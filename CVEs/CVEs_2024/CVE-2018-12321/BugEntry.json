{"buggy_code": ["/* radare - Apache 2.0 - Copyright 2010-2015 - pancake and\n Adam Pridgen <dso@rice.edu || adam.pridgen@thecoverofnight.com> */\n\n#include <string.h>\n\n#include <r_types.h>\n#include <r_lib.h>\n#include <r_asm.h>\n#include <r_anal.h>\n#include <r_anal_ex.h>\n#include <r_cons.h>\n\n#include \"../../../shlr/java/code.h\"\n#include \"../../../shlr/java/class.h\"\n\n#ifdef IFDBG\n#define dprintf eprintf\n#endif\n\n#define DO_THE_DBG 0\n#define IFDBG  if(DO_THE_DBG)\n#define IFINT  if(0)\n\nstruct r_anal_java_access_t;\n\ntypedef struct r_anal_java_access_t {\n\tchar *method;\n\tut64 addr;\n\tut64 value;\n\tut64 op_type;\n\tstruct r_anal_java_access_t *next;\n\tstruct r_anal_java_access_t *previous;\n} RAnalJavaAccess;\n\ntypedef struct r_anal_java_local_var_t {\n\tchar *name;\n\tchar *type;\n\tRList *writes;\n\tRList *reads;\n\tRList *binops;\n} RAnalJavaLocalVar;\n\ntypedef struct r_anal_ex_java_lin_sweep {\n\tRList *cfg_node_addrs;\n}RAnalJavaLinearSweep;\n\nut64 METHOD_START = 0;\n\n// XXX - TODO add code in the java_op that is aware of when it is in a\n// switch statement, like in the shlr/java/code.c so that this does not \n// report bad blocks.  currently is should be easy to ignore these blocks,\n// in output for the pdj\n\n//static int java_print_ssa_bb (RAnal *anal, char *addr);\nstatic int java_reset_counter (RAnal *anal, ut64 addr);\nstatic int java_new_method (ut64 addr);\nstatic void java_update_anal_types (RAnal *anal, RBinJavaObj *bin_obj);\nstatic void java_set_function_prototype (RAnal *anal, RAnalFunction *fcn, RBinJavaField *method);\n\nstatic int java_cmd_ext(RAnal *anal, const char* input);\nstatic int analyze_from_code_buffer (RAnal *anal, RAnalFunction *fcn, ut64 addr, const ut8 *code_buf, ut64 code_length);\nstatic int analyze_from_code_attr (RAnal *anal, RAnalFunction *fcn, RBinJavaField *method, ut64 loadaddr);\nstatic int analyze_method(RAnal *anal, RAnalFunction *fcn, RAnalState *state);\n\nstatic int java_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len);\n//static int java_bb(RAnal *anal, RAnalFunction *fcn, ut64 addr, ut8 *buf, ut64 len, int reftype);\n//static int java_fn(RAnal *anal, RAnalFunction *fcn, ut64 addr, ut8 *buf, ut64 len, int reftype);\n\nstatic int java_recursive_descent(RAnal *anal, RAnalState *state, ut64 addr);\nstatic int handle_bb_cf_recursive_descent (RAnal *anal, RAnalState *state);\n\nstatic int java_linear_sweep(RAnal *anal, RAnalState *state, ut64 addr);\nstatic int handle_bb_cf_linear_sweep (RAnal *anal, RAnalState *state);\nstatic int java_post_anal_linear_sweep(RAnal *anal, RAnalState *state, ut64 addr);\nstatic RBinJavaObj * get_java_bin_obj(RAnal *anal);\nstatic RList * get_java_bin_obj_list(RAnal *anal);\n\nstatic int java_analyze_fns( RAnal *anal, ut64 start, ut64 end, int reftype, int depth);\n\n//static RAnalOp * java_op_from_buffer(RAnal *anal, RAnalState *state, ut64 addr);\n//static RAnalBlock * java_bb_from_buffer(RAnal *anal, RAnalState *state, ut64 addr);\n//static RAnalFunction * java_fn_from_buffer(RAnal *anal, RAnalState *state, ut64 addr);\n\nstatic int check_addr_in_code (RBinJavaField *method, ut64 addr);\nstatic int check_addr_less_end (RBinJavaField *method, ut64 addr);\nstatic int check_addr_less_start (RBinJavaField *method, ut64 addr);\n\nstatic int java_revisit_bb_anal_recursive_descent(RAnal *anal, RAnalState *state, ut64 addr);\n\nstatic RBinJavaObj * get_java_bin_obj(RAnal *anal) {\n\tRBin *b = anal->binb.bin;\n\tRBinPlugin *plugin = b->cur && b->cur->o ? b->cur->o->plugin : NULL;\n\tut8 is_java = (plugin && strcmp (plugin->name, \"java\") == 0) ? 1 : 0;\n\treturn is_java ? b->cur->o->bin_obj : NULL;\n}\n\nstatic RList * get_java_bin_obj_list(RAnal *anal) {\n\tRBinJavaObj *bin_obj = (RBinJavaObj * )get_java_bin_obj(anal);\n\t// See libr/bin/p/bin_java.c to see what is happening here.  The original intention\n\t// was to use a shared global db variable from shlr/java/class.c, but the\n\t// BIN_OBJS_ADDRS variable kept getting corrupted on Mac, so I (deeso) switched the\n\t// way the access to the db was taking place by using the bin_obj as a proxy back\n\t// to the BIN_OBJS_ADDRS which is instantiated in libr/bin/p/bin_java.c\n\t// not the easiest way to make sausage, but its getting made.\n\treturn  r_bin_java_get_bin_obj_list_thru_obj (bin_obj);\n}\n\nstatic int check_addr_less_end (RBinJavaField *method, ut64 addr) {\n\tut64 end = r_bin_java_get_method_code_size (method);\n\treturn (addr < end);\n}\n\nstatic int check_addr_in_code (RBinJavaField *method, ut64 addr) {\n\treturn !check_addr_less_start (method, addr) && \\\n\t\tcheck_addr_less_end ( method, addr);\n}\n\nstatic int check_addr_less_start (RBinJavaField *method, ut64 addr) {\n\tut64 start = r_bin_java_get_method_code_offset (method);\n\treturn (addr < start);\n}\n\n\nstatic int java_new_method (ut64 method_start) {\n\tMETHOD_START = method_start;\n\t// reset the current bytes consumed counter\n\tr_java_new_method ();\n\treturn 0;\n}\n\nstatic ut64 java_get_method_start () {\n\treturn METHOD_START;\n}\n\nstatic int java_revisit_bb_anal_recursive_descent(RAnal *anal, RAnalState *state, ut64 addr) {\n\tRAnalBlock *current_head = state && state->current_bb_head ? state->current_bb_head : NULL;\n\tif (current_head && state->current_bb &&\n\t\tstate->current_bb->type & R_ANAL_BB_TYPE_TAIL) {\n\t\tr_anal_ex_update_bb_cfg_head_tail (current_head, current_head, state->current_bb);\n\t\t// XXX should i do this instead -> r_anal_ex_perform_post_anal_bb_cb (anal, state, addr+offset);\n\t\tstate->done = 1;\n\t}\n\treturn R_ANAL_RET_END;\n}\n\nstatic int java_recursive_descent(RAnal *anal, RAnalState *state, ut64 addr) {\n\tRAnalBlock *bb;\n\tRAnalBlock *current_head;\n\n\tif (!anal || !state || !state->current_bb || state->current_bb_head)\n\t\treturn 0;\n\n\tbb = state->current_bb;\n\tcurrent_head = state->current_bb_head;\n\n\tif (current_head && state->current_bb->type & R_ANAL_BB_TYPE_TAIL) {\n\t\tr_anal_ex_update_bb_cfg_head_tail (current_head, current_head, state->current_bb);\n\t}\n\n\t// basic filter for handling the different type of operations\n\t// depending on flags some may be called more than once\n\t// if (bb->type2 & R_ANAL_EX_ILL_OP)   handle_bb_ill_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_COND_OP)  handle_bb_cond_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_UNK_OP)   handle_bb_unknown_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_NULL_OP)  handle_bb_null_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_NOP_OP)   handle_bb_nop_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_REP_OP)   handle_bb_rep_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_STORE_OP) handle_bb_store_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_LOAD_OP)  handle_bb_load_op (anal, state\n\t// if (bb->type2 & R_ANAL_EX_REG_OP)   handle_bb_reg_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_OBJ_OP)   handle_bb_obj_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_STACK_OP) handle_bb_stack_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_BIN_OP)   handle_bb_bin_op (anal, state);\n\tif (bb->type2 & R_ANAL_EX_CODE_OP)  handle_bb_cf_recursive_descent (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_DATA_OP)  handle_bb_data_op (anal, state);\n\treturn 0;\n}\n\nstatic int java_linear_sweep(RAnal *anal, RAnalState *state, ut64 addr) {\n\tRAnalBlock *bb = state->current_bb;\n\tif (state->current_bb_head && state->current_bb->type & R_ANAL_BB_TYPE_TAIL) {\n\t\t//r_anal_ex_update_bb_cfg_head_tail (state->current_bb_head, state->current_bb_head, state->current_bb);\n\t}\n\n\t// basic filter for handling the different type of operations\n\t// depending on flags some may be called more than once\n\t// if (bb->type2 & R_ANAL_EX_ILL_OP)   handle_bb_ill_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_COND_OP)  handle_bb_cond_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_UNK_OP)   handle_bb_unknown_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_NULL_OP)  handle_bb_null_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_NOP_OP)   handle_bb_nop_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_REP_OP)   handle_bb_rep_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_STORE_OP) handle_bb_store_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_LOAD_OP)  handle_bb_load_op (anal, state\n\t// if (bb->type2 & R_ANAL_EX_REG_OP)   handle_bb_reg_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_OBJ_OP)   handle_bb_obj_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_STACK_OP) handle_bb_stack_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_BIN_OP)   handle_bb_bin_op (anal, state);\n\tif (bb->type2 & R_ANAL_EX_CODE_OP)  handle_bb_cf_linear_sweep (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_DATA_OP)  handle_bb_data_op (anal, state);\n\treturn 0;\n}\n\nstatic int handle_bb_cf_recursive_descent (RAnal *anal, RAnalState *state) {\n\n\tRAnalBlock *bb = state->current_bb;\n\n\tut64 addr = 0;\n\tint result = 0;\n\tif (!bb) {\n\t\teprintf (\"Error: unable to handle basic block @ 0x%08\"PFMT64x\"\\n\", addr);\n\t\treturn R_ANAL_RET_ERROR;\n\t} else if (state->max_depth <= state->current_depth) {\n\t\treturn R_ANAL_RET_ERROR;\n\t}\n\n\tstate->current_depth++;\n\taddr = bb->addr;\n\tIFDBG eprintf (\"Handling a control flow change @ 0x%04\"PFMT64x\".\\n\", addr);\n\tut64 control_type = r_anal_ex_map_anal_ex_to_anal_op_type (bb->type2);\n\n\t// XXX - transition to type2 control flow condtions\n\tswitch (control_type) {\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\tIFDBG eprintf (\" - Handling a call @ 0x%04\"PFMT64x\".\\n\", addr);\n\t\t\tr_anal_xrefs_set (anal, bb->addr, bb->jump, R_ANAL_REF_TYPE_CALL);\n\t\t\tresult = R_ANAL_RET_ERROR;\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\t{\n\t\t\t\tRList * jmp_list;\n\t\t\t\tIFDBG eprintf (\" - Handling a jmp @ 0x%04\"PFMT64x\" to 0x%04\"PFMT64x\".\\n\", addr, bb->jump);\n\n\t\t\t\t// visited some other time\n\t\t\t\tif (!r_anal_state_search_bb (state, bb->jump)) {\n\t\t\t\t\tjmp_list = r_anal_ex_perform_analysis ( anal, state, bb->jump );\n\t\t\t\t\tif (jmp_list)\n\t\t\t\t\t\tbb->jumpbb = (RAnalBlock *) r_list_get_n (jmp_list, 0);\n\t\t\t\t\tif (bb->jumpbb)\n\t\t\t\t\t\tbb->jump = bb->jumpbb->addr;\n\t\t\t\t} else {\n\t\t\t\t\tbb->jumpbb = r_anal_state_search_bb (state, bb->jump);\n\t\t\t\t\tif (bb->jumpbb)\n\t\t\t\t\t\tbb->jump = bb->jumpbb->addr;\n\t\t\t\t}\n\n\t\t\t\tif (state->done == 1) {\n\t\t\t\t\tIFDBG eprintf (\" Looks like this jmp (bb @ 0x%04\"PFMT64x\") found a return.\\n\", addr);\n\t\t\t\t}\n\t\t\t\tresult = R_ANAL_RET_END;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\t{\n\t\t\t\tRList *jmp_list;\n\t\t\t\tut8 encountered_stop = 0;\n\t\t\t\tIFDBG eprintf (\" - Handling a cjmp @ 0x%04\"PFMT64x\" jmp to 0x%04\"PFMT64x\" and fail to 0x%04\"PFMT64x\".\\n\", addr, bb->jump, bb->fail);\n\t\t\t\tIFDBG eprintf (\" - Handling jmp to 0x%04\"PFMT64x\".\\n\", bb->jump);\n\t\t\t\t// visited some other time\n\t\t\t\tif (!r_anal_state_search_bb (state, bb->jump)) {\n\t\t\t\t\tjmp_list = r_anal_ex_perform_analysis ( anal, state, bb->jump );\n\t\t\t\t\tif (jmp_list)\n\t\t\t\t\t\tbb->jumpbb = (RAnalBlock *) r_list_get_n (jmp_list, 0);\n\t\t\t\t\tif (bb->jumpbb) {\n\t\t\t\t\t\tbb->jump = bb->jumpbb->addr;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbb->jumpbb = r_anal_state_search_bb (state, bb->jump);\n\t\t\t\t\tbb->jump = bb->jumpbb->addr;\n\t\t\t\t}\n\n\t\t\t\tif (state->done == 1) {\n\t\t\t\t\tIFDBG eprintf (\" Looks like this jmp (bb @ 0x%04\"PFMT64x\") found a return.\\n\", addr);\n\t\t\t\t\tstate->done = 0;\n\t\t\t\t\tencountered_stop = 1;\n\t\t\t\t}\n\n\t\t\t\tif (!r_anal_state_search_bb (state, bb->fail)) {\n\t\t\t\t\tjmp_list = r_anal_ex_perform_analysis ( anal, state, bb->fail );\n\t\t\t\t\tif (jmp_list)\n\t\t\t\t\t\tbb->failbb = (RAnalBlock *) r_list_get_n (jmp_list, 0);\n\t\t\t\t\tif (bb->failbb) {\n\t\t\t\t\t\tbb->fail = bb->failbb->addr;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbb->failbb = r_anal_state_search_bb (state, bb->fail);\n\t\t\t\t\tif (bb->failbb) {\n\t\t\t\t\t\tbb->fail = bb->failbb->addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tIFDBG eprintf (\" - Handling an cjmp @ 0x%04\"PFMT64x\" jmp to 0x%04\"PFMT64x\" and fail to 0x%04\"PFMT64x\".\\n\", addr, bb->jump, bb->fail);\n\t\t\t\tIFDBG eprintf (\" - Handling fail to 0x%04\"PFMT64x\".\\n\", bb->fail);\n\t\t\t\t// r_anal_state_merge_bb_list (state, fail_list);\n\t\t\t\tif (state->done == 1) {\n\t\t\t\t\tIFDBG eprintf (\" Looks like this fail (bb @ 0x%04\"PFMT64x\") found a return.\\n\", addr);\n\t\t\t\t}\n\n\t\t\t\tresult = R_ANAL_RET_END;\n\t\t\t\tif (encountered_stop) state->done = 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase R_ANAL_OP_TYPE_SWITCH:\n\t\t{\n\t\t\tIFDBG eprintf (\" - Handling an switch @ 0x%04\"PFMT64x\".\\n\", addr);\n\t\t\tif (bb->switch_op) {\n\t\t\t\tRAnalCaseOp *caseop;\n\t\t\t\tRListIter *iter;\n\t\t\t\tRList *jmp_list = NULL;\n\t\t\t\tut8 encountered_stop = 0;\n\t\t\t\tr_list_foreach (bb->switch_op->cases, iter, caseop) {\n\t\t\t\t\tif (caseop) {\n\t\t\t\t\t\tif (r_anal_state_addr_is_valid (state, caseop->jump) ) {\n\t\t\t\t\t\t\tjmp_list = r_anal_ex_perform_analysis ( anal, state, caseop->jump );\n\t\t\t\t\t\t\tif (jmp_list)\n\t\t\t\t\t\t\t\tcaseop->jumpbb = (RAnalBlock *) r_list_get_n (jmp_list, 0);\n\t\t\t\t\t\t\tif (state->done == 1) {\n\t\t\t\t\t\t\t\tIFDBG eprintf (\" Looks like this jmp (bb @ 0x%04\"PFMT64x\") found a return.\\n\", addr);\n\t\t\t\t\t\t\t\tstate->done = 0;\n\t\t\t\t\t\t\t\tencountered_stop = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_list_free (jmp_list);\n\t\t\t\tif (encountered_stop) state->done = 1;\n\t\t\t}\n\n\t\t\tresult = R_ANAL_RET_END;\n\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\tcase R_ANAL_OP_TYPE_IJMP:\n\t\tcase R_ANAL_OP_TYPE_RJMP:\n\t\tcase R_ANAL_OP_TYPE_IRJMP:\n\t\tcase R_ANAL_OP_TYPE_RET:\n\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\t\tIFDBG eprintf (\" - Handling an ret @ 0x%04\"PFMT64x\".\\n\", addr);\n\t\t\tstate->done = 1;\n\t\t\tresult = R_ANAL_RET_END;\n\t\t\tbreak;\n\t\tdefault: break;\n\t}\n\n\tstate->current_depth--;\n\treturn result;\n}\n\nstatic int java_post_anal_linear_sweep(RAnal *anal, RAnalState *state, ut64 addr) {\n\tRAnalJavaLinearSweep *nodes = state->user_state;\n\tRList *jmp_list = NULL;\n\tut64 *paddr64;\n\n\tstate->done = 0;\n\tif (!nodes || !nodes->cfg_node_addrs) {\n\t\tstate->done = 1;\n\t\treturn R_ANAL_RET_ERROR;\n\t}\n\n\twhile (r_list_length (nodes->cfg_node_addrs) > 0) {\n\t\tpaddr64 = r_list_get_n (nodes->cfg_node_addrs, 0);\n\t\tr_list_del_n (nodes->cfg_node_addrs, 0);\n\t\tif (paddr64 && !r_anal_state_search_bb (state, *paddr64)) {\n\t\t\tut64 list_length = 0;\n\t\t\tIFDBG eprintf (\" - Visiting 0x%04\"PFMT64x\" for analysis.\\n\", *paddr64);\n\t\t\tjmp_list = r_anal_ex_perform_analysis ( anal, state, *paddr64 );\n\t\t\tlist_length = r_list_length (jmp_list);\n\t\t\tr_list_free (jmp_list);\n\t\t\tif ( list_length > 0) {\n\t\t\t\tIFDBG eprintf (\" - Found %\"PFMT64d\" more basic blocks missed on the initial pass.\\n\", *paddr64);\n\t\t\t}\n\t\t}\n\n\t}\n\treturn R_ANAL_RET_END;\n}\n\n\nstatic int handle_bb_cf_linear_sweep (RAnal *anal, RAnalState *state) {\n\tut64 * paddr64;\n\tRAnalBlock *bb = state->current_bb;\n\tRAnalJavaLinearSweep *nodes = state->user_state;\n\n\tif (!nodes || !nodes->cfg_node_addrs) {\n\t\tstate->done = 1;\n\t\treturn R_ANAL_RET_ERROR;\n\t}\n\n\tut64 addr = 0;\n\tint result = 0;\n\tif (!bb) {\n\t\teprintf (\"Error: unable to handle basic block @ 0x%08\"PFMT64x\"\\n\", addr);\n\t\treturn R_ANAL_RET_ERROR;\n\t} else if (state->max_depth <= state->current_depth) {\n\t\treturn R_ANAL_RET_ERROR;\n\t}\n\n\tstate->current_depth++;\n\taddr = bb->addr;\n\tIFDBG eprintf (\"Handling a control flow change @ 0x%04\"PFMT64x\".\\n\", addr);\n\tut32 control_type = r_anal_ex_map_anal_ex_to_anal_op_type (bb->type2);\n\n\t// XXX - transition to type2 control flow condtions\n\tswitch (control_type) {\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\tIFDBG eprintf (\" - Handling a call @ 0x%04\"PFMT64x\"\\n\", addr);\n\t\t\tr_anal_xrefs_set (anal, bb->addr, bb->jump, R_ANAL_REF_TYPE_CALL);\n\t\t\tresult = R_ANAL_RET_ERROR;\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tpaddr64 = malloc (sizeof(ut64));\n\t\t\t*paddr64 = bb->jump;\n\t\t\tIFDBG eprintf (\" - Handling a jmp @ 0x%04\"PFMT64x\", adding for future visit\\n\", addr);\n\t\t\tr_list_append (nodes->cfg_node_addrs, paddr64);\n\t\t\tresult = R_ANAL_RET_END;\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\tpaddr64 = malloc (sizeof(ut64));\n\t\t\t*paddr64 = bb->jump;\n\t\t\tIFDBG eprintf (\" - Handling a bb->jump @ 0x%04\"PFMT64x\", adding 0x%04\"PFMT64x\" for future visit\\n\", addr, *paddr64);\n\t\t\tr_list_append (nodes->cfg_node_addrs, paddr64);\n\t\t\tpaddr64 = malloc (sizeof(ut64));\n\t\t\tif (paddr64) {\n\t\t\t\t*paddr64 = bb->fail;\n\t\t\t\tIFDBG eprintf (\" - Handling a bb->fail @ 0x%04\"PFMT64x\", adding 0x%04\"PFMT64x\" for future visit\\n\", addr, *paddr64);\n\t\t\t\tr_list_append (nodes->cfg_node_addrs, paddr64);\n\t\t\t}\n\t\t\tresult = R_ANAL_RET_END;\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_SWITCH:\n\t\t\tif (bb->switch_op) {\n\t\t\t\tRAnalCaseOp *caseop;\n\t\t\t\tRListIter *iter;\n\t\t\t\t//RList *jmp_list = NULL;\n\t\t\t\tIFDBG eprintf (\" - Handling a switch_op @ 0x%04\"PFMT64x\":\\n\", addr);\n\t\t\t\tr_list_foreach (bb->switch_op->cases, iter, caseop) {\n\t\t\t\t\tut64 * paddr64;\n\t\t\t\t\tif (caseop) {\n\t\t\t\t\t\tpaddr64 = malloc (sizeof(ut64));\n\t\t\t\t\t\t*paddr64 = caseop->jump;\n\t\t\t\t\t\tIFDBG eprintf (\"Adding 0x%04\"PFMT64x\" for future visit\\n\", *paddr64);\n\t\t\t\t\t\tr_list_append (nodes->cfg_node_addrs, paddr64);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult = R_ANAL_RET_END;\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\tcase R_ANAL_OP_TYPE_RJMP:\n\t\tcase R_ANAL_OP_TYPE_IJMP:\n\t\tcase R_ANAL_OP_TYPE_IRJMP:\n\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tIFDBG eprintf (\" - Handling an ret @ 0x%04\"PFMT64x\".\\n\", addr);\n\t\t\tstate->done = 1;\n\t\t\tresult = R_ANAL_RET_END;\n\t\t\tbreak;\n\t\tdefault: break;\n\t}\n\n\tstate->current_depth--;\n\treturn result;\n}\n\n\n//many flaws UAF\nstatic int analyze_from_code_buffer(RAnal *anal, RAnalFunction *fcn, ut64 addr, const ut8 *code_buf, ut64 code_length) {\n\tchar gen_name[1025];\n\tRListIter *bb_iter;\n\tRAnalBlock *bb;\n\tut64 actual_size = 0;\n\tRAnalState *state = NULL;\n\tint result = R_ANAL_RET_ERROR;\n\tRAnalJavaLinearSweep *nodes;\n\n\tfree (fcn->name);\n\tfree (fcn->dsc);\n\tsnprintf (gen_name, 1024, \"sym.%08\"PFMT64x\"\", addr);\n\n\tfcn->name = strdup (gen_name);\n\tfcn->dsc = strdup (\"unknown\");\n\tr_anal_fcn_set_size (NULL, fcn, code_length);\n\tfcn->type = R_ANAL_FCN_TYPE_FCN;\n\tfcn->addr = addr;\n\tstate = r_anal_state_new (addr, (ut8*) code_buf, code_length);\n\tnodes = R_NEW0 (RAnalJavaLinearSweep);\n\tnodes->cfg_node_addrs = r_list_new ();\n\tnodes->cfg_node_addrs->free = free;\n\tstate->user_state = nodes;\n\tresult = analyze_method (anal, fcn, state);\n\tr_list_foreach (fcn->bbs, bb_iter, bb) {\n\t\tactual_size += bb->size;\n\t}\n\tr_anal_fcn_set_size (NULL, fcn, state->bytes_consumed);\n\tresult = state->anal_ret_val;\n\tr_list_free (nodes->cfg_node_addrs);\n\tfree (nodes);\n\t//leak to avoid UAF is the easy solution otherwise a whole rewrite is needed\n\t//r_anal_state_free (state);\n\tif (r_anal_fcn_size (fcn) != code_length) {\n\t\treturn R_ANAL_RET_ERROR;\n#if 0\n\t\teprintf (\"WARNING Analysis of %s Incorrect: Code Length: 0x%\"PFMT64x\", Function size reported 0x%x\\n\", fcn->name, code_length, r_anal_fcn_size(fcn));\n\t\teprintf (\"Deadcode detected, setting code length to: 0x%\"PFMT64x\"\\n\", code_length);\n\t\tr_anal_fcn_set_size (fcn, code_length);\n#endif\n\t}\n\treturn result;\n}\n\nstatic int analyze_from_code_attr (RAnal *anal, RAnalFunction *fcn, RBinJavaField *method, ut64 loadaddr) {\n\tRBinJavaAttrInfo* code_attr = method ? r_bin_java_get_method_code_attribute(method) : NULL;\n\tut8 * code_buf = NULL;\n\tint result = false;\n\tut64 code_length = 0;\n\tut64 code_addr = -1;\n\n\tif (!code_attr) {\n\t\tfcn->name = strdup (\"sym.UNKNOWN\");\n\t\tfcn->dsc = strdup (\"unknown\");\n\t\tr_anal_fcn_set_size (NULL, fcn, code_length);\n\t\tfcn->type = R_ANAL_FCN_TYPE_FCN;\n\t\tfcn->addr = 0;\n\t\treturn R_ANAL_RET_ERROR;\n\t}\n\n\tcode_length = code_attr->info.code_attr.code_length;\n\tcode_addr = code_attr->info.code_attr.code_offset;\n\tcode_buf = calloc (1, code_length);\n\n\tanal->iob.read_at (anal->iob.io, code_addr + loadaddr, code_buf, code_length);\n\tresult = analyze_from_code_buffer (anal, fcn, code_addr + loadaddr, code_buf, code_length);\n\tfree (code_buf);\n\n\tchar *name = strdup (method->name);\n\tif (name) {\n\t\tr_name_filter (name, 80);\n\t\tfree (fcn->name);\n\t\tif (method->class_name) {\n\t\t\tchar *cname = strdup (method->class_name);\n\t\t\tr_name_filter (cname, 50);\n\t\t\tfcn->name = r_str_newf (\"sym.%s.%s\", cname, name);\n\t\t\tfree (cname);\n\t\t} else {\n\t\t\tfcn->name = r_str_newf (\"sym.%s\", name);\n\t\t}\n\t\tfree (name);\n\t}\n\n\tfree (fcn->dsc);\n\tfcn->dsc = strdup (method->descriptor);\n\tIFDBG eprintf (\"Completed analysing code from attr, name: %s, desc: %s\", fcn->name, fcn->dsc);\n\n\treturn result;\n}\n\nstatic int analyze_method(RAnal *anal, RAnalFunction *fcn, RAnalState *state) {\n\t// deallocate niceties\n\tr_list_free (fcn->bbs);\n\tfcn->bbs = r_anal_bb_list_new ();\n\tjava_new_method (fcn->addr);\n\tstate->current_fcn = fcn;\n\t// Not a resource leak.  Basic blocks should be stored in the state->fcn\n\t// TODO: ? RList *bbs = \n\tr_anal_ex_perform_analysis (anal, state, fcn->addr);\n\treturn state->anal_ret_val;\n}\n\nstatic int java_analyze_fns_from_buffer( RAnal *anal, ut64 start, ut64 end, int reftype, int depth) {\n\tint result = R_ANAL_RET_ERROR;\n\tut64 addr = start;\n\tut64 offset = 0;\n\tut64 buf_len = end - start;\n\tut8 analyze_all = 0,\n\t\t*buffer = NULL;\n\n\tif (end == UT64_MAX) {\n\t\t//analyze_all = 1;\n\t\tbuf_len = anal->iob.desc_size (anal->iob.io->desc);\n\n\t\tif (buf_len == UT64_MAX) buf_len = 1024;\n\n\t\tend = start + buf_len;\n\t}\n\n\tbuffer = malloc (buf_len);\n\tif (!buffer) {\n\t\treturn R_ANAL_RET_ERROR;\n\t}\n\n\tanal->iob.read_at (anal->iob.io, addr, buffer, buf_len);\n\n\twhile (offset < buf_len) {\n\t\tut64 length = buf_len - offset;\n\n\t\tRAnalFunction *fcn = r_anal_fcn_new ();\n\t\tfcn->cc = r_str_const (r_anal_cc_default (anal));\n\t\tresult = analyze_from_code_buffer ( anal, fcn, addr, buffer+offset, length );\n\t\tif (result == R_ANAL_RET_ERROR) {\n\t\t\teprintf (\"Failed to parse java fn: %s @ 0x%04\"PFMT64x\"\\n\", fcn->name, fcn->addr);\n\t\t\t// XXX - TO Stop or not to Stop ??\n\t\t\tbreak;\n\t\t}\n\t\t//r_listrange_add (anal->fcnstore, fcn);\n\t\tr_anal_fcn_tree_insert (&anal->fcn_tree, fcn);\n\t\tr_list_append (anal->fcns, fcn);\n\t\toffset += r_anal_fcn_size (fcn);\n\t\tif (!analyze_all) break;\n\t}\n\tfree (buffer);\n\treturn result;\n}\n\nstatic int java_analyze_fns( RAnal *anal, ut64 start, ut64 end, int reftype, int depth) {\n\t//anal->iob.read_at (anal->iob.io, op.jump, bbuf, sizeof (bbuf));\n\tRBinJavaObj *bin = NULL;// = get_java_bin_obj (anal);\n\tRBinJavaField *method = NULL;\n\tRListIter *methods_iter, *bin_obs_iter;\n\tRList * bin_objs_list = get_java_bin_obj_list (anal);\n\n\tut8 analyze_all = 0;\n\t//RAnalRef *ref = NULL;\n\tint result = R_ANAL_RET_ERROR;\n\n\tif (end == UT64_MAX) {\n\t\tanalyze_all = 1;\n\t}\n\tif (!bin_objs_list || r_list_empty (bin_objs_list)) {\n\t\tr_list_free (bin_objs_list);\n\t\treturn java_analyze_fns_from_buffer (anal, start, end, reftype, depth);\n\t}\n\tr_list_foreach (bin_objs_list, bin_obs_iter, bin) {\n\t\t// loop over all bin object that are loaded\n\t\tjava_update_anal_types (anal, bin);\n\t\tRList *methods_list = (RList *) r_bin_java_get_methods_list (bin);\n\t\tut64 loadaddr = bin->loadaddr;\n\t\t// loop over all methods in the binary object and analyse\n\t\t// the functions\n\t\tr_list_foreach (methods_list, methods_iter, method) {\n\t\t\tif ((method && analyze_all) ||\n\t\t\t    (check_addr_less_start (method, end) ||\n\t\t\t     check_addr_in_code (method, end))) {\n\t\t\t\tRAnalFunction *fcn = r_anal_fcn_new ();\n\t\t\t\tfcn->cc = r_str_const (r_anal_cc_default (anal));\n\t\t\t\tjava_set_function_prototype (anal, fcn, method);\n\t\t\t\tresult = analyze_from_code_attr (anal, fcn, method, loadaddr);\n\t\t\t\tif (result == R_ANAL_RET_ERROR) {\n\t\t\t\t\t//eprintf (\"Failed to parse java fn: %s @ 0x%04\"PFMT64x\"\\n\", fcn->name, fcn->addr);\n\t\t\t\t\treturn result;\n\t\t\t\t\t// XXX - TO Stop or not to Stop ??\n\t\t\t\t}\n\t\t\t\t//r_listrange_add (anal->fcnstore, fcn);\n\t\t\t\tr_anal_fcn_update_tinyrange_bbs (fcn);\n\t\t\t\tr_anal_fcn_tree_insert (&anal->fcn_tree, fcn);\n\t\t\t\tr_list_append (anal->fcns, fcn);\n\t\t\t}\n\t\t} // End of methods loop\n\t}// end of bin_objs list loop\n\treturn result;\n}\n\n/*static int java_fn(RAnal *anal, RAnalFunction *fcn, ut64 addr, ut8 *buf, ut64 len, int reftype) {\n\t// XXX - this may clash with malloc:// uris because the file name is\n\t// malloc:// **\n\tRBinJavaObj *bin = (RBinJavaObj *) get_java_bin_obj (anal);\n\tRBinJavaField *method = bin ? r_bin_java_get_method_code_attribute_with_addr (bin,  addr) : NULL;\n\tut64 loadaddr = bin ? bin->loadaddr : 0;\n\tIFDBG eprintf (\"Analyzing java functions for %s\\n\", anal->iob.io->fd->name);\n\tif (method) return analyze_from_code_attr (anal, fcn, method, loadaddr);\n\treturn analyze_from_code_buffer (anal, fcn, addr, buf, len);\n}*/\n\nstatic int java_switch_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tut8 op_byte = data[0];\n\tut64 offset = addr - java_get_method_start ();\n\tut8 pos = (offset+1)%4 ? 1 + 4 - (offset+1)%4 : 1;\n\n\tif (op_byte == 0xaa) {\n\t\t// handle a table switch condition\n\t\tif (pos + 8 > len) {\n\t\t\treturn op->size;\n\t\t}\n\t\tint min_val = (ut32)(UINT (data, pos + 4)),\n\t\t\tmax_val = (ut32)(UINT (data, pos + 8));\n\n\t\tut32 default_loc = (ut32) (UINT (data, pos)), cur_case = 0;\n\t\top->switch_op = r_anal_switch_op_new (addr, min_val, default_loc);\n\t\tRAnalCaseOp *caseop = NULL;\n\t\tpos += 12;\n\t\tif (max_val > min_val && ((max_val - min_val)<(UT16_MAX/4))) {\n\t\t\t//caseop = r_anal_switch_op_add_case(op->switch_op, addr+default_loc, -1, addr+offset);\n\t\t\tfor (cur_case = 0; cur_case <= max_val - min_val; pos += 4, cur_case++) {\n\t\t\t\t//ut32 value = (ut32)(UINT (data, pos));\n\t\t\t\tif (pos + 4 >= len) {\n\t\t\t\t\t// switch is too big cant read further\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint offset = (int)(ut32)(R_BIN_JAVA_UINT (data, pos));\n\t\t\t\tcaseop = r_anal_switch_op_add_case (op->switch_op,\n\t\t\t\t\taddr + pos, cur_case + min_val, addr + offset);\n\t\t\t\tif (caseop) {\n\t\t\t\t\tcaseop->bb_ref_to = addr+offset;\n\t\t\t\t\tcaseop->bb_ref_from = addr; // TODO figure this one out\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Invalid switch boundaries at 0x%\"PFMT64x\"\\n\", addr);\n\t\t}\n\t}\n\top->size = pos;\n\treturn op->size;\n}\n\nstatic int java_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\t/* get opcode size */\n\t//ut8 op_byte = data[0];\n\tut8 op_byte = data[0];\n\tint sz = JAVA_OPS[op_byte].size;\n\tif (!op) {\n\t\treturn sz;\n\t}\n\tmemset (op, '\\0', sizeof (RAnalOp));\n\tIFDBG {\n\t\t//eprintf (\"Extracting op from buffer (%d byte(s)) @ 0x%04x\\n\", len, addr);\n\t\t//eprintf (\"Parsing op: (0x%02x) %s.\\n\", op_byte, JAVA_OPS[op_byte].name);\n\t}\n\top->addr = addr;\n\top->size = sz;\n\top->id = data[0];\n\top->type2 = JAVA_OPS[op_byte].op_type;\n\top->type = r_anal_ex_map_anal_ex_to_anal_op_type (op->type2);\n\t// handle lookup and table switch offsets\n\tif (op_byte == 0xaa || op_byte == 0xab) {\n\t\tjava_switch_op (anal, op, addr, data, len);\n\t\t// IN_SWITCH_OP = 1;\n\t}\n\t/* TODO: \n\t// not sure how to handle the states for IN_SWITCH_OP, SWITCH_OP_CASES,\n\t// and NUM_CASES_SEEN, because these are dependent on whether or not we\n\t// are in a switch, and given the non-reentrant state of opcode analysis\n\t// this can't always be guaranteed.  Below is the pseudo code for handling\n\t// the easy parts though\n\tif (IN_SWITCH_OP) {\n\t\tNUM_CASES_SEEN++;\n\t\tif (NUM_CASES_SEEN == SWITCH_OP_CASES) IN_SWITCH_OP=0;\n\t\top->addr = addr;\n\t\top->size = 4;\n\t\top->type2 = 0;\n\t\top->type = R_ANAL_OP_TYPE_CASE\n\t\top->eob = 0;\n\t\treturn op->sizes;\n\t}\n\t*/\n\n\top->eob = r_anal_ex_is_op_type_eop (op->type2);\n\tIFDBG {\n\t\tconst char *ot_str = r_anal_optype_to_string (op->type);\n\t\teprintf (\"op_type2: %s @ 0x%04\"PFMT64x\" 0x%08\"PFMT64x\" op_type: (0x%02\"PFMT64x\") %s.\\n\",\n\t\t\tJAVA_OPS[op_byte].name, addr, (ut64)op->type2, (ut64)op->type,  ot_str);\n\t\t//eprintf (\"op_eob: 0x%02x.\\n\", op->eob);\n\t\t//eprintf (\"op_byte @ 0: 0x%02x op_byte @ 0x%04x: 0x%02x.\\n\", data[0], addr, data[addr]);\n\t}\n\n\tif (len < 4) {\n\t\t// incomplete analysis here\n\t\treturn 0;\n\t}\n\tif (op->type == R_ANAL_OP_TYPE_CJMP) {\n\t\top->jump = addr + (short)(USHORT (data, 1));\n\t\top->fail = addr + sz;\n\t\tIFDBG eprintf (\"%s jmpto 0x%04\"PFMT64x\"  failto 0x%04\"PFMT64x\".\\n\",\n\t\t\tJAVA_OPS[op_byte].name, op->jump, op->fail);\n\t} else if (op->type  == R_ANAL_OP_TYPE_JMP) {\n\t\top->jump = addr + (short)(USHORT (data, 1));\n\t\tIFDBG eprintf (\"%s jmpto 0x%04\"PFMT64x\".\\n\", JAVA_OPS[op_byte].name, op->jump);\n\t} else if ( (op->type & R_ANAL_OP_TYPE_CALL) == R_ANAL_OP_TYPE_CALL ) {\n\t\top->jump = (int)(short)(USHORT (data, 1));\n\t\top->fail = addr + sz;\n\t\t//IFDBG eprintf (\"%s callto 0x%04x  failto 0x%04x.\\n\", JAVA_OPS[op_byte].name, op->jump, op->fail);\n\t}\n\n\t//r_java_disasm(addr, data, len, output, outlen);\n\t//IFDBG eprintf (\"%s\\n\", output);\n\treturn op->size;\n}\n/*\nstatic RAnalOp * java_op_from_buffer(RAnal *anal, RAnalState *state, ut64 addr) {\n\n\tRAnalOp *op = r_anal_op_new ();\n\t//  get opcode size \n\tif (!op) return 0;\n\tmemset (op, '\\0', sizeof (RAnalOp));\n\tjava_op (anal, op, addr, state->buffer, state->len - (addr - state->start) );\n\treturn op;\n\n}\n*/\n\nstatic void java_set_function_prototype (RAnal *anal, RAnalFunction *fcn, RBinJavaField *method) {\n\tRList *the_list = r_bin_java_extract_type_values (method->descriptor);\n\tSdb *D = anal->sdb_types;\n\tSdb *A = anal->sdb_args;\n\tconst char *type_fmt = \"%08\"PFMT64x\".arg.%d.type\",\n\t     *namek_fmt = \"%08\"PFMT64x\".var.%d.name\",\n\t     *namev_fmt = \"%08\"PFMT64x\"local.%d\";\n\n\tchar  key_buf[1024], value_buf [1024];\n\tRListIter *iter;\n\tchar *str;\n\n\tif (the_list) {\n\t\tut8 start = 0, stop = 0;\n\t\tint idx = 0;\n\t\tr_list_foreach (the_list, iter, str) {\n\t\t\tIFDBG eprintf (\"Adding type: %s to known types.\\n\", str);\n\t\t\tif (str && *str == '('){\n\t\t\t\tstart = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (str && start && *str != ')') {\n\t\t\t\t// set type\n\t\t\t\t// set arg type\n\t\t\t\tsnprintf (key_buf, sizeof(key_buf)-1, type_fmt, (ut64)fcn->addr, idx);\n\t\t\t\tsdb_set (A, str, key_buf, 0);\n\t\t\t\tsdb_set (D, str, \"type\", 0);\n\t\t\t\t// set value\n\t\t\t\tsnprintf (key_buf, sizeof(key_buf)-1, namek_fmt, fcn->addr, idx);\n\t\t\t\tsnprintf (value_buf, sizeof(value_buf)-1, namev_fmt, fcn->addr, idx);\n\t\t\t\tsdb_set (A, value_buf, key_buf, 0);\n\t\t\t\tidx ++;\n\t\t\t}\n\t\t\tif (start && str && *str == ')') {\n\t\t\t\tstop = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((start & stop & 1) && str) {\n\t\t\t\tsdb_set (A, str, \"ret.type\", 0);\n\t\t\t\tsdb_set (D, str, \"type\", 0);\n\t\t\t}\n\t\t}\n\t\tr_list_free (the_list);\n\t}\n}\n\n\nstatic void java_update_anal_types (RAnal *anal, RBinJavaObj *bin_obj) {\n\tSdb *D = anal->sdb_types;\n\tif (D && bin_obj) {\n\t\tRListIter *iter;\n\t\tchar *str;\n\t\tRList * the_list = r_bin_java_extract_all_bin_type_values (bin_obj);\n\t\tif (the_list) {\n\t\t\tr_list_foreach (the_list, iter, str) {\n\t\t\t\tIFDBG eprintf (\"Adding type: %s to known types.\\n\", str);\n\t\t\t\tif (str) sdb_set (D, str, \"type\", 0);\n\t\t\t}\n\t\t}\n\t\tr_list_free (the_list);\n\t}\n}\n\nstatic int java_cmd_ext(RAnal *anal, const char* input) {\n\tRBinJavaObj *obj = (RBinJavaObj *) get_java_bin_obj (anal);\n\n\tif (!obj) {\n\t\teprintf (\"Execute \\\"af\\\" to set the current bin, and this will bind the current bin\\n\");\n\t\treturn -1;\n\t}\n\tswitch (*input) {\n\tcase 'c':\n\t\t// reset bytes counter for case operations\n\t\tr_java_new_method ();\n\t\tbreak;\n\tcase 'u':\n\t\tswitch (*(input+1)) {\n\t\t\tcase 't': {java_update_anal_types (anal, obj); return true;}\n\t\t\tdefault: break;\n\t\t}\n\t\tbreak;\n\tcase 's':\n\t\tswitch (*(input+1)) {\n\t\t\t//case 'e': return java_resolve_cp_idx_b64 (anal, input+2);\n\t\t\tdefault: break;\n\t\t}\n\t\tbreak;\n\n\tdefault: eprintf(\"Command not supported\"); break;\n\t}\n\treturn 0;\n}\n\nstatic int java_reset_counter (RAnal *anal, ut64 start_addr ) {\n\tIFDBG eprintf (\"Setting the new METHOD_START to 0x%08\"PFMT64x\" was 0x%08\"PFMT64x\"\\n\", start_addr, METHOD_START);\n\tMETHOD_START = start_addr;\n\tr_java_new_method ();\n\treturn true;\n}\n\nRAnalPlugin r_anal_plugin_java = {\n\t.name = \"java\",\n\t.desc = \"Java bytecode analysis plugin\",\n\t.license = \"Apache\",\n\t.arch = \"java\",\n\t.bits = 32,\n\t.custom_fn_anal = 1,\n\t.reset_counter = java_reset_counter,\n\t.analyze_fns = java_analyze_fns,\n\t.post_anal_bb_cb = java_recursive_descent,\n\t.revisit_bb_anal = java_revisit_bb_anal_recursive_descent,\n\t.op = &java_op,\n\t.cmd_ext = java_cmd_ext,\n\t0\n};\n\nRAnalPlugin r_anal_plugin_java_ls = {\n\t.name = \"java_ls\",\n\t.desc = \"Java bytecode analysis plugin with linear sweep\",\n\t.license = \"Apache\",\n\t.arch = \"java\",\n\t.bits = 32,\n\t.custom_fn_anal = 1,\n\t.analyze_fns = java_analyze_fns,\n\t.post_anal_bb_cb = java_linear_sweep,\n\t.post_anal = java_post_anal_linear_sweep,\n\t.revisit_bb_anal = java_revisit_bb_anal_recursive_descent,\n\t.op = &java_op,\n\t.cmd_ext = java_cmd_ext,\n\t0\n};\n\n#ifndef CORELIB\nRLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_ANAL,\n\t//.data = &r_anal_plugin_java\n\t.data = &r_anal_plugin_java_ls,\n\t.version = R2_VERSION\n};\n#endif\n"], "fixing_code": ["/* radare - Apache 2.0 - Copyright 2010-2015 - pancake and\n Adam Pridgen <dso@rice.edu || adam.pridgen@thecoverofnight.com> */\n\n#include <string.h>\n\n#include <r_types.h>\n#include <r_lib.h>\n#include <r_asm.h>\n#include <r_anal.h>\n#include <r_anal_ex.h>\n#include <r_cons.h>\n\n#include \"../../../shlr/java/code.h\"\n#include \"../../../shlr/java/class.h\"\n\n#ifdef IFDBG\n#define dprintf eprintf\n#endif\n\n#define DO_THE_DBG 0\n#define IFDBG  if(DO_THE_DBG)\n#define IFINT  if(0)\n\nstruct r_anal_java_access_t;\n\ntypedef struct r_anal_java_access_t {\n\tchar *method;\n\tut64 addr;\n\tut64 value;\n\tut64 op_type;\n\tstruct r_anal_java_access_t *next;\n\tstruct r_anal_java_access_t *previous;\n} RAnalJavaAccess;\n\ntypedef struct r_anal_java_local_var_t {\n\tchar *name;\n\tchar *type;\n\tRList *writes;\n\tRList *reads;\n\tRList *binops;\n} RAnalJavaLocalVar;\n\ntypedef struct r_anal_ex_java_lin_sweep {\n\tRList *cfg_node_addrs;\n}RAnalJavaLinearSweep;\n\nut64 METHOD_START = 0;\n\n// XXX - TODO add code in the java_op that is aware of when it is in a\n// switch statement, like in the shlr/java/code.c so that this does not \n// report bad blocks.  currently is should be easy to ignore these blocks,\n// in output for the pdj\n\n//static int java_print_ssa_bb (RAnal *anal, char *addr);\nstatic int java_reset_counter (RAnal *anal, ut64 addr);\nstatic int java_new_method (ut64 addr);\nstatic void java_update_anal_types (RAnal *anal, RBinJavaObj *bin_obj);\nstatic void java_set_function_prototype (RAnal *anal, RAnalFunction *fcn, RBinJavaField *method);\n\nstatic int java_cmd_ext(RAnal *anal, const char* input);\nstatic int analyze_from_code_buffer (RAnal *anal, RAnalFunction *fcn, ut64 addr, const ut8 *code_buf, ut64 code_length);\nstatic int analyze_from_code_attr (RAnal *anal, RAnalFunction *fcn, RBinJavaField *method, ut64 loadaddr);\nstatic int analyze_method(RAnal *anal, RAnalFunction *fcn, RAnalState *state);\n\nstatic int java_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len);\n//static int java_bb(RAnal *anal, RAnalFunction *fcn, ut64 addr, ut8 *buf, ut64 len, int reftype);\n//static int java_fn(RAnal *anal, RAnalFunction *fcn, ut64 addr, ut8 *buf, ut64 len, int reftype);\n\nstatic int java_recursive_descent(RAnal *anal, RAnalState *state, ut64 addr);\nstatic int handle_bb_cf_recursive_descent (RAnal *anal, RAnalState *state);\n\nstatic int java_linear_sweep(RAnal *anal, RAnalState *state, ut64 addr);\nstatic int handle_bb_cf_linear_sweep (RAnal *anal, RAnalState *state);\nstatic int java_post_anal_linear_sweep(RAnal *anal, RAnalState *state, ut64 addr);\nstatic RBinJavaObj * get_java_bin_obj(RAnal *anal);\nstatic RList * get_java_bin_obj_list(RAnal *anal);\n\nstatic int java_analyze_fns( RAnal *anal, ut64 start, ut64 end, int reftype, int depth);\n\n//static RAnalOp * java_op_from_buffer(RAnal *anal, RAnalState *state, ut64 addr);\n//static RAnalBlock * java_bb_from_buffer(RAnal *anal, RAnalState *state, ut64 addr);\n//static RAnalFunction * java_fn_from_buffer(RAnal *anal, RAnalState *state, ut64 addr);\n\nstatic int check_addr_in_code (RBinJavaField *method, ut64 addr);\nstatic int check_addr_less_end (RBinJavaField *method, ut64 addr);\nstatic int check_addr_less_start (RBinJavaField *method, ut64 addr);\n\nstatic int java_revisit_bb_anal_recursive_descent(RAnal *anal, RAnalState *state, ut64 addr);\n\nstatic RBinJavaObj * get_java_bin_obj(RAnal *anal) {\n\tRBin *b = anal->binb.bin;\n\tRBinPlugin *plugin = b->cur && b->cur->o ? b->cur->o->plugin : NULL;\n\tut8 is_java = (plugin && strcmp (plugin->name, \"java\") == 0) ? 1 : 0;\n\treturn is_java ? b->cur->o->bin_obj : NULL;\n}\n\nstatic RList * get_java_bin_obj_list(RAnal *anal) {\n\tRBinJavaObj *bin_obj = (RBinJavaObj * )get_java_bin_obj(anal);\n\t// See libr/bin/p/bin_java.c to see what is happening here.  The original intention\n\t// was to use a shared global db variable from shlr/java/class.c, but the\n\t// BIN_OBJS_ADDRS variable kept getting corrupted on Mac, so I (deeso) switched the\n\t// way the access to the db was taking place by using the bin_obj as a proxy back\n\t// to the BIN_OBJS_ADDRS which is instantiated in libr/bin/p/bin_java.c\n\t// not the easiest way to make sausage, but its getting made.\n\treturn  r_bin_java_get_bin_obj_list_thru_obj (bin_obj);\n}\n\nstatic int check_addr_less_end (RBinJavaField *method, ut64 addr) {\n\tut64 end = r_bin_java_get_method_code_size (method);\n\treturn (addr < end);\n}\n\nstatic int check_addr_in_code (RBinJavaField *method, ut64 addr) {\n\treturn !check_addr_less_start (method, addr) && \\\n\t\tcheck_addr_less_end ( method, addr);\n}\n\nstatic int check_addr_less_start (RBinJavaField *method, ut64 addr) {\n\tut64 start = r_bin_java_get_method_code_offset (method);\n\treturn (addr < start);\n}\n\n\nstatic int java_new_method (ut64 method_start) {\n\tMETHOD_START = method_start;\n\t// reset the current bytes consumed counter\n\tr_java_new_method ();\n\treturn 0;\n}\n\nstatic ut64 java_get_method_start () {\n\treturn METHOD_START;\n}\n\nstatic int java_revisit_bb_anal_recursive_descent(RAnal *anal, RAnalState *state, ut64 addr) {\n\tRAnalBlock *current_head = state && state->current_bb_head ? state->current_bb_head : NULL;\n\tif (current_head && state->current_bb &&\n\t\tstate->current_bb->type & R_ANAL_BB_TYPE_TAIL) {\n\t\tr_anal_ex_update_bb_cfg_head_tail (current_head, current_head, state->current_bb);\n\t\t// XXX should i do this instead -> r_anal_ex_perform_post_anal_bb_cb (anal, state, addr+offset);\n\t\tstate->done = 1;\n\t}\n\treturn R_ANAL_RET_END;\n}\n\nstatic int java_recursive_descent(RAnal *anal, RAnalState *state, ut64 addr) {\n\tRAnalBlock *bb;\n\tRAnalBlock *current_head;\n\n\tif (!anal || !state || !state->current_bb || state->current_bb_head)\n\t\treturn 0;\n\n\tbb = state->current_bb;\n\tcurrent_head = state->current_bb_head;\n\n\tif (current_head && state->current_bb->type & R_ANAL_BB_TYPE_TAIL) {\n\t\tr_anal_ex_update_bb_cfg_head_tail (current_head, current_head, state->current_bb);\n\t}\n\n\t// basic filter for handling the different type of operations\n\t// depending on flags some may be called more than once\n\t// if (bb->type2 & R_ANAL_EX_ILL_OP)   handle_bb_ill_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_COND_OP)  handle_bb_cond_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_UNK_OP)   handle_bb_unknown_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_NULL_OP)  handle_bb_null_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_NOP_OP)   handle_bb_nop_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_REP_OP)   handle_bb_rep_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_STORE_OP) handle_bb_store_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_LOAD_OP)  handle_bb_load_op (anal, state\n\t// if (bb->type2 & R_ANAL_EX_REG_OP)   handle_bb_reg_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_OBJ_OP)   handle_bb_obj_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_STACK_OP) handle_bb_stack_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_BIN_OP)   handle_bb_bin_op (anal, state);\n\tif (bb->type2 & R_ANAL_EX_CODE_OP)  handle_bb_cf_recursive_descent (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_DATA_OP)  handle_bb_data_op (anal, state);\n\treturn 0;\n}\n\nstatic int java_linear_sweep(RAnal *anal, RAnalState *state, ut64 addr) {\n\tRAnalBlock *bb = state->current_bb;\n\tif (state->current_bb_head && state->current_bb->type & R_ANAL_BB_TYPE_TAIL) {\n\t\t//r_anal_ex_update_bb_cfg_head_tail (state->current_bb_head, state->current_bb_head, state->current_bb);\n\t}\n\n\t// basic filter for handling the different type of operations\n\t// depending on flags some may be called more than once\n\t// if (bb->type2 & R_ANAL_EX_ILL_OP)   handle_bb_ill_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_COND_OP)  handle_bb_cond_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_UNK_OP)   handle_bb_unknown_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_NULL_OP)  handle_bb_null_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_NOP_OP)   handle_bb_nop_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_REP_OP)   handle_bb_rep_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_STORE_OP) handle_bb_store_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_LOAD_OP)  handle_bb_load_op (anal, state\n\t// if (bb->type2 & R_ANAL_EX_REG_OP)   handle_bb_reg_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_OBJ_OP)   handle_bb_obj_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_STACK_OP) handle_bb_stack_op (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_BIN_OP)   handle_bb_bin_op (anal, state);\n\tif (bb->type2 & R_ANAL_EX_CODE_OP)  handle_bb_cf_linear_sweep (anal, state);\n\t// if (bb->type2 & R_ANAL_EX_DATA_OP)  handle_bb_data_op (anal, state);\n\treturn 0;\n}\n\nstatic int handle_bb_cf_recursive_descent (RAnal *anal, RAnalState *state) {\n\n\tRAnalBlock *bb = state->current_bb;\n\n\tut64 addr = 0;\n\tint result = 0;\n\tif (!bb) {\n\t\teprintf (\"Error: unable to handle basic block @ 0x%08\"PFMT64x\"\\n\", addr);\n\t\treturn R_ANAL_RET_ERROR;\n\t} else if (state->max_depth <= state->current_depth) {\n\t\treturn R_ANAL_RET_ERROR;\n\t}\n\n\tstate->current_depth++;\n\taddr = bb->addr;\n\tIFDBG eprintf (\"Handling a control flow change @ 0x%04\"PFMT64x\".\\n\", addr);\n\tut64 control_type = r_anal_ex_map_anal_ex_to_anal_op_type (bb->type2);\n\n\t// XXX - transition to type2 control flow condtions\n\tswitch (control_type) {\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\tIFDBG eprintf (\" - Handling a call @ 0x%04\"PFMT64x\".\\n\", addr);\n\t\t\tr_anal_xrefs_set (anal, bb->addr, bb->jump, R_ANAL_REF_TYPE_CALL);\n\t\t\tresult = R_ANAL_RET_ERROR;\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\t{\n\t\t\t\tRList * jmp_list;\n\t\t\t\tIFDBG eprintf (\" - Handling a jmp @ 0x%04\"PFMT64x\" to 0x%04\"PFMT64x\".\\n\", addr, bb->jump);\n\n\t\t\t\t// visited some other time\n\t\t\t\tif (!r_anal_state_search_bb (state, bb->jump)) {\n\t\t\t\t\tjmp_list = r_anal_ex_perform_analysis ( anal, state, bb->jump );\n\t\t\t\t\tif (jmp_list)\n\t\t\t\t\t\tbb->jumpbb = (RAnalBlock *) r_list_get_n (jmp_list, 0);\n\t\t\t\t\tif (bb->jumpbb)\n\t\t\t\t\t\tbb->jump = bb->jumpbb->addr;\n\t\t\t\t} else {\n\t\t\t\t\tbb->jumpbb = r_anal_state_search_bb (state, bb->jump);\n\t\t\t\t\tif (bb->jumpbb)\n\t\t\t\t\t\tbb->jump = bb->jumpbb->addr;\n\t\t\t\t}\n\n\t\t\t\tif (state->done == 1) {\n\t\t\t\t\tIFDBG eprintf (\" Looks like this jmp (bb @ 0x%04\"PFMT64x\") found a return.\\n\", addr);\n\t\t\t\t}\n\t\t\t\tresult = R_ANAL_RET_END;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\t{\n\t\t\t\tRList *jmp_list;\n\t\t\t\tut8 encountered_stop = 0;\n\t\t\t\tIFDBG eprintf (\" - Handling a cjmp @ 0x%04\"PFMT64x\" jmp to 0x%04\"PFMT64x\" and fail to 0x%04\"PFMT64x\".\\n\", addr, bb->jump, bb->fail);\n\t\t\t\tIFDBG eprintf (\" - Handling jmp to 0x%04\"PFMT64x\".\\n\", bb->jump);\n\t\t\t\t// visited some other time\n\t\t\t\tif (!r_anal_state_search_bb (state, bb->jump)) {\n\t\t\t\t\tjmp_list = r_anal_ex_perform_analysis ( anal, state, bb->jump );\n\t\t\t\t\tif (jmp_list)\n\t\t\t\t\t\tbb->jumpbb = (RAnalBlock *) r_list_get_n (jmp_list, 0);\n\t\t\t\t\tif (bb->jumpbb) {\n\t\t\t\t\t\tbb->jump = bb->jumpbb->addr;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbb->jumpbb = r_anal_state_search_bb (state, bb->jump);\n\t\t\t\t\tbb->jump = bb->jumpbb->addr;\n\t\t\t\t}\n\n\t\t\t\tif (state->done == 1) {\n\t\t\t\t\tIFDBG eprintf (\" Looks like this jmp (bb @ 0x%04\"PFMT64x\") found a return.\\n\", addr);\n\t\t\t\t\tstate->done = 0;\n\t\t\t\t\tencountered_stop = 1;\n\t\t\t\t}\n\n\t\t\t\tif (!r_anal_state_search_bb (state, bb->fail)) {\n\t\t\t\t\tjmp_list = r_anal_ex_perform_analysis ( anal, state, bb->fail );\n\t\t\t\t\tif (jmp_list)\n\t\t\t\t\t\tbb->failbb = (RAnalBlock *) r_list_get_n (jmp_list, 0);\n\t\t\t\t\tif (bb->failbb) {\n\t\t\t\t\t\tbb->fail = bb->failbb->addr;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbb->failbb = r_anal_state_search_bb (state, bb->fail);\n\t\t\t\t\tif (bb->failbb) {\n\t\t\t\t\t\tbb->fail = bb->failbb->addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tIFDBG eprintf (\" - Handling an cjmp @ 0x%04\"PFMT64x\" jmp to 0x%04\"PFMT64x\" and fail to 0x%04\"PFMT64x\".\\n\", addr, bb->jump, bb->fail);\n\t\t\t\tIFDBG eprintf (\" - Handling fail to 0x%04\"PFMT64x\".\\n\", bb->fail);\n\t\t\t\t// r_anal_state_merge_bb_list (state, fail_list);\n\t\t\t\tif (state->done == 1) {\n\t\t\t\t\tIFDBG eprintf (\" Looks like this fail (bb @ 0x%04\"PFMT64x\") found a return.\\n\", addr);\n\t\t\t\t}\n\n\t\t\t\tresult = R_ANAL_RET_END;\n\t\t\t\tif (encountered_stop) state->done = 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase R_ANAL_OP_TYPE_SWITCH:\n\t\t{\n\t\t\tIFDBG eprintf (\" - Handling an switch @ 0x%04\"PFMT64x\".\\n\", addr);\n\t\t\tif (bb->switch_op) {\n\t\t\t\tRAnalCaseOp *caseop;\n\t\t\t\tRListIter *iter;\n\t\t\t\tRList *jmp_list = NULL;\n\t\t\t\tut8 encountered_stop = 0;\n\t\t\t\tr_list_foreach (bb->switch_op->cases, iter, caseop) {\n\t\t\t\t\tif (caseop) {\n\t\t\t\t\t\tif (r_anal_state_addr_is_valid (state, caseop->jump) ) {\n\t\t\t\t\t\t\tjmp_list = r_anal_ex_perform_analysis ( anal, state, caseop->jump );\n\t\t\t\t\t\t\tif (jmp_list)\n\t\t\t\t\t\t\t\tcaseop->jumpbb = (RAnalBlock *) r_list_get_n (jmp_list, 0);\n\t\t\t\t\t\t\tif (state->done == 1) {\n\t\t\t\t\t\t\t\tIFDBG eprintf (\" Looks like this jmp (bb @ 0x%04\"PFMT64x\") found a return.\\n\", addr);\n\t\t\t\t\t\t\t\tstate->done = 0;\n\t\t\t\t\t\t\t\tencountered_stop = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr_list_free (jmp_list);\n\t\t\t\tif (encountered_stop) state->done = 1;\n\t\t\t}\n\n\t\t\tresult = R_ANAL_RET_END;\n\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\tcase R_ANAL_OP_TYPE_IJMP:\n\t\tcase R_ANAL_OP_TYPE_RJMP:\n\t\tcase R_ANAL_OP_TYPE_IRJMP:\n\t\tcase R_ANAL_OP_TYPE_RET:\n\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\t\tIFDBG eprintf (\" - Handling an ret @ 0x%04\"PFMT64x\".\\n\", addr);\n\t\t\tstate->done = 1;\n\t\t\tresult = R_ANAL_RET_END;\n\t\t\tbreak;\n\t\tdefault: break;\n\t}\n\n\tstate->current_depth--;\n\treturn result;\n}\n\nstatic int java_post_anal_linear_sweep(RAnal *anal, RAnalState *state, ut64 addr) {\n\tRAnalJavaLinearSweep *nodes = state->user_state;\n\tRList *jmp_list = NULL;\n\tut64 *paddr64;\n\n\tstate->done = 0;\n\tif (!nodes || !nodes->cfg_node_addrs) {\n\t\tstate->done = 1;\n\t\treturn R_ANAL_RET_ERROR;\n\t}\n\n\twhile (r_list_length (nodes->cfg_node_addrs) > 0) {\n\t\tpaddr64 = r_list_get_n (nodes->cfg_node_addrs, 0);\n\t\tr_list_del_n (nodes->cfg_node_addrs, 0);\n\t\tif (paddr64 && !r_anal_state_search_bb (state, *paddr64)) {\n\t\t\tut64 list_length = 0;\n\t\t\tIFDBG eprintf (\" - Visiting 0x%04\"PFMT64x\" for analysis.\\n\", *paddr64);\n\t\t\tjmp_list = r_anal_ex_perform_analysis ( anal, state, *paddr64 );\n\t\t\tlist_length = r_list_length (jmp_list);\n\t\t\tr_list_free (jmp_list);\n\t\t\tif ( list_length > 0) {\n\t\t\t\tIFDBG eprintf (\" - Found %\"PFMT64d\" more basic blocks missed on the initial pass.\\n\", *paddr64);\n\t\t\t}\n\t\t}\n\n\t}\n\treturn R_ANAL_RET_END;\n}\n\n\nstatic int handle_bb_cf_linear_sweep (RAnal *anal, RAnalState *state) {\n\tut64 * paddr64;\n\tRAnalBlock *bb = state->current_bb;\n\tRAnalJavaLinearSweep *nodes = state->user_state;\n\n\tif (!nodes || !nodes->cfg_node_addrs) {\n\t\tstate->done = 1;\n\t\treturn R_ANAL_RET_ERROR;\n\t}\n\n\tut64 addr = 0;\n\tint result = 0;\n\tif (!bb) {\n\t\teprintf (\"Error: unable to handle basic block @ 0x%08\"PFMT64x\"\\n\", addr);\n\t\treturn R_ANAL_RET_ERROR;\n\t} else if (state->max_depth <= state->current_depth) {\n\t\treturn R_ANAL_RET_ERROR;\n\t}\n\n\tstate->current_depth++;\n\taddr = bb->addr;\n\tIFDBG eprintf (\"Handling a control flow change @ 0x%04\"PFMT64x\".\\n\", addr);\n\tut32 control_type = r_anal_ex_map_anal_ex_to_anal_op_type (bb->type2);\n\n\t// XXX - transition to type2 control flow condtions\n\tswitch (control_type) {\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\tIFDBG eprintf (\" - Handling a call @ 0x%04\"PFMT64x\"\\n\", addr);\n\t\t\tr_anal_xrefs_set (anal, bb->addr, bb->jump, R_ANAL_REF_TYPE_CALL);\n\t\t\tresult = R_ANAL_RET_ERROR;\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tpaddr64 = malloc (sizeof(ut64));\n\t\t\t*paddr64 = bb->jump;\n\t\t\tIFDBG eprintf (\" - Handling a jmp @ 0x%04\"PFMT64x\", adding for future visit\\n\", addr);\n\t\t\tr_list_append (nodes->cfg_node_addrs, paddr64);\n\t\t\tresult = R_ANAL_RET_END;\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\tpaddr64 = malloc (sizeof(ut64));\n\t\t\t*paddr64 = bb->jump;\n\t\t\tIFDBG eprintf (\" - Handling a bb->jump @ 0x%04\"PFMT64x\", adding 0x%04\"PFMT64x\" for future visit\\n\", addr, *paddr64);\n\t\t\tr_list_append (nodes->cfg_node_addrs, paddr64);\n\t\t\tpaddr64 = malloc (sizeof(ut64));\n\t\t\tif (paddr64) {\n\t\t\t\t*paddr64 = bb->fail;\n\t\t\t\tIFDBG eprintf (\" - Handling a bb->fail @ 0x%04\"PFMT64x\", adding 0x%04\"PFMT64x\" for future visit\\n\", addr, *paddr64);\n\t\t\t\tr_list_append (nodes->cfg_node_addrs, paddr64);\n\t\t\t}\n\t\t\tresult = R_ANAL_RET_END;\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_SWITCH:\n\t\t\tif (bb->switch_op) {\n\t\t\t\tRAnalCaseOp *caseop;\n\t\t\t\tRListIter *iter;\n\t\t\t\t//RList *jmp_list = NULL;\n\t\t\t\tIFDBG eprintf (\" - Handling a switch_op @ 0x%04\"PFMT64x\":\\n\", addr);\n\t\t\t\tr_list_foreach (bb->switch_op->cases, iter, caseop) {\n\t\t\t\t\tut64 * paddr64;\n\t\t\t\t\tif (caseop) {\n\t\t\t\t\t\tpaddr64 = malloc (sizeof(ut64));\n\t\t\t\t\t\t*paddr64 = caseop->jump;\n\t\t\t\t\t\tIFDBG eprintf (\"Adding 0x%04\"PFMT64x\" for future visit\\n\", *paddr64);\n\t\t\t\t\t\tr_list_append (nodes->cfg_node_addrs, paddr64);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult = R_ANAL_RET_END;\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\tcase R_ANAL_OP_TYPE_RJMP:\n\t\tcase R_ANAL_OP_TYPE_IJMP:\n\t\tcase R_ANAL_OP_TYPE_IRJMP:\n\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tIFDBG eprintf (\" - Handling an ret @ 0x%04\"PFMT64x\".\\n\", addr);\n\t\t\tstate->done = 1;\n\t\t\tresult = R_ANAL_RET_END;\n\t\t\tbreak;\n\t\tdefault: break;\n\t}\n\n\tstate->current_depth--;\n\treturn result;\n}\n\n\n//many flaws UAF\nstatic int analyze_from_code_buffer(RAnal *anal, RAnalFunction *fcn, ut64 addr, const ut8 *code_buf, ut64 code_length) {\n\tchar gen_name[1025];\n\tRListIter *bb_iter;\n\tRAnalBlock *bb;\n\tut64 actual_size = 0;\n\tRAnalState *state = NULL;\n\tint result = R_ANAL_RET_ERROR;\n\tRAnalJavaLinearSweep *nodes;\n\n\tfree (fcn->name);\n\tfree (fcn->dsc);\n\tsnprintf (gen_name, 1024, \"sym.%08\"PFMT64x\"\", addr);\n\n\tfcn->name = strdup (gen_name);\n\tfcn->dsc = strdup (\"unknown\");\n\tr_anal_fcn_set_size (NULL, fcn, code_length);\n\tfcn->type = R_ANAL_FCN_TYPE_FCN;\n\tfcn->addr = addr;\n\tstate = r_anal_state_new (addr, (ut8*) code_buf, code_length);\n\tnodes = R_NEW0 (RAnalJavaLinearSweep);\n\tnodes->cfg_node_addrs = r_list_new ();\n\tnodes->cfg_node_addrs->free = free;\n\tstate->user_state = nodes;\n\tresult = analyze_method (anal, fcn, state);\n\tr_list_foreach (fcn->bbs, bb_iter, bb) {\n\t\tactual_size += bb->size;\n\t}\n\tr_anal_fcn_set_size (NULL, fcn, state->bytes_consumed);\n\tresult = state->anal_ret_val;\n\tr_list_free (nodes->cfg_node_addrs);\n\tfree (nodes);\n\t//leak to avoid UAF is the easy solution otherwise a whole rewrite is needed\n\t//r_anal_state_free (state);\n\tif (r_anal_fcn_size (fcn) != code_length) {\n\t\treturn R_ANAL_RET_ERROR;\n#if 0\n\t\teprintf (\"WARNING Analysis of %s Incorrect: Code Length: 0x%\"PFMT64x\", Function size reported 0x%x\\n\", fcn->name, code_length, r_anal_fcn_size(fcn));\n\t\teprintf (\"Deadcode detected, setting code length to: 0x%\"PFMT64x\"\\n\", code_length);\n\t\tr_anal_fcn_set_size (fcn, code_length);\n#endif\n\t}\n\treturn result;\n}\n\nstatic int analyze_from_code_attr (RAnal *anal, RAnalFunction *fcn, RBinJavaField *method, ut64 loadaddr) {\n\tRBinJavaAttrInfo* code_attr = method ? r_bin_java_get_method_code_attribute(method) : NULL;\n\tut8 * code_buf = NULL;\n\tint result = false;\n\tut64 code_length = 0;\n\tut64 code_addr = -1;\n\n\tif (!code_attr) {\n\t\tfcn->name = strdup (\"sym.UNKNOWN\");\n\t\tfcn->dsc = strdup (\"unknown\");\n\t\tr_anal_fcn_set_size (NULL, fcn, code_length);\n\t\tfcn->type = R_ANAL_FCN_TYPE_FCN;\n\t\tfcn->addr = 0;\n\t\treturn R_ANAL_RET_ERROR;\n\t}\n\n\tcode_length = code_attr->info.code_attr.code_length;\n\tcode_addr = code_attr->info.code_attr.code_offset;\n\tcode_buf = calloc (1, code_length);\n\n\tanal->iob.read_at (anal->iob.io, code_addr + loadaddr, code_buf, code_length);\n\tresult = analyze_from_code_buffer (anal, fcn, code_addr + loadaddr, code_buf, code_length);\n\tfree (code_buf);\n\n\tchar *name = strdup (method->name);\n\tif (name) {\n\t\tr_name_filter (name, 80);\n\t\tfree (fcn->name);\n\t\tif (method->class_name) {\n\t\t\tchar *cname = strdup (method->class_name);\n\t\t\tr_name_filter (cname, 50);\n\t\t\tfcn->name = r_str_newf (\"sym.%s.%s\", cname, name);\n\t\t\tfree (cname);\n\t\t} else {\n\t\t\tfcn->name = r_str_newf (\"sym.%s\", name);\n\t\t}\n\t\tfree (name);\n\t}\n\n\tfree (fcn->dsc);\n\tfcn->dsc = strdup (method->descriptor);\n\tIFDBG eprintf (\"Completed analysing code from attr, name: %s, desc: %s\", fcn->name, fcn->dsc);\n\n\treturn result;\n}\n\nstatic int analyze_method(RAnal *anal, RAnalFunction *fcn, RAnalState *state) {\n\t// deallocate niceties\n\tr_list_free (fcn->bbs);\n\tfcn->bbs = r_anal_bb_list_new ();\n\tjava_new_method (fcn->addr);\n\tstate->current_fcn = fcn;\n\t// Not a resource leak.  Basic blocks should be stored in the state->fcn\n\t// TODO: ? RList *bbs = \n\tr_anal_ex_perform_analysis (anal, state, fcn->addr);\n\treturn state->anal_ret_val;\n}\n\nstatic int java_analyze_fns_from_buffer( RAnal *anal, ut64 start, ut64 end, int reftype, int depth) {\n\tint result = R_ANAL_RET_ERROR;\n\tut64 addr = start;\n\tut64 offset = 0;\n\tut64 buf_len = end - start;\n\tut8 analyze_all = 0,\n\t\t*buffer = NULL;\n\n\tif (end == UT64_MAX) {\n\t\t//analyze_all = 1;\n\t\tbuf_len = anal->iob.desc_size (anal->iob.io->desc);\n\n\t\tif (buf_len == UT64_MAX) buf_len = 1024;\n\n\t\tend = start + buf_len;\n\t}\n\n\tbuffer = malloc (buf_len);\n\tif (!buffer) {\n\t\treturn R_ANAL_RET_ERROR;\n\t}\n\n\tanal->iob.read_at (anal->iob.io, addr, buffer, buf_len);\n\n\twhile (offset < buf_len) {\n\t\tut64 length = buf_len - offset;\n\n\t\tRAnalFunction *fcn = r_anal_fcn_new ();\n\t\tfcn->cc = r_str_const (r_anal_cc_default (anal));\n\t\tresult = analyze_from_code_buffer ( anal, fcn, addr, buffer+offset, length );\n\t\tif (result == R_ANAL_RET_ERROR) {\n\t\t\teprintf (\"Failed to parse java fn: %s @ 0x%04\"PFMT64x\"\\n\", fcn->name, fcn->addr);\n\t\t\t// XXX - TO Stop or not to Stop ??\n\t\t\tbreak;\n\t\t}\n\t\t//r_listrange_add (anal->fcnstore, fcn);\n\t\tr_anal_fcn_tree_insert (&anal->fcn_tree, fcn);\n\t\tr_list_append (anal->fcns, fcn);\n\t\toffset += r_anal_fcn_size (fcn);\n\t\tif (!analyze_all) break;\n\t}\n\tfree (buffer);\n\treturn result;\n}\n\nstatic int java_analyze_fns( RAnal *anal, ut64 start, ut64 end, int reftype, int depth) {\n\t//anal->iob.read_at (anal->iob.io, op.jump, bbuf, sizeof (bbuf));\n\tRBinJavaObj *bin = NULL;// = get_java_bin_obj (anal);\n\tRBinJavaField *method = NULL;\n\tRListIter *methods_iter, *bin_obs_iter;\n\tRList * bin_objs_list = get_java_bin_obj_list (anal);\n\n\tut8 analyze_all = 0;\n\t//RAnalRef *ref = NULL;\n\tint result = R_ANAL_RET_ERROR;\n\n\tif (end == UT64_MAX) {\n\t\tanalyze_all = 1;\n\t}\n\tif (!bin_objs_list || r_list_empty (bin_objs_list)) {\n\t\tr_list_free (bin_objs_list);\n\t\treturn java_analyze_fns_from_buffer (anal, start, end, reftype, depth);\n\t}\n\tr_list_foreach (bin_objs_list, bin_obs_iter, bin) {\n\t\t// loop over all bin object that are loaded\n\t\tjava_update_anal_types (anal, bin);\n\t\tRList *methods_list = (RList *) r_bin_java_get_methods_list (bin);\n\t\tut64 loadaddr = bin->loadaddr;\n\t\t// loop over all methods in the binary object and analyse\n\t\t// the functions\n\t\tr_list_foreach (methods_list, methods_iter, method) {\n\t\t\tif ((method && analyze_all) ||\n\t\t\t    (check_addr_less_start (method, end) ||\n\t\t\t     check_addr_in_code (method, end))) {\n\t\t\t\tRAnalFunction *fcn = r_anal_fcn_new ();\n\t\t\t\tfcn->cc = r_str_const (r_anal_cc_default (anal));\n\t\t\t\tjava_set_function_prototype (anal, fcn, method);\n\t\t\t\tresult = analyze_from_code_attr (anal, fcn, method, loadaddr);\n\t\t\t\tif (result == R_ANAL_RET_ERROR) {\n\t\t\t\t\t//eprintf (\"Failed to parse java fn: %s @ 0x%04\"PFMT64x\"\\n\", fcn->name, fcn->addr);\n\t\t\t\t\treturn result;\n\t\t\t\t\t// XXX - TO Stop or not to Stop ??\n\t\t\t\t}\n\t\t\t\t//r_listrange_add (anal->fcnstore, fcn);\n\t\t\t\tr_anal_fcn_update_tinyrange_bbs (fcn);\n\t\t\t\tr_anal_fcn_tree_insert (&anal->fcn_tree, fcn);\n\t\t\t\tr_list_append (anal->fcns, fcn);\n\t\t\t}\n\t\t} // End of methods loop\n\t}// end of bin_objs list loop\n\treturn result;\n}\n\n/*static int java_fn(RAnal *anal, RAnalFunction *fcn, ut64 addr, ut8 *buf, ut64 len, int reftype) {\n\t// XXX - this may clash with malloc:// uris because the file name is\n\t// malloc:// **\n\tRBinJavaObj *bin = (RBinJavaObj *) get_java_bin_obj (anal);\n\tRBinJavaField *method = bin ? r_bin_java_get_method_code_attribute_with_addr (bin,  addr) : NULL;\n\tut64 loadaddr = bin ? bin->loadaddr : 0;\n\tIFDBG eprintf (\"Analyzing java functions for %s\\n\", anal->iob.io->fd->name);\n\tif (method) return analyze_from_code_attr (anal, fcn, method, loadaddr);\n\treturn analyze_from_code_buffer (anal, fcn, addr, buf, len);\n}*/\n\nstatic int java_switch_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tut8 op_byte = data[0];\n\tut64 offset = addr - java_get_method_start ();\n\tut8 pos = (offset+1)%4 ? 1 + 4 - (offset+1)%4 : 1;\n\n\tif (op_byte == 0xaa) {\n\t\t// handle a table switch condition\n\t\tif (pos + 8 + 8 > len) {\n\t\t\treturn op->size;\n\t\t}\n\t\tconst int min_val = (ut32)(UINT (data, pos + 4));\n\t\tconst int max_val = (ut32)(UINT (data, pos + 8));\n\n\t\tut32 default_loc = (ut32) (UINT (data, pos)), cur_case = 0;\n\t\top->switch_op = r_anal_switch_op_new (addr, min_val, default_loc);\n\t\tRAnalCaseOp *caseop = NULL;\n\t\tpos += 12;\n\t\tif (max_val > min_val && ((max_val - min_val)<(UT16_MAX/4))) {\n\t\t\t//caseop = r_anal_switch_op_add_case(op->switch_op, addr+default_loc, -1, addr+offset);\n\t\t\tfor (cur_case = 0; cur_case <= max_val - min_val; pos += 4, cur_case++) {\n\t\t\t\t//ut32 value = (ut32)(UINT (data, pos));\n\t\t\t\tif (pos + 4 >= len) {\n\t\t\t\t\t// switch is too big cant read further\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint offset = (int)(ut32)(R_BIN_JAVA_UINT (data, pos));\n\t\t\t\tcaseop = r_anal_switch_op_add_case (op->switch_op,\n\t\t\t\t\taddr + pos, cur_case + min_val, addr + offset);\n\t\t\t\tif (caseop) {\n\t\t\t\t\tcaseop->bb_ref_to = addr+offset;\n\t\t\t\t\tcaseop->bb_ref_from = addr; // TODO figure this one out\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Invalid switch boundaries at 0x%\"PFMT64x\"\\n\", addr);\n\t\t}\n\t}\n\top->size = pos;\n\treturn op->size;\n}\n\nstatic int java_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\t/* get opcode size */\n\t//ut8 op_byte = data[0];\n\tut8 op_byte = data[0];\n\tint sz = JAVA_OPS[op_byte].size;\n\tif (!op) {\n\t\treturn sz;\n\t}\n\tmemset (op, '\\0', sizeof (RAnalOp));\n\tIFDBG {\n\t\t//eprintf (\"Extracting op from buffer (%d byte(s)) @ 0x%04x\\n\", len, addr);\n\t\t//eprintf (\"Parsing op: (0x%02x) %s.\\n\", op_byte, JAVA_OPS[op_byte].name);\n\t}\n\top->addr = addr;\n\top->size = sz;\n\top->id = data[0];\n\top->type2 = JAVA_OPS[op_byte].op_type;\n\top->type = r_anal_ex_map_anal_ex_to_anal_op_type (op->type2);\n\t// handle lookup and table switch offsets\n\tif (op_byte == 0xaa || op_byte == 0xab) {\n\t\tjava_switch_op (anal, op, addr, data, len);\n\t\t// IN_SWITCH_OP = 1;\n\t}\n\t/* TODO: \n\t// not sure how to handle the states for IN_SWITCH_OP, SWITCH_OP_CASES,\n\t// and NUM_CASES_SEEN, because these are dependent on whether or not we\n\t// are in a switch, and given the non-reentrant state of opcode analysis\n\t// this can't always be guaranteed.  Below is the pseudo code for handling\n\t// the easy parts though\n\tif (IN_SWITCH_OP) {\n\t\tNUM_CASES_SEEN++;\n\t\tif (NUM_CASES_SEEN == SWITCH_OP_CASES) IN_SWITCH_OP=0;\n\t\top->addr = addr;\n\t\top->size = 4;\n\t\top->type2 = 0;\n\t\top->type = R_ANAL_OP_TYPE_CASE\n\t\top->eob = 0;\n\t\treturn op->sizes;\n\t}\n\t*/\n\n\top->eob = r_anal_ex_is_op_type_eop (op->type2);\n\tIFDBG {\n\t\tconst char *ot_str = r_anal_optype_to_string (op->type);\n\t\teprintf (\"op_type2: %s @ 0x%04\"PFMT64x\" 0x%08\"PFMT64x\" op_type: (0x%02\"PFMT64x\") %s.\\n\",\n\t\t\tJAVA_OPS[op_byte].name, addr, (ut64)op->type2, (ut64)op->type,  ot_str);\n\t\t//eprintf (\"op_eob: 0x%02x.\\n\", op->eob);\n\t\t//eprintf (\"op_byte @ 0: 0x%02x op_byte @ 0x%04x: 0x%02x.\\n\", data[0], addr, data[addr]);\n\t}\n\n\tif (len < 4) {\n\t\t// incomplete analysis here\n\t\treturn 0;\n\t}\n\tif (op->type == R_ANAL_OP_TYPE_CJMP) {\n\t\top->jump = addr + (short)(USHORT (data, 1));\n\t\top->fail = addr + sz;\n\t\tIFDBG eprintf (\"%s jmpto 0x%04\"PFMT64x\"  failto 0x%04\"PFMT64x\".\\n\",\n\t\t\tJAVA_OPS[op_byte].name, op->jump, op->fail);\n\t} else if (op->type  == R_ANAL_OP_TYPE_JMP) {\n\t\top->jump = addr + (short)(USHORT (data, 1));\n\t\tIFDBG eprintf (\"%s jmpto 0x%04\"PFMT64x\".\\n\", JAVA_OPS[op_byte].name, op->jump);\n\t} else if ( (op->type & R_ANAL_OP_TYPE_CALL) == R_ANAL_OP_TYPE_CALL ) {\n\t\top->jump = (int)(short)(USHORT (data, 1));\n\t\top->fail = addr + sz;\n\t\t//IFDBG eprintf (\"%s callto 0x%04x  failto 0x%04x.\\n\", JAVA_OPS[op_byte].name, op->jump, op->fail);\n\t}\n\n\t//r_java_disasm(addr, data, len, output, outlen);\n\t//IFDBG eprintf (\"%s\\n\", output);\n\treturn op->size;\n}\n/*\nstatic RAnalOp * java_op_from_buffer(RAnal *anal, RAnalState *state, ut64 addr) {\n\n\tRAnalOp *op = r_anal_op_new ();\n\t//  get opcode size \n\tif (!op) return 0;\n\tmemset (op, '\\0', sizeof (RAnalOp));\n\tjava_op (anal, op, addr, state->buffer, state->len - (addr - state->start) );\n\treturn op;\n\n}\n*/\n\nstatic void java_set_function_prototype (RAnal *anal, RAnalFunction *fcn, RBinJavaField *method) {\n\tRList *the_list = r_bin_java_extract_type_values (method->descriptor);\n\tSdb *D = anal->sdb_types;\n\tSdb *A = anal->sdb_args;\n\tconst char *type_fmt = \"%08\"PFMT64x\".arg.%d.type\",\n\t     *namek_fmt = \"%08\"PFMT64x\".var.%d.name\",\n\t     *namev_fmt = \"%08\"PFMT64x\"local.%d\";\n\n\tchar  key_buf[1024], value_buf [1024];\n\tRListIter *iter;\n\tchar *str;\n\n\tif (the_list) {\n\t\tut8 start = 0, stop = 0;\n\t\tint idx = 0;\n\t\tr_list_foreach (the_list, iter, str) {\n\t\t\tIFDBG eprintf (\"Adding type: %s to known types.\\n\", str);\n\t\t\tif (str && *str == '('){\n\t\t\t\tstart = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (str && start && *str != ')') {\n\t\t\t\t// set type\n\t\t\t\t// set arg type\n\t\t\t\tsnprintf (key_buf, sizeof(key_buf)-1, type_fmt, (ut64)fcn->addr, idx);\n\t\t\t\tsdb_set (A, str, key_buf, 0);\n\t\t\t\tsdb_set (D, str, \"type\", 0);\n\t\t\t\t// set value\n\t\t\t\tsnprintf (key_buf, sizeof(key_buf)-1, namek_fmt, fcn->addr, idx);\n\t\t\t\tsnprintf (value_buf, sizeof(value_buf)-1, namev_fmt, fcn->addr, idx);\n\t\t\t\tsdb_set (A, value_buf, key_buf, 0);\n\t\t\t\tidx ++;\n\t\t\t}\n\t\t\tif (start && str && *str == ')') {\n\t\t\t\tstop = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((start & stop & 1) && str) {\n\t\t\t\tsdb_set (A, str, \"ret.type\", 0);\n\t\t\t\tsdb_set (D, str, \"type\", 0);\n\t\t\t}\n\t\t}\n\t\tr_list_free (the_list);\n\t}\n}\n\n\nstatic void java_update_anal_types (RAnal *anal, RBinJavaObj *bin_obj) {\n\tSdb *D = anal->sdb_types;\n\tif (D && bin_obj) {\n\t\tRListIter *iter;\n\t\tchar *str;\n\t\tRList * the_list = r_bin_java_extract_all_bin_type_values (bin_obj);\n\t\tif (the_list) {\n\t\t\tr_list_foreach (the_list, iter, str) {\n\t\t\t\tIFDBG eprintf (\"Adding type: %s to known types.\\n\", str);\n\t\t\t\tif (str) sdb_set (D, str, \"type\", 0);\n\t\t\t}\n\t\t}\n\t\tr_list_free (the_list);\n\t}\n}\n\nstatic int java_cmd_ext(RAnal *anal, const char* input) {\n\tRBinJavaObj *obj = (RBinJavaObj *) get_java_bin_obj (anal);\n\n\tif (!obj) {\n\t\teprintf (\"Execute \\\"af\\\" to set the current bin, and this will bind the current bin\\n\");\n\t\treturn -1;\n\t}\n\tswitch (*input) {\n\tcase 'c':\n\t\t// reset bytes counter for case operations\n\t\tr_java_new_method ();\n\t\tbreak;\n\tcase 'u':\n\t\tswitch (*(input+1)) {\n\t\t\tcase 't': {java_update_anal_types (anal, obj); return true;}\n\t\t\tdefault: break;\n\t\t}\n\t\tbreak;\n\tcase 's':\n\t\tswitch (*(input+1)) {\n\t\t\t//case 'e': return java_resolve_cp_idx_b64 (anal, input+2);\n\t\t\tdefault: break;\n\t\t}\n\t\tbreak;\n\n\tdefault: eprintf(\"Command not supported\"); break;\n\t}\n\treturn 0;\n}\n\nstatic int java_reset_counter (RAnal *anal, ut64 start_addr ) {\n\tIFDBG eprintf (\"Setting the new METHOD_START to 0x%08\"PFMT64x\" was 0x%08\"PFMT64x\"\\n\", start_addr, METHOD_START);\n\tMETHOD_START = start_addr;\n\tr_java_new_method ();\n\treturn true;\n}\n\nRAnalPlugin r_anal_plugin_java = {\n\t.name = \"java\",\n\t.desc = \"Java bytecode analysis plugin\",\n\t.license = \"Apache\",\n\t.arch = \"java\",\n\t.bits = 32,\n\t.custom_fn_anal = 1,\n\t.reset_counter = java_reset_counter,\n\t.analyze_fns = java_analyze_fns,\n\t.post_anal_bb_cb = java_recursive_descent,\n\t.revisit_bb_anal = java_revisit_bb_anal_recursive_descent,\n\t.op = &java_op,\n\t.cmd_ext = java_cmd_ext,\n\t0\n};\n\nRAnalPlugin r_anal_plugin_java_ls = {\n\t.name = \"java_ls\",\n\t.desc = \"Java bytecode analysis plugin with linear sweep\",\n\t.license = \"Apache\",\n\t.arch = \"java\",\n\t.bits = 32,\n\t.custom_fn_anal = 1,\n\t.analyze_fns = java_analyze_fns,\n\t.post_anal_bb_cb = java_linear_sweep,\n\t.post_anal = java_post_anal_linear_sweep,\n\t.revisit_bb_anal = java_revisit_bb_anal_recursive_descent,\n\t.op = &java_op,\n\t.cmd_ext = java_cmd_ext,\n\t0\n};\n\n#ifndef CORELIB\nRLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_ANAL,\n\t//.data = &r_anal_plugin_java\n\t.data = &r_anal_plugin_java_ls,\n\t.version = R2_VERSION\n};\n#endif\n"], "filenames": ["libr/anal/p/anal_java.c"], "buggy_code_start_loc": [682], "buggy_code_end_loc": [687], "fixing_code_start_loc": [682], "fixing_code_end_loc": [687], "type": "CWE-125", "message": "There is a heap out of bounds read in radare2 2.6.0 in java_switch_op() in libr/anal/p/anal_java.c via a crafted Java binary file.", "other": {"cve": {"id": "CVE-2018-12321", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-13T16:29:01.593", "lastModified": "2018-08-02T13:06:54.320", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "There is a heap out of bounds read in radare2 2.6.0 in java_switch_op() in libr/anal/p/anal_java.c via a crafted Java binary file."}, {"lang": "es", "value": "Hay una lectura fuera de l\u00edmites en radare2 2.6.0 en java_switch_op() en libr/anal/p/anal_java.c mediante un archivo binario de Java manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:2.6.0:*:*:*:*:*:*:*", "matchCriteriaId": "ECF03BDC-4698-4552-A58C-67FD78902BED"}]}]}], "references": [{"url": "https://github.com/radare/radare2/commit/224e6bc13fa353dd3b7f7a2334588f1c4229e58d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/radare/radare2/issues/10296", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radare/radare2/commit/224e6bc13fa353dd3b7f7a2334588f1c4229e58d"}}