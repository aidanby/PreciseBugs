{"buggy_code": ["/*\n * hid-cp2112.c - Silicon Labs HID USB to SMBus master bridge\n * Copyright (c) 2013,2014 Uplogix, Inc.\n * David Barksdale <dbarksdale@uplogix.com>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms and conditions of the GNU General Public License,\n * version 2, as published by the Free Software Foundation.\n *\n * This program is distributed in the hope it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n * more details.\n */\n\n/*\n * The Silicon Labs CP2112 chip is a USB HID device which provides an\n * SMBus controller for talking to slave devices and 8 GPIO pins. The\n * host communicates with the CP2112 via raw HID reports.\n *\n * Data Sheet:\n *   http://www.silabs.com/Support%20Documents/TechnicalDocs/CP2112.pdf\n * Programming Interface Specification:\n *   http://www.silabs.com/Support%20Documents/TechnicalDocs/AN495.pdf\n */\n\n#include <linux/gpio.h>\n#include <linux/gpio/driver.h>\n#include <linux/hid.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/nls.h>\n#include <linux/usb/ch9.h>\n#include \"hid-ids.h\"\n\n#define CP2112_REPORT_MAX_LENGTH\t\t64\n#define CP2112_GPIO_CONFIG_LENGTH\t\t5\n#define CP2112_GPIO_GET_LENGTH\t\t\t2\n#define CP2112_GPIO_SET_LENGTH\t\t\t3\n\nenum {\n\tCP2112_GPIO_CONFIG\t\t= 0x02,\n\tCP2112_GPIO_GET\t\t\t= 0x03,\n\tCP2112_GPIO_SET\t\t\t= 0x04,\n\tCP2112_GET_VERSION_INFO\t\t= 0x05,\n\tCP2112_SMBUS_CONFIG\t\t= 0x06,\n\tCP2112_DATA_READ_REQUEST\t= 0x10,\n\tCP2112_DATA_WRITE_READ_REQUEST\t= 0x11,\n\tCP2112_DATA_READ_FORCE_SEND\t= 0x12,\n\tCP2112_DATA_READ_RESPONSE\t= 0x13,\n\tCP2112_DATA_WRITE_REQUEST\t= 0x14,\n\tCP2112_TRANSFER_STATUS_REQUEST\t= 0x15,\n\tCP2112_TRANSFER_STATUS_RESPONSE\t= 0x16,\n\tCP2112_CANCEL_TRANSFER\t\t= 0x17,\n\tCP2112_LOCK_BYTE\t\t= 0x20,\n\tCP2112_USB_CONFIG\t\t= 0x21,\n\tCP2112_MANUFACTURER_STRING\t= 0x22,\n\tCP2112_PRODUCT_STRING\t\t= 0x23,\n\tCP2112_SERIAL_STRING\t\t= 0x24,\n};\n\nenum {\n\tSTATUS0_IDLE\t\t= 0x00,\n\tSTATUS0_BUSY\t\t= 0x01,\n\tSTATUS0_COMPLETE\t= 0x02,\n\tSTATUS0_ERROR\t\t= 0x03,\n};\n\nenum {\n\tSTATUS1_TIMEOUT_NACK\t\t= 0x00,\n\tSTATUS1_TIMEOUT_BUS\t\t= 0x01,\n\tSTATUS1_ARBITRATION_LOST\t= 0x02,\n\tSTATUS1_READ_INCOMPLETE\t\t= 0x03,\n\tSTATUS1_WRITE_INCOMPLETE\t= 0x04,\n\tSTATUS1_SUCCESS\t\t\t= 0x05,\n};\n\nstruct cp2112_smbus_config_report {\n\tu8 report;\t\t/* CP2112_SMBUS_CONFIG */\n\t__be32 clock_speed;\t/* Hz */\n\tu8 device_address;\t/* Stored in the upper 7 bits */\n\tu8 auto_send_read;\t/* 1 = enabled, 0 = disabled */\n\t__be16 write_timeout;\t/* ms, 0 = no timeout */\n\t__be16 read_timeout;\t/* ms, 0 = no timeout */\n\tu8 scl_low_timeout;\t/* 1 = enabled, 0 = disabled */\n\t__be16 retry_time;\t/* # of retries, 0 = no limit */\n} __packed;\n\nstruct cp2112_usb_config_report {\n\tu8 report;\t/* CP2112_USB_CONFIG */\n\t__le16 vid;\t/* Vendor ID */\n\t__le16 pid;\t/* Product ID */\n\tu8 max_power;\t/* Power requested in 2mA units */\n\tu8 power_mode;\t/* 0x00 = bus powered\n\t\t\t   0x01 = self powered & regulator off\n\t\t\t   0x02 = self powered & regulator on */\n\tu8 release_major;\n\tu8 release_minor;\n\tu8 mask;\t/* What fields to program */\n} __packed;\n\nstruct cp2112_read_req_report {\n\tu8 report;\t/* CP2112_DATA_READ_REQUEST */\n\tu8 slave_address;\n\t__be16 length;\n} __packed;\n\nstruct cp2112_write_read_req_report {\n\tu8 report;\t/* CP2112_DATA_WRITE_READ_REQUEST */\n\tu8 slave_address;\n\t__be16 length;\n\tu8 target_address_length;\n\tu8 target_address[16];\n} __packed;\n\nstruct cp2112_write_req_report {\n\tu8 report;\t/* CP2112_DATA_WRITE_REQUEST */\n\tu8 slave_address;\n\tu8 length;\n\tu8 data[61];\n} __packed;\n\nstruct cp2112_force_read_report {\n\tu8 report;\t/* CP2112_DATA_READ_FORCE_SEND */\n\t__be16 length;\n} __packed;\n\nstruct cp2112_xfer_status_report {\n\tu8 report;\t/* CP2112_TRANSFER_STATUS_RESPONSE */\n\tu8 status0;\t/* STATUS0_* */\n\tu8 status1;\t/* STATUS1_* */\n\t__be16 retries;\n\t__be16 length;\n} __packed;\n\nstruct cp2112_string_report {\n\tu8 dummy;\t\t/* force .string to be aligned */\n\tu8 report;\t\t/* CP2112_*_STRING */\n\tu8 length;\t\t/* length in bytes of everyting after .report */\n\tu8 type;\t\t/* USB_DT_STRING */\n\twchar_t string[30];\t/* UTF16_LITTLE_ENDIAN string */\n} __packed;\n\n/* Number of times to request transfer status before giving up waiting for a\n   transfer to complete. This may need to be changed if SMBUS clock, retries,\n   or read/write/scl_low timeout settings are changed. */\nstatic const int XFER_STATUS_RETRIES = 10;\n\n/* Time in ms to wait for a CP2112_DATA_READ_RESPONSE or\n   CP2112_TRANSFER_STATUS_RESPONSE. */\nstatic const int RESPONSE_TIMEOUT = 50;\n\nstatic const struct hid_device_id cp2112_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYGNAL, USB_DEVICE_ID_CYGNAL_CP2112) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, cp2112_devices);\n\nstruct cp2112_device {\n\tstruct i2c_adapter adap;\n\tstruct hid_device *hdev;\n\twait_queue_head_t wait;\n\tu8 read_data[61];\n\tu8 read_length;\n\tu8 hwversion;\n\tint xfer_status;\n\tatomic_t read_avail;\n\tatomic_t xfer_avail;\n\tstruct gpio_chip gc;\n\tu8 *in_out_buffer;\n\tstruct mutex lock;\n\n\tstruct gpio_desc *desc[8];\n\tbool gpio_poll;\n\tstruct delayed_work gpio_poll_worker;\n\tunsigned long irq_mask;\n\tu8 gpio_prev_state;\n};\n\nstatic int gpio_push_pull = 0xFF;\nmodule_param(gpio_push_pull, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(gpio_push_pull, \"GPIO push-pull configuration bitmask\");\n\nstatic int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\n\tmutex_lock(&dev->lock);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tbuf[1] &= ~(1 << offset);\n\tbuf[2] = gpio_push_pull;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = 0;\n\nexit:\n\tmutex_unlock(&dev->lock);\n\treturn ret <= 0 ? ret : -EIO;\n}\n\nstatic void cp2112_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\n\tmutex_lock(&dev->lock);\n\n\tbuf[0] = CP2112_GPIO_SET;\n\tbuf[1] = value ? 0xff : 0;\n\tbuf[2] = 1 << offset;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_SET, buf,\n\t\t\t\t CP2112_GPIO_SET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0)\n\t\thid_err(hdev, \"error setting GPIO values: %d\\n\", ret);\n\n\tmutex_unlock(&dev->lock);\n}\n\nstatic int cp2112_gpio_get_all(struct gpio_chip *chip)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\n\tmutex_lock(&dev->lock);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,\n\t\t\t\t CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_GET_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO values: %d\\n\", ret);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tgoto exit;\n\t}\n\n\tret = buf[1];\n\nexit:\n\tmutex_unlock(&dev->lock);\n\n\treturn ret;\n}\n\nstatic int cp2112_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tint ret;\n\n\tret = cp2112_gpio_get_all(chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn (ret >> offset) & 1;\n}\n\nstatic int cp2112_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned offset, int value)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\n\tmutex_lock(&dev->lock);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tbuf[1] |= 1 << offset;\n\tbuf[2] = gpio_push_pull;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tmutex_unlock(&dev->lock);\n\n\t/*\n\t * Set gpio value when output direction is already set,\n\t * as specified in AN495, Rev. 0.2, cpt. 4.4\n\t */\n\tcp2112_gpio_set(chip, offset, value);\n\n\treturn 0;\n\nfail:\n\tmutex_unlock(&dev->lock);\n\treturn ret < 0 ? ret : -EIO;\n}\n\nstatic int cp2112_hid_get(struct hid_device *hdev, unsigned char report_number,\n\t\t\t  u8 *data, size_t count, unsigned char report_type)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmalloc(count, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = hid_hw_raw_request(hdev, report_number, buf, count,\n\t\t\t\t       report_type, HID_REQ_GET_REPORT);\n\tmemcpy(data, buf, count);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int cp2112_hid_output(struct hid_device *hdev, u8 *data, size_t count,\n\t\t\t     unsigned char report_type)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmemdup(data, count, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (report_type == HID_OUTPUT_REPORT)\n\t\tret = hid_hw_output_report(hdev, buf, count);\n\telse\n\t\tret = hid_hw_raw_request(hdev, buf[0], buf, count, report_type,\n\t\t\t\tHID_REQ_SET_REPORT);\n\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int cp2112_wait(struct cp2112_device *dev, atomic_t *avail)\n{\n\tint ret = 0;\n\n\t/* We have sent either a CP2112_TRANSFER_STATUS_REQUEST or a\n\t * CP2112_DATA_READ_FORCE_SEND and we are waiting for the response to\n\t * come in cp2112_raw_event or timeout. There will only be one of these\n\t * in flight at any one time. The timeout is extremely large and is a\n\t * last resort if the CP2112 has died. If we do timeout we don't expect\n\t * to receive the response which would cause data races, it's not like\n\t * we can do anything about it anyway.\n\t */\n\tret = wait_event_interruptible_timeout(dev->wait,\n\t\tatomic_read(avail), msecs_to_jiffies(RESPONSE_TIMEOUT));\n\tif (-ERESTARTSYS == ret)\n\t\treturn ret;\n\tif (!ret)\n\t\treturn -ETIMEDOUT;\n\n\tatomic_set(avail, 0);\n\treturn 0;\n}\n\nstatic int cp2112_xfer_status(struct cp2112_device *dev)\n{\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 buf[2];\n\tint ret;\n\n\tbuf[0] = CP2112_TRANSFER_STATUS_REQUEST;\n\tbuf[1] = 0x01;\n\tatomic_set(&dev->xfer_avail, 0);\n\n\tret = cp2112_hid_output(hdev, buf, 2, HID_OUTPUT_REPORT);\n\tif (ret < 0) {\n\t\thid_warn(hdev, \"Error requesting status: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = cp2112_wait(dev, &dev->xfer_avail);\n\tif (ret)\n\t\treturn ret;\n\n\treturn dev->xfer_status;\n}\n\nstatic int cp2112_read(struct cp2112_device *dev, u8 *data, size_t size)\n{\n\tstruct hid_device *hdev = dev->hdev;\n\tstruct cp2112_force_read_report report;\n\tint ret;\n\n\tif (size > sizeof(dev->read_data))\n\t\tsize = sizeof(dev->read_data);\n\treport.report = CP2112_DATA_READ_FORCE_SEND;\n\treport.length = cpu_to_be16(size);\n\n\tatomic_set(&dev->read_avail, 0);\n\n\tret = cp2112_hid_output(hdev, &report.report, sizeof(report),\n\t\t\t\tHID_OUTPUT_REPORT);\n\tif (ret < 0) {\n\t\thid_warn(hdev, \"Error requesting data: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = cp2112_wait(dev, &dev->read_avail);\n\tif (ret)\n\t\treturn ret;\n\n\thid_dbg(hdev, \"read %d of %zd bytes requested\\n\",\n\t\tdev->read_length, size);\n\n\tif (size > dev->read_length)\n\t\tsize = dev->read_length;\n\n\tmemcpy(data, dev->read_data, size);\n\treturn dev->read_length;\n}\n\nstatic int cp2112_read_req(void *buf, u8 slave_address, u16 length)\n{\n\tstruct cp2112_read_req_report *report = buf;\n\n\tif (length < 1 || length > 512)\n\t\treturn -EINVAL;\n\n\treport->report = CP2112_DATA_READ_REQUEST;\n\treport->slave_address = slave_address << 1;\n\treport->length = cpu_to_be16(length);\n\treturn sizeof(*report);\n}\n\nstatic int cp2112_write_read_req(void *buf, u8 slave_address, u16 length,\n\t\t\t\t u8 command, u8 *data, u8 data_length)\n{\n\tstruct cp2112_write_read_req_report *report = buf;\n\n\tif (length < 1 || length > 512\n\t    || data_length > sizeof(report->target_address) - 1)\n\t\treturn -EINVAL;\n\n\treport->report = CP2112_DATA_WRITE_READ_REQUEST;\n\treport->slave_address = slave_address << 1;\n\treport->length = cpu_to_be16(length);\n\treport->target_address_length = data_length + 1;\n\treport->target_address[0] = command;\n\tmemcpy(&report->target_address[1], data, data_length);\n\treturn data_length + 6;\n}\n\nstatic int cp2112_write_req(void *buf, u8 slave_address, u8 command, u8 *data,\n\t\t\t    u8 data_length)\n{\n\tstruct cp2112_write_req_report *report = buf;\n\n\tif (data_length > sizeof(report->data) - 1)\n\t\treturn -EINVAL;\n\n\treport->report = CP2112_DATA_WRITE_REQUEST;\n\treport->slave_address = slave_address << 1;\n\treport->length = data_length + 1;\n\treport->data[0] = command;\n\tmemcpy(&report->data[1], data, data_length);\n\treturn data_length + 4;\n}\n\nstatic int cp2112_i2c_write_req(void *buf, u8 slave_address, u8 *data,\n\t\t\t\tu8 data_length)\n{\n\tstruct cp2112_write_req_report *report = buf;\n\n\tif (data_length > sizeof(report->data))\n\t\treturn -EINVAL;\n\n\treport->report = CP2112_DATA_WRITE_REQUEST;\n\treport->slave_address = slave_address << 1;\n\treport->length = data_length;\n\tmemcpy(report->data, data, data_length);\n\treturn data_length + 3;\n}\n\nstatic int cp2112_i2c_write_read_req(void *buf, u8 slave_address,\n\t\t\t\t     u8 *addr, int addr_length,\n\t\t\t\t     int read_length)\n{\n\tstruct cp2112_write_read_req_report *report = buf;\n\n\tif (read_length < 1 || read_length > 512 ||\n\t    addr_length > sizeof(report->target_address))\n\t\treturn -EINVAL;\n\n\treport->report = CP2112_DATA_WRITE_READ_REQUEST;\n\treport->slave_address = slave_address << 1;\n\treport->length = cpu_to_be16(read_length);\n\treport->target_address_length = addr_length;\n\tmemcpy(report->target_address, addr, addr_length);\n\treturn addr_length + 5;\n}\n\nstatic int cp2112_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\t   int num)\n{\n\tstruct cp2112_device *dev = (struct cp2112_device *)adap->algo_data;\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 buf[64];\n\tssize_t count;\n\tssize_t read_length = 0;\n\tu8 *read_buf = NULL;\n\tunsigned int retries;\n\tint ret;\n\n\thid_dbg(hdev, \"I2C %d messages\\n\", num);\n\n\tif (num == 1) {\n\t\tif (msgs->flags & I2C_M_RD) {\n\t\t\thid_dbg(hdev, \"I2C read %#04x len %d\\n\",\n\t\t\t\tmsgs->addr, msgs->len);\n\t\t\tread_length = msgs->len;\n\t\t\tread_buf = msgs->buf;\n\t\t\tcount = cp2112_read_req(buf, msgs->addr, msgs->len);\n\t\t} else {\n\t\t\thid_dbg(hdev, \"I2C write %#04x len %d\\n\",\n\t\t\t\tmsgs->addr, msgs->len);\n\t\t\tcount = cp2112_i2c_write_req(buf, msgs->addr,\n\t\t\t\t\t\t     msgs->buf, msgs->len);\n\t\t}\n\t\tif (count < 0)\n\t\t\treturn count;\n\t} else if (dev->hwversion > 1 &&  /* no repeated start in rev 1 */\n\t\t   num == 2 &&\n\t\t   msgs[0].addr == msgs[1].addr &&\n\t\t   !(msgs[0].flags & I2C_M_RD) && (msgs[1].flags & I2C_M_RD)) {\n\t\thid_dbg(hdev, \"I2C write-read %#04x wlen %d rlen %d\\n\",\n\t\t\tmsgs[0].addr, msgs[0].len, msgs[1].len);\n\t\tread_length = msgs[1].len;\n\t\tread_buf = msgs[1].buf;\n\t\tcount = cp2112_i2c_write_read_req(buf, msgs[0].addr,\n\t\t\t\tmsgs[0].buf, msgs[0].len, msgs[1].len);\n\t\tif (count < 0)\n\t\t\treturn count;\n\t} else {\n\t\thid_err(hdev,\n\t\t\t\"Multi-message I2C transactions not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = hid_hw_power(hdev, PM_HINT_FULLON);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"power management error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = cp2112_hid_output(hdev, buf, count, HID_OUTPUT_REPORT);\n\tif (ret < 0) {\n\t\thid_warn(hdev, \"Error starting transaction: %d\\n\", ret);\n\t\tgoto power_normal;\n\t}\n\n\tfor (retries = 0; retries < XFER_STATUS_RETRIES; ++retries) {\n\t\tret = cp2112_xfer_status(dev);\n\t\tif (-EBUSY == ret)\n\t\t\tcontinue;\n\t\tif (ret < 0)\n\t\t\tgoto power_normal;\n\t\tbreak;\n\t}\n\n\tif (XFER_STATUS_RETRIES <= retries) {\n\t\thid_warn(hdev, \"Transfer timed out, cancelling.\\n\");\n\t\tbuf[0] = CP2112_CANCEL_TRANSFER;\n\t\tbuf[1] = 0x01;\n\n\t\tret = cp2112_hid_output(hdev, buf, 2, HID_OUTPUT_REPORT);\n\t\tif (ret < 0)\n\t\t\thid_warn(hdev, \"Error cancelling transaction: %d\\n\",\n\t\t\t\t ret);\n\n\t\tret = -ETIMEDOUT;\n\t\tgoto power_normal;\n\t}\n\n\tfor (count = 0; count < read_length;) {\n\t\tret = cp2112_read(dev, read_buf + count, read_length - count);\n\t\tif (ret < 0)\n\t\t\tgoto power_normal;\n\t\tif (ret == 0) {\n\t\t\thid_err(hdev, \"read returned 0\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto power_normal;\n\t\t}\n\t\tcount += ret;\n\t\tif (count > read_length) {\n\t\t\t/*\n\t\t\t * The hardware returned too much data.\n\t\t\t * This is mostly harmless because cp2112_read()\n\t\t\t * has a limit check so didn't overrun our\n\t\t\t * buffer.  Nevertheless, we return an error\n\t\t\t * because something is seriously wrong and\n\t\t\t * it shouldn't go unnoticed.\n\t\t\t */\n\t\t\thid_err(hdev, \"long read: %d > %zd\\n\",\n\t\t\t\tret, read_length - count + ret);\n\t\t\tret = -EIO;\n\t\t\tgoto power_normal;\n\t\t}\n\t}\n\n\t/* return the number of transferred messages */\n\tret = num;\n\npower_normal:\n\thid_hw_power(hdev, PM_HINT_NORMAL);\n\thid_dbg(hdev, \"I2C transfer finished: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int cp2112_xfer(struct i2c_adapter *adap, u16 addr,\n\t\t       unsigned short flags, char read_write, u8 command,\n\t\t       int size, union i2c_smbus_data *data)\n{\n\tstruct cp2112_device *dev = (struct cp2112_device *)adap->algo_data;\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 buf[64];\n\t__le16 word;\n\tssize_t count;\n\tsize_t read_length = 0;\n\tunsigned int retries;\n\tint ret;\n\n\thid_dbg(hdev, \"%s addr 0x%x flags 0x%x cmd 0x%x size %d\\n\",\n\t\tread_write == I2C_SMBUS_WRITE ? \"write\" : \"read\",\n\t\taddr, flags, command, size);\n\n\tswitch (size) {\n\tcase I2C_SMBUS_BYTE:\n\t\tread_length = 1;\n\n\t\tif (I2C_SMBUS_READ == read_write)\n\t\t\tcount = cp2112_read_req(buf, addr, read_length);\n\t\telse\n\t\t\tcount = cp2112_write_req(buf, addr, command, NULL,\n\t\t\t\t\t\t 0);\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tread_length = 1;\n\n\t\tif (I2C_SMBUS_READ == read_write)\n\t\t\tcount = cp2112_write_read_req(buf, addr, read_length,\n\t\t\t\t\t\t      command, NULL, 0);\n\t\telse\n\t\t\tcount = cp2112_write_req(buf, addr, command,\n\t\t\t\t\t\t &data->byte, 1);\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tread_length = 2;\n\t\tword = cpu_to_le16(data->word);\n\n\t\tif (I2C_SMBUS_READ == read_write)\n\t\t\tcount = cp2112_write_read_req(buf, addr, read_length,\n\t\t\t\t\t\t      command, NULL, 0);\n\t\telse\n\t\t\tcount = cp2112_write_req(buf, addr, command,\n\t\t\t\t\t\t (u8 *)&word, 2);\n\t\tbreak;\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tsize = I2C_SMBUS_WORD_DATA;\n\t\tread_write = I2C_SMBUS_READ;\n\t\tread_length = 2;\n\t\tword = cpu_to_le16(data->word);\n\n\t\tcount = cp2112_write_read_req(buf, addr, read_length, command,\n\t\t\t\t\t      (u8 *)&word, 2);\n\t\tbreak;\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\tsize = I2C_SMBUS_BLOCK_DATA;\n\t\t/* fallthrough */\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (I2C_SMBUS_READ == read_write) {\n\t\t\tcount = cp2112_write_read_req(buf, addr,\n\t\t\t\t\t\t      I2C_SMBUS_BLOCK_MAX,\n\t\t\t\t\t\t      command, NULL, 0);\n\t\t} else {\n\t\t\tcount = cp2112_write_req(buf, addr, command,\n\t\t\t\t\t\t data->block,\n\t\t\t\t\t\t data->block[0] + 1);\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tsize = I2C_SMBUS_BLOCK_DATA;\n\t\tread_write = I2C_SMBUS_READ;\n\n\t\tcount = cp2112_write_read_req(buf, addr, I2C_SMBUS_BLOCK_MAX,\n\t\t\t\t\t      command, data->block,\n\t\t\t\t\t      data->block[0] + 1);\n\t\tbreak;\n\tdefault:\n\t\thid_warn(hdev, \"Unsupported transaction %d\\n\", size);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (count < 0)\n\t\treturn count;\n\n\tret = hid_hw_power(hdev, PM_HINT_FULLON);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"power management error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = cp2112_hid_output(hdev, buf, count, HID_OUTPUT_REPORT);\n\tif (ret < 0) {\n\t\thid_warn(hdev, \"Error starting transaction: %d\\n\", ret);\n\t\tgoto power_normal;\n\t}\n\n\tfor (retries = 0; retries < XFER_STATUS_RETRIES; ++retries) {\n\t\tret = cp2112_xfer_status(dev);\n\t\tif (-EBUSY == ret)\n\t\t\tcontinue;\n\t\tif (ret < 0)\n\t\t\tgoto power_normal;\n\t\tbreak;\n\t}\n\n\tif (XFER_STATUS_RETRIES <= retries) {\n\t\thid_warn(hdev, \"Transfer timed out, cancelling.\\n\");\n\t\tbuf[0] = CP2112_CANCEL_TRANSFER;\n\t\tbuf[1] = 0x01;\n\n\t\tret = cp2112_hid_output(hdev, buf, 2, HID_OUTPUT_REPORT);\n\t\tif (ret < 0)\n\t\t\thid_warn(hdev, \"Error cancelling transaction: %d\\n\",\n\t\t\t\t ret);\n\n\t\tret = -ETIMEDOUT;\n\t\tgoto power_normal;\n\t}\n\n\tif (I2C_SMBUS_WRITE == read_write) {\n\t\tret = 0;\n\t\tgoto power_normal;\n\t}\n\n\tif (I2C_SMBUS_BLOCK_DATA == size)\n\t\tread_length = ret;\n\n\tret = cp2112_read(dev, buf, read_length);\n\tif (ret < 0)\n\t\tgoto power_normal;\n\tif (ret != read_length) {\n\t\thid_warn(hdev, \"short read: %d < %zd\\n\", ret, read_length);\n\t\tret = -EIO;\n\t\tgoto power_normal;\n\t}\n\n\tswitch (size) {\n\tcase I2C_SMBUS_BYTE:\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tdata->byte = buf[0];\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tdata->word = le16_to_cpup((__le16 *)buf);\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (read_length > I2C_SMBUS_BLOCK_MAX) {\n\t\t\tret = -EPROTO;\n\t\t\tgoto power_normal;\n\t\t}\n\n\t\tmemcpy(data->block, buf, read_length);\n\t\tbreak;\n\t}\n\n\tret = 0;\npower_normal:\n\thid_hw_power(hdev, PM_HINT_NORMAL);\n\thid_dbg(hdev, \"transfer finished: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic u32 cp2112_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C |\n\t\tI2C_FUNC_SMBUS_BYTE |\n\t\tI2C_FUNC_SMBUS_BYTE_DATA |\n\t\tI2C_FUNC_SMBUS_WORD_DATA |\n\t\tI2C_FUNC_SMBUS_BLOCK_DATA |\n\t\tI2C_FUNC_SMBUS_I2C_BLOCK |\n\t\tI2C_FUNC_SMBUS_PROC_CALL |\n\t\tI2C_FUNC_SMBUS_BLOCK_PROC_CALL;\n}\n\nstatic const struct i2c_algorithm smbus_algorithm = {\n\t.master_xfer\t= cp2112_i2c_xfer,\n\t.smbus_xfer\t= cp2112_xfer,\n\t.functionality\t= cp2112_functionality,\n};\n\nstatic int cp2112_get_usb_config(struct hid_device *hdev,\n\t\t\t\t struct cp2112_usb_config_report *cfg)\n{\n\tint ret;\n\n\tret = cp2112_hid_get(hdev, CP2112_USB_CONFIG, (u8 *)cfg, sizeof(*cfg),\n\t\t\t     HID_FEATURE_REPORT);\n\tif (ret != sizeof(*cfg)) {\n\t\thid_err(hdev, \"error reading usb config: %d\\n\", ret);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int cp2112_set_usb_config(struct hid_device *hdev,\n\t\t\t\t struct cp2112_usb_config_report *cfg)\n{\n\tint ret;\n\n\tBUG_ON(cfg->report != CP2112_USB_CONFIG);\n\n\tret = cp2112_hid_output(hdev, (u8 *)cfg, sizeof(*cfg),\n\t\t\t\tHID_FEATURE_REPORT);\n\tif (ret != sizeof(*cfg)) {\n\t\thid_err(hdev, \"error writing usb config: %d\\n\", ret);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void chmod_sysfs_attrs(struct hid_device *hdev);\n\n#define CP2112_CONFIG_ATTR(name, store, format, ...) \\\nstatic ssize_t name##_store(struct device *kdev, \\\n\t\t\t    struct device_attribute *attr, const char *buf, \\\n\t\t\t    size_t count) \\\n{ \\\n\tstruct hid_device *hdev = to_hid_device(kdev); \\\n\tstruct cp2112_usb_config_report cfg; \\\n\tint ret = cp2112_get_usb_config(hdev, &cfg); \\\n\tif (ret) \\\n\t\treturn ret; \\\n\tstore; \\\n\tret = cp2112_set_usb_config(hdev, &cfg); \\\n\tif (ret) \\\n\t\treturn ret; \\\n\tchmod_sysfs_attrs(hdev); \\\n\treturn count; \\\n} \\\nstatic ssize_t name##_show(struct device *kdev, \\\n\t\t\t   struct device_attribute *attr, char *buf) \\\n{ \\\n\tstruct hid_device *hdev = to_hid_device(kdev); \\\n\tstruct cp2112_usb_config_report cfg; \\\n\tint ret = cp2112_get_usb_config(hdev, &cfg); \\\n\tif (ret) \\\n\t\treturn ret; \\\n\treturn scnprintf(buf, PAGE_SIZE, format, ##__VA_ARGS__); \\\n} \\\nstatic DEVICE_ATTR_RW(name);\n\nCP2112_CONFIG_ATTR(vendor_id, ({\n\tu16 vid;\n\n\tif (sscanf(buf, \"%hi\", &vid) != 1)\n\t\treturn -EINVAL;\n\n\tcfg.vid = cpu_to_le16(vid);\n\tcfg.mask = 0x01;\n}), \"0x%04x\\n\", le16_to_cpu(cfg.vid));\n\nCP2112_CONFIG_ATTR(product_id, ({\n\tu16 pid;\n\n\tif (sscanf(buf, \"%hi\", &pid) != 1)\n\t\treturn -EINVAL;\n\n\tcfg.pid = cpu_to_le16(pid);\n\tcfg.mask = 0x02;\n}), \"0x%04x\\n\", le16_to_cpu(cfg.pid));\n\nCP2112_CONFIG_ATTR(max_power, ({\n\tint mA;\n\n\tif (sscanf(buf, \"%i\", &mA) != 1)\n\t\treturn -EINVAL;\n\n\tcfg.max_power = (mA + 1) / 2;\n\tcfg.mask = 0x04;\n}), \"%u mA\\n\", cfg.max_power * 2);\n\nCP2112_CONFIG_ATTR(power_mode, ({\n\tif (sscanf(buf, \"%hhi\", &cfg.power_mode) != 1)\n\t\treturn -EINVAL;\n\n\tcfg.mask = 0x08;\n}), \"%u\\n\", cfg.power_mode);\n\nCP2112_CONFIG_ATTR(release_version, ({\n\tif (sscanf(buf, \"%hhi.%hhi\", &cfg.release_major, &cfg.release_minor)\n\t    != 2)\n\t\treturn -EINVAL;\n\n\tcfg.mask = 0x10;\n}), \"%u.%u\\n\", cfg.release_major, cfg.release_minor);\n\n#undef CP2112_CONFIG_ATTR\n\nstruct cp2112_pstring_attribute {\n\tstruct device_attribute attr;\n\tunsigned char report;\n};\n\nstatic ssize_t pstr_store(struct device *kdev,\n\t\t\t  struct device_attribute *kattr, const char *buf,\n\t\t\t  size_t count)\n{\n\tstruct hid_device *hdev = to_hid_device(kdev);\n\tstruct cp2112_pstring_attribute *attr =\n\t\tcontainer_of(kattr, struct cp2112_pstring_attribute, attr);\n\tstruct cp2112_string_report report;\n\tint ret;\n\n\tmemset(&report, 0, sizeof(report));\n\n\tret = utf8s_to_utf16s(buf, count, UTF16_LITTLE_ENDIAN,\n\t\t\t      report.string, ARRAY_SIZE(report.string));\n\treport.report = attr->report;\n\treport.length = ret * sizeof(report.string[0]) + 2;\n\treport.type = USB_DT_STRING;\n\n\tret = cp2112_hid_output(hdev, &report.report, report.length + 1,\n\t\t\t\tHID_FEATURE_REPORT);\n\tif (ret != report.length + 1) {\n\t\thid_err(hdev, \"error writing %s string: %d\\n\", kattr->attr.name,\n\t\t\tret);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn -EIO;\n\t}\n\n\tchmod_sysfs_attrs(hdev);\n\treturn count;\n}\n\nstatic ssize_t pstr_show(struct device *kdev,\n\t\t\t struct device_attribute *kattr, char *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(kdev);\n\tstruct cp2112_pstring_attribute *attr =\n\t\tcontainer_of(kattr, struct cp2112_pstring_attribute, attr);\n\tstruct cp2112_string_report report;\n\tu8 length;\n\tint ret;\n\n\tret = cp2112_hid_get(hdev, attr->report, &report.report,\n\t\t\t     sizeof(report) - 1, HID_FEATURE_REPORT);\n\tif (ret < 3) {\n\t\thid_err(hdev, \"error reading %s string: %d\\n\", kattr->attr.name,\n\t\t\tret);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn -EIO;\n\t}\n\n\tif (report.length < 2) {\n\t\thid_err(hdev, \"invalid %s string length: %d\\n\",\n\t\t\tkattr->attr.name, report.length);\n\t\treturn -EIO;\n\t}\n\n\tlength = report.length > ret - 1 ? ret - 1 : report.length;\n\tlength = (length - 2) / sizeof(report.string[0]);\n\tret = utf16s_to_utf8s(report.string, length, UTF16_LITTLE_ENDIAN, buf,\n\t\t\t      PAGE_SIZE - 1);\n\tbuf[ret++] = '\\n';\n\treturn ret;\n}\n\n#define CP2112_PSTR_ATTR(name, _report) \\\nstatic struct cp2112_pstring_attribute dev_attr_##name = { \\\n\t.attr = __ATTR(name, (S_IWUSR | S_IRUGO), pstr_show, pstr_store), \\\n\t.report = _report, \\\n};\n\nCP2112_PSTR_ATTR(manufacturer,\tCP2112_MANUFACTURER_STRING);\nCP2112_PSTR_ATTR(product,\tCP2112_PRODUCT_STRING);\nCP2112_PSTR_ATTR(serial,\tCP2112_SERIAL_STRING);\n\n#undef CP2112_PSTR_ATTR\n\nstatic const struct attribute_group cp2112_attr_group = {\n\t.attrs = (struct attribute *[]){\n\t\t&dev_attr_vendor_id.attr,\n\t\t&dev_attr_product_id.attr,\n\t\t&dev_attr_max_power.attr,\n\t\t&dev_attr_power_mode.attr,\n\t\t&dev_attr_release_version.attr,\n\t\t&dev_attr_manufacturer.attr.attr,\n\t\t&dev_attr_product.attr.attr,\n\t\t&dev_attr_serial.attr.attr,\n\t\tNULL\n\t}\n};\n\n/* Chmoding our sysfs attributes is simply a way to expose which fields in the\n * PROM have already been programmed. We do not depend on this preventing\n * writing to these attributes since the CP2112 will simply ignore writes to\n * already-programmed fields. This is why there is no sense in fixing this\n * racy behaviour.\n */\nstatic void chmod_sysfs_attrs(struct hid_device *hdev)\n{\n\tstruct attribute **attr;\n\tu8 buf[2];\n\tint ret;\n\n\tret = cp2112_hid_get(hdev, CP2112_LOCK_BYTE, buf, sizeof(buf),\n\t\t\t     HID_FEATURE_REPORT);\n\tif (ret != sizeof(buf)) {\n\t\thid_err(hdev, \"error reading lock byte: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tfor (attr = cp2112_attr_group.attrs; *attr; ++attr) {\n\t\tumode_t mode = (buf[1] & 1) ? S_IWUSR | S_IRUGO : S_IRUGO;\n\t\tret = sysfs_chmod_file(&hdev->dev.kobj, *attr, mode);\n\t\tif (ret < 0)\n\t\t\thid_err(hdev, \"error chmoding sysfs file %s\\n\",\n\t\t\t\t(*attr)->name);\n\t\tbuf[1] >>= 1;\n\t}\n}\n\nstatic void cp2112_gpio_irq_ack(struct irq_data *d)\n{\n}\n\nstatic void cp2112_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct cp2112_device *dev = gpiochip_get_data(gc);\n\n\t__clear_bit(d->hwirq, &dev->irq_mask);\n}\n\nstatic void cp2112_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct cp2112_device *dev = gpiochip_get_data(gc);\n\n\t__set_bit(d->hwirq, &dev->irq_mask);\n}\n\nstatic void cp2112_gpio_poll_callback(struct work_struct *work)\n{\n\tstruct cp2112_device *dev = container_of(work, struct cp2112_device,\n\t\t\t\t\t\t gpio_poll_worker.work);\n\tstruct irq_data *d;\n\tu8 gpio_mask;\n\tu8 virqs = (u8)dev->irq_mask;\n\tu32 irq_type;\n\tint irq, virq, ret;\n\n\tret = cp2112_gpio_get_all(&dev->gc);\n\tif (ret == -ENODEV) /* the hardware has been disconnected */\n\t\treturn;\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tgpio_mask = ret;\n\n\twhile (virqs) {\n\t\tvirq = ffs(virqs) - 1;\n\t\tvirqs &= ~BIT(virq);\n\n\t\tif (!dev->gc.to_irq)\n\t\t\tbreak;\n\n\t\tirq = dev->gc.to_irq(&dev->gc, virq);\n\n\t\td = irq_get_irq_data(irq);\n\t\tif (!d)\n\t\t\tcontinue;\n\n\t\tirq_type = irqd_get_trigger_type(d);\n\n\t\tif (gpio_mask & BIT(virq)) {\n\t\t\t/* Level High */\n\n\t\t\tif (irq_type & IRQ_TYPE_LEVEL_HIGH)\n\t\t\t\thandle_nested_irq(irq);\n\n\t\t\tif ((irq_type & IRQ_TYPE_EDGE_RISING) &&\n\t\t\t    !(dev->gpio_prev_state & BIT(virq)))\n\t\t\t\thandle_nested_irq(irq);\n\t\t} else {\n\t\t\t/* Level Low */\n\n\t\t\tif (irq_type & IRQ_TYPE_LEVEL_LOW)\n\t\t\t\thandle_nested_irq(irq);\n\n\t\t\tif ((irq_type & IRQ_TYPE_EDGE_FALLING) &&\n\t\t\t    (dev->gpio_prev_state & BIT(virq)))\n\t\t\t\thandle_nested_irq(irq);\n\t\t}\n\t}\n\n\tdev->gpio_prev_state = gpio_mask;\n\nexit:\n\tif (dev->gpio_poll)\n\t\tschedule_delayed_work(&dev->gpio_poll_worker, 10);\n}\n\n\nstatic unsigned int cp2112_gpio_irq_startup(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct cp2112_device *dev = gpiochip_get_data(gc);\n\n\tINIT_DELAYED_WORK(&dev->gpio_poll_worker, cp2112_gpio_poll_callback);\n\n\tcp2112_gpio_direction_input(gc, d->hwirq);\n\n\tif (!dev->gpio_poll) {\n\t\tdev->gpio_poll = true;\n\t\tschedule_delayed_work(&dev->gpio_poll_worker, 0);\n\t}\n\n\tcp2112_gpio_irq_unmask(d);\n\treturn 0;\n}\n\nstatic void cp2112_gpio_irq_shutdown(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct cp2112_device *dev = gpiochip_get_data(gc);\n\n\tcancel_delayed_work_sync(&dev->gpio_poll_worker);\n}\n\nstatic int cp2112_gpio_irq_type(struct irq_data *d, unsigned int type)\n{\n\treturn 0;\n}\n\nstatic struct irq_chip cp2112_gpio_irqchip = {\n\t.name = \"cp2112-gpio\",\n\t.irq_startup = cp2112_gpio_irq_startup,\n\t.irq_shutdown = cp2112_gpio_irq_shutdown,\n\t.irq_ack = cp2112_gpio_irq_ack,\n\t.irq_mask = cp2112_gpio_irq_mask,\n\t.irq_unmask = cp2112_gpio_irq_unmask,\n\t.irq_set_type = cp2112_gpio_irq_type,\n};\n\nstatic int __maybe_unused cp2112_allocate_irq(struct cp2112_device *dev,\n\t\t\t\t\t      int pin)\n{\n\tint ret;\n\n\tif (dev->desc[pin])\n\t\treturn -EINVAL;\n\n\tdev->desc[pin] = gpiochip_request_own_desc(&dev->gc, pin,\n\t\t\t\t\t\t   \"HID/I2C:Event\");\n\tif (IS_ERR(dev->desc[pin])) {\n\t\tdev_err(dev->gc.parent, \"Failed to request GPIO\\n\");\n\t\treturn PTR_ERR(dev->desc[pin]);\n\t}\n\n\tret = gpiochip_lock_as_irq(&dev->gc, pin);\n\tif (ret) {\n\t\tdev_err(dev->gc.parent, \"Failed to lock GPIO as interrupt\\n\");\n\t\tgoto err_desc;\n\t}\n\n\tret = gpiod_to_irq(dev->desc[pin]);\n\tif (ret < 0) {\n\t\tdev_err(dev->gc.parent, \"Failed to translate GPIO to IRQ\\n\");\n\t\tgoto err_lock;\n\t}\n\n\treturn ret;\n\nerr_lock:\n\tgpiochip_unlock_as_irq(&dev->gc, pin);\nerr_desc:\n\tgpiochip_free_own_desc(dev->desc[pin]);\n\tdev->desc[pin] = NULL;\n\treturn ret;\n}\n\nstatic int cp2112_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct cp2112_device *dev;\n\tu8 buf[3];\n\tstruct cp2112_smbus_config_report config;\n\tint ret;\n\n\tdev = devm_kzalloc(&hdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->in_out_buffer = devm_kzalloc(&hdev->dev, CP2112_REPORT_MAX_LENGTH,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!dev->in_out_buffer)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&dev->lock);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_open(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"hw open failed\\n\");\n\t\tgoto err_hid_stop;\n\t}\n\n\tret = hid_hw_power(hdev, PM_HINT_FULLON);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"power management error: %d\\n\", ret);\n\t\tgoto err_hid_close;\n\t}\n\n\tret = cp2112_hid_get(hdev, CP2112_GET_VERSION_INFO, buf, sizeof(buf),\n\t\t\t     HID_FEATURE_REPORT);\n\tif (ret != sizeof(buf)) {\n\t\thid_err(hdev, \"error requesting version\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto err_power_normal;\n\t}\n\n\thid_info(hdev, \"Part Number: 0x%02X Device Version: 0x%02X\\n\",\n\t\t buf[1], buf[2]);\n\n\tret = cp2112_hid_get(hdev, CP2112_SMBUS_CONFIG, (u8 *)&config,\n\t\t\t     sizeof(config), HID_FEATURE_REPORT);\n\tif (ret != sizeof(config)) {\n\t\thid_err(hdev, \"error requesting SMBus config\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto err_power_normal;\n\t}\n\n\tconfig.retry_time = cpu_to_be16(1);\n\n\tret = cp2112_hid_output(hdev, (u8 *)&config, sizeof(config),\n\t\t\t\tHID_FEATURE_REPORT);\n\tif (ret != sizeof(config)) {\n\t\thid_err(hdev, \"error setting SMBus config\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto err_power_normal;\n\t}\n\n\thid_set_drvdata(hdev, (void *)dev);\n\tdev->hdev\t\t= hdev;\n\tdev->adap.owner\t\t= THIS_MODULE;\n\tdev->adap.class\t\t= I2C_CLASS_HWMON;\n\tdev->adap.algo\t\t= &smbus_algorithm;\n\tdev->adap.algo_data\t= dev;\n\tdev->adap.dev.parent\t= &hdev->dev;\n\tsnprintf(dev->adap.name, sizeof(dev->adap.name),\n\t\t \"CP2112 SMBus Bridge on hiddev%d\", hdev->minor);\n\tdev->hwversion = buf[2];\n\tinit_waitqueue_head(&dev->wait);\n\n\thid_device_io_start(hdev);\n\tret = i2c_add_adapter(&dev->adap);\n\thid_device_io_stop(hdev);\n\n\tif (ret) {\n\t\thid_err(hdev, \"error registering i2c adapter\\n\");\n\t\tgoto err_power_normal;\n\t}\n\n\thid_dbg(hdev, \"adapter registered\\n\");\n\n\tdev->gc.label\t\t\t= \"cp2112_gpio\";\n\tdev->gc.direction_input\t\t= cp2112_gpio_direction_input;\n\tdev->gc.direction_output\t= cp2112_gpio_direction_output;\n\tdev->gc.set\t\t\t= cp2112_gpio_set;\n\tdev->gc.get\t\t\t= cp2112_gpio_get;\n\tdev->gc.base\t\t\t= -1;\n\tdev->gc.ngpio\t\t\t= 8;\n\tdev->gc.can_sleep\t\t= 1;\n\tdev->gc.parent\t\t\t= &hdev->dev;\n\n\tret = gpiochip_add_data(&dev->gc, dev);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error registering gpio chip\\n\");\n\t\tgoto err_free_i2c;\n\t}\n\n\tret = sysfs_create_group(&hdev->dev.kobj, &cp2112_attr_group);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error creating sysfs attrs\\n\");\n\t\tgoto err_gpiochip_remove;\n\t}\n\n\tchmod_sysfs_attrs(hdev);\n\thid_hw_power(hdev, PM_HINT_NORMAL);\n\n\tret = gpiochip_irqchip_add(&dev->gc, &cp2112_gpio_irqchip, 0,\n\t\t\t\t   handle_simple_irq, IRQ_TYPE_NONE);\n\tif (ret) {\n\t\tdev_err(dev->gc.parent, \"failed to add IRQ chip\\n\");\n\t\tgoto err_sysfs_remove;\n\t}\n\n\treturn ret;\n\nerr_sysfs_remove:\n\tsysfs_remove_group(&hdev->dev.kobj, &cp2112_attr_group);\nerr_gpiochip_remove:\n\tgpiochip_remove(&dev->gc);\nerr_free_i2c:\n\ti2c_del_adapter(&dev->adap);\nerr_power_normal:\n\thid_hw_power(hdev, PM_HINT_NORMAL);\nerr_hid_close:\n\thid_hw_close(hdev);\nerr_hid_stop:\n\thid_hw_stop(hdev);\n\treturn ret;\n}\n\nstatic void cp2112_remove(struct hid_device *hdev)\n{\n\tstruct cp2112_device *dev = hid_get_drvdata(hdev);\n\tint i;\n\n\tsysfs_remove_group(&hdev->dev.kobj, &cp2112_attr_group);\n\ti2c_del_adapter(&dev->adap);\n\n\tif (dev->gpio_poll) {\n\t\tdev->gpio_poll = false;\n\t\tcancel_delayed_work_sync(&dev->gpio_poll_worker);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(dev->desc); i++) {\n\t\tgpiochip_unlock_as_irq(&dev->gc, i);\n\t\tgpiochip_free_own_desc(dev->desc[i]);\n\t}\n\n\tgpiochip_remove(&dev->gc);\n\t/* i2c_del_adapter has finished removing all i2c devices from our\n\t * adapter. Well behaved devices should no longer call our cp2112_xfer\n\t * and should have waited for any pending calls to finish. It has also\n\t * waited for device_unregister(&adap->dev) to complete. Therefore we\n\t * can safely free our struct cp2112_device.\n\t */\n\thid_hw_close(hdev);\n\thid_hw_stop(hdev);\n}\n\nstatic int cp2112_raw_event(struct hid_device *hdev, struct hid_report *report,\n\t\t\t    u8 *data, int size)\n{\n\tstruct cp2112_device *dev = hid_get_drvdata(hdev);\n\tstruct cp2112_xfer_status_report *xfer = (void *)data;\n\n\tswitch (data[0]) {\n\tcase CP2112_TRANSFER_STATUS_RESPONSE:\n\t\thid_dbg(hdev, \"xfer status: %02x %02x %04x %04x\\n\",\n\t\t\txfer->status0, xfer->status1,\n\t\t\tbe16_to_cpu(xfer->retries), be16_to_cpu(xfer->length));\n\n\t\tswitch (xfer->status0) {\n\t\tcase STATUS0_IDLE:\n\t\t\tdev->xfer_status = -EAGAIN;\n\t\t\tbreak;\n\t\tcase STATUS0_BUSY:\n\t\t\tdev->xfer_status = -EBUSY;\n\t\t\tbreak;\n\t\tcase STATUS0_COMPLETE:\n\t\t\tdev->xfer_status = be16_to_cpu(xfer->length);\n\t\t\tbreak;\n\t\tcase STATUS0_ERROR:\n\t\t\tswitch (xfer->status1) {\n\t\t\tcase STATUS1_TIMEOUT_NACK:\n\t\t\tcase STATUS1_TIMEOUT_BUS:\n\t\t\t\tdev->xfer_status = -ETIMEDOUT;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev->xfer_status = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev->xfer_status = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tatomic_set(&dev->xfer_avail, 1);\n\t\tbreak;\n\tcase CP2112_DATA_READ_RESPONSE:\n\t\thid_dbg(hdev, \"read response: %02x %02x\\n\", data[1], data[2]);\n\n\t\tdev->read_length = data[2];\n\t\tif (dev->read_length > sizeof(dev->read_data))\n\t\t\tdev->read_length = sizeof(dev->read_data);\n\n\t\tmemcpy(dev->read_data, &data[3], dev->read_length);\n\t\tatomic_set(&dev->read_avail, 1);\n\t\tbreak;\n\tdefault:\n\t\thid_err(hdev, \"unknown report\\n\");\n\n\t\treturn 0;\n\t}\n\n\twake_up_interruptible(&dev->wait);\n\treturn 1;\n}\n\nstatic struct hid_driver cp2112_driver = {\n\t.name\t\t= \"cp2112\",\n\t.id_table\t= cp2112_devices,\n\t.probe\t\t= cp2112_probe,\n\t.remove\t\t= cp2112_remove,\n\t.raw_event\t= cp2112_raw_event,\n};\n\nmodule_hid_driver(cp2112_driver);\nMODULE_DESCRIPTION(\"Silicon Labs HID USB to SMBus master bridge\");\nMODULE_AUTHOR(\"David Barksdale <dbarksdale@uplogix.com>\");\nMODULE_LICENSE(\"GPL\");\n\n"], "fixing_code": ["/*\n * hid-cp2112.c - Silicon Labs HID USB to SMBus master bridge\n * Copyright (c) 2013,2014 Uplogix, Inc.\n * David Barksdale <dbarksdale@uplogix.com>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms and conditions of the GNU General Public License,\n * version 2, as published by the Free Software Foundation.\n *\n * This program is distributed in the hope it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n * more details.\n */\n\n/*\n * The Silicon Labs CP2112 chip is a USB HID device which provides an\n * SMBus controller for talking to slave devices and 8 GPIO pins. The\n * host communicates with the CP2112 via raw HID reports.\n *\n * Data Sheet:\n *   http://www.silabs.com/Support%20Documents/TechnicalDocs/CP2112.pdf\n * Programming Interface Specification:\n *   http://www.silabs.com/Support%20Documents/TechnicalDocs/AN495.pdf\n */\n\n#include <linux/gpio.h>\n#include <linux/gpio/driver.h>\n#include <linux/hid.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/nls.h>\n#include <linux/usb/ch9.h>\n#include \"hid-ids.h\"\n\n#define CP2112_REPORT_MAX_LENGTH\t\t64\n#define CP2112_GPIO_CONFIG_LENGTH\t\t5\n#define CP2112_GPIO_GET_LENGTH\t\t\t2\n#define CP2112_GPIO_SET_LENGTH\t\t\t3\n\nenum {\n\tCP2112_GPIO_CONFIG\t\t= 0x02,\n\tCP2112_GPIO_GET\t\t\t= 0x03,\n\tCP2112_GPIO_SET\t\t\t= 0x04,\n\tCP2112_GET_VERSION_INFO\t\t= 0x05,\n\tCP2112_SMBUS_CONFIG\t\t= 0x06,\n\tCP2112_DATA_READ_REQUEST\t= 0x10,\n\tCP2112_DATA_WRITE_READ_REQUEST\t= 0x11,\n\tCP2112_DATA_READ_FORCE_SEND\t= 0x12,\n\tCP2112_DATA_READ_RESPONSE\t= 0x13,\n\tCP2112_DATA_WRITE_REQUEST\t= 0x14,\n\tCP2112_TRANSFER_STATUS_REQUEST\t= 0x15,\n\tCP2112_TRANSFER_STATUS_RESPONSE\t= 0x16,\n\tCP2112_CANCEL_TRANSFER\t\t= 0x17,\n\tCP2112_LOCK_BYTE\t\t= 0x20,\n\tCP2112_USB_CONFIG\t\t= 0x21,\n\tCP2112_MANUFACTURER_STRING\t= 0x22,\n\tCP2112_PRODUCT_STRING\t\t= 0x23,\n\tCP2112_SERIAL_STRING\t\t= 0x24,\n};\n\nenum {\n\tSTATUS0_IDLE\t\t= 0x00,\n\tSTATUS0_BUSY\t\t= 0x01,\n\tSTATUS0_COMPLETE\t= 0x02,\n\tSTATUS0_ERROR\t\t= 0x03,\n};\n\nenum {\n\tSTATUS1_TIMEOUT_NACK\t\t= 0x00,\n\tSTATUS1_TIMEOUT_BUS\t\t= 0x01,\n\tSTATUS1_ARBITRATION_LOST\t= 0x02,\n\tSTATUS1_READ_INCOMPLETE\t\t= 0x03,\n\tSTATUS1_WRITE_INCOMPLETE\t= 0x04,\n\tSTATUS1_SUCCESS\t\t\t= 0x05,\n};\n\nstruct cp2112_smbus_config_report {\n\tu8 report;\t\t/* CP2112_SMBUS_CONFIG */\n\t__be32 clock_speed;\t/* Hz */\n\tu8 device_address;\t/* Stored in the upper 7 bits */\n\tu8 auto_send_read;\t/* 1 = enabled, 0 = disabled */\n\t__be16 write_timeout;\t/* ms, 0 = no timeout */\n\t__be16 read_timeout;\t/* ms, 0 = no timeout */\n\tu8 scl_low_timeout;\t/* 1 = enabled, 0 = disabled */\n\t__be16 retry_time;\t/* # of retries, 0 = no limit */\n} __packed;\n\nstruct cp2112_usb_config_report {\n\tu8 report;\t/* CP2112_USB_CONFIG */\n\t__le16 vid;\t/* Vendor ID */\n\t__le16 pid;\t/* Product ID */\n\tu8 max_power;\t/* Power requested in 2mA units */\n\tu8 power_mode;\t/* 0x00 = bus powered\n\t\t\t   0x01 = self powered & regulator off\n\t\t\t   0x02 = self powered & regulator on */\n\tu8 release_major;\n\tu8 release_minor;\n\tu8 mask;\t/* What fields to program */\n} __packed;\n\nstruct cp2112_read_req_report {\n\tu8 report;\t/* CP2112_DATA_READ_REQUEST */\n\tu8 slave_address;\n\t__be16 length;\n} __packed;\n\nstruct cp2112_write_read_req_report {\n\tu8 report;\t/* CP2112_DATA_WRITE_READ_REQUEST */\n\tu8 slave_address;\n\t__be16 length;\n\tu8 target_address_length;\n\tu8 target_address[16];\n} __packed;\n\nstruct cp2112_write_req_report {\n\tu8 report;\t/* CP2112_DATA_WRITE_REQUEST */\n\tu8 slave_address;\n\tu8 length;\n\tu8 data[61];\n} __packed;\n\nstruct cp2112_force_read_report {\n\tu8 report;\t/* CP2112_DATA_READ_FORCE_SEND */\n\t__be16 length;\n} __packed;\n\nstruct cp2112_xfer_status_report {\n\tu8 report;\t/* CP2112_TRANSFER_STATUS_RESPONSE */\n\tu8 status0;\t/* STATUS0_* */\n\tu8 status1;\t/* STATUS1_* */\n\t__be16 retries;\n\t__be16 length;\n} __packed;\n\nstruct cp2112_string_report {\n\tu8 dummy;\t\t/* force .string to be aligned */\n\tu8 report;\t\t/* CP2112_*_STRING */\n\tu8 length;\t\t/* length in bytes of everyting after .report */\n\tu8 type;\t\t/* USB_DT_STRING */\n\twchar_t string[30];\t/* UTF16_LITTLE_ENDIAN string */\n} __packed;\n\n/* Number of times to request transfer status before giving up waiting for a\n   transfer to complete. This may need to be changed if SMBUS clock, retries,\n   or read/write/scl_low timeout settings are changed. */\nstatic const int XFER_STATUS_RETRIES = 10;\n\n/* Time in ms to wait for a CP2112_DATA_READ_RESPONSE or\n   CP2112_TRANSFER_STATUS_RESPONSE. */\nstatic const int RESPONSE_TIMEOUT = 50;\n\nstatic const struct hid_device_id cp2112_devices[] = {\n\t{ HID_USB_DEVICE(USB_VENDOR_ID_CYGNAL, USB_DEVICE_ID_CYGNAL_CP2112) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(hid, cp2112_devices);\n\nstruct cp2112_device {\n\tstruct i2c_adapter adap;\n\tstruct hid_device *hdev;\n\twait_queue_head_t wait;\n\tu8 read_data[61];\n\tu8 read_length;\n\tu8 hwversion;\n\tint xfer_status;\n\tatomic_t read_avail;\n\tatomic_t xfer_avail;\n\tstruct gpio_chip gc;\n\tu8 *in_out_buffer;\n\tstruct mutex lock;\n\n\tstruct gpio_desc *desc[8];\n\tbool gpio_poll;\n\tstruct delayed_work gpio_poll_worker;\n\tunsigned long irq_mask;\n\tu8 gpio_prev_state;\n};\n\nstatic int gpio_push_pull = 0xFF;\nmodule_param(gpio_push_pull, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(gpio_push_pull, \"GPIO push-pull configuration bitmask\");\n\nstatic int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\n\tmutex_lock(&dev->lock);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tbuf[1] &= ~(1 << offset);\n\tbuf[2] = gpio_push_pull;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = 0;\n\nexit:\n\tmutex_unlock(&dev->lock);\n\treturn ret < 0 ? ret : -EIO;\n}\n\nstatic void cp2112_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\n\tmutex_lock(&dev->lock);\n\n\tbuf[0] = CP2112_GPIO_SET;\n\tbuf[1] = value ? 0xff : 0;\n\tbuf[2] = 1 << offset;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_SET, buf,\n\t\t\t\t CP2112_GPIO_SET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0)\n\t\thid_err(hdev, \"error setting GPIO values: %d\\n\", ret);\n\n\tmutex_unlock(&dev->lock);\n}\n\nstatic int cp2112_gpio_get_all(struct gpio_chip *chip)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\n\tmutex_lock(&dev->lock);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,\n\t\t\t\t CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_GET_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO values: %d\\n\", ret);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tgoto exit;\n\t}\n\n\tret = buf[1];\n\nexit:\n\tmutex_unlock(&dev->lock);\n\n\treturn ret;\n}\n\nstatic int cp2112_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tint ret;\n\n\tret = cp2112_gpio_get_all(chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn (ret >> offset) & 1;\n}\n\nstatic int cp2112_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned offset, int value)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\n\tmutex_lock(&dev->lock);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tbuf[1] |= 1 << offset;\n\tbuf[2] = gpio_push_pull;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tmutex_unlock(&dev->lock);\n\n\t/*\n\t * Set gpio value when output direction is already set,\n\t * as specified in AN495, Rev. 0.2, cpt. 4.4\n\t */\n\tcp2112_gpio_set(chip, offset, value);\n\n\treturn 0;\n\nfail:\n\tmutex_unlock(&dev->lock);\n\treturn ret < 0 ? ret : -EIO;\n}\n\nstatic int cp2112_hid_get(struct hid_device *hdev, unsigned char report_number,\n\t\t\t  u8 *data, size_t count, unsigned char report_type)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmalloc(count, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = hid_hw_raw_request(hdev, report_number, buf, count,\n\t\t\t\t       report_type, HID_REQ_GET_REPORT);\n\tmemcpy(data, buf, count);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int cp2112_hid_output(struct hid_device *hdev, u8 *data, size_t count,\n\t\t\t     unsigned char report_type)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmemdup(data, count, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (report_type == HID_OUTPUT_REPORT)\n\t\tret = hid_hw_output_report(hdev, buf, count);\n\telse\n\t\tret = hid_hw_raw_request(hdev, buf[0], buf, count, report_type,\n\t\t\t\tHID_REQ_SET_REPORT);\n\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int cp2112_wait(struct cp2112_device *dev, atomic_t *avail)\n{\n\tint ret = 0;\n\n\t/* We have sent either a CP2112_TRANSFER_STATUS_REQUEST or a\n\t * CP2112_DATA_READ_FORCE_SEND and we are waiting for the response to\n\t * come in cp2112_raw_event or timeout. There will only be one of these\n\t * in flight at any one time. The timeout is extremely large and is a\n\t * last resort if the CP2112 has died. If we do timeout we don't expect\n\t * to receive the response which would cause data races, it's not like\n\t * we can do anything about it anyway.\n\t */\n\tret = wait_event_interruptible_timeout(dev->wait,\n\t\tatomic_read(avail), msecs_to_jiffies(RESPONSE_TIMEOUT));\n\tif (-ERESTARTSYS == ret)\n\t\treturn ret;\n\tif (!ret)\n\t\treturn -ETIMEDOUT;\n\n\tatomic_set(avail, 0);\n\treturn 0;\n}\n\nstatic int cp2112_xfer_status(struct cp2112_device *dev)\n{\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 buf[2];\n\tint ret;\n\n\tbuf[0] = CP2112_TRANSFER_STATUS_REQUEST;\n\tbuf[1] = 0x01;\n\tatomic_set(&dev->xfer_avail, 0);\n\n\tret = cp2112_hid_output(hdev, buf, 2, HID_OUTPUT_REPORT);\n\tif (ret < 0) {\n\t\thid_warn(hdev, \"Error requesting status: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = cp2112_wait(dev, &dev->xfer_avail);\n\tif (ret)\n\t\treturn ret;\n\n\treturn dev->xfer_status;\n}\n\nstatic int cp2112_read(struct cp2112_device *dev, u8 *data, size_t size)\n{\n\tstruct hid_device *hdev = dev->hdev;\n\tstruct cp2112_force_read_report report;\n\tint ret;\n\n\tif (size > sizeof(dev->read_data))\n\t\tsize = sizeof(dev->read_data);\n\treport.report = CP2112_DATA_READ_FORCE_SEND;\n\treport.length = cpu_to_be16(size);\n\n\tatomic_set(&dev->read_avail, 0);\n\n\tret = cp2112_hid_output(hdev, &report.report, sizeof(report),\n\t\t\t\tHID_OUTPUT_REPORT);\n\tif (ret < 0) {\n\t\thid_warn(hdev, \"Error requesting data: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = cp2112_wait(dev, &dev->read_avail);\n\tif (ret)\n\t\treturn ret;\n\n\thid_dbg(hdev, \"read %d of %zd bytes requested\\n\",\n\t\tdev->read_length, size);\n\n\tif (size > dev->read_length)\n\t\tsize = dev->read_length;\n\n\tmemcpy(data, dev->read_data, size);\n\treturn dev->read_length;\n}\n\nstatic int cp2112_read_req(void *buf, u8 slave_address, u16 length)\n{\n\tstruct cp2112_read_req_report *report = buf;\n\n\tif (length < 1 || length > 512)\n\t\treturn -EINVAL;\n\n\treport->report = CP2112_DATA_READ_REQUEST;\n\treport->slave_address = slave_address << 1;\n\treport->length = cpu_to_be16(length);\n\treturn sizeof(*report);\n}\n\nstatic int cp2112_write_read_req(void *buf, u8 slave_address, u16 length,\n\t\t\t\t u8 command, u8 *data, u8 data_length)\n{\n\tstruct cp2112_write_read_req_report *report = buf;\n\n\tif (length < 1 || length > 512\n\t    || data_length > sizeof(report->target_address) - 1)\n\t\treturn -EINVAL;\n\n\treport->report = CP2112_DATA_WRITE_READ_REQUEST;\n\treport->slave_address = slave_address << 1;\n\treport->length = cpu_to_be16(length);\n\treport->target_address_length = data_length + 1;\n\treport->target_address[0] = command;\n\tmemcpy(&report->target_address[1], data, data_length);\n\treturn data_length + 6;\n}\n\nstatic int cp2112_write_req(void *buf, u8 slave_address, u8 command, u8 *data,\n\t\t\t    u8 data_length)\n{\n\tstruct cp2112_write_req_report *report = buf;\n\n\tif (data_length > sizeof(report->data) - 1)\n\t\treturn -EINVAL;\n\n\treport->report = CP2112_DATA_WRITE_REQUEST;\n\treport->slave_address = slave_address << 1;\n\treport->length = data_length + 1;\n\treport->data[0] = command;\n\tmemcpy(&report->data[1], data, data_length);\n\treturn data_length + 4;\n}\n\nstatic int cp2112_i2c_write_req(void *buf, u8 slave_address, u8 *data,\n\t\t\t\tu8 data_length)\n{\n\tstruct cp2112_write_req_report *report = buf;\n\n\tif (data_length > sizeof(report->data))\n\t\treturn -EINVAL;\n\n\treport->report = CP2112_DATA_WRITE_REQUEST;\n\treport->slave_address = slave_address << 1;\n\treport->length = data_length;\n\tmemcpy(report->data, data, data_length);\n\treturn data_length + 3;\n}\n\nstatic int cp2112_i2c_write_read_req(void *buf, u8 slave_address,\n\t\t\t\t     u8 *addr, int addr_length,\n\t\t\t\t     int read_length)\n{\n\tstruct cp2112_write_read_req_report *report = buf;\n\n\tif (read_length < 1 || read_length > 512 ||\n\t    addr_length > sizeof(report->target_address))\n\t\treturn -EINVAL;\n\n\treport->report = CP2112_DATA_WRITE_READ_REQUEST;\n\treport->slave_address = slave_address << 1;\n\treport->length = cpu_to_be16(read_length);\n\treport->target_address_length = addr_length;\n\tmemcpy(report->target_address, addr, addr_length);\n\treturn addr_length + 5;\n}\n\nstatic int cp2112_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\t   int num)\n{\n\tstruct cp2112_device *dev = (struct cp2112_device *)adap->algo_data;\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 buf[64];\n\tssize_t count;\n\tssize_t read_length = 0;\n\tu8 *read_buf = NULL;\n\tunsigned int retries;\n\tint ret;\n\n\thid_dbg(hdev, \"I2C %d messages\\n\", num);\n\n\tif (num == 1) {\n\t\tif (msgs->flags & I2C_M_RD) {\n\t\t\thid_dbg(hdev, \"I2C read %#04x len %d\\n\",\n\t\t\t\tmsgs->addr, msgs->len);\n\t\t\tread_length = msgs->len;\n\t\t\tread_buf = msgs->buf;\n\t\t\tcount = cp2112_read_req(buf, msgs->addr, msgs->len);\n\t\t} else {\n\t\t\thid_dbg(hdev, \"I2C write %#04x len %d\\n\",\n\t\t\t\tmsgs->addr, msgs->len);\n\t\t\tcount = cp2112_i2c_write_req(buf, msgs->addr,\n\t\t\t\t\t\t     msgs->buf, msgs->len);\n\t\t}\n\t\tif (count < 0)\n\t\t\treturn count;\n\t} else if (dev->hwversion > 1 &&  /* no repeated start in rev 1 */\n\t\t   num == 2 &&\n\t\t   msgs[0].addr == msgs[1].addr &&\n\t\t   !(msgs[0].flags & I2C_M_RD) && (msgs[1].flags & I2C_M_RD)) {\n\t\thid_dbg(hdev, \"I2C write-read %#04x wlen %d rlen %d\\n\",\n\t\t\tmsgs[0].addr, msgs[0].len, msgs[1].len);\n\t\tread_length = msgs[1].len;\n\t\tread_buf = msgs[1].buf;\n\t\tcount = cp2112_i2c_write_read_req(buf, msgs[0].addr,\n\t\t\t\tmsgs[0].buf, msgs[0].len, msgs[1].len);\n\t\tif (count < 0)\n\t\t\treturn count;\n\t} else {\n\t\thid_err(hdev,\n\t\t\t\"Multi-message I2C transactions not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = hid_hw_power(hdev, PM_HINT_FULLON);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"power management error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = cp2112_hid_output(hdev, buf, count, HID_OUTPUT_REPORT);\n\tif (ret < 0) {\n\t\thid_warn(hdev, \"Error starting transaction: %d\\n\", ret);\n\t\tgoto power_normal;\n\t}\n\n\tfor (retries = 0; retries < XFER_STATUS_RETRIES; ++retries) {\n\t\tret = cp2112_xfer_status(dev);\n\t\tif (-EBUSY == ret)\n\t\t\tcontinue;\n\t\tif (ret < 0)\n\t\t\tgoto power_normal;\n\t\tbreak;\n\t}\n\n\tif (XFER_STATUS_RETRIES <= retries) {\n\t\thid_warn(hdev, \"Transfer timed out, cancelling.\\n\");\n\t\tbuf[0] = CP2112_CANCEL_TRANSFER;\n\t\tbuf[1] = 0x01;\n\n\t\tret = cp2112_hid_output(hdev, buf, 2, HID_OUTPUT_REPORT);\n\t\tif (ret < 0)\n\t\t\thid_warn(hdev, \"Error cancelling transaction: %d\\n\",\n\t\t\t\t ret);\n\n\t\tret = -ETIMEDOUT;\n\t\tgoto power_normal;\n\t}\n\n\tfor (count = 0; count < read_length;) {\n\t\tret = cp2112_read(dev, read_buf + count, read_length - count);\n\t\tif (ret < 0)\n\t\t\tgoto power_normal;\n\t\tif (ret == 0) {\n\t\t\thid_err(hdev, \"read returned 0\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto power_normal;\n\t\t}\n\t\tcount += ret;\n\t\tif (count > read_length) {\n\t\t\t/*\n\t\t\t * The hardware returned too much data.\n\t\t\t * This is mostly harmless because cp2112_read()\n\t\t\t * has a limit check so didn't overrun our\n\t\t\t * buffer.  Nevertheless, we return an error\n\t\t\t * because something is seriously wrong and\n\t\t\t * it shouldn't go unnoticed.\n\t\t\t */\n\t\t\thid_err(hdev, \"long read: %d > %zd\\n\",\n\t\t\t\tret, read_length - count + ret);\n\t\t\tret = -EIO;\n\t\t\tgoto power_normal;\n\t\t}\n\t}\n\n\t/* return the number of transferred messages */\n\tret = num;\n\npower_normal:\n\thid_hw_power(hdev, PM_HINT_NORMAL);\n\thid_dbg(hdev, \"I2C transfer finished: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int cp2112_xfer(struct i2c_adapter *adap, u16 addr,\n\t\t       unsigned short flags, char read_write, u8 command,\n\t\t       int size, union i2c_smbus_data *data)\n{\n\tstruct cp2112_device *dev = (struct cp2112_device *)adap->algo_data;\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 buf[64];\n\t__le16 word;\n\tssize_t count;\n\tsize_t read_length = 0;\n\tunsigned int retries;\n\tint ret;\n\n\thid_dbg(hdev, \"%s addr 0x%x flags 0x%x cmd 0x%x size %d\\n\",\n\t\tread_write == I2C_SMBUS_WRITE ? \"write\" : \"read\",\n\t\taddr, flags, command, size);\n\n\tswitch (size) {\n\tcase I2C_SMBUS_BYTE:\n\t\tread_length = 1;\n\n\t\tif (I2C_SMBUS_READ == read_write)\n\t\t\tcount = cp2112_read_req(buf, addr, read_length);\n\t\telse\n\t\t\tcount = cp2112_write_req(buf, addr, command, NULL,\n\t\t\t\t\t\t 0);\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tread_length = 1;\n\n\t\tif (I2C_SMBUS_READ == read_write)\n\t\t\tcount = cp2112_write_read_req(buf, addr, read_length,\n\t\t\t\t\t\t      command, NULL, 0);\n\t\telse\n\t\t\tcount = cp2112_write_req(buf, addr, command,\n\t\t\t\t\t\t &data->byte, 1);\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tread_length = 2;\n\t\tword = cpu_to_le16(data->word);\n\n\t\tif (I2C_SMBUS_READ == read_write)\n\t\t\tcount = cp2112_write_read_req(buf, addr, read_length,\n\t\t\t\t\t\t      command, NULL, 0);\n\t\telse\n\t\t\tcount = cp2112_write_req(buf, addr, command,\n\t\t\t\t\t\t (u8 *)&word, 2);\n\t\tbreak;\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tsize = I2C_SMBUS_WORD_DATA;\n\t\tread_write = I2C_SMBUS_READ;\n\t\tread_length = 2;\n\t\tword = cpu_to_le16(data->word);\n\n\t\tcount = cp2112_write_read_req(buf, addr, read_length, command,\n\t\t\t\t\t      (u8 *)&word, 2);\n\t\tbreak;\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\tsize = I2C_SMBUS_BLOCK_DATA;\n\t\t/* fallthrough */\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (I2C_SMBUS_READ == read_write) {\n\t\t\tcount = cp2112_write_read_req(buf, addr,\n\t\t\t\t\t\t      I2C_SMBUS_BLOCK_MAX,\n\t\t\t\t\t\t      command, NULL, 0);\n\t\t} else {\n\t\t\tcount = cp2112_write_req(buf, addr, command,\n\t\t\t\t\t\t data->block,\n\t\t\t\t\t\t data->block[0] + 1);\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tsize = I2C_SMBUS_BLOCK_DATA;\n\t\tread_write = I2C_SMBUS_READ;\n\n\t\tcount = cp2112_write_read_req(buf, addr, I2C_SMBUS_BLOCK_MAX,\n\t\t\t\t\t      command, data->block,\n\t\t\t\t\t      data->block[0] + 1);\n\t\tbreak;\n\tdefault:\n\t\thid_warn(hdev, \"Unsupported transaction %d\\n\", size);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (count < 0)\n\t\treturn count;\n\n\tret = hid_hw_power(hdev, PM_HINT_FULLON);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"power management error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = cp2112_hid_output(hdev, buf, count, HID_OUTPUT_REPORT);\n\tif (ret < 0) {\n\t\thid_warn(hdev, \"Error starting transaction: %d\\n\", ret);\n\t\tgoto power_normal;\n\t}\n\n\tfor (retries = 0; retries < XFER_STATUS_RETRIES; ++retries) {\n\t\tret = cp2112_xfer_status(dev);\n\t\tif (-EBUSY == ret)\n\t\t\tcontinue;\n\t\tif (ret < 0)\n\t\t\tgoto power_normal;\n\t\tbreak;\n\t}\n\n\tif (XFER_STATUS_RETRIES <= retries) {\n\t\thid_warn(hdev, \"Transfer timed out, cancelling.\\n\");\n\t\tbuf[0] = CP2112_CANCEL_TRANSFER;\n\t\tbuf[1] = 0x01;\n\n\t\tret = cp2112_hid_output(hdev, buf, 2, HID_OUTPUT_REPORT);\n\t\tif (ret < 0)\n\t\t\thid_warn(hdev, \"Error cancelling transaction: %d\\n\",\n\t\t\t\t ret);\n\n\t\tret = -ETIMEDOUT;\n\t\tgoto power_normal;\n\t}\n\n\tif (I2C_SMBUS_WRITE == read_write) {\n\t\tret = 0;\n\t\tgoto power_normal;\n\t}\n\n\tif (I2C_SMBUS_BLOCK_DATA == size)\n\t\tread_length = ret;\n\n\tret = cp2112_read(dev, buf, read_length);\n\tif (ret < 0)\n\t\tgoto power_normal;\n\tif (ret != read_length) {\n\t\thid_warn(hdev, \"short read: %d < %zd\\n\", ret, read_length);\n\t\tret = -EIO;\n\t\tgoto power_normal;\n\t}\n\n\tswitch (size) {\n\tcase I2C_SMBUS_BYTE:\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tdata->byte = buf[0];\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tdata->word = le16_to_cpup((__le16 *)buf);\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (read_length > I2C_SMBUS_BLOCK_MAX) {\n\t\t\tret = -EPROTO;\n\t\t\tgoto power_normal;\n\t\t}\n\n\t\tmemcpy(data->block, buf, read_length);\n\t\tbreak;\n\t}\n\n\tret = 0;\npower_normal:\n\thid_hw_power(hdev, PM_HINT_NORMAL);\n\thid_dbg(hdev, \"transfer finished: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic u32 cp2112_functionality(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C |\n\t\tI2C_FUNC_SMBUS_BYTE |\n\t\tI2C_FUNC_SMBUS_BYTE_DATA |\n\t\tI2C_FUNC_SMBUS_WORD_DATA |\n\t\tI2C_FUNC_SMBUS_BLOCK_DATA |\n\t\tI2C_FUNC_SMBUS_I2C_BLOCK |\n\t\tI2C_FUNC_SMBUS_PROC_CALL |\n\t\tI2C_FUNC_SMBUS_BLOCK_PROC_CALL;\n}\n\nstatic const struct i2c_algorithm smbus_algorithm = {\n\t.master_xfer\t= cp2112_i2c_xfer,\n\t.smbus_xfer\t= cp2112_xfer,\n\t.functionality\t= cp2112_functionality,\n};\n\nstatic int cp2112_get_usb_config(struct hid_device *hdev,\n\t\t\t\t struct cp2112_usb_config_report *cfg)\n{\n\tint ret;\n\n\tret = cp2112_hid_get(hdev, CP2112_USB_CONFIG, (u8 *)cfg, sizeof(*cfg),\n\t\t\t     HID_FEATURE_REPORT);\n\tif (ret != sizeof(*cfg)) {\n\t\thid_err(hdev, \"error reading usb config: %d\\n\", ret);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int cp2112_set_usb_config(struct hid_device *hdev,\n\t\t\t\t struct cp2112_usb_config_report *cfg)\n{\n\tint ret;\n\n\tBUG_ON(cfg->report != CP2112_USB_CONFIG);\n\n\tret = cp2112_hid_output(hdev, (u8 *)cfg, sizeof(*cfg),\n\t\t\t\tHID_FEATURE_REPORT);\n\tif (ret != sizeof(*cfg)) {\n\t\thid_err(hdev, \"error writing usb config: %d\\n\", ret);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void chmod_sysfs_attrs(struct hid_device *hdev);\n\n#define CP2112_CONFIG_ATTR(name, store, format, ...) \\\nstatic ssize_t name##_store(struct device *kdev, \\\n\t\t\t    struct device_attribute *attr, const char *buf, \\\n\t\t\t    size_t count) \\\n{ \\\n\tstruct hid_device *hdev = to_hid_device(kdev); \\\n\tstruct cp2112_usb_config_report cfg; \\\n\tint ret = cp2112_get_usb_config(hdev, &cfg); \\\n\tif (ret) \\\n\t\treturn ret; \\\n\tstore; \\\n\tret = cp2112_set_usb_config(hdev, &cfg); \\\n\tif (ret) \\\n\t\treturn ret; \\\n\tchmod_sysfs_attrs(hdev); \\\n\treturn count; \\\n} \\\nstatic ssize_t name##_show(struct device *kdev, \\\n\t\t\t   struct device_attribute *attr, char *buf) \\\n{ \\\n\tstruct hid_device *hdev = to_hid_device(kdev); \\\n\tstruct cp2112_usb_config_report cfg; \\\n\tint ret = cp2112_get_usb_config(hdev, &cfg); \\\n\tif (ret) \\\n\t\treturn ret; \\\n\treturn scnprintf(buf, PAGE_SIZE, format, ##__VA_ARGS__); \\\n} \\\nstatic DEVICE_ATTR_RW(name);\n\nCP2112_CONFIG_ATTR(vendor_id, ({\n\tu16 vid;\n\n\tif (sscanf(buf, \"%hi\", &vid) != 1)\n\t\treturn -EINVAL;\n\n\tcfg.vid = cpu_to_le16(vid);\n\tcfg.mask = 0x01;\n}), \"0x%04x\\n\", le16_to_cpu(cfg.vid));\n\nCP2112_CONFIG_ATTR(product_id, ({\n\tu16 pid;\n\n\tif (sscanf(buf, \"%hi\", &pid) != 1)\n\t\treturn -EINVAL;\n\n\tcfg.pid = cpu_to_le16(pid);\n\tcfg.mask = 0x02;\n}), \"0x%04x\\n\", le16_to_cpu(cfg.pid));\n\nCP2112_CONFIG_ATTR(max_power, ({\n\tint mA;\n\n\tif (sscanf(buf, \"%i\", &mA) != 1)\n\t\treturn -EINVAL;\n\n\tcfg.max_power = (mA + 1) / 2;\n\tcfg.mask = 0x04;\n}), \"%u mA\\n\", cfg.max_power * 2);\n\nCP2112_CONFIG_ATTR(power_mode, ({\n\tif (sscanf(buf, \"%hhi\", &cfg.power_mode) != 1)\n\t\treturn -EINVAL;\n\n\tcfg.mask = 0x08;\n}), \"%u\\n\", cfg.power_mode);\n\nCP2112_CONFIG_ATTR(release_version, ({\n\tif (sscanf(buf, \"%hhi.%hhi\", &cfg.release_major, &cfg.release_minor)\n\t    != 2)\n\t\treturn -EINVAL;\n\n\tcfg.mask = 0x10;\n}), \"%u.%u\\n\", cfg.release_major, cfg.release_minor);\n\n#undef CP2112_CONFIG_ATTR\n\nstruct cp2112_pstring_attribute {\n\tstruct device_attribute attr;\n\tunsigned char report;\n};\n\nstatic ssize_t pstr_store(struct device *kdev,\n\t\t\t  struct device_attribute *kattr, const char *buf,\n\t\t\t  size_t count)\n{\n\tstruct hid_device *hdev = to_hid_device(kdev);\n\tstruct cp2112_pstring_attribute *attr =\n\t\tcontainer_of(kattr, struct cp2112_pstring_attribute, attr);\n\tstruct cp2112_string_report report;\n\tint ret;\n\n\tmemset(&report, 0, sizeof(report));\n\n\tret = utf8s_to_utf16s(buf, count, UTF16_LITTLE_ENDIAN,\n\t\t\t      report.string, ARRAY_SIZE(report.string));\n\treport.report = attr->report;\n\treport.length = ret * sizeof(report.string[0]) + 2;\n\treport.type = USB_DT_STRING;\n\n\tret = cp2112_hid_output(hdev, &report.report, report.length + 1,\n\t\t\t\tHID_FEATURE_REPORT);\n\tif (ret != report.length + 1) {\n\t\thid_err(hdev, \"error writing %s string: %d\\n\", kattr->attr.name,\n\t\t\tret);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn -EIO;\n\t}\n\n\tchmod_sysfs_attrs(hdev);\n\treturn count;\n}\n\nstatic ssize_t pstr_show(struct device *kdev,\n\t\t\t struct device_attribute *kattr, char *buf)\n{\n\tstruct hid_device *hdev = to_hid_device(kdev);\n\tstruct cp2112_pstring_attribute *attr =\n\t\tcontainer_of(kattr, struct cp2112_pstring_attribute, attr);\n\tstruct cp2112_string_report report;\n\tu8 length;\n\tint ret;\n\n\tret = cp2112_hid_get(hdev, attr->report, &report.report,\n\t\t\t     sizeof(report) - 1, HID_FEATURE_REPORT);\n\tif (ret < 3) {\n\t\thid_err(hdev, \"error reading %s string: %d\\n\", kattr->attr.name,\n\t\t\tret);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn -EIO;\n\t}\n\n\tif (report.length < 2) {\n\t\thid_err(hdev, \"invalid %s string length: %d\\n\",\n\t\t\tkattr->attr.name, report.length);\n\t\treturn -EIO;\n\t}\n\n\tlength = report.length > ret - 1 ? ret - 1 : report.length;\n\tlength = (length - 2) / sizeof(report.string[0]);\n\tret = utf16s_to_utf8s(report.string, length, UTF16_LITTLE_ENDIAN, buf,\n\t\t\t      PAGE_SIZE - 1);\n\tbuf[ret++] = '\\n';\n\treturn ret;\n}\n\n#define CP2112_PSTR_ATTR(name, _report) \\\nstatic struct cp2112_pstring_attribute dev_attr_##name = { \\\n\t.attr = __ATTR(name, (S_IWUSR | S_IRUGO), pstr_show, pstr_store), \\\n\t.report = _report, \\\n};\n\nCP2112_PSTR_ATTR(manufacturer,\tCP2112_MANUFACTURER_STRING);\nCP2112_PSTR_ATTR(product,\tCP2112_PRODUCT_STRING);\nCP2112_PSTR_ATTR(serial,\tCP2112_SERIAL_STRING);\n\n#undef CP2112_PSTR_ATTR\n\nstatic const struct attribute_group cp2112_attr_group = {\n\t.attrs = (struct attribute *[]){\n\t\t&dev_attr_vendor_id.attr,\n\t\t&dev_attr_product_id.attr,\n\t\t&dev_attr_max_power.attr,\n\t\t&dev_attr_power_mode.attr,\n\t\t&dev_attr_release_version.attr,\n\t\t&dev_attr_manufacturer.attr.attr,\n\t\t&dev_attr_product.attr.attr,\n\t\t&dev_attr_serial.attr.attr,\n\t\tNULL\n\t}\n};\n\n/* Chmoding our sysfs attributes is simply a way to expose which fields in the\n * PROM have already been programmed. We do not depend on this preventing\n * writing to these attributes since the CP2112 will simply ignore writes to\n * already-programmed fields. This is why there is no sense in fixing this\n * racy behaviour.\n */\nstatic void chmod_sysfs_attrs(struct hid_device *hdev)\n{\n\tstruct attribute **attr;\n\tu8 buf[2];\n\tint ret;\n\n\tret = cp2112_hid_get(hdev, CP2112_LOCK_BYTE, buf, sizeof(buf),\n\t\t\t     HID_FEATURE_REPORT);\n\tif (ret != sizeof(buf)) {\n\t\thid_err(hdev, \"error reading lock byte: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tfor (attr = cp2112_attr_group.attrs; *attr; ++attr) {\n\t\tumode_t mode = (buf[1] & 1) ? S_IWUSR | S_IRUGO : S_IRUGO;\n\t\tret = sysfs_chmod_file(&hdev->dev.kobj, *attr, mode);\n\t\tif (ret < 0)\n\t\t\thid_err(hdev, \"error chmoding sysfs file %s\\n\",\n\t\t\t\t(*attr)->name);\n\t\tbuf[1] >>= 1;\n\t}\n}\n\nstatic void cp2112_gpio_irq_ack(struct irq_data *d)\n{\n}\n\nstatic void cp2112_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct cp2112_device *dev = gpiochip_get_data(gc);\n\n\t__clear_bit(d->hwirq, &dev->irq_mask);\n}\n\nstatic void cp2112_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct cp2112_device *dev = gpiochip_get_data(gc);\n\n\t__set_bit(d->hwirq, &dev->irq_mask);\n}\n\nstatic void cp2112_gpio_poll_callback(struct work_struct *work)\n{\n\tstruct cp2112_device *dev = container_of(work, struct cp2112_device,\n\t\t\t\t\t\t gpio_poll_worker.work);\n\tstruct irq_data *d;\n\tu8 gpio_mask;\n\tu8 virqs = (u8)dev->irq_mask;\n\tu32 irq_type;\n\tint irq, virq, ret;\n\n\tret = cp2112_gpio_get_all(&dev->gc);\n\tif (ret == -ENODEV) /* the hardware has been disconnected */\n\t\treturn;\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tgpio_mask = ret;\n\n\twhile (virqs) {\n\t\tvirq = ffs(virqs) - 1;\n\t\tvirqs &= ~BIT(virq);\n\n\t\tif (!dev->gc.to_irq)\n\t\t\tbreak;\n\n\t\tirq = dev->gc.to_irq(&dev->gc, virq);\n\n\t\td = irq_get_irq_data(irq);\n\t\tif (!d)\n\t\t\tcontinue;\n\n\t\tirq_type = irqd_get_trigger_type(d);\n\n\t\tif (gpio_mask & BIT(virq)) {\n\t\t\t/* Level High */\n\n\t\t\tif (irq_type & IRQ_TYPE_LEVEL_HIGH)\n\t\t\t\thandle_nested_irq(irq);\n\n\t\t\tif ((irq_type & IRQ_TYPE_EDGE_RISING) &&\n\t\t\t    !(dev->gpio_prev_state & BIT(virq)))\n\t\t\t\thandle_nested_irq(irq);\n\t\t} else {\n\t\t\t/* Level Low */\n\n\t\t\tif (irq_type & IRQ_TYPE_LEVEL_LOW)\n\t\t\t\thandle_nested_irq(irq);\n\n\t\t\tif ((irq_type & IRQ_TYPE_EDGE_FALLING) &&\n\t\t\t    (dev->gpio_prev_state & BIT(virq)))\n\t\t\t\thandle_nested_irq(irq);\n\t\t}\n\t}\n\n\tdev->gpio_prev_state = gpio_mask;\n\nexit:\n\tif (dev->gpio_poll)\n\t\tschedule_delayed_work(&dev->gpio_poll_worker, 10);\n}\n\n\nstatic unsigned int cp2112_gpio_irq_startup(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct cp2112_device *dev = gpiochip_get_data(gc);\n\n\tINIT_DELAYED_WORK(&dev->gpio_poll_worker, cp2112_gpio_poll_callback);\n\n\tcp2112_gpio_direction_input(gc, d->hwirq);\n\n\tif (!dev->gpio_poll) {\n\t\tdev->gpio_poll = true;\n\t\tschedule_delayed_work(&dev->gpio_poll_worker, 0);\n\t}\n\n\tcp2112_gpio_irq_unmask(d);\n\treturn 0;\n}\n\nstatic void cp2112_gpio_irq_shutdown(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct cp2112_device *dev = gpiochip_get_data(gc);\n\n\tcancel_delayed_work_sync(&dev->gpio_poll_worker);\n}\n\nstatic int cp2112_gpio_irq_type(struct irq_data *d, unsigned int type)\n{\n\treturn 0;\n}\n\nstatic struct irq_chip cp2112_gpio_irqchip = {\n\t.name = \"cp2112-gpio\",\n\t.irq_startup = cp2112_gpio_irq_startup,\n\t.irq_shutdown = cp2112_gpio_irq_shutdown,\n\t.irq_ack = cp2112_gpio_irq_ack,\n\t.irq_mask = cp2112_gpio_irq_mask,\n\t.irq_unmask = cp2112_gpio_irq_unmask,\n\t.irq_set_type = cp2112_gpio_irq_type,\n};\n\nstatic int __maybe_unused cp2112_allocate_irq(struct cp2112_device *dev,\n\t\t\t\t\t      int pin)\n{\n\tint ret;\n\n\tif (dev->desc[pin])\n\t\treturn -EINVAL;\n\n\tdev->desc[pin] = gpiochip_request_own_desc(&dev->gc, pin,\n\t\t\t\t\t\t   \"HID/I2C:Event\");\n\tif (IS_ERR(dev->desc[pin])) {\n\t\tdev_err(dev->gc.parent, \"Failed to request GPIO\\n\");\n\t\treturn PTR_ERR(dev->desc[pin]);\n\t}\n\n\tret = gpiochip_lock_as_irq(&dev->gc, pin);\n\tif (ret) {\n\t\tdev_err(dev->gc.parent, \"Failed to lock GPIO as interrupt\\n\");\n\t\tgoto err_desc;\n\t}\n\n\tret = gpiod_to_irq(dev->desc[pin]);\n\tif (ret < 0) {\n\t\tdev_err(dev->gc.parent, \"Failed to translate GPIO to IRQ\\n\");\n\t\tgoto err_lock;\n\t}\n\n\treturn ret;\n\nerr_lock:\n\tgpiochip_unlock_as_irq(&dev->gc, pin);\nerr_desc:\n\tgpiochip_free_own_desc(dev->desc[pin]);\n\tdev->desc[pin] = NULL;\n\treturn ret;\n}\n\nstatic int cp2112_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct cp2112_device *dev;\n\tu8 buf[3];\n\tstruct cp2112_smbus_config_report config;\n\tint ret;\n\n\tdev = devm_kzalloc(&hdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->in_out_buffer = devm_kzalloc(&hdev->dev, CP2112_REPORT_MAX_LENGTH,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!dev->in_out_buffer)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&dev->lock);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hid_hw_open(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"hw open failed\\n\");\n\t\tgoto err_hid_stop;\n\t}\n\n\tret = hid_hw_power(hdev, PM_HINT_FULLON);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"power management error: %d\\n\", ret);\n\t\tgoto err_hid_close;\n\t}\n\n\tret = cp2112_hid_get(hdev, CP2112_GET_VERSION_INFO, buf, sizeof(buf),\n\t\t\t     HID_FEATURE_REPORT);\n\tif (ret != sizeof(buf)) {\n\t\thid_err(hdev, \"error requesting version\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto err_power_normal;\n\t}\n\n\thid_info(hdev, \"Part Number: 0x%02X Device Version: 0x%02X\\n\",\n\t\t buf[1], buf[2]);\n\n\tret = cp2112_hid_get(hdev, CP2112_SMBUS_CONFIG, (u8 *)&config,\n\t\t\t     sizeof(config), HID_FEATURE_REPORT);\n\tif (ret != sizeof(config)) {\n\t\thid_err(hdev, \"error requesting SMBus config\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto err_power_normal;\n\t}\n\n\tconfig.retry_time = cpu_to_be16(1);\n\n\tret = cp2112_hid_output(hdev, (u8 *)&config, sizeof(config),\n\t\t\t\tHID_FEATURE_REPORT);\n\tif (ret != sizeof(config)) {\n\t\thid_err(hdev, \"error setting SMBus config\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto err_power_normal;\n\t}\n\n\thid_set_drvdata(hdev, (void *)dev);\n\tdev->hdev\t\t= hdev;\n\tdev->adap.owner\t\t= THIS_MODULE;\n\tdev->adap.class\t\t= I2C_CLASS_HWMON;\n\tdev->adap.algo\t\t= &smbus_algorithm;\n\tdev->adap.algo_data\t= dev;\n\tdev->adap.dev.parent\t= &hdev->dev;\n\tsnprintf(dev->adap.name, sizeof(dev->adap.name),\n\t\t \"CP2112 SMBus Bridge on hiddev%d\", hdev->minor);\n\tdev->hwversion = buf[2];\n\tinit_waitqueue_head(&dev->wait);\n\n\thid_device_io_start(hdev);\n\tret = i2c_add_adapter(&dev->adap);\n\thid_device_io_stop(hdev);\n\n\tif (ret) {\n\t\thid_err(hdev, \"error registering i2c adapter\\n\");\n\t\tgoto err_power_normal;\n\t}\n\n\thid_dbg(hdev, \"adapter registered\\n\");\n\n\tdev->gc.label\t\t\t= \"cp2112_gpio\";\n\tdev->gc.direction_input\t\t= cp2112_gpio_direction_input;\n\tdev->gc.direction_output\t= cp2112_gpio_direction_output;\n\tdev->gc.set\t\t\t= cp2112_gpio_set;\n\tdev->gc.get\t\t\t= cp2112_gpio_get;\n\tdev->gc.base\t\t\t= -1;\n\tdev->gc.ngpio\t\t\t= 8;\n\tdev->gc.can_sleep\t\t= 1;\n\tdev->gc.parent\t\t\t= &hdev->dev;\n\n\tret = gpiochip_add_data(&dev->gc, dev);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error registering gpio chip\\n\");\n\t\tgoto err_free_i2c;\n\t}\n\n\tret = sysfs_create_group(&hdev->dev.kobj, &cp2112_attr_group);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error creating sysfs attrs\\n\");\n\t\tgoto err_gpiochip_remove;\n\t}\n\n\tchmod_sysfs_attrs(hdev);\n\thid_hw_power(hdev, PM_HINT_NORMAL);\n\n\tret = gpiochip_irqchip_add(&dev->gc, &cp2112_gpio_irqchip, 0,\n\t\t\t\t   handle_simple_irq, IRQ_TYPE_NONE);\n\tif (ret) {\n\t\tdev_err(dev->gc.parent, \"failed to add IRQ chip\\n\");\n\t\tgoto err_sysfs_remove;\n\t}\n\n\treturn ret;\n\nerr_sysfs_remove:\n\tsysfs_remove_group(&hdev->dev.kobj, &cp2112_attr_group);\nerr_gpiochip_remove:\n\tgpiochip_remove(&dev->gc);\nerr_free_i2c:\n\ti2c_del_adapter(&dev->adap);\nerr_power_normal:\n\thid_hw_power(hdev, PM_HINT_NORMAL);\nerr_hid_close:\n\thid_hw_close(hdev);\nerr_hid_stop:\n\thid_hw_stop(hdev);\n\treturn ret;\n}\n\nstatic void cp2112_remove(struct hid_device *hdev)\n{\n\tstruct cp2112_device *dev = hid_get_drvdata(hdev);\n\tint i;\n\n\tsysfs_remove_group(&hdev->dev.kobj, &cp2112_attr_group);\n\ti2c_del_adapter(&dev->adap);\n\n\tif (dev->gpio_poll) {\n\t\tdev->gpio_poll = false;\n\t\tcancel_delayed_work_sync(&dev->gpio_poll_worker);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(dev->desc); i++) {\n\t\tgpiochip_unlock_as_irq(&dev->gc, i);\n\t\tgpiochip_free_own_desc(dev->desc[i]);\n\t}\n\n\tgpiochip_remove(&dev->gc);\n\t/* i2c_del_adapter has finished removing all i2c devices from our\n\t * adapter. Well behaved devices should no longer call our cp2112_xfer\n\t * and should have waited for any pending calls to finish. It has also\n\t * waited for device_unregister(&adap->dev) to complete. Therefore we\n\t * can safely free our struct cp2112_device.\n\t */\n\thid_hw_close(hdev);\n\thid_hw_stop(hdev);\n}\n\nstatic int cp2112_raw_event(struct hid_device *hdev, struct hid_report *report,\n\t\t\t    u8 *data, int size)\n{\n\tstruct cp2112_device *dev = hid_get_drvdata(hdev);\n\tstruct cp2112_xfer_status_report *xfer = (void *)data;\n\n\tswitch (data[0]) {\n\tcase CP2112_TRANSFER_STATUS_RESPONSE:\n\t\thid_dbg(hdev, \"xfer status: %02x %02x %04x %04x\\n\",\n\t\t\txfer->status0, xfer->status1,\n\t\t\tbe16_to_cpu(xfer->retries), be16_to_cpu(xfer->length));\n\n\t\tswitch (xfer->status0) {\n\t\tcase STATUS0_IDLE:\n\t\t\tdev->xfer_status = -EAGAIN;\n\t\t\tbreak;\n\t\tcase STATUS0_BUSY:\n\t\t\tdev->xfer_status = -EBUSY;\n\t\t\tbreak;\n\t\tcase STATUS0_COMPLETE:\n\t\t\tdev->xfer_status = be16_to_cpu(xfer->length);\n\t\t\tbreak;\n\t\tcase STATUS0_ERROR:\n\t\t\tswitch (xfer->status1) {\n\t\t\tcase STATUS1_TIMEOUT_NACK:\n\t\t\tcase STATUS1_TIMEOUT_BUS:\n\t\t\t\tdev->xfer_status = -ETIMEDOUT;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev->xfer_status = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev->xfer_status = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tatomic_set(&dev->xfer_avail, 1);\n\t\tbreak;\n\tcase CP2112_DATA_READ_RESPONSE:\n\t\thid_dbg(hdev, \"read response: %02x %02x\\n\", data[1], data[2]);\n\n\t\tdev->read_length = data[2];\n\t\tif (dev->read_length > sizeof(dev->read_data))\n\t\t\tdev->read_length = sizeof(dev->read_data);\n\n\t\tmemcpy(dev->read_data, &data[3], dev->read_length);\n\t\tatomic_set(&dev->read_avail, 1);\n\t\tbreak;\n\tdefault:\n\t\thid_err(hdev, \"unknown report\\n\");\n\n\t\treturn 0;\n\t}\n\n\twake_up_interruptible(&dev->wait);\n\treturn 1;\n}\n\nstatic struct hid_driver cp2112_driver = {\n\t.name\t\t= \"cp2112\",\n\t.id_table\t= cp2112_devices,\n\t.probe\t\t= cp2112_probe,\n\t.remove\t\t= cp2112_remove,\n\t.raw_event\t= cp2112_raw_event,\n};\n\nmodule_hid_driver(cp2112_driver);\nMODULE_DESCRIPTION(\"Silicon Labs HID USB to SMBus master bridge\");\nMODULE_AUTHOR(\"David Barksdale <dbarksdale@uplogix.com>\");\nMODULE_LICENSE(\"GPL\");\n\n"], "filenames": ["drivers/hid/hid-cp2112.c"], "buggy_code_start_loc": [216], "buggy_code_end_loc": [217], "fixing_code_start_loc": [216], "fixing_code_end_loc": [217], "type": "CWE-388", "message": "The cp2112_gpio_direction_input function in drivers/hid/hid-cp2112.c in the Linux kernel 4.9.x before 4.9.9 does not have the expected EIO error status for a zero-length report, which allows local users to have an unspecified impact via unknown vectors.", "other": {"cve": {"id": "CVE-2017-8072", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-23T05:59:00.647", "lastModified": "2017-04-27T17:50:05.737", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The cp2112_gpio_direction_input function in drivers/hid/hid-cp2112.c in the Linux kernel 4.9.x before 4.9.9 does not have the expected EIO error status for a zero-length report, which allows local users to have an unspecified impact via unknown vectors."}, {"lang": "es", "value": "La funci\u00f3n cp2112_gpio_direction_input en drivers/hid/hid-cp2112.c en el kernel de Linux 4.9.x en versiones anteriores a 4.9.9 no tiene el estado de error EIO esperado para un informe de longitud cero, lo que permite a los usuarios locales tener un impacto no especificado a trav\u00e9s de vectores desconocidos."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-388"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9:*:*:*:*:*:*:*", "matchCriteriaId": "27B10B33-5F64-4039-8351-694A7AB6E4E4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "686DF390-3DCA-4D64-9858-FF699FA21D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "D24EF446-2120-4F2F-9D84-F782BF1D85CF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "DA879AFB-E995-458B-ABD2-87477376A70D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "719F2C9D-1897-480A-93CE-C2AC987B80AC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "F1516D1D-261D-421C-83FF-05DD90DAEB50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "8A944C6C-C1BF-472D-8BC2-B112EEDF3BD5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "29F4F9E6-4EE0-43C4-9B72-03D773AF5719"}]}]}], "references": [{"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.9.9", "source": "cve@mitre.org", "tags": ["Vendor Advisory", "Release Notes"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/04/16/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/98010", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=8e9faa15469ed7c7467423db4c62aeed3ff4cae3", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/torvalds/linux/commit/8e9faa15469ed7c7467423db4c62aeed3ff4cae3", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/8e9faa15469ed7c7467423db4c62aeed3ff4cae3"}}