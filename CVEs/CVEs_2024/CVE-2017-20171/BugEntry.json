{"buggy_code": ["/**\n * Created by ctalmacel on 12/8/15.\n */\n\nvar Q = require('q');\nvar createRawObject = require(\"../../lib/abstractPersistence.js\").createRawObject;\nvar modelUtil = require(\"../../lib/ModelDescription.js\");\nvar mysqlUtils = require(\"./mysqlUtils.js\");\n\nfunction sqlPersistenceStrategy(mysqlPool) {\n    var self = this;\n    var runQuery = Q.nbind(mysqlPool.query,mysqlPool);\n\n    this.validateModel = function(typeName,description,callback){\n        runQuery(mysqlUtils.describeTable(typeName)).\n        then(validate,createTable).\n        then(function(isValid){callback(null,isValid)}).\n        catch(callback);\n\n        function validate(tableStructure){\n\n            var validModel = true;\n            var model = new modelUtil.ModelDescription(typeName,description,self);\n\n            tableStructure[0].forEach(function(column){\n                column['Type'] = column['Type'].split('(')[0];   //ignore size specifications such as INT(10)\n            });\n\n            model.persistentProperties.some(function(modelProperty){\n                var expectedDbType = self.getDatabaseType(model.getFieldType(modelProperty));\n\n                if(expectedDbType === undefined){\n                    validModel = false;\n                    return true;\n                }\n\n                var validProperty = false;\n                tableStructure[0].some(function(column){\n                    if(column['Field'] === modelProperty){\n                        validProperty = true;\n                        var dbType = column['Type'];\n\n                        if(dbType.indexOf(')')!==-1){\n                            dbType = dbType.slice(dbType.indexOf('('));\n                        }\n\n                        if(dbType !== expectedDbType) {\n                            validProperty = false;\n                        }\n\n                        if(column['Key']==='PRI') {\n                            if (column['Field'] !== model.getPKField()) {\n                                validProperty = false;\n                            }\n                        }\n                        return true; // arry.some(callback) breaks when the callback returns true\n                    }\n                });\n\n                if(validProperty === false){\n                    validModel = false;\n                    return true; // same motivation\n                }\n            });\n            return validModel;\n        }\n\n        function createTable(){\n            var persistentFields = modelUtil.getModel(typeName).persistentProperties;\n            var tableDescription = {}\n            persistentFields.forEach(function(field){\n                tableDescription[field] = description[field];\n            });\n            return runQuery(mysqlUtils.createTable(self,typeName,tableDescription));\n        }\n\n    };\n\n    this.findById = function (typeName, serialized_id, callback) {\n        self.getObject(typeName,serialized_id,function(err,obj){\n            if(err){\n                callback(err);\n            }else{\n                if(obj.__meta.freshRawObject===true){\n                    callback(null,null);\n                }else{\n                    callback(undefined,obj);\n                }\n            }\n        });\n    };\n\n    this.getObject = function (typeName, serialized_id, callback) {\n        var query = mysqlUtils.find(typeName,modelUtil.getPKField(typeName),serialized_id);\n        mysqlPool.query(query,function(err,result){\n            if(err){\n                callback(err);\n            }else{\n                var model = modelUtil.getModel(typeName);\n                \n                var deserialized_id = modelUtil.deserialiseField(typeName,model.getPKField(),serialized_id,self)\n                var retObj = createRawObject(typeName, deserialized_id);\n                if (result.length>0) {\n                    modelUtil.load(retObj, result[0], self);\n                }\n                self.cache[deserialized_id] = retObj;\n                callback(null,retObj);\n            }\n        })\n    };\n\n    this.updateFields = function(obj,fields,values,callback){\n        var typeName = obj.__meta.typeName;\n        var pkName = obj.__meta.getPKField();\n        var id = obj.__meta.getPK();\n        var serialised_id = modelUtil.serialiseField(typeName,pkName,id,self);\n\n        var model = modelUtil.getModel(typeName);\n\n        var query;\n        if(obj.__meta.savedValues.hasOwnProperty(obj.__meta.getPKField()))\n            query = mysqlUtils.update(typeName,model.getPKField(),serialised_id,fields,values);\n        else{\n            var data = {};\n            fields.forEach(function(field,index){\n                data[field] = values[index];\n            })\n            query = mysqlUtils.insertRow(typeName,data);\n        }\n\n        mysqlPool.query(query,function(err,result){\n            if(err){\n                callback(err);\n            }else{\n                self.cache[id] = obj;\n                callback(null,obj);\n            }\n        });\n    };\n\n    this.filter = function(typeName,filter,callback){\n        function createObjectsFromData(queryResponse){\n            var results = queryResponse[0];\n            var objects = [];\n            results.forEach(function(rawData){\n                var newObject = createRawObject(typeName,rawData[modelUtil.getPKField(typeName)]);\n                modelUtil.load(newObject,rawData,self);\n                objects.push(newObject);\n            })\n            return objects;\n        }\n        runQuery(mysqlUtils.filter(typeName,filter)).\n        then(createObjectsFromData).\n        then(function(objectsArray){callback(null,objectsArray);}).\n        catch(callback);\n    };\n\n    this.deleteObject = function(typeName,id,callback){\n        var query = mysqlUtils.deleteObject(typeName,id);\n        runQuery(query).\n        then(function(result){\n            delete self.cache[id];\n            callback(null,result)}).\n        catch(function(err){\n            delete self.cache[id];\n            callback(err);\n        });\n    }\n}\n\nsqlPersistenceStrategy.prototype = require('../../lib/BasicStrategy.js').createBasicStrategy();\n\n\nexports.createMySqlStrategy = function (mysqlConnection){\n    return new sqlPersistenceStrategy(mysqlConnection);\n}\n\n", "/**\n * Created by ctalmacel on 12/21/15.\n */\n\n\nvar Q = require('q');\nvar modelUtil = require(\"../../lib/ModelDescription.js\");\n\nexports.createTable= function(persistenceStrategy,tableName,model){\n    var query = 'CREATE TABLE IF NOT EXISTS '+tableName+'(';\n    for(field in model){\n        query+=field+' ';\n        var type = model[field].type;\n        var dbType = persistenceStrategy.getDatabaseType(type);\n        if(dbType === 'varchar'){\n            if(model[field]['length']){\n                dbType += '('+model[field]['length']+') ';\n            }else {\n                dbType += '(30) ';\n            }\n        }\n\n        if(dbType === 'int'){\n            if(model[field]['length']){\n                dbType += '('+model[field]['length']+') ';\n            }else {\n                dbType += '(10) ';\n            }\n        }\n        query+=dbType;\n        if(field.hasOwnProperty('default')){\n            query+=' DEFAULT'+field.default;\n        }\n        query+=',';\n    }\n    for(field in model) {\n        if (model[field].pk === true) {\n            query += ' PRIMARY KEY (' + field + '),';\n        }\n    }\n\n        query = query.slice(0,-1);\n    query+=');';\n    return query;\n};\n\nexports.insertRow = function(tableName,serializedData){\n\n    var model = modelUtil.getModel(tableName);\n\n    var query=\"REPLACE INTO \"+tableName+\" (\";\n    for (field in serializedData){\n        query += field + \",\";\n    }\n    query = query.slice(0, -1);\n    query += \") VALUES (\";\n\n\n\n    for(var field in serializedData){\n        \n        if(model.getFieldDescription(field).type === 'boolean') {\n            query+=' b\\''+serializedData[field]+'\\',';\n        }else{\n            query+=' \\''+serializedData[field]+'\\',';\n        }\n\n\n    }\n    query = query.slice(0, -1);\n    query+=');';\n    return query;\n};\n\nexports.insertDataIntoTable = function(mysqlConnection,persistence,tableName,serializedData){\n    var result = [];\n    var runQuery = Q.nbind(mysqlConnection.query,mysqlConnection);\n    serializedData.forEach(function(row,index){\n        result.push(runQuery(exports.insertRow(mysqlConnection,persistence,tableName,row)));\n    });\n    return Q.all(result);\n};\n\nexports.createAndPopulateNewTable = function(mysqlConnection,persistence,tableName,model,serializedData){\n    return exports.createNewTable(mysqlConnection,persistence,tableName,model).\n    then(function(){return exports.insertDataIntoTable(mysqlConnection,persistence,tableName,serializedData,model)}).\n    catch(function(err){console.log(err.stack);});\n};\n\nexports.createNewTable = function(mysqlConnection,persistence,tableName,model){\n    return exports.dropTable(mysqlConnection,tableName).\n    then(function(){return exports.createTable(mysqlConnection,persistence,tableName,model)}).\n    catch(function(err){console.log(err.stack);});\n};\n\nexports.dropTable =function(tableName){\n    return \"DROP TABLE IF EXISTS \" +tableName+\";\";\n};\n\nexports.deleteObject = function(typeName,serialized_id){\n    return \"DELETE from \"+typeName+ \" WHERE \"+modelUtil.getPKField(typeName)+\" = \\'\"+serialized_id+\"\\';\";\n}\n\nexports.describeTable = function(typeName){\n    return \"DESCRIBE \"+typeName;\n}\n\nexports.find = function(typeName,pkField,serializedPk){\n    var query = 'SELECT * from ' + typeName + ' WHERE ' + pkField + \" = \\'\" + serializedPk+\"\\';\";\n    return query\n}\n\nexports.update = function(typeName,pkField,serialisedPk,fields,values){\n    var model = modelUtil.getModel(typeName);\n\n    var query = 'UPDATE '+typeName+ \" SET \";\n    var length = fields.length;\n    fields.forEach(function(field,index) {\n\n        if(model.getFieldDescription(field).type === \"boolean\"){\n            query += field+\"=b\\'\" +values[index]+\"\\',\";\n        }else{\n            query += field+\"=\\'\" +values[index]+\"\\',\";\n\n        }\n        \n    });\n    query = query.slice(0,-1);\n    query+=\"WHERE \"+pkField+\"=\\'\"+serialisedPk+\"\\';\";\n\n    return query;\n}\n\nexports.filter = function(typeName,filter){\n    var query = \"SELECT * from \"+typeName+\" \";\n\n\n    var model = modelUtil.getModel(typeName);\n\n    if(filter == undefined){\n        return query+\";\";\n    }\n    query +=\"WHERE \";\n    for(var field in filter){\n        if(model.getFieldDescription(field).type === \"boolean\"){\n            query += field + \"= b\\'\"+filter[field]+\"\\' AND \";\n        }else{\n            query += field + \"=\\'\"+filter[field]+\"\\' AND \";\n        }\n    }\n    query = query.slice(0,-4);\n    query+=\";\";\n    return query;\n}", "\nfunction BasicStrategy(){\n    var typeConverterRegistryFromDatabase = {};\n    var typeConverterRegistryToDatabase = {};\n\n    var typeToDbTypeCorrespondence = {};\n    var dbTypeToTypeCorrespondence = {};\n\n    this.registerConverter = function(typeName, fromDatabase, toDatabase, dbType){\n\n        typeConverterRegistryFromDatabase[typeName] = fromDatabase;\n        typeConverterRegistryToDatabase[typeName] = toDatabase;\n\n        if(dbType !== undefined) {\n\n            if(dbType.indexOf(')') != -1){\n                dbType = dbType.slice(dbType.indexOf('('));\n            }\n            typeToDbTypeCorrespondence[typeName] = dbType;\n            dbTypeToTypeCorrespondence[dbType] = typeName;\n        }\n    }\n\n    this.getConverterFrom = function(typeName){\n        return typeConverterRegistryFromDatabase[typeName];\n    }\n\n    this.getConverterTo = function(typeName){\n        return typeConverterRegistryToDatabase[typeName];\n    }\n\n    this.isFresh = function(obj){\n        return obj.__meta.freshRawObject;\n    }\n\n    this.getDatabaseType = function(typename){\n        return typeToDbTypeCorrespondence[typename];\n    }\n\n    this.getType = function(dbType){\n\n        if(dbType.indexOf(')') != -1){\n            dbType = dbType.slice(dbType.indexOf('('));\n        }\n        return dbTypeToTypeCorrespondence[dbType];\n    }\n\n    this.cache = {};\n}\n\n\nexports.createBasicStrategy = function(){\n    return new BasicStrategy();\n}", "\nvar apersistence = require(\"./abstractPersistence.js\");\n\nfunction ModelDescription(typeName, description, strategy){\n    this.persistentProperties = [];\n    this.transientProperties = [];  //these properties are other objects and are loaded lazily\n    var self = this;\n    var pkField = \"id\";\n    var template = {};\n    var functions = {};\n    var indexes = [];\n    var _hasIndexAll = false;\n\n    this.getFieldType = function(fieldName){\n        var desc = description[fieldName];\n        if(!desc){\n            return null;\n        }\n        return desc.type;\n    };\n\n    this.getFieldDescription = function(fieldName){\n        var desc = description[fieldName];\n        if(!desc){\n            return null;\n        }\n        return desc;\n    };\n\n    this.getIndexes = function(){\n        return indexes;\n    }\n\n    this.hasIndexAll = function(){\n         return _hasIndexAll;\n    }\n\n    this.getPKField = function(){\n        return pkField;\n    }\n\n    this.createRaw = function(pkValue){\n        var args = [];\n        for(var i = 0; i<arguments.length;i++){\n            args.push(arguments[i]);\n        }\n\n        var res = {\n            __meta:{\n                    typeName:typeName,\n                    freshRawObject:true,\n                    savedValues: {},\n                    getPK : function(){\n                        if(pkField){\n                            return res[pkField];\n                        } else {\n                            throw new Error(\"No pk member found for type \" + typeName);\n                        }\n                    },\n                    getPKField : function(){\n                        if(pkField){\n                            return pkField;\n                        } else {\n                            throw new Error(\"No pk member found for type \" + typeName);\n                        }\n                    },\n                    loadLazyField : function(field,callback){\n                        var typeDescription = self.getFieldDescription(field).type;\n                        var typeOfField = self.isArray(field)?typeDescription.split(\":\")[1]:typeDescription;\n\n                        var persistence = apersistence.getPersistenceForType(typeOfField);\n                        var relationFields = description[field].relation.split(\":\");\n\n                        var myField = relationFields[0];\n                        var hisField = relationFields[1];\n                        var filter = {};\n                        filter[hisField] = res[myField];\n                        persistence.filter(typeOfField,filter,function(err,results){\n                            if(err){\n                                callback(err);\n                            }else{\n                                if(!self.isArray(field)) {\n                                    results = results.length !== 0 ? results[0] : undefined\n                                }\n\n                                Object.defineProperty(res,field, {\n                                    get:function(field){\n                                        return results;\n                                    }\n                                });\n\n                                callback(null,res);\n                            }\n                        });\n                    },\n                    loadLazyFields: function(callback){\n                        var errs = {};\n                        var numErrs = 0;\n                        var left = self.transientProperties.length;\n                        self.transientProperties.forEach(function(transientField){\n                            res.__meta.loadLazyField(transientField,function(err,result){\n                                if(err){\n                                    errs[transientField] = err;\n                                    numErrs++;\n                                }\n                                left--;\n                                if(left===0 ){\n                                    if(numErrs>0) {\n                                        callback(errs, res);\n                                    }else{\n                                        callback(null,res);\n                                    }\n                                }\n                            })\n                        })\n                    }\n                }\n            };\n\n        res.assign = castAssign.bind(res);\n\n        res.__meta.getPK = res.__meta.getPK.bind(res);\n\n        for(var v in functions){\n            var field = description[v];\n            res[v] = field.bind(res);\n        }\n\n        for(var v in template){\n            res[v] = template[v];\n        }\n\n        // throw erros if trying to access lazy fields that are not loaded or setting fields #this is not OOP:)\n        self.transientProperties.forEach(function(field){\n\n            Object.defineProperty(res,field,{\n                get:function(field){\n                    return null;\n                },\n                set:function(){\n                    throw new Error(\"Cannot set lazy fields\\nUse the relationship table for such things\")\n                },\n                configurable:true,\n                enumerable:true\n            })\n\n        });\n\n        res[pkField] = pkValue;\n\n        if(description.ctor){\n            description.ctor.apply(res,args);\n        }\n\n        return res;\n    };\n\n    this.isTransient = function(field){\n        return !strategy.getConverterTo(description[field].type) &&\n            !strategy.getConverterTo(description[field].type.split(\":\")[1])\n    };\n\n    this.isArray = function(field){\n        return description[field].type.match(\"array\")?true:false;\n    };\n\n    for(var v in description){\n        var field = description[v];\n        if(typeof field !== \"function\"){\n            if(this.isTransient(v)){\n                description[v].loadLazy = true;\n                this.transientProperties.push(v);\n            }else{\n                this.persistentProperties.push(v);\n                if(field.pk === true){\n                    pkField = v;\n                }\n\n                if(field.index === true){\n                    _hasIndexAll = true;\n                    indexes.push(v);\n                }\n                template[v] = field.default;\n            }\n        } else {\n            functions[v] = field;\n        }\n    }\n    \n\n    function castAssign(fieldName, value){ //will get binding to a model object\n        this[fieldName] = convertFrom(strategy, this.__meta.typeName, fieldName, value)\n    }\n}\n\nvar models = {};\n\nexports.registerModel = function(typeName, description, strategy){\n    models[typeName] = new ModelDescription(typeName, description, strategy);\n    return models[typeName];\n};\n\nexports.ModelDescription = ModelDescription;\n\nfunction convertFrom(strategy, modelName, fieldName, fromData){\n    var model = models[modelName];\n    var typeDesc = model.getFieldDescription(fieldName);\n    var typeName = typeDesc.type;\n    if(!typeName){\n        throw new Error(\"Unknown type name for field \"+fieldName+\" in model \"+modelName);\n    }\n\n    if(typeName.match('array')){\n        typeName = 'array';\n    }\n    var converterFrom = strategy.getConverterFrom(typeName);\n    if(!converterFrom){\n        throw new Error(\"No register convertor can deserialize field of type \"+typeName);\n    }\n\n    if(fromData == null || fromData == undefined){\n        return fromData;\n    }\n    return converterFrom(fromData,typeDesc);\n}\n\nfunction convertTo(modelName, fieldName,value, strategy){\n    var model = models[modelName];\n    var typeDesc = model.getFieldDescription(fieldName);\n    var typeName = typeDesc.type;\n    if(!typeName){\n        throw new Error(\"Unknown type name for field \"+fieldName+\" in model \"+modelName);\n    }\n\n    if(typeName.match('array')){\n        typeName = 'array';\n    }\n    var converterOut = strategy.getConverterTo(typeName);\n    if(!converterOut){\n        throw new Error(\"No register convertor can serialize field of type \"+typeName);\n    }\n    if(value == null || value == undefined){\n        return value;\n    }\n    return converterOut(value,typeDesc);\n}\n\nexports.load = function( rawObject, from , strategy){\n    var rawModel = models[rawObject.__meta.typeName];\n    var props = rawModel.persistentProperties;\n    props.forEach(function(p){\n        if(from[p] || from[p]===false) {\n            var value = convertFrom(strategy, rawObject.__meta.typeName, p, from[p]);\n            rawObject[p] = value;\n            rawObject.__meta.savedValues[p] = value;\n        }\n    });\n    delete rawObject.__meta.freshRawObject;\n};\n\nexports.updateObject = function(modelObject,from,strategy){\n    var props = models[modelObject.__meta.typeName].persistentProperties\n    props.forEach(function(property){\n        if(from[property]) {\n            modelObject[property] = convertFrom(strategy, modelObject.__meta.typeName, property, from[property]);\n        }\n    })\n};\n\nexports.serialiseField = function(typeName,field,value,strategy){\n    return convertTo(typeName,field,value,strategy);\n};\n\nexports.serialiseObjectValues = function(typeName,object,strategy){\n    var ser = {};\n    for(var field in object){\n        var s = exports.serialiseField(typeName,field,object[field],strategy)\n        ser[field] = s;\n    }\n    return ser;\n};\n\nexports.deserialiseField = function(typeName,field,value,strategy){\n    return convertFrom(strategy,typeName,field,value);\n};\n\nexports.changesDiff = function(obj){\n    var diff = [];\n    var modelObject = models[obj.__meta.typeName];\n    modelObject.persistentProperties.forEach(function (p) {\n        if (!modelObject.isArray(p)) {\n            if (obj[p] !== obj.__meta.savedValues[p]) {\n                diff.push(p);\n            }\n        } else {\n            if (!arraysMatch(obj[p], obj.__meta.savedValues[p])) {\n                diff.push(p);\n            }\n        }\n    });    \n    return diff;\n    function arraysMatch(arr1,arr2){\n        try {\n            if (arr1.length !== arr2.length) {\n                return false;\n            }\n            for (var arrIndex = 0; arrIndex < arr1.length; arrIndex++) {\n                if (arr1[arrIndex] !== arr2[arrIndex]) {\n                    return false;\n                }\n            }\n            return true;\n        }catch(e){\n            //one of the arrays is probably undefined\n            return false;\n        }\n    }\n};\n\nexports.createObjectFromData = function(typename,data){\n    var m = models[typename];\n    var raw = exports.createRaw(typename, data[m.getPKField()]);\n    var props = m.persistentProperties;\n    props.forEach(function(p){\n        raw[p]= data[p];\n    })\n    delete raw.__meta.freshRawObject;\n    return raw;\n}\n\nexports.createRaw = function(typeName, pk,strategy){\n    var d = models[typeName];\n    return d.createRaw(pk);\n}\n\nexports.getIndexes = function(typeName){\n    var d = models[typeName];\n    return d.getIndexes();\n}\n\nexports.hasIndexAll = function(typeName){\n    var d = models[typeName];\n    return d.hasIndexAll();\n}\n\nexports.getPKField = function(typeName){\n    var d = models[typeName];\n    return d.getPKField();\n}\n\nexports.getModel = function(typeName){\n    return models[typeName];\n}\n\nexports.getInnerValues = function(obj, strategy){\n    var ret = {};\n    for(var field in obj){\n        if(field != \"__meta\" && typeof obj[field] != \"function\"){\n            ret[field] = obj[field];\n        }\n    }\n    return ret;\n}\n\n", "/**\n * Created by ctalmacel on 12/15/15.\n */\n\n\nexports.registerTypeConverters = function(persistence){\n    persistence.registerConverter(\"string\",\n        function(value){\n            return value;\n        },\n        function(value){\n            return value;\n        },\n        'varchar'\n    )\n    persistence.registerConverter(\"textString\",\n        function(value){\n            return value;\n        },\n        function(value){\n            return value;\n        },\n        'text'\n    )\n\n    persistence.registerConverter('int',\n        function(value){\n            return (value);\n        },\n        function(value){\n            return value;\n        },\n        \"int\"\n    )\n\n    persistence.registerConverter('float',\n        function(value){\n            return value;\n        },\n        function(value){\n            return value;\n        },\n        \"float\"\n    )\n\n    persistence.registerConverter('boolean',\n        function(value){\n            \n            if(value[0] != '0') {\n                return true;\n            }\n            else {\n                return false;\n            }\n        },\n        function(value){\n            if(value){\n                return \"1\"\n            }\n            else{\n                return \"0\"\n            }\n        },\n        \"bit\"\n    );\n\n    persistence.registerConverter('date',\n        function(value){\n            return value.toISOString().substring(0,10);\n        },\n        function(javascriptDate){\n            return javascriptDate.toISOString().slice(0, 19).replace('T', ' ');\n        },\n        \"date\"\n    )\n\n    persistence.registerConverter(\"dateFormat\",\n        function(value, typeDescription){\n            if(!value){\n                return null;\n            }\n            var m = moment(value,typeDescription.format);\n            return m;\n        },\n        function(value, typeDescription){\n            var txt = value.format(typeDescription.format);\n            return txt;\n        },\n        \"varchar\"\n    );\n\n    persistence.registerConverter(\"array\",\n        function(blobOfStuff, typeDescription){\n            if (blobOfStuff == null || blobOfStuff == undefined){\n                return \"null\";\n            }\n            return JSON.parse(blobOfStuff);\n        },\n        function(arrayOfStuff, typeDescription){\n            if(arrayOfStuff == \"null\"){\n                return null;\n            }\n            if(arrayOfStuff.length>0&&arrayOfStuff[0].__meta){\n                //the array is of lazy objects and was filled\n                arrayOfStuff = arrayOfStuff.map(function(lazyLoadedObject){\n                    return lazyLoadedObject.__meta.getPK()\n                })\n            }\n\n            return JSON.stringify(arrayOfStuff)\n        },\n        'blob'\n    )\n}", "/**\n * Created by ciprian on 3/16/17.\n */\n\n\nvar apersistence = require(\"../lib/abstractPersistence.js\");\nvar mysqlUtils = require(\"../db/sql/mysqlUtils\");\nvar modelUtil  = require(\"../lib/ModelDescription\");\nvar assert = require('double-check').assert;\nvar mysql      = require('mysql');\nvar mysqlPool = mysql.createPool({\n    host     : 'localhost',\n    user     : 'root',\n    password : 'operando',\n    database : 'operando'\n});\n\nvar userModel = {\n    name: {\n        pk:true,\n        type:'string',\n        default:\"Mircea Cartarescu\"\n    },\n    bookName1:{\n        \"type\":\"string\",\n        \"default\":\"War and Peace\"\n    },\n    bookName2:{\n        \"type\":\"string\",\n        \"default\":\"War and Peace\"\n    },\n    book1:{\n        type:\"TestBook\",\n        relation:\"bookName1:name\"\n    },\n    book2:{\n        type:\"TestBook\",\n        relation:\"bookName2:name\"\n    }\n};\nvar bookModel = {\n    name:{\n        pk:true,\n        type:'string'\n    }\n};\n\n\nvar persistence = apersistence.createMySqlPersistence(mysqlPool);\nfunction storeSomeBooks(callback){\n    var book1 = apersistence.createRawObject(\"TestBook\",\"Shogun\");\n    var book2 = apersistence.createRawObject(\"TestBook\",\"War And Peace\");\n    persistence.save(book1,function(err,result){\n        if(err){\n            callback(err);\n        }else {\n            persistence.save(book2, function (err, result) {\n                if (err) {\n                    callback(err)\n                }else {\n                    callback(null, [book1, book2]);\n                }\n            })\n        }\n    })\n}\n\nassert.steps(\"Load lazy objects test\",[\n    function(next){\n        mysqlPool.query(\"DROP TABLE TestUser\", function (err, result) {\n            mysqlPool.query(\"DROP TABLE TestBook\", function (err, result) {\n                next();\n            });\n        });\n    },\n    function(next) {\n        persistence.registerModel(\"TestBook\", bookModel, function (err, result) {\n        });\n        persistence.registerModel(\"TestUser\", userModel, function (err, result) {\n            next();\n        })\n    },\n    function(next){\n        storeSomeBooks(function (err, books) {\n            var user = apersistence.createRawObject(\"TestUser\", \"Johnny Smith\");\n            try {\n                user.book1 = books[0];\n                assert.fail(\"Should throw error. Cannot set transient properties directly.\")\n            } catch (e) {\n                user.bookName1 = \"Shogun\";\n                persistence.save(user, function (err, user) {\n                    next()\n                })\n            }\n        })\n    },\n    function(next) {\n        persistence.findById(\"TestUser\", \"Johnny Smith\", function (err, user) {\n            assert.equal(user.name, \"Johnny Smith\",\"Should retrieve the right user\");\n            user.__meta.loadLazyFields(function (err, user) {\n                assert.equal(user.book1.name, \"Shogun\",\"Should match the expected data\");\n                assert.equal(user.book2.name, \"War And Peace\",\"Should match the expected data\");\n                assert.equal(user.book1.__meta !== undefined, true,\"Should be loaded\");\n                mysqlPool.query(\"DROP TABLE TestUser\", function (err, result) {\n                    mysqlPool.query(\"DROP TABLE TestBook\", function (err, result) {\n                        mysqlPool.end();\n                        next();\n                    });\n                });\n            })\n        })\n    }]);\n\n\n\n\n"], "fixing_code": ["/**\n * Created by ctalmacel on 12/8/15.\n */\n\nvar Q = require('q');\nvar createRawObject = require(\"../../lib/abstractPersistence.js\").createRawObject;\nvar modelUtil = require(\"../../lib/ModelDescription.js\");\nvar mysqlUtils = require(\"./mysqlUtils.js\");\n\nfunction sqlPersistenceStrategy(mysqlPool) {\n    var self = this;\n    var runQuery = Q.nbind(mysqlPool.query,mysqlPool);\n\n    this.validateModel = function(typeName,description,callback){\n        runQuery(mysqlUtils.describeTable(typeName)).\n        then(validate,createTable).\n        then(function(isValid){callback(null,isValid)}).\n        catch(callback);\n\n        function validate(tableStructure){\n\n            var validModel = true;\n            var model = new modelUtil.ModelDescription(typeName,description,self);\n            \n            tableStructure[0].forEach(function(column){\n                column['Type'] = column['Type'].split('(')[0];   //ignore size specifications such as INT(10) ... not neccesarily reccomender\n            });\n\n            model.persistentProperties.some(function(modelProperty){\n                var expectedDbType = self.getDatabaseType(model.getFieldType(modelProperty));\n                if(expectedDbType === undefined){\n                    validModel = false;\n                    return true;\n                }\n\n                var validProperty = false;\n                tableStructure[0].some(function(column){\n                    if(column['Field'] === modelProperty){\n                        validProperty = true;\n                        var dbType = column['Type'];\n\n                        if(dbType.indexOf(')')!==-1){\n                            dbType = dbType.slice(dbType.indexOf('('));\n                        }\n\n                        if(dbType !== expectedDbType) {\n                            validProperty = false;\n                        }\n\n                        if(column['Key']==='PRI') {\n                            if (column['Field'] !== model.getPKField()) {\n                                validProperty = false;\n                            }\n                        }\n                        return true; // arry.some(callback) breaks when the callback returns true\n                    }\n                });\n\n                if(validProperty === false){\n                    validModel = false;\n                    return true; // same motivation\n                }\n            });\n            return validModel;\n        }\n\n        function createTable(){\n            var persistentFields = modelUtil.getModel(typeName).persistentProperties;\n            var tableDescription = {}\n            persistentFields.forEach(function(field){\n                tableDescription[field] = description[field];\n            });\n            return runQuery(mysqlUtils.createTable(self,typeName,tableDescription));\n        }\n\n    };\n\n    this.findById = function (typeName, serialized_id, callback) {\n        self.getObject(typeName,serialized_id,function(err,obj){\n            if(err){\n                callback(err);\n            }else{\n                if(obj.__meta.freshRawObject===true){\n                    callback(null,null);\n                }else{\n                    callback(undefined,obj);\n                }\n            }\n        });\n    };\n\n    this.getObject = function (typeName, serialized_id, callback) {\n        var query = mysqlUtils.find(typeName,modelUtil.getPKField(typeName),serialized_id);\n        mysqlPool.query(query,function(err,result){\n            if(err){\n                callback(err);\n            }else{\n                var model = modelUtil.getModel(typeName);\n                var deserialized_id = modelUtil.deserialiseField(typeName,model.getPKField(),serialized_id,self);\n                var retObj = createRawObject(typeName, deserialized_id);\n                if (result.length>0) {\n                    modelUtil.load(retObj, result[0], self);\n                }\n                self.cache[deserialized_id] = retObj;\n                callback(null,retObj);\n            }\n        })\n    };\n\n    this.updateFields = function(obj,fields,values,callback){\n        var typeName = obj.__meta.typeName;\n        var pkName = obj.__meta.getPKField();\n        var id = obj.__meta.getPK();\n        var serialised_id = modelUtil.serialiseField(typeName,pkName,id,self);\n\n        var model = modelUtil.getModel(typeName);\n\n        var query;\n        if(obj.__meta.savedValues.hasOwnProperty(obj.__meta.getPKField()))\n            query = mysqlUtils.update(typeName,model.getPKField(),serialised_id,fields,values);\n        else{\n            var data = {};\n            fields.forEach(function(field,index){\n                data[field] = values[index];\n            })\n            query = mysqlUtils.insertRow(typeName,data);\n        }\n\n        mysqlPool.query(query,function(err,result){\n            if(err){\n                callback(err);\n            }else{\n                self.cache[id] = obj;\n                callback(null,obj);\n            }\n        });\n    };\n\n    this.filter = function(typeName,filter,callback){\n        function createObjectsFromData(queryResponse){\n            var results = queryResponse[0];\n            var objects = [];\n            results.forEach(function(rawData){\n                var newObject = createRawObject(typeName,rawData[modelUtil.getPKField(typeName)]);\n                modelUtil.load(newObject,rawData,self);\n                objects.push(newObject);\n            })\n            return objects;\n        }\n        runQuery(mysqlUtils.filter(typeName,filter)).\n        then(createObjectsFromData).\n        then(function(objectsArray){callback(null,objectsArray);}).\n        catch(callback);\n    };\n\n    this.deleteObject = function(typeName,id,callback){\n        var query = mysqlUtils.deleteObject(typeName,id);\n        runQuery(query).\n        then(function(result){\n            delete self.cache[id];\n            callback(null,result)}).\n        catch(function(err){\n            delete self.cache[id];\n            callback(err);\n        });\n    }\n}\n\nsqlPersistenceStrategy.prototype = require('../../lib/BasicStrategy.js').createBasicStrategy();\n\n\nexports.createMySqlStrategy = function (mysqlConnection){\n    return new sqlPersistenceStrategy(mysqlConnection);\n}\n\n", "/**\n * Created by ctalmacel on 12/21/15.\n */\n\nvar mysql = require('mysql');\nvar Q = require('q');\nvar modelUtil = require(\"../../lib/ModelDescription.js\");\n\nexports.createTable= function(persistenceStrategy,tableName,model){\n    var query = 'CREATE TABLE IF NOT EXISTS '+tableName+'(';\n    for(field in model){\n        query+=field+' ';\n        var type = model[field].type;\n        var dbType = persistenceStrategy.getDatabaseType(type);\n        if(dbType === 'varchar'){\n            if(model[field]['length']){\n                dbType += '('+model[field]['length']+') ';\n            }else {\n                dbType += '(30) ';\n            }\n        }\n\n        if(dbType === 'int'){\n            if(model[field]['length']){\n                dbType += '('+model[field]['length']+') ';\n            }else {\n                dbType += '(10) ';\n            }\n        }\n        query+=dbType;\n        if(field.hasOwnProperty('default')){\n            query+=' DEFAULT'+field.default;\n        }\n        query+=',';\n    }\n    for(field in model) {\n        if (model[field].pk === true) {\n            query += ' PRIMARY KEY (' + field + '),';\n        }\n    }\n\n        query = query.slice(0,-1);\n    query+=');';\n    return query;\n};\n\nexports.insertRow = function(tableName,serializedData){\n\n    var model = modelUtil.getModel(tableName);\n\n    var query=\"REPLACE INTO \"+tableName+\" (\";\n    for (field in serializedData){\n        query += field + \",\";\n    }\n    query = query.slice(0, -1);\n    query += \") VALUES (\";\n\n\n\n    for(var field in serializedData){\n        query+= mysql.escape(serializedData[field])+',';\n    }\n    query = query.slice(0, -1);\n    query+=');';\n    return query;\n};\n\nexports.insertDataIntoTable = function(mysqlConnection,persistence,tableName,serializedData){\n    var result = [];\n    var runQuery = Q.nbind(mysqlConnection.query,mysqlConnection);\n    serializedData.forEach(function(row,index){\n        result.push(runQuery(exports.insertRow(mysqlConnection,persistence,tableName,row)));\n    });\n    return Q.all(result);\n};\n\nexports.createAndPopulateNewTable = function(mysqlConnection,persistence,tableName,model,serializedData){\n    return exports.createNewTable(mysqlConnection,persistence,tableName,model).\n    then(function(){return exports.insertDataIntoTable(mysqlConnection,persistence,tableName,serializedData,model)}).\n    catch(function(err){console.log(err.stack);});\n};\n\nexports.createNewTable = function(mysqlConnection,persistence,tableName,model){\n    return exports.dropTable(mysqlConnection,tableName).\n    then(function(){return exports.createTable(mysqlConnection,persistence,tableName,model)}).\n    catch(function(err){console.log(err.stack);});\n};\n\nexports.dropTable =function(tableName){\n    return \"DROP TABLE IF EXISTS \" +tableName+\";\";\n};\n\nexports.deleteObject = function(typeName,serialized_id){\n    return \"DELETE from \"+typeName+ \" WHERE \"+modelUtil.getPKField(typeName)+\" = \\'\"+serialized_id+\"\\';\";\n}\n\nexports.describeTable = function(typeName){\n    return \"DESCRIBE \"+typeName;\n}\n\nexports.find = function(typeName,pkField,serializedPk){\n    var query = 'SELECT * from ' + typeName + ' WHERE ' + pkField + \" = \\'\" + serializedPk+\"\\';\";\n    return query\n}\n\nexports.update = function(typeName,pkField,serialisedPk,fields,values){\n    var model = modelUtil.getModel(typeName);\n\n    var query = 'UPDATE '+typeName+ \" SET \";\n    var length = fields.length;\n    fields.forEach(function(field,index) {\n\n        if(model.getFieldDescription(field).type === \"boolean\"){\n            query += field+\"=b\\'\" +values[index]+\"\\',\";\n        }else{\n            query += field+\"=\\'\" +values[index]+\"\\',\";\n\n        }\n        \n    });\n    query = query.slice(0,-1);\n    query+=\"WHERE \"+pkField+\"=\\'\"+serialisedPk+\"\\';\";\n\n    return query;\n}\n\nexports.filter = function(typeName,filter){\n    var query = \"SELECT * from \"+typeName+\" \";\n\n\n    var model = modelUtil.getModel(typeName);\n\n    if(filter == undefined){\n        return query+\";\";\n    }\n    query +=\"WHERE \";\n    for(var field in filter){\n        if(model.getFieldDescription(field).type === \"boolean\"){\n            query += field + \"= b\\'\"+filter[field]+\"\\' AND \";\n        }else{\n            query += field + \"=\\'\"+filter[field]+\"\\' AND \";\n        }\n    }\n    query = query.slice(0,-4);\n    query+=\";\";\n    return query;\n}", "\nfunction BasicStrategy(){\n    var typeConverterRegistryFromDatabase = {};\n    var typeConverterRegistryToDatabase = {};\n\n    var typeToDbTypeCorrespondence = {};\n    var dbTypeToTypeCorrespondence = {};\n\n    this.registerConverter = function(typeName, fromDatabase, toDatabase, dbType){\n\n        typeConverterRegistryFromDatabase[typeName] = fromDatabase;\n        typeConverterRegistryToDatabase[typeName] = toDatabase;\n\n        if(dbType !== undefined) {\n\n            if(dbType.indexOf(')') != -1){\n                dbType = dbType.slice(0,dbType.indexOf('('));\n            }\n            typeToDbTypeCorrespondence[typeName] = dbType;\n            dbTypeToTypeCorrespondence[dbType] = typeName;\n        }\n    }\n\n    this.getConverterFrom = function(typeName){\n        return typeConverterRegistryFromDatabase[typeName];\n    }\n\n    this.getConverterTo = function(typeName){\n        return typeConverterRegistryToDatabase[typeName];\n    }\n\n    this.isFresh = function(obj){\n        return obj.__meta.freshRawObject;\n    }\n\n    this.getDatabaseType = function(typename){\n        return typeToDbTypeCorrespondence[typename];\n    }\n\n    this.getType = function(dbType){\n\n        if(dbType.indexOf(')') != -1){\n            dbType = dbType.slice(dbType.indexOf('('));\n        }\n        return dbTypeToTypeCorrespondence[dbType];\n    }\n\n    this.cache = {};\n}\n\n\nexports.createBasicStrategy = function(){\n    return new BasicStrategy();\n}", "\nvar apersistence = require(\"./abstractPersistence.js\");\n\nfunction ModelDescription(typeName, description, strategy){\n    this.persistentProperties = [];\n    this.transientProperties = [];  //these properties are other objects and are loaded lazily\n    var self = this;\n    var pkField = \"id\";\n    var template = {};\n    var functions = {};\n    var indexes = [];\n    var _hasIndexAll = false;\n\n    this.getFieldType = function(fieldName){\n        var desc = description[fieldName];\n        if(!desc){\n            return null;\n        }\n        return desc.type;\n    };\n\n    this.getFieldDescription = function(fieldName){\n        var desc = description[fieldName];\n        if(!desc){\n            return null;\n        }\n        return desc;\n    };\n\n    this.getIndexes = function(){\n        return indexes;\n    }\n\n    this.hasIndexAll = function(){\n         return _hasIndexAll;\n    }\n\n    this.getPKField = function(){\n        return pkField;\n    }\n\n    this.createRaw = function(pkValue){\n        var args = [];\n        for(var i = 0; i<arguments.length;i++){\n            args.push(arguments[i]);\n        }\n\n        var res = {\n            __meta:{\n                    typeName:typeName,\n                    freshRawObject:true,\n                    savedValues: {},\n                    getPK : function(){\n                        if(pkField){\n                            return res[pkField];\n                        } else {\n                            throw new Error(\"No pk member found for type \" + typeName);\n                        }\n                    },\n                    getPKField : function(){\n                        if(pkField){\n                            return pkField;\n                        } else {\n                            throw new Error(\"No pk member found for type \" + typeName);\n                        }\n                    },\n                    loadLazyField : function(field,callback){\n                        var typeDescription = self.getFieldDescription(field).type;\n                        var typeOfField = self.isArray(field)?typeDescription.split(\":\")[1]:typeDescription;\n\n                        var persistence = apersistence.getPersistenceForType(typeOfField);\n                        var relationFields = description[field].relation.split(\":\");\n\n                        var myField = relationFields[0];\n                        var hisField = relationFields[1];\n                        var filter = {};\n                        filter[hisField] = res[myField];\n                        persistence.filter(typeOfField,filter,function(err,results){\n                            if(err){\n                                callback(err);\n                            }else{\n                                if(!self.isArray(field)) {\n                                    results = results.length !== 0 ? results[0] : undefined\n                                }\n\n                                Object.defineProperty(res,field, {\n                                    get:function(field){\n                                        return results;\n                                    }\n                                });\n\n                                callback(null,res);\n                            }\n                        });\n                    },\n                    loadLazyFields: function(callback){\n                        var errs = {};\n                        var numErrs = 0;\n                        var left = self.transientProperties.length;\n                        self.transientProperties.forEach(function(transientField){\n                            res.__meta.loadLazyField(transientField,function(err,result){\n                                if(err){\n                                    errs[transientField] = err;\n                                    numErrs++;\n                                }\n                                left--;\n                                if(left===0 ){\n                                    if(numErrs>0) {\n                                        callback(errs, res);\n                                    }else{\n                                        callback(null,res);\n                                    }\n                                }\n                            })\n                        })\n                    }\n                }\n            };\n\n        res.assign = castAssign.bind(res);\n\n        res.__meta.getPK = res.__meta.getPK.bind(res);\n\n        for(var v in functions){\n            var field = description[v];\n            res[v] = field.bind(res);\n        }\n\n        for(var v in template){\n            res[v] = template[v];\n        }\n\n        // throw erros if trying to access lazy fields that are not loaded or setting fields #this is not OOP:)\n        self.transientProperties.forEach(function(field){\n            Object.defineProperty(res,field,{\n                get:function(field){\n                    return null;\n                },\n                set:function(){\n                    throw new Error(\"Cannot set lazy fields\\nUse the relationship table for such things\")\n                },\n                configurable:true,\n                enumerable:true\n            })\n\n        });\n\n        res[pkField] = pkValue;\n\n        if(description.ctor){\n            description.ctor.apply(res,args);\n        }\n\n        return res;\n    };\n\n    this.isTransient = function(field){\n        return !strategy.getConverterTo(description[field].type) &&\n            !strategy.getConverterTo(description[field].type.split(\":\")[1])\n    };\n\n    this.isArray = function(field){\n        return description[field].type.match(\"array\")?true:false;\n    };\n\n    for(var v in description){\n        var field = description[v];\n        if(typeof field !== \"function\"){\n            if(this.isTransient(v)){\n                description[v].loadLazy = true;\n                this.transientProperties.push(v);\n            }else{\n                this.persistentProperties.push(v);\n                if(field.pk === true){\n                    pkField = v;\n                }\n\n                if(field.index === true){\n                    _hasIndexAll = true;\n                    indexes.push(v);\n                }\n                template[v] = field.default;\n            }\n        } else {\n            functions[v] = field;\n        }\n    }\n    \n\n    function castAssign(fieldName, value){ //will get binding to a model object\n        this[fieldName] = convertFrom(strategy, this.__meta.typeName, fieldName, value)\n    }\n}\n\nvar models = {};\n\nexports.registerModel = function(typeName, description, strategy){\n    models[typeName] = new ModelDescription(typeName, description, strategy);\n    return models[typeName];\n};\n\nexports.ModelDescription = ModelDescription;\n\nfunction convertFrom(strategy, modelName, fieldName, fromData){\n    var model = models[modelName];\n    var typeDesc = model.getFieldDescription(fieldName);\n    var typeName = typeDesc.type;\n    if(!typeName){\n        throw new Error(\"Unknown type name for field \"+fieldName+\" in model \"+modelName);\n    }\n\n    if(typeName.match('array')){\n        typeName = 'array';\n    }\n    var converterFrom = strategy.getConverterFrom(typeName);\n    if(!converterFrom){\n        throw new Error(\"No register convertor can deserialize field of type \"+typeName);\n    }\n\n    if(fromData == null || fromData == undefined){\n        return fromData;\n    }\n    return converterFrom(fromData,typeDesc);\n}\n\nfunction convertTo(modelName, fieldName,value, strategy){\n    var model = models[modelName];\n    var typeDesc = model.getFieldDescription(fieldName);\n    var typeName = typeDesc.type;\n    if(!typeName){\n        throw new Error(\"Unknown type name for field \"+fieldName+\" in model \"+modelName);\n    }\n\n    if(typeName.match('array')){\n        typeName = 'array';\n    }\n    var converterOut = strategy.getConverterTo(typeName);\n    if(!converterOut){\n        throw new Error(\"No register convertor can serialize field of type \"+typeName);\n    }\n    if(value == null || value == undefined){\n        return value;\n    }\n    return converterOut(value,typeDesc);\n}\n\nexports.load = function( rawObject, from , strategy){\n    var rawModel = models[rawObject.__meta.typeName];\n    var props = rawModel.persistentProperties;\n    props.forEach(function(p){\n        if(from.hasOwnProperty(p)) {\n            var value = convertFrom(strategy, rawObject.__meta.typeName, p, from[p]);\n            rawObject[p] = value;\n            rawObject.__meta.savedValues[p] = value;\n        }\n    });\n    delete rawObject.__meta.freshRawObject;\n};\n\nexports.updateObject = function(modelObject,from,strategy){\n    var props = models[modelObject.__meta.typeName].persistentProperties\n    props.forEach(function(property){\n        if(from[property]) {\n            modelObject[property] = convertFrom(strategy, modelObject.__meta.typeName, property, from[property]);\n        }\n    })\n};\n\nexports.serialiseField = function(typeName,field,value,strategy){\n    return convertTo(typeName,field,value,strategy);\n};\n\nexports.serialiseObjectValues = function(typeName,object,strategy){\n    var ser = {};\n    for(var field in object){\n        var s = exports.serialiseField(typeName,field,object[field],strategy)\n        ser[field] = s;\n    }\n    return ser;\n};\n\nexports.deserialiseField = function(typeName,field,value,strategy){\n    return convertFrom(strategy,typeName,field,value);\n};\n\nexports.changesDiff = function(obj){\n    var diff = [];\n    var modelObject = models[obj.__meta.typeName];\n    modelObject.persistentProperties.forEach(function (p) {\n        if (!modelObject.isArray(p)) {\n            if (obj[p] !== obj.__meta.savedValues[p]) {\n                diff.push(p);\n            }\n        } else {\n            if (!arraysMatch(obj[p], obj.__meta.savedValues[p])) {\n                diff.push(p);\n            }\n        }\n    });    \n    return diff;\n    function arraysMatch(arr1,arr2){\n        try {\n            if (arr1.length !== arr2.length) {\n                return false;\n            }\n            for (var arrIndex = 0; arrIndex < arr1.length; arrIndex++) {\n                if (arr1[arrIndex] !== arr2[arrIndex]) {\n                    return false;\n                }\n            }\n            return true;\n        }catch(e){\n            //one of the arrays is probably undefined\n            return false;\n        }\n    }\n};\n\nexports.createObjectFromData = function(typename,data){\n    var m = models[typename];\n    var raw = exports.createRaw(typename, data[m.getPKField()]);\n    var props = m.persistentProperties;\n    props.forEach(function(p){\n        raw[p]= data[p];\n    })\n    delete raw.__meta.freshRawObject;\n    return raw;\n}\n\nexports.createRaw = function(typeName, pk,strategy){\n    var d = models[typeName];\n    return d.createRaw(pk);\n}\n\nexports.getIndexes = function(typeName){\n    var d = models[typeName];\n    return d.getIndexes();\n}\n\nexports.hasIndexAll = function(typeName){\n    var d = models[typeName];\n    return d.hasIndexAll();\n}\n\nexports.getPKField = function(typeName){\n    var d = models[typeName];\n    return d.getPKField();\n}\n\nexports.getModel = function(typeName){\n    return models[typeName];\n}\n\nexports.getInnerValues = function(obj, strategy){\n    var ret = {};\n    for(var field in obj){\n        if(field != \"__meta\" && typeof obj[field] != \"function\"){\n            ret[field] = obj[field];\n        }\n    }\n    return ret;\n}\n\n", "/**\n * Created by ctalmacel on 12/15/15.\n */\n\n\nexports.registerTypeConverters = function(persistence){\n    persistence.registerConverter(\"string\",\n        function(value){\n            return value;\n        },\n        function(value){\n            return value;\n        },\n        'varchar'\n    )\n    persistence.registerConverter(\"textString\",\n        function(value){\n            return value;\n        },\n        function(value){\n            return value;\n        },\n        'text'\n    )\n\n    persistence.registerConverter('int',\n        function(value){\n            return (value);\n        },\n        function(value){\n            return value;\n        },\n        \"int\"\n    )\n\n    persistence.registerConverter('float',\n        function(value){\n            return value;\n        },\n        function(value){\n            return value;\n        },\n        \"float\"\n    )\n\n    persistence.registerConverter('boolean',\n        function(value){\n            if(value == 1) {\n                return true;\n            }\n            else {\n                return false;\n            }\n        },\n        function(value){\n            if(value == true){\n                return 1\n            }\n            else{\n                return 0\n            }\n        },\n        \"tinyint(1)\"\n    );\n\n    persistence.registerConverter('date',\n        function(value){\n            return value.toISOString().substring(0,10);\n        },\n        function(javascriptDate){\n            return javascriptDate.toISOString().slice(0, 19).replace('T', ' ');\n        },\n        \"date\"\n    )\n\n    persistence.registerConverter(\"dateFormat\",\n        function(value, typeDescription){\n            if(!value){\n                return null;\n            }\n            var m = moment(value,typeDescription.format);\n            return m;\n        },\n        function(value, typeDescription){\n            var txt = value.format(typeDescription.format);\n            return txt;\n        },\n        \"varchar\"\n    );\n\n    persistence.registerConverter(\"array\",\n        function(blobOfStuff, typeDescription){\n            if (blobOfStuff == null || blobOfStuff == undefined){\n                return \"null\";\n            }\n            return JSON.parse(blobOfStuff);\n        },\n        function(arrayOfStuff, typeDescription){\n            if(arrayOfStuff == \"null\"){\n                return null;\n            }\n\n            return JSON.stringify(arrayOfStuff)\n        },\n        'blob'\n    )\n}", "/**\n * Created by ciprian on 3/16/17.\n */\n\n\nvar apersistence = require(\"../lib/abstractPersistence.js\");\nvar mysqlUtils = require(\"../db/sql/mysqlUtils\");\nvar modelUtil  = require(\"../lib/ModelDescription\");\nvar assert = require('double-check').assert;\nvar mysql      = require('mysql');\nvar mysqlPool = mysql.createPool({\n    host     : 'localhost',\n    user     : 'root',\n    password : 'operando',\n    database : 'operando'\n});\n\nvar userModel = {\n    name: {\n        pk:true,\n        type:'string',\n        default:\"Mircea Cartarescu\"\n    },\n    bookName1:{\n        \"type\":\"string\",\n        \"default\":\"War and Peace\"\n    },\n    bookName2:{\n        \"type\":\"string\",\n        \"default\":\"War and Peace\"\n    },\n    book1:{\n        type:\"TestBook\",\n        relation:\"bookName1:name\"\n    },\n    book2:{\n        type:\"TestBook\",\n        relation:\"bookName2:name\"\n    }\n};\nvar bookModel = {\n    name:{\n        pk:true,\n        type:'string'\n    }\n};\n\n\nvar persistence = apersistence.createMySqlPersistence(mysqlPool);\nfunction storeSomeBooks(callback){\n    var book1 = apersistence.createRawObject(\"TestBook\",\"Shogun\");\n    var book2 = apersistence.createRawObject(\"TestBook\",\"War And Peace\");\n    persistence.save(book1,function(err,result){\n        if(err){\n            callback(err);\n        }else {\n            persistence.save(book2, function (err, result) {\n                if (err) {\n                    callback(err)\n                }else {\n                    callback(null, [book1, book2]);\n                }\n            })\n        }\n    })\n}\n\nassert.steps(\"Load lazy objects test\",[\n    function(next){\n        mysqlPool.query(\"DROP TABLE TestUser\", function (err, result) {\n            mysqlPool.query(\"DROP TABLE TestBook\", function (err, result) {\n                next();\n            });\n        });\n    },\n    function(next) {\n        persistence.registerModel(\"TestBook\", bookModel, function (err, result) {\n        });\n        persistence.registerModel(\"TestUser\", userModel, function (err, result) {\n            next();\n        })\n    },\n    function(next){\n        storeSomeBooks(function (err, books) {\n            var user = apersistence.createRawObject(\"TestUser\", \"Johnny Smith\");\n            try {\n                user.book1 = books[0];\n                assert.fail(\"Should throw error. Cannot set transient properties directly.\")\n            } catch (e) {\n                user.bookName1 = \"Shogun\";\n                persistence.save(user, function (err, user) {\n                    next()\n                })\n            }\n        })\n    },\n    function(next) {\n        persistence.findById(\"TestUser\", \"Johnny Smith\", function (err, user) {\n            assert.equal(user.name, \"Johnny Smith\",\"Should retrieve the right user\");\n            user.__meta.loadLazyFields(function (err, user) {\n                assert.equal(user.book1.name, \"Shogun\",\"Should match the expected data\");\n                assert.equal(user.book2.name, \"War And Peace\",\"Should match the expected data\");\n                assert.equal(user.book1.__meta !== undefined, true,\"Should be loaded\");\n                mysqlPool.query(\"DROP TABLE TestUser\", function (err, result) {\n                    mysqlPool.query(\"DROP TABLE TestBook\", function (err, result) {\n                        mysqlPool.end();\n                        next();\n                    });\n                });\n            })\n        })\n    }],1000);\n\n\n\n\n"], "filenames": ["db/sql/MySqlPersistence.js", "db/sql/mysqlUtils.js", "lib/BasicStrategy.js", "lib/ModelDescription.js", "lib/basicSQLTypes.js", "test/fillLazyTest.js"], "buggy_code_start_loc": [24, 5, 17, 135, 48, 112], "buggy_code_end_loc": [102, 69, 18, 253, 109, 113], "fixing_code_start_loc": [24, 5, 17, 134, 48, 112], "fixing_code_end_loc": [100, 62, 18, 252, 101, 113], "type": "CWE-89", "message": "A vulnerability classified as critical has been found in PrivateSky apersistence. This affects an unknown part of the file db/sql/mysqlUtils.js. The manipulation leads to sql injection. The name of the patch is 954425f61634b556fe644837a592a5b8fcfca068. It is recommended to apply a patch to fix this issue. The identifier VDB-218457 was assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2017-20171", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-17T23:15:15.417", "lastModified": "2023-01-24T19:35:13.600", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability classified as critical has been found in PrivateSky apersistence. This affects an unknown part of the file db/sql/mysqlUtils.js. The manipulation leads to sql injection. The name of the patch is 954425f61634b556fe644837a592a5b8fcfca068. It is recommended to apply a patch to fix this issue. The identifier VDB-218457 was assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.1, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apersistence_project:apersistence:*:*:*:*:*:*:*:*", "versionEndExcluding": "2017-04-10", "matchCriteriaId": "5078A4F9-4985-4FB0-A1E2-6B9E496F12A4"}]}]}], "references": [{"url": "https://github.com/PrivateSky/apersistence/commit/954425f61634b556fe644837a592a5b8fcfca068", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.218457", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory", "VDB Entry"]}, {"url": "https://vuldb.com/?id.218457", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/PrivateSky/apersistence/commit/954425f61634b556fe644837a592a5b8fcfca068"}}