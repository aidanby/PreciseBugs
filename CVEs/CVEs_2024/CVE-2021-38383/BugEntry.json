{"buggy_code": ["/*\n * Copyright (C) 2009-2010 Julien BLACHE <jb@jblache.org>\n *\n * Some code included below is in the public domain, check comments\n * in the file.\n *\n * Pieces of code adapted from mt-daapd:\n * Copyright (C) 2003-2007 Ron Pedde (ron@pedde.com)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#ifndef CLOCK_REALTIME\n#include <sys/time.h>\n#endif\n#ifdef HAVE_UUID\n#include <uuid/uuid.h>\n#endif\n#ifdef HAVE_PTHREAD_NP_H\n# include <pthread_np.h>\n#endif\n\n#include <netdb.h>\n#include <arpa/inet.h>\n\n#include <unistr.h>\n#include <uniconv.h>\n\n#include <libavutil/base64.h>\n\n#include \"logger.h\"\n#include \"conffile.h\"\n#include \"misc.h\"\n\n\nstatic char *buildopts[] =\n  {\n#ifdef HAVE_FFMPEG\n    \"ffmpeg\",\n#else\n    \"libav\",\n#endif\n#ifdef SPOTIFY\n    \"Spotify\",\n#else\n    \"Without Spotify\",\n#endif\n#ifdef SPOTIFY_LIBRESPOTC\n    \"librespot-c\",\n#endif\n#ifdef SPOTIFY_LIBSPOTIFY\n    \"libspotify\",\n#endif\n#ifdef LASTFM\n    \"LastFM\",\n#else\n    \"Without LastFM\",\n#endif\n#ifdef CHROMECAST\n    \"Chromecast\",\n#else\n    \"Without Chromecast\",\n#endif\n#ifdef MPD\n    \"MPD\",\n#else\n    \"Without MPD\",\n#endif\n#ifdef HAVE_LIBWEBSOCKETS\n    \"Websockets\",\n#else\n    \"Without websockets\",\n#endif\n#ifdef HAVE_ALSA\n    \"ALSA\",\n#else\n    \"Without ALSA\",\n#endif\n#ifdef HAVE_LIBPULSE\n    \"Pulseaudio\",\n#endif\n#ifdef WEBINTERFACE\n    \"Webinterface\",\n#else\n    \"Without webinterface\",\n#endif\n#ifdef HAVE_REGEX_H\n    \"Regex\",\n#else\n    \"Without regex\",\n#endif\n    NULL\n  };\n\n\n/* ------------------------ Network utility functions ----------------------- */\n\nbool\nnet_peer_address_is_trusted(const char *addr)\n{\n  cfg_t *section;\n  const char *network;\n  int i;\n  int n;\n\n  if (!addr)\n    return false;\n\n  if (strncmp(addr, \"::ffff:\", strlen(\"::ffff:\")) == 0)\n    addr += strlen(\"::ffff:\");\n\n  section = cfg_getsec(cfg, \"general\");\n\n  n = cfg_size(section, \"trusted_networks\");\n  for (i = 0; i < n; i++)\n    {\n      network = cfg_getnstr(section, \"trusted_networks\", i);\n\n      if (!network || network[0] == '\\0')\n\treturn false;\n\n      if (strncmp(network, addr, strlen(network)) == 0)\n\treturn true;\n\n      if ((strcmp(network, \"localhost\") == 0) && (strcmp(addr, \"127.0.0.1\") == 0 || strcmp(addr, \"::1\") == 0))\n\treturn true;\n\n      if (strcmp(network, \"any\") == 0)\n\treturn true;\n    }\n\n  return false;\n}\n\nint\nnet_address_get(char *addr, size_t addr_len, union net_sockaddr *naddr)\n{\n  const char *s;\n\n  memset(addr, 0, addr_len); // Just in case caller doesn't check for errors\n\n  if (naddr->sa.sa_family == AF_INET6)\n     s = inet_ntop(AF_INET6, &naddr->sin6.sin6_addr, addr, addr_len);\n  else\n     s = inet_ntop(AF_INET, &naddr->sin.sin_addr, addr, addr_len);\n\n  if (!s)\n    return -1;\n\n  return 0;\n}\n\nint\nnet_port_get(short unsigned *port, union net_sockaddr *naddr)\n{\n  if (naddr->sa.sa_family == AF_INET6)\n     *port = ntohs(naddr->sin6.sin6_port);\n  else\n     *port = ntohs(naddr->sin.sin_port);\n\n  return 0;\n}\n\nint\nnet_connect(const char *addr, unsigned short port, int type, const char *log_service_name)\n{\n  struct addrinfo hints = { 0 };\n  struct addrinfo *servinfo;\n  struct addrinfo *ptr;\n  char strport[8];\n  int fd;\n  int ret;\n\n  DPRINTF(E_DBG, L_MISC, \"Connecting to '%s' at %s (port %u)\\n\", log_service_name, addr, port);\n\n  hints.ai_socktype = (type & (SOCK_STREAM | SOCK_DGRAM)); // filter since type can be SOCK_STREAM | SOCK_NONBLOCK\n  hints.ai_family = (cfg_getbool(cfg_getsec(cfg, \"general\"), \"ipv6\")) ? AF_UNSPEC : AF_INET;\n\n  snprintf(strport, sizeof(strport), \"%hu\", port);\n  ret = getaddrinfo(addr, strport, &hints, &servinfo);\n  if (ret < 0)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not connect to '%s' at %s (port %u): %s\\n\", log_service_name, addr, port, gai_strerror(ret));\n      return -1;\n    }\n\n  for (ptr = servinfo; ptr; ptr = ptr->ai_next)\n    {\n      fd = socket(ptr->ai_family, type | SOCK_CLOEXEC, ptr->ai_protocol);\n      if (fd < 0)\n\t{\n\t  continue;\n\t}\n\n      ret = connect(fd, ptr->ai_addr, ptr->ai_addrlen);\n      if (ret < 0 && errno != EINPROGRESS) // EINPROGRESS in case of SOCK_NONBLOCK\n\t{\n\t  close(fd);\n\t  continue;\n\t}\n\n      break;\n    }\n\n  freeaddrinfo(servinfo);\n\n  if (!ptr)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not connect to '%s' at %s (port %u): %s\\n\", log_service_name, addr, port, strerror(errno));\n      return -1;\n    }\n\n  // net_address_get(ipaddr, sizeof(ipaddr), (union net_sockaddr *)ptr->ai-addr);\n\n  return fd;\n}\n\n// If *port is 0 then a random port will be assigned, and *port will be updated\n// with the port number\nint\nnet_bind(short unsigned *port, int type, const char *log_service_name)\n{\n  struct addrinfo hints = { 0 };\n  struct addrinfo *servinfo;\n  struct addrinfo *ptr;\n  const char *cfgaddr;\n  char addr[INET6_ADDRSTRLEN];\n  char strport[8];\n  int yes = 1;\n  int no = 0;\n  int fd;\n  int ret;\n\n  cfgaddr = cfg_getstr(cfg_getsec(cfg, \"general\"), \"bind_address\");\n\n  hints.ai_socktype = (type & (SOCK_STREAM | SOCK_DGRAM)); // filter since type can be SOCK_STREAM | SOCK_NONBLOCK\n  hints.ai_family = (cfg_getbool(cfg_getsec(cfg, \"general\"), \"ipv6\")) ? AF_INET6 : AF_INET;\n  hints.ai_flags = cfgaddr ? 0 : AI_PASSIVE;\n\n  snprintf(strport, sizeof(strport), \"%hu\", *port);\n  ret = getaddrinfo(cfgaddr, strport, &hints, &servinfo);\n  if (ret < 0)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Failure creating '%s' service, could not resolve '%s' (port %s): %s\\n\", log_service_name, cfgaddr ? cfgaddr : \"(ANY)\", strport, gai_strerror(ret));\n      return -1;\n    }\n\n  for (ptr = servinfo, fd = -1; ptr != NULL; ptr = ptr->ai_next)\n    {\n      if (fd >= 0)\n\tclose(fd);\n\n      fd = socket(ptr->ai_family, type | SOCK_CLOEXEC, ptr->ai_protocol);\n      if (fd < 0)\n\tcontinue;\n\n      // TODO libevent sets this, we do the same?\n      ret = setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &yes, sizeof(yes));\n      if (ret < 0)\n\tcontinue;\n\n      ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));\n      if (ret < 0)\n\tcontinue;\n\n      if (ptr->ai_family == AF_INET6)\n\t{\n\t  // We want to be sure the service is dual stack\n\t  ret = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &no, sizeof(no));\n\t  if (ret < 0)\n\t    continue;\n\t}\n\n      ret = bind(fd, ptr->ai_addr, ptr->ai_addrlen);\n      if (ret < 0)\n\tcontinue;\n\n      break;\n    }\n\n  freeaddrinfo(servinfo);\n\n  if (!ptr)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not create service '%s' with address %s, port %hu: %s\\n\", log_service_name, cfgaddr ? cfgaddr : \"(ANY)\", *port, strerror(errno));\n      goto error;\n    }\n\n  // Get the port that was assigned\n  ret = getsockname(fd, ptr->ai_addr, &ptr->ai_addrlen);\n  if (ret < 0)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not find address of service '%s': %s\\n\", log_service_name, strerror(errno));\n      goto error;\n    }\n\n  net_port_get(port, (union net_sockaddr *)ptr->ai_addr);\n  net_address_get(addr, sizeof(addr), (union net_sockaddr *)ptr->ai_addr);\n\n  DPRINTF(E_DBG, L_MISC, \"Service '%s' bound to %s, port %hu, socket %d\\n\", log_service_name, addr, *port, fd);\n\n  return fd;\n\n error:\n  close(fd);\n  return -1;\n}\n\nint\nnet_evhttp_bind(struct evhttp *evhttp, short unsigned port, const char *log_service_name)\n{\n  const char *bind_address;\n  bool v6_enabled;\n  int ret;\n\n  bind_address = cfg_getstr(cfg_getsec(cfg, \"general\"), \"bind_address\");\n  if (bind_address)\n    evhttp_bind_socket(evhttp, bind_address, port);\n\n  // For Linux, we could just do evhttp_bind_socket() for \"::\", and both the\n  // ipv4 and v6 port would be bound. However, for bsd it seems it is necessary\n  // to do like below.\n  v6_enabled = cfg_getbool(cfg_getsec(cfg, \"general\"), \"ipv6\");\n  if (v6_enabled)\n    {\n      ret = evhttp_bind_socket(evhttp, \"::\", port);\n      if (ret < 0)\n\t{\n\t  DPRINTF(E_LOG, L_MISC, \"Could not bind service '%s' to port %d with IPv6, falling back to IPv4\\n\", log_service_name, port);\n\t  v6_enabled = 0;\n\t}\n    }\n\n  ret = evhttp_bind_socket(evhttp, \"0.0.0.0\", port);\n  if (ret < 0)\n    {\n      if (!v6_enabled)\n\treturn -1;\n\n#ifndef __linux__\n      DPRINTF(E_LOG, L_MISC, \"Could not bind service '%s' to port %d with IPv4, listening on IPv6 only\\n\", log_service_name, port);\n#endif\n    }\n\n  return 0;\n}\n\nbool\nnet_is_http_or_https(const char *url)\n{\n  return (strncasecmp(url, \"http://\", strlen(\"http://\")) == 0 || strncasecmp(url, \"https://\", strlen(\"https://\")) == 0);\n}\n\n/* ----------------------- Conversion/hashing/sanitizers -------------------- */\n\nint\nsafe_atoi32(const char *str, int32_t *val)\n{\n  char *end;\n  long intval;\n\n  *val = 0;\n\n  errno = 0;\n  intval = strtol(str, &end, 10);\n\n  if (((errno == ERANGE) && ((intval == LONG_MAX) || (intval == LONG_MIN)))\n      || ((errno != 0) && (intval == 0)))\n    {\n      DPRINTF(E_DBG, L_MISC, \"Invalid integer in string (%s): %s\\n\", str, strerror(errno));\n\n      return -1;\n    }\n\n  if (end == str)\n    {\n      DPRINTF(E_DBG, L_MISC, \"No integer found in string (%s)\\n\", str);\n\n      return -1;\n    }\n\n  if (intval > INT32_MAX)\n    {\n      DPRINTF(E_DBG, L_MISC, \"Integer value too large (%s)\\n\", str);\n\n      return -1;\n    }\n\n  *val = (int32_t)intval;\n\n  return 0;\n}\n\nint\nsafe_atou32(const char *str, uint32_t *val)\n{\n  char *end;\n  unsigned long intval;\n\n  *val = 0;\n\n  errno = 0;\n  intval = strtoul(str, &end, 10);\n\n  if (((errno == ERANGE) && (intval == ULONG_MAX))\n      || ((errno != 0) && (intval == 0)))\n    {\n      DPRINTF(E_DBG, L_MISC, \"Invalid integer in string (%s): %s\\n\", str, strerror(errno));\n\n      return -1;\n    }\n\n  if (end == str)\n    {\n      DPRINTF(E_DBG, L_MISC, \"No integer found in string (%s)\\n\", str);\n\n      return -1;\n    }\n\n  if (intval > UINT32_MAX)\n    {\n      DPRINTF(E_DBG, L_MISC, \"Integer value too large (%s)\\n\", str);\n\n      return -1;\n    }\n\n  *val = (uint32_t)intval;\n\n  return 0;\n}\n\nint\nsafe_hextou32(const char *str, uint32_t *val)\n{\n  char *end;\n  unsigned long intval;\n\n  *val = 0;\n\n  errno = 0;\n  intval = strtoul(str, &end, 16);\n\n  if (((errno == ERANGE) && (intval == ULONG_MAX))\n      || ((errno != 0) && (intval == 0)))\n    {\n      DPRINTF(E_DBG, L_MISC, \"Invalid integer in string (%s): %s\\n\", str, strerror(errno));\n\n      return -1;\n    }\n\n  if (end == str)\n    {\n      DPRINTF(E_DBG, L_MISC, \"No integer found in string (%s)\\n\", str);\n\n      return -1;\n    }\n\n  if (intval > UINT32_MAX)\n    {\n      DPRINTF(E_DBG, L_MISC, \"Integer value too large (%s)\\n\", str);\n\n      return -1;\n    }\n\n  *val = (uint32_t)intval;\n\n  return 0;\n}\n\nint\nsafe_atoi64(const char *str, int64_t *val)\n{\n  char *end;\n  long long intval;\n\n  *val = 0;\n\n  errno = 0;\n  intval = strtoll(str, &end, 10);\n\n  if (((errno == ERANGE) && ((intval == LLONG_MAX) || (intval == LLONG_MIN)))\n      || ((errno != 0) && (intval == 0)))\n    {\n      DPRINTF(E_DBG, L_MISC, \"Invalid integer in string (%s): %s\\n\", str, strerror(errno));\n\n      return -1;\n    }\n\n  if (end == str)\n    {\n      DPRINTF(E_DBG, L_MISC, \"No integer found in string (%s)\\n\", str);\n\n      return -1;\n    }\n\n  if (intval > INT64_MAX)\n    {\n      DPRINTF(E_DBG, L_MISC, \"Integer value too large (%s)\\n\", str);\n\n      return -1;\n    }\n\n  *val = (int64_t)intval;\n\n  return 0;\n}\n\nint\nsafe_atou64(const char *str, uint64_t *val)\n{\n  char *end;\n  unsigned long long intval;\n\n  *val = 0;\n\n  errno = 0;\n  intval = strtoull(str, &end, 10);\n\n  if (((errno == ERANGE) && (intval == ULLONG_MAX))\n      || ((errno != 0) && (intval == 0)))\n    {\n      DPRINTF(E_DBG, L_MISC, \"Invalid integer in string (%s): %s\\n\", str, strerror(errno));\n\n      return -1;\n    }\n\n  if (end == str)\n    {\n      DPRINTF(E_DBG, L_MISC, \"No integer found in string (%s)\\n\", str);\n\n      return -1;\n    }\n\n  if (intval > UINT64_MAX)\n    {\n      DPRINTF(E_DBG, L_MISC, \"Integer value too large (%s)\\n\", str);\n\n      return -1;\n    }\n\n  *val = (uint64_t)intval;\n\n  return 0;\n}\n\nint\nsafe_hextou64(const char *str, uint64_t *val)\n{\n  char *end;\n  unsigned long long intval;\n\n  *val = 0;\n\n  errno = 0;\n  intval = strtoull(str, &end, 16);\n\n  if (((errno == ERANGE) && (intval == ULLONG_MAX))\n      || ((errno != 0) && (intval == 0)))\n    {\n      DPRINTF(E_DBG, L_MISC, \"Invalid integer in string (%s): %s\\n\", str, strerror(errno));\n\n      return -1;\n    }\n\n  if (end == str)\n    {\n      DPRINTF(E_DBG, L_MISC, \"No integer found in string (%s)\\n\", str);\n\n      return -1;\n    }\n\n  if (intval > UINT64_MAX)\n    {\n      DPRINTF(E_DBG, L_MISC, \"Integer value too large (%s)\\n\", str);\n\n      return -1;\n    }\n\n  *val = (uint64_t)intval;\n\n  return 0;\n}\n\nchar *\nsafe_strdup(const char *str)\n{\n  if (str == NULL)\n    return NULL;\n\n  return strdup(str);\n}\n\n/*\n * Wrapper function for vasprintf by Intel Corporation\n * Published under the L-GPL 2.1 licence as part of clr-boot-manager\n *\n * https://github.com/clearlinux/clr-boot-manager\n */\nchar *\nsafe_asprintf(const char *fmt, ...)\n{\n  char *ret = NULL;\n  va_list va;\n\n  va_start(va, fmt);\n  if (vasprintf(&ret, fmt, va) < 0)\n    {\n      DPRINTF(E_FATAL, L_MISC, \"Out of memory for safe_asprintf\\n\");\n      abort();\n    }\n  va_end(va);\n\n  return ret;\n}\n\nint\nsafe_snprintf_cat(char *dst, size_t n, const char *fmt, ...)\n{\n  size_t dstlen;\n  va_list va;\n  int ret;\n\n  if (!dst || !fmt)\n    return -1;\n\n  dstlen = strlen(dst);\n  if (n < dstlen)\n    return -1;\n\n  va_start(va, fmt);\n  ret = vsnprintf(dst + dstlen, n - dstlen, fmt, va);\n  va_end(va);\n\n  if (ret >= 0 && ret < n - dstlen)\n    return 0;\n  else\n    return -1;\n}\n\nint\nsafe_snreplace(char *s, size_t sz, const char *pattern, const char *replacement)\n{\n  char *ptr;\n  char *src;\n  char *dst;\n  size_t num;\n\n  if (!s)\n    return -1;\n\n  if (!pattern || !replacement)\n    return 0;\n\n  size_t p_len = strlen(pattern);\n  size_t r_len = strlen(replacement);\n  size_t s_len = strlen(s) + 1; // Incl terminator\n\n  ptr = s;\n  while ((ptr = strstr(ptr, pattern)))\n    {\n      // We will move the part of the string after the pattern from src to dst\n      src = ptr + p_len;\n      dst = ptr + r_len;\n\n      num = s_len - (src - s); // Number of bytes w/terminator we need to move\n      if (dst + num > s + sz)\n\treturn -1; // Not enough room\n\n      // Shift everything after the pattern to the right, use memmove since\n      // there might be an overlap\n      memmove(dst, src, num);\n\n      // Write replacement, no null terminater\n      memcpy(ptr, replacement, r_len);\n\n      // Advance ptr to avoid infinite looping\n      ptr = dst;\n    }\n\n  return 0;\n}\n\n\nchar *\nunicode_fixup_string(char *str, const char *fromcode)\n{\n  uint8_t *ret;\n  size_t len;\n\n  if (!str)\n    return NULL;\n\n  len = strlen(str);\n\n  /* String is valid UTF-8 */\n  if (!u8_check((uint8_t *)str, len))\n    {\n      if (len >= 3)\n\t{\n\t  /* Check for and strip byte-order mark */\n\t  if (memcmp(\"\\xef\\xbb\\xbf\", str, 3) == 0)\n\t    memmove(str, str + 3, len - 3 + 1);\n\t}\n\n      return str;\n    }\n\n  ret = u8_strconv_from_encoding(str, fromcode, iconveh_question_mark);\n  if (!ret)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not convert string '%s' to UTF-8: %s\\n\", str, strerror(errno));\n\n      return NULL;\n    }\n\n  return (char *)ret;\n}\n\nchar *\ntrim(char *str)\n{\n  size_t start; // Position of first non-space char\n  size_t term;  // Position of 0-terminator\n\n  if (!str)\n    return NULL;\n\n  start = 0;\n  term  = strlen(str);\n\n  while ((start < term) && isspace(str[start]))\n    start++;\n  while ((term > start) && isspace(str[term - 1]))\n    term--;\n\n  str[term] = '\\0';\n\n  // Shift chars incl. terminator\n  if (start)\n    memmove(str, str + start, term - start + 1);\n\n  return str;\n}\n\nchar *\natrim(const char *str)\n{\n  size_t start; // Position of first non-space char\n  size_t term;  // Position of 0-terminator\n  size_t size;\n  char *result;\n\n  if (!str)\n    return NULL;\n\n  start = 0;\n  term  = strlen(str);\n\n  while ((start < term) && isspace(str[start]))\n    start++;\n  while ((term > start) && isspace(str[term - 1]))\n    term--;\n\n  size = term - start + 1;\n\n  result = malloc(size);\n\n  memcpy(result, str + start, size);\n  result[size - 1] = '\\0';\n\n  return result;\n}\n\nvoid\nswap_pointers(char **a, char **b)\n{\n  char *t = *a;\n  *a = *b;\n  *b = t;\n}\n\nuint32_t\ndjb_hash(const void *data, size_t len)\n{\n  const unsigned char *bytes = data;\n  uint32_t hash = 5381;\n\n  while (len--)\n    {\n      hash = ((hash << 5) + hash) + *bytes;\n      bytes++;\n    }\n\n  return hash;\n}\n\nint64_t\ntwo_str_hash(const char *a, const char *b)\n{\n  char hashbuf[2048];\n  int64_t hash;\n  int i;\n  int ret;\n\n  ret = snprintf(hashbuf, sizeof(hashbuf), \"%s==%s\", (a) ? a : \"\", (b) ? b : \"\");\n  if (ret < 0 || ret == sizeof(hashbuf))\n    {\n      DPRINTF(E_LOG, L_MISC, \"Buffer too large to calculate hash: '%s==%s'\\n\", a, b);\n      return 999999; // Stand-in hash...\n    }\n\n  for (i = 0; hashbuf[i]; i++)\n    hashbuf[i] = tolower(hashbuf[i]);\n\n  // Limit hash length to 63 bits, due to signed type in sqlite\n  hash = murmur_hash64(hashbuf, strlen(hashbuf), 0) >> 1;\n\n  return hash;\n}\n\nuint8_t *\nb64_decode(int *dstlen, const char *src)\n{\n  uint8_t *out;\n  int len;\n  int ret;\n\n  len = AV_BASE64_DECODE_SIZE(strlen(src));\n\n  // Add a extra zero byte just in case we are decoding a string without null\n  // termination\n  CHECK_NULL(L_MISC, out = calloc(1, len + 1));\n\n  ret = av_base64_decode(out, src, len);\n  if (ret < 0)\n    {\n      free(out);\n      return NULL;\n    }\n\n  if (dstlen)\n    *dstlen = ret;\n\n  return out;\n}\n\nchar *\nb64_encode(const uint8_t *src, int srclen)\n{\n  char *out;\n  int len;\n  char *ret;\n\n  len = AV_BASE64_SIZE(srclen);\n\n  CHECK_NULL(L_MISC, out = calloc(1, len));\n\n  ret = av_base64_encode(out, len, src, srclen);\n  if (!ret)\n    {\n      free(out);\n      return NULL;\n    }\n\n  return out;\n}\n\n\n/*\n * MurmurHash2, 64-bit versions, by Austin Appleby\n *\n * Code released under the public domain, as per\n *    <http://murmurhash.googlepages.com/>\n * as of 2010-01-03.\n */\n\n#if SIZEOF_VOID_P == 8 /* 64bit platforms */\n\nuint64_t\nmurmur_hash64(const void *key, int len, uint32_t seed)\n{\n  const int r = 47;\n  const uint64_t m = 0xc6a4a7935bd1e995;\n\n  const uint64_t *data;\n  const uint64_t *end;\n  const unsigned char *data_tail;\n  uint64_t h;\n  uint64_t k;\n\n  h = seed ^ (len * m);\n  data = (const uint64_t *)key;\n  end = data + (len / 8);\n\n  while (data != end)\n    {\n      k = *data++;\n\n      k *= m;\n      k ^= k >> r;\n      k *= m;\n\n      h ^= k;\n      h *= m;\n    }\n\n  data_tail = (const unsigned char *)data;\n\n  switch (len & 7)\n    {\n      case 7:\n\th ^= (uint64_t)(data_tail[6]) << 48; /* FALLTHROUGH */\n      case 6:\n\th ^= (uint64_t)(data_tail[5]) << 40; /* FALLTHROUGH */\n      case 5:\n\th ^= (uint64_t)(data_tail[4]) << 32; /* FALLTHROUGH */\n      case 4:\n\th ^= (uint64_t)(data_tail[3]) << 24; /* FALLTHROUGH */\n      case 3:\n\th ^= (uint64_t)(data_tail[2]) << 16; /* FALLTHROUGH */\n      case 2:\n\th ^= (uint64_t)(data_tail[1]) << 8; /* FALLTHROUGH */\n      case 1:\n\th ^= (uint64_t)(data_tail[0]);\n\th *= m;\n    }\n\n  h ^= h >> r;\n  h *= m;\n  h ^= h >> r;\n\n  return h;\n}\n\n#elif SIZEOF_VOID_P == 4 /* 32bit platforms */\n\nuint64_t\nmurmur_hash64(const void *key, int len, uint32_t seed)\n{\n  const int r = 24;\n  const uint32_t m = 0x5bd1e995;\n\n  const uint32_t *data;\n  const unsigned char *data_tail;\n  uint32_t k1;\n  uint32_t h1;\n  uint32_t k2;\n  uint32_t h2;\n\n  uint64_t h;\n\n  h1 = seed ^ len;\n  h2 = 0;\n\n  data = (const uint32_t *)key;\n\n  while (len >= 8)\n    {\n      k1 = *data++;\n      k1 *= m; k1 ^= k1 >> r; k1 *= m;\n      h1 *= m; h1 ^= k1;\n\n      k2 = *data++;\n      k2 *= m; k2 ^= k2 >> r; k2 *= m;\n      h2 *= m; h2 ^= k2;\n\n      len -= 8;\n    }\n\n  if (len >= 4)\n    {\n      k1 = *data++;\n      k1 *= m; k1 ^= k1 >> r; k1 *= m;\n      h1 *= m; h1 ^= k1;\n      len -= 4;\n    }\n\n  data_tail = (const unsigned char *)data;\n\n  switch(len)\n    {\n      case 3:\n\th2 ^= (uint32_t)(data_tail[2]) << 16;\n      case 2:\n\th2 ^= (uint32_t)(data_tail[1]) << 8;\n      case 1:\n\th2 ^= (uint32_t)(data_tail[0]);\n\th2 *= m;\n    };\n\n  h1 ^= h2 >> 18; h1 *= m;\n  h2 ^= h1 >> 22; h2 *= m;\n  h1 ^= h2 >> 17; h1 *= m;\n  h2 ^= h1 >> 19; h2 *= m;\n\n  h = h1;\n  h = (h << 32) | h2;\n\n  return h;\n}\n#else\n# error Platform not supported\n#endif\n\n\n/* --------------------------- Key/value functions -------------------------- */\n\nstruct keyval *\nkeyval_alloc(void)\n{\n  struct keyval *kv;\n\n  kv = calloc(1, sizeof(struct keyval));\n  if (!kv)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Out of memory for keyval alloc\\n\");\n\n      return NULL;\n    }\n\n  return kv;\n}\n\nint\nkeyval_add_size(struct keyval *kv, const char *name, const char *value, size_t size)\n{\n  struct onekeyval *okv;\n  const char *val;\n\n  if (!kv)\n    return -1;\n\n  /* Check for duplicate key names */\n  val = keyval_get(kv, name);\n  if (val)\n    {\n      /* Same value, fine */\n      if (strcmp(val, value) == 0)\n        return 0;\n      else /* Different value, bad */\n        return -1;\n    }\n\n  okv = (struct onekeyval *)malloc(sizeof(struct onekeyval));\n  if (!okv)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Out of memory for new keyval\\n\");\n\n      return -1;\n    }\n\n  okv->name = strdup(name);\n  if (!okv->name)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Out of memory for new keyval name\\n\");\n\n      free(okv);\n      return -1;\n    }\n\n  okv->value = (char *)malloc(size + 1);\n  if (!okv->value)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Out of memory for new keyval value\\n\");\n\n      free(okv->name);\n      free(okv);\n      return -1;\n    }\n\n  memcpy(okv->value, value, size);\n  okv->value[size] = '\\0';\n\n  okv->next = NULL;\n\n  if (!kv->head)\n    kv->head = okv;\n\n  if (kv->tail)\n    kv->tail->next = okv;\n\n  kv->tail = okv;\n\n  return 0;\n}\n\nint\nkeyval_add(struct keyval *kv, const char *name, const char *value)\n{\n  return keyval_add_size(kv, name, value, strlen(value));\n}\n\nvoid\nkeyval_remove(struct keyval *kv, const char *name)\n{\n  struct onekeyval *okv;\n  struct onekeyval *pokv;\n\n  if (!kv)\n    return;\n\n  for (pokv = NULL, okv = kv->head; okv; pokv = okv, okv = okv->next)\n    {\n      if (strcasecmp(okv->name, name) == 0)\n        break;\n    }\n\n  if (!okv)\n    return;\n\n  if (okv == kv->head)\n    kv->head = okv->next;\n\n  if (okv == kv->tail)\n    kv->tail = pokv;\n\n  if (pokv)\n    pokv->next = okv->next;\n\n  free(okv->name);\n  free(okv->value);\n  free(okv);\n}\n\nconst char *\nkeyval_get(struct keyval *kv, const char *name)\n{\n  struct onekeyval *okv;\n\n  if (!kv)\n    return NULL;\n\n  for (okv = kv->head; okv; okv = okv->next)\n    {\n      if (strcasecmp(okv->name, name) == 0)\n        return okv->value;\n    }\n\n  return NULL;\n}\n\nvoid\nkeyval_clear(struct keyval *kv)\n{\n  struct onekeyval *hokv;\n  struct onekeyval *okv;\n\n  if (!kv)\n    return;\n\n  hokv = kv->head;\n\n  for (okv = hokv; hokv; okv = hokv)\n    {\n      hokv = okv->next;\n\n      free(okv->name);\n      free(okv->value);\n      free(okv);\n    }\n\n  kv->head = NULL;\n  kv->tail = NULL;\n}\n\nvoid\nkeyval_sort(struct keyval *kv)\n{\n  struct onekeyval *head;\n  struct onekeyval *okv;\n  struct onekeyval *sokv;\n\n  if (!kv || !kv->head)\n    return;\n\n  head = kv->head;\n  for (okv = kv->head; okv; okv = okv->next)\n    {\n      okv->sort = NULL;\n      for (sokv = kv->head; sokv; sokv = sokv->next)\n\t{\n\t  // We try to find a name which is greater than okv->name\n\t  // but less than our current candidate (okv->sort->name)\n\t  if ( (strcmp(sokv->name, okv->name) > 0) &&\n\t       ((okv->sort == NULL) || (strcmp(sokv->name, okv->sort->name) < 0)) )\n\t    okv->sort = sokv;\n\t}\n\n      // Find smallest name, which will be the new head\n      if (strcmp(okv->name, head->name) < 0)\n\thead = okv;\n    }\n\n  while ((okv = kv->head))\n    {\n      kv->head  = okv->next;\n      okv->next = okv->sort;\n    }\n\n  kv->head = head;\n  for (okv = kv->head; okv; okv = okv->next)\n    kv->tail = okv;\n\n  DPRINTF(E_DBG, L_MISC, \"Keyval sorted. New head: %s. New tail: %s.\\n\", kv->head->name, kv->tail->name);\n}\n\n\n/* ------------------------------- Ringbuffer ------------------------------- */\n\nint\nringbuffer_init(struct ringbuffer *buf, size_t size)\n{\n  memset(buf, 0, sizeof(struct ringbuffer));\n\n  CHECK_NULL(L_MISC, buf->buffer = malloc(size));\n  buf->size = size;\n  buf->write_avail = size;\n  return 0;\n}\n\nvoid\nringbuffer_free(struct ringbuffer *buf, bool content_only)\n{\n  if (!buf)\n    return;\n\n  free(buf->buffer);\n\n  if (content_only)\n    memset(buf, 0, sizeof(struct ringbuffer));\n  else\n    free(buf);\n}\n\nsize_t\nringbuffer_write(struct ringbuffer *buf, const void* src, size_t srclen)\n{\n  int remaining;\n\n  if (buf->write_avail == 0 || srclen == 0)\n    return 0;\n\n  if (srclen > buf->write_avail)\n   srclen = buf->write_avail;\n\n  remaining = buf->size - buf->write_pos;\n  if (srclen > remaining)\n    {\n      memcpy(buf->buffer + buf->write_pos, src, remaining);\n      memcpy(buf->buffer, src + remaining, srclen - remaining);\n    }\n  else\n    {\n      memcpy(buf->buffer + buf->write_pos, src, srclen);\n    }\n\n  buf->write_pos = (buf->write_pos + srclen) % buf->size;\n\n  buf->write_avail -= srclen;\n  buf->read_avail += srclen;\n\n  return srclen;\n}\n\nsize_t\nringbuffer_read(uint8_t **dst, size_t dstlen, struct ringbuffer *buf)\n{\n  int remaining;\n\n  *dst = buf->buffer + buf->read_pos;\n\n  if (buf->read_avail == 0 || dstlen == 0)\n    return 0;\n\n  remaining = buf->size - buf->read_pos;\n\n  // The number of bytes we will return will be MIN(dstlen, remaining, read_avail)\n  if (dstlen > remaining)\n    dstlen = remaining;\n  if (dstlen > buf->read_avail)\n    dstlen = buf->read_avail;\n\n  buf->read_pos = (buf->read_pos + dstlen) % buf->size;\n\n  buf->write_avail += dstlen;\n  buf->read_avail -= dstlen;\n\n  return dstlen;\n}\n\n\n/* ------------------------- Clock utility functions ------------------------ */\n\nint\nclock_gettime_with_res(clockid_t clock_id, struct timespec *tp, struct timespec *res)\n{\n  int ret;\n\n  if ((!tp) || (!res))\n    return -1;\n\n  ret = clock_gettime(clock_id, tp);\n  /* this will only work for sub-second resolutions. */\n  if (ret == 0 && res->tv_nsec > 1)\n    tp->tv_nsec = (tp->tv_nsec/res->tv_nsec)*res->tv_nsec;\n\n  return ret;\n}\n\nstruct timespec\ntimespec_add(struct timespec time1, struct timespec time2)\n{\n  struct timespec result;\n\n  result.tv_sec = time1.tv_sec + time2.tv_sec;\n  result.tv_nsec = time1.tv_nsec + time2.tv_nsec;\n  if (result.tv_nsec >= 1000000000L)\n    {\n      result.tv_sec++;\n      result.tv_nsec -= 1000000000L;\n    }\n  return result;\n}\n\nint\ntimespec_cmp(struct timespec time1, struct timespec time2)\n{\n  /* Less than. */\n  if (time1.tv_sec < time2.tv_sec)\n    return -1;\n  /* Greater than. */\n  else if (time1.tv_sec > time2.tv_sec)\n    return 1;\n  /* Less than. */\n  else if (time1.tv_nsec < time2.tv_nsec)\n    return -1;\n  /* Greater than. */\n  else if (time1.tv_nsec > time2.tv_nsec)\n    return 1;\n  /* Equal. */\n  else\n    return 0;\n}\n\nstruct timespec\ntimespec_reltoabs(struct timespec relative)\n{\n  struct timespec absolute;\n\n#ifdef CLOCK_REALTIME\n  clock_gettime(CLOCK_REALTIME, &absolute);\n#else\n  struct timeval tv;\n  gettimeofday(&tv, NULL);\n  TIMEVAL_TO_TIMESPEC(&tv, &absolute);\n#endif\n  return timespec_add(absolute, relative);\n}\n\n#if defined(HAVE_MACH_CLOCK) || defined(HAVE_MACH_TIMER)\n\n#include <mach/mach_time.h> /* mach_absolute_time */\n#include <mach/mach.h>      /* host_get_clock_service */\n#include <mach/clock.h>     /* clock_get_time */\n\n/* mach monotonic clock port */\nextern mach_port_t clock_port;\n\n#ifndef HAVE_CLOCK_GETTIME\n\nint\nclock_gettime(clockid_t clock_id, struct timespec *tp)\n{\n  static int clock_init = 0;\n  static clock_serv_t clock;\n\n  mach_timespec_t mts;\n  int ret;\n\n  if (! clock_init) {\n    clock_init = 1;\n    if (host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &clock))\n      abort(); /* unlikely */\n  }\n\n  if(! tp)\n    return -1;\n\n  switch (clock_id) {\n\n  case CLOCK_REALTIME:\n\n    /* query mach for calendar time */\n    ret = clock_get_time(clock, &mts);\n    if (! ret) {\n      tp->tv_sec = mts.tv_sec;\n      tp->tv_nsec = mts.tv_nsec;\n    }\n    break;\n\n  case CLOCK_MONOTONIC:\n\n    /* query mach for monotinic time */\n    ret = clock_get_time(clock_port, &mts);\n    if (! ret) {\n      tp->tv_sec = mts.tv_sec;\n      tp->tv_nsec = mts.tv_nsec;\n    }\n    break;\n\n  default:\n    ret = -1;\n    break;\n  }\n\n  return ret;\n}\n\nint\nclock_getres(clockid_t clock_id, struct timespec *res)\n{\n  if (! res)\n    return -1;\n\n  /* hardcode ms resolution */\n  res->tv_sec = 0;\n  res->tv_nsec = 1000;\n\n  return 0;\n}\n\n#endif /* HAVE_CLOCK_GETTIME */\n\n#ifndef HAVE_TIMER_SETTIME\n\n#include <sys/time.h> /* ITIMER_REAL */\n\nint\ntimer_create(clockid_t clock_id, void *sevp, timer_t *timer_id)\n{\n  if (clock_id != CLOCK_MONOTONIC)\n    return -1;\n  if (sevp)\n    return -1;\n\n  /* setitimer only supports one timer */\n  *timer_id = 0;\n\n  return 0;\n}\n\nint\ntimer_delete(timer_t timer_id)\n{\n  struct itimerval timerval;\n\n  if (timer_id != 0)\n    return -1;\n\n  memset(&timerval, 0, sizeof(struct itimerval));\n\n  return setitimer(ITIMER_REAL, &timerval, NULL);\n}\n\nint\ntimer_settime(timer_t timer_id, int flags, const struct itimerspec *tp, struct itimerspec *old)\n{\n  struct itimerval tv;\n\n  if (timer_id != 0 || ! tp || old)\n    return -1;\n\n  TIMESPEC_TO_TIMEVAL(&(tv.it_value), &(tp->it_value));\n  TIMESPEC_TO_TIMEVAL(&(tv.it_interval), &(tp->it_interval));\n\n  return setitimer(ITIMER_REAL, &tv, NULL);\n}\n\nint\ntimer_getoverrun(timer_t timer_id)\n{\n  /* since we don't know if there have been signals that weren't delivered,\n     assume none */\n  return 0;\n}\n\n#endif /* HAVE_TIMER_SETTIME */\n\n#endif /* HAVE_MACH_CLOCK */\n\n\n/* ------------------------------- Media quality ---------------------------- */\n\nbool\nquality_is_equal(struct media_quality *a, struct media_quality *b)\n{\n  return (a->sample_rate == b->sample_rate && a->bits_per_sample == b->bits_per_sample && a->channels == b->channels && a->bit_rate == b->bit_rate);\n}\n\n\n/* -------------------------- Misc utility functions ------------------------ */\n\nchar **\nbuildopts_get()\n{\n  return buildopts;\n}\n\nint\nmutex_init(pthread_mutex_t *mutex)\n{\n  pthread_mutexattr_t mattr;\n  int err;\n\n  CHECK_ERR(L_MISC, pthread_mutexattr_init(&mattr));\n  CHECK_ERR(L_MISC, pthread_mutexattr_settype(&mattr, PTHREAD_MUTEX_ERRORCHECK));\n  err = pthread_mutex_init(mutex, &mattr);\n  CHECK_ERR(L_MISC, pthread_mutexattr_destroy(&mattr));\n\n  return err;\n}\n\nvoid\nthread_setname(pthread_t thread, const char *name)\n{\n#if defined(HAVE_PTHREAD_SETNAME_NP)\n  pthread_setname_np(thread, name);\n#elif defined(HAVE_PTHREAD_SET_NAME_NP)\n  pthread_set_name_np(thread, name);\n#endif\n}\n\n#ifdef HAVE_UUID\nvoid\nuuid_make(char *str)\n{\n  uuid_t uu;\n\n  uuid_generate_random(uu);\n  uuid_unparse_upper(uu, str);\n}\n#else\nvoid\nuuid_make(char *str)\n{\n  uint16_t uuid[8];\n  time_t now;\n  int i;\n\n  now = time(NULL);\n\n  srand((unsigned int)now);\n\n  for (i = 0; i < ARRAY_SIZE(uuid); i++)\n    {\n      uuid[i] = (uint16_t)rand();\n\n      // time_hi_and_version, set version to 4 (=random)\n      if (i == 3)\n\tuuid[i] = (uuid[i] & 0x0FFF) | 0x4000;\n      // clock_seq, variant 1\n      if (i == 4)\n\tuuid[i] = (uuid[i] & 0x3FFF) | 0x8000;\n\n\n      if (i == 2 || i == 3 || i == 4 || i == 5)\n\tstr += sprintf(str, \"-\");\n\n      str += sprintf(str, \"%04\" PRIX16, uuid[i]);\n    }\n}\n#endif\n\nint\nlinear_regression(double *m, double *b, double *r2, const double *x, const double *y, int n)\n{\n  double x_val;\n  double sum_x  = 0;\n  double sum_x2 = 0;\n  double sum_y  = 0;\n  double sum_y2 = 0;\n  double sum_xy = 0;\n  double denom;\n  int i;\n\n  for (i = 0; i < n; i++)\n    {\n      x_val   = x ? x[i] : (double)i;\n      sum_x  += x_val;\n      sum_x2 += x_val * x_val;\n      sum_y  += y[i];\n      sum_y2 += y[i] * y[i];\n      sum_xy += x_val * y[i];\n    }\n\n  denom = (n * sum_x2 - sum_x * sum_x);\n  if (denom == 0)\n    return -1;\n\n  *m = (n * sum_xy - sum_x * sum_y) / denom;\n  *b = (sum_y * sum_x2 - sum_x * sum_xy) / denom;\n  if (r2)\n    *r2 = (sum_xy - (sum_x * sum_y)/n) * (sum_xy - (sum_x * sum_y)/n) / ((sum_x2 - (sum_x * sum_x)/n) * (sum_y2 - (sum_y * sum_y)/n));\n\n  return 0;\n}\n\nchar **\nm_readfile(const char *path, int num_lines)\n{\n  char buf[256];\n  FILE *fp;\n  char **lines;\n  char *line;\n  int i;\n\n  // Alloc array of char pointers\n  lines = calloc(num_lines, sizeof(char *));\n  if (!lines)\n    return NULL;\n\n  fp = fopen(path, \"rb\");\n  if (!fp)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not open file '%s' for reading: %s\\n\", path, strerror(errno));\n      free(lines);\n      return NULL;\n    }\n\n  for (i = 0; i < num_lines; i++)\n    {\n      line = fgets(buf, sizeof(buf), fp);\n      if (!line)\n\t{\n\t  DPRINTF(E_LOG, L_MISC, \"File '%s' has fewer lines than expected (found %d, expected %d)\\n\", path, i, num_lines);\n\t  goto error;\n\t}\n\n      lines[i] = atrim(line);\n      if (!lines[i] || (strlen(lines[i]) == 0))\n\t{\n\t  DPRINTF(E_LOG, L_MISC, \"Line %d in '%s' is invalid\\n\", i+1, path);\n\t  goto error;\n\t}\n    }\n\n  fclose(fp);\n\n  return lines;\n\n error:\n  for (i = 0; i < num_lines; i++)\n    free(lines[i]);\n\n  free(lines);\n  fclose(fp);\n  return NULL;\n}\n\n\n/* -------------------------------- Assertion ------------------------------- */\n\nvoid\nlog_fatal_err(int domain, const char *func, int line, int err)\n{\n  DPRINTF(E_FATAL, domain, \"%s failed at line %d, error %d (%s)\\n\", func, line, err, strerror(err));\n  abort();\n}\n\nvoid\nlog_fatal_errno(int domain, const char *func, int line)\n{\n  DPRINTF(E_FATAL, domain, \"%s failed at line %d, error %d (%s)\\n\", func, line, errno, strerror(errno));\n  abort();\n}\n\nvoid\nlog_fatal_null(int domain, const char *func, int line)\n{\n  DPRINTF(E_FATAL, domain, \"%s returned NULL at line %d\\n\", func, line);\n  abort();\n}\n\n\n"], "fixing_code": ["/*\n * Copyright (C) 2009-2010 Julien BLACHE <jb@jblache.org>\n *\n * Some code included below is in the public domain, check comments\n * in the file.\n *\n * Pieces of code adapted from mt-daapd:\n * Copyright (C) 2003-2007 Ron Pedde (ron@pedde.com)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <sys/param.h>\n#include <sys/types.h>\n#ifndef CLOCK_REALTIME\n#include <sys/time.h>\n#endif\n#ifdef HAVE_UUID\n#include <uuid/uuid.h>\n#endif\n#ifdef HAVE_PTHREAD_NP_H\n# include <pthread_np.h>\n#endif\n\n#include <netdb.h>\n#include <arpa/inet.h>\n\n#include <unistr.h>\n#include <uniconv.h>\n\n#include <libavutil/base64.h>\n\n#include \"logger.h\"\n#include \"conffile.h\"\n#include \"misc.h\"\n\n\nstatic char *buildopts[] =\n  {\n#ifdef HAVE_FFMPEG\n    \"ffmpeg\",\n#else\n    \"libav\",\n#endif\n#ifdef SPOTIFY\n    \"Spotify\",\n#else\n    \"Without Spotify\",\n#endif\n#ifdef SPOTIFY_LIBRESPOTC\n    \"librespot-c\",\n#endif\n#ifdef SPOTIFY_LIBSPOTIFY\n    \"libspotify\",\n#endif\n#ifdef LASTFM\n    \"LastFM\",\n#else\n    \"Without LastFM\",\n#endif\n#ifdef CHROMECAST\n    \"Chromecast\",\n#else\n    \"Without Chromecast\",\n#endif\n#ifdef MPD\n    \"MPD\",\n#else\n    \"Without MPD\",\n#endif\n#ifdef HAVE_LIBWEBSOCKETS\n    \"Websockets\",\n#else\n    \"Without websockets\",\n#endif\n#ifdef HAVE_ALSA\n    \"ALSA\",\n#else\n    \"Without ALSA\",\n#endif\n#ifdef HAVE_LIBPULSE\n    \"Pulseaudio\",\n#endif\n#ifdef WEBINTERFACE\n    \"Webinterface\",\n#else\n    \"Without webinterface\",\n#endif\n#ifdef HAVE_REGEX_H\n    \"Regex\",\n#else\n    \"Without regex\",\n#endif\n    NULL\n  };\n\n\n/* ------------------------ Network utility functions ----------------------- */\n\nbool\nnet_peer_address_is_trusted(const char *addr)\n{\n  cfg_t *section;\n  const char *network;\n  int i;\n  int n;\n\n  if (!addr)\n    return false;\n\n  if (strncmp(addr, \"::ffff:\", strlen(\"::ffff:\")) == 0)\n    addr += strlen(\"::ffff:\");\n\n  section = cfg_getsec(cfg, \"general\");\n\n  n = cfg_size(section, \"trusted_networks\");\n  for (i = 0; i < n; i++)\n    {\n      network = cfg_getnstr(section, \"trusted_networks\", i);\n\n      if (!network || network[0] == '\\0')\n\treturn false;\n\n      if (strncmp(network, addr, strlen(network)) == 0)\n\treturn true;\n\n      if ((strcmp(network, \"localhost\") == 0) && (strcmp(addr, \"127.0.0.1\") == 0 || strcmp(addr, \"::1\") == 0))\n\treturn true;\n\n      if (strcmp(network, \"any\") == 0)\n\treturn true;\n    }\n\n  return false;\n}\n\nint\nnet_address_get(char *addr, size_t addr_len, union net_sockaddr *naddr)\n{\n  const char *s;\n\n  memset(addr, 0, addr_len); // Just in case caller doesn't check for errors\n\n  if (naddr->sa.sa_family == AF_INET6)\n     s = inet_ntop(AF_INET6, &naddr->sin6.sin6_addr, addr, addr_len);\n  else\n     s = inet_ntop(AF_INET, &naddr->sin.sin_addr, addr, addr_len);\n\n  if (!s)\n    return -1;\n\n  return 0;\n}\n\nint\nnet_port_get(short unsigned *port, union net_sockaddr *naddr)\n{\n  if (naddr->sa.sa_family == AF_INET6)\n     *port = ntohs(naddr->sin6.sin6_port);\n  else\n     *port = ntohs(naddr->sin.sin_port);\n\n  return 0;\n}\n\nint\nnet_connect(const char *addr, unsigned short port, int type, const char *log_service_name)\n{\n  struct addrinfo hints = { 0 };\n  struct addrinfo *servinfo;\n  struct addrinfo *ptr;\n  char strport[8];\n  int fd;\n  int ret;\n\n  DPRINTF(E_DBG, L_MISC, \"Connecting to '%s' at %s (port %u)\\n\", log_service_name, addr, port);\n\n  hints.ai_socktype = (type & (SOCK_STREAM | SOCK_DGRAM)); // filter since type can be SOCK_STREAM | SOCK_NONBLOCK\n  hints.ai_family = (cfg_getbool(cfg_getsec(cfg, \"general\"), \"ipv6\")) ? AF_UNSPEC : AF_INET;\n\n  snprintf(strport, sizeof(strport), \"%hu\", port);\n  ret = getaddrinfo(addr, strport, &hints, &servinfo);\n  if (ret < 0)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not connect to '%s' at %s (port %u): %s\\n\", log_service_name, addr, port, gai_strerror(ret));\n      return -1;\n    }\n\n  for (ptr = servinfo; ptr; ptr = ptr->ai_next)\n    {\n      fd = socket(ptr->ai_family, type | SOCK_CLOEXEC, ptr->ai_protocol);\n      if (fd < 0)\n\t{\n\t  continue;\n\t}\n\n      ret = connect(fd, ptr->ai_addr, ptr->ai_addrlen);\n      if (ret < 0 && errno != EINPROGRESS) // EINPROGRESS in case of SOCK_NONBLOCK\n\t{\n\t  close(fd);\n\t  continue;\n\t}\n\n      break;\n    }\n\n  freeaddrinfo(servinfo);\n\n  if (!ptr)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not connect to '%s' at %s (port %u): %s\\n\", log_service_name, addr, port, strerror(errno));\n      return -1;\n    }\n\n  // net_address_get(ipaddr, sizeof(ipaddr), (union net_sockaddr *)ptr->ai-addr);\n\n  return fd;\n}\n\n// If *port is 0 then a random port will be assigned, and *port will be updated\n// with the port number\nint\nnet_bind(short unsigned *port, int type, const char *log_service_name)\n{\n  struct addrinfo hints = { 0 };\n  struct addrinfo *servinfo;\n  struct addrinfo *ptr;\n  union net_sockaddr naddr = { 0 };\n  socklen_t naddr_len = sizeof(naddr);\n  const char *cfgaddr;\n  char addr[INET6_ADDRSTRLEN];\n  char strport[8];\n  int yes = 1;\n  int no = 0;\n  int fd;\n  int ret;\n\n  cfgaddr = cfg_getstr(cfg_getsec(cfg, \"general\"), \"bind_address\");\n\n  hints.ai_socktype = (type & (SOCK_STREAM | SOCK_DGRAM)); // filter since type can be SOCK_STREAM | SOCK_NONBLOCK\n  hints.ai_family = (cfg_getbool(cfg_getsec(cfg, \"general\"), \"ipv6\")) ? AF_INET6 : AF_INET;\n  hints.ai_flags = cfgaddr ? 0 : AI_PASSIVE;\n\n  snprintf(strport, sizeof(strport), \"%hu\", *port);\n  ret = getaddrinfo(cfgaddr, strport, &hints, &servinfo);\n  if (ret < 0)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Failure creating '%s' service, could not resolve '%s' (port %s): %s\\n\", log_service_name, cfgaddr ? cfgaddr : \"(ANY)\", strport, gai_strerror(ret));\n      return -1;\n    }\n\n  for (ptr = servinfo, fd = -1; ptr != NULL; ptr = ptr->ai_next)\n    {\n      if (fd >= 0)\n\tclose(fd);\n\n      fd = socket(ptr->ai_family, type | SOCK_CLOEXEC, ptr->ai_protocol);\n      if (fd < 0)\n\tcontinue;\n\n      // TODO libevent sets this, we do the same?\n      ret = setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &yes, sizeof(yes));\n      if (ret < 0)\n\tcontinue;\n\n      ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));\n      if (ret < 0)\n\tcontinue;\n\n      if (ptr->ai_family == AF_INET6)\n\t{\n\t  // We want to be sure the service is dual stack\n\t  ret = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &no, sizeof(no));\n\t  if (ret < 0)\n\t    continue;\n\t}\n\n      ret = bind(fd, ptr->ai_addr, ptr->ai_addrlen);\n      if (ret < 0)\n\tcontinue;\n\n      break;\n    }\n\n  freeaddrinfo(servinfo);\n\n  if (!ptr)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not create service '%s' with address %s, port %hu: %s\\n\", log_service_name, cfgaddr ? cfgaddr : \"(ANY)\", *port, strerror(errno));\n      goto error;\n    }\n\n  // Get our address (as string) and the port that was assigned (necessary when\n  // caller didn't specify a port)\n  ret = getsockname(fd, &naddr.sa, &naddr_len);\n  if (ret < 0)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Error finding address of service '%s': %s\\n\", log_service_name, strerror(errno));\n      goto error;\n    }\n  else if (naddr_len > sizeof(naddr))\n    {\n      DPRINTF(E_LOG, L_MISC, \"Unexpected address length of service '%s'\\n\", log_service_name);\n      goto error;\n    }\n\n  net_port_get(port, &naddr);\n  net_address_get(addr, sizeof(addr), &naddr);\n\n  DPRINTF(E_DBG, L_MISC, \"Service '%s' bound to %s, port %hu, socket %d\\n\", log_service_name, addr, *port, fd);\n\n  return fd;\n\n error:\n  close(fd);\n  return -1;\n}\n\nint\nnet_evhttp_bind(struct evhttp *evhttp, short unsigned port, const char *log_service_name)\n{\n  const char *bind_address;\n  bool v6_enabled;\n  int ret;\n\n  bind_address = cfg_getstr(cfg_getsec(cfg, \"general\"), \"bind_address\");\n  if (bind_address)\n    evhttp_bind_socket(evhttp, bind_address, port);\n\n  // For Linux, we could just do evhttp_bind_socket() for \"::\", and both the\n  // ipv4 and v6 port would be bound. However, for bsd it seems it is necessary\n  // to do like below.\n  v6_enabled = cfg_getbool(cfg_getsec(cfg, \"general\"), \"ipv6\");\n  if (v6_enabled)\n    {\n      ret = evhttp_bind_socket(evhttp, \"::\", port);\n      if (ret < 0)\n\t{\n\t  DPRINTF(E_LOG, L_MISC, \"Could not bind service '%s' to port %d with IPv6, falling back to IPv4\\n\", log_service_name, port);\n\t  v6_enabled = 0;\n\t}\n    }\n\n  ret = evhttp_bind_socket(evhttp, \"0.0.0.0\", port);\n  if (ret < 0)\n    {\n      if (!v6_enabled)\n\treturn -1;\n\n#ifndef __linux__\n      DPRINTF(E_LOG, L_MISC, \"Could not bind service '%s' to port %d with IPv4, listening on IPv6 only\\n\", log_service_name, port);\n#endif\n    }\n\n  return 0;\n}\n\nbool\nnet_is_http_or_https(const char *url)\n{\n  return (strncasecmp(url, \"http://\", strlen(\"http://\")) == 0 || strncasecmp(url, \"https://\", strlen(\"https://\")) == 0);\n}\n\n/* ----------------------- Conversion/hashing/sanitizers -------------------- */\n\nint\nsafe_atoi32(const char *str, int32_t *val)\n{\n  char *end;\n  long intval;\n\n  *val = 0;\n\n  errno = 0;\n  intval = strtol(str, &end, 10);\n\n  if (((errno == ERANGE) && ((intval == LONG_MAX) || (intval == LONG_MIN)))\n      || ((errno != 0) && (intval == 0)))\n    {\n      DPRINTF(E_DBG, L_MISC, \"Invalid integer in string (%s): %s\\n\", str, strerror(errno));\n\n      return -1;\n    }\n\n  if (end == str)\n    {\n      DPRINTF(E_DBG, L_MISC, \"No integer found in string (%s)\\n\", str);\n\n      return -1;\n    }\n\n  if (intval > INT32_MAX)\n    {\n      DPRINTF(E_DBG, L_MISC, \"Integer value too large (%s)\\n\", str);\n\n      return -1;\n    }\n\n  *val = (int32_t)intval;\n\n  return 0;\n}\n\nint\nsafe_atou32(const char *str, uint32_t *val)\n{\n  char *end;\n  unsigned long intval;\n\n  *val = 0;\n\n  errno = 0;\n  intval = strtoul(str, &end, 10);\n\n  if (((errno == ERANGE) && (intval == ULONG_MAX))\n      || ((errno != 0) && (intval == 0)))\n    {\n      DPRINTF(E_DBG, L_MISC, \"Invalid integer in string (%s): %s\\n\", str, strerror(errno));\n\n      return -1;\n    }\n\n  if (end == str)\n    {\n      DPRINTF(E_DBG, L_MISC, \"No integer found in string (%s)\\n\", str);\n\n      return -1;\n    }\n\n  if (intval > UINT32_MAX)\n    {\n      DPRINTF(E_DBG, L_MISC, \"Integer value too large (%s)\\n\", str);\n\n      return -1;\n    }\n\n  *val = (uint32_t)intval;\n\n  return 0;\n}\n\nint\nsafe_hextou32(const char *str, uint32_t *val)\n{\n  char *end;\n  unsigned long intval;\n\n  *val = 0;\n\n  errno = 0;\n  intval = strtoul(str, &end, 16);\n\n  if (((errno == ERANGE) && (intval == ULONG_MAX))\n      || ((errno != 0) && (intval == 0)))\n    {\n      DPRINTF(E_DBG, L_MISC, \"Invalid integer in string (%s): %s\\n\", str, strerror(errno));\n\n      return -1;\n    }\n\n  if (end == str)\n    {\n      DPRINTF(E_DBG, L_MISC, \"No integer found in string (%s)\\n\", str);\n\n      return -1;\n    }\n\n  if (intval > UINT32_MAX)\n    {\n      DPRINTF(E_DBG, L_MISC, \"Integer value too large (%s)\\n\", str);\n\n      return -1;\n    }\n\n  *val = (uint32_t)intval;\n\n  return 0;\n}\n\nint\nsafe_atoi64(const char *str, int64_t *val)\n{\n  char *end;\n  long long intval;\n\n  *val = 0;\n\n  errno = 0;\n  intval = strtoll(str, &end, 10);\n\n  if (((errno == ERANGE) && ((intval == LLONG_MAX) || (intval == LLONG_MIN)))\n      || ((errno != 0) && (intval == 0)))\n    {\n      DPRINTF(E_DBG, L_MISC, \"Invalid integer in string (%s): %s\\n\", str, strerror(errno));\n\n      return -1;\n    }\n\n  if (end == str)\n    {\n      DPRINTF(E_DBG, L_MISC, \"No integer found in string (%s)\\n\", str);\n\n      return -1;\n    }\n\n  if (intval > INT64_MAX)\n    {\n      DPRINTF(E_DBG, L_MISC, \"Integer value too large (%s)\\n\", str);\n\n      return -1;\n    }\n\n  *val = (int64_t)intval;\n\n  return 0;\n}\n\nint\nsafe_atou64(const char *str, uint64_t *val)\n{\n  char *end;\n  unsigned long long intval;\n\n  *val = 0;\n\n  errno = 0;\n  intval = strtoull(str, &end, 10);\n\n  if (((errno == ERANGE) && (intval == ULLONG_MAX))\n      || ((errno != 0) && (intval == 0)))\n    {\n      DPRINTF(E_DBG, L_MISC, \"Invalid integer in string (%s): %s\\n\", str, strerror(errno));\n\n      return -1;\n    }\n\n  if (end == str)\n    {\n      DPRINTF(E_DBG, L_MISC, \"No integer found in string (%s)\\n\", str);\n\n      return -1;\n    }\n\n  if (intval > UINT64_MAX)\n    {\n      DPRINTF(E_DBG, L_MISC, \"Integer value too large (%s)\\n\", str);\n\n      return -1;\n    }\n\n  *val = (uint64_t)intval;\n\n  return 0;\n}\n\nint\nsafe_hextou64(const char *str, uint64_t *val)\n{\n  char *end;\n  unsigned long long intval;\n\n  *val = 0;\n\n  errno = 0;\n  intval = strtoull(str, &end, 16);\n\n  if (((errno == ERANGE) && (intval == ULLONG_MAX))\n      || ((errno != 0) && (intval == 0)))\n    {\n      DPRINTF(E_DBG, L_MISC, \"Invalid integer in string (%s): %s\\n\", str, strerror(errno));\n\n      return -1;\n    }\n\n  if (end == str)\n    {\n      DPRINTF(E_DBG, L_MISC, \"No integer found in string (%s)\\n\", str);\n\n      return -1;\n    }\n\n  if (intval > UINT64_MAX)\n    {\n      DPRINTF(E_DBG, L_MISC, \"Integer value too large (%s)\\n\", str);\n\n      return -1;\n    }\n\n  *val = (uint64_t)intval;\n\n  return 0;\n}\n\nchar *\nsafe_strdup(const char *str)\n{\n  if (str == NULL)\n    return NULL;\n\n  return strdup(str);\n}\n\n/*\n * Wrapper function for vasprintf by Intel Corporation\n * Published under the L-GPL 2.1 licence as part of clr-boot-manager\n *\n * https://github.com/clearlinux/clr-boot-manager\n */\nchar *\nsafe_asprintf(const char *fmt, ...)\n{\n  char *ret = NULL;\n  va_list va;\n\n  va_start(va, fmt);\n  if (vasprintf(&ret, fmt, va) < 0)\n    {\n      DPRINTF(E_FATAL, L_MISC, \"Out of memory for safe_asprintf\\n\");\n      abort();\n    }\n  va_end(va);\n\n  return ret;\n}\n\nint\nsafe_snprintf_cat(char *dst, size_t n, const char *fmt, ...)\n{\n  size_t dstlen;\n  va_list va;\n  int ret;\n\n  if (!dst || !fmt)\n    return -1;\n\n  dstlen = strlen(dst);\n  if (n < dstlen)\n    return -1;\n\n  va_start(va, fmt);\n  ret = vsnprintf(dst + dstlen, n - dstlen, fmt, va);\n  va_end(va);\n\n  if (ret >= 0 && ret < n - dstlen)\n    return 0;\n  else\n    return -1;\n}\n\nint\nsafe_snreplace(char *s, size_t sz, const char *pattern, const char *replacement)\n{\n  char *ptr;\n  char *src;\n  char *dst;\n  size_t num;\n\n  if (!s)\n    return -1;\n\n  if (!pattern || !replacement)\n    return 0;\n\n  size_t p_len = strlen(pattern);\n  size_t r_len = strlen(replacement);\n  size_t s_len = strlen(s) + 1; // Incl terminator\n\n  ptr = s;\n  while ((ptr = strstr(ptr, pattern)))\n    {\n      // We will move the part of the string after the pattern from src to dst\n      src = ptr + p_len;\n      dst = ptr + r_len;\n\n      num = s_len - (src - s); // Number of bytes w/terminator we need to move\n      if (dst + num > s + sz)\n\treturn -1; // Not enough room\n\n      // Shift everything after the pattern to the right, use memmove since\n      // there might be an overlap\n      memmove(dst, src, num);\n\n      // Write replacement, no null terminater\n      memcpy(ptr, replacement, r_len);\n\n      // Advance ptr to avoid infinite looping\n      ptr = dst;\n    }\n\n  return 0;\n}\n\n\nchar *\nunicode_fixup_string(char *str, const char *fromcode)\n{\n  uint8_t *ret;\n  size_t len;\n\n  if (!str)\n    return NULL;\n\n  len = strlen(str);\n\n  /* String is valid UTF-8 */\n  if (!u8_check((uint8_t *)str, len))\n    {\n      if (len >= 3)\n\t{\n\t  /* Check for and strip byte-order mark */\n\t  if (memcmp(\"\\xef\\xbb\\xbf\", str, 3) == 0)\n\t    memmove(str, str + 3, len - 3 + 1);\n\t}\n\n      return str;\n    }\n\n  ret = u8_strconv_from_encoding(str, fromcode, iconveh_question_mark);\n  if (!ret)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not convert string '%s' to UTF-8: %s\\n\", str, strerror(errno));\n\n      return NULL;\n    }\n\n  return (char *)ret;\n}\n\nchar *\ntrim(char *str)\n{\n  size_t start; // Position of first non-space char\n  size_t term;  // Position of 0-terminator\n\n  if (!str)\n    return NULL;\n\n  start = 0;\n  term  = strlen(str);\n\n  while ((start < term) && isspace(str[start]))\n    start++;\n  while ((term > start) && isspace(str[term - 1]))\n    term--;\n\n  str[term] = '\\0';\n\n  // Shift chars incl. terminator\n  if (start)\n    memmove(str, str + start, term - start + 1);\n\n  return str;\n}\n\nchar *\natrim(const char *str)\n{\n  size_t start; // Position of first non-space char\n  size_t term;  // Position of 0-terminator\n  size_t size;\n  char *result;\n\n  if (!str)\n    return NULL;\n\n  start = 0;\n  term  = strlen(str);\n\n  while ((start < term) && isspace(str[start]))\n    start++;\n  while ((term > start) && isspace(str[term - 1]))\n    term--;\n\n  size = term - start + 1;\n\n  result = malloc(size);\n\n  memcpy(result, str + start, size);\n  result[size - 1] = '\\0';\n\n  return result;\n}\n\nvoid\nswap_pointers(char **a, char **b)\n{\n  char *t = *a;\n  *a = *b;\n  *b = t;\n}\n\nuint32_t\ndjb_hash(const void *data, size_t len)\n{\n  const unsigned char *bytes = data;\n  uint32_t hash = 5381;\n\n  while (len--)\n    {\n      hash = ((hash << 5) + hash) + *bytes;\n      bytes++;\n    }\n\n  return hash;\n}\n\nint64_t\ntwo_str_hash(const char *a, const char *b)\n{\n  char hashbuf[2048];\n  int64_t hash;\n  int i;\n  int ret;\n\n  ret = snprintf(hashbuf, sizeof(hashbuf), \"%s==%s\", (a) ? a : \"\", (b) ? b : \"\");\n  if (ret < 0 || ret == sizeof(hashbuf))\n    {\n      DPRINTF(E_LOG, L_MISC, \"Buffer too large to calculate hash: '%s==%s'\\n\", a, b);\n      return 999999; // Stand-in hash...\n    }\n\n  for (i = 0; hashbuf[i]; i++)\n    hashbuf[i] = tolower(hashbuf[i]);\n\n  // Limit hash length to 63 bits, due to signed type in sqlite\n  hash = murmur_hash64(hashbuf, strlen(hashbuf), 0) >> 1;\n\n  return hash;\n}\n\nuint8_t *\nb64_decode(int *dstlen, const char *src)\n{\n  uint8_t *out;\n  int len;\n  int ret;\n\n  len = AV_BASE64_DECODE_SIZE(strlen(src));\n\n  // Add a extra zero byte just in case we are decoding a string without null\n  // termination\n  CHECK_NULL(L_MISC, out = calloc(1, len + 1));\n\n  ret = av_base64_decode(out, src, len);\n  if (ret < 0)\n    {\n      free(out);\n      return NULL;\n    }\n\n  if (dstlen)\n    *dstlen = ret;\n\n  return out;\n}\n\nchar *\nb64_encode(const uint8_t *src, int srclen)\n{\n  char *out;\n  int len;\n  char *ret;\n\n  len = AV_BASE64_SIZE(srclen);\n\n  CHECK_NULL(L_MISC, out = calloc(1, len));\n\n  ret = av_base64_encode(out, len, src, srclen);\n  if (!ret)\n    {\n      free(out);\n      return NULL;\n    }\n\n  return out;\n}\n\n\n/*\n * MurmurHash2, 64-bit versions, by Austin Appleby\n *\n * Code released under the public domain, as per\n *    <http://murmurhash.googlepages.com/>\n * as of 2010-01-03.\n */\n\n#if SIZEOF_VOID_P == 8 /* 64bit platforms */\n\nuint64_t\nmurmur_hash64(const void *key, int len, uint32_t seed)\n{\n  const int r = 47;\n  const uint64_t m = 0xc6a4a7935bd1e995;\n\n  const uint64_t *data;\n  const uint64_t *end;\n  const unsigned char *data_tail;\n  uint64_t h;\n  uint64_t k;\n\n  h = seed ^ (len * m);\n  data = (const uint64_t *)key;\n  end = data + (len / 8);\n\n  while (data != end)\n    {\n      k = *data++;\n\n      k *= m;\n      k ^= k >> r;\n      k *= m;\n\n      h ^= k;\n      h *= m;\n    }\n\n  data_tail = (const unsigned char *)data;\n\n  switch (len & 7)\n    {\n      case 7:\n\th ^= (uint64_t)(data_tail[6]) << 48; /* FALLTHROUGH */\n      case 6:\n\th ^= (uint64_t)(data_tail[5]) << 40; /* FALLTHROUGH */\n      case 5:\n\th ^= (uint64_t)(data_tail[4]) << 32; /* FALLTHROUGH */\n      case 4:\n\th ^= (uint64_t)(data_tail[3]) << 24; /* FALLTHROUGH */\n      case 3:\n\th ^= (uint64_t)(data_tail[2]) << 16; /* FALLTHROUGH */\n      case 2:\n\th ^= (uint64_t)(data_tail[1]) << 8; /* FALLTHROUGH */\n      case 1:\n\th ^= (uint64_t)(data_tail[0]);\n\th *= m;\n    }\n\n  h ^= h >> r;\n  h *= m;\n  h ^= h >> r;\n\n  return h;\n}\n\n#elif SIZEOF_VOID_P == 4 /* 32bit platforms */\n\nuint64_t\nmurmur_hash64(const void *key, int len, uint32_t seed)\n{\n  const int r = 24;\n  const uint32_t m = 0x5bd1e995;\n\n  const uint32_t *data;\n  const unsigned char *data_tail;\n  uint32_t k1;\n  uint32_t h1;\n  uint32_t k2;\n  uint32_t h2;\n\n  uint64_t h;\n\n  h1 = seed ^ len;\n  h2 = 0;\n\n  data = (const uint32_t *)key;\n\n  while (len >= 8)\n    {\n      k1 = *data++;\n      k1 *= m; k1 ^= k1 >> r; k1 *= m;\n      h1 *= m; h1 ^= k1;\n\n      k2 = *data++;\n      k2 *= m; k2 ^= k2 >> r; k2 *= m;\n      h2 *= m; h2 ^= k2;\n\n      len -= 8;\n    }\n\n  if (len >= 4)\n    {\n      k1 = *data++;\n      k1 *= m; k1 ^= k1 >> r; k1 *= m;\n      h1 *= m; h1 ^= k1;\n      len -= 4;\n    }\n\n  data_tail = (const unsigned char *)data;\n\n  switch(len)\n    {\n      case 3:\n\th2 ^= (uint32_t)(data_tail[2]) << 16;\n      case 2:\n\th2 ^= (uint32_t)(data_tail[1]) << 8;\n      case 1:\n\th2 ^= (uint32_t)(data_tail[0]);\n\th2 *= m;\n    };\n\n  h1 ^= h2 >> 18; h1 *= m;\n  h2 ^= h1 >> 22; h2 *= m;\n  h1 ^= h2 >> 17; h1 *= m;\n  h2 ^= h1 >> 19; h2 *= m;\n\n  h = h1;\n  h = (h << 32) | h2;\n\n  return h;\n}\n#else\n# error Platform not supported\n#endif\n\n\n/* --------------------------- Key/value functions -------------------------- */\n\nstruct keyval *\nkeyval_alloc(void)\n{\n  struct keyval *kv;\n\n  kv = calloc(1, sizeof(struct keyval));\n  if (!kv)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Out of memory for keyval alloc\\n\");\n\n      return NULL;\n    }\n\n  return kv;\n}\n\nint\nkeyval_add_size(struct keyval *kv, const char *name, const char *value, size_t size)\n{\n  struct onekeyval *okv;\n  const char *val;\n\n  if (!kv)\n    return -1;\n\n  /* Check for duplicate key names */\n  val = keyval_get(kv, name);\n  if (val)\n    {\n      /* Same value, fine */\n      if (strcmp(val, value) == 0)\n        return 0;\n      else /* Different value, bad */\n        return -1;\n    }\n\n  okv = (struct onekeyval *)malloc(sizeof(struct onekeyval));\n  if (!okv)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Out of memory for new keyval\\n\");\n\n      return -1;\n    }\n\n  okv->name = strdup(name);\n  if (!okv->name)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Out of memory for new keyval name\\n\");\n\n      free(okv);\n      return -1;\n    }\n\n  okv->value = (char *)malloc(size + 1);\n  if (!okv->value)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Out of memory for new keyval value\\n\");\n\n      free(okv->name);\n      free(okv);\n      return -1;\n    }\n\n  memcpy(okv->value, value, size);\n  okv->value[size] = '\\0';\n\n  okv->next = NULL;\n\n  if (!kv->head)\n    kv->head = okv;\n\n  if (kv->tail)\n    kv->tail->next = okv;\n\n  kv->tail = okv;\n\n  return 0;\n}\n\nint\nkeyval_add(struct keyval *kv, const char *name, const char *value)\n{\n  return keyval_add_size(kv, name, value, strlen(value));\n}\n\nvoid\nkeyval_remove(struct keyval *kv, const char *name)\n{\n  struct onekeyval *okv;\n  struct onekeyval *pokv;\n\n  if (!kv)\n    return;\n\n  for (pokv = NULL, okv = kv->head; okv; pokv = okv, okv = okv->next)\n    {\n      if (strcasecmp(okv->name, name) == 0)\n        break;\n    }\n\n  if (!okv)\n    return;\n\n  if (okv == kv->head)\n    kv->head = okv->next;\n\n  if (okv == kv->tail)\n    kv->tail = pokv;\n\n  if (pokv)\n    pokv->next = okv->next;\n\n  free(okv->name);\n  free(okv->value);\n  free(okv);\n}\n\nconst char *\nkeyval_get(struct keyval *kv, const char *name)\n{\n  struct onekeyval *okv;\n\n  if (!kv)\n    return NULL;\n\n  for (okv = kv->head; okv; okv = okv->next)\n    {\n      if (strcasecmp(okv->name, name) == 0)\n        return okv->value;\n    }\n\n  return NULL;\n}\n\nvoid\nkeyval_clear(struct keyval *kv)\n{\n  struct onekeyval *hokv;\n  struct onekeyval *okv;\n\n  if (!kv)\n    return;\n\n  hokv = kv->head;\n\n  for (okv = hokv; hokv; okv = hokv)\n    {\n      hokv = okv->next;\n\n      free(okv->name);\n      free(okv->value);\n      free(okv);\n    }\n\n  kv->head = NULL;\n  kv->tail = NULL;\n}\n\nvoid\nkeyval_sort(struct keyval *kv)\n{\n  struct onekeyval *head;\n  struct onekeyval *okv;\n  struct onekeyval *sokv;\n\n  if (!kv || !kv->head)\n    return;\n\n  head = kv->head;\n  for (okv = kv->head; okv; okv = okv->next)\n    {\n      okv->sort = NULL;\n      for (sokv = kv->head; sokv; sokv = sokv->next)\n\t{\n\t  // We try to find a name which is greater than okv->name\n\t  // but less than our current candidate (okv->sort->name)\n\t  if ( (strcmp(sokv->name, okv->name) > 0) &&\n\t       ((okv->sort == NULL) || (strcmp(sokv->name, okv->sort->name) < 0)) )\n\t    okv->sort = sokv;\n\t}\n\n      // Find smallest name, which will be the new head\n      if (strcmp(okv->name, head->name) < 0)\n\thead = okv;\n    }\n\n  while ((okv = kv->head))\n    {\n      kv->head  = okv->next;\n      okv->next = okv->sort;\n    }\n\n  kv->head = head;\n  for (okv = kv->head; okv; okv = okv->next)\n    kv->tail = okv;\n\n  DPRINTF(E_DBG, L_MISC, \"Keyval sorted. New head: %s. New tail: %s.\\n\", kv->head->name, kv->tail->name);\n}\n\n\n/* ------------------------------- Ringbuffer ------------------------------- */\n\nint\nringbuffer_init(struct ringbuffer *buf, size_t size)\n{\n  memset(buf, 0, sizeof(struct ringbuffer));\n\n  CHECK_NULL(L_MISC, buf->buffer = malloc(size));\n  buf->size = size;\n  buf->write_avail = size;\n  return 0;\n}\n\nvoid\nringbuffer_free(struct ringbuffer *buf, bool content_only)\n{\n  if (!buf)\n    return;\n\n  free(buf->buffer);\n\n  if (content_only)\n    memset(buf, 0, sizeof(struct ringbuffer));\n  else\n    free(buf);\n}\n\nsize_t\nringbuffer_write(struct ringbuffer *buf, const void* src, size_t srclen)\n{\n  int remaining;\n\n  if (buf->write_avail == 0 || srclen == 0)\n    return 0;\n\n  if (srclen > buf->write_avail)\n   srclen = buf->write_avail;\n\n  remaining = buf->size - buf->write_pos;\n  if (srclen > remaining)\n    {\n      memcpy(buf->buffer + buf->write_pos, src, remaining);\n      memcpy(buf->buffer, src + remaining, srclen - remaining);\n    }\n  else\n    {\n      memcpy(buf->buffer + buf->write_pos, src, srclen);\n    }\n\n  buf->write_pos = (buf->write_pos + srclen) % buf->size;\n\n  buf->write_avail -= srclen;\n  buf->read_avail += srclen;\n\n  return srclen;\n}\n\nsize_t\nringbuffer_read(uint8_t **dst, size_t dstlen, struct ringbuffer *buf)\n{\n  int remaining;\n\n  *dst = buf->buffer + buf->read_pos;\n\n  if (buf->read_avail == 0 || dstlen == 0)\n    return 0;\n\n  remaining = buf->size - buf->read_pos;\n\n  // The number of bytes we will return will be MIN(dstlen, remaining, read_avail)\n  if (dstlen > remaining)\n    dstlen = remaining;\n  if (dstlen > buf->read_avail)\n    dstlen = buf->read_avail;\n\n  buf->read_pos = (buf->read_pos + dstlen) % buf->size;\n\n  buf->write_avail += dstlen;\n  buf->read_avail -= dstlen;\n\n  return dstlen;\n}\n\n\n/* ------------------------- Clock utility functions ------------------------ */\n\nint\nclock_gettime_with_res(clockid_t clock_id, struct timespec *tp, struct timespec *res)\n{\n  int ret;\n\n  if ((!tp) || (!res))\n    return -1;\n\n  ret = clock_gettime(clock_id, tp);\n  /* this will only work for sub-second resolutions. */\n  if (ret == 0 && res->tv_nsec > 1)\n    tp->tv_nsec = (tp->tv_nsec/res->tv_nsec)*res->tv_nsec;\n\n  return ret;\n}\n\nstruct timespec\ntimespec_add(struct timespec time1, struct timespec time2)\n{\n  struct timespec result;\n\n  result.tv_sec = time1.tv_sec + time2.tv_sec;\n  result.tv_nsec = time1.tv_nsec + time2.tv_nsec;\n  if (result.tv_nsec >= 1000000000L)\n    {\n      result.tv_sec++;\n      result.tv_nsec -= 1000000000L;\n    }\n  return result;\n}\n\nint\ntimespec_cmp(struct timespec time1, struct timespec time2)\n{\n  /* Less than. */\n  if (time1.tv_sec < time2.tv_sec)\n    return -1;\n  /* Greater than. */\n  else if (time1.tv_sec > time2.tv_sec)\n    return 1;\n  /* Less than. */\n  else if (time1.tv_nsec < time2.tv_nsec)\n    return -1;\n  /* Greater than. */\n  else if (time1.tv_nsec > time2.tv_nsec)\n    return 1;\n  /* Equal. */\n  else\n    return 0;\n}\n\nstruct timespec\ntimespec_reltoabs(struct timespec relative)\n{\n  struct timespec absolute;\n\n#ifdef CLOCK_REALTIME\n  clock_gettime(CLOCK_REALTIME, &absolute);\n#else\n  struct timeval tv;\n  gettimeofday(&tv, NULL);\n  TIMEVAL_TO_TIMESPEC(&tv, &absolute);\n#endif\n  return timespec_add(absolute, relative);\n}\n\n#if defined(HAVE_MACH_CLOCK) || defined(HAVE_MACH_TIMER)\n\n#include <mach/mach_time.h> /* mach_absolute_time */\n#include <mach/mach.h>      /* host_get_clock_service */\n#include <mach/clock.h>     /* clock_get_time */\n\n/* mach monotonic clock port */\nextern mach_port_t clock_port;\n\n#ifndef HAVE_CLOCK_GETTIME\n\nint\nclock_gettime(clockid_t clock_id, struct timespec *tp)\n{\n  static int clock_init = 0;\n  static clock_serv_t clock;\n\n  mach_timespec_t mts;\n  int ret;\n\n  if (! clock_init) {\n    clock_init = 1;\n    if (host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &clock))\n      abort(); /* unlikely */\n  }\n\n  if(! tp)\n    return -1;\n\n  switch (clock_id) {\n\n  case CLOCK_REALTIME:\n\n    /* query mach for calendar time */\n    ret = clock_get_time(clock, &mts);\n    if (! ret) {\n      tp->tv_sec = mts.tv_sec;\n      tp->tv_nsec = mts.tv_nsec;\n    }\n    break;\n\n  case CLOCK_MONOTONIC:\n\n    /* query mach for monotinic time */\n    ret = clock_get_time(clock_port, &mts);\n    if (! ret) {\n      tp->tv_sec = mts.tv_sec;\n      tp->tv_nsec = mts.tv_nsec;\n    }\n    break;\n\n  default:\n    ret = -1;\n    break;\n  }\n\n  return ret;\n}\n\nint\nclock_getres(clockid_t clock_id, struct timespec *res)\n{\n  if (! res)\n    return -1;\n\n  /* hardcode ms resolution */\n  res->tv_sec = 0;\n  res->tv_nsec = 1000;\n\n  return 0;\n}\n\n#endif /* HAVE_CLOCK_GETTIME */\n\n#ifndef HAVE_TIMER_SETTIME\n\n#include <sys/time.h> /* ITIMER_REAL */\n\nint\ntimer_create(clockid_t clock_id, void *sevp, timer_t *timer_id)\n{\n  if (clock_id != CLOCK_MONOTONIC)\n    return -1;\n  if (sevp)\n    return -1;\n\n  /* setitimer only supports one timer */\n  *timer_id = 0;\n\n  return 0;\n}\n\nint\ntimer_delete(timer_t timer_id)\n{\n  struct itimerval timerval;\n\n  if (timer_id != 0)\n    return -1;\n\n  memset(&timerval, 0, sizeof(struct itimerval));\n\n  return setitimer(ITIMER_REAL, &timerval, NULL);\n}\n\nint\ntimer_settime(timer_t timer_id, int flags, const struct itimerspec *tp, struct itimerspec *old)\n{\n  struct itimerval tv;\n\n  if (timer_id != 0 || ! tp || old)\n    return -1;\n\n  TIMESPEC_TO_TIMEVAL(&(tv.it_value), &(tp->it_value));\n  TIMESPEC_TO_TIMEVAL(&(tv.it_interval), &(tp->it_interval));\n\n  return setitimer(ITIMER_REAL, &tv, NULL);\n}\n\nint\ntimer_getoverrun(timer_t timer_id)\n{\n  /* since we don't know if there have been signals that weren't delivered,\n     assume none */\n  return 0;\n}\n\n#endif /* HAVE_TIMER_SETTIME */\n\n#endif /* HAVE_MACH_CLOCK */\n\n\n/* ------------------------------- Media quality ---------------------------- */\n\nbool\nquality_is_equal(struct media_quality *a, struct media_quality *b)\n{\n  return (a->sample_rate == b->sample_rate && a->bits_per_sample == b->bits_per_sample && a->channels == b->channels && a->bit_rate == b->bit_rate);\n}\n\n\n/* -------------------------- Misc utility functions ------------------------ */\n\nchar **\nbuildopts_get()\n{\n  return buildopts;\n}\n\nint\nmutex_init(pthread_mutex_t *mutex)\n{\n  pthread_mutexattr_t mattr;\n  int err;\n\n  CHECK_ERR(L_MISC, pthread_mutexattr_init(&mattr));\n  CHECK_ERR(L_MISC, pthread_mutexattr_settype(&mattr, PTHREAD_MUTEX_ERRORCHECK));\n  err = pthread_mutex_init(mutex, &mattr);\n  CHECK_ERR(L_MISC, pthread_mutexattr_destroy(&mattr));\n\n  return err;\n}\n\nvoid\nthread_setname(pthread_t thread, const char *name)\n{\n#if defined(HAVE_PTHREAD_SETNAME_NP)\n  pthread_setname_np(thread, name);\n#elif defined(HAVE_PTHREAD_SET_NAME_NP)\n  pthread_set_name_np(thread, name);\n#endif\n}\n\n#ifdef HAVE_UUID\nvoid\nuuid_make(char *str)\n{\n  uuid_t uu;\n\n  uuid_generate_random(uu);\n  uuid_unparse_upper(uu, str);\n}\n#else\nvoid\nuuid_make(char *str)\n{\n  uint16_t uuid[8];\n  time_t now;\n  int i;\n\n  now = time(NULL);\n\n  srand((unsigned int)now);\n\n  for (i = 0; i < ARRAY_SIZE(uuid); i++)\n    {\n      uuid[i] = (uint16_t)rand();\n\n      // time_hi_and_version, set version to 4 (=random)\n      if (i == 3)\n\tuuid[i] = (uuid[i] & 0x0FFF) | 0x4000;\n      // clock_seq, variant 1\n      if (i == 4)\n\tuuid[i] = (uuid[i] & 0x3FFF) | 0x8000;\n\n\n      if (i == 2 || i == 3 || i == 4 || i == 5)\n\tstr += sprintf(str, \"-\");\n\n      str += sprintf(str, \"%04\" PRIX16, uuid[i]);\n    }\n}\n#endif\n\nint\nlinear_regression(double *m, double *b, double *r2, const double *x, const double *y, int n)\n{\n  double x_val;\n  double sum_x  = 0;\n  double sum_x2 = 0;\n  double sum_y  = 0;\n  double sum_y2 = 0;\n  double sum_xy = 0;\n  double denom;\n  int i;\n\n  for (i = 0; i < n; i++)\n    {\n      x_val   = x ? x[i] : (double)i;\n      sum_x  += x_val;\n      sum_x2 += x_val * x_val;\n      sum_y  += y[i];\n      sum_y2 += y[i] * y[i];\n      sum_xy += x_val * y[i];\n    }\n\n  denom = (n * sum_x2 - sum_x * sum_x);\n  if (denom == 0)\n    return -1;\n\n  *m = (n * sum_xy - sum_x * sum_y) / denom;\n  *b = (sum_y * sum_x2 - sum_x * sum_xy) / denom;\n  if (r2)\n    *r2 = (sum_xy - (sum_x * sum_y)/n) * (sum_xy - (sum_x * sum_y)/n) / ((sum_x2 - (sum_x * sum_x)/n) * (sum_y2 - (sum_y * sum_y)/n));\n\n  return 0;\n}\n\nchar **\nm_readfile(const char *path, int num_lines)\n{\n  char buf[256];\n  FILE *fp;\n  char **lines;\n  char *line;\n  int i;\n\n  // Alloc array of char pointers\n  lines = calloc(num_lines, sizeof(char *));\n  if (!lines)\n    return NULL;\n\n  fp = fopen(path, \"rb\");\n  if (!fp)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not open file '%s' for reading: %s\\n\", path, strerror(errno));\n      free(lines);\n      return NULL;\n    }\n\n  for (i = 0; i < num_lines; i++)\n    {\n      line = fgets(buf, sizeof(buf), fp);\n      if (!line)\n\t{\n\t  DPRINTF(E_LOG, L_MISC, \"File '%s' has fewer lines than expected (found %d, expected %d)\\n\", path, i, num_lines);\n\t  goto error;\n\t}\n\n      lines[i] = atrim(line);\n      if (!lines[i] || (strlen(lines[i]) == 0))\n\t{\n\t  DPRINTF(E_LOG, L_MISC, \"Line %d in '%s' is invalid\\n\", i+1, path);\n\t  goto error;\n\t}\n    }\n\n  fclose(fp);\n\n  return lines;\n\n error:\n  for (i = 0; i < num_lines; i++)\n    free(lines[i]);\n\n  free(lines);\n  fclose(fp);\n  return NULL;\n}\n\n\n/* -------------------------------- Assertion ------------------------------- */\n\nvoid\nlog_fatal_err(int domain, const char *func, int line, int err)\n{\n  DPRINTF(E_FATAL, domain, \"%s failed at line %d, error %d (%s)\\n\", func, line, err, strerror(err));\n  abort();\n}\n\nvoid\nlog_fatal_errno(int domain, const char *func, int line)\n{\n  DPRINTF(E_FATAL, domain, \"%s failed at line %d, error %d (%s)\\n\", func, line, errno, strerror(errno));\n  abort();\n}\n\nvoid\nlog_fatal_null(int domain, const char *func, int line)\n{\n  DPRINTF(E_FATAL, domain, \"%s returned NULL at line %d\\n\", func, line);\n  abort();\n}\n\n\n"], "filenames": ["src/misc.c"], "buggy_code_start_loc": [253], "buggy_code_end_loc": [327], "fixing_code_start_loc": [254], "fixing_code_end_loc": [335], "type": "CWE-416", "message": "OwnTone (aka owntone-server) through 28.1 has a use-after-free in net_bind() in misc.c.", "other": {"cve": {"id": "CVE-2021-38383", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-10T18:15:07.470", "lastModified": "2021-08-17T19:21:05.850", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OwnTone (aka owntone-server) through 28.1 has a use-after-free in net_bind() in misc.c."}, {"lang": "es", "value": "OwnTone (tambi\u00e9n se conoce como owntone-server) versiones hasta 28.1, presenta un uso de la memoria previamente liberada en la funci\u00f3n net_bind() en el archivo misc.c"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:owntone_project:owntone:*:*:*:*:*:*:*:*", "versionEndIncluding": "28.1", "matchCriteriaId": "5878878D-B69E-4165-8A65-3BB57C965934"}]}]}], "references": [{"url": "https://github.com/owntone/owntone-server/commit/246d8ae0cef27377e5dfe9ee3ad87e864d6b6266", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/owntone/owntone-server/commit/246d8ae0cef27377e5dfe9ee3ad87e864d6b6266"}}