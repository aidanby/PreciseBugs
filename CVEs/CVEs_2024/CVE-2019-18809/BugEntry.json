{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/* DVB USB compliant Linux driver for the Afatech 9005\n * USB1.1 DVB-T receiver.\n *\n * Copyright (C) 2007 Luca Olivetti (luca@ventoso.org)\n *\n * Thanks to Afatech who kindly provided information.\n *\n * see Documentation/media/dvb-drivers/dvb-usb.rst for more information\n */\n#include \"af9005.h\"\n\n/* debug */\nint dvb_usb_af9005_debug;\nmodule_param_named(debug, dvb_usb_af9005_debug, int, 0644);\nMODULE_PARM_DESC(debug,\n\t\t \"set debugging level (1=info,xfer=2,rc=4,reg=8,i2c=16,fw=32 (or-able)).\"\n\t\t DVB_USB_DEBUG_STATUS);\n/* enable obnoxious led */\nbool dvb_usb_af9005_led = true;\nmodule_param_named(led, dvb_usb_af9005_led, bool, 0644);\nMODULE_PARM_DESC(led, \"enable led (default: 1).\");\n\n/* eeprom dump */\nstatic int dvb_usb_af9005_dump_eeprom;\nmodule_param_named(dump_eeprom, dvb_usb_af9005_dump_eeprom, int, 0);\nMODULE_PARM_DESC(dump_eeprom, \"dump contents of the eeprom.\");\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n/* remote control decoder */\nstatic int (*rc_decode) (struct dvb_usb_device *d, u8 *data, int len,\n\t\tu32 *event, int *state);\nstatic void *rc_keys;\nstatic int *rc_keys_size;\n\nu8 regmask[8] = { 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff };\n\nstruct af9005_device_state {\n\tu8 sequence;\n\tint led_state;\n\tunsigned char data[256];\n};\n\nstatic int af9005_generic_read_write(struct dvb_usb_device *d, u16 reg,\n\t\t\t      int readwrite, int type, u8 * values, int len)\n{\n\tstruct af9005_device_state *st = d->priv;\n\tu8 command, seq;\n\tint i, ret;\n\n\tif (len < 1) {\n\t\terr(\"generic read/write, less than 1 byte. Makes no sense.\");\n\t\treturn -EINVAL;\n\t}\n\tif (len > 8) {\n\t\terr(\"generic read/write, more than 8 bytes. Not supported.\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&d->data_mutex);\n\tst->data[0] = 14;\t\t/* rest of buffer length low */\n\tst->data[1] = 0;\t\t/* rest of buffer length high */\n\n\tst->data[2] = AF9005_REGISTER_RW;\t/* register operation */\n\tst->data[3] = 12;\t\t/* rest of buffer length */\n\n\tst->data[4] = seq = st->sequence++;\t/* sequence number */\n\n\tst->data[5] = (u8) (reg >> 8);\t/* register address */\n\tst->data[6] = (u8) (reg & 0xff);\n\n\tif (type == AF9005_OFDM_REG) {\n\t\tcommand = AF9005_CMD_OFDM_REG;\n\t} else {\n\t\tcommand = AF9005_CMD_TUNER;\n\t}\n\n\tif (len > 1)\n\t\tcommand |=\n\t\t    AF9005_CMD_BURST | AF9005_CMD_AUTOINC | (len - 1) << 3;\n\tcommand |= readwrite;\n\tif (readwrite == AF9005_CMD_WRITE)\n\t\tfor (i = 0; i < len; i++)\n\t\t\tst->data[8 + i] = values[i];\n\telse if (type == AF9005_TUNER_REG)\n\t\t/* read command for tuner, the first byte contains the i2c address */\n\t\tst->data[8] = values[0];\n\tst->data[7] = command;\n\n\tret = dvb_usb_generic_rw(d, st->data, 16, st->data, 17, 0);\n\tif (ret)\n\t\tgoto ret;\n\n\t/* sanity check */\n\tif (st->data[2] != AF9005_REGISTER_RW_ACK) {\n\t\terr(\"generic read/write, wrong reply code.\");\n\t\tret = -EIO;\n\t\tgoto ret;\n\t}\n\tif (st->data[3] != 0x0d) {\n\t\terr(\"generic read/write, wrong length in reply.\");\n\t\tret = -EIO;\n\t\tgoto ret;\n\t}\n\tif (st->data[4] != seq) {\n\t\terr(\"generic read/write, wrong sequence in reply.\");\n\t\tret = -EIO;\n\t\tgoto ret;\n\t}\n\t/*\n\t * In thesis, both input and output buffers should have\n\t * identical values for st->data[5] to st->data[8].\n\t * However, windows driver doesn't check these fields, in fact\n\t * sometimes the register in the reply is different that what\n\t * has been sent\n\t */\n\tif (st->data[16] != 0x01) {\n\t\terr(\"generic read/write wrong status code in reply.\");\n\t\tret = -EIO;\n\t\tgoto ret;\n\t}\n\n\tif (readwrite == AF9005_CMD_READ)\n\t\tfor (i = 0; i < len; i++)\n\t\t\tvalues[i] = st->data[8 + i];\n\nret:\n\tmutex_unlock(&d->data_mutex);\n\treturn ret;\n\n}\n\nint af9005_read_ofdm_register(struct dvb_usb_device *d, u16 reg, u8 * value)\n{\n\tint ret;\n\tdeb_reg(\"read register %x \", reg);\n\tret = af9005_generic_read_write(d, reg,\n\t\t\t\t\tAF9005_CMD_READ, AF9005_OFDM_REG,\n\t\t\t\t\tvalue, 1);\n\tif (ret)\n\t\tdeb_reg(\"failed\\n\");\n\telse\n\t\tdeb_reg(\"value %x\\n\", *value);\n\treturn ret;\n}\n\nint af9005_read_ofdm_registers(struct dvb_usb_device *d, u16 reg,\n\t\t\t       u8 * values, int len)\n{\n\tint ret;\n\tdeb_reg(\"read %d registers %x \", len, reg);\n\tret = af9005_generic_read_write(d, reg,\n\t\t\t\t\tAF9005_CMD_READ, AF9005_OFDM_REG,\n\t\t\t\t\tvalues, len);\n\tif (ret)\n\t\tdeb_reg(\"failed\\n\");\n\telse\n\t\tdebug_dump(values, len, deb_reg);\n\treturn ret;\n}\n\nint af9005_write_ofdm_register(struct dvb_usb_device *d, u16 reg, u8 value)\n{\n\tint ret;\n\tu8 temp = value;\n\tdeb_reg(\"write register %x value %x \", reg, value);\n\tret = af9005_generic_read_write(d, reg,\n\t\t\t\t\tAF9005_CMD_WRITE, AF9005_OFDM_REG,\n\t\t\t\t\t&temp, 1);\n\tif (ret)\n\t\tdeb_reg(\"failed\\n\");\n\telse\n\t\tdeb_reg(\"ok\\n\");\n\treturn ret;\n}\n\nint af9005_write_ofdm_registers(struct dvb_usb_device *d, u16 reg,\n\t\t\t\tu8 * values, int len)\n{\n\tint ret;\n\tdeb_reg(\"write %d registers %x values \", len, reg);\n\tdebug_dump(values, len, deb_reg);\n\n\tret = af9005_generic_read_write(d, reg,\n\t\t\t\t\tAF9005_CMD_WRITE, AF9005_OFDM_REG,\n\t\t\t\t\tvalues, len);\n\tif (ret)\n\t\tdeb_reg(\"failed\\n\");\n\telse\n\t\tdeb_reg(\"ok\\n\");\n\treturn ret;\n}\n\nint af9005_read_register_bits(struct dvb_usb_device *d, u16 reg, u8 pos,\n\t\t\t      u8 len, u8 * value)\n{\n\tu8 temp;\n\tint ret;\n\tdeb_reg(\"read bits %x %x %x\", reg, pos, len);\n\tret = af9005_read_ofdm_register(d, reg, &temp);\n\tif (ret) {\n\t\tdeb_reg(\" failed\\n\");\n\t\treturn ret;\n\t}\n\t*value = (temp >> pos) & regmask[len - 1];\n\tdeb_reg(\" value %x\\n\", *value);\n\treturn 0;\n\n}\n\nint af9005_write_register_bits(struct dvb_usb_device *d, u16 reg, u8 pos,\n\t\t\t       u8 len, u8 value)\n{\n\tu8 temp, mask;\n\tint ret;\n\tdeb_reg(\"write bits %x %x %x value %x\\n\", reg, pos, len, value);\n\tif (pos == 0 && len == 8)\n\t\treturn af9005_write_ofdm_register(d, reg, value);\n\tret = af9005_read_ofdm_register(d, reg, &temp);\n\tif (ret)\n\t\treturn ret;\n\tmask = regmask[len - 1] << pos;\n\ttemp = (temp & ~mask) | ((value << pos) & mask);\n\treturn af9005_write_ofdm_register(d, reg, temp);\n\n}\n\nstatic int af9005_usb_read_tuner_registers(struct dvb_usb_device *d,\n\t\t\t\t\t   u16 reg, u8 * values, int len)\n{\n\treturn af9005_generic_read_write(d, reg,\n\t\t\t\t\t AF9005_CMD_READ, AF9005_TUNER_REG,\n\t\t\t\t\t values, len);\n}\n\nstatic int af9005_usb_write_tuner_registers(struct dvb_usb_device *d,\n\t\t\t\t\t    u16 reg, u8 * values, int len)\n{\n\treturn af9005_generic_read_write(d, reg,\n\t\t\t\t\t AF9005_CMD_WRITE,\n\t\t\t\t\t AF9005_TUNER_REG, values, len);\n}\n\nint af9005_write_tuner_registers(struct dvb_usb_device *d, u16 reg,\n\t\t\t\t u8 * values, int len)\n{\n\t/* don't let the name of this function mislead you: it's just used\n\t   as an interface from the firmware to the i2c bus. The actual\n\t   i2c addresses are contained in the data */\n\tint ret, i, done = 0, fail = 0;\n\tu8 temp;\n\tret = af9005_usb_write_tuner_registers(d, reg, values, len);\n\tif (ret)\n\t\treturn ret;\n\tif (reg != 0xffff) {\n\t\t/* check if write done (0xa40d bit 1) or fail (0xa40d bit 2) */\n\t\tfor (i = 0; i < 200; i++) {\n\t\t\tret =\n\t\t\t    af9005_read_ofdm_register(d,\n\t\t\t\t\t\t      xd_I2C_i2c_m_status_wdat_done,\n\t\t\t\t\t\t      &temp);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tdone = temp & (regmask[i2c_m_status_wdat_done_len - 1]\n\t\t\t\t       << i2c_m_status_wdat_done_pos);\n\t\t\tif (done)\n\t\t\t\tbreak;\n\t\t\tfail = temp & (regmask[i2c_m_status_wdat_fail_len - 1]\n\t\t\t\t       << i2c_m_status_wdat_fail_pos);\n\t\t\tif (fail)\n\t\t\t\tbreak;\n\t\t\tmsleep(50);\n\t\t}\n\t\tif (i == 200)\n\t\t\treturn -ETIMEDOUT;\n\t\tif (fail) {\n\t\t\t/* clear write fail bit */\n\t\t\taf9005_write_register_bits(d,\n\t\t\t\t\t\t   xd_I2C_i2c_m_status_wdat_fail,\n\t\t\t\t\t\t   i2c_m_status_wdat_fail_pos,\n\t\t\t\t\t\t   i2c_m_status_wdat_fail_len,\n\t\t\t\t\t\t   1);\n\t\t\treturn -EIO;\n\t\t}\n\t\t/* clear write done bit */\n\t\tret =\n\t\t    af9005_write_register_bits(d,\n\t\t\t\t\t       xd_I2C_i2c_m_status_wdat_fail,\n\t\t\t\t\t       i2c_m_status_wdat_done_pos,\n\t\t\t\t\t       i2c_m_status_wdat_done_len, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nint af9005_read_tuner_registers(struct dvb_usb_device *d, u16 reg, u8 addr,\n\t\t\t\tu8 * values, int len)\n{\n\t/* don't let the name of this function mislead you: it's just used\n\t   as an interface from the firmware to the i2c bus. The actual\n\t   i2c addresses are contained in the data */\n\tint ret, i;\n\tu8 temp, buf[2];\n\n\tbuf[0] = addr;\t\t/* tuner i2c address */\n\tbuf[1] = values[0];\t/* tuner register */\n\n\tvalues[0] = addr + 0x01;\t/* i2c read address */\n\n\tif (reg == APO_REG_I2C_RW_SILICON_TUNER) {\n\t\t/* write tuner i2c address to tuner, 0c00c0 undocumented, found by sniffing */\n\t\tret = af9005_write_tuner_registers(d, 0x00c0, buf, 2);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* send read command to ofsm */\n\tret = af9005_usb_read_tuner_registers(d, reg, values, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/* check if read done */\n\tfor (i = 0; i < 200; i++) {\n\t\tret = af9005_read_ofdm_register(d, 0xa408, &temp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (temp & 0x01)\n\t\t\tbreak;\n\t\tmsleep(50);\n\t}\n\tif (i == 200)\n\t\treturn -ETIMEDOUT;\n\n\t/* clear read done bit (by writing 1) */\n\tret = af9005_write_ofdm_register(d, xd_I2C_i2c_m_data8, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/* get read data (available from 0xa400) */\n\tfor (i = 0; i < len; i++) {\n\t\tret = af9005_read_ofdm_register(d, 0xa400 + i, &temp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tvalues[i] = temp;\n\t}\n\treturn 0;\n}\n\nstatic int af9005_i2c_write(struct dvb_usb_device *d, u8 i2caddr, u8 reg,\n\t\t\t    u8 * data, int len)\n{\n\tint ret, i;\n\tu8 buf[3];\n\tdeb_i2c(\"i2c_write i2caddr %x, reg %x, len %d data \", i2caddr,\n\t\treg, len);\n\tdebug_dump(data, len, deb_i2c);\n\n\tfor (i = 0; i < len; i++) {\n\t\tbuf[0] = i2caddr;\n\t\tbuf[1] = reg + (u8) i;\n\t\tbuf[2] = data[i];\n\t\tret =\n\t\t    af9005_write_tuner_registers(d,\n\t\t\t\t\t\t APO_REG_I2C_RW_SILICON_TUNER,\n\t\t\t\t\t\t buf, 3);\n\t\tif (ret) {\n\t\t\tdeb_i2c(\"i2c_write failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tdeb_i2c(\"i2c_write ok\\n\");\n\treturn 0;\n}\n\nstatic int af9005_i2c_read(struct dvb_usb_device *d, u8 i2caddr, u8 reg,\n\t\t\t   u8 * data, int len)\n{\n\tint ret, i;\n\tu8 temp;\n\tdeb_i2c(\"i2c_read i2caddr %x, reg %x, len %d\\n \", i2caddr, reg, len);\n\tfor (i = 0; i < len; i++) {\n\t\ttemp = reg + i;\n\t\tret =\n\t\t    af9005_read_tuner_registers(d,\n\t\t\t\t\t\tAPO_REG_I2C_RW_SILICON_TUNER,\n\t\t\t\t\t\ti2caddr, &temp, 1);\n\t\tif (ret) {\n\t\t\tdeb_i2c(\"i2c_read failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tdata[i] = temp;\n\t}\n\tdeb_i2c(\"i2c data read: \");\n\tdebug_dump(data, len, deb_i2c);\n\treturn 0;\n}\n\nstatic int af9005_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\t\t\t   int num)\n{\n\t/* only implements what the mt2060 module does, don't know how\n\t   to make it really generic */\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tint ret;\n\tu8 reg, addr;\n\tu8 *value;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tif (num > 2)\n\t\twarn(\"more than 2 i2c messages at a time is not handled yet. TODO.\");\n\n\tif (num == 2) {\n\t\t/* reads a single register */\n\t\treg = *msg[0].buf;\n\t\taddr = msg[0].addr;\n\t\tvalue = msg[1].buf;\n\t\tret = af9005_i2c_read(d, addr, reg, value, 1);\n\t\tif (ret == 0)\n\t\t\tret = 2;\n\t} else {\n\t\t/* write one or more registers */\n\t\treg = msg[0].buf[0];\n\t\taddr = msg[0].addr;\n\t\tvalue = &msg[0].buf[1];\n\t\tret = af9005_i2c_write(d, addr, reg, value, msg[0].len - 1);\n\t\tif (ret == 0)\n\t\t\tret = 1;\n\t}\n\n\tmutex_unlock(&d->i2c_mutex);\n\treturn ret;\n}\n\nstatic u32 af9005_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm af9005_i2c_algo = {\n\t.master_xfer = af9005_i2c_xfer,\n\t.functionality = af9005_i2c_func,\n};\n\nint af9005_send_command(struct dvb_usb_device *d, u8 command, u8 * wbuf,\n\t\t\tint wlen, u8 * rbuf, int rlen)\n{\n\tstruct af9005_device_state *st = d->priv;\n\n\tint ret, i, packet_len;\n\tu8 seq;\n\n\tif (wlen < 0) {\n\t\terr(\"send command, wlen less than 0 bytes. Makes no sense.\");\n\t\treturn -EINVAL;\n\t}\n\tif (wlen > 54) {\n\t\terr(\"send command, wlen more than 54 bytes. Not supported.\");\n\t\treturn -EINVAL;\n\t}\n\tif (rlen > 54) {\n\t\terr(\"send command, rlen more than 54 bytes. Not supported.\");\n\t\treturn -EINVAL;\n\t}\n\tpacket_len = wlen + 5;\n\n\tmutex_lock(&d->data_mutex);\n\n\tst->data[0] = (u8) (packet_len & 0xff);\n\tst->data[1] = (u8) ((packet_len & 0xff00) >> 8);\n\n\tst->data[2] = 0x26;\t\t/* packet type */\n\tst->data[3] = wlen + 3;\n\tst->data[4] = seq = st->sequence++;\n\tst->data[5] = command;\n\tst->data[6] = wlen;\n\tfor (i = 0; i < wlen; i++)\n\t\tst->data[7 + i] = wbuf[i];\n\tret = dvb_usb_generic_rw(d, st->data, wlen + 7, st->data, rlen + 7, 0);\n\tif (st->data[2] != 0x27) {\n\t\terr(\"send command, wrong reply code.\");\n\t\tret = -EIO;\n\t} else if (st->data[4] != seq) {\n\t\terr(\"send command, wrong sequence in reply.\");\n\t\tret = -EIO;\n\t} else if (st->data[5] != 0x01) {\n\t\terr(\"send command, wrong status code in reply.\");\n\t\tret = -EIO;\n\t} else if (st->data[6] != rlen) {\n\t\terr(\"send command, invalid data length in reply.\");\n\t\tret = -EIO;\n\t}\n\tif (!ret) {\n\t\tfor (i = 0; i < rlen; i++)\n\t\t\trbuf[i] = st->data[i + 7];\n\t}\n\n\tmutex_unlock(&d->data_mutex);\n\treturn ret;\n}\n\nint af9005_read_eeprom(struct dvb_usb_device *d, u8 address, u8 * values,\n\t\t       int len)\n{\n\tstruct af9005_device_state *st = d->priv;\n\tu8 seq;\n\tint ret, i;\n\n\tmutex_lock(&d->data_mutex);\n\n\tmemset(st->data, 0, sizeof(st->data));\n\n\tst->data[0] = 14;\t\t/* length of rest of packet low */\n\tst->data[1] = 0;\t\t/* length of rest of packer high */\n\n\tst->data[2] = 0x2a;\t\t/* read/write eeprom */\n\n\tst->data[3] = 12;\t\t/* size */\n\n\tst->data[4] = seq = st->sequence++;\n\n\tst->data[5] = 0;\t\t/* read */\n\n\tst->data[6] = len;\n\tst->data[7] = address;\n\tret = dvb_usb_generic_rw(d, st->data, 16, st->data, 14, 0);\n\tif (st->data[2] != 0x2b) {\n\t\terr(\"Read eeprom, invalid reply code\");\n\t\tret = -EIO;\n\t} else if (st->data[3] != 10) {\n\t\terr(\"Read eeprom, invalid reply length\");\n\t\tret = -EIO;\n\t} else if (st->data[4] != seq) {\n\t\terr(\"Read eeprom, wrong sequence in reply \");\n\t\tret = -EIO;\n\t} else if (st->data[5] != 1) {\n\t\terr(\"Read eeprom, wrong status in reply \");\n\t\tret = -EIO;\n\t}\n\n\tif (!ret) {\n\t\tfor (i = 0; i < len; i++)\n\t\t\tvalues[i] = st->data[6 + i];\n\t}\n\tmutex_unlock(&d->data_mutex);\n\n\treturn ret;\n}\n\nstatic int af9005_boot_packet(struct usb_device *udev, int type, u8 *reply,\n\t\t\t      u8 *buf, int size)\n{\n\tu16 checksum;\n\tint act_len, i, ret;\n\n\tmemset(buf, 0, size);\n\tbuf[0] = (u8) (FW_BULKOUT_SIZE & 0xff);\n\tbuf[1] = (u8) ((FW_BULKOUT_SIZE >> 8) & 0xff);\n\tswitch (type) {\n\tcase FW_CONFIG:\n\t\tbuf[2] = 0x11;\n\t\tbuf[3] = 0x04;\n\t\tbuf[4] = 0x00;\t/* sequence number, original driver doesn't increment it here */\n\t\tbuf[5] = 0x03;\n\t\tchecksum = buf[4] + buf[5];\n\t\tbuf[6] = (u8) ((checksum >> 8) & 0xff);\n\t\tbuf[7] = (u8) (checksum & 0xff);\n\t\tbreak;\n\tcase FW_CONFIRM:\n\t\tbuf[2] = 0x11;\n\t\tbuf[3] = 0x04;\n\t\tbuf[4] = 0x00;\t/* sequence number, original driver doesn't increment it here */\n\t\tbuf[5] = 0x01;\n\t\tchecksum = buf[4] + buf[5];\n\t\tbuf[6] = (u8) ((checksum >> 8) & 0xff);\n\t\tbuf[7] = (u8) (checksum & 0xff);\n\t\tbreak;\n\tcase FW_BOOT:\n\t\tbuf[2] = 0x10;\n\t\tbuf[3] = 0x08;\n\t\tbuf[4] = 0x00;\t/* sequence number, original driver doesn't increment it here */\n\t\tbuf[5] = 0x97;\n\t\tbuf[6] = 0xaa;\n\t\tbuf[7] = 0x55;\n\t\tbuf[8] = 0xa5;\n\t\tbuf[9] = 0x5a;\n\t\tchecksum = 0;\n\t\tfor (i = 4; i <= 9; i++)\n\t\t\tchecksum += buf[i];\n\t\tbuf[10] = (u8) ((checksum >> 8) & 0xff);\n\t\tbuf[11] = (u8) (checksum & 0xff);\n\t\tbreak;\n\tdefault:\n\t\terr(\"boot packet invalid boot packet type\");\n\t\treturn -EINVAL;\n\t}\n\tdeb_fw(\">>> \");\n\tdebug_dump(buf, FW_BULKOUT_SIZE + 2, deb_fw);\n\n\tret = usb_bulk_msg(udev,\n\t\t\t   usb_sndbulkpipe(udev, 0x02),\n\t\t\t   buf, FW_BULKOUT_SIZE + 2, &act_len, 2000);\n\tif (ret)\n\t\terr(\"boot packet bulk message failed: %d (%d/%d)\", ret,\n\t\t    FW_BULKOUT_SIZE + 2, act_len);\n\telse\n\t\tret = act_len != FW_BULKOUT_SIZE + 2 ? -1 : 0;\n\tif (ret)\n\t\treturn ret;\n\tmemset(buf, 0, 9);\n\tret = usb_bulk_msg(udev,\n\t\t\t   usb_rcvbulkpipe(udev, 0x01), buf, 9, &act_len, 2000);\n\tif (ret) {\n\t\terr(\"boot packet recv bulk message failed: %d\", ret);\n\t\treturn ret;\n\t}\n\tdeb_fw(\"<<< \");\n\tdebug_dump(buf, act_len, deb_fw);\n\tchecksum = 0;\n\tswitch (type) {\n\tcase FW_CONFIG:\n\t\tif (buf[2] != 0x11) {\n\t\t\terr(\"boot bad config header.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (buf[3] != 0x05) {\n\t\t\terr(\"boot bad config size.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (buf[4] != 0x00) {\n\t\t\terr(\"boot bad config sequence.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (buf[5] != 0x04) {\n\t\t\terr(\"boot bad config subtype.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tfor (i = 4; i <= 6; i++)\n\t\t\tchecksum += buf[i];\n\t\tif (buf[7] * 256 + buf[8] != checksum) {\n\t\t\terr(\"boot bad config checksum.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\t*reply = buf[6];\n\t\tbreak;\n\tcase FW_CONFIRM:\n\t\tif (buf[2] != 0x11) {\n\t\t\terr(\"boot bad confirm header.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (buf[3] != 0x05) {\n\t\t\terr(\"boot bad confirm size.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (buf[4] != 0x00) {\n\t\t\terr(\"boot bad confirm sequence.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (buf[5] != 0x02) {\n\t\t\terr(\"boot bad confirm subtype.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tfor (i = 4; i <= 6; i++)\n\t\t\tchecksum += buf[i];\n\t\tif (buf[7] * 256 + buf[8] != checksum) {\n\t\t\terr(\"boot bad confirm checksum.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\t*reply = buf[6];\n\t\tbreak;\n\tcase FW_BOOT:\n\t\tif (buf[2] != 0x10) {\n\t\t\terr(\"boot bad boot header.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (buf[3] != 0x05) {\n\t\t\terr(\"boot bad boot size.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (buf[4] != 0x00) {\n\t\t\terr(\"boot bad boot sequence.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (buf[5] != 0x01) {\n\t\t\terr(\"boot bad boot pattern 01.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (buf[6] != 0x10) {\n\t\t\terr(\"boot bad boot pattern 10.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tfor (i = 4; i <= 6; i++)\n\t\t\tchecksum += buf[i];\n\t\tif (buf[7] * 256 + buf[8] != checksum) {\n\t\t\terr(\"boot bad boot checksum.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tbreak;\n\n\t}\n\n\treturn 0;\n}\n\nstatic int af9005_download_firmware(struct usb_device *udev, const struct firmware *fw)\n{\n\tint i, packets, ret, act_len;\n\n\tu8 *buf;\n\tu8 reply;\n\n\tbuf = kmalloc(FW_BULKOUT_SIZE + 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = af9005_boot_packet(udev, FW_CONFIG, &reply, buf,\n\t\t\t\t FW_BULKOUT_SIZE + 2);\n\tif (ret)\n\t\tgoto err;\n\tif (reply != 0x01) {\n\t\terr(\"before downloading firmware, FW_CONFIG expected 0x01, received 0x%x\", reply);\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\tpackets = fw->size / FW_BULKOUT_SIZE;\n\tbuf[0] = (u8) (FW_BULKOUT_SIZE & 0xff);\n\tbuf[1] = (u8) ((FW_BULKOUT_SIZE >> 8) & 0xff);\n\tfor (i = 0; i < packets; i++) {\n\t\tmemcpy(&buf[2], fw->data + i * FW_BULKOUT_SIZE,\n\t\t       FW_BULKOUT_SIZE);\n\t\tdeb_fw(\">>> \");\n\t\tdebug_dump(buf, FW_BULKOUT_SIZE + 2, deb_fw);\n\t\tret = usb_bulk_msg(udev,\n\t\t\t\t   usb_sndbulkpipe(udev, 0x02),\n\t\t\t\t   buf, FW_BULKOUT_SIZE + 2, &act_len, 1000);\n\t\tif (ret) {\n\t\t\terr(\"firmware download failed at packet %d with code %d\", i, ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tret = af9005_boot_packet(udev, FW_CONFIRM, &reply,\n\t\t\t\t buf, FW_BULKOUT_SIZE + 2);\n\tif (ret)\n\t\tgoto err;\n\tif (reply != (u8) (packets & 0xff)) {\n\t\terr(\"after downloading firmware, FW_CONFIRM expected 0x%x, received 0x%x\", packets & 0xff, reply);\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\tret = af9005_boot_packet(udev, FW_BOOT, &reply, buf,\n\t\t\t\t FW_BULKOUT_SIZE + 2);\n\tif (ret)\n\t\tgoto err;\n\tret = af9005_boot_packet(udev, FW_CONFIG, &reply, buf,\n\t\t\t\t FW_BULKOUT_SIZE + 2);\n\tif (ret)\n\t\tgoto err;\n\tif (reply != 0x02) {\n\t\terr(\"after downloading firmware, FW_CONFIG expected 0x02, received 0x%x\", reply);\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\nerr:\n\tkfree(buf);\n\treturn ret;\n\n}\n\nint af9005_led_control(struct dvb_usb_device *d, int onoff)\n{\n\tstruct af9005_device_state *st = d->priv;\n\tint temp, ret;\n\n\tif (onoff && dvb_usb_af9005_led)\n\t\ttemp = 1;\n\telse\n\t\ttemp = 0;\n\tif (st->led_state != temp) {\n\t\tret =\n\t\t    af9005_write_register_bits(d, xd_p_reg_top_locken1,\n\t\t\t\t\t       reg_top_locken1_pos,\n\t\t\t\t\t       reg_top_locken1_len, temp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret =\n\t\t    af9005_write_register_bits(d, xd_p_reg_top_lock1,\n\t\t\t\t\t       reg_top_lock1_pos,\n\t\t\t\t\t       reg_top_lock1_len, temp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tst->led_state = temp;\n\t}\n\treturn 0;\n}\n\nstatic int af9005_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tu8 buf[8];\n\tint i;\n\n\t/* without these calls the first commands after downloading\n\t   the firmware fail. I put these calls here to simulate\n\t   what it is done in dvb-usb-init.c.\n\t */\n\tstruct usb_device *udev = adap->dev->udev;\n\tusb_clear_halt(udev, usb_sndbulkpipe(udev, 2));\n\tusb_clear_halt(udev, usb_rcvbulkpipe(udev, 1));\n\tif (dvb_usb_af9005_dump_eeprom) {\n\t\tprintk(\"EEPROM DUMP\\n\");\n\t\tfor (i = 0; i < 255; i += 8) {\n\t\t\taf9005_read_eeprom(adap->dev, i, buf, 8);\n\t\t\tdebug_dump(buf, 8, printk);\n\t\t}\n\t}\n\tadap->fe_adap[0].fe = af9005_fe_attach(adap->dev);\n\treturn 0;\n}\n\nstatic int af9005_rc_query(struct dvb_usb_device *d, u32 * event, int *state)\n{\n\tstruct af9005_device_state *st = d->priv;\n\tint ret, len;\n\tu8 seq;\n\n\t*state = REMOTE_NO_KEY_PRESSED;\n\tif (rc_decode == NULL) {\n\t\t/* it shouldn't never come here */\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&d->data_mutex);\n\n\t/* deb_info(\"rc_query\\n\"); */\n\tst->data[0] = 3;\t\t/* rest of packet length low */\n\tst->data[1] = 0;\t\t/* rest of packet length high */\n\tst->data[2] = 0x40;\t\t/* read remote */\n\tst->data[3] = 1;\t\t/* rest of packet length */\n\tst->data[4] = seq = st->sequence++;\t/* sequence number */\n\tret = dvb_usb_generic_rw(d, st->data, 5, st->data, 256, 0);\n\tif (ret) {\n\t\terr(\"rc query failed\");\n\t\tgoto ret;\n\t}\n\tif (st->data[2] != 0x41) {\n\t\terr(\"rc query bad header.\");\n\t\tret = -EIO;\n\t\tgoto ret;\n\t} else if (st->data[4] != seq) {\n\t\terr(\"rc query bad sequence.\");\n\t\tret = -EIO;\n\t\tgoto ret;\n\t}\n\tlen = st->data[5];\n\tif (len > 246) {\n\t\terr(\"rc query invalid length\");\n\t\tret = -EIO;\n\t\tgoto ret;\n\t}\n\tif (len > 0) {\n\t\tdeb_rc(\"rc data (%d) \", len);\n\t\tdebug_dump((st->data + 6), len, deb_rc);\n\t\tret = rc_decode(d, &st->data[6], len, event, state);\n\t\tif (ret) {\n\t\t\terr(\"rc_decode failed\");\n\t\t\tgoto ret;\n\t\t} else {\n\t\t\tdeb_rc(\"rc_decode state %x event %x\\n\", *state, *event);\n\t\t\tif (*state == REMOTE_KEY_REPEAT)\n\t\t\t\t*event = d->last_event;\n\t\t}\n\t}\n\nret:\n\tmutex_unlock(&d->data_mutex);\n\treturn ret;\n}\n\nstatic int af9005_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\n\treturn 0;\n}\n\nstatic int af9005_pid_filter_control(struct dvb_usb_adapter *adap, int onoff)\n{\n\tint ret;\n\tdeb_info(\"pid filter control  onoff %d\\n\", onoff);\n\tif (onoff) {\n\t\tret =\n\t\t    af9005_write_ofdm_register(adap->dev, XD_MP2IF_DMX_CTRL, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret =\n\t\t    af9005_write_register_bits(adap->dev,\n\t\t\t\t\t       XD_MP2IF_DMX_CTRL, 1, 1, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret =\n\t\t    af9005_write_ofdm_register(adap->dev, XD_MP2IF_DMX_CTRL, 1);\n\t} else\n\t\tret =\n\t\t    af9005_write_ofdm_register(adap->dev, XD_MP2IF_DMX_CTRL, 0);\n\tif (ret)\n\t\treturn ret;\n\tdeb_info(\"pid filter control ok\\n\");\n\treturn 0;\n}\n\nstatic int af9005_pid_filter(struct dvb_usb_adapter *adap, int index,\n\t\t\t     u16 pid, int onoff)\n{\n\tu8 cmd = index & 0x1f;\n\tint ret;\n\tdeb_info(\"set pid filter, index %d, pid %x, onoff %d\\n\", index,\n\t\t pid, onoff);\n\tif (onoff) {\n\t\t/* cannot use it as pid_filter_ctrl since it has to be done\n\t\t   before setting the first pid */\n\t\tif (adap->feedcount == 1) {\n\t\t\tdeb_info(\"first pid set, enable pid table\\n\");\n\t\t\tret = af9005_pid_filter_control(adap, onoff);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tret =\n\t\t    af9005_write_ofdm_register(adap->dev,\n\t\t\t\t\t       XD_MP2IF_PID_DATA_L,\n\t\t\t\t\t       (u8) (pid & 0xff));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret =\n\t\t    af9005_write_ofdm_register(adap->dev,\n\t\t\t\t\t       XD_MP2IF_PID_DATA_H,\n\t\t\t\t\t       (u8) (pid >> 8));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcmd |= 0x20 | 0x40;\n\t} else {\n\t\tif (adap->feedcount == 0) {\n\t\t\tdeb_info(\"last pid unset, disable pid table\\n\");\n\t\t\tret = af9005_pid_filter_control(adap, onoff);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\tret = af9005_write_ofdm_register(adap->dev, XD_MP2IF_PID_IDX, cmd);\n\tif (ret)\n\t\treturn ret;\n\tdeb_info(\"set pid ok\\n\");\n\treturn 0;\n}\n\nstatic int af9005_identify_state(struct usb_device *udev,\n\t\t\t\t struct dvb_usb_device_properties *props,\n\t\t\t\t struct dvb_usb_device_description **desc,\n\t\t\t\t int *cold)\n{\n\tint ret;\n\tu8 reply, *buf;\n\n\tbuf = kmalloc(FW_BULKOUT_SIZE + 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = af9005_boot_packet(udev, FW_CONFIG, &reply,\n\t\t\t\t buf, FW_BULKOUT_SIZE + 2);\n\tif (ret)\n\t\tgoto err;\n\tdeb_info(\"result of FW_CONFIG in identify state %d\\n\", reply);\n\tif (reply == 0x01)\n\t\t*cold = 1;\n\telse if (reply == 0x02)\n\t\t*cold = 0;\n\telse\n\t\treturn -EIO;\n\tdeb_info(\"Identify state cold = %d\\n\", *cold);\n\nerr:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic struct dvb_usb_device_properties af9005_properties;\n\nstatic int af9005_usb_probe(struct usb_interface *intf,\n\t\t\t    const struct usb_device_id *id)\n{\n\treturn dvb_usb_device_init(intf, &af9005_properties,\n\t\t\t\t  THIS_MODULE, NULL, adapter_nr);\n}\n\nenum af9005_usb_table_entry {\n\tAFATECH_AF9005,\n\tTERRATEC_AF9005,\n\tANSONIC_AF9005,\n};\n\nstatic struct usb_device_id af9005_usb_table[] = {\n\t[AFATECH_AF9005] = {USB_DEVICE(USB_VID_AFATECH,\n\t\t\t\tUSB_PID_AFATECH_AF9005)},\n\t[TERRATEC_AF9005] = {USB_DEVICE(USB_VID_TERRATEC,\n\t\t\t\tUSB_PID_TERRATEC_CINERGY_T_USB_XE)},\n\t[ANSONIC_AF9005] = {USB_DEVICE(USB_VID_ANSONIC,\n\t\t\t\tUSB_PID_ANSONIC_DVBT_USB)},\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, af9005_usb_table);\n\nstatic struct dvb_usb_device_properties af9005_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl = DEVICE_SPECIFIC,\n\t.firmware = \"af9005.fw\",\n\t.download_firmware = af9005_download_firmware,\n\t.no_reconnect = 1,\n\n\t.size_of_priv = sizeof(struct af9005_device_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t    {\n\t\t    .num_frontends = 1,\n\t\t    .fe = {{\n\t\t     .caps =\n\t\t     DVB_USB_ADAP_HAS_PID_FILTER |\n\t\t     DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t     .pid_filter_count = 32,\n\t\t     .pid_filter = af9005_pid_filter,\n\t\t     /* .pid_filter_ctrl = af9005_pid_filter_control, */\n\t\t     .frontend_attach = af9005_frontend_attach,\n\t\t     /* .tuner_attach     = af9005_tuner_attach, */\n\t\t     /* parameter for the MPEG2-data transfer */\n\t\t     .stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 10,\n\t\t\t\t.endpoint = 0x04,\n\t\t\t\t.u = {\n\t\t\t\t      .bulk = {\n\t\t\t\t\t       .buffersize = 4096,\t/* actual size seen is 3948 */\n\t\t\t\t\t       }\n\t\t\t\t      }\n\t\t\t\t},\n\t\t     }},\n\t\t     }\n\t\t    },\n\t.power_ctrl = af9005_power_ctrl,\n\t.identify_state = af9005_identify_state,\n\n\t.i2c_algo = &af9005_i2c_algo,\n\n\t.rc.legacy = {\n\t\t.rc_interval = 200,\n\t\t.rc_map_table = NULL,\n\t\t.rc_map_size = 0,\n\t\t.rc_query = af9005_rc_query,\n\t},\n\n\t.generic_bulk_ctrl_endpoint          = 2,\n\t.generic_bulk_ctrl_endpoint_response = 1,\n\n\t.num_device_descs = 3,\n\t.devices = {\n\t\t    {.name = \"Afatech DVB-T USB1.1 stick\",\n\t\t     .cold_ids = {&af9005_usb_table[AFATECH_AF9005], NULL},\n\t\t     .warm_ids = {NULL},\n\t\t     },\n\t\t    {.name = \"TerraTec Cinergy T USB XE\",\n\t\t     .cold_ids = {&af9005_usb_table[TERRATEC_AF9005], NULL},\n\t\t     .warm_ids = {NULL},\n\t\t     },\n\t\t    {.name = \"Ansonic DVB-T USB1.1 stick\",\n\t\t     .cold_ids = {&af9005_usb_table[ANSONIC_AF9005], NULL},\n\t\t     .warm_ids = {NULL},\n\t\t     },\n\t\t    {NULL},\n\t\t    }\n};\n\n/* usb specific object needed to register this driver with the usb subsystem */\nstatic struct usb_driver af9005_usb_driver = {\n\t.name = \"dvb_usb_af9005\",\n\t.probe = af9005_usb_probe,\n\t.disconnect = dvb_usb_device_exit,\n\t.id_table = af9005_usb_table,\n};\n\n/* module stuff */\nstatic int __init af9005_usb_module_init(void)\n{\n\tint result;\n\tif ((result = usb_register(&af9005_usb_driver))) {\n\t\terr(\"usb_register failed. (%d)\", result);\n\t\treturn result;\n\t}\n#if IS_MODULE(CONFIG_DVB_USB_AF9005) || defined(CONFIG_DVB_USB_AF9005_REMOTE)\n\t/* FIXME: convert to todays kernel IR infrastructure */\n\trc_decode = symbol_request(af9005_rc_decode);\n\trc_keys = symbol_request(rc_map_af9005_table);\n\trc_keys_size = symbol_request(rc_map_af9005_table_size);\n#endif\n\tif (rc_decode == NULL || rc_keys == NULL || rc_keys_size == NULL) {\n\t\terr(\"af9005_rc_decode function not found, disabling remote\");\n\t\taf9005_properties.rc.legacy.rc_query = NULL;\n\t} else {\n\t\taf9005_properties.rc.legacy.rc_map_table = rc_keys;\n\t\taf9005_properties.rc.legacy.rc_map_size = *rc_keys_size;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit af9005_usb_module_exit(void)\n{\n\t/* release rc decode symbols */\n\tif (rc_decode != NULL)\n\t\tsymbol_put(af9005_rc_decode);\n\tif (rc_keys != NULL)\n\t\tsymbol_put(rc_map_af9005_table);\n\tif (rc_keys_size != NULL)\n\t\tsymbol_put(rc_map_af9005_table_size);\n\t/* deregister this driver from the USB subsystem */\n\tusb_deregister(&af9005_usb_driver);\n}\n\nmodule_init(af9005_usb_module_init);\nmodule_exit(af9005_usb_module_exit);\n\nMODULE_AUTHOR(\"Luca Olivetti <luca@ventoso.org>\");\nMODULE_DESCRIPTION(\"Driver for Afatech 9005 DVB-T USB1.1 stick\");\nMODULE_VERSION(\"1.0\");\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/* DVB USB compliant Linux driver for the Afatech 9005\n * USB1.1 DVB-T receiver.\n *\n * Copyright (C) 2007 Luca Olivetti (luca@ventoso.org)\n *\n * Thanks to Afatech who kindly provided information.\n *\n * see Documentation/media/dvb-drivers/dvb-usb.rst for more information\n */\n#include \"af9005.h\"\n\n/* debug */\nint dvb_usb_af9005_debug;\nmodule_param_named(debug, dvb_usb_af9005_debug, int, 0644);\nMODULE_PARM_DESC(debug,\n\t\t \"set debugging level (1=info,xfer=2,rc=4,reg=8,i2c=16,fw=32 (or-able)).\"\n\t\t DVB_USB_DEBUG_STATUS);\n/* enable obnoxious led */\nbool dvb_usb_af9005_led = true;\nmodule_param_named(led, dvb_usb_af9005_led, bool, 0644);\nMODULE_PARM_DESC(led, \"enable led (default: 1).\");\n\n/* eeprom dump */\nstatic int dvb_usb_af9005_dump_eeprom;\nmodule_param_named(dump_eeprom, dvb_usb_af9005_dump_eeprom, int, 0);\nMODULE_PARM_DESC(dump_eeprom, \"dump contents of the eeprom.\");\n\nDVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);\n\n/* remote control decoder */\nstatic int (*rc_decode) (struct dvb_usb_device *d, u8 *data, int len,\n\t\tu32 *event, int *state);\nstatic void *rc_keys;\nstatic int *rc_keys_size;\n\nu8 regmask[8] = { 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff };\n\nstruct af9005_device_state {\n\tu8 sequence;\n\tint led_state;\n\tunsigned char data[256];\n};\n\nstatic int af9005_generic_read_write(struct dvb_usb_device *d, u16 reg,\n\t\t\t      int readwrite, int type, u8 * values, int len)\n{\n\tstruct af9005_device_state *st = d->priv;\n\tu8 command, seq;\n\tint i, ret;\n\n\tif (len < 1) {\n\t\terr(\"generic read/write, less than 1 byte. Makes no sense.\");\n\t\treturn -EINVAL;\n\t}\n\tif (len > 8) {\n\t\terr(\"generic read/write, more than 8 bytes. Not supported.\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&d->data_mutex);\n\tst->data[0] = 14;\t\t/* rest of buffer length low */\n\tst->data[1] = 0;\t\t/* rest of buffer length high */\n\n\tst->data[2] = AF9005_REGISTER_RW;\t/* register operation */\n\tst->data[3] = 12;\t\t/* rest of buffer length */\n\n\tst->data[4] = seq = st->sequence++;\t/* sequence number */\n\n\tst->data[5] = (u8) (reg >> 8);\t/* register address */\n\tst->data[6] = (u8) (reg & 0xff);\n\n\tif (type == AF9005_OFDM_REG) {\n\t\tcommand = AF9005_CMD_OFDM_REG;\n\t} else {\n\t\tcommand = AF9005_CMD_TUNER;\n\t}\n\n\tif (len > 1)\n\t\tcommand |=\n\t\t    AF9005_CMD_BURST | AF9005_CMD_AUTOINC | (len - 1) << 3;\n\tcommand |= readwrite;\n\tif (readwrite == AF9005_CMD_WRITE)\n\t\tfor (i = 0; i < len; i++)\n\t\t\tst->data[8 + i] = values[i];\n\telse if (type == AF9005_TUNER_REG)\n\t\t/* read command for tuner, the first byte contains the i2c address */\n\t\tst->data[8] = values[0];\n\tst->data[7] = command;\n\n\tret = dvb_usb_generic_rw(d, st->data, 16, st->data, 17, 0);\n\tif (ret)\n\t\tgoto ret;\n\n\t/* sanity check */\n\tif (st->data[2] != AF9005_REGISTER_RW_ACK) {\n\t\terr(\"generic read/write, wrong reply code.\");\n\t\tret = -EIO;\n\t\tgoto ret;\n\t}\n\tif (st->data[3] != 0x0d) {\n\t\terr(\"generic read/write, wrong length in reply.\");\n\t\tret = -EIO;\n\t\tgoto ret;\n\t}\n\tif (st->data[4] != seq) {\n\t\terr(\"generic read/write, wrong sequence in reply.\");\n\t\tret = -EIO;\n\t\tgoto ret;\n\t}\n\t/*\n\t * In thesis, both input and output buffers should have\n\t * identical values for st->data[5] to st->data[8].\n\t * However, windows driver doesn't check these fields, in fact\n\t * sometimes the register in the reply is different that what\n\t * has been sent\n\t */\n\tif (st->data[16] != 0x01) {\n\t\terr(\"generic read/write wrong status code in reply.\");\n\t\tret = -EIO;\n\t\tgoto ret;\n\t}\n\n\tif (readwrite == AF9005_CMD_READ)\n\t\tfor (i = 0; i < len; i++)\n\t\t\tvalues[i] = st->data[8 + i];\n\nret:\n\tmutex_unlock(&d->data_mutex);\n\treturn ret;\n\n}\n\nint af9005_read_ofdm_register(struct dvb_usb_device *d, u16 reg, u8 * value)\n{\n\tint ret;\n\tdeb_reg(\"read register %x \", reg);\n\tret = af9005_generic_read_write(d, reg,\n\t\t\t\t\tAF9005_CMD_READ, AF9005_OFDM_REG,\n\t\t\t\t\tvalue, 1);\n\tif (ret)\n\t\tdeb_reg(\"failed\\n\");\n\telse\n\t\tdeb_reg(\"value %x\\n\", *value);\n\treturn ret;\n}\n\nint af9005_read_ofdm_registers(struct dvb_usb_device *d, u16 reg,\n\t\t\t       u8 * values, int len)\n{\n\tint ret;\n\tdeb_reg(\"read %d registers %x \", len, reg);\n\tret = af9005_generic_read_write(d, reg,\n\t\t\t\t\tAF9005_CMD_READ, AF9005_OFDM_REG,\n\t\t\t\t\tvalues, len);\n\tif (ret)\n\t\tdeb_reg(\"failed\\n\");\n\telse\n\t\tdebug_dump(values, len, deb_reg);\n\treturn ret;\n}\n\nint af9005_write_ofdm_register(struct dvb_usb_device *d, u16 reg, u8 value)\n{\n\tint ret;\n\tu8 temp = value;\n\tdeb_reg(\"write register %x value %x \", reg, value);\n\tret = af9005_generic_read_write(d, reg,\n\t\t\t\t\tAF9005_CMD_WRITE, AF9005_OFDM_REG,\n\t\t\t\t\t&temp, 1);\n\tif (ret)\n\t\tdeb_reg(\"failed\\n\");\n\telse\n\t\tdeb_reg(\"ok\\n\");\n\treturn ret;\n}\n\nint af9005_write_ofdm_registers(struct dvb_usb_device *d, u16 reg,\n\t\t\t\tu8 * values, int len)\n{\n\tint ret;\n\tdeb_reg(\"write %d registers %x values \", len, reg);\n\tdebug_dump(values, len, deb_reg);\n\n\tret = af9005_generic_read_write(d, reg,\n\t\t\t\t\tAF9005_CMD_WRITE, AF9005_OFDM_REG,\n\t\t\t\t\tvalues, len);\n\tif (ret)\n\t\tdeb_reg(\"failed\\n\");\n\telse\n\t\tdeb_reg(\"ok\\n\");\n\treturn ret;\n}\n\nint af9005_read_register_bits(struct dvb_usb_device *d, u16 reg, u8 pos,\n\t\t\t      u8 len, u8 * value)\n{\n\tu8 temp;\n\tint ret;\n\tdeb_reg(\"read bits %x %x %x\", reg, pos, len);\n\tret = af9005_read_ofdm_register(d, reg, &temp);\n\tif (ret) {\n\t\tdeb_reg(\" failed\\n\");\n\t\treturn ret;\n\t}\n\t*value = (temp >> pos) & regmask[len - 1];\n\tdeb_reg(\" value %x\\n\", *value);\n\treturn 0;\n\n}\n\nint af9005_write_register_bits(struct dvb_usb_device *d, u16 reg, u8 pos,\n\t\t\t       u8 len, u8 value)\n{\n\tu8 temp, mask;\n\tint ret;\n\tdeb_reg(\"write bits %x %x %x value %x\\n\", reg, pos, len, value);\n\tif (pos == 0 && len == 8)\n\t\treturn af9005_write_ofdm_register(d, reg, value);\n\tret = af9005_read_ofdm_register(d, reg, &temp);\n\tif (ret)\n\t\treturn ret;\n\tmask = regmask[len - 1] << pos;\n\ttemp = (temp & ~mask) | ((value << pos) & mask);\n\treturn af9005_write_ofdm_register(d, reg, temp);\n\n}\n\nstatic int af9005_usb_read_tuner_registers(struct dvb_usb_device *d,\n\t\t\t\t\t   u16 reg, u8 * values, int len)\n{\n\treturn af9005_generic_read_write(d, reg,\n\t\t\t\t\t AF9005_CMD_READ, AF9005_TUNER_REG,\n\t\t\t\t\t values, len);\n}\n\nstatic int af9005_usb_write_tuner_registers(struct dvb_usb_device *d,\n\t\t\t\t\t    u16 reg, u8 * values, int len)\n{\n\treturn af9005_generic_read_write(d, reg,\n\t\t\t\t\t AF9005_CMD_WRITE,\n\t\t\t\t\t AF9005_TUNER_REG, values, len);\n}\n\nint af9005_write_tuner_registers(struct dvb_usb_device *d, u16 reg,\n\t\t\t\t u8 * values, int len)\n{\n\t/* don't let the name of this function mislead you: it's just used\n\t   as an interface from the firmware to the i2c bus. The actual\n\t   i2c addresses are contained in the data */\n\tint ret, i, done = 0, fail = 0;\n\tu8 temp;\n\tret = af9005_usb_write_tuner_registers(d, reg, values, len);\n\tif (ret)\n\t\treturn ret;\n\tif (reg != 0xffff) {\n\t\t/* check if write done (0xa40d bit 1) or fail (0xa40d bit 2) */\n\t\tfor (i = 0; i < 200; i++) {\n\t\t\tret =\n\t\t\t    af9005_read_ofdm_register(d,\n\t\t\t\t\t\t      xd_I2C_i2c_m_status_wdat_done,\n\t\t\t\t\t\t      &temp);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tdone = temp & (regmask[i2c_m_status_wdat_done_len - 1]\n\t\t\t\t       << i2c_m_status_wdat_done_pos);\n\t\t\tif (done)\n\t\t\t\tbreak;\n\t\t\tfail = temp & (regmask[i2c_m_status_wdat_fail_len - 1]\n\t\t\t\t       << i2c_m_status_wdat_fail_pos);\n\t\t\tif (fail)\n\t\t\t\tbreak;\n\t\t\tmsleep(50);\n\t\t}\n\t\tif (i == 200)\n\t\t\treturn -ETIMEDOUT;\n\t\tif (fail) {\n\t\t\t/* clear write fail bit */\n\t\t\taf9005_write_register_bits(d,\n\t\t\t\t\t\t   xd_I2C_i2c_m_status_wdat_fail,\n\t\t\t\t\t\t   i2c_m_status_wdat_fail_pos,\n\t\t\t\t\t\t   i2c_m_status_wdat_fail_len,\n\t\t\t\t\t\t   1);\n\t\t\treturn -EIO;\n\t\t}\n\t\t/* clear write done bit */\n\t\tret =\n\t\t    af9005_write_register_bits(d,\n\t\t\t\t\t       xd_I2C_i2c_m_status_wdat_fail,\n\t\t\t\t\t       i2c_m_status_wdat_done_pos,\n\t\t\t\t\t       i2c_m_status_wdat_done_len, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nint af9005_read_tuner_registers(struct dvb_usb_device *d, u16 reg, u8 addr,\n\t\t\t\tu8 * values, int len)\n{\n\t/* don't let the name of this function mislead you: it's just used\n\t   as an interface from the firmware to the i2c bus. The actual\n\t   i2c addresses are contained in the data */\n\tint ret, i;\n\tu8 temp, buf[2];\n\n\tbuf[0] = addr;\t\t/* tuner i2c address */\n\tbuf[1] = values[0];\t/* tuner register */\n\n\tvalues[0] = addr + 0x01;\t/* i2c read address */\n\n\tif (reg == APO_REG_I2C_RW_SILICON_TUNER) {\n\t\t/* write tuner i2c address to tuner, 0c00c0 undocumented, found by sniffing */\n\t\tret = af9005_write_tuner_registers(d, 0x00c0, buf, 2);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* send read command to ofsm */\n\tret = af9005_usb_read_tuner_registers(d, reg, values, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/* check if read done */\n\tfor (i = 0; i < 200; i++) {\n\t\tret = af9005_read_ofdm_register(d, 0xa408, &temp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (temp & 0x01)\n\t\t\tbreak;\n\t\tmsleep(50);\n\t}\n\tif (i == 200)\n\t\treturn -ETIMEDOUT;\n\n\t/* clear read done bit (by writing 1) */\n\tret = af9005_write_ofdm_register(d, xd_I2C_i2c_m_data8, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/* get read data (available from 0xa400) */\n\tfor (i = 0; i < len; i++) {\n\t\tret = af9005_read_ofdm_register(d, 0xa400 + i, &temp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tvalues[i] = temp;\n\t}\n\treturn 0;\n}\n\nstatic int af9005_i2c_write(struct dvb_usb_device *d, u8 i2caddr, u8 reg,\n\t\t\t    u8 * data, int len)\n{\n\tint ret, i;\n\tu8 buf[3];\n\tdeb_i2c(\"i2c_write i2caddr %x, reg %x, len %d data \", i2caddr,\n\t\treg, len);\n\tdebug_dump(data, len, deb_i2c);\n\n\tfor (i = 0; i < len; i++) {\n\t\tbuf[0] = i2caddr;\n\t\tbuf[1] = reg + (u8) i;\n\t\tbuf[2] = data[i];\n\t\tret =\n\t\t    af9005_write_tuner_registers(d,\n\t\t\t\t\t\t APO_REG_I2C_RW_SILICON_TUNER,\n\t\t\t\t\t\t buf, 3);\n\t\tif (ret) {\n\t\t\tdeb_i2c(\"i2c_write failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tdeb_i2c(\"i2c_write ok\\n\");\n\treturn 0;\n}\n\nstatic int af9005_i2c_read(struct dvb_usb_device *d, u8 i2caddr, u8 reg,\n\t\t\t   u8 * data, int len)\n{\n\tint ret, i;\n\tu8 temp;\n\tdeb_i2c(\"i2c_read i2caddr %x, reg %x, len %d\\n \", i2caddr, reg, len);\n\tfor (i = 0; i < len; i++) {\n\t\ttemp = reg + i;\n\t\tret =\n\t\t    af9005_read_tuner_registers(d,\n\t\t\t\t\t\tAPO_REG_I2C_RW_SILICON_TUNER,\n\t\t\t\t\t\ti2caddr, &temp, 1);\n\t\tif (ret) {\n\t\t\tdeb_i2c(\"i2c_read failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tdata[i] = temp;\n\t}\n\tdeb_i2c(\"i2c data read: \");\n\tdebug_dump(data, len, deb_i2c);\n\treturn 0;\n}\n\nstatic int af9005_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\n\t\t\t   int num)\n{\n\t/* only implements what the mt2060 module does, don't know how\n\t   to make it really generic */\n\tstruct dvb_usb_device *d = i2c_get_adapdata(adap);\n\tint ret;\n\tu8 reg, addr;\n\tu8 *value;\n\n\tif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\n\t\treturn -EAGAIN;\n\n\tif (num > 2)\n\t\twarn(\"more than 2 i2c messages at a time is not handled yet. TODO.\");\n\n\tif (num == 2) {\n\t\t/* reads a single register */\n\t\treg = *msg[0].buf;\n\t\taddr = msg[0].addr;\n\t\tvalue = msg[1].buf;\n\t\tret = af9005_i2c_read(d, addr, reg, value, 1);\n\t\tif (ret == 0)\n\t\t\tret = 2;\n\t} else {\n\t\t/* write one or more registers */\n\t\treg = msg[0].buf[0];\n\t\taddr = msg[0].addr;\n\t\tvalue = &msg[0].buf[1];\n\t\tret = af9005_i2c_write(d, addr, reg, value, msg[0].len - 1);\n\t\tif (ret == 0)\n\t\t\tret = 1;\n\t}\n\n\tmutex_unlock(&d->i2c_mutex);\n\treturn ret;\n}\n\nstatic u32 af9005_i2c_func(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C;\n}\n\nstatic struct i2c_algorithm af9005_i2c_algo = {\n\t.master_xfer = af9005_i2c_xfer,\n\t.functionality = af9005_i2c_func,\n};\n\nint af9005_send_command(struct dvb_usb_device *d, u8 command, u8 * wbuf,\n\t\t\tint wlen, u8 * rbuf, int rlen)\n{\n\tstruct af9005_device_state *st = d->priv;\n\n\tint ret, i, packet_len;\n\tu8 seq;\n\n\tif (wlen < 0) {\n\t\terr(\"send command, wlen less than 0 bytes. Makes no sense.\");\n\t\treturn -EINVAL;\n\t}\n\tif (wlen > 54) {\n\t\terr(\"send command, wlen more than 54 bytes. Not supported.\");\n\t\treturn -EINVAL;\n\t}\n\tif (rlen > 54) {\n\t\terr(\"send command, rlen more than 54 bytes. Not supported.\");\n\t\treturn -EINVAL;\n\t}\n\tpacket_len = wlen + 5;\n\n\tmutex_lock(&d->data_mutex);\n\n\tst->data[0] = (u8) (packet_len & 0xff);\n\tst->data[1] = (u8) ((packet_len & 0xff00) >> 8);\n\n\tst->data[2] = 0x26;\t\t/* packet type */\n\tst->data[3] = wlen + 3;\n\tst->data[4] = seq = st->sequence++;\n\tst->data[5] = command;\n\tst->data[6] = wlen;\n\tfor (i = 0; i < wlen; i++)\n\t\tst->data[7 + i] = wbuf[i];\n\tret = dvb_usb_generic_rw(d, st->data, wlen + 7, st->data, rlen + 7, 0);\n\tif (st->data[2] != 0x27) {\n\t\terr(\"send command, wrong reply code.\");\n\t\tret = -EIO;\n\t} else if (st->data[4] != seq) {\n\t\terr(\"send command, wrong sequence in reply.\");\n\t\tret = -EIO;\n\t} else if (st->data[5] != 0x01) {\n\t\terr(\"send command, wrong status code in reply.\");\n\t\tret = -EIO;\n\t} else if (st->data[6] != rlen) {\n\t\terr(\"send command, invalid data length in reply.\");\n\t\tret = -EIO;\n\t}\n\tif (!ret) {\n\t\tfor (i = 0; i < rlen; i++)\n\t\t\trbuf[i] = st->data[i + 7];\n\t}\n\n\tmutex_unlock(&d->data_mutex);\n\treturn ret;\n}\n\nint af9005_read_eeprom(struct dvb_usb_device *d, u8 address, u8 * values,\n\t\t       int len)\n{\n\tstruct af9005_device_state *st = d->priv;\n\tu8 seq;\n\tint ret, i;\n\n\tmutex_lock(&d->data_mutex);\n\n\tmemset(st->data, 0, sizeof(st->data));\n\n\tst->data[0] = 14;\t\t/* length of rest of packet low */\n\tst->data[1] = 0;\t\t/* length of rest of packer high */\n\n\tst->data[2] = 0x2a;\t\t/* read/write eeprom */\n\n\tst->data[3] = 12;\t\t/* size */\n\n\tst->data[4] = seq = st->sequence++;\n\n\tst->data[5] = 0;\t\t/* read */\n\n\tst->data[6] = len;\n\tst->data[7] = address;\n\tret = dvb_usb_generic_rw(d, st->data, 16, st->data, 14, 0);\n\tif (st->data[2] != 0x2b) {\n\t\terr(\"Read eeprom, invalid reply code\");\n\t\tret = -EIO;\n\t} else if (st->data[3] != 10) {\n\t\terr(\"Read eeprom, invalid reply length\");\n\t\tret = -EIO;\n\t} else if (st->data[4] != seq) {\n\t\terr(\"Read eeprom, wrong sequence in reply \");\n\t\tret = -EIO;\n\t} else if (st->data[5] != 1) {\n\t\terr(\"Read eeprom, wrong status in reply \");\n\t\tret = -EIO;\n\t}\n\n\tif (!ret) {\n\t\tfor (i = 0; i < len; i++)\n\t\t\tvalues[i] = st->data[6 + i];\n\t}\n\tmutex_unlock(&d->data_mutex);\n\n\treturn ret;\n}\n\nstatic int af9005_boot_packet(struct usb_device *udev, int type, u8 *reply,\n\t\t\t      u8 *buf, int size)\n{\n\tu16 checksum;\n\tint act_len, i, ret;\n\n\tmemset(buf, 0, size);\n\tbuf[0] = (u8) (FW_BULKOUT_SIZE & 0xff);\n\tbuf[1] = (u8) ((FW_BULKOUT_SIZE >> 8) & 0xff);\n\tswitch (type) {\n\tcase FW_CONFIG:\n\t\tbuf[2] = 0x11;\n\t\tbuf[3] = 0x04;\n\t\tbuf[4] = 0x00;\t/* sequence number, original driver doesn't increment it here */\n\t\tbuf[5] = 0x03;\n\t\tchecksum = buf[4] + buf[5];\n\t\tbuf[6] = (u8) ((checksum >> 8) & 0xff);\n\t\tbuf[7] = (u8) (checksum & 0xff);\n\t\tbreak;\n\tcase FW_CONFIRM:\n\t\tbuf[2] = 0x11;\n\t\tbuf[3] = 0x04;\n\t\tbuf[4] = 0x00;\t/* sequence number, original driver doesn't increment it here */\n\t\tbuf[5] = 0x01;\n\t\tchecksum = buf[4] + buf[5];\n\t\tbuf[6] = (u8) ((checksum >> 8) & 0xff);\n\t\tbuf[7] = (u8) (checksum & 0xff);\n\t\tbreak;\n\tcase FW_BOOT:\n\t\tbuf[2] = 0x10;\n\t\tbuf[3] = 0x08;\n\t\tbuf[4] = 0x00;\t/* sequence number, original driver doesn't increment it here */\n\t\tbuf[5] = 0x97;\n\t\tbuf[6] = 0xaa;\n\t\tbuf[7] = 0x55;\n\t\tbuf[8] = 0xa5;\n\t\tbuf[9] = 0x5a;\n\t\tchecksum = 0;\n\t\tfor (i = 4; i <= 9; i++)\n\t\t\tchecksum += buf[i];\n\t\tbuf[10] = (u8) ((checksum >> 8) & 0xff);\n\t\tbuf[11] = (u8) (checksum & 0xff);\n\t\tbreak;\n\tdefault:\n\t\terr(\"boot packet invalid boot packet type\");\n\t\treturn -EINVAL;\n\t}\n\tdeb_fw(\">>> \");\n\tdebug_dump(buf, FW_BULKOUT_SIZE + 2, deb_fw);\n\n\tret = usb_bulk_msg(udev,\n\t\t\t   usb_sndbulkpipe(udev, 0x02),\n\t\t\t   buf, FW_BULKOUT_SIZE + 2, &act_len, 2000);\n\tif (ret)\n\t\terr(\"boot packet bulk message failed: %d (%d/%d)\", ret,\n\t\t    FW_BULKOUT_SIZE + 2, act_len);\n\telse\n\t\tret = act_len != FW_BULKOUT_SIZE + 2 ? -1 : 0;\n\tif (ret)\n\t\treturn ret;\n\tmemset(buf, 0, 9);\n\tret = usb_bulk_msg(udev,\n\t\t\t   usb_rcvbulkpipe(udev, 0x01), buf, 9, &act_len, 2000);\n\tif (ret) {\n\t\terr(\"boot packet recv bulk message failed: %d\", ret);\n\t\treturn ret;\n\t}\n\tdeb_fw(\"<<< \");\n\tdebug_dump(buf, act_len, deb_fw);\n\tchecksum = 0;\n\tswitch (type) {\n\tcase FW_CONFIG:\n\t\tif (buf[2] != 0x11) {\n\t\t\terr(\"boot bad config header.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (buf[3] != 0x05) {\n\t\t\terr(\"boot bad config size.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (buf[4] != 0x00) {\n\t\t\terr(\"boot bad config sequence.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (buf[5] != 0x04) {\n\t\t\terr(\"boot bad config subtype.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tfor (i = 4; i <= 6; i++)\n\t\t\tchecksum += buf[i];\n\t\tif (buf[7] * 256 + buf[8] != checksum) {\n\t\t\terr(\"boot bad config checksum.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\t*reply = buf[6];\n\t\tbreak;\n\tcase FW_CONFIRM:\n\t\tif (buf[2] != 0x11) {\n\t\t\terr(\"boot bad confirm header.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (buf[3] != 0x05) {\n\t\t\terr(\"boot bad confirm size.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (buf[4] != 0x00) {\n\t\t\terr(\"boot bad confirm sequence.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (buf[5] != 0x02) {\n\t\t\terr(\"boot bad confirm subtype.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tfor (i = 4; i <= 6; i++)\n\t\t\tchecksum += buf[i];\n\t\tif (buf[7] * 256 + buf[8] != checksum) {\n\t\t\terr(\"boot bad confirm checksum.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\t*reply = buf[6];\n\t\tbreak;\n\tcase FW_BOOT:\n\t\tif (buf[2] != 0x10) {\n\t\t\terr(\"boot bad boot header.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (buf[3] != 0x05) {\n\t\t\terr(\"boot bad boot size.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (buf[4] != 0x00) {\n\t\t\terr(\"boot bad boot sequence.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (buf[5] != 0x01) {\n\t\t\terr(\"boot bad boot pattern 01.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (buf[6] != 0x10) {\n\t\t\terr(\"boot bad boot pattern 10.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tfor (i = 4; i <= 6; i++)\n\t\t\tchecksum += buf[i];\n\t\tif (buf[7] * 256 + buf[8] != checksum) {\n\t\t\terr(\"boot bad boot checksum.\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tbreak;\n\n\t}\n\n\treturn 0;\n}\n\nstatic int af9005_download_firmware(struct usb_device *udev, const struct firmware *fw)\n{\n\tint i, packets, ret, act_len;\n\n\tu8 *buf;\n\tu8 reply;\n\n\tbuf = kmalloc(FW_BULKOUT_SIZE + 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = af9005_boot_packet(udev, FW_CONFIG, &reply, buf,\n\t\t\t\t FW_BULKOUT_SIZE + 2);\n\tif (ret)\n\t\tgoto err;\n\tif (reply != 0x01) {\n\t\terr(\"before downloading firmware, FW_CONFIG expected 0x01, received 0x%x\", reply);\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\tpackets = fw->size / FW_BULKOUT_SIZE;\n\tbuf[0] = (u8) (FW_BULKOUT_SIZE & 0xff);\n\tbuf[1] = (u8) ((FW_BULKOUT_SIZE >> 8) & 0xff);\n\tfor (i = 0; i < packets; i++) {\n\t\tmemcpy(&buf[2], fw->data + i * FW_BULKOUT_SIZE,\n\t\t       FW_BULKOUT_SIZE);\n\t\tdeb_fw(\">>> \");\n\t\tdebug_dump(buf, FW_BULKOUT_SIZE + 2, deb_fw);\n\t\tret = usb_bulk_msg(udev,\n\t\t\t\t   usb_sndbulkpipe(udev, 0x02),\n\t\t\t\t   buf, FW_BULKOUT_SIZE + 2, &act_len, 1000);\n\t\tif (ret) {\n\t\t\terr(\"firmware download failed at packet %d with code %d\", i, ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tret = af9005_boot_packet(udev, FW_CONFIRM, &reply,\n\t\t\t\t buf, FW_BULKOUT_SIZE + 2);\n\tif (ret)\n\t\tgoto err;\n\tif (reply != (u8) (packets & 0xff)) {\n\t\terr(\"after downloading firmware, FW_CONFIRM expected 0x%x, received 0x%x\", packets & 0xff, reply);\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\tret = af9005_boot_packet(udev, FW_BOOT, &reply, buf,\n\t\t\t\t FW_BULKOUT_SIZE + 2);\n\tif (ret)\n\t\tgoto err;\n\tret = af9005_boot_packet(udev, FW_CONFIG, &reply, buf,\n\t\t\t\t FW_BULKOUT_SIZE + 2);\n\tif (ret)\n\t\tgoto err;\n\tif (reply != 0x02) {\n\t\terr(\"after downloading firmware, FW_CONFIG expected 0x02, received 0x%x\", reply);\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\nerr:\n\tkfree(buf);\n\treturn ret;\n\n}\n\nint af9005_led_control(struct dvb_usb_device *d, int onoff)\n{\n\tstruct af9005_device_state *st = d->priv;\n\tint temp, ret;\n\n\tif (onoff && dvb_usb_af9005_led)\n\t\ttemp = 1;\n\telse\n\t\ttemp = 0;\n\tif (st->led_state != temp) {\n\t\tret =\n\t\t    af9005_write_register_bits(d, xd_p_reg_top_locken1,\n\t\t\t\t\t       reg_top_locken1_pos,\n\t\t\t\t\t       reg_top_locken1_len, temp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret =\n\t\t    af9005_write_register_bits(d, xd_p_reg_top_lock1,\n\t\t\t\t\t       reg_top_lock1_pos,\n\t\t\t\t\t       reg_top_lock1_len, temp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tst->led_state = temp;\n\t}\n\treturn 0;\n}\n\nstatic int af9005_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tu8 buf[8];\n\tint i;\n\n\t/* without these calls the first commands after downloading\n\t   the firmware fail. I put these calls here to simulate\n\t   what it is done in dvb-usb-init.c.\n\t */\n\tstruct usb_device *udev = adap->dev->udev;\n\tusb_clear_halt(udev, usb_sndbulkpipe(udev, 2));\n\tusb_clear_halt(udev, usb_rcvbulkpipe(udev, 1));\n\tif (dvb_usb_af9005_dump_eeprom) {\n\t\tprintk(\"EEPROM DUMP\\n\");\n\t\tfor (i = 0; i < 255; i += 8) {\n\t\t\taf9005_read_eeprom(adap->dev, i, buf, 8);\n\t\t\tdebug_dump(buf, 8, printk);\n\t\t}\n\t}\n\tadap->fe_adap[0].fe = af9005_fe_attach(adap->dev);\n\treturn 0;\n}\n\nstatic int af9005_rc_query(struct dvb_usb_device *d, u32 * event, int *state)\n{\n\tstruct af9005_device_state *st = d->priv;\n\tint ret, len;\n\tu8 seq;\n\n\t*state = REMOTE_NO_KEY_PRESSED;\n\tif (rc_decode == NULL) {\n\t\t/* it shouldn't never come here */\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&d->data_mutex);\n\n\t/* deb_info(\"rc_query\\n\"); */\n\tst->data[0] = 3;\t\t/* rest of packet length low */\n\tst->data[1] = 0;\t\t/* rest of packet length high */\n\tst->data[2] = 0x40;\t\t/* read remote */\n\tst->data[3] = 1;\t\t/* rest of packet length */\n\tst->data[4] = seq = st->sequence++;\t/* sequence number */\n\tret = dvb_usb_generic_rw(d, st->data, 5, st->data, 256, 0);\n\tif (ret) {\n\t\terr(\"rc query failed\");\n\t\tgoto ret;\n\t}\n\tif (st->data[2] != 0x41) {\n\t\terr(\"rc query bad header.\");\n\t\tret = -EIO;\n\t\tgoto ret;\n\t} else if (st->data[4] != seq) {\n\t\terr(\"rc query bad sequence.\");\n\t\tret = -EIO;\n\t\tgoto ret;\n\t}\n\tlen = st->data[5];\n\tif (len > 246) {\n\t\terr(\"rc query invalid length\");\n\t\tret = -EIO;\n\t\tgoto ret;\n\t}\n\tif (len > 0) {\n\t\tdeb_rc(\"rc data (%d) \", len);\n\t\tdebug_dump((st->data + 6), len, deb_rc);\n\t\tret = rc_decode(d, &st->data[6], len, event, state);\n\t\tif (ret) {\n\t\t\terr(\"rc_decode failed\");\n\t\t\tgoto ret;\n\t\t} else {\n\t\t\tdeb_rc(\"rc_decode state %x event %x\\n\", *state, *event);\n\t\t\tif (*state == REMOTE_KEY_REPEAT)\n\t\t\t\t*event = d->last_event;\n\t\t}\n\t}\n\nret:\n\tmutex_unlock(&d->data_mutex);\n\treturn ret;\n}\n\nstatic int af9005_power_ctrl(struct dvb_usb_device *d, int onoff)\n{\n\n\treturn 0;\n}\n\nstatic int af9005_pid_filter_control(struct dvb_usb_adapter *adap, int onoff)\n{\n\tint ret;\n\tdeb_info(\"pid filter control  onoff %d\\n\", onoff);\n\tif (onoff) {\n\t\tret =\n\t\t    af9005_write_ofdm_register(adap->dev, XD_MP2IF_DMX_CTRL, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret =\n\t\t    af9005_write_register_bits(adap->dev,\n\t\t\t\t\t       XD_MP2IF_DMX_CTRL, 1, 1, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret =\n\t\t    af9005_write_ofdm_register(adap->dev, XD_MP2IF_DMX_CTRL, 1);\n\t} else\n\t\tret =\n\t\t    af9005_write_ofdm_register(adap->dev, XD_MP2IF_DMX_CTRL, 0);\n\tif (ret)\n\t\treturn ret;\n\tdeb_info(\"pid filter control ok\\n\");\n\treturn 0;\n}\n\nstatic int af9005_pid_filter(struct dvb_usb_adapter *adap, int index,\n\t\t\t     u16 pid, int onoff)\n{\n\tu8 cmd = index & 0x1f;\n\tint ret;\n\tdeb_info(\"set pid filter, index %d, pid %x, onoff %d\\n\", index,\n\t\t pid, onoff);\n\tif (onoff) {\n\t\t/* cannot use it as pid_filter_ctrl since it has to be done\n\t\t   before setting the first pid */\n\t\tif (adap->feedcount == 1) {\n\t\t\tdeb_info(\"first pid set, enable pid table\\n\");\n\t\t\tret = af9005_pid_filter_control(adap, onoff);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tret =\n\t\t    af9005_write_ofdm_register(adap->dev,\n\t\t\t\t\t       XD_MP2IF_PID_DATA_L,\n\t\t\t\t\t       (u8) (pid & 0xff));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret =\n\t\t    af9005_write_ofdm_register(adap->dev,\n\t\t\t\t\t       XD_MP2IF_PID_DATA_H,\n\t\t\t\t\t       (u8) (pid >> 8));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcmd |= 0x20 | 0x40;\n\t} else {\n\t\tif (adap->feedcount == 0) {\n\t\t\tdeb_info(\"last pid unset, disable pid table\\n\");\n\t\t\tret = af9005_pid_filter_control(adap, onoff);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\tret = af9005_write_ofdm_register(adap->dev, XD_MP2IF_PID_IDX, cmd);\n\tif (ret)\n\t\treturn ret;\n\tdeb_info(\"set pid ok\\n\");\n\treturn 0;\n}\n\nstatic int af9005_identify_state(struct usb_device *udev,\n\t\t\t\t struct dvb_usb_device_properties *props,\n\t\t\t\t struct dvb_usb_device_description **desc,\n\t\t\t\t int *cold)\n{\n\tint ret;\n\tu8 reply, *buf;\n\n\tbuf = kmalloc(FW_BULKOUT_SIZE + 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = af9005_boot_packet(udev, FW_CONFIG, &reply,\n\t\t\t\t buf, FW_BULKOUT_SIZE + 2);\n\tif (ret)\n\t\tgoto err;\n\tdeb_info(\"result of FW_CONFIG in identify state %d\\n\", reply);\n\tif (reply == 0x01)\n\t\t*cold = 1;\n\telse if (reply == 0x02)\n\t\t*cold = 0;\n\telse\n\t\tret = -EIO;\n\tif (!ret)\n\t\tdeb_info(\"Identify state cold = %d\\n\", *cold);\n\nerr:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic struct dvb_usb_device_properties af9005_properties;\n\nstatic int af9005_usb_probe(struct usb_interface *intf,\n\t\t\t    const struct usb_device_id *id)\n{\n\treturn dvb_usb_device_init(intf, &af9005_properties,\n\t\t\t\t  THIS_MODULE, NULL, adapter_nr);\n}\n\nenum af9005_usb_table_entry {\n\tAFATECH_AF9005,\n\tTERRATEC_AF9005,\n\tANSONIC_AF9005,\n};\n\nstatic struct usb_device_id af9005_usb_table[] = {\n\t[AFATECH_AF9005] = {USB_DEVICE(USB_VID_AFATECH,\n\t\t\t\tUSB_PID_AFATECH_AF9005)},\n\t[TERRATEC_AF9005] = {USB_DEVICE(USB_VID_TERRATEC,\n\t\t\t\tUSB_PID_TERRATEC_CINERGY_T_USB_XE)},\n\t[ANSONIC_AF9005] = {USB_DEVICE(USB_VID_ANSONIC,\n\t\t\t\tUSB_PID_ANSONIC_DVBT_USB)},\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, af9005_usb_table);\n\nstatic struct dvb_usb_device_properties af9005_properties = {\n\t.caps = DVB_USB_IS_AN_I2C_ADAPTER,\n\n\t.usb_ctrl = DEVICE_SPECIFIC,\n\t.firmware = \"af9005.fw\",\n\t.download_firmware = af9005_download_firmware,\n\t.no_reconnect = 1,\n\n\t.size_of_priv = sizeof(struct af9005_device_state),\n\n\t.num_adapters = 1,\n\t.adapter = {\n\t\t    {\n\t\t    .num_frontends = 1,\n\t\t    .fe = {{\n\t\t     .caps =\n\t\t     DVB_USB_ADAP_HAS_PID_FILTER |\n\t\t     DVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF,\n\t\t     .pid_filter_count = 32,\n\t\t     .pid_filter = af9005_pid_filter,\n\t\t     /* .pid_filter_ctrl = af9005_pid_filter_control, */\n\t\t     .frontend_attach = af9005_frontend_attach,\n\t\t     /* .tuner_attach     = af9005_tuner_attach, */\n\t\t     /* parameter for the MPEG2-data transfer */\n\t\t     .stream = {\n\t\t\t\t.type = USB_BULK,\n\t\t\t\t.count = 10,\n\t\t\t\t.endpoint = 0x04,\n\t\t\t\t.u = {\n\t\t\t\t      .bulk = {\n\t\t\t\t\t       .buffersize = 4096,\t/* actual size seen is 3948 */\n\t\t\t\t\t       }\n\t\t\t\t      }\n\t\t\t\t},\n\t\t     }},\n\t\t     }\n\t\t    },\n\t.power_ctrl = af9005_power_ctrl,\n\t.identify_state = af9005_identify_state,\n\n\t.i2c_algo = &af9005_i2c_algo,\n\n\t.rc.legacy = {\n\t\t.rc_interval = 200,\n\t\t.rc_map_table = NULL,\n\t\t.rc_map_size = 0,\n\t\t.rc_query = af9005_rc_query,\n\t},\n\n\t.generic_bulk_ctrl_endpoint          = 2,\n\t.generic_bulk_ctrl_endpoint_response = 1,\n\n\t.num_device_descs = 3,\n\t.devices = {\n\t\t    {.name = \"Afatech DVB-T USB1.1 stick\",\n\t\t     .cold_ids = {&af9005_usb_table[AFATECH_AF9005], NULL},\n\t\t     .warm_ids = {NULL},\n\t\t     },\n\t\t    {.name = \"TerraTec Cinergy T USB XE\",\n\t\t     .cold_ids = {&af9005_usb_table[TERRATEC_AF9005], NULL},\n\t\t     .warm_ids = {NULL},\n\t\t     },\n\t\t    {.name = \"Ansonic DVB-T USB1.1 stick\",\n\t\t     .cold_ids = {&af9005_usb_table[ANSONIC_AF9005], NULL},\n\t\t     .warm_ids = {NULL},\n\t\t     },\n\t\t    {NULL},\n\t\t    }\n};\n\n/* usb specific object needed to register this driver with the usb subsystem */\nstatic struct usb_driver af9005_usb_driver = {\n\t.name = \"dvb_usb_af9005\",\n\t.probe = af9005_usb_probe,\n\t.disconnect = dvb_usb_device_exit,\n\t.id_table = af9005_usb_table,\n};\n\n/* module stuff */\nstatic int __init af9005_usb_module_init(void)\n{\n\tint result;\n\tif ((result = usb_register(&af9005_usb_driver))) {\n\t\terr(\"usb_register failed. (%d)\", result);\n\t\treturn result;\n\t}\n#if IS_MODULE(CONFIG_DVB_USB_AF9005) || defined(CONFIG_DVB_USB_AF9005_REMOTE)\n\t/* FIXME: convert to todays kernel IR infrastructure */\n\trc_decode = symbol_request(af9005_rc_decode);\n\trc_keys = symbol_request(rc_map_af9005_table);\n\trc_keys_size = symbol_request(rc_map_af9005_table_size);\n#endif\n\tif (rc_decode == NULL || rc_keys == NULL || rc_keys_size == NULL) {\n\t\terr(\"af9005_rc_decode function not found, disabling remote\");\n\t\taf9005_properties.rc.legacy.rc_query = NULL;\n\t} else {\n\t\taf9005_properties.rc.legacy.rc_map_table = rc_keys;\n\t\taf9005_properties.rc.legacy.rc_map_size = *rc_keys_size;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit af9005_usb_module_exit(void)\n{\n\t/* release rc decode symbols */\n\tif (rc_decode != NULL)\n\t\tsymbol_put(af9005_rc_decode);\n\tif (rc_keys != NULL)\n\t\tsymbol_put(rc_map_af9005_table);\n\tif (rc_keys_size != NULL)\n\t\tsymbol_put(rc_map_af9005_table_size);\n\t/* deregister this driver from the USB subsystem */\n\tusb_deregister(&af9005_usb_driver);\n}\n\nmodule_init(af9005_usb_module_init);\nmodule_exit(af9005_usb_module_exit);\n\nMODULE_AUTHOR(\"Luca Olivetti <luca@ventoso.org>\");\nMODULE_DESCRIPTION(\"Driver for Afatech 9005 DVB-T USB1.1 stick\");\nMODULE_VERSION(\"1.0\");\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/media/usb/dvb-usb/af9005.c"], "buggy_code_start_loc": [979], "buggy_code_end_loc": [981], "fixing_code_start_loc": [979], "fixing_code_end_loc": [982], "type": "CWE-401", "message": "A memory leak in the af9005_identify_state() function in drivers/media/usb/dvb-usb/af9005.c in the Linux kernel through 5.3.9 allows attackers to cause a denial of service (memory consumption), aka CID-2289adbfa559.", "other": {"cve": {"id": "CVE-2019-18809", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-07T16:15:11.437", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A memory leak in the af9005_identify_state() function in drivers/media/usb/dvb-usb/af9005.c in the Linux kernel through 5.3.9 allows attackers to cause a denial of service (memory consumption), aka CID-2289adbfa559."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n af9005_identify_state() en el archivo drivers/media/usb/dvb-usb/af9005.c en el kernel de Linux versiones hasta 5.3.9, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria), tambi\u00e9n se conoce como CID-2289adbfa559."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.3.9", "matchCriteriaId": "3D729DA7-EC0B-4D1C-9F5B-BA9E7B7AF272"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-12/msg00029.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/2289adbfa559050d2a38bcd9caac1c18b800e928", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/03/msg00001.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LYIFGYEDQXP5DVJQQUARQRK2PXKBKQGY/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YWWOOJKZ4NQYN4RMFIVJ3ZIXKJJI3MKP/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4285-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4287-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4287-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4300-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/2289adbfa559050d2a38bcd9caac1c18b800e928"}}