{"buggy_code": ["import * as Utils from './utils';\nimport Exception from './exception';\nimport {\n  COMPILER_REVISION,\n  createFrame,\n  LAST_COMPATIBLE_COMPILER_REVISION,\n  REVISION_CHANGES\n} from './base';\nimport { moveHelperToHooks } from './helpers';\nimport { wrapHelper } from './internal/wrapHelper';\nimport {\n  createProtoAccessControl,\n  resultIsAllowed\n} from './internal/proto-access';\n\nexport function checkRevision(compilerInfo) {\n  const compilerRevision = (compilerInfo && compilerInfo[0]) || 1,\n    currentRevision = COMPILER_REVISION;\n\n  if (\n    compilerRevision >= LAST_COMPATIBLE_COMPILER_REVISION &&\n    compilerRevision <= COMPILER_REVISION\n  ) {\n    return;\n  }\n\n  if (compilerRevision < LAST_COMPATIBLE_COMPILER_REVISION) {\n    const runtimeVersions = REVISION_CHANGES[currentRevision],\n      compilerVersions = REVISION_CHANGES[compilerRevision];\n    throw new Exception(\n      'Template was precompiled with an older version of Handlebars than the current runtime. ' +\n        'Please update your precompiler to a newer version (' +\n        runtimeVersions +\n        ') or downgrade your runtime to an older version (' +\n        compilerVersions +\n        ').'\n    );\n  } else {\n    // Use the embedded version info since the runtime doesn't know about this revision yet\n    throw new Exception(\n      'Template was precompiled with a newer version of Handlebars than the current runtime. ' +\n        'Please update your runtime to a newer version (' +\n        compilerInfo[1] +\n        ').'\n    );\n  }\n}\n\nexport function template(templateSpec, env) {\n  /* istanbul ignore next */\n  if (!env) {\n    throw new Exception('No environment passed to template');\n  }\n  if (!templateSpec || !templateSpec.main) {\n    throw new Exception('Unknown template object: ' + typeof templateSpec);\n  }\n\n  templateSpec.main.decorator = templateSpec.main_d;\n\n  // Note: Using env.VM references rather than local var references throughout this section to allow\n  // for external users to override these as pseudo-supported APIs.\n  env.VM.checkRevision(templateSpec.compiler);\n\n  // backwards compatibility for precompiled templates with compiler-version 7 (<4.3.0)\n  const templateWasPrecompiledWithCompilerV7 =\n    templateSpec.compiler && templateSpec.compiler[0] === 7;\n\n  function invokePartialWrapper(partial, context, options) {\n    if (options.hash) {\n      context = Utils.extend({}, context, options.hash);\n      if (options.ids) {\n        options.ids[0] = true;\n      }\n    }\n    partial = env.VM.resolvePartial.call(this, partial, context, options);\n\n    let extendedOptions = Utils.extend({}, options, {\n      hooks: this.hooks,\n      protoAccessControl: this.protoAccessControl\n    });\n\n    let result = env.VM.invokePartial.call(\n      this,\n      partial,\n      context,\n      extendedOptions\n    );\n\n    if (result == null && env.compile) {\n      options.partials[options.name] = env.compile(\n        partial,\n        templateSpec.compilerOptions,\n        env\n      );\n      result = options.partials[options.name](context, extendedOptions);\n    }\n    if (result != null) {\n      if (options.indent) {\n        let lines = result.split('\\n');\n        for (let i = 0, l = lines.length; i < l; i++) {\n          if (!lines[i] && i + 1 === l) {\n            break;\n          }\n\n          lines[i] = options.indent + lines[i];\n        }\n        result = lines.join('\\n');\n      }\n      return result;\n    } else {\n      throw new Exception(\n        'The partial ' +\n          options.name +\n          ' could not be compiled when running in runtime-only mode'\n      );\n    }\n  }\n\n  // Just add water\n  let container = {\n    strict: function(obj, name, loc) {\n      if (!obj || !(name in obj)) {\n        throw new Exception('\"' + name + '\" not defined in ' + obj, {\n          loc: loc\n        });\n      }\n      return obj[name];\n    },\n    lookupProperty: function(parent, propertyName) {\n      let result = parent[propertyName];\n      if (result == null) {\n        return result;\n      }\n      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n        return result;\n      }\n\n      if (resultIsAllowed(result, container.protoAccessControl, propertyName)) {\n        return result;\n      }\n      return undefined;\n    },\n    lookup: function(depths, name) {\n      const len = depths.length;\n      for (let i = 0; i < len; i++) {\n        let result = depths[i] && container.lookupProperty(depths[i], name);\n        if (result != null) {\n          return depths[i][name];\n        }\n      }\n    },\n    lambda: function(current, context) {\n      return typeof current === 'function' ? current.call(context) : current;\n    },\n\n    escapeExpression: Utils.escapeExpression,\n    invokePartial: invokePartialWrapper,\n\n    fn: function(i) {\n      let ret = templateSpec[i];\n      ret.decorator = templateSpec[i + '_d'];\n      return ret;\n    },\n\n    programs: [],\n    program: function(i, data, declaredBlockParams, blockParams, depths) {\n      let programWrapper = this.programs[i],\n        fn = this.fn(i);\n      if (data || depths || blockParams || declaredBlockParams) {\n        programWrapper = wrapProgram(\n          this,\n          i,\n          fn,\n          data,\n          declaredBlockParams,\n          blockParams,\n          depths\n        );\n      } else if (!programWrapper) {\n        programWrapper = this.programs[i] = wrapProgram(this, i, fn);\n      }\n      return programWrapper;\n    },\n\n    data: function(value, depth) {\n      while (value && depth--) {\n        value = value._parent;\n      }\n      return value;\n    },\n    mergeIfNeeded: function(param, common) {\n      let obj = param || common;\n\n      if (param && common && param !== common) {\n        obj = Utils.extend({}, common, param);\n      }\n\n      return obj;\n    },\n    // An empty object to use as replacement for null-contexts\n    nullContext: Object.seal({}),\n\n    noop: env.VM.noop,\n    compilerInfo: templateSpec.compiler\n  };\n\n  function ret(context, options = {}) {\n    let data = options.data;\n\n    ret._setup(options);\n    if (!options.partial && templateSpec.useData) {\n      data = initData(context, data);\n    }\n    let depths,\n      blockParams = templateSpec.useBlockParams ? [] : undefined;\n    if (templateSpec.useDepths) {\n      if (options.depths) {\n        depths =\n          context != options.depths[0]\n            ? [context].concat(options.depths)\n            : options.depths;\n      } else {\n        depths = [context];\n      }\n    }\n\n    function main(context /*, options*/) {\n      return (\n        '' +\n        templateSpec.main(\n          container,\n          context,\n          container.helpers,\n          container.partials,\n          data,\n          blockParams,\n          depths\n        )\n      );\n    }\n\n    main = executeDecorators(\n      templateSpec.main,\n      main,\n      container,\n      options.depths || [],\n      data,\n      blockParams\n    );\n    return main(context, options);\n  }\n\n  ret.isTop = true;\n\n  ret._setup = function(options) {\n    if (!options.partial) {\n      let mergedHelpers = Utils.extend({}, env.helpers, options.helpers);\n      wrapHelpersToPassLookupProperty(mergedHelpers, container);\n      container.helpers = mergedHelpers;\n\n      if (templateSpec.usePartial) {\n        // Use mergeIfNeeded here to prevent compiling global partials multiple times\n        container.partials = container.mergeIfNeeded(\n          options.partials,\n          env.partials\n        );\n      }\n      if (templateSpec.usePartial || templateSpec.useDecorators) {\n        container.decorators = Utils.extend(\n          {},\n          env.decorators,\n          options.decorators\n        );\n      }\n\n      container.hooks = {};\n      container.protoAccessControl = createProtoAccessControl(options);\n\n      let keepHelperInHelpers =\n        options.allowCallsToHelperMissing ||\n        templateWasPrecompiledWithCompilerV7;\n      moveHelperToHooks(container, 'helperMissing', keepHelperInHelpers);\n      moveHelperToHooks(container, 'blockHelperMissing', keepHelperInHelpers);\n    } else {\n      container.protoAccessControl = options.protoAccessControl; // internal option\n      container.helpers = options.helpers;\n      container.partials = options.partials;\n      container.decorators = options.decorators;\n      container.hooks = options.hooks;\n    }\n  };\n\n  ret._child = function(i, data, blockParams, depths) {\n    if (templateSpec.useBlockParams && !blockParams) {\n      throw new Exception('must pass block params');\n    }\n    if (templateSpec.useDepths && !depths) {\n      throw new Exception('must pass parent depths');\n    }\n\n    return wrapProgram(\n      container,\n      i,\n      templateSpec[i],\n      data,\n      0,\n      blockParams,\n      depths\n    );\n  };\n  return ret;\n}\n\nexport function wrapProgram(\n  container,\n  i,\n  fn,\n  data,\n  declaredBlockParams,\n  blockParams,\n  depths\n) {\n  function prog(context, options = {}) {\n    let currentDepths = depths;\n    if (\n      depths &&\n      context != depths[0] &&\n      !(context === container.nullContext && depths[0] === null)\n    ) {\n      currentDepths = [context].concat(depths);\n    }\n\n    return fn(\n      container,\n      context,\n      container.helpers,\n      container.partials,\n      options.data || data,\n      blockParams && [options.blockParams].concat(blockParams),\n      currentDepths\n    );\n  }\n\n  prog = executeDecorators(fn, prog, container, depths, data, blockParams);\n\n  prog.program = i;\n  prog.depth = depths ? depths.length : 0;\n  prog.blockParams = declaredBlockParams || 0;\n  return prog;\n}\n\n/**\n * This is currently part of the official API, therefore implementation details should not be changed.\n */\nexport function resolvePartial(partial, context, options) {\n  if (!partial) {\n    if (options.name === '@partial-block') {\n      partial = options.data['partial-block'];\n    } else {\n      partial = options.partials[options.name];\n    }\n  } else if (!partial.call && !options.name) {\n    // This is a dynamic partial that returned a string\n    options.name = partial;\n    partial = options.partials[partial];\n  }\n  return partial;\n}\n\nexport function invokePartial(partial, context, options) {\n  // Use the current closure context to save the partial-block if this partial\n  const currentPartialBlock = options.data && options.data['partial-block'];\n  options.partial = true;\n  if (options.ids) {\n    options.data.contextPath = options.ids[0] || options.data.contextPath;\n  }\n\n  let partialBlock;\n  if (options.fn && options.fn !== noop) {\n    options.data = createFrame(options.data);\n    // Wrapper function to get access to currentPartialBlock from the closure\n    let fn = options.fn;\n    partialBlock = options.data['partial-block'] = function partialBlockWrapper(\n      context,\n      options = {}\n    ) {\n      // Restore the partial-block from the closure for the execution of the block\n      // i.e. the part inside the block of the partial call.\n      options.data = createFrame(options.data);\n      options.data['partial-block'] = currentPartialBlock;\n      return fn(context, options);\n    };\n    if (fn.partials) {\n      options.partials = Utils.extend({}, options.partials, fn.partials);\n    }\n  }\n\n  if (partial === undefined && partialBlock) {\n    partial = partialBlock;\n  }\n\n  if (partial === undefined) {\n    throw new Exception('The partial ' + options.name + ' could not be found');\n  } else if (partial instanceof Function) {\n    return partial(context, options);\n  }\n}\n\nexport function noop() {\n  return '';\n}\n\nfunction initData(context, data) {\n  if (!data || !('root' in data)) {\n    data = data ? createFrame(data) : {};\n    data.root = context;\n  }\n  return data;\n}\n\nfunction executeDecorators(fn, prog, container, depths, data, blockParams) {\n  if (fn.decorator) {\n    let props = {};\n    prog = fn.decorator(\n      prog,\n      props,\n      container,\n      depths && depths[0],\n      data,\n      blockParams,\n      depths\n    );\n    Utils.extend(prog, props);\n  }\n  return prog;\n}\n\nfunction wrapHelpersToPassLookupProperty(mergedHelpers, container) {\n  Object.keys(mergedHelpers).forEach(helperName => {\n    let helper = mergedHelpers[helperName];\n    mergedHelpers[helperName] = passLookupPropertyOption(helper, container);\n  });\n}\n\nfunction passLookupPropertyOption(helper, container) {\n  const lookupProperty = container.lookupProperty;\n  return wrapHelper(helper, options => {\n    return Utils.extend({ lookupProperty }, options);\n  });\n}\n", "describe('security issues', function() {\n  describe('GH-1495: Prevent Remote Code Execution via constructor', function() {\n    it('should not allow constructors to be accessed', function() {\n      expectTemplate('{{lookup (lookup this \"constructor\") \"name\"}}')\n        .withInput({})\n        .toCompileTo('');\n\n      expectTemplate('{{constructor.name}}')\n        .withInput({})\n        .toCompileTo('');\n    });\n\n    it('GH-1603: should not allow constructors to be accessed (lookup via toString)', function() {\n      expectTemplate('{{lookup (lookup this (list \"constructor\")) \"name\"}}')\n        .withInput({})\n        .withHelper('list', function(element) {\n          return [element];\n        })\n        .toCompileTo('');\n    });\n\n    it('should allow the \"constructor\" property to be accessed if it is an \"ownProperty\"', function() {\n      expectTemplate('{{constructor.name}}')\n        .withInput({ constructor: { name: 'here we go' } })\n        .toCompileTo('here we go');\n\n      expectTemplate('{{lookup (lookup this \"constructor\") \"name\"}}')\n        .withInput({ constructor: { name: 'here we go' } })\n        .toCompileTo('here we go');\n    });\n\n    it('should allow the \"constructor\" property to be accessed if it is an \"own property\"', function() {\n      expectTemplate('{{lookup (lookup this \"constructor\") \"name\"}}')\n        .withInput({ constructor: { name: 'here we go' } })\n        .toCompileTo('here we go');\n    });\n  });\n\n  describe('GH-1558: Prevent explicit call of helperMissing-helpers', function() {\n    if (!Handlebars.compile) {\n      return;\n    }\n\n    describe('without the option \"allowExplicitCallOfHelperMissing\"', function() {\n      it('should throw an exception when calling  \"{{helperMissing}}\" ', function() {\n        expectTemplate('{{helperMissing}}').toThrow(Error);\n      });\n\n      it('should throw an exception when calling  \"{{#helperMissing}}{{/helperMissing}}\" ', function() {\n        expectTemplate('{{#helperMissing}}{{/helperMissing}}').toThrow(Error);\n      });\n\n      it('should throw an exception when calling  \"{{blockHelperMissing \"abc\" .}}\" ', function() {\n        var functionCalls = [];\n        expect(function() {\n          var template = Handlebars.compile('{{blockHelperMissing \"abc\" .}}');\n          template({\n            fn: function() {\n              functionCalls.push('called');\n            }\n          });\n        }).to.throw(Error);\n        expect(functionCalls.length).to.equal(0);\n      });\n\n      it('should throw an exception when calling  \"{{#blockHelperMissing .}}{{/blockHelperMissing}}\"', function() {\n        expectTemplate('{{#blockHelperMissing .}}{{/blockHelperMissing}}')\n          .withInput({\n            fn: function() {\n              return 'functionInData';\n            }\n          })\n          .toThrow(Error);\n      });\n    });\n\n    describe('with the option \"allowCallsToHelperMissing\" set to true', function() {\n      it('should not throw an exception when calling  \"{{helperMissing}}\" ', function() {\n        var template = Handlebars.compile('{{helperMissing}}');\n        template({}, { allowCallsToHelperMissing: true });\n      });\n\n      it('should not throw an exception when calling  \"{{#helperMissing}}{{/helperMissing}}\" ', function() {\n        var template = Handlebars.compile(\n          '{{#helperMissing}}{{/helperMissing}}'\n        );\n        template({}, { allowCallsToHelperMissing: true });\n      });\n\n      it('should not throw an exception when calling  \"{{blockHelperMissing \"abc\" .}}\" ', function() {\n        var functionCalls = [];\n        var template = Handlebars.compile('{{blockHelperMissing \"abc\" .}}');\n        template(\n          {\n            fn: function() {\n              functionCalls.push('called');\n            }\n          },\n          { allowCallsToHelperMissing: true }\n        );\n        equals(functionCalls.length, 1);\n      });\n\n      it('should not throw an exception when calling  \"{{#blockHelperMissing .}}{{/blockHelperMissing}}\"', function() {\n        var template = Handlebars.compile(\n          '{{#blockHelperMissing true}}sdads{{/blockHelperMissing}}'\n        );\n        template({}, { allowCallsToHelperMissing: true });\n      });\n    });\n  });\n\n  describe('GH-1563', function() {\n    it('should not allow to access constructor after overriding via __defineGetter__', function() {\n      if ({}.__defineGetter__ == null || {}.__lookupGetter__ == null) {\n        return this.skip(); // Browser does not support this exploit anyway\n      }\n      expectTemplate(\n        '{{__defineGetter__ \"undefined\" valueOf }}' +\n          '{{#with __lookupGetter__ }}' +\n          '{{__defineGetter__ \"propertyIsEnumerable\" (this.bind (this.bind 1)) }}' +\n          '{{constructor.name}}' +\n          '{{/with}}'\n      )\n        .withInput({})\n        .toThrow(/Missing helper: \"__defineGetter__\"/);\n    });\n  });\n\n  describe('GH-1595: dangerous properties', function() {\n    var templates = [\n      '{{constructor}}',\n      '{{__defineGetter__}}',\n      '{{__defineSetter__}}',\n      '{{__lookupGetter__}}',\n      '{{__proto__}}',\n      '{{lookup this \"constructor\"}}',\n      '{{lookup this \"__defineGetter__\"}}',\n      '{{lookup this \"__defineSetter__\"}}',\n      '{{lookup this \"__lookupGetter__\"}}',\n      '{{lookup this \"__proto__\"}}'\n    ];\n\n    templates.forEach(function(template) {\n      describe('access should be denied to ' + template, function() {\n        it('by default', function() {\n          expectTemplate(template)\n            .withInput({})\n            .toCompileTo('');\n        });\n        it(' with proto-access enabled', function() {\n          expectTemplate(template)\n            .withInput({})\n            .withRuntimeOptions({\n              allowProtoPropertiesByDefault: true,\n              allowProtoMethodsByDefault: true\n            })\n            .toCompileTo('');\n        });\n      });\n    });\n  });\n  describe('GH-1631: disallow access to prototype functions', function() {\n    function TestClass() {}\n\n    TestClass.prototype.aProperty = 'propertyValue';\n    TestClass.prototype.aMethod = function() {\n      return 'returnValue';\n    };\n\n    beforeEach(function() {\n      handlebarsEnv.resetLoggedPropertyAccesses();\n    });\n\n    afterEach(function() {\n      sinon.restore();\n    });\n\n    describe('control access to prototype methods via \"allowedProtoMethods\"', function() {\n      checkProtoMethodAccess({});\n\n      describe('in compat mode', function() {\n        checkProtoMethodAccess({ compat: true });\n      });\n\n      function checkProtoMethodAccess(compileOptions) {\n        it('should be prohibited by default and log a warning', function() {\n          var spy = sinon.spy(console, 'error');\n\n          expectTemplate('{{aMethod}}')\n            .withInput(new TestClass())\n            .withCompileOptions(compileOptions)\n            .toCompileTo('');\n\n          expect(spy.calledOnce).to.be.true();\n          expect(spy.args[0][0]).to.match(/Handlebars: Access has been denied/);\n        });\n\n        it('should only log the warning once', function() {\n          var spy = sinon.spy(console, 'error');\n\n          expectTemplate('{{aMethod}}')\n            .withInput(new TestClass())\n            .withCompileOptions(compileOptions)\n            .toCompileTo('');\n\n          expectTemplate('{{aMethod}}')\n            .withInput(new TestClass())\n            .withCompileOptions(compileOptions)\n            .toCompileTo('');\n\n          expect(spy.calledOnce).to.be.true();\n          expect(spy.args[0][0]).to.match(/Handlebars: Access has been denied/);\n        });\n\n        it('can be allowed, which disables the warning', function() {\n          var spy = sinon.spy(console, 'error');\n\n          expectTemplate('{{aMethod}}')\n            .withInput(new TestClass())\n            .withCompileOptions(compileOptions)\n            .withRuntimeOptions({\n              allowedProtoMethods: {\n                aMethod: true\n              }\n            })\n            .toCompileTo('returnValue');\n\n          expect(spy.callCount).to.equal(0);\n        });\n\n        it('can be turned on by default, which disables the warning', function() {\n          var spy = sinon.spy(console, 'error');\n\n          expectTemplate('{{aMethod}}')\n            .withInput(new TestClass())\n            .withCompileOptions(compileOptions)\n            .withRuntimeOptions({\n              allowProtoMethodsByDefault: true\n            })\n            .toCompileTo('returnValue');\n\n          expect(spy.callCount).to.equal(0);\n        });\n\n        it('can be turned off by default, which disables the warning', function() {\n          var spy = sinon.spy(console, 'error');\n\n          expectTemplate('{{aMethod}}')\n            .withInput(new TestClass())\n            .withCompileOptions(compileOptions)\n            .withRuntimeOptions({\n              allowProtoMethodsByDefault: false\n            })\n            .toCompileTo('');\n\n          expect(spy.callCount).to.equal(0);\n        });\n\n        it('can be turned off, if turned on by default', function() {\n          expectTemplate('{{aMethod}}')\n            .withInput(new TestClass())\n            .withCompileOptions(compileOptions)\n            .withRuntimeOptions({\n              allowProtoMethodsByDefault: true,\n              allowedProtoMethods: {\n                aMethod: false\n              }\n            })\n            .toCompileTo('');\n        });\n      }\n\n      it('should cause the recursive lookup by default (in \"compat\" mode)', function() {\n        expectTemplate('{{#aString}}{{trim}}{{/aString}}')\n          .withInput({ aString: '  abc  ', trim: 'trim' })\n          .withCompileOptions({ compat: true })\n          .toCompileTo('trim');\n      });\n\n      it('should not cause the recursive lookup if allowed through options(in \"compat\" mode)', function() {\n        expectTemplate('{{#aString}}{{trim}}{{/aString}}')\n          .withInput({ aString: '  abc  ', trim: 'trim' })\n          .withCompileOptions({ compat: true })\n          .withRuntimeOptions({\n            allowedProtoMethods: {\n              trim: true\n            }\n          })\n          .toCompileTo('abc');\n      });\n    });\n\n    describe('control access to prototype non-methods via \"allowedProtoProperties\" and \"allowProtoPropertiesByDefault', function() {\n      checkProtoPropertyAccess({});\n\n      describe('in compat-mode', function() {\n        checkProtoPropertyAccess({ compat: true });\n      });\n\n      function checkProtoPropertyAccess(compileOptions) {\n        it('should be prohibited by default and log a warning', function() {\n          var spy = sinon.spy(console, 'error');\n\n          expectTemplate('{{aProperty}}')\n            .withInput(new TestClass())\n            .withCompileOptions(compileOptions)\n            .toCompileTo('');\n\n          expect(spy.calledOnce).to.be.true();\n          expect(spy.args[0][0]).to.match(/Handlebars: Access has been denied/);\n        });\n\n        it('can be explicitly prohibited by default, which disables the warning', function() {\n          var spy = sinon.spy(console, 'error');\n\n          expectTemplate('{{aProperty}}')\n            .withInput(new TestClass())\n            .withCompileOptions(compileOptions)\n            .withRuntimeOptions({\n              allowProtoPropertiesByDefault: false\n            })\n            .toCompileTo('');\n\n          expect(spy.callCount).to.equal(0);\n        });\n\n        it('can be turned on, which disables the warning', function() {\n          var spy = sinon.spy(console, 'error');\n\n          expectTemplate('{{aProperty}}')\n            .withInput(new TestClass())\n            .withCompileOptions(compileOptions)\n            .withRuntimeOptions({\n              allowedProtoProperties: {\n                aProperty: true\n              }\n            })\n            .toCompileTo('propertyValue');\n\n          expect(spy.callCount).to.equal(0);\n        });\n\n        it('can be turned on by default, which disables the warning', function() {\n          var spy = sinon.spy(console, 'error');\n\n          expectTemplate('{{aProperty}}')\n            .withInput(new TestClass())\n            .withCompileOptions(compileOptions)\n            .withRuntimeOptions({\n              allowProtoPropertiesByDefault: true\n            })\n            .toCompileTo('propertyValue');\n\n          expect(spy.callCount).to.equal(0);\n        });\n\n        it('can be turned off, if turned on by default', function() {\n          expectTemplate('{{aProperty}}')\n            .withInput(new TestClass())\n            .withCompileOptions(compileOptions)\n            .withRuntimeOptions({\n              allowProtoPropertiesByDefault: true,\n              allowedProtoProperties: {\n                aProperty: false\n              }\n            })\n            .toCompileTo('');\n        });\n      }\n    });\n\n    describe('compatibility with old runtimes, that do not provide the function \"container.lookupProperty\"', function() {\n      beforeEach(function simulateRuntimeWithoutLookupProperty() {\n        var oldTemplateMethod = handlebarsEnv.template;\n        sinon.replace(handlebarsEnv, 'template', function(templateSpec) {\n          templateSpec.main = wrapToAdjustContainer(templateSpec.main);\n          return oldTemplateMethod.call(this, templateSpec);\n        });\n      });\n\n      afterEach(function() {\n        sinon.restore();\n      });\n\n      it('should work with simple properties', function() {\n        expectTemplate('{{aProperty}}')\n          .withInput({ aProperty: 'propertyValue' })\n          .toCompileTo('propertyValue');\n      });\n\n      it('should work with Array.prototype.length', function() {\n        expectTemplate('{{anArray.length}}')\n          .withInput({ anArray: ['a', 'b', 'c'] })\n          .toCompileTo('3');\n      });\n    });\n  });\n\n  describe('escapes template variables', function() {\n    it('in compat mode', function() {\n      expectTemplate(\"{{'a\\\\b'}}\")\n        .withCompileOptions({ compat: true })\n        .withInput({ 'a\\\\b': 'c' })\n        .toCompileTo('c');\n    });\n\n    it('in default mode', function() {\n      expectTemplate(\"{{'a\\\\b'}}\")\n        .withCompileOptions()\n        .withInput({ 'a\\\\b': 'c' })\n        .toCompileTo('c');\n    });\n    it('in default mode', function() {\n      expectTemplate(\"{{'a\\\\b'}}\")\n        .withCompileOptions({ strict: true })\n        .withInput({ 'a\\\\b': 'c' })\n        .toCompileTo('c');\n    });\n  });\n});\n\nfunction wrapToAdjustContainer(precompiledTemplateFunction) {\n  return function templateFunctionWrapper(container /*, more args */) {\n    delete container.lookupProperty;\n    return precompiledTemplateFunction.apply(this, arguments);\n  };\n}\n"], "fixing_code": ["import * as Utils from './utils';\nimport Exception from './exception';\nimport {\n  COMPILER_REVISION,\n  createFrame,\n  LAST_COMPATIBLE_COMPILER_REVISION,\n  REVISION_CHANGES\n} from './base';\nimport { moveHelperToHooks } from './helpers';\nimport { wrapHelper } from './internal/wrapHelper';\nimport {\n  createProtoAccessControl,\n  resultIsAllowed\n} from './internal/proto-access';\n\nexport function checkRevision(compilerInfo) {\n  const compilerRevision = (compilerInfo && compilerInfo[0]) || 1,\n    currentRevision = COMPILER_REVISION;\n\n  if (\n    compilerRevision >= LAST_COMPATIBLE_COMPILER_REVISION &&\n    compilerRevision <= COMPILER_REVISION\n  ) {\n    return;\n  }\n\n  if (compilerRevision < LAST_COMPATIBLE_COMPILER_REVISION) {\n    const runtimeVersions = REVISION_CHANGES[currentRevision],\n      compilerVersions = REVISION_CHANGES[compilerRevision];\n    throw new Exception(\n      'Template was precompiled with an older version of Handlebars than the current runtime. ' +\n        'Please update your precompiler to a newer version (' +\n        runtimeVersions +\n        ') or downgrade your runtime to an older version (' +\n        compilerVersions +\n        ').'\n    );\n  } else {\n    // Use the embedded version info since the runtime doesn't know about this revision yet\n    throw new Exception(\n      'Template was precompiled with a newer version of Handlebars than the current runtime. ' +\n        'Please update your runtime to a newer version (' +\n        compilerInfo[1] +\n        ').'\n    );\n  }\n}\n\nexport function template(templateSpec, env) {\n  /* istanbul ignore next */\n  if (!env) {\n    throw new Exception('No environment passed to template');\n  }\n  if (!templateSpec || !templateSpec.main) {\n    throw new Exception('Unknown template object: ' + typeof templateSpec);\n  }\n\n  templateSpec.main.decorator = templateSpec.main_d;\n\n  // Note: Using env.VM references rather than local var references throughout this section to allow\n  // for external users to override these as pseudo-supported APIs.\n  env.VM.checkRevision(templateSpec.compiler);\n\n  // backwards compatibility for precompiled templates with compiler-version 7 (<4.3.0)\n  const templateWasPrecompiledWithCompilerV7 =\n    templateSpec.compiler && templateSpec.compiler[0] === 7;\n\n  function invokePartialWrapper(partial, context, options) {\n    if (options.hash) {\n      context = Utils.extend({}, context, options.hash);\n      if (options.ids) {\n        options.ids[0] = true;\n      }\n    }\n    partial = env.VM.resolvePartial.call(this, partial, context, options);\n\n    let extendedOptions = Utils.extend({}, options, {\n      hooks: this.hooks,\n      protoAccessControl: this.protoAccessControl\n    });\n\n    let result = env.VM.invokePartial.call(\n      this,\n      partial,\n      context,\n      extendedOptions\n    );\n\n    if (result == null && env.compile) {\n      options.partials[options.name] = env.compile(\n        partial,\n        templateSpec.compilerOptions,\n        env\n      );\n      result = options.partials[options.name](context, extendedOptions);\n    }\n    if (result != null) {\n      if (options.indent) {\n        let lines = result.split('\\n');\n        for (let i = 0, l = lines.length; i < l; i++) {\n          if (!lines[i] && i + 1 === l) {\n            break;\n          }\n\n          lines[i] = options.indent + lines[i];\n        }\n        result = lines.join('\\n');\n      }\n      return result;\n    } else {\n      throw new Exception(\n        'The partial ' +\n          options.name +\n          ' could not be compiled when running in runtime-only mode'\n      );\n    }\n  }\n\n  // Just add water\n  let container = {\n    strict: function(obj, name, loc) {\n      if (!obj || !(name in obj)) {\n        throw new Exception('\"' + name + '\" not defined in ' + obj, {\n          loc: loc\n        });\n      }\n      return container.lookupProperty(obj, name);\n    },\n    lookupProperty: function(parent, propertyName) {\n      let result = parent[propertyName];\n      if (result == null) {\n        return result;\n      }\n      if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n        return result;\n      }\n\n      if (resultIsAllowed(result, container.protoAccessControl, propertyName)) {\n        return result;\n      }\n      return undefined;\n    },\n    lookup: function(depths, name) {\n      const len = depths.length;\n      for (let i = 0; i < len; i++) {\n        let result = depths[i] && container.lookupProperty(depths[i], name);\n        if (result != null) {\n          return depths[i][name];\n        }\n      }\n    },\n    lambda: function(current, context) {\n      return typeof current === 'function' ? current.call(context) : current;\n    },\n\n    escapeExpression: Utils.escapeExpression,\n    invokePartial: invokePartialWrapper,\n\n    fn: function(i) {\n      let ret = templateSpec[i];\n      ret.decorator = templateSpec[i + '_d'];\n      return ret;\n    },\n\n    programs: [],\n    program: function(i, data, declaredBlockParams, blockParams, depths) {\n      let programWrapper = this.programs[i],\n        fn = this.fn(i);\n      if (data || depths || blockParams || declaredBlockParams) {\n        programWrapper = wrapProgram(\n          this,\n          i,\n          fn,\n          data,\n          declaredBlockParams,\n          blockParams,\n          depths\n        );\n      } else if (!programWrapper) {\n        programWrapper = this.programs[i] = wrapProgram(this, i, fn);\n      }\n      return programWrapper;\n    },\n\n    data: function(value, depth) {\n      while (value && depth--) {\n        value = value._parent;\n      }\n      return value;\n    },\n    mergeIfNeeded: function(param, common) {\n      let obj = param || common;\n\n      if (param && common && param !== common) {\n        obj = Utils.extend({}, common, param);\n      }\n\n      return obj;\n    },\n    // An empty object to use as replacement for null-contexts\n    nullContext: Object.seal({}),\n\n    noop: env.VM.noop,\n    compilerInfo: templateSpec.compiler\n  };\n\n  function ret(context, options = {}) {\n    let data = options.data;\n\n    ret._setup(options);\n    if (!options.partial && templateSpec.useData) {\n      data = initData(context, data);\n    }\n    let depths,\n      blockParams = templateSpec.useBlockParams ? [] : undefined;\n    if (templateSpec.useDepths) {\n      if (options.depths) {\n        depths =\n          context != options.depths[0]\n            ? [context].concat(options.depths)\n            : options.depths;\n      } else {\n        depths = [context];\n      }\n    }\n\n    function main(context /*, options*/) {\n      return (\n        '' +\n        templateSpec.main(\n          container,\n          context,\n          container.helpers,\n          container.partials,\n          data,\n          blockParams,\n          depths\n        )\n      );\n    }\n\n    main = executeDecorators(\n      templateSpec.main,\n      main,\n      container,\n      options.depths || [],\n      data,\n      blockParams\n    );\n    return main(context, options);\n  }\n\n  ret.isTop = true;\n\n  ret._setup = function(options) {\n    if (!options.partial) {\n      let mergedHelpers = Utils.extend({}, env.helpers, options.helpers);\n      wrapHelpersToPassLookupProperty(mergedHelpers, container);\n      container.helpers = mergedHelpers;\n\n      if (templateSpec.usePartial) {\n        // Use mergeIfNeeded here to prevent compiling global partials multiple times\n        container.partials = container.mergeIfNeeded(\n          options.partials,\n          env.partials\n        );\n      }\n      if (templateSpec.usePartial || templateSpec.useDecorators) {\n        container.decorators = Utils.extend(\n          {},\n          env.decorators,\n          options.decorators\n        );\n      }\n\n      container.hooks = {};\n      container.protoAccessControl = createProtoAccessControl(options);\n\n      let keepHelperInHelpers =\n        options.allowCallsToHelperMissing ||\n        templateWasPrecompiledWithCompilerV7;\n      moveHelperToHooks(container, 'helperMissing', keepHelperInHelpers);\n      moveHelperToHooks(container, 'blockHelperMissing', keepHelperInHelpers);\n    } else {\n      container.protoAccessControl = options.protoAccessControl; // internal option\n      container.helpers = options.helpers;\n      container.partials = options.partials;\n      container.decorators = options.decorators;\n      container.hooks = options.hooks;\n    }\n  };\n\n  ret._child = function(i, data, blockParams, depths) {\n    if (templateSpec.useBlockParams && !blockParams) {\n      throw new Exception('must pass block params');\n    }\n    if (templateSpec.useDepths && !depths) {\n      throw new Exception('must pass parent depths');\n    }\n\n    return wrapProgram(\n      container,\n      i,\n      templateSpec[i],\n      data,\n      0,\n      blockParams,\n      depths\n    );\n  };\n  return ret;\n}\n\nexport function wrapProgram(\n  container,\n  i,\n  fn,\n  data,\n  declaredBlockParams,\n  blockParams,\n  depths\n) {\n  function prog(context, options = {}) {\n    let currentDepths = depths;\n    if (\n      depths &&\n      context != depths[0] &&\n      !(context === container.nullContext && depths[0] === null)\n    ) {\n      currentDepths = [context].concat(depths);\n    }\n\n    return fn(\n      container,\n      context,\n      container.helpers,\n      container.partials,\n      options.data || data,\n      blockParams && [options.blockParams].concat(blockParams),\n      currentDepths\n    );\n  }\n\n  prog = executeDecorators(fn, prog, container, depths, data, blockParams);\n\n  prog.program = i;\n  prog.depth = depths ? depths.length : 0;\n  prog.blockParams = declaredBlockParams || 0;\n  return prog;\n}\n\n/**\n * This is currently part of the official API, therefore implementation details should not be changed.\n */\nexport function resolvePartial(partial, context, options) {\n  if (!partial) {\n    if (options.name === '@partial-block') {\n      partial = options.data['partial-block'];\n    } else {\n      partial = options.partials[options.name];\n    }\n  } else if (!partial.call && !options.name) {\n    // This is a dynamic partial that returned a string\n    options.name = partial;\n    partial = options.partials[partial];\n  }\n  return partial;\n}\n\nexport function invokePartial(partial, context, options) {\n  // Use the current closure context to save the partial-block if this partial\n  const currentPartialBlock = options.data && options.data['partial-block'];\n  options.partial = true;\n  if (options.ids) {\n    options.data.contextPath = options.ids[0] || options.data.contextPath;\n  }\n\n  let partialBlock;\n  if (options.fn && options.fn !== noop) {\n    options.data = createFrame(options.data);\n    // Wrapper function to get access to currentPartialBlock from the closure\n    let fn = options.fn;\n    partialBlock = options.data['partial-block'] = function partialBlockWrapper(\n      context,\n      options = {}\n    ) {\n      // Restore the partial-block from the closure for the execution of the block\n      // i.e. the part inside the block of the partial call.\n      options.data = createFrame(options.data);\n      options.data['partial-block'] = currentPartialBlock;\n      return fn(context, options);\n    };\n    if (fn.partials) {\n      options.partials = Utils.extend({}, options.partials, fn.partials);\n    }\n  }\n\n  if (partial === undefined && partialBlock) {\n    partial = partialBlock;\n  }\n\n  if (partial === undefined) {\n    throw new Exception('The partial ' + options.name + ' could not be found');\n  } else if (partial instanceof Function) {\n    return partial(context, options);\n  }\n}\n\nexport function noop() {\n  return '';\n}\n\nfunction initData(context, data) {\n  if (!data || !('root' in data)) {\n    data = data ? createFrame(data) : {};\n    data.root = context;\n  }\n  return data;\n}\n\nfunction executeDecorators(fn, prog, container, depths, data, blockParams) {\n  if (fn.decorator) {\n    let props = {};\n    prog = fn.decorator(\n      prog,\n      props,\n      container,\n      depths && depths[0],\n      data,\n      blockParams,\n      depths\n    );\n    Utils.extend(prog, props);\n  }\n  return prog;\n}\n\nfunction wrapHelpersToPassLookupProperty(mergedHelpers, container) {\n  Object.keys(mergedHelpers).forEach(helperName => {\n    let helper = mergedHelpers[helperName];\n    mergedHelpers[helperName] = passLookupPropertyOption(helper, container);\n  });\n}\n\nfunction passLookupPropertyOption(helper, container) {\n  const lookupProperty = container.lookupProperty;\n  return wrapHelper(helper, options => {\n    return Utils.extend({ lookupProperty }, options);\n  });\n}\n", "describe('security issues', function() {\n  describe('GH-1495: Prevent Remote Code Execution via constructor', function() {\n    it('should not allow constructors to be accessed', function() {\n      expectTemplate('{{lookup (lookup this \"constructor\") \"name\"}}')\n        .withInput({})\n        .toCompileTo('');\n\n      expectTemplate('{{constructor.name}}')\n        .withInput({})\n        .toCompileTo('');\n    });\n\n    it('GH-1603: should not allow constructors to be accessed (lookup via toString)', function() {\n      expectTemplate('{{lookup (lookup this (list \"constructor\")) \"name\"}}')\n        .withInput({})\n        .withHelper('list', function(element) {\n          return [element];\n        })\n        .toCompileTo('');\n    });\n\n    it('should allow the \"constructor\" property to be accessed if it is an \"ownProperty\"', function() {\n      expectTemplate('{{constructor.name}}')\n        .withInput({ constructor: { name: 'here we go' } })\n        .toCompileTo('here we go');\n\n      expectTemplate('{{lookup (lookup this \"constructor\") \"name\"}}')\n        .withInput({ constructor: { name: 'here we go' } })\n        .toCompileTo('here we go');\n    });\n\n    it('should allow the \"constructor\" property to be accessed if it is an \"own property\"', function() {\n      expectTemplate('{{lookup (lookup this \"constructor\") \"name\"}}')\n        .withInput({ constructor: { name: 'here we go' } })\n        .toCompileTo('here we go');\n    });\n  });\n\n  describe('GH-1558: Prevent explicit call of helperMissing-helpers', function() {\n    if (!Handlebars.compile) {\n      return;\n    }\n\n    describe('without the option \"allowExplicitCallOfHelperMissing\"', function() {\n      it('should throw an exception when calling  \"{{helperMissing}}\" ', function() {\n        expectTemplate('{{helperMissing}}').toThrow(Error);\n      });\n\n      it('should throw an exception when calling  \"{{#helperMissing}}{{/helperMissing}}\" ', function() {\n        expectTemplate('{{#helperMissing}}{{/helperMissing}}').toThrow(Error);\n      });\n\n      it('should throw an exception when calling  \"{{blockHelperMissing \"abc\" .}}\" ', function() {\n        var functionCalls = [];\n        expect(function() {\n          var template = Handlebars.compile('{{blockHelperMissing \"abc\" .}}');\n          template({\n            fn: function() {\n              functionCalls.push('called');\n            }\n          });\n        }).to.throw(Error);\n        expect(functionCalls.length).to.equal(0);\n      });\n\n      it('should throw an exception when calling  \"{{#blockHelperMissing .}}{{/blockHelperMissing}}\"', function() {\n        expectTemplate('{{#blockHelperMissing .}}{{/blockHelperMissing}}')\n          .withInput({\n            fn: function() {\n              return 'functionInData';\n            }\n          })\n          .toThrow(Error);\n      });\n    });\n\n    describe('with the option \"allowCallsToHelperMissing\" set to true', function() {\n      it('should not throw an exception when calling  \"{{helperMissing}}\" ', function() {\n        var template = Handlebars.compile('{{helperMissing}}');\n        template({}, { allowCallsToHelperMissing: true });\n      });\n\n      it('should not throw an exception when calling  \"{{#helperMissing}}{{/helperMissing}}\" ', function() {\n        var template = Handlebars.compile(\n          '{{#helperMissing}}{{/helperMissing}}'\n        );\n        template({}, { allowCallsToHelperMissing: true });\n      });\n\n      it('should not throw an exception when calling  \"{{blockHelperMissing \"abc\" .}}\" ', function() {\n        var functionCalls = [];\n        var template = Handlebars.compile('{{blockHelperMissing \"abc\" .}}');\n        template(\n          {\n            fn: function() {\n              functionCalls.push('called');\n            }\n          },\n          { allowCallsToHelperMissing: true }\n        );\n        equals(functionCalls.length, 1);\n      });\n\n      it('should not throw an exception when calling  \"{{#blockHelperMissing .}}{{/blockHelperMissing}}\"', function() {\n        var template = Handlebars.compile(\n          '{{#blockHelperMissing true}}sdads{{/blockHelperMissing}}'\n        );\n        template({}, { allowCallsToHelperMissing: true });\n      });\n    });\n  });\n\n  describe('GH-1563', function() {\n    it('should not allow to access constructor after overriding via __defineGetter__', function() {\n      if ({}.__defineGetter__ == null || {}.__lookupGetter__ == null) {\n        return this.skip(); // Browser does not support this exploit anyway\n      }\n      expectTemplate(\n        '{{__defineGetter__ \"undefined\" valueOf }}' +\n          '{{#with __lookupGetter__ }}' +\n          '{{__defineGetter__ \"propertyIsEnumerable\" (this.bind (this.bind 1)) }}' +\n          '{{constructor.name}}' +\n          '{{/with}}'\n      )\n        .withInput({})\n        .toThrow(/Missing helper: \"__defineGetter__\"/);\n    });\n  });\n\n  describe('GH-1595: dangerous properties', function() {\n    var templates = [\n      '{{constructor}}',\n      '{{__defineGetter__}}',\n      '{{__defineSetter__}}',\n      '{{__lookupGetter__}}',\n      '{{__proto__}}',\n      '{{lookup this \"constructor\"}}',\n      '{{lookup this \"__defineGetter__\"}}',\n      '{{lookup this \"__defineSetter__\"}}',\n      '{{lookup this \"__lookupGetter__\"}}',\n      '{{lookup this \"__proto__\"}}'\n    ];\n\n    templates.forEach(function(template) {\n      describe('access should be denied to ' + template, function() {\n        it('by default', function() {\n          expectTemplate(template)\n            .withInput({})\n            .toCompileTo('');\n        });\n        it(' with proto-access enabled', function() {\n          expectTemplate(template)\n            .withInput({})\n            .withRuntimeOptions({\n              allowProtoPropertiesByDefault: true,\n              allowProtoMethodsByDefault: true\n            })\n            .toCompileTo('');\n        });\n      });\n    });\n  });\n  describe('GH-1631: disallow access to prototype functions', function() {\n    function TestClass() {}\n\n    TestClass.prototype.aProperty = 'propertyValue';\n    TestClass.prototype.aMethod = function() {\n      return 'returnValue';\n    };\n\n    beforeEach(function() {\n      handlebarsEnv.resetLoggedPropertyAccesses();\n    });\n\n    afterEach(function() {\n      sinon.restore();\n    });\n\n    describe('control access to prototype methods via \"allowedProtoMethods\"', function() {\n      checkProtoMethodAccess({});\n\n      describe('in compat mode', function() {\n        checkProtoMethodAccess({ compat: true });\n      });\n\n      function checkProtoMethodAccess(compileOptions) {\n        it('should be prohibited by default and log a warning', function() {\n          var spy = sinon.spy(console, 'error');\n\n          expectTemplate('{{aMethod}}')\n            .withInput(new TestClass())\n            .withCompileOptions(compileOptions)\n            .toCompileTo('');\n\n          expect(spy.calledOnce).to.be.true();\n          expect(spy.args[0][0]).to.match(/Handlebars: Access has been denied/);\n        });\n\n        it('should only log the warning once', function() {\n          var spy = sinon.spy(console, 'error');\n\n          expectTemplate('{{aMethod}}')\n            .withInput(new TestClass())\n            .withCompileOptions(compileOptions)\n            .toCompileTo('');\n\n          expectTemplate('{{aMethod}}')\n            .withInput(new TestClass())\n            .withCompileOptions(compileOptions)\n            .toCompileTo('');\n\n          expect(spy.calledOnce).to.be.true();\n          expect(spy.args[0][0]).to.match(/Handlebars: Access has been denied/);\n        });\n\n        it('can be allowed, which disables the warning', function() {\n          var spy = sinon.spy(console, 'error');\n\n          expectTemplate('{{aMethod}}')\n            .withInput(new TestClass())\n            .withCompileOptions(compileOptions)\n            .withRuntimeOptions({\n              allowedProtoMethods: {\n                aMethod: true\n              }\n            })\n            .toCompileTo('returnValue');\n\n          expect(spy.callCount).to.equal(0);\n        });\n\n        it('can be turned on by default, which disables the warning', function() {\n          var spy = sinon.spy(console, 'error');\n\n          expectTemplate('{{aMethod}}')\n            .withInput(new TestClass())\n            .withCompileOptions(compileOptions)\n            .withRuntimeOptions({\n              allowProtoMethodsByDefault: true\n            })\n            .toCompileTo('returnValue');\n\n          expect(spy.callCount).to.equal(0);\n        });\n\n        it('can be turned off by default, which disables the warning', function() {\n          var spy = sinon.spy(console, 'error');\n\n          expectTemplate('{{aMethod}}')\n            .withInput(new TestClass())\n            .withCompileOptions(compileOptions)\n            .withRuntimeOptions({\n              allowProtoMethodsByDefault: false\n            })\n            .toCompileTo('');\n\n          expect(spy.callCount).to.equal(0);\n        });\n\n        it('can be turned off, if turned on by default', function() {\n          expectTemplate('{{aMethod}}')\n            .withInput(new TestClass())\n            .withCompileOptions(compileOptions)\n            .withRuntimeOptions({\n              allowProtoMethodsByDefault: true,\n              allowedProtoMethods: {\n                aMethod: false\n              }\n            })\n            .toCompileTo('');\n        });\n      }\n\n      it('should cause the recursive lookup by default (in \"compat\" mode)', function() {\n        expectTemplate('{{#aString}}{{trim}}{{/aString}}')\n          .withInput({ aString: '  abc  ', trim: 'trim' })\n          .withCompileOptions({ compat: true })\n          .toCompileTo('trim');\n      });\n\n      it('should not cause the recursive lookup if allowed through options(in \"compat\" mode)', function() {\n        expectTemplate('{{#aString}}{{trim}}{{/aString}}')\n          .withInput({ aString: '  abc  ', trim: 'trim' })\n          .withCompileOptions({ compat: true })\n          .withRuntimeOptions({\n            allowedProtoMethods: {\n              trim: true\n            }\n          })\n          .toCompileTo('abc');\n      });\n    });\n\n    describe('control access to prototype non-methods via \"allowedProtoProperties\" and \"allowProtoPropertiesByDefault', function() {\n      checkProtoPropertyAccess({});\n\n      describe('in compat-mode', function() {\n        checkProtoPropertyAccess({ compat: true });\n      });\n\n      describe('in strict-mode', function() {\n        checkProtoPropertyAccess({ strict: true });\n      });\n\n      function checkProtoPropertyAccess(compileOptions) {\n        it('should be prohibited by default and log a warning', function() {\n          var spy = sinon.spy(console, 'error');\n\n          expectTemplate('{{aProperty}}')\n            .withInput(new TestClass())\n            .withCompileOptions(compileOptions)\n            .toCompileTo('');\n\n          expect(spy.calledOnce).to.be.true();\n          expect(spy.args[0][0]).to.match(/Handlebars: Access has been denied/);\n        });\n\n        it('can be explicitly prohibited by default, which disables the warning', function() {\n          var spy = sinon.spy(console, 'error');\n\n          expectTemplate('{{aProperty}}')\n            .withInput(new TestClass())\n            .withCompileOptions(compileOptions)\n            .withRuntimeOptions({\n              allowProtoPropertiesByDefault: false\n            })\n            .toCompileTo('');\n\n          expect(spy.callCount).to.equal(0);\n        });\n\n        it('can be turned on, which disables the warning', function() {\n          var spy = sinon.spy(console, 'error');\n\n          expectTemplate('{{aProperty}}')\n            .withInput(new TestClass())\n            .withCompileOptions(compileOptions)\n            .withRuntimeOptions({\n              allowedProtoProperties: {\n                aProperty: true\n              }\n            })\n            .toCompileTo('propertyValue');\n\n          expect(spy.callCount).to.equal(0);\n        });\n\n        it('can be turned on by default, which disables the warning', function() {\n          var spy = sinon.spy(console, 'error');\n\n          expectTemplate('{{aProperty}}')\n            .withInput(new TestClass())\n            .withCompileOptions(compileOptions)\n            .withRuntimeOptions({\n              allowProtoPropertiesByDefault: true\n            })\n            .toCompileTo('propertyValue');\n\n          expect(spy.callCount).to.equal(0);\n        });\n\n        it('can be turned off, if turned on by default', function() {\n          expectTemplate('{{aProperty}}')\n            .withInput(new TestClass())\n            .withCompileOptions(compileOptions)\n            .withRuntimeOptions({\n              allowProtoPropertiesByDefault: true,\n              allowedProtoProperties: {\n                aProperty: false\n              }\n            })\n            .toCompileTo('');\n        });\n      }\n    });\n\n    describe('compatibility with old runtimes, that do not provide the function \"container.lookupProperty\"', function() {\n      beforeEach(function simulateRuntimeWithoutLookupProperty() {\n        var oldTemplateMethod = handlebarsEnv.template;\n        sinon.replace(handlebarsEnv, 'template', function(templateSpec) {\n          templateSpec.main = wrapToAdjustContainer(templateSpec.main);\n          return oldTemplateMethod.call(this, templateSpec);\n        });\n      });\n\n      afterEach(function() {\n        sinon.restore();\n      });\n\n      it('should work with simple properties', function() {\n        expectTemplate('{{aProperty}}')\n          .withInput({ aProperty: 'propertyValue' })\n          .toCompileTo('propertyValue');\n      });\n\n      it('should work with Array.prototype.length', function() {\n        expectTemplate('{{anArray.length}}')\n          .withInput({ anArray: ['a', 'b', 'c'] })\n          .toCompileTo('3');\n      });\n    });\n  });\n\n  describe('escapes template variables', function() {\n    it('in compat mode', function() {\n      expectTemplate(\"{{'a\\\\b'}}\")\n        .withCompileOptions({ compat: true })\n        .withInput({ 'a\\\\b': 'c' })\n        .toCompileTo('c');\n    });\n\n    it('in default mode', function() {\n      expectTemplate(\"{{'a\\\\b'}}\")\n        .withCompileOptions()\n        .withInput({ 'a\\\\b': 'c' })\n        .toCompileTo('c');\n    });\n    it('in default mode', function() {\n      expectTemplate(\"{{'a\\\\b'}}\")\n        .withCompileOptions({ strict: true })\n        .withInput({ 'a\\\\b': 'c' })\n        .toCompileTo('c');\n    });\n  });\n});\n\nfunction wrapToAdjustContainer(precompiledTemplateFunction) {\n  return function templateFunctionWrapper(container /*, more args */) {\n    delete container.lookupProperty;\n    return precompiledTemplateFunction.apply(this, arguments);\n  };\n}\n"], "filenames": ["lib/handlebars/runtime.js", "spec/security.js"], "buggy_code_start_loc": [127, 300], "buggy_code_end_loc": [128, 300], "fixing_code_start_loc": [127, 301], "fixing_code_end_loc": [128, 305], "type": "NVD-CWE-noinfo", "message": "The package handlebars before 4.7.7 are vulnerable to Remote Code Execution (RCE) when selecting certain compiling options to compile templates coming from an untrusted source.", "other": {"cve": {"id": "CVE-2021-23369", "sourceIdentifier": "report@snyk.io", "published": "2021-04-12T14:15:14.383", "lastModified": "2021-06-08T13:54:19.493", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package handlebars before 4.7.7 are vulnerable to Remote Code Execution (RCE) when selecting certain compiling options to compile templates coming from an untrusted source."}, {"lang": "es", "value": "El paquete handlebars versiones anteriores a 4.7.7, son vulnerables a una Ejecuci\u00f3n de C\u00f3digo Remota (RCE) al seleccionar determinadas opciones de compilaci\u00f3n para compilar plantillas que provienen de una fuente no confiable"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:handlebarsjs:handlebars:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "4.7.7", "matchCriteriaId": "D57084A5-784A-4392-AF0D-6EB14CF4B573"}]}]}], "references": [{"url": "https://github.com/handlebars-lang/handlebars.js/commit/b6d3de7123eebba603e321f04afdbae608e8fea8", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/handlebars-lang/handlebars.js/commit/f0589701698268578199be25285b2ebea1c1e427", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210604-0008/", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARS-1074950", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARSBOWER-1074951", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARSNPM-1074952", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-HANDLEBARS-1056767", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/handlebars-lang/handlebars.js/commit/b6d3de7123eebba603e321f04afdbae608e8fea8"}}