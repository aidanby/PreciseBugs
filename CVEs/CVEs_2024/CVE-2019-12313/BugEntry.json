{"buggy_code": ["!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?t():\"function\"==typeof define&&define.amd?define(t):t()}(0,function(){\"use strict\";if(\"undefined\"!=typeof window){var e=window.$||window.jQuery||window.Zepto;e&&(e.fn.shave=function(e,t){return function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};if(!t)throw Error(\"maxHeight is required\");var i=\"string\"==typeof e?document.querySelectorAll(e):e;if(i){var o=n.character||\"\u2026\",a=n.classname||\"js-shave\",s=\"boolean\"!=typeof n.spaces||n.spaces,r='<span class=\"js-shave-char\">'.concat(o,\"</span>\");\"length\"in i||(i=[i]);for(var c=0;c<i.length;c+=1){var f=i[c],h=f.style,l=f.querySelector(\".\".concat(a)),d=void 0===f.textContent?\"innerText\":\"textContent\";l&&(f.removeChild(f.querySelector(\".js-shave-char\")),f[d]=f[d]);var v=f[d],g=s?v.split(\" \"):v;if(!(g.length<2)){var u=h.height;h.height=\"auto\";var p=h.maxHeight;if(h.maxHeight=\"none\",f.offsetHeight<=t)h.height=u,h.maxHeight=p;else{for(var y=g.length-1,j=0,m=void 0;j<y;)m=j+y+1>>1,f[d]=s?g.slice(0,m).join(\" \"):g.slice(0,m),f.insertAdjacentHTML(\"beforeend\",r),f.offsetHeight>t?y=s?m-1:m-2:j=m;f[d]=s?g.slice(0,y).join(\" \"):g.slice(0,y),f.insertAdjacentHTML(\"beforeend\",r);var H=s?\" \".concat(g.slice(y).join(\" \")):g.slice(y);f.insertAdjacentHTML(\"beforeend\",'<span class=\"'.concat(a,'\" style=\"display:none;\">').concat(H,\"</span>\")),h.height=u,h.maxHeight=p}}}}}(this,e,t),this})}});\n", "/**\n  shave - Shave is a javascript plugin that truncates multi-line text within a html element based on set max height\n  @version v2.5.2\n  @link https://github.com/dollarshaveclub/shave#readme\n  @author Jeff Wainwright <yowainwright@gmail.com> (jeffry.in)\n  @license MIT\n**/\nfunction shave(target, maxHeight) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!maxHeight) throw Error('maxHeight is required');\n  var els = typeof target === 'string' ? document.querySelectorAll(target) : target;\n  if (!els) return;\n  var character = opts.character || '\u2026';\n  var classname = opts.classname || 'js-shave';\n  var spaces = typeof opts.spaces === 'boolean' ? opts.spaces : true;\n  var charHtml = \"<span class=\\\"js-shave-char\\\">\".concat(character, \"</span>\");\n  if (!('length' in els)) els = [els];\n\n  for (var i = 0; i < els.length; i += 1) {\n    var el = els[i];\n    var styles = el.style;\n    var span = el.querySelector(\".\".concat(classname));\n    var textProp = el.textContent === undefined ? 'innerText' : 'textContent'; // If element text has already been shaved\n\n    if (span) {\n      // Remove the ellipsis to recapture the original text\n      el.removeChild(el.querySelector('.js-shave-char'));\n      el[textProp] = el[textProp]; // eslint-disable-line\n      // nuke span, recombine text\n    }\n\n    var fullText = el[textProp];\n    var words = spaces ? fullText.split(' ') : fullText; // If 0 or 1 words, we're done\n\n    if (words.length < 2) continue; // Temporarily remove any CSS height for text height calculation\n\n    var heightStyle = styles.height;\n    styles.height = 'auto';\n    var maxHeightStyle = styles.maxHeight;\n    styles.maxHeight = 'none'; // If already short enough, we're done\n\n    if (el.offsetHeight <= maxHeight) {\n      styles.height = heightStyle;\n      styles.maxHeight = maxHeightStyle;\n      continue;\n    } // Binary search for number of words which can fit in allotted height\n\n\n    var max = words.length - 1;\n    var min = 0;\n    var pivot = void 0;\n\n    while (min < max) {\n      pivot = min + max + 1 >> 1; // eslint-disable-line no-bitwise\n\n      el[textProp] = spaces ? words.slice(0, pivot).join(' ') : words.slice(0, pivot);\n      el.insertAdjacentHTML('beforeend', charHtml);\n      if (el.offsetHeight > maxHeight) max = spaces ? pivot - 1 : pivot - 2;else min = pivot;\n    }\n\n    el[textProp] = spaces ? words.slice(0, max).join(' ') : words.slice(0, max);\n    el.insertAdjacentHTML('beforeend', charHtml);\n    var diff = spaces ? \" \".concat(words.slice(max).join(' ')) : words.slice(max);\n    el.insertAdjacentHTML('beforeend', \"<span class=\\\"\".concat(classname, \"\\\" style=\\\"display:none;\\\">\").concat(diff, \"</span>\"));\n    styles.height = heightStyle;\n    styles.maxHeight = maxHeightStyle;\n  }\n}\n\nexport default shave;\n", "/**\n  shave - Shave is a javascript plugin that truncates multi-line text within a html element based on set max height\n  @version v2.5.2\n  @link https://github.com/dollarshaveclub/shave#readme\n  @author Jeff Wainwright <yowainwright@gmail.com> (jeffry.in)\n  @license MIT\n**/\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.shave = factory());\n}(this, (function () { 'use strict';\n\n  function shave(target, maxHeight) {\n    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!maxHeight) throw Error('maxHeight is required');\n    var els = typeof target === 'string' ? document.querySelectorAll(target) : target;\n    if (!els) return;\n    var character = opts.character || '\u2026';\n    var classname = opts.classname || 'js-shave';\n    var spaces = typeof opts.spaces === 'boolean' ? opts.spaces : true;\n    var charHtml = \"<span class=\\\"js-shave-char\\\">\".concat(character, \"</span>\");\n    if (!('length' in els)) els = [els];\n\n    for (var i = 0; i < els.length; i += 1) {\n      var el = els[i];\n      var styles = el.style;\n      var span = el.querySelector(\".\".concat(classname));\n      var textProp = el.textContent === undefined ? 'innerText' : 'textContent'; // If element text has already been shaved\n\n      if (span) {\n        // Remove the ellipsis to recapture the original text\n        el.removeChild(el.querySelector('.js-shave-char'));\n        el[textProp] = el[textProp]; // eslint-disable-line\n        // nuke span, recombine text\n      }\n\n      var fullText = el[textProp];\n      var words = spaces ? fullText.split(' ') : fullText; // If 0 or 1 words, we're done\n\n      if (words.length < 2) continue; // Temporarily remove any CSS height for text height calculation\n\n      var heightStyle = styles.height;\n      styles.height = 'auto';\n      var maxHeightStyle = styles.maxHeight;\n      styles.maxHeight = 'none'; // If already short enough, we're done\n\n      if (el.offsetHeight <= maxHeight) {\n        styles.height = heightStyle;\n        styles.maxHeight = maxHeightStyle;\n        continue;\n      } // Binary search for number of words which can fit in allotted height\n\n\n      var max = words.length - 1;\n      var min = 0;\n      var pivot = void 0;\n\n      while (min < max) {\n        pivot = min + max + 1 >> 1; // eslint-disable-line no-bitwise\n\n        el[textProp] = spaces ? words.slice(0, pivot).join(' ') : words.slice(0, pivot);\n        el.insertAdjacentHTML('beforeend', charHtml);\n        if (el.offsetHeight > maxHeight) max = spaces ? pivot - 1 : pivot - 2;else min = pivot;\n      }\n\n      el[textProp] = spaces ? words.slice(0, max).join(' ') : words.slice(0, max);\n      el.insertAdjacentHTML('beforeend', charHtml);\n      var diff = spaces ? \" \".concat(words.slice(max).join(' ')) : words.slice(max);\n      el.insertAdjacentHTML('beforeend', \"<span class=\\\"\".concat(classname, \"\\\" style=\\\"display:none;\\\">\").concat(diff, \"</span>\"));\n      styles.height = heightStyle;\n      styles.maxHeight = maxHeightStyle;\n    }\n  }\n\n  return shave;\n\n})));\n", "!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):e.shave=t()}(this,function(){\"use strict\";return function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};if(!t)throw Error(\"maxHeight is required\");var i=\"string\"==typeof e?document.querySelectorAll(e):e;if(i){var o=n.character||\"\u2026\",a=n.classname||\"js-shave\",s=\"boolean\"!=typeof n.spaces||n.spaces,r='<span class=\"js-shave-char\">'.concat(o,\"</span>\");\"length\"in i||(i=[i]);for(var c=0;c<i.length;c+=1){var h=i[c],l=h.style,f=h.querySelector(\".\".concat(a)),d=void 0===h.textContent?\"innerText\":\"textContent\";f&&(h.removeChild(h.querySelector(\".js-shave-char\")),h[d]=h[d]);var v=h[d],g=s?v.split(\" \"):v;if(!(g.length<2)){var p=l.height;l.height=\"auto\";var u=l.maxHeight;if(l.maxHeight=\"none\",h.offsetHeight<=t)l.height=p,l.maxHeight=u;else{for(var m=g.length-1,y=0,j=void 0;y<m;)j=y+m+1>>1,h[d]=s?g.slice(0,j).join(\" \"):g.slice(0,j),h.insertAdjacentHTML(\"beforeend\",r),h.offsetHeight>t?m=s?j-1:j-2:y=j;h[d]=s?g.slice(0,m).join(\" \"):g.slice(0,m),h.insertAdjacentHTML(\"beforeend\",r);var x=s?\" \".concat(g.slice(m).join(\" \")):g.slice(m);h.insertAdjacentHTML(\"beforeend\",'<span class=\"'.concat(a,'\" style=\"display:none;\">').concat(x,\"</span>\")),l.height=p,l.maxHeight=u}}}}}});\n", "{\n  \"name\": \"shave\",\n  \"version\": \"2.5.2\",\n  \"description\": \"Shave is a javascript plugin that truncates multi-line text within a html element based on set max height\",\n  \"main\": \"dist/shave.js\",\n  \"module\": \"dist/shave.es.js\",\n  \"unpkg\": \"dist/shave.min.js\",\n  \"files\": [\n    \"dist\",\n    \"src\",\n    \"types\"\n  ],\n  \"types\": \"types/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"rollup --config rollup.config.js\",\n    \"chore:delete-changelog-branch\": \"if git show-ref --quiet refs/heads/chore-changelog; then git branch -D chore-changelog; fi\",\n    \"chore:branch\": \"git checkout -b chore-changelog\",\n    \"chore:changelog\": \"conventional-changelog -p eslint -i CHANGELOG.md -s -r 0\",\n    \"chore:setup-next-work\": \"git checkout master && npm run chore:delete-changelog-branch\",\n    \"chore:pr\": \"git add . && git commit -m '[chore] updates changelog' --no-verify && git push origin chore-changelog -f\",\n    \"chore:setup-changelog\": \"git checkout master && git pull\",\n    \"chore\": \"npm run chore:delete-changelog-branch && npm run chore:branch && npm run chore:changelog && npm run chore:pr && npm run chore:setup-next-work\",\n    \"eslint\": \"eslint . --fix\",\n    \"eslint:ci\": \"eslint .\",\n    \"postpublish\": \"git tag $npm_package_version && git push origin --tags && npm run chore\",\n    \"prepush\": \"npm run build && npm test && npm run eslint:ci\",\n    \"test\": \"npm run test:acceptance && npm run test:es-check\",\n    \"test:acceptance\": \"node ./scripts/acceptance.js --coverage\",\n    \"test:es-check\": \"es-check es5 dist/shave.min.js dist/shave.js dist/jquery.shave.js dist/jquery.shave.min.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/dollarshaveclub/shave.git\"\n  },\n  \"keywords\": [\n    \"ellipsis\",\n    \"truncate\",\n    \"truncation\",\n    \"truncated\",\n    \"semantic\",\n    \"js\",\n    \"content\",\n    \"shorten\",\n    \"javascript\",\n    \"text\",\n    \"shave\",\n    \"trim\"\n  ],\n  \"author\": \"Jeff Wainwright <yowainwright@gmail.com> (jeffry.in)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/dollarshaveclub/shave/issues\"\n  },\n  \"homepage\": \"https://github.com/dollarshaveclub/shave#readme\",\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.0.0-beta.44\",\n    \"@babel/preset-env\": \"^7.0.0-beta.40\",\n    \"babel-core\": \"^7.0.0-bridge.0\",\n    \"conventional-changelog-cli\": \"^2.0.11\",\n    \"es-check\": \"5.0.0\",\n    \"eslint\": \"^5.0.0\",\n    \"eslint-config-dollarshaveclub\": \"^3.1.0\",\n    \"husky\": \"^1.0.0\",\n    \"node-qunit-phantomjs\": \"^2.0.0\",\n    \"rollup\": \"^1.0.0\",\n    \"rollup-plugin-babel\": \"^4.0.0-beta.0\",\n    \"rollup-plugin-uglify\": \"^6.0.1\",\n    \"typescript\": \"^3.0.1\"\n  }\n}\n", "export default function shave (target, maxHeight, opts = {}) {\n  if (!maxHeight) throw Error('maxHeight is required')\n  let els = (typeof target === 'string') ? document.querySelectorAll(target) : target\n  if (!els) return\n\n  const character = opts.character || '\u2026'\n  const classname = opts.classname || 'js-shave'\n  const spaces = typeof opts.spaces === 'boolean' ? opts.spaces : true\n  const charHtml = `<span class=\"js-shave-char\">${character}</span>`\n\n  if (!('length' in els)) els = [els]\n  for (let i = 0; i < els.length; i += 1) {\n    const el = els[i]\n    const styles = el.style\n    const span = el.querySelector(`.${classname}`)\n    const textProp = el.textContent === undefined ? 'innerText' : 'textContent'\n\n    // If element text has already been shaved\n    if (span) {\n      // Remove the ellipsis to recapture the original text\n      el.removeChild(el.querySelector('.js-shave-char'))\n      el[textProp] = el[textProp] // eslint-disable-line\n      // nuke span, recombine text\n    }\n\n    const fullText = el[textProp]\n    const words = spaces ? fullText.split(' ') : fullText\n    // If 0 or 1 words, we're done\n    if (words.length < 2) continue\n\n    // Temporarily remove any CSS height for text height calculation\n    const heightStyle = styles.height\n    styles.height = 'auto'\n    const maxHeightStyle = styles.maxHeight\n    styles.maxHeight = 'none'\n\n    // If already short enough, we're done\n    if (el.offsetHeight <= maxHeight) {\n      styles.height = heightStyle\n      styles.maxHeight = maxHeightStyle\n      continue\n    }\n\n    // Binary search for number of words which can fit in allotted height\n    let max = words.length - 1\n    let min = 0\n    let pivot\n    while (min < max) {\n      pivot = (min + max + 1) >> 1 // eslint-disable-line no-bitwise\n      el[textProp] = spaces ? words.slice(0, pivot).join(' ') : words.slice(0, pivot)\n      el.insertAdjacentHTML('beforeend', charHtml)\n      if (el.offsetHeight > maxHeight) max = spaces ? pivot - 1 : pivot - 2\n      else min = pivot\n    }\n\n    el[textProp] = spaces ? words.slice(0, max).join(' ') : words.slice(0, max)\n    el.insertAdjacentHTML('beforeend', charHtml)\n    const diff = spaces ? ` ${words.slice(max).join(' ')}` : words.slice(max)\n\n    // https://stackoverflow.com/questions/476821/is-a-dom-text-node-guaranteed-to-not-be-interpreted-as-html\n    const shavedText = document.createTextNode(diff)\n    const elWithShavedText = document.createElement('span')\n    elWithShavedText.classList.add(classname)\n    elWithShavedText.style.display = 'none'\n    elWithShavedText.appendChild(shavedText)\n    el.insertAdjacentElement('beforeend', elWithShavedText)\n\n    styles.height = heightStyle\n    styles.maxHeight = maxHeightStyle\n  }\n}\n"], "fixing_code": ["!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?t():\"function\"==typeof define&&define.amd?define(t):t()}(0,function(){\"use strict\";if(\"undefined\"!=typeof window){var e=window.$||window.jQuery||window.Zepto;e&&(e.fn.shave=function(e,t){return function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};if(!t)throw Error(\"maxHeight is required\");var i=\"string\"==typeof e?document.querySelectorAll(e):e;if(i){var o=n.character||\"\u2026\",a=n.classname||\"js-shave\",r=\"boolean\"!=typeof n.spaces||n.spaces,s='<span class=\"js-shave-char\">'.concat(o,\"</span>\");\"length\"in i||(i=[i]);for(var c=0;c<i.length;c+=1){var d=i[c],h=d.style,f=d.querySelector(\".\".concat(a)),l=void 0===d.textContent?\"innerText\":\"textContent\";f&&(d.removeChild(d.querySelector(\".js-shave-char\")),d[l]=d[l]);var u=d[l],v=r?u.split(\" \"):u;if(!(v.length<2)){var g=h.height;h.height=\"auto\";var p=h.maxHeight;if(h.maxHeight=\"none\",d.offsetHeight<=t)h.height=g,h.maxHeight=p;else{for(var m=v.length-1,y=0,j=void 0;y<m;)j=y+m+1>>1,d[l]=r?v.slice(0,j).join(\" \"):v.slice(0,j),d.insertAdjacentHTML(\"beforeend\",s),d.offsetHeight>t?m=r?j-1:j-2:y=j;d[l]=r?v.slice(0,m).join(\" \"):v.slice(0,m),d.insertAdjacentHTML(\"beforeend\",s);var x=r?\" \".concat(v.slice(m).join(\" \")):v.slice(m),w=document.createTextNode(x),H=document.createElement(\"span\");H.classList.add(a),H.style.display=\"none\",H.appendChild(w),d.insertAdjacentElement(\"beforeend\",H),h.height=g,h.maxHeight=p}}}}}(this,e,t),this})}});\n", "/**\n  shave - Shave is a javascript plugin that truncates multi-line text within a html element based on set max height\n  @version v2.5.3\n  @link https://github.com/dollarshaveclub/shave#readme\n  @author Jeff Wainwright <yowainwright@gmail.com> (jeffry.in)\n  @license MIT\n**/\nfunction shave(target, maxHeight) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!maxHeight) throw Error('maxHeight is required');\n  var els = typeof target === 'string' ? document.querySelectorAll(target) : target;\n  if (!els) return;\n  var character = opts.character || '\u2026';\n  var classname = opts.classname || 'js-shave';\n  var spaces = typeof opts.spaces === 'boolean' ? opts.spaces : true;\n  var charHtml = \"<span class=\\\"js-shave-char\\\">\".concat(character, \"</span>\");\n  if (!('length' in els)) els = [els];\n\n  for (var i = 0; i < els.length; i += 1) {\n    var el = els[i];\n    var styles = el.style;\n    var span = el.querySelector(\".\".concat(classname));\n    var textProp = el.textContent === undefined ? 'innerText' : 'textContent'; // If element text has already been shaved\n\n    if (span) {\n      // Remove the ellipsis to recapture the original text\n      el.removeChild(el.querySelector('.js-shave-char'));\n      el[textProp] = el[textProp]; // eslint-disable-line\n      // nuke span, recombine text\n    }\n\n    var fullText = el[textProp];\n    var words = spaces ? fullText.split(' ') : fullText; // If 0 or 1 words, we're done\n\n    if (words.length < 2) continue; // Temporarily remove any CSS height for text height calculation\n\n    var heightStyle = styles.height;\n    styles.height = 'auto';\n    var maxHeightStyle = styles.maxHeight;\n    styles.maxHeight = 'none'; // If already short enough, we're done\n\n    if (el.offsetHeight <= maxHeight) {\n      styles.height = heightStyle;\n      styles.maxHeight = maxHeightStyle;\n      continue;\n    } // Binary search for number of words which can fit in allotted height\n\n\n    var max = words.length - 1;\n    var min = 0;\n    var pivot = void 0;\n\n    while (min < max) {\n      pivot = min + max + 1 >> 1; // eslint-disable-line no-bitwise\n\n      el[textProp] = spaces ? words.slice(0, pivot).join(' ') : words.slice(0, pivot);\n      el.insertAdjacentHTML('beforeend', charHtml);\n      if (el.offsetHeight > maxHeight) max = spaces ? pivot - 1 : pivot - 2;else min = pivot;\n    }\n\n    el[textProp] = spaces ? words.slice(0, max).join(' ') : words.slice(0, max);\n    el.insertAdjacentHTML('beforeend', charHtml);\n    var diff = spaces ? \" \".concat(words.slice(max).join(' ')) : words.slice(max);\n    var shavedText = document.createTextNode(diff);\n    var elWithShavedText = document.createElement('span');\n    elWithShavedText.classList.add(classname);\n    elWithShavedText.style.display = 'none';\n    elWithShavedText.appendChild(shavedText);\n    el.insertAdjacentElement('beforeend', elWithShavedText);\n    styles.height = heightStyle;\n    styles.maxHeight = maxHeightStyle;\n  }\n}\n\nexport default shave;\n", "/**\n  shave - Shave is a javascript plugin that truncates multi-line text within a html element based on set max height\n  @version v2.5.3\n  @link https://github.com/dollarshaveclub/shave#readme\n  @author Jeff Wainwright <yowainwright@gmail.com> (jeffry.in)\n  @license MIT\n**/\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.shave = factory());\n}(this, (function () { 'use strict';\n\n  function shave(target, maxHeight) {\n    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!maxHeight) throw Error('maxHeight is required');\n    var els = typeof target === 'string' ? document.querySelectorAll(target) : target;\n    if (!els) return;\n    var character = opts.character || '\u2026';\n    var classname = opts.classname || 'js-shave';\n    var spaces = typeof opts.spaces === 'boolean' ? opts.spaces : true;\n    var charHtml = \"<span class=\\\"js-shave-char\\\">\".concat(character, \"</span>\");\n    if (!('length' in els)) els = [els];\n\n    for (var i = 0; i < els.length; i += 1) {\n      var el = els[i];\n      var styles = el.style;\n      var span = el.querySelector(\".\".concat(classname));\n      var textProp = el.textContent === undefined ? 'innerText' : 'textContent'; // If element text has already been shaved\n\n      if (span) {\n        // Remove the ellipsis to recapture the original text\n        el.removeChild(el.querySelector('.js-shave-char'));\n        el[textProp] = el[textProp]; // eslint-disable-line\n        // nuke span, recombine text\n      }\n\n      var fullText = el[textProp];\n      var words = spaces ? fullText.split(' ') : fullText; // If 0 or 1 words, we're done\n\n      if (words.length < 2) continue; // Temporarily remove any CSS height for text height calculation\n\n      var heightStyle = styles.height;\n      styles.height = 'auto';\n      var maxHeightStyle = styles.maxHeight;\n      styles.maxHeight = 'none'; // If already short enough, we're done\n\n      if (el.offsetHeight <= maxHeight) {\n        styles.height = heightStyle;\n        styles.maxHeight = maxHeightStyle;\n        continue;\n      } // Binary search for number of words which can fit in allotted height\n\n\n      var max = words.length - 1;\n      var min = 0;\n      var pivot = void 0;\n\n      while (min < max) {\n        pivot = min + max + 1 >> 1; // eslint-disable-line no-bitwise\n\n        el[textProp] = spaces ? words.slice(0, pivot).join(' ') : words.slice(0, pivot);\n        el.insertAdjacentHTML('beforeend', charHtml);\n        if (el.offsetHeight > maxHeight) max = spaces ? pivot - 1 : pivot - 2;else min = pivot;\n      }\n\n      el[textProp] = spaces ? words.slice(0, max).join(' ') : words.slice(0, max);\n      el.insertAdjacentHTML('beforeend', charHtml);\n      var diff = spaces ? \" \".concat(words.slice(max).join(' ')) : words.slice(max);\n      var shavedText = document.createTextNode(diff);\n      var elWithShavedText = document.createElement('span');\n      elWithShavedText.classList.add(classname);\n      elWithShavedText.style.display = 'none';\n      elWithShavedText.appendChild(shavedText);\n      el.insertAdjacentElement('beforeend', elWithShavedText);\n      styles.height = heightStyle;\n      styles.maxHeight = maxHeightStyle;\n    }\n  }\n\n  return shave;\n\n})));\n", "!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):e.shave=t()}(this,function(){\"use strict\";return function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};if(!t)throw Error(\"maxHeight is required\");var i=\"string\"==typeof e?document.querySelectorAll(e):e;if(i){var o=n.character||\"\u2026\",a=n.classname||\"js-shave\",r=\"boolean\"!=typeof n.spaces||n.spaces,s='<span class=\"js-shave-char\">'.concat(o,\"</span>\");\"length\"in i||(i=[i]);for(var c=0;c<i.length;c+=1){var h=i[c],l=h.style,d=h.querySelector(\".\".concat(a)),f=void 0===h.textContent?\"innerText\":\"textContent\";d&&(h.removeChild(h.querySelector(\".js-shave-char\")),h[f]=h[f]);var v=h[f],g=r?v.split(\" \"):v;if(!(g.length<2)){var u=l.height;l.height=\"auto\";var p=l.maxHeight;if(l.maxHeight=\"none\",h.offsetHeight<=t)l.height=u,l.maxHeight=p;else{for(var m=g.length-1,x=0,y=void 0;x<m;)y=x+m+1>>1,h[f]=r?g.slice(0,y).join(\" \"):g.slice(0,y),h.insertAdjacentHTML(\"beforeend\",s),h.offsetHeight>t?m=r?y-1:y-2:x=y;h[f]=r?g.slice(0,m).join(\" \"):g.slice(0,m),h.insertAdjacentHTML(\"beforeend\",s);var j=r?\" \".concat(g.slice(m).join(\" \")):g.slice(m),H=document.createTextNode(j),b=document.createElement(\"span\");b.classList.add(a),b.style.display=\"none\",b.appendChild(H),h.insertAdjacentElement(\"beforeend\",b),l.height=u,l.maxHeight=p}}}}}});\n", "{\n  \"name\": \"shave\",\n  \"version\": \"2.5.3\",\n  \"description\": \"Shave is a javascript plugin that truncates multi-line text within a html element based on set max height\",\n  \"main\": \"dist/shave.js\",\n  \"module\": \"dist/shave.es.js\",\n  \"unpkg\": \"dist/shave.min.js\",\n  \"files\": [\n    \"dist\",\n    \"src\",\n    \"types\"\n  ],\n  \"types\": \"types/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"rollup --config rollup.config.js\",\n    \"chore:delete-changelog-branch\": \"if git show-ref --quiet refs/heads/chore-changelog; then git branch -D chore-changelog; fi\",\n    \"chore:branch\": \"git checkout -b chore-changelog\",\n    \"chore:changelog\": \"conventional-changelog -p eslint -i CHANGELOG.md -s -r 0\",\n    \"chore:setup-next-work\": \"git checkout master && npm run chore:delete-changelog-branch\",\n    \"chore:pr\": \"git add . && git commit -m '[chore] updates changelog' --no-verify && git push origin chore-changelog -f\",\n    \"chore:setup-changelog\": \"git checkout master && git pull\",\n    \"chore\": \"npm run chore:delete-changelog-branch && npm run chore:branch && npm run chore:changelog && npm run chore:pr && npm run chore:setup-next-work\",\n    \"eslint\": \"eslint . --fix\",\n    \"eslint:ci\": \"eslint .\",\n    \"postpublish\": \"git tag $npm_package_version && git push origin --tags && npm run chore\",\n    \"prepush\": \"npm run build && npm test && npm run eslint:ci\",\n    \"test\": \"npm run test:acceptance && npm run test:es-check\",\n    \"test:acceptance\": \"node ./scripts/acceptance.js --coverage\",\n    \"test:es-check\": \"es-check es5 dist/shave.min.js dist/shave.js dist/jquery.shave.js dist/jquery.shave.min.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/dollarshaveclub/shave.git\"\n  },\n  \"keywords\": [\n    \"ellipsis\",\n    \"truncate\",\n    \"truncation\",\n    \"truncated\",\n    \"semantic\",\n    \"js\",\n    \"content\",\n    \"shorten\",\n    \"javascript\",\n    \"text\",\n    \"shave\",\n    \"trim\"\n  ],\n  \"author\": \"Jeff Wainwright <yowainwright@gmail.com> (jeffry.in)\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/dollarshaveclub/shave/issues\"\n  },\n  \"homepage\": \"https://github.com/dollarshaveclub/shave#readme\",\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.0.0-beta.44\",\n    \"@babel/preset-env\": \"^7.0.0-beta.40\",\n    \"babel-core\": \"^7.0.0-bridge.0\",\n    \"conventional-changelog-cli\": \"^2.0.11\",\n    \"es-check\": \"5.0.0\",\n    \"eslint\": \"^5.0.0\",\n    \"eslint-config-dollarshaveclub\": \"^3.1.0\",\n    \"husky\": \"^1.0.0\",\n    \"node-qunit-phantomjs\": \"^2.0.0\",\n    \"rollup\": \"^1.0.0\",\n    \"rollup-plugin-babel\": \"^4.0.0-beta.0\",\n    \"rollup-plugin-uglify\": \"^6.0.1\",\n    \"typescript\": \"^3.0.1\"\n  }\n}\n", "export default function shave (target, maxHeight, opts = {}) {\n  if (!maxHeight) throw Error('maxHeight is required')\n  let els = (typeof target === 'string') ? document.querySelectorAll(target) : target\n  if (!els) return\n\n  const character = opts.character || '\u2026'\n  const classname = opts.classname || 'js-shave'\n  const spaces = typeof opts.spaces === 'boolean' ? opts.spaces : true\n  const charHtml = `<span class=\"js-shave-char\">${character}</span>`\n\n  if (!('length' in els)) els = [els]\n  for (let i = 0; i < els.length; i += 1) {\n    const el = els[i]\n    const styles = el.style\n    const span = el.querySelector(`.${classname}`)\n    const textProp = el.textContent === undefined ? 'innerText' : 'textContent'\n\n    // If element text has already been shaved\n    if (span) {\n      // Remove the ellipsis to recapture the original text\n      el.removeChild(el.querySelector('.js-shave-char'))\n      el[textProp] = el[textProp] // eslint-disable-line\n      // nuke span, recombine text\n    }\n\n    const fullText = el[textProp]\n    const words = spaces ? fullText.split(' ') : fullText\n    // If 0 or 1 words, we're done\n    if (words.length < 2) continue\n\n    // Temporarily remove any CSS height for text height calculation\n    const heightStyle = styles.height\n    styles.height = 'auto'\n    const maxHeightStyle = styles.maxHeight\n    styles.maxHeight = 'none'\n\n    // If already short enough, we're done\n    if (el.offsetHeight <= maxHeight) {\n      styles.height = heightStyle\n      styles.maxHeight = maxHeightStyle\n      continue\n    }\n\n    // Binary search for number of words which can fit in allotted height\n    let max = words.length - 1\n    let min = 0\n    let pivot\n    while (min < max) {\n      pivot = (min + max + 1) >> 1 // eslint-disable-line no-bitwise\n      el[textProp] = spaces ? words.slice(0, pivot).join(' ') : words.slice(0, pivot)\n      el.insertAdjacentHTML('beforeend', charHtml)\n      if (el.offsetHeight > maxHeight) max = spaces ? pivot - 1 : pivot - 2\n      else min = pivot\n    }\n\n    el[textProp] = spaces ? words.slice(0, max).join(' ') : words.slice(0, max)\n    el.insertAdjacentHTML('beforeend', charHtml)\n    const diff = spaces ? ` ${words.slice(max).join(' ')}` : words.slice(max)\n\n    const shavedText = document.createTextNode(diff)\n    const elWithShavedText = document.createElement('span')\n    elWithShavedText.classList.add(classname)\n    elWithShavedText.style.display = 'none'\n    elWithShavedText.appendChild(shavedText)\n    el.insertAdjacentElement('beforeend', elWithShavedText)\n\n    styles.height = heightStyle\n    styles.maxHeight = maxHeightStyle\n  }\n}\n"], "filenames": ["dist/jquery.shave.min.js", "dist/shave.es.js", "dist/shave.js", "dist/shave.min.js", "package.json", "src/shave.js"], "buggy_code_start_loc": [1, 3, 3, 1, 3, 60], "buggy_code_end_loc": [2, 65, 71, 2, 4, 61], "fixing_code_start_loc": [1, 3, 3, 1, 3, 59], "fixing_code_end_loc": [2, 70, 76, 2, 4, 59], "type": "CWE-79", "message": "XSS exists in Shave before 2.5.3 because output encoding is mishandled during the overwrite of an HTML element.", "other": {"cve": {"id": "CVE-2019-12313", "sourceIdentifier": "cve@mitre.org", "published": "2019-05-24T14:29:00.327", "lastModified": "2019-05-28T15:05:17.950", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "XSS exists in Shave before 2.5.3 because output encoding is mishandled during the overwrite of an HTML element."}, {"lang": "es", "value": "Se presenta una vulnerabilidad de tipo XSS en Shave anterior a la versi\u00f3n 2.5.3, porque la codificaci\u00f3n de salida es manejada inapropiadamente durante la sobrescritura de un elemento HTML."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dollarshaveclub:shave:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.5.3", "matchCriteriaId": "B9D6BF53-2BD8-46E0-8012-6843BF1BFB9E"}]}]}], "references": [{"url": "https://github.com/dollarshaveclub/shave/commit/da7371b0531ba14eae48ef1bb1456a3de4cfa954#diff-074799b511e4b61923dfd3f2a3bf9b54R67", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dollarshaveclub/shave/compare/852b537...da7371b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.npmjs.com/advisories/822", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dollarshaveclub/shave/commit/da7371b0531ba14eae48ef1bb1456a3de4cfa954#diff-074799b511e4b61923dfd3f2a3bf9b54R67"}}