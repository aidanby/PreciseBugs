{"buggy_code": ["<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\AdminBundle\\Controller\\Searchadmin;\n\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\AdminController;\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\Traits\\AdminStyleTrait;\nuse Pimcore\\Bundle\\AdminBundle\\Helper\\GridHelperService;\nuse Pimcore\\Config;\nuse Pimcore\\Db\\Helper;\nuse Pimcore\\Event\\Admin\\ElementAdminStyleEvent;\nuse Pimcore\\Event\\AdminEvents;\nuse Pimcore\\Model\\Asset;\nuse Pimcore\\Model\\DataObject;\nuse Pimcore\\Model\\Document;\nuse Pimcore\\Model\\Element;\nuse Pimcore\\Model\\Search\\Backend\\Data;\nuse Symfony\\Component\\EventDispatcher\\GenericEvent;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface;\n\n/**\n * @Route(\"/search\")\n *\n * @internal\n */\nclass SearchController extends AdminController\n{\n    use AdminStyleTrait;\n\n    /**\n     * @Route(\"/find\", name=\"pimcore_admin_searchadmin_search_find\", methods={\"GET\", \"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     *\n     * @todo: $conditionTypeParts could be undefined\n     *\n     * @todo: $conditionSubtypeParts could be undefined\n     *\n     * @todo: $conditionClassnameParts could be undefined\n     *\n     * @todo: $data could be undefined\n     */\n    public function findAction(Request $request, EventDispatcherInterface $eventDispatcher, GridHelperService $gridHelperService)\n    {\n        $allParams = array_merge($request->request->all(), $request->query->all());\n\n        $requestedLanguage = $allParams['language'] ?? null;\n        if ($requestedLanguage) {\n            if ($requestedLanguage != 'default') {\n                $request->setLocale($requestedLanguage);\n            }\n        }\n\n        $filterPrepareEvent = new GenericEvent($this, [\n            'requestParams' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($filterPrepareEvent, AdminEvents::SEARCH_LIST_BEFORE_FILTER_PREPARE);\n\n        $allParams = $filterPrepareEvent->getArgument('requestParams');\n\n        $query = $this->filterQueryParam($allParams['query'] ?? '');\n\n        $types = explode(',', $allParams['type'] ?? '');\n        $subtypes = explode(',', $allParams['subtype'] ?? '');\n        $classnames = explode(',', $allParams['class'] ?? '');\n\n        $offset = (int)$allParams['start'];\n        $limit = (int)$allParams['limit'];\n\n        $offset = $offset ? $offset : 0;\n        $limit = $limit ? $limit : 50;\n\n        $searcherList = new Data\\Listing();\n        $conditionParts = [];\n        $db = \\Pimcore\\Db::get();\n\n        $conditionParts[] = $this->getPermittedPaths($types);\n\n        $queryCondition = '';\n        if (!empty($query)) {\n            $queryCondition = '( MATCH (`data`,`properties`) AGAINST (' . $db->quote($query) . ' IN BOOLEAN MODE) )';\n\n            // the following should be done with an exact-search now \"ID\", because the Element-ID is now in the fulltext index\n            // if the query is numeric the user might want to search by id\n            //if(is_numeric($query)) {\n            //$queryCondition = \"(\" . $queryCondition . \" OR id = \" . $db->quote($query) .\" )\";\n            //}\n\n            $conditionParts[] = $queryCondition;\n        }\n\n        //For objects - handling of bricks\n        $fields = [];\n        $bricks = [];\n        if (!empty($allParams['fields'])) {\n            $fields = $allParams['fields'];\n\n            foreach ($fields as $f) {\n                $parts = explode('~', $f);\n                if (substr($f, 0, 1) == '~') {\n                    //                    $type = $parts[1];\n//                    $field = $parts[2];\n//                    $keyid = $parts[3];\n                    // key value, ignore for now\n                } elseif (count($parts) > 1) {\n                    $bricks[$parts[0]] = $parts[0];\n                }\n            }\n        }\n\n        // filtering for objects\n        if (!empty($allParams['filter']) && !empty($allParams['class'])) {\n            $class = DataObject\\ClassDefinition::getByName($allParams['class']);\n\n            // add Localized Fields filtering\n            $params = $this->decodeJson($allParams['filter']);\n            $unlocalizedFieldsFilters = [];\n            $localizedFieldsFilters = [];\n\n            foreach ($params as $paramConditionObject) {\n                //this loop divides filter parameters to localized and unlocalized groups\n                $definitionExists = in_array('o_' . $paramConditionObject['property'], DataObject\\Service::getSystemFields())\n                    || $class->getFieldDefinition($paramConditionObject['property']);\n                if ($definitionExists) { //TODO: for sure, we can add additional condition like getLocalizedFieldDefinition()->getFieldDefiniton(...\n                    $unlocalizedFieldsFilters[] = $paramConditionObject;\n                } else {\n                    $localizedFieldsFilters[] = $paramConditionObject;\n                }\n            }\n\n            //get filter condition only when filters array is not empty\n\n            //string statements for divided filters\n            $conditionFilters = count($unlocalizedFieldsFilters)\n                ? $gridHelperService->getFilterCondition($this->encodeJson($unlocalizedFieldsFilters), $class)\n                : null;\n            $localizedConditionFilters = count($localizedFieldsFilters)\n                ? $gridHelperService->getFilterCondition($this->encodeJson($localizedFieldsFilters), $class)\n                : null;\n\n            $join = '';\n            $localizedJoin = '';\n            foreach ($bricks as $ob) {\n                $join .= ' LEFT JOIN object_brick_query_' . $ob . '_' . $class->getId();\n                $join .= ' `' . $ob . '`';\n\n                if ($localizedConditionFilters) {\n                    $localizedJoin = $join . ' ON `' . $ob . '`.o_id = `object_localized_data_' . $class->getId() . '`.ooo_id';\n                }\n\n                $join .= ' ON `' . $ob . '`.o_id = `object_' . $class->getId() . '`.o_id';\n            }\n\n            if (null !== $conditionFilters) {\n                //add condition query for non localised fields\n                $conditionParts[] = '( id IN (SELECT `object_' . $class->getId() . '`.o_id FROM object_' . $class->getId()\n                    . $join . ' WHERE ' . $conditionFilters . ') )';\n            }\n\n            if (null !== $localizedConditionFilters) {\n                //add condition query for localised fields\n                $conditionParts[] = '( id IN (SELECT `object_localized_data_' . $class->getId()\n                    . '`.ooo_id FROM object_localized_data_' . $class->getId() . $localizedJoin . ' WHERE '\n                    . $localizedConditionFilters . ' GROUP BY ooo_id ' . ') )';\n            }\n        }\n\n        if (is_array($types) && !empty($types[0])) {\n            $conditionTypeParts = [];\n            foreach ($types as $type) {\n                $conditionTypeParts[] = $db->quote($type);\n            }\n            if (in_array('folder', $subtypes)) {\n                $conditionTypeParts[] = $db->quote('folder');\n            }\n            $conditionParts[] = '( maintype IN (' . implode(',', $conditionTypeParts) . ') )';\n        }\n\n        if (is_array($subtypes) && !empty($subtypes[0])) {\n            $conditionSubtypeParts = [];\n            foreach ($subtypes as $subtype) {\n                $conditionSubtypeParts[] = $db->quote($subtype);\n            }\n            $conditionParts[] = '( type IN (' . implode(',', $conditionSubtypeParts) . ') )';\n        }\n\n        if (is_array($classnames) && !empty($classnames[0])) {\n            if (in_array('folder', $subtypes)) {\n                $classnames[] = 'folder';\n            }\n            $conditionClassnameParts = [];\n            foreach ($classnames as $classname) {\n                $conditionClassnameParts[] = $db->quote($classname);\n            }\n            $conditionParts[] = '( subtype IN (' . implode(',', $conditionClassnameParts) . ') )';\n        }\n\n        //filtering for tags\n        if (!empty($allParams['tagIds'])) {\n            $tagIds = $allParams['tagIds'];\n\n            $tagsTypeCondition = '';\n            if (is_array($types) && !empty($types[0])) {\n                $tagsTypeCondition = 'ctype IN (\\'' . implode('\\',\\'', $types) . '\\') AND';\n            } elseif (!is_array($types)) {\n                $tagsTypeCondition = 'ctype = ' . $db->quote($types) . ' AND ';\n            }\n\n            foreach ($tagIds as $tagId) {\n                if (($allParams['considerChildTags'] ?? 'false') === 'true') {\n                    $tag = Element\\Tag::getById($tagId);\n                    if ($tag) {\n                        $tagPath = $tag->getFullIdPath();\n                        $conditionParts[] = 'id IN (SELECT cId FROM tags_assignment INNER JOIN tags ON tags.id = tags_assignment.tagid WHERE '.$tagsTypeCondition.' (id = ' .(int)$tagId. ' OR idPath LIKE ' . $db->quote(Helper::escapeLike($tagPath) . '%') . '))';\n                    }\n                } else {\n                    $conditionParts[] = 'id IN (SELECT cId FROM tags_assignment WHERE '.$tagsTypeCondition.' tagid = ' .(int)$tagId. ')';\n                }\n            }\n        }\n\n        $condition = implode(' AND ', $conditionParts);\n        $searcherList->setCondition($condition);\n\n        $searcherList->setOffset($offset);\n        $searcherList->setLimit($limit);\n\n        $searcherList->setOrderKey($queryCondition, false);\n        $searcherList->setOrder('DESC');\n\n        $sortingSettings = \\Pimcore\\Bundle\\AdminBundle\\Helper\\QueryParams::extractSortingSettings($allParams);\n        if ($sortingSettings['orderKey']) {\n            // Order by key column instead of filename\n            $orderKeyQuote = true;\n            if ($sortingSettings['orderKey'] === 'filename') {\n                $sortingSettings['orderKey'] = 'CAST(`key` AS CHAR CHARACTER SET utf8) COLLATE utf8_general_ci';\n                $orderKeyQuote = false;\n            }\n\n            // we need a special mapping for classname as this is stored in subtype column\n            $sortMapping = [\n                'classname' => 'subtype',\n            ];\n\n            $sort = $sortingSettings['orderKey'];\n            if (array_key_exists($sortingSettings['orderKey'], $sortMapping)) {\n                $sort = $sortMapping[$sortingSettings['orderKey']];\n            }\n            $searcherList->setOrderKey($sort, $orderKeyQuote);\n        }\n        if ($sortingSettings['order']) {\n            $searcherList->setOrder($sortingSettings['order']);\n        }\n\n        $beforeListLoadEvent = new GenericEvent($this, [\n            'list' => $searcherList,\n            'context' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($beforeListLoadEvent, AdminEvents::SEARCH_LIST_BEFORE_LIST_LOAD);\n        /** @var Data\\Listing $searcherList */\n        $searcherList = $beforeListLoadEvent->getArgument('list');\n\n        if (in_array('asset', $types)) {\n            // Global asset list event (same than the SEARCH_LIST_BEFORE_LIST_LOAD event, but this last one is global for search, list, tree)\n            $beforeListLoadEvent = new GenericEvent($this, [\n                'list' => $searcherList,\n                'context' => $allParams,\n            ]);\n            $eventDispatcher->dispatch($beforeListLoadEvent, AdminEvents::ASSET_LIST_BEFORE_LIST_LOAD);\n            /** @var Data\\Listing $searcherList */\n            $searcherList = $beforeListLoadEvent->getArgument('list');\n        }\n\n        if (in_array('document', $types)) {\n            // Global document list event (same than the SEARCH_LIST_BEFORE_LIST_LOAD event, but this last one is global for search, list, tree)\n            $beforeListLoadEvent = new GenericEvent($this, [\n                'list' => $searcherList,\n                'context' => $allParams,\n            ]);\n            $eventDispatcher->dispatch($beforeListLoadEvent, AdminEvents::DOCUMENT_LIST_BEFORE_LIST_LOAD);\n            /** @var Data\\Listing $searcherList */\n            $searcherList = $beforeListLoadEvent->getArgument('list');\n        }\n\n        if (in_array('object', $types)) {\n            // Global object list event (same than the SEARCH_LIST_BEFORE_LIST_LOAD event, but this last one is global for search, list, tree)\n            $beforeListLoadEvent = new GenericEvent($this, [\n                'list' => $searcherList,\n                'context' => $allParams,\n            ]);\n            $eventDispatcher->dispatch($beforeListLoadEvent, AdminEvents::OBJECT_LIST_BEFORE_LIST_LOAD);\n            /** @var Data\\Listing $searcherList */\n            $searcherList = $beforeListLoadEvent->getArgument('list');\n        }\n\n        $hits = $searcherList->load();\n\n        $elements = [];\n        foreach ($hits as $hit) {\n            $element = Element\\Service::getElementById($hit->getId()->getType(), $hit->getId()->getId());\n            if ($element->isAllowed('list')) {\n                $data = null;\n                if ($element instanceof DataObject\\AbstractObject) {\n                    $data = DataObject\\Service::gridObjectData($element, $fields);\n                } elseif ($element instanceof Document) {\n                    $data = Document\\Service::gridDocumentData($element);\n                } elseif ($element instanceof Asset) {\n                    $data = Asset\\Service::gridAssetData($element);\n                }\n\n                if ($data) {\n                    $elements[] = $data;\n                }\n            } else {\n                //TODO: any message that view is blocked?\n                //$data = Element\\Service::gridElementData($element);\n            }\n        }\n\n        // only get the real total-count when the limit parameter is given otherwise use the default limit\n        if ($allParams['limit']) {\n            $totalMatches = $searcherList->getTotalCount();\n        } else {\n            $totalMatches = count($elements);\n        }\n\n        $result = ['data' => $elements, 'success' => true, 'total' => $totalMatches];\n\n        $afterListLoadEvent = new GenericEvent($this, [\n            'list' => $result,\n            'context' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($afterListLoadEvent, AdminEvents::SEARCH_LIST_AFTER_LIST_LOAD);\n        $result = $afterListLoadEvent->getArgument('list');\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @internal\n     *\n     * @param array $types\n     *\n     * @return string\n     */\n    protected function getPermittedPaths($types = ['asset', 'document', 'object'])\n    {\n        $user = $this->getAdminUser();\n        $db = \\Pimcore\\Db::get();\n\n        $allowedTypes = [];\n\n        foreach ($types as $type) {\n            if ($user->isAllowed($type . 's')) { //the permissions are just plural\n                $elementPaths = Element\\Service::findForbiddenPaths($type, $user);\n\n                $forbiddenPathSql = [];\n                $allowedPathSql = [];\n                foreach ($elementPaths['forbidden'] as $forbiddenPath => $allowedPaths) {\n                    $exceptions = '';\n                    $folderSuffix = '';\n                    if ($allowedPaths) {\n                        $exceptionsConcat = implode(\"%' OR fullpath LIKE '\", $allowedPaths);\n                        $exceptions = \" OR (fullpath LIKE '\" . $exceptionsConcat . \"%')\";\n                        $folderSuffix = '/'; //if allowed children are found, the current folder is listable but its content is still blocked, can easily done by adding a trailing slash\n                    }\n                    $forbiddenPathSql[] = ' (fullpath NOT LIKE ' . $db->quote($forbiddenPath . $folderSuffix . '%') . $exceptions . ') ';\n                }\n                foreach ($elementPaths['allowed'] as $allowedPaths) {\n                    $allowedPathSql[] = ' fullpath LIKE ' . $db->quote($allowedPaths  . '%');\n                }\n\n                // this is to avoid query error when implode is empty.\n                // the result would be like `(maintype = type AND ((path1 OR path2) AND (not_path3 AND not_path4)))`\n                $forbiddenAndAllowedSql = '(maintype = \\'' . $type . '\\'';\n\n                if ($allowedPathSql || $forbiddenPathSql) {\n                    $forbiddenAndAllowedSql .= ' AND (';\n                    $forbiddenAndAllowedSql .= $allowedPathSql ? '( ' . implode(' OR ', $allowedPathSql) . ' )' : '';\n\n                    if ($forbiddenPathSql) {\n                        //if $allowedPathSql \"implosion\" is present, we need `AND` in between\n                        $forbiddenAndAllowedSql .= $allowedPathSql ? ' AND ' : '';\n                        $forbiddenAndAllowedSql .= implode(' AND ', $forbiddenPathSql);\n                    }\n                    $forbiddenAndAllowedSql .= ' )';\n                }\n\n                $forbiddenAndAllowedSql.= ' )';\n\n                $allowedTypes[] = $forbiddenAndAllowedSql;\n            }\n        }\n\n        //if allowedTypes is still empty after getting the workspaces, it means that there are no any master permissions set\n        // by setting a `false` condition in the query makes sure that nothing would be displayed.\n        if (!$allowedTypes) {\n            $allowedTypes = ['false'];\n        }\n\n        return '('.implode(' OR ', $allowedTypes) .')';\n    }\n\n    /**\n     * @param string $query\n     *\n     * @return string\n     */\n    protected function filterQueryParam(string $query)\n    {\n        if ($query == '*') {\n            $query = '';\n        }\n\n        $query = str_replace('&quot;', '\"', $query);\n        $query = str_replace('%', '*', $query);\n        $query = str_replace('@', '#', $query);\n        $query = preg_replace(\"@([^ ])\\-@\", '$1 ', $query);\n\n        $query = str_replace(['<', '>', '(', ')', '~'], ' ', $query);\n\n        // it is not allowed to have * behind another *\n        $query = preg_replace('#[*]+#', '*', $query);\n\n        // no boolean operators at the end of the query\n        $query = rtrim($query, '+- ');\n\n        return $query;\n    }\n\n    /**\n     * @Route(\"/quicksearch\", name=\"pimcore_admin_searchadmin_search_quicksearch\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     *\n     * @return JsonResponse\n     */\n    public function quicksearchAction(Request $request, EventDispatcherInterface $eventDispatcher)\n    {\n        $query = $this->filterQueryParam($request->get('query', ''));\n        if (!preg_match('/[\\+\\-\\*\"]/', $query)) {\n            // check for a boolean operator (which was not filtered by filterQueryParam()),\n            // if present, do not add asterisk at the end of the query\n            $query = $query . '*';\n        }\n\n        $db = \\Pimcore\\Db::get();\n        $searcherList = new Data\\Listing();\n\n        $conditionParts = [];\n\n        $conditionParts[] = $this->getPermittedPaths();\n\n        $matchCondition = '( MATCH (`data`,`properties`) AGAINST (' . $db->quote($query) . ' IN BOOLEAN MODE) )';\n        $conditionParts[] = '(' . $matchCondition . \" AND type != 'folder') \";\n\n        $queryCondition = implode(' AND ', $conditionParts);\n\n        $searcherList->setCondition($queryCondition);\n        $searcherList->setLimit(50);\n        $searcherList->setOrderKey($matchCondition, false);\n        $searcherList->setOrder('DESC');\n\n        $beforeListLoadEvent = new GenericEvent($this, [\n            'list' => $searcherList,\n            'query' => $query,\n        ]);\n        $eventDispatcher->dispatch($beforeListLoadEvent, AdminEvents::QUICKSEARCH_LIST_BEFORE_LIST_LOAD);\n        $searcherList = $beforeListLoadEvent->getArgument('list');\n\n        $hits = $searcherList->load();\n\n        $elements = [];\n        foreach ($hits as $hit) {\n            $element = Element\\Service::getElementById($hit->getId()->getType(), $hit->getId()->getId());\n            if ($element->isAllowed('list')) {\n                $data = [\n                    'id' => $element->getId(),\n                    'type' => $hit->getId()->getType(),\n                    'subtype' => $element->getType(),\n                    'className' => ($element instanceof DataObject\\Concrete) ? $element->getClassName() : '',\n                    'fullpathList' => htmlspecialchars($this->shortenPath($element->getRealFullPath())),\n                ];\n\n                $this->addAdminStyle($element, ElementAdminStyleEvent::CONTEXT_SEARCH, $data);\n\n                $elements[] = $data;\n            }\n        }\n\n        $afterListLoadEvent = new GenericEvent($this, [\n            'list' => $elements,\n            'context' => $query,\n        ]);\n        $eventDispatcher->dispatch($afterListLoadEvent, AdminEvents::QUICKSEARCH_LIST_AFTER_LIST_LOAD);\n        $elements = $afterListLoadEvent->getArgument('list');\n\n        $result = ['data' => $elements, 'success' => true];\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @Route(\"/quicksearch-get-by-id\", name=\"pimcore_admin_searchadmin_search_quicksearch_by_id\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param Config $config\n     *\n     * @return JsonResponse\n     */\n    public function quicksearchByIdAction(Request $request, Config $config)\n    {\n        $type = $request->get('type');\n        $id = $request->get('id');\n        $db = \\Pimcore\\Db::get();\n        $searcherList = new Data\\Listing();\n\n        $searcherList->addConditionParam('id = :id', ['id' => $id]);\n        $searcherList->addConditionParam('maintype = :type', ['type' => $type]);\n        $searcherList->setLimit(1);\n\n        $hits = $searcherList->load();\n\n        //There will always be one result in hits but load returns array.\n        $data = [];\n        foreach ($hits as $hit) {\n            $element = Element\\Service::getElementById($hit->getId()->getType(), $hit->getId()->getId());\n            if ($element->isAllowed('list')) {\n                $data = [\n                    'id' => $element->getId(),\n                    'type' => $hit->getId()->getType(),\n                    'subtype' => $element->getType(),\n                    'className' => ($element instanceof DataObject\\Concrete) ? $element->getClassName() : '',\n                    'fullpath' => htmlspecialchars($element->getRealFullPath()),\n                    'fullpathList' => htmlspecialchars($this->shortenPath($element->getRealFullPath())),\n                    'iconCls' => 'pimcore_icon_asset_default',\n                ];\n\n                $this->addAdminStyle($element, ElementAdminStyleEvent::CONTEXT_SEARCH, $data);\n\n                $validLanguages = \\Pimcore\\Tool::getValidLanguages();\n\n                $data['preview'] = $this->renderView(\n                    '@PimcoreAdmin/SearchAdmin/Search/Quicksearch/' . $hit->getId()->getType() . '.html.twig', [\n                        'element' => $element,\n                        'iconCls' => $data['iconCls'],\n                        'config' => $config,\n                        'validLanguages' => $validLanguages,\n                    ]\n                );\n            }\n        }\n\n        return $this->adminJson($data);\n    }\n\n    /**\n     * @param string $path\n     *\n     * @return string\n     */\n    protected function shortenPath($path)\n    {\n        $parts = explode('/', trim($path, '/'));\n        $count = count($parts) - 1;\n\n        for ($i = $count; ; $i--) {\n            $shortPath = '/' . implode('/', array_unique($parts));\n            if ($i === 0 || strlen($shortPath) <= 50) {\n                break;\n            }\n            array_splice($parts, $i - 1, 1, '\u2026');\n        }\n\n        if (mb_strlen($shortPath) > 50) {\n            $shortPath = mb_substr($shortPath, 0, 49) . '\u2026';\n        }\n\n        return $shortPath;\n    }\n}\n"], "fixing_code": ["<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\AdminBundle\\Controller\\Searchadmin;\n\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\AdminController;\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\Traits\\AdminStyleTrait;\nuse Pimcore\\Bundle\\AdminBundle\\Helper\\GridHelperService;\nuse Pimcore\\Config;\nuse Pimcore\\Db\\Helper;\nuse Pimcore\\Event\\Admin\\ElementAdminStyleEvent;\nuse Pimcore\\Event\\AdminEvents;\nuse Pimcore\\Model\\Asset;\nuse Pimcore\\Model\\DataObject;\nuse Pimcore\\Model\\Document;\nuse Pimcore\\Model\\Element;\nuse Pimcore\\Model\\Search\\Backend\\Data;\nuse Symfony\\Component\\EventDispatcher\\GenericEvent;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface;\n\n/**\n * @Route(\"/search\")\n *\n * @internal\n */\nclass SearchController extends AdminController\n{\n    use AdminStyleTrait;\n\n    /**\n     * @Route(\"/find\", name=\"pimcore_admin_searchadmin_search_find\", methods={\"GET\", \"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     *\n     * @todo: $conditionTypeParts could be undefined\n     *\n     * @todo: $conditionSubtypeParts could be undefined\n     *\n     * @todo: $conditionClassnameParts could be undefined\n     *\n     * @todo: $data could be undefined\n     */\n    public function findAction(Request $request, EventDispatcherInterface $eventDispatcher, GridHelperService $gridHelperService)\n    {\n        $allParams = array_merge($request->request->all(), $request->query->all());\n\n        $requestedLanguage = $allParams['language'] ?? null;\n        if ($requestedLanguage) {\n            if ($requestedLanguage != 'default') {\n                $request->setLocale($requestedLanguage);\n            }\n        }\n\n        $filterPrepareEvent = new GenericEvent($this, [\n            'requestParams' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($filterPrepareEvent, AdminEvents::SEARCH_LIST_BEFORE_FILTER_PREPARE);\n\n        $allParams = $filterPrepareEvent->getArgument('requestParams');\n\n        $query = $this->filterQueryParam($allParams['query'] ?? '');\n\n        $types = explode(',', preg_replace(\"/[^a-z,]/i\", '', $allParams['type'] ?? ''));\n        $subtypes = explode(',', preg_replace(\"/[^a-z,]/i\", '', $allParams['subtype'] ?? ''));\n        $classnames = explode(',', preg_replace(\"/[^a-z0-9_,]/i\", '', $allParams['class'] ?? ''));\n\n        $offset = (int)$allParams['start'];\n        $limit = (int)$allParams['limit'];\n\n        $offset = $offset ? $offset : 0;\n        $limit = $limit ? $limit : 50;\n\n        $searcherList = new Data\\Listing();\n        $conditionParts = [];\n        $db = \\Pimcore\\Db::get();\n\n        $conditionParts[] = $this->getPermittedPaths($types);\n\n        $queryCondition = '';\n        if (!empty($query)) {\n            $queryCondition = '( MATCH (`data`,`properties`) AGAINST (' . $db->quote($query) . ' IN BOOLEAN MODE) )';\n\n            // the following should be done with an exact-search now \"ID\", because the Element-ID is now in the fulltext index\n            // if the query is numeric the user might want to search by id\n            //if(is_numeric($query)) {\n            //$queryCondition = \"(\" . $queryCondition . \" OR id = \" . $db->quote($query) .\" )\";\n            //}\n\n            $conditionParts[] = $queryCondition;\n        }\n\n        //For objects - handling of bricks\n        $fields = [];\n        $bricks = [];\n        if (!empty($allParams['fields'])) {\n            $fields = $allParams['fields'];\n\n            foreach ($fields as $f) {\n                $parts = explode('~', $f);\n                if (substr($f, 0, 1) == '~') {\n                    //                    $type = $parts[1];\n//                    $field = $parts[2];\n//                    $keyid = $parts[3];\n                    // key value, ignore for now\n                } elseif (count($parts) > 1) {\n                    $bricks[$parts[0]] = $parts[0];\n                }\n            }\n        }\n\n        // filtering for objects\n        if (!empty($allParams['filter']) && !empty($allParams['class'])) {\n            $class = DataObject\\ClassDefinition::getByName($allParams['class']);\n\n            // add Localized Fields filtering\n            $params = $this->decodeJson($allParams['filter']);\n            $unlocalizedFieldsFilters = [];\n            $localizedFieldsFilters = [];\n\n            foreach ($params as $paramConditionObject) {\n                //this loop divides filter parameters to localized and unlocalized groups\n                $definitionExists = in_array('o_' . $paramConditionObject['property'], DataObject\\Service::getSystemFields())\n                    || $class->getFieldDefinition($paramConditionObject['property']);\n                if ($definitionExists) { //TODO: for sure, we can add additional condition like getLocalizedFieldDefinition()->getFieldDefiniton(...\n                    $unlocalizedFieldsFilters[] = $paramConditionObject;\n                } else {\n                    $localizedFieldsFilters[] = $paramConditionObject;\n                }\n            }\n\n            //get filter condition only when filters array is not empty\n\n            //string statements for divided filters\n            $conditionFilters = count($unlocalizedFieldsFilters)\n                ? $gridHelperService->getFilterCondition($this->encodeJson($unlocalizedFieldsFilters), $class)\n                : null;\n            $localizedConditionFilters = count($localizedFieldsFilters)\n                ? $gridHelperService->getFilterCondition($this->encodeJson($localizedFieldsFilters), $class)\n                : null;\n\n            $join = '';\n            $localizedJoin = '';\n            foreach ($bricks as $ob) {\n                $join .= ' LEFT JOIN object_brick_query_' . $ob . '_' . $class->getId();\n                $join .= ' `' . $ob . '`';\n\n                if ($localizedConditionFilters) {\n                    $localizedJoin = $join . ' ON `' . $ob . '`.o_id = `object_localized_data_' . $class->getId() . '`.ooo_id';\n                }\n\n                $join .= ' ON `' . $ob . '`.o_id = `object_' . $class->getId() . '`.o_id';\n            }\n\n            if (null !== $conditionFilters) {\n                //add condition query for non localised fields\n                $conditionParts[] = '( id IN (SELECT `object_' . $class->getId() . '`.o_id FROM object_' . $class->getId()\n                    . $join . ' WHERE ' . $conditionFilters . ') )';\n            }\n\n            if (null !== $localizedConditionFilters) {\n                //add condition query for localised fields\n                $conditionParts[] = '( id IN (SELECT `object_localized_data_' . $class->getId()\n                    . '`.ooo_id FROM object_localized_data_' . $class->getId() . $localizedJoin . ' WHERE '\n                    . $localizedConditionFilters . ' GROUP BY ooo_id ' . ') )';\n            }\n        }\n\n        if (is_array($types) && !empty($types[0])) {\n            $conditionTypeParts = [];\n            foreach ($types as $type) {\n                $conditionTypeParts[] = $db->quote($type);\n            }\n            if (in_array('folder', $subtypes)) {\n                $conditionTypeParts[] = $db->quote('folder');\n            }\n            $conditionParts[] = '( maintype IN (' . implode(',', $conditionTypeParts) . ') )';\n        }\n\n        if (is_array($subtypes) && !empty($subtypes[0])) {\n            $conditionSubtypeParts = [];\n            foreach ($subtypes as $subtype) {\n                $conditionSubtypeParts[] = $db->quote($subtype);\n            }\n            $conditionParts[] = '( type IN (' . implode(',', $conditionSubtypeParts) . ') )';\n        }\n\n        if (is_array($classnames) && !empty($classnames[0])) {\n            if (in_array('folder', $subtypes)) {\n                $classnames[] = 'folder';\n            }\n            $conditionClassnameParts = [];\n            foreach ($classnames as $classname) {\n                $conditionClassnameParts[] = $db->quote($classname);\n            }\n            $conditionParts[] = '( subtype IN (' . implode(',', $conditionClassnameParts) . ') )';\n        }\n\n        //filtering for tags\n        if (!empty($allParams['tagIds'])) {\n            $tagIds = $allParams['tagIds'];\n\n            $tagsTypeCondition = '';\n            if (is_array($types) && !empty($types[0])) {\n                $tagsTypeCondition = 'ctype IN (\\'' . implode('\\',\\'', $types) . '\\') AND';\n            } elseif (!is_array($types)) {\n                $tagsTypeCondition = 'ctype = ' . $db->quote($types) . ' AND ';\n            }\n\n            foreach ($tagIds as $tagId) {\n                if (($allParams['considerChildTags'] ?? 'false') === 'true') {\n                    $tag = Element\\Tag::getById($tagId);\n                    if ($tag) {\n                        $tagPath = $tag->getFullIdPath();\n                        $conditionParts[] = 'id IN (SELECT cId FROM tags_assignment INNER JOIN tags ON tags.id = tags_assignment.tagid WHERE '.$tagsTypeCondition.' (id = ' .(int)$tagId. ' OR idPath LIKE ' . $db->quote(Helper::escapeLike($tagPath) . '%') . '))';\n                    }\n                } else {\n                    $conditionParts[] = 'id IN (SELECT cId FROM tags_assignment WHERE '.$tagsTypeCondition.' tagid = ' .(int)$tagId. ')';\n                }\n            }\n        }\n\n        $condition = implode(' AND ', $conditionParts);\n        $searcherList->setCondition($condition);\n\n        $searcherList->setOffset($offset);\n        $searcherList->setLimit($limit);\n\n        $searcherList->setOrderKey($queryCondition, false);\n        $searcherList->setOrder('DESC');\n\n        $sortingSettings = \\Pimcore\\Bundle\\AdminBundle\\Helper\\QueryParams::extractSortingSettings($allParams);\n        if ($sortingSettings['orderKey']) {\n            // Order by key column instead of filename\n            $orderKeyQuote = true;\n            if ($sortingSettings['orderKey'] === 'filename') {\n                $sortingSettings['orderKey'] = 'CAST(`key` AS CHAR CHARACTER SET utf8) COLLATE utf8_general_ci';\n                $orderKeyQuote = false;\n            }\n\n            // we need a special mapping for classname as this is stored in subtype column\n            $sortMapping = [\n                'classname' => 'subtype',\n            ];\n\n            $sort = $sortingSettings['orderKey'];\n            if (array_key_exists($sortingSettings['orderKey'], $sortMapping)) {\n                $sort = $sortMapping[$sortingSettings['orderKey']];\n            }\n            $searcherList->setOrderKey($sort, $orderKeyQuote);\n        }\n        if ($sortingSettings['order']) {\n            $searcherList->setOrder($sortingSettings['order']);\n        }\n\n        $beforeListLoadEvent = new GenericEvent($this, [\n            'list' => $searcherList,\n            'context' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($beforeListLoadEvent, AdminEvents::SEARCH_LIST_BEFORE_LIST_LOAD);\n        /** @var Data\\Listing $searcherList */\n        $searcherList = $beforeListLoadEvent->getArgument('list');\n\n        if (in_array('asset', $types)) {\n            // Global asset list event (same than the SEARCH_LIST_BEFORE_LIST_LOAD event, but this last one is global for search, list, tree)\n            $beforeListLoadEvent = new GenericEvent($this, [\n                'list' => $searcherList,\n                'context' => $allParams,\n            ]);\n            $eventDispatcher->dispatch($beforeListLoadEvent, AdminEvents::ASSET_LIST_BEFORE_LIST_LOAD);\n            /** @var Data\\Listing $searcherList */\n            $searcherList = $beforeListLoadEvent->getArgument('list');\n        }\n\n        if (in_array('document', $types)) {\n            // Global document list event (same than the SEARCH_LIST_BEFORE_LIST_LOAD event, but this last one is global for search, list, tree)\n            $beforeListLoadEvent = new GenericEvent($this, [\n                'list' => $searcherList,\n                'context' => $allParams,\n            ]);\n            $eventDispatcher->dispatch($beforeListLoadEvent, AdminEvents::DOCUMENT_LIST_BEFORE_LIST_LOAD);\n            /** @var Data\\Listing $searcherList */\n            $searcherList = $beforeListLoadEvent->getArgument('list');\n        }\n\n        if (in_array('object', $types)) {\n            // Global object list event (same than the SEARCH_LIST_BEFORE_LIST_LOAD event, but this last one is global for search, list, tree)\n            $beforeListLoadEvent = new GenericEvent($this, [\n                'list' => $searcherList,\n                'context' => $allParams,\n            ]);\n            $eventDispatcher->dispatch($beforeListLoadEvent, AdminEvents::OBJECT_LIST_BEFORE_LIST_LOAD);\n            /** @var Data\\Listing $searcherList */\n            $searcherList = $beforeListLoadEvent->getArgument('list');\n        }\n\n        $hits = $searcherList->load();\n\n        $elements = [];\n        foreach ($hits as $hit) {\n            $element = Element\\Service::getElementById($hit->getId()->getType(), $hit->getId()->getId());\n            if ($element->isAllowed('list')) {\n                $data = null;\n                if ($element instanceof DataObject\\AbstractObject) {\n                    $data = DataObject\\Service::gridObjectData($element, $fields);\n                } elseif ($element instanceof Document) {\n                    $data = Document\\Service::gridDocumentData($element);\n                } elseif ($element instanceof Asset) {\n                    $data = Asset\\Service::gridAssetData($element);\n                }\n\n                if ($data) {\n                    $elements[] = $data;\n                }\n            } else {\n                //TODO: any message that view is blocked?\n                //$data = Element\\Service::gridElementData($element);\n            }\n        }\n\n        // only get the real total-count when the limit parameter is given otherwise use the default limit\n        if ($allParams['limit']) {\n            $totalMatches = $searcherList->getTotalCount();\n        } else {\n            $totalMatches = count($elements);\n        }\n\n        $result = ['data' => $elements, 'success' => true, 'total' => $totalMatches];\n\n        $afterListLoadEvent = new GenericEvent($this, [\n            'list' => $result,\n            'context' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($afterListLoadEvent, AdminEvents::SEARCH_LIST_AFTER_LIST_LOAD);\n        $result = $afterListLoadEvent->getArgument('list');\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @internal\n     *\n     * @param array $types\n     *\n     * @return string\n     */\n    protected function getPermittedPaths($types = ['asset', 'document', 'object'])\n    {\n        $user = $this->getAdminUser();\n        $db = \\Pimcore\\Db::get();\n\n        $allowedTypes = [];\n\n        foreach ($types as $type) {\n            if ($user->isAllowed($type . 's')) { //the permissions are just plural\n                $elementPaths = Element\\Service::findForbiddenPaths($type, $user);\n\n                $forbiddenPathSql = [];\n                $allowedPathSql = [];\n                foreach ($elementPaths['forbidden'] as $forbiddenPath => $allowedPaths) {\n                    $exceptions = '';\n                    $folderSuffix = '';\n                    if ($allowedPaths) {\n                        $exceptionsConcat = implode(\"%' OR fullpath LIKE '\", $allowedPaths);\n                        $exceptions = \" OR (fullpath LIKE '\" . $exceptionsConcat . \"%')\";\n                        $folderSuffix = '/'; //if allowed children are found, the current folder is listable but its content is still blocked, can easily done by adding a trailing slash\n                    }\n                    $forbiddenPathSql[] = ' (fullpath NOT LIKE ' . $db->quote($forbiddenPath . $folderSuffix . '%') . $exceptions . ') ';\n                }\n                foreach ($elementPaths['allowed'] as $allowedPaths) {\n                    $allowedPathSql[] = ' fullpath LIKE ' . $db->quote($allowedPaths  . '%');\n                }\n\n                // this is to avoid query error when implode is empty.\n                // the result would be like `(maintype = type AND ((path1 OR path2) AND (not_path3 AND not_path4)))`\n                $forbiddenAndAllowedSql = '(maintype = \\'' . $type . '\\'';\n\n                if ($allowedPathSql || $forbiddenPathSql) {\n                    $forbiddenAndAllowedSql .= ' AND (';\n                    $forbiddenAndAllowedSql .= $allowedPathSql ? '( ' . implode(' OR ', $allowedPathSql) . ' )' : '';\n\n                    if ($forbiddenPathSql) {\n                        //if $allowedPathSql \"implosion\" is present, we need `AND` in between\n                        $forbiddenAndAllowedSql .= $allowedPathSql ? ' AND ' : '';\n                        $forbiddenAndAllowedSql .= implode(' AND ', $forbiddenPathSql);\n                    }\n                    $forbiddenAndAllowedSql .= ' )';\n                }\n\n                $forbiddenAndAllowedSql.= ' )';\n\n                $allowedTypes[] = $forbiddenAndAllowedSql;\n            }\n        }\n\n        //if allowedTypes is still empty after getting the workspaces, it means that there are no any master permissions set\n        // by setting a `false` condition in the query makes sure that nothing would be displayed.\n        if (!$allowedTypes) {\n            $allowedTypes = ['false'];\n        }\n\n        return '('.implode(' OR ', $allowedTypes) .')';\n    }\n\n    /**\n     * @param string $query\n     *\n     * @return string\n     */\n    protected function filterQueryParam(string $query)\n    {\n        if ($query == '*') {\n            $query = '';\n        }\n\n        $query = str_replace('&quot;', '\"', $query);\n        $query = str_replace('%', '*', $query);\n        $query = str_replace('@', '#', $query);\n        $query = preg_replace(\"@([^ ])\\-@\", '$1 ', $query);\n\n        $query = str_replace(['<', '>', '(', ')', '~'], ' ', $query);\n\n        // it is not allowed to have * behind another *\n        $query = preg_replace('#[*]+#', '*', $query);\n\n        // no boolean operators at the end of the query\n        $query = rtrim($query, '+- ');\n\n        return $query;\n    }\n\n    /**\n     * @Route(\"/quicksearch\", name=\"pimcore_admin_searchadmin_search_quicksearch\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     *\n     * @return JsonResponse\n     */\n    public function quicksearchAction(Request $request, EventDispatcherInterface $eventDispatcher)\n    {\n        $query = $this->filterQueryParam($request->get('query', ''));\n        if (!preg_match('/[\\+\\-\\*\"]/', $query)) {\n            // check for a boolean operator (which was not filtered by filterQueryParam()),\n            // if present, do not add asterisk at the end of the query\n            $query = $query . '*';\n        }\n\n        $db = \\Pimcore\\Db::get();\n        $searcherList = new Data\\Listing();\n\n        $conditionParts = [];\n\n        $conditionParts[] = $this->getPermittedPaths();\n\n        $matchCondition = '( MATCH (`data`,`properties`) AGAINST (' . $db->quote($query) . ' IN BOOLEAN MODE) )';\n        $conditionParts[] = '(' . $matchCondition . \" AND type != 'folder') \";\n\n        $queryCondition = implode(' AND ', $conditionParts);\n\n        $searcherList->setCondition($queryCondition);\n        $searcherList->setLimit(50);\n        $searcherList->setOrderKey($matchCondition, false);\n        $searcherList->setOrder('DESC');\n\n        $beforeListLoadEvent = new GenericEvent($this, [\n            'list' => $searcherList,\n            'query' => $query,\n        ]);\n        $eventDispatcher->dispatch($beforeListLoadEvent, AdminEvents::QUICKSEARCH_LIST_BEFORE_LIST_LOAD);\n        $searcherList = $beforeListLoadEvent->getArgument('list');\n\n        $hits = $searcherList->load();\n\n        $elements = [];\n        foreach ($hits as $hit) {\n            $element = Element\\Service::getElementById($hit->getId()->getType(), $hit->getId()->getId());\n            if ($element->isAllowed('list')) {\n                $data = [\n                    'id' => $element->getId(),\n                    'type' => $hit->getId()->getType(),\n                    'subtype' => $element->getType(),\n                    'className' => ($element instanceof DataObject\\Concrete) ? $element->getClassName() : '',\n                    'fullpathList' => htmlspecialchars($this->shortenPath($element->getRealFullPath())),\n                ];\n\n                $this->addAdminStyle($element, ElementAdminStyleEvent::CONTEXT_SEARCH, $data);\n\n                $elements[] = $data;\n            }\n        }\n\n        $afterListLoadEvent = new GenericEvent($this, [\n            'list' => $elements,\n            'context' => $query,\n        ]);\n        $eventDispatcher->dispatch($afterListLoadEvent, AdminEvents::QUICKSEARCH_LIST_AFTER_LIST_LOAD);\n        $elements = $afterListLoadEvent->getArgument('list');\n\n        $result = ['data' => $elements, 'success' => true];\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @Route(\"/quicksearch-get-by-id\", name=\"pimcore_admin_searchadmin_search_quicksearch_by_id\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param Config $config\n     *\n     * @return JsonResponse\n     */\n    public function quicksearchByIdAction(Request $request, Config $config)\n    {\n        $type = $request->get('type');\n        $id = $request->get('id');\n        $db = \\Pimcore\\Db::get();\n        $searcherList = new Data\\Listing();\n\n        $searcherList->addConditionParam('id = :id', ['id' => $id]);\n        $searcherList->addConditionParam('maintype = :type', ['type' => $type]);\n        $searcherList->setLimit(1);\n\n        $hits = $searcherList->load();\n\n        //There will always be one result in hits but load returns array.\n        $data = [];\n        foreach ($hits as $hit) {\n            $element = Element\\Service::getElementById($hit->getId()->getType(), $hit->getId()->getId());\n            if ($element->isAllowed('list')) {\n                $data = [\n                    'id' => $element->getId(),\n                    'type' => $hit->getId()->getType(),\n                    'subtype' => $element->getType(),\n                    'className' => ($element instanceof DataObject\\Concrete) ? $element->getClassName() : '',\n                    'fullpath' => htmlspecialchars($element->getRealFullPath()),\n                    'fullpathList' => htmlspecialchars($this->shortenPath($element->getRealFullPath())),\n                    'iconCls' => 'pimcore_icon_asset_default',\n                ];\n\n                $this->addAdminStyle($element, ElementAdminStyleEvent::CONTEXT_SEARCH, $data);\n\n                $validLanguages = \\Pimcore\\Tool::getValidLanguages();\n\n                $data['preview'] = $this->renderView(\n                    '@PimcoreAdmin/SearchAdmin/Search/Quicksearch/' . $hit->getId()->getType() . '.html.twig', [\n                        'element' => $element,\n                        'iconCls' => $data['iconCls'],\n                        'config' => $config,\n                        'validLanguages' => $validLanguages,\n                    ]\n                );\n            }\n        }\n\n        return $this->adminJson($data);\n    }\n\n    /**\n     * @param string $path\n     *\n     * @return string\n     */\n    protected function shortenPath($path)\n    {\n        $parts = explode('/', trim($path, '/'));\n        $count = count($parts) - 1;\n\n        for ($i = $count; ; $i--) {\n            $shortPath = '/' . implode('/', array_unique($parts));\n            if ($i === 0 || strlen($shortPath) <= 50) {\n                break;\n            }\n            array_splice($parts, $i - 1, 1, '\u2026');\n        }\n\n        if (mb_strlen($shortPath) > 50) {\n            $shortPath = mb_substr($shortPath, 0, 49) . '\u2026';\n        }\n\n        return $shortPath;\n    }\n}\n"], "filenames": ["bundles/AdminBundle/Controller/Searchadmin/SearchController.php"], "buggy_code_start_loc": [80], "buggy_code_end_loc": [83], "fixing_code_start_loc": [80], "fixing_code_end_loc": [83], "type": "CWE-89", "message": "SQL Injection in GitHub repository pimcore/pimcore prior to 10.5.19.", "other": {"cve": {"id": "CVE-2023-1578", "sourceIdentifier": "security@huntr.dev", "published": "2023-03-22T16:15:13.553", "lastModified": "2023-03-24T20:59:40.380", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "SQL Injection in GitHub repository pimcore/pimcore prior to 10.5.19."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pimcore:pimcore:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.5.19", "matchCriteriaId": "9F355AEC-329F-43D1-A3D7-44C2481A1999"}]}]}], "references": [{"url": "https://github.com/pimcore/pimcore/commit/367b74488808d71ec3f66f4ca9e8df5217c2c8d2", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/7e441a14-8e55-4ab4-932c-4dc56bb1bc2e", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pimcore/pimcore/commit/367b74488808d71ec3f66f4ca9e8df5217c2c8d2"}}