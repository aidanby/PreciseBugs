{"buggy_code": ["// \u00a9 2016 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html\n/*\n*******************************************************************************\n* Copyright (C) 1997-2016, International Business Machines Corporation and\n* others. All Rights Reserved.\n*******************************************************************************\n*\n* File FMTABLE.CPP\n*\n* Modification History:\n*\n*   Date        Name        Description\n*   03/25/97    clhuang     Initial Implementation.\n********************************************************************************\n*/\n\n#include \"unicode/utypes.h\"\n\n#if !UCONFIG_NO_FORMATTING\n\n#include <cstdlib>\n#include <math.h>\n#include \"unicode/fmtable.h\"\n#include \"unicode/ustring.h\"\n#include \"unicode/measure.h\"\n#include \"unicode/curramt.h\"\n#include \"unicode/uformattable.h\"\n#include \"charstr.h\"\n#include \"cmemory.h\"\n#include \"cstring.h\"\n#include \"fmtableimp.h\"\n#include \"number_decimalquantity.h\"\n\n// *****************************************************************************\n// class Formattable\n// *****************************************************************************\n\nU_NAMESPACE_BEGIN\n\nUOBJECT_DEFINE_RTTI_IMPLEMENTATION(Formattable)\n\nusing number::impl::DecimalQuantity;\n\n\n//-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n// NOTE: As of 3.0, there are limitations to the UObject API.  It does\n// not (yet) support cloning, operator=, nor operator==.  To\n// work around this, I implement some simple inlines here.  Later\n// these can be modified or removed.  [alan]\n\n// NOTE: These inlines assume that all fObjects are in fact instances\n// of the Measure class, which is true as of 3.0.  [alan]\n\n// Return TRUE if *a == *b.\nstatic inline UBool objectEquals(const UObject* a, const UObject* b) {\n    // LATER: return *a == *b;\n    return *((const Measure*) a) == *((const Measure*) b);\n}\n\n// Return a clone of *a.\nstatic inline UObject* objectClone(const UObject* a) {\n    // LATER: return a->clone();\n    return ((const Measure*) a)->clone();\n}\n\n// Return TRUE if *a is an instance of Measure.\nstatic inline UBool instanceOfMeasure(const UObject* a) {\n    return dynamic_cast<const Measure*>(a) != NULL;\n}\n\n/**\n * Creates a new Formattable array and copies the values from the specified\n * original.\n * @param array the original array\n * @param count the original array count\n * @return the new Formattable array.\n */\nstatic Formattable* createArrayCopy(const Formattable* array, int32_t count) {\n    Formattable *result = new Formattable[count];\n    if (result != NULL) {\n        for (int32_t i=0; i<count; ++i)\n            result[i] = array[i]; // Don't memcpy!\n    }\n    return result;\n}\n\n//-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n/**\n * Set 'ec' to 'err' only if 'ec' is not already set to a failing UErrorCode.\n */\nstatic void setError(UErrorCode& ec, UErrorCode err) {\n    if (U_SUCCESS(ec)) {\n        ec = err;\n    }\n}\n\n//\n//  Common initialization code, shared by constructors.\n//  Put everything into a known state.\n//\nvoid  Formattable::init() {\n    fValue.fInt64 = 0;\n    fType = kLong;\n    fDecimalStr = NULL;\n    fDecimalQuantity = NULL;\n    fBogus.setToBogus(); \n}\n\n// -------------------------------------\n// default constructor.\n// Creates a formattable object with a long value 0.\n\nFormattable::Formattable() {\n    init();\n}\n\n// -------------------------------------\n// Creates a formattable object with a Date instance.\n\nFormattable::Formattable(UDate date, ISDATE /*isDate*/)\n{\n    init();\n    fType = kDate;\n    fValue.fDate = date;\n}\n\n// -------------------------------------\n// Creates a formattable object with a double value.\n\nFormattable::Formattable(double value)\n{\n    init();\n    fType = kDouble;\n    fValue.fDouble = value;\n}\n\n// -------------------------------------\n// Creates a formattable object with an int32_t value.\n\nFormattable::Formattable(int32_t value)\n{\n    init();\n    fValue.fInt64 = value;\n}\n\n// -------------------------------------\n// Creates a formattable object with an int64_t value.\n\nFormattable::Formattable(int64_t value)\n{\n    init();\n    fType = kInt64;\n    fValue.fInt64 = value;\n}\n\n// -------------------------------------\n// Creates a formattable object with a decimal number value from a string.\n\nFormattable::Formattable(StringPiece number, UErrorCode &status) {\n    init();\n    setDecimalNumber(number, status);\n}\n\n\n// -------------------------------------\n// Creates a formattable object with a UnicodeString instance.\n\nFormattable::Formattable(const UnicodeString& stringToCopy)\n{\n    init();\n    fType = kString;\n    fValue.fString = new UnicodeString(stringToCopy);\n}\n\n// -------------------------------------\n// Creates a formattable object with a UnicodeString* value.\n// (adopting symantics)\n\nFormattable::Formattable(UnicodeString* stringToAdopt)\n{\n    init();\n    fType = kString;\n    fValue.fString = stringToAdopt;\n}\n\nFormattable::Formattable(UObject* objectToAdopt)\n{\n    init();\n    fType = kObject;\n    fValue.fObject = objectToAdopt;\n}\n\n// -------------------------------------\n\nFormattable::Formattable(const Formattable* arrayToCopy, int32_t count)\n    :   UObject(), fType(kArray)\n{\n    init();\n    fType = kArray;\n    fValue.fArrayAndCount.fArray = createArrayCopy(arrayToCopy, count);\n    fValue.fArrayAndCount.fCount = count;\n}\n\n// -------------------------------------\n// copy constructor\n\n\nFormattable::Formattable(const Formattable &source)\n     :  UObject(*this)\n{\n    init();\n    *this = source;\n}\n\n// -------------------------------------\n// assignment operator\n\nFormattable&\nFormattable::operator=(const Formattable& source)\n{\n    if (this != &source)\n    {\n        // Disposes the current formattable value/setting.\n        dispose();\n\n        // Sets the correct data type for this value.\n        fType = source.fType;\n        switch (fType)\n        {\n        case kArray:\n            // Sets each element in the array one by one and records the array count.\n            fValue.fArrayAndCount.fCount = source.fValue.fArrayAndCount.fCount;\n            fValue.fArrayAndCount.fArray = createArrayCopy(source.fValue.fArrayAndCount.fArray,\n                                                           source.fValue.fArrayAndCount.fCount);\n            break;\n        case kString:\n            // Sets the string value.\n            fValue.fString = new UnicodeString(*source.fValue.fString);\n            break;\n        case kDouble:\n            // Sets the double value.\n            fValue.fDouble = source.fValue.fDouble;\n            break;\n        case kLong:\n        case kInt64:\n            // Sets the long value.\n            fValue.fInt64 = source.fValue.fInt64;\n            break;\n        case kDate:\n            // Sets the Date value.\n            fValue.fDate = source.fValue.fDate;\n            break;\n        case kObject:\n            fValue.fObject = objectClone(source.fValue.fObject);\n            break;\n        }\n\n        UErrorCode status = U_ZERO_ERROR;\n        if (source.fDecimalQuantity != NULL) {\n          fDecimalQuantity = new DecimalQuantity(*source.fDecimalQuantity);\n        }\n        if (source.fDecimalStr != NULL) {\n            fDecimalStr = new CharString(*source.fDecimalStr, status);\n            if (U_FAILURE(status)) {\n                delete fDecimalStr;\n                fDecimalStr = NULL;\n            }\n        }\n    }\n    return *this;\n}\n\n// -------------------------------------\n\nUBool\nFormattable::operator==(const Formattable& that) const\n{\n    int32_t i;\n\n    if (this == &that) return TRUE;\n\n    // Returns FALSE if the data types are different.\n    if (fType != that.fType) return FALSE;\n\n    // Compares the actual data values.\n    UBool equal = TRUE;\n    switch (fType) {\n    case kDate:\n        equal = (fValue.fDate == that.fValue.fDate);\n        break;\n    case kDouble:\n        equal = (fValue.fDouble == that.fValue.fDouble);\n        break;\n    case kLong:\n    case kInt64:\n        equal = (fValue.fInt64 == that.fValue.fInt64);\n        break;\n    case kString:\n        equal = (*(fValue.fString) == *(that.fValue.fString));\n        break;\n    case kArray:\n        if (fValue.fArrayAndCount.fCount != that.fValue.fArrayAndCount.fCount) {\n            equal = FALSE;\n            break;\n        }\n        // Checks each element for equality.\n        for (i=0; i<fValue.fArrayAndCount.fCount; ++i) {\n            if (fValue.fArrayAndCount.fArray[i] != that.fValue.fArrayAndCount.fArray[i]) {\n                equal = FALSE;\n                break;\n            }\n        }\n        break;\n    case kObject:\n        if (fValue.fObject == NULL || that.fValue.fObject == NULL) {\n            equal = FALSE;\n        } else {\n            equal = objectEquals(fValue.fObject, that.fValue.fObject);\n        }\n        break;\n    }\n\n    // TODO:  compare digit lists if numeric.\n    return equal;\n}\n\n// -------------------------------------\n\nFormattable::~Formattable()\n{\n    dispose();\n}\n\n// -------------------------------------\n\nvoid Formattable::dispose()\n{\n    // Deletes the data value if necessary.\n    switch (fType) {\n    case kString:\n        delete fValue.fString;\n        break;\n    case kArray:\n        delete[] fValue.fArrayAndCount.fArray;\n        break;\n    case kObject:\n        delete fValue.fObject;\n        break;\n    default:\n        break;\n    }\n\n    fType = kLong;\n    fValue.fInt64 = 0;\n\n    delete fDecimalStr;\n    fDecimalStr = NULL;\n\n    delete fDecimalQuantity;\n    fDecimalQuantity = NULL;\n}\n\nFormattable *\nFormattable::clone() const {\n    return new Formattable(*this);\n}\n\n// -------------------------------------\n// Gets the data type of this Formattable object. \nFormattable::Type\nFormattable::getType() const\n{\n    return fType;\n}\n\nUBool\nFormattable::isNumeric() const {\n    switch (fType) {\n    case kDouble:\n    case kLong:\n    case kInt64:\n        return TRUE;\n    default:\n        return FALSE;\n    }\n}\n\n// -------------------------------------\nint32_t\n//Formattable::getLong(UErrorCode* status) const\nFormattable::getLong(UErrorCode& status) const\n{\n    if (U_FAILURE(status)) {\n        return 0;\n    }\n        \n    switch (fType) {\n    case Formattable::kLong: \n        return (int32_t)fValue.fInt64;\n    case Formattable::kInt64:\n        if (fValue.fInt64 > INT32_MAX) {\n            status = U_INVALID_FORMAT_ERROR;\n            return INT32_MAX;\n        } else if (fValue.fInt64 < INT32_MIN) {\n            status = U_INVALID_FORMAT_ERROR;\n            return INT32_MIN;\n        } else {\n            return (int32_t)fValue.fInt64;\n        }\n    case Formattable::kDouble:\n        if (fValue.fDouble > INT32_MAX) {\n            status = U_INVALID_FORMAT_ERROR;\n            return INT32_MAX;\n        } else if (fValue.fDouble < INT32_MIN) {\n            status = U_INVALID_FORMAT_ERROR;\n            return INT32_MIN;\n        } else {\n            return (int32_t)fValue.fDouble; // loses fraction\n        }\n    case Formattable::kObject:\n        if (fValue.fObject == NULL) {\n            status = U_MEMORY_ALLOCATION_ERROR;\n            return 0;\n        }\n        // TODO Later replace this with instanceof call\n        if (instanceOfMeasure(fValue.fObject)) {\n            return ((const Measure*) fValue.fObject)->\n                getNumber().getLong(status);\n        }\n        U_FALLTHROUGH;\n    default:\n        status = U_INVALID_FORMAT_ERROR;\n        return 0;\n    }\n}\n\n// -------------------------------------\n// Maximum int that can be represented exactly in a double.  (53 bits)\n//    Larger ints may be rounded to a near-by value as not all are representable.\n// TODO:  move this constant elsewhere, possibly configure it for different\n//        floating point formats, if any non-standard ones are still in use.\nstatic const int64_t U_DOUBLE_MAX_EXACT_INT = 9007199254740992LL;\n\nint64_t\nFormattable::getInt64(UErrorCode& status) const\n{\n    if (U_FAILURE(status)) {\n        return 0;\n    }\n        \n    switch (fType) {\n    case Formattable::kLong: \n    case Formattable::kInt64: \n        return fValue.fInt64;\n    case Formattable::kDouble:\n        if (fValue.fDouble > (double)U_INT64_MAX) {\n            status = U_INVALID_FORMAT_ERROR;\n            return U_INT64_MAX;\n        } else if (fValue.fDouble < (double)U_INT64_MIN) {\n            status = U_INVALID_FORMAT_ERROR;\n            return U_INT64_MIN;\n        } else if (fabs(fValue.fDouble) > U_DOUBLE_MAX_EXACT_INT && fDecimalQuantity != NULL) {\n            if (fDecimalQuantity->fitsInLong(true)) {\n                return fDecimalQuantity->toLong();\n            } else {\n                // Unexpected\n                status = U_INVALID_FORMAT_ERROR;\n                return fDecimalQuantity->isNegative() ? U_INT64_MIN : U_INT64_MAX;\n            }\n        } else {\n            return (int64_t)fValue.fDouble;\n        } \n    case Formattable::kObject:\n        if (fValue.fObject == NULL) {\n            status = U_MEMORY_ALLOCATION_ERROR;\n            return 0;\n        }\n        if (instanceOfMeasure(fValue.fObject)) {\n            return ((const Measure*) fValue.fObject)->\n                getNumber().getInt64(status);\n        }\n        U_FALLTHROUGH;\n    default:\n        status = U_INVALID_FORMAT_ERROR;\n        return 0;\n    }\n}\n\n// -------------------------------------\ndouble\nFormattable::getDouble(UErrorCode& status) const\n{\n    if (U_FAILURE(status)) {\n        return 0;\n    }\n        \n    switch (fType) {\n    case Formattable::kLong: \n    case Formattable::kInt64: // loses precision\n        return (double)fValue.fInt64;\n    case Formattable::kDouble:\n        return fValue.fDouble;\n    case Formattable::kObject:\n        if (fValue.fObject == NULL) {\n            status = U_MEMORY_ALLOCATION_ERROR;\n            return 0;\n        }\n        // TODO Later replace this with instanceof call\n        if (instanceOfMeasure(fValue.fObject)) {\n            return ((const Measure*) fValue.fObject)->\n                getNumber().getDouble(status);\n        }\n        U_FALLTHROUGH;\n    default:\n        status = U_INVALID_FORMAT_ERROR;\n        return 0;\n    }\n}\n\nconst UObject*\nFormattable::getObject() const {\n    return (fType == kObject) ? fValue.fObject : NULL;\n}\n\n// -------------------------------------\n// Sets the value to a double value d.\n\nvoid\nFormattable::setDouble(double d)\n{\n    dispose();\n    fType = kDouble;\n    fValue.fDouble = d;\n}\n\n// -------------------------------------\n// Sets the value to a long value l.\n\nvoid\nFormattable::setLong(int32_t l)\n{\n    dispose();\n    fType = kLong;\n    fValue.fInt64 = l;\n}\n\n// -------------------------------------\n// Sets the value to an int64 value ll.\n\nvoid\nFormattable::setInt64(int64_t ll)\n{\n    dispose();\n    fType = kInt64;\n    fValue.fInt64 = ll;\n}\n\n// -------------------------------------\n// Sets the value to a Date instance d.\n\nvoid\nFormattable::setDate(UDate d)\n{\n    dispose();\n    fType = kDate;\n    fValue.fDate = d;\n}\n\n// -------------------------------------\n// Sets the value to a string value stringToCopy.\n\nvoid\nFormattable::setString(const UnicodeString& stringToCopy)\n{\n    dispose();\n    fType = kString;\n    fValue.fString = new UnicodeString(stringToCopy);\n}\n\n// -------------------------------------\n// Sets the value to an array of Formattable objects.\n\nvoid\nFormattable::setArray(const Formattable* array, int32_t count)\n{\n    dispose();\n    fType = kArray;\n    fValue.fArrayAndCount.fArray = createArrayCopy(array, count);\n    fValue.fArrayAndCount.fCount = count;\n}\n\n// -------------------------------------\n// Adopts the stringToAdopt value.\n\nvoid\nFormattable::adoptString(UnicodeString* stringToAdopt)\n{\n    dispose();\n    fType = kString;\n    fValue.fString = stringToAdopt;\n}\n\n// -------------------------------------\n// Adopts the array value and its count.\n\nvoid\nFormattable::adoptArray(Formattable* array, int32_t count)\n{\n    dispose();\n    fType = kArray;\n    fValue.fArrayAndCount.fArray = array;\n    fValue.fArrayAndCount.fCount = count;\n}\n\nvoid\nFormattable::adoptObject(UObject* objectToAdopt) {\n    dispose();\n    fType = kObject;\n    fValue.fObject = objectToAdopt;\n}\n\n// -------------------------------------\nUnicodeString& \nFormattable::getString(UnicodeString& result, UErrorCode& status) const \n{\n    if (fType != kString) {\n        setError(status, U_INVALID_FORMAT_ERROR);\n        result.setToBogus();\n    } else {\n        if (fValue.fString == NULL) {\n            setError(status, U_MEMORY_ALLOCATION_ERROR);\n        } else {\n            result = *fValue.fString;\n        }\n    }\n    return result;\n}\n\n// -------------------------------------\nconst UnicodeString& \nFormattable::getString(UErrorCode& status) const \n{\n    if (fType != kString) {\n        setError(status, U_INVALID_FORMAT_ERROR);\n        return *getBogus();\n    }\n    if (fValue.fString == NULL) {\n        setError(status, U_MEMORY_ALLOCATION_ERROR);\n        return *getBogus();\n    }\n    return *fValue.fString;\n}\n\n// -------------------------------------\nUnicodeString& \nFormattable::getString(UErrorCode& status) \n{\n    if (fType != kString) {\n        setError(status, U_INVALID_FORMAT_ERROR);\n        return *getBogus();\n    }\n    if (fValue.fString == NULL) {\n    \tsetError(status, U_MEMORY_ALLOCATION_ERROR);\n    \treturn *getBogus();\n    }\n    return *fValue.fString;\n}\n\n// -------------------------------------\nconst Formattable* \nFormattable::getArray(int32_t& count, UErrorCode& status) const \n{\n    if (fType != kArray) {\n        setError(status, U_INVALID_FORMAT_ERROR);\n        count = 0;\n        return NULL;\n    }\n    count = fValue.fArrayAndCount.fCount; \n    return fValue.fArrayAndCount.fArray;\n}\n\n// -------------------------------------\n// Gets the bogus string, ensures mondo bogosity.\n\nUnicodeString*\nFormattable::getBogus() const \n{\n    return (UnicodeString*)&fBogus; /* cast away const :-( */\n}\n\n\n// --------------------------------------\nStringPiece Formattable::getDecimalNumber(UErrorCode &status) {\n    if (U_FAILURE(status)) {\n        return \"\";\n    }\n    if (fDecimalStr != NULL) {\n      return fDecimalStr->toStringPiece();\n    }\n\n    CharString *decimalStr = internalGetCharString(status);\n    if(decimalStr == NULL) {\n      return \"\"; // getDecimalNumber returns \"\" for error cases\n    } else {\n      return decimalStr->toStringPiece();\n    }\n}\n\nCharString *Formattable::internalGetCharString(UErrorCode &status) {\n    if(fDecimalStr == NULL) {\n      if (fDecimalQuantity == NULL) {\n        // No decimal number for the formattable yet.  Which means the value was\n        // set directly by the user as an int, int64 or double.  If the value came\n        // from parsing, or from the user setting a decimal number, fDecimalNum\n        // would already be set.\n        //\n        LocalPointer<DecimalQuantity> dq(new DecimalQuantity(), status);\n        if (U_FAILURE(status)) { return nullptr; }\n        populateDecimalQuantity(*dq, status);\n        if (U_FAILURE(status)) { return nullptr; }\n        fDecimalQuantity = dq.orphan();\n      }\n\n      fDecimalStr = new CharString();\n      if (fDecimalStr == NULL) {\n        status = U_MEMORY_ALLOCATION_ERROR;\n        return NULL;\n      }\n      // Older ICUs called uprv_decNumberToString here, which is not exactly the same as\n      // DecimalQuantity::toScientificString(). The biggest difference is that uprv_decNumberToString does\n      // not print scientific notation for magnitudes greater than -5 and smaller than some amount (+5?).\n      if (fDecimalQuantity->isZero()) {\n        fDecimalStr->append(\"0\", -1, status);\n      } else if (std::abs(fDecimalQuantity->getMagnitude()) < 5) {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toPlainString(), status);\n      } else {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toScientificString(), status);\n      }\n    }\n    return fDecimalStr;\n}\n\nvoid\nFormattable::populateDecimalQuantity(number::impl::DecimalQuantity& output, UErrorCode& status) const {\n    if (fDecimalQuantity != nullptr) {\n        output = *fDecimalQuantity;\n        return;\n    }\n\n    switch (fType) {\n        case kDouble:\n            output.setToDouble(this->getDouble());\n            output.roundToInfinity();\n            break;\n        case kLong:\n            output.setToInt(this->getLong());\n            break;\n        case kInt64:\n            output.setToLong(this->getInt64());\n            break;\n        default:\n            // The formattable's value is not a numeric type.\n            status = U_INVALID_STATE_ERROR;\n    }\n}\n\n// ---------------------------------------\nvoid\nFormattable::adoptDecimalQuantity(DecimalQuantity *dq) {\n    if (fDecimalQuantity != NULL) {\n        delete fDecimalQuantity;\n    }\n    fDecimalQuantity = dq;\n    if (dq == NULL) { // allow adoptDigitList(NULL) to clear\n        return;\n    }\n\n    // Set the value into the Union of simple type values.\n    // Cannot use the set() functions because they would delete the fDecimalNum value.\n    if (fDecimalQuantity->fitsInLong()) {\n        fValue.fInt64 = fDecimalQuantity->toLong();\n        if (fValue.fInt64 <= INT32_MAX && fValue.fInt64 >= INT32_MIN) {\n            fType = kLong;\n        } else {\n            fType = kInt64;\n        }\n    } else {\n        fType = kDouble;\n        fValue.fDouble = fDecimalQuantity->toDouble();\n    }\n}\n\n\n// ---------------------------------------\nvoid\nFormattable::setDecimalNumber(StringPiece numberString, UErrorCode &status) {\n    if (U_FAILURE(status)) {\n        return;\n    }\n    dispose();\n\n    auto* dq = new DecimalQuantity();\n    dq->setToDecNumber(numberString, status);\n    adoptDecimalQuantity(dq);\n\n    // Note that we do not hang on to the caller's input string.\n    // If we are asked for the string, we will regenerate one from fDecimalQuantity.\n}\n\n#if 0\n//----------------------------------------------------\n// console I/O\n//----------------------------------------------------\n#ifdef _DEBUG\n\n#include <iostream>\nusing namespace std;\n\n#include \"unicode/datefmt.h\"\n#include \"unistrm.h\"\n\nclass FormattableStreamer /* not : public UObject because all methods are static */ {\npublic:\n    static void streamOut(ostream& stream, const Formattable& obj);\n\nprivate:\n    FormattableStreamer() {} // private - forbid instantiation\n};\n\n// This is for debugging purposes only.  This will send a displayable\n// form of the Formattable object to the output stream.\n\nvoid\nFormattableStreamer::streamOut(ostream& stream, const Formattable& obj)\n{\n    static DateFormat *defDateFormat = 0;\n\n    UnicodeString buffer;\n    switch(obj.getType()) {\n        case Formattable::kDate : \n            // Creates a DateFormat instance for formatting the\n            // Date instance.\n            if (defDateFormat == 0) {\n                defDateFormat = DateFormat::createInstance();\n            }\n            defDateFormat->format(obj.getDate(), buffer);\n            stream << buffer;\n            break;\n        case Formattable::kDouble :\n            // Output the double as is.\n            stream << obj.getDouble() << 'D';\n            break;\n        case Formattable::kLong :\n            // Output the double as is.\n            stream << obj.getLong() << 'L';\n            break;\n        case Formattable::kString:\n            // Output the double as is.  Please see UnicodeString console\n            // I/O routine for more details.\n            stream << '\"' << obj.getString(buffer) << '\"';\n            break;\n        case Formattable::kArray:\n            int32_t i, count;\n            const Formattable* array;\n            array = obj.getArray(count);\n            stream << '[';\n            // Recursively calling the console I/O routine for each element in the array.\n            for (i=0; i<count; ++i) {\n                FormattableStreamer::streamOut(stream, array[i]);\n                stream << ( (i==(count-1)) ? \"\" : \", \" );\n            }\n            stream << ']';\n            break;\n        default:\n            // Not a recognizable Formattable object.\n            stream << \"INVALID_Formattable\";\n    }\n    stream.flush();\n}\n#endif\n\n#endif\n\nU_NAMESPACE_END\n\n/* ---- UFormattable implementation ---- */\n\nU_NAMESPACE_USE\n\nU_DRAFT UFormattable* U_EXPORT2\nufmt_open(UErrorCode *status) {\n  if( U_FAILURE(*status) ) {\n    return NULL;\n  }\n  UFormattable *fmt = (new Formattable())->toUFormattable();\n\n  if( fmt == NULL ) {\n    *status = U_MEMORY_ALLOCATION_ERROR;\n  }\n  return fmt;\n}\n\nU_DRAFT void U_EXPORT2\nufmt_close(UFormattable *fmt) {\n  Formattable *obj = Formattable::fromUFormattable(fmt);\n\n  delete obj;\n}\n\nU_INTERNAL UFormattableType U_EXPORT2\nufmt_getType(const UFormattable *fmt, UErrorCode *status) {\n  if(U_FAILURE(*status)) {\n    return (UFormattableType)UFMT_COUNT;\n  }\n  const Formattable *obj = Formattable::fromUFormattable(fmt);\n  return (UFormattableType)obj->getType();\n}\n\n\nU_INTERNAL UBool U_EXPORT2\nufmt_isNumeric(const UFormattable *fmt) {\n  const Formattable *obj = Formattable::fromUFormattable(fmt);\n  return obj->isNumeric();\n}\n\nU_DRAFT UDate U_EXPORT2\nufmt_getDate(const UFormattable *fmt, UErrorCode *status) {\n  const Formattable *obj = Formattable::fromUFormattable(fmt);\n\n  return obj->getDate(*status);\n}\n\nU_DRAFT double U_EXPORT2\nufmt_getDouble(UFormattable *fmt, UErrorCode *status) {\n  Formattable *obj = Formattable::fromUFormattable(fmt);\n\n  return obj->getDouble(*status);\n}\n\nU_DRAFT int32_t U_EXPORT2\nufmt_getLong(UFormattable *fmt, UErrorCode *status) {\n  Formattable *obj = Formattable::fromUFormattable(fmt);\n\n  return obj->getLong(*status);\n}\n\n\nU_DRAFT const void *U_EXPORT2\nufmt_getObject(const UFormattable *fmt, UErrorCode *status) {\n  const Formattable *obj = Formattable::fromUFormattable(fmt);\n\n  const void *ret = obj->getObject();\n  if( ret==NULL &&\n      (obj->getType() != Formattable::kObject) &&\n      U_SUCCESS( *status )) {\n    *status = U_INVALID_FORMAT_ERROR;\n  }\n  return ret;\n}\n\nU_DRAFT const UChar* U_EXPORT2\nufmt_getUChars(UFormattable *fmt, int32_t *len, UErrorCode *status) {\n  Formattable *obj = Formattable::fromUFormattable(fmt);\n\n  // avoid bogosity by checking the type first.\n  if( obj->getType() != Formattable::kString ) {\n    if( U_SUCCESS(*status) ){\n      *status = U_INVALID_FORMAT_ERROR;\n    }\n    return NULL;\n  }\n\n  // This should return a valid string\n  UnicodeString &str = obj->getString(*status);\n  if( U_SUCCESS(*status) && len != NULL ) {\n    *len = str.length();\n  }\n  return str.getTerminatedBuffer();\n}\n\nU_DRAFT int32_t U_EXPORT2\nufmt_getArrayLength(const UFormattable* fmt, UErrorCode *status) {\n  const Formattable *obj = Formattable::fromUFormattable(fmt);\n\n  int32_t count;\n  (void)obj->getArray(count, *status);\n  return count;\n}\n\nU_DRAFT UFormattable * U_EXPORT2\nufmt_getArrayItemByIndex(UFormattable* fmt, int32_t n, UErrorCode *status) {\n  Formattable *obj = Formattable::fromUFormattable(fmt);\n  int32_t count;\n  (void)obj->getArray(count, *status);\n  if(U_FAILURE(*status)) {\n    return NULL;\n  } else if(n<0 || n>=count) {\n    setError(*status, U_INDEX_OUTOFBOUNDS_ERROR);\n    return NULL;\n  } else {\n    return (*obj)[n].toUFormattable(); // returns non-const Formattable\n  }\n}\n\nU_DRAFT const char * U_EXPORT2\nufmt_getDecNumChars(UFormattable *fmt, int32_t *len, UErrorCode *status) {\n  if(U_FAILURE(*status)) {\n    return \"\";\n  }\n  Formattable *obj = Formattable::fromUFormattable(fmt);\n  CharString *charString = obj->internalGetCharString(*status);\n  if(U_FAILURE(*status)) {\n    return \"\";\n  }\n  if(charString == NULL) {\n    *status = U_MEMORY_ALLOCATION_ERROR;\n    return \"\";\n  } else {\n    if(len!=NULL) {\n      *len = charString->length();\n    }\n    return charString->data();\n  }\n}\n\nU_DRAFT int64_t U_EXPORT2\nufmt_getInt64(UFormattable *fmt, UErrorCode *status) {\n  Formattable *obj = Formattable::fromUFormattable(fmt);\n  return obj->getInt64(*status);\n}\n\n#endif /* #if !UCONFIG_NO_FORMATTING */\n\n//eof\n", "// \u00a9 2017 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html\n\n#include \"unicode/utypes.h\"\n\n#if !UCONFIG_NO_FORMATTING\n\n#include <cstdlib>\n#include <cmath>\n#include <limits>\n#include <stdlib.h>\n\n#include \"unicode/plurrule.h\"\n#include \"cmemory.h\"\n#include \"number_decnum.h\"\n#include \"putilimp.h\"\n#include \"number_decimalquantity.h\"\n#include \"number_roundingutils.h\"\n#include \"double-conversion.h\"\n#include \"charstr.h\"\n#include \"number_utils.h\"\n#include \"uassert.h\"\n\nusing namespace icu;\nusing namespace icu::number;\nusing namespace icu::number::impl;\n\nusing icu::double_conversion::DoubleToStringConverter;\nusing icu::double_conversion::StringToDoubleConverter;\n\nnamespace {\n\nint8_t NEGATIVE_FLAG = 1;\nint8_t INFINITY_FLAG = 2;\nint8_t NAN_FLAG = 4;\n\n/** Helper function for safe subtraction (no overflow). */\ninline int32_t safeSubtract(int32_t a, int32_t b) {\n    // Note: In C++, signed integer subtraction is undefined behavior.\n    int32_t diff = static_cast<int32_t>(static_cast<uint32_t>(a) - static_cast<uint32_t>(b));\n    if (b < 0 && diff < a) { return INT32_MAX; }\n    if (b > 0 && diff > a) { return INT32_MIN; }\n    return diff;\n}\n\nstatic double DOUBLE_MULTIPLIERS[] = {\n        1e0,\n        1e1,\n        1e2,\n        1e3,\n        1e4,\n        1e5,\n        1e6,\n        1e7,\n        1e8,\n        1e9,\n        1e10,\n        1e11,\n        1e12,\n        1e13,\n        1e14,\n        1e15,\n        1e16,\n        1e17,\n        1e18,\n        1e19,\n        1e20,\n        1e21};\n\n}  // namespace\n\nicu::IFixedDecimal::~IFixedDecimal() = default;\n\nDecimalQuantity::DecimalQuantity() {\n    setBcdToZero();\n    flags = 0;\n}\n\nDecimalQuantity::~DecimalQuantity() {\n    if (usingBytes) {\n        uprv_free(fBCD.bcdBytes.ptr);\n        fBCD.bcdBytes.ptr = nullptr;\n        usingBytes = false;\n    }\n}\n\nDecimalQuantity::DecimalQuantity(const DecimalQuantity &other) {\n    *this = other;\n}\n\nDecimalQuantity::DecimalQuantity(DecimalQuantity&& src) U_NOEXCEPT {\n    *this = std::move(src);\n}\n\nDecimalQuantity &DecimalQuantity::operator=(const DecimalQuantity &other) {\n    if (this == &other) {\n        return *this;\n    }\n    copyBcdFrom(other);\n    copyFieldsFrom(other);\n    return *this;\n}\n\nDecimalQuantity& DecimalQuantity::operator=(DecimalQuantity&& src) U_NOEXCEPT {\n    if (this == &src) {\n        return *this;\n    }\n    moveBcdFrom(src);\n    copyFieldsFrom(src);\n    return *this;\n}\n\nvoid DecimalQuantity::copyFieldsFrom(const DecimalQuantity& other) {\n    bogus = other.bogus;\n    lOptPos = other.lOptPos;\n    lReqPos = other.lReqPos;\n    rReqPos = other.rReqPos;\n    rOptPos = other.rOptPos;\n    scale = other.scale;\n    precision = other.precision;\n    flags = other.flags;\n    origDouble = other.origDouble;\n    origDelta = other.origDelta;\n    isApproximate = other.isApproximate;\n}\n\nvoid DecimalQuantity::clear() {\n    lOptPos = INT32_MAX;\n    lReqPos = 0;\n    rReqPos = 0;\n    rOptPos = INT32_MIN;\n    flags = 0;\n    setBcdToZero(); // sets scale, precision, hasDouble, origDouble, origDelta, and BCD data\n}\n\nvoid DecimalQuantity::setIntegerLength(int32_t minInt, int32_t maxInt) {\n    // Validation should happen outside of DecimalQuantity, e.g., in the Precision class.\n    U_ASSERT(minInt >= 0);\n    U_ASSERT(maxInt >= minInt);\n\n    // Special behavior: do not set minInt to be less than what is already set.\n    // This is so significant digits rounding can set the integer length.\n    if (minInt < lReqPos) {\n        minInt = lReqPos;\n    }\n\n    // Save values into internal state\n    // Negation is safe for minFrac/maxFrac because -Integer.MAX_VALUE > Integer.MIN_VALUE\n    lOptPos = maxInt;\n    lReqPos = minInt;\n}\n\nvoid DecimalQuantity::setFractionLength(int32_t minFrac, int32_t maxFrac) {\n    // Validation should happen outside of DecimalQuantity, e.g., in the Precision class.\n    U_ASSERT(minFrac >= 0);\n    U_ASSERT(maxFrac >= minFrac);\n\n    // Save values into internal state\n    // Negation is safe for minFrac/maxFrac because -Integer.MAX_VALUE > Integer.MIN_VALUE\n    rReqPos = -minFrac;\n    rOptPos = -maxFrac;\n}\n\nuint64_t DecimalQuantity::getPositionFingerprint() const {\n    uint64_t fingerprint = 0;\n    fingerprint ^= lOptPos;\n    fingerprint ^= (lReqPos << 16);\n    fingerprint ^= (static_cast<uint64_t>(rReqPos) << 32);\n    fingerprint ^= (static_cast<uint64_t>(rOptPos) << 48);\n    return fingerprint;\n}\n\nvoid DecimalQuantity::roundToIncrement(double roundingIncrement, RoundingMode roundingMode,\n                                       int32_t maxFrac, UErrorCode& status) {\n    // TODO(13701): Move the nickel check into a higher-level API.\n    if (roundingIncrement == 0.05) {\n        roundToMagnitude(-2, roundingMode, true, status);\n        roundToMagnitude(-maxFrac, roundingMode, false, status);\n        return;\n    } else if (roundingIncrement == 0.5) {\n        roundToMagnitude(-1, roundingMode, true, status);\n        roundToMagnitude(-maxFrac, roundingMode, false, status);\n        return;\n    }\n    // TODO(13701): This is innefficient.  Improve?\n    // TODO(13701): Should we convert to decNumber instead?\n    roundToInfinity();\n    double temp = toDouble();\n    temp /= roundingIncrement;\n    // Use another DecimalQuantity to perform the actual rounding...\n    DecimalQuantity dq;\n    dq.setToDouble(temp);\n    dq.roundToMagnitude(0, roundingMode, status);\n    temp = dq.toDouble();\n    temp *= roundingIncrement;\n    setToDouble(temp);\n    // Since we reset the value to a double, we need to specify the rounding boundary\n    // in order to get the DecimalQuantity out of approximation mode.\n    // NOTE: In Java, we have minMaxFrac, but in C++, the two are differentiated.\n    roundToMagnitude(-maxFrac, roundingMode, status);\n}\n\nvoid DecimalQuantity::multiplyBy(const DecNum& multiplicand, UErrorCode& status) {\n    if (isInfinite() || isZero() || isNaN()) {\n        return;\n    }\n    // Convert to DecNum, multiply, and convert back.\n    DecNum decnum;\n    toDecNum(decnum, status);\n    if (U_FAILURE(status)) { return; }\n    decnum.multiplyBy(multiplicand, status);\n    if (U_FAILURE(status)) { return; }\n    setToDecNum(decnum, status);\n}\n\nvoid DecimalQuantity::divideBy(const DecNum& divisor, UErrorCode& status) {\n    if (isInfinite() || isZero() || isNaN()) {\n        return;\n    }\n    // Convert to DecNum, multiply, and convert back.\n    DecNum decnum;\n    toDecNum(decnum, status);\n    if (U_FAILURE(status)) { return; }\n    decnum.divideBy(divisor, status);\n    if (U_FAILURE(status)) { return; }\n    setToDecNum(decnum, status);\n}\n\nvoid DecimalQuantity::negate() {\n    flags ^= NEGATIVE_FLAG;\n}\n\nint32_t DecimalQuantity::getMagnitude() const {\n    U_ASSERT(precision != 0);\n    return scale + precision - 1;\n}\n\nbool DecimalQuantity::adjustMagnitude(int32_t delta) {\n    if (precision != 0) {\n        // i.e., scale += delta; origDelta += delta\n        bool overflow = uprv_add32_overflow(scale, delta, &scale);\n        overflow = uprv_add32_overflow(origDelta, delta, &origDelta) || overflow;\n        // Make sure that precision + scale won't overflow, either\n        int32_t dummy;\n        overflow = overflow || uprv_add32_overflow(scale, precision, &dummy);\n        return overflow;\n    }\n    return false;\n}\n\ndouble DecimalQuantity::getPluralOperand(PluralOperand operand) const {\n    // If this assertion fails, you need to call roundToInfinity() or some other rounding method.\n    // See the comment at the top of this file explaining the \"isApproximate\" field.\n    U_ASSERT(!isApproximate);\n\n    switch (operand) {\n        case PLURAL_OPERAND_I:\n            // Invert the negative sign if necessary\n            return static_cast<double>(isNegative() ? -toLong(true) : toLong(true));\n        case PLURAL_OPERAND_F:\n            return static_cast<double>(toFractionLong(true));\n        case PLURAL_OPERAND_T:\n            return static_cast<double>(toFractionLong(false));\n        case PLURAL_OPERAND_V:\n            return fractionCount();\n        case PLURAL_OPERAND_W:\n            return fractionCountWithoutTrailingZeros();\n        default:\n            return std::abs(toDouble());\n    }\n}\n\nbool DecimalQuantity::hasIntegerValue() const {\n    return scale >= 0;\n}\n\nint32_t DecimalQuantity::getUpperDisplayMagnitude() const {\n    // If this assertion fails, you need to call roundToInfinity() or some other rounding method.\n    // See the comment in the header file explaining the \"isApproximate\" field.\n    U_ASSERT(!isApproximate);\n\n    int32_t magnitude = scale + precision;\n    int32_t result = (lReqPos > magnitude) ? lReqPos : (lOptPos < magnitude) ? lOptPos : magnitude;\n    return result - 1;\n}\n\nint32_t DecimalQuantity::getLowerDisplayMagnitude() const {\n    // If this assertion fails, you need to call roundToInfinity() or some other rounding method.\n    // See the comment in the header file explaining the \"isApproximate\" field.\n    U_ASSERT(!isApproximate);\n\n    int32_t magnitude = scale;\n    int32_t result = (rReqPos < magnitude) ? rReqPos : (rOptPos > magnitude) ? rOptPos : magnitude;\n    return result;\n}\n\nint8_t DecimalQuantity::getDigit(int32_t magnitude) const {\n    // If this assertion fails, you need to call roundToInfinity() or some other rounding method.\n    // See the comment at the top of this file explaining the \"isApproximate\" field.\n    U_ASSERT(!isApproximate);\n\n    return getDigitPos(magnitude - scale);\n}\n\nint32_t DecimalQuantity::fractionCount() const {\n    return -getLowerDisplayMagnitude();\n}\n\nint32_t DecimalQuantity::fractionCountWithoutTrailingZeros() const {\n    return -scale > 0 ? -scale : 0;  // max(-scale, 0)\n}\n\nbool DecimalQuantity::isNegative() const {\n    return (flags & NEGATIVE_FLAG) != 0;\n}\n\nint8_t DecimalQuantity::signum() const {\n    return isNegative() ? -1 : isZero() ? 0 : 1;\n}\n\nbool DecimalQuantity::isInfinite() const {\n    return (flags & INFINITY_FLAG) != 0;\n}\n\nbool DecimalQuantity::isNaN() const {\n    return (flags & NAN_FLAG) != 0;\n}\n\nbool DecimalQuantity::isZero() const {\n    return precision == 0;\n}\n\nDecimalQuantity &DecimalQuantity::setToInt(int32_t n) {\n    setBcdToZero();\n    flags = 0;\n    if (n == INT32_MIN) {\n        flags |= NEGATIVE_FLAG;\n        // leave as INT32_MIN; handled below in _setToInt()\n    } else if (n < 0) {\n        flags |= NEGATIVE_FLAG;\n        n = -n;\n    }\n    if (n != 0) {\n        _setToInt(n);\n        compact();\n    }\n    return *this;\n}\n\nvoid DecimalQuantity::_setToInt(int32_t n) {\n    if (n == INT32_MIN) {\n        readLongToBcd(-static_cast<int64_t>(n));\n    } else {\n        readIntToBcd(n);\n    }\n}\n\nDecimalQuantity &DecimalQuantity::setToLong(int64_t n) {\n    setBcdToZero();\n    flags = 0;\n    if (n < 0 && n > INT64_MIN) {\n        flags |= NEGATIVE_FLAG;\n        n = -n;\n    }\n    if (n != 0) {\n        _setToLong(n);\n        compact();\n    }\n    return *this;\n}\n\nvoid DecimalQuantity::_setToLong(int64_t n) {\n    if (n == INT64_MIN) {\n        DecNum decnum;\n        UErrorCode localStatus = U_ZERO_ERROR;\n        decnum.setTo(\"9.223372036854775808E+18\", localStatus);\n        if (U_FAILURE(localStatus)) { return; } // unexpected\n        flags |= NEGATIVE_FLAG;\n        readDecNumberToBcd(decnum);\n    } else if (n <= INT32_MAX) {\n        readIntToBcd(static_cast<int32_t>(n));\n    } else {\n        readLongToBcd(n);\n    }\n}\n\nDecimalQuantity &DecimalQuantity::setToDouble(double n) {\n    setBcdToZero();\n    flags = 0;\n    // signbit() from <math.h> handles +0.0 vs -0.0\n    if (std::signbit(n)) {\n        flags |= NEGATIVE_FLAG;\n        n = -n;\n    }\n    if (std::isnan(n) != 0) {\n        flags |= NAN_FLAG;\n    } else if (std::isfinite(n) == 0) {\n        flags |= INFINITY_FLAG;\n    } else if (n != 0) {\n        _setToDoubleFast(n);\n        compact();\n    }\n    return *this;\n}\n\nvoid DecimalQuantity::_setToDoubleFast(double n) {\n    isApproximate = true;\n    origDouble = n;\n    origDelta = 0;\n\n    // Make sure the double is an IEEE 754 double.  If not, fall back to the slow path right now.\n    // TODO: Make a fast path for other types of doubles.\n    if (!std::numeric_limits<double>::is_iec559) {\n        convertToAccurateDouble();\n        // Turn off the approximate double flag, since the value is now exact.\n        isApproximate = false;\n        origDouble = 0.0;\n        return;\n    }\n\n    // To get the bits from the double, use memcpy, which takes care of endianness.\n    uint64_t ieeeBits;\n    uprv_memcpy(&ieeeBits, &n, sizeof(n));\n    int32_t exponent = static_cast<int32_t>((ieeeBits & 0x7ff0000000000000L) >> 52) - 0x3ff;\n\n    // Not all integers can be represented exactly for exponent > 52\n    if (exponent <= 52 && static_cast<int64_t>(n) == n) {\n        _setToLong(static_cast<int64_t>(n));\n        return;\n    }\n\n    // 3.3219... is log2(10)\n    auto fracLength = static_cast<int32_t> ((52 - exponent) / 3.32192809489);\n    if (fracLength >= 0) {\n        int32_t i = fracLength;\n        // 1e22 is the largest exact double.\n        for (; i >= 22; i -= 22) n *= 1e22;\n        n *= DOUBLE_MULTIPLIERS[i];\n    } else {\n        int32_t i = fracLength;\n        // 1e22 is the largest exact double.\n        for (; i <= -22; i += 22) n /= 1e22;\n        n /= DOUBLE_MULTIPLIERS[-i];\n    }\n    auto result = static_cast<int64_t>(std::round(n));\n    if (result != 0) {\n        _setToLong(result);\n        scale -= fracLength;\n    }\n}\n\nvoid DecimalQuantity::convertToAccurateDouble() {\n    U_ASSERT(origDouble != 0);\n    int32_t delta = origDelta;\n\n    // Call the slow oracle function (Double.toString in Java, DoubleToAscii in C++).\n    char buffer[DoubleToStringConverter::kBase10MaximalLength + 1];\n    bool sign; // unused; always positive\n    int32_t length;\n    int32_t point;\n    DoubleToStringConverter::DoubleToAscii(\n        origDouble,\n        DoubleToStringConverter::DtoaMode::SHORTEST,\n        0,\n        buffer,\n        sizeof(buffer),\n        &sign,\n        &length,\n        &point\n    );\n\n    setBcdToZero();\n    readDoubleConversionToBcd(buffer, length, point);\n    scale += delta;\n    explicitExactDouble = true;\n}\n\nDecimalQuantity &DecimalQuantity::setToDecNumber(StringPiece n, UErrorCode& status) {\n    setBcdToZero();\n    flags = 0;\n\n    // Compute the decNumber representation\n    DecNum decnum;\n    decnum.setTo(n, status);\n\n    _setToDecNum(decnum, status);\n    return *this;\n}\n\nDecimalQuantity& DecimalQuantity::setToDecNum(const DecNum& decnum, UErrorCode& status) {\n    setBcdToZero();\n    flags = 0;\n\n    _setToDecNum(decnum, status);\n    return *this;\n}\n\nvoid DecimalQuantity::_setToDecNum(const DecNum& decnum, UErrorCode& status) {\n    if (U_FAILURE(status)) { return; }\n    if (decnum.isNegative()) {\n        flags |= NEGATIVE_FLAG;\n    }\n    if (!decnum.isZero()) {\n        readDecNumberToBcd(decnum);\n        compact();\n    }\n}\n\nint64_t DecimalQuantity::toLong(bool truncateIfOverflow) const {\n    // NOTE: Call sites should be guarded by fitsInLong(), like this:\n    // if (dq.fitsInLong()) { /* use dq.toLong() */ } else { /* use some fallback */ }\n    // Fallback behavior upon truncateIfOverflow is to truncate at 17 digits.\n    uint64_t result = 0L;\n    int32_t upperMagnitude = std::min(scale + precision, lOptPos) - 1;\n    if (truncateIfOverflow) {\n        upperMagnitude = std::min(upperMagnitude, 17);\n    }\n    for (int32_t magnitude = upperMagnitude; magnitude >= 0; magnitude--) {\n        result = result * 10 + getDigitPos(magnitude - scale);\n    }\n    if (isNegative()) {\n        return static_cast<int64_t>(0LL - result); // i.e., -result\n    }\n    return static_cast<int64_t>(result);\n}\n\nuint64_t DecimalQuantity::toFractionLong(bool includeTrailingZeros) const {\n    uint64_t result = 0L;\n    int32_t magnitude = -1;\n    int32_t lowerMagnitude = std::max(scale, rOptPos);\n    if (includeTrailingZeros) {\n        lowerMagnitude = std::min(lowerMagnitude, rReqPos);\n    }\n    for (; magnitude >= lowerMagnitude && result <= 1e18L; magnitude--) {\n        result = result * 10 + getDigitPos(magnitude - scale);\n    }\n    // Remove trailing zeros; this can happen during integer overflow cases.\n    if (!includeTrailingZeros) {\n        while (result > 0 && (result % 10) == 0) {\n            result /= 10;\n        }\n    }\n    return result;\n}\n\nbool DecimalQuantity::fitsInLong(bool ignoreFraction) const {\n    if (isZero()) {\n        return true;\n    }\n    if (scale < 0 && !ignoreFraction) {\n        return false;\n    }\n    int magnitude = getMagnitude();\n    if (magnitude < 18) {\n        return true;\n    }\n    if (magnitude > 18) {\n        return false;\n    }\n    // Hard case: the magnitude is 10^18.\n    // The largest int64 is: 9,223,372,036,854,775,807\n    for (int p = 0; p < precision; p++) {\n        int8_t digit = getDigit(18 - p);\n        static int8_t INT64_BCD[] = { 9, 2, 2, 3, 3, 7, 2, 0, 3, 6, 8, 5, 4, 7, 7, 5, 8, 0, 8 };\n        if (digit < INT64_BCD[p]) {\n            return true;\n        } else if (digit > INT64_BCD[p]) {\n            return false;\n        }\n    }\n    // Exactly equal to max long plus one.\n    return isNegative();\n}\n\ndouble DecimalQuantity::toDouble() const {\n    // If this assertion fails, you need to call roundToInfinity() or some other rounding method.\n    // See the comment in the header file explaining the \"isApproximate\" field.\n    U_ASSERT(!isApproximate);\n\n    if (isNaN()) {\n        return NAN;\n    } else if (isInfinite()) {\n        return isNegative() ? -INFINITY : INFINITY;\n    }\n\n    // We are processing well-formed input, so we don't need any special options to StringToDoubleConverter.\n    StringToDoubleConverter converter(0, 0, 0, \"\", \"\");\n    UnicodeString numberString = this->toScientificString();\n    int32_t count;\n    return converter.StringToDouble(\n            reinterpret_cast<const uint16_t*>(numberString.getBuffer()),\n            numberString.length(),\n            &count);\n}\n\nvoid DecimalQuantity::toDecNum(DecNum& output, UErrorCode& status) const {\n    // Special handling for zero\n    if (precision == 0) {\n        output.setTo(\"0\", status);\n    }\n\n    // Use the BCD constructor. We need to do a little bit of work to convert, though.\n    // The decNumber constructor expects most-significant first, but we store least-significant first.\n    MaybeStackArray<uint8_t, 20> ubcd(precision);\n    for (int32_t m = 0; m < precision; m++) {\n        ubcd[precision - m - 1] = static_cast<uint8_t>(getDigitPos(m));\n    }\n    output.setTo(ubcd.getAlias(), precision, scale, isNegative(), status);\n}\n\nvoid DecimalQuantity::truncate() {\n    if (scale < 0) {\n        shiftRight(-scale);\n        scale = 0;\n        compact();\n    }\n}\n\nvoid DecimalQuantity::roundToNickel(int32_t magnitude, RoundingMode roundingMode, UErrorCode& status) {\n    roundToMagnitude(magnitude, roundingMode, true, status);\n}\n\nvoid DecimalQuantity::roundToMagnitude(int32_t magnitude, RoundingMode roundingMode, UErrorCode& status) {\n    roundToMagnitude(magnitude, roundingMode, false, status);\n}\n\nvoid DecimalQuantity::roundToMagnitude(int32_t magnitude, RoundingMode roundingMode, bool nickel, UErrorCode& status) {\n    // The position in the BCD at which rounding will be performed; digits to the right of position\n    // will be rounded away.\n    int position = safeSubtract(magnitude, scale);\n\n    // \"trailing\" = least significant digit to the left of rounding\n    int8_t trailingDigit = getDigitPos(position);\n\n    if (position <= 0 && !isApproximate && (!nickel || trailingDigit == 0 || trailingDigit == 5)) {\n        // All digits are to the left of the rounding magnitude.\n    } else if (precision == 0) {\n        // No rounding for zero.\n    } else {\n        // Perform rounding logic.\n        // \"leading\" = most significant digit to the right of rounding\n        int8_t leadingDigit = getDigitPos(safeSubtract(position, 1));\n\n        // Compute which section of the number we are in.\n        // EDGE means we are at the bottom or top edge, like 1.000 or 1.999 (used by doubles)\n        // LOWER means we are between the bottom edge and the midpoint, like 1.391\n        // MIDPOINT means we are exactly in the middle, like 1.500\n        // UPPER means we are between the midpoint and the top edge, like 1.916\n        roundingutils::Section section;\n        if (!isApproximate) {\n            if (nickel && trailingDigit != 2 && trailingDigit != 7) {\n                // Nickel rounding, and not at .02x or .07x\n                if (trailingDigit < 2) {\n                    // .00, .01 => down to .00\n                    section = roundingutils::SECTION_LOWER;\n                } else if (trailingDigit < 5) {\n                    // .03, .04 => up to .05\n                    section = roundingutils::SECTION_UPPER;\n                } else if (trailingDigit < 7) {\n                    // .05, .06 => down to .05\n                    section = roundingutils::SECTION_LOWER;\n                } else {\n                    // .08, .09 => up to .10\n                    section = roundingutils::SECTION_UPPER;\n                }\n            } else if (leadingDigit < 5) {\n                // Includes nickel rounding .020-.024 and .070-.074\n                section = roundingutils::SECTION_LOWER;\n            } else if (leadingDigit > 5) {\n                // Includes nickel rounding .026-.029 and .076-.079\n                section = roundingutils::SECTION_UPPER;\n            } else {\n                // Includes nickel rounding .025 and .075\n                section = roundingutils::SECTION_MIDPOINT;\n                for (int p = safeSubtract(position, 2); p >= 0; p--) {\n                    if (getDigitPos(p) != 0) {\n                        section = roundingutils::SECTION_UPPER;\n                        break;\n                    }\n                }\n            }\n        } else {\n            int32_t p = safeSubtract(position, 2);\n            int32_t minP = uprv_max(0, precision - 14);\n            if (leadingDigit == 0 && (!nickel || trailingDigit == 0 || trailingDigit == 5)) {\n                section = roundingutils::SECTION_LOWER_EDGE;\n                for (; p >= minP; p--) {\n                    if (getDigitPos(p) != 0) {\n                        section = roundingutils::SECTION_LOWER;\n                        break;\n                    }\n                }\n            } else if (leadingDigit == 4 && (!nickel || trailingDigit == 2 || trailingDigit == 7)) {\n                section = roundingutils::SECTION_MIDPOINT;\n                for (; p >= minP; p--) {\n                    if (getDigitPos(p) != 9) {\n                        section = roundingutils::SECTION_LOWER;\n                        break;\n                    }\n                }\n            } else if (leadingDigit == 5 && (!nickel || trailingDigit == 2 || trailingDigit == 7)) {\n                section = roundingutils::SECTION_MIDPOINT;\n                for (; p >= minP; p--) {\n                    if (getDigitPos(p) != 0) {\n                        section = roundingutils::SECTION_UPPER;\n                        break;\n                    }\n                }\n            } else if (leadingDigit == 9 && (!nickel || trailingDigit == 4 || trailingDigit == 9)) {\n                section = roundingutils::SECTION_UPPER_EDGE;\n                for (; p >= minP; p--) {\n                    if (getDigitPos(p) != 9) {\n                        section = roundingutils::SECTION_UPPER;\n                        break;\n                    }\n                }\n            } else if (nickel && trailingDigit != 2 && trailingDigit != 7) {\n                // Nickel rounding, and not at .02x or .07x\n                if (trailingDigit < 2) {\n                    // .00, .01 => down to .00\n                    section = roundingutils::SECTION_LOWER;\n                } else if (trailingDigit < 5) {\n                    // .03, .04 => up to .05\n                    section = roundingutils::SECTION_UPPER;\n                } else if (trailingDigit < 7) {\n                    // .05, .06 => down to .05\n                    section = roundingutils::SECTION_LOWER;\n                } else {\n                    // .08, .09 => up to .10\n                    section = roundingutils::SECTION_UPPER;\n                }\n            } else if (leadingDigit < 5) {\n                // Includes nickel rounding .020-.024 and .070-.074\n                section = roundingutils::SECTION_LOWER;\n            } else {\n                // Includes nickel rounding .026-.029 and .076-.079\n                section = roundingutils::SECTION_UPPER;\n            }\n\n            bool roundsAtMidpoint = roundingutils::roundsAtMidpoint(roundingMode);\n            if (safeSubtract(position, 1) < precision - 14 ||\n                (roundsAtMidpoint && section == roundingutils::SECTION_MIDPOINT) ||\n                (!roundsAtMidpoint && section < 0 /* i.e. at upper or lower edge */)) {\n                // Oops! This means that we have to get the exact representation of the double,\n                // because the zone of uncertainty is along the rounding boundary.\n                convertToAccurateDouble();\n                roundToMagnitude(magnitude, roundingMode, nickel, status); // start over\n                return;\n            }\n\n            // Turn off the approximate double flag, since the value is now confirmed to be exact.\n            isApproximate = false;\n            origDouble = 0.0;\n            origDelta = 0;\n\n            if (position <= 0 && (!nickel || trailingDigit == 0 || trailingDigit == 5)) {\n                // All digits are to the left of the rounding magnitude.\n                return;\n            }\n\n            // Good to continue rounding.\n            if (section == -1) { section = roundingutils::SECTION_LOWER; }\n            if (section == -2) { section = roundingutils::SECTION_UPPER; }\n        }\n\n        // Nickel rounding \"half even\" goes to the nearest whole (away from the 5).\n        bool isEven = nickel\n                ? (trailingDigit < 2 || trailingDigit > 7\n                        || (trailingDigit == 2 && section != roundingutils::SECTION_UPPER)\n                        || (trailingDigit == 7 && section == roundingutils::SECTION_UPPER))\n                : (trailingDigit % 2) == 0;\n\n        bool roundDown = roundingutils::getRoundingDirection(isEven,\n                isNegative(),\n                section,\n                roundingMode,\n                status);\n        if (U_FAILURE(status)) {\n            return;\n        }\n\n        // Perform truncation\n        if (position >= precision) {\n            setBcdToZero();\n            scale = magnitude;\n        } else {\n            shiftRight(position);\n        }\n\n        if (nickel) {\n            if (trailingDigit < 5 && roundDown) {\n                setDigitPos(0, 0);\n                compact();\n                return;\n            } else if (trailingDigit >= 5 && !roundDown) {\n                setDigitPos(0, 9);\n                trailingDigit = 9;\n                // do not return: use the bubbling logic below\n            } else {\n                setDigitPos(0, 5);\n                // compact not necessary: digit at position 0 is nonzero\n                return;\n            }\n        }\n\n        // Bubble the result to the higher digits\n        if (!roundDown) {\n            if (trailingDigit == 9) {\n                int bubblePos = 0;\n                // Note: in the long implementation, the most digits BCD can have at this point is\n                // 15, so bubblePos <= 15 and getDigitPos(bubblePos) is safe.\n                for (; getDigitPos(bubblePos) == 9; bubblePos++) {}\n                shiftRight(bubblePos); // shift off the trailing 9s\n            }\n            int8_t digit0 = getDigitPos(0);\n            U_ASSERT(digit0 != 9);\n            setDigitPos(0, static_cast<int8_t>(digit0 + 1));\n            precision += 1; // in case an extra digit got added\n        }\n\n        compact();\n    }\n}\n\nvoid DecimalQuantity::roundToInfinity() {\n    if (isApproximate) {\n        convertToAccurateDouble();\n    }\n}\n\nvoid DecimalQuantity::appendDigit(int8_t value, int32_t leadingZeros, bool appendAsInteger) {\n    U_ASSERT(leadingZeros >= 0);\n\n    // Zero requires special handling to maintain the invariant that the least-significant digit\n    // in the BCD is nonzero.\n    if (value == 0) {\n        if (appendAsInteger && precision != 0) {\n            scale += leadingZeros + 1;\n        }\n        return;\n    }\n\n    // Deal with trailing zeros\n    if (scale > 0) {\n        leadingZeros += scale;\n        if (appendAsInteger) {\n            scale = 0;\n        }\n    }\n\n    // Append digit\n    shiftLeft(leadingZeros + 1);\n    setDigitPos(0, value);\n\n    // Fix scale if in integer mode\n    if (appendAsInteger) {\n        scale += leadingZeros + 1;\n    }\n}\n\nUnicodeString DecimalQuantity::toPlainString() const {\n    U_ASSERT(!isApproximate);\n    UnicodeString sb;\n    if (isNegative()) {\n        sb.append(u'-');\n    }\n    if (precision == 0 || getMagnitude() < 0) {\n        sb.append(u'0');\n    }\n    for (int m = getUpperDisplayMagnitude(); m >= getLowerDisplayMagnitude(); m--) {\n        if (m == -1) { sb.append(u'.'); }\n        sb.append(getDigit(m) + u'0');\n    }\n    return sb;\n}\n\nUnicodeString DecimalQuantity::toScientificString() const {\n    U_ASSERT(!isApproximate);\n    UnicodeString result;\n    if (isNegative()) {\n        result.append(u'-');\n    }\n    if (precision == 0) {\n        result.append(u\"0E+0\", -1);\n        return result;\n    }\n    // NOTE: It is not safe to add to lOptPos (aka maxInt) or subtract from\n    // rOptPos (aka -maxFrac) due to overflow.\n    int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;\n    int32_t lowerPos = std::max(scale, rOptPos) - scale;\n    int32_t p = upperPos;\n    result.append(u'0' + getDigitPos(p));\n    if ((--p) >= lowerPos) {\n        result.append(u'.');\n        for (; p >= lowerPos; p--) {\n            result.append(u'0' + getDigitPos(p));\n        }\n    }\n    result.append(u'E');\n    int32_t _scale = upperPos + scale;\n    if (_scale < 0) {\n        _scale *= -1;\n        result.append(u'-');\n    } else {\n        result.append(u'+');\n    }\n    if (_scale == 0) {\n        result.append(u'0');\n    }\n    int32_t insertIndex = result.length();\n    while (_scale > 0) {\n        std::div_t res = std::div(_scale, 10);\n        result.insert(insertIndex, u'0' + res.rem);\n        _scale = res.quot;\n    }\n    return result;\n}\n\n////////////////////////////////////////////////////\n/// End of DecimalQuantity_AbstractBCD.java      ///\n/// Start of DecimalQuantity_DualStorageBCD.java ///\n////////////////////////////////////////////////////\n\nint8_t DecimalQuantity::getDigitPos(int32_t position) const {\n    if (usingBytes) {\n        if (position < 0 || position >= precision) { return 0; }\n        return fBCD.bcdBytes.ptr[position];\n    } else {\n        if (position < 0 || position >= 16) { return 0; }\n        return (int8_t) ((fBCD.bcdLong >> (position * 4)) & 0xf);\n    }\n}\n\nvoid DecimalQuantity::setDigitPos(int32_t position, int8_t value) {\n    U_ASSERT(position >= 0);\n    if (usingBytes) {\n        ensureCapacity(position + 1);\n        fBCD.bcdBytes.ptr[position] = value;\n    } else if (position >= 16) {\n        switchStorage();\n        ensureCapacity(position + 1);\n        fBCD.bcdBytes.ptr[position] = value;\n    } else {\n        int shift = position * 4;\n        fBCD.bcdLong = (fBCD.bcdLong & ~(0xfL << shift)) | ((long) value << shift);\n    }\n}\n\nvoid DecimalQuantity::shiftLeft(int32_t numDigits) {\n    if (!usingBytes && precision + numDigits > 16) {\n        switchStorage();\n    }\n    if (usingBytes) {\n        ensureCapacity(precision + numDigits);\n        int i = precision + numDigits - 1;\n        for (; i >= numDigits; i--) {\n            fBCD.bcdBytes.ptr[i] = fBCD.bcdBytes.ptr[i - numDigits];\n        }\n        for (; i >= 0; i--) {\n            fBCD.bcdBytes.ptr[i] = 0;\n        }\n    } else {\n        fBCD.bcdLong <<= (numDigits * 4);\n    }\n    scale -= numDigits;\n    precision += numDigits;\n}\n\nvoid DecimalQuantity::shiftRight(int32_t numDigits) {\n    if (usingBytes) {\n        int i = 0;\n        for (; i < precision - numDigits; i++) {\n            fBCD.bcdBytes.ptr[i] = fBCD.bcdBytes.ptr[i + numDigits];\n        }\n        for (; i < precision; i++) {\n            fBCD.bcdBytes.ptr[i] = 0;\n        }\n    } else {\n        fBCD.bcdLong >>= (numDigits * 4);\n    }\n    scale += numDigits;\n    precision -= numDigits;\n}\n\nvoid DecimalQuantity::setBcdToZero() {\n    if (usingBytes) {\n        uprv_free(fBCD.bcdBytes.ptr);\n        fBCD.bcdBytes.ptr = nullptr;\n        usingBytes = false;\n    }\n    fBCD.bcdLong = 0L;\n    scale = 0;\n    precision = 0;\n    isApproximate = false;\n    origDouble = 0;\n    origDelta = 0;\n}\n\nvoid DecimalQuantity::readIntToBcd(int32_t n) {\n    U_ASSERT(n != 0);\n    // ints always fit inside the long implementation.\n    uint64_t result = 0L;\n    int i = 16;\n    for (; n != 0; n /= 10, i--) {\n        result = (result >> 4) + ((static_cast<uint64_t>(n) % 10) << 60);\n    }\n    U_ASSERT(!usingBytes);\n    fBCD.bcdLong = result >> (i * 4);\n    scale = 0;\n    precision = 16 - i;\n}\n\nvoid DecimalQuantity::readLongToBcd(int64_t n) {\n    U_ASSERT(n != 0);\n    if (n >= 10000000000000000L) {\n        ensureCapacity();\n        int i = 0;\n        for (; n != 0L; n /= 10L, i++) {\n            fBCD.bcdBytes.ptr[i] = static_cast<int8_t>(n % 10);\n        }\n        U_ASSERT(usingBytes);\n        scale = 0;\n        precision = i;\n    } else {\n        uint64_t result = 0L;\n        int i = 16;\n        for (; n != 0L; n /= 10L, i--) {\n            result = (result >> 4) + ((n % 10) << 60);\n        }\n        U_ASSERT(i >= 0);\n        U_ASSERT(!usingBytes);\n        fBCD.bcdLong = result >> (i * 4);\n        scale = 0;\n        precision = 16 - i;\n    }\n}\n\nvoid DecimalQuantity::readDecNumberToBcd(const DecNum& decnum) {\n    const decNumber* dn = decnum.getRawDecNumber();\n    if (dn->digits > 16) {\n        ensureCapacity(dn->digits);\n        for (int32_t i = 0; i < dn->digits; i++) {\n            fBCD.bcdBytes.ptr[i] = dn->lsu[i];\n        }\n    } else {\n        uint64_t result = 0L;\n        for (int32_t i = 0; i < dn->digits; i++) {\n            result |= static_cast<uint64_t>(dn->lsu[i]) << (4 * i);\n        }\n        fBCD.bcdLong = result;\n    }\n    scale = dn->exponent;\n    precision = dn->digits;\n}\n\nvoid DecimalQuantity::readDoubleConversionToBcd(\n        const char* buffer, int32_t length, int32_t point) {\n    // NOTE: Despite the fact that double-conversion's API is called\n    // \"DoubleToAscii\", they actually use '0' (as opposed to u8'0').\n    if (length > 16) {\n        ensureCapacity(length);\n        for (int32_t i = 0; i < length; i++) {\n            fBCD.bcdBytes.ptr[i] = buffer[length-i-1] - '0';\n        }\n    } else {\n        uint64_t result = 0L;\n        for (int32_t i = 0; i < length; i++) {\n            result |= static_cast<uint64_t>(buffer[length-i-1] - '0') << (4 * i);\n        }\n        fBCD.bcdLong = result;\n    }\n    scale = point - length;\n    precision = length;\n}\n\nvoid DecimalQuantity::compact() {\n    if (usingBytes) {\n        int32_t delta = 0;\n        for (; delta < precision && fBCD.bcdBytes.ptr[delta] == 0; delta++);\n        if (delta == precision) {\n            // Number is zero\n            setBcdToZero();\n            return;\n        } else {\n            // Remove trailing zeros\n            shiftRight(delta);\n        }\n\n        // Compute precision\n        int32_t leading = precision - 1;\n        for (; leading >= 0 && fBCD.bcdBytes.ptr[leading] == 0; leading--);\n        precision = leading + 1;\n\n        // Switch storage mechanism if possible\n        if (precision <= 16) {\n            switchStorage();\n        }\n\n    } else {\n        if (fBCD.bcdLong == 0L) {\n            // Number is zero\n            setBcdToZero();\n            return;\n        }\n\n        // Compact the number (remove trailing zeros)\n        // TODO: Use a more efficient algorithm here and below. There is a logarithmic one.\n        int32_t delta = 0;\n        for (; delta < precision && getDigitPos(delta) == 0; delta++);\n        fBCD.bcdLong >>= delta * 4;\n        scale += delta;\n\n        // Compute precision\n        int32_t leading = precision - 1;\n        for (; leading >= 0 && getDigitPos(leading) == 0; leading--);\n        precision = leading + 1;\n    }\n}\n\nvoid DecimalQuantity::ensureCapacity() {\n    ensureCapacity(40);\n}\n\nvoid DecimalQuantity::ensureCapacity(int32_t capacity) {\n    if (capacity == 0) { return; }\n    int32_t oldCapacity = usingBytes ? fBCD.bcdBytes.len : 0;\n    if (!usingBytes) {\n        // TODO: There is nothing being done to check for memory allocation failures.\n        // TODO: Consider indexing by nybbles instead of bytes in C++, so that we can\n        // make these arrays half the size.\n        fBCD.bcdBytes.ptr = static_cast<int8_t*>(uprv_malloc(capacity * sizeof(int8_t)));\n        fBCD.bcdBytes.len = capacity;\n        // Initialize the byte array to zeros (this is done automatically in Java)\n        uprv_memset(fBCD.bcdBytes.ptr, 0, capacity * sizeof(int8_t));\n    } else if (oldCapacity < capacity) {\n        auto bcd1 = static_cast<int8_t*>(uprv_malloc(capacity * 2 * sizeof(int8_t)));\n        uprv_memcpy(bcd1, fBCD.bcdBytes.ptr, oldCapacity * sizeof(int8_t));\n        // Initialize the rest of the byte array to zeros (this is done automatically in Java)\n        uprv_memset(bcd1 + oldCapacity, 0, (capacity - oldCapacity) * sizeof(int8_t));\n        uprv_free(fBCD.bcdBytes.ptr);\n        fBCD.bcdBytes.ptr = bcd1;\n        fBCD.bcdBytes.len = capacity * 2;\n    }\n    usingBytes = true;\n}\n\nvoid DecimalQuantity::switchStorage() {\n    if (usingBytes) {\n        // Change from bytes to long\n        uint64_t bcdLong = 0L;\n        for (int i = precision - 1; i >= 0; i--) {\n            bcdLong <<= 4;\n            bcdLong |= fBCD.bcdBytes.ptr[i];\n        }\n        uprv_free(fBCD.bcdBytes.ptr);\n        fBCD.bcdBytes.ptr = nullptr;\n        fBCD.bcdLong = bcdLong;\n        usingBytes = false;\n    } else {\n        // Change from long to bytes\n        // Copy the long into a local variable since it will get munged when we allocate the bytes\n        uint64_t bcdLong = fBCD.bcdLong;\n        ensureCapacity();\n        for (int i = 0; i < precision; i++) {\n            fBCD.bcdBytes.ptr[i] = static_cast<int8_t>(bcdLong & 0xf);\n            bcdLong >>= 4;\n        }\n        U_ASSERT(usingBytes);\n    }\n}\n\nvoid DecimalQuantity::copyBcdFrom(const DecimalQuantity &other) {\n    setBcdToZero();\n    if (other.usingBytes) {\n        ensureCapacity(other.precision);\n        uprv_memcpy(fBCD.bcdBytes.ptr, other.fBCD.bcdBytes.ptr, other.precision * sizeof(int8_t));\n    } else {\n        fBCD.bcdLong = other.fBCD.bcdLong;\n    }\n}\n\nvoid DecimalQuantity::moveBcdFrom(DecimalQuantity &other) {\n    setBcdToZero();\n    if (other.usingBytes) {\n        usingBytes = true;\n        fBCD.bcdBytes.ptr = other.fBCD.bcdBytes.ptr;\n        fBCD.bcdBytes.len = other.fBCD.bcdBytes.len;\n        // Take ownership away from the old instance:\n        other.fBCD.bcdBytes.ptr = nullptr;\n        other.usingBytes = false;\n    } else {\n        fBCD.bcdLong = other.fBCD.bcdLong;\n    }\n}\n\nconst char16_t* DecimalQuantity::checkHealth() const {\n    if (usingBytes) {\n        if (precision == 0) { return u\"Zero precision but we are in byte mode\"; }\n        int32_t capacity = fBCD.bcdBytes.len;\n        if (precision > capacity) { return u\"Precision exceeds length of byte array\"; }\n        if (getDigitPos(precision - 1) == 0) { return u\"Most significant digit is zero in byte mode\"; }\n        if (getDigitPos(0) == 0) { return u\"Least significant digit is zero in long mode\"; }\n        for (int i = 0; i < precision; i++) {\n            if (getDigitPos(i) >= 10) { return u\"Digit exceeding 10 in byte array\"; }\n            if (getDigitPos(i) < 0) { return u\"Digit below 0 in byte array\"; }\n        }\n        for (int i = precision; i < capacity; i++) {\n            if (getDigitPos(i) != 0) { return u\"Nonzero digits outside of range in byte array\"; }\n        }\n    } else {\n        if (precision == 0 && fBCD.bcdLong != 0) {\n            return u\"Value in bcdLong even though precision is zero\";\n        }\n        if (precision > 16) { return u\"Precision exceeds length of long\"; }\n        if (precision != 0 && getDigitPos(precision - 1) == 0) {\n            return u\"Most significant digit is zero in long mode\";\n        }\n        if (precision != 0 && getDigitPos(0) == 0) {\n            return u\"Least significant digit is zero in long mode\";\n        }\n        for (int i = 0; i < precision; i++) {\n            if (getDigitPos(i) >= 10) { return u\"Digit exceeding 10 in long\"; }\n            if (getDigitPos(i) < 0) { return u\"Digit below 0 in long (?!)\"; }\n        }\n        for (int i = precision; i < 16; i++) {\n            if (getDigitPos(i) != 0) { return u\"Nonzero digits outside of range in long\"; }\n        }\n    }\n\n    // No error\n    return nullptr;\n}\n\nbool DecimalQuantity::operator==(const DecimalQuantity& other) const {\n    bool basicEquals =\n            scale == other.scale\n            && precision == other.precision\n            && flags == other.flags\n            && lOptPos == other.lOptPos\n            && lReqPos == other.lReqPos\n            && rReqPos == other.rReqPos\n            && rOptPos == other.rOptPos\n            && isApproximate == other.isApproximate;\n    if (!basicEquals) {\n        return false;\n    }\n\n    if (precision == 0) {\n        return true;\n    } else if (isApproximate) {\n        return origDouble == other.origDouble && origDelta == other.origDelta;\n    } else {\n        for (int m = getUpperDisplayMagnitude(); m >= getLowerDisplayMagnitude(); m--) {\n            if (getDigit(m) != other.getDigit(m)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\nUnicodeString DecimalQuantity::toString() const {\n    MaybeStackArray<char, 30> digits(precision + 1);\n    for (int32_t i = 0; i < precision; i++) {\n        digits[i] = getDigitPos(precision - i - 1) + '0';\n    }\n    digits[precision] = 0; // terminate buffer\n    char buffer8[100];\n    snprintf(\n            buffer8,\n            sizeof(buffer8),\n            \"<DecimalQuantity %d:%d:%d:%d %s %s%s%s%d>\",\n            (lOptPos > 999 ? 999 : lOptPos),\n            lReqPos,\n            rReqPos,\n            (rOptPos < -999 ? -999 : rOptPos),\n            (usingBytes ? \"bytes\" : \"long\"),\n            (isNegative() ? \"-\" : \"\"),\n            (precision == 0 ? \"0\" : digits.getAlias()),\n            \"E\",\n            scale);\n    return UnicodeString(buffer8, -1, US_INV);\n}\n\n#endif /* #if !UCONFIG_NO_FORMATTING */\n", "// \u00a9 2016 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html\n/********************************************************************\n * COPYRIGHT:\n * Copyright (c) 1997-2016, International Business Machines Corporation and\n * others. All Rights Reserved.\n ********************************************************************/\n/* Modification History:\n*   Date        Name        Description\n*   07/15/99    helena      Ported to HPUX 10/11 CC.\n*/\n\n#include \"unicode/utypes.h\"\n\n#if !UCONFIG_NO_FORMATTING\n\n#include \"numfmtst.h\"\n#include \"unicode/currpinf.h\"\n#include \"unicode/dcfmtsym.h\"\n#include \"unicode/decimfmt.h\"\n#include \"unicode/localpointer.h\"\n#include \"unicode/ucurr.h\"\n#include \"unicode/ustring.h\"\n#include \"unicode/measfmt.h\"\n#include \"unicode/curramt.h\"\n#include \"unicode/strenum.h\"\n#include \"textfile.h\"\n#include \"tokiter.h\"\n#include \"charstr.h\"\n#include \"cstr.h\"\n#include \"putilimp.h\"\n#include \"winnmtst.h\"\n#include <cmath>\n#include <float.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"cmemory.h\"\n#include \"cstring.h\"\n#include \"unicode/numsys.h\"\n#include \"fmtableimp.h\"\n#include \"numberformattesttuple.h\"\n#include \"unicode/msgfmt.h\"\n#include \"number_decimalquantity.h\"\n#include \"unicode/numberformatter.h\"\n\n#if (U_PLATFORM == U_PF_AIX) || (U_PLATFORM == U_PF_OS390)\n// These should not be macros. If they are,\n// replace them with std::isnan and std::isinf\n#if defined(isnan)\n#undef isnan\nnamespace std {\n bool isnan(double x) {\n   return _isnan(x);\n }\n}\n#endif\n#if defined(isinf)\n#undef isinf\nnamespace std {\n bool isinf(double x) {\n   return _isinf(x);\n }\n}\n#endif\n#endif\n\nusing icu::number::impl::DecimalQuantity;\nusing namespace icu::number;\n\n//#define NUMFMTST_CACHE_DEBUG 1\n#include \"stdio.h\" /* for sprintf */\n// #include \"iostream\"   // for cout\n\n//#define NUMFMTST_DEBUG 1\n\nstatic const UChar EUR[] = {69,85,82,0}; // \"EUR\"\nstatic const UChar ISO_CURRENCY_USD[] = {0x55, 0x53, 0x44, 0}; // \"USD\"\n\n\n// *****************************************************************************\n// class NumberFormatTest\n// *****************************************************************************\n\n#define CHECK(status,str) if (U_FAILURE(status)) { errcheckln(status, UnicodeString(\"FAIL: \") + str + \" - \" + u_errorName(status)); return; }\n#define CHECK_DATA(status,str) if (U_FAILURE(status)) { dataerrln(UnicodeString(\"FAIL: \") + str + \" - \" + u_errorName(status)); return; }\n\nvoid NumberFormatTest::runIndexedTest( int32_t index, UBool exec, const char* &name, char* /*par*/ )\n{\n  TESTCASE_AUTO_BEGIN;\n  TESTCASE_AUTO(TestCurrencySign);\n  TESTCASE_AUTO(TestCurrency);\n  TESTCASE_AUTO(TestParse);\n  TESTCASE_AUTO(TestRounding487);\n  TESTCASE_AUTO(TestQuotes);\n  TESTCASE_AUTO(TestExponential);\n  TESTCASE_AUTO(TestPatterns);\n\n  // Upgrade to alphaWorks - liu 5/99\n  TESTCASE_AUTO(TestExponent);\n  TESTCASE_AUTO(TestScientific);\n  TESTCASE_AUTO(TestPad);\n  TESTCASE_AUTO(TestPatterns2);\n  TESTCASE_AUTO(TestSecondaryGrouping);\n  TESTCASE_AUTO(TestSurrogateSupport);\n  TESTCASE_AUTO(TestAPI);\n\n  TESTCASE_AUTO(TestCurrencyObject);\n  TESTCASE_AUTO(TestCurrencyPatterns);\n  //TESTCASE_AUTO(TestDigitList);\n  TESTCASE_AUTO(TestWhiteSpaceParsing);\n  TESTCASE_AUTO(TestComplexCurrency);  // This test removed because CLDR no longer uses choice formats in currency symbols.\n  TESTCASE_AUTO(TestRegCurrency);\n  TESTCASE_AUTO(TestSymbolsWithBadLocale);\n  TESTCASE_AUTO(TestAdoptDecimalFormatSymbols);\n\n  TESTCASE_AUTO(TestScientific2);\n  TESTCASE_AUTO(TestScientificGrouping);\n  TESTCASE_AUTO(TestInt64);\n\n  TESTCASE_AUTO(TestPerMill);\n  TESTCASE_AUTO(TestIllegalPatterns);\n  TESTCASE_AUTO(TestCases);\n\n  TESTCASE_AUTO(TestCurrencyNames);\n  TESTCASE_AUTO(TestCurrencyAmount);\n  TESTCASE_AUTO(TestCurrencyUnit);\n  TESTCASE_AUTO(TestCoverage);\n  TESTCASE_AUTO(TestLocalizedPatternSymbolCoverage);\n  TESTCASE_AUTO(TestJB3832);\n  TESTCASE_AUTO(TestHost);\n  TESTCASE_AUTO(TestHostClone);\n  TESTCASE_AUTO(TestCurrencyFormat);\n  TESTCASE_AUTO(TestRounding);\n  TESTCASE_AUTO(TestNonpositiveMultiplier);\n  TESTCASE_AUTO(TestNumberingSystems);\n  TESTCASE_AUTO(TestSpaceParsing);\n  TESTCASE_AUTO(TestMultiCurrencySign);\n  TESTCASE_AUTO(TestCurrencyFormatForMixParsing);\n  TESTCASE_AUTO(TestMismatchedCurrencyFormatFail);\n  TESTCASE_AUTO(TestDecimalFormatCurrencyParse);\n  TESTCASE_AUTO(TestCurrencyIsoPluralFormat);\n  TESTCASE_AUTO(TestCurrencyParsing);\n  TESTCASE_AUTO(TestParseCurrencyInUCurr);\n  TESTCASE_AUTO(TestFormatAttributes);\n  TESTCASE_AUTO(TestFieldPositionIterator);\n  TESTCASE_AUTO(TestDecimal);\n  TESTCASE_AUTO(TestCurrencyFractionDigits);\n  TESTCASE_AUTO(TestExponentParse);\n  TESTCASE_AUTO(TestExplicitParents);\n  TESTCASE_AUTO(TestLenientParse);\n  TESTCASE_AUTO(TestAvailableNumberingSystems);\n  TESTCASE_AUTO(TestRoundingPattern);\n  TESTCASE_AUTO(Test9087);\n  TESTCASE_AUTO(TestFormatFastpaths);\n  TESTCASE_AUTO(TestFormattableSize);\n  TESTCASE_AUTO(TestUFormattable);\n  TESTCASE_AUTO(TestSignificantDigits);\n  TESTCASE_AUTO(TestShowZero);\n  TESTCASE_AUTO(TestCompatibleCurrencies);\n  TESTCASE_AUTO(TestBug9936);\n  TESTCASE_AUTO(TestParseNegativeWithFaLocale);\n  TESTCASE_AUTO(TestParseNegativeWithAlternateMinusSign);\n  TESTCASE_AUTO(TestCustomCurrencySignAndSeparator);\n  TESTCASE_AUTO(TestParseSignsAndMarks);\n  TESTCASE_AUTO(Test10419RoundingWith0FractionDigits);\n  TESTCASE_AUTO(Test10468ApplyPattern);\n  TESTCASE_AUTO(TestRoundingScientific10542);\n  TESTCASE_AUTO(TestZeroScientific10547);\n  TESTCASE_AUTO(TestAccountingCurrency);\n  TESTCASE_AUTO(TestEquality);\n  TESTCASE_AUTO(TestCurrencyUsage);\n  TESTCASE_AUTO(TestDoubleLimit11439);\n  TESTCASE_AUTO(TestGetAffixes);\n  TESTCASE_AUTO(TestToPatternScientific11648);\n  TESTCASE_AUTO(TestBenchmark);\n  TESTCASE_AUTO(TestCtorApplyPatternDifference);\n  TESTCASE_AUTO(TestFractionalDigitsForCurrency);\n  TESTCASE_AUTO(TestFormatCurrencyPlural);\n  TESTCASE_AUTO(Test11868);\n  TESTCASE_AUTO(Test11739_ParseLongCurrency);\n  TESTCASE_AUTO(Test13035_MultiCodePointPaddingInPattern);\n  TESTCASE_AUTO(Test13737_ParseScientificStrict);\n  TESTCASE_AUTO(Test10727_RoundingZero);\n  TESTCASE_AUTO(Test11376_getAndSetPositivePrefix);\n  TESTCASE_AUTO(Test11475_signRecognition);\n  TESTCASE_AUTO(Test11640_getAffixes);\n  TESTCASE_AUTO(Test11649_toPatternWithMultiCurrency);\n  TESTCASE_AUTO(Test13327_numberingSystemBufferOverflow);\n  TESTCASE_AUTO(Test13391_chakmaParsing);\n  TESTCASE_AUTO(Test11735_ExceptionIssue);\n  TESTCASE_AUTO(Test11035_FormatCurrencyAmount);\n  TESTCASE_AUTO(Test11318_DoubleConversion);\n  TESTCASE_AUTO(TestParsePercentRegression);\n  TESTCASE_AUTO(TestMultiplierWithScale);\n  TESTCASE_AUTO(TestFastFormatInt32);\n  TESTCASE_AUTO(Test11646_Equality);\n  TESTCASE_AUTO(TestParseNaN);\n  TESTCASE_AUTO(Test11897_LocalizedPatternSeparator);\n  TESTCASE_AUTO(Test13055_PercentageRounding);\n  TESTCASE_AUTO(Test11839);\n  TESTCASE_AUTO(Test10354);\n  TESTCASE_AUTO(Test11645_ApplyPatternEquality);\n  TESTCASE_AUTO(Test12567);\n  TESTCASE_AUTO(Test11626_CustomizeCurrencyPluralInfo);\n  TESTCASE_AUTO(Test20073_StrictPercentParseErrorIndex);\n  TESTCASE_AUTO(Test13056_GroupingSize);\n  TESTCASE_AUTO(Test11025_CurrencyPadding);\n  TESTCASE_AUTO(Test11648_ExpDecFormatMalPattern);\n  TESTCASE_AUTO(Test11649_DecFmtCurrencies);\n  TESTCASE_AUTO(Test13148_ParseGroupingSeparators);\n  TESTCASE_AUTO(Test12753_PatternDecimalPoint);\n  TESTCASE_AUTO(Test11647_PatternCurrencySymbols);\n  TESTCASE_AUTO(Test11913_BigDecimal);\n  TESTCASE_AUTO(Test11020_RoundingInScientificNotation);\n  TESTCASE_AUTO(Test11640_TripleCurrencySymbol);\n  TESTCASE_AUTO(Test13763_FieldPositionIteratorOffset);\n  TESTCASE_AUTO(Test13777_ParseLongNameNonCurrencyMode);\n  TESTCASE_AUTO(Test13804_EmptyStringsWhenParsing);\n  TESTCASE_AUTO(Test20037_ScientificIntegerOverflow);\n  TESTCASE_AUTO(Test13840_ParseLongStringCrash);\n  TESTCASE_AUTO(Test13850_EmptyStringCurrency);\n  TESTCASE_AUTO_END;\n}\n\n// -------------------------------------\n\n// Test API (increase code coverage)\nvoid\nNumberFormatTest::TestAPI(void)\n{\n  logln(\"Test API\");\n  UErrorCode status = U_ZERO_ERROR;\n  NumberFormat *test = NumberFormat::createInstance(\"root\", status);\n  if(U_FAILURE(status)) {\n    dataerrln(\"unable to create format object - %s\", u_errorName(status));\n  }\n  if(test != NULL) {\n    test->setMinimumIntegerDigits(10);\n    test->setMaximumIntegerDigits(1);\n\n    test->setMinimumFractionDigits(10);\n    test->setMaximumFractionDigits(1);\n\n    UnicodeString result;\n    FieldPosition pos;\n    Formattable bla(\"Paja Patak\"); // Donald Duck for non Serbian speakers\n    test->format(bla, result, pos, status);\n    if(U_SUCCESS(status)) {\n      errln(\"Yuck... Formatted a duck... As a number!\");\n    } else {\n      status = U_ZERO_ERROR;\n    }\n\n    result.remove();\n    int64_t ll = 12;\n    test->format(ll, result);\n    assertEquals(\"format int64_t error\", u\"2.0\", result);\n\n    test->setMinimumIntegerDigits(4);\n    test->setMinimumFractionDigits(4);\n\n    result.remove();\n    test->format(ll, result);\n    assertEquals(\"format int64_t error\", u\"0,012.0000\", result);\n\n    ParsePosition ppos;\n    LocalPointer<CurrencyAmount> currAmt(test->parseCurrency(\"\",ppos));\n    // old test for (U_FAILURE(status)) was bogus here, method does not set status!\n    if (ppos.getIndex()) {\n        errln(\"Parsed empty string as currency\");\n    }\n\n    delete test;\n  }\n}\n\nclass StubNumberFormat :public NumberFormat{\npublic:\n    StubNumberFormat(){};\n    virtual UnicodeString& format(double ,UnicodeString& appendTo,FieldPosition& ) const {\n        return appendTo;\n    }\n    virtual UnicodeString& format(int32_t ,UnicodeString& appendTo,FieldPosition& ) const {\n        return appendTo.append((UChar)0x0033);\n    }\n    virtual UnicodeString& format(int64_t number,UnicodeString& appendTo,FieldPosition& pos) const {\n        return NumberFormat::format(number, appendTo, pos);\n    }\n    virtual UnicodeString& format(const Formattable& , UnicodeString& appendTo, FieldPosition& , UErrorCode& ) const {\n        return appendTo;\n    }\n    virtual void parse(const UnicodeString& ,\n                    Formattable& ,\n                    ParsePosition& ) const {}\n    virtual void parse( const UnicodeString& ,\n                        Formattable& ,\n                        UErrorCode& ) const {}\n    virtual UClassID getDynamicClassID(void) const {\n        static char classID = 0;\n        return (UClassID)&classID;\n    }\n    virtual Format* clone() const {return NULL;}\n};\n\nvoid\nNumberFormatTest::TestCoverage(void){\n    StubNumberFormat stub;\n    UnicodeString agent(\"agent\");\n    FieldPosition pos;\n    int64_t num = 4;\n    if (stub.format(num, agent, pos) != UnicodeString(\"agent3\")){\n        errln(\"NumberFormat::format(int64, UnicodString&, FieldPosition&) should delegate to (int32, ,)\");\n    };\n}\n\nvoid NumberFormatTest::TestLocalizedPatternSymbolCoverage() {\n    IcuTestErrorCode errorCode(*this, \"TestLocalizedPatternSymbolCoverage\");\n    // Ticket #12961: DecimalFormat::toLocalizedPattern() is not working as designed.\n    DecimalFormatSymbols dfs(errorCode);\n    dfs.setSymbol(DecimalFormatSymbols::kGroupingSeparatorSymbol, u'\u2056');\n    dfs.setSymbol(DecimalFormatSymbols::kDecimalSeparatorSymbol, u'\u2058');\n    dfs.setSymbol(DecimalFormatSymbols::kPatternSeparatorSymbol, u'\u2059');\n    dfs.setSymbol(DecimalFormatSymbols::kDigitSymbol, u'\u25b0');\n    dfs.setSymbol(DecimalFormatSymbols::kZeroDigitSymbol, u'\u0ed0');\n    dfs.setSymbol(DecimalFormatSymbols::kSignificantDigitSymbol, u'\u2055');\n    dfs.setSymbol(DecimalFormatSymbols::kPlusSignSymbol, u'\u2020');\n    dfs.setSymbol(DecimalFormatSymbols::kMinusSignSymbol, u'\u2021');\n    dfs.setSymbol(DecimalFormatSymbols::kPercentSymbol, u'\u205c');\n    dfs.setSymbol(DecimalFormatSymbols::kPerMillSymbol, u'\u2031');\n    dfs.setSymbol(DecimalFormatSymbols::kExponentialSymbol, u\"\u2051\u2051\"); // tests multi-char sequence\n    dfs.setSymbol(DecimalFormatSymbols::kPadEscapeSymbol, u'\u2042');\n\n    {\n        UnicodeString standardPattern(u\"#,##0.05+%;#,##0.05-%\");\n        UnicodeString localizedPattern(u\"\u25b0\u2056\u25b0\u25b0\u0ed0\u2058\u0ed0\u0ed5\u2020\u205c\u2059\u25b0\u2056\u25b0\u25b0\u0ed0\u2058\u0ed0\u0ed5\u2021\u205c\");\n\n        DecimalFormat df1(\"#\", new DecimalFormatSymbols(dfs), errorCode);\n        df1.applyPattern(standardPattern, errorCode);\n        DecimalFormat df2(\"#\", new DecimalFormatSymbols(dfs), errorCode);\n        df2.applyLocalizedPattern(localizedPattern, errorCode);\n        assertTrue(\"DecimalFormat instances should be equal\", df1 == df2);\n        UnicodeString p2;\n        assertEquals(\"toPattern should match on localizedPattern instance\",\n                standardPattern, df2.toPattern(p2));\n        UnicodeString lp1;\n        assertEquals(\"toLocalizedPattern should match on standardPattern instance\",\n                localizedPattern, df1.toLocalizedPattern(lp1));\n    }\n\n    {\n        UnicodeString standardPattern(u\"* @@@E0\u2030\");\n        UnicodeString localizedPattern(u\"\u2042 \u2055\u2055\u2055\u2051\u2051\u0ed0\u2031\");\n\n        DecimalFormat df1(\"#\", new DecimalFormatSymbols(dfs), errorCode);\n        df1.applyPattern(standardPattern, errorCode);\n        DecimalFormat df2(\"#\", new DecimalFormatSymbols(dfs), errorCode);\n        df2.applyLocalizedPattern(localizedPattern, errorCode);\n        assertTrue(\"DecimalFormat instances should be equal\", df1 == df2);\n        UnicodeString p2;\n        assertEquals(\"toPattern should match on localizedPattern instance\",\n                standardPattern, df2.toPattern(p2));\n        UnicodeString lp1;\n        assertEquals(\"toLocalizedPattern should match on standardPattern instance\",\n                localizedPattern, df1.toLocalizedPattern(lp1));\n    }\n}\n\n// Test various patterns\nvoid\nNumberFormatTest::TestPatterns(void)\n{\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols sym(Locale::getUS(), status);\n    if (U_FAILURE(status)) { errcheckln(status, \"FAIL: Could not construct DecimalFormatSymbols - %s\", u_errorName(status)); return; }\n\n    const char* pat[]    = { \"#.#\", \"#.\", \".#\", \"#\" };\n    int32_t pat_length = UPRV_LENGTHOF(pat);\n    const char* newpat[] = { \"0.#\", \"0.\", \"#.0\", \"0\" };\n    const char* num[]    = { \"0\",   \"0.\", \".0\", \"0\" };\n    for (int32_t i=0; i<pat_length; ++i)\n    {\n        status = U_ZERO_ERROR;\n        DecimalFormat fmt(pat[i], sym, status);\n        if (U_FAILURE(status)) { errln((UnicodeString)\"FAIL: DecimalFormat constructor failed for \" + pat[i]); continue; }\n        UnicodeString newp; fmt.toPattern(newp);\n        if (!(newp == newpat[i]))\n            errln((UnicodeString)\"FAIL: Pattern \" + pat[i] + \" should transmute to \" + newpat[i] +\n                  \"; \" + newp + \" seen instead\");\n\n        UnicodeString s; (*(NumberFormat*)&fmt).format((int32_t)0, s);\n        if (!(s == num[i]))\n        {\n            errln((UnicodeString)\"FAIL: Pattern \" + pat[i] + \" should format zero as \" + num[i] +\n                  \"; \" + s + \" seen instead\");\n            logln((UnicodeString)\"Min integer digits = \" + fmt.getMinimumIntegerDigits());\n        }\n    }\n}\n\n/*\nicu_2_4::DigitList::operator== 0 0 2 icuuc24d.dll digitlst.cpp Doug\nicu_2_4::DigitList::append 0 0 4 icuin24d.dll digitlst.h Doug\nicu_2_4::DigitList::operator!= 0 0 1 icuuc24d.dll digitlst.h Doug\n*/\n/*\nvoid\nNumberFormatTest::TestDigitList(void)\n{\n  // API coverage for DigitList\n  DigitList list1;\n  list1.append('1');\n  list1.fDecimalAt = 1;\n  DigitList list2;\n  list2.set((int32_t)1);\n  if (list1 != list2) {\n    errln(\"digitlist append, operator!= or set failed \");\n  }\n  if (!(list1 == list2)) {\n    errln(\"digitlist append, operator== or set failed \");\n  }\n}\n*/\n\n// -------------------------------------\n\n// Test exponential pattern\nvoid\nNumberFormatTest::TestExponential(void)\n{\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols sym(Locale::getUS(), status);\n    if (U_FAILURE(status)) { errcheckln(status, \"FAIL: Bad status returned by DecimalFormatSymbols ct - %s\", u_errorName(status)); return; }\n    const char* pat[] = { \"0.####E0\", \"00.000E00\", \"##0.######E000\", \"0.###E0;[0.###E0]\"  };\n    int32_t pat_length = UPRV_LENGTHOF(pat);\n\n// The following #if statements allow this test to be built and run on\n// platforms that do not have standard IEEE numerics.  For example,\n// S/390 doubles have an exponent range of -78 to +75.  For the\n// following #if statements to work, float.h must define\n// DBL_MAX_10_EXP to be a compile-time constant.\n\n// This section may be expanded as needed.\n\n#if DBL_MAX_10_EXP > 300\n    double val[] = { 0.01234, 123456789, 1.23e300, -3.141592653e-271 };\n    int32_t val_length = UPRV_LENGTHOF(val);\n    const char* valFormat[] =\n    {\n        // 0.####E0\n        \"1.234E-2\", \"1.2346E8\", \"1.23E300\", \"-3.1416E-271\",\n        // 00.000E00\n        \"12.340E-03\", \"12.346E07\", \"12.300E299\", \"-31.416E-272\",\n        // ##0.######E000\n        \"12.34E-003\", \"123.4568E006\", \"1.23E300\", \"-314.1593E-273\",\n        // 0.###E0;[0.###E0]\n        \"1.234E-2\", \"1.235E8\", \"1.23E300\", \"[3.142E-271]\"\n    };\n    double valParse[] =\n    {\n        0.01234, 123460000, 1.23E300, -3.1416E-271,\n        0.01234, 123460000, 1.23E300, -3.1416E-271,\n        0.01234, 123456800, 1.23E300, -3.141593E-271,\n        0.01234, 123500000, 1.23E300, -3.142E-271,\n    };\n#elif DBL_MAX_10_EXP > 70\n    double val[] = { 0.01234, 123456789, 1.23e70, -3.141592653e-71 };\n    int32_t val_length = UPRV_LENGTHOF(val);\n    char* valFormat[] =\n    {\n        // 0.####E0\n        \"1.234E-2\", \"1.2346E8\", \"1.23E70\", \"-3.1416E-71\",\n        // 00.000E00\n        \"12.340E-03\", \"12.346E07\", \"12.300E69\", \"-31.416E-72\",\n        // ##0.######E000\n        \"12.34E-003\", \"123.4568E006\", \"12.3E069\", \"-31.41593E-072\",\n        // 0.###E0;[0.###E0]\n        \"1.234E-2\", \"1.235E8\", \"1.23E70\", \"[3.142E-71]\"\n    };\n    double valParse[] =\n    {\n        0.01234, 123460000, 1.23E70, -3.1416E-71,\n        0.01234, 123460000, 1.23E70, -3.1416E-71,\n        0.01234, 123456800, 1.23E70, -3.141593E-71,\n        0.01234, 123500000, 1.23E70, -3.142E-71,\n    };\n#else\n    // Don't test double conversion\n    double* val = 0;\n    int32_t val_length = 0;\n    char** valFormat = 0;\n    double* valParse = 0;\n    logln(\"Warning: Skipping double conversion tests\");\n#endif\n\n    int32_t lval[] = { 0, -1, 1, 123456789 };\n    int32_t lval_length = UPRV_LENGTHOF(lval);\n    const char* lvalFormat[] =\n    {\n        // 0.####E0\n        \"0E0\", \"-1E0\", \"1E0\", \"1.2346E8\",\n        // 00.000E00\n        \"00.000E00\", \"-10.000E-01\", \"10.000E-01\", \"12.346E07\",\n        // ##0.######E000\n        \"0E000\", \"-1E000\", \"1E000\", \"123.4568E006\",\n        // 0.###E0;[0.###E0]\n        \"0E0\", \"[1E0]\", \"1E0\", \"1.235E8\"\n    };\n    int32_t lvalParse[] =\n    {\n        0, -1, 1, 123460000,\n        0, -1, 1, 123460000,\n        0, -1, 1, 123456800,\n        0, -1, 1, 123500000,\n    };\n    int32_t ival = 0, ilval = 0;\n    for (int32_t p=0; p<pat_length; ++p)\n    {\n        DecimalFormat fmt(pat[p], sym, status);\n        if (U_FAILURE(status)) { errln(\"FAIL: Bad status returned by DecimalFormat ct\"); continue; }\n        UnicodeString pattern;\n        logln((UnicodeString)\"Pattern \\\"\" + pat[p] + \"\\\" -toPattern-> \\\"\" +\n          fmt.toPattern(pattern) + \"\\\"\");\n        int32_t v;\n        for (v=0; v<val_length; ++v)\n        {\n            UnicodeString s; (*(NumberFormat*)&fmt).format(val[v], s);\n            logln((UnicodeString)\" \" + val[v] + \" -format-> \" + s);\n            if (s != valFormat[v+ival])\n                errln((UnicodeString)\"FAIL: Expected \" + valFormat[v+ival]);\n\n            ParsePosition pos(0);\n            Formattable af;\n            fmt.parse(s, af, pos);\n            double a;\n            UBool useEpsilon = FALSE;\n            if (af.getType() == Formattable::kLong)\n                a = af.getLong();\n            else if (af.getType() == Formattable::kDouble) {\n                a = af.getDouble();\n#if U_PF_OS390 <= U_PLATFORM && U_PLATFORM <= U_PF_OS400\n                // S/390 will show a failure like this:\n                //| -3.141592652999999e-271 -format-> -3.1416E-271\n                //|                          -parse-> -3.1416e-271\n                //| FAIL: Expected -3.141599999999999e-271\n                // To compensate, we use an epsilon-based equality\n                // test on S/390 only.  We don't want to do this in\n                // general because it's less exacting.\n                useEpsilon = TRUE;\n#endif\n            }\n            else {\n                errln(UnicodeString(\"FAIL: Non-numeric Formattable returned: \") + pattern + \" \" + s);\n                continue;\n            }\n            if (pos.getIndex() == s.length())\n            {\n                logln((UnicodeString)\"  -parse-> \" + a);\n                // Use epsilon comparison as necessary\n                if ((useEpsilon &&\n                    (uprv_fabs(a - valParse[v+ival]) / a > (2*DBL_EPSILON))) ||\n                    (!useEpsilon && a != valParse[v+ival]))\n                {\n                    errln((UnicodeString)\"FAIL: Expected \" + valParse[v+ival] + \" but got \" + a\n                        + \" on input \" + s);\n                }\n            }\n            else {\n                errln((UnicodeString)\"FAIL: Partial parse (\" + pos.getIndex() + \" chars) -> \" + a);\n                errln((UnicodeString)\"  should be (\" + s.length() + \" chars) -> \" + valParse[v+ival]);\n            }\n        }\n        for (v=0; v<lval_length; ++v)\n        {\n            UnicodeString s;\n            (*(NumberFormat*)&fmt).format(lval[v], s);\n            logln((UnicodeString)\" \" + lval[v] + \"L -format-> \" + s);\n            if (s != lvalFormat[v+ilval])\n                errln((UnicodeString)\"ERROR: Expected \" + lvalFormat[v+ilval] + \" Got: \" + s);\n\n            ParsePosition pos(0);\n            Formattable af;\n            fmt.parse(s, af, pos);\n            if (af.getType() == Formattable::kLong ||\n                af.getType() == Formattable::kInt64) {\n                UErrorCode status = U_ZERO_ERROR;\n                int32_t a = af.getLong(status);\n                if (pos.getIndex() == s.length())\n                {\n                    logln((UnicodeString)\"  -parse-> \" + a);\n                    if (a != lvalParse[v+ilval])\n                        errln((UnicodeString)\"FAIL: Expected \" + lvalParse[v+ilval] + \" but got \" + a);\n                }\n                else\n                    errln((UnicodeString)\"FAIL: Partial parse (\" + pos.getIndex() + \" chars) -> \" + a);\n            }\n            else\n                errln((UnicodeString)\"FAIL: Non-long Formattable returned for \" + s\n                    + \" Double: \" + af.getDouble()\n                    + \", Long: \" + af.getLong());\n        }\n        ival += val_length;\n        ilval += lval_length;\n    }\n}\n\nvoid\nNumberFormatTest::TestScientific2() {\n    // jb 2552\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat* fmt = (DecimalFormat*)NumberFormat::createCurrencyInstance(\"en_US\", status);\n    if (U_SUCCESS(status)) {\n        double num = 12.34;\n        expect(*fmt, num, \"$12.34\");\n        fmt->setScientificNotation(TRUE);\n        expect(*fmt, num, \"$1.23E1\");\n        fmt->setScientificNotation(FALSE);\n        expect(*fmt, num, \"$12.34\");\n    }\n    delete fmt;\n}\n\nvoid\nNumberFormatTest::TestScientificGrouping() {\n    // jb 2552\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat fmt(\"##0.00E0\",status);\n    if (assertSuccess(\"\", status, true, __FILE__, __LINE__)) {\n        expect(fmt, .01234, \"12.3E-3\");\n        expect(fmt, .1234, \"123E-3\");\n        expect(fmt, 1.234, \"1.23E0\");\n        expect(fmt, 12.34, \"12.3E0\");\n        expect(fmt, 123.4, \"123E0\");\n        expect(fmt, 1234., \"1.23E3\");\n    }\n}\n\n/*static void setFromString(DigitList& dl, const char* str) {\n    char c;\n    UBool decimalSet = FALSE;\n    dl.clear();\n    while ((c = *str++)) {\n        if (c == '-') {\n            dl.fIsPositive = FALSE;\n        } else if (c == '+') {\n            dl.fIsPositive = TRUE;\n        } else if (c == '.') {\n            dl.fDecimalAt = dl.fCount;\n            decimalSet = TRUE;\n        } else {\n            dl.append(c);\n        }\n    }\n    if (!decimalSet) {\n        dl.fDecimalAt = dl.fCount;\n    }\n}*/\n\nvoid\nNumberFormatTest::TestInt64() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat fmt(\"#.#E0\",status);\n    if (U_FAILURE(status)) {\n        dataerrln(\"Error creating DecimalFormat - %s\", u_errorName(status));\n        return;\n    }\n    fmt.setMaximumFractionDigits(20);\n    if (U_SUCCESS(status)) {\n        expect(fmt, (Formattable)(int64_t)0, \"0E0\");\n        expect(fmt, (Formattable)(int64_t)-1, \"-1E0\");\n        expect(fmt, (Formattable)(int64_t)1, \"1E0\");\n        expect(fmt, (Formattable)(int64_t)2147483647, \"2.147483647E9\");\n        expect(fmt, (Formattable)((int64_t)-2147483647-1), \"-2.147483648E9\");\n        expect(fmt, (Formattable)(int64_t)U_INT64_MAX, \"9.223372036854775807E18\");\n        expect(fmt, (Formattable)(int64_t)U_INT64_MIN, \"-9.223372036854775808E18\");\n    }\n\n    // also test digitlist\n/*    int64_t int64max = U_INT64_MAX;\n    int64_t int64min = U_INT64_MIN;\n    const char* int64maxstr = \"9223372036854775807\";\n    const char* int64minstr = \"-9223372036854775808\";\n    UnicodeString fail(\"fail: \");\n\n    // test max int64 value\n    DigitList dl;\n    setFromString(dl, int64maxstr);\n    {\n        if (!dl.fitsIntoInt64(FALSE)) {\n            errln(fail + int64maxstr + \" didn't fit\");\n        }\n        int64_t int64Value = dl.getInt64();\n        if (int64Value != int64max) {\n            errln(fail + int64maxstr);\n        }\n        dl.set(int64Value);\n        int64Value = dl.getInt64();\n        if (int64Value != int64max) {\n            errln(fail + int64maxstr);\n        }\n    }\n    // test negative of max int64 value (1 shy of min int64 value)\n    dl.fIsPositive = FALSE;\n    {\n        if (!dl.fitsIntoInt64(FALSE)) {\n            errln(fail + \"-\" + int64maxstr + \" didn't fit\");\n        }\n        int64_t int64Value = dl.getInt64();\n        if (int64Value != -int64max) {\n            errln(fail + \"-\" + int64maxstr);\n        }\n        dl.set(int64Value);\n        int64Value = dl.getInt64();\n        if (int64Value != -int64max) {\n            errln(fail + \"-\" + int64maxstr);\n        }\n    }\n    // test min int64 value\n    setFromString(dl, int64minstr);\n    {\n        if (!dl.fitsIntoInt64(FALSE)) {\n            errln(fail + \"-\" + int64minstr + \" didn't fit\");\n        }\n        int64_t int64Value = dl.getInt64();\n        if (int64Value != int64min) {\n            errln(fail + int64minstr);\n        }\n        dl.set(int64Value);\n        int64Value = dl.getInt64();\n        if (int64Value != int64min) {\n            errln(fail + int64minstr);\n        }\n    }\n    // test negative of min int 64 value (1 more than max int64 value)\n    dl.fIsPositive = TRUE; // won't fit\n    {\n        if (dl.fitsIntoInt64(FALSE)) {\n            errln(fail + \"-(\" + int64minstr + \") didn't fit\");\n        }\n    }*/\n}\n\n// -------------------------------------\n\n// Test the handling of quotes\nvoid\nNumberFormatTest::TestQuotes(void)\n{\n    UErrorCode status = U_ZERO_ERROR;\n    UnicodeString *pat;\n    DecimalFormatSymbols *sym = new DecimalFormatSymbols(Locale::getUS(), status);\n    if (U_FAILURE(status)) {\n        errcheckln(status, \"Fail to create DecimalFormatSymbols - %s\", u_errorName(status));\n        delete sym;\n        return;\n    }\n    pat = new UnicodeString(\"a'fo''o'b#\");\n    DecimalFormat *fmt = new DecimalFormat(*pat, *sym, status);\n    UnicodeString s;\n    ((NumberFormat*)fmt)->format((int32_t)123, s);\n    logln((UnicodeString)\"Pattern \\\"\" + *pat + \"\\\"\");\n    logln((UnicodeString)\" Format 123 -> \" + escape(s));\n    if (!(s==\"afo'ob123\"))\n        errln((UnicodeString)\"FAIL: Expected afo'ob123\");\n\n    s.truncate(0);\n    delete fmt;\n    delete pat;\n\n    pat = new UnicodeString(\"a''b#\");\n    fmt = new DecimalFormat(*pat, *sym, status);\n    ((NumberFormat*)fmt)->format((int32_t)123, s);\n    logln((UnicodeString)\"Pattern \\\"\" + *pat + \"\\\"\");\n    logln((UnicodeString)\" Format 123 -> \" + escape(s));\n    if (!(s==\"a'b123\"))\n        errln((UnicodeString)\"FAIL: Expected a'b123\");\n    delete fmt;\n    delete pat;\n    delete sym;\n}\n\n/**\n * Test the handling of the currency symbol in patterns.\n */\nvoid\nNumberFormatTest::TestCurrencySign(void)\n{\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols* sym = new DecimalFormatSymbols(Locale::getUS(), status);\n    UnicodeString pat;\n    UChar currency = 0x00A4;\n    if (U_FAILURE(status)) {\n        errcheckln(status, \"Fail to create DecimalFormatSymbols - %s\", u_errorName(status));\n        delete sym;\n        return;\n    }\n    // \"\\xA4#,##0.00;-\\xA4#,##0.00\"\n    pat.append(currency).append(\"#,##0.00;-\").\n        append(currency).append(\"#,##0.00\");\n    DecimalFormat *fmt = new DecimalFormat(pat, *sym, status);\n    UnicodeString s; ((NumberFormat*)fmt)->format(1234.56, s);\n    pat.truncate(0);\n    logln((UnicodeString)\"Pattern \\\"\" + fmt->toPattern(pat) + \"\\\"\");\n    logln((UnicodeString)\" Format \" + 1234.56 + \" -> \" + escape(s));\n    if (s != \"$1,234.56\") dataerrln((UnicodeString)\"FAIL: Expected $1,234.56\");\n    s.truncate(0);\n    ((NumberFormat*)fmt)->format(- 1234.56, s);\n    logln((UnicodeString)\" Format \" + (-1234.56) + \" -> \" + escape(s));\n    if (s != \"-$1,234.56\") dataerrln((UnicodeString)\"FAIL: Expected -$1,234.56\");\n    delete fmt;\n    pat.truncate(0);\n    // \"\\xA4\\xA4 #,##0.00;\\xA4\\xA4 -#,##0.00\"\n    pat.append(currency).append(currency).\n        append(\" #,##0.00;\").\n        append(currency).append(currency).\n        append(\" -#,##0.00\");\n    fmt = new DecimalFormat(pat, *sym, status);\n    s.truncate(0);\n    ((NumberFormat*)fmt)->format(1234.56, s);\n    logln((UnicodeString)\"Pattern \\\"\" + fmt->toPattern(pat) + \"\\\"\");\n    logln((UnicodeString)\" Format \" + 1234.56 + \" -> \" + escape(s));\n    if (s != \"USD 1,234.56\") dataerrln((UnicodeString)\"FAIL: Expected USD 1,234.56\");\n    s.truncate(0);\n    ((NumberFormat*)fmt)->format(-1234.56, s);\n    logln((UnicodeString)\" Format \" + (-1234.56) + \" -> \" + escape(s));\n    if (s != \"USD -1,234.56\") dataerrln((UnicodeString)\"FAIL: Expected USD -1,234.56\");\n    delete fmt;\n    delete sym;\n    if (U_FAILURE(status)) errln((UnicodeString)\"FAIL: Status \" + u_errorName(status));\n}\n\n// -------------------------------------\n\nstatic UChar toHexString(int32_t i) { return (UChar)(i + (i < 10 ? 0x30 : (0x41 - 10))); }\n\nUnicodeString&\nNumberFormatTest::escape(UnicodeString& s)\n{\n    UnicodeString buf;\n    for (int32_t i=0; i<s.length(); ++i)\n    {\n        UChar c = s[(int32_t)i];\n        if (c <= (UChar)0x7F) buf += c;\n        else {\n            buf += (UChar)0x5c; buf += (UChar)0x55;\n            buf += toHexString((c & 0xF000) >> 12);\n            buf += toHexString((c & 0x0F00) >> 8);\n            buf += toHexString((c & 0x00F0) >> 4);\n            buf += toHexString(c & 0x000F);\n        }\n    }\n    return (s = buf);\n}\n\n\n// -------------------------------------\nstatic const char* testCases[][2]= {\n     /* locale ID */  /* expected */\n    {\"ca_ES_PREEURO\", \"\\\\u20A7\\\\u00A01.150\" },\n    {\"de_LU_PREEURO\", \"1,150\\\\u00A0F\" },\n    {\"el_GR_PREEURO\", \"1.150,50\\\\u00A0\\\\u0394\\\\u03C1\\\\u03C7\" },\n    {\"en_BE_PREEURO\", \"1.150,50\\\\u00A0BEF\" },\n    {\"es_ES_PREEURO\", \"1.150\\\\u00A0\\\\u20A7\" },\n    {\"eu_ES_PREEURO\", \"\\\\u20A7\\\\u00A01.150\" },\n    {\"gl_ES_PREEURO\", \"1.150\\\\u00A0\\\\u20A7\" },\n    {\"it_IT_PREEURO\", \"ITL\\\\u00A01.150\" },\n    {\"pt_PT_PREEURO\", \"1,150$50\\\\u00A0\\\\u200B\"}, // per cldrbug 7670\n    {\"en_US@currency=JPY\", \"\\\\u00A51,150\"},\n    {\"en_US@currency=jpy\", \"\\\\u00A51,150\"},\n    {\"en-US-u-cu-jpy\", \"\\\\u00A51,150\"}\n};\n/**\n * Test localized currency patterns.\n */\nvoid\nNumberFormatTest::TestCurrency(void)\n{\n    UErrorCode status = U_ZERO_ERROR;\n    NumberFormat* currencyFmt = NumberFormat::createCurrencyInstance(Locale::getCanadaFrench(), status);\n    if (U_FAILURE(status)) {\n        dataerrln(\"Error calling NumberFormat::createCurrencyInstance()\");\n        return;\n    }\n\n    UnicodeString s; currencyFmt->format(1.50, s);\n    logln((UnicodeString)\"Un pauvre ici a...........\" + s);\n    if (!(s==CharsToUnicodeString(\"1,50\\\\u00A0$\")))\n        errln((UnicodeString)\"FAIL: Expected 1,50<nbsp>$ but got \" + s);\n    delete currencyFmt;\n    s.truncate(0);\n    char loc[256]={0};\n    int len = uloc_canonicalize(\"de_DE_PREEURO\", loc, 256, &status);\n    (void)len;  // Suppress unused variable warning.\n    currencyFmt = NumberFormat::createCurrencyInstance(Locale(loc),status);\n    currencyFmt->format(1.50, s);\n    logln((UnicodeString)\"Un pauvre en Allemagne a..\" + s);\n    if (!(s==CharsToUnicodeString(\"1,50\\\\u00A0DM\")))\n        errln((UnicodeString)\"FAIL: Expected 1,50<nbsp>DM but got \" + s);\n    delete currencyFmt;\n    s.truncate(0);\n    len = uloc_canonicalize(\"fr_FR_PREEURO\", loc, 256, &status);\n    currencyFmt = NumberFormat::createCurrencyInstance(Locale(loc), status);\n    currencyFmt->format(1.50, s);\n    logln((UnicodeString)\"Un pauvre en France a.....\" + s);\n    if (!(s==CharsToUnicodeString(\"1,50\\\\u00A0F\")))\n        errln((UnicodeString)\"FAIL: Expected 1,50<nbsp>F\");\n    delete currencyFmt;\n    if (U_FAILURE(status))\n        errln((UnicodeString)\"FAIL: Status \" + (int32_t)status);\n\n    for(int i=0; i < UPRV_LENGTHOF(testCases); i++){\n        status = U_ZERO_ERROR;\n        const char *localeID = testCases[i][0];\n        UnicodeString expected(testCases[i][1], -1, US_INV);\n        expected = expected.unescape();\n        s.truncate(0);\n        char loc[256]={0};\n        uloc_canonicalize(localeID, loc, 256, &status);\n        currencyFmt = NumberFormat::createCurrencyInstance(Locale(loc), status);\n        if(U_FAILURE(status)){\n            errln(\"Could not create currency formatter for locale %s\",localeID);\n            continue;\n        }\n        currencyFmt->format(1150.50, s);\n        if(s!=expected){\n            errln(UnicodeString(\"FAIL: Expected: \")+expected\n                    + UnicodeString(\" Got: \") + s\n                    + UnicodeString( \" for locale: \")+ UnicodeString(localeID) );\n        }\n        if (U_FAILURE(status)){\n            errln((UnicodeString)\"FAIL: Status \" + (int32_t)status);\n        }\n        delete currencyFmt;\n    }\n}\n\n// -------------------------------------\n\n/**\n * Test the Currency object handling, new as of ICU 2.2.\n */\nvoid NumberFormatTest::TestCurrencyObject() {\n    UErrorCode ec = U_ZERO_ERROR;\n    NumberFormat* fmt =\n        NumberFormat::createCurrencyInstance(Locale::getUS(), ec);\n\n    if (U_FAILURE(ec)) {\n        dataerrln(\"FAIL: getCurrencyInstance(US) - %s\", u_errorName(ec));\n        delete fmt;\n        return;\n    }\n\n    Locale null(\"\", \"\", \"\");\n\n    expectCurrency(*fmt, null, 1234.56, \"$1,234.56\");\n\n    expectCurrency(*fmt, Locale::getFrance(),\n                   1234.56, CharsToUnicodeString(\"\\\\u20AC1,234.56\")); // Euro\n\n    expectCurrency(*fmt, Locale::getJapan(),\n                   1234.56, CharsToUnicodeString(\"\\\\u00A51,235\")); // Yen\n\n    expectCurrency(*fmt, Locale(\"fr\", \"CH\", \"\"),\n                   1234.56, \"CHF 1,234.56\"); // no more 0.05 rounding here, see cldrbug 5548\n\n    expectCurrency(*fmt, Locale::getUS(),\n                   1234.56, \"$1,234.56\");\n\n    delete fmt;\n    fmt = NumberFormat::createCurrencyInstance(Locale::getFrance(), ec);\n\n    if (U_FAILURE(ec)) {\n        errln(\"FAIL: getCurrencyInstance(FRANCE)\");\n        delete fmt;\n        return;\n    }\n\n    expectCurrency(*fmt, null, 1234.56, CharsToUnicodeString(\"1\\\\u202F234,56 \\\\u20AC\"));\n\n    expectCurrency(*fmt, Locale::getJapan(),\n                   1234.56, CharsToUnicodeString(\"1\\\\u202F235 JPY\")); // Yen\n\n    expectCurrency(*fmt, Locale(\"fr\", \"CH\", \"\"),\n                   1234.56, CharsToUnicodeString(\"1\\\\u202F234,56 CHF\")); // no more 0.05 rounding here, see cldrbug 5548\n\n    expectCurrency(*fmt, Locale::getUS(),\n                   1234.56, CharsToUnicodeString(\"1\\\\u202F234,56 $US\"));\n\n    expectCurrency(*fmt, Locale::getFrance(),\n                   1234.56, CharsToUnicodeString(\"1\\\\u202F234,56 \\\\u20AC\")); // Euro\n\n    delete fmt;\n}\n\n// -------------------------------------\n\n/**\n * Do rudimentary testing of parsing.\n */\nvoid\nNumberFormatTest::TestParse(void)\n{\n    UErrorCode status = U_ZERO_ERROR;\n    UnicodeString arg(\"0\");\n    DecimalFormat* format = new DecimalFormat(\"00\", status);\n    //try {\n        Formattable n; format->parse(arg, n, status);\n        logln((UnicodeString)\"parse(\" + arg + \") = \" + n.getLong());\n        if (n.getType() != Formattable::kLong ||\n            n.getLong() != 0) errln((UnicodeString)\"FAIL: Expected 0\");\n    delete format;\n    if (U_FAILURE(status)) errcheckln(status, (UnicodeString)\"FAIL: Status \" + u_errorName(status));\n    //}\n    //catch(Exception e) {\n    //    errln((UnicodeString)\"Exception caught: \" + e);\n    //}\n}\n\n// -------------------------------------\n\nstatic const char *lenientAffixTestCases[] = {\n        \"(1)\",\n        \"( 1)\",\n        \"(1 )\",\n        \"( 1 )\"\n};\n\nstatic const char *lenientMinusTestCases[] = {\n    \"-5\",\n    \"\\\\u22125\",\n    \"\\\\u27965\"\n};\n\nstatic const char *lenientCurrencyTestCases[] = {\n        \"$1,000\",\n        \"$ 1,000\",\n        \"$1000\",\n        \"$ 1000\",\n        \"$1 000.00\",\n        \"$ 1 000.00\",\n        \"$ 1\\\\u00A0000.00\",\n        \"1000.00\"\n};\n\n// changed from () to - per cldrbug 5674\nstatic const char *lenientNegativeCurrencyTestCases[] = {\n        \"-$1,000\",\n        \"-$ 1,000\",\n        \"-$1000\",\n        \"-$ 1000\",\n        \"-$1 000.00\",\n        \"-$ 1 000.00\",\n        \"- $ 1,000.00 \",\n        \"-$ 1\\\\u00A0000.00\",\n        \"-1000.00\"\n};\n\nstatic const char *lenientPercentTestCases[] = {\n        \"25%\",\n        \" 25%\",\n        \" 25 %\",\n    \t\"25 %\",\n\t\t\"25\\\\u00A0%\",\n\t\t\"25\"\n};\n\nstatic const char *lenientNegativePercentTestCases[] = {\n\t\t\"-25%\",\n\t\t\" -25%\",\n\t\t\" - 25%\",\n\t\t\"- 25 %\",\n\t\t\" - 25 %\",\n\t\t\"-25 %\",\n\t\t\"-25\\\\u00A0%\",\n\t\t\"-25\",\n\t\t\"- 25\"\n};\n\nstatic const char *strictFailureTestCases[] = {\n\t\t\" 1000\",\n\t\t\"10,00\",\n\t\t\"1,000,.0\"\n};\n\n/**\n * Test lenient parsing.\n */\nvoid\nNumberFormatTest::TestLenientParse(void)\n{\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat *format = new DecimalFormat(\"(#,##0)\", status);\n    Formattable n;\n\n    if (format == NULL || U_FAILURE(status)) {\n        dataerrln(\"Unable to create DecimalFormat (#,##0) - %s\", u_errorName(status));\n    } else {\n        format->setLenient(TRUE);\n        for (int32_t t = 0; t < UPRV_LENGTHOF (lenientAffixTestCases); t += 1) {\n        \tUnicodeString testCase = ctou(lenientAffixTestCases[t]);\n\n            format->parse(testCase, n, status);\n            logln((UnicodeString)\"parse(\" + testCase + \") = \" + n.getLong());\n\n            if (U_FAILURE(status) || n.getType() != Formattable::kLong ||\n            \tn.getLong() != 1) {\n            \tdataerrln((UnicodeString)\"Lenient parse failed for \\\"\" + (UnicodeString) lenientAffixTestCases[t]\n                      + (UnicodeString) \"\\\"; error code = \" + u_errorName(status));\n            \tstatus = U_ZERO_ERROR;\n            }\n       }\n       delete format;\n    }\n\n    Locale en_US(\"en_US\");\n    Locale sv_SE(\"sv_SE\");\n\n    NumberFormat *mFormat = NumberFormat::createInstance(sv_SE, UNUM_DECIMAL, status);\n\n    if (mFormat == NULL || U_FAILURE(status)) {\n        dataerrln(\"Unable to create NumberFormat (sv_SE, UNUM_DECIMAL) - %s\", u_errorName(status));\n    } else {\n        mFormat->setLenient(TRUE);\n        for (int32_t t = 0; t < UPRV_LENGTHOF(lenientMinusTestCases); t += 1) {\n            UnicodeString testCase = ctou(lenientMinusTestCases[t]);\n\n            mFormat->parse(testCase, n, status);\n            logln((UnicodeString)\"parse(\" + testCase + \") = \" + n.getLong());\n\n            if (U_FAILURE(status) || n.getType() != Formattable::kLong || n.getLong() != -5) {\n                errln((UnicodeString)\"Lenient parse failed for \\\"\" + (UnicodeString) lenientMinusTestCases[t]\n                      + (UnicodeString) \"\\\"; error code = \" + u_errorName(status));\n                status = U_ZERO_ERROR;\n            }\n        }\n        delete mFormat;\n    }\n\n    mFormat = NumberFormat::createInstance(en_US, UNUM_DECIMAL, status);\n\n    if (mFormat == NULL || U_FAILURE(status)) {\n        dataerrln(\"Unable to create NumberFormat (en_US, UNUM_DECIMAL) - %s\", u_errorName(status));\n    } else {\n        mFormat->setLenient(TRUE);\n        for (int32_t t = 0; t < UPRV_LENGTHOF(lenientMinusTestCases); t += 1) {\n            UnicodeString testCase = ctou(lenientMinusTestCases[t]);\n\n            mFormat->parse(testCase, n, status);\n            logln((UnicodeString)\"parse(\" + testCase + \") = \" + n.getLong());\n\n            if (U_FAILURE(status) || n.getType() != Formattable::kLong || n.getLong() != -5) {\n                errln((UnicodeString)\"Lenient parse failed for \\\"\" + (UnicodeString) lenientMinusTestCases[t]\n                      + (UnicodeString) \"\\\"; error code = \" + u_errorName(status));\n                status = U_ZERO_ERROR;\n            }\n        }\n        delete mFormat;\n    }\n\n    NumberFormat *cFormat = NumberFormat::createInstance(en_US, UNUM_CURRENCY, status);\n\n    if (cFormat == NULL || U_FAILURE(status)) {\n        dataerrln(\"Unable to create NumberFormat (en_US, UNUM_CURRENCY) - %s\", u_errorName(status));\n    } else {\n        cFormat->setLenient(TRUE);\n        for (int32_t t = 0; t < UPRV_LENGTHOF (lenientCurrencyTestCases); t += 1) {\n        \tUnicodeString testCase = ctou(lenientCurrencyTestCases[t]);\n\n            cFormat->parse(testCase, n, status);\n            logln((UnicodeString)\"parse(\" + testCase + \") = \" + n.getLong());\n\n            if (U_FAILURE(status) ||n.getType() != Formattable::kLong ||\n            \tn.getLong() != 1000) {\n            \terrln((UnicodeString)\"Lenient parse failed for \\\"\" + (UnicodeString) lenientCurrencyTestCases[t]\n                      + (UnicodeString) \"\\\"; error code = \" + u_errorName(status));\n            \tstatus = U_ZERO_ERROR;\n            }\n        }\n\n        for (int32_t t = 0; t < UPRV_LENGTHOF (lenientNegativeCurrencyTestCases); t += 1) {\n        \tUnicodeString testCase = ctou(lenientNegativeCurrencyTestCases[t]);\n\n            cFormat->parse(testCase, n, status);\n            logln((UnicodeString)\"parse(\" + testCase + \") = \" + n.getLong());\n\n            if (U_FAILURE(status) ||n.getType() != Formattable::kLong ||\n            \tn.getLong() != -1000) {\n            \terrln((UnicodeString)\"Lenient parse failed for \\\"\" + (UnicodeString) lenientNegativeCurrencyTestCases[t]\n                      + (UnicodeString) \"\\\"; error code = \" + u_errorName(status));\n            \tstatus = U_ZERO_ERROR;\n            }\n        }\n\n        delete cFormat;\n    }\n\n    NumberFormat *pFormat = NumberFormat::createPercentInstance(en_US, status);\n\n    if (pFormat == NULL || U_FAILURE(status)) {\n        dataerrln(\"Unable to create NumberFormat::createPercentInstance (en_US) - %s\", u_errorName(status));\n    } else {\n        pFormat->setLenient(TRUE);\n        for (int32_t t = 0; t < UPRV_LENGTHOF (lenientPercentTestCases); t += 1) {\n        \tUnicodeString testCase = ctou(lenientPercentTestCases[t]);\n\n        \tpFormat->parse(testCase, n, status);\n            logln((UnicodeString)\"parse(\" + testCase + \") = \" + n.getDouble());\n\n            if (U_FAILURE(status) ||n.getType() != Formattable::kDouble ||\n            \tn.getDouble() != 0.25) {\n            \terrln((UnicodeString)\"Lenient parse failed for \\\"\" + (UnicodeString) lenientPercentTestCases[t]\n                      + (UnicodeString) \"\\\"; error code = \" + u_errorName(status)\n                      + \"; got: \" + n.getDouble(status));\n            \tstatus = U_ZERO_ERROR;\n            }\n        }\n\n        for (int32_t t = 0; t < UPRV_LENGTHOF (lenientNegativePercentTestCases); t += 1) {\n        \tUnicodeString testCase = ctou(lenientNegativePercentTestCases[t]);\n\n        \tpFormat->parse(testCase, n, status);\n            logln((UnicodeString)\"parse(\" + testCase + \") = \" + n.getDouble());\n\n            if (U_FAILURE(status) ||n.getType() != Formattable::kDouble ||\n            \tn.getDouble() != -0.25) {\n            \terrln((UnicodeString)\"Lenient parse failed for \\\"\" + (UnicodeString) lenientNegativePercentTestCases[t]\n                      + (UnicodeString) \"\\\"; error code = \" + u_errorName(status)\n                      + \"; got: \" + n.getDouble(status));\n            \tstatus = U_ZERO_ERROR;\n            }\n        }\n\n        delete pFormat;\n    }\n\n   // Test cases that should fail with a strict parse and pass with a\n   // lenient parse.\n   NumberFormat *nFormat = NumberFormat::createInstance(en_US, status);\n\n   if (nFormat == NULL || U_FAILURE(status)) {\n       dataerrln(\"Unable to create NumberFormat (en_US) - %s\", u_errorName(status));\n   } else {\n       // first, make sure that they fail with a strict parse\n       for (int32_t t = 0; t < UPRV_LENGTHOF(strictFailureTestCases); t += 1) {\n\t       UnicodeString testCase = ctou(strictFailureTestCases[t]);\n\n\t       nFormat->parse(testCase, n, status);\n\t       logln((UnicodeString)\"parse(\" + testCase + \") = \" + n.getLong());\n\n\t       if (! U_FAILURE(status)) {\n\t\t       errln((UnicodeString)\"Strict Parse succeeded for \\\"\" + (UnicodeString) strictFailureTestCases[t]\n                     + (UnicodeString) \"\\\"; error code = \" + u_errorName(status));\n\t       }\n\n\t       status = U_ZERO_ERROR;\n       }\n\n       // then, make sure that they pass with a lenient parse\n       nFormat->setLenient(TRUE);\n       for (int32_t t = 0; t < UPRV_LENGTHOF(strictFailureTestCases); t += 1) {\n\t       UnicodeString testCase = ctou(strictFailureTestCases[t]);\n\n\t       nFormat->parse(testCase, n, status);\n\t       logln((UnicodeString)\"parse(\" + testCase + \") = \" + n.getLong());\n\n\t       if (U_FAILURE(status) ||n.getType() != Formattable::kLong ||\n\t            \tn.getLong() != 1000) {\n\t\t       errln((UnicodeString)\"Lenient parse failed for \\\"\" + (UnicodeString) strictFailureTestCases[t]\n                     + (UnicodeString) \"\\\"; error code = \" + u_errorName(status));\n\t\t       status = U_ZERO_ERROR;\n\t       }\n       }\n\n       delete nFormat;\n   }\n}\n\n// -------------------------------------\n\n/**\n * Test proper rounding by the format method.\n */\nvoid\nNumberFormatTest::TestRounding487(void)\n{\n    UErrorCode status = U_ZERO_ERROR;\n    NumberFormat *nf = NumberFormat::createInstance(status);\n    if (U_FAILURE(status)) {\n        dataerrln(\"Error calling NumberFormat::createInstance()\");\n        return;\n    }\n\n    roundingTest(*nf, 0.00159999, 4, \"0.0016\");\n    roundingTest(*nf, 0.00995, 4, \"0.01\");\n\n    roundingTest(*nf, 12.3995, 3, \"12.4\");\n\n    roundingTest(*nf, 12.4999, 0, \"12\");\n    roundingTest(*nf, - 19.5, 0, \"-20\");\n    delete nf;\n    if (U_FAILURE(status)) errln((UnicodeString)\"FAIL: Status \" + (int32_t)status);\n}\n\n/**\n * Test the functioning of the secondary grouping value.\n */\nvoid NumberFormatTest::TestSecondaryGrouping(void) {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols US(Locale::getUS(), status);\n    CHECK(status, \"DecimalFormatSymbols ct\");\n\n    DecimalFormat f(\"#,##,###\", US, status);\n    CHECK(status, \"DecimalFormat ct\");\n\n    expect2(f, (int32_t)123456789L, \"12,34,56,789\");\n    expectPat(f, \"#,##,##0\");\n    f.applyPattern(\"#,###\", status);\n    CHECK(status, \"applyPattern\");\n\n    f.setSecondaryGroupingSize(4);\n    expect2(f, (int32_t)123456789L, \"12,3456,789\");\n    expectPat(f, \"#,####,##0\");\n    NumberFormat *g = NumberFormat::createInstance(Locale(\"hi\", \"IN\"), status);\n    CHECK_DATA(status, \"createInstance(hi_IN)\");\n\n    UnicodeString out;\n    int32_t l = (int32_t)1876543210L;\n    g->format(l, out);\n    delete g;\n    // expect \"1,87,65,43,210\", but with Hindi digits\n    //         01234567890123\n    UBool ok = TRUE;\n    if (out.length() != 14) {\n        ok = FALSE;\n    } else {\n        for (int32_t i=0; i<out.length(); ++i) {\n            UBool expectGroup = FALSE;\n            switch (i) {\n            case 1:\n            case 4:\n            case 7:\n            case 10:\n                expectGroup = TRUE;\n                break;\n            }\n            // Later -- fix this to get the actual grouping\n            // character from the resource bundle.\n            UBool isGroup = (out.charAt(i) == 0x002C);\n            if (isGroup != expectGroup) {\n                ok = FALSE;\n                break;\n            }\n        }\n    }\n    if (!ok) {\n        errln((UnicodeString)\"FAIL  Expected \" + l +\n              \" x hi_IN -> \\\"1,87,65,43,210\\\" (with Hindi digits), got \\\"\" +\n              escape(out) + \"\\\"\");\n    } else {\n        logln((UnicodeString)\"Ok    \" + l +\n              \" x hi_IN -> \\\"\" +\n              escape(out) + \"\\\"\");\n    }\n}\n\nvoid NumberFormatTest::TestWhiteSpaceParsing(void) {\n    UErrorCode ec = U_ZERO_ERROR;\n    DecimalFormatSymbols US(Locale::getUS(), ec);\n    DecimalFormat fmt(\"a  b#0c  \", US, ec);\n    if (U_FAILURE(ec)) {\n        errcheckln(ec, \"FAIL: Constructor - %s\", u_errorName(ec));\n        return;\n    }\n    // From ICU 62, flexible whitespace needs lenient mode\n    fmt.setLenient(TRUE);\n    int32_t n = 1234;\n    expect(fmt, \"a b1234c \", n);\n    expect(fmt, \"a   b1234c   \", n);\n}\n\n/**\n * Test currencies whose display name is a ChoiceFormat.\n */\nvoid NumberFormatTest::TestComplexCurrency() {\n\n//    UErrorCode ec = U_ZERO_ERROR;\n//    Locale loc(\"kn\", \"IN\", \"\");\n//    NumberFormat* fmt = NumberFormat::createCurrencyInstance(loc, ec);\n//    if (U_SUCCESS(ec)) {\n//        expect2(*fmt, 1.0, CharsToUnicodeString(\"Re.\\\\u00A01.00\"));\n//        Use .00392625 because that's 2^-8.  Any value less than 0.005 is fine.\n//        expect(*fmt, 1.00390625, CharsToUnicodeString(\"Re.\\\\u00A01.00\")); // tricky\n//        expect2(*fmt, 12345678.0, CharsToUnicodeString(\"Rs.\\\\u00A01,23,45,678.00\"));\n//        expect2(*fmt, 0.5, CharsToUnicodeString(\"Rs.\\\\u00A00.50\"));\n//        expect2(*fmt, -1.0, CharsToUnicodeString(\"-Re.\\\\u00A01.00\"));\n//        expect2(*fmt, -10.0, CharsToUnicodeString(\"-Rs.\\\\u00A010.00\"));\n//    } else {\n//        errln(\"FAIL: getCurrencyInstance(kn_IN)\");\n//    }\n//    delete fmt;\n\n}\n\n// -------------------------------------\n\nvoid\nNumberFormatTest::roundingTest(NumberFormat& nf, double x, int32_t maxFractionDigits, const char* expected)\n{\n    nf.setMaximumFractionDigits(maxFractionDigits);\n    UnicodeString out; nf.format(x, out);\n    logln((UnicodeString)\"\" + x + \" formats with \" + maxFractionDigits + \" fractional digits to \" + out);\n    if (!(out==expected)) errln((UnicodeString)\"FAIL: Expected \" + expected);\n}\n\n/**\n * Upgrade to alphaWorks\n */\nvoid NumberFormatTest::TestExponent(void) {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols US(Locale::getUS(), status);\n    CHECK(status, \"DecimalFormatSymbols constructor\");\n    DecimalFormat fmt1(UnicodeString(\"0.###E0\"), US, status);\n    CHECK(status, \"DecimalFormat(0.###E0)\");\n    DecimalFormat fmt2(UnicodeString(\"0.###E+0\"), US, status);\n    CHECK(status, \"DecimalFormat(0.###E+0)\");\n    int32_t n = 1234;\n    expect2(fmt1, n, \"1.234E3\");\n    expect2(fmt2, n, \"1.234E+3\");\n    expect(fmt1, \"1.234E+3\", n); // Either format should parse \"E+3\"\n}\n\n/**\n * Upgrade to alphaWorks\n */\nvoid NumberFormatTest::TestScientific(void) {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols US(Locale::getUS(), status);\n    CHECK(status, \"DecimalFormatSymbols constructor\");\n\n    // Test pattern round-trip\n    const char* PAT[] = { \"#E0\", \"0.####E0\", \"00.000E00\", \"##0.####E000\",\n                          \"0.###E0;[0.###E0]\" };\n    int32_t PAT_length = UPRV_LENGTHOF(PAT);\n    int32_t DIGITS[] = {\n        // min int, max int, min frac, max frac\n        1, 1, 0, 0, // \"#E0\"\n        1, 1, 0, 4, // \"0.####E0\"\n        2, 2, 3, 3, // \"00.000E00\"\n        1, 3, 0, 4, // \"##0.####E000\"\n        1, 1, 0, 3, // \"0.###E0;[0.###E0]\"\n    };\n    for (int32_t i=0; i<PAT_length; ++i) {\n        UnicodeString pat(PAT[i]);\n        DecimalFormat df(pat, US, status);\n        CHECK(status, \"DecimalFormat constructor\");\n        UnicodeString pat2;\n        df.toPattern(pat2);\n        if (pat == pat2) {\n            logln(UnicodeString(\"Ok   Pattern rt \\\"\") +\n                  pat + \"\\\" -> \\\"\" +\n                  pat2 + \"\\\"\");\n        } else {\n            errln(UnicodeString(\"FAIL Pattern rt \\\"\") +\n                  pat + \"\\\" -> \\\"\" +\n                  pat2 + \"\\\"\");\n        }\n        // Make sure digit counts match what we expect\n        if (df.getMinimumIntegerDigits() != DIGITS[4*i] ||\n            df.getMaximumIntegerDigits() != DIGITS[4*i+1] ||\n            df.getMinimumFractionDigits() != DIGITS[4*i+2] ||\n            df.getMaximumFractionDigits() != DIGITS[4*i+3]) {\n            errln(UnicodeString(\"FAIL \\\"\" + pat +\n                                \"\\\" min/max int; min/max frac = \") +\n                  df.getMinimumIntegerDigits() + \"/\" +\n                  df.getMaximumIntegerDigits() + \";\" +\n                  df.getMinimumFractionDigits() + \"/\" +\n                  df.getMaximumFractionDigits() + \", expect \" +\n                  DIGITS[4*i] + \"/\" +\n                  DIGITS[4*i+1] + \";\" +\n                  DIGITS[4*i+2] + \"/\" +\n                  DIGITS[4*i+3]);\n        }\n    }\n\n\n    // Test the constructor for default locale. We have to\n    // manually set the default locale, as there is no\n    // guarantee that the default locale has the same\n    // scientific format.\n    Locale def = Locale::getDefault();\n    Locale::setDefault(Locale::getUS(), status);\n    expect2(NumberFormat::createScientificInstance(status),\n           12345.678901,\n           \"1.2345678901E4\", status);\n    Locale::setDefault(def, status);\n\n    expect2(new DecimalFormat(\"#E0\", US, status),\n           12345.0,\n           \"1.2345E4\", status);\n    expect(new DecimalFormat(\"0E0\", US, status),\n           12345.0,\n           \"1E4\", status);\n    expect2(NumberFormat::createScientificInstance(Locale::getUS(), status),\n           12345.678901,\n           \"1.2345678901E4\", status);\n    expect(new DecimalFormat(\"##0.###E0\", US, status),\n           12345.0,\n           \"12.34E3\", status);\n    expect(new DecimalFormat(\"##0.###E0\", US, status),\n           12345.00001,\n           \"12.35E3\", status);\n    expect2(new DecimalFormat(\"##0.####E0\", US, status),\n           (int32_t) 12345,\n           \"12.345E3\", status);\n    expect2(NumberFormat::createScientificInstance(Locale::getFrance(), status),\n           12345.678901,\n           \"1,2345678901E4\", status);\n    expect(new DecimalFormat(\"##0.####E0\", US, status),\n           789.12345e-9,\n           \"789.12E-9\", status);\n    expect2(new DecimalFormat(\"##0.####E0\", US, status),\n           780.e-9,\n           \"780E-9\", status);\n    expect(new DecimalFormat(\".###E0\", US, status),\n           45678.0,\n           \".457E5\", status);\n    expect2(new DecimalFormat(\".###E0\", US, status),\n           (int32_t) 0,\n           \".0E0\", status);\n    /*\n    expect(new DecimalFormat[] { new DecimalFormat(\"#E0\", US),\n                                 new DecimalFormat(\"##E0\", US),\n                                 new DecimalFormat(\"####E0\", US),\n                                 new DecimalFormat(\"0E0\", US),\n                                 new DecimalFormat(\"00E0\", US),\n                                 new DecimalFormat(\"000E0\", US),\n                               },\n           new Long(45678000),\n           new String[] { \"4.5678E7\",\n                          \"45.678E6\",\n                          \"4567.8E4\",\n                          \"5E7\",\n                          \"46E6\",\n                          \"457E5\",\n                        }\n           );\n    !\n    ! Unroll this test into individual tests below...\n    !\n    */\n    expect2(new DecimalFormat(\"#E0\", US, status),\n           (int32_t) 45678000, \"4.5678E7\", status);\n    expect2(new DecimalFormat(\"##E0\", US, status),\n           (int32_t) 45678000, \"45.678E6\", status);\n    expect2(new DecimalFormat(\"####E0\", US, status),\n           (int32_t) 45678000, \"4567.8E4\", status);\n    expect(new DecimalFormat(\"0E0\", US, status),\n           (int32_t) 45678000, \"5E7\", status);\n    expect(new DecimalFormat(\"00E0\", US, status),\n           (int32_t) 45678000, \"46E6\", status);\n    expect(new DecimalFormat(\"000E0\", US, status),\n           (int32_t) 45678000, \"457E5\", status);\n    /*\n    expect(new DecimalFormat(\"###E0\", US, status),\n           new Object[] { new Double(0.0000123), \"12.3E-6\",\n                          new Double(0.000123), \"123E-6\",\n                          new Double(0.00123), \"1.23E-3\",\n                          new Double(0.0123), \"12.3E-3\",\n                          new Double(0.123), \"123E-3\",\n                          new Double(1.23), \"1.23E0\",\n                          new Double(12.3), \"12.3E0\",\n                          new Double(123), \"123E0\",\n                          new Double(1230), \"1.23E3\",\n                         });\n    !\n    ! Unroll this test into individual tests below...\n    !\n    */\n    expect2(new DecimalFormat(\"###E0\", US, status),\n           0.0000123, \"12.3E-6\", status);\n    expect2(new DecimalFormat(\"###E0\", US, status),\n           0.000123, \"123E-6\", status);\n    expect2(new DecimalFormat(\"###E0\", US, status),\n           0.00123, \"1.23E-3\", status);\n    expect2(new DecimalFormat(\"###E0\", US, status),\n           0.0123, \"12.3E-3\", status);\n    expect2(new DecimalFormat(\"###E0\", US, status),\n           0.123, \"123E-3\", status);\n    expect2(new DecimalFormat(\"###E0\", US, status),\n           1.23, \"1.23E0\", status);\n    expect2(new DecimalFormat(\"###E0\", US, status),\n           12.3, \"12.3E0\", status);\n    expect2(new DecimalFormat(\"###E0\", US, status),\n           123.0, \"123E0\", status);\n    expect2(new DecimalFormat(\"###E0\", US, status),\n           1230.0, \"1.23E3\", status);\n    /*\n    expect(new DecimalFormat(\"0.#E+00\", US, status),\n           new Object[] { new Double(0.00012), \"1.2E-04\",\n                          new Long(12000),     \"1.2E+04\",\n                         });\n    !\n    ! Unroll this test into individual tests below...\n    !\n    */\n    expect2(new DecimalFormat(\"0.#E+00\", US, status),\n           0.00012, \"1.2E-04\", status);\n    expect2(new DecimalFormat(\"0.#E+00\", US, status),\n           (int32_t) 12000, \"1.2E+04\", status);\n}\n\n/**\n * Upgrade to alphaWorks\n */\nvoid NumberFormatTest::TestPad(void) {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols US(Locale::getUS(), status);\n    CHECK(status, \"DecimalFormatSymbols constructor\");\n\n    expect2(new DecimalFormat(\"*^##.##\", US, status),\n           int32_t(0), \"^^^^0\", status);\n    expect2(new DecimalFormat(\"*^##.##\", US, status),\n           -1.3, \"^-1.3\", status);\n    expect2(new DecimalFormat(\"##0.0####E0*_ 'g-m/s^2'\", US, status),\n           int32_t(0), \"0.0E0______ g-m/s^2\", status);\n    expect(new DecimalFormat(\"##0.0####E0*_ 'g-m/s^2'\", US, status),\n           1.0/3, \"333.333E-3_ g-m/s^2\", status);\n    expect2(new DecimalFormat(\"##0.0####*_ 'g-m/s^2'\", US, status),\n           int32_t(0), \"0.0______ g-m/s^2\", status);\n    expect(new DecimalFormat(\"##0.0####*_ 'g-m/s^2'\", US, status),\n           1.0/3, \"0.33333__ g-m/s^2\", status);\n\n    // Test padding before a sign\n    const char *formatStr = \"*x#,###,###,##0.0#;*x(###,###,##0.0#)\";\n    expect2(new DecimalFormat(formatStr, US, status),\n           int32_t(-10),  \"xxxxxxxxxx(10.0)\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           int32_t(-1000),\"xxxxxxx(1,000.0)\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           int32_t(-1000000),\"xxx(1,000,000.0)\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           -100.37,       \"xxxxxxxx(100.37)\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           -10456.37,     \"xxxxx(10,456.37)\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           -1120456.37,   \"xx(1,120,456.37)\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           -112045600.37, \"(112,045,600.37)\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           -1252045600.37,\"(1,252,045,600.37)\", status);\n\n    expect2(new DecimalFormat(formatStr, US, status),\n           int32_t(10),  \"xxxxxxxxxxxx10.0\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           int32_t(1000),\"xxxxxxxxx1,000.0\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           int32_t(1000000),\"xxxxx1,000,000.0\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           100.37,       \"xxxxxxxxxx100.37\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           10456.37,     \"xxxxxxx10,456.37\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           1120456.37,   \"xxxx1,120,456.37\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           112045600.37, \"xx112,045,600.37\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           10252045600.37,\"10,252,045,600.37\", status);\n\n\n    // Test padding between a sign and a number\n    const char *formatStr2 = \"#,###,###,##0.0#*x;(###,###,##0.0#*x)\";\n    expect2(new DecimalFormat(formatStr2, US, status),\n           int32_t(-10),  \"(10.0xxxxxxxxxx)\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           int32_t(-1000),\"(1,000.0xxxxxxx)\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           int32_t(-1000000),\"(1,000,000.0xxx)\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           -100.37,       \"(100.37xxxxxxxx)\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           -10456.37,     \"(10,456.37xxxxx)\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           -1120456.37,   \"(1,120,456.37xx)\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           -112045600.37, \"(112,045,600.37)\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           -1252045600.37,\"(1,252,045,600.37)\", status);\n\n    expect2(new DecimalFormat(formatStr2, US, status),\n           int32_t(10),  \"10.0xxxxxxxxxxxx\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           int32_t(1000),\"1,000.0xxxxxxxxx\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           int32_t(1000000),\"1,000,000.0xxxxx\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           100.37,       \"100.37xxxxxxxxxx\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           10456.37,     \"10,456.37xxxxxxx\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           1120456.37,   \"1,120,456.37xxxx\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           112045600.37, \"112,045,600.37xx\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           10252045600.37,\"10,252,045,600.37\", status);\n\n    //testing the setPadCharacter(UnicodeString) and getPadCharacterString()\n    DecimalFormat fmt(\"#\", US, status);\n    CHECK(status, \"DecimalFormat constructor\");\n    UnicodeString padString(\"P\");\n    fmt.setPadCharacter(padString);\n    expectPad(fmt, \"*P##.##\", DecimalFormat::kPadBeforePrefix, 5, padString);\n    fmt.setPadCharacter((UnicodeString)\"^\");\n    expectPad(fmt, \"*^#\", DecimalFormat::kPadBeforePrefix, 1, (UnicodeString)\"^\");\n    //commented untill implementation is complete\n  /*  fmt.setPadCharacter((UnicodeString)\"^^^\");\n    expectPad(fmt, \"*^^^#\", DecimalFormat::kPadBeforePrefix, 3, (UnicodeString)\"^^^\");\n    padString.remove();\n    padString.append((UChar)0x0061);\n    padString.append((UChar)0x0302);\n    fmt.setPadCharacter(padString);\n    UChar patternChars[]={0x002a, 0x0061, 0x0302, 0x0061, 0x0302, 0x0023, 0x0000};\n    UnicodeString pattern(patternChars);\n    expectPad(fmt, pattern , DecimalFormat::kPadBeforePrefix, 4, padString);\n */\n\n}\n\n/**\n * Upgrade to alphaWorks\n */\nvoid NumberFormatTest::TestPatterns2(void) {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols US(Locale::getUS(), status);\n    CHECK(status, \"DecimalFormatSymbols constructor\");\n\n    DecimalFormat fmt(\"#\", US, status);\n    CHECK(status, \"DecimalFormat constructor\");\n\n    UChar hat = 0x005E; /*^*/\n\n    expectPad(fmt, \"*^#\", DecimalFormat::kPadBeforePrefix, 1, hat);\n    expectPad(fmt, \"$*^#\", DecimalFormat::kPadAfterPrefix, 2, hat);\n    expectPad(fmt, \"#*^\", DecimalFormat::kPadBeforeSuffix, 1, hat);\n    expectPad(fmt, \"#$*^\", DecimalFormat::kPadAfterSuffix, 2, hat);\n    expectPad(fmt, \"$*^$#\", ILLEGAL);\n    expectPad(fmt, \"#$*^$\", ILLEGAL);\n    expectPad(fmt, \"'pre'#,##0*x'post'\", DecimalFormat::kPadBeforeSuffix,\n              12, (UChar)0x0078 /*x*/);\n    expectPad(fmt, \"''#0*x\", DecimalFormat::kPadBeforeSuffix,\n              3, (UChar)0x0078 /*x*/);\n    expectPad(fmt, \"'I''ll'*a###.##\", DecimalFormat::kPadAfterPrefix,\n              10, (UChar)0x0061 /*a*/);\n\n    fmt.applyPattern(\"AA#,##0.00ZZ\", status);\n    CHECK(status, \"applyPattern\");\n    fmt.setPadCharacter(hat);\n\n    fmt.setFormatWidth(10);\n\n    fmt.setPadPosition(DecimalFormat::kPadBeforePrefix);\n    expectPat(fmt, \"*^AA#,##0.00ZZ\");\n\n    fmt.setPadPosition(DecimalFormat::kPadBeforeSuffix);\n    expectPat(fmt, \"AA#,##0.00*^ZZ\");\n\n    fmt.setPadPosition(DecimalFormat::kPadAfterSuffix);\n    expectPat(fmt, \"AA#,##0.00ZZ*^\");\n\n    //            12  3456789012\n    UnicodeString exp(\"AA*^#,##0.00ZZ\", \"\");\n    fmt.setFormatWidth(12);\n    fmt.setPadPosition(DecimalFormat::kPadAfterPrefix);\n    expectPat(fmt, exp);\n\n    fmt.setFormatWidth(13);\n    //              12  34567890123\n    expectPat(fmt, \"AA*^##,##0.00ZZ\");\n\n    fmt.setFormatWidth(14);\n    //              12  345678901234\n    expectPat(fmt, \"AA*^###,##0.00ZZ\");\n\n    fmt.setFormatWidth(15);\n    //              12  3456789012345\n    expectPat(fmt, \"AA*^####,##0.00ZZ\"); // This is the interesting case\n\n    fmt.setFormatWidth(16);\n    //              12  34567890123456\n    expectPat(fmt, \"AA*^#####,##0.00ZZ\");\n}\n\nvoid NumberFormatTest::TestSurrogateSupport(void) {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols custom(Locale::getUS(), status);\n    CHECK(status, \"DecimalFormatSymbols constructor\");\n\n    custom.setSymbol(DecimalFormatSymbols::kDecimalSeparatorSymbol, \"decimal\");\n    custom.setSymbol(DecimalFormatSymbols::kPlusSignSymbol, \"plus\");\n    custom.setSymbol(DecimalFormatSymbols::kMinusSignSymbol, \" minus \");\n    custom.setSymbol(DecimalFormatSymbols::kExponentialSymbol, \"exponent\");\n\n    UnicodeString patternStr(\"*\\\\U00010000##.##\", \"\");\n    patternStr = patternStr.unescape();\n    UnicodeString expStr(\"\\\\U00010000\\\\U00010000\\\\U00010000\\\\U000100000\", \"\");\n    expStr = expStr.unescape();\n    expect2(new DecimalFormat(patternStr, custom, status),\n           int32_t(0), expStr, status);\n\n    status = U_ZERO_ERROR;\n    expect2(new DecimalFormat(\"*^##.##\", custom, status),\n           int32_t(0), \"^^^^0\", status);\n    status = U_ZERO_ERROR;\n    expect2(new DecimalFormat(\"##.##\", custom, status),\n           -1.3, \" minus 1decimal3\", status);\n    status = U_ZERO_ERROR;\n    expect2(new DecimalFormat(\"##0.0####E0 'g-m/s^2'\", custom, status),\n           int32_t(0), \"0decimal0exponent0 g-m/s^2\", status);\n    status = U_ZERO_ERROR;\n    expect(new DecimalFormat(\"##0.0####E0 'g-m/s^2'\", custom, status),\n           1.0/3, \"333decimal333exponent minus 3 g-m/s^2\", status);\n    status = U_ZERO_ERROR;\n    expect2(new DecimalFormat(\"##0.0#### 'g-m/s^2'\", custom, status),\n           int32_t(0), \"0decimal0 g-m/s^2\", status);\n    status = U_ZERO_ERROR;\n    expect(new DecimalFormat(\"##0.0#### 'g-m/s^2'\", custom, status),\n           1.0/3, \"0decimal33333 g-m/s^2\", status);\n\n    UnicodeString zero((UChar32)0x10000);\n    UnicodeString one((UChar32)0x10001);\n    UnicodeString two((UChar32)0x10002);\n    UnicodeString five((UChar32)0x10005);\n    custom.setSymbol(DecimalFormatSymbols::kZeroDigitSymbol, zero);\n    custom.setSymbol(DecimalFormatSymbols::kOneDigitSymbol, one);\n    custom.setSymbol(DecimalFormatSymbols::kTwoDigitSymbol, two);\n    custom.setSymbol(DecimalFormatSymbols::kFiveDigitSymbol, five);\n    expStr = UnicodeString(\"\\\\U00010001decimal\\\\U00010002\\\\U00010005\\\\U00010000\", \"\");\n    expStr = expStr.unescape();\n    status = U_ZERO_ERROR;\n    expect2(new DecimalFormat(\"##0.000\", custom, status),\n           1.25, expStr, status);\n\n    custom.setSymbol(DecimalFormatSymbols::kZeroDigitSymbol, (UChar)0x30);\n    custom.setSymbol(DecimalFormatSymbols::kCurrencySymbol, \"units of money\");\n    custom.setSymbol(DecimalFormatSymbols::kMonetarySeparatorSymbol, \"money separator\");\n    patternStr = UNICODE_STRING_SIMPLE(\"0.00 \\\\u00A4' in your bank account'\");\n    patternStr = patternStr.unescape();\n    expStr = UnicodeString(\" minus 20money separator00 units of money in your bank account\", \"\");\n    status = U_ZERO_ERROR;\n    expect2(new DecimalFormat(patternStr, custom, status),\n           int32_t(-20), expStr, status);\n\n    custom.setSymbol(DecimalFormatSymbols::kPercentSymbol, \"percent\");\n    patternStr = \"'You''ve lost ' -0.00 %' of your money today'\";\n    patternStr = patternStr.unescape();\n    expStr = UnicodeString(\" minus You've lost   minus 2000decimal00 percent of your money today\", \"\");\n    status = U_ZERO_ERROR;\n    expect2(new DecimalFormat(patternStr, custom, status),\n           int32_t(-20), expStr, status);\n}\n\nvoid NumberFormatTest::TestCurrencyPatterns(void) {\n    int32_t i, locCount;\n    const Locale* locs = NumberFormat::getAvailableLocales(locCount);\n    for (i=0; i<locCount; ++i) {\n        UErrorCode ec = U_ZERO_ERROR;\n        NumberFormat* nf = NumberFormat::createCurrencyInstance(locs[i], ec);\n        if (U_FAILURE(ec)) {\n            errln(\"FAIL: Can't create NumberFormat(%s) - %s\", locs[i].getName(), u_errorName(ec));\n        } else {\n            // Make sure currency formats do not have a variable number\n            // of fraction digits\n            int32_t min = nf->getMinimumFractionDigits();\n            int32_t max = nf->getMaximumFractionDigits();\n            if (min != max) {\n                UnicodeString a, b;\n                nf->format(1.0, a);\n                nf->format(1.125, b);\n                errln((UnicodeString)\"FAIL: \" + locs[i].getName() +\n                      \" min fraction digits != max fraction digits; \"\n                      \"x 1.0 => \" + escape(a) +\n                      \"; x 1.125 => \" + escape(b));\n            }\n\n            // Make sure EURO currency formats have exactly 2 fraction digits\n            DecimalFormat* df = dynamic_cast<DecimalFormat*>(nf);\n            if (df != NULL) {\n                if (u_strcmp(EUR, df->getCurrency()) == 0) {\n                    if (min != 2 || max != 2) {\n                        UnicodeString a;\n                        nf->format(1.0, a);\n                        errln((UnicodeString)\"FAIL: \" + locs[i].getName() +\n                              \" is a EURO format but it does not have 2 fraction digits; \"\n                              \"x 1.0 => \" +\n                              escape(a));\n                    }\n                }\n            }\n        }\n        delete nf;\n    }\n}\n\nvoid NumberFormatTest::TestRegCurrency(void) {\n#if !UCONFIG_NO_SERVICE\n    UErrorCode status = U_ZERO_ERROR;\n    UChar USD[4];\n    ucurr_forLocale(\"en_US\", USD, 4, &status);\n    UChar YEN[4];\n    ucurr_forLocale(\"ja_JP\", YEN, 4, &status);\n    UChar TMP[4];\n    static const UChar QQQ[] = {0x51, 0x51, 0x51, 0};\n    if(U_FAILURE(status)) {\n        errcheckln(status, \"Unable to get currency for locale, error %s\", u_errorName(status));\n        return;\n    }\n\n    UCurrRegistryKey enkey = ucurr_register(YEN, \"en_US\", &status);\n    UCurrRegistryKey enUSEUROkey = ucurr_register(QQQ, \"en_US_EURO\", &status);\n\n    ucurr_forLocale(\"en_US\", TMP, 4, &status);\n    if (u_strcmp(YEN, TMP) != 0) {\n        errln(\"FAIL: didn't return YEN registered for en_US\");\n    }\n\n    ucurr_forLocale(\"en_US_EURO\", TMP, 4, &status);\n    if (u_strcmp(QQQ, TMP) != 0) {\n        errln(\"FAIL: didn't return QQQ for en_US_EURO\");\n    }\n\n    int32_t fallbackLen = ucurr_forLocale(\"en_XX_BAR\", TMP, 4, &status);\n    if (fallbackLen) {\n        errln(\"FAIL: tried to fallback en_XX_BAR\");\n    }\n    status = U_ZERO_ERROR; // reset\n\n    if (!ucurr_unregister(enkey, &status)) {\n        errln(\"FAIL: couldn't unregister enkey\");\n    }\n\n    ucurr_forLocale(\"en_US\", TMP, 4, &status);\n    if (u_strcmp(USD, TMP) != 0) {\n        errln(\"FAIL: didn't return USD for en_US after unregister of en_US\");\n    }\n    status = U_ZERO_ERROR; // reset\n\n    ucurr_forLocale(\"en_US_EURO\", TMP, 4, &status);\n    if (u_strcmp(QQQ, TMP) != 0) {\n        errln(\"FAIL: didn't return QQQ for en_US_EURO after unregister of en_US\");\n    }\n\n    ucurr_forLocale(\"en_US_BLAH\", TMP, 4, &status);\n    if (u_strcmp(USD, TMP) != 0) {\n        errln(\"FAIL: could not find USD for en_US_BLAH after unregister of en\");\n    }\n    status = U_ZERO_ERROR; // reset\n\n    if (!ucurr_unregister(enUSEUROkey, &status)) {\n        errln(\"FAIL: couldn't unregister enUSEUROkey\");\n    }\n\n    ucurr_forLocale(\"en_US_EURO\", TMP, 4, &status);\n    if (u_strcmp(EUR, TMP) != 0) {\n        errln(\"FAIL: didn't return EUR for en_US_EURO after unregister of en_US_EURO\");\n    }\n    status = U_ZERO_ERROR; // reset\n#endif\n}\n\nvoid NumberFormatTest::TestCurrencyNames(void) {\n    // Do a basic check of getName()\n    // USD { \"US$\", \"US Dollar\"            } // 04/04/1792-\n    UErrorCode ec = U_ZERO_ERROR;\n    static const UChar USD[] = {0x55, 0x53, 0x44, 0}; /*USD*/\n    static const UChar USX[] = {0x55, 0x53, 0x58, 0}; /*USX*/\n    static const UChar CAD[] = {0x43, 0x41, 0x44, 0}; /*CAD*/\n    static const UChar ITL[] = {0x49, 0x54, 0x4C, 0}; /*ITL*/\n    UBool isChoiceFormat;\n    int32_t len;\n    const UBool possibleDataError = TRUE;\n    // Warning: HARD-CODED LOCALE DATA in this test.  If it fails, CHECK\n    // THE LOCALE DATA before diving into the code.\n    assertEquals(\"USD.getName(SYMBOL_NAME, en)\",\n                 UnicodeString(\"$\"),\n                 UnicodeString(ucurr_getName(USD, \"en\",\n                                             UCURR_SYMBOL_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertEquals(\"USD.getName(NARROW_SYMBOL_NAME, en)\",\n                 UnicodeString(\"$\"),\n                 UnicodeString(ucurr_getName(USD, \"en\",\n                                             UCURR_NARROW_SYMBOL_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertEquals(\"USD.getName(LONG_NAME, en)\",\n                 UnicodeString(\"US Dollar\"),\n                 UnicodeString(ucurr_getName(USD, \"en\",\n                                             UCURR_LONG_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertEquals(\"CAD.getName(SYMBOL_NAME, en)\",\n                 UnicodeString(\"CA$\"),\n                 UnicodeString(ucurr_getName(CAD, \"en\",\n                                             UCURR_SYMBOL_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertEquals(\"CAD.getName(NARROW_SYMBOL_NAME, en)\",\n                 UnicodeString(\"$\"),\n                 UnicodeString(ucurr_getName(CAD, \"en\",\n                                             UCURR_NARROW_SYMBOL_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertEquals(\"CAD.getName(SYMBOL_NAME, en_CA)\",\n                 UnicodeString(\"$\"),\n                 UnicodeString(ucurr_getName(CAD, \"en_CA\",\n                                             UCURR_SYMBOL_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertEquals(\"USD.getName(SYMBOL_NAME, en_CA)\",\n                 UnicodeString(\"US$\"),\n                 UnicodeString(ucurr_getName(USD, \"en_CA\",\n                                             UCURR_SYMBOL_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertEquals(\"USD.getName(NARROW_SYMBOL_NAME, en_CA)\",\n                 UnicodeString(\"$\"),\n                 UnicodeString(ucurr_getName(USD, \"en_CA\",\n                                             UCURR_NARROW_SYMBOL_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertEquals(\"USD.getName(SYMBOL_NAME) in en_NZ\",\n                 UnicodeString(\"US$\"),\n                 UnicodeString(ucurr_getName(USD, \"en_NZ\",\n                                             UCURR_SYMBOL_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertEquals(\"CAD.getName(SYMBOL_NAME)\",\n                 UnicodeString(\"CA$\"),\n                 UnicodeString(ucurr_getName(CAD, \"en_NZ\",\n                                             UCURR_SYMBOL_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertEquals(\"USX.getName(SYMBOL_NAME)\",\n                 UnicodeString(\"USX\"),\n                 UnicodeString(ucurr_getName(USX, \"en_US\",\n                                             UCURR_SYMBOL_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertEquals(\"USX.getName(NARROW_SYMBOL_NAME)\",\n                 UnicodeString(\"USX\"),\n                 UnicodeString(ucurr_getName(USX, \"en_US\",\n                                             UCURR_NARROW_SYMBOL_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertEquals(\"USX.getName(LONG_NAME)\",\n                 UnicodeString(\"USX\"),\n                 UnicodeString(ucurr_getName(USX, \"en_US\",\n                                             UCURR_LONG_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertSuccess(\"ucurr_getName\", ec);\n\n    ec = U_ZERO_ERROR;\n\n    // Test that a default or fallback warning is being returned. JB 4239.\n    ucurr_getName(CAD, \"es_ES\", UCURR_LONG_NAME, &isChoiceFormat,\n                            &len, &ec);\n    assertTrue(\"ucurr_getName (es_ES fallback)\",\n                    U_USING_FALLBACK_WARNING == ec, TRUE, possibleDataError);\n\n    ucurr_getName(CAD, \"zh_TW\", UCURR_LONG_NAME, &isChoiceFormat,\n                            &len, &ec);\n    assertTrue(\"ucurr_getName (zh_TW fallback)\",\n                    U_USING_FALLBACK_WARNING == ec, TRUE, possibleDataError);\n\n    ucurr_getName(CAD, \"en_US\", UCURR_LONG_NAME, &isChoiceFormat,\n                            &len, &ec);\n    assertTrue(\"ucurr_getName (en_US default)\",\n                    U_USING_DEFAULT_WARNING == ec || U_USING_FALLBACK_WARNING == ec, TRUE);\n\n    ucurr_getName(CAD, \"ti\", UCURR_LONG_NAME, &isChoiceFormat,\n                            &len, &ec);\n    assertTrue(\"ucurr_getName (ti default)\",\n                    U_USING_DEFAULT_WARNING == ec, TRUE);\n\n    // Test that a default warning is being returned when falling back to root. JB 4536.\n    ucurr_getName(ITL, \"cy\", UCURR_LONG_NAME, &isChoiceFormat,\n                            &len, &ec);\n    assertTrue(\"ucurr_getName (cy default to root)\",\n                    U_USING_DEFAULT_WARNING == ec, TRUE);\n\n    // TODO add more tests later\n}\n\nvoid NumberFormatTest::TestCurrencyUnit(void){\n    UErrorCode ec = U_ZERO_ERROR;\n    static const UChar USD[]  = u\"USD\";\n    static const char USD8[]  =  \"USD\";\n    static const UChar BAD[]  = u\"???\";\n    static const UChar BAD2[] = u\"??A\";\n    static const UChar XXX[]  = u\"XXX\";\n    static const char XXX8[]  =  \"XXX\";\n    CurrencyUnit cu(USD, ec);\n    assertSuccess(\"CurrencyUnit\", ec);\n\n    assertEquals(\"getISOCurrency()\", USD, cu.getISOCurrency());\n    assertEquals(\"getSubtype()\", USD8, cu.getSubtype());\n\n    CurrencyUnit cu2(cu);\n    if (!(cu2 == cu)){\n        errln(\"CurrencyUnit copy constructed object should be same\");\n    }\n\n    CurrencyUnit * cu3 = (CurrencyUnit *)cu.clone();\n    if (!(*cu3 == cu)){\n        errln(\"CurrencyUnit cloned object should be same\");\n    }\n    CurrencyUnit bad(BAD, ec);\n    assertSuccess(\"CurrencyUnit\", ec);\n    if (cu.getIndex() == bad.getIndex()) {\n        errln(\"Indexes of different currencies should differ.\");\n    }\n    CurrencyUnit bad2(BAD2, ec);\n    assertSuccess(\"CurrencyUnit\", ec);\n    if (bad2.getIndex() != bad.getIndex()) {\n        errln(\"Indexes of unrecognized currencies should be the same.\");\n    }\n    if (bad == bad2) {\n        errln(\"Different unrecognized currencies should not be equal.\");\n    }\n    bad = bad2;\n    if (bad != bad2) {\n        errln(\"Currency unit assignment should be the same.\");\n    }\n    delete cu3;\n\n    // Test default constructor\n    CurrencyUnit def;\n    assertEquals(\"Default currency\", XXX, def.getISOCurrency());\n    assertEquals(\"Default currency as subtype\", XXX8, def.getSubtype());\n\n    // Test slicing\n    MeasureUnit sliced1 = cu;\n    MeasureUnit sliced2 = cu;\n    assertEquals(\"Subtype after slicing 1\", USD8, sliced1.getSubtype());\n    assertEquals(\"Subtype after slicing 2\", USD8, sliced2.getSubtype());\n    CurrencyUnit restored1(sliced1, ec);\n    CurrencyUnit restored2(sliced2, ec);\n    assertSuccess(\"Restoring from MeasureUnit\", ec);\n    assertEquals(\"Subtype after restoring 1\", USD8, restored1.getSubtype());\n    assertEquals(\"Subtype after restoring 2\", USD8, restored2.getSubtype());\n    assertEquals(\"ISO Code after restoring 1\", USD, restored1.getISOCurrency());\n    assertEquals(\"ISO Code after restoring 2\", USD, restored2.getISOCurrency());\n\n    // Test copy constructor failure\n    LocalPointer<MeasureUnit> meter(MeasureUnit::createMeter(ec));\n    assertSuccess(\"Creating meter\", ec);\n    CurrencyUnit failure(*meter, ec);\n    assertEquals(\"Copying from meter should fail\", ec, U_ILLEGAL_ARGUMENT_ERROR);\n    assertEquals(\"Copying should not give uninitialized ISO code\", u\"\", failure.getISOCurrency());\n}\n\nvoid NumberFormatTest::TestCurrencyAmount(void){\n    UErrorCode ec = U_ZERO_ERROR;\n    static const UChar USD[] = {85, 83, 68, 0}; /*USD*/\n    CurrencyAmount ca(9, USD, ec);\n    assertSuccess(\"CurrencyAmount\", ec);\n\n    CurrencyAmount ca2(ca);\n    if (!(ca2 == ca)){\n        errln(\"CurrencyAmount copy constructed object should be same\");\n    }\n\n    ca2=ca;\n    if (!(ca2 == ca)){\n        errln(\"CurrencyAmount assigned object should be same\");\n    }\n\n    CurrencyAmount *ca3 = (CurrencyAmount *)ca.clone();\n    if (!(*ca3 == ca)){\n        errln(\"CurrencyAmount cloned object should be same\");\n    }\n    delete ca3;\n}\n\nvoid NumberFormatTest::TestSymbolsWithBadLocale(void) {\n    Locale locDefault;\n    static const char *badLocales[] = {\n        // length < ULOC_FULLNAME_CAPACITY\n        \"x-crazy_ZZ_MY_SPECIAL_ADMINISTRATION_REGION_NEEDS_A_SPECIAL_VARIANT_WITH_A_REALLY_REALLY_REALLY_REALLY_REALLY_REALLY_REALLY_LONG_NAME\",\n\n        // length > ULOC_FULLNAME_CAPACITY\n        \"x-crazy_ZZ_MY_SPECIAL_ADMINISTRATION_REGION_NEEDS_A_SPECIAL_VARIANT_WITH_A_REALLY_REALLY_REALLY_REALLY_REALLY_REALLY_REALLY_REALLY_REALLY_REALLY_REALLY_LONG_NAME\"\n    }; // expect U_USING_DEFAULT_WARNING for both\n\n    unsigned int i;\n    for (i = 0; i < UPRV_LENGTHOF(badLocales); i++) {\n        const char *localeName = badLocales[i];\n        Locale locBad(localeName);\n        TEST_ASSERT_TRUE(!locBad.isBogus());\n        UErrorCode status = U_ZERO_ERROR;\n        UnicodeString intlCurrencySymbol((UChar)0xa4);\n\n        intlCurrencySymbol.append((UChar)0xa4);\n\n        logln(\"Current locale is %s\", Locale::getDefault().getName());\n        Locale::setDefault(locBad, status);\n        logln(\"Current locale is %s\", Locale::getDefault().getName());\n        DecimalFormatSymbols mySymbols(status);\n        if (status != U_USING_DEFAULT_WARNING) {\n            errln(\"DecimalFormatSymbols should return U_USING_DEFAULT_WARNING.\");\n        }\n        if (strcmp(mySymbols.getLocale().getName(), locBad.getName()) != 0) {\n            errln(\"DecimalFormatSymbols does not have the right locale.\", locBad.getName());\n        }\n        int symbolEnum = (int)DecimalFormatSymbols::kDecimalSeparatorSymbol;\n        for (; symbolEnum < (int)DecimalFormatSymbols::kFormatSymbolCount; symbolEnum++) {\n            UnicodeString symbolString = mySymbols.getSymbol((DecimalFormatSymbols::ENumberFormatSymbol)symbolEnum);\n            logln(UnicodeString(\"DecimalFormatSymbols[\") + symbolEnum + UnicodeString(\"] = \") + prettify(symbolString));\n            if (symbolString.length() == 0\n                && symbolEnum != (int)DecimalFormatSymbols::kGroupingSeparatorSymbol\n                && symbolEnum != (int)DecimalFormatSymbols::kMonetaryGroupingSeparatorSymbol)\n            {\n                errln(\"DecimalFormatSymbols has an empty string at index %d.\", symbolEnum);\n            }\n        }\n\n        status = U_ZERO_ERROR;\n        Locale::setDefault(locDefault, status);\n        logln(\"Current locale is %s\", Locale::getDefault().getName());\n    }\n}\n\n/**\n * Check that adoptDecimalFormatSymbols and setDecimalFormatSymbols\n * behave the same, except for memory ownership semantics. (No\n * version of this test on Java, since Java has only one method.)\n */\nvoid NumberFormatTest::TestAdoptDecimalFormatSymbols(void) {\n    UErrorCode ec = U_ZERO_ERROR;\n    DecimalFormatSymbols *sym = new DecimalFormatSymbols(Locale::getUS(), ec);\n    if (U_FAILURE(ec)) {\n        errcheckln(ec, \"Fail: DecimalFormatSymbols constructor - %s\", u_errorName(ec));\n        delete sym;\n        return;\n    }\n    UnicodeString pat(\" #,##0.00\");\n    pat.insert(0, (UChar)0x00A4);\n    DecimalFormat fmt(pat, sym, ec);\n    if (U_FAILURE(ec)) {\n        errln(\"Fail: DecimalFormat constructor\");\n        return;\n    }\n\n    UnicodeString str;\n    fmt.format(2350.75, str);\n    if (str == \"$ 2,350.75\") {\n        logln(str);\n    } else {\n        dataerrln(\"Fail: \" + str + \", expected $ 2,350.75\");\n    }\n\n    sym = new DecimalFormatSymbols(Locale::getUS(), ec);\n    if (U_FAILURE(ec)) {\n        errln(\"Fail: DecimalFormatSymbols constructor\");\n        delete sym;\n        return;\n    }\n    sym->setSymbol(DecimalFormatSymbols::kCurrencySymbol, \"Q\");\n    fmt.adoptDecimalFormatSymbols(sym);\n\n    str.truncate(0);\n    fmt.format(2350.75, str);\n    if (str == \"Q 2,350.75\") {\n        logln(str);\n    } else {\n        dataerrln(\"Fail: adoptDecimalFormatSymbols -> \" + str + \", expected Q 2,350.75\");\n    }\n\n    sym = new DecimalFormatSymbols(Locale::getUS(), ec);\n    if (U_FAILURE(ec)) {\n        errln(\"Fail: DecimalFormatSymbols constructor\");\n        delete sym;\n        return;\n    }\n    DecimalFormat fmt2(pat, sym, ec);\n    if (U_FAILURE(ec)) {\n        errln(\"Fail: DecimalFormat constructor\");\n        return;\n    }\n\n    DecimalFormatSymbols sym2(Locale::getUS(), ec);\n    if (U_FAILURE(ec)) {\n        errln(\"Fail: DecimalFormatSymbols constructor\");\n        return;\n    }\n    sym2.setSymbol(DecimalFormatSymbols::kCurrencySymbol, \"Q\");\n    fmt2.setDecimalFormatSymbols(sym2);\n\n    str.truncate(0);\n    fmt2.format(2350.75, str);\n    if (str == \"Q 2,350.75\") {\n        logln(str);\n    } else {\n        dataerrln(\"Fail: setDecimalFormatSymbols -> \" + str + \", expected Q 2,350.75\");\n    }\n}\n\nvoid NumberFormatTest::TestPerMill() {\n    UErrorCode ec = U_ZERO_ERROR;\n    UnicodeString str;\n    DecimalFormat fmt(ctou(\"###.###\\\\u2030\"), ec);\n    if (!assertSuccess(\"DecimalFormat ct\", ec)) return;\n    assertEquals(\"0.4857 x ###.###\\\\u2030\",\n                 ctou(\"485.7\\\\u2030\"), fmt.format(0.4857, str), true);\n\n    DecimalFormatSymbols sym(Locale::getUS(), ec);\n    if (!assertSuccess(\"\", ec, true, __FILE__, __LINE__)) {\n        return;\n    }\n    sym.setSymbol(DecimalFormatSymbols::kPerMillSymbol, ctou(\"m\"));\n    DecimalFormat fmt2(\"\", sym, ec);\n    if (!assertSuccess(\"\", ec, true, __FILE__, __LINE__)) {\n        return;\n    }\n    fmt2.applyLocalizedPattern(\"###.###m\", ec);\n    if (!assertSuccess(\"setup\", ec)) return;\n    str.truncate(0);\n    assertEquals(\"0.4857 x ###.###m\",\n                 \"485.7m\", fmt2.format(0.4857, str));\n}\n\n/**\n * Generic test for patterns that should be legal/illegal.\n */\nvoid NumberFormatTest::TestIllegalPatterns() {\n    // Test cases:\n    // Prefix with \"-:\" for illegal patterns\n    // Prefix with \"+:\" for legal patterns\n    const char* DATA[] = {\n        // Unquoted special characters in the suffix are illegal\n        \"-:000.000|###\",\n        \"+:000.000'|###'\",\n        0\n    };\n    for (int32_t i=0; DATA[i]; ++i) {\n        const char* pat=DATA[i];\n        UBool valid = (*pat) == '+';\n        pat += 2;\n        UErrorCode ec = U_ZERO_ERROR;\n        DecimalFormat fmt(pat, ec); // locale doesn't matter here\n        if (U_SUCCESS(ec) == valid) {\n            logln(\"Ok: pattern \\\"%s\\\": %s\",\n                  pat, u_errorName(ec));\n        } else {\n            errcheckln(ec, \"FAIL: pattern \\\"%s\\\" should have %s; got %s\",\n                  pat, (valid?\"succeeded\":\"failed\"),\n                  u_errorName(ec));\n        }\n    }\n}\n\n//----------------------------------------------------------------------\n\nstatic const char* KEYWORDS[] = {\n    /*0*/ \"ref=\", // <reference pattern to parse numbers>\n    /*1*/ \"loc=\", // <locale for formats>\n    /*2*/ \"f:\",   // <pattern or '-'> <number> <exp. string>\n    /*3*/ \"fp:\",  // <pattern or '-'> <number> <exp. string> <exp. number>\n    /*4*/ \"rt:\",  // <pattern or '-'> <(exp.) number> <(exp.) string>\n    /*5*/ \"p:\",   // <pattern or '-'> <string> <exp. number>\n    /*6*/ \"perr:\", // <pattern or '-'> <invalid string>\n    /*7*/ \"pat:\", // <pattern or '-'> <exp. toPattern or '-' or 'err'>\n    /*8*/ \"fpc:\", // <pattern or '-'> <curr.amt> <exp. string> <exp. curr.amt>\n    0\n};\n\n/**\n * Return an integer representing the next token from this\n * iterator.  The integer will be an index into the given list, or\n * -1 if there are no more tokens, or -2 if the token is not on\n * the list.\n */\nstatic int32_t keywordIndex(const UnicodeString& tok) {\n    for (int32_t i=0; KEYWORDS[i]!=0; ++i) {\n        if (tok==KEYWORDS[i]) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n/**\n * Parse a CurrencyAmount using the given NumberFormat, with\n * the 'delim' character separating the number and the currency.\n */\nstatic void parseCurrencyAmount(const UnicodeString& str,\n                                const NumberFormat& fmt,\n                                UChar delim,\n                                Formattable& result,\n                                UErrorCode& ec) {\n    UnicodeString num, cur;\n    int32_t i = str.indexOf(delim);\n    str.extractBetween(0, i, num);\n    str.extractBetween(i+1, INT32_MAX, cur);\n    Formattable n;\n    fmt.parse(num, n, ec);\n    result.adoptObject(new CurrencyAmount(n, cur.getTerminatedBuffer(), ec));\n}\n\nvoid NumberFormatTest::TestCases() {\n    UErrorCode ec = U_ZERO_ERROR;\n    TextFile reader(\"NumberFormatTestCases.txt\", \"UTF8\", ec);\n    if (U_FAILURE(ec)) {\n        dataerrln(\"Couldn't open NumberFormatTestCases.txt\");\n        return;\n    }\n    TokenIterator tokens(&reader);\n\n    Locale loc(\"en\", \"US\", \"\");\n    DecimalFormat *ref = 0, *fmt = 0;\n    MeasureFormat *mfmt = 0;\n    UnicodeString pat, tok, mloc, str, out, where, currAmt;\n    Formattable n;\n\n    for (;;) {\n        ec = U_ZERO_ERROR;\n        if (!tokens.next(tok, ec)) {\n            break;\n        }\n        where = UnicodeString(\"(\") + tokens.getLineNumber() + \") \";\n        int32_t cmd = keywordIndex(tok);\n        switch (cmd) {\n        case 0:\n            // ref= <reference pattern>\n            if (!tokens.next(tok, ec)) goto error;\n            delete ref;\n            ref = new DecimalFormat(tok,\n                      new DecimalFormatSymbols(Locale::getUS(), ec), ec);\n            if (U_FAILURE(ec)) {\n                dataerrln(\"Error constructing DecimalFormat\");\n                goto error;\n            }\n            break;\n        case 1:\n            // loc= <locale>\n            if (!tokens.next(tok, ec)) goto error;\n            loc = Locale::createFromName(CharString().appendInvariantChars(tok, ec).data());\n            break;\n        case 2: // f:\n        case 3: // fp:\n        case 4: // rt:\n        case 5: // p:\n            if (!tokens.next(tok, ec)) goto error;\n            if (tok != \"-\") {\n                pat = tok;\n                delete fmt;\n                fmt = new DecimalFormat(pat, new DecimalFormatSymbols(loc, ec), ec);\n                if (U_FAILURE(ec)) {\n                    errln(\"FAIL: \" + where + \"Pattern \\\"\" + pat + \"\\\": \" + u_errorName(ec));\n                    ec = U_ZERO_ERROR;\n                    if (!tokens.next(tok, ec)) goto error;\n                    if (!tokens.next(tok, ec)) goto error;\n                    if (cmd == 3) {\n                        if (!tokens.next(tok, ec)) goto error;\n                    }\n                    continue;\n                }\n            }\n            if (cmd == 2 || cmd == 3 || cmd == 4) {\n                // f: <pattern or '-'> <number> <exp. string>\n                // fp: <pattern or '-'> <number> <exp. string> <exp. number>\n                // rt: <pattern or '-'> <number> <string>\n                UnicodeString num;\n                if (!tokens.next(num, ec)) goto error;\n                if (!tokens.next(str, ec)) goto error;\n                ref->parse(num, n, ec);\n                assertSuccess(\"parse\", ec);\n                assertEquals(where + \"\\\"\" + pat + \"\\\".format(\" + num + \")\",\n                             str, fmt->format(n, out.remove(), ec));\n                assertSuccess(\"format\", ec);\n                if (cmd == 3) { // fp:\n                    if (!tokens.next(num, ec)) goto error;\n                    ref->parse(num, n, ec);\n                    assertSuccess(\"parse\", ec);\n                }\n                if (cmd != 2) { // != f:\n                    Formattable m;\n                    fmt->parse(str, m, ec);\n                    assertSuccess(\"parse\", ec);\n                    assertEquals(where + \"\\\"\" + pat + \"\\\".parse(\\\"\" + str + \"\\\")\",\n                                 n, m);\n                }\n            }\n            // p: <pattern or '-'> <string to parse> <exp. number>\n            else {\n                UnicodeString expstr;\n                if (!tokens.next(str, ec)) goto error;\n                if (!tokens.next(expstr, ec)) goto error;\n                Formattable exp, n;\n                ref->parse(expstr, exp, ec);\n                assertSuccess(\"parse\", ec);\n                fmt->parse(str, n, ec);\n                assertSuccess(\"parse\", ec);\n                assertEquals(where + \"\\\"\" + pat + \"\\\".parse(\\\"\" + str + \"\\\")\",\n                             exp, n);\n            }\n            break;\n        case 8: // fpc:\n            if (!tokens.next(tok, ec)) goto error;\n            if (tok != \"-\") {\n                mloc = tok;\n                delete mfmt;\n                mfmt = MeasureFormat::createCurrencyFormat(\n                    Locale::createFromName(\n                        CharString().appendInvariantChars(mloc, ec).data()), ec);\n                if (U_FAILURE(ec)) {\n                    errln(\"FAIL: \" + where + \"Loc \\\"\" + mloc + \"\\\": \" + u_errorName(ec));\n                    ec = U_ZERO_ERROR;\n                    if (!tokens.next(tok, ec)) goto error;\n                    if (!tokens.next(tok, ec)) goto error;\n                    if (!tokens.next(tok, ec)) goto error;\n                    continue;\n                }\n            } else if (mfmt == NULL) {\n                errln(\"FAIL: \" + where + \"Loc \\\"\" + mloc + \"\\\": skip case using previous locale, no valid MeasureFormat\");\n                if (!tokens.next(tok, ec)) goto error;\n                if (!tokens.next(tok, ec)) goto error;\n                if (!tokens.next(tok, ec)) goto error;\n                continue;\n            }\n            // fpc: <loc or '-'> <curr.amt> <exp. string> <exp. curr.amt>\n            if (!tokens.next(currAmt, ec)) goto error;\n            if (!tokens.next(str, ec)) goto error;\n            parseCurrencyAmount(currAmt, *ref, (UChar)0x2F/*'/'*/, n, ec);\n            if (assertSuccess(\"parseCurrencyAmount\", ec)) {\n                assertEquals(where + \"getCurrencyFormat(\" + mloc + \").format(\" + currAmt + \")\",\n                             str, mfmt->format(n, out.remove(), ec));\n                assertSuccess(\"format\", ec);\n            }\n            if (!tokens.next(currAmt, ec)) goto error;\n            parseCurrencyAmount(currAmt, *ref, (UChar)0x2F/*'/'*/, n, ec);\n            if (assertSuccess(\"parseCurrencyAmount\", ec)) {\n                Formattable m;\n\n                mfmt->parseObject(str, m, ec);\n                if (assertSuccess(\"parseCurrency\", ec)) {\n                    assertEquals(where + \"getCurrencyFormat(\" + mloc + \").parse(\\\"\" + str + \"\\\")\",\n                                 n, m);\n                } else {\n                    errln(\"FAIL: source \" + str);\n                }\n            }\n            break;\n        case 6:\n            // perr: <pattern or '-'> <invalid string>\n            errln(\"FAIL: Under construction\");\n            goto done;\n        case 7: {\n            // pat: <pattern> <exp. toPattern, or '-' or 'err'>\n            UnicodeString testpat;\n            UnicodeString exppat;\n            if (!tokens.next(testpat, ec)) goto error;\n            if (!tokens.next(exppat, ec)) goto error;\n            UBool err = exppat == \"err\";\n            UBool existingPat = FALSE;\n            if (testpat == \"-\") {\n                if (err) {\n                    errln(\"FAIL: \" + where + \"Invalid command \\\"pat: - err\\\"\");\n                    continue;\n                }\n                existingPat = TRUE;\n                testpat = pat;\n            }\n            if (exppat == \"-\") exppat = testpat;\n            DecimalFormat* f = 0;\n            UErrorCode ec2 = U_ZERO_ERROR;\n            if (existingPat) {\n                f = fmt;\n            } else {\n                f = new DecimalFormat(testpat, ec2);\n            }\n            if (U_SUCCESS(ec2)) {\n                if (err) {\n                    errln(\"FAIL: \" + where + \"Invalid pattern \\\"\" + testpat +\n                          \"\\\" was accepted\");\n                } else {\n                    UnicodeString pat2;\n                    assertEquals(where + \"\\\"\" + testpat + \"\\\".toPattern()\",\n                                 exppat, f->toPattern(pat2));\n                }\n            } else {\n                if (err) {\n                    logln(\"Ok: \" + where + \"Invalid pattern \\\"\" + testpat +\n                          \"\\\" failed: \" + u_errorName(ec2));\n                } else {\n                    errln(\"FAIL: \" + where + \"Valid pattern \\\"\" + testpat +\n                          \"\\\" failed: \" + u_errorName(ec2));\n                }\n            }\n            if (!existingPat) delete f;\n            } break;\n        case -1:\n            errln(\"FAIL: \" + where + \"Unknown command \\\"\" + tok + \"\\\"\");\n            goto done;\n        }\n    }\n    goto done;\n\n error:\n    if (U_SUCCESS(ec)) {\n        errln(\"FAIL: Unexpected EOF\");\n    } else {\n        errcheckln(ec, \"FAIL: \" + where + \"Unexpected \" + u_errorName(ec));\n    }\n\n done:\n    delete mfmt;\n    delete fmt;\n    delete ref;\n}\n\n\n//----------------------------------------------------------------------\n// Support methods\n//----------------------------------------------------------------------\n\nUBool NumberFormatTest::equalValue(const Formattable& a, const Formattable& b) {\n    if (a.getType() == b.getType()) {\n        return a == b;\n    }\n\n    if (a.getType() == Formattable::kLong) {\n        if (b.getType() == Formattable::kInt64) {\n            return a.getLong() == b.getLong();\n        } else if (b.getType() == Formattable::kDouble) {\n            return (double) a.getLong() == b.getDouble(); // TODO check use of double instead of long\n        }\n    } else if (a.getType() == Formattable::kDouble) {\n        if (b.getType() == Formattable::kLong) {\n            return a.getDouble() == (double) b.getLong();\n        } else if (b.getType() == Formattable::kInt64) {\n            return a.getDouble() == (double)b.getInt64();\n        }\n    } else if (a.getType() == Formattable::kInt64) {\n        if (b.getType() == Formattable::kLong) {\n                return a.getInt64() == (int64_t)b.getLong();\n        } else if (b.getType() == Formattable::kDouble) {\n            return a.getInt64() == (int64_t)b.getDouble();\n        }\n    }\n    return FALSE;\n}\n\nvoid NumberFormatTest::expect3(NumberFormat& fmt, const Formattable& n, const UnicodeString& str) {\n    // Don't round-trip format test, since we explicitly do it\n    expect_rbnf(fmt, n, str, FALSE);\n    expect_rbnf(fmt, str, n);\n}\n\nvoid NumberFormatTest::expect2(NumberFormat& fmt, const Formattable& n, const UnicodeString& str) {\n    // Don't round-trip format test, since we explicitly do it\n    expect(fmt, n, str, FALSE);\n    expect(fmt, str, n);\n}\n\nvoid NumberFormatTest::expect2(NumberFormat* fmt, const Formattable& n,\n                               const UnicodeString& exp,\n                               UErrorCode status) {\n    if (fmt == NULL || U_FAILURE(status)) {\n        dataerrln(\"FAIL: NumberFormat constructor\");\n    } else {\n        expect2(*fmt, n, exp);\n    }\n    delete fmt;\n}\n\nvoid NumberFormatTest::expect(NumberFormat& fmt, const UnicodeString& str, const Formattable& n) {\n    UErrorCode status = U_ZERO_ERROR;\n    Formattable num;\n    fmt.parse(str, num, status);\n    if (U_FAILURE(status)) {\n        dataerrln(UnicodeString(\"FAIL: Parse failed for \\\"\") + str + \"\\\" - \" + u_errorName(status));\n        return;\n    }\n    UnicodeString pat;\n    ((DecimalFormat*) &fmt)->toPattern(pat);\n    if (equalValue(num, n)) {\n        logln(UnicodeString(\"Ok   \\\"\") + str + \"\\\" x \" +\n              pat + \" = \" +\n              toString(num));\n    } else {\n        dataerrln(UnicodeString(\"FAIL \\\"\") + str + \"\\\" x \" +\n              pat + \" = \" +\n              toString(num) + \", expected \" + toString(n));\n    }\n}\n\nvoid NumberFormatTest::expect_rbnf(NumberFormat& fmt, const UnicodeString& str, const Formattable& n) {\n    UErrorCode status = U_ZERO_ERROR;\n    Formattable num;\n    fmt.parse(str, num, status);\n    if (U_FAILURE(status)) {\n        errln(UnicodeString(\"FAIL: Parse failed for \\\"\") + str + \"\\\"\");\n        return;\n    }\n    if (equalValue(num, n)) {\n        logln(UnicodeString(\"Ok   \\\"\") + str + \" = \" +\n              toString(num));\n    } else {\n        errln(UnicodeString(\"FAIL \\\"\") + str + \" = \" +\n              toString(num) + \", expected \" + toString(n));\n    }\n}\n\nvoid NumberFormatTest::expect_rbnf(NumberFormat& fmt, const Formattable& n,\n                              const UnicodeString& exp, UBool rt) {\n    UnicodeString saw;\n    FieldPosition pos;\n    UErrorCode status = U_ZERO_ERROR;\n    fmt.format(n, saw, pos, status);\n    CHECK(status, \"NumberFormat::format\");\n    if (saw == exp) {\n        logln(UnicodeString(\"Ok   \") + toString(n) +\n              \" = \\\"\" +\n              escape(saw) + \"\\\"\");\n        // We should be able to round-trip the formatted string =>\n        // number => string (but not the other way around: number\n        // => string => number2, might have number2 != number):\n        if (rt) {\n            Formattable n2;\n            fmt.parse(exp, n2, status);\n            if (U_FAILURE(status)) {\n                errln(UnicodeString(\"FAIL: Parse failed for \\\"\") + exp + \"\\\"\");\n                return;\n            }\n            UnicodeString saw2;\n            fmt.format(n2, saw2, pos, status);\n            CHECK(status, \"NumberFormat::format\");\n            if (saw2 != exp) {\n                errln((UnicodeString)\"FAIL \\\"\" + exp + \"\\\" => \" + toString(n2) +\n                      \" => \\\"\" + saw2 + \"\\\"\");\n            }\n        }\n    } else {\n        errln(UnicodeString(\"FAIL \") + toString(n) +\n              \" = \\\"\" +\n              escape(saw) + \"\\\", expected \\\"\" + exp + \"\\\"\");\n    }\n}\n\nvoid NumberFormatTest::expect(NumberFormat& fmt, const Formattable& n,\n                              const UnicodeString& exp, UBool rt) {\n    UnicodeString saw;\n    FieldPosition pos;\n    UErrorCode status = U_ZERO_ERROR;\n    fmt.format(n, saw, pos, status);\n    CHECK(status, \"NumberFormat::format\");\n    UnicodeString pat;\n    ((DecimalFormat*) &fmt)->toPattern(pat);\n    if (saw == exp) {\n        logln(UnicodeString(\"Ok   \") + toString(n) + \" x \" +\n              escape(pat) + \" = \\\"\" +\n              escape(saw) + \"\\\"\");\n        // We should be able to round-trip the formatted string =>\n        // number => string (but not the other way around: number\n        // => string => number2, might have number2 != number):\n        if (rt) {\n            Formattable n2;\n            fmt.parse(exp, n2, status);\n            if (U_FAILURE(status)) {\n                errln(UnicodeString(\"FAIL: Parse failed for \\\"\") + exp + \"\\\" - \" + u_errorName(status));\n                return;\n            }\n            UnicodeString saw2;\n            fmt.format(n2, saw2, pos, status);\n            CHECK(status, \"NumberFormat::format\");\n            if (saw2 != exp) {\n                errln((UnicodeString)\"FAIL \\\"\" + exp + \"\\\" => \" + toString(n2) +\n                      \" => \\\"\" + saw2 + \"\\\"\");\n            }\n        }\n    } else {\n        dataerrln(UnicodeString(\"FAIL \") + toString(n) + \" x \" +\n              escape(pat) + \" = \\\"\" +\n              escape(saw) + \"\\\", expected \\\"\" + exp + \"\\\"\");\n    }\n}\n\nvoid NumberFormatTest::expect(NumberFormat* fmt, const Formattable& n,\n                              const UnicodeString& exp, UBool rt,\n                              UErrorCode status) {\n    if (fmt == NULL || U_FAILURE(status)) {\n        dataerrln(\"FAIL: NumberFormat constructor\");\n    } else {\n        expect(*fmt, n, exp, rt);\n    }\n    delete fmt;\n}\n\nvoid NumberFormatTest::expectCurrency(NumberFormat& nf, const Locale& locale,\n                                      double value, const UnicodeString& string) {\n    UErrorCode ec = U_ZERO_ERROR;\n    DecimalFormat& fmt = * (DecimalFormat*) &nf;\n    const UChar DEFAULT_CURR[] = {45/*-*/,0};\n    UChar curr[4];\n    u_strcpy(curr, DEFAULT_CURR);\n    if (*locale.getLanguage() != 0) {\n        ucurr_forLocale(locale.getName(), curr, 4, &ec);\n        assertSuccess(\"ucurr_forLocale\", ec);\n        fmt.setCurrency(curr, ec);\n        assertSuccess(\"DecimalFormat::setCurrency\", ec);\n        fmt.setCurrency(curr); //Deprecated variant, for coverage only\n    }\n    UnicodeString s;\n    fmt.format(value, s);\n    s.findAndReplace((UChar32)0x00A0, (UChar32)0x0020);\n\n    // Default display of the number yields \"1234.5599999999999\"\n    // instead of \"1234.56\".  Use a formatter to fix this.\n    NumberFormat* f =\n        NumberFormat::createInstance(Locale::getUS(), ec);\n    UnicodeString v;\n    if (U_FAILURE(ec)) {\n        // Oops; bad formatter.  Use default op+= display.\n        v = (UnicodeString)\"\" + value;\n    } else {\n        f->setMaximumFractionDigits(4);\n        f->setGroupingUsed(FALSE);\n        f->format(value, v);\n    }\n    delete f;\n\n    if (s == string) {\n        logln((UnicodeString)\"Ok: \" + v + \" x \" + curr + \" => \" + prettify(s));\n    } else {\n        errln((UnicodeString)\"FAIL: \" + v + \" x \" + curr + \" => \" + prettify(s) +\n              \", expected \" + prettify(string));\n    }\n}\n\nvoid NumberFormatTest::expectPat(DecimalFormat& fmt, const UnicodeString& exp) {\n    UnicodeString pat;\n    fmt.toPattern(pat);\n    if (pat == exp) {\n        logln(UnicodeString(\"Ok   \\\"\") + pat + \"\\\"\");\n    } else {\n        errln(UnicodeString(\"FAIL \\\"\") + pat + \"\\\", expected \\\"\" + exp + \"\\\"\");\n    }\n}\n\nvoid NumberFormatTest::expectPad(DecimalFormat& fmt, const UnicodeString& pat,\n                                 int32_t pos) {\n    expectPad(fmt, pat, pos, 0, (UnicodeString)\"\");\n}\nvoid NumberFormatTest::expectPad(DecimalFormat& fmt, const UnicodeString& pat,\n                                 int32_t pos, int32_t width, UChar pad) {\n    expectPad(fmt, pat, pos, width, UnicodeString(pad));\n}\nvoid NumberFormatTest::expectPad(DecimalFormat& fmt, const UnicodeString& pat,\n                                 int32_t pos, int32_t width, const UnicodeString& pad) {\n    int32_t apos = 0, awidth = 0;\n    UnicodeString apadStr;\n    UErrorCode status = U_ZERO_ERROR;\n    fmt.applyPattern(pat, status);\n    if (U_SUCCESS(status)) {\n        apos = fmt.getPadPosition();\n        awidth = fmt.getFormatWidth();\n        apadStr=fmt.getPadCharacterString();\n    } else {\n        apos = -1;\n        awidth = width;\n        apadStr = pad;\n    }\n    if (apos == pos && awidth == width && apadStr == pad) {\n        UnicodeString infoStr;\n        if (pos == ILLEGAL) {\n            infoStr = UnicodeString(\" width=\", \"\") + awidth + UnicodeString(\" pad=\", \"\") + apadStr;\n        }\n        logln(UnicodeString(\"Ok   \\\"\") + pat + \"\\\" pos=\" + apos + infoStr);\n    } else {\n        errln(UnicodeString(\"FAIL \\\"\") + pat + \"\\\" pos=\" + apos +\n              \" width=\" + awidth + \" pad=\" + apadStr +\n              \", expected \" + pos + \" \" + width + \" \" + pad);\n    }\n}\n\n// This test is flaky b/c the symbols for CNY and JPY are equivalent in this locale  - FIXME\nvoid NumberFormatTest::TestCompatibleCurrencies() {\n/*\n    static const UChar JPY[] = {0x4A, 0x50, 0x59, 0};\n    static const UChar CNY[] = {0x43, 0x4E, 0x59, 0};\n    UErrorCode status = U_ZERO_ERROR;\n    LocalPointer<NumberFormat> fmt(\n        NumberFormat::createCurrencyInstance(Locale::getUS(), status));\n    if (U_FAILURE(status)) {\n        errln(\"Could not create number format instance.\");\n        return;\n    }\n    logln(\"%s:%d - testing parse of halfwidth yen sign\\n\", __FILE__, __LINE__);\n    expectParseCurrency(*fmt, JPY, 1235,  \"\\\\u00A51,235\");\n    logln(\"%s:%d - testing parse of fullwidth yen sign\\n\", __FILE__, __LINE__);\n    expectParseCurrency(*fmt, JPY, 1235,  \"\\\\uFFE51,235\");\n    logln(\"%s:%d - testing parse of halfwidth yen sign\\n\", __FILE__, __LINE__);\n    expectParseCurrency(*fmt, CNY, 1235,  \"CN\\\\u00A51,235\");\n\n    LocalPointer<NumberFormat> fmtTW(\n        NumberFormat::createCurrencyInstance(Locale::getTaiwan(), status));\n\n    logln(\"%s:%d - testing parse of halfwidth yen sign in TW\\n\", __FILE__, __LINE__);\n    expectParseCurrency(*fmtTW, CNY, 1235,  \"\\\\u00A51,235\");\n    logln(\"%s:%d - testing parse of fullwidth yen sign in TW\\n\", __FILE__, __LINE__);\n    expectParseCurrency(*fmtTW, CNY, 1235,  \"\\\\uFFE51,235\");\n\n    LocalPointer<NumberFormat> fmtJP(\n        NumberFormat::createCurrencyInstance(Locale::getJapan(), status));\n\n    logln(\"%s:%d - testing parse of halfwidth yen sign in JP\\n\", __FILE__, __LINE__);\n    expectParseCurrency(*fmtJP, JPY, 1235,  \"\\\\u00A51,235\");\n    logln(\"%s:%d - testing parse of fullwidth yen sign in JP\\n\", __FILE__, __LINE__);\n    expectParseCurrency(*fmtJP, JPY, 1235,  \"\\\\uFFE51,235\");\n\n    // more..\n*/\n}\n\nvoid NumberFormatTest::expectParseCurrency(const NumberFormat &fmt, const UChar* currency, double amount, const char *text) {\n    ParsePosition ppos;\n    UnicodeString utext = ctou(text);\n    LocalPointer<CurrencyAmount> currencyAmount(fmt.parseCurrency(utext, ppos));\n    if (!ppos.getIndex()) {\n        errln(UnicodeString(\"Parse of \") + utext + \" should have succeeded.\");\n        return;\n    }\n    UErrorCode status = U_ZERO_ERROR;\n\n    char theInfo[100];\n    sprintf(theInfo, \"For locale %s, string \\\"%s\\\", currency \",\n            fmt.getLocale(ULOC_ACTUAL_LOCALE, status).getBaseName(),\n            text);\n    u_austrcpy(theInfo+uprv_strlen(theInfo), currency);\n\n    char theOperation[100];\n\n    uprv_strcpy(theOperation, theInfo);\n    uprv_strcat(theOperation, \", check amount:\");\n    assertTrue(theOperation, amount ==  currencyAmount->getNumber().getDouble(status));\n\n    uprv_strcpy(theOperation, theInfo);\n    uprv_strcat(theOperation, \", check currency:\");\n    assertEquals(theOperation, currency, currencyAmount->getISOCurrency());\n}\n\n\nvoid NumberFormatTest::TestJB3832(){\n    const char* localeID = \"pt_PT@currency=PTE\";\n    Locale loc(localeID);\n    UErrorCode status = U_ZERO_ERROR;\n    UnicodeString expected(CharsToUnicodeString(\"1,150$50\\\\u00A0\\\\u200B\")); // per cldrbug 7670\n    UnicodeString s;\n    NumberFormat* currencyFmt = NumberFormat::createCurrencyInstance(loc, status);\n    if(U_FAILURE(status)){\n        dataerrln(\"Could not create currency formatter for locale %s - %s\", localeID, u_errorName(status));\n        return;\n    }\n    currencyFmt->format(1150.50, s);\n    if(s!=expected){\n        errln(UnicodeString(\"FAIL: Expected: \")+expected\n                + UnicodeString(\" Got: \") + s\n                + UnicodeString( \" for locale: \")+ UnicodeString(localeID) );\n    }\n    if (U_FAILURE(status)){\n        errln(\"FAIL: Status %s\", u_errorName(status));\n    }\n    delete currencyFmt;\n}\n\nvoid NumberFormatTest::TestHost()\n{\n#if U_PLATFORM_USES_ONLY_WIN32_API\n    Win32NumberTest::testLocales(this);\n#endif\n    Locale loc(\"en_US@compat=host\");\n    for (UNumberFormatStyle k = UNUM_DECIMAL;\n         k < UNUM_FORMAT_STYLE_COUNT; k = (UNumberFormatStyle)(k+1)) {\n        UErrorCode status = U_ZERO_ERROR;\n        LocalPointer<NumberFormat> full(NumberFormat::createInstance(loc, k, status));\n        if (!NumberFormat::isStyleSupported(k)) {\n            if (status != U_UNSUPPORTED_ERROR) {\n                errln(\"FAIL: expected style %d to be unsupported - %s\",\n                      k, u_errorName(status));\n            }\n            continue;\n        }\n        if (full.isNull() || U_FAILURE(status)) {\n            dataerrln(\"FAIL: Can't create number instance of style %d for host - %s\",\n                      k, u_errorName(status));\n            return;\n        }\n        UnicodeString result1;\n        Formattable number(10.00);\n        full->format(number, result1, status);\n        if (U_FAILURE(status)) {\n            errln(\"FAIL: Can't format for host\");\n            return;\n        }\n        Formattable formattable;\n        full->parse(result1, formattable, status);\n        if (U_FAILURE(status)) {\n            errln(\"FAIL: Can't parse for host\");\n            return;\n        }\n    }\n}\n\nvoid NumberFormatTest::TestHostClone()\n{\n    /*\n    Verify that a cloned formatter gives the same results\n    and is useable after the original has been deleted.\n    */\n    // This is mainly important on Windows.\n    UErrorCode status = U_ZERO_ERROR;\n    Locale loc(\"en_US@compat=host\");\n    UDate now = Calendar::getNow();\n    NumberFormat *full = NumberFormat::createInstance(loc, status);\n    if (full == NULL || U_FAILURE(status)) {\n        dataerrln(\"FAIL: Can't create NumberFormat date instance - %s\", u_errorName(status));\n        return;\n    }\n    UnicodeString result1;\n    full->format(now, result1, status);\n    Format *fullClone = full->clone();\n    delete full;\n    full = NULL;\n\n    UnicodeString result2;\n    fullClone->format(now, result2, status);\n    if (U_FAILURE(status)) {\n        errln(\"FAIL: format failure.\");\n    }\n    if (result1 != result2) {\n        errln(\"FAIL: Clone returned different result from non-clone.\");\n    }\n    delete fullClone;\n}\n\nvoid NumberFormatTest::TestCurrencyFormat()\n{\n    // This test is here to increase code coverage.\n    UErrorCode status = U_ZERO_ERROR;\n    MeasureFormat *cloneObj;\n    UnicodeString str;\n    Formattable toFormat, result;\n    static const UChar ISO_CODE[4] = {0x0047, 0x0042, 0x0050, 0};\n\n    Locale  saveDefaultLocale = Locale::getDefault();\n    Locale::setDefault( Locale::getUK(), status );\n    if (U_FAILURE(status)) {\n        errln(\"couldn't set default Locale!\");\n        return;\n    }\n\n    MeasureFormat *measureObj = MeasureFormat::createCurrencyFormat(status);\n    Locale::setDefault( saveDefaultLocale, status );\n    if (U_FAILURE(status)){\n        dataerrln(\"FAIL: Status %s\", u_errorName(status));\n        return;\n    }\n    cloneObj = (MeasureFormat *)measureObj->clone();\n    if (cloneObj == NULL) {\n        errln(\"Clone doesn't work\");\n        return;\n    }\n    toFormat.adoptObject(new CurrencyAmount(1234.56, ISO_CODE, status));\n    measureObj->format(toFormat, str, status);\n    measureObj->parseObject(str, result, status);\n    if (U_FAILURE(status)){\n        errln(\"FAIL: Status %s\", u_errorName(status));\n    }\n    if (result != toFormat) {\n        errln(\"measureObj does not round trip. Formatted string was \\\"\" + str + \"\\\" Got: \" + toString(result) + \" Expected: \" + toString(toFormat));\n    }\n    status = U_ZERO_ERROR;\n    str.truncate(0);\n    cloneObj->format(toFormat, str, status);\n    cloneObj->parseObject(str, result, status);\n    if (U_FAILURE(status)){\n        errln(\"FAIL: Status %s\", u_errorName(status));\n    }\n    if (result != toFormat) {\n        errln(\"Clone does not round trip. Formatted string was \\\"\" + str + \"\\\" Got: \" + toString(result) + \" Expected: \" + toString(toFormat));\n    }\n    if (*measureObj != *cloneObj) {\n        errln(\"Cloned object is not equal to the original object\");\n    }\n    delete measureObj;\n    delete cloneObj;\n\n    status = U_USELESS_COLLATOR_ERROR;\n    if (MeasureFormat::createCurrencyFormat(status) != NULL) {\n        errln(\"createCurrencyFormat should have returned NULL.\");\n    }\n}\n\n/* Port of ICU4J rounding test. */\nvoid NumberFormatTest::TestRounding() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat *df = (DecimalFormat*)NumberFormat::createCurrencyInstance(Locale::getEnglish(), status);\n\n    if (U_FAILURE(status)) {\n        dataerrln(\"Unable to create decimal formatter. - %s\", u_errorName(status));\n        return;\n    }\n\n    int roundingIncrements[]={1, 2, 5, 20, 50, 100};\n    int testValues[]={0, 300};\n\n    for (int j=0; j<2; j++) {\n        for (int mode=DecimalFormat::kRoundUp;mode<DecimalFormat::kRoundHalfEven;mode++) {\n            df->setRoundingMode((DecimalFormat::ERoundingMode)mode);\n            for (int increment=0; increment<6; increment++) {\n                double base=testValues[j];\n                double rInc=roundingIncrements[increment];\n                checkRounding(df, base, 20, rInc);\n                rInc=1.000000000/rInc;\n                checkRounding(df, base, 20, rInc);\n            }\n        }\n    }\n    delete df;\n}\n\nvoid NumberFormatTest::TestRoundingPattern() {\n    UErrorCode status = U_ZERO_ERROR;\n    struct {\n        UnicodeString  pattern;\n        double        testCase;\n        UnicodeString expected;\n    } tests[] = {\n            { (UnicodeString)\"##0.65\", 1.234, (UnicodeString)\"1.30\" },\n            { (UnicodeString)\"#50\",    1230,  (UnicodeString)\"1250\" }\n    };\n    int32_t numOfTests = UPRV_LENGTHOF(tests);\n    UnicodeString result;\n\n    DecimalFormat *df = (DecimalFormat*)NumberFormat::createCurrencyInstance(Locale::getEnglish(), status);\n    if (U_FAILURE(status)) {\n        dataerrln(\"Unable to create decimal formatter. - %s\", u_errorName(status));\n        return;\n    }\n\n    for (int32_t i = 0; i < numOfTests; i++) {\n        result.remove();\n\n        df->applyPattern(tests[i].pattern, status);\n        if (U_FAILURE(status)) {\n            errln(\"Unable to apply pattern to decimal formatter. - %s\", u_errorName(status));\n        }\n\n        df->format(tests[i].testCase, result);\n\n        if (result != tests[i].expected) {\n            errln(\"String Pattern Rounding Test Failed: Pattern: \\\"\" + tests[i].pattern + \"\\\" Number: \" + tests[i].testCase + \" - Got: \" + result + \" Expected: \" + tests[i].expected);\n        }\n    }\n\n    delete df;\n}\n\nvoid NumberFormatTest::checkRounding(DecimalFormat* df, double base, int iterations, double increment) {\n    df->setRoundingIncrement(increment);\n    double lastParsed=INT32_MIN; //Intger.MIN_VALUE\n    for (int i=-iterations; i<=iterations;i++) {\n        double iValue=base+(increment*(i*0.1));\n        double smallIncrement=0.00000001;\n        if (iValue!=0) {\n            smallIncrement*=iValue;\n        }\n        //we not only test the value, but some values in a small range around it\n        lastParsed=checkRound(df, iValue-smallIncrement, lastParsed);\n        lastParsed=checkRound(df, iValue, lastParsed);\n        lastParsed=checkRound(df, iValue+smallIncrement, lastParsed);\n    }\n}\n\ndouble NumberFormatTest::checkRound(DecimalFormat* df, double iValue, double lastParsed) {\n    UErrorCode status=U_ZERO_ERROR;\n    UnicodeString formattedDecimal;\n    double parsed;\n    Formattable result;\n    df->format(iValue, formattedDecimal, status);\n\n    if (U_FAILURE(status)) {\n        errln(\"Error formatting number.\");\n    }\n\n    df->parse(formattedDecimal, result, status);\n\n    if (U_FAILURE(status)) {\n        errln(\"Error parsing number.\");\n    }\n\n    parsed=result.getDouble();\n\n    if (lastParsed>parsed) {\n        errln(\"Rounding wrong direction! %d > %d\", lastParsed, parsed);\n    }\n\n    return lastParsed;\n}\n\nvoid NumberFormatTest::TestNonpositiveMultiplier() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols US(Locale::getUS(), status);\n    CHECK(status, \"DecimalFormatSymbols constructor\");\n    DecimalFormat df(UnicodeString(\"0\"), US, status);\n    CHECK(status, \"DecimalFormat(0)\");\n\n    // test zero multiplier\n\n    int32_t mult = df.getMultiplier();\n    df.setMultiplier(0);\n    if (df.getMultiplier() != mult) {\n        errln(\"DecimalFormat.setMultiplier(0) did not ignore its zero input\");\n    }\n\n    // test negative multiplier\n\n    df.setMultiplier(-1);\n    if (df.getMultiplier() != -1) {\n        errln(\"DecimalFormat.setMultiplier(-1) ignored its negative input\");\n        return;\n    }\n\n    expect(df, \"1122.123\", -1122.123);\n    expect(df, \"-1122.123\", 1122.123);\n    expect(df, \"1.2\", -1.2);\n    expect(df, \"-1.2\", 1.2);\n\n    // Note:  the tests with the final parameter of FALSE will not round trip.\n    //        The initial numeric value will format correctly, after the multiplier.\n    //        Parsing the formatted text will be out-of-range for an int64, however.\n    //        The expect() function could be modified to detect this and fall back\n    //        to looking at the decimal parsed value, but it doesn't.\n    expect(df, U_INT64_MIN,    \"9223372036854775808\", FALSE);\n    expect(df, U_INT64_MIN+1,  \"9223372036854775807\");\n    expect(df, (int64_t)-123,                  \"123\");\n    expect(df, (int64_t)123,                  \"-123\");\n    expect(df, U_INT64_MAX-1, \"-9223372036854775806\");\n    expect(df, U_INT64_MAX,   \"-9223372036854775807\");\n\n    df.setMultiplier(-2);\n    expect(df, -(U_INT64_MIN/2)-1, \"-9223372036854775806\");\n    expect(df, -(U_INT64_MIN/2),   \"-9223372036854775808\");\n    expect(df, -(U_INT64_MIN/2)+1, \"-9223372036854775810\", FALSE);\n\n    df.setMultiplier(-7);\n    expect(df, -(U_INT64_MAX/7)-1, \"9223372036854775814\", FALSE);\n    expect(df, -(U_INT64_MAX/7),   \"9223372036854775807\");\n    expect(df, -(U_INT64_MAX/7)+1, \"9223372036854775800\");\n\n    // TODO: uncomment (and fix up) all the following int64_t tests once BigInteger is ported\n    // (right now the big numbers get turned into doubles and lose tons of accuracy)\n    //expect2(df, U_INT64_MAX, Int64ToUnicodeString(-U_INT64_MAX));\n    //expect2(df, U_INT64_MIN, UnicodeString(Int64ToUnicodeString(U_INT64_MIN), 1));\n    //expect2(df, U_INT64_MAX / 2, Int64ToUnicodeString(-(U_INT64_MAX / 2)));\n    //expect2(df, U_INT64_MIN / 2, Int64ToUnicodeString(-(U_INT64_MIN / 2)));\n\n    // TODO: uncomment (and fix up) once BigDecimal is ported and DecimalFormat can handle it\n    //expect2(df, BigDecimal.valueOf(Long.MAX_VALUE), BigDecimal.valueOf(Long.MAX_VALUE).negate().toString());\n    //expect2(df, BigDecimal.valueOf(Long.MIN_VALUE), BigDecimal.valueOf(Long.MIN_VALUE).negate().toString());\n    //expect2(df, java.math.BigDecimal.valueOf(Long.MAX_VALUE), java.math.BigDecimal.valueOf(Long.MAX_VALUE).negate().toString());\n    //expect2(df, java.math.BigDecimal.valueOf(Long.MIN_VALUE), java.math.BigDecimal.valueOf(Long.MIN_VALUE).negate().toString());\n}\n\ntypedef struct {\n    const char * stringToParse;\n    int          parsedPos;\n    int          errorIndex;\n    UBool        lenient;\n} TestSpaceParsingItem;\n\nvoid\nNumberFormatTest::TestSpaceParsing() {\n    // the data are:\n    // the string to be parsed, parsed position, parsed error index\n    const TestSpaceParsingItem DATA[] = {\n        {\"$124\",           4, -1, FALSE},\n        {\"$124 $124\",      4, -1, FALSE},\n        {\"$124 \",          4, -1, FALSE},\n        {\"$ 124 \",         0,  1, FALSE},\n        {\"$\\\\u00A0124 \",   5, -1, FALSE},\n        {\" $ 124 \",        0,  0, FALSE},\n        {\"124$\",           0,  4, FALSE},\n        {\"124 $\",          0,  3, FALSE},\n        {\"$124\",           4, -1, TRUE},\n        {\"$124 $124\",      4, -1, TRUE},\n        {\"$124 \",          4, -1, TRUE},\n        {\"$ 124 \",         5, -1, TRUE},\n        {\"$\\\\u00A0124 \",   5, -1, TRUE},\n        {\" $ 124 \",        6, -1, TRUE},\n        {\"124$\",           4, -1, TRUE},\n        {\"124$\",           4, -1, TRUE},\n        {\"124 $\",          5, -1, TRUE},\n        {\"124 $\",          5, -1, TRUE},\n    };\n    UErrorCode status = U_ZERO_ERROR;\n    Locale locale(\"en_US\");\n    NumberFormat* foo = NumberFormat::createCurrencyInstance(locale, status);\n\n    if (U_FAILURE(status)) {\n        delete foo;\n        return;\n    }\n    for (uint32_t i = 0; i < UPRV_LENGTHOF(DATA); ++i) {\n        ParsePosition parsePosition(0);\n        UnicodeString stringToBeParsed = ctou(DATA[i].stringToParse);\n        int parsedPosition = DATA[i].parsedPos;\n        int errorIndex = DATA[i].errorIndex;\n        foo->setLenient(DATA[i].lenient);\n        Formattable result;\n        foo->parse(stringToBeParsed, result, parsePosition);\n        logln(\"Parsing: \" + stringToBeParsed);\n        if (parsePosition.getIndex() != parsedPosition ||\n            parsePosition.getErrorIndex() != errorIndex) {\n            errln(\"FAILED parse \" + stringToBeParsed + \"; lenient: \" + DATA[i].lenient + \"; wrong position, expected: (\" + parsedPosition + \", \" + errorIndex + \"); got (\" + parsePosition.getIndex() + \", \" + parsePosition.getErrorIndex() + \")\");\n        }\n        if (parsePosition.getErrorIndex() == -1 &&\n            result.getType() == Formattable::kLong &&\n            result.getLong() != 124) {\n            errln(\"FAILED parse \" + stringToBeParsed + \"; wrong number, expect: 124, got \" + result.getLong());\n        }\n    }\n    delete foo;\n}\n\n/**\n * Test using various numbering systems and numbering system keyword.\n */\ntypedef struct {\n    const char *localeName;\n    double      value;\n    UBool        isRBNF;\n    const char *expectedResult;\n} TestNumberingSystemItem;\n\nvoid NumberFormatTest::TestNumberingSystems() {\n\n    const TestNumberingSystemItem DATA[] = {\n        { \"en_US@numbers=thai\", 1234.567, FALSE, \"\\\\u0E51,\\\\u0E52\\\\u0E53\\\\u0E54.\\\\u0E55\\\\u0E56\\\\u0E57\" },\n        { \"en_US@numbers=hebr\", 5678.0, TRUE, \"\\\\u05D4\\\\u05F3\\\\u05EA\\\\u05E8\\\\u05E2\\\\u05F4\\\\u05D7\" },\n        { \"en_US@numbers=arabext\", 1234.567, FALSE, \"\\\\u06F1\\\\u066c\\\\u06F2\\\\u06F3\\\\u06F4\\\\u066b\\\\u06F5\\\\u06F6\\\\u06F7\" },\n        { \"ar_EG\", 1234.567, FALSE, \"\\\\u0661\\\\u066C\\\\u0662\\\\u0663\\\\u0664\\\\u066b\\\\u0665\\\\u0666\\\\u0667\" },\n        { \"th_TH@numbers=traditional\", 1234.567, FALSE, \"\\\\u0E51,\\\\u0E52\\\\u0E53\\\\u0E54.\\\\u0E55\\\\u0E56\\\\u0E57\" }, // fall back to native per TR35\n        { \"ar_MA\", 1234.567, FALSE, \"1.234,567\" },\n        { \"en_US@numbers=hanidec\", 1234.567, FALSE, \"\\\\u4e00,\\\\u4e8c\\\\u4e09\\\\u56db.\\\\u4e94\\\\u516d\\\\u4e03\" },\n        { \"ta_IN@numbers=native\", 1234.567, FALSE, \"\\\\u0BE7,\\\\u0BE8\\\\u0BE9\\\\u0BEA.\\\\u0BEB\\\\u0BEC\\\\u0BED\" },\n        { \"ta_IN@numbers=traditional\", 1235.0, TRUE, \"\\\\u0BF2\\\\u0BE8\\\\u0BF1\\\\u0BE9\\\\u0BF0\\\\u0BEB\" },\n        { \"ta_IN@numbers=finance\", 1234.567, FALSE, \"1,234.567\" }, // fall back to default per TR35\n        { \"zh_TW@numbers=native\", 1234.567, FALSE, \"\\\\u4e00,\\\\u4e8c\\\\u4e09\\\\u56db.\\\\u4e94\\\\u516d\\\\u4e03\" },\n        { \"zh_TW@numbers=traditional\", 1234.567, TRUE, \"\\\\u4E00\\\\u5343\\\\u4E8C\\\\u767E\\\\u4E09\\\\u5341\\\\u56DB\\\\u9EDE\\\\u4E94\\\\u516D\\\\u4E03\" },\n        { \"zh_TW@numbers=finance\", 1234.567, TRUE, \"\\\\u58F9\\\\u4EDF\\\\u8CB3\\\\u4F70\\\\u53C3\\\\u62FE\\\\u8086\\\\u9EDE\\\\u4F0D\\\\u9678\\\\u67D2\" },\n        { NULL, 0, FALSE, NULL }\n    };\n\n    UErrorCode ec;\n\n    const TestNumberingSystemItem *item;\n    for (item = DATA; item->localeName != NULL; item++) {\n        ec = U_ZERO_ERROR;\n        Locale loc = Locale::createFromName(item->localeName);\n\n        NumberFormat *origFmt = NumberFormat::createInstance(loc,ec);\n        if (U_FAILURE(ec)) {\n            dataerrln(\"FAIL: getInstance(%s) - %s\", item->localeName, u_errorName(ec));\n            continue;\n        }\n        // Clone to test ticket #10682\n        NumberFormat *fmt = (NumberFormat *) origFmt->clone();\n        delete origFmt;\n\n\n        if (item->isRBNF) {\n            expect3(*fmt,item->value,CharsToUnicodeString(item->expectedResult));\n        } else {\n            expect2(*fmt,item->value,CharsToUnicodeString(item->expectedResult));\n        }\n        delete fmt;\n    }\n\n\n    // Test bogus keyword value\n    ec = U_ZERO_ERROR;\n    Locale loc4 = Locale::createFromName(\"en_US@numbers=foobar\");\n    NumberFormat* fmt4= NumberFormat::createInstance(loc4, ec);\n    if ( ec != U_UNSUPPORTED_ERROR ) {\n        errln(\"FAIL: getInstance(en_US@numbers=foobar) should have returned U_UNSUPPORTED_ERROR\");\n        delete fmt4;\n    }\n\n    ec = U_ZERO_ERROR;\n    NumberingSystem *ns = NumberingSystem::createInstance(ec);\n    if (U_FAILURE(ec)) {\n        dataerrln(\"FAIL: NumberingSystem::createInstance(ec); - %s\", u_errorName(ec));\n    }\n\n    if ( ns != NULL ) {\n        ns->getDynamicClassID();\n        ns->getStaticClassID();\n    } else {\n        errln(\"FAIL: getInstance() returned NULL.\");\n    }\n\n    NumberingSystem *ns1 = new NumberingSystem(*ns);\n    if (ns1 == NULL) {\n        errln(\"FAIL: NumberSystem copy constructor returned NULL.\");\n    }\n\n    delete ns1;\n    delete ns;\n\n}\n\n\nvoid\nNumberFormatTest::TestMultiCurrencySign() {\n    const char* DATA[][6] = {\n        // the fields in the following test are:\n        // locale,\n        // currency pattern (with negative pattern),\n        // currency number to be formatted,\n        // currency format using currency symbol name, such as \"$\" for USD,\n        // currency format using currency ISO name, such as \"USD\",\n        // currency format using plural name, such as \"US dollars\".\n        // for US locale\n        {\"en_US\", \"\\\\u00A4#,##0.00;-\\\\u00A4#,##0.00\", \"1234.56\", \"$1,234.56\", \"USD\\\\u00A01,234.56\", \"US dollars\\\\u00A01,234.56\"},\n        {\"en_US\", \"\\\\u00A4#,##0.00;-\\\\u00A4#,##0.00\", \"-1234.56\", \"-$1,234.56\", \"-USD\\\\u00A01,234.56\", \"-US dollars\\\\u00A01,234.56\"},\n        {\"en_US\", \"\\\\u00A4#,##0.00;-\\\\u00A4#,##0.00\", \"1\", \"$1.00\", \"USD\\\\u00A01.00\", \"US dollars\\\\u00A01.00\"},\n        // for CHINA locale\n        {\"zh_CN\", \"\\\\u00A4#,##0.00;(\\\\u00A4#,##0.00)\", \"1234.56\", \"\\\\uFFE51,234.56\", \"CNY\\\\u00A01,234.56\", \"\\\\u4EBA\\\\u6C11\\\\u5E01\\\\u00A01,234.56\"},\n        {\"zh_CN\", \"\\\\u00A4#,##0.00;(\\\\u00A4#,##0.00)\", \"-1234.56\", \"(\\\\uFFE51,234.56)\", \"(CNY\\\\u00A01,234.56)\", \"(\\\\u4EBA\\\\u6C11\\\\u5E01\\\\u00A01,234.56)\"},\n        {\"zh_CN\", \"\\\\u00A4#,##0.00;(\\\\u00A4#,##0.00)\", \"1\", \"\\\\uFFE51.00\", \"CNY\\\\u00A01.00\", \"\\\\u4EBA\\\\u6C11\\\\u5E01\\\\u00A01.00\"}\n    };\n\n    const UChar doubleCurrencySign[] = {0xA4, 0xA4, 0};\n    UnicodeString doubleCurrencyStr(doubleCurrencySign);\n    const UChar tripleCurrencySign[] = {0xA4, 0xA4, 0xA4, 0};\n    UnicodeString tripleCurrencyStr(tripleCurrencySign);\n\n    for (uint32_t i=0; i<UPRV_LENGTHOF(DATA); ++i) {\n        const char* locale = DATA[i][0];\n        UnicodeString pat = ctou(DATA[i][1]);\n        double numberToBeFormat = atof(DATA[i][2]);\n        UErrorCode status = U_ZERO_ERROR;\n        DecimalFormatSymbols* sym = new DecimalFormatSymbols(Locale(locale), status);\n        if (U_FAILURE(status)) {\n            delete sym;\n            continue;\n        }\n        for (int j=1; j<=3; ++j) {\n            // j represents the number of currency sign in the pattern.\n            if (j == 2) {\n                pat = pat.findAndReplace(ctou(\"\\\\u00A4\"), doubleCurrencyStr);\n            } else if (j == 3) {\n                pat = pat.findAndReplace(ctou(\"\\\\u00A4\\\\u00A4\"), tripleCurrencyStr);\n            }\n\n            DecimalFormat* fmt = new DecimalFormat(pat, new DecimalFormatSymbols(*sym), status);\n            if (U_FAILURE(status)) {\n                errln(\"FAILED init DecimalFormat \");\n                delete fmt;\n                continue;\n            }\n            UnicodeString s;\n            ((NumberFormat*) fmt)->format(numberToBeFormat, s);\n            // DATA[i][3] is the currency format result using a\n            // single currency sign.\n            // DATA[i][4] is the currency format result using\n            // double currency sign.\n            // DATA[i][5] is the currency format result using\n            // triple currency sign.\n            // DATA[i][j+2] is the currency format result using\n            // 'j' number of currency sign.\n            UnicodeString currencyFormatResult = ctou(DATA[i][2+j]);\n            if (s.compare(currencyFormatResult)) {\n                errln(\"FAIL format: Expected \" + currencyFormatResult + \"; Got \" + s);\n            }\n            // mix style parsing\n            for (int k=3; k<=5; ++k) {\n              // DATA[i][3] is the currency format result using a\n              // single currency sign.\n              // DATA[i][4] is the currency format result using\n              // double currency sign.\n              // DATA[i][5] is the currency format result using\n              // triple currency sign.\n              UnicodeString oneCurrencyFormat = ctou(DATA[i][k]);\n              UErrorCode status = U_ZERO_ERROR;\n              Formattable parseRes;\n              fmt->parse(oneCurrencyFormat, parseRes, status);\n              if (U_FAILURE(status) ||\n                  (parseRes.getType() == Formattable::kDouble &&\n                   parseRes.getDouble() != numberToBeFormat) ||\n                  (parseRes.getType() == Formattable::kLong &&\n                   parseRes.getLong() != numberToBeFormat)) {\n                  errln(\"FAILED parse \" + oneCurrencyFormat + \"; (i, j, k): \" +\n                        i + \", \" + j + \", \" + k);\n              }\n            }\n            delete fmt;\n        }\n        delete sym;\n    }\n}\n\n\nvoid\nNumberFormatTest::TestCurrencyFormatForMixParsing() {\n    UErrorCode status = U_ZERO_ERROR;\n    MeasureFormat* curFmt = MeasureFormat::createCurrencyFormat(Locale(\"en_US\"), status);\n    if (U_FAILURE(status)) {\n        delete curFmt;\n        return;\n    }\n    const char* formats[] = {\n        \"$1,234.56\",  // string to be parsed\n        \"USD1,234.56\",\n        \"US dollars1,234.56\",\n        // \"1,234.56 US dollars\" // Fails in 62 because currency format is not compatible with pattern.\n    };\n    const CurrencyAmount* curramt = NULL;\n    for (uint32_t i = 0; i < UPRV_LENGTHOF(formats); ++i) {\n        UnicodeString stringToBeParsed = ctou(formats[i]);\n        logln(UnicodeString(\"stringToBeParsed: \") + stringToBeParsed);\n        Formattable result;\n        UErrorCode status = U_ZERO_ERROR;\n        curFmt->parseObject(stringToBeParsed, result, status);\n        if (U_FAILURE(status)) {\n          errln(\"FAIL: measure format parsing: '%s' ec: %s\", formats[i], u_errorName(status));\n        } else if (result.getType() != Formattable::kObject ||\n            (curramt = dynamic_cast<const CurrencyAmount*>(result.getObject())) == NULL ||\n            curramt->getNumber().getDouble() != 1234.56 ||\n            UnicodeString(curramt->getISOCurrency()).compare(ISO_CURRENCY_USD)\n        ) {\n            errln(\"FAIL: getCurrencyFormat of default locale (en_US) failed roundtripping the number \");\n            if (curramt->getNumber().getDouble() != 1234.56) {\n                errln((UnicodeString)\"wong number, expect: 1234.56\" + \", got: \" + curramt->getNumber().getDouble());\n            }\n            if (curramt->getISOCurrency() != ISO_CURRENCY_USD) {\n                errln((UnicodeString)\"wong currency, expect: USD\" + \", got: \" + curramt->getISOCurrency());\n            }\n        }\n    }\n    delete curFmt;\n}\n\n\n/** Starting in ICU 62, strict mode is actually strict with currency formats. */\nvoid NumberFormatTest::TestMismatchedCurrencyFormatFail() {\n    IcuTestErrorCode status(*this, \"TestMismatchedCurrencyFormatFail\");\n    LocalPointer<DecimalFormat> df(\n            dynamic_cast<DecimalFormat*>(DecimalFormat::createCurrencyInstance(\"en\", status)), status);\n    if (!assertSuccess(\"createCurrencyInstance() failed.\", status, true, __FILE__, __LINE__)) {return;}\n    UnicodeString pattern;\n    assertEquals(\"Test assumes that currency sign is at the beginning\",\n            u\"\\u00A4#,##0.00\",\n            df->toPattern(pattern));\n    // Should round-trip on the correct currency format:\n    expect2(*df, 1.23, u\"\\u00A41.23\");\n    df->setCurrency(u\"EUR\", status);\n    expect2(*df, 1.23, u\"\\u20AC1.23\");\n    // Should parse with currency in the wrong place in lenient mode\n    df->setLenient(TRUE);\n    expect(*df, u\"1.23\\u20AC\", 1.23);\n    expectParseCurrency(*df, u\"EUR\", 1.23, \"1.23\\\\u20AC\");\n    // Should NOT parse with currency in the wrong place in STRICT mode\n    df->setLenient(FALSE);\n    {\n        Formattable result;\n        ErrorCode failStatus;\n        df->parse(u\"1.23\\u20AC\", result, failStatus);\n        assertEquals(\"Should fail to parse\", U_INVALID_FORMAT_ERROR, failStatus);\n    }\n    {\n        ParsePosition ppos;\n        df->parseCurrency(u\"1.23\\u20AC\", ppos);\n        assertEquals(\"Should fail to parse currency\", 0, ppos.getIndex());\n    }\n}\n\n\nvoid\nNumberFormatTest::TestDecimalFormatCurrencyParse() {\n    // Locale.US\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols* sym = new DecimalFormatSymbols(Locale(\"en_US\"), status);\n    if (U_FAILURE(status)) {\n        delete sym;\n        return;\n    }\n    UnicodeString pat;\n    UChar currency = 0x00A4;\n    // \"\\xA4#,##0.00;-\\xA4#,##0.00\"\n    pat.append(currency).append(currency).append(currency).append(\"#,##0.00;-\").append(currency).append(currency).append(currency).append(\"#,##0.00\");\n    DecimalFormat* fmt = new DecimalFormat(pat, sym, status);\n    if (U_FAILURE(status)) {\n        delete fmt;\n        errln(\"failed to new DecimalFormat in TestDecimalFormatCurrencyParse\");\n        return;\n    }\n    const char* DATA[][2] = {\n        // the data are:\n        // string to be parsed, the parsed result (number)\n        {\"$1.00\", \"1\"},\n        {\"USD1.00\", \"1\"},\n        {\"1.00 US dollar\", \"1\"},\n        {\"$1,234.56\", \"1234.56\"},\n        {\"USD1,234.56\", \"1234.56\"},\n        {\"1,234.56 US dollar\", \"1234.56\"},\n    };\n    // NOTE: ICU 62 requires that the currency format match the pattern in strict mode.\n    fmt->setLenient(TRUE);\n    for (uint32_t i = 0; i < UPRV_LENGTHOF(DATA); ++i) {\n        UnicodeString stringToBeParsed = ctou(DATA[i][0]);\n        double parsedResult = atof(DATA[i][1]);\n        UErrorCode status = U_ZERO_ERROR;\n        Formattable result;\n        fmt->parse(stringToBeParsed, result, status);\n        logln((UnicodeString)\"Input: \" + stringToBeParsed + \"; output: \" + result.getDouble(status));\n        if (U_FAILURE(status) ||\n            (result.getType() == Formattable::kDouble &&\n            result.getDouble() != parsedResult) ||\n            (result.getType() == Formattable::kLong &&\n            result.getLong() != parsedResult)) {\n            errln((UnicodeString)\"FAIL parse: Expected \" + parsedResult);\n        }\n    }\n    delete fmt;\n}\n\n\nvoid\nNumberFormatTest::TestCurrencyIsoPluralFormat() {\n    static const char* DATA[][6] = {\n        // the data are:\n        // locale,\n        // currency amount to be formatted,\n        // currency ISO code to be formatted,\n        // format result using CURRENCYSTYLE,\n        // format result using ISOCURRENCYSTYLE,\n        // format result using PLURALCURRENCYSTYLE,\n\n        {\"en_US\", \"1\", \"USD\", \"$1.00\", \"USD\\\\u00A01.00\", \"1.00 US dollars\"},\n        {\"en_US\", \"1234.56\", \"USD\", \"$1,234.56\", \"USD\\\\u00A01,234.56\", \"1,234.56 US dollars\"},\n        {\"en_US\", \"-1234.56\", \"USD\", \"-$1,234.56\", \"-USD\\\\u00A01,234.56\", \"-1,234.56 US dollars\"},\n        {\"zh_CN\", \"1\", \"USD\", \"US$1.00\", \"USD\\\\u00A01.00\", \"1.00\\\\u00A0\\\\u7F8E\\\\u5143\"},\n        {\"zh_CN\", \"1234.56\", \"USD\", \"US$1,234.56\", \"USD\\\\u00A01,234.56\", \"1,234.56\\\\u00A0\\\\u7F8E\\\\u5143\"},\n        {\"zh_CN\", \"1\", \"CNY\", \"\\\\uFFE51.00\", \"CNY\\\\u00A01.00\", \"1.00\\\\u00A0\\\\u4EBA\\\\u6C11\\\\u5E01\"},\n        {\"zh_CN\", \"1234.56\", \"CNY\", \"\\\\uFFE51,234.56\", \"CNY\\\\u00A01,234.56\", \"1,234.56\\\\u00A0\\\\u4EBA\\\\u6C11\\\\u5E01\"},\n        {\"ru_RU\", \"1\", \"RUB\", \"1,00\\\\u00A0\\\\u20BD\", \"1,00\\\\u00A0RUB\", \"1,00 \\\\u0440\\\\u043E\\\\u0441\\\\u0441\\\\u0438\\\\u0439\\\\u0441\\\\u043A\\\\u043E\\\\u0433\\\\u043E \\\\u0440\\\\u0443\\\\u0431\\\\u043B\\\\u044F\"},\n        {\"ru_RU\", \"2\", \"RUB\", \"2,00\\\\u00A0\\\\u20BD\", \"2,00\\\\u00A0RUB\", \"2,00 \\\\u0440\\\\u043E\\\\u0441\\\\u0441\\\\u0438\\\\u0439\\\\u0441\\\\u043A\\\\u043E\\\\u0433\\\\u043E \\\\u0440\\\\u0443\\\\u0431\\\\u043B\\\\u044F\"},\n        {\"ru_RU\", \"5\", \"RUB\", \"5,00\\\\u00A0\\\\u20BD\", \"5,00\\\\u00A0RUB\", \"5,00 \\\\u0440\\\\u043E\\\\u0441\\\\u0441\\\\u0438\\\\u0439\\\\u0441\\\\u043A\\\\u043E\\\\u0433\\\\u043E \\\\u0440\\\\u0443\\\\u0431\\\\u043B\\\\u044F\"},\n        // test locale without currency information\n        {\"root\", \"-1.23\", \"USD\", \"-US$\\\\u00A01.23\", \"-USD\\\\u00A01.23\", \"-1.23 USD\"},\n        // test choice format\n        {\"es_AR\", \"1\", \"INR\", \"INR\\\\u00A01,00\", \"INR\\\\u00A01,00\", \"1,00 rupia india\"},\n    };\n    static const UNumberFormatStyle currencyStyles[] = {\n        UNUM_CURRENCY,\n        UNUM_CURRENCY_ISO,\n        UNUM_CURRENCY_PLURAL\n    };\n\n    for (int32_t i=0; i<UPRV_LENGTHOF(DATA); ++i) {\n      const char* localeString = DATA[i][0];\n      double numberToBeFormat = atof(DATA[i][1]);\n      const char* currencyISOCode = DATA[i][2];\n      logln(UnicodeString(u\"Locale: \") + localeString + \"; amount: \" + numberToBeFormat);\n      Locale locale(localeString);\n      for (int32_t kIndex = 0; kIndex < UPRV_LENGTHOF(currencyStyles); ++kIndex) {\n        UNumberFormatStyle k = currencyStyles[kIndex];\n        logln(UnicodeString(u\"UNumberFormatStyle: \") + k);\n        UErrorCode status = U_ZERO_ERROR;\n        NumberFormat* numFmt = NumberFormat::createInstance(locale, k, status);\n        if (U_FAILURE(status)) {\n            delete numFmt;\n            dataerrln((UnicodeString)\"can not create instance, locale:\" + localeString + \", style: \" + k + \" - \" + u_errorName(status));\n            continue;\n        }\n        UChar currencyCode[4];\n        u_charsToUChars(currencyISOCode, currencyCode, 4);\n        numFmt->setCurrency(currencyCode, status);\n        if (U_FAILURE(status)) {\n            delete numFmt;\n            errln((UnicodeString)\"can not set currency:\" + currencyISOCode);\n            continue;\n        }\n\n        UnicodeString strBuf;\n        numFmt->format(numberToBeFormat, strBuf);\n        int resultDataIndex = 3 + kIndex;\n        // DATA[i][resultDataIndex] is the currency format result\n        // using 'k' currency style.\n        UnicodeString formatResult = ctou(DATA[i][resultDataIndex]);\n        if (strBuf.compare(formatResult)) {\n            errln(\"FAIL: Expected \" + formatResult + \" actual: \" + strBuf);\n        }\n        // test parsing, and test parsing for all currency formats.\n        // NOTE: ICU 62 requires that the currency format match the pattern in strict mode.\n        numFmt->setLenient(TRUE);\n        for (int j = 3; j < 6; ++j) {\n            // DATA[i][3] is the currency format result using\n            // CURRENCYSTYLE formatter.\n            // DATA[i][4] is the currency format result using\n            // ISOCURRENCYSTYLE formatter.\n            // DATA[i][5] is the currency format result using\n            // PLURALCURRENCYSTYLE formatter.\n            UnicodeString oneCurrencyFormatResult = ctou(DATA[i][j]);\n            UErrorCode status = U_ZERO_ERROR;\n            Formattable parseResult;\n            numFmt->parse(oneCurrencyFormatResult, parseResult, status);\n            if (U_FAILURE(status) ||\n                (parseResult.getType() == Formattable::kDouble &&\n                 parseResult.getDouble() != numberToBeFormat) ||\n                (parseResult.getType() == Formattable::kLong &&\n                 parseResult.getLong() != numberToBeFormat)) {\n                errln((UnicodeString)\"FAIL: getCurrencyFormat of locale \" +\n                      localeString + \" failed roundtripping the number\");\n                if (parseResult.getType() == Formattable::kDouble) {\n                    errln((UnicodeString)\"expected: \" + numberToBeFormat + \"; actual: \" +parseResult.getDouble());\n                } else {\n                    errln((UnicodeString)\"expected: \" + numberToBeFormat + \"; actual: \" +parseResult.getLong());\n                }\n            }\n        }\n        delete numFmt;\n      }\n    }\n}\n\nvoid\nNumberFormatTest::TestCurrencyParsing() {\n    static const char* DATA[][6] = {\n        // the data are:\n        // locale,\n        // currency amount to be formatted,\n        // currency ISO code to be formatted,\n        // format result using CURRENCYSTYLE,\n        // format result using ISOCURRENCYSTYLE,\n        // format result using PLURALCURRENCYSTYLE,\n        {\"en_US\", \"1\", \"USD\", \"$1.00\", \"USD\\\\u00A01.00\", \"1.00 US dollars\"},\n        {\"pa_IN\", \"1\", \"USD\", \"US$\\\\u00A01.00\", \"USD\\\\u00A01.00\", \"1.00 \\\\u0a2f\\\\u0a42.\\\\u0a10\\\\u0a38. \\\\u0a21\\\\u0a3e\\\\u0a32\\\\u0a30\"},\n        {\"es_AR\", \"1\", \"USD\", \"US$\\\\u00A01,00\", \"USD\\\\u00A01,00\", \"1,00 d\\\\u00f3lar estadounidense\"},\n        {\"ar_EG\", \"1\", \"USD\", \"\\\\u0661\\\\u066b\\\\u0660\\\\u0660\\\\u00a0US$\", \"\\\\u0661\\\\u066b\\\\u0660\\\\u0660\\\\u00a0USD\", \"\\\\u0661\\\\u066b\\\\u0660\\\\u0660 \\\\u062f\\\\u0648\\\\u0644\\\\u0627\\\\u0631 \\\\u0623\\\\u0645\\\\u0631\\\\u064a\\\\u0643\\\\u064a\"},\n        {\"fa_CA\", \"1\", \"USD\", \"\\\\u200e$\\\\u06f1\\\\u066b\\\\u06f0\\\\u06f0\", \"\\\\u200eUSD\\\\u06f1\\\\u066b\\\\u06f0\\\\u06f0\", \"\\\\u06f1\\\\u066b\\\\u06f0\\\\u06f0 \\\\u062f\\\\u0644\\\\u0627\\\\u0631 \\\\u0627\\\\u0645\\\\u0631\\\\u06cc\\\\u06a9\\\\u0627\"},\n        {\"he_IL\", \"1\", \"USD\", \"\\\\u200f1.00\\\\u00a0$\", \"\\\\u200f1.00\\\\u00a0USD\", \"1.00 \\\\u05d3\\\\u05d5\\\\u05dc\\\\u05e8 \\\\u05d0\\\\u05de\\\\u05e8\\\\u05d9\\\\u05e7\\\\u05d0\\\\u05d9\"},\n        {\"hr_HR\", \"1\", \"USD\", \"1,00\\\\u00a0USD\", \"1,00\\\\u00a0USD\", \"1,00 ameri\\\\u010Dkih dolara\"},\n        {\"id_ID\", \"1\", \"USD\", \"US$\\\\u00A01,00\", \"USD\\\\u00A01,00\", \"1,00 Dolar Amerika Serikat\"},\n        {\"it_IT\", \"1\", \"USD\", \"1,00\\\\u00a0USD\", \"1,00\\\\u00a0USD\", \"1,00 dollari statunitensi\"},\n        {\"ko_KR\", \"1\", \"USD\", \"US$\\\\u00A01.00\", \"USD\\\\u00A01.00\", \"1.00 \\\\ubbf8\\\\uad6d \\\\ub2ec\\\\ub7ec\"},\n        {\"ja_JP\", \"1\", \"USD\", \"$1.00\", \"USD\\\\u00A01.00\", \"1.00\\\\u00A0\\\\u7c73\\\\u30c9\\\\u30eb\"},\n        {\"zh_CN\", \"1\", \"CNY\", \"\\\\uFFE51.00\", \"CNY\\\\u00A001.00\", \"1.00\\\\u00A0\\\\u4EBA\\\\u6C11\\\\u5E01\"},\n        {\"zh_TW\", \"1\", \"CNY\", \"CN\\\\u00A51.00\", \"CNY\\\\u00A01.00\", \"1.00 \\\\u4eba\\\\u6c11\\\\u5e63\"},\n        {\"zh_Hant\", \"1\", \"CNY\", \"CN\\\\u00A51.00\", \"CNY\\\\u00A01.00\", \"1.00 \\\\u4eba\\\\u6c11\\\\u5e63\"},\n        {\"zh_Hant\", \"1\", \"JPY\", \"\\\\u00A51.00\", \"JPY\\\\u00A01.00\", \"1 \\\\u65E5\\\\u5713\"},\n        {\"ja_JP\", \"1\", \"JPY\", \"\\\\uFFE51.00\", \"JPY\\\\u00A01.00\", \"1\\\\u00A0\\\\u5186\"},\n        // ICU 62 requires #parseCurrency() to recognize variants when parsing\n        // {\"ja_JP\", \"1\", \"JPY\", \"\\\\u00A51.00\", \"JPY\\\\u00A01.00\", \"1\\\\u00A0\\\\u5186\"},\n        {\"ru_RU\", \"1\", \"RUB\", \"1,00\\\\u00A0\\\\u00A0\\\\u20BD\", \"1,00\\\\u00A0\\\\u00A0RUB\", \"1,00 \\\\u0440\\\\u043E\\\\u0441\\\\u0441\\\\u0438\\\\u0439\\\\u0441\\\\u043A\\\\u043E\\\\u0433\\\\u043E \\\\u0440\\\\u0443\\\\u0431\\\\u043B\\\\u044F\"}\n    };\n    static const UNumberFormatStyle currencyStyles[] = {\n        UNUM_CURRENCY,\n        UNUM_CURRENCY_ISO,\n        UNUM_CURRENCY_PLURAL\n    };\n    static const char* currencyStyleNames[] = {\n      \"UNUM_CURRENCY\",\n      \"UNUM_CURRENCY_ISO\",\n      \"UNUM_CURRENCY_PLURAL\"\n    };\n\n#ifdef NUMFMTST_CACHE_DEBUG\nint deadloop = 0;\nfor (;;) {\n    printf(\"loop: %d\\n\", deadloop++);\n#endif\n    for (uint32_t i=0; i< UPRV_LENGTHOF(DATA); ++i) {  /* i = test case #  - should be i=0*/\n      for (int32_t kIndex = 2; kIndex < UPRV_LENGTHOF(currencyStyles); ++kIndex) {\n        UNumberFormatStyle k = currencyStyles[kIndex]; /* k = style */\n        const char* localeString = DATA[i][0];\n        double numberToBeFormat = atof(DATA[i][1]);\n        const char* currencyISOCode = DATA[i][2];\n        Locale locale(localeString);\n        UErrorCode status = U_ZERO_ERROR;\n        NumberFormat* numFmt = NumberFormat::createInstance(locale, k, status);\n        logln(\"#%d NumberFormat(%s, %s) Currency=%s\\n\",\n              i, localeString, currencyStyleNames[kIndex],\n              currencyISOCode);\n\n        if (U_FAILURE(status)) {\n            delete numFmt;\n            dataerrln((UnicodeString)\"can not create instance, locale:\" + localeString + \", style: \" + k + \" - \" + u_errorName(status));\n            continue;\n        }\n        UChar currencyCode[4];\n        u_charsToUChars(currencyISOCode, currencyCode, 4);\n        numFmt->setCurrency(currencyCode, status);\n        if (U_FAILURE(status)) {\n            delete numFmt;\n            errln((UnicodeString)\"can not set currency:\" + currencyISOCode);\n            continue;\n        }\n\n        UnicodeString strBuf;\n        numFmt->format(numberToBeFormat, strBuf);\n        int resultDataIndex = 3 + kIndex;\n        // DATA[i][resultDataIndex] is the currency format result\n        // using 'k' currency style.\n        UnicodeString formatResult = ctou(DATA[i][resultDataIndex]);\n        if (strBuf.compare(formatResult)) {\n            errln(\"FAIL: Expected \" + formatResult + \" actual: \" + strBuf);\n        }\n        // test parsing, and test parsing for all currency formats.\n        // NOTE: ICU 62 requires that the currency format match the pattern in strict mode.\n        numFmt->setLenient(TRUE);\n        for (int j = 3; j < 6; ++j) {\n            // DATA[i][3] is the currency format result using\n            // CURRENCYSTYLE formatter.\n            // DATA[i][4] is the currency format result using\n            // ISOCURRENCYSTYLE formatter.\n            // DATA[i][5] is the currency format result using\n            // PLURALCURRENCYSTYLE formatter.\n            UnicodeString oneCurrencyFormatResult = ctou(DATA[i][j]);\n            UErrorCode status = U_ZERO_ERROR;\n            Formattable parseResult;\n            logln(\"parse(%s)\", DATA[i][j]);\n            numFmt->parse(oneCurrencyFormatResult, parseResult, status);\n            if (U_FAILURE(status) ||\n                (parseResult.getType() == Formattable::kDouble &&\n                 parseResult.getDouble() != numberToBeFormat) ||\n                (parseResult.getType() == Formattable::kLong &&\n                 parseResult.getLong() != numberToBeFormat)) {\n                errln((UnicodeString)\"FAIL: NumberFormat(\" + localeString +\", \" + currencyStyleNames[kIndex] +\n                      \"), Currency=\"+currencyISOCode+\", parse(\"+DATA[i][j]+\") returned error \" + (UnicodeString)u_errorName(status)+\".  Testcase: data[\" + i + \"][\" + currencyStyleNames[j-3] +\"=\"+j+\"]\");\n                if (parseResult.getType() == Formattable::kDouble) {\n                    errln((UnicodeString)\"expected: \" + numberToBeFormat + \"; actual (double): \" +parseResult.getDouble());\n                } else {\n                    errln((UnicodeString)\"expected: \" + numberToBeFormat + \"; actual (long): \" +parseResult.getLong());\n                }\n                errln((UnicodeString)\" round-trip would be: \" + strBuf);\n            }\n        }\n        delete numFmt;\n      }\n    }\n#ifdef NUMFMTST_CACHE_DEBUG\n}\n#endif\n}\n\n\nvoid\nNumberFormatTest::TestParseCurrencyInUCurr() {\n    const char* DATA[] = {\n        \"1.00 US DOLLAR\",  // case in-sensitive\n        \"$1.00\",\n        \"USD1.00\",\n        \"usd1.00\", // case in-sensitive: #13696\n        \"US dollar1.00\",\n        \"US dollars1.00\",\n        \"$1.00\",\n        \"A$1.00\",\n        \"ADP1.00\",\n        \"ADP1.00\",\n        \"AED1.00\",\n        \"AED1.00\",\n        \"AFA1.00\",\n        \"AFA1.00\",\n        \"AFN1.00\",\n        \"ALL1.00\",\n        \"AMD1.00\",\n        \"ANG1.00\",\n        \"AOA1.00\",\n        \"AOK1.00\",\n        \"AOK1.00\",\n        \"AON1.00\",\n        \"AON1.00\",\n        \"AOR1.00\",\n        \"AOR1.00\",\n        \"ARS1.00\",\n        \"ARA1.00\",\n        \"ARA1.00\",\n        \"ARP1.00\",\n        \"ARP1.00\",\n        \"ARS1.00\",\n        \"ATS1.00\",\n        \"ATS1.00\",\n        \"AUD1.00\",\n        \"AWG1.00\",\n        \"AZM1.00\",\n        \"AZM1.00\",\n        \"AZN1.00\",\n        \"Afghan Afghani (1927\\\\u20132002)1.00\",\n        \"Afghan afghani (1927\\\\u20132002)1.00\",\n        \"Afghan Afghani1.00\",\n        \"Afghan Afghanis1.00\",\n        \"Albanian Lek1.00\",\n        \"Albanian lek1.00\",\n        \"Albanian lek\\\\u00eb1.00\",\n        \"Algerian Dinar1.00\",\n        \"Algerian dinar1.00\",\n        \"Algerian dinars1.00\",\n        \"Andorran Peseta1.00\",\n        \"Andorran peseta1.00\",\n        \"Andorran pesetas1.00\",\n        \"Angolan Kwanza (1977\\\\u20131991)1.00\",\n        \"Angolan Readjusted Kwanza (1995\\\\u20131999)1.00\",\n        \"Angolan Kwanza1.00\",\n        \"Angolan New Kwanza (1990\\\\u20132000)1.00\",\n        \"Angolan kwanza (1977\\\\u20131991)1.00\",\n        \"Angolan readjusted kwanza (1995\\\\u20131999)1.00\",\n        \"Angolan kwanza1.00\",\n        \"Angolan kwanzas (1977\\\\u20131991)1.00\",\n        \"Angolan readjusted kwanzas (1995\\\\u20131999)1.00\",\n        \"Angolan kwanzas1.00\",\n        \"Angolan new kwanza (1990\\\\u20132000)1.00\",\n        \"Angolan new kwanzas (1990\\\\u20132000)1.00\",\n        \"Argentine Austral1.00\",\n        \"Argentine Peso (1983\\\\u20131985)1.00\",\n        \"Argentine Peso1.00\",\n        \"Argentine austral1.00\",\n        \"Argentine australs1.00\",\n        \"Argentine peso (1983\\\\u20131985)1.00\",\n        \"Argentine peso1.00\",\n        \"Argentine pesos (1983\\\\u20131985)1.00\",\n        \"Argentine pesos1.00\",\n        \"Armenian Dram1.00\",\n        \"Armenian dram1.00\",\n        \"Armenian drams1.00\",\n        \"Aruban Florin1.00\",\n        \"Aruban florin1.00\",\n        \"Australian Dollar1.00\",\n        \"Australian dollar1.00\",\n        \"Australian dollars1.00\",\n        \"Austrian Schilling1.00\",\n        \"Austrian schilling1.00\",\n        \"Austrian schillings1.00\",\n        \"Azerbaijani Manat (1993\\\\u20132006)1.00\",\n        \"Azerbaijani Manat1.00\",\n        \"Azerbaijani manat (1993\\\\u20132006)1.00\",\n        \"Azerbaijani manat1.00\",\n        \"Azerbaijani manats (1993\\\\u20132006)1.00\",\n        \"Azerbaijani manats1.00\",\n        \"BAD1.00\",\n        \"BAD1.00\",\n        \"BAM1.00\",\n        \"BBD1.00\",\n        \"BDT1.00\",\n        \"BEC1.00\",\n        \"BEC1.00\",\n        \"BEF1.00\",\n        \"BEL1.00\",\n        \"BEL1.00\",\n        \"BGL1.00\",\n        \"BGN1.00\",\n        \"BGN1.00\",\n        \"BHD1.00\",\n        \"BIF1.00\",\n        \"BMD1.00\",\n        \"BND1.00\",\n        \"BOB1.00\",\n        \"BOP1.00\",\n        \"BOP1.00\",\n        \"BOV1.00\",\n        \"BOV1.00\",\n        \"BRB1.00\",\n        \"BRB1.00\",\n        \"BRC1.00\",\n        \"BRC1.00\",\n        \"BRE1.00\",\n        \"BRE1.00\",\n        \"BRL1.00\",\n        \"BRN1.00\",\n        \"BRN1.00\",\n        \"BRR1.00\",\n        \"BRR1.00\",\n        \"BSD1.00\",\n        \"BSD1.00\",\n        \"BTN1.00\",\n        \"BUK1.00\",\n        \"BUK1.00\",\n        \"BWP1.00\",\n        \"BYB1.00\",\n        \"BYB1.00\",\n        \"BYR1.00\",\n        \"BZD1.00\",\n        \"Bahamian Dollar1.00\",\n        \"Bahamian dollar1.00\",\n        \"Bahamian dollars1.00\",\n        \"Bahraini Dinar1.00\",\n        \"Bahraini dinar1.00\",\n        \"Bahraini dinars1.00\",\n        \"Bangladeshi Taka1.00\",\n        \"Bangladeshi taka1.00\",\n        \"Bangladeshi takas1.00\",\n        \"Barbadian Dollar1.00\",\n        \"Barbadian dollar1.00\",\n        \"Barbadian dollars1.00\",\n        \"Belarusian Ruble (1994\\\\u20131999)1.00\",\n        \"Belarusian Ruble1.00\",\n        \"Belarusian ruble (1994\\\\u20131999)1.00\",\n        \"Belarusian rubles (1994\\\\u20131999)1.00\",\n        \"Belarusian ruble1.00\",\n        \"Belarusian rubles1.00\",\n        \"Belgian Franc (convertible)1.00\",\n        \"Belgian Franc (financial)1.00\",\n        \"Belgian Franc1.00\",\n        \"Belgian franc (convertible)1.00\",\n        \"Belgian franc (financial)1.00\",\n        \"Belgian franc1.00\",\n        \"Belgian francs (convertible)1.00\",\n        \"Belgian francs (financial)1.00\",\n        \"Belgian francs1.00\",\n        \"Belize Dollar1.00\",\n        \"Belize dollar1.00\",\n        \"Belize dollars1.00\",\n        \"Bermudan Dollar1.00\",\n        \"Bermudan dollar1.00\",\n        \"Bermudan dollars1.00\",\n        \"Bhutanese Ngultrum1.00\",\n        \"Bhutanese ngultrum1.00\",\n        \"Bhutanese ngultrums1.00\",\n        \"Bolivian Mvdol1.00\",\n        \"Bolivian Peso1.00\",\n        \"Bolivian mvdol1.00\",\n        \"Bolivian mvdols1.00\",\n        \"Bolivian peso1.00\",\n        \"Bolivian pesos1.00\",\n        \"Bolivian Boliviano1.00\",\n        \"Bolivian Boliviano1.00\",\n        \"Bolivian Bolivianos1.00\",\n        \"Bosnia-Herzegovina Convertible Mark1.00\",\n        \"Bosnia-Herzegovina Dinar (1992\\\\u20131994)1.00\",\n        \"Bosnia-Herzegovina convertible mark1.00\",\n        \"Bosnia-Herzegovina convertible marks1.00\",\n        \"Bosnia-Herzegovina dinar (1992\\\\u20131994)1.00\",\n        \"Bosnia-Herzegovina dinars (1992\\\\u20131994)1.00\",\n        \"Botswanan Pula1.00\",\n        \"Botswanan pula1.00\",\n        \"Botswanan pulas1.00\",\n        \"Brazilian New Cruzado (1989\\\\u20131990)1.00\",\n        \"Brazilian Cruzado (1986\\\\u20131989)1.00\",\n        \"Brazilian Cruzeiro (1990\\\\u20131993)1.00\",\n        \"Brazilian New Cruzeiro (1967\\\\u20131986)1.00\",\n        \"Brazilian Cruzeiro (1993\\\\u20131994)1.00\",\n        \"Brazilian Real1.00\",\n        \"Brazilian new cruzado (1989\\\\u20131990)1.00\",\n        \"Brazilian new cruzados (1989\\\\u20131990)1.00\",\n        \"Brazilian cruzado (1986\\\\u20131989)1.00\",\n        \"Brazilian cruzados (1986\\\\u20131989)1.00\",\n        \"Brazilian cruzeiro (1990\\\\u20131993)1.00\",\n        \"Brazilian new cruzeiro (1967\\\\u20131986)1.00\",\n        \"Brazilian cruzeiro (1993\\\\u20131994)1.00\",\n        \"Brazilian cruzeiros (1990\\\\u20131993)1.00\",\n        \"Brazilian new cruzeiros (1967\\\\u20131986)1.00\",\n        \"Brazilian cruzeiros (1993\\\\u20131994)1.00\",\n        \"Brazilian real1.00\",\n        \"Brazilian reals1.00\",\n        \"British Pound1.00\",\n        \"British pound1.00\",\n        \"British pounds1.00\",\n        \"Brunei Dollar1.00\",\n        \"Brunei dollar1.00\",\n        \"Brunei dollars1.00\",\n        \"Bulgarian Hard Lev1.00\",\n        \"Bulgarian Lev1.00\",\n        \"Bulgarian Leva1.00\",\n        \"Bulgarian hard lev1.00\",\n        \"Bulgarian hard leva1.00\",\n        \"Bulgarian lev1.00\",\n        \"Burmese Kyat1.00\",\n        \"Burmese kyat1.00\",\n        \"Burmese kyats1.00\",\n        \"Burundian Franc1.00\",\n        \"Burundian franc1.00\",\n        \"Burundian francs1.00\",\n        \"CA$1.00\",\n        \"CAD1.00\",\n        \"CDF1.00\",\n        \"CDF1.00\",\n        \"West African CFA Franc1.00\",\n        \"Central African CFA Franc1.00\",\n        \"West African CFA franc1.00\",\n        \"Central African CFA franc1.00\",\n        \"West African CFA francs1.00\",\n        \"Central African CFA francs1.00\",\n        \"CFP Franc1.00\",\n        \"CFP franc1.00\",\n        \"CFP francs1.00\",\n        \"CFPF1.00\",\n        \"CHE1.00\",\n        \"CHE1.00\",\n        \"CHF1.00\",\n        \"CHW1.00\",\n        \"CHW1.00\",\n        \"CLF1.00\",\n        \"CLF1.00\",\n        \"CLP1.00\",\n        \"CNY1.00\",\n        \"COP1.00\",\n        \"COU1.00\",\n        \"COU1.00\",\n        \"CRC1.00\",\n        \"CSD1.00\",\n        \"CSD1.00\",\n        \"CSK1.00\",\n        \"CSK1.00\",\n        \"CUP1.00\",\n        \"CUP1.00\",\n        \"CVE1.00\",\n        \"CYP1.00\",\n        \"CZK1.00\",\n        \"Cambodian Riel1.00\",\n        \"Cambodian riel1.00\",\n        \"Cambodian riels1.00\",\n        \"Canadian Dollar1.00\",\n        \"Canadian dollar1.00\",\n        \"Canadian dollars1.00\",\n        \"Cape Verdean Escudo1.00\",\n        \"Cape Verdean escudo1.00\",\n        \"Cape Verdean escudos1.00\",\n        \"Cayman Islands Dollar1.00\",\n        \"Cayman Islands dollar1.00\",\n        \"Cayman Islands dollars1.00\",\n        \"Chilean Peso1.00\",\n        \"Chilean Unit of Account (UF)1.00\",\n        \"Chilean peso1.00\",\n        \"Chilean pesos1.00\",\n        \"Chilean unit of account (UF)1.00\",\n        \"Chilean units of account (UF)1.00\",\n        \"Chinese Yuan1.00\",\n        \"Chinese yuan1.00\",\n        \"Colombian Peso1.00\",\n        \"Colombian peso1.00\",\n        \"Colombian pesos1.00\",\n        \"Comorian Franc1.00\",\n        \"Comorian franc1.00\",\n        \"Comorian francs1.00\",\n        \"Congolese Franc1.00\",\n        \"Congolese franc1.00\",\n        \"Congolese francs1.00\",\n        \"Costa Rican Col\\\\u00f3n1.00\",\n        \"Costa Rican col\\\\u00f3n1.00\",\n        \"Costa Rican col\\\\u00f3ns1.00\",\n        \"Croatian Dinar1.00\",\n        \"Croatian Kuna1.00\",\n        \"Croatian dinar1.00\",\n        \"Croatian dinars1.00\",\n        \"Croatian kuna1.00\",\n        \"Croatian kunas1.00\",\n        \"Cuban Peso1.00\",\n        \"Cuban peso1.00\",\n        \"Cuban pesos1.00\",\n        \"Cypriot Pound1.00\",\n        \"Cypriot pound1.00\",\n        \"Cypriot pounds1.00\",\n        \"Czech Koruna1.00\",\n        \"Czech koruna1.00\",\n        \"Czech korunas1.00\",\n        \"Czechoslovak Hard Koruna1.00\",\n        \"Czechoslovak hard koruna1.00\",\n        \"Czechoslovak hard korunas1.00\",\n        \"DDM1.00\",\n        \"DDM1.00\",\n        \"DEM1.00\",\n        \"DEM1.00\",\n        \"DJF1.00\",\n        \"DKK1.00\",\n        \"DOP1.00\",\n        \"DZD1.00\",\n        \"Danish Krone1.00\",\n        \"Danish krone1.00\",\n        \"Danish kroner1.00\",\n        \"German Mark1.00\",\n        \"German mark1.00\",\n        \"German marks1.00\",\n        \"Djiboutian Franc1.00\",\n        \"Djiboutian franc1.00\",\n        \"Djiboutian francs1.00\",\n        \"Dominican Peso1.00\",\n        \"Dominican peso1.00\",\n        \"Dominican pesos1.00\",\n        \"EC$1.00\",\n        \"ECS1.00\",\n        \"ECS1.00\",\n        \"ECV1.00\",\n        \"ECV1.00\",\n        \"EEK1.00\",\n        \"EEK1.00\",\n        \"EGP1.00\",\n        \"EGP1.00\",\n        \"ERN1.00\",\n        \"ERN1.00\",\n        \"ESA1.00\",\n        \"ESA1.00\",\n        \"ESB1.00\",\n        \"ESB1.00\",\n        \"ESP1.00\",\n        \"ETB1.00\",\n        \"EUR1.00\",\n        \"East Caribbean Dollar1.00\",\n        \"East Caribbean dollar1.00\",\n        \"East Caribbean dollars1.00\",\n        \"East German Mark1.00\",\n        \"East German mark1.00\",\n        \"East German marks1.00\",\n        \"Ecuadorian Sucre1.00\",\n        \"Ecuadorian Unit of Constant Value1.00\",\n        \"Ecuadorian sucre1.00\",\n        \"Ecuadorian sucres1.00\",\n        \"Ecuadorian unit of constant value1.00\",\n        \"Ecuadorian units of constant value1.00\",\n        \"Egyptian Pound1.00\",\n        \"Egyptian pound1.00\",\n        \"Egyptian pounds1.00\",\n        \"Salvadoran Col\\\\u00f3n1.00\",\n        \"Salvadoran col\\\\u00f3n1.00\",\n        \"Salvadoran colones1.00\",\n        \"Equatorial Guinean Ekwele1.00\",\n        \"Equatorial Guinean ekwele1.00\",\n        \"Eritrean Nakfa1.00\",\n        \"Eritrean nakfa1.00\",\n        \"Eritrean nakfas1.00\",\n        \"Estonian Kroon1.00\",\n        \"Estonian kroon1.00\",\n        \"Estonian kroons1.00\",\n        \"Ethiopian Birr1.00\",\n        \"Ethiopian birr1.00\",\n        \"Ethiopian birrs1.00\",\n        \"Euro1.00\",\n        \"European Composite Unit1.00\",\n        \"European Currency Unit1.00\",\n        \"European Monetary Unit1.00\",\n        \"European Unit of Account (XBC)1.00\",\n        \"European Unit of Account (XBD)1.00\",\n        \"European composite unit1.00\",\n        \"European composite units1.00\",\n        \"European currency unit1.00\",\n        \"European currency units1.00\",\n        \"European monetary unit1.00\",\n        \"European monetary units1.00\",\n        \"European unit of account (XBC)1.00\",\n        \"European unit of account (XBD)1.00\",\n        \"European units of account (XBC)1.00\",\n        \"European units of account (XBD)1.00\",\n        \"FIM1.00\",\n        \"FIM1.00\",\n        \"FJD1.00\",\n        \"FKP1.00\",\n        \"FKP1.00\",\n        \"FRF1.00\",\n        \"FRF1.00\",\n        \"Falkland Islands Pound1.00\",\n        \"Falkland Islands pound1.00\",\n        \"Falkland Islands pounds1.00\",\n        \"Fijian Dollar1.00\",\n        \"Fijian dollar1.00\",\n        \"Fijian dollars1.00\",\n        \"Finnish Markka1.00\",\n        \"Finnish markka1.00\",\n        \"Finnish markkas1.00\",\n        \"CHF1.00\",\n        \"French Franc1.00\",\n        \"French Gold Franc1.00\",\n        \"French UIC-Franc1.00\",\n        \"French UIC-franc1.00\",\n        \"French UIC-francs1.00\",\n        \"French franc1.00\",\n        \"French francs1.00\",\n        \"French gold franc1.00\",\n        \"French gold francs1.00\",\n        \"GBP1.00\",\n        \"GEK1.00\",\n        \"GEK1.00\",\n        \"GEL1.00\",\n        \"GHC1.00\",\n        \"GHC1.00\",\n        \"GHS1.00\",\n        \"GIP1.00\",\n        \"GIP1.00\",\n        \"GMD1.00\",\n        \"GMD1.00\",\n        \"GNF1.00\",\n        \"GNS1.00\",\n        \"GNS1.00\",\n        \"GQE1.00\",\n        \"GQE1.00\",\n        \"GRD1.00\",\n        \"GRD1.00\",\n        \"GTQ1.00\",\n        \"GWE1.00\",\n        \"GWE1.00\",\n        \"GWP1.00\",\n        \"GWP1.00\",\n        \"GYD1.00\",\n        \"Gambian Dalasi1.00\",\n        \"Gambian dalasi1.00\",\n        \"Gambian dalasis1.00\",\n        \"Georgian Kupon Larit1.00\",\n        \"Georgian Lari1.00\",\n        \"Georgian kupon larit1.00\",\n        \"Georgian kupon larits1.00\",\n        \"Georgian lari1.00\",\n        \"Georgian laris1.00\",\n        \"Ghanaian Cedi (1979\\\\u20132007)1.00\",\n        \"Ghanaian Cedi1.00\",\n        \"Ghanaian cedi (1979\\\\u20132007)1.00\",\n        \"Ghanaian cedi1.00\",\n        \"Ghanaian cedis (1979\\\\u20132007)1.00\",\n        \"Ghanaian cedis1.00\",\n        \"Gibraltar Pound1.00\",\n        \"Gibraltar pound1.00\",\n        \"Gibraltar pounds1.00\",\n        \"Gold1.00\",\n        \"Gold1.00\",\n        \"Greek Drachma1.00\",\n        \"Greek drachma1.00\",\n        \"Greek drachmas1.00\",\n        \"Guatemalan Quetzal1.00\",\n        \"Guatemalan quetzal1.00\",\n        \"Guatemalan quetzals1.00\",\n        \"Guinean Franc1.00\",\n        \"Guinean Syli1.00\",\n        \"Guinean franc1.00\",\n        \"Guinean francs1.00\",\n        \"Guinean syli1.00\",\n        \"Guinean sylis1.00\",\n        \"Guinea-Bissau Peso1.00\",\n        \"Guinea-Bissau peso1.00\",\n        \"Guinea-Bissau pesos1.00\",\n        \"Guyanaese Dollar1.00\",\n        \"Guyanaese dollar1.00\",\n        \"Guyanaese dollars1.00\",\n        \"HK$1.00\",\n        \"HKD1.00\",\n        \"HNL1.00\",\n        \"HRD1.00\",\n        \"HRD1.00\",\n        \"HRK1.00\",\n        \"HRK1.00\",\n        \"HTG1.00\",\n        \"HTG1.00\",\n        \"HUF1.00\",\n        \"Haitian Gourde1.00\",\n        \"Haitian gourde1.00\",\n        \"Haitian gourdes1.00\",\n        \"Honduran Lempira1.00\",\n        \"Honduran lempira1.00\",\n        \"Honduran lempiras1.00\",\n        \"Hong Kong Dollar1.00\",\n        \"Hong Kong dollar1.00\",\n        \"Hong Kong dollars1.00\",\n        \"Hungarian Forint1.00\",\n        \"Hungarian forint1.00\",\n        \"Hungarian forints1.00\",\n        \"IDR1.00\",\n        \"IEP1.00\",\n        \"ILP1.00\",\n        \"ILP1.00\",\n        \"ILS1.00\",\n        \"INR1.00\",\n        \"IQD1.00\",\n        \"IRR1.00\",\n        \"ISK1.00\",\n        \"ISK1.00\",\n        \"ITL1.00\",\n        \"Icelandic Kr\\\\u00f3na1.00\",\n        \"Icelandic kr\\\\u00f3na1.00\",\n        \"Icelandic kr\\\\u00f3nur1.00\",\n        \"Indian Rupee1.00\",\n        \"Indian rupee1.00\",\n        \"Indian rupees1.00\",\n        \"Indonesian Rupiah1.00\",\n        \"Indonesian rupiah1.00\",\n        \"Indonesian rupiahs1.00\",\n        \"Iranian Rial1.00\",\n        \"Iranian rial1.00\",\n        \"Iranian rials1.00\",\n        \"Iraqi Dinar1.00\",\n        \"Iraqi dinar1.00\",\n        \"Iraqi dinars1.00\",\n        \"Irish Pound1.00\",\n        \"Irish pound1.00\",\n        \"Irish pounds1.00\",\n        \"Israeli Pound1.00\",\n        \"Israeli new shekel1.00\",\n        \"Israeli pound1.00\",\n        \"Israeli pounds1.00\",\n        \"Italian Lira1.00\",\n        \"Italian lira1.00\",\n        \"Italian liras1.00\",\n        \"JMD1.00\",\n        \"JOD1.00\",\n        \"JPY1.00\",\n        \"Jamaican Dollar1.00\",\n        \"Jamaican dollar1.00\",\n        \"Jamaican dollars1.00\",\n        \"Japanese Yen1.00\",\n        \"Japanese yen1.00\",\n        \"Jordanian Dinar1.00\",\n        \"Jordanian dinar1.00\",\n        \"Jordanian dinars1.00\",\n        \"KES1.00\",\n        \"KGS1.00\",\n        \"KHR1.00\",\n        \"KMF1.00\",\n        \"KPW1.00\",\n        \"KPW1.00\",\n        \"KRW1.00\",\n        \"KWD1.00\",\n        \"KYD1.00\",\n        \"KYD1.00\",\n        \"KZT1.00\",\n        \"Kazakhstani Tenge1.00\",\n        \"Kazakhstani tenge1.00\",\n        \"Kazakhstani tenges1.00\",\n        \"Kenyan Shilling1.00\",\n        \"Kenyan shilling1.00\",\n        \"Kenyan shillings1.00\",\n        \"Kuwaiti Dinar1.00\",\n        \"Kuwaiti dinar1.00\",\n        \"Kuwaiti dinars1.00\",\n        \"Kyrgystani Som1.00\",\n        \"Kyrgystani som1.00\",\n        \"Kyrgystani soms1.00\",\n        \"HNL1.00\",\n        \"LAK1.00\",\n        \"LAK1.00\",\n        \"LBP1.00\",\n        \"LKR1.00\",\n        \"LRD1.00\",\n        \"LRD1.00\",\n        \"LSL1.00\",\n        \"LTL1.00\",\n        \"LTL1.00\",\n        \"LTT1.00\",\n        \"LTT1.00\",\n        \"LUC1.00\",\n        \"LUC1.00\",\n        \"LUF1.00\",\n        \"LUF1.00\",\n        \"LUL1.00\",\n        \"LUL1.00\",\n        \"LVL1.00\",\n        \"LVL1.00\",\n        \"LVR1.00\",\n        \"LVR1.00\",\n        \"LYD1.00\",\n        \"Laotian Kip1.00\",\n        \"Laotian kip1.00\",\n        \"Laotian kips1.00\",\n        \"Latvian Lats1.00\",\n        \"Latvian Ruble1.00\",\n        \"Latvian lats1.00\",\n        \"Latvian lati1.00\",\n        \"Latvian ruble1.00\",\n        \"Latvian rubles1.00\",\n        \"Lebanese Pound1.00\",\n        \"Lebanese pound1.00\",\n        \"Lebanese pounds1.00\",\n        \"Lesotho Loti1.00\",\n        \"Lesotho loti1.00\",\n        \"Lesotho lotis1.00\",\n        \"Liberian Dollar1.00\",\n        \"Liberian dollar1.00\",\n        \"Liberian dollars1.00\",\n        \"Libyan Dinar1.00\",\n        \"Libyan dinar1.00\",\n        \"Libyan dinars1.00\",\n        \"Lithuanian Litas1.00\",\n        \"Lithuanian Talonas1.00\",\n        \"Lithuanian litas1.00\",\n        \"Lithuanian litai1.00\",\n        \"Lithuanian talonas1.00\",\n        \"Lithuanian talonases1.00\",\n        \"Luxembourgian Convertible Franc1.00\",\n        \"Luxembourg Financial Franc1.00\",\n        \"Luxembourgian Franc1.00\",\n        \"Luxembourgian convertible franc1.00\",\n        \"Luxembourgian convertible francs1.00\",\n        \"Luxembourg financial franc1.00\",\n        \"Luxembourg financial francs1.00\",\n        \"Luxembourgian franc1.00\",\n        \"Luxembourgian francs1.00\",\n        \"MAD1.00\",\n        \"MAD1.00\",\n        \"MAF1.00\",\n        \"MAF1.00\",\n        \"MDL1.00\",\n        \"MDL1.00\",\n        \"MX$1.00\",\n        \"MGA1.00\",\n        \"MGA1.00\",\n        \"MGF1.00\",\n        \"MGF1.00\",\n        \"MKD1.00\",\n        \"MLF1.00\",\n        \"MLF1.00\",\n        \"MMK1.00\",\n        \"MMK1.00\",\n        \"MNT1.00\",\n        \"MOP1.00\",\n        \"MOP1.00\",\n        \"MRO1.00\",\n        \"MTL1.00\",\n        \"MTP1.00\",\n        \"MTP1.00\",\n        \"MUR1.00\",\n        \"MUR1.00\",\n        \"MVR1.00\",\n        \"MVR1.00\",\n        \"MWK1.00\",\n        \"MXN1.00\",\n        \"MXP1.00\",\n        \"MXP1.00\",\n        \"MXV1.00\",\n        \"MXV1.00\",\n        \"MYR1.00\",\n        \"MZE1.00\",\n        \"MZE1.00\",\n        \"MZM1.00\",\n        \"MZN1.00\",\n        \"Macanese Pataca1.00\",\n        \"Macanese pataca1.00\",\n        \"Macanese patacas1.00\",\n        \"Macedonian Denar1.00\",\n        \"Macedonian denar1.00\",\n        \"Macedonian denari1.00\",\n        \"Malagasy Ariaries1.00\",\n        \"Malagasy Ariary1.00\",\n        \"Malagasy Ariary1.00\",\n        \"Malagasy Franc1.00\",\n        \"Malagasy franc1.00\",\n        \"Malagasy francs1.00\",\n        \"Malawian Kwacha1.00\",\n        \"Malawian Kwacha1.00\",\n        \"Malawian Kwachas1.00\",\n        \"Malaysian Ringgit1.00\",\n        \"Malaysian ringgit1.00\",\n        \"Malaysian ringgits1.00\",\n        \"Maldivian Rufiyaa1.00\",\n        \"Maldivian rufiyaa1.00\",\n        \"Maldivian rufiyaas1.00\",\n        \"Malian Franc1.00\",\n        \"Malian franc1.00\",\n        \"Malian francs1.00\",\n        \"Maltese Lira1.00\",\n        \"Maltese Pound1.00\",\n        \"Maltese lira1.00\",\n        \"Maltese lira1.00\",\n        \"Maltese pound1.00\",\n        \"Maltese pounds1.00\",\n        \"Mauritanian Ouguiya1.00\",\n        \"Mauritanian ouguiya1.00\",\n        \"Mauritanian ouguiyas1.00\",\n        \"Mauritian Rupee1.00\",\n        \"Mauritian rupee1.00\",\n        \"Mauritian rupees1.00\",\n        \"Mexican Peso1.00\",\n        \"Mexican Silver Peso (1861\\\\u20131992)1.00\",\n        \"Mexican Investment Unit1.00\",\n        \"Mexican peso1.00\",\n        \"Mexican pesos1.00\",\n        \"Mexican silver peso (1861\\\\u20131992)1.00\",\n        \"Mexican silver pesos (1861\\\\u20131992)1.00\",\n        \"Mexican investment unit1.00\",\n        \"Mexican investment units1.00\",\n        \"Moldovan Leu1.00\",\n        \"Moldovan leu1.00\",\n        \"Moldovan lei1.00\",\n        \"Mongolian Tugrik1.00\",\n        \"Mongolian tugrik1.00\",\n        \"Mongolian tugriks1.00\",\n        \"Moroccan Dirham1.00\",\n        \"Moroccan Franc1.00\",\n        \"Moroccan dirham1.00\",\n        \"Moroccan dirhams1.00\",\n        \"Moroccan franc1.00\",\n        \"Moroccan francs1.00\",\n        \"Mozambican Escudo1.00\",\n        \"Mozambican Metical1.00\",\n        \"Mozambican escudo1.00\",\n        \"Mozambican escudos1.00\",\n        \"Mozambican metical1.00\",\n        \"Mozambican meticals1.00\",\n        \"Myanmar Kyat1.00\",\n        \"Myanmar kyat1.00\",\n        \"Myanmar kyats1.00\",\n        \"NAD1.00\",\n        \"NGN1.00\",\n        \"NIC1.00\",\n        \"NIO1.00\",\n        \"NIO1.00\",\n        \"NLG1.00\",\n        \"NLG1.00\",\n        \"NOK1.00\",\n        \"NPR1.00\",\n        \"NT$1.00\",\n        \"NZ$1.00\",\n        \"NZD1.00\",\n        \"Namibian Dollar1.00\",\n        \"Namibian dollar1.00\",\n        \"Namibian dollars1.00\",\n        \"Nepalese Rupee1.00\",\n        \"Nepalese rupee1.00\",\n        \"Nepalese rupees1.00\",\n        \"Netherlands Antillean Guilder1.00\",\n        \"Netherlands Antillean guilder1.00\",\n        \"Netherlands Antillean guilders1.00\",\n        \"Dutch Guilder1.00\",\n        \"Dutch guilder1.00\",\n        \"Dutch guilders1.00\",\n        \"Israeli New Shekel1.00\",\n        \"Israeli New Shekels1.00\",\n        \"New Zealand Dollar1.00\",\n        \"New Zealand dollar1.00\",\n        \"New Zealand dollars1.00\",\n        \"Nicaraguan C\\\\u00f3rdoba1.00\",\n        \"Nicaraguan C\\\\u00f3rdoba (1988\\\\u20131991)1.00\",\n        \"Nicaraguan c\\\\u00f3rdoba1.00\",\n        \"Nicaraguan c\\\\u00f3rdobas1.00\",\n        \"Nicaraguan c\\\\u00f3rdoba (1988\\\\u20131991)1.00\",\n        \"Nicaraguan c\\\\u00f3rdobas (1988\\\\u20131991)1.00\",\n        \"Nigerian Naira1.00\",\n        \"Nigerian naira1.00\",\n        \"Nigerian nairas1.00\",\n        \"North Korean Won1.00\",\n        \"North Korean won1.00\",\n        \"North Korean won1.00\",\n        \"Norwegian Krone1.00\",\n        \"Norwegian krone1.00\",\n        \"Norwegian kroner1.00\",\n        \"OMR1.00\",\n        \"Mozambican Metical (1980\\\\u20132006)1.00\",\n        \"Mozambican metical (1980\\\\u20132006)1.00\",\n        \"Mozambican meticals (1980\\\\u20132006)1.00\",\n        \"Romanian Lei (1952\\\\u20132006)1.00\",\n        \"Romanian Leu (1952\\\\u20132006)1.00\",\n        \"Romanian leu (1952\\\\u20132006)1.00\",\n        \"Serbian Dinar (2002\\\\u20132006)1.00\",\n        \"Serbian dinar (2002\\\\u20132006)1.00\",\n        \"Serbian dinars (2002\\\\u20132006)1.00\",\n        \"Sudanese Dinar (1992\\\\u20132007)1.00\",\n        \"Sudanese Pound (1957\\\\u20131998)1.00\",\n        \"Sudanese dinar (1992\\\\u20132007)1.00\",\n        \"Sudanese dinars (1992\\\\u20132007)1.00\",\n        \"Sudanese pound (1957\\\\u20131998)1.00\",\n        \"Sudanese pounds (1957\\\\u20131998)1.00\",\n        \"Turkish Lira (1922\\\\u20132005)1.00\",\n        \"Turkish Lira (1922\\\\u20132005)1.00\",\n        \"Omani Rial1.00\",\n        \"Omani rial1.00\",\n        \"Omani rials1.00\",\n        \"PAB1.00\",\n        \"PAB1.00\",\n        \"PEI1.00\",\n        \"PEI1.00\",\n        \"PEN1.00\",\n        \"PEN1.00\",\n        \"PES1.00\",\n        \"PES1.00\",\n        \"PGK1.00\",\n        \"PGK1.00\",\n        \"PHP1.00\",\n        \"PKR1.00\",\n        \"PLN1.00\",\n        \"PLZ1.00\",\n        \"PLZ1.00\",\n        \"PTE1.00\",\n        \"PTE1.00\",\n        \"PYG1.00\",\n        \"Pakistani Rupee1.00\",\n        \"Pakistani rupee1.00\",\n        \"Pakistani rupees1.00\",\n        \"Palladium1.00\",\n        \"Palladium1.00\",\n        \"Panamanian Balboa1.00\",\n        \"Panamanian balboa1.00\",\n        \"Panamanian balboas1.00\",\n        \"Papua New Guinean Kina1.00\",\n        \"Papua New Guinean kina1.00\",\n        \"Papua New Guinean kina1.00\",\n        \"Paraguayan Guarani1.00\",\n        \"Paraguayan guarani1.00\",\n        \"Paraguayan guaranis1.00\",\n        \"Peruvian Inti1.00\",\n        \"Peruvian Sol1.00\",\n        \"Peruvian Sol (1863\\\\u20131965)1.00\",\n        \"Peruvian inti1.00\",\n        \"Peruvian intis1.00\",\n        \"Peruvian sol1.00\",\n        \"Peruvian soles1.00\",\n        \"Peruvian sol (1863\\\\u20131965)1.00\",\n        \"Peruvian soles (1863\\\\u20131965)1.00\",\n        \"Philippine Piso1.00\",\n        \"Philippine piso1.00\",\n        \"Philippine pisos1.00\",\n        \"Platinum1.00\",\n        \"Platinum1.00\",\n        \"Polish Zloty (1950\\\\u20131995)1.00\",\n        \"Polish Zloty1.00\",\n        \"Polish zlotys1.00\",\n        \"Polish zloty (PLZ)1.00\",\n        \"Polish zloty1.00\",\n        \"Polish zlotys (PLZ)1.00\",\n        \"Portuguese Escudo1.00\",\n        \"Portuguese Guinea Escudo1.00\",\n        \"Portuguese Guinea escudo1.00\",\n        \"Portuguese Guinea escudos1.00\",\n        \"Portuguese escudo1.00\",\n        \"Portuguese escudos1.00\",\n        \"GTQ1.00\",\n        \"QAR1.00\",\n        \"Qatari Rial1.00\",\n        \"Qatari rial1.00\",\n        \"Qatari rials1.00\",\n        \"RHD1.00\",\n        \"RHD1.00\",\n        \"RINET Funds1.00\",\n        \"RINET Funds1.00\",\n        \"CN\\\\u00a51.00\",\n        \"ROL1.00\",\n        \"ROL1.00\",\n        \"RON1.00\",\n        \"RON1.00\",\n        \"RSD1.00\",\n        \"RSD1.00\",\n        \"RUB1.00\",\n        \"RUR1.00\",\n        \"RUR1.00\",\n        \"RWF1.00\",\n        \"RWF1.00\",\n        \"Rhodesian Dollar1.00\",\n        \"Rhodesian dollar1.00\",\n        \"Rhodesian dollars1.00\",\n        \"Romanian Leu1.00\",\n        \"Romanian lei1.00\",\n        \"Romanian leu1.00\",\n        \"Russian Ruble (1991\\\\u20131998)1.00\",\n        \"Russian Ruble1.00\",\n        \"Russian ruble (1991\\\\u20131998)1.00\",\n        \"Russian ruble1.00\",\n        \"Russian rubles (1991\\\\u20131998)1.00\",\n        \"Russian rubles1.00\",\n        \"Rwandan Franc1.00\",\n        \"Rwandan franc1.00\",\n        \"Rwandan francs1.00\",\n        \"SAR1.00\",\n        \"SBD1.00\",\n        \"SCR1.00\",\n        \"SDD1.00\",\n        \"SDD1.00\",\n        \"SDG1.00\",\n        \"SDG1.00\",\n        \"SDP1.00\",\n        \"SDP1.00\",\n        \"SEK1.00\",\n        \"SGD1.00\",\n        \"SHP1.00\",\n        \"SHP1.00\",\n        \"SIT1.00\",\n        \"SIT1.00\",\n        \"SKK1.00\",\n        \"SLL1.00\",\n        \"SLL1.00\",\n        \"SOS1.00\",\n        \"SRD1.00\",\n        \"SRD1.00\",\n        \"SRG1.00\",\n        \"STD1.00\",\n        \"SUR1.00\",\n        \"SUR1.00\",\n        \"SVC1.00\",\n        \"SVC1.00\",\n        \"SYP1.00\",\n        \"SZL1.00\",\n        \"St. Helena Pound1.00\",\n        \"St. Helena pound1.00\",\n        \"St. Helena pounds1.00\",\n        \"S\\\\u00e3o Tom\\\\u00e9 & Pr\\\\u00edncipe Dobra1.00\",\n        \"S\\\\u00e3o Tom\\\\u00e9 & Pr\\\\u00edncipe dobra1.00\",\n        \"S\\\\u00e3o Tom\\\\u00e9 & Pr\\\\u00edncipe dobras1.00\",\n        \"Saudi Riyal1.00\",\n        \"Saudi riyal1.00\",\n        \"Saudi riyals1.00\",\n        \"Serbian Dinar1.00\",\n        \"Serbian dinar1.00\",\n        \"Serbian dinars1.00\",\n        \"Seychellois Rupee1.00\",\n        \"Seychellois rupee1.00\",\n        \"Seychellois rupees1.00\",\n        \"Sierra Leonean Leone1.00\",\n        \"Sierra Leonean leone1.00\",\n        \"Sierra Leonean leones1.00\",\n        \"Silver1.00\",\n        \"Silver1.00\",\n        \"Singapore Dollar1.00\",\n        \"Singapore dollar1.00\",\n        \"Singapore dollars1.00\",\n        \"Slovak Koruna1.00\",\n        \"Slovak koruna1.00\",\n        \"Slovak korunas1.00\",\n        \"Slovenian Tolar1.00\",\n        \"Slovenian tolar1.00\",\n        \"Slovenian tolars1.00\",\n        \"Solomon Islands Dollar1.00\",\n        \"Solomon Islands dollar1.00\",\n        \"Solomon Islands dollars1.00\",\n        \"Somali Shilling1.00\",\n        \"Somali shilling1.00\",\n        \"Somali shillings1.00\",\n        \"South African Rand (financial)1.00\",\n        \"South African Rand1.00\",\n        \"South African rand (financial)1.00\",\n        \"South African rand1.00\",\n        \"South African rands (financial)1.00\",\n        \"South African rand1.00\",\n        \"South Korean Won1.00\",\n        \"South Korean won1.00\",\n        \"South Korean won1.00\",\n        \"Soviet Rouble1.00\",\n        \"Soviet rouble1.00\",\n        \"Soviet roubles1.00\",\n        \"Spanish Peseta (A account)1.00\",\n        \"Spanish Peseta (convertible account)1.00\",\n        \"Spanish Peseta1.00\",\n        \"Spanish peseta (A account)1.00\",\n        \"Spanish peseta (convertible account)1.00\",\n        \"Spanish peseta1.00\",\n        \"Spanish pesetas (A account)1.00\",\n        \"Spanish pesetas (convertible account)1.00\",\n        \"Spanish pesetas1.00\",\n        \"Special Drawing Rights1.00\",\n        \"Sri Lankan Rupee1.00\",\n        \"Sri Lankan rupee1.00\",\n        \"Sri Lankan rupees1.00\",\n        \"Sudanese Pound1.00\",\n        \"Sudanese pound1.00\",\n        \"Sudanese pounds1.00\",\n        \"Surinamese Dollar1.00\",\n        \"Surinamese dollar1.00\",\n        \"Surinamese dollars1.00\",\n        \"Surinamese Guilder1.00\",\n        \"Surinamese guilder1.00\",\n        \"Surinamese guilders1.00\",\n        \"Swazi Lilangeni1.00\",\n        \"Swazi lilangeni1.00\",\n        \"Swazi emalangeni1.00\",\n        \"Swedish Krona1.00\",\n        \"Swedish krona1.00\",\n        \"Swedish kronor1.00\",\n        \"Swiss Franc1.00\",\n        \"Swiss franc1.00\",\n        \"Swiss francs1.00\",\n        \"Syrian Pound1.00\",\n        \"Syrian pound1.00\",\n        \"Syrian pounds1.00\",\n        \"THB1.00\",\n        \"TJR1.00\",\n        \"TJR1.00\",\n        \"TJS1.00\",\n        \"TJS1.00\",\n        \"TMM1.00\",\n        \"TMM1.00\",\n        \"TND1.00\",\n        \"TND1.00\",\n        \"TOP1.00\",\n        \"TPE1.00\",\n        \"TPE1.00\",\n        \"TRL1.00\",\n        \"TRY1.00\",\n        \"TRY1.00\",\n        \"TTD1.00\",\n        \"TWD1.00\",\n        \"TZS1.00\",\n        \"New Taiwan Dollar1.00\",\n        \"New Taiwan dollar1.00\",\n        \"New Taiwan dollars1.00\",\n        \"Tajikistani Ruble1.00\",\n        \"Tajikistani Somoni1.00\",\n        \"Tajikistani ruble1.00\",\n        \"Tajikistani rubles1.00\",\n        \"Tajikistani somoni1.00\",\n        \"Tajikistani somonis1.00\",\n        \"Tanzanian Shilling1.00\",\n        \"Tanzanian shilling1.00\",\n        \"Tanzanian shillings1.00\",\n        \"Testing Currency Code1.00\",\n        \"Testing Currency Code1.00\",\n        \"Thai Baht1.00\",\n        \"Thai baht1.00\",\n        \"Thai baht1.00\",\n        \"Timorese Escudo1.00\",\n        \"Timorese escudo1.00\",\n        \"Timorese escudos1.00\",\n        \"Tongan Pa\\\\u02bbanga1.00\",\n        \"Tongan pa\\\\u02bbanga1.00\",\n        \"Tongan pa\\\\u02bbanga1.00\",\n        \"Trinidad & Tobago Dollar1.00\",\n        \"Trinidad & Tobago dollar1.00\",\n        \"Trinidad & Tobago dollars1.00\",\n        \"Tunisian Dinar1.00\",\n        \"Tunisian dinar1.00\",\n        \"Tunisian dinars1.00\",\n        \"Turkish Lira1.00\",\n        \"Turkish Lira1.00\",\n        \"Turkish lira1.00\",\n        \"Turkmenistani Manat1.00\",\n        \"Turkmenistani manat1.00\",\n        \"Turkmenistani manat1.00\",\n        \"UAE dirham1.00\",\n        \"UAE dirhams1.00\",\n        \"UAH1.00\",\n        \"UAK1.00\",\n        \"UAK1.00\",\n        \"UGS1.00\",\n        \"UGS1.00\",\n        \"UGX1.00\",\n        \"US Dollar (Next day)1.00\",\n        \"US Dollar (Same day)1.00\",\n        \"US Dollar1.00\",\n        \"US dollar (next day)1.00\",\n        \"US dollar (same day)1.00\",\n        \"US dollar1.00\",\n        \"US dollars (next day)1.00\",\n        \"US dollars (same day)1.00\",\n        \"US dollars1.00\",\n        \"USD1.00\",\n        \"USN1.00\",\n        \"USN1.00\",\n        \"USS1.00\",\n        \"USS1.00\",\n        \"UYI1.00\",\n        \"UYI1.00\",\n        \"UYP1.00\",\n        \"UYP1.00\",\n        \"UYU1.00\",\n        \"UZS1.00\",\n        \"UZS1.00\",\n        \"Ugandan Shilling (1966\\\\u20131987)1.00\",\n        \"Ugandan Shilling1.00\",\n        \"Ugandan shilling (1966\\\\u20131987)1.00\",\n        \"Ugandan shilling1.00\",\n        \"Ugandan shillings (1966\\\\u20131987)1.00\",\n        \"Ugandan shillings1.00\",\n        \"Ukrainian Hryvnia1.00\",\n        \"Ukrainian Karbovanets1.00\",\n        \"Ukrainian hryvnia1.00\",\n        \"Ukrainian hryvnias1.00\",\n        \"Ukrainian karbovanets1.00\",\n        \"Ukrainian karbovantsiv1.00\",\n        \"Colombian Real Value Unit1.00\",\n        \"United Arab Emirates Dirham1.00\",\n        \"Unknown Currency1.00\",\n        \"Uruguayan Peso (1975\\\\u20131993)1.00\",\n        \"Uruguayan Peso1.00\",\n        \"Uruguayan Peso (Indexed Units)1.00\",\n        \"Uruguayan peso (1975\\\\u20131993)1.00\",\n        \"Uruguayan peso (indexed units)1.00\",\n        \"Uruguayan peso1.00\",\n        \"Uruguayan pesos (1975\\\\u20131993)1.00\",\n        \"Uruguayan pesos (indexed units)1.00\",\n        \"Uruguayan pesos1.00\",\n        \"Uzbekistani Som1.00\",\n        \"Uzbekistani som1.00\",\n        \"Uzbekistani som1.00\",\n        \"VEB1.00\",\n        \"VEF1.00\",\n        \"VND1.00\",\n        \"VUV1.00\",\n        \"Vanuatu Vatu1.00\",\n        \"Vanuatu vatu1.00\",\n        \"Vanuatu vatus1.00\",\n        \"Venezuelan Bol\\\\u00edvar1.00\",\n        \"Venezuelan Bol\\\\u00edvar (1871\\\\u20132008)1.00\",\n        \"Venezuelan bol\\\\u00edvar1.00\",\n        \"Venezuelan bol\\\\u00edvars1.00\",\n        \"Venezuelan bol\\\\u00edvar (1871\\\\u20132008)1.00\",\n        \"Venezuelan bol\\\\u00edvars (1871\\\\u20132008)1.00\",\n        \"Vietnamese Dong1.00\",\n        \"Vietnamese dong1.00\",\n        \"Vietnamese dong1.00\",\n        \"WIR Euro1.00\",\n        \"WIR Franc1.00\",\n        \"WIR euro1.00\",\n        \"WIR euros1.00\",\n        \"WIR franc1.00\",\n        \"WIR francs1.00\",\n        \"WST1.00\",\n        \"WST1.00\",\n        \"Samoan Tala1.00\",\n        \"Samoan tala1.00\",\n        \"Samoan tala1.00\",\n        \"XAF1.00\",\n        \"XAF1.00\",\n        \"XAG1.00\",\n        \"XAG1.00\",\n        \"XAU1.00\",\n        \"XAU1.00\",\n        \"XBA1.00\",\n        \"XBA1.00\",\n        \"XBB1.00\",\n        \"XBB1.00\",\n        \"XBC1.00\",\n        \"XBC1.00\",\n        \"XBD1.00\",\n        \"XBD1.00\",\n        \"XCD1.00\",\n        \"XDR1.00\",\n        \"XDR1.00\",\n        \"XEU1.00\",\n        \"XEU1.00\",\n        \"XFO1.00\",\n        \"XFO1.00\",\n        \"XFU1.00\",\n        \"XFU1.00\",\n        \"XOF1.00\",\n        \"XOF1.00\",\n        \"XPD1.00\",\n        \"XPD1.00\",\n        \"XPF1.00\",\n        \"XPT1.00\",\n        \"XPT1.00\",\n        \"XRE1.00\",\n        \"XRE1.00\",\n        \"XTS1.00\",\n        \"XTS1.00\",\n        \"XXX1.00\",\n        \"XXX1.00\",\n        \"YDD1.00\",\n        \"YDD1.00\",\n        \"YER1.00\",\n        \"YUD1.00\",\n        \"YUD1.00\",\n        \"YUM1.00\",\n        \"YUM1.00\",\n        \"YUN1.00\",\n        \"YUN1.00\",\n        \"Yemeni Dinar1.00\",\n        \"Yemeni Rial1.00\",\n        \"Yemeni dinar1.00\",\n        \"Yemeni dinars1.00\",\n        \"Yemeni rial1.00\",\n        \"Yemeni rials1.00\",\n        \"Yugoslavian Convertible Dinar (1990\\\\u20131992)1.00\",\n        \"Yugoslavian Hard Dinar (1966\\\\u20131990)1.00\",\n        \"Yugoslavian New Dinar (1994\\\\u20132002)1.00\",\n        \"Yugoslavian convertible dinar (1990\\\\u20131992)1.00\",\n        \"Yugoslavian convertible dinars (1990\\\\u20131992)1.00\",\n        \"Yugoslavian hard dinar (1966\\\\u20131990)1.00\",\n        \"Yugoslavian hard dinars (1966\\\\u20131990)1.00\",\n        \"Yugoslavian new dinar (1994\\\\u20132002)1.00\",\n        \"Yugoslavian new dinars (1994\\\\u20132002)1.00\",\n        \"ZAL1.00\",\n        \"ZAL1.00\",\n        \"ZAR1.00\",\n        \"ZMK1.00\",\n        \"ZMK1.00\",\n        \"ZRN1.00\",\n        \"ZRN1.00\",\n        \"ZRZ1.00\",\n        \"ZRZ1.00\",\n        \"ZWD1.00\",\n        \"Zairean New Zaire (1993\\\\u20131998)1.00\",\n        \"Zairean Zaire (1971\\\\u20131993)1.00\",\n        \"Zairean new zaire (1993\\\\u20131998)1.00\",\n        \"Zairean new zaires (1993\\\\u20131998)1.00\",\n        \"Zairean zaire (1971\\\\u20131993)1.00\",\n        \"Zairean zaires (1971\\\\u20131993)1.00\",\n        \"Zambian Kwacha1.00\",\n        \"Zambian kwacha1.00\",\n        \"Zambian kwachas1.00\",\n        \"Zimbabwean Dollar (1980\\\\u20132008)1.00\",\n        \"Zimbabwean dollar (1980\\\\u20132008)1.00\",\n        \"Zimbabwean dollars (1980\\\\u20132008)1.00\",\n        \"euro1.00\",\n        \"euros1.00\",\n        \"Turkish lira (1922\\\\u20132005)1.00\",\n        \"special drawing rights1.00\",\n        \"Colombian real value unit1.00\",\n        \"Colombian real value units1.00\",\n        \"unknown currency1.00\",\n        \"\\\\u00a31.00\",\n        \"\\\\u00a51.00\",\n        \"\\\\u20ab1.00\",\n        \"\\\\u20aa1.00\",\n        \"\\\\u20ac1.00\",\n        \"\\\\u20b91.00\",\n        //\n        // Following has extra text, should be parsed correctly too\n        \"$1.00 random\",\n        \"USD1.00 random\",\n        \"1.00 US dollar random\",\n        \"1.00 US dollars random\",\n        \"1.00 Afghan Afghani random\",\n        \"1.00 Afghan Afghani random\",\n        \"1.00 Afghan Afghanis (1927\\\\u20131992) random\",\n        \"1.00 Afghan Afghanis random\",\n        \"1.00 Albanian Lek random\",\n        \"1.00 Albanian lek random\",\n        \"1.00 Albanian lek\\\\u00eb random\",\n        \"1.00 Algerian Dinar random\",\n        \"1.00 Algerian dinar random\",\n        \"1.00 Algerian dinars random\",\n        \"1.00 Andorran Peseta random\",\n        \"1.00 Andorran peseta random\",\n        \"1.00 Andorran pesetas random\",\n        \"1.00 Angolan Kwanza (1977\\\\u20131990) random\",\n        \"1.00 Angolan Readjusted Kwanza (1995\\\\u20131999) random\",\n        \"1.00 Angolan Kwanza random\",\n        \"1.00 Angolan New Kwanza (1990\\\\u20132000) random\",\n        \"1.00 Angolan kwanza (1977\\\\u20131991) random\",\n        \"1.00 Angolan readjusted kwanza (1995\\\\u20131999) random\",\n        \"1.00 Angolan kwanza random\",\n        \"1.00 Angolan kwanzas (1977\\\\u20131991) random\",\n        \"1.00 Angolan readjusted kwanzas (1995\\\\u20131999) random\",\n        \"1.00 Angolan kwanzas random\",\n        \"1.00 Angolan new kwanza (1990\\\\u20132000) random\",\n        \"1.00 Angolan new kwanzas (1990\\\\u20132000) random\",\n        \"1.00 Argentine Austral random\",\n        \"1.00 Argentine Peso (1983\\\\u20131985) random\",\n        \"1.00 Argentine Peso random\",\n        \"1.00 Argentine austral random\",\n        \"1.00 Argentine australs random\",\n        \"1.00 Argentine peso (1983\\\\u20131985) random\",\n        \"1.00 Argentine peso random\",\n        \"1.00 Argentine pesos (1983\\\\u20131985) random\",\n        \"1.00 Argentine pesos random\",\n        \"1.00 Armenian Dram random\",\n        \"1.00 Armenian dram random\",\n        \"1.00 Armenian drams random\",\n        \"1.00 Aruban Florin random\",\n        \"1.00 Aruban florin random\",\n        \"1.00 Australian Dollar random\",\n        \"1.00 Australian dollar random\",\n        \"1.00 Australian dollars random\",\n        \"1.00 Austrian Schilling random\",\n        \"1.00 Austrian schilling random\",\n        \"1.00 Austrian schillings random\",\n        \"1.00 Azerbaijani Manat (1993\\\\u20132006) random\",\n        \"1.00 Azerbaijani Manat random\",\n        \"1.00 Azerbaijani manat (1993\\\\u20132006) random\",\n        \"1.00 Azerbaijani manat random\",\n        \"1.00 Azerbaijani manats (1993\\\\u20132006) random\",\n        \"1.00 Azerbaijani manats random\",\n        \"1.00 Bahamian Dollar random\",\n        \"1.00 Bahamian dollar random\",\n        \"1.00 Bahamian dollars random\",\n        \"1.00 Bahraini Dinar random\",\n        \"1.00 Bahraini dinar random\",\n        \"1.00 Bahraini dinars random\",\n        \"1.00 Bangladeshi Taka random\",\n        \"1.00 Bangladeshi taka random\",\n        \"1.00 Bangladeshi takas random\",\n        \"1.00 Barbadian Dollar random\",\n        \"1.00 Barbadian dollar random\",\n        \"1.00 Barbadian dollars random\",\n        \"1.00 Belarusian Ruble (1994\\\\u20131999) random\",\n        \"1.00 Belarusian Ruble random\",\n        \"1.00 Belarusian ruble (1994\\\\u20131999) random\",\n        \"1.00 Belarusian rubles (1994\\\\u20131999) random\",\n        \"1.00 Belarusian ruble random\",\n        \"1.00 Belarusian rubles random\",\n        \"1.00 Belgian Franc (convertible) random\",\n        \"1.00 Belgian Franc (financial) random\",\n        \"1.00 Belgian Franc random\",\n        \"1.00 Belgian franc (convertible) random\",\n        \"1.00 Belgian franc (financial) random\",\n        \"1.00 Belgian franc random\",\n        \"1.00 Belgian francs (convertible) random\",\n        \"1.00 Belgian francs (financial) random\",\n        \"1.00 Belgian francs random\",\n        \"1.00 Belize Dollar random\",\n        \"1.00 Belize dollar random\",\n        \"1.00 Belize dollars random\",\n        \"1.00 Bermudan Dollar random\",\n        \"1.00 Bermudan dollar random\",\n        \"1.00 Bermudan dollars random\",\n        \"1.00 Bhutanese Ngultrum random\",\n        \"1.00 Bhutanese ngultrum random\",\n        \"1.00 Bhutanese ngultrums random\",\n        \"1.00 Bolivian Mvdol random\",\n        \"1.00 Bolivian Peso random\",\n        \"1.00 Bolivian mvdol random\",\n        \"1.00 Bolivian mvdols random\",\n        \"1.00 Bolivian peso random\",\n        \"1.00 Bolivian pesos random\",\n        \"1.00 Bolivian Boliviano random\",\n        \"1.00 Bolivian Boliviano random\",\n        \"1.00 Bolivian Bolivianos random\",\n        \"1.00 Bosnia-Herzegovina Convertible Mark random\",\n        \"1.00 Bosnia-Herzegovina Dinar (1992\\\\u20131994) random\",\n        \"1.00 Bosnia-Herzegovina convertible mark random\",\n        \"1.00 Bosnia-Herzegovina convertible marks random\",\n        \"1.00 Bosnia-Herzegovina dinar (1992\\\\u20131994) random\",\n        \"1.00 Bosnia-Herzegovina dinars (1992\\\\u20131994) random\",\n        \"1.00 Botswanan Pula random\",\n        \"1.00 Botswanan pula random\",\n        \"1.00 Botswanan pulas random\",\n        \"1.00 Brazilian New Cruzado (1989\\\\u20131990) random\",\n        \"1.00 Brazilian Cruzado (1986\\\\u20131989) random\",\n        \"1.00 Brazilian Cruzeiro (1990\\\\u20131993) random\",\n        \"1.00 Brazilian New Cruzeiro (1967\\\\u20131986) random\",\n        \"1.00 Brazilian Cruzeiro (1993\\\\u20131994) random\",\n        \"1.00 Brazilian Real random\",\n        \"1.00 Brazilian new cruzado (1989\\\\u20131990) random\",\n        \"1.00 Brazilian new cruzados (1989\\\\u20131990) random\",\n        \"1.00 Brazilian cruzado (1986\\\\u20131989) random\",\n        \"1.00 Brazilian cruzados (1986\\\\u20131989) random\",\n        \"1.00 Brazilian cruzeiro (1990\\\\u20131993) random\",\n        \"1.00 Brazilian new cruzeiro (1967\\\\u20131986) random\",\n        \"1.00 Brazilian cruzeiro (1993\\\\u20131994) random\",\n        \"1.00 Brazilian cruzeiros (1990\\\\u20131993) random\",\n        \"1.00 Brazilian new cruzeiros (1967\\\\u20131986) random\",\n        \"1.00 Brazilian cruzeiros (1993\\\\u20131994) random\",\n        \"1.00 Brazilian real random\",\n        \"1.00 Brazilian reals random\",\n        \"1.00 British Pound random\",\n        \"1.00 British pound random\",\n        \"1.00 British pounds random\",\n        \"1.00 Brunei Dollar random\",\n        \"1.00 Brunei dollar random\",\n        \"1.00 Brunei dollars random\",\n        \"1.00 Bulgarian Hard Lev random\",\n        \"1.00 Bulgarian Lev random\",\n        \"1.00 Bulgarian Leva random\",\n        \"1.00 Bulgarian hard lev random\",\n        \"1.00 Bulgarian hard leva random\",\n        \"1.00 Bulgarian lev random\",\n        \"1.00 Burmese Kyat random\",\n        \"1.00 Burmese kyat random\",\n        \"1.00 Burmese kyats random\",\n        \"1.00 Burundian Franc random\",\n        \"1.00 Burundian franc random\",\n        \"1.00 Burundian francs random\",\n        \"1.00 Cambodian Riel random\",\n        \"1.00 Cambodian riel random\",\n        \"1.00 Cambodian riels random\",\n        \"1.00 Canadian Dollar random\",\n        \"1.00 Canadian dollar random\",\n        \"1.00 Canadian dollars random\",\n        \"1.00 Cape Verdean Escudo random\",\n        \"1.00 Cape Verdean escudo random\",\n        \"1.00 Cape Verdean escudos random\",\n        \"1.00 Cayman Islands Dollar random\",\n        \"1.00 Cayman Islands dollar random\",\n        \"1.00 Cayman Islands dollars random\",\n        \"1.00 Chilean Peso random\",\n        \"1.00 Chilean Unit of Account (UF) random\",\n        \"1.00 Chilean peso random\",\n        \"1.00 Chilean pesos random\",\n        \"1.00 Chilean unit of account (UF) random\",\n        \"1.00 Chilean units of account (UF) random\",\n        \"1.00 Chinese Yuan random\",\n        \"1.00 Chinese yuan random\",\n        \"1.00 Colombian Peso random\",\n        \"1.00 Colombian peso random\",\n        \"1.00 Colombian pesos random\",\n        \"1.00 Comorian Franc random\",\n        \"1.00 Comorian franc random\",\n        \"1.00 Comorian francs random\",\n        \"1.00 Congolese Franc Congolais random\",\n        \"1.00 Congolese franc Congolais random\",\n        \"1.00 Congolese francs Congolais random\",\n        \"1.00 Costa Rican Col\\\\u00f3n random\",\n        \"1.00 Costa Rican col\\\\u00f3n random\",\n        \"1.00 Costa Rican col\\\\u00f3ns random\",\n        \"1.00 Croatian Dinar random\",\n        \"1.00 Croatian Kuna random\",\n        \"1.00 Croatian dinar random\",\n        \"1.00 Croatian dinars random\",\n        \"1.00 Croatian kuna random\",\n        \"1.00 Croatian kunas random\",\n        \"1.00 Cuban Peso random\",\n        \"1.00 Cuban peso random\",\n        \"1.00 Cuban pesos random\",\n        \"1.00 Cypriot Pound random\",\n        \"1.00 Cypriot pound random\",\n        \"1.00 Cypriot pounds random\",\n        \"1.00 Czech Koruna random\",\n        \"1.00 Czech koruna random\",\n        \"1.00 Czech korunas random\",\n        \"1.00 Czechoslovak Hard Koruna random\",\n        \"1.00 Czechoslovak hard koruna random\",\n        \"1.00 Czechoslovak hard korunas random\",\n        \"1.00 Danish Krone random\",\n        \"1.00 Danish krone random\",\n        \"1.00 Danish kroner random\",\n        \"1.00 German Mark random\",\n        \"1.00 German mark random\",\n        \"1.00 German marks random\",\n        \"1.00 Djiboutian Franc random\",\n        \"1.00 Djiboutian franc random\",\n        \"1.00 Djiboutian francs random\",\n        \"1.00 Dominican Peso random\",\n        \"1.00 Dominican peso random\",\n        \"1.00 Dominican pesos random\",\n        \"1.00 East Caribbean Dollar random\",\n        \"1.00 East Caribbean dollar random\",\n        \"1.00 East Caribbean dollars random\",\n        \"1.00 East German Mark random\",\n        \"1.00 East German mark random\",\n        \"1.00 East German marks random\",\n        \"1.00 Ecuadorian Sucre random\",\n        \"1.00 Ecuadorian Unit of Constant Value random\",\n        \"1.00 Ecuadorian sucre random\",\n        \"1.00 Ecuadorian sucres random\",\n        \"1.00 Ecuadorian unit of constant value random\",\n        \"1.00 Ecuadorian units of constant value random\",\n        \"1.00 Egyptian Pound random\",\n        \"1.00 Egyptian pound random\",\n        \"1.00 Egyptian pounds random\",\n        \"1.00 Salvadoran Col\\\\u00f3n random\",\n        \"1.00 Salvadoran col\\\\u00f3n random\",\n        \"1.00 Salvadoran colones random\",\n        \"1.00 Equatorial Guinean Ekwele random\",\n        \"1.00 Equatorial Guinean ekwele random\",\n        \"1.00 Eritrean Nakfa random\",\n        \"1.00 Eritrean nakfa random\",\n        \"1.00 Eritrean nakfas random\",\n        \"1.00 Estonian Kroon random\",\n        \"1.00 Estonian kroon random\",\n        \"1.00 Estonian kroons random\",\n        \"1.00 Ethiopian Birr random\",\n        \"1.00 Ethiopian birr random\",\n        \"1.00 Ethiopian birrs random\",\n        \"1.00 European Composite Unit random\",\n        \"1.00 European Currency Unit random\",\n        \"1.00 European Monetary Unit random\",\n        \"1.00 European Unit of Account (XBC) random\",\n        \"1.00 European Unit of Account (XBD) random\",\n        \"1.00 European composite unit random\",\n        \"1.00 European composite units random\",\n        \"1.00 European currency unit random\",\n        \"1.00 European currency units random\",\n        \"1.00 European monetary unit random\",\n        \"1.00 European monetary units random\",\n        \"1.00 European unit of account (XBC) random\",\n        \"1.00 European unit of account (XBD) random\",\n        \"1.00 European units of account (XBC) random\",\n        \"1.00 European units of account (XBD) random\",\n        \"1.00 Falkland Islands Pound random\",\n        \"1.00 Falkland Islands pound random\",\n        \"1.00 Falkland Islands pounds random\",\n        \"1.00 Fijian Dollar random\",\n        \"1.00 Fijian dollar random\",\n        \"1.00 Fijian dollars random\",\n        \"1.00 Finnish Markka random\",\n        \"1.00 Finnish markka random\",\n        \"1.00 Finnish markkas random\",\n        \"1.00 French Franc random\",\n        \"1.00 French Gold Franc random\",\n        \"1.00 French UIC-Franc random\",\n        \"1.00 French UIC-franc random\",\n        \"1.00 French UIC-francs random\",\n        \"1.00 French franc random\",\n        \"1.00 French francs random\",\n        \"1.00 French gold franc random\",\n        \"1.00 French gold francs random\",\n        \"1.00 Gambian Dalasi random\",\n        \"1.00 Gambian dalasi random\",\n        \"1.00 Gambian dalasis random\",\n        \"1.00 Georgian Kupon Larit random\",\n        \"1.00 Georgian Lari random\",\n        \"1.00 Georgian kupon larit random\",\n        \"1.00 Georgian kupon larits random\",\n        \"1.00 Georgian lari random\",\n        \"1.00 Georgian laris random\",\n        \"1.00 Ghanaian Cedi (1979\\\\u20132007) random\",\n        \"1.00 Ghanaian Cedi random\",\n        \"1.00 Ghanaian cedi (1979\\\\u20132007) random\",\n        \"1.00 Ghanaian cedi random\",\n        \"1.00 Ghanaian cedis (1979\\\\u20132007) random\",\n        \"1.00 Ghanaian cedis random\",\n        \"1.00 Gibraltar Pound random\",\n        \"1.00 Gibraltar pound random\",\n        \"1.00 Gibraltar pounds random\",\n        \"1.00 Gold random\",\n        \"1.00 Gold random\",\n        \"1.00 Greek Drachma random\",\n        \"1.00 Greek drachma random\",\n        \"1.00 Greek drachmas random\",\n        \"1.00 Guatemalan Quetzal random\",\n        \"1.00 Guatemalan quetzal random\",\n        \"1.00 Guatemalan quetzals random\",\n        \"1.00 Guinean Franc random\",\n        \"1.00 Guinean Syli random\",\n        \"1.00 Guinean franc random\",\n        \"1.00 Guinean francs random\",\n        \"1.00 Guinean syli random\",\n        \"1.00 Guinean sylis random\",\n        \"1.00 Guinea-Bissau Peso random\",\n        \"1.00 Guinea-Bissau peso random\",\n        \"1.00 Guinea-Bissau pesos random\",\n        \"1.00 Guyanaese Dollar random\",\n        \"1.00 Guyanaese dollar random\",\n        \"1.00 Guyanaese dollars random\",\n        \"1.00 Haitian Gourde random\",\n        \"1.00 Haitian gourde random\",\n        \"1.00 Haitian gourdes random\",\n        \"1.00 Honduran Lempira random\",\n        \"1.00 Honduran lempira random\",\n        \"1.00 Honduran lempiras random\",\n        \"1.00 Hong Kong Dollar random\",\n        \"1.00 Hong Kong dollar random\",\n        \"1.00 Hong Kong dollars random\",\n        \"1.00 Hungarian Forint random\",\n        \"1.00 Hungarian forint random\",\n        \"1.00 Hungarian forints random\",\n        \"1.00 Icelandic Kr\\\\u00f3na random\",\n        \"1.00 Icelandic kr\\\\u00f3na random\",\n        \"1.00 Icelandic kr\\\\u00f3nur random\",\n        \"1.00 Indian Rupee random\",\n        \"1.00 Indian rupee random\",\n        \"1.00 Indian rupees random\",\n        \"1.00 Indonesian Rupiah random\",\n        \"1.00 Indonesian rupiah random\",\n        \"1.00 Indonesian rupiahs random\",\n        \"1.00 Iranian Rial random\",\n        \"1.00 Iranian rial random\",\n        \"1.00 Iranian rials random\",\n        \"1.00 Iraqi Dinar random\",\n        \"1.00 Iraqi dinar random\",\n        \"1.00 Iraqi dinars random\",\n        \"1.00 Irish Pound random\",\n        \"1.00 Irish pound random\",\n        \"1.00 Irish pounds random\",\n        \"1.00 Israeli Pound random\",\n        \"1.00 Israeli new shekel random\",\n        \"1.00 Israeli pound random\",\n        \"1.00 Israeli pounds random\",\n        \"1.00 Italian Lira random\",\n        \"1.00 Italian lira random\",\n        \"1.00 Italian liras random\",\n        \"1.00 Jamaican Dollar random\",\n        \"1.00 Jamaican dollar random\",\n        \"1.00 Jamaican dollars random\",\n        \"1.00 Japanese Yen random\",\n        \"1.00 Japanese yen random\",\n        \"1.00 Jordanian Dinar random\",\n        \"1.00 Jordanian dinar random\",\n        \"1.00 Jordanian dinars random\",\n        \"1.00 Kazakhstani Tenge random\",\n        \"1.00 Kazakhstani tenge random\",\n        \"1.00 Kazakhstani tenges random\",\n        \"1.00 Kenyan Shilling random\",\n        \"1.00 Kenyan shilling random\",\n        \"1.00 Kenyan shillings random\",\n        \"1.00 Kuwaiti Dinar random\",\n        \"1.00 Kuwaiti dinar random\",\n        \"1.00 Kuwaiti dinars random\",\n        \"1.00 Kyrgystani Som random\",\n        \"1.00 Kyrgystani som random\",\n        \"1.00 Kyrgystani soms random\",\n        \"1.00 Laotian Kip random\",\n        \"1.00 Laotian kip random\",\n        \"1.00 Laotian kips random\",\n        \"1.00 Latvian Lats random\",\n        \"1.00 Latvian Ruble random\",\n        \"1.00 Latvian lats random\",\n        \"1.00 Latvian lati random\",\n        \"1.00 Latvian ruble random\",\n        \"1.00 Latvian rubles random\",\n        \"1.00 Lebanese Pound random\",\n        \"1.00 Lebanese pound random\",\n        \"1.00 Lebanese pounds random\",\n        \"1.00 Lesotho Loti random\",\n        \"1.00 Lesotho loti random\",\n        \"1.00 Lesotho lotis random\",\n        \"1.00 Liberian Dollar random\",\n        \"1.00 Liberian dollar random\",\n        \"1.00 Liberian dollars random\",\n        \"1.00 Libyan Dinar random\",\n        \"1.00 Libyan dinar random\",\n        \"1.00 Libyan dinars random\",\n        \"1.00 Lithuanian Litas random\",\n        \"1.00 Lithuanian Talonas random\",\n        \"1.00 Lithuanian litas random\",\n        \"1.00 Lithuanian litai random\",\n        \"1.00 Lithuanian talonas random\",\n        \"1.00 Lithuanian talonases random\",\n        \"1.00 Luxembourgian Convertible Franc random\",\n        \"1.00 Luxembourg Financial Franc random\",\n        \"1.00 Luxembourgian Franc random\",\n        \"1.00 Luxembourgian convertible franc random\",\n        \"1.00 Luxembourgian convertible francs random\",\n        \"1.00 Luxembourg financial franc random\",\n        \"1.00 Luxembourg financial francs random\",\n        \"1.00 Luxembourgian franc random\",\n        \"1.00 Luxembourgian francs random\",\n        \"1.00 Macanese Pataca random\",\n        \"1.00 Macanese pataca random\",\n        \"1.00 Macanese patacas random\",\n        \"1.00 Macedonian Denar random\",\n        \"1.00 Macedonian denar random\",\n        \"1.00 Macedonian denari random\",\n        \"1.00 Malagasy Ariaries random\",\n        \"1.00 Malagasy Ariary random\",\n        \"1.00 Malagasy Ariary random\",\n        \"1.00 Malagasy Franc random\",\n        \"1.00 Malagasy franc random\",\n        \"1.00 Malagasy francs random\",\n        \"1.00 Malawian Kwacha random\",\n        \"1.00 Malawian Kwacha random\",\n        \"1.00 Malawian Kwachas random\",\n        \"1.00 Malaysian Ringgit random\",\n        \"1.00 Malaysian ringgit random\",\n        \"1.00 Malaysian ringgits random\",\n        \"1.00 Maldivian Rufiyaa random\",\n        \"1.00 Maldivian rufiyaa random\",\n        \"1.00 Maldivian rufiyaas random\",\n        \"1.00 Malian Franc random\",\n        \"1.00 Malian franc random\",\n        \"1.00 Malian francs random\",\n        \"1.00 Maltese Lira random\",\n        \"1.00 Maltese Pound random\",\n        \"1.00 Maltese lira random\",\n        \"1.00 Maltese liras random\",\n        \"1.00 Maltese pound random\",\n        \"1.00 Maltese pounds random\",\n        \"1.00 Mauritanian Ouguiya random\",\n        \"1.00 Mauritanian ouguiya random\",\n        \"1.00 Mauritanian ouguiyas random\",\n        \"1.00 Mauritian Rupee random\",\n        \"1.00 Mauritian rupee random\",\n        \"1.00 Mauritian rupees random\",\n        \"1.00 Mexican Peso random\",\n        \"1.00 Mexican Silver Peso (1861\\\\u20131992) random\",\n        \"1.00 Mexican Investment Unit random\",\n        \"1.00 Mexican peso random\",\n        \"1.00 Mexican pesos random\",\n        \"1.00 Mexican silver peso (1861\\\\u20131992) random\",\n        \"1.00 Mexican silver pesos (1861\\\\u20131992) random\",\n        \"1.00 Mexican investment unit random\",\n        \"1.00 Mexican investment units random\",\n        \"1.00 Moldovan Leu random\",\n        \"1.00 Moldovan leu random\",\n        \"1.00 Moldovan lei random\",\n        \"1.00 Mongolian Tugrik random\",\n        \"1.00 Mongolian tugrik random\",\n        \"1.00 Mongolian tugriks random\",\n        \"1.00 Moroccan Dirham random\",\n        \"1.00 Moroccan Franc random\",\n        \"1.00 Moroccan dirham random\",\n        \"1.00 Moroccan dirhams random\",\n        \"1.00 Moroccan franc random\",\n        \"1.00 Moroccan francs random\",\n        \"1.00 Mozambican Escudo random\",\n        \"1.00 Mozambican Metical random\",\n        \"1.00 Mozambican escudo random\",\n        \"1.00 Mozambican escudos random\",\n        \"1.00 Mozambican metical random\",\n        \"1.00 Mozambican meticals random\",\n        \"1.00 Myanmar Kyat random\",\n        \"1.00 Myanmar kyat random\",\n        \"1.00 Myanmar kyats random\",\n        \"1.00 Namibian Dollar random\",\n        \"1.00 Namibian dollar random\",\n        \"1.00 Namibian dollars random\",\n        \"1.00 Nepalese Rupee random\",\n        \"1.00 Nepalese rupee random\",\n        \"1.00 Nepalese rupees random\",\n        \"1.00 Netherlands Antillean Guilder random\",\n        \"1.00 Netherlands Antillean guilder random\",\n        \"1.00 Netherlands Antillean guilders random\",\n        \"1.00 Dutch Guilder random\",\n        \"1.00 Dutch guilder random\",\n        \"1.00 Dutch guilders random\",\n        \"1.00 Israeli New Shekel random\",\n        \"1.00 Israeli new shekels random\",\n        \"1.00 New Zealand Dollar random\",\n        \"1.00 New Zealand dollar random\",\n        \"1.00 New Zealand dollars random\",\n        \"1.00 Nicaraguan C\\\\u00f3rdoba random\",\n        \"1.00 Nicaraguan C\\\\u00f3rdoba (1988\\\\u20131991) random\",\n        \"1.00 Nicaraguan c\\\\u00f3rdoba random\",\n        \"1.00 Nicaraguan c\\\\u00f3rdoba random\",\n        \"1.00 Nicaraguan c\\\\u00f3rdoba (1988\\\\u20131991) random\",\n        \"1.00 Nicaraguan c\\\\u00f3rdobas (1988\\\\u20131991) random\",\n        \"1.00 Nigerian Naira random\",\n        \"1.00 Nigerian naira random\",\n        \"1.00 Nigerian nairas random\",\n        \"1.00 North Korean Won random\",\n        \"1.00 North Korean won random\",\n        \"1.00 North Korean won random\",\n        \"1.00 Norwegian Krone random\",\n        \"1.00 Norwegian krone random\",\n        \"1.00 Norwegian kroner random\",\n        \"1.00 Mozambican Metical (1980\\\\u20132006) random\",\n        \"1.00 Mozambican metical (1980\\\\u20132006) random\",\n        \"1.00 Mozambican meticals (1980\\\\u20132006) random\",\n        \"1.00 Romanian Lei (1952\\\\u20132006) random\",\n        \"1.00 Romanian Leu (1952\\\\u20132006) random\",\n        \"1.00 Romanian leu (1952\\\\u20132006) random\",\n        \"1.00 Serbian Dinar (2002\\\\u20132006) random\",\n        \"1.00 Serbian dinar (2002\\\\u20132006) random\",\n        \"1.00 Serbian dinars (2002\\\\u20132006) random\",\n        \"1.00 Sudanese Dinar (1992\\\\u20132007) random\",\n        \"1.00 Sudanese Pound (1957\\\\u20131998) random\",\n        \"1.00 Sudanese dinar (1992\\\\u20132007) random\",\n        \"1.00 Sudanese dinars (1992\\\\u20132007) random\",\n        \"1.00 Sudanese pound (1957\\\\u20131998) random\",\n        \"1.00 Sudanese pounds (1957\\\\u20131998) random\",\n        \"1.00 Turkish Lira (1922\\\\u20132005) random\",\n        \"1.00 Turkish Lira (1922\\\\u20132005) random\",\n        \"1.00 Omani Rial random\",\n        \"1.00 Omani rial random\",\n        \"1.00 Omani rials random\",\n        \"1.00 Pakistani Rupee random\",\n        \"1.00 Pakistani rupee random\",\n        \"1.00 Pakistani rupees random\",\n        \"1.00 Palladium random\",\n        \"1.00 Palladium random\",\n        \"1.00 Panamanian Balboa random\",\n        \"1.00 Panamanian balboa random\",\n        \"1.00 Panamanian balboas random\",\n        \"1.00 Papua New Guinean Kina random\",\n        \"1.00 Papua New Guinean kina random\",\n        \"1.00 Papua New Guinean kina random\",\n        \"1.00 Paraguayan Guarani random\",\n        \"1.00 Paraguayan guarani random\",\n        \"1.00 Paraguayan guaranis random\",\n        \"1.00 Peruvian Inti random\",\n        \"1.00 Peruvian Sol random\",\n        \"1.00 Peruvian Sol (1863\\\\u20131965) random\",\n        \"1.00 Peruvian inti random\",\n        \"1.00 Peruvian intis random\",\n        \"1.00 Peruvian sol random\",\n        \"1.00 Peruvian soles random\",\n        \"1.00 Peruvian sol (1863\\\\u20131965) random\",\n        \"1.00 Peruvian soles (1863\\\\u20131965) random\",\n        \"1.00 Philippine Piso random\",\n        \"1.00 Philippine piso random\",\n        \"1.00 Philippine pisos random\",\n        \"1.00 Platinum random\",\n        \"1.00 Platinum random\",\n        \"1.00 Polish Zloty (1950\\\\u20131995) random\",\n        \"1.00 Polish Zloty random\",\n        \"1.00 Polish zlotys random\",\n        \"1.00 Polish zloty (PLZ) random\",\n        \"1.00 Polish zloty random\",\n        \"1.00 Polish zlotys (PLZ) random\",\n        \"1.00 Portuguese Escudo random\",\n        \"1.00 Portuguese Guinea Escudo random\",\n        \"1.00 Portuguese Guinea escudo random\",\n        \"1.00 Portuguese Guinea escudos random\",\n        \"1.00 Portuguese escudo random\",\n        \"1.00 Portuguese escudos random\",\n        \"1.00 Qatari Rial random\",\n        \"1.00 Qatari rial random\",\n        \"1.00 Qatari rials random\",\n        \"1.00 RINET Funds random\",\n        \"1.00 RINET Funds random\",\n        \"1.00 Rhodesian Dollar random\",\n        \"1.00 Rhodesian dollar random\",\n        \"1.00 Rhodesian dollars random\",\n        \"1.00 Romanian Leu random\",\n        \"1.00 Romanian lei random\",\n        \"1.00 Romanian leu random\",\n        \"1.00 Russian Ruble (1991\\\\u20131998) random\",\n        \"1.00 Russian Ruble random\",\n        \"1.00 Russian ruble (1991\\\\u20131998) random\",\n        \"1.00 Russian ruble random\",\n        \"1.00 Russian rubles (1991\\\\u20131998) random\",\n        \"1.00 Russian rubles random\",\n        \"1.00 Rwandan Franc random\",\n        \"1.00 Rwandan franc random\",\n        \"1.00 Rwandan francs random\",\n        \"1.00 St. Helena Pound random\",\n        \"1.00 St. Helena pound random\",\n        \"1.00 St. Helena pounds random\",\n        \"1.00 S\\\\u00e3o Tom\\\\u00e9 & Pr\\\\u00edncipe Dobra random\",\n        \"1.00 S\\\\u00e3o Tom\\\\u00e9 & Pr\\\\u00edncipe dobra random\",\n        \"1.00 S\\\\u00e3o Tom\\\\u00e9 & Pr\\\\u00edncipe dobras random\",\n        \"1.00 Saudi Riyal random\",\n        \"1.00 Saudi riyal random\",\n        \"1.00 Saudi riyals random\",\n        \"1.00 Serbian Dinar random\",\n        \"1.00 Serbian dinar random\",\n        \"1.00 Serbian dinars random\",\n        \"1.00 Seychellois Rupee random\",\n        \"1.00 Seychellois rupee random\",\n        \"1.00 Seychellois rupees random\",\n        \"1.00 Sierra Leonean Leone random\",\n        \"1.00 Sierra Leonean leone random\",\n        \"1.00 Sierra Leonean leones random\",\n        \"1.00 Singapore Dollar random\",\n        \"1.00 Singapore dollar random\",\n        \"1.00 Singapore dollars random\",\n        \"1.00 Slovak Koruna random\",\n        \"1.00 Slovak koruna random\",\n        \"1.00 Slovak korunas random\",\n        \"1.00 Slovenian Tolar random\",\n        \"1.00 Slovenian tolar random\",\n        \"1.00 Slovenian tolars random\",\n        \"1.00 Solomon Islands Dollar random\",\n        \"1.00 Solomon Islands dollar random\",\n        \"1.00 Solomon Islands dollars random\",\n        \"1.00 Somali Shilling random\",\n        \"1.00 Somali shilling random\",\n        \"1.00 Somali shillings random\",\n        \"1.00 South African Rand (financial) random\",\n        \"1.00 South African Rand random\",\n        \"1.00 South African rand (financial) random\",\n        \"1.00 South African rand random\",\n        \"1.00 South African rands (financial) random\",\n        \"1.00 South African rand random\",\n        \"1.00 South Korean Won random\",\n        \"1.00 South Korean won random\",\n        \"1.00 South Korean won random\",\n        \"1.00 Soviet Rouble random\",\n        \"1.00 Soviet rouble random\",\n        \"1.00 Soviet roubles random\",\n        \"1.00 Spanish Peseta (A account) random\",\n        \"1.00 Spanish Peseta (convertible account) random\",\n        \"1.00 Spanish Peseta random\",\n        \"1.00 Spanish peseta (A account) random\",\n        \"1.00 Spanish peseta (convertible account) random\",\n        \"1.00 Spanish peseta random\",\n        \"1.00 Spanish pesetas (A account) random\",\n        \"1.00 Spanish pesetas (convertible account) random\",\n        \"1.00 Spanish pesetas random\",\n        \"1.00 Special Drawing Rights random\",\n        \"1.00 Sri Lankan Rupee random\",\n        \"1.00 Sri Lankan rupee random\",\n        \"1.00 Sri Lankan rupees random\",\n        \"1.00 Sudanese Pound random\",\n        \"1.00 Sudanese pound random\",\n        \"1.00 Sudanese pounds random\",\n        \"1.00 Surinamese Dollar random\",\n        \"1.00 Surinamese dollar random\",\n        \"1.00 Surinamese dollars random\",\n        \"1.00 Surinamese Guilder random\",\n        \"1.00 Surinamese guilder random\",\n        \"1.00 Surinamese guilders random\",\n        \"1.00 Swazi Lilangeni random\",\n        \"1.00 Swazi lilangeni random\",\n        \"1.00 Swazi emalangeni random\",\n        \"1.00 Swedish Krona random\",\n        \"1.00 Swedish krona random\",\n        \"1.00 Swedish kronor random\",\n        \"1.00 Swiss Franc random\",\n        \"1.00 Swiss franc random\",\n        \"1.00 Swiss francs random\",\n        \"1.00 Syrian Pound random\",\n        \"1.00 Syrian pound random\",\n        \"1.00 Syrian pounds random\",\n        \"1.00 New Taiwan Dollar random\",\n        \"1.00 New Taiwan dollar random\",\n        \"1.00 New Taiwan dollars random\",\n        \"1.00 Tajikistani Ruble random\",\n        \"1.00 Tajikistani Somoni random\",\n        \"1.00 Tajikistani ruble random\",\n        \"1.00 Tajikistani rubles random\",\n        \"1.00 Tajikistani somoni random\",\n        \"1.00 Tajikistani somonis random\",\n        \"1.00 Tanzanian Shilling random\",\n        \"1.00 Tanzanian shilling random\",\n        \"1.00 Tanzanian shillings random\",\n        \"1.00 Testing Currency Code random\",\n        \"1.00 Testing Currency Code random\",\n        \"1.00 Thai Baht random\",\n        \"1.00 Thai baht random\",\n        \"1.00 Thai baht random\",\n        \"1.00 Timorese Escudo random\",\n        \"1.00 Timorese escudo random\",\n        \"1.00 Timorese escudos random\",\n        \"1.00 Trinidad & Tobago Dollar random\",\n        \"1.00 Trinidad & Tobago dollar random\",\n        \"1.00 Trinidad & Tobago dollars random\",\n        \"1.00 Tunisian Dinar random\",\n        \"1.00 Tunisian dinar random\",\n        \"1.00 Tunisian dinars random\",\n        \"1.00 Turkish Lira random\",\n        \"1.00 Turkish Lira random\",\n        \"1.00 Turkish lira random\",\n        \"1.00 Turkmenistani Manat random\",\n        \"1.00 Turkmenistani manat random\",\n        \"1.00 Turkmenistani manat random\",\n        \"1.00 US Dollar (Next day) random\",\n        \"1.00 US Dollar (Same day) random\",\n        \"1.00 US Dollar random\",\n        \"1.00 US dollar (next day) random\",\n        \"1.00 US dollar (same day) random\",\n        \"1.00 US dollar random\",\n        \"1.00 US dollars (next day) random\",\n        \"1.00 US dollars (same day) random\",\n        \"1.00 US dollars random\",\n        \"1.00 Ugandan Shilling (1966\\\\u20131987) random\",\n        \"1.00 Ugandan Shilling random\",\n        \"1.00 Ugandan shilling (1966\\\\u20131987) random\",\n        \"1.00 Ugandan shilling random\",\n        \"1.00 Ugandan shillings (1966\\\\u20131987) random\",\n        \"1.00 Ugandan shillings random\",\n        \"1.00 Ukrainian Hryvnia random\",\n        \"1.00 Ukrainian Karbovanets random\",\n        \"1.00 Ukrainian hryvnia random\",\n        \"1.00 Ukrainian hryvnias random\",\n        \"1.00 Ukrainian karbovanets random\",\n        \"1.00 Ukrainian karbovantsiv random\",\n        \"1.00 Colombian Real Value Unit random\",\n        \"1.00 United Arab Emirates Dirham random\",\n        \"1.00 Unknown Currency random\",\n        \"1.00 Uruguayan Peso (1975\\\\u20131993) random\",\n        \"1.00 Uruguayan Peso random\",\n        \"1.00 Uruguayan Peso (Indexed Units) random\",\n        \"1.00 Uruguayan peso (1975\\\\u20131993) random\",\n        \"1.00 Uruguayan peso (indexed units) random\",\n        \"1.00 Uruguayan peso random\",\n        \"1.00 Uruguayan pesos (1975\\\\u20131993) random\",\n        \"1.00 Uruguayan pesos (indexed units) random\",\n        \"1.00 Uzbekistani Som random\",\n        \"1.00 Uzbekistani som random\",\n        \"1.00 Uzbekistani som random\",\n        \"1.00 Vanuatu Vatu random\",\n        \"1.00 Vanuatu vatu random\",\n        \"1.00 Vanuatu vatus random\",\n        \"1.00 Venezuelan Bol\\\\u00edvar random\",\n        \"1.00 Venezuelan Bol\\\\u00edvar (1871\\\\u20132008) random\",\n        \"1.00 Venezuelan bol\\\\u00edvar random\",\n        \"1.00 Venezuelan bol\\\\u00edvars random\",\n        \"1.00 Venezuelan bol\\\\u00edvar (1871\\\\u20132008) random\",\n        \"1.00 Venezuelan bol\\\\u00edvars (1871\\\\u20132008) random\",\n        \"1.00 Vietnamese Dong random\",\n        \"1.00 Vietnamese dong random\",\n        \"1.00 Vietnamese dong random\",\n        \"1.00 WIR Euro random\",\n        \"1.00 WIR Franc random\",\n        \"1.00 WIR euro random\",\n        \"1.00 WIR euros random\",\n        \"1.00 WIR franc random\",\n        \"1.00 WIR francs random\",\n        \"1.00 Samoan Tala random\",\n        \"1.00 Samoan tala random\",\n        \"1.00 Samoan tala random\",\n        \"1.00 Yemeni Dinar random\",\n        \"1.00 Yemeni Rial random\",\n        \"1.00 Yemeni dinar random\",\n        \"1.00 Yemeni dinars random\",\n        \"1.00 Yemeni rial random\",\n        \"1.00 Yemeni rials random\",\n        \"1.00 Yugoslavian Convertible Dinar (1990\\\\u20131992) random\",\n        \"1.00 Yugoslavian Hard Dinar (1966\\\\u20131990) random\",\n        \"1.00 Yugoslavian New Dinar (1994\\\\u20132002) random\",\n        \"1.00 Yugoslavian convertible dinar (1990\\\\u20131992) random\",\n        \"1.00 Yugoslavian convertible dinars (1990\\\\u20131992) random\",\n        \"1.00 Yugoslavian hard dinar (1966\\\\u20131990) random\",\n        \"1.00 Yugoslavian hard dinars (1966\\\\u20131990) random\",\n        \"1.00 Yugoslavian new dinar (1994\\\\u20132002) random\",\n        \"1.00 Yugoslavian new dinars (1994\\\\u20132002) random\",\n        \"1.00 Zairean New Zaire (1993\\\\u20131998) random\",\n        \"1.00 Zairean Zaire (1971\\\\u20131993) random\",\n        \"1.00 Zairean new zaire (1993\\\\u20131998) random\",\n        \"1.00 Zairean new zaires (1993\\\\u20131998) random\",\n        \"1.00 Zairean zaire (1971\\\\u20131993) random\",\n        \"1.00 Zairean zaires (1971\\\\u20131993) random\",\n        \"1.00 Zambian Kwacha random\",\n        \"1.00 Zambian kwacha random\",\n        \"1.00 Zambian kwachas random\",\n        \"1.00 Zimbabwean Dollar (1980\\\\u20132008) random\",\n        \"1.00 Zimbabwean dollar (1980\\\\u20132008) random\",\n        \"1.00 Zimbabwean dollars (1980\\\\u20132008) random\",\n        \"1.00 euro random\",\n        \"1.00 euros random\",\n        \"1.00 Turkish lira (1922\\\\u20132005) random\",\n        \"1.00 special drawing rights random\",\n        \"1.00 Colombian real value unit random\",\n        \"1.00 Colombian real value units random\",\n        \"1.00 unknown currency random\",\n    };\n\n    const char* WRONG_DATA[] = {\n        // Following are missing one last char in the currency name\n        \"1.00 Nicaraguan Cordob\",\n        \"1.00 Namibian Dolla\",\n        \"1.00 Namibian dolla\",\n        \"1.00 Nepalese Rupe\",\n        \"1.00 Nepalese rupe\",\n        \"1.00 Netherlands Antillean Guilde\",\n        \"1.00 Netherlands Antillean guilde\",\n        \"1.00 Dutch Guilde\",\n        \"1.00 Dutch guilde\",\n        \"1.00 Israeli New Sheqe\",\n        \"1.00 New Zealand Dolla\",\n        \"1.00 New Zealand dolla\",\n        \"1.00 Nicaraguan cordob\",\n        \"1.00 Nigerian Nair\",\n        \"1.00 Nigerian nair\",\n        \"1.00 North Korean Wo\",\n        \"1.00 North Korean wo\",\n        \"1.00 Norwegian Kron\",\n        \"1.00 Norwegian kron\",\n        \"1.00 US dolla\",\n        \"1.00\",\n        \"A1.00\",\n        \"AD1.00\",\n        \"AE1.00\",\n        \"AF1.00\",\n        \"AL1.00\",\n        \"AM1.00\",\n        \"AN1.00\",\n        \"AO1.00\",\n        \"AR1.00\",\n        \"AT1.00\",\n        \"AU1.00\",\n        \"AW1.00\",\n        \"AZ1.00\",\n        \"Afghan Afghan1.00\",\n        \"Afghan Afghani (1927\\\\u201320021.00\",\n        \"Afl1.00\",\n        \"Albanian Le1.00\",\n        \"Algerian Dina1.00\",\n        \"Andorran Peset1.00\",\n        \"Angolan Kwanz1.00\",\n        \"Angolan Kwanza (1977\\\\u201319901.00\",\n        \"Angolan Readjusted Kwanza (1995\\\\u201319991.00\",\n        \"Angolan New Kwanza (1990\\\\u201320001.00\",\n        \"Argentine Austra1.00\",\n        \"Argentine Pes1.00\",\n        \"Argentine Peso (1983\\\\u201319851.00\",\n        \"Armenian Dra1.00\",\n        \"Aruban Flori1.00\",\n        \"Australian Dolla1.00\",\n        \"Austrian Schillin1.00\",\n        \"Azerbaijani Mana1.00\",\n        \"Azerbaijani Manat (1993\\\\u201320061.00\",\n        \"B1.00\",\n        \"BA1.00\",\n        \"BB1.00\",\n        \"BE1.00\",\n        \"BG1.00\",\n        \"BH1.00\",\n        \"BI1.00\",\n        \"BM1.00\",\n        \"BN1.00\",\n        \"BO1.00\",\n        \"BR1.00\",\n        \"BS1.00\",\n        \"BT1.00\",\n        \"BU1.00\",\n        \"BW1.00\",\n        \"BY1.00\",\n        \"BZ1.00\",\n        \"Bahamian Dolla1.00\",\n        \"Bahraini Dina1.00\",\n        \"Bangladeshi Tak1.00\",\n        \"Barbadian Dolla1.00\",\n        \"Bds1.00\",\n        \"Belarusian Ruble (1994\\\\u201319991.00\",\n        \"Belarusian Rubl1.00\",\n        \"Belgian Fran1.00\",\n        \"Belgian Franc (convertible1.00\",\n        \"Belgian Franc (financial1.00\",\n        \"Belize Dolla1.00\",\n        \"Bermudan Dolla1.00\",\n        \"Bhutanese Ngultru1.00\",\n        \"Bolivian Mvdo1.00\",\n        \"Bolivian Pes1.00\",\n        \"Bolivian Bolivian1.00\",\n        \"Bosnia-Herzegovina Convertible Mar1.00\",\n        \"Bosnia-Herzegovina Dina1.00\",\n        \"Botswanan Pul1.00\",\n        \"Brazilian Cruzad1.00\",\n        \"Brazilian Cruzado Nov1.00\",\n        \"Brazilian Cruzeir1.00\",\n        \"Brazilian Cruzeiro (1990\\\\u201319931.00\",\n        \"Brazilian New Cruzeiro (1967\\\\u201319861.00\",\n        \"Brazilian Rea1.00\",\n        \"British Pound Sterlin1.00\",\n        \"Brunei Dolla1.00\",\n        \"Bulgarian Hard Le1.00\",\n        \"Bulgarian Le1.00\",\n        \"Burmese Kya1.00\",\n        \"Burundian Fran1.00\",\n        \"C1.00\",\n        \"CA1.00\",\n        \"CD1.00\",\n        \"CFP Fran1.00\",\n        \"CFP1.00\",\n        \"CH1.00\",\n        \"CL1.00\",\n        \"CN1.00\",\n        \"CO1.00\",\n        \"CS1.00\",\n        \"CU1.00\",\n        \"CV1.00\",\n        \"CY1.00\",\n        \"CZ1.00\",\n        \"Cambodian Rie1.00\",\n        \"Canadian Dolla1.00\",\n        \"Cape Verdean Escud1.00\",\n        \"Cayman Islands Dolla1.00\",\n        \"Chilean Pes1.00\",\n        \"Chilean Unit of Accoun1.00\",\n        \"Chinese Yua1.00\",\n        \"Colombian Pes1.00\",\n        \"Comoro Fran1.00\",\n        \"Congolese Fran1.00\",\n        \"Costa Rican Col\\\\u00f31.00\",\n        \"Croatian Dina1.00\",\n        \"Croatian Kun1.00\",\n        \"Cuban Pes1.00\",\n        \"Cypriot Poun1.00\",\n        \"Czech Republic Korun1.00\",\n        \"Czechoslovak Hard Korun1.00\",\n        \"D1.00\",\n        \"DD1.00\",\n        \"DE1.00\",\n        \"DJ1.00\",\n        \"DK1.00\",\n        \"DO1.00\",\n        \"DZ1.00\",\n        \"Danish Kron1.00\",\n        \"German Mar1.00\",\n        \"Djiboutian Fran1.00\",\n        \"Dk1.00\",\n        \"Dominican Pes1.00\",\n        \"EC1.00\",\n        \"EE1.00\",\n        \"EG1.00\",\n        \"EQ1.00\",\n        \"ER1.00\",\n        \"ES1.00\",\n        \"ET1.00\",\n        \"EU1.00\",\n        \"East Caribbean Dolla1.00\",\n        \"East German Ostmar1.00\",\n        \"Ecuadorian Sucr1.00\",\n        \"Ecuadorian Unit of Constant Valu1.00\",\n        \"Egyptian Poun1.00\",\n        \"Ekwel1.00\",\n        \"Salvadoran Col\\\\u00f31.00\",\n        \"Equatorial Guinean Ekwel1.00\",\n        \"Eritrean Nakf1.00\",\n        \"Es1.00\",\n        \"Estonian Kroo1.00\",\n        \"Ethiopian Bir1.00\",\n        \"Eur1.00\",\n        \"European Composite Uni1.00\",\n        \"European Currency Uni1.00\",\n        \"European Monetary Uni1.00\",\n        \"European Unit of Account (XBC1.00\",\n        \"European Unit of Account (XBD1.00\",\n        \"F1.00\",\n        \"FB1.00\",\n        \"FI1.00\",\n        \"FJ1.00\",\n        \"FK1.00\",\n        \"FR1.00\",\n        \"Falkland Islands Poun1.00\",\n        \"Fd1.00\",\n        \"Fijian Dolla1.00\",\n        \"Finnish Markk1.00\",\n        \"Fr1.00\",\n        \"French Fran1.00\",\n        \"French Gold Fran1.00\",\n        \"French UIC-Fran1.00\",\n        \"G1.00\",\n        \"GB1.00\",\n        \"GE1.00\",\n        \"GH1.00\",\n        \"GI1.00\",\n        \"GM1.00\",\n        \"GN1.00\",\n        \"GQ1.00\",\n        \"GR1.00\",\n        \"GT1.00\",\n        \"GW1.00\",\n        \"GY1.00\",\n        \"Gambian Dalas1.00\",\n        \"Georgian Kupon Lari1.00\",\n        \"Georgian Lar1.00\",\n        \"Ghanaian Ced1.00\",\n        \"Ghanaian Cedi (1979\\\\u201320071.00\",\n        \"Gibraltar Poun1.00\",\n        \"Gol1.00\",\n        \"Greek Drachm1.00\",\n        \"Guatemalan Quetza1.00\",\n        \"Guinean Fran1.00\",\n        \"Guinean Syl1.00\",\n        \"Guinea-Bissau Pes1.00\",\n        \"Guyanaese Dolla1.00\",\n        \"HK1.00\",\n        \"HN1.00\",\n        \"HR1.00\",\n        \"HT1.00\",\n        \"HU1.00\",\n        \"Haitian Gourd1.00\",\n        \"Honduran Lempir1.00\",\n        \"Hong Kong Dolla1.00\",\n        \"Hungarian Forin1.00\",\n        \"I1.00\",\n        \"IE1.00\",\n        \"IL1.00\",\n        \"IN1.00\",\n        \"IQ1.00\",\n        \"IR1.00\",\n        \"IS1.00\",\n        \"IT1.00\",\n        \"Icelandic Kron1.00\",\n        \"Indian Rupe1.00\",\n        \"Indonesian Rupia1.00\",\n        \"Iranian Ria1.00\",\n        \"Iraqi Dina1.00\",\n        \"Irish Poun1.00\",\n        \"Israeli Poun1.00\",\n        \"Italian Lir1.00\",\n        \"J1.00\",\n        \"JM1.00\",\n        \"JO1.00\",\n        \"JP1.00\",\n        \"Jamaican Dolla1.00\",\n        \"Japanese Ye1.00\",\n        \"Jordanian Dina1.00\",\n        \"K S1.00\",\n        \"K1.00\",\n        \"KE1.00\",\n        \"KG1.00\",\n        \"KH1.00\",\n        \"KP1.00\",\n        \"KR1.00\",\n        \"KW1.00\",\n        \"KY1.00\",\n        \"KZ1.00\",\n        \"Kazakhstani Teng1.00\",\n        \"Kenyan Shillin1.00\",\n        \"Kuwaiti Dina1.00\",\n        \"Kyrgystani So1.00\",\n        \"LA1.00\",\n        \"LB1.00\",\n        \"LK1.00\",\n        \"LR1.00\",\n        \"LT1.00\",\n        \"LU1.00\",\n        \"LV1.00\",\n        \"LY1.00\",\n        \"Laotian Ki1.00\",\n        \"Latvian Lat1.00\",\n        \"Latvian Rubl1.00\",\n        \"Lebanese Poun1.00\",\n        \"Lesotho Lot1.00\",\n        \"Liberian Dolla1.00\",\n        \"Libyan Dina1.00\",\n        \"Lithuanian Lit1.00\",\n        \"Lithuanian Talona1.00\",\n        \"Luxembourgian Convertible Fran1.00\",\n        \"Luxembourg Financial Fran1.00\",\n        \"Luxembourgian Fran1.00\",\n        \"MA1.00\",\n        \"MD1.00\",\n        \"MDe1.00\",\n        \"MEX1.00\",\n        \"MG1.00\",\n        \"ML1.00\",\n        \"MM1.00\",\n        \"MN1.00\",\n        \"MO1.00\",\n        \"MR1.00\",\n        \"MT1.00\",\n        \"MU1.00\",\n        \"MV1.00\",\n        \"MW1.00\",\n        \"MX1.00\",\n        \"MY1.00\",\n        \"MZ1.00\",\n        \"Macanese Patac1.00\",\n        \"Macedonian Dena1.00\",\n        \"Malagasy Ariar1.00\",\n        \"Malagasy Fran1.00\",\n        \"Malawian Kwach1.00\",\n        \"Malaysian Ringgi1.00\",\n        \"Maldivian Rufiya1.00\",\n        \"Malian Fran1.00\",\n        \"Malot1.00\",\n        \"Maltese Lir1.00\",\n        \"Maltese Poun1.00\",\n        \"Mauritanian Ouguiy1.00\",\n        \"Mauritian Rupe1.00\",\n        \"Mexican Pes1.00\",\n        \"Mexican Silver Peso (1861\\\\u201319921.00\",\n        \"Mexican Investment Uni1.00\",\n        \"Moldovan Le1.00\",\n        \"Mongolian Tugri1.00\",\n        \"Moroccan Dirha1.00\",\n        \"Moroccan Fran1.00\",\n        \"Mozambican Escud1.00\",\n        \"Mozambican Metica1.00\",\n        \"Myanmar Kya1.00\",\n        \"N1.00\",\n        \"NA1.00\",\n        \"NAf1.00\",\n        \"NG1.00\",\n        \"NI1.00\",\n        \"NK1.00\",\n        \"NL1.00\",\n        \"NO1.00\",\n        \"NP1.00\",\n        \"NT1.00\",\n        \"Namibian Dolla1.00\",\n        \"Nepalese Rupe1.00\",\n        \"Netherlands Antillean Guilde1.00\",\n        \"Dutch Guilde1.00\",\n        \"Israeli New Sheqe1.00\",\n        \"New Zealand Dolla1.00\",\n        \"Nicaraguan C\\\\u00f3rdoba (1988\\\\u201319911.00\",\n        \"Nicaraguan C\\\\u00f3rdob1.00\",\n        \"Nigerian Nair1.00\",\n        \"North Korean Wo1.00\",\n        \"Norwegian Kron1.00\",\n        \"Nr1.00\",\n        \"OM1.00\",\n        \"Old Mozambican Metica1.00\",\n        \"Romanian Leu (1952\\\\u201320061.00\",\n        \"Serbian Dinar (2002\\\\u201320061.00\",\n        \"Sudanese Dinar (1992\\\\u201320071.00\",\n        \"Sudanese Pound (1957\\\\u201319981.00\",\n        \"Turkish Lira (1922\\\\u201320051.00\",\n        \"Omani Ria1.00\",\n        \"PA1.00\",\n        \"PE1.00\",\n        \"PG1.00\",\n        \"PH1.00\",\n        \"PK1.00\",\n        \"PL1.00\",\n        \"PT1.00\",\n        \"PY1.00\",\n        \"Pakistani Rupe1.00\",\n        \"Palladiu1.00\",\n        \"Panamanian Balbo1.00\",\n        \"Papua New Guinean Kin1.00\",\n        \"Paraguayan Guaran1.00\",\n        \"Peruvian Int1.00\",\n        \"Peruvian Sol (1863\\\\u201319651.00\",\n        \"Peruvian Sol Nuev1.00\",\n        \"Philippine Pes1.00\",\n        \"Platinu1.00\",\n        \"Polish Zlot1.00\",\n        \"Polish Zloty (1950\\\\u201319951.00\",\n        \"Portuguese Escud1.00\",\n        \"Portuguese Guinea Escud1.00\",\n        \"Pr1.00\",\n        \"QA1.00\",\n        \"Qatari Ria1.00\",\n        \"RD1.00\",\n        \"RH1.00\",\n        \"RINET Fund1.00\",\n        \"RS1.00\",\n        \"RU1.00\",\n        \"RW1.00\",\n        \"Rb1.00\",\n        \"Rhodesian Dolla1.00\",\n        \"Romanian Le1.00\",\n        \"Russian Rubl1.00\",\n        \"Russian Ruble (1991\\\\u201319981.00\",\n        \"Rwandan Fran1.00\",\n        \"S1.00\",\n        \"SA1.00\",\n        \"SB1.00\",\n        \"SC1.00\",\n        \"SD1.00\",\n        \"SE1.00\",\n        \"SG1.00\",\n        \"SH1.00\",\n        \"SI1.00\",\n        \"SK1.00\",\n        \"SL R1.00\",\n        \"SL1.00\",\n        \"SO1.00\",\n        \"ST1.00\",\n        \"SU1.00\",\n        \"SV1.00\",\n        \"SY1.00\",\n        \"SZ1.00\",\n        \"St. Helena Poun1.00\",\n        \"S\\\\u00e3o Tom\\\\u00e9 & Pr\\\\u00edncipe Dobr1.00\",\n        \"Saudi Riya1.00\",\n        \"Serbian Dina1.00\",\n        \"Seychellois Rupe1.00\",\n        \"Sh1.00\",\n        \"Sierra Leonean Leon1.00\",\n        \"Silve1.00\",\n        \"Singapore Dolla1.00\",\n        \"Slovak Korun1.00\",\n        \"Slovenian Tola1.00\",\n        \"Solomon Islands Dolla1.00\",\n        \"Somali Shillin1.00\",\n        \"South African Ran1.00\",\n        \"South African Rand (financial1.00\",\n        \"South Korean Wo1.00\",\n        \"Soviet Roubl1.00\",\n        \"Spanish Peset1.00\",\n        \"Spanish Peseta (A account1.00\",\n        \"Spanish Peseta (convertible account1.00\",\n        \"Special Drawing Right1.00\",\n        \"Sri Lankan Rupe1.00\",\n        \"Sudanese Poun1.00\",\n        \"Surinamese Dolla1.00\",\n        \"Surinamese Guilde1.00\",\n        \"Swazi Lilangen1.00\",\n        \"Swedish Kron1.00\",\n        \"Swiss Fran1.00\",\n        \"Syrian Poun1.00\",\n        \"T S1.00\",\n        \"TH1.00\",\n        \"TJ1.00\",\n        \"TM1.00\",\n        \"TN1.00\",\n        \"TO1.00\",\n        \"TP1.00\",\n        \"TR1.00\",\n        \"TT1.00\",\n        \"TW1.00\",\n        \"TZ1.00\",\n        \"New Taiwan Dolla1.00\",\n        \"Tajikistani Rubl1.00\",\n        \"Tajikistani Somon1.00\",\n        \"Tanzanian Shillin1.00\",\n        \"Testing Currency Cod1.00\",\n        \"Thai Bah1.00\",\n        \"Timorese Escud1.00\",\n        \"Tongan Pa\\\\u20bbang1.00\",\n        \"Trinidad & Tobago Dolla1.00\",\n        \"Tunisian Dina1.00\",\n        \"Turkish Lir1.00\",\n        \"Turkmenistani Mana1.00\",\n        \"U S1.00\",\n        \"U1.00\",\n        \"UA1.00\",\n        \"UG1.00\",\n        \"US Dolla1.00\",\n        \"US Dollar (Next day1.00\",\n        \"US Dollar (Same day1.00\",\n        \"US1.00\",\n        \"UY1.00\",\n        \"UZ1.00\",\n        \"Ugandan Shillin1.00\",\n        \"Ugandan Shilling (1966\\\\u201319871.00\",\n        \"Ukrainian Hryvni1.00\",\n        \"Ukrainian Karbovanet1.00\",\n        \"Colombian Real Value Uni1.00\",\n        \"United Arab Emirates Dirha1.00\",\n        \"Unknown Currenc1.00\",\n        \"Ur1.00\",\n        \"Uruguay Peso (1975\\\\u201319931.00\",\n        \"Uruguay Peso Uruguay1.00\",\n        \"Uruguay Peso (Indexed Units1.00\",\n        \"Uzbekistani So1.00\",\n        \"V1.00\",\n        \"VE1.00\",\n        \"VN1.00\",\n        \"VU1.00\",\n        \"Vanuatu Vat1.00\",\n        \"Venezuelan Bol\\\\u00edva1.00\",\n        \"Venezuelan Bol\\\\u00edvar Fuert1.00\",\n        \"Vietnamese Don1.00\",\n        \"West African CFA Fran1.00\",\n        \"Central African CFA Fran1.00\",\n        \"WIR Eur1.00\",\n        \"WIR Fran1.00\",\n        \"WS1.00\",\n        \"Samoa Tal1.00\",\n        \"XA1.00\",\n        \"XB1.00\",\n        \"XC1.00\",\n        \"XD1.00\",\n        \"XE1.00\",\n        \"XF1.00\",\n        \"XO1.00\",\n        \"XP1.00\",\n        \"XR1.00\",\n        \"XT1.00\",\n        \"XX1.00\",\n        \"YD1.00\",\n        \"YE1.00\",\n        \"YU1.00\",\n        \"Yemeni Dina1.00\",\n        \"Yemeni Ria1.00\",\n        \"Yugoslavian Convertible Dina1.00\",\n        \"Yugoslavian Hard Dinar (1966\\\\u201319901.00\",\n        \"Yugoslavian New Dina1.00\",\n        \"Z1.00\",\n        \"ZA1.00\",\n        \"ZM1.00\",\n        \"ZR1.00\",\n        \"ZW1.00\",\n        \"Zairean New Zaire (1993\\\\u201319981.00\",\n        \"Zairean Zair1.00\",\n        \"Zambian Kwach1.00\",\n        \"Zimbabwean Dollar (1980\\\\u201320081.00\",\n        \"dra1.00\",\n        \"lar1.00\",\n        \"le1.00\",\n        \"man1.00\",\n        \"so1.00\",\n    };\n\n    Locale locale(\"en_US\");\n    for (uint32_t i=0; i<UPRV_LENGTHOF(DATA); ++i) {\n        UnicodeString formatted = ctou(DATA[i]);\n        UErrorCode status = U_ZERO_ERROR;\n        LocalPointer<NumberFormat> numFmt(NumberFormat::createInstance(locale, UNUM_CURRENCY, status), status);\n        if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) {\n            return;\n        }\n        // NOTE: ICU 62 requires that the currency format match the pattern in strict mode.\n        numFmt->setLenient(TRUE);\n        ParsePosition parsePos;\n        LocalPointer<CurrencyAmount> currAmt(numFmt->parseCurrency(formatted, parsePos));\n        if (parsePos.getIndex() > 0) {\n            double doubleVal = currAmt->getNumber().getDouble(status);\n            if ( doubleVal != 1.0 ) {\n                errln(\"Parsed as currency value other than 1.0: \" + formatted + \" -> \" + doubleVal);\n            }\n        } else {\n            errln(\"Failed to parse as currency: \" + formatted);\n        }\n    }\n\n    for (uint32_t i=0; i<UPRV_LENGTHOF(WRONG_DATA); ++i) {\n      UnicodeString formatted = ctou(WRONG_DATA[i]);\n      UErrorCode status = U_ZERO_ERROR;\n      NumberFormat* numFmt = NumberFormat::createInstance(locale, UNUM_CURRENCY, status);\n      if (numFmt != NULL && U_SUCCESS(status)) {\n          ParsePosition parsePos;\n          LocalPointer<CurrencyAmount> currAmt(numFmt->parseCurrency(formatted, parsePos));\n          if (parsePos.getIndex() > 0) {\n              double doubleVal = currAmt->getNumber().getDouble(status);\n              errln(\"Parsed as currency, should not have: \" + formatted + \" -> \" + doubleVal);\n          }\n      } else {\n          dataerrln(\"Unable to create NumberFormat. - %s\", u_errorName(status));\n          delete numFmt;\n          break;\n      }\n      delete numFmt;\n    }\n}\n\nconst char* attrString(int32_t);\n\n// UnicodeString s;\n//  std::string ss;\n//  std::cout << s.toUTF8String(ss)\nvoid NumberFormatTest::expectPositions(FieldPositionIterator& iter, int32_t *values, int32_t tupleCount,\n                                       const UnicodeString& str)  {\n  UBool found[10];\n  FieldPosition fp;\n\n  if (tupleCount > 10) {\n    assertTrue(\"internal error, tupleCount too large\", FALSE);\n  } else {\n    for (int i = 0; i < tupleCount; ++i) {\n      found[i] = FALSE;\n    }\n  }\n\n  logln(str);\n  while (iter.next(fp)) {\n    UBool ok = FALSE;\n    int32_t id = fp.getField();\n    int32_t start = fp.getBeginIndex();\n    int32_t limit = fp.getEndIndex();\n\n    // is there a logln using printf?\n    char buf[128];\n    sprintf(buf, \"%24s %3d %3d %3d\", attrString(id), id, start, limit);\n    logln(buf);\n\n    for (int i = 0; i < tupleCount; ++i) {\n      if (found[i]) {\n        continue;\n      }\n      if (values[i*3] == id &&\n          values[i*3+1] == start &&\n          values[i*3+2] == limit) {\n        found[i] = ok = TRUE;\n        break;\n      }\n    }\n\n    assertTrue((UnicodeString)\"found [\" + id + \",\" + start + \",\" + limit + \"]\", ok);\n  }\n\n  // check that all were found\n  UBool ok = TRUE;\n  for (int i = 0; i < tupleCount; ++i) {\n    if (!found[i]) {\n      ok = FALSE;\n      assertTrue((UnicodeString) \"missing [\" + values[i*3] + \",\" + values[i*3+1] + \",\" + values[i*3+2] + \"]\", found[i]);\n    }\n  }\n  assertTrue(\"no expected values were missing\", ok);\n}\n\nvoid NumberFormatTest::expectPosition(FieldPosition& pos, int32_t id, int32_t start, int32_t limit,\n                                       const UnicodeString& str)  {\n  logln(str);\n  assertTrue((UnicodeString)\"id \" + id + \" == \" + pos.getField(), id == pos.getField());\n  assertTrue((UnicodeString)\"begin \" + start + \" == \" + pos.getBeginIndex(), start == pos.getBeginIndex());\n  assertTrue((UnicodeString)\"end \" + limit + \" == \" + pos.getEndIndex(), limit == pos.getEndIndex());\n}\n\nvoid NumberFormatTest::TestFieldPositionIterator() {\n  // bug 7372\n  UErrorCode status = U_ZERO_ERROR;\n  FieldPositionIterator iter1;\n  FieldPositionIterator iter2;\n  FieldPosition pos;\n\n  DecimalFormat *decFmt = (DecimalFormat *) NumberFormat::createInstance(status);\n  if (failure(status, \"NumberFormat::createInstance\", TRUE)) return;\n\n  double num = 1234.56;\n  UnicodeString str1;\n  UnicodeString str2;\n\n  assertTrue((UnicodeString)\"self==\", iter1 == iter1);\n  assertTrue((UnicodeString)\"iter1==iter2\", iter1 == iter2);\n\n  decFmt->format(num, str1, &iter1, status);\n  assertTrue((UnicodeString)\"iter1 != iter2\", iter1 != iter2);\n  decFmt->format(num, str2, &iter2, status);\n  assertTrue((UnicodeString)\"iter1 == iter2 (2)\", iter1 == iter2);\n  iter1.next(pos);\n  assertTrue((UnicodeString)\"iter1 != iter2 (2)\", iter1 != iter2);\n  iter2.next(pos);\n  assertTrue((UnicodeString)\"iter1 == iter2 (3)\", iter1 == iter2);\n\n  // should format ok with no iterator\n  str2.remove();\n  decFmt->format(num, str2, NULL, status);\n  assertEquals(\"null fpiter\", str1, str2);\n\n  delete decFmt;\n}\n\nvoid NumberFormatTest::TestFormatAttributes() {\n  Locale locale(\"en_US\");\n  UErrorCode status = U_ZERO_ERROR;\n  DecimalFormat *decFmt = (DecimalFormat *) NumberFormat::createInstance(locale, UNUM_CURRENCY, status);\n    if (failure(status, \"NumberFormat::createInstance\", TRUE)) return;\n  double val = 12345.67;\n\n  {\n    int32_t expected[] = {\n      UNUM_CURRENCY_FIELD, 0, 1,\n      UNUM_GROUPING_SEPARATOR_FIELD, 3, 4,\n      UNUM_INTEGER_FIELD, 1, 7,\n      UNUM_DECIMAL_SEPARATOR_FIELD, 7, 8,\n      UNUM_FRACTION_FIELD, 8, 10,\n    };\n    int32_t tupleCount = UPRV_LENGTHOF(expected)/3;\n\n    FieldPositionIterator posIter;\n    UnicodeString result;\n    decFmt->format(val, result, &posIter, status);\n    expectPositions(posIter, expected, tupleCount, result);\n  }\n  {\n    FieldPosition fp(UNUM_INTEGER_FIELD);\n    UnicodeString result;\n    decFmt->format(val, result, fp);\n    expectPosition(fp, UNUM_INTEGER_FIELD, 1, 7, result);\n  }\n  {\n    FieldPosition fp(UNUM_FRACTION_FIELD);\n    UnicodeString result;\n    decFmt->format(val, result, fp);\n    expectPosition(fp, UNUM_FRACTION_FIELD, 8, 10, result);\n  }\n  delete decFmt;\n\n  decFmt = (DecimalFormat *) NumberFormat::createInstance(locale, UNUM_SCIENTIFIC, status);\n  val = -0.0000123;\n  {\n    int32_t expected[] = {\n      UNUM_SIGN_FIELD, 0, 1,\n      UNUM_INTEGER_FIELD, 1, 2,\n      UNUM_DECIMAL_SEPARATOR_FIELD, 2, 3,\n      UNUM_FRACTION_FIELD, 3, 5,\n      UNUM_EXPONENT_SYMBOL_FIELD, 5, 6,\n      UNUM_EXPONENT_SIGN_FIELD, 6, 7,\n      UNUM_EXPONENT_FIELD, 7, 8\n    };\n    int32_t tupleCount = UPRV_LENGTHOF(expected)/3;\n\n    FieldPositionIterator posIter;\n    UnicodeString result;\n    decFmt->format(val, result, &posIter, status);\n    expectPositions(posIter, expected, tupleCount, result);\n  }\n  {\n    FieldPosition fp(UNUM_INTEGER_FIELD);\n    UnicodeString result;\n    decFmt->format(val, result, fp);\n    expectPosition(fp, UNUM_INTEGER_FIELD, 1, 2, result);\n  }\n  {\n    FieldPosition fp(UNUM_FRACTION_FIELD);\n    UnicodeString result;\n    decFmt->format(val, result, fp);\n    expectPosition(fp, UNUM_FRACTION_FIELD, 3, 5, result);\n  }\n  delete decFmt;\n\n  fflush(stderr);\n}\n\nconst char* attrString(int32_t attrId) {\n  switch (attrId) {\n    case UNUM_INTEGER_FIELD: return \"integer\";\n    case UNUM_FRACTION_FIELD: return \"fraction\";\n    case UNUM_DECIMAL_SEPARATOR_FIELD: return \"decimal separator\";\n    case UNUM_EXPONENT_SYMBOL_FIELD: return \"exponent symbol\";\n    case UNUM_EXPONENT_SIGN_FIELD: return \"exponent sign\";\n    case UNUM_EXPONENT_FIELD: return \"exponent\";\n    case UNUM_GROUPING_SEPARATOR_FIELD: return \"grouping separator\";\n    case UNUM_CURRENCY_FIELD: return \"currency\";\n    case UNUM_PERCENT_FIELD: return \"percent\";\n    case UNUM_PERMILL_FIELD: return \"permille\";\n    case UNUM_SIGN_FIELD: return \"sign\";\n    default: return \"\";\n  }\n}\n\n//\n//   Test formatting & parsing of big decimals.\n//      API test, not a comprehensive test.\n//      See DecimalFormatTest/DataDrivenTests\n//\n#define ASSERT_SUCCESS(status) { \\\n    assertSuccess(UnicodeString(\"file \") + __FILE__ + \", line \" + __LINE__, (status)); \\\n}\n#define ASSERT_EQUALS(expected, actual) { \\\n    assertEquals(UnicodeString(\"file \") + __FILE__ + \", line \" + __LINE__, (expected), (actual)); \\\n}\n\nvoid NumberFormatTest::TestDecimal() {\n    {\n        UErrorCode  status = U_ZERO_ERROR;\n        Formattable f(\"12.345678999987654321E666\", status);\n        ASSERT_SUCCESS(status);\n        StringPiece s = f.getDecimalNumber(status);\n        ASSERT_SUCCESS(status);\n        ASSERT_EQUALS(\"1.2345678999987654321E+667\", s.data());\n        //printf(\"%s\\n\", s.data());\n    }\n\n    {\n        UErrorCode status = U_ZERO_ERROR;\n        Formattable f1(\"this is not a number\", status);\n        ASSERT_EQUALS(U_DECIMAL_NUMBER_SYNTAX_ERROR, status);\n    }\n\n    {\n        UErrorCode status = U_ZERO_ERROR;\n        Formattable f;\n        f.setDecimalNumber(\"123.45\", status);\n        ASSERT_SUCCESS(status);\n        ASSERT_EQUALS( Formattable::kDouble, f.getType());\n        ASSERT_EQUALS(123.45, f.getDouble());\n        ASSERT_EQUALS(123.45, f.getDouble(status));\n        ASSERT_SUCCESS(status);\n        ASSERT_EQUALS(\"123.45\", f.getDecimalNumber(status).data());\n        ASSERT_SUCCESS(status);\n\n        f.setDecimalNumber(\"4.5678E7\", status);\n        int32_t n;\n        n = f.getLong();\n        ASSERT_EQUALS(45678000, n);\n\n        status = U_ZERO_ERROR;\n        f.setDecimalNumber(\"-123\", status);\n        ASSERT_SUCCESS(status);\n        ASSERT_EQUALS( Formattable::kLong, f.getType());\n        ASSERT_EQUALS(-123, f.getLong());\n        ASSERT_EQUALS(-123, f.getLong(status));\n        ASSERT_SUCCESS(status);\n        ASSERT_EQUALS(\"-123\", f.getDecimalNumber(status).data());\n        ASSERT_SUCCESS(status);\n\n        status = U_ZERO_ERROR;\n        f.setDecimalNumber(\"1234567890123\", status);  // Number too big for 32 bits\n        ASSERT_SUCCESS(status);\n        ASSERT_EQUALS( Formattable::kInt64, f.getType());\n        ASSERT_EQUALS(1234567890123LL, f.getInt64());\n        ASSERT_EQUALS(1234567890123LL, f.getInt64(status));\n        ASSERT_SUCCESS(status);\n        ASSERT_EQUALS(\"1.234567890123E+12\", f.getDecimalNumber(status).data());\n        ASSERT_SUCCESS(status);\n    }\n\n    {\n        UErrorCode status = U_ZERO_ERROR;\n        NumberFormat *fmtr = NumberFormat::createInstance(Locale::getUS(), UNUM_DECIMAL, status);\n        if (U_FAILURE(status) || fmtr == NULL) {\n            dataerrln(\"Unable to create NumberFormat\");\n        } else {\n            UnicodeString formattedResult;\n            StringPiece num(\"244444444444444444444444444444444444446.4\");\n            fmtr->format(num, formattedResult, NULL, status);\n            ASSERT_SUCCESS(status);\n            ASSERT_EQUALS(\"244,444,444,444,444,444,444,444,444,444,444,444,446.4\", formattedResult);\n            //std::string ss; std::cout << formattedResult.toUTF8String(ss);\n            delete fmtr;\n        }\n    }\n\n    {\n        // Check formatting a DigitList.  DigitList is internal, but this is\n        // a critical interface that must work.\n        UErrorCode status = U_ZERO_ERROR;\n        NumberFormat *fmtr = NumberFormat::createInstance(Locale::getUS(), UNUM_DECIMAL, status);\n        if (U_FAILURE(status) || fmtr == NULL) {\n            dataerrln(\"Unable to create NumberFormat\");\n        } else {\n            UnicodeString formattedResult;\n            DecimalQuantity dl;\n            StringPiece num(\"123.4566666666666666666666666666666666621E+40\");\n            dl.setToDecNumber(num, status);\n            ASSERT_SUCCESS(status);\n            fmtr->format(dl, formattedResult, NULL, status);\n            ASSERT_SUCCESS(status);\n            ASSERT_EQUALS(\"1,234,566,666,666,666,666,666,666,666,666,666,666,621,000\", formattedResult);\n\n            status = U_ZERO_ERROR;\n            num.set(\"666.666\");\n            dl.setToDecNumber(num, status);\n            FieldPosition pos(NumberFormat::FRACTION_FIELD);\n            ASSERT_SUCCESS(status);\n            formattedResult.remove();\n            fmtr->format(dl, formattedResult, pos, status);\n            ASSERT_SUCCESS(status);\n            ASSERT_EQUALS(\"666.666\", formattedResult);\n            ASSERT_EQUALS(4, pos.getBeginIndex());\n            ASSERT_EQUALS(7, pos.getEndIndex());\n            delete fmtr;\n        }\n    }\n\n    {\n        // Check a parse with a formatter with a multiplier.\n        UErrorCode status = U_ZERO_ERROR;\n        NumberFormat *fmtr = NumberFormat::createInstance(Locale::getUS(), UNUM_PERCENT, status);\n        if (U_FAILURE(status) || fmtr == NULL) {\n            dataerrln(\"Unable to create NumberFormat\");\n        } else {\n            UnicodeString input = \"1.84%\";\n            Formattable result;\n            fmtr->parse(input, result, status);\n            ASSERT_SUCCESS(status);\n            ASSERT_EQUALS(\"0.0184\", result.getDecimalNumber(status).data());\n            //std::cout << result.getDecimalNumber(status).data();\n            delete fmtr;\n        }\n    }\n\n#if U_PLATFORM != U_PF_CYGWIN || defined(CYGWINMSVC)\n    /*\n     * This test fails on Cygwin (1.7.16) using GCC because of a rounding issue with strtod().\n     * See #9463\n     */\n    {\n        // Check that a parse returns a decimal number with full accuracy\n        UErrorCode status = U_ZERO_ERROR;\n        NumberFormat *fmtr = NumberFormat::createInstance(Locale::getUS(), UNUM_DECIMAL, status);\n        if (U_FAILURE(status) || fmtr == NULL) {\n            dataerrln(\"Unable to create NumberFormat\");\n        } else {\n            UnicodeString input = \"1.002200044400088880000070000\";\n            Formattable result;\n            fmtr->parse(input, result, status);\n            ASSERT_SUCCESS(status);\n            ASSERT_EQUALS(0, strcmp(\"1.00220004440008888000007\", result.getDecimalNumber(status).data()));\n            ASSERT_EQUALS(1.00220004440008888,   result.getDouble());\n            //std::cout << result.getDecimalNumber(status).data();\n            delete fmtr;\n        }\n    }\n#endif\n\n}\n\nvoid NumberFormatTest::TestCurrencyFractionDigits() {\n    UErrorCode status = U_ZERO_ERROR;\n    UnicodeString text1, text2;\n    double value = 99.12345;\n\n    // Create currenct instance\n    NumberFormat* fmt = NumberFormat::createCurrencyInstance(\"ja_JP\", status);\n    if (U_FAILURE(status) || fmt == NULL) {\n        dataerrln(\"Unable to create NumberFormat\");\n    } else {\n        fmt->format(value, text1);\n\n        // Reset the same currency and format the test value again\n        fmt->setCurrency(fmt->getCurrency(), status);\n        ASSERT_SUCCESS(status);\n        fmt->format(value, text2);\n\n        if (text1 != text2) {\n            errln((UnicodeString)\"NumberFormat::format() should return the same result - text1=\"\n                + text1 + \" text2=\" + text2);\n        }\n    }\n    delete fmt;\n}\n\nvoid NumberFormatTest::TestExponentParse() {\n\n    UErrorCode status = U_ZERO_ERROR;\n    Formattable result;\n    ParsePosition parsePos(0);\n\n    // set the exponent symbol\n    status = U_ZERO_ERROR;\n    DecimalFormatSymbols symbols(Locale::getDefault(), status);\n    if(U_FAILURE(status)) {\n        dataerrln((UnicodeString)\"ERROR: Could not create DecimalFormatSymbols (Default)\");\n        return;\n    }\n\n    // create format instance\n    status = U_ZERO_ERROR;\n    DecimalFormat fmt(u\"#####\", symbols, status);\n    if(U_FAILURE(status)) {\n        errln((UnicodeString)\"ERROR: Could not create DecimalFormat (pattern, symbols*)\");\n    }\n\n    // parse the text\n    fmt.parse(\"5.06e-27\", result, parsePos);\n    if(result.getType() != Formattable::kDouble &&\n       result.getDouble() != 5.06E-27 &&\n       parsePos.getIndex() != 8\n       )\n    {\n        errln(\"ERROR: parse failed - expected 5.06E-27, 8  - returned %d, %i\",\n              result.getDouble(), parsePos.getIndex());\n    }\n}\n\nvoid NumberFormatTest::TestExplicitParents() {\n\n    /* Test that number formats are properly inherited from es_419 */\n    /* These could be subject to change if the CLDR data changes */\n    static const char* parentLocaleTests[][2]= {\n    /* locale ID */  /* expected */\n    {\"es_CO\", \"1.250,75\" },\n    {\"es_ES\", \"1.250,75\" },\n    {\"es_GQ\", \"1.250,75\" },\n    {\"es_MX\", \"1,250.75\" },\n    {\"es_US\", \"1,250.75\" },\n    {\"es_VE\", \"1.250,75\" },\n    };\n\n    UnicodeString s;\n\n    for(int i=0; i < UPRV_LENGTHOF(parentLocaleTests); i++){\n        UErrorCode status = U_ZERO_ERROR;\n        const char *localeID = parentLocaleTests[i][0];\n        UnicodeString expected(parentLocaleTests[i][1], -1, US_INV);\n        expected = expected.unescape();\n        char loc[256]={0};\n        uloc_canonicalize(localeID, loc, 256, &status);\n        NumberFormat *fmt= NumberFormat::createInstance(Locale(loc), status);\n        if(U_FAILURE(status)){\n            dataerrln(\"Could not create number formatter for locale %s - %s\",localeID, u_errorName(status));\n            continue;\n        }\n        s.remove();\n        fmt->format(1250.75, s);\n        if(s!=expected){\n            errln(UnicodeString(\"FAIL: Expected: \")+expected\n                    + UnicodeString(\" Got: \") + s\n                    + UnicodeString( \" for locale: \")+ UnicodeString(localeID) );\n        }\n        if (U_FAILURE(status)){\n            errln((UnicodeString)\"FAIL: Status \" + (int32_t)status);\n        }\n        delete fmt;\n    }\n\n}\n\n/**\n * Test available numbering systems API.\n */\nvoid NumberFormatTest::TestAvailableNumberingSystems() {\n    UErrorCode status = U_ZERO_ERROR;\n    StringEnumeration *availableNumberingSystems = NumberingSystem::getAvailableNames(status);\n    CHECK_DATA(status, \"NumberingSystem::getAvailableNames()\")\n\n    int32_t nsCount = availableNumberingSystems->count(status);\n    if ( nsCount < 74 ) {\n        errln(\"FAIL: Didn't get as many numbering systems as we had hoped for. Need at least 74, got %d\",nsCount);\n    }\n\n    /* A relatively simple test of the API.  We call getAvailableNames() and cycle through */\n    /* each name returned, attempting to create a numbering system based on that name and  */\n    /* verifying that the name returned from the resulting numbering system is the same    */\n    /* one that we initially thought.                                                      */\n\n    int32_t len;\n    for ( int32_t i = 0 ; i < nsCount ; i++ ) {\n        const char *nsname = availableNumberingSystems->next(&len,status);\n        NumberingSystem* ns = NumberingSystem::createInstanceByName(nsname,status);\n        logln(\"OK for ns = %s\",nsname);\n        if ( uprv_strcmp(nsname,ns->getName()) ) {\n            errln(\"FAIL: Numbering system name didn't match for name = %s\\n\",nsname);\n        }\n\n        delete ns;\n    }\n\n    delete availableNumberingSystems;\n}\n\nvoid\nNumberFormatTest::Test9087(void)\n{\n    U_STRING_DECL(pattern,\"#\",1);\n    U_STRING_INIT(pattern,\"#\",1);\n\n    U_STRING_DECL(infstr,\"INF\",3);\n    U_STRING_INIT(infstr,\"INF\",3);\n\n    U_STRING_DECL(nanstr,\"NAN\",3);\n    U_STRING_INIT(nanstr,\"NAN\",3);\n\n    UChar outputbuf[50] = {0};\n    UErrorCode status = U_ZERO_ERROR;\n    UNumberFormat* fmt = unum_open(UNUM_PATTERN_DECIMAL,pattern,1,NULL,NULL,&status);\n    if ( U_FAILURE(status) ) {\n        dataerrln(\"FAIL: error in unum_open() - %s\", u_errorName(status));\n        return;\n    }\n\n    unum_setSymbol(fmt,UNUM_INFINITY_SYMBOL,infstr,3,&status);\n    unum_setSymbol(fmt,UNUM_NAN_SYMBOL,nanstr,3,&status);\n    if ( U_FAILURE(status) ) {\n        errln(\"FAIL: error setting symbols\");\n    }\n\n    double inf = uprv_getInfinity();\n\n    unum_setAttribute(fmt,UNUM_ROUNDING_MODE,UNUM_ROUND_HALFEVEN);\n    unum_setDoubleAttribute(fmt,UNUM_ROUNDING_INCREMENT,0);\n\n    UFieldPosition position = { 0, 0, 0};\n    unum_formatDouble(fmt,inf,outputbuf,50,&position,&status);\n\n    if ( u_strcmp(infstr, outputbuf)) {\n        errln((UnicodeString)\"FAIL: unexpected result for infinity - expected \" + infstr + \" got \" + outputbuf);\n    }\n\n    unum_close(fmt);\n}\n\nvoid NumberFormatTest::TestFormatFastpaths() {\n    // get some additional case\n    {\n        UErrorCode status=U_ZERO_ERROR;\n        DecimalFormat df(UnicodeString(u\"0000\"),status);\n        if (U_FAILURE(status)) {\n            dataerrln(\"Error creating DecimalFormat - %s\", u_errorName(status));\n        } else {\n            int64_t long_number = 1;\n            UnicodeString expect = \"0001\";\n            UnicodeString result;\n            FieldPosition pos;\n            df.format(long_number, result, pos);\n            if(U_FAILURE(status)||expect!=result) {\n                dataerrln(\"%s:%d FAIL: expected '%s' got '%s' status %s\",\n                          __FILE__, __LINE__, CStr(expect)(), CStr(result)(), u_errorName(status));\n             } else {\n                logln(\"OK:  got expected '\"+result+\"' status \"+UnicodeString(u_errorName(status),\"\"));\n            }\n        }\n    }\n    {\n        UErrorCode status=U_ZERO_ERROR;\n        DecimalFormat df(UnicodeString(u\"0000000000000000000\"),status);\n        if (U_FAILURE(status)) {\n            dataerrln(\"Error creating DecimalFormat - %s\", u_errorName(status));\n        } else {\n            int64_t long_number = U_INT64_MIN; // -9223372036854775808L;\n            // uint8_t bits[8];\n            // memcpy(bits,&long_number,8);\n            // for(int i=0;i<8;i++) {\n            //   logln(\"bits: %02X\", (unsigned int)bits[i]);\n            // }\n            UnicodeString expect = \"-9223372036854775808\";\n            UnicodeString result;\n            FieldPosition pos;\n            df.format(long_number, result, pos);\n            if(U_FAILURE(status)||expect!=result) {\n                dataerrln(\"%s:%d FAIL: expected '%s' got '%s' status %s on -9223372036854775808\",\n                          __FILE__, __LINE__, CStr(expect)(), CStr(result)(), u_errorName(status));\n            } else {\n                logln(\"OK:  got expected '\"+result+\"' status \"+UnicodeString(u_errorName(status),\"\")+\" on -9223372036854775808\");\n            }\n        }\n    }\n    {\n        UErrorCode status=U_ZERO_ERROR;\n        DecimalFormat df(UnicodeString(u\"0000000000000000000\"),status);\n        if (U_FAILURE(status)) {\n            dataerrln(\"Error creating DecimalFormat - %s\", u_errorName(status));\n        } else {\n            int64_t long_number = U_INT64_MAX; // -9223372036854775808L;\n            // uint8_t bits[8];\n            // memcpy(bits,&long_number,8);\n            // for(int i=0;i<8;i++) {\n            //   logln(\"bits: %02X\", (unsigned int)bits[i]);\n            // }\n            UnicodeString expect = \"9223372036854775807\";\n            UnicodeString result;\n            FieldPosition pos;\n            df.format(long_number, result, pos);\n            if(U_FAILURE(status)||expect!=result) {\n                dataerrln(\"%s:%d FAIL: expected '%s' got '%s' status %s on U_INT64_MAX\",\n                          __FILE__, __LINE__, CStr(expect)(), CStr(result)(), u_errorName(status));\n            } else {\n                logln(\"OK:  got expected '\"+result+\"' status \"+UnicodeString(u_errorName(status),\"\")+\" on U_INT64_MAX\");\n            }\n        }\n    }\n    {\n        UErrorCode status=U_ZERO_ERROR;\n        DecimalFormat df(UnicodeString(\"0000000000000000000\",\"\"),status);\n        if (U_FAILURE(status)) {\n            dataerrln(\"Error creating DecimalFormat - %s\", u_errorName(status));\n        } else {\n            int64_t long_number = 0;\n            // uint8_t bits[8];\n            // memcpy(bits,&long_number,8);\n            // for(int i=0;i<8;i++) {\n            //   logln(\"bits: %02X\", (unsigned int)bits[i]);\n            // }\n            UnicodeString expect = \"0000000000000000000\";\n            UnicodeString result;\n            FieldPosition pos;\n            df.format(long_number, result, pos);\n            if(U_FAILURE(status)||expect!=result) {\n                dataerrln(\"%s:%d FAIL: expected '%s' got '%s' status %s on 0\",\n                          __FILE__, __LINE__, CStr(expect)(), CStr(result)(), u_errorName(status));\n            } else {\n                logln(\"OK:  got expected '\"+result+\"' status \"+UnicodeString(u_errorName(status),\"\")+\" on 0\");\n            }\n        }\n    }\n    {\n        UErrorCode status=U_ZERO_ERROR;\n        DecimalFormat df(UnicodeString(\"0000000000000000000\",\"\"),status);\n        if (U_FAILURE(status)) {\n            dataerrln(\"Error creating DecimalFormat - %s\", u_errorName(status));\n        } else {\n            int64_t long_number = U_INT64_MIN + 1;\n            UnicodeString expect = \"-9223372036854775807\";\n            UnicodeString result;\n            FieldPosition pos;\n            df.format(long_number, result, pos);\n            if(U_FAILURE(status)||expect!=result) {\n                dataerrln(\"%s:%d FAIL: expected '%s' got '%s' status %s on -9223372036854775807\",\n                          __FILE__, __LINE__, CStr(expect)(), CStr(result)(), u_errorName(status));\n            } else {\n                logln(\"OK:  got expected '\"+result+\"' status \"+UnicodeString(u_errorName(status),\"\")+\" on -9223372036854775807\");\n            }\n        }\n    }\n}\n\n\nvoid NumberFormatTest::TestFormattableSize(void) {\n  if(sizeof(Formattable) > 112) {\n    errln(\"Error: sizeof(Formattable)=%d, 112=%d\\n\",\n          sizeof(Formattable), 112);\n  } else if(sizeof(Formattable) < 112) {\n    logln(\"Warning: sizeof(Formattable)=%d, 112=%d\\n\",\n        sizeof(Formattable), 112);\n  } else {\n    logln(\"sizeof(Formattable)=%d, 112=%d\\n\",\n        sizeof(Formattable), 112);\n  }\n}\n\nUBool NumberFormatTest::testFormattableAsUFormattable(const char *file, int line, Formattable &f) {\n  UnicodeString fileLine = UnicodeString(file)+UnicodeString(\":\")+line+UnicodeString(\": \");\n\n  UFormattable *u = f.toUFormattable();\n  logln();\n  if (u == NULL) {\n    errln(\"%s:%d: Error: f.toUFormattable() retuned NULL.\");\n    return FALSE;\n  }\n  logln(\"%s:%d: comparing Formattable with UFormattable\", file, line);\n  logln(fileLine + toString(f));\n\n  UErrorCode status = U_ZERO_ERROR;\n  UErrorCode valueStatus = U_ZERO_ERROR;\n  UFormattableType expectUType = UFMT_COUNT; // invalid\n\n  UBool triedExact = FALSE; // did we attempt an exact comparison?\n  UBool exactMatch = FALSE; // was the exact comparison true?\n\n  switch( f.getType() ) {\n  case Formattable::kDate:\n    expectUType = UFMT_DATE;\n    exactMatch = (f.getDate()==ufmt_getDate(u, &valueStatus));\n    triedExact = TRUE;\n    break;\n  case Formattable::kDouble:\n    expectUType = UFMT_DOUBLE;\n    exactMatch = (f.getDouble()==ufmt_getDouble(u, &valueStatus));\n    triedExact = TRUE;\n    break;\n  case Formattable::kLong:\n    expectUType = UFMT_LONG;\n    exactMatch = (f.getLong()==ufmt_getLong(u, &valueStatus));\n    triedExact = TRUE;\n    break;\n  case Formattable::kString:\n    expectUType = UFMT_STRING;\n    {\n      UnicodeString str;\n      f.getString(str);\n      int32_t len;\n      const UChar* uch = ufmt_getUChars(u, &len, &valueStatus);\n      if(U_SUCCESS(valueStatus)) {\n        UnicodeString str2(uch, len);\n        assertTrue(\"UChar* NULL-terminated\", uch[len]==0);\n        exactMatch = (str == str2);\n      }\n      triedExact = TRUE;\n    }\n    break;\n  case Formattable::kArray:\n    expectUType = UFMT_ARRAY;\n    triedExact = TRUE;\n    {\n      int32_t count = ufmt_getArrayLength(u, &valueStatus);\n      int32_t count2;\n      const Formattable *array2 = f.getArray(count2);\n      exactMatch = assertEquals(fileLine + \" array count\", count, count2);\n\n      if(exactMatch) {\n        for(int i=0;U_SUCCESS(valueStatus) && i<count;i++) {\n          UFormattable *uu = ufmt_getArrayItemByIndex(u, i, &valueStatus);\n          if(*Formattable::fromUFormattable(uu) != (array2[i])) {\n            errln(\"%s:%d: operator== did not match at index[%d] - %p vs %p\", file, line, i,\n                  (const void*)Formattable::fromUFormattable(uu), (const void*)&(array2[i]));\n            exactMatch = FALSE;\n          } else {\n            if(!testFormattableAsUFormattable(\"(sub item)\",i,*Formattable::fromUFormattable(uu))) {\n              exactMatch = FALSE;\n            }\n          }\n        }\n      }\n    }\n    break;\n  case Formattable::kInt64:\n    expectUType = UFMT_INT64;\n    exactMatch = (f.getInt64()==ufmt_getInt64(u, &valueStatus));\n    triedExact = TRUE;\n    break;\n  case Formattable::kObject:\n    expectUType = UFMT_OBJECT;\n    exactMatch = (f.getObject()==ufmt_getObject(u, &valueStatus));\n    triedExact = TRUE;\n    break;\n  }\n  UFormattableType uType = ufmt_getType(u, &status);\n\n  if(U_FAILURE(status)) {\n    errln(\"%s:%d: Error calling ufmt_getType - %s\", file, line, u_errorName(status));\n    return FALSE;\n  }\n\n  if(uType != expectUType) {\n    errln(\"%s:%d: got type (%d) expected (%d) from ufmt_getType\", file, line, (int) uType, (int) expectUType);\n  }\n\n  if(triedExact) {\n    if(U_FAILURE(valueStatus)) {\n      errln(\"%s:%d: got err %s trying to ufmt_get...() for exact match check\", file, line, u_errorName(valueStatus));\n    } else if(!exactMatch) {\n     errln(\"%s:%d: failed exact match for the Formattable type\", file, line);\n    } else {\n      logln(\"%s:%d: exact match OK\", file, line);\n    }\n  } else {\n    logln(\"%s:%d: note, did not attempt exact match for this formattable type\", file, line);\n  }\n\n  if( assertEquals(fileLine + \" isNumeric()\", f.isNumeric(), ufmt_isNumeric(u))\n      && f.isNumeric()) {\n    UErrorCode convStatus = U_ZERO_ERROR;\n\n    if(uType != UFMT_INT64) { // may fail to compare\n      assertTrue(fileLine + \" as doubles ==\", f.getDouble(convStatus)==ufmt_getDouble(u, &convStatus));\n    }\n\n    if( assertSuccess(fileLine + \" (numeric conversion status)\", convStatus) ) {\n      StringPiece fDecNum = f.getDecimalNumber(convStatus);\n#if 1\n      int32_t len;\n      const char *decNumChars = ufmt_getDecNumChars(u, &len, &convStatus);\n#else\n      // copy version\n      char decNumChars[200];\n      int32_t len = ufmt_getDecNumChars(u, decNumChars, 200, &convStatus);\n#endif\n\n      if( assertSuccess(fileLine + \" (decNumbers conversion)\", convStatus) ) {\n        logln(fileLine + decNumChars);\n        assertEquals(fileLine + \" decNumChars length==\", len, fDecNum.length());\n        assertEquals(fileLine + \" decNumChars digits\", decNumChars, fDecNum.data());\n      }\n\n      UErrorCode int64ConversionF = U_ZERO_ERROR;\n      int64_t l = f.getInt64(int64ConversionF);\n      UErrorCode int64ConversionU = U_ZERO_ERROR;\n      int64_t r = ufmt_getInt64(u, &int64ConversionU);\n\n      if( (l==r)\n          && ( uType != UFMT_INT64 ) // int64 better not overflow\n          && (U_INVALID_FORMAT_ERROR==int64ConversionU)\n          && (U_INVALID_FORMAT_ERROR==int64ConversionF) ) {\n        logln(\"%s:%d: OK: 64 bit overflow\", file, line);\n      } else {\n        assertEquals(fileLine + \" as int64 ==\", l, r);\n        assertSuccess(fileLine + \" Formattable.getnt64()\", int64ConversionF);\n        assertSuccess(fileLine + \" ufmt_getInt64()\", int64ConversionU);\n      }\n    }\n  }\n  return exactMatch || !triedExact;\n}\n\nvoid NumberFormatTest::TestUFormattable(void) {\n  {\n    // test that a default formattable is equal to Formattable()\n    UErrorCode status = U_ZERO_ERROR;\n    LocalUFormattablePointer defaultUFormattable(ufmt_open(&status));\n    assertSuccess(\"calling umt_open\", status);\n    Formattable defaultFormattable;\n    assertTrue((UnicodeString)\"comparing ufmt_open() with Formattable()\",\n               (defaultFormattable\n                == *(Formattable::fromUFormattable(defaultUFormattable.getAlias()))));\n    assertTrue((UnicodeString)\"comparing ufmt_open() with Formattable()\",\n               (defaultFormattable\n                == *(Formattable::fromUFormattable(defaultUFormattable.getAlias()))));\n    assertTrue((UnicodeString)\"comparing Formattable() round tripped through UFormattable\",\n               (defaultFormattable\n                == *(Formattable::fromUFormattable(defaultFormattable.toUFormattable()))));\n    assertTrue((UnicodeString)\"comparing &Formattable() round tripped through UFormattable\",\n               ((&defaultFormattable)\n                == Formattable::fromUFormattable(defaultFormattable.toUFormattable())));\n    assertFalse((UnicodeString)\"comparing &Formattable() with ufmt_open()\",\n               ((&defaultFormattable)\n                == Formattable::fromUFormattable(defaultUFormattable.getAlias())));\n    testFormattableAsUFormattable(__FILE__, __LINE__, defaultFormattable);\n  }\n  // test some random Formattables\n  {\n    Formattable f(ucal_getNow(), Formattable::kIsDate);\n    testFormattableAsUFormattable(__FILE__, __LINE__,  f);\n  }\n  {\n    Formattable f((double)1.61803398874989484820); // golden ratio\n    testFormattableAsUFormattable(__FILE__, __LINE__,  f);\n  }\n  {\n    Formattable f((int64_t)80994231587905127LL); // weight of the moon, in kilotons http://solarsystem.nasa.gov/planets/profile.cfm?Display=Facts&Object=Moon\n    testFormattableAsUFormattable(__FILE__, __LINE__,  f);\n  }\n  {\n    Formattable f((int32_t)4); // random number, source: http://www.xkcd.com/221/\n    testFormattableAsUFormattable(__FILE__, __LINE__,  f);\n  }\n  {\n    Formattable f(\"Hello world.\"); // should be invariant?\n    testFormattableAsUFormattable(__FILE__, __LINE__,  f);\n  }\n  {\n    UErrorCode status2 = U_ZERO_ERROR;\n    Formattable f(StringPiece(\"73476730924573500000000.0\"), status2); // weight of the moon, kg\n    assertSuccess(\"Constructing a StringPiece\", status2);\n    testFormattableAsUFormattable(__FILE__, __LINE__,  f);\n  }\n  {\n    UErrorCode status2 = U_ZERO_ERROR;\n    UObject *obj = new Locale();\n    Formattable f(obj);\n    assertSuccess(\"Constructing a Formattable from a default constructed Locale()\", status2);\n    testFormattableAsUFormattable(__FILE__, __LINE__,  f);\n  }\n  {\n    const Formattable array[] = {\n      Formattable(ucal_getNow(), Formattable::kIsDate),\n      Formattable((int32_t)4),\n      Formattable((double)1.234),\n    };\n\n    Formattable fa(array, 3);\n    testFormattableAsUFormattable(__FILE__, __LINE__, fa);\n  }\n}\n\nvoid NumberFormatTest::TestSignificantDigits(void) {\n  double input[] = {\n        0, 0,\n        0.1, -0.1,\n        123, -123,\n        12345, -12345,\n        123.45, -123.45,\n        123.44501, -123.44501,\n        0.001234, -0.001234,\n        0.00000000123, -0.00000000123,\n        0.0000000000000000000123, -0.0000000000000000000123,\n        1.2, -1.2,\n        0.0000000012344501, -0.0000000012344501,\n        123445.01, -123445.01,\n        12344501000000000000000000000000000.0, -12344501000000000000000000000000000.0,\n    };\n    const char* expected[] = {\n        \"0.00\", \"0.00\",\n        \"0.100\", \"-0.100\",\n        \"123\", \"-123\",\n        \"12345\", \"-12345\",\n        \"123.45\", \"-123.45\",\n        \"123.45\", \"-123.45\",\n        \"0.001234\", \"-0.001234\",\n        \"0.00000000123\", \"-0.00000000123\",\n        \"0.0000000000000000000123\", \"-0.0000000000000000000123\",\n        \"1.20\", \"-1.20\",\n        \"0.0000000012345\", \"-0.0000000012345\",\n        \"123450\", \"-123450\",\n        \"12345000000000000000000000000000000\", \"-12345000000000000000000000000000000\",\n    };\n\n    UErrorCode status = U_ZERO_ERROR;\n    Locale locale(\"en_US\");\n    LocalPointer<DecimalFormat> numberFormat(static_cast<DecimalFormat*>(\n            NumberFormat::createInstance(locale, status)));\n    CHECK_DATA(status,\"NumberFormat::createInstance\")\n\n    numberFormat->setSignificantDigitsUsed(TRUE);\n    numberFormat->setMinimumSignificantDigits(3);\n    numberFormat->setMaximumSignificantDigits(5);\n    numberFormat->setGroupingUsed(false);\n\n    UnicodeString result;\n    UnicodeString expectedResult;\n    for (unsigned int i = 0; i < UPRV_LENGTHOF(input); ++i) {\n        numberFormat->format(input[i], result);\n        UnicodeString expectedResult(expected[i]);\n        if (result != expectedResult) {\n          errln((UnicodeString)\"Expected: '\" + expectedResult + \"' got '\" + result);\n        }\n        result.remove();\n    }\n\n    // Test for ICU-20063\n    {\n        DecimalFormat df({\"en-us\", status}, status);\n        df.setSignificantDigitsUsed(TRUE);\n        expect(df, 9.87654321, u\"9.87654\");\n        df.setMaximumSignificantDigits(3);\n        expect(df, 9.87654321, u\"9.88\");\n        // setSignificantDigitsUsed with maxSig only\n        df.setSignificantDigitsUsed(TRUE);\n        expect(df, 9.87654321, u\"9.88\");\n        df.setMinimumSignificantDigits(2);\n        expect(df, 9, u\"9.0\");\n        // setSignificantDigitsUsed with both minSig and maxSig\n        df.setSignificantDigitsUsed(TRUE);\n        expect(df, 9, u\"9.0\");\n        // setSignificantDigitsUsed to false: should revert to fraction rounding\n        df.setSignificantDigitsUsed(FALSE);\n        expect(df, 9.87654321, u\"9.876543\");\n        expect(df, 9, u\"9\");\n        df.setSignificantDigitsUsed(TRUE);\n        df.setMinimumSignificantDigits(2);\n        expect(df, 9.87654321, u\"9.87654\");\n        expect(df, 9, u\"9.0\");\n        // setSignificantDigitsUsed with minSig only\n        df.setSignificantDigitsUsed(TRUE);\n        expect(df, 9.87654321, u\"9.87654\");\n        expect(df, 9, u\"9.0\");\n    }\n}\n\nvoid NumberFormatTest::TestShowZero() {\n    UErrorCode status = U_ZERO_ERROR;\n    Locale locale(\"en_US\");\n    LocalPointer<DecimalFormat> numberFormat(static_cast<DecimalFormat*>(\n            NumberFormat::createInstance(locale, status)));\n    CHECK_DATA(status, \"NumberFormat::createInstance\")\n\n    numberFormat->setSignificantDigitsUsed(TRUE);\n    numberFormat->setMaximumSignificantDigits(3);\n\n    UnicodeString result;\n    numberFormat->format(0.0, result);\n    if (result != \"0\") {\n        errln((UnicodeString)\"Expected: 0, got \" + result);\n    }\n}\n\nvoid NumberFormatTest::TestBug9936() {\n    UErrorCode status = U_ZERO_ERROR;\n    Locale locale(\"en_US\");\n    LocalPointer<DecimalFormat> numberFormat(static_cast<DecimalFormat*>(\n            NumberFormat::createInstance(locale, status)));\n    if (U_FAILURE(status)) {\n        dataerrln(\"File %s, Line %d: status = %s.\\n\", __FILE__, __LINE__, u_errorName(status));\n        return;\n    }\n\n    if (numberFormat->areSignificantDigitsUsed() == TRUE) {\n        errln(\"File %s, Line %d: areSignificantDigitsUsed() was TRUE, expected FALSE.\\n\", __FILE__, __LINE__);\n    }\n    numberFormat->setSignificantDigitsUsed(TRUE);\n    if (numberFormat->areSignificantDigitsUsed() == FALSE) {\n        errln(\"File %s, Line %d: areSignificantDigitsUsed() was FALSE, expected TRUE.\\n\", __FILE__, __LINE__);\n    }\n\n    numberFormat->setSignificantDigitsUsed(FALSE);\n    if (numberFormat->areSignificantDigitsUsed() == TRUE) {\n        errln(\"File %s, Line %d: areSignificantDigitsUsed() was TRUE, expected FALSE.\\n\", __FILE__, __LINE__);\n    }\n\n    numberFormat->setMinimumSignificantDigits(3);\n    if (numberFormat->areSignificantDigitsUsed() == FALSE) {\n        errln(\"File %s, Line %d: areSignificantDigitsUsed() was FALSE, expected TRUE.\\n\", __FILE__, __LINE__);\n    }\n\n    numberFormat->setSignificantDigitsUsed(FALSE);\n    numberFormat->setMaximumSignificantDigits(6);\n    if (numberFormat->areSignificantDigitsUsed() == FALSE) {\n        errln(\"File %s, Line %d: areSignificantDigitsUsed() was FALSE, expected TRUE.\\n\", __FILE__, __LINE__);\n    }\n\n}\n\nvoid NumberFormatTest::TestParseNegativeWithFaLocale() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat *test = (DecimalFormat *) NumberFormat::createInstance(\"fa\", status);\n    CHECK_DATA(status, \"NumberFormat::createInstance\")\n    test->setLenient(TRUE);\n    Formattable af;\n    ParsePosition ppos;\n    UnicodeString value(\"\\\\u200e-0,5\");\n    value = value.unescape();\n    test->parse(value, af, ppos);\n    if (ppos.getIndex() == 0) {\n        errln(\"Expected -0,5 to parse for Farsi.\");\n    }\n    delete test;\n}\n\nvoid NumberFormatTest::TestParseNegativeWithAlternateMinusSign() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat *test = (DecimalFormat *) NumberFormat::createInstance(\"en\", status);\n    CHECK_DATA(status, \"NumberFormat::createInstance\")\n    test->setLenient(TRUE);\n    Formattable af;\n    ParsePosition ppos;\n    UnicodeString value(\"\\\\u208B0.5\");\n    value = value.unescape();\n    test->parse(value, af, ppos);\n    if (ppos.getIndex() == 0) {\n        errln(UnicodeString(\"Expected \") + value + UnicodeString(\" to parse.\"));\n    }\n    delete test;\n}\n\nvoid NumberFormatTest::TestCustomCurrencySignAndSeparator() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols custom(Locale::getUS(), status);\n    CHECK(status, \"DecimalFormatSymbols constructor\");\n\n    custom.setSymbol(DecimalFormatSymbols::kCurrencySymbol, \"*\");\n    custom.setSymbol(DecimalFormatSymbols::kMonetaryGroupingSeparatorSymbol, \"^\");\n    custom.setSymbol(DecimalFormatSymbols::kMonetarySeparatorSymbol, \":\");\n\n    UnicodeString pat(\" #,##0.00\");\n    pat.insert(0, (UChar)0x00A4);\n\n    DecimalFormat fmt(pat, custom, status);\n    CHECK(status, \"DecimalFormat constructor\");\n\n    UnicodeString numstr(\"* 1^234:56\");\n    expect2(fmt, (Formattable)((double)1234.56), numstr);\n}\n\ntypedef struct {\n    const char *   locale;\n    UBool          lenient;\n    UnicodeString  numString;\n    double         value;\n} SignsAndMarksItem;\n\n\nvoid NumberFormatTest::TestParseSignsAndMarks() {\n    const SignsAndMarksItem items[] = {\n        // locale               lenient numString                                                       value\n        { \"en\",                 FALSE,  CharsToUnicodeString(\"12\"),                                      12 },\n        { \"en\",                 TRUE,   CharsToUnicodeString(\"12\"),                                      12 },\n        { \"en\",                 FALSE,  CharsToUnicodeString(\"-23\"),                                    -23 },\n        { \"en\",                 TRUE,   CharsToUnicodeString(\"-23\"),                                    -23 },\n        { \"en\",                 TRUE,   CharsToUnicodeString(\"- 23\"),                                   -23 },\n        { \"en\",                 FALSE,  CharsToUnicodeString(\"\\\\u200E-23\"),                             -23 },\n        { \"en\",                 TRUE,   CharsToUnicodeString(\"\\\\u200E-23\"),                             -23 },\n        { \"en\",                 TRUE,   CharsToUnicodeString(\"\\\\u200E- 23\"),                            -23 },\n\n        { \"en@numbers=arab\",    FALSE,  CharsToUnicodeString(\"\\\\u0663\\\\u0664\"),                          34 },\n        { \"en@numbers=arab\",    TRUE,   CharsToUnicodeString(\"\\\\u0663\\\\u0664\"),                          34 },\n        { \"en@numbers=arab\",    FALSE,  CharsToUnicodeString(\"-\\\\u0664\\\\u0665\"),                        -45 },\n        { \"en@numbers=arab\",    TRUE,   CharsToUnicodeString(\"-\\\\u0664\\\\u0665\"),                        -45 },\n        { \"en@numbers=arab\",    TRUE,   CharsToUnicodeString(\"- \\\\u0664\\\\u0665\"),                       -45 },\n        { \"en@numbers=arab\",    FALSE,  CharsToUnicodeString(\"\\\\u200F-\\\\u0664\\\\u0665\"),                 -45 },\n        { \"en@numbers=arab\",    TRUE,   CharsToUnicodeString(\"\\\\u200F-\\\\u0664\\\\u0665\"),                 -45 },\n        { \"en@numbers=arab\",    TRUE,   CharsToUnicodeString(\"\\\\u200F- \\\\u0664\\\\u0665\"),                -45 },\n\n        { \"en@numbers=arabext\", FALSE,  CharsToUnicodeString(\"\\\\u06F5\\\\u06F6\"),                          56 },\n        { \"en@numbers=arabext\", TRUE,   CharsToUnicodeString(\"\\\\u06F5\\\\u06F6\"),                          56 },\n        { \"en@numbers=arabext\", FALSE,  CharsToUnicodeString(\"-\\\\u06F6\\\\u06F7\"),                        -67 },\n        { \"en@numbers=arabext\", TRUE,   CharsToUnicodeString(\"-\\\\u06F6\\\\u06F7\"),                        -67 },\n        { \"en@numbers=arabext\", TRUE,   CharsToUnicodeString(\"- \\\\u06F6\\\\u06F7\"),                       -67 },\n        { \"en@numbers=arabext\", FALSE,  CharsToUnicodeString(\"\\\\u200E-\\\\u200E\\\\u06F6\\\\u06F7\"),          -67 },\n        { \"en@numbers=arabext\", TRUE,   CharsToUnicodeString(\"\\\\u200E-\\\\u200E\\\\u06F6\\\\u06F7\"),          -67 },\n        { \"en@numbers=arabext\", TRUE,   CharsToUnicodeString(\"\\\\u200E-\\\\u200E \\\\u06F6\\\\u06F7\"),         -67 },\n\n        { \"he\",                 FALSE,  CharsToUnicodeString(\"12\"),                                      12 },\n        { \"he\",                 TRUE,   CharsToUnicodeString(\"12\"),                                      12 },\n        { \"he\",                 FALSE,  CharsToUnicodeString(\"-23\"),                                    -23 },\n        { \"he\",                 TRUE,   CharsToUnicodeString(\"-23\"),                                    -23 },\n        { \"he\",                 TRUE,   CharsToUnicodeString(\"- 23\"),                                   -23 },\n        { \"he\",                 FALSE,  CharsToUnicodeString(\"\\\\u200E-23\"),                             -23 },\n        { \"he\",                 TRUE,   CharsToUnicodeString(\"\\\\u200E-23\"),                             -23 },\n        { \"he\",                 TRUE,   CharsToUnicodeString(\"\\\\u200E- 23\"),                            -23 },\n\n        { \"ar\",                 FALSE,  CharsToUnicodeString(\"\\\\u0663\\\\u0664\"),                          34 },\n        { \"ar\",                 TRUE,   CharsToUnicodeString(\"\\\\u0663\\\\u0664\"),                          34 },\n        { \"ar\",                 FALSE,  CharsToUnicodeString(\"-\\\\u0664\\\\u0665\"),                        -45 },\n        { \"ar\",                 TRUE,   CharsToUnicodeString(\"-\\\\u0664\\\\u0665\"),                        -45 },\n        { \"ar\",                 TRUE,   CharsToUnicodeString(\"- \\\\u0664\\\\u0665\"),                       -45 },\n        { \"ar\",                 FALSE,  CharsToUnicodeString(\"\\\\u200F-\\\\u0664\\\\u0665\"),                 -45 },\n        { \"ar\",                 TRUE,   CharsToUnicodeString(\"\\\\u200F-\\\\u0664\\\\u0665\"),                 -45 },\n        { \"ar\",                 TRUE,   CharsToUnicodeString(\"\\\\u200F- \\\\u0664\\\\u0665\"),                -45 },\n\n        { \"ar_MA\",              FALSE,  CharsToUnicodeString(\"12\"),                                      12 },\n        { \"ar_MA\",              TRUE,   CharsToUnicodeString(\"12\"),                                      12 },\n        { \"ar_MA\",              FALSE,  CharsToUnicodeString(\"-23\"),                                    -23 },\n        { \"ar_MA\",              TRUE,   CharsToUnicodeString(\"-23\"),                                    -23 },\n        { \"ar_MA\",              TRUE,   CharsToUnicodeString(\"- 23\"),                                   -23 },\n        { \"ar_MA\",              FALSE,  CharsToUnicodeString(\"\\\\u200E-23\"),                             -23 },\n        { \"ar_MA\",              TRUE,   CharsToUnicodeString(\"\\\\u200E-23\"),                             -23 },\n        { \"ar_MA\",              TRUE,   CharsToUnicodeString(\"\\\\u200E- 23\"),                            -23 },\n\n        { \"fa\",                 FALSE,  CharsToUnicodeString(\"\\\\u06F5\\\\u06F6\"),                          56 },\n        { \"fa\",                 TRUE,   CharsToUnicodeString(\"\\\\u06F5\\\\u06F6\"),                          56 },\n        { \"fa\",                 FALSE,  CharsToUnicodeString(\"\\\\u2212\\\\u06F6\\\\u06F7\"),                  -67 },\n        { \"fa\",                 TRUE,   CharsToUnicodeString(\"\\\\u2212\\\\u06F6\\\\u06F7\"),                  -67 },\n        { \"fa\",                 TRUE,   CharsToUnicodeString(\"\\\\u2212 \\\\u06F6\\\\u06F7\"),                 -67 },\n        { \"fa\",                 FALSE,  CharsToUnicodeString(\"\\\\u200E\\\\u2212\\\\u200E\\\\u06F6\\\\u06F7\"),    -67 },\n        { \"fa\",                 TRUE,   CharsToUnicodeString(\"\\\\u200E\\\\u2212\\\\u200E\\\\u06F6\\\\u06F7\"),    -67 },\n        { \"fa\",                 TRUE,   CharsToUnicodeString(\"\\\\u200E\\\\u2212\\\\u200E \\\\u06F6\\\\u06F7\"),   -67 },\n\n        { \"ps\",                 FALSE,  CharsToUnicodeString(\"\\\\u06F5\\\\u06F6\"),                          56 },\n        { \"ps\",                 TRUE,   CharsToUnicodeString(\"\\\\u06F5\\\\u06F6\"),                          56 },\n        { \"ps\",                 FALSE,  CharsToUnicodeString(\"-\\\\u06F6\\\\u06F7\"),                        -67 },\n        { \"ps\",                 TRUE,   CharsToUnicodeString(\"-\\\\u06F6\\\\u06F7\"),                        -67 },\n        { \"ps\",                 TRUE,   CharsToUnicodeString(\"- \\\\u06F6\\\\u06F7\"),                       -67 },\n        { \"ps\",                 FALSE,  CharsToUnicodeString(\"\\\\u200E-\\\\u200E\\\\u06F6\\\\u06F7\"),          -67 },\n        { \"ps\",                 TRUE,   CharsToUnicodeString(\"\\\\u200E-\\\\u200E\\\\u06F6\\\\u06F7\"),          -67 },\n        { \"ps\",                 TRUE,   CharsToUnicodeString(\"\\\\u200E-\\\\u200E \\\\u06F6\\\\u06F7\"),         -67 },\n        { \"ps\",                 FALSE,  CharsToUnicodeString(\"-\\\\u200E\\\\u06F6\\\\u06F7\"),                 -67 },\n        { \"ps\",                 TRUE,   CharsToUnicodeString(\"-\\\\u200E\\\\u06F6\\\\u06F7\"),                 -67 },\n        { \"ps\",                 TRUE,   CharsToUnicodeString(\"-\\\\u200E \\\\u06F6\\\\u06F7\"),                -67 },\n        // terminator\n        { NULL,                 0,      UnicodeString(\"\"),                                                0 },\n    };\n\n    const SignsAndMarksItem * itemPtr;\n    for (itemPtr = items; itemPtr->locale != NULL; itemPtr++ ) {\n        UErrorCode status = U_ZERO_ERROR;\n        NumberFormat *numfmt = NumberFormat::createInstance(Locale(itemPtr->locale), status);\n        if (U_SUCCESS(status)) {\n            numfmt->setLenient(itemPtr->lenient);\n            Formattable fmtobj;\n            ParsePosition ppos;\n            numfmt->parse(itemPtr->numString, fmtobj, ppos);\n            if (ppos.getIndex() == itemPtr->numString.length()) {\n                double parsedValue = fmtobj.getDouble(status);\n                if (U_FAILURE(status) || parsedValue != itemPtr->value) {\n                    errln((UnicodeString)\"FAIL: locale \" + itemPtr->locale + \", lenient \" + itemPtr->lenient + \", parse of \\\"\" + itemPtr->numString + \"\\\" gives value \" + parsedValue);\n                }\n            } else {\n                errln((UnicodeString)\"FAIL: locale \" + itemPtr->locale + \", lenient \" + itemPtr->lenient + \", parse of \\\"\" + itemPtr->numString + \"\\\" gives position \" + ppos.getIndex());\n            }\n        } else {\n            dataerrln(\"FAIL: NumberFormat::createInstance for locale % gives error %s\", itemPtr->locale, u_errorName(status));\n        }\n        delete numfmt;\n    }\n}\n\ntypedef struct {\n  DecimalFormat::ERoundingMode mode;\n  double value;\n  UnicodeString expected;\n} Test10419Data;\n\n\n// Tests that rounding works right when fractional digits is set to 0.\nvoid NumberFormatTest::Test10419RoundingWith0FractionDigits() {\n    const Test10419Data items[] = {\n        { DecimalFormat::kRoundCeiling, 1.488,  \"2\"},\n        { DecimalFormat::kRoundDown, 1.588,  \"1\"},\n        { DecimalFormat::kRoundFloor, 1.888,  \"1\"},\n        { DecimalFormat::kRoundHalfDown, 1.5,  \"1\"},\n        { DecimalFormat::kRoundHalfEven, 2.5,  \"2\"},\n        { DecimalFormat::kRoundHalfUp, 2.5,  \"3\"},\n        { DecimalFormat::kRoundUp, 1.5,  \"2\"},\n    };\n    UErrorCode status = U_ZERO_ERROR;\n    LocalPointer<DecimalFormat> decfmt((DecimalFormat *) NumberFormat::createInstance(Locale(\"en_US\"), status));\n    if (U_FAILURE(status)) {\n        dataerrln(\"Failure creating DecimalFormat %s\", u_errorName(status));\n        return;\n    }\n    for (int32_t i = 0; i < UPRV_LENGTHOF(items); ++i) {\n        decfmt->setRoundingMode(items[i].mode);\n        decfmt->setMaximumFractionDigits(0);\n        UnicodeString actual;\n        if (items[i].expected != decfmt->format(items[i].value, actual)) {\n            errln(\"Expected \" + items[i].expected + \", got \" + actual);\n        }\n    }\n}\n\nvoid NumberFormatTest::Test10468ApplyPattern() {\n    // Padding char of fmt is now 'a'\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat fmt(\"'I''ll'*a###.##\", status);\n\n    if (U_FAILURE(status)) {\n        errcheckln(status, \"DecimalFormat constructor failed - %s\", u_errorName(status));\n        return;\n    }\n\n    assertEquals(\"Padding character should be 'a'.\", u\"a\", fmt.getPadCharacterString());\n\n    // Padding char of fmt ought to be '*' since that is the default and no\n    // explicit padding char is specified in the new pattern.\n    fmt.applyPattern(\"AA#,##0.00ZZ\", status);\n\n    // Oops this still prints 'a' even though we changed the pattern.\n    assertEquals(\"applyPattern did not clear padding character.\", u\" \", fmt.getPadCharacterString());\n}\n\nvoid NumberFormatTest::TestRoundingScientific10542() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat format(\"0.00E0\", status);\n    if (U_FAILURE(status)) {\n        errcheckln(status, \"DecimalFormat constructor failed - %s\", u_errorName(status));\n        return;\n    }\n\n    DecimalFormat::ERoundingMode roundingModes[] = {\n            DecimalFormat::kRoundCeiling,\n            DecimalFormat::kRoundDown,\n            DecimalFormat::kRoundFloor,\n            DecimalFormat::kRoundHalfDown,\n            DecimalFormat::kRoundHalfEven,\n            DecimalFormat::kRoundHalfUp,\n            DecimalFormat::kRoundUp};\n    const char *descriptions[] = {\n            \"Round Ceiling\",\n            \"Round Down\",\n            \"Round Floor\",\n            \"Round half down\",\n            \"Round half even\",\n            \"Round half up\",\n            \"Round up\"};\n\n    {\n        double values[] = {-0.003006, -0.003005, -0.003004, 0.003014, 0.003015, 0.003016};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        const char *expected[] = {\n                \"-3.00E-3\", \"-3.00E-3\", \"-3.00E-3\", \"3.02E-3\", \"3.02E-3\", \"3.02E-3\",\n                \"-3.00E-3\", \"-3.00E-3\", \"-3.00E-3\", \"3.01E-3\", \"3.01E-3\", \"3.01E-3\",\n                \"-3.01E-3\", \"-3.01E-3\", \"-3.01E-3\", \"3.01E-3\", \"3.01E-3\", \"3.01E-3\",\n                \"-3.01E-3\", \"-3.00E-3\", \"-3.00E-3\", \"3.01E-3\", \"3.01E-3\", \"3.02E-3\",\n                \"-3.01E-3\", \"-3.00E-3\", \"-3.00E-3\", \"3.01E-3\", \"3.02E-3\", \"3.02E-3\",\n                \"-3.01E-3\", \"-3.01E-3\", \"-3.00E-3\", \"3.01E-3\", \"3.02E-3\", \"3.02E-3\",\n                \"-3.01E-3\", \"-3.01E-3\", \"-3.01E-3\", \"3.02E-3\", \"3.02E-3\", \"3.02E-3\"};\n        verifyRounding(\n                format,\n                values,\n                expected,\n                roundingModes,\n                descriptions,\n                UPRV_LENGTHOF(values),\n                UPRV_LENGTHOF(roundingModes));\n    }\n    {\n        double values[] = {-3006.0, -3005, -3004, 3014, 3015, 3016};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        const char *expected[] = {\n                \"-3.00E3\", \"-3.00E3\", \"-3.00E3\", \"3.02E3\", \"3.02E3\", \"3.02E3\",\n                \"-3.00E3\", \"-3.00E3\", \"-3.00E3\", \"3.01E3\", \"3.01E3\", \"3.01E3\",\n                \"-3.01E3\", \"-3.01E3\", \"-3.01E3\", \"3.01E3\", \"3.01E3\", \"3.01E3\",\n                \"-3.01E3\", \"-3.00E3\", \"-3.00E3\", \"3.01E3\", \"3.01E3\", \"3.02E3\",\n                \"-3.01E3\", \"-3.00E3\", \"-3.00E3\", \"3.01E3\", \"3.02E3\", \"3.02E3\",\n                \"-3.01E3\", \"-3.01E3\", \"-3.00E3\", \"3.01E3\", \"3.02E3\", \"3.02E3\",\n                \"-3.01E3\", \"-3.01E3\", \"-3.01E3\", \"3.02E3\", \"3.02E3\", \"3.02E3\"};\n        verifyRounding(\n                format,\n                values,\n                expected,\n                roundingModes,\n                descriptions,\n                UPRV_LENGTHOF(values),\n                UPRV_LENGTHOF(roundingModes));\n    }\n/* Commented out for now until we decide how rounding to zero should work, +0 vs. -0\n    {\n        double values[] = {0.0, -0.0};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        const char *expected[] = {\n                \"0.00E0\", \"-0.00E0\",\n                \"0.00E0\", \"-0.00E0\",\n                \"0.00E0\", \"-0.00E0\",\n                \"0.00E0\", \"-0.00E0\",\n                \"0.00E0\", \"-0.00E0\",\n                \"0.00E0\", \"-0.00E0\",\n                \"0.00E0\", \"-0.00E0\"};\n        verifyRounding(\n                format,\n                values,\n                expected,\n                roundingModes,\n                descriptions,\n                UPRV_LENGTHOF(values),\n                UPRV_LENGTHOF(roundingModes));\n    }\n*/\n    {\n\n        double values[] = {1e25, 1e25 + 1e15, 1e25 - 1e15};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        const char *expected[] = {\n                \"1.00E25\", \"1.01E25\", \"1.00E25\",\n                \"1.00E25\", \"1.00E25\", \"9.99E24\",\n                \"1.00E25\", \"1.00E25\", \"9.99E24\",\n                \"1.00E25\", \"1.00E25\", \"1.00E25\",\n                \"1.00E25\", \"1.00E25\", \"1.00E25\",\n                \"1.00E25\", \"1.00E25\", \"1.00E25\",\n                \"1.00E25\", \"1.01E25\", \"1.00E25\"};\n        verifyRounding(\n                format,\n                values,\n                expected,\n                roundingModes,\n                descriptions,\n                UPRV_LENGTHOF(values),\n                UPRV_LENGTHOF(roundingModes));\n        }\n    {\n        double values[] = {-1e25, -1e25 + 1e15, -1e25 - 1e15};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        const char *expected[] = {\n                \"-1.00E25\", \"-9.99E24\", \"-1.00E25\",\n                \"-1.00E25\", \"-9.99E24\", \"-1.00E25\",\n                \"-1.00E25\", \"-1.00E25\", \"-1.01E25\",\n                \"-1.00E25\", \"-1.00E25\", \"-1.00E25\",\n                \"-1.00E25\", \"-1.00E25\", \"-1.00E25\",\n                \"-1.00E25\", \"-1.00E25\", \"-1.00E25\",\n                \"-1.00E25\", \"-1.00E25\", \"-1.01E25\"};\n        verifyRounding(\n                format,\n                values,\n                expected,\n                roundingModes,\n                descriptions,\n                UPRV_LENGTHOF(values),\n                UPRV_LENGTHOF(roundingModes));\n        }\n    {\n        double values[] = {1e-25, 1e-25 + 1e-35, 1e-25 - 1e-35};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        const char *expected[] = {\n                \"1.00E-25\", \"1.01E-25\", \"1.00E-25\",\n                \"1.00E-25\", \"1.00E-25\", \"9.99E-26\",\n                \"1.00E-25\", \"1.00E-25\", \"9.99E-26\",\n                \"1.00E-25\", \"1.00E-25\", \"1.00E-25\",\n                \"1.00E-25\", \"1.00E-25\", \"1.00E-25\",\n                \"1.00E-25\", \"1.00E-25\", \"1.00E-25\",\n                \"1.00E-25\", \"1.01E-25\", \"1.00E-25\"};\n        verifyRounding(\n                format,\n                values,\n                expected,\n                roundingModes,\n                descriptions,\n                UPRV_LENGTHOF(values),\n                UPRV_LENGTHOF(roundingModes));\n        }\n    {\n        double values[] = {-1e-25, -1e-25 + 1e-35, -1e-25 - 1e-35};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        const char *expected[] = {\n                \"-1.00E-25\", \"-9.99E-26\", \"-1.00E-25\",\n                \"-1.00E-25\", \"-9.99E-26\", \"-1.00E-25\",\n                \"-1.00E-25\", \"-1.00E-25\", \"-1.01E-25\",\n                \"-1.00E-25\", \"-1.00E-25\", \"-1.00E-25\",\n                \"-1.00E-25\", \"-1.00E-25\", \"-1.00E-25\",\n                \"-1.00E-25\", \"-1.00E-25\", \"-1.00E-25\",\n                \"-1.00E-25\", \"-1.00E-25\", \"-1.01E-25\"};\n        verifyRounding(\n                format,\n                values,\n                expected,\n                roundingModes,\n                descriptions,\n                UPRV_LENGTHOF(values),\n                UPRV_LENGTHOF(roundingModes));\n    }\n}\n\nvoid NumberFormatTest::TestZeroScientific10547() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat fmt(\"0.00E0\", status);\n    if (!assertSuccess(\"Format creation\", status)) {\n        return;\n    }\n    UnicodeString out;\n    fmt.format(-0.0, out);\n    assertEquals(\"format\", \"-0.00E0\", out, true);\n}\n\nvoid NumberFormatTest::verifyRounding(\n        DecimalFormat& format,\n        const double *values,\n        const char * const *expected,\n        const DecimalFormat::ERoundingMode *roundingModes,\n        const char * const *descriptions,\n        int32_t valueSize,\n        int32_t roundingModeSize) {\n    for (int32_t i = 0; i < roundingModeSize; ++i) {\n        format.setRoundingMode(roundingModes[i]);\n        for (int32_t j = 0; j < valueSize; j++) {\n            UnicodeString currentExpected(expected[i * valueSize + j]);\n            currentExpected = currentExpected.unescape();\n            UnicodeString actual;\n            format.format(values[j], actual);\n            if (currentExpected != actual) {\n                dataerrln(\"For %s value %f, expected '%s', got '%s'\",\n                          descriptions[i], values[j], CStr(currentExpected)(), CStr(actual)());\n            }\n        }\n    }\n}\n\nvoid NumberFormatTest::TestAccountingCurrency() {\n    UErrorCode status = U_ZERO_ERROR;\n    UNumberFormatStyle style = UNUM_CURRENCY_ACCOUNTING;\n\n    expect(NumberFormat::createInstance(\"en_US\", style, status),\n        (Formattable)(double)1234.5, \"$1,234.50\", TRUE, status);\n    expect(NumberFormat::createInstance(\"en_US\", style, status),\n        (Formattable)(double)-1234.5, \"($1,234.50)\", TRUE, status);\n    expect(NumberFormat::createInstance(\"en_US\", style, status),\n        (Formattable)(double)0, \"$0.00\", TRUE, status);\n    expect(NumberFormat::createInstance(\"en_US\", style, status),\n        (Formattable)(double)-0.2, \"($0.20)\", TRUE, status);\n    expect(NumberFormat::createInstance(\"ja_JP\", style, status),\n        (Formattable)(double)10000, UnicodeString(\"\\\\uFFE510,000\").unescape(), TRUE, status);\n    expect(NumberFormat::createInstance(\"ja_JP\", style, status),\n        (Formattable)(double)-1000.5, UnicodeString(\"(\\\\uFFE51,000)\").unescape(), FALSE, status);\n    expect(NumberFormat::createInstance(\"de_DE\", style, status),\n        (Formattable)(double)-23456.7, UnicodeString(\"-23.456,70\\\\u00A0\\\\u20AC\").unescape(), TRUE, status);\n}\n\n// for #5186\nvoid NumberFormatTest::TestEquality() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols symbols(Locale(\"root\"), status);\n    if (U_FAILURE(status)) {\n    \tdataerrln(\"Fail: can't create DecimalFormatSymbols for root\");\n    \treturn;\n    }\n    UnicodeString pattern(\"#,##0.###\");\n    DecimalFormat fmtBase(pattern, symbols, status);\n    if (U_FAILURE(status)) {\n    \tdataerrln(\"Fail: can't create DecimalFormat using root symbols\");\n    \treturn;\n    }\n\n    DecimalFormat* fmtClone = (DecimalFormat*)fmtBase.clone();\n    fmtClone->setFormatWidth(fmtBase.getFormatWidth() + 32);\n    if (*fmtClone == fmtBase) {\n        errln(\"Error: DecimalFormat == does not distinguish objects that differ only in FormatWidth\");\n    }\n    delete fmtClone;\n}\n\nvoid NumberFormatTest::TestCurrencyUsage() {\n    double agent = 123.567;\n\n    UErrorCode status;\n    DecimalFormat *fmt;\n\n    // compare the Currency and Currency Cash Digits\n    // Note that as of CLDR 26:\n    // * TWD and PKR switched from 0 decimals to 2; ISK still has 0, so change test to that\n    // * CAD rounds to .05 in cash mode only\n    // 1st time for getter/setter, 2nd time for factory method\n    Locale enUS_ISK(\"en_US@currency=ISK\");\n\n    for(int i=0; i<2; i++){\n        status = U_ZERO_ERROR;\n        if(i == 0){\n            fmt = (DecimalFormat *) NumberFormat::createInstance(enUS_ISK, UNUM_CURRENCY, status);\n            if (assertSuccess(\"en_US@currency=ISK/CURRENCY\", status, TRUE) == FALSE) {\n                continue;\n            }\n\n            UnicodeString original;\n            fmt->format(agent,original);\n            assertEquals(\"Test Currency Usage 1\", u\"ISK\\u00A0124\", original);\n\n            // test the getter here\n            UCurrencyUsage curUsage = fmt->getCurrencyUsage();\n            assertEquals(\"Test usage getter - standard\", (int32_t)curUsage, (int32_t)UCURR_USAGE_STANDARD);\n\n            fmt->setCurrencyUsage(UCURR_USAGE_CASH, &status);\n        }else{\n            fmt = (DecimalFormat *) NumberFormat::createInstance(enUS_ISK, UNUM_CASH_CURRENCY, status);\n            if (assertSuccess(\"en_US@currency=ISK/CASH\", status, TRUE) == FALSE) {\n                continue;\n            }\n        }\n\n        // must be usage = cash\n        UCurrencyUsage curUsage = fmt->getCurrencyUsage();\n        assertEquals(\"Test usage getter - cash\", (int32_t)curUsage, (int32_t)UCURR_USAGE_CASH);\n\n        UnicodeString cash_currency;\n        fmt->format(agent,cash_currency);\n        assertEquals(\"Test Currency Usage 2\", u\"ISK\\u00A0124\", cash_currency);\n        delete fmt;\n    }\n\n    // compare the Currency and Currency Cash Rounding\n    // 1st time for getter/setter, 2nd time for factory method\n    Locale enUS_CAD(\"en_US@currency=CAD\");\n    for(int i=0; i<2; i++){\n        status = U_ZERO_ERROR;\n        if(i == 0){\n            fmt = (DecimalFormat *) NumberFormat::createInstance(enUS_CAD, UNUM_CURRENCY, status);\n            if (assertSuccess(\"en_US@currency=CAD/CURRENCY\", status, TRUE) == FALSE) {\n                continue;\n            }\n\n            UnicodeString original_rounding;\n            fmt->format(agent, original_rounding);\n            assertEquals(\"Test Currency Usage 3\", u\"CA$123.57\", original_rounding);\n            fmt->setCurrencyUsage(UCURR_USAGE_CASH, &status);\n        }else{\n            fmt = (DecimalFormat *) NumberFormat::createInstance(enUS_CAD, UNUM_CASH_CURRENCY, status);\n            if (assertSuccess(\"en_US@currency=CAD/CASH\", status, TRUE) == FALSE) {\n                continue;\n            }\n        }\n\n        UnicodeString cash_rounding_currency;\n        fmt->format(agent, cash_rounding_currency);\n        assertEquals(\"Test Currency Usage 4\", u\"CA$123.55\", cash_rounding_currency);\n        delete fmt;\n    }\n\n    // Test the currency change\n    // 1st time for getter/setter, 2nd time for factory method\n    const UChar CUR_PKR[] = {0x50, 0x4B, 0x52, 0};\n    for(int i=0; i<2; i++){\n        status = U_ZERO_ERROR;\n        if(i == 0){\n            fmt = (DecimalFormat *) NumberFormat::createInstance(enUS_CAD, UNUM_CURRENCY, status);\n            if (assertSuccess(\"en_US@currency=CAD/CURRENCY\", status, TRUE) == FALSE) {\n                continue;\n            }\n            fmt->setCurrencyUsage(UCURR_USAGE_CASH, &status);\n        }else{\n            fmt = (DecimalFormat *) NumberFormat::createInstance(enUS_CAD, UNUM_CASH_CURRENCY, status);\n            if (assertSuccess(\"en_US@currency=CAD/CASH\", status, TRUE) == FALSE) {\n                continue;\n            }\n        }\n\n        UnicodeString cur_original;\n        fmt->setCurrencyUsage(UCURR_USAGE_STANDARD, &status);\n        fmt->format(agent, cur_original);\n        assertEquals(\"Test Currency Usage 5\", u\"CA$123.57\", cur_original);\n\n        fmt->setCurrency(CUR_PKR, status);\n        assertSuccess(\"Set currency to PKR\", status);\n\n        UnicodeString PKR_changed;\n        fmt->format(agent, PKR_changed);\n        assertEquals(\"Test Currency Usage 6\", u\"PKR\\u00A0123.57\", PKR_changed);\n        delete fmt;\n    }\n}\n\n\n// Check the constant MAX_INT64_IN_DOUBLE.\n// The value should convert to a double with no loss of precision.\n// A failure may indicate a platform with a different double format, requiring\n// a revision to the constant.\n//\n// Note that this is actually hard to test, because the language standard gives\n//  compilers considerable flexibility to do unexpected things with rounding and\n//  with overflow in simple int to/from float conversions. Some compilers will completely optimize\n//  away a simple round-trip conversion from int64_t -> double -> int64_t.\n\nvoid NumberFormatTest::TestDoubleLimit11439() {\n    char  buf[50];\n    for (int64_t num = MAX_INT64_IN_DOUBLE-10; num<=MAX_INT64_IN_DOUBLE; num++) {\n        sprintf(buf, \"%lld\", (long long)num);\n        double fNum = 0.0;\n        sscanf(buf, \"%lf\", &fNum);\n        int64_t rtNum = static_cast<int64_t>(fNum);\n        if (num != rtNum) {\n            errln(\"%s:%d MAX_INT64_IN_DOUBLE test, %lld did not round trip. Got %lld\", __FILE__, __LINE__, (long long)num, (long long)rtNum);\n            return;\n        }\n    }\n    for (int64_t num = -MAX_INT64_IN_DOUBLE+10; num>=-MAX_INT64_IN_DOUBLE; num--) {\n        sprintf(buf, \"%lld\", (long long)num);\n        double fNum = 0.0;\n        sscanf(buf, \"%lf\", &fNum);\n        int64_t rtNum = static_cast<int64_t>(fNum);\n        if (num != rtNum) {\n            errln(\"%s:%d MAX_INT64_IN_DOUBLE test, %lld did not round trip. Got %lld\", __FILE__, __LINE__, (long long)num, (long long)rtNum);\n            return;\n        }\n    }\n}\n\nvoid NumberFormatTest::TestGetAffixes() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols sym(\"en_US\", status);\n    UnicodeString pattern(\"\\\\u00a4\\\\u00a4\\\\u00a4 0.00 %\\\\u00a4\\\\u00a4\");\n    pattern = pattern.unescape();\n    DecimalFormat fmt(pattern, sym, status);\n    if (U_FAILURE(status)) {\n        dataerrln(\"Error creating DecimalFormat - %s\", u_errorName(status));\n        return;\n    }\n    UnicodeString affixStr;\n    assertEquals(\"\", \"US dollars \", fmt.getPositivePrefix(affixStr));\n    assertEquals(\"\", \" %USD\", fmt.getPositiveSuffix(affixStr));\n    assertEquals(\"\", \"-US dollars \", fmt.getNegativePrefix(affixStr));\n    assertEquals(\"\", \" %USD\", fmt.getNegativeSuffix(affixStr));\n\n    // Test equality with affixes. set affix methods can't capture special\n    // characters which is why equality should fail.\n    {\n        DecimalFormat fmtCopy(fmt);\n        assertTrue(\"\", fmt == fmtCopy);\n        UnicodeString someAffix;\n        fmtCopy.setPositivePrefix(fmtCopy.getPositivePrefix(someAffix));\n        assertTrue(\"\", fmt != fmtCopy);\n    }\n    {\n        DecimalFormat fmtCopy(fmt);\n        assertTrue(\"\", fmt == fmtCopy);\n        UnicodeString someAffix;\n        fmtCopy.setPositiveSuffix(fmtCopy.getPositiveSuffix(someAffix));\n        assertTrue(\"\", fmt != fmtCopy);\n    }\n    {\n        DecimalFormat fmtCopy(fmt);\n        assertTrue(\"\", fmt == fmtCopy);\n        UnicodeString someAffix;\n        fmtCopy.setNegativePrefix(fmtCopy.getNegativePrefix(someAffix));\n        assertTrue(\"\", fmt != fmtCopy);\n    }\n    {\n        DecimalFormat fmtCopy(fmt);\n        assertTrue(\"\", fmt == fmtCopy);\n        UnicodeString someAffix;\n        fmtCopy.setNegativeSuffix(fmtCopy.getNegativeSuffix(someAffix));\n        assertTrue(\"\", fmt != fmtCopy);\n    }\n    fmt.setPositivePrefix(\"Don't\");\n    fmt.setPositiveSuffix(\"do\");\n    UnicodeString someAffix(\"be''eet\\\\u00a4\\\\u00a4\\\\u00a4 it.\");\n    someAffix = someAffix.unescape();\n    fmt.setNegativePrefix(someAffix);\n    fmt.setNegativeSuffix(\"%\");\n    assertEquals(\"\", \"Don't\", fmt.getPositivePrefix(affixStr));\n    assertEquals(\"\", \"do\", fmt.getPositiveSuffix(affixStr));\n    assertEquals(\"\", someAffix, fmt.getNegativePrefix(affixStr));\n    assertEquals(\"\", \"%\", fmt.getNegativeSuffix(affixStr));\n}\n\nvoid NumberFormatTest::TestToPatternScientific11648() {\n    UErrorCode status = U_ZERO_ERROR;\n    Locale en(\"en\");\n    DecimalFormatSymbols sym(en, status);\n    DecimalFormat fmt(\"0.00\", sym, status);\n    if (U_FAILURE(status)) {\n        dataerrln(\"Error creating DecimalFormat - %s\", u_errorName(status));\n        return;\n    }\n    fmt.setScientificNotation(TRUE);\n    UnicodeString pattern;\n    assertEquals(\"\", \"0.00E0\", fmt.toPattern(pattern));\n    DecimalFormat fmt2(pattern, sym, status);\n    assertSuccess(\"\", status);\n}\n\nvoid NumberFormatTest::TestBenchmark() {\n/*\n    UErrorCode status = U_ZERO_ERROR;\n    Locale en(\"en\");\n    DecimalFormatSymbols sym(en, status);\n    DecimalFormat fmt(\"0.0000000\", new DecimalFormatSymbols(sym), status);\n//    DecimalFormat fmt(\"0.00000E0\", new DecimalFormatSymbols(sym), status);\n//    DecimalFormat fmt(\"0\", new DecimalFormatSymbols(sym), status);\n    FieldPosition fpos(FieldPosition::DONT_CARE);\n    clock_t start = clock();\n    for (int32_t i = 0; i < 1000000; ++i) {\n        UnicodeString append;\n        fmt.format(3.0, append, fpos, status);\n//        fmt.format(4.6692016, append, fpos, status);\n//        fmt.format(1234567.8901, append, fpos, status);\n//        fmt.format(2.99792458E8, append, fpos, status);\n//        fmt.format(31, append);\n    }\n    errln(\"Took %f\", (double) (clock() - start) / CLOCKS_PER_SEC);\n    assertSuccess(\"\", status);\n\n    UErrorCode status = U_ZERO_ERROR;\n    MessageFormat fmt(\"{0, plural, one {I have # friend.} other {I have # friends.}}\", status);\n    FieldPosition fpos(FieldPosition::DONT_CARE);\n    Formattable one(1.0);\n    Formattable three(3.0);\n    clock_t start = clock();\n    for (int32_t i = 0; i < 500000; ++i) {\n        UnicodeString append;\n        fmt.format(&one, 1, append, fpos, status);\n        UnicodeString append2;\n        fmt.format(&three, 1, append2, fpos, status);\n    }\n    errln(\"Took %f\", (double) (clock() - start) / CLOCKS_PER_SEC);\n    assertSuccess(\"\", status);\n\n    UErrorCode status = U_ZERO_ERROR;\n    Locale en(\"en\");\n    Measure measureC(23, MeasureUnit::createCelsius(status), status);\n    MeasureFormat fmt(en, UMEASFMT_WIDTH_WIDE, status);\n    FieldPosition fpos(FieldPosition::DONT_CARE);\n    clock_t start = clock();\n    for (int32_t i = 0; i < 1000000; ++i) {\n        UnicodeString appendTo;\n        fmt.formatMeasures(\n                &measureC, 1, appendTo, fpos, status);\n    }\n    errln(\"Took %f\", (double) (clock() - start) / CLOCKS_PER_SEC);\n    assertSuccess(\"\", status);\n*/\n}\n\nvoid NumberFormatTest::TestFractionalDigitsForCurrency() {\n    UErrorCode status = U_ZERO_ERROR;\n    LocalPointer<NumberFormat> fmt(NumberFormat::createCurrencyInstance(\"en\", status));\n    if (U_FAILURE(status)) {\n        dataerrln(\"Error creating NumberFormat - %s\", u_errorName(status));\n        return;\n    }\n    UChar JPY[] = {0x4A, 0x50, 0x59, 0x0};\n    fmt->setCurrency(JPY, status);\n    if (!assertSuccess(\"\", status)) {\n        return;\n    }\n    assertEquals(\"\", 0, fmt->getMaximumFractionDigits());\n}\n\n\nvoid NumberFormatTest::TestFormatCurrencyPlural() {\n    UErrorCode status = U_ZERO_ERROR;\n    Locale locale = Locale::createCanonical(\"en_US\");\n    NumberFormat *fmt = NumberFormat::createInstance(locale, UNUM_CURRENCY_PLURAL, status);\n    if (U_FAILURE(status)) {\n        dataerrln(\"Error creating NumberFormat - %s\", u_errorName(status));\n        return;\n    }\n   UnicodeString formattedNum;\n   fmt->format(11234.567, formattedNum, NULL, status);\n   assertEquals(\"\", \"11,234.57 US dollars\", formattedNum);\n   delete fmt;\n}\n\nvoid NumberFormatTest::TestCtorApplyPatternDifference() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols sym(\"en_US\", status);\n    UnicodeString pattern(\"\\\\u00a40\");\n    DecimalFormat fmt(pattern.unescape(), sym, status);\n    if (U_FAILURE(status)) {\n        dataerrln(\"Error creating DecimalFormat - %s\", u_errorName(status));\n        return;\n    }\n    UnicodeString result;\n    assertEquals(\n            \"ctor favors precision of currency\",\n            \"$5.00\",\n            fmt.format((double)5, result));\n    result.remove();\n    fmt.applyPattern(pattern.unescape(), status);\n    assertEquals(\n            \"applyPattern favors precision of pattern\",\n            \"$5\",\n            fmt.format((double)5, result));\n}\n\nvoid NumberFormatTest::Test11868() {\n    double posAmt = 34.567;\n    double negAmt = -9876.543;\n\n    Locale selectedLocale(\"en_US\");\n    UErrorCode status = U_ZERO_ERROR;\n\n    UnicodeString result;\n    FieldPosition fpCurr(UNUM_CURRENCY_FIELD);\n    LocalPointer<NumberFormat> fmt(\n            NumberFormat::createInstance(\n                    selectedLocale, UNUM_CURRENCY_PLURAL, status));\n    if (!assertSuccess(\"Format creation\", status)) {\n        return;\n    }\n    fmt->format(posAmt, result, fpCurr, status);\n    assertEquals(\"\", \"34.57 US dollars\", result);\n    assertEquals(\"begin index\", 6, fpCurr.getBeginIndex());\n    assertEquals(\"end index\", 16, fpCurr.getEndIndex());\n\n    // Test field position iterator\n    {\n        NumberFormatTest_Attributes attributes[] = {\n                {UNUM_INTEGER_FIELD, 0, 2},\n                {UNUM_DECIMAL_SEPARATOR_FIELD, 2, 3},\n                {UNUM_FRACTION_FIELD, 3, 5},\n                {UNUM_CURRENCY_FIELD, 6, 16},\n                {0, -1, 0}};\n        UnicodeString result;\n        FieldPositionIterator iter;\n        fmt->format(posAmt, result, &iter, status);\n        assertEquals(\"\", \"34.57 US dollars\", result);\n        verifyFieldPositionIterator(attributes, iter);\n    }\n\n    result.remove();\n    fmt->format(negAmt, result, fpCurr, status);\n    assertEquals(\"\", \"-9,876.54 US dollars\", result);\n    assertEquals(\"begin index\", 10, fpCurr.getBeginIndex());\n    assertEquals(\"end index\", 20, fpCurr.getEndIndex());\n\n    // Test field position iterator\n    {\n        NumberFormatTest_Attributes attributes[] = {\n                {UNUM_SIGN_FIELD, 0, 1},\n                {UNUM_GROUPING_SEPARATOR_FIELD, 2, 3},\n                {UNUM_INTEGER_FIELD, 1, 6},\n                {UNUM_DECIMAL_SEPARATOR_FIELD, 6, 7},\n                {UNUM_FRACTION_FIELD, 7, 9},\n                {UNUM_CURRENCY_FIELD, 10, 20},\n                {0, -1, 0}};\n        UnicodeString result;\n        FieldPositionIterator iter;\n        fmt->format(negAmt, result, &iter, status);\n        assertEquals(\"\", \"-9,876.54 US dollars\", result);\n        verifyFieldPositionIterator(attributes, iter);\n    }\n}\n\nvoid NumberFormatTest::Test10727_RoundingZero() {\n    IcuTestErrorCode status(*this, \"Test10727_RoundingZero\");\n    DecimalQuantity dq;\n    dq.setToDouble(-0.0);\n    assertTrue(\"\", dq.isNegative());\n    dq.roundToMagnitude(0, UNUM_ROUND_HALFEVEN, status);\n    assertTrue(\"\", dq.isNegative());\n}\n\nvoid NumberFormatTest::Test11739_ParseLongCurrency() {\n    IcuTestErrorCode status(*this, \"Test11739_ParseLongCurrency\");\n    LocalPointer<NumberFormat> nf(NumberFormat::createCurrencyInstance(\"sr_BA\", status));\n    if (status.errDataIfFailureAndReset()) { return; }\n    ((DecimalFormat*) nf.getAlias())->applyPattern(u\"#,##0.0 \u00a4\u00a4\u00a4\", status);\n    ParsePosition ppos(0);\n    LocalPointer<CurrencyAmount> result(nf->parseCurrency(u\"1.500 \u0430\u043c\u0435\u0440\u0438\u0447\u043a\u0438 \u0434\u043e\u043b\u0430\u0440\", ppos));\n    assertEquals(\"Should parse to 1500 USD\", -1, ppos.getErrorIndex());\n    assertEquals(\"Should parse to 1500 USD\", 1500LL, result->getNumber().getInt64(status));\n    assertEquals(\"Should parse to 1500 USD\", u\"USD\", result->getISOCurrency());\n}\n\nvoid NumberFormatTest::Test13035_MultiCodePointPaddingInPattern() {\n    IcuTestErrorCode status(*this, \"Test13035_MultiCodePointPaddingInPattern\");\n    DecimalFormat df(u\"a*'\u0ba8\u0bbf'###0b\", status);\n    if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) { return; }\n    UnicodeString result;\n    df.format(12, result.remove());\n    // TODO(13034): Re-enable this test when support is added in ICU4C.\n    //assertEquals(\"Multi-codepoint padding should not be split\", u\"a\u0ba8\u0bbf\u0ba8\u0bbf12b\", result);\n    df = DecimalFormat(u\"a*\\U0001F601###0b\", status);\n    if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) { return; }\n    result = df.format(12, result.remove());\n    assertEquals(\"Single-codepoint padding should not be split\", u\"a\\U0001F601\\U0001F60112b\", result, true);\n    df = DecimalFormat(u\"a*''###0b\", status);\n    if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) { return; }\n    result = df.format(12, result.remove());\n    assertEquals(\"Quote should be escapable in padding syntax\", \"a''12b\", result, true);\n}\n\nvoid NumberFormatTest::Test13737_ParseScientificStrict() {\n    IcuTestErrorCode status(*this, \"Test13737_ParseScientificStrict\");\n    LocalPointer<NumberFormat> df(NumberFormat::createScientificInstance(\"en\", status), status);\n    if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) {return;}\n    df->setLenient(FALSE);\n    // Parse Test\n    expect(*df, u\"1.2\", 1.2);\n}\n\nvoid NumberFormatTest::Test11376_getAndSetPositivePrefix() {\n    {\n        const UChar USD[] = {0x55, 0x53, 0x44, 0x0};\n        UErrorCode status = U_ZERO_ERROR;\n        LocalPointer<NumberFormat> fmt(\n                NumberFormat::createCurrencyInstance(\"en\", status));\n        if (!assertSuccess(\"\", status)) {\n            return;\n        }\n        DecimalFormat *dfmt = (DecimalFormat *) fmt.getAlias();\n        dfmt->setCurrency(USD);\n        UnicodeString result;\n\n        // This line should be a no-op. I am setting the positive prefix\n        // to be the same thing it was before.\n        dfmt->setPositivePrefix(dfmt->getPositivePrefix(result));\n\n        UnicodeString appendTo;\n        assertEquals(\"\", \"$3.78\", dfmt->format(3.78, appendTo, status));\n        assertSuccess(\"\", status);\n    }\n    {\n        const UChar USD[] = {0x55, 0x53, 0x44, 0x0};\n        UErrorCode status = U_ZERO_ERROR;\n        LocalPointer<NumberFormat> fmt(\n                NumberFormat::createInstance(\"en\", UNUM_CURRENCY_PLURAL, status));\n        if (!assertSuccess(\"\", status)) {\n            return;\n        }\n        DecimalFormat *dfmt = (DecimalFormat *) fmt.getAlias();\n        UnicodeString result;\n        assertEquals(\"\", u\" (unknown currency)\", dfmt->getPositiveSuffix(result));\n        dfmt->setCurrency(USD);\n\n        // getPositiveSuffix() always returns the suffix for the\n        // \"other\" plural category\n        assertEquals(\"\", \" US dollars\", dfmt->getPositiveSuffix(result));\n        UnicodeString appendTo;\n        assertEquals(\"\", \"3.78 US dollars\", dfmt->format(3.78, appendTo, status));\n        assertEquals(\"\", \" US dollars\", dfmt->getPositiveSuffix(result));\n        dfmt->setPositiveSuffix(\"booya\");\n        appendTo.remove();\n        assertEquals(\"\", \"3.78booya\", dfmt->format(3.78, appendTo, status));\n        assertEquals(\"\", \"booya\", dfmt->getPositiveSuffix(result));\n    }\n}\n\nvoid NumberFormatTest::Test11475_signRecognition() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols sym(\"en\", status);\n    UnicodeString result;\n    {\n        DecimalFormat fmt(\"+0.00\", sym, status);\n        if (!assertSuccess(\"\", status)) {\n            return;\n        }\n        NumberFormatTest_Attributes attributes[] = {\n                {UNUM_SIGN_FIELD, 0, 1},\n                {UNUM_INTEGER_FIELD, 1, 2},\n                {UNUM_DECIMAL_SEPARATOR_FIELD, 2, 3},\n                {UNUM_FRACTION_FIELD, 3, 5},\n                {0, -1, 0}};\n        UnicodeString result;\n        FieldPositionIterator iter;\n        fmt.format(2.3, result, &iter, status);\n        assertEquals(\"\", \"+2.30\", result);\n        verifyFieldPositionIterator(attributes, iter);\n    }\n    {\n        DecimalFormat fmt(\"++0.00+;-(#)--\", sym, status);\n        if (!assertSuccess(\"\", status)) {\n            return;\n        }\n        {\n            NumberFormatTest_Attributes attributes[] = {\n                    {UNUM_SIGN_FIELD, 0, 2},\n                    {UNUM_INTEGER_FIELD, 2, 3},\n                    {UNUM_DECIMAL_SEPARATOR_FIELD, 3, 4},\n                    {UNUM_FRACTION_FIELD, 4, 6},\n                    {UNUM_SIGN_FIELD, 6, 7},\n                    {0, -1, 0}};\n            UnicodeString result;\n            FieldPositionIterator iter;\n            fmt.format(2.3, result, &iter, status);\n            assertEquals(\"\", \"++2.30+\", result);\n            verifyFieldPositionIterator(attributes, iter);\n        }\n        {\n            NumberFormatTest_Attributes attributes[] = {\n                    {UNUM_SIGN_FIELD, 0, 1},\n                    {UNUM_INTEGER_FIELD, 2, 3},\n                    {UNUM_DECIMAL_SEPARATOR_FIELD, 3, 4},\n                    {UNUM_FRACTION_FIELD, 4, 6},\n                    {UNUM_SIGN_FIELD, 7, 9},\n                    {0, -1, 0}};\n            UnicodeString result;\n            FieldPositionIterator iter;\n            fmt.format(-2.3, result, &iter, status);\n            assertEquals(\"\", \"-(2.30)--\", result);\n            verifyFieldPositionIterator(attributes, iter);\n        }\n    }\n}\n\nvoid NumberFormatTest::Test11640_getAffixes() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols symbols(\"en_US\", status);\n    if (!assertSuccess(\"\", status)) {\n        return;\n    }\n    UnicodeString pattern(\"\\\\u00a4\\\\u00a4\\\\u00a4 0.00 %\\\\u00a4\\\\u00a4\");\n    pattern = pattern.unescape();\n    DecimalFormat fmt(pattern, symbols, status);\n    if (!assertSuccess(\"\", status)) {\n        return;\n    }\n    UnicodeString affixStr;\n    assertEquals(\"\", \"US dollars \", fmt.getPositivePrefix(affixStr));\n    assertEquals(\"\", \" %USD\", fmt.getPositiveSuffix(affixStr));\n    assertEquals(\"\", \"-US dollars \", fmt.getNegativePrefix(affixStr));\n    assertEquals(\"\", \" %USD\", fmt.getNegativeSuffix(affixStr));\n}\n\nvoid NumberFormatTest::Test11649_toPatternWithMultiCurrency() {\n    UnicodeString pattern(\"\\\\u00a4\\\\u00a4\\\\u00a4 0.00\");\n    pattern = pattern.unescape();\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat fmt(pattern, status);\n    if (!assertSuccess(\"\", status)) {\n        return;\n    }\n    static UChar USD[] = {0x55, 0x53, 0x44, 0x0};\n    fmt.setCurrency(USD);\n    UnicodeString appendTo;\n\n    assertEquals(\"\", \"US dollars 12.34\", fmt.format(12.34, appendTo));\n\n    UnicodeString topattern;\n    fmt.toPattern(topattern);\n    DecimalFormat fmt2(topattern, status);\n    if (!assertSuccess(\"\", status)) {\n        return;\n    }\n    fmt2.setCurrency(USD);\n\n    appendTo.remove();\n    assertEquals(\"\", \"US dollars 12.34\", fmt2.format(12.34, appendTo));\n}\n\nvoid NumberFormatTest::Test13327_numberingSystemBufferOverflow() {\n    UErrorCode status = U_ZERO_ERROR;\n    for (int runId = 0; runId < 2; runId++) {\n        // Construct a locale string with a very long \"numbers\" value.\n        // The first time, make the value length exactly equal to ULOC_KEYWORDS_CAPACITY.\n        // The second time, make it exceed ULOC_KEYWORDS_CAPACITY.\n        int extraLength = (runId == 0) ? 0 : 5;\n\n        CharString localeId(\"en@numbers=\", status);\n        for (int i = 0; i < ULOC_KEYWORDS_CAPACITY + extraLength; i++) {\n            localeId.append('x', status);\n        }\n        assertSuccess(\"Constructing locale string\", status);\n        Locale locale(localeId.data());\n\n        LocalPointer<NumberingSystem> ns(NumberingSystem::createInstance(locale, status));\n        assertFalse(\"Should not be null\", ns.getAlias() == nullptr);\n        assertSuccess(\"Should create with no error\", status);\n    }\n}\n\nvoid NumberFormatTest::Test13391_chakmaParsing() {\n    UErrorCode status = U_ZERO_ERROR;\n    LocalPointer<DecimalFormat> df(dynamic_cast<DecimalFormat*>(\n        NumberFormat::createInstance(Locale(\"ccp\"), status)));\n    if (df == nullptr) {\n        dataerrln(\"%s %d Chakma df is null\",  __FILE__, __LINE__);\n        return;\n    }\n    const UChar* expected = u\"\\U00011137\\U00011138,\\U00011139\\U0001113A\\U0001113B\";\n    UnicodeString actual;\n    df->format(12345, actual, status);\n    assertSuccess(\"Should not fail when formatting in ccp\", status);\n    assertEquals(\"Should produce expected output in ccp\", expected, actual);\n\n    Formattable result;\n    df->parse(expected, result, status);\n    assertSuccess(\"Should not fail when parsing in ccp\", status);\n    assertEquals(\"Should parse to 12345 in ccp\", 12345, result);\n\n    const UChar* expectedScientific = u\"\\U00011137.\\U00011139E\\U00011138\";\n    UnicodeString actualScientific;\n    df.adoptInstead(static_cast<DecimalFormat*>(\n        NumberFormat::createScientificInstance(Locale(\"ccp\"), status)));\n    df->format(130, actualScientific, status);\n    assertSuccess(\"Should not fail when formatting scientific in ccp\", status);\n    assertEquals(\"Should produce expected scientific output in ccp\",\n        expectedScientific, actualScientific);\n\n    Formattable resultScientific;\n    df->parse(expectedScientific, resultScientific, status);\n    assertSuccess(\"Should not fail when parsing scientific in ccp\", status);\n    assertEquals(\"Should parse scientific to 130 in ccp\", 130, resultScientific);\n}\n\n\nvoid NumberFormatTest::verifyFieldPositionIterator(\n        NumberFormatTest_Attributes *expected, FieldPositionIterator &iter) {\n    int32_t idx = 0;\n    FieldPosition fp;\n    while (iter.next(fp)) {\n        if (expected[idx].spos == -1) {\n            errln(\"Iterator should have ended. got %d\", fp.getField());\n            return;\n        }\n        assertEquals(\"id\", expected[idx].id, fp.getField());\n        assertEquals(\"start\", expected[idx].spos, fp.getBeginIndex());\n        assertEquals(\"end\", expected[idx].epos, fp.getEndIndex());\n        ++idx;\n    }\n    if (expected[idx].spos != -1) {\n        errln(\"Premature end of iterator. expected %d\", expected[idx].id);\n    }\n}\n\nvoid NumberFormatTest::Test11735_ExceptionIssue() {\n    IcuTestErrorCode status(*this, \"Test11735_ExceptionIssue\");\n    Locale enLocale(\"en\");\n    DecimalFormatSymbols symbols(enLocale, status);\n    if (status.isSuccess()) {\n        DecimalFormat fmt(\"0\", symbols, status);\n        assertSuccess(\"Fail: Construct DecimalFormat formatter\", status, true, __FILE__, __LINE__);\n        ParsePosition ppos(0);\n        fmt.parseCurrency(\"53.45\", ppos);  // NPE thrown here in ICU4J.\n        assertEquals(\"Issue11735 ppos\", 0, ppos.getIndex());\n    }\n}\n\nvoid NumberFormatTest::Test11035_FormatCurrencyAmount() {\n    UErrorCode status = U_ZERO_ERROR;\n    double amount = 12345.67;\n    const char16_t* expected = u\"12,345$67\u00a0\u200b\";\n\n    // Test two ways to set a currency via API\n\n    Locale loc1 = Locale(\"pt_PT\");\n    LocalPointer<NumberFormat> fmt1(NumberFormat::createCurrencyInstance(\"loc1\", status),\n                                    status);\n    if (U_FAILURE(status)) {\n      dataerrln(\"%s %d NumberFormat instance fmt1 is null\",  __FILE__, __LINE__);\n      return;\n    }\n    fmt1->setCurrency(u\"PTE\", status);\n    assertSuccess(\"Setting currency on fmt1\", status);\n    UnicodeString actualSetCurrency;\n    fmt1->format(amount, actualSetCurrency);\n\n    Locale loc2 = Locale(\"pt_PT@currency=PTE\");\n    LocalPointer<NumberFormat> fmt2(NumberFormat::createCurrencyInstance(loc2, status));\n    assertSuccess(\"Creating fmt2\", status);\n    UnicodeString actualLocaleString;\n    fmt2->format(amount, actualLocaleString);\n\n    // TODO: The following test will fail until DecimalFormat wraps NumberFormatter.\n    if (!logKnownIssue(\"13574\")) {\n        assertEquals(\"Custom Currency Pattern, Set Currency\", expected, actualSetCurrency);\n    }\n}\n\nvoid NumberFormatTest::Test11318_DoubleConversion() {\n    IcuTestErrorCode status(*this, \"Test11318_DoubleConversion\");\n    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(\"en\", status), status);\n    if (U_FAILURE(status)) {\n      dataerrln(\"%s %d Error in NumberFormat instance creation\",  __FILE__, __LINE__);\n      return;\n    }\n    nf->setMaximumFractionDigits(40);\n    nf->setMaximumIntegerDigits(40);\n    UnicodeString appendTo;\n    nf->format(999999999999999.9, appendTo);\n    assertEquals(\"Should render all digits\", u\"999,999,999,999,999.9\", appendTo);\n}\n\nvoid NumberFormatTest::TestParsePercentRegression() {\n    IcuTestErrorCode status(*this, \"TestParsePercentRegression\");\n    LocalPointer<DecimalFormat> df1((DecimalFormat*) NumberFormat::createInstance(\"en\", status), status);\n    LocalPointer<DecimalFormat> df2((DecimalFormat*) NumberFormat::createPercentInstance(\"en\", status), status);\n    if (status.isFailure()) {return; }\n    df1->setLenient(TRUE);\n    df2->setLenient(TRUE);\n\n    {\n        ParsePosition ppos;\n        Formattable result;\n        df1->parse(\"50%\", result, ppos);\n        assertEquals(\"df1 should accept a number but not the percent sign\", 2, ppos.getIndex());\n        assertEquals(\"df1 should return the number as 50\", 50.0, result.getDouble(status));\n    }\n    {\n        ParsePosition ppos;\n        Formattable result;\n        df2->parse(\"50%\", result, ppos);\n        assertEquals(\"df2 should accept the percent sign\", 3, ppos.getIndex());\n        assertEquals(\"df2 should return the number as 0.5\", 0.5, result.getDouble(status));\n    }\n    {\n        ParsePosition ppos;\n        Formattable result;\n        df2->parse(\"50\", result, ppos);\n        assertEquals(\"df2 should return the number as 0.5 even though the percent sign is missing\",\n                0.5,\n                result.getDouble(status));\n    }\n}\n\nvoid NumberFormatTest::TestMultiplierWithScale() {\n    IcuTestErrorCode status(*this, \"TestMultiplierWithScale\");\n\n    // Test magnitude combined with multiplier, as shown in API docs\n    DecimalFormat df(\"0\", {\"en\", status}, status);\n    if (status.isSuccess()) {\n        df.setMultiplier(5);\n        df.setMultiplierScale(-1);\n        expect2(df, 100, u\"50\"); // round-trip test\n    }\n}\n\nvoid NumberFormatTest::TestFastFormatInt32() {\n    IcuTestErrorCode status(*this, \"TestFastFormatInt32\");\n\n    // The two simplest formatters, old API and new API.\n    // Old API should use the fastpath for ints.\n    LocalizedNumberFormatter lnf = NumberFormatter::withLocale(\"en\");\n    LocalPointer<NumberFormat> df(NumberFormat::createInstance(\"en\", status), status);\n    if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) {return;}\n\n    double nums[] = {\n            0.0,\n            -0.0,\n            NAN,\n            INFINITY,\n            0.1,\n            1.0,\n            1.1,\n            2.0,\n            3.0,\n            9.0,\n            10.0,\n            99.0,\n            100.0,\n            999.0,\n            1000.0,\n            9999.0,\n            10000.0,\n            99999.0,\n            100000.0,\n            999999.0,\n            1000000.0,\n            static_cast<double>(INT32_MAX) - 1,\n            static_cast<double>(INT32_MAX),\n            static_cast<double>(INT32_MAX) + 1,\n            static_cast<double>(INT32_MIN) - 1,\n            static_cast<double>(INT32_MIN),\n            static_cast<double>(INT32_MIN) + 1};\n\n    for (auto num : nums) {\n        UnicodeString expected = lnf.formatDouble(num, status).toString();\n        UnicodeString actual;\n        df->format(num, actual);\n        assertEquals(UnicodeString(\"d = \") + num, expected, actual);\n    }\n}\n\nvoid NumberFormatTest::Test11646_Equality() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols symbols(Locale::getEnglish(), status);\n    UnicodeString pattern(u\"\\u00a4\\u00a4\\u00a4 0.00 %\\u00a4\\u00a4\");\n    DecimalFormat fmt(pattern, symbols, status);\n    if (!assertSuccess(\"\", status)) return;\n\n    // Test equality with affixes. set affix methods can't capture special\n    // characters which is why equality should fail.\n    {\n        DecimalFormat fmtCopy(fmt);\n        assertTrue(\"\", fmt == fmtCopy);\n        UnicodeString positivePrefix;\n        fmtCopy.setPositivePrefix(fmtCopy.getPositivePrefix(positivePrefix));\n        assertFalse(\"\", fmt == fmtCopy);\n    }\n    {\n        DecimalFormat fmtCopy = DecimalFormat(fmt);\n        assertTrue(\"\", fmt == fmtCopy);\n        UnicodeString positivePrefix;\n        fmtCopy.setPositiveSuffix(fmtCopy.getPositiveSuffix(positivePrefix));\n        assertFalse(\"\", fmt == fmtCopy);\n    }\n    {\n        DecimalFormat fmtCopy(fmt);\n        assertTrue(\"\", fmt == fmtCopy);\n        UnicodeString negativePrefix;\n        fmtCopy.setNegativePrefix(fmtCopy.getNegativePrefix(negativePrefix));\n        assertFalse(\"\", fmt == fmtCopy);\n    }\n    {\n        DecimalFormat fmtCopy(fmt);\n        assertTrue(\"\", fmt == fmtCopy);\n        UnicodeString negativePrefix;\n        fmtCopy.setNegativeSuffix(fmtCopy.getNegativeSuffix(negativePrefix));\n        assertFalse(\"\", fmt == fmtCopy);\n    }\n}\n\nvoid NumberFormatTest::TestParseNaN() {\n    IcuTestErrorCode status(*this, \"TestParseNaN\");\n\n    DecimalFormat df(\"0\", { \"en\", status }, status);\n    if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) { return; }\n    Formattable parseResult;\n    df.parse(u\"NaN\", parseResult, status);\n    assertEquals(\"NaN should parse successfully\", NAN, parseResult.getDouble());\n    assertFalse(\"Result NaN should be positive\", std::signbit(parseResult.getDouble()));\n    UnicodeString formatResult;\n    df.format(parseResult.getDouble(), formatResult);\n    assertEquals(\"NaN should round-trip\", u\"NaN\", formatResult);\n}\n\nvoid NumberFormatTest::Test11897_LocalizedPatternSeparator() {\n    IcuTestErrorCode status(*this, \"Test11897_LocalizedPatternSeparator\");\n\n    // In a locale with a different <list> symbol, like arabic,\n    // kPatternSeparatorSymbol should still be ';'\n    {\n        DecimalFormatSymbols dfs(\"ar\", status);\n        assertEquals(\"pattern separator symbol should be ;\",\n                u\";\",\n                dfs.getSymbol(DecimalFormatSymbols::kPatternSeparatorSymbol));\n    }\n\n    // However, the custom symbol should be used in localized notation\n    // when set manually via API\n    {\n        DecimalFormatSymbols dfs(\"en\", status);\n        dfs.setSymbol(DecimalFormatSymbols::kPatternSeparatorSymbol, u\"!\", FALSE);\n        DecimalFormat df(u\"0\", dfs, status);\n        if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) { return; }\n        df.applyPattern(\"a0;b0\", status); // should not throw\n        UnicodeString result;\n        assertEquals(\"should apply the normal pattern\",\n                df.getNegativePrefix(result.remove()),\n                \"b\");\n        df.applyLocalizedPattern(u\"c0!d0\", status); // should not throw\n        assertEquals(\"should apply the localized pattern\",\n                df.getNegativePrefix(result.remove()),\n                \"d\");\n    }\n}\n\nvoid NumberFormatTest::Test13055_PercentageRounding() {\n  IcuTestErrorCode status(*this, \"PercentageRounding\");\n  UnicodeString actual;\n  LocalPointer<NumberFormat>pFormat(NumberFormat::createPercentInstance(\"en_US\", status));\n  if (U_FAILURE(status)) {\n      dataerrln(\"Failure creating DecimalFormat %s\", u_errorName(status));\n      return;\n  }\n  pFormat->setMaximumFractionDigits(0);\n  pFormat->setRoundingMode(DecimalFormat::kRoundHalfEven);\n  pFormat->format(2.155, actual);\n  assertEquals(\"Should round percent toward even number\", \"216%\", actual);\n}\n  \nvoid NumberFormatTest::Test11839() {\n    IcuTestErrorCode errorCode(*this, \"Test11839\");\n    // Ticket #11839: DecimalFormat does not respect custom plus sign\n    LocalPointer<DecimalFormatSymbols> dfs(new DecimalFormatSymbols(Locale::getEnglish(), errorCode), errorCode);\n    if (!assertSuccess(\"\", errorCode, true, __FILE__, __LINE__)) { return; }\n    dfs->setSymbol(DecimalFormatSymbols::kMinusSignSymbol, u\"a\u2238\");\n    dfs->setSymbol(DecimalFormatSymbols::kPlusSignSymbol, u\"b\u2214\"); //  \u2214  U+2214 DOT PLUS\n    DecimalFormat df(u\"0.00+;0.00-\", dfs.orphan(), errorCode);\n    UnicodeString result;\n    df.format(-1.234, result, errorCode);\n    assertEquals(\"Locale-specific minus sign should be used\", u\"1.23a\u2238\", result);\n    df.format(1.234, result.remove(), errorCode);\n    assertEquals(\"Locale-specific plus sign should be used\", u\"1.23b\u2214\", result);\n    // Test round-trip with parse\n    expect2(df, -456, u\"456.00a\u2238\");\n    expect2(df, 456, u\"456.00b\u2214\");\n}\n\nvoid NumberFormatTest::Test10354() {\n    IcuTestErrorCode errorCode(*this, \"Test10354\");\n    // Ticket #10354: invalid FieldPositionIterator when formatting with empty NaN\n    DecimalFormatSymbols dfs(errorCode);\n    UnicodeString empty;\n    dfs.setSymbol(DecimalFormatSymbols::kNaNSymbol, empty);\n    DecimalFormat df(errorCode);\n    df.setDecimalFormatSymbols(dfs);\n    UnicodeString result;\n    FieldPositionIterator positions;\n    df.format(NAN, result, &positions, errorCode);\n    errorCode.errIfFailureAndReset(\"DecimalFormat.format(NAN, FieldPositionIterator) failed\");\n    FieldPosition fp;\n    while (positions.next(fp)) {\n        // Should not loop forever\n    }\n}\n\nvoid NumberFormatTest::Test11645_ApplyPatternEquality() {\n    IcuTestErrorCode status(*this, \"Test11645_ApplyPatternEquality\");\n    const char16_t* pattern = u\"#,##0.0#\";\n    LocalPointer<DecimalFormat> fmt((DecimalFormat*) NumberFormat::createInstance(status), status);\n    if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) { return; }\n    fmt->applyPattern(pattern, status);\n    LocalPointer<DecimalFormat> fmtCopy;\n\n    static const int32_t newMultiplier = 37;\n    fmtCopy.adoptInstead(new DecimalFormat(*fmt));\n    assertFalse(\"Value before setter\", fmtCopy->getMultiplier() == newMultiplier);\n    fmtCopy->setMultiplier(newMultiplier);\n    assertEquals(\"Value after setter\", fmtCopy->getMultiplier(), newMultiplier);\n    fmtCopy->applyPattern(pattern, status);\n    assertEquals(\"Value after applyPattern\", fmtCopy->getMultiplier(), newMultiplier);\n    assertFalse(\"multiplier\", *fmt == *fmtCopy);\n\n    static const NumberFormat::ERoundingMode newRoundingMode = NumberFormat::ERoundingMode::kRoundCeiling;\n    fmtCopy.adoptInstead(new DecimalFormat(*fmt));\n    assertFalse(\"Value before setter\", fmtCopy->getRoundingMode() == newRoundingMode);\n    fmtCopy->setRoundingMode(newRoundingMode);\n    assertEquals(\"Value after setter\", fmtCopy->getRoundingMode(), newRoundingMode);\n    fmtCopy->applyPattern(pattern, status);\n    assertEquals(\"Value after applyPattern\", fmtCopy->getRoundingMode(), newRoundingMode);\n    assertFalse(\"roundingMode\", *fmt == *fmtCopy);\n\n    static const char16_t *const newCurrency = u\"EAT\";\n    fmtCopy.adoptInstead(new DecimalFormat(*fmt));\n    assertFalse(\"Value before setter\", fmtCopy->getCurrency() == newCurrency);\n    fmtCopy->setCurrency(newCurrency);\n    assertEquals(\"Value after setter\", fmtCopy->getCurrency(), newCurrency);\n    fmtCopy->applyPattern(pattern, status);\n    assertEquals(\"Value after applyPattern\", fmtCopy->getCurrency(), newCurrency);\n    assertFalse(\"currency\", *fmt == *fmtCopy);\n\n    static const UCurrencyUsage newCurrencyUsage = UCurrencyUsage::UCURR_USAGE_CASH;\n    fmtCopy.adoptInstead(new DecimalFormat(*fmt));\n    assertFalse(\"Value before setter\", fmtCopy->getCurrencyUsage() == newCurrencyUsage);\n    fmtCopy->setCurrencyUsage(newCurrencyUsage, status);\n    assertEquals(\"Value after setter\", fmtCopy->getCurrencyUsage(), newCurrencyUsage);\n    fmtCopy->applyPattern(pattern, status);\n    assertEquals(\"Value after applyPattern\", fmtCopy->getCurrencyUsage(), newCurrencyUsage);\n    assertFalse(\"currencyUsage\", *fmt == *fmtCopy);\n}\n\nvoid NumberFormatTest::Test12567() {\n    IcuTestErrorCode errorCode(*this, \"Test12567\");\n    // Ticket #12567: DecimalFormat.equals() may not be symmetric\n    LocalPointer<DecimalFormat> df1((DecimalFormat *)\n        NumberFormat::createInstance(Locale::getUS(), UNUM_CURRENCY, errorCode));\n    LocalPointer<DecimalFormat> df2((DecimalFormat *)\n        NumberFormat::createInstance(Locale::getUS(), UNUM_DECIMAL, errorCode));\n    if (!assertSuccess(\"\", errorCode, true, __FILE__, __LINE__)) { return; }\n    // NOTE: CurrencyPluralInfo equality not tested in C++ because its operator== is not defined.\n    df1->applyPattern(u\"0.00\", errorCode);\n    df2->applyPattern(u\"0.00\", errorCode);\n    assertTrue(\"df1 == df2\", *df1 == *df2);\n    assertTrue(\"df2 == df1\", *df2 == *df1);\n    df2->setPositivePrefix(u\"abc\");\n    assertTrue(\"df1 != df2\", *df1 != *df2);\n    assertTrue(\"df2 != df1\", *df2 != *df1);\n}\n\nvoid NumberFormatTest::Test11626_CustomizeCurrencyPluralInfo() {\n    IcuTestErrorCode errorCode(*this, \"Test11626_CustomizeCurrencyPluralInfo\");\n    // Ticket #11626: No unit test demonstrating how to use CurrencyPluralInfo to\n    // change formatting spelled out currencies\n    // Use locale sr because it has interesting plural rules.\n    Locale locale(\"sr\");\n    LocalPointer<DecimalFormatSymbols> symbols(new DecimalFormatSymbols(locale, errorCode), errorCode);\n    CurrencyPluralInfo info(locale, errorCode);\n    if (!assertSuccess(\"\", errorCode, true, __FILE__, __LINE__)) { return; }\n    info.setCurrencyPluralPattern(u\"one\", u\"0 qwerty\", errorCode);\n    info.setCurrencyPluralPattern(u\"few\", u\"0 dvorak\", errorCode);\n    DecimalFormat df(u\"#\", symbols.orphan(), UNUM_CURRENCY_PLURAL, errorCode);\n    df.setCurrencyPluralInfo(info);\n    df.setCurrency(u\"USD\");\n    df.setMaximumFractionDigits(0);\n\n    UnicodeString result;\n    assertEquals(\"Plural one\", u\"1 qwerty\", df.format(1, result, errorCode));\n    assertEquals(\"Plural few\", u\"3 dvorak\", df.format(3, result.remove(), errorCode));\n    assertEquals(\"Plural other\", u\"99 \u0430\u043c\u0435\u0440\u0438\u0447\u043a\u0438\u0445 \u0434\u043e\u043b\u0430\u0440\u0430\", df.format(99, result.remove(), errorCode));\n\n    info.setPluralRules(u\"few: n is 1; one: n in 2..4\", errorCode);\n    df.setCurrencyPluralInfo(info);\n    assertEquals(\"Plural one\", u\"1 dvorak\", df.format(1, result.remove(), errorCode));\n    assertEquals(\"Plural few\", u\"3 qwerty\", df.format(3, result.remove(), errorCode));\n    assertEquals(\"Plural other\", u\"99 \u0430\u043c\u0435\u0440\u0438\u0447\u043a\u0438\u0445 \u0434\u043e\u043b\u0430\u0440\u0430\", df.format(99, result.remove(), errorCode));\n}\n\nvoid NumberFormatTest::Test20073_StrictPercentParseErrorIndex() {\n    IcuTestErrorCode status(*this, \"Test20073_StrictPercentParseErrorIndex\");\n    ParsePosition parsePosition(0);\n    DecimalFormat df(u\"0%\", {\"en-us\", status}, status);\n    if (U_FAILURE(status)) {\n        dataerrln(\"Unable to create DecimalFormat instance.\");\n        return;\n    }\n    df.setLenient(FALSE);\n    Formattable result;\n    df.parse(u\"%2%\", result, parsePosition);\n    assertEquals(\"\", 0, parsePosition.getIndex());\n    assertEquals(\"\", 0, parsePosition.getErrorIndex());\n}\n\nvoid NumberFormatTest::Test13056_GroupingSize() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat df(u\"#,##0\", status);\n    if (!assertSuccess(\"\", status)) return;\n    assertEquals(\"Primary grouping should return 3\", 3, df.getGroupingSize());\n    assertEquals(\"Secondary grouping should return 0\", 0, df.getSecondaryGroupingSize());\n    df.setSecondaryGroupingSize(3);\n    assertEquals(\"Primary grouping should still return 3\", 3, df.getGroupingSize());\n    assertEquals(\"Secondary grouping should round-trip\", 3, df.getSecondaryGroupingSize());\n    df.setGroupingSize(4);\n    assertEquals(\"Primary grouping should return 4\", 4, df.getGroupingSize());\n    assertEquals(\"Secondary should remember explicit setting and return 3\", 3, df.getSecondaryGroupingSize());\n}\n\n\nvoid NumberFormatTest::Test11025_CurrencyPadding() {\n    UErrorCode status = U_ZERO_ERROR;\n    UnicodeString pattern(u\"\u00a4\u00a4 **####0.00\");\n    DecimalFormatSymbols sym(Locale::getFrance(), status);\n    if (!assertSuccess(\"\", status)) return;\n    DecimalFormat fmt(pattern, sym, status);\n    if (!assertSuccess(\"\", status)) return;\n    UnicodeString result;\n    fmt.format(433.0, result);\n    assertEquals(\"Number should be padded to 11 characters\", \"EUR *433,00\", result);\n}\n\nvoid NumberFormatTest::Test11648_ExpDecFormatMalPattern() {\n    UErrorCode status = U_ZERO_ERROR;\n\n    DecimalFormat fmt(\"0.00\", {\"en\", status}, status);\n    if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) { return; }\n    fmt.setScientificNotation(TRUE);\n    UnicodeString pattern;\n\n    assertEquals(\"A valid scientific notation pattern should be produced\",\n            \"0.00E0\",\n            fmt.toPattern(pattern));\n\n    DecimalFormat fmt2(pattern, status);\n    assertSuccess(\"\", status);\n}\n\nvoid NumberFormatTest::Test11649_DecFmtCurrencies() {\n    IcuTestErrorCode status(*this, \"Test11649_DecFmtCurrencies\");\n    UnicodeString pattern(\"\\\\u00a4\\\\u00a4\\\\u00a4 0.00\");\n    pattern = pattern.unescape();\n    DecimalFormat fmt(pattern, status);\n    if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) { return; }\n    static const UChar USD[] = u\"USD\";\n    fmt.setCurrency(USD);\n    UnicodeString appendTo;\n\n    assertEquals(\"\", \"US dollars 12.34\", fmt.format(12.34, appendTo));\n    UnicodeString topattern;\n\n    assertEquals(\"\", pattern, fmt.toPattern(topattern));\n    DecimalFormat fmt2(topattern, status);\n    fmt2.setCurrency(USD);\n\n    appendTo.remove();\n    assertEquals(\"\", \"US dollars 12.34\", fmt2.format(12.34, appendTo));\n}\n\nvoid NumberFormatTest::Test13148_ParseGroupingSeparators() {\n  IcuTestErrorCode status(*this, \"Test13148\");\n  LocalPointer<DecimalFormat> fmt(\n      (DecimalFormat*)NumberFormat::createInstance(\"en-ZA\", status), status);\n  if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) { return; }\n\n  DecimalFormatSymbols symbols = *fmt->getDecimalFormatSymbols();\n\n  symbols.setSymbol(DecimalFormatSymbols::kDecimalSeparatorSymbol, u'.');\n  symbols.setSymbol(DecimalFormatSymbols::kGroupingSeparatorSymbol, u',');\n  fmt->setDecimalFormatSymbols(symbols);\n  Formattable number;\n  fmt->parse(u\"300,000\", number, status);\n  assertEquals(\"Should parse as 300000\", 300000LL, number.getInt64(status));\n}\n\nvoid NumberFormatTest::Test12753_PatternDecimalPoint() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols symbols(Locale::getUS(), status);\n    symbols.setSymbol(DecimalFormatSymbols::kDecimalSeparatorSymbol, u\"*\", false);\n    DecimalFormat df(u\"0.00\", symbols, status);\n    if (!assertSuccess(\"\", status)) return;\n    df.setDecimalPatternMatchRequired(true);\n    Formattable result;\n    df.parse(u\"123\",result, status);\n    assertEquals(\"Parsing integer succeeded even though setDecimalPatternMatchRequired was set\",\n                 U_INVALID_FORMAT_ERROR, status);\n    }\n\n void NumberFormatTest::Test11647_PatternCurrencySymbols() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat df(status);\n    df.applyPattern(u\"\u00a4\u00a4\u00a4\u00a4#\", status);\n    if (!assertSuccess(\"\", status)) return;\n    UnicodeString actual;\n    df.format(123, actual);\n    assertEquals(\"Should replace 4 currency signs with U+FFFD\", u\"\\uFFFD123\", actual);\n}\n\nvoid NumberFormatTest::Test11913_BigDecimal() {\n    UErrorCode status = U_ZERO_ERROR;\n    LocalPointer<NumberFormat> df(NumberFormat::createInstance(Locale::getEnglish(), status), status);\n    if (!assertSuccess(\"\", status)) return;\n    UnicodeString result;\n    df->format(StringPiece(\"1.23456789E400\"), result, nullptr, status);\n    assertSuccess(\"\", status);\n    assertEquals(\"Should format more than 309 digits\", u\"12,345,678\", UnicodeString(result, 0, 10));\n    assertEquals(\"Should format more than 309 digits\", 534, result.length());\n}\n\nvoid NumberFormatTest::Test11020_RoundingInScientificNotation() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols sym(Locale::getFrance(), status);\n    DecimalFormat fmt(u\"0.05E0\", sym, status);\n    if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) { return; }\n    assertSuccess(\"\", status);\n    UnicodeString result;\n    fmt.format(12301.2, result);\n    assertEquals(\"Rounding increment should be applied after magnitude scaling\", u\"1,25E4\", result);\n}\n\nvoid NumberFormatTest::Test11640_TripleCurrencySymbol() {\n    IcuTestErrorCode status(*this, \"Test11640_TripleCurrencySymbol\");\n    UnicodeString actual;\n    DecimalFormat dFormat(u\"\u00a4\u00a4\u00a4 0\", status);\n    if (U_FAILURE(status)) {\n        dataerrln(\"Failure creating DecimalFormat %s\", u_errorName(status));\n        return;\n    }\n    dFormat.setCurrency(u\"USD\");\n    UnicodeString result;\n    dFormat.getPositivePrefix(result);\n    assertEquals(\"Triple-currency should give long name on getPositivePrefix\",\n                \"US dollars \", result);\n}\n\n\nvoid NumberFormatTest::Test13763_FieldPositionIteratorOffset() {\n    IcuTestErrorCode status(*this, \"Test13763_FieldPositionIteratorOffset\");\n    FieldPositionIterator fpi;\n    UnicodeString result(u\"foo\\U0001F4FBbar\"); // 8 code units\n    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(\"en\", status), status);\n    if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) { return; }\n    nf->format(5142.3, result, &fpi, status);\n\n    int32_t expected[] = {\n      UNUM_GROUPING_SEPARATOR_FIELD, 9, 10,\n      UNUM_INTEGER_FIELD, 8, 13,\n      UNUM_DECIMAL_SEPARATOR_FIELD, 13, 14,\n      UNUM_FRACTION_FIELD, 14, 15,\n    };\n    int32_t tupleCount = UPRV_LENGTHOF(expected)/3;\n    expectPositions(fpi, expected, tupleCount, result);\n}\n\nvoid NumberFormatTest::Test13777_ParseLongNameNonCurrencyMode() {\n    IcuTestErrorCode status(*this, \"Test13777_ParseLongNameNonCurrencyMode\");\n\n    LocalPointer<NumberFormat> df(\n        NumberFormat::createInstance(\"en-us\", UNumberFormatStyle::UNUM_CURRENCY_PLURAL, status), status);\n    if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) { return; }\n    expect2(*df, 1.5, u\"1.50 US dollars\");\n}\n\nvoid NumberFormatTest::Test13804_EmptyStringsWhenParsing() {\n    IcuTestErrorCode status(*this, \"Test13804_EmptyStringsWhenParsing\");\n\n    DecimalFormatSymbols dfs(\"en\", status);\n    if (status.errIfFailureAndReset()) {\n        return;\n    }\n    dfs.setSymbol(DecimalFormatSymbols::kCurrencySymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kDecimalSeparatorSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kZeroDigitSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kOneDigitSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kTwoDigitSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kThreeDigitSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kFourDigitSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kFiveDigitSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kSixDigitSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kSevenDigitSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kEightDigitSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kNineDigitSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kExponentMultiplicationSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kExponentialSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kGroupingSeparatorSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kInfinitySymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kIntlCurrencySymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kMinusSignSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kMonetarySeparatorSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kMonetaryGroupingSeparatorSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kNaNSymbol, u\"\", FALSE);\n    dfs.setPatternForCurrencySpacing(UNUM_CURRENCY_INSERT, FALSE, u\"\");\n    dfs.setPatternForCurrencySpacing(UNUM_CURRENCY_INSERT, TRUE, u\"\");\n    dfs.setSymbol(DecimalFormatSymbols::kPercentSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kPerMillSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kPlusSignSymbol, u\"\", FALSE);\n\n    DecimalFormat df(\"0\", dfs, status);\n    if (status.errIfFailureAndReset()) {\n        return;\n    }\n    df.setGroupingUsed(TRUE);\n    df.setScientificNotation(TRUE);\n    df.setLenient(TRUE); // enable all matchers\n    {\n        UnicodeString result;\n        df.format(0, result); // should not crash or hit infinite loop\n    }\n    const char16_t* samples[] = {\n            u\"\",\n            u\"123\",\n            u\"$123\",\n            u\"-\",\n            u\"+\",\n            u\"44%\",\n            u\"1E+2.3\"\n    };\n    for (auto& sample : samples) {\n        logln(UnicodeString(u\"Attempting parse on: \") + sample);\n        status.setScope(sample);\n        // We don't care about the results, only that we don't crash and don't loop.\n        Formattable result;\n        ParsePosition ppos(0);\n        df.parse(sample, result, ppos);\n        ppos = ParsePosition(0);\n        LocalPointer<CurrencyAmount> curramt(df.parseCurrency(sample, ppos));\n        status.errIfFailureAndReset();\n    }\n\n    // Test with a nonempty exponent separator symbol to cover more code\n    dfs.setSymbol(DecimalFormatSymbols::kExponentialSymbol, u\"E\", FALSE);\n    df.setDecimalFormatSymbols(dfs);\n    {\n        Formattable result;\n        ParsePosition ppos(0);\n        df.parse(u\"1E+2.3\", result, ppos);\n    }\n}\n\nvoid NumberFormatTest::Test20037_ScientificIntegerOverflow() {\n    IcuTestErrorCode status(*this, \"Test20037_ScientificIntegerOverflow\");\n\n    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));\n    if (U_FAILURE(status)) {\n        dataerrln(\"Unable to create NumberFormat instance.\");\n        return;\n    }\n    Formattable result;\n\n    // Test overflow of exponent\n    nf->parse(u\"1E-2147483648\", result, status);\n    StringPiece sp = result.getDecimalNumber(status);\n    assertEquals(u\"Should snap to zero\",\n                 u\"0\",\n                 {sp.data(), sp.length(), US_INV});\n\n    // Test edge case overflow of exponent\n    result = Formattable();\n    nf->parse(u\"1E-2147483647E-1\", result, status);\n    sp = result.getDecimalNumber(status);\n    assertEquals(u\"Should not overflow and should parse only the first exponent\",\n                 u\"1E-2147483647\",\n                 {sp.data(), sp.length(), US_INV});\n}\n\nvoid NumberFormatTest::Test13840_ParseLongStringCrash() {\n    IcuTestErrorCode status(*this, \"Test13840_ParseLongStringCrash\");\n\n    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(\"en\", status), status);\n    if (status.errIfFailureAndReset()) { return; }\n\n    Formattable result;\n    static const char16_t* bigString =\n        u\"111111111111111111111111111111111111111111111111111111111111111111111\"\n        u\"111111111111111111111111111111111111111111111111111111111111111111111\"\n        u\"111111111111111111111111111111111111111111111111111111111111111111111\"\n        u\"111111111111111111111111111111111111111111111111111111111111111111111\"\n        u\"111111111111111111111111111111111111111111111111111111111111111111111\"\n        u\"111111111111111111111111111111111111111111111111111111111111111111111\";\n    nf->parse(bigString, result, status);\n\n    // Normalize the input string:\n    CharString expectedChars;\n    expectedChars.appendInvariantChars(bigString, status);\n    DecimalQuantity expectedDQ;\n    expectedDQ.setToDecNumber(expectedChars.toStringPiece(), status);\n    UnicodeString expectedUString = expectedDQ.toScientificString();\n\n    // Get the output string:\n    StringPiece actualChars = result.getDecimalNumber(status);\n    UnicodeString actualUString = UnicodeString(actualChars.data(), actualChars.length(), US_INV);\n\n    assertEquals(\"Should round-trip without crashing\", expectedUString, actualUString);\n}\n\nvoid NumberFormatTest::Test13850_EmptyStringCurrency() {\n    IcuTestErrorCode status(*this, \"Test13840_EmptyStringCurrency\");\n\n    struct TestCase {\n        const char16_t* currencyArg;\n        UErrorCode expectedError;\n    } cases[] = {\n        {u\"\", U_ZERO_ERROR},\n        {u\"U\", U_ILLEGAL_ARGUMENT_ERROR},\n        {u\"Us\", U_ILLEGAL_ARGUMENT_ERROR},\n        {nullptr, U_ZERO_ERROR},\n        {u\"U$D\", U_INVARIANT_CONVERSION_ERROR},\n        {u\"Xxx\", U_ZERO_ERROR}\n    };\n    for (const auto& cas : cases) {\n        UnicodeString message(u\"with currency arg: \");\n        if (cas.currencyArg == nullptr) {\n            message += u\"nullptr\";\n        } else {\n            message += UnicodeString(cas.currencyArg);\n        }\n        status.setScope(message);\n        LocalPointer<NumberFormat> nf(NumberFormat::createCurrencyInstance(\"en-US\", status), status);\n        if (status.errIfFailureAndReset()) { return; }\n        UnicodeString actual;\n        nf->format(1, actual, status);\n        status.errIfFailureAndReset();\n        assertEquals(u\"Should format with US currency \" + message, u\"$1.00\", actual);\n        nf->setCurrency(cas.currencyArg, status);\n        if (status.expectErrorAndReset(cas.expectedError)) {\n            // If an error occurred, do not check formatting.\n            continue;\n        }\n        nf->format(1, actual.remove(), status);\n        assertEquals(u\"Should unset the currency \" + message, u\"\\u00A41.00\", actual);\n        status.errIfFailureAndReset();\n    }\n}\n\n#endif /* #if !UCONFIG_NO_FORMATTING */\n", "// \u00a9 2017 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html#License\npackage com.ibm.icu.impl.number;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.math.MathContext;\nimport java.text.FieldPosition;\n\nimport com.ibm.icu.impl.StandardPlural;\nimport com.ibm.icu.impl.Utility;\nimport com.ibm.icu.text.PluralRules;\nimport com.ibm.icu.text.PluralRules.Operand;\nimport com.ibm.icu.text.UFieldPosition;\n\n/**\n * Represents numbers and digit display properties using Binary Coded Decimal (BCD).\n *\n * @implements {@link DecimalQuantity}\n */\npublic abstract class DecimalQuantity_AbstractBCD implements DecimalQuantity {\n\n    /**\n     * The power of ten corresponding to the least significant digit in the BCD. For example, if this\n     * object represents the number \"3.14\", the BCD will be \"0x314\" and the scale will be -2.\n     *\n     * <p>\n     * Note that in {@link java.math.BigDecimal}, the scale is defined differently: the number of digits\n     * after the decimal place, which is the negative of our definition of scale.\n     */\n    protected int scale;\n\n    /**\n     * The number of digits in the BCD. For example, \"1007\" has BCD \"0x1007\" and precision 4. A long\n     * cannot represent precisions greater than 16.\n     *\n     * <p>\n     * This value must be re-calculated whenever the value in bcd changes by using\n     * {@link #computePrecisionAndCompact()}.\n     */\n    protected int precision;\n\n    /**\n     * A bitmask of properties relating to the number represented by this object.\n     *\n     * @see #NEGATIVE_FLAG\n     * @see #INFINITY_FLAG\n     * @see #NAN_FLAG\n     */\n    protected byte flags;\n\n    protected static final int NEGATIVE_FLAG = 1;\n    protected static final int INFINITY_FLAG = 2;\n    protected static final int NAN_FLAG = 4;\n\n    // The following three fields relate to the double-to-ascii fast path algorithm.\n    // When a double is given to DecimalQuantityBCD, it is converted to using a fast algorithm. The\n    // fast algorithm guarantees correctness to only the first ~12 digits of the double. The process\n    // of rounding the number ensures that the converted digits are correct, falling back to a slow-\n    // path algorithm if required. Therefore, if a DecimalQuantity is constructed from a double, it\n    // is *required* that roundToMagnitude(), roundToIncrement(), or roundToInfinity() is called. If\n    // you don't round, assertions will fail in certain other methods if you try calling them.\n\n    /**\n     * The original number provided by the user and which is represented in BCD. Used when we need to\n     * re-compute the BCD for an exact double representation.\n     */\n    protected double origDouble;\n\n    /**\n     * The change in magnitude relative to the original double. Used when we need to re-compute the BCD\n     * for an exact double representation.\n     */\n    protected int origDelta;\n\n    /**\n     * Whether the value in the BCD comes from the double fast path without having been rounded to ensure\n     * correctness\n     */\n    protected boolean isApproximate;\n\n    // Four positions: left optional '(', left required '[', right required ']', right optional ')'.\n    // These four positions determine which digits are displayed in the output string. They do NOT\n    // affect rounding. These positions are internal-only and can be specified only by the public\n    // endpoints like setFractionLength, setIntegerLength, and setSignificantDigits, among others.\n    //\n    // * Digits between lReqPos and rReqPos are in the \"required zone\" and are always displayed.\n    // * Digits between lOptPos and rOptPos but outside the required zone are in the \"optional zone\"\n    // and are displayed unless they are trailing off the left or right edge of the number and\n    // have a numerical value of zero. In order to be \"trailing\", the digits need to be beyond\n    // the decimal point in their respective directions.\n    // * Digits outside of the \"optional zone\" are never displayed.\n    //\n    // See the table below for illustrative examples.\n    //\n    // +---------+---------+---------+---------+------------+------------------------+--------------+\n    // | lOptPos | lReqPos | rReqPos | rOptPos |   number   |        positions       | en-US string |\n    // +---------+---------+---------+---------+------------+------------------------+--------------+\n    // |    5    |    2    |   -1    |   -5    |   1234.567 |     ( 12[34.5]67  )    |   1,234.567  |\n    // |    3    |    2    |   -1    |   -5    |   1234.567 |      1(2[34.5]67  )    |     234.567  |\n    // |    3    |    2    |   -1    |   -2    |   1234.567 |      1(2[34.5]6)7      |     234.56   |\n    // |    6    |    4    |    2    |   -5    | 123456789. |  123(45[67]89.     )   | 456,789.     |\n    // |    6    |    4    |    2    |    1    | 123456789. |     123(45[67]8)9.     | 456,780.     |\n    // |   -1    |   -1    |   -3    |   -4    | 0.123456   |     0.1([23]4)56       |        .0234 |\n    // |    6    |    4    |   -2    |   -2    |     12.3   |     (  [  12.3 ])      |    0012.30   |\n    // +---------+---------+---------+---------+------------+------------------------+--------------+\n    //\n    protected int lOptPos = Integer.MAX_VALUE;\n    protected int lReqPos = 0;\n    protected int rReqPos = 0;\n    protected int rOptPos = Integer.MIN_VALUE;\n\n    @Override\n    public void copyFrom(DecimalQuantity _other) {\n        copyBcdFrom(_other);\n        DecimalQuantity_AbstractBCD other = (DecimalQuantity_AbstractBCD) _other;\n        lOptPos = other.lOptPos;\n        lReqPos = other.lReqPos;\n        rReqPos = other.rReqPos;\n        rOptPos = other.rOptPos;\n        scale = other.scale;\n        precision = other.precision;\n        flags = other.flags;\n        origDouble = other.origDouble;\n        origDelta = other.origDelta;\n        isApproximate = other.isApproximate;\n    }\n\n    public DecimalQuantity_AbstractBCD clear() {\n        lOptPos = Integer.MAX_VALUE;\n        lReqPos = 0;\n        rReqPos = 0;\n        rOptPos = Integer.MIN_VALUE;\n        flags = 0;\n        setBcdToZero(); // sets scale, precision, hasDouble, origDouble, origDelta, and BCD data\n        return this;\n    }\n\n    @Override\n    public void setIntegerLength(int minInt, int maxInt) {\n        // Validation should happen outside of DecimalQuantity, e.g., in the Rounder class.\n        assert minInt >= 0;\n        assert maxInt >= minInt;\n\n        // Special behavior: do not set minInt to be less than what is already set.\n        // This is so significant digits rounding can set the integer length.\n        if (minInt < lReqPos) {\n            minInt = lReqPos;\n        }\n\n        // Save values into internal state\n        // Negation is safe for minFrac/maxFrac because -Integer.MAX_VALUE > Integer.MIN_VALUE\n        lOptPos = maxInt;\n        lReqPos = minInt;\n    }\n\n    @Override\n    public void setFractionLength(int minFrac, int maxFrac) {\n        // Validation should happen outside of DecimalQuantity, e.g., in the Rounder class.\n        assert minFrac >= 0;\n        assert maxFrac >= minFrac;\n\n        // Save values into internal state\n        // Negation is safe for minFrac/maxFrac because -Integer.MAX_VALUE > Integer.MIN_VALUE\n        rReqPos = -minFrac;\n        rOptPos = -maxFrac;\n    }\n\n    @Override\n    public long getPositionFingerprint() {\n        long fingerprint = 0;\n        fingerprint ^= lOptPos;\n        fingerprint ^= (lReqPos << 16);\n        fingerprint ^= ((long) rReqPos << 32);\n        fingerprint ^= ((long) rOptPos << 48);\n        return fingerprint;\n    }\n\n    @Override\n    public void roundToIncrement(BigDecimal roundingIncrement, MathContext mathContext) {\n        // TODO(13701): Avoid this check on every call to roundToIncrement().\n        BigDecimal stripped = roundingIncrement.stripTrailingZeros();\n        if (stripped.unscaledValue().compareTo(BigInteger.valueOf(5)) == 0) {\n            roundToNickel(-stripped.scale(), mathContext);\n            return;\n        }\n        BigDecimal temp = toBigDecimal();\n        temp = temp.divide(roundingIncrement, 0, mathContext.getRoundingMode())\n                .multiply(roundingIncrement).round(mathContext);\n        if (temp.signum() == 0) {\n            setBcdToZero(); // keeps negative flag for -0.0\n        } else {\n            setToBigDecimal(temp);\n        }\n    }\n\n    @Override\n    public void multiplyBy(BigDecimal multiplicand) {\n        if (isInfinite() || isZero() || isNaN()) {\n            return;\n        }\n        BigDecimal temp = toBigDecimal();\n        temp = temp.multiply(multiplicand);\n        setToBigDecimal(temp);\n    }\n\n    @Override\n    public void negate() {\n      flags ^= NEGATIVE_FLAG;\n    }\n\n    @Override\n    public int getMagnitude() throws ArithmeticException {\n        if (precision == 0) {\n            throw new ArithmeticException(\"Magnitude is not well-defined for zero\");\n        } else {\n            return scale + precision - 1;\n        }\n    }\n\n    @Override\n    public void adjustMagnitude(int delta) {\n        if (precision != 0) {\n            scale = Utility.addExact(scale, delta);\n            origDelta = Utility.addExact(origDelta, delta);\n        }\n    }\n\n    @Override\n    public StandardPlural getStandardPlural(PluralRules rules) {\n        if (rules == null) {\n            // Fail gracefully if the user didn't provide a PluralRules\n            return StandardPlural.OTHER;\n        } else {\n            @SuppressWarnings(\"deprecation\")\n            String ruleString = rules.select(this);\n            return StandardPlural.orOtherFromString(ruleString);\n        }\n    }\n\n    @Override\n    public double getPluralOperand(Operand operand) {\n        // If this assertion fails, you need to call roundToInfinity() or some other rounding method.\n        // See the comment at the top of this file explaining the \"isApproximate\" field.\n        assert !isApproximate;\n\n        switch (operand) {\n        case i:\n            // Invert the negative sign if necessary\n            return isNegative() ? -toLong(true) : toLong(true);\n        case f:\n            return toFractionLong(true);\n        case t:\n            return toFractionLong(false);\n        case v:\n            return fractionCount();\n        case w:\n            return fractionCountWithoutTrailingZeros();\n        default:\n            return Math.abs(toDouble());\n        }\n    }\n\n    @Override\n    public void populateUFieldPosition(FieldPosition fp) {\n        if (fp instanceof UFieldPosition) {\n            ((UFieldPosition) fp).setFractionDigits((int) getPluralOperand(Operand.v),\n                    (long) getPluralOperand(Operand.f));\n        }\n    }\n\n    @Override\n    public int getUpperDisplayMagnitude() {\n        // If this assertion fails, you need to call roundToInfinity() or some other rounding method.\n        // See the comment at the top of this file explaining the \"isApproximate\" field.\n        assert !isApproximate;\n\n        int magnitude = scale + precision;\n        int result = (lReqPos > magnitude) ? lReqPos : (lOptPos < magnitude) ? lOptPos : magnitude;\n        return result - 1;\n    }\n\n    @Override\n    public int getLowerDisplayMagnitude() {\n        // If this assertion fails, you need to call roundToInfinity() or some other rounding method.\n        // See the comment at the top of this file explaining the \"isApproximate\" field.\n        assert !isApproximate;\n\n        int magnitude = scale;\n        int result = (rReqPos < magnitude) ? rReqPos : (rOptPos > magnitude) ? rOptPos : magnitude;\n        return result;\n    }\n\n    @Override\n    public byte getDigit(int magnitude) {\n        // If this assertion fails, you need to call roundToInfinity() or some other rounding method.\n        // See the comment at the top of this file explaining the \"isApproximate\" field.\n        assert !isApproximate;\n\n        return getDigitPos(magnitude - scale);\n    }\n\n    private int fractionCount() {\n        return -getLowerDisplayMagnitude();\n    }\n\n    private int fractionCountWithoutTrailingZeros() {\n        return Math.max(-scale, 0);\n    }\n\n    @Override\n    public boolean isNegative() {\n        return (flags & NEGATIVE_FLAG) != 0;\n    }\n\n    @Override\n    public int signum() {\n        return isNegative() ? -1 : isZero() ? 0 : 1;\n    }\n\n    @Override\n    public boolean isInfinite() {\n        return (flags & INFINITY_FLAG) != 0;\n    }\n\n    @Override\n    public boolean isNaN() {\n        return (flags & NAN_FLAG) != 0;\n    }\n\n    @Override\n    public boolean isZero() {\n        return precision == 0;\n    }\n\n    public void setToInt(int n) {\n        setBcdToZero();\n        flags = 0;\n        if (n < 0) {\n            flags |= NEGATIVE_FLAG;\n            n = -n;\n        }\n        if (n != 0) {\n            _setToInt(n);\n            compact();\n        }\n    }\n\n    private void _setToInt(int n) {\n        if (n == Integer.MIN_VALUE) {\n            readLongToBcd(-(long) n);\n        } else {\n            readIntToBcd(n);\n        }\n    }\n\n    public void setToLong(long n) {\n        setBcdToZero();\n        flags = 0;\n        if (n < 0) {\n            flags |= NEGATIVE_FLAG;\n            n = -n;\n        }\n        if (n != 0) {\n            _setToLong(n);\n            compact();\n        }\n    }\n\n    private void _setToLong(long n) {\n        if (n == Long.MIN_VALUE) {\n            readBigIntegerToBcd(BigInteger.valueOf(n).negate());\n        } else if (n <= Integer.MAX_VALUE) {\n            readIntToBcd((int) n);\n        } else {\n            readLongToBcd(n);\n        }\n    }\n\n    public void setToBigInteger(BigInteger n) {\n        setBcdToZero();\n        flags = 0;\n        if (n.signum() == -1) {\n            flags |= NEGATIVE_FLAG;\n            n = n.negate();\n        }\n        if (n.signum() != 0) {\n            _setToBigInteger(n);\n            compact();\n        }\n    }\n\n    private void _setToBigInteger(BigInteger n) {\n        if (n.bitLength() < 32) {\n            readIntToBcd(n.intValue());\n        } else if (n.bitLength() < 64) {\n            readLongToBcd(n.longValue());\n        } else {\n            readBigIntegerToBcd(n);\n        }\n    }\n\n    /**\n     * Sets the internal BCD state to represent the value in the given double.\n     *\n     * @param n\n     *            The value to consume.\n     */\n    public void setToDouble(double n) {\n        setBcdToZero();\n        flags = 0;\n        // Double.compare() handles +0.0 vs -0.0\n        if (Double.compare(n, 0.0) < 0) {\n            flags |= NEGATIVE_FLAG;\n            n = -n;\n        }\n        if (Double.isNaN(n)) {\n            flags |= NAN_FLAG;\n        } else if (Double.isInfinite(n)) {\n            flags |= INFINITY_FLAG;\n        } else if (n != 0) {\n            _setToDoubleFast(n);\n            compact();\n        }\n    }\n\n    private static final double[] DOUBLE_MULTIPLIERS = {\n            1e0,\n            1e1,\n            1e2,\n            1e3,\n            1e4,\n            1e5,\n            1e6,\n            1e7,\n            1e8,\n            1e9,\n            1e10,\n            1e11,\n            1e12,\n            1e13,\n            1e14,\n            1e15,\n            1e16,\n            1e17,\n            1e18,\n            1e19,\n            1e20,\n            1e21 };\n\n    /**\n     * Uses double multiplication and division to get the number into integer space before converting to\n     * digits. Since double arithmetic is inexact, the resulting digits may not be accurate.\n     */\n    private void _setToDoubleFast(double n) {\n        isApproximate = true;\n        origDouble = n;\n        origDelta = 0;\n\n        // NOTE: Unlike ICU4C, doubles are always IEEE 754 doubles.\n        long ieeeBits = Double.doubleToLongBits(n);\n        int exponent = (int) ((ieeeBits & 0x7ff0000000000000L) >> 52) - 0x3ff;\n\n        // Not all integers can be represented exactly for exponent > 52\n        if (exponent <= 52 && (long) n == n) {\n            _setToLong((long) n);\n            return;\n        }\n\n        // 3.3219... is log2(10)\n        int fracLength = (int) ((52 - exponent) / 3.32192809489);\n        if (fracLength >= 0) {\n            int i = fracLength;\n            // 1e22 is the largest exact double.\n            for (; i >= 22; i -= 22)\n                n *= 1e22;\n            n *= DOUBLE_MULTIPLIERS[i];\n        } else {\n            int i = fracLength;\n            // 1e22 is the largest exact double.\n            for (; i <= -22; i += 22)\n                n /= 1e22;\n            n /= DOUBLE_MULTIPLIERS[-i];\n        }\n        long result = Math.round(n);\n        if (result != 0) {\n            _setToLong(result);\n            scale -= fracLength;\n        }\n    }\n\n    /**\n     * Uses Double.toString() to obtain an exact accurate representation of the double, overwriting it\n     * into the BCD. This method can be called at any point after {@link #_setToDoubleFast} while\n     * {@link #isApproximate} is still true.\n     */\n    private void convertToAccurateDouble() {\n        double n = origDouble;\n        assert n != 0;\n        int delta = origDelta;\n        setBcdToZero();\n\n        // Call the slow oracle function (Double.toString in Java, sprintf in C++).\n        String dstr = Double.toString(n);\n\n        if (dstr.indexOf('E') != -1) {\n            // Case 1: Exponential notation.\n            assert dstr.indexOf('.') == 1;\n            int expPos = dstr.indexOf('E');\n            _setToLong(Long.parseLong(dstr.charAt(0) + dstr.substring(2, expPos)));\n            scale += Integer.parseInt(dstr.substring(expPos + 1)) - (expPos - 1) + 1;\n        } else if (dstr.charAt(0) == '0') {\n            // Case 2: Fraction-only number.\n            assert dstr.indexOf('.') == 1;\n            _setToLong(Long.parseLong(dstr.substring(2)));\n            scale += 2 - dstr.length();\n        } else if (dstr.charAt(dstr.length() - 1) == '0') {\n            // Case 3: Integer-only number.\n            // Note: this path should not normally happen, because integer-only numbers are captured\n            // before the approximate double logic is performed.\n            assert dstr.indexOf('.') == dstr.length() - 2;\n            assert dstr.length() - 2 <= 18;\n            _setToLong(Long.parseLong(dstr.substring(0, dstr.length() - 2)));\n            // no need to adjust scale\n        } else {\n            // Case 4: Number with both a fraction and an integer.\n            int decimalPos = dstr.indexOf('.');\n            _setToLong(Long.parseLong(dstr.substring(0, decimalPos) + dstr.substring(decimalPos + 1)));\n            scale += decimalPos - dstr.length() + 1;\n        }\n\n        scale += delta;\n        compact();\n        explicitExactDouble = true;\n    }\n\n    /**\n     * Whether this {@link DecimalQuantity_DualStorageBCD} has been explicitly converted to an exact\n     * double. true if backed by a double that was explicitly converted via convertToAccurateDouble;\n     * false otherwise. Used for testing.\n     *\n     * @internal\n     * @deprecated This API is ICU internal only.\n     */\n    @Deprecated\n    public boolean explicitExactDouble = false;\n\n    /**\n     * Sets the internal BCD state to represent the value in the given BigDecimal.\n     *\n     * @param n\n     *            The value to consume.\n     */\n    @Override\n    public void setToBigDecimal(BigDecimal n) {\n        setBcdToZero();\n        flags = 0;\n        if (n.signum() == -1) {\n            flags |= NEGATIVE_FLAG;\n            n = n.negate();\n        }\n        if (n.signum() != 0) {\n            _setToBigDecimal(n);\n            compact();\n        }\n    }\n\n    private void _setToBigDecimal(BigDecimal n) {\n        int fracLength = n.scale();\n        n = n.scaleByPowerOfTen(fracLength);\n        BigInteger bi = n.toBigInteger();\n        _setToBigInteger(bi);\n        scale -= fracLength;\n    }\n\n    /**\n     * Returns a long approximating the internal BCD. A long can only represent the integral part of the\n     * number.\n     *\n     * @param truncateIfOverflow if false and the number does NOT fit, fails with an assertion error.\n     * @return A 64-bit integer representation of the internal BCD.\n     */\n    public long toLong(boolean truncateIfOverflow) {\n        // NOTE: Call sites should be guarded by fitsInLong(), like this:\n        // if (dq.fitsInLong()) { /* use dq.toLong() */ } else { /* use some fallback */ }\n        // Fallback behavior upon truncateIfOverflow is to truncate at 17 digits.\n        assert(truncateIfOverflow || fitsInLong());\n        long result = 0L;\n        int upperMagnitude = Math.min(scale + precision, lOptPos) - 1;\n        if (truncateIfOverflow) {\n            upperMagnitude = Math.min(upperMagnitude, 17);\n        }\n        for (int magnitude = upperMagnitude; magnitude >= 0; magnitude--) {\n            result = result * 10 + getDigitPos(magnitude - scale);\n        }\n        if (isNegative()) {\n            result = -result;\n        }\n        return result;\n    }\n\n    /**\n     * This returns a long representing the fraction digits of the number, as required by PluralRules.\n     * For example, if we represent the number \"1.20\" (including optional and required digits), then this\n     * function returns \"20\" if includeTrailingZeros is true or \"2\" if false.\n     */\n    public long toFractionLong(boolean includeTrailingZeros) {\n        long result = 0L;\n        int magnitude = -1;\n        int lowerMagnitude = Math.max(scale, rOptPos);\n        if (includeTrailingZeros) {\n            lowerMagnitude = Math.min(lowerMagnitude, rReqPos);\n        }\n        // NOTE: Java has only signed longs, so we check result <= 1e17 instead of 1e18\n        for (; magnitude >= lowerMagnitude && result <= 1e17; magnitude--) {\n            result = result * 10 + getDigitPos(magnitude - scale);\n        }\n        // Remove trailing zeros; this can happen during integer overflow cases.\n        if (!includeTrailingZeros) {\n            while (result > 0 && (result % 10) == 0) {\n                result /= 10;\n            }\n        }\n        return result;\n    }\n\n    static final byte[] INT64_BCD = { 9, 2, 2, 3, 3, 7, 2, 0, 3, 6, 8, 5, 4, 7, 7, 5, 8, 0, 8 };\n\n    /**\n     * Returns whether or not a Long can fully represent the value stored in this DecimalQuantity.\n     */\n    public boolean fitsInLong() {\n        if (isZero()) {\n            return true;\n        }\n        if (scale < 0) {\n            return false;\n        }\n        int magnitude = getMagnitude();\n        if (magnitude < 18) {\n            return true;\n        }\n        if (magnitude > 18) {\n            return false;\n        }\n        // Hard case: the magnitude is 10^18.\n        // The largest int64 is: 9,223,372,036,854,775,807\n        for (int p = 0; p < precision; p++) {\n            byte digit = getDigit(18 - p);\n            if (digit < INT64_BCD[p]) {\n                return true;\n            } else if (digit > INT64_BCD[p]) {\n                return false;\n            }\n        }\n        // Exactly equal to max long plus one.\n        return isNegative();\n    }\n\n    /**\n     * Returns a double approximating the internal BCD. The double may not retain all of the information\n     * encoded in the BCD if the BCD represents a number out of range of a double.\n     *\n     * @return A double representation of the internal BCD.\n     */\n    @Override\n    public double toDouble() {\n        // If this assertion fails, you need to call roundToInfinity() or some other rounding method.\n        // See the comment at the top of this file explaining the \"isApproximate\" field.\n        assert !isApproximate;\n\n        if (isNaN()) {\n            return Double.NaN;\n        } else if (isInfinite()) {\n            return isNegative() ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n        // TODO: Do like in C++ and use a library function to perform this conversion?\n        // This code is not as hot in Java because .parse() returns a BigDecimal, not a double.\n\n        long tempLong = 0L;\n        int lostDigits = precision - Math.min(precision, 17);\n        for (int shift = precision - 1; shift >= lostDigits; shift--) {\n            tempLong = tempLong * 10 + getDigitPos(shift);\n        }\n        double result = tempLong;\n        int _scale = scale + lostDigits;\n        if (_scale >= 0) {\n            // 1e22 is the largest exact double.\n            int i = _scale;\n            for (; i >= 22; i -= 22) {\n                result *= 1e22;\n                if (Double.isInfinite(result)) {\n                    // Further multiplications will not be productive.\n                    i = 0;\n                    break;\n                }\n            }\n            result *= DOUBLE_MULTIPLIERS[i];\n        } else {\n            // 1e22 is the largest exact double.\n            int i = _scale;\n            for (; i <= -22; i += 22) {\n                result /= 1e22;\n                if (result == 0.0) {\n                    // Further divisions will not be productive.\n                    i = 0;\n                    break;\n                }\n            }\n            result /= DOUBLE_MULTIPLIERS[-i];\n        }\n        if (isNegative()) {\n            result = -result;\n        }\n        return result;\n    }\n\n    @Override\n    public BigDecimal toBigDecimal() {\n        if (isApproximate) {\n            // Converting to a BigDecimal requires Double.toString().\n            convertToAccurateDouble();\n        }\n        return bcdToBigDecimal();\n    }\n\n    private static int safeSubtract(int a, int b) {\n        int diff = a - b;\n        if (b < 0 && diff < a)\n            return Integer.MAX_VALUE;\n        if (b > 0 && diff > a)\n            return Integer.MIN_VALUE;\n        return diff;\n    }\n\n    private static final int SECTION_LOWER_EDGE = -1;\n    private static final int SECTION_UPPER_EDGE = -2;\n\n    /** Removes all fraction digits. */\n    public void truncate() {\n        if (scale < 0) {\n            shiftRight(-scale);\n            scale = 0;\n            compact();\n        }\n    }\n\n    @Override\n    public void roundToNickel(int magnitude, MathContext mathContext) {\n        roundToMagnitude(magnitude, mathContext, true);\n    }\n\n    @Override\n    public void roundToMagnitude(int magnitude, MathContext mathContext) {\n        roundToMagnitude(magnitude, mathContext, false);\n    }\n\n    private void roundToMagnitude(int magnitude, MathContext mathContext, boolean nickel) {\n        // The position in the BCD at which rounding will be performed; digits to the right of position\n        // will be rounded away.\n        int position = safeSubtract(magnitude, scale);\n\n        // Enforce the number of digits required by the MathContext.\n        int _mcPrecision = mathContext.getPrecision();\n        if (_mcPrecision > 0 && precision - _mcPrecision > position) {\n            position = precision - _mcPrecision;\n        }\n\n        // \"trailing\" = least significant digit to the left of rounding\n        byte trailingDigit = getDigitPos(position);\n\n        if (position <= 0 && !isApproximate && (!nickel || trailingDigit == 0 || trailingDigit == 5)) {\n            // All digits are to the left of the rounding magnitude.\n        } else if (precision == 0) {\n            // No rounding for zero.\n        } else {\n            // Perform rounding logic.\n            // \"leading\" = most significant digit to the right of rounding\n            byte leadingDigit = getDigitPos(safeSubtract(position, 1));\n\n            // Compute which section of the number we are in.\n            // EDGE means we are at the bottom or top edge, like 1.000 or 1.999 (used by doubles)\n            // LOWER means we are between the bottom edge and the midpoint, like 1.391\n            // MIDPOINT means we are exactly in the middle, like 1.500\n            // UPPER means we are between the midpoint and the top edge, like 1.916\n            int section;\n            if (!isApproximate) {\n                if (nickel && trailingDigit != 2 && trailingDigit != 7) {\n                    // Nickel rounding, and not at .02x or .07x\n                    if (trailingDigit < 2) {\n                        // .00, .01 => down to .00\n                        section = RoundingUtils.SECTION_LOWER;\n                    } else if (trailingDigit < 5) {\n                        // .03, .04 => up to .05\n                        section = RoundingUtils.SECTION_UPPER;\n                    } else if (trailingDigit < 7) {\n                        // .05, .06 => down to .05\n                        section = RoundingUtils.SECTION_LOWER;\n                    } else {\n                        // .08, .09 => up to .10\n                        section = RoundingUtils.SECTION_UPPER;\n                    }\n                } else if (leadingDigit < 5) {\n                    // Includes nickel rounding .020-.024 and .070-.074\n                    section = RoundingUtils.SECTION_LOWER;\n                } else if (leadingDigit > 5) {\n                    // Includes nickel rounding .026-.029 and .076-.079\n                    section = RoundingUtils.SECTION_UPPER;\n                } else {\n                    // Includes nickel rounding .025 and .075\n                    section = RoundingUtils.SECTION_MIDPOINT;\n                    for (int p = safeSubtract(position, 2); p >= 0; p--) {\n                        if (getDigitPos(p) != 0) {\n                            section = RoundingUtils.SECTION_UPPER;\n                            break;\n                        }\n                    }\n                }\n            } else {\n                int p = safeSubtract(position, 2);\n                int minP = Math.max(0, precision - 14);\n                if (leadingDigit == 0 && (!nickel || trailingDigit == 0 || trailingDigit == 5)) {\n                    section = SECTION_LOWER_EDGE;\n                    for (; p >= minP; p--) {\n                        if (getDigitPos(p) != 0) {\n                            section = RoundingUtils.SECTION_LOWER;\n                            break;\n                        }\n                    }\n                } else if (leadingDigit == 4 && (!nickel || trailingDigit == 2 || trailingDigit == 7)) {\n                    section = RoundingUtils.SECTION_MIDPOINT;\n                    for (; p >= minP; p--) {\n                        if (getDigitPos(p) != 9) {\n                            section = RoundingUtils.SECTION_LOWER;\n                            break;\n                        }\n                    }\n                } else if (leadingDigit == 5 && (!nickel || trailingDigit == 2 || trailingDigit == 7)) {\n                    section = RoundingUtils.SECTION_MIDPOINT;\n                    for (; p >= minP; p--) {\n                        if (getDigitPos(p) != 0) {\n                            section = RoundingUtils.SECTION_UPPER;\n                            break;\n                        }\n                    }\n                } else if (leadingDigit == 9 && (!nickel || trailingDigit == 4 || trailingDigit == 9)) {\n                    section = SECTION_UPPER_EDGE;\n                    for (; p >= minP; p--) {\n                        if (getDigitPos(p) != 9) {\n                            section = RoundingUtils.SECTION_UPPER;\n                            break;\n                        }\n                    }\n                } else if (nickel && trailingDigit != 2 && trailingDigit != 7) {\n                    // Nickel rounding, and not at .02x or .07x\n                    if (trailingDigit < 2) {\n                        // .00, .01 => down to .00\n                        section = RoundingUtils.SECTION_LOWER;\n                    } else if (trailingDigit < 5) {\n                        // .03, .04 => up to .05\n                        section = RoundingUtils.SECTION_UPPER;\n                    } else if (trailingDigit < 7) {\n                        // .05, .06 => down to .05\n                        section = RoundingUtils.SECTION_LOWER;\n                    } else {\n                        // .08, .09 => up to .10\n                        section = RoundingUtils.SECTION_UPPER;\n                    }\n                } else if (leadingDigit < 5) {\n                    // Includes nickel rounding .020-.024 and .070-.074\n                    section = RoundingUtils.SECTION_LOWER;\n                } else {\n                    // Includes nickel rounding .026-.029 and .076-.079\n                    section = RoundingUtils.SECTION_UPPER;\n                }\n\n                boolean roundsAtMidpoint = RoundingUtils\n                        .roundsAtMidpoint(mathContext.getRoundingMode().ordinal());\n                if (safeSubtract(position, 1) < precision - 14\n                        || (roundsAtMidpoint && section == RoundingUtils.SECTION_MIDPOINT)\n                        || (!roundsAtMidpoint && section < 0 /* i.e. at upper or lower edge */)) {\n                    // Oops! This means that we have to get the exact representation of the double,\n                    // because the zone of uncertainty is along the rounding boundary.\n                    convertToAccurateDouble();\n                    roundToMagnitude(magnitude, mathContext, nickel); // start over\n                    return;\n                }\n\n                // Turn off the approximate double flag, since the value is now confirmed to be exact.\n                isApproximate = false;\n                origDouble = 0.0;\n                origDelta = 0;\n\n                if (position <= 0 && (!nickel || trailingDigit == 0 || trailingDigit == 5)) {\n                    // All digits are to the left of the rounding magnitude.\n                    return;\n                }\n\n                // Good to continue rounding.\n                if (section == SECTION_LOWER_EDGE)\n                    section = RoundingUtils.SECTION_LOWER;\n                if (section == SECTION_UPPER_EDGE)\n                    section = RoundingUtils.SECTION_UPPER;\n            }\n\n            // Nickel rounding \"half even\" goes to the nearest whole (away from the 5).\n            boolean isEven = nickel\n                    ? (trailingDigit < 2 || trailingDigit > 7\n                            || (trailingDigit == 2 && section != RoundingUtils.SECTION_UPPER)\n                            || (trailingDigit == 7 && section == RoundingUtils.SECTION_UPPER))\n                    : (trailingDigit % 2) == 0;\n\n            boolean roundDown = RoundingUtils.getRoundingDirection(isEven,\n                    isNegative(),\n                    section,\n                    mathContext.getRoundingMode().ordinal(),\n                    this);\n\n            // Perform truncation\n            if (position >= precision) {\n                setBcdToZero();\n                scale = magnitude;\n            } else {\n                shiftRight(position);\n            }\n\n            if (nickel) {\n                if (trailingDigit < 5 && roundDown) {\n                    setDigitPos(0, (byte) 0);\n                    compact();\n                    return;\n                } else if (trailingDigit >= 5 && !roundDown) {\n                    setDigitPos(0, (byte) 9);\n                    trailingDigit = 9;\n                    // do not return: use the bubbling logic below\n                } else {\n                    setDigitPos(0, (byte) 5);\n                    // compact not necessary: digit at position 0 is nonzero\n                    return;\n                }\n            }\n\n            // Bubble the result to the higher digits\n            if (!roundDown) {\n                if (trailingDigit == 9) {\n                    int bubblePos = 0;\n                    // Note: in the long implementation, the most digits BCD can have at this point is\n                    // 15, so bubblePos <= 15 and getDigitPos(bubblePos) is safe.\n                    for (; getDigitPos(bubblePos) == 9; bubblePos++) {\n                    }\n                    shiftRight(bubblePos); // shift off the trailing 9s\n                }\n                byte digit0 = getDigitPos(0);\n                assert digit0 != 9;\n                setDigitPos(0, (byte) (digit0 + 1));\n                precision += 1; // in case an extra digit got added\n            }\n\n            compact();\n        }\n    }\n\n    @Override\n    public void roundToInfinity() {\n        if (isApproximate) {\n            convertToAccurateDouble();\n        }\n    }\n\n    /**\n     * Appends a digit, optionally with one or more leading zeros, to the end of the value represented by\n     * this DecimalQuantity.\n     *\n     * <p>\n     * The primary use of this method is to construct numbers during a parsing loop. It allows parsing to\n     * take advantage of the digit list infrastructure primarily designed for formatting.\n     *\n     * @param value\n     *            The digit to append.\n     * @param leadingZeros\n     *            The number of zeros to append before the digit. For example, if the value in this\n     *            instance starts as 12.3, and you append a 4 with 1 leading zero, the value becomes\n     *            12.304.\n     * @param appendAsInteger\n     *            If true, increase the magnitude of existing digits to make room for the new digit. If\n     *            false, append to the end like a fraction digit. If true, there must not be any fraction\n     *            digits already in the number.\n     * @internal\n     * @deprecated This API is ICU internal only.\n     */\n    @Deprecated\n    public void appendDigit(byte value, int leadingZeros, boolean appendAsInteger) {\n        assert leadingZeros >= 0;\n\n        // Zero requires special handling to maintain the invariant that the least-significant digit\n        // in the BCD is nonzero.\n        if (value == 0) {\n            if (appendAsInteger && precision != 0) {\n                scale += leadingZeros + 1;\n            }\n            return;\n        }\n\n        // Deal with trailing zeros\n        if (scale > 0) {\n            leadingZeros += scale;\n            if (appendAsInteger) {\n                scale = 0;\n            }\n        }\n\n        // Append digit\n        shiftLeft(leadingZeros + 1);\n        setDigitPos(0, value);\n\n        // Fix scale if in integer mode\n        if (appendAsInteger) {\n            scale += leadingZeros + 1;\n        }\n    }\n\n    @Override\n    public String toPlainString() {\n        // NOTE: This logic is duplicated between here and DecimalQuantity_SimpleStorage.\n        StringBuilder sb = new StringBuilder();\n        if (isNegative()) {\n            sb.append('-');\n        }\n        if (precision == 0 || getMagnitude() < 0) {\n            sb.append('0');\n        }\n        for (int m = getUpperDisplayMagnitude(); m >= getLowerDisplayMagnitude(); m--) {\n            sb.append((char) ('0' + getDigit(m)));\n            if (m == 0)\n                sb.append('.');\n        }\n        return sb.toString();\n    }\n\n    public String toScientificString() {\n        StringBuilder sb = new StringBuilder();\n        toScientificString(sb);\n        return sb.toString();\n    }\n\n    public void toScientificString(StringBuilder result) {\n        assert(!isApproximate);\n        if (isNegative()) {\n            result.append('-');\n        }\n        if (precision == 0) {\n            result.append(\"0E+0\");\n            return;\n        }\n        // NOTE: It is not safe to add to lOptPos (aka maxInt) or subtract from\n        // rOptPos (aka -maxFrac) due to overflow.\n        int upperPos = Math.min(precision + scale, lOptPos) - scale - 1;\n        int lowerPos = Math.max(scale, rOptPos) - scale;\n        int p = upperPos;\n        result.append((char) ('0' + getDigitPos(p)));\n        if ((--p) >= lowerPos) {\n            result.append('.');\n            for (; p >= lowerPos; p--) {\n                result.append((char) ('0' + getDigitPos(p)));\n            }\n        }\n        result.append('E');\n        int _scale = upperPos + scale;\n        if (_scale < 0) {\n            _scale *= -1;\n            result.append('-');\n        } else {\n            result.append('+');\n        }\n        if (_scale == 0) {\n            result.append('0');\n        }\n        int insertIndex = result.length();\n        while (_scale > 0) {\n            int quot = _scale / 10;\n            int rem = _scale % 10;\n            result.insert(insertIndex, (char) ('0' + rem));\n            _scale = quot;\n        }\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other == null) {\n            return false;\n        }\n        if (!(other instanceof DecimalQuantity_AbstractBCD)) {\n            return false;\n        }\n        DecimalQuantity_AbstractBCD _other = (DecimalQuantity_AbstractBCD) other;\n\n        boolean basicEquals =\n                scale == _other.scale\n                && precision == _other.precision\n                && flags == _other.flags\n                && lOptPos == _other.lOptPos\n                && lReqPos == _other.lReqPos\n                && rReqPos == _other.rReqPos\n                && rOptPos == _other.rOptPos\n                && isApproximate == _other.isApproximate;\n        if (!basicEquals) {\n            return false;\n        }\n\n        if (precision == 0) {\n            return true;\n        } else if (isApproximate) {\n            return origDouble == _other.origDouble && origDelta == _other.origDelta;\n        } else {\n            for (int m = getUpperDisplayMagnitude(); m >= getLowerDisplayMagnitude(); m--) {\n                if (getDigit(m) != _other.getDigit(m)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Returns a single digit from the BCD list. No internal state is changed by calling this method.\n     *\n     * @param position\n     *            The position of the digit to pop, counted in BCD units from the least significant\n     *            digit. If outside the range supported by the implementation, zero is returned.\n     * @return The digit at the specified location.\n     */\n    protected abstract byte getDigitPos(int position);\n\n    /**\n     * Sets the digit in the BCD list. This method only sets the digit; it is the caller's responsibility\n     * to call {@link #compact} after setting the digit.\n     *\n     * @param position\n     *            The position of the digit to pop, counted in BCD units from the least significant\n     *            digit. If outside the range supported by the implementation, an AssertionError is\n     *            thrown.\n     * @param value\n     *            The digit to set at the specified location.\n     */\n    protected abstract void setDigitPos(int position, byte value);\n\n    /**\n     * Adds zeros to the end of the BCD list. This will result in an invalid BCD representation; it is\n     * the caller's responsibility to do further manipulation and then call {@link #compact}.\n     *\n     * @param numDigits\n     *            The number of zeros to add.\n     */\n    protected abstract void shiftLeft(int numDigits);\n\n    /**\n     * Removes digits from the end of the BCD list. This may result in an invalid BCD representation; it\n     * is the caller's responsibility to follow-up with a call to {@link #compact}.\n     *\n     * @param numDigits\n     *            The number of digits to remove.\n     */\n    protected abstract void shiftRight(int numDigits);\n\n    /**\n     * Sets the internal representation to zero. Clears any values stored in scale, precision, hasDouble,\n     * origDouble, origDelta, and BCD data.\n     */\n    protected abstract void setBcdToZero();\n\n    /**\n     * Sets the internal BCD state to represent the value in the given int. The int is guaranteed to be\n     * either positive. The internal state is guaranteed to be empty when this method is called.\n     *\n     * @param n\n     *            The value to consume.\n     */\n    protected abstract void readIntToBcd(int input);\n\n    /**\n     * Sets the internal BCD state to represent the value in the given long. The long is guaranteed to be\n     * either positive. The internal state is guaranteed to be empty when this method is called.\n     *\n     * @param n\n     *            The value to consume.\n     */\n    protected abstract void readLongToBcd(long input);\n\n    /**\n     * Sets the internal BCD state to represent the value in the given BigInteger. The BigInteger is\n     * guaranteed to be positive, and it is guaranteed to be larger than Long.MAX_VALUE. The internal\n     * state is guaranteed to be empty when this method is called.\n     *\n     * @param n\n     *            The value to consume.\n     */\n    protected abstract void readBigIntegerToBcd(BigInteger input);\n\n    /**\n     * Returns a BigDecimal encoding the internal BCD value.\n     *\n     * @return A BigDecimal representation of the internal BCD.\n     */\n    protected abstract BigDecimal bcdToBigDecimal();\n\n    protected abstract void copyBcdFrom(DecimalQuantity _other);\n\n    /**\n     * Removes trailing zeros from the BCD (adjusting the scale as required) and then computes the\n     * precision. The precision is the number of digits in the number up through the greatest nonzero\n     * digit.\n     *\n     * <p>\n     * This method must always be called when bcd changes in order for assumptions to be correct in\n     * methods like {@link #fractionCount()}.\n     */\n    protected abstract void compact();\n}\n", "// \u00a9 2017 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html#License\npackage com.ibm.icu.impl.number;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\n/**\n * A DecimalQuantity with internal storage as a 64-bit BCD, with fallback to a byte array for numbers\n * that don't fit into the standard BCD.\n */\npublic final class DecimalQuantity_DualStorageBCD extends DecimalQuantity_AbstractBCD {\n\n    /**\n     * The BCD of the 16 digits of the number represented by this object. Every 4 bits of the long map to\n     * one digit. For example, the number \"12345\" in BCD is \"0x12345\".\n     *\n     * <p>\n     * Whenever bcd changes internally, {@link #compact()} must be called, except in special cases like\n     * setting the digit to zero.\n     */\n    private byte[] bcdBytes;\n\n    private long bcdLong = 0L;\n\n    private boolean usingBytes = false;\n\n    @Override\n    public int maxRepresentableDigits() {\n        return Integer.MAX_VALUE;\n    }\n\n    public DecimalQuantity_DualStorageBCD() {\n        setBcdToZero();\n        flags = 0;\n    }\n\n    public DecimalQuantity_DualStorageBCD(long input) {\n        setToLong(input);\n    }\n\n    public DecimalQuantity_DualStorageBCD(int input) {\n        setToInt(input);\n    }\n\n    public DecimalQuantity_DualStorageBCD(double input) {\n        setToDouble(input);\n    }\n\n    public DecimalQuantity_DualStorageBCD(BigInteger input) {\n        setToBigInteger(input);\n    }\n\n    public DecimalQuantity_DualStorageBCD(BigDecimal input) {\n        setToBigDecimal(input);\n    }\n\n    public DecimalQuantity_DualStorageBCD(DecimalQuantity_DualStorageBCD other) {\n        copyFrom(other);\n    }\n\n    public DecimalQuantity_DualStorageBCD(Number number) {\n        // NOTE: Number type expansion happens both here\n        // and in NumberFormat.java\n        if (number instanceof Long) {\n            setToLong(number.longValue());\n        } else if (number instanceof Integer) {\n            setToInt(number.intValue());\n        } else if (number instanceof Float) {\n            setToDouble(number.doubleValue());\n        } else if (number instanceof Double) {\n            setToDouble(number.doubleValue());\n        } else if (number instanceof BigInteger) {\n            setToBigInteger((BigInteger) number);\n        } else if (number instanceof BigDecimal) {\n            setToBigDecimal((BigDecimal) number);\n        } else if (number instanceof com.ibm.icu.math.BigDecimal) {\n            setToBigDecimal(((com.ibm.icu.math.BigDecimal) number).toBigDecimal());\n        } else {\n            throw new IllegalArgumentException(\n                    \"Number is of an unsupported type: \" + number.getClass().getName());\n        }\n    }\n\n    @Override\n    public DecimalQuantity createCopy() {\n        return new DecimalQuantity_DualStorageBCD(this);\n    }\n\n    @Override\n    protected byte getDigitPos(int position) {\n        if (usingBytes) {\n            if (position < 0 || position >= precision)\n                return 0;\n            return bcdBytes[position];\n        } else {\n            if (position < 0 || position >= 16)\n                return 0;\n            return (byte) ((bcdLong >>> (position * 4)) & 0xf);\n        }\n    }\n\n    @Override\n    protected void setDigitPos(int position, byte value) {\n        assert position >= 0;\n        if (usingBytes) {\n            ensureCapacity(position + 1);\n            bcdBytes[position] = value;\n        } else if (position >= 16) {\n            switchStorage();\n            ensureCapacity(position + 1);\n            bcdBytes[position] = value;\n        } else {\n            int shift = position * 4;\n            bcdLong = bcdLong & ~(0xfL << shift) | ((long) value << shift);\n        }\n    }\n\n    @Override\n    protected void shiftLeft(int numDigits) {\n        if (!usingBytes && precision + numDigits > 16) {\n            switchStorage();\n        }\n        if (usingBytes) {\n            ensureCapacity(precision + numDigits);\n            int i = precision + numDigits - 1;\n            for (; i >= numDigits; i--) {\n                bcdBytes[i] = bcdBytes[i - numDigits];\n            }\n            for (; i >= 0; i--) {\n                bcdBytes[i] = 0;\n            }\n        } else {\n            bcdLong <<= (numDigits * 4);\n        }\n        scale -= numDigits;\n        precision += numDigits;\n    }\n\n    @Override\n    protected void shiftRight(int numDigits) {\n        if (usingBytes) {\n            int i = 0;\n            for (; i < precision - numDigits; i++) {\n                bcdBytes[i] = bcdBytes[i + numDigits];\n            }\n            for (; i < precision; i++) {\n                bcdBytes[i] = 0;\n            }\n        } else {\n            bcdLong >>>= (numDigits * 4);\n        }\n        scale += numDigits;\n        precision -= numDigits;\n    }\n\n    @Override\n    protected void setBcdToZero() {\n        if (usingBytes) {\n            bcdBytes = null;\n            usingBytes = false;\n        }\n        bcdLong = 0L;\n        scale = 0;\n        precision = 0;\n        isApproximate = false;\n        origDouble = 0;\n        origDelta = 0;\n    }\n\n    @Override\n    protected void readIntToBcd(int n) {\n        assert n != 0;\n        // ints always fit inside the long implementation.\n        long result = 0L;\n        int i = 16;\n        for (; n != 0; n /= 10, i--) {\n            result = (result >>> 4) + (((long) n % 10) << 60);\n        }\n        assert !usingBytes;\n        bcdLong = result >>> (i * 4);\n        scale = 0;\n        precision = 16 - i;\n    }\n\n    @Override\n    protected void readLongToBcd(long n) {\n        assert n != 0;\n        if (n >= 10000000000000000L) {\n            ensureCapacity();\n            int i = 0;\n            for (; n != 0L; n /= 10L, i++) {\n                bcdBytes[i] = (byte) (n % 10);\n            }\n            assert usingBytes;\n            scale = 0;\n            precision = i;\n        } else {\n            long result = 0L;\n            int i = 16;\n            for (; n != 0L; n /= 10L, i--) {\n                result = (result >>> 4) + ((n % 10) << 60);\n            }\n            assert i >= 0;\n            assert !usingBytes;\n            bcdLong = result >>> (i * 4);\n            scale = 0;\n            precision = 16 - i;\n        }\n    }\n\n    @Override\n    protected void readBigIntegerToBcd(BigInteger n) {\n        assert n.signum() != 0;\n        ensureCapacity(); // allocate initial byte array\n        int i = 0;\n        for (; n.signum() != 0; i++) {\n            BigInteger[] temp = n.divideAndRemainder(BigInteger.TEN);\n            ensureCapacity(i + 1);\n            bcdBytes[i] = temp[1].byteValue();\n            n = temp[0];\n        }\n        scale = 0;\n        precision = i;\n    }\n\n    @Override\n    protected BigDecimal bcdToBigDecimal() {\n        if (usingBytes) {\n            // Converting to a string here is faster than doing BigInteger/BigDecimal arithmetic.\n            BigDecimal result = new BigDecimal(toNumberString());\n            if (isNegative()) {\n                result = result.negate();\n            }\n            return result;\n        } else {\n            long tempLong = 0L;\n            for (int shift = (precision - 1); shift >= 0; shift--) {\n                tempLong = tempLong * 10 + getDigitPos(shift);\n            }\n            BigDecimal result = BigDecimal.valueOf(tempLong);\n            result = result.scaleByPowerOfTen(scale);\n            if (isNegative())\n                result = result.negate();\n            return result;\n        }\n    }\n\n    @Override\n    protected void compact() {\n        if (usingBytes) {\n            int delta = 0;\n            for (; delta < precision && bcdBytes[delta] == 0; delta++)\n                ;\n            if (delta == precision) {\n                // Number is zero\n                setBcdToZero();\n                return;\n            } else {\n                // Remove trailing zeros\n                shiftRight(delta);\n            }\n\n            // Compute precision\n            int leading = precision - 1;\n            for (; leading >= 0 && bcdBytes[leading] == 0; leading--)\n                ;\n            precision = leading + 1;\n\n            // Switch storage mechanism if possible\n            if (precision <= 16) {\n                switchStorage();\n            }\n\n        } else {\n            if (bcdLong == 0L) {\n                // Number is zero\n                setBcdToZero();\n                return;\n            }\n\n            // Compact the number (remove trailing zeros)\n            int delta = Long.numberOfTrailingZeros(bcdLong) / 4;\n            bcdLong >>>= delta * 4;\n            scale += delta;\n\n            // Compute precision\n            precision = 16 - (Long.numberOfLeadingZeros(bcdLong) / 4);\n        }\n    }\n\n    /** Ensure that a byte array of at least 40 digits is allocated. */\n    private void ensureCapacity() {\n        ensureCapacity(40);\n    }\n\n    private void ensureCapacity(int capacity) {\n        if (capacity == 0)\n            return;\n        int oldCapacity = usingBytes ? bcdBytes.length : 0;\n        if (!usingBytes) {\n            bcdBytes = new byte[capacity];\n        } else if (oldCapacity < capacity) {\n            byte[] bcd1 = new byte[capacity * 2];\n            System.arraycopy(bcdBytes, 0, bcd1, 0, oldCapacity);\n            bcdBytes = bcd1;\n        }\n        usingBytes = true;\n    }\n\n    /** Switches the internal storage mechanism between the 64-bit long and the byte array. */\n    private void switchStorage() {\n        if (usingBytes) {\n            // Change from bytes to long\n            bcdLong = 0L;\n            for (int i = precision - 1; i >= 0; i--) {\n                bcdLong <<= 4;\n                bcdLong |= bcdBytes[i];\n            }\n            bcdBytes = null;\n            usingBytes = false;\n        } else {\n            // Change from long to bytes\n            ensureCapacity();\n            for (int i = 0; i < precision; i++) {\n                bcdBytes[i] = (byte) (bcdLong & 0xf);\n                bcdLong >>>= 4;\n            }\n            assert usingBytes;\n        }\n    }\n\n    @Override\n    protected void copyBcdFrom(DecimalQuantity _other) {\n        DecimalQuantity_DualStorageBCD other = (DecimalQuantity_DualStorageBCD) _other;\n        setBcdToZero();\n        if (other.usingBytes) {\n            ensureCapacity(other.precision);\n            System.arraycopy(other.bcdBytes, 0, bcdBytes, 0, other.precision);\n        } else {\n            bcdLong = other.bcdLong;\n        }\n    }\n\n    /**\n     * Checks whether the bytes stored in this instance are all valid. For internal unit testing only.\n     *\n     * @return An error message if this instance is invalid, or null if this instance is healthy.\n     * @internal\n     * @deprecated This API is for ICU internal use only.\n     */\n    @Deprecated\n    public String checkHealth() {\n        if (usingBytes) {\n            if (bcdLong != 0)\n                return \"Value in bcdLong but we are in byte mode\";\n            if (precision == 0)\n                return \"Zero precision but we are in byte mode\";\n            if (precision > bcdBytes.length)\n                return \"Precision exceeds length of byte array\";\n            if (getDigitPos(precision - 1) == 0)\n                return \"Most significant digit is zero in byte mode\";\n            if (getDigitPos(0) == 0)\n                return \"Least significant digit is zero in long mode\";\n            for (int i = 0; i < precision; i++) {\n                if (getDigitPos(i) >= 10)\n                    return \"Digit exceeding 10 in byte array\";\n                if (getDigitPos(i) < 0)\n                    return \"Digit below 0 in byte array\";\n            }\n            for (int i = precision; i < bcdBytes.length; i++) {\n                if (getDigitPos(i) != 0)\n                    return \"Nonzero digits outside of range in byte array\";\n            }\n        } else {\n            if (bcdBytes != null) {\n                for (int i = 0; i < bcdBytes.length; i++) {\n                    if (bcdBytes[i] != 0)\n                        return \"Nonzero digits in byte array but we are in long mode\";\n                }\n            }\n            if (precision == 0 && bcdLong != 0)\n                return \"Value in bcdLong even though precision is zero\";\n            if (precision > 16)\n                return \"Precision exceeds length of long\";\n            if (precision != 0 && getDigitPos(precision - 1) == 0)\n                return \"Most significant digit is zero in long mode\";\n            if (precision != 0 && getDigitPos(0) == 0)\n                return \"Least significant digit is zero in long mode\";\n            for (int i = 0; i < precision; i++) {\n                if (getDigitPos(i) >= 10)\n                    return \"Digit exceeding 10 in long\";\n                if (getDigitPos(i) < 0)\n                    return \"Digit below 0 in long (?!)\";\n            }\n            for (int i = precision; i < 16; i++) {\n                if (getDigitPos(i) != 0)\n                    return \"Nonzero digits outside of range in long\";\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Checks whether this {@link DecimalQuantity_DualStorageBCD} is using its internal byte array\n     * storage mechanism.\n     *\n     * @return true if an internal byte array is being used; false if a long is being used.\n     * @internal\n     * @deprecated This API is ICU internal only.\n     */\n    @Deprecated\n    public boolean isUsingBytes() {\n        return usingBytes;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"<DecimalQuantity %s:%d:%d:%s %s %s%s>\",\n                (lOptPos > 1000 ? \"999\" : String.valueOf(lOptPos)),\n                lReqPos,\n                rReqPos,\n                (rOptPos < -1000 ? \"-999\" : String.valueOf(rOptPos)),\n                (usingBytes ? \"bytes\" : \"long\"),\n                (isNegative() ? \"-\" : \"\"),\n                toNumberString());\n    }\n\n    private String toNumberString() {\n        StringBuilder sb = new StringBuilder();\n        if (usingBytes) {\n            if (precision == 0) {\n                sb.append('0');\n            }\n            for (int i = precision - 1; i >= 0; i--) {\n                sb.append(bcdBytes[i]);\n            }\n        } else {\n            sb.append(Long.toHexString(bcdLong));\n        }\n        sb.append(\"E\");\n        sb.append(scale);\n        return sb.toString();\n    }\n}\n", "// \u00a9 2016 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html#License\n/*\n *******************************************************************************\n * Copyright (C) 2001-2016, International Business Machines Corporation and\n * others. All Rights Reserved.\n *******************************************************************************\n */\n\n/**\n * Port From:   ICU4C v1.8.1 : format : NumberFormatTest\n * Source File: $ICU4oot/source/test/intltest/numfmtst.cpp\n **/\n\npackage com.ibm.icu.dev.test.format;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.math.BigInteger;\nimport java.math.RoundingMode;\nimport java.text.AttributedCharacterIterator;\nimport java.text.FieldPosition;\nimport java.text.Format;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Random;\nimport java.util.Set;\n\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\nimport com.ibm.icu.dev.test.TestFmwk;\nimport com.ibm.icu.dev.test.TestUtil;\nimport com.ibm.icu.dev.test.format.IntlTestDecimalFormatAPIC.FieldContainer;\nimport com.ibm.icu.dev.text.DecimalFormat_ICU58;\nimport com.ibm.icu.impl.ICUConfig;\nimport com.ibm.icu.impl.LocaleUtility;\nimport com.ibm.icu.impl.data.ResourceReader;\nimport com.ibm.icu.impl.data.TokenIterator;\nimport com.ibm.icu.math.BigDecimal;\nimport com.ibm.icu.math.MathContext;\nimport com.ibm.icu.text.CompactDecimalFormat;\nimport com.ibm.icu.text.CurrencyPluralInfo;\nimport com.ibm.icu.text.DecimalFormat;\nimport com.ibm.icu.text.DecimalFormatSymbols;\nimport com.ibm.icu.text.DisplayContext;\nimport com.ibm.icu.text.MeasureFormat;\nimport com.ibm.icu.text.NumberFormat;\nimport com.ibm.icu.text.NumberFormat.NumberFormatFactory;\nimport com.ibm.icu.text.NumberFormat.SimpleNumberFormatFactory;\nimport com.ibm.icu.text.NumberingSystem;\nimport com.ibm.icu.text.RuleBasedNumberFormat;\nimport com.ibm.icu.text.UnicodeSet;\nimport com.ibm.icu.util.Currency;\nimport com.ibm.icu.util.Currency.CurrencyUsage;\nimport com.ibm.icu.util.CurrencyAmount;\nimport com.ibm.icu.util.ULocale;\n\n@RunWith(JUnit4.class)\npublic class NumberFormatTest extends TestFmwk {\n\n    @Test\n    public void TestRoundingScientific10542() {\n        DecimalFormat format =\n                new DecimalFormat(\"0.00E0\");\n\n        int[] roundingModes = {\n              BigDecimal.ROUND_CEILING,\n              BigDecimal.ROUND_DOWN,\n              BigDecimal.ROUND_FLOOR,\n              BigDecimal.ROUND_HALF_DOWN,\n              BigDecimal.ROUND_HALF_EVEN,\n              BigDecimal.ROUND_HALF_UP,\n              BigDecimal.ROUND_UP};\n        String[] descriptions = {\n                \"Round Ceiling\",\n                \"Round Down\",\n                \"Round Floor\",\n                \"Round half down\",\n                \"Round half even\",\n                \"Round half up\",\n                \"Round up\"};\n\n        double[] values = {-0.003006, -0.003005, -0.003004, 0.003014, 0.003015, 0.003016};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        String[][] expected = {\n                {\"-3.00E-3\", \"-3.00E-3\", \"-3.00E-3\", \"3.02E-3\", \"3.02E-3\", \"3.02E-3\"},\n                {\"-3.00E-3\", \"-3.00E-3\", \"-3.00E-3\", \"3.01E-3\", \"3.01E-3\", \"3.01E-3\"},\n                {\"-3.01E-3\", \"-3.01E-3\", \"-3.01E-3\", \"3.01E-3\", \"3.01E-3\", \"3.01E-3\"},\n                {\"-3.01E-3\", \"-3.00E-3\", \"-3.00E-3\", \"3.01E-3\", \"3.01E-3\", \"3.02E-3\"},\n                {\"-3.01E-3\", \"-3.00E-3\", \"-3.00E-3\", \"3.01E-3\", \"3.02E-3\", \"3.02E-3\"},\n                {\"-3.01E-3\", \"-3.01E-3\", \"-3.00E-3\", \"3.01E-3\", \"3.02E-3\", \"3.02E-3\"},\n                {\"-3.01E-3\", \"-3.01E-3\", \"-3.01E-3\", \"3.02E-3\", \"3.02E-3\", \"3.02E-3\"}};\n        verifyRounding(format, values, expected, roundingModes, descriptions);\n        values = new double[]{-3006.0, -3005, -3004, 3014, 3015, 3016};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        expected = new String[][]{\n                {\"-3.00E3\", \"-3.00E3\", \"-3.00E3\", \"3.02E3\", \"3.02E3\", \"3.02E3\"},\n                {\"-3.00E3\", \"-3.00E3\", \"-3.00E3\", \"3.01E3\", \"3.01E3\", \"3.01E3\"},\n                {\"-3.01E3\", \"-3.01E3\", \"-3.01E3\", \"3.01E3\", \"3.01E3\", \"3.01E3\"},\n                {\"-3.01E3\", \"-3.00E3\", \"-3.00E3\", \"3.01E3\", \"3.01E3\", \"3.02E3\"},\n                {\"-3.01E3\", \"-3.00E3\", \"-3.00E3\", \"3.01E3\", \"3.02E3\", \"3.02E3\"},\n                {\"-3.01E3\", \"-3.01E3\", \"-3.00E3\", \"3.01E3\", \"3.02E3\", \"3.02E3\"},\n                {\"-3.01E3\", \"-3.01E3\", \"-3.01E3\", \"3.02E3\", \"3.02E3\", \"3.02E3\"}};\n        verifyRounding(format, values, expected, roundingModes, descriptions);\n        values = new double[]{0.0, -0.0};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        expected = new String[][]{\n                {\"0.00E0\", \"-0.00E0\"},\n                {\"0.00E0\", \"-0.00E0\"},\n                {\"0.00E0\", \"-0.00E0\"},\n                {\"0.00E0\", \"-0.00E0\"},\n                {\"0.00E0\", \"-0.00E0\"},\n                {\"0.00E0\", \"-0.00E0\"},\n                {\"0.00E0\", \"-0.00E0\"}};\n        verifyRounding(format, values, expected, roundingModes, descriptions);\n        values = new double[]{1e25, 1e25 + 1e15, 1e25 - 1e15};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        expected = new String[][]{\n                {\"1.00E25\", \"1.01E25\", \"1.00E25\"},\n                {\"1.00E25\", \"1.00E25\", \"9.99E24\"},\n                {\"1.00E25\", \"1.00E25\", \"9.99E24\"},\n                {\"1.00E25\", \"1.00E25\", \"1.00E25\"},\n                {\"1.00E25\", \"1.00E25\", \"1.00E25\"},\n                {\"1.00E25\", \"1.00E25\", \"1.00E25\"},\n                {\"1.00E25\", \"1.01E25\", \"1.00E25\"}};\n        verifyRounding(format, values, expected, roundingModes, descriptions);\n        values = new double[]{-1e25, -1e25 + 1e15, -1e25 - 1e15};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        expected = new String[][]{\n                {\"-1.00E25\", \"-9.99E24\", \"-1.00E25\"},\n                {\"-1.00E25\", \"-9.99E24\", \"-1.00E25\"},\n                {\"-1.00E25\", \"-1.00E25\", \"-1.01E25\"},\n                {\"-1.00E25\", \"-1.00E25\", \"-1.00E25\"},\n                {\"-1.00E25\", \"-1.00E25\", \"-1.00E25\"},\n                {\"-1.00E25\", \"-1.00E25\", \"-1.00E25\"},\n                {\"-1.00E25\", \"-1.00E25\", \"-1.01E25\"}};\n        verifyRounding(format, values, expected, roundingModes, descriptions);\n        values = new double[]{1e-25, 1e-25 + 1e-35, 1e-25 - 1e-35};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        expected = new String[][]{\n                {\"1.00E-25\", \"1.01E-25\", \"1.00E-25\"},\n                {\"1.00E-25\", \"1.00E-25\", \"9.99E-26\"},\n                {\"1.00E-25\", \"1.00E-25\", \"9.99E-26\"},\n                {\"1.00E-25\", \"1.00E-25\", \"1.00E-25\"},\n                {\"1.00E-25\", \"1.00E-25\", \"1.00E-25\"},\n                {\"1.00E-25\", \"1.00E-25\", \"1.00E-25\"},\n                {\"1.00E-25\", \"1.01E-25\", \"1.00E-25\"}};\n        verifyRounding(format, values, expected, roundingModes, descriptions);\n        values = new double[]{-1e-25, -1e-25 + 1e-35, -1e-25 - 1e-35};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        expected = new String[][]{\n                {\"-1.00E-25\", \"-9.99E-26\", \"-1.00E-25\"},\n                {\"-1.00E-25\", \"-9.99E-26\", \"-1.00E-25\"},\n                {\"-1.00E-25\", \"-1.00E-25\", \"-1.01E-25\"},\n                {\"-1.00E-25\", \"-1.00E-25\", \"-1.00E-25\"},\n                {\"-1.00E-25\", \"-1.00E-25\", \"-1.00E-25\"},\n                {\"-1.00E-25\", \"-1.00E-25\", \"-1.00E-25\"},\n                {\"-1.00E-25\", \"-1.00E-25\", \"-1.01E-25\"}};\n        verifyRounding(format, values, expected, roundingModes, descriptions);\n    }\n\n    private void verifyRounding(DecimalFormat format, double[] values, String[][] expected, int[] roundingModes,\n            String[] descriptions) {\n        for (int i = 0; i < roundingModes.length; i++) {\n            format.setRoundingMode(roundingModes[i]);\n            for (int j = 0; j < values.length; j++) {\n                assertEquals(descriptions[i]+\" \" +values[j], expected[i][j], format.format(values[j]));\n            }\n        }\n    }\n\n    @Test\n    public void Test10419RoundingWith0FractionDigits() {\n        Object[][] data = new Object[][]{\n                {BigDecimal.ROUND_CEILING, 1.488, \"2\"},\n                {BigDecimal.ROUND_DOWN, 1.588, \"1\"},\n                {BigDecimal.ROUND_FLOOR, 1.588, \"1\"},\n                {BigDecimal.ROUND_HALF_DOWN, 1.5, \"1\"},\n                {BigDecimal.ROUND_HALF_EVEN, 2.5, \"2\"},\n                {BigDecimal.ROUND_HALF_UP, 2.5, \"3\"},\n                {BigDecimal.ROUND_UP, 1.5, \"2\"},\n        };\n        NumberFormat nff = NumberFormat.getNumberInstance(ULocale.ENGLISH);\n        nff.setMaximumFractionDigits(0);\n        for (Object[] item : data) {\n          nff.setRoundingMode(((Integer) item[0]).intValue());\n          assertEquals(\"Test10419\", item[2], nff.format(item[1]));\n        }\n    }\n\n    @Test\n    public void TestParseNegativeWithFaLocale() {\n        DecimalFormat parser = (DecimalFormat) NumberFormat.getInstance(new ULocale(\"fa\"));\n        try {\n            double value = parser.parse(\"-0,5\").doubleValue();\n            assertEquals(\"Expect -0.5\", -0.5, value);\n        } catch (ParseException e) {\n            TestFmwk.errln(\"Parsing -0.5 should have succeeded.\");\n        }\n    }\n\n    @Test\n    public void TestParseNegativeWithAlternativeMinusSign() {\n        DecimalFormat parser = (DecimalFormat) NumberFormat.getInstance(new ULocale(\"en\"));\n        try {\n            double value = parser.parse(\"\\u208B0.5\").doubleValue();\n            assertEquals(\"Expect -0.5\", -0.5, value);\n        } catch (ParseException e) {\n            TestFmwk.errln(\"Parsing -0.5 should have succeeded.\");\n        }\n    }\n\n    // Test various patterns\n    @Test\n    public void TestPatterns() {\n\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(Locale.US);\n        final String pat[]    = { \"#.#\", \"#.\", \".#\", \"#\" };\n        int pat_length = pat.length;\n        final String newpat[] = { \"0.#\", \"0.\", \"#.0\", \"0\" };\n        final String num[]    = { \"0\",   \"0.\", \".0\", \"0\" };\n        for (int i=0; i<pat_length; ++i)\n        {\n            DecimalFormat fmt = new DecimalFormat(pat[i], sym);\n            String newp = fmt.toPattern();\n            if (!newp.equals(newpat[i]))\n                errln(\"FAIL: Pattern \" + pat[i] + \" should transmute to \" + newpat[i] +\n                        \"; \" + newp + \" seen instead\");\n\n            String s = ((NumberFormat)fmt).format(0);\n            if (!s.equals(num[i]))\n            {\n                errln(\"FAIL: Pattern \" + pat[i] + \" should format zero as \" + num[i] +\n                        \"; \" + s + \" seen instead\");\n                logln(\"Min integer digits = \" + fmt.getMinimumIntegerDigits());\n            }\n            // BigInteger 0 - ticket#4731\n            s = ((NumberFormat)fmt).format(BigInteger.ZERO);\n            if (!s.equals(num[i]))\n            {\n                errln(\"FAIL: Pattern \" + pat[i] + \" should format BigInteger zero as \" + num[i] +\n                        \"; \" + s + \" seen instead\");\n                logln(\"Min integer digits = \" + fmt.getMinimumIntegerDigits());\n            }\n        }\n    }\n\n    // Test exponential pattern\n    @Test\n    public void TestExponential() {\n\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(Locale.US);\n        final String pat[] = { \"0.####E0\", \"00.000E00\", \"##0.######E000\", \"0.###E0;[0.###E0]\" };\n        int pat_length = pat.length;\n\n        double val[] = { 0.01234, 123456789, 1.23e300, -3.141592653e-271 };\n        int val_length = val.length;\n        final String valFormat[] = {\n                // 0.####E0\n                \"1.234E-2\", \"1.2346E8\", \"1.23E300\", \"-3.1416E-271\",\n                // 00.000E00\n                \"12.340E-03\", \"12.346E07\", \"12.300E299\", \"-31.416E-272\",\n                // ##0.######E000\n                \"12.34E-003\", \"123.4568E006\", \"1.23E300\", \"-314.1593E-273\",\n                // 0.###E0;[0.###E0]\n                \"1.234E-2\", \"1.235E8\", \"1.23E300\", \"[3.142E-271]\" };\n        /*double valParse[] =\n            {\n                0.01234, 123460000, 1.23E300, -3.1416E-271,\n                0.01234, 123460000, 1.23E300, -3.1416E-271,\n                0.01234, 123456800, 1.23E300, -3.141593E-271,\n                0.01234, 123500000, 1.23E300, -3.142E-271,\n            };*/ //The variable is never used\n\n        int lval[] = { 0, -1, 1, 123456789 };\n        int lval_length = lval.length;\n        final String lvalFormat[] = {\n                // 0.####E0\n                \"0E0\", \"-1E0\", \"1E0\", \"1.2346E8\",\n                // 00.000E00\n                \"00.000E00\", \"-10.000E-01\", \"10.000E-01\", \"12.346E07\",\n                // ##0.######E000\n                \"0E000\", \"-1E000\", \"1E000\", \"123.4568E006\",\n                // 0.###E0;[0.###E0]\n                \"0E0\", \"[1E0]\", \"1E0\", \"1.235E8\" };\n        int lvalParse[] =\n            {\n                0, -1, 1, 123460000,\n                0, -1, 1, 123460000,\n                0, -1, 1, 123456800,\n                0, -1, 1, 123500000,\n            };\n        int ival = 0, ilval = 0;\n        for (int p = 0; p < pat_length; ++p) {\n            DecimalFormat fmt = new DecimalFormat(pat[p], sym);\n            logln(\"Pattern \\\"\" + pat[p] + \"\\\" -toPattern-> \\\"\" + fmt.toPattern() + \"\\\"\");\n            int v;\n            for (v = 0; v < val_length; ++v) {\n                String s;\n                s = ((NumberFormat) fmt).format(val[v]);\n                logln(\" \" + val[v] + \" -format-> \" + s);\n                if (!s.equals(valFormat[v + ival]))\n                    errln(\"FAIL: Expected \" + valFormat[v + ival]);\n\n                ParsePosition pos = new ParsePosition(0);\n                double a = fmt.parse(s, pos).doubleValue();\n                if (pos.getIndex() == s.length()) {\n                    logln(\"  -parse-> \" + Double.toString(a));\n                    // Use epsilon comparison as necessary\n                } else\n                    errln(\"FAIL: Partial parse (\" + pos.getIndex() + \" chars) -> \" + a);\n            }\n            for (v = 0; v < lval_length; ++v) {\n                String s;\n                s = ((NumberFormat) fmt).format(lval[v]);\n                logln(\" \" + lval[v] + \"L -format-> \" + s);\n                if (!s.equals(lvalFormat[v + ilval]))\n                    errln(\"ERROR: Expected \" + lvalFormat[v + ilval] + \" Got: \" + s);\n\n                ParsePosition pos = new ParsePosition(0);\n                long a = 0;\n                Number A = fmt.parse(s, pos);\n                if (A != null) {\n                    a = A.longValue();\n                    if (pos.getIndex() == s.length()) {\n                        logln(\"  -parse-> \" + a);\n                        if (a != lvalParse[v + ilval])\n                            errln(\"FAIL: Expected \" + lvalParse[v + ilval]);\n                    } else\n                        errln(\"FAIL: Partial parse (\" + pos.getIndex() + \" chars) -> \" + Long.toString(a));\n                } else {\n                    errln(\"Fail to parse the string: \" + s);\n                }\n            }\n            ival += val_length;\n            ilval += lval_length;\n        }\n    }\n\n    // Test the handling of quotes\n    @Test\n    public void TestQuotes() {\n\n        StringBuffer pat;\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(Locale.US);\n        pat = new StringBuffer(\"a'fo''o'b#\");\n        DecimalFormat fmt = new DecimalFormat(pat.toString(), sym);\n        String s = ((NumberFormat)fmt).format(123);\n        logln(\"Pattern \\\"\" + pat + \"\\\"\");\n        logln(\" Format 123 . \" + s);\n        if (!s.equals(\"afo'ob123\"))\n            errln(\"FAIL: Expected afo'ob123\");\n\n        s =\"\";\n        pat = new StringBuffer(\"a''b#\");\n        fmt = new DecimalFormat(pat.toString(), sym);\n        s = ((NumberFormat)fmt).format(123);\n        logln(\"Pattern \\\"\" + pat + \"\\\"\");\n        logln(\" Format 123 . \" + s);\n        if (!s.equals(\"a'b123\"))\n            errln(\"FAIL: Expected a'b123\");\n    }\n\n    @Test\n    public void TestParseCurrencyTrailingSymbol() {\n        // see sun bug 4709840\n        NumberFormat fmt = NumberFormat.getCurrencyInstance(Locale.GERMANY);\n        float val = 12345.67f;\n        String str = fmt.format(val);\n        logln(\"val: \" + val + \" str: \" + str);\n        try {\n            Number num = fmt.parse(str);\n            logln(\"num: \" + num);\n        } catch (ParseException e) {\n            errln(\"parse of '\" + str + \"' threw exception: \" + e);\n        }\n    }\n\n    /**\n     * Test the handling of the currency symbol in patterns.\n     **/\n    @Test\n    public void TestCurrencySign() {\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(Locale.US);\n        StringBuffer pat = new StringBuffer(\"\");\n        char currency = 0x00A4;\n        // \"\\xA4#,##0.00;-\\xA4#,##0.00\"\n        pat.append(currency).append(\"#,##0.00;-\").append(currency).append(\"#,##0.00\");\n        DecimalFormat fmt = new DecimalFormat(pat.toString(), sym);\n        String s = ((NumberFormat) fmt).format(1234.56);\n        pat = new StringBuffer();\n        logln(\"Pattern \\\"\" + fmt.toPattern() + \"\\\"\");\n        logln(\" Format \" + 1234.56 + \" . \" + s);\n        assertEquals(\"symbol, pos\", \"$1,234.56\", s);\n\n        s = ((NumberFormat) fmt).format(-1234.56);\n        logln(\" Format \" + Double.toString(-1234.56) + \" . \" + s);\n        assertEquals(\"symbol, neg\", \"-$1,234.56\", s);\n\n        pat.setLength(0);\n        // \"\\xA4\\xA4 #,##0.00;\\xA4\\xA4 -#,##0.00\"\n        pat.append(currency).append(currency).append(\" #,##0.00;\").append(currency).append(currency).append(\" -#,##0.00\");\n        fmt = new DecimalFormat(pat.toString(), sym);\n        s = ((NumberFormat) fmt).format(1234.56);\n        logln(\"Pattern \\\"\" + fmt.toPattern() + \"\\\"\");\n        logln(\" Format \" + Double.toString(1234.56) + \" . \" + s);\n        assertEquals(\"name, pos\", \"USD 1,234.56\", s);\n\n        s = ((NumberFormat) fmt).format(-1234.56);\n        logln(\" Format \" + Double.toString(-1234.56) + \" . \" + s);\n        assertEquals(\"name, neg\", \"USD -1,234.56\", s);\n    }\n\n    @Test\n    public void TestSpaceParsing() {\n        // the data are:\n        // the string to be parsed, parsed position, parsed error index\n        String[][] DATA = {\n                {\"$124\", \"4\", \"-1\"},\n                {\"$124 $124\", \"4\", \"-1\"},\n                {\"$124 \", \"4\", \"-1\"},\n                {\"$124  \", \"4\", \"-1\"},\n                {\"$ 124 \", \"5\", \"-1\"},\n                {\"$\\u00A0124 \", \"5\", \"-1\"},\n                {\" $ 124 \", \"6\", \"-1\"},\n                {\"124$\", \"4\", \"-1\"},\n                {\"124 $\", \"5\", \"-1\"},\n                {\"$124\\u200A\", \"4\", \"-1\"},\n                {\"$\\u200A124\", \"5\", \"-1\"},\n        };\n        NumberFormat foo = NumberFormat.getCurrencyInstance();\n        for (int i = 0; i < DATA.length; ++i) {\n            ParsePosition parsePosition = new ParsePosition(0);\n            String stringToBeParsed = DATA[i][0];\n            int parsedPosition = Integer.parseInt(DATA[i][1]);\n            int errorIndex = Integer.parseInt(DATA[i][2]);\n            try {\n                Number result = foo.parse(stringToBeParsed, parsePosition);\n                if (parsePosition.getIndex() != parsedPosition ||\n                        parsePosition.getErrorIndex() != errorIndex) {\n                    errln(\"FAILED parse \" + stringToBeParsed + \"; parse position: \" + parsePosition.getIndex() + \"; error position: \" + parsePosition.getErrorIndex());\n                }\n                if (parsePosition.getErrorIndex() == -1 &&\n                        result.doubleValue() != 124) {\n                    errln(\"FAILED parse \" + stringToBeParsed + \"; value \" + result.doubleValue());\n                }\n            } catch (Exception e) {\n                errln(\"FAILED \" + e.toString());\n            }\n        }\n    }\n\n    @Test\n    public void TestSpaceParsingStrict() {\n        // All trailing grouping separators should be ignored in strict mode, not just the first.\n        Object[][] cases = {\n                {\"123 \", 3, -1},\n                {\"123  \", 3, -1},\n                {\"123  ,\", 3, -1},\n                {\"123,\", 3, -1},\n                {\"123, \", 3, -1},\n                {\"123,,\", 3, -1},\n                {\"123,, \", 3, -1},\n                {\"123,,456\", 3, -1},\n                {\"123 ,\", 3, -1},\n                {\"123, \", 3, -1},\n                {\"123, 456\", 3, -1},\n                {\"123  456\", 3, -1}\n        };\n        DecimalFormat df = new DecimalFormat(\"#,###\");\n        df.setParseStrict(true);\n        for (Object[] cas : cases) {\n            String input = (String) cas[0];\n            int expectedIndex = (Integer) cas[1];\n            int expectedErrorIndex = (Integer) cas[2];\n            ParsePosition ppos = new ParsePosition(0);\n            df.parse(input, ppos);\n            assertEquals(\"Failed on index: '\" + input + \"'\", expectedIndex, ppos.getIndex());\n            assertEquals(\"Failed on error: '\" + input + \"'\", expectedErrorIndex, ppos.getErrorIndex());\n        }\n    }\n\n    @Test\n    public void TestMultiCurrencySign() {\n        String[][] DATA = {\n                // the fields in the following test are:\n                // locale,\n                // currency pattern (with negative pattern),\n                // currency number to be formatted,\n                // currency format using currency symbol name, such as \"$\" for USD,\n                // currency format using currency ISO name, such as \"USD\",\n                // currency format using plural name, such as \"US dollars\".\n                // for US locale\n                {\"en_US\", \"\\u00A4#,##0.00;-\\u00A4#,##0.00\", \"1234.56\", \"$1,234.56\", \"USD\u00a01,234.56\", \"US dollars\u00a01,234.56\"},\n                {\"en_US\", \"\\u00A4#,##0.00;-\\u00A4#,##0.00\", \"-1234.56\", \"-$1,234.56\", \"-USD\u00a01,234.56\", \"-US dollars\u00a01,234.56\"},\n                {\"en_US\", \"\\u00A4#,##0.00;-\\u00A4#,##0.00\", \"1\", \"$1.00\", \"USD\u00a01.00\", \"US dollars\u00a01.00\"},\n                // for CHINA locale\n                {\"zh_CN\", \"\\u00A4#,##0.00;(\\u00A4#,##0.00)\", \"1234.56\", \"\\uFFE51,234.56\", \"CNY\u00a01,234.56\", \"\\u4EBA\\u6C11\\u5E01\u00a01,234.56\"},\n                {\"zh_CN\", \"\\u00A4#,##0.00;(\\u00A4#,##0.00)\", \"-1234.56\", \"(\\uFFE51,234.56)\", \"(CNY\u00a01,234.56)\", \"(\\u4EBA\\u6C11\\u5E01\u00a01,234.56)\"},\n                {\"zh_CN\", \"\\u00A4#,##0.00;(\\u00A4#,##0.00)\", \"1\", \"\\uFFE51.00\", \"CNY\u00a01.00\", \"\\u4EBA\\u6C11\\u5E01\u00a01.00\"}\n        };\n\n        String doubleCurrencyStr = \"\\u00A4\\u00A4\";\n        String tripleCurrencyStr = \"\\u00A4\\u00A4\\u00A4\";\n\n        for (int i=0; i<DATA.length; ++i) {\n            String locale = DATA[i][0];\n            String pat = DATA[i][1];\n            Double numberToBeFormat = new Double(DATA[i][2]);\n            DecimalFormatSymbols sym = new DecimalFormatSymbols(new ULocale(locale));\n            for (int j=1; j<=3; ++j) {\n                // j represents the number of currency sign in the pattern.\n                if (j == 2) {\n                    pat = pat.replaceAll(\"\\u00A4\", doubleCurrencyStr);\n                } else if (j == 3) {\n                    pat = pat.replaceAll(\"\\u00A4\\u00A4\", tripleCurrencyStr);\n                }\n                DecimalFormat fmt = new DecimalFormat(pat, sym);\n                String s = ((NumberFormat) fmt).format(numberToBeFormat);\n                // DATA[i][3] is the currency format result using a\n                // single currency sign.\n                // DATA[i][4] is the currency format result using\n                // double currency sign.\n                // DATA[i][5] is the currency format result using\n                // triple currency sign.\n                // DATA[i][j+2] is the currency format result using\n                // 'j' number of currency sign.\n                String currencyFormatResult = DATA[i][2+j];\n                if (!s.equals(currencyFormatResult)) {\n                    errln(\"FAIL format: Expected \" + currencyFormatResult + \" but got \" + s);\n                }\n                try {\n                    // mix style parsing\n                    for (int k=3; k<=4; ++k) {\n                        // DATA[i][3] is the currency format result using a\n                        // single currency sign.\n                        // DATA[i][4] is the currency format result using\n                        // double currency sign.\n                        // DATA[i][5] is the currency format result using\n                        // triple currency sign.\n                        // ICU 59: long name parsing requires currency mode.\n                        String oneCurrencyFormat = DATA[i][k];\n                        if (fmt.parse(oneCurrencyFormat).doubleValue() !=\n                                numberToBeFormat.doubleValue()) {\n                            errln(\"FAILED parse \" + oneCurrencyFormat);\n                        }\n                    }\n                } catch (ParseException e) {\n                    errln(\"FAILED, DecimalFormat parse currency: \" + e.toString());\n                }\n            }\n        }\n    }\n\n    @Test\n    public void TestCurrencyFormatForMixParsing() {\n        MeasureFormat curFmt = MeasureFormat.getCurrencyFormat(new ULocale(\"en_US\"));\n        String[] formats = {\n                \"$1,234.56\",  // string to be parsed\n                \"USD1,234.56\",\n                \"US dollars1,234.56\",\n                \"1,234.56 US dollars\"\n        };\n        try {\n            for (int i = 0; i < formats.length; ++i) {\n                String stringToBeParsed = formats[i];\n                CurrencyAmount parsedVal = (CurrencyAmount)curFmt.parseObject(stringToBeParsed);\n                Number val = parsedVal.getNumber();\n                if (!val.equals(new BigDecimal(\"1234.56\"))) {\n                    errln(\"FAIL: getCurrencyFormat of default locale (en_US) failed roundtripping the number. val=\" + val);\n                }\n                if (!parsedVal.getCurrency().equals(Currency.getInstance(\"USD\"))) {\n                    errln(\"FAIL: getCurrencyFormat of default locale (en_US) failed roundtripping the currency\");\n                }\n            }\n        } catch (ParseException e) {\n            errln(\"parse FAILED: \" + e.toString());\n        }\n    }\n\n\n    /** Starting in ICU 62, strict mode is actually strict with currency formats. */\n    @Test\n    public void TestMismatchedCurrencyFormatFail() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getCurrencyInstance(ULocale.ENGLISH);\n        assertEquals(\"Test assumes that currency sign is at the beginning\",\n                \"\\u00A4#,##0.00\",\n                df.toPattern());\n        // Should round-trip on the correct currency format:\n        expect2(df, 1.23, \"\\u00A41.23\");\n        df.setCurrency(Currency.getInstance(\"EUR\"));\n        expect2(df, 1.23, \"\\u20AC1.23\");\n        // Should parse with currency in the wrong place in lenient mode\n        df.setParseStrict(false);\n        expect(df, \"1.23\\u20AC\", 1.23);\n        expectParseCurrency(df, Currency.getInstance(\"EUR\"), \"1.23\\u20AC\");\n        // Should NOT parse with currency in the wrong place in STRICT mode\n        df.setParseStrict(true);\n        {\n            ParsePosition ppos = new ParsePosition(0);\n            df.parse(\"1.23\\u20AC\", ppos);\n            assertEquals(\"Should fail to parse\", 0, ppos.getIndex());\n        }\n        {\n            ParsePosition ppos = new ParsePosition(0);\n            df.parseCurrency(\"1.23\\u20AC\", ppos);\n            assertEquals(\"Should fail to parse currency\", 0, ppos.getIndex());\n        }\n    }\n\n    @Test\n    public void TestDecimalFormatCurrencyParse() {\n        // Locale.US\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(Locale.US);\n        StringBuffer pat = new StringBuffer(\"\");\n        char currency = 0x00A4;\n        // \"\\xA4#,##0.00;-\\xA4#,##0.00\"\n        pat.append(currency).append(currency).append(currency).append(\"#,##0.00;-\").append(currency).append(currency).append(currency).append(\"#,##0.00\");\n        DecimalFormat fmt = new DecimalFormat(pat.toString(), sym);\n        String[][] DATA = {\n                // the data are:\n                // string to be parsed, the parsed result (number)\n                {\"$1.00\", \"1\"},\n                {\"USD1.00\", \"1\"},\n                {\"1.00 US dollar\", \"1\"},\n                {\"$1,234.56\", \"1234.56\"},\n                {\"USD1,234.56\", \"1234.56\"},\n                {\"1,234.56 US dollar\", \"1234.56\"},\n        };\n        try {\n            for (int i = 0; i < DATA.length; ++i) {\n                String stringToBeParsed = DATA[i][0];\n                double parsedResult = Double.parseDouble(DATA[i][1]);\n                Number num = fmt.parse(stringToBeParsed);\n                if (num.doubleValue() != parsedResult) {\n                    errln(\"FAIL parse: Expected \" + parsedResult);\n                }\n            }\n        } catch (ParseException e) {\n            errln(\"FAILED, DecimalFormat parse currency: \" + e.toString());\n        }\n    }\n\n    /**\n     * Test localized currency patterns.\n     */\n    @Test\n    public void TestCurrency() {\n        String[] DATA = {\n                \"fr\", \"CA\", \"\", \"1,50\\u00a0$\",\n                \"de\", \"DE\", \"\", \"1,50\\u00a0\\u20AC\",\n                \"de\", \"DE\", \"PREEURO\", \"1,50\\u00a0DM\",\n                \"fr\", \"FR\", \"\", \"1,50\\u00a0\\u20AC\",\n                \"fr\", \"FR\", \"PREEURO\", \"1,50\\u00a0F\",\n        };\n\n        for (int i=0; i<DATA.length; i+=4) {\n            Locale locale = new Locale(DATA[i], DATA[i+1], DATA[i+2]);\n            NumberFormat fmt = NumberFormat.getCurrencyInstance(locale);\n            String s = fmt.format(1.50);\n            if (s.equals(DATA[i+3])) {\n                logln(\"Ok: 1.50 x \" + locale + \" => \" + s);\n            } else {\n                logln(\"FAIL: 1.50 x \" + locale + \" => \" + s +\n                        \", expected \" + DATA[i+3]);\n            }\n        }\n\n        // format currency with CurrencyAmount\n        for (int i=0; i<DATA.length; i+=4) {\n            Locale locale = new Locale(DATA[i], DATA[i+1], DATA[i+2]);\n\n            Currency curr = Currency.getInstance(locale);\n            logln(\"\\nName of the currency is: \" + curr.getName(locale, Currency.LONG_NAME, new boolean[] {false}));\n            CurrencyAmount cAmt = new CurrencyAmount(1.5, curr);\n            logln(\"CurrencyAmount object's hashCode is: \" + cAmt.hashCode()); //cover hashCode\n\n            NumberFormat fmt = NumberFormat.getCurrencyInstance(locale);\n            String sCurr = fmt.format(cAmt);\n            if (sCurr.equals(DATA[i+3])) {\n                logln(\"Ok: 1.50 x \" + locale + \" => \" + sCurr);\n            } else {\n                errln(\"FAIL: 1.50 x \" + locale + \" => \" + sCurr +\n                        \", expected \" + DATA[i+3]);\n            }\n        }\n\n        //Cover MeasureFormat.getCurrencyFormat()\n        ULocale save = ULocale.getDefault();\n        ULocale.setDefault(ULocale.US);\n        MeasureFormat curFmt = MeasureFormat.getCurrencyFormat();\n        String strBuf = curFmt.format(new CurrencyAmount(new Float(1234.56), Currency.getInstance(\"USD\")));\n\n        try {\n            CurrencyAmount parsedVal = (CurrencyAmount)curFmt.parseObject(strBuf);\n            Number val = parsedVal.getNumber();\n            if (!val.equals(new BigDecimal(\"1234.56\"))) {\n                errln(\"FAIL: getCurrencyFormat of default locale (en_US) failed roundtripping the number. val=\" + val);\n            }\n            if (!parsedVal.getCurrency().equals(Currency.getInstance(\"USD\"))) {\n                errln(\"FAIL: getCurrencyFormat of default locale (en_US) failed roundtripping the currency\");\n            }\n        }\n        catch (ParseException e) {\n            errln(\"FAIL: \" + e.getMessage());\n        }\n        ULocale.setDefault(save);\n    }\n\n    @Test\n    public void TestJavaCurrencyConversion() {\n        java.util.Currency gbpJava = java.util.Currency.getInstance(\"GBP\");\n        Currency gbpIcu = Currency.getInstance(\"GBP\");\n        assertEquals(\"ICU should equal API value\", gbpIcu, Currency.fromJavaCurrency(gbpJava));\n        assertEquals(\"Java should equal API value\", gbpJava, gbpIcu.toJavaCurrency());\n        // Test CurrencyAmount constructors\n        CurrencyAmount ca1 = new CurrencyAmount(123.45, gbpJava);\n        CurrencyAmount ca2 = new CurrencyAmount(123.45, gbpIcu);\n        assertEquals(\"CurrencyAmount from both Double constructors should be equal\", ca1, ca2);\n        // Coverage for the Number constructor\n        ca1 = new CurrencyAmount(new BigDecimal(\"543.21\"), gbpJava);\n        ca2 = new CurrencyAmount(new BigDecimal(\"543.21\"), gbpIcu);\n        assertEquals(\"CurrencyAmount from both Number constructors should be equal\", ca1, ca2);\n    }\n\n    @Test\n    public void TestCurrencyIsoPluralFormat() {\n        String[][] DATA = {\n                // the data are:\n                // locale,\n                // currency amount to be formatted,\n                // currency ISO code to be formatted,\n                // format result using CURRENCYSTYLE,\n                // format result using ISOCURRENCYSTYLE,\n                // format result using PLURALCURRENCYSTYLE,\n                {\"en_US\", \"1\", \"USD\", \"$1.00\", \"USD\u00a01.00\", \"1.00 US dollars\"},\n                {\"en_US\", \"1234.56\", \"USD\", \"$1,234.56\", \"USD\u00a01,234.56\", \"1,234.56 US dollars\"},\n                {\"en_US\", \"-1234.56\", \"USD\", \"-$1,234.56\", \"-USD\u00a01,234.56\", \"-1,234.56 US dollars\"},\n                {\"zh_CN\", \"1\", \"USD\", \"US$1.00\", \"USD\u00a01.00\", \"1.00\u00a0\u7f8e\u5143\"},\n                {\"zh_CN\", \"1234.56\", \"USD\", \"US$1,234.56\", \"USD\u00a01,234.56\", \"1,234.56\u00a0\u7f8e\u5143\"},\n                {\"zh_CN\", \"1\", \"CNY\", \"\uffe51.00\", \"CNY\u00a01.00\", \"1.00\u00a0\u4eba\u6c11\u5e01\"},\n                {\"zh_CN\", \"1234.56\", \"CNY\", \"\uffe51,234.56\", \"CNY\u00a01,234.56\", \"1,234.56\u00a0\u4eba\u6c11\u5e01\"},\n                {\"ru_RU\", \"1\", \"RUB\", \"1,00\u00a0\\u20BD\", \"1,00\u00a0RUB\", \"1,00 \u0440\u043e\u0441\u0441\u0438\u0439\u0441\u043a\u043e\u0433\u043e \u0440\u0443\u0431\u043b\u044f\"},\n                {\"ru_RU\", \"2\", \"RUB\", \"2,00\u00a0\\u20BD\", \"2,00\u00a0RUB\", \"2,00 \u0440\u043e\u0441\u0441\u0438\u0439\u0441\u043a\u043e\u0433\u043e \u0440\u0443\u0431\u043b\u044f\"},\n                {\"ru_RU\", \"5\", \"RUB\", \"5,00\u00a0\\u20BD\", \"5,00\u00a0RUB\", \"5,00 \u0440\u043e\u0441\u0441\u0438\u0439\u0441\u043a\u043e\u0433\u043e \u0440\u0443\u0431\u043b\u044f\"},\n                // test locale without currency information\n                {\"root\", \"-1.23\", \"USD\", \"-US$\u00a01.23\", \"-USD\u00a01.23\", \"-1.23 USD\"},\n                {\"root@numbers=latn\", \"-1.23\", \"USD\", \"-US$\u00a01.23\", \"-USD\u00a01.23\", \"-1.23 USD\"}, // ensure that the root locale is still used with modifiers\n                {\"root@numbers=arab\", \"-1.23\", \"USD\", \"\\u061C-\\u0661\\u066B\\u0662\\u0663\\u00A0US$\", \"\\u061C-\\u0661\\u066B\\u0662\\u0663\\u00A0USD\", \"\\u061C-\\u0661\\u066B\\u0662\\u0663 USD\"}, // ensure that the root locale is still used with modifiers\n                {\"es_AR\", \"1\", \"INR\", \"INR\\u00A01,00\", \"INR\\u00A01,00\", \"1,00 rupia india\"},\n                {\"ar_EG\", \"1\", \"USD\", \"\u0661\u066b\u0660\u0660\\u00A0US$\", \"\u0661\u066b\u0660\u0660\\u00A0USD\", \"\u0661\u066b\u0660\u0660 \u062f\u0648\u0644\u0627\u0631 \u0623\u0645\u0631\u064a\u0643\u064a\"},\n        };\n\n        for (int i=0; i<DATA.length; ++i) {\n            for (int k = NumberFormat.CURRENCYSTYLE;\n                    k <= NumberFormat.PLURALCURRENCYSTYLE;\n                    ++k) {\n                // k represents currency format style.\n                if ( k != NumberFormat.CURRENCYSTYLE &&\n                        k != NumberFormat.ISOCURRENCYSTYLE &&\n                        k != NumberFormat.PLURALCURRENCYSTYLE ) {\n                    continue;\n                }\n                String localeString = DATA[i][0];\n                Double numberToBeFormat = new Double(DATA[i][1]);\n                String currencyISOCode = DATA[i][2];\n                ULocale locale = new ULocale(localeString);\n                NumberFormat numFmt = NumberFormat.getInstance(locale, k);\n                numFmt.setCurrency(Currency.getInstance(currencyISOCode));\n                String strBuf = numFmt.format(numberToBeFormat);\n                int resultDataIndex = k-1;\n                if ( k == NumberFormat.CURRENCYSTYLE ) {\n                    resultDataIndex = k+2;\n                }\n                // DATA[i][resultDataIndex] is the currency format result\n                // using 'k' currency style.\n                String formatResult = DATA[i][resultDataIndex];\n                if (!strBuf.equals(formatResult)) {\n                    errln(\"FAIL: localeID: \" + localeString + \", expected(\" + formatResult.length() + \"): \\\"\" + formatResult + \"\\\", actual(\" + strBuf.length() + \"): \\\"\" + strBuf + \"\\\"\");\n                }\n                // test parsing, and test parsing for all currency formats.\n                for (int j = 3; j < 6; ++j) {\n                    // DATA[i][3] is the currency format result using\n                    // CURRENCYSTYLE formatter.\n                    // DATA[i][4] is the currency format result using\n                    // ISOCURRENCYSTYLE formatter.\n                    // DATA[i][5] is the currency format result using\n                    // PLURALCURRENCYSTYLE formatter.\n                    String oneCurrencyFormatResult = DATA[i][j];\n                    CurrencyAmount val = numFmt.parseCurrency(oneCurrencyFormatResult, null);\n                    if (val.getNumber().doubleValue() != numberToBeFormat.doubleValue()) {\n                        errln(\"FAIL: getCurrencyFormat of locale \" + localeString + \" failed roundtripping the number. val=\" + val + \"; expected: \" + numberToBeFormat);\n                    }\n                }\n            }\n        }\n    }\n\n\n    @Test\n    public void TestMiscCurrencyParsing() {\n        String[][] DATA = {\n                // each has: string to be parsed, parsed position, error position\n                {\"1.00 \", \"4\", \"-1\", \"0\", \"4\"},\n                {\"1.00 UAE dirha\", \"4\", \"-1\", \"0\", \"4\"},\n                {\"1.00 us dollar\", \"14\", \"-1\", \"14\", \"-1\"},\n                {\"1.00 US DOLLAR\", \"14\", \"-1\", \"14\", \"-1\"},\n                {\"1.00 usd\", \"8\", \"-1\", \"8\", \"-1\"},\n                {\"1.00 USD\", \"8\", \"-1\", \"8\", \"-1\"},\n        };\n        ULocale locale = new ULocale(\"en_US\");\n        for (int i=0; i<DATA.length; ++i) {\n            String stringToBeParsed = DATA[i][0];\n            int parsedPosition = Integer.parseInt(DATA[i][1]);\n            int errorIndex = Integer.parseInt(DATA[i][2]);\n            int currParsedPosition = Integer.parseInt(DATA[i][3]);\n            int currErrorIndex = Integer.parseInt(DATA[i][4]);\n            NumberFormat numFmt = NumberFormat.getInstance(locale, NumberFormat.CURRENCYSTYLE);\n            ParsePosition parsePosition = new ParsePosition(0);\n            Number val = numFmt.parse(stringToBeParsed, parsePosition);\n            if (parsePosition.getIndex() != parsedPosition ||\n                    parsePosition.getErrorIndex() != errorIndex) {\n                errln(\"FAIL: parse failed on case \"+i+\". expected position: \" + parsedPosition +\"; actual: \" + parsePosition.getIndex());\n                errln(\"FAIL: parse failed on case \"+i+\". expected error position: \" + errorIndex + \"; actual: \" + parsePosition.getErrorIndex());\n            }\n            if (parsePosition.getErrorIndex() == -1 &&\n                    val.doubleValue() != 1.00) {\n                errln(\"FAIL: parse failed. expected 1.00, actual:\" + val);\n            }\n            parsePosition = new ParsePosition(0);\n            CurrencyAmount amt = numFmt.parseCurrency(stringToBeParsed, parsePosition);\n            if (parsePosition.getIndex() != currParsedPosition ||\n                    parsePosition.getErrorIndex() != currErrorIndex) {\n                errln(\"FAIL: parseCurrency failed on case \"+i+\". expected error position: \" + currErrorIndex + \"; actual: \" + parsePosition.getErrorIndex());\n                errln(\"FAIL: parseCurrency failed on case \"+i+\". expected position: \" + currParsedPosition +\"; actual: \" + parsePosition.getIndex());\n            }\n            if (parsePosition.getErrorIndex() == -1 &&\n                    amt.getNumber().doubleValue() != 1.00) {\n                errln(\"FAIL: parseCurrency failed. expected 1.00, actual:\" + val);\n            }\n        }\n    }\n\n    @Test\n    public void TestParseCurrency() {\n        class ParseCurrencyItem {\n            private final String localeString;\n            private final String descrip;\n            private final String currStr;\n            private final int    doubExpectPos;\n            private final int    doubExpectVal;\n            private final int    curExpectPos;\n            private final int    curExpectVal;\n            private final String curExpectCurr;\n\n            ParseCurrencyItem(String locStr, String desc, String curr, int doubExPos, int doubExVal, int curExPos, int curExVal, String curExCurr) {\n                localeString  = locStr;\n                descrip       = desc;\n                currStr       = curr;\n                doubExpectPos  = doubExPos;\n                doubExpectVal  = doubExVal;\n                curExpectPos  = curExPos;\n                curExpectVal  = curExVal;\n                curExpectCurr = curExCurr;\n            }\n            public String getLocaleString()  { return localeString; }\n            public String getDescrip()       { return descrip; }\n            public String getCurrStr()       { return currStr; }\n            public int    getDoubExpectPos()  { return doubExpectPos; }\n            public int    getDoubExpectVal()  { return doubExpectVal; }\n            public int    getCurExpectPos()  { return curExpectPos; }\n            public int    getCurExpectVal()  { return curExpectVal; }\n            public String getCurExpectCurr() { return curExpectCurr; }\n        }\n        // Note: In cases where the number occurs before the currency sign, non-currency mode will parse the number\n        // and stop when it reaches the currency symbol.\n        final ParseCurrencyItem[] parseCurrencyItems = {\n                new ParseCurrencyItem( \"en_US\", \"dollars2\", \"$2.00\",            5,  2,  5,  2,  \"USD\" ),\n                new ParseCurrencyItem( \"en_US\", \"dollars4\", \"$4\",               2,  4,  2,  4,  \"USD\" ),\n                new ParseCurrencyItem( \"en_US\", \"dollars9\", \"9\\u00A0$\",         3,  9,  3,  9,  \"USD\" ),\n                new ParseCurrencyItem( \"en_US\", \"pounds3\",  \"\\u00A33.00\",       0,  0,  5,  3,  \"GBP\" ),\n                new ParseCurrencyItem( \"en_US\", \"pounds5\",  \"\\u00A35\",          0,  0,  2,  5,  \"GBP\" ),\n                new ParseCurrencyItem( \"en_US\", \"pounds7\",  \"7\\u00A0\\u00A3\",    1,  7,  3,  7,  \"GBP\" ),\n                new ParseCurrencyItem( \"en_US\", \"euros8\",   \"\\u20AC8\",          0,  0,  2,  8,  \"EUR\" ),\n\n                new ParseCurrencyItem( \"en_GB\", \"pounds3\",  \"\\u00A33.00\",       5,  3,  5,  3,  \"GBP\" ),\n                new ParseCurrencyItem( \"en_GB\", \"pounds5\",  \"\\u00A35\",          2,  5,  2,  5,  \"GBP\" ),\n                new ParseCurrencyItem( \"en_GB\", \"pounds7\",  \"7\\u00A0\\u00A3\",    3,  7,  3,  7,  \"GBP\" ),\n                new ParseCurrencyItem( \"en_GB\", \"euros4\",   \"4,00\\u00A0\\u20AC\", 4,400,  6,400,  \"EUR\" ),\n                new ParseCurrencyItem( \"en_GB\", \"euros6\",   \"6\\u00A0\\u20AC\",    1,  6,  3,  6,  \"EUR\" ),\n                new ParseCurrencyItem( \"en_GB\", \"euros8\",   \"\\u20AC8\",          0,  0,  2,  8,  \"EUR\" ),\n                new ParseCurrencyItem( \"en_GB\", \"dollars4\", \"US$4\",             0,  0,  4,  4,  \"USD\" ),\n\n                new ParseCurrencyItem( \"fr_FR\", \"euros4\",   \"4,00\\u00A0\\u20AC\", 6,  4,  6,  4,  \"EUR\" ),\n                new ParseCurrencyItem( \"fr_FR\", \"euros6\",   \"6\\u00A0\\u20AC\",    3,  6,  3,  6,  \"EUR\" ),\n                new ParseCurrencyItem( \"fr_FR\", \"euros8\",   \"\\u20AC8\",          2,  8,  2,  8,  \"EUR\" ),\n                new ParseCurrencyItem( \"fr_FR\", \"dollars2\", \"$2.00\",            0,  0,  0,  0,  \"\"    ),\n                new ParseCurrencyItem( \"fr_FR\", \"dollars4\", \"$4\",               0,  0,  0,  0,  \"\"    ),\n        };\n        for (ParseCurrencyItem item: parseCurrencyItems) {\n            String localeString = item.getLocaleString();\n            ULocale uloc = new ULocale(localeString);\n            NumberFormat fmt = null;\n            try {\n                fmt = NumberFormat.getCurrencyInstance(uloc);\n            } catch (Exception e) {\n                errln(\"NumberFormat.getCurrencyInstance fails for locale \" + localeString);\n                continue;\n            }\n            String currStr = item.getCurrStr();\n            ParsePosition parsePos = new ParsePosition(0);\n\n            Number numVal = fmt.parse(currStr, parsePos);\n            if ( parsePos.getIndex() != item.getDoubExpectPos() || (numVal != null && numVal.intValue() != item.getDoubExpectVal()) ) {\n                if (numVal != null) {\n                    errln(\"NumberFormat.getCurrencyInstance parse \" + localeString + \"/\" + item.getDescrip() +\n                            \", expect pos/val \" + item.getDoubExpectPos() + \"/\" + item.getDoubExpectVal() +\n                            \", get \" + parsePos.getIndex() + \"/\" + numVal.intValue() );\n                } else {\n                    errln(\"NumberFormat.getCurrencyInstance parse \" + localeString + \"/\" + item.getDescrip() +\n                            \", expect pos/val \" + item.getDoubExpectPos() + \"/\" + item.getDoubExpectVal() +\n                            \", get \" + parsePos.getIndex() + \"/(NULL)\" );\n                }\n            }\n\n            parsePos.setIndex(0);\n            int curExpectPos = item.getCurExpectPos();\n            CurrencyAmount currAmt = fmt.parseCurrency(currStr, parsePos);\n            if ( parsePos.getIndex() != curExpectPos || (currAmt != null && (currAmt.getNumber().intValue() != item.getCurExpectVal() ||\n                    currAmt.getCurrency().getCurrencyCode().compareTo(item.getCurExpectCurr()) != 0)) ) {\n                if (currAmt != null) {\n                    errln(\"NumberFormat.getCurrencyInstance parseCurrency \" + localeString + \"/\" + item.getDescrip() +\n                            \", expect pos/val/curr \" + curExpectPos + \"/\" + item.getCurExpectVal() + \"/\" + item.getCurExpectCurr() +\n                            \", get \" + parsePos.getIndex() + \"/\" + currAmt.getNumber().intValue() + \"/\" + currAmt.getCurrency().getCurrencyCode() );\n                } else {\n                    errln(\"NumberFormat.getCurrencyInstance parseCurrency \" + localeString + \"/\" + item.getDescrip() +\n                            \", expect pos/val/curr \" + curExpectPos + \"/\" + item.getCurExpectVal() + \"/\" + item.getCurExpectCurr() +\n                            \", get \" + parsePos.getIndex() + \"/(NULL)\" );\n                }\n            }\n        }\n    }\n\n    @Test\n    public void TestParseCurrencyWithWhitespace() {\n        DecimalFormat df = new DecimalFormat(\"#,##0.00 \u00a4\u00a4\");\n        ParsePosition ppos = new ParsePosition(0);\n        df.parseCurrency(\"1.00 us denmark\", ppos);\n        assertEquals(\"Expected to fail on 'us denmark' string\", 4, ppos.getErrorIndex());\n    }\n\n    @Test\n    public void TestParseCurrPatternWithDecStyle() {\n        String currpat = \"\u00a4#,##0.00\";\n        String parsetxt = \"x0y$\";\n        DecimalFormat decfmt = (DecimalFormat)NumberFormat.getInstance(new ULocale(\"en_US\"), NumberFormat.NUMBERSTYLE);\n        decfmt.applyPattern(currpat);\n        ParsePosition ppos = new ParsePosition(0);\n        Number value = decfmt.parse(parsetxt, ppos);\n        if (ppos.getIndex() != 0) {\n            errln(\"DecimalFormat.parse expected to fail but got ppos \" + ppos.getIndex() + \", value \" + value);\n        }\n    }\n\n    /**\n     * Test the Currency object handling, new as of ICU 2.2.\n     */\n    @Test\n    public void TestCurrencyObject() {\n        NumberFormat fmt =\n                NumberFormat.getCurrencyInstance(Locale.US);\n\n        expectCurrency(fmt, null, 1234.56, \"$1,234.56\");\n\n        expectCurrency(fmt, Currency.getInstance(Locale.FRANCE),\n                1234.56, \"\\u20AC1,234.56\"); // Euro\n\n        expectCurrency(fmt, Currency.getInstance(Locale.JAPAN),\n                1234.56, \"\\u00A51,235\"); // Yen\n\n        expectCurrency(fmt, Currency.getInstance(new Locale(\"fr\", \"CH\", \"\")),\n                1234.56, \"CHF 1,234.56\"); // no more 0.05 rounding here, see cldrbug 5548\n\n        expectCurrency(fmt, Currency.getInstance(Locale.US),\n                1234.56, \"$1,234.56\");\n\n        fmt = NumberFormat.getCurrencyInstance(Locale.FRANCE);\n\n        expectCurrency(fmt, null, 1234.56, \"1\\u202F234,56 \\u20AC\");\n\n        expectCurrency(fmt, Currency.getInstance(Locale.JAPAN),\n                1234.56, \"1\\u202F235 JPY\"); // Yen\n\n        expectCurrency(fmt, Currency.getInstance(new Locale(\"fr\", \"CH\", \"\")),\n                1234.56, \"1\\u202F234,56 CHF\"); // no more rounding here, see cldrbug 5548\n\n        expectCurrency(fmt, Currency.getInstance(Locale.US),\n                1234.56, \"1\\u202F234,56 $US\");\n\n        expectCurrency(fmt, Currency.getInstance(Locale.FRANCE),\n                1234.56, \"1\\u202F234,56 \\u20AC\"); // Euro\n    }\n\n    @Test\n    public void TestCompatibleCurrencies() {\n        NumberFormat fmt =\n                NumberFormat.getCurrencyInstance(Locale.US);\n        expectParseCurrency(fmt, Currency.getInstance(Locale.JAPAN), \"\\u00A51,235\"); // Yen half-width\n        expectParseCurrency(fmt, Currency.getInstance(Locale.JAPAN), \"\\uFFE51,235\"); // Yen full-wdith\n    }\n\n    @Test\n    public void TestCurrencyPatterns() {\n        int i;\n        Random rnd = new Random(2017);\n        Locale[] locs = NumberFormat.getAvailableLocales();\n        for (i=0; i<locs.length; ++i) {\n            if (rnd.nextDouble() < 0.9) {\n                // Check a random subset for speed:\n                // Otherwise, this test takes a large fraction of the entire time.\n                continue;\n            }\n            NumberFormat nf = NumberFormat.getCurrencyInstance(locs[i]);\n            // Make sure currency formats do not have a variable number\n            // of fraction digits\n            int min = nf.getMinimumFractionDigits();\n            int max = nf.getMaximumFractionDigits();\n            if (min != max) {\n                String a = nf.format(1.0);\n                String b = nf.format(1.125);\n                errln(\"FAIL: \" + locs[i] +\n                        \" min fraction digits != max fraction digits; \"+\n                        \"x 1.0 => \" + a +\n                        \"; x 1.125 => \" + b);\n            }\n\n            // Make sure EURO currency formats have exactly 2 fraction digits\n            if (nf instanceof DecimalFormat) {\n                Currency curr = ((DecimalFormat) nf).getCurrency();\n                if (curr != null && \"EUR\".equals(curr.getCurrencyCode())) {\n                    if (min != 2 || max != 2) {\n                        String a = nf.format(1.0);\n                        errln(\"FAIL: \" + locs[i] +\n                                \" is a EURO format but it does not have 2 fraction digits; \"+\n                                \"x 1.0 => \" +\n                                a);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Do rudimentary testing of parsing.\n     */\n    @Test\n    public void TestParse() {\n        String arg = \"0.0\";\n        DecimalFormat format = new DecimalFormat(\"00\");\n        double aNumber = 0l;\n        try {\n            aNumber = format.parse(arg).doubleValue();\n        } catch (ParseException e) {\n            System.out.println(e);\n        }\n        logln(\"parse(\" + arg + \") = \" + aNumber);\n    }\n\n    /**\n     * Test proper rounding by the format method.\n     */\n    @Test\n    public void TestRounding487() {\n\n        NumberFormat nf = NumberFormat.getInstance();\n        roundingTest(nf, 0.00159999, 4, \"0.0016\");\n        roundingTest(nf, 0.00995, 4, \"0.01\");\n\n        roundingTest(nf, 12.3995, 3, \"12.4\");\n\n        roundingTest(nf, 12.4999, 0, \"12\");\n        roundingTest(nf, - 19.5, 0, \"-20\");\n\n    }\n\n    /**\n     * Test the functioning of the secondary grouping value.\n     */\n    @Test\n    public void TestSecondaryGrouping() {\n\n        DecimalFormatSymbols US = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat f = new DecimalFormat(\"#,##,###\", US);\n\n        expect(f, 123456789L, \"12,34,56,789\");\n        expectPat(f, \"#,##,##0\");\n        f.applyPattern(\"#,###\");\n\n        f.setSecondaryGroupingSize(4);\n        expect(f, 123456789L, \"12,3456,789\");\n        expectPat(f, \"#,####,##0\");\n        NumberFormat g = NumberFormat.getInstance(new Locale(\"hi\", \"IN\"));\n\n        String out = \"\";\n        long l = 1876543210L;\n        out = g.format(l);\n\n        // expect \"1,87,65,43,210\", but with Hindi digits\n        //         01234567890123\n        boolean ok = true;\n        if (out.length() != 14) {\n            ok = false;\n        } else {\n            for (int i = 0; i < out.length(); ++i) {\n                boolean expectGroup = false;\n                switch (i) {\n                case 1 :\n                case 4 :\n                case 7 :\n                case 10 :\n                    expectGroup = true;\n                    break;\n                }\n                // Later -- fix this to get the actual grouping\n                // character from the resource bundle.\n                boolean isGroup = (out.charAt(i) == 0x002C);\n                if (isGroup != expectGroup) {\n                    ok = false;\n                    break;\n                }\n            }\n        }\n        if (!ok) {\n            errln(\"FAIL  Expected \"+ l + \" x hi_IN . \\\"1,87,65,43,210\\\" (with Hindi digits), got \\\"\"\n                    + out + \"\\\"\");\n        } else {\n            logln(\"Ok    \" + l + \" x hi_IN . \\\"\" + out + \"\\\"\");\n        }\n    }\n\n    /*\n     * Internal test utility.\n     */\n    private void roundingTest(NumberFormat nf, double x, int maxFractionDigits, final String expected) {\n        nf.setMaximumFractionDigits(maxFractionDigits);\n        String out = nf.format(x);\n        logln(x + \" formats with \" + maxFractionDigits + \" fractional digits to \" + out);\n        if (!out.equals(expected))\n            errln(\"FAIL: Expected \" + expected);\n    }\n\n    /**\n     * Upgrade to alphaWorks\n     */\n    @Test\n    public void TestExponent() {\n        DecimalFormatSymbols US = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat fmt1 = new DecimalFormat(\"0.###E0\", US);\n        DecimalFormat fmt2 = new DecimalFormat(\"0.###E+0\", US);\n        int n = 1234;\n        expect2(fmt1, n, \"1.234E3\");\n        expect2(fmt2, n, \"1.234E+3\");\n        expect(fmt1, \"1.234E+3\", n); // Either format should parse \"E+3\"\n\n    }\n\n    /**\n     * Upgrade to alphaWorks\n     */\n    @Test\n    public void TestScientific() {\n\n        DecimalFormatSymbols US = new DecimalFormatSymbols(Locale.US);\n\n        // Test pattern round-trip\n        final String PAT[] = { \"#E0\", \"0.####E0\", \"00.000E00\", \"##0.####E000\", \"0.###E0;[0.###E0]\" };\n        int PAT_length = PAT.length;\n        int DIGITS[] = {\n                // min int, max int, min frac, max frac\n                0, 1, 0, 0, // \"#E0\"\n                1, 1, 0, 4, // \"0.####E0\"\n                2, 2, 3, 3, // \"00.000E00\"\n                1, 3, 0, 4, // \"##0.####E000\"\n                1, 1, 0, 3, // \"0.###E0;[0.###E0]\"\n        };\n        for (int i = 0; i < PAT_length; ++i) {\n            String pat = PAT[i];\n            DecimalFormat df = new DecimalFormat(pat, US);\n            String pat2 = df.toPattern();\n            if (pat.equals(pat2)) {\n                logln(\"Ok   Pattern rt \\\"\" + pat + \"\\\" . \\\"\" + pat2 + \"\\\"\");\n            } else {\n                errln(\"FAIL Pattern rt \\\"\" + pat + \"\\\" . \\\"\" + pat2 + \"\\\"\");\n            }\n            // Make sure digit counts match what we expect\n            if (i == 0) continue; // outputs to 1,1,0,0 since at least one min digit is required.\n            if (df.getMinimumIntegerDigits() != DIGITS[4 * i]\n                    || df.getMaximumIntegerDigits() != DIGITS[4 * i + 1]\n                            || df.getMinimumFractionDigits() != DIGITS[4 * i + 2]\n                                    || df.getMaximumFractionDigits() != DIGITS[4 * i + 3]) {\n                errln(\"FAIL \\\"\"+ pat+ \"\\\" min/max int; min/max frac = \"\n                        + df.getMinimumIntegerDigits() + \"/\"\n                        + df.getMaximumIntegerDigits() + \";\"\n                        + df.getMinimumFractionDigits() + \"/\"\n                        + df.getMaximumFractionDigits() + \", expect \"\n                        + DIGITS[4 * i] + \"/\"\n                        + DIGITS[4 * i + 1] + \";\"\n                        + DIGITS[4 * i + 2] + \"/\"\n                        + DIGITS[4 * i + 3]);\n            }\n        }\n\n        expect2(new DecimalFormat(\"#E0\", US), 12345.0, \"1.2345E4\");\n        expect(new DecimalFormat(\"0E0\", US), 12345.0, \"1E4\");\n\n        // pattern of NumberFormat.getScientificInstance(Locale.US) = \"0.######E0\" not \"#E0\"\n        // so result = 1.234568E4 not 1.2345678901E4\n        //when the pattern problem is finalized, delete comment mark'//'\n        //of the following code\n        expect2(NumberFormat.getScientificInstance(Locale.US), 12345.678901, \"1.2345678901E4\");\n        logln(\"Testing NumberFormat.getScientificInstance(ULocale) ...\");\n        expect2(NumberFormat.getScientificInstance(ULocale.US), 12345.678901, \"1.2345678901E4\");\n\n        expect(new DecimalFormat(\"##0.###E0\", US), 12345.0, \"12.34E3\");\n        expect(new DecimalFormat(\"##0.###E0\", US), 12345.00001, \"12.35E3\");\n        expect2(new DecimalFormat(\"##0.####E0\", US), 12345, \"12.345E3\");\n\n        // pattern of NumberFormat.getScientificInstance(Locale.US) = \"0.######E0\" not \"#E0\"\n        // so result = 1.234568E4 not 1.2345678901E4\n        expect2(NumberFormat.getScientificInstance(Locale.FRANCE), 12345.678901, \"1,2345678901E4\");\n        logln(\"Testing NumberFormat.getScientificInstance(ULocale) ...\");\n        expect2(NumberFormat.getScientificInstance(ULocale.FRANCE), 12345.678901, \"1,2345678901E4\");\n\n        expect(new DecimalFormat(\"##0.####E0\", US), 789.12345e-9, \"789.12E-9\");\n        expect2(new DecimalFormat(\"##0.####E0\", US), 780.e-9, \"780E-9\");\n        expect(new DecimalFormat(\".###E0\", US), 45678.0, \".457E5\");\n        expect2(new DecimalFormat(\".###E0\", US), 0, \".0E0\");\n        /*\n        expect(new DecimalFormat[] { new DecimalFormat(\"#E0\", US),\n                                     new DecimalFormat(\"##E0\", US),\n                                     new DecimalFormat(\"####E0\", US),\n                                     new DecimalFormat(\"0E0\", US),\n                                     new DecimalFormat(\"00E0\", US),\n                                     new DecimalFormat(\"000E0\", US),\n                                   },\n               new Long(45678000),\n               new String[] { \"4.5678E7\",\n                              \"45.678E6\",\n                              \"4567.8E4\",\n                              \"5E7\",\n                              \"46E6\",\n                              \"457E5\",\n                            }\n               );\n        !\n        ! Unroll this test into individual tests below...\n        !\n         */\n        expect2(new DecimalFormat(\"#E0\", US), 45678000, \"4.5678E7\");\n        expect2(new DecimalFormat(\"##E0\", US), 45678000, \"45.678E6\");\n        expect2(new DecimalFormat(\"####E0\", US), 45678000, \"4567.8E4\");\n        expect(new DecimalFormat(\"0E0\", US), 45678000, \"5E7\");\n        expect(new DecimalFormat(\"00E0\", US), 45678000, \"46E6\");\n        expect(new DecimalFormat(\"000E0\", US), 45678000, \"457E5\");\n        /*\n        expect(new DecimalFormat(\"###E0\", US, status),\n               new Object[] { new Double(0.0000123), \"12.3E-6\",\n                              new Double(0.000123), \"123E-6\",\n                              new Double(0.00123), \"1.23E-3\",\n                              new Double(0.0123), \"12.3E-3\",\n                              new Double(0.123), \"123E-3\",\n                              new Double(1.23), \"1.23E0\",\n                              new Double(12.3), \"12.3E0\",\n                              new Double(123), \"123E0\",\n                              new Double(1230), \"1.23E3\",\n                             });\n        !\n        ! Unroll this test into individual tests below...\n        !\n         */\n        expect2(new DecimalFormat(\"###E0\", US), 0.0000123, \"12.3E-6\");\n        expect2(new DecimalFormat(\"###E0\", US), 0.000123, \"123E-6\");\n        expect2(new DecimalFormat(\"###E0\", US), 0.00123, \"1.23E-3\");\n        expect2(new DecimalFormat(\"###E0\", US), 0.0123, \"12.3E-3\");\n        expect2(new DecimalFormat(\"###E0\", US), 0.123, \"123E-3\");\n        expect2(new DecimalFormat(\"###E0\", US), 1.23, \"1.23E0\");\n        expect2(new DecimalFormat(\"###E0\", US), 12.3, \"12.3E0\");\n        expect2(new DecimalFormat(\"###E0\", US), 123.0, \"123E0\");\n        expect2(new DecimalFormat(\"###E0\", US), 1230.0, \"1.23E3\");\n        /*\n        expect(new DecimalFormat(\"0.#E+00\", US, status),\n               new Object[] { new Double(0.00012), \"1.2E-04\",\n                              new Long(12000),     \"1.2E+04\",\n                             });\n        !\n        ! Unroll this test into individual tests below...\n        !\n         */\n        expect2(new DecimalFormat(\"0.#E+00\", US), 0.00012, \"1.2E-04\");\n        expect2(new DecimalFormat(\"0.#E+00\", US), 12000, \"1.2E+04\");\n    }\n\n    /**\n     * Upgrade to alphaWorks\n     */\n    @Test\n    public void TestPad() {\n\n        DecimalFormatSymbols US = new DecimalFormatSymbols(Locale.US);\n        expect2(new DecimalFormat(\"*^##.##\", US), 0, \"^^^^0\");\n        expect2(new DecimalFormat(\"*^##.##\", US), -1.3, \"^-1.3\");\n        expect2(\n                new DecimalFormat(\"##0.0####E0*_ 'g-m/s^2'\", US),\n                0,\n                \"0.0E0______ g-m/s^2\");\n        expect(\n                new DecimalFormat(\"##0.0####E0*_ 'g-m/s^2'\", US),\n                1.0 / 3,\n                \"333.333E-3_ g-m/s^2\");\n        expect2(new DecimalFormat(\"##0.0####*_ 'g-m/s^2'\", US), 0, \"0.0______ g-m/s^2\");\n        expect(\n                new DecimalFormat(\"##0.0####*_ 'g-m/s^2'\", US),\n                1.0 / 3,\n                \"0.33333__ g-m/s^2\");\n\n        // Test padding before a sign\n        final String formatStr = \"*x#,###,###,##0.0#;*x(###,###,##0.0#)\";\n        expect2(new DecimalFormat(formatStr, US), -10, \"xxxxxxxxxx(10.0)\");\n        expect2(new DecimalFormat(formatStr, US), -1000, \"xxxxxxx(1,000.0)\");\n        expect2(new DecimalFormat(formatStr, US), -1000000, \"xxx(1,000,000.0)\");\n        expect2(new DecimalFormat(formatStr, US), -100.37, \"xxxxxxxx(100.37)\");\n        expect2(new DecimalFormat(formatStr, US), -10456.37, \"xxxxx(10,456.37)\");\n        expect2(new DecimalFormat(formatStr, US), -1120456.37, \"xx(1,120,456.37)\");\n        expect2(new DecimalFormat(formatStr, US), -112045600.37, \"(112,045,600.37)\");\n        expect2(new DecimalFormat(formatStr, US), -1252045600.37, \"(1,252,045,600.37)\");\n\n        expect2(new DecimalFormat(formatStr, US), 10, \"xxxxxxxxxxxx10.0\");\n        expect2(new DecimalFormat(formatStr, US), 1000, \"xxxxxxxxx1,000.0\");\n        expect2(new DecimalFormat(formatStr, US), 1000000, \"xxxxx1,000,000.0\");\n        expect2(new DecimalFormat(formatStr, US), 100.37, \"xxxxxxxxxx100.37\");\n        expect2(new DecimalFormat(formatStr, US), 10456.37, \"xxxxxxx10,456.37\");\n        expect2(new DecimalFormat(formatStr, US), 1120456.37, \"xxxx1,120,456.37\");\n        expect2(new DecimalFormat(formatStr, US), 112045600.37, \"xx112,045,600.37\");\n        expect2(new DecimalFormat(formatStr, US), 10252045600.37, \"10,252,045,600.37\");\n\n        // Test padding between a sign and a number\n        final String formatStr2 = \"#,###,###,##0.0#*x;(###,###,##0.0#*x)\";\n        expect2(new DecimalFormat(formatStr2, US), -10, \"(10.0xxxxxxxxxx)\");\n        expect2(new DecimalFormat(formatStr2, US), -1000, \"(1,000.0xxxxxxx)\");\n        expect2(new DecimalFormat(formatStr2, US), -1000000, \"(1,000,000.0xxx)\");\n        expect2(new DecimalFormat(formatStr2, US), -100.37, \"(100.37xxxxxxxx)\");\n        expect2(new DecimalFormat(formatStr2, US), -10456.37, \"(10,456.37xxxxx)\");\n        expect2(new DecimalFormat(formatStr2, US), -1120456.37, \"(1,120,456.37xx)\");\n        expect2(new DecimalFormat(formatStr2, US), -112045600.37, \"(112,045,600.37)\");\n        expect2(new DecimalFormat(formatStr2, US), -1252045600.37, \"(1,252,045,600.37)\");\n\n        expect2(new DecimalFormat(formatStr2, US), 10, \"10.0xxxxxxxxxxxx\");\n        expect2(new DecimalFormat(formatStr2, US), 1000, \"1,000.0xxxxxxxxx\");\n        expect2(new DecimalFormat(formatStr2, US), 1000000, \"1,000,000.0xxxxx\");\n        expect2(new DecimalFormat(formatStr2, US), 100.37, \"100.37xxxxxxxxxx\");\n        expect2(new DecimalFormat(formatStr2, US), 10456.37, \"10,456.37xxxxxxx\");\n        expect2(new DecimalFormat(formatStr2, US), 1120456.37, \"1,120,456.37xxxx\");\n        expect2(new DecimalFormat(formatStr2, US), 112045600.37, \"112,045,600.37xx\");\n        expect2(new DecimalFormat(formatStr2, US), 10252045600.37, \"10,252,045,600.37\");\n\n        //testing the setPadCharacter(UnicodeString) and getPadCharacterString()\n        DecimalFormat fmt = new DecimalFormat(\"#\", US);\n        char padString = 'P';\n        fmt.setPadCharacter(padString);\n        expectPad(fmt, \"*P##.##\", DecimalFormat.PAD_BEFORE_PREFIX, 5, padString);\n        fmt.setPadCharacter('^');\n        expectPad(fmt, \"*^#\", DecimalFormat.PAD_BEFORE_PREFIX, 1, '^');\n        //commented untill implementation is complete\n        /*  fmt.setPadCharacter((UnicodeString)\"^^^\");\n          expectPad(fmt, \"*^^^#\", DecimalFormat.kPadBeforePrefix, 3, (UnicodeString)\"^^^\");\n          padString.remove();\n          padString.append((UChar)0x0061);\n          padString.append((UChar)0x0302);\n          fmt.setPadCharacter(padString);\n          UChar patternChars[]={0x002a, 0x0061, 0x0302, 0x0061, 0x0302, 0x0023, 0x0000};\n          UnicodeString pattern(patternChars);\n          expectPad(fmt, pattern , DecimalFormat.kPadBeforePrefix, 4, padString);\n         */\n\n        // Test multi-char padding sequence specified via pattern\n        expect2(new DecimalFormat(\"*'\ud83d\ude03'####.00\", US), 1.1, \"\ud83d\ude03\ud83d\ude03\ud83d\ude031.10\");\n    }\n\n    /**\n     * Upgrade to alphaWorks\n     */\n    @Test\n    public void TestPatterns2() {\n        DecimalFormatSymbols US = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat fmt = new DecimalFormat(\"#\", US);\n\n        char hat = 0x005E; /*^*/\n\n        expectPad(fmt, \"*^#\", DecimalFormat.PAD_BEFORE_PREFIX, 1, hat);\n        expectPad(fmt, \"$*^#\", DecimalFormat.PAD_AFTER_PREFIX, 2, hat);\n        expectPad(fmt, \"#*^\", DecimalFormat.PAD_BEFORE_SUFFIX, 1, hat);\n        expectPad(fmt, \"#$*^\", DecimalFormat.PAD_AFTER_SUFFIX, 2, hat);\n        expectPad(fmt, \"$*^$#\", -1);\n        expectPad(fmt, \"#$*^$\", -1);\n        expectPad(fmt, \"'pre'#,##0*x'post'\", DecimalFormat.PAD_BEFORE_SUFFIX, 12, (char) 0x0078 /*x*/);\n        expectPad(fmt, \"''#0*x\", DecimalFormat.PAD_BEFORE_SUFFIX, 3, (char) 0x0078 /*x*/);\n        expectPad(fmt, \"'I''ll'*a###.##\", DecimalFormat.PAD_AFTER_PREFIX, 10, (char) 0x0061 /*a*/);\n\n        fmt.applyPattern(\"AA#,##0.00ZZ\");\n        fmt.setPadCharacter(hat);\n\n        fmt.setFormatWidth(10);\n\n        fmt.setPadPosition(DecimalFormat.PAD_BEFORE_PREFIX);\n        expectPat(fmt, \"*^AA#,##0.00ZZ\");\n\n        fmt.setPadPosition(DecimalFormat.PAD_BEFORE_SUFFIX);\n        expectPat(fmt, \"AA#,##0.00*^ZZ\");\n\n        fmt.setPadPosition(DecimalFormat.PAD_AFTER_SUFFIX);\n        expectPat(fmt, \"AA#,##0.00ZZ*^\");\n\n        //            12  3456789012\n        String exp = \"AA*^#,##0.00ZZ\";\n        fmt.setFormatWidth(12);\n        fmt.setPadPosition(DecimalFormat.PAD_AFTER_PREFIX);\n        expectPat(fmt, exp);\n\n        fmt.setFormatWidth(13);\n        //              12  34567890123\n        expectPat(fmt, \"AA*^##,##0.00ZZ\");\n\n        fmt.setFormatWidth(14);\n        //              12  345678901234\n        expectPat(fmt, \"AA*^###,##0.00ZZ\");\n\n        fmt.setFormatWidth(15);\n        //              12  3456789012345\n        expectPat(fmt, \"AA*^####,##0.00ZZ\"); // This is the interesting case\n\n        // The new implementation produces \"AA*^#####,##0.00ZZ\", which is functionally equivalent\n        // to what the old implementation produced, \"AA*^#,###,##0.00ZZ\"\n        fmt.setFormatWidth(16);\n        //              12  34567890123456\n        //expectPat(fmt, \"AA*^#,###,##0.00ZZ\");\n        expectPat(fmt, \"AA*^#####,##0.00ZZ\");\n    }\n\n    @Test\n    public void TestRegistration() {\n        final ULocale SRC_LOC = ULocale.FRANCE;\n        final ULocale SWAP_LOC = ULocale.US;\n\n        class TestFactory extends SimpleNumberFormatFactory {\n            NumberFormat currencyStyle;\n\n            TestFactory() {\n                super(SRC_LOC, true);\n                currencyStyle = NumberFormat.getIntegerInstance(SWAP_LOC);\n            }\n\n            @Override\n            public NumberFormat createFormat(ULocale loc, int formatType) {\n                if (formatType == FORMAT_CURRENCY) {\n                    return currencyStyle;\n                }\n                return null;\n            }\n        }\n\n        NumberFormat f0 = NumberFormat.getIntegerInstance(SWAP_LOC);\n        NumberFormat f1 = NumberFormat.getIntegerInstance(SRC_LOC);\n        NumberFormat f2 = NumberFormat.getCurrencyInstance(SRC_LOC);\n        Object key = NumberFormat.registerFactory(new TestFactory());\n        NumberFormat f3 = NumberFormat.getCurrencyInstance(SRC_LOC);\n        NumberFormat f4 = NumberFormat.getIntegerInstance(SRC_LOC);\n        NumberFormat.unregister(key); // restore for other tests\n        NumberFormat f5 = NumberFormat.getCurrencyInstance(SRC_LOC);\n\n        float n = 1234.567f;\n        logln(\"f0 swap int: \" + f0.format(n));\n        logln(\"f1 src int: \" + f1.format(n));\n        logln(\"f2 src cur: \" + f2.format(n));\n        logln(\"f3 reg cur: \" + f3.format(n));\n        logln(\"f4 reg int: \" + f4.format(n));\n        logln(\"f5 unreg cur: \" + f5.format(n));\n\n        if (!f3.format(n).equals(f0.format(n))) {\n            errln(\"registered service did not match\");\n        }\n        if (!f4.format(n).equals(f1.format(n))) {\n            errln(\"registered service did not inherit\");\n        }\n        if (!f5.format(n).equals(f2.format(n))) {\n            errln(\"unregistered service did not match original\");\n        }\n    }\n\n    @Test\n    public void TestScientific2() {\n        // jb 2552\n        DecimalFormat fmt = (DecimalFormat)NumberFormat.getCurrencyInstance();\n        Number num = new Double(12.34);\n        expect(fmt, num, \"$12.34\");\n        fmt.setScientificNotation(true);\n        expect(fmt, num, \"$1.23E1\");\n        fmt.setScientificNotation(false);\n        expect(fmt, num, \"$12.34\");\n    }\n\n    @Test\n    public void TestScientificGrouping() {\n        // jb 2552\n        DecimalFormat fmt = new DecimalFormat(\"###.##E0\");\n        expect(fmt, .01234, \"12.3E-3\");\n        expect(fmt, .1234, \"123E-3\");\n        expect(fmt, 1.234, \"1.23E0\");\n        expect(fmt, 12.34, \"12.3E0\");\n        expect(fmt, 123.4, \"123E0\");\n        expect(fmt, 1234, \"1.23E3\");\n    }\n\n    // additional coverage tests\n\n    // sigh, can't have static inner classes, why not?\n\n    static final class PI extends Number {\n        /**\n         * For serialization\n         */\n        private static final long serialVersionUID = -305601227915602172L;\n\n        private PI() {}\n        @Override\n        public int intValue() { return (int)Math.PI; }\n        @Override\n        public long longValue() { return (long)Math.PI; }\n        @Override\n        public float  floatValue() { return (float)Math.PI; }\n        @Override\n        public double doubleValue() { return Math.PI; }\n        @Override\n        public byte byteValue() { return (byte)Math.PI; }\n        @Override\n        public short shortValue() { return (short)Math.PI; }\n\n        public static final Number INSTANCE = new PI();\n    }\n\n    @Test\n    public void TestCoverage() {\n        NumberFormat fmt = NumberFormat.getNumberInstance(); // default locale\n        logln(fmt.format(new BigInteger(\"1234567890987654321234567890987654321\", 10)));\n\n        fmt = NumberFormat.getScientificInstance(); // default locale\n\n        logln(fmt.format(PI.INSTANCE));\n\n        try {\n            logln(fmt.format(\"12345\"));\n            errln(\"numberformat of string did not throw exception\");\n        }\n        catch (Exception e) {\n            logln(\"PASS: numberformat of string failed as expected\");\n        }\n\n        int hash = fmt.hashCode();\n        logln(\"hash code \" + hash);\n\n        logln(\"compare to string returns: \" + fmt.equals(\"\"));\n\n        // For ICU 2.6 - alan\n        DecimalFormatSymbols US = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat df = new DecimalFormat(\"'*&'' '\\u00A4' ''&*' #,##0.00\", US);\n        df.setCurrency(Currency.getInstance(\"INR\"));\n        expect2(df, 1.0, \"*&' \\u20B9 '&* 1.00\");\n        expect2(df, -2.0, \"-*&' \\u20B9 '&* 2.00\");\n        df.applyPattern(\"#,##0.00 '*&'' '\\u00A4' ''&*'\");\n        expect2(df, 2.0, \"2.00 *&' \\u20B9 '&*\");\n        expect2(df, -1.0, \"-1.00 *&' \\u20B9 '&*\");\n\n        java.math.BigDecimal r;\n\n        r = df.getRoundingIncrement();\n        if (r != null) {\n            errln(\"FAIL: rounding = \" + r + \", expect null\");\n        }\n\n        if (df.isScientificNotation()) {\n            errln(\"FAIL: isScientificNotation = true, expect false\");\n        }\n\n        // Create a new instance to flush out currency info\n        df = new DecimalFormat(\"0.00000\", US);\n        df.setScientificNotation(true);\n        if (!df.isScientificNotation()) {\n            errln(\"FAIL: isScientificNotation = false, expect true\");\n        }\n        df.setMinimumExponentDigits((byte)2);\n        if (df.getMinimumExponentDigits() != 2) {\n            errln(\"FAIL: getMinimumExponentDigits = \" +\n                    df.getMinimumExponentDigits() + \", expect 2\");\n        }\n        df.setExponentSignAlwaysShown(true);\n        if (!df.isExponentSignAlwaysShown()) {\n            errln(\"FAIL: isExponentSignAlwaysShown = false, expect true\");\n        }\n        df.setSecondaryGroupingSize(0);\n        if (df.getSecondaryGroupingSize() != 0) {\n            errln(\"FAIL: getSecondaryGroupingSize = \" +\n                    df.getSecondaryGroupingSize() + \", expect 0\");\n        }\n        expect2(df, 3.14159, \"3.14159E+00\");\n\n        // DecimalFormatSymbols#getInstance\n        DecimalFormatSymbols decsym1 = DecimalFormatSymbols.getInstance();\n        DecimalFormatSymbols decsym2 = new DecimalFormatSymbols();\n        if (!decsym1.equals(decsym2)) {\n            errln(\"FAIL: DecimalFormatSymbols returned by getInstance()\" +\n                    \"does not match new DecimalFormatSymbols().\");\n        }\n        decsym1 = DecimalFormatSymbols.getInstance(Locale.JAPAN);\n        decsym2 = DecimalFormatSymbols.getInstance(ULocale.JAPAN);\n        if (!decsym1.equals(decsym2)) {\n            errln(\"FAIL: DecimalFormatSymbols returned by getInstance(Locale.JAPAN)\" +\n                    \"does not match the one returned by getInstance(ULocale.JAPAN).\");\n        }\n\n        // DecimalFormatSymbols#getAvailableLocales/#getAvailableULocales\n        Locale[] allLocales = DecimalFormatSymbols.getAvailableLocales();\n        if (allLocales.length == 0) {\n            errln(\"FAIL: Got a empty list for DecimalFormatSymbols.getAvailableLocales\");\n        } else {\n            logln(\"PASS: \" + allLocales.length +\n                    \" available locales returned by DecimalFormatSymbols.getAvailableLocales\");\n        }\n        ULocale[] allULocales = DecimalFormatSymbols.getAvailableULocales();\n        if (allULocales.length == 0) {\n            errln(\"FAIL: Got a empty list for DecimalFormatSymbols.getAvailableLocales\");\n        } else {\n            logln(\"PASS: \" + allULocales.length +\n                    \" available locales returned by DecimalFormatSymbols.getAvailableULocales\");\n        }\n    }\n\n    @Test\n    public void TestLocalizedPatternSymbolCoverage() {\n        String[] standardPatterns = { \"#,##0.05+%;#,##0.05-%\", \"* @@@E0\u2030\" };\n        String[] standardPatterns58 = { \"#,##0.05+%;#,##0.05-%\", \"* @@@E0\u2030;* -@@@E0\u2030\" };\n        String[] localizedPatterns = { \"\u25b0\u2056\u25b0\u25b0\u0ed0\u2058\u0ed0\u0ed5\u2020\u205c\u2059\u25b0\u2056\u25b0\u25b0\u0ed0\u2058\u0ed0\u0ed5\u2021\u205c\", \"\u2042 \u2055\u2055\u2055\u2051\u2051\u0ed0\u2031\" };\n        String[] localizedPatterns58 = { \"\u25b0\u2056\u25b0\u25b0\u0ed0\u2058\u0ed0\u0ed5+\u205c\u2059\u25b0\u2056\u25b0\u25b0\u0ed0\u2058\u0ed0\u0ed5\u2021\u205c\", \"\u2042 \u2055\u2055\u2055\u2051\u2051\u0ed0\u2031\u2059\u2042 \u2021\u2055\u2055\u2055\u2051\u2051\u0ed0\u2031\" };\n\n        DecimalFormatSymbols dfs = new DecimalFormatSymbols();\n        dfs.setGroupingSeparator('\u2056');\n        dfs.setDecimalSeparator('\u2058');\n        dfs.setPatternSeparator('\u2059');\n        dfs.setDigit('\u25b0');\n        dfs.setZeroDigit('\u0ed0');\n        dfs.setSignificantDigit('\u2055');\n        dfs.setPlusSign('\u2020');\n        dfs.setMinusSign('\u2021');\n        dfs.setPercent('\u205c');\n        dfs.setPerMill('\u2031');\n        dfs.setExponentSeparator(\"\u2051\u2051\"); // tests multi-char sequence\n        dfs.setPadEscape('\u2042');\n\n        for (int i=0; i<2; i++) {\n            String standardPattern = standardPatterns[i];\n            String standardPattern58 = standardPatterns58[i];\n            String localizedPattern = localizedPatterns[i];\n            String localizedPattern58 = localizedPatterns58[i];\n\n            DecimalFormat df1 = new DecimalFormat(\"#\", dfs);\n            df1.applyPattern(standardPattern);\n            DecimalFormat df2 = new DecimalFormat(\"#\", dfs);\n            df2.applyLocalizedPattern(localizedPattern);\n            assertEquals(\"DecimalFormat instances should be equal\",\n                    df1, df2);\n            assertEquals(\"toPattern should match on localizedPattern instance\",\n                    standardPattern, df2.toPattern());\n            assertEquals(\"toLocalizedPattern should match on standardPattern instance\",\n                    localizedPattern, df1.toLocalizedPattern());\n\n            // Android can't access DecimalFormat_ICU58 for testing (ticket #13283).\n            if (TestUtil.getJavaVendor() == TestUtil.JavaVendor.Android) continue;\n\n            // Note: ICU 58 does not support plus signs in patterns\n            // Note: ICU 58 always prints the negative part of scientific notation patterns,\n            //       even when the negative part is not necessary\n            DecimalFormat_ICU58 df3 = new DecimalFormat_ICU58(\"#\", dfs);\n            df3.applyPattern(standardPattern); // Reading standardPattern is OK\n            DecimalFormat_ICU58 df4 = new DecimalFormat_ICU58(\"#\", dfs);\n            df4.applyLocalizedPattern(localizedPattern58);\n            // Note: DecimalFormat#equals() is broken on ICU 58\n            assertEquals(\"toPattern should match on ICU58 localizedPattern instance\",\n                    standardPattern58, df4.toPattern());\n            assertEquals(\"toLocalizedPattern should match on ICU58 standardPattern instance\",\n                    localizedPattern58, df3.toLocalizedPattern());\n        }\n    }\n\n    @Test\n    public void TestParseNull() throws ParseException {\n        DecimalFormat df = new DecimalFormat();\n        try {\n            df.parse(null);\n            fail(\"df.parse(null) didn't throw an exception\");\n        } catch (IllegalArgumentException e){}\n        try {\n            df.parse(null, null);\n            fail(\"df.parse(null) didn't throw an exception\");\n        } catch (IllegalArgumentException e){}\n        try {\n            df.parseCurrency(null, null);\n            fail(\"df.parse(null) didn't throw an exception\");\n        } catch (IllegalArgumentException e){}\n    }\n\n    @Test\n    public void TestWhiteSpaceParsing() {\n        DecimalFormatSymbols US = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat fmt = new DecimalFormat(\"a  b#0c  \", US);\n        int n = 1234;\n        expect(fmt, \"a b1234c \", n);\n        expect(fmt, \"a   b1234c   \", n);\n        expect(fmt, \"ab1234\", n);\n\n        fmt.applyPattern(\"a b #\");\n        expect(fmt, \"ab1234\", n);\n        expect(fmt, \"ab  1234\", n);\n        expect(fmt, \"a b1234\", n);\n        expect(fmt, \"a   b1234\", n);\n        expect(fmt, \" a b 1234\", n);\n\n        // Horizontal whitespace is allowed, but not vertical whitespace.\n        expect(fmt, \"\\ta\\u00A0b\\u20001234\", n);\n        expect(fmt, \"a   \\u200A    b1234\", n);\n        expectParseException(fmt, \"\\nab1234\", n);\n        expectParseException(fmt, \"a    \\n   b1234\", n);\n        expectParseException(fmt, \"a    \\u0085   b1234\", n);\n        expectParseException(fmt, \"a    \\u2028   b1234\", n);\n\n        // Test all characters in the UTS 18 \"blank\" set stated in the API docstring.\n        UnicodeSet blanks = new UnicodeSet(\"[[:Zs:][\\\\u0009]]\").freeze();\n        for (String space : blanks) {\n            String str = \"a \" + space + \" b1234c  \";\n            expect(fmt, str, n);\n        }\n\n        // Arbitrary whitespace is not accepted in strict mode.\n        fmt.setParseStrict(true);\n        for (String space : blanks) {\n            String str = \"a \" + space + \" b1234c  \";\n            expectParseException(fmt, str, n);\n        }\n\n        // Test default ignorable characters.  These should work in both lenient and strict.\n        UnicodeSet defaultIgnorables = new UnicodeSet(\"[[:Bidi_Control:]]\").freeze();\n        fmt.setParseStrict(false);\n        for (String ignorable : defaultIgnorables) {\n            String str = \"a b \" + ignorable + \"1234c  \";\n            expect(fmt, str, n);\n        }\n        fmt.setParseStrict(true);\n        for (String ignorable : defaultIgnorables) {\n            String str = \"a b \" + ignorable + \"1234c  \";\n            expect(fmt, str, n);\n        }\n\n        // Test that other whitespace characters do not work\n        fmt.setParseStrict(false);\n        UnicodeSet otherWhitespace = new UnicodeSet(\"[[:whitespace:]]\").removeAll(blanks).freeze();\n        for (String space : otherWhitespace) {\n            String str = \"a  \" + space + \"  b1234\";\n            expectParseException(fmt, str, n);\n        }\n    }\n\n    /**\n     * Test currencies whose display name is a ChoiceFormat.\n     */\n    @Test\n    public void TestComplexCurrency() {\n        //  CLDR No Longer uses complex currency symbols.\n        //  Skipping this test.\n        //        Locale loc = new Locale(\"kn\", \"IN\", \"\");\n        //        NumberFormat fmt = NumberFormat.getCurrencyInstance(loc);\n\n        //        expect2(fmt, 1.0, \"Re.\\u00a01.00\");\n        //        expect(fmt, 1.001, \"Re.\\u00a01.00\"); // tricky\n        //        expect2(fmt, 12345678.0, \"Rs.\\u00a01,23,45,678.00\");\n        //        expect2(fmt, 0.5, \"Rs.\\u00a00.50\");\n        //        expect2(fmt, -1.0, \"-Re.\\u00a01.00\");\n        //        expect2(fmt, -10.0, \"-Rs.\\u00a010.00\");\n    }\n\n    @Test\n    public void TestCurrencyKeyword() {\n        ULocale locale = new ULocale(\"th_TH@currency=QQQ\");\n        NumberFormat format = NumberFormat.getCurrencyInstance(locale);\n        String result = format.format(12.34f);\n        if (!\"QQQ\u00a012.34\".equals(result)) {\n            errln(\"got unexpected currency: \" + result);\n        }\n    }\n\n    /**\n     * Test alternate numbering systems\n     */\n    @Test\n    public void TestNumberingSystems() {\n        class TestNumberingSystemItem {\n            private final String localeName;\n            private final double value;\n            private final boolean isRBNF;\n            private final String expectedResult;\n\n            TestNumberingSystemItem(String loc, double val, boolean rbnf, String exp) {\n                localeName  = loc;\n                value = val;\n                isRBNF = rbnf;\n                expectedResult = exp;\n            }\n        }\n\n        final TestNumberingSystemItem[] DATA = {\n                new TestNumberingSystemItem( \"en_US@numbers=thai\",        1234.567, false, \"\\u0e51,\\u0e52\\u0e53\\u0e54.\\u0e55\\u0e56\\u0e57\" ),\n                new TestNumberingSystemItem( \"en_US@numbers=thai\",        1234.567, false, \"\\u0E51,\\u0E52\\u0E53\\u0E54.\\u0E55\\u0E56\\u0E57\" ),\n                new TestNumberingSystemItem( \"en_US@numbers=hebr\",        5678.0,   true,  \"\\u05D4\\u05F3\\u05EA\\u05E8\\u05E2\\u05F4\\u05D7\" ),\n                new TestNumberingSystemItem( \"en_US@numbers=arabext\",     1234.567, false, \"\\u06F1\\u066c\\u06F2\\u06F3\\u06F4\\u066b\\u06F5\\u06F6\\u06F7\" ),\n                new TestNumberingSystemItem( \"de_DE@numbers=foobar\",      1234.567, false, \"1.234,567\" ),\n                new TestNumberingSystemItem( \"ar_EG\",                     1234.567, false, \"\\u0661\\u066c\\u0662\\u0663\\u0664\\u066b\\u0665\\u0666\\u0667\" ),\n                new TestNumberingSystemItem( \"th_TH@numbers=traditional\", 1234.567, false, \"\\u0E51,\\u0E52\\u0E53\\u0E54.\\u0E55\\u0E56\\u0E57\" ), // fall back to native per TR35\n                new TestNumberingSystemItem( \"ar_MA\",                     1234.567, false, \"1.234,567\" ),\n                new TestNumberingSystemItem( \"en_US@numbers=hanidec\",     1234.567, false, \"\\u4e00,\\u4e8c\\u4e09\\u56db.\\u4e94\\u516d\\u4e03\" ),\n                new TestNumberingSystemItem( \"ta_IN@numbers=native\",      1234.567, false, \"\\u0BE7,\\u0BE8\\u0BE9\\u0BEA.\\u0BEB\\u0BEC\\u0BED\" ),\n                new TestNumberingSystemItem( \"ta_IN@numbers=traditional\", 1235.0,   true,  \"\\u0BF2\\u0BE8\\u0BF1\\u0BE9\\u0BF0\\u0BEB\" ),\n                new TestNumberingSystemItem( \"ta_IN@numbers=finance\",     1234.567, false, \"1,234.567\" ), // fall back to default per TR35\n                new TestNumberingSystemItem( \"zh_TW@numbers=native\",      1234.567, false, \"\\u4e00,\\u4e8c\\u4e09\\u56db.\\u4e94\\u516d\\u4e03\" ),\n                new TestNumberingSystemItem( \"zh_TW@numbers=traditional\", 1234.567, true,  \"\\u4E00\\u5343\\u4E8C\\u767E\\u4E09\\u5341\\u56DB\\u9EDE\\u4E94\\u516D\\u4E03\" ),\n                new TestNumberingSystemItem( \"zh_TW@numbers=finance\",     1234.567, true,  \"\\u58F9\\u4EDF\\u8CB3\\u4F70\\u53C3\\u62FE\\u8086\\u9EDE\\u4F0D\\u9678\\u67D2\" ),\n                new TestNumberingSystemItem( \"en_US@numbers=mathsanb\",    1234.567, false,  \"\ud835\udfed,\ud835\udfee\ud835\udfef\ud835\udff0.\ud835\udff1\ud835\udff2\ud835\udff3\" ), // ticket #13286\n        };\n\n\n        for (TestNumberingSystemItem item : DATA) {\n            ULocale loc = new ULocale(item.localeName);\n            NumberFormat fmt = NumberFormat.getInstance(loc);\n            if (item.isRBNF) {\n                expect3(fmt,item.value,item.expectedResult);\n            } else {\n                expect2(fmt,item.value,item.expectedResult);\n            }\n        }\n    }\n\n    // Coverage tests for methods not being called otherwise.\n    @Test\n    public void TestNumberingSystemCoverage() {\n        // Test getAvaliableNames\n        String[] availableNames = NumberingSystem.getAvailableNames();\n        if (availableNames == null || availableNames.length <= 0) {\n            errln(\"ERROR: NumberingSystem.getAvailableNames() returned a null or empty array.\");\n        } else {\n            boolean latnFound = false;\n            for (String name : availableNames){\n                if (\"latn\".equals(name)) {\n                    latnFound = true;\n                    break;\n                }\n            }\n\n            if (!latnFound) {\n                errln(\"ERROR: 'latn' numbering system not found on NumberingSystem.getAvailableNames().\");\n            }\n        }\n\n        // Test NumberingSystem.getInstance()\n        NumberingSystem ns1 = NumberingSystem.getInstance();\n        if (ns1 == null || ns1.isAlgorithmic()) {\n            errln(\"ERROR: NumberingSystem.getInstance() returned a null or invalid NumberingSystem\");\n        }\n\n        // Test NumberingSystem.getInstance(int,boolean,String)\n        /* Parameters used: the ones used in the default constructor\n         * radix = 10;\n         * algorithmic = false;\n         * desc = \"0123456789\";\n         */\n        NumberingSystem ns2 = NumberingSystem.getInstance(10, false, \"0123456789\");\n        if (ns2 == null || ns2.isAlgorithmic()) {\n            errln(\"ERROR: NumberingSystem.getInstance(int,boolean,String) returned a null or invalid NumberingSystem\");\n        }\n\n        // Test NumberingSystem.getInstance(Locale)\n        NumberingSystem ns3 = NumberingSystem.getInstance(Locale.ENGLISH);\n        if (ns3 == null || ns3.isAlgorithmic()) {\n            errln(\"ERROR: NumberingSystem.getInstance(Locale) returned a null or invalid NumberingSystem\");\n        }\n    }\n\n    @Test\n    public void Test6816() {\n        Currency cur1 = Currency.getInstance(new Locale(\"und\", \"PH\"));\n\n        NumberFormat nfmt = NumberFormat.getCurrencyInstance(new Locale(\"und\", \"PH\"));\n        DecimalFormatSymbols decsym = ((DecimalFormat)nfmt).getDecimalFormatSymbols();\n        Currency cur2 = decsym.getCurrency();\n\n        if ( !cur1.getCurrencyCode().equals(\"PHP\") || !cur2.getCurrencyCode().equals(\"PHP\")) {\n            errln(\"FAIL: Currencies should match PHP: cur1 = \"+cur1.getCurrencyCode()+\"; cur2 = \"+cur2.getCurrencyCode());\n        }\n\n    }\n\n    @Test\n    public void TestThreadedFormat() {\n\n        class FormatTask implements Runnable {\n            DecimalFormat fmt;\n            StringBuffer buf;\n            boolean inc;\n            float num;\n\n            FormatTask(DecimalFormat fmt, int index) {\n                this.fmt = fmt;\n                this.buf = new StringBuffer();\n                this.inc = (index & 0x1) == 0;\n                this.num = inc ? 0 : 10000;\n            }\n\n            @Override\n            public void run() {\n                if (inc) {\n                    while (num < 10000) {\n                        buf.append(fmt.format(num) + \"\\n\");\n                        num += 3.14159;\n                    }\n                } else {\n                    while (num > 0) {\n                        buf.append(fmt.format(num) + \"\\n\");\n                        num -= 3.14159;\n                    }\n                }\n            }\n\n            String result() {\n                return buf.toString();\n            }\n        }\n\n        DecimalFormat fmt = new DecimalFormat(\"0.####\");\n        FormatTask[] tasks = new FormatTask[8];\n        for (int i = 0; i < tasks.length; ++i) {\n            tasks[i] = new FormatTask(fmt, i);\n        }\n\n        TestUtil.runUntilDone(tasks);\n\n        for (int i = 2; i < tasks.length; i++) {\n            String str1 = tasks[i].result();\n            String str2 = tasks[i-2].result();\n            if (!str1.equals(str2)) {\n                System.out.println(\"mismatch at \" + i);\n                System.out.println(str1);\n                System.out.println(str2);\n                errln(\"decimal format thread mismatch\");\n\n                break;\n            }\n            str1 = str2;\n        }\n    }\n\n    @Test\n    public void TestPerMill() {\n        DecimalFormat fmt = new DecimalFormat(\"###.###\\u2030\");\n        assertEquals(\"0.4857 x ###.###\\u2030\",\n                \"485.7\\u2030\", fmt.format(0.4857));\n\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(Locale.ENGLISH);\n        sym.setPerMill('m');\n        DecimalFormat fmt2 = new DecimalFormat(\"\", sym);\n        fmt2.applyLocalizedPattern(\"###.###m\");\n        assertEquals(\"0.4857 x ###.###m\",\n                \"485.7m\", fmt2.format(0.4857));\n    }\n\n    @Test\n    public void TestIllegalPatterns() {\n        // Test cases:\n        // Prefix with \"-:\" for illegal patterns\n        // Prefix with \"+:\" for legal patterns\n        String DATA[] = {\n                // Unquoted special characters in the suffix are illegal\n                \"-:000.000|###\",\n                \"+:000.000'|###'\",\n        };\n        for (int i=0; i<DATA.length; ++i) {\n            String pat=DATA[i];\n            boolean valid = pat.charAt(0) == '+';\n            pat = pat.substring(2);\n            Exception e = null;\n            try {\n                // locale doesn't matter here\n                new DecimalFormat(pat);\n            } catch (IllegalArgumentException e1) {\n                e = e1;\n            } catch (IndexOutOfBoundsException e1) {\n                e = e1;\n            }\n            String msg = (e==null) ? \"success\" : e.getMessage();\n            if ((e==null) == valid) {\n                logln(\"Ok: pattern \\\"\" + pat + \"\\\": \" + msg);\n            } else {\n                errln(\"FAIL: pattern \\\"\" + pat + \"\\\" should have \" +\n                        (valid?\"succeeded\":\"failed\") + \"; got \" + msg);\n            }\n        }\n    }\n\n    /**\n     * Parse a CurrencyAmount using the given NumberFormat, with\n     * the 'delim' character separating the number and the currency.\n     */\n    private static CurrencyAmount parseCurrencyAmount(String str, NumberFormat fmt,\n            char delim)\n                    throws ParseException {\n        int i = str.indexOf(delim);\n        return new CurrencyAmount(fmt.parse(str.substring(0,i)),\n                Currency.getInstance(str.substring(i+1)));\n    }\n\n    /**\n     * Return an integer representing the next token from this\n     * iterator.  The integer will be an index into the given list, or\n     * -1 if there are no more tokens, or -2 if the token is not on\n     * the list.\n     */\n    private static int keywordIndex(String tok) {\n        for (int i=0; i<KEYWORDS.length; ++i) {\n            if (tok.equals(KEYWORDS[i])) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    private static final String KEYWORDS[] = {\n        /*0*/ \"ref=\", // <reference pattern to parse numbers>\n        /*1*/ \"loc=\", // <locale for formats>\n        /*2*/ \"f:\",   // <pattern or '-'> <number> <exp. string>\n        /*3*/ \"fp:\",  // <pattern or '-'> <number> <exp. string> <exp. number>\n        /*4*/ \"rt:\",  // <pattern or '-'> <(exp.) number> <(exp.) string>\n        /*5*/ \"p:\",   // <pattern or '-'> <string> <exp. number>\n        /*6*/ \"perr:\", // <pattern or '-'> <invalid string>\n        /*7*/ \"pat:\", // <pattern or '-'> <exp. toPattern or '-' or 'err'>\n        /*8*/ \"fpc:\", // <loc or '-'> <curr.amt> <exp. string> <exp. curr.amt>\n        /*9*/ \"strict=\", // true or false\n    };\n\n    @SuppressWarnings(\"resource\")  // InputStream is will be closed by the ResourceReader.\n    @Test\n    public void TestCases() {\n        String caseFileName = \"NumberFormatTestCases.txt\";\n        java.io.InputStream is = NumberFormatTest.class.getResourceAsStream(caseFileName);\n\n        ResourceReader reader = new ResourceReader(is, caseFileName, \"utf-8\");\n        TokenIterator tokens = new TokenIterator(reader);\n\n        Locale loc = new Locale(\"en\", \"US\", \"\");\n        DecimalFormat ref = null, fmt = null;\n        MeasureFormat mfmt = null;\n        String pat = null, str = null, mloc = null;\n        boolean strict = false;\n\n        try {\n            for (;;) {\n                String tok = tokens.next();\n                if (tok == null) {\n                    break;\n                }\n                String where = \"(\" + tokens.getLineNumber() + \") \";\n                int cmd = keywordIndex(tok);\n                switch (cmd) {\n                case 0:\n                    // ref= <reference pattern>\n                    ref = new DecimalFormat(tokens.next(),\n                            new DecimalFormatSymbols(Locale.US));\n                    ref.setParseStrict(strict);\n                    logln(\"Setting reference pattern to:\\t\" + ref);\n                    break;\n                case 1:\n                    // loc= <locale>\n                    loc = LocaleUtility.getLocaleFromName(tokens.next());\n                    pat = ((DecimalFormat) NumberFormat.getInstance(loc)).toPattern();\n                    logln(\"Setting locale to:\\t\" + loc + \", \\tand pattern to:\\t\" + pat);\n                    break;\n                case 2: // f:\n                case 3: // fp:\n                case 4: // rt:\n                case 5: // p:\n                    tok = tokens.next();\n                    if (!tok.equals(\"-\")) {\n                        pat = tok;\n                    }\n                    try {\n                        fmt = new DecimalFormat(pat, new DecimalFormatSymbols(loc));\n                        fmt.setParseStrict(strict);\n                    } catch (IllegalArgumentException iae) {\n                        errln(where + \"Pattern \\\"\" + pat + '\"');\n                        iae.printStackTrace();\n                        tokens.next(); // consume remaining tokens\n                        //tokens.next();\n                        if (cmd == 3) tokens.next();\n                        continue;\n                    }\n                    str = null;\n                    try {\n                        if (cmd == 2 || cmd == 3 || cmd == 4) {\n                            // f: <pattern or '-'> <number> <exp. string>\n                            // fp: <pattern or '-'> <number> <exp. string> <exp. number>\n                            // rt: <pattern or '-'> <number> <string>\n                            String num = tokens.next();\n                            str = tokens.next();\n                            Number n = ref.parse(num);\n                            assertEquals(where + '\"' + pat + \"\\\".format(\" + num + \")\",\n                                    str, fmt.format(n));\n                            if (cmd == 3) { // fp:\n                                n = ref.parse(tokens.next());\n                            }\n                            if (cmd != 2) { // != f:\n                                assertEquals(where + '\"' + pat + \"\\\".parse(\\\"\" + str + \"\\\")\",\n                                        n, fmt.parse(str));\n                            }\n                        }\n                        // p: <pattern or '-'> <string to parse> <exp. number>\n                        else {\n                            str = tokens.next();\n                            String expstr = tokens.next();\n                            Number parsed = fmt.parse(str);\n                            Number exp = ref.parse(expstr);\n                            assertEquals(where + '\"' + pat + \"\\\".parse(\\\"\" + str + \"\\\")\",\n                                    exp, parsed);\n                        }\n                    } catch (ParseException e) {\n                        errln(where + '\"' + pat + \"\\\".parse(\\\"\" + str +\n                                \"\\\") threw an exception\");\n                        e.printStackTrace();\n                    }\n                    break;\n                case 6:\n                    // perr: <pattern or '-'> <invalid string>\n                    errln(\"Under construction\");\n                    return;\n                case 7:\n                    // pat: <pattern> <exp. toPattern, or '-' or 'err'>\n                    String testpat = tokens.next();\n                    String exppat  = tokens.next();\n                    boolean err    = exppat.equals(\"err\");\n                    if (testpat.equals(\"-\")) {\n                        if (err) {\n                            errln(\"Invalid command \\\"pat: - err\\\" at \" +  tokens.describePosition());\n                            continue;\n                        }\n                        testpat = pat;\n                    }\n                    if (exppat.equals(\"-\")) exppat = testpat;\n                    try {\n                        DecimalFormat f = null;\n                        if (testpat == pat) { // [sic]\n                            f = fmt;\n                        } else {\n                            f = new DecimalFormat(testpat);\n                            f.setParseStrict(strict);\n                        }\n                        if (err) {\n                            errln(where + \"Invalid pattern \\\"\" + testpat +\n                                    \"\\\" was accepted\");\n                        } else {\n                            assertEquals(where + '\"' + testpat + \"\\\".toPattern()\",\n                                    exppat, f.toPattern());\n                        }\n                    } catch (IllegalArgumentException iae2) {\n                        if (err) {\n                            logln(\"Ok: \" + where + \"Invalid pattern \\\"\" + testpat +\n                                    \"\\\" threw an exception\");\n                        } else {\n                            errln(where + \"Valid pattern \\\"\" + testpat +\n                                    \"\\\" threw an exception\");\n                            iae2.printStackTrace();\n                        }\n                    }\n                    break;\n                case 8: // fpc:\n                    tok = tokens.next();\n                    if (!tok.equals(\"-\")) {\n                        mloc = tok;\n                        ULocale l = new ULocale(mloc);\n                        try {\n                            mfmt = MeasureFormat.getCurrencyFormat(l);\n                        } catch (IllegalArgumentException iae) {\n                            errln(where + \"Loc \\\"\" + tok + '\"');\n                            iae.printStackTrace();\n                            tokens.next(); // consume remaining tokens\n                            tokens.next();\n                            tokens.next();\n                            continue;\n                        }\n                    }\n                    str = null;\n                    try {\n                        // fpc: <loc or '-'> <curr.amt> <exp. string> <exp. curr.amt>\n                        String currAmt = tokens.next();\n                        str = tokens.next();\n                        CurrencyAmount target = parseCurrencyAmount(currAmt, ref, '/');\n                        String formatResult = mfmt.format(target);\n                        assertEquals(where + \"getCurrencyFormat(\" + mloc + \").format(\" + currAmt + \")\",\n                                str, formatResult);\n                        target = parseCurrencyAmount(tokens.next(), ref, '/');\n                        CurrencyAmount parseResult = (CurrencyAmount) mfmt.parseObject(str);\n                        assertEquals(where + \"getCurrencyFormat(\" + mloc + \").parse(\\\"\" + str + \"\\\")\",\n                                target, parseResult);\n                    } catch (ParseException e) {\n                        errln(where + '\"' + pat + \"\\\".parse(\\\"\" + str +\n                                \"\\\") threw an exception\");\n                        e.printStackTrace();\n                    }\n                    break;\n                case 9: // strict= true or false\n                    strict = \"true\".equalsIgnoreCase(tokens.next());\n                    logln(\"Setting strict to:\\t\" + strict);\n                    break;\n                case -1:\n                    errln(\"Unknown command \\\"\" + tok + \"\\\" at \" + tokens.describePosition());\n                    return;\n                }\n            }\n        } catch (java.io.IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            try {\n                reader.close();\n            } catch (IOException ignored) {\n            }\n        }\n    }\n\n    @Test\n    public void TestFieldPositionDecimal() {\n        DecimalFormat nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getInstance(ULocale.ENGLISH);\n        nf.setPositivePrefix(\"FOO\");\n        nf.setPositiveSuffix(\"BA\");\n        StringBuffer buffer = new StringBuffer();\n        FieldPosition fp = new FieldPosition(NumberFormat.Field.DECIMAL_SEPARATOR);\n        nf.format(35.47, buffer, fp);\n        assertEquals(\"35.47\", \"FOO35.47BA\", buffer.toString());\n        assertEquals(\"fp begin\", 5, fp.getBeginIndex());\n        assertEquals(\"fp end\", 6, fp.getEndIndex());\n    }\n\n    @Test\n    public void TestFieldPositionInteger() {\n        DecimalFormat nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getInstance(ULocale.ENGLISH);\n        nf.setPositivePrefix(\"FOO\");\n        nf.setPositiveSuffix(\"BA\");\n        StringBuffer buffer = new StringBuffer();\n        FieldPosition fp = new FieldPosition(NumberFormat.Field.INTEGER);\n        nf.format(35.47, buffer, fp);\n        assertEquals(\"35.47\", \"FOO35.47BA\", buffer.toString());\n        assertEquals(\"fp begin\", 3, fp.getBeginIndex());\n        assertEquals(\"fp end\", 5, fp.getEndIndex());\n    }\n\n    @Test\n    public void TestFieldPositionFractionButInteger() {\n        DecimalFormat nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getInstance(ULocale.ENGLISH);\n        nf.setPositivePrefix(\"FOO\");\n        nf.setPositiveSuffix(\"BA\");\n        StringBuffer buffer = new StringBuffer();\n        FieldPosition fp = new FieldPosition(NumberFormat.Field.FRACTION);\n        nf.format(35, buffer, fp);\n        assertEquals(\"35\", \"FOO35BA\", buffer.toString());\n        assertEquals(\"fp begin\", 5, fp.getBeginIndex());\n        assertEquals(\"fp end\", 5, fp.getEndIndex());\n    }\n\n    @Test\n    public void TestFieldPositionFraction() {\n        DecimalFormat nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getInstance(ULocale.ENGLISH);\n        nf.setPositivePrefix(\"FOO\");\n        nf.setPositiveSuffix(\"BA\");\n        StringBuffer buffer = new StringBuffer();\n        FieldPosition fp = new FieldPosition(NumberFormat.Field.FRACTION);\n        nf.format(35.47, buffer, fp);\n        assertEquals(\"35.47\", \"FOO35.47BA\", buffer.toString());\n        assertEquals(\"fp begin\", 6, fp.getBeginIndex());\n        assertEquals(\"fp end\", 8, fp.getEndIndex());\n    }\n\n    @Test\n    public void TestFieldPositionCurrency() {\n        DecimalFormat nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getCurrencyInstance(Locale.US);\n        double amount = 35.47;\n        double negAmount = -34.567;\n        FieldPosition cp = new FieldPosition(NumberFormat.Field.CURRENCY);\n\n        StringBuffer buffer0 = new StringBuffer();\n        nf.format(amount, buffer0, cp);\n        assertEquals(\"$35.47\", \"$35.47\", buffer0.toString());\n        assertEquals(\"cp begin\", 0, cp.getBeginIndex());\n        assertEquals(\"cp end\", 1, cp.getEndIndex());\n\n        StringBuffer buffer01 = new StringBuffer();\n        nf.format(negAmount, buffer01, cp);\n        assertEquals(\"-$34.57\", \"-$34.57\", buffer01.toString());\n        assertEquals(\"cp begin\", 1, cp.getBeginIndex());\n        assertEquals(\"cp end\", 2, cp.getEndIndex());\n\n        nf.setCurrency(Currency.getInstance(Locale.FRANCE));\n        StringBuffer buffer1 = new StringBuffer();\n        nf.format(amount, buffer1, cp);\n        assertEquals(\"\u20ac35.47\", \"\u20ac35.47\", buffer1.toString());\n        assertEquals(\"cp begin\", 0, cp.getBeginIndex());\n        assertEquals(\"cp end\", 1, cp.getEndIndex());\n\n        nf.setCurrency(Currency.getInstance(new Locale(\"fr\", \"ch\", \"\")));\n        StringBuffer buffer2 = new StringBuffer();\n        nf.format(amount, buffer2, cp);\n        assertEquals(\"CHF\u00a035.47\", \"CHF\u00a035.47\", buffer2.toString());\n        assertEquals(\"cp begin\", 0, cp.getBeginIndex());\n        assertEquals(\"cp end\", 3, cp.getEndIndex());\n\n        StringBuffer buffer20 = new StringBuffer();\n        nf.format(negAmount, buffer20, cp);\n        assertEquals(\"-CHF\u00a034.57\", \"-CHF\u00a034.57\", buffer20.toString());\n        assertEquals(\"cp begin\", 1, cp.getBeginIndex());\n        assertEquals(\"cp end\", 4, cp.getEndIndex());\n\n        nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getCurrencyInstance(Locale.FRANCE);\n        StringBuffer buffer3 = new StringBuffer();\n        nf.format(amount, buffer3, cp);\n        assertEquals(\"35,47\u00a0\u20ac\", \"35,47\u00a0\u20ac\", buffer3.toString());\n        assertEquals(\"cp begin\", 6, cp.getBeginIndex());\n        assertEquals(\"cp end\", 7, cp.getEndIndex());\n\n        StringBuffer buffer4 = new StringBuffer();\n        nf.format(negAmount, buffer4, cp);\n        assertEquals(\"-34,57\u00a0\u20ac\", \"-34,57\u00a0\u20ac\", buffer4.toString());\n        assertEquals(\"cp begin\", 7, cp.getBeginIndex());\n        assertEquals(\"cp end\", 8, cp.getEndIndex());\n\n        nf.setCurrency(Currency.getInstance(new Locale(\"fr\", \"ch\")));\n        StringBuffer buffer5 = new StringBuffer();\n        nf.format(negAmount, buffer5, cp);\n        assertEquals(\"-34,57\u00a0CHF\", \"-34,57\u00a0CHF\", buffer5.toString());\n        assertEquals(\"cp begin\", 7, cp.getBeginIndex());\n        assertEquals(\"cp end\", 10, cp.getEndIndex());\n\n        NumberFormat plCurrencyFmt = NumberFormat.getInstance(new Locale(\"fr\", \"ch\"), NumberFormat.PLURALCURRENCYSTYLE);\n        StringBuffer buffer6 = new StringBuffer();\n        plCurrencyFmt.format(negAmount, buffer6, cp);\n        assertEquals(\"-34.57 francs suisses\", \"-34.57 francs suisses\", buffer6.toString());\n        assertEquals(\"cp begin\", 7, cp.getBeginIndex());\n        assertEquals(\"cp end\", 21, cp.getEndIndex());\n\n        // Positive value with PLURALCURRENCYSTYLE.\n        plCurrencyFmt = NumberFormat.getInstance(new Locale(\"ja\", \"ch\"), NumberFormat.PLURALCURRENCYSTYLE);\n        StringBuffer buffer7 = new StringBuffer();\n        plCurrencyFmt.format(amount, buffer7, cp);\n        assertEquals(\"35.47\u00a0\u30b9\u30a4\u30b9 \u30d5\u30e9\u30f3\", \"35.47\u00a0\u30b9\u30a4\u30b9 \u30d5\u30e9\u30f3\", buffer7.toString());\n        assertEquals(\"cp begin\", 6, cp.getBeginIndex());\n        assertEquals(\"cp end\", 13, cp.getEndIndex());\n\n        // PLURALCURRENCYSTYLE for non-ASCII.\n        plCurrencyFmt = NumberFormat.getInstance(new Locale(\"ja\", \"de\"), NumberFormat.PLURALCURRENCYSTYLE);\n        StringBuffer buffer8 = new StringBuffer();\n        plCurrencyFmt.format(negAmount, buffer8, cp);\n        assertEquals(\"-34.57\u00a0\u30e6\u30fc\u30ed\", \"-34.57\u00a0\u30e6\u30fc\u30ed\", buffer8.toString());\n        assertEquals(\"cp begin\", 7, cp.getBeginIndex());\n        assertEquals(\"cp end\", 10, cp.getEndIndex());\n\n        nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getCurrencyInstance(Locale.JAPAN);\n        nf.setCurrency(Currency.getInstance(new Locale(\"ja\", \"jp\")));\n        StringBuffer buffer9 = new StringBuffer();\n        nf.format(negAmount, buffer9, cp);\n        assertEquals(\"-\uffe535\", \"-\uffe535\", buffer9.toString());\n        assertEquals(\"cp begin\", 1, cp.getBeginIndex());\n        assertEquals(\"cp end\", 2, cp.getEndIndex());\n\n        // Negative value with PLURALCURRENCYSTYLE.\n        plCurrencyFmt = NumberFormat.getInstance(new Locale(\"ja\", \"ch\"), NumberFormat.PLURALCURRENCYSTYLE);\n        StringBuffer buffer10 = new StringBuffer();\n        plCurrencyFmt.format(negAmount, buffer10, cp);\n        assertEquals(\"-34.57\u00a0\u30b9\u30a4\u30b9 \u30d5\u30e9\u30f3\", \"-34.57\u00a0\u30b9\u30a4\u30b9 \u30d5\u30e9\u30f3\", buffer10.toString());\n        assertEquals(\"cp begin\", 7, cp.getBeginIndex());\n        assertEquals(\"cp end\", 14, cp.getEndIndex());\n\n        // Nagative value with PLURALCURRENCYSTYLE, Arabic digits.\n        nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getCurrencyInstance(new Locale(\"ar\", \"eg\"));\n        plCurrencyFmt = NumberFormat.getInstance(new Locale(\"ar\", \"eg\"), NumberFormat.PLURALCURRENCYSTYLE);\n        StringBuffer buffer11 = new StringBuffer();\n        plCurrencyFmt.format(negAmount, buffer11, cp);\n        assertEquals(\"\u061c-\u0663\u0664\u066b\u0665\u0667 \u062c\u0646\u064a\u0647 \u0645\u0635\u0631\u064a\", \"\u061c-\u0663\u0664\u066b\u0665\u0667 \u062c\u0646\u064a\u0647 \u0645\u0635\u0631\u064a\", buffer11.toString());\n        assertEquals(\"cp begin\", 8, cp.getBeginIndex());\n        assertEquals(\"cp end\", 17, cp.getEndIndex());\n    }\n\n    @Test\n    public void TestRounding() {\n        DecimalFormat nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getInstance(ULocale.ENGLISH);\n        if (false) { // for debugging specific value\n            nf.setRoundingMode(BigDecimal.ROUND_HALF_UP);\n            checkRounding(nf, new BigDecimal(\"300.0300000000\"), 0, new BigDecimal(\"0.020000000\"));\n        }\n        // full tests\n        int[] roundingIncrements = {1, 2, 5, 20, 50, 100};\n        int[] testValues = {0, 300};\n        for (int j = 0; j < testValues.length; ++j) {\n            for (int mode = BigDecimal.ROUND_UP; mode < BigDecimal.ROUND_HALF_EVEN; ++mode) {\n                nf.setRoundingMode(mode);\n                for (int increment = 0; increment < roundingIncrements.length; ++increment) {\n                    BigDecimal base = new BigDecimal(testValues[j]);\n                    BigDecimal rInc = new BigDecimal(roundingIncrements[increment]);\n                    checkRounding(nf,  base, 20, rInc);\n                    rInc = new BigDecimal(\"1.000000000\").divide(rInc);\n                    checkRounding(nf,  base, 20, rInc);\n                }\n            }\n        }\n    }\n\n    @Test\n    public void TestRoundingPattern() {\n        class TestRoundingPatternItem {\n            String     pattern;\n            BigDecimal roundingIncrement;\n            double     testCase;\n            String     expected;\n\n            TestRoundingPatternItem(String pattern, BigDecimal roundingIncrement, double testCase, String expected) {\n                this.pattern = pattern;\n                this.roundingIncrement = roundingIncrement;\n                this.testCase = testCase;\n                this.expected = expected;\n            }\n        };\n\n        TestRoundingPatternItem []tests = {\n                new TestRoundingPatternItem(\"##0.65\", new BigDecimal(\"0.65\"), 1.234, \"1.30\"),\n                new TestRoundingPatternItem(\"#50\", new BigDecimal(\"50\"), 1230, \"1250\")\n        };\n\n        DecimalFormat df = (DecimalFormat) com.ibm.icu.text.NumberFormat.getInstance(ULocale.ENGLISH);\n        String result;\n        for (int i = 0; i < tests.length; i++) {\n            df.applyPattern(tests[i].pattern);\n\n            result = df.format(tests[i].testCase);\n\n            if (!tests[i].expected.equals(result)) {\n                errln(\"String Pattern Rounding Test Failed: Pattern: \\\"\" + tests[i].pattern + \"\\\" Number: \" + tests[i].testCase + \" - Got: \" + result + \" Expected: \" + tests[i].expected);\n            }\n\n            df.setRoundingIncrement(tests[i].roundingIncrement);\n\n            result = df.format(tests[i].testCase);\n\n            if (!tests[i].expected.equals(result)) {\n                errln(\"BigDecimal Rounding Test Failed: Pattern: \\\"\" + tests[i].pattern + \"\\\" Number: \" + tests[i].testCase + \" - Got: \" + result + \" Expected: \" + tests[i].expected);\n            }\n        }\n    }\n\n    @Test\n    public void TestBigDecimalRounding() {\n        String figure = \"50.000000004\";\n        Double dbl = new Double(figure);\n        BigDecimal dec = new BigDecimal(figure);\n\n        DecimalFormat f = (DecimalFormat) NumberFormat.getInstance();\n        f.applyPattern(\"00.00######\");\n\n        assertEquals(\"double format\", \"50.00\", f.format(dbl));\n        assertEquals(\"bigdec format\", \"50.00\", f.format(dec));\n\n        int maxFracDigits = f.getMaximumFractionDigits();\n        BigDecimal roundingIncrement = new BigDecimal(\"1\").movePointLeft(maxFracDigits);\n\n        f.setRoundingIncrement(roundingIncrement);\n        f.setRoundingMode(BigDecimal.ROUND_DOWN);\n        assertEquals(\"Rounding down\", f.format(dbl), f.format(dec));\n\n        f.setRoundingIncrement(roundingIncrement);\n        f.setRoundingMode(BigDecimal.ROUND_HALF_UP);\n        assertEquals(\"Rounding half up\", f.format(dbl), f.format(dec));\n    }\n\n    void checkRounding(DecimalFormat nf, BigDecimal base, int iterations, BigDecimal increment) {\n        nf.setRoundingIncrement(increment.toBigDecimal());\n        BigDecimal lastParsed = new BigDecimal(Integer.MIN_VALUE); // used to make sure that rounding is monotonic\n        for (int i = -iterations; i <= iterations; ++i) {\n            BigDecimal iValue = base.add(increment.multiply(new BigDecimal(i)).movePointLeft(1));\n            BigDecimal smallIncrement = new BigDecimal(\"0.00000001\");\n            if (iValue.signum() != 0) {\n                smallIncrement.multiply(iValue); // scale unless zero\n            }\n            // we not only test the value, but some values in a small range around it.\n            lastParsed = checkRound(nf, iValue.subtract(smallIncrement), lastParsed);\n            lastParsed = checkRound(nf, iValue, lastParsed);\n            lastParsed = checkRound(nf, iValue.add(smallIncrement), lastParsed);\n        }\n    }\n\n    private BigDecimal checkRound(DecimalFormat nf, BigDecimal iValue, BigDecimal lastParsed) {\n        String formatedBigDecimal = nf.format(iValue);\n        String formattedDouble = nf.format(iValue.doubleValue());\n        if (!equalButForTrailingZeros(formatedBigDecimal, formattedDouble)) {\n\n            errln(\"Failure at: \" + iValue + \" (\" + iValue.doubleValue() + \")\"\n                    + \",\\tRounding-mode: \" + roundingModeNames[nf.getRoundingMode()]\n                            + \",\\tRounding-increment: \" + nf.getRoundingIncrement()\n                            + \",\\tdouble: \" + formattedDouble\n                            + \",\\tBigDecimal: \" + formatedBigDecimal);\n\n        } else {\n            logln(\"Value: \" + iValue\n                    + \",\\tRounding-mode: \" + roundingModeNames[nf.getRoundingMode()]\n                            + \",\\tRounding-increment: \" + nf.getRoundingIncrement()\n                            + \",\\tdouble: \" + formattedDouble\n                            + \",\\tBigDecimal: \" + formatedBigDecimal);\n        }\n        try {\n            // Number should have compareTo(...)\n            BigDecimal parsed = toBigDecimal(nf.parse(formatedBigDecimal));\n            if (lastParsed.compareTo(parsed) > 0) {\n                errln(\"Rounding wrong direction!: \" + lastParsed + \" > \" + parsed);\n            }\n            lastParsed = parsed;\n        } catch (ParseException e) {\n            errln(\"Parse Failure with: \" + formatedBigDecimal);\n        }\n        return lastParsed;\n    }\n\n    static BigDecimal toBigDecimal(Number number) {\n        return number instanceof BigDecimal ? (BigDecimal) number\n                : number instanceof BigInteger ? new BigDecimal((BigInteger)number)\n        : number instanceof java.math.BigDecimal ? new BigDecimal((java.math.BigDecimal)number)\n                : number instanceof Double ? new BigDecimal(number.doubleValue())\n        : number instanceof Float ? new BigDecimal(number.floatValue())\n                : new BigDecimal(number.longValue());\n    }\n\n    static String[] roundingModeNames = {\n        \"ROUND_UP\", \"ROUND_DOWN\", \"ROUND_CEILING\", \"ROUND_FLOOR\",\n        \"ROUND_HALF_UP\", \"ROUND_HALF_DOWN\", \"ROUND_HALF_EVEN\",\n        \"ROUND_UNNECESSARY\"\n    };\n\n    private static boolean equalButForTrailingZeros(String formatted1, String formatted2) {\n        if (formatted1.length() == formatted2.length()) return formatted1.equals(formatted2);\n        return stripFinalZeros(formatted1).equals(stripFinalZeros(formatted2));\n    }\n\n    private static String stripFinalZeros(String formatted) {\n        int len1 = formatted.length();\n        char ch;\n        while (len1 > 0 && ((ch = formatted.charAt(len1-1)) == '0' || ch == '.')) --len1;\n        if (len1==1 && ((ch = formatted.charAt(len1-1)) == '-')) --len1;\n        return formatted.substring(0,len1);\n    }\n\n    //------------------------------------------------------------------\n    // Support methods\n    //------------------------------------------------------------------\n\n    /** Format-Parse test */\n    public void expect2(NumberFormat fmt, Number n, String exp) {\n        // Don't round-trip format test, since we explicitly do it\n        expect(fmt, n, exp, false);\n        expect(fmt, exp, n);\n    }\n    /** Format-Parse test */\n    public void expect3(NumberFormat fmt, Number n, String exp) {\n        // Don't round-trip format test, since we explicitly do it\n        expect_rbnf(fmt, n, exp, false);\n        expect_rbnf(fmt, exp, n);\n    }\n\n    /** Format-Parse test (convenience) */\n    public void expect2(NumberFormat fmt, double n, String exp) {\n        expect2(fmt, new Double(n), exp);\n    }\n    /** RBNF Format-Parse test (convenience) */\n    public void expect3(NumberFormat fmt, double n, String exp) {\n        expect3(fmt, new Double(n), exp);\n    }\n\n    /** Format-Parse test (convenience) */\n    public void expect2(NumberFormat fmt, long n, String exp) {\n        expect2(fmt, new Long(n), exp);\n    }\n    /** RBNF Format-Parse test (convenience) */\n    public void expect3(NumberFormat fmt, long n, String exp) {\n        expect3(fmt, new Long(n), exp);\n    }\n\n    /** Format test */\n    public void expect(NumberFormat fmt, Number n, String exp, boolean rt) {\n        StringBuffer saw = new StringBuffer();\n        FieldPosition pos = new FieldPosition(0);\n        fmt.format(n, saw, pos);\n        String pat = ((DecimalFormat)fmt).toPattern();\n        if (saw.toString().equals(exp)) {\n            logln(\"Ok   \" + n + \" x \" +\n                    pat + \" = \\\"\" +\n                    saw + \"\\\"\");\n            // We should be able to round-trip the formatted string =>\n            // number => string (but not the other way around: number\n            // => string => number2, might have number2 != number):\n            if (rt) {\n                try {\n                    Number n2 = fmt.parse(exp);\n                    StringBuffer saw2 = new StringBuffer();\n                    fmt.format(n2, saw2, pos);\n                    if (!saw2.toString().equals(exp)) {\n                        errln(\"expect() format test rt, locale \" + fmt.getLocale(ULocale.VALID_LOCALE) +\n                                \", FAIL \\\"\" + exp + \"\\\" => \" + n2 + \" => \\\"\" + saw2 + '\"');\n                    }\n                } catch (ParseException e) {\n                    errln(\"expect() format test rt, locale \" + fmt.getLocale(ULocale.VALID_LOCALE) +\n                            \", \" + e.getMessage());\n                    return;\n                }\n            }\n        } else {\n            errln(\"expect() format test, locale \" + fmt.getLocale(ULocale.VALID_LOCALE) +\n                    \", FAIL \" + n + \" x \" + pat + \" = \\\"\" + saw + \"\\\", expected \\\"\" + exp + \"\\\"\");\n        }\n    }\n    /** RBNF format test */\n    public void expect_rbnf(NumberFormat fmt, Number n, String exp, boolean rt) {\n        StringBuffer saw = new StringBuffer();\n        FieldPosition pos = new FieldPosition(0);\n        fmt.format(n, saw, pos);\n        if (saw.toString().equals(exp)) {\n            logln(\"Ok   \" + n + \" = \\\"\" +\n                    saw + \"\\\"\");\n            // We should be able to round-trip the formatted string =>\n            // number => string (but not the other way around: number\n            // => string => number2, might have number2 != number):\n            if (rt) {\n                try {\n                    Number n2 = fmt.parse(exp);\n                    StringBuffer saw2 = new StringBuffer();\n                    fmt.format(n2, saw2, pos);\n                    if (!saw2.toString().equals(exp)) {\n                        errln(\"expect_rbnf() format test rt, locale \" + fmt.getLocale(ULocale.VALID_LOCALE) +\n                                \", FAIL \\\"\" + exp + \"\\\" => \" + n2 + \" => \\\"\" + saw2 + '\"');\n                    }\n                } catch (ParseException e) {\n                    errln(\"expect_rbnf() format test rt, locale \" + fmt.getLocale(ULocale.VALID_LOCALE) +\n                            \", \" + e.getMessage());\n                    return;\n                }\n            }\n        } else {\n            errln(\"expect_rbnf() format test, locale \" + fmt.getLocale(ULocale.VALID_LOCALE) +\n                    \", FAIL \" + n + \" = \\\"\" + saw + \"\\\", expected \\\"\" + exp + \"\\\"\");\n        }\n    }\n\n    /** Format test (convenience) */\n    public void expect(NumberFormat fmt, Number n, String exp) {\n        expect(fmt, n, exp, true);\n    }\n\n    /** Format test (convenience) */\n    public void expect(NumberFormat fmt, double n, String exp) {\n        expect(fmt, new Double(n), exp);\n    }\n\n    /** Format test (convenience) */\n    public void expect(NumberFormat fmt, long n, String exp) {\n        expect(fmt, new Long(n), exp);\n    }\n\n    /** Parse test */\n    public void expect(NumberFormat fmt, String str, Number n) {\n        Number num = null;\n        try {\n            num = fmt.parse(str);\n        } catch (ParseException e) {\n            errln(e.getMessage());\n            return;\n        }\n        String pat = ((DecimalFormat)fmt).toPattern();\n        // A little tricky here -- make sure Double(12345.0) and\n        // Long(12345) match.\n        if (num.equals(n) || num.doubleValue() == n.doubleValue()) {\n            logln(\"Ok   \\\"\" + str + \"\\\" x \" +\n                    pat + \" = \" +\n                    num);\n        } else {\n            errln(\"expect() parse test, locale \" + fmt.getLocale(ULocale.VALID_LOCALE) +\n                    \", FAIL \\\"\" + str + \"\\\" x \" + pat + \" = \" + num + \", expected \" + n);\n        }\n    }\n\n    /** RBNF Parse test */\n    public void expect_rbnf(NumberFormat fmt, String str, Number n) {\n        Number num = null;\n        try {\n            num = fmt.parse(str);\n        } catch (ParseException e) {\n            errln(e.getMessage());\n            return;\n        }\n        // A little tricky here -- make sure Double(12345.0) and\n        // Long(12345) match.\n        if (num.equals(n) || num.doubleValue() == n.doubleValue()) {\n            logln(\"Ok   \\\"\" + str + \" = \" +\n                    num);\n        } else {\n            errln(\"expect_rbnf() parse test, locale \" + fmt.getLocale(ULocale.VALID_LOCALE) +\n                    \", FAIL \\\"\" + str + \" = \" + num + \", expected \" + n);\n        }\n    }\n\n    /** Parse test (convenience) */\n    public void expect(NumberFormat fmt, String str, double n) {\n        expect(fmt, str, new Double(n));\n    }\n\n    /** Parse test (convenience) */\n    public void expect(NumberFormat fmt, String str, long n) {\n        expect(fmt, str, new Long(n));\n    }\n\n    /** Parse test */\n    public void expectParseException(DecimalFormat fmt, String str, Number n) {\n        Number num = null;\n        try {\n            num = fmt.parse(str);\n            errln(\"Expected failure, but passed: \" + n + \" on \" + fmt.toPattern() + \" -> \" + num);\n        } catch (ParseException e) {\n        }\n    }\n\n    private void expectCurrency(NumberFormat nf, Currency curr,\n            double value, String string) {\n        DecimalFormat fmt = (DecimalFormat) nf;\n        if (curr != null) {\n            fmt.setCurrency(curr);\n        }\n        String s = fmt.format(value).replace('\\u00A0', ' ');\n\n        if (s.equals(string)) {\n            logln(\"Ok: \" + value + \" x \" + curr + \" => \" + s);\n        } else {\n            errln(\"FAIL: \" + value + \" x \" + curr + \" => \" + s +\n                    \", expected \" + string);\n        }\n    }\n\n    public void expectPad(DecimalFormat fmt, String pat, int pos) {\n        expectPad(fmt, pat, pos, 0, (char)0);\n    }\n\n    public void expectPad(DecimalFormat fmt, final String pat, int pos, int width, final char pad) {\n        int apos = 0, awidth = 0;\n        char apadStr;\n        try {\n            fmt.applyPattern(pat);\n            apos = fmt.getPadPosition();\n            awidth = fmt.getFormatWidth();\n            apadStr = fmt.getPadCharacter();\n        } catch (Exception e) {\n            apos = -1;\n            awidth = width;\n            apadStr = pad;\n        }\n\n        if (apos == pos && awidth == width && apadStr == pad) {\n            logln(\"Ok   \\\"\" + pat + \"\\\" pos=\"\n                    + apos + ((pos == -1) ? \"\" : \" width=\" + awidth + \" pad=\" + apadStr));\n        } else {\n            errln(\"FAIL \\\"\" + pat + \"\\\" pos=\" + apos + \" width=\"\n                    + awidth + \" pad=\" + apadStr + \", expected \"\n                    + pos + \" \" + width + \" \" + pad);\n        }\n    }\n\n    public void expectPat(DecimalFormat fmt, final String exp) {\n        String pat = fmt.toPattern();\n        if (pat.equals(exp)) {\n            logln(\"Ok   \\\"\" + pat + \"\\\"\");\n        } else {\n            errln(\"FAIL \\\"\" + pat + \"\\\", expected \\\"\" + exp + \"\\\"\");\n        }\n    }\n\n\n    private void expectParseCurrency(NumberFormat fmt, Currency expected, String text) {\n        ParsePosition pos = new ParsePosition(0);\n        CurrencyAmount currencyAmount = fmt.parseCurrency(text, pos);\n        assertTrue(\"Parse of \" + text + \" should have succeeded.\", pos.getIndex() > 0);\n        assertEquals(\"Currency should be correct.\", expected, currencyAmount.getCurrency());\n    }\n\n    @Test\n    public void TestJB3832(){\n        ULocale locale = new ULocale(\"pt_PT@currency=PTE\");\n        NumberFormat format = NumberFormat.getCurrencyInstance(locale);\n        Currency curr = Currency.getInstance(locale);\n        logln(\"\\nName of the currency is: \" + curr.getName(locale, Currency.LONG_NAME, new boolean[] {false}));\n        CurrencyAmount cAmt = new CurrencyAmount(1150.50, curr);\n        logln(\"CurrencyAmount object's hashCode is: \" + cAmt.hashCode()); //cover hashCode\n        String str = format.format(cAmt);\n        String expected = \"1,150$50\\u00a0\\u200b\";\n        if(!expected.equals(str)){\n            errln(\"Did not get the expected output Expected: \"+expected+\" Got: \"+ str);\n        }\n    }\n\n    @Test\n    public void TestScientificWithGrouping() {\n        // Grouping separators are not allowed in the pattern, but we can enable them via the API.\n        DecimalFormat df = new DecimalFormat(\"###0.000E0\");\n        df.setGroupingUsed(true);\n        df.setGroupingSize(3);\n        expect2(df, 123, \"123.0E0\");\n        expect2(df, 1234, \"1,234E0\");\n        expect2(df, 12340, \"1.234E4\");\n    }\n\n    @Test\n    public void TestStrictParse() {\n        // Pass both strict and lenient:\n        String[] pass = {\n                \"0\",           // single zero before end of text is not leading\n                \"0 \",          // single zero at end of number is not leading\n                \"0.\",          // single zero before period (or decimal, it's ambiguous) is not leading\n                \"0,\",          // single zero before comma (not group separator) is not leading\n                \"0.0\",         // single zero before decimal followed by digit is not leading\n                \"0. \",         // same as above before period (or decimal) is not leading\n                \"0.100,5\",     // comma stops parse of decimal (no grouping)\n                \"0.100,,5\",    // two commas also stops parse\n                \".00\",         // leading decimal is ok, even with zeros\n                \"1234567\",     // group separators are not required\n                \"12345, \",     // comma not followed by digit is not a group separator, but end of number\n                \"1,234, \",     // if group separator is present, group sizes must be appropriate\n                \"1,234,567\",   // ...secondary too\n                \"0E\",          // an exponent not followed by zero or digits is not an exponent\n                \"00\",          // leading zero before zero - used to be error - see ticket #7913\n                \"012\",         // leading zero before digit - used to be error - see ticket #7913\n                \"0,456\",       // leading zero before group separator - used to be error - see ticket #7913\n                \"999,999\",     // see ticket #6863\n                \"-99,999\",     // see ticket #6863\n                \"-999,999\",    // see ticket #6863\n                \"-9,999,999\",  // see ticket #6863\n        };\n        // Pass lenient, fail strict:\n        String[] fail = {\n                \"1,2\",       // wrong number of digits after group separator\n                \",.02\",      // leading group separator before decimal\n                \"1,.02\",     // group separator before decimal\n                \",0\",        // leading group separator before a single digit\n                \",1\",        // leading group separator before a single digit\n                \"1,45\",      // wrong number of digits in primary group\n                \"1,45 that\", // wrong number of digits in primary group\n                \"1,45.34\",   // wrong number of digits in primary group\n                \"1234,567\",  // wrong number of digits in secondary group\n                \"12,34,567\", // wrong number of digits in secondary group\n                \"1,23,456,7890\", // wrong number of digits in primary and secondary groups\n        };\n        // Fail both lenient and strict:\n        String[] failBoth = {\n        };\n\n        DecimalFormat nf = (DecimalFormat) NumberFormat.getInstance(Locale.ENGLISH);\n        runStrictParseBatch(nf, pass, fail, failBoth);\n\n        String[] scientificPass = {\n                \"0E2\",      // single zero before exponent is ok\n                \"1234E2\",   // any number of digits before exponent is ok\n                \"1,234E\",   // an exponent string not followed by zero or digits is not an exponent\n                \"00E2\",     // leading zeroes now allowed in strict mode - see ticket #\n        };\n        String[] scientificFail = {\n        };\n        String[] scientificFailBoth = {\n        };\n\n        nf = (DecimalFormat) NumberFormat.getInstance(Locale.ENGLISH);\n        runStrictParseBatch(nf, scientificPass, scientificFail, scientificFailBoth);\n\n        String[] mixedPass = {\n                \"12,34,567\",\n                \"12,34,567,\",\n                \"12,34,567, that\",\n                \"12,34,567 that\",\n        };\n        String[] mixedFail = {\n                \"12,34,56\",\n                \"12,34,56,\",\n                \"12,34,56, that \",\n                \"12,34,56 that\",\n        };\n        String[] mixedFailBoth = {\n        };\n\n        nf = new DecimalFormat(\"#,##,##0.#\");\n        runStrictParseBatch(nf, mixedPass, mixedFail, mixedFailBoth);\n    }\n\n    void runStrictParseBatch(DecimalFormat nf, String[] pass, String[] fail, String[] failBoth) {\n        nf.setParseStrict(false);\n        runStrictParseTests(\"should pass\", nf, pass, true);\n        runStrictParseTests(\"should also pass\", nf, fail, true);\n        runStrictParseTests(\"should fail\", nf, failBoth, false);\n        nf.setParseStrict(true);\n        runStrictParseTests(\"should still pass\", nf, pass, true);\n        runStrictParseTests(\"should fail\", nf, fail, false);\n        runStrictParseTests(\"should still fail\", nf, failBoth, false);\n    }\n\n    void runStrictParseTests(String msg, DecimalFormat nf, String[] tests, boolean pass) {\n        logln(\"\");\n        logln(\"pattern: '\" + nf.toPattern() + \"'\");\n        logln(msg);\n        for (int i = 0; i < tests.length; ++i) {\n            String str = tests[i];\n            ParsePosition pp = new ParsePosition(0);\n            Number n = nf.parse(str, pp);\n            String formatted = n != null ? nf.format(n) : \"null\";\n            String err = pp.getErrorIndex() == -1 ? \"\" : \"(error at \" + pp.getErrorIndex() + \")\";\n            if ((err.length() == 0) != pass) {\n                errln(\"'\" + str + \"' parsed '\" +\n                        str.substring(0, pp.getIndex()) +\n                        \"' returned \" + n + \" formats to '\" +\n                        formatted + \"' \" + err);\n            } else {\n                if (err.length() > 0) {\n                    err = \"got expected \" + err;\n                }\n                logln(\"'\" + str + \"' parsed '\" +\n                        str.substring(0, pp.getIndex()) +\n                        \"' returned \" + n + \" formats to '\" +\n                        formatted + \"' \" + err);\n            }\n        }\n    }\n\n    @Test\n    public void TestJB5251(){\n        //save default locale\n        ULocale defaultLocale = ULocale.getDefault();\n        ULocale.setDefault(new ULocale(\"qr_QR\"));\n        try {\n            NumberFormat.getInstance();\n        }\n        catch (Exception e) {\n            errln(\"Numberformat threw exception for non-existent locale. It should use the default.\");\n        }\n        //reset default locale\n        ULocale.setDefault(defaultLocale);\n    }\n\n    @Test\n    public void TestParseReturnType() {\n        String[] defaultLong = {\n                \"123\",\n                \"123.0\",\n                \"0.0\",\n                \"-9223372036854775808\", // Min Long\n                \"9223372036854775807\" // Max Long\n        };\n\n        String[] defaultNonLong = {\n                \"12345678901234567890\",\n                \"9223372036854775808\",\n                \"-9223372036854775809\"\n        };\n\n        String[] doubles = {\n                \"-0.0\",\n                \"NaN\",\n                \"\\u221E\"    // Infinity\n        };\n\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat nf = new DecimalFormat(\"#.#\", sym);\n\n        if (nf.isParseBigDecimal()) {\n            errln(\"FAIL: isParseDecimal() must return false by default\");\n        }\n\n        // isParseBigDecimal() is false\n        for (int i = 0; i < defaultLong.length; i++) {\n            try {\n                Number n = nf.parse(defaultLong[i]);\n                if (!(n instanceof Long)) {\n                    errln(\"FAIL: parse does not return Long instance\");\n                }\n            } catch (ParseException e) {\n                errln(\"parse of '\" + defaultLong[i] + \"' threw exception: \" + e);\n            }\n        }\n        for (int i = 0; i < defaultNonLong.length; i++) {\n            try {\n                Number n = nf.parse(defaultNonLong[i]);\n                if (n instanceof Long) {\n                    errln(\"FAIL: parse returned a Long\");\n                }\n            } catch (ParseException e) {\n                errln(\"parse of '\" + defaultNonLong[i] + \"' threw exception: \" + e);\n            }\n        }\n        // parse results for doubls must be always Double\n        for (int i = 0; i < doubles.length; i++) {\n            try {\n                Number n = nf.parse(doubles[i]);\n                if (!(n instanceof Double)) {\n                    errln(\"FAIL: parse does not return Double instance\");\n                }\n            } catch (ParseException e) {\n                errln(\"parse of '\" + doubles[i] + \"' threw exception: \" + e);\n            }\n        }\n\n        // force this DecimalFormat to return BigDecimal\n        nf.setParseBigDecimal(true);\n        if (!nf.isParseBigDecimal()) {\n            errln(\"FAIL: isParseBigDecimal() must return true\");\n        }\n\n        // isParseBigDecimal() is true\n        for (int i = 0; i < defaultLong.length + defaultNonLong.length; i++) {\n            String input = (i < defaultLong.length) ? defaultLong[i] : defaultNonLong[i - defaultLong.length];\n            try {\n                Number n = nf.parse(input);\n                if (!(n instanceof BigDecimal)) {\n                    errln(\"FAIL: parse does not return BigDecimal instance\");\n                }\n            } catch (ParseException e) {\n                errln(\"parse of '\" + input + \"' threw exception: \" + e);\n            }\n        }\n        // parse results for doubls must be always Double\n        for (int i = 0; i < doubles.length; i++) {\n            try {\n                Number n = nf.parse(doubles[i]);\n                if (!(n instanceof Double)) {\n                    errln(\"FAIL: parse does not return Double instance\");\n                }\n            } catch (ParseException e) {\n                errln(\"parse of '\" + doubles[i] + \"' threw exception: \" + e);\n            }\n        }\n    }\n\n    @Test\n    public void TestNonpositiveMultiplier() {\n        DecimalFormat df = new DecimalFormat(\"0\");\n\n        // test zero multiplier\n\n        try {\n            df.setMultiplier(0);\n\n            // bad\n            errln(\"DecimalFormat.setMultiplier(0) did not throw an IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            // good\n        }\n\n        // test negative multiplier\n\n        try {\n            df.setMultiplier(-1);\n\n            if (df.getMultiplier() != -1) {\n                errln(\"DecimalFormat.setMultiplier(-1) did not change the multiplier to -1\");\n                return;\n            }\n\n            // good\n        } catch (IllegalArgumentException ex) {\n            // bad\n            errln(\"DecimalFormat.setMultiplier(-1) threw an IllegalArgumentException\");\n            return;\n        }\n\n        expect(df, \"1122.123\", -1122.123);\n        expect(df, \"-1122.123\", 1122.123);\n        expect(df, \"1.2\", -1.2);\n        expect(df, \"-1.2\", 1.2);\n\n        expect2(df, Long.MAX_VALUE, BigInteger.valueOf(Long.MAX_VALUE).negate().toString());\n        expect2(df, Long.MIN_VALUE, BigInteger.valueOf(Long.MIN_VALUE).negate().toString());\n        expect2(df, Long.MAX_VALUE / 2, BigInteger.valueOf(Long.MAX_VALUE / 2).negate().toString());\n        expect2(df, Long.MIN_VALUE / 2, BigInteger.valueOf(Long.MIN_VALUE / 2).negate().toString());\n\n        expect2(df, BigDecimal.valueOf(Long.MAX_VALUE), BigDecimal.valueOf(Long.MAX_VALUE).negate().toString());\n        expect2(df, BigDecimal.valueOf(Long.MIN_VALUE), BigDecimal.valueOf(Long.MIN_VALUE).negate().toString());\n\n        expect2(df, java.math.BigDecimal.valueOf(Long.MAX_VALUE), java.math.BigDecimal.valueOf(Long.MAX_VALUE).negate().toString());\n        expect2(df, java.math.BigDecimal.valueOf(Long.MIN_VALUE), java.math.BigDecimal.valueOf(Long.MIN_VALUE).negate().toString());\n    }\n\n    @Test\n    public void TestJB5358() {\n        int numThreads = 10;\n        String numstr = \"12345\";\n        double expected = 12345;\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat fmt = new DecimalFormat(\"#.#\", sym);\n        ArrayList errors = new ArrayList();\n\n        ParseThreadJB5358[] threads = new ParseThreadJB5358[numThreads];\n        for (int i = 0; i < numThreads; i++) {\n            threads[i] = new ParseThreadJB5358((DecimalFormat)fmt.clone(), numstr, expected, errors);\n            threads[i].start();\n        }\n        for (int i = 0; i < numThreads; i++) {\n            try {\n                threads[i].join();\n            } catch (InterruptedException ie) {\n                ie.printStackTrace();\n            }\n        }\n        if (errors.size() != 0) {\n            StringBuffer errBuf = new StringBuffer();\n            for (int i = 0; i < errors.size(); i++) {\n                errBuf.append((String)errors.get(i));\n                errBuf.append(\"\\n\");\n            }\n            errln(\"FAIL: \" + errBuf);\n        }\n    }\n\n    static private class ParseThreadJB5358 extends Thread {\n        private final DecimalFormat decfmt;\n        private final String numstr;\n        private final double expect;\n        private final ArrayList errors;\n\n        public ParseThreadJB5358(DecimalFormat decfmt, String numstr, double expect, ArrayList errors) {\n            this.decfmt = decfmt;\n            this.numstr = numstr;\n            this.expect = expect;\n            this.errors = errors;\n        }\n\n        @Override\n        public void run() {\n            for (int i = 0; i < 10000; i++) {\n                try {\n                    Number n = decfmt.parse(numstr);\n                    if (n.doubleValue() != expect) {\n                        synchronized(errors) {\n                            errors.add(new String(\"Bad parse result - expected:\" + expect + \" actual:\" + n.doubleValue()));\n                        }\n                    }\n                } catch (Throwable t) {\n                    synchronized(errors) {\n                        errors.add(new String(t.getClass().getName() + \" - \" + t.getMessage()));\n                    }\n                }\n            }\n        }\n    }\n\n    @Test\n    public void TestSetCurrency() {\n        DecimalFormatSymbols decf1 = DecimalFormatSymbols.getInstance(ULocale.US);\n        DecimalFormatSymbols decf2 = DecimalFormatSymbols.getInstance(ULocale.US);\n        decf2.setCurrencySymbol(\"UKD\");\n        DecimalFormat format1 = new DecimalFormat(\"000.000\", decf1);\n        DecimalFormat format2 = new DecimalFormat(\"000.000\", decf2);\n        Currency euro = Currency.getInstance(\"EUR\");\n        format1.setCurrency(euro);\n        format2.setCurrency(euro);\n        assertEquals(\"Reset with currency symbol\", format1, format2);\n    }\n\n    /*\n     * Testing the method public StringBuffer format(Object number, ...)\n     */\n    @Test\n    public void TestFormat() {\n        NumberFormat nf = NumberFormat.getInstance();\n        StringBuffer sb = new StringBuffer(\"dummy\");\n        FieldPosition fp = new FieldPosition(0);\n\n        // Tests when \"if (number instanceof Long)\" is true\n        try {\n            nf.format(new Long(\"0\"), sb, fp);\n        } catch (Exception e) {\n            errln(\"NumberFormat.format(Object number, ...) was not suppose to \"\n                    + \"return an exception for a Long object. Error: \" + e);\n        }\n\n        // Tests when \"else if (number instanceof BigInteger)\" is true\n        try {\n            nf.format((Object)new BigInteger(\"0\"), sb, fp);\n        } catch (Exception e) {\n            errln(\"NumberFormat.format(Object number, ...) was not suppose to \"\n                    + \"return an exception for a BigInteger object. Error: \" + e);\n        }\n\n        // Tests when \"else if (number instanceof java.math.BigDecimal)\" is true\n        try {\n            nf.format((Object)new java.math.BigDecimal(\"0\"), sb, fp);\n        } catch (Exception e) {\n            errln(\"NumberFormat.format(Object number, ...) was not suppose to \"\n                    + \"return an exception for a java.math.BigDecimal object. Error: \" + e);\n        }\n\n        // Tests when \"else if (number instanceof com.ibm.icu.math.BigDecimal)\" is true\n        try {\n            nf.format((Object)new com.ibm.icu.math.BigDecimal(\"0\"), sb, fp);\n        } catch (Exception e) {\n            errln(\"NumberFormat.format(Object number, ...) was not suppose to \"\n                    + \"return an exception for a com.ibm.icu.math.BigDecimal object. Error: \" + e);\n        }\n\n        // Tests when \"else if (number instanceof CurrencyAmount)\" is true\n        try {\n            CurrencyAmount ca = new CurrencyAmount(0.0, Currency.getInstance(new ULocale(\"en_US\")));\n            nf.format((Object)ca, sb, fp);\n        } catch (Exception e) {\n            errln(\"NumberFormat.format(Object number, ...) was not suppose to \"\n                    + \"return an exception for a CurrencyAmount object. Error: \" + e);\n        }\n\n        // Tests when \"else if (number instanceof Number)\" is true\n        try {\n            nf.format(0.0, sb, fp);\n        } catch (Exception e) {\n            errln(\"NumberFormat.format(Object number, ...) was not suppose to \"\n                    + \"to return an exception for a Number object. Error: \" + e);\n        }\n\n        // Tests when \"else\" is true\n        try {\n            nf.format(new Object(), sb, fp);\n            errln(\"NumberFormat.format(Object number, ...) was suppose to \"\n                    + \"return an exception for an invalid object.\");\n        } catch (Exception e) {\n        }\n\n        try {\n            nf.format(new String(\"dummy\"), sb, fp);\n            errln(\"NumberFormat.format(Object number, ...) was suppose to \"\n                    + \"return an exception for an invalid object.\");\n        } catch (Exception e) {\n        }\n    }\n\n    /*\n     * Coverage tests for the implementation of abstract format methods not being called otherwise\n     */\n    @Test\n    public void TestFormatAbstractImplCoverage() {\n        NumberFormat df = DecimalFormat.getInstance(Locale.ENGLISH);\n        NumberFormat cdf = CompactDecimalFormat.getInstance(Locale.ENGLISH, CompactDecimalFormat.CompactStyle.SHORT);\n        NumberFormat rbf = new RuleBasedNumberFormat(ULocale.ENGLISH, RuleBasedNumberFormat.SPELLOUT);\n\n        /*\n         *  Test  NumberFormat.format(BigDecimal,StringBuffer,FieldPosition)\n         */\n        StringBuffer sb = new StringBuffer();\n        String result = df.format(new BigDecimal(2000.43), sb, new FieldPosition(0)).toString();\n        if (!\"2,000.43\".equals(result)) {\n            errln(\"DecimalFormat failed. Expected: 2,000.43 - Actual: \" + result);\n        }\n\n        sb.delete(0, sb.length());\n        result = cdf.format(new BigDecimal(2000.43), sb, new FieldPosition(0)).toString();\n        if (!\"2K\".equals(result)) {\n            errln(\"DecimalFormat failed. Expected: 2K - Actual: \" + result);\n        }\n\n        sb.delete(0, sb.length());\n        result = rbf.format(new BigDecimal(2000.43), sb, new FieldPosition(0)).toString();\n        if (!\"two thousand point four three\".equals(result)) {\n            errln(\"DecimalFormat failed. Expected: 'two thousand point four three' - Actual: '\" + result + \"'\");\n        }\n    }\n\n    /*\n     * Tests the method public final static NumberFormat getInstance(int style) public static NumberFormat\n     * getInstance(Locale inLocale, int style) public static NumberFormat getInstance(ULocale desiredLocale, int choice)\n     */\n    @Test\n    public void TestGetInstance() {\n        // Tests \"public final static NumberFormat getInstance(int style)\"\n        int maxStyle = NumberFormat.STANDARDCURRENCYSTYLE;\n\n        int[] invalid_cases = { NumberFormat.NUMBERSTYLE - 1, NumberFormat.NUMBERSTYLE - 2,\n                maxStyle + 1, maxStyle + 2 };\n\n        for (int i = NumberFormat.NUMBERSTYLE; i < maxStyle; i++) {\n            try {\n                NumberFormat.getInstance(i);\n            } catch (Exception e) {\n                errln(\"NumberFormat.getInstance(int style) was not suppose to \"\n                        + \"return an exception for passing value of \" + i);\n            }\n        }\n\n        for (int i = 0; i < invalid_cases.length; i++) {\n            try {\n                NumberFormat.getInstance(invalid_cases[i]);\n                errln(\"NumberFormat.getInstance(int style) was suppose to \"\n                        + \"return an exception for passing value of \" + invalid_cases[i]);\n            } catch (Exception e) {\n            }\n        }\n\n        // Tests \"public static NumberFormat getInstance(Locale inLocale, int style)\"\n        String[] localeCases = { \"en_US\", \"fr_FR\", \"de_DE\", \"jp_JP\" };\n\n        for (int i = NumberFormat.NUMBERSTYLE; i < maxStyle; i++) {\n            for (int j = 0; j < localeCases.length; j++) {\n                try {\n                    NumberFormat.getInstance(new Locale(localeCases[j]), i);\n                } catch (Exception e) {\n                    errln(\"NumberFormat.getInstance(Locale inLocale, int style) was not suppose to \"\n                            + \"return an exception for passing value of \" + localeCases[j] + \", \" + i);\n                }\n            }\n        }\n\n        // Tests \"public static NumberFormat getInstance(ULocale desiredLocale, int choice)\"\n        // Tests when \"if (choice < NUMBERSTYLE || choice > PLURALCURRENCYSTYLE)\" is true\n        for (int i = 0; i < invalid_cases.length; i++) {\n            try {\n                NumberFormat.getInstance((ULocale) null, invalid_cases[i]);\n                errln(\"NumberFormat.getInstance(ULocale inLocale, int choice) was not suppose to \"\n                        + \"return an exception for passing value of \" + invalid_cases[i]);\n            } catch (Exception e) {\n            }\n        }\n    }\n\n    /*\n     * Tests the class public static abstract class NumberFormatFactory\n     */\n    @Test\n    public void TestNumberFormatFactory() {\n        /*\n         * The following class allows the method public NumberFormat createFormat(Locale loc, int formatType) to be\n         * tested.\n         */\n        class TestFactory extends NumberFormatFactory {\n            @Override\n            public Set<String> getSupportedLocaleNames() {\n                return null;\n            }\n\n            @Override\n            public NumberFormat createFormat(ULocale loc, int formatType) {\n                return null;\n            }\n        }\n\n        /*\n         * The following class allows the method public NumberFormat createFormat(ULocale loc, int formatType) to be\n         * tested.\n         */\n        class TestFactory1 extends NumberFormatFactory {\n            @Override\n            public Set<String> getSupportedLocaleNames() {\n                return null;\n            }\n\n            @Override\n            public NumberFormat createFormat(Locale loc, int formatType) {\n                return null;\n            }\n        }\n\n        TestFactory tf = new TestFactory();\n        TestFactory1 tf1 = new TestFactory1();\n\n        /*\n         * Tests the method public boolean visible()\n         */\n        if (tf.visible() != true) {\n            errln(\"NumberFormatFactory.visible() was suppose to return true.\");\n        }\n\n        /*\n         * Tests the method public NumberFormat createFormat(Locale loc, int formatType)\n         */\n        if (tf.createFormat(new Locale(\"\"), 0) != null) {\n            errln(\"NumberFormatFactory.createFormat(Locale loc, int formatType) \" + \"was suppose to return null\");\n        }\n\n        /*\n         * Tests the method public NumberFormat createFormat(ULocale loc, int formatType)\n         */\n        if (tf1.createFormat(new ULocale(\"\"), 0) != null) {\n            errln(\"NumberFormatFactory.createFormat(ULocale loc, int formatType) \" + \"was suppose to return null\");\n        }\n    }\n\n    /*\n     * Tests the class public static abstract class SimpleNumberFormatFactory extends NumberFormatFactory\n     */\n    @Test\n    public void TestSimpleNumberFormatFactory() {\n        class TestSimpleNumberFormatFactory extends SimpleNumberFormatFactory {\n            /*\n             * Tests the method public SimpleNumberFormatFactory(Locale locale)\n             */\n            TestSimpleNumberFormatFactory() {\n                super(new Locale(\"\"));\n            }\n        }\n        @SuppressWarnings(\"unused\")\n        TestSimpleNumberFormatFactory tsnff = new TestSimpleNumberFormatFactory();\n    }\n\n    /*\n     * Tests the method public static ULocale[] getAvailableLocales()\n     */\n    @SuppressWarnings(\"static-access\")\n    @Test\n    public void TestGetAvailableLocales() {\n        // Tests when \"if (shim == null)\" is true\n        @SuppressWarnings(\"serial\")\n        class TestGetAvailableLocales extends NumberFormat {\n            @Override\n            public StringBuffer format(double number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public StringBuffer format(long number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public StringBuffer format(BigInteger number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public StringBuffer format(java.math.BigDecimal number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public StringBuffer format(BigDecimal number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public Number parse(String text, ParsePosition parsePosition) {\n                return null;\n            }\n        }\n\n        try {\n            TestGetAvailableLocales test = new TestGetAvailableLocales();\n            test.getAvailableLocales();\n        } catch (Exception e) {\n            errln(\"NumberFormat.getAvailableLocales() was not suppose to \"\n                    + \"return an exception when getting getting available locales.\");\n        }\n    }\n\n    /*\n     * Tests the method public void setMinimumIntegerDigits(int newValue)\n     */\n    @Test\n    public void TestSetMinimumIntegerDigits() {\n        NumberFormat nf = NumberFormat.getInstance();\n        // For valid array, it is displayed as {min value, max value}\n        // Tests when \"if (minimumIntegerDigits > maximumIntegerDigits)\" is true\n        int[][] cases = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 2, 0 }, { 2, 1 }, { 10, 0 } };\n        int[] expectedMax = { 1, 1, 0, 0, 1, 0 };\n        if (cases.length != expectedMax.length) {\n            errln(\"Can't continue test case method TestSetMinimumIntegerDigits \"\n                    + \"since the test case arrays are unequal.\");\n        } else {\n            for (int i = 0; i < cases.length; i++) {\n                nf.setMinimumIntegerDigits(cases[i][0]);\n                nf.setMaximumIntegerDigits(cases[i][1]);\n                if (nf.getMaximumIntegerDigits() != expectedMax[i]) {\n                    errln(\"NumberFormat.setMinimumIntegerDigits(int newValue \"\n                            + \"did not return an expected result for parameter \" + cases[i][0] + \" and \" + cases[i][1]\n                                    + \" and expected \" + expectedMax[i] + \" but got \" + nf.getMaximumIntegerDigits());\n                }\n            }\n        }\n    }\n\n    /*\n     * Tests the method public int getRoundingMode() public void setRoundingMode(int roundingMode)\n     */\n    @Test\n    public void TestRoundingMode() {\n        @SuppressWarnings(\"serial\")\n        class TestRoundingMode extends NumberFormat {\n            @Override\n            public StringBuffer format(double number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public StringBuffer format(long number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public StringBuffer format(BigInteger number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public StringBuffer format(java.math.BigDecimal number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public StringBuffer format(BigDecimal number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public Number parse(String text, ParsePosition parsePosition) {\n                return null;\n            }\n        }\n        TestRoundingMode tgrm = new TestRoundingMode();\n\n        // Tests the function 'public void setRoundingMode(int roundingMode)'\n        try {\n            tgrm.setRoundingMode(0);\n            errln(\"NumberFormat.setRoundingMode(int) was suppose to return an exception\");\n        } catch (Exception e) {\n        }\n\n        // Tests the function 'public int getRoundingMode()'\n        try {\n            tgrm.getRoundingMode();\n            errln(\"NumberFormat.getRoundingMode() was suppose to return an exception\");\n        } catch (Exception e) {\n        }\n    }\n\n    /*\n     * Testing lenient decimal/grouping separator parsing\n     */\n    @Test\n    public void TestLenientSymbolParsing() {\n        DecimalFormat fmt = new DecimalFormat();\n        DecimalFormatSymbols sym = new DecimalFormatSymbols();\n\n        expect(fmt, \"12\\u300234\", 12.34);\n\n        // Ticket#7345 - case 1\n        // Even strict parsing, the decimal separator set in the symbols\n        // should be successfully parsed.\n\n        sym.setDecimalSeparator('\\u3002');\n\n        // non-strict\n        fmt.setDecimalFormatSymbols(sym);\n\n        // strict - failed before the fix for #7345\n        fmt.setParseStrict(true);\n        expect(fmt, \"23\\u300245\", 23.45);\n        fmt.setParseStrict(false);\n\n\n        // Ticket#7345 - case 2\n        // Decimal separator variants other than DecimalFormatSymbols.decimalSeparator\n        // should not hide the grouping separator DecimalFormatSymbols.groupingSeparator.\n        sym.setDecimalSeparator('.');\n        sym.setGroupingSeparator(',');\n        fmt.setDecimalFormatSymbols(sym);\n\n        expect(fmt, \"1,234.56\", 1234.56);\n\n        sym.setGroupingSeparator('\\uFF61');\n        fmt.setDecimalFormatSymbols(sym);\n\n        expect(fmt, \"2\\uFF61345.67\", 2345.67);\n\n        // Ticket#7128\n        //\n        sym.setGroupingSeparator(',');\n        fmt.setDecimalFormatSymbols(sym);\n\n        String skipExtSepParse = ICUConfig.get(\"com.ibm.icu.text.DecimalFormat.SkipExtendedSeparatorParsing\", \"false\");\n        if (skipExtSepParse.equals(\"true\")) {\n            // When the property SkipExtendedSeparatorParsing is true,\n            // DecimalFormat does not use the extended equivalent separator\n            // data and only uses the one in DecimalFormatSymbols.\n            expect(fmt, \"23 456\", 23);\n        } else {\n            // Lenient separator parsing is enabled by default.\n            // A space character below is interpreted as a\n            // group separator, even ',' is used as grouping\n            // separator in the symbols.\n            expect(fmt, \"12 345\", 12345);\n        }\n    }\n\n    /*\n     * Testing currency driven max/min fraction digits problem\n     * reported by ticket#7282\n     */\n    @Test\n    public void TestCurrencyFractionDigits() {\n        double value = 99.12345;\n\n        // Create currency instance\n        NumberFormat cfmt  = NumberFormat.getCurrencyInstance(new ULocale(\"ja_JP\"));\n        String text1 = cfmt.format(value);\n\n        // Reset the same currency and format the test value again\n        cfmt.setCurrency(cfmt.getCurrency());\n        String text2 = cfmt.format(value);\n\n        // output1 and output2 must be identical\n        if (!text1.equals(text2)) {\n            errln(\"NumberFormat.format() should return the same result - text1=\"\n                    + text1 + \" text2=\" + text2);\n        }\n    }\n\n    /*\n     * Testing rounding to negative zero problem\n     * reported by ticket#7609\n     */\n    @Test\n    public void TestNegZeroRounding() {\n\n        DecimalFormat df = (DecimalFormat) NumberFormat.getInstance();\n        df.setRoundingMode(MathContext.ROUND_HALF_UP);\n        df.setMinimumFractionDigits(1);\n        df.setMaximumFractionDigits(1);\n        String text1 = df.format(-0.01);\n\n        df.setRoundingIncrement(0.1);\n        String text2 = df.format(-0.01);\n\n        // output1 and output2 must be identical\n        if (!text1.equals(text2)) {\n            errln(\"NumberFormat.format() should return the same result - text1=\"\n                    + text1 + \" text2=\" + text2);\n        }\n\n    }\n\n    @Test\n    public void TestCurrencyAmountCoverage() {\n        CurrencyAmount ca, cb;\n\n        try {\n            ca = new CurrencyAmount(null, (Currency) null);\n            errln(\"NullPointerException should have been thrown.\");\n        } catch (NullPointerException ex) {\n        }\n        try {\n            ca = new CurrencyAmount(new Integer(0), (Currency) null);\n            errln(\"NullPointerException should have been thrown.\");\n        } catch (NullPointerException ex) {\n        }\n\n        ca = new CurrencyAmount(new Integer(0), Currency.getInstance(new ULocale(\"ja_JP\")));\n        cb = new CurrencyAmount(new Integer(1), Currency.getInstance(new ULocale(\"ja_JP\")));\n        if (ca.equals(null)) {\n            errln(\"Comparison should return false.\");\n        }\n        if (!ca.equals(ca)) {\n            errln(\"Comparision should return true.\");\n        }\n        if (ca.equals(cb)) {\n            errln(\"Comparison should return false.\");\n        }\n    }\n\n    @Test\n    public void TestExponentParse() {\n        ParsePosition parsePos = new ParsePosition(0);\n        DecimalFormatSymbols symbols = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat fmt = new DecimalFormat(\"#####\", symbols);\n        Number result = fmt.parse(\"5.06e-27\", parsePos);\n        if ( result.doubleValue() != 5.06E-27 || parsePos.getIndex() != 8) {\n            errln(\"ERROR: ERROR: parse failed - expected 5.06E-27, 8; got \" + result.doubleValue() + \", \" + parsePos.getIndex());\n        }\n    }\n\n    @Test\n    public void TestExplicitParents() {\n        // We use these for testing because decimal and grouping separators will be inherited from es_419\n        // starting with CLDR 2.0\n        String[] DATA = {\n                \"es\", \"CO\", \"\", \"1.250,75\",\n                \"es\", \"ES\", \"\", \"1.250,75\",\n                \"es\", \"GQ\", \"\", \"1.250,75\",\n                \"es\", \"MX\", \"\", \"1,250.75\",\n                \"es\", \"US\", \"\", \"1,250.75\",\n                \"es\", \"VE\", \"\", \"1.250,75\",\n\n        };\n\n        for (int i=0; i<DATA.length; i+=4) {\n            Locale locale = new Locale(DATA[i], DATA[i+1], DATA[i+2]);\n            NumberFormat fmt = NumberFormat.getInstance(locale);\n            String s = fmt.format(1250.75);\n            if (s.equals(DATA[i+3])) {\n                logln(\"Ok: 1250.75 x \" + locale + \" => \" + s);\n            } else {\n                errln(\"FAIL: 1250.75 x \" + locale + \" => \" + s +\n                        \", expected \" + DATA[i+3]);\n            }\n        }\n    }\n\n    /*\n     * Test case for #9240\n     * ICU4J 49.1 DecimalFormat did not clone the internal object holding\n     * formatted text attribute information properly. Therefore, DecimalFormat\n     * created by cloning may return incorrect results or may throw an exception\n     * when formatToCharacterIterator is invoked from multiple threads.\n     */\n    @Test\n    public void TestFormatToCharacterIteratorThread() {\n        final int COUNT = 10;\n\n        DecimalFormat fmt1 = new DecimalFormat(\"#0\");\n        DecimalFormat fmt2 = (DecimalFormat)fmt1.clone();\n\n        int[] res1 = new int[COUNT];\n        int[] res2 = new int[COUNT];\n\n        Thread t1 = new Thread(new FormatCharItrTestThread(fmt1, 1, res1));\n        Thread t2 = new Thread(new FormatCharItrTestThread(fmt2, 100, res2));\n\n        t1.start();\n        t2.start();\n\n        try {\n            t1.join();\n            t2.join();\n        } catch (InterruptedException e) {\n            //TODO\n        }\n\n        int val1 = res1[0];\n        int val2 = res2[0];\n\n        for (int i = 0; i < COUNT; i++) {\n            if (res1[i] != val1) {\n                errln(\"Inconsistent first run limit in test thread 1\");\n            }\n            if (res2[i] != val2) {\n                errln(\"Inconsistent first run limit in test thread 2\");\n            }\n        }\n    }\n\n    /*\n     * This feature had to do with a limitation in DigitList.java that no longer exists in the\n     * new implementation.\n     *\n    @Test\n    public void TestParseMaxDigits() {\n        DecimalFormat fmt = new DecimalFormat();\n        String number = \"100000000000\";\n        int newParseMax = number.length() - 1;\n\n        fmt.setParseMaxDigits(-1);\n\n        // Default value is 1000\n        if (fmt.getParseMaxDigits() != 1000) {\n            errln(\"Fail valid value checking in setParseMaxDigits.\");\n        }\n\n        try {\n            if (fmt.parse(number).doubleValue() == Float.POSITIVE_INFINITY) {\n                errln(\"Got Infinity but should NOT when parsing number: \" + number);\n            }\n\n            fmt.setParseMaxDigits(newParseMax);\n\n            if (fmt.parse(number).doubleValue() != Float.POSITIVE_INFINITY) {\n                errln(\"Did not get Infinity but should when parsing number: \" + number);\n            }\n        } catch (ParseException ex) {\n\n        }\n    }\n    */\n\n    private static class FormatCharItrTestThread implements Runnable {\n        private final NumberFormat fmt;\n        private final int num;\n        private final int[] result;\n\n        FormatCharItrTestThread(NumberFormat fmt, int num, int[] result) {\n            this.fmt = fmt;\n            this.num = num;\n            this.result = result;\n        }\n\n        @Override\n        public void run() {\n            for (int i = 0; i < result.length; i++) {\n                AttributedCharacterIterator acitr = fmt.formatToCharacterIterator(num);\n                acitr.first();\n                result[i] = acitr.getRunLimit();\n            }\n        }\n    }\n\n    @Test\n    public void TestRoundingBehavior() {\n        final Object[][] TEST_CASES = {\n                {\n                    ULocale.US,                             // ULocale - null for default locale\n                    \"#.##\",                                 // Pattern\n                    Integer.valueOf(BigDecimal.ROUND_DOWN), // Rounding Mode or null (implicit)\n                    Double.valueOf(0.0d),                   // Rounding increment, Double or BigDecimal, or null (implicit)\n                    Double.valueOf(123.4567d),              // Input value, Long, Double, BigInteger or BigDecimal\n                    \"123.45\"                                // Expected result, null for exception\n                },\n                {\n                    ULocale.US,\n                    \"#.##\",\n                    null,\n                    Double.valueOf(0.1d),\n                    Double.valueOf(123.4567d),\n                    \"123.5\"\n                },\n                {\n                    ULocale.US,\n                    \"#.##\",\n                    Integer.valueOf(BigDecimal.ROUND_DOWN),\n                    Double.valueOf(0.1d),\n                    Double.valueOf(123.4567d),\n                    \"123.4\"\n                },\n                {\n                    ULocale.US,\n                    \"#.##\",\n                    Integer.valueOf(BigDecimal.ROUND_UNNECESSARY),\n                    null,\n                    Double.valueOf(123.4567d),\n                    null\n                },\n                {\n                    ULocale.US,\n                    \"#.##\",\n                    Integer.valueOf(BigDecimal.ROUND_DOWN),\n                    null,\n                    Long.valueOf(1234),\n                    \"1234\"\n                },\n        };\n\n        int testNum = 1;\n\n        for (Object[] testCase : TEST_CASES) {\n            // 0: locale\n            // 1: pattern\n            ULocale locale = testCase[0] == null ? ULocale.getDefault() : (ULocale)testCase[0];\n            String pattern = (String)testCase[1];\n\n            DecimalFormat fmt = new DecimalFormat(pattern, DecimalFormatSymbols.getInstance(locale));\n\n            // 2: rounding mode\n            Integer roundingMode = null;\n            if (testCase[2] != null) {\n                roundingMode = (Integer)testCase[2];\n                fmt.setRoundingMode(roundingMode);\n            }\n\n            // 3: rounding increment\n            if (testCase[3] != null) {\n                if (testCase[3] instanceof Double) {\n                    fmt.setRoundingIncrement((Double)testCase[3]);\n                } else if (testCase[3] instanceof BigDecimal) {\n                    fmt.setRoundingIncrement((BigDecimal)testCase[3]);\n                } else if (testCase[3] instanceof java.math.BigDecimal) {\n                    fmt.setRoundingIncrement((java.math.BigDecimal)testCase[3]);\n                }\n            }\n\n            // 4: input number\n            String s = null;\n            boolean bException = false;\n            try {\n                s = fmt.format(testCase[4]);\n            } catch (ArithmeticException e) {\n                bException = true;\n            }\n\n            if (bException) {\n                if (testCase[5] != null) {\n                    errln(\"Test case #\" + testNum + \": ArithmeticException was thrown.\");\n                }\n            } else {\n                if (testCase[5] == null) {\n                    errln(\"Test case #\" + testNum +\n                            \": ArithmeticException must be thrown, but got formatted result: \" +\n                            s);\n                } else {\n                    assertEquals(\"Test case #\" + testNum, testCase[5], s);\n                }\n            }\n\n            testNum++;\n        }\n    }\n\n    @Test\n    public void TestSignificantDigits() {\n        double input[] = {\n                0, 0,\n                123, -123,\n                12345, -12345,\n                123.45, -123.45,\n                123.44501, -123.44501,\n                0.001234, -0.001234,\n                0.00000000123, -0.00000000123,\n                0.0000000000000000000123, -0.0000000000000000000123,\n                1.2, -1.2,\n                0.0000000012344501, -0.0000000012344501,\n                123445.01, -123445.01,\n                12344501000000000000000000000000000.0, -12344501000000000000000000000000000.0,\n        };\n        String[] expected = {\n                \"0.00\", \"0.00\",\n                \"123\", \"-123\",\n                \"12345\", \"-12345\",\n                \"123.45\", \"-123.45\",\n                \"123.45\", \"-123.45\",\n                \"0.001234\", \"-0.001234\",\n                \"0.00000000123\", \"-0.00000000123\",\n                \"0.0000000000000000000123\", \"-0.0000000000000000000123\",\n                \"1.20\", \"-1.20\",\n                \"0.0000000012345\", \"-0.0000000012345\",\n                \"123450\", \"-123450\",\n                \"12345000000000000000000000000000000\", \"-12345000000000000000000000000000000\",\n        };\n        DecimalFormat numberFormat =\n                (DecimalFormat) NumberFormat.getInstance(ULocale.US);\n        numberFormat.setSignificantDigitsUsed(true);\n        numberFormat.setMinimumSignificantDigits(3);\n        numberFormat.setMaximumSignificantDigits(5);\n        numberFormat.setGroupingUsed(false);\n        for (int i = 0; i < input.length; i++) {\n            assertEquals(\"TestSignificantDigits\", expected[i], numberFormat.format(input[i]));\n        }\n\n        // Test for ICU-20063\n        {\n            DecimalFormat df = new DecimalFormat(\"0.######\", DecimalFormatSymbols.getInstance(ULocale.US));\n            df.setSignificantDigitsUsed(true);\n            expect(df, 9.87654321, \"9.87654\");\n            df.setMaximumSignificantDigits(3);\n            expect(df, 9.87654321, \"9.88\");\n            // setSignificantDigitsUsed with maxSig only\n            df.setSignificantDigitsUsed(true);\n            expect(df, 9.87654321, \"9.88\");\n            df.setMinimumSignificantDigits(2);\n            expect(df, 9, \"9.0\");\n            // setSignificantDigitsUsed with both minSig and maxSig\n            df.setSignificantDigitsUsed(true);\n            expect(df, 9, \"9.0\");\n            // setSignificantDigitsUsed to false: should revert to fraction rounding\n            df.setSignificantDigitsUsed(false);\n            expect(df, 9.87654321, \"9.876543\");\n            expect(df, 9, \"9\");\n            df.setSignificantDigitsUsed(true);\n            df.setMinimumSignificantDigits(2);\n            expect(df, 9.87654321, \"9.87654\");\n            expect(df, 9, \"9.0\");\n            // setSignificantDigitsUsed with minSig only\n            df.setSignificantDigitsUsed(true);\n            expect(df, 9.87654321, \"9.87654\");\n            expect(df, 9, \"9.0\");\n        }\n    }\n\n    @Test\n    public void TestBug9936() {\n        DecimalFormat numberFormat =\n                (DecimalFormat) NumberFormat.getInstance(ULocale.US);\n        assertFalse(\"\", numberFormat.areSignificantDigitsUsed());\n\n        numberFormat.setSignificantDigitsUsed(true);\n        assertTrue(\"\", numberFormat.areSignificantDigitsUsed());\n\n        numberFormat.setSignificantDigitsUsed(false);\n        assertFalse(\"\", numberFormat.areSignificantDigitsUsed());\n\n        numberFormat.setMinimumSignificantDigits(3);\n        assertTrue(\"\", numberFormat.areSignificantDigitsUsed());\n\n        numberFormat.setSignificantDigitsUsed(false);\n        numberFormat.setMaximumSignificantDigits(6);\n        assertTrue(\"\", numberFormat.areSignificantDigitsUsed());\n    }\n\n    @Test\n    public void TestShowZero() {\n        DecimalFormat numberFormat =\n                (DecimalFormat) NumberFormat.getInstance(ULocale.US);\n        numberFormat.setSignificantDigitsUsed(true);\n        numberFormat.setMaximumSignificantDigits(3);\n        assertEquals(\"TestShowZero\", \"0\", numberFormat.format(0.0));\n    }\n\n    @Test\n    public void TestCurrencyPlurals() {\n        String[][] tests = {\n                {\"en\", \"USD\", \"1\", \"1 US dollar\"},\n                {\"en\", \"USD\", \"1.0\", \"1.0 US dollars\"},\n                {\"en\", \"USD\", \"1.00\", \"1.00 US dollars\"},\n                {\"en\", \"USD\", \"1.99\", \"1.99 US dollars\"},\n                {\"en\", \"AUD\", \"1\", \"1 Australian dollar\"},\n                {\"en\", \"AUD\", \"1.00\", \"1.00 Australian dollars\"},\n                {\"sl\", \"USD\", \"1\", \"1 ameri\\u0161ki dolar\"},\n                {\"sl\", \"USD\", \"2\", \"2 ameri\\u0161ka dolarja\"},\n                {\"sl\", \"USD\", \"3\", \"3 ameri\\u0161ki dolarji\"},\n                {\"sl\", \"USD\", \"5\", \"5 ameri\u0161kih dolarjev\"},\n                {\"fr\", \"USD\", \"1.99\", \"1,99 dollar des \u00c9tats-Unis\"},\n                {\"ru\", \"RUB\", \"1\", \"1 \\u0440\\u043E\\u0441\\u0441\\u0438\\u0439\\u0441\\u043A\\u0438\\u0439 \\u0440\\u0443\\u0431\\u043B\\u044C\"},\n                {\"ru\", \"RUB\", \"2\", \"2 \\u0440\\u043E\\u0441\\u0441\\u0438\\u0439\\u0441\\u043A\\u0438\\u0445 \\u0440\\u0443\\u0431\\u043B\\u044F\"},\n                {\"ru\", \"RUB\", \"5\", \"5 \\u0440\\u043E\\u0441\\u0441\\u0438\\u0439\\u0441\\u043A\\u0438\\u0445 \\u0440\\u0443\\u0431\\u043B\\u0435\\u0439\"},\n        };\n        for (String test[] : tests) {\n            DecimalFormat numberFormat = (DecimalFormat) DecimalFormat.getInstance(new ULocale(test[0]), NumberFormat.PLURALCURRENCYSTYLE);\n            numberFormat.setCurrency(Currency.getInstance(test[1]));\n            double number = Double.parseDouble(test[2]);\n            int dotPos = test[2].indexOf('.');\n            int decimals = dotPos < 0 ? 0 : test[2].length() - dotPos - 1;\n            int digits = dotPos < 0 ? test[2].length() : test[2].length() - 1;\n            numberFormat.setMaximumFractionDigits(decimals);\n            numberFormat.setMinimumFractionDigits(decimals);\n            String actual = numberFormat.format(number);\n            assertEquals(test[0] + \"\\t\" + test[1] + \"\\t\" + test[2], test[3], actual);\n            numberFormat.setMaximumSignificantDigits(digits);\n            numberFormat.setMinimumSignificantDigits(digits);\n            actual = numberFormat.format(number);\n            assertEquals(test[0] + \"\\t\" + test[1] + \"\\t\" + test[2], test[3], actual);\n        }\n    }\n\n    @Test\n    public void TestCustomCurrencySignAndSeparator() {\n        DecimalFormatSymbols custom = new DecimalFormatSymbols(ULocale.US);\n\n        custom.setCurrencySymbol(\"*\");\n        custom.setMonetaryGroupingSeparator('^');\n        custom.setMonetaryDecimalSeparator(':');\n\n        DecimalFormat fmt = new DecimalFormat(\"\\u00A4 #,##0.00\", custom);\n\n        final String numstr = \"* 1^234:56\";\n        expect2(fmt, 1234.56, numstr);\n    }\n\n    @Test\n    public void TestParseSignsAndMarks() {\n        class SignsAndMarksItem {\n            public String locale;\n            public boolean lenient;\n            public String numString;\n            public double value;\n             // Simple constructor\n            public SignsAndMarksItem(String loc, boolean lnt, String numStr, double val) {\n                locale = loc;\n                lenient = lnt;\n                numString = numStr;\n                value = val;\n            }\n        };\n        final SignsAndMarksItem[] items = {\n            // *** Note, ICU4J lenient number parsing does not handle arbitrary whitespace, but can\n            // treat some whitespace as a grouping separator. The cases marked *** below depend\n            // on isGroupingUsed() being set for the locale, which in turn depends on grouping\n            // separators being present in the decimalFormat pattern for the locale (& num sys).\n            //\n            //                    locale                lenient numString                               value\n            new SignsAndMarksItem(\"en\",                 false,  \"12\",                                    12 ),\n            new SignsAndMarksItem(\"en\",                 true,   \"12\",                                    12 ),\n            new SignsAndMarksItem(\"en\",                 false,  \"-23\",                                  -23 ),\n            new SignsAndMarksItem(\"en\",                 true,   \"-23\",                                  -23 ),\n            new SignsAndMarksItem(\"en\",                 true,   \"- 23\",                                 -23 ), // ***\n            new SignsAndMarksItem(\"en\",                 false,  \"\\u200E-23\",                            -23 ),\n            new SignsAndMarksItem(\"en\",                 true,   \"\\u200E-23\",                            -23 ),\n            new SignsAndMarksItem(\"en\",                 true,   \"\\u200E- 23\",                           -23 ), // ***\n\n            new SignsAndMarksItem(\"en@numbers=arab\",    false,  \"\\u0663\\u0664\",                          34 ),\n            new SignsAndMarksItem(\"en@numbers=arab\",    true,   \"\\u0663\\u0664\",                          34 ),\n            new SignsAndMarksItem(\"en@numbers=arab\",    false,  \"-\\u0664\\u0665\",                        -45 ),\n            new SignsAndMarksItem(\"en@numbers=arab\",    true,   \"-\\u0664\\u0665\",                        -45 ),\n            new SignsAndMarksItem(\"en@numbers=arab\",    true,   \"- \\u0664\\u0665\",                       -45 ), // ***\n            new SignsAndMarksItem(\"en@numbers=arab\",    false,  \"\\u200F-\\u0664\\u0665\",                  -45 ),\n            new SignsAndMarksItem(\"en@numbers=arab\",    true,   \"\\u200F-\\u0664\\u0665\",                  -45 ),\n            new SignsAndMarksItem(\"en@numbers=arab\",    true,   \"\\u200F- \\u0664\\u0665\",                 -45 ), // ***\n\n            new SignsAndMarksItem(\"en@numbers=arabext\", false,  \"\\u06F5\\u06F6\",                          56 ),\n            new SignsAndMarksItem(\"en@numbers=arabext\", true,   \"\\u06F5\\u06F6\",                          56 ),\n            new SignsAndMarksItem(\"en@numbers=arabext\", false,  \"-\\u06F6\\u06F7\",                        -67 ),\n            new SignsAndMarksItem(\"en@numbers=arabext\", true,   \"-\\u06F6\\u06F7\",                        -67 ),\n            new SignsAndMarksItem(\"en@numbers=arabext\", true,   \"- \\u06F6\\u06F7\",                       -67 ), // ***\n            new SignsAndMarksItem(\"en@numbers=arabext\", false,  \"\\u200E-\\u200E\\u06F6\\u06F7\",            -67 ),\n            new SignsAndMarksItem(\"en@numbers=arabext\", true,   \"\\u200E-\\u200E\\u06F6\\u06F7\",            -67 ),\n            new SignsAndMarksItem(\"en@numbers=arabext\", true,   \"\\u200E-\\u200E \\u06F6\\u06F7\",           -67 ), // ***\n\n            new SignsAndMarksItem(\"he\",                 false,  \"12\",                                    12 ),\n            new SignsAndMarksItem(\"he\",                 true,   \"12\",                                    12 ),\n            new SignsAndMarksItem(\"he\",                 false,  \"-23\",                                  -23 ),\n            new SignsAndMarksItem(\"he\",                 true,   \"-23\",                                  -23 ),\n            new SignsAndMarksItem(\"he\",                 true,   \"- 23\",                                 -23 ), // ***\n            new SignsAndMarksItem(\"he\",                 false,  \"\\u200E-23\",                            -23 ),\n            new SignsAndMarksItem(\"he\",                 true,   \"\\u200E-23\",                            -23 ),\n            new SignsAndMarksItem(\"he\",                 true,   \"\\u200E- 23\",                           -23 ), // ***\n\n            new SignsAndMarksItem(\"ar\",                 false,  \"\\u0663\\u0664\",                          34 ),\n            new SignsAndMarksItem(\"ar\",                 true,   \"\\u0663\\u0664\",                          34 ),\n            new SignsAndMarksItem(\"ar\",                 false,  \"-\\u0664\\u0665\",                        -45 ),\n            new SignsAndMarksItem(\"ar\",                 true,   \"-\\u0664\\u0665\",                        -45 ),\n            new SignsAndMarksItem(\"ar\",                 true,   \"- \\u0664\\u0665\",                       -45 ), // ***\n            new SignsAndMarksItem(\"ar\",                 false,  \"\\u200F-\\u0664\\u0665\",                  -45 ),\n            new SignsAndMarksItem(\"ar\",                 true,   \"\\u200F-\\u0664\\u0665\",                  -45 ),\n            new SignsAndMarksItem(\"ar\",                 true,   \"\\u200F- \\u0664\\u0665\",                 -45 ), // ***\n\n            new SignsAndMarksItem(\"ar_MA\",              false,  \"12\",                                    12 ),\n            new SignsAndMarksItem(\"ar_MA\",              true,   \"12\",                                    12 ),\n            new SignsAndMarksItem(\"ar_MA\",              false,  \"-23\",                                  -23 ),\n            new SignsAndMarksItem(\"ar_MA\",              true,   \"-23\",                                  -23 ),\n            new SignsAndMarksItem(\"ar_MA\",              true,   \"- 23\",                                 -23 ), // ***\n            new SignsAndMarksItem(\"ar_MA\",              false,  \"\\u200E-23\",                            -23 ),\n            new SignsAndMarksItem(\"ar_MA\",              true,   \"\\u200E-23\",                            -23 ),\n            new SignsAndMarksItem(\"ar_MA\",              true,   \"\\u200E- 23\",                           -23 ), // ***\n\n            new SignsAndMarksItem(\"fa\",                 false,  \"\\u06F5\\u06F6\",                          56 ),\n            new SignsAndMarksItem(\"fa\",                 true,   \"\\u06F5\\u06F6\",                          56 ),\n            new SignsAndMarksItem(\"fa\",                 false,  \"\\u2212\\u06F6\\u06F7\",                   -67 ),\n            new SignsAndMarksItem(\"fa\",                 true,   \"\\u2212\\u06F6\\u06F7\",                   -67 ),\n            new SignsAndMarksItem(\"fa\",                 true,   \"\\u2212 \\u06F6\\u06F7\",                  -67 ), // ***\n            new SignsAndMarksItem(\"fa\",                 false,  \"\\u200E\\u2212\\u200E\\u06F6\\u06F7\",       -67 ),\n            new SignsAndMarksItem(\"fa\",                 true,   \"\\u200E\\u2212\\u200E\\u06F6\\u06F7\",       -67 ),\n            new SignsAndMarksItem(\"fa\",                 true,   \"\\u200E\\u2212\\u200E \\u06F6\\u06F7\",      -67 ), // ***\n\n            new SignsAndMarksItem(\"ps\",                 false,  \"\\u06F5\\u06F6\",                          56 ),\n            new SignsAndMarksItem(\"ps\",                 true,   \"\\u06F5\\u06F6\",                          56 ),\n            new SignsAndMarksItem(\"ps\",                 false,  \"-\\u06F6\\u06F7\",                        -67 ),\n            new SignsAndMarksItem(\"ps\",                 true,   \"-\\u06F6\\u06F7\",                        -67 ),\n            new SignsAndMarksItem(\"ps\",                 true,   \"- \\u06F6\\u06F7\",                       -67 ), // ***\n            new SignsAndMarksItem(\"ps\",                 false,  \"\\u200E-\\u200E\\u06F6\\u06F7\",            -67 ),\n            new SignsAndMarksItem(\"ps\",                 true,   \"\\u200E-\\u200E\\u06F6\\u06F7\",            -67 ),\n            new SignsAndMarksItem(\"ps\",                 true,   \"\\u200E-\\u200E \\u06F6\\u06F7\",           -67 ), // ***\n            new SignsAndMarksItem(\"ps\",                 false,  \"-\\u200E\\u06F6\\u06F7\",                  -67 ),\n            new SignsAndMarksItem(\"ps\",                 true,   \"-\\u200E\\u06F6\\u06F7\",                  -67 ),\n            new SignsAndMarksItem(\"ps\",                 true,   \"-\\u200E \\u06F6\\u06F7\",                 -67 ), // ***\n        };\n        for (SignsAndMarksItem item: items) {\n            ULocale locale = new ULocale(item.locale);\n            NumberFormat numfmt = NumberFormat.getInstance(locale);\n            if (numfmt != null) {\n                numfmt.setParseStrict(!item.lenient);\n                ParsePosition ppos = new ParsePosition(0);\n                Number num = numfmt.parse(item.numString, ppos);\n                if (num != null && ppos.getIndex() == item.numString.length()) {\n                    double parsedValue = num.doubleValue();\n                    if (parsedValue != item.value) {\n                        errln(\"FAIL: locale \" + item.locale + \", lenient \" + item.lenient + \", parse of \\\"\" + item.numString + \"\\\" gives value \" + parsedValue);\n                    }\n                } else {\n                    errln(\"FAIL: locale \" + item.locale + \", lenient \" + item.lenient + \", parse of \\\"\" + item.numString + \"\\\" gives position \" + ppos.getIndex());\n                }\n            } else {\n                errln(\"FAIL: NumberFormat.getInstance for locale \" + item.locale);\n            }\n        }\n    }\n\n    @Test\n    public void TestContext() {\n        // just a minimal sanity check for now\n        NumberFormat nfmt = NumberFormat.getInstance();\n        DisplayContext context = nfmt.getContext(DisplayContext.Type.CAPITALIZATION);\n        if (context != DisplayContext.CAPITALIZATION_NONE) {\n            errln(\"FAIL: Initial NumberFormat.getContext() is not CAPITALIZATION_NONE\");\n        }\n        nfmt.setContext(DisplayContext.CAPITALIZATION_FOR_STANDALONE);\n        context = nfmt.getContext(DisplayContext.Type.CAPITALIZATION);\n        if (context != DisplayContext.CAPITALIZATION_FOR_STANDALONE) {\n            errln(\"FAIL: NumberFormat.getContext() does not return the value set, CAPITALIZATION_FOR_STANDALONE\");\n        }\n    }\n\n    @Test\n    public void TestAccountingCurrency() {\n        String[][] tests = {\n                //locale              num         curr fmt per loc     curr std fmt         curr acct fmt        rt\n                {\"en_US\",             \"1234.5\",   \"$1,234.50\",         \"$1,234.50\",         \"$1,234.50\",         \"true\"},\n                {\"en_US@cf=account\",  \"1234.5\",   \"$1,234.50\",         \"$1,234.50\",         \"$1,234.50\",         \"true\"},\n                {\"en_US\",             \"-1234.5\",  \"-$1,234.50\",        \"-$1,234.50\",        \"($1,234.50)\",       \"true\"},\n                {\"en_US@cf=standard\", \"-1234.5\",  \"-$1,234.50\",        \"-$1,234.50\",        \"($1,234.50)\",       \"true\"},\n                {\"en_US@cf=account\",  \"-1234.5\",  \"($1,234.50)\",       \"-$1,234.50\",        \"($1,234.50)\",       \"true\"},\n                {\"en_US\",             \"0\",        \"$0.00\",             \"$0.00\",             \"$0.00\",             \"true\"},\n                {\"en_US\",             \"-0.2\",     \"-$0.20\",            \"-$0.20\",            \"($0.20)\",           \"true\"},\n                {\"en_US@cf=standard\", \"-0.2\",     \"-$0.20\",            \"-$0.20\",            \"($0.20)\",           \"true\"},\n                {\"en_US@cf=account\",  \"-0.2\",     \"($0.20)\",           \"-$0.20\",            \"($0.20)\",           \"true\"},\n                {\"ja_JP\",             \"10000\",    \"\uffe510,000\",          \"\uffe510,000\",          \"\uffe510,000\",          \"true\" },\n                {\"ja_JP\",             \"-1000.5\",  \"-\uffe51,000\",          \"-\uffe51,000\",          \"(\uffe51,000)\",         \"false\"},\n                {\"ja_JP@cf=account\",  \"-1000.5\",  \"(\uffe51,000)\",         \"-\uffe51,000\",          \"(\uffe51,000)\",         \"false\"},\n                {\"de_DE\",             \"-23456.7\", \"-23.456,70\\u00A0\u20ac\", \"-23.456,70\\u00A0\u20ac\", \"-23.456,70\\u00A0\u20ac\", \"true\" },\n        };\n        for (String[] data : tests) {\n            ULocale loc = new ULocale(data[0]);\n            double num = Double.parseDouble(data[1]);\n            String fmtPerLocExpected   = data[2];\n            String fmtStandardExpected = data[3];\n            String fmtAccountExpected  = data[4];\n            boolean rt = Boolean.parseBoolean(data[5]);\n\n            NumberFormat fmtPerLoc = NumberFormat.getInstance(loc, NumberFormat.CURRENCYSTYLE);\n            expect(fmtPerLoc, num, fmtPerLocExpected, rt);\n\n            NumberFormat fmtStandard = NumberFormat.getInstance(loc, NumberFormat.STANDARDCURRENCYSTYLE);\n            expect(fmtStandard, num, fmtStandardExpected, rt);\n\n            NumberFormat fmtAccount = NumberFormat.getInstance(loc, NumberFormat.ACCOUNTINGCURRENCYSTYLE);\n            expect(fmtAccount, num, fmtAccountExpected, rt);\n        }\n    }\n\n    @Test\n    public void TestCurrencyUsage() {\n        // the 1st one is checking setter/getter, while the 2nd one checks for getInstance\n        // compare the Currency and Currency Cash Digits\n        // Note that as of CLDR 26:\n        // * TWD and PKR switched from 0 decimals to 2; ISK still has 0, so change test to that\n        // * CAD rounds to .05 in the cash style only.\n        for (int i = 0; i < 2; i++) {\n            String original_expected = \"ISK\u00a0124\";\n            DecimalFormat custom = null;\n            if (i == 0) {\n                custom = (DecimalFormat) DecimalFormat.getInstance(new ULocale(\"en_US@currency=ISK\"),\n                        DecimalFormat.CURRENCYSTYLE);\n\n                String original = custom.format(123.567);\n                assertEquals(\"Test Currency Context\", original_expected, original);\n\n                // test the getter\n                assertEquals(\"Test Currency Context Purpose\", custom.getCurrencyUsage(),\n                        Currency.CurrencyUsage.STANDARD);\n                custom.setCurrencyUsage(Currency.CurrencyUsage.CASH);\n                assertEquals(\"Test Currency Context Purpose\", custom.getCurrencyUsage(), Currency.CurrencyUsage.CASH);\n            } else {\n                custom = (DecimalFormat) DecimalFormat.getInstance(new ULocale(\"en_US@currency=ISK\"),\n                        DecimalFormat.CASHCURRENCYSTYLE);\n\n                // test the getter\n                assertEquals(\"Test Currency Context Purpose\", custom.getCurrencyUsage(), Currency.CurrencyUsage.CASH);\n            }\n\n            String cash_currency = custom.format(123.567);\n            String cash_currency_expected = \"ISK\u00a0124\";\n            assertEquals(\"Test Currency Context\", cash_currency_expected, cash_currency);\n        }\n\n        // the 1st one is checking setter/getter, while the 2nd one checks for getInstance\n        // compare the Currency and Currency Cash Rounding\n        for (int i = 0; i < 2; i++) {\n            String original_rounding_expected = \"CA$123.57\";\n            DecimalFormat fmt = null;\n            if (i == 0) {\n                fmt = (DecimalFormat) DecimalFormat.getInstance(new ULocale(\"en_US@currency=CAD\"),\n                        DecimalFormat.CURRENCYSTYLE);\n\n                String original_rounding = fmt.format(123.566);\n                assertEquals(\"Test Currency Context\", original_rounding_expected, original_rounding);\n\n                fmt.setCurrencyUsage(Currency.CurrencyUsage.CASH);\n            } else {\n                fmt = (DecimalFormat) DecimalFormat.getInstance(new ULocale(\"en_US@currency=CAD\"),\n                        DecimalFormat.CASHCURRENCYSTYLE);\n            }\n\n            String cash_rounding_currency = fmt.format(123.567);\n            String cash__rounding_currency_expected = \"CA$123.55\";\n            assertEquals(\"Test Currency Context\", cash__rounding_currency_expected, cash_rounding_currency);\n        }\n\n        // the 1st one is checking setter/getter, while the 2nd one checks for getInstance\n        // Test the currency change\n        for (int i = 0; i < 2; i++) {\n            DecimalFormat fmt2 = null;\n            if (i == 1) {\n                fmt2 = (DecimalFormat) NumberFormat.getInstance(new ULocale(\"en_US@currency=JPY\"),\n                        NumberFormat.CURRENCYSTYLE);\n                fmt2.setCurrencyUsage(Currency.CurrencyUsage.CASH);\n            } else {\n                fmt2 = (DecimalFormat) NumberFormat.getInstance(new ULocale(\"en_US@currency=JPY\"),\n                        NumberFormat.CASHCURRENCYSTYLE);\n            }\n\n            fmt2.setCurrency(Currency.getInstance(\"PKR\"));\n            String PKR_changed = fmt2.format(123.567);\n            String PKR_changed_expected = \"PKR\u00a0124\";\n            assertEquals(\"Test Currency Context\", PKR_changed_expected, PKR_changed);\n        }\n    }\n\n    @Test\n    public void TestCurrencyWithMinMaxFractionDigits() {\n        DecimalFormat df = new DecimalFormat();\n        df.applyPattern(\"\u00a4#,##0.00\");\n        df.setCurrency(Currency.getInstance(\"USD\"));\n        assertEquals(\"Basic currency format fails\", \"$1.23\", df.format(1.234));\n        df.setMaximumFractionDigits(4);\n        assertEquals(\"Currency with max fraction == 4\", \"$1.234\", df.format(1.234));\n        df.setMinimumFractionDigits(4);\n        assertEquals(\"Currency with min fraction == 4\", \"$1.2340\", df.format(1.234));\n    }\n\n    @Test\n    public void TestParseRequiredDecimalPoint() {\n\n        String[] testPattern = { \"00.####\", \"00.0\", \"00\" };\n\n        String value2Parse = \"99\";\n        String value2ParseWithDecimal = \"99.9\";\n        double parseValue  =  99;\n        double parseValueWithDecimal = 99.9;\n        DecimalFormat parser = new DecimalFormat();\n        double result;\n        boolean hasDecimalPoint;\n        for (int i = 0; i < testPattern.length; i++) {\n            parser.applyPattern(testPattern[i]);\n            hasDecimalPoint = testPattern[i].contains(\".\");\n\n            parser.setDecimalPatternMatchRequired(false);\n            try {\n                result = parser.parse(value2Parse).doubleValue();\n                assertEquals(\"wrong parsed value\", parseValue, result);\n            } catch (ParseException e) {\n                TestFmwk.errln(\"Parsing \" + value2Parse + \" should have succeeded with \" + testPattern[i] +\n                            \" and isDecimalPointMatchRequired set to: \" + parser.isDecimalPatternMatchRequired());\n            }\n            try {\n                result = parser.parse(value2ParseWithDecimal).doubleValue();\n                assertEquals(\"wrong parsed value\", parseValueWithDecimal, result);\n            } catch (ParseException e) {\n                TestFmwk.errln(\"Parsing \" + value2ParseWithDecimal + \" should have succeeded with \" + testPattern[i] +\n                            \" and isDecimalPointMatchRequired set to: \" + parser.isDecimalPatternMatchRequired());\n            }\n\n            parser.setDecimalPatternMatchRequired(true);\n            try {\n                result = parser.parse(value2Parse).doubleValue();\n                if(hasDecimalPoint){\n                    TestFmwk.errln(\"Parsing \" + value2Parse + \" should NOT have succeeded with \" + testPattern[i] +\n                            \" and isDecimalPointMatchRequired set to: \" + parser.isDecimalPatternMatchRequired());\n                }\n            } catch (ParseException e) {\n                    // OK, should fail\n            }\n            try {\n                result = parser.parse(value2ParseWithDecimal).doubleValue();\n                if(!hasDecimalPoint){\n                    TestFmwk.errln(\"Parsing \" + value2ParseWithDecimal + \" should NOT have succeeded with \" + testPattern[i] +\n                            \" and isDecimalPointMatchRequired set to: \" + parser.isDecimalPatternMatchRequired() +\n                            \" (got: \" + result + \")\");\n                }\n            } catch (ParseException e) {\n                    // OK, should fail\n            }\n        }\n    }\n\n    @Test\n    public void TestCurrFmtNegSameAsPositive() {\n        DecimalFormatSymbols decfmtsym = DecimalFormatSymbols.getInstance(Locale.US);\n        decfmtsym.setMinusSign('\\u200B'); // ZERO WIDTH SPACE, in ICU4J cannot set to empty string\n        DecimalFormat decfmt = new DecimalFormat(\"\\u00A4#,##0.00;-\\u00A4#,##0.00\", decfmtsym);\n        String currFmtResult = decfmt.format(-100.0);\n        if (!currFmtResult.equals(\"\\u200B$100.00\")) {\n            errln(\"decfmt.toPattern results wrong, expected \\u200B$100.00, got \" + currFmtResult);\n        }\n    }\n\n    @Test\n    public void TestNumberFormatTestDataToString() {\n        new DataDrivenNumberFormatTestData().toString();\n    }\n\n   // Testing for Issue 11805.\n    @Test\n    public void TestFormatToCharacterIteratorIssue11805 () {\n        final double number = -350.76;\n        DecimalFormat dfUS = (DecimalFormat) DecimalFormat.getCurrencyInstance(Locale.US);\n        String strUS = dfUS.format(number);\n        Set<AttributedCharacterIterator.Attribute> resultUS  = dfUS.formatToCharacterIterator(number).getAllAttributeKeys();\n        assertEquals(\"Negative US Results: \" + strUS, 5, resultUS.size());\n\n        // For each test, add assert that all the fields are present and in the right spot.\n        // TODO: Add tests for identify and position of each field, as in IntlTestDecimalFormatAPIC.\n\n        DecimalFormat dfDE = (DecimalFormat) DecimalFormat.getCurrencyInstance(Locale.GERMANY);\n        String strDE = dfDE.format(number);\n        Set<AttributedCharacterIterator.Attribute> resultDE  = dfDE.formatToCharacterIterator(number).getAllAttributeKeys();\n        assertEquals(\"Negative DE Results: \" + strDE, 5, resultDE.size());\n\n        DecimalFormat dfIN = (DecimalFormat) DecimalFormat.getCurrencyInstance(new Locale(\"hi\", \"in\"));\n        String strIN = dfIN.format(number);\n        Set<AttributedCharacterIterator.Attribute> resultIN  = dfIN.formatToCharacterIterator(number).getAllAttributeKeys();\n        assertEquals(\"Negative IN Results: \" + strIN, 5, resultIN.size());\n\n        DecimalFormat dfJP = (DecimalFormat) DecimalFormat.getCurrencyInstance(Locale.JAPAN);\n        String strJP = dfJP.format(number);\n        Set<AttributedCharacterIterator.Attribute> resultJP  = dfJP.formatToCharacterIterator(number).getAllAttributeKeys();\n        assertEquals(\"Negative JA Results: \" + strJP, 3, resultJP.size());\n\n        DecimalFormat dfGB = (DecimalFormat) DecimalFormat.getCurrencyInstance(new Locale(\"en\", \"gb\"));\n        String strGB = dfGB.format(number);\n        Set<AttributedCharacterIterator.Attribute> resultGB  = dfGB.formatToCharacterIterator(number).getAllAttributeKeys();\n        assertEquals(\"Negative GB Results: \" + strGB , 5, resultGB.size());\n\n        DecimalFormat dfPlural = (DecimalFormat) NumberFormat.getInstance(new Locale(\"en\", \"gb\"),\n            NumberFormat.PLURALCURRENCYSTYLE);\n        strGB = dfPlural.format(number);\n        resultGB = dfPlural.formatToCharacterIterator(number).getAllAttributeKeys();\n        assertEquals(\"Negative GB Results: \" + strGB , 5, resultGB.size());\n\n        strGB = dfPlural.format(1);\n        resultGB = dfPlural.formatToCharacterIterator(1).getAllAttributeKeys();\n        assertEquals(\"Negative GB Results: \" + strGB , 4, resultGB.size());\n\n        // Test output with unit value.\n        DecimalFormat auPlural = (DecimalFormat) NumberFormat.getInstance(new Locale(\"en\", \"au\"),\n                NumberFormat.PLURALCURRENCYSTYLE);\n        String strAU = auPlural.format(1L);\n        Set<AttributedCharacterIterator.Attribute> resultAU  =\n                auPlural.formatToCharacterIterator(1L).getAllAttributeKeys();\n        assertEquals(\"Unit AU Result: \" + strAU , 4, resultAU.size());\n\n        // Verify Permille fields.\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(new Locale(\"en\", \"gb\"));\n        DecimalFormat dfPermille = new DecimalFormat(\"####0.##\\u2030\", sym);\n        strGB = dfPermille.format(number);\n        resultGB = dfPermille.formatToCharacterIterator(number).getAllAttributeKeys();\n        assertEquals(\"Negative GB Permille Results: \" + strGB , 3, resultGB.size());\n    }\n\n    // Testing for Issue 11808.\n    @Test\n    public void TestRoundUnnecessarytIssue11808 () {\n        DecimalFormat df = (DecimalFormat) DecimalFormat.getInstance();\n        StringBuffer result = new StringBuffer(\"\");\n        df.setRoundingMode(BigDecimal.ROUND_UNNECESSARY);\n        df.applyPattern(\"00.0#E0\");\n\n        try {\n            df.format(99999.0, result, new FieldPosition(0));\n            fail(\"Missing ArithmeticException for double: \" + result);\n        } catch (ArithmeticException expected) {\n            // The exception should be thrown, since rounding is needed.\n        }\n\n        try {\n            result = df.format(99999, result, new FieldPosition(0));\n            fail(\"Missing ArithmeticException for int: \" + result);\n       } catch (ArithmeticException expected) {\n           // The exception should be thrown, since rounding is needed.\n        }\n\n        try {\n            result = df.format(new BigInteger(\"999999\"), result, new FieldPosition(0));\n            fail(\"Missing ArithmeticException for BigInteger: \" + result);\n        } catch (ArithmeticException expected) {\n            // The exception should be thrown, since rounding is needed.\n        }\n\n        try {\n            result = df.format(new BigDecimal(\"99999\"), result, new FieldPosition(0));\n            fail(\"Missing ArithmeticException for BigDecimal: \" + result);\n        } catch (ArithmeticException expected) {\n            // The exception should be thrown, since rounding is needed.\n        }\n\n        try {\n            result = df.format(new BigDecimal(\"-99999\"), result, new FieldPosition(0));\n            fail(\"Missing ArithmeticException for BigDecimal: \" + result);\n        } catch (ArithmeticException expected) {\n            // The exception should be thrown, since rounding is needed.\n        }\n    }\n\n    // Testing for Issue 11735.\n    @Test\n    public void TestNPEIssue11735() {\n        DecimalFormat fmt = new DecimalFormat(\"0\", new DecimalFormatSymbols(new ULocale(\"en\")));\n        ParsePosition ppos = new ParsePosition(0);\n        assertEquals(\"Currency symbol missing in parse. Expect null result.\",\n                fmt.parseCurrency(\"53.45\", ppos), null);\n    }\n\n    private void CompareAttributedCharacterFormatOutput(AttributedCharacterIterator iterator,\n        List<FieldContainer> expected, String formattedOutput) {\n\n        List<FieldContainer> result = new ArrayList<>();\n        while (iterator.getIndex() != iterator.getEndIndex()) {\n            int start = iterator.getRunStart();\n            int end = iterator.getRunLimit();\n            Iterator it = iterator.getAttributes().keySet().iterator();\n            AttributedCharacterIterator.Attribute attribute = (AttributedCharacterIterator.Attribute) it.next();\n            // For positions with both INTEGER and GROUPING attributes, we want the GROUPING attribute.\n            if (it.hasNext() && attribute.equals(NumberFormat.Field.INTEGER)) {\n                attribute = (AttributedCharacterIterator.Attribute) it.next();\n            }\n            Object value = iterator.getAttribute(attribute);\n            result.add(new FieldContainer(start, end, attribute, value));\n            iterator.setIndex(end);\n        }\n        assertEquals(\"Comparing vector length for \" + formattedOutput,\n            expected.size(), result.size());\n\n        if (!expected.containsAll(result)) {\n          // Print information on the differences.\n          for (int i = 0; i < expected.size(); i++) {\n            System.out.println(\"     expected[\" + i + \"] =\" +\n                expected.get(i).start + \" \" +\n                expected.get(i).end + \" \" +\n                expected.get(i).attribute + \" \" +\n                expected.get(i).value);\n            System.out.println(\" result[\" + i + \"] =\" +\n                result.get(i).start + \" \" +\n                result.get(i).end + \" \" +\n                result.get(i).attribute + \" \" +\n                result.get(i).value);\n          }\n        }\n        assertTrue(\"Comparing vector results for \" + formattedOutput, expected.containsAll(result));\n    }\n\n    // Testing for Issue 11914, missing FieldPositions for some field types.\n    @Test\n    public void TestNPEIssue11914() {\n        // First test: Double value with grouping separators.\n        List<FieldContainer> v1 = new ArrayList<>(7);\n        v1.add(new FieldContainer(0, 3, NumberFormat.Field.INTEGER));\n        v1.add(new FieldContainer(3, 4, NumberFormat.Field.GROUPING_SEPARATOR));\n        v1.add(new FieldContainer(4, 7, NumberFormat.Field.INTEGER));\n        v1.add(new FieldContainer(7, 8, NumberFormat.Field.GROUPING_SEPARATOR));\n        v1.add(new FieldContainer(8, 11, NumberFormat.Field.INTEGER));\n        v1.add(new FieldContainer(11, 12, NumberFormat.Field.DECIMAL_SEPARATOR));\n        v1.add(new FieldContainer(12, 15, NumberFormat.Field.FRACTION));\n\n        Number number = new Double(123456789.9753);\n        ULocale usLoc = new ULocale(\"en-US\");\n        DecimalFormatSymbols US = new DecimalFormatSymbols(usLoc);\n\n        NumberFormat outFmt = NumberFormat.getNumberInstance(usLoc);\n        String numFmtted = outFmt.format(number);\n        AttributedCharacterIterator iterator =\n                outFmt.formatToCharacterIterator(number);\n        CompareAttributedCharacterFormatOutput(iterator, v1, numFmtted);\n\n        // Second test: Double with scientific notation formatting.\n        List<FieldContainer> v2 = new ArrayList<>(7);\n        v2.add(new FieldContainer(0, 1, NumberFormat.Field.INTEGER));\n        v2.add(new FieldContainer(1, 2, NumberFormat.Field.DECIMAL_SEPARATOR));\n        v2.add(new FieldContainer(2, 5, NumberFormat.Field.FRACTION));\n        v2.add(new FieldContainer(5, 6, NumberFormat.Field.EXPONENT_SYMBOL));\n        v2.add(new FieldContainer(6, 7, NumberFormat.Field.EXPONENT_SIGN));\n        v2.add(new FieldContainer(7, 8, NumberFormat.Field.EXPONENT));\n        DecimalFormat fmt2 = new DecimalFormat(\"0.###E+0\", US);\n\n        numFmtted = fmt2.format(number);\n        iterator = fmt2.formatToCharacterIterator(number);\n        CompareAttributedCharacterFormatOutput(iterator, v2, numFmtted);\n\n        // Third test. BigInteger with grouping separators.\n        List<FieldContainer> v3 = new ArrayList<>(7);\n        v3.add(new FieldContainer(0, 1, NumberFormat.Field.SIGN));\n        v3.add(new FieldContainer(1, 2, NumberFormat.Field.INTEGER));\n        v3.add(new FieldContainer(2, 3, NumberFormat.Field.GROUPING_SEPARATOR));\n        v3.add(new FieldContainer(3, 6, NumberFormat.Field.INTEGER));\n        v3.add(new FieldContainer(6, 7, NumberFormat.Field.GROUPING_SEPARATOR));\n        v3.add(new FieldContainer(7, 10, NumberFormat.Field.INTEGER));\n        v3.add(new FieldContainer(10, 11, NumberFormat.Field.GROUPING_SEPARATOR));\n        v3.add(new FieldContainer(11, 14, NumberFormat.Field.INTEGER));\n        v3.add(new FieldContainer(14, 15, NumberFormat.Field.GROUPING_SEPARATOR));\n        v3.add(new FieldContainer(15, 18, NumberFormat.Field.INTEGER));\n        v3.add(new FieldContainer(18, 19, NumberFormat.Field.GROUPING_SEPARATOR));\n        v3.add(new FieldContainer(19, 22, NumberFormat.Field.INTEGER));\n        v3.add(new FieldContainer(22, 23, NumberFormat.Field.GROUPING_SEPARATOR));\n        v3.add(new FieldContainer(23, 26, NumberFormat.Field.INTEGER));\n        BigInteger bigNumberInt = new BigInteger(\"-1234567890246813579\");\n        String fmtNumberBigInt = outFmt.format(bigNumberInt);\n\n        iterator = outFmt.formatToCharacterIterator(bigNumberInt);\n        CompareAttributedCharacterFormatOutput(iterator, v3, fmtNumberBigInt);\n\n        // Fourth test: BigDecimal with exponential formatting.\n        List<FieldContainer> v4 = new ArrayList<>(7);\n        v4.add(new FieldContainer(0, 1, NumberFormat.Field.SIGN));\n        v4.add(new FieldContainer(1, 2, NumberFormat.Field.INTEGER));\n        v4.add(new FieldContainer(2, 3, NumberFormat.Field.DECIMAL_SEPARATOR));\n        v4.add(new FieldContainer(3, 6, NumberFormat.Field.FRACTION));\n        v4.add(new FieldContainer(6, 7, NumberFormat.Field.EXPONENT_SYMBOL));\n        v4.add(new FieldContainer(7, 8, NumberFormat.Field.EXPONENT_SIGN));\n        v4.add(new FieldContainer(8, 9, NumberFormat.Field.EXPONENT));\n\n        java.math.BigDecimal numberBigD = new java.math.BigDecimal(-123456789);\n        String fmtNumberBigDExp = fmt2.format(numberBigD);\n\n        iterator = fmt2.formatToCharacterIterator(numberBigD);\n        CompareAttributedCharacterFormatOutput(iterator, v4, fmtNumberBigDExp);\n\n    }\n\n    // Test that the decimal is shown even when there are no fractional digits\n    @Test\n    public void Test11621() throws Exception {\n        String pat = \"0.##E0\";\n\n        DecimalFormatSymbols icuSym = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat icuFmt = new DecimalFormat(pat, icuSym);\n        icuFmt.setDecimalSeparatorAlwaysShown(true);\n        String icu = ((NumberFormat)icuFmt).format(299792458);\n\n        java.text.DecimalFormatSymbols jdkSym = new java.text.DecimalFormatSymbols(Locale.US);\n        java.text.DecimalFormat jdkFmt = new java.text.DecimalFormat(pat,jdkSym);\n        jdkFmt.setDecimalSeparatorAlwaysShown(true);\n        String jdk = ((java.text.NumberFormat)jdkFmt).format(299792458);\n\n        assertEquals(\"ICU and JDK placement of decimal in exponent\", jdk, icu);\n    }\n\n    private void checkFormatWithField(String testInfo, Format format, Object object,\n            String expected, Format.Field field, int begin, int end) {\n        StringBuffer buffer = new StringBuffer();\n        FieldPosition pos = new FieldPosition(field);\n        format.format(object, buffer, pos);\n\n        assertEquals(\"Test \" + testInfo + \": incorrect formatted text\", expected, buffer.toString());\n\n        if (begin != pos.getBeginIndex() || end != pos.getEndIndex()) {\n            assertEquals(\"Index mismatch\", field + \" \" + begin + \"..\" + end,\n                pos.getFieldAttribute() + \" \" + pos.getBeginIndex() + \"..\" + pos.getEndIndex());\n        }\n    }\n\n    @Test\n    public void TestMissingFieldPositionsCurrency() {\n        DecimalFormat formatter = (DecimalFormat) NumberFormat.getCurrencyInstance(ULocale.US);\n        Number number = new Double(92314587.66);\n        String result = \"$92,314,587.66\";\n\n        checkFormatWithField(\"currency\", formatter, number, result,\n            NumberFormat.Field.CURRENCY, 0, 1);\n        checkFormatWithField(\"integer\", formatter, number, result,\n            NumberFormat.Field.INTEGER, 1, 11);\n        checkFormatWithField(\"grouping separator\", formatter, number, result,\n            NumberFormat.Field.GROUPING_SEPARATOR, 3, 4);\n        checkFormatWithField(\"decimal separator\", formatter, number, result,\n            NumberFormat.Field.DECIMAL_SEPARATOR, 11, 12);\n        checkFormatWithField(\"fraction\", formatter, number, result,\n            NumberFormat.Field.FRACTION, 12, 14);\n    }\n\n    @Test\n    public void TestMissingFieldPositionsNegativeDouble() {\n        // test for exponential fields with double\n        DecimalFormatSymbols us_symbols = new DecimalFormatSymbols(ULocale.US);\n        Number number = new Double(-12345678.90123);\n        DecimalFormat formatter = new DecimalFormat(\"0.#####E+00\", us_symbols);\n        String numFmtted = formatter.format(number);\n\n        checkFormatWithField(\"sign\", formatter, number, numFmtted,\n            NumberFormat.Field.SIGN, 0, 1);\n        checkFormatWithField(\"integer\", formatter, number, numFmtted,\n            NumberFormat.Field.INTEGER, 1, 2);\n        checkFormatWithField(\"decimal separator\", formatter, number, numFmtted,\n            NumberFormat.Field.DECIMAL_SEPARATOR, 2, 3);\n        checkFormatWithField(\"exponent symbol\", formatter, number, numFmtted,\n            NumberFormat.Field.EXPONENT_SYMBOL, 8, 9);\n        checkFormatWithField(\"exponent sign\", formatter, number, numFmtted,\n            NumberFormat.Field.EXPONENT_SIGN, 9, 10);\n        checkFormatWithField(\"exponent\", formatter, number, numFmtted,\n            NumberFormat.Field.EXPONENT, 10, 12);\n    }\n\n    @Test\n    public void TestMissingFieldPositionsPerCent() {\n        // Check PERCENT\n        DecimalFormat percentFormat = (DecimalFormat) NumberFormat.getPercentInstance(ULocale.US);\n        Number number = new Double(-0.986);\n        String numberFormatted = percentFormat.format(number);\n        checkFormatWithField(\"sign\", percentFormat, number, numberFormatted,\n            NumberFormat.Field.SIGN, 0, 1);\n        checkFormatWithField(\"integer\", percentFormat, number, numberFormatted,\n            NumberFormat.Field.INTEGER, 1, 3);\n        checkFormatWithField(\"percent\", percentFormat, number, numberFormatted,\n            NumberFormat.Field.PERCENT, 3, 4);\n    }\n\n    @Test\n    public void TestMissingFieldPositionsPerCentPattern() {\n        // Check PERCENT with more digits\n        DecimalFormatSymbols us_symbols = new DecimalFormatSymbols(ULocale.US);\n        DecimalFormat fmtPercent = new DecimalFormat(\"0.#####%\", us_symbols);\n        Number number = new Double(-0.986);\n        String numFmtted = fmtPercent.format(number);\n\n        checkFormatWithField(\"sign\", fmtPercent, number, numFmtted,\n            NumberFormat.Field.SIGN, 0, 1);\n        checkFormatWithField(\"integer\", fmtPercent, number, numFmtted,\n            NumberFormat.Field.INTEGER, 1, 3);\n        checkFormatWithField(\"decimal separator\", fmtPercent, number, numFmtted,\n            NumberFormat.Field.DECIMAL_SEPARATOR, 3, 4);\n        checkFormatWithField(\"fraction\", fmtPercent, number, numFmtted,\n            NumberFormat.Field.FRACTION, 4, 5);\n        checkFormatWithField(\"percent\", fmtPercent, number, numFmtted,\n            NumberFormat.Field.PERCENT, 5, 6);\n    }\n\n    @Test\n    public void TestMissingFieldPositionsPerMille() {\n        // Check PERMILLE\n        DecimalFormatSymbols us_symbols = new DecimalFormatSymbols(ULocale.US);\n        DecimalFormat fmtPerMille = new DecimalFormat(\"0.######\u2030\", us_symbols);\n        Number numberPermille = new Double(-0.98654);\n        String numFmtted = fmtPerMille.format(numberPermille);\n\n        checkFormatWithField(\"sign\", fmtPerMille, numberPermille, numFmtted,\n            NumberFormat.Field.SIGN, 0, 1);\n        checkFormatWithField(\"integer\", fmtPerMille, numberPermille, numFmtted,\n            NumberFormat.Field.INTEGER, 1, 4);\n        checkFormatWithField(\"decimal separator\", fmtPerMille, numberPermille, numFmtted,\n            NumberFormat.Field.DECIMAL_SEPARATOR, 4, 5);\n        checkFormatWithField(\"fraction\", fmtPerMille, numberPermille, numFmtted,\n            NumberFormat.Field.FRACTION, 5, 7);\n        checkFormatWithField(\"permille\", fmtPerMille, numberPermille, numFmtted,\n            NumberFormat.Field.PERMILLE, 7, 8);\n    }\n\n    @Test\n    public void TestMissingFieldPositionsNegativeBigInt() {\n      DecimalFormatSymbols us_symbols = new DecimalFormatSymbols(ULocale.US);\n        DecimalFormat formatter = new DecimalFormat(\"0.#####E+0\", us_symbols);\n        Number number = new BigDecimal(\"-123456789987654321\");\n        String bigDecFmtted = formatter.format(number);\n\n        checkFormatWithField(\"sign\", formatter, number, bigDecFmtted,\n            NumberFormat.Field.SIGN, 0, 1);\n        checkFormatWithField(\"integer\", formatter, number, bigDecFmtted,\n            NumberFormat.Field.INTEGER, 1, 2);\n        checkFormatWithField(\"decimal separator\", formatter, number, bigDecFmtted,\n            NumberFormat.Field.DECIMAL_SEPARATOR, 2, 3);\n        checkFormatWithField(\"exponent symbol\", formatter, number, bigDecFmtted,\n            NumberFormat.Field.EXPONENT_SYMBOL, 8, 9);\n        checkFormatWithField(\"exponent sign\", formatter, number, bigDecFmtted,\n            NumberFormat.Field.EXPONENT_SIGN, 9, 10);\n        checkFormatWithField(\"exponent\", formatter, number, bigDecFmtted,\n            NumberFormat.Field.EXPONENT, 10, 12);\n    }\n\n    @Test\n    public void TestMissingFieldPositionsNegativeLong() {\n        Number number = new Long(\"-123456789987654321\");\n        DecimalFormatSymbols us_symbols = new DecimalFormatSymbols(ULocale.US);\n        DecimalFormat formatter = new DecimalFormat(\"0.#####E+0\", us_symbols);\n        String longFmtted = formatter.format(number);\n\n        checkFormatWithField(\"sign\", formatter, number, longFmtted,\n            NumberFormat.Field.SIGN, 0, 1);\n        checkFormatWithField(\"integer\", formatter, number, longFmtted,\n            NumberFormat.Field.INTEGER, 1, 2);\n        checkFormatWithField(\"decimal separator\", formatter, number, longFmtted,\n            NumberFormat.Field.DECIMAL_SEPARATOR, 2, 3);\n        checkFormatWithField(\"exponent symbol\", formatter, number, longFmtted,\n            NumberFormat.Field.EXPONENT_SYMBOL, 8, 9);\n        checkFormatWithField(\"exponent sign\", formatter, number, longFmtted,\n            NumberFormat.Field.EXPONENT_SIGN, 9, 10);\n        checkFormatWithField(\"exponent\", formatter, number, longFmtted,\n            NumberFormat.Field.EXPONENT, 10, 12);\n    }\n\n    @Test\n    public void TestMissingFieldPositionsPositiveBigDec() {\n        // Check complex positive;negative pattern.\n        DecimalFormatSymbols us_symbols = new DecimalFormatSymbols(ULocale.US);\n        DecimalFormat fmtPosNegSign = new DecimalFormat(\"+0.####E+00;-0.#######E+0\", us_symbols);\n        Number positiveExp = new Double(\"9876543210\");\n        String posExpFormatted = fmtPosNegSign.format(positiveExp);\n\n        checkFormatWithField(\"sign\", fmtPosNegSign, positiveExp, posExpFormatted,\n            NumberFormat.Field.SIGN, 0, 1);\n        checkFormatWithField(\"integer\", fmtPosNegSign, positiveExp, posExpFormatted,\n            NumberFormat.Field.INTEGER, 1, 2);\n        checkFormatWithField(\"decimal separator\", fmtPosNegSign, positiveExp, posExpFormatted,\n            NumberFormat.Field.DECIMAL_SEPARATOR, 2, 3);\n        checkFormatWithField(\"fraction\", fmtPosNegSign, positiveExp, posExpFormatted,\n            NumberFormat.Field.FRACTION, 3, 7);\n        checkFormatWithField(\"exponent symbol\", fmtPosNegSign, positiveExp, posExpFormatted,\n            NumberFormat.Field.EXPONENT_SYMBOL, 7, 8);\n        checkFormatWithField(\"exponent sign\", fmtPosNegSign, positiveExp, posExpFormatted,\n            NumberFormat.Field.EXPONENT_SIGN, 8, 9);\n        checkFormatWithField(\"exponent\", fmtPosNegSign, positiveExp, posExpFormatted,\n            NumberFormat.Field.EXPONENT, 9, 11);\n    }\n\n    @Test\n    public void TestMissingFieldPositionsNegativeBigDec() {\n        // Check complex positive;negative pattern.\n      DecimalFormatSymbols us_symbols = new DecimalFormatSymbols(ULocale.US);\n        DecimalFormat fmtPosNegSign = new DecimalFormat(\"+0.####E+00;-0.#######E+0\", us_symbols);\n        Number negativeExp = new BigDecimal(\"-0.000000987654321083\");\n        String negExpFormatted = fmtPosNegSign.format(negativeExp);\n\n        checkFormatWithField(\"sign\", fmtPosNegSign, negativeExp, negExpFormatted,\n            NumberFormat.Field.SIGN, 0, 1);\n        checkFormatWithField(\"integer\", fmtPosNegSign, negativeExp, negExpFormatted,\n            NumberFormat.Field.INTEGER, 1, 2);\n        checkFormatWithField(\"decimal separator\", fmtPosNegSign, negativeExp, negExpFormatted,\n            NumberFormat.Field.DECIMAL_SEPARATOR, 2, 3);\n        checkFormatWithField(\"fraction\", fmtPosNegSign, negativeExp, negExpFormatted,\n            NumberFormat.Field.FRACTION, 3, 7);\n        checkFormatWithField(\"exponent symbol\", fmtPosNegSign, negativeExp, negExpFormatted,\n            NumberFormat.Field.EXPONENT_SYMBOL, 7, 8);\n        checkFormatWithField(\"exponent sign\", fmtPosNegSign, negativeExp, negExpFormatted,\n            NumberFormat.Field.EXPONENT_SIGN, 8, 9);\n        checkFormatWithField(\"exponent\", fmtPosNegSign, negativeExp, negExpFormatted,\n            NumberFormat.Field.EXPONENT, 9, 11);\n    }\n\n    @Test\n    public void TestStringSymbols() {\n        DecimalFormatSymbols symbols = new DecimalFormatSymbols(ULocale.US);\n\n        // Attempt digits with multiple code points.\n        String[] customDigits = {\"(0)\", \"(1)\", \"(2)\", \"(3)\", \"(4)\", \"(5)\", \"(6)\", \"(7)\", \"(8)\", \"(9)\"};\n        symbols.setDigitStrings(customDigits);\n        DecimalFormat fmt = new DecimalFormat(\"#,##0.0#\", symbols);\n        expect2(fmt, 1234567.89, \"(1),(2)(3)(4),(5)(6)(7).(8)(9)\");\n\n        // Scientific notation should work.\n        fmt.applyPattern(\"@@@E0\");\n        expect2(fmt, 1230000, \"(1).(2)(3)E(6)\");\n\n        // Grouping and decimal with multiple code points (supported in parsing since ICU 61)\n        symbols.setDecimalSeparatorString(\"~~\");\n        symbols.setGroupingSeparatorString(\"^^\");\n        fmt.setDecimalFormatSymbols(symbols);\n        fmt.applyPattern(\"#,##0.0#\");\n        expect2(fmt, 1234567.89, \"(1)^^(2)(3)(4)^^(5)(6)(7)~~(8)(9)\");\n\n        // Digits starting at U+1D7CE MATHEMATICAL BOLD DIGIT ZERO\n        // These are all single code points, so parsing will work.\n        for (int i=0; i<10; i++) customDigits[i] = new String(Character.toChars(0x1D7CE+i));\n        symbols.setDigitStrings(customDigits);\n        symbols.setDecimalSeparatorString(\"\ud83d\ude01\");\n        symbols.setGroupingSeparatorString(\"\ud83d\ude0e\");\n        fmt.setDecimalFormatSymbols(symbols);\n        expect2(fmt, 1234.56, \"\ud835\udfcf\ud83d\ude0e\ud835\udfd0\ud835\udfd1\ud835\udfd2\ud83d\ude01\ud835\udfd3\ud835\udfd4\");\n    }\n\n    @Test\n    public void TestArabicCurrencyPatternInfo() {\n        ULocale arLocale = new ULocale(\"ar\");\n\n        DecimalFormatSymbols symbols = new DecimalFormatSymbols(arLocale);\n        String currSpacingPatn = symbols.getPatternForCurrencySpacing(DecimalFormatSymbols.CURRENCY_SPC_CURRENCY_MATCH, true);\n        if (currSpacingPatn==null || currSpacingPatn.length() == 0) {\n            errln(\"locale ar, getPatternForCurrencySpacing returns null or 0-length string\");\n        }\n\n        DecimalFormat currAcctFormat = (DecimalFormat)NumberFormat.getInstance(arLocale, NumberFormat.ACCOUNTINGCURRENCYSTYLE);\n        String currAcctPatn = currAcctFormat.toPattern();\n        if (currAcctPatn==null || currAcctPatn.length() == 0) {\n            errln(\"locale ar, toPattern for ACCOUNTINGCURRENCYSTYLE returns null or 0-length string\");\n        }\n    }\n\n    @Test\n    public void TestMinMaxOverrides()\n            throws IllegalAccessException, IllegalArgumentException, InvocationTargetException,\n                NoSuchMethodException, SecurityException {\n        Class<?>[] baseClasses = {NumberFormat.class, NumberFormat.class, DecimalFormat.class};\n        String[] names = {\"Integer\", \"Fraction\", \"Significant\"};\n        for (int i = 0; i < 3; i++) {\n            DecimalFormat df = new DecimalFormat();\n            Class<?> base = baseClasses[i];\n            String name = names[i];\n            Method getMinimum = base.getDeclaredMethod(\"getMinimum\" + name + \"Digits\");\n            Method setMinimum = base.getDeclaredMethod(\"setMinimum\" + name + \"Digits\", Integer.TYPE);\n            Method getMaximum = base.getDeclaredMethod(\"getMaximum\" + name + \"Digits\");\n            Method setMaximum = base.getDeclaredMethod(\"setMaximum\" + name + \"Digits\", Integer.TYPE);\n\n            // Check max overrides min\n            setMinimum.invoke(df, 2);\n            assertEquals(name + \" getMin A\", 2, getMinimum.invoke(df));\n            setMaximum.invoke(df, 3);\n            assertEquals(name + \" getMin B\", 2, getMinimum.invoke(df));\n            assertEquals(name + \" getMax B\", 3, getMaximum.invoke(df));\n            setMaximum.invoke(df, 2);\n            assertEquals(name + \" getMin C\", 2, getMinimum.invoke(df));\n            assertEquals(name + \" getMax C\", 2, getMaximum.invoke(df));\n            setMaximum.invoke(df, 1);\n            assertEquals(name + \" getMin D\", 1, getMinimum.invoke(df));\n            assertEquals(name + \" getMax D\", 1, getMaximum.invoke(df));\n\n            // Check min overrides max\n            setMaximum.invoke(df, 2);\n            assertEquals(name + \" getMax E\", 2, getMaximum.invoke(df));\n            setMinimum.invoke(df, 1);\n            assertEquals(name + \" getMin F\", 1, getMinimum.invoke(df));\n            assertEquals(name + \" getMax F\", 2, getMaximum.invoke(df));\n            setMinimum.invoke(df, 2);\n            assertEquals(name + \" getMin G\", 2, getMinimum.invoke(df));\n            assertEquals(name + \" getMax G\", 2, getMaximum.invoke(df));\n            setMinimum.invoke(df, 3);\n            assertEquals(name + \" getMin H\", 3, getMinimum.invoke(df));\n            assertEquals(name + \" getMax H\", 3, getMaximum.invoke(df));\n        }\n    }\n\n    @Test\n    public void TestSetMathContext() throws ParseException {\n        java.math.MathContext fourDigits = new java.math.MathContext(4);\n        java.math.MathContext unlimitedCeiling = new java.math.MathContext(0, RoundingMode.CEILING);\n\n        // Test rounding\n        DecimalFormat df = new DecimalFormat();\n        assertEquals(\"Default format\", \"9,876.543\", df.format(9876.5432));\n        df.setMathContext(fourDigits);\n        assertEquals(\"Format with fourDigits\", \"9,877\", df.format(9876.5432));\n        df.setMathContext(unlimitedCeiling);\n        assertEquals(\"Format with unlimitedCeiling\", \"9,876.544\", df.format(9876.5432));\n\n        // Test multiplication\n        df = new DecimalFormat(\"0.000%\");\n        assertEquals(\"Default multiplication\", \"12.001%\", df.format(0.120011));\n        df.setMathContext(fourDigits);\n        assertEquals(\"Multiplication with fourDigits\", \"12.000%\", df.format(0.120011));\n        df.setMathContext(unlimitedCeiling);\n        assertEquals(\"Multiplication with unlimitedCeiling\", \"12.002%\", df.format(0.120011));\n\n        // Test simple division\n        df = new DecimalFormat(\"0%\");\n        assertEquals(\"Default division\", 0.12001, df.parse(\"12.001%\").doubleValue());\n        df.setMathContext(fourDigits);\n        // NOTE: Since ICU 61, division no longer occurs with percentage parsing.\n        // assertEquals(\"Division with fourDigits\", 0.12, df.parse(\"12.001%\").doubleValue());\n        assertEquals(\"Division with fourDigits\", 0.12001, df.parse(\"12.001%\").doubleValue());\n        df.setMathContext(unlimitedCeiling);\n        assertEquals(\"Division with unlimitedCeiling\", 0.12001, df.parse(\"12.001%\").doubleValue());\n\n        // Test extreme division\n        df = new DecimalFormat();\n        df.setMultiplier(1000000007); // prime number\n        String hugeNumberString = \"9876543212345678987654321234567898765432123456789\"; // 49 digits\n        BigInteger huge34Digits = new BigInteger(\"9876543143209876985185182338271622000000\");\n        BigInteger huge4Digits = new BigInteger(\"9877000000000000000000000000000000000000\");\n        BigInteger actual34Digits = ((BigDecimal) df.parse(hugeNumberString)).toBigIntegerExact();\n        assertEquals(\"Default extreme division\", huge34Digits, actual34Digits);\n        df.setMathContext(fourDigits);\n        BigInteger actual4Digits = ((BigDecimal) df.parse(hugeNumberString)).toBigIntegerExact();\n        assertEquals(\"Extreme division with fourDigits\", huge4Digits, actual4Digits);\n    }\n\n    /**\n     * ArithmeticException is thrown when inverting multiplier produces a non-terminating\n     * decimal result in conjunction with MathContext of unlimited precision.\n     */\n    @Test\n    public void testSetMathContextArithmeticException() {\n        DecimalFormat df = new DecimalFormat();\n        df.setMultiplier(7);\n        try {\n            df.setMathContext(java.math.MathContext.UNLIMITED);\n            fail(\"Extreme division with unlimited precision should throw ArithmeticException\");\n        } catch (ArithmeticException e) {\n            // expected\n        }\n    }\n\n    /**\n     * ArithmeticException is thrown when inverting multiplier produces a non-terminating\n     * decimal result in conjunction with MathContext of unlimited precision.\n     */\n    @Test\n    public void testSetMathContextICUArithmeticException() {\n        DecimalFormat df = new DecimalFormat();\n        df.setMultiplier(7);\n        try {\n            df.setMathContextICU(new MathContext(0));\n            fail(\"Extreme division with unlimited precision should throw ArithmeticException\");\n        } catch (ArithmeticException e) {\n            // expected\n        }\n    }\n\n    /**\n     * ArithmeticException is thrown when inverting multiplier produces a non-terminating\n     * decimal result in conjunction with MathContext of unlimited precision.\n     */\n    @Test\n    public void testSetMultiplierArithmeticException() {\n        DecimalFormat df = new DecimalFormat();\n        df.setMathContext(java.math.MathContext.UNLIMITED);\n        try {\n            df.setMultiplier(7);\n            fail(\"Extreme division with unlimited precision should throw ArithmeticException\");\n        } catch (ArithmeticException e) {\n            // expected\n        }\n    }\n\n    @Test\n    public void Test10436() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getInstance(Locale.ENGLISH);\n        df.setRoundingMode(MathContext.ROUND_CEILING);\n        df.setMinimumFractionDigits(0);\n        df.setMaximumFractionDigits(0);\n        assertEquals(\"-.99 should round toward infinity\", \"-0\", df.format(-0.99));\n    }\n\n    @Test\n    public void Test10765() {\n        NumberFormat fmt = NumberFormat.getInstance(new ULocale(\"en\"));\n        fmt.setMinimumIntegerDigits(10);\n        FieldPosition pos = new FieldPosition(NumberFormat.Field.GROUPING_SEPARATOR);\n        StringBuffer sb = new StringBuffer();\n        fmt.format(1234567, sb, pos);\n        assertEquals(\"Should have multiple grouping separators\", \"0,001,234,567\", sb.toString());\n        assertEquals(\"FieldPosition should report the first occurence\", 1, pos.getBeginIndex());\n        assertEquals(\"FieldPosition should report the first occurence\", 2, pos.getEndIndex());\n    }\n\n    @Test\n    public void Test10997() {\n        NumberFormat fmt = NumberFormat.getCurrencyInstance(new ULocale(\"en-US\"));\n        fmt.setMinimumFractionDigits(4);\n        fmt.setMaximumFractionDigits(4);\n        String str1 = fmt.format(new CurrencyAmount(123.45, Currency.getInstance(\"USD\")));\n        String str2 = fmt.format(new CurrencyAmount(123.45, Currency.getInstance(\"EUR\")));\n        assertEquals(\"minFrac 4 should be respected in default currency\", \"$123.4500\", str1);\n        assertEquals(\"minFrac 4 should be respected in different currency\", \"\u20ac123.4500\", str2);\n    }\n\n    @Test\n    public void Test11020() {\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(ULocale.FRANCE);\n        DecimalFormat fmt = new DecimalFormat(\"0.05E0\", sym);\n        String result = fmt.format(12301.2).replace('\\u00a0', ' ');\n        assertEquals(\"Rounding increment should be applied after magnitude scaling\", \"1,25E4\", result);\n    }\n\n    @Test\n    public void Test11025() {\n        String pattern = \"\u00a4\u00a4 **####0.00\";\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(ULocale.FRANCE);\n        DecimalFormat fmt = new DecimalFormat(pattern, sym);\n        String result = fmt.format(433.0);\n        assertEquals(\"Number should be padded to 11 characters\", \"EUR *433,00\", result);\n    }\n\n    @Test\n    public void Test11640_TripleCurrencySymbol() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getInstance();\n        df.applyPattern(\"\u00a4\u00a4\u00a4 0\");\n        String result = df.getPositivePrefix();\n        assertEquals(\"Triple-currency should give long name on getPositivePrefix\", \"US dollars \", result);\n    }\n\n    @Test\n    public void Test11645() {\n        String pattern = \"#,##0.0#\";\n        DecimalFormat fmt = (DecimalFormat) NumberFormat.getInstance();\n        fmt.applyPattern(pattern);\n        DecimalFormat fmtCopy;\n\n        final int newMultiplier = 37;\n        fmtCopy = (DecimalFormat) fmt.clone();\n        assertNotEquals(\"Value before setter\", fmtCopy.getMultiplier(), newMultiplier);\n        fmtCopy.setMultiplier(newMultiplier);\n        assertEquals(\"Value after setter\", fmtCopy.getMultiplier(), newMultiplier);\n        fmtCopy.applyPattern(pattern);\n        assertEquals(\"Value after applyPattern\", fmtCopy.getMultiplier(), newMultiplier);\n        assertFalse(\"multiplier\", fmt.equals(fmtCopy));\n\n        final int newRoundingMode = RoundingMode.CEILING.ordinal();\n        fmtCopy = (DecimalFormat) fmt.clone();\n        assertNotEquals(\"Value before setter\", fmtCopy.getRoundingMode(), newRoundingMode);\n        fmtCopy.setRoundingMode(newRoundingMode);\n        assertEquals(\"Value after setter\", fmtCopy.getRoundingMode(), newRoundingMode);\n        fmtCopy.applyPattern(pattern);\n        assertEquals(\"Value after applyPattern\", fmtCopy.getRoundingMode(), newRoundingMode);\n        assertFalse(\"roundingMode\", fmt.equals(fmtCopy));\n\n        final Currency newCurrency = Currency.getInstance(\"EAT\");\n        fmtCopy = (DecimalFormat) fmt.clone();\n        assertNotEquals(\"Value before setter\", fmtCopy.getCurrency(), newCurrency);\n        fmtCopy.setCurrency(newCurrency);\n        assertEquals(\"Value after setter\", fmtCopy.getCurrency(), newCurrency);\n        fmtCopy.applyPattern(pattern);\n        assertEquals(\"Value after applyPattern\", fmtCopy.getCurrency(), newCurrency);\n        assertFalse(\"currency\", fmt.equals(fmtCopy));\n\n        final CurrencyUsage newCurrencyUsage = CurrencyUsage.CASH;\n        fmtCopy = (DecimalFormat) fmt.clone();\n        assertNotEquals(\"Value before setter\", fmtCopy.getCurrencyUsage(), newCurrencyUsage);\n        fmtCopy.setCurrencyUsage(CurrencyUsage.CASH);\n        assertEquals(\"Value after setter\", fmtCopy.getCurrencyUsage(), newCurrencyUsage);\n        fmtCopy.applyPattern(pattern);\n        assertEquals(\"Value after applyPattern\", fmtCopy.getCurrencyUsage(), newCurrencyUsage);\n        assertFalse(\"currencyUsage\", fmt.equals(fmtCopy));\n    }\n\n    @Test\n    public void Test11646() {\n        DecimalFormatSymbols symbols = new DecimalFormatSymbols(new ULocale(\"en_US\"));\n        String pattern = \"\\u00a4\\u00a4\\u00a4 0.00 %\\u00a4\\u00a4\";\n        DecimalFormat fmt = new DecimalFormat(pattern, symbols);\n\n        // Test equality with affixes. set affix methods can't capture special\n        // characters which is why equality should fail.\n        {\n          DecimalFormat fmtCopy = (DecimalFormat) fmt.clone();\n          assertEquals(\"\", fmt, fmtCopy);\n          fmtCopy.setPositivePrefix(fmtCopy.getPositivePrefix());\n          assertNotEquals(\"\", fmt, fmtCopy);\n        }\n        {\n          DecimalFormat fmtCopy = (DecimalFormat) fmt.clone();\n          assertEquals(\"\", fmt, fmtCopy);\n          fmtCopy.setPositiveSuffix(fmtCopy.getPositiveSuffix());\n          assertNotEquals(\"\", fmt, fmtCopy);\n        }\n        {\n          DecimalFormat fmtCopy = (DecimalFormat) fmt.clone();\n          assertEquals(\"\", fmt, fmtCopy);\n          fmtCopy.setNegativePrefix(fmtCopy.getNegativePrefix());\n          assertNotEquals(\"\", fmt, fmtCopy);\n        }\n        {\n          DecimalFormat fmtCopy = (DecimalFormat) fmt.clone();\n          assertEquals(\"\", fmt, fmtCopy);\n          fmtCopy.setNegativeSuffix(fmtCopy.getNegativeSuffix());\n          assertNotEquals(\"\", fmt, fmtCopy);\n        }\n    }\n\n    @Test\n    public void Test11648() {\n        DecimalFormat df = new DecimalFormat(\"0.00\");\n        df.setScientificNotation(true);\n        String pat = df.toPattern();\n        assertEquals(\"A valid scientific notation pattern should be produced\", \"0.00E0\", pat);\n    }\n\n    @Test\n    public void Test11649() {\n        String pattern = \"\\u00a4\\u00a4\\u00a4 0.00\";\n        DecimalFormat fmt = new DecimalFormat(pattern);\n        fmt.setCurrency(Currency.getInstance(\"USD\"));\n        assertEquals(\"Triple currency sign should format long name\", \"US dollars 12.34\", fmt.format(12.34));\n\n        String newPattern = fmt.toPattern();\n        assertEquals(\"Should produce a valid pattern\", pattern, newPattern);\n\n        DecimalFormat fmt2 = new DecimalFormat(newPattern);\n        fmt2.setCurrency(Currency.getInstance(\"USD\"));\n        assertEquals(\"Triple currency sign pattern should round-trip\", \"US dollars 12.34\", fmt2.format(12.34));\n\n        String quotedPattern = \"\\u00a4\\u00a4'\\u00a4' 0.00\";\n        DecimalFormat fmt3 = new DecimalFormat(quotedPattern);\n        assertEquals(\"Should be treated as double currency sign\", \"USD\\u00a4 12.34\", fmt3.format(12.34));\n\n        String outQuotedPattern = fmt3.toPattern();\n        assertEquals(\"Double currency sign with quoted sign should round-trip\", quotedPattern, outQuotedPattern);\n    }\n\n    @Test\n    @Ignore\n    public void Test11686() {\n        // Only passes with slow mode.\n        // TODO: Re-enable this test with slow mode.\n        DecimalFormat df = new DecimalFormat();\n        df.setPositiveSuffix(\"0K\");\n        df.setNegativeSuffix(\"0N\");\n        expect2(df, 123, \"1230K\");\n        expect2(df, -123, \"-1230N\");\n    }\n\n    @Test\n    public void Test11839() {\n        DecimalFormatSymbols dfs = new DecimalFormatSymbols(ULocale.ENGLISH);\n        dfs.setMinusSignString(\"a\u2238\");\n        dfs.setPlusSignString(\"b\u2214\"); //  \u2214  U+2214 DOT PLUS\n        DecimalFormat df = new DecimalFormat(\"0.00+;0.00-\", dfs);\n        String result = df.format(-1.234);\n        assertEquals(\"Locale-specific minus sign should be used\", \"1.23a\u2238\", result);\n        result = df.format(1.234);\n        assertEquals(\"Locale-specific plus sign should be used\", \"1.23b\u2214\", result);\n        // Test round-trip with parse\n        expect2(df, -456, \"456.00a\u2238\");\n        expect2(df, 456, \"456.00b\u2214\");\n    }\n\n    @Test\n    public void Test12753() {\n        ULocale locale = new ULocale(\"en-US\");\n        DecimalFormatSymbols symbols = DecimalFormatSymbols.getInstance(locale);\n        symbols.setDecimalSeparator('*');\n        DecimalFormat df = new DecimalFormat(\"0.00\", symbols);\n        df.setDecimalPatternMatchRequired(true);\n        try {\n            df.parse(\"123\");\n            fail(\"Parsing integer succeeded even though setDecimalPatternMatchRequired was set\");\n        } catch (ParseException e) {\n            // Parse failed (expected)\n        }\n    }\n\n    @Test\n    public void Test12962() {\n        String pat = \"**0.00\";\n        DecimalFormat df = new DecimalFormat(pat);\n        String newPat = df.toPattern();\n        assertEquals(\"Format width changed upon calling applyPattern\", pat.length(), newPat.length());\n    }\n\n    @Test\n    public void Test10354() {\n        DecimalFormatSymbols dfs = new DecimalFormatSymbols();\n        dfs.setNaN(\"\");\n        DecimalFormat df = new DecimalFormat();\n        df.setDecimalFormatSymbols(dfs);\n        try {\n            df.formatToCharacterIterator(Double.NaN);\n            // pass\n        } catch (IllegalArgumentException e) {\n            throw new AssertionError(e);\n        }\n    }\n\n    @Test\n    public void Test11913() {\n        NumberFormat df = DecimalFormat.getInstance();\n        String result = df.format(new BigDecimal(\"1.23456789E400\"));\n        assertEquals(\"Should format more than 309 digits\", \"12,345,678\", result.substring(0, 10));\n        assertEquals(\"Should format more than 309 digits\", 534, result.length());\n    }\n\n    @Test\n    public void Test12045() {\n        if (logKnownIssue(\"12045\", \"XSU is missing from fr\")) { return; }\n\n        NumberFormat nf = NumberFormat.getInstance(new ULocale(\"fr\"), NumberFormat.PLURALCURRENCYSTYLE);\n        ParsePosition ppos = new ParsePosition(0);\n        try {\n            CurrencyAmount result = nf.parseCurrency(\"2,34 XSU\", ppos);\n            assertEquals(\"Parsing should succeed on XSU\",\n                         new CurrencyAmount(2.34, Currency.getInstance(\"XSU\")), result);\n            // pass\n        } catch (Exception e) {\n            //throw new AssertionError(\"Should have been able to parse XSU\", e);\n            throw new AssertionError(\"Should have been able to parse XSU: \" + e.getMessage());\n        }\n    }\n\n    @Test\n    public void Test11739() {\n        NumberFormat nf = NumberFormat.getCurrencyInstance(new ULocale(\"sr_BA\"));\n        ((DecimalFormat) nf).applyPattern(\"#,##0.0 \u00a4\u00a4\u00a4\");\n        ParsePosition ppos = new ParsePosition(0);\n        CurrencyAmount result = nf.parseCurrency(\"1.500 \u0430\u043c\u0435\u0440\u0438\u0447\u043a\u0438 \u0434\u043e\u043b\u0430\u0440\", ppos);\n        assertEquals(\"Should parse to 1500 USD\", new CurrencyAmount(1500, Currency.getInstance(\"USD\")), result);\n    }\n\n    @Test\n    public void Test11647() {\n        DecimalFormat df = new DecimalFormat();\n        df.applyPattern(\"\u00a4\u00a4\u00a4\u00a4#\");\n        String actual = df.format(123);\n        assertEquals(\"Should replace 4 currency signs with U+FFFD\", \"\\uFFFD123\", actual);\n    }\n\n    @Test\n    public void Test12567() {\n        DecimalFormat df1 = (DecimalFormat) NumberFormat.getInstance(NumberFormat.PLURALCURRENCYSTYLE);\n        DecimalFormat df2 = (DecimalFormat) NumberFormat.getInstance(NumberFormat.NUMBERSTYLE);\n        df2.setCurrency(df1.getCurrency());\n        df2.setCurrencyPluralInfo(df1.getCurrencyPluralInfo());\n        df1.applyPattern(\"0.00\");\n        df2.applyPattern(\"0.00\");\n        assertEquals(\"df1 == df2\", df1, df2);\n        assertEquals(\"df2 == df1\", df2, df1);\n        df2.setPositivePrefix(\"abc\");\n        assertNotEquals(\"df1 != df2\", df1, df2);\n        assertNotEquals(\"df2 != df1\", df2, df1);\n    }\n\n    @Test\n    public void Test11897_LocalizedPatternSeparator() {\n        // In a locale with a different <list> symbol, like arabic,\n        // kPatternSeparatorSymbol should still be ';'\n        {\n            DecimalFormatSymbols dfs = new DecimalFormatSymbols(new ULocale(\"ar\"));\n            assertEquals(\"pattern separator symbol should be ;\",\n                    ';',\n                    dfs.getPatternSeparator());\n        }\n\n        // However, the custom symbol should be used in localized notation\n        // when set manually via API\n        {\n            DecimalFormatSymbols dfs = new DecimalFormatSymbols(new ULocale(\"en\"));\n            dfs.setPatternSeparator('!');\n            DecimalFormat df = new DecimalFormat(\"0\", dfs);\n            df.applyPattern(\"a0;b0\"); // should not throw\n            assertEquals(\"should apply the normal pattern\",\n                    df.getNegativePrefix(),\n                    \"b\");\n            df.applyLocalizedPattern(\"c0!d0\"); // should not throw\n            assertEquals(\"should apply the localized pattern\",\n                    df.getNegativePrefix(),\n                    \"d\");\n        }\n    }\n\n    @Test\n    public void Test13055() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getPercentInstance();\n        df.setMaximumFractionDigits(0);\n        df.setRoundingMode(BigDecimal.ROUND_HALF_EVEN);\n        assertEquals(\"Should round percent toward even number\", \"216%\", df.format(2.155));\n    }\n\n    @Test\n    public void Test13056() {\n        DecimalFormat df = new DecimalFormat(\"#,##0\");\n        assertEquals(\"Primary grouping should return 3\", 3, df.getGroupingSize());\n        assertEquals(\"Secondary grouping should return 0\", 0, df.getSecondaryGroupingSize());\n        df.setSecondaryGroupingSize(3);\n        assertEquals(\"Primary grouping should still return 3\", 3, df.getGroupingSize());\n        assertEquals(\"Secondary grouping should round-trip\", 3, df.getSecondaryGroupingSize());\n        df.setGroupingSize(4);\n        assertEquals(\"Primary grouping should return 4\", 4, df.getGroupingSize());\n        assertEquals(\"Secondary should remember explicit setting and return 3\", 3, df.getSecondaryGroupingSize());\n    }\n\n    @Test\n    public void Test13074() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getCurrencyInstance(new ULocale(\"bg-BG\"));\n        String result = df.format(987654.321);\n        assertEquals(\"Locale 'bg' should not use monetary grouping\", \"987654,32\u00a0\u043b\u0432.\", result);\n    }\n\n    @Test\n    public void Test13088and13162() {\n        ULocale loc = new ULocale(\"fa\");\n        String pattern1 = \"%\\u00A0#,##0;%\\u00A0-#,##0\";\n        double num = -12.34;\n        DecimalFormatSymbols symbols = DecimalFormatSymbols.getInstance(loc);\n        // If the symbols ever change in locale data, please call the setters so that this test\n        // continues to use the old symbols.\n        // The fa percent symbol does change in CLDR 32, so....\n        symbols.setPercentString(\"\u200e\u066a\");\n        assertEquals(\"Checking for expected symbols\", \"\u200e\u2212\", symbols.getMinusSignString());\n        assertEquals(\"Checking for expected symbols\", \"\u200e\u066a\", symbols.getPercentString());\n        DecimalFormat numfmt = new DecimalFormat(pattern1, symbols);\n        expect2(numfmt, num, \"\u200e\u066a\u00a0\u200e\u2212\u06f1\u066c\u06f2\u06f3\u06f4\");\n        String pattern2 = \"%#,##0;%-#,##0\";\n        numfmt = new DecimalFormat(pattern2, symbols);\n        expect2(numfmt, num, \"\u200e\u066a\u200e\u2212\u06f1\u066c\u06f2\u06f3\u06f4\");\n    }\n\n    @Test\n    public void Test13113_MalformedPatterns() {\n        String[][] cases = {\n                {\"'\", \"quoted literal\"},\n                {\"ab#c'd\", \"quoted literal\"},\n                {\"ab#c*\", \"unquoted literal\"},\n                {\"0#\", \"# cannot follow 0\"},\n                {\".#0\", \"0 cannot follow #\"},\n                {\"@0\", \"Cannot mix @ and 0\"},\n                {\"0@\", \"Cannot mix 0 and @\"},\n                {\"#x#\", \"unquoted special character\"},\n                {\"@#@\", \"# inside of a run of @\"},\n        };\n        for (String[] cas : cases) {\n            try {\n                new DecimalFormat(cas[0]);\n                fail(\"Should have thrown on malformed pattern\");\n            } catch (IllegalArgumentException ex) {\n                assertTrue(\"Exception should contain \\\"Malformed pattern\\\": \" + ex.getMessage(),\n                        ex.getMessage().contains(\"Malformed pattern\"));\n                assertTrue(\"Exception should contain \\\"\" + cas[1] + \"\\\"\" + ex.getMessage(),\n                        ex.getMessage().contains(cas[1]));\n            }\n        }\n    }\n\n    @Test\n    public void Test13118() {\n        DecimalFormat df = new DecimalFormat(\"@@@\");\n        df.setScientificNotation(true);\n        for (double d=12345.67; d>1e-6; d/=10) {\n            String result = df.format(d);\n            assertEquals(\"Should produce a string of expected length on \" + d,\n                    d > 1 ? 6 : 7, result.length());\n        }\n    }\n\n    @Test\n    public void Test13289() {\n        DecimalFormat df = new DecimalFormat(\"#00.0#E0\");\n        String result = df.format(0.00123);\n        assertEquals(\"Should ignore scientific minInt if maxInt>minInt\", \"1.23E-3\", result);\n    }\n\n    @Test\n    public void Test13310() {\n        // Note: if minInt > 8, then maxInt can be greater than 8.\n        assertEquals(\"Should not throw an assertion error\",\n                \"100000007.6E-1\",\n                new DecimalFormat(\"000000000.0#E0\").format(10000000.76d));\n    }\n\n    @Test\n    public void Test13391() throws ParseException {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getInstance(new ULocale(\"ccp\"));\n        df.setParseStrict(true);\n        String expected = \"\\uD804\\uDD37\\uD804\\uDD38,\\uD804\\uDD39\\uD804\\uDD3A\\uD804\\uDD3B\";\n        assertEquals(\"Should produce expected output in ccp\", expected, df.format(12345));\n        Number result = df.parse(expected);\n        assertEquals(\"Should parse to 12345 in ccp\", 12345, result.longValue());\n\n        df = (DecimalFormat) NumberFormat.getScientificInstance(new ULocale(\"ccp\"));\n        df.setParseStrict(true);\n        String expectedScientific = \"\\uD804\\uDD37.\\uD804\\uDD39E\\uD804\\uDD38\";\n        assertEquals(\"Should produce expected scientific output in ccp\",\n                expectedScientific, df.format(130));\n        Number resultScientific = df.parse(expectedScientific);\n        assertEquals(\"Should parse scientific to 130 in ccp\",\n                130, resultScientific.longValue());\n    }\n\n    @Test\n    public void Test13453_AffixContent() {\n        DecimalFormat df = (DecimalFormat) DecimalFormat.getScientificInstance();\n        assertEquals(\"Scientific should NOT be included\", \"\", df.getPositiveSuffix());\n\n        df = CompactDecimalFormat.getInstance(ULocale.ENGLISH, CompactDecimalFormat.CompactStyle.SHORT);\n        assertEquals(\"Compact should NOT be included\", \"\", df.getPositiveSuffix());\n\n        df = (DecimalFormat) DecimalFormat.getInstance(NumberFormat.ISOCURRENCYSTYLE);\n        df.setCurrency(Currency.getInstance(\"GBP\"));\n        assertEquals(\"ISO currency SHOULD be included\", \"GBP\", df.getPositivePrefix());\n\n        df = (DecimalFormat) DecimalFormat.getInstance(NumberFormat.PLURALCURRENCYSTYLE);\n        df.setCurrency(Currency.getInstance(\"GBP\"));\n        assertEquals(\"Plural name SHOULD be included\", \" British pounds\", df.getPositiveSuffix());\n    }\n\n    @Test\n    public void Test11035_FormatCurrencyAmount() {\n        double amount = 12345.67;\n        String expected = \"12,345$67\u00a0\u200b\";\n        Currency cur = Currency.getInstance(\"PTE\");\n\n        // Test three ways to set currency via API\n\n        ULocale loc1 = new ULocale(\"pt_PT\");\n        NumberFormat fmt1 = NumberFormat.getCurrencyInstance(loc1);\n        fmt1.setCurrency(cur);\n        String actualSetCurrency = fmt1.format(amount);\n\n        ULocale loc2 = new ULocale(\"pt_PT@currency=PTE\");\n        NumberFormat fmt2 = NumberFormat.getCurrencyInstance(loc2);\n        String actualLocaleString = fmt2.format(amount);\n\n        ULocale loc3 = new ULocale(\"pt_PT\");\n        NumberFormat fmt3 = NumberFormat.getCurrencyInstance(loc3);\n        CurrencyAmount curAmt = new CurrencyAmount(amount, cur);\n        String actualCurrencyAmount = fmt3.format(curAmt);\n\n        assertEquals(\"Custom Currency Pattern, Set Currency\", expected, actualSetCurrency);\n        assertEquals(\"Custom Currency Pattern, Locale String\", expected, actualCurrencyAmount);\n        assertEquals(\"Custom Currency Pattern, CurrencyAmount\", expected, actualLocaleString);\n    }\n\n    @Test\n    public void testPercentZero() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getPercentInstance();\n        String actual = df.format(0);\n        assertEquals(\"Should have one zero digit\", \"0%\", actual);\n    }\n\n    @Test\n    public void testCurrencyZeroRounding() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getCurrencyInstance();\n        df.setMaximumFractionDigits(0);\n        String actual = df.format(0);\n        assertEquals(\"Should have zero fraction digits\", \"$0\", actual);\n    }\n\n    @Test\n    public void testCustomCurrencySymbol() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getCurrencyInstance();\n        df.setCurrency(Currency.getInstance(\"USD\"));\n        DecimalFormatSymbols symbols = df.getDecimalFormatSymbols();\n        symbols.setCurrencySymbol(\"#\");\n        df.setDecimalFormatSymbols(symbols);\n        String actual = df.format(123);\n        assertEquals(\"Should use '#' instad of '$'\", \"#\u00a0123.00\", actual);\n    }\n\n    @Test\n    public void TestBasicSerializationRoundTrip() throws IOException, ClassNotFoundException {\n        DecimalFormat df0 = new DecimalFormat(\"A-**#####,#00.00b\u00a4\");\n\n        // Write to byte stream\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(baos);\n        oos.writeObject(df0);\n        oos.flush();\n        baos.close();\n        byte[] bytes = baos.toByteArray();\n\n        // Read from byte stream\n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Object obj = ois.readObject();\n        ois.close();\n        DecimalFormat df1 = (DecimalFormat) obj;\n\n        // Test equality\n        assertEquals(\"Did not round-trip through serialization\", df0, df1);\n\n        // Test basic functionality\n        String str0 = df0.format(12345.67);\n        String str1 = df1.format(12345.67);\n        assertEquals(\"Serialized formatter does not produce same output\", str0, str1);\n    }\n\n    @Test\n    public void testGetSetCurrency() {\n        DecimalFormat df = new DecimalFormat(\"\u00a4#\", DecimalFormatSymbols.getInstance(ULocale.US));\n        assertEquals(\"Currency should start out as the locale default\", Currency.getInstance(\"USD\"), df.getCurrency());\n        Currency curr = Currency.getInstance(\"EUR\");\n        df.setCurrency(curr);\n        assertEquals(\"Currency should equal EUR after set\", curr, df.getCurrency());\n        String result = df.format(123);\n        assertEquals(\"Currency should format as expected in EUR\", \"\u20ac123.00\", result);\n    }\n\n    @Test\n    public void testRoundingModeSetters() {\n        DecimalFormat df1 = new DecimalFormat();\n        DecimalFormat df2 = new DecimalFormat();\n\n        df1.setRoundingMode(java.math.BigDecimal.ROUND_CEILING);\n        assertNotEquals(\"Rounding mode was set to a non-default\", df1, df2);\n        df2.setRoundingMode(com.ibm.icu.math.BigDecimal.ROUND_CEILING);\n        assertEquals(\"Rounding mode from icu.math and java.math should be the same\", df1, df2);\n        df2.setRoundingMode(java.math.RoundingMode.CEILING.ordinal());\n        assertEquals(\"Rounding mode ordinal from java.math.RoundingMode should be the same\", df1, df2);\n    }\n\n    @Test\n    public void testCurrencySignificantDigits() {\n        ULocale locale = new ULocale(\"en-US\");\n        DecimalFormat df = (DecimalFormat) NumberFormat.getCurrencyInstance(locale);\n        df.setMaximumSignificantDigits(2);\n        String result = df.format(1234);\n        assertEquals(\"Currency rounding should obey significant digits\", \"$1,200\", result);\n    }\n\n    @Test\n    public void testParseStrictScientific() {\n        // See ticket #13057\n        DecimalFormat df = (DecimalFormat) NumberFormat.getScientificInstance();\n        df.setParseStrict(true);\n        ParsePosition ppos = new ParsePosition(0);\n        Number result0 = df.parse(\"123E4\", ppos);\n        assertEquals(\"Should accept number with exponent\", 1230000L, result0);\n        assertEquals(\"Should consume the whole number\", 5, ppos.getIndex());\n        ppos.setIndex(0);\n        result0 = df.parse(\"123\", ppos);\n        // #13737: For backwards compatibility, do NOT require the exponent.\n        assertEquals(\"Should NOT reject number without exponent\", 123L, result0);\n        ppos.setIndex(0);\n        CurrencyAmount result1 = df.parseCurrency(\"USD123\", ppos);\n        assertEquals(\"Should NOT reject currency without exponent\",\n                new CurrencyAmount(123L, Currency.getInstance(\"USD\")),\n                result1);\n    }\n\n    @Test\n    public void testParseLenientScientific() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getScientificInstance();\n        ParsePosition ppos = new ParsePosition(0);\n        Number result0 = df.parse(\"123E\", ppos);\n        assertEquals(\"Should parse the number in lenient mode\", 123L, result0);\n        assertEquals(\"Should stop before the E\", 3, ppos.getIndex());\n        DecimalFormatSymbols dfs = df.getDecimalFormatSymbols();\n        dfs.setExponentSeparator(\"EE\");\n        df.setDecimalFormatSymbols(dfs);\n        ppos.setIndex(0);\n        result0 = df.parse(\"123EE\", ppos);\n        assertEquals(\"Should parse the number in lenient mode\", 123L, result0);\n        assertEquals(\"Should stop before the EE\", 3, ppos.getIndex());\n    }\n\n    @Test\n    public void testParseAcceptAsciiPercentPermilleFallback() {\n        ULocale loc = new ULocale(\"ar\");\n        DecimalFormat df = (DecimalFormat) NumberFormat.getPercentInstance(loc);\n        ParsePosition ppos = new ParsePosition(0);\n        Number result = df.parse(\"42%\", ppos);\n        assertEquals(\"Should parse as 0.42 even in ar\", new BigDecimal(\"0.42\"), result);\n        assertEquals(\"Should consume the entire string even in ar\", 3, ppos.getIndex());\n        // TODO: Is there a better way to make a localized permille formatter?\n        df.applyPattern(df.toPattern().replace(\"%\", \"\u2030\"));\n        ppos.setIndex(0);\n        result = df.parse(\"42\u2030\", ppos);\n        assertEquals(\"Should parse as 0.042 even in ar\", new BigDecimal(\"0.042\"), result);\n        assertEquals(\"Should consume the entire string even in ar\", 3, ppos.getIndex());\n    }\n\n    @Test\n    public void testParseSubtraction() {\n        // TODO: Is this a case we need to support? It prevents us from automatically parsing\n        // minus signs that appear after the number, like  in \"12-\" vs \"-12\".\n        DecimalFormat df = new DecimalFormat();\n        String str = \"12 - 5\";\n        ParsePosition ppos = new ParsePosition(0);\n        Number n1 = df.parse(str, ppos);\n        Number n2 = df.parse(str, ppos);\n        assertEquals(\"Should parse 12 and -5\", 12, n1.intValue());\n        assertEquals(\"Should parse 12 and -5\", -5, n2.intValue());\n    }\n\n    @Test\n    public void testSetPrefixDefaultSuffix() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getPercentInstance();\n        df.setPositivePrefix(\"+\");\n        assertEquals(\"Should have manual plus sign and auto percent sign\", \"+100%\", df.format(1));\n    }\n\n    @Test\n    public void testMultiCodePointPaddingInPattern() {\n        DecimalFormat df = new DecimalFormat(\"a*'\u0ba8\u0bbf'###0b\");\n        String result = df.format(12);\n        assertEquals(\"Multi-codepoint padding should not be split\", \"a\u0ba8\u0bbf\u0ba8\u0bbf12b\", result);\n        df = new DecimalFormat(\"a*\ud83d\ude01###0b\");\n        result = df.format(12);\n        assertEquals(\"Single-codepoint padding should not be split\", \"a\ud83d\ude01\ud83d\ude0112b\", result);\n        df = new DecimalFormat(\"a*''###0b\");\n        result = df.format(12);\n        assertEquals(\"Quote should be escapable in padding syntax\", \"a''12b\", result);\n    }\n\n    @Test\n    public void Test13737_ParseScientificStrict() {\n        NumberFormat df = NumberFormat.getScientificInstance(ULocale.ENGLISH);\n        df.setParseStrict(true);\n        // Parse Test: exponent is not required, even in strict mode\n        expect(df, \"1.2\", 1.2);\n    }\n\n    // TODO: Investigate this test and re-enable if appropriate.\n    @Test\n    @Ignore\n    public void testParseAmbiguousAffixes() {\n        BigDecimal positive = new BigDecimal(\"0.0567\");\n        BigDecimal negative = new BigDecimal(\"-0.0567\");\n        DecimalFormat df = new DecimalFormat();\n        df.setParseBigDecimal(true);\n\n        String[] patterns = { \"+0.00%;-0.00%\", \"+0.00%;0.00%\", \"0.00%;-0.00%\" };\n        String[] inputs = { \"+5.67%\", \"-5.67%\", \"5.67%\" };\n        boolean[][] expectedPositive = {\n                { true, false, true },\n                { true, false, false },\n                { true, false, true }\n        };\n\n        for (int i=0; i<patterns.length; i++) {\n            String pattern = patterns[i];\n            df.applyPattern(pattern);\n            for (int j=0; j<inputs.length; j++) {\n                String input = inputs[j];\n                ParsePosition ppos = new ParsePosition(0);\n                Number actual = df.parse(input, ppos);\n                BigDecimal expected = expectedPositive[i][j] ? positive : negative;\n                String message = \"Pattern \" + pattern + \" with input \" + input;\n                assertEquals(message, expected, actual);\n                assertEquals(message, input.length(), ppos.getIndex());\n            }\n        }\n    }\n\n    @Test\n    public void testParseIgnorables() {\n        // Also see the test case \"test parse ignorables\" in numberformattestspecification.txt\n        DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance();\n        dfs.setPercentString(\"\\u200E%\\u200E\");\n        DecimalFormat df = new DecimalFormat(\"0 %;-0a\", dfs);\n        ParsePosition ppos = new ParsePosition(0);\n        Number result = df.parse(\"42\\u200E%\\u200E \", ppos);\n        assertEquals(\"Should parse as percentage\", new BigDecimal(\"0.42\"), result);\n        assertEquals(\"Should consume the trailing bidi since it is in the symbol\", 5, ppos.getIndex());\n        ppos.setIndex(0);\n        result = df.parse(\"-42a\\u200E \", ppos);\n        assertEquals(\"Should parse as percent\", -0.42, result.doubleValue());\n        assertEquals(\"Should not consume the trailing bidi or whitespace\", 4, ppos.getIndex());\n\n        // A few more cases based on the docstring:\n        expect(df, \"42%\", 0.42);\n        expect(df, \"42 %\", 0.42);\n        expect(df, \"42   %\", 0.42);\n        expect(df, \"42\\u00A0%\", 0.42);\n    }\n\n    @Test\n    public void testCustomCurrencyUsageOverridesPattern() {\n        DecimalFormat df = new DecimalFormat(\"#,##0.###\");\n        expect2(df, 1234, \"1,234\");\n        df.setCurrencyUsage(CurrencyUsage.STANDARD);\n        expect2(df, 1234, \"1,234.00\");\n        df.setCurrencyUsage(null);\n        expect2(df, 1234, \"1,234\");\n    }\n\n    @Test\n    public void testCurrencyUsageFractionOverrides() {\n        NumberFormat df = DecimalFormat.getCurrencyInstance(ULocale.US);\n        expect2(df, 35.0, \"$35.00\");\n        df.setMinimumFractionDigits(3);\n        expect2(df, 35.0, \"$35.000\");\n        df.setMaximumFractionDigits(3);\n        expect2(df, 35.0, \"$35.000\");\n        df.setMinimumFractionDigits(-1);\n        expect2(df, 35.0, \"$35.00\");\n        df.setMaximumFractionDigits(-1);\n        expect2(df, 35.0, \"$35.00\");\n    }\n\n    @Test\n    public void testParseVeryVeryLargeExponent() {\n        DecimalFormat df = new DecimalFormat();\n        ParsePosition ppos = new ParsePosition(0);\n\n        Object[][] cases = {\n                {\"1.2E+1234567890\", Double.POSITIVE_INFINITY},\n                {\"1.2E+999999999\", new com.ibm.icu.math.BigDecimal(\"1.2E+999999999\")},\n                {\"1.2E+1000000000\", Double.POSITIVE_INFINITY},\n                {\"-1.2E+999999999\", new com.ibm.icu.math.BigDecimal(\"-1.2E+999999999\")},\n                {\"-1.2E+1000000000\", Double.NEGATIVE_INFINITY},\n                {\"1.2E-999999999\", new com.ibm.icu.math.BigDecimal(\"1.2E-999999999\")},\n                {\"1.2E-1000000000\", 0.0},\n                {\"-1.2E-999999999\", new com.ibm.icu.math.BigDecimal(\"-1.2E-999999999\")},\n                {\"-1.2E-1000000000\", -0.0},\n\n        };\n\n        for (Object[] cas : cases) {\n            ppos.setIndex(0);\n            String input = (String) cas[0];\n            Number expected = (Number) cas[1];\n            Number actual = df.parse(input, ppos);\n            assertEquals(input, expected, actual);\n        }\n    }\n\n    @Test\n    public void testStringMethodsNPE() {\n        String[] npeMethods = {\n                \"applyLocalizedPattern\",\n                \"applyPattern\",\n                \"setNegativePrefix\",\n                \"setNegativeSuffix\",\n                \"setPositivePrefix\",\n                \"setPositiveSuffix\"\n        };\n        for (String npeMethod : npeMethods) {\n            DecimalFormat df = new DecimalFormat();\n            try {\n                DecimalFormat.class.getDeclaredMethod(npeMethod, String.class).invoke(df, (String) null);\n                fail(\"NullPointerException not thrown in method \" + npeMethod);\n            } catch (InvocationTargetException e) {\n                assertTrue(\"Exception should be NullPointerException in method \" + npeMethod,\n                        e.getCause() instanceof NullPointerException);\n            } catch (Exception e) {\n                // Other reflection exceptions\n                throw new AssertionError(\"Reflection error in method \" + npeMethod + \": \" + e.getMessage());\n            }\n        }\n\n        // Also test the constructors\n        try {\n            new DecimalFormat(null);\n            fail(\"NullPointerException not thrown in 1-parameter constructor\");\n        } catch (NullPointerException e) {\n            // Expected\n        }\n        try {\n            new DecimalFormat(null, new DecimalFormatSymbols());\n            fail(\"NullPointerException not thrown in 2-parameter constructor\");\n        } catch (NullPointerException e) {\n            // Expected\n        }\n        try {\n            new DecimalFormat(null, new DecimalFormatSymbols(), CurrencyPluralInfo.getInstance(), 0);\n            fail(\"NullPointerException not thrown in 4-parameter constructor\");\n        } catch (NullPointerException e) {\n            // Expected\n        }\n    }\n\n    @Test\n    public void testParseNoExponent() throws ParseException {\n        DecimalFormat df = new DecimalFormat();\n        assertEquals(\"Parse no exponent has wrong default\", false, df.getParseNoExponent());\n        Number result1 = df.parse(\"123E4\");\n        df.setParseNoExponent(true);\n        assertEquals(\"Parse no exponent getter is broken\", true, df.getParseNoExponent());\n        Number result2 = df.parse(\"123E4\");\n        assertEquals(\"Exponent did not parse before setParseNoExponent\", result1, new Long(1230000));\n        assertEquals(\"Exponent parsed after setParseNoExponent\", result2, new Long(123));\n    }\n\n    @Test\n    public void testMinimumGroupingDigits() {\n        String[][] allExpected = {\n                {\"123\", \"123\"},\n                {\"1,230\", \"1230\"},\n                {\"12,300\", \"12,300\"},\n                {\"1,23,000\", \"1,23,000\"}\n        };\n\n        DecimalFormat df = new DecimalFormat(\"#,##,##0\");\n        assertEquals(\"Minimum grouping digits has wrong default\", 1, df.getMinimumGroupingDigits());\n\n        for (int l = 123, i=0; l <= 123000; l *= 10, i++) {\n            df.setMinimumGroupingDigits(1);\n            assertEquals(\"Minimum grouping digits getter is broken\", 1, df.getMinimumGroupingDigits());\n            String actual = df.format(l);\n            assertEquals(\"Output is wrong for 1, \"+i, allExpected[i][0], actual);\n            df.setMinimumGroupingDigits(2);\n            assertEquals(\"Minimum grouping digits getter is broken\", 2, df.getMinimumGroupingDigits());\n            actual = df.format(l);\n            assertEquals(\"Output is wrong for 2, \"+i, allExpected[i][1], actual);\n        }\n    }\n\n    @Test\n    public void testParseCaseSensitive() {\n        String[] patterns = {\"a#b\", \"A#B\"};\n        String[] inputs = {\"a500b\", \"A500b\", \"a500B\", \"a500e10b\", \"a500E10b\"};\n        int[][] expectedParsePositions = {\n                {5, 5, 5, 8, 8}, // case insensitive, pattern 0\n                {5, 0, 4, 4, 8}, // case sensitive, pattern 0\n                {5, 5, 5, 8, 8}, // case insensitive, pattern 1\n                {0, 4, 0, 0, 0}, // case sensitive, pattern 1\n        };\n\n        for (int p = 0; p < patterns.length; p++) {\n            String pat = patterns[p];\n            DecimalFormat df = new DecimalFormat(pat);\n            assertEquals(\"parseCaseSensitive default is wrong\", false, df.getParseCaseSensitive());\n            for (int i = 0; i < inputs.length; i++) {\n                String inp = inputs[i];\n                df.setParseCaseSensitive(false);\n                assertEquals(\"parseCaseSensitive getter is broken\", false, df.getParseCaseSensitive());\n                ParsePosition actualInsensitive = new ParsePosition(0);\n                df.parse(inp, actualInsensitive);\n                assertEquals(\"Insensitive, pattern \"+p+\", input \"+i,\n                        expectedParsePositions[p*2][i], actualInsensitive.getIndex());\n                df.setParseCaseSensitive(true);\n                assertEquals(\"parseCaseSensitive getter is broken\", true, df.getParseCaseSensitive());\n                ParsePosition actualSensitive = new ParsePosition(0);\n                df.parse(inp, actualSensitive);\n                assertEquals(\"Sensitive, pattern \"+p+\", input \"+i,\n                        expectedParsePositions[p*2+1][i], actualSensitive.getIndex());\n            }\n        }\n    }\n\n    @Test\n    public void testPlusSignAlwaysShown() throws ParseException {\n        double[] numbers = {0.012, 5.78, 0, -0.012, -5.78};\n        ULocale[] locs = {new ULocale(\"en-US\"), new ULocale(\"ar-EG\"), new ULocale(\"es-CL\")};\n        String[][][] expecteds = {\n                // en-US\n                {\n                    // decimal\n                    { \"+0.012\", \"+5.78\", \"+0\", \"-0.012\", \"-5.78\" },\n                    // currency\n                    { \"+$0.01\", \"+$5.78\", \"+$0.00\", \"-$0.01\", \"-$5.78\" }\n                },\n                // ar-EG (interesting because the plus sign string starts with \\u061C)\n                {\n                    // decimal\n                    {\n                        \"\\u061C+\\u0660\\u066B\\u0660\\u0661\\u0662\", // \"\u061c+\u0660\u066b\u0660\u0661\u0662\"\n                        \"\\u061C+\\u0665\\u066B\\u0667\\u0668\", // \"\u061c+\u0665\u066b\u0667\u0668\"\n                        \"\\u061C+\\u0660\", // \"\u061c+\u0660\"\n                        \"\\u061C-\\u0660\\u066B\\u0660\\u0661\\u0662\", // \"\u061c-\u0660\u066b\u0660\u0661\u0662\"\n                        \"\\u061C-\\u0665\\u066B\\u0667\\u0668\", // \"\u061c-\u0665\u066b\u0667\u0668\"\n                    },\n                    // currency (\\062C.\\0645.\\200F is the currency sign in ar for EGP)\n                    {\n                        \"\\u061C+\\u0660\\u066B\\u0660\\u0661\\u00A0\\u062C.\\u0645.\\u200F\",\n                        \"\\u061C+\\u0665\\u066B\\u0667\\u0668\\u00A0\\u062C.\\u0645.\\u200F\",\n                        \"\\u061C+\\u0660\\u066B\\u0660\\u0660\\u00A0\\u062C.\\u0645.\\u200F\",\n                        \"\\u061C-\\u0660\\u066B\\u0660\\u0661\\u00A0\\u062C.\\u0645.\\u200F\",\n                        \"\\u061C-\\u0665\\u066B\\u0667\\u0668\\u00A0\\u062C.\\u0645.\\u200F\"\n                    }\n                },\n                // es-CL (interesting because of position of sign in currency)\n                {\n                    // decimal\n                    { \"+0,012\", \"+5,78\", \"+0\", \"-0,012\", \"-5,78\" },\n                    // currency (note: rounding for es-CL's currency, CLP, is 0 fraction digits)\n                    { \"$+0\", \"$+6\", \"$+0\", \"$-0\", \"$-6\" }\n                }\n        };\n\n        for (int i=0; i<locs.length; i++) {\n            ULocale loc = locs[i];\n            DecimalFormat df1 = (DecimalFormat) NumberFormat.getNumberInstance(loc);\n            assertFalse(\"Default should be false\", df1.getSignAlwaysShown());\n            df1.setSignAlwaysShown(true);\n            assertTrue(\"Getter should now return true\", df1.getSignAlwaysShown());\n            DecimalFormat df2 = (DecimalFormat) NumberFormat.getCurrencyInstance(loc);\n            assertFalse(\"Default should be false\", df2.getSignAlwaysShown());\n            df2.setSignAlwaysShown(true);\n            assertTrue(\"Getter should now return true\", df2.getSignAlwaysShown());\n            for (int j=0; j<2; j++) {\n                DecimalFormat df = (j == 0) ? df1 : df2;\n                for (int k=0; k<numbers.length; k++) {\n                    double d = numbers[k];\n                    String exp = expecteds[i][j][k];\n                    String act = df.format(d);\n                    assertEquals(\"Locale \" + loc + \", type \" + j + \", \" + d, exp, act);\n                    BigDecimal parsedExp = BigDecimal.valueOf(d);\n                    if (j == 1) {\n                        // Currency-round expected parse output\n                        int scale = (i == 2) ? 0 : 2;\n                        parsedExp = parsedExp.setScale(scale, BigDecimal.ROUND_HALF_EVEN);\n                    }\n                    Number parsedNum = df.parse(exp);\n                    BigDecimal parsedAct = (parsedNum.getClass() == BigDecimal.class)\n                            ? (BigDecimal) parsedNum\n                            : BigDecimal.valueOf(parsedNum.doubleValue());\n                    assertEquals(\n                            \"Locale \" + loc + \", type \" + j + \", \" + d + \", \" + parsedExp + \" => \" + parsedAct,\n                            0, parsedExp.compareTo(parsedAct));\n                }\n            }\n        }\n    }\n\n    @Test\n    public void Test20073_StrictPercentParseErrorIndex() {\n        ParsePosition parsePosition = new ParsePosition(0);\n        DecimalFormat df = new DecimalFormat(\"0%\", DecimalFormatSymbols.getInstance(Locale.US));\n        df.setParseStrict(true);\n        Number number = df.parse(\"%2%\", parsePosition);\n        assertNull(\"\", number);\n        assertEquals(\"\", 0, parsePosition.getIndex());\n        assertEquals(\"\", 0, parsePosition.getErrorIndex());\n    }\n\n    @Test\n    public void Test11626_CustomizeCurrencyPluralInfo() throws ParseException {\n        // Use locale sr because it has interesting plural rules.\n        ULocale locale = ULocale.forLanguageTag(\"sr\");\n        DecimalFormatSymbols symbols = DecimalFormatSymbols.getInstance(locale);\n        CurrencyPluralInfo info = CurrencyPluralInfo.getInstance(locale);\n        info.setCurrencyPluralPattern(\"one\", \"0 qwerty\");\n        info.setCurrencyPluralPattern(\"few\", \"0 dvorak\");\n        DecimalFormat df = new DecimalFormat(\"#\", symbols, info, NumberFormat.CURRENCYSTYLE);\n        df.setCurrency(Currency.getInstance(\"USD\"));\n        df.setMaximumFractionDigits(0);\n\n        assertEquals(\"Plural one\", \"1 qwerty\", df.format(1));\n        assertEquals(\"Plural few\", \"3 dvorak\", df.format(3));\n        assertEquals(\"Plural other\", \"99 \u0430\u043c\u0435\u0440\u0438\u0447\u043a\u0438\u0445 \u0434\u043e\u043b\u0430\u0440\u0430\", df.format(99));\n\n        info.setPluralRules(\"few: n is 1; one: n in 2..4\");\n        df.setCurrencyPluralInfo(info);\n        assertEquals(\"Plural one\", \"1 dvorak\", df.format(1));\n        assertEquals(\"Plural few\", \"3 qwerty\", df.format(3));\n        assertEquals(\"Plural other\", \"99 \u0430\u043c\u0435\u0440\u0438\u0447\u043a\u0438\u0445 \u0434\u043e\u043b\u0430\u0440\u0430\", df.format(99));\n    }\n\n    @Test\n    public void TestNarrowCurrencySymbols() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getCurrencyInstance(ULocale.CANADA);\n        df.setCurrency(Currency.getInstance(\"USD\"));\n        expect2(df, 123.45, \"US$123.45\");\n        String pattern = df.toPattern();\n        pattern = pattern.replace(\"\u00a4\", \"\u00a4\u00a4\u00a4\u00a4\u00a4\");\n        df.applyPattern(pattern);\n        // Note: Narrow currency is not parseable because of ambiguity.\n        assertEquals(\"Narrow currency symbol for USD in en_CA is $\",\n                \"$123.45\", df.format(123.45));\n    }\n\n    @Test\n    public void TestAffixOverrideBehavior() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getInstance(ULocale.ENGLISH);\n        expect2(df, 100, \"100\");\n        expect2(df, -100, \"-100\");\n        // This is not the right way to set an override plus sign, but we need to support it for compatibility.\n        df.setPositivePrefix(\"+\");\n        expect2(df, 100, \"+100\");\n        expect2(df, -100, \"-100\"); // note: the positive prefix does not affect the negative prefix\n        df.applyPattern(\"a0\");\n        expect2(df, 100, \"a100\");\n        expect2(df, -100, \"-a100\");\n    }\n\n    @Test\n    public void TestCurrencyRoundingMinWithoutMax() {\n        NumberFormat currencyFormat = DecimalFormat.getCurrencyInstance(Locale.US);\n        currencyFormat.setCurrency(Currency.getInstance(\"AUD\"));\n        currencyFormat.setMinimumFractionDigits(0);\n        expect(currencyFormat, 0.001, \"A$0\");\n\n        // NOTE: The size of the increment takes precedent over minFrac since ICU 59.\n        // CAD-Cash uses nickel rounding.\n        currencyFormat = DecimalFormat.getCurrencyInstance(Locale.US);\n        currencyFormat.setCurrency(Currency.getInstance(\"CAD\"));\n        ((DecimalFormat)currencyFormat).setCurrencyUsage(CurrencyUsage.CASH);\n        currencyFormat.setMinimumFractionDigits(0);\n        // expect(currencyFormat, 0.08, \"CA$0.1\");  // ICU 58 and down\n        expect(currencyFormat, 0.08, \"CA$0.10\");  // ICU 59 and up\n    }\n\n    @Test\n    public void testParsePositionIncrease() {\n        String input = \"123\\n456\\n$789\";\n        ParsePosition ppos = new ParsePosition(0);\n        DecimalFormat df = new DecimalFormat();\n        df.parse(input, ppos);\n        assertEquals(\"Should stop after first entry\", 3, ppos.getIndex());\n        ppos.setIndex(ppos.getIndex() + 1);\n        df.parse(input, ppos);\n        assertEquals(\"Should stop after second entry\", 7, ppos.getIndex());\n        ppos.setIndex(ppos.getIndex() + 1);\n        df.parseCurrency(input, ppos); // test parseCurrency API as well\n        assertEquals(\"Should stop after third entry\", 12, ppos.getIndex());\n    }\n\n    @Test\n    public void testTrailingMinusSign() {\n        String input = \"52-\";\n        DecimalFormat df = (DecimalFormat) DecimalFormat.getInstance(ULocale.ENGLISH);\n        ParsePosition ppos = new ParsePosition(0);\n        Number result = df.parse(input, ppos);\n        assertEquals(\"Trailing sign should NOT be accepted after the number in English by default\",\n                52.0,\n                result.doubleValue(),\n                0.0);\n        df.applyPattern(\"#;#-\");\n        ppos.setIndex(0);\n        result = df.parse(input, ppos);\n        assertEquals(\"Trailing sign SHOULD be accepted if there is one in the pattern\",\n                -52.0,\n                result.doubleValue(),\n                0.0);\n    }\n\n    @Test\n    public void testScientificCustomSign() {\n        DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(ULocale.ENGLISH);\n        dfs.setMinusSignString(\"nnn\");\n        dfs.setPlusSignString(\"ppp\");\n        DecimalFormat df = new DecimalFormat(\"0E0\", dfs);\n        df.setExponentSignAlwaysShown(true);\n        expect2(df, 0.5, \"5Ennn1\");\n        expect2(df, 50, \"5Eppp1\");\n    }\n\n    @Test\n    public void testParsePercentInPattern() {\n        DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(ULocale.ENGLISH);\n        DecimalFormat df = new DecimalFormat(\"0x%\", dfs);\n        df.setParseStrict(true);\n        expect2(df, 0.5, \"50x%\");\n    }\n\n    @Test\n    public void testParseIsoStrict() {\n        DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(ULocale.ENGLISH);\n        DecimalFormat df = new DecimalFormat(\"\u00a4\u00a40;-0\u00a4\u00a4\", dfs);\n        df.setCurrency(Currency.getInstance(\"USD\"));\n        df.setParseStrict(true);\n        expect2(df, 45, \"USD\u00a045.00\");\n        expect2(df, -45, \"-45.00\u00a0USD\");\n    }\n\n    @Test\n    public void test13684_FrenchPercentParsing() {\n        NumberFormat numberFormat = NumberFormat.getPercentInstance(ULocale.FRENCH);\n        numberFormat.setParseStrict(true);\n        ParsePosition ppos = new ParsePosition(0);\n        Number percentage = numberFormat.parse(\"8\\u00A0%\", ppos);\n        assertEquals(\"Should parse successfully\", 0.08, percentage.doubleValue());\n        assertEquals(\"Should consume whole string\", 3, ppos.getIndex());\n    }\n\n    @Test\n    public void testStrictParseCurrencyLongNames() {\n        DecimalFormat df = (DecimalFormat) DecimalFormat.getInstance(ULocale.ENGLISH, DecimalFormat.PLURALCURRENCYSTYLE);\n        df.setParseStrict(true);\n        df.setCurrency(Currency.getInstance(\"USD\"));\n        double input = 514.23;\n        String formatted = df.format(input);\n        String expected = \"514.23 US dollars\";\n        assertEquals(\"Should format as expected\", expected, formatted);\n        ParsePosition ppos = new ParsePosition(0);\n        CurrencyAmount ca = df.parseCurrency(formatted, ppos);\n        assertEquals(\"Should consume whole number\", ppos.getIndex(), 17);\n        assertEquals(\"Number should round-trip\", ca.getNumber().doubleValue(), input);\n        assertEquals(\"Should get correct currency\", ca.getCurrency().getCurrencyCode(), \"USD\");\n        // Should also round-trip in non-currency parsing\n        expect2(df, input, expected);\n    }\n\n    @Test\n    public void testStrictParseCurrencySpacing() {\n        DecimalFormat df = new DecimalFormat(\"\u00a4\u00a00\", DecimalFormatSymbols.getInstance(ULocale.ROOT));\n        df.setCurrency(Currency.getInstance(\"USD\"));\n        df.setParseStrict(true);\n        expect2(df, -51.42, \"-US$\u00a051.42\");\n    }\n\n    @Test\n    public void testCaseSensitiveCustomIsoCurrency() {\n        DecimalFormat df = new DecimalFormat(\"\u00a4\u00a40\", DecimalFormatSymbols.getInstance(ULocale.ENGLISH));\n        df.setCurrency(Currency.getInstance(\"ICU\"));\n        ParsePosition ppos = new ParsePosition(0);\n        df.parseCurrency(\"icu123\", ppos);\n        assertEquals(\"Should succeed\", 6, ppos.getIndex());\n        assertEquals(\"Should succeed\", -1, ppos.getErrorIndex());\n    }\n\n    @Test\n    public void testCurrencyPluralAffixOverrides() {\n        // The affix setters should override CurrencyPluralInfo, used in the plural currency constructor.\n        DecimalFormat df = (DecimalFormat) NumberFormat.getInstance(ULocale.ENGLISH, NumberFormat.PLURALCURRENCYSTYLE);\n        assertEquals(\"Defaults to unknown currency\", \" (unknown currency)\", df.getPositiveSuffix());\n        df.setCurrency(Currency.getInstance(\"USD\"));\n        assertEquals(\"Should resolve to CurrencyPluralInfo\", \" US dollars\", df.getPositiveSuffix());\n        df.setPositiveSuffix(\"lala\");\n        assertEquals(\"Custom suffix should round-trip\", \"lala\", df.getPositiveSuffix());\n        assertEquals(\"Custom suffix should be used in formatting\", \"123.00lala\", df.format(123));\n    }\n\n    @Test\n    public void testParseDoubleMinus() {\n        DecimalFormat df = new DecimalFormat(\"-0\", DecimalFormatSymbols.getInstance(ULocale.ENGLISH));\n        expect2(df, -5, \"--5\");\n    }\n\n    @Test\n    public void testParsePercentRegression() {\n        DecimalFormat df1 = (DecimalFormat) NumberFormat.getInstance(ULocale.ENGLISH);\n        DecimalFormat df2 = (DecimalFormat) NumberFormat.getPercentInstance(ULocale.ENGLISH);\n        df1.setParseStrict(false);\n        df2.setParseStrict(false);\n\n        {\n            ParsePosition ppos = new ParsePosition(0);\n            Number result = df1.parse(\"50%\", ppos);\n            assertEquals(\"df1 should accept a number but not the percent sign\", 2, ppos.getIndex());\n            assertEquals(\"df1 should return the number as 50\", 50.0, result.doubleValue());\n        }\n        {\n            ParsePosition ppos = new ParsePosition(0);\n            Number result = df2.parse(\"50%\", ppos);\n            assertEquals(\"df2 should accept the percent sign\", 3, ppos.getIndex());\n            assertEquals(\"df2 should return the number as 0.5\", 0.5, result.doubleValue());\n        }\n        {\n            ParsePosition ppos = new ParsePosition(0);\n            Number result = df2.parse(\"50\", ppos);\n            assertEquals(\"df2 should return the number as 0.5 even though the percent sign is missing\",\n                    0.5,\n                    result.doubleValue());\n        }\n    }\n\n    @Test\n    public void test13148_GroupingSeparatorOverride() throws Exception {\n        DecimalFormat fmt = (DecimalFormat)NumberFormat.getInstance(new ULocale(\"en\", \"ZA\"));\n        DecimalFormatSymbols symbols = fmt.getDecimalFormatSymbols();\n        symbols.setDecimalSeparator('.');\n        symbols.setGroupingSeparator(',');\n        fmt.setDecimalFormatSymbols(symbols);\n        Number number = fmt.parse(\"300,000\");\n        assertEquals(\"Should use custom symbols and not monetary symbols\", 300000L, number);\n    }\n\n    @Test\n    public void test11897_LocalizedPatternSeparator() {\n        DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(ULocale.ENGLISH);\n        dfs.setPatternSeparator('!');\n        DecimalFormat df = new DecimalFormat(\"0\", dfs);\n        df.applyPattern(\"a0;b0\"); // should not throw\n        assertEquals(\"should apply the normal pattern\", df.getNegativePrefix(), \"b\");\n        df.applyLocalizedPattern(\"c0!d0\"); // should not throw\n        assertEquals(\"should apply the localized pattern\", df.getNegativePrefix(), \"d\");\n    }\n\n    @Test\n    public void test13777_ParseLongNameNonCurrencyMode() {\n        // Currency long name should round-trip even when non-currency parsing is used.\n        NumberFormat df = NumberFormat.getInstance(ULocale.US, NumberFormat.PLURALCURRENCYSTYLE);\n        expect2(df, 1.5, \"1.50 US dollars\");\n    }\n\n    @Test\n    public void test13804_EmptyStringsWhenParsing() {\n        DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(ULocale.ENGLISH);\n        dfs.setCurrencySymbol(\"\");\n        dfs.setDecimalSeparatorString(\"\");\n        dfs.setDigitStrings(new String[] { \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\" });\n        dfs.setExponentMultiplicationSign(\"\");\n        dfs.setExponentSeparator(\"\");\n        dfs.setGroupingSeparatorString(\"\");\n        dfs.setInfinity(\"\");\n        dfs.setInternationalCurrencySymbol(\"\");\n        dfs.setMinusSignString(\"\");\n        dfs.setMonetaryDecimalSeparatorString(\"\");\n        dfs.setMonetaryGroupingSeparatorString(\"\");\n        dfs.setNaN(\"\");\n        dfs.setPatternForCurrencySpacing(DecimalFormatSymbols.CURRENCY_SPC_INSERT, false, \"\");\n        dfs.setPatternForCurrencySpacing(DecimalFormatSymbols.CURRENCY_SPC_INSERT, true, \"\");\n        dfs.setPercentString(\"\");\n        dfs.setPerMillString(\"\");\n        dfs.setPlusSignString(\"\");\n\n        DecimalFormat df = new DecimalFormat(\"0\", dfs);\n        df.setGroupingUsed(true);\n        df.setScientificNotation(true);\n        df.setParseStrict(false); // enable all matchers\n        df.format(0); // should not throw or hit infinite loop\n        String[] samples = new String[] {\n                \"\",\n                \"123\",\n                \"$123\",\n                \"-\",\n                \"+\",\n                \"44%\",\n                \"1E+2.3\"\n        };\n        for (String sample : samples) {\n            logln(\"Attempting parse on: \" + sample);\n            // We don't care about the results, only that we don't throw and don't loop.\n            ParsePosition ppos = new ParsePosition(0);\n            df.parse(sample, ppos);\n            ppos = new ParsePosition(0);\n            df.parseCurrency(sample, ppos);\n        }\n\n        // Test with a nonempty exponent separator symbol to cover more code\n        dfs.setExponentSeparator(\"E\");\n        df.setDecimalFormatSymbols(dfs);\n        {\n            ParsePosition ppos = new ParsePosition(0);\n            df.parse(\"1E+2.3\", ppos);\n        }\n    }\n\n    @Test\n    public void Test20037_ScientificIntegerOverflow() throws ParseException {\n        NumberFormat nf = NumberFormat.getInstance(ULocale.US);\n\n        // Test overflow of exponent\n        Number result = nf.parse(\"1E-2147483648\");\n        assertEquals(\"Should snap to zero\",\n                \"0\", result.toString());\n\n        // Test edge case overflow of exponent\n        // Note: the behavior is different from C++; this is probably due to the\n        // intermediate BigDecimal form, which has its own restrictions\n        result = nf.parse(\"1E-2147483647E-1\");\n        assertEquals(\"Should not overflow and should parse only the first exponent\",\n                \"0.0\", result.toString());\n\n        // For Java, we should get *pretty close* to 2^31.\n        result = nf.parse(\"1E-547483647\");\n        assertEquals(\"Should *not* snap to zero\",\n                \"1E-547483647\", result.toString());\n    }\n\n    @Test\n    public void test13840_ParseLongStringCrash() throws ParseException {\n        NumberFormat nf = NumberFormat.getInstance(ULocale.ENGLISH);\n        String bigString =\n            \"111111111111111111111111111111111111111111111111111111111111111111111\" +\n            \"111111111111111111111111111111111111111111111111111111111111111111111\" +\n            \"111111111111111111111111111111111111111111111111111111111111111111111\" +\n            \"111111111111111111111111111111111111111111111111111111111111111111111\" +\n            \"111111111111111111111111111111111111111111111111111111111111111111111\" +\n            \"111111111111111111111111111111111111111111111111111111111111111111111\";\n        Number result = nf.parse(bigString);\n\n        // Normalize the input string:\n        BigDecimal expectedBigDecimal = new BigDecimal(bigString);\n        String expectedUString = expectedBigDecimal.toString();\n\n        // Get the output string:\n        BigDecimal actualBigDecimal = (BigDecimal) result;\n        String actualUString = actualBigDecimal.toString();\n\n        assertEquals(\"Should round-trip without crashing\", expectedUString, actualUString);\n    }\n}\n"], "fixing_code": ["// \u00a9 2016 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html\n/*\n*******************************************************************************\n* Copyright (C) 1997-2016, International Business Machines Corporation and\n* others. All Rights Reserved.\n*******************************************************************************\n*\n* File FMTABLE.CPP\n*\n* Modification History:\n*\n*   Date        Name        Description\n*   03/25/97    clhuang     Initial Implementation.\n********************************************************************************\n*/\n\n#include \"unicode/utypes.h\"\n\n#if !UCONFIG_NO_FORMATTING\n\n#include <cstdlib>\n#include <math.h>\n#include \"unicode/fmtable.h\"\n#include \"unicode/ustring.h\"\n#include \"unicode/measure.h\"\n#include \"unicode/curramt.h\"\n#include \"unicode/uformattable.h\"\n#include \"charstr.h\"\n#include \"cmemory.h\"\n#include \"cstring.h\"\n#include \"fmtableimp.h\"\n#include \"number_decimalquantity.h\"\n\n// *****************************************************************************\n// class Formattable\n// *****************************************************************************\n\nU_NAMESPACE_BEGIN\n\nUOBJECT_DEFINE_RTTI_IMPLEMENTATION(Formattable)\n\nusing number::impl::DecimalQuantity;\n\n\n//-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n// NOTE: As of 3.0, there are limitations to the UObject API.  It does\n// not (yet) support cloning, operator=, nor operator==.  To\n// work around this, I implement some simple inlines here.  Later\n// these can be modified or removed.  [alan]\n\n// NOTE: These inlines assume that all fObjects are in fact instances\n// of the Measure class, which is true as of 3.0.  [alan]\n\n// Return TRUE if *a == *b.\nstatic inline UBool objectEquals(const UObject* a, const UObject* b) {\n    // LATER: return *a == *b;\n    return *((const Measure*) a) == *((const Measure*) b);\n}\n\n// Return a clone of *a.\nstatic inline UObject* objectClone(const UObject* a) {\n    // LATER: return a->clone();\n    return ((const Measure*) a)->clone();\n}\n\n// Return TRUE if *a is an instance of Measure.\nstatic inline UBool instanceOfMeasure(const UObject* a) {\n    return dynamic_cast<const Measure*>(a) != NULL;\n}\n\n/**\n * Creates a new Formattable array and copies the values from the specified\n * original.\n * @param array the original array\n * @param count the original array count\n * @return the new Formattable array.\n */\nstatic Formattable* createArrayCopy(const Formattable* array, int32_t count) {\n    Formattable *result = new Formattable[count];\n    if (result != NULL) {\n        for (int32_t i=0; i<count; ++i)\n            result[i] = array[i]; // Don't memcpy!\n    }\n    return result;\n}\n\n//-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.\n\n/**\n * Set 'ec' to 'err' only if 'ec' is not already set to a failing UErrorCode.\n */\nstatic void setError(UErrorCode& ec, UErrorCode err) {\n    if (U_SUCCESS(ec)) {\n        ec = err;\n    }\n}\n\n//\n//  Common initialization code, shared by constructors.\n//  Put everything into a known state.\n//\nvoid  Formattable::init() {\n    fValue.fInt64 = 0;\n    fType = kLong;\n    fDecimalStr = NULL;\n    fDecimalQuantity = NULL;\n    fBogus.setToBogus(); \n}\n\n// -------------------------------------\n// default constructor.\n// Creates a formattable object with a long value 0.\n\nFormattable::Formattable() {\n    init();\n}\n\n// -------------------------------------\n// Creates a formattable object with a Date instance.\n\nFormattable::Formattable(UDate date, ISDATE /*isDate*/)\n{\n    init();\n    fType = kDate;\n    fValue.fDate = date;\n}\n\n// -------------------------------------\n// Creates a formattable object with a double value.\n\nFormattable::Formattable(double value)\n{\n    init();\n    fType = kDouble;\n    fValue.fDouble = value;\n}\n\n// -------------------------------------\n// Creates a formattable object with an int32_t value.\n\nFormattable::Formattable(int32_t value)\n{\n    init();\n    fValue.fInt64 = value;\n}\n\n// -------------------------------------\n// Creates a formattable object with an int64_t value.\n\nFormattable::Formattable(int64_t value)\n{\n    init();\n    fType = kInt64;\n    fValue.fInt64 = value;\n}\n\n// -------------------------------------\n// Creates a formattable object with a decimal number value from a string.\n\nFormattable::Formattable(StringPiece number, UErrorCode &status) {\n    init();\n    setDecimalNumber(number, status);\n}\n\n\n// -------------------------------------\n// Creates a formattable object with a UnicodeString instance.\n\nFormattable::Formattable(const UnicodeString& stringToCopy)\n{\n    init();\n    fType = kString;\n    fValue.fString = new UnicodeString(stringToCopy);\n}\n\n// -------------------------------------\n// Creates a formattable object with a UnicodeString* value.\n// (adopting symantics)\n\nFormattable::Formattable(UnicodeString* stringToAdopt)\n{\n    init();\n    fType = kString;\n    fValue.fString = stringToAdopt;\n}\n\nFormattable::Formattable(UObject* objectToAdopt)\n{\n    init();\n    fType = kObject;\n    fValue.fObject = objectToAdopt;\n}\n\n// -------------------------------------\n\nFormattable::Formattable(const Formattable* arrayToCopy, int32_t count)\n    :   UObject(), fType(kArray)\n{\n    init();\n    fType = kArray;\n    fValue.fArrayAndCount.fArray = createArrayCopy(arrayToCopy, count);\n    fValue.fArrayAndCount.fCount = count;\n}\n\n// -------------------------------------\n// copy constructor\n\n\nFormattable::Formattable(const Formattable &source)\n     :  UObject(*this)\n{\n    init();\n    *this = source;\n}\n\n// -------------------------------------\n// assignment operator\n\nFormattable&\nFormattable::operator=(const Formattable& source)\n{\n    if (this != &source)\n    {\n        // Disposes the current formattable value/setting.\n        dispose();\n\n        // Sets the correct data type for this value.\n        fType = source.fType;\n        switch (fType)\n        {\n        case kArray:\n            // Sets each element in the array one by one and records the array count.\n            fValue.fArrayAndCount.fCount = source.fValue.fArrayAndCount.fCount;\n            fValue.fArrayAndCount.fArray = createArrayCopy(source.fValue.fArrayAndCount.fArray,\n                                                           source.fValue.fArrayAndCount.fCount);\n            break;\n        case kString:\n            // Sets the string value.\n            fValue.fString = new UnicodeString(*source.fValue.fString);\n            break;\n        case kDouble:\n            // Sets the double value.\n            fValue.fDouble = source.fValue.fDouble;\n            break;\n        case kLong:\n        case kInt64:\n            // Sets the long value.\n            fValue.fInt64 = source.fValue.fInt64;\n            break;\n        case kDate:\n            // Sets the Date value.\n            fValue.fDate = source.fValue.fDate;\n            break;\n        case kObject:\n            fValue.fObject = objectClone(source.fValue.fObject);\n            break;\n        }\n\n        UErrorCode status = U_ZERO_ERROR;\n        if (source.fDecimalQuantity != NULL) {\n          fDecimalQuantity = new DecimalQuantity(*source.fDecimalQuantity);\n        }\n        if (source.fDecimalStr != NULL) {\n            fDecimalStr = new CharString(*source.fDecimalStr, status);\n            if (U_FAILURE(status)) {\n                delete fDecimalStr;\n                fDecimalStr = NULL;\n            }\n        }\n    }\n    return *this;\n}\n\n// -------------------------------------\n\nUBool\nFormattable::operator==(const Formattable& that) const\n{\n    int32_t i;\n\n    if (this == &that) return TRUE;\n\n    // Returns FALSE if the data types are different.\n    if (fType != that.fType) return FALSE;\n\n    // Compares the actual data values.\n    UBool equal = TRUE;\n    switch (fType) {\n    case kDate:\n        equal = (fValue.fDate == that.fValue.fDate);\n        break;\n    case kDouble:\n        equal = (fValue.fDouble == that.fValue.fDouble);\n        break;\n    case kLong:\n    case kInt64:\n        equal = (fValue.fInt64 == that.fValue.fInt64);\n        break;\n    case kString:\n        equal = (*(fValue.fString) == *(that.fValue.fString));\n        break;\n    case kArray:\n        if (fValue.fArrayAndCount.fCount != that.fValue.fArrayAndCount.fCount) {\n            equal = FALSE;\n            break;\n        }\n        // Checks each element for equality.\n        for (i=0; i<fValue.fArrayAndCount.fCount; ++i) {\n            if (fValue.fArrayAndCount.fArray[i] != that.fValue.fArrayAndCount.fArray[i]) {\n                equal = FALSE;\n                break;\n            }\n        }\n        break;\n    case kObject:\n        if (fValue.fObject == NULL || that.fValue.fObject == NULL) {\n            equal = FALSE;\n        } else {\n            equal = objectEquals(fValue.fObject, that.fValue.fObject);\n        }\n        break;\n    }\n\n    // TODO:  compare digit lists if numeric.\n    return equal;\n}\n\n// -------------------------------------\n\nFormattable::~Formattable()\n{\n    dispose();\n}\n\n// -------------------------------------\n\nvoid Formattable::dispose()\n{\n    // Deletes the data value if necessary.\n    switch (fType) {\n    case kString:\n        delete fValue.fString;\n        break;\n    case kArray:\n        delete[] fValue.fArrayAndCount.fArray;\n        break;\n    case kObject:\n        delete fValue.fObject;\n        break;\n    default:\n        break;\n    }\n\n    fType = kLong;\n    fValue.fInt64 = 0;\n\n    delete fDecimalStr;\n    fDecimalStr = NULL;\n\n    delete fDecimalQuantity;\n    fDecimalQuantity = NULL;\n}\n\nFormattable *\nFormattable::clone() const {\n    return new Formattable(*this);\n}\n\n// -------------------------------------\n// Gets the data type of this Formattable object. \nFormattable::Type\nFormattable::getType() const\n{\n    return fType;\n}\n\nUBool\nFormattable::isNumeric() const {\n    switch (fType) {\n    case kDouble:\n    case kLong:\n    case kInt64:\n        return TRUE;\n    default:\n        return FALSE;\n    }\n}\n\n// -------------------------------------\nint32_t\n//Formattable::getLong(UErrorCode* status) const\nFormattable::getLong(UErrorCode& status) const\n{\n    if (U_FAILURE(status)) {\n        return 0;\n    }\n        \n    switch (fType) {\n    case Formattable::kLong: \n        return (int32_t)fValue.fInt64;\n    case Formattable::kInt64:\n        if (fValue.fInt64 > INT32_MAX) {\n            status = U_INVALID_FORMAT_ERROR;\n            return INT32_MAX;\n        } else if (fValue.fInt64 < INT32_MIN) {\n            status = U_INVALID_FORMAT_ERROR;\n            return INT32_MIN;\n        } else {\n            return (int32_t)fValue.fInt64;\n        }\n    case Formattable::kDouble:\n        if (fValue.fDouble > INT32_MAX) {\n            status = U_INVALID_FORMAT_ERROR;\n            return INT32_MAX;\n        } else if (fValue.fDouble < INT32_MIN) {\n            status = U_INVALID_FORMAT_ERROR;\n            return INT32_MIN;\n        } else {\n            return (int32_t)fValue.fDouble; // loses fraction\n        }\n    case Formattable::kObject:\n        if (fValue.fObject == NULL) {\n            status = U_MEMORY_ALLOCATION_ERROR;\n            return 0;\n        }\n        // TODO Later replace this with instanceof call\n        if (instanceOfMeasure(fValue.fObject)) {\n            return ((const Measure*) fValue.fObject)->\n                getNumber().getLong(status);\n        }\n        U_FALLTHROUGH;\n    default:\n        status = U_INVALID_FORMAT_ERROR;\n        return 0;\n    }\n}\n\n// -------------------------------------\n// Maximum int that can be represented exactly in a double.  (53 bits)\n//    Larger ints may be rounded to a near-by value as not all are representable.\n// TODO:  move this constant elsewhere, possibly configure it for different\n//        floating point formats, if any non-standard ones are still in use.\nstatic const int64_t U_DOUBLE_MAX_EXACT_INT = 9007199254740992LL;\n\nint64_t\nFormattable::getInt64(UErrorCode& status) const\n{\n    if (U_FAILURE(status)) {\n        return 0;\n    }\n        \n    switch (fType) {\n    case Formattable::kLong: \n    case Formattable::kInt64: \n        return fValue.fInt64;\n    case Formattable::kDouble:\n        if (fValue.fDouble > (double)U_INT64_MAX) {\n            status = U_INVALID_FORMAT_ERROR;\n            return U_INT64_MAX;\n        } else if (fValue.fDouble < (double)U_INT64_MIN) {\n            status = U_INVALID_FORMAT_ERROR;\n            return U_INT64_MIN;\n        } else if (fabs(fValue.fDouble) > U_DOUBLE_MAX_EXACT_INT && fDecimalQuantity != NULL) {\n            if (fDecimalQuantity->fitsInLong(true)) {\n                return fDecimalQuantity->toLong();\n            } else {\n                // Unexpected\n                status = U_INVALID_FORMAT_ERROR;\n                return fDecimalQuantity->isNegative() ? U_INT64_MIN : U_INT64_MAX;\n            }\n        } else {\n            return (int64_t)fValue.fDouble;\n        } \n    case Formattable::kObject:\n        if (fValue.fObject == NULL) {\n            status = U_MEMORY_ALLOCATION_ERROR;\n            return 0;\n        }\n        if (instanceOfMeasure(fValue.fObject)) {\n            return ((const Measure*) fValue.fObject)->\n                getNumber().getInt64(status);\n        }\n        U_FALLTHROUGH;\n    default:\n        status = U_INVALID_FORMAT_ERROR;\n        return 0;\n    }\n}\n\n// -------------------------------------\ndouble\nFormattable::getDouble(UErrorCode& status) const\n{\n    if (U_FAILURE(status)) {\n        return 0;\n    }\n        \n    switch (fType) {\n    case Formattable::kLong: \n    case Formattable::kInt64: // loses precision\n        return (double)fValue.fInt64;\n    case Formattable::kDouble:\n        return fValue.fDouble;\n    case Formattable::kObject:\n        if (fValue.fObject == NULL) {\n            status = U_MEMORY_ALLOCATION_ERROR;\n            return 0;\n        }\n        // TODO Later replace this with instanceof call\n        if (instanceOfMeasure(fValue.fObject)) {\n            return ((const Measure*) fValue.fObject)->\n                getNumber().getDouble(status);\n        }\n        U_FALLTHROUGH;\n    default:\n        status = U_INVALID_FORMAT_ERROR;\n        return 0;\n    }\n}\n\nconst UObject*\nFormattable::getObject() const {\n    return (fType == kObject) ? fValue.fObject : NULL;\n}\n\n// -------------------------------------\n// Sets the value to a double value d.\n\nvoid\nFormattable::setDouble(double d)\n{\n    dispose();\n    fType = kDouble;\n    fValue.fDouble = d;\n}\n\n// -------------------------------------\n// Sets the value to a long value l.\n\nvoid\nFormattable::setLong(int32_t l)\n{\n    dispose();\n    fType = kLong;\n    fValue.fInt64 = l;\n}\n\n// -------------------------------------\n// Sets the value to an int64 value ll.\n\nvoid\nFormattable::setInt64(int64_t ll)\n{\n    dispose();\n    fType = kInt64;\n    fValue.fInt64 = ll;\n}\n\n// -------------------------------------\n// Sets the value to a Date instance d.\n\nvoid\nFormattable::setDate(UDate d)\n{\n    dispose();\n    fType = kDate;\n    fValue.fDate = d;\n}\n\n// -------------------------------------\n// Sets the value to a string value stringToCopy.\n\nvoid\nFormattable::setString(const UnicodeString& stringToCopy)\n{\n    dispose();\n    fType = kString;\n    fValue.fString = new UnicodeString(stringToCopy);\n}\n\n// -------------------------------------\n// Sets the value to an array of Formattable objects.\n\nvoid\nFormattable::setArray(const Formattable* array, int32_t count)\n{\n    dispose();\n    fType = kArray;\n    fValue.fArrayAndCount.fArray = createArrayCopy(array, count);\n    fValue.fArrayAndCount.fCount = count;\n}\n\n// -------------------------------------\n// Adopts the stringToAdopt value.\n\nvoid\nFormattable::adoptString(UnicodeString* stringToAdopt)\n{\n    dispose();\n    fType = kString;\n    fValue.fString = stringToAdopt;\n}\n\n// -------------------------------------\n// Adopts the array value and its count.\n\nvoid\nFormattable::adoptArray(Formattable* array, int32_t count)\n{\n    dispose();\n    fType = kArray;\n    fValue.fArrayAndCount.fArray = array;\n    fValue.fArrayAndCount.fCount = count;\n}\n\nvoid\nFormattable::adoptObject(UObject* objectToAdopt) {\n    dispose();\n    fType = kObject;\n    fValue.fObject = objectToAdopt;\n}\n\n// -------------------------------------\nUnicodeString& \nFormattable::getString(UnicodeString& result, UErrorCode& status) const \n{\n    if (fType != kString) {\n        setError(status, U_INVALID_FORMAT_ERROR);\n        result.setToBogus();\n    } else {\n        if (fValue.fString == NULL) {\n            setError(status, U_MEMORY_ALLOCATION_ERROR);\n        } else {\n            result = *fValue.fString;\n        }\n    }\n    return result;\n}\n\n// -------------------------------------\nconst UnicodeString& \nFormattable::getString(UErrorCode& status) const \n{\n    if (fType != kString) {\n        setError(status, U_INVALID_FORMAT_ERROR);\n        return *getBogus();\n    }\n    if (fValue.fString == NULL) {\n        setError(status, U_MEMORY_ALLOCATION_ERROR);\n        return *getBogus();\n    }\n    return *fValue.fString;\n}\n\n// -------------------------------------\nUnicodeString& \nFormattable::getString(UErrorCode& status) \n{\n    if (fType != kString) {\n        setError(status, U_INVALID_FORMAT_ERROR);\n        return *getBogus();\n    }\n    if (fValue.fString == NULL) {\n    \tsetError(status, U_MEMORY_ALLOCATION_ERROR);\n    \treturn *getBogus();\n    }\n    return *fValue.fString;\n}\n\n// -------------------------------------\nconst Formattable* \nFormattable::getArray(int32_t& count, UErrorCode& status) const \n{\n    if (fType != kArray) {\n        setError(status, U_INVALID_FORMAT_ERROR);\n        count = 0;\n        return NULL;\n    }\n    count = fValue.fArrayAndCount.fCount; \n    return fValue.fArrayAndCount.fArray;\n}\n\n// -------------------------------------\n// Gets the bogus string, ensures mondo bogosity.\n\nUnicodeString*\nFormattable::getBogus() const \n{\n    return (UnicodeString*)&fBogus; /* cast away const :-( */\n}\n\n\n// --------------------------------------\nStringPiece Formattable::getDecimalNumber(UErrorCode &status) {\n    if (U_FAILURE(status)) {\n        return \"\";\n    }\n    if (fDecimalStr != NULL) {\n      return fDecimalStr->toStringPiece();\n    }\n\n    CharString *decimalStr = internalGetCharString(status);\n    if(decimalStr == NULL) {\n      return \"\"; // getDecimalNumber returns \"\" for error cases\n    } else {\n      return decimalStr->toStringPiece();\n    }\n}\n\nCharString *Formattable::internalGetCharString(UErrorCode &status) {\n    if(fDecimalStr == NULL) {\n      if (fDecimalQuantity == NULL) {\n        // No decimal number for the formattable yet.  Which means the value was\n        // set directly by the user as an int, int64 or double.  If the value came\n        // from parsing, or from the user setting a decimal number, fDecimalNum\n        // would already be set.\n        //\n        LocalPointer<DecimalQuantity> dq(new DecimalQuantity(), status);\n        if (U_FAILURE(status)) { return nullptr; }\n        populateDecimalQuantity(*dq, status);\n        if (U_FAILURE(status)) { return nullptr; }\n        fDecimalQuantity = dq.orphan();\n      }\n\n      fDecimalStr = new CharString();\n      if (fDecimalStr == NULL) {\n        status = U_MEMORY_ALLOCATION_ERROR;\n        return NULL;\n      }\n      // Older ICUs called uprv_decNumberToString here, which is not exactly the same as\n      // DecimalQuantity::toScientificString(). The biggest difference is that uprv_decNumberToString does\n      // not print scientific notation for magnitudes greater than -5 and smaller than some amount (+5?).\n      if (fDecimalQuantity->isZero()) {\n        fDecimalStr->append(\"0\", -1, status);\n      } else if (fDecimalQuantity->getMagnitude() != INT32_MIN && std::abs(fDecimalQuantity->getMagnitude()) < 5) {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toPlainString(), status);\n      } else {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toScientificString(), status);\n      }\n    }\n    return fDecimalStr;\n}\n\nvoid\nFormattable::populateDecimalQuantity(number::impl::DecimalQuantity& output, UErrorCode& status) const {\n    if (fDecimalQuantity != nullptr) {\n        output = *fDecimalQuantity;\n        return;\n    }\n\n    switch (fType) {\n        case kDouble:\n            output.setToDouble(this->getDouble());\n            output.roundToInfinity();\n            break;\n        case kLong:\n            output.setToInt(this->getLong());\n            break;\n        case kInt64:\n            output.setToLong(this->getInt64());\n            break;\n        default:\n            // The formattable's value is not a numeric type.\n            status = U_INVALID_STATE_ERROR;\n    }\n}\n\n// ---------------------------------------\nvoid\nFormattable::adoptDecimalQuantity(DecimalQuantity *dq) {\n    if (fDecimalQuantity != NULL) {\n        delete fDecimalQuantity;\n    }\n    fDecimalQuantity = dq;\n    if (dq == NULL) { // allow adoptDigitList(NULL) to clear\n        return;\n    }\n\n    // Set the value into the Union of simple type values.\n    // Cannot use the set() functions because they would delete the fDecimalNum value.\n    if (fDecimalQuantity->fitsInLong()) {\n        fValue.fInt64 = fDecimalQuantity->toLong();\n        if (fValue.fInt64 <= INT32_MAX && fValue.fInt64 >= INT32_MIN) {\n            fType = kLong;\n        } else {\n            fType = kInt64;\n        }\n    } else {\n        fType = kDouble;\n        fValue.fDouble = fDecimalQuantity->toDouble();\n    }\n}\n\n\n// ---------------------------------------\nvoid\nFormattable::setDecimalNumber(StringPiece numberString, UErrorCode &status) {\n    if (U_FAILURE(status)) {\n        return;\n    }\n    dispose();\n\n    auto* dq = new DecimalQuantity();\n    dq->setToDecNumber(numberString, status);\n    adoptDecimalQuantity(dq);\n\n    // Note that we do not hang on to the caller's input string.\n    // If we are asked for the string, we will regenerate one from fDecimalQuantity.\n}\n\n#if 0\n//----------------------------------------------------\n// console I/O\n//----------------------------------------------------\n#ifdef _DEBUG\n\n#include <iostream>\nusing namespace std;\n\n#include \"unicode/datefmt.h\"\n#include \"unistrm.h\"\n\nclass FormattableStreamer /* not : public UObject because all methods are static */ {\npublic:\n    static void streamOut(ostream& stream, const Formattable& obj);\n\nprivate:\n    FormattableStreamer() {} // private - forbid instantiation\n};\n\n// This is for debugging purposes only.  This will send a displayable\n// form of the Formattable object to the output stream.\n\nvoid\nFormattableStreamer::streamOut(ostream& stream, const Formattable& obj)\n{\n    static DateFormat *defDateFormat = 0;\n\n    UnicodeString buffer;\n    switch(obj.getType()) {\n        case Formattable::kDate : \n            // Creates a DateFormat instance for formatting the\n            // Date instance.\n            if (defDateFormat == 0) {\n                defDateFormat = DateFormat::createInstance();\n            }\n            defDateFormat->format(obj.getDate(), buffer);\n            stream << buffer;\n            break;\n        case Formattable::kDouble :\n            // Output the double as is.\n            stream << obj.getDouble() << 'D';\n            break;\n        case Formattable::kLong :\n            // Output the double as is.\n            stream << obj.getLong() << 'L';\n            break;\n        case Formattable::kString:\n            // Output the double as is.  Please see UnicodeString console\n            // I/O routine for more details.\n            stream << '\"' << obj.getString(buffer) << '\"';\n            break;\n        case Formattable::kArray:\n            int32_t i, count;\n            const Formattable* array;\n            array = obj.getArray(count);\n            stream << '[';\n            // Recursively calling the console I/O routine for each element in the array.\n            for (i=0; i<count; ++i) {\n                FormattableStreamer::streamOut(stream, array[i]);\n                stream << ( (i==(count-1)) ? \"\" : \", \" );\n            }\n            stream << ']';\n            break;\n        default:\n            // Not a recognizable Formattable object.\n            stream << \"INVALID_Formattable\";\n    }\n    stream.flush();\n}\n#endif\n\n#endif\n\nU_NAMESPACE_END\n\n/* ---- UFormattable implementation ---- */\n\nU_NAMESPACE_USE\n\nU_DRAFT UFormattable* U_EXPORT2\nufmt_open(UErrorCode *status) {\n  if( U_FAILURE(*status) ) {\n    return NULL;\n  }\n  UFormattable *fmt = (new Formattable())->toUFormattable();\n\n  if( fmt == NULL ) {\n    *status = U_MEMORY_ALLOCATION_ERROR;\n  }\n  return fmt;\n}\n\nU_DRAFT void U_EXPORT2\nufmt_close(UFormattable *fmt) {\n  Formattable *obj = Formattable::fromUFormattable(fmt);\n\n  delete obj;\n}\n\nU_INTERNAL UFormattableType U_EXPORT2\nufmt_getType(const UFormattable *fmt, UErrorCode *status) {\n  if(U_FAILURE(*status)) {\n    return (UFormattableType)UFMT_COUNT;\n  }\n  const Formattable *obj = Formattable::fromUFormattable(fmt);\n  return (UFormattableType)obj->getType();\n}\n\n\nU_INTERNAL UBool U_EXPORT2\nufmt_isNumeric(const UFormattable *fmt) {\n  const Formattable *obj = Formattable::fromUFormattable(fmt);\n  return obj->isNumeric();\n}\n\nU_DRAFT UDate U_EXPORT2\nufmt_getDate(const UFormattable *fmt, UErrorCode *status) {\n  const Formattable *obj = Formattable::fromUFormattable(fmt);\n\n  return obj->getDate(*status);\n}\n\nU_DRAFT double U_EXPORT2\nufmt_getDouble(UFormattable *fmt, UErrorCode *status) {\n  Formattable *obj = Formattable::fromUFormattable(fmt);\n\n  return obj->getDouble(*status);\n}\n\nU_DRAFT int32_t U_EXPORT2\nufmt_getLong(UFormattable *fmt, UErrorCode *status) {\n  Formattable *obj = Formattable::fromUFormattable(fmt);\n\n  return obj->getLong(*status);\n}\n\n\nU_DRAFT const void *U_EXPORT2\nufmt_getObject(const UFormattable *fmt, UErrorCode *status) {\n  const Formattable *obj = Formattable::fromUFormattable(fmt);\n\n  const void *ret = obj->getObject();\n  if( ret==NULL &&\n      (obj->getType() != Formattable::kObject) &&\n      U_SUCCESS( *status )) {\n    *status = U_INVALID_FORMAT_ERROR;\n  }\n  return ret;\n}\n\nU_DRAFT const UChar* U_EXPORT2\nufmt_getUChars(UFormattable *fmt, int32_t *len, UErrorCode *status) {\n  Formattable *obj = Formattable::fromUFormattable(fmt);\n\n  // avoid bogosity by checking the type first.\n  if( obj->getType() != Formattable::kString ) {\n    if( U_SUCCESS(*status) ){\n      *status = U_INVALID_FORMAT_ERROR;\n    }\n    return NULL;\n  }\n\n  // This should return a valid string\n  UnicodeString &str = obj->getString(*status);\n  if( U_SUCCESS(*status) && len != NULL ) {\n    *len = str.length();\n  }\n  return str.getTerminatedBuffer();\n}\n\nU_DRAFT int32_t U_EXPORT2\nufmt_getArrayLength(const UFormattable* fmt, UErrorCode *status) {\n  const Formattable *obj = Formattable::fromUFormattable(fmt);\n\n  int32_t count;\n  (void)obj->getArray(count, *status);\n  return count;\n}\n\nU_DRAFT UFormattable * U_EXPORT2\nufmt_getArrayItemByIndex(UFormattable* fmt, int32_t n, UErrorCode *status) {\n  Formattable *obj = Formattable::fromUFormattable(fmt);\n  int32_t count;\n  (void)obj->getArray(count, *status);\n  if(U_FAILURE(*status)) {\n    return NULL;\n  } else if(n<0 || n>=count) {\n    setError(*status, U_INDEX_OUTOFBOUNDS_ERROR);\n    return NULL;\n  } else {\n    return (*obj)[n].toUFormattable(); // returns non-const Formattable\n  }\n}\n\nU_DRAFT const char * U_EXPORT2\nufmt_getDecNumChars(UFormattable *fmt, int32_t *len, UErrorCode *status) {\n  if(U_FAILURE(*status)) {\n    return \"\";\n  }\n  Formattable *obj = Formattable::fromUFormattable(fmt);\n  CharString *charString = obj->internalGetCharString(*status);\n  if(U_FAILURE(*status)) {\n    return \"\";\n  }\n  if(charString == NULL) {\n    *status = U_MEMORY_ALLOCATION_ERROR;\n    return \"\";\n  } else {\n    if(len!=NULL) {\n      *len = charString->length();\n    }\n    return charString->data();\n  }\n}\n\nU_DRAFT int64_t U_EXPORT2\nufmt_getInt64(UFormattable *fmt, UErrorCode *status) {\n  Formattable *obj = Formattable::fromUFormattable(fmt);\n  return obj->getInt64(*status);\n}\n\n#endif /* #if !UCONFIG_NO_FORMATTING */\n\n//eof\n", "// \u00a9 2017 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html\n\n#include \"unicode/utypes.h\"\n\n#if !UCONFIG_NO_FORMATTING\n\n#include <cstdlib>\n#include <cmath>\n#include <limits>\n#include <stdlib.h>\n\n#include \"unicode/plurrule.h\"\n#include \"cmemory.h\"\n#include \"number_decnum.h\"\n#include \"putilimp.h\"\n#include \"number_decimalquantity.h\"\n#include \"number_roundingutils.h\"\n#include \"double-conversion.h\"\n#include \"charstr.h\"\n#include \"number_utils.h\"\n#include \"uassert.h\"\n\nusing namespace icu;\nusing namespace icu::number;\nusing namespace icu::number::impl;\n\nusing icu::double_conversion::DoubleToStringConverter;\nusing icu::double_conversion::StringToDoubleConverter;\n\nnamespace {\n\nint8_t NEGATIVE_FLAG = 1;\nint8_t INFINITY_FLAG = 2;\nint8_t NAN_FLAG = 4;\n\n/** Helper function for safe subtraction (no overflow). */\ninline int32_t safeSubtract(int32_t a, int32_t b) {\n    // Note: In C++, signed integer subtraction is undefined behavior.\n    int32_t diff = static_cast<int32_t>(static_cast<uint32_t>(a) - static_cast<uint32_t>(b));\n    if (b < 0 && diff < a) { return INT32_MAX; }\n    if (b > 0 && diff > a) { return INT32_MIN; }\n    return diff;\n}\n\nstatic double DOUBLE_MULTIPLIERS[] = {\n        1e0,\n        1e1,\n        1e2,\n        1e3,\n        1e4,\n        1e5,\n        1e6,\n        1e7,\n        1e8,\n        1e9,\n        1e10,\n        1e11,\n        1e12,\n        1e13,\n        1e14,\n        1e15,\n        1e16,\n        1e17,\n        1e18,\n        1e19,\n        1e20,\n        1e21};\n\n}  // namespace\n\nicu::IFixedDecimal::~IFixedDecimal() = default;\n\nDecimalQuantity::DecimalQuantity() {\n    setBcdToZero();\n    flags = 0;\n}\n\nDecimalQuantity::~DecimalQuantity() {\n    if (usingBytes) {\n        uprv_free(fBCD.bcdBytes.ptr);\n        fBCD.bcdBytes.ptr = nullptr;\n        usingBytes = false;\n    }\n}\n\nDecimalQuantity::DecimalQuantity(const DecimalQuantity &other) {\n    *this = other;\n}\n\nDecimalQuantity::DecimalQuantity(DecimalQuantity&& src) U_NOEXCEPT {\n    *this = std::move(src);\n}\n\nDecimalQuantity &DecimalQuantity::operator=(const DecimalQuantity &other) {\n    if (this == &other) {\n        return *this;\n    }\n    copyBcdFrom(other);\n    copyFieldsFrom(other);\n    return *this;\n}\n\nDecimalQuantity& DecimalQuantity::operator=(DecimalQuantity&& src) U_NOEXCEPT {\n    if (this == &src) {\n        return *this;\n    }\n    moveBcdFrom(src);\n    copyFieldsFrom(src);\n    return *this;\n}\n\nvoid DecimalQuantity::copyFieldsFrom(const DecimalQuantity& other) {\n    bogus = other.bogus;\n    lOptPos = other.lOptPos;\n    lReqPos = other.lReqPos;\n    rReqPos = other.rReqPos;\n    rOptPos = other.rOptPos;\n    scale = other.scale;\n    precision = other.precision;\n    flags = other.flags;\n    origDouble = other.origDouble;\n    origDelta = other.origDelta;\n    isApproximate = other.isApproximate;\n}\n\nvoid DecimalQuantity::clear() {\n    lOptPos = INT32_MAX;\n    lReqPos = 0;\n    rReqPos = 0;\n    rOptPos = INT32_MIN;\n    flags = 0;\n    setBcdToZero(); // sets scale, precision, hasDouble, origDouble, origDelta, and BCD data\n}\n\nvoid DecimalQuantity::setIntegerLength(int32_t minInt, int32_t maxInt) {\n    // Validation should happen outside of DecimalQuantity, e.g., in the Precision class.\n    U_ASSERT(minInt >= 0);\n    U_ASSERT(maxInt >= minInt);\n\n    // Special behavior: do not set minInt to be less than what is already set.\n    // This is so significant digits rounding can set the integer length.\n    if (minInt < lReqPos) {\n        minInt = lReqPos;\n    }\n\n    // Save values into internal state\n    // Negation is safe for minFrac/maxFrac because -Integer.MAX_VALUE > Integer.MIN_VALUE\n    lOptPos = maxInt;\n    lReqPos = minInt;\n}\n\nvoid DecimalQuantity::setFractionLength(int32_t minFrac, int32_t maxFrac) {\n    // Validation should happen outside of DecimalQuantity, e.g., in the Precision class.\n    U_ASSERT(minFrac >= 0);\n    U_ASSERT(maxFrac >= minFrac);\n\n    // Save values into internal state\n    // Negation is safe for minFrac/maxFrac because -Integer.MAX_VALUE > Integer.MIN_VALUE\n    rReqPos = -minFrac;\n    rOptPos = -maxFrac;\n}\n\nuint64_t DecimalQuantity::getPositionFingerprint() const {\n    uint64_t fingerprint = 0;\n    fingerprint ^= lOptPos;\n    fingerprint ^= (lReqPos << 16);\n    fingerprint ^= (static_cast<uint64_t>(rReqPos) << 32);\n    fingerprint ^= (static_cast<uint64_t>(rOptPos) << 48);\n    return fingerprint;\n}\n\nvoid DecimalQuantity::roundToIncrement(double roundingIncrement, RoundingMode roundingMode,\n                                       int32_t maxFrac, UErrorCode& status) {\n    // TODO(13701): Move the nickel check into a higher-level API.\n    if (roundingIncrement == 0.05) {\n        roundToMagnitude(-2, roundingMode, true, status);\n        roundToMagnitude(-maxFrac, roundingMode, false, status);\n        return;\n    } else if (roundingIncrement == 0.5) {\n        roundToMagnitude(-1, roundingMode, true, status);\n        roundToMagnitude(-maxFrac, roundingMode, false, status);\n        return;\n    }\n    // TODO(13701): This is innefficient.  Improve?\n    // TODO(13701): Should we convert to decNumber instead?\n    roundToInfinity();\n    double temp = toDouble();\n    temp /= roundingIncrement;\n    // Use another DecimalQuantity to perform the actual rounding...\n    DecimalQuantity dq;\n    dq.setToDouble(temp);\n    dq.roundToMagnitude(0, roundingMode, status);\n    temp = dq.toDouble();\n    temp *= roundingIncrement;\n    setToDouble(temp);\n    // Since we reset the value to a double, we need to specify the rounding boundary\n    // in order to get the DecimalQuantity out of approximation mode.\n    // NOTE: In Java, we have minMaxFrac, but in C++, the two are differentiated.\n    roundToMagnitude(-maxFrac, roundingMode, status);\n}\n\nvoid DecimalQuantity::multiplyBy(const DecNum& multiplicand, UErrorCode& status) {\n    if (isInfinite() || isZero() || isNaN()) {\n        return;\n    }\n    // Convert to DecNum, multiply, and convert back.\n    DecNum decnum;\n    toDecNum(decnum, status);\n    if (U_FAILURE(status)) { return; }\n    decnum.multiplyBy(multiplicand, status);\n    if (U_FAILURE(status)) { return; }\n    setToDecNum(decnum, status);\n}\n\nvoid DecimalQuantity::divideBy(const DecNum& divisor, UErrorCode& status) {\n    if (isInfinite() || isZero() || isNaN()) {\n        return;\n    }\n    // Convert to DecNum, multiply, and convert back.\n    DecNum decnum;\n    toDecNum(decnum, status);\n    if (U_FAILURE(status)) { return; }\n    decnum.divideBy(divisor, status);\n    if (U_FAILURE(status)) { return; }\n    setToDecNum(decnum, status);\n}\n\nvoid DecimalQuantity::negate() {\n    flags ^= NEGATIVE_FLAG;\n}\n\nint32_t DecimalQuantity::getMagnitude() const {\n    U_ASSERT(precision != 0);\n    return scale + precision - 1;\n}\n\nbool DecimalQuantity::adjustMagnitude(int32_t delta) {\n    if (precision != 0) {\n        // i.e., scale += delta; origDelta += delta\n        bool overflow = uprv_add32_overflow(scale, delta, &scale);\n        overflow = uprv_add32_overflow(origDelta, delta, &origDelta) || overflow;\n        // Make sure that precision + scale won't overflow, either\n        int32_t dummy;\n        overflow = overflow || uprv_add32_overflow(scale, precision, &dummy);\n        return overflow;\n    }\n    return false;\n}\n\ndouble DecimalQuantity::getPluralOperand(PluralOperand operand) const {\n    // If this assertion fails, you need to call roundToInfinity() or some other rounding method.\n    // See the comment at the top of this file explaining the \"isApproximate\" field.\n    U_ASSERT(!isApproximate);\n\n    switch (operand) {\n        case PLURAL_OPERAND_I:\n            // Invert the negative sign if necessary\n            return static_cast<double>(isNegative() ? -toLong(true) : toLong(true));\n        case PLURAL_OPERAND_F:\n            return static_cast<double>(toFractionLong(true));\n        case PLURAL_OPERAND_T:\n            return static_cast<double>(toFractionLong(false));\n        case PLURAL_OPERAND_V:\n            return fractionCount();\n        case PLURAL_OPERAND_W:\n            return fractionCountWithoutTrailingZeros();\n        default:\n            return std::abs(toDouble());\n    }\n}\n\nbool DecimalQuantity::hasIntegerValue() const {\n    return scale >= 0;\n}\n\nint32_t DecimalQuantity::getUpperDisplayMagnitude() const {\n    // If this assertion fails, you need to call roundToInfinity() or some other rounding method.\n    // See the comment in the header file explaining the \"isApproximate\" field.\n    U_ASSERT(!isApproximate);\n\n    int32_t magnitude = scale + precision;\n    int32_t result = (lReqPos > magnitude) ? lReqPos : (lOptPos < magnitude) ? lOptPos : magnitude;\n    return result - 1;\n}\n\nint32_t DecimalQuantity::getLowerDisplayMagnitude() const {\n    // If this assertion fails, you need to call roundToInfinity() or some other rounding method.\n    // See the comment in the header file explaining the \"isApproximate\" field.\n    U_ASSERT(!isApproximate);\n\n    int32_t magnitude = scale;\n    int32_t result = (rReqPos < magnitude) ? rReqPos : (rOptPos > magnitude) ? rOptPos : magnitude;\n    return result;\n}\n\nint8_t DecimalQuantity::getDigit(int32_t magnitude) const {\n    // If this assertion fails, you need to call roundToInfinity() or some other rounding method.\n    // See the comment at the top of this file explaining the \"isApproximate\" field.\n    U_ASSERT(!isApproximate);\n\n    return getDigitPos(magnitude - scale);\n}\n\nint32_t DecimalQuantity::fractionCount() const {\n    return -getLowerDisplayMagnitude();\n}\n\nint32_t DecimalQuantity::fractionCountWithoutTrailingZeros() const {\n    return -scale > 0 ? -scale : 0;  // max(-scale, 0)\n}\n\nbool DecimalQuantity::isNegative() const {\n    return (flags & NEGATIVE_FLAG) != 0;\n}\n\nint8_t DecimalQuantity::signum() const {\n    return isNegative() ? -1 : isZero() ? 0 : 1;\n}\n\nbool DecimalQuantity::isInfinite() const {\n    return (flags & INFINITY_FLAG) != 0;\n}\n\nbool DecimalQuantity::isNaN() const {\n    return (flags & NAN_FLAG) != 0;\n}\n\nbool DecimalQuantity::isZero() const {\n    return precision == 0;\n}\n\nDecimalQuantity &DecimalQuantity::setToInt(int32_t n) {\n    setBcdToZero();\n    flags = 0;\n    if (n == INT32_MIN) {\n        flags |= NEGATIVE_FLAG;\n        // leave as INT32_MIN; handled below in _setToInt()\n    } else if (n < 0) {\n        flags |= NEGATIVE_FLAG;\n        n = -n;\n    }\n    if (n != 0) {\n        _setToInt(n);\n        compact();\n    }\n    return *this;\n}\n\nvoid DecimalQuantity::_setToInt(int32_t n) {\n    if (n == INT32_MIN) {\n        readLongToBcd(-static_cast<int64_t>(n));\n    } else {\n        readIntToBcd(n);\n    }\n}\n\nDecimalQuantity &DecimalQuantity::setToLong(int64_t n) {\n    setBcdToZero();\n    flags = 0;\n    if (n < 0 && n > INT64_MIN) {\n        flags |= NEGATIVE_FLAG;\n        n = -n;\n    }\n    if (n != 0) {\n        _setToLong(n);\n        compact();\n    }\n    return *this;\n}\n\nvoid DecimalQuantity::_setToLong(int64_t n) {\n    if (n == INT64_MIN) {\n        DecNum decnum;\n        UErrorCode localStatus = U_ZERO_ERROR;\n        decnum.setTo(\"9.223372036854775808E+18\", localStatus);\n        if (U_FAILURE(localStatus)) { return; } // unexpected\n        flags |= NEGATIVE_FLAG;\n        readDecNumberToBcd(decnum);\n    } else if (n <= INT32_MAX) {\n        readIntToBcd(static_cast<int32_t>(n));\n    } else {\n        readLongToBcd(n);\n    }\n}\n\nDecimalQuantity &DecimalQuantity::setToDouble(double n) {\n    setBcdToZero();\n    flags = 0;\n    // signbit() from <math.h> handles +0.0 vs -0.0\n    if (std::signbit(n)) {\n        flags |= NEGATIVE_FLAG;\n        n = -n;\n    }\n    if (std::isnan(n) != 0) {\n        flags |= NAN_FLAG;\n    } else if (std::isfinite(n) == 0) {\n        flags |= INFINITY_FLAG;\n    } else if (n != 0) {\n        _setToDoubleFast(n);\n        compact();\n    }\n    return *this;\n}\n\nvoid DecimalQuantity::_setToDoubleFast(double n) {\n    isApproximate = true;\n    origDouble = n;\n    origDelta = 0;\n\n    // Make sure the double is an IEEE 754 double.  If not, fall back to the slow path right now.\n    // TODO: Make a fast path for other types of doubles.\n    if (!std::numeric_limits<double>::is_iec559) {\n        convertToAccurateDouble();\n        // Turn off the approximate double flag, since the value is now exact.\n        isApproximate = false;\n        origDouble = 0.0;\n        return;\n    }\n\n    // To get the bits from the double, use memcpy, which takes care of endianness.\n    uint64_t ieeeBits;\n    uprv_memcpy(&ieeeBits, &n, sizeof(n));\n    int32_t exponent = static_cast<int32_t>((ieeeBits & 0x7ff0000000000000L) >> 52) - 0x3ff;\n\n    // Not all integers can be represented exactly for exponent > 52\n    if (exponent <= 52 && static_cast<int64_t>(n) == n) {\n        _setToLong(static_cast<int64_t>(n));\n        return;\n    }\n\n    // 3.3219... is log2(10)\n    auto fracLength = static_cast<int32_t> ((52 - exponent) / 3.32192809489);\n    if (fracLength >= 0) {\n        int32_t i = fracLength;\n        // 1e22 is the largest exact double.\n        for (; i >= 22; i -= 22) n *= 1e22;\n        n *= DOUBLE_MULTIPLIERS[i];\n    } else {\n        int32_t i = fracLength;\n        // 1e22 is the largest exact double.\n        for (; i <= -22; i += 22) n /= 1e22;\n        n /= DOUBLE_MULTIPLIERS[-i];\n    }\n    auto result = static_cast<int64_t>(std::round(n));\n    if (result != 0) {\n        _setToLong(result);\n        scale -= fracLength;\n    }\n}\n\nvoid DecimalQuantity::convertToAccurateDouble() {\n    U_ASSERT(origDouble != 0);\n    int32_t delta = origDelta;\n\n    // Call the slow oracle function (Double.toString in Java, DoubleToAscii in C++).\n    char buffer[DoubleToStringConverter::kBase10MaximalLength + 1];\n    bool sign; // unused; always positive\n    int32_t length;\n    int32_t point;\n    DoubleToStringConverter::DoubleToAscii(\n        origDouble,\n        DoubleToStringConverter::DtoaMode::SHORTEST,\n        0,\n        buffer,\n        sizeof(buffer),\n        &sign,\n        &length,\n        &point\n    );\n\n    setBcdToZero();\n    readDoubleConversionToBcd(buffer, length, point);\n    scale += delta;\n    explicitExactDouble = true;\n}\n\nDecimalQuantity &DecimalQuantity::setToDecNumber(StringPiece n, UErrorCode& status) {\n    setBcdToZero();\n    flags = 0;\n\n    // Compute the decNumber representation\n    DecNum decnum;\n    decnum.setTo(n, status);\n\n    _setToDecNum(decnum, status);\n    return *this;\n}\n\nDecimalQuantity& DecimalQuantity::setToDecNum(const DecNum& decnum, UErrorCode& status) {\n    setBcdToZero();\n    flags = 0;\n\n    _setToDecNum(decnum, status);\n    return *this;\n}\n\nvoid DecimalQuantity::_setToDecNum(const DecNum& decnum, UErrorCode& status) {\n    if (U_FAILURE(status)) { return; }\n    if (decnum.isNegative()) {\n        flags |= NEGATIVE_FLAG;\n    }\n    if (!decnum.isZero()) {\n        readDecNumberToBcd(decnum);\n        compact();\n    }\n}\n\nint64_t DecimalQuantity::toLong(bool truncateIfOverflow) const {\n    // NOTE: Call sites should be guarded by fitsInLong(), like this:\n    // if (dq.fitsInLong()) { /* use dq.toLong() */ } else { /* use some fallback */ }\n    // Fallback behavior upon truncateIfOverflow is to truncate at 17 digits.\n    uint64_t result = 0L;\n    int32_t upperMagnitude = std::min(scale + precision, lOptPos) - 1;\n    if (truncateIfOverflow) {\n        upperMagnitude = std::min(upperMagnitude, 17);\n    }\n    for (int32_t magnitude = upperMagnitude; magnitude >= 0; magnitude--) {\n        result = result * 10 + getDigitPos(magnitude - scale);\n    }\n    if (isNegative()) {\n        return static_cast<int64_t>(0LL - result); // i.e., -result\n    }\n    return static_cast<int64_t>(result);\n}\n\nuint64_t DecimalQuantity::toFractionLong(bool includeTrailingZeros) const {\n    uint64_t result = 0L;\n    int32_t magnitude = -1;\n    int32_t lowerMagnitude = std::max(scale, rOptPos);\n    if (includeTrailingZeros) {\n        lowerMagnitude = std::min(lowerMagnitude, rReqPos);\n    }\n    for (; magnitude >= lowerMagnitude && result <= 1e18L; magnitude--) {\n        result = result * 10 + getDigitPos(magnitude - scale);\n    }\n    // Remove trailing zeros; this can happen during integer overflow cases.\n    if (!includeTrailingZeros) {\n        while (result > 0 && (result % 10) == 0) {\n            result /= 10;\n        }\n    }\n    return result;\n}\n\nbool DecimalQuantity::fitsInLong(bool ignoreFraction) const {\n    if (isZero()) {\n        return true;\n    }\n    if (scale < 0 && !ignoreFraction) {\n        return false;\n    }\n    int magnitude = getMagnitude();\n    if (magnitude < 18) {\n        return true;\n    }\n    if (magnitude > 18) {\n        return false;\n    }\n    // Hard case: the magnitude is 10^18.\n    // The largest int64 is: 9,223,372,036,854,775,807\n    for (int p = 0; p < precision; p++) {\n        int8_t digit = getDigit(18 - p);\n        static int8_t INT64_BCD[] = { 9, 2, 2, 3, 3, 7, 2, 0, 3, 6, 8, 5, 4, 7, 7, 5, 8, 0, 8 };\n        if (digit < INT64_BCD[p]) {\n            return true;\n        } else if (digit > INT64_BCD[p]) {\n            return false;\n        }\n    }\n    // Exactly equal to max long plus one.\n    return isNegative();\n}\n\ndouble DecimalQuantity::toDouble() const {\n    // If this assertion fails, you need to call roundToInfinity() or some other rounding method.\n    // See the comment in the header file explaining the \"isApproximate\" field.\n    U_ASSERT(!isApproximate);\n\n    if (isNaN()) {\n        return NAN;\n    } else if (isInfinite()) {\n        return isNegative() ? -INFINITY : INFINITY;\n    }\n\n    // We are processing well-formed input, so we don't need any special options to StringToDoubleConverter.\n    StringToDoubleConverter converter(0, 0, 0, \"\", \"\");\n    UnicodeString numberString = this->toScientificString();\n    int32_t count;\n    return converter.StringToDouble(\n            reinterpret_cast<const uint16_t*>(numberString.getBuffer()),\n            numberString.length(),\n            &count);\n}\n\nvoid DecimalQuantity::toDecNum(DecNum& output, UErrorCode& status) const {\n    // Special handling for zero\n    if (precision == 0) {\n        output.setTo(\"0\", status);\n    }\n\n    // Use the BCD constructor. We need to do a little bit of work to convert, though.\n    // The decNumber constructor expects most-significant first, but we store least-significant first.\n    MaybeStackArray<uint8_t, 20> ubcd(precision);\n    for (int32_t m = 0; m < precision; m++) {\n        ubcd[precision - m - 1] = static_cast<uint8_t>(getDigitPos(m));\n    }\n    output.setTo(ubcd.getAlias(), precision, scale, isNegative(), status);\n}\n\nvoid DecimalQuantity::truncate() {\n    if (scale < 0) {\n        shiftRight(-scale);\n        scale = 0;\n        compact();\n    }\n}\n\nvoid DecimalQuantity::roundToNickel(int32_t magnitude, RoundingMode roundingMode, UErrorCode& status) {\n    roundToMagnitude(magnitude, roundingMode, true, status);\n}\n\nvoid DecimalQuantity::roundToMagnitude(int32_t magnitude, RoundingMode roundingMode, UErrorCode& status) {\n    roundToMagnitude(magnitude, roundingMode, false, status);\n}\n\nvoid DecimalQuantity::roundToMagnitude(int32_t magnitude, RoundingMode roundingMode, bool nickel, UErrorCode& status) {\n    // The position in the BCD at which rounding will be performed; digits to the right of position\n    // will be rounded away.\n    int position = safeSubtract(magnitude, scale);\n\n    // \"trailing\" = least significant digit to the left of rounding\n    int8_t trailingDigit = getDigitPos(position);\n\n    if (position <= 0 && !isApproximate && (!nickel || trailingDigit == 0 || trailingDigit == 5)) {\n        // All digits are to the left of the rounding magnitude.\n    } else if (precision == 0) {\n        // No rounding for zero.\n    } else {\n        // Perform rounding logic.\n        // \"leading\" = most significant digit to the right of rounding\n        int8_t leadingDigit = getDigitPos(safeSubtract(position, 1));\n\n        // Compute which section of the number we are in.\n        // EDGE means we are at the bottom or top edge, like 1.000 or 1.999 (used by doubles)\n        // LOWER means we are between the bottom edge and the midpoint, like 1.391\n        // MIDPOINT means we are exactly in the middle, like 1.500\n        // UPPER means we are between the midpoint and the top edge, like 1.916\n        roundingutils::Section section;\n        if (!isApproximate) {\n            if (nickel && trailingDigit != 2 && trailingDigit != 7) {\n                // Nickel rounding, and not at .02x or .07x\n                if (trailingDigit < 2) {\n                    // .00, .01 => down to .00\n                    section = roundingutils::SECTION_LOWER;\n                } else if (trailingDigit < 5) {\n                    // .03, .04 => up to .05\n                    section = roundingutils::SECTION_UPPER;\n                } else if (trailingDigit < 7) {\n                    // .05, .06 => down to .05\n                    section = roundingutils::SECTION_LOWER;\n                } else {\n                    // .08, .09 => up to .10\n                    section = roundingutils::SECTION_UPPER;\n                }\n            } else if (leadingDigit < 5) {\n                // Includes nickel rounding .020-.024 and .070-.074\n                section = roundingutils::SECTION_LOWER;\n            } else if (leadingDigit > 5) {\n                // Includes nickel rounding .026-.029 and .076-.079\n                section = roundingutils::SECTION_UPPER;\n            } else {\n                // Includes nickel rounding .025 and .075\n                section = roundingutils::SECTION_MIDPOINT;\n                for (int p = safeSubtract(position, 2); p >= 0; p--) {\n                    if (getDigitPos(p) != 0) {\n                        section = roundingutils::SECTION_UPPER;\n                        break;\n                    }\n                }\n            }\n        } else {\n            int32_t p = safeSubtract(position, 2);\n            int32_t minP = uprv_max(0, precision - 14);\n            if (leadingDigit == 0 && (!nickel || trailingDigit == 0 || trailingDigit == 5)) {\n                section = roundingutils::SECTION_LOWER_EDGE;\n                for (; p >= minP; p--) {\n                    if (getDigitPos(p) != 0) {\n                        section = roundingutils::SECTION_LOWER;\n                        break;\n                    }\n                }\n            } else if (leadingDigit == 4 && (!nickel || trailingDigit == 2 || trailingDigit == 7)) {\n                section = roundingutils::SECTION_MIDPOINT;\n                for (; p >= minP; p--) {\n                    if (getDigitPos(p) != 9) {\n                        section = roundingutils::SECTION_LOWER;\n                        break;\n                    }\n                }\n            } else if (leadingDigit == 5 && (!nickel || trailingDigit == 2 || trailingDigit == 7)) {\n                section = roundingutils::SECTION_MIDPOINT;\n                for (; p >= minP; p--) {\n                    if (getDigitPos(p) != 0) {\n                        section = roundingutils::SECTION_UPPER;\n                        break;\n                    }\n                }\n            } else if (leadingDigit == 9 && (!nickel || trailingDigit == 4 || trailingDigit == 9)) {\n                section = roundingutils::SECTION_UPPER_EDGE;\n                for (; p >= minP; p--) {\n                    if (getDigitPos(p) != 9) {\n                        section = roundingutils::SECTION_UPPER;\n                        break;\n                    }\n                }\n            } else if (nickel && trailingDigit != 2 && trailingDigit != 7) {\n                // Nickel rounding, and not at .02x or .07x\n                if (trailingDigit < 2) {\n                    // .00, .01 => down to .00\n                    section = roundingutils::SECTION_LOWER;\n                } else if (trailingDigit < 5) {\n                    // .03, .04 => up to .05\n                    section = roundingutils::SECTION_UPPER;\n                } else if (trailingDigit < 7) {\n                    // .05, .06 => down to .05\n                    section = roundingutils::SECTION_LOWER;\n                } else {\n                    // .08, .09 => up to .10\n                    section = roundingutils::SECTION_UPPER;\n                }\n            } else if (leadingDigit < 5) {\n                // Includes nickel rounding .020-.024 and .070-.074\n                section = roundingutils::SECTION_LOWER;\n            } else {\n                // Includes nickel rounding .026-.029 and .076-.079\n                section = roundingutils::SECTION_UPPER;\n            }\n\n            bool roundsAtMidpoint = roundingutils::roundsAtMidpoint(roundingMode);\n            if (safeSubtract(position, 1) < precision - 14 ||\n                (roundsAtMidpoint && section == roundingutils::SECTION_MIDPOINT) ||\n                (!roundsAtMidpoint && section < 0 /* i.e. at upper or lower edge */)) {\n                // Oops! This means that we have to get the exact representation of the double,\n                // because the zone of uncertainty is along the rounding boundary.\n                convertToAccurateDouble();\n                roundToMagnitude(magnitude, roundingMode, nickel, status); // start over\n                return;\n            }\n\n            // Turn off the approximate double flag, since the value is now confirmed to be exact.\n            isApproximate = false;\n            origDouble = 0.0;\n            origDelta = 0;\n\n            if (position <= 0 && (!nickel || trailingDigit == 0 || trailingDigit == 5)) {\n                // All digits are to the left of the rounding magnitude.\n                return;\n            }\n\n            // Good to continue rounding.\n            if (section == -1) { section = roundingutils::SECTION_LOWER; }\n            if (section == -2) { section = roundingutils::SECTION_UPPER; }\n        }\n\n        // Nickel rounding \"half even\" goes to the nearest whole (away from the 5).\n        bool isEven = nickel\n                ? (trailingDigit < 2 || trailingDigit > 7\n                        || (trailingDigit == 2 && section != roundingutils::SECTION_UPPER)\n                        || (trailingDigit == 7 && section == roundingutils::SECTION_UPPER))\n                : (trailingDigit % 2) == 0;\n\n        bool roundDown = roundingutils::getRoundingDirection(isEven,\n                isNegative(),\n                section,\n                roundingMode,\n                status);\n        if (U_FAILURE(status)) {\n            return;\n        }\n\n        // Perform truncation\n        if (position >= precision) {\n            setBcdToZero();\n            scale = magnitude;\n        } else {\n            shiftRight(position);\n        }\n\n        if (nickel) {\n            if (trailingDigit < 5 && roundDown) {\n                setDigitPos(0, 0);\n                compact();\n                return;\n            } else if (trailingDigit >= 5 && !roundDown) {\n                setDigitPos(0, 9);\n                trailingDigit = 9;\n                // do not return: use the bubbling logic below\n            } else {\n                setDigitPos(0, 5);\n                // compact not necessary: digit at position 0 is nonzero\n                return;\n            }\n        }\n\n        // Bubble the result to the higher digits\n        if (!roundDown) {\n            if (trailingDigit == 9) {\n                int bubblePos = 0;\n                // Note: in the long implementation, the most digits BCD can have at this point is\n                // 15, so bubblePos <= 15 and getDigitPos(bubblePos) is safe.\n                for (; getDigitPos(bubblePos) == 9; bubblePos++) {}\n                shiftRight(bubblePos); // shift off the trailing 9s\n            }\n            int8_t digit0 = getDigitPos(0);\n            U_ASSERT(digit0 != 9);\n            setDigitPos(0, static_cast<int8_t>(digit0 + 1));\n            precision += 1; // in case an extra digit got added\n        }\n\n        compact();\n    }\n}\n\nvoid DecimalQuantity::roundToInfinity() {\n    if (isApproximate) {\n        convertToAccurateDouble();\n    }\n}\n\nvoid DecimalQuantity::appendDigit(int8_t value, int32_t leadingZeros, bool appendAsInteger) {\n    U_ASSERT(leadingZeros >= 0);\n\n    // Zero requires special handling to maintain the invariant that the least-significant digit\n    // in the BCD is nonzero.\n    if (value == 0) {\n        if (appendAsInteger && precision != 0) {\n            scale += leadingZeros + 1;\n        }\n        return;\n    }\n\n    // Deal with trailing zeros\n    if (scale > 0) {\n        leadingZeros += scale;\n        if (appendAsInteger) {\n            scale = 0;\n        }\n    }\n\n    // Append digit\n    shiftLeft(leadingZeros + 1);\n    setDigitPos(0, value);\n\n    // Fix scale if in integer mode\n    if (appendAsInteger) {\n        scale += leadingZeros + 1;\n    }\n}\n\nUnicodeString DecimalQuantity::toPlainString() const {\n    U_ASSERT(!isApproximate);\n    UnicodeString sb;\n    if (isNegative()) {\n        sb.append(u'-');\n    }\n    if (precision == 0 || getMagnitude() < 0) {\n        sb.append(u'0');\n    }\n    for (int m = getUpperDisplayMagnitude(); m >= getLowerDisplayMagnitude(); m--) {\n        if (m == -1) { sb.append(u'.'); }\n        sb.append(getDigit(m) + u'0');\n    }\n    return sb;\n}\n\nUnicodeString DecimalQuantity::toScientificString() const {\n    U_ASSERT(!isApproximate);\n    UnicodeString result;\n    if (isNegative()) {\n        result.append(u'-');\n    }\n    if (precision == 0) {\n        result.append(u\"0E+0\", -1);\n        return result;\n    }\n    // NOTE: It is not safe to add to lOptPos (aka maxInt) or subtract from\n    // rOptPos (aka -maxFrac) due to overflow.\n    int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;\n    int32_t lowerPos = std::max(scale, rOptPos) - scale;\n    int32_t p = upperPos;\n    result.append(u'0' + getDigitPos(p));\n    if ((--p) >= lowerPos) {\n        result.append(u'.');\n        for (; p >= lowerPos; p--) {\n            result.append(u'0' + getDigitPos(p));\n        }\n    }\n    result.append(u'E');\n    int32_t _scale = upperPos + scale;\n    if (_scale == INT32_MIN) {\n        result.append({u\"-2147483648\", -1});\n        return result;\n    } else if (_scale < 0) {\n        _scale *= -1;\n        result.append(u'-');\n    } else {\n        result.append(u'+');\n    }\n    if (_scale == 0) {\n        result.append(u'0');\n    }\n    int32_t insertIndex = result.length();\n    while (_scale > 0) {\n        std::div_t res = std::div(_scale, 10);\n        result.insert(insertIndex, u'0' + res.rem);\n        _scale = res.quot;\n    }\n    return result;\n}\n\n////////////////////////////////////////////////////\n/// End of DecimalQuantity_AbstractBCD.java      ///\n/// Start of DecimalQuantity_DualStorageBCD.java ///\n////////////////////////////////////////////////////\n\nint8_t DecimalQuantity::getDigitPos(int32_t position) const {\n    if (usingBytes) {\n        if (position < 0 || position >= precision) { return 0; }\n        return fBCD.bcdBytes.ptr[position];\n    } else {\n        if (position < 0 || position >= 16) { return 0; }\n        return (int8_t) ((fBCD.bcdLong >> (position * 4)) & 0xf);\n    }\n}\n\nvoid DecimalQuantity::setDigitPos(int32_t position, int8_t value) {\n    U_ASSERT(position >= 0);\n    if (usingBytes) {\n        ensureCapacity(position + 1);\n        fBCD.bcdBytes.ptr[position] = value;\n    } else if (position >= 16) {\n        switchStorage();\n        ensureCapacity(position + 1);\n        fBCD.bcdBytes.ptr[position] = value;\n    } else {\n        int shift = position * 4;\n        fBCD.bcdLong = (fBCD.bcdLong & ~(0xfL << shift)) | ((long) value << shift);\n    }\n}\n\nvoid DecimalQuantity::shiftLeft(int32_t numDigits) {\n    if (!usingBytes && precision + numDigits > 16) {\n        switchStorage();\n    }\n    if (usingBytes) {\n        ensureCapacity(precision + numDigits);\n        int i = precision + numDigits - 1;\n        for (; i >= numDigits; i--) {\n            fBCD.bcdBytes.ptr[i] = fBCD.bcdBytes.ptr[i - numDigits];\n        }\n        for (; i >= 0; i--) {\n            fBCD.bcdBytes.ptr[i] = 0;\n        }\n    } else {\n        fBCD.bcdLong <<= (numDigits * 4);\n    }\n    scale -= numDigits;\n    precision += numDigits;\n}\n\nvoid DecimalQuantity::shiftRight(int32_t numDigits) {\n    if (usingBytes) {\n        int i = 0;\n        for (; i < precision - numDigits; i++) {\n            fBCD.bcdBytes.ptr[i] = fBCD.bcdBytes.ptr[i + numDigits];\n        }\n        for (; i < precision; i++) {\n            fBCD.bcdBytes.ptr[i] = 0;\n        }\n    } else {\n        fBCD.bcdLong >>= (numDigits * 4);\n    }\n    scale += numDigits;\n    precision -= numDigits;\n}\n\nvoid DecimalQuantity::setBcdToZero() {\n    if (usingBytes) {\n        uprv_free(fBCD.bcdBytes.ptr);\n        fBCD.bcdBytes.ptr = nullptr;\n        usingBytes = false;\n    }\n    fBCD.bcdLong = 0L;\n    scale = 0;\n    precision = 0;\n    isApproximate = false;\n    origDouble = 0;\n    origDelta = 0;\n}\n\nvoid DecimalQuantity::readIntToBcd(int32_t n) {\n    U_ASSERT(n != 0);\n    // ints always fit inside the long implementation.\n    uint64_t result = 0L;\n    int i = 16;\n    for (; n != 0; n /= 10, i--) {\n        result = (result >> 4) + ((static_cast<uint64_t>(n) % 10) << 60);\n    }\n    U_ASSERT(!usingBytes);\n    fBCD.bcdLong = result >> (i * 4);\n    scale = 0;\n    precision = 16 - i;\n}\n\nvoid DecimalQuantity::readLongToBcd(int64_t n) {\n    U_ASSERT(n != 0);\n    if (n >= 10000000000000000L) {\n        ensureCapacity();\n        int i = 0;\n        for (; n != 0L; n /= 10L, i++) {\n            fBCD.bcdBytes.ptr[i] = static_cast<int8_t>(n % 10);\n        }\n        U_ASSERT(usingBytes);\n        scale = 0;\n        precision = i;\n    } else {\n        uint64_t result = 0L;\n        int i = 16;\n        for (; n != 0L; n /= 10L, i--) {\n            result = (result >> 4) + ((n % 10) << 60);\n        }\n        U_ASSERT(i >= 0);\n        U_ASSERT(!usingBytes);\n        fBCD.bcdLong = result >> (i * 4);\n        scale = 0;\n        precision = 16 - i;\n    }\n}\n\nvoid DecimalQuantity::readDecNumberToBcd(const DecNum& decnum) {\n    const decNumber* dn = decnum.getRawDecNumber();\n    if (dn->digits > 16) {\n        ensureCapacity(dn->digits);\n        for (int32_t i = 0; i < dn->digits; i++) {\n            fBCD.bcdBytes.ptr[i] = dn->lsu[i];\n        }\n    } else {\n        uint64_t result = 0L;\n        for (int32_t i = 0; i < dn->digits; i++) {\n            result |= static_cast<uint64_t>(dn->lsu[i]) << (4 * i);\n        }\n        fBCD.bcdLong = result;\n    }\n    scale = dn->exponent;\n    precision = dn->digits;\n}\n\nvoid DecimalQuantity::readDoubleConversionToBcd(\n        const char* buffer, int32_t length, int32_t point) {\n    // NOTE: Despite the fact that double-conversion's API is called\n    // \"DoubleToAscii\", they actually use '0' (as opposed to u8'0').\n    if (length > 16) {\n        ensureCapacity(length);\n        for (int32_t i = 0; i < length; i++) {\n            fBCD.bcdBytes.ptr[i] = buffer[length-i-1] - '0';\n        }\n    } else {\n        uint64_t result = 0L;\n        for (int32_t i = 0; i < length; i++) {\n            result |= static_cast<uint64_t>(buffer[length-i-1] - '0') << (4 * i);\n        }\n        fBCD.bcdLong = result;\n    }\n    scale = point - length;\n    precision = length;\n}\n\nvoid DecimalQuantity::compact() {\n    if (usingBytes) {\n        int32_t delta = 0;\n        for (; delta < precision && fBCD.bcdBytes.ptr[delta] == 0; delta++);\n        if (delta == precision) {\n            // Number is zero\n            setBcdToZero();\n            return;\n        } else {\n            // Remove trailing zeros\n            shiftRight(delta);\n        }\n\n        // Compute precision\n        int32_t leading = precision - 1;\n        for (; leading >= 0 && fBCD.bcdBytes.ptr[leading] == 0; leading--);\n        precision = leading + 1;\n\n        // Switch storage mechanism if possible\n        if (precision <= 16) {\n            switchStorage();\n        }\n\n    } else {\n        if (fBCD.bcdLong == 0L) {\n            // Number is zero\n            setBcdToZero();\n            return;\n        }\n\n        // Compact the number (remove trailing zeros)\n        // TODO: Use a more efficient algorithm here and below. There is a logarithmic one.\n        int32_t delta = 0;\n        for (; delta < precision && getDigitPos(delta) == 0; delta++);\n        fBCD.bcdLong >>= delta * 4;\n        scale += delta;\n\n        // Compute precision\n        int32_t leading = precision - 1;\n        for (; leading >= 0 && getDigitPos(leading) == 0; leading--);\n        precision = leading + 1;\n    }\n}\n\nvoid DecimalQuantity::ensureCapacity() {\n    ensureCapacity(40);\n}\n\nvoid DecimalQuantity::ensureCapacity(int32_t capacity) {\n    if (capacity == 0) { return; }\n    int32_t oldCapacity = usingBytes ? fBCD.bcdBytes.len : 0;\n    if (!usingBytes) {\n        // TODO: There is nothing being done to check for memory allocation failures.\n        // TODO: Consider indexing by nybbles instead of bytes in C++, so that we can\n        // make these arrays half the size.\n        fBCD.bcdBytes.ptr = static_cast<int8_t*>(uprv_malloc(capacity * sizeof(int8_t)));\n        fBCD.bcdBytes.len = capacity;\n        // Initialize the byte array to zeros (this is done automatically in Java)\n        uprv_memset(fBCD.bcdBytes.ptr, 0, capacity * sizeof(int8_t));\n    } else if (oldCapacity < capacity) {\n        auto bcd1 = static_cast<int8_t*>(uprv_malloc(capacity * 2 * sizeof(int8_t)));\n        uprv_memcpy(bcd1, fBCD.bcdBytes.ptr, oldCapacity * sizeof(int8_t));\n        // Initialize the rest of the byte array to zeros (this is done automatically in Java)\n        uprv_memset(bcd1 + oldCapacity, 0, (capacity - oldCapacity) * sizeof(int8_t));\n        uprv_free(fBCD.bcdBytes.ptr);\n        fBCD.bcdBytes.ptr = bcd1;\n        fBCD.bcdBytes.len = capacity * 2;\n    }\n    usingBytes = true;\n}\n\nvoid DecimalQuantity::switchStorage() {\n    if (usingBytes) {\n        // Change from bytes to long\n        uint64_t bcdLong = 0L;\n        for (int i = precision - 1; i >= 0; i--) {\n            bcdLong <<= 4;\n            bcdLong |= fBCD.bcdBytes.ptr[i];\n        }\n        uprv_free(fBCD.bcdBytes.ptr);\n        fBCD.bcdBytes.ptr = nullptr;\n        fBCD.bcdLong = bcdLong;\n        usingBytes = false;\n    } else {\n        // Change from long to bytes\n        // Copy the long into a local variable since it will get munged when we allocate the bytes\n        uint64_t bcdLong = fBCD.bcdLong;\n        ensureCapacity();\n        for (int i = 0; i < precision; i++) {\n            fBCD.bcdBytes.ptr[i] = static_cast<int8_t>(bcdLong & 0xf);\n            bcdLong >>= 4;\n        }\n        U_ASSERT(usingBytes);\n    }\n}\n\nvoid DecimalQuantity::copyBcdFrom(const DecimalQuantity &other) {\n    setBcdToZero();\n    if (other.usingBytes) {\n        ensureCapacity(other.precision);\n        uprv_memcpy(fBCD.bcdBytes.ptr, other.fBCD.bcdBytes.ptr, other.precision * sizeof(int8_t));\n    } else {\n        fBCD.bcdLong = other.fBCD.bcdLong;\n    }\n}\n\nvoid DecimalQuantity::moveBcdFrom(DecimalQuantity &other) {\n    setBcdToZero();\n    if (other.usingBytes) {\n        usingBytes = true;\n        fBCD.bcdBytes.ptr = other.fBCD.bcdBytes.ptr;\n        fBCD.bcdBytes.len = other.fBCD.bcdBytes.len;\n        // Take ownership away from the old instance:\n        other.fBCD.bcdBytes.ptr = nullptr;\n        other.usingBytes = false;\n    } else {\n        fBCD.bcdLong = other.fBCD.bcdLong;\n    }\n}\n\nconst char16_t* DecimalQuantity::checkHealth() const {\n    if (usingBytes) {\n        if (precision == 0) { return u\"Zero precision but we are in byte mode\"; }\n        int32_t capacity = fBCD.bcdBytes.len;\n        if (precision > capacity) { return u\"Precision exceeds length of byte array\"; }\n        if (getDigitPos(precision - 1) == 0) { return u\"Most significant digit is zero in byte mode\"; }\n        if (getDigitPos(0) == 0) { return u\"Least significant digit is zero in long mode\"; }\n        for (int i = 0; i < precision; i++) {\n            if (getDigitPos(i) >= 10) { return u\"Digit exceeding 10 in byte array\"; }\n            if (getDigitPos(i) < 0) { return u\"Digit below 0 in byte array\"; }\n        }\n        for (int i = precision; i < capacity; i++) {\n            if (getDigitPos(i) != 0) { return u\"Nonzero digits outside of range in byte array\"; }\n        }\n    } else {\n        if (precision == 0 && fBCD.bcdLong != 0) {\n            return u\"Value in bcdLong even though precision is zero\";\n        }\n        if (precision > 16) { return u\"Precision exceeds length of long\"; }\n        if (precision != 0 && getDigitPos(precision - 1) == 0) {\n            return u\"Most significant digit is zero in long mode\";\n        }\n        if (precision != 0 && getDigitPos(0) == 0) {\n            return u\"Least significant digit is zero in long mode\";\n        }\n        for (int i = 0; i < precision; i++) {\n            if (getDigitPos(i) >= 10) { return u\"Digit exceeding 10 in long\"; }\n            if (getDigitPos(i) < 0) { return u\"Digit below 0 in long (?!)\"; }\n        }\n        for (int i = precision; i < 16; i++) {\n            if (getDigitPos(i) != 0) { return u\"Nonzero digits outside of range in long\"; }\n        }\n    }\n\n    // No error\n    return nullptr;\n}\n\nbool DecimalQuantity::operator==(const DecimalQuantity& other) const {\n    bool basicEquals =\n            scale == other.scale\n            && precision == other.precision\n            && flags == other.flags\n            && lOptPos == other.lOptPos\n            && lReqPos == other.lReqPos\n            && rReqPos == other.rReqPos\n            && rOptPos == other.rOptPos\n            && isApproximate == other.isApproximate;\n    if (!basicEquals) {\n        return false;\n    }\n\n    if (precision == 0) {\n        return true;\n    } else if (isApproximate) {\n        return origDouble == other.origDouble && origDelta == other.origDelta;\n    } else {\n        for (int m = getUpperDisplayMagnitude(); m >= getLowerDisplayMagnitude(); m--) {\n            if (getDigit(m) != other.getDigit(m)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\nUnicodeString DecimalQuantity::toString() const {\n    MaybeStackArray<char, 30> digits(precision + 1);\n    for (int32_t i = 0; i < precision; i++) {\n        digits[i] = getDigitPos(precision - i - 1) + '0';\n    }\n    digits[precision] = 0; // terminate buffer\n    char buffer8[100];\n    snprintf(\n            buffer8,\n            sizeof(buffer8),\n            \"<DecimalQuantity %d:%d:%d:%d %s %s%s%s%d>\",\n            (lOptPos > 999 ? 999 : lOptPos),\n            lReqPos,\n            rReqPos,\n            (rOptPos < -999 ? -999 : rOptPos),\n            (usingBytes ? \"bytes\" : \"long\"),\n            (isNegative() ? \"-\" : \"\"),\n            (precision == 0 ? \"0\" : digits.getAlias()),\n            \"E\",\n            scale);\n    return UnicodeString(buffer8, -1, US_INV);\n}\n\n#endif /* #if !UCONFIG_NO_FORMATTING */\n", "// \u00a9 2016 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html\n/********************************************************************\n * COPYRIGHT:\n * Copyright (c) 1997-2016, International Business Machines Corporation and\n * others. All Rights Reserved.\n ********************************************************************/\n/* Modification History:\n*   Date        Name        Description\n*   07/15/99    helena      Ported to HPUX 10/11 CC.\n*/\n\n#include \"unicode/utypes.h\"\n\n#if !UCONFIG_NO_FORMATTING\n\n#include \"numfmtst.h\"\n#include \"unicode/currpinf.h\"\n#include \"unicode/dcfmtsym.h\"\n#include \"unicode/decimfmt.h\"\n#include \"unicode/localpointer.h\"\n#include \"unicode/ucurr.h\"\n#include \"unicode/ustring.h\"\n#include \"unicode/measfmt.h\"\n#include \"unicode/curramt.h\"\n#include \"unicode/strenum.h\"\n#include \"textfile.h\"\n#include \"tokiter.h\"\n#include \"charstr.h\"\n#include \"cstr.h\"\n#include \"putilimp.h\"\n#include \"winnmtst.h\"\n#include <cmath>\n#include <float.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"cmemory.h\"\n#include \"cstring.h\"\n#include \"unicode/numsys.h\"\n#include \"fmtableimp.h\"\n#include \"numberformattesttuple.h\"\n#include \"unicode/msgfmt.h\"\n#include \"number_decimalquantity.h\"\n#include \"unicode/numberformatter.h\"\n\n#if (U_PLATFORM == U_PF_AIX) || (U_PLATFORM == U_PF_OS390)\n// These should not be macros. If they are,\n// replace them with std::isnan and std::isinf\n#if defined(isnan)\n#undef isnan\nnamespace std {\n bool isnan(double x) {\n   return _isnan(x);\n }\n}\n#endif\n#if defined(isinf)\n#undef isinf\nnamespace std {\n bool isinf(double x) {\n   return _isinf(x);\n }\n}\n#endif\n#endif\n\nusing icu::number::impl::DecimalQuantity;\nusing namespace icu::number;\n\n//#define NUMFMTST_CACHE_DEBUG 1\n#include \"stdio.h\" /* for sprintf */\n// #include \"iostream\"   // for cout\n\n//#define NUMFMTST_DEBUG 1\n\nstatic const UChar EUR[] = {69,85,82,0}; // \"EUR\"\nstatic const UChar ISO_CURRENCY_USD[] = {0x55, 0x53, 0x44, 0}; // \"USD\"\n\n\n// *****************************************************************************\n// class NumberFormatTest\n// *****************************************************************************\n\n#define CHECK(status,str) if (U_FAILURE(status)) { errcheckln(status, UnicodeString(\"FAIL: \") + str + \" - \" + u_errorName(status)); return; }\n#define CHECK_DATA(status,str) if (U_FAILURE(status)) { dataerrln(UnicodeString(\"FAIL: \") + str + \" - \" + u_errorName(status)); return; }\n\nvoid NumberFormatTest::runIndexedTest( int32_t index, UBool exec, const char* &name, char* /*par*/ )\n{\n  TESTCASE_AUTO_BEGIN;\n  TESTCASE_AUTO(TestCurrencySign);\n  TESTCASE_AUTO(TestCurrency);\n  TESTCASE_AUTO(TestParse);\n  TESTCASE_AUTO(TestRounding487);\n  TESTCASE_AUTO(TestQuotes);\n  TESTCASE_AUTO(TestExponential);\n  TESTCASE_AUTO(TestPatterns);\n\n  // Upgrade to alphaWorks - liu 5/99\n  TESTCASE_AUTO(TestExponent);\n  TESTCASE_AUTO(TestScientific);\n  TESTCASE_AUTO(TestPad);\n  TESTCASE_AUTO(TestPatterns2);\n  TESTCASE_AUTO(TestSecondaryGrouping);\n  TESTCASE_AUTO(TestSurrogateSupport);\n  TESTCASE_AUTO(TestAPI);\n\n  TESTCASE_AUTO(TestCurrencyObject);\n  TESTCASE_AUTO(TestCurrencyPatterns);\n  //TESTCASE_AUTO(TestDigitList);\n  TESTCASE_AUTO(TestWhiteSpaceParsing);\n  TESTCASE_AUTO(TestComplexCurrency);  // This test removed because CLDR no longer uses choice formats in currency symbols.\n  TESTCASE_AUTO(TestRegCurrency);\n  TESTCASE_AUTO(TestSymbolsWithBadLocale);\n  TESTCASE_AUTO(TestAdoptDecimalFormatSymbols);\n\n  TESTCASE_AUTO(TestScientific2);\n  TESTCASE_AUTO(TestScientificGrouping);\n  TESTCASE_AUTO(TestInt64);\n\n  TESTCASE_AUTO(TestPerMill);\n  TESTCASE_AUTO(TestIllegalPatterns);\n  TESTCASE_AUTO(TestCases);\n\n  TESTCASE_AUTO(TestCurrencyNames);\n  TESTCASE_AUTO(TestCurrencyAmount);\n  TESTCASE_AUTO(TestCurrencyUnit);\n  TESTCASE_AUTO(TestCoverage);\n  TESTCASE_AUTO(TestLocalizedPatternSymbolCoverage);\n  TESTCASE_AUTO(TestJB3832);\n  TESTCASE_AUTO(TestHost);\n  TESTCASE_AUTO(TestHostClone);\n  TESTCASE_AUTO(TestCurrencyFormat);\n  TESTCASE_AUTO(TestRounding);\n  TESTCASE_AUTO(TestNonpositiveMultiplier);\n  TESTCASE_AUTO(TestNumberingSystems);\n  TESTCASE_AUTO(TestSpaceParsing);\n  TESTCASE_AUTO(TestMultiCurrencySign);\n  TESTCASE_AUTO(TestCurrencyFormatForMixParsing);\n  TESTCASE_AUTO(TestMismatchedCurrencyFormatFail);\n  TESTCASE_AUTO(TestDecimalFormatCurrencyParse);\n  TESTCASE_AUTO(TestCurrencyIsoPluralFormat);\n  TESTCASE_AUTO(TestCurrencyParsing);\n  TESTCASE_AUTO(TestParseCurrencyInUCurr);\n  TESTCASE_AUTO(TestFormatAttributes);\n  TESTCASE_AUTO(TestFieldPositionIterator);\n  TESTCASE_AUTO(TestDecimal);\n  TESTCASE_AUTO(TestCurrencyFractionDigits);\n  TESTCASE_AUTO(TestExponentParse);\n  TESTCASE_AUTO(TestExplicitParents);\n  TESTCASE_AUTO(TestLenientParse);\n  TESTCASE_AUTO(TestAvailableNumberingSystems);\n  TESTCASE_AUTO(TestRoundingPattern);\n  TESTCASE_AUTO(Test9087);\n  TESTCASE_AUTO(TestFormatFastpaths);\n  TESTCASE_AUTO(TestFormattableSize);\n  TESTCASE_AUTO(TestUFormattable);\n  TESTCASE_AUTO(TestSignificantDigits);\n  TESTCASE_AUTO(TestShowZero);\n  TESTCASE_AUTO(TestCompatibleCurrencies);\n  TESTCASE_AUTO(TestBug9936);\n  TESTCASE_AUTO(TestParseNegativeWithFaLocale);\n  TESTCASE_AUTO(TestParseNegativeWithAlternateMinusSign);\n  TESTCASE_AUTO(TestCustomCurrencySignAndSeparator);\n  TESTCASE_AUTO(TestParseSignsAndMarks);\n  TESTCASE_AUTO(Test10419RoundingWith0FractionDigits);\n  TESTCASE_AUTO(Test10468ApplyPattern);\n  TESTCASE_AUTO(TestRoundingScientific10542);\n  TESTCASE_AUTO(TestZeroScientific10547);\n  TESTCASE_AUTO(TestAccountingCurrency);\n  TESTCASE_AUTO(TestEquality);\n  TESTCASE_AUTO(TestCurrencyUsage);\n  TESTCASE_AUTO(TestDoubleLimit11439);\n  TESTCASE_AUTO(TestGetAffixes);\n  TESTCASE_AUTO(TestToPatternScientific11648);\n  TESTCASE_AUTO(TestBenchmark);\n  TESTCASE_AUTO(TestCtorApplyPatternDifference);\n  TESTCASE_AUTO(TestFractionalDigitsForCurrency);\n  TESTCASE_AUTO(TestFormatCurrencyPlural);\n  TESTCASE_AUTO(Test11868);\n  TESTCASE_AUTO(Test11739_ParseLongCurrency);\n  TESTCASE_AUTO(Test13035_MultiCodePointPaddingInPattern);\n  TESTCASE_AUTO(Test13737_ParseScientificStrict);\n  TESTCASE_AUTO(Test10727_RoundingZero);\n  TESTCASE_AUTO(Test11376_getAndSetPositivePrefix);\n  TESTCASE_AUTO(Test11475_signRecognition);\n  TESTCASE_AUTO(Test11640_getAffixes);\n  TESTCASE_AUTO(Test11649_toPatternWithMultiCurrency);\n  TESTCASE_AUTO(Test13327_numberingSystemBufferOverflow);\n  TESTCASE_AUTO(Test13391_chakmaParsing);\n  TESTCASE_AUTO(Test11735_ExceptionIssue);\n  TESTCASE_AUTO(Test11035_FormatCurrencyAmount);\n  TESTCASE_AUTO(Test11318_DoubleConversion);\n  TESTCASE_AUTO(TestParsePercentRegression);\n  TESTCASE_AUTO(TestMultiplierWithScale);\n  TESTCASE_AUTO(TestFastFormatInt32);\n  TESTCASE_AUTO(Test11646_Equality);\n  TESTCASE_AUTO(TestParseNaN);\n  TESTCASE_AUTO(Test11897_LocalizedPatternSeparator);\n  TESTCASE_AUTO(Test13055_PercentageRounding);\n  TESTCASE_AUTO(Test11839);\n  TESTCASE_AUTO(Test10354);\n  TESTCASE_AUTO(Test11645_ApplyPatternEquality);\n  TESTCASE_AUTO(Test12567);\n  TESTCASE_AUTO(Test11626_CustomizeCurrencyPluralInfo);\n  TESTCASE_AUTO(Test20073_StrictPercentParseErrorIndex);\n  TESTCASE_AUTO(Test13056_GroupingSize);\n  TESTCASE_AUTO(Test11025_CurrencyPadding);\n  TESTCASE_AUTO(Test11648_ExpDecFormatMalPattern);\n  TESTCASE_AUTO(Test11649_DecFmtCurrencies);\n  TESTCASE_AUTO(Test13148_ParseGroupingSeparators);\n  TESTCASE_AUTO(Test12753_PatternDecimalPoint);\n  TESTCASE_AUTO(Test11647_PatternCurrencySymbols);\n  TESTCASE_AUTO(Test11913_BigDecimal);\n  TESTCASE_AUTO(Test11020_RoundingInScientificNotation);\n  TESTCASE_AUTO(Test11640_TripleCurrencySymbol);\n  TESTCASE_AUTO(Test13763_FieldPositionIteratorOffset);\n  TESTCASE_AUTO(Test13777_ParseLongNameNonCurrencyMode);\n  TESTCASE_AUTO(Test13804_EmptyStringsWhenParsing);\n  TESTCASE_AUTO(Test20037_ScientificIntegerOverflow);\n  TESTCASE_AUTO(Test13840_ParseLongStringCrash);\n  TESTCASE_AUTO(Test13850_EmptyStringCurrency);\n  TESTCASE_AUTO_END;\n}\n\n// -------------------------------------\n\n// Test API (increase code coverage)\nvoid\nNumberFormatTest::TestAPI(void)\n{\n  logln(\"Test API\");\n  UErrorCode status = U_ZERO_ERROR;\n  NumberFormat *test = NumberFormat::createInstance(\"root\", status);\n  if(U_FAILURE(status)) {\n    dataerrln(\"unable to create format object - %s\", u_errorName(status));\n  }\n  if(test != NULL) {\n    test->setMinimumIntegerDigits(10);\n    test->setMaximumIntegerDigits(1);\n\n    test->setMinimumFractionDigits(10);\n    test->setMaximumFractionDigits(1);\n\n    UnicodeString result;\n    FieldPosition pos;\n    Formattable bla(\"Paja Patak\"); // Donald Duck for non Serbian speakers\n    test->format(bla, result, pos, status);\n    if(U_SUCCESS(status)) {\n      errln(\"Yuck... Formatted a duck... As a number!\");\n    } else {\n      status = U_ZERO_ERROR;\n    }\n\n    result.remove();\n    int64_t ll = 12;\n    test->format(ll, result);\n    assertEquals(\"format int64_t error\", u\"2.0\", result);\n\n    test->setMinimumIntegerDigits(4);\n    test->setMinimumFractionDigits(4);\n\n    result.remove();\n    test->format(ll, result);\n    assertEquals(\"format int64_t error\", u\"0,012.0000\", result);\n\n    ParsePosition ppos;\n    LocalPointer<CurrencyAmount> currAmt(test->parseCurrency(\"\",ppos));\n    // old test for (U_FAILURE(status)) was bogus here, method does not set status!\n    if (ppos.getIndex()) {\n        errln(\"Parsed empty string as currency\");\n    }\n\n    delete test;\n  }\n}\n\nclass StubNumberFormat :public NumberFormat{\npublic:\n    StubNumberFormat(){};\n    virtual UnicodeString& format(double ,UnicodeString& appendTo,FieldPosition& ) const {\n        return appendTo;\n    }\n    virtual UnicodeString& format(int32_t ,UnicodeString& appendTo,FieldPosition& ) const {\n        return appendTo.append((UChar)0x0033);\n    }\n    virtual UnicodeString& format(int64_t number,UnicodeString& appendTo,FieldPosition& pos) const {\n        return NumberFormat::format(number, appendTo, pos);\n    }\n    virtual UnicodeString& format(const Formattable& , UnicodeString& appendTo, FieldPosition& , UErrorCode& ) const {\n        return appendTo;\n    }\n    virtual void parse(const UnicodeString& ,\n                    Formattable& ,\n                    ParsePosition& ) const {}\n    virtual void parse( const UnicodeString& ,\n                        Formattable& ,\n                        UErrorCode& ) const {}\n    virtual UClassID getDynamicClassID(void) const {\n        static char classID = 0;\n        return (UClassID)&classID;\n    }\n    virtual Format* clone() const {return NULL;}\n};\n\nvoid\nNumberFormatTest::TestCoverage(void){\n    StubNumberFormat stub;\n    UnicodeString agent(\"agent\");\n    FieldPosition pos;\n    int64_t num = 4;\n    if (stub.format(num, agent, pos) != UnicodeString(\"agent3\")){\n        errln(\"NumberFormat::format(int64, UnicodString&, FieldPosition&) should delegate to (int32, ,)\");\n    };\n}\n\nvoid NumberFormatTest::TestLocalizedPatternSymbolCoverage() {\n    IcuTestErrorCode errorCode(*this, \"TestLocalizedPatternSymbolCoverage\");\n    // Ticket #12961: DecimalFormat::toLocalizedPattern() is not working as designed.\n    DecimalFormatSymbols dfs(errorCode);\n    dfs.setSymbol(DecimalFormatSymbols::kGroupingSeparatorSymbol, u'\u2056');\n    dfs.setSymbol(DecimalFormatSymbols::kDecimalSeparatorSymbol, u'\u2058');\n    dfs.setSymbol(DecimalFormatSymbols::kPatternSeparatorSymbol, u'\u2059');\n    dfs.setSymbol(DecimalFormatSymbols::kDigitSymbol, u'\u25b0');\n    dfs.setSymbol(DecimalFormatSymbols::kZeroDigitSymbol, u'\u0ed0');\n    dfs.setSymbol(DecimalFormatSymbols::kSignificantDigitSymbol, u'\u2055');\n    dfs.setSymbol(DecimalFormatSymbols::kPlusSignSymbol, u'\u2020');\n    dfs.setSymbol(DecimalFormatSymbols::kMinusSignSymbol, u'\u2021');\n    dfs.setSymbol(DecimalFormatSymbols::kPercentSymbol, u'\u205c');\n    dfs.setSymbol(DecimalFormatSymbols::kPerMillSymbol, u'\u2031');\n    dfs.setSymbol(DecimalFormatSymbols::kExponentialSymbol, u\"\u2051\u2051\"); // tests multi-char sequence\n    dfs.setSymbol(DecimalFormatSymbols::kPadEscapeSymbol, u'\u2042');\n\n    {\n        UnicodeString standardPattern(u\"#,##0.05+%;#,##0.05-%\");\n        UnicodeString localizedPattern(u\"\u25b0\u2056\u25b0\u25b0\u0ed0\u2058\u0ed0\u0ed5\u2020\u205c\u2059\u25b0\u2056\u25b0\u25b0\u0ed0\u2058\u0ed0\u0ed5\u2021\u205c\");\n\n        DecimalFormat df1(\"#\", new DecimalFormatSymbols(dfs), errorCode);\n        df1.applyPattern(standardPattern, errorCode);\n        DecimalFormat df2(\"#\", new DecimalFormatSymbols(dfs), errorCode);\n        df2.applyLocalizedPattern(localizedPattern, errorCode);\n        assertTrue(\"DecimalFormat instances should be equal\", df1 == df2);\n        UnicodeString p2;\n        assertEquals(\"toPattern should match on localizedPattern instance\",\n                standardPattern, df2.toPattern(p2));\n        UnicodeString lp1;\n        assertEquals(\"toLocalizedPattern should match on standardPattern instance\",\n                localizedPattern, df1.toLocalizedPattern(lp1));\n    }\n\n    {\n        UnicodeString standardPattern(u\"* @@@E0\u2030\");\n        UnicodeString localizedPattern(u\"\u2042 \u2055\u2055\u2055\u2051\u2051\u0ed0\u2031\");\n\n        DecimalFormat df1(\"#\", new DecimalFormatSymbols(dfs), errorCode);\n        df1.applyPattern(standardPattern, errorCode);\n        DecimalFormat df2(\"#\", new DecimalFormatSymbols(dfs), errorCode);\n        df2.applyLocalizedPattern(localizedPattern, errorCode);\n        assertTrue(\"DecimalFormat instances should be equal\", df1 == df2);\n        UnicodeString p2;\n        assertEquals(\"toPattern should match on localizedPattern instance\",\n                standardPattern, df2.toPattern(p2));\n        UnicodeString lp1;\n        assertEquals(\"toLocalizedPattern should match on standardPattern instance\",\n                localizedPattern, df1.toLocalizedPattern(lp1));\n    }\n}\n\n// Test various patterns\nvoid\nNumberFormatTest::TestPatterns(void)\n{\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols sym(Locale::getUS(), status);\n    if (U_FAILURE(status)) { errcheckln(status, \"FAIL: Could not construct DecimalFormatSymbols - %s\", u_errorName(status)); return; }\n\n    const char* pat[]    = { \"#.#\", \"#.\", \".#\", \"#\" };\n    int32_t pat_length = UPRV_LENGTHOF(pat);\n    const char* newpat[] = { \"0.#\", \"0.\", \"#.0\", \"0\" };\n    const char* num[]    = { \"0\",   \"0.\", \".0\", \"0\" };\n    for (int32_t i=0; i<pat_length; ++i)\n    {\n        status = U_ZERO_ERROR;\n        DecimalFormat fmt(pat[i], sym, status);\n        if (U_FAILURE(status)) { errln((UnicodeString)\"FAIL: DecimalFormat constructor failed for \" + pat[i]); continue; }\n        UnicodeString newp; fmt.toPattern(newp);\n        if (!(newp == newpat[i]))\n            errln((UnicodeString)\"FAIL: Pattern \" + pat[i] + \" should transmute to \" + newpat[i] +\n                  \"; \" + newp + \" seen instead\");\n\n        UnicodeString s; (*(NumberFormat*)&fmt).format((int32_t)0, s);\n        if (!(s == num[i]))\n        {\n            errln((UnicodeString)\"FAIL: Pattern \" + pat[i] + \" should format zero as \" + num[i] +\n                  \"; \" + s + \" seen instead\");\n            logln((UnicodeString)\"Min integer digits = \" + fmt.getMinimumIntegerDigits());\n        }\n    }\n}\n\n/*\nicu_2_4::DigitList::operator== 0 0 2 icuuc24d.dll digitlst.cpp Doug\nicu_2_4::DigitList::append 0 0 4 icuin24d.dll digitlst.h Doug\nicu_2_4::DigitList::operator!= 0 0 1 icuuc24d.dll digitlst.h Doug\n*/\n/*\nvoid\nNumberFormatTest::TestDigitList(void)\n{\n  // API coverage for DigitList\n  DigitList list1;\n  list1.append('1');\n  list1.fDecimalAt = 1;\n  DigitList list2;\n  list2.set((int32_t)1);\n  if (list1 != list2) {\n    errln(\"digitlist append, operator!= or set failed \");\n  }\n  if (!(list1 == list2)) {\n    errln(\"digitlist append, operator== or set failed \");\n  }\n}\n*/\n\n// -------------------------------------\n\n// Test exponential pattern\nvoid\nNumberFormatTest::TestExponential(void)\n{\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols sym(Locale::getUS(), status);\n    if (U_FAILURE(status)) { errcheckln(status, \"FAIL: Bad status returned by DecimalFormatSymbols ct - %s\", u_errorName(status)); return; }\n    const char* pat[] = { \"0.####E0\", \"00.000E00\", \"##0.######E000\", \"0.###E0;[0.###E0]\"  };\n    int32_t pat_length = UPRV_LENGTHOF(pat);\n\n// The following #if statements allow this test to be built and run on\n// platforms that do not have standard IEEE numerics.  For example,\n// S/390 doubles have an exponent range of -78 to +75.  For the\n// following #if statements to work, float.h must define\n// DBL_MAX_10_EXP to be a compile-time constant.\n\n// This section may be expanded as needed.\n\n#if DBL_MAX_10_EXP > 300\n    double val[] = { 0.01234, 123456789, 1.23e300, -3.141592653e-271 };\n    int32_t val_length = UPRV_LENGTHOF(val);\n    const char* valFormat[] =\n    {\n        // 0.####E0\n        \"1.234E-2\", \"1.2346E8\", \"1.23E300\", \"-3.1416E-271\",\n        // 00.000E00\n        \"12.340E-03\", \"12.346E07\", \"12.300E299\", \"-31.416E-272\",\n        // ##0.######E000\n        \"12.34E-003\", \"123.4568E006\", \"1.23E300\", \"-314.1593E-273\",\n        // 0.###E0;[0.###E0]\n        \"1.234E-2\", \"1.235E8\", \"1.23E300\", \"[3.142E-271]\"\n    };\n    double valParse[] =\n    {\n        0.01234, 123460000, 1.23E300, -3.1416E-271,\n        0.01234, 123460000, 1.23E300, -3.1416E-271,\n        0.01234, 123456800, 1.23E300, -3.141593E-271,\n        0.01234, 123500000, 1.23E300, -3.142E-271,\n    };\n#elif DBL_MAX_10_EXP > 70\n    double val[] = { 0.01234, 123456789, 1.23e70, -3.141592653e-71 };\n    int32_t val_length = UPRV_LENGTHOF(val);\n    char* valFormat[] =\n    {\n        // 0.####E0\n        \"1.234E-2\", \"1.2346E8\", \"1.23E70\", \"-3.1416E-71\",\n        // 00.000E00\n        \"12.340E-03\", \"12.346E07\", \"12.300E69\", \"-31.416E-72\",\n        // ##0.######E000\n        \"12.34E-003\", \"123.4568E006\", \"12.3E069\", \"-31.41593E-072\",\n        // 0.###E0;[0.###E0]\n        \"1.234E-2\", \"1.235E8\", \"1.23E70\", \"[3.142E-71]\"\n    };\n    double valParse[] =\n    {\n        0.01234, 123460000, 1.23E70, -3.1416E-71,\n        0.01234, 123460000, 1.23E70, -3.1416E-71,\n        0.01234, 123456800, 1.23E70, -3.141593E-71,\n        0.01234, 123500000, 1.23E70, -3.142E-71,\n    };\n#else\n    // Don't test double conversion\n    double* val = 0;\n    int32_t val_length = 0;\n    char** valFormat = 0;\n    double* valParse = 0;\n    logln(\"Warning: Skipping double conversion tests\");\n#endif\n\n    int32_t lval[] = { 0, -1, 1, 123456789 };\n    int32_t lval_length = UPRV_LENGTHOF(lval);\n    const char* lvalFormat[] =\n    {\n        // 0.####E0\n        \"0E0\", \"-1E0\", \"1E0\", \"1.2346E8\",\n        // 00.000E00\n        \"00.000E00\", \"-10.000E-01\", \"10.000E-01\", \"12.346E07\",\n        // ##0.######E000\n        \"0E000\", \"-1E000\", \"1E000\", \"123.4568E006\",\n        // 0.###E0;[0.###E0]\n        \"0E0\", \"[1E0]\", \"1E0\", \"1.235E8\"\n    };\n    int32_t lvalParse[] =\n    {\n        0, -1, 1, 123460000,\n        0, -1, 1, 123460000,\n        0, -1, 1, 123456800,\n        0, -1, 1, 123500000,\n    };\n    int32_t ival = 0, ilval = 0;\n    for (int32_t p=0; p<pat_length; ++p)\n    {\n        DecimalFormat fmt(pat[p], sym, status);\n        if (U_FAILURE(status)) { errln(\"FAIL: Bad status returned by DecimalFormat ct\"); continue; }\n        UnicodeString pattern;\n        logln((UnicodeString)\"Pattern \\\"\" + pat[p] + \"\\\" -toPattern-> \\\"\" +\n          fmt.toPattern(pattern) + \"\\\"\");\n        int32_t v;\n        for (v=0; v<val_length; ++v)\n        {\n            UnicodeString s; (*(NumberFormat*)&fmt).format(val[v], s);\n            logln((UnicodeString)\" \" + val[v] + \" -format-> \" + s);\n            if (s != valFormat[v+ival])\n                errln((UnicodeString)\"FAIL: Expected \" + valFormat[v+ival]);\n\n            ParsePosition pos(0);\n            Formattable af;\n            fmt.parse(s, af, pos);\n            double a;\n            UBool useEpsilon = FALSE;\n            if (af.getType() == Formattable::kLong)\n                a = af.getLong();\n            else if (af.getType() == Formattable::kDouble) {\n                a = af.getDouble();\n#if U_PF_OS390 <= U_PLATFORM && U_PLATFORM <= U_PF_OS400\n                // S/390 will show a failure like this:\n                //| -3.141592652999999e-271 -format-> -3.1416E-271\n                //|                          -parse-> -3.1416e-271\n                //| FAIL: Expected -3.141599999999999e-271\n                // To compensate, we use an epsilon-based equality\n                // test on S/390 only.  We don't want to do this in\n                // general because it's less exacting.\n                useEpsilon = TRUE;\n#endif\n            }\n            else {\n                errln(UnicodeString(\"FAIL: Non-numeric Formattable returned: \") + pattern + \" \" + s);\n                continue;\n            }\n            if (pos.getIndex() == s.length())\n            {\n                logln((UnicodeString)\"  -parse-> \" + a);\n                // Use epsilon comparison as necessary\n                if ((useEpsilon &&\n                    (uprv_fabs(a - valParse[v+ival]) / a > (2*DBL_EPSILON))) ||\n                    (!useEpsilon && a != valParse[v+ival]))\n                {\n                    errln((UnicodeString)\"FAIL: Expected \" + valParse[v+ival] + \" but got \" + a\n                        + \" on input \" + s);\n                }\n            }\n            else {\n                errln((UnicodeString)\"FAIL: Partial parse (\" + pos.getIndex() + \" chars) -> \" + a);\n                errln((UnicodeString)\"  should be (\" + s.length() + \" chars) -> \" + valParse[v+ival]);\n            }\n        }\n        for (v=0; v<lval_length; ++v)\n        {\n            UnicodeString s;\n            (*(NumberFormat*)&fmt).format(lval[v], s);\n            logln((UnicodeString)\" \" + lval[v] + \"L -format-> \" + s);\n            if (s != lvalFormat[v+ilval])\n                errln((UnicodeString)\"ERROR: Expected \" + lvalFormat[v+ilval] + \" Got: \" + s);\n\n            ParsePosition pos(0);\n            Formattable af;\n            fmt.parse(s, af, pos);\n            if (af.getType() == Formattable::kLong ||\n                af.getType() == Formattable::kInt64) {\n                UErrorCode status = U_ZERO_ERROR;\n                int32_t a = af.getLong(status);\n                if (pos.getIndex() == s.length())\n                {\n                    logln((UnicodeString)\"  -parse-> \" + a);\n                    if (a != lvalParse[v+ilval])\n                        errln((UnicodeString)\"FAIL: Expected \" + lvalParse[v+ilval] + \" but got \" + a);\n                }\n                else\n                    errln((UnicodeString)\"FAIL: Partial parse (\" + pos.getIndex() + \" chars) -> \" + a);\n            }\n            else\n                errln((UnicodeString)\"FAIL: Non-long Formattable returned for \" + s\n                    + \" Double: \" + af.getDouble()\n                    + \", Long: \" + af.getLong());\n        }\n        ival += val_length;\n        ilval += lval_length;\n    }\n}\n\nvoid\nNumberFormatTest::TestScientific2() {\n    // jb 2552\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat* fmt = (DecimalFormat*)NumberFormat::createCurrencyInstance(\"en_US\", status);\n    if (U_SUCCESS(status)) {\n        double num = 12.34;\n        expect(*fmt, num, \"$12.34\");\n        fmt->setScientificNotation(TRUE);\n        expect(*fmt, num, \"$1.23E1\");\n        fmt->setScientificNotation(FALSE);\n        expect(*fmt, num, \"$12.34\");\n    }\n    delete fmt;\n}\n\nvoid\nNumberFormatTest::TestScientificGrouping() {\n    // jb 2552\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat fmt(\"##0.00E0\",status);\n    if (assertSuccess(\"\", status, true, __FILE__, __LINE__)) {\n        expect(fmt, .01234, \"12.3E-3\");\n        expect(fmt, .1234, \"123E-3\");\n        expect(fmt, 1.234, \"1.23E0\");\n        expect(fmt, 12.34, \"12.3E0\");\n        expect(fmt, 123.4, \"123E0\");\n        expect(fmt, 1234., \"1.23E3\");\n    }\n}\n\n/*static void setFromString(DigitList& dl, const char* str) {\n    char c;\n    UBool decimalSet = FALSE;\n    dl.clear();\n    while ((c = *str++)) {\n        if (c == '-') {\n            dl.fIsPositive = FALSE;\n        } else if (c == '+') {\n            dl.fIsPositive = TRUE;\n        } else if (c == '.') {\n            dl.fDecimalAt = dl.fCount;\n            decimalSet = TRUE;\n        } else {\n            dl.append(c);\n        }\n    }\n    if (!decimalSet) {\n        dl.fDecimalAt = dl.fCount;\n    }\n}*/\n\nvoid\nNumberFormatTest::TestInt64() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat fmt(\"#.#E0\",status);\n    if (U_FAILURE(status)) {\n        dataerrln(\"Error creating DecimalFormat - %s\", u_errorName(status));\n        return;\n    }\n    fmt.setMaximumFractionDigits(20);\n    if (U_SUCCESS(status)) {\n        expect(fmt, (Formattable)(int64_t)0, \"0E0\");\n        expect(fmt, (Formattable)(int64_t)-1, \"-1E0\");\n        expect(fmt, (Formattable)(int64_t)1, \"1E0\");\n        expect(fmt, (Formattable)(int64_t)2147483647, \"2.147483647E9\");\n        expect(fmt, (Formattable)((int64_t)-2147483647-1), \"-2.147483648E9\");\n        expect(fmt, (Formattable)(int64_t)U_INT64_MAX, \"9.223372036854775807E18\");\n        expect(fmt, (Formattable)(int64_t)U_INT64_MIN, \"-9.223372036854775808E18\");\n    }\n\n    // also test digitlist\n/*    int64_t int64max = U_INT64_MAX;\n    int64_t int64min = U_INT64_MIN;\n    const char* int64maxstr = \"9223372036854775807\";\n    const char* int64minstr = \"-9223372036854775808\";\n    UnicodeString fail(\"fail: \");\n\n    // test max int64 value\n    DigitList dl;\n    setFromString(dl, int64maxstr);\n    {\n        if (!dl.fitsIntoInt64(FALSE)) {\n            errln(fail + int64maxstr + \" didn't fit\");\n        }\n        int64_t int64Value = dl.getInt64();\n        if (int64Value != int64max) {\n            errln(fail + int64maxstr);\n        }\n        dl.set(int64Value);\n        int64Value = dl.getInt64();\n        if (int64Value != int64max) {\n            errln(fail + int64maxstr);\n        }\n    }\n    // test negative of max int64 value (1 shy of min int64 value)\n    dl.fIsPositive = FALSE;\n    {\n        if (!dl.fitsIntoInt64(FALSE)) {\n            errln(fail + \"-\" + int64maxstr + \" didn't fit\");\n        }\n        int64_t int64Value = dl.getInt64();\n        if (int64Value != -int64max) {\n            errln(fail + \"-\" + int64maxstr);\n        }\n        dl.set(int64Value);\n        int64Value = dl.getInt64();\n        if (int64Value != -int64max) {\n            errln(fail + \"-\" + int64maxstr);\n        }\n    }\n    // test min int64 value\n    setFromString(dl, int64minstr);\n    {\n        if (!dl.fitsIntoInt64(FALSE)) {\n            errln(fail + \"-\" + int64minstr + \" didn't fit\");\n        }\n        int64_t int64Value = dl.getInt64();\n        if (int64Value != int64min) {\n            errln(fail + int64minstr);\n        }\n        dl.set(int64Value);\n        int64Value = dl.getInt64();\n        if (int64Value != int64min) {\n            errln(fail + int64minstr);\n        }\n    }\n    // test negative of min int 64 value (1 more than max int64 value)\n    dl.fIsPositive = TRUE; // won't fit\n    {\n        if (dl.fitsIntoInt64(FALSE)) {\n            errln(fail + \"-(\" + int64minstr + \") didn't fit\");\n        }\n    }*/\n}\n\n// -------------------------------------\n\n// Test the handling of quotes\nvoid\nNumberFormatTest::TestQuotes(void)\n{\n    UErrorCode status = U_ZERO_ERROR;\n    UnicodeString *pat;\n    DecimalFormatSymbols *sym = new DecimalFormatSymbols(Locale::getUS(), status);\n    if (U_FAILURE(status)) {\n        errcheckln(status, \"Fail to create DecimalFormatSymbols - %s\", u_errorName(status));\n        delete sym;\n        return;\n    }\n    pat = new UnicodeString(\"a'fo''o'b#\");\n    DecimalFormat *fmt = new DecimalFormat(*pat, *sym, status);\n    UnicodeString s;\n    ((NumberFormat*)fmt)->format((int32_t)123, s);\n    logln((UnicodeString)\"Pattern \\\"\" + *pat + \"\\\"\");\n    logln((UnicodeString)\" Format 123 -> \" + escape(s));\n    if (!(s==\"afo'ob123\"))\n        errln((UnicodeString)\"FAIL: Expected afo'ob123\");\n\n    s.truncate(0);\n    delete fmt;\n    delete pat;\n\n    pat = new UnicodeString(\"a''b#\");\n    fmt = new DecimalFormat(*pat, *sym, status);\n    ((NumberFormat*)fmt)->format((int32_t)123, s);\n    logln((UnicodeString)\"Pattern \\\"\" + *pat + \"\\\"\");\n    logln((UnicodeString)\" Format 123 -> \" + escape(s));\n    if (!(s==\"a'b123\"))\n        errln((UnicodeString)\"FAIL: Expected a'b123\");\n    delete fmt;\n    delete pat;\n    delete sym;\n}\n\n/**\n * Test the handling of the currency symbol in patterns.\n */\nvoid\nNumberFormatTest::TestCurrencySign(void)\n{\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols* sym = new DecimalFormatSymbols(Locale::getUS(), status);\n    UnicodeString pat;\n    UChar currency = 0x00A4;\n    if (U_FAILURE(status)) {\n        errcheckln(status, \"Fail to create DecimalFormatSymbols - %s\", u_errorName(status));\n        delete sym;\n        return;\n    }\n    // \"\\xA4#,##0.00;-\\xA4#,##0.00\"\n    pat.append(currency).append(\"#,##0.00;-\").\n        append(currency).append(\"#,##0.00\");\n    DecimalFormat *fmt = new DecimalFormat(pat, *sym, status);\n    UnicodeString s; ((NumberFormat*)fmt)->format(1234.56, s);\n    pat.truncate(0);\n    logln((UnicodeString)\"Pattern \\\"\" + fmt->toPattern(pat) + \"\\\"\");\n    logln((UnicodeString)\" Format \" + 1234.56 + \" -> \" + escape(s));\n    if (s != \"$1,234.56\") dataerrln((UnicodeString)\"FAIL: Expected $1,234.56\");\n    s.truncate(0);\n    ((NumberFormat*)fmt)->format(- 1234.56, s);\n    logln((UnicodeString)\" Format \" + (-1234.56) + \" -> \" + escape(s));\n    if (s != \"-$1,234.56\") dataerrln((UnicodeString)\"FAIL: Expected -$1,234.56\");\n    delete fmt;\n    pat.truncate(0);\n    // \"\\xA4\\xA4 #,##0.00;\\xA4\\xA4 -#,##0.00\"\n    pat.append(currency).append(currency).\n        append(\" #,##0.00;\").\n        append(currency).append(currency).\n        append(\" -#,##0.00\");\n    fmt = new DecimalFormat(pat, *sym, status);\n    s.truncate(0);\n    ((NumberFormat*)fmt)->format(1234.56, s);\n    logln((UnicodeString)\"Pattern \\\"\" + fmt->toPattern(pat) + \"\\\"\");\n    logln((UnicodeString)\" Format \" + 1234.56 + \" -> \" + escape(s));\n    if (s != \"USD 1,234.56\") dataerrln((UnicodeString)\"FAIL: Expected USD 1,234.56\");\n    s.truncate(0);\n    ((NumberFormat*)fmt)->format(-1234.56, s);\n    logln((UnicodeString)\" Format \" + (-1234.56) + \" -> \" + escape(s));\n    if (s != \"USD -1,234.56\") dataerrln((UnicodeString)\"FAIL: Expected USD -1,234.56\");\n    delete fmt;\n    delete sym;\n    if (U_FAILURE(status)) errln((UnicodeString)\"FAIL: Status \" + u_errorName(status));\n}\n\n// -------------------------------------\n\nstatic UChar toHexString(int32_t i) { return (UChar)(i + (i < 10 ? 0x30 : (0x41 - 10))); }\n\nUnicodeString&\nNumberFormatTest::escape(UnicodeString& s)\n{\n    UnicodeString buf;\n    for (int32_t i=0; i<s.length(); ++i)\n    {\n        UChar c = s[(int32_t)i];\n        if (c <= (UChar)0x7F) buf += c;\n        else {\n            buf += (UChar)0x5c; buf += (UChar)0x55;\n            buf += toHexString((c & 0xF000) >> 12);\n            buf += toHexString((c & 0x0F00) >> 8);\n            buf += toHexString((c & 0x00F0) >> 4);\n            buf += toHexString(c & 0x000F);\n        }\n    }\n    return (s = buf);\n}\n\n\n// -------------------------------------\nstatic const char* testCases[][2]= {\n     /* locale ID */  /* expected */\n    {\"ca_ES_PREEURO\", \"\\\\u20A7\\\\u00A01.150\" },\n    {\"de_LU_PREEURO\", \"1,150\\\\u00A0F\" },\n    {\"el_GR_PREEURO\", \"1.150,50\\\\u00A0\\\\u0394\\\\u03C1\\\\u03C7\" },\n    {\"en_BE_PREEURO\", \"1.150,50\\\\u00A0BEF\" },\n    {\"es_ES_PREEURO\", \"1.150\\\\u00A0\\\\u20A7\" },\n    {\"eu_ES_PREEURO\", \"\\\\u20A7\\\\u00A01.150\" },\n    {\"gl_ES_PREEURO\", \"1.150\\\\u00A0\\\\u20A7\" },\n    {\"it_IT_PREEURO\", \"ITL\\\\u00A01.150\" },\n    {\"pt_PT_PREEURO\", \"1,150$50\\\\u00A0\\\\u200B\"}, // per cldrbug 7670\n    {\"en_US@currency=JPY\", \"\\\\u00A51,150\"},\n    {\"en_US@currency=jpy\", \"\\\\u00A51,150\"},\n    {\"en-US-u-cu-jpy\", \"\\\\u00A51,150\"}\n};\n/**\n * Test localized currency patterns.\n */\nvoid\nNumberFormatTest::TestCurrency(void)\n{\n    UErrorCode status = U_ZERO_ERROR;\n    NumberFormat* currencyFmt = NumberFormat::createCurrencyInstance(Locale::getCanadaFrench(), status);\n    if (U_FAILURE(status)) {\n        dataerrln(\"Error calling NumberFormat::createCurrencyInstance()\");\n        return;\n    }\n\n    UnicodeString s; currencyFmt->format(1.50, s);\n    logln((UnicodeString)\"Un pauvre ici a...........\" + s);\n    if (!(s==CharsToUnicodeString(\"1,50\\\\u00A0$\")))\n        errln((UnicodeString)\"FAIL: Expected 1,50<nbsp>$ but got \" + s);\n    delete currencyFmt;\n    s.truncate(0);\n    char loc[256]={0};\n    int len = uloc_canonicalize(\"de_DE_PREEURO\", loc, 256, &status);\n    (void)len;  // Suppress unused variable warning.\n    currencyFmt = NumberFormat::createCurrencyInstance(Locale(loc),status);\n    currencyFmt->format(1.50, s);\n    logln((UnicodeString)\"Un pauvre en Allemagne a..\" + s);\n    if (!(s==CharsToUnicodeString(\"1,50\\\\u00A0DM\")))\n        errln((UnicodeString)\"FAIL: Expected 1,50<nbsp>DM but got \" + s);\n    delete currencyFmt;\n    s.truncate(0);\n    len = uloc_canonicalize(\"fr_FR_PREEURO\", loc, 256, &status);\n    currencyFmt = NumberFormat::createCurrencyInstance(Locale(loc), status);\n    currencyFmt->format(1.50, s);\n    logln((UnicodeString)\"Un pauvre en France a.....\" + s);\n    if (!(s==CharsToUnicodeString(\"1,50\\\\u00A0F\")))\n        errln((UnicodeString)\"FAIL: Expected 1,50<nbsp>F\");\n    delete currencyFmt;\n    if (U_FAILURE(status))\n        errln((UnicodeString)\"FAIL: Status \" + (int32_t)status);\n\n    for(int i=0; i < UPRV_LENGTHOF(testCases); i++){\n        status = U_ZERO_ERROR;\n        const char *localeID = testCases[i][0];\n        UnicodeString expected(testCases[i][1], -1, US_INV);\n        expected = expected.unescape();\n        s.truncate(0);\n        char loc[256]={0};\n        uloc_canonicalize(localeID, loc, 256, &status);\n        currencyFmt = NumberFormat::createCurrencyInstance(Locale(loc), status);\n        if(U_FAILURE(status)){\n            errln(\"Could not create currency formatter for locale %s\",localeID);\n            continue;\n        }\n        currencyFmt->format(1150.50, s);\n        if(s!=expected){\n            errln(UnicodeString(\"FAIL: Expected: \")+expected\n                    + UnicodeString(\" Got: \") + s\n                    + UnicodeString( \" for locale: \")+ UnicodeString(localeID) );\n        }\n        if (U_FAILURE(status)){\n            errln((UnicodeString)\"FAIL: Status \" + (int32_t)status);\n        }\n        delete currencyFmt;\n    }\n}\n\n// -------------------------------------\n\n/**\n * Test the Currency object handling, new as of ICU 2.2.\n */\nvoid NumberFormatTest::TestCurrencyObject() {\n    UErrorCode ec = U_ZERO_ERROR;\n    NumberFormat* fmt =\n        NumberFormat::createCurrencyInstance(Locale::getUS(), ec);\n\n    if (U_FAILURE(ec)) {\n        dataerrln(\"FAIL: getCurrencyInstance(US) - %s\", u_errorName(ec));\n        delete fmt;\n        return;\n    }\n\n    Locale null(\"\", \"\", \"\");\n\n    expectCurrency(*fmt, null, 1234.56, \"$1,234.56\");\n\n    expectCurrency(*fmt, Locale::getFrance(),\n                   1234.56, CharsToUnicodeString(\"\\\\u20AC1,234.56\")); // Euro\n\n    expectCurrency(*fmt, Locale::getJapan(),\n                   1234.56, CharsToUnicodeString(\"\\\\u00A51,235\")); // Yen\n\n    expectCurrency(*fmt, Locale(\"fr\", \"CH\", \"\"),\n                   1234.56, \"CHF 1,234.56\"); // no more 0.05 rounding here, see cldrbug 5548\n\n    expectCurrency(*fmt, Locale::getUS(),\n                   1234.56, \"$1,234.56\");\n\n    delete fmt;\n    fmt = NumberFormat::createCurrencyInstance(Locale::getFrance(), ec);\n\n    if (U_FAILURE(ec)) {\n        errln(\"FAIL: getCurrencyInstance(FRANCE)\");\n        delete fmt;\n        return;\n    }\n\n    expectCurrency(*fmt, null, 1234.56, CharsToUnicodeString(\"1\\\\u202F234,56 \\\\u20AC\"));\n\n    expectCurrency(*fmt, Locale::getJapan(),\n                   1234.56, CharsToUnicodeString(\"1\\\\u202F235 JPY\")); // Yen\n\n    expectCurrency(*fmt, Locale(\"fr\", \"CH\", \"\"),\n                   1234.56, CharsToUnicodeString(\"1\\\\u202F234,56 CHF\")); // no more 0.05 rounding here, see cldrbug 5548\n\n    expectCurrency(*fmt, Locale::getUS(),\n                   1234.56, CharsToUnicodeString(\"1\\\\u202F234,56 $US\"));\n\n    expectCurrency(*fmt, Locale::getFrance(),\n                   1234.56, CharsToUnicodeString(\"1\\\\u202F234,56 \\\\u20AC\")); // Euro\n\n    delete fmt;\n}\n\n// -------------------------------------\n\n/**\n * Do rudimentary testing of parsing.\n */\nvoid\nNumberFormatTest::TestParse(void)\n{\n    UErrorCode status = U_ZERO_ERROR;\n    UnicodeString arg(\"0\");\n    DecimalFormat* format = new DecimalFormat(\"00\", status);\n    //try {\n        Formattable n; format->parse(arg, n, status);\n        logln((UnicodeString)\"parse(\" + arg + \") = \" + n.getLong());\n        if (n.getType() != Formattable::kLong ||\n            n.getLong() != 0) errln((UnicodeString)\"FAIL: Expected 0\");\n    delete format;\n    if (U_FAILURE(status)) errcheckln(status, (UnicodeString)\"FAIL: Status \" + u_errorName(status));\n    //}\n    //catch(Exception e) {\n    //    errln((UnicodeString)\"Exception caught: \" + e);\n    //}\n}\n\n// -------------------------------------\n\nstatic const char *lenientAffixTestCases[] = {\n        \"(1)\",\n        \"( 1)\",\n        \"(1 )\",\n        \"( 1 )\"\n};\n\nstatic const char *lenientMinusTestCases[] = {\n    \"-5\",\n    \"\\\\u22125\",\n    \"\\\\u27965\"\n};\n\nstatic const char *lenientCurrencyTestCases[] = {\n        \"$1,000\",\n        \"$ 1,000\",\n        \"$1000\",\n        \"$ 1000\",\n        \"$1 000.00\",\n        \"$ 1 000.00\",\n        \"$ 1\\\\u00A0000.00\",\n        \"1000.00\"\n};\n\n// changed from () to - per cldrbug 5674\nstatic const char *lenientNegativeCurrencyTestCases[] = {\n        \"-$1,000\",\n        \"-$ 1,000\",\n        \"-$1000\",\n        \"-$ 1000\",\n        \"-$1 000.00\",\n        \"-$ 1 000.00\",\n        \"- $ 1,000.00 \",\n        \"-$ 1\\\\u00A0000.00\",\n        \"-1000.00\"\n};\n\nstatic const char *lenientPercentTestCases[] = {\n        \"25%\",\n        \" 25%\",\n        \" 25 %\",\n    \t\"25 %\",\n\t\t\"25\\\\u00A0%\",\n\t\t\"25\"\n};\n\nstatic const char *lenientNegativePercentTestCases[] = {\n\t\t\"-25%\",\n\t\t\" -25%\",\n\t\t\" - 25%\",\n\t\t\"- 25 %\",\n\t\t\" - 25 %\",\n\t\t\"-25 %\",\n\t\t\"-25\\\\u00A0%\",\n\t\t\"-25\",\n\t\t\"- 25\"\n};\n\nstatic const char *strictFailureTestCases[] = {\n\t\t\" 1000\",\n\t\t\"10,00\",\n\t\t\"1,000,.0\"\n};\n\n/**\n * Test lenient parsing.\n */\nvoid\nNumberFormatTest::TestLenientParse(void)\n{\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat *format = new DecimalFormat(\"(#,##0)\", status);\n    Formattable n;\n\n    if (format == NULL || U_FAILURE(status)) {\n        dataerrln(\"Unable to create DecimalFormat (#,##0) - %s\", u_errorName(status));\n    } else {\n        format->setLenient(TRUE);\n        for (int32_t t = 0; t < UPRV_LENGTHOF (lenientAffixTestCases); t += 1) {\n        \tUnicodeString testCase = ctou(lenientAffixTestCases[t]);\n\n            format->parse(testCase, n, status);\n            logln((UnicodeString)\"parse(\" + testCase + \") = \" + n.getLong());\n\n            if (U_FAILURE(status) || n.getType() != Formattable::kLong ||\n            \tn.getLong() != 1) {\n            \tdataerrln((UnicodeString)\"Lenient parse failed for \\\"\" + (UnicodeString) lenientAffixTestCases[t]\n                      + (UnicodeString) \"\\\"; error code = \" + u_errorName(status));\n            \tstatus = U_ZERO_ERROR;\n            }\n       }\n       delete format;\n    }\n\n    Locale en_US(\"en_US\");\n    Locale sv_SE(\"sv_SE\");\n\n    NumberFormat *mFormat = NumberFormat::createInstance(sv_SE, UNUM_DECIMAL, status);\n\n    if (mFormat == NULL || U_FAILURE(status)) {\n        dataerrln(\"Unable to create NumberFormat (sv_SE, UNUM_DECIMAL) - %s\", u_errorName(status));\n    } else {\n        mFormat->setLenient(TRUE);\n        for (int32_t t = 0; t < UPRV_LENGTHOF(lenientMinusTestCases); t += 1) {\n            UnicodeString testCase = ctou(lenientMinusTestCases[t]);\n\n            mFormat->parse(testCase, n, status);\n            logln((UnicodeString)\"parse(\" + testCase + \") = \" + n.getLong());\n\n            if (U_FAILURE(status) || n.getType() != Formattable::kLong || n.getLong() != -5) {\n                errln((UnicodeString)\"Lenient parse failed for \\\"\" + (UnicodeString) lenientMinusTestCases[t]\n                      + (UnicodeString) \"\\\"; error code = \" + u_errorName(status));\n                status = U_ZERO_ERROR;\n            }\n        }\n        delete mFormat;\n    }\n\n    mFormat = NumberFormat::createInstance(en_US, UNUM_DECIMAL, status);\n\n    if (mFormat == NULL || U_FAILURE(status)) {\n        dataerrln(\"Unable to create NumberFormat (en_US, UNUM_DECIMAL) - %s\", u_errorName(status));\n    } else {\n        mFormat->setLenient(TRUE);\n        for (int32_t t = 0; t < UPRV_LENGTHOF(lenientMinusTestCases); t += 1) {\n            UnicodeString testCase = ctou(lenientMinusTestCases[t]);\n\n            mFormat->parse(testCase, n, status);\n            logln((UnicodeString)\"parse(\" + testCase + \") = \" + n.getLong());\n\n            if (U_FAILURE(status) || n.getType() != Formattable::kLong || n.getLong() != -5) {\n                errln((UnicodeString)\"Lenient parse failed for \\\"\" + (UnicodeString) lenientMinusTestCases[t]\n                      + (UnicodeString) \"\\\"; error code = \" + u_errorName(status));\n                status = U_ZERO_ERROR;\n            }\n        }\n        delete mFormat;\n    }\n\n    NumberFormat *cFormat = NumberFormat::createInstance(en_US, UNUM_CURRENCY, status);\n\n    if (cFormat == NULL || U_FAILURE(status)) {\n        dataerrln(\"Unable to create NumberFormat (en_US, UNUM_CURRENCY) - %s\", u_errorName(status));\n    } else {\n        cFormat->setLenient(TRUE);\n        for (int32_t t = 0; t < UPRV_LENGTHOF (lenientCurrencyTestCases); t += 1) {\n        \tUnicodeString testCase = ctou(lenientCurrencyTestCases[t]);\n\n            cFormat->parse(testCase, n, status);\n            logln((UnicodeString)\"parse(\" + testCase + \") = \" + n.getLong());\n\n            if (U_FAILURE(status) ||n.getType() != Formattable::kLong ||\n            \tn.getLong() != 1000) {\n            \terrln((UnicodeString)\"Lenient parse failed for \\\"\" + (UnicodeString) lenientCurrencyTestCases[t]\n                      + (UnicodeString) \"\\\"; error code = \" + u_errorName(status));\n            \tstatus = U_ZERO_ERROR;\n            }\n        }\n\n        for (int32_t t = 0; t < UPRV_LENGTHOF (lenientNegativeCurrencyTestCases); t += 1) {\n        \tUnicodeString testCase = ctou(lenientNegativeCurrencyTestCases[t]);\n\n            cFormat->parse(testCase, n, status);\n            logln((UnicodeString)\"parse(\" + testCase + \") = \" + n.getLong());\n\n            if (U_FAILURE(status) ||n.getType() != Formattable::kLong ||\n            \tn.getLong() != -1000) {\n            \terrln((UnicodeString)\"Lenient parse failed for \\\"\" + (UnicodeString) lenientNegativeCurrencyTestCases[t]\n                      + (UnicodeString) \"\\\"; error code = \" + u_errorName(status));\n            \tstatus = U_ZERO_ERROR;\n            }\n        }\n\n        delete cFormat;\n    }\n\n    NumberFormat *pFormat = NumberFormat::createPercentInstance(en_US, status);\n\n    if (pFormat == NULL || U_FAILURE(status)) {\n        dataerrln(\"Unable to create NumberFormat::createPercentInstance (en_US) - %s\", u_errorName(status));\n    } else {\n        pFormat->setLenient(TRUE);\n        for (int32_t t = 0; t < UPRV_LENGTHOF (lenientPercentTestCases); t += 1) {\n        \tUnicodeString testCase = ctou(lenientPercentTestCases[t]);\n\n        \tpFormat->parse(testCase, n, status);\n            logln((UnicodeString)\"parse(\" + testCase + \") = \" + n.getDouble());\n\n            if (U_FAILURE(status) ||n.getType() != Formattable::kDouble ||\n            \tn.getDouble() != 0.25) {\n            \terrln((UnicodeString)\"Lenient parse failed for \\\"\" + (UnicodeString) lenientPercentTestCases[t]\n                      + (UnicodeString) \"\\\"; error code = \" + u_errorName(status)\n                      + \"; got: \" + n.getDouble(status));\n            \tstatus = U_ZERO_ERROR;\n            }\n        }\n\n        for (int32_t t = 0; t < UPRV_LENGTHOF (lenientNegativePercentTestCases); t += 1) {\n        \tUnicodeString testCase = ctou(lenientNegativePercentTestCases[t]);\n\n        \tpFormat->parse(testCase, n, status);\n            logln((UnicodeString)\"parse(\" + testCase + \") = \" + n.getDouble());\n\n            if (U_FAILURE(status) ||n.getType() != Formattable::kDouble ||\n            \tn.getDouble() != -0.25) {\n            \terrln((UnicodeString)\"Lenient parse failed for \\\"\" + (UnicodeString) lenientNegativePercentTestCases[t]\n                      + (UnicodeString) \"\\\"; error code = \" + u_errorName(status)\n                      + \"; got: \" + n.getDouble(status));\n            \tstatus = U_ZERO_ERROR;\n            }\n        }\n\n        delete pFormat;\n    }\n\n   // Test cases that should fail with a strict parse and pass with a\n   // lenient parse.\n   NumberFormat *nFormat = NumberFormat::createInstance(en_US, status);\n\n   if (nFormat == NULL || U_FAILURE(status)) {\n       dataerrln(\"Unable to create NumberFormat (en_US) - %s\", u_errorName(status));\n   } else {\n       // first, make sure that they fail with a strict parse\n       for (int32_t t = 0; t < UPRV_LENGTHOF(strictFailureTestCases); t += 1) {\n\t       UnicodeString testCase = ctou(strictFailureTestCases[t]);\n\n\t       nFormat->parse(testCase, n, status);\n\t       logln((UnicodeString)\"parse(\" + testCase + \") = \" + n.getLong());\n\n\t       if (! U_FAILURE(status)) {\n\t\t       errln((UnicodeString)\"Strict Parse succeeded for \\\"\" + (UnicodeString) strictFailureTestCases[t]\n                     + (UnicodeString) \"\\\"; error code = \" + u_errorName(status));\n\t       }\n\n\t       status = U_ZERO_ERROR;\n       }\n\n       // then, make sure that they pass with a lenient parse\n       nFormat->setLenient(TRUE);\n       for (int32_t t = 0; t < UPRV_LENGTHOF(strictFailureTestCases); t += 1) {\n\t       UnicodeString testCase = ctou(strictFailureTestCases[t]);\n\n\t       nFormat->parse(testCase, n, status);\n\t       logln((UnicodeString)\"parse(\" + testCase + \") = \" + n.getLong());\n\n\t       if (U_FAILURE(status) ||n.getType() != Formattable::kLong ||\n\t            \tn.getLong() != 1000) {\n\t\t       errln((UnicodeString)\"Lenient parse failed for \\\"\" + (UnicodeString) strictFailureTestCases[t]\n                     + (UnicodeString) \"\\\"; error code = \" + u_errorName(status));\n\t\t       status = U_ZERO_ERROR;\n\t       }\n       }\n\n       delete nFormat;\n   }\n}\n\n// -------------------------------------\n\n/**\n * Test proper rounding by the format method.\n */\nvoid\nNumberFormatTest::TestRounding487(void)\n{\n    UErrorCode status = U_ZERO_ERROR;\n    NumberFormat *nf = NumberFormat::createInstance(status);\n    if (U_FAILURE(status)) {\n        dataerrln(\"Error calling NumberFormat::createInstance()\");\n        return;\n    }\n\n    roundingTest(*nf, 0.00159999, 4, \"0.0016\");\n    roundingTest(*nf, 0.00995, 4, \"0.01\");\n\n    roundingTest(*nf, 12.3995, 3, \"12.4\");\n\n    roundingTest(*nf, 12.4999, 0, \"12\");\n    roundingTest(*nf, - 19.5, 0, \"-20\");\n    delete nf;\n    if (U_FAILURE(status)) errln((UnicodeString)\"FAIL: Status \" + (int32_t)status);\n}\n\n/**\n * Test the functioning of the secondary grouping value.\n */\nvoid NumberFormatTest::TestSecondaryGrouping(void) {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols US(Locale::getUS(), status);\n    CHECK(status, \"DecimalFormatSymbols ct\");\n\n    DecimalFormat f(\"#,##,###\", US, status);\n    CHECK(status, \"DecimalFormat ct\");\n\n    expect2(f, (int32_t)123456789L, \"12,34,56,789\");\n    expectPat(f, \"#,##,##0\");\n    f.applyPattern(\"#,###\", status);\n    CHECK(status, \"applyPattern\");\n\n    f.setSecondaryGroupingSize(4);\n    expect2(f, (int32_t)123456789L, \"12,3456,789\");\n    expectPat(f, \"#,####,##0\");\n    NumberFormat *g = NumberFormat::createInstance(Locale(\"hi\", \"IN\"), status);\n    CHECK_DATA(status, \"createInstance(hi_IN)\");\n\n    UnicodeString out;\n    int32_t l = (int32_t)1876543210L;\n    g->format(l, out);\n    delete g;\n    // expect \"1,87,65,43,210\", but with Hindi digits\n    //         01234567890123\n    UBool ok = TRUE;\n    if (out.length() != 14) {\n        ok = FALSE;\n    } else {\n        for (int32_t i=0; i<out.length(); ++i) {\n            UBool expectGroup = FALSE;\n            switch (i) {\n            case 1:\n            case 4:\n            case 7:\n            case 10:\n                expectGroup = TRUE;\n                break;\n            }\n            // Later -- fix this to get the actual grouping\n            // character from the resource bundle.\n            UBool isGroup = (out.charAt(i) == 0x002C);\n            if (isGroup != expectGroup) {\n                ok = FALSE;\n                break;\n            }\n        }\n    }\n    if (!ok) {\n        errln((UnicodeString)\"FAIL  Expected \" + l +\n              \" x hi_IN -> \\\"1,87,65,43,210\\\" (with Hindi digits), got \\\"\" +\n              escape(out) + \"\\\"\");\n    } else {\n        logln((UnicodeString)\"Ok    \" + l +\n              \" x hi_IN -> \\\"\" +\n              escape(out) + \"\\\"\");\n    }\n}\n\nvoid NumberFormatTest::TestWhiteSpaceParsing(void) {\n    UErrorCode ec = U_ZERO_ERROR;\n    DecimalFormatSymbols US(Locale::getUS(), ec);\n    DecimalFormat fmt(\"a  b#0c  \", US, ec);\n    if (U_FAILURE(ec)) {\n        errcheckln(ec, \"FAIL: Constructor - %s\", u_errorName(ec));\n        return;\n    }\n    // From ICU 62, flexible whitespace needs lenient mode\n    fmt.setLenient(TRUE);\n    int32_t n = 1234;\n    expect(fmt, \"a b1234c \", n);\n    expect(fmt, \"a   b1234c   \", n);\n}\n\n/**\n * Test currencies whose display name is a ChoiceFormat.\n */\nvoid NumberFormatTest::TestComplexCurrency() {\n\n//    UErrorCode ec = U_ZERO_ERROR;\n//    Locale loc(\"kn\", \"IN\", \"\");\n//    NumberFormat* fmt = NumberFormat::createCurrencyInstance(loc, ec);\n//    if (U_SUCCESS(ec)) {\n//        expect2(*fmt, 1.0, CharsToUnicodeString(\"Re.\\\\u00A01.00\"));\n//        Use .00392625 because that's 2^-8.  Any value less than 0.005 is fine.\n//        expect(*fmt, 1.00390625, CharsToUnicodeString(\"Re.\\\\u00A01.00\")); // tricky\n//        expect2(*fmt, 12345678.0, CharsToUnicodeString(\"Rs.\\\\u00A01,23,45,678.00\"));\n//        expect2(*fmt, 0.5, CharsToUnicodeString(\"Rs.\\\\u00A00.50\"));\n//        expect2(*fmt, -1.0, CharsToUnicodeString(\"-Re.\\\\u00A01.00\"));\n//        expect2(*fmt, -10.0, CharsToUnicodeString(\"-Rs.\\\\u00A010.00\"));\n//    } else {\n//        errln(\"FAIL: getCurrencyInstance(kn_IN)\");\n//    }\n//    delete fmt;\n\n}\n\n// -------------------------------------\n\nvoid\nNumberFormatTest::roundingTest(NumberFormat& nf, double x, int32_t maxFractionDigits, const char* expected)\n{\n    nf.setMaximumFractionDigits(maxFractionDigits);\n    UnicodeString out; nf.format(x, out);\n    logln((UnicodeString)\"\" + x + \" formats with \" + maxFractionDigits + \" fractional digits to \" + out);\n    if (!(out==expected)) errln((UnicodeString)\"FAIL: Expected \" + expected);\n}\n\n/**\n * Upgrade to alphaWorks\n */\nvoid NumberFormatTest::TestExponent(void) {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols US(Locale::getUS(), status);\n    CHECK(status, \"DecimalFormatSymbols constructor\");\n    DecimalFormat fmt1(UnicodeString(\"0.###E0\"), US, status);\n    CHECK(status, \"DecimalFormat(0.###E0)\");\n    DecimalFormat fmt2(UnicodeString(\"0.###E+0\"), US, status);\n    CHECK(status, \"DecimalFormat(0.###E+0)\");\n    int32_t n = 1234;\n    expect2(fmt1, n, \"1.234E3\");\n    expect2(fmt2, n, \"1.234E+3\");\n    expect(fmt1, \"1.234E+3\", n); // Either format should parse \"E+3\"\n}\n\n/**\n * Upgrade to alphaWorks\n */\nvoid NumberFormatTest::TestScientific(void) {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols US(Locale::getUS(), status);\n    CHECK(status, \"DecimalFormatSymbols constructor\");\n\n    // Test pattern round-trip\n    const char* PAT[] = { \"#E0\", \"0.####E0\", \"00.000E00\", \"##0.####E000\",\n                          \"0.###E0;[0.###E0]\" };\n    int32_t PAT_length = UPRV_LENGTHOF(PAT);\n    int32_t DIGITS[] = {\n        // min int, max int, min frac, max frac\n        1, 1, 0, 0, // \"#E0\"\n        1, 1, 0, 4, // \"0.####E0\"\n        2, 2, 3, 3, // \"00.000E00\"\n        1, 3, 0, 4, // \"##0.####E000\"\n        1, 1, 0, 3, // \"0.###E0;[0.###E0]\"\n    };\n    for (int32_t i=0; i<PAT_length; ++i) {\n        UnicodeString pat(PAT[i]);\n        DecimalFormat df(pat, US, status);\n        CHECK(status, \"DecimalFormat constructor\");\n        UnicodeString pat2;\n        df.toPattern(pat2);\n        if (pat == pat2) {\n            logln(UnicodeString(\"Ok   Pattern rt \\\"\") +\n                  pat + \"\\\" -> \\\"\" +\n                  pat2 + \"\\\"\");\n        } else {\n            errln(UnicodeString(\"FAIL Pattern rt \\\"\") +\n                  pat + \"\\\" -> \\\"\" +\n                  pat2 + \"\\\"\");\n        }\n        // Make sure digit counts match what we expect\n        if (df.getMinimumIntegerDigits() != DIGITS[4*i] ||\n            df.getMaximumIntegerDigits() != DIGITS[4*i+1] ||\n            df.getMinimumFractionDigits() != DIGITS[4*i+2] ||\n            df.getMaximumFractionDigits() != DIGITS[4*i+3]) {\n            errln(UnicodeString(\"FAIL \\\"\" + pat +\n                                \"\\\" min/max int; min/max frac = \") +\n                  df.getMinimumIntegerDigits() + \"/\" +\n                  df.getMaximumIntegerDigits() + \";\" +\n                  df.getMinimumFractionDigits() + \"/\" +\n                  df.getMaximumFractionDigits() + \", expect \" +\n                  DIGITS[4*i] + \"/\" +\n                  DIGITS[4*i+1] + \";\" +\n                  DIGITS[4*i+2] + \"/\" +\n                  DIGITS[4*i+3]);\n        }\n    }\n\n\n    // Test the constructor for default locale. We have to\n    // manually set the default locale, as there is no\n    // guarantee that the default locale has the same\n    // scientific format.\n    Locale def = Locale::getDefault();\n    Locale::setDefault(Locale::getUS(), status);\n    expect2(NumberFormat::createScientificInstance(status),\n           12345.678901,\n           \"1.2345678901E4\", status);\n    Locale::setDefault(def, status);\n\n    expect2(new DecimalFormat(\"#E0\", US, status),\n           12345.0,\n           \"1.2345E4\", status);\n    expect(new DecimalFormat(\"0E0\", US, status),\n           12345.0,\n           \"1E4\", status);\n    expect2(NumberFormat::createScientificInstance(Locale::getUS(), status),\n           12345.678901,\n           \"1.2345678901E4\", status);\n    expect(new DecimalFormat(\"##0.###E0\", US, status),\n           12345.0,\n           \"12.34E3\", status);\n    expect(new DecimalFormat(\"##0.###E0\", US, status),\n           12345.00001,\n           \"12.35E3\", status);\n    expect2(new DecimalFormat(\"##0.####E0\", US, status),\n           (int32_t) 12345,\n           \"12.345E3\", status);\n    expect2(NumberFormat::createScientificInstance(Locale::getFrance(), status),\n           12345.678901,\n           \"1,2345678901E4\", status);\n    expect(new DecimalFormat(\"##0.####E0\", US, status),\n           789.12345e-9,\n           \"789.12E-9\", status);\n    expect2(new DecimalFormat(\"##0.####E0\", US, status),\n           780.e-9,\n           \"780E-9\", status);\n    expect(new DecimalFormat(\".###E0\", US, status),\n           45678.0,\n           \".457E5\", status);\n    expect2(new DecimalFormat(\".###E0\", US, status),\n           (int32_t) 0,\n           \".0E0\", status);\n    /*\n    expect(new DecimalFormat[] { new DecimalFormat(\"#E0\", US),\n                                 new DecimalFormat(\"##E0\", US),\n                                 new DecimalFormat(\"####E0\", US),\n                                 new DecimalFormat(\"0E0\", US),\n                                 new DecimalFormat(\"00E0\", US),\n                                 new DecimalFormat(\"000E0\", US),\n                               },\n           new Long(45678000),\n           new String[] { \"4.5678E7\",\n                          \"45.678E6\",\n                          \"4567.8E4\",\n                          \"5E7\",\n                          \"46E6\",\n                          \"457E5\",\n                        }\n           );\n    !\n    ! Unroll this test into individual tests below...\n    !\n    */\n    expect2(new DecimalFormat(\"#E0\", US, status),\n           (int32_t) 45678000, \"4.5678E7\", status);\n    expect2(new DecimalFormat(\"##E0\", US, status),\n           (int32_t) 45678000, \"45.678E6\", status);\n    expect2(new DecimalFormat(\"####E0\", US, status),\n           (int32_t) 45678000, \"4567.8E4\", status);\n    expect(new DecimalFormat(\"0E0\", US, status),\n           (int32_t) 45678000, \"5E7\", status);\n    expect(new DecimalFormat(\"00E0\", US, status),\n           (int32_t) 45678000, \"46E6\", status);\n    expect(new DecimalFormat(\"000E0\", US, status),\n           (int32_t) 45678000, \"457E5\", status);\n    /*\n    expect(new DecimalFormat(\"###E0\", US, status),\n           new Object[] { new Double(0.0000123), \"12.3E-6\",\n                          new Double(0.000123), \"123E-6\",\n                          new Double(0.00123), \"1.23E-3\",\n                          new Double(0.0123), \"12.3E-3\",\n                          new Double(0.123), \"123E-3\",\n                          new Double(1.23), \"1.23E0\",\n                          new Double(12.3), \"12.3E0\",\n                          new Double(123), \"123E0\",\n                          new Double(1230), \"1.23E3\",\n                         });\n    !\n    ! Unroll this test into individual tests below...\n    !\n    */\n    expect2(new DecimalFormat(\"###E0\", US, status),\n           0.0000123, \"12.3E-6\", status);\n    expect2(new DecimalFormat(\"###E0\", US, status),\n           0.000123, \"123E-6\", status);\n    expect2(new DecimalFormat(\"###E0\", US, status),\n           0.00123, \"1.23E-3\", status);\n    expect2(new DecimalFormat(\"###E0\", US, status),\n           0.0123, \"12.3E-3\", status);\n    expect2(new DecimalFormat(\"###E0\", US, status),\n           0.123, \"123E-3\", status);\n    expect2(new DecimalFormat(\"###E0\", US, status),\n           1.23, \"1.23E0\", status);\n    expect2(new DecimalFormat(\"###E0\", US, status),\n           12.3, \"12.3E0\", status);\n    expect2(new DecimalFormat(\"###E0\", US, status),\n           123.0, \"123E0\", status);\n    expect2(new DecimalFormat(\"###E0\", US, status),\n           1230.0, \"1.23E3\", status);\n    /*\n    expect(new DecimalFormat(\"0.#E+00\", US, status),\n           new Object[] { new Double(0.00012), \"1.2E-04\",\n                          new Long(12000),     \"1.2E+04\",\n                         });\n    !\n    ! Unroll this test into individual tests below...\n    !\n    */\n    expect2(new DecimalFormat(\"0.#E+00\", US, status),\n           0.00012, \"1.2E-04\", status);\n    expect2(new DecimalFormat(\"0.#E+00\", US, status),\n           (int32_t) 12000, \"1.2E+04\", status);\n}\n\n/**\n * Upgrade to alphaWorks\n */\nvoid NumberFormatTest::TestPad(void) {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols US(Locale::getUS(), status);\n    CHECK(status, \"DecimalFormatSymbols constructor\");\n\n    expect2(new DecimalFormat(\"*^##.##\", US, status),\n           int32_t(0), \"^^^^0\", status);\n    expect2(new DecimalFormat(\"*^##.##\", US, status),\n           -1.3, \"^-1.3\", status);\n    expect2(new DecimalFormat(\"##0.0####E0*_ 'g-m/s^2'\", US, status),\n           int32_t(0), \"0.0E0______ g-m/s^2\", status);\n    expect(new DecimalFormat(\"##0.0####E0*_ 'g-m/s^2'\", US, status),\n           1.0/3, \"333.333E-3_ g-m/s^2\", status);\n    expect2(new DecimalFormat(\"##0.0####*_ 'g-m/s^2'\", US, status),\n           int32_t(0), \"0.0______ g-m/s^2\", status);\n    expect(new DecimalFormat(\"##0.0####*_ 'g-m/s^2'\", US, status),\n           1.0/3, \"0.33333__ g-m/s^2\", status);\n\n    // Test padding before a sign\n    const char *formatStr = \"*x#,###,###,##0.0#;*x(###,###,##0.0#)\";\n    expect2(new DecimalFormat(formatStr, US, status),\n           int32_t(-10),  \"xxxxxxxxxx(10.0)\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           int32_t(-1000),\"xxxxxxx(1,000.0)\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           int32_t(-1000000),\"xxx(1,000,000.0)\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           -100.37,       \"xxxxxxxx(100.37)\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           -10456.37,     \"xxxxx(10,456.37)\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           -1120456.37,   \"xx(1,120,456.37)\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           -112045600.37, \"(112,045,600.37)\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           -1252045600.37,\"(1,252,045,600.37)\", status);\n\n    expect2(new DecimalFormat(formatStr, US, status),\n           int32_t(10),  \"xxxxxxxxxxxx10.0\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           int32_t(1000),\"xxxxxxxxx1,000.0\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           int32_t(1000000),\"xxxxx1,000,000.0\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           100.37,       \"xxxxxxxxxx100.37\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           10456.37,     \"xxxxxxx10,456.37\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           1120456.37,   \"xxxx1,120,456.37\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           112045600.37, \"xx112,045,600.37\", status);\n    expect2(new DecimalFormat(formatStr, US, status),\n           10252045600.37,\"10,252,045,600.37\", status);\n\n\n    // Test padding between a sign and a number\n    const char *formatStr2 = \"#,###,###,##0.0#*x;(###,###,##0.0#*x)\";\n    expect2(new DecimalFormat(formatStr2, US, status),\n           int32_t(-10),  \"(10.0xxxxxxxxxx)\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           int32_t(-1000),\"(1,000.0xxxxxxx)\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           int32_t(-1000000),\"(1,000,000.0xxx)\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           -100.37,       \"(100.37xxxxxxxx)\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           -10456.37,     \"(10,456.37xxxxx)\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           -1120456.37,   \"(1,120,456.37xx)\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           -112045600.37, \"(112,045,600.37)\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           -1252045600.37,\"(1,252,045,600.37)\", status);\n\n    expect2(new DecimalFormat(formatStr2, US, status),\n           int32_t(10),  \"10.0xxxxxxxxxxxx\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           int32_t(1000),\"1,000.0xxxxxxxxx\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           int32_t(1000000),\"1,000,000.0xxxxx\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           100.37,       \"100.37xxxxxxxxxx\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           10456.37,     \"10,456.37xxxxxxx\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           1120456.37,   \"1,120,456.37xxxx\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           112045600.37, \"112,045,600.37xx\", status);\n    expect2(new DecimalFormat(formatStr2, US, status),\n           10252045600.37,\"10,252,045,600.37\", status);\n\n    //testing the setPadCharacter(UnicodeString) and getPadCharacterString()\n    DecimalFormat fmt(\"#\", US, status);\n    CHECK(status, \"DecimalFormat constructor\");\n    UnicodeString padString(\"P\");\n    fmt.setPadCharacter(padString);\n    expectPad(fmt, \"*P##.##\", DecimalFormat::kPadBeforePrefix, 5, padString);\n    fmt.setPadCharacter((UnicodeString)\"^\");\n    expectPad(fmt, \"*^#\", DecimalFormat::kPadBeforePrefix, 1, (UnicodeString)\"^\");\n    //commented untill implementation is complete\n  /*  fmt.setPadCharacter((UnicodeString)\"^^^\");\n    expectPad(fmt, \"*^^^#\", DecimalFormat::kPadBeforePrefix, 3, (UnicodeString)\"^^^\");\n    padString.remove();\n    padString.append((UChar)0x0061);\n    padString.append((UChar)0x0302);\n    fmt.setPadCharacter(padString);\n    UChar patternChars[]={0x002a, 0x0061, 0x0302, 0x0061, 0x0302, 0x0023, 0x0000};\n    UnicodeString pattern(patternChars);\n    expectPad(fmt, pattern , DecimalFormat::kPadBeforePrefix, 4, padString);\n */\n\n}\n\n/**\n * Upgrade to alphaWorks\n */\nvoid NumberFormatTest::TestPatterns2(void) {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols US(Locale::getUS(), status);\n    CHECK(status, \"DecimalFormatSymbols constructor\");\n\n    DecimalFormat fmt(\"#\", US, status);\n    CHECK(status, \"DecimalFormat constructor\");\n\n    UChar hat = 0x005E; /*^*/\n\n    expectPad(fmt, \"*^#\", DecimalFormat::kPadBeforePrefix, 1, hat);\n    expectPad(fmt, \"$*^#\", DecimalFormat::kPadAfterPrefix, 2, hat);\n    expectPad(fmt, \"#*^\", DecimalFormat::kPadBeforeSuffix, 1, hat);\n    expectPad(fmt, \"#$*^\", DecimalFormat::kPadAfterSuffix, 2, hat);\n    expectPad(fmt, \"$*^$#\", ILLEGAL);\n    expectPad(fmt, \"#$*^$\", ILLEGAL);\n    expectPad(fmt, \"'pre'#,##0*x'post'\", DecimalFormat::kPadBeforeSuffix,\n              12, (UChar)0x0078 /*x*/);\n    expectPad(fmt, \"''#0*x\", DecimalFormat::kPadBeforeSuffix,\n              3, (UChar)0x0078 /*x*/);\n    expectPad(fmt, \"'I''ll'*a###.##\", DecimalFormat::kPadAfterPrefix,\n              10, (UChar)0x0061 /*a*/);\n\n    fmt.applyPattern(\"AA#,##0.00ZZ\", status);\n    CHECK(status, \"applyPattern\");\n    fmt.setPadCharacter(hat);\n\n    fmt.setFormatWidth(10);\n\n    fmt.setPadPosition(DecimalFormat::kPadBeforePrefix);\n    expectPat(fmt, \"*^AA#,##0.00ZZ\");\n\n    fmt.setPadPosition(DecimalFormat::kPadBeforeSuffix);\n    expectPat(fmt, \"AA#,##0.00*^ZZ\");\n\n    fmt.setPadPosition(DecimalFormat::kPadAfterSuffix);\n    expectPat(fmt, \"AA#,##0.00ZZ*^\");\n\n    //            12  3456789012\n    UnicodeString exp(\"AA*^#,##0.00ZZ\", \"\");\n    fmt.setFormatWidth(12);\n    fmt.setPadPosition(DecimalFormat::kPadAfterPrefix);\n    expectPat(fmt, exp);\n\n    fmt.setFormatWidth(13);\n    //              12  34567890123\n    expectPat(fmt, \"AA*^##,##0.00ZZ\");\n\n    fmt.setFormatWidth(14);\n    //              12  345678901234\n    expectPat(fmt, \"AA*^###,##0.00ZZ\");\n\n    fmt.setFormatWidth(15);\n    //              12  3456789012345\n    expectPat(fmt, \"AA*^####,##0.00ZZ\"); // This is the interesting case\n\n    fmt.setFormatWidth(16);\n    //              12  34567890123456\n    expectPat(fmt, \"AA*^#####,##0.00ZZ\");\n}\n\nvoid NumberFormatTest::TestSurrogateSupport(void) {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols custom(Locale::getUS(), status);\n    CHECK(status, \"DecimalFormatSymbols constructor\");\n\n    custom.setSymbol(DecimalFormatSymbols::kDecimalSeparatorSymbol, \"decimal\");\n    custom.setSymbol(DecimalFormatSymbols::kPlusSignSymbol, \"plus\");\n    custom.setSymbol(DecimalFormatSymbols::kMinusSignSymbol, \" minus \");\n    custom.setSymbol(DecimalFormatSymbols::kExponentialSymbol, \"exponent\");\n\n    UnicodeString patternStr(\"*\\\\U00010000##.##\", \"\");\n    patternStr = patternStr.unescape();\n    UnicodeString expStr(\"\\\\U00010000\\\\U00010000\\\\U00010000\\\\U000100000\", \"\");\n    expStr = expStr.unescape();\n    expect2(new DecimalFormat(patternStr, custom, status),\n           int32_t(0), expStr, status);\n\n    status = U_ZERO_ERROR;\n    expect2(new DecimalFormat(\"*^##.##\", custom, status),\n           int32_t(0), \"^^^^0\", status);\n    status = U_ZERO_ERROR;\n    expect2(new DecimalFormat(\"##.##\", custom, status),\n           -1.3, \" minus 1decimal3\", status);\n    status = U_ZERO_ERROR;\n    expect2(new DecimalFormat(\"##0.0####E0 'g-m/s^2'\", custom, status),\n           int32_t(0), \"0decimal0exponent0 g-m/s^2\", status);\n    status = U_ZERO_ERROR;\n    expect(new DecimalFormat(\"##0.0####E0 'g-m/s^2'\", custom, status),\n           1.0/3, \"333decimal333exponent minus 3 g-m/s^2\", status);\n    status = U_ZERO_ERROR;\n    expect2(new DecimalFormat(\"##0.0#### 'g-m/s^2'\", custom, status),\n           int32_t(0), \"0decimal0 g-m/s^2\", status);\n    status = U_ZERO_ERROR;\n    expect(new DecimalFormat(\"##0.0#### 'g-m/s^2'\", custom, status),\n           1.0/3, \"0decimal33333 g-m/s^2\", status);\n\n    UnicodeString zero((UChar32)0x10000);\n    UnicodeString one((UChar32)0x10001);\n    UnicodeString two((UChar32)0x10002);\n    UnicodeString five((UChar32)0x10005);\n    custom.setSymbol(DecimalFormatSymbols::kZeroDigitSymbol, zero);\n    custom.setSymbol(DecimalFormatSymbols::kOneDigitSymbol, one);\n    custom.setSymbol(DecimalFormatSymbols::kTwoDigitSymbol, two);\n    custom.setSymbol(DecimalFormatSymbols::kFiveDigitSymbol, five);\n    expStr = UnicodeString(\"\\\\U00010001decimal\\\\U00010002\\\\U00010005\\\\U00010000\", \"\");\n    expStr = expStr.unescape();\n    status = U_ZERO_ERROR;\n    expect2(new DecimalFormat(\"##0.000\", custom, status),\n           1.25, expStr, status);\n\n    custom.setSymbol(DecimalFormatSymbols::kZeroDigitSymbol, (UChar)0x30);\n    custom.setSymbol(DecimalFormatSymbols::kCurrencySymbol, \"units of money\");\n    custom.setSymbol(DecimalFormatSymbols::kMonetarySeparatorSymbol, \"money separator\");\n    patternStr = UNICODE_STRING_SIMPLE(\"0.00 \\\\u00A4' in your bank account'\");\n    patternStr = patternStr.unescape();\n    expStr = UnicodeString(\" minus 20money separator00 units of money in your bank account\", \"\");\n    status = U_ZERO_ERROR;\n    expect2(new DecimalFormat(patternStr, custom, status),\n           int32_t(-20), expStr, status);\n\n    custom.setSymbol(DecimalFormatSymbols::kPercentSymbol, \"percent\");\n    patternStr = \"'You''ve lost ' -0.00 %' of your money today'\";\n    patternStr = patternStr.unescape();\n    expStr = UnicodeString(\" minus You've lost   minus 2000decimal00 percent of your money today\", \"\");\n    status = U_ZERO_ERROR;\n    expect2(new DecimalFormat(patternStr, custom, status),\n           int32_t(-20), expStr, status);\n}\n\nvoid NumberFormatTest::TestCurrencyPatterns(void) {\n    int32_t i, locCount;\n    const Locale* locs = NumberFormat::getAvailableLocales(locCount);\n    for (i=0; i<locCount; ++i) {\n        UErrorCode ec = U_ZERO_ERROR;\n        NumberFormat* nf = NumberFormat::createCurrencyInstance(locs[i], ec);\n        if (U_FAILURE(ec)) {\n            errln(\"FAIL: Can't create NumberFormat(%s) - %s\", locs[i].getName(), u_errorName(ec));\n        } else {\n            // Make sure currency formats do not have a variable number\n            // of fraction digits\n            int32_t min = nf->getMinimumFractionDigits();\n            int32_t max = nf->getMaximumFractionDigits();\n            if (min != max) {\n                UnicodeString a, b;\n                nf->format(1.0, a);\n                nf->format(1.125, b);\n                errln((UnicodeString)\"FAIL: \" + locs[i].getName() +\n                      \" min fraction digits != max fraction digits; \"\n                      \"x 1.0 => \" + escape(a) +\n                      \"; x 1.125 => \" + escape(b));\n            }\n\n            // Make sure EURO currency formats have exactly 2 fraction digits\n            DecimalFormat* df = dynamic_cast<DecimalFormat*>(nf);\n            if (df != NULL) {\n                if (u_strcmp(EUR, df->getCurrency()) == 0) {\n                    if (min != 2 || max != 2) {\n                        UnicodeString a;\n                        nf->format(1.0, a);\n                        errln((UnicodeString)\"FAIL: \" + locs[i].getName() +\n                              \" is a EURO format but it does not have 2 fraction digits; \"\n                              \"x 1.0 => \" +\n                              escape(a));\n                    }\n                }\n            }\n        }\n        delete nf;\n    }\n}\n\nvoid NumberFormatTest::TestRegCurrency(void) {\n#if !UCONFIG_NO_SERVICE\n    UErrorCode status = U_ZERO_ERROR;\n    UChar USD[4];\n    ucurr_forLocale(\"en_US\", USD, 4, &status);\n    UChar YEN[4];\n    ucurr_forLocale(\"ja_JP\", YEN, 4, &status);\n    UChar TMP[4];\n    static const UChar QQQ[] = {0x51, 0x51, 0x51, 0};\n    if(U_FAILURE(status)) {\n        errcheckln(status, \"Unable to get currency for locale, error %s\", u_errorName(status));\n        return;\n    }\n\n    UCurrRegistryKey enkey = ucurr_register(YEN, \"en_US\", &status);\n    UCurrRegistryKey enUSEUROkey = ucurr_register(QQQ, \"en_US_EURO\", &status);\n\n    ucurr_forLocale(\"en_US\", TMP, 4, &status);\n    if (u_strcmp(YEN, TMP) != 0) {\n        errln(\"FAIL: didn't return YEN registered for en_US\");\n    }\n\n    ucurr_forLocale(\"en_US_EURO\", TMP, 4, &status);\n    if (u_strcmp(QQQ, TMP) != 0) {\n        errln(\"FAIL: didn't return QQQ for en_US_EURO\");\n    }\n\n    int32_t fallbackLen = ucurr_forLocale(\"en_XX_BAR\", TMP, 4, &status);\n    if (fallbackLen) {\n        errln(\"FAIL: tried to fallback en_XX_BAR\");\n    }\n    status = U_ZERO_ERROR; // reset\n\n    if (!ucurr_unregister(enkey, &status)) {\n        errln(\"FAIL: couldn't unregister enkey\");\n    }\n\n    ucurr_forLocale(\"en_US\", TMP, 4, &status);\n    if (u_strcmp(USD, TMP) != 0) {\n        errln(\"FAIL: didn't return USD for en_US after unregister of en_US\");\n    }\n    status = U_ZERO_ERROR; // reset\n\n    ucurr_forLocale(\"en_US_EURO\", TMP, 4, &status);\n    if (u_strcmp(QQQ, TMP) != 0) {\n        errln(\"FAIL: didn't return QQQ for en_US_EURO after unregister of en_US\");\n    }\n\n    ucurr_forLocale(\"en_US_BLAH\", TMP, 4, &status);\n    if (u_strcmp(USD, TMP) != 0) {\n        errln(\"FAIL: could not find USD for en_US_BLAH after unregister of en\");\n    }\n    status = U_ZERO_ERROR; // reset\n\n    if (!ucurr_unregister(enUSEUROkey, &status)) {\n        errln(\"FAIL: couldn't unregister enUSEUROkey\");\n    }\n\n    ucurr_forLocale(\"en_US_EURO\", TMP, 4, &status);\n    if (u_strcmp(EUR, TMP) != 0) {\n        errln(\"FAIL: didn't return EUR for en_US_EURO after unregister of en_US_EURO\");\n    }\n    status = U_ZERO_ERROR; // reset\n#endif\n}\n\nvoid NumberFormatTest::TestCurrencyNames(void) {\n    // Do a basic check of getName()\n    // USD { \"US$\", \"US Dollar\"            } // 04/04/1792-\n    UErrorCode ec = U_ZERO_ERROR;\n    static const UChar USD[] = {0x55, 0x53, 0x44, 0}; /*USD*/\n    static const UChar USX[] = {0x55, 0x53, 0x58, 0}; /*USX*/\n    static const UChar CAD[] = {0x43, 0x41, 0x44, 0}; /*CAD*/\n    static const UChar ITL[] = {0x49, 0x54, 0x4C, 0}; /*ITL*/\n    UBool isChoiceFormat;\n    int32_t len;\n    const UBool possibleDataError = TRUE;\n    // Warning: HARD-CODED LOCALE DATA in this test.  If it fails, CHECK\n    // THE LOCALE DATA before diving into the code.\n    assertEquals(\"USD.getName(SYMBOL_NAME, en)\",\n                 UnicodeString(\"$\"),\n                 UnicodeString(ucurr_getName(USD, \"en\",\n                                             UCURR_SYMBOL_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertEquals(\"USD.getName(NARROW_SYMBOL_NAME, en)\",\n                 UnicodeString(\"$\"),\n                 UnicodeString(ucurr_getName(USD, \"en\",\n                                             UCURR_NARROW_SYMBOL_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertEquals(\"USD.getName(LONG_NAME, en)\",\n                 UnicodeString(\"US Dollar\"),\n                 UnicodeString(ucurr_getName(USD, \"en\",\n                                             UCURR_LONG_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertEquals(\"CAD.getName(SYMBOL_NAME, en)\",\n                 UnicodeString(\"CA$\"),\n                 UnicodeString(ucurr_getName(CAD, \"en\",\n                                             UCURR_SYMBOL_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertEquals(\"CAD.getName(NARROW_SYMBOL_NAME, en)\",\n                 UnicodeString(\"$\"),\n                 UnicodeString(ucurr_getName(CAD, \"en\",\n                                             UCURR_NARROW_SYMBOL_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertEquals(\"CAD.getName(SYMBOL_NAME, en_CA)\",\n                 UnicodeString(\"$\"),\n                 UnicodeString(ucurr_getName(CAD, \"en_CA\",\n                                             UCURR_SYMBOL_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertEquals(\"USD.getName(SYMBOL_NAME, en_CA)\",\n                 UnicodeString(\"US$\"),\n                 UnicodeString(ucurr_getName(USD, \"en_CA\",\n                                             UCURR_SYMBOL_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertEquals(\"USD.getName(NARROW_SYMBOL_NAME, en_CA)\",\n                 UnicodeString(\"$\"),\n                 UnicodeString(ucurr_getName(USD, \"en_CA\",\n                                             UCURR_NARROW_SYMBOL_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertEquals(\"USD.getName(SYMBOL_NAME) in en_NZ\",\n                 UnicodeString(\"US$\"),\n                 UnicodeString(ucurr_getName(USD, \"en_NZ\",\n                                             UCURR_SYMBOL_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertEquals(\"CAD.getName(SYMBOL_NAME)\",\n                 UnicodeString(\"CA$\"),\n                 UnicodeString(ucurr_getName(CAD, \"en_NZ\",\n                                             UCURR_SYMBOL_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertEquals(\"USX.getName(SYMBOL_NAME)\",\n                 UnicodeString(\"USX\"),\n                 UnicodeString(ucurr_getName(USX, \"en_US\",\n                                             UCURR_SYMBOL_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertEquals(\"USX.getName(NARROW_SYMBOL_NAME)\",\n                 UnicodeString(\"USX\"),\n                 UnicodeString(ucurr_getName(USX, \"en_US\",\n                                             UCURR_NARROW_SYMBOL_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertEquals(\"USX.getName(LONG_NAME)\",\n                 UnicodeString(\"USX\"),\n                 UnicodeString(ucurr_getName(USX, \"en_US\",\n                                             UCURR_LONG_NAME,\n                                             &isChoiceFormat, &len, &ec)),\n                                             possibleDataError);\n    assertSuccess(\"ucurr_getName\", ec);\n\n    ec = U_ZERO_ERROR;\n\n    // Test that a default or fallback warning is being returned. JB 4239.\n    ucurr_getName(CAD, \"es_ES\", UCURR_LONG_NAME, &isChoiceFormat,\n                            &len, &ec);\n    assertTrue(\"ucurr_getName (es_ES fallback)\",\n                    U_USING_FALLBACK_WARNING == ec, TRUE, possibleDataError);\n\n    ucurr_getName(CAD, \"zh_TW\", UCURR_LONG_NAME, &isChoiceFormat,\n                            &len, &ec);\n    assertTrue(\"ucurr_getName (zh_TW fallback)\",\n                    U_USING_FALLBACK_WARNING == ec, TRUE, possibleDataError);\n\n    ucurr_getName(CAD, \"en_US\", UCURR_LONG_NAME, &isChoiceFormat,\n                            &len, &ec);\n    assertTrue(\"ucurr_getName (en_US default)\",\n                    U_USING_DEFAULT_WARNING == ec || U_USING_FALLBACK_WARNING == ec, TRUE);\n\n    ucurr_getName(CAD, \"ti\", UCURR_LONG_NAME, &isChoiceFormat,\n                            &len, &ec);\n    assertTrue(\"ucurr_getName (ti default)\",\n                    U_USING_DEFAULT_WARNING == ec, TRUE);\n\n    // Test that a default warning is being returned when falling back to root. JB 4536.\n    ucurr_getName(ITL, \"cy\", UCURR_LONG_NAME, &isChoiceFormat,\n                            &len, &ec);\n    assertTrue(\"ucurr_getName (cy default to root)\",\n                    U_USING_DEFAULT_WARNING == ec, TRUE);\n\n    // TODO add more tests later\n}\n\nvoid NumberFormatTest::TestCurrencyUnit(void){\n    UErrorCode ec = U_ZERO_ERROR;\n    static const UChar USD[]  = u\"USD\";\n    static const char USD8[]  =  \"USD\";\n    static const UChar BAD[]  = u\"???\";\n    static const UChar BAD2[] = u\"??A\";\n    static const UChar XXX[]  = u\"XXX\";\n    static const char XXX8[]  =  \"XXX\";\n    CurrencyUnit cu(USD, ec);\n    assertSuccess(\"CurrencyUnit\", ec);\n\n    assertEquals(\"getISOCurrency()\", USD, cu.getISOCurrency());\n    assertEquals(\"getSubtype()\", USD8, cu.getSubtype());\n\n    CurrencyUnit cu2(cu);\n    if (!(cu2 == cu)){\n        errln(\"CurrencyUnit copy constructed object should be same\");\n    }\n\n    CurrencyUnit * cu3 = (CurrencyUnit *)cu.clone();\n    if (!(*cu3 == cu)){\n        errln(\"CurrencyUnit cloned object should be same\");\n    }\n    CurrencyUnit bad(BAD, ec);\n    assertSuccess(\"CurrencyUnit\", ec);\n    if (cu.getIndex() == bad.getIndex()) {\n        errln(\"Indexes of different currencies should differ.\");\n    }\n    CurrencyUnit bad2(BAD2, ec);\n    assertSuccess(\"CurrencyUnit\", ec);\n    if (bad2.getIndex() != bad.getIndex()) {\n        errln(\"Indexes of unrecognized currencies should be the same.\");\n    }\n    if (bad == bad2) {\n        errln(\"Different unrecognized currencies should not be equal.\");\n    }\n    bad = bad2;\n    if (bad != bad2) {\n        errln(\"Currency unit assignment should be the same.\");\n    }\n    delete cu3;\n\n    // Test default constructor\n    CurrencyUnit def;\n    assertEquals(\"Default currency\", XXX, def.getISOCurrency());\n    assertEquals(\"Default currency as subtype\", XXX8, def.getSubtype());\n\n    // Test slicing\n    MeasureUnit sliced1 = cu;\n    MeasureUnit sliced2 = cu;\n    assertEquals(\"Subtype after slicing 1\", USD8, sliced1.getSubtype());\n    assertEquals(\"Subtype after slicing 2\", USD8, sliced2.getSubtype());\n    CurrencyUnit restored1(sliced1, ec);\n    CurrencyUnit restored2(sliced2, ec);\n    assertSuccess(\"Restoring from MeasureUnit\", ec);\n    assertEquals(\"Subtype after restoring 1\", USD8, restored1.getSubtype());\n    assertEquals(\"Subtype after restoring 2\", USD8, restored2.getSubtype());\n    assertEquals(\"ISO Code after restoring 1\", USD, restored1.getISOCurrency());\n    assertEquals(\"ISO Code after restoring 2\", USD, restored2.getISOCurrency());\n\n    // Test copy constructor failure\n    LocalPointer<MeasureUnit> meter(MeasureUnit::createMeter(ec));\n    assertSuccess(\"Creating meter\", ec);\n    CurrencyUnit failure(*meter, ec);\n    assertEquals(\"Copying from meter should fail\", ec, U_ILLEGAL_ARGUMENT_ERROR);\n    assertEquals(\"Copying should not give uninitialized ISO code\", u\"\", failure.getISOCurrency());\n}\n\nvoid NumberFormatTest::TestCurrencyAmount(void){\n    UErrorCode ec = U_ZERO_ERROR;\n    static const UChar USD[] = {85, 83, 68, 0}; /*USD*/\n    CurrencyAmount ca(9, USD, ec);\n    assertSuccess(\"CurrencyAmount\", ec);\n\n    CurrencyAmount ca2(ca);\n    if (!(ca2 == ca)){\n        errln(\"CurrencyAmount copy constructed object should be same\");\n    }\n\n    ca2=ca;\n    if (!(ca2 == ca)){\n        errln(\"CurrencyAmount assigned object should be same\");\n    }\n\n    CurrencyAmount *ca3 = (CurrencyAmount *)ca.clone();\n    if (!(*ca3 == ca)){\n        errln(\"CurrencyAmount cloned object should be same\");\n    }\n    delete ca3;\n}\n\nvoid NumberFormatTest::TestSymbolsWithBadLocale(void) {\n    Locale locDefault;\n    static const char *badLocales[] = {\n        // length < ULOC_FULLNAME_CAPACITY\n        \"x-crazy_ZZ_MY_SPECIAL_ADMINISTRATION_REGION_NEEDS_A_SPECIAL_VARIANT_WITH_A_REALLY_REALLY_REALLY_REALLY_REALLY_REALLY_REALLY_LONG_NAME\",\n\n        // length > ULOC_FULLNAME_CAPACITY\n        \"x-crazy_ZZ_MY_SPECIAL_ADMINISTRATION_REGION_NEEDS_A_SPECIAL_VARIANT_WITH_A_REALLY_REALLY_REALLY_REALLY_REALLY_REALLY_REALLY_REALLY_REALLY_REALLY_REALLY_LONG_NAME\"\n    }; // expect U_USING_DEFAULT_WARNING for both\n\n    unsigned int i;\n    for (i = 0; i < UPRV_LENGTHOF(badLocales); i++) {\n        const char *localeName = badLocales[i];\n        Locale locBad(localeName);\n        TEST_ASSERT_TRUE(!locBad.isBogus());\n        UErrorCode status = U_ZERO_ERROR;\n        UnicodeString intlCurrencySymbol((UChar)0xa4);\n\n        intlCurrencySymbol.append((UChar)0xa4);\n\n        logln(\"Current locale is %s\", Locale::getDefault().getName());\n        Locale::setDefault(locBad, status);\n        logln(\"Current locale is %s\", Locale::getDefault().getName());\n        DecimalFormatSymbols mySymbols(status);\n        if (status != U_USING_DEFAULT_WARNING) {\n            errln(\"DecimalFormatSymbols should return U_USING_DEFAULT_WARNING.\");\n        }\n        if (strcmp(mySymbols.getLocale().getName(), locBad.getName()) != 0) {\n            errln(\"DecimalFormatSymbols does not have the right locale.\", locBad.getName());\n        }\n        int symbolEnum = (int)DecimalFormatSymbols::kDecimalSeparatorSymbol;\n        for (; symbolEnum < (int)DecimalFormatSymbols::kFormatSymbolCount; symbolEnum++) {\n            UnicodeString symbolString = mySymbols.getSymbol((DecimalFormatSymbols::ENumberFormatSymbol)symbolEnum);\n            logln(UnicodeString(\"DecimalFormatSymbols[\") + symbolEnum + UnicodeString(\"] = \") + prettify(symbolString));\n            if (symbolString.length() == 0\n                && symbolEnum != (int)DecimalFormatSymbols::kGroupingSeparatorSymbol\n                && symbolEnum != (int)DecimalFormatSymbols::kMonetaryGroupingSeparatorSymbol)\n            {\n                errln(\"DecimalFormatSymbols has an empty string at index %d.\", symbolEnum);\n            }\n        }\n\n        status = U_ZERO_ERROR;\n        Locale::setDefault(locDefault, status);\n        logln(\"Current locale is %s\", Locale::getDefault().getName());\n    }\n}\n\n/**\n * Check that adoptDecimalFormatSymbols and setDecimalFormatSymbols\n * behave the same, except for memory ownership semantics. (No\n * version of this test on Java, since Java has only one method.)\n */\nvoid NumberFormatTest::TestAdoptDecimalFormatSymbols(void) {\n    UErrorCode ec = U_ZERO_ERROR;\n    DecimalFormatSymbols *sym = new DecimalFormatSymbols(Locale::getUS(), ec);\n    if (U_FAILURE(ec)) {\n        errcheckln(ec, \"Fail: DecimalFormatSymbols constructor - %s\", u_errorName(ec));\n        delete sym;\n        return;\n    }\n    UnicodeString pat(\" #,##0.00\");\n    pat.insert(0, (UChar)0x00A4);\n    DecimalFormat fmt(pat, sym, ec);\n    if (U_FAILURE(ec)) {\n        errln(\"Fail: DecimalFormat constructor\");\n        return;\n    }\n\n    UnicodeString str;\n    fmt.format(2350.75, str);\n    if (str == \"$ 2,350.75\") {\n        logln(str);\n    } else {\n        dataerrln(\"Fail: \" + str + \", expected $ 2,350.75\");\n    }\n\n    sym = new DecimalFormatSymbols(Locale::getUS(), ec);\n    if (U_FAILURE(ec)) {\n        errln(\"Fail: DecimalFormatSymbols constructor\");\n        delete sym;\n        return;\n    }\n    sym->setSymbol(DecimalFormatSymbols::kCurrencySymbol, \"Q\");\n    fmt.adoptDecimalFormatSymbols(sym);\n\n    str.truncate(0);\n    fmt.format(2350.75, str);\n    if (str == \"Q 2,350.75\") {\n        logln(str);\n    } else {\n        dataerrln(\"Fail: adoptDecimalFormatSymbols -> \" + str + \", expected Q 2,350.75\");\n    }\n\n    sym = new DecimalFormatSymbols(Locale::getUS(), ec);\n    if (U_FAILURE(ec)) {\n        errln(\"Fail: DecimalFormatSymbols constructor\");\n        delete sym;\n        return;\n    }\n    DecimalFormat fmt2(pat, sym, ec);\n    if (U_FAILURE(ec)) {\n        errln(\"Fail: DecimalFormat constructor\");\n        return;\n    }\n\n    DecimalFormatSymbols sym2(Locale::getUS(), ec);\n    if (U_FAILURE(ec)) {\n        errln(\"Fail: DecimalFormatSymbols constructor\");\n        return;\n    }\n    sym2.setSymbol(DecimalFormatSymbols::kCurrencySymbol, \"Q\");\n    fmt2.setDecimalFormatSymbols(sym2);\n\n    str.truncate(0);\n    fmt2.format(2350.75, str);\n    if (str == \"Q 2,350.75\") {\n        logln(str);\n    } else {\n        dataerrln(\"Fail: setDecimalFormatSymbols -> \" + str + \", expected Q 2,350.75\");\n    }\n}\n\nvoid NumberFormatTest::TestPerMill() {\n    UErrorCode ec = U_ZERO_ERROR;\n    UnicodeString str;\n    DecimalFormat fmt(ctou(\"###.###\\\\u2030\"), ec);\n    if (!assertSuccess(\"DecimalFormat ct\", ec)) return;\n    assertEquals(\"0.4857 x ###.###\\\\u2030\",\n                 ctou(\"485.7\\\\u2030\"), fmt.format(0.4857, str), true);\n\n    DecimalFormatSymbols sym(Locale::getUS(), ec);\n    if (!assertSuccess(\"\", ec, true, __FILE__, __LINE__)) {\n        return;\n    }\n    sym.setSymbol(DecimalFormatSymbols::kPerMillSymbol, ctou(\"m\"));\n    DecimalFormat fmt2(\"\", sym, ec);\n    if (!assertSuccess(\"\", ec, true, __FILE__, __LINE__)) {\n        return;\n    }\n    fmt2.applyLocalizedPattern(\"###.###m\", ec);\n    if (!assertSuccess(\"setup\", ec)) return;\n    str.truncate(0);\n    assertEquals(\"0.4857 x ###.###m\",\n                 \"485.7m\", fmt2.format(0.4857, str));\n}\n\n/**\n * Generic test for patterns that should be legal/illegal.\n */\nvoid NumberFormatTest::TestIllegalPatterns() {\n    // Test cases:\n    // Prefix with \"-:\" for illegal patterns\n    // Prefix with \"+:\" for legal patterns\n    const char* DATA[] = {\n        // Unquoted special characters in the suffix are illegal\n        \"-:000.000|###\",\n        \"+:000.000'|###'\",\n        0\n    };\n    for (int32_t i=0; DATA[i]; ++i) {\n        const char* pat=DATA[i];\n        UBool valid = (*pat) == '+';\n        pat += 2;\n        UErrorCode ec = U_ZERO_ERROR;\n        DecimalFormat fmt(pat, ec); // locale doesn't matter here\n        if (U_SUCCESS(ec) == valid) {\n            logln(\"Ok: pattern \\\"%s\\\": %s\",\n                  pat, u_errorName(ec));\n        } else {\n            errcheckln(ec, \"FAIL: pattern \\\"%s\\\" should have %s; got %s\",\n                  pat, (valid?\"succeeded\":\"failed\"),\n                  u_errorName(ec));\n        }\n    }\n}\n\n//----------------------------------------------------------------------\n\nstatic const char* KEYWORDS[] = {\n    /*0*/ \"ref=\", // <reference pattern to parse numbers>\n    /*1*/ \"loc=\", // <locale for formats>\n    /*2*/ \"f:\",   // <pattern or '-'> <number> <exp. string>\n    /*3*/ \"fp:\",  // <pattern or '-'> <number> <exp. string> <exp. number>\n    /*4*/ \"rt:\",  // <pattern or '-'> <(exp.) number> <(exp.) string>\n    /*5*/ \"p:\",   // <pattern or '-'> <string> <exp. number>\n    /*6*/ \"perr:\", // <pattern or '-'> <invalid string>\n    /*7*/ \"pat:\", // <pattern or '-'> <exp. toPattern or '-' or 'err'>\n    /*8*/ \"fpc:\", // <pattern or '-'> <curr.amt> <exp. string> <exp. curr.amt>\n    0\n};\n\n/**\n * Return an integer representing the next token from this\n * iterator.  The integer will be an index into the given list, or\n * -1 if there are no more tokens, or -2 if the token is not on\n * the list.\n */\nstatic int32_t keywordIndex(const UnicodeString& tok) {\n    for (int32_t i=0; KEYWORDS[i]!=0; ++i) {\n        if (tok==KEYWORDS[i]) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n/**\n * Parse a CurrencyAmount using the given NumberFormat, with\n * the 'delim' character separating the number and the currency.\n */\nstatic void parseCurrencyAmount(const UnicodeString& str,\n                                const NumberFormat& fmt,\n                                UChar delim,\n                                Formattable& result,\n                                UErrorCode& ec) {\n    UnicodeString num, cur;\n    int32_t i = str.indexOf(delim);\n    str.extractBetween(0, i, num);\n    str.extractBetween(i+1, INT32_MAX, cur);\n    Formattable n;\n    fmt.parse(num, n, ec);\n    result.adoptObject(new CurrencyAmount(n, cur.getTerminatedBuffer(), ec));\n}\n\nvoid NumberFormatTest::TestCases() {\n    UErrorCode ec = U_ZERO_ERROR;\n    TextFile reader(\"NumberFormatTestCases.txt\", \"UTF8\", ec);\n    if (U_FAILURE(ec)) {\n        dataerrln(\"Couldn't open NumberFormatTestCases.txt\");\n        return;\n    }\n    TokenIterator tokens(&reader);\n\n    Locale loc(\"en\", \"US\", \"\");\n    DecimalFormat *ref = 0, *fmt = 0;\n    MeasureFormat *mfmt = 0;\n    UnicodeString pat, tok, mloc, str, out, where, currAmt;\n    Formattable n;\n\n    for (;;) {\n        ec = U_ZERO_ERROR;\n        if (!tokens.next(tok, ec)) {\n            break;\n        }\n        where = UnicodeString(\"(\") + tokens.getLineNumber() + \") \";\n        int32_t cmd = keywordIndex(tok);\n        switch (cmd) {\n        case 0:\n            // ref= <reference pattern>\n            if (!tokens.next(tok, ec)) goto error;\n            delete ref;\n            ref = new DecimalFormat(tok,\n                      new DecimalFormatSymbols(Locale::getUS(), ec), ec);\n            if (U_FAILURE(ec)) {\n                dataerrln(\"Error constructing DecimalFormat\");\n                goto error;\n            }\n            break;\n        case 1:\n            // loc= <locale>\n            if (!tokens.next(tok, ec)) goto error;\n            loc = Locale::createFromName(CharString().appendInvariantChars(tok, ec).data());\n            break;\n        case 2: // f:\n        case 3: // fp:\n        case 4: // rt:\n        case 5: // p:\n            if (!tokens.next(tok, ec)) goto error;\n            if (tok != \"-\") {\n                pat = tok;\n                delete fmt;\n                fmt = new DecimalFormat(pat, new DecimalFormatSymbols(loc, ec), ec);\n                if (U_FAILURE(ec)) {\n                    errln(\"FAIL: \" + where + \"Pattern \\\"\" + pat + \"\\\": \" + u_errorName(ec));\n                    ec = U_ZERO_ERROR;\n                    if (!tokens.next(tok, ec)) goto error;\n                    if (!tokens.next(tok, ec)) goto error;\n                    if (cmd == 3) {\n                        if (!tokens.next(tok, ec)) goto error;\n                    }\n                    continue;\n                }\n            }\n            if (cmd == 2 || cmd == 3 || cmd == 4) {\n                // f: <pattern or '-'> <number> <exp. string>\n                // fp: <pattern or '-'> <number> <exp. string> <exp. number>\n                // rt: <pattern or '-'> <number> <string>\n                UnicodeString num;\n                if (!tokens.next(num, ec)) goto error;\n                if (!tokens.next(str, ec)) goto error;\n                ref->parse(num, n, ec);\n                assertSuccess(\"parse\", ec);\n                assertEquals(where + \"\\\"\" + pat + \"\\\".format(\" + num + \")\",\n                             str, fmt->format(n, out.remove(), ec));\n                assertSuccess(\"format\", ec);\n                if (cmd == 3) { // fp:\n                    if (!tokens.next(num, ec)) goto error;\n                    ref->parse(num, n, ec);\n                    assertSuccess(\"parse\", ec);\n                }\n                if (cmd != 2) { // != f:\n                    Formattable m;\n                    fmt->parse(str, m, ec);\n                    assertSuccess(\"parse\", ec);\n                    assertEquals(where + \"\\\"\" + pat + \"\\\".parse(\\\"\" + str + \"\\\")\",\n                                 n, m);\n                }\n            }\n            // p: <pattern or '-'> <string to parse> <exp. number>\n            else {\n                UnicodeString expstr;\n                if (!tokens.next(str, ec)) goto error;\n                if (!tokens.next(expstr, ec)) goto error;\n                Formattable exp, n;\n                ref->parse(expstr, exp, ec);\n                assertSuccess(\"parse\", ec);\n                fmt->parse(str, n, ec);\n                assertSuccess(\"parse\", ec);\n                assertEquals(where + \"\\\"\" + pat + \"\\\".parse(\\\"\" + str + \"\\\")\",\n                             exp, n);\n            }\n            break;\n        case 8: // fpc:\n            if (!tokens.next(tok, ec)) goto error;\n            if (tok != \"-\") {\n                mloc = tok;\n                delete mfmt;\n                mfmt = MeasureFormat::createCurrencyFormat(\n                    Locale::createFromName(\n                        CharString().appendInvariantChars(mloc, ec).data()), ec);\n                if (U_FAILURE(ec)) {\n                    errln(\"FAIL: \" + where + \"Loc \\\"\" + mloc + \"\\\": \" + u_errorName(ec));\n                    ec = U_ZERO_ERROR;\n                    if (!tokens.next(tok, ec)) goto error;\n                    if (!tokens.next(tok, ec)) goto error;\n                    if (!tokens.next(tok, ec)) goto error;\n                    continue;\n                }\n            } else if (mfmt == NULL) {\n                errln(\"FAIL: \" + where + \"Loc \\\"\" + mloc + \"\\\": skip case using previous locale, no valid MeasureFormat\");\n                if (!tokens.next(tok, ec)) goto error;\n                if (!tokens.next(tok, ec)) goto error;\n                if (!tokens.next(tok, ec)) goto error;\n                continue;\n            }\n            // fpc: <loc or '-'> <curr.amt> <exp. string> <exp. curr.amt>\n            if (!tokens.next(currAmt, ec)) goto error;\n            if (!tokens.next(str, ec)) goto error;\n            parseCurrencyAmount(currAmt, *ref, (UChar)0x2F/*'/'*/, n, ec);\n            if (assertSuccess(\"parseCurrencyAmount\", ec)) {\n                assertEquals(where + \"getCurrencyFormat(\" + mloc + \").format(\" + currAmt + \")\",\n                             str, mfmt->format(n, out.remove(), ec));\n                assertSuccess(\"format\", ec);\n            }\n            if (!tokens.next(currAmt, ec)) goto error;\n            parseCurrencyAmount(currAmt, *ref, (UChar)0x2F/*'/'*/, n, ec);\n            if (assertSuccess(\"parseCurrencyAmount\", ec)) {\n                Formattable m;\n\n                mfmt->parseObject(str, m, ec);\n                if (assertSuccess(\"parseCurrency\", ec)) {\n                    assertEquals(where + \"getCurrencyFormat(\" + mloc + \").parse(\\\"\" + str + \"\\\")\",\n                                 n, m);\n                } else {\n                    errln(\"FAIL: source \" + str);\n                }\n            }\n            break;\n        case 6:\n            // perr: <pattern or '-'> <invalid string>\n            errln(\"FAIL: Under construction\");\n            goto done;\n        case 7: {\n            // pat: <pattern> <exp. toPattern, or '-' or 'err'>\n            UnicodeString testpat;\n            UnicodeString exppat;\n            if (!tokens.next(testpat, ec)) goto error;\n            if (!tokens.next(exppat, ec)) goto error;\n            UBool err = exppat == \"err\";\n            UBool existingPat = FALSE;\n            if (testpat == \"-\") {\n                if (err) {\n                    errln(\"FAIL: \" + where + \"Invalid command \\\"pat: - err\\\"\");\n                    continue;\n                }\n                existingPat = TRUE;\n                testpat = pat;\n            }\n            if (exppat == \"-\") exppat = testpat;\n            DecimalFormat* f = 0;\n            UErrorCode ec2 = U_ZERO_ERROR;\n            if (existingPat) {\n                f = fmt;\n            } else {\n                f = new DecimalFormat(testpat, ec2);\n            }\n            if (U_SUCCESS(ec2)) {\n                if (err) {\n                    errln(\"FAIL: \" + where + \"Invalid pattern \\\"\" + testpat +\n                          \"\\\" was accepted\");\n                } else {\n                    UnicodeString pat2;\n                    assertEquals(where + \"\\\"\" + testpat + \"\\\".toPattern()\",\n                                 exppat, f->toPattern(pat2));\n                }\n            } else {\n                if (err) {\n                    logln(\"Ok: \" + where + \"Invalid pattern \\\"\" + testpat +\n                          \"\\\" failed: \" + u_errorName(ec2));\n                } else {\n                    errln(\"FAIL: \" + where + \"Valid pattern \\\"\" + testpat +\n                          \"\\\" failed: \" + u_errorName(ec2));\n                }\n            }\n            if (!existingPat) delete f;\n            } break;\n        case -1:\n            errln(\"FAIL: \" + where + \"Unknown command \\\"\" + tok + \"\\\"\");\n            goto done;\n        }\n    }\n    goto done;\n\n error:\n    if (U_SUCCESS(ec)) {\n        errln(\"FAIL: Unexpected EOF\");\n    } else {\n        errcheckln(ec, \"FAIL: \" + where + \"Unexpected \" + u_errorName(ec));\n    }\n\n done:\n    delete mfmt;\n    delete fmt;\n    delete ref;\n}\n\n\n//----------------------------------------------------------------------\n// Support methods\n//----------------------------------------------------------------------\n\nUBool NumberFormatTest::equalValue(const Formattable& a, const Formattable& b) {\n    if (a.getType() == b.getType()) {\n        return a == b;\n    }\n\n    if (a.getType() == Formattable::kLong) {\n        if (b.getType() == Formattable::kInt64) {\n            return a.getLong() == b.getLong();\n        } else if (b.getType() == Formattable::kDouble) {\n            return (double) a.getLong() == b.getDouble(); // TODO check use of double instead of long\n        }\n    } else if (a.getType() == Formattable::kDouble) {\n        if (b.getType() == Formattable::kLong) {\n            return a.getDouble() == (double) b.getLong();\n        } else if (b.getType() == Formattable::kInt64) {\n            return a.getDouble() == (double)b.getInt64();\n        }\n    } else if (a.getType() == Formattable::kInt64) {\n        if (b.getType() == Formattable::kLong) {\n                return a.getInt64() == (int64_t)b.getLong();\n        } else if (b.getType() == Formattable::kDouble) {\n            return a.getInt64() == (int64_t)b.getDouble();\n        }\n    }\n    return FALSE;\n}\n\nvoid NumberFormatTest::expect3(NumberFormat& fmt, const Formattable& n, const UnicodeString& str) {\n    // Don't round-trip format test, since we explicitly do it\n    expect_rbnf(fmt, n, str, FALSE);\n    expect_rbnf(fmt, str, n);\n}\n\nvoid NumberFormatTest::expect2(NumberFormat& fmt, const Formattable& n, const UnicodeString& str) {\n    // Don't round-trip format test, since we explicitly do it\n    expect(fmt, n, str, FALSE);\n    expect(fmt, str, n);\n}\n\nvoid NumberFormatTest::expect2(NumberFormat* fmt, const Formattable& n,\n                               const UnicodeString& exp,\n                               UErrorCode status) {\n    if (fmt == NULL || U_FAILURE(status)) {\n        dataerrln(\"FAIL: NumberFormat constructor\");\n    } else {\n        expect2(*fmt, n, exp);\n    }\n    delete fmt;\n}\n\nvoid NumberFormatTest::expect(NumberFormat& fmt, const UnicodeString& str, const Formattable& n) {\n    UErrorCode status = U_ZERO_ERROR;\n    Formattable num;\n    fmt.parse(str, num, status);\n    if (U_FAILURE(status)) {\n        dataerrln(UnicodeString(\"FAIL: Parse failed for \\\"\") + str + \"\\\" - \" + u_errorName(status));\n        return;\n    }\n    UnicodeString pat;\n    ((DecimalFormat*) &fmt)->toPattern(pat);\n    if (equalValue(num, n)) {\n        logln(UnicodeString(\"Ok   \\\"\") + str + \"\\\" x \" +\n              pat + \" = \" +\n              toString(num));\n    } else {\n        dataerrln(UnicodeString(\"FAIL \\\"\") + str + \"\\\" x \" +\n              pat + \" = \" +\n              toString(num) + \", expected \" + toString(n));\n    }\n}\n\nvoid NumberFormatTest::expect_rbnf(NumberFormat& fmt, const UnicodeString& str, const Formattable& n) {\n    UErrorCode status = U_ZERO_ERROR;\n    Formattable num;\n    fmt.parse(str, num, status);\n    if (U_FAILURE(status)) {\n        errln(UnicodeString(\"FAIL: Parse failed for \\\"\") + str + \"\\\"\");\n        return;\n    }\n    if (equalValue(num, n)) {\n        logln(UnicodeString(\"Ok   \\\"\") + str + \" = \" +\n              toString(num));\n    } else {\n        errln(UnicodeString(\"FAIL \\\"\") + str + \" = \" +\n              toString(num) + \", expected \" + toString(n));\n    }\n}\n\nvoid NumberFormatTest::expect_rbnf(NumberFormat& fmt, const Formattable& n,\n                              const UnicodeString& exp, UBool rt) {\n    UnicodeString saw;\n    FieldPosition pos;\n    UErrorCode status = U_ZERO_ERROR;\n    fmt.format(n, saw, pos, status);\n    CHECK(status, \"NumberFormat::format\");\n    if (saw == exp) {\n        logln(UnicodeString(\"Ok   \") + toString(n) +\n              \" = \\\"\" +\n              escape(saw) + \"\\\"\");\n        // We should be able to round-trip the formatted string =>\n        // number => string (but not the other way around: number\n        // => string => number2, might have number2 != number):\n        if (rt) {\n            Formattable n2;\n            fmt.parse(exp, n2, status);\n            if (U_FAILURE(status)) {\n                errln(UnicodeString(\"FAIL: Parse failed for \\\"\") + exp + \"\\\"\");\n                return;\n            }\n            UnicodeString saw2;\n            fmt.format(n2, saw2, pos, status);\n            CHECK(status, \"NumberFormat::format\");\n            if (saw2 != exp) {\n                errln((UnicodeString)\"FAIL \\\"\" + exp + \"\\\" => \" + toString(n2) +\n                      \" => \\\"\" + saw2 + \"\\\"\");\n            }\n        }\n    } else {\n        errln(UnicodeString(\"FAIL \") + toString(n) +\n              \" = \\\"\" +\n              escape(saw) + \"\\\", expected \\\"\" + exp + \"\\\"\");\n    }\n}\n\nvoid NumberFormatTest::expect(NumberFormat& fmt, const Formattable& n,\n                              const UnicodeString& exp, UBool rt) {\n    UnicodeString saw;\n    FieldPosition pos;\n    UErrorCode status = U_ZERO_ERROR;\n    fmt.format(n, saw, pos, status);\n    CHECK(status, \"NumberFormat::format\");\n    UnicodeString pat;\n    ((DecimalFormat*) &fmt)->toPattern(pat);\n    if (saw == exp) {\n        logln(UnicodeString(\"Ok   \") + toString(n) + \" x \" +\n              escape(pat) + \" = \\\"\" +\n              escape(saw) + \"\\\"\");\n        // We should be able to round-trip the formatted string =>\n        // number => string (but not the other way around: number\n        // => string => number2, might have number2 != number):\n        if (rt) {\n            Formattable n2;\n            fmt.parse(exp, n2, status);\n            if (U_FAILURE(status)) {\n                errln(UnicodeString(\"FAIL: Parse failed for \\\"\") + exp + \"\\\" - \" + u_errorName(status));\n                return;\n            }\n            UnicodeString saw2;\n            fmt.format(n2, saw2, pos, status);\n            CHECK(status, \"NumberFormat::format\");\n            if (saw2 != exp) {\n                errln((UnicodeString)\"FAIL \\\"\" + exp + \"\\\" => \" + toString(n2) +\n                      \" => \\\"\" + saw2 + \"\\\"\");\n            }\n        }\n    } else {\n        dataerrln(UnicodeString(\"FAIL \") + toString(n) + \" x \" +\n              escape(pat) + \" = \\\"\" +\n              escape(saw) + \"\\\", expected \\\"\" + exp + \"\\\"\");\n    }\n}\n\nvoid NumberFormatTest::expect(NumberFormat* fmt, const Formattable& n,\n                              const UnicodeString& exp, UBool rt,\n                              UErrorCode status) {\n    if (fmt == NULL || U_FAILURE(status)) {\n        dataerrln(\"FAIL: NumberFormat constructor\");\n    } else {\n        expect(*fmt, n, exp, rt);\n    }\n    delete fmt;\n}\n\nvoid NumberFormatTest::expectCurrency(NumberFormat& nf, const Locale& locale,\n                                      double value, const UnicodeString& string) {\n    UErrorCode ec = U_ZERO_ERROR;\n    DecimalFormat& fmt = * (DecimalFormat*) &nf;\n    const UChar DEFAULT_CURR[] = {45/*-*/,0};\n    UChar curr[4];\n    u_strcpy(curr, DEFAULT_CURR);\n    if (*locale.getLanguage() != 0) {\n        ucurr_forLocale(locale.getName(), curr, 4, &ec);\n        assertSuccess(\"ucurr_forLocale\", ec);\n        fmt.setCurrency(curr, ec);\n        assertSuccess(\"DecimalFormat::setCurrency\", ec);\n        fmt.setCurrency(curr); //Deprecated variant, for coverage only\n    }\n    UnicodeString s;\n    fmt.format(value, s);\n    s.findAndReplace((UChar32)0x00A0, (UChar32)0x0020);\n\n    // Default display of the number yields \"1234.5599999999999\"\n    // instead of \"1234.56\".  Use a formatter to fix this.\n    NumberFormat* f =\n        NumberFormat::createInstance(Locale::getUS(), ec);\n    UnicodeString v;\n    if (U_FAILURE(ec)) {\n        // Oops; bad formatter.  Use default op+= display.\n        v = (UnicodeString)\"\" + value;\n    } else {\n        f->setMaximumFractionDigits(4);\n        f->setGroupingUsed(FALSE);\n        f->format(value, v);\n    }\n    delete f;\n\n    if (s == string) {\n        logln((UnicodeString)\"Ok: \" + v + \" x \" + curr + \" => \" + prettify(s));\n    } else {\n        errln((UnicodeString)\"FAIL: \" + v + \" x \" + curr + \" => \" + prettify(s) +\n              \", expected \" + prettify(string));\n    }\n}\n\nvoid NumberFormatTest::expectPat(DecimalFormat& fmt, const UnicodeString& exp) {\n    UnicodeString pat;\n    fmt.toPattern(pat);\n    if (pat == exp) {\n        logln(UnicodeString(\"Ok   \\\"\") + pat + \"\\\"\");\n    } else {\n        errln(UnicodeString(\"FAIL \\\"\") + pat + \"\\\", expected \\\"\" + exp + \"\\\"\");\n    }\n}\n\nvoid NumberFormatTest::expectPad(DecimalFormat& fmt, const UnicodeString& pat,\n                                 int32_t pos) {\n    expectPad(fmt, pat, pos, 0, (UnicodeString)\"\");\n}\nvoid NumberFormatTest::expectPad(DecimalFormat& fmt, const UnicodeString& pat,\n                                 int32_t pos, int32_t width, UChar pad) {\n    expectPad(fmt, pat, pos, width, UnicodeString(pad));\n}\nvoid NumberFormatTest::expectPad(DecimalFormat& fmt, const UnicodeString& pat,\n                                 int32_t pos, int32_t width, const UnicodeString& pad) {\n    int32_t apos = 0, awidth = 0;\n    UnicodeString apadStr;\n    UErrorCode status = U_ZERO_ERROR;\n    fmt.applyPattern(pat, status);\n    if (U_SUCCESS(status)) {\n        apos = fmt.getPadPosition();\n        awidth = fmt.getFormatWidth();\n        apadStr=fmt.getPadCharacterString();\n    } else {\n        apos = -1;\n        awidth = width;\n        apadStr = pad;\n    }\n    if (apos == pos && awidth == width && apadStr == pad) {\n        UnicodeString infoStr;\n        if (pos == ILLEGAL) {\n            infoStr = UnicodeString(\" width=\", \"\") + awidth + UnicodeString(\" pad=\", \"\") + apadStr;\n        }\n        logln(UnicodeString(\"Ok   \\\"\") + pat + \"\\\" pos=\" + apos + infoStr);\n    } else {\n        errln(UnicodeString(\"FAIL \\\"\") + pat + \"\\\" pos=\" + apos +\n              \" width=\" + awidth + \" pad=\" + apadStr +\n              \", expected \" + pos + \" \" + width + \" \" + pad);\n    }\n}\n\n// This test is flaky b/c the symbols for CNY and JPY are equivalent in this locale  - FIXME\nvoid NumberFormatTest::TestCompatibleCurrencies() {\n/*\n    static const UChar JPY[] = {0x4A, 0x50, 0x59, 0};\n    static const UChar CNY[] = {0x43, 0x4E, 0x59, 0};\n    UErrorCode status = U_ZERO_ERROR;\n    LocalPointer<NumberFormat> fmt(\n        NumberFormat::createCurrencyInstance(Locale::getUS(), status));\n    if (U_FAILURE(status)) {\n        errln(\"Could not create number format instance.\");\n        return;\n    }\n    logln(\"%s:%d - testing parse of halfwidth yen sign\\n\", __FILE__, __LINE__);\n    expectParseCurrency(*fmt, JPY, 1235,  \"\\\\u00A51,235\");\n    logln(\"%s:%d - testing parse of fullwidth yen sign\\n\", __FILE__, __LINE__);\n    expectParseCurrency(*fmt, JPY, 1235,  \"\\\\uFFE51,235\");\n    logln(\"%s:%d - testing parse of halfwidth yen sign\\n\", __FILE__, __LINE__);\n    expectParseCurrency(*fmt, CNY, 1235,  \"CN\\\\u00A51,235\");\n\n    LocalPointer<NumberFormat> fmtTW(\n        NumberFormat::createCurrencyInstance(Locale::getTaiwan(), status));\n\n    logln(\"%s:%d - testing parse of halfwidth yen sign in TW\\n\", __FILE__, __LINE__);\n    expectParseCurrency(*fmtTW, CNY, 1235,  \"\\\\u00A51,235\");\n    logln(\"%s:%d - testing parse of fullwidth yen sign in TW\\n\", __FILE__, __LINE__);\n    expectParseCurrency(*fmtTW, CNY, 1235,  \"\\\\uFFE51,235\");\n\n    LocalPointer<NumberFormat> fmtJP(\n        NumberFormat::createCurrencyInstance(Locale::getJapan(), status));\n\n    logln(\"%s:%d - testing parse of halfwidth yen sign in JP\\n\", __FILE__, __LINE__);\n    expectParseCurrency(*fmtJP, JPY, 1235,  \"\\\\u00A51,235\");\n    logln(\"%s:%d - testing parse of fullwidth yen sign in JP\\n\", __FILE__, __LINE__);\n    expectParseCurrency(*fmtJP, JPY, 1235,  \"\\\\uFFE51,235\");\n\n    // more..\n*/\n}\n\nvoid NumberFormatTest::expectParseCurrency(const NumberFormat &fmt, const UChar* currency, double amount, const char *text) {\n    ParsePosition ppos;\n    UnicodeString utext = ctou(text);\n    LocalPointer<CurrencyAmount> currencyAmount(fmt.parseCurrency(utext, ppos));\n    if (!ppos.getIndex()) {\n        errln(UnicodeString(\"Parse of \") + utext + \" should have succeeded.\");\n        return;\n    }\n    UErrorCode status = U_ZERO_ERROR;\n\n    char theInfo[100];\n    sprintf(theInfo, \"For locale %s, string \\\"%s\\\", currency \",\n            fmt.getLocale(ULOC_ACTUAL_LOCALE, status).getBaseName(),\n            text);\n    u_austrcpy(theInfo+uprv_strlen(theInfo), currency);\n\n    char theOperation[100];\n\n    uprv_strcpy(theOperation, theInfo);\n    uprv_strcat(theOperation, \", check amount:\");\n    assertTrue(theOperation, amount ==  currencyAmount->getNumber().getDouble(status));\n\n    uprv_strcpy(theOperation, theInfo);\n    uprv_strcat(theOperation, \", check currency:\");\n    assertEquals(theOperation, currency, currencyAmount->getISOCurrency());\n}\n\n\nvoid NumberFormatTest::TestJB3832(){\n    const char* localeID = \"pt_PT@currency=PTE\";\n    Locale loc(localeID);\n    UErrorCode status = U_ZERO_ERROR;\n    UnicodeString expected(CharsToUnicodeString(\"1,150$50\\\\u00A0\\\\u200B\")); // per cldrbug 7670\n    UnicodeString s;\n    NumberFormat* currencyFmt = NumberFormat::createCurrencyInstance(loc, status);\n    if(U_FAILURE(status)){\n        dataerrln(\"Could not create currency formatter for locale %s - %s\", localeID, u_errorName(status));\n        return;\n    }\n    currencyFmt->format(1150.50, s);\n    if(s!=expected){\n        errln(UnicodeString(\"FAIL: Expected: \")+expected\n                + UnicodeString(\" Got: \") + s\n                + UnicodeString( \" for locale: \")+ UnicodeString(localeID) );\n    }\n    if (U_FAILURE(status)){\n        errln(\"FAIL: Status %s\", u_errorName(status));\n    }\n    delete currencyFmt;\n}\n\nvoid NumberFormatTest::TestHost()\n{\n#if U_PLATFORM_USES_ONLY_WIN32_API\n    Win32NumberTest::testLocales(this);\n#endif\n    Locale loc(\"en_US@compat=host\");\n    for (UNumberFormatStyle k = UNUM_DECIMAL;\n         k < UNUM_FORMAT_STYLE_COUNT; k = (UNumberFormatStyle)(k+1)) {\n        UErrorCode status = U_ZERO_ERROR;\n        LocalPointer<NumberFormat> full(NumberFormat::createInstance(loc, k, status));\n        if (!NumberFormat::isStyleSupported(k)) {\n            if (status != U_UNSUPPORTED_ERROR) {\n                errln(\"FAIL: expected style %d to be unsupported - %s\",\n                      k, u_errorName(status));\n            }\n            continue;\n        }\n        if (full.isNull() || U_FAILURE(status)) {\n            dataerrln(\"FAIL: Can't create number instance of style %d for host - %s\",\n                      k, u_errorName(status));\n            return;\n        }\n        UnicodeString result1;\n        Formattable number(10.00);\n        full->format(number, result1, status);\n        if (U_FAILURE(status)) {\n            errln(\"FAIL: Can't format for host\");\n            return;\n        }\n        Formattable formattable;\n        full->parse(result1, formattable, status);\n        if (U_FAILURE(status)) {\n            errln(\"FAIL: Can't parse for host\");\n            return;\n        }\n    }\n}\n\nvoid NumberFormatTest::TestHostClone()\n{\n    /*\n    Verify that a cloned formatter gives the same results\n    and is useable after the original has been deleted.\n    */\n    // This is mainly important on Windows.\n    UErrorCode status = U_ZERO_ERROR;\n    Locale loc(\"en_US@compat=host\");\n    UDate now = Calendar::getNow();\n    NumberFormat *full = NumberFormat::createInstance(loc, status);\n    if (full == NULL || U_FAILURE(status)) {\n        dataerrln(\"FAIL: Can't create NumberFormat date instance - %s\", u_errorName(status));\n        return;\n    }\n    UnicodeString result1;\n    full->format(now, result1, status);\n    Format *fullClone = full->clone();\n    delete full;\n    full = NULL;\n\n    UnicodeString result2;\n    fullClone->format(now, result2, status);\n    if (U_FAILURE(status)) {\n        errln(\"FAIL: format failure.\");\n    }\n    if (result1 != result2) {\n        errln(\"FAIL: Clone returned different result from non-clone.\");\n    }\n    delete fullClone;\n}\n\nvoid NumberFormatTest::TestCurrencyFormat()\n{\n    // This test is here to increase code coverage.\n    UErrorCode status = U_ZERO_ERROR;\n    MeasureFormat *cloneObj;\n    UnicodeString str;\n    Formattable toFormat, result;\n    static const UChar ISO_CODE[4] = {0x0047, 0x0042, 0x0050, 0};\n\n    Locale  saveDefaultLocale = Locale::getDefault();\n    Locale::setDefault( Locale::getUK(), status );\n    if (U_FAILURE(status)) {\n        errln(\"couldn't set default Locale!\");\n        return;\n    }\n\n    MeasureFormat *measureObj = MeasureFormat::createCurrencyFormat(status);\n    Locale::setDefault( saveDefaultLocale, status );\n    if (U_FAILURE(status)){\n        dataerrln(\"FAIL: Status %s\", u_errorName(status));\n        return;\n    }\n    cloneObj = (MeasureFormat *)measureObj->clone();\n    if (cloneObj == NULL) {\n        errln(\"Clone doesn't work\");\n        return;\n    }\n    toFormat.adoptObject(new CurrencyAmount(1234.56, ISO_CODE, status));\n    measureObj->format(toFormat, str, status);\n    measureObj->parseObject(str, result, status);\n    if (U_FAILURE(status)){\n        errln(\"FAIL: Status %s\", u_errorName(status));\n    }\n    if (result != toFormat) {\n        errln(\"measureObj does not round trip. Formatted string was \\\"\" + str + \"\\\" Got: \" + toString(result) + \" Expected: \" + toString(toFormat));\n    }\n    status = U_ZERO_ERROR;\n    str.truncate(0);\n    cloneObj->format(toFormat, str, status);\n    cloneObj->parseObject(str, result, status);\n    if (U_FAILURE(status)){\n        errln(\"FAIL: Status %s\", u_errorName(status));\n    }\n    if (result != toFormat) {\n        errln(\"Clone does not round trip. Formatted string was \\\"\" + str + \"\\\" Got: \" + toString(result) + \" Expected: \" + toString(toFormat));\n    }\n    if (*measureObj != *cloneObj) {\n        errln(\"Cloned object is not equal to the original object\");\n    }\n    delete measureObj;\n    delete cloneObj;\n\n    status = U_USELESS_COLLATOR_ERROR;\n    if (MeasureFormat::createCurrencyFormat(status) != NULL) {\n        errln(\"createCurrencyFormat should have returned NULL.\");\n    }\n}\n\n/* Port of ICU4J rounding test. */\nvoid NumberFormatTest::TestRounding() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat *df = (DecimalFormat*)NumberFormat::createCurrencyInstance(Locale::getEnglish(), status);\n\n    if (U_FAILURE(status)) {\n        dataerrln(\"Unable to create decimal formatter. - %s\", u_errorName(status));\n        return;\n    }\n\n    int roundingIncrements[]={1, 2, 5, 20, 50, 100};\n    int testValues[]={0, 300};\n\n    for (int j=0; j<2; j++) {\n        for (int mode=DecimalFormat::kRoundUp;mode<DecimalFormat::kRoundHalfEven;mode++) {\n            df->setRoundingMode((DecimalFormat::ERoundingMode)mode);\n            for (int increment=0; increment<6; increment++) {\n                double base=testValues[j];\n                double rInc=roundingIncrements[increment];\n                checkRounding(df, base, 20, rInc);\n                rInc=1.000000000/rInc;\n                checkRounding(df, base, 20, rInc);\n            }\n        }\n    }\n    delete df;\n}\n\nvoid NumberFormatTest::TestRoundingPattern() {\n    UErrorCode status = U_ZERO_ERROR;\n    struct {\n        UnicodeString  pattern;\n        double        testCase;\n        UnicodeString expected;\n    } tests[] = {\n            { (UnicodeString)\"##0.65\", 1.234, (UnicodeString)\"1.30\" },\n            { (UnicodeString)\"#50\",    1230,  (UnicodeString)\"1250\" }\n    };\n    int32_t numOfTests = UPRV_LENGTHOF(tests);\n    UnicodeString result;\n\n    DecimalFormat *df = (DecimalFormat*)NumberFormat::createCurrencyInstance(Locale::getEnglish(), status);\n    if (U_FAILURE(status)) {\n        dataerrln(\"Unable to create decimal formatter. - %s\", u_errorName(status));\n        return;\n    }\n\n    for (int32_t i = 0; i < numOfTests; i++) {\n        result.remove();\n\n        df->applyPattern(tests[i].pattern, status);\n        if (U_FAILURE(status)) {\n            errln(\"Unable to apply pattern to decimal formatter. - %s\", u_errorName(status));\n        }\n\n        df->format(tests[i].testCase, result);\n\n        if (result != tests[i].expected) {\n            errln(\"String Pattern Rounding Test Failed: Pattern: \\\"\" + tests[i].pattern + \"\\\" Number: \" + tests[i].testCase + \" - Got: \" + result + \" Expected: \" + tests[i].expected);\n        }\n    }\n\n    delete df;\n}\n\nvoid NumberFormatTest::checkRounding(DecimalFormat* df, double base, int iterations, double increment) {\n    df->setRoundingIncrement(increment);\n    double lastParsed=INT32_MIN; //Intger.MIN_VALUE\n    for (int i=-iterations; i<=iterations;i++) {\n        double iValue=base+(increment*(i*0.1));\n        double smallIncrement=0.00000001;\n        if (iValue!=0) {\n            smallIncrement*=iValue;\n        }\n        //we not only test the value, but some values in a small range around it\n        lastParsed=checkRound(df, iValue-smallIncrement, lastParsed);\n        lastParsed=checkRound(df, iValue, lastParsed);\n        lastParsed=checkRound(df, iValue+smallIncrement, lastParsed);\n    }\n}\n\ndouble NumberFormatTest::checkRound(DecimalFormat* df, double iValue, double lastParsed) {\n    UErrorCode status=U_ZERO_ERROR;\n    UnicodeString formattedDecimal;\n    double parsed;\n    Formattable result;\n    df->format(iValue, formattedDecimal, status);\n\n    if (U_FAILURE(status)) {\n        errln(\"Error formatting number.\");\n    }\n\n    df->parse(formattedDecimal, result, status);\n\n    if (U_FAILURE(status)) {\n        errln(\"Error parsing number.\");\n    }\n\n    parsed=result.getDouble();\n\n    if (lastParsed>parsed) {\n        errln(\"Rounding wrong direction! %d > %d\", lastParsed, parsed);\n    }\n\n    return lastParsed;\n}\n\nvoid NumberFormatTest::TestNonpositiveMultiplier() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols US(Locale::getUS(), status);\n    CHECK(status, \"DecimalFormatSymbols constructor\");\n    DecimalFormat df(UnicodeString(\"0\"), US, status);\n    CHECK(status, \"DecimalFormat(0)\");\n\n    // test zero multiplier\n\n    int32_t mult = df.getMultiplier();\n    df.setMultiplier(0);\n    if (df.getMultiplier() != mult) {\n        errln(\"DecimalFormat.setMultiplier(0) did not ignore its zero input\");\n    }\n\n    // test negative multiplier\n\n    df.setMultiplier(-1);\n    if (df.getMultiplier() != -1) {\n        errln(\"DecimalFormat.setMultiplier(-1) ignored its negative input\");\n        return;\n    }\n\n    expect(df, \"1122.123\", -1122.123);\n    expect(df, \"-1122.123\", 1122.123);\n    expect(df, \"1.2\", -1.2);\n    expect(df, \"-1.2\", 1.2);\n\n    // Note:  the tests with the final parameter of FALSE will not round trip.\n    //        The initial numeric value will format correctly, after the multiplier.\n    //        Parsing the formatted text will be out-of-range for an int64, however.\n    //        The expect() function could be modified to detect this and fall back\n    //        to looking at the decimal parsed value, but it doesn't.\n    expect(df, U_INT64_MIN,    \"9223372036854775808\", FALSE);\n    expect(df, U_INT64_MIN+1,  \"9223372036854775807\");\n    expect(df, (int64_t)-123,                  \"123\");\n    expect(df, (int64_t)123,                  \"-123\");\n    expect(df, U_INT64_MAX-1, \"-9223372036854775806\");\n    expect(df, U_INT64_MAX,   \"-9223372036854775807\");\n\n    df.setMultiplier(-2);\n    expect(df, -(U_INT64_MIN/2)-1, \"-9223372036854775806\");\n    expect(df, -(U_INT64_MIN/2),   \"-9223372036854775808\");\n    expect(df, -(U_INT64_MIN/2)+1, \"-9223372036854775810\", FALSE);\n\n    df.setMultiplier(-7);\n    expect(df, -(U_INT64_MAX/7)-1, \"9223372036854775814\", FALSE);\n    expect(df, -(U_INT64_MAX/7),   \"9223372036854775807\");\n    expect(df, -(U_INT64_MAX/7)+1, \"9223372036854775800\");\n\n    // TODO: uncomment (and fix up) all the following int64_t tests once BigInteger is ported\n    // (right now the big numbers get turned into doubles and lose tons of accuracy)\n    //expect2(df, U_INT64_MAX, Int64ToUnicodeString(-U_INT64_MAX));\n    //expect2(df, U_INT64_MIN, UnicodeString(Int64ToUnicodeString(U_INT64_MIN), 1));\n    //expect2(df, U_INT64_MAX / 2, Int64ToUnicodeString(-(U_INT64_MAX / 2)));\n    //expect2(df, U_INT64_MIN / 2, Int64ToUnicodeString(-(U_INT64_MIN / 2)));\n\n    // TODO: uncomment (and fix up) once BigDecimal is ported and DecimalFormat can handle it\n    //expect2(df, BigDecimal.valueOf(Long.MAX_VALUE), BigDecimal.valueOf(Long.MAX_VALUE).negate().toString());\n    //expect2(df, BigDecimal.valueOf(Long.MIN_VALUE), BigDecimal.valueOf(Long.MIN_VALUE).negate().toString());\n    //expect2(df, java.math.BigDecimal.valueOf(Long.MAX_VALUE), java.math.BigDecimal.valueOf(Long.MAX_VALUE).negate().toString());\n    //expect2(df, java.math.BigDecimal.valueOf(Long.MIN_VALUE), java.math.BigDecimal.valueOf(Long.MIN_VALUE).negate().toString());\n}\n\ntypedef struct {\n    const char * stringToParse;\n    int          parsedPos;\n    int          errorIndex;\n    UBool        lenient;\n} TestSpaceParsingItem;\n\nvoid\nNumberFormatTest::TestSpaceParsing() {\n    // the data are:\n    // the string to be parsed, parsed position, parsed error index\n    const TestSpaceParsingItem DATA[] = {\n        {\"$124\",           4, -1, FALSE},\n        {\"$124 $124\",      4, -1, FALSE},\n        {\"$124 \",          4, -1, FALSE},\n        {\"$ 124 \",         0,  1, FALSE},\n        {\"$\\\\u00A0124 \",   5, -1, FALSE},\n        {\" $ 124 \",        0,  0, FALSE},\n        {\"124$\",           0,  4, FALSE},\n        {\"124 $\",          0,  3, FALSE},\n        {\"$124\",           4, -1, TRUE},\n        {\"$124 $124\",      4, -1, TRUE},\n        {\"$124 \",          4, -1, TRUE},\n        {\"$ 124 \",         5, -1, TRUE},\n        {\"$\\\\u00A0124 \",   5, -1, TRUE},\n        {\" $ 124 \",        6, -1, TRUE},\n        {\"124$\",           4, -1, TRUE},\n        {\"124$\",           4, -1, TRUE},\n        {\"124 $\",          5, -1, TRUE},\n        {\"124 $\",          5, -1, TRUE},\n    };\n    UErrorCode status = U_ZERO_ERROR;\n    Locale locale(\"en_US\");\n    NumberFormat* foo = NumberFormat::createCurrencyInstance(locale, status);\n\n    if (U_FAILURE(status)) {\n        delete foo;\n        return;\n    }\n    for (uint32_t i = 0; i < UPRV_LENGTHOF(DATA); ++i) {\n        ParsePosition parsePosition(0);\n        UnicodeString stringToBeParsed = ctou(DATA[i].stringToParse);\n        int parsedPosition = DATA[i].parsedPos;\n        int errorIndex = DATA[i].errorIndex;\n        foo->setLenient(DATA[i].lenient);\n        Formattable result;\n        foo->parse(stringToBeParsed, result, parsePosition);\n        logln(\"Parsing: \" + stringToBeParsed);\n        if (parsePosition.getIndex() != parsedPosition ||\n            parsePosition.getErrorIndex() != errorIndex) {\n            errln(\"FAILED parse \" + stringToBeParsed + \"; lenient: \" + DATA[i].lenient + \"; wrong position, expected: (\" + parsedPosition + \", \" + errorIndex + \"); got (\" + parsePosition.getIndex() + \", \" + parsePosition.getErrorIndex() + \")\");\n        }\n        if (parsePosition.getErrorIndex() == -1 &&\n            result.getType() == Formattable::kLong &&\n            result.getLong() != 124) {\n            errln(\"FAILED parse \" + stringToBeParsed + \"; wrong number, expect: 124, got \" + result.getLong());\n        }\n    }\n    delete foo;\n}\n\n/**\n * Test using various numbering systems and numbering system keyword.\n */\ntypedef struct {\n    const char *localeName;\n    double      value;\n    UBool        isRBNF;\n    const char *expectedResult;\n} TestNumberingSystemItem;\n\nvoid NumberFormatTest::TestNumberingSystems() {\n\n    const TestNumberingSystemItem DATA[] = {\n        { \"en_US@numbers=thai\", 1234.567, FALSE, \"\\\\u0E51,\\\\u0E52\\\\u0E53\\\\u0E54.\\\\u0E55\\\\u0E56\\\\u0E57\" },\n        { \"en_US@numbers=hebr\", 5678.0, TRUE, \"\\\\u05D4\\\\u05F3\\\\u05EA\\\\u05E8\\\\u05E2\\\\u05F4\\\\u05D7\" },\n        { \"en_US@numbers=arabext\", 1234.567, FALSE, \"\\\\u06F1\\\\u066c\\\\u06F2\\\\u06F3\\\\u06F4\\\\u066b\\\\u06F5\\\\u06F6\\\\u06F7\" },\n        { \"ar_EG\", 1234.567, FALSE, \"\\\\u0661\\\\u066C\\\\u0662\\\\u0663\\\\u0664\\\\u066b\\\\u0665\\\\u0666\\\\u0667\" },\n        { \"th_TH@numbers=traditional\", 1234.567, FALSE, \"\\\\u0E51,\\\\u0E52\\\\u0E53\\\\u0E54.\\\\u0E55\\\\u0E56\\\\u0E57\" }, // fall back to native per TR35\n        { \"ar_MA\", 1234.567, FALSE, \"1.234,567\" },\n        { \"en_US@numbers=hanidec\", 1234.567, FALSE, \"\\\\u4e00,\\\\u4e8c\\\\u4e09\\\\u56db.\\\\u4e94\\\\u516d\\\\u4e03\" },\n        { \"ta_IN@numbers=native\", 1234.567, FALSE, \"\\\\u0BE7,\\\\u0BE8\\\\u0BE9\\\\u0BEA.\\\\u0BEB\\\\u0BEC\\\\u0BED\" },\n        { \"ta_IN@numbers=traditional\", 1235.0, TRUE, \"\\\\u0BF2\\\\u0BE8\\\\u0BF1\\\\u0BE9\\\\u0BF0\\\\u0BEB\" },\n        { \"ta_IN@numbers=finance\", 1234.567, FALSE, \"1,234.567\" }, // fall back to default per TR35\n        { \"zh_TW@numbers=native\", 1234.567, FALSE, \"\\\\u4e00,\\\\u4e8c\\\\u4e09\\\\u56db.\\\\u4e94\\\\u516d\\\\u4e03\" },\n        { \"zh_TW@numbers=traditional\", 1234.567, TRUE, \"\\\\u4E00\\\\u5343\\\\u4E8C\\\\u767E\\\\u4E09\\\\u5341\\\\u56DB\\\\u9EDE\\\\u4E94\\\\u516D\\\\u4E03\" },\n        { \"zh_TW@numbers=finance\", 1234.567, TRUE, \"\\\\u58F9\\\\u4EDF\\\\u8CB3\\\\u4F70\\\\u53C3\\\\u62FE\\\\u8086\\\\u9EDE\\\\u4F0D\\\\u9678\\\\u67D2\" },\n        { NULL, 0, FALSE, NULL }\n    };\n\n    UErrorCode ec;\n\n    const TestNumberingSystemItem *item;\n    for (item = DATA; item->localeName != NULL; item++) {\n        ec = U_ZERO_ERROR;\n        Locale loc = Locale::createFromName(item->localeName);\n\n        NumberFormat *origFmt = NumberFormat::createInstance(loc,ec);\n        if (U_FAILURE(ec)) {\n            dataerrln(\"FAIL: getInstance(%s) - %s\", item->localeName, u_errorName(ec));\n            continue;\n        }\n        // Clone to test ticket #10682\n        NumberFormat *fmt = (NumberFormat *) origFmt->clone();\n        delete origFmt;\n\n\n        if (item->isRBNF) {\n            expect3(*fmt,item->value,CharsToUnicodeString(item->expectedResult));\n        } else {\n            expect2(*fmt,item->value,CharsToUnicodeString(item->expectedResult));\n        }\n        delete fmt;\n    }\n\n\n    // Test bogus keyword value\n    ec = U_ZERO_ERROR;\n    Locale loc4 = Locale::createFromName(\"en_US@numbers=foobar\");\n    NumberFormat* fmt4= NumberFormat::createInstance(loc4, ec);\n    if ( ec != U_UNSUPPORTED_ERROR ) {\n        errln(\"FAIL: getInstance(en_US@numbers=foobar) should have returned U_UNSUPPORTED_ERROR\");\n        delete fmt4;\n    }\n\n    ec = U_ZERO_ERROR;\n    NumberingSystem *ns = NumberingSystem::createInstance(ec);\n    if (U_FAILURE(ec)) {\n        dataerrln(\"FAIL: NumberingSystem::createInstance(ec); - %s\", u_errorName(ec));\n    }\n\n    if ( ns != NULL ) {\n        ns->getDynamicClassID();\n        ns->getStaticClassID();\n    } else {\n        errln(\"FAIL: getInstance() returned NULL.\");\n    }\n\n    NumberingSystem *ns1 = new NumberingSystem(*ns);\n    if (ns1 == NULL) {\n        errln(\"FAIL: NumberSystem copy constructor returned NULL.\");\n    }\n\n    delete ns1;\n    delete ns;\n\n}\n\n\nvoid\nNumberFormatTest::TestMultiCurrencySign() {\n    const char* DATA[][6] = {\n        // the fields in the following test are:\n        // locale,\n        // currency pattern (with negative pattern),\n        // currency number to be formatted,\n        // currency format using currency symbol name, such as \"$\" for USD,\n        // currency format using currency ISO name, such as \"USD\",\n        // currency format using plural name, such as \"US dollars\".\n        // for US locale\n        {\"en_US\", \"\\\\u00A4#,##0.00;-\\\\u00A4#,##0.00\", \"1234.56\", \"$1,234.56\", \"USD\\\\u00A01,234.56\", \"US dollars\\\\u00A01,234.56\"},\n        {\"en_US\", \"\\\\u00A4#,##0.00;-\\\\u00A4#,##0.00\", \"-1234.56\", \"-$1,234.56\", \"-USD\\\\u00A01,234.56\", \"-US dollars\\\\u00A01,234.56\"},\n        {\"en_US\", \"\\\\u00A4#,##0.00;-\\\\u00A4#,##0.00\", \"1\", \"$1.00\", \"USD\\\\u00A01.00\", \"US dollars\\\\u00A01.00\"},\n        // for CHINA locale\n        {\"zh_CN\", \"\\\\u00A4#,##0.00;(\\\\u00A4#,##0.00)\", \"1234.56\", \"\\\\uFFE51,234.56\", \"CNY\\\\u00A01,234.56\", \"\\\\u4EBA\\\\u6C11\\\\u5E01\\\\u00A01,234.56\"},\n        {\"zh_CN\", \"\\\\u00A4#,##0.00;(\\\\u00A4#,##0.00)\", \"-1234.56\", \"(\\\\uFFE51,234.56)\", \"(CNY\\\\u00A01,234.56)\", \"(\\\\u4EBA\\\\u6C11\\\\u5E01\\\\u00A01,234.56)\"},\n        {\"zh_CN\", \"\\\\u00A4#,##0.00;(\\\\u00A4#,##0.00)\", \"1\", \"\\\\uFFE51.00\", \"CNY\\\\u00A01.00\", \"\\\\u4EBA\\\\u6C11\\\\u5E01\\\\u00A01.00\"}\n    };\n\n    const UChar doubleCurrencySign[] = {0xA4, 0xA4, 0};\n    UnicodeString doubleCurrencyStr(doubleCurrencySign);\n    const UChar tripleCurrencySign[] = {0xA4, 0xA4, 0xA4, 0};\n    UnicodeString tripleCurrencyStr(tripleCurrencySign);\n\n    for (uint32_t i=0; i<UPRV_LENGTHOF(DATA); ++i) {\n        const char* locale = DATA[i][0];\n        UnicodeString pat = ctou(DATA[i][1]);\n        double numberToBeFormat = atof(DATA[i][2]);\n        UErrorCode status = U_ZERO_ERROR;\n        DecimalFormatSymbols* sym = new DecimalFormatSymbols(Locale(locale), status);\n        if (U_FAILURE(status)) {\n            delete sym;\n            continue;\n        }\n        for (int j=1; j<=3; ++j) {\n            // j represents the number of currency sign in the pattern.\n            if (j == 2) {\n                pat = pat.findAndReplace(ctou(\"\\\\u00A4\"), doubleCurrencyStr);\n            } else if (j == 3) {\n                pat = pat.findAndReplace(ctou(\"\\\\u00A4\\\\u00A4\"), tripleCurrencyStr);\n            }\n\n            DecimalFormat* fmt = new DecimalFormat(pat, new DecimalFormatSymbols(*sym), status);\n            if (U_FAILURE(status)) {\n                errln(\"FAILED init DecimalFormat \");\n                delete fmt;\n                continue;\n            }\n            UnicodeString s;\n            ((NumberFormat*) fmt)->format(numberToBeFormat, s);\n            // DATA[i][3] is the currency format result using a\n            // single currency sign.\n            // DATA[i][4] is the currency format result using\n            // double currency sign.\n            // DATA[i][5] is the currency format result using\n            // triple currency sign.\n            // DATA[i][j+2] is the currency format result using\n            // 'j' number of currency sign.\n            UnicodeString currencyFormatResult = ctou(DATA[i][2+j]);\n            if (s.compare(currencyFormatResult)) {\n                errln(\"FAIL format: Expected \" + currencyFormatResult + \"; Got \" + s);\n            }\n            // mix style parsing\n            for (int k=3; k<=5; ++k) {\n              // DATA[i][3] is the currency format result using a\n              // single currency sign.\n              // DATA[i][4] is the currency format result using\n              // double currency sign.\n              // DATA[i][5] is the currency format result using\n              // triple currency sign.\n              UnicodeString oneCurrencyFormat = ctou(DATA[i][k]);\n              UErrorCode status = U_ZERO_ERROR;\n              Formattable parseRes;\n              fmt->parse(oneCurrencyFormat, parseRes, status);\n              if (U_FAILURE(status) ||\n                  (parseRes.getType() == Formattable::kDouble &&\n                   parseRes.getDouble() != numberToBeFormat) ||\n                  (parseRes.getType() == Formattable::kLong &&\n                   parseRes.getLong() != numberToBeFormat)) {\n                  errln(\"FAILED parse \" + oneCurrencyFormat + \"; (i, j, k): \" +\n                        i + \", \" + j + \", \" + k);\n              }\n            }\n            delete fmt;\n        }\n        delete sym;\n    }\n}\n\n\nvoid\nNumberFormatTest::TestCurrencyFormatForMixParsing() {\n    UErrorCode status = U_ZERO_ERROR;\n    MeasureFormat* curFmt = MeasureFormat::createCurrencyFormat(Locale(\"en_US\"), status);\n    if (U_FAILURE(status)) {\n        delete curFmt;\n        return;\n    }\n    const char* formats[] = {\n        \"$1,234.56\",  // string to be parsed\n        \"USD1,234.56\",\n        \"US dollars1,234.56\",\n        // \"1,234.56 US dollars\" // Fails in 62 because currency format is not compatible with pattern.\n    };\n    const CurrencyAmount* curramt = NULL;\n    for (uint32_t i = 0; i < UPRV_LENGTHOF(formats); ++i) {\n        UnicodeString stringToBeParsed = ctou(formats[i]);\n        logln(UnicodeString(\"stringToBeParsed: \") + stringToBeParsed);\n        Formattable result;\n        UErrorCode status = U_ZERO_ERROR;\n        curFmt->parseObject(stringToBeParsed, result, status);\n        if (U_FAILURE(status)) {\n          errln(\"FAIL: measure format parsing: '%s' ec: %s\", formats[i], u_errorName(status));\n        } else if (result.getType() != Formattable::kObject ||\n            (curramt = dynamic_cast<const CurrencyAmount*>(result.getObject())) == NULL ||\n            curramt->getNumber().getDouble() != 1234.56 ||\n            UnicodeString(curramt->getISOCurrency()).compare(ISO_CURRENCY_USD)\n        ) {\n            errln(\"FAIL: getCurrencyFormat of default locale (en_US) failed roundtripping the number \");\n            if (curramt->getNumber().getDouble() != 1234.56) {\n                errln((UnicodeString)\"wong number, expect: 1234.56\" + \", got: \" + curramt->getNumber().getDouble());\n            }\n            if (curramt->getISOCurrency() != ISO_CURRENCY_USD) {\n                errln((UnicodeString)\"wong currency, expect: USD\" + \", got: \" + curramt->getISOCurrency());\n            }\n        }\n    }\n    delete curFmt;\n}\n\n\n/** Starting in ICU 62, strict mode is actually strict with currency formats. */\nvoid NumberFormatTest::TestMismatchedCurrencyFormatFail() {\n    IcuTestErrorCode status(*this, \"TestMismatchedCurrencyFormatFail\");\n    LocalPointer<DecimalFormat> df(\n            dynamic_cast<DecimalFormat*>(DecimalFormat::createCurrencyInstance(\"en\", status)), status);\n    if (!assertSuccess(\"createCurrencyInstance() failed.\", status, true, __FILE__, __LINE__)) {return;}\n    UnicodeString pattern;\n    assertEquals(\"Test assumes that currency sign is at the beginning\",\n            u\"\\u00A4#,##0.00\",\n            df->toPattern(pattern));\n    // Should round-trip on the correct currency format:\n    expect2(*df, 1.23, u\"\\u00A41.23\");\n    df->setCurrency(u\"EUR\", status);\n    expect2(*df, 1.23, u\"\\u20AC1.23\");\n    // Should parse with currency in the wrong place in lenient mode\n    df->setLenient(TRUE);\n    expect(*df, u\"1.23\\u20AC\", 1.23);\n    expectParseCurrency(*df, u\"EUR\", 1.23, \"1.23\\\\u20AC\");\n    // Should NOT parse with currency in the wrong place in STRICT mode\n    df->setLenient(FALSE);\n    {\n        Formattable result;\n        ErrorCode failStatus;\n        df->parse(u\"1.23\\u20AC\", result, failStatus);\n        assertEquals(\"Should fail to parse\", U_INVALID_FORMAT_ERROR, failStatus);\n    }\n    {\n        ParsePosition ppos;\n        df->parseCurrency(u\"1.23\\u20AC\", ppos);\n        assertEquals(\"Should fail to parse currency\", 0, ppos.getIndex());\n    }\n}\n\n\nvoid\nNumberFormatTest::TestDecimalFormatCurrencyParse() {\n    // Locale.US\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols* sym = new DecimalFormatSymbols(Locale(\"en_US\"), status);\n    if (U_FAILURE(status)) {\n        delete sym;\n        return;\n    }\n    UnicodeString pat;\n    UChar currency = 0x00A4;\n    // \"\\xA4#,##0.00;-\\xA4#,##0.00\"\n    pat.append(currency).append(currency).append(currency).append(\"#,##0.00;-\").append(currency).append(currency).append(currency).append(\"#,##0.00\");\n    DecimalFormat* fmt = new DecimalFormat(pat, sym, status);\n    if (U_FAILURE(status)) {\n        delete fmt;\n        errln(\"failed to new DecimalFormat in TestDecimalFormatCurrencyParse\");\n        return;\n    }\n    const char* DATA[][2] = {\n        // the data are:\n        // string to be parsed, the parsed result (number)\n        {\"$1.00\", \"1\"},\n        {\"USD1.00\", \"1\"},\n        {\"1.00 US dollar\", \"1\"},\n        {\"$1,234.56\", \"1234.56\"},\n        {\"USD1,234.56\", \"1234.56\"},\n        {\"1,234.56 US dollar\", \"1234.56\"},\n    };\n    // NOTE: ICU 62 requires that the currency format match the pattern in strict mode.\n    fmt->setLenient(TRUE);\n    for (uint32_t i = 0; i < UPRV_LENGTHOF(DATA); ++i) {\n        UnicodeString stringToBeParsed = ctou(DATA[i][0]);\n        double parsedResult = atof(DATA[i][1]);\n        UErrorCode status = U_ZERO_ERROR;\n        Formattable result;\n        fmt->parse(stringToBeParsed, result, status);\n        logln((UnicodeString)\"Input: \" + stringToBeParsed + \"; output: \" + result.getDouble(status));\n        if (U_FAILURE(status) ||\n            (result.getType() == Formattable::kDouble &&\n            result.getDouble() != parsedResult) ||\n            (result.getType() == Formattable::kLong &&\n            result.getLong() != parsedResult)) {\n            errln((UnicodeString)\"FAIL parse: Expected \" + parsedResult);\n        }\n    }\n    delete fmt;\n}\n\n\nvoid\nNumberFormatTest::TestCurrencyIsoPluralFormat() {\n    static const char* DATA[][6] = {\n        // the data are:\n        // locale,\n        // currency amount to be formatted,\n        // currency ISO code to be formatted,\n        // format result using CURRENCYSTYLE,\n        // format result using ISOCURRENCYSTYLE,\n        // format result using PLURALCURRENCYSTYLE,\n\n        {\"en_US\", \"1\", \"USD\", \"$1.00\", \"USD\\\\u00A01.00\", \"1.00 US dollars\"},\n        {\"en_US\", \"1234.56\", \"USD\", \"$1,234.56\", \"USD\\\\u00A01,234.56\", \"1,234.56 US dollars\"},\n        {\"en_US\", \"-1234.56\", \"USD\", \"-$1,234.56\", \"-USD\\\\u00A01,234.56\", \"-1,234.56 US dollars\"},\n        {\"zh_CN\", \"1\", \"USD\", \"US$1.00\", \"USD\\\\u00A01.00\", \"1.00\\\\u00A0\\\\u7F8E\\\\u5143\"},\n        {\"zh_CN\", \"1234.56\", \"USD\", \"US$1,234.56\", \"USD\\\\u00A01,234.56\", \"1,234.56\\\\u00A0\\\\u7F8E\\\\u5143\"},\n        {\"zh_CN\", \"1\", \"CNY\", \"\\\\uFFE51.00\", \"CNY\\\\u00A01.00\", \"1.00\\\\u00A0\\\\u4EBA\\\\u6C11\\\\u5E01\"},\n        {\"zh_CN\", \"1234.56\", \"CNY\", \"\\\\uFFE51,234.56\", \"CNY\\\\u00A01,234.56\", \"1,234.56\\\\u00A0\\\\u4EBA\\\\u6C11\\\\u5E01\"},\n        {\"ru_RU\", \"1\", \"RUB\", \"1,00\\\\u00A0\\\\u20BD\", \"1,00\\\\u00A0RUB\", \"1,00 \\\\u0440\\\\u043E\\\\u0441\\\\u0441\\\\u0438\\\\u0439\\\\u0441\\\\u043A\\\\u043E\\\\u0433\\\\u043E \\\\u0440\\\\u0443\\\\u0431\\\\u043B\\\\u044F\"},\n        {\"ru_RU\", \"2\", \"RUB\", \"2,00\\\\u00A0\\\\u20BD\", \"2,00\\\\u00A0RUB\", \"2,00 \\\\u0440\\\\u043E\\\\u0441\\\\u0441\\\\u0438\\\\u0439\\\\u0441\\\\u043A\\\\u043E\\\\u0433\\\\u043E \\\\u0440\\\\u0443\\\\u0431\\\\u043B\\\\u044F\"},\n        {\"ru_RU\", \"5\", \"RUB\", \"5,00\\\\u00A0\\\\u20BD\", \"5,00\\\\u00A0RUB\", \"5,00 \\\\u0440\\\\u043E\\\\u0441\\\\u0441\\\\u0438\\\\u0439\\\\u0441\\\\u043A\\\\u043E\\\\u0433\\\\u043E \\\\u0440\\\\u0443\\\\u0431\\\\u043B\\\\u044F\"},\n        // test locale without currency information\n        {\"root\", \"-1.23\", \"USD\", \"-US$\\\\u00A01.23\", \"-USD\\\\u00A01.23\", \"-1.23 USD\"},\n        // test choice format\n        {\"es_AR\", \"1\", \"INR\", \"INR\\\\u00A01,00\", \"INR\\\\u00A01,00\", \"1,00 rupia india\"},\n    };\n    static const UNumberFormatStyle currencyStyles[] = {\n        UNUM_CURRENCY,\n        UNUM_CURRENCY_ISO,\n        UNUM_CURRENCY_PLURAL\n    };\n\n    for (int32_t i=0; i<UPRV_LENGTHOF(DATA); ++i) {\n      const char* localeString = DATA[i][0];\n      double numberToBeFormat = atof(DATA[i][1]);\n      const char* currencyISOCode = DATA[i][2];\n      logln(UnicodeString(u\"Locale: \") + localeString + \"; amount: \" + numberToBeFormat);\n      Locale locale(localeString);\n      for (int32_t kIndex = 0; kIndex < UPRV_LENGTHOF(currencyStyles); ++kIndex) {\n        UNumberFormatStyle k = currencyStyles[kIndex];\n        logln(UnicodeString(u\"UNumberFormatStyle: \") + k);\n        UErrorCode status = U_ZERO_ERROR;\n        NumberFormat* numFmt = NumberFormat::createInstance(locale, k, status);\n        if (U_FAILURE(status)) {\n            delete numFmt;\n            dataerrln((UnicodeString)\"can not create instance, locale:\" + localeString + \", style: \" + k + \" - \" + u_errorName(status));\n            continue;\n        }\n        UChar currencyCode[4];\n        u_charsToUChars(currencyISOCode, currencyCode, 4);\n        numFmt->setCurrency(currencyCode, status);\n        if (U_FAILURE(status)) {\n            delete numFmt;\n            errln((UnicodeString)\"can not set currency:\" + currencyISOCode);\n            continue;\n        }\n\n        UnicodeString strBuf;\n        numFmt->format(numberToBeFormat, strBuf);\n        int resultDataIndex = 3 + kIndex;\n        // DATA[i][resultDataIndex] is the currency format result\n        // using 'k' currency style.\n        UnicodeString formatResult = ctou(DATA[i][resultDataIndex]);\n        if (strBuf.compare(formatResult)) {\n            errln(\"FAIL: Expected \" + formatResult + \" actual: \" + strBuf);\n        }\n        // test parsing, and test parsing for all currency formats.\n        // NOTE: ICU 62 requires that the currency format match the pattern in strict mode.\n        numFmt->setLenient(TRUE);\n        for (int j = 3; j < 6; ++j) {\n            // DATA[i][3] is the currency format result using\n            // CURRENCYSTYLE formatter.\n            // DATA[i][4] is the currency format result using\n            // ISOCURRENCYSTYLE formatter.\n            // DATA[i][5] is the currency format result using\n            // PLURALCURRENCYSTYLE formatter.\n            UnicodeString oneCurrencyFormatResult = ctou(DATA[i][j]);\n            UErrorCode status = U_ZERO_ERROR;\n            Formattable parseResult;\n            numFmt->parse(oneCurrencyFormatResult, parseResult, status);\n            if (U_FAILURE(status) ||\n                (parseResult.getType() == Formattable::kDouble &&\n                 parseResult.getDouble() != numberToBeFormat) ||\n                (parseResult.getType() == Formattable::kLong &&\n                 parseResult.getLong() != numberToBeFormat)) {\n                errln((UnicodeString)\"FAIL: getCurrencyFormat of locale \" +\n                      localeString + \" failed roundtripping the number\");\n                if (parseResult.getType() == Formattable::kDouble) {\n                    errln((UnicodeString)\"expected: \" + numberToBeFormat + \"; actual: \" +parseResult.getDouble());\n                } else {\n                    errln((UnicodeString)\"expected: \" + numberToBeFormat + \"; actual: \" +parseResult.getLong());\n                }\n            }\n        }\n        delete numFmt;\n      }\n    }\n}\n\nvoid\nNumberFormatTest::TestCurrencyParsing() {\n    static const char* DATA[][6] = {\n        // the data are:\n        // locale,\n        // currency amount to be formatted,\n        // currency ISO code to be formatted,\n        // format result using CURRENCYSTYLE,\n        // format result using ISOCURRENCYSTYLE,\n        // format result using PLURALCURRENCYSTYLE,\n        {\"en_US\", \"1\", \"USD\", \"$1.00\", \"USD\\\\u00A01.00\", \"1.00 US dollars\"},\n        {\"pa_IN\", \"1\", \"USD\", \"US$\\\\u00A01.00\", \"USD\\\\u00A01.00\", \"1.00 \\\\u0a2f\\\\u0a42.\\\\u0a10\\\\u0a38. \\\\u0a21\\\\u0a3e\\\\u0a32\\\\u0a30\"},\n        {\"es_AR\", \"1\", \"USD\", \"US$\\\\u00A01,00\", \"USD\\\\u00A01,00\", \"1,00 d\\\\u00f3lar estadounidense\"},\n        {\"ar_EG\", \"1\", \"USD\", \"\\\\u0661\\\\u066b\\\\u0660\\\\u0660\\\\u00a0US$\", \"\\\\u0661\\\\u066b\\\\u0660\\\\u0660\\\\u00a0USD\", \"\\\\u0661\\\\u066b\\\\u0660\\\\u0660 \\\\u062f\\\\u0648\\\\u0644\\\\u0627\\\\u0631 \\\\u0623\\\\u0645\\\\u0631\\\\u064a\\\\u0643\\\\u064a\"},\n        {\"fa_CA\", \"1\", \"USD\", \"\\\\u200e$\\\\u06f1\\\\u066b\\\\u06f0\\\\u06f0\", \"\\\\u200eUSD\\\\u06f1\\\\u066b\\\\u06f0\\\\u06f0\", \"\\\\u06f1\\\\u066b\\\\u06f0\\\\u06f0 \\\\u062f\\\\u0644\\\\u0627\\\\u0631 \\\\u0627\\\\u0645\\\\u0631\\\\u06cc\\\\u06a9\\\\u0627\"},\n        {\"he_IL\", \"1\", \"USD\", \"\\\\u200f1.00\\\\u00a0$\", \"\\\\u200f1.00\\\\u00a0USD\", \"1.00 \\\\u05d3\\\\u05d5\\\\u05dc\\\\u05e8 \\\\u05d0\\\\u05de\\\\u05e8\\\\u05d9\\\\u05e7\\\\u05d0\\\\u05d9\"},\n        {\"hr_HR\", \"1\", \"USD\", \"1,00\\\\u00a0USD\", \"1,00\\\\u00a0USD\", \"1,00 ameri\\\\u010Dkih dolara\"},\n        {\"id_ID\", \"1\", \"USD\", \"US$\\\\u00A01,00\", \"USD\\\\u00A01,00\", \"1,00 Dolar Amerika Serikat\"},\n        {\"it_IT\", \"1\", \"USD\", \"1,00\\\\u00a0USD\", \"1,00\\\\u00a0USD\", \"1,00 dollari statunitensi\"},\n        {\"ko_KR\", \"1\", \"USD\", \"US$\\\\u00A01.00\", \"USD\\\\u00A01.00\", \"1.00 \\\\ubbf8\\\\uad6d \\\\ub2ec\\\\ub7ec\"},\n        {\"ja_JP\", \"1\", \"USD\", \"$1.00\", \"USD\\\\u00A01.00\", \"1.00\\\\u00A0\\\\u7c73\\\\u30c9\\\\u30eb\"},\n        {\"zh_CN\", \"1\", \"CNY\", \"\\\\uFFE51.00\", \"CNY\\\\u00A001.00\", \"1.00\\\\u00A0\\\\u4EBA\\\\u6C11\\\\u5E01\"},\n        {\"zh_TW\", \"1\", \"CNY\", \"CN\\\\u00A51.00\", \"CNY\\\\u00A01.00\", \"1.00 \\\\u4eba\\\\u6c11\\\\u5e63\"},\n        {\"zh_Hant\", \"1\", \"CNY\", \"CN\\\\u00A51.00\", \"CNY\\\\u00A01.00\", \"1.00 \\\\u4eba\\\\u6c11\\\\u5e63\"},\n        {\"zh_Hant\", \"1\", \"JPY\", \"\\\\u00A51.00\", \"JPY\\\\u00A01.00\", \"1 \\\\u65E5\\\\u5713\"},\n        {\"ja_JP\", \"1\", \"JPY\", \"\\\\uFFE51.00\", \"JPY\\\\u00A01.00\", \"1\\\\u00A0\\\\u5186\"},\n        // ICU 62 requires #parseCurrency() to recognize variants when parsing\n        // {\"ja_JP\", \"1\", \"JPY\", \"\\\\u00A51.00\", \"JPY\\\\u00A01.00\", \"1\\\\u00A0\\\\u5186\"},\n        {\"ru_RU\", \"1\", \"RUB\", \"1,00\\\\u00A0\\\\u00A0\\\\u20BD\", \"1,00\\\\u00A0\\\\u00A0RUB\", \"1,00 \\\\u0440\\\\u043E\\\\u0441\\\\u0441\\\\u0438\\\\u0439\\\\u0441\\\\u043A\\\\u043E\\\\u0433\\\\u043E \\\\u0440\\\\u0443\\\\u0431\\\\u043B\\\\u044F\"}\n    };\n    static const UNumberFormatStyle currencyStyles[] = {\n        UNUM_CURRENCY,\n        UNUM_CURRENCY_ISO,\n        UNUM_CURRENCY_PLURAL\n    };\n    static const char* currencyStyleNames[] = {\n      \"UNUM_CURRENCY\",\n      \"UNUM_CURRENCY_ISO\",\n      \"UNUM_CURRENCY_PLURAL\"\n    };\n\n#ifdef NUMFMTST_CACHE_DEBUG\nint deadloop = 0;\nfor (;;) {\n    printf(\"loop: %d\\n\", deadloop++);\n#endif\n    for (uint32_t i=0; i< UPRV_LENGTHOF(DATA); ++i) {  /* i = test case #  - should be i=0*/\n      for (int32_t kIndex = 2; kIndex < UPRV_LENGTHOF(currencyStyles); ++kIndex) {\n        UNumberFormatStyle k = currencyStyles[kIndex]; /* k = style */\n        const char* localeString = DATA[i][0];\n        double numberToBeFormat = atof(DATA[i][1]);\n        const char* currencyISOCode = DATA[i][2];\n        Locale locale(localeString);\n        UErrorCode status = U_ZERO_ERROR;\n        NumberFormat* numFmt = NumberFormat::createInstance(locale, k, status);\n        logln(\"#%d NumberFormat(%s, %s) Currency=%s\\n\",\n              i, localeString, currencyStyleNames[kIndex],\n              currencyISOCode);\n\n        if (U_FAILURE(status)) {\n            delete numFmt;\n            dataerrln((UnicodeString)\"can not create instance, locale:\" + localeString + \", style: \" + k + \" - \" + u_errorName(status));\n            continue;\n        }\n        UChar currencyCode[4];\n        u_charsToUChars(currencyISOCode, currencyCode, 4);\n        numFmt->setCurrency(currencyCode, status);\n        if (U_FAILURE(status)) {\n            delete numFmt;\n            errln((UnicodeString)\"can not set currency:\" + currencyISOCode);\n            continue;\n        }\n\n        UnicodeString strBuf;\n        numFmt->format(numberToBeFormat, strBuf);\n        int resultDataIndex = 3 + kIndex;\n        // DATA[i][resultDataIndex] is the currency format result\n        // using 'k' currency style.\n        UnicodeString formatResult = ctou(DATA[i][resultDataIndex]);\n        if (strBuf.compare(formatResult)) {\n            errln(\"FAIL: Expected \" + formatResult + \" actual: \" + strBuf);\n        }\n        // test parsing, and test parsing for all currency formats.\n        // NOTE: ICU 62 requires that the currency format match the pattern in strict mode.\n        numFmt->setLenient(TRUE);\n        for (int j = 3; j < 6; ++j) {\n            // DATA[i][3] is the currency format result using\n            // CURRENCYSTYLE formatter.\n            // DATA[i][4] is the currency format result using\n            // ISOCURRENCYSTYLE formatter.\n            // DATA[i][5] is the currency format result using\n            // PLURALCURRENCYSTYLE formatter.\n            UnicodeString oneCurrencyFormatResult = ctou(DATA[i][j]);\n            UErrorCode status = U_ZERO_ERROR;\n            Formattable parseResult;\n            logln(\"parse(%s)\", DATA[i][j]);\n            numFmt->parse(oneCurrencyFormatResult, parseResult, status);\n            if (U_FAILURE(status) ||\n                (parseResult.getType() == Formattable::kDouble &&\n                 parseResult.getDouble() != numberToBeFormat) ||\n                (parseResult.getType() == Formattable::kLong &&\n                 parseResult.getLong() != numberToBeFormat)) {\n                errln((UnicodeString)\"FAIL: NumberFormat(\" + localeString +\", \" + currencyStyleNames[kIndex] +\n                      \"), Currency=\"+currencyISOCode+\", parse(\"+DATA[i][j]+\") returned error \" + (UnicodeString)u_errorName(status)+\".  Testcase: data[\" + i + \"][\" + currencyStyleNames[j-3] +\"=\"+j+\"]\");\n                if (parseResult.getType() == Formattable::kDouble) {\n                    errln((UnicodeString)\"expected: \" + numberToBeFormat + \"; actual (double): \" +parseResult.getDouble());\n                } else {\n                    errln((UnicodeString)\"expected: \" + numberToBeFormat + \"; actual (long): \" +parseResult.getLong());\n                }\n                errln((UnicodeString)\" round-trip would be: \" + strBuf);\n            }\n        }\n        delete numFmt;\n      }\n    }\n#ifdef NUMFMTST_CACHE_DEBUG\n}\n#endif\n}\n\n\nvoid\nNumberFormatTest::TestParseCurrencyInUCurr() {\n    const char* DATA[] = {\n        \"1.00 US DOLLAR\",  // case in-sensitive\n        \"$1.00\",\n        \"USD1.00\",\n        \"usd1.00\", // case in-sensitive: #13696\n        \"US dollar1.00\",\n        \"US dollars1.00\",\n        \"$1.00\",\n        \"A$1.00\",\n        \"ADP1.00\",\n        \"ADP1.00\",\n        \"AED1.00\",\n        \"AED1.00\",\n        \"AFA1.00\",\n        \"AFA1.00\",\n        \"AFN1.00\",\n        \"ALL1.00\",\n        \"AMD1.00\",\n        \"ANG1.00\",\n        \"AOA1.00\",\n        \"AOK1.00\",\n        \"AOK1.00\",\n        \"AON1.00\",\n        \"AON1.00\",\n        \"AOR1.00\",\n        \"AOR1.00\",\n        \"ARS1.00\",\n        \"ARA1.00\",\n        \"ARA1.00\",\n        \"ARP1.00\",\n        \"ARP1.00\",\n        \"ARS1.00\",\n        \"ATS1.00\",\n        \"ATS1.00\",\n        \"AUD1.00\",\n        \"AWG1.00\",\n        \"AZM1.00\",\n        \"AZM1.00\",\n        \"AZN1.00\",\n        \"Afghan Afghani (1927\\\\u20132002)1.00\",\n        \"Afghan afghani (1927\\\\u20132002)1.00\",\n        \"Afghan Afghani1.00\",\n        \"Afghan Afghanis1.00\",\n        \"Albanian Lek1.00\",\n        \"Albanian lek1.00\",\n        \"Albanian lek\\\\u00eb1.00\",\n        \"Algerian Dinar1.00\",\n        \"Algerian dinar1.00\",\n        \"Algerian dinars1.00\",\n        \"Andorran Peseta1.00\",\n        \"Andorran peseta1.00\",\n        \"Andorran pesetas1.00\",\n        \"Angolan Kwanza (1977\\\\u20131991)1.00\",\n        \"Angolan Readjusted Kwanza (1995\\\\u20131999)1.00\",\n        \"Angolan Kwanza1.00\",\n        \"Angolan New Kwanza (1990\\\\u20132000)1.00\",\n        \"Angolan kwanza (1977\\\\u20131991)1.00\",\n        \"Angolan readjusted kwanza (1995\\\\u20131999)1.00\",\n        \"Angolan kwanza1.00\",\n        \"Angolan kwanzas (1977\\\\u20131991)1.00\",\n        \"Angolan readjusted kwanzas (1995\\\\u20131999)1.00\",\n        \"Angolan kwanzas1.00\",\n        \"Angolan new kwanza (1990\\\\u20132000)1.00\",\n        \"Angolan new kwanzas (1990\\\\u20132000)1.00\",\n        \"Argentine Austral1.00\",\n        \"Argentine Peso (1983\\\\u20131985)1.00\",\n        \"Argentine Peso1.00\",\n        \"Argentine austral1.00\",\n        \"Argentine australs1.00\",\n        \"Argentine peso (1983\\\\u20131985)1.00\",\n        \"Argentine peso1.00\",\n        \"Argentine pesos (1983\\\\u20131985)1.00\",\n        \"Argentine pesos1.00\",\n        \"Armenian Dram1.00\",\n        \"Armenian dram1.00\",\n        \"Armenian drams1.00\",\n        \"Aruban Florin1.00\",\n        \"Aruban florin1.00\",\n        \"Australian Dollar1.00\",\n        \"Australian dollar1.00\",\n        \"Australian dollars1.00\",\n        \"Austrian Schilling1.00\",\n        \"Austrian schilling1.00\",\n        \"Austrian schillings1.00\",\n        \"Azerbaijani Manat (1993\\\\u20132006)1.00\",\n        \"Azerbaijani Manat1.00\",\n        \"Azerbaijani manat (1993\\\\u20132006)1.00\",\n        \"Azerbaijani manat1.00\",\n        \"Azerbaijani manats (1993\\\\u20132006)1.00\",\n        \"Azerbaijani manats1.00\",\n        \"BAD1.00\",\n        \"BAD1.00\",\n        \"BAM1.00\",\n        \"BBD1.00\",\n        \"BDT1.00\",\n        \"BEC1.00\",\n        \"BEC1.00\",\n        \"BEF1.00\",\n        \"BEL1.00\",\n        \"BEL1.00\",\n        \"BGL1.00\",\n        \"BGN1.00\",\n        \"BGN1.00\",\n        \"BHD1.00\",\n        \"BIF1.00\",\n        \"BMD1.00\",\n        \"BND1.00\",\n        \"BOB1.00\",\n        \"BOP1.00\",\n        \"BOP1.00\",\n        \"BOV1.00\",\n        \"BOV1.00\",\n        \"BRB1.00\",\n        \"BRB1.00\",\n        \"BRC1.00\",\n        \"BRC1.00\",\n        \"BRE1.00\",\n        \"BRE1.00\",\n        \"BRL1.00\",\n        \"BRN1.00\",\n        \"BRN1.00\",\n        \"BRR1.00\",\n        \"BRR1.00\",\n        \"BSD1.00\",\n        \"BSD1.00\",\n        \"BTN1.00\",\n        \"BUK1.00\",\n        \"BUK1.00\",\n        \"BWP1.00\",\n        \"BYB1.00\",\n        \"BYB1.00\",\n        \"BYR1.00\",\n        \"BZD1.00\",\n        \"Bahamian Dollar1.00\",\n        \"Bahamian dollar1.00\",\n        \"Bahamian dollars1.00\",\n        \"Bahraini Dinar1.00\",\n        \"Bahraini dinar1.00\",\n        \"Bahraini dinars1.00\",\n        \"Bangladeshi Taka1.00\",\n        \"Bangladeshi taka1.00\",\n        \"Bangladeshi takas1.00\",\n        \"Barbadian Dollar1.00\",\n        \"Barbadian dollar1.00\",\n        \"Barbadian dollars1.00\",\n        \"Belarusian Ruble (1994\\\\u20131999)1.00\",\n        \"Belarusian Ruble1.00\",\n        \"Belarusian ruble (1994\\\\u20131999)1.00\",\n        \"Belarusian rubles (1994\\\\u20131999)1.00\",\n        \"Belarusian ruble1.00\",\n        \"Belarusian rubles1.00\",\n        \"Belgian Franc (convertible)1.00\",\n        \"Belgian Franc (financial)1.00\",\n        \"Belgian Franc1.00\",\n        \"Belgian franc (convertible)1.00\",\n        \"Belgian franc (financial)1.00\",\n        \"Belgian franc1.00\",\n        \"Belgian francs (convertible)1.00\",\n        \"Belgian francs (financial)1.00\",\n        \"Belgian francs1.00\",\n        \"Belize Dollar1.00\",\n        \"Belize dollar1.00\",\n        \"Belize dollars1.00\",\n        \"Bermudan Dollar1.00\",\n        \"Bermudan dollar1.00\",\n        \"Bermudan dollars1.00\",\n        \"Bhutanese Ngultrum1.00\",\n        \"Bhutanese ngultrum1.00\",\n        \"Bhutanese ngultrums1.00\",\n        \"Bolivian Mvdol1.00\",\n        \"Bolivian Peso1.00\",\n        \"Bolivian mvdol1.00\",\n        \"Bolivian mvdols1.00\",\n        \"Bolivian peso1.00\",\n        \"Bolivian pesos1.00\",\n        \"Bolivian Boliviano1.00\",\n        \"Bolivian Boliviano1.00\",\n        \"Bolivian Bolivianos1.00\",\n        \"Bosnia-Herzegovina Convertible Mark1.00\",\n        \"Bosnia-Herzegovina Dinar (1992\\\\u20131994)1.00\",\n        \"Bosnia-Herzegovina convertible mark1.00\",\n        \"Bosnia-Herzegovina convertible marks1.00\",\n        \"Bosnia-Herzegovina dinar (1992\\\\u20131994)1.00\",\n        \"Bosnia-Herzegovina dinars (1992\\\\u20131994)1.00\",\n        \"Botswanan Pula1.00\",\n        \"Botswanan pula1.00\",\n        \"Botswanan pulas1.00\",\n        \"Brazilian New Cruzado (1989\\\\u20131990)1.00\",\n        \"Brazilian Cruzado (1986\\\\u20131989)1.00\",\n        \"Brazilian Cruzeiro (1990\\\\u20131993)1.00\",\n        \"Brazilian New Cruzeiro (1967\\\\u20131986)1.00\",\n        \"Brazilian Cruzeiro (1993\\\\u20131994)1.00\",\n        \"Brazilian Real1.00\",\n        \"Brazilian new cruzado (1989\\\\u20131990)1.00\",\n        \"Brazilian new cruzados (1989\\\\u20131990)1.00\",\n        \"Brazilian cruzado (1986\\\\u20131989)1.00\",\n        \"Brazilian cruzados (1986\\\\u20131989)1.00\",\n        \"Brazilian cruzeiro (1990\\\\u20131993)1.00\",\n        \"Brazilian new cruzeiro (1967\\\\u20131986)1.00\",\n        \"Brazilian cruzeiro (1993\\\\u20131994)1.00\",\n        \"Brazilian cruzeiros (1990\\\\u20131993)1.00\",\n        \"Brazilian new cruzeiros (1967\\\\u20131986)1.00\",\n        \"Brazilian cruzeiros (1993\\\\u20131994)1.00\",\n        \"Brazilian real1.00\",\n        \"Brazilian reals1.00\",\n        \"British Pound1.00\",\n        \"British pound1.00\",\n        \"British pounds1.00\",\n        \"Brunei Dollar1.00\",\n        \"Brunei dollar1.00\",\n        \"Brunei dollars1.00\",\n        \"Bulgarian Hard Lev1.00\",\n        \"Bulgarian Lev1.00\",\n        \"Bulgarian Leva1.00\",\n        \"Bulgarian hard lev1.00\",\n        \"Bulgarian hard leva1.00\",\n        \"Bulgarian lev1.00\",\n        \"Burmese Kyat1.00\",\n        \"Burmese kyat1.00\",\n        \"Burmese kyats1.00\",\n        \"Burundian Franc1.00\",\n        \"Burundian franc1.00\",\n        \"Burundian francs1.00\",\n        \"CA$1.00\",\n        \"CAD1.00\",\n        \"CDF1.00\",\n        \"CDF1.00\",\n        \"West African CFA Franc1.00\",\n        \"Central African CFA Franc1.00\",\n        \"West African CFA franc1.00\",\n        \"Central African CFA franc1.00\",\n        \"West African CFA francs1.00\",\n        \"Central African CFA francs1.00\",\n        \"CFP Franc1.00\",\n        \"CFP franc1.00\",\n        \"CFP francs1.00\",\n        \"CFPF1.00\",\n        \"CHE1.00\",\n        \"CHE1.00\",\n        \"CHF1.00\",\n        \"CHW1.00\",\n        \"CHW1.00\",\n        \"CLF1.00\",\n        \"CLF1.00\",\n        \"CLP1.00\",\n        \"CNY1.00\",\n        \"COP1.00\",\n        \"COU1.00\",\n        \"COU1.00\",\n        \"CRC1.00\",\n        \"CSD1.00\",\n        \"CSD1.00\",\n        \"CSK1.00\",\n        \"CSK1.00\",\n        \"CUP1.00\",\n        \"CUP1.00\",\n        \"CVE1.00\",\n        \"CYP1.00\",\n        \"CZK1.00\",\n        \"Cambodian Riel1.00\",\n        \"Cambodian riel1.00\",\n        \"Cambodian riels1.00\",\n        \"Canadian Dollar1.00\",\n        \"Canadian dollar1.00\",\n        \"Canadian dollars1.00\",\n        \"Cape Verdean Escudo1.00\",\n        \"Cape Verdean escudo1.00\",\n        \"Cape Verdean escudos1.00\",\n        \"Cayman Islands Dollar1.00\",\n        \"Cayman Islands dollar1.00\",\n        \"Cayman Islands dollars1.00\",\n        \"Chilean Peso1.00\",\n        \"Chilean Unit of Account (UF)1.00\",\n        \"Chilean peso1.00\",\n        \"Chilean pesos1.00\",\n        \"Chilean unit of account (UF)1.00\",\n        \"Chilean units of account (UF)1.00\",\n        \"Chinese Yuan1.00\",\n        \"Chinese yuan1.00\",\n        \"Colombian Peso1.00\",\n        \"Colombian peso1.00\",\n        \"Colombian pesos1.00\",\n        \"Comorian Franc1.00\",\n        \"Comorian franc1.00\",\n        \"Comorian francs1.00\",\n        \"Congolese Franc1.00\",\n        \"Congolese franc1.00\",\n        \"Congolese francs1.00\",\n        \"Costa Rican Col\\\\u00f3n1.00\",\n        \"Costa Rican col\\\\u00f3n1.00\",\n        \"Costa Rican col\\\\u00f3ns1.00\",\n        \"Croatian Dinar1.00\",\n        \"Croatian Kuna1.00\",\n        \"Croatian dinar1.00\",\n        \"Croatian dinars1.00\",\n        \"Croatian kuna1.00\",\n        \"Croatian kunas1.00\",\n        \"Cuban Peso1.00\",\n        \"Cuban peso1.00\",\n        \"Cuban pesos1.00\",\n        \"Cypriot Pound1.00\",\n        \"Cypriot pound1.00\",\n        \"Cypriot pounds1.00\",\n        \"Czech Koruna1.00\",\n        \"Czech koruna1.00\",\n        \"Czech korunas1.00\",\n        \"Czechoslovak Hard Koruna1.00\",\n        \"Czechoslovak hard koruna1.00\",\n        \"Czechoslovak hard korunas1.00\",\n        \"DDM1.00\",\n        \"DDM1.00\",\n        \"DEM1.00\",\n        \"DEM1.00\",\n        \"DJF1.00\",\n        \"DKK1.00\",\n        \"DOP1.00\",\n        \"DZD1.00\",\n        \"Danish Krone1.00\",\n        \"Danish krone1.00\",\n        \"Danish kroner1.00\",\n        \"German Mark1.00\",\n        \"German mark1.00\",\n        \"German marks1.00\",\n        \"Djiboutian Franc1.00\",\n        \"Djiboutian franc1.00\",\n        \"Djiboutian francs1.00\",\n        \"Dominican Peso1.00\",\n        \"Dominican peso1.00\",\n        \"Dominican pesos1.00\",\n        \"EC$1.00\",\n        \"ECS1.00\",\n        \"ECS1.00\",\n        \"ECV1.00\",\n        \"ECV1.00\",\n        \"EEK1.00\",\n        \"EEK1.00\",\n        \"EGP1.00\",\n        \"EGP1.00\",\n        \"ERN1.00\",\n        \"ERN1.00\",\n        \"ESA1.00\",\n        \"ESA1.00\",\n        \"ESB1.00\",\n        \"ESB1.00\",\n        \"ESP1.00\",\n        \"ETB1.00\",\n        \"EUR1.00\",\n        \"East Caribbean Dollar1.00\",\n        \"East Caribbean dollar1.00\",\n        \"East Caribbean dollars1.00\",\n        \"East German Mark1.00\",\n        \"East German mark1.00\",\n        \"East German marks1.00\",\n        \"Ecuadorian Sucre1.00\",\n        \"Ecuadorian Unit of Constant Value1.00\",\n        \"Ecuadorian sucre1.00\",\n        \"Ecuadorian sucres1.00\",\n        \"Ecuadorian unit of constant value1.00\",\n        \"Ecuadorian units of constant value1.00\",\n        \"Egyptian Pound1.00\",\n        \"Egyptian pound1.00\",\n        \"Egyptian pounds1.00\",\n        \"Salvadoran Col\\\\u00f3n1.00\",\n        \"Salvadoran col\\\\u00f3n1.00\",\n        \"Salvadoran colones1.00\",\n        \"Equatorial Guinean Ekwele1.00\",\n        \"Equatorial Guinean ekwele1.00\",\n        \"Eritrean Nakfa1.00\",\n        \"Eritrean nakfa1.00\",\n        \"Eritrean nakfas1.00\",\n        \"Estonian Kroon1.00\",\n        \"Estonian kroon1.00\",\n        \"Estonian kroons1.00\",\n        \"Ethiopian Birr1.00\",\n        \"Ethiopian birr1.00\",\n        \"Ethiopian birrs1.00\",\n        \"Euro1.00\",\n        \"European Composite Unit1.00\",\n        \"European Currency Unit1.00\",\n        \"European Monetary Unit1.00\",\n        \"European Unit of Account (XBC)1.00\",\n        \"European Unit of Account (XBD)1.00\",\n        \"European composite unit1.00\",\n        \"European composite units1.00\",\n        \"European currency unit1.00\",\n        \"European currency units1.00\",\n        \"European monetary unit1.00\",\n        \"European monetary units1.00\",\n        \"European unit of account (XBC)1.00\",\n        \"European unit of account (XBD)1.00\",\n        \"European units of account (XBC)1.00\",\n        \"European units of account (XBD)1.00\",\n        \"FIM1.00\",\n        \"FIM1.00\",\n        \"FJD1.00\",\n        \"FKP1.00\",\n        \"FKP1.00\",\n        \"FRF1.00\",\n        \"FRF1.00\",\n        \"Falkland Islands Pound1.00\",\n        \"Falkland Islands pound1.00\",\n        \"Falkland Islands pounds1.00\",\n        \"Fijian Dollar1.00\",\n        \"Fijian dollar1.00\",\n        \"Fijian dollars1.00\",\n        \"Finnish Markka1.00\",\n        \"Finnish markka1.00\",\n        \"Finnish markkas1.00\",\n        \"CHF1.00\",\n        \"French Franc1.00\",\n        \"French Gold Franc1.00\",\n        \"French UIC-Franc1.00\",\n        \"French UIC-franc1.00\",\n        \"French UIC-francs1.00\",\n        \"French franc1.00\",\n        \"French francs1.00\",\n        \"French gold franc1.00\",\n        \"French gold francs1.00\",\n        \"GBP1.00\",\n        \"GEK1.00\",\n        \"GEK1.00\",\n        \"GEL1.00\",\n        \"GHC1.00\",\n        \"GHC1.00\",\n        \"GHS1.00\",\n        \"GIP1.00\",\n        \"GIP1.00\",\n        \"GMD1.00\",\n        \"GMD1.00\",\n        \"GNF1.00\",\n        \"GNS1.00\",\n        \"GNS1.00\",\n        \"GQE1.00\",\n        \"GQE1.00\",\n        \"GRD1.00\",\n        \"GRD1.00\",\n        \"GTQ1.00\",\n        \"GWE1.00\",\n        \"GWE1.00\",\n        \"GWP1.00\",\n        \"GWP1.00\",\n        \"GYD1.00\",\n        \"Gambian Dalasi1.00\",\n        \"Gambian dalasi1.00\",\n        \"Gambian dalasis1.00\",\n        \"Georgian Kupon Larit1.00\",\n        \"Georgian Lari1.00\",\n        \"Georgian kupon larit1.00\",\n        \"Georgian kupon larits1.00\",\n        \"Georgian lari1.00\",\n        \"Georgian laris1.00\",\n        \"Ghanaian Cedi (1979\\\\u20132007)1.00\",\n        \"Ghanaian Cedi1.00\",\n        \"Ghanaian cedi (1979\\\\u20132007)1.00\",\n        \"Ghanaian cedi1.00\",\n        \"Ghanaian cedis (1979\\\\u20132007)1.00\",\n        \"Ghanaian cedis1.00\",\n        \"Gibraltar Pound1.00\",\n        \"Gibraltar pound1.00\",\n        \"Gibraltar pounds1.00\",\n        \"Gold1.00\",\n        \"Gold1.00\",\n        \"Greek Drachma1.00\",\n        \"Greek drachma1.00\",\n        \"Greek drachmas1.00\",\n        \"Guatemalan Quetzal1.00\",\n        \"Guatemalan quetzal1.00\",\n        \"Guatemalan quetzals1.00\",\n        \"Guinean Franc1.00\",\n        \"Guinean Syli1.00\",\n        \"Guinean franc1.00\",\n        \"Guinean francs1.00\",\n        \"Guinean syli1.00\",\n        \"Guinean sylis1.00\",\n        \"Guinea-Bissau Peso1.00\",\n        \"Guinea-Bissau peso1.00\",\n        \"Guinea-Bissau pesos1.00\",\n        \"Guyanaese Dollar1.00\",\n        \"Guyanaese dollar1.00\",\n        \"Guyanaese dollars1.00\",\n        \"HK$1.00\",\n        \"HKD1.00\",\n        \"HNL1.00\",\n        \"HRD1.00\",\n        \"HRD1.00\",\n        \"HRK1.00\",\n        \"HRK1.00\",\n        \"HTG1.00\",\n        \"HTG1.00\",\n        \"HUF1.00\",\n        \"Haitian Gourde1.00\",\n        \"Haitian gourde1.00\",\n        \"Haitian gourdes1.00\",\n        \"Honduran Lempira1.00\",\n        \"Honduran lempira1.00\",\n        \"Honduran lempiras1.00\",\n        \"Hong Kong Dollar1.00\",\n        \"Hong Kong dollar1.00\",\n        \"Hong Kong dollars1.00\",\n        \"Hungarian Forint1.00\",\n        \"Hungarian forint1.00\",\n        \"Hungarian forints1.00\",\n        \"IDR1.00\",\n        \"IEP1.00\",\n        \"ILP1.00\",\n        \"ILP1.00\",\n        \"ILS1.00\",\n        \"INR1.00\",\n        \"IQD1.00\",\n        \"IRR1.00\",\n        \"ISK1.00\",\n        \"ISK1.00\",\n        \"ITL1.00\",\n        \"Icelandic Kr\\\\u00f3na1.00\",\n        \"Icelandic kr\\\\u00f3na1.00\",\n        \"Icelandic kr\\\\u00f3nur1.00\",\n        \"Indian Rupee1.00\",\n        \"Indian rupee1.00\",\n        \"Indian rupees1.00\",\n        \"Indonesian Rupiah1.00\",\n        \"Indonesian rupiah1.00\",\n        \"Indonesian rupiahs1.00\",\n        \"Iranian Rial1.00\",\n        \"Iranian rial1.00\",\n        \"Iranian rials1.00\",\n        \"Iraqi Dinar1.00\",\n        \"Iraqi dinar1.00\",\n        \"Iraqi dinars1.00\",\n        \"Irish Pound1.00\",\n        \"Irish pound1.00\",\n        \"Irish pounds1.00\",\n        \"Israeli Pound1.00\",\n        \"Israeli new shekel1.00\",\n        \"Israeli pound1.00\",\n        \"Israeli pounds1.00\",\n        \"Italian Lira1.00\",\n        \"Italian lira1.00\",\n        \"Italian liras1.00\",\n        \"JMD1.00\",\n        \"JOD1.00\",\n        \"JPY1.00\",\n        \"Jamaican Dollar1.00\",\n        \"Jamaican dollar1.00\",\n        \"Jamaican dollars1.00\",\n        \"Japanese Yen1.00\",\n        \"Japanese yen1.00\",\n        \"Jordanian Dinar1.00\",\n        \"Jordanian dinar1.00\",\n        \"Jordanian dinars1.00\",\n        \"KES1.00\",\n        \"KGS1.00\",\n        \"KHR1.00\",\n        \"KMF1.00\",\n        \"KPW1.00\",\n        \"KPW1.00\",\n        \"KRW1.00\",\n        \"KWD1.00\",\n        \"KYD1.00\",\n        \"KYD1.00\",\n        \"KZT1.00\",\n        \"Kazakhstani Tenge1.00\",\n        \"Kazakhstani tenge1.00\",\n        \"Kazakhstani tenges1.00\",\n        \"Kenyan Shilling1.00\",\n        \"Kenyan shilling1.00\",\n        \"Kenyan shillings1.00\",\n        \"Kuwaiti Dinar1.00\",\n        \"Kuwaiti dinar1.00\",\n        \"Kuwaiti dinars1.00\",\n        \"Kyrgystani Som1.00\",\n        \"Kyrgystani som1.00\",\n        \"Kyrgystani soms1.00\",\n        \"HNL1.00\",\n        \"LAK1.00\",\n        \"LAK1.00\",\n        \"LBP1.00\",\n        \"LKR1.00\",\n        \"LRD1.00\",\n        \"LRD1.00\",\n        \"LSL1.00\",\n        \"LTL1.00\",\n        \"LTL1.00\",\n        \"LTT1.00\",\n        \"LTT1.00\",\n        \"LUC1.00\",\n        \"LUC1.00\",\n        \"LUF1.00\",\n        \"LUF1.00\",\n        \"LUL1.00\",\n        \"LUL1.00\",\n        \"LVL1.00\",\n        \"LVL1.00\",\n        \"LVR1.00\",\n        \"LVR1.00\",\n        \"LYD1.00\",\n        \"Laotian Kip1.00\",\n        \"Laotian kip1.00\",\n        \"Laotian kips1.00\",\n        \"Latvian Lats1.00\",\n        \"Latvian Ruble1.00\",\n        \"Latvian lats1.00\",\n        \"Latvian lati1.00\",\n        \"Latvian ruble1.00\",\n        \"Latvian rubles1.00\",\n        \"Lebanese Pound1.00\",\n        \"Lebanese pound1.00\",\n        \"Lebanese pounds1.00\",\n        \"Lesotho Loti1.00\",\n        \"Lesotho loti1.00\",\n        \"Lesotho lotis1.00\",\n        \"Liberian Dollar1.00\",\n        \"Liberian dollar1.00\",\n        \"Liberian dollars1.00\",\n        \"Libyan Dinar1.00\",\n        \"Libyan dinar1.00\",\n        \"Libyan dinars1.00\",\n        \"Lithuanian Litas1.00\",\n        \"Lithuanian Talonas1.00\",\n        \"Lithuanian litas1.00\",\n        \"Lithuanian litai1.00\",\n        \"Lithuanian talonas1.00\",\n        \"Lithuanian talonases1.00\",\n        \"Luxembourgian Convertible Franc1.00\",\n        \"Luxembourg Financial Franc1.00\",\n        \"Luxembourgian Franc1.00\",\n        \"Luxembourgian convertible franc1.00\",\n        \"Luxembourgian convertible francs1.00\",\n        \"Luxembourg financial franc1.00\",\n        \"Luxembourg financial francs1.00\",\n        \"Luxembourgian franc1.00\",\n        \"Luxembourgian francs1.00\",\n        \"MAD1.00\",\n        \"MAD1.00\",\n        \"MAF1.00\",\n        \"MAF1.00\",\n        \"MDL1.00\",\n        \"MDL1.00\",\n        \"MX$1.00\",\n        \"MGA1.00\",\n        \"MGA1.00\",\n        \"MGF1.00\",\n        \"MGF1.00\",\n        \"MKD1.00\",\n        \"MLF1.00\",\n        \"MLF1.00\",\n        \"MMK1.00\",\n        \"MMK1.00\",\n        \"MNT1.00\",\n        \"MOP1.00\",\n        \"MOP1.00\",\n        \"MRO1.00\",\n        \"MTL1.00\",\n        \"MTP1.00\",\n        \"MTP1.00\",\n        \"MUR1.00\",\n        \"MUR1.00\",\n        \"MVR1.00\",\n        \"MVR1.00\",\n        \"MWK1.00\",\n        \"MXN1.00\",\n        \"MXP1.00\",\n        \"MXP1.00\",\n        \"MXV1.00\",\n        \"MXV1.00\",\n        \"MYR1.00\",\n        \"MZE1.00\",\n        \"MZE1.00\",\n        \"MZM1.00\",\n        \"MZN1.00\",\n        \"Macanese Pataca1.00\",\n        \"Macanese pataca1.00\",\n        \"Macanese patacas1.00\",\n        \"Macedonian Denar1.00\",\n        \"Macedonian denar1.00\",\n        \"Macedonian denari1.00\",\n        \"Malagasy Ariaries1.00\",\n        \"Malagasy Ariary1.00\",\n        \"Malagasy Ariary1.00\",\n        \"Malagasy Franc1.00\",\n        \"Malagasy franc1.00\",\n        \"Malagasy francs1.00\",\n        \"Malawian Kwacha1.00\",\n        \"Malawian Kwacha1.00\",\n        \"Malawian Kwachas1.00\",\n        \"Malaysian Ringgit1.00\",\n        \"Malaysian ringgit1.00\",\n        \"Malaysian ringgits1.00\",\n        \"Maldivian Rufiyaa1.00\",\n        \"Maldivian rufiyaa1.00\",\n        \"Maldivian rufiyaas1.00\",\n        \"Malian Franc1.00\",\n        \"Malian franc1.00\",\n        \"Malian francs1.00\",\n        \"Maltese Lira1.00\",\n        \"Maltese Pound1.00\",\n        \"Maltese lira1.00\",\n        \"Maltese lira1.00\",\n        \"Maltese pound1.00\",\n        \"Maltese pounds1.00\",\n        \"Mauritanian Ouguiya1.00\",\n        \"Mauritanian ouguiya1.00\",\n        \"Mauritanian ouguiyas1.00\",\n        \"Mauritian Rupee1.00\",\n        \"Mauritian rupee1.00\",\n        \"Mauritian rupees1.00\",\n        \"Mexican Peso1.00\",\n        \"Mexican Silver Peso (1861\\\\u20131992)1.00\",\n        \"Mexican Investment Unit1.00\",\n        \"Mexican peso1.00\",\n        \"Mexican pesos1.00\",\n        \"Mexican silver peso (1861\\\\u20131992)1.00\",\n        \"Mexican silver pesos (1861\\\\u20131992)1.00\",\n        \"Mexican investment unit1.00\",\n        \"Mexican investment units1.00\",\n        \"Moldovan Leu1.00\",\n        \"Moldovan leu1.00\",\n        \"Moldovan lei1.00\",\n        \"Mongolian Tugrik1.00\",\n        \"Mongolian tugrik1.00\",\n        \"Mongolian tugriks1.00\",\n        \"Moroccan Dirham1.00\",\n        \"Moroccan Franc1.00\",\n        \"Moroccan dirham1.00\",\n        \"Moroccan dirhams1.00\",\n        \"Moroccan franc1.00\",\n        \"Moroccan francs1.00\",\n        \"Mozambican Escudo1.00\",\n        \"Mozambican Metical1.00\",\n        \"Mozambican escudo1.00\",\n        \"Mozambican escudos1.00\",\n        \"Mozambican metical1.00\",\n        \"Mozambican meticals1.00\",\n        \"Myanmar Kyat1.00\",\n        \"Myanmar kyat1.00\",\n        \"Myanmar kyats1.00\",\n        \"NAD1.00\",\n        \"NGN1.00\",\n        \"NIC1.00\",\n        \"NIO1.00\",\n        \"NIO1.00\",\n        \"NLG1.00\",\n        \"NLG1.00\",\n        \"NOK1.00\",\n        \"NPR1.00\",\n        \"NT$1.00\",\n        \"NZ$1.00\",\n        \"NZD1.00\",\n        \"Namibian Dollar1.00\",\n        \"Namibian dollar1.00\",\n        \"Namibian dollars1.00\",\n        \"Nepalese Rupee1.00\",\n        \"Nepalese rupee1.00\",\n        \"Nepalese rupees1.00\",\n        \"Netherlands Antillean Guilder1.00\",\n        \"Netherlands Antillean guilder1.00\",\n        \"Netherlands Antillean guilders1.00\",\n        \"Dutch Guilder1.00\",\n        \"Dutch guilder1.00\",\n        \"Dutch guilders1.00\",\n        \"Israeli New Shekel1.00\",\n        \"Israeli New Shekels1.00\",\n        \"New Zealand Dollar1.00\",\n        \"New Zealand dollar1.00\",\n        \"New Zealand dollars1.00\",\n        \"Nicaraguan C\\\\u00f3rdoba1.00\",\n        \"Nicaraguan C\\\\u00f3rdoba (1988\\\\u20131991)1.00\",\n        \"Nicaraguan c\\\\u00f3rdoba1.00\",\n        \"Nicaraguan c\\\\u00f3rdobas1.00\",\n        \"Nicaraguan c\\\\u00f3rdoba (1988\\\\u20131991)1.00\",\n        \"Nicaraguan c\\\\u00f3rdobas (1988\\\\u20131991)1.00\",\n        \"Nigerian Naira1.00\",\n        \"Nigerian naira1.00\",\n        \"Nigerian nairas1.00\",\n        \"North Korean Won1.00\",\n        \"North Korean won1.00\",\n        \"North Korean won1.00\",\n        \"Norwegian Krone1.00\",\n        \"Norwegian krone1.00\",\n        \"Norwegian kroner1.00\",\n        \"OMR1.00\",\n        \"Mozambican Metical (1980\\\\u20132006)1.00\",\n        \"Mozambican metical (1980\\\\u20132006)1.00\",\n        \"Mozambican meticals (1980\\\\u20132006)1.00\",\n        \"Romanian Lei (1952\\\\u20132006)1.00\",\n        \"Romanian Leu (1952\\\\u20132006)1.00\",\n        \"Romanian leu (1952\\\\u20132006)1.00\",\n        \"Serbian Dinar (2002\\\\u20132006)1.00\",\n        \"Serbian dinar (2002\\\\u20132006)1.00\",\n        \"Serbian dinars (2002\\\\u20132006)1.00\",\n        \"Sudanese Dinar (1992\\\\u20132007)1.00\",\n        \"Sudanese Pound (1957\\\\u20131998)1.00\",\n        \"Sudanese dinar (1992\\\\u20132007)1.00\",\n        \"Sudanese dinars (1992\\\\u20132007)1.00\",\n        \"Sudanese pound (1957\\\\u20131998)1.00\",\n        \"Sudanese pounds (1957\\\\u20131998)1.00\",\n        \"Turkish Lira (1922\\\\u20132005)1.00\",\n        \"Turkish Lira (1922\\\\u20132005)1.00\",\n        \"Omani Rial1.00\",\n        \"Omani rial1.00\",\n        \"Omani rials1.00\",\n        \"PAB1.00\",\n        \"PAB1.00\",\n        \"PEI1.00\",\n        \"PEI1.00\",\n        \"PEN1.00\",\n        \"PEN1.00\",\n        \"PES1.00\",\n        \"PES1.00\",\n        \"PGK1.00\",\n        \"PGK1.00\",\n        \"PHP1.00\",\n        \"PKR1.00\",\n        \"PLN1.00\",\n        \"PLZ1.00\",\n        \"PLZ1.00\",\n        \"PTE1.00\",\n        \"PTE1.00\",\n        \"PYG1.00\",\n        \"Pakistani Rupee1.00\",\n        \"Pakistani rupee1.00\",\n        \"Pakistani rupees1.00\",\n        \"Palladium1.00\",\n        \"Palladium1.00\",\n        \"Panamanian Balboa1.00\",\n        \"Panamanian balboa1.00\",\n        \"Panamanian balboas1.00\",\n        \"Papua New Guinean Kina1.00\",\n        \"Papua New Guinean kina1.00\",\n        \"Papua New Guinean kina1.00\",\n        \"Paraguayan Guarani1.00\",\n        \"Paraguayan guarani1.00\",\n        \"Paraguayan guaranis1.00\",\n        \"Peruvian Inti1.00\",\n        \"Peruvian Sol1.00\",\n        \"Peruvian Sol (1863\\\\u20131965)1.00\",\n        \"Peruvian inti1.00\",\n        \"Peruvian intis1.00\",\n        \"Peruvian sol1.00\",\n        \"Peruvian soles1.00\",\n        \"Peruvian sol (1863\\\\u20131965)1.00\",\n        \"Peruvian soles (1863\\\\u20131965)1.00\",\n        \"Philippine Piso1.00\",\n        \"Philippine piso1.00\",\n        \"Philippine pisos1.00\",\n        \"Platinum1.00\",\n        \"Platinum1.00\",\n        \"Polish Zloty (1950\\\\u20131995)1.00\",\n        \"Polish Zloty1.00\",\n        \"Polish zlotys1.00\",\n        \"Polish zloty (PLZ)1.00\",\n        \"Polish zloty1.00\",\n        \"Polish zlotys (PLZ)1.00\",\n        \"Portuguese Escudo1.00\",\n        \"Portuguese Guinea Escudo1.00\",\n        \"Portuguese Guinea escudo1.00\",\n        \"Portuguese Guinea escudos1.00\",\n        \"Portuguese escudo1.00\",\n        \"Portuguese escudos1.00\",\n        \"GTQ1.00\",\n        \"QAR1.00\",\n        \"Qatari Rial1.00\",\n        \"Qatari rial1.00\",\n        \"Qatari rials1.00\",\n        \"RHD1.00\",\n        \"RHD1.00\",\n        \"RINET Funds1.00\",\n        \"RINET Funds1.00\",\n        \"CN\\\\u00a51.00\",\n        \"ROL1.00\",\n        \"ROL1.00\",\n        \"RON1.00\",\n        \"RON1.00\",\n        \"RSD1.00\",\n        \"RSD1.00\",\n        \"RUB1.00\",\n        \"RUR1.00\",\n        \"RUR1.00\",\n        \"RWF1.00\",\n        \"RWF1.00\",\n        \"Rhodesian Dollar1.00\",\n        \"Rhodesian dollar1.00\",\n        \"Rhodesian dollars1.00\",\n        \"Romanian Leu1.00\",\n        \"Romanian lei1.00\",\n        \"Romanian leu1.00\",\n        \"Russian Ruble (1991\\\\u20131998)1.00\",\n        \"Russian Ruble1.00\",\n        \"Russian ruble (1991\\\\u20131998)1.00\",\n        \"Russian ruble1.00\",\n        \"Russian rubles (1991\\\\u20131998)1.00\",\n        \"Russian rubles1.00\",\n        \"Rwandan Franc1.00\",\n        \"Rwandan franc1.00\",\n        \"Rwandan francs1.00\",\n        \"SAR1.00\",\n        \"SBD1.00\",\n        \"SCR1.00\",\n        \"SDD1.00\",\n        \"SDD1.00\",\n        \"SDG1.00\",\n        \"SDG1.00\",\n        \"SDP1.00\",\n        \"SDP1.00\",\n        \"SEK1.00\",\n        \"SGD1.00\",\n        \"SHP1.00\",\n        \"SHP1.00\",\n        \"SIT1.00\",\n        \"SIT1.00\",\n        \"SKK1.00\",\n        \"SLL1.00\",\n        \"SLL1.00\",\n        \"SOS1.00\",\n        \"SRD1.00\",\n        \"SRD1.00\",\n        \"SRG1.00\",\n        \"STD1.00\",\n        \"SUR1.00\",\n        \"SUR1.00\",\n        \"SVC1.00\",\n        \"SVC1.00\",\n        \"SYP1.00\",\n        \"SZL1.00\",\n        \"St. Helena Pound1.00\",\n        \"St. Helena pound1.00\",\n        \"St. Helena pounds1.00\",\n        \"S\\\\u00e3o Tom\\\\u00e9 & Pr\\\\u00edncipe Dobra1.00\",\n        \"S\\\\u00e3o Tom\\\\u00e9 & Pr\\\\u00edncipe dobra1.00\",\n        \"S\\\\u00e3o Tom\\\\u00e9 & Pr\\\\u00edncipe dobras1.00\",\n        \"Saudi Riyal1.00\",\n        \"Saudi riyal1.00\",\n        \"Saudi riyals1.00\",\n        \"Serbian Dinar1.00\",\n        \"Serbian dinar1.00\",\n        \"Serbian dinars1.00\",\n        \"Seychellois Rupee1.00\",\n        \"Seychellois rupee1.00\",\n        \"Seychellois rupees1.00\",\n        \"Sierra Leonean Leone1.00\",\n        \"Sierra Leonean leone1.00\",\n        \"Sierra Leonean leones1.00\",\n        \"Silver1.00\",\n        \"Silver1.00\",\n        \"Singapore Dollar1.00\",\n        \"Singapore dollar1.00\",\n        \"Singapore dollars1.00\",\n        \"Slovak Koruna1.00\",\n        \"Slovak koruna1.00\",\n        \"Slovak korunas1.00\",\n        \"Slovenian Tolar1.00\",\n        \"Slovenian tolar1.00\",\n        \"Slovenian tolars1.00\",\n        \"Solomon Islands Dollar1.00\",\n        \"Solomon Islands dollar1.00\",\n        \"Solomon Islands dollars1.00\",\n        \"Somali Shilling1.00\",\n        \"Somali shilling1.00\",\n        \"Somali shillings1.00\",\n        \"South African Rand (financial)1.00\",\n        \"South African Rand1.00\",\n        \"South African rand (financial)1.00\",\n        \"South African rand1.00\",\n        \"South African rands (financial)1.00\",\n        \"South African rand1.00\",\n        \"South Korean Won1.00\",\n        \"South Korean won1.00\",\n        \"South Korean won1.00\",\n        \"Soviet Rouble1.00\",\n        \"Soviet rouble1.00\",\n        \"Soviet roubles1.00\",\n        \"Spanish Peseta (A account)1.00\",\n        \"Spanish Peseta (convertible account)1.00\",\n        \"Spanish Peseta1.00\",\n        \"Spanish peseta (A account)1.00\",\n        \"Spanish peseta (convertible account)1.00\",\n        \"Spanish peseta1.00\",\n        \"Spanish pesetas (A account)1.00\",\n        \"Spanish pesetas (convertible account)1.00\",\n        \"Spanish pesetas1.00\",\n        \"Special Drawing Rights1.00\",\n        \"Sri Lankan Rupee1.00\",\n        \"Sri Lankan rupee1.00\",\n        \"Sri Lankan rupees1.00\",\n        \"Sudanese Pound1.00\",\n        \"Sudanese pound1.00\",\n        \"Sudanese pounds1.00\",\n        \"Surinamese Dollar1.00\",\n        \"Surinamese dollar1.00\",\n        \"Surinamese dollars1.00\",\n        \"Surinamese Guilder1.00\",\n        \"Surinamese guilder1.00\",\n        \"Surinamese guilders1.00\",\n        \"Swazi Lilangeni1.00\",\n        \"Swazi lilangeni1.00\",\n        \"Swazi emalangeni1.00\",\n        \"Swedish Krona1.00\",\n        \"Swedish krona1.00\",\n        \"Swedish kronor1.00\",\n        \"Swiss Franc1.00\",\n        \"Swiss franc1.00\",\n        \"Swiss francs1.00\",\n        \"Syrian Pound1.00\",\n        \"Syrian pound1.00\",\n        \"Syrian pounds1.00\",\n        \"THB1.00\",\n        \"TJR1.00\",\n        \"TJR1.00\",\n        \"TJS1.00\",\n        \"TJS1.00\",\n        \"TMM1.00\",\n        \"TMM1.00\",\n        \"TND1.00\",\n        \"TND1.00\",\n        \"TOP1.00\",\n        \"TPE1.00\",\n        \"TPE1.00\",\n        \"TRL1.00\",\n        \"TRY1.00\",\n        \"TRY1.00\",\n        \"TTD1.00\",\n        \"TWD1.00\",\n        \"TZS1.00\",\n        \"New Taiwan Dollar1.00\",\n        \"New Taiwan dollar1.00\",\n        \"New Taiwan dollars1.00\",\n        \"Tajikistani Ruble1.00\",\n        \"Tajikistani Somoni1.00\",\n        \"Tajikistani ruble1.00\",\n        \"Tajikistani rubles1.00\",\n        \"Tajikistani somoni1.00\",\n        \"Tajikistani somonis1.00\",\n        \"Tanzanian Shilling1.00\",\n        \"Tanzanian shilling1.00\",\n        \"Tanzanian shillings1.00\",\n        \"Testing Currency Code1.00\",\n        \"Testing Currency Code1.00\",\n        \"Thai Baht1.00\",\n        \"Thai baht1.00\",\n        \"Thai baht1.00\",\n        \"Timorese Escudo1.00\",\n        \"Timorese escudo1.00\",\n        \"Timorese escudos1.00\",\n        \"Tongan Pa\\\\u02bbanga1.00\",\n        \"Tongan pa\\\\u02bbanga1.00\",\n        \"Tongan pa\\\\u02bbanga1.00\",\n        \"Trinidad & Tobago Dollar1.00\",\n        \"Trinidad & Tobago dollar1.00\",\n        \"Trinidad & Tobago dollars1.00\",\n        \"Tunisian Dinar1.00\",\n        \"Tunisian dinar1.00\",\n        \"Tunisian dinars1.00\",\n        \"Turkish Lira1.00\",\n        \"Turkish Lira1.00\",\n        \"Turkish lira1.00\",\n        \"Turkmenistani Manat1.00\",\n        \"Turkmenistani manat1.00\",\n        \"Turkmenistani manat1.00\",\n        \"UAE dirham1.00\",\n        \"UAE dirhams1.00\",\n        \"UAH1.00\",\n        \"UAK1.00\",\n        \"UAK1.00\",\n        \"UGS1.00\",\n        \"UGS1.00\",\n        \"UGX1.00\",\n        \"US Dollar (Next day)1.00\",\n        \"US Dollar (Same day)1.00\",\n        \"US Dollar1.00\",\n        \"US dollar (next day)1.00\",\n        \"US dollar (same day)1.00\",\n        \"US dollar1.00\",\n        \"US dollars (next day)1.00\",\n        \"US dollars (same day)1.00\",\n        \"US dollars1.00\",\n        \"USD1.00\",\n        \"USN1.00\",\n        \"USN1.00\",\n        \"USS1.00\",\n        \"USS1.00\",\n        \"UYI1.00\",\n        \"UYI1.00\",\n        \"UYP1.00\",\n        \"UYP1.00\",\n        \"UYU1.00\",\n        \"UZS1.00\",\n        \"UZS1.00\",\n        \"Ugandan Shilling (1966\\\\u20131987)1.00\",\n        \"Ugandan Shilling1.00\",\n        \"Ugandan shilling (1966\\\\u20131987)1.00\",\n        \"Ugandan shilling1.00\",\n        \"Ugandan shillings (1966\\\\u20131987)1.00\",\n        \"Ugandan shillings1.00\",\n        \"Ukrainian Hryvnia1.00\",\n        \"Ukrainian Karbovanets1.00\",\n        \"Ukrainian hryvnia1.00\",\n        \"Ukrainian hryvnias1.00\",\n        \"Ukrainian karbovanets1.00\",\n        \"Ukrainian karbovantsiv1.00\",\n        \"Colombian Real Value Unit1.00\",\n        \"United Arab Emirates Dirham1.00\",\n        \"Unknown Currency1.00\",\n        \"Uruguayan Peso (1975\\\\u20131993)1.00\",\n        \"Uruguayan Peso1.00\",\n        \"Uruguayan Peso (Indexed Units)1.00\",\n        \"Uruguayan peso (1975\\\\u20131993)1.00\",\n        \"Uruguayan peso (indexed units)1.00\",\n        \"Uruguayan peso1.00\",\n        \"Uruguayan pesos (1975\\\\u20131993)1.00\",\n        \"Uruguayan pesos (indexed units)1.00\",\n        \"Uruguayan pesos1.00\",\n        \"Uzbekistani Som1.00\",\n        \"Uzbekistani som1.00\",\n        \"Uzbekistani som1.00\",\n        \"VEB1.00\",\n        \"VEF1.00\",\n        \"VND1.00\",\n        \"VUV1.00\",\n        \"Vanuatu Vatu1.00\",\n        \"Vanuatu vatu1.00\",\n        \"Vanuatu vatus1.00\",\n        \"Venezuelan Bol\\\\u00edvar1.00\",\n        \"Venezuelan Bol\\\\u00edvar (1871\\\\u20132008)1.00\",\n        \"Venezuelan bol\\\\u00edvar1.00\",\n        \"Venezuelan bol\\\\u00edvars1.00\",\n        \"Venezuelan bol\\\\u00edvar (1871\\\\u20132008)1.00\",\n        \"Venezuelan bol\\\\u00edvars (1871\\\\u20132008)1.00\",\n        \"Vietnamese Dong1.00\",\n        \"Vietnamese dong1.00\",\n        \"Vietnamese dong1.00\",\n        \"WIR Euro1.00\",\n        \"WIR Franc1.00\",\n        \"WIR euro1.00\",\n        \"WIR euros1.00\",\n        \"WIR franc1.00\",\n        \"WIR francs1.00\",\n        \"WST1.00\",\n        \"WST1.00\",\n        \"Samoan Tala1.00\",\n        \"Samoan tala1.00\",\n        \"Samoan tala1.00\",\n        \"XAF1.00\",\n        \"XAF1.00\",\n        \"XAG1.00\",\n        \"XAG1.00\",\n        \"XAU1.00\",\n        \"XAU1.00\",\n        \"XBA1.00\",\n        \"XBA1.00\",\n        \"XBB1.00\",\n        \"XBB1.00\",\n        \"XBC1.00\",\n        \"XBC1.00\",\n        \"XBD1.00\",\n        \"XBD1.00\",\n        \"XCD1.00\",\n        \"XDR1.00\",\n        \"XDR1.00\",\n        \"XEU1.00\",\n        \"XEU1.00\",\n        \"XFO1.00\",\n        \"XFO1.00\",\n        \"XFU1.00\",\n        \"XFU1.00\",\n        \"XOF1.00\",\n        \"XOF1.00\",\n        \"XPD1.00\",\n        \"XPD1.00\",\n        \"XPF1.00\",\n        \"XPT1.00\",\n        \"XPT1.00\",\n        \"XRE1.00\",\n        \"XRE1.00\",\n        \"XTS1.00\",\n        \"XTS1.00\",\n        \"XXX1.00\",\n        \"XXX1.00\",\n        \"YDD1.00\",\n        \"YDD1.00\",\n        \"YER1.00\",\n        \"YUD1.00\",\n        \"YUD1.00\",\n        \"YUM1.00\",\n        \"YUM1.00\",\n        \"YUN1.00\",\n        \"YUN1.00\",\n        \"Yemeni Dinar1.00\",\n        \"Yemeni Rial1.00\",\n        \"Yemeni dinar1.00\",\n        \"Yemeni dinars1.00\",\n        \"Yemeni rial1.00\",\n        \"Yemeni rials1.00\",\n        \"Yugoslavian Convertible Dinar (1990\\\\u20131992)1.00\",\n        \"Yugoslavian Hard Dinar (1966\\\\u20131990)1.00\",\n        \"Yugoslavian New Dinar (1994\\\\u20132002)1.00\",\n        \"Yugoslavian convertible dinar (1990\\\\u20131992)1.00\",\n        \"Yugoslavian convertible dinars (1990\\\\u20131992)1.00\",\n        \"Yugoslavian hard dinar (1966\\\\u20131990)1.00\",\n        \"Yugoslavian hard dinars (1966\\\\u20131990)1.00\",\n        \"Yugoslavian new dinar (1994\\\\u20132002)1.00\",\n        \"Yugoslavian new dinars (1994\\\\u20132002)1.00\",\n        \"ZAL1.00\",\n        \"ZAL1.00\",\n        \"ZAR1.00\",\n        \"ZMK1.00\",\n        \"ZMK1.00\",\n        \"ZRN1.00\",\n        \"ZRN1.00\",\n        \"ZRZ1.00\",\n        \"ZRZ1.00\",\n        \"ZWD1.00\",\n        \"Zairean New Zaire (1993\\\\u20131998)1.00\",\n        \"Zairean Zaire (1971\\\\u20131993)1.00\",\n        \"Zairean new zaire (1993\\\\u20131998)1.00\",\n        \"Zairean new zaires (1993\\\\u20131998)1.00\",\n        \"Zairean zaire (1971\\\\u20131993)1.00\",\n        \"Zairean zaires (1971\\\\u20131993)1.00\",\n        \"Zambian Kwacha1.00\",\n        \"Zambian kwacha1.00\",\n        \"Zambian kwachas1.00\",\n        \"Zimbabwean Dollar (1980\\\\u20132008)1.00\",\n        \"Zimbabwean dollar (1980\\\\u20132008)1.00\",\n        \"Zimbabwean dollars (1980\\\\u20132008)1.00\",\n        \"euro1.00\",\n        \"euros1.00\",\n        \"Turkish lira (1922\\\\u20132005)1.00\",\n        \"special drawing rights1.00\",\n        \"Colombian real value unit1.00\",\n        \"Colombian real value units1.00\",\n        \"unknown currency1.00\",\n        \"\\\\u00a31.00\",\n        \"\\\\u00a51.00\",\n        \"\\\\u20ab1.00\",\n        \"\\\\u20aa1.00\",\n        \"\\\\u20ac1.00\",\n        \"\\\\u20b91.00\",\n        //\n        // Following has extra text, should be parsed correctly too\n        \"$1.00 random\",\n        \"USD1.00 random\",\n        \"1.00 US dollar random\",\n        \"1.00 US dollars random\",\n        \"1.00 Afghan Afghani random\",\n        \"1.00 Afghan Afghani random\",\n        \"1.00 Afghan Afghanis (1927\\\\u20131992) random\",\n        \"1.00 Afghan Afghanis random\",\n        \"1.00 Albanian Lek random\",\n        \"1.00 Albanian lek random\",\n        \"1.00 Albanian lek\\\\u00eb random\",\n        \"1.00 Algerian Dinar random\",\n        \"1.00 Algerian dinar random\",\n        \"1.00 Algerian dinars random\",\n        \"1.00 Andorran Peseta random\",\n        \"1.00 Andorran peseta random\",\n        \"1.00 Andorran pesetas random\",\n        \"1.00 Angolan Kwanza (1977\\\\u20131990) random\",\n        \"1.00 Angolan Readjusted Kwanza (1995\\\\u20131999) random\",\n        \"1.00 Angolan Kwanza random\",\n        \"1.00 Angolan New Kwanza (1990\\\\u20132000) random\",\n        \"1.00 Angolan kwanza (1977\\\\u20131991) random\",\n        \"1.00 Angolan readjusted kwanza (1995\\\\u20131999) random\",\n        \"1.00 Angolan kwanza random\",\n        \"1.00 Angolan kwanzas (1977\\\\u20131991) random\",\n        \"1.00 Angolan readjusted kwanzas (1995\\\\u20131999) random\",\n        \"1.00 Angolan kwanzas random\",\n        \"1.00 Angolan new kwanza (1990\\\\u20132000) random\",\n        \"1.00 Angolan new kwanzas (1990\\\\u20132000) random\",\n        \"1.00 Argentine Austral random\",\n        \"1.00 Argentine Peso (1983\\\\u20131985) random\",\n        \"1.00 Argentine Peso random\",\n        \"1.00 Argentine austral random\",\n        \"1.00 Argentine australs random\",\n        \"1.00 Argentine peso (1983\\\\u20131985) random\",\n        \"1.00 Argentine peso random\",\n        \"1.00 Argentine pesos (1983\\\\u20131985) random\",\n        \"1.00 Argentine pesos random\",\n        \"1.00 Armenian Dram random\",\n        \"1.00 Armenian dram random\",\n        \"1.00 Armenian drams random\",\n        \"1.00 Aruban Florin random\",\n        \"1.00 Aruban florin random\",\n        \"1.00 Australian Dollar random\",\n        \"1.00 Australian dollar random\",\n        \"1.00 Australian dollars random\",\n        \"1.00 Austrian Schilling random\",\n        \"1.00 Austrian schilling random\",\n        \"1.00 Austrian schillings random\",\n        \"1.00 Azerbaijani Manat (1993\\\\u20132006) random\",\n        \"1.00 Azerbaijani Manat random\",\n        \"1.00 Azerbaijani manat (1993\\\\u20132006) random\",\n        \"1.00 Azerbaijani manat random\",\n        \"1.00 Azerbaijani manats (1993\\\\u20132006) random\",\n        \"1.00 Azerbaijani manats random\",\n        \"1.00 Bahamian Dollar random\",\n        \"1.00 Bahamian dollar random\",\n        \"1.00 Bahamian dollars random\",\n        \"1.00 Bahraini Dinar random\",\n        \"1.00 Bahraini dinar random\",\n        \"1.00 Bahraini dinars random\",\n        \"1.00 Bangladeshi Taka random\",\n        \"1.00 Bangladeshi taka random\",\n        \"1.00 Bangladeshi takas random\",\n        \"1.00 Barbadian Dollar random\",\n        \"1.00 Barbadian dollar random\",\n        \"1.00 Barbadian dollars random\",\n        \"1.00 Belarusian Ruble (1994\\\\u20131999) random\",\n        \"1.00 Belarusian Ruble random\",\n        \"1.00 Belarusian ruble (1994\\\\u20131999) random\",\n        \"1.00 Belarusian rubles (1994\\\\u20131999) random\",\n        \"1.00 Belarusian ruble random\",\n        \"1.00 Belarusian rubles random\",\n        \"1.00 Belgian Franc (convertible) random\",\n        \"1.00 Belgian Franc (financial) random\",\n        \"1.00 Belgian Franc random\",\n        \"1.00 Belgian franc (convertible) random\",\n        \"1.00 Belgian franc (financial) random\",\n        \"1.00 Belgian franc random\",\n        \"1.00 Belgian francs (convertible) random\",\n        \"1.00 Belgian francs (financial) random\",\n        \"1.00 Belgian francs random\",\n        \"1.00 Belize Dollar random\",\n        \"1.00 Belize dollar random\",\n        \"1.00 Belize dollars random\",\n        \"1.00 Bermudan Dollar random\",\n        \"1.00 Bermudan dollar random\",\n        \"1.00 Bermudan dollars random\",\n        \"1.00 Bhutanese Ngultrum random\",\n        \"1.00 Bhutanese ngultrum random\",\n        \"1.00 Bhutanese ngultrums random\",\n        \"1.00 Bolivian Mvdol random\",\n        \"1.00 Bolivian Peso random\",\n        \"1.00 Bolivian mvdol random\",\n        \"1.00 Bolivian mvdols random\",\n        \"1.00 Bolivian peso random\",\n        \"1.00 Bolivian pesos random\",\n        \"1.00 Bolivian Boliviano random\",\n        \"1.00 Bolivian Boliviano random\",\n        \"1.00 Bolivian Bolivianos random\",\n        \"1.00 Bosnia-Herzegovina Convertible Mark random\",\n        \"1.00 Bosnia-Herzegovina Dinar (1992\\\\u20131994) random\",\n        \"1.00 Bosnia-Herzegovina convertible mark random\",\n        \"1.00 Bosnia-Herzegovina convertible marks random\",\n        \"1.00 Bosnia-Herzegovina dinar (1992\\\\u20131994) random\",\n        \"1.00 Bosnia-Herzegovina dinars (1992\\\\u20131994) random\",\n        \"1.00 Botswanan Pula random\",\n        \"1.00 Botswanan pula random\",\n        \"1.00 Botswanan pulas random\",\n        \"1.00 Brazilian New Cruzado (1989\\\\u20131990) random\",\n        \"1.00 Brazilian Cruzado (1986\\\\u20131989) random\",\n        \"1.00 Brazilian Cruzeiro (1990\\\\u20131993) random\",\n        \"1.00 Brazilian New Cruzeiro (1967\\\\u20131986) random\",\n        \"1.00 Brazilian Cruzeiro (1993\\\\u20131994) random\",\n        \"1.00 Brazilian Real random\",\n        \"1.00 Brazilian new cruzado (1989\\\\u20131990) random\",\n        \"1.00 Brazilian new cruzados (1989\\\\u20131990) random\",\n        \"1.00 Brazilian cruzado (1986\\\\u20131989) random\",\n        \"1.00 Brazilian cruzados (1986\\\\u20131989) random\",\n        \"1.00 Brazilian cruzeiro (1990\\\\u20131993) random\",\n        \"1.00 Brazilian new cruzeiro (1967\\\\u20131986) random\",\n        \"1.00 Brazilian cruzeiro (1993\\\\u20131994) random\",\n        \"1.00 Brazilian cruzeiros (1990\\\\u20131993) random\",\n        \"1.00 Brazilian new cruzeiros (1967\\\\u20131986) random\",\n        \"1.00 Brazilian cruzeiros (1993\\\\u20131994) random\",\n        \"1.00 Brazilian real random\",\n        \"1.00 Brazilian reals random\",\n        \"1.00 British Pound random\",\n        \"1.00 British pound random\",\n        \"1.00 British pounds random\",\n        \"1.00 Brunei Dollar random\",\n        \"1.00 Brunei dollar random\",\n        \"1.00 Brunei dollars random\",\n        \"1.00 Bulgarian Hard Lev random\",\n        \"1.00 Bulgarian Lev random\",\n        \"1.00 Bulgarian Leva random\",\n        \"1.00 Bulgarian hard lev random\",\n        \"1.00 Bulgarian hard leva random\",\n        \"1.00 Bulgarian lev random\",\n        \"1.00 Burmese Kyat random\",\n        \"1.00 Burmese kyat random\",\n        \"1.00 Burmese kyats random\",\n        \"1.00 Burundian Franc random\",\n        \"1.00 Burundian franc random\",\n        \"1.00 Burundian francs random\",\n        \"1.00 Cambodian Riel random\",\n        \"1.00 Cambodian riel random\",\n        \"1.00 Cambodian riels random\",\n        \"1.00 Canadian Dollar random\",\n        \"1.00 Canadian dollar random\",\n        \"1.00 Canadian dollars random\",\n        \"1.00 Cape Verdean Escudo random\",\n        \"1.00 Cape Verdean escudo random\",\n        \"1.00 Cape Verdean escudos random\",\n        \"1.00 Cayman Islands Dollar random\",\n        \"1.00 Cayman Islands dollar random\",\n        \"1.00 Cayman Islands dollars random\",\n        \"1.00 Chilean Peso random\",\n        \"1.00 Chilean Unit of Account (UF) random\",\n        \"1.00 Chilean peso random\",\n        \"1.00 Chilean pesos random\",\n        \"1.00 Chilean unit of account (UF) random\",\n        \"1.00 Chilean units of account (UF) random\",\n        \"1.00 Chinese Yuan random\",\n        \"1.00 Chinese yuan random\",\n        \"1.00 Colombian Peso random\",\n        \"1.00 Colombian peso random\",\n        \"1.00 Colombian pesos random\",\n        \"1.00 Comorian Franc random\",\n        \"1.00 Comorian franc random\",\n        \"1.00 Comorian francs random\",\n        \"1.00 Congolese Franc Congolais random\",\n        \"1.00 Congolese franc Congolais random\",\n        \"1.00 Congolese francs Congolais random\",\n        \"1.00 Costa Rican Col\\\\u00f3n random\",\n        \"1.00 Costa Rican col\\\\u00f3n random\",\n        \"1.00 Costa Rican col\\\\u00f3ns random\",\n        \"1.00 Croatian Dinar random\",\n        \"1.00 Croatian Kuna random\",\n        \"1.00 Croatian dinar random\",\n        \"1.00 Croatian dinars random\",\n        \"1.00 Croatian kuna random\",\n        \"1.00 Croatian kunas random\",\n        \"1.00 Cuban Peso random\",\n        \"1.00 Cuban peso random\",\n        \"1.00 Cuban pesos random\",\n        \"1.00 Cypriot Pound random\",\n        \"1.00 Cypriot pound random\",\n        \"1.00 Cypriot pounds random\",\n        \"1.00 Czech Koruna random\",\n        \"1.00 Czech koruna random\",\n        \"1.00 Czech korunas random\",\n        \"1.00 Czechoslovak Hard Koruna random\",\n        \"1.00 Czechoslovak hard koruna random\",\n        \"1.00 Czechoslovak hard korunas random\",\n        \"1.00 Danish Krone random\",\n        \"1.00 Danish krone random\",\n        \"1.00 Danish kroner random\",\n        \"1.00 German Mark random\",\n        \"1.00 German mark random\",\n        \"1.00 German marks random\",\n        \"1.00 Djiboutian Franc random\",\n        \"1.00 Djiboutian franc random\",\n        \"1.00 Djiboutian francs random\",\n        \"1.00 Dominican Peso random\",\n        \"1.00 Dominican peso random\",\n        \"1.00 Dominican pesos random\",\n        \"1.00 East Caribbean Dollar random\",\n        \"1.00 East Caribbean dollar random\",\n        \"1.00 East Caribbean dollars random\",\n        \"1.00 East German Mark random\",\n        \"1.00 East German mark random\",\n        \"1.00 East German marks random\",\n        \"1.00 Ecuadorian Sucre random\",\n        \"1.00 Ecuadorian Unit of Constant Value random\",\n        \"1.00 Ecuadorian sucre random\",\n        \"1.00 Ecuadorian sucres random\",\n        \"1.00 Ecuadorian unit of constant value random\",\n        \"1.00 Ecuadorian units of constant value random\",\n        \"1.00 Egyptian Pound random\",\n        \"1.00 Egyptian pound random\",\n        \"1.00 Egyptian pounds random\",\n        \"1.00 Salvadoran Col\\\\u00f3n random\",\n        \"1.00 Salvadoran col\\\\u00f3n random\",\n        \"1.00 Salvadoran colones random\",\n        \"1.00 Equatorial Guinean Ekwele random\",\n        \"1.00 Equatorial Guinean ekwele random\",\n        \"1.00 Eritrean Nakfa random\",\n        \"1.00 Eritrean nakfa random\",\n        \"1.00 Eritrean nakfas random\",\n        \"1.00 Estonian Kroon random\",\n        \"1.00 Estonian kroon random\",\n        \"1.00 Estonian kroons random\",\n        \"1.00 Ethiopian Birr random\",\n        \"1.00 Ethiopian birr random\",\n        \"1.00 Ethiopian birrs random\",\n        \"1.00 European Composite Unit random\",\n        \"1.00 European Currency Unit random\",\n        \"1.00 European Monetary Unit random\",\n        \"1.00 European Unit of Account (XBC) random\",\n        \"1.00 European Unit of Account (XBD) random\",\n        \"1.00 European composite unit random\",\n        \"1.00 European composite units random\",\n        \"1.00 European currency unit random\",\n        \"1.00 European currency units random\",\n        \"1.00 European monetary unit random\",\n        \"1.00 European monetary units random\",\n        \"1.00 European unit of account (XBC) random\",\n        \"1.00 European unit of account (XBD) random\",\n        \"1.00 European units of account (XBC) random\",\n        \"1.00 European units of account (XBD) random\",\n        \"1.00 Falkland Islands Pound random\",\n        \"1.00 Falkland Islands pound random\",\n        \"1.00 Falkland Islands pounds random\",\n        \"1.00 Fijian Dollar random\",\n        \"1.00 Fijian dollar random\",\n        \"1.00 Fijian dollars random\",\n        \"1.00 Finnish Markka random\",\n        \"1.00 Finnish markka random\",\n        \"1.00 Finnish markkas random\",\n        \"1.00 French Franc random\",\n        \"1.00 French Gold Franc random\",\n        \"1.00 French UIC-Franc random\",\n        \"1.00 French UIC-franc random\",\n        \"1.00 French UIC-francs random\",\n        \"1.00 French franc random\",\n        \"1.00 French francs random\",\n        \"1.00 French gold franc random\",\n        \"1.00 French gold francs random\",\n        \"1.00 Gambian Dalasi random\",\n        \"1.00 Gambian dalasi random\",\n        \"1.00 Gambian dalasis random\",\n        \"1.00 Georgian Kupon Larit random\",\n        \"1.00 Georgian Lari random\",\n        \"1.00 Georgian kupon larit random\",\n        \"1.00 Georgian kupon larits random\",\n        \"1.00 Georgian lari random\",\n        \"1.00 Georgian laris random\",\n        \"1.00 Ghanaian Cedi (1979\\\\u20132007) random\",\n        \"1.00 Ghanaian Cedi random\",\n        \"1.00 Ghanaian cedi (1979\\\\u20132007) random\",\n        \"1.00 Ghanaian cedi random\",\n        \"1.00 Ghanaian cedis (1979\\\\u20132007) random\",\n        \"1.00 Ghanaian cedis random\",\n        \"1.00 Gibraltar Pound random\",\n        \"1.00 Gibraltar pound random\",\n        \"1.00 Gibraltar pounds random\",\n        \"1.00 Gold random\",\n        \"1.00 Gold random\",\n        \"1.00 Greek Drachma random\",\n        \"1.00 Greek drachma random\",\n        \"1.00 Greek drachmas random\",\n        \"1.00 Guatemalan Quetzal random\",\n        \"1.00 Guatemalan quetzal random\",\n        \"1.00 Guatemalan quetzals random\",\n        \"1.00 Guinean Franc random\",\n        \"1.00 Guinean Syli random\",\n        \"1.00 Guinean franc random\",\n        \"1.00 Guinean francs random\",\n        \"1.00 Guinean syli random\",\n        \"1.00 Guinean sylis random\",\n        \"1.00 Guinea-Bissau Peso random\",\n        \"1.00 Guinea-Bissau peso random\",\n        \"1.00 Guinea-Bissau pesos random\",\n        \"1.00 Guyanaese Dollar random\",\n        \"1.00 Guyanaese dollar random\",\n        \"1.00 Guyanaese dollars random\",\n        \"1.00 Haitian Gourde random\",\n        \"1.00 Haitian gourde random\",\n        \"1.00 Haitian gourdes random\",\n        \"1.00 Honduran Lempira random\",\n        \"1.00 Honduran lempira random\",\n        \"1.00 Honduran lempiras random\",\n        \"1.00 Hong Kong Dollar random\",\n        \"1.00 Hong Kong dollar random\",\n        \"1.00 Hong Kong dollars random\",\n        \"1.00 Hungarian Forint random\",\n        \"1.00 Hungarian forint random\",\n        \"1.00 Hungarian forints random\",\n        \"1.00 Icelandic Kr\\\\u00f3na random\",\n        \"1.00 Icelandic kr\\\\u00f3na random\",\n        \"1.00 Icelandic kr\\\\u00f3nur random\",\n        \"1.00 Indian Rupee random\",\n        \"1.00 Indian rupee random\",\n        \"1.00 Indian rupees random\",\n        \"1.00 Indonesian Rupiah random\",\n        \"1.00 Indonesian rupiah random\",\n        \"1.00 Indonesian rupiahs random\",\n        \"1.00 Iranian Rial random\",\n        \"1.00 Iranian rial random\",\n        \"1.00 Iranian rials random\",\n        \"1.00 Iraqi Dinar random\",\n        \"1.00 Iraqi dinar random\",\n        \"1.00 Iraqi dinars random\",\n        \"1.00 Irish Pound random\",\n        \"1.00 Irish pound random\",\n        \"1.00 Irish pounds random\",\n        \"1.00 Israeli Pound random\",\n        \"1.00 Israeli new shekel random\",\n        \"1.00 Israeli pound random\",\n        \"1.00 Israeli pounds random\",\n        \"1.00 Italian Lira random\",\n        \"1.00 Italian lira random\",\n        \"1.00 Italian liras random\",\n        \"1.00 Jamaican Dollar random\",\n        \"1.00 Jamaican dollar random\",\n        \"1.00 Jamaican dollars random\",\n        \"1.00 Japanese Yen random\",\n        \"1.00 Japanese yen random\",\n        \"1.00 Jordanian Dinar random\",\n        \"1.00 Jordanian dinar random\",\n        \"1.00 Jordanian dinars random\",\n        \"1.00 Kazakhstani Tenge random\",\n        \"1.00 Kazakhstani tenge random\",\n        \"1.00 Kazakhstani tenges random\",\n        \"1.00 Kenyan Shilling random\",\n        \"1.00 Kenyan shilling random\",\n        \"1.00 Kenyan shillings random\",\n        \"1.00 Kuwaiti Dinar random\",\n        \"1.00 Kuwaiti dinar random\",\n        \"1.00 Kuwaiti dinars random\",\n        \"1.00 Kyrgystani Som random\",\n        \"1.00 Kyrgystani som random\",\n        \"1.00 Kyrgystani soms random\",\n        \"1.00 Laotian Kip random\",\n        \"1.00 Laotian kip random\",\n        \"1.00 Laotian kips random\",\n        \"1.00 Latvian Lats random\",\n        \"1.00 Latvian Ruble random\",\n        \"1.00 Latvian lats random\",\n        \"1.00 Latvian lati random\",\n        \"1.00 Latvian ruble random\",\n        \"1.00 Latvian rubles random\",\n        \"1.00 Lebanese Pound random\",\n        \"1.00 Lebanese pound random\",\n        \"1.00 Lebanese pounds random\",\n        \"1.00 Lesotho Loti random\",\n        \"1.00 Lesotho loti random\",\n        \"1.00 Lesotho lotis random\",\n        \"1.00 Liberian Dollar random\",\n        \"1.00 Liberian dollar random\",\n        \"1.00 Liberian dollars random\",\n        \"1.00 Libyan Dinar random\",\n        \"1.00 Libyan dinar random\",\n        \"1.00 Libyan dinars random\",\n        \"1.00 Lithuanian Litas random\",\n        \"1.00 Lithuanian Talonas random\",\n        \"1.00 Lithuanian litas random\",\n        \"1.00 Lithuanian litai random\",\n        \"1.00 Lithuanian talonas random\",\n        \"1.00 Lithuanian talonases random\",\n        \"1.00 Luxembourgian Convertible Franc random\",\n        \"1.00 Luxembourg Financial Franc random\",\n        \"1.00 Luxembourgian Franc random\",\n        \"1.00 Luxembourgian convertible franc random\",\n        \"1.00 Luxembourgian convertible francs random\",\n        \"1.00 Luxembourg financial franc random\",\n        \"1.00 Luxembourg financial francs random\",\n        \"1.00 Luxembourgian franc random\",\n        \"1.00 Luxembourgian francs random\",\n        \"1.00 Macanese Pataca random\",\n        \"1.00 Macanese pataca random\",\n        \"1.00 Macanese patacas random\",\n        \"1.00 Macedonian Denar random\",\n        \"1.00 Macedonian denar random\",\n        \"1.00 Macedonian denari random\",\n        \"1.00 Malagasy Ariaries random\",\n        \"1.00 Malagasy Ariary random\",\n        \"1.00 Malagasy Ariary random\",\n        \"1.00 Malagasy Franc random\",\n        \"1.00 Malagasy franc random\",\n        \"1.00 Malagasy francs random\",\n        \"1.00 Malawian Kwacha random\",\n        \"1.00 Malawian Kwacha random\",\n        \"1.00 Malawian Kwachas random\",\n        \"1.00 Malaysian Ringgit random\",\n        \"1.00 Malaysian ringgit random\",\n        \"1.00 Malaysian ringgits random\",\n        \"1.00 Maldivian Rufiyaa random\",\n        \"1.00 Maldivian rufiyaa random\",\n        \"1.00 Maldivian rufiyaas random\",\n        \"1.00 Malian Franc random\",\n        \"1.00 Malian franc random\",\n        \"1.00 Malian francs random\",\n        \"1.00 Maltese Lira random\",\n        \"1.00 Maltese Pound random\",\n        \"1.00 Maltese lira random\",\n        \"1.00 Maltese liras random\",\n        \"1.00 Maltese pound random\",\n        \"1.00 Maltese pounds random\",\n        \"1.00 Mauritanian Ouguiya random\",\n        \"1.00 Mauritanian ouguiya random\",\n        \"1.00 Mauritanian ouguiyas random\",\n        \"1.00 Mauritian Rupee random\",\n        \"1.00 Mauritian rupee random\",\n        \"1.00 Mauritian rupees random\",\n        \"1.00 Mexican Peso random\",\n        \"1.00 Mexican Silver Peso (1861\\\\u20131992) random\",\n        \"1.00 Mexican Investment Unit random\",\n        \"1.00 Mexican peso random\",\n        \"1.00 Mexican pesos random\",\n        \"1.00 Mexican silver peso (1861\\\\u20131992) random\",\n        \"1.00 Mexican silver pesos (1861\\\\u20131992) random\",\n        \"1.00 Mexican investment unit random\",\n        \"1.00 Mexican investment units random\",\n        \"1.00 Moldovan Leu random\",\n        \"1.00 Moldovan leu random\",\n        \"1.00 Moldovan lei random\",\n        \"1.00 Mongolian Tugrik random\",\n        \"1.00 Mongolian tugrik random\",\n        \"1.00 Mongolian tugriks random\",\n        \"1.00 Moroccan Dirham random\",\n        \"1.00 Moroccan Franc random\",\n        \"1.00 Moroccan dirham random\",\n        \"1.00 Moroccan dirhams random\",\n        \"1.00 Moroccan franc random\",\n        \"1.00 Moroccan francs random\",\n        \"1.00 Mozambican Escudo random\",\n        \"1.00 Mozambican Metical random\",\n        \"1.00 Mozambican escudo random\",\n        \"1.00 Mozambican escudos random\",\n        \"1.00 Mozambican metical random\",\n        \"1.00 Mozambican meticals random\",\n        \"1.00 Myanmar Kyat random\",\n        \"1.00 Myanmar kyat random\",\n        \"1.00 Myanmar kyats random\",\n        \"1.00 Namibian Dollar random\",\n        \"1.00 Namibian dollar random\",\n        \"1.00 Namibian dollars random\",\n        \"1.00 Nepalese Rupee random\",\n        \"1.00 Nepalese rupee random\",\n        \"1.00 Nepalese rupees random\",\n        \"1.00 Netherlands Antillean Guilder random\",\n        \"1.00 Netherlands Antillean guilder random\",\n        \"1.00 Netherlands Antillean guilders random\",\n        \"1.00 Dutch Guilder random\",\n        \"1.00 Dutch guilder random\",\n        \"1.00 Dutch guilders random\",\n        \"1.00 Israeli New Shekel random\",\n        \"1.00 Israeli new shekels random\",\n        \"1.00 New Zealand Dollar random\",\n        \"1.00 New Zealand dollar random\",\n        \"1.00 New Zealand dollars random\",\n        \"1.00 Nicaraguan C\\\\u00f3rdoba random\",\n        \"1.00 Nicaraguan C\\\\u00f3rdoba (1988\\\\u20131991) random\",\n        \"1.00 Nicaraguan c\\\\u00f3rdoba random\",\n        \"1.00 Nicaraguan c\\\\u00f3rdoba random\",\n        \"1.00 Nicaraguan c\\\\u00f3rdoba (1988\\\\u20131991) random\",\n        \"1.00 Nicaraguan c\\\\u00f3rdobas (1988\\\\u20131991) random\",\n        \"1.00 Nigerian Naira random\",\n        \"1.00 Nigerian naira random\",\n        \"1.00 Nigerian nairas random\",\n        \"1.00 North Korean Won random\",\n        \"1.00 North Korean won random\",\n        \"1.00 North Korean won random\",\n        \"1.00 Norwegian Krone random\",\n        \"1.00 Norwegian krone random\",\n        \"1.00 Norwegian kroner random\",\n        \"1.00 Mozambican Metical (1980\\\\u20132006) random\",\n        \"1.00 Mozambican metical (1980\\\\u20132006) random\",\n        \"1.00 Mozambican meticals (1980\\\\u20132006) random\",\n        \"1.00 Romanian Lei (1952\\\\u20132006) random\",\n        \"1.00 Romanian Leu (1952\\\\u20132006) random\",\n        \"1.00 Romanian leu (1952\\\\u20132006) random\",\n        \"1.00 Serbian Dinar (2002\\\\u20132006) random\",\n        \"1.00 Serbian dinar (2002\\\\u20132006) random\",\n        \"1.00 Serbian dinars (2002\\\\u20132006) random\",\n        \"1.00 Sudanese Dinar (1992\\\\u20132007) random\",\n        \"1.00 Sudanese Pound (1957\\\\u20131998) random\",\n        \"1.00 Sudanese dinar (1992\\\\u20132007) random\",\n        \"1.00 Sudanese dinars (1992\\\\u20132007) random\",\n        \"1.00 Sudanese pound (1957\\\\u20131998) random\",\n        \"1.00 Sudanese pounds (1957\\\\u20131998) random\",\n        \"1.00 Turkish Lira (1922\\\\u20132005) random\",\n        \"1.00 Turkish Lira (1922\\\\u20132005) random\",\n        \"1.00 Omani Rial random\",\n        \"1.00 Omani rial random\",\n        \"1.00 Omani rials random\",\n        \"1.00 Pakistani Rupee random\",\n        \"1.00 Pakistani rupee random\",\n        \"1.00 Pakistani rupees random\",\n        \"1.00 Palladium random\",\n        \"1.00 Palladium random\",\n        \"1.00 Panamanian Balboa random\",\n        \"1.00 Panamanian balboa random\",\n        \"1.00 Panamanian balboas random\",\n        \"1.00 Papua New Guinean Kina random\",\n        \"1.00 Papua New Guinean kina random\",\n        \"1.00 Papua New Guinean kina random\",\n        \"1.00 Paraguayan Guarani random\",\n        \"1.00 Paraguayan guarani random\",\n        \"1.00 Paraguayan guaranis random\",\n        \"1.00 Peruvian Inti random\",\n        \"1.00 Peruvian Sol random\",\n        \"1.00 Peruvian Sol (1863\\\\u20131965) random\",\n        \"1.00 Peruvian inti random\",\n        \"1.00 Peruvian intis random\",\n        \"1.00 Peruvian sol random\",\n        \"1.00 Peruvian soles random\",\n        \"1.00 Peruvian sol (1863\\\\u20131965) random\",\n        \"1.00 Peruvian soles (1863\\\\u20131965) random\",\n        \"1.00 Philippine Piso random\",\n        \"1.00 Philippine piso random\",\n        \"1.00 Philippine pisos random\",\n        \"1.00 Platinum random\",\n        \"1.00 Platinum random\",\n        \"1.00 Polish Zloty (1950\\\\u20131995) random\",\n        \"1.00 Polish Zloty random\",\n        \"1.00 Polish zlotys random\",\n        \"1.00 Polish zloty (PLZ) random\",\n        \"1.00 Polish zloty random\",\n        \"1.00 Polish zlotys (PLZ) random\",\n        \"1.00 Portuguese Escudo random\",\n        \"1.00 Portuguese Guinea Escudo random\",\n        \"1.00 Portuguese Guinea escudo random\",\n        \"1.00 Portuguese Guinea escudos random\",\n        \"1.00 Portuguese escudo random\",\n        \"1.00 Portuguese escudos random\",\n        \"1.00 Qatari Rial random\",\n        \"1.00 Qatari rial random\",\n        \"1.00 Qatari rials random\",\n        \"1.00 RINET Funds random\",\n        \"1.00 RINET Funds random\",\n        \"1.00 Rhodesian Dollar random\",\n        \"1.00 Rhodesian dollar random\",\n        \"1.00 Rhodesian dollars random\",\n        \"1.00 Romanian Leu random\",\n        \"1.00 Romanian lei random\",\n        \"1.00 Romanian leu random\",\n        \"1.00 Russian Ruble (1991\\\\u20131998) random\",\n        \"1.00 Russian Ruble random\",\n        \"1.00 Russian ruble (1991\\\\u20131998) random\",\n        \"1.00 Russian ruble random\",\n        \"1.00 Russian rubles (1991\\\\u20131998) random\",\n        \"1.00 Russian rubles random\",\n        \"1.00 Rwandan Franc random\",\n        \"1.00 Rwandan franc random\",\n        \"1.00 Rwandan francs random\",\n        \"1.00 St. Helena Pound random\",\n        \"1.00 St. Helena pound random\",\n        \"1.00 St. Helena pounds random\",\n        \"1.00 S\\\\u00e3o Tom\\\\u00e9 & Pr\\\\u00edncipe Dobra random\",\n        \"1.00 S\\\\u00e3o Tom\\\\u00e9 & Pr\\\\u00edncipe dobra random\",\n        \"1.00 S\\\\u00e3o Tom\\\\u00e9 & Pr\\\\u00edncipe dobras random\",\n        \"1.00 Saudi Riyal random\",\n        \"1.00 Saudi riyal random\",\n        \"1.00 Saudi riyals random\",\n        \"1.00 Serbian Dinar random\",\n        \"1.00 Serbian dinar random\",\n        \"1.00 Serbian dinars random\",\n        \"1.00 Seychellois Rupee random\",\n        \"1.00 Seychellois rupee random\",\n        \"1.00 Seychellois rupees random\",\n        \"1.00 Sierra Leonean Leone random\",\n        \"1.00 Sierra Leonean leone random\",\n        \"1.00 Sierra Leonean leones random\",\n        \"1.00 Singapore Dollar random\",\n        \"1.00 Singapore dollar random\",\n        \"1.00 Singapore dollars random\",\n        \"1.00 Slovak Koruna random\",\n        \"1.00 Slovak koruna random\",\n        \"1.00 Slovak korunas random\",\n        \"1.00 Slovenian Tolar random\",\n        \"1.00 Slovenian tolar random\",\n        \"1.00 Slovenian tolars random\",\n        \"1.00 Solomon Islands Dollar random\",\n        \"1.00 Solomon Islands dollar random\",\n        \"1.00 Solomon Islands dollars random\",\n        \"1.00 Somali Shilling random\",\n        \"1.00 Somali shilling random\",\n        \"1.00 Somali shillings random\",\n        \"1.00 South African Rand (financial) random\",\n        \"1.00 South African Rand random\",\n        \"1.00 South African rand (financial) random\",\n        \"1.00 South African rand random\",\n        \"1.00 South African rands (financial) random\",\n        \"1.00 South African rand random\",\n        \"1.00 South Korean Won random\",\n        \"1.00 South Korean won random\",\n        \"1.00 South Korean won random\",\n        \"1.00 Soviet Rouble random\",\n        \"1.00 Soviet rouble random\",\n        \"1.00 Soviet roubles random\",\n        \"1.00 Spanish Peseta (A account) random\",\n        \"1.00 Spanish Peseta (convertible account) random\",\n        \"1.00 Spanish Peseta random\",\n        \"1.00 Spanish peseta (A account) random\",\n        \"1.00 Spanish peseta (convertible account) random\",\n        \"1.00 Spanish peseta random\",\n        \"1.00 Spanish pesetas (A account) random\",\n        \"1.00 Spanish pesetas (convertible account) random\",\n        \"1.00 Spanish pesetas random\",\n        \"1.00 Special Drawing Rights random\",\n        \"1.00 Sri Lankan Rupee random\",\n        \"1.00 Sri Lankan rupee random\",\n        \"1.00 Sri Lankan rupees random\",\n        \"1.00 Sudanese Pound random\",\n        \"1.00 Sudanese pound random\",\n        \"1.00 Sudanese pounds random\",\n        \"1.00 Surinamese Dollar random\",\n        \"1.00 Surinamese dollar random\",\n        \"1.00 Surinamese dollars random\",\n        \"1.00 Surinamese Guilder random\",\n        \"1.00 Surinamese guilder random\",\n        \"1.00 Surinamese guilders random\",\n        \"1.00 Swazi Lilangeni random\",\n        \"1.00 Swazi lilangeni random\",\n        \"1.00 Swazi emalangeni random\",\n        \"1.00 Swedish Krona random\",\n        \"1.00 Swedish krona random\",\n        \"1.00 Swedish kronor random\",\n        \"1.00 Swiss Franc random\",\n        \"1.00 Swiss franc random\",\n        \"1.00 Swiss francs random\",\n        \"1.00 Syrian Pound random\",\n        \"1.00 Syrian pound random\",\n        \"1.00 Syrian pounds random\",\n        \"1.00 New Taiwan Dollar random\",\n        \"1.00 New Taiwan dollar random\",\n        \"1.00 New Taiwan dollars random\",\n        \"1.00 Tajikistani Ruble random\",\n        \"1.00 Tajikistani Somoni random\",\n        \"1.00 Tajikistani ruble random\",\n        \"1.00 Tajikistani rubles random\",\n        \"1.00 Tajikistani somoni random\",\n        \"1.00 Tajikistani somonis random\",\n        \"1.00 Tanzanian Shilling random\",\n        \"1.00 Tanzanian shilling random\",\n        \"1.00 Tanzanian shillings random\",\n        \"1.00 Testing Currency Code random\",\n        \"1.00 Testing Currency Code random\",\n        \"1.00 Thai Baht random\",\n        \"1.00 Thai baht random\",\n        \"1.00 Thai baht random\",\n        \"1.00 Timorese Escudo random\",\n        \"1.00 Timorese escudo random\",\n        \"1.00 Timorese escudos random\",\n        \"1.00 Trinidad & Tobago Dollar random\",\n        \"1.00 Trinidad & Tobago dollar random\",\n        \"1.00 Trinidad & Tobago dollars random\",\n        \"1.00 Tunisian Dinar random\",\n        \"1.00 Tunisian dinar random\",\n        \"1.00 Tunisian dinars random\",\n        \"1.00 Turkish Lira random\",\n        \"1.00 Turkish Lira random\",\n        \"1.00 Turkish lira random\",\n        \"1.00 Turkmenistani Manat random\",\n        \"1.00 Turkmenistani manat random\",\n        \"1.00 Turkmenistani manat random\",\n        \"1.00 US Dollar (Next day) random\",\n        \"1.00 US Dollar (Same day) random\",\n        \"1.00 US Dollar random\",\n        \"1.00 US dollar (next day) random\",\n        \"1.00 US dollar (same day) random\",\n        \"1.00 US dollar random\",\n        \"1.00 US dollars (next day) random\",\n        \"1.00 US dollars (same day) random\",\n        \"1.00 US dollars random\",\n        \"1.00 Ugandan Shilling (1966\\\\u20131987) random\",\n        \"1.00 Ugandan Shilling random\",\n        \"1.00 Ugandan shilling (1966\\\\u20131987) random\",\n        \"1.00 Ugandan shilling random\",\n        \"1.00 Ugandan shillings (1966\\\\u20131987) random\",\n        \"1.00 Ugandan shillings random\",\n        \"1.00 Ukrainian Hryvnia random\",\n        \"1.00 Ukrainian Karbovanets random\",\n        \"1.00 Ukrainian hryvnia random\",\n        \"1.00 Ukrainian hryvnias random\",\n        \"1.00 Ukrainian karbovanets random\",\n        \"1.00 Ukrainian karbovantsiv random\",\n        \"1.00 Colombian Real Value Unit random\",\n        \"1.00 United Arab Emirates Dirham random\",\n        \"1.00 Unknown Currency random\",\n        \"1.00 Uruguayan Peso (1975\\\\u20131993) random\",\n        \"1.00 Uruguayan Peso random\",\n        \"1.00 Uruguayan Peso (Indexed Units) random\",\n        \"1.00 Uruguayan peso (1975\\\\u20131993) random\",\n        \"1.00 Uruguayan peso (indexed units) random\",\n        \"1.00 Uruguayan peso random\",\n        \"1.00 Uruguayan pesos (1975\\\\u20131993) random\",\n        \"1.00 Uruguayan pesos (indexed units) random\",\n        \"1.00 Uzbekistani Som random\",\n        \"1.00 Uzbekistani som random\",\n        \"1.00 Uzbekistani som random\",\n        \"1.00 Vanuatu Vatu random\",\n        \"1.00 Vanuatu vatu random\",\n        \"1.00 Vanuatu vatus random\",\n        \"1.00 Venezuelan Bol\\\\u00edvar random\",\n        \"1.00 Venezuelan Bol\\\\u00edvar (1871\\\\u20132008) random\",\n        \"1.00 Venezuelan bol\\\\u00edvar random\",\n        \"1.00 Venezuelan bol\\\\u00edvars random\",\n        \"1.00 Venezuelan bol\\\\u00edvar (1871\\\\u20132008) random\",\n        \"1.00 Venezuelan bol\\\\u00edvars (1871\\\\u20132008) random\",\n        \"1.00 Vietnamese Dong random\",\n        \"1.00 Vietnamese dong random\",\n        \"1.00 Vietnamese dong random\",\n        \"1.00 WIR Euro random\",\n        \"1.00 WIR Franc random\",\n        \"1.00 WIR euro random\",\n        \"1.00 WIR euros random\",\n        \"1.00 WIR franc random\",\n        \"1.00 WIR francs random\",\n        \"1.00 Samoan Tala random\",\n        \"1.00 Samoan tala random\",\n        \"1.00 Samoan tala random\",\n        \"1.00 Yemeni Dinar random\",\n        \"1.00 Yemeni Rial random\",\n        \"1.00 Yemeni dinar random\",\n        \"1.00 Yemeni dinars random\",\n        \"1.00 Yemeni rial random\",\n        \"1.00 Yemeni rials random\",\n        \"1.00 Yugoslavian Convertible Dinar (1990\\\\u20131992) random\",\n        \"1.00 Yugoslavian Hard Dinar (1966\\\\u20131990) random\",\n        \"1.00 Yugoslavian New Dinar (1994\\\\u20132002) random\",\n        \"1.00 Yugoslavian convertible dinar (1990\\\\u20131992) random\",\n        \"1.00 Yugoslavian convertible dinars (1990\\\\u20131992) random\",\n        \"1.00 Yugoslavian hard dinar (1966\\\\u20131990) random\",\n        \"1.00 Yugoslavian hard dinars (1966\\\\u20131990) random\",\n        \"1.00 Yugoslavian new dinar (1994\\\\u20132002) random\",\n        \"1.00 Yugoslavian new dinars (1994\\\\u20132002) random\",\n        \"1.00 Zairean New Zaire (1993\\\\u20131998) random\",\n        \"1.00 Zairean Zaire (1971\\\\u20131993) random\",\n        \"1.00 Zairean new zaire (1993\\\\u20131998) random\",\n        \"1.00 Zairean new zaires (1993\\\\u20131998) random\",\n        \"1.00 Zairean zaire (1971\\\\u20131993) random\",\n        \"1.00 Zairean zaires (1971\\\\u20131993) random\",\n        \"1.00 Zambian Kwacha random\",\n        \"1.00 Zambian kwacha random\",\n        \"1.00 Zambian kwachas random\",\n        \"1.00 Zimbabwean Dollar (1980\\\\u20132008) random\",\n        \"1.00 Zimbabwean dollar (1980\\\\u20132008) random\",\n        \"1.00 Zimbabwean dollars (1980\\\\u20132008) random\",\n        \"1.00 euro random\",\n        \"1.00 euros random\",\n        \"1.00 Turkish lira (1922\\\\u20132005) random\",\n        \"1.00 special drawing rights random\",\n        \"1.00 Colombian real value unit random\",\n        \"1.00 Colombian real value units random\",\n        \"1.00 unknown currency random\",\n    };\n\n    const char* WRONG_DATA[] = {\n        // Following are missing one last char in the currency name\n        \"1.00 Nicaraguan Cordob\",\n        \"1.00 Namibian Dolla\",\n        \"1.00 Namibian dolla\",\n        \"1.00 Nepalese Rupe\",\n        \"1.00 Nepalese rupe\",\n        \"1.00 Netherlands Antillean Guilde\",\n        \"1.00 Netherlands Antillean guilde\",\n        \"1.00 Dutch Guilde\",\n        \"1.00 Dutch guilde\",\n        \"1.00 Israeli New Sheqe\",\n        \"1.00 New Zealand Dolla\",\n        \"1.00 New Zealand dolla\",\n        \"1.00 Nicaraguan cordob\",\n        \"1.00 Nigerian Nair\",\n        \"1.00 Nigerian nair\",\n        \"1.00 North Korean Wo\",\n        \"1.00 North Korean wo\",\n        \"1.00 Norwegian Kron\",\n        \"1.00 Norwegian kron\",\n        \"1.00 US dolla\",\n        \"1.00\",\n        \"A1.00\",\n        \"AD1.00\",\n        \"AE1.00\",\n        \"AF1.00\",\n        \"AL1.00\",\n        \"AM1.00\",\n        \"AN1.00\",\n        \"AO1.00\",\n        \"AR1.00\",\n        \"AT1.00\",\n        \"AU1.00\",\n        \"AW1.00\",\n        \"AZ1.00\",\n        \"Afghan Afghan1.00\",\n        \"Afghan Afghani (1927\\\\u201320021.00\",\n        \"Afl1.00\",\n        \"Albanian Le1.00\",\n        \"Algerian Dina1.00\",\n        \"Andorran Peset1.00\",\n        \"Angolan Kwanz1.00\",\n        \"Angolan Kwanza (1977\\\\u201319901.00\",\n        \"Angolan Readjusted Kwanza (1995\\\\u201319991.00\",\n        \"Angolan New Kwanza (1990\\\\u201320001.00\",\n        \"Argentine Austra1.00\",\n        \"Argentine Pes1.00\",\n        \"Argentine Peso (1983\\\\u201319851.00\",\n        \"Armenian Dra1.00\",\n        \"Aruban Flori1.00\",\n        \"Australian Dolla1.00\",\n        \"Austrian Schillin1.00\",\n        \"Azerbaijani Mana1.00\",\n        \"Azerbaijani Manat (1993\\\\u201320061.00\",\n        \"B1.00\",\n        \"BA1.00\",\n        \"BB1.00\",\n        \"BE1.00\",\n        \"BG1.00\",\n        \"BH1.00\",\n        \"BI1.00\",\n        \"BM1.00\",\n        \"BN1.00\",\n        \"BO1.00\",\n        \"BR1.00\",\n        \"BS1.00\",\n        \"BT1.00\",\n        \"BU1.00\",\n        \"BW1.00\",\n        \"BY1.00\",\n        \"BZ1.00\",\n        \"Bahamian Dolla1.00\",\n        \"Bahraini Dina1.00\",\n        \"Bangladeshi Tak1.00\",\n        \"Barbadian Dolla1.00\",\n        \"Bds1.00\",\n        \"Belarusian Ruble (1994\\\\u201319991.00\",\n        \"Belarusian Rubl1.00\",\n        \"Belgian Fran1.00\",\n        \"Belgian Franc (convertible1.00\",\n        \"Belgian Franc (financial1.00\",\n        \"Belize Dolla1.00\",\n        \"Bermudan Dolla1.00\",\n        \"Bhutanese Ngultru1.00\",\n        \"Bolivian Mvdo1.00\",\n        \"Bolivian Pes1.00\",\n        \"Bolivian Bolivian1.00\",\n        \"Bosnia-Herzegovina Convertible Mar1.00\",\n        \"Bosnia-Herzegovina Dina1.00\",\n        \"Botswanan Pul1.00\",\n        \"Brazilian Cruzad1.00\",\n        \"Brazilian Cruzado Nov1.00\",\n        \"Brazilian Cruzeir1.00\",\n        \"Brazilian Cruzeiro (1990\\\\u201319931.00\",\n        \"Brazilian New Cruzeiro (1967\\\\u201319861.00\",\n        \"Brazilian Rea1.00\",\n        \"British Pound Sterlin1.00\",\n        \"Brunei Dolla1.00\",\n        \"Bulgarian Hard Le1.00\",\n        \"Bulgarian Le1.00\",\n        \"Burmese Kya1.00\",\n        \"Burundian Fran1.00\",\n        \"C1.00\",\n        \"CA1.00\",\n        \"CD1.00\",\n        \"CFP Fran1.00\",\n        \"CFP1.00\",\n        \"CH1.00\",\n        \"CL1.00\",\n        \"CN1.00\",\n        \"CO1.00\",\n        \"CS1.00\",\n        \"CU1.00\",\n        \"CV1.00\",\n        \"CY1.00\",\n        \"CZ1.00\",\n        \"Cambodian Rie1.00\",\n        \"Canadian Dolla1.00\",\n        \"Cape Verdean Escud1.00\",\n        \"Cayman Islands Dolla1.00\",\n        \"Chilean Pes1.00\",\n        \"Chilean Unit of Accoun1.00\",\n        \"Chinese Yua1.00\",\n        \"Colombian Pes1.00\",\n        \"Comoro Fran1.00\",\n        \"Congolese Fran1.00\",\n        \"Costa Rican Col\\\\u00f31.00\",\n        \"Croatian Dina1.00\",\n        \"Croatian Kun1.00\",\n        \"Cuban Pes1.00\",\n        \"Cypriot Poun1.00\",\n        \"Czech Republic Korun1.00\",\n        \"Czechoslovak Hard Korun1.00\",\n        \"D1.00\",\n        \"DD1.00\",\n        \"DE1.00\",\n        \"DJ1.00\",\n        \"DK1.00\",\n        \"DO1.00\",\n        \"DZ1.00\",\n        \"Danish Kron1.00\",\n        \"German Mar1.00\",\n        \"Djiboutian Fran1.00\",\n        \"Dk1.00\",\n        \"Dominican Pes1.00\",\n        \"EC1.00\",\n        \"EE1.00\",\n        \"EG1.00\",\n        \"EQ1.00\",\n        \"ER1.00\",\n        \"ES1.00\",\n        \"ET1.00\",\n        \"EU1.00\",\n        \"East Caribbean Dolla1.00\",\n        \"East German Ostmar1.00\",\n        \"Ecuadorian Sucr1.00\",\n        \"Ecuadorian Unit of Constant Valu1.00\",\n        \"Egyptian Poun1.00\",\n        \"Ekwel1.00\",\n        \"Salvadoran Col\\\\u00f31.00\",\n        \"Equatorial Guinean Ekwel1.00\",\n        \"Eritrean Nakf1.00\",\n        \"Es1.00\",\n        \"Estonian Kroo1.00\",\n        \"Ethiopian Bir1.00\",\n        \"Eur1.00\",\n        \"European Composite Uni1.00\",\n        \"European Currency Uni1.00\",\n        \"European Monetary Uni1.00\",\n        \"European Unit of Account (XBC1.00\",\n        \"European Unit of Account (XBD1.00\",\n        \"F1.00\",\n        \"FB1.00\",\n        \"FI1.00\",\n        \"FJ1.00\",\n        \"FK1.00\",\n        \"FR1.00\",\n        \"Falkland Islands Poun1.00\",\n        \"Fd1.00\",\n        \"Fijian Dolla1.00\",\n        \"Finnish Markk1.00\",\n        \"Fr1.00\",\n        \"French Fran1.00\",\n        \"French Gold Fran1.00\",\n        \"French UIC-Fran1.00\",\n        \"G1.00\",\n        \"GB1.00\",\n        \"GE1.00\",\n        \"GH1.00\",\n        \"GI1.00\",\n        \"GM1.00\",\n        \"GN1.00\",\n        \"GQ1.00\",\n        \"GR1.00\",\n        \"GT1.00\",\n        \"GW1.00\",\n        \"GY1.00\",\n        \"Gambian Dalas1.00\",\n        \"Georgian Kupon Lari1.00\",\n        \"Georgian Lar1.00\",\n        \"Ghanaian Ced1.00\",\n        \"Ghanaian Cedi (1979\\\\u201320071.00\",\n        \"Gibraltar Poun1.00\",\n        \"Gol1.00\",\n        \"Greek Drachm1.00\",\n        \"Guatemalan Quetza1.00\",\n        \"Guinean Fran1.00\",\n        \"Guinean Syl1.00\",\n        \"Guinea-Bissau Pes1.00\",\n        \"Guyanaese Dolla1.00\",\n        \"HK1.00\",\n        \"HN1.00\",\n        \"HR1.00\",\n        \"HT1.00\",\n        \"HU1.00\",\n        \"Haitian Gourd1.00\",\n        \"Honduran Lempir1.00\",\n        \"Hong Kong Dolla1.00\",\n        \"Hungarian Forin1.00\",\n        \"I1.00\",\n        \"IE1.00\",\n        \"IL1.00\",\n        \"IN1.00\",\n        \"IQ1.00\",\n        \"IR1.00\",\n        \"IS1.00\",\n        \"IT1.00\",\n        \"Icelandic Kron1.00\",\n        \"Indian Rupe1.00\",\n        \"Indonesian Rupia1.00\",\n        \"Iranian Ria1.00\",\n        \"Iraqi Dina1.00\",\n        \"Irish Poun1.00\",\n        \"Israeli Poun1.00\",\n        \"Italian Lir1.00\",\n        \"J1.00\",\n        \"JM1.00\",\n        \"JO1.00\",\n        \"JP1.00\",\n        \"Jamaican Dolla1.00\",\n        \"Japanese Ye1.00\",\n        \"Jordanian Dina1.00\",\n        \"K S1.00\",\n        \"K1.00\",\n        \"KE1.00\",\n        \"KG1.00\",\n        \"KH1.00\",\n        \"KP1.00\",\n        \"KR1.00\",\n        \"KW1.00\",\n        \"KY1.00\",\n        \"KZ1.00\",\n        \"Kazakhstani Teng1.00\",\n        \"Kenyan Shillin1.00\",\n        \"Kuwaiti Dina1.00\",\n        \"Kyrgystani So1.00\",\n        \"LA1.00\",\n        \"LB1.00\",\n        \"LK1.00\",\n        \"LR1.00\",\n        \"LT1.00\",\n        \"LU1.00\",\n        \"LV1.00\",\n        \"LY1.00\",\n        \"Laotian Ki1.00\",\n        \"Latvian Lat1.00\",\n        \"Latvian Rubl1.00\",\n        \"Lebanese Poun1.00\",\n        \"Lesotho Lot1.00\",\n        \"Liberian Dolla1.00\",\n        \"Libyan Dina1.00\",\n        \"Lithuanian Lit1.00\",\n        \"Lithuanian Talona1.00\",\n        \"Luxembourgian Convertible Fran1.00\",\n        \"Luxembourg Financial Fran1.00\",\n        \"Luxembourgian Fran1.00\",\n        \"MA1.00\",\n        \"MD1.00\",\n        \"MDe1.00\",\n        \"MEX1.00\",\n        \"MG1.00\",\n        \"ML1.00\",\n        \"MM1.00\",\n        \"MN1.00\",\n        \"MO1.00\",\n        \"MR1.00\",\n        \"MT1.00\",\n        \"MU1.00\",\n        \"MV1.00\",\n        \"MW1.00\",\n        \"MX1.00\",\n        \"MY1.00\",\n        \"MZ1.00\",\n        \"Macanese Patac1.00\",\n        \"Macedonian Dena1.00\",\n        \"Malagasy Ariar1.00\",\n        \"Malagasy Fran1.00\",\n        \"Malawian Kwach1.00\",\n        \"Malaysian Ringgi1.00\",\n        \"Maldivian Rufiya1.00\",\n        \"Malian Fran1.00\",\n        \"Malot1.00\",\n        \"Maltese Lir1.00\",\n        \"Maltese Poun1.00\",\n        \"Mauritanian Ouguiy1.00\",\n        \"Mauritian Rupe1.00\",\n        \"Mexican Pes1.00\",\n        \"Mexican Silver Peso (1861\\\\u201319921.00\",\n        \"Mexican Investment Uni1.00\",\n        \"Moldovan Le1.00\",\n        \"Mongolian Tugri1.00\",\n        \"Moroccan Dirha1.00\",\n        \"Moroccan Fran1.00\",\n        \"Mozambican Escud1.00\",\n        \"Mozambican Metica1.00\",\n        \"Myanmar Kya1.00\",\n        \"N1.00\",\n        \"NA1.00\",\n        \"NAf1.00\",\n        \"NG1.00\",\n        \"NI1.00\",\n        \"NK1.00\",\n        \"NL1.00\",\n        \"NO1.00\",\n        \"NP1.00\",\n        \"NT1.00\",\n        \"Namibian Dolla1.00\",\n        \"Nepalese Rupe1.00\",\n        \"Netherlands Antillean Guilde1.00\",\n        \"Dutch Guilde1.00\",\n        \"Israeli New Sheqe1.00\",\n        \"New Zealand Dolla1.00\",\n        \"Nicaraguan C\\\\u00f3rdoba (1988\\\\u201319911.00\",\n        \"Nicaraguan C\\\\u00f3rdob1.00\",\n        \"Nigerian Nair1.00\",\n        \"North Korean Wo1.00\",\n        \"Norwegian Kron1.00\",\n        \"Nr1.00\",\n        \"OM1.00\",\n        \"Old Mozambican Metica1.00\",\n        \"Romanian Leu (1952\\\\u201320061.00\",\n        \"Serbian Dinar (2002\\\\u201320061.00\",\n        \"Sudanese Dinar (1992\\\\u201320071.00\",\n        \"Sudanese Pound (1957\\\\u201319981.00\",\n        \"Turkish Lira (1922\\\\u201320051.00\",\n        \"Omani Ria1.00\",\n        \"PA1.00\",\n        \"PE1.00\",\n        \"PG1.00\",\n        \"PH1.00\",\n        \"PK1.00\",\n        \"PL1.00\",\n        \"PT1.00\",\n        \"PY1.00\",\n        \"Pakistani Rupe1.00\",\n        \"Palladiu1.00\",\n        \"Panamanian Balbo1.00\",\n        \"Papua New Guinean Kin1.00\",\n        \"Paraguayan Guaran1.00\",\n        \"Peruvian Int1.00\",\n        \"Peruvian Sol (1863\\\\u201319651.00\",\n        \"Peruvian Sol Nuev1.00\",\n        \"Philippine Pes1.00\",\n        \"Platinu1.00\",\n        \"Polish Zlot1.00\",\n        \"Polish Zloty (1950\\\\u201319951.00\",\n        \"Portuguese Escud1.00\",\n        \"Portuguese Guinea Escud1.00\",\n        \"Pr1.00\",\n        \"QA1.00\",\n        \"Qatari Ria1.00\",\n        \"RD1.00\",\n        \"RH1.00\",\n        \"RINET Fund1.00\",\n        \"RS1.00\",\n        \"RU1.00\",\n        \"RW1.00\",\n        \"Rb1.00\",\n        \"Rhodesian Dolla1.00\",\n        \"Romanian Le1.00\",\n        \"Russian Rubl1.00\",\n        \"Russian Ruble (1991\\\\u201319981.00\",\n        \"Rwandan Fran1.00\",\n        \"S1.00\",\n        \"SA1.00\",\n        \"SB1.00\",\n        \"SC1.00\",\n        \"SD1.00\",\n        \"SE1.00\",\n        \"SG1.00\",\n        \"SH1.00\",\n        \"SI1.00\",\n        \"SK1.00\",\n        \"SL R1.00\",\n        \"SL1.00\",\n        \"SO1.00\",\n        \"ST1.00\",\n        \"SU1.00\",\n        \"SV1.00\",\n        \"SY1.00\",\n        \"SZ1.00\",\n        \"St. Helena Poun1.00\",\n        \"S\\\\u00e3o Tom\\\\u00e9 & Pr\\\\u00edncipe Dobr1.00\",\n        \"Saudi Riya1.00\",\n        \"Serbian Dina1.00\",\n        \"Seychellois Rupe1.00\",\n        \"Sh1.00\",\n        \"Sierra Leonean Leon1.00\",\n        \"Silve1.00\",\n        \"Singapore Dolla1.00\",\n        \"Slovak Korun1.00\",\n        \"Slovenian Tola1.00\",\n        \"Solomon Islands Dolla1.00\",\n        \"Somali Shillin1.00\",\n        \"South African Ran1.00\",\n        \"South African Rand (financial1.00\",\n        \"South Korean Wo1.00\",\n        \"Soviet Roubl1.00\",\n        \"Spanish Peset1.00\",\n        \"Spanish Peseta (A account1.00\",\n        \"Spanish Peseta (convertible account1.00\",\n        \"Special Drawing Right1.00\",\n        \"Sri Lankan Rupe1.00\",\n        \"Sudanese Poun1.00\",\n        \"Surinamese Dolla1.00\",\n        \"Surinamese Guilde1.00\",\n        \"Swazi Lilangen1.00\",\n        \"Swedish Kron1.00\",\n        \"Swiss Fran1.00\",\n        \"Syrian Poun1.00\",\n        \"T S1.00\",\n        \"TH1.00\",\n        \"TJ1.00\",\n        \"TM1.00\",\n        \"TN1.00\",\n        \"TO1.00\",\n        \"TP1.00\",\n        \"TR1.00\",\n        \"TT1.00\",\n        \"TW1.00\",\n        \"TZ1.00\",\n        \"New Taiwan Dolla1.00\",\n        \"Tajikistani Rubl1.00\",\n        \"Tajikistani Somon1.00\",\n        \"Tanzanian Shillin1.00\",\n        \"Testing Currency Cod1.00\",\n        \"Thai Bah1.00\",\n        \"Timorese Escud1.00\",\n        \"Tongan Pa\\\\u20bbang1.00\",\n        \"Trinidad & Tobago Dolla1.00\",\n        \"Tunisian Dina1.00\",\n        \"Turkish Lir1.00\",\n        \"Turkmenistani Mana1.00\",\n        \"U S1.00\",\n        \"U1.00\",\n        \"UA1.00\",\n        \"UG1.00\",\n        \"US Dolla1.00\",\n        \"US Dollar (Next day1.00\",\n        \"US Dollar (Same day1.00\",\n        \"US1.00\",\n        \"UY1.00\",\n        \"UZ1.00\",\n        \"Ugandan Shillin1.00\",\n        \"Ugandan Shilling (1966\\\\u201319871.00\",\n        \"Ukrainian Hryvni1.00\",\n        \"Ukrainian Karbovanet1.00\",\n        \"Colombian Real Value Uni1.00\",\n        \"United Arab Emirates Dirha1.00\",\n        \"Unknown Currenc1.00\",\n        \"Ur1.00\",\n        \"Uruguay Peso (1975\\\\u201319931.00\",\n        \"Uruguay Peso Uruguay1.00\",\n        \"Uruguay Peso (Indexed Units1.00\",\n        \"Uzbekistani So1.00\",\n        \"V1.00\",\n        \"VE1.00\",\n        \"VN1.00\",\n        \"VU1.00\",\n        \"Vanuatu Vat1.00\",\n        \"Venezuelan Bol\\\\u00edva1.00\",\n        \"Venezuelan Bol\\\\u00edvar Fuert1.00\",\n        \"Vietnamese Don1.00\",\n        \"West African CFA Fran1.00\",\n        \"Central African CFA Fran1.00\",\n        \"WIR Eur1.00\",\n        \"WIR Fran1.00\",\n        \"WS1.00\",\n        \"Samoa Tal1.00\",\n        \"XA1.00\",\n        \"XB1.00\",\n        \"XC1.00\",\n        \"XD1.00\",\n        \"XE1.00\",\n        \"XF1.00\",\n        \"XO1.00\",\n        \"XP1.00\",\n        \"XR1.00\",\n        \"XT1.00\",\n        \"XX1.00\",\n        \"YD1.00\",\n        \"YE1.00\",\n        \"YU1.00\",\n        \"Yemeni Dina1.00\",\n        \"Yemeni Ria1.00\",\n        \"Yugoslavian Convertible Dina1.00\",\n        \"Yugoslavian Hard Dinar (1966\\\\u201319901.00\",\n        \"Yugoslavian New Dina1.00\",\n        \"Z1.00\",\n        \"ZA1.00\",\n        \"ZM1.00\",\n        \"ZR1.00\",\n        \"ZW1.00\",\n        \"Zairean New Zaire (1993\\\\u201319981.00\",\n        \"Zairean Zair1.00\",\n        \"Zambian Kwach1.00\",\n        \"Zimbabwean Dollar (1980\\\\u201320081.00\",\n        \"dra1.00\",\n        \"lar1.00\",\n        \"le1.00\",\n        \"man1.00\",\n        \"so1.00\",\n    };\n\n    Locale locale(\"en_US\");\n    for (uint32_t i=0; i<UPRV_LENGTHOF(DATA); ++i) {\n        UnicodeString formatted = ctou(DATA[i]);\n        UErrorCode status = U_ZERO_ERROR;\n        LocalPointer<NumberFormat> numFmt(NumberFormat::createInstance(locale, UNUM_CURRENCY, status), status);\n        if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) {\n            return;\n        }\n        // NOTE: ICU 62 requires that the currency format match the pattern in strict mode.\n        numFmt->setLenient(TRUE);\n        ParsePosition parsePos;\n        LocalPointer<CurrencyAmount> currAmt(numFmt->parseCurrency(formatted, parsePos));\n        if (parsePos.getIndex() > 0) {\n            double doubleVal = currAmt->getNumber().getDouble(status);\n            if ( doubleVal != 1.0 ) {\n                errln(\"Parsed as currency value other than 1.0: \" + formatted + \" -> \" + doubleVal);\n            }\n        } else {\n            errln(\"Failed to parse as currency: \" + formatted);\n        }\n    }\n\n    for (uint32_t i=0; i<UPRV_LENGTHOF(WRONG_DATA); ++i) {\n      UnicodeString formatted = ctou(WRONG_DATA[i]);\n      UErrorCode status = U_ZERO_ERROR;\n      NumberFormat* numFmt = NumberFormat::createInstance(locale, UNUM_CURRENCY, status);\n      if (numFmt != NULL && U_SUCCESS(status)) {\n          ParsePosition parsePos;\n          LocalPointer<CurrencyAmount> currAmt(numFmt->parseCurrency(formatted, parsePos));\n          if (parsePos.getIndex() > 0) {\n              double doubleVal = currAmt->getNumber().getDouble(status);\n              errln(\"Parsed as currency, should not have: \" + formatted + \" -> \" + doubleVal);\n          }\n      } else {\n          dataerrln(\"Unable to create NumberFormat. - %s\", u_errorName(status));\n          delete numFmt;\n          break;\n      }\n      delete numFmt;\n    }\n}\n\nconst char* attrString(int32_t);\n\n// UnicodeString s;\n//  std::string ss;\n//  std::cout << s.toUTF8String(ss)\nvoid NumberFormatTest::expectPositions(FieldPositionIterator& iter, int32_t *values, int32_t tupleCount,\n                                       const UnicodeString& str)  {\n  UBool found[10];\n  FieldPosition fp;\n\n  if (tupleCount > 10) {\n    assertTrue(\"internal error, tupleCount too large\", FALSE);\n  } else {\n    for (int i = 0; i < tupleCount; ++i) {\n      found[i] = FALSE;\n    }\n  }\n\n  logln(str);\n  while (iter.next(fp)) {\n    UBool ok = FALSE;\n    int32_t id = fp.getField();\n    int32_t start = fp.getBeginIndex();\n    int32_t limit = fp.getEndIndex();\n\n    // is there a logln using printf?\n    char buf[128];\n    sprintf(buf, \"%24s %3d %3d %3d\", attrString(id), id, start, limit);\n    logln(buf);\n\n    for (int i = 0; i < tupleCount; ++i) {\n      if (found[i]) {\n        continue;\n      }\n      if (values[i*3] == id &&\n          values[i*3+1] == start &&\n          values[i*3+2] == limit) {\n        found[i] = ok = TRUE;\n        break;\n      }\n    }\n\n    assertTrue((UnicodeString)\"found [\" + id + \",\" + start + \",\" + limit + \"]\", ok);\n  }\n\n  // check that all were found\n  UBool ok = TRUE;\n  for (int i = 0; i < tupleCount; ++i) {\n    if (!found[i]) {\n      ok = FALSE;\n      assertTrue((UnicodeString) \"missing [\" + values[i*3] + \",\" + values[i*3+1] + \",\" + values[i*3+2] + \"]\", found[i]);\n    }\n  }\n  assertTrue(\"no expected values were missing\", ok);\n}\n\nvoid NumberFormatTest::expectPosition(FieldPosition& pos, int32_t id, int32_t start, int32_t limit,\n                                       const UnicodeString& str)  {\n  logln(str);\n  assertTrue((UnicodeString)\"id \" + id + \" == \" + pos.getField(), id == pos.getField());\n  assertTrue((UnicodeString)\"begin \" + start + \" == \" + pos.getBeginIndex(), start == pos.getBeginIndex());\n  assertTrue((UnicodeString)\"end \" + limit + \" == \" + pos.getEndIndex(), limit == pos.getEndIndex());\n}\n\nvoid NumberFormatTest::TestFieldPositionIterator() {\n  // bug 7372\n  UErrorCode status = U_ZERO_ERROR;\n  FieldPositionIterator iter1;\n  FieldPositionIterator iter2;\n  FieldPosition pos;\n\n  DecimalFormat *decFmt = (DecimalFormat *) NumberFormat::createInstance(status);\n  if (failure(status, \"NumberFormat::createInstance\", TRUE)) return;\n\n  double num = 1234.56;\n  UnicodeString str1;\n  UnicodeString str2;\n\n  assertTrue((UnicodeString)\"self==\", iter1 == iter1);\n  assertTrue((UnicodeString)\"iter1==iter2\", iter1 == iter2);\n\n  decFmt->format(num, str1, &iter1, status);\n  assertTrue((UnicodeString)\"iter1 != iter2\", iter1 != iter2);\n  decFmt->format(num, str2, &iter2, status);\n  assertTrue((UnicodeString)\"iter1 == iter2 (2)\", iter1 == iter2);\n  iter1.next(pos);\n  assertTrue((UnicodeString)\"iter1 != iter2 (2)\", iter1 != iter2);\n  iter2.next(pos);\n  assertTrue((UnicodeString)\"iter1 == iter2 (3)\", iter1 == iter2);\n\n  // should format ok with no iterator\n  str2.remove();\n  decFmt->format(num, str2, NULL, status);\n  assertEquals(\"null fpiter\", str1, str2);\n\n  delete decFmt;\n}\n\nvoid NumberFormatTest::TestFormatAttributes() {\n  Locale locale(\"en_US\");\n  UErrorCode status = U_ZERO_ERROR;\n  DecimalFormat *decFmt = (DecimalFormat *) NumberFormat::createInstance(locale, UNUM_CURRENCY, status);\n    if (failure(status, \"NumberFormat::createInstance\", TRUE)) return;\n  double val = 12345.67;\n\n  {\n    int32_t expected[] = {\n      UNUM_CURRENCY_FIELD, 0, 1,\n      UNUM_GROUPING_SEPARATOR_FIELD, 3, 4,\n      UNUM_INTEGER_FIELD, 1, 7,\n      UNUM_DECIMAL_SEPARATOR_FIELD, 7, 8,\n      UNUM_FRACTION_FIELD, 8, 10,\n    };\n    int32_t tupleCount = UPRV_LENGTHOF(expected)/3;\n\n    FieldPositionIterator posIter;\n    UnicodeString result;\n    decFmt->format(val, result, &posIter, status);\n    expectPositions(posIter, expected, tupleCount, result);\n  }\n  {\n    FieldPosition fp(UNUM_INTEGER_FIELD);\n    UnicodeString result;\n    decFmt->format(val, result, fp);\n    expectPosition(fp, UNUM_INTEGER_FIELD, 1, 7, result);\n  }\n  {\n    FieldPosition fp(UNUM_FRACTION_FIELD);\n    UnicodeString result;\n    decFmt->format(val, result, fp);\n    expectPosition(fp, UNUM_FRACTION_FIELD, 8, 10, result);\n  }\n  delete decFmt;\n\n  decFmt = (DecimalFormat *) NumberFormat::createInstance(locale, UNUM_SCIENTIFIC, status);\n  val = -0.0000123;\n  {\n    int32_t expected[] = {\n      UNUM_SIGN_FIELD, 0, 1,\n      UNUM_INTEGER_FIELD, 1, 2,\n      UNUM_DECIMAL_SEPARATOR_FIELD, 2, 3,\n      UNUM_FRACTION_FIELD, 3, 5,\n      UNUM_EXPONENT_SYMBOL_FIELD, 5, 6,\n      UNUM_EXPONENT_SIGN_FIELD, 6, 7,\n      UNUM_EXPONENT_FIELD, 7, 8\n    };\n    int32_t tupleCount = UPRV_LENGTHOF(expected)/3;\n\n    FieldPositionIterator posIter;\n    UnicodeString result;\n    decFmt->format(val, result, &posIter, status);\n    expectPositions(posIter, expected, tupleCount, result);\n  }\n  {\n    FieldPosition fp(UNUM_INTEGER_FIELD);\n    UnicodeString result;\n    decFmt->format(val, result, fp);\n    expectPosition(fp, UNUM_INTEGER_FIELD, 1, 2, result);\n  }\n  {\n    FieldPosition fp(UNUM_FRACTION_FIELD);\n    UnicodeString result;\n    decFmt->format(val, result, fp);\n    expectPosition(fp, UNUM_FRACTION_FIELD, 3, 5, result);\n  }\n  delete decFmt;\n\n  fflush(stderr);\n}\n\nconst char* attrString(int32_t attrId) {\n  switch (attrId) {\n    case UNUM_INTEGER_FIELD: return \"integer\";\n    case UNUM_FRACTION_FIELD: return \"fraction\";\n    case UNUM_DECIMAL_SEPARATOR_FIELD: return \"decimal separator\";\n    case UNUM_EXPONENT_SYMBOL_FIELD: return \"exponent symbol\";\n    case UNUM_EXPONENT_SIGN_FIELD: return \"exponent sign\";\n    case UNUM_EXPONENT_FIELD: return \"exponent\";\n    case UNUM_GROUPING_SEPARATOR_FIELD: return \"grouping separator\";\n    case UNUM_CURRENCY_FIELD: return \"currency\";\n    case UNUM_PERCENT_FIELD: return \"percent\";\n    case UNUM_PERMILL_FIELD: return \"permille\";\n    case UNUM_SIGN_FIELD: return \"sign\";\n    default: return \"\";\n  }\n}\n\n//\n//   Test formatting & parsing of big decimals.\n//      API test, not a comprehensive test.\n//      See DecimalFormatTest/DataDrivenTests\n//\n#define ASSERT_SUCCESS(status) { \\\n    assertSuccess(UnicodeString(\"file \") + __FILE__ + \", line \" + __LINE__, (status)); \\\n}\n#define ASSERT_EQUALS(expected, actual) { \\\n    assertEquals(UnicodeString(\"file \") + __FILE__ + \", line \" + __LINE__, (expected), (actual)); \\\n}\n\nvoid NumberFormatTest::TestDecimal() {\n    {\n        UErrorCode  status = U_ZERO_ERROR;\n        Formattable f(\"12.345678999987654321E666\", status);\n        ASSERT_SUCCESS(status);\n        StringPiece s = f.getDecimalNumber(status);\n        ASSERT_SUCCESS(status);\n        ASSERT_EQUALS(\"1.2345678999987654321E+667\", s.data());\n        //printf(\"%s\\n\", s.data());\n    }\n\n    {\n        UErrorCode status = U_ZERO_ERROR;\n        Formattable f1(\"this is not a number\", status);\n        ASSERT_EQUALS(U_DECIMAL_NUMBER_SYNTAX_ERROR, status);\n    }\n\n    {\n        UErrorCode status = U_ZERO_ERROR;\n        Formattable f;\n        f.setDecimalNumber(\"123.45\", status);\n        ASSERT_SUCCESS(status);\n        ASSERT_EQUALS( Formattable::kDouble, f.getType());\n        ASSERT_EQUALS(123.45, f.getDouble());\n        ASSERT_EQUALS(123.45, f.getDouble(status));\n        ASSERT_SUCCESS(status);\n        ASSERT_EQUALS(\"123.45\", f.getDecimalNumber(status).data());\n        ASSERT_SUCCESS(status);\n\n        f.setDecimalNumber(\"4.5678E7\", status);\n        int32_t n;\n        n = f.getLong();\n        ASSERT_EQUALS(45678000, n);\n\n        status = U_ZERO_ERROR;\n        f.setDecimalNumber(\"-123\", status);\n        ASSERT_SUCCESS(status);\n        ASSERT_EQUALS( Formattable::kLong, f.getType());\n        ASSERT_EQUALS(-123, f.getLong());\n        ASSERT_EQUALS(-123, f.getLong(status));\n        ASSERT_SUCCESS(status);\n        ASSERT_EQUALS(\"-123\", f.getDecimalNumber(status).data());\n        ASSERT_SUCCESS(status);\n\n        status = U_ZERO_ERROR;\n        f.setDecimalNumber(\"1234567890123\", status);  // Number too big for 32 bits\n        ASSERT_SUCCESS(status);\n        ASSERT_EQUALS( Formattable::kInt64, f.getType());\n        ASSERT_EQUALS(1234567890123LL, f.getInt64());\n        ASSERT_EQUALS(1234567890123LL, f.getInt64(status));\n        ASSERT_SUCCESS(status);\n        ASSERT_EQUALS(\"1.234567890123E+12\", f.getDecimalNumber(status).data());\n        ASSERT_SUCCESS(status);\n    }\n\n    {\n        UErrorCode status = U_ZERO_ERROR;\n        NumberFormat *fmtr = NumberFormat::createInstance(Locale::getUS(), UNUM_DECIMAL, status);\n        if (U_FAILURE(status) || fmtr == NULL) {\n            dataerrln(\"Unable to create NumberFormat\");\n        } else {\n            UnicodeString formattedResult;\n            StringPiece num(\"244444444444444444444444444444444444446.4\");\n            fmtr->format(num, formattedResult, NULL, status);\n            ASSERT_SUCCESS(status);\n            ASSERT_EQUALS(\"244,444,444,444,444,444,444,444,444,444,444,444,446.4\", formattedResult);\n            //std::string ss; std::cout << formattedResult.toUTF8String(ss);\n            delete fmtr;\n        }\n    }\n\n    {\n        // Check formatting a DigitList.  DigitList is internal, but this is\n        // a critical interface that must work.\n        UErrorCode status = U_ZERO_ERROR;\n        NumberFormat *fmtr = NumberFormat::createInstance(Locale::getUS(), UNUM_DECIMAL, status);\n        if (U_FAILURE(status) || fmtr == NULL) {\n            dataerrln(\"Unable to create NumberFormat\");\n        } else {\n            UnicodeString formattedResult;\n            DecimalQuantity dl;\n            StringPiece num(\"123.4566666666666666666666666666666666621E+40\");\n            dl.setToDecNumber(num, status);\n            ASSERT_SUCCESS(status);\n            fmtr->format(dl, formattedResult, NULL, status);\n            ASSERT_SUCCESS(status);\n            ASSERT_EQUALS(\"1,234,566,666,666,666,666,666,666,666,666,666,666,621,000\", formattedResult);\n\n            status = U_ZERO_ERROR;\n            num.set(\"666.666\");\n            dl.setToDecNumber(num, status);\n            FieldPosition pos(NumberFormat::FRACTION_FIELD);\n            ASSERT_SUCCESS(status);\n            formattedResult.remove();\n            fmtr->format(dl, formattedResult, pos, status);\n            ASSERT_SUCCESS(status);\n            ASSERT_EQUALS(\"666.666\", formattedResult);\n            ASSERT_EQUALS(4, pos.getBeginIndex());\n            ASSERT_EQUALS(7, pos.getEndIndex());\n            delete fmtr;\n        }\n    }\n\n    {\n        // Check a parse with a formatter with a multiplier.\n        UErrorCode status = U_ZERO_ERROR;\n        NumberFormat *fmtr = NumberFormat::createInstance(Locale::getUS(), UNUM_PERCENT, status);\n        if (U_FAILURE(status) || fmtr == NULL) {\n            dataerrln(\"Unable to create NumberFormat\");\n        } else {\n            UnicodeString input = \"1.84%\";\n            Formattable result;\n            fmtr->parse(input, result, status);\n            ASSERT_SUCCESS(status);\n            ASSERT_EQUALS(\"0.0184\", result.getDecimalNumber(status).data());\n            //std::cout << result.getDecimalNumber(status).data();\n            delete fmtr;\n        }\n    }\n\n#if U_PLATFORM != U_PF_CYGWIN || defined(CYGWINMSVC)\n    /*\n     * This test fails on Cygwin (1.7.16) using GCC because of a rounding issue with strtod().\n     * See #9463\n     */\n    {\n        // Check that a parse returns a decimal number with full accuracy\n        UErrorCode status = U_ZERO_ERROR;\n        NumberFormat *fmtr = NumberFormat::createInstance(Locale::getUS(), UNUM_DECIMAL, status);\n        if (U_FAILURE(status) || fmtr == NULL) {\n            dataerrln(\"Unable to create NumberFormat\");\n        } else {\n            UnicodeString input = \"1.002200044400088880000070000\";\n            Formattable result;\n            fmtr->parse(input, result, status);\n            ASSERT_SUCCESS(status);\n            ASSERT_EQUALS(0, strcmp(\"1.00220004440008888000007\", result.getDecimalNumber(status).data()));\n            ASSERT_EQUALS(1.00220004440008888,   result.getDouble());\n            //std::cout << result.getDecimalNumber(status).data();\n            delete fmtr;\n        }\n    }\n#endif\n\n}\n\nvoid NumberFormatTest::TestCurrencyFractionDigits() {\n    UErrorCode status = U_ZERO_ERROR;\n    UnicodeString text1, text2;\n    double value = 99.12345;\n\n    // Create currenct instance\n    NumberFormat* fmt = NumberFormat::createCurrencyInstance(\"ja_JP\", status);\n    if (U_FAILURE(status) || fmt == NULL) {\n        dataerrln(\"Unable to create NumberFormat\");\n    } else {\n        fmt->format(value, text1);\n\n        // Reset the same currency and format the test value again\n        fmt->setCurrency(fmt->getCurrency(), status);\n        ASSERT_SUCCESS(status);\n        fmt->format(value, text2);\n\n        if (text1 != text2) {\n            errln((UnicodeString)\"NumberFormat::format() should return the same result - text1=\"\n                + text1 + \" text2=\" + text2);\n        }\n    }\n    delete fmt;\n}\n\nvoid NumberFormatTest::TestExponentParse() {\n\n    UErrorCode status = U_ZERO_ERROR;\n    Formattable result;\n    ParsePosition parsePos(0);\n\n    // set the exponent symbol\n    status = U_ZERO_ERROR;\n    DecimalFormatSymbols symbols(Locale::getDefault(), status);\n    if(U_FAILURE(status)) {\n        dataerrln((UnicodeString)\"ERROR: Could not create DecimalFormatSymbols (Default)\");\n        return;\n    }\n\n    // create format instance\n    status = U_ZERO_ERROR;\n    DecimalFormat fmt(u\"#####\", symbols, status);\n    if(U_FAILURE(status)) {\n        errln((UnicodeString)\"ERROR: Could not create DecimalFormat (pattern, symbols*)\");\n    }\n\n    // parse the text\n    fmt.parse(\"5.06e-27\", result, parsePos);\n    if(result.getType() != Formattable::kDouble &&\n       result.getDouble() != 5.06E-27 &&\n       parsePos.getIndex() != 8\n       )\n    {\n        errln(\"ERROR: parse failed - expected 5.06E-27, 8  - returned %d, %i\",\n              result.getDouble(), parsePos.getIndex());\n    }\n}\n\nvoid NumberFormatTest::TestExplicitParents() {\n\n    /* Test that number formats are properly inherited from es_419 */\n    /* These could be subject to change if the CLDR data changes */\n    static const char* parentLocaleTests[][2]= {\n    /* locale ID */  /* expected */\n    {\"es_CO\", \"1.250,75\" },\n    {\"es_ES\", \"1.250,75\" },\n    {\"es_GQ\", \"1.250,75\" },\n    {\"es_MX\", \"1,250.75\" },\n    {\"es_US\", \"1,250.75\" },\n    {\"es_VE\", \"1.250,75\" },\n    };\n\n    UnicodeString s;\n\n    for(int i=0; i < UPRV_LENGTHOF(parentLocaleTests); i++){\n        UErrorCode status = U_ZERO_ERROR;\n        const char *localeID = parentLocaleTests[i][0];\n        UnicodeString expected(parentLocaleTests[i][1], -1, US_INV);\n        expected = expected.unescape();\n        char loc[256]={0};\n        uloc_canonicalize(localeID, loc, 256, &status);\n        NumberFormat *fmt= NumberFormat::createInstance(Locale(loc), status);\n        if(U_FAILURE(status)){\n            dataerrln(\"Could not create number formatter for locale %s - %s\",localeID, u_errorName(status));\n            continue;\n        }\n        s.remove();\n        fmt->format(1250.75, s);\n        if(s!=expected){\n            errln(UnicodeString(\"FAIL: Expected: \")+expected\n                    + UnicodeString(\" Got: \") + s\n                    + UnicodeString( \" for locale: \")+ UnicodeString(localeID) );\n        }\n        if (U_FAILURE(status)){\n            errln((UnicodeString)\"FAIL: Status \" + (int32_t)status);\n        }\n        delete fmt;\n    }\n\n}\n\n/**\n * Test available numbering systems API.\n */\nvoid NumberFormatTest::TestAvailableNumberingSystems() {\n    UErrorCode status = U_ZERO_ERROR;\n    StringEnumeration *availableNumberingSystems = NumberingSystem::getAvailableNames(status);\n    CHECK_DATA(status, \"NumberingSystem::getAvailableNames()\")\n\n    int32_t nsCount = availableNumberingSystems->count(status);\n    if ( nsCount < 74 ) {\n        errln(\"FAIL: Didn't get as many numbering systems as we had hoped for. Need at least 74, got %d\",nsCount);\n    }\n\n    /* A relatively simple test of the API.  We call getAvailableNames() and cycle through */\n    /* each name returned, attempting to create a numbering system based on that name and  */\n    /* verifying that the name returned from the resulting numbering system is the same    */\n    /* one that we initially thought.                                                      */\n\n    int32_t len;\n    for ( int32_t i = 0 ; i < nsCount ; i++ ) {\n        const char *nsname = availableNumberingSystems->next(&len,status);\n        NumberingSystem* ns = NumberingSystem::createInstanceByName(nsname,status);\n        logln(\"OK for ns = %s\",nsname);\n        if ( uprv_strcmp(nsname,ns->getName()) ) {\n            errln(\"FAIL: Numbering system name didn't match for name = %s\\n\",nsname);\n        }\n\n        delete ns;\n    }\n\n    delete availableNumberingSystems;\n}\n\nvoid\nNumberFormatTest::Test9087(void)\n{\n    U_STRING_DECL(pattern,\"#\",1);\n    U_STRING_INIT(pattern,\"#\",1);\n\n    U_STRING_DECL(infstr,\"INF\",3);\n    U_STRING_INIT(infstr,\"INF\",3);\n\n    U_STRING_DECL(nanstr,\"NAN\",3);\n    U_STRING_INIT(nanstr,\"NAN\",3);\n\n    UChar outputbuf[50] = {0};\n    UErrorCode status = U_ZERO_ERROR;\n    UNumberFormat* fmt = unum_open(UNUM_PATTERN_DECIMAL,pattern,1,NULL,NULL,&status);\n    if ( U_FAILURE(status) ) {\n        dataerrln(\"FAIL: error in unum_open() - %s\", u_errorName(status));\n        return;\n    }\n\n    unum_setSymbol(fmt,UNUM_INFINITY_SYMBOL,infstr,3,&status);\n    unum_setSymbol(fmt,UNUM_NAN_SYMBOL,nanstr,3,&status);\n    if ( U_FAILURE(status) ) {\n        errln(\"FAIL: error setting symbols\");\n    }\n\n    double inf = uprv_getInfinity();\n\n    unum_setAttribute(fmt,UNUM_ROUNDING_MODE,UNUM_ROUND_HALFEVEN);\n    unum_setDoubleAttribute(fmt,UNUM_ROUNDING_INCREMENT,0);\n\n    UFieldPosition position = { 0, 0, 0};\n    unum_formatDouble(fmt,inf,outputbuf,50,&position,&status);\n\n    if ( u_strcmp(infstr, outputbuf)) {\n        errln((UnicodeString)\"FAIL: unexpected result for infinity - expected \" + infstr + \" got \" + outputbuf);\n    }\n\n    unum_close(fmt);\n}\n\nvoid NumberFormatTest::TestFormatFastpaths() {\n    // get some additional case\n    {\n        UErrorCode status=U_ZERO_ERROR;\n        DecimalFormat df(UnicodeString(u\"0000\"),status);\n        if (U_FAILURE(status)) {\n            dataerrln(\"Error creating DecimalFormat - %s\", u_errorName(status));\n        } else {\n            int64_t long_number = 1;\n            UnicodeString expect = \"0001\";\n            UnicodeString result;\n            FieldPosition pos;\n            df.format(long_number, result, pos);\n            if(U_FAILURE(status)||expect!=result) {\n                dataerrln(\"%s:%d FAIL: expected '%s' got '%s' status %s\",\n                          __FILE__, __LINE__, CStr(expect)(), CStr(result)(), u_errorName(status));\n             } else {\n                logln(\"OK:  got expected '\"+result+\"' status \"+UnicodeString(u_errorName(status),\"\"));\n            }\n        }\n    }\n    {\n        UErrorCode status=U_ZERO_ERROR;\n        DecimalFormat df(UnicodeString(u\"0000000000000000000\"),status);\n        if (U_FAILURE(status)) {\n            dataerrln(\"Error creating DecimalFormat - %s\", u_errorName(status));\n        } else {\n            int64_t long_number = U_INT64_MIN; // -9223372036854775808L;\n            // uint8_t bits[8];\n            // memcpy(bits,&long_number,8);\n            // for(int i=0;i<8;i++) {\n            //   logln(\"bits: %02X\", (unsigned int)bits[i]);\n            // }\n            UnicodeString expect = \"-9223372036854775808\";\n            UnicodeString result;\n            FieldPosition pos;\n            df.format(long_number, result, pos);\n            if(U_FAILURE(status)||expect!=result) {\n                dataerrln(\"%s:%d FAIL: expected '%s' got '%s' status %s on -9223372036854775808\",\n                          __FILE__, __LINE__, CStr(expect)(), CStr(result)(), u_errorName(status));\n            } else {\n                logln(\"OK:  got expected '\"+result+\"' status \"+UnicodeString(u_errorName(status),\"\")+\" on -9223372036854775808\");\n            }\n        }\n    }\n    {\n        UErrorCode status=U_ZERO_ERROR;\n        DecimalFormat df(UnicodeString(u\"0000000000000000000\"),status);\n        if (U_FAILURE(status)) {\n            dataerrln(\"Error creating DecimalFormat - %s\", u_errorName(status));\n        } else {\n            int64_t long_number = U_INT64_MAX; // -9223372036854775808L;\n            // uint8_t bits[8];\n            // memcpy(bits,&long_number,8);\n            // for(int i=0;i<8;i++) {\n            //   logln(\"bits: %02X\", (unsigned int)bits[i]);\n            // }\n            UnicodeString expect = \"9223372036854775807\";\n            UnicodeString result;\n            FieldPosition pos;\n            df.format(long_number, result, pos);\n            if(U_FAILURE(status)||expect!=result) {\n                dataerrln(\"%s:%d FAIL: expected '%s' got '%s' status %s on U_INT64_MAX\",\n                          __FILE__, __LINE__, CStr(expect)(), CStr(result)(), u_errorName(status));\n            } else {\n                logln(\"OK:  got expected '\"+result+\"' status \"+UnicodeString(u_errorName(status),\"\")+\" on U_INT64_MAX\");\n            }\n        }\n    }\n    {\n        UErrorCode status=U_ZERO_ERROR;\n        DecimalFormat df(UnicodeString(\"0000000000000000000\",\"\"),status);\n        if (U_FAILURE(status)) {\n            dataerrln(\"Error creating DecimalFormat - %s\", u_errorName(status));\n        } else {\n            int64_t long_number = 0;\n            // uint8_t bits[8];\n            // memcpy(bits,&long_number,8);\n            // for(int i=0;i<8;i++) {\n            //   logln(\"bits: %02X\", (unsigned int)bits[i]);\n            // }\n            UnicodeString expect = \"0000000000000000000\";\n            UnicodeString result;\n            FieldPosition pos;\n            df.format(long_number, result, pos);\n            if(U_FAILURE(status)||expect!=result) {\n                dataerrln(\"%s:%d FAIL: expected '%s' got '%s' status %s on 0\",\n                          __FILE__, __LINE__, CStr(expect)(), CStr(result)(), u_errorName(status));\n            } else {\n                logln(\"OK:  got expected '\"+result+\"' status \"+UnicodeString(u_errorName(status),\"\")+\" on 0\");\n            }\n        }\n    }\n    {\n        UErrorCode status=U_ZERO_ERROR;\n        DecimalFormat df(UnicodeString(\"0000000000000000000\",\"\"),status);\n        if (U_FAILURE(status)) {\n            dataerrln(\"Error creating DecimalFormat - %s\", u_errorName(status));\n        } else {\n            int64_t long_number = U_INT64_MIN + 1;\n            UnicodeString expect = \"-9223372036854775807\";\n            UnicodeString result;\n            FieldPosition pos;\n            df.format(long_number, result, pos);\n            if(U_FAILURE(status)||expect!=result) {\n                dataerrln(\"%s:%d FAIL: expected '%s' got '%s' status %s on -9223372036854775807\",\n                          __FILE__, __LINE__, CStr(expect)(), CStr(result)(), u_errorName(status));\n            } else {\n                logln(\"OK:  got expected '\"+result+\"' status \"+UnicodeString(u_errorName(status),\"\")+\" on -9223372036854775807\");\n            }\n        }\n    }\n}\n\n\nvoid NumberFormatTest::TestFormattableSize(void) {\n  if(sizeof(Formattable) > 112) {\n    errln(\"Error: sizeof(Formattable)=%d, 112=%d\\n\",\n          sizeof(Formattable), 112);\n  } else if(sizeof(Formattable) < 112) {\n    logln(\"Warning: sizeof(Formattable)=%d, 112=%d\\n\",\n        sizeof(Formattable), 112);\n  } else {\n    logln(\"sizeof(Formattable)=%d, 112=%d\\n\",\n        sizeof(Formattable), 112);\n  }\n}\n\nUBool NumberFormatTest::testFormattableAsUFormattable(const char *file, int line, Formattable &f) {\n  UnicodeString fileLine = UnicodeString(file)+UnicodeString(\":\")+line+UnicodeString(\": \");\n\n  UFormattable *u = f.toUFormattable();\n  logln();\n  if (u == NULL) {\n    errln(\"%s:%d: Error: f.toUFormattable() retuned NULL.\");\n    return FALSE;\n  }\n  logln(\"%s:%d: comparing Formattable with UFormattable\", file, line);\n  logln(fileLine + toString(f));\n\n  UErrorCode status = U_ZERO_ERROR;\n  UErrorCode valueStatus = U_ZERO_ERROR;\n  UFormattableType expectUType = UFMT_COUNT; // invalid\n\n  UBool triedExact = FALSE; // did we attempt an exact comparison?\n  UBool exactMatch = FALSE; // was the exact comparison true?\n\n  switch( f.getType() ) {\n  case Formattable::kDate:\n    expectUType = UFMT_DATE;\n    exactMatch = (f.getDate()==ufmt_getDate(u, &valueStatus));\n    triedExact = TRUE;\n    break;\n  case Formattable::kDouble:\n    expectUType = UFMT_DOUBLE;\n    exactMatch = (f.getDouble()==ufmt_getDouble(u, &valueStatus));\n    triedExact = TRUE;\n    break;\n  case Formattable::kLong:\n    expectUType = UFMT_LONG;\n    exactMatch = (f.getLong()==ufmt_getLong(u, &valueStatus));\n    triedExact = TRUE;\n    break;\n  case Formattable::kString:\n    expectUType = UFMT_STRING;\n    {\n      UnicodeString str;\n      f.getString(str);\n      int32_t len;\n      const UChar* uch = ufmt_getUChars(u, &len, &valueStatus);\n      if(U_SUCCESS(valueStatus)) {\n        UnicodeString str2(uch, len);\n        assertTrue(\"UChar* NULL-terminated\", uch[len]==0);\n        exactMatch = (str == str2);\n      }\n      triedExact = TRUE;\n    }\n    break;\n  case Formattable::kArray:\n    expectUType = UFMT_ARRAY;\n    triedExact = TRUE;\n    {\n      int32_t count = ufmt_getArrayLength(u, &valueStatus);\n      int32_t count2;\n      const Formattable *array2 = f.getArray(count2);\n      exactMatch = assertEquals(fileLine + \" array count\", count, count2);\n\n      if(exactMatch) {\n        for(int i=0;U_SUCCESS(valueStatus) && i<count;i++) {\n          UFormattable *uu = ufmt_getArrayItemByIndex(u, i, &valueStatus);\n          if(*Formattable::fromUFormattable(uu) != (array2[i])) {\n            errln(\"%s:%d: operator== did not match at index[%d] - %p vs %p\", file, line, i,\n                  (const void*)Formattable::fromUFormattable(uu), (const void*)&(array2[i]));\n            exactMatch = FALSE;\n          } else {\n            if(!testFormattableAsUFormattable(\"(sub item)\",i,*Formattable::fromUFormattable(uu))) {\n              exactMatch = FALSE;\n            }\n          }\n        }\n      }\n    }\n    break;\n  case Formattable::kInt64:\n    expectUType = UFMT_INT64;\n    exactMatch = (f.getInt64()==ufmt_getInt64(u, &valueStatus));\n    triedExact = TRUE;\n    break;\n  case Formattable::kObject:\n    expectUType = UFMT_OBJECT;\n    exactMatch = (f.getObject()==ufmt_getObject(u, &valueStatus));\n    triedExact = TRUE;\n    break;\n  }\n  UFormattableType uType = ufmt_getType(u, &status);\n\n  if(U_FAILURE(status)) {\n    errln(\"%s:%d: Error calling ufmt_getType - %s\", file, line, u_errorName(status));\n    return FALSE;\n  }\n\n  if(uType != expectUType) {\n    errln(\"%s:%d: got type (%d) expected (%d) from ufmt_getType\", file, line, (int) uType, (int) expectUType);\n  }\n\n  if(triedExact) {\n    if(U_FAILURE(valueStatus)) {\n      errln(\"%s:%d: got err %s trying to ufmt_get...() for exact match check\", file, line, u_errorName(valueStatus));\n    } else if(!exactMatch) {\n     errln(\"%s:%d: failed exact match for the Formattable type\", file, line);\n    } else {\n      logln(\"%s:%d: exact match OK\", file, line);\n    }\n  } else {\n    logln(\"%s:%d: note, did not attempt exact match for this formattable type\", file, line);\n  }\n\n  if( assertEquals(fileLine + \" isNumeric()\", f.isNumeric(), ufmt_isNumeric(u))\n      && f.isNumeric()) {\n    UErrorCode convStatus = U_ZERO_ERROR;\n\n    if(uType != UFMT_INT64) { // may fail to compare\n      assertTrue(fileLine + \" as doubles ==\", f.getDouble(convStatus)==ufmt_getDouble(u, &convStatus));\n    }\n\n    if( assertSuccess(fileLine + \" (numeric conversion status)\", convStatus) ) {\n      StringPiece fDecNum = f.getDecimalNumber(convStatus);\n#if 1\n      int32_t len;\n      const char *decNumChars = ufmt_getDecNumChars(u, &len, &convStatus);\n#else\n      // copy version\n      char decNumChars[200];\n      int32_t len = ufmt_getDecNumChars(u, decNumChars, 200, &convStatus);\n#endif\n\n      if( assertSuccess(fileLine + \" (decNumbers conversion)\", convStatus) ) {\n        logln(fileLine + decNumChars);\n        assertEquals(fileLine + \" decNumChars length==\", len, fDecNum.length());\n        assertEquals(fileLine + \" decNumChars digits\", decNumChars, fDecNum.data());\n      }\n\n      UErrorCode int64ConversionF = U_ZERO_ERROR;\n      int64_t l = f.getInt64(int64ConversionF);\n      UErrorCode int64ConversionU = U_ZERO_ERROR;\n      int64_t r = ufmt_getInt64(u, &int64ConversionU);\n\n      if( (l==r)\n          && ( uType != UFMT_INT64 ) // int64 better not overflow\n          && (U_INVALID_FORMAT_ERROR==int64ConversionU)\n          && (U_INVALID_FORMAT_ERROR==int64ConversionF) ) {\n        logln(\"%s:%d: OK: 64 bit overflow\", file, line);\n      } else {\n        assertEquals(fileLine + \" as int64 ==\", l, r);\n        assertSuccess(fileLine + \" Formattable.getnt64()\", int64ConversionF);\n        assertSuccess(fileLine + \" ufmt_getInt64()\", int64ConversionU);\n      }\n    }\n  }\n  return exactMatch || !triedExact;\n}\n\nvoid NumberFormatTest::TestUFormattable(void) {\n  {\n    // test that a default formattable is equal to Formattable()\n    UErrorCode status = U_ZERO_ERROR;\n    LocalUFormattablePointer defaultUFormattable(ufmt_open(&status));\n    assertSuccess(\"calling umt_open\", status);\n    Formattable defaultFormattable;\n    assertTrue((UnicodeString)\"comparing ufmt_open() with Formattable()\",\n               (defaultFormattable\n                == *(Formattable::fromUFormattable(defaultUFormattable.getAlias()))));\n    assertTrue((UnicodeString)\"comparing ufmt_open() with Formattable()\",\n               (defaultFormattable\n                == *(Formattable::fromUFormattable(defaultUFormattable.getAlias()))));\n    assertTrue((UnicodeString)\"comparing Formattable() round tripped through UFormattable\",\n               (defaultFormattable\n                == *(Formattable::fromUFormattable(defaultFormattable.toUFormattable()))));\n    assertTrue((UnicodeString)\"comparing &Formattable() round tripped through UFormattable\",\n               ((&defaultFormattable)\n                == Formattable::fromUFormattable(defaultFormattable.toUFormattable())));\n    assertFalse((UnicodeString)\"comparing &Formattable() with ufmt_open()\",\n               ((&defaultFormattable)\n                == Formattable::fromUFormattable(defaultUFormattable.getAlias())));\n    testFormattableAsUFormattable(__FILE__, __LINE__, defaultFormattable);\n  }\n  // test some random Formattables\n  {\n    Formattable f(ucal_getNow(), Formattable::kIsDate);\n    testFormattableAsUFormattable(__FILE__, __LINE__,  f);\n  }\n  {\n    Formattable f((double)1.61803398874989484820); // golden ratio\n    testFormattableAsUFormattable(__FILE__, __LINE__,  f);\n  }\n  {\n    Formattable f((int64_t)80994231587905127LL); // weight of the moon, in kilotons http://solarsystem.nasa.gov/planets/profile.cfm?Display=Facts&Object=Moon\n    testFormattableAsUFormattable(__FILE__, __LINE__,  f);\n  }\n  {\n    Formattable f((int32_t)4); // random number, source: http://www.xkcd.com/221/\n    testFormattableAsUFormattable(__FILE__, __LINE__,  f);\n  }\n  {\n    Formattable f(\"Hello world.\"); // should be invariant?\n    testFormattableAsUFormattable(__FILE__, __LINE__,  f);\n  }\n  {\n    UErrorCode status2 = U_ZERO_ERROR;\n    Formattable f(StringPiece(\"73476730924573500000000.0\"), status2); // weight of the moon, kg\n    assertSuccess(\"Constructing a StringPiece\", status2);\n    testFormattableAsUFormattable(__FILE__, __LINE__,  f);\n  }\n  {\n    UErrorCode status2 = U_ZERO_ERROR;\n    UObject *obj = new Locale();\n    Formattable f(obj);\n    assertSuccess(\"Constructing a Formattable from a default constructed Locale()\", status2);\n    testFormattableAsUFormattable(__FILE__, __LINE__,  f);\n  }\n  {\n    const Formattable array[] = {\n      Formattable(ucal_getNow(), Formattable::kIsDate),\n      Formattable((int32_t)4),\n      Formattable((double)1.234),\n    };\n\n    Formattable fa(array, 3);\n    testFormattableAsUFormattable(__FILE__, __LINE__, fa);\n  }\n}\n\nvoid NumberFormatTest::TestSignificantDigits(void) {\n  double input[] = {\n        0, 0,\n        0.1, -0.1,\n        123, -123,\n        12345, -12345,\n        123.45, -123.45,\n        123.44501, -123.44501,\n        0.001234, -0.001234,\n        0.00000000123, -0.00000000123,\n        0.0000000000000000000123, -0.0000000000000000000123,\n        1.2, -1.2,\n        0.0000000012344501, -0.0000000012344501,\n        123445.01, -123445.01,\n        12344501000000000000000000000000000.0, -12344501000000000000000000000000000.0,\n    };\n    const char* expected[] = {\n        \"0.00\", \"0.00\",\n        \"0.100\", \"-0.100\",\n        \"123\", \"-123\",\n        \"12345\", \"-12345\",\n        \"123.45\", \"-123.45\",\n        \"123.45\", \"-123.45\",\n        \"0.001234\", \"-0.001234\",\n        \"0.00000000123\", \"-0.00000000123\",\n        \"0.0000000000000000000123\", \"-0.0000000000000000000123\",\n        \"1.20\", \"-1.20\",\n        \"0.0000000012345\", \"-0.0000000012345\",\n        \"123450\", \"-123450\",\n        \"12345000000000000000000000000000000\", \"-12345000000000000000000000000000000\",\n    };\n\n    UErrorCode status = U_ZERO_ERROR;\n    Locale locale(\"en_US\");\n    LocalPointer<DecimalFormat> numberFormat(static_cast<DecimalFormat*>(\n            NumberFormat::createInstance(locale, status)));\n    CHECK_DATA(status,\"NumberFormat::createInstance\")\n\n    numberFormat->setSignificantDigitsUsed(TRUE);\n    numberFormat->setMinimumSignificantDigits(3);\n    numberFormat->setMaximumSignificantDigits(5);\n    numberFormat->setGroupingUsed(false);\n\n    UnicodeString result;\n    UnicodeString expectedResult;\n    for (unsigned int i = 0; i < UPRV_LENGTHOF(input); ++i) {\n        numberFormat->format(input[i], result);\n        UnicodeString expectedResult(expected[i]);\n        if (result != expectedResult) {\n          errln((UnicodeString)\"Expected: '\" + expectedResult + \"' got '\" + result);\n        }\n        result.remove();\n    }\n\n    // Test for ICU-20063\n    {\n        DecimalFormat df({\"en-us\", status}, status);\n        df.setSignificantDigitsUsed(TRUE);\n        expect(df, 9.87654321, u\"9.87654\");\n        df.setMaximumSignificantDigits(3);\n        expect(df, 9.87654321, u\"9.88\");\n        // setSignificantDigitsUsed with maxSig only\n        df.setSignificantDigitsUsed(TRUE);\n        expect(df, 9.87654321, u\"9.88\");\n        df.setMinimumSignificantDigits(2);\n        expect(df, 9, u\"9.0\");\n        // setSignificantDigitsUsed with both minSig and maxSig\n        df.setSignificantDigitsUsed(TRUE);\n        expect(df, 9, u\"9.0\");\n        // setSignificantDigitsUsed to false: should revert to fraction rounding\n        df.setSignificantDigitsUsed(FALSE);\n        expect(df, 9.87654321, u\"9.876543\");\n        expect(df, 9, u\"9\");\n        df.setSignificantDigitsUsed(TRUE);\n        df.setMinimumSignificantDigits(2);\n        expect(df, 9.87654321, u\"9.87654\");\n        expect(df, 9, u\"9.0\");\n        // setSignificantDigitsUsed with minSig only\n        df.setSignificantDigitsUsed(TRUE);\n        expect(df, 9.87654321, u\"9.87654\");\n        expect(df, 9, u\"9.0\");\n    }\n}\n\nvoid NumberFormatTest::TestShowZero() {\n    UErrorCode status = U_ZERO_ERROR;\n    Locale locale(\"en_US\");\n    LocalPointer<DecimalFormat> numberFormat(static_cast<DecimalFormat*>(\n            NumberFormat::createInstance(locale, status)));\n    CHECK_DATA(status, \"NumberFormat::createInstance\")\n\n    numberFormat->setSignificantDigitsUsed(TRUE);\n    numberFormat->setMaximumSignificantDigits(3);\n\n    UnicodeString result;\n    numberFormat->format(0.0, result);\n    if (result != \"0\") {\n        errln((UnicodeString)\"Expected: 0, got \" + result);\n    }\n}\n\nvoid NumberFormatTest::TestBug9936() {\n    UErrorCode status = U_ZERO_ERROR;\n    Locale locale(\"en_US\");\n    LocalPointer<DecimalFormat> numberFormat(static_cast<DecimalFormat*>(\n            NumberFormat::createInstance(locale, status)));\n    if (U_FAILURE(status)) {\n        dataerrln(\"File %s, Line %d: status = %s.\\n\", __FILE__, __LINE__, u_errorName(status));\n        return;\n    }\n\n    if (numberFormat->areSignificantDigitsUsed() == TRUE) {\n        errln(\"File %s, Line %d: areSignificantDigitsUsed() was TRUE, expected FALSE.\\n\", __FILE__, __LINE__);\n    }\n    numberFormat->setSignificantDigitsUsed(TRUE);\n    if (numberFormat->areSignificantDigitsUsed() == FALSE) {\n        errln(\"File %s, Line %d: areSignificantDigitsUsed() was FALSE, expected TRUE.\\n\", __FILE__, __LINE__);\n    }\n\n    numberFormat->setSignificantDigitsUsed(FALSE);\n    if (numberFormat->areSignificantDigitsUsed() == TRUE) {\n        errln(\"File %s, Line %d: areSignificantDigitsUsed() was TRUE, expected FALSE.\\n\", __FILE__, __LINE__);\n    }\n\n    numberFormat->setMinimumSignificantDigits(3);\n    if (numberFormat->areSignificantDigitsUsed() == FALSE) {\n        errln(\"File %s, Line %d: areSignificantDigitsUsed() was FALSE, expected TRUE.\\n\", __FILE__, __LINE__);\n    }\n\n    numberFormat->setSignificantDigitsUsed(FALSE);\n    numberFormat->setMaximumSignificantDigits(6);\n    if (numberFormat->areSignificantDigitsUsed() == FALSE) {\n        errln(\"File %s, Line %d: areSignificantDigitsUsed() was FALSE, expected TRUE.\\n\", __FILE__, __LINE__);\n    }\n\n}\n\nvoid NumberFormatTest::TestParseNegativeWithFaLocale() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat *test = (DecimalFormat *) NumberFormat::createInstance(\"fa\", status);\n    CHECK_DATA(status, \"NumberFormat::createInstance\")\n    test->setLenient(TRUE);\n    Formattable af;\n    ParsePosition ppos;\n    UnicodeString value(\"\\\\u200e-0,5\");\n    value = value.unescape();\n    test->parse(value, af, ppos);\n    if (ppos.getIndex() == 0) {\n        errln(\"Expected -0,5 to parse for Farsi.\");\n    }\n    delete test;\n}\n\nvoid NumberFormatTest::TestParseNegativeWithAlternateMinusSign() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat *test = (DecimalFormat *) NumberFormat::createInstance(\"en\", status);\n    CHECK_DATA(status, \"NumberFormat::createInstance\")\n    test->setLenient(TRUE);\n    Formattable af;\n    ParsePosition ppos;\n    UnicodeString value(\"\\\\u208B0.5\");\n    value = value.unescape();\n    test->parse(value, af, ppos);\n    if (ppos.getIndex() == 0) {\n        errln(UnicodeString(\"Expected \") + value + UnicodeString(\" to parse.\"));\n    }\n    delete test;\n}\n\nvoid NumberFormatTest::TestCustomCurrencySignAndSeparator() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols custom(Locale::getUS(), status);\n    CHECK(status, \"DecimalFormatSymbols constructor\");\n\n    custom.setSymbol(DecimalFormatSymbols::kCurrencySymbol, \"*\");\n    custom.setSymbol(DecimalFormatSymbols::kMonetaryGroupingSeparatorSymbol, \"^\");\n    custom.setSymbol(DecimalFormatSymbols::kMonetarySeparatorSymbol, \":\");\n\n    UnicodeString pat(\" #,##0.00\");\n    pat.insert(0, (UChar)0x00A4);\n\n    DecimalFormat fmt(pat, custom, status);\n    CHECK(status, \"DecimalFormat constructor\");\n\n    UnicodeString numstr(\"* 1^234:56\");\n    expect2(fmt, (Formattable)((double)1234.56), numstr);\n}\n\ntypedef struct {\n    const char *   locale;\n    UBool          lenient;\n    UnicodeString  numString;\n    double         value;\n} SignsAndMarksItem;\n\n\nvoid NumberFormatTest::TestParseSignsAndMarks() {\n    const SignsAndMarksItem items[] = {\n        // locale               lenient numString                                                       value\n        { \"en\",                 FALSE,  CharsToUnicodeString(\"12\"),                                      12 },\n        { \"en\",                 TRUE,   CharsToUnicodeString(\"12\"),                                      12 },\n        { \"en\",                 FALSE,  CharsToUnicodeString(\"-23\"),                                    -23 },\n        { \"en\",                 TRUE,   CharsToUnicodeString(\"-23\"),                                    -23 },\n        { \"en\",                 TRUE,   CharsToUnicodeString(\"- 23\"),                                   -23 },\n        { \"en\",                 FALSE,  CharsToUnicodeString(\"\\\\u200E-23\"),                             -23 },\n        { \"en\",                 TRUE,   CharsToUnicodeString(\"\\\\u200E-23\"),                             -23 },\n        { \"en\",                 TRUE,   CharsToUnicodeString(\"\\\\u200E- 23\"),                            -23 },\n\n        { \"en@numbers=arab\",    FALSE,  CharsToUnicodeString(\"\\\\u0663\\\\u0664\"),                          34 },\n        { \"en@numbers=arab\",    TRUE,   CharsToUnicodeString(\"\\\\u0663\\\\u0664\"),                          34 },\n        { \"en@numbers=arab\",    FALSE,  CharsToUnicodeString(\"-\\\\u0664\\\\u0665\"),                        -45 },\n        { \"en@numbers=arab\",    TRUE,   CharsToUnicodeString(\"-\\\\u0664\\\\u0665\"),                        -45 },\n        { \"en@numbers=arab\",    TRUE,   CharsToUnicodeString(\"- \\\\u0664\\\\u0665\"),                       -45 },\n        { \"en@numbers=arab\",    FALSE,  CharsToUnicodeString(\"\\\\u200F-\\\\u0664\\\\u0665\"),                 -45 },\n        { \"en@numbers=arab\",    TRUE,   CharsToUnicodeString(\"\\\\u200F-\\\\u0664\\\\u0665\"),                 -45 },\n        { \"en@numbers=arab\",    TRUE,   CharsToUnicodeString(\"\\\\u200F- \\\\u0664\\\\u0665\"),                -45 },\n\n        { \"en@numbers=arabext\", FALSE,  CharsToUnicodeString(\"\\\\u06F5\\\\u06F6\"),                          56 },\n        { \"en@numbers=arabext\", TRUE,   CharsToUnicodeString(\"\\\\u06F5\\\\u06F6\"),                          56 },\n        { \"en@numbers=arabext\", FALSE,  CharsToUnicodeString(\"-\\\\u06F6\\\\u06F7\"),                        -67 },\n        { \"en@numbers=arabext\", TRUE,   CharsToUnicodeString(\"-\\\\u06F6\\\\u06F7\"),                        -67 },\n        { \"en@numbers=arabext\", TRUE,   CharsToUnicodeString(\"- \\\\u06F6\\\\u06F7\"),                       -67 },\n        { \"en@numbers=arabext\", FALSE,  CharsToUnicodeString(\"\\\\u200E-\\\\u200E\\\\u06F6\\\\u06F7\"),          -67 },\n        { \"en@numbers=arabext\", TRUE,   CharsToUnicodeString(\"\\\\u200E-\\\\u200E\\\\u06F6\\\\u06F7\"),          -67 },\n        { \"en@numbers=arabext\", TRUE,   CharsToUnicodeString(\"\\\\u200E-\\\\u200E \\\\u06F6\\\\u06F7\"),         -67 },\n\n        { \"he\",                 FALSE,  CharsToUnicodeString(\"12\"),                                      12 },\n        { \"he\",                 TRUE,   CharsToUnicodeString(\"12\"),                                      12 },\n        { \"he\",                 FALSE,  CharsToUnicodeString(\"-23\"),                                    -23 },\n        { \"he\",                 TRUE,   CharsToUnicodeString(\"-23\"),                                    -23 },\n        { \"he\",                 TRUE,   CharsToUnicodeString(\"- 23\"),                                   -23 },\n        { \"he\",                 FALSE,  CharsToUnicodeString(\"\\\\u200E-23\"),                             -23 },\n        { \"he\",                 TRUE,   CharsToUnicodeString(\"\\\\u200E-23\"),                             -23 },\n        { \"he\",                 TRUE,   CharsToUnicodeString(\"\\\\u200E- 23\"),                            -23 },\n\n        { \"ar\",                 FALSE,  CharsToUnicodeString(\"\\\\u0663\\\\u0664\"),                          34 },\n        { \"ar\",                 TRUE,   CharsToUnicodeString(\"\\\\u0663\\\\u0664\"),                          34 },\n        { \"ar\",                 FALSE,  CharsToUnicodeString(\"-\\\\u0664\\\\u0665\"),                        -45 },\n        { \"ar\",                 TRUE,   CharsToUnicodeString(\"-\\\\u0664\\\\u0665\"),                        -45 },\n        { \"ar\",                 TRUE,   CharsToUnicodeString(\"- \\\\u0664\\\\u0665\"),                       -45 },\n        { \"ar\",                 FALSE,  CharsToUnicodeString(\"\\\\u200F-\\\\u0664\\\\u0665\"),                 -45 },\n        { \"ar\",                 TRUE,   CharsToUnicodeString(\"\\\\u200F-\\\\u0664\\\\u0665\"),                 -45 },\n        { \"ar\",                 TRUE,   CharsToUnicodeString(\"\\\\u200F- \\\\u0664\\\\u0665\"),                -45 },\n\n        { \"ar_MA\",              FALSE,  CharsToUnicodeString(\"12\"),                                      12 },\n        { \"ar_MA\",              TRUE,   CharsToUnicodeString(\"12\"),                                      12 },\n        { \"ar_MA\",              FALSE,  CharsToUnicodeString(\"-23\"),                                    -23 },\n        { \"ar_MA\",              TRUE,   CharsToUnicodeString(\"-23\"),                                    -23 },\n        { \"ar_MA\",              TRUE,   CharsToUnicodeString(\"- 23\"),                                   -23 },\n        { \"ar_MA\",              FALSE,  CharsToUnicodeString(\"\\\\u200E-23\"),                             -23 },\n        { \"ar_MA\",              TRUE,   CharsToUnicodeString(\"\\\\u200E-23\"),                             -23 },\n        { \"ar_MA\",              TRUE,   CharsToUnicodeString(\"\\\\u200E- 23\"),                            -23 },\n\n        { \"fa\",                 FALSE,  CharsToUnicodeString(\"\\\\u06F5\\\\u06F6\"),                          56 },\n        { \"fa\",                 TRUE,   CharsToUnicodeString(\"\\\\u06F5\\\\u06F6\"),                          56 },\n        { \"fa\",                 FALSE,  CharsToUnicodeString(\"\\\\u2212\\\\u06F6\\\\u06F7\"),                  -67 },\n        { \"fa\",                 TRUE,   CharsToUnicodeString(\"\\\\u2212\\\\u06F6\\\\u06F7\"),                  -67 },\n        { \"fa\",                 TRUE,   CharsToUnicodeString(\"\\\\u2212 \\\\u06F6\\\\u06F7\"),                 -67 },\n        { \"fa\",                 FALSE,  CharsToUnicodeString(\"\\\\u200E\\\\u2212\\\\u200E\\\\u06F6\\\\u06F7\"),    -67 },\n        { \"fa\",                 TRUE,   CharsToUnicodeString(\"\\\\u200E\\\\u2212\\\\u200E\\\\u06F6\\\\u06F7\"),    -67 },\n        { \"fa\",                 TRUE,   CharsToUnicodeString(\"\\\\u200E\\\\u2212\\\\u200E \\\\u06F6\\\\u06F7\"),   -67 },\n\n        { \"ps\",                 FALSE,  CharsToUnicodeString(\"\\\\u06F5\\\\u06F6\"),                          56 },\n        { \"ps\",                 TRUE,   CharsToUnicodeString(\"\\\\u06F5\\\\u06F6\"),                          56 },\n        { \"ps\",                 FALSE,  CharsToUnicodeString(\"-\\\\u06F6\\\\u06F7\"),                        -67 },\n        { \"ps\",                 TRUE,   CharsToUnicodeString(\"-\\\\u06F6\\\\u06F7\"),                        -67 },\n        { \"ps\",                 TRUE,   CharsToUnicodeString(\"- \\\\u06F6\\\\u06F7\"),                       -67 },\n        { \"ps\",                 FALSE,  CharsToUnicodeString(\"\\\\u200E-\\\\u200E\\\\u06F6\\\\u06F7\"),          -67 },\n        { \"ps\",                 TRUE,   CharsToUnicodeString(\"\\\\u200E-\\\\u200E\\\\u06F6\\\\u06F7\"),          -67 },\n        { \"ps\",                 TRUE,   CharsToUnicodeString(\"\\\\u200E-\\\\u200E \\\\u06F6\\\\u06F7\"),         -67 },\n        { \"ps\",                 FALSE,  CharsToUnicodeString(\"-\\\\u200E\\\\u06F6\\\\u06F7\"),                 -67 },\n        { \"ps\",                 TRUE,   CharsToUnicodeString(\"-\\\\u200E\\\\u06F6\\\\u06F7\"),                 -67 },\n        { \"ps\",                 TRUE,   CharsToUnicodeString(\"-\\\\u200E \\\\u06F6\\\\u06F7\"),                -67 },\n        // terminator\n        { NULL,                 0,      UnicodeString(\"\"),                                                0 },\n    };\n\n    const SignsAndMarksItem * itemPtr;\n    for (itemPtr = items; itemPtr->locale != NULL; itemPtr++ ) {\n        UErrorCode status = U_ZERO_ERROR;\n        NumberFormat *numfmt = NumberFormat::createInstance(Locale(itemPtr->locale), status);\n        if (U_SUCCESS(status)) {\n            numfmt->setLenient(itemPtr->lenient);\n            Formattable fmtobj;\n            ParsePosition ppos;\n            numfmt->parse(itemPtr->numString, fmtobj, ppos);\n            if (ppos.getIndex() == itemPtr->numString.length()) {\n                double parsedValue = fmtobj.getDouble(status);\n                if (U_FAILURE(status) || parsedValue != itemPtr->value) {\n                    errln((UnicodeString)\"FAIL: locale \" + itemPtr->locale + \", lenient \" + itemPtr->lenient + \", parse of \\\"\" + itemPtr->numString + \"\\\" gives value \" + parsedValue);\n                }\n            } else {\n                errln((UnicodeString)\"FAIL: locale \" + itemPtr->locale + \", lenient \" + itemPtr->lenient + \", parse of \\\"\" + itemPtr->numString + \"\\\" gives position \" + ppos.getIndex());\n            }\n        } else {\n            dataerrln(\"FAIL: NumberFormat::createInstance for locale % gives error %s\", itemPtr->locale, u_errorName(status));\n        }\n        delete numfmt;\n    }\n}\n\ntypedef struct {\n  DecimalFormat::ERoundingMode mode;\n  double value;\n  UnicodeString expected;\n} Test10419Data;\n\n\n// Tests that rounding works right when fractional digits is set to 0.\nvoid NumberFormatTest::Test10419RoundingWith0FractionDigits() {\n    const Test10419Data items[] = {\n        { DecimalFormat::kRoundCeiling, 1.488,  \"2\"},\n        { DecimalFormat::kRoundDown, 1.588,  \"1\"},\n        { DecimalFormat::kRoundFloor, 1.888,  \"1\"},\n        { DecimalFormat::kRoundHalfDown, 1.5,  \"1\"},\n        { DecimalFormat::kRoundHalfEven, 2.5,  \"2\"},\n        { DecimalFormat::kRoundHalfUp, 2.5,  \"3\"},\n        { DecimalFormat::kRoundUp, 1.5,  \"2\"},\n    };\n    UErrorCode status = U_ZERO_ERROR;\n    LocalPointer<DecimalFormat> decfmt((DecimalFormat *) NumberFormat::createInstance(Locale(\"en_US\"), status));\n    if (U_FAILURE(status)) {\n        dataerrln(\"Failure creating DecimalFormat %s\", u_errorName(status));\n        return;\n    }\n    for (int32_t i = 0; i < UPRV_LENGTHOF(items); ++i) {\n        decfmt->setRoundingMode(items[i].mode);\n        decfmt->setMaximumFractionDigits(0);\n        UnicodeString actual;\n        if (items[i].expected != decfmt->format(items[i].value, actual)) {\n            errln(\"Expected \" + items[i].expected + \", got \" + actual);\n        }\n    }\n}\n\nvoid NumberFormatTest::Test10468ApplyPattern() {\n    // Padding char of fmt is now 'a'\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat fmt(\"'I''ll'*a###.##\", status);\n\n    if (U_FAILURE(status)) {\n        errcheckln(status, \"DecimalFormat constructor failed - %s\", u_errorName(status));\n        return;\n    }\n\n    assertEquals(\"Padding character should be 'a'.\", u\"a\", fmt.getPadCharacterString());\n\n    // Padding char of fmt ought to be '*' since that is the default and no\n    // explicit padding char is specified in the new pattern.\n    fmt.applyPattern(\"AA#,##0.00ZZ\", status);\n\n    // Oops this still prints 'a' even though we changed the pattern.\n    assertEquals(\"applyPattern did not clear padding character.\", u\" \", fmt.getPadCharacterString());\n}\n\nvoid NumberFormatTest::TestRoundingScientific10542() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat format(\"0.00E0\", status);\n    if (U_FAILURE(status)) {\n        errcheckln(status, \"DecimalFormat constructor failed - %s\", u_errorName(status));\n        return;\n    }\n\n    DecimalFormat::ERoundingMode roundingModes[] = {\n            DecimalFormat::kRoundCeiling,\n            DecimalFormat::kRoundDown,\n            DecimalFormat::kRoundFloor,\n            DecimalFormat::kRoundHalfDown,\n            DecimalFormat::kRoundHalfEven,\n            DecimalFormat::kRoundHalfUp,\n            DecimalFormat::kRoundUp};\n    const char *descriptions[] = {\n            \"Round Ceiling\",\n            \"Round Down\",\n            \"Round Floor\",\n            \"Round half down\",\n            \"Round half even\",\n            \"Round half up\",\n            \"Round up\"};\n\n    {\n        double values[] = {-0.003006, -0.003005, -0.003004, 0.003014, 0.003015, 0.003016};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        const char *expected[] = {\n                \"-3.00E-3\", \"-3.00E-3\", \"-3.00E-3\", \"3.02E-3\", \"3.02E-3\", \"3.02E-3\",\n                \"-3.00E-3\", \"-3.00E-3\", \"-3.00E-3\", \"3.01E-3\", \"3.01E-3\", \"3.01E-3\",\n                \"-3.01E-3\", \"-3.01E-3\", \"-3.01E-3\", \"3.01E-3\", \"3.01E-3\", \"3.01E-3\",\n                \"-3.01E-3\", \"-3.00E-3\", \"-3.00E-3\", \"3.01E-3\", \"3.01E-3\", \"3.02E-3\",\n                \"-3.01E-3\", \"-3.00E-3\", \"-3.00E-3\", \"3.01E-3\", \"3.02E-3\", \"3.02E-3\",\n                \"-3.01E-3\", \"-3.01E-3\", \"-3.00E-3\", \"3.01E-3\", \"3.02E-3\", \"3.02E-3\",\n                \"-3.01E-3\", \"-3.01E-3\", \"-3.01E-3\", \"3.02E-3\", \"3.02E-3\", \"3.02E-3\"};\n        verifyRounding(\n                format,\n                values,\n                expected,\n                roundingModes,\n                descriptions,\n                UPRV_LENGTHOF(values),\n                UPRV_LENGTHOF(roundingModes));\n    }\n    {\n        double values[] = {-3006.0, -3005, -3004, 3014, 3015, 3016};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        const char *expected[] = {\n                \"-3.00E3\", \"-3.00E3\", \"-3.00E3\", \"3.02E3\", \"3.02E3\", \"3.02E3\",\n                \"-3.00E3\", \"-3.00E3\", \"-3.00E3\", \"3.01E3\", \"3.01E3\", \"3.01E3\",\n                \"-3.01E3\", \"-3.01E3\", \"-3.01E3\", \"3.01E3\", \"3.01E3\", \"3.01E3\",\n                \"-3.01E3\", \"-3.00E3\", \"-3.00E3\", \"3.01E3\", \"3.01E3\", \"3.02E3\",\n                \"-3.01E3\", \"-3.00E3\", \"-3.00E3\", \"3.01E3\", \"3.02E3\", \"3.02E3\",\n                \"-3.01E3\", \"-3.01E3\", \"-3.00E3\", \"3.01E3\", \"3.02E3\", \"3.02E3\",\n                \"-3.01E3\", \"-3.01E3\", \"-3.01E3\", \"3.02E3\", \"3.02E3\", \"3.02E3\"};\n        verifyRounding(\n                format,\n                values,\n                expected,\n                roundingModes,\n                descriptions,\n                UPRV_LENGTHOF(values),\n                UPRV_LENGTHOF(roundingModes));\n    }\n/* Commented out for now until we decide how rounding to zero should work, +0 vs. -0\n    {\n        double values[] = {0.0, -0.0};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        const char *expected[] = {\n                \"0.00E0\", \"-0.00E0\",\n                \"0.00E0\", \"-0.00E0\",\n                \"0.00E0\", \"-0.00E0\",\n                \"0.00E0\", \"-0.00E0\",\n                \"0.00E0\", \"-0.00E0\",\n                \"0.00E0\", \"-0.00E0\",\n                \"0.00E0\", \"-0.00E0\"};\n        verifyRounding(\n                format,\n                values,\n                expected,\n                roundingModes,\n                descriptions,\n                UPRV_LENGTHOF(values),\n                UPRV_LENGTHOF(roundingModes));\n    }\n*/\n    {\n\n        double values[] = {1e25, 1e25 + 1e15, 1e25 - 1e15};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        const char *expected[] = {\n                \"1.00E25\", \"1.01E25\", \"1.00E25\",\n                \"1.00E25\", \"1.00E25\", \"9.99E24\",\n                \"1.00E25\", \"1.00E25\", \"9.99E24\",\n                \"1.00E25\", \"1.00E25\", \"1.00E25\",\n                \"1.00E25\", \"1.00E25\", \"1.00E25\",\n                \"1.00E25\", \"1.00E25\", \"1.00E25\",\n                \"1.00E25\", \"1.01E25\", \"1.00E25\"};\n        verifyRounding(\n                format,\n                values,\n                expected,\n                roundingModes,\n                descriptions,\n                UPRV_LENGTHOF(values),\n                UPRV_LENGTHOF(roundingModes));\n        }\n    {\n        double values[] = {-1e25, -1e25 + 1e15, -1e25 - 1e15};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        const char *expected[] = {\n                \"-1.00E25\", \"-9.99E24\", \"-1.00E25\",\n                \"-1.00E25\", \"-9.99E24\", \"-1.00E25\",\n                \"-1.00E25\", \"-1.00E25\", \"-1.01E25\",\n                \"-1.00E25\", \"-1.00E25\", \"-1.00E25\",\n                \"-1.00E25\", \"-1.00E25\", \"-1.00E25\",\n                \"-1.00E25\", \"-1.00E25\", \"-1.00E25\",\n                \"-1.00E25\", \"-1.00E25\", \"-1.01E25\"};\n        verifyRounding(\n                format,\n                values,\n                expected,\n                roundingModes,\n                descriptions,\n                UPRV_LENGTHOF(values),\n                UPRV_LENGTHOF(roundingModes));\n        }\n    {\n        double values[] = {1e-25, 1e-25 + 1e-35, 1e-25 - 1e-35};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        const char *expected[] = {\n                \"1.00E-25\", \"1.01E-25\", \"1.00E-25\",\n                \"1.00E-25\", \"1.00E-25\", \"9.99E-26\",\n                \"1.00E-25\", \"1.00E-25\", \"9.99E-26\",\n                \"1.00E-25\", \"1.00E-25\", \"1.00E-25\",\n                \"1.00E-25\", \"1.00E-25\", \"1.00E-25\",\n                \"1.00E-25\", \"1.00E-25\", \"1.00E-25\",\n                \"1.00E-25\", \"1.01E-25\", \"1.00E-25\"};\n        verifyRounding(\n                format,\n                values,\n                expected,\n                roundingModes,\n                descriptions,\n                UPRV_LENGTHOF(values),\n                UPRV_LENGTHOF(roundingModes));\n        }\n    {\n        double values[] = {-1e-25, -1e-25 + 1e-35, -1e-25 - 1e-35};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        const char *expected[] = {\n                \"-1.00E-25\", \"-9.99E-26\", \"-1.00E-25\",\n                \"-1.00E-25\", \"-9.99E-26\", \"-1.00E-25\",\n                \"-1.00E-25\", \"-1.00E-25\", \"-1.01E-25\",\n                \"-1.00E-25\", \"-1.00E-25\", \"-1.00E-25\",\n                \"-1.00E-25\", \"-1.00E-25\", \"-1.00E-25\",\n                \"-1.00E-25\", \"-1.00E-25\", \"-1.00E-25\",\n                \"-1.00E-25\", \"-1.00E-25\", \"-1.01E-25\"};\n        verifyRounding(\n                format,\n                values,\n                expected,\n                roundingModes,\n                descriptions,\n                UPRV_LENGTHOF(values),\n                UPRV_LENGTHOF(roundingModes));\n    }\n}\n\nvoid NumberFormatTest::TestZeroScientific10547() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat fmt(\"0.00E0\", status);\n    if (!assertSuccess(\"Format creation\", status)) {\n        return;\n    }\n    UnicodeString out;\n    fmt.format(-0.0, out);\n    assertEquals(\"format\", \"-0.00E0\", out, true);\n}\n\nvoid NumberFormatTest::verifyRounding(\n        DecimalFormat& format,\n        const double *values,\n        const char * const *expected,\n        const DecimalFormat::ERoundingMode *roundingModes,\n        const char * const *descriptions,\n        int32_t valueSize,\n        int32_t roundingModeSize) {\n    for (int32_t i = 0; i < roundingModeSize; ++i) {\n        format.setRoundingMode(roundingModes[i]);\n        for (int32_t j = 0; j < valueSize; j++) {\n            UnicodeString currentExpected(expected[i * valueSize + j]);\n            currentExpected = currentExpected.unescape();\n            UnicodeString actual;\n            format.format(values[j], actual);\n            if (currentExpected != actual) {\n                dataerrln(\"For %s value %f, expected '%s', got '%s'\",\n                          descriptions[i], values[j], CStr(currentExpected)(), CStr(actual)());\n            }\n        }\n    }\n}\n\nvoid NumberFormatTest::TestAccountingCurrency() {\n    UErrorCode status = U_ZERO_ERROR;\n    UNumberFormatStyle style = UNUM_CURRENCY_ACCOUNTING;\n\n    expect(NumberFormat::createInstance(\"en_US\", style, status),\n        (Formattable)(double)1234.5, \"$1,234.50\", TRUE, status);\n    expect(NumberFormat::createInstance(\"en_US\", style, status),\n        (Formattable)(double)-1234.5, \"($1,234.50)\", TRUE, status);\n    expect(NumberFormat::createInstance(\"en_US\", style, status),\n        (Formattable)(double)0, \"$0.00\", TRUE, status);\n    expect(NumberFormat::createInstance(\"en_US\", style, status),\n        (Formattable)(double)-0.2, \"($0.20)\", TRUE, status);\n    expect(NumberFormat::createInstance(\"ja_JP\", style, status),\n        (Formattable)(double)10000, UnicodeString(\"\\\\uFFE510,000\").unescape(), TRUE, status);\n    expect(NumberFormat::createInstance(\"ja_JP\", style, status),\n        (Formattable)(double)-1000.5, UnicodeString(\"(\\\\uFFE51,000)\").unescape(), FALSE, status);\n    expect(NumberFormat::createInstance(\"de_DE\", style, status),\n        (Formattable)(double)-23456.7, UnicodeString(\"-23.456,70\\\\u00A0\\\\u20AC\").unescape(), TRUE, status);\n}\n\n// for #5186\nvoid NumberFormatTest::TestEquality() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols symbols(Locale(\"root\"), status);\n    if (U_FAILURE(status)) {\n    \tdataerrln(\"Fail: can't create DecimalFormatSymbols for root\");\n    \treturn;\n    }\n    UnicodeString pattern(\"#,##0.###\");\n    DecimalFormat fmtBase(pattern, symbols, status);\n    if (U_FAILURE(status)) {\n    \tdataerrln(\"Fail: can't create DecimalFormat using root symbols\");\n    \treturn;\n    }\n\n    DecimalFormat* fmtClone = (DecimalFormat*)fmtBase.clone();\n    fmtClone->setFormatWidth(fmtBase.getFormatWidth() + 32);\n    if (*fmtClone == fmtBase) {\n        errln(\"Error: DecimalFormat == does not distinguish objects that differ only in FormatWidth\");\n    }\n    delete fmtClone;\n}\n\nvoid NumberFormatTest::TestCurrencyUsage() {\n    double agent = 123.567;\n\n    UErrorCode status;\n    DecimalFormat *fmt;\n\n    // compare the Currency and Currency Cash Digits\n    // Note that as of CLDR 26:\n    // * TWD and PKR switched from 0 decimals to 2; ISK still has 0, so change test to that\n    // * CAD rounds to .05 in cash mode only\n    // 1st time for getter/setter, 2nd time for factory method\n    Locale enUS_ISK(\"en_US@currency=ISK\");\n\n    for(int i=0; i<2; i++){\n        status = U_ZERO_ERROR;\n        if(i == 0){\n            fmt = (DecimalFormat *) NumberFormat::createInstance(enUS_ISK, UNUM_CURRENCY, status);\n            if (assertSuccess(\"en_US@currency=ISK/CURRENCY\", status, TRUE) == FALSE) {\n                continue;\n            }\n\n            UnicodeString original;\n            fmt->format(agent,original);\n            assertEquals(\"Test Currency Usage 1\", u\"ISK\\u00A0124\", original);\n\n            // test the getter here\n            UCurrencyUsage curUsage = fmt->getCurrencyUsage();\n            assertEquals(\"Test usage getter - standard\", (int32_t)curUsage, (int32_t)UCURR_USAGE_STANDARD);\n\n            fmt->setCurrencyUsage(UCURR_USAGE_CASH, &status);\n        }else{\n            fmt = (DecimalFormat *) NumberFormat::createInstance(enUS_ISK, UNUM_CASH_CURRENCY, status);\n            if (assertSuccess(\"en_US@currency=ISK/CASH\", status, TRUE) == FALSE) {\n                continue;\n            }\n        }\n\n        // must be usage = cash\n        UCurrencyUsage curUsage = fmt->getCurrencyUsage();\n        assertEquals(\"Test usage getter - cash\", (int32_t)curUsage, (int32_t)UCURR_USAGE_CASH);\n\n        UnicodeString cash_currency;\n        fmt->format(agent,cash_currency);\n        assertEquals(\"Test Currency Usage 2\", u\"ISK\\u00A0124\", cash_currency);\n        delete fmt;\n    }\n\n    // compare the Currency and Currency Cash Rounding\n    // 1st time for getter/setter, 2nd time for factory method\n    Locale enUS_CAD(\"en_US@currency=CAD\");\n    for(int i=0; i<2; i++){\n        status = U_ZERO_ERROR;\n        if(i == 0){\n            fmt = (DecimalFormat *) NumberFormat::createInstance(enUS_CAD, UNUM_CURRENCY, status);\n            if (assertSuccess(\"en_US@currency=CAD/CURRENCY\", status, TRUE) == FALSE) {\n                continue;\n            }\n\n            UnicodeString original_rounding;\n            fmt->format(agent, original_rounding);\n            assertEquals(\"Test Currency Usage 3\", u\"CA$123.57\", original_rounding);\n            fmt->setCurrencyUsage(UCURR_USAGE_CASH, &status);\n        }else{\n            fmt = (DecimalFormat *) NumberFormat::createInstance(enUS_CAD, UNUM_CASH_CURRENCY, status);\n            if (assertSuccess(\"en_US@currency=CAD/CASH\", status, TRUE) == FALSE) {\n                continue;\n            }\n        }\n\n        UnicodeString cash_rounding_currency;\n        fmt->format(agent, cash_rounding_currency);\n        assertEquals(\"Test Currency Usage 4\", u\"CA$123.55\", cash_rounding_currency);\n        delete fmt;\n    }\n\n    // Test the currency change\n    // 1st time for getter/setter, 2nd time for factory method\n    const UChar CUR_PKR[] = {0x50, 0x4B, 0x52, 0};\n    for(int i=0; i<2; i++){\n        status = U_ZERO_ERROR;\n        if(i == 0){\n            fmt = (DecimalFormat *) NumberFormat::createInstance(enUS_CAD, UNUM_CURRENCY, status);\n            if (assertSuccess(\"en_US@currency=CAD/CURRENCY\", status, TRUE) == FALSE) {\n                continue;\n            }\n            fmt->setCurrencyUsage(UCURR_USAGE_CASH, &status);\n        }else{\n            fmt = (DecimalFormat *) NumberFormat::createInstance(enUS_CAD, UNUM_CASH_CURRENCY, status);\n            if (assertSuccess(\"en_US@currency=CAD/CASH\", status, TRUE) == FALSE) {\n                continue;\n            }\n        }\n\n        UnicodeString cur_original;\n        fmt->setCurrencyUsage(UCURR_USAGE_STANDARD, &status);\n        fmt->format(agent, cur_original);\n        assertEquals(\"Test Currency Usage 5\", u\"CA$123.57\", cur_original);\n\n        fmt->setCurrency(CUR_PKR, status);\n        assertSuccess(\"Set currency to PKR\", status);\n\n        UnicodeString PKR_changed;\n        fmt->format(agent, PKR_changed);\n        assertEquals(\"Test Currency Usage 6\", u\"PKR\\u00A0123.57\", PKR_changed);\n        delete fmt;\n    }\n}\n\n\n// Check the constant MAX_INT64_IN_DOUBLE.\n// The value should convert to a double with no loss of precision.\n// A failure may indicate a platform with a different double format, requiring\n// a revision to the constant.\n//\n// Note that this is actually hard to test, because the language standard gives\n//  compilers considerable flexibility to do unexpected things with rounding and\n//  with overflow in simple int to/from float conversions. Some compilers will completely optimize\n//  away a simple round-trip conversion from int64_t -> double -> int64_t.\n\nvoid NumberFormatTest::TestDoubleLimit11439() {\n    char  buf[50];\n    for (int64_t num = MAX_INT64_IN_DOUBLE-10; num<=MAX_INT64_IN_DOUBLE; num++) {\n        sprintf(buf, \"%lld\", (long long)num);\n        double fNum = 0.0;\n        sscanf(buf, \"%lf\", &fNum);\n        int64_t rtNum = static_cast<int64_t>(fNum);\n        if (num != rtNum) {\n            errln(\"%s:%d MAX_INT64_IN_DOUBLE test, %lld did not round trip. Got %lld\", __FILE__, __LINE__, (long long)num, (long long)rtNum);\n            return;\n        }\n    }\n    for (int64_t num = -MAX_INT64_IN_DOUBLE+10; num>=-MAX_INT64_IN_DOUBLE; num--) {\n        sprintf(buf, \"%lld\", (long long)num);\n        double fNum = 0.0;\n        sscanf(buf, \"%lf\", &fNum);\n        int64_t rtNum = static_cast<int64_t>(fNum);\n        if (num != rtNum) {\n            errln(\"%s:%d MAX_INT64_IN_DOUBLE test, %lld did not round trip. Got %lld\", __FILE__, __LINE__, (long long)num, (long long)rtNum);\n            return;\n        }\n    }\n}\n\nvoid NumberFormatTest::TestGetAffixes() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols sym(\"en_US\", status);\n    UnicodeString pattern(\"\\\\u00a4\\\\u00a4\\\\u00a4 0.00 %\\\\u00a4\\\\u00a4\");\n    pattern = pattern.unescape();\n    DecimalFormat fmt(pattern, sym, status);\n    if (U_FAILURE(status)) {\n        dataerrln(\"Error creating DecimalFormat - %s\", u_errorName(status));\n        return;\n    }\n    UnicodeString affixStr;\n    assertEquals(\"\", \"US dollars \", fmt.getPositivePrefix(affixStr));\n    assertEquals(\"\", \" %USD\", fmt.getPositiveSuffix(affixStr));\n    assertEquals(\"\", \"-US dollars \", fmt.getNegativePrefix(affixStr));\n    assertEquals(\"\", \" %USD\", fmt.getNegativeSuffix(affixStr));\n\n    // Test equality with affixes. set affix methods can't capture special\n    // characters which is why equality should fail.\n    {\n        DecimalFormat fmtCopy(fmt);\n        assertTrue(\"\", fmt == fmtCopy);\n        UnicodeString someAffix;\n        fmtCopy.setPositivePrefix(fmtCopy.getPositivePrefix(someAffix));\n        assertTrue(\"\", fmt != fmtCopy);\n    }\n    {\n        DecimalFormat fmtCopy(fmt);\n        assertTrue(\"\", fmt == fmtCopy);\n        UnicodeString someAffix;\n        fmtCopy.setPositiveSuffix(fmtCopy.getPositiveSuffix(someAffix));\n        assertTrue(\"\", fmt != fmtCopy);\n    }\n    {\n        DecimalFormat fmtCopy(fmt);\n        assertTrue(\"\", fmt == fmtCopy);\n        UnicodeString someAffix;\n        fmtCopy.setNegativePrefix(fmtCopy.getNegativePrefix(someAffix));\n        assertTrue(\"\", fmt != fmtCopy);\n    }\n    {\n        DecimalFormat fmtCopy(fmt);\n        assertTrue(\"\", fmt == fmtCopy);\n        UnicodeString someAffix;\n        fmtCopy.setNegativeSuffix(fmtCopy.getNegativeSuffix(someAffix));\n        assertTrue(\"\", fmt != fmtCopy);\n    }\n    fmt.setPositivePrefix(\"Don't\");\n    fmt.setPositiveSuffix(\"do\");\n    UnicodeString someAffix(\"be''eet\\\\u00a4\\\\u00a4\\\\u00a4 it.\");\n    someAffix = someAffix.unescape();\n    fmt.setNegativePrefix(someAffix);\n    fmt.setNegativeSuffix(\"%\");\n    assertEquals(\"\", \"Don't\", fmt.getPositivePrefix(affixStr));\n    assertEquals(\"\", \"do\", fmt.getPositiveSuffix(affixStr));\n    assertEquals(\"\", someAffix, fmt.getNegativePrefix(affixStr));\n    assertEquals(\"\", \"%\", fmt.getNegativeSuffix(affixStr));\n}\n\nvoid NumberFormatTest::TestToPatternScientific11648() {\n    UErrorCode status = U_ZERO_ERROR;\n    Locale en(\"en\");\n    DecimalFormatSymbols sym(en, status);\n    DecimalFormat fmt(\"0.00\", sym, status);\n    if (U_FAILURE(status)) {\n        dataerrln(\"Error creating DecimalFormat - %s\", u_errorName(status));\n        return;\n    }\n    fmt.setScientificNotation(TRUE);\n    UnicodeString pattern;\n    assertEquals(\"\", \"0.00E0\", fmt.toPattern(pattern));\n    DecimalFormat fmt2(pattern, sym, status);\n    assertSuccess(\"\", status);\n}\n\nvoid NumberFormatTest::TestBenchmark() {\n/*\n    UErrorCode status = U_ZERO_ERROR;\n    Locale en(\"en\");\n    DecimalFormatSymbols sym(en, status);\n    DecimalFormat fmt(\"0.0000000\", new DecimalFormatSymbols(sym), status);\n//    DecimalFormat fmt(\"0.00000E0\", new DecimalFormatSymbols(sym), status);\n//    DecimalFormat fmt(\"0\", new DecimalFormatSymbols(sym), status);\n    FieldPosition fpos(FieldPosition::DONT_CARE);\n    clock_t start = clock();\n    for (int32_t i = 0; i < 1000000; ++i) {\n        UnicodeString append;\n        fmt.format(3.0, append, fpos, status);\n//        fmt.format(4.6692016, append, fpos, status);\n//        fmt.format(1234567.8901, append, fpos, status);\n//        fmt.format(2.99792458E8, append, fpos, status);\n//        fmt.format(31, append);\n    }\n    errln(\"Took %f\", (double) (clock() - start) / CLOCKS_PER_SEC);\n    assertSuccess(\"\", status);\n\n    UErrorCode status = U_ZERO_ERROR;\n    MessageFormat fmt(\"{0, plural, one {I have # friend.} other {I have # friends.}}\", status);\n    FieldPosition fpos(FieldPosition::DONT_CARE);\n    Formattable one(1.0);\n    Formattable three(3.0);\n    clock_t start = clock();\n    for (int32_t i = 0; i < 500000; ++i) {\n        UnicodeString append;\n        fmt.format(&one, 1, append, fpos, status);\n        UnicodeString append2;\n        fmt.format(&three, 1, append2, fpos, status);\n    }\n    errln(\"Took %f\", (double) (clock() - start) / CLOCKS_PER_SEC);\n    assertSuccess(\"\", status);\n\n    UErrorCode status = U_ZERO_ERROR;\n    Locale en(\"en\");\n    Measure measureC(23, MeasureUnit::createCelsius(status), status);\n    MeasureFormat fmt(en, UMEASFMT_WIDTH_WIDE, status);\n    FieldPosition fpos(FieldPosition::DONT_CARE);\n    clock_t start = clock();\n    for (int32_t i = 0; i < 1000000; ++i) {\n        UnicodeString appendTo;\n        fmt.formatMeasures(\n                &measureC, 1, appendTo, fpos, status);\n    }\n    errln(\"Took %f\", (double) (clock() - start) / CLOCKS_PER_SEC);\n    assertSuccess(\"\", status);\n*/\n}\n\nvoid NumberFormatTest::TestFractionalDigitsForCurrency() {\n    UErrorCode status = U_ZERO_ERROR;\n    LocalPointer<NumberFormat> fmt(NumberFormat::createCurrencyInstance(\"en\", status));\n    if (U_FAILURE(status)) {\n        dataerrln(\"Error creating NumberFormat - %s\", u_errorName(status));\n        return;\n    }\n    UChar JPY[] = {0x4A, 0x50, 0x59, 0x0};\n    fmt->setCurrency(JPY, status);\n    if (!assertSuccess(\"\", status)) {\n        return;\n    }\n    assertEquals(\"\", 0, fmt->getMaximumFractionDigits());\n}\n\n\nvoid NumberFormatTest::TestFormatCurrencyPlural() {\n    UErrorCode status = U_ZERO_ERROR;\n    Locale locale = Locale::createCanonical(\"en_US\");\n    NumberFormat *fmt = NumberFormat::createInstance(locale, UNUM_CURRENCY_PLURAL, status);\n    if (U_FAILURE(status)) {\n        dataerrln(\"Error creating NumberFormat - %s\", u_errorName(status));\n        return;\n    }\n   UnicodeString formattedNum;\n   fmt->format(11234.567, formattedNum, NULL, status);\n   assertEquals(\"\", \"11,234.57 US dollars\", formattedNum);\n   delete fmt;\n}\n\nvoid NumberFormatTest::TestCtorApplyPatternDifference() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols sym(\"en_US\", status);\n    UnicodeString pattern(\"\\\\u00a40\");\n    DecimalFormat fmt(pattern.unescape(), sym, status);\n    if (U_FAILURE(status)) {\n        dataerrln(\"Error creating DecimalFormat - %s\", u_errorName(status));\n        return;\n    }\n    UnicodeString result;\n    assertEquals(\n            \"ctor favors precision of currency\",\n            \"$5.00\",\n            fmt.format((double)5, result));\n    result.remove();\n    fmt.applyPattern(pattern.unescape(), status);\n    assertEquals(\n            \"applyPattern favors precision of pattern\",\n            \"$5\",\n            fmt.format((double)5, result));\n}\n\nvoid NumberFormatTest::Test11868() {\n    double posAmt = 34.567;\n    double negAmt = -9876.543;\n\n    Locale selectedLocale(\"en_US\");\n    UErrorCode status = U_ZERO_ERROR;\n\n    UnicodeString result;\n    FieldPosition fpCurr(UNUM_CURRENCY_FIELD);\n    LocalPointer<NumberFormat> fmt(\n            NumberFormat::createInstance(\n                    selectedLocale, UNUM_CURRENCY_PLURAL, status));\n    if (!assertSuccess(\"Format creation\", status)) {\n        return;\n    }\n    fmt->format(posAmt, result, fpCurr, status);\n    assertEquals(\"\", \"34.57 US dollars\", result);\n    assertEquals(\"begin index\", 6, fpCurr.getBeginIndex());\n    assertEquals(\"end index\", 16, fpCurr.getEndIndex());\n\n    // Test field position iterator\n    {\n        NumberFormatTest_Attributes attributes[] = {\n                {UNUM_INTEGER_FIELD, 0, 2},\n                {UNUM_DECIMAL_SEPARATOR_FIELD, 2, 3},\n                {UNUM_FRACTION_FIELD, 3, 5},\n                {UNUM_CURRENCY_FIELD, 6, 16},\n                {0, -1, 0}};\n        UnicodeString result;\n        FieldPositionIterator iter;\n        fmt->format(posAmt, result, &iter, status);\n        assertEquals(\"\", \"34.57 US dollars\", result);\n        verifyFieldPositionIterator(attributes, iter);\n    }\n\n    result.remove();\n    fmt->format(negAmt, result, fpCurr, status);\n    assertEquals(\"\", \"-9,876.54 US dollars\", result);\n    assertEquals(\"begin index\", 10, fpCurr.getBeginIndex());\n    assertEquals(\"end index\", 20, fpCurr.getEndIndex());\n\n    // Test field position iterator\n    {\n        NumberFormatTest_Attributes attributes[] = {\n                {UNUM_SIGN_FIELD, 0, 1},\n                {UNUM_GROUPING_SEPARATOR_FIELD, 2, 3},\n                {UNUM_INTEGER_FIELD, 1, 6},\n                {UNUM_DECIMAL_SEPARATOR_FIELD, 6, 7},\n                {UNUM_FRACTION_FIELD, 7, 9},\n                {UNUM_CURRENCY_FIELD, 10, 20},\n                {0, -1, 0}};\n        UnicodeString result;\n        FieldPositionIterator iter;\n        fmt->format(negAmt, result, &iter, status);\n        assertEquals(\"\", \"-9,876.54 US dollars\", result);\n        verifyFieldPositionIterator(attributes, iter);\n    }\n}\n\nvoid NumberFormatTest::Test10727_RoundingZero() {\n    IcuTestErrorCode status(*this, \"Test10727_RoundingZero\");\n    DecimalQuantity dq;\n    dq.setToDouble(-0.0);\n    assertTrue(\"\", dq.isNegative());\n    dq.roundToMagnitude(0, UNUM_ROUND_HALFEVEN, status);\n    assertTrue(\"\", dq.isNegative());\n}\n\nvoid NumberFormatTest::Test11739_ParseLongCurrency() {\n    IcuTestErrorCode status(*this, \"Test11739_ParseLongCurrency\");\n    LocalPointer<NumberFormat> nf(NumberFormat::createCurrencyInstance(\"sr_BA\", status));\n    if (status.errDataIfFailureAndReset()) { return; }\n    ((DecimalFormat*) nf.getAlias())->applyPattern(u\"#,##0.0 \u00a4\u00a4\u00a4\", status);\n    ParsePosition ppos(0);\n    LocalPointer<CurrencyAmount> result(nf->parseCurrency(u\"1.500 \u0430\u043c\u0435\u0440\u0438\u0447\u043a\u0438 \u0434\u043e\u043b\u0430\u0440\", ppos));\n    assertEquals(\"Should parse to 1500 USD\", -1, ppos.getErrorIndex());\n    assertEquals(\"Should parse to 1500 USD\", 1500LL, result->getNumber().getInt64(status));\n    assertEquals(\"Should parse to 1500 USD\", u\"USD\", result->getISOCurrency());\n}\n\nvoid NumberFormatTest::Test13035_MultiCodePointPaddingInPattern() {\n    IcuTestErrorCode status(*this, \"Test13035_MultiCodePointPaddingInPattern\");\n    DecimalFormat df(u\"a*'\u0ba8\u0bbf'###0b\", status);\n    if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) { return; }\n    UnicodeString result;\n    df.format(12, result.remove());\n    // TODO(13034): Re-enable this test when support is added in ICU4C.\n    //assertEquals(\"Multi-codepoint padding should not be split\", u\"a\u0ba8\u0bbf\u0ba8\u0bbf12b\", result);\n    df = DecimalFormat(u\"a*\\U0001F601###0b\", status);\n    if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) { return; }\n    result = df.format(12, result.remove());\n    assertEquals(\"Single-codepoint padding should not be split\", u\"a\\U0001F601\\U0001F60112b\", result, true);\n    df = DecimalFormat(u\"a*''###0b\", status);\n    if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) { return; }\n    result = df.format(12, result.remove());\n    assertEquals(\"Quote should be escapable in padding syntax\", \"a''12b\", result, true);\n}\n\nvoid NumberFormatTest::Test13737_ParseScientificStrict() {\n    IcuTestErrorCode status(*this, \"Test13737_ParseScientificStrict\");\n    LocalPointer<NumberFormat> df(NumberFormat::createScientificInstance(\"en\", status), status);\n    if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) {return;}\n    df->setLenient(FALSE);\n    // Parse Test\n    expect(*df, u\"1.2\", 1.2);\n}\n\nvoid NumberFormatTest::Test11376_getAndSetPositivePrefix() {\n    {\n        const UChar USD[] = {0x55, 0x53, 0x44, 0x0};\n        UErrorCode status = U_ZERO_ERROR;\n        LocalPointer<NumberFormat> fmt(\n                NumberFormat::createCurrencyInstance(\"en\", status));\n        if (!assertSuccess(\"\", status)) {\n            return;\n        }\n        DecimalFormat *dfmt = (DecimalFormat *) fmt.getAlias();\n        dfmt->setCurrency(USD);\n        UnicodeString result;\n\n        // This line should be a no-op. I am setting the positive prefix\n        // to be the same thing it was before.\n        dfmt->setPositivePrefix(dfmt->getPositivePrefix(result));\n\n        UnicodeString appendTo;\n        assertEquals(\"\", \"$3.78\", dfmt->format(3.78, appendTo, status));\n        assertSuccess(\"\", status);\n    }\n    {\n        const UChar USD[] = {0x55, 0x53, 0x44, 0x0};\n        UErrorCode status = U_ZERO_ERROR;\n        LocalPointer<NumberFormat> fmt(\n                NumberFormat::createInstance(\"en\", UNUM_CURRENCY_PLURAL, status));\n        if (!assertSuccess(\"\", status)) {\n            return;\n        }\n        DecimalFormat *dfmt = (DecimalFormat *) fmt.getAlias();\n        UnicodeString result;\n        assertEquals(\"\", u\" (unknown currency)\", dfmt->getPositiveSuffix(result));\n        dfmt->setCurrency(USD);\n\n        // getPositiveSuffix() always returns the suffix for the\n        // \"other\" plural category\n        assertEquals(\"\", \" US dollars\", dfmt->getPositiveSuffix(result));\n        UnicodeString appendTo;\n        assertEquals(\"\", \"3.78 US dollars\", dfmt->format(3.78, appendTo, status));\n        assertEquals(\"\", \" US dollars\", dfmt->getPositiveSuffix(result));\n        dfmt->setPositiveSuffix(\"booya\");\n        appendTo.remove();\n        assertEquals(\"\", \"3.78booya\", dfmt->format(3.78, appendTo, status));\n        assertEquals(\"\", \"booya\", dfmt->getPositiveSuffix(result));\n    }\n}\n\nvoid NumberFormatTest::Test11475_signRecognition() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols sym(\"en\", status);\n    UnicodeString result;\n    {\n        DecimalFormat fmt(\"+0.00\", sym, status);\n        if (!assertSuccess(\"\", status)) {\n            return;\n        }\n        NumberFormatTest_Attributes attributes[] = {\n                {UNUM_SIGN_FIELD, 0, 1},\n                {UNUM_INTEGER_FIELD, 1, 2},\n                {UNUM_DECIMAL_SEPARATOR_FIELD, 2, 3},\n                {UNUM_FRACTION_FIELD, 3, 5},\n                {0, -1, 0}};\n        UnicodeString result;\n        FieldPositionIterator iter;\n        fmt.format(2.3, result, &iter, status);\n        assertEquals(\"\", \"+2.30\", result);\n        verifyFieldPositionIterator(attributes, iter);\n    }\n    {\n        DecimalFormat fmt(\"++0.00+;-(#)--\", sym, status);\n        if (!assertSuccess(\"\", status)) {\n            return;\n        }\n        {\n            NumberFormatTest_Attributes attributes[] = {\n                    {UNUM_SIGN_FIELD, 0, 2},\n                    {UNUM_INTEGER_FIELD, 2, 3},\n                    {UNUM_DECIMAL_SEPARATOR_FIELD, 3, 4},\n                    {UNUM_FRACTION_FIELD, 4, 6},\n                    {UNUM_SIGN_FIELD, 6, 7},\n                    {0, -1, 0}};\n            UnicodeString result;\n            FieldPositionIterator iter;\n            fmt.format(2.3, result, &iter, status);\n            assertEquals(\"\", \"++2.30+\", result);\n            verifyFieldPositionIterator(attributes, iter);\n        }\n        {\n            NumberFormatTest_Attributes attributes[] = {\n                    {UNUM_SIGN_FIELD, 0, 1},\n                    {UNUM_INTEGER_FIELD, 2, 3},\n                    {UNUM_DECIMAL_SEPARATOR_FIELD, 3, 4},\n                    {UNUM_FRACTION_FIELD, 4, 6},\n                    {UNUM_SIGN_FIELD, 7, 9},\n                    {0, -1, 0}};\n            UnicodeString result;\n            FieldPositionIterator iter;\n            fmt.format(-2.3, result, &iter, status);\n            assertEquals(\"\", \"-(2.30)--\", result);\n            verifyFieldPositionIterator(attributes, iter);\n        }\n    }\n}\n\nvoid NumberFormatTest::Test11640_getAffixes() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols symbols(\"en_US\", status);\n    if (!assertSuccess(\"\", status)) {\n        return;\n    }\n    UnicodeString pattern(\"\\\\u00a4\\\\u00a4\\\\u00a4 0.00 %\\\\u00a4\\\\u00a4\");\n    pattern = pattern.unescape();\n    DecimalFormat fmt(pattern, symbols, status);\n    if (!assertSuccess(\"\", status)) {\n        return;\n    }\n    UnicodeString affixStr;\n    assertEquals(\"\", \"US dollars \", fmt.getPositivePrefix(affixStr));\n    assertEquals(\"\", \" %USD\", fmt.getPositiveSuffix(affixStr));\n    assertEquals(\"\", \"-US dollars \", fmt.getNegativePrefix(affixStr));\n    assertEquals(\"\", \" %USD\", fmt.getNegativeSuffix(affixStr));\n}\n\nvoid NumberFormatTest::Test11649_toPatternWithMultiCurrency() {\n    UnicodeString pattern(\"\\\\u00a4\\\\u00a4\\\\u00a4 0.00\");\n    pattern = pattern.unescape();\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat fmt(pattern, status);\n    if (!assertSuccess(\"\", status)) {\n        return;\n    }\n    static UChar USD[] = {0x55, 0x53, 0x44, 0x0};\n    fmt.setCurrency(USD);\n    UnicodeString appendTo;\n\n    assertEquals(\"\", \"US dollars 12.34\", fmt.format(12.34, appendTo));\n\n    UnicodeString topattern;\n    fmt.toPattern(topattern);\n    DecimalFormat fmt2(topattern, status);\n    if (!assertSuccess(\"\", status)) {\n        return;\n    }\n    fmt2.setCurrency(USD);\n\n    appendTo.remove();\n    assertEquals(\"\", \"US dollars 12.34\", fmt2.format(12.34, appendTo));\n}\n\nvoid NumberFormatTest::Test13327_numberingSystemBufferOverflow() {\n    UErrorCode status = U_ZERO_ERROR;\n    for (int runId = 0; runId < 2; runId++) {\n        // Construct a locale string with a very long \"numbers\" value.\n        // The first time, make the value length exactly equal to ULOC_KEYWORDS_CAPACITY.\n        // The second time, make it exceed ULOC_KEYWORDS_CAPACITY.\n        int extraLength = (runId == 0) ? 0 : 5;\n\n        CharString localeId(\"en@numbers=\", status);\n        for (int i = 0; i < ULOC_KEYWORDS_CAPACITY + extraLength; i++) {\n            localeId.append('x', status);\n        }\n        assertSuccess(\"Constructing locale string\", status);\n        Locale locale(localeId.data());\n\n        LocalPointer<NumberingSystem> ns(NumberingSystem::createInstance(locale, status));\n        assertFalse(\"Should not be null\", ns.getAlias() == nullptr);\n        assertSuccess(\"Should create with no error\", status);\n    }\n}\n\nvoid NumberFormatTest::Test13391_chakmaParsing() {\n    UErrorCode status = U_ZERO_ERROR;\n    LocalPointer<DecimalFormat> df(dynamic_cast<DecimalFormat*>(\n        NumberFormat::createInstance(Locale(\"ccp\"), status)));\n    if (df == nullptr) {\n        dataerrln(\"%s %d Chakma df is null\",  __FILE__, __LINE__);\n        return;\n    }\n    const UChar* expected = u\"\\U00011137\\U00011138,\\U00011139\\U0001113A\\U0001113B\";\n    UnicodeString actual;\n    df->format(12345, actual, status);\n    assertSuccess(\"Should not fail when formatting in ccp\", status);\n    assertEquals(\"Should produce expected output in ccp\", expected, actual);\n\n    Formattable result;\n    df->parse(expected, result, status);\n    assertSuccess(\"Should not fail when parsing in ccp\", status);\n    assertEquals(\"Should parse to 12345 in ccp\", 12345, result);\n\n    const UChar* expectedScientific = u\"\\U00011137.\\U00011139E\\U00011138\";\n    UnicodeString actualScientific;\n    df.adoptInstead(static_cast<DecimalFormat*>(\n        NumberFormat::createScientificInstance(Locale(\"ccp\"), status)));\n    df->format(130, actualScientific, status);\n    assertSuccess(\"Should not fail when formatting scientific in ccp\", status);\n    assertEquals(\"Should produce expected scientific output in ccp\",\n        expectedScientific, actualScientific);\n\n    Formattable resultScientific;\n    df->parse(expectedScientific, resultScientific, status);\n    assertSuccess(\"Should not fail when parsing scientific in ccp\", status);\n    assertEquals(\"Should parse scientific to 130 in ccp\", 130, resultScientific);\n}\n\n\nvoid NumberFormatTest::verifyFieldPositionIterator(\n        NumberFormatTest_Attributes *expected, FieldPositionIterator &iter) {\n    int32_t idx = 0;\n    FieldPosition fp;\n    while (iter.next(fp)) {\n        if (expected[idx].spos == -1) {\n            errln(\"Iterator should have ended. got %d\", fp.getField());\n            return;\n        }\n        assertEquals(\"id\", expected[idx].id, fp.getField());\n        assertEquals(\"start\", expected[idx].spos, fp.getBeginIndex());\n        assertEquals(\"end\", expected[idx].epos, fp.getEndIndex());\n        ++idx;\n    }\n    if (expected[idx].spos != -1) {\n        errln(\"Premature end of iterator. expected %d\", expected[idx].id);\n    }\n}\n\nvoid NumberFormatTest::Test11735_ExceptionIssue() {\n    IcuTestErrorCode status(*this, \"Test11735_ExceptionIssue\");\n    Locale enLocale(\"en\");\n    DecimalFormatSymbols symbols(enLocale, status);\n    if (status.isSuccess()) {\n        DecimalFormat fmt(\"0\", symbols, status);\n        assertSuccess(\"Fail: Construct DecimalFormat formatter\", status, true, __FILE__, __LINE__);\n        ParsePosition ppos(0);\n        fmt.parseCurrency(\"53.45\", ppos);  // NPE thrown here in ICU4J.\n        assertEquals(\"Issue11735 ppos\", 0, ppos.getIndex());\n    }\n}\n\nvoid NumberFormatTest::Test11035_FormatCurrencyAmount() {\n    UErrorCode status = U_ZERO_ERROR;\n    double amount = 12345.67;\n    const char16_t* expected = u\"12,345$67\u00a0\u200b\";\n\n    // Test two ways to set a currency via API\n\n    Locale loc1 = Locale(\"pt_PT\");\n    LocalPointer<NumberFormat> fmt1(NumberFormat::createCurrencyInstance(\"loc1\", status),\n                                    status);\n    if (U_FAILURE(status)) {\n      dataerrln(\"%s %d NumberFormat instance fmt1 is null\",  __FILE__, __LINE__);\n      return;\n    }\n    fmt1->setCurrency(u\"PTE\", status);\n    assertSuccess(\"Setting currency on fmt1\", status);\n    UnicodeString actualSetCurrency;\n    fmt1->format(amount, actualSetCurrency);\n\n    Locale loc2 = Locale(\"pt_PT@currency=PTE\");\n    LocalPointer<NumberFormat> fmt2(NumberFormat::createCurrencyInstance(loc2, status));\n    assertSuccess(\"Creating fmt2\", status);\n    UnicodeString actualLocaleString;\n    fmt2->format(amount, actualLocaleString);\n\n    // TODO: The following test will fail until DecimalFormat wraps NumberFormatter.\n    if (!logKnownIssue(\"13574\")) {\n        assertEquals(\"Custom Currency Pattern, Set Currency\", expected, actualSetCurrency);\n    }\n}\n\nvoid NumberFormatTest::Test11318_DoubleConversion() {\n    IcuTestErrorCode status(*this, \"Test11318_DoubleConversion\");\n    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(\"en\", status), status);\n    if (U_FAILURE(status)) {\n      dataerrln(\"%s %d Error in NumberFormat instance creation\",  __FILE__, __LINE__);\n      return;\n    }\n    nf->setMaximumFractionDigits(40);\n    nf->setMaximumIntegerDigits(40);\n    UnicodeString appendTo;\n    nf->format(999999999999999.9, appendTo);\n    assertEquals(\"Should render all digits\", u\"999,999,999,999,999.9\", appendTo);\n}\n\nvoid NumberFormatTest::TestParsePercentRegression() {\n    IcuTestErrorCode status(*this, \"TestParsePercentRegression\");\n    LocalPointer<DecimalFormat> df1((DecimalFormat*) NumberFormat::createInstance(\"en\", status), status);\n    LocalPointer<DecimalFormat> df2((DecimalFormat*) NumberFormat::createPercentInstance(\"en\", status), status);\n    if (status.isFailure()) {return; }\n    df1->setLenient(TRUE);\n    df2->setLenient(TRUE);\n\n    {\n        ParsePosition ppos;\n        Formattable result;\n        df1->parse(\"50%\", result, ppos);\n        assertEquals(\"df1 should accept a number but not the percent sign\", 2, ppos.getIndex());\n        assertEquals(\"df1 should return the number as 50\", 50.0, result.getDouble(status));\n    }\n    {\n        ParsePosition ppos;\n        Formattable result;\n        df2->parse(\"50%\", result, ppos);\n        assertEquals(\"df2 should accept the percent sign\", 3, ppos.getIndex());\n        assertEquals(\"df2 should return the number as 0.5\", 0.5, result.getDouble(status));\n    }\n    {\n        ParsePosition ppos;\n        Formattable result;\n        df2->parse(\"50\", result, ppos);\n        assertEquals(\"df2 should return the number as 0.5 even though the percent sign is missing\",\n                0.5,\n                result.getDouble(status));\n    }\n}\n\nvoid NumberFormatTest::TestMultiplierWithScale() {\n    IcuTestErrorCode status(*this, \"TestMultiplierWithScale\");\n\n    // Test magnitude combined with multiplier, as shown in API docs\n    DecimalFormat df(\"0\", {\"en\", status}, status);\n    if (status.isSuccess()) {\n        df.setMultiplier(5);\n        df.setMultiplierScale(-1);\n        expect2(df, 100, u\"50\"); // round-trip test\n    }\n}\n\nvoid NumberFormatTest::TestFastFormatInt32() {\n    IcuTestErrorCode status(*this, \"TestFastFormatInt32\");\n\n    // The two simplest formatters, old API and new API.\n    // Old API should use the fastpath for ints.\n    LocalizedNumberFormatter lnf = NumberFormatter::withLocale(\"en\");\n    LocalPointer<NumberFormat> df(NumberFormat::createInstance(\"en\", status), status);\n    if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) {return;}\n\n    double nums[] = {\n            0.0,\n            -0.0,\n            NAN,\n            INFINITY,\n            0.1,\n            1.0,\n            1.1,\n            2.0,\n            3.0,\n            9.0,\n            10.0,\n            99.0,\n            100.0,\n            999.0,\n            1000.0,\n            9999.0,\n            10000.0,\n            99999.0,\n            100000.0,\n            999999.0,\n            1000000.0,\n            static_cast<double>(INT32_MAX) - 1,\n            static_cast<double>(INT32_MAX),\n            static_cast<double>(INT32_MAX) + 1,\n            static_cast<double>(INT32_MIN) - 1,\n            static_cast<double>(INT32_MIN),\n            static_cast<double>(INT32_MIN) + 1};\n\n    for (auto num : nums) {\n        UnicodeString expected = lnf.formatDouble(num, status).toString();\n        UnicodeString actual;\n        df->format(num, actual);\n        assertEquals(UnicodeString(\"d = \") + num, expected, actual);\n    }\n}\n\nvoid NumberFormatTest::Test11646_Equality() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols symbols(Locale::getEnglish(), status);\n    UnicodeString pattern(u\"\\u00a4\\u00a4\\u00a4 0.00 %\\u00a4\\u00a4\");\n    DecimalFormat fmt(pattern, symbols, status);\n    if (!assertSuccess(\"\", status)) return;\n\n    // Test equality with affixes. set affix methods can't capture special\n    // characters which is why equality should fail.\n    {\n        DecimalFormat fmtCopy(fmt);\n        assertTrue(\"\", fmt == fmtCopy);\n        UnicodeString positivePrefix;\n        fmtCopy.setPositivePrefix(fmtCopy.getPositivePrefix(positivePrefix));\n        assertFalse(\"\", fmt == fmtCopy);\n    }\n    {\n        DecimalFormat fmtCopy = DecimalFormat(fmt);\n        assertTrue(\"\", fmt == fmtCopy);\n        UnicodeString positivePrefix;\n        fmtCopy.setPositiveSuffix(fmtCopy.getPositiveSuffix(positivePrefix));\n        assertFalse(\"\", fmt == fmtCopy);\n    }\n    {\n        DecimalFormat fmtCopy(fmt);\n        assertTrue(\"\", fmt == fmtCopy);\n        UnicodeString negativePrefix;\n        fmtCopy.setNegativePrefix(fmtCopy.getNegativePrefix(negativePrefix));\n        assertFalse(\"\", fmt == fmtCopy);\n    }\n    {\n        DecimalFormat fmtCopy(fmt);\n        assertTrue(\"\", fmt == fmtCopy);\n        UnicodeString negativePrefix;\n        fmtCopy.setNegativeSuffix(fmtCopy.getNegativeSuffix(negativePrefix));\n        assertFalse(\"\", fmt == fmtCopy);\n    }\n}\n\nvoid NumberFormatTest::TestParseNaN() {\n    IcuTestErrorCode status(*this, \"TestParseNaN\");\n\n    DecimalFormat df(\"0\", { \"en\", status }, status);\n    if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) { return; }\n    Formattable parseResult;\n    df.parse(u\"NaN\", parseResult, status);\n    assertEquals(\"NaN should parse successfully\", NAN, parseResult.getDouble());\n    assertFalse(\"Result NaN should be positive\", std::signbit(parseResult.getDouble()));\n    UnicodeString formatResult;\n    df.format(parseResult.getDouble(), formatResult);\n    assertEquals(\"NaN should round-trip\", u\"NaN\", formatResult);\n}\n\nvoid NumberFormatTest::Test11897_LocalizedPatternSeparator() {\n    IcuTestErrorCode status(*this, \"Test11897_LocalizedPatternSeparator\");\n\n    // In a locale with a different <list> symbol, like arabic,\n    // kPatternSeparatorSymbol should still be ';'\n    {\n        DecimalFormatSymbols dfs(\"ar\", status);\n        assertEquals(\"pattern separator symbol should be ;\",\n                u\";\",\n                dfs.getSymbol(DecimalFormatSymbols::kPatternSeparatorSymbol));\n    }\n\n    // However, the custom symbol should be used in localized notation\n    // when set manually via API\n    {\n        DecimalFormatSymbols dfs(\"en\", status);\n        dfs.setSymbol(DecimalFormatSymbols::kPatternSeparatorSymbol, u\"!\", FALSE);\n        DecimalFormat df(u\"0\", dfs, status);\n        if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) { return; }\n        df.applyPattern(\"a0;b0\", status); // should not throw\n        UnicodeString result;\n        assertEquals(\"should apply the normal pattern\",\n                df.getNegativePrefix(result.remove()),\n                \"b\");\n        df.applyLocalizedPattern(u\"c0!d0\", status); // should not throw\n        assertEquals(\"should apply the localized pattern\",\n                df.getNegativePrefix(result.remove()),\n                \"d\");\n    }\n}\n\nvoid NumberFormatTest::Test13055_PercentageRounding() {\n  IcuTestErrorCode status(*this, \"PercentageRounding\");\n  UnicodeString actual;\n  LocalPointer<NumberFormat>pFormat(NumberFormat::createPercentInstance(\"en_US\", status));\n  if (U_FAILURE(status)) {\n      dataerrln(\"Failure creating DecimalFormat %s\", u_errorName(status));\n      return;\n  }\n  pFormat->setMaximumFractionDigits(0);\n  pFormat->setRoundingMode(DecimalFormat::kRoundHalfEven);\n  pFormat->format(2.155, actual);\n  assertEquals(\"Should round percent toward even number\", \"216%\", actual);\n}\n  \nvoid NumberFormatTest::Test11839() {\n    IcuTestErrorCode errorCode(*this, \"Test11839\");\n    // Ticket #11839: DecimalFormat does not respect custom plus sign\n    LocalPointer<DecimalFormatSymbols> dfs(new DecimalFormatSymbols(Locale::getEnglish(), errorCode), errorCode);\n    if (!assertSuccess(\"\", errorCode, true, __FILE__, __LINE__)) { return; }\n    dfs->setSymbol(DecimalFormatSymbols::kMinusSignSymbol, u\"a\u2238\");\n    dfs->setSymbol(DecimalFormatSymbols::kPlusSignSymbol, u\"b\u2214\"); //  \u2214  U+2214 DOT PLUS\n    DecimalFormat df(u\"0.00+;0.00-\", dfs.orphan(), errorCode);\n    UnicodeString result;\n    df.format(-1.234, result, errorCode);\n    assertEquals(\"Locale-specific minus sign should be used\", u\"1.23a\u2238\", result);\n    df.format(1.234, result.remove(), errorCode);\n    assertEquals(\"Locale-specific plus sign should be used\", u\"1.23b\u2214\", result);\n    // Test round-trip with parse\n    expect2(df, -456, u\"456.00a\u2238\");\n    expect2(df, 456, u\"456.00b\u2214\");\n}\n\nvoid NumberFormatTest::Test10354() {\n    IcuTestErrorCode errorCode(*this, \"Test10354\");\n    // Ticket #10354: invalid FieldPositionIterator when formatting with empty NaN\n    DecimalFormatSymbols dfs(errorCode);\n    UnicodeString empty;\n    dfs.setSymbol(DecimalFormatSymbols::kNaNSymbol, empty);\n    DecimalFormat df(errorCode);\n    df.setDecimalFormatSymbols(dfs);\n    UnicodeString result;\n    FieldPositionIterator positions;\n    df.format(NAN, result, &positions, errorCode);\n    errorCode.errIfFailureAndReset(\"DecimalFormat.format(NAN, FieldPositionIterator) failed\");\n    FieldPosition fp;\n    while (positions.next(fp)) {\n        // Should not loop forever\n    }\n}\n\nvoid NumberFormatTest::Test11645_ApplyPatternEquality() {\n    IcuTestErrorCode status(*this, \"Test11645_ApplyPatternEquality\");\n    const char16_t* pattern = u\"#,##0.0#\";\n    LocalPointer<DecimalFormat> fmt((DecimalFormat*) NumberFormat::createInstance(status), status);\n    if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) { return; }\n    fmt->applyPattern(pattern, status);\n    LocalPointer<DecimalFormat> fmtCopy;\n\n    static const int32_t newMultiplier = 37;\n    fmtCopy.adoptInstead(new DecimalFormat(*fmt));\n    assertFalse(\"Value before setter\", fmtCopy->getMultiplier() == newMultiplier);\n    fmtCopy->setMultiplier(newMultiplier);\n    assertEquals(\"Value after setter\", fmtCopy->getMultiplier(), newMultiplier);\n    fmtCopy->applyPattern(pattern, status);\n    assertEquals(\"Value after applyPattern\", fmtCopy->getMultiplier(), newMultiplier);\n    assertFalse(\"multiplier\", *fmt == *fmtCopy);\n\n    static const NumberFormat::ERoundingMode newRoundingMode = NumberFormat::ERoundingMode::kRoundCeiling;\n    fmtCopy.adoptInstead(new DecimalFormat(*fmt));\n    assertFalse(\"Value before setter\", fmtCopy->getRoundingMode() == newRoundingMode);\n    fmtCopy->setRoundingMode(newRoundingMode);\n    assertEquals(\"Value after setter\", fmtCopy->getRoundingMode(), newRoundingMode);\n    fmtCopy->applyPattern(pattern, status);\n    assertEquals(\"Value after applyPattern\", fmtCopy->getRoundingMode(), newRoundingMode);\n    assertFalse(\"roundingMode\", *fmt == *fmtCopy);\n\n    static const char16_t *const newCurrency = u\"EAT\";\n    fmtCopy.adoptInstead(new DecimalFormat(*fmt));\n    assertFalse(\"Value before setter\", fmtCopy->getCurrency() == newCurrency);\n    fmtCopy->setCurrency(newCurrency);\n    assertEquals(\"Value after setter\", fmtCopy->getCurrency(), newCurrency);\n    fmtCopy->applyPattern(pattern, status);\n    assertEquals(\"Value after applyPattern\", fmtCopy->getCurrency(), newCurrency);\n    assertFalse(\"currency\", *fmt == *fmtCopy);\n\n    static const UCurrencyUsage newCurrencyUsage = UCurrencyUsage::UCURR_USAGE_CASH;\n    fmtCopy.adoptInstead(new DecimalFormat(*fmt));\n    assertFalse(\"Value before setter\", fmtCopy->getCurrencyUsage() == newCurrencyUsage);\n    fmtCopy->setCurrencyUsage(newCurrencyUsage, status);\n    assertEquals(\"Value after setter\", fmtCopy->getCurrencyUsage(), newCurrencyUsage);\n    fmtCopy->applyPattern(pattern, status);\n    assertEquals(\"Value after applyPattern\", fmtCopy->getCurrencyUsage(), newCurrencyUsage);\n    assertFalse(\"currencyUsage\", *fmt == *fmtCopy);\n}\n\nvoid NumberFormatTest::Test12567() {\n    IcuTestErrorCode errorCode(*this, \"Test12567\");\n    // Ticket #12567: DecimalFormat.equals() may not be symmetric\n    LocalPointer<DecimalFormat> df1((DecimalFormat *)\n        NumberFormat::createInstance(Locale::getUS(), UNUM_CURRENCY, errorCode));\n    LocalPointer<DecimalFormat> df2((DecimalFormat *)\n        NumberFormat::createInstance(Locale::getUS(), UNUM_DECIMAL, errorCode));\n    if (!assertSuccess(\"\", errorCode, true, __FILE__, __LINE__)) { return; }\n    // NOTE: CurrencyPluralInfo equality not tested in C++ because its operator== is not defined.\n    df1->applyPattern(u\"0.00\", errorCode);\n    df2->applyPattern(u\"0.00\", errorCode);\n    assertTrue(\"df1 == df2\", *df1 == *df2);\n    assertTrue(\"df2 == df1\", *df2 == *df1);\n    df2->setPositivePrefix(u\"abc\");\n    assertTrue(\"df1 != df2\", *df1 != *df2);\n    assertTrue(\"df2 != df1\", *df2 != *df1);\n}\n\nvoid NumberFormatTest::Test11626_CustomizeCurrencyPluralInfo() {\n    IcuTestErrorCode errorCode(*this, \"Test11626_CustomizeCurrencyPluralInfo\");\n    // Ticket #11626: No unit test demonstrating how to use CurrencyPluralInfo to\n    // change formatting spelled out currencies\n    // Use locale sr because it has interesting plural rules.\n    Locale locale(\"sr\");\n    LocalPointer<DecimalFormatSymbols> symbols(new DecimalFormatSymbols(locale, errorCode), errorCode);\n    CurrencyPluralInfo info(locale, errorCode);\n    if (!assertSuccess(\"\", errorCode, true, __FILE__, __LINE__)) { return; }\n    info.setCurrencyPluralPattern(u\"one\", u\"0 qwerty\", errorCode);\n    info.setCurrencyPluralPattern(u\"few\", u\"0 dvorak\", errorCode);\n    DecimalFormat df(u\"#\", symbols.orphan(), UNUM_CURRENCY_PLURAL, errorCode);\n    df.setCurrencyPluralInfo(info);\n    df.setCurrency(u\"USD\");\n    df.setMaximumFractionDigits(0);\n\n    UnicodeString result;\n    assertEquals(\"Plural one\", u\"1 qwerty\", df.format(1, result, errorCode));\n    assertEquals(\"Plural few\", u\"3 dvorak\", df.format(3, result.remove(), errorCode));\n    assertEquals(\"Plural other\", u\"99 \u0430\u043c\u0435\u0440\u0438\u0447\u043a\u0438\u0445 \u0434\u043e\u043b\u0430\u0440\u0430\", df.format(99, result.remove(), errorCode));\n\n    info.setPluralRules(u\"few: n is 1; one: n in 2..4\", errorCode);\n    df.setCurrencyPluralInfo(info);\n    assertEquals(\"Plural one\", u\"1 dvorak\", df.format(1, result.remove(), errorCode));\n    assertEquals(\"Plural few\", u\"3 qwerty\", df.format(3, result.remove(), errorCode));\n    assertEquals(\"Plural other\", u\"99 \u0430\u043c\u0435\u0440\u0438\u0447\u043a\u0438\u0445 \u0434\u043e\u043b\u0430\u0440\u0430\", df.format(99, result.remove(), errorCode));\n}\n\nvoid NumberFormatTest::Test20073_StrictPercentParseErrorIndex() {\n    IcuTestErrorCode status(*this, \"Test20073_StrictPercentParseErrorIndex\");\n    ParsePosition parsePosition(0);\n    DecimalFormat df(u\"0%\", {\"en-us\", status}, status);\n    if (U_FAILURE(status)) {\n        dataerrln(\"Unable to create DecimalFormat instance.\");\n        return;\n    }\n    df.setLenient(FALSE);\n    Formattable result;\n    df.parse(u\"%2%\", result, parsePosition);\n    assertEquals(\"\", 0, parsePosition.getIndex());\n    assertEquals(\"\", 0, parsePosition.getErrorIndex());\n}\n\nvoid NumberFormatTest::Test13056_GroupingSize() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat df(u\"#,##0\", status);\n    if (!assertSuccess(\"\", status)) return;\n    assertEquals(\"Primary grouping should return 3\", 3, df.getGroupingSize());\n    assertEquals(\"Secondary grouping should return 0\", 0, df.getSecondaryGroupingSize());\n    df.setSecondaryGroupingSize(3);\n    assertEquals(\"Primary grouping should still return 3\", 3, df.getGroupingSize());\n    assertEquals(\"Secondary grouping should round-trip\", 3, df.getSecondaryGroupingSize());\n    df.setGroupingSize(4);\n    assertEquals(\"Primary grouping should return 4\", 4, df.getGroupingSize());\n    assertEquals(\"Secondary should remember explicit setting and return 3\", 3, df.getSecondaryGroupingSize());\n}\n\n\nvoid NumberFormatTest::Test11025_CurrencyPadding() {\n    UErrorCode status = U_ZERO_ERROR;\n    UnicodeString pattern(u\"\u00a4\u00a4 **####0.00\");\n    DecimalFormatSymbols sym(Locale::getFrance(), status);\n    if (!assertSuccess(\"\", status)) return;\n    DecimalFormat fmt(pattern, sym, status);\n    if (!assertSuccess(\"\", status)) return;\n    UnicodeString result;\n    fmt.format(433.0, result);\n    assertEquals(\"Number should be padded to 11 characters\", \"EUR *433,00\", result);\n}\n\nvoid NumberFormatTest::Test11648_ExpDecFormatMalPattern() {\n    UErrorCode status = U_ZERO_ERROR;\n\n    DecimalFormat fmt(\"0.00\", {\"en\", status}, status);\n    if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) { return; }\n    fmt.setScientificNotation(TRUE);\n    UnicodeString pattern;\n\n    assertEquals(\"A valid scientific notation pattern should be produced\",\n            \"0.00E0\",\n            fmt.toPattern(pattern));\n\n    DecimalFormat fmt2(pattern, status);\n    assertSuccess(\"\", status);\n}\n\nvoid NumberFormatTest::Test11649_DecFmtCurrencies() {\n    IcuTestErrorCode status(*this, \"Test11649_DecFmtCurrencies\");\n    UnicodeString pattern(\"\\\\u00a4\\\\u00a4\\\\u00a4 0.00\");\n    pattern = pattern.unescape();\n    DecimalFormat fmt(pattern, status);\n    if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) { return; }\n    static const UChar USD[] = u\"USD\";\n    fmt.setCurrency(USD);\n    UnicodeString appendTo;\n\n    assertEquals(\"\", \"US dollars 12.34\", fmt.format(12.34, appendTo));\n    UnicodeString topattern;\n\n    assertEquals(\"\", pattern, fmt.toPattern(topattern));\n    DecimalFormat fmt2(topattern, status);\n    fmt2.setCurrency(USD);\n\n    appendTo.remove();\n    assertEquals(\"\", \"US dollars 12.34\", fmt2.format(12.34, appendTo));\n}\n\nvoid NumberFormatTest::Test13148_ParseGroupingSeparators() {\n  IcuTestErrorCode status(*this, \"Test13148\");\n  LocalPointer<DecimalFormat> fmt(\n      (DecimalFormat*)NumberFormat::createInstance(\"en-ZA\", status), status);\n  if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) { return; }\n\n  DecimalFormatSymbols symbols = *fmt->getDecimalFormatSymbols();\n\n  symbols.setSymbol(DecimalFormatSymbols::kDecimalSeparatorSymbol, u'.');\n  symbols.setSymbol(DecimalFormatSymbols::kGroupingSeparatorSymbol, u',');\n  fmt->setDecimalFormatSymbols(symbols);\n  Formattable number;\n  fmt->parse(u\"300,000\", number, status);\n  assertEquals(\"Should parse as 300000\", 300000LL, number.getInt64(status));\n}\n\nvoid NumberFormatTest::Test12753_PatternDecimalPoint() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols symbols(Locale::getUS(), status);\n    symbols.setSymbol(DecimalFormatSymbols::kDecimalSeparatorSymbol, u\"*\", false);\n    DecimalFormat df(u\"0.00\", symbols, status);\n    if (!assertSuccess(\"\", status)) return;\n    df.setDecimalPatternMatchRequired(true);\n    Formattable result;\n    df.parse(u\"123\",result, status);\n    assertEquals(\"Parsing integer succeeded even though setDecimalPatternMatchRequired was set\",\n                 U_INVALID_FORMAT_ERROR, status);\n    }\n\n void NumberFormatTest::Test11647_PatternCurrencySymbols() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormat df(status);\n    df.applyPattern(u\"\u00a4\u00a4\u00a4\u00a4#\", status);\n    if (!assertSuccess(\"\", status)) return;\n    UnicodeString actual;\n    df.format(123, actual);\n    assertEquals(\"Should replace 4 currency signs with U+FFFD\", u\"\\uFFFD123\", actual);\n}\n\nvoid NumberFormatTest::Test11913_BigDecimal() {\n    UErrorCode status = U_ZERO_ERROR;\n    LocalPointer<NumberFormat> df(NumberFormat::createInstance(Locale::getEnglish(), status), status);\n    if (!assertSuccess(\"\", status)) return;\n    UnicodeString result;\n    df->format(StringPiece(\"1.23456789E400\"), result, nullptr, status);\n    assertSuccess(\"\", status);\n    assertEquals(\"Should format more than 309 digits\", u\"12,345,678\", UnicodeString(result, 0, 10));\n    assertEquals(\"Should format more than 309 digits\", 534, result.length());\n}\n\nvoid NumberFormatTest::Test11020_RoundingInScientificNotation() {\n    UErrorCode status = U_ZERO_ERROR;\n    DecimalFormatSymbols sym(Locale::getFrance(), status);\n    DecimalFormat fmt(u\"0.05E0\", sym, status);\n    if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) { return; }\n    assertSuccess(\"\", status);\n    UnicodeString result;\n    fmt.format(12301.2, result);\n    assertEquals(\"Rounding increment should be applied after magnitude scaling\", u\"1,25E4\", result);\n}\n\nvoid NumberFormatTest::Test11640_TripleCurrencySymbol() {\n    IcuTestErrorCode status(*this, \"Test11640_TripleCurrencySymbol\");\n    UnicodeString actual;\n    DecimalFormat dFormat(u\"\u00a4\u00a4\u00a4 0\", status);\n    if (U_FAILURE(status)) {\n        dataerrln(\"Failure creating DecimalFormat %s\", u_errorName(status));\n        return;\n    }\n    dFormat.setCurrency(u\"USD\");\n    UnicodeString result;\n    dFormat.getPositivePrefix(result);\n    assertEquals(\"Triple-currency should give long name on getPositivePrefix\",\n                \"US dollars \", result);\n}\n\n\nvoid NumberFormatTest::Test13763_FieldPositionIteratorOffset() {\n    IcuTestErrorCode status(*this, \"Test13763_FieldPositionIteratorOffset\");\n    FieldPositionIterator fpi;\n    UnicodeString result(u\"foo\\U0001F4FBbar\"); // 8 code units\n    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(\"en\", status), status);\n    if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) { return; }\n    nf->format(5142.3, result, &fpi, status);\n\n    int32_t expected[] = {\n      UNUM_GROUPING_SEPARATOR_FIELD, 9, 10,\n      UNUM_INTEGER_FIELD, 8, 13,\n      UNUM_DECIMAL_SEPARATOR_FIELD, 13, 14,\n      UNUM_FRACTION_FIELD, 14, 15,\n    };\n    int32_t tupleCount = UPRV_LENGTHOF(expected)/3;\n    expectPositions(fpi, expected, tupleCount, result);\n}\n\nvoid NumberFormatTest::Test13777_ParseLongNameNonCurrencyMode() {\n    IcuTestErrorCode status(*this, \"Test13777_ParseLongNameNonCurrencyMode\");\n\n    LocalPointer<NumberFormat> df(\n        NumberFormat::createInstance(\"en-us\", UNumberFormatStyle::UNUM_CURRENCY_PLURAL, status), status);\n    if (!assertSuccess(\"\", status, true, __FILE__, __LINE__)) { return; }\n    expect2(*df, 1.5, u\"1.50 US dollars\");\n}\n\nvoid NumberFormatTest::Test13804_EmptyStringsWhenParsing() {\n    IcuTestErrorCode status(*this, \"Test13804_EmptyStringsWhenParsing\");\n\n    DecimalFormatSymbols dfs(\"en\", status);\n    if (status.errIfFailureAndReset()) {\n        return;\n    }\n    dfs.setSymbol(DecimalFormatSymbols::kCurrencySymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kDecimalSeparatorSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kZeroDigitSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kOneDigitSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kTwoDigitSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kThreeDigitSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kFourDigitSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kFiveDigitSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kSixDigitSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kSevenDigitSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kEightDigitSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kNineDigitSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kExponentMultiplicationSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kExponentialSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kGroupingSeparatorSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kInfinitySymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kIntlCurrencySymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kMinusSignSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kMonetarySeparatorSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kMonetaryGroupingSeparatorSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kNaNSymbol, u\"\", FALSE);\n    dfs.setPatternForCurrencySpacing(UNUM_CURRENCY_INSERT, FALSE, u\"\");\n    dfs.setPatternForCurrencySpacing(UNUM_CURRENCY_INSERT, TRUE, u\"\");\n    dfs.setSymbol(DecimalFormatSymbols::kPercentSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kPerMillSymbol, u\"\", FALSE);\n    dfs.setSymbol(DecimalFormatSymbols::kPlusSignSymbol, u\"\", FALSE);\n\n    DecimalFormat df(\"0\", dfs, status);\n    if (status.errIfFailureAndReset()) {\n        return;\n    }\n    df.setGroupingUsed(TRUE);\n    df.setScientificNotation(TRUE);\n    df.setLenient(TRUE); // enable all matchers\n    {\n        UnicodeString result;\n        df.format(0, result); // should not crash or hit infinite loop\n    }\n    const char16_t* samples[] = {\n            u\"\",\n            u\"123\",\n            u\"$123\",\n            u\"-\",\n            u\"+\",\n            u\"44%\",\n            u\"1E+2.3\"\n    };\n    for (auto& sample : samples) {\n        logln(UnicodeString(u\"Attempting parse on: \") + sample);\n        status.setScope(sample);\n        // We don't care about the results, only that we don't crash and don't loop.\n        Formattable result;\n        ParsePosition ppos(0);\n        df.parse(sample, result, ppos);\n        ppos = ParsePosition(0);\n        LocalPointer<CurrencyAmount> curramt(df.parseCurrency(sample, ppos));\n        status.errIfFailureAndReset();\n    }\n\n    // Test with a nonempty exponent separator symbol to cover more code\n    dfs.setSymbol(DecimalFormatSymbols::kExponentialSymbol, u\"E\", FALSE);\n    df.setDecimalFormatSymbols(dfs);\n    {\n        Formattable result;\n        ParsePosition ppos(0);\n        df.parse(u\"1E+2.3\", result, ppos);\n    }\n}\n\nvoid NumberFormatTest::Test20037_ScientificIntegerOverflow() {\n    IcuTestErrorCode status(*this, \"Test20037_ScientificIntegerOverflow\");\n\n    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));\n    if (U_FAILURE(status)) {\n        dataerrln(\"Unable to create NumberFormat instance.\");\n        return;\n    }\n    Formattable result;\n\n    // Test overflow of exponent\n    nf->parse(u\"1E-2147483648\", result, status);\n    StringPiece sp = result.getDecimalNumber(status);\n    assertEquals(u\"Should snap to zero\",\n                 u\"0\",\n                 {sp.data(), sp.length(), US_INV});\n\n    // Test edge case overflow of exponent\n    result = Formattable();\n    nf->parse(u\"1E-2147483647E-1\", result, status);\n    sp = result.getDecimalNumber(status);\n    assertEquals(u\"Should not overflow and should parse only the first exponent\",\n                 u\"1E-2147483647\",\n                 {sp.data(), sp.length(), US_INV});\n\n    // Test edge case overflow of exponent\n    result = Formattable();\n    nf->parse(u\".0003e-2147483644\", result, status);\n    sp = result.getDecimalNumber(status);\n    assertEquals(u\"Should not overflow\",\n                 u\"3E-2147483648\",\n                 {sp.data(), sp.length(), US_INV});\n}\n\nvoid NumberFormatTest::Test13840_ParseLongStringCrash() {\n    IcuTestErrorCode status(*this, \"Test13840_ParseLongStringCrash\");\n\n    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(\"en\", status), status);\n    if (status.errIfFailureAndReset()) { return; }\n\n    Formattable result;\n    static const char16_t* bigString =\n        u\"111111111111111111111111111111111111111111111111111111111111111111111\"\n        u\"111111111111111111111111111111111111111111111111111111111111111111111\"\n        u\"111111111111111111111111111111111111111111111111111111111111111111111\"\n        u\"111111111111111111111111111111111111111111111111111111111111111111111\"\n        u\"111111111111111111111111111111111111111111111111111111111111111111111\"\n        u\"111111111111111111111111111111111111111111111111111111111111111111111\";\n    nf->parse(bigString, result, status);\n\n    // Normalize the input string:\n    CharString expectedChars;\n    expectedChars.appendInvariantChars(bigString, status);\n    DecimalQuantity expectedDQ;\n    expectedDQ.setToDecNumber(expectedChars.toStringPiece(), status);\n    UnicodeString expectedUString = expectedDQ.toScientificString();\n\n    // Get the output string:\n    StringPiece actualChars = result.getDecimalNumber(status);\n    UnicodeString actualUString = UnicodeString(actualChars.data(), actualChars.length(), US_INV);\n\n    assertEquals(\"Should round-trip without crashing\", expectedUString, actualUString);\n}\n\nvoid NumberFormatTest::Test13850_EmptyStringCurrency() {\n    IcuTestErrorCode status(*this, \"Test13840_EmptyStringCurrency\");\n\n    struct TestCase {\n        const char16_t* currencyArg;\n        UErrorCode expectedError;\n    } cases[] = {\n        {u\"\", U_ZERO_ERROR},\n        {u\"U\", U_ILLEGAL_ARGUMENT_ERROR},\n        {u\"Us\", U_ILLEGAL_ARGUMENT_ERROR},\n        {nullptr, U_ZERO_ERROR},\n        {u\"U$D\", U_INVARIANT_CONVERSION_ERROR},\n        {u\"Xxx\", U_ZERO_ERROR}\n    };\n    for (const auto& cas : cases) {\n        UnicodeString message(u\"with currency arg: \");\n        if (cas.currencyArg == nullptr) {\n            message += u\"nullptr\";\n        } else {\n            message += UnicodeString(cas.currencyArg);\n        }\n        status.setScope(message);\n        LocalPointer<NumberFormat> nf(NumberFormat::createCurrencyInstance(\"en-US\", status), status);\n        if (status.errIfFailureAndReset()) { return; }\n        UnicodeString actual;\n        nf->format(1, actual, status);\n        status.errIfFailureAndReset();\n        assertEquals(u\"Should format with US currency \" + message, u\"$1.00\", actual);\n        nf->setCurrency(cas.currencyArg, status);\n        if (status.expectErrorAndReset(cas.expectedError)) {\n            // If an error occurred, do not check formatting.\n            continue;\n        }\n        nf->format(1, actual.remove(), status);\n        assertEquals(u\"Should unset the currency \" + message, u\"\\u00A41.00\", actual);\n        status.errIfFailureAndReset();\n    }\n}\n\n#endif /* #if !UCONFIG_NO_FORMATTING */\n", "// \u00a9 2017 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html#License\npackage com.ibm.icu.impl.number;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.math.MathContext;\nimport java.text.FieldPosition;\n\nimport com.ibm.icu.impl.StandardPlural;\nimport com.ibm.icu.impl.Utility;\nimport com.ibm.icu.text.PluralRules;\nimport com.ibm.icu.text.PluralRules.Operand;\nimport com.ibm.icu.text.UFieldPosition;\n\n/**\n * Represents numbers and digit display properties using Binary Coded Decimal (BCD).\n *\n * @implements {@link DecimalQuantity}\n */\npublic abstract class DecimalQuantity_AbstractBCD implements DecimalQuantity {\n\n    /**\n     * The power of ten corresponding to the least significant digit in the BCD. For example, if this\n     * object represents the number \"3.14\", the BCD will be \"0x314\" and the scale will be -2.\n     *\n     * <p>\n     * Note that in {@link java.math.BigDecimal}, the scale is defined differently: the number of digits\n     * after the decimal place, which is the negative of our definition of scale.\n     */\n    protected int scale;\n\n    /**\n     * The number of digits in the BCD. For example, \"1007\" has BCD \"0x1007\" and precision 4. A long\n     * cannot represent precisions greater than 16.\n     *\n     * <p>\n     * This value must be re-calculated whenever the value in bcd changes by using\n     * {@link #computePrecisionAndCompact()}.\n     */\n    protected int precision;\n\n    /**\n     * A bitmask of properties relating to the number represented by this object.\n     *\n     * @see #NEGATIVE_FLAG\n     * @see #INFINITY_FLAG\n     * @see #NAN_FLAG\n     */\n    protected byte flags;\n\n    protected static final int NEGATIVE_FLAG = 1;\n    protected static final int INFINITY_FLAG = 2;\n    protected static final int NAN_FLAG = 4;\n\n    // The following three fields relate to the double-to-ascii fast path algorithm.\n    // When a double is given to DecimalQuantityBCD, it is converted to using a fast algorithm. The\n    // fast algorithm guarantees correctness to only the first ~12 digits of the double. The process\n    // of rounding the number ensures that the converted digits are correct, falling back to a slow-\n    // path algorithm if required. Therefore, if a DecimalQuantity is constructed from a double, it\n    // is *required* that roundToMagnitude(), roundToIncrement(), or roundToInfinity() is called. If\n    // you don't round, assertions will fail in certain other methods if you try calling them.\n\n    /**\n     * The original number provided by the user and which is represented in BCD. Used when we need to\n     * re-compute the BCD for an exact double representation.\n     */\n    protected double origDouble;\n\n    /**\n     * The change in magnitude relative to the original double. Used when we need to re-compute the BCD\n     * for an exact double representation.\n     */\n    protected int origDelta;\n\n    /**\n     * Whether the value in the BCD comes from the double fast path without having been rounded to ensure\n     * correctness\n     */\n    protected boolean isApproximate;\n\n    // Four positions: left optional '(', left required '[', right required ']', right optional ')'.\n    // These four positions determine which digits are displayed in the output string. They do NOT\n    // affect rounding. These positions are internal-only and can be specified only by the public\n    // endpoints like setFractionLength, setIntegerLength, and setSignificantDigits, among others.\n    //\n    // * Digits between lReqPos and rReqPos are in the \"required zone\" and are always displayed.\n    // * Digits between lOptPos and rOptPos but outside the required zone are in the \"optional zone\"\n    // and are displayed unless they are trailing off the left or right edge of the number and\n    // have a numerical value of zero. In order to be \"trailing\", the digits need to be beyond\n    // the decimal point in their respective directions.\n    // * Digits outside of the \"optional zone\" are never displayed.\n    //\n    // See the table below for illustrative examples.\n    //\n    // +---------+---------+---------+---------+------------+------------------------+--------------+\n    // | lOptPos | lReqPos | rReqPos | rOptPos |   number   |        positions       | en-US string |\n    // +---------+---------+---------+---------+------------+------------------------+--------------+\n    // |    5    |    2    |   -1    |   -5    |   1234.567 |     ( 12[34.5]67  )    |   1,234.567  |\n    // |    3    |    2    |   -1    |   -5    |   1234.567 |      1(2[34.5]67  )    |     234.567  |\n    // |    3    |    2    |   -1    |   -2    |   1234.567 |      1(2[34.5]6)7      |     234.56   |\n    // |    6    |    4    |    2    |   -5    | 123456789. |  123(45[67]89.     )   | 456,789.     |\n    // |    6    |    4    |    2    |    1    | 123456789. |     123(45[67]8)9.     | 456,780.     |\n    // |   -1    |   -1    |   -3    |   -4    | 0.123456   |     0.1([23]4)56       |        .0234 |\n    // |    6    |    4    |   -2    |   -2    |     12.3   |     (  [  12.3 ])      |    0012.30   |\n    // +---------+---------+---------+---------+------------+------------------------+--------------+\n    //\n    protected int lOptPos = Integer.MAX_VALUE;\n    protected int lReqPos = 0;\n    protected int rReqPos = 0;\n    protected int rOptPos = Integer.MIN_VALUE;\n\n    @Override\n    public void copyFrom(DecimalQuantity _other) {\n        copyBcdFrom(_other);\n        DecimalQuantity_AbstractBCD other = (DecimalQuantity_AbstractBCD) _other;\n        lOptPos = other.lOptPos;\n        lReqPos = other.lReqPos;\n        rReqPos = other.rReqPos;\n        rOptPos = other.rOptPos;\n        scale = other.scale;\n        precision = other.precision;\n        flags = other.flags;\n        origDouble = other.origDouble;\n        origDelta = other.origDelta;\n        isApproximate = other.isApproximate;\n    }\n\n    public DecimalQuantity_AbstractBCD clear() {\n        lOptPos = Integer.MAX_VALUE;\n        lReqPos = 0;\n        rReqPos = 0;\n        rOptPos = Integer.MIN_VALUE;\n        flags = 0;\n        setBcdToZero(); // sets scale, precision, hasDouble, origDouble, origDelta, and BCD data\n        return this;\n    }\n\n    @Override\n    public void setIntegerLength(int minInt, int maxInt) {\n        // Validation should happen outside of DecimalQuantity, e.g., in the Rounder class.\n        assert minInt >= 0;\n        assert maxInt >= minInt;\n\n        // Special behavior: do not set minInt to be less than what is already set.\n        // This is so significant digits rounding can set the integer length.\n        if (minInt < lReqPos) {\n            minInt = lReqPos;\n        }\n\n        // Save values into internal state\n        // Negation is safe for minFrac/maxFrac because -Integer.MAX_VALUE > Integer.MIN_VALUE\n        lOptPos = maxInt;\n        lReqPos = minInt;\n    }\n\n    @Override\n    public void setFractionLength(int minFrac, int maxFrac) {\n        // Validation should happen outside of DecimalQuantity, e.g., in the Rounder class.\n        assert minFrac >= 0;\n        assert maxFrac >= minFrac;\n\n        // Save values into internal state\n        // Negation is safe for minFrac/maxFrac because -Integer.MAX_VALUE > Integer.MIN_VALUE\n        rReqPos = -minFrac;\n        rOptPos = -maxFrac;\n    }\n\n    @Override\n    public long getPositionFingerprint() {\n        long fingerprint = 0;\n        fingerprint ^= lOptPos;\n        fingerprint ^= (lReqPos << 16);\n        fingerprint ^= ((long) rReqPos << 32);\n        fingerprint ^= ((long) rOptPos << 48);\n        return fingerprint;\n    }\n\n    @Override\n    public void roundToIncrement(BigDecimal roundingIncrement, MathContext mathContext) {\n        // TODO(13701): Avoid this check on every call to roundToIncrement().\n        BigDecimal stripped = roundingIncrement.stripTrailingZeros();\n        if (stripped.unscaledValue().compareTo(BigInteger.valueOf(5)) == 0) {\n            roundToNickel(-stripped.scale(), mathContext);\n            return;\n        }\n        BigDecimal temp = toBigDecimal();\n        temp = temp.divide(roundingIncrement, 0, mathContext.getRoundingMode())\n                .multiply(roundingIncrement).round(mathContext);\n        if (temp.signum() == 0) {\n            setBcdToZero(); // keeps negative flag for -0.0\n        } else {\n            setToBigDecimal(temp);\n        }\n    }\n\n    @Override\n    public void multiplyBy(BigDecimal multiplicand) {\n        if (isInfinite() || isZero() || isNaN()) {\n            return;\n        }\n        BigDecimal temp = toBigDecimal();\n        temp = temp.multiply(multiplicand);\n        setToBigDecimal(temp);\n    }\n\n    @Override\n    public void negate() {\n      flags ^= NEGATIVE_FLAG;\n    }\n\n    @Override\n    public int getMagnitude() throws ArithmeticException {\n        if (precision == 0) {\n            throw new ArithmeticException(\"Magnitude is not well-defined for zero\");\n        } else {\n            return scale + precision - 1;\n        }\n    }\n\n    @Override\n    public void adjustMagnitude(int delta) {\n        if (precision != 0) {\n            scale = Utility.addExact(scale, delta);\n            origDelta = Utility.addExact(origDelta, delta);\n        }\n    }\n\n    @Override\n    public StandardPlural getStandardPlural(PluralRules rules) {\n        if (rules == null) {\n            // Fail gracefully if the user didn't provide a PluralRules\n            return StandardPlural.OTHER;\n        } else {\n            @SuppressWarnings(\"deprecation\")\n            String ruleString = rules.select(this);\n            return StandardPlural.orOtherFromString(ruleString);\n        }\n    }\n\n    @Override\n    public double getPluralOperand(Operand operand) {\n        // If this assertion fails, you need to call roundToInfinity() or some other rounding method.\n        // See the comment at the top of this file explaining the \"isApproximate\" field.\n        assert !isApproximate;\n\n        switch (operand) {\n        case i:\n            // Invert the negative sign if necessary\n            return isNegative() ? -toLong(true) : toLong(true);\n        case f:\n            return toFractionLong(true);\n        case t:\n            return toFractionLong(false);\n        case v:\n            return fractionCount();\n        case w:\n            return fractionCountWithoutTrailingZeros();\n        default:\n            return Math.abs(toDouble());\n        }\n    }\n\n    @Override\n    public void populateUFieldPosition(FieldPosition fp) {\n        if (fp instanceof UFieldPosition) {\n            ((UFieldPosition) fp).setFractionDigits((int) getPluralOperand(Operand.v),\n                    (long) getPluralOperand(Operand.f));\n        }\n    }\n\n    @Override\n    public int getUpperDisplayMagnitude() {\n        // If this assertion fails, you need to call roundToInfinity() or some other rounding method.\n        // See the comment at the top of this file explaining the \"isApproximate\" field.\n        assert !isApproximate;\n\n        int magnitude = scale + precision;\n        int result = (lReqPos > magnitude) ? lReqPos : (lOptPos < magnitude) ? lOptPos : magnitude;\n        return result - 1;\n    }\n\n    @Override\n    public int getLowerDisplayMagnitude() {\n        // If this assertion fails, you need to call roundToInfinity() or some other rounding method.\n        // See the comment at the top of this file explaining the \"isApproximate\" field.\n        assert !isApproximate;\n\n        int magnitude = scale;\n        int result = (rReqPos < magnitude) ? rReqPos : (rOptPos > magnitude) ? rOptPos : magnitude;\n        return result;\n    }\n\n    @Override\n    public byte getDigit(int magnitude) {\n        // If this assertion fails, you need to call roundToInfinity() or some other rounding method.\n        // See the comment at the top of this file explaining the \"isApproximate\" field.\n        assert !isApproximate;\n\n        return getDigitPos(magnitude - scale);\n    }\n\n    private int fractionCount() {\n        return -getLowerDisplayMagnitude();\n    }\n\n    private int fractionCountWithoutTrailingZeros() {\n        return Math.max(-scale, 0);\n    }\n\n    @Override\n    public boolean isNegative() {\n        return (flags & NEGATIVE_FLAG) != 0;\n    }\n\n    @Override\n    public int signum() {\n        return isNegative() ? -1 : isZero() ? 0 : 1;\n    }\n\n    @Override\n    public boolean isInfinite() {\n        return (flags & INFINITY_FLAG) != 0;\n    }\n\n    @Override\n    public boolean isNaN() {\n        return (flags & NAN_FLAG) != 0;\n    }\n\n    @Override\n    public boolean isZero() {\n        return precision == 0;\n    }\n\n    public void setToInt(int n) {\n        setBcdToZero();\n        flags = 0;\n        if (n < 0) {\n            flags |= NEGATIVE_FLAG;\n            n = -n;\n        }\n        if (n != 0) {\n            _setToInt(n);\n            compact();\n        }\n    }\n\n    private void _setToInt(int n) {\n        if (n == Integer.MIN_VALUE) {\n            readLongToBcd(-(long) n);\n        } else {\n            readIntToBcd(n);\n        }\n    }\n\n    public void setToLong(long n) {\n        setBcdToZero();\n        flags = 0;\n        if (n < 0) {\n            flags |= NEGATIVE_FLAG;\n            n = -n;\n        }\n        if (n != 0) {\n            _setToLong(n);\n            compact();\n        }\n    }\n\n    private void _setToLong(long n) {\n        if (n == Long.MIN_VALUE) {\n            readBigIntegerToBcd(BigInteger.valueOf(n).negate());\n        } else if (n <= Integer.MAX_VALUE) {\n            readIntToBcd((int) n);\n        } else {\n            readLongToBcd(n);\n        }\n    }\n\n    public void setToBigInteger(BigInteger n) {\n        setBcdToZero();\n        flags = 0;\n        if (n.signum() == -1) {\n            flags |= NEGATIVE_FLAG;\n            n = n.negate();\n        }\n        if (n.signum() != 0) {\n            _setToBigInteger(n);\n            compact();\n        }\n    }\n\n    private void _setToBigInteger(BigInteger n) {\n        if (n.bitLength() < 32) {\n            readIntToBcd(n.intValue());\n        } else if (n.bitLength() < 64) {\n            readLongToBcd(n.longValue());\n        } else {\n            readBigIntegerToBcd(n);\n        }\n    }\n\n    /**\n     * Sets the internal BCD state to represent the value in the given double.\n     *\n     * @param n\n     *            The value to consume.\n     */\n    public void setToDouble(double n) {\n        setBcdToZero();\n        flags = 0;\n        // Double.compare() handles +0.0 vs -0.0\n        if (Double.compare(n, 0.0) < 0) {\n            flags |= NEGATIVE_FLAG;\n            n = -n;\n        }\n        if (Double.isNaN(n)) {\n            flags |= NAN_FLAG;\n        } else if (Double.isInfinite(n)) {\n            flags |= INFINITY_FLAG;\n        } else if (n != 0) {\n            _setToDoubleFast(n);\n            compact();\n        }\n    }\n\n    private static final double[] DOUBLE_MULTIPLIERS = {\n            1e0,\n            1e1,\n            1e2,\n            1e3,\n            1e4,\n            1e5,\n            1e6,\n            1e7,\n            1e8,\n            1e9,\n            1e10,\n            1e11,\n            1e12,\n            1e13,\n            1e14,\n            1e15,\n            1e16,\n            1e17,\n            1e18,\n            1e19,\n            1e20,\n            1e21 };\n\n    /**\n     * Uses double multiplication and division to get the number into integer space before converting to\n     * digits. Since double arithmetic is inexact, the resulting digits may not be accurate.\n     */\n    private void _setToDoubleFast(double n) {\n        isApproximate = true;\n        origDouble = n;\n        origDelta = 0;\n\n        // NOTE: Unlike ICU4C, doubles are always IEEE 754 doubles.\n        long ieeeBits = Double.doubleToLongBits(n);\n        int exponent = (int) ((ieeeBits & 0x7ff0000000000000L) >> 52) - 0x3ff;\n\n        // Not all integers can be represented exactly for exponent > 52\n        if (exponent <= 52 && (long) n == n) {\n            _setToLong((long) n);\n            return;\n        }\n\n        // 3.3219... is log2(10)\n        int fracLength = (int) ((52 - exponent) / 3.32192809489);\n        if (fracLength >= 0) {\n            int i = fracLength;\n            // 1e22 is the largest exact double.\n            for (; i >= 22; i -= 22)\n                n *= 1e22;\n            n *= DOUBLE_MULTIPLIERS[i];\n        } else {\n            int i = fracLength;\n            // 1e22 is the largest exact double.\n            for (; i <= -22; i += 22)\n                n /= 1e22;\n            n /= DOUBLE_MULTIPLIERS[-i];\n        }\n        long result = Math.round(n);\n        if (result != 0) {\n            _setToLong(result);\n            scale -= fracLength;\n        }\n    }\n\n    /**\n     * Uses Double.toString() to obtain an exact accurate representation of the double, overwriting it\n     * into the BCD. This method can be called at any point after {@link #_setToDoubleFast} while\n     * {@link #isApproximate} is still true.\n     */\n    private void convertToAccurateDouble() {\n        double n = origDouble;\n        assert n != 0;\n        int delta = origDelta;\n        setBcdToZero();\n\n        // Call the slow oracle function (Double.toString in Java, sprintf in C++).\n        String dstr = Double.toString(n);\n\n        if (dstr.indexOf('E') != -1) {\n            // Case 1: Exponential notation.\n            assert dstr.indexOf('.') == 1;\n            int expPos = dstr.indexOf('E');\n            _setToLong(Long.parseLong(dstr.charAt(0) + dstr.substring(2, expPos)));\n            scale += Integer.parseInt(dstr.substring(expPos + 1)) - (expPos - 1) + 1;\n        } else if (dstr.charAt(0) == '0') {\n            // Case 2: Fraction-only number.\n            assert dstr.indexOf('.') == 1;\n            _setToLong(Long.parseLong(dstr.substring(2)));\n            scale += 2 - dstr.length();\n        } else if (dstr.charAt(dstr.length() - 1) == '0') {\n            // Case 3: Integer-only number.\n            // Note: this path should not normally happen, because integer-only numbers are captured\n            // before the approximate double logic is performed.\n            assert dstr.indexOf('.') == dstr.length() - 2;\n            assert dstr.length() - 2 <= 18;\n            _setToLong(Long.parseLong(dstr.substring(0, dstr.length() - 2)));\n            // no need to adjust scale\n        } else {\n            // Case 4: Number with both a fraction and an integer.\n            int decimalPos = dstr.indexOf('.');\n            _setToLong(Long.parseLong(dstr.substring(0, decimalPos) + dstr.substring(decimalPos + 1)));\n            scale += decimalPos - dstr.length() + 1;\n        }\n\n        scale += delta;\n        compact();\n        explicitExactDouble = true;\n    }\n\n    /**\n     * Whether this {@link DecimalQuantity_DualStorageBCD} has been explicitly converted to an exact\n     * double. true if backed by a double that was explicitly converted via convertToAccurateDouble;\n     * false otherwise. Used for testing.\n     *\n     * @internal\n     * @deprecated This API is ICU internal only.\n     */\n    @Deprecated\n    public boolean explicitExactDouble = false;\n\n    /**\n     * Sets the internal BCD state to represent the value in the given BigDecimal.\n     *\n     * @param n\n     *            The value to consume.\n     */\n    @Override\n    public void setToBigDecimal(BigDecimal n) {\n        setBcdToZero();\n        flags = 0;\n        if (n.signum() == -1) {\n            flags |= NEGATIVE_FLAG;\n            n = n.negate();\n        }\n        if (n.signum() != 0) {\n            _setToBigDecimal(n);\n            compact();\n        }\n    }\n\n    private void _setToBigDecimal(BigDecimal n) {\n        int fracLength = n.scale();\n        n = n.scaleByPowerOfTen(fracLength);\n        BigInteger bi = n.toBigInteger();\n        _setToBigInteger(bi);\n        scale -= fracLength;\n    }\n\n    /**\n     * Returns a long approximating the internal BCD. A long can only represent the integral part of the\n     * number.\n     *\n     * @param truncateIfOverflow if false and the number does NOT fit, fails with an assertion error.\n     * @return A 64-bit integer representation of the internal BCD.\n     */\n    public long toLong(boolean truncateIfOverflow) {\n        // NOTE: Call sites should be guarded by fitsInLong(), like this:\n        // if (dq.fitsInLong()) { /* use dq.toLong() */ } else { /* use some fallback */ }\n        // Fallback behavior upon truncateIfOverflow is to truncate at 17 digits.\n        assert(truncateIfOverflow || fitsInLong());\n        long result = 0L;\n        int upperMagnitude = Math.min(scale + precision, lOptPos) - 1;\n        if (truncateIfOverflow) {\n            upperMagnitude = Math.min(upperMagnitude, 17);\n        }\n        for (int magnitude = upperMagnitude; magnitude >= 0; magnitude--) {\n            result = result * 10 + getDigitPos(magnitude - scale);\n        }\n        if (isNegative()) {\n            result = -result;\n        }\n        return result;\n    }\n\n    /**\n     * This returns a long representing the fraction digits of the number, as required by PluralRules.\n     * For example, if we represent the number \"1.20\" (including optional and required digits), then this\n     * function returns \"20\" if includeTrailingZeros is true or \"2\" if false.\n     */\n    public long toFractionLong(boolean includeTrailingZeros) {\n        long result = 0L;\n        int magnitude = -1;\n        int lowerMagnitude = Math.max(scale, rOptPos);\n        if (includeTrailingZeros) {\n            lowerMagnitude = Math.min(lowerMagnitude, rReqPos);\n        }\n        // NOTE: Java has only signed longs, so we check result <= 1e17 instead of 1e18\n        for (; magnitude >= lowerMagnitude && result <= 1e17; magnitude--) {\n            result = result * 10 + getDigitPos(magnitude - scale);\n        }\n        // Remove trailing zeros; this can happen during integer overflow cases.\n        if (!includeTrailingZeros) {\n            while (result > 0 && (result % 10) == 0) {\n                result /= 10;\n            }\n        }\n        return result;\n    }\n\n    static final byte[] INT64_BCD = { 9, 2, 2, 3, 3, 7, 2, 0, 3, 6, 8, 5, 4, 7, 7, 5, 8, 0, 8 };\n\n    /**\n     * Returns whether or not a Long can fully represent the value stored in this DecimalQuantity.\n     */\n    public boolean fitsInLong() {\n        if (isZero()) {\n            return true;\n        }\n        if (scale < 0) {\n            return false;\n        }\n        int magnitude = getMagnitude();\n        if (magnitude < 18) {\n            return true;\n        }\n        if (magnitude > 18) {\n            return false;\n        }\n        // Hard case: the magnitude is 10^18.\n        // The largest int64 is: 9,223,372,036,854,775,807\n        for (int p = 0; p < precision; p++) {\n            byte digit = getDigit(18 - p);\n            if (digit < INT64_BCD[p]) {\n                return true;\n            } else if (digit > INT64_BCD[p]) {\n                return false;\n            }\n        }\n        // Exactly equal to max long plus one.\n        return isNegative();\n    }\n\n    /**\n     * Returns a double approximating the internal BCD. The double may not retain all of the information\n     * encoded in the BCD if the BCD represents a number out of range of a double.\n     *\n     * @return A double representation of the internal BCD.\n     */\n    @Override\n    public double toDouble() {\n        // If this assertion fails, you need to call roundToInfinity() or some other rounding method.\n        // See the comment at the top of this file explaining the \"isApproximate\" field.\n        assert !isApproximate;\n\n        if (isNaN()) {\n            return Double.NaN;\n        } else if (isInfinite()) {\n            return isNegative() ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n        // TODO: Do like in C++ and use a library function to perform this conversion?\n        // This code is not as hot in Java because .parse() returns a BigDecimal, not a double.\n\n        long tempLong = 0L;\n        int lostDigits = precision - Math.min(precision, 17);\n        for (int shift = precision - 1; shift >= lostDigits; shift--) {\n            tempLong = tempLong * 10 + getDigitPos(shift);\n        }\n        double result = tempLong;\n        int _scale = scale + lostDigits;\n        if (_scale >= 0) {\n            // 1e22 is the largest exact double.\n            int i = _scale;\n            for (; i >= 22; i -= 22) {\n                result *= 1e22;\n                if (Double.isInfinite(result)) {\n                    // Further multiplications will not be productive.\n                    i = 0;\n                    break;\n                }\n            }\n            result *= DOUBLE_MULTIPLIERS[i];\n        } else {\n            // 1e22 is the largest exact double.\n            int i = _scale;\n            for (; i <= -22; i += 22) {\n                result /= 1e22;\n                if (result == 0.0) {\n                    // Further divisions will not be productive.\n                    i = 0;\n                    break;\n                }\n            }\n            result /= DOUBLE_MULTIPLIERS[-i];\n        }\n        if (isNegative()) {\n            result = -result;\n        }\n        return result;\n    }\n\n    @Override\n    public BigDecimal toBigDecimal() {\n        if (isApproximate) {\n            // Converting to a BigDecimal requires Double.toString().\n            convertToAccurateDouble();\n        }\n        return bcdToBigDecimal();\n    }\n\n    private static int safeSubtract(int a, int b) {\n        int diff = a - b;\n        if (b < 0 && diff < a)\n            return Integer.MAX_VALUE;\n        if (b > 0 && diff > a)\n            return Integer.MIN_VALUE;\n        return diff;\n    }\n\n    private static final int SECTION_LOWER_EDGE = -1;\n    private static final int SECTION_UPPER_EDGE = -2;\n\n    /** Removes all fraction digits. */\n    public void truncate() {\n        if (scale < 0) {\n            shiftRight(-scale);\n            scale = 0;\n            compact();\n        }\n    }\n\n    @Override\n    public void roundToNickel(int magnitude, MathContext mathContext) {\n        roundToMagnitude(magnitude, mathContext, true);\n    }\n\n    @Override\n    public void roundToMagnitude(int magnitude, MathContext mathContext) {\n        roundToMagnitude(magnitude, mathContext, false);\n    }\n\n    private void roundToMagnitude(int magnitude, MathContext mathContext, boolean nickel) {\n        // The position in the BCD at which rounding will be performed; digits to the right of position\n        // will be rounded away.\n        int position = safeSubtract(magnitude, scale);\n\n        // Enforce the number of digits required by the MathContext.\n        int _mcPrecision = mathContext.getPrecision();\n        if (_mcPrecision > 0 && precision - _mcPrecision > position) {\n            position = precision - _mcPrecision;\n        }\n\n        // \"trailing\" = least significant digit to the left of rounding\n        byte trailingDigit = getDigitPos(position);\n\n        if (position <= 0 && !isApproximate && (!nickel || trailingDigit == 0 || trailingDigit == 5)) {\n            // All digits are to the left of the rounding magnitude.\n        } else if (precision == 0) {\n            // No rounding for zero.\n        } else {\n            // Perform rounding logic.\n            // \"leading\" = most significant digit to the right of rounding\n            byte leadingDigit = getDigitPos(safeSubtract(position, 1));\n\n            // Compute which section of the number we are in.\n            // EDGE means we are at the bottom or top edge, like 1.000 or 1.999 (used by doubles)\n            // LOWER means we are between the bottom edge and the midpoint, like 1.391\n            // MIDPOINT means we are exactly in the middle, like 1.500\n            // UPPER means we are between the midpoint and the top edge, like 1.916\n            int section;\n            if (!isApproximate) {\n                if (nickel && trailingDigit != 2 && trailingDigit != 7) {\n                    // Nickel rounding, and not at .02x or .07x\n                    if (trailingDigit < 2) {\n                        // .00, .01 => down to .00\n                        section = RoundingUtils.SECTION_LOWER;\n                    } else if (trailingDigit < 5) {\n                        // .03, .04 => up to .05\n                        section = RoundingUtils.SECTION_UPPER;\n                    } else if (trailingDigit < 7) {\n                        // .05, .06 => down to .05\n                        section = RoundingUtils.SECTION_LOWER;\n                    } else {\n                        // .08, .09 => up to .10\n                        section = RoundingUtils.SECTION_UPPER;\n                    }\n                } else if (leadingDigit < 5) {\n                    // Includes nickel rounding .020-.024 and .070-.074\n                    section = RoundingUtils.SECTION_LOWER;\n                } else if (leadingDigit > 5) {\n                    // Includes nickel rounding .026-.029 and .076-.079\n                    section = RoundingUtils.SECTION_UPPER;\n                } else {\n                    // Includes nickel rounding .025 and .075\n                    section = RoundingUtils.SECTION_MIDPOINT;\n                    for (int p = safeSubtract(position, 2); p >= 0; p--) {\n                        if (getDigitPos(p) != 0) {\n                            section = RoundingUtils.SECTION_UPPER;\n                            break;\n                        }\n                    }\n                }\n            } else {\n                int p = safeSubtract(position, 2);\n                int minP = Math.max(0, precision - 14);\n                if (leadingDigit == 0 && (!nickel || trailingDigit == 0 || trailingDigit == 5)) {\n                    section = SECTION_LOWER_EDGE;\n                    for (; p >= minP; p--) {\n                        if (getDigitPos(p) != 0) {\n                            section = RoundingUtils.SECTION_LOWER;\n                            break;\n                        }\n                    }\n                } else if (leadingDigit == 4 && (!nickel || trailingDigit == 2 || trailingDigit == 7)) {\n                    section = RoundingUtils.SECTION_MIDPOINT;\n                    for (; p >= minP; p--) {\n                        if (getDigitPos(p) != 9) {\n                            section = RoundingUtils.SECTION_LOWER;\n                            break;\n                        }\n                    }\n                } else if (leadingDigit == 5 && (!nickel || trailingDigit == 2 || trailingDigit == 7)) {\n                    section = RoundingUtils.SECTION_MIDPOINT;\n                    for (; p >= minP; p--) {\n                        if (getDigitPos(p) != 0) {\n                            section = RoundingUtils.SECTION_UPPER;\n                            break;\n                        }\n                    }\n                } else if (leadingDigit == 9 && (!nickel || trailingDigit == 4 || trailingDigit == 9)) {\n                    section = SECTION_UPPER_EDGE;\n                    for (; p >= minP; p--) {\n                        if (getDigitPos(p) != 9) {\n                            section = RoundingUtils.SECTION_UPPER;\n                            break;\n                        }\n                    }\n                } else if (nickel && trailingDigit != 2 && trailingDigit != 7) {\n                    // Nickel rounding, and not at .02x or .07x\n                    if (trailingDigit < 2) {\n                        // .00, .01 => down to .00\n                        section = RoundingUtils.SECTION_LOWER;\n                    } else if (trailingDigit < 5) {\n                        // .03, .04 => up to .05\n                        section = RoundingUtils.SECTION_UPPER;\n                    } else if (trailingDigit < 7) {\n                        // .05, .06 => down to .05\n                        section = RoundingUtils.SECTION_LOWER;\n                    } else {\n                        // .08, .09 => up to .10\n                        section = RoundingUtils.SECTION_UPPER;\n                    }\n                } else if (leadingDigit < 5) {\n                    // Includes nickel rounding .020-.024 and .070-.074\n                    section = RoundingUtils.SECTION_LOWER;\n                } else {\n                    // Includes nickel rounding .026-.029 and .076-.079\n                    section = RoundingUtils.SECTION_UPPER;\n                }\n\n                boolean roundsAtMidpoint = RoundingUtils\n                        .roundsAtMidpoint(mathContext.getRoundingMode().ordinal());\n                if (safeSubtract(position, 1) < precision - 14\n                        || (roundsAtMidpoint && section == RoundingUtils.SECTION_MIDPOINT)\n                        || (!roundsAtMidpoint && section < 0 /* i.e. at upper or lower edge */)) {\n                    // Oops! This means that we have to get the exact representation of the double,\n                    // because the zone of uncertainty is along the rounding boundary.\n                    convertToAccurateDouble();\n                    roundToMagnitude(magnitude, mathContext, nickel); // start over\n                    return;\n                }\n\n                // Turn off the approximate double flag, since the value is now confirmed to be exact.\n                isApproximate = false;\n                origDouble = 0.0;\n                origDelta = 0;\n\n                if (position <= 0 && (!nickel || trailingDigit == 0 || trailingDigit == 5)) {\n                    // All digits are to the left of the rounding magnitude.\n                    return;\n                }\n\n                // Good to continue rounding.\n                if (section == SECTION_LOWER_EDGE)\n                    section = RoundingUtils.SECTION_LOWER;\n                if (section == SECTION_UPPER_EDGE)\n                    section = RoundingUtils.SECTION_UPPER;\n            }\n\n            // Nickel rounding \"half even\" goes to the nearest whole (away from the 5).\n            boolean isEven = nickel\n                    ? (trailingDigit < 2 || trailingDigit > 7\n                            || (trailingDigit == 2 && section != RoundingUtils.SECTION_UPPER)\n                            || (trailingDigit == 7 && section == RoundingUtils.SECTION_UPPER))\n                    : (trailingDigit % 2) == 0;\n\n            boolean roundDown = RoundingUtils.getRoundingDirection(isEven,\n                    isNegative(),\n                    section,\n                    mathContext.getRoundingMode().ordinal(),\n                    this);\n\n            // Perform truncation\n            if (position >= precision) {\n                setBcdToZero();\n                scale = magnitude;\n            } else {\n                shiftRight(position);\n            }\n\n            if (nickel) {\n                if (trailingDigit < 5 && roundDown) {\n                    setDigitPos(0, (byte) 0);\n                    compact();\n                    return;\n                } else if (trailingDigit >= 5 && !roundDown) {\n                    setDigitPos(0, (byte) 9);\n                    trailingDigit = 9;\n                    // do not return: use the bubbling logic below\n                } else {\n                    setDigitPos(0, (byte) 5);\n                    // compact not necessary: digit at position 0 is nonzero\n                    return;\n                }\n            }\n\n            // Bubble the result to the higher digits\n            if (!roundDown) {\n                if (trailingDigit == 9) {\n                    int bubblePos = 0;\n                    // Note: in the long implementation, the most digits BCD can have at this point is\n                    // 15, so bubblePos <= 15 and getDigitPos(bubblePos) is safe.\n                    for (; getDigitPos(bubblePos) == 9; bubblePos++) {\n                    }\n                    shiftRight(bubblePos); // shift off the trailing 9s\n                }\n                byte digit0 = getDigitPos(0);\n                assert digit0 != 9;\n                setDigitPos(0, (byte) (digit0 + 1));\n                precision += 1; // in case an extra digit got added\n            }\n\n            compact();\n        }\n    }\n\n    @Override\n    public void roundToInfinity() {\n        if (isApproximate) {\n            convertToAccurateDouble();\n        }\n    }\n\n    /**\n     * Appends a digit, optionally with one or more leading zeros, to the end of the value represented by\n     * this DecimalQuantity.\n     *\n     * <p>\n     * The primary use of this method is to construct numbers during a parsing loop. It allows parsing to\n     * take advantage of the digit list infrastructure primarily designed for formatting.\n     *\n     * @param value\n     *            The digit to append.\n     * @param leadingZeros\n     *            The number of zeros to append before the digit. For example, if the value in this\n     *            instance starts as 12.3, and you append a 4 with 1 leading zero, the value becomes\n     *            12.304.\n     * @param appendAsInteger\n     *            If true, increase the magnitude of existing digits to make room for the new digit. If\n     *            false, append to the end like a fraction digit. If true, there must not be any fraction\n     *            digits already in the number.\n     * @internal\n     * @deprecated This API is ICU internal only.\n     */\n    @Deprecated\n    public void appendDigit(byte value, int leadingZeros, boolean appendAsInteger) {\n        assert leadingZeros >= 0;\n\n        // Zero requires special handling to maintain the invariant that the least-significant digit\n        // in the BCD is nonzero.\n        if (value == 0) {\n            if (appendAsInteger && precision != 0) {\n                scale += leadingZeros + 1;\n            }\n            return;\n        }\n\n        // Deal with trailing zeros\n        if (scale > 0) {\n            leadingZeros += scale;\n            if (appendAsInteger) {\n                scale = 0;\n            }\n        }\n\n        // Append digit\n        shiftLeft(leadingZeros + 1);\n        setDigitPos(0, value);\n\n        // Fix scale if in integer mode\n        if (appendAsInteger) {\n            scale += leadingZeros + 1;\n        }\n    }\n\n    @Override\n    public String toPlainString() {\n        // NOTE: This logic is duplicated between here and DecimalQuantity_SimpleStorage.\n        StringBuilder sb = new StringBuilder();\n        if (isNegative()) {\n            sb.append('-');\n        }\n        if (precision == 0 || getMagnitude() < 0) {\n            sb.append('0');\n        }\n        for (int m = getUpperDisplayMagnitude(); m >= getLowerDisplayMagnitude(); m--) {\n            sb.append((char) ('0' + getDigit(m)));\n            if (m == 0)\n                sb.append('.');\n        }\n        return sb.toString();\n    }\n\n    public String toScientificString() {\n        StringBuilder sb = new StringBuilder();\n        toScientificString(sb);\n        return sb.toString();\n    }\n\n    public void toScientificString(StringBuilder result) {\n        assert(!isApproximate);\n        if (isNegative()) {\n            result.append('-');\n        }\n        if (precision == 0) {\n            result.append(\"0E+0\");\n            return;\n        }\n        // NOTE: It is not safe to add to lOptPos (aka maxInt) or subtract from\n        // rOptPos (aka -maxFrac) due to overflow.\n        int upperPos = Math.min(precision + scale, lOptPos) - scale - 1;\n        int lowerPos = Math.max(scale, rOptPos) - scale;\n        int p = upperPos;\n        result.append((char) ('0' + getDigitPos(p)));\n        if ((--p) >= lowerPos) {\n            result.append('.');\n            for (; p >= lowerPos; p--) {\n                result.append((char) ('0' + getDigitPos(p)));\n            }\n        }\n        result.append('E');\n        int _scale = upperPos + scale;\n        if (_scale == Integer.MIN_VALUE) {\n            result.append(\"-2147483648\");\n            return;\n        } else if (_scale < 0) {\n            _scale *= -1;\n            result.append('-');\n        } else {\n            result.append('+');\n        }\n        if (_scale == 0) {\n            result.append('0');\n        }\n        int insertIndex = result.length();\n        while (_scale > 0) {\n            int quot = _scale / 10;\n            int rem = _scale % 10;\n            result.insert(insertIndex, (char) ('0' + rem));\n            _scale = quot;\n        }\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other == null) {\n            return false;\n        }\n        if (!(other instanceof DecimalQuantity_AbstractBCD)) {\n            return false;\n        }\n        DecimalQuantity_AbstractBCD _other = (DecimalQuantity_AbstractBCD) other;\n\n        boolean basicEquals =\n                scale == _other.scale\n                && precision == _other.precision\n                && flags == _other.flags\n                && lOptPos == _other.lOptPos\n                && lReqPos == _other.lReqPos\n                && rReqPos == _other.rReqPos\n                && rOptPos == _other.rOptPos\n                && isApproximate == _other.isApproximate;\n        if (!basicEquals) {\n            return false;\n        }\n\n        if (precision == 0) {\n            return true;\n        } else if (isApproximate) {\n            return origDouble == _other.origDouble && origDelta == _other.origDelta;\n        } else {\n            for (int m = getUpperDisplayMagnitude(); m >= getLowerDisplayMagnitude(); m--) {\n                if (getDigit(m) != _other.getDigit(m)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Returns a single digit from the BCD list. No internal state is changed by calling this method.\n     *\n     * @param position\n     *            The position of the digit to pop, counted in BCD units from the least significant\n     *            digit. If outside the range supported by the implementation, zero is returned.\n     * @return The digit at the specified location.\n     */\n    protected abstract byte getDigitPos(int position);\n\n    /**\n     * Sets the digit in the BCD list. This method only sets the digit; it is the caller's responsibility\n     * to call {@link #compact} after setting the digit.\n     *\n     * @param position\n     *            The position of the digit to pop, counted in BCD units from the least significant\n     *            digit. If outside the range supported by the implementation, an AssertionError is\n     *            thrown.\n     * @param value\n     *            The digit to set at the specified location.\n     */\n    protected abstract void setDigitPos(int position, byte value);\n\n    /**\n     * Adds zeros to the end of the BCD list. This will result in an invalid BCD representation; it is\n     * the caller's responsibility to do further manipulation and then call {@link #compact}.\n     *\n     * @param numDigits\n     *            The number of zeros to add.\n     */\n    protected abstract void shiftLeft(int numDigits);\n\n    /**\n     * Removes digits from the end of the BCD list. This may result in an invalid BCD representation; it\n     * is the caller's responsibility to follow-up with a call to {@link #compact}.\n     *\n     * @param numDigits\n     *            The number of digits to remove.\n     */\n    protected abstract void shiftRight(int numDigits);\n\n    /**\n     * Sets the internal representation to zero. Clears any values stored in scale, precision, hasDouble,\n     * origDouble, origDelta, and BCD data.\n     */\n    protected abstract void setBcdToZero();\n\n    /**\n     * Sets the internal BCD state to represent the value in the given int. The int is guaranteed to be\n     * either positive. The internal state is guaranteed to be empty when this method is called.\n     *\n     * @param n\n     *            The value to consume.\n     */\n    protected abstract void readIntToBcd(int input);\n\n    /**\n     * Sets the internal BCD state to represent the value in the given long. The long is guaranteed to be\n     * either positive. The internal state is guaranteed to be empty when this method is called.\n     *\n     * @param n\n     *            The value to consume.\n     */\n    protected abstract void readLongToBcd(long input);\n\n    /**\n     * Sets the internal BCD state to represent the value in the given BigInteger. The BigInteger is\n     * guaranteed to be positive, and it is guaranteed to be larger than Long.MAX_VALUE. The internal\n     * state is guaranteed to be empty when this method is called.\n     *\n     * @param n\n     *            The value to consume.\n     */\n    protected abstract void readBigIntegerToBcd(BigInteger input);\n\n    /**\n     * Returns a BigDecimal encoding the internal BCD value.\n     *\n     * @return A BigDecimal representation of the internal BCD.\n     */\n    protected abstract BigDecimal bcdToBigDecimal();\n\n    protected abstract void copyBcdFrom(DecimalQuantity _other);\n\n    /**\n     * Removes trailing zeros from the BCD (adjusting the scale as required) and then computes the\n     * precision. The precision is the number of digits in the number up through the greatest nonzero\n     * digit.\n     *\n     * <p>\n     * This method must always be called when bcd changes in order for assumptions to be correct in\n     * methods like {@link #fractionCount()}.\n     */\n    protected abstract void compact();\n}\n", "// \u00a9 2017 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html#License\npackage com.ibm.icu.impl.number;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\n/**\n * A DecimalQuantity with internal storage as a 64-bit BCD, with fallback to a byte array for numbers\n * that don't fit into the standard BCD.\n */\npublic final class DecimalQuantity_DualStorageBCD extends DecimalQuantity_AbstractBCD {\n\n    /**\n     * The BCD of the 16 digits of the number represented by this object. Every 4 bits of the long map to\n     * one digit. For example, the number \"12345\" in BCD is \"0x12345\".\n     *\n     * <p>\n     * Whenever bcd changes internally, {@link #compact()} must be called, except in special cases like\n     * setting the digit to zero.\n     */\n    private byte[] bcdBytes;\n\n    private long bcdLong = 0L;\n\n    private boolean usingBytes = false;\n\n    @Override\n    public int maxRepresentableDigits() {\n        return Integer.MAX_VALUE;\n    }\n\n    public DecimalQuantity_DualStorageBCD() {\n        setBcdToZero();\n        flags = 0;\n    }\n\n    public DecimalQuantity_DualStorageBCD(long input) {\n        setToLong(input);\n    }\n\n    public DecimalQuantity_DualStorageBCD(int input) {\n        setToInt(input);\n    }\n\n    public DecimalQuantity_DualStorageBCD(double input) {\n        setToDouble(input);\n    }\n\n    public DecimalQuantity_DualStorageBCD(BigInteger input) {\n        setToBigInteger(input);\n    }\n\n    public DecimalQuantity_DualStorageBCD(BigDecimal input) {\n        setToBigDecimal(input);\n    }\n\n    public DecimalQuantity_DualStorageBCD(DecimalQuantity_DualStorageBCD other) {\n        copyFrom(other);\n    }\n\n    public DecimalQuantity_DualStorageBCD(Number number) {\n        // NOTE: Number type expansion happens both here\n        // and in NumberFormat.java\n        if (number instanceof Long) {\n            setToLong(number.longValue());\n        } else if (number instanceof Integer) {\n            setToInt(number.intValue());\n        } else if (number instanceof Float) {\n            setToDouble(number.doubleValue());\n        } else if (number instanceof Double) {\n            setToDouble(number.doubleValue());\n        } else if (number instanceof BigInteger) {\n            setToBigInteger((BigInteger) number);\n        } else if (number instanceof BigDecimal) {\n            setToBigDecimal((BigDecimal) number);\n        } else if (number instanceof com.ibm.icu.math.BigDecimal) {\n            setToBigDecimal(((com.ibm.icu.math.BigDecimal) number).toBigDecimal());\n        } else {\n            throw new IllegalArgumentException(\n                    \"Number is of an unsupported type: \" + number.getClass().getName());\n        }\n    }\n\n    @Override\n    public DecimalQuantity createCopy() {\n        return new DecimalQuantity_DualStorageBCD(this);\n    }\n\n    @Override\n    protected byte getDigitPos(int position) {\n        if (usingBytes) {\n            if (position < 0 || position >= precision)\n                return 0;\n            return bcdBytes[position];\n        } else {\n            if (position < 0 || position >= 16)\n                return 0;\n            return (byte) ((bcdLong >>> (position * 4)) & 0xf);\n        }\n    }\n\n    @Override\n    protected void setDigitPos(int position, byte value) {\n        assert position >= 0;\n        if (usingBytes) {\n            ensureCapacity(position + 1);\n            bcdBytes[position] = value;\n        } else if (position >= 16) {\n            switchStorage();\n            ensureCapacity(position + 1);\n            bcdBytes[position] = value;\n        } else {\n            int shift = position * 4;\n            bcdLong = bcdLong & ~(0xfL << shift) | ((long) value << shift);\n        }\n    }\n\n    @Override\n    protected void shiftLeft(int numDigits) {\n        if (!usingBytes && precision + numDigits > 16) {\n            switchStorage();\n        }\n        if (usingBytes) {\n            ensureCapacity(precision + numDigits);\n            int i = precision + numDigits - 1;\n            for (; i >= numDigits; i--) {\n                bcdBytes[i] = bcdBytes[i - numDigits];\n            }\n            for (; i >= 0; i--) {\n                bcdBytes[i] = 0;\n            }\n        } else {\n            bcdLong <<= (numDigits * 4);\n        }\n        scale -= numDigits;\n        precision += numDigits;\n    }\n\n    @Override\n    protected void shiftRight(int numDigits) {\n        if (usingBytes) {\n            int i = 0;\n            for (; i < precision - numDigits; i++) {\n                bcdBytes[i] = bcdBytes[i + numDigits];\n            }\n            for (; i < precision; i++) {\n                bcdBytes[i] = 0;\n            }\n        } else {\n            bcdLong >>>= (numDigits * 4);\n        }\n        scale += numDigits;\n        precision -= numDigits;\n    }\n\n    @Override\n    protected void setBcdToZero() {\n        if (usingBytes) {\n            bcdBytes = null;\n            usingBytes = false;\n        }\n        bcdLong = 0L;\n        scale = 0;\n        precision = 0;\n        isApproximate = false;\n        origDouble = 0;\n        origDelta = 0;\n    }\n\n    @Override\n    protected void readIntToBcd(int n) {\n        assert n != 0;\n        // ints always fit inside the long implementation.\n        long result = 0L;\n        int i = 16;\n        for (; n != 0; n /= 10, i--) {\n            result = (result >>> 4) + (((long) n % 10) << 60);\n        }\n        assert !usingBytes;\n        bcdLong = result >>> (i * 4);\n        scale = 0;\n        precision = 16 - i;\n    }\n\n    @Override\n    protected void readLongToBcd(long n) {\n        assert n != 0;\n        if (n >= 10000000000000000L) {\n            ensureCapacity();\n            int i = 0;\n            for (; n != 0L; n /= 10L, i++) {\n                bcdBytes[i] = (byte) (n % 10);\n            }\n            assert usingBytes;\n            scale = 0;\n            precision = i;\n        } else {\n            long result = 0L;\n            int i = 16;\n            for (; n != 0L; n /= 10L, i--) {\n                result = (result >>> 4) + ((n % 10) << 60);\n            }\n            assert i >= 0;\n            assert !usingBytes;\n            bcdLong = result >>> (i * 4);\n            scale = 0;\n            precision = 16 - i;\n        }\n    }\n\n    @Override\n    protected void readBigIntegerToBcd(BigInteger n) {\n        assert n.signum() != 0;\n        ensureCapacity(); // allocate initial byte array\n        int i = 0;\n        for (; n.signum() != 0; i++) {\n            BigInteger[] temp = n.divideAndRemainder(BigInteger.TEN);\n            ensureCapacity(i + 1);\n            bcdBytes[i] = temp[1].byteValue();\n            n = temp[0];\n        }\n        scale = 0;\n        precision = i;\n    }\n\n    @Override\n    protected BigDecimal bcdToBigDecimal() {\n        if (usingBytes) {\n            // Converting to a string here is faster than doing BigInteger/BigDecimal arithmetic.\n            BigDecimal result = new BigDecimal(toNumberString());\n            if (isNegative()) {\n                result = result.negate();\n            }\n            return result;\n        } else {\n            long tempLong = 0L;\n            for (int shift = (precision - 1); shift >= 0; shift--) {\n                tempLong = tempLong * 10 + getDigitPos(shift);\n            }\n            BigDecimal result = BigDecimal.valueOf(tempLong);\n            try {\n                result = result.scaleByPowerOfTen(scale);\n            } catch (ArithmeticException e) {\n                if (e.getMessage().contains(\"Underflow\")) {\n                    result = BigDecimal.ZERO;\n                } else {\n                    throw e;\n                }\n            }\n            if (isNegative())\n                result = result.negate();\n            return result;\n        }\n    }\n\n    @Override\n    protected void compact() {\n        if (usingBytes) {\n            int delta = 0;\n            for (; delta < precision && bcdBytes[delta] == 0; delta++)\n                ;\n            if (delta == precision) {\n                // Number is zero\n                setBcdToZero();\n                return;\n            } else {\n                // Remove trailing zeros\n                shiftRight(delta);\n            }\n\n            // Compute precision\n            int leading = precision - 1;\n            for (; leading >= 0 && bcdBytes[leading] == 0; leading--)\n                ;\n            precision = leading + 1;\n\n            // Switch storage mechanism if possible\n            if (precision <= 16) {\n                switchStorage();\n            }\n\n        } else {\n            if (bcdLong == 0L) {\n                // Number is zero\n                setBcdToZero();\n                return;\n            }\n\n            // Compact the number (remove trailing zeros)\n            int delta = Long.numberOfTrailingZeros(bcdLong) / 4;\n            bcdLong >>>= delta * 4;\n            scale += delta;\n\n            // Compute precision\n            precision = 16 - (Long.numberOfLeadingZeros(bcdLong) / 4);\n        }\n    }\n\n    /** Ensure that a byte array of at least 40 digits is allocated. */\n    private void ensureCapacity() {\n        ensureCapacity(40);\n    }\n\n    private void ensureCapacity(int capacity) {\n        if (capacity == 0)\n            return;\n        int oldCapacity = usingBytes ? bcdBytes.length : 0;\n        if (!usingBytes) {\n            bcdBytes = new byte[capacity];\n        } else if (oldCapacity < capacity) {\n            byte[] bcd1 = new byte[capacity * 2];\n            System.arraycopy(bcdBytes, 0, bcd1, 0, oldCapacity);\n            bcdBytes = bcd1;\n        }\n        usingBytes = true;\n    }\n\n    /** Switches the internal storage mechanism between the 64-bit long and the byte array. */\n    private void switchStorage() {\n        if (usingBytes) {\n            // Change from bytes to long\n            bcdLong = 0L;\n            for (int i = precision - 1; i >= 0; i--) {\n                bcdLong <<= 4;\n                bcdLong |= bcdBytes[i];\n            }\n            bcdBytes = null;\n            usingBytes = false;\n        } else {\n            // Change from long to bytes\n            ensureCapacity();\n            for (int i = 0; i < precision; i++) {\n                bcdBytes[i] = (byte) (bcdLong & 0xf);\n                bcdLong >>>= 4;\n            }\n            assert usingBytes;\n        }\n    }\n\n    @Override\n    protected void copyBcdFrom(DecimalQuantity _other) {\n        DecimalQuantity_DualStorageBCD other = (DecimalQuantity_DualStorageBCD) _other;\n        setBcdToZero();\n        if (other.usingBytes) {\n            ensureCapacity(other.precision);\n            System.arraycopy(other.bcdBytes, 0, bcdBytes, 0, other.precision);\n        } else {\n            bcdLong = other.bcdLong;\n        }\n    }\n\n    /**\n     * Checks whether the bytes stored in this instance are all valid. For internal unit testing only.\n     *\n     * @return An error message if this instance is invalid, or null if this instance is healthy.\n     * @internal\n     * @deprecated This API is for ICU internal use only.\n     */\n    @Deprecated\n    public String checkHealth() {\n        if (usingBytes) {\n            if (bcdLong != 0)\n                return \"Value in bcdLong but we are in byte mode\";\n            if (precision == 0)\n                return \"Zero precision but we are in byte mode\";\n            if (precision > bcdBytes.length)\n                return \"Precision exceeds length of byte array\";\n            if (getDigitPos(precision - 1) == 0)\n                return \"Most significant digit is zero in byte mode\";\n            if (getDigitPos(0) == 0)\n                return \"Least significant digit is zero in long mode\";\n            for (int i = 0; i < precision; i++) {\n                if (getDigitPos(i) >= 10)\n                    return \"Digit exceeding 10 in byte array\";\n                if (getDigitPos(i) < 0)\n                    return \"Digit below 0 in byte array\";\n            }\n            for (int i = precision; i < bcdBytes.length; i++) {\n                if (getDigitPos(i) != 0)\n                    return \"Nonzero digits outside of range in byte array\";\n            }\n        } else {\n            if (bcdBytes != null) {\n                for (int i = 0; i < bcdBytes.length; i++) {\n                    if (bcdBytes[i] != 0)\n                        return \"Nonzero digits in byte array but we are in long mode\";\n                }\n            }\n            if (precision == 0 && bcdLong != 0)\n                return \"Value in bcdLong even though precision is zero\";\n            if (precision > 16)\n                return \"Precision exceeds length of long\";\n            if (precision != 0 && getDigitPos(precision - 1) == 0)\n                return \"Most significant digit is zero in long mode\";\n            if (precision != 0 && getDigitPos(0) == 0)\n                return \"Least significant digit is zero in long mode\";\n            for (int i = 0; i < precision; i++) {\n                if (getDigitPos(i) >= 10)\n                    return \"Digit exceeding 10 in long\";\n                if (getDigitPos(i) < 0)\n                    return \"Digit below 0 in long (?!)\";\n            }\n            for (int i = precision; i < 16; i++) {\n                if (getDigitPos(i) != 0)\n                    return \"Nonzero digits outside of range in long\";\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Checks whether this {@link DecimalQuantity_DualStorageBCD} is using its internal byte array\n     * storage mechanism.\n     *\n     * @return true if an internal byte array is being used; false if a long is being used.\n     * @internal\n     * @deprecated This API is ICU internal only.\n     */\n    @Deprecated\n    public boolean isUsingBytes() {\n        return usingBytes;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"<DecimalQuantity %s:%d:%d:%s %s %s%s>\",\n                (lOptPos > 1000 ? \"999\" : String.valueOf(lOptPos)),\n                lReqPos,\n                rReqPos,\n                (rOptPos < -1000 ? \"-999\" : String.valueOf(rOptPos)),\n                (usingBytes ? \"bytes\" : \"long\"),\n                (isNegative() ? \"-\" : \"\"),\n                toNumberString());\n    }\n\n    private String toNumberString() {\n        StringBuilder sb = new StringBuilder();\n        if (usingBytes) {\n            if (precision == 0) {\n                sb.append('0');\n            }\n            for (int i = precision - 1; i >= 0; i--) {\n                sb.append(bcdBytes[i]);\n            }\n        } else {\n            sb.append(Long.toHexString(bcdLong));\n        }\n        sb.append(\"E\");\n        sb.append(scale);\n        return sb.toString();\n    }\n}\n", "// \u00a9 2016 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html#License\n/*\n *******************************************************************************\n * Copyright (C) 2001-2016, International Business Machines Corporation and\n * others. All Rights Reserved.\n *******************************************************************************\n */\n\n/**\n * Port From:   ICU4C v1.8.1 : format : NumberFormatTest\n * Source File: $ICU4oot/source/test/intltest/numfmtst.cpp\n **/\n\npackage com.ibm.icu.dev.test.format;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.math.BigInteger;\nimport java.math.RoundingMode;\nimport java.text.AttributedCharacterIterator;\nimport java.text.FieldPosition;\nimport java.text.Format;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Random;\nimport java.util.Set;\n\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\nimport com.ibm.icu.dev.test.TestFmwk;\nimport com.ibm.icu.dev.test.TestUtil;\nimport com.ibm.icu.dev.test.format.IntlTestDecimalFormatAPIC.FieldContainer;\nimport com.ibm.icu.dev.text.DecimalFormat_ICU58;\nimport com.ibm.icu.impl.ICUConfig;\nimport com.ibm.icu.impl.LocaleUtility;\nimport com.ibm.icu.impl.data.ResourceReader;\nimport com.ibm.icu.impl.data.TokenIterator;\nimport com.ibm.icu.math.BigDecimal;\nimport com.ibm.icu.math.MathContext;\nimport com.ibm.icu.text.CompactDecimalFormat;\nimport com.ibm.icu.text.CurrencyPluralInfo;\nimport com.ibm.icu.text.DecimalFormat;\nimport com.ibm.icu.text.DecimalFormatSymbols;\nimport com.ibm.icu.text.DisplayContext;\nimport com.ibm.icu.text.MeasureFormat;\nimport com.ibm.icu.text.NumberFormat;\nimport com.ibm.icu.text.NumberFormat.NumberFormatFactory;\nimport com.ibm.icu.text.NumberFormat.SimpleNumberFormatFactory;\nimport com.ibm.icu.text.NumberingSystem;\nimport com.ibm.icu.text.RuleBasedNumberFormat;\nimport com.ibm.icu.text.UnicodeSet;\nimport com.ibm.icu.util.Currency;\nimport com.ibm.icu.util.Currency.CurrencyUsage;\nimport com.ibm.icu.util.CurrencyAmount;\nimport com.ibm.icu.util.ULocale;\n\n@RunWith(JUnit4.class)\npublic class NumberFormatTest extends TestFmwk {\n\n    @Test\n    public void TestRoundingScientific10542() {\n        DecimalFormat format =\n                new DecimalFormat(\"0.00E0\");\n\n        int[] roundingModes = {\n              BigDecimal.ROUND_CEILING,\n              BigDecimal.ROUND_DOWN,\n              BigDecimal.ROUND_FLOOR,\n              BigDecimal.ROUND_HALF_DOWN,\n              BigDecimal.ROUND_HALF_EVEN,\n              BigDecimal.ROUND_HALF_UP,\n              BigDecimal.ROUND_UP};\n        String[] descriptions = {\n                \"Round Ceiling\",\n                \"Round Down\",\n                \"Round Floor\",\n                \"Round half down\",\n                \"Round half even\",\n                \"Round half up\",\n                \"Round up\"};\n\n        double[] values = {-0.003006, -0.003005, -0.003004, 0.003014, 0.003015, 0.003016};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        String[][] expected = {\n                {\"-3.00E-3\", \"-3.00E-3\", \"-3.00E-3\", \"3.02E-3\", \"3.02E-3\", \"3.02E-3\"},\n                {\"-3.00E-3\", \"-3.00E-3\", \"-3.00E-3\", \"3.01E-3\", \"3.01E-3\", \"3.01E-3\"},\n                {\"-3.01E-3\", \"-3.01E-3\", \"-3.01E-3\", \"3.01E-3\", \"3.01E-3\", \"3.01E-3\"},\n                {\"-3.01E-3\", \"-3.00E-3\", \"-3.00E-3\", \"3.01E-3\", \"3.01E-3\", \"3.02E-3\"},\n                {\"-3.01E-3\", \"-3.00E-3\", \"-3.00E-3\", \"3.01E-3\", \"3.02E-3\", \"3.02E-3\"},\n                {\"-3.01E-3\", \"-3.01E-3\", \"-3.00E-3\", \"3.01E-3\", \"3.02E-3\", \"3.02E-3\"},\n                {\"-3.01E-3\", \"-3.01E-3\", \"-3.01E-3\", \"3.02E-3\", \"3.02E-3\", \"3.02E-3\"}};\n        verifyRounding(format, values, expected, roundingModes, descriptions);\n        values = new double[]{-3006.0, -3005, -3004, 3014, 3015, 3016};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        expected = new String[][]{\n                {\"-3.00E3\", \"-3.00E3\", \"-3.00E3\", \"3.02E3\", \"3.02E3\", \"3.02E3\"},\n                {\"-3.00E3\", \"-3.00E3\", \"-3.00E3\", \"3.01E3\", \"3.01E3\", \"3.01E3\"},\n                {\"-3.01E3\", \"-3.01E3\", \"-3.01E3\", \"3.01E3\", \"3.01E3\", \"3.01E3\"},\n                {\"-3.01E3\", \"-3.00E3\", \"-3.00E3\", \"3.01E3\", \"3.01E3\", \"3.02E3\"},\n                {\"-3.01E3\", \"-3.00E3\", \"-3.00E3\", \"3.01E3\", \"3.02E3\", \"3.02E3\"},\n                {\"-3.01E3\", \"-3.01E3\", \"-3.00E3\", \"3.01E3\", \"3.02E3\", \"3.02E3\"},\n                {\"-3.01E3\", \"-3.01E3\", \"-3.01E3\", \"3.02E3\", \"3.02E3\", \"3.02E3\"}};\n        verifyRounding(format, values, expected, roundingModes, descriptions);\n        values = new double[]{0.0, -0.0};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        expected = new String[][]{\n                {\"0.00E0\", \"-0.00E0\"},\n                {\"0.00E0\", \"-0.00E0\"},\n                {\"0.00E0\", \"-0.00E0\"},\n                {\"0.00E0\", \"-0.00E0\"},\n                {\"0.00E0\", \"-0.00E0\"},\n                {\"0.00E0\", \"-0.00E0\"},\n                {\"0.00E0\", \"-0.00E0\"}};\n        verifyRounding(format, values, expected, roundingModes, descriptions);\n        values = new double[]{1e25, 1e25 + 1e15, 1e25 - 1e15};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        expected = new String[][]{\n                {\"1.00E25\", \"1.01E25\", \"1.00E25\"},\n                {\"1.00E25\", \"1.00E25\", \"9.99E24\"},\n                {\"1.00E25\", \"1.00E25\", \"9.99E24\"},\n                {\"1.00E25\", \"1.00E25\", \"1.00E25\"},\n                {\"1.00E25\", \"1.00E25\", \"1.00E25\"},\n                {\"1.00E25\", \"1.00E25\", \"1.00E25\"},\n                {\"1.00E25\", \"1.01E25\", \"1.00E25\"}};\n        verifyRounding(format, values, expected, roundingModes, descriptions);\n        values = new double[]{-1e25, -1e25 + 1e15, -1e25 - 1e15};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        expected = new String[][]{\n                {\"-1.00E25\", \"-9.99E24\", \"-1.00E25\"},\n                {\"-1.00E25\", \"-9.99E24\", \"-1.00E25\"},\n                {\"-1.00E25\", \"-1.00E25\", \"-1.01E25\"},\n                {\"-1.00E25\", \"-1.00E25\", \"-1.00E25\"},\n                {\"-1.00E25\", \"-1.00E25\", \"-1.00E25\"},\n                {\"-1.00E25\", \"-1.00E25\", \"-1.00E25\"},\n                {\"-1.00E25\", \"-1.00E25\", \"-1.01E25\"}};\n        verifyRounding(format, values, expected, roundingModes, descriptions);\n        values = new double[]{1e-25, 1e-25 + 1e-35, 1e-25 - 1e-35};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        expected = new String[][]{\n                {\"1.00E-25\", \"1.01E-25\", \"1.00E-25\"},\n                {\"1.00E-25\", \"1.00E-25\", \"9.99E-26\"},\n                {\"1.00E-25\", \"1.00E-25\", \"9.99E-26\"},\n                {\"1.00E-25\", \"1.00E-25\", \"1.00E-25\"},\n                {\"1.00E-25\", \"1.00E-25\", \"1.00E-25\"},\n                {\"1.00E-25\", \"1.00E-25\", \"1.00E-25\"},\n                {\"1.00E-25\", \"1.01E-25\", \"1.00E-25\"}};\n        verifyRounding(format, values, expected, roundingModes, descriptions);\n        values = new double[]{-1e-25, -1e-25 + 1e-35, -1e-25 - 1e-35};\n        // The order of these expected values correspond to the order of roundingModes and the order of values.\n        expected = new String[][]{\n                {\"-1.00E-25\", \"-9.99E-26\", \"-1.00E-25\"},\n                {\"-1.00E-25\", \"-9.99E-26\", \"-1.00E-25\"},\n                {\"-1.00E-25\", \"-1.00E-25\", \"-1.01E-25\"},\n                {\"-1.00E-25\", \"-1.00E-25\", \"-1.00E-25\"},\n                {\"-1.00E-25\", \"-1.00E-25\", \"-1.00E-25\"},\n                {\"-1.00E-25\", \"-1.00E-25\", \"-1.00E-25\"},\n                {\"-1.00E-25\", \"-1.00E-25\", \"-1.01E-25\"}};\n        verifyRounding(format, values, expected, roundingModes, descriptions);\n    }\n\n    private void verifyRounding(DecimalFormat format, double[] values, String[][] expected, int[] roundingModes,\n            String[] descriptions) {\n        for (int i = 0; i < roundingModes.length; i++) {\n            format.setRoundingMode(roundingModes[i]);\n            for (int j = 0; j < values.length; j++) {\n                assertEquals(descriptions[i]+\" \" +values[j], expected[i][j], format.format(values[j]));\n            }\n        }\n    }\n\n    @Test\n    public void Test10419RoundingWith0FractionDigits() {\n        Object[][] data = new Object[][]{\n                {BigDecimal.ROUND_CEILING, 1.488, \"2\"},\n                {BigDecimal.ROUND_DOWN, 1.588, \"1\"},\n                {BigDecimal.ROUND_FLOOR, 1.588, \"1\"},\n                {BigDecimal.ROUND_HALF_DOWN, 1.5, \"1\"},\n                {BigDecimal.ROUND_HALF_EVEN, 2.5, \"2\"},\n                {BigDecimal.ROUND_HALF_UP, 2.5, \"3\"},\n                {BigDecimal.ROUND_UP, 1.5, \"2\"},\n        };\n        NumberFormat nff = NumberFormat.getNumberInstance(ULocale.ENGLISH);\n        nff.setMaximumFractionDigits(0);\n        for (Object[] item : data) {\n          nff.setRoundingMode(((Integer) item[0]).intValue());\n          assertEquals(\"Test10419\", item[2], nff.format(item[1]));\n        }\n    }\n\n    @Test\n    public void TestParseNegativeWithFaLocale() {\n        DecimalFormat parser = (DecimalFormat) NumberFormat.getInstance(new ULocale(\"fa\"));\n        try {\n            double value = parser.parse(\"-0,5\").doubleValue();\n            assertEquals(\"Expect -0.5\", -0.5, value);\n        } catch (ParseException e) {\n            TestFmwk.errln(\"Parsing -0.5 should have succeeded.\");\n        }\n    }\n\n    @Test\n    public void TestParseNegativeWithAlternativeMinusSign() {\n        DecimalFormat parser = (DecimalFormat) NumberFormat.getInstance(new ULocale(\"en\"));\n        try {\n            double value = parser.parse(\"\\u208B0.5\").doubleValue();\n            assertEquals(\"Expect -0.5\", -0.5, value);\n        } catch (ParseException e) {\n            TestFmwk.errln(\"Parsing -0.5 should have succeeded.\");\n        }\n    }\n\n    // Test various patterns\n    @Test\n    public void TestPatterns() {\n\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(Locale.US);\n        final String pat[]    = { \"#.#\", \"#.\", \".#\", \"#\" };\n        int pat_length = pat.length;\n        final String newpat[] = { \"0.#\", \"0.\", \"#.0\", \"0\" };\n        final String num[]    = { \"0\",   \"0.\", \".0\", \"0\" };\n        for (int i=0; i<pat_length; ++i)\n        {\n            DecimalFormat fmt = new DecimalFormat(pat[i], sym);\n            String newp = fmt.toPattern();\n            if (!newp.equals(newpat[i]))\n                errln(\"FAIL: Pattern \" + pat[i] + \" should transmute to \" + newpat[i] +\n                        \"; \" + newp + \" seen instead\");\n\n            String s = ((NumberFormat)fmt).format(0);\n            if (!s.equals(num[i]))\n            {\n                errln(\"FAIL: Pattern \" + pat[i] + \" should format zero as \" + num[i] +\n                        \"; \" + s + \" seen instead\");\n                logln(\"Min integer digits = \" + fmt.getMinimumIntegerDigits());\n            }\n            // BigInteger 0 - ticket#4731\n            s = ((NumberFormat)fmt).format(BigInteger.ZERO);\n            if (!s.equals(num[i]))\n            {\n                errln(\"FAIL: Pattern \" + pat[i] + \" should format BigInteger zero as \" + num[i] +\n                        \"; \" + s + \" seen instead\");\n                logln(\"Min integer digits = \" + fmt.getMinimumIntegerDigits());\n            }\n        }\n    }\n\n    // Test exponential pattern\n    @Test\n    public void TestExponential() {\n\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(Locale.US);\n        final String pat[] = { \"0.####E0\", \"00.000E00\", \"##0.######E000\", \"0.###E0;[0.###E0]\" };\n        int pat_length = pat.length;\n\n        double val[] = { 0.01234, 123456789, 1.23e300, -3.141592653e-271 };\n        int val_length = val.length;\n        final String valFormat[] = {\n                // 0.####E0\n                \"1.234E-2\", \"1.2346E8\", \"1.23E300\", \"-3.1416E-271\",\n                // 00.000E00\n                \"12.340E-03\", \"12.346E07\", \"12.300E299\", \"-31.416E-272\",\n                // ##0.######E000\n                \"12.34E-003\", \"123.4568E006\", \"1.23E300\", \"-314.1593E-273\",\n                // 0.###E0;[0.###E0]\n                \"1.234E-2\", \"1.235E8\", \"1.23E300\", \"[3.142E-271]\" };\n        /*double valParse[] =\n            {\n                0.01234, 123460000, 1.23E300, -3.1416E-271,\n                0.01234, 123460000, 1.23E300, -3.1416E-271,\n                0.01234, 123456800, 1.23E300, -3.141593E-271,\n                0.01234, 123500000, 1.23E300, -3.142E-271,\n            };*/ //The variable is never used\n\n        int lval[] = { 0, -1, 1, 123456789 };\n        int lval_length = lval.length;\n        final String lvalFormat[] = {\n                // 0.####E0\n                \"0E0\", \"-1E0\", \"1E0\", \"1.2346E8\",\n                // 00.000E00\n                \"00.000E00\", \"-10.000E-01\", \"10.000E-01\", \"12.346E07\",\n                // ##0.######E000\n                \"0E000\", \"-1E000\", \"1E000\", \"123.4568E006\",\n                // 0.###E0;[0.###E0]\n                \"0E0\", \"[1E0]\", \"1E0\", \"1.235E8\" };\n        int lvalParse[] =\n            {\n                0, -1, 1, 123460000,\n                0, -1, 1, 123460000,\n                0, -1, 1, 123456800,\n                0, -1, 1, 123500000,\n            };\n        int ival = 0, ilval = 0;\n        for (int p = 0; p < pat_length; ++p) {\n            DecimalFormat fmt = new DecimalFormat(pat[p], sym);\n            logln(\"Pattern \\\"\" + pat[p] + \"\\\" -toPattern-> \\\"\" + fmt.toPattern() + \"\\\"\");\n            int v;\n            for (v = 0; v < val_length; ++v) {\n                String s;\n                s = ((NumberFormat) fmt).format(val[v]);\n                logln(\" \" + val[v] + \" -format-> \" + s);\n                if (!s.equals(valFormat[v + ival]))\n                    errln(\"FAIL: Expected \" + valFormat[v + ival]);\n\n                ParsePosition pos = new ParsePosition(0);\n                double a = fmt.parse(s, pos).doubleValue();\n                if (pos.getIndex() == s.length()) {\n                    logln(\"  -parse-> \" + Double.toString(a));\n                    // Use epsilon comparison as necessary\n                } else\n                    errln(\"FAIL: Partial parse (\" + pos.getIndex() + \" chars) -> \" + a);\n            }\n            for (v = 0; v < lval_length; ++v) {\n                String s;\n                s = ((NumberFormat) fmt).format(lval[v]);\n                logln(\" \" + lval[v] + \"L -format-> \" + s);\n                if (!s.equals(lvalFormat[v + ilval]))\n                    errln(\"ERROR: Expected \" + lvalFormat[v + ilval] + \" Got: \" + s);\n\n                ParsePosition pos = new ParsePosition(0);\n                long a = 0;\n                Number A = fmt.parse(s, pos);\n                if (A != null) {\n                    a = A.longValue();\n                    if (pos.getIndex() == s.length()) {\n                        logln(\"  -parse-> \" + a);\n                        if (a != lvalParse[v + ilval])\n                            errln(\"FAIL: Expected \" + lvalParse[v + ilval]);\n                    } else\n                        errln(\"FAIL: Partial parse (\" + pos.getIndex() + \" chars) -> \" + Long.toString(a));\n                } else {\n                    errln(\"Fail to parse the string: \" + s);\n                }\n            }\n            ival += val_length;\n            ilval += lval_length;\n        }\n    }\n\n    // Test the handling of quotes\n    @Test\n    public void TestQuotes() {\n\n        StringBuffer pat;\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(Locale.US);\n        pat = new StringBuffer(\"a'fo''o'b#\");\n        DecimalFormat fmt = new DecimalFormat(pat.toString(), sym);\n        String s = ((NumberFormat)fmt).format(123);\n        logln(\"Pattern \\\"\" + pat + \"\\\"\");\n        logln(\" Format 123 . \" + s);\n        if (!s.equals(\"afo'ob123\"))\n            errln(\"FAIL: Expected afo'ob123\");\n\n        s =\"\";\n        pat = new StringBuffer(\"a''b#\");\n        fmt = new DecimalFormat(pat.toString(), sym);\n        s = ((NumberFormat)fmt).format(123);\n        logln(\"Pattern \\\"\" + pat + \"\\\"\");\n        logln(\" Format 123 . \" + s);\n        if (!s.equals(\"a'b123\"))\n            errln(\"FAIL: Expected a'b123\");\n    }\n\n    @Test\n    public void TestParseCurrencyTrailingSymbol() {\n        // see sun bug 4709840\n        NumberFormat fmt = NumberFormat.getCurrencyInstance(Locale.GERMANY);\n        float val = 12345.67f;\n        String str = fmt.format(val);\n        logln(\"val: \" + val + \" str: \" + str);\n        try {\n            Number num = fmt.parse(str);\n            logln(\"num: \" + num);\n        } catch (ParseException e) {\n            errln(\"parse of '\" + str + \"' threw exception: \" + e);\n        }\n    }\n\n    /**\n     * Test the handling of the currency symbol in patterns.\n     **/\n    @Test\n    public void TestCurrencySign() {\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(Locale.US);\n        StringBuffer pat = new StringBuffer(\"\");\n        char currency = 0x00A4;\n        // \"\\xA4#,##0.00;-\\xA4#,##0.00\"\n        pat.append(currency).append(\"#,##0.00;-\").append(currency).append(\"#,##0.00\");\n        DecimalFormat fmt = new DecimalFormat(pat.toString(), sym);\n        String s = ((NumberFormat) fmt).format(1234.56);\n        pat = new StringBuffer();\n        logln(\"Pattern \\\"\" + fmt.toPattern() + \"\\\"\");\n        logln(\" Format \" + 1234.56 + \" . \" + s);\n        assertEquals(\"symbol, pos\", \"$1,234.56\", s);\n\n        s = ((NumberFormat) fmt).format(-1234.56);\n        logln(\" Format \" + Double.toString(-1234.56) + \" . \" + s);\n        assertEquals(\"symbol, neg\", \"-$1,234.56\", s);\n\n        pat.setLength(0);\n        // \"\\xA4\\xA4 #,##0.00;\\xA4\\xA4 -#,##0.00\"\n        pat.append(currency).append(currency).append(\" #,##0.00;\").append(currency).append(currency).append(\" -#,##0.00\");\n        fmt = new DecimalFormat(pat.toString(), sym);\n        s = ((NumberFormat) fmt).format(1234.56);\n        logln(\"Pattern \\\"\" + fmt.toPattern() + \"\\\"\");\n        logln(\" Format \" + Double.toString(1234.56) + \" . \" + s);\n        assertEquals(\"name, pos\", \"USD 1,234.56\", s);\n\n        s = ((NumberFormat) fmt).format(-1234.56);\n        logln(\" Format \" + Double.toString(-1234.56) + \" . \" + s);\n        assertEquals(\"name, neg\", \"USD -1,234.56\", s);\n    }\n\n    @Test\n    public void TestSpaceParsing() {\n        // the data are:\n        // the string to be parsed, parsed position, parsed error index\n        String[][] DATA = {\n                {\"$124\", \"4\", \"-1\"},\n                {\"$124 $124\", \"4\", \"-1\"},\n                {\"$124 \", \"4\", \"-1\"},\n                {\"$124  \", \"4\", \"-1\"},\n                {\"$ 124 \", \"5\", \"-1\"},\n                {\"$\\u00A0124 \", \"5\", \"-1\"},\n                {\" $ 124 \", \"6\", \"-1\"},\n                {\"124$\", \"4\", \"-1\"},\n                {\"124 $\", \"5\", \"-1\"},\n                {\"$124\\u200A\", \"4\", \"-1\"},\n                {\"$\\u200A124\", \"5\", \"-1\"},\n        };\n        NumberFormat foo = NumberFormat.getCurrencyInstance();\n        for (int i = 0; i < DATA.length; ++i) {\n            ParsePosition parsePosition = new ParsePosition(0);\n            String stringToBeParsed = DATA[i][0];\n            int parsedPosition = Integer.parseInt(DATA[i][1]);\n            int errorIndex = Integer.parseInt(DATA[i][2]);\n            try {\n                Number result = foo.parse(stringToBeParsed, parsePosition);\n                if (parsePosition.getIndex() != parsedPosition ||\n                        parsePosition.getErrorIndex() != errorIndex) {\n                    errln(\"FAILED parse \" + stringToBeParsed + \"; parse position: \" + parsePosition.getIndex() + \"; error position: \" + parsePosition.getErrorIndex());\n                }\n                if (parsePosition.getErrorIndex() == -1 &&\n                        result.doubleValue() != 124) {\n                    errln(\"FAILED parse \" + stringToBeParsed + \"; value \" + result.doubleValue());\n                }\n            } catch (Exception e) {\n                errln(\"FAILED \" + e.toString());\n            }\n        }\n    }\n\n    @Test\n    public void TestSpaceParsingStrict() {\n        // All trailing grouping separators should be ignored in strict mode, not just the first.\n        Object[][] cases = {\n                {\"123 \", 3, -1},\n                {\"123  \", 3, -1},\n                {\"123  ,\", 3, -1},\n                {\"123,\", 3, -1},\n                {\"123, \", 3, -1},\n                {\"123,,\", 3, -1},\n                {\"123,, \", 3, -1},\n                {\"123,,456\", 3, -1},\n                {\"123 ,\", 3, -1},\n                {\"123, \", 3, -1},\n                {\"123, 456\", 3, -1},\n                {\"123  456\", 3, -1}\n        };\n        DecimalFormat df = new DecimalFormat(\"#,###\");\n        df.setParseStrict(true);\n        for (Object[] cas : cases) {\n            String input = (String) cas[0];\n            int expectedIndex = (Integer) cas[1];\n            int expectedErrorIndex = (Integer) cas[2];\n            ParsePosition ppos = new ParsePosition(0);\n            df.parse(input, ppos);\n            assertEquals(\"Failed on index: '\" + input + \"'\", expectedIndex, ppos.getIndex());\n            assertEquals(\"Failed on error: '\" + input + \"'\", expectedErrorIndex, ppos.getErrorIndex());\n        }\n    }\n\n    @Test\n    public void TestMultiCurrencySign() {\n        String[][] DATA = {\n                // the fields in the following test are:\n                // locale,\n                // currency pattern (with negative pattern),\n                // currency number to be formatted,\n                // currency format using currency symbol name, such as \"$\" for USD,\n                // currency format using currency ISO name, such as \"USD\",\n                // currency format using plural name, such as \"US dollars\".\n                // for US locale\n                {\"en_US\", \"\\u00A4#,##0.00;-\\u00A4#,##0.00\", \"1234.56\", \"$1,234.56\", \"USD\u00a01,234.56\", \"US dollars\u00a01,234.56\"},\n                {\"en_US\", \"\\u00A4#,##0.00;-\\u00A4#,##0.00\", \"-1234.56\", \"-$1,234.56\", \"-USD\u00a01,234.56\", \"-US dollars\u00a01,234.56\"},\n                {\"en_US\", \"\\u00A4#,##0.00;-\\u00A4#,##0.00\", \"1\", \"$1.00\", \"USD\u00a01.00\", \"US dollars\u00a01.00\"},\n                // for CHINA locale\n                {\"zh_CN\", \"\\u00A4#,##0.00;(\\u00A4#,##0.00)\", \"1234.56\", \"\\uFFE51,234.56\", \"CNY\u00a01,234.56\", \"\\u4EBA\\u6C11\\u5E01\u00a01,234.56\"},\n                {\"zh_CN\", \"\\u00A4#,##0.00;(\\u00A4#,##0.00)\", \"-1234.56\", \"(\\uFFE51,234.56)\", \"(CNY\u00a01,234.56)\", \"(\\u4EBA\\u6C11\\u5E01\u00a01,234.56)\"},\n                {\"zh_CN\", \"\\u00A4#,##0.00;(\\u00A4#,##0.00)\", \"1\", \"\\uFFE51.00\", \"CNY\u00a01.00\", \"\\u4EBA\\u6C11\\u5E01\u00a01.00\"}\n        };\n\n        String doubleCurrencyStr = \"\\u00A4\\u00A4\";\n        String tripleCurrencyStr = \"\\u00A4\\u00A4\\u00A4\";\n\n        for (int i=0; i<DATA.length; ++i) {\n            String locale = DATA[i][0];\n            String pat = DATA[i][1];\n            Double numberToBeFormat = new Double(DATA[i][2]);\n            DecimalFormatSymbols sym = new DecimalFormatSymbols(new ULocale(locale));\n            for (int j=1; j<=3; ++j) {\n                // j represents the number of currency sign in the pattern.\n                if (j == 2) {\n                    pat = pat.replaceAll(\"\\u00A4\", doubleCurrencyStr);\n                } else if (j == 3) {\n                    pat = pat.replaceAll(\"\\u00A4\\u00A4\", tripleCurrencyStr);\n                }\n                DecimalFormat fmt = new DecimalFormat(pat, sym);\n                String s = ((NumberFormat) fmt).format(numberToBeFormat);\n                // DATA[i][3] is the currency format result using a\n                // single currency sign.\n                // DATA[i][4] is the currency format result using\n                // double currency sign.\n                // DATA[i][5] is the currency format result using\n                // triple currency sign.\n                // DATA[i][j+2] is the currency format result using\n                // 'j' number of currency sign.\n                String currencyFormatResult = DATA[i][2+j];\n                if (!s.equals(currencyFormatResult)) {\n                    errln(\"FAIL format: Expected \" + currencyFormatResult + \" but got \" + s);\n                }\n                try {\n                    // mix style parsing\n                    for (int k=3; k<=4; ++k) {\n                        // DATA[i][3] is the currency format result using a\n                        // single currency sign.\n                        // DATA[i][4] is the currency format result using\n                        // double currency sign.\n                        // DATA[i][5] is the currency format result using\n                        // triple currency sign.\n                        // ICU 59: long name parsing requires currency mode.\n                        String oneCurrencyFormat = DATA[i][k];\n                        if (fmt.parse(oneCurrencyFormat).doubleValue() !=\n                                numberToBeFormat.doubleValue()) {\n                            errln(\"FAILED parse \" + oneCurrencyFormat);\n                        }\n                    }\n                } catch (ParseException e) {\n                    errln(\"FAILED, DecimalFormat parse currency: \" + e.toString());\n                }\n            }\n        }\n    }\n\n    @Test\n    public void TestCurrencyFormatForMixParsing() {\n        MeasureFormat curFmt = MeasureFormat.getCurrencyFormat(new ULocale(\"en_US\"));\n        String[] formats = {\n                \"$1,234.56\",  // string to be parsed\n                \"USD1,234.56\",\n                \"US dollars1,234.56\",\n                \"1,234.56 US dollars\"\n        };\n        try {\n            for (int i = 0; i < formats.length; ++i) {\n                String stringToBeParsed = formats[i];\n                CurrencyAmount parsedVal = (CurrencyAmount)curFmt.parseObject(stringToBeParsed);\n                Number val = parsedVal.getNumber();\n                if (!val.equals(new BigDecimal(\"1234.56\"))) {\n                    errln(\"FAIL: getCurrencyFormat of default locale (en_US) failed roundtripping the number. val=\" + val);\n                }\n                if (!parsedVal.getCurrency().equals(Currency.getInstance(\"USD\"))) {\n                    errln(\"FAIL: getCurrencyFormat of default locale (en_US) failed roundtripping the currency\");\n                }\n            }\n        } catch (ParseException e) {\n            errln(\"parse FAILED: \" + e.toString());\n        }\n    }\n\n\n    /** Starting in ICU 62, strict mode is actually strict with currency formats. */\n    @Test\n    public void TestMismatchedCurrencyFormatFail() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getCurrencyInstance(ULocale.ENGLISH);\n        assertEquals(\"Test assumes that currency sign is at the beginning\",\n                \"\\u00A4#,##0.00\",\n                df.toPattern());\n        // Should round-trip on the correct currency format:\n        expect2(df, 1.23, \"\\u00A41.23\");\n        df.setCurrency(Currency.getInstance(\"EUR\"));\n        expect2(df, 1.23, \"\\u20AC1.23\");\n        // Should parse with currency in the wrong place in lenient mode\n        df.setParseStrict(false);\n        expect(df, \"1.23\\u20AC\", 1.23);\n        expectParseCurrency(df, Currency.getInstance(\"EUR\"), \"1.23\\u20AC\");\n        // Should NOT parse with currency in the wrong place in STRICT mode\n        df.setParseStrict(true);\n        {\n            ParsePosition ppos = new ParsePosition(0);\n            df.parse(\"1.23\\u20AC\", ppos);\n            assertEquals(\"Should fail to parse\", 0, ppos.getIndex());\n        }\n        {\n            ParsePosition ppos = new ParsePosition(0);\n            df.parseCurrency(\"1.23\\u20AC\", ppos);\n            assertEquals(\"Should fail to parse currency\", 0, ppos.getIndex());\n        }\n    }\n\n    @Test\n    public void TestDecimalFormatCurrencyParse() {\n        // Locale.US\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(Locale.US);\n        StringBuffer pat = new StringBuffer(\"\");\n        char currency = 0x00A4;\n        // \"\\xA4#,##0.00;-\\xA4#,##0.00\"\n        pat.append(currency).append(currency).append(currency).append(\"#,##0.00;-\").append(currency).append(currency).append(currency).append(\"#,##0.00\");\n        DecimalFormat fmt = new DecimalFormat(pat.toString(), sym);\n        String[][] DATA = {\n                // the data are:\n                // string to be parsed, the parsed result (number)\n                {\"$1.00\", \"1\"},\n                {\"USD1.00\", \"1\"},\n                {\"1.00 US dollar\", \"1\"},\n                {\"$1,234.56\", \"1234.56\"},\n                {\"USD1,234.56\", \"1234.56\"},\n                {\"1,234.56 US dollar\", \"1234.56\"},\n        };\n        try {\n            for (int i = 0; i < DATA.length; ++i) {\n                String stringToBeParsed = DATA[i][0];\n                double parsedResult = Double.parseDouble(DATA[i][1]);\n                Number num = fmt.parse(stringToBeParsed);\n                if (num.doubleValue() != parsedResult) {\n                    errln(\"FAIL parse: Expected \" + parsedResult);\n                }\n            }\n        } catch (ParseException e) {\n            errln(\"FAILED, DecimalFormat parse currency: \" + e.toString());\n        }\n    }\n\n    /**\n     * Test localized currency patterns.\n     */\n    @Test\n    public void TestCurrency() {\n        String[] DATA = {\n                \"fr\", \"CA\", \"\", \"1,50\\u00a0$\",\n                \"de\", \"DE\", \"\", \"1,50\\u00a0\\u20AC\",\n                \"de\", \"DE\", \"PREEURO\", \"1,50\\u00a0DM\",\n                \"fr\", \"FR\", \"\", \"1,50\\u00a0\\u20AC\",\n                \"fr\", \"FR\", \"PREEURO\", \"1,50\\u00a0F\",\n        };\n\n        for (int i=0; i<DATA.length; i+=4) {\n            Locale locale = new Locale(DATA[i], DATA[i+1], DATA[i+2]);\n            NumberFormat fmt = NumberFormat.getCurrencyInstance(locale);\n            String s = fmt.format(1.50);\n            if (s.equals(DATA[i+3])) {\n                logln(\"Ok: 1.50 x \" + locale + \" => \" + s);\n            } else {\n                logln(\"FAIL: 1.50 x \" + locale + \" => \" + s +\n                        \", expected \" + DATA[i+3]);\n            }\n        }\n\n        // format currency with CurrencyAmount\n        for (int i=0; i<DATA.length; i+=4) {\n            Locale locale = new Locale(DATA[i], DATA[i+1], DATA[i+2]);\n\n            Currency curr = Currency.getInstance(locale);\n            logln(\"\\nName of the currency is: \" + curr.getName(locale, Currency.LONG_NAME, new boolean[] {false}));\n            CurrencyAmount cAmt = new CurrencyAmount(1.5, curr);\n            logln(\"CurrencyAmount object's hashCode is: \" + cAmt.hashCode()); //cover hashCode\n\n            NumberFormat fmt = NumberFormat.getCurrencyInstance(locale);\n            String sCurr = fmt.format(cAmt);\n            if (sCurr.equals(DATA[i+3])) {\n                logln(\"Ok: 1.50 x \" + locale + \" => \" + sCurr);\n            } else {\n                errln(\"FAIL: 1.50 x \" + locale + \" => \" + sCurr +\n                        \", expected \" + DATA[i+3]);\n            }\n        }\n\n        //Cover MeasureFormat.getCurrencyFormat()\n        ULocale save = ULocale.getDefault();\n        ULocale.setDefault(ULocale.US);\n        MeasureFormat curFmt = MeasureFormat.getCurrencyFormat();\n        String strBuf = curFmt.format(new CurrencyAmount(new Float(1234.56), Currency.getInstance(\"USD\")));\n\n        try {\n            CurrencyAmount parsedVal = (CurrencyAmount)curFmt.parseObject(strBuf);\n            Number val = parsedVal.getNumber();\n            if (!val.equals(new BigDecimal(\"1234.56\"))) {\n                errln(\"FAIL: getCurrencyFormat of default locale (en_US) failed roundtripping the number. val=\" + val);\n            }\n            if (!parsedVal.getCurrency().equals(Currency.getInstance(\"USD\"))) {\n                errln(\"FAIL: getCurrencyFormat of default locale (en_US) failed roundtripping the currency\");\n            }\n        }\n        catch (ParseException e) {\n            errln(\"FAIL: \" + e.getMessage());\n        }\n        ULocale.setDefault(save);\n    }\n\n    @Test\n    public void TestJavaCurrencyConversion() {\n        java.util.Currency gbpJava = java.util.Currency.getInstance(\"GBP\");\n        Currency gbpIcu = Currency.getInstance(\"GBP\");\n        assertEquals(\"ICU should equal API value\", gbpIcu, Currency.fromJavaCurrency(gbpJava));\n        assertEquals(\"Java should equal API value\", gbpJava, gbpIcu.toJavaCurrency());\n        // Test CurrencyAmount constructors\n        CurrencyAmount ca1 = new CurrencyAmount(123.45, gbpJava);\n        CurrencyAmount ca2 = new CurrencyAmount(123.45, gbpIcu);\n        assertEquals(\"CurrencyAmount from both Double constructors should be equal\", ca1, ca2);\n        // Coverage for the Number constructor\n        ca1 = new CurrencyAmount(new BigDecimal(\"543.21\"), gbpJava);\n        ca2 = new CurrencyAmount(new BigDecimal(\"543.21\"), gbpIcu);\n        assertEquals(\"CurrencyAmount from both Number constructors should be equal\", ca1, ca2);\n    }\n\n    @Test\n    public void TestCurrencyIsoPluralFormat() {\n        String[][] DATA = {\n                // the data are:\n                // locale,\n                // currency amount to be formatted,\n                // currency ISO code to be formatted,\n                // format result using CURRENCYSTYLE,\n                // format result using ISOCURRENCYSTYLE,\n                // format result using PLURALCURRENCYSTYLE,\n                {\"en_US\", \"1\", \"USD\", \"$1.00\", \"USD\u00a01.00\", \"1.00 US dollars\"},\n                {\"en_US\", \"1234.56\", \"USD\", \"$1,234.56\", \"USD\u00a01,234.56\", \"1,234.56 US dollars\"},\n                {\"en_US\", \"-1234.56\", \"USD\", \"-$1,234.56\", \"-USD\u00a01,234.56\", \"-1,234.56 US dollars\"},\n                {\"zh_CN\", \"1\", \"USD\", \"US$1.00\", \"USD\u00a01.00\", \"1.00\u00a0\u7f8e\u5143\"},\n                {\"zh_CN\", \"1234.56\", \"USD\", \"US$1,234.56\", \"USD\u00a01,234.56\", \"1,234.56\u00a0\u7f8e\u5143\"},\n                {\"zh_CN\", \"1\", \"CNY\", \"\uffe51.00\", \"CNY\u00a01.00\", \"1.00\u00a0\u4eba\u6c11\u5e01\"},\n                {\"zh_CN\", \"1234.56\", \"CNY\", \"\uffe51,234.56\", \"CNY\u00a01,234.56\", \"1,234.56\u00a0\u4eba\u6c11\u5e01\"},\n                {\"ru_RU\", \"1\", \"RUB\", \"1,00\u00a0\\u20BD\", \"1,00\u00a0RUB\", \"1,00 \u0440\u043e\u0441\u0441\u0438\u0439\u0441\u043a\u043e\u0433\u043e \u0440\u0443\u0431\u043b\u044f\"},\n                {\"ru_RU\", \"2\", \"RUB\", \"2,00\u00a0\\u20BD\", \"2,00\u00a0RUB\", \"2,00 \u0440\u043e\u0441\u0441\u0438\u0439\u0441\u043a\u043e\u0433\u043e \u0440\u0443\u0431\u043b\u044f\"},\n                {\"ru_RU\", \"5\", \"RUB\", \"5,00\u00a0\\u20BD\", \"5,00\u00a0RUB\", \"5,00 \u0440\u043e\u0441\u0441\u0438\u0439\u0441\u043a\u043e\u0433\u043e \u0440\u0443\u0431\u043b\u044f\"},\n                // test locale without currency information\n                {\"root\", \"-1.23\", \"USD\", \"-US$\u00a01.23\", \"-USD\u00a01.23\", \"-1.23 USD\"},\n                {\"root@numbers=latn\", \"-1.23\", \"USD\", \"-US$\u00a01.23\", \"-USD\u00a01.23\", \"-1.23 USD\"}, // ensure that the root locale is still used with modifiers\n                {\"root@numbers=arab\", \"-1.23\", \"USD\", \"\\u061C-\\u0661\\u066B\\u0662\\u0663\\u00A0US$\", \"\\u061C-\\u0661\\u066B\\u0662\\u0663\\u00A0USD\", \"\\u061C-\\u0661\\u066B\\u0662\\u0663 USD\"}, // ensure that the root locale is still used with modifiers\n                {\"es_AR\", \"1\", \"INR\", \"INR\\u00A01,00\", \"INR\\u00A01,00\", \"1,00 rupia india\"},\n                {\"ar_EG\", \"1\", \"USD\", \"\u0661\u066b\u0660\u0660\\u00A0US$\", \"\u0661\u066b\u0660\u0660\\u00A0USD\", \"\u0661\u066b\u0660\u0660 \u062f\u0648\u0644\u0627\u0631 \u0623\u0645\u0631\u064a\u0643\u064a\"},\n        };\n\n        for (int i=0; i<DATA.length; ++i) {\n            for (int k = NumberFormat.CURRENCYSTYLE;\n                    k <= NumberFormat.PLURALCURRENCYSTYLE;\n                    ++k) {\n                // k represents currency format style.\n                if ( k != NumberFormat.CURRENCYSTYLE &&\n                        k != NumberFormat.ISOCURRENCYSTYLE &&\n                        k != NumberFormat.PLURALCURRENCYSTYLE ) {\n                    continue;\n                }\n                String localeString = DATA[i][0];\n                Double numberToBeFormat = new Double(DATA[i][1]);\n                String currencyISOCode = DATA[i][2];\n                ULocale locale = new ULocale(localeString);\n                NumberFormat numFmt = NumberFormat.getInstance(locale, k);\n                numFmt.setCurrency(Currency.getInstance(currencyISOCode));\n                String strBuf = numFmt.format(numberToBeFormat);\n                int resultDataIndex = k-1;\n                if ( k == NumberFormat.CURRENCYSTYLE ) {\n                    resultDataIndex = k+2;\n                }\n                // DATA[i][resultDataIndex] is the currency format result\n                // using 'k' currency style.\n                String formatResult = DATA[i][resultDataIndex];\n                if (!strBuf.equals(formatResult)) {\n                    errln(\"FAIL: localeID: \" + localeString + \", expected(\" + formatResult.length() + \"): \\\"\" + formatResult + \"\\\", actual(\" + strBuf.length() + \"): \\\"\" + strBuf + \"\\\"\");\n                }\n                // test parsing, and test parsing for all currency formats.\n                for (int j = 3; j < 6; ++j) {\n                    // DATA[i][3] is the currency format result using\n                    // CURRENCYSTYLE formatter.\n                    // DATA[i][4] is the currency format result using\n                    // ISOCURRENCYSTYLE formatter.\n                    // DATA[i][5] is the currency format result using\n                    // PLURALCURRENCYSTYLE formatter.\n                    String oneCurrencyFormatResult = DATA[i][j];\n                    CurrencyAmount val = numFmt.parseCurrency(oneCurrencyFormatResult, null);\n                    if (val.getNumber().doubleValue() != numberToBeFormat.doubleValue()) {\n                        errln(\"FAIL: getCurrencyFormat of locale \" + localeString + \" failed roundtripping the number. val=\" + val + \"; expected: \" + numberToBeFormat);\n                    }\n                }\n            }\n        }\n    }\n\n\n    @Test\n    public void TestMiscCurrencyParsing() {\n        String[][] DATA = {\n                // each has: string to be parsed, parsed position, error position\n                {\"1.00 \", \"4\", \"-1\", \"0\", \"4\"},\n                {\"1.00 UAE dirha\", \"4\", \"-1\", \"0\", \"4\"},\n                {\"1.00 us dollar\", \"14\", \"-1\", \"14\", \"-1\"},\n                {\"1.00 US DOLLAR\", \"14\", \"-1\", \"14\", \"-1\"},\n                {\"1.00 usd\", \"8\", \"-1\", \"8\", \"-1\"},\n                {\"1.00 USD\", \"8\", \"-1\", \"8\", \"-1\"},\n        };\n        ULocale locale = new ULocale(\"en_US\");\n        for (int i=0; i<DATA.length; ++i) {\n            String stringToBeParsed = DATA[i][0];\n            int parsedPosition = Integer.parseInt(DATA[i][1]);\n            int errorIndex = Integer.parseInt(DATA[i][2]);\n            int currParsedPosition = Integer.parseInt(DATA[i][3]);\n            int currErrorIndex = Integer.parseInt(DATA[i][4]);\n            NumberFormat numFmt = NumberFormat.getInstance(locale, NumberFormat.CURRENCYSTYLE);\n            ParsePosition parsePosition = new ParsePosition(0);\n            Number val = numFmt.parse(stringToBeParsed, parsePosition);\n            if (parsePosition.getIndex() != parsedPosition ||\n                    parsePosition.getErrorIndex() != errorIndex) {\n                errln(\"FAIL: parse failed on case \"+i+\". expected position: \" + parsedPosition +\"; actual: \" + parsePosition.getIndex());\n                errln(\"FAIL: parse failed on case \"+i+\". expected error position: \" + errorIndex + \"; actual: \" + parsePosition.getErrorIndex());\n            }\n            if (parsePosition.getErrorIndex() == -1 &&\n                    val.doubleValue() != 1.00) {\n                errln(\"FAIL: parse failed. expected 1.00, actual:\" + val);\n            }\n            parsePosition = new ParsePosition(0);\n            CurrencyAmount amt = numFmt.parseCurrency(stringToBeParsed, parsePosition);\n            if (parsePosition.getIndex() != currParsedPosition ||\n                    parsePosition.getErrorIndex() != currErrorIndex) {\n                errln(\"FAIL: parseCurrency failed on case \"+i+\". expected error position: \" + currErrorIndex + \"; actual: \" + parsePosition.getErrorIndex());\n                errln(\"FAIL: parseCurrency failed on case \"+i+\". expected position: \" + currParsedPosition +\"; actual: \" + parsePosition.getIndex());\n            }\n            if (parsePosition.getErrorIndex() == -1 &&\n                    amt.getNumber().doubleValue() != 1.00) {\n                errln(\"FAIL: parseCurrency failed. expected 1.00, actual:\" + val);\n            }\n        }\n    }\n\n    @Test\n    public void TestParseCurrency() {\n        class ParseCurrencyItem {\n            private final String localeString;\n            private final String descrip;\n            private final String currStr;\n            private final int    doubExpectPos;\n            private final int    doubExpectVal;\n            private final int    curExpectPos;\n            private final int    curExpectVal;\n            private final String curExpectCurr;\n\n            ParseCurrencyItem(String locStr, String desc, String curr, int doubExPos, int doubExVal, int curExPos, int curExVal, String curExCurr) {\n                localeString  = locStr;\n                descrip       = desc;\n                currStr       = curr;\n                doubExpectPos  = doubExPos;\n                doubExpectVal  = doubExVal;\n                curExpectPos  = curExPos;\n                curExpectVal  = curExVal;\n                curExpectCurr = curExCurr;\n            }\n            public String getLocaleString()  { return localeString; }\n            public String getDescrip()       { return descrip; }\n            public String getCurrStr()       { return currStr; }\n            public int    getDoubExpectPos()  { return doubExpectPos; }\n            public int    getDoubExpectVal()  { return doubExpectVal; }\n            public int    getCurExpectPos()  { return curExpectPos; }\n            public int    getCurExpectVal()  { return curExpectVal; }\n            public String getCurExpectCurr() { return curExpectCurr; }\n        }\n        // Note: In cases where the number occurs before the currency sign, non-currency mode will parse the number\n        // and stop when it reaches the currency symbol.\n        final ParseCurrencyItem[] parseCurrencyItems = {\n                new ParseCurrencyItem( \"en_US\", \"dollars2\", \"$2.00\",            5,  2,  5,  2,  \"USD\" ),\n                new ParseCurrencyItem( \"en_US\", \"dollars4\", \"$4\",               2,  4,  2,  4,  \"USD\" ),\n                new ParseCurrencyItem( \"en_US\", \"dollars9\", \"9\\u00A0$\",         3,  9,  3,  9,  \"USD\" ),\n                new ParseCurrencyItem( \"en_US\", \"pounds3\",  \"\\u00A33.00\",       0,  0,  5,  3,  \"GBP\" ),\n                new ParseCurrencyItem( \"en_US\", \"pounds5\",  \"\\u00A35\",          0,  0,  2,  5,  \"GBP\" ),\n                new ParseCurrencyItem( \"en_US\", \"pounds7\",  \"7\\u00A0\\u00A3\",    1,  7,  3,  7,  \"GBP\" ),\n                new ParseCurrencyItem( \"en_US\", \"euros8\",   \"\\u20AC8\",          0,  0,  2,  8,  \"EUR\" ),\n\n                new ParseCurrencyItem( \"en_GB\", \"pounds3\",  \"\\u00A33.00\",       5,  3,  5,  3,  \"GBP\" ),\n                new ParseCurrencyItem( \"en_GB\", \"pounds5\",  \"\\u00A35\",          2,  5,  2,  5,  \"GBP\" ),\n                new ParseCurrencyItem( \"en_GB\", \"pounds7\",  \"7\\u00A0\\u00A3\",    3,  7,  3,  7,  \"GBP\" ),\n                new ParseCurrencyItem( \"en_GB\", \"euros4\",   \"4,00\\u00A0\\u20AC\", 4,400,  6,400,  \"EUR\" ),\n                new ParseCurrencyItem( \"en_GB\", \"euros6\",   \"6\\u00A0\\u20AC\",    1,  6,  3,  6,  \"EUR\" ),\n                new ParseCurrencyItem( \"en_GB\", \"euros8\",   \"\\u20AC8\",          0,  0,  2,  8,  \"EUR\" ),\n                new ParseCurrencyItem( \"en_GB\", \"dollars4\", \"US$4\",             0,  0,  4,  4,  \"USD\" ),\n\n                new ParseCurrencyItem( \"fr_FR\", \"euros4\",   \"4,00\\u00A0\\u20AC\", 6,  4,  6,  4,  \"EUR\" ),\n                new ParseCurrencyItem( \"fr_FR\", \"euros6\",   \"6\\u00A0\\u20AC\",    3,  6,  3,  6,  \"EUR\" ),\n                new ParseCurrencyItem( \"fr_FR\", \"euros8\",   \"\\u20AC8\",          2,  8,  2,  8,  \"EUR\" ),\n                new ParseCurrencyItem( \"fr_FR\", \"dollars2\", \"$2.00\",            0,  0,  0,  0,  \"\"    ),\n                new ParseCurrencyItem( \"fr_FR\", \"dollars4\", \"$4\",               0,  0,  0,  0,  \"\"    ),\n        };\n        for (ParseCurrencyItem item: parseCurrencyItems) {\n            String localeString = item.getLocaleString();\n            ULocale uloc = new ULocale(localeString);\n            NumberFormat fmt = null;\n            try {\n                fmt = NumberFormat.getCurrencyInstance(uloc);\n            } catch (Exception e) {\n                errln(\"NumberFormat.getCurrencyInstance fails for locale \" + localeString);\n                continue;\n            }\n            String currStr = item.getCurrStr();\n            ParsePosition parsePos = new ParsePosition(0);\n\n            Number numVal = fmt.parse(currStr, parsePos);\n            if ( parsePos.getIndex() != item.getDoubExpectPos() || (numVal != null && numVal.intValue() != item.getDoubExpectVal()) ) {\n                if (numVal != null) {\n                    errln(\"NumberFormat.getCurrencyInstance parse \" + localeString + \"/\" + item.getDescrip() +\n                            \", expect pos/val \" + item.getDoubExpectPos() + \"/\" + item.getDoubExpectVal() +\n                            \", get \" + parsePos.getIndex() + \"/\" + numVal.intValue() );\n                } else {\n                    errln(\"NumberFormat.getCurrencyInstance parse \" + localeString + \"/\" + item.getDescrip() +\n                            \", expect pos/val \" + item.getDoubExpectPos() + \"/\" + item.getDoubExpectVal() +\n                            \", get \" + parsePos.getIndex() + \"/(NULL)\" );\n                }\n            }\n\n            parsePos.setIndex(0);\n            int curExpectPos = item.getCurExpectPos();\n            CurrencyAmount currAmt = fmt.parseCurrency(currStr, parsePos);\n            if ( parsePos.getIndex() != curExpectPos || (currAmt != null && (currAmt.getNumber().intValue() != item.getCurExpectVal() ||\n                    currAmt.getCurrency().getCurrencyCode().compareTo(item.getCurExpectCurr()) != 0)) ) {\n                if (currAmt != null) {\n                    errln(\"NumberFormat.getCurrencyInstance parseCurrency \" + localeString + \"/\" + item.getDescrip() +\n                            \", expect pos/val/curr \" + curExpectPos + \"/\" + item.getCurExpectVal() + \"/\" + item.getCurExpectCurr() +\n                            \", get \" + parsePos.getIndex() + \"/\" + currAmt.getNumber().intValue() + \"/\" + currAmt.getCurrency().getCurrencyCode() );\n                } else {\n                    errln(\"NumberFormat.getCurrencyInstance parseCurrency \" + localeString + \"/\" + item.getDescrip() +\n                            \", expect pos/val/curr \" + curExpectPos + \"/\" + item.getCurExpectVal() + \"/\" + item.getCurExpectCurr() +\n                            \", get \" + parsePos.getIndex() + \"/(NULL)\" );\n                }\n            }\n        }\n    }\n\n    @Test\n    public void TestParseCurrencyWithWhitespace() {\n        DecimalFormat df = new DecimalFormat(\"#,##0.00 \u00a4\u00a4\");\n        ParsePosition ppos = new ParsePosition(0);\n        df.parseCurrency(\"1.00 us denmark\", ppos);\n        assertEquals(\"Expected to fail on 'us denmark' string\", 4, ppos.getErrorIndex());\n    }\n\n    @Test\n    public void TestParseCurrPatternWithDecStyle() {\n        String currpat = \"\u00a4#,##0.00\";\n        String parsetxt = \"x0y$\";\n        DecimalFormat decfmt = (DecimalFormat)NumberFormat.getInstance(new ULocale(\"en_US\"), NumberFormat.NUMBERSTYLE);\n        decfmt.applyPattern(currpat);\n        ParsePosition ppos = new ParsePosition(0);\n        Number value = decfmt.parse(parsetxt, ppos);\n        if (ppos.getIndex() != 0) {\n            errln(\"DecimalFormat.parse expected to fail but got ppos \" + ppos.getIndex() + \", value \" + value);\n        }\n    }\n\n    /**\n     * Test the Currency object handling, new as of ICU 2.2.\n     */\n    @Test\n    public void TestCurrencyObject() {\n        NumberFormat fmt =\n                NumberFormat.getCurrencyInstance(Locale.US);\n\n        expectCurrency(fmt, null, 1234.56, \"$1,234.56\");\n\n        expectCurrency(fmt, Currency.getInstance(Locale.FRANCE),\n                1234.56, \"\\u20AC1,234.56\"); // Euro\n\n        expectCurrency(fmt, Currency.getInstance(Locale.JAPAN),\n                1234.56, \"\\u00A51,235\"); // Yen\n\n        expectCurrency(fmt, Currency.getInstance(new Locale(\"fr\", \"CH\", \"\")),\n                1234.56, \"CHF 1,234.56\"); // no more 0.05 rounding here, see cldrbug 5548\n\n        expectCurrency(fmt, Currency.getInstance(Locale.US),\n                1234.56, \"$1,234.56\");\n\n        fmt = NumberFormat.getCurrencyInstance(Locale.FRANCE);\n\n        expectCurrency(fmt, null, 1234.56, \"1\\u202F234,56 \\u20AC\");\n\n        expectCurrency(fmt, Currency.getInstance(Locale.JAPAN),\n                1234.56, \"1\\u202F235 JPY\"); // Yen\n\n        expectCurrency(fmt, Currency.getInstance(new Locale(\"fr\", \"CH\", \"\")),\n                1234.56, \"1\\u202F234,56 CHF\"); // no more rounding here, see cldrbug 5548\n\n        expectCurrency(fmt, Currency.getInstance(Locale.US),\n                1234.56, \"1\\u202F234,56 $US\");\n\n        expectCurrency(fmt, Currency.getInstance(Locale.FRANCE),\n                1234.56, \"1\\u202F234,56 \\u20AC\"); // Euro\n    }\n\n    @Test\n    public void TestCompatibleCurrencies() {\n        NumberFormat fmt =\n                NumberFormat.getCurrencyInstance(Locale.US);\n        expectParseCurrency(fmt, Currency.getInstance(Locale.JAPAN), \"\\u00A51,235\"); // Yen half-width\n        expectParseCurrency(fmt, Currency.getInstance(Locale.JAPAN), \"\\uFFE51,235\"); // Yen full-wdith\n    }\n\n    @Test\n    public void TestCurrencyPatterns() {\n        int i;\n        Random rnd = new Random(2017);\n        Locale[] locs = NumberFormat.getAvailableLocales();\n        for (i=0; i<locs.length; ++i) {\n            if (rnd.nextDouble() < 0.9) {\n                // Check a random subset for speed:\n                // Otherwise, this test takes a large fraction of the entire time.\n                continue;\n            }\n            NumberFormat nf = NumberFormat.getCurrencyInstance(locs[i]);\n            // Make sure currency formats do not have a variable number\n            // of fraction digits\n            int min = nf.getMinimumFractionDigits();\n            int max = nf.getMaximumFractionDigits();\n            if (min != max) {\n                String a = nf.format(1.0);\n                String b = nf.format(1.125);\n                errln(\"FAIL: \" + locs[i] +\n                        \" min fraction digits != max fraction digits; \"+\n                        \"x 1.0 => \" + a +\n                        \"; x 1.125 => \" + b);\n            }\n\n            // Make sure EURO currency formats have exactly 2 fraction digits\n            if (nf instanceof DecimalFormat) {\n                Currency curr = ((DecimalFormat) nf).getCurrency();\n                if (curr != null && \"EUR\".equals(curr.getCurrencyCode())) {\n                    if (min != 2 || max != 2) {\n                        String a = nf.format(1.0);\n                        errln(\"FAIL: \" + locs[i] +\n                                \" is a EURO format but it does not have 2 fraction digits; \"+\n                                \"x 1.0 => \" +\n                                a);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Do rudimentary testing of parsing.\n     */\n    @Test\n    public void TestParse() {\n        String arg = \"0.0\";\n        DecimalFormat format = new DecimalFormat(\"00\");\n        double aNumber = 0l;\n        try {\n            aNumber = format.parse(arg).doubleValue();\n        } catch (ParseException e) {\n            System.out.println(e);\n        }\n        logln(\"parse(\" + arg + \") = \" + aNumber);\n    }\n\n    /**\n     * Test proper rounding by the format method.\n     */\n    @Test\n    public void TestRounding487() {\n\n        NumberFormat nf = NumberFormat.getInstance();\n        roundingTest(nf, 0.00159999, 4, \"0.0016\");\n        roundingTest(nf, 0.00995, 4, \"0.01\");\n\n        roundingTest(nf, 12.3995, 3, \"12.4\");\n\n        roundingTest(nf, 12.4999, 0, \"12\");\n        roundingTest(nf, - 19.5, 0, \"-20\");\n\n    }\n\n    /**\n     * Test the functioning of the secondary grouping value.\n     */\n    @Test\n    public void TestSecondaryGrouping() {\n\n        DecimalFormatSymbols US = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat f = new DecimalFormat(\"#,##,###\", US);\n\n        expect(f, 123456789L, \"12,34,56,789\");\n        expectPat(f, \"#,##,##0\");\n        f.applyPattern(\"#,###\");\n\n        f.setSecondaryGroupingSize(4);\n        expect(f, 123456789L, \"12,3456,789\");\n        expectPat(f, \"#,####,##0\");\n        NumberFormat g = NumberFormat.getInstance(new Locale(\"hi\", \"IN\"));\n\n        String out = \"\";\n        long l = 1876543210L;\n        out = g.format(l);\n\n        // expect \"1,87,65,43,210\", but with Hindi digits\n        //         01234567890123\n        boolean ok = true;\n        if (out.length() != 14) {\n            ok = false;\n        } else {\n            for (int i = 0; i < out.length(); ++i) {\n                boolean expectGroup = false;\n                switch (i) {\n                case 1 :\n                case 4 :\n                case 7 :\n                case 10 :\n                    expectGroup = true;\n                    break;\n                }\n                // Later -- fix this to get the actual grouping\n                // character from the resource bundle.\n                boolean isGroup = (out.charAt(i) == 0x002C);\n                if (isGroup != expectGroup) {\n                    ok = false;\n                    break;\n                }\n            }\n        }\n        if (!ok) {\n            errln(\"FAIL  Expected \"+ l + \" x hi_IN . \\\"1,87,65,43,210\\\" (with Hindi digits), got \\\"\"\n                    + out + \"\\\"\");\n        } else {\n            logln(\"Ok    \" + l + \" x hi_IN . \\\"\" + out + \"\\\"\");\n        }\n    }\n\n    /*\n     * Internal test utility.\n     */\n    private void roundingTest(NumberFormat nf, double x, int maxFractionDigits, final String expected) {\n        nf.setMaximumFractionDigits(maxFractionDigits);\n        String out = nf.format(x);\n        logln(x + \" formats with \" + maxFractionDigits + \" fractional digits to \" + out);\n        if (!out.equals(expected))\n            errln(\"FAIL: Expected \" + expected);\n    }\n\n    /**\n     * Upgrade to alphaWorks\n     */\n    @Test\n    public void TestExponent() {\n        DecimalFormatSymbols US = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat fmt1 = new DecimalFormat(\"0.###E0\", US);\n        DecimalFormat fmt2 = new DecimalFormat(\"0.###E+0\", US);\n        int n = 1234;\n        expect2(fmt1, n, \"1.234E3\");\n        expect2(fmt2, n, \"1.234E+3\");\n        expect(fmt1, \"1.234E+3\", n); // Either format should parse \"E+3\"\n\n    }\n\n    /**\n     * Upgrade to alphaWorks\n     */\n    @Test\n    public void TestScientific() {\n\n        DecimalFormatSymbols US = new DecimalFormatSymbols(Locale.US);\n\n        // Test pattern round-trip\n        final String PAT[] = { \"#E0\", \"0.####E0\", \"00.000E00\", \"##0.####E000\", \"0.###E0;[0.###E0]\" };\n        int PAT_length = PAT.length;\n        int DIGITS[] = {\n                // min int, max int, min frac, max frac\n                0, 1, 0, 0, // \"#E0\"\n                1, 1, 0, 4, // \"0.####E0\"\n                2, 2, 3, 3, // \"00.000E00\"\n                1, 3, 0, 4, // \"##0.####E000\"\n                1, 1, 0, 3, // \"0.###E0;[0.###E0]\"\n        };\n        for (int i = 0; i < PAT_length; ++i) {\n            String pat = PAT[i];\n            DecimalFormat df = new DecimalFormat(pat, US);\n            String pat2 = df.toPattern();\n            if (pat.equals(pat2)) {\n                logln(\"Ok   Pattern rt \\\"\" + pat + \"\\\" . \\\"\" + pat2 + \"\\\"\");\n            } else {\n                errln(\"FAIL Pattern rt \\\"\" + pat + \"\\\" . \\\"\" + pat2 + \"\\\"\");\n            }\n            // Make sure digit counts match what we expect\n            if (i == 0) continue; // outputs to 1,1,0,0 since at least one min digit is required.\n            if (df.getMinimumIntegerDigits() != DIGITS[4 * i]\n                    || df.getMaximumIntegerDigits() != DIGITS[4 * i + 1]\n                            || df.getMinimumFractionDigits() != DIGITS[4 * i + 2]\n                                    || df.getMaximumFractionDigits() != DIGITS[4 * i + 3]) {\n                errln(\"FAIL \\\"\"+ pat+ \"\\\" min/max int; min/max frac = \"\n                        + df.getMinimumIntegerDigits() + \"/\"\n                        + df.getMaximumIntegerDigits() + \";\"\n                        + df.getMinimumFractionDigits() + \"/\"\n                        + df.getMaximumFractionDigits() + \", expect \"\n                        + DIGITS[4 * i] + \"/\"\n                        + DIGITS[4 * i + 1] + \";\"\n                        + DIGITS[4 * i + 2] + \"/\"\n                        + DIGITS[4 * i + 3]);\n            }\n        }\n\n        expect2(new DecimalFormat(\"#E0\", US), 12345.0, \"1.2345E4\");\n        expect(new DecimalFormat(\"0E0\", US), 12345.0, \"1E4\");\n\n        // pattern of NumberFormat.getScientificInstance(Locale.US) = \"0.######E0\" not \"#E0\"\n        // so result = 1.234568E4 not 1.2345678901E4\n        //when the pattern problem is finalized, delete comment mark'//'\n        //of the following code\n        expect2(NumberFormat.getScientificInstance(Locale.US), 12345.678901, \"1.2345678901E4\");\n        logln(\"Testing NumberFormat.getScientificInstance(ULocale) ...\");\n        expect2(NumberFormat.getScientificInstance(ULocale.US), 12345.678901, \"1.2345678901E4\");\n\n        expect(new DecimalFormat(\"##0.###E0\", US), 12345.0, \"12.34E3\");\n        expect(new DecimalFormat(\"##0.###E0\", US), 12345.00001, \"12.35E3\");\n        expect2(new DecimalFormat(\"##0.####E0\", US), 12345, \"12.345E3\");\n\n        // pattern of NumberFormat.getScientificInstance(Locale.US) = \"0.######E0\" not \"#E0\"\n        // so result = 1.234568E4 not 1.2345678901E4\n        expect2(NumberFormat.getScientificInstance(Locale.FRANCE), 12345.678901, \"1,2345678901E4\");\n        logln(\"Testing NumberFormat.getScientificInstance(ULocale) ...\");\n        expect2(NumberFormat.getScientificInstance(ULocale.FRANCE), 12345.678901, \"1,2345678901E4\");\n\n        expect(new DecimalFormat(\"##0.####E0\", US), 789.12345e-9, \"789.12E-9\");\n        expect2(new DecimalFormat(\"##0.####E0\", US), 780.e-9, \"780E-9\");\n        expect(new DecimalFormat(\".###E0\", US), 45678.0, \".457E5\");\n        expect2(new DecimalFormat(\".###E0\", US), 0, \".0E0\");\n        /*\n        expect(new DecimalFormat[] { new DecimalFormat(\"#E0\", US),\n                                     new DecimalFormat(\"##E0\", US),\n                                     new DecimalFormat(\"####E0\", US),\n                                     new DecimalFormat(\"0E0\", US),\n                                     new DecimalFormat(\"00E0\", US),\n                                     new DecimalFormat(\"000E0\", US),\n                                   },\n               new Long(45678000),\n               new String[] { \"4.5678E7\",\n                              \"45.678E6\",\n                              \"4567.8E4\",\n                              \"5E7\",\n                              \"46E6\",\n                              \"457E5\",\n                            }\n               );\n        !\n        ! Unroll this test into individual tests below...\n        !\n         */\n        expect2(new DecimalFormat(\"#E0\", US), 45678000, \"4.5678E7\");\n        expect2(new DecimalFormat(\"##E0\", US), 45678000, \"45.678E6\");\n        expect2(new DecimalFormat(\"####E0\", US), 45678000, \"4567.8E4\");\n        expect(new DecimalFormat(\"0E0\", US), 45678000, \"5E7\");\n        expect(new DecimalFormat(\"00E0\", US), 45678000, \"46E6\");\n        expect(new DecimalFormat(\"000E0\", US), 45678000, \"457E5\");\n        /*\n        expect(new DecimalFormat(\"###E0\", US, status),\n               new Object[] { new Double(0.0000123), \"12.3E-6\",\n                              new Double(0.000123), \"123E-6\",\n                              new Double(0.00123), \"1.23E-3\",\n                              new Double(0.0123), \"12.3E-3\",\n                              new Double(0.123), \"123E-3\",\n                              new Double(1.23), \"1.23E0\",\n                              new Double(12.3), \"12.3E0\",\n                              new Double(123), \"123E0\",\n                              new Double(1230), \"1.23E3\",\n                             });\n        !\n        ! Unroll this test into individual tests below...\n        !\n         */\n        expect2(new DecimalFormat(\"###E0\", US), 0.0000123, \"12.3E-6\");\n        expect2(new DecimalFormat(\"###E0\", US), 0.000123, \"123E-6\");\n        expect2(new DecimalFormat(\"###E0\", US), 0.00123, \"1.23E-3\");\n        expect2(new DecimalFormat(\"###E0\", US), 0.0123, \"12.3E-3\");\n        expect2(new DecimalFormat(\"###E0\", US), 0.123, \"123E-3\");\n        expect2(new DecimalFormat(\"###E0\", US), 1.23, \"1.23E0\");\n        expect2(new DecimalFormat(\"###E0\", US), 12.3, \"12.3E0\");\n        expect2(new DecimalFormat(\"###E0\", US), 123.0, \"123E0\");\n        expect2(new DecimalFormat(\"###E0\", US), 1230.0, \"1.23E3\");\n        /*\n        expect(new DecimalFormat(\"0.#E+00\", US, status),\n               new Object[] { new Double(0.00012), \"1.2E-04\",\n                              new Long(12000),     \"1.2E+04\",\n                             });\n        !\n        ! Unroll this test into individual tests below...\n        !\n         */\n        expect2(new DecimalFormat(\"0.#E+00\", US), 0.00012, \"1.2E-04\");\n        expect2(new DecimalFormat(\"0.#E+00\", US), 12000, \"1.2E+04\");\n    }\n\n    /**\n     * Upgrade to alphaWorks\n     */\n    @Test\n    public void TestPad() {\n\n        DecimalFormatSymbols US = new DecimalFormatSymbols(Locale.US);\n        expect2(new DecimalFormat(\"*^##.##\", US), 0, \"^^^^0\");\n        expect2(new DecimalFormat(\"*^##.##\", US), -1.3, \"^-1.3\");\n        expect2(\n                new DecimalFormat(\"##0.0####E0*_ 'g-m/s^2'\", US),\n                0,\n                \"0.0E0______ g-m/s^2\");\n        expect(\n                new DecimalFormat(\"##0.0####E0*_ 'g-m/s^2'\", US),\n                1.0 / 3,\n                \"333.333E-3_ g-m/s^2\");\n        expect2(new DecimalFormat(\"##0.0####*_ 'g-m/s^2'\", US), 0, \"0.0______ g-m/s^2\");\n        expect(\n                new DecimalFormat(\"##0.0####*_ 'g-m/s^2'\", US),\n                1.0 / 3,\n                \"0.33333__ g-m/s^2\");\n\n        // Test padding before a sign\n        final String formatStr = \"*x#,###,###,##0.0#;*x(###,###,##0.0#)\";\n        expect2(new DecimalFormat(formatStr, US), -10, \"xxxxxxxxxx(10.0)\");\n        expect2(new DecimalFormat(formatStr, US), -1000, \"xxxxxxx(1,000.0)\");\n        expect2(new DecimalFormat(formatStr, US), -1000000, \"xxx(1,000,000.0)\");\n        expect2(new DecimalFormat(formatStr, US), -100.37, \"xxxxxxxx(100.37)\");\n        expect2(new DecimalFormat(formatStr, US), -10456.37, \"xxxxx(10,456.37)\");\n        expect2(new DecimalFormat(formatStr, US), -1120456.37, \"xx(1,120,456.37)\");\n        expect2(new DecimalFormat(formatStr, US), -112045600.37, \"(112,045,600.37)\");\n        expect2(new DecimalFormat(formatStr, US), -1252045600.37, \"(1,252,045,600.37)\");\n\n        expect2(new DecimalFormat(formatStr, US), 10, \"xxxxxxxxxxxx10.0\");\n        expect2(new DecimalFormat(formatStr, US), 1000, \"xxxxxxxxx1,000.0\");\n        expect2(new DecimalFormat(formatStr, US), 1000000, \"xxxxx1,000,000.0\");\n        expect2(new DecimalFormat(formatStr, US), 100.37, \"xxxxxxxxxx100.37\");\n        expect2(new DecimalFormat(formatStr, US), 10456.37, \"xxxxxxx10,456.37\");\n        expect2(new DecimalFormat(formatStr, US), 1120456.37, \"xxxx1,120,456.37\");\n        expect2(new DecimalFormat(formatStr, US), 112045600.37, \"xx112,045,600.37\");\n        expect2(new DecimalFormat(formatStr, US), 10252045600.37, \"10,252,045,600.37\");\n\n        // Test padding between a sign and a number\n        final String formatStr2 = \"#,###,###,##0.0#*x;(###,###,##0.0#*x)\";\n        expect2(new DecimalFormat(formatStr2, US), -10, \"(10.0xxxxxxxxxx)\");\n        expect2(new DecimalFormat(formatStr2, US), -1000, \"(1,000.0xxxxxxx)\");\n        expect2(new DecimalFormat(formatStr2, US), -1000000, \"(1,000,000.0xxx)\");\n        expect2(new DecimalFormat(formatStr2, US), -100.37, \"(100.37xxxxxxxx)\");\n        expect2(new DecimalFormat(formatStr2, US), -10456.37, \"(10,456.37xxxxx)\");\n        expect2(new DecimalFormat(formatStr2, US), -1120456.37, \"(1,120,456.37xx)\");\n        expect2(new DecimalFormat(formatStr2, US), -112045600.37, \"(112,045,600.37)\");\n        expect2(new DecimalFormat(formatStr2, US), -1252045600.37, \"(1,252,045,600.37)\");\n\n        expect2(new DecimalFormat(formatStr2, US), 10, \"10.0xxxxxxxxxxxx\");\n        expect2(new DecimalFormat(formatStr2, US), 1000, \"1,000.0xxxxxxxxx\");\n        expect2(new DecimalFormat(formatStr2, US), 1000000, \"1,000,000.0xxxxx\");\n        expect2(new DecimalFormat(formatStr2, US), 100.37, \"100.37xxxxxxxxxx\");\n        expect2(new DecimalFormat(formatStr2, US), 10456.37, \"10,456.37xxxxxxx\");\n        expect2(new DecimalFormat(formatStr2, US), 1120456.37, \"1,120,456.37xxxx\");\n        expect2(new DecimalFormat(formatStr2, US), 112045600.37, \"112,045,600.37xx\");\n        expect2(new DecimalFormat(formatStr2, US), 10252045600.37, \"10,252,045,600.37\");\n\n        //testing the setPadCharacter(UnicodeString) and getPadCharacterString()\n        DecimalFormat fmt = new DecimalFormat(\"#\", US);\n        char padString = 'P';\n        fmt.setPadCharacter(padString);\n        expectPad(fmt, \"*P##.##\", DecimalFormat.PAD_BEFORE_PREFIX, 5, padString);\n        fmt.setPadCharacter('^');\n        expectPad(fmt, \"*^#\", DecimalFormat.PAD_BEFORE_PREFIX, 1, '^');\n        //commented untill implementation is complete\n        /*  fmt.setPadCharacter((UnicodeString)\"^^^\");\n          expectPad(fmt, \"*^^^#\", DecimalFormat.kPadBeforePrefix, 3, (UnicodeString)\"^^^\");\n          padString.remove();\n          padString.append((UChar)0x0061);\n          padString.append((UChar)0x0302);\n          fmt.setPadCharacter(padString);\n          UChar patternChars[]={0x002a, 0x0061, 0x0302, 0x0061, 0x0302, 0x0023, 0x0000};\n          UnicodeString pattern(patternChars);\n          expectPad(fmt, pattern , DecimalFormat.kPadBeforePrefix, 4, padString);\n         */\n\n        // Test multi-char padding sequence specified via pattern\n        expect2(new DecimalFormat(\"*'\ud83d\ude03'####.00\", US), 1.1, \"\ud83d\ude03\ud83d\ude03\ud83d\ude031.10\");\n    }\n\n    /**\n     * Upgrade to alphaWorks\n     */\n    @Test\n    public void TestPatterns2() {\n        DecimalFormatSymbols US = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat fmt = new DecimalFormat(\"#\", US);\n\n        char hat = 0x005E; /*^*/\n\n        expectPad(fmt, \"*^#\", DecimalFormat.PAD_BEFORE_PREFIX, 1, hat);\n        expectPad(fmt, \"$*^#\", DecimalFormat.PAD_AFTER_PREFIX, 2, hat);\n        expectPad(fmt, \"#*^\", DecimalFormat.PAD_BEFORE_SUFFIX, 1, hat);\n        expectPad(fmt, \"#$*^\", DecimalFormat.PAD_AFTER_SUFFIX, 2, hat);\n        expectPad(fmt, \"$*^$#\", -1);\n        expectPad(fmt, \"#$*^$\", -1);\n        expectPad(fmt, \"'pre'#,##0*x'post'\", DecimalFormat.PAD_BEFORE_SUFFIX, 12, (char) 0x0078 /*x*/);\n        expectPad(fmt, \"''#0*x\", DecimalFormat.PAD_BEFORE_SUFFIX, 3, (char) 0x0078 /*x*/);\n        expectPad(fmt, \"'I''ll'*a###.##\", DecimalFormat.PAD_AFTER_PREFIX, 10, (char) 0x0061 /*a*/);\n\n        fmt.applyPattern(\"AA#,##0.00ZZ\");\n        fmt.setPadCharacter(hat);\n\n        fmt.setFormatWidth(10);\n\n        fmt.setPadPosition(DecimalFormat.PAD_BEFORE_PREFIX);\n        expectPat(fmt, \"*^AA#,##0.00ZZ\");\n\n        fmt.setPadPosition(DecimalFormat.PAD_BEFORE_SUFFIX);\n        expectPat(fmt, \"AA#,##0.00*^ZZ\");\n\n        fmt.setPadPosition(DecimalFormat.PAD_AFTER_SUFFIX);\n        expectPat(fmt, \"AA#,##0.00ZZ*^\");\n\n        //            12  3456789012\n        String exp = \"AA*^#,##0.00ZZ\";\n        fmt.setFormatWidth(12);\n        fmt.setPadPosition(DecimalFormat.PAD_AFTER_PREFIX);\n        expectPat(fmt, exp);\n\n        fmt.setFormatWidth(13);\n        //              12  34567890123\n        expectPat(fmt, \"AA*^##,##0.00ZZ\");\n\n        fmt.setFormatWidth(14);\n        //              12  345678901234\n        expectPat(fmt, \"AA*^###,##0.00ZZ\");\n\n        fmt.setFormatWidth(15);\n        //              12  3456789012345\n        expectPat(fmt, \"AA*^####,##0.00ZZ\"); // This is the interesting case\n\n        // The new implementation produces \"AA*^#####,##0.00ZZ\", which is functionally equivalent\n        // to what the old implementation produced, \"AA*^#,###,##0.00ZZ\"\n        fmt.setFormatWidth(16);\n        //              12  34567890123456\n        //expectPat(fmt, \"AA*^#,###,##0.00ZZ\");\n        expectPat(fmt, \"AA*^#####,##0.00ZZ\");\n    }\n\n    @Test\n    public void TestRegistration() {\n        final ULocale SRC_LOC = ULocale.FRANCE;\n        final ULocale SWAP_LOC = ULocale.US;\n\n        class TestFactory extends SimpleNumberFormatFactory {\n            NumberFormat currencyStyle;\n\n            TestFactory() {\n                super(SRC_LOC, true);\n                currencyStyle = NumberFormat.getIntegerInstance(SWAP_LOC);\n            }\n\n            @Override\n            public NumberFormat createFormat(ULocale loc, int formatType) {\n                if (formatType == FORMAT_CURRENCY) {\n                    return currencyStyle;\n                }\n                return null;\n            }\n        }\n\n        NumberFormat f0 = NumberFormat.getIntegerInstance(SWAP_LOC);\n        NumberFormat f1 = NumberFormat.getIntegerInstance(SRC_LOC);\n        NumberFormat f2 = NumberFormat.getCurrencyInstance(SRC_LOC);\n        Object key = NumberFormat.registerFactory(new TestFactory());\n        NumberFormat f3 = NumberFormat.getCurrencyInstance(SRC_LOC);\n        NumberFormat f4 = NumberFormat.getIntegerInstance(SRC_LOC);\n        NumberFormat.unregister(key); // restore for other tests\n        NumberFormat f5 = NumberFormat.getCurrencyInstance(SRC_LOC);\n\n        float n = 1234.567f;\n        logln(\"f0 swap int: \" + f0.format(n));\n        logln(\"f1 src int: \" + f1.format(n));\n        logln(\"f2 src cur: \" + f2.format(n));\n        logln(\"f3 reg cur: \" + f3.format(n));\n        logln(\"f4 reg int: \" + f4.format(n));\n        logln(\"f5 unreg cur: \" + f5.format(n));\n\n        if (!f3.format(n).equals(f0.format(n))) {\n            errln(\"registered service did not match\");\n        }\n        if (!f4.format(n).equals(f1.format(n))) {\n            errln(\"registered service did not inherit\");\n        }\n        if (!f5.format(n).equals(f2.format(n))) {\n            errln(\"unregistered service did not match original\");\n        }\n    }\n\n    @Test\n    public void TestScientific2() {\n        // jb 2552\n        DecimalFormat fmt = (DecimalFormat)NumberFormat.getCurrencyInstance();\n        Number num = new Double(12.34);\n        expect(fmt, num, \"$12.34\");\n        fmt.setScientificNotation(true);\n        expect(fmt, num, \"$1.23E1\");\n        fmt.setScientificNotation(false);\n        expect(fmt, num, \"$12.34\");\n    }\n\n    @Test\n    public void TestScientificGrouping() {\n        // jb 2552\n        DecimalFormat fmt = new DecimalFormat(\"###.##E0\");\n        expect(fmt, .01234, \"12.3E-3\");\n        expect(fmt, .1234, \"123E-3\");\n        expect(fmt, 1.234, \"1.23E0\");\n        expect(fmt, 12.34, \"12.3E0\");\n        expect(fmt, 123.4, \"123E0\");\n        expect(fmt, 1234, \"1.23E3\");\n    }\n\n    // additional coverage tests\n\n    // sigh, can't have static inner classes, why not?\n\n    static final class PI extends Number {\n        /**\n         * For serialization\n         */\n        private static final long serialVersionUID = -305601227915602172L;\n\n        private PI() {}\n        @Override\n        public int intValue() { return (int)Math.PI; }\n        @Override\n        public long longValue() { return (long)Math.PI; }\n        @Override\n        public float  floatValue() { return (float)Math.PI; }\n        @Override\n        public double doubleValue() { return Math.PI; }\n        @Override\n        public byte byteValue() { return (byte)Math.PI; }\n        @Override\n        public short shortValue() { return (short)Math.PI; }\n\n        public static final Number INSTANCE = new PI();\n    }\n\n    @Test\n    public void TestCoverage() {\n        NumberFormat fmt = NumberFormat.getNumberInstance(); // default locale\n        logln(fmt.format(new BigInteger(\"1234567890987654321234567890987654321\", 10)));\n\n        fmt = NumberFormat.getScientificInstance(); // default locale\n\n        logln(fmt.format(PI.INSTANCE));\n\n        try {\n            logln(fmt.format(\"12345\"));\n            errln(\"numberformat of string did not throw exception\");\n        }\n        catch (Exception e) {\n            logln(\"PASS: numberformat of string failed as expected\");\n        }\n\n        int hash = fmt.hashCode();\n        logln(\"hash code \" + hash);\n\n        logln(\"compare to string returns: \" + fmt.equals(\"\"));\n\n        // For ICU 2.6 - alan\n        DecimalFormatSymbols US = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat df = new DecimalFormat(\"'*&'' '\\u00A4' ''&*' #,##0.00\", US);\n        df.setCurrency(Currency.getInstance(\"INR\"));\n        expect2(df, 1.0, \"*&' \\u20B9 '&* 1.00\");\n        expect2(df, -2.0, \"-*&' \\u20B9 '&* 2.00\");\n        df.applyPattern(\"#,##0.00 '*&'' '\\u00A4' ''&*'\");\n        expect2(df, 2.0, \"2.00 *&' \\u20B9 '&*\");\n        expect2(df, -1.0, \"-1.00 *&' \\u20B9 '&*\");\n\n        java.math.BigDecimal r;\n\n        r = df.getRoundingIncrement();\n        if (r != null) {\n            errln(\"FAIL: rounding = \" + r + \", expect null\");\n        }\n\n        if (df.isScientificNotation()) {\n            errln(\"FAIL: isScientificNotation = true, expect false\");\n        }\n\n        // Create a new instance to flush out currency info\n        df = new DecimalFormat(\"0.00000\", US);\n        df.setScientificNotation(true);\n        if (!df.isScientificNotation()) {\n            errln(\"FAIL: isScientificNotation = false, expect true\");\n        }\n        df.setMinimumExponentDigits((byte)2);\n        if (df.getMinimumExponentDigits() != 2) {\n            errln(\"FAIL: getMinimumExponentDigits = \" +\n                    df.getMinimumExponentDigits() + \", expect 2\");\n        }\n        df.setExponentSignAlwaysShown(true);\n        if (!df.isExponentSignAlwaysShown()) {\n            errln(\"FAIL: isExponentSignAlwaysShown = false, expect true\");\n        }\n        df.setSecondaryGroupingSize(0);\n        if (df.getSecondaryGroupingSize() != 0) {\n            errln(\"FAIL: getSecondaryGroupingSize = \" +\n                    df.getSecondaryGroupingSize() + \", expect 0\");\n        }\n        expect2(df, 3.14159, \"3.14159E+00\");\n\n        // DecimalFormatSymbols#getInstance\n        DecimalFormatSymbols decsym1 = DecimalFormatSymbols.getInstance();\n        DecimalFormatSymbols decsym2 = new DecimalFormatSymbols();\n        if (!decsym1.equals(decsym2)) {\n            errln(\"FAIL: DecimalFormatSymbols returned by getInstance()\" +\n                    \"does not match new DecimalFormatSymbols().\");\n        }\n        decsym1 = DecimalFormatSymbols.getInstance(Locale.JAPAN);\n        decsym2 = DecimalFormatSymbols.getInstance(ULocale.JAPAN);\n        if (!decsym1.equals(decsym2)) {\n            errln(\"FAIL: DecimalFormatSymbols returned by getInstance(Locale.JAPAN)\" +\n                    \"does not match the one returned by getInstance(ULocale.JAPAN).\");\n        }\n\n        // DecimalFormatSymbols#getAvailableLocales/#getAvailableULocales\n        Locale[] allLocales = DecimalFormatSymbols.getAvailableLocales();\n        if (allLocales.length == 0) {\n            errln(\"FAIL: Got a empty list for DecimalFormatSymbols.getAvailableLocales\");\n        } else {\n            logln(\"PASS: \" + allLocales.length +\n                    \" available locales returned by DecimalFormatSymbols.getAvailableLocales\");\n        }\n        ULocale[] allULocales = DecimalFormatSymbols.getAvailableULocales();\n        if (allULocales.length == 0) {\n            errln(\"FAIL: Got a empty list for DecimalFormatSymbols.getAvailableLocales\");\n        } else {\n            logln(\"PASS: \" + allULocales.length +\n                    \" available locales returned by DecimalFormatSymbols.getAvailableULocales\");\n        }\n    }\n\n    @Test\n    public void TestLocalizedPatternSymbolCoverage() {\n        String[] standardPatterns = { \"#,##0.05+%;#,##0.05-%\", \"* @@@E0\u2030\" };\n        String[] standardPatterns58 = { \"#,##0.05+%;#,##0.05-%\", \"* @@@E0\u2030;* -@@@E0\u2030\" };\n        String[] localizedPatterns = { \"\u25b0\u2056\u25b0\u25b0\u0ed0\u2058\u0ed0\u0ed5\u2020\u205c\u2059\u25b0\u2056\u25b0\u25b0\u0ed0\u2058\u0ed0\u0ed5\u2021\u205c\", \"\u2042 \u2055\u2055\u2055\u2051\u2051\u0ed0\u2031\" };\n        String[] localizedPatterns58 = { \"\u25b0\u2056\u25b0\u25b0\u0ed0\u2058\u0ed0\u0ed5+\u205c\u2059\u25b0\u2056\u25b0\u25b0\u0ed0\u2058\u0ed0\u0ed5\u2021\u205c\", \"\u2042 \u2055\u2055\u2055\u2051\u2051\u0ed0\u2031\u2059\u2042 \u2021\u2055\u2055\u2055\u2051\u2051\u0ed0\u2031\" };\n\n        DecimalFormatSymbols dfs = new DecimalFormatSymbols();\n        dfs.setGroupingSeparator('\u2056');\n        dfs.setDecimalSeparator('\u2058');\n        dfs.setPatternSeparator('\u2059');\n        dfs.setDigit('\u25b0');\n        dfs.setZeroDigit('\u0ed0');\n        dfs.setSignificantDigit('\u2055');\n        dfs.setPlusSign('\u2020');\n        dfs.setMinusSign('\u2021');\n        dfs.setPercent('\u205c');\n        dfs.setPerMill('\u2031');\n        dfs.setExponentSeparator(\"\u2051\u2051\"); // tests multi-char sequence\n        dfs.setPadEscape('\u2042');\n\n        for (int i=0; i<2; i++) {\n            String standardPattern = standardPatterns[i];\n            String standardPattern58 = standardPatterns58[i];\n            String localizedPattern = localizedPatterns[i];\n            String localizedPattern58 = localizedPatterns58[i];\n\n            DecimalFormat df1 = new DecimalFormat(\"#\", dfs);\n            df1.applyPattern(standardPattern);\n            DecimalFormat df2 = new DecimalFormat(\"#\", dfs);\n            df2.applyLocalizedPattern(localizedPattern);\n            assertEquals(\"DecimalFormat instances should be equal\",\n                    df1, df2);\n            assertEquals(\"toPattern should match on localizedPattern instance\",\n                    standardPattern, df2.toPattern());\n            assertEquals(\"toLocalizedPattern should match on standardPattern instance\",\n                    localizedPattern, df1.toLocalizedPattern());\n\n            // Android can't access DecimalFormat_ICU58 for testing (ticket #13283).\n            if (TestUtil.getJavaVendor() == TestUtil.JavaVendor.Android) continue;\n\n            // Note: ICU 58 does not support plus signs in patterns\n            // Note: ICU 58 always prints the negative part of scientific notation patterns,\n            //       even when the negative part is not necessary\n            DecimalFormat_ICU58 df3 = new DecimalFormat_ICU58(\"#\", dfs);\n            df3.applyPattern(standardPattern); // Reading standardPattern is OK\n            DecimalFormat_ICU58 df4 = new DecimalFormat_ICU58(\"#\", dfs);\n            df4.applyLocalizedPattern(localizedPattern58);\n            // Note: DecimalFormat#equals() is broken on ICU 58\n            assertEquals(\"toPattern should match on ICU58 localizedPattern instance\",\n                    standardPattern58, df4.toPattern());\n            assertEquals(\"toLocalizedPattern should match on ICU58 standardPattern instance\",\n                    localizedPattern58, df3.toLocalizedPattern());\n        }\n    }\n\n    @Test\n    public void TestParseNull() throws ParseException {\n        DecimalFormat df = new DecimalFormat();\n        try {\n            df.parse(null);\n            fail(\"df.parse(null) didn't throw an exception\");\n        } catch (IllegalArgumentException e){}\n        try {\n            df.parse(null, null);\n            fail(\"df.parse(null) didn't throw an exception\");\n        } catch (IllegalArgumentException e){}\n        try {\n            df.parseCurrency(null, null);\n            fail(\"df.parse(null) didn't throw an exception\");\n        } catch (IllegalArgumentException e){}\n    }\n\n    @Test\n    public void TestWhiteSpaceParsing() {\n        DecimalFormatSymbols US = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat fmt = new DecimalFormat(\"a  b#0c  \", US);\n        int n = 1234;\n        expect(fmt, \"a b1234c \", n);\n        expect(fmt, \"a   b1234c   \", n);\n        expect(fmt, \"ab1234\", n);\n\n        fmt.applyPattern(\"a b #\");\n        expect(fmt, \"ab1234\", n);\n        expect(fmt, \"ab  1234\", n);\n        expect(fmt, \"a b1234\", n);\n        expect(fmt, \"a   b1234\", n);\n        expect(fmt, \" a b 1234\", n);\n\n        // Horizontal whitespace is allowed, but not vertical whitespace.\n        expect(fmt, \"\\ta\\u00A0b\\u20001234\", n);\n        expect(fmt, \"a   \\u200A    b1234\", n);\n        expectParseException(fmt, \"\\nab1234\", n);\n        expectParseException(fmt, \"a    \\n   b1234\", n);\n        expectParseException(fmt, \"a    \\u0085   b1234\", n);\n        expectParseException(fmt, \"a    \\u2028   b1234\", n);\n\n        // Test all characters in the UTS 18 \"blank\" set stated in the API docstring.\n        UnicodeSet blanks = new UnicodeSet(\"[[:Zs:][\\\\u0009]]\").freeze();\n        for (String space : blanks) {\n            String str = \"a \" + space + \" b1234c  \";\n            expect(fmt, str, n);\n        }\n\n        // Arbitrary whitespace is not accepted in strict mode.\n        fmt.setParseStrict(true);\n        for (String space : blanks) {\n            String str = \"a \" + space + \" b1234c  \";\n            expectParseException(fmt, str, n);\n        }\n\n        // Test default ignorable characters.  These should work in both lenient and strict.\n        UnicodeSet defaultIgnorables = new UnicodeSet(\"[[:Bidi_Control:]]\").freeze();\n        fmt.setParseStrict(false);\n        for (String ignorable : defaultIgnorables) {\n            String str = \"a b \" + ignorable + \"1234c  \";\n            expect(fmt, str, n);\n        }\n        fmt.setParseStrict(true);\n        for (String ignorable : defaultIgnorables) {\n            String str = \"a b \" + ignorable + \"1234c  \";\n            expect(fmt, str, n);\n        }\n\n        // Test that other whitespace characters do not work\n        fmt.setParseStrict(false);\n        UnicodeSet otherWhitespace = new UnicodeSet(\"[[:whitespace:]]\").removeAll(blanks).freeze();\n        for (String space : otherWhitespace) {\n            String str = \"a  \" + space + \"  b1234\";\n            expectParseException(fmt, str, n);\n        }\n    }\n\n    /**\n     * Test currencies whose display name is a ChoiceFormat.\n     */\n    @Test\n    public void TestComplexCurrency() {\n        //  CLDR No Longer uses complex currency symbols.\n        //  Skipping this test.\n        //        Locale loc = new Locale(\"kn\", \"IN\", \"\");\n        //        NumberFormat fmt = NumberFormat.getCurrencyInstance(loc);\n\n        //        expect2(fmt, 1.0, \"Re.\\u00a01.00\");\n        //        expect(fmt, 1.001, \"Re.\\u00a01.00\"); // tricky\n        //        expect2(fmt, 12345678.0, \"Rs.\\u00a01,23,45,678.00\");\n        //        expect2(fmt, 0.5, \"Rs.\\u00a00.50\");\n        //        expect2(fmt, -1.0, \"-Re.\\u00a01.00\");\n        //        expect2(fmt, -10.0, \"-Rs.\\u00a010.00\");\n    }\n\n    @Test\n    public void TestCurrencyKeyword() {\n        ULocale locale = new ULocale(\"th_TH@currency=QQQ\");\n        NumberFormat format = NumberFormat.getCurrencyInstance(locale);\n        String result = format.format(12.34f);\n        if (!\"QQQ\u00a012.34\".equals(result)) {\n            errln(\"got unexpected currency: \" + result);\n        }\n    }\n\n    /**\n     * Test alternate numbering systems\n     */\n    @Test\n    public void TestNumberingSystems() {\n        class TestNumberingSystemItem {\n            private final String localeName;\n            private final double value;\n            private final boolean isRBNF;\n            private final String expectedResult;\n\n            TestNumberingSystemItem(String loc, double val, boolean rbnf, String exp) {\n                localeName  = loc;\n                value = val;\n                isRBNF = rbnf;\n                expectedResult = exp;\n            }\n        }\n\n        final TestNumberingSystemItem[] DATA = {\n                new TestNumberingSystemItem( \"en_US@numbers=thai\",        1234.567, false, \"\\u0e51,\\u0e52\\u0e53\\u0e54.\\u0e55\\u0e56\\u0e57\" ),\n                new TestNumberingSystemItem( \"en_US@numbers=thai\",        1234.567, false, \"\\u0E51,\\u0E52\\u0E53\\u0E54.\\u0E55\\u0E56\\u0E57\" ),\n                new TestNumberingSystemItem( \"en_US@numbers=hebr\",        5678.0,   true,  \"\\u05D4\\u05F3\\u05EA\\u05E8\\u05E2\\u05F4\\u05D7\" ),\n                new TestNumberingSystemItem( \"en_US@numbers=arabext\",     1234.567, false, \"\\u06F1\\u066c\\u06F2\\u06F3\\u06F4\\u066b\\u06F5\\u06F6\\u06F7\" ),\n                new TestNumberingSystemItem( \"de_DE@numbers=foobar\",      1234.567, false, \"1.234,567\" ),\n                new TestNumberingSystemItem( \"ar_EG\",                     1234.567, false, \"\\u0661\\u066c\\u0662\\u0663\\u0664\\u066b\\u0665\\u0666\\u0667\" ),\n                new TestNumberingSystemItem( \"th_TH@numbers=traditional\", 1234.567, false, \"\\u0E51,\\u0E52\\u0E53\\u0E54.\\u0E55\\u0E56\\u0E57\" ), // fall back to native per TR35\n                new TestNumberingSystemItem( \"ar_MA\",                     1234.567, false, \"1.234,567\" ),\n                new TestNumberingSystemItem( \"en_US@numbers=hanidec\",     1234.567, false, \"\\u4e00,\\u4e8c\\u4e09\\u56db.\\u4e94\\u516d\\u4e03\" ),\n                new TestNumberingSystemItem( \"ta_IN@numbers=native\",      1234.567, false, \"\\u0BE7,\\u0BE8\\u0BE9\\u0BEA.\\u0BEB\\u0BEC\\u0BED\" ),\n                new TestNumberingSystemItem( \"ta_IN@numbers=traditional\", 1235.0,   true,  \"\\u0BF2\\u0BE8\\u0BF1\\u0BE9\\u0BF0\\u0BEB\" ),\n                new TestNumberingSystemItem( \"ta_IN@numbers=finance\",     1234.567, false, \"1,234.567\" ), // fall back to default per TR35\n                new TestNumberingSystemItem( \"zh_TW@numbers=native\",      1234.567, false, \"\\u4e00,\\u4e8c\\u4e09\\u56db.\\u4e94\\u516d\\u4e03\" ),\n                new TestNumberingSystemItem( \"zh_TW@numbers=traditional\", 1234.567, true,  \"\\u4E00\\u5343\\u4E8C\\u767E\\u4E09\\u5341\\u56DB\\u9EDE\\u4E94\\u516D\\u4E03\" ),\n                new TestNumberingSystemItem( \"zh_TW@numbers=finance\",     1234.567, true,  \"\\u58F9\\u4EDF\\u8CB3\\u4F70\\u53C3\\u62FE\\u8086\\u9EDE\\u4F0D\\u9678\\u67D2\" ),\n                new TestNumberingSystemItem( \"en_US@numbers=mathsanb\",    1234.567, false,  \"\ud835\udfed,\ud835\udfee\ud835\udfef\ud835\udff0.\ud835\udff1\ud835\udff2\ud835\udff3\" ), // ticket #13286\n        };\n\n\n        for (TestNumberingSystemItem item : DATA) {\n            ULocale loc = new ULocale(item.localeName);\n            NumberFormat fmt = NumberFormat.getInstance(loc);\n            if (item.isRBNF) {\n                expect3(fmt,item.value,item.expectedResult);\n            } else {\n                expect2(fmt,item.value,item.expectedResult);\n            }\n        }\n    }\n\n    // Coverage tests for methods not being called otherwise.\n    @Test\n    public void TestNumberingSystemCoverage() {\n        // Test getAvaliableNames\n        String[] availableNames = NumberingSystem.getAvailableNames();\n        if (availableNames == null || availableNames.length <= 0) {\n            errln(\"ERROR: NumberingSystem.getAvailableNames() returned a null or empty array.\");\n        } else {\n            boolean latnFound = false;\n            for (String name : availableNames){\n                if (\"latn\".equals(name)) {\n                    latnFound = true;\n                    break;\n                }\n            }\n\n            if (!latnFound) {\n                errln(\"ERROR: 'latn' numbering system not found on NumberingSystem.getAvailableNames().\");\n            }\n        }\n\n        // Test NumberingSystem.getInstance()\n        NumberingSystem ns1 = NumberingSystem.getInstance();\n        if (ns1 == null || ns1.isAlgorithmic()) {\n            errln(\"ERROR: NumberingSystem.getInstance() returned a null or invalid NumberingSystem\");\n        }\n\n        // Test NumberingSystem.getInstance(int,boolean,String)\n        /* Parameters used: the ones used in the default constructor\n         * radix = 10;\n         * algorithmic = false;\n         * desc = \"0123456789\";\n         */\n        NumberingSystem ns2 = NumberingSystem.getInstance(10, false, \"0123456789\");\n        if (ns2 == null || ns2.isAlgorithmic()) {\n            errln(\"ERROR: NumberingSystem.getInstance(int,boolean,String) returned a null or invalid NumberingSystem\");\n        }\n\n        // Test NumberingSystem.getInstance(Locale)\n        NumberingSystem ns3 = NumberingSystem.getInstance(Locale.ENGLISH);\n        if (ns3 == null || ns3.isAlgorithmic()) {\n            errln(\"ERROR: NumberingSystem.getInstance(Locale) returned a null or invalid NumberingSystem\");\n        }\n    }\n\n    @Test\n    public void Test6816() {\n        Currency cur1 = Currency.getInstance(new Locale(\"und\", \"PH\"));\n\n        NumberFormat nfmt = NumberFormat.getCurrencyInstance(new Locale(\"und\", \"PH\"));\n        DecimalFormatSymbols decsym = ((DecimalFormat)nfmt).getDecimalFormatSymbols();\n        Currency cur2 = decsym.getCurrency();\n\n        if ( !cur1.getCurrencyCode().equals(\"PHP\") || !cur2.getCurrencyCode().equals(\"PHP\")) {\n            errln(\"FAIL: Currencies should match PHP: cur1 = \"+cur1.getCurrencyCode()+\"; cur2 = \"+cur2.getCurrencyCode());\n        }\n\n    }\n\n    @Test\n    public void TestThreadedFormat() {\n\n        class FormatTask implements Runnable {\n            DecimalFormat fmt;\n            StringBuffer buf;\n            boolean inc;\n            float num;\n\n            FormatTask(DecimalFormat fmt, int index) {\n                this.fmt = fmt;\n                this.buf = new StringBuffer();\n                this.inc = (index & 0x1) == 0;\n                this.num = inc ? 0 : 10000;\n            }\n\n            @Override\n            public void run() {\n                if (inc) {\n                    while (num < 10000) {\n                        buf.append(fmt.format(num) + \"\\n\");\n                        num += 3.14159;\n                    }\n                } else {\n                    while (num > 0) {\n                        buf.append(fmt.format(num) + \"\\n\");\n                        num -= 3.14159;\n                    }\n                }\n            }\n\n            String result() {\n                return buf.toString();\n            }\n        }\n\n        DecimalFormat fmt = new DecimalFormat(\"0.####\");\n        FormatTask[] tasks = new FormatTask[8];\n        for (int i = 0; i < tasks.length; ++i) {\n            tasks[i] = new FormatTask(fmt, i);\n        }\n\n        TestUtil.runUntilDone(tasks);\n\n        for (int i = 2; i < tasks.length; i++) {\n            String str1 = tasks[i].result();\n            String str2 = tasks[i-2].result();\n            if (!str1.equals(str2)) {\n                System.out.println(\"mismatch at \" + i);\n                System.out.println(str1);\n                System.out.println(str2);\n                errln(\"decimal format thread mismatch\");\n\n                break;\n            }\n            str1 = str2;\n        }\n    }\n\n    @Test\n    public void TestPerMill() {\n        DecimalFormat fmt = new DecimalFormat(\"###.###\\u2030\");\n        assertEquals(\"0.4857 x ###.###\\u2030\",\n                \"485.7\\u2030\", fmt.format(0.4857));\n\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(Locale.ENGLISH);\n        sym.setPerMill('m');\n        DecimalFormat fmt2 = new DecimalFormat(\"\", sym);\n        fmt2.applyLocalizedPattern(\"###.###m\");\n        assertEquals(\"0.4857 x ###.###m\",\n                \"485.7m\", fmt2.format(0.4857));\n    }\n\n    @Test\n    public void TestIllegalPatterns() {\n        // Test cases:\n        // Prefix with \"-:\" for illegal patterns\n        // Prefix with \"+:\" for legal patterns\n        String DATA[] = {\n                // Unquoted special characters in the suffix are illegal\n                \"-:000.000|###\",\n                \"+:000.000'|###'\",\n        };\n        for (int i=0; i<DATA.length; ++i) {\n            String pat=DATA[i];\n            boolean valid = pat.charAt(0) == '+';\n            pat = pat.substring(2);\n            Exception e = null;\n            try {\n                // locale doesn't matter here\n                new DecimalFormat(pat);\n            } catch (IllegalArgumentException e1) {\n                e = e1;\n            } catch (IndexOutOfBoundsException e1) {\n                e = e1;\n            }\n            String msg = (e==null) ? \"success\" : e.getMessage();\n            if ((e==null) == valid) {\n                logln(\"Ok: pattern \\\"\" + pat + \"\\\": \" + msg);\n            } else {\n                errln(\"FAIL: pattern \\\"\" + pat + \"\\\" should have \" +\n                        (valid?\"succeeded\":\"failed\") + \"; got \" + msg);\n            }\n        }\n    }\n\n    /**\n     * Parse a CurrencyAmount using the given NumberFormat, with\n     * the 'delim' character separating the number and the currency.\n     */\n    private static CurrencyAmount parseCurrencyAmount(String str, NumberFormat fmt,\n            char delim)\n                    throws ParseException {\n        int i = str.indexOf(delim);\n        return new CurrencyAmount(fmt.parse(str.substring(0,i)),\n                Currency.getInstance(str.substring(i+1)));\n    }\n\n    /**\n     * Return an integer representing the next token from this\n     * iterator.  The integer will be an index into the given list, or\n     * -1 if there are no more tokens, or -2 if the token is not on\n     * the list.\n     */\n    private static int keywordIndex(String tok) {\n        for (int i=0; i<KEYWORDS.length; ++i) {\n            if (tok.equals(KEYWORDS[i])) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    private static final String KEYWORDS[] = {\n        /*0*/ \"ref=\", // <reference pattern to parse numbers>\n        /*1*/ \"loc=\", // <locale for formats>\n        /*2*/ \"f:\",   // <pattern or '-'> <number> <exp. string>\n        /*3*/ \"fp:\",  // <pattern or '-'> <number> <exp. string> <exp. number>\n        /*4*/ \"rt:\",  // <pattern or '-'> <(exp.) number> <(exp.) string>\n        /*5*/ \"p:\",   // <pattern or '-'> <string> <exp. number>\n        /*6*/ \"perr:\", // <pattern or '-'> <invalid string>\n        /*7*/ \"pat:\", // <pattern or '-'> <exp. toPattern or '-' or 'err'>\n        /*8*/ \"fpc:\", // <loc or '-'> <curr.amt> <exp. string> <exp. curr.amt>\n        /*9*/ \"strict=\", // true or false\n    };\n\n    @SuppressWarnings(\"resource\")  // InputStream is will be closed by the ResourceReader.\n    @Test\n    public void TestCases() {\n        String caseFileName = \"NumberFormatTestCases.txt\";\n        java.io.InputStream is = NumberFormatTest.class.getResourceAsStream(caseFileName);\n\n        ResourceReader reader = new ResourceReader(is, caseFileName, \"utf-8\");\n        TokenIterator tokens = new TokenIterator(reader);\n\n        Locale loc = new Locale(\"en\", \"US\", \"\");\n        DecimalFormat ref = null, fmt = null;\n        MeasureFormat mfmt = null;\n        String pat = null, str = null, mloc = null;\n        boolean strict = false;\n\n        try {\n            for (;;) {\n                String tok = tokens.next();\n                if (tok == null) {\n                    break;\n                }\n                String where = \"(\" + tokens.getLineNumber() + \") \";\n                int cmd = keywordIndex(tok);\n                switch (cmd) {\n                case 0:\n                    // ref= <reference pattern>\n                    ref = new DecimalFormat(tokens.next(),\n                            new DecimalFormatSymbols(Locale.US));\n                    ref.setParseStrict(strict);\n                    logln(\"Setting reference pattern to:\\t\" + ref);\n                    break;\n                case 1:\n                    // loc= <locale>\n                    loc = LocaleUtility.getLocaleFromName(tokens.next());\n                    pat = ((DecimalFormat) NumberFormat.getInstance(loc)).toPattern();\n                    logln(\"Setting locale to:\\t\" + loc + \", \\tand pattern to:\\t\" + pat);\n                    break;\n                case 2: // f:\n                case 3: // fp:\n                case 4: // rt:\n                case 5: // p:\n                    tok = tokens.next();\n                    if (!tok.equals(\"-\")) {\n                        pat = tok;\n                    }\n                    try {\n                        fmt = new DecimalFormat(pat, new DecimalFormatSymbols(loc));\n                        fmt.setParseStrict(strict);\n                    } catch (IllegalArgumentException iae) {\n                        errln(where + \"Pattern \\\"\" + pat + '\"');\n                        iae.printStackTrace();\n                        tokens.next(); // consume remaining tokens\n                        //tokens.next();\n                        if (cmd == 3) tokens.next();\n                        continue;\n                    }\n                    str = null;\n                    try {\n                        if (cmd == 2 || cmd == 3 || cmd == 4) {\n                            // f: <pattern or '-'> <number> <exp. string>\n                            // fp: <pattern or '-'> <number> <exp. string> <exp. number>\n                            // rt: <pattern or '-'> <number> <string>\n                            String num = tokens.next();\n                            str = tokens.next();\n                            Number n = ref.parse(num);\n                            assertEquals(where + '\"' + pat + \"\\\".format(\" + num + \")\",\n                                    str, fmt.format(n));\n                            if (cmd == 3) { // fp:\n                                n = ref.parse(tokens.next());\n                            }\n                            if (cmd != 2) { // != f:\n                                assertEquals(where + '\"' + pat + \"\\\".parse(\\\"\" + str + \"\\\")\",\n                                        n, fmt.parse(str));\n                            }\n                        }\n                        // p: <pattern or '-'> <string to parse> <exp. number>\n                        else {\n                            str = tokens.next();\n                            String expstr = tokens.next();\n                            Number parsed = fmt.parse(str);\n                            Number exp = ref.parse(expstr);\n                            assertEquals(where + '\"' + pat + \"\\\".parse(\\\"\" + str + \"\\\")\",\n                                    exp, parsed);\n                        }\n                    } catch (ParseException e) {\n                        errln(where + '\"' + pat + \"\\\".parse(\\\"\" + str +\n                                \"\\\") threw an exception\");\n                        e.printStackTrace();\n                    }\n                    break;\n                case 6:\n                    // perr: <pattern or '-'> <invalid string>\n                    errln(\"Under construction\");\n                    return;\n                case 7:\n                    // pat: <pattern> <exp. toPattern, or '-' or 'err'>\n                    String testpat = tokens.next();\n                    String exppat  = tokens.next();\n                    boolean err    = exppat.equals(\"err\");\n                    if (testpat.equals(\"-\")) {\n                        if (err) {\n                            errln(\"Invalid command \\\"pat: - err\\\" at \" +  tokens.describePosition());\n                            continue;\n                        }\n                        testpat = pat;\n                    }\n                    if (exppat.equals(\"-\")) exppat = testpat;\n                    try {\n                        DecimalFormat f = null;\n                        if (testpat == pat) { // [sic]\n                            f = fmt;\n                        } else {\n                            f = new DecimalFormat(testpat);\n                            f.setParseStrict(strict);\n                        }\n                        if (err) {\n                            errln(where + \"Invalid pattern \\\"\" + testpat +\n                                    \"\\\" was accepted\");\n                        } else {\n                            assertEquals(where + '\"' + testpat + \"\\\".toPattern()\",\n                                    exppat, f.toPattern());\n                        }\n                    } catch (IllegalArgumentException iae2) {\n                        if (err) {\n                            logln(\"Ok: \" + where + \"Invalid pattern \\\"\" + testpat +\n                                    \"\\\" threw an exception\");\n                        } else {\n                            errln(where + \"Valid pattern \\\"\" + testpat +\n                                    \"\\\" threw an exception\");\n                            iae2.printStackTrace();\n                        }\n                    }\n                    break;\n                case 8: // fpc:\n                    tok = tokens.next();\n                    if (!tok.equals(\"-\")) {\n                        mloc = tok;\n                        ULocale l = new ULocale(mloc);\n                        try {\n                            mfmt = MeasureFormat.getCurrencyFormat(l);\n                        } catch (IllegalArgumentException iae) {\n                            errln(where + \"Loc \\\"\" + tok + '\"');\n                            iae.printStackTrace();\n                            tokens.next(); // consume remaining tokens\n                            tokens.next();\n                            tokens.next();\n                            continue;\n                        }\n                    }\n                    str = null;\n                    try {\n                        // fpc: <loc or '-'> <curr.amt> <exp. string> <exp. curr.amt>\n                        String currAmt = tokens.next();\n                        str = tokens.next();\n                        CurrencyAmount target = parseCurrencyAmount(currAmt, ref, '/');\n                        String formatResult = mfmt.format(target);\n                        assertEquals(where + \"getCurrencyFormat(\" + mloc + \").format(\" + currAmt + \")\",\n                                str, formatResult);\n                        target = parseCurrencyAmount(tokens.next(), ref, '/');\n                        CurrencyAmount parseResult = (CurrencyAmount) mfmt.parseObject(str);\n                        assertEquals(where + \"getCurrencyFormat(\" + mloc + \").parse(\\\"\" + str + \"\\\")\",\n                                target, parseResult);\n                    } catch (ParseException e) {\n                        errln(where + '\"' + pat + \"\\\".parse(\\\"\" + str +\n                                \"\\\") threw an exception\");\n                        e.printStackTrace();\n                    }\n                    break;\n                case 9: // strict= true or false\n                    strict = \"true\".equalsIgnoreCase(tokens.next());\n                    logln(\"Setting strict to:\\t\" + strict);\n                    break;\n                case -1:\n                    errln(\"Unknown command \\\"\" + tok + \"\\\" at \" + tokens.describePosition());\n                    return;\n                }\n            }\n        } catch (java.io.IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            try {\n                reader.close();\n            } catch (IOException ignored) {\n            }\n        }\n    }\n\n    @Test\n    public void TestFieldPositionDecimal() {\n        DecimalFormat nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getInstance(ULocale.ENGLISH);\n        nf.setPositivePrefix(\"FOO\");\n        nf.setPositiveSuffix(\"BA\");\n        StringBuffer buffer = new StringBuffer();\n        FieldPosition fp = new FieldPosition(NumberFormat.Field.DECIMAL_SEPARATOR);\n        nf.format(35.47, buffer, fp);\n        assertEquals(\"35.47\", \"FOO35.47BA\", buffer.toString());\n        assertEquals(\"fp begin\", 5, fp.getBeginIndex());\n        assertEquals(\"fp end\", 6, fp.getEndIndex());\n    }\n\n    @Test\n    public void TestFieldPositionInteger() {\n        DecimalFormat nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getInstance(ULocale.ENGLISH);\n        nf.setPositivePrefix(\"FOO\");\n        nf.setPositiveSuffix(\"BA\");\n        StringBuffer buffer = new StringBuffer();\n        FieldPosition fp = new FieldPosition(NumberFormat.Field.INTEGER);\n        nf.format(35.47, buffer, fp);\n        assertEquals(\"35.47\", \"FOO35.47BA\", buffer.toString());\n        assertEquals(\"fp begin\", 3, fp.getBeginIndex());\n        assertEquals(\"fp end\", 5, fp.getEndIndex());\n    }\n\n    @Test\n    public void TestFieldPositionFractionButInteger() {\n        DecimalFormat nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getInstance(ULocale.ENGLISH);\n        nf.setPositivePrefix(\"FOO\");\n        nf.setPositiveSuffix(\"BA\");\n        StringBuffer buffer = new StringBuffer();\n        FieldPosition fp = new FieldPosition(NumberFormat.Field.FRACTION);\n        nf.format(35, buffer, fp);\n        assertEquals(\"35\", \"FOO35BA\", buffer.toString());\n        assertEquals(\"fp begin\", 5, fp.getBeginIndex());\n        assertEquals(\"fp end\", 5, fp.getEndIndex());\n    }\n\n    @Test\n    public void TestFieldPositionFraction() {\n        DecimalFormat nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getInstance(ULocale.ENGLISH);\n        nf.setPositivePrefix(\"FOO\");\n        nf.setPositiveSuffix(\"BA\");\n        StringBuffer buffer = new StringBuffer();\n        FieldPosition fp = new FieldPosition(NumberFormat.Field.FRACTION);\n        nf.format(35.47, buffer, fp);\n        assertEquals(\"35.47\", \"FOO35.47BA\", buffer.toString());\n        assertEquals(\"fp begin\", 6, fp.getBeginIndex());\n        assertEquals(\"fp end\", 8, fp.getEndIndex());\n    }\n\n    @Test\n    public void TestFieldPositionCurrency() {\n        DecimalFormat nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getCurrencyInstance(Locale.US);\n        double amount = 35.47;\n        double negAmount = -34.567;\n        FieldPosition cp = new FieldPosition(NumberFormat.Field.CURRENCY);\n\n        StringBuffer buffer0 = new StringBuffer();\n        nf.format(amount, buffer0, cp);\n        assertEquals(\"$35.47\", \"$35.47\", buffer0.toString());\n        assertEquals(\"cp begin\", 0, cp.getBeginIndex());\n        assertEquals(\"cp end\", 1, cp.getEndIndex());\n\n        StringBuffer buffer01 = new StringBuffer();\n        nf.format(negAmount, buffer01, cp);\n        assertEquals(\"-$34.57\", \"-$34.57\", buffer01.toString());\n        assertEquals(\"cp begin\", 1, cp.getBeginIndex());\n        assertEquals(\"cp end\", 2, cp.getEndIndex());\n\n        nf.setCurrency(Currency.getInstance(Locale.FRANCE));\n        StringBuffer buffer1 = new StringBuffer();\n        nf.format(amount, buffer1, cp);\n        assertEquals(\"\u20ac35.47\", \"\u20ac35.47\", buffer1.toString());\n        assertEquals(\"cp begin\", 0, cp.getBeginIndex());\n        assertEquals(\"cp end\", 1, cp.getEndIndex());\n\n        nf.setCurrency(Currency.getInstance(new Locale(\"fr\", \"ch\", \"\")));\n        StringBuffer buffer2 = new StringBuffer();\n        nf.format(amount, buffer2, cp);\n        assertEquals(\"CHF\u00a035.47\", \"CHF\u00a035.47\", buffer2.toString());\n        assertEquals(\"cp begin\", 0, cp.getBeginIndex());\n        assertEquals(\"cp end\", 3, cp.getEndIndex());\n\n        StringBuffer buffer20 = new StringBuffer();\n        nf.format(negAmount, buffer20, cp);\n        assertEquals(\"-CHF\u00a034.57\", \"-CHF\u00a034.57\", buffer20.toString());\n        assertEquals(\"cp begin\", 1, cp.getBeginIndex());\n        assertEquals(\"cp end\", 4, cp.getEndIndex());\n\n        nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getCurrencyInstance(Locale.FRANCE);\n        StringBuffer buffer3 = new StringBuffer();\n        nf.format(amount, buffer3, cp);\n        assertEquals(\"35,47\u00a0\u20ac\", \"35,47\u00a0\u20ac\", buffer3.toString());\n        assertEquals(\"cp begin\", 6, cp.getBeginIndex());\n        assertEquals(\"cp end\", 7, cp.getEndIndex());\n\n        StringBuffer buffer4 = new StringBuffer();\n        nf.format(negAmount, buffer4, cp);\n        assertEquals(\"-34,57\u00a0\u20ac\", \"-34,57\u00a0\u20ac\", buffer4.toString());\n        assertEquals(\"cp begin\", 7, cp.getBeginIndex());\n        assertEquals(\"cp end\", 8, cp.getEndIndex());\n\n        nf.setCurrency(Currency.getInstance(new Locale(\"fr\", \"ch\")));\n        StringBuffer buffer5 = new StringBuffer();\n        nf.format(negAmount, buffer5, cp);\n        assertEquals(\"-34,57\u00a0CHF\", \"-34,57\u00a0CHF\", buffer5.toString());\n        assertEquals(\"cp begin\", 7, cp.getBeginIndex());\n        assertEquals(\"cp end\", 10, cp.getEndIndex());\n\n        NumberFormat plCurrencyFmt = NumberFormat.getInstance(new Locale(\"fr\", \"ch\"), NumberFormat.PLURALCURRENCYSTYLE);\n        StringBuffer buffer6 = new StringBuffer();\n        plCurrencyFmt.format(negAmount, buffer6, cp);\n        assertEquals(\"-34.57 francs suisses\", \"-34.57 francs suisses\", buffer6.toString());\n        assertEquals(\"cp begin\", 7, cp.getBeginIndex());\n        assertEquals(\"cp end\", 21, cp.getEndIndex());\n\n        // Positive value with PLURALCURRENCYSTYLE.\n        plCurrencyFmt = NumberFormat.getInstance(new Locale(\"ja\", \"ch\"), NumberFormat.PLURALCURRENCYSTYLE);\n        StringBuffer buffer7 = new StringBuffer();\n        plCurrencyFmt.format(amount, buffer7, cp);\n        assertEquals(\"35.47\u00a0\u30b9\u30a4\u30b9 \u30d5\u30e9\u30f3\", \"35.47\u00a0\u30b9\u30a4\u30b9 \u30d5\u30e9\u30f3\", buffer7.toString());\n        assertEquals(\"cp begin\", 6, cp.getBeginIndex());\n        assertEquals(\"cp end\", 13, cp.getEndIndex());\n\n        // PLURALCURRENCYSTYLE for non-ASCII.\n        plCurrencyFmt = NumberFormat.getInstance(new Locale(\"ja\", \"de\"), NumberFormat.PLURALCURRENCYSTYLE);\n        StringBuffer buffer8 = new StringBuffer();\n        plCurrencyFmt.format(negAmount, buffer8, cp);\n        assertEquals(\"-34.57\u00a0\u30e6\u30fc\u30ed\", \"-34.57\u00a0\u30e6\u30fc\u30ed\", buffer8.toString());\n        assertEquals(\"cp begin\", 7, cp.getBeginIndex());\n        assertEquals(\"cp end\", 10, cp.getEndIndex());\n\n        nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getCurrencyInstance(Locale.JAPAN);\n        nf.setCurrency(Currency.getInstance(new Locale(\"ja\", \"jp\")));\n        StringBuffer buffer9 = new StringBuffer();\n        nf.format(negAmount, buffer9, cp);\n        assertEquals(\"-\uffe535\", \"-\uffe535\", buffer9.toString());\n        assertEquals(\"cp begin\", 1, cp.getBeginIndex());\n        assertEquals(\"cp end\", 2, cp.getEndIndex());\n\n        // Negative value with PLURALCURRENCYSTYLE.\n        plCurrencyFmt = NumberFormat.getInstance(new Locale(\"ja\", \"ch\"), NumberFormat.PLURALCURRENCYSTYLE);\n        StringBuffer buffer10 = new StringBuffer();\n        plCurrencyFmt.format(negAmount, buffer10, cp);\n        assertEquals(\"-34.57\u00a0\u30b9\u30a4\u30b9 \u30d5\u30e9\u30f3\", \"-34.57\u00a0\u30b9\u30a4\u30b9 \u30d5\u30e9\u30f3\", buffer10.toString());\n        assertEquals(\"cp begin\", 7, cp.getBeginIndex());\n        assertEquals(\"cp end\", 14, cp.getEndIndex());\n\n        // Nagative value with PLURALCURRENCYSTYLE, Arabic digits.\n        nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getCurrencyInstance(new Locale(\"ar\", \"eg\"));\n        plCurrencyFmt = NumberFormat.getInstance(new Locale(\"ar\", \"eg\"), NumberFormat.PLURALCURRENCYSTYLE);\n        StringBuffer buffer11 = new StringBuffer();\n        plCurrencyFmt.format(negAmount, buffer11, cp);\n        assertEquals(\"\u061c-\u0663\u0664\u066b\u0665\u0667 \u062c\u0646\u064a\u0647 \u0645\u0635\u0631\u064a\", \"\u061c-\u0663\u0664\u066b\u0665\u0667 \u062c\u0646\u064a\u0647 \u0645\u0635\u0631\u064a\", buffer11.toString());\n        assertEquals(\"cp begin\", 8, cp.getBeginIndex());\n        assertEquals(\"cp end\", 17, cp.getEndIndex());\n    }\n\n    @Test\n    public void TestRounding() {\n        DecimalFormat nf = (DecimalFormat) com.ibm.icu.text.NumberFormat.getInstance(ULocale.ENGLISH);\n        if (false) { // for debugging specific value\n            nf.setRoundingMode(BigDecimal.ROUND_HALF_UP);\n            checkRounding(nf, new BigDecimal(\"300.0300000000\"), 0, new BigDecimal(\"0.020000000\"));\n        }\n        // full tests\n        int[] roundingIncrements = {1, 2, 5, 20, 50, 100};\n        int[] testValues = {0, 300};\n        for (int j = 0; j < testValues.length; ++j) {\n            for (int mode = BigDecimal.ROUND_UP; mode < BigDecimal.ROUND_HALF_EVEN; ++mode) {\n                nf.setRoundingMode(mode);\n                for (int increment = 0; increment < roundingIncrements.length; ++increment) {\n                    BigDecimal base = new BigDecimal(testValues[j]);\n                    BigDecimal rInc = new BigDecimal(roundingIncrements[increment]);\n                    checkRounding(nf,  base, 20, rInc);\n                    rInc = new BigDecimal(\"1.000000000\").divide(rInc);\n                    checkRounding(nf,  base, 20, rInc);\n                }\n            }\n        }\n    }\n\n    @Test\n    public void TestRoundingPattern() {\n        class TestRoundingPatternItem {\n            String     pattern;\n            BigDecimal roundingIncrement;\n            double     testCase;\n            String     expected;\n\n            TestRoundingPatternItem(String pattern, BigDecimal roundingIncrement, double testCase, String expected) {\n                this.pattern = pattern;\n                this.roundingIncrement = roundingIncrement;\n                this.testCase = testCase;\n                this.expected = expected;\n            }\n        };\n\n        TestRoundingPatternItem []tests = {\n                new TestRoundingPatternItem(\"##0.65\", new BigDecimal(\"0.65\"), 1.234, \"1.30\"),\n                new TestRoundingPatternItem(\"#50\", new BigDecimal(\"50\"), 1230, \"1250\")\n        };\n\n        DecimalFormat df = (DecimalFormat) com.ibm.icu.text.NumberFormat.getInstance(ULocale.ENGLISH);\n        String result;\n        for (int i = 0; i < tests.length; i++) {\n            df.applyPattern(tests[i].pattern);\n\n            result = df.format(tests[i].testCase);\n\n            if (!tests[i].expected.equals(result)) {\n                errln(\"String Pattern Rounding Test Failed: Pattern: \\\"\" + tests[i].pattern + \"\\\" Number: \" + tests[i].testCase + \" - Got: \" + result + \" Expected: \" + tests[i].expected);\n            }\n\n            df.setRoundingIncrement(tests[i].roundingIncrement);\n\n            result = df.format(tests[i].testCase);\n\n            if (!tests[i].expected.equals(result)) {\n                errln(\"BigDecimal Rounding Test Failed: Pattern: \\\"\" + tests[i].pattern + \"\\\" Number: \" + tests[i].testCase + \" - Got: \" + result + \" Expected: \" + tests[i].expected);\n            }\n        }\n    }\n\n    @Test\n    public void TestBigDecimalRounding() {\n        String figure = \"50.000000004\";\n        Double dbl = new Double(figure);\n        BigDecimal dec = new BigDecimal(figure);\n\n        DecimalFormat f = (DecimalFormat) NumberFormat.getInstance();\n        f.applyPattern(\"00.00######\");\n\n        assertEquals(\"double format\", \"50.00\", f.format(dbl));\n        assertEquals(\"bigdec format\", \"50.00\", f.format(dec));\n\n        int maxFracDigits = f.getMaximumFractionDigits();\n        BigDecimal roundingIncrement = new BigDecimal(\"1\").movePointLeft(maxFracDigits);\n\n        f.setRoundingIncrement(roundingIncrement);\n        f.setRoundingMode(BigDecimal.ROUND_DOWN);\n        assertEquals(\"Rounding down\", f.format(dbl), f.format(dec));\n\n        f.setRoundingIncrement(roundingIncrement);\n        f.setRoundingMode(BigDecimal.ROUND_HALF_UP);\n        assertEquals(\"Rounding half up\", f.format(dbl), f.format(dec));\n    }\n\n    void checkRounding(DecimalFormat nf, BigDecimal base, int iterations, BigDecimal increment) {\n        nf.setRoundingIncrement(increment.toBigDecimal());\n        BigDecimal lastParsed = new BigDecimal(Integer.MIN_VALUE); // used to make sure that rounding is monotonic\n        for (int i = -iterations; i <= iterations; ++i) {\n            BigDecimal iValue = base.add(increment.multiply(new BigDecimal(i)).movePointLeft(1));\n            BigDecimal smallIncrement = new BigDecimal(\"0.00000001\");\n            if (iValue.signum() != 0) {\n                smallIncrement.multiply(iValue); // scale unless zero\n            }\n            // we not only test the value, but some values in a small range around it.\n            lastParsed = checkRound(nf, iValue.subtract(smallIncrement), lastParsed);\n            lastParsed = checkRound(nf, iValue, lastParsed);\n            lastParsed = checkRound(nf, iValue.add(smallIncrement), lastParsed);\n        }\n    }\n\n    private BigDecimal checkRound(DecimalFormat nf, BigDecimal iValue, BigDecimal lastParsed) {\n        String formatedBigDecimal = nf.format(iValue);\n        String formattedDouble = nf.format(iValue.doubleValue());\n        if (!equalButForTrailingZeros(formatedBigDecimal, formattedDouble)) {\n\n            errln(\"Failure at: \" + iValue + \" (\" + iValue.doubleValue() + \")\"\n                    + \",\\tRounding-mode: \" + roundingModeNames[nf.getRoundingMode()]\n                            + \",\\tRounding-increment: \" + nf.getRoundingIncrement()\n                            + \",\\tdouble: \" + formattedDouble\n                            + \",\\tBigDecimal: \" + formatedBigDecimal);\n\n        } else {\n            logln(\"Value: \" + iValue\n                    + \",\\tRounding-mode: \" + roundingModeNames[nf.getRoundingMode()]\n                            + \",\\tRounding-increment: \" + nf.getRoundingIncrement()\n                            + \",\\tdouble: \" + formattedDouble\n                            + \",\\tBigDecimal: \" + formatedBigDecimal);\n        }\n        try {\n            // Number should have compareTo(...)\n            BigDecimal parsed = toBigDecimal(nf.parse(formatedBigDecimal));\n            if (lastParsed.compareTo(parsed) > 0) {\n                errln(\"Rounding wrong direction!: \" + lastParsed + \" > \" + parsed);\n            }\n            lastParsed = parsed;\n        } catch (ParseException e) {\n            errln(\"Parse Failure with: \" + formatedBigDecimal);\n        }\n        return lastParsed;\n    }\n\n    static BigDecimal toBigDecimal(Number number) {\n        return number instanceof BigDecimal ? (BigDecimal) number\n                : number instanceof BigInteger ? new BigDecimal((BigInteger)number)\n        : number instanceof java.math.BigDecimal ? new BigDecimal((java.math.BigDecimal)number)\n                : number instanceof Double ? new BigDecimal(number.doubleValue())\n        : number instanceof Float ? new BigDecimal(number.floatValue())\n                : new BigDecimal(number.longValue());\n    }\n\n    static String[] roundingModeNames = {\n        \"ROUND_UP\", \"ROUND_DOWN\", \"ROUND_CEILING\", \"ROUND_FLOOR\",\n        \"ROUND_HALF_UP\", \"ROUND_HALF_DOWN\", \"ROUND_HALF_EVEN\",\n        \"ROUND_UNNECESSARY\"\n    };\n\n    private static boolean equalButForTrailingZeros(String formatted1, String formatted2) {\n        if (formatted1.length() == formatted2.length()) return formatted1.equals(formatted2);\n        return stripFinalZeros(formatted1).equals(stripFinalZeros(formatted2));\n    }\n\n    private static String stripFinalZeros(String formatted) {\n        int len1 = formatted.length();\n        char ch;\n        while (len1 > 0 && ((ch = formatted.charAt(len1-1)) == '0' || ch == '.')) --len1;\n        if (len1==1 && ((ch = formatted.charAt(len1-1)) == '-')) --len1;\n        return formatted.substring(0,len1);\n    }\n\n    //------------------------------------------------------------------\n    // Support methods\n    //------------------------------------------------------------------\n\n    /** Format-Parse test */\n    public void expect2(NumberFormat fmt, Number n, String exp) {\n        // Don't round-trip format test, since we explicitly do it\n        expect(fmt, n, exp, false);\n        expect(fmt, exp, n);\n    }\n    /** Format-Parse test */\n    public void expect3(NumberFormat fmt, Number n, String exp) {\n        // Don't round-trip format test, since we explicitly do it\n        expect_rbnf(fmt, n, exp, false);\n        expect_rbnf(fmt, exp, n);\n    }\n\n    /** Format-Parse test (convenience) */\n    public void expect2(NumberFormat fmt, double n, String exp) {\n        expect2(fmt, new Double(n), exp);\n    }\n    /** RBNF Format-Parse test (convenience) */\n    public void expect3(NumberFormat fmt, double n, String exp) {\n        expect3(fmt, new Double(n), exp);\n    }\n\n    /** Format-Parse test (convenience) */\n    public void expect2(NumberFormat fmt, long n, String exp) {\n        expect2(fmt, new Long(n), exp);\n    }\n    /** RBNF Format-Parse test (convenience) */\n    public void expect3(NumberFormat fmt, long n, String exp) {\n        expect3(fmt, new Long(n), exp);\n    }\n\n    /** Format test */\n    public void expect(NumberFormat fmt, Number n, String exp, boolean rt) {\n        StringBuffer saw = new StringBuffer();\n        FieldPosition pos = new FieldPosition(0);\n        fmt.format(n, saw, pos);\n        String pat = ((DecimalFormat)fmt).toPattern();\n        if (saw.toString().equals(exp)) {\n            logln(\"Ok   \" + n + \" x \" +\n                    pat + \" = \\\"\" +\n                    saw + \"\\\"\");\n            // We should be able to round-trip the formatted string =>\n            // number => string (but not the other way around: number\n            // => string => number2, might have number2 != number):\n            if (rt) {\n                try {\n                    Number n2 = fmt.parse(exp);\n                    StringBuffer saw2 = new StringBuffer();\n                    fmt.format(n2, saw2, pos);\n                    if (!saw2.toString().equals(exp)) {\n                        errln(\"expect() format test rt, locale \" + fmt.getLocale(ULocale.VALID_LOCALE) +\n                                \", FAIL \\\"\" + exp + \"\\\" => \" + n2 + \" => \\\"\" + saw2 + '\"');\n                    }\n                } catch (ParseException e) {\n                    errln(\"expect() format test rt, locale \" + fmt.getLocale(ULocale.VALID_LOCALE) +\n                            \", \" + e.getMessage());\n                    return;\n                }\n            }\n        } else {\n            errln(\"expect() format test, locale \" + fmt.getLocale(ULocale.VALID_LOCALE) +\n                    \", FAIL \" + n + \" x \" + pat + \" = \\\"\" + saw + \"\\\", expected \\\"\" + exp + \"\\\"\");\n        }\n    }\n    /** RBNF format test */\n    public void expect_rbnf(NumberFormat fmt, Number n, String exp, boolean rt) {\n        StringBuffer saw = new StringBuffer();\n        FieldPosition pos = new FieldPosition(0);\n        fmt.format(n, saw, pos);\n        if (saw.toString().equals(exp)) {\n            logln(\"Ok   \" + n + \" = \\\"\" +\n                    saw + \"\\\"\");\n            // We should be able to round-trip the formatted string =>\n            // number => string (but not the other way around: number\n            // => string => number2, might have number2 != number):\n            if (rt) {\n                try {\n                    Number n2 = fmt.parse(exp);\n                    StringBuffer saw2 = new StringBuffer();\n                    fmt.format(n2, saw2, pos);\n                    if (!saw2.toString().equals(exp)) {\n                        errln(\"expect_rbnf() format test rt, locale \" + fmt.getLocale(ULocale.VALID_LOCALE) +\n                                \", FAIL \\\"\" + exp + \"\\\" => \" + n2 + \" => \\\"\" + saw2 + '\"');\n                    }\n                } catch (ParseException e) {\n                    errln(\"expect_rbnf() format test rt, locale \" + fmt.getLocale(ULocale.VALID_LOCALE) +\n                            \", \" + e.getMessage());\n                    return;\n                }\n            }\n        } else {\n            errln(\"expect_rbnf() format test, locale \" + fmt.getLocale(ULocale.VALID_LOCALE) +\n                    \", FAIL \" + n + \" = \\\"\" + saw + \"\\\", expected \\\"\" + exp + \"\\\"\");\n        }\n    }\n\n    /** Format test (convenience) */\n    public void expect(NumberFormat fmt, Number n, String exp) {\n        expect(fmt, n, exp, true);\n    }\n\n    /** Format test (convenience) */\n    public void expect(NumberFormat fmt, double n, String exp) {\n        expect(fmt, new Double(n), exp);\n    }\n\n    /** Format test (convenience) */\n    public void expect(NumberFormat fmt, long n, String exp) {\n        expect(fmt, new Long(n), exp);\n    }\n\n    /** Parse test */\n    public void expect(NumberFormat fmt, String str, Number n) {\n        Number num = null;\n        try {\n            num = fmt.parse(str);\n        } catch (ParseException e) {\n            errln(e.getMessage());\n            return;\n        }\n        String pat = ((DecimalFormat)fmt).toPattern();\n        // A little tricky here -- make sure Double(12345.0) and\n        // Long(12345) match.\n        if (num.equals(n) || num.doubleValue() == n.doubleValue()) {\n            logln(\"Ok   \\\"\" + str + \"\\\" x \" +\n                    pat + \" = \" +\n                    num);\n        } else {\n            errln(\"expect() parse test, locale \" + fmt.getLocale(ULocale.VALID_LOCALE) +\n                    \", FAIL \\\"\" + str + \"\\\" x \" + pat + \" = \" + num + \", expected \" + n);\n        }\n    }\n\n    /** RBNF Parse test */\n    public void expect_rbnf(NumberFormat fmt, String str, Number n) {\n        Number num = null;\n        try {\n            num = fmt.parse(str);\n        } catch (ParseException e) {\n            errln(e.getMessage());\n            return;\n        }\n        // A little tricky here -- make sure Double(12345.0) and\n        // Long(12345) match.\n        if (num.equals(n) || num.doubleValue() == n.doubleValue()) {\n            logln(\"Ok   \\\"\" + str + \" = \" +\n                    num);\n        } else {\n            errln(\"expect_rbnf() parse test, locale \" + fmt.getLocale(ULocale.VALID_LOCALE) +\n                    \", FAIL \\\"\" + str + \" = \" + num + \", expected \" + n);\n        }\n    }\n\n    /** Parse test (convenience) */\n    public void expect(NumberFormat fmt, String str, double n) {\n        expect(fmt, str, new Double(n));\n    }\n\n    /** Parse test (convenience) */\n    public void expect(NumberFormat fmt, String str, long n) {\n        expect(fmt, str, new Long(n));\n    }\n\n    /** Parse test */\n    public void expectParseException(DecimalFormat fmt, String str, Number n) {\n        Number num = null;\n        try {\n            num = fmt.parse(str);\n            errln(\"Expected failure, but passed: \" + n + \" on \" + fmt.toPattern() + \" -> \" + num);\n        } catch (ParseException e) {\n        }\n    }\n\n    private void expectCurrency(NumberFormat nf, Currency curr,\n            double value, String string) {\n        DecimalFormat fmt = (DecimalFormat) nf;\n        if (curr != null) {\n            fmt.setCurrency(curr);\n        }\n        String s = fmt.format(value).replace('\\u00A0', ' ');\n\n        if (s.equals(string)) {\n            logln(\"Ok: \" + value + \" x \" + curr + \" => \" + s);\n        } else {\n            errln(\"FAIL: \" + value + \" x \" + curr + \" => \" + s +\n                    \", expected \" + string);\n        }\n    }\n\n    public void expectPad(DecimalFormat fmt, String pat, int pos) {\n        expectPad(fmt, pat, pos, 0, (char)0);\n    }\n\n    public void expectPad(DecimalFormat fmt, final String pat, int pos, int width, final char pad) {\n        int apos = 0, awidth = 0;\n        char apadStr;\n        try {\n            fmt.applyPattern(pat);\n            apos = fmt.getPadPosition();\n            awidth = fmt.getFormatWidth();\n            apadStr = fmt.getPadCharacter();\n        } catch (Exception e) {\n            apos = -1;\n            awidth = width;\n            apadStr = pad;\n        }\n\n        if (apos == pos && awidth == width && apadStr == pad) {\n            logln(\"Ok   \\\"\" + pat + \"\\\" pos=\"\n                    + apos + ((pos == -1) ? \"\" : \" width=\" + awidth + \" pad=\" + apadStr));\n        } else {\n            errln(\"FAIL \\\"\" + pat + \"\\\" pos=\" + apos + \" width=\"\n                    + awidth + \" pad=\" + apadStr + \", expected \"\n                    + pos + \" \" + width + \" \" + pad);\n        }\n    }\n\n    public void expectPat(DecimalFormat fmt, final String exp) {\n        String pat = fmt.toPattern();\n        if (pat.equals(exp)) {\n            logln(\"Ok   \\\"\" + pat + \"\\\"\");\n        } else {\n            errln(\"FAIL \\\"\" + pat + \"\\\", expected \\\"\" + exp + \"\\\"\");\n        }\n    }\n\n\n    private void expectParseCurrency(NumberFormat fmt, Currency expected, String text) {\n        ParsePosition pos = new ParsePosition(0);\n        CurrencyAmount currencyAmount = fmt.parseCurrency(text, pos);\n        assertTrue(\"Parse of \" + text + \" should have succeeded.\", pos.getIndex() > 0);\n        assertEquals(\"Currency should be correct.\", expected, currencyAmount.getCurrency());\n    }\n\n    @Test\n    public void TestJB3832(){\n        ULocale locale = new ULocale(\"pt_PT@currency=PTE\");\n        NumberFormat format = NumberFormat.getCurrencyInstance(locale);\n        Currency curr = Currency.getInstance(locale);\n        logln(\"\\nName of the currency is: \" + curr.getName(locale, Currency.LONG_NAME, new boolean[] {false}));\n        CurrencyAmount cAmt = new CurrencyAmount(1150.50, curr);\n        logln(\"CurrencyAmount object's hashCode is: \" + cAmt.hashCode()); //cover hashCode\n        String str = format.format(cAmt);\n        String expected = \"1,150$50\\u00a0\\u200b\";\n        if(!expected.equals(str)){\n            errln(\"Did not get the expected output Expected: \"+expected+\" Got: \"+ str);\n        }\n    }\n\n    @Test\n    public void TestScientificWithGrouping() {\n        // Grouping separators are not allowed in the pattern, but we can enable them via the API.\n        DecimalFormat df = new DecimalFormat(\"###0.000E0\");\n        df.setGroupingUsed(true);\n        df.setGroupingSize(3);\n        expect2(df, 123, \"123.0E0\");\n        expect2(df, 1234, \"1,234E0\");\n        expect2(df, 12340, \"1.234E4\");\n    }\n\n    @Test\n    public void TestStrictParse() {\n        // Pass both strict and lenient:\n        String[] pass = {\n                \"0\",           // single zero before end of text is not leading\n                \"0 \",          // single zero at end of number is not leading\n                \"0.\",          // single zero before period (or decimal, it's ambiguous) is not leading\n                \"0,\",          // single zero before comma (not group separator) is not leading\n                \"0.0\",         // single zero before decimal followed by digit is not leading\n                \"0. \",         // same as above before period (or decimal) is not leading\n                \"0.100,5\",     // comma stops parse of decimal (no grouping)\n                \"0.100,,5\",    // two commas also stops parse\n                \".00\",         // leading decimal is ok, even with zeros\n                \"1234567\",     // group separators are not required\n                \"12345, \",     // comma not followed by digit is not a group separator, but end of number\n                \"1,234, \",     // if group separator is present, group sizes must be appropriate\n                \"1,234,567\",   // ...secondary too\n                \"0E\",          // an exponent not followed by zero or digits is not an exponent\n                \"00\",          // leading zero before zero - used to be error - see ticket #7913\n                \"012\",         // leading zero before digit - used to be error - see ticket #7913\n                \"0,456\",       // leading zero before group separator - used to be error - see ticket #7913\n                \"999,999\",     // see ticket #6863\n                \"-99,999\",     // see ticket #6863\n                \"-999,999\",    // see ticket #6863\n                \"-9,999,999\",  // see ticket #6863\n        };\n        // Pass lenient, fail strict:\n        String[] fail = {\n                \"1,2\",       // wrong number of digits after group separator\n                \",.02\",      // leading group separator before decimal\n                \"1,.02\",     // group separator before decimal\n                \",0\",        // leading group separator before a single digit\n                \",1\",        // leading group separator before a single digit\n                \"1,45\",      // wrong number of digits in primary group\n                \"1,45 that\", // wrong number of digits in primary group\n                \"1,45.34\",   // wrong number of digits in primary group\n                \"1234,567\",  // wrong number of digits in secondary group\n                \"12,34,567\", // wrong number of digits in secondary group\n                \"1,23,456,7890\", // wrong number of digits in primary and secondary groups\n        };\n        // Fail both lenient and strict:\n        String[] failBoth = {\n        };\n\n        DecimalFormat nf = (DecimalFormat) NumberFormat.getInstance(Locale.ENGLISH);\n        runStrictParseBatch(nf, pass, fail, failBoth);\n\n        String[] scientificPass = {\n                \"0E2\",      // single zero before exponent is ok\n                \"1234E2\",   // any number of digits before exponent is ok\n                \"1,234E\",   // an exponent string not followed by zero or digits is not an exponent\n                \"00E2\",     // leading zeroes now allowed in strict mode - see ticket #\n        };\n        String[] scientificFail = {\n        };\n        String[] scientificFailBoth = {\n        };\n\n        nf = (DecimalFormat) NumberFormat.getInstance(Locale.ENGLISH);\n        runStrictParseBatch(nf, scientificPass, scientificFail, scientificFailBoth);\n\n        String[] mixedPass = {\n                \"12,34,567\",\n                \"12,34,567,\",\n                \"12,34,567, that\",\n                \"12,34,567 that\",\n        };\n        String[] mixedFail = {\n                \"12,34,56\",\n                \"12,34,56,\",\n                \"12,34,56, that \",\n                \"12,34,56 that\",\n        };\n        String[] mixedFailBoth = {\n        };\n\n        nf = new DecimalFormat(\"#,##,##0.#\");\n        runStrictParseBatch(nf, mixedPass, mixedFail, mixedFailBoth);\n    }\n\n    void runStrictParseBatch(DecimalFormat nf, String[] pass, String[] fail, String[] failBoth) {\n        nf.setParseStrict(false);\n        runStrictParseTests(\"should pass\", nf, pass, true);\n        runStrictParseTests(\"should also pass\", nf, fail, true);\n        runStrictParseTests(\"should fail\", nf, failBoth, false);\n        nf.setParseStrict(true);\n        runStrictParseTests(\"should still pass\", nf, pass, true);\n        runStrictParseTests(\"should fail\", nf, fail, false);\n        runStrictParseTests(\"should still fail\", nf, failBoth, false);\n    }\n\n    void runStrictParseTests(String msg, DecimalFormat nf, String[] tests, boolean pass) {\n        logln(\"\");\n        logln(\"pattern: '\" + nf.toPattern() + \"'\");\n        logln(msg);\n        for (int i = 0; i < tests.length; ++i) {\n            String str = tests[i];\n            ParsePosition pp = new ParsePosition(0);\n            Number n = nf.parse(str, pp);\n            String formatted = n != null ? nf.format(n) : \"null\";\n            String err = pp.getErrorIndex() == -1 ? \"\" : \"(error at \" + pp.getErrorIndex() + \")\";\n            if ((err.length() == 0) != pass) {\n                errln(\"'\" + str + \"' parsed '\" +\n                        str.substring(0, pp.getIndex()) +\n                        \"' returned \" + n + \" formats to '\" +\n                        formatted + \"' \" + err);\n            } else {\n                if (err.length() > 0) {\n                    err = \"got expected \" + err;\n                }\n                logln(\"'\" + str + \"' parsed '\" +\n                        str.substring(0, pp.getIndex()) +\n                        \"' returned \" + n + \" formats to '\" +\n                        formatted + \"' \" + err);\n            }\n        }\n    }\n\n    @Test\n    public void TestJB5251(){\n        //save default locale\n        ULocale defaultLocale = ULocale.getDefault();\n        ULocale.setDefault(new ULocale(\"qr_QR\"));\n        try {\n            NumberFormat.getInstance();\n        }\n        catch (Exception e) {\n            errln(\"Numberformat threw exception for non-existent locale. It should use the default.\");\n        }\n        //reset default locale\n        ULocale.setDefault(defaultLocale);\n    }\n\n    @Test\n    public void TestParseReturnType() {\n        String[] defaultLong = {\n                \"123\",\n                \"123.0\",\n                \"0.0\",\n                \"-9223372036854775808\", // Min Long\n                \"9223372036854775807\" // Max Long\n        };\n\n        String[] defaultNonLong = {\n                \"12345678901234567890\",\n                \"9223372036854775808\",\n                \"-9223372036854775809\"\n        };\n\n        String[] doubles = {\n                \"-0.0\",\n                \"NaN\",\n                \"\\u221E\"    // Infinity\n        };\n\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat nf = new DecimalFormat(\"#.#\", sym);\n\n        if (nf.isParseBigDecimal()) {\n            errln(\"FAIL: isParseDecimal() must return false by default\");\n        }\n\n        // isParseBigDecimal() is false\n        for (int i = 0; i < defaultLong.length; i++) {\n            try {\n                Number n = nf.parse(defaultLong[i]);\n                if (!(n instanceof Long)) {\n                    errln(\"FAIL: parse does not return Long instance\");\n                }\n            } catch (ParseException e) {\n                errln(\"parse of '\" + defaultLong[i] + \"' threw exception: \" + e);\n            }\n        }\n        for (int i = 0; i < defaultNonLong.length; i++) {\n            try {\n                Number n = nf.parse(defaultNonLong[i]);\n                if (n instanceof Long) {\n                    errln(\"FAIL: parse returned a Long\");\n                }\n            } catch (ParseException e) {\n                errln(\"parse of '\" + defaultNonLong[i] + \"' threw exception: \" + e);\n            }\n        }\n        // parse results for doubls must be always Double\n        for (int i = 0; i < doubles.length; i++) {\n            try {\n                Number n = nf.parse(doubles[i]);\n                if (!(n instanceof Double)) {\n                    errln(\"FAIL: parse does not return Double instance\");\n                }\n            } catch (ParseException e) {\n                errln(\"parse of '\" + doubles[i] + \"' threw exception: \" + e);\n            }\n        }\n\n        // force this DecimalFormat to return BigDecimal\n        nf.setParseBigDecimal(true);\n        if (!nf.isParseBigDecimal()) {\n            errln(\"FAIL: isParseBigDecimal() must return true\");\n        }\n\n        // isParseBigDecimal() is true\n        for (int i = 0; i < defaultLong.length + defaultNonLong.length; i++) {\n            String input = (i < defaultLong.length) ? defaultLong[i] : defaultNonLong[i - defaultLong.length];\n            try {\n                Number n = nf.parse(input);\n                if (!(n instanceof BigDecimal)) {\n                    errln(\"FAIL: parse does not return BigDecimal instance\");\n                }\n            } catch (ParseException e) {\n                errln(\"parse of '\" + input + \"' threw exception: \" + e);\n            }\n        }\n        // parse results for doubls must be always Double\n        for (int i = 0; i < doubles.length; i++) {\n            try {\n                Number n = nf.parse(doubles[i]);\n                if (!(n instanceof Double)) {\n                    errln(\"FAIL: parse does not return Double instance\");\n                }\n            } catch (ParseException e) {\n                errln(\"parse of '\" + doubles[i] + \"' threw exception: \" + e);\n            }\n        }\n    }\n\n    @Test\n    public void TestNonpositiveMultiplier() {\n        DecimalFormat df = new DecimalFormat(\"0\");\n\n        // test zero multiplier\n\n        try {\n            df.setMultiplier(0);\n\n            // bad\n            errln(\"DecimalFormat.setMultiplier(0) did not throw an IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            // good\n        }\n\n        // test negative multiplier\n\n        try {\n            df.setMultiplier(-1);\n\n            if (df.getMultiplier() != -1) {\n                errln(\"DecimalFormat.setMultiplier(-1) did not change the multiplier to -1\");\n                return;\n            }\n\n            // good\n        } catch (IllegalArgumentException ex) {\n            // bad\n            errln(\"DecimalFormat.setMultiplier(-1) threw an IllegalArgumentException\");\n            return;\n        }\n\n        expect(df, \"1122.123\", -1122.123);\n        expect(df, \"-1122.123\", 1122.123);\n        expect(df, \"1.2\", -1.2);\n        expect(df, \"-1.2\", 1.2);\n\n        expect2(df, Long.MAX_VALUE, BigInteger.valueOf(Long.MAX_VALUE).negate().toString());\n        expect2(df, Long.MIN_VALUE, BigInteger.valueOf(Long.MIN_VALUE).negate().toString());\n        expect2(df, Long.MAX_VALUE / 2, BigInteger.valueOf(Long.MAX_VALUE / 2).negate().toString());\n        expect2(df, Long.MIN_VALUE / 2, BigInteger.valueOf(Long.MIN_VALUE / 2).negate().toString());\n\n        expect2(df, BigDecimal.valueOf(Long.MAX_VALUE), BigDecimal.valueOf(Long.MAX_VALUE).negate().toString());\n        expect2(df, BigDecimal.valueOf(Long.MIN_VALUE), BigDecimal.valueOf(Long.MIN_VALUE).negate().toString());\n\n        expect2(df, java.math.BigDecimal.valueOf(Long.MAX_VALUE), java.math.BigDecimal.valueOf(Long.MAX_VALUE).negate().toString());\n        expect2(df, java.math.BigDecimal.valueOf(Long.MIN_VALUE), java.math.BigDecimal.valueOf(Long.MIN_VALUE).negate().toString());\n    }\n\n    @Test\n    public void TestJB5358() {\n        int numThreads = 10;\n        String numstr = \"12345\";\n        double expected = 12345;\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat fmt = new DecimalFormat(\"#.#\", sym);\n        ArrayList errors = new ArrayList();\n\n        ParseThreadJB5358[] threads = new ParseThreadJB5358[numThreads];\n        for (int i = 0; i < numThreads; i++) {\n            threads[i] = new ParseThreadJB5358((DecimalFormat)fmt.clone(), numstr, expected, errors);\n            threads[i].start();\n        }\n        for (int i = 0; i < numThreads; i++) {\n            try {\n                threads[i].join();\n            } catch (InterruptedException ie) {\n                ie.printStackTrace();\n            }\n        }\n        if (errors.size() != 0) {\n            StringBuffer errBuf = new StringBuffer();\n            for (int i = 0; i < errors.size(); i++) {\n                errBuf.append((String)errors.get(i));\n                errBuf.append(\"\\n\");\n            }\n            errln(\"FAIL: \" + errBuf);\n        }\n    }\n\n    static private class ParseThreadJB5358 extends Thread {\n        private final DecimalFormat decfmt;\n        private final String numstr;\n        private final double expect;\n        private final ArrayList errors;\n\n        public ParseThreadJB5358(DecimalFormat decfmt, String numstr, double expect, ArrayList errors) {\n            this.decfmt = decfmt;\n            this.numstr = numstr;\n            this.expect = expect;\n            this.errors = errors;\n        }\n\n        @Override\n        public void run() {\n            for (int i = 0; i < 10000; i++) {\n                try {\n                    Number n = decfmt.parse(numstr);\n                    if (n.doubleValue() != expect) {\n                        synchronized(errors) {\n                            errors.add(new String(\"Bad parse result - expected:\" + expect + \" actual:\" + n.doubleValue()));\n                        }\n                    }\n                } catch (Throwable t) {\n                    synchronized(errors) {\n                        errors.add(new String(t.getClass().getName() + \" - \" + t.getMessage()));\n                    }\n                }\n            }\n        }\n    }\n\n    @Test\n    public void TestSetCurrency() {\n        DecimalFormatSymbols decf1 = DecimalFormatSymbols.getInstance(ULocale.US);\n        DecimalFormatSymbols decf2 = DecimalFormatSymbols.getInstance(ULocale.US);\n        decf2.setCurrencySymbol(\"UKD\");\n        DecimalFormat format1 = new DecimalFormat(\"000.000\", decf1);\n        DecimalFormat format2 = new DecimalFormat(\"000.000\", decf2);\n        Currency euro = Currency.getInstance(\"EUR\");\n        format1.setCurrency(euro);\n        format2.setCurrency(euro);\n        assertEquals(\"Reset with currency symbol\", format1, format2);\n    }\n\n    /*\n     * Testing the method public StringBuffer format(Object number, ...)\n     */\n    @Test\n    public void TestFormat() {\n        NumberFormat nf = NumberFormat.getInstance();\n        StringBuffer sb = new StringBuffer(\"dummy\");\n        FieldPosition fp = new FieldPosition(0);\n\n        // Tests when \"if (number instanceof Long)\" is true\n        try {\n            nf.format(new Long(\"0\"), sb, fp);\n        } catch (Exception e) {\n            errln(\"NumberFormat.format(Object number, ...) was not suppose to \"\n                    + \"return an exception for a Long object. Error: \" + e);\n        }\n\n        // Tests when \"else if (number instanceof BigInteger)\" is true\n        try {\n            nf.format((Object)new BigInteger(\"0\"), sb, fp);\n        } catch (Exception e) {\n            errln(\"NumberFormat.format(Object number, ...) was not suppose to \"\n                    + \"return an exception for a BigInteger object. Error: \" + e);\n        }\n\n        // Tests when \"else if (number instanceof java.math.BigDecimal)\" is true\n        try {\n            nf.format((Object)new java.math.BigDecimal(\"0\"), sb, fp);\n        } catch (Exception e) {\n            errln(\"NumberFormat.format(Object number, ...) was not suppose to \"\n                    + \"return an exception for a java.math.BigDecimal object. Error: \" + e);\n        }\n\n        // Tests when \"else if (number instanceof com.ibm.icu.math.BigDecimal)\" is true\n        try {\n            nf.format((Object)new com.ibm.icu.math.BigDecimal(\"0\"), sb, fp);\n        } catch (Exception e) {\n            errln(\"NumberFormat.format(Object number, ...) was not suppose to \"\n                    + \"return an exception for a com.ibm.icu.math.BigDecimal object. Error: \" + e);\n        }\n\n        // Tests when \"else if (number instanceof CurrencyAmount)\" is true\n        try {\n            CurrencyAmount ca = new CurrencyAmount(0.0, Currency.getInstance(new ULocale(\"en_US\")));\n            nf.format((Object)ca, sb, fp);\n        } catch (Exception e) {\n            errln(\"NumberFormat.format(Object number, ...) was not suppose to \"\n                    + \"return an exception for a CurrencyAmount object. Error: \" + e);\n        }\n\n        // Tests when \"else if (number instanceof Number)\" is true\n        try {\n            nf.format(0.0, sb, fp);\n        } catch (Exception e) {\n            errln(\"NumberFormat.format(Object number, ...) was not suppose to \"\n                    + \"to return an exception for a Number object. Error: \" + e);\n        }\n\n        // Tests when \"else\" is true\n        try {\n            nf.format(new Object(), sb, fp);\n            errln(\"NumberFormat.format(Object number, ...) was suppose to \"\n                    + \"return an exception for an invalid object.\");\n        } catch (Exception e) {\n        }\n\n        try {\n            nf.format(new String(\"dummy\"), sb, fp);\n            errln(\"NumberFormat.format(Object number, ...) was suppose to \"\n                    + \"return an exception for an invalid object.\");\n        } catch (Exception e) {\n        }\n    }\n\n    /*\n     * Coverage tests for the implementation of abstract format methods not being called otherwise\n     */\n    @Test\n    public void TestFormatAbstractImplCoverage() {\n        NumberFormat df = DecimalFormat.getInstance(Locale.ENGLISH);\n        NumberFormat cdf = CompactDecimalFormat.getInstance(Locale.ENGLISH, CompactDecimalFormat.CompactStyle.SHORT);\n        NumberFormat rbf = new RuleBasedNumberFormat(ULocale.ENGLISH, RuleBasedNumberFormat.SPELLOUT);\n\n        /*\n         *  Test  NumberFormat.format(BigDecimal,StringBuffer,FieldPosition)\n         */\n        StringBuffer sb = new StringBuffer();\n        String result = df.format(new BigDecimal(2000.43), sb, new FieldPosition(0)).toString();\n        if (!\"2,000.43\".equals(result)) {\n            errln(\"DecimalFormat failed. Expected: 2,000.43 - Actual: \" + result);\n        }\n\n        sb.delete(0, sb.length());\n        result = cdf.format(new BigDecimal(2000.43), sb, new FieldPosition(0)).toString();\n        if (!\"2K\".equals(result)) {\n            errln(\"DecimalFormat failed. Expected: 2K - Actual: \" + result);\n        }\n\n        sb.delete(0, sb.length());\n        result = rbf.format(new BigDecimal(2000.43), sb, new FieldPosition(0)).toString();\n        if (!\"two thousand point four three\".equals(result)) {\n            errln(\"DecimalFormat failed. Expected: 'two thousand point four three' - Actual: '\" + result + \"'\");\n        }\n    }\n\n    /*\n     * Tests the method public final static NumberFormat getInstance(int style) public static NumberFormat\n     * getInstance(Locale inLocale, int style) public static NumberFormat getInstance(ULocale desiredLocale, int choice)\n     */\n    @Test\n    public void TestGetInstance() {\n        // Tests \"public final static NumberFormat getInstance(int style)\"\n        int maxStyle = NumberFormat.STANDARDCURRENCYSTYLE;\n\n        int[] invalid_cases = { NumberFormat.NUMBERSTYLE - 1, NumberFormat.NUMBERSTYLE - 2,\n                maxStyle + 1, maxStyle + 2 };\n\n        for (int i = NumberFormat.NUMBERSTYLE; i < maxStyle; i++) {\n            try {\n                NumberFormat.getInstance(i);\n            } catch (Exception e) {\n                errln(\"NumberFormat.getInstance(int style) was not suppose to \"\n                        + \"return an exception for passing value of \" + i);\n            }\n        }\n\n        for (int i = 0; i < invalid_cases.length; i++) {\n            try {\n                NumberFormat.getInstance(invalid_cases[i]);\n                errln(\"NumberFormat.getInstance(int style) was suppose to \"\n                        + \"return an exception for passing value of \" + invalid_cases[i]);\n            } catch (Exception e) {\n            }\n        }\n\n        // Tests \"public static NumberFormat getInstance(Locale inLocale, int style)\"\n        String[] localeCases = { \"en_US\", \"fr_FR\", \"de_DE\", \"jp_JP\" };\n\n        for (int i = NumberFormat.NUMBERSTYLE; i < maxStyle; i++) {\n            for (int j = 0; j < localeCases.length; j++) {\n                try {\n                    NumberFormat.getInstance(new Locale(localeCases[j]), i);\n                } catch (Exception e) {\n                    errln(\"NumberFormat.getInstance(Locale inLocale, int style) was not suppose to \"\n                            + \"return an exception for passing value of \" + localeCases[j] + \", \" + i);\n                }\n            }\n        }\n\n        // Tests \"public static NumberFormat getInstance(ULocale desiredLocale, int choice)\"\n        // Tests when \"if (choice < NUMBERSTYLE || choice > PLURALCURRENCYSTYLE)\" is true\n        for (int i = 0; i < invalid_cases.length; i++) {\n            try {\n                NumberFormat.getInstance((ULocale) null, invalid_cases[i]);\n                errln(\"NumberFormat.getInstance(ULocale inLocale, int choice) was not suppose to \"\n                        + \"return an exception for passing value of \" + invalid_cases[i]);\n            } catch (Exception e) {\n            }\n        }\n    }\n\n    /*\n     * Tests the class public static abstract class NumberFormatFactory\n     */\n    @Test\n    public void TestNumberFormatFactory() {\n        /*\n         * The following class allows the method public NumberFormat createFormat(Locale loc, int formatType) to be\n         * tested.\n         */\n        class TestFactory extends NumberFormatFactory {\n            @Override\n            public Set<String> getSupportedLocaleNames() {\n                return null;\n            }\n\n            @Override\n            public NumberFormat createFormat(ULocale loc, int formatType) {\n                return null;\n            }\n        }\n\n        /*\n         * The following class allows the method public NumberFormat createFormat(ULocale loc, int formatType) to be\n         * tested.\n         */\n        class TestFactory1 extends NumberFormatFactory {\n            @Override\n            public Set<String> getSupportedLocaleNames() {\n                return null;\n            }\n\n            @Override\n            public NumberFormat createFormat(Locale loc, int formatType) {\n                return null;\n            }\n        }\n\n        TestFactory tf = new TestFactory();\n        TestFactory1 tf1 = new TestFactory1();\n\n        /*\n         * Tests the method public boolean visible()\n         */\n        if (tf.visible() != true) {\n            errln(\"NumberFormatFactory.visible() was suppose to return true.\");\n        }\n\n        /*\n         * Tests the method public NumberFormat createFormat(Locale loc, int formatType)\n         */\n        if (tf.createFormat(new Locale(\"\"), 0) != null) {\n            errln(\"NumberFormatFactory.createFormat(Locale loc, int formatType) \" + \"was suppose to return null\");\n        }\n\n        /*\n         * Tests the method public NumberFormat createFormat(ULocale loc, int formatType)\n         */\n        if (tf1.createFormat(new ULocale(\"\"), 0) != null) {\n            errln(\"NumberFormatFactory.createFormat(ULocale loc, int formatType) \" + \"was suppose to return null\");\n        }\n    }\n\n    /*\n     * Tests the class public static abstract class SimpleNumberFormatFactory extends NumberFormatFactory\n     */\n    @Test\n    public void TestSimpleNumberFormatFactory() {\n        class TestSimpleNumberFormatFactory extends SimpleNumberFormatFactory {\n            /*\n             * Tests the method public SimpleNumberFormatFactory(Locale locale)\n             */\n            TestSimpleNumberFormatFactory() {\n                super(new Locale(\"\"));\n            }\n        }\n        @SuppressWarnings(\"unused\")\n        TestSimpleNumberFormatFactory tsnff = new TestSimpleNumberFormatFactory();\n    }\n\n    /*\n     * Tests the method public static ULocale[] getAvailableLocales()\n     */\n    @SuppressWarnings(\"static-access\")\n    @Test\n    public void TestGetAvailableLocales() {\n        // Tests when \"if (shim == null)\" is true\n        @SuppressWarnings(\"serial\")\n        class TestGetAvailableLocales extends NumberFormat {\n            @Override\n            public StringBuffer format(double number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public StringBuffer format(long number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public StringBuffer format(BigInteger number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public StringBuffer format(java.math.BigDecimal number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public StringBuffer format(BigDecimal number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public Number parse(String text, ParsePosition parsePosition) {\n                return null;\n            }\n        }\n\n        try {\n            TestGetAvailableLocales test = new TestGetAvailableLocales();\n            test.getAvailableLocales();\n        } catch (Exception e) {\n            errln(\"NumberFormat.getAvailableLocales() was not suppose to \"\n                    + \"return an exception when getting getting available locales.\");\n        }\n    }\n\n    /*\n     * Tests the method public void setMinimumIntegerDigits(int newValue)\n     */\n    @Test\n    public void TestSetMinimumIntegerDigits() {\n        NumberFormat nf = NumberFormat.getInstance();\n        // For valid array, it is displayed as {min value, max value}\n        // Tests when \"if (minimumIntegerDigits > maximumIntegerDigits)\" is true\n        int[][] cases = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 2, 0 }, { 2, 1 }, { 10, 0 } };\n        int[] expectedMax = { 1, 1, 0, 0, 1, 0 };\n        if (cases.length != expectedMax.length) {\n            errln(\"Can't continue test case method TestSetMinimumIntegerDigits \"\n                    + \"since the test case arrays are unequal.\");\n        } else {\n            for (int i = 0; i < cases.length; i++) {\n                nf.setMinimumIntegerDigits(cases[i][0]);\n                nf.setMaximumIntegerDigits(cases[i][1]);\n                if (nf.getMaximumIntegerDigits() != expectedMax[i]) {\n                    errln(\"NumberFormat.setMinimumIntegerDigits(int newValue \"\n                            + \"did not return an expected result for parameter \" + cases[i][0] + \" and \" + cases[i][1]\n                                    + \" and expected \" + expectedMax[i] + \" but got \" + nf.getMaximumIntegerDigits());\n                }\n            }\n        }\n    }\n\n    /*\n     * Tests the method public int getRoundingMode() public void setRoundingMode(int roundingMode)\n     */\n    @Test\n    public void TestRoundingMode() {\n        @SuppressWarnings(\"serial\")\n        class TestRoundingMode extends NumberFormat {\n            @Override\n            public StringBuffer format(double number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public StringBuffer format(long number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public StringBuffer format(BigInteger number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public StringBuffer format(java.math.BigDecimal number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public StringBuffer format(BigDecimal number, StringBuffer toAppendTo, FieldPosition pos) {\n                return null;\n            }\n\n            @Override\n            public Number parse(String text, ParsePosition parsePosition) {\n                return null;\n            }\n        }\n        TestRoundingMode tgrm = new TestRoundingMode();\n\n        // Tests the function 'public void setRoundingMode(int roundingMode)'\n        try {\n            tgrm.setRoundingMode(0);\n            errln(\"NumberFormat.setRoundingMode(int) was suppose to return an exception\");\n        } catch (Exception e) {\n        }\n\n        // Tests the function 'public int getRoundingMode()'\n        try {\n            tgrm.getRoundingMode();\n            errln(\"NumberFormat.getRoundingMode() was suppose to return an exception\");\n        } catch (Exception e) {\n        }\n    }\n\n    /*\n     * Testing lenient decimal/grouping separator parsing\n     */\n    @Test\n    public void TestLenientSymbolParsing() {\n        DecimalFormat fmt = new DecimalFormat();\n        DecimalFormatSymbols sym = new DecimalFormatSymbols();\n\n        expect(fmt, \"12\\u300234\", 12.34);\n\n        // Ticket#7345 - case 1\n        // Even strict parsing, the decimal separator set in the symbols\n        // should be successfully parsed.\n\n        sym.setDecimalSeparator('\\u3002');\n\n        // non-strict\n        fmt.setDecimalFormatSymbols(sym);\n\n        // strict - failed before the fix for #7345\n        fmt.setParseStrict(true);\n        expect(fmt, \"23\\u300245\", 23.45);\n        fmt.setParseStrict(false);\n\n\n        // Ticket#7345 - case 2\n        // Decimal separator variants other than DecimalFormatSymbols.decimalSeparator\n        // should not hide the grouping separator DecimalFormatSymbols.groupingSeparator.\n        sym.setDecimalSeparator('.');\n        sym.setGroupingSeparator(',');\n        fmt.setDecimalFormatSymbols(sym);\n\n        expect(fmt, \"1,234.56\", 1234.56);\n\n        sym.setGroupingSeparator('\\uFF61');\n        fmt.setDecimalFormatSymbols(sym);\n\n        expect(fmt, \"2\\uFF61345.67\", 2345.67);\n\n        // Ticket#7128\n        //\n        sym.setGroupingSeparator(',');\n        fmt.setDecimalFormatSymbols(sym);\n\n        String skipExtSepParse = ICUConfig.get(\"com.ibm.icu.text.DecimalFormat.SkipExtendedSeparatorParsing\", \"false\");\n        if (skipExtSepParse.equals(\"true\")) {\n            // When the property SkipExtendedSeparatorParsing is true,\n            // DecimalFormat does not use the extended equivalent separator\n            // data and only uses the one in DecimalFormatSymbols.\n            expect(fmt, \"23 456\", 23);\n        } else {\n            // Lenient separator parsing is enabled by default.\n            // A space character below is interpreted as a\n            // group separator, even ',' is used as grouping\n            // separator in the symbols.\n            expect(fmt, \"12 345\", 12345);\n        }\n    }\n\n    /*\n     * Testing currency driven max/min fraction digits problem\n     * reported by ticket#7282\n     */\n    @Test\n    public void TestCurrencyFractionDigits() {\n        double value = 99.12345;\n\n        // Create currency instance\n        NumberFormat cfmt  = NumberFormat.getCurrencyInstance(new ULocale(\"ja_JP\"));\n        String text1 = cfmt.format(value);\n\n        // Reset the same currency and format the test value again\n        cfmt.setCurrency(cfmt.getCurrency());\n        String text2 = cfmt.format(value);\n\n        // output1 and output2 must be identical\n        if (!text1.equals(text2)) {\n            errln(\"NumberFormat.format() should return the same result - text1=\"\n                    + text1 + \" text2=\" + text2);\n        }\n    }\n\n    /*\n     * Testing rounding to negative zero problem\n     * reported by ticket#7609\n     */\n    @Test\n    public void TestNegZeroRounding() {\n\n        DecimalFormat df = (DecimalFormat) NumberFormat.getInstance();\n        df.setRoundingMode(MathContext.ROUND_HALF_UP);\n        df.setMinimumFractionDigits(1);\n        df.setMaximumFractionDigits(1);\n        String text1 = df.format(-0.01);\n\n        df.setRoundingIncrement(0.1);\n        String text2 = df.format(-0.01);\n\n        // output1 and output2 must be identical\n        if (!text1.equals(text2)) {\n            errln(\"NumberFormat.format() should return the same result - text1=\"\n                    + text1 + \" text2=\" + text2);\n        }\n\n    }\n\n    @Test\n    public void TestCurrencyAmountCoverage() {\n        CurrencyAmount ca, cb;\n\n        try {\n            ca = new CurrencyAmount(null, (Currency) null);\n            errln(\"NullPointerException should have been thrown.\");\n        } catch (NullPointerException ex) {\n        }\n        try {\n            ca = new CurrencyAmount(new Integer(0), (Currency) null);\n            errln(\"NullPointerException should have been thrown.\");\n        } catch (NullPointerException ex) {\n        }\n\n        ca = new CurrencyAmount(new Integer(0), Currency.getInstance(new ULocale(\"ja_JP\")));\n        cb = new CurrencyAmount(new Integer(1), Currency.getInstance(new ULocale(\"ja_JP\")));\n        if (ca.equals(null)) {\n            errln(\"Comparison should return false.\");\n        }\n        if (!ca.equals(ca)) {\n            errln(\"Comparision should return true.\");\n        }\n        if (ca.equals(cb)) {\n            errln(\"Comparison should return false.\");\n        }\n    }\n\n    @Test\n    public void TestExponentParse() {\n        ParsePosition parsePos = new ParsePosition(0);\n        DecimalFormatSymbols symbols = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat fmt = new DecimalFormat(\"#####\", symbols);\n        Number result = fmt.parse(\"5.06e-27\", parsePos);\n        if ( result.doubleValue() != 5.06E-27 || parsePos.getIndex() != 8) {\n            errln(\"ERROR: ERROR: parse failed - expected 5.06E-27, 8; got \" + result.doubleValue() + \", \" + parsePos.getIndex());\n        }\n    }\n\n    @Test\n    public void TestExplicitParents() {\n        // We use these for testing because decimal and grouping separators will be inherited from es_419\n        // starting with CLDR 2.0\n        String[] DATA = {\n                \"es\", \"CO\", \"\", \"1.250,75\",\n                \"es\", \"ES\", \"\", \"1.250,75\",\n                \"es\", \"GQ\", \"\", \"1.250,75\",\n                \"es\", \"MX\", \"\", \"1,250.75\",\n                \"es\", \"US\", \"\", \"1,250.75\",\n                \"es\", \"VE\", \"\", \"1.250,75\",\n\n        };\n\n        for (int i=0; i<DATA.length; i+=4) {\n            Locale locale = new Locale(DATA[i], DATA[i+1], DATA[i+2]);\n            NumberFormat fmt = NumberFormat.getInstance(locale);\n            String s = fmt.format(1250.75);\n            if (s.equals(DATA[i+3])) {\n                logln(\"Ok: 1250.75 x \" + locale + \" => \" + s);\n            } else {\n                errln(\"FAIL: 1250.75 x \" + locale + \" => \" + s +\n                        \", expected \" + DATA[i+3]);\n            }\n        }\n    }\n\n    /*\n     * Test case for #9240\n     * ICU4J 49.1 DecimalFormat did not clone the internal object holding\n     * formatted text attribute information properly. Therefore, DecimalFormat\n     * created by cloning may return incorrect results or may throw an exception\n     * when formatToCharacterIterator is invoked from multiple threads.\n     */\n    @Test\n    public void TestFormatToCharacterIteratorThread() {\n        final int COUNT = 10;\n\n        DecimalFormat fmt1 = new DecimalFormat(\"#0\");\n        DecimalFormat fmt2 = (DecimalFormat)fmt1.clone();\n\n        int[] res1 = new int[COUNT];\n        int[] res2 = new int[COUNT];\n\n        Thread t1 = new Thread(new FormatCharItrTestThread(fmt1, 1, res1));\n        Thread t2 = new Thread(new FormatCharItrTestThread(fmt2, 100, res2));\n\n        t1.start();\n        t2.start();\n\n        try {\n            t1.join();\n            t2.join();\n        } catch (InterruptedException e) {\n            //TODO\n        }\n\n        int val1 = res1[0];\n        int val2 = res2[0];\n\n        for (int i = 0; i < COUNT; i++) {\n            if (res1[i] != val1) {\n                errln(\"Inconsistent first run limit in test thread 1\");\n            }\n            if (res2[i] != val2) {\n                errln(\"Inconsistent first run limit in test thread 2\");\n            }\n        }\n    }\n\n    /*\n     * This feature had to do with a limitation in DigitList.java that no longer exists in the\n     * new implementation.\n     *\n    @Test\n    public void TestParseMaxDigits() {\n        DecimalFormat fmt = new DecimalFormat();\n        String number = \"100000000000\";\n        int newParseMax = number.length() - 1;\n\n        fmt.setParseMaxDigits(-1);\n\n        // Default value is 1000\n        if (fmt.getParseMaxDigits() != 1000) {\n            errln(\"Fail valid value checking in setParseMaxDigits.\");\n        }\n\n        try {\n            if (fmt.parse(number).doubleValue() == Float.POSITIVE_INFINITY) {\n                errln(\"Got Infinity but should NOT when parsing number: \" + number);\n            }\n\n            fmt.setParseMaxDigits(newParseMax);\n\n            if (fmt.parse(number).doubleValue() != Float.POSITIVE_INFINITY) {\n                errln(\"Did not get Infinity but should when parsing number: \" + number);\n            }\n        } catch (ParseException ex) {\n\n        }\n    }\n    */\n\n    private static class FormatCharItrTestThread implements Runnable {\n        private final NumberFormat fmt;\n        private final int num;\n        private final int[] result;\n\n        FormatCharItrTestThread(NumberFormat fmt, int num, int[] result) {\n            this.fmt = fmt;\n            this.num = num;\n            this.result = result;\n        }\n\n        @Override\n        public void run() {\n            for (int i = 0; i < result.length; i++) {\n                AttributedCharacterIterator acitr = fmt.formatToCharacterIterator(num);\n                acitr.first();\n                result[i] = acitr.getRunLimit();\n            }\n        }\n    }\n\n    @Test\n    public void TestRoundingBehavior() {\n        final Object[][] TEST_CASES = {\n                {\n                    ULocale.US,                             // ULocale - null for default locale\n                    \"#.##\",                                 // Pattern\n                    Integer.valueOf(BigDecimal.ROUND_DOWN), // Rounding Mode or null (implicit)\n                    Double.valueOf(0.0d),                   // Rounding increment, Double or BigDecimal, or null (implicit)\n                    Double.valueOf(123.4567d),              // Input value, Long, Double, BigInteger or BigDecimal\n                    \"123.45\"                                // Expected result, null for exception\n                },\n                {\n                    ULocale.US,\n                    \"#.##\",\n                    null,\n                    Double.valueOf(0.1d),\n                    Double.valueOf(123.4567d),\n                    \"123.5\"\n                },\n                {\n                    ULocale.US,\n                    \"#.##\",\n                    Integer.valueOf(BigDecimal.ROUND_DOWN),\n                    Double.valueOf(0.1d),\n                    Double.valueOf(123.4567d),\n                    \"123.4\"\n                },\n                {\n                    ULocale.US,\n                    \"#.##\",\n                    Integer.valueOf(BigDecimal.ROUND_UNNECESSARY),\n                    null,\n                    Double.valueOf(123.4567d),\n                    null\n                },\n                {\n                    ULocale.US,\n                    \"#.##\",\n                    Integer.valueOf(BigDecimal.ROUND_DOWN),\n                    null,\n                    Long.valueOf(1234),\n                    \"1234\"\n                },\n        };\n\n        int testNum = 1;\n\n        for (Object[] testCase : TEST_CASES) {\n            // 0: locale\n            // 1: pattern\n            ULocale locale = testCase[0] == null ? ULocale.getDefault() : (ULocale)testCase[0];\n            String pattern = (String)testCase[1];\n\n            DecimalFormat fmt = new DecimalFormat(pattern, DecimalFormatSymbols.getInstance(locale));\n\n            // 2: rounding mode\n            Integer roundingMode = null;\n            if (testCase[2] != null) {\n                roundingMode = (Integer)testCase[2];\n                fmt.setRoundingMode(roundingMode);\n            }\n\n            // 3: rounding increment\n            if (testCase[3] != null) {\n                if (testCase[3] instanceof Double) {\n                    fmt.setRoundingIncrement((Double)testCase[3]);\n                } else if (testCase[3] instanceof BigDecimal) {\n                    fmt.setRoundingIncrement((BigDecimal)testCase[3]);\n                } else if (testCase[3] instanceof java.math.BigDecimal) {\n                    fmt.setRoundingIncrement((java.math.BigDecimal)testCase[3]);\n                }\n            }\n\n            // 4: input number\n            String s = null;\n            boolean bException = false;\n            try {\n                s = fmt.format(testCase[4]);\n            } catch (ArithmeticException e) {\n                bException = true;\n            }\n\n            if (bException) {\n                if (testCase[5] != null) {\n                    errln(\"Test case #\" + testNum + \": ArithmeticException was thrown.\");\n                }\n            } else {\n                if (testCase[5] == null) {\n                    errln(\"Test case #\" + testNum +\n                            \": ArithmeticException must be thrown, but got formatted result: \" +\n                            s);\n                } else {\n                    assertEquals(\"Test case #\" + testNum, testCase[5], s);\n                }\n            }\n\n            testNum++;\n        }\n    }\n\n    @Test\n    public void TestSignificantDigits() {\n        double input[] = {\n                0, 0,\n                123, -123,\n                12345, -12345,\n                123.45, -123.45,\n                123.44501, -123.44501,\n                0.001234, -0.001234,\n                0.00000000123, -0.00000000123,\n                0.0000000000000000000123, -0.0000000000000000000123,\n                1.2, -1.2,\n                0.0000000012344501, -0.0000000012344501,\n                123445.01, -123445.01,\n                12344501000000000000000000000000000.0, -12344501000000000000000000000000000.0,\n        };\n        String[] expected = {\n                \"0.00\", \"0.00\",\n                \"123\", \"-123\",\n                \"12345\", \"-12345\",\n                \"123.45\", \"-123.45\",\n                \"123.45\", \"-123.45\",\n                \"0.001234\", \"-0.001234\",\n                \"0.00000000123\", \"-0.00000000123\",\n                \"0.0000000000000000000123\", \"-0.0000000000000000000123\",\n                \"1.20\", \"-1.20\",\n                \"0.0000000012345\", \"-0.0000000012345\",\n                \"123450\", \"-123450\",\n                \"12345000000000000000000000000000000\", \"-12345000000000000000000000000000000\",\n        };\n        DecimalFormat numberFormat =\n                (DecimalFormat) NumberFormat.getInstance(ULocale.US);\n        numberFormat.setSignificantDigitsUsed(true);\n        numberFormat.setMinimumSignificantDigits(3);\n        numberFormat.setMaximumSignificantDigits(5);\n        numberFormat.setGroupingUsed(false);\n        for (int i = 0; i < input.length; i++) {\n            assertEquals(\"TestSignificantDigits\", expected[i], numberFormat.format(input[i]));\n        }\n\n        // Test for ICU-20063\n        {\n            DecimalFormat df = new DecimalFormat(\"0.######\", DecimalFormatSymbols.getInstance(ULocale.US));\n            df.setSignificantDigitsUsed(true);\n            expect(df, 9.87654321, \"9.87654\");\n            df.setMaximumSignificantDigits(3);\n            expect(df, 9.87654321, \"9.88\");\n            // setSignificantDigitsUsed with maxSig only\n            df.setSignificantDigitsUsed(true);\n            expect(df, 9.87654321, \"9.88\");\n            df.setMinimumSignificantDigits(2);\n            expect(df, 9, \"9.0\");\n            // setSignificantDigitsUsed with both minSig and maxSig\n            df.setSignificantDigitsUsed(true);\n            expect(df, 9, \"9.0\");\n            // setSignificantDigitsUsed to false: should revert to fraction rounding\n            df.setSignificantDigitsUsed(false);\n            expect(df, 9.87654321, \"9.876543\");\n            expect(df, 9, \"9\");\n            df.setSignificantDigitsUsed(true);\n            df.setMinimumSignificantDigits(2);\n            expect(df, 9.87654321, \"9.87654\");\n            expect(df, 9, \"9.0\");\n            // setSignificantDigitsUsed with minSig only\n            df.setSignificantDigitsUsed(true);\n            expect(df, 9.87654321, \"9.87654\");\n            expect(df, 9, \"9.0\");\n        }\n    }\n\n    @Test\n    public void TestBug9936() {\n        DecimalFormat numberFormat =\n                (DecimalFormat) NumberFormat.getInstance(ULocale.US);\n        assertFalse(\"\", numberFormat.areSignificantDigitsUsed());\n\n        numberFormat.setSignificantDigitsUsed(true);\n        assertTrue(\"\", numberFormat.areSignificantDigitsUsed());\n\n        numberFormat.setSignificantDigitsUsed(false);\n        assertFalse(\"\", numberFormat.areSignificantDigitsUsed());\n\n        numberFormat.setMinimumSignificantDigits(3);\n        assertTrue(\"\", numberFormat.areSignificantDigitsUsed());\n\n        numberFormat.setSignificantDigitsUsed(false);\n        numberFormat.setMaximumSignificantDigits(6);\n        assertTrue(\"\", numberFormat.areSignificantDigitsUsed());\n    }\n\n    @Test\n    public void TestShowZero() {\n        DecimalFormat numberFormat =\n                (DecimalFormat) NumberFormat.getInstance(ULocale.US);\n        numberFormat.setSignificantDigitsUsed(true);\n        numberFormat.setMaximumSignificantDigits(3);\n        assertEquals(\"TestShowZero\", \"0\", numberFormat.format(0.0));\n    }\n\n    @Test\n    public void TestCurrencyPlurals() {\n        String[][] tests = {\n                {\"en\", \"USD\", \"1\", \"1 US dollar\"},\n                {\"en\", \"USD\", \"1.0\", \"1.0 US dollars\"},\n                {\"en\", \"USD\", \"1.00\", \"1.00 US dollars\"},\n                {\"en\", \"USD\", \"1.99\", \"1.99 US dollars\"},\n                {\"en\", \"AUD\", \"1\", \"1 Australian dollar\"},\n                {\"en\", \"AUD\", \"1.00\", \"1.00 Australian dollars\"},\n                {\"sl\", \"USD\", \"1\", \"1 ameri\\u0161ki dolar\"},\n                {\"sl\", \"USD\", \"2\", \"2 ameri\\u0161ka dolarja\"},\n                {\"sl\", \"USD\", \"3\", \"3 ameri\\u0161ki dolarji\"},\n                {\"sl\", \"USD\", \"5\", \"5 ameri\u0161kih dolarjev\"},\n                {\"fr\", \"USD\", \"1.99\", \"1,99 dollar des \u00c9tats-Unis\"},\n                {\"ru\", \"RUB\", \"1\", \"1 \\u0440\\u043E\\u0441\\u0441\\u0438\\u0439\\u0441\\u043A\\u0438\\u0439 \\u0440\\u0443\\u0431\\u043B\\u044C\"},\n                {\"ru\", \"RUB\", \"2\", \"2 \\u0440\\u043E\\u0441\\u0441\\u0438\\u0439\\u0441\\u043A\\u0438\\u0445 \\u0440\\u0443\\u0431\\u043B\\u044F\"},\n                {\"ru\", \"RUB\", \"5\", \"5 \\u0440\\u043E\\u0441\\u0441\\u0438\\u0439\\u0441\\u043A\\u0438\\u0445 \\u0440\\u0443\\u0431\\u043B\\u0435\\u0439\"},\n        };\n        for (String test[] : tests) {\n            DecimalFormat numberFormat = (DecimalFormat) DecimalFormat.getInstance(new ULocale(test[0]), NumberFormat.PLURALCURRENCYSTYLE);\n            numberFormat.setCurrency(Currency.getInstance(test[1]));\n            double number = Double.parseDouble(test[2]);\n            int dotPos = test[2].indexOf('.');\n            int decimals = dotPos < 0 ? 0 : test[2].length() - dotPos - 1;\n            int digits = dotPos < 0 ? test[2].length() : test[2].length() - 1;\n            numberFormat.setMaximumFractionDigits(decimals);\n            numberFormat.setMinimumFractionDigits(decimals);\n            String actual = numberFormat.format(number);\n            assertEquals(test[0] + \"\\t\" + test[1] + \"\\t\" + test[2], test[3], actual);\n            numberFormat.setMaximumSignificantDigits(digits);\n            numberFormat.setMinimumSignificantDigits(digits);\n            actual = numberFormat.format(number);\n            assertEquals(test[0] + \"\\t\" + test[1] + \"\\t\" + test[2], test[3], actual);\n        }\n    }\n\n    @Test\n    public void TestCustomCurrencySignAndSeparator() {\n        DecimalFormatSymbols custom = new DecimalFormatSymbols(ULocale.US);\n\n        custom.setCurrencySymbol(\"*\");\n        custom.setMonetaryGroupingSeparator('^');\n        custom.setMonetaryDecimalSeparator(':');\n\n        DecimalFormat fmt = new DecimalFormat(\"\\u00A4 #,##0.00\", custom);\n\n        final String numstr = \"* 1^234:56\";\n        expect2(fmt, 1234.56, numstr);\n    }\n\n    @Test\n    public void TestParseSignsAndMarks() {\n        class SignsAndMarksItem {\n            public String locale;\n            public boolean lenient;\n            public String numString;\n            public double value;\n             // Simple constructor\n            public SignsAndMarksItem(String loc, boolean lnt, String numStr, double val) {\n                locale = loc;\n                lenient = lnt;\n                numString = numStr;\n                value = val;\n            }\n        };\n        final SignsAndMarksItem[] items = {\n            // *** Note, ICU4J lenient number parsing does not handle arbitrary whitespace, but can\n            // treat some whitespace as a grouping separator. The cases marked *** below depend\n            // on isGroupingUsed() being set for the locale, which in turn depends on grouping\n            // separators being present in the decimalFormat pattern for the locale (& num sys).\n            //\n            //                    locale                lenient numString                               value\n            new SignsAndMarksItem(\"en\",                 false,  \"12\",                                    12 ),\n            new SignsAndMarksItem(\"en\",                 true,   \"12\",                                    12 ),\n            new SignsAndMarksItem(\"en\",                 false,  \"-23\",                                  -23 ),\n            new SignsAndMarksItem(\"en\",                 true,   \"-23\",                                  -23 ),\n            new SignsAndMarksItem(\"en\",                 true,   \"- 23\",                                 -23 ), // ***\n            new SignsAndMarksItem(\"en\",                 false,  \"\\u200E-23\",                            -23 ),\n            new SignsAndMarksItem(\"en\",                 true,   \"\\u200E-23\",                            -23 ),\n            new SignsAndMarksItem(\"en\",                 true,   \"\\u200E- 23\",                           -23 ), // ***\n\n            new SignsAndMarksItem(\"en@numbers=arab\",    false,  \"\\u0663\\u0664\",                          34 ),\n            new SignsAndMarksItem(\"en@numbers=arab\",    true,   \"\\u0663\\u0664\",                          34 ),\n            new SignsAndMarksItem(\"en@numbers=arab\",    false,  \"-\\u0664\\u0665\",                        -45 ),\n            new SignsAndMarksItem(\"en@numbers=arab\",    true,   \"-\\u0664\\u0665\",                        -45 ),\n            new SignsAndMarksItem(\"en@numbers=arab\",    true,   \"- \\u0664\\u0665\",                       -45 ), // ***\n            new SignsAndMarksItem(\"en@numbers=arab\",    false,  \"\\u200F-\\u0664\\u0665\",                  -45 ),\n            new SignsAndMarksItem(\"en@numbers=arab\",    true,   \"\\u200F-\\u0664\\u0665\",                  -45 ),\n            new SignsAndMarksItem(\"en@numbers=arab\",    true,   \"\\u200F- \\u0664\\u0665\",                 -45 ), // ***\n\n            new SignsAndMarksItem(\"en@numbers=arabext\", false,  \"\\u06F5\\u06F6\",                          56 ),\n            new SignsAndMarksItem(\"en@numbers=arabext\", true,   \"\\u06F5\\u06F6\",                          56 ),\n            new SignsAndMarksItem(\"en@numbers=arabext\", false,  \"-\\u06F6\\u06F7\",                        -67 ),\n            new SignsAndMarksItem(\"en@numbers=arabext\", true,   \"-\\u06F6\\u06F7\",                        -67 ),\n            new SignsAndMarksItem(\"en@numbers=arabext\", true,   \"- \\u06F6\\u06F7\",                       -67 ), // ***\n            new SignsAndMarksItem(\"en@numbers=arabext\", false,  \"\\u200E-\\u200E\\u06F6\\u06F7\",            -67 ),\n            new SignsAndMarksItem(\"en@numbers=arabext\", true,   \"\\u200E-\\u200E\\u06F6\\u06F7\",            -67 ),\n            new SignsAndMarksItem(\"en@numbers=arabext\", true,   \"\\u200E-\\u200E \\u06F6\\u06F7\",           -67 ), // ***\n\n            new SignsAndMarksItem(\"he\",                 false,  \"12\",                                    12 ),\n            new SignsAndMarksItem(\"he\",                 true,   \"12\",                                    12 ),\n            new SignsAndMarksItem(\"he\",                 false,  \"-23\",                                  -23 ),\n            new SignsAndMarksItem(\"he\",                 true,   \"-23\",                                  -23 ),\n            new SignsAndMarksItem(\"he\",                 true,   \"- 23\",                                 -23 ), // ***\n            new SignsAndMarksItem(\"he\",                 false,  \"\\u200E-23\",                            -23 ),\n            new SignsAndMarksItem(\"he\",                 true,   \"\\u200E-23\",                            -23 ),\n            new SignsAndMarksItem(\"he\",                 true,   \"\\u200E- 23\",                           -23 ), // ***\n\n            new SignsAndMarksItem(\"ar\",                 false,  \"\\u0663\\u0664\",                          34 ),\n            new SignsAndMarksItem(\"ar\",                 true,   \"\\u0663\\u0664\",                          34 ),\n            new SignsAndMarksItem(\"ar\",                 false,  \"-\\u0664\\u0665\",                        -45 ),\n            new SignsAndMarksItem(\"ar\",                 true,   \"-\\u0664\\u0665\",                        -45 ),\n            new SignsAndMarksItem(\"ar\",                 true,   \"- \\u0664\\u0665\",                       -45 ), // ***\n            new SignsAndMarksItem(\"ar\",                 false,  \"\\u200F-\\u0664\\u0665\",                  -45 ),\n            new SignsAndMarksItem(\"ar\",                 true,   \"\\u200F-\\u0664\\u0665\",                  -45 ),\n            new SignsAndMarksItem(\"ar\",                 true,   \"\\u200F- \\u0664\\u0665\",                 -45 ), // ***\n\n            new SignsAndMarksItem(\"ar_MA\",              false,  \"12\",                                    12 ),\n            new SignsAndMarksItem(\"ar_MA\",              true,   \"12\",                                    12 ),\n            new SignsAndMarksItem(\"ar_MA\",              false,  \"-23\",                                  -23 ),\n            new SignsAndMarksItem(\"ar_MA\",              true,   \"-23\",                                  -23 ),\n            new SignsAndMarksItem(\"ar_MA\",              true,   \"- 23\",                                 -23 ), // ***\n            new SignsAndMarksItem(\"ar_MA\",              false,  \"\\u200E-23\",                            -23 ),\n            new SignsAndMarksItem(\"ar_MA\",              true,   \"\\u200E-23\",                            -23 ),\n            new SignsAndMarksItem(\"ar_MA\",              true,   \"\\u200E- 23\",                           -23 ), // ***\n\n            new SignsAndMarksItem(\"fa\",                 false,  \"\\u06F5\\u06F6\",                          56 ),\n            new SignsAndMarksItem(\"fa\",                 true,   \"\\u06F5\\u06F6\",                          56 ),\n            new SignsAndMarksItem(\"fa\",                 false,  \"\\u2212\\u06F6\\u06F7\",                   -67 ),\n            new SignsAndMarksItem(\"fa\",                 true,   \"\\u2212\\u06F6\\u06F7\",                   -67 ),\n            new SignsAndMarksItem(\"fa\",                 true,   \"\\u2212 \\u06F6\\u06F7\",                  -67 ), // ***\n            new SignsAndMarksItem(\"fa\",                 false,  \"\\u200E\\u2212\\u200E\\u06F6\\u06F7\",       -67 ),\n            new SignsAndMarksItem(\"fa\",                 true,   \"\\u200E\\u2212\\u200E\\u06F6\\u06F7\",       -67 ),\n            new SignsAndMarksItem(\"fa\",                 true,   \"\\u200E\\u2212\\u200E \\u06F6\\u06F7\",      -67 ), // ***\n\n            new SignsAndMarksItem(\"ps\",                 false,  \"\\u06F5\\u06F6\",                          56 ),\n            new SignsAndMarksItem(\"ps\",                 true,   \"\\u06F5\\u06F6\",                          56 ),\n            new SignsAndMarksItem(\"ps\",                 false,  \"-\\u06F6\\u06F7\",                        -67 ),\n            new SignsAndMarksItem(\"ps\",                 true,   \"-\\u06F6\\u06F7\",                        -67 ),\n            new SignsAndMarksItem(\"ps\",                 true,   \"- \\u06F6\\u06F7\",                       -67 ), // ***\n            new SignsAndMarksItem(\"ps\",                 false,  \"\\u200E-\\u200E\\u06F6\\u06F7\",            -67 ),\n            new SignsAndMarksItem(\"ps\",                 true,   \"\\u200E-\\u200E\\u06F6\\u06F7\",            -67 ),\n            new SignsAndMarksItem(\"ps\",                 true,   \"\\u200E-\\u200E \\u06F6\\u06F7\",           -67 ), // ***\n            new SignsAndMarksItem(\"ps\",                 false,  \"-\\u200E\\u06F6\\u06F7\",                  -67 ),\n            new SignsAndMarksItem(\"ps\",                 true,   \"-\\u200E\\u06F6\\u06F7\",                  -67 ),\n            new SignsAndMarksItem(\"ps\",                 true,   \"-\\u200E \\u06F6\\u06F7\",                 -67 ), // ***\n        };\n        for (SignsAndMarksItem item: items) {\n            ULocale locale = new ULocale(item.locale);\n            NumberFormat numfmt = NumberFormat.getInstance(locale);\n            if (numfmt != null) {\n                numfmt.setParseStrict(!item.lenient);\n                ParsePosition ppos = new ParsePosition(0);\n                Number num = numfmt.parse(item.numString, ppos);\n                if (num != null && ppos.getIndex() == item.numString.length()) {\n                    double parsedValue = num.doubleValue();\n                    if (parsedValue != item.value) {\n                        errln(\"FAIL: locale \" + item.locale + \", lenient \" + item.lenient + \", parse of \\\"\" + item.numString + \"\\\" gives value \" + parsedValue);\n                    }\n                } else {\n                    errln(\"FAIL: locale \" + item.locale + \", lenient \" + item.lenient + \", parse of \\\"\" + item.numString + \"\\\" gives position \" + ppos.getIndex());\n                }\n            } else {\n                errln(\"FAIL: NumberFormat.getInstance for locale \" + item.locale);\n            }\n        }\n    }\n\n    @Test\n    public void TestContext() {\n        // just a minimal sanity check for now\n        NumberFormat nfmt = NumberFormat.getInstance();\n        DisplayContext context = nfmt.getContext(DisplayContext.Type.CAPITALIZATION);\n        if (context != DisplayContext.CAPITALIZATION_NONE) {\n            errln(\"FAIL: Initial NumberFormat.getContext() is not CAPITALIZATION_NONE\");\n        }\n        nfmt.setContext(DisplayContext.CAPITALIZATION_FOR_STANDALONE);\n        context = nfmt.getContext(DisplayContext.Type.CAPITALIZATION);\n        if (context != DisplayContext.CAPITALIZATION_FOR_STANDALONE) {\n            errln(\"FAIL: NumberFormat.getContext() does not return the value set, CAPITALIZATION_FOR_STANDALONE\");\n        }\n    }\n\n    @Test\n    public void TestAccountingCurrency() {\n        String[][] tests = {\n                //locale              num         curr fmt per loc     curr std fmt         curr acct fmt        rt\n                {\"en_US\",             \"1234.5\",   \"$1,234.50\",         \"$1,234.50\",         \"$1,234.50\",         \"true\"},\n                {\"en_US@cf=account\",  \"1234.5\",   \"$1,234.50\",         \"$1,234.50\",         \"$1,234.50\",         \"true\"},\n                {\"en_US\",             \"-1234.5\",  \"-$1,234.50\",        \"-$1,234.50\",        \"($1,234.50)\",       \"true\"},\n                {\"en_US@cf=standard\", \"-1234.5\",  \"-$1,234.50\",        \"-$1,234.50\",        \"($1,234.50)\",       \"true\"},\n                {\"en_US@cf=account\",  \"-1234.5\",  \"($1,234.50)\",       \"-$1,234.50\",        \"($1,234.50)\",       \"true\"},\n                {\"en_US\",             \"0\",        \"$0.00\",             \"$0.00\",             \"$0.00\",             \"true\"},\n                {\"en_US\",             \"-0.2\",     \"-$0.20\",            \"-$0.20\",            \"($0.20)\",           \"true\"},\n                {\"en_US@cf=standard\", \"-0.2\",     \"-$0.20\",            \"-$0.20\",            \"($0.20)\",           \"true\"},\n                {\"en_US@cf=account\",  \"-0.2\",     \"($0.20)\",           \"-$0.20\",            \"($0.20)\",           \"true\"},\n                {\"ja_JP\",             \"10000\",    \"\uffe510,000\",          \"\uffe510,000\",          \"\uffe510,000\",          \"true\" },\n                {\"ja_JP\",             \"-1000.5\",  \"-\uffe51,000\",          \"-\uffe51,000\",          \"(\uffe51,000)\",         \"false\"},\n                {\"ja_JP@cf=account\",  \"-1000.5\",  \"(\uffe51,000)\",         \"-\uffe51,000\",          \"(\uffe51,000)\",         \"false\"},\n                {\"de_DE\",             \"-23456.7\", \"-23.456,70\\u00A0\u20ac\", \"-23.456,70\\u00A0\u20ac\", \"-23.456,70\\u00A0\u20ac\", \"true\" },\n        };\n        for (String[] data : tests) {\n            ULocale loc = new ULocale(data[0]);\n            double num = Double.parseDouble(data[1]);\n            String fmtPerLocExpected   = data[2];\n            String fmtStandardExpected = data[3];\n            String fmtAccountExpected  = data[4];\n            boolean rt = Boolean.parseBoolean(data[5]);\n\n            NumberFormat fmtPerLoc = NumberFormat.getInstance(loc, NumberFormat.CURRENCYSTYLE);\n            expect(fmtPerLoc, num, fmtPerLocExpected, rt);\n\n            NumberFormat fmtStandard = NumberFormat.getInstance(loc, NumberFormat.STANDARDCURRENCYSTYLE);\n            expect(fmtStandard, num, fmtStandardExpected, rt);\n\n            NumberFormat fmtAccount = NumberFormat.getInstance(loc, NumberFormat.ACCOUNTINGCURRENCYSTYLE);\n            expect(fmtAccount, num, fmtAccountExpected, rt);\n        }\n    }\n\n    @Test\n    public void TestCurrencyUsage() {\n        // the 1st one is checking setter/getter, while the 2nd one checks for getInstance\n        // compare the Currency and Currency Cash Digits\n        // Note that as of CLDR 26:\n        // * TWD and PKR switched from 0 decimals to 2; ISK still has 0, so change test to that\n        // * CAD rounds to .05 in the cash style only.\n        for (int i = 0; i < 2; i++) {\n            String original_expected = \"ISK\u00a0124\";\n            DecimalFormat custom = null;\n            if (i == 0) {\n                custom = (DecimalFormat) DecimalFormat.getInstance(new ULocale(\"en_US@currency=ISK\"),\n                        DecimalFormat.CURRENCYSTYLE);\n\n                String original = custom.format(123.567);\n                assertEquals(\"Test Currency Context\", original_expected, original);\n\n                // test the getter\n                assertEquals(\"Test Currency Context Purpose\", custom.getCurrencyUsage(),\n                        Currency.CurrencyUsage.STANDARD);\n                custom.setCurrencyUsage(Currency.CurrencyUsage.CASH);\n                assertEquals(\"Test Currency Context Purpose\", custom.getCurrencyUsage(), Currency.CurrencyUsage.CASH);\n            } else {\n                custom = (DecimalFormat) DecimalFormat.getInstance(new ULocale(\"en_US@currency=ISK\"),\n                        DecimalFormat.CASHCURRENCYSTYLE);\n\n                // test the getter\n                assertEquals(\"Test Currency Context Purpose\", custom.getCurrencyUsage(), Currency.CurrencyUsage.CASH);\n            }\n\n            String cash_currency = custom.format(123.567);\n            String cash_currency_expected = \"ISK\u00a0124\";\n            assertEquals(\"Test Currency Context\", cash_currency_expected, cash_currency);\n        }\n\n        // the 1st one is checking setter/getter, while the 2nd one checks for getInstance\n        // compare the Currency and Currency Cash Rounding\n        for (int i = 0; i < 2; i++) {\n            String original_rounding_expected = \"CA$123.57\";\n            DecimalFormat fmt = null;\n            if (i == 0) {\n                fmt = (DecimalFormat) DecimalFormat.getInstance(new ULocale(\"en_US@currency=CAD\"),\n                        DecimalFormat.CURRENCYSTYLE);\n\n                String original_rounding = fmt.format(123.566);\n                assertEquals(\"Test Currency Context\", original_rounding_expected, original_rounding);\n\n                fmt.setCurrencyUsage(Currency.CurrencyUsage.CASH);\n            } else {\n                fmt = (DecimalFormat) DecimalFormat.getInstance(new ULocale(\"en_US@currency=CAD\"),\n                        DecimalFormat.CASHCURRENCYSTYLE);\n            }\n\n            String cash_rounding_currency = fmt.format(123.567);\n            String cash__rounding_currency_expected = \"CA$123.55\";\n            assertEquals(\"Test Currency Context\", cash__rounding_currency_expected, cash_rounding_currency);\n        }\n\n        // the 1st one is checking setter/getter, while the 2nd one checks for getInstance\n        // Test the currency change\n        for (int i = 0; i < 2; i++) {\n            DecimalFormat fmt2 = null;\n            if (i == 1) {\n                fmt2 = (DecimalFormat) NumberFormat.getInstance(new ULocale(\"en_US@currency=JPY\"),\n                        NumberFormat.CURRENCYSTYLE);\n                fmt2.setCurrencyUsage(Currency.CurrencyUsage.CASH);\n            } else {\n                fmt2 = (DecimalFormat) NumberFormat.getInstance(new ULocale(\"en_US@currency=JPY\"),\n                        NumberFormat.CASHCURRENCYSTYLE);\n            }\n\n            fmt2.setCurrency(Currency.getInstance(\"PKR\"));\n            String PKR_changed = fmt2.format(123.567);\n            String PKR_changed_expected = \"PKR\u00a0124\";\n            assertEquals(\"Test Currency Context\", PKR_changed_expected, PKR_changed);\n        }\n    }\n\n    @Test\n    public void TestCurrencyWithMinMaxFractionDigits() {\n        DecimalFormat df = new DecimalFormat();\n        df.applyPattern(\"\u00a4#,##0.00\");\n        df.setCurrency(Currency.getInstance(\"USD\"));\n        assertEquals(\"Basic currency format fails\", \"$1.23\", df.format(1.234));\n        df.setMaximumFractionDigits(4);\n        assertEquals(\"Currency with max fraction == 4\", \"$1.234\", df.format(1.234));\n        df.setMinimumFractionDigits(4);\n        assertEquals(\"Currency with min fraction == 4\", \"$1.2340\", df.format(1.234));\n    }\n\n    @Test\n    public void TestParseRequiredDecimalPoint() {\n\n        String[] testPattern = { \"00.####\", \"00.0\", \"00\" };\n\n        String value2Parse = \"99\";\n        String value2ParseWithDecimal = \"99.9\";\n        double parseValue  =  99;\n        double parseValueWithDecimal = 99.9;\n        DecimalFormat parser = new DecimalFormat();\n        double result;\n        boolean hasDecimalPoint;\n        for (int i = 0; i < testPattern.length; i++) {\n            parser.applyPattern(testPattern[i]);\n            hasDecimalPoint = testPattern[i].contains(\".\");\n\n            parser.setDecimalPatternMatchRequired(false);\n            try {\n                result = parser.parse(value2Parse).doubleValue();\n                assertEquals(\"wrong parsed value\", parseValue, result);\n            } catch (ParseException e) {\n                TestFmwk.errln(\"Parsing \" + value2Parse + \" should have succeeded with \" + testPattern[i] +\n                            \" and isDecimalPointMatchRequired set to: \" + parser.isDecimalPatternMatchRequired());\n            }\n            try {\n                result = parser.parse(value2ParseWithDecimal).doubleValue();\n                assertEquals(\"wrong parsed value\", parseValueWithDecimal, result);\n            } catch (ParseException e) {\n                TestFmwk.errln(\"Parsing \" + value2ParseWithDecimal + \" should have succeeded with \" + testPattern[i] +\n                            \" and isDecimalPointMatchRequired set to: \" + parser.isDecimalPatternMatchRequired());\n            }\n\n            parser.setDecimalPatternMatchRequired(true);\n            try {\n                result = parser.parse(value2Parse).doubleValue();\n                if(hasDecimalPoint){\n                    TestFmwk.errln(\"Parsing \" + value2Parse + \" should NOT have succeeded with \" + testPattern[i] +\n                            \" and isDecimalPointMatchRequired set to: \" + parser.isDecimalPatternMatchRequired());\n                }\n            } catch (ParseException e) {\n                    // OK, should fail\n            }\n            try {\n                result = parser.parse(value2ParseWithDecimal).doubleValue();\n                if(!hasDecimalPoint){\n                    TestFmwk.errln(\"Parsing \" + value2ParseWithDecimal + \" should NOT have succeeded with \" + testPattern[i] +\n                            \" and isDecimalPointMatchRequired set to: \" + parser.isDecimalPatternMatchRequired() +\n                            \" (got: \" + result + \")\");\n                }\n            } catch (ParseException e) {\n                    // OK, should fail\n            }\n        }\n    }\n\n    @Test\n    public void TestCurrFmtNegSameAsPositive() {\n        DecimalFormatSymbols decfmtsym = DecimalFormatSymbols.getInstance(Locale.US);\n        decfmtsym.setMinusSign('\\u200B'); // ZERO WIDTH SPACE, in ICU4J cannot set to empty string\n        DecimalFormat decfmt = new DecimalFormat(\"\\u00A4#,##0.00;-\\u00A4#,##0.00\", decfmtsym);\n        String currFmtResult = decfmt.format(-100.0);\n        if (!currFmtResult.equals(\"\\u200B$100.00\")) {\n            errln(\"decfmt.toPattern results wrong, expected \\u200B$100.00, got \" + currFmtResult);\n        }\n    }\n\n    @Test\n    public void TestNumberFormatTestDataToString() {\n        new DataDrivenNumberFormatTestData().toString();\n    }\n\n   // Testing for Issue 11805.\n    @Test\n    public void TestFormatToCharacterIteratorIssue11805 () {\n        final double number = -350.76;\n        DecimalFormat dfUS = (DecimalFormat) DecimalFormat.getCurrencyInstance(Locale.US);\n        String strUS = dfUS.format(number);\n        Set<AttributedCharacterIterator.Attribute> resultUS  = dfUS.formatToCharacterIterator(number).getAllAttributeKeys();\n        assertEquals(\"Negative US Results: \" + strUS, 5, resultUS.size());\n\n        // For each test, add assert that all the fields are present and in the right spot.\n        // TODO: Add tests for identify and position of each field, as in IntlTestDecimalFormatAPIC.\n\n        DecimalFormat dfDE = (DecimalFormat) DecimalFormat.getCurrencyInstance(Locale.GERMANY);\n        String strDE = dfDE.format(number);\n        Set<AttributedCharacterIterator.Attribute> resultDE  = dfDE.formatToCharacterIterator(number).getAllAttributeKeys();\n        assertEquals(\"Negative DE Results: \" + strDE, 5, resultDE.size());\n\n        DecimalFormat dfIN = (DecimalFormat) DecimalFormat.getCurrencyInstance(new Locale(\"hi\", \"in\"));\n        String strIN = dfIN.format(number);\n        Set<AttributedCharacterIterator.Attribute> resultIN  = dfIN.formatToCharacterIterator(number).getAllAttributeKeys();\n        assertEquals(\"Negative IN Results: \" + strIN, 5, resultIN.size());\n\n        DecimalFormat dfJP = (DecimalFormat) DecimalFormat.getCurrencyInstance(Locale.JAPAN);\n        String strJP = dfJP.format(number);\n        Set<AttributedCharacterIterator.Attribute> resultJP  = dfJP.formatToCharacterIterator(number).getAllAttributeKeys();\n        assertEquals(\"Negative JA Results: \" + strJP, 3, resultJP.size());\n\n        DecimalFormat dfGB = (DecimalFormat) DecimalFormat.getCurrencyInstance(new Locale(\"en\", \"gb\"));\n        String strGB = dfGB.format(number);\n        Set<AttributedCharacterIterator.Attribute> resultGB  = dfGB.formatToCharacterIterator(number).getAllAttributeKeys();\n        assertEquals(\"Negative GB Results: \" + strGB , 5, resultGB.size());\n\n        DecimalFormat dfPlural = (DecimalFormat) NumberFormat.getInstance(new Locale(\"en\", \"gb\"),\n            NumberFormat.PLURALCURRENCYSTYLE);\n        strGB = dfPlural.format(number);\n        resultGB = dfPlural.formatToCharacterIterator(number).getAllAttributeKeys();\n        assertEquals(\"Negative GB Results: \" + strGB , 5, resultGB.size());\n\n        strGB = dfPlural.format(1);\n        resultGB = dfPlural.formatToCharacterIterator(1).getAllAttributeKeys();\n        assertEquals(\"Negative GB Results: \" + strGB , 4, resultGB.size());\n\n        // Test output with unit value.\n        DecimalFormat auPlural = (DecimalFormat) NumberFormat.getInstance(new Locale(\"en\", \"au\"),\n                NumberFormat.PLURALCURRENCYSTYLE);\n        String strAU = auPlural.format(1L);\n        Set<AttributedCharacterIterator.Attribute> resultAU  =\n                auPlural.formatToCharacterIterator(1L).getAllAttributeKeys();\n        assertEquals(\"Unit AU Result: \" + strAU , 4, resultAU.size());\n\n        // Verify Permille fields.\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(new Locale(\"en\", \"gb\"));\n        DecimalFormat dfPermille = new DecimalFormat(\"####0.##\\u2030\", sym);\n        strGB = dfPermille.format(number);\n        resultGB = dfPermille.formatToCharacterIterator(number).getAllAttributeKeys();\n        assertEquals(\"Negative GB Permille Results: \" + strGB , 3, resultGB.size());\n    }\n\n    // Testing for Issue 11808.\n    @Test\n    public void TestRoundUnnecessarytIssue11808 () {\n        DecimalFormat df = (DecimalFormat) DecimalFormat.getInstance();\n        StringBuffer result = new StringBuffer(\"\");\n        df.setRoundingMode(BigDecimal.ROUND_UNNECESSARY);\n        df.applyPattern(\"00.0#E0\");\n\n        try {\n            df.format(99999.0, result, new FieldPosition(0));\n            fail(\"Missing ArithmeticException for double: \" + result);\n        } catch (ArithmeticException expected) {\n            // The exception should be thrown, since rounding is needed.\n        }\n\n        try {\n            result = df.format(99999, result, new FieldPosition(0));\n            fail(\"Missing ArithmeticException for int: \" + result);\n       } catch (ArithmeticException expected) {\n           // The exception should be thrown, since rounding is needed.\n        }\n\n        try {\n            result = df.format(new BigInteger(\"999999\"), result, new FieldPosition(0));\n            fail(\"Missing ArithmeticException for BigInteger: \" + result);\n        } catch (ArithmeticException expected) {\n            // The exception should be thrown, since rounding is needed.\n        }\n\n        try {\n            result = df.format(new BigDecimal(\"99999\"), result, new FieldPosition(0));\n            fail(\"Missing ArithmeticException for BigDecimal: \" + result);\n        } catch (ArithmeticException expected) {\n            // The exception should be thrown, since rounding is needed.\n        }\n\n        try {\n            result = df.format(new BigDecimal(\"-99999\"), result, new FieldPosition(0));\n            fail(\"Missing ArithmeticException for BigDecimal: \" + result);\n        } catch (ArithmeticException expected) {\n            // The exception should be thrown, since rounding is needed.\n        }\n    }\n\n    // Testing for Issue 11735.\n    @Test\n    public void TestNPEIssue11735() {\n        DecimalFormat fmt = new DecimalFormat(\"0\", new DecimalFormatSymbols(new ULocale(\"en\")));\n        ParsePosition ppos = new ParsePosition(0);\n        assertEquals(\"Currency symbol missing in parse. Expect null result.\",\n                fmt.parseCurrency(\"53.45\", ppos), null);\n    }\n\n    private void CompareAttributedCharacterFormatOutput(AttributedCharacterIterator iterator,\n        List<FieldContainer> expected, String formattedOutput) {\n\n        List<FieldContainer> result = new ArrayList<>();\n        while (iterator.getIndex() != iterator.getEndIndex()) {\n            int start = iterator.getRunStart();\n            int end = iterator.getRunLimit();\n            Iterator it = iterator.getAttributes().keySet().iterator();\n            AttributedCharacterIterator.Attribute attribute = (AttributedCharacterIterator.Attribute) it.next();\n            // For positions with both INTEGER and GROUPING attributes, we want the GROUPING attribute.\n            if (it.hasNext() && attribute.equals(NumberFormat.Field.INTEGER)) {\n                attribute = (AttributedCharacterIterator.Attribute) it.next();\n            }\n            Object value = iterator.getAttribute(attribute);\n            result.add(new FieldContainer(start, end, attribute, value));\n            iterator.setIndex(end);\n        }\n        assertEquals(\"Comparing vector length for \" + formattedOutput,\n            expected.size(), result.size());\n\n        if (!expected.containsAll(result)) {\n          // Print information on the differences.\n          for (int i = 0; i < expected.size(); i++) {\n            System.out.println(\"     expected[\" + i + \"] =\" +\n                expected.get(i).start + \" \" +\n                expected.get(i).end + \" \" +\n                expected.get(i).attribute + \" \" +\n                expected.get(i).value);\n            System.out.println(\" result[\" + i + \"] =\" +\n                result.get(i).start + \" \" +\n                result.get(i).end + \" \" +\n                result.get(i).attribute + \" \" +\n                result.get(i).value);\n          }\n        }\n        assertTrue(\"Comparing vector results for \" + formattedOutput, expected.containsAll(result));\n    }\n\n    // Testing for Issue 11914, missing FieldPositions for some field types.\n    @Test\n    public void TestNPEIssue11914() {\n        // First test: Double value with grouping separators.\n        List<FieldContainer> v1 = new ArrayList<>(7);\n        v1.add(new FieldContainer(0, 3, NumberFormat.Field.INTEGER));\n        v1.add(new FieldContainer(3, 4, NumberFormat.Field.GROUPING_SEPARATOR));\n        v1.add(new FieldContainer(4, 7, NumberFormat.Field.INTEGER));\n        v1.add(new FieldContainer(7, 8, NumberFormat.Field.GROUPING_SEPARATOR));\n        v1.add(new FieldContainer(8, 11, NumberFormat.Field.INTEGER));\n        v1.add(new FieldContainer(11, 12, NumberFormat.Field.DECIMAL_SEPARATOR));\n        v1.add(new FieldContainer(12, 15, NumberFormat.Field.FRACTION));\n\n        Number number = new Double(123456789.9753);\n        ULocale usLoc = new ULocale(\"en-US\");\n        DecimalFormatSymbols US = new DecimalFormatSymbols(usLoc);\n\n        NumberFormat outFmt = NumberFormat.getNumberInstance(usLoc);\n        String numFmtted = outFmt.format(number);\n        AttributedCharacterIterator iterator =\n                outFmt.formatToCharacterIterator(number);\n        CompareAttributedCharacterFormatOutput(iterator, v1, numFmtted);\n\n        // Second test: Double with scientific notation formatting.\n        List<FieldContainer> v2 = new ArrayList<>(7);\n        v2.add(new FieldContainer(0, 1, NumberFormat.Field.INTEGER));\n        v2.add(new FieldContainer(1, 2, NumberFormat.Field.DECIMAL_SEPARATOR));\n        v2.add(new FieldContainer(2, 5, NumberFormat.Field.FRACTION));\n        v2.add(new FieldContainer(5, 6, NumberFormat.Field.EXPONENT_SYMBOL));\n        v2.add(new FieldContainer(6, 7, NumberFormat.Field.EXPONENT_SIGN));\n        v2.add(new FieldContainer(7, 8, NumberFormat.Field.EXPONENT));\n        DecimalFormat fmt2 = new DecimalFormat(\"0.###E+0\", US);\n\n        numFmtted = fmt2.format(number);\n        iterator = fmt2.formatToCharacterIterator(number);\n        CompareAttributedCharacterFormatOutput(iterator, v2, numFmtted);\n\n        // Third test. BigInteger with grouping separators.\n        List<FieldContainer> v3 = new ArrayList<>(7);\n        v3.add(new FieldContainer(0, 1, NumberFormat.Field.SIGN));\n        v3.add(new FieldContainer(1, 2, NumberFormat.Field.INTEGER));\n        v3.add(new FieldContainer(2, 3, NumberFormat.Field.GROUPING_SEPARATOR));\n        v3.add(new FieldContainer(3, 6, NumberFormat.Field.INTEGER));\n        v3.add(new FieldContainer(6, 7, NumberFormat.Field.GROUPING_SEPARATOR));\n        v3.add(new FieldContainer(7, 10, NumberFormat.Field.INTEGER));\n        v3.add(new FieldContainer(10, 11, NumberFormat.Field.GROUPING_SEPARATOR));\n        v3.add(new FieldContainer(11, 14, NumberFormat.Field.INTEGER));\n        v3.add(new FieldContainer(14, 15, NumberFormat.Field.GROUPING_SEPARATOR));\n        v3.add(new FieldContainer(15, 18, NumberFormat.Field.INTEGER));\n        v3.add(new FieldContainer(18, 19, NumberFormat.Field.GROUPING_SEPARATOR));\n        v3.add(new FieldContainer(19, 22, NumberFormat.Field.INTEGER));\n        v3.add(new FieldContainer(22, 23, NumberFormat.Field.GROUPING_SEPARATOR));\n        v3.add(new FieldContainer(23, 26, NumberFormat.Field.INTEGER));\n        BigInteger bigNumberInt = new BigInteger(\"-1234567890246813579\");\n        String fmtNumberBigInt = outFmt.format(bigNumberInt);\n\n        iterator = outFmt.formatToCharacterIterator(bigNumberInt);\n        CompareAttributedCharacterFormatOutput(iterator, v3, fmtNumberBigInt);\n\n        // Fourth test: BigDecimal with exponential formatting.\n        List<FieldContainer> v4 = new ArrayList<>(7);\n        v4.add(new FieldContainer(0, 1, NumberFormat.Field.SIGN));\n        v4.add(new FieldContainer(1, 2, NumberFormat.Field.INTEGER));\n        v4.add(new FieldContainer(2, 3, NumberFormat.Field.DECIMAL_SEPARATOR));\n        v4.add(new FieldContainer(3, 6, NumberFormat.Field.FRACTION));\n        v4.add(new FieldContainer(6, 7, NumberFormat.Field.EXPONENT_SYMBOL));\n        v4.add(new FieldContainer(7, 8, NumberFormat.Field.EXPONENT_SIGN));\n        v4.add(new FieldContainer(8, 9, NumberFormat.Field.EXPONENT));\n\n        java.math.BigDecimal numberBigD = new java.math.BigDecimal(-123456789);\n        String fmtNumberBigDExp = fmt2.format(numberBigD);\n\n        iterator = fmt2.formatToCharacterIterator(numberBigD);\n        CompareAttributedCharacterFormatOutput(iterator, v4, fmtNumberBigDExp);\n\n    }\n\n    // Test that the decimal is shown even when there are no fractional digits\n    @Test\n    public void Test11621() throws Exception {\n        String pat = \"0.##E0\";\n\n        DecimalFormatSymbols icuSym = new DecimalFormatSymbols(Locale.US);\n        DecimalFormat icuFmt = new DecimalFormat(pat, icuSym);\n        icuFmt.setDecimalSeparatorAlwaysShown(true);\n        String icu = ((NumberFormat)icuFmt).format(299792458);\n\n        java.text.DecimalFormatSymbols jdkSym = new java.text.DecimalFormatSymbols(Locale.US);\n        java.text.DecimalFormat jdkFmt = new java.text.DecimalFormat(pat,jdkSym);\n        jdkFmt.setDecimalSeparatorAlwaysShown(true);\n        String jdk = ((java.text.NumberFormat)jdkFmt).format(299792458);\n\n        assertEquals(\"ICU and JDK placement of decimal in exponent\", jdk, icu);\n    }\n\n    private void checkFormatWithField(String testInfo, Format format, Object object,\n            String expected, Format.Field field, int begin, int end) {\n        StringBuffer buffer = new StringBuffer();\n        FieldPosition pos = new FieldPosition(field);\n        format.format(object, buffer, pos);\n\n        assertEquals(\"Test \" + testInfo + \": incorrect formatted text\", expected, buffer.toString());\n\n        if (begin != pos.getBeginIndex() || end != pos.getEndIndex()) {\n            assertEquals(\"Index mismatch\", field + \" \" + begin + \"..\" + end,\n                pos.getFieldAttribute() + \" \" + pos.getBeginIndex() + \"..\" + pos.getEndIndex());\n        }\n    }\n\n    @Test\n    public void TestMissingFieldPositionsCurrency() {\n        DecimalFormat formatter = (DecimalFormat) NumberFormat.getCurrencyInstance(ULocale.US);\n        Number number = new Double(92314587.66);\n        String result = \"$92,314,587.66\";\n\n        checkFormatWithField(\"currency\", formatter, number, result,\n            NumberFormat.Field.CURRENCY, 0, 1);\n        checkFormatWithField(\"integer\", formatter, number, result,\n            NumberFormat.Field.INTEGER, 1, 11);\n        checkFormatWithField(\"grouping separator\", formatter, number, result,\n            NumberFormat.Field.GROUPING_SEPARATOR, 3, 4);\n        checkFormatWithField(\"decimal separator\", formatter, number, result,\n            NumberFormat.Field.DECIMAL_SEPARATOR, 11, 12);\n        checkFormatWithField(\"fraction\", formatter, number, result,\n            NumberFormat.Field.FRACTION, 12, 14);\n    }\n\n    @Test\n    public void TestMissingFieldPositionsNegativeDouble() {\n        // test for exponential fields with double\n        DecimalFormatSymbols us_symbols = new DecimalFormatSymbols(ULocale.US);\n        Number number = new Double(-12345678.90123);\n        DecimalFormat formatter = new DecimalFormat(\"0.#####E+00\", us_symbols);\n        String numFmtted = formatter.format(number);\n\n        checkFormatWithField(\"sign\", formatter, number, numFmtted,\n            NumberFormat.Field.SIGN, 0, 1);\n        checkFormatWithField(\"integer\", formatter, number, numFmtted,\n            NumberFormat.Field.INTEGER, 1, 2);\n        checkFormatWithField(\"decimal separator\", formatter, number, numFmtted,\n            NumberFormat.Field.DECIMAL_SEPARATOR, 2, 3);\n        checkFormatWithField(\"exponent symbol\", formatter, number, numFmtted,\n            NumberFormat.Field.EXPONENT_SYMBOL, 8, 9);\n        checkFormatWithField(\"exponent sign\", formatter, number, numFmtted,\n            NumberFormat.Field.EXPONENT_SIGN, 9, 10);\n        checkFormatWithField(\"exponent\", formatter, number, numFmtted,\n            NumberFormat.Field.EXPONENT, 10, 12);\n    }\n\n    @Test\n    public void TestMissingFieldPositionsPerCent() {\n        // Check PERCENT\n        DecimalFormat percentFormat = (DecimalFormat) NumberFormat.getPercentInstance(ULocale.US);\n        Number number = new Double(-0.986);\n        String numberFormatted = percentFormat.format(number);\n        checkFormatWithField(\"sign\", percentFormat, number, numberFormatted,\n            NumberFormat.Field.SIGN, 0, 1);\n        checkFormatWithField(\"integer\", percentFormat, number, numberFormatted,\n            NumberFormat.Field.INTEGER, 1, 3);\n        checkFormatWithField(\"percent\", percentFormat, number, numberFormatted,\n            NumberFormat.Field.PERCENT, 3, 4);\n    }\n\n    @Test\n    public void TestMissingFieldPositionsPerCentPattern() {\n        // Check PERCENT with more digits\n        DecimalFormatSymbols us_symbols = new DecimalFormatSymbols(ULocale.US);\n        DecimalFormat fmtPercent = new DecimalFormat(\"0.#####%\", us_symbols);\n        Number number = new Double(-0.986);\n        String numFmtted = fmtPercent.format(number);\n\n        checkFormatWithField(\"sign\", fmtPercent, number, numFmtted,\n            NumberFormat.Field.SIGN, 0, 1);\n        checkFormatWithField(\"integer\", fmtPercent, number, numFmtted,\n            NumberFormat.Field.INTEGER, 1, 3);\n        checkFormatWithField(\"decimal separator\", fmtPercent, number, numFmtted,\n            NumberFormat.Field.DECIMAL_SEPARATOR, 3, 4);\n        checkFormatWithField(\"fraction\", fmtPercent, number, numFmtted,\n            NumberFormat.Field.FRACTION, 4, 5);\n        checkFormatWithField(\"percent\", fmtPercent, number, numFmtted,\n            NumberFormat.Field.PERCENT, 5, 6);\n    }\n\n    @Test\n    public void TestMissingFieldPositionsPerMille() {\n        // Check PERMILLE\n        DecimalFormatSymbols us_symbols = new DecimalFormatSymbols(ULocale.US);\n        DecimalFormat fmtPerMille = new DecimalFormat(\"0.######\u2030\", us_symbols);\n        Number numberPermille = new Double(-0.98654);\n        String numFmtted = fmtPerMille.format(numberPermille);\n\n        checkFormatWithField(\"sign\", fmtPerMille, numberPermille, numFmtted,\n            NumberFormat.Field.SIGN, 0, 1);\n        checkFormatWithField(\"integer\", fmtPerMille, numberPermille, numFmtted,\n            NumberFormat.Field.INTEGER, 1, 4);\n        checkFormatWithField(\"decimal separator\", fmtPerMille, numberPermille, numFmtted,\n            NumberFormat.Field.DECIMAL_SEPARATOR, 4, 5);\n        checkFormatWithField(\"fraction\", fmtPerMille, numberPermille, numFmtted,\n            NumberFormat.Field.FRACTION, 5, 7);\n        checkFormatWithField(\"permille\", fmtPerMille, numberPermille, numFmtted,\n            NumberFormat.Field.PERMILLE, 7, 8);\n    }\n\n    @Test\n    public void TestMissingFieldPositionsNegativeBigInt() {\n      DecimalFormatSymbols us_symbols = new DecimalFormatSymbols(ULocale.US);\n        DecimalFormat formatter = new DecimalFormat(\"0.#####E+0\", us_symbols);\n        Number number = new BigDecimal(\"-123456789987654321\");\n        String bigDecFmtted = formatter.format(number);\n\n        checkFormatWithField(\"sign\", formatter, number, bigDecFmtted,\n            NumberFormat.Field.SIGN, 0, 1);\n        checkFormatWithField(\"integer\", formatter, number, bigDecFmtted,\n            NumberFormat.Field.INTEGER, 1, 2);\n        checkFormatWithField(\"decimal separator\", formatter, number, bigDecFmtted,\n            NumberFormat.Field.DECIMAL_SEPARATOR, 2, 3);\n        checkFormatWithField(\"exponent symbol\", formatter, number, bigDecFmtted,\n            NumberFormat.Field.EXPONENT_SYMBOL, 8, 9);\n        checkFormatWithField(\"exponent sign\", formatter, number, bigDecFmtted,\n            NumberFormat.Field.EXPONENT_SIGN, 9, 10);\n        checkFormatWithField(\"exponent\", formatter, number, bigDecFmtted,\n            NumberFormat.Field.EXPONENT, 10, 12);\n    }\n\n    @Test\n    public void TestMissingFieldPositionsNegativeLong() {\n        Number number = new Long(\"-123456789987654321\");\n        DecimalFormatSymbols us_symbols = new DecimalFormatSymbols(ULocale.US);\n        DecimalFormat formatter = new DecimalFormat(\"0.#####E+0\", us_symbols);\n        String longFmtted = formatter.format(number);\n\n        checkFormatWithField(\"sign\", formatter, number, longFmtted,\n            NumberFormat.Field.SIGN, 0, 1);\n        checkFormatWithField(\"integer\", formatter, number, longFmtted,\n            NumberFormat.Field.INTEGER, 1, 2);\n        checkFormatWithField(\"decimal separator\", formatter, number, longFmtted,\n            NumberFormat.Field.DECIMAL_SEPARATOR, 2, 3);\n        checkFormatWithField(\"exponent symbol\", formatter, number, longFmtted,\n            NumberFormat.Field.EXPONENT_SYMBOL, 8, 9);\n        checkFormatWithField(\"exponent sign\", formatter, number, longFmtted,\n            NumberFormat.Field.EXPONENT_SIGN, 9, 10);\n        checkFormatWithField(\"exponent\", formatter, number, longFmtted,\n            NumberFormat.Field.EXPONENT, 10, 12);\n    }\n\n    @Test\n    public void TestMissingFieldPositionsPositiveBigDec() {\n        // Check complex positive;negative pattern.\n        DecimalFormatSymbols us_symbols = new DecimalFormatSymbols(ULocale.US);\n        DecimalFormat fmtPosNegSign = new DecimalFormat(\"+0.####E+00;-0.#######E+0\", us_symbols);\n        Number positiveExp = new Double(\"9876543210\");\n        String posExpFormatted = fmtPosNegSign.format(positiveExp);\n\n        checkFormatWithField(\"sign\", fmtPosNegSign, positiveExp, posExpFormatted,\n            NumberFormat.Field.SIGN, 0, 1);\n        checkFormatWithField(\"integer\", fmtPosNegSign, positiveExp, posExpFormatted,\n            NumberFormat.Field.INTEGER, 1, 2);\n        checkFormatWithField(\"decimal separator\", fmtPosNegSign, positiveExp, posExpFormatted,\n            NumberFormat.Field.DECIMAL_SEPARATOR, 2, 3);\n        checkFormatWithField(\"fraction\", fmtPosNegSign, positiveExp, posExpFormatted,\n            NumberFormat.Field.FRACTION, 3, 7);\n        checkFormatWithField(\"exponent symbol\", fmtPosNegSign, positiveExp, posExpFormatted,\n            NumberFormat.Field.EXPONENT_SYMBOL, 7, 8);\n        checkFormatWithField(\"exponent sign\", fmtPosNegSign, positiveExp, posExpFormatted,\n            NumberFormat.Field.EXPONENT_SIGN, 8, 9);\n        checkFormatWithField(\"exponent\", fmtPosNegSign, positiveExp, posExpFormatted,\n            NumberFormat.Field.EXPONENT, 9, 11);\n    }\n\n    @Test\n    public void TestMissingFieldPositionsNegativeBigDec() {\n        // Check complex positive;negative pattern.\n      DecimalFormatSymbols us_symbols = new DecimalFormatSymbols(ULocale.US);\n        DecimalFormat fmtPosNegSign = new DecimalFormat(\"+0.####E+00;-0.#######E+0\", us_symbols);\n        Number negativeExp = new BigDecimal(\"-0.000000987654321083\");\n        String negExpFormatted = fmtPosNegSign.format(negativeExp);\n\n        checkFormatWithField(\"sign\", fmtPosNegSign, negativeExp, negExpFormatted,\n            NumberFormat.Field.SIGN, 0, 1);\n        checkFormatWithField(\"integer\", fmtPosNegSign, negativeExp, negExpFormatted,\n            NumberFormat.Field.INTEGER, 1, 2);\n        checkFormatWithField(\"decimal separator\", fmtPosNegSign, negativeExp, negExpFormatted,\n            NumberFormat.Field.DECIMAL_SEPARATOR, 2, 3);\n        checkFormatWithField(\"fraction\", fmtPosNegSign, negativeExp, negExpFormatted,\n            NumberFormat.Field.FRACTION, 3, 7);\n        checkFormatWithField(\"exponent symbol\", fmtPosNegSign, negativeExp, negExpFormatted,\n            NumberFormat.Field.EXPONENT_SYMBOL, 7, 8);\n        checkFormatWithField(\"exponent sign\", fmtPosNegSign, negativeExp, negExpFormatted,\n            NumberFormat.Field.EXPONENT_SIGN, 8, 9);\n        checkFormatWithField(\"exponent\", fmtPosNegSign, negativeExp, negExpFormatted,\n            NumberFormat.Field.EXPONENT, 9, 11);\n    }\n\n    @Test\n    public void TestStringSymbols() {\n        DecimalFormatSymbols symbols = new DecimalFormatSymbols(ULocale.US);\n\n        // Attempt digits with multiple code points.\n        String[] customDigits = {\"(0)\", \"(1)\", \"(2)\", \"(3)\", \"(4)\", \"(5)\", \"(6)\", \"(7)\", \"(8)\", \"(9)\"};\n        symbols.setDigitStrings(customDigits);\n        DecimalFormat fmt = new DecimalFormat(\"#,##0.0#\", symbols);\n        expect2(fmt, 1234567.89, \"(1),(2)(3)(4),(5)(6)(7).(8)(9)\");\n\n        // Scientific notation should work.\n        fmt.applyPattern(\"@@@E0\");\n        expect2(fmt, 1230000, \"(1).(2)(3)E(6)\");\n\n        // Grouping and decimal with multiple code points (supported in parsing since ICU 61)\n        symbols.setDecimalSeparatorString(\"~~\");\n        symbols.setGroupingSeparatorString(\"^^\");\n        fmt.setDecimalFormatSymbols(symbols);\n        fmt.applyPattern(\"#,##0.0#\");\n        expect2(fmt, 1234567.89, \"(1)^^(2)(3)(4)^^(5)(6)(7)~~(8)(9)\");\n\n        // Digits starting at U+1D7CE MATHEMATICAL BOLD DIGIT ZERO\n        // These are all single code points, so parsing will work.\n        for (int i=0; i<10; i++) customDigits[i] = new String(Character.toChars(0x1D7CE+i));\n        symbols.setDigitStrings(customDigits);\n        symbols.setDecimalSeparatorString(\"\ud83d\ude01\");\n        symbols.setGroupingSeparatorString(\"\ud83d\ude0e\");\n        fmt.setDecimalFormatSymbols(symbols);\n        expect2(fmt, 1234.56, \"\ud835\udfcf\ud83d\ude0e\ud835\udfd0\ud835\udfd1\ud835\udfd2\ud83d\ude01\ud835\udfd3\ud835\udfd4\");\n    }\n\n    @Test\n    public void TestArabicCurrencyPatternInfo() {\n        ULocale arLocale = new ULocale(\"ar\");\n\n        DecimalFormatSymbols symbols = new DecimalFormatSymbols(arLocale);\n        String currSpacingPatn = symbols.getPatternForCurrencySpacing(DecimalFormatSymbols.CURRENCY_SPC_CURRENCY_MATCH, true);\n        if (currSpacingPatn==null || currSpacingPatn.length() == 0) {\n            errln(\"locale ar, getPatternForCurrencySpacing returns null or 0-length string\");\n        }\n\n        DecimalFormat currAcctFormat = (DecimalFormat)NumberFormat.getInstance(arLocale, NumberFormat.ACCOUNTINGCURRENCYSTYLE);\n        String currAcctPatn = currAcctFormat.toPattern();\n        if (currAcctPatn==null || currAcctPatn.length() == 0) {\n            errln(\"locale ar, toPattern for ACCOUNTINGCURRENCYSTYLE returns null or 0-length string\");\n        }\n    }\n\n    @Test\n    public void TestMinMaxOverrides()\n            throws IllegalAccessException, IllegalArgumentException, InvocationTargetException,\n                NoSuchMethodException, SecurityException {\n        Class<?>[] baseClasses = {NumberFormat.class, NumberFormat.class, DecimalFormat.class};\n        String[] names = {\"Integer\", \"Fraction\", \"Significant\"};\n        for (int i = 0; i < 3; i++) {\n            DecimalFormat df = new DecimalFormat();\n            Class<?> base = baseClasses[i];\n            String name = names[i];\n            Method getMinimum = base.getDeclaredMethod(\"getMinimum\" + name + \"Digits\");\n            Method setMinimum = base.getDeclaredMethod(\"setMinimum\" + name + \"Digits\", Integer.TYPE);\n            Method getMaximum = base.getDeclaredMethod(\"getMaximum\" + name + \"Digits\");\n            Method setMaximum = base.getDeclaredMethod(\"setMaximum\" + name + \"Digits\", Integer.TYPE);\n\n            // Check max overrides min\n            setMinimum.invoke(df, 2);\n            assertEquals(name + \" getMin A\", 2, getMinimum.invoke(df));\n            setMaximum.invoke(df, 3);\n            assertEquals(name + \" getMin B\", 2, getMinimum.invoke(df));\n            assertEquals(name + \" getMax B\", 3, getMaximum.invoke(df));\n            setMaximum.invoke(df, 2);\n            assertEquals(name + \" getMin C\", 2, getMinimum.invoke(df));\n            assertEquals(name + \" getMax C\", 2, getMaximum.invoke(df));\n            setMaximum.invoke(df, 1);\n            assertEquals(name + \" getMin D\", 1, getMinimum.invoke(df));\n            assertEquals(name + \" getMax D\", 1, getMaximum.invoke(df));\n\n            // Check min overrides max\n            setMaximum.invoke(df, 2);\n            assertEquals(name + \" getMax E\", 2, getMaximum.invoke(df));\n            setMinimum.invoke(df, 1);\n            assertEquals(name + \" getMin F\", 1, getMinimum.invoke(df));\n            assertEquals(name + \" getMax F\", 2, getMaximum.invoke(df));\n            setMinimum.invoke(df, 2);\n            assertEquals(name + \" getMin G\", 2, getMinimum.invoke(df));\n            assertEquals(name + \" getMax G\", 2, getMaximum.invoke(df));\n            setMinimum.invoke(df, 3);\n            assertEquals(name + \" getMin H\", 3, getMinimum.invoke(df));\n            assertEquals(name + \" getMax H\", 3, getMaximum.invoke(df));\n        }\n    }\n\n    @Test\n    public void TestSetMathContext() throws ParseException {\n        java.math.MathContext fourDigits = new java.math.MathContext(4);\n        java.math.MathContext unlimitedCeiling = new java.math.MathContext(0, RoundingMode.CEILING);\n\n        // Test rounding\n        DecimalFormat df = new DecimalFormat();\n        assertEquals(\"Default format\", \"9,876.543\", df.format(9876.5432));\n        df.setMathContext(fourDigits);\n        assertEquals(\"Format with fourDigits\", \"9,877\", df.format(9876.5432));\n        df.setMathContext(unlimitedCeiling);\n        assertEquals(\"Format with unlimitedCeiling\", \"9,876.544\", df.format(9876.5432));\n\n        // Test multiplication\n        df = new DecimalFormat(\"0.000%\");\n        assertEquals(\"Default multiplication\", \"12.001%\", df.format(0.120011));\n        df.setMathContext(fourDigits);\n        assertEquals(\"Multiplication with fourDigits\", \"12.000%\", df.format(0.120011));\n        df.setMathContext(unlimitedCeiling);\n        assertEquals(\"Multiplication with unlimitedCeiling\", \"12.002%\", df.format(0.120011));\n\n        // Test simple division\n        df = new DecimalFormat(\"0%\");\n        assertEquals(\"Default division\", 0.12001, df.parse(\"12.001%\").doubleValue());\n        df.setMathContext(fourDigits);\n        // NOTE: Since ICU 61, division no longer occurs with percentage parsing.\n        // assertEquals(\"Division with fourDigits\", 0.12, df.parse(\"12.001%\").doubleValue());\n        assertEquals(\"Division with fourDigits\", 0.12001, df.parse(\"12.001%\").doubleValue());\n        df.setMathContext(unlimitedCeiling);\n        assertEquals(\"Division with unlimitedCeiling\", 0.12001, df.parse(\"12.001%\").doubleValue());\n\n        // Test extreme division\n        df = new DecimalFormat();\n        df.setMultiplier(1000000007); // prime number\n        String hugeNumberString = \"9876543212345678987654321234567898765432123456789\"; // 49 digits\n        BigInteger huge34Digits = new BigInteger(\"9876543143209876985185182338271622000000\");\n        BigInteger huge4Digits = new BigInteger(\"9877000000000000000000000000000000000000\");\n        BigInteger actual34Digits = ((BigDecimal) df.parse(hugeNumberString)).toBigIntegerExact();\n        assertEquals(\"Default extreme division\", huge34Digits, actual34Digits);\n        df.setMathContext(fourDigits);\n        BigInteger actual4Digits = ((BigDecimal) df.parse(hugeNumberString)).toBigIntegerExact();\n        assertEquals(\"Extreme division with fourDigits\", huge4Digits, actual4Digits);\n    }\n\n    /**\n     * ArithmeticException is thrown when inverting multiplier produces a non-terminating\n     * decimal result in conjunction with MathContext of unlimited precision.\n     */\n    @Test\n    public void testSetMathContextArithmeticException() {\n        DecimalFormat df = new DecimalFormat();\n        df.setMultiplier(7);\n        try {\n            df.setMathContext(java.math.MathContext.UNLIMITED);\n            fail(\"Extreme division with unlimited precision should throw ArithmeticException\");\n        } catch (ArithmeticException e) {\n            // expected\n        }\n    }\n\n    /**\n     * ArithmeticException is thrown when inverting multiplier produces a non-terminating\n     * decimal result in conjunction with MathContext of unlimited precision.\n     */\n    @Test\n    public void testSetMathContextICUArithmeticException() {\n        DecimalFormat df = new DecimalFormat();\n        df.setMultiplier(7);\n        try {\n            df.setMathContextICU(new MathContext(0));\n            fail(\"Extreme division with unlimited precision should throw ArithmeticException\");\n        } catch (ArithmeticException e) {\n            // expected\n        }\n    }\n\n    /**\n     * ArithmeticException is thrown when inverting multiplier produces a non-terminating\n     * decimal result in conjunction with MathContext of unlimited precision.\n     */\n    @Test\n    public void testSetMultiplierArithmeticException() {\n        DecimalFormat df = new DecimalFormat();\n        df.setMathContext(java.math.MathContext.UNLIMITED);\n        try {\n            df.setMultiplier(7);\n            fail(\"Extreme division with unlimited precision should throw ArithmeticException\");\n        } catch (ArithmeticException e) {\n            // expected\n        }\n    }\n\n    @Test\n    public void Test10436() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getInstance(Locale.ENGLISH);\n        df.setRoundingMode(MathContext.ROUND_CEILING);\n        df.setMinimumFractionDigits(0);\n        df.setMaximumFractionDigits(0);\n        assertEquals(\"-.99 should round toward infinity\", \"-0\", df.format(-0.99));\n    }\n\n    @Test\n    public void Test10765() {\n        NumberFormat fmt = NumberFormat.getInstance(new ULocale(\"en\"));\n        fmt.setMinimumIntegerDigits(10);\n        FieldPosition pos = new FieldPosition(NumberFormat.Field.GROUPING_SEPARATOR);\n        StringBuffer sb = new StringBuffer();\n        fmt.format(1234567, sb, pos);\n        assertEquals(\"Should have multiple grouping separators\", \"0,001,234,567\", sb.toString());\n        assertEquals(\"FieldPosition should report the first occurence\", 1, pos.getBeginIndex());\n        assertEquals(\"FieldPosition should report the first occurence\", 2, pos.getEndIndex());\n    }\n\n    @Test\n    public void Test10997() {\n        NumberFormat fmt = NumberFormat.getCurrencyInstance(new ULocale(\"en-US\"));\n        fmt.setMinimumFractionDigits(4);\n        fmt.setMaximumFractionDigits(4);\n        String str1 = fmt.format(new CurrencyAmount(123.45, Currency.getInstance(\"USD\")));\n        String str2 = fmt.format(new CurrencyAmount(123.45, Currency.getInstance(\"EUR\")));\n        assertEquals(\"minFrac 4 should be respected in default currency\", \"$123.4500\", str1);\n        assertEquals(\"minFrac 4 should be respected in different currency\", \"\u20ac123.4500\", str2);\n    }\n\n    @Test\n    public void Test11020() {\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(ULocale.FRANCE);\n        DecimalFormat fmt = new DecimalFormat(\"0.05E0\", sym);\n        String result = fmt.format(12301.2).replace('\\u00a0', ' ');\n        assertEquals(\"Rounding increment should be applied after magnitude scaling\", \"1,25E4\", result);\n    }\n\n    @Test\n    public void Test11025() {\n        String pattern = \"\u00a4\u00a4 **####0.00\";\n        DecimalFormatSymbols sym = new DecimalFormatSymbols(ULocale.FRANCE);\n        DecimalFormat fmt = new DecimalFormat(pattern, sym);\n        String result = fmt.format(433.0);\n        assertEquals(\"Number should be padded to 11 characters\", \"EUR *433,00\", result);\n    }\n\n    @Test\n    public void Test11640_TripleCurrencySymbol() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getInstance();\n        df.applyPattern(\"\u00a4\u00a4\u00a4 0\");\n        String result = df.getPositivePrefix();\n        assertEquals(\"Triple-currency should give long name on getPositivePrefix\", \"US dollars \", result);\n    }\n\n    @Test\n    public void Test11645() {\n        String pattern = \"#,##0.0#\";\n        DecimalFormat fmt = (DecimalFormat) NumberFormat.getInstance();\n        fmt.applyPattern(pattern);\n        DecimalFormat fmtCopy;\n\n        final int newMultiplier = 37;\n        fmtCopy = (DecimalFormat) fmt.clone();\n        assertNotEquals(\"Value before setter\", fmtCopy.getMultiplier(), newMultiplier);\n        fmtCopy.setMultiplier(newMultiplier);\n        assertEquals(\"Value after setter\", fmtCopy.getMultiplier(), newMultiplier);\n        fmtCopy.applyPattern(pattern);\n        assertEquals(\"Value after applyPattern\", fmtCopy.getMultiplier(), newMultiplier);\n        assertFalse(\"multiplier\", fmt.equals(fmtCopy));\n\n        final int newRoundingMode = RoundingMode.CEILING.ordinal();\n        fmtCopy = (DecimalFormat) fmt.clone();\n        assertNotEquals(\"Value before setter\", fmtCopy.getRoundingMode(), newRoundingMode);\n        fmtCopy.setRoundingMode(newRoundingMode);\n        assertEquals(\"Value after setter\", fmtCopy.getRoundingMode(), newRoundingMode);\n        fmtCopy.applyPattern(pattern);\n        assertEquals(\"Value after applyPattern\", fmtCopy.getRoundingMode(), newRoundingMode);\n        assertFalse(\"roundingMode\", fmt.equals(fmtCopy));\n\n        final Currency newCurrency = Currency.getInstance(\"EAT\");\n        fmtCopy = (DecimalFormat) fmt.clone();\n        assertNotEquals(\"Value before setter\", fmtCopy.getCurrency(), newCurrency);\n        fmtCopy.setCurrency(newCurrency);\n        assertEquals(\"Value after setter\", fmtCopy.getCurrency(), newCurrency);\n        fmtCopy.applyPattern(pattern);\n        assertEquals(\"Value after applyPattern\", fmtCopy.getCurrency(), newCurrency);\n        assertFalse(\"currency\", fmt.equals(fmtCopy));\n\n        final CurrencyUsage newCurrencyUsage = CurrencyUsage.CASH;\n        fmtCopy = (DecimalFormat) fmt.clone();\n        assertNotEquals(\"Value before setter\", fmtCopy.getCurrencyUsage(), newCurrencyUsage);\n        fmtCopy.setCurrencyUsage(CurrencyUsage.CASH);\n        assertEquals(\"Value after setter\", fmtCopy.getCurrencyUsage(), newCurrencyUsage);\n        fmtCopy.applyPattern(pattern);\n        assertEquals(\"Value after applyPattern\", fmtCopy.getCurrencyUsage(), newCurrencyUsage);\n        assertFalse(\"currencyUsage\", fmt.equals(fmtCopy));\n    }\n\n    @Test\n    public void Test11646() {\n        DecimalFormatSymbols symbols = new DecimalFormatSymbols(new ULocale(\"en_US\"));\n        String pattern = \"\\u00a4\\u00a4\\u00a4 0.00 %\\u00a4\\u00a4\";\n        DecimalFormat fmt = new DecimalFormat(pattern, symbols);\n\n        // Test equality with affixes. set affix methods can't capture special\n        // characters which is why equality should fail.\n        {\n          DecimalFormat fmtCopy = (DecimalFormat) fmt.clone();\n          assertEquals(\"\", fmt, fmtCopy);\n          fmtCopy.setPositivePrefix(fmtCopy.getPositivePrefix());\n          assertNotEquals(\"\", fmt, fmtCopy);\n        }\n        {\n          DecimalFormat fmtCopy = (DecimalFormat) fmt.clone();\n          assertEquals(\"\", fmt, fmtCopy);\n          fmtCopy.setPositiveSuffix(fmtCopy.getPositiveSuffix());\n          assertNotEquals(\"\", fmt, fmtCopy);\n        }\n        {\n          DecimalFormat fmtCopy = (DecimalFormat) fmt.clone();\n          assertEquals(\"\", fmt, fmtCopy);\n          fmtCopy.setNegativePrefix(fmtCopy.getNegativePrefix());\n          assertNotEquals(\"\", fmt, fmtCopy);\n        }\n        {\n          DecimalFormat fmtCopy = (DecimalFormat) fmt.clone();\n          assertEquals(\"\", fmt, fmtCopy);\n          fmtCopy.setNegativeSuffix(fmtCopy.getNegativeSuffix());\n          assertNotEquals(\"\", fmt, fmtCopy);\n        }\n    }\n\n    @Test\n    public void Test11648() {\n        DecimalFormat df = new DecimalFormat(\"0.00\");\n        df.setScientificNotation(true);\n        String pat = df.toPattern();\n        assertEquals(\"A valid scientific notation pattern should be produced\", \"0.00E0\", pat);\n    }\n\n    @Test\n    public void Test11649() {\n        String pattern = \"\\u00a4\\u00a4\\u00a4 0.00\";\n        DecimalFormat fmt = new DecimalFormat(pattern);\n        fmt.setCurrency(Currency.getInstance(\"USD\"));\n        assertEquals(\"Triple currency sign should format long name\", \"US dollars 12.34\", fmt.format(12.34));\n\n        String newPattern = fmt.toPattern();\n        assertEquals(\"Should produce a valid pattern\", pattern, newPattern);\n\n        DecimalFormat fmt2 = new DecimalFormat(newPattern);\n        fmt2.setCurrency(Currency.getInstance(\"USD\"));\n        assertEquals(\"Triple currency sign pattern should round-trip\", \"US dollars 12.34\", fmt2.format(12.34));\n\n        String quotedPattern = \"\\u00a4\\u00a4'\\u00a4' 0.00\";\n        DecimalFormat fmt3 = new DecimalFormat(quotedPattern);\n        assertEquals(\"Should be treated as double currency sign\", \"USD\\u00a4 12.34\", fmt3.format(12.34));\n\n        String outQuotedPattern = fmt3.toPattern();\n        assertEquals(\"Double currency sign with quoted sign should round-trip\", quotedPattern, outQuotedPattern);\n    }\n\n    @Test\n    @Ignore\n    public void Test11686() {\n        // Only passes with slow mode.\n        // TODO: Re-enable this test with slow mode.\n        DecimalFormat df = new DecimalFormat();\n        df.setPositiveSuffix(\"0K\");\n        df.setNegativeSuffix(\"0N\");\n        expect2(df, 123, \"1230K\");\n        expect2(df, -123, \"-1230N\");\n    }\n\n    @Test\n    public void Test11839() {\n        DecimalFormatSymbols dfs = new DecimalFormatSymbols(ULocale.ENGLISH);\n        dfs.setMinusSignString(\"a\u2238\");\n        dfs.setPlusSignString(\"b\u2214\"); //  \u2214  U+2214 DOT PLUS\n        DecimalFormat df = new DecimalFormat(\"0.00+;0.00-\", dfs);\n        String result = df.format(-1.234);\n        assertEquals(\"Locale-specific minus sign should be used\", \"1.23a\u2238\", result);\n        result = df.format(1.234);\n        assertEquals(\"Locale-specific plus sign should be used\", \"1.23b\u2214\", result);\n        // Test round-trip with parse\n        expect2(df, -456, \"456.00a\u2238\");\n        expect2(df, 456, \"456.00b\u2214\");\n    }\n\n    @Test\n    public void Test12753() {\n        ULocale locale = new ULocale(\"en-US\");\n        DecimalFormatSymbols symbols = DecimalFormatSymbols.getInstance(locale);\n        symbols.setDecimalSeparator('*');\n        DecimalFormat df = new DecimalFormat(\"0.00\", symbols);\n        df.setDecimalPatternMatchRequired(true);\n        try {\n            df.parse(\"123\");\n            fail(\"Parsing integer succeeded even though setDecimalPatternMatchRequired was set\");\n        } catch (ParseException e) {\n            // Parse failed (expected)\n        }\n    }\n\n    @Test\n    public void Test12962() {\n        String pat = \"**0.00\";\n        DecimalFormat df = new DecimalFormat(pat);\n        String newPat = df.toPattern();\n        assertEquals(\"Format width changed upon calling applyPattern\", pat.length(), newPat.length());\n    }\n\n    @Test\n    public void Test10354() {\n        DecimalFormatSymbols dfs = new DecimalFormatSymbols();\n        dfs.setNaN(\"\");\n        DecimalFormat df = new DecimalFormat();\n        df.setDecimalFormatSymbols(dfs);\n        try {\n            df.formatToCharacterIterator(Double.NaN);\n            // pass\n        } catch (IllegalArgumentException e) {\n            throw new AssertionError(e);\n        }\n    }\n\n    @Test\n    public void Test11913() {\n        NumberFormat df = DecimalFormat.getInstance();\n        String result = df.format(new BigDecimal(\"1.23456789E400\"));\n        assertEquals(\"Should format more than 309 digits\", \"12,345,678\", result.substring(0, 10));\n        assertEquals(\"Should format more than 309 digits\", 534, result.length());\n    }\n\n    @Test\n    public void Test12045() {\n        if (logKnownIssue(\"12045\", \"XSU is missing from fr\")) { return; }\n\n        NumberFormat nf = NumberFormat.getInstance(new ULocale(\"fr\"), NumberFormat.PLURALCURRENCYSTYLE);\n        ParsePosition ppos = new ParsePosition(0);\n        try {\n            CurrencyAmount result = nf.parseCurrency(\"2,34 XSU\", ppos);\n            assertEquals(\"Parsing should succeed on XSU\",\n                         new CurrencyAmount(2.34, Currency.getInstance(\"XSU\")), result);\n            // pass\n        } catch (Exception e) {\n            //throw new AssertionError(\"Should have been able to parse XSU\", e);\n            throw new AssertionError(\"Should have been able to parse XSU: \" + e.getMessage());\n        }\n    }\n\n    @Test\n    public void Test11739() {\n        NumberFormat nf = NumberFormat.getCurrencyInstance(new ULocale(\"sr_BA\"));\n        ((DecimalFormat) nf).applyPattern(\"#,##0.0 \u00a4\u00a4\u00a4\");\n        ParsePosition ppos = new ParsePosition(0);\n        CurrencyAmount result = nf.parseCurrency(\"1.500 \u0430\u043c\u0435\u0440\u0438\u0447\u043a\u0438 \u0434\u043e\u043b\u0430\u0440\", ppos);\n        assertEquals(\"Should parse to 1500 USD\", new CurrencyAmount(1500, Currency.getInstance(\"USD\")), result);\n    }\n\n    @Test\n    public void Test11647() {\n        DecimalFormat df = new DecimalFormat();\n        df.applyPattern(\"\u00a4\u00a4\u00a4\u00a4#\");\n        String actual = df.format(123);\n        assertEquals(\"Should replace 4 currency signs with U+FFFD\", \"\\uFFFD123\", actual);\n    }\n\n    @Test\n    public void Test12567() {\n        DecimalFormat df1 = (DecimalFormat) NumberFormat.getInstance(NumberFormat.PLURALCURRENCYSTYLE);\n        DecimalFormat df2 = (DecimalFormat) NumberFormat.getInstance(NumberFormat.NUMBERSTYLE);\n        df2.setCurrency(df1.getCurrency());\n        df2.setCurrencyPluralInfo(df1.getCurrencyPluralInfo());\n        df1.applyPattern(\"0.00\");\n        df2.applyPattern(\"0.00\");\n        assertEquals(\"df1 == df2\", df1, df2);\n        assertEquals(\"df2 == df1\", df2, df1);\n        df2.setPositivePrefix(\"abc\");\n        assertNotEquals(\"df1 != df2\", df1, df2);\n        assertNotEquals(\"df2 != df1\", df2, df1);\n    }\n\n    @Test\n    public void Test11897_LocalizedPatternSeparator() {\n        // In a locale with a different <list> symbol, like arabic,\n        // kPatternSeparatorSymbol should still be ';'\n        {\n            DecimalFormatSymbols dfs = new DecimalFormatSymbols(new ULocale(\"ar\"));\n            assertEquals(\"pattern separator symbol should be ;\",\n                    ';',\n                    dfs.getPatternSeparator());\n        }\n\n        // However, the custom symbol should be used in localized notation\n        // when set manually via API\n        {\n            DecimalFormatSymbols dfs = new DecimalFormatSymbols(new ULocale(\"en\"));\n            dfs.setPatternSeparator('!');\n            DecimalFormat df = new DecimalFormat(\"0\", dfs);\n            df.applyPattern(\"a0;b0\"); // should not throw\n            assertEquals(\"should apply the normal pattern\",\n                    df.getNegativePrefix(),\n                    \"b\");\n            df.applyLocalizedPattern(\"c0!d0\"); // should not throw\n            assertEquals(\"should apply the localized pattern\",\n                    df.getNegativePrefix(),\n                    \"d\");\n        }\n    }\n\n    @Test\n    public void Test13055() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getPercentInstance();\n        df.setMaximumFractionDigits(0);\n        df.setRoundingMode(BigDecimal.ROUND_HALF_EVEN);\n        assertEquals(\"Should round percent toward even number\", \"216%\", df.format(2.155));\n    }\n\n    @Test\n    public void Test13056() {\n        DecimalFormat df = new DecimalFormat(\"#,##0\");\n        assertEquals(\"Primary grouping should return 3\", 3, df.getGroupingSize());\n        assertEquals(\"Secondary grouping should return 0\", 0, df.getSecondaryGroupingSize());\n        df.setSecondaryGroupingSize(3);\n        assertEquals(\"Primary grouping should still return 3\", 3, df.getGroupingSize());\n        assertEquals(\"Secondary grouping should round-trip\", 3, df.getSecondaryGroupingSize());\n        df.setGroupingSize(4);\n        assertEquals(\"Primary grouping should return 4\", 4, df.getGroupingSize());\n        assertEquals(\"Secondary should remember explicit setting and return 3\", 3, df.getSecondaryGroupingSize());\n    }\n\n    @Test\n    public void Test13074() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getCurrencyInstance(new ULocale(\"bg-BG\"));\n        String result = df.format(987654.321);\n        assertEquals(\"Locale 'bg' should not use monetary grouping\", \"987654,32\u00a0\u043b\u0432.\", result);\n    }\n\n    @Test\n    public void Test13088and13162() {\n        ULocale loc = new ULocale(\"fa\");\n        String pattern1 = \"%\\u00A0#,##0;%\\u00A0-#,##0\";\n        double num = -12.34;\n        DecimalFormatSymbols symbols = DecimalFormatSymbols.getInstance(loc);\n        // If the symbols ever change in locale data, please call the setters so that this test\n        // continues to use the old symbols.\n        // The fa percent symbol does change in CLDR 32, so....\n        symbols.setPercentString(\"\u200e\u066a\");\n        assertEquals(\"Checking for expected symbols\", \"\u200e\u2212\", symbols.getMinusSignString());\n        assertEquals(\"Checking for expected symbols\", \"\u200e\u066a\", symbols.getPercentString());\n        DecimalFormat numfmt = new DecimalFormat(pattern1, symbols);\n        expect2(numfmt, num, \"\u200e\u066a\u00a0\u200e\u2212\u06f1\u066c\u06f2\u06f3\u06f4\");\n        String pattern2 = \"%#,##0;%-#,##0\";\n        numfmt = new DecimalFormat(pattern2, symbols);\n        expect2(numfmt, num, \"\u200e\u066a\u200e\u2212\u06f1\u066c\u06f2\u06f3\u06f4\");\n    }\n\n    @Test\n    public void Test13113_MalformedPatterns() {\n        String[][] cases = {\n                {\"'\", \"quoted literal\"},\n                {\"ab#c'd\", \"quoted literal\"},\n                {\"ab#c*\", \"unquoted literal\"},\n                {\"0#\", \"# cannot follow 0\"},\n                {\".#0\", \"0 cannot follow #\"},\n                {\"@0\", \"Cannot mix @ and 0\"},\n                {\"0@\", \"Cannot mix 0 and @\"},\n                {\"#x#\", \"unquoted special character\"},\n                {\"@#@\", \"# inside of a run of @\"},\n        };\n        for (String[] cas : cases) {\n            try {\n                new DecimalFormat(cas[0]);\n                fail(\"Should have thrown on malformed pattern\");\n            } catch (IllegalArgumentException ex) {\n                assertTrue(\"Exception should contain \\\"Malformed pattern\\\": \" + ex.getMessage(),\n                        ex.getMessage().contains(\"Malformed pattern\"));\n                assertTrue(\"Exception should contain \\\"\" + cas[1] + \"\\\"\" + ex.getMessage(),\n                        ex.getMessage().contains(cas[1]));\n            }\n        }\n    }\n\n    @Test\n    public void Test13118() {\n        DecimalFormat df = new DecimalFormat(\"@@@\");\n        df.setScientificNotation(true);\n        for (double d=12345.67; d>1e-6; d/=10) {\n            String result = df.format(d);\n            assertEquals(\"Should produce a string of expected length on \" + d,\n                    d > 1 ? 6 : 7, result.length());\n        }\n    }\n\n    @Test\n    public void Test13289() {\n        DecimalFormat df = new DecimalFormat(\"#00.0#E0\");\n        String result = df.format(0.00123);\n        assertEquals(\"Should ignore scientific minInt if maxInt>minInt\", \"1.23E-3\", result);\n    }\n\n    @Test\n    public void Test13310() {\n        // Note: if minInt > 8, then maxInt can be greater than 8.\n        assertEquals(\"Should not throw an assertion error\",\n                \"100000007.6E-1\",\n                new DecimalFormat(\"000000000.0#E0\").format(10000000.76d));\n    }\n\n    @Test\n    public void Test13391() throws ParseException {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getInstance(new ULocale(\"ccp\"));\n        df.setParseStrict(true);\n        String expected = \"\\uD804\\uDD37\\uD804\\uDD38,\\uD804\\uDD39\\uD804\\uDD3A\\uD804\\uDD3B\";\n        assertEquals(\"Should produce expected output in ccp\", expected, df.format(12345));\n        Number result = df.parse(expected);\n        assertEquals(\"Should parse to 12345 in ccp\", 12345, result.longValue());\n\n        df = (DecimalFormat) NumberFormat.getScientificInstance(new ULocale(\"ccp\"));\n        df.setParseStrict(true);\n        String expectedScientific = \"\\uD804\\uDD37.\\uD804\\uDD39E\\uD804\\uDD38\";\n        assertEquals(\"Should produce expected scientific output in ccp\",\n                expectedScientific, df.format(130));\n        Number resultScientific = df.parse(expectedScientific);\n        assertEquals(\"Should parse scientific to 130 in ccp\",\n                130, resultScientific.longValue());\n    }\n\n    @Test\n    public void Test13453_AffixContent() {\n        DecimalFormat df = (DecimalFormat) DecimalFormat.getScientificInstance();\n        assertEquals(\"Scientific should NOT be included\", \"\", df.getPositiveSuffix());\n\n        df = CompactDecimalFormat.getInstance(ULocale.ENGLISH, CompactDecimalFormat.CompactStyle.SHORT);\n        assertEquals(\"Compact should NOT be included\", \"\", df.getPositiveSuffix());\n\n        df = (DecimalFormat) DecimalFormat.getInstance(NumberFormat.ISOCURRENCYSTYLE);\n        df.setCurrency(Currency.getInstance(\"GBP\"));\n        assertEquals(\"ISO currency SHOULD be included\", \"GBP\", df.getPositivePrefix());\n\n        df = (DecimalFormat) DecimalFormat.getInstance(NumberFormat.PLURALCURRENCYSTYLE);\n        df.setCurrency(Currency.getInstance(\"GBP\"));\n        assertEquals(\"Plural name SHOULD be included\", \" British pounds\", df.getPositiveSuffix());\n    }\n\n    @Test\n    public void Test11035_FormatCurrencyAmount() {\n        double amount = 12345.67;\n        String expected = \"12,345$67\u00a0\u200b\";\n        Currency cur = Currency.getInstance(\"PTE\");\n\n        // Test three ways to set currency via API\n\n        ULocale loc1 = new ULocale(\"pt_PT\");\n        NumberFormat fmt1 = NumberFormat.getCurrencyInstance(loc1);\n        fmt1.setCurrency(cur);\n        String actualSetCurrency = fmt1.format(amount);\n\n        ULocale loc2 = new ULocale(\"pt_PT@currency=PTE\");\n        NumberFormat fmt2 = NumberFormat.getCurrencyInstance(loc2);\n        String actualLocaleString = fmt2.format(amount);\n\n        ULocale loc3 = new ULocale(\"pt_PT\");\n        NumberFormat fmt3 = NumberFormat.getCurrencyInstance(loc3);\n        CurrencyAmount curAmt = new CurrencyAmount(amount, cur);\n        String actualCurrencyAmount = fmt3.format(curAmt);\n\n        assertEquals(\"Custom Currency Pattern, Set Currency\", expected, actualSetCurrency);\n        assertEquals(\"Custom Currency Pattern, Locale String\", expected, actualCurrencyAmount);\n        assertEquals(\"Custom Currency Pattern, CurrencyAmount\", expected, actualLocaleString);\n    }\n\n    @Test\n    public void testPercentZero() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getPercentInstance();\n        String actual = df.format(0);\n        assertEquals(\"Should have one zero digit\", \"0%\", actual);\n    }\n\n    @Test\n    public void testCurrencyZeroRounding() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getCurrencyInstance();\n        df.setMaximumFractionDigits(0);\n        String actual = df.format(0);\n        assertEquals(\"Should have zero fraction digits\", \"$0\", actual);\n    }\n\n    @Test\n    public void testCustomCurrencySymbol() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getCurrencyInstance();\n        df.setCurrency(Currency.getInstance(\"USD\"));\n        DecimalFormatSymbols symbols = df.getDecimalFormatSymbols();\n        symbols.setCurrencySymbol(\"#\");\n        df.setDecimalFormatSymbols(symbols);\n        String actual = df.format(123);\n        assertEquals(\"Should use '#' instad of '$'\", \"#\u00a0123.00\", actual);\n    }\n\n    @Test\n    public void TestBasicSerializationRoundTrip() throws IOException, ClassNotFoundException {\n        DecimalFormat df0 = new DecimalFormat(\"A-**#####,#00.00b\u00a4\");\n\n        // Write to byte stream\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(baos);\n        oos.writeObject(df0);\n        oos.flush();\n        baos.close();\n        byte[] bytes = baos.toByteArray();\n\n        // Read from byte stream\n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Object obj = ois.readObject();\n        ois.close();\n        DecimalFormat df1 = (DecimalFormat) obj;\n\n        // Test equality\n        assertEquals(\"Did not round-trip through serialization\", df0, df1);\n\n        // Test basic functionality\n        String str0 = df0.format(12345.67);\n        String str1 = df1.format(12345.67);\n        assertEquals(\"Serialized formatter does not produce same output\", str0, str1);\n    }\n\n    @Test\n    public void testGetSetCurrency() {\n        DecimalFormat df = new DecimalFormat(\"\u00a4#\", DecimalFormatSymbols.getInstance(ULocale.US));\n        assertEquals(\"Currency should start out as the locale default\", Currency.getInstance(\"USD\"), df.getCurrency());\n        Currency curr = Currency.getInstance(\"EUR\");\n        df.setCurrency(curr);\n        assertEquals(\"Currency should equal EUR after set\", curr, df.getCurrency());\n        String result = df.format(123);\n        assertEquals(\"Currency should format as expected in EUR\", \"\u20ac123.00\", result);\n    }\n\n    @Test\n    public void testRoundingModeSetters() {\n        DecimalFormat df1 = new DecimalFormat();\n        DecimalFormat df2 = new DecimalFormat();\n\n        df1.setRoundingMode(java.math.BigDecimal.ROUND_CEILING);\n        assertNotEquals(\"Rounding mode was set to a non-default\", df1, df2);\n        df2.setRoundingMode(com.ibm.icu.math.BigDecimal.ROUND_CEILING);\n        assertEquals(\"Rounding mode from icu.math and java.math should be the same\", df1, df2);\n        df2.setRoundingMode(java.math.RoundingMode.CEILING.ordinal());\n        assertEquals(\"Rounding mode ordinal from java.math.RoundingMode should be the same\", df1, df2);\n    }\n\n    @Test\n    public void testCurrencySignificantDigits() {\n        ULocale locale = new ULocale(\"en-US\");\n        DecimalFormat df = (DecimalFormat) NumberFormat.getCurrencyInstance(locale);\n        df.setMaximumSignificantDigits(2);\n        String result = df.format(1234);\n        assertEquals(\"Currency rounding should obey significant digits\", \"$1,200\", result);\n    }\n\n    @Test\n    public void testParseStrictScientific() {\n        // See ticket #13057\n        DecimalFormat df = (DecimalFormat) NumberFormat.getScientificInstance();\n        df.setParseStrict(true);\n        ParsePosition ppos = new ParsePosition(0);\n        Number result0 = df.parse(\"123E4\", ppos);\n        assertEquals(\"Should accept number with exponent\", 1230000L, result0);\n        assertEquals(\"Should consume the whole number\", 5, ppos.getIndex());\n        ppos.setIndex(0);\n        result0 = df.parse(\"123\", ppos);\n        // #13737: For backwards compatibility, do NOT require the exponent.\n        assertEquals(\"Should NOT reject number without exponent\", 123L, result0);\n        ppos.setIndex(0);\n        CurrencyAmount result1 = df.parseCurrency(\"USD123\", ppos);\n        assertEquals(\"Should NOT reject currency without exponent\",\n                new CurrencyAmount(123L, Currency.getInstance(\"USD\")),\n                result1);\n    }\n\n    @Test\n    public void testParseLenientScientific() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getScientificInstance();\n        ParsePosition ppos = new ParsePosition(0);\n        Number result0 = df.parse(\"123E\", ppos);\n        assertEquals(\"Should parse the number in lenient mode\", 123L, result0);\n        assertEquals(\"Should stop before the E\", 3, ppos.getIndex());\n        DecimalFormatSymbols dfs = df.getDecimalFormatSymbols();\n        dfs.setExponentSeparator(\"EE\");\n        df.setDecimalFormatSymbols(dfs);\n        ppos.setIndex(0);\n        result0 = df.parse(\"123EE\", ppos);\n        assertEquals(\"Should parse the number in lenient mode\", 123L, result0);\n        assertEquals(\"Should stop before the EE\", 3, ppos.getIndex());\n    }\n\n    @Test\n    public void testParseAcceptAsciiPercentPermilleFallback() {\n        ULocale loc = new ULocale(\"ar\");\n        DecimalFormat df = (DecimalFormat) NumberFormat.getPercentInstance(loc);\n        ParsePosition ppos = new ParsePosition(0);\n        Number result = df.parse(\"42%\", ppos);\n        assertEquals(\"Should parse as 0.42 even in ar\", new BigDecimal(\"0.42\"), result);\n        assertEquals(\"Should consume the entire string even in ar\", 3, ppos.getIndex());\n        // TODO: Is there a better way to make a localized permille formatter?\n        df.applyPattern(df.toPattern().replace(\"%\", \"\u2030\"));\n        ppos.setIndex(0);\n        result = df.parse(\"42\u2030\", ppos);\n        assertEquals(\"Should parse as 0.042 even in ar\", new BigDecimal(\"0.042\"), result);\n        assertEquals(\"Should consume the entire string even in ar\", 3, ppos.getIndex());\n    }\n\n    @Test\n    public void testParseSubtraction() {\n        // TODO: Is this a case we need to support? It prevents us from automatically parsing\n        // minus signs that appear after the number, like  in \"12-\" vs \"-12\".\n        DecimalFormat df = new DecimalFormat();\n        String str = \"12 - 5\";\n        ParsePosition ppos = new ParsePosition(0);\n        Number n1 = df.parse(str, ppos);\n        Number n2 = df.parse(str, ppos);\n        assertEquals(\"Should parse 12 and -5\", 12, n1.intValue());\n        assertEquals(\"Should parse 12 and -5\", -5, n2.intValue());\n    }\n\n    @Test\n    public void testSetPrefixDefaultSuffix() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getPercentInstance();\n        df.setPositivePrefix(\"+\");\n        assertEquals(\"Should have manual plus sign and auto percent sign\", \"+100%\", df.format(1));\n    }\n\n    @Test\n    public void testMultiCodePointPaddingInPattern() {\n        DecimalFormat df = new DecimalFormat(\"a*'\u0ba8\u0bbf'###0b\");\n        String result = df.format(12);\n        assertEquals(\"Multi-codepoint padding should not be split\", \"a\u0ba8\u0bbf\u0ba8\u0bbf12b\", result);\n        df = new DecimalFormat(\"a*\ud83d\ude01###0b\");\n        result = df.format(12);\n        assertEquals(\"Single-codepoint padding should not be split\", \"a\ud83d\ude01\ud83d\ude0112b\", result);\n        df = new DecimalFormat(\"a*''###0b\");\n        result = df.format(12);\n        assertEquals(\"Quote should be escapable in padding syntax\", \"a''12b\", result);\n    }\n\n    @Test\n    public void Test13737_ParseScientificStrict() {\n        NumberFormat df = NumberFormat.getScientificInstance(ULocale.ENGLISH);\n        df.setParseStrict(true);\n        // Parse Test: exponent is not required, even in strict mode\n        expect(df, \"1.2\", 1.2);\n    }\n\n    // TODO: Investigate this test and re-enable if appropriate.\n    @Test\n    @Ignore\n    public void testParseAmbiguousAffixes() {\n        BigDecimal positive = new BigDecimal(\"0.0567\");\n        BigDecimal negative = new BigDecimal(\"-0.0567\");\n        DecimalFormat df = new DecimalFormat();\n        df.setParseBigDecimal(true);\n\n        String[] patterns = { \"+0.00%;-0.00%\", \"+0.00%;0.00%\", \"0.00%;-0.00%\" };\n        String[] inputs = { \"+5.67%\", \"-5.67%\", \"5.67%\" };\n        boolean[][] expectedPositive = {\n                { true, false, true },\n                { true, false, false },\n                { true, false, true }\n        };\n\n        for (int i=0; i<patterns.length; i++) {\n            String pattern = patterns[i];\n            df.applyPattern(pattern);\n            for (int j=0; j<inputs.length; j++) {\n                String input = inputs[j];\n                ParsePosition ppos = new ParsePosition(0);\n                Number actual = df.parse(input, ppos);\n                BigDecimal expected = expectedPositive[i][j] ? positive : negative;\n                String message = \"Pattern \" + pattern + \" with input \" + input;\n                assertEquals(message, expected, actual);\n                assertEquals(message, input.length(), ppos.getIndex());\n            }\n        }\n    }\n\n    @Test\n    public void testParseIgnorables() {\n        // Also see the test case \"test parse ignorables\" in numberformattestspecification.txt\n        DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance();\n        dfs.setPercentString(\"\\u200E%\\u200E\");\n        DecimalFormat df = new DecimalFormat(\"0 %;-0a\", dfs);\n        ParsePosition ppos = new ParsePosition(0);\n        Number result = df.parse(\"42\\u200E%\\u200E \", ppos);\n        assertEquals(\"Should parse as percentage\", new BigDecimal(\"0.42\"), result);\n        assertEquals(\"Should consume the trailing bidi since it is in the symbol\", 5, ppos.getIndex());\n        ppos.setIndex(0);\n        result = df.parse(\"-42a\\u200E \", ppos);\n        assertEquals(\"Should parse as percent\", -0.42, result.doubleValue());\n        assertEquals(\"Should not consume the trailing bidi or whitespace\", 4, ppos.getIndex());\n\n        // A few more cases based on the docstring:\n        expect(df, \"42%\", 0.42);\n        expect(df, \"42 %\", 0.42);\n        expect(df, \"42   %\", 0.42);\n        expect(df, \"42\\u00A0%\", 0.42);\n    }\n\n    @Test\n    public void testCustomCurrencyUsageOverridesPattern() {\n        DecimalFormat df = new DecimalFormat(\"#,##0.###\");\n        expect2(df, 1234, \"1,234\");\n        df.setCurrencyUsage(CurrencyUsage.STANDARD);\n        expect2(df, 1234, \"1,234.00\");\n        df.setCurrencyUsage(null);\n        expect2(df, 1234, \"1,234\");\n    }\n\n    @Test\n    public void testCurrencyUsageFractionOverrides() {\n        NumberFormat df = DecimalFormat.getCurrencyInstance(ULocale.US);\n        expect2(df, 35.0, \"$35.00\");\n        df.setMinimumFractionDigits(3);\n        expect2(df, 35.0, \"$35.000\");\n        df.setMaximumFractionDigits(3);\n        expect2(df, 35.0, \"$35.000\");\n        df.setMinimumFractionDigits(-1);\n        expect2(df, 35.0, \"$35.00\");\n        df.setMaximumFractionDigits(-1);\n        expect2(df, 35.0, \"$35.00\");\n    }\n\n    @Test\n    public void testParseVeryVeryLargeExponent() {\n        DecimalFormat df = new DecimalFormat();\n        ParsePosition ppos = new ParsePosition(0);\n\n        Object[][] cases = {\n                {\"1.2E+1234567890\", Double.POSITIVE_INFINITY},\n                {\"1.2E+999999999\", new com.ibm.icu.math.BigDecimal(\"1.2E+999999999\")},\n                {\"1.2E+1000000000\", Double.POSITIVE_INFINITY},\n                {\"-1.2E+999999999\", new com.ibm.icu.math.BigDecimal(\"-1.2E+999999999\")},\n                {\"-1.2E+1000000000\", Double.NEGATIVE_INFINITY},\n                {\"1.2E-999999999\", new com.ibm.icu.math.BigDecimal(\"1.2E-999999999\")},\n                {\"1.2E-1000000000\", 0.0},\n                {\"-1.2E-999999999\", new com.ibm.icu.math.BigDecimal(\"-1.2E-999999999\")},\n                {\"-1.2E-1000000000\", -0.0},\n\n        };\n\n        for (Object[] cas : cases) {\n            ppos.setIndex(0);\n            String input = (String) cas[0];\n            Number expected = (Number) cas[1];\n            Number actual = df.parse(input, ppos);\n            assertEquals(input, expected, actual);\n        }\n    }\n\n    @Test\n    public void testStringMethodsNPE() {\n        String[] npeMethods = {\n                \"applyLocalizedPattern\",\n                \"applyPattern\",\n                \"setNegativePrefix\",\n                \"setNegativeSuffix\",\n                \"setPositivePrefix\",\n                \"setPositiveSuffix\"\n        };\n        for (String npeMethod : npeMethods) {\n            DecimalFormat df = new DecimalFormat();\n            try {\n                DecimalFormat.class.getDeclaredMethod(npeMethod, String.class).invoke(df, (String) null);\n                fail(\"NullPointerException not thrown in method \" + npeMethod);\n            } catch (InvocationTargetException e) {\n                assertTrue(\"Exception should be NullPointerException in method \" + npeMethod,\n                        e.getCause() instanceof NullPointerException);\n            } catch (Exception e) {\n                // Other reflection exceptions\n                throw new AssertionError(\"Reflection error in method \" + npeMethod + \": \" + e.getMessage());\n            }\n        }\n\n        // Also test the constructors\n        try {\n            new DecimalFormat(null);\n            fail(\"NullPointerException not thrown in 1-parameter constructor\");\n        } catch (NullPointerException e) {\n            // Expected\n        }\n        try {\n            new DecimalFormat(null, new DecimalFormatSymbols());\n            fail(\"NullPointerException not thrown in 2-parameter constructor\");\n        } catch (NullPointerException e) {\n            // Expected\n        }\n        try {\n            new DecimalFormat(null, new DecimalFormatSymbols(), CurrencyPluralInfo.getInstance(), 0);\n            fail(\"NullPointerException not thrown in 4-parameter constructor\");\n        } catch (NullPointerException e) {\n            // Expected\n        }\n    }\n\n    @Test\n    public void testParseNoExponent() throws ParseException {\n        DecimalFormat df = new DecimalFormat();\n        assertEquals(\"Parse no exponent has wrong default\", false, df.getParseNoExponent());\n        Number result1 = df.parse(\"123E4\");\n        df.setParseNoExponent(true);\n        assertEquals(\"Parse no exponent getter is broken\", true, df.getParseNoExponent());\n        Number result2 = df.parse(\"123E4\");\n        assertEquals(\"Exponent did not parse before setParseNoExponent\", result1, new Long(1230000));\n        assertEquals(\"Exponent parsed after setParseNoExponent\", result2, new Long(123));\n    }\n\n    @Test\n    public void testMinimumGroupingDigits() {\n        String[][] allExpected = {\n                {\"123\", \"123\"},\n                {\"1,230\", \"1230\"},\n                {\"12,300\", \"12,300\"},\n                {\"1,23,000\", \"1,23,000\"}\n        };\n\n        DecimalFormat df = new DecimalFormat(\"#,##,##0\");\n        assertEquals(\"Minimum grouping digits has wrong default\", 1, df.getMinimumGroupingDigits());\n\n        for (int l = 123, i=0; l <= 123000; l *= 10, i++) {\n            df.setMinimumGroupingDigits(1);\n            assertEquals(\"Minimum grouping digits getter is broken\", 1, df.getMinimumGroupingDigits());\n            String actual = df.format(l);\n            assertEquals(\"Output is wrong for 1, \"+i, allExpected[i][0], actual);\n            df.setMinimumGroupingDigits(2);\n            assertEquals(\"Minimum grouping digits getter is broken\", 2, df.getMinimumGroupingDigits());\n            actual = df.format(l);\n            assertEquals(\"Output is wrong for 2, \"+i, allExpected[i][1], actual);\n        }\n    }\n\n    @Test\n    public void testParseCaseSensitive() {\n        String[] patterns = {\"a#b\", \"A#B\"};\n        String[] inputs = {\"a500b\", \"A500b\", \"a500B\", \"a500e10b\", \"a500E10b\"};\n        int[][] expectedParsePositions = {\n                {5, 5, 5, 8, 8}, // case insensitive, pattern 0\n                {5, 0, 4, 4, 8}, // case sensitive, pattern 0\n                {5, 5, 5, 8, 8}, // case insensitive, pattern 1\n                {0, 4, 0, 0, 0}, // case sensitive, pattern 1\n        };\n\n        for (int p = 0; p < patterns.length; p++) {\n            String pat = patterns[p];\n            DecimalFormat df = new DecimalFormat(pat);\n            assertEquals(\"parseCaseSensitive default is wrong\", false, df.getParseCaseSensitive());\n            for (int i = 0; i < inputs.length; i++) {\n                String inp = inputs[i];\n                df.setParseCaseSensitive(false);\n                assertEquals(\"parseCaseSensitive getter is broken\", false, df.getParseCaseSensitive());\n                ParsePosition actualInsensitive = new ParsePosition(0);\n                df.parse(inp, actualInsensitive);\n                assertEquals(\"Insensitive, pattern \"+p+\", input \"+i,\n                        expectedParsePositions[p*2][i], actualInsensitive.getIndex());\n                df.setParseCaseSensitive(true);\n                assertEquals(\"parseCaseSensitive getter is broken\", true, df.getParseCaseSensitive());\n                ParsePosition actualSensitive = new ParsePosition(0);\n                df.parse(inp, actualSensitive);\n                assertEquals(\"Sensitive, pattern \"+p+\", input \"+i,\n                        expectedParsePositions[p*2+1][i], actualSensitive.getIndex());\n            }\n        }\n    }\n\n    @Test\n    public void testPlusSignAlwaysShown() throws ParseException {\n        double[] numbers = {0.012, 5.78, 0, -0.012, -5.78};\n        ULocale[] locs = {new ULocale(\"en-US\"), new ULocale(\"ar-EG\"), new ULocale(\"es-CL\")};\n        String[][][] expecteds = {\n                // en-US\n                {\n                    // decimal\n                    { \"+0.012\", \"+5.78\", \"+0\", \"-0.012\", \"-5.78\" },\n                    // currency\n                    { \"+$0.01\", \"+$5.78\", \"+$0.00\", \"-$0.01\", \"-$5.78\" }\n                },\n                // ar-EG (interesting because the plus sign string starts with \\u061C)\n                {\n                    // decimal\n                    {\n                        \"\\u061C+\\u0660\\u066B\\u0660\\u0661\\u0662\", // \"\u061c+\u0660\u066b\u0660\u0661\u0662\"\n                        \"\\u061C+\\u0665\\u066B\\u0667\\u0668\", // \"\u061c+\u0665\u066b\u0667\u0668\"\n                        \"\\u061C+\\u0660\", // \"\u061c+\u0660\"\n                        \"\\u061C-\\u0660\\u066B\\u0660\\u0661\\u0662\", // \"\u061c-\u0660\u066b\u0660\u0661\u0662\"\n                        \"\\u061C-\\u0665\\u066B\\u0667\\u0668\", // \"\u061c-\u0665\u066b\u0667\u0668\"\n                    },\n                    // currency (\\062C.\\0645.\\200F is the currency sign in ar for EGP)\n                    {\n                        \"\\u061C+\\u0660\\u066B\\u0660\\u0661\\u00A0\\u062C.\\u0645.\\u200F\",\n                        \"\\u061C+\\u0665\\u066B\\u0667\\u0668\\u00A0\\u062C.\\u0645.\\u200F\",\n                        \"\\u061C+\\u0660\\u066B\\u0660\\u0660\\u00A0\\u062C.\\u0645.\\u200F\",\n                        \"\\u061C-\\u0660\\u066B\\u0660\\u0661\\u00A0\\u062C.\\u0645.\\u200F\",\n                        \"\\u061C-\\u0665\\u066B\\u0667\\u0668\\u00A0\\u062C.\\u0645.\\u200F\"\n                    }\n                },\n                // es-CL (interesting because of position of sign in currency)\n                {\n                    // decimal\n                    { \"+0,012\", \"+5,78\", \"+0\", \"-0,012\", \"-5,78\" },\n                    // currency (note: rounding for es-CL's currency, CLP, is 0 fraction digits)\n                    { \"$+0\", \"$+6\", \"$+0\", \"$-0\", \"$-6\" }\n                }\n        };\n\n        for (int i=0; i<locs.length; i++) {\n            ULocale loc = locs[i];\n            DecimalFormat df1 = (DecimalFormat) NumberFormat.getNumberInstance(loc);\n            assertFalse(\"Default should be false\", df1.getSignAlwaysShown());\n            df1.setSignAlwaysShown(true);\n            assertTrue(\"Getter should now return true\", df1.getSignAlwaysShown());\n            DecimalFormat df2 = (DecimalFormat) NumberFormat.getCurrencyInstance(loc);\n            assertFalse(\"Default should be false\", df2.getSignAlwaysShown());\n            df2.setSignAlwaysShown(true);\n            assertTrue(\"Getter should now return true\", df2.getSignAlwaysShown());\n            for (int j=0; j<2; j++) {\n                DecimalFormat df = (j == 0) ? df1 : df2;\n                for (int k=0; k<numbers.length; k++) {\n                    double d = numbers[k];\n                    String exp = expecteds[i][j][k];\n                    String act = df.format(d);\n                    assertEquals(\"Locale \" + loc + \", type \" + j + \", \" + d, exp, act);\n                    BigDecimal parsedExp = BigDecimal.valueOf(d);\n                    if (j == 1) {\n                        // Currency-round expected parse output\n                        int scale = (i == 2) ? 0 : 2;\n                        parsedExp = parsedExp.setScale(scale, BigDecimal.ROUND_HALF_EVEN);\n                    }\n                    Number parsedNum = df.parse(exp);\n                    BigDecimal parsedAct = (parsedNum.getClass() == BigDecimal.class)\n                            ? (BigDecimal) parsedNum\n                            : BigDecimal.valueOf(parsedNum.doubleValue());\n                    assertEquals(\n                            \"Locale \" + loc + \", type \" + j + \", \" + d + \", \" + parsedExp + \" => \" + parsedAct,\n                            0, parsedExp.compareTo(parsedAct));\n                }\n            }\n        }\n    }\n\n    @Test\n    public void Test20073_StrictPercentParseErrorIndex() {\n        ParsePosition parsePosition = new ParsePosition(0);\n        DecimalFormat df = new DecimalFormat(\"0%\", DecimalFormatSymbols.getInstance(Locale.US));\n        df.setParseStrict(true);\n        Number number = df.parse(\"%2%\", parsePosition);\n        assertNull(\"\", number);\n        assertEquals(\"\", 0, parsePosition.getIndex());\n        assertEquals(\"\", 0, parsePosition.getErrorIndex());\n    }\n\n    @Test\n    public void Test11626_CustomizeCurrencyPluralInfo() throws ParseException {\n        // Use locale sr because it has interesting plural rules.\n        ULocale locale = ULocale.forLanguageTag(\"sr\");\n        DecimalFormatSymbols symbols = DecimalFormatSymbols.getInstance(locale);\n        CurrencyPluralInfo info = CurrencyPluralInfo.getInstance(locale);\n        info.setCurrencyPluralPattern(\"one\", \"0 qwerty\");\n        info.setCurrencyPluralPattern(\"few\", \"0 dvorak\");\n        DecimalFormat df = new DecimalFormat(\"#\", symbols, info, NumberFormat.CURRENCYSTYLE);\n        df.setCurrency(Currency.getInstance(\"USD\"));\n        df.setMaximumFractionDigits(0);\n\n        assertEquals(\"Plural one\", \"1 qwerty\", df.format(1));\n        assertEquals(\"Plural few\", \"3 dvorak\", df.format(3));\n        assertEquals(\"Plural other\", \"99 \u0430\u043c\u0435\u0440\u0438\u0447\u043a\u0438\u0445 \u0434\u043e\u043b\u0430\u0440\u0430\", df.format(99));\n\n        info.setPluralRules(\"few: n is 1; one: n in 2..4\");\n        df.setCurrencyPluralInfo(info);\n        assertEquals(\"Plural one\", \"1 dvorak\", df.format(1));\n        assertEquals(\"Plural few\", \"3 qwerty\", df.format(3));\n        assertEquals(\"Plural other\", \"99 \u0430\u043c\u0435\u0440\u0438\u0447\u043a\u0438\u0445 \u0434\u043e\u043b\u0430\u0440\u0430\", df.format(99));\n    }\n\n    @Test\n    public void TestNarrowCurrencySymbols() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getCurrencyInstance(ULocale.CANADA);\n        df.setCurrency(Currency.getInstance(\"USD\"));\n        expect2(df, 123.45, \"US$123.45\");\n        String pattern = df.toPattern();\n        pattern = pattern.replace(\"\u00a4\", \"\u00a4\u00a4\u00a4\u00a4\u00a4\");\n        df.applyPattern(pattern);\n        // Note: Narrow currency is not parseable because of ambiguity.\n        assertEquals(\"Narrow currency symbol for USD in en_CA is $\",\n                \"$123.45\", df.format(123.45));\n    }\n\n    @Test\n    public void TestAffixOverrideBehavior() {\n        DecimalFormat df = (DecimalFormat) NumberFormat.getInstance(ULocale.ENGLISH);\n        expect2(df, 100, \"100\");\n        expect2(df, -100, \"-100\");\n        // This is not the right way to set an override plus sign, but we need to support it for compatibility.\n        df.setPositivePrefix(\"+\");\n        expect2(df, 100, \"+100\");\n        expect2(df, -100, \"-100\"); // note: the positive prefix does not affect the negative prefix\n        df.applyPattern(\"a0\");\n        expect2(df, 100, \"a100\");\n        expect2(df, -100, \"-a100\");\n    }\n\n    @Test\n    public void TestCurrencyRoundingMinWithoutMax() {\n        NumberFormat currencyFormat = DecimalFormat.getCurrencyInstance(Locale.US);\n        currencyFormat.setCurrency(Currency.getInstance(\"AUD\"));\n        currencyFormat.setMinimumFractionDigits(0);\n        expect(currencyFormat, 0.001, \"A$0\");\n\n        // NOTE: The size of the increment takes precedent over minFrac since ICU 59.\n        // CAD-Cash uses nickel rounding.\n        currencyFormat = DecimalFormat.getCurrencyInstance(Locale.US);\n        currencyFormat.setCurrency(Currency.getInstance(\"CAD\"));\n        ((DecimalFormat)currencyFormat).setCurrencyUsage(CurrencyUsage.CASH);\n        currencyFormat.setMinimumFractionDigits(0);\n        // expect(currencyFormat, 0.08, \"CA$0.1\");  // ICU 58 and down\n        expect(currencyFormat, 0.08, \"CA$0.10\");  // ICU 59 and up\n    }\n\n    @Test\n    public void testParsePositionIncrease() {\n        String input = \"123\\n456\\n$789\";\n        ParsePosition ppos = new ParsePosition(0);\n        DecimalFormat df = new DecimalFormat();\n        df.parse(input, ppos);\n        assertEquals(\"Should stop after first entry\", 3, ppos.getIndex());\n        ppos.setIndex(ppos.getIndex() + 1);\n        df.parse(input, ppos);\n        assertEquals(\"Should stop after second entry\", 7, ppos.getIndex());\n        ppos.setIndex(ppos.getIndex() + 1);\n        df.parseCurrency(input, ppos); // test parseCurrency API as well\n        assertEquals(\"Should stop after third entry\", 12, ppos.getIndex());\n    }\n\n    @Test\n    public void testTrailingMinusSign() {\n        String input = \"52-\";\n        DecimalFormat df = (DecimalFormat) DecimalFormat.getInstance(ULocale.ENGLISH);\n        ParsePosition ppos = new ParsePosition(0);\n        Number result = df.parse(input, ppos);\n        assertEquals(\"Trailing sign should NOT be accepted after the number in English by default\",\n                52.0,\n                result.doubleValue(),\n                0.0);\n        df.applyPattern(\"#;#-\");\n        ppos.setIndex(0);\n        result = df.parse(input, ppos);\n        assertEquals(\"Trailing sign SHOULD be accepted if there is one in the pattern\",\n                -52.0,\n                result.doubleValue(),\n                0.0);\n    }\n\n    @Test\n    public void testScientificCustomSign() {\n        DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(ULocale.ENGLISH);\n        dfs.setMinusSignString(\"nnn\");\n        dfs.setPlusSignString(\"ppp\");\n        DecimalFormat df = new DecimalFormat(\"0E0\", dfs);\n        df.setExponentSignAlwaysShown(true);\n        expect2(df, 0.5, \"5Ennn1\");\n        expect2(df, 50, \"5Eppp1\");\n    }\n\n    @Test\n    public void testParsePercentInPattern() {\n        DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(ULocale.ENGLISH);\n        DecimalFormat df = new DecimalFormat(\"0x%\", dfs);\n        df.setParseStrict(true);\n        expect2(df, 0.5, \"50x%\");\n    }\n\n    @Test\n    public void testParseIsoStrict() {\n        DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(ULocale.ENGLISH);\n        DecimalFormat df = new DecimalFormat(\"\u00a4\u00a40;-0\u00a4\u00a4\", dfs);\n        df.setCurrency(Currency.getInstance(\"USD\"));\n        df.setParseStrict(true);\n        expect2(df, 45, \"USD\u00a045.00\");\n        expect2(df, -45, \"-45.00\u00a0USD\");\n    }\n\n    @Test\n    public void test13684_FrenchPercentParsing() {\n        NumberFormat numberFormat = NumberFormat.getPercentInstance(ULocale.FRENCH);\n        numberFormat.setParseStrict(true);\n        ParsePosition ppos = new ParsePosition(0);\n        Number percentage = numberFormat.parse(\"8\\u00A0%\", ppos);\n        assertEquals(\"Should parse successfully\", 0.08, percentage.doubleValue());\n        assertEquals(\"Should consume whole string\", 3, ppos.getIndex());\n    }\n\n    @Test\n    public void testStrictParseCurrencyLongNames() {\n        DecimalFormat df = (DecimalFormat) DecimalFormat.getInstance(ULocale.ENGLISH, DecimalFormat.PLURALCURRENCYSTYLE);\n        df.setParseStrict(true);\n        df.setCurrency(Currency.getInstance(\"USD\"));\n        double input = 514.23;\n        String formatted = df.format(input);\n        String expected = \"514.23 US dollars\";\n        assertEquals(\"Should format as expected\", expected, formatted);\n        ParsePosition ppos = new ParsePosition(0);\n        CurrencyAmount ca = df.parseCurrency(formatted, ppos);\n        assertEquals(\"Should consume whole number\", ppos.getIndex(), 17);\n        assertEquals(\"Number should round-trip\", ca.getNumber().doubleValue(), input);\n        assertEquals(\"Should get correct currency\", ca.getCurrency().getCurrencyCode(), \"USD\");\n        // Should also round-trip in non-currency parsing\n        expect2(df, input, expected);\n    }\n\n    @Test\n    public void testStrictParseCurrencySpacing() {\n        DecimalFormat df = new DecimalFormat(\"\u00a4\u00a00\", DecimalFormatSymbols.getInstance(ULocale.ROOT));\n        df.setCurrency(Currency.getInstance(\"USD\"));\n        df.setParseStrict(true);\n        expect2(df, -51.42, \"-US$\u00a051.42\");\n    }\n\n    @Test\n    public void testCaseSensitiveCustomIsoCurrency() {\n        DecimalFormat df = new DecimalFormat(\"\u00a4\u00a40\", DecimalFormatSymbols.getInstance(ULocale.ENGLISH));\n        df.setCurrency(Currency.getInstance(\"ICU\"));\n        ParsePosition ppos = new ParsePosition(0);\n        df.parseCurrency(\"icu123\", ppos);\n        assertEquals(\"Should succeed\", 6, ppos.getIndex());\n        assertEquals(\"Should succeed\", -1, ppos.getErrorIndex());\n    }\n\n    @Test\n    public void testCurrencyPluralAffixOverrides() {\n        // The affix setters should override CurrencyPluralInfo, used in the plural currency constructor.\n        DecimalFormat df = (DecimalFormat) NumberFormat.getInstance(ULocale.ENGLISH, NumberFormat.PLURALCURRENCYSTYLE);\n        assertEquals(\"Defaults to unknown currency\", \" (unknown currency)\", df.getPositiveSuffix());\n        df.setCurrency(Currency.getInstance(\"USD\"));\n        assertEquals(\"Should resolve to CurrencyPluralInfo\", \" US dollars\", df.getPositiveSuffix());\n        df.setPositiveSuffix(\"lala\");\n        assertEquals(\"Custom suffix should round-trip\", \"lala\", df.getPositiveSuffix());\n        assertEquals(\"Custom suffix should be used in formatting\", \"123.00lala\", df.format(123));\n    }\n\n    @Test\n    public void testParseDoubleMinus() {\n        DecimalFormat df = new DecimalFormat(\"-0\", DecimalFormatSymbols.getInstance(ULocale.ENGLISH));\n        expect2(df, -5, \"--5\");\n    }\n\n    @Test\n    public void testParsePercentRegression() {\n        DecimalFormat df1 = (DecimalFormat) NumberFormat.getInstance(ULocale.ENGLISH);\n        DecimalFormat df2 = (DecimalFormat) NumberFormat.getPercentInstance(ULocale.ENGLISH);\n        df1.setParseStrict(false);\n        df2.setParseStrict(false);\n\n        {\n            ParsePosition ppos = new ParsePosition(0);\n            Number result = df1.parse(\"50%\", ppos);\n            assertEquals(\"df1 should accept a number but not the percent sign\", 2, ppos.getIndex());\n            assertEquals(\"df1 should return the number as 50\", 50.0, result.doubleValue());\n        }\n        {\n            ParsePosition ppos = new ParsePosition(0);\n            Number result = df2.parse(\"50%\", ppos);\n            assertEquals(\"df2 should accept the percent sign\", 3, ppos.getIndex());\n            assertEquals(\"df2 should return the number as 0.5\", 0.5, result.doubleValue());\n        }\n        {\n            ParsePosition ppos = new ParsePosition(0);\n            Number result = df2.parse(\"50\", ppos);\n            assertEquals(\"df2 should return the number as 0.5 even though the percent sign is missing\",\n                    0.5,\n                    result.doubleValue());\n        }\n    }\n\n    @Test\n    public void test13148_GroupingSeparatorOverride() throws Exception {\n        DecimalFormat fmt = (DecimalFormat)NumberFormat.getInstance(new ULocale(\"en\", \"ZA\"));\n        DecimalFormatSymbols symbols = fmt.getDecimalFormatSymbols();\n        symbols.setDecimalSeparator('.');\n        symbols.setGroupingSeparator(',');\n        fmt.setDecimalFormatSymbols(symbols);\n        Number number = fmt.parse(\"300,000\");\n        assertEquals(\"Should use custom symbols and not monetary symbols\", 300000L, number);\n    }\n\n    @Test\n    public void test11897_LocalizedPatternSeparator() {\n        DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(ULocale.ENGLISH);\n        dfs.setPatternSeparator('!');\n        DecimalFormat df = new DecimalFormat(\"0\", dfs);\n        df.applyPattern(\"a0;b0\"); // should not throw\n        assertEquals(\"should apply the normal pattern\", df.getNegativePrefix(), \"b\");\n        df.applyLocalizedPattern(\"c0!d0\"); // should not throw\n        assertEquals(\"should apply the localized pattern\", df.getNegativePrefix(), \"d\");\n    }\n\n    @Test\n    public void test13777_ParseLongNameNonCurrencyMode() {\n        // Currency long name should round-trip even when non-currency parsing is used.\n        NumberFormat df = NumberFormat.getInstance(ULocale.US, NumberFormat.PLURALCURRENCYSTYLE);\n        expect2(df, 1.5, \"1.50 US dollars\");\n    }\n\n    @Test\n    public void test13804_EmptyStringsWhenParsing() {\n        DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(ULocale.ENGLISH);\n        dfs.setCurrencySymbol(\"\");\n        dfs.setDecimalSeparatorString(\"\");\n        dfs.setDigitStrings(new String[] { \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\" });\n        dfs.setExponentMultiplicationSign(\"\");\n        dfs.setExponentSeparator(\"\");\n        dfs.setGroupingSeparatorString(\"\");\n        dfs.setInfinity(\"\");\n        dfs.setInternationalCurrencySymbol(\"\");\n        dfs.setMinusSignString(\"\");\n        dfs.setMonetaryDecimalSeparatorString(\"\");\n        dfs.setMonetaryGroupingSeparatorString(\"\");\n        dfs.setNaN(\"\");\n        dfs.setPatternForCurrencySpacing(DecimalFormatSymbols.CURRENCY_SPC_INSERT, false, \"\");\n        dfs.setPatternForCurrencySpacing(DecimalFormatSymbols.CURRENCY_SPC_INSERT, true, \"\");\n        dfs.setPercentString(\"\");\n        dfs.setPerMillString(\"\");\n        dfs.setPlusSignString(\"\");\n\n        DecimalFormat df = new DecimalFormat(\"0\", dfs);\n        df.setGroupingUsed(true);\n        df.setScientificNotation(true);\n        df.setParseStrict(false); // enable all matchers\n        df.format(0); // should not throw or hit infinite loop\n        String[] samples = new String[] {\n                \"\",\n                \"123\",\n                \"$123\",\n                \"-\",\n                \"+\",\n                \"44%\",\n                \"1E+2.3\"\n        };\n        for (String sample : samples) {\n            logln(\"Attempting parse on: \" + sample);\n            // We don't care about the results, only that we don't throw and don't loop.\n            ParsePosition ppos = new ParsePosition(0);\n            df.parse(sample, ppos);\n            ppos = new ParsePosition(0);\n            df.parseCurrency(sample, ppos);\n        }\n\n        // Test with a nonempty exponent separator symbol to cover more code\n        dfs.setExponentSeparator(\"E\");\n        df.setDecimalFormatSymbols(dfs);\n        {\n            ParsePosition ppos = new ParsePosition(0);\n            df.parse(\"1E+2.3\", ppos);\n        }\n    }\n\n    @Test\n    public void Test20037_ScientificIntegerOverflow() throws ParseException {\n        NumberFormat nf = NumberFormat.getInstance(ULocale.US);\n\n        // Test overflow of exponent\n        Number result = nf.parse(\"1E-2147483648\");\n        assertEquals(\"Should snap to zero\",\n                \"0\", result.toString());\n\n        // Test edge case overflow of exponent\n        // Note: the behavior is different from C++; this is probably due to the\n        // intermediate BigDecimal form, which has its own restrictions\n        result = nf.parse(\"1E-2147483647E-1\");\n        assertEquals(\"Should not overflow and should parse only the first exponent\",\n                \"0.0\", result.toString());\n\n        // For Java, we should get *pretty close* to 2^31.\n        result = nf.parse(\"1E-547483647\");\n        assertEquals(\"Should *not* snap to zero\",\n                \"1E-547483647\", result.toString());\n\n        // Test edge case overflow of exponent\n        result = nf.parse(\".0003e-2147483644\");\n        assertEquals(\"Should not overflow\",\n                \"0\", result.toString());\n    }\n\n    @Test\n    public void test13840_ParseLongStringCrash() throws ParseException {\n        NumberFormat nf = NumberFormat.getInstance(ULocale.ENGLISH);\n        String bigString =\n            \"111111111111111111111111111111111111111111111111111111111111111111111\" +\n            \"111111111111111111111111111111111111111111111111111111111111111111111\" +\n            \"111111111111111111111111111111111111111111111111111111111111111111111\" +\n            \"111111111111111111111111111111111111111111111111111111111111111111111\" +\n            \"111111111111111111111111111111111111111111111111111111111111111111111\" +\n            \"111111111111111111111111111111111111111111111111111111111111111111111\";\n        Number result = nf.parse(bigString);\n\n        // Normalize the input string:\n        BigDecimal expectedBigDecimal = new BigDecimal(bigString);\n        String expectedUString = expectedBigDecimal.toString();\n\n        // Get the output string:\n        BigDecimal actualBigDecimal = (BigDecimal) result;\n        String actualUString = actualBigDecimal.toString();\n\n        assertEquals(\"Should round-trip without crashing\", expectedUString, actualUString);\n    }\n}\n"], "filenames": ["icu4c/source/i18n/fmtable.cpp", "icu4c/source/i18n/number_decimalquantity.cpp", "icu4c/source/test/intltest/numfmtst.cpp", "icu4j/main/classes/core/src/com/ibm/icu/impl/number/DecimalQuantity_AbstractBCD.java", "icu4j/main/classes/core/src/com/ibm/icu/impl/number/DecimalQuantity_DualStorageBCD.java", "icu4j/main/tests/core/src/com/ibm/icu/dev/test/format/NumberFormatTest.java"], "buggy_code_start_loc": [737, 901, 9228, 1070, 242, 6327], "buggy_code_end_loc": [738, 902, 9228, 1071, 243, 6327], "fixing_code_start_loc": [737, 901, 9229, 1070, 242, 6328], "fixing_code_end_loc": [738, 905, 9237, 1074, 251, 6333], "type": "CWE-190", "message": "International Components for Unicode (ICU) for C/C++ 63.1 has an integer overflow in number::impl::DecimalQuantity::toScientificString() in i18n/number_decimalquantity.cpp.", "other": {"cve": {"id": "CVE-2018-18928", "sourceIdentifier": "cve@mitre.org", "published": "2018-11-04T20:29:00.247", "lastModified": "2019-01-16T19:30:09.907", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "International Components for Unicode (ICU) for C/C++ 63.1 has an integer overflow in number::impl::DecimalQuantity::toScientificString() in i18n/number_decimalquantity.cpp."}, {"lang": "es", "value": "International Components for Unicode (ICU) for C/C++ 63.1 tiene un desbordamiento de enteros en number::impl::DecimalQuantity::toScientificString() en i18n/number_decimalquantity.cpp."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:icu-project:international_components_for_unicode:63.1:*:*:*:*:c\\/c\\+\\+:*:*", "matchCriteriaId": "7741F50C-8503-4C32-B893-F7211D04E98A"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/chromium/issues/detail?id=900059", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/unicode-org/icu/commit/53d8c8f3d181d87a6aa925b449b51c4a2c922a51", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://unicode-org.atlassian.net/browse/ICU-20246", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/unicode-org/icu/commit/53d8c8f3d181d87a6aa925b449b51c4a2c922a51"}}