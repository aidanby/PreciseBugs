{"buggy_code": ["/* \n * Copyright 2002-2009 Andy Clark, Marc Guillemot\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.cyberneko.html;\n\nimport java.io.EOFException;\nimport java.io.FilterInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URL;\nimport java.util.BitSet;\nimport java.util.Locale;\nimport java.util.Stack;\n\nimport org.apache.xerces.util.EncodingMap;\nimport org.apache.xerces.util.NamespaceSupport;\nimport org.apache.xerces.util.URI;\nimport org.apache.xerces.util.XMLAttributesImpl;\nimport org.apache.xerces.util.XMLResourceIdentifierImpl;\nimport org.apache.xerces.util.XMLStringBuffer;\nimport org.apache.xerces.xni.Augmentations;\nimport org.apache.xerces.xni.NamespaceContext;\nimport org.apache.xerces.xni.QName;\nimport org.apache.xerces.xni.XMLAttributes;\nimport org.apache.xerces.xni.XMLDocumentHandler;\nimport org.apache.xerces.xni.XMLLocator;\nimport org.apache.xerces.xni.XMLResourceIdentifier;\nimport org.apache.xerces.xni.XMLString;\nimport org.apache.xerces.xni.XNIException;\nimport org.apache.xerces.xni.parser.XMLComponentManager;\nimport org.apache.xerces.xni.parser.XMLConfigurationException;\nimport org.apache.xerces.xni.parser.XMLDocumentScanner;\nimport org.apache.xerces.xni.parser.XMLInputSource;\nimport org.cyberneko.html.xercesbridge.XercesBridge;\n\n/**\n * A simple HTML scanner. This scanner makes no attempt to balance tags\n * or fix other problems in the source document &mdash; it just scans what \n * it can and generates XNI document \"events\", ignoring errors of all \n * kinds.\n * <p>\n * This component recognizes the following features:\n * <ul>\n * <li>http://cyberneko.org/html/features/augmentations\n * <li>http://cyberneko.org/html/features/report-errors\n * <li>http://apache.org/xml/features/scanner/notify-char-refs\n * <li>http://apache.org/xml/features/scanner/notify-builtin-refs\n * <li>http://cyberneko.org/html/features/scanner/notify-builtin-refs\n * <li>http://cyberneko.org/html/features/scanner/fix-mswindows-refs\n * <li>http://cyberneko.org/html/features/scanner/script/strip-cdata-delims\n * <li>http://cyberneko.org/html/features/scanner/script/strip-comment-delims\n * <li>http://cyberneko.org/html/features/scanner/style/strip-cdata-delims\n * <li>http://cyberneko.org/html/features/scanner/style/strip-comment-delims\n * <li>http://cyberneko.org/html/features/scanner/ignore-specified-charset\n * <li>http://cyberneko.org/html/features/scanner/cdata-sections\n * <li>http://cyberneko.org/html/features/override-doctype\n * <li>http://cyberneko.org/html/features/insert-doctype\n * <li>http://cyberneko.org/html/features/parse-noscript-content\n * <li>http://cyberneko.org/html/features/scanner/allow-selfclosing-iframe\n * <li>http://cyberneko.org/html/features/scanner/allow-selfclosing-tags\n * </ul>\n * <p>\n * This component recognizes the following properties:\n * <ul>\n * <li>http://cyberneko.org/html/properties/names/elems\n * <li>http://cyberneko.org/html/properties/names/attrs\n * <li>http://cyberneko.org/html/properties/default-encoding\n * <li>http://cyberneko.org/html/properties/error-reporter\n * <li>http://cyberneko.org/html/properties/doctype/pubid\n * <li>http://cyberneko.org/html/properties/doctype/sysid\n * </ul>\n *\n * @see HTMLElements\n * @see HTMLEntities\n *\n * @author Andy Clark\n * @author Marc Guillemot\n * @author Ahmed Ashour\n *\n * @version $Id: HTMLScanner.java,v 1.19 2005/06/14 05:52:37 andyc Exp $\n */\npublic class HTMLScanner \n    implements XMLDocumentScanner, XMLLocator, HTMLComponent {\n\n    //\n    // Constants\n    //\n\n    // doctype info: HTML 4.01 strict\n\n    /** HTML 4.01 strict public identifier (\"-//W3C//DTD HTML 4.01//EN\"). */\n    public static final String HTML_4_01_STRICT_PUBID = \"-//W3C//DTD HTML 4.01//EN\";\n\n    /** HTML 4.01 strict system identifier (\"http://www.w3.org/TR/html4/strict.dtd\"). */\n    public static final String HTML_4_01_STRICT_SYSID = \"http://www.w3.org/TR/html4/strict.dtd\";\n\n    // doctype info: HTML 4.01 loose\n\n    /** HTML 4.01 transitional public identifier (\"-//W3C//DTD HTML 4.01 Transitional//EN\"). */\n    public static final String HTML_4_01_TRANSITIONAL_PUBID = \"-//W3C//DTD HTML 4.01 Transitional//EN\";\n\n    /** HTML 4.01 transitional system identifier (\"http://www.w3.org/TR/html4/loose.dtd\"). */\n    public static final String HTML_4_01_TRANSITIONAL_SYSID = \"http://www.w3.org/TR/html4/loose.dtd\";\n\n    // doctype info: HTML 4.01 frameset\n\n    /** HTML 4.01 frameset public identifier (\"-//W3C//DTD HTML 4.01 Frameset//EN\"). */\n    public static final String HTML_4_01_FRAMESET_PUBID = \"-//W3C//DTD HTML 4.01 Frameset//EN\";\n\n    /** HTML 4.01 frameset system identifier (\"http://www.w3.org/TR/html4/frameset.dtd\"). */\n    public static final String HTML_4_01_FRAMESET_SYSID = \"http://www.w3.org/TR/html4/frameset.dtd\";\n\n    // features\n\n    /** Include infoset augmentations. */\n    protected static final String AUGMENTATIONS = \"http://cyberneko.org/html/features/augmentations\";\n\n    /** Report errors. */\n    protected static final String REPORT_ERRORS = \"http://cyberneko.org/html/features/report-errors\";\n\n    /** Notify character entity references (e.g. &amp;#32;, &amp;#x20;, etc). */\n    public static final String NOTIFY_CHAR_REFS = \"http://apache.org/xml/features/scanner/notify-char-refs\";\n\n    /** \n     * Notify handler of built-in entity references (e.g. &amp;amp;, \n     * &amp;lt;, etc).\n     * <p>\n     * <strong>Note:</strong>\n     * This only applies to the five pre-defined XML general entities.\n     * Specifically, \"amp\", \"lt\", \"gt\", \"quot\", and \"apos\". This is done \n     * for compatibility with the Xerces feature.\n     * <p>\n     * To be notified of the built-in entity references in HTML, set the \n     * <code>http://cyberneko.org/html/features/scanner/notify-builtin-refs</code> \n     * feature to <code>true</code>.\n     */\n    public static final String NOTIFY_XML_BUILTIN_REFS = \"http://apache.org/xml/features/scanner/notify-builtin-refs\";\n\n    /** \n     * Notify handler of built-in entity references (e.g. &amp;nobr;, \n     * &amp;copy;, etc).\n     * <p>\n     * <strong>Note:</strong>\n     * This <em>includes</em> the five pre-defined XML general entities.\n     */\n    public static final String NOTIFY_HTML_BUILTIN_REFS = \"http://cyberneko.org/html/features/scanner/notify-builtin-refs\";\n\n    /** Fix Microsoft Windows&reg; character entity references. */\n    public static final String FIX_MSWINDOWS_REFS = \"http://cyberneko.org/html/features/scanner/fix-mswindows-refs\";\n\n    /** \n     * Strip HTML comment delimiters (\"&lt;!&minus;&minus;\" and \n     * \"&minus;&minus;&gt;\") from SCRIPT tag contents.\n     */\n    public static final String SCRIPT_STRIP_COMMENT_DELIMS = \"http://cyberneko.org/html/features/scanner/script/strip-comment-delims\";\n\n    /** \n     * Strip XHTML CDATA delimiters (\"&lt;![CDATA[\" and \"]]&gt;\") from \n     * SCRIPT tag contents.\n     */\n    public static final String SCRIPT_STRIP_CDATA_DELIMS = \"http://cyberneko.org/html/features/scanner/script/strip-cdata-delims\";\n\n    /** \n     * Strip HTML comment delimiters (\"&lt;!&minus;&minus;\" and \n     * \"&minus;&minus;&gt;\") from STYLE tag contents.\n     */\n    public static final String STYLE_STRIP_COMMENT_DELIMS = \"http://cyberneko.org/html/features/scanner/style/strip-comment-delims\";\n\n    /** \n     * Strip XHTML CDATA delimiters (\"&lt;![CDATA[\" and \"]]&gt;\") from \n     * STYLE tag contents.\n     */\n    public static final String STYLE_STRIP_CDATA_DELIMS = \"http://cyberneko.org/html/features/scanner/style/strip-cdata-delims\";\n\n    /**\n     * Ignore specified charset found in the &lt;meta equiv='Content-Type'\n     * content='text/html;charset=&hellip;'&gt; tag or in the &lt;?xml &hellip; encoding='&hellip;'&gt; processing instruction\n     */\n    public static final String IGNORE_SPECIFIED_CHARSET = \"http://cyberneko.org/html/features/scanner/ignore-specified-charset\";\n\n    /** Scan CDATA sections. */\n    public static final String CDATA_SECTIONS = \"http://cyberneko.org/html/features/scanner/cdata-sections\";\n\n    /** Override doctype declaration public and system identifiers. */\n    public static final String OVERRIDE_DOCTYPE = \"http://cyberneko.org/html/features/override-doctype\";\n\n    /** Insert document type declaration. */\n    public static final String INSERT_DOCTYPE = \"http://cyberneko.org/html/features/insert-doctype\";\n    \n    /** Parse &lt;noscript&gt;...&lt;/noscript&gt; content */\n    public static final String PARSE_NOSCRIPT_CONTENT = \"http://cyberneko.org/html/features/parse-noscript-content\";\n\n    /** Allows self closing &lt;iframe/&gt; tag */\n    public static final String ALLOW_SELFCLOSING_IFRAME = \"http://cyberneko.org/html/features/scanner/allow-selfclosing-iframe\";\n    \n    /** Allows self closing tags e.g. &lt;div/&gt; (XHTML) */\n    public static final String ALLOW_SELFCLOSING_TAGS = \"http://cyberneko.org/html/features/scanner/allow-selfclosing-tags\";\n\n    /** Normalize attribute values. */\n    protected static final String NORMALIZE_ATTRIBUTES = \"http://cyberneko.org/html/features/scanner/normalize-attrs\";\n\n    /** Recognized features. */\n    private static final String[] RECOGNIZED_FEATURES = {\n        AUGMENTATIONS,\n        REPORT_ERRORS,\n        NOTIFY_CHAR_REFS,\n        NOTIFY_XML_BUILTIN_REFS,\n        NOTIFY_HTML_BUILTIN_REFS,\n        FIX_MSWINDOWS_REFS,\n        SCRIPT_STRIP_CDATA_DELIMS,\n        SCRIPT_STRIP_COMMENT_DELIMS,\n        STYLE_STRIP_CDATA_DELIMS,\n        STYLE_STRIP_COMMENT_DELIMS,\n        IGNORE_SPECIFIED_CHARSET,\n        CDATA_SECTIONS,\n        OVERRIDE_DOCTYPE,\n        INSERT_DOCTYPE,\n        NORMALIZE_ATTRIBUTES,\n        PARSE_NOSCRIPT_CONTENT,\n        ALLOW_SELFCLOSING_IFRAME,\n        ALLOW_SELFCLOSING_TAGS,\n    };\n\n    /** Recognized features defaults. */\n    private static final Boolean[] RECOGNIZED_FEATURES_DEFAULTS = {\n        null,\n        null,\n        Boolean.FALSE,\n        Boolean.FALSE,\n        Boolean.FALSE,\n        Boolean.FALSE,\n        Boolean.FALSE,\n        Boolean.FALSE,\n        Boolean.FALSE,\n        Boolean.FALSE,\n        Boolean.FALSE,\n        Boolean.FALSE,\n        Boolean.FALSE,\n        Boolean.FALSE,\n        Boolean.FALSE,\n        Boolean.TRUE,\n        Boolean.FALSE,\n        Boolean.FALSE,\n    };\n\n    // properties\n\n    /** Modify HTML element names: { \"upper\", \"lower\", \"default\" }. */\n    protected static final String NAMES_ELEMS = \"http://cyberneko.org/html/properties/names/elems\";\n\n    /** Modify HTML attribute names: { \"upper\", \"lower\", \"default\" }. */\n    protected static final String NAMES_ATTRS = \"http://cyberneko.org/html/properties/names/attrs\";\n    \n    /** Default encoding. */\n    protected static final String DEFAULT_ENCODING = \"http://cyberneko.org/html/properties/default-encoding\";\n    \n    /** Error reporter. */\n    protected static final String ERROR_REPORTER = \"http://cyberneko.org/html/properties/error-reporter\";\n\n    /** Doctype declaration public identifier. */\n    protected static final String DOCTYPE_PUBID = \"http://cyberneko.org/html/properties/doctype/pubid\";\n\n    /** Doctype declaration system identifier. */\n    protected static final String DOCTYPE_SYSID = \"http://cyberneko.org/html/properties/doctype/sysid\";\n\n    /** Recognized properties. */\n    private static final String[] RECOGNIZED_PROPERTIES = {\n        NAMES_ELEMS,\n        NAMES_ATTRS,\n        DEFAULT_ENCODING,\n        ERROR_REPORTER,\n        DOCTYPE_PUBID,\n        DOCTYPE_SYSID,\n    };\n\n    /** Recognized properties defaults. */\n    private static final Object[] RECOGNIZED_PROPERTIES_DEFAULTS = {\n        null,\n        null,\n        \"Windows-1252\",\n        null,\n        HTML_4_01_TRANSITIONAL_PUBID,\n        HTML_4_01_TRANSITIONAL_SYSID,\n    };\n\n    // states\n\n    /** State: content. */\n    protected static final short STATE_CONTENT = 0;\n\n    /** State: markup bracket. */\n    protected static final short STATE_MARKUP_BRACKET = 1;\n\n    /** State: start document. */\n    protected static final short STATE_START_DOCUMENT = 10;\n\n    /** State: end document. */\n    protected static final short STATE_END_DOCUMENT = 11;\n\n    // modify HTML names\n\n    /** Don't modify HTML names. */\n    protected static final short NAMES_NO_CHANGE = 0;\n\n    /** Uppercase HTML names. */\n    protected static final short NAMES_UPPERCASE = 1;\n\n    /** Lowercase HTML names. */\n    protected static final short NAMES_LOWERCASE = 2;\n\n    // defaults\n\n    /** Default buffer size. */\n    protected static final int DEFAULT_BUFFER_SIZE = 2048;\n\n    // debugging\n\n    /** Set to true to debug changes in the scanner. */\n    private static final boolean DEBUG_SCANNER = false;\n\n    /** Set to true to debug changes in the scanner state. */\n    private static final boolean DEBUG_SCANNER_STATE = false;\n\n    /** Set to true to debug the buffer. */\n    private static final boolean DEBUG_BUFFER = false;\n\n    /** Set to true to debug character encoding handling. */\n    private static final boolean DEBUG_CHARSET = false;\n\n    /** Set to true to debug callbacks. */\n    protected static final boolean DEBUG_CALLBACKS = false;\n    \n    // static vars\n\n    /** Synthesized event info item. */\n    protected static final HTMLEventInfo SYNTHESIZED_ITEM = \n        new HTMLEventInfo.SynthesizedItem();\n        \n    private final static BitSet ENTITY_CHARS = new BitSet();\n    static {\n    \tfinal String str = \"-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\";\n    \tfor (int i = 0; i < str.length(); ++i) {\n    \t\tchar c = str.charAt(i);\n    \t\tENTITY_CHARS.set(c);\n    \t}\n    }\n    //\n    // Data\n    //\n\n    // features\n\n    /** Augmentations. */\n    protected boolean fAugmentations;\n\n    /** Report errors. */\n    protected boolean fReportErrors;\n\n    /** Notify character entity references. */\n    protected boolean fNotifyCharRefs;\n\n    /** Notify XML built-in general entity references. */\n    protected boolean fNotifyXmlBuiltinRefs;\n\n    /** Notify HTML built-in general entity references. */\n    protected boolean fNotifyHtmlBuiltinRefs;\n\n    /** Fix Microsoft Windows&reg; character entity references. */\n    protected boolean fFixWindowsCharRefs;\n\n    /** Strip CDATA delimiters from SCRIPT tags. */\n    protected boolean fScriptStripCDATADelims;\n\n    /** Strip comment delimiters from SCRIPT tags. */\n    protected boolean fScriptStripCommentDelims;\n\n    /** Strip CDATA delimiters from STYLE tags. */\n    protected boolean fStyleStripCDATADelims;\n\n    /** Strip comment delimiters from STYLE tags. */\n    protected boolean fStyleStripCommentDelims;\n\n    /** Ignore specified character set. */\n    protected boolean fIgnoreSpecifiedCharset;\n\n    /** CDATA sections. */\n    protected boolean fCDATASections;\n\n    /** Override doctype declaration public and system identifiers. */\n    protected boolean fOverrideDoctype;\n\n    /** Insert document type declaration. */\n    protected boolean fInsertDoctype;\n\n    /** Normalize attribute values. */\n    protected boolean fNormalizeAttributes;\n    \n    /** Parse noscript content. */\n    protected boolean fParseNoScriptContent;\n\n    /** Parse noframes content. */\n    protected boolean fParseNoFramesContent;\n    \n    /** Allows self closing iframe tags. */\n    protected boolean fAllowSelfclosingIframe;\n\n    /** Allows self closing tags. */\n    protected boolean fAllowSelfclosingTags;\n\n    // properties\n\n    /** Modify HTML element names. */\n    protected short fNamesElems;\n\n    /** Modify HTML attribute names. */\n    protected short fNamesAttrs;\n\n    /** Default encoding. */\n    protected String fDefaultIANAEncoding;\n\n    /** Error reporter. */\n    protected HTMLErrorReporter fErrorReporter;\n\n    /** Doctype declaration public identifier. */\n    protected String fDoctypePubid;\n\n    /** Doctype declaration system identifier. */\n    protected String fDoctypeSysid;\n\n    // boundary locator information\n\n    /** Beginning line number. */\n    protected int fBeginLineNumber;\n\n    /** Beginning column number. */\n    protected int fBeginColumnNumber;\n\n    /** Beginning character offset in the file. */\n    protected int fBeginCharacterOffset;\n\n    /** Ending line number. */\n    protected int fEndLineNumber;\n\n    /** Ending column number. */\n    protected int fEndColumnNumber;\n\n    /** Ending character offset in the file. */\n    protected int fEndCharacterOffset;\n\n    // state\n\n    /** The playback byte stream. */\n    protected PlaybackInputStream fByteStream;\n\n    /** Current entity. */\n    protected CurrentEntity fCurrentEntity;\n    \n    /** The current entity stack. */\n    protected final Stack fCurrentEntityStack = new Stack();\n\n    /** The current scanner. */\n    protected Scanner fScanner;\n\n    /** The current scanner state. */\n    protected short fScannerState;\n\n    /** The document handler. */\n    protected XMLDocumentHandler fDocumentHandler;\n\n    /** Auto-detected IANA encoding. */\n    protected String fIANAEncoding;\n\n    /** Auto-detected Java encoding. */\n    protected String fJavaEncoding;\n\n    /** True if the encoding matches \"ISO-8859-*\". */\n    protected boolean fIso8859Encoding;\n\n    /** Element count. */\n    protected int fElementCount;\n\n    /** Element depth. */\n    protected int fElementDepth;\n\n    // scanners\n\n    /** Content scanner. */\n    protected Scanner fContentScanner = new ContentScanner();\n\n    /** \n     * Special scanner used for elements whose content needs to be scanned \n     * as plain text, ignoring markup such as elements and entity references.\n     * For example: &lt;SCRIPT&gt; and &lt;COMMENT&gt;.\n     */\n    protected SpecialScanner fSpecialScanner = new SpecialScanner();\n\n    // temp vars\n\n    /** String buffer. */\n    protected final XMLStringBuffer fStringBuffer = new XMLStringBuffer(1024);\n\n    /** String buffer. */\n    private final XMLStringBuffer fStringBuffer2 = new XMLStringBuffer(1024);\n\n    /** Non-normalized attribute string buffer. */\n    private final XMLStringBuffer fNonNormAttr = new XMLStringBuffer(128);\n\n    /** Augmentations. */\n    private final HTMLAugmentations fInfosetAugs = new HTMLAugmentations();\n\n    /** Location infoset item. */\n    private final LocationItem fLocationItem = new LocationItem();\n\n    /** Single boolean array. */\n    private final boolean[] fSingleBoolean = { false };\n\n    /** Resource identifier. */\n    private final XMLResourceIdentifierImpl fResourceId = new XMLResourceIdentifierImpl();\n\n\tprivate final char REPLACEMENT_CHARACTER = '\\uFFFD'; // the \ufffd character\n\n    //\n    // Public methods\n    //\n\n    /** \n     * Pushes an input source onto the current entity stack. This \n     * enables the scanner to transparently scan new content (e.g. \n     * the output written by an embedded script). At the end of the\n     * current entity, the scanner returns where it left off at the\n     * time this entity source was pushed.\n     * <p>\n     * <strong>Note:</strong>\n     * This functionality is experimental at this time and is\n     * subject to change in future releases of NekoHTML.\n     *\n     * @param inputSource The new input source to start scanning.\n     * @see #evaluateInputSource(XMLInputSource)\n     */\n    public void pushInputSource(XMLInputSource inputSource) {\n    \tfinal Reader reader = getReader(inputSource);\n\n    \tfCurrentEntityStack.push(fCurrentEntity);\n        String encoding = inputSource.getEncoding();\n        String publicId = inputSource.getPublicId();\n        String baseSystemId = inputSource.getBaseSystemId();\n        String literalSystemId = inputSource.getSystemId();\n        String expandedSystemId = expandSystemId(literalSystemId, baseSystemId);\n        fCurrentEntity = new CurrentEntity(reader, encoding, \n                                           publicId, baseSystemId,\n                                           literalSystemId, expandedSystemId);\n    } // pushInputSource(XMLInputSource)\n\n    private Reader getReader(final XMLInputSource inputSource) {\n        Reader reader = inputSource.getCharacterStream();\n        if (reader == null) {\n        \ttry {\n\t\t\t\treturn new InputStreamReader(inputSource.getByteStream(), fJavaEncoding);\n\t\t\t}\n        \tcatch (final UnsupportedEncodingException e) {\n\t\t\t\t// should not happen as this encoding is already used to parse the \"main\" source\n\t\t\t}\n        }\n        return reader;\n\t}\n\n\t/** \n     * Immediately evaluates an input source and add the new content (e.g. \n     * the output written by an embedded script).\n     *\n     * @param inputSource The new input source to start evaluating.\n     * @see #pushInputSource(XMLInputSource)\n     */\n    public void evaluateInputSource(XMLInputSource inputSource) {\n        final Scanner previousScanner = fScanner;\n        final short previousScannerState = fScannerState;\n        final CurrentEntity previousEntity = fCurrentEntity;\n        final Reader reader = getReader(inputSource);\n\n        String encoding = inputSource.getEncoding();\n        String publicId = inputSource.getPublicId();\n        String baseSystemId = inputSource.getBaseSystemId();\n        String literalSystemId = inputSource.getSystemId();\n        String expandedSystemId = expandSystemId(literalSystemId, baseSystemId);\n        fCurrentEntity = new CurrentEntity(reader, encoding, \n                                           publicId, baseSystemId,\n                                           literalSystemId, expandedSystemId);\n        setScanner(fContentScanner);\n        setScannerState(STATE_CONTENT);\n        try {\n            do {\n                fScanner.scan(false);\n            } while (fScannerState != STATE_END_DOCUMENT);\n        }\n        catch (final IOException e) {\n            // ignore\n        }\n        setScanner(previousScanner);\n        setScannerState(previousScannerState);\n        fCurrentEntity = previousEntity;\n    } // evaluateInputSource(XMLInputSource)\n\n    /**\n     * Cleans up used resources. For example, if scanning is terminated\n     * early, then this method ensures all remaining open streams are\n     * closed.\n     *\n     * @param closeall Close all streams, including the original.\n     *                 This is used in cases when the application has\n     *                 opened the original document stream and should\n     *                 be responsible for closing it.\n     */\n    public void cleanup(boolean closeall) {\n        int size = fCurrentEntityStack.size();\n        if (size > 0) {\n            // current entity is not the original, so close it\n            if (fCurrentEntity != null) {\n            \tfCurrentEntity.closeQuietly();\n            }\n            // close remaining streams\n            for (int i = closeall ? 0 : 1; i < size; i++) {\n                fCurrentEntity = (CurrentEntity) fCurrentEntityStack.pop();\n                fCurrentEntity.closeQuietly();\n            }\n        }\n        else if (closeall && fCurrentEntity != null) {\n        \tfCurrentEntity.closeQuietly();\n        }\n    } // cleanup(boolean)\n\n    //\n    // XMLLocator methods\n    //\n\n    /** Returns the encoding. */\n    public String getEncoding() {\n        return fCurrentEntity != null ? fCurrentEntity.encoding : null;\n    } // getEncoding():String\n\n    /** Returns the public identifier. */\n    public String getPublicId() { \n        return fCurrentEntity != null ? fCurrentEntity.publicId : null; \n    } // getPublicId():String\n\n    /** Returns the base system identifier. */\n    public String getBaseSystemId() { \n        return fCurrentEntity != null ? fCurrentEntity.baseSystemId : null; \n    } // getBaseSystemId():String\n\n    /** Returns the literal system identifier. */\n    public String getLiteralSystemId() { \n        return fCurrentEntity != null ? fCurrentEntity.literalSystemId : null; \n    } // getLiteralSystemId():String\n\n    /** Returns the expanded system identifier. */\n    public String getExpandedSystemId() { \n        return fCurrentEntity != null ? fCurrentEntity.expandedSystemId : null; \n    } // getExpandedSystemId():String\n\n    /** Returns the current line number. */\n    public int getLineNumber() { \n        return fCurrentEntity != null ? fCurrentEntity.getLineNumber() : -1; \n    } // getLineNumber():int\n\n    /** Returns the current column number. */\n    public int getColumnNumber() { \n        return fCurrentEntity != null ? fCurrentEntity.getColumnNumber() : -1; \n    } // getColumnNumber():int\n    \n    /** Returns the XML version. */\n    public String getXMLVersion() {\n\t\treturn fCurrentEntity != null ? fCurrentEntity.version : null; \n    } // getXMLVersion():String\n    \n    /** Returns the character offset. */\n    public int getCharacterOffset() {\n\t\treturn fCurrentEntity != null ? fCurrentEntity.getCharacterOffset() : -1; \n    } // getCharacterOffset():int\n\n    //\n    // HTMLComponent methods\n    //\n\n    /** Returns the default state for a feature. */\n    public Boolean getFeatureDefault(String featureId) {\n        int length = RECOGNIZED_FEATURES != null ? RECOGNIZED_FEATURES.length : 0;\n        for (int i = 0; i < length; i++) {\n            if (RECOGNIZED_FEATURES[i].equals(featureId)) {\n                return RECOGNIZED_FEATURES_DEFAULTS[i];\n            }\n        }\n        return null;\n    } // getFeatureDefault(String):Boolean\n\n    /** Returns the default state for a property. */\n    public Object getPropertyDefault(String propertyId) {\n        int length = RECOGNIZED_PROPERTIES != null ? RECOGNIZED_PROPERTIES.length : 0;\n        for (int i = 0; i < length; i++) {\n            if (RECOGNIZED_PROPERTIES[i].equals(propertyId)) {\n                return RECOGNIZED_PROPERTIES_DEFAULTS[i];\n            }\n        }\n        return null;\n    } // getPropertyDefault(String):Object\n\n    //\n    // XMLComponent methods\n    //\n\n    /** Returns recognized features. */\n    public String[] getRecognizedFeatures() {\n        return RECOGNIZED_FEATURES;\n    } // getRecognizedFeatures():String[]\n\n    /** Returns recognized properties. */\n    public String[] getRecognizedProperties() {\n        return RECOGNIZED_PROPERTIES;\n    } // getRecognizedProperties():String[]\n\n    /** Resets the component. */\n    public void reset(XMLComponentManager manager)\n        throws XMLConfigurationException {\n\n        // get features\n        fAugmentations = manager.getFeature(AUGMENTATIONS);\n        fReportErrors = manager.getFeature(REPORT_ERRORS);\n        fNotifyCharRefs = manager.getFeature(NOTIFY_CHAR_REFS);\n        fNotifyXmlBuiltinRefs = manager.getFeature(NOTIFY_XML_BUILTIN_REFS);\n        fNotifyHtmlBuiltinRefs = manager.getFeature(NOTIFY_HTML_BUILTIN_REFS);\n        fFixWindowsCharRefs = manager.getFeature(FIX_MSWINDOWS_REFS);\n        fScriptStripCDATADelims = manager.getFeature(SCRIPT_STRIP_CDATA_DELIMS);\n        fScriptStripCommentDelims = manager.getFeature(SCRIPT_STRIP_COMMENT_DELIMS);\n        fStyleStripCDATADelims = manager.getFeature(STYLE_STRIP_CDATA_DELIMS);\n        fStyleStripCommentDelims = manager.getFeature(STYLE_STRIP_COMMENT_DELIMS);\n        fIgnoreSpecifiedCharset = manager.getFeature(IGNORE_SPECIFIED_CHARSET);\n        fCDATASections = manager.getFeature(CDATA_SECTIONS);\n        fOverrideDoctype = manager.getFeature(OVERRIDE_DOCTYPE);\n        fInsertDoctype = manager.getFeature(INSERT_DOCTYPE);\n        fNormalizeAttributes = manager.getFeature(NORMALIZE_ATTRIBUTES);\n        fParseNoScriptContent = manager.getFeature(PARSE_NOSCRIPT_CONTENT);\n        fAllowSelfclosingIframe = manager.getFeature(ALLOW_SELFCLOSING_IFRAME);\n        fAllowSelfclosingTags = manager.getFeature(ALLOW_SELFCLOSING_TAGS);\n\n        // get properties\n        fNamesElems = getNamesValue(String.valueOf(manager.getProperty(NAMES_ELEMS)));\n        fNamesAttrs = getNamesValue(String.valueOf(manager.getProperty(NAMES_ATTRS)));\n        fDefaultIANAEncoding = String.valueOf(manager.getProperty(DEFAULT_ENCODING));\n        fErrorReporter = (HTMLErrorReporter)manager.getProperty(ERROR_REPORTER);\n        fDoctypePubid = String.valueOf(manager.getProperty(DOCTYPE_PUBID));\n        fDoctypeSysid = String.valueOf(manager.getProperty(DOCTYPE_SYSID));\n    \n    } // reset(XMLComponentManager)\n\n    /** Sets a feature. */\n    public void setFeature(final String featureId, final boolean state) {\n\n        if (featureId.equals(AUGMENTATIONS)) { \n            fAugmentations = state; \n        }\n        else if (featureId.equals(IGNORE_SPECIFIED_CHARSET)) { \n            fIgnoreSpecifiedCharset = state; \n        }\n        else if (featureId.equals(NOTIFY_CHAR_REFS)) { \n            fNotifyCharRefs = state; \n        }\n        else if (featureId.equals(NOTIFY_XML_BUILTIN_REFS)) { \n            fNotifyXmlBuiltinRefs = state; \n        }\n        else if (featureId.equals(NOTIFY_HTML_BUILTIN_REFS)) { \n            fNotifyHtmlBuiltinRefs = state; \n        }\n        else if (featureId.equals(FIX_MSWINDOWS_REFS)) { \n            fFixWindowsCharRefs = state; \n        }\n        else if (featureId.equals(SCRIPT_STRIP_CDATA_DELIMS)) { \n            fScriptStripCDATADelims = state; \n        }\n        else if (featureId.equals(SCRIPT_STRIP_COMMENT_DELIMS)) { \n            fScriptStripCommentDelims = state; \n        }\n        else if (featureId.equals(STYLE_STRIP_CDATA_DELIMS)) { \n            fStyleStripCDATADelims = state; \n        }\n        else if (featureId.equals(STYLE_STRIP_COMMENT_DELIMS)) { \n            fStyleStripCommentDelims = state; \n        }\n        else if (featureId.equals(PARSE_NOSCRIPT_CONTENT)) { \n            fParseNoScriptContent = state; \n        }\n        else if (featureId.equals(ALLOW_SELFCLOSING_IFRAME)) { \n            fAllowSelfclosingIframe = state; \n        }\n        else if (featureId.equals(ALLOW_SELFCLOSING_TAGS)) { \n            fAllowSelfclosingTags = state; \n        }\n\n    } // setFeature(String,boolean)\n\n    /** Sets a property. */\n    public void setProperty(String propertyId, Object value)\n        throws XMLConfigurationException {\n    \n        if (propertyId.equals(NAMES_ELEMS)) {\n            fNamesElems = getNamesValue(String.valueOf(value));\n            return;\n        }\n\n        if (propertyId.equals(NAMES_ATTRS)) {\n            fNamesAttrs = getNamesValue(String.valueOf(value));\n            return;\n        }\n\n        if (propertyId.equals(DEFAULT_ENCODING)) {\n            fDefaultIANAEncoding = String.valueOf(value);\n            return;\n        }\n\n    } // setProperty(String,Object)\n\n    //\n    // XMLDocumentScanner methods\n    //\n\n    /** Sets the input source. */\n    public void setInputSource(XMLInputSource source) throws IOException {\n\n        // reset state\n        fElementCount = 0;\n        fElementDepth = -1;\n        fByteStream = null;\n        fCurrentEntityStack.removeAllElements();\n\n        fBeginLineNumber = 1;\n        fBeginColumnNumber = 1;\n        fBeginCharacterOffset = 0;\n        fEndLineNumber = fBeginLineNumber;\n        fEndColumnNumber = fBeginColumnNumber;\n        fEndCharacterOffset = fBeginCharacterOffset;\n\n        // reset encoding information\n        fIANAEncoding = fDefaultIANAEncoding;\n        fJavaEncoding = fIANAEncoding;\n\n        // get location information\n        String encoding = source.getEncoding();\n        String publicId = source.getPublicId();\n        String baseSystemId = source.getBaseSystemId();\n        String literalSystemId = source.getSystemId();\n        String expandedSystemId = expandSystemId(literalSystemId, baseSystemId);\n\n        // open stream\n        Reader reader = source.getCharacterStream();\n        if (reader == null) {\n            InputStream inputStream = source.getByteStream();\n            if (inputStream == null) {\n                URL url = new URL(expandedSystemId);\n                inputStream = url.openStream();\n            }\n            fByteStream = new PlaybackInputStream(inputStream);\n            String[] encodings = new String[2];\n            if (encoding == null) {\n                fByteStream.detectEncoding(encodings);\n            }\n            else {\n                encodings[0] = encoding;\n            }\n            if (encodings[0] == null) {\n                encodings[0] = fDefaultIANAEncoding;\n                if (fReportErrors) {\n                    fErrorReporter.reportWarning(\"HTML1000\", null);\n                }\n            }\n            if (encodings[1] == null) {\n                encodings[1] = EncodingMap.getIANA2JavaMapping(encodings[0].toUpperCase(Locale.ENGLISH));\n                if (encodings[1] == null) {\n                    encodings[1] = encodings[0];\n                    if (fReportErrors) {\n                        fErrorReporter.reportWarning(\"HTML1001\", new Object[]{encodings[0]});\n                    }\n                }\n            }\n            fIANAEncoding = encodings[0];\n            fJavaEncoding = encodings[1];\n            /* PATCH: Asgeir Asgeirsson */\n            fIso8859Encoding = fIANAEncoding == null \n                            || fIANAEncoding.toUpperCase(Locale.ENGLISH).startsWith(\"ISO-8859\")\n                            || fIANAEncoding.equalsIgnoreCase(fDefaultIANAEncoding);\n            encoding = fIANAEncoding;\n            reader = new InputStreamReader(fByteStream, fJavaEncoding);\n        }\n        fCurrentEntity = new CurrentEntity(reader, encoding,\n                                           publicId, baseSystemId,\n                                           literalSystemId, expandedSystemId);\n\n        // set scanner and state\n        setScanner(fContentScanner);\n        setScannerState(STATE_START_DOCUMENT);\n\n    } // setInputSource(XMLInputSource)\n\n    /** Scans the document. */\n    public boolean scanDocument(boolean complete) throws XNIException, IOException {\n        do {\n            if (!fScanner.scan(complete)) {\n                return false;\n            }\n        } while (complete);\n        return true;\n    } // scanDocument(boolean):boolean\n\n    /** Sets the document handler. */\n    public void setDocumentHandler(XMLDocumentHandler handler) {\n        fDocumentHandler = handler;\n    } // setDocumentHandler(XMLDocumentHandler)\n\n    // @since Xerces 2.1.0\n\n    /** Returns the document handler. */\n    public XMLDocumentHandler getDocumentHandler() {\n        return fDocumentHandler;\n    } // getDocumentHandler():XMLDocumentHandler\n\n    //\n    // Protected static methods\n    //\n\n    /** Returns the value of the specified attribute, ignoring case. */\n    protected static String getValue(XMLAttributes attrs, String aname) {\n        int length = attrs != null ? attrs.getLength() : 0;\n        for (int i = 0; i < length; i++) {\n            if (attrs.getQName(i).equalsIgnoreCase(aname)) {\n                return attrs.getValue(i);\n            }\n        }\n        return null;\n    } // getValue(XMLAttributes,String):String\n\n    /**\n     * Expands a system id and returns the system id as a URI, if\n     * it can be expanded. A return value of null means that the\n     * identifier is already expanded. An exception thrown\n     * indicates a failure to expand the id.\n     *\n     * @param systemId The systemId to be expanded.\n     *\n     * @return Returns the URI string representing the expanded system\n     *         identifier. A null value indicates that the given\n     *         system identifier is already expanded.\n     *\n     */\n    public static String expandSystemId(String systemId, String baseSystemId) {\n\n        // check for bad parameters id\n        if (systemId == null || systemId.length() == 0) {\n            return systemId;\n        }\n        // if id already expanded, return\n        try {\n            URI uri = new URI(systemId);\n            if (uri != null) {\n                return systemId;\n            }\n        }\n        catch (URI.MalformedURIException e) {\n            // continue on...\n        }\n        // normalize id\n        String id = fixURI(systemId);\n\n        // normalize base\n        URI base = null;\n        URI uri = null;\n        try {\n            if (baseSystemId == null || baseSystemId.length() == 0 ||\n                baseSystemId.equals(systemId)) {\n                String dir;\n                try {\n                    dir = fixURI(System.getProperty(\"user.dir\"));\n                }\n                catch (SecurityException se) {\n                    dir = \"\";\n                }\n                if (!dir.endsWith(\"/\")) {\n                    dir = dir + \"/\";\n                }\n                base = new URI(\"file\", \"\", dir, null, null);\n            }\n            else {\n                try {\n                    base = new URI(fixURI(baseSystemId));\n                }\n                catch (URI.MalformedURIException e) {\n                    String dir;\n                    try {\n                        dir = fixURI(System.getProperty(\"user.dir\"));\n                    }\n                    catch (SecurityException se) {\n                        dir = \"\";\n                    }\n                    if (baseSystemId.indexOf(':') != -1) {\n                        // for xml schemas we might have baseURI with\n                        // a specified drive\n                        base = new URI(\"file\", \"\", fixURI(baseSystemId), null, null);\n                    }\n                    else {\n                        if (!dir.endsWith(\"/\")) {\n                            dir = dir + \"/\";\n                        }\n                        dir = dir + fixURI(baseSystemId);\n                        base = new URI(\"file\", \"\", dir, null, null);\n                    }\n                }\n             }\n             // expand id\n             uri = new URI(base, id);\n        }\n        catch (URI.MalformedURIException e) {\n            // let it go through\n        }\n\n        if (uri == null) {\n            return systemId;\n        }\n        return uri.toString();\n\n    } // expandSystemId(String,String):String\n\n    /**\n     * Fixes a platform dependent filename to standard URI form.\n     *\n     * @param str The string to fix.\n     *\n     * @return Returns the fixed URI string.\n     */\n    protected static String fixURI(String str) {\n\n        // handle platform dependent strings\n        str = str.replace(java.io.File.separatorChar, '/');\n\n        // Windows fix\n        if (str.length() >= 2) {\n            char ch1 = str.charAt(1);\n            // change \"C:blah\" to \"/C:blah\"\n            if (ch1 == ':') {\n                final char ch0 = String.valueOf(str.charAt(0)).toUpperCase(Locale.ENGLISH).charAt(0);\n                if (ch0 >= 'A' && ch0 <= 'Z') {\n                    str = \"/\" + str;\n                }\n            }\n            // change \"//blah\" to \"file://blah\"\n            else if (ch1 == '/' && str.charAt(0) == '/') {\n                str = \"file:\" + str;\n            }\n        }\n\n        // done\n        return str;\n\n    } // fixURI(String):String\n\n    /** Modifies the given name based on the specified mode. */\n    protected static final String modifyName(String name, short mode) {\n        switch (mode) {\n            case NAMES_UPPERCASE: return name.toUpperCase(Locale.ENGLISH);\n            case NAMES_LOWERCASE: return name.toLowerCase(Locale.ENGLISH);\n        }\n        return name;\n    } // modifyName(String,short):String\n\n    /**\n     * Converts HTML names string value to constant value. \n     *\n     * @see #NAMES_NO_CHANGE\n     * @see #NAMES_LOWERCASE\n     * @see #NAMES_UPPERCASE\n     */\n    protected static final short getNamesValue(String value) {\n        if (value.equals(\"lower\")) {\n            return NAMES_LOWERCASE;\n        }\n        if (value.equals(\"upper\")) {\n            return NAMES_UPPERCASE;\n        }\n        return NAMES_NO_CHANGE;\n    } // getNamesValue(String):short\n\n    /**\n     * Fixes Microsoft Windows&reg; specific characters.\n     * <p>\n     * Details about this common problem can be found at \n     * <a href='http://www.cs.tut.fi/~jkorpela/www/windows-chars.html'>http://www.cs.tut.fi/~jkorpela/www/windows-chars.html</a>\n     */\n    protected int fixWindowsCharacter(int origChar) {\n        /* PATCH: Asgeir Asgeirsson */\n        switch(origChar) {\n            case 130: return 8218;\n            case 131: return 402;\n            case 132: return 8222;\n            case 133: return 8230;\n            case 134: return 8224;\n            case 135: return 8225;\n            case 136: return 710;\n            case 137: return 8240;\n            case 138: return 352;\n            case 139: return 8249;\n            case 140: return 338;\n            case 145: return 8216;\n            case 146: return 8217;\n            case 147: return 8220;\n            case 148: return 8221;\n            case 149: return 8226;\n            case 150: return 8211;\n            case 151: return 8212;\n            case 152: return 732;\n            case 153: return 8482;\n            case 154: return 353;\n            case 155: return 8250;\n            case 156: return 339;\n            case 159: return 376;\n        }\n        return origChar;\n    } // fixWindowsCharacter(int):int\n\n    //\n    // Protected methods\n    //\n\n    // i/o\n    /** Reads a single character. */\n    protected int read() throws IOException {\n    \treturn fCurrentEntity.read();\n    }\n\n\n    // debugging\n\n    /** Sets the scanner. */\n    protected void setScanner(Scanner scanner) {\n        fScanner = scanner;\n        if (DEBUG_SCANNER) {\n            System.out.print(\"$$$ setScanner(\");\n            System.out.print(scanner!=null?scanner.getClass().getName():\"null\");\n            System.out.println(\");\");\n        }\n    } // setScanner(Scanner)\n    \n    /** Sets the scanner state. */\n    protected void setScannerState(short state) {\n        fScannerState = state;\n        if (DEBUG_SCANNER_STATE) {\n            System.out.print(\"$$$ setScannerState(\");\n            switch (fScannerState) {\n                case STATE_CONTENT: { System.out.print(\"STATE_CONTENT\"); break; }\n                case STATE_MARKUP_BRACKET: { System.out.print(\"STATE_MARKUP_BRACKET\"); break; }\n                case STATE_START_DOCUMENT: { System.out.print(\"STATE_START_DOCUMENT\"); break; }\n                case STATE_END_DOCUMENT: { System.out.print(\"STATE_END_DOCUMENT\"); break; }\n            }\n            System.out.println(\");\");\n        }\n    } // setScannerState(short)\n\n    // scanning\n\n    /** Scans a DOCTYPE line. */\n    protected void scanDoctype() throws IOException {\n        String root = null;\n        String pubid = null;\n        String sysid = null;\n\n        if (skipSpaces()) {\n            root = scanName(true);\n            if (root == null) {\n                if (fReportErrors) {\n                    fErrorReporter.reportError(\"HTML1014\", null);\n                }\n            }\n            else {\n                root = modifyName(root, fNamesElems);\n            }\n            if (skipSpaces()) {\n                if (skip(\"PUBLIC\", false)) {\n                    skipSpaces();\n                    pubid = scanLiteral();\n                    if (skipSpaces()) {\n                        sysid = scanLiteral();\n                    }\n                }\n                else if (skip(\"SYSTEM\", false)) {\n                    skipSpaces();\n                    sysid = scanLiteral();\n                }\n            }\n        }\n        int c;\n        while ((c = fCurrentEntity.read()) != -1) {\n            if (c == '<') {\n            \tfCurrentEntity.rewind();\n                break;\n            }\n            if (c == '>') {\n                break;\n            }\n            if (c == '[') {\n                skipMarkup(true);\n                break;\n            }\n        }\n\n        if (fDocumentHandler != null) {\n            if (fOverrideDoctype) {\n                pubid = fDoctypePubid;\n                sysid = fDoctypeSysid;\n            }\n            fEndLineNumber = fCurrentEntity.getLineNumber();\n            fEndColumnNumber = fCurrentEntity.getColumnNumber();\n            fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n            fDocumentHandler.doctypeDecl(root, pubid, sysid, locationAugs());\n        }\n\n    } // scanDoctype()\n\n    /** Scans a quoted literal. */\n    protected String scanLiteral() throws IOException {\n        int quote = fCurrentEntity.read();\n        if (quote == '\\'' || quote == '\"') {\n            StringBuffer str = new StringBuffer();\n            int c;\n            while ((c = fCurrentEntity.read()) != -1) {\n                if (c == quote) {\n                    break;\n                }\n                if (c == '\\r' || c == '\\n') {\n                \tfCurrentEntity.rewind();\n                    // NOTE: This collapses newlines to a single space.\n                    //       [Q] Is this the right thing to do here? -Ac\n                    skipNewlines();\n                    str.append(' ');\n                }\n                else if (c == '<') {\n                \tfCurrentEntity.rewind();\n                    break;\n                }\n                else {\n                    appendChar(str, c);\n                }\n            }\n            if (c == -1) {\n                if (fReportErrors) {\n                    fErrorReporter.reportError(\"HTML1007\", null);\n                }\n                throw new EOFException();\n            }\n            return str.toString();\n        }\n       \tfCurrentEntity.rewind();\n        return null;\n    } // scanLiteral():String\n\n    /** Scans a name. */\n    protected String scanName(final boolean strict) throws IOException {\n        if (DEBUG_BUFFER) { \n            fCurrentEntity.debugBufferIfNeeded(\"(scanName: \");\n        }\n        if (fCurrentEntity.offset == fCurrentEntity.length) {\n            if (fCurrentEntity.load(0) == -1) {\n                if (DEBUG_BUFFER) { \n                    fCurrentEntity.debugBufferIfNeeded(\")scanName: \");\n                }\n                return null;\n            }\n        }\n        int offset = fCurrentEntity.offset;\n        while (true) {\n            while (fCurrentEntity.hasNext()) {\n                char c = fCurrentEntity.getNextChar();\n                if ((strict && (!Character.isLetterOrDigit(c) && c != '-' && c != '.' && c != ':' && c != '_'))\n                    || (!strict && (Character.isWhitespace(c) || c == '=' || c == '/' || c == '>'))) {\n                \tfCurrentEntity.rewind();\n                    break;\n                }\n            }\n            if (fCurrentEntity.offset == fCurrentEntity.length) {\n                int length = fCurrentEntity.length - offset;\n                System.arraycopy(fCurrentEntity.buffer, offset, fCurrentEntity.buffer, 0, length);\n                int count = fCurrentEntity.load(length);\n                offset = 0;\n                if (count == -1) {\n                    break;\n                }\n            }\n            else {\n                break;\n            }\n        }\n        int length = fCurrentEntity.offset - offset;\n        String name = length > 0 ? new String(fCurrentEntity.buffer, offset, length) : null;\n        if (DEBUG_BUFFER) { \n            fCurrentEntity.debugBufferIfNeeded(\")scanName: \", \" -> \\\"\" + name + '\"');\n        }\n        return name;\n    } // scanName():String\n\n    /** Scans an entity reference. */\n    protected int scanEntityRef(final XMLStringBuffer str, final boolean content) \n        throws IOException {\n        str.clear();\n        str.append('&');\n        boolean endsWithSemicolon = false;\n        while (true) {\n            int c = fCurrentEntity.read();\n            if (c == ';') {\n                str.append(';');\n                endsWithSemicolon = true;\n                break;\n            }\n            else if (c == -1) {\n            \tbreak;\n            }\n            else if (!ENTITY_CHARS.get(c) && c != '#') {\n            \tfCurrentEntity.rewind();\n                break;\n            }\n            appendChar(str, c);\n        }\n\n        if (!endsWithSemicolon) {\n            if (fReportErrors) {\n                fErrorReporter.reportWarning(\"HTML1004\", null);\n            }\n        }\n        if (str.length == 1) {\n            if (content && fDocumentHandler != null && fElementCount >= fElementDepth) {\n                fEndLineNumber = fCurrentEntity.getLineNumber();\n                fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                fDocumentHandler.characters(str, locationAugs());\n            }\n            return -1;\n        }\n\n        final String name;\n        if (endsWithSemicolon)\n        \tname = str.toString().substring(1, str.length -1);\n        else\n        \tname = str.toString().substring(1);\n\n        if (name.startsWith(\"#\")) {\n            int value = -1;\n            try {\n                if (name.startsWith(\"#x\") || name.startsWith(\"#X\")) {\n                    value = Integer.parseInt(name.substring(2), 16);\n                }\n                else {\n                    value = Integer.parseInt(name.substring(1));\n                }\n                /* PATCH: Asgeir Asgeirsson */\n                if (fFixWindowsCharRefs && fIso8859Encoding) {\n                    value = fixWindowsCharacter(value);\n                }\n                if (content && fDocumentHandler != null && fElementCount >= fElementDepth) {\n                    fEndLineNumber = fCurrentEntity.getLineNumber();\n                    fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                    fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                    if (fNotifyCharRefs) {\n                        XMLResourceIdentifier id = resourceId();\n                        String encoding = null;\n                        fDocumentHandler.startGeneralEntity(name, id, encoding, locationAugs());\n                    }\n                    str.clear();\n                    try {\n                    \tappendChar(str, value);\n                    }\n                    catch (final IllegalArgumentException e) { // when value is not valid as UTF-16 \n        \t\t        if (fReportErrors) {\n        \t\t            fErrorReporter.reportError(\"HTML1005\", new Object[]{name});\n        \t\t        }\n                \t\tstr.append(REPLACEMENT_CHARACTER);\n                    }\n                    fDocumentHandler.characters(str, locationAugs());\n                    if (fNotifyCharRefs) {\n                        fDocumentHandler.endGeneralEntity(name, locationAugs());\n                    }\n                }\n            }\n            catch (NumberFormatException e) {\n                if (fReportErrors) {\n                    fErrorReporter.reportError(\"HTML1005\", new Object[]{name});\n                }\n                if (content && fDocumentHandler != null && fElementCount >= fElementDepth) {\n                    fEndLineNumber = fCurrentEntity.getLineNumber();\n                    fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                    fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                    fDocumentHandler.characters(str, locationAugs());\n                }\n            }\n            return value;\n        }\n\n        int c = HTMLEntities.get(name);\n        // in attributes, some incomplete entities should be recognized, not all\n        // TODO: investigate to find which ones (there are differences between browsers)\n        // in a first time, consider only those that behave the same in FF and IE \n        final boolean invalidEntityInAttribute = !content && !endsWithSemicolon && c > 256;\n        if (c == -1 || invalidEntityInAttribute) {\n            if (fReportErrors) {\n                fErrorReporter.reportWarning(\"HTML1006\", new Object[]{name});\n            }\n            if (content && fDocumentHandler != null && fElementCount >= fElementDepth) {\n                fEndLineNumber = fCurrentEntity.getLineNumber();\n                fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                fDocumentHandler.characters(str, locationAugs());\n            }\n            return -1;\n        }\n        if (content && fDocumentHandler != null && fElementCount >= fElementDepth) {\n            fEndLineNumber = fCurrentEntity.getLineNumber();\n            fEndColumnNumber = fCurrentEntity.getColumnNumber();\n            fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n            boolean notify = fNotifyHtmlBuiltinRefs || (fNotifyXmlBuiltinRefs && builtinXmlRef(name));\n            if (notify) {\n                XMLResourceIdentifier id = resourceId();\n                String encoding = null;\n                fDocumentHandler.startGeneralEntity(name, id, encoding, locationAugs());\n            }\n            str.clear();\n            appendChar(str, c);\n            fDocumentHandler.characters(str, locationAugs());\n            if (notify) {\n                fDocumentHandler.endGeneralEntity(name, locationAugs());\n            }\n        }\n        return c;\n\n    } // scanEntityRef(XMLStringBuffer,boolean):int\n\n    /** Returns true if the specified text is present and is skipped. */\n    protected boolean skip(String s, boolean caseSensitive) throws IOException {\n        int length = s != null ? s.length() : 0;\n        for (int i = 0; i < length; i++) {\n            if (fCurrentEntity.offset == fCurrentEntity.length) {\n                System.arraycopy(fCurrentEntity.buffer, fCurrentEntity.offset - i, fCurrentEntity.buffer, 0, i);\n                if (fCurrentEntity.load(i) == -1) {\n                    fCurrentEntity.offset = 0;\n                    return false;\n                }\n            }\n            char c0 = s.charAt(i);\n            char c1 = fCurrentEntity.getNextChar();\n            if (!caseSensitive) {\n                c0 = String.valueOf(c0).toUpperCase(Locale.ENGLISH).charAt(0);\n                c1 = String.valueOf(c1).toUpperCase(Locale.ENGLISH).charAt(0);\n            }\n            if (c0 != c1) {\n            \tfCurrentEntity.rewind(i + 1);\n                return false;\n            }\n        }\n        return true;\n    } // skip(String):boolean\n\n    /** Skips markup. */\n    protected boolean skipMarkup(boolean balance) throws IOException {\n        if (DEBUG_BUFFER) { \n            fCurrentEntity.debugBufferIfNeeded(\"(skipMarkup: \");\n        }\n        int depth = 1;\n        boolean slashgt = false;\n        OUTER: while (true) {\n            if (fCurrentEntity.offset == fCurrentEntity.length) {\n                if (fCurrentEntity.load(0) == -1) {\n                    break OUTER;\n                }\n            }\n            while (fCurrentEntity.hasNext()) {\n                char c = fCurrentEntity.getNextChar();\n                if (balance && c == '<') {\n                    depth++;\n                }\n                else if (c == '>') {\n                    depth--;\n                    if (depth == 0) {\n                        break OUTER;\n                    }\n                }\n                else if (c == '/') {\n                    if (fCurrentEntity.offset == fCurrentEntity.length) {\n                        if (fCurrentEntity.load(0) == -1) {\n                            break OUTER;\n                        }\n                    }\n                    c = fCurrentEntity.getNextChar();\n                    if (c == '>') {\n                        slashgt = true;\n                        depth--;\n                        if (depth == 0) {\n                            break OUTER;\n                        }\n                    }\n                    else {\n                    \tfCurrentEntity.rewind();\n                    }\n                }\n                else if (c == '\\r' || c == '\\n') {\n                \tfCurrentEntity.rewind();\n                    skipNewlines();\n                }\n            }\n        }\n        if (DEBUG_BUFFER) { \n            fCurrentEntity.debugBufferIfNeeded(\")skipMarkup: \", \" -> \" + slashgt);\n        }\n        return slashgt;\n    } // skipMarkup():boolean\n\n    /** Skips whitespace. */\n    protected boolean skipSpaces() throws IOException {\n        if (DEBUG_BUFFER) { \n            fCurrentEntity.debugBufferIfNeeded(\"(skipSpaces: \");\n        }\n        boolean spaces = false;\n        while (true) {\n            if (fCurrentEntity.offset == fCurrentEntity.length) {\n                if (fCurrentEntity.load(0) == -1) {\n                    break;\n                }\n            }\n            char c = fCurrentEntity.getNextChar();\n            if (!Character.isWhitespace(c)) {\n            \tfCurrentEntity.rewind();\n                break;\n            }\n            spaces = true;\n            if (c == '\\r' || c == '\\n') {\n            \tfCurrentEntity.rewind();\n                skipNewlines();\n                continue;\n            }\n        }\n        if (DEBUG_BUFFER) { \n            fCurrentEntity.debugBufferIfNeeded(\")skipSpaces: \", \" -> \" + spaces);\n        }\n        return spaces;\n    } // skipSpaces()\n\n    /** Skips newlines and returns the number of newlines skipped. */\n    protected int skipNewlines() throws IOException {\n        if (DEBUG_BUFFER) { \n            fCurrentEntity.debugBufferIfNeeded(\"(skipNewlines: \");\n        }\n\n        if (!fCurrentEntity.hasNext()) {\n            if (fCurrentEntity.load(0) == -1) {\n                if (DEBUG_BUFFER) { \n                    fCurrentEntity.debugBufferIfNeeded(\")skipNewlines: \");\n                }\n                return 0;\n            }\n        }\n        char c = fCurrentEntity.getCurrentChar();\n        int newlines = 0;\n        int offset = fCurrentEntity.offset;\n        if (c == '\\n' || c == '\\r') {\n            do {\n                c = fCurrentEntity.getNextChar();\n                if (c == '\\r') {\n                    newlines++;\n                    if (fCurrentEntity.offset == fCurrentEntity.length) {\n                        offset = 0;\n                        fCurrentEntity.offset = newlines;\n                        if (fCurrentEntity.load(newlines) == -1) {\n                            break;\n                        }\n                    }\n                    if (fCurrentEntity.getCurrentChar() == '\\n') {\n                        fCurrentEntity.offset++;\n                        fCurrentEntity.characterOffset_++;\n                        offset++;\n                    }\n                }\n                else if (c == '\\n') {\n                    newlines++;\n                    if (fCurrentEntity.offset == fCurrentEntity.length) {\n                        offset = 0;\n                        fCurrentEntity.offset = newlines;\n                        if (fCurrentEntity.load(newlines) == -1) {\n                            break;\n                        }\n                    }\n                }\n                else {\n                    fCurrentEntity.rewind();\n                    break;\n                }\n            } while (fCurrentEntity.offset < fCurrentEntity.length - 1);\n            fCurrentEntity.incLine(newlines);\n        }\n        if (DEBUG_BUFFER) { \n            fCurrentEntity.debugBufferIfNeeded(\")skipNewlines: \", \" -> \" + newlines);\n        }\n        return newlines;\n    } // skipNewlines(int):int\n\n    // infoset utility methods\n\n    /** Returns an augmentations object with a location item added. */\n    protected final Augmentations locationAugs() {\n        HTMLAugmentations augs = null;\n        if (fAugmentations) {\n            fLocationItem.setValues(fBeginLineNumber, fBeginColumnNumber, \n                                    fBeginCharacterOffset, fEndLineNumber,\n                                    fEndColumnNumber, fEndCharacterOffset);\n            augs = fInfosetAugs;\n            augs.removeAllItems();\n            augs.putItem(AUGMENTATIONS, fLocationItem);\n        }\n        return augs;\n    } // locationAugs():Augmentations\n\n    /** Returns an augmentations object with a synthesized item added. */\n    protected final Augmentations synthesizedAugs() {\n        HTMLAugmentations augs = null;\n        if (fAugmentations) {\n            augs = fInfosetAugs;\n            augs.removeAllItems();\n            augs.putItem(AUGMENTATIONS, SYNTHESIZED_ITEM);\n        }\n        return augs;\n    } // synthesizedAugs():Augmentations\n\n    /** Returns an empty resource identifier. */\n    protected final XMLResourceIdentifier resourceId() {\n        /***/\n        fResourceId.clear();\n        return fResourceId;\n        /***\n        // NOTE: Unfortunately, the Xerces DOM parser classes expect a\n        //       non-null resource identifier object to be passed to\n        //       startGeneralEntity. -Ac\n        return null;\n        /***/\n    } // resourceId():XMLResourceIdentifier\n\n    //\n    // Protected static methods\n    //\n\n    /** Returns true if the name is a built-in XML general entity reference. */\n    protected static boolean builtinXmlRef(String name) {\n        return name.equals(\"amp\") || name.equals(\"lt\") || name.equals(\"gt\") ||\n               name.equals(\"quot\") || name.equals(\"apos\");\n    } // builtinXmlRef(String):boolean\n\n    //\n    // Private methods\n    //\n\n    /**\n     * Append a character to an XMLStringBuffer. The character is an int value, and can either be a\n     * single UTF-16 character or a supplementary character represented by two UTF-16 code points.\n     *\n     * @param str The XMLStringBuffer to append to.\n     * @param value The character value.\n     */\n    private void appendChar( XMLStringBuffer str, int value )\n    {\n        if ( value > Character.MAX_VALUE )\n        {\n            char[] chars = Character.toChars( value );\n\n            str.append( chars, 0, chars.length );\n        }\n        else\n        {\n            str.append( (char) value );\n        }\n    }\n\n    /**\n     * Append a character to a StringBuffer. The character is an int value, and can either be a\n     * single UTF-16 character or a supplementary character represented by two UTF-16 code points.\n     *\n     * @param str The StringBuffer to append to.\n     * @param value The character value.\n     */\n    private void appendChar( StringBuffer str, int value )\n    {\n        if ( value > Character.MAX_VALUE )\n        {\n            char[] chars = Character.toChars( value );\n\n            str.append( chars, 0, chars.length );\n        }\n        else\n        {\n            str.append( (char) value );\n        }\n    }\n\n    //\n    // Interfaces\n    //\n\n    /**\n     * Basic scanner interface.\n     *\n     * @author Andy Clark\n     */\n    public interface Scanner {\n\n        //\n        // Scanner methods\n        //\n\n        /** \n         * Scans part of the document. This interface allows scanning to\n         * be performed in a pulling manner.\n         *\n         * @param complete True if the scanner should not return until\n         *                 scanning is complete.\n         *\n         * @return True if additional scanning is required.\n         *\n         * @throws IOException Thrown if I/O error occurs.\n         */\n        public boolean scan(boolean complete) throws IOException;\n\n    } // interface Scanner\n\n    //\n    // Classes\n    //\n\n    /**\n     * Current entity.\n     *\n     * @author Andy Clark\n     */\n    public static class CurrentEntity {\n\n        //\n        // Data\n        //\n\n        /** Character stream. */\n        private Reader stream_;\n\n        /** Encoding. */\n        private String encoding;\n\n        /** Public identifier. */\n        public final String publicId;\n\n        /** Base system identifier. */\n        public final String baseSystemId;\n\n        /** Literal system identifier. */\n        public final String literalSystemId;\n\n        /** Expanded system identifier. */\n        public final String expandedSystemId;\n\n\t\t/** XML version. */\n\t\tpublic final String version = \"1.0\";\n\n        /** Line number. */\n        private int lineNumber_ = 1;\n\n        /** Column number. */\n        private int columnNumber_ = 1;\n        \n        /** Character offset in the file. */\n        public int characterOffset_ = 0;\n\n        // buffer\n\n        /** Character buffer. */\n        public char[] buffer = new char[DEFAULT_BUFFER_SIZE];\n\n        /** Offset into character buffer. */\n        public int offset = 0;\n\n        /** Length of characters read into character buffer. */\n        public int length = 0;\n        \n        private boolean endReached_ = false;\n\n        //\n        // Constructors\n        //\n\n        /** Constructs an entity from the specified stream. */\n        public CurrentEntity(Reader stream, String encoding, \n                             String publicId, String baseSystemId,\n                             String literalSystemId, String expandedSystemId) {\n            stream_ = stream;\n            this.encoding = encoding;\n            this.publicId = publicId;\n            this.baseSystemId = baseSystemId;\n            this.literalSystemId = literalSystemId;\n            this.expandedSystemId = expandedSystemId;\n        } // <init>(Reader,String,String,String,String)\n\n\t\tprivate char getCurrentChar() {\n        \treturn buffer[offset];\n        }\n\n        /**\n         * Gets the current character and moves to next one.\n         * @return\n         */\n        private char getNextChar() {\n\t        characterOffset_++;\n\t        columnNumber_++;\n        \treturn buffer[offset++];\n        }\n        private void closeQuietly() {\n            try {\n                stream_.close();\n            }\n            catch (IOException e) {\n                // ignore\n            }\n\t\t}\n\n\t\t/**\n         * Indicates if there are characters left.\n         */\n        boolean hasNext() {\n        \treturn offset < length;        \t\n        }\n\n        /** \n         * Loads a new chunk of data into the buffer and returns the number of\n         * characters loaded or -1 if no additional characters were loaded.\n         *\n         * @param offset The offset at which new characters should be loaded.\n         */\n        protected int load(int offset) throws IOException {\n            if (DEBUG_BUFFER) { \n                debugBufferIfNeeded(\"(load: \");\n            }\n            // resize buffer, if needed\n            if (offset == buffer.length) {\n                int adjust = buffer.length / 4;\n                char[] array = new char[buffer.length + adjust];\n                System.arraycopy(buffer, 0, array, 0, length);\n                buffer = array;\n            }\n            // read a block of characters\n            int count = stream_.read(buffer, offset, buffer.length - offset);\n            if (count == -1) {\n            \tendReached_ = true;\n            }\n            length = count != -1 ? count + offset : offset;\n            this.offset = offset;\n            if (DEBUG_BUFFER) { \n                debugBufferIfNeeded(\")load: \", \" -> \" + count);\n            }\n            return count;\n        } // load():int\n\n        /** Reads a single character. */\n        protected int read() throws IOException {\n            if (DEBUG_BUFFER) { \n                debugBufferIfNeeded(\"(read: \");\n            }\n            if (offset == length) {\n                if (endReached_) {\n                \treturn -1;\n                }\n                if (load(0) == -1) {\n                    if (DEBUG_BUFFER) { \n                        System.out.println(\")read: -> -1\");\n                    }\n                    return -1;\n                }\n            }\n            final char c = buffer[offset++];\n\t        characterOffset_++;\n\t        columnNumber_++;\n\n            if (DEBUG_BUFFER) { \n                debugBufferIfNeeded(\")read: \", \" -> \" + c);\n            }\n            return c;\n        } // read():int\n\n        /** Prints the contents of the character buffer to standard out. */\n        private void debugBufferIfNeeded(final String prefix) {\n        \tdebugBufferIfNeeded(prefix, \"\");\n        }\n        /** Prints the contents of the character buffer to standard out. */\n        private void debugBufferIfNeeded(final String prefix, final String suffix) {\n            if (DEBUG_BUFFER) {\n                System.out.print(prefix);\n                System.out.print('[');\n                System.out.print(length);\n                System.out.print(' ');\n                System.out.print(offset);\n                if (length > 0) {\n                    System.out.print(\" \\\"\");\n                    for (int i = 0; i < length; i++) {\n                        if (i == offset) {\n                            System.out.print('^');\n                        }\n                        char c = buffer[i];\n                        switch (c) {\n                            case '\\r': {\n                                System.out.print(\"\\\\r\");\n                                break;\n                            }\n                            case '\\n': {\n                                System.out.print(\"\\\\n\");\n                                break;\n                            }\n                            case '\\t': {\n                                System.out.print(\"\\\\t\");\n                                break;\n                            }\n                            case '\"': {\n                                System.out.print(\"\\\\\\\"\");\n                                break;\n                            }\n                            default: {\n                                System.out.print(c);\n                            }\n                        }\n                    }\n                    if (offset == length) {\n                        System.out.print('^');\n                    }\n                    System.out.print('\"');\n                }\n                System.out.print(']');\n                System.out.print(suffix);\n                System.out.println();\n            }\n        } // printBuffer()\n\n\t\tprivate void setStream(final InputStreamReader inputStreamReader) {\n            stream_ = inputStreamReader;\n            offset = length = characterOffset_ = 0;\n            lineNumber_ = columnNumber_ = 1;\n            encoding = inputStreamReader.getEncoding();\n\t\t}\n\t\t\n\t\t/**\n\t\t * Goes back, cancelling the effect of the previous read() call.\n\t\t */\n\t\tprivate void rewind() {\n\t        offset--;\n\t        characterOffset_--;\n\t        columnNumber_--;\n\t\t}\n        private void rewind(int i) {\n            offset -= i;\n            characterOffset_ -= i;\n            columnNumber_ -= i;\n\t\t}\n\n\t\tprivate void incLine() {\n            lineNumber_++;\n            columnNumber_ = 1;\n\t\t}\n\n\t\tprivate void incLine(int nbLines) {\n            lineNumber_ += nbLines;\n            columnNumber_ = 1;\n\t\t}\n\n\t\tpublic int getLineNumber() {\n\t\t\treturn lineNumber_;\n\t\t}\n\n\t\tprivate void resetBuffer(final XMLStringBuffer buffer, final int lineNumber,\n\t\t\t\tfinal int columnNumber, final int characterOffset) {\n        \tlineNumber_ = lineNumber;\n        \tcolumnNumber_ = columnNumber;\n        \tthis.characterOffset_ = characterOffset;\n        \tthis.buffer = buffer.ch;\n        \tthis.offset = buffer.offset;\n        \tthis.length = buffer.length;\n\t\t}\n\n\t\tprivate int getColumnNumber() {\n\t\t\treturn columnNumber_;\n\t\t}\n\n\t\tprivate void restorePosition(int originalOffset,\n\t\t\t\tint originalColumnNumber, int originalCharacterOffset) {\n\t        this.offset = originalOffset;\n\t        this.columnNumber_ = originalColumnNumber;\n\t        this.characterOffset_ = originalCharacterOffset;\n\t\t}\n\n\t\tprivate int getCharacterOffset() {\n\t\t\treturn characterOffset_;\n\t\t}\n    } // class CurrentEntity\n\n    /**\n     * The primary HTML document scanner.\n     *\n     * @author Andy Clark\n     */\n    public class ContentScanner \n        implements Scanner {\n\n        //\n        // Data\n        //\n\n        // temp vars\n\n        /** A qualified name. */\n        private final QName fQName = new QName();\n\n        /** Attributes. */\n        private final XMLAttributesImpl fAttributes = new XMLAttributesImpl();\n\n        //\n        // Scanner methods\n        //\n\n        /** Scan. */\n        public boolean scan(boolean complete) throws IOException {\n            boolean next;\n            do {\n                try {\n                    next = false;\n                    switch (fScannerState) {\n                        case STATE_CONTENT: {\n                            fBeginLineNumber = fCurrentEntity.getLineNumber();\n                            fBeginColumnNumber = fCurrentEntity.getColumnNumber();\n                            fBeginCharacterOffset = fCurrentEntity.getCharacterOffset();\n                            int c = fCurrentEntity.read();\n                            if (c == '<') {\n                                setScannerState(STATE_MARKUP_BRACKET);\n                                next = true;\n                            }\n                            else if (c == '&') {\n                                scanEntityRef(fStringBuffer, true);\n                            }\n                            else if (c == -1) {\n                                throw new EOFException();\n                            }\n                            else {\n                            \tfCurrentEntity.rewind();\n                                scanCharacters();\n                            }\n                            break;\n                        }\n                        case STATE_MARKUP_BRACKET: {\n                            int c = fCurrentEntity.read();\n                            if (c == '!') {\n                                if (skip(\"--\", false)) {\n                                    scanComment();\n                                }\n                                else if (skip(\"[CDATA[\", false)) {\n                                    scanCDATA();\n                                }\n                                else if (skip(\"DOCTYPE\", false)) {\n                                    scanDoctype();\n                                }\n                                else {\n                                    if (fReportErrors) {\n                                        fErrorReporter.reportError(\"HTML1002\", null);\n                                    }\n                                    skipMarkup(true);\n                                }\n                            }\n                            else if (c == '?') {\n                                scanPI();\n                            }\n                            else if (c == '/') {\n                                scanEndElement();\n                            }\n                            else if (c == -1) {\n                                if (fReportErrors) {\n                                    fErrorReporter.reportError(\"HTML1003\", null);\n                                }\n                                if (fDocumentHandler != null && fElementCount >= fElementDepth) {\n                                    fStringBuffer.clear();\n                                    fStringBuffer.append('<');\n                                    fDocumentHandler.characters(fStringBuffer, null);\n                                }\n                                throw new EOFException();\n                            }\n                            else {\n                            \tfCurrentEntity.rewind();\n                                fElementCount++;\n                                fSingleBoolean[0] = false;\n                                final String ename = scanStartElement(fSingleBoolean);\n                                final String enameLC = ename == null ? null : ename.toLowerCase();\n                                fBeginLineNumber = fCurrentEntity.getLineNumber();\n                                fBeginColumnNumber = fCurrentEntity.getColumnNumber();\n                                fBeginCharacterOffset = fCurrentEntity.getCharacterOffset();\n                                if (\"script\".equals(enameLC)) {\n                                \tscanScriptContent();\n                                }\n                                else if (!fAllowSelfclosingTags && !fAllowSelfclosingIframe && \"iframe\".equals(enameLC)) {\n                                \tscanUntilEndTag(\"iframe\");\n                                }\n                                else if (!fParseNoScriptContent && \"noscript\".equals(enameLC)) {\n                                \tscanUntilEndTag(\"noscript\");\n                                }\n                                else if (!fParseNoFramesContent && \"noframes\".equals(enameLC)) {\n                                \tscanUntilEndTag(\"noframes\");\n                                }\n                                else if (ename != null && !fSingleBoolean[0] \n                                    && HTMLElements.getElement(enameLC).isSpecial() \n                                    && (!ename.equalsIgnoreCase(\"TITLE\") || isEnded(enameLC))) {\n                                    setScanner(fSpecialScanner.setElementName(ename));\n                                    setScannerState(STATE_CONTENT);\n                                    return true;\n                                }\n                            }\n                            setScannerState(STATE_CONTENT);\n                            break;\n                        }\n                        case STATE_START_DOCUMENT: {\n                            if (fDocumentHandler != null && fElementCount >= fElementDepth) {\n                                if (DEBUG_CALLBACKS) {\n                                    System.out.println(\"startDocument()\");\n                                }\n                                XMLLocator locator = HTMLScanner.this;\n                                String encoding = fIANAEncoding;\n                                Augmentations augs = locationAugs();\n                                NamespaceContext nscontext = new NamespaceSupport();\n                                XercesBridge.getInstance().XMLDocumentHandler_startDocument(fDocumentHandler, locator, encoding, nscontext, augs);\n                            }\n                            if (fInsertDoctype && fDocumentHandler != null) {\n                                String root = HTMLElements.getElement(HTMLElements.HTML).name;\n                                root = modifyName(root, fNamesElems);\n                                String pubid = fDoctypePubid;\n                                String sysid = fDoctypeSysid;\n                                fDocumentHandler.doctypeDecl(root, pubid, sysid,\n                                                             synthesizedAugs());\n                            }\n                            setScannerState(STATE_CONTENT);\n                            break;\n                        }\n                        case STATE_END_DOCUMENT: {\n                            if (fDocumentHandler != null && fElementCount >= fElementDepth && complete) {\n                                if (DEBUG_CALLBACKS) {\n                                    System.out.println(\"endDocument()\");\n                                }\n                                fEndLineNumber = fCurrentEntity.getLineNumber();\n                                fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                                fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                                fDocumentHandler.endDocument(locationAugs());\n                            }\n                            return false;\n                        }\n                        default: {\n                            throw new RuntimeException(\"unknown scanner state: \"+fScannerState);\n                        }\n                    }\n                }\n                catch (EOFException e) {\n                    if (fCurrentEntityStack.empty()) {\n                        setScannerState(STATE_END_DOCUMENT);\n                    }\n                    else {\n                        fCurrentEntity = (CurrentEntity)fCurrentEntityStack.pop();\n                    }\n                    next = true;\n                }\n            } while (next || complete);\n            return true;\n        } // scan(boolean):boolean\n\n        /**\n         * Scans the content of <noscript>: it doesn't get parsed but is considered as plain text\n         * when feature {@link HTMLScanner#PARSE_NOSCRIPT_CONTENT} is set to false.\n         * @param the tag for which content is scanned (one of \"noscript\", \"noframes\", \"iframe\")\n         * @throws IOException\n         */\n        private void scanUntilEndTag(final String tagName) throws IOException {\n        \tfinal XMLStringBuffer buffer = new XMLStringBuffer();\n        \tfinal String end = \"/\" + tagName;\n        \tfinal int lengthToScan = tagName.length() + 2;\n        \t\n            while (true) {\n                int c = fCurrentEntity.read();\n                if (c == -1) {\n                    break;\n                }\n                if (c == '<') {\n                \tfinal String next = nextContent(lengthToScan) + \" \";\n                \tif (next.length() >= lengthToScan && end.equalsIgnoreCase(next.substring(0, end.length()))\n            \t\t\t&& ('>' == next.charAt(lengthToScan - 1) || Character.isWhitespace(next.charAt(lengthToScan - 1)))) {\n                \t\tfCurrentEntity.rewind();\n\t                    break;\n                \t}\n            \t}\n            \tif (c == '\\r' || c == '\\n') {\n            \t\tfCurrentEntity.rewind();\n                    int newlines = skipNewlines();\n                    for (int i = 0; i < newlines; i++) {\n                        buffer.append('\\n');\n                    }\n                }\n                else {\n                    appendChar(buffer, c);\n                }\n            }\n            if (buffer.length > 0 && fDocumentHandler != null) {\n                fEndLineNumber = fCurrentEntity.getLineNumber();\n                fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                fDocumentHandler.characters(buffer, locationAugs());\n            }\n        }\n        \n        private void scanScriptContent() throws IOException {\n\n        \tfinal XMLStringBuffer buffer = new XMLStringBuffer();\n            boolean waitForEndComment = false;\n            while (true) {\n                int c = fCurrentEntity.read();\n                if (c == -1) {\n                    break;\n                }\n                else if (c == '-' && endsWith(buffer, \"<!-\"))\n            \t{\n            \t\twaitForEndComment = endCommentAvailable();\n            \t}\n                else if (!waitForEndComment && c == '<') {\n                \tfinal String next = nextContent(8) + \" \";\n                \tif (next.length() >= 8 && \"/script\".equalsIgnoreCase(next.substring(0, 7))\n                \t\t\t&& ('>' == next.charAt(7) || Character.isWhitespace(next.charAt(7)))) {\n                \t\tfCurrentEntity.rewind();\n                        break;\n                \t}\n                }\n                else if (c == '>' && endsWith(buffer, \"--\"))  {\n               \t\twaitForEndComment = false;\n                }\n\n                if (c == '\\r' || c == '\\n') {\n                \tfCurrentEntity.rewind();\n                    int newlines = skipNewlines();\n                    for (int i = 0; i < newlines; i++) {\n                        buffer.append('\\n');\n                    }\n                }\n                else {\n                    appendChar(buffer, c);\n                }\n            }\n\n            if (fScriptStripCommentDelims) {\n            \treduceToContent(buffer, \"<!--\", \"-->\");\n            }\n            if (fScriptStripCDATADelims) {\n            \treduceToContent(buffer, \"<![CDATA[\", \"]]>\");\n            }\n\n            if (buffer.length > 0 && fDocumentHandler != null && fElementCount >= fElementDepth) {\n                if (DEBUG_CALLBACKS) {\n                    System.out.println(\"characters(\"+buffer+\")\");\n                }\n                fEndLineNumber = fCurrentEntity.getLineNumber();\n                fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                fDocumentHandler.characters(buffer, locationAugs());\n            }\n        }\n\n        \n        /**\n         * Reads the next characters WITHOUT impacting the buffer content\n         * up to current offset.\n         * @param len the number of characters to read\n         * @return the read string (length may be smaller if EOF is encountered)\n         */\n        protected String nextContent(int len) throws IOException {\n            final int originalOffset = fCurrentEntity.offset;\n            final int originalColumnNumber = fCurrentEntity.getColumnNumber();\n            final int originalCharacterOffset = fCurrentEntity.getCharacterOffset();\n            \n            char[] buff = new char[len];\n            int nbRead = 0;\n            for (nbRead=0; nbRead<len; ++nbRead) {\n    \t\t\t// read() should not clear the buffer\n    \t        if (fCurrentEntity.offset == fCurrentEntity.length) {\n    \t        \tif (fCurrentEntity.length == fCurrentEntity.buffer.length) {\n    \t        \t\tfCurrentEntity.load(fCurrentEntity.buffer.length);\n    \t        \t}\n    \t        \telse { // everything was already loaded\n    \t        \t\tbreak;\n    \t        \t}\n    \t        }\n    \t        \n    \t        int c = fCurrentEntity.read();\n    \t        if (c == -1) {\n    \t        \tbreak;\n    \t        }\n   \t        \tbuff[nbRead] = (char) c;\n    \t\t}\n\t        fCurrentEntity.restorePosition(originalOffset, originalColumnNumber, originalCharacterOffset);\n\t        return new String(buff, 0, nbRead);\n    \t}\n\n\t\t//\n        // Protected methods\n        //\n\n        /** Scans characters. */\n        protected void scanCharacters() throws IOException {\n            if (DEBUG_BUFFER) { \n                fCurrentEntity.debugBufferIfNeeded(\"(scanCharacters: \");\n            }\n            fStringBuffer.clear();  \n            while(true) { \n               int newlines = skipNewlines();\n               if (newlines == 0 && fCurrentEntity.offset == fCurrentEntity.length) {\n                   if (DEBUG_BUFFER) { \n                       fCurrentEntity.debugBufferIfNeeded(\")scanCharacters: \");\n                   }\n                   break;\n               }\n               char c;\n               int offset = fCurrentEntity.offset - newlines;\n               for (int i = offset; i < fCurrentEntity.offset; i++) {\n                   fCurrentEntity.buffer[i] = '\\n';\n               }\n               while (fCurrentEntity.hasNext()) {\n                   c = fCurrentEntity.getNextChar();\n                   if (c == '<' || c == '&' || c == '\\n' || c == '\\r') {\n                    \tfCurrentEntity.rewind();\n                        break;\n                    }\n                }\n                if (fCurrentEntity.offset > offset && \n                    fDocumentHandler != null && fElementCount >= fElementDepth) {\n                    if (DEBUG_CALLBACKS) {\n                    \tfinal XMLString xmlString = new XMLString(fCurrentEntity.buffer, offset, fCurrentEntity.offset - offset);\n                        System.out.println(\"characters(\" + xmlString + \")\");\n                    }\n                    fEndLineNumber = fCurrentEntity.getLineNumber();\n                    fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                    fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                    fStringBuffer.append(fCurrentEntity.buffer, offset, fCurrentEntity.offset - offset);\n                }\n                if (DEBUG_BUFFER) { \n                    fCurrentEntity.debugBufferIfNeeded(\")scanCharacters: \");\n                }\n\n                boolean hasNext = fCurrentEntity.offset  < fCurrentEntity.buffer.length;\n                int next = hasNext ? fCurrentEntity.getCurrentChar() : -1; \n                \n                if(next == '&' || next == '<' || next == -1) {\n                     break;\n                 }\n\n            } //end while\n\n            if(fStringBuffer.length != 0) {\n                fDocumentHandler.characters(fStringBuffer, locationAugs());\n            }\n\n        } // scanCharacters()\n\n        /** Scans a CDATA section. */\n        protected void scanCDATA() throws IOException {\n            if (DEBUG_BUFFER) { \n                fCurrentEntity.debugBufferIfNeeded(\"(scanCDATA: \");\n            }\n            fStringBuffer.clear();\n            if (fCDATASections) {\n                if (fDocumentHandler != null && fElementCount >= fElementDepth) {\n                    fEndLineNumber = fCurrentEntity.getLineNumber();\n                    fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                    fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                    if (DEBUG_CALLBACKS) {\n                        System.out.println(\"startCDATA()\");\n                    }\n                    fDocumentHandler.startCDATA(locationAugs());\n                }\n            }\n            else {\n                fStringBuffer.append(\"[CDATA[\");\n            }\n            boolean eof = scanMarkupContent(fStringBuffer, ']');\n            if (!fCDATASections) {\n                fStringBuffer.append(\"]]\");\n            }\n            if (fDocumentHandler != null && fElementCount >= fElementDepth) {\n                fEndLineNumber = fCurrentEntity.getLineNumber();\n                fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                if (fCDATASections) {\n                    if (DEBUG_CALLBACKS) {\n                        System.out.println(\"characters(\"+fStringBuffer+\")\");\n                    }\n                    fDocumentHandler.characters(fStringBuffer, locationAugs());\n                    if (DEBUG_CALLBACKS) {\n                        System.out.println(\"endCDATA()\");\n                    }\n                    fDocumentHandler.endCDATA(locationAugs());\n                }\n                else {\n                    if (DEBUG_CALLBACKS) {\n                        System.out.println(\"comment(\"+fStringBuffer+\")\");\n                    }\n                    fDocumentHandler.comment(fStringBuffer, locationAugs());\n                }\n            }\n            if (DEBUG_BUFFER) { \n                fCurrentEntity.debugBufferIfNeeded(\")scanCDATA: \");\n            }\n            if (eof) {\n                throw new EOFException();\n            }\n        } // scanCDATA()\n        \n        /** Scans a comment. */\n        protected void scanComment() throws IOException {\n            if (DEBUG_BUFFER) { \n                fCurrentEntity.debugBufferIfNeeded(\"(scanComment: \");\n            }\n            fEndLineNumber = fCurrentEntity.getLineNumber();\n            fEndColumnNumber = fCurrentEntity.getColumnNumber();\n            fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n        \tXMLStringBuffer buffer = new XMLStringBuffer();\n            boolean eof = scanMarkupContent(buffer, '-');\n            // no --> found, comment with end only with >\n            if (eof) {\n            \tfCurrentEntity.resetBuffer(buffer, fEndLineNumber, fEndColumnNumber, fEndCharacterOffset);\n            \tbuffer = new XMLStringBuffer(); // take a new one to avoid interactions\n            \twhile (true) {\n            \t\tint c = fCurrentEntity.read();\n                    if (c == -1) {\n                        if (fReportErrors) {\n                            fErrorReporter.reportError(\"HTML1007\", null);\n                        }\n                        eof = true;\n                        break;\n                    }\n                    else if (c != '>') {\n                        appendChar(buffer, c);\n                        continue;\n            \t\t}\n            \t\telse if (c == '\\n' || c == '\\r') {\n            \t\t\tfCurrentEntity.rewind();\n\t                    int newlines = skipNewlines();\n\t                    for (int i = 0; i < newlines; i++) {\n\t                    \tbuffer.append('\\n');\n\t                    }\n\t                    continue;\n\t                }\n                    eof = false;\n            \t\tbreak;\n            \t}\n            }\n            if (fDocumentHandler != null && fElementCount >= fElementDepth) {\n                if (DEBUG_CALLBACKS) {\n                    System.out.println(\"comment(\" + buffer + \")\");\n                }\n                fEndLineNumber = fCurrentEntity.getLineNumber();\n                fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                fDocumentHandler.comment(buffer, locationAugs());\n            }\n            if (DEBUG_BUFFER) { \n                fCurrentEntity.debugBufferIfNeeded(\")scanComment: \");\n            }\n            if (eof) {\n                throw new EOFException();\n            }\n        } // scanComment()\n\n        /** Scans markup content. */\n        protected boolean scanMarkupContent(XMLStringBuffer buffer, \n                                            char cend) throws IOException {\n            int c = -1;\n            OUTER: while (true) {\n                c = fCurrentEntity.read();\n                if (c == cend) {\n                    int count = 1;\n                    while (true) {\n                        c = fCurrentEntity.read();\n                        if (c == cend) {\n                            count++;\n                            continue;\n                        }\n                        break;\n                    }\n                    if (c == -1) {\n                        if (fReportErrors) {\n                            fErrorReporter.reportError(\"HTML1007\", null);\n                        }\n                        break OUTER;\n                    }\n                    if (count < 2) {\n                        buffer.append(cend);\n                        //if (c != -1) {\n                        fCurrentEntity.rewind();\n                        //}\n                        continue;\n                    }\n                    if (c != '>') {\n                        for (int i = 0; i < count; i++) {\n                            buffer.append(cend);\n                        }\n                        fCurrentEntity.rewind();\n                        continue;\n                    }\n                    for (int i = 0; i < count - 2; i++) {\n                        buffer.append(cend);\n                    }\n                    break;\n                }\n                else if (c == '\\n' || c == '\\r') {\n                \tfCurrentEntity.rewind();\n                    int newlines = skipNewlines();\n                    for (int i = 0; i < newlines; i++) {\n                        buffer.append('\\n');\n                    }\n                    continue;\n                }\n                else if (c == -1) {\n                    if (fReportErrors) {\n                        fErrorReporter.reportError(\"HTML1007\", null);\n                    }\n                    break;\n                }\n                appendChar(buffer, c);\n            }\n            return c == -1;\n        } // scanMarkupContent(XMLStringBuffer,char):boolean\n\n        /** Scans a processing instruction. */\n        protected void scanPI() throws IOException {\n            if (DEBUG_BUFFER) { \n                fCurrentEntity.debugBufferIfNeeded(\"(scanPI: \");\n            }\n            if (fReportErrors) {\n                fErrorReporter.reportWarning(\"HTML1008\", null);\n            }\n\n            // scan processing instruction\n            String target = scanName(true);\n            if (target != null && !target.equalsIgnoreCase(\"xml\")) {\n                while (true) {\n                    int c = fCurrentEntity.read();\n                    if (c == '\\r' || c == '\\n') {\n                        if (c == '\\r') {\n                            c = fCurrentEntity.read();\n                            if (c != '\\n') {\n                                fCurrentEntity.offset--;\n                                fCurrentEntity.characterOffset_--;\n                            }\n                        }\n                        fCurrentEntity.incLine();\n                        continue;\n                    }\n                    if (c == -1) {\n                        break;\n                    }\n                    if (c != ' ' && c != '\\t') {\n                    \tfCurrentEntity.rewind();\n                        break;\n                    }\n                }\n                fStringBuffer.clear();\n                while (true) {\n                    int c = fCurrentEntity.read();\n                    if (c == '?' || c == '/') {\n                        char c0 = (char)c;\n                        c = fCurrentEntity.read();\n                        if (c == '>') {\n                            break;\n                        }\n                        fStringBuffer.append(c0);\n                        fCurrentEntity.rewind();\n                        continue;\n                    }\n                    else if (c == '\\r' || c == '\\n') {\n                        fStringBuffer.append('\\n');\n                        if (c == '\\r') {\n                            c = fCurrentEntity.read();\n                            if (c != '\\n') {\n                                fCurrentEntity.offset--;\n                                fCurrentEntity.characterOffset_--;\n                            }\n                        }\n                        fCurrentEntity.incLine();\n                        continue;\n                    }\n                    else if (c == -1) {\n                        break;\n                    }\n                    else {\n                        appendChar(fStringBuffer, c);\n                    }\n                }\n                XMLString data = fStringBuffer;\n                if (fDocumentHandler != null) {\n                    fEndLineNumber = fCurrentEntity.getLineNumber();\n                    fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                    fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                    fDocumentHandler.processingInstruction(target, data, locationAugs());\n                }\n            }\n\n            // scan xml/text declaration\n            else {\n                int beginLineNumber = fBeginLineNumber;\n                int beginColumnNumber = fBeginColumnNumber;\n                int beginCharacterOffset = fBeginCharacterOffset;\n                fAttributes.removeAllAttributes();\n                int aindex = 0;\n                while (scanPseudoAttribute(fAttributes)) {\n                \t// if we haven't scanned a value, remove the entry as values have special signification\n                \tif (fAttributes.getValue(aindex).length() == 0) {\n                \t\tfAttributes.removeAttributeAt(aindex); \n                \t}\n                \telse {\n\t                    fAttributes.getName(aindex,fQName);\n\t                    fQName.rawname = fQName.rawname.toLowerCase();\n\t                    fAttributes.setName(aindex,fQName);\n\t                    aindex++;\n                \t}\n                }\n                if (fDocumentHandler != null) {\n                    String version = fAttributes.getValue(\"version\");\n                    String encoding = fAttributes.getValue(\"encoding\");\n                    String standalone = fAttributes.getValue(\"standalone\");\n\n                    // if the encoding is successfully changed, the stream will be processed again\n                    // with the right encoding an we will come here again but without need to change the encoding\n                    final boolean xmlDeclNow = fIgnoreSpecifiedCharset || !changeEncoding(encoding);\n                    if (xmlDeclNow) {\n\t                    fBeginLineNumber = beginLineNumber;\n\t                    fBeginColumnNumber = beginColumnNumber;\n\t                    fBeginCharacterOffset = beginCharacterOffset;\n\t                    fEndLineNumber = fCurrentEntity.getLineNumber();\n\t                    fEndColumnNumber = fCurrentEntity.getColumnNumber();\n\t                    fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n\t                    fDocumentHandler.xmlDecl(version, encoding, standalone,\n\t                                             locationAugs());\n                    }\n                }\n            }\n\n            if (DEBUG_BUFFER) { \n                fCurrentEntity.debugBufferIfNeeded(\")scanPI: \");\n            }\n        } // scanPI()\n\n        /** \n         * Scans a start element. \n         *\n         * @param empty Is used for a second return value to indicate whether\n         *              the start element tag is empty (e.g. \"/&gt;\").\n         */\n        protected String scanStartElement(boolean[] empty) throws IOException {\n            String ename = scanName(true);\n            int length = ename != null ? ename.length() : 0;\n            int c = length > 0 ? ename.charAt(0) : -1;\n            if (length == 0 || !((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))) {\n                if (fReportErrors) {\n                    fErrorReporter.reportError(\"HTML1009\", null);\n                }\n                if (fDocumentHandler != null && fElementCount >= fElementDepth) {\n                    fStringBuffer.clear();\n                    fStringBuffer.append('<');\n                    if (length > 0) {\n                        fStringBuffer.append(ename);\n                    }\n                    fDocumentHandler.characters(fStringBuffer, null);\n                }\n                return null;\n            }\n            ename = modifyName(ename, fNamesElems);\n            fAttributes.removeAllAttributes();\n            int beginLineNumber = fBeginLineNumber;\n            int beginColumnNumber = fBeginColumnNumber;\n            int beginCharacterOffset = fBeginCharacterOffset;\n            while (scanAttribute(fAttributes, empty)) {\n                // do nothing\n            }\n            fBeginLineNumber = beginLineNumber;\n            fBeginColumnNumber = beginColumnNumber;\n            fBeginCharacterOffset = beginCharacterOffset;\n            if (fByteStream != null && fElementDepth == -1) {\n                if (ename.equalsIgnoreCase(\"META\") && !fIgnoreSpecifiedCharset) {\n                    if (DEBUG_CHARSET) {\n                        System.out.println(\"+++ <META>\");\n                    }\n                    String httpEquiv = getValue(fAttributes, \"http-equiv\");\n                    if (httpEquiv != null && httpEquiv.equalsIgnoreCase(\"content-type\")) {\n                        if (DEBUG_CHARSET) {\n                            System.out.println(\"+++ @content-type: \\\"\"+httpEquiv+'\"');\n                        }\n                        String content = getValue(fAttributes, \"content\");\n                        if (content != null) {\n                        \tcontent = removeSpaces(content);\n                            int index1 = content.toLowerCase().indexOf(\"charset=\");\n                            if (index1 != -1) {\n                                final int index2 = content.indexOf(';', index1);\n                                final String charset = index2 != -1 ? content.substring(index1+8, index2) : content.substring(index1+8);\n                                changeEncoding(charset);\n                            }\n                        }\n                    }\n                    else {\n                        final String metaCharset = getValue(fAttributes, \"charset\");\n                        if (metaCharset != null) {\n                            changeEncoding(metaCharset);\n                        }\n                    }\n                }\n                else if (ename.equalsIgnoreCase(\"BODY\")) {\n                    fByteStream.clear();\n                    fByteStream = null;\n                }\n                else {\n                     HTMLElements.Element element = HTMLElements.getElement(ename);\n                     if (element.parent != null && element.parent.length > 0) {\n                         if (element.parent[0].code == HTMLElements.BODY) {\n                             fByteStream.clear();\n                             fByteStream = null;\n                         }\n                     }\n                }\n            }\n            if (fDocumentHandler != null && fElementCount >= fElementDepth) {\n                fQName.setValues(null, ename, ename, null);\n                if (DEBUG_CALLBACKS) {\n                    System.out.println(\"startElement(\"+fQName+','+fAttributes+\")\");\n                }\n                fEndLineNumber = fCurrentEntity.getLineNumber();\n                fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                if (empty[0]) {\n                    fDocumentHandler.emptyElement(fQName, fAttributes, locationAugs());\n                }\n                else {\n                    fDocumentHandler.startElement(fQName, fAttributes, locationAugs());\n                }\n            }\n            return ename;\n        } // scanStartElement():ename\n\n        /**\n         * Removes all spaces for the string (remember: JDK 1.3!)\n         */\n        private String removeSpaces(final String content) {\n        \tStringBuffer sb = null;\n        \tfor (int i=content.length()-1; i>=0; --i) {\n        \t\tif (Character.isWhitespace(content.charAt(i))) {\n        \t\t\tif (sb == null) {\n        \t\t\t\tsb = new StringBuffer(content);\n        \t\t\t}\n        \t\t\tsb.deleteCharAt(i);\n        \t\t}\n        \t}\n\t\t\treturn (sb == null) ? content : sb.toString();\n\t\t}\n\n\t\t/**\n         * Tries to change the encoding used to read the input stream to the specified one\n         * @param charset the charset that should be used\n         * @return <code>true</code> when the encoding has been changed\n         */\n\t\tprivate boolean changeEncoding(String charset) {\n\t\t\tif (charset == null || fByteStream == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcharset = charset.trim();\n\t\t\tboolean encodingChanged = false;\n\t\t\ttry {\n\t\t\t    String ianaEncoding = charset;\n\t\t\t    String javaEncoding = EncodingMap.getIANA2JavaMapping(ianaEncoding.toUpperCase(Locale.ENGLISH));\n\t\t\t    if (DEBUG_CHARSET) {\n\t\t\t        System.out.println(\"+++ ianaEncoding: \"+ianaEncoding);\n\t\t\t        System.out.println(\"+++ javaEncoding: \"+javaEncoding);\n\t\t\t    }\n\t\t\t    if (javaEncoding == null) {\n\t\t\t        javaEncoding = ianaEncoding;\n\t\t\t        if (fReportErrors) {\n\t\t\t            fErrorReporter.reportError(\"HTML1001\", new Object[]{ianaEncoding});\n\t\t\t        }\n\t\t\t    }\n\t\t\t    // patch: Marc Guillemot\n\t\t\t    if (!javaEncoding.equals(fJavaEncoding)) { \n\t\t\t      \tif (!isEncodingCompatible(javaEncoding, fJavaEncoding)) {\n\t\t\t            if (fReportErrors) {\n\t\t\t                fErrorReporter.reportError(\"HTML1015\", new Object[]{javaEncoding,fJavaEncoding});\n\t\t\t            }\n\t\t\t     \t}\n\t\t\t  \t\t// change the charset\n\t\t\t     \telse {\n\t\t\t            fIso8859Encoding = ianaEncoding == null \n\t\t\t                    || ianaEncoding.toUpperCase(Locale.ENGLISH).startsWith(\"ISO-8859\")\n\t\t\t                    || ianaEncoding.equalsIgnoreCase(fDefaultIANAEncoding);\n\t\t\t            fJavaEncoding = javaEncoding;\n\t\t\t            fCurrentEntity.setStream(new InputStreamReader(fByteStream, javaEncoding));\n\t\t\t            fByteStream.playback();\n\t\t\t            fElementDepth = fElementCount;\n\t\t\t            fElementCount = 0;\n\t                    encodingChanged = true;\n\t\t\t     \t}\n\t\t\t     }\n\t\t\t}\n\t\t\tcatch (UnsupportedEncodingException e) {\n\t\t\t    if (fReportErrors) {\n\t\t\t        fErrorReporter.reportError(\"HTML1010\", new Object[]{charset});\n\t\t\t    }\n\t\t\t    // NOTE: If the encoding change doesn't work, \n\t\t\t    //       then there's no point in continuing to \n\t\t\t    //       buffer the input stream.\n\t\t\t    fByteStream.clear();\n\t\t\t    fByteStream = null;\n\t\t\t}\n\t\t\treturn encodingChanged;\n\t\t}\n\n        /** \n         * Scans a real attribute. \n         *\n         * @param attributes The list of attributes.\n         * @param empty      Is used for a second return value to indicate \n         *                   whether the start element tag is empty \n         *                   (e.g. \"/&gt;\").\n         */\n        protected boolean scanAttribute(XMLAttributesImpl attributes,\n                                        boolean[] empty)\n            throws IOException {\n            return scanAttribute(attributes,empty,'/');\n        } // scanAttribute(XMLAttributesImpl,boolean[]):boolean\n\n        /** \n         * Scans a pseudo attribute. \n         *\n         * @param attributes The list of attributes.\n         */\n        protected boolean scanPseudoAttribute(XMLAttributesImpl attributes)\n            throws IOException {\n            return scanAttribute(attributes,fSingleBoolean,'?');\n        } // scanPseudoAttribute(XMLAttributesImpl):boolean\n\n        /** \n         * Scans an attribute, pseudo or real. \n         *\n         * @param attributes The list of attributes.\n         * @param empty      Is used for a second return value to indicate \n         *                   whether the start element tag is empty \n         *                   (e.g. \"/&gt;\").\n         * @param endc       The end character that appears before the\n         *                   closing angle bracket ('>').\n         */\n        protected boolean scanAttribute(XMLAttributesImpl attributes,\n                                        boolean[] empty, char endc)\n            throws IOException {\n            boolean skippedSpaces = skipSpaces();\n            fBeginLineNumber = fCurrentEntity.getLineNumber();\n            fBeginColumnNumber = fCurrentEntity.getColumnNumber();\n            fBeginCharacterOffset = fCurrentEntity.getCharacterOffset();\n            int c = fCurrentEntity.read();\n            if (c == -1) {\n                if (fReportErrors) {\n                    fErrorReporter.reportError(\"HTML1007\", null);\n                }\n                return false;\n            }\n            else if (c == '>') {\n                return false;\n            }\n            else if(c == '<') {\n              fCurrentEntity.rewind();\n              if(fReportErrors) {\n                fErrorReporter.reportError(\"HTML2001\", null);\n              }\n              return false;\n            }\n            fCurrentEntity.rewind();\n            String aname = scanName(false);\n            if(aname == null) {\n              empty[0] = skipMarkup(false);\n              return false;\n            }\n            if (!skippedSpaces && fReportErrors) {\n                fErrorReporter.reportError(\"HTML1013\", new Object[] { aname });\n            }\n            aname = modifyName(aname, fNamesAttrs);\n            skipSpaces();\n            c = fCurrentEntity.read();\n            if (c == -1) {\n                if (fReportErrors) {\n                    fErrorReporter.reportError(\"HTML1007\", null);\n                }\n                throw new EOFException();\n            }\n            if (c == '/' || c == '>') {\n                fQName.setValues(null, aname, aname, null);\n                attributes.addAttribute(fQName, \"CDATA\", \"\");\n                attributes.setSpecified(attributes.getLength()-1, true);\n                if (fAugmentations) {\n                    addLocationItem(attributes, attributes.getLength() - 1);\n                }\n                if (c == '/') {\n                \tfCurrentEntity.rewind();\n                    empty[0] = skipMarkup(false);\n                }\n                return false;\n            }\n            /***\n            // REVISIT: [Q] Why is this still here? -Ac\n            if (c == '/' || c == '>') {\n                if (c == '/') {\n                    fCurrentEntity.offset--;\n                    fCurrentEntity.columnNumber--;\n                    empty[0] = skipMarkup(false);\n                }\n                fQName.setValues(null, aname, aname, null);\n                attributes.addAttribute(fQName, \"CDATA\", \"\");\n                attributes.setSpecified(attributes.getLength()-1, true);\n                if (fAugmentations) {\n                    addLocationItem(attributes, attributes.getLength() - 1);\n                }\n                return false;\n            }\n            /***/\n            if (c == '=') {\n                skipSpaces();\n                c = fCurrentEntity.read();\n                if (c == -1) {\n                    if (fReportErrors) {\n                        fErrorReporter.reportError(\"HTML1007\", null);\n                    }\n                    throw new EOFException();\n                }\n                // Xiaowei/Ac: Fix for <a href=/cgi-bin/myscript>...</a>\n                if (c == '>') {\n                    fQName.setValues(null, aname, aname, null);\n                    attributes.addAttribute(fQName, \"CDATA\", \"\");\n                    attributes.setSpecified(attributes.getLength()-1, true);\n                    if (fAugmentations) {\n                        addLocationItem(attributes, attributes.getLength() - 1);\n                    }\n                    return false;\n                }\n                fStringBuffer.clear();\n                fNonNormAttr.clear();\n                if (c != '\\'' && c != '\"') {\n                \tfCurrentEntity.rewind();\n                    while (true) {\n                        c = fCurrentEntity.read();\n                        // Xiaowei/Ac: Fix for <a href=/broken/>...</a>\n                        if (Character.isWhitespace((char)c) || c == '>') {\n                            //fCharOffset--;\n                        \tfCurrentEntity.rewind();\n                            break;\n                        }\n                        if (c == -1) {\n                            if (fReportErrors) {\n                                fErrorReporter.reportError(\"HTML1007\", null);\n                            }\n                            throw new EOFException();\n                        }\n                        if (c == '&') {\n                            int ce = scanEntityRef(fStringBuffer2, false);\n                            if (ce != -1) {\n                                appendChar(fStringBuffer, ce);\n                            }\n                            else {\n                                fStringBuffer.append(fStringBuffer2);\n                            }\n                            fNonNormAttr.append(fStringBuffer2);\n                        }\n                        else {\n                            appendChar(fStringBuffer, c);\n                            appendChar(fNonNormAttr, c);\n                        }\n                    }\n                    fQName.setValues(null, aname, aname, null);\n                    String avalue = fStringBuffer.toString();\n                    attributes.addAttribute(fQName, \"CDATA\", avalue);\n\n                    int lastattr = attributes.getLength()-1;\n                    attributes.setSpecified(lastattr, true);\n                    attributes.setNonNormalizedValue(lastattr, fNonNormAttr.toString());\n                    if (fAugmentations) {\n                        addLocationItem(attributes, attributes.getLength() - 1);\n                    }\n                    return true;\n                }\n                char quote = (char)c;\n                boolean isStart = true;\n                boolean prevSpace = false;\n                do {\n                \tboolean acceptSpace = !fNormalizeAttributes || (!isStart && !prevSpace);\n                    c = fCurrentEntity.read();\n                    if (c == -1) {\n                        if (fReportErrors) {\n                            fErrorReporter.reportError(\"HTML1007\", null);\n                        }\n                        break;\n//                        throw new EOFException();\n                    }\n                    if (c == '&') {\n                    \tisStart = false;\n                        int ce = scanEntityRef(fStringBuffer2, false);\n                        if (ce != -1) {\n                            appendChar(fStringBuffer, ce);\n                        }\n                        else {\n                            fStringBuffer.append(fStringBuffer2);\n                        }\n                        fNonNormAttr.append(fStringBuffer2);\n                    }\n                    else if (c == ' ' || c == '\\t') {\n                    \tif (acceptSpace) {\n\t                        fStringBuffer.append(fNormalizeAttributes ? ' ' : (char)c);\n\t                    }\n                        fNonNormAttr.append((char)c);\n                    }\n                    else if (c == '\\r' || c == '\\n') {\n                        if (c == '\\r') {\n                            int c2 = fCurrentEntity.read();\n                            if (c2 == '\\n') {\n                                fNonNormAttr.append('\\r');\n                                c = c2;\n                            }\n                            else if (c2 != -1) {\n                            \tfCurrentEntity.rewind();\n                            }\n                        }\n                        if (acceptSpace) {\n\t                        fStringBuffer.append(fNormalizeAttributes ? ' ' : '\\n');\n\t                    }\n                        fCurrentEntity.incLine();\n                        fNonNormAttr.append((char)c);\n                    }\n                    else if (c != quote) {\n                    \tisStart = false;\n                        appendChar(fStringBuffer, c);\n                        appendChar(fNonNormAttr, c);\n                    }\n                    prevSpace = c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n                    isStart = isStart && prevSpace;\n                } while (c != quote);\n                \n                if (fNormalizeAttributes && fStringBuffer.length > 0) {\n                \t// trailing whitespace already normalized to single space\n       \t        \tif (fStringBuffer.ch[fStringBuffer.length - 1] == ' ') {\n           \t    \t\tfStringBuffer.length--;\n               \t\t}\n    \t        }\n\n                fQName.setValues(null, aname, aname, null);\n                String avalue = fStringBuffer.toString();\n                attributes.addAttribute(fQName, \"CDATA\", avalue);\n\n                int lastattr = attributes.getLength()-1;\n                attributes.setSpecified(lastattr, true);\n                attributes.setNonNormalizedValue(lastattr, fNonNormAttr.toString());\n                if (fAugmentations) {\n                    addLocationItem(attributes, attributes.getLength() - 1);\n                }\n            }\n            else {\n                fQName.setValues(null, aname, aname, null);\n                attributes.addAttribute(fQName, \"CDATA\", \"\");\n                attributes.setSpecified(attributes.getLength()-1, true);\n                fCurrentEntity.rewind();\n                if (fAugmentations) {\n                    addLocationItem(attributes, attributes.getLength() - 1);\n                }\n            }\n            return true;\n        } // scanAttribute(XMLAttributesImpl):boolean\n\n        /** Adds location augmentations to the specified attribute. */\n        protected void addLocationItem(XMLAttributes attributes, int index) {\n            fEndLineNumber = fCurrentEntity.getLineNumber();\n            fEndColumnNumber = fCurrentEntity.getColumnNumber();\n            fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n            LocationItem locationItem = new LocationItem();\n            locationItem.setValues(fBeginLineNumber, fBeginColumnNumber,\n                                   fBeginCharacterOffset, fEndLineNumber,\n                                   fEndColumnNumber, fEndCharacterOffset);\n            Augmentations augs = attributes.getAugmentations(index);\n            augs.putItem(AUGMENTATIONS, locationItem);\n        } // addLocationItem(XMLAttributes,int)\n\n        /** Scans an end element. */\n        protected void scanEndElement() throws IOException {\n            String ename = scanName(true);\n            if (fReportErrors && ename == null) {\n                fErrorReporter.reportError(\"HTML1012\", null);\n            }\n            skipMarkup(false);\n            if (ename != null) {\n                ename = modifyName(ename, fNamesElems);\n                if (fDocumentHandler != null && fElementCount >= fElementDepth) {\n                    fQName.setValues(null, ename, ename, null);\n                    if (DEBUG_CALLBACKS) {\n                        System.out.println(\"endElement(\"+fQName+\")\");\n                    }\n                    fEndLineNumber = fCurrentEntity.getLineNumber();\n                    fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                    fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                    fDocumentHandler.endElement(fQName, locationAugs());\n                }\n            }\n        } // scanEndElement()\n\n        //\n        // Private methods\n        //\n\n        /**\n         * Returns true if the given element has an end-tag.\n         */\n        private boolean isEnded(String ename) {\n            String content = new String(fCurrentEntity.buffer, fCurrentEntity.offset,\n                fCurrentEntity.length - fCurrentEntity.offset);\n            return content.toLowerCase().indexOf(\"</\" + ename.toLowerCase() + \">\") != -1;\n        }\n\n    } // class ContentScanner\n\n    /**\n     * Special scanner used for elements whose content needs to be scanned \n     * as plain text, ignoring markup such as elements and entity references.\n     * For example: &lt;SCRIPT&gt; and &lt;COMMENT&gt;.\n     *\n     * @author Andy Clark\n     */\n    public class SpecialScanner\n        implements Scanner {\n\n        //\n        // Data\n        //\n\n        /** Name of element whose content needs to be scanned as text. */\n        protected String fElementName;\n\n        /** True if &lt;style&gt; element. */\n        protected boolean fStyle;\n\n        /** True if &lt;textarea&gt; element. */\n        protected boolean fTextarea;\n\n        /** True if &lt;title&gt; element. */\n        protected boolean fTitle;\n\n        // temp vars\n\n        /** A qualified name. */\n        private final QName fQName = new QName();\n\n        /** A string buffer. */\n        private final XMLStringBuffer fStringBuffer = new XMLStringBuffer();\n\n        //\n        // Public methods\n        //\n\n        /** Sets the element name. */\n        public Scanner setElementName(String ename) {\n            fElementName = ename;\n            fStyle = fElementName.equalsIgnoreCase(\"STYLE\");\n            fTextarea = fElementName.equalsIgnoreCase(\"TEXTAREA\");\n            fTitle = fElementName.equalsIgnoreCase(\"TITLE\");\n            return this;\n        } // setElementName(String):Scanner\n\n        //\n        // Scanner methods\n        //\n\n        /** Scan. */\n        public boolean scan(boolean complete) throws IOException {\n            boolean next;\n            do {\n                try {\n                    next = false;\n                    switch (fScannerState) {\n                        case STATE_CONTENT: {\n                            fBeginLineNumber = fCurrentEntity.getLineNumber();\n                            fBeginColumnNumber = fCurrentEntity.getColumnNumber();\n                            fBeginCharacterOffset = fCurrentEntity.getCharacterOffset();\n                            int c = fCurrentEntity.read();\n                            if (c == '<') {\n                                setScannerState(STATE_MARKUP_BRACKET);\n                                continue;\n                            }\n                            if (c == '&') {\n                                if (fTextarea || fTitle) {\n                                    scanEntityRef(fStringBuffer, true);\n                                    continue;\n                                }\n                                fStringBuffer.clear();\n                                fStringBuffer.append('&');\n                            }\n                            else if (c == -1) {\n                                if (fReportErrors) {\n                                    fErrorReporter.reportError(\"HTML1007\", null);\n                                }\n                                throw new EOFException();\n                            }\n                            else {\n                            \tfCurrentEntity.rewind();\n                                fStringBuffer.clear();\n                            }\n                            scanCharacters(fStringBuffer, -1);\n                            break;\n                        } // case STATE_CONTENT\n                        case STATE_MARKUP_BRACKET: {\n                            int delimiter = -1;\n                            int c = fCurrentEntity.read();\n                            if (c == '/') {\n                                String ename = scanName(true);\n                                if (ename != null) {\n                                    if (ename.equalsIgnoreCase(fElementName)) {\n                                        if (fCurrentEntity.read() == '>') {\n                                            ename = modifyName(ename, fNamesElems);\n                                            if (fDocumentHandler != null && fElementCount >= fElementDepth) {\n                                                fQName.setValues(null, ename, ename, null);\n                                                if (DEBUG_CALLBACKS) {\n                                                    System.out.println(\"endElement(\"+fQName+\")\");\n                                                }\n                                                fEndLineNumber = fCurrentEntity.getLineNumber();\n                                                fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                                                fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                                                fDocumentHandler.endElement(fQName, locationAugs());\n                                            }\n                                            setScanner(fContentScanner);\n                                            setScannerState(STATE_CONTENT);\n                                            return true;\n                                        }\n                                      \tfCurrentEntity.rewind();\n                                    }\n                                    fStringBuffer.clear();\n                                    fStringBuffer.append(\"</\");\n                                    fStringBuffer.append(ename);\n                                }\n                                else {\n                                    fStringBuffer.clear();\n                                    fStringBuffer.append(\"</\");\n                                }\n                            }\n                            else {\n                                fStringBuffer.clear();\n                                fStringBuffer.append('<');\n                                appendChar(fStringBuffer, c);\n                            }\n                            scanCharacters(fStringBuffer, delimiter);\n                            setScannerState(STATE_CONTENT);\n                            break;\n                        } // case STATE_MARKUP_BRACKET\n                    } // switch\n                } // try\n                catch (EOFException e) {\n                    setScanner(fContentScanner);\n                    if (fCurrentEntityStack.empty()) {\n                        setScannerState(STATE_END_DOCUMENT);\n                    }\n                    else {\n                        fCurrentEntity = (CurrentEntity)fCurrentEntityStack.pop();\n                        setScannerState(STATE_CONTENT);\n                    }\n                    return true;\n                }\n            } // do\n            while (next || complete);\n            return true;\n        } // scan(boolean):boolean\n\n        //\n        // Protected methods\n        //\n\n        /** Scan characters. */\n        protected void scanCharacters(XMLStringBuffer buffer,\n                                      int delimiter) throws IOException {\n            if (DEBUG_BUFFER) { \n                fCurrentEntity.debugBufferIfNeeded(\"(scanCharacters, delimiter=\"+delimiter+\": \");\n            }\n            \n            while (true) {\n                int c = fCurrentEntity.read();\n\n                if (c == -1 || (c == '<' || c == '&')) {\n                    if (c != -1) {\n                    \tfCurrentEntity.rewind();\n                    }\n                    break;\n                }\n                // Patch supplied by Jonathan Baxter\n                else if (c == '\\r' || c == '\\n') {\n                \tfCurrentEntity.rewind();\n                    int newlines = skipNewlines();\n                    for (int i = 0; i < newlines; i++) {\n                        buffer.append('\\n');\n                    }\n                }\n                else {\n                    appendChar(buffer, c);\n                    if (c == '\\n') {\n                        fCurrentEntity.incLine();\n                    }\n                }\n            }\n\n            if (fStyle) {\n            \tif (fStyleStripCommentDelims) {\n            \t\treduceToContent(buffer, \"<!--\", \"-->\");\n            \t}\n            \tif (fStyleStripCDATADelims) {\n                \treduceToContent(buffer, \"<![CDATA[\", \"]]>\");\n            \t}\n            }\n\n            if (buffer.length > 0 && fDocumentHandler != null && fElementCount >= fElementDepth) {\n                if (DEBUG_CALLBACKS) {\n                    System.out.println(\"characters(\"+buffer+\")\");\n                }\n                fEndLineNumber = fCurrentEntity.getLineNumber();\n                fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                fDocumentHandler.characters(buffer, locationAugs());\n            }\n            if (DEBUG_BUFFER) { \n                fCurrentEntity.debugBufferIfNeeded(\")scanCharacters: \");\n            }\n        } // scanCharacters(StringBuffer)\n    } // class SpecialScanner\n\n    /**\n     * A playback input stream. This class has the ability to save the bytes\n     * read from the underlying input stream and play the bytes back later.\n     * This class is used by the HTML scanner to switch encodings when a \n     * &lt;meta&gt; tag is detected that specifies a different encoding. \n     * <p>\n     * If the encoding is changed, then the scanner calls the \n     * <code>playback</code> method and re-scans the beginning of the HTML\n     * document again. This should not be too much of a performance problem\n     * because the &lt;meta&gt; tag appears at the beginning of the document.\n     * <p>\n     * If the &lt;body&gt; tag is reached without playing back the bytes,\n     * then the buffer can be cleared by calling the <code>clear</code>\n     * method. This stops the buffering of bytes and allows the memory used\n     * by the buffer to be reclaimed. \n     * <p>\n     * <strong>Note:</strong> \n     * If the buffer is never played back or cleared, this input stream\n     * will continue to buffer the entire stream. Therefore, it is very\n     * important to use this stream correctly.\n     *\n     * @author Andy Clark\n     */\n    public static class PlaybackInputStream\n        extends FilterInputStream {\n\n        //\n        // Constants\n        //\n\n        /** Set to true to debug playback. */\n        private static final boolean DEBUG_PLAYBACK = false;\n\n        //\n        // Data\n        //\n\n        // state\n\n        /** Playback mode. */\n        protected boolean fPlayback = false;\n\n        /** Buffer cleared. */\n        protected boolean fCleared = false;\n\n        /** Encoding detected. */\n        protected boolean fDetected = false;\n\n        // buffer info\n\n        /** Byte buffer. */\n        protected byte[] fByteBuffer = new byte[1024];\n\n        /** Offset into byte buffer during playback. */\n        protected int fByteOffset = 0;\n\n        /** Length of bytes read into byte buffer. */\n        protected int fByteLength = 0;\n\n        /** Pushback offset. */\n        public int fPushbackOffset = 0;\n\n        /** Pushback length. */\n        public int fPushbackLength = 0;\n\n        //\n        // Constructors\n        //\n\n        /** Constructor. */\n        public PlaybackInputStream(InputStream in) {\n            super(in);\n        } // <init>(InputStream)\n\n        //\n        // Public methods\n        //\n\n        /** Detect encoding. */\n        public void detectEncoding(String[] encodings) throws IOException {\n            if (fDetected) {\n                throw new IOException(\"Should not detect encoding twice.\");\n            }\n            fDetected = true;\n            int b1 = read();\n            if (b1 == -1) {\n                return;\n            }\n            int b2 = read();\n            if (b2 == -1) {\n                fPushbackLength = 1;\n                return;\n            }\n            // UTF-8 BOM: 0xEFBBBF\n            if (b1 == 0xEF && b2 == 0xBB) {\n                int b3 = read();\n                if (b3 == 0xBF) {\n                    fPushbackOffset = 3;\n                    encodings[0] = \"UTF-8\";\n                    encodings[1] = \"UTF8\";\n                    return;\n                }\n                fPushbackLength = 3;\n            }\n            // UTF-16 LE BOM: 0xFFFE\n            if (b1 == 0xFF && b2 == 0xFE) {\n                encodings[0] = \"UTF-16\";\n                encodings[1] = \"UnicodeLittleUnmarked\";\n                return;\n            }\n            // UTF-16 BE BOM: 0xFEFF\n            else if (b1 == 0xFE && b2 == 0xFF) {\n                encodings[0] = \"UTF-16\";\n                encodings[1] = \"UnicodeBigUnmarked\";\n                return;\n            }\n            // unknown\n            fPushbackLength = 2;\n        } // detectEncoding()\n\n        /** Playback buffer contents. */\n        public void playback() {\n            fPlayback = true;\n        } // playback()\n\n        /** \n         * Clears the buffer.\n         * <p>\n         * <strong>Note:</strong>\n         * The buffer cannot be cleared during playback. Therefore, calling\n         * this method during playback will not do anything. However, the\n         * buffer will be cleared automatically at the end of playback.\n         */\n        public void clear() {\n            if (!fPlayback) {\n                fCleared = true;\n                fByteBuffer = null;\n            }\n        } // clear()\n\n        //\n        // InputStream methods\n        //\n\n        /** Read a byte. */\n        public int read() throws IOException {\n            if (DEBUG_PLAYBACK) {\n                System.out.println(\"(read\");\n            }\n            if (fPushbackOffset < fPushbackLength) {\n                return fByteBuffer[fPushbackOffset++];\n            }\n            if (fCleared) {\n                return in.read();\n            }\n            if (fPlayback) {\n                int c = fByteBuffer[fByteOffset++];\n                if (fByteOffset == fByteLength) {\n                    fCleared = true;\n                    fByteBuffer = null;\n                }\n                if (DEBUG_PLAYBACK) {\n                    System.out.println(\")read -> \"+(char)c);\n                }\n                return c;\n            }\n            int c = in.read();\n            if (c != -1) {\n                if (fByteLength == fByteBuffer.length) {\n                    byte[] newarray = new byte[fByteLength + 1024];\n                    System.arraycopy(fByteBuffer, 0, newarray, 0, fByteLength);\n                    fByteBuffer = newarray;\n                }\n                fByteBuffer[fByteLength++] = (byte)c;\n            }\n            if (DEBUG_PLAYBACK) {\n                System.out.println(\")read -> \"+(char)c);\n            }\n            return c;\n        } // read():int\n\n        /** Read an array of bytes. */\n        public int read(byte[] array) throws IOException {\n            return read(array, 0, array.length);\n        } // read(byte[]):int\n\n        /** Read an array of bytes. */\n        public int read(byte[] array, int offset, int length) throws IOException {\n            if (DEBUG_PLAYBACK) {\n                System.out.println(\")read(\"+offset+','+length+')');\n            }\n            if (fPushbackOffset < fPushbackLength) {\n                int count = fPushbackLength - fPushbackOffset;\n                if (count > length) {\n                    count = length;\n                }\n                System.arraycopy(fByteBuffer, fPushbackOffset, array, offset, count);\n                fPushbackOffset += count;\n                return count;\n            }\n            if (fCleared) {\n                return in.read(array, offset, length);\n            }\n            if (fPlayback) {\n                if (fByteOffset + length > fByteLength) {\n                    length = fByteLength - fByteOffset;\n                }\n                System.arraycopy(fByteBuffer, fByteOffset, array, offset, length);\n                fByteOffset += length;\n                if (fByteOffset == fByteLength) {\n                    fCleared = true;\n                    fByteBuffer = null;\n                }\n                return length;\n            }\n            int count = in.read(array, offset, length);\n            if (count != -1) {\n                if (fByteLength + count > fByteBuffer.length) {\n                    byte[] newarray = new byte[fByteLength + count + 512];\n                    System.arraycopy(fByteBuffer, 0, newarray, 0, fByteLength);\n                    fByteBuffer = newarray;\n                }\n                System.arraycopy(array, offset, fByteBuffer, fByteLength, count);\n                fByteLength += count;\n            }\n            if (DEBUG_PLAYBACK) {\n                System.out.println(\")read(\"+offset+','+length+\") -> \"+count);\n            }\n            return count;\n        } // read(byte[]):int\n\n    } // class PlaybackInputStream\n\n    /**\n     * Location infoset item. \n     *\n     * @author Andy Clark\n     */\n    protected static class LocationItem implements HTMLEventInfo, Cloneable {\n\n        //\n        // Data\n        //\n\n        /** Beginning line number. */\n        protected int fBeginLineNumber;\n\n        /** Beginning column number. */\n        protected int fBeginColumnNumber;\n\n        /** Beginning character offset. */\n        protected int fBeginCharacterOffset;\n\n        /** Ending line number. */\n        protected int fEndLineNumber;\n\n        /** Ending column number. */\n        protected int fEndColumnNumber;\n\n        /** Ending character offset. */\n        protected int fEndCharacterOffset;\n\n        //\n        // Public methods\n        //\n        public LocationItem() {\n        \t// nothing\n        }\n\n        LocationItem(final LocationItem other) {\n\t\t\tsetValues(other.fBeginLineNumber, other.fBeginColumnNumber, other.fBeginCharacterOffset,\n\t\t\t\t\tother.fEndLineNumber, other.fEndColumnNumber, other.fEndCharacterOffset);\n\t\t}\n\n        /** Sets the values of this item. */\n        public void setValues(int beginLine, int beginColumn, int beginOffset,\n                              int endLine, int endColumn, int endOffset) {\n            fBeginLineNumber = beginLine;\n            fBeginColumnNumber = beginColumn;\n            fBeginCharacterOffset = beginOffset;\n            fEndLineNumber = endLine;\n            fEndColumnNumber = endColumn;\n            fEndCharacterOffset = endOffset;\n        } // setValues(int,int,int,int)\n\n        //\n        // HTMLEventInfo methods\n        //\n\n        // location information\n\n        /** Returns the line number of the beginning of this event.*/\n        public int getBeginLineNumber() {\n            return fBeginLineNumber;\n        } // getBeginLineNumber():int\n\n        /** Returns the column number of the beginning of this event.*/\n        public int getBeginColumnNumber() { \n            return fBeginColumnNumber;\n        } // getBeginColumnNumber():int\n\n        /** Returns the character offset of the beginning of this event.*/\n        public int getBeginCharacterOffset() { \n            return fBeginCharacterOffset;\n        } // getBeginCharacterOffset():int\n\n        /** Returns the line number of the end of this event.*/\n        public int getEndLineNumber() {\n            return fEndLineNumber;\n        } // getEndLineNumber():int\n\n        /** Returns the column number of the end of this event.*/\n        public int getEndColumnNumber() {\n            return fEndColumnNumber;\n        } // getEndColumnNumber():int\n\n        /** Returns the character offset of the end of this event.*/\n        public int getEndCharacterOffset() { \n            return fEndCharacterOffset;\n        } // getEndCharacterOffset():int\n\n        // other information\n\n        /** Returns true if this corresponding event was synthesized. */\n        public boolean isSynthesized() {\n            return false;\n        } // isSynthesize():boolean\n\n        //\n        // Object methods\n        //\n\n        /** Returns a string representation of this object. */\n        public String toString() {\n            StringBuffer str = new StringBuffer();\n            str.append(fBeginLineNumber);\n            str.append(':');\n            str.append(fBeginColumnNumber);\n            str.append(':');\n            str.append(fBeginCharacterOffset);\n            str.append(':');\n            str.append(fEndLineNumber);\n            str.append(':');\n            str.append(fEndColumnNumber);\n            str.append(':');\n            str.append(fEndCharacterOffset);\n            return str.toString();\n        } // toString():String\n\n    } // class LocationItem\n\n    /**\n     * To detect if 2 encoding are compatible, both must be able to read the meta tag specifying\n     * the new encoding. This means that the byte representation of some minimal html markup must\n     * be the same in both encodings\n     */ \n    boolean isEncodingCompatible(final String encoding1, final String encoding2) {\n\t\ttry {\n            try {\n                return canRoundtrip(encoding1, encoding2);\n            }\n            catch (final UnsupportedOperationException e) {\n                // if encoding1 only supports decode, we can test it the other way to only decode with it\n                try {\n                    return canRoundtrip(encoding2, encoding1);\n                }\n                catch (final UnsupportedOperationException e1) {\n                    // encoding2 only supports decode too. Time to give up.\n                    return false;\n                }\n            }\n\t\t}\n\t\tcatch (final UnsupportedEncodingException e) {\n\t\t\treturn false;\n\t\t}\n    }\n\n    private boolean canRoundtrip(final String encodeCharset, final String decodeCharset) throws UnsupportedEncodingException {\n        final String reference = \"<html><head><meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=\";\n        final byte[] bytesEncoding1 = reference.getBytes(encodeCharset);\n        final String referenceWithEncoding2 = new String(bytesEncoding1, decodeCharset);\n        return reference.equals(referenceWithEncoding2);\n    }\n\n    private boolean endsWith(final XMLStringBuffer buffer, final String string) {\n\t\tfinal int l = string.length();\n\t\tif (buffer.length < l) {\n\t\t\treturn false;\n\t\t}\n\t\tfinal String s = new String(buffer.ch, buffer.length-l, l);\n\t\treturn string.equals(s);\n\t}\n\n     /** Reads a single character, preserving the old buffer content */\n     protected int readPreservingBufferContent() throws IOException {\n         if (DEBUG_BUFFER) { \n             fCurrentEntity.debugBufferIfNeeded(\"(read: \");\n         }\n         if (fCurrentEntity.offset == fCurrentEntity.length) {\n             if (fCurrentEntity.load(fCurrentEntity.length) < 1) {\n                 if (DEBUG_BUFFER) { \n                     System.out.println(\")read: -> -1\");\n                 }\n                 return -1;\n             }\n         }\n         final char c = fCurrentEntity.getNextChar();\n         if (DEBUG_BUFFER) { \n             fCurrentEntity.debugBufferIfNeeded(\")read: \", \" -> \" + c);\n         }\n         return c;\n     } // readPreservingBufferContent():int\n\n     /**\n     * Indicates if the end comment --> is available, loading further data if needed, without to reset the buffer\n     */\n\tprivate boolean endCommentAvailable() throws IOException {\n\t\tint nbCaret = 0;\n        final int originalOffset = fCurrentEntity.offset;\n        final int originalColumnNumber = fCurrentEntity.getColumnNumber();\n        final int originalCharacterOffset = fCurrentEntity.getCharacterOffset();\n\n\t\twhile (true) {\n\t        int c = readPreservingBufferContent();\n\t        if (c == -1) {\n\t\t        fCurrentEntity.restorePosition(originalOffset, originalColumnNumber, originalCharacterOffset);\n\t        \treturn false;\n\t        }\n\t        else if (c == '>' && nbCaret >= 2) {\n\t\t        fCurrentEntity.restorePosition(originalOffset, originalColumnNumber, originalCharacterOffset);\n\t        \treturn true;\n\t        }\n\t        else if (c == '-') {\n\t        \tnbCaret++;\n\t        }\n\t        else {\n\t        \tnbCaret = 0;\n\t        }\n\t\t}\n\t}\n\n\t/**\n     * Reduces the buffer to the content between start and end marker when\n     * only whitespaces are found before the startMarker as well as after the end marker\n     */\n\tstatic void reduceToContent(final XMLStringBuffer buffer, final String startMarker, final String endMarker) {\n\t\tint i = 0;\n\t\tint startContent = -1;\n\t\tfinal int l1 = startMarker.length();\n\t\tfinal int l2 = endMarker.length();\n\t\twhile (i < buffer.length - l1 - l2) {\n\t\t\tfinal char c = buffer.ch[buffer.offset+i];\n\t\t\tif (Character.isWhitespace(c)) {\n\t\t\t\t++i;\n\t\t\t}\n\t\t\telse if (c == startMarker.charAt(0)\n\t\t\t\t&& startMarker.equals(new String(buffer.ch, buffer.offset+i, l1))) {\n\t\t\t\tstartContent = buffer.offset + i + l1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn; // start marker not found\n\t\t\t}\n\t\t}\n\t\tif (startContent == -1) { // start marker not found\n\t\t\treturn;\n\t\t}\n\t\t\n\t\ti = buffer.length - 1;\n\t\twhile (i > startContent + l2) {\n\t\t\tfinal char c = buffer.ch[buffer.offset+i];\n\t\t\tif (Character.isWhitespace(c)) {\n\t\t\t\t--i;\n\t\t\t}\n\t\t\telse if (c == endMarker.charAt(l2-1)\n\t\t\t\t&& endMarker.equals(new String(buffer.ch, buffer.offset+i-l2+1, l2))) {\n\t\t\t\t\n\t\t\t\tbuffer.length = buffer.offset + i - startContent - 2;\n\t\t\t\tbuffer.offset = startContent;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn; // start marker not found\n\t\t\t}\n\t\t}\n\t}\n} // class HTMLScanner\n"], "fixing_code": ["/* \n * Copyright 2002-2009 Andy Clark, Marc Guillemot\n * \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.cyberneko.html;\n\nimport java.io.EOFException;\nimport java.io.FilterInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URL;\nimport java.util.BitSet;\nimport java.util.Locale;\nimport java.util.Stack;\n\nimport org.apache.xerces.util.EncodingMap;\nimport org.apache.xerces.util.NamespaceSupport;\nimport org.apache.xerces.util.URI;\nimport org.apache.xerces.util.XMLAttributesImpl;\nimport org.apache.xerces.util.XMLResourceIdentifierImpl;\nimport org.apache.xerces.util.XMLStringBuffer;\nimport org.apache.xerces.xni.Augmentations;\nimport org.apache.xerces.xni.NamespaceContext;\nimport org.apache.xerces.xni.QName;\nimport org.apache.xerces.xni.XMLAttributes;\nimport org.apache.xerces.xni.XMLDocumentHandler;\nimport org.apache.xerces.xni.XMLLocator;\nimport org.apache.xerces.xni.XMLResourceIdentifier;\nimport org.apache.xerces.xni.XMLString;\nimport org.apache.xerces.xni.XNIException;\nimport org.apache.xerces.xni.parser.XMLComponentManager;\nimport org.apache.xerces.xni.parser.XMLConfigurationException;\nimport org.apache.xerces.xni.parser.XMLDocumentScanner;\nimport org.apache.xerces.xni.parser.XMLInputSource;\nimport org.cyberneko.html.xercesbridge.XercesBridge;\n\n/**\n * A simple HTML scanner. This scanner makes no attempt to balance tags\n * or fix other problems in the source document &mdash; it just scans what \n * it can and generates XNI document \"events\", ignoring errors of all \n * kinds.\n * <p>\n * This component recognizes the following features:\n * <ul>\n * <li>http://cyberneko.org/html/features/augmentations\n * <li>http://cyberneko.org/html/features/report-errors\n * <li>http://apache.org/xml/features/scanner/notify-char-refs\n * <li>http://apache.org/xml/features/scanner/notify-builtin-refs\n * <li>http://cyberneko.org/html/features/scanner/notify-builtin-refs\n * <li>http://cyberneko.org/html/features/scanner/fix-mswindows-refs\n * <li>http://cyberneko.org/html/features/scanner/script/strip-cdata-delims\n * <li>http://cyberneko.org/html/features/scanner/script/strip-comment-delims\n * <li>http://cyberneko.org/html/features/scanner/style/strip-cdata-delims\n * <li>http://cyberneko.org/html/features/scanner/style/strip-comment-delims\n * <li>http://cyberneko.org/html/features/scanner/ignore-specified-charset\n * <li>http://cyberneko.org/html/features/scanner/cdata-sections\n * <li>http://cyberneko.org/html/features/override-doctype\n * <li>http://cyberneko.org/html/features/insert-doctype\n * <li>http://cyberneko.org/html/features/parse-noscript-content\n * <li>http://cyberneko.org/html/features/scanner/allow-selfclosing-iframe\n * <li>http://cyberneko.org/html/features/scanner/allow-selfclosing-tags\n * </ul>\n * <p>\n * This component recognizes the following properties:\n * <ul>\n * <li>http://cyberneko.org/html/properties/names/elems\n * <li>http://cyberneko.org/html/properties/names/attrs\n * <li>http://cyberneko.org/html/properties/default-encoding\n * <li>http://cyberneko.org/html/properties/error-reporter\n * <li>http://cyberneko.org/html/properties/doctype/pubid\n * <li>http://cyberneko.org/html/properties/doctype/sysid\n * </ul>\n *\n * @see HTMLElements\n * @see HTMLEntities\n *\n * @author Andy Clark\n * @author Marc Guillemot\n * @author Ahmed Ashour\n *\n * @version $Id: HTMLScanner.java,v 1.19 2005/06/14 05:52:37 andyc Exp $\n */\npublic class HTMLScanner \n    implements XMLDocumentScanner, XMLLocator, HTMLComponent {\n\n    //\n    // Constants\n    //\n\n    // doctype info: HTML 4.01 strict\n\n    /** HTML 4.01 strict public identifier (\"-//W3C//DTD HTML 4.01//EN\"). */\n    public static final String HTML_4_01_STRICT_PUBID = \"-//W3C//DTD HTML 4.01//EN\";\n\n    /** HTML 4.01 strict system identifier (\"http://www.w3.org/TR/html4/strict.dtd\"). */\n    public static final String HTML_4_01_STRICT_SYSID = \"http://www.w3.org/TR/html4/strict.dtd\";\n\n    // doctype info: HTML 4.01 loose\n\n    /** HTML 4.01 transitional public identifier (\"-//W3C//DTD HTML 4.01 Transitional//EN\"). */\n    public static final String HTML_4_01_TRANSITIONAL_PUBID = \"-//W3C//DTD HTML 4.01 Transitional//EN\";\n\n    /** HTML 4.01 transitional system identifier (\"http://www.w3.org/TR/html4/loose.dtd\"). */\n    public static final String HTML_4_01_TRANSITIONAL_SYSID = \"http://www.w3.org/TR/html4/loose.dtd\";\n\n    // doctype info: HTML 4.01 frameset\n\n    /** HTML 4.01 frameset public identifier (\"-//W3C//DTD HTML 4.01 Frameset//EN\"). */\n    public static final String HTML_4_01_FRAMESET_PUBID = \"-//W3C//DTD HTML 4.01 Frameset//EN\";\n\n    /** HTML 4.01 frameset system identifier (\"http://www.w3.org/TR/html4/frameset.dtd\"). */\n    public static final String HTML_4_01_FRAMESET_SYSID = \"http://www.w3.org/TR/html4/frameset.dtd\";\n\n    // features\n\n    /** Include infoset augmentations. */\n    protected static final String AUGMENTATIONS = \"http://cyberneko.org/html/features/augmentations\";\n\n    /** Report errors. */\n    protected static final String REPORT_ERRORS = \"http://cyberneko.org/html/features/report-errors\";\n\n    /** Notify character entity references (e.g. &amp;#32;, &amp;#x20;, etc). */\n    public static final String NOTIFY_CHAR_REFS = \"http://apache.org/xml/features/scanner/notify-char-refs\";\n\n    /** \n     * Notify handler of built-in entity references (e.g. &amp;amp;, \n     * &amp;lt;, etc).\n     * <p>\n     * <strong>Note:</strong>\n     * This only applies to the five pre-defined XML general entities.\n     * Specifically, \"amp\", \"lt\", \"gt\", \"quot\", and \"apos\". This is done \n     * for compatibility with the Xerces feature.\n     * <p>\n     * To be notified of the built-in entity references in HTML, set the \n     * <code>http://cyberneko.org/html/features/scanner/notify-builtin-refs</code> \n     * feature to <code>true</code>.\n     */\n    public static final String NOTIFY_XML_BUILTIN_REFS = \"http://apache.org/xml/features/scanner/notify-builtin-refs\";\n\n    /** \n     * Notify handler of built-in entity references (e.g. &amp;nobr;, \n     * &amp;copy;, etc).\n     * <p>\n     * <strong>Note:</strong>\n     * This <em>includes</em> the five pre-defined XML general entities.\n     */\n    public static final String NOTIFY_HTML_BUILTIN_REFS = \"http://cyberneko.org/html/features/scanner/notify-builtin-refs\";\n\n    /** Fix Microsoft Windows&reg; character entity references. */\n    public static final String FIX_MSWINDOWS_REFS = \"http://cyberneko.org/html/features/scanner/fix-mswindows-refs\";\n\n    /** \n     * Strip HTML comment delimiters (\"&lt;!&minus;&minus;\" and \n     * \"&minus;&minus;&gt;\") from SCRIPT tag contents.\n     */\n    public static final String SCRIPT_STRIP_COMMENT_DELIMS = \"http://cyberneko.org/html/features/scanner/script/strip-comment-delims\";\n\n    /** \n     * Strip XHTML CDATA delimiters (\"&lt;![CDATA[\" and \"]]&gt;\") from \n     * SCRIPT tag contents.\n     */\n    public static final String SCRIPT_STRIP_CDATA_DELIMS = \"http://cyberneko.org/html/features/scanner/script/strip-cdata-delims\";\n\n    /** \n     * Strip HTML comment delimiters (\"&lt;!&minus;&minus;\" and \n     * \"&minus;&minus;&gt;\") from STYLE tag contents.\n     */\n    public static final String STYLE_STRIP_COMMENT_DELIMS = \"http://cyberneko.org/html/features/scanner/style/strip-comment-delims\";\n\n    /** \n     * Strip XHTML CDATA delimiters (\"&lt;![CDATA[\" and \"]]&gt;\") from \n     * STYLE tag contents.\n     */\n    public static final String STYLE_STRIP_CDATA_DELIMS = \"http://cyberneko.org/html/features/scanner/style/strip-cdata-delims\";\n\n    /**\n     * Ignore specified charset found in the &lt;meta equiv='Content-Type'\n     * content='text/html;charset=&hellip;'&gt; tag or in the &lt;?xml &hellip; encoding='&hellip;'&gt; processing instruction\n     */\n    public static final String IGNORE_SPECIFIED_CHARSET = \"http://cyberneko.org/html/features/scanner/ignore-specified-charset\";\n\n    /** Scan CDATA sections. */\n    public static final String CDATA_SECTIONS = \"http://cyberneko.org/html/features/scanner/cdata-sections\";\n\n    /** Override doctype declaration public and system identifiers. */\n    public static final String OVERRIDE_DOCTYPE = \"http://cyberneko.org/html/features/override-doctype\";\n\n    /** Insert document type declaration. */\n    public static final String INSERT_DOCTYPE = \"http://cyberneko.org/html/features/insert-doctype\";\n    \n    /** Parse &lt;noscript&gt;...&lt;/noscript&gt; content */\n    public static final String PARSE_NOSCRIPT_CONTENT = \"http://cyberneko.org/html/features/parse-noscript-content\";\n\n    /** Allows self closing &lt;iframe/&gt; tag */\n    public static final String ALLOW_SELFCLOSING_IFRAME = \"http://cyberneko.org/html/features/scanner/allow-selfclosing-iframe\";\n    \n    /** Allows self closing tags e.g. &lt;div/&gt; (XHTML) */\n    public static final String ALLOW_SELFCLOSING_TAGS = \"http://cyberneko.org/html/features/scanner/allow-selfclosing-tags\";\n\n    /** Normalize attribute values. */\n    protected static final String NORMALIZE_ATTRIBUTES = \"http://cyberneko.org/html/features/scanner/normalize-attrs\";\n\n    /** Recognized features. */\n    private static final String[] RECOGNIZED_FEATURES = {\n        AUGMENTATIONS,\n        REPORT_ERRORS,\n        NOTIFY_CHAR_REFS,\n        NOTIFY_XML_BUILTIN_REFS,\n        NOTIFY_HTML_BUILTIN_REFS,\n        FIX_MSWINDOWS_REFS,\n        SCRIPT_STRIP_CDATA_DELIMS,\n        SCRIPT_STRIP_COMMENT_DELIMS,\n        STYLE_STRIP_CDATA_DELIMS,\n        STYLE_STRIP_COMMENT_DELIMS,\n        IGNORE_SPECIFIED_CHARSET,\n        CDATA_SECTIONS,\n        OVERRIDE_DOCTYPE,\n        INSERT_DOCTYPE,\n        NORMALIZE_ATTRIBUTES,\n        PARSE_NOSCRIPT_CONTENT,\n        ALLOW_SELFCLOSING_IFRAME,\n        ALLOW_SELFCLOSING_TAGS,\n    };\n\n    /** Recognized features defaults. */\n    private static final Boolean[] RECOGNIZED_FEATURES_DEFAULTS = {\n        null,\n        null,\n        Boolean.FALSE,\n        Boolean.FALSE,\n        Boolean.FALSE,\n        Boolean.FALSE,\n        Boolean.FALSE,\n        Boolean.FALSE,\n        Boolean.FALSE,\n        Boolean.FALSE,\n        Boolean.FALSE,\n        Boolean.FALSE,\n        Boolean.FALSE,\n        Boolean.FALSE,\n        Boolean.FALSE,\n        Boolean.TRUE,\n        Boolean.FALSE,\n        Boolean.FALSE,\n    };\n\n    // properties\n\n    /** Modify HTML element names: { \"upper\", \"lower\", \"default\" }. */\n    protected static final String NAMES_ELEMS = \"http://cyberneko.org/html/properties/names/elems\";\n\n    /** Modify HTML attribute names: { \"upper\", \"lower\", \"default\" }. */\n    protected static final String NAMES_ATTRS = \"http://cyberneko.org/html/properties/names/attrs\";\n    \n    /** Default encoding. */\n    protected static final String DEFAULT_ENCODING = \"http://cyberneko.org/html/properties/default-encoding\";\n    \n    /** Error reporter. */\n    protected static final String ERROR_REPORTER = \"http://cyberneko.org/html/properties/error-reporter\";\n\n    /** Doctype declaration public identifier. */\n    protected static final String DOCTYPE_PUBID = \"http://cyberneko.org/html/properties/doctype/pubid\";\n\n    /** Doctype declaration system identifier. */\n    protected static final String DOCTYPE_SYSID = \"http://cyberneko.org/html/properties/doctype/sysid\";\n\n    /** Recognized properties. */\n    private static final String[] RECOGNIZED_PROPERTIES = {\n        NAMES_ELEMS,\n        NAMES_ATTRS,\n        DEFAULT_ENCODING,\n        ERROR_REPORTER,\n        DOCTYPE_PUBID,\n        DOCTYPE_SYSID,\n    };\n\n    /** Recognized properties defaults. */\n    private static final Object[] RECOGNIZED_PROPERTIES_DEFAULTS = {\n        null,\n        null,\n        \"Windows-1252\",\n        null,\n        HTML_4_01_TRANSITIONAL_PUBID,\n        HTML_4_01_TRANSITIONAL_SYSID,\n    };\n\n    // states\n\n    /** State: content. */\n    protected static final short STATE_CONTENT = 0;\n\n    /** State: markup bracket. */\n    protected static final short STATE_MARKUP_BRACKET = 1;\n\n    /** State: start document. */\n    protected static final short STATE_START_DOCUMENT = 10;\n\n    /** State: end document. */\n    protected static final short STATE_END_DOCUMENT = 11;\n\n    // modify HTML names\n\n    /** Don't modify HTML names. */\n    protected static final short NAMES_NO_CHANGE = 0;\n\n    /** Uppercase HTML names. */\n    protected static final short NAMES_UPPERCASE = 1;\n\n    /** Lowercase HTML names. */\n    protected static final short NAMES_LOWERCASE = 2;\n\n    // defaults\n\n    /** Default buffer size. */\n    protected static final int DEFAULT_BUFFER_SIZE = 2048;\n\n    // debugging\n\n    /** Set to true to debug changes in the scanner. */\n    private static final boolean DEBUG_SCANNER = false;\n\n    /** Set to true to debug changes in the scanner state. */\n    private static final boolean DEBUG_SCANNER_STATE = false;\n\n    /** Set to true to debug the buffer. */\n    private static final boolean DEBUG_BUFFER = false;\n\n    /** Set to true to debug character encoding handling. */\n    private static final boolean DEBUG_CHARSET = false;\n\n    /** Set to true to debug callbacks. */\n    protected static final boolean DEBUG_CALLBACKS = false;\n    \n    // static vars\n\n    /** Synthesized event info item. */\n    protected static final HTMLEventInfo SYNTHESIZED_ITEM = \n        new HTMLEventInfo.SynthesizedItem();\n        \n    private final static BitSet ENTITY_CHARS = new BitSet();\n    static {\n    \tfinal String str = \"-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\";\n    \tfor (int i = 0; i < str.length(); ++i) {\n    \t\tchar c = str.charAt(i);\n    \t\tENTITY_CHARS.set(c);\n    \t}\n    }\n    //\n    // Data\n    //\n\n    // features\n\n    /** Augmentations. */\n    protected boolean fAugmentations;\n\n    /** Report errors. */\n    protected boolean fReportErrors;\n\n    /** Notify character entity references. */\n    protected boolean fNotifyCharRefs;\n\n    /** Notify XML built-in general entity references. */\n    protected boolean fNotifyXmlBuiltinRefs;\n\n    /** Notify HTML built-in general entity references. */\n    protected boolean fNotifyHtmlBuiltinRefs;\n\n    /** Fix Microsoft Windows&reg; character entity references. */\n    protected boolean fFixWindowsCharRefs;\n\n    /** Strip CDATA delimiters from SCRIPT tags. */\n    protected boolean fScriptStripCDATADelims;\n\n    /** Strip comment delimiters from SCRIPT tags. */\n    protected boolean fScriptStripCommentDelims;\n\n    /** Strip CDATA delimiters from STYLE tags. */\n    protected boolean fStyleStripCDATADelims;\n\n    /** Strip comment delimiters from STYLE tags. */\n    protected boolean fStyleStripCommentDelims;\n\n    /** Ignore specified character set. */\n    protected boolean fIgnoreSpecifiedCharset;\n\n    /** CDATA sections. */\n    protected boolean fCDATASections;\n\n    /** Override doctype declaration public and system identifiers. */\n    protected boolean fOverrideDoctype;\n\n    /** Insert document type declaration. */\n    protected boolean fInsertDoctype;\n\n    /** Normalize attribute values. */\n    protected boolean fNormalizeAttributes;\n    \n    /** Parse noscript content. */\n    protected boolean fParseNoScriptContent;\n\n    /** Parse noframes content. */\n    protected boolean fParseNoFramesContent;\n    \n    /** Allows self closing iframe tags. */\n    protected boolean fAllowSelfclosingIframe;\n\n    /** Allows self closing tags. */\n    protected boolean fAllowSelfclosingTags;\n\n    // properties\n\n    /** Modify HTML element names. */\n    protected short fNamesElems;\n\n    /** Modify HTML attribute names. */\n    protected short fNamesAttrs;\n\n    /** Default encoding. */\n    protected String fDefaultIANAEncoding;\n\n    /** Error reporter. */\n    protected HTMLErrorReporter fErrorReporter;\n\n    /** Doctype declaration public identifier. */\n    protected String fDoctypePubid;\n\n    /** Doctype declaration system identifier. */\n    protected String fDoctypeSysid;\n\n    // boundary locator information\n\n    /** Beginning line number. */\n    protected int fBeginLineNumber;\n\n    /** Beginning column number. */\n    protected int fBeginColumnNumber;\n\n    /** Beginning character offset in the file. */\n    protected int fBeginCharacterOffset;\n\n    /** Ending line number. */\n    protected int fEndLineNumber;\n\n    /** Ending column number. */\n    protected int fEndColumnNumber;\n\n    /** Ending character offset in the file. */\n    protected int fEndCharacterOffset;\n\n    // state\n\n    /** The playback byte stream. */\n    protected PlaybackInputStream fByteStream;\n\n    /** Current entity. */\n    protected CurrentEntity fCurrentEntity;\n    \n    /** The current entity stack. */\n    protected final Stack fCurrentEntityStack = new Stack();\n\n    /** The current scanner. */\n    protected Scanner fScanner;\n\n    /** The current scanner state. */\n    protected short fScannerState;\n\n    /** The document handler. */\n    protected XMLDocumentHandler fDocumentHandler;\n\n    /** Auto-detected IANA encoding. */\n    protected String fIANAEncoding;\n\n    /** Auto-detected Java encoding. */\n    protected String fJavaEncoding;\n\n    /** True if the encoding matches \"ISO-8859-*\". */\n    protected boolean fIso8859Encoding;\n\n    /** Element count. */\n    protected int fElementCount;\n\n    /** Element depth. */\n    protected int fElementDepth;\n\n    // scanners\n\n    /** Content scanner. */\n    protected Scanner fContentScanner = new ContentScanner();\n\n    /** \n     * Special scanner used for elements whose content needs to be scanned \n     * as plain text, ignoring markup such as elements and entity references.\n     * For example: &lt;SCRIPT&gt; and &lt;COMMENT&gt;.\n     */\n    protected SpecialScanner fSpecialScanner = new SpecialScanner();\n\n    // temp vars\n\n    /** String buffer. */\n    protected final XMLStringBuffer fStringBuffer = new XMLStringBuffer(1024);\n\n    /** String buffer. */\n    private final XMLStringBuffer fStringBuffer2 = new XMLStringBuffer(1024);\n\n    /** Non-normalized attribute string buffer. */\n    private final XMLStringBuffer fNonNormAttr = new XMLStringBuffer(128);\n\n    /** Augmentations. */\n    private final HTMLAugmentations fInfosetAugs = new HTMLAugmentations();\n\n    /** Location infoset item. */\n    private final LocationItem fLocationItem = new LocationItem();\n\n    /** Single boolean array. */\n    private final boolean[] fSingleBoolean = { false };\n\n    /** Resource identifier. */\n    private final XMLResourceIdentifierImpl fResourceId = new XMLResourceIdentifierImpl();\n\n\tprivate final char REPLACEMENT_CHARACTER = '\\uFFFD'; // the \ufffd character\n\n    //\n    // Public methods\n    //\n\n    /** \n     * Pushes an input source onto the current entity stack. This \n     * enables the scanner to transparently scan new content (e.g. \n     * the output written by an embedded script). At the end of the\n     * current entity, the scanner returns where it left off at the\n     * time this entity source was pushed.\n     * <p>\n     * <strong>Note:</strong>\n     * This functionality is experimental at this time and is\n     * subject to change in future releases of NekoHTML.\n     *\n     * @param inputSource The new input source to start scanning.\n     * @see #evaluateInputSource(XMLInputSource)\n     */\n    public void pushInputSource(XMLInputSource inputSource) {\n    \tfinal Reader reader = getReader(inputSource);\n\n    \tfCurrentEntityStack.push(fCurrentEntity);\n        String encoding = inputSource.getEncoding();\n        String publicId = inputSource.getPublicId();\n        String baseSystemId = inputSource.getBaseSystemId();\n        String literalSystemId = inputSource.getSystemId();\n        String expandedSystemId = expandSystemId(literalSystemId, baseSystemId);\n        fCurrentEntity = new CurrentEntity(reader, encoding, \n                                           publicId, baseSystemId,\n                                           literalSystemId, expandedSystemId);\n    } // pushInputSource(XMLInputSource)\n\n    private Reader getReader(final XMLInputSource inputSource) {\n        Reader reader = inputSource.getCharacterStream();\n        if (reader == null) {\n        \ttry {\n\t\t\t\treturn new InputStreamReader(inputSource.getByteStream(), fJavaEncoding);\n\t\t\t}\n        \tcatch (final UnsupportedEncodingException e) {\n\t\t\t\t// should not happen as this encoding is already used to parse the \"main\" source\n\t\t\t}\n        }\n        return reader;\n\t}\n\n\t/** \n     * Immediately evaluates an input source and add the new content (e.g. \n     * the output written by an embedded script).\n     *\n     * @param inputSource The new input source to start evaluating.\n     * @see #pushInputSource(XMLInputSource)\n     */\n    public void evaluateInputSource(XMLInputSource inputSource) {\n        final Scanner previousScanner = fScanner;\n        final short previousScannerState = fScannerState;\n        final CurrentEntity previousEntity = fCurrentEntity;\n        final Reader reader = getReader(inputSource);\n\n        String encoding = inputSource.getEncoding();\n        String publicId = inputSource.getPublicId();\n        String baseSystemId = inputSource.getBaseSystemId();\n        String literalSystemId = inputSource.getSystemId();\n        String expandedSystemId = expandSystemId(literalSystemId, baseSystemId);\n        fCurrentEntity = new CurrentEntity(reader, encoding, \n                                           publicId, baseSystemId,\n                                           literalSystemId, expandedSystemId);\n        setScanner(fContentScanner);\n        setScannerState(STATE_CONTENT);\n        try {\n            do {\n                fScanner.scan(false);\n            } while (fScannerState != STATE_END_DOCUMENT);\n        }\n        catch (final IOException e) {\n            // ignore\n        }\n        setScanner(previousScanner);\n        setScannerState(previousScannerState);\n        fCurrentEntity = previousEntity;\n    } // evaluateInputSource(XMLInputSource)\n\n    /**\n     * Cleans up used resources. For example, if scanning is terminated\n     * early, then this method ensures all remaining open streams are\n     * closed.\n     *\n     * @param closeall Close all streams, including the original.\n     *                 This is used in cases when the application has\n     *                 opened the original document stream and should\n     *                 be responsible for closing it.\n     */\n    public void cleanup(boolean closeall) {\n        int size = fCurrentEntityStack.size();\n        if (size > 0) {\n            // current entity is not the original, so close it\n            if (fCurrentEntity != null) {\n            \tfCurrentEntity.closeQuietly();\n            }\n            // close remaining streams\n            for (int i = closeall ? 0 : 1; i < size; i++) {\n                fCurrentEntity = (CurrentEntity) fCurrentEntityStack.pop();\n                fCurrentEntity.closeQuietly();\n            }\n        }\n        else if (closeall && fCurrentEntity != null) {\n        \tfCurrentEntity.closeQuietly();\n        }\n    } // cleanup(boolean)\n\n    //\n    // XMLLocator methods\n    //\n\n    /** Returns the encoding. */\n    public String getEncoding() {\n        return fCurrentEntity != null ? fCurrentEntity.encoding : null;\n    } // getEncoding():String\n\n    /** Returns the public identifier. */\n    public String getPublicId() { \n        return fCurrentEntity != null ? fCurrentEntity.publicId : null; \n    } // getPublicId():String\n\n    /** Returns the base system identifier. */\n    public String getBaseSystemId() { \n        return fCurrentEntity != null ? fCurrentEntity.baseSystemId : null; \n    } // getBaseSystemId():String\n\n    /** Returns the literal system identifier. */\n    public String getLiteralSystemId() { \n        return fCurrentEntity != null ? fCurrentEntity.literalSystemId : null; \n    } // getLiteralSystemId():String\n\n    /** Returns the expanded system identifier. */\n    public String getExpandedSystemId() { \n        return fCurrentEntity != null ? fCurrentEntity.expandedSystemId : null; \n    } // getExpandedSystemId():String\n\n    /** Returns the current line number. */\n    public int getLineNumber() { \n        return fCurrentEntity != null ? fCurrentEntity.getLineNumber() : -1; \n    } // getLineNumber():int\n\n    /** Returns the current column number. */\n    public int getColumnNumber() { \n        return fCurrentEntity != null ? fCurrentEntity.getColumnNumber() : -1; \n    } // getColumnNumber():int\n    \n    /** Returns the XML version. */\n    public String getXMLVersion() {\n\t\treturn fCurrentEntity != null ? fCurrentEntity.version : null; \n    } // getXMLVersion():String\n    \n    /** Returns the character offset. */\n    public int getCharacterOffset() {\n\t\treturn fCurrentEntity != null ? fCurrentEntity.getCharacterOffset() : -1; \n    } // getCharacterOffset():int\n\n    //\n    // HTMLComponent methods\n    //\n\n    /** Returns the default state for a feature. */\n    public Boolean getFeatureDefault(String featureId) {\n        int length = RECOGNIZED_FEATURES != null ? RECOGNIZED_FEATURES.length : 0;\n        for (int i = 0; i < length; i++) {\n            if (RECOGNIZED_FEATURES[i].equals(featureId)) {\n                return RECOGNIZED_FEATURES_DEFAULTS[i];\n            }\n        }\n        return null;\n    } // getFeatureDefault(String):Boolean\n\n    /** Returns the default state for a property. */\n    public Object getPropertyDefault(String propertyId) {\n        int length = RECOGNIZED_PROPERTIES != null ? RECOGNIZED_PROPERTIES.length : 0;\n        for (int i = 0; i < length; i++) {\n            if (RECOGNIZED_PROPERTIES[i].equals(propertyId)) {\n                return RECOGNIZED_PROPERTIES_DEFAULTS[i];\n            }\n        }\n        return null;\n    } // getPropertyDefault(String):Object\n\n    //\n    // XMLComponent methods\n    //\n\n    /** Returns recognized features. */\n    public String[] getRecognizedFeatures() {\n        return RECOGNIZED_FEATURES;\n    } // getRecognizedFeatures():String[]\n\n    /** Returns recognized properties. */\n    public String[] getRecognizedProperties() {\n        return RECOGNIZED_PROPERTIES;\n    } // getRecognizedProperties():String[]\n\n    /** Resets the component. */\n    public void reset(XMLComponentManager manager)\n        throws XMLConfigurationException {\n\n        // get features\n        fAugmentations = manager.getFeature(AUGMENTATIONS);\n        fReportErrors = manager.getFeature(REPORT_ERRORS);\n        fNotifyCharRefs = manager.getFeature(NOTIFY_CHAR_REFS);\n        fNotifyXmlBuiltinRefs = manager.getFeature(NOTIFY_XML_BUILTIN_REFS);\n        fNotifyHtmlBuiltinRefs = manager.getFeature(NOTIFY_HTML_BUILTIN_REFS);\n        fFixWindowsCharRefs = manager.getFeature(FIX_MSWINDOWS_REFS);\n        fScriptStripCDATADelims = manager.getFeature(SCRIPT_STRIP_CDATA_DELIMS);\n        fScriptStripCommentDelims = manager.getFeature(SCRIPT_STRIP_COMMENT_DELIMS);\n        fStyleStripCDATADelims = manager.getFeature(STYLE_STRIP_CDATA_DELIMS);\n        fStyleStripCommentDelims = manager.getFeature(STYLE_STRIP_COMMENT_DELIMS);\n        fIgnoreSpecifiedCharset = manager.getFeature(IGNORE_SPECIFIED_CHARSET);\n        fCDATASections = manager.getFeature(CDATA_SECTIONS);\n        fOverrideDoctype = manager.getFeature(OVERRIDE_DOCTYPE);\n        fInsertDoctype = manager.getFeature(INSERT_DOCTYPE);\n        fNormalizeAttributes = manager.getFeature(NORMALIZE_ATTRIBUTES);\n        fParseNoScriptContent = manager.getFeature(PARSE_NOSCRIPT_CONTENT);\n        fAllowSelfclosingIframe = manager.getFeature(ALLOW_SELFCLOSING_IFRAME);\n        fAllowSelfclosingTags = manager.getFeature(ALLOW_SELFCLOSING_TAGS);\n\n        // get properties\n        fNamesElems = getNamesValue(String.valueOf(manager.getProperty(NAMES_ELEMS)));\n        fNamesAttrs = getNamesValue(String.valueOf(manager.getProperty(NAMES_ATTRS)));\n        fDefaultIANAEncoding = String.valueOf(manager.getProperty(DEFAULT_ENCODING));\n        fErrorReporter = (HTMLErrorReporter)manager.getProperty(ERROR_REPORTER);\n        fDoctypePubid = String.valueOf(manager.getProperty(DOCTYPE_PUBID));\n        fDoctypeSysid = String.valueOf(manager.getProperty(DOCTYPE_SYSID));\n    \n    } // reset(XMLComponentManager)\n\n    /** Sets a feature. */\n    public void setFeature(final String featureId, final boolean state) {\n\n        if (featureId.equals(AUGMENTATIONS)) { \n            fAugmentations = state; \n        }\n        else if (featureId.equals(IGNORE_SPECIFIED_CHARSET)) { \n            fIgnoreSpecifiedCharset = state; \n        }\n        else if (featureId.equals(NOTIFY_CHAR_REFS)) { \n            fNotifyCharRefs = state; \n        }\n        else if (featureId.equals(NOTIFY_XML_BUILTIN_REFS)) { \n            fNotifyXmlBuiltinRefs = state; \n        }\n        else if (featureId.equals(NOTIFY_HTML_BUILTIN_REFS)) { \n            fNotifyHtmlBuiltinRefs = state; \n        }\n        else if (featureId.equals(FIX_MSWINDOWS_REFS)) { \n            fFixWindowsCharRefs = state; \n        }\n        else if (featureId.equals(SCRIPT_STRIP_CDATA_DELIMS)) { \n            fScriptStripCDATADelims = state; \n        }\n        else if (featureId.equals(SCRIPT_STRIP_COMMENT_DELIMS)) { \n            fScriptStripCommentDelims = state; \n        }\n        else if (featureId.equals(STYLE_STRIP_CDATA_DELIMS)) { \n            fStyleStripCDATADelims = state; \n        }\n        else if (featureId.equals(STYLE_STRIP_COMMENT_DELIMS)) { \n            fStyleStripCommentDelims = state; \n        }\n        else if (featureId.equals(PARSE_NOSCRIPT_CONTENT)) { \n            fParseNoScriptContent = state; \n        }\n        else if (featureId.equals(ALLOW_SELFCLOSING_IFRAME)) { \n            fAllowSelfclosingIframe = state; \n        }\n        else if (featureId.equals(ALLOW_SELFCLOSING_TAGS)) { \n            fAllowSelfclosingTags = state; \n        }\n\n    } // setFeature(String,boolean)\n\n    /** Sets a property. */\n    public void setProperty(String propertyId, Object value)\n        throws XMLConfigurationException {\n    \n        if (propertyId.equals(NAMES_ELEMS)) {\n            fNamesElems = getNamesValue(String.valueOf(value));\n            return;\n        }\n\n        if (propertyId.equals(NAMES_ATTRS)) {\n            fNamesAttrs = getNamesValue(String.valueOf(value));\n            return;\n        }\n\n        if (propertyId.equals(DEFAULT_ENCODING)) {\n            fDefaultIANAEncoding = String.valueOf(value);\n            return;\n        }\n\n    } // setProperty(String,Object)\n\n    //\n    // XMLDocumentScanner methods\n    //\n\n    /** Sets the input source. */\n    public void setInputSource(XMLInputSource source) throws IOException {\n\n        // reset state\n        fElementCount = 0;\n        fElementDepth = -1;\n        fByteStream = null;\n        fCurrentEntityStack.removeAllElements();\n\n        fBeginLineNumber = 1;\n        fBeginColumnNumber = 1;\n        fBeginCharacterOffset = 0;\n        fEndLineNumber = fBeginLineNumber;\n        fEndColumnNumber = fBeginColumnNumber;\n        fEndCharacterOffset = fBeginCharacterOffset;\n\n        // reset encoding information\n        fIANAEncoding = fDefaultIANAEncoding;\n        fJavaEncoding = fIANAEncoding;\n\n        // get location information\n        String encoding = source.getEncoding();\n        String publicId = source.getPublicId();\n        String baseSystemId = source.getBaseSystemId();\n        String literalSystemId = source.getSystemId();\n        String expandedSystemId = expandSystemId(literalSystemId, baseSystemId);\n\n        // open stream\n        Reader reader = source.getCharacterStream();\n        if (reader == null) {\n            InputStream inputStream = source.getByteStream();\n            if (inputStream == null) {\n                URL url = new URL(expandedSystemId);\n                inputStream = url.openStream();\n            }\n            fByteStream = new PlaybackInputStream(inputStream);\n            String[] encodings = new String[2];\n            if (encoding == null) {\n                fByteStream.detectEncoding(encodings);\n            }\n            else {\n                encodings[0] = encoding;\n            }\n            if (encodings[0] == null) {\n                encodings[0] = fDefaultIANAEncoding;\n                if (fReportErrors) {\n                    fErrorReporter.reportWarning(\"HTML1000\", null);\n                }\n            }\n            if (encodings[1] == null) {\n                encodings[1] = EncodingMap.getIANA2JavaMapping(encodings[0].toUpperCase(Locale.ENGLISH));\n                if (encodings[1] == null) {\n                    encodings[1] = encodings[0];\n                    if (fReportErrors) {\n                        fErrorReporter.reportWarning(\"HTML1001\", new Object[]{encodings[0]});\n                    }\n                }\n            }\n            fIANAEncoding = encodings[0];\n            fJavaEncoding = encodings[1];\n            /* PATCH: Asgeir Asgeirsson */\n            fIso8859Encoding = fIANAEncoding == null \n                            || fIANAEncoding.toUpperCase(Locale.ENGLISH).startsWith(\"ISO-8859\")\n                            || fIANAEncoding.equalsIgnoreCase(fDefaultIANAEncoding);\n            encoding = fIANAEncoding;\n            reader = new InputStreamReader(fByteStream, fJavaEncoding);\n        }\n        fCurrentEntity = new CurrentEntity(reader, encoding,\n                                           publicId, baseSystemId,\n                                           literalSystemId, expandedSystemId);\n\n        // set scanner and state\n        setScanner(fContentScanner);\n        setScannerState(STATE_START_DOCUMENT);\n\n    } // setInputSource(XMLInputSource)\n\n    /** Scans the document. */\n    public boolean scanDocument(boolean complete) throws XNIException, IOException {\n        do {\n            if (!fScanner.scan(complete)) {\n                return false;\n            }\n        } while (complete);\n        return true;\n    } // scanDocument(boolean):boolean\n\n    /** Sets the document handler. */\n    public void setDocumentHandler(XMLDocumentHandler handler) {\n        fDocumentHandler = handler;\n    } // setDocumentHandler(XMLDocumentHandler)\n\n    // @since Xerces 2.1.0\n\n    /** Returns the document handler. */\n    public XMLDocumentHandler getDocumentHandler() {\n        return fDocumentHandler;\n    } // getDocumentHandler():XMLDocumentHandler\n\n    //\n    // Protected static methods\n    //\n\n    /** Returns the value of the specified attribute, ignoring case. */\n    protected static String getValue(XMLAttributes attrs, String aname) {\n        int length = attrs != null ? attrs.getLength() : 0;\n        for (int i = 0; i < length; i++) {\n            if (attrs.getQName(i).equalsIgnoreCase(aname)) {\n                return attrs.getValue(i);\n            }\n        }\n        return null;\n    } // getValue(XMLAttributes,String):String\n\n    /**\n     * Expands a system id and returns the system id as a URI, if\n     * it can be expanded. A return value of null means that the\n     * identifier is already expanded. An exception thrown\n     * indicates a failure to expand the id.\n     *\n     * @param systemId The systemId to be expanded.\n     *\n     * @return Returns the URI string representing the expanded system\n     *         identifier. A null value indicates that the given\n     *         system identifier is already expanded.\n     *\n     */\n    public static String expandSystemId(String systemId, String baseSystemId) {\n\n        // check for bad parameters id\n        if (systemId == null || systemId.length() == 0) {\n            return systemId;\n        }\n        // if id already expanded, return\n        try {\n            URI uri = new URI(systemId);\n            if (uri != null) {\n                return systemId;\n            }\n        }\n        catch (URI.MalformedURIException e) {\n            // continue on...\n        }\n        // normalize id\n        String id = fixURI(systemId);\n\n        // normalize base\n        URI base = null;\n        URI uri = null;\n        try {\n            if (baseSystemId == null || baseSystemId.length() == 0 ||\n                baseSystemId.equals(systemId)) {\n                String dir;\n                try {\n                    dir = fixURI(System.getProperty(\"user.dir\"));\n                }\n                catch (SecurityException se) {\n                    dir = \"\";\n                }\n                if (!dir.endsWith(\"/\")) {\n                    dir = dir + \"/\";\n                }\n                base = new URI(\"file\", \"\", dir, null, null);\n            }\n            else {\n                try {\n                    base = new URI(fixURI(baseSystemId));\n                }\n                catch (URI.MalformedURIException e) {\n                    String dir;\n                    try {\n                        dir = fixURI(System.getProperty(\"user.dir\"));\n                    }\n                    catch (SecurityException se) {\n                        dir = \"\";\n                    }\n                    if (baseSystemId.indexOf(':') != -1) {\n                        // for xml schemas we might have baseURI with\n                        // a specified drive\n                        base = new URI(\"file\", \"\", fixURI(baseSystemId), null, null);\n                    }\n                    else {\n                        if (!dir.endsWith(\"/\")) {\n                            dir = dir + \"/\";\n                        }\n                        dir = dir + fixURI(baseSystemId);\n                        base = new URI(\"file\", \"\", dir, null, null);\n                    }\n                }\n             }\n             // expand id\n             uri = new URI(base, id);\n        }\n        catch (URI.MalformedURIException e) {\n            // let it go through\n        }\n\n        if (uri == null) {\n            return systemId;\n        }\n        return uri.toString();\n\n    } // expandSystemId(String,String):String\n\n    /**\n     * Fixes a platform dependent filename to standard URI form.\n     *\n     * @param str The string to fix.\n     *\n     * @return Returns the fixed URI string.\n     */\n    protected static String fixURI(String str) {\n\n        // handle platform dependent strings\n        str = str.replace(java.io.File.separatorChar, '/');\n\n        // Windows fix\n        if (str.length() >= 2) {\n            char ch1 = str.charAt(1);\n            // change \"C:blah\" to \"/C:blah\"\n            if (ch1 == ':') {\n                final char ch0 = String.valueOf(str.charAt(0)).toUpperCase(Locale.ENGLISH).charAt(0);\n                if (ch0 >= 'A' && ch0 <= 'Z') {\n                    str = \"/\" + str;\n                }\n            }\n            // change \"//blah\" to \"file://blah\"\n            else if (ch1 == '/' && str.charAt(0) == '/') {\n                str = \"file:\" + str;\n            }\n        }\n\n        // done\n        return str;\n\n    } // fixURI(String):String\n\n    /** Modifies the given name based on the specified mode. */\n    protected static final String modifyName(String name, short mode) {\n        switch (mode) {\n            case NAMES_UPPERCASE: return name.toUpperCase(Locale.ENGLISH);\n            case NAMES_LOWERCASE: return name.toLowerCase(Locale.ENGLISH);\n        }\n        return name;\n    } // modifyName(String,short):String\n\n    /**\n     * Converts HTML names string value to constant value. \n     *\n     * @see #NAMES_NO_CHANGE\n     * @see #NAMES_LOWERCASE\n     * @see #NAMES_UPPERCASE\n     */\n    protected static final short getNamesValue(String value) {\n        if (value.equals(\"lower\")) {\n            return NAMES_LOWERCASE;\n        }\n        if (value.equals(\"upper\")) {\n            return NAMES_UPPERCASE;\n        }\n        return NAMES_NO_CHANGE;\n    } // getNamesValue(String):short\n\n    /**\n     * Fixes Microsoft Windows&reg; specific characters.\n     * <p>\n     * Details about this common problem can be found at \n     * <a href='http://www.cs.tut.fi/~jkorpela/www/windows-chars.html'>http://www.cs.tut.fi/~jkorpela/www/windows-chars.html</a>\n     */\n    protected int fixWindowsCharacter(int origChar) {\n        /* PATCH: Asgeir Asgeirsson */\n        switch(origChar) {\n            case 130: return 8218;\n            case 131: return 402;\n            case 132: return 8222;\n            case 133: return 8230;\n            case 134: return 8224;\n            case 135: return 8225;\n            case 136: return 710;\n            case 137: return 8240;\n            case 138: return 352;\n            case 139: return 8249;\n            case 140: return 338;\n            case 145: return 8216;\n            case 146: return 8217;\n            case 147: return 8220;\n            case 148: return 8221;\n            case 149: return 8226;\n            case 150: return 8211;\n            case 151: return 8212;\n            case 152: return 732;\n            case 153: return 8482;\n            case 154: return 353;\n            case 155: return 8250;\n            case 156: return 339;\n            case 159: return 376;\n        }\n        return origChar;\n    } // fixWindowsCharacter(int):int\n\n    //\n    // Protected methods\n    //\n\n    // i/o\n    /** Reads a single character. */\n    protected int read() throws IOException {\n    \treturn fCurrentEntity.read();\n    }\n\n\n    // debugging\n\n    /** Sets the scanner. */\n    protected void setScanner(Scanner scanner) {\n        fScanner = scanner;\n        if (DEBUG_SCANNER) {\n            System.out.print(\"$$$ setScanner(\");\n            System.out.print(scanner!=null?scanner.getClass().getName():\"null\");\n            System.out.println(\");\");\n        }\n    } // setScanner(Scanner)\n    \n    /** Sets the scanner state. */\n    protected void setScannerState(short state) {\n        fScannerState = state;\n        if (DEBUG_SCANNER_STATE) {\n            System.out.print(\"$$$ setScannerState(\");\n            switch (fScannerState) {\n                case STATE_CONTENT: { System.out.print(\"STATE_CONTENT\"); break; }\n                case STATE_MARKUP_BRACKET: { System.out.print(\"STATE_MARKUP_BRACKET\"); break; }\n                case STATE_START_DOCUMENT: { System.out.print(\"STATE_START_DOCUMENT\"); break; }\n                case STATE_END_DOCUMENT: { System.out.print(\"STATE_END_DOCUMENT\"); break; }\n            }\n            System.out.println(\");\");\n        }\n    } // setScannerState(short)\n\n    // scanning\n\n    /** Scans a DOCTYPE line. */\n    protected void scanDoctype() throws IOException {\n        String root = null;\n        String pubid = null;\n        String sysid = null;\n\n        if (skipSpaces()) {\n            root = scanName(true);\n            if (root == null) {\n                if (fReportErrors) {\n                    fErrorReporter.reportError(\"HTML1014\", null);\n                }\n            }\n            else {\n                root = modifyName(root, fNamesElems);\n            }\n            if (skipSpaces()) {\n                if (skip(\"PUBLIC\", false)) {\n                    skipSpaces();\n                    pubid = scanLiteral();\n                    if (skipSpaces()) {\n                        sysid = scanLiteral();\n                    }\n                }\n                else if (skip(\"SYSTEM\", false)) {\n                    skipSpaces();\n                    sysid = scanLiteral();\n                }\n            }\n        }\n        int c;\n        while ((c = fCurrentEntity.read()) != -1) {\n            if (c == '<') {\n            \tfCurrentEntity.rewind();\n                break;\n            }\n            if (c == '>') {\n                break;\n            }\n            if (c == '[') {\n                skipMarkup(true);\n                break;\n            }\n        }\n\n        if (fDocumentHandler != null) {\n            if (fOverrideDoctype) {\n                pubid = fDoctypePubid;\n                sysid = fDoctypeSysid;\n            }\n            fEndLineNumber = fCurrentEntity.getLineNumber();\n            fEndColumnNumber = fCurrentEntity.getColumnNumber();\n            fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n            fDocumentHandler.doctypeDecl(root, pubid, sysid, locationAugs());\n        }\n\n    } // scanDoctype()\n\n    /** Scans a quoted literal. */\n    protected String scanLiteral() throws IOException {\n        int quote = fCurrentEntity.read();\n        if (quote == '\\'' || quote == '\"') {\n            StringBuffer str = new StringBuffer();\n            int c;\n            while ((c = fCurrentEntity.read()) != -1) {\n                if (c == quote) {\n                    break;\n                }\n                if (c == '\\r' || c == '\\n') {\n                \tfCurrentEntity.rewind();\n                    // NOTE: This collapses newlines to a single space.\n                    //       [Q] Is this the right thing to do here? -Ac\n                    skipNewlines();\n                    str.append(' ');\n                }\n                else if (c == '<') {\n                \tfCurrentEntity.rewind();\n                    break;\n                }\n                else {\n                    appendChar(str, c);\n                }\n            }\n            if (c == -1) {\n                if (fReportErrors) {\n                    fErrorReporter.reportError(\"HTML1007\", null);\n                }\n                throw new EOFException();\n            }\n            return str.toString();\n        }\n       \tfCurrentEntity.rewind();\n        return null;\n    } // scanLiteral():String\n\n    /** Scans a name. */\n    protected String scanName(final boolean strict) throws IOException {\n        if (DEBUG_BUFFER) { \n            fCurrentEntity.debugBufferIfNeeded(\"(scanName: \");\n        }\n        if (fCurrentEntity.offset == fCurrentEntity.length) {\n            if (fCurrentEntity.load(0) == -1) {\n                if (DEBUG_BUFFER) { \n                    fCurrentEntity.debugBufferIfNeeded(\")scanName: \");\n                }\n                return null;\n            }\n        }\n        int offset = fCurrentEntity.offset;\n        while (true) {\n            while (fCurrentEntity.hasNext()) {\n                char c = fCurrentEntity.getNextChar();\n                if ((strict && (!Character.isLetterOrDigit(c) && c != '-' && c != '.' && c != ':' && c != '_'))\n                    || (!strict && (Character.isWhitespace(c) || c == '=' || c == '/' || c == '>'))) {\n                \tfCurrentEntity.rewind();\n                    break;\n                }\n            }\n            if (fCurrentEntity.offset == fCurrentEntity.length) {\n                int length = fCurrentEntity.length - offset;\n                System.arraycopy(fCurrentEntity.buffer, offset, fCurrentEntity.buffer, 0, length);\n                int count = fCurrentEntity.load(length);\n                offset = 0;\n                if (count == -1) {\n                    break;\n                }\n            }\n            else {\n                break;\n            }\n        }\n        int length = fCurrentEntity.offset - offset;\n        String name = length > 0 ? new String(fCurrentEntity.buffer, offset, length) : null;\n        if (DEBUG_BUFFER) { \n            fCurrentEntity.debugBufferIfNeeded(\")scanName: \", \" -> \\\"\" + name + '\"');\n        }\n        return name;\n    } // scanName():String\n\n    /** Scans an entity reference. */\n    protected int scanEntityRef(final XMLStringBuffer str, final boolean content) \n        throws IOException {\n        str.clear();\n        str.append('&');\n        boolean endsWithSemicolon = false;\n        while (true) {\n            int c = fCurrentEntity.read();\n            if (c == ';') {\n                str.append(';');\n                endsWithSemicolon = true;\n                break;\n            }\n            else if (c == -1) {\n            \tbreak;\n            }\n            else if (!ENTITY_CHARS.get(c) && c != '#') {\n            \tfCurrentEntity.rewind();\n                break;\n            }\n            appendChar(str, c);\n        }\n\n        if (!endsWithSemicolon) {\n            if (fReportErrors) {\n                fErrorReporter.reportWarning(\"HTML1004\", null);\n            }\n        }\n        if (str.length == 1) {\n            if (content && fDocumentHandler != null && fElementCount >= fElementDepth) {\n                fEndLineNumber = fCurrentEntity.getLineNumber();\n                fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                fDocumentHandler.characters(str, locationAugs());\n            }\n            return -1;\n        }\n\n        final String name;\n        if (endsWithSemicolon)\n        \tname = str.toString().substring(1, str.length -1);\n        else\n        \tname = str.toString().substring(1);\n\n        if (name.startsWith(\"#\")) {\n            int value = -1;\n            try {\n                if (name.startsWith(\"#x\") || name.startsWith(\"#X\")) {\n                    value = Integer.parseInt(name.substring(2), 16);\n                }\n                else {\n                    value = Integer.parseInt(name.substring(1));\n                }\n                /* PATCH: Asgeir Asgeirsson */\n                if (fFixWindowsCharRefs && fIso8859Encoding) {\n                    value = fixWindowsCharacter(value);\n                }\n                if (content && fDocumentHandler != null && fElementCount >= fElementDepth) {\n                    fEndLineNumber = fCurrentEntity.getLineNumber();\n                    fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                    fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                    if (fNotifyCharRefs) {\n                        XMLResourceIdentifier id = resourceId();\n                        String encoding = null;\n                        fDocumentHandler.startGeneralEntity(name, id, encoding, locationAugs());\n                    }\n                    str.clear();\n                    try {\n                    \tappendChar(str, value);\n                    }\n                    catch (final IllegalArgumentException e) { // when value is not valid as UTF-16 \n        \t\t        if (fReportErrors) {\n        \t\t            fErrorReporter.reportError(\"HTML1005\", new Object[]{name});\n        \t\t        }\n                \t\tstr.append(REPLACEMENT_CHARACTER);\n                    }\n                    fDocumentHandler.characters(str, locationAugs());\n                    if (fNotifyCharRefs) {\n                        fDocumentHandler.endGeneralEntity(name, locationAugs());\n                    }\n                }\n            }\n            catch (NumberFormatException e) {\n                if (fReportErrors) {\n                    fErrorReporter.reportError(\"HTML1005\", new Object[]{name});\n                }\n                if (content && fDocumentHandler != null && fElementCount >= fElementDepth) {\n                    fEndLineNumber = fCurrentEntity.getLineNumber();\n                    fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                    fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                    fDocumentHandler.characters(str, locationAugs());\n                }\n            }\n            return value;\n        }\n\n        int c = HTMLEntities.get(name);\n        // in attributes, some incomplete entities should be recognized, not all\n        // TODO: investigate to find which ones (there are differences between browsers)\n        // in a first time, consider only those that behave the same in FF and IE \n        final boolean invalidEntityInAttribute = !content && !endsWithSemicolon && c > 256;\n        if (c == -1 || invalidEntityInAttribute) {\n            if (fReportErrors) {\n                fErrorReporter.reportWarning(\"HTML1006\", new Object[]{name});\n            }\n            if (content && fDocumentHandler != null && fElementCount >= fElementDepth) {\n                fEndLineNumber = fCurrentEntity.getLineNumber();\n                fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                fDocumentHandler.characters(str, locationAugs());\n            }\n            return -1;\n        }\n        if (content && fDocumentHandler != null && fElementCount >= fElementDepth) {\n            fEndLineNumber = fCurrentEntity.getLineNumber();\n            fEndColumnNumber = fCurrentEntity.getColumnNumber();\n            fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n            boolean notify = fNotifyHtmlBuiltinRefs || (fNotifyXmlBuiltinRefs && builtinXmlRef(name));\n            if (notify) {\n                XMLResourceIdentifier id = resourceId();\n                String encoding = null;\n                fDocumentHandler.startGeneralEntity(name, id, encoding, locationAugs());\n            }\n            str.clear();\n            appendChar(str, c);\n            fDocumentHandler.characters(str, locationAugs());\n            if (notify) {\n                fDocumentHandler.endGeneralEntity(name, locationAugs());\n            }\n        }\n        return c;\n\n    } // scanEntityRef(XMLStringBuffer,boolean):int\n\n    /** Returns true if the specified text is present and is skipped. */\n    protected boolean skip(String s, boolean caseSensitive) throws IOException {\n        int length = s != null ? s.length() : 0;\n        for (int i = 0; i < length; i++) {\n            if (fCurrentEntity.offset == fCurrentEntity.length) {\n                System.arraycopy(fCurrentEntity.buffer, fCurrentEntity.offset - i, fCurrentEntity.buffer, 0, i);\n                if (fCurrentEntity.load(i) == -1) {\n                    fCurrentEntity.offset = 0;\n                    return false;\n                }\n            }\n            char c0 = s.charAt(i);\n            char c1 = fCurrentEntity.getNextChar();\n            if (!caseSensitive) {\n                c0 = String.valueOf(c0).toUpperCase(Locale.ENGLISH).charAt(0);\n                c1 = String.valueOf(c1).toUpperCase(Locale.ENGLISH).charAt(0);\n            }\n            if (c0 != c1) {\n            \tfCurrentEntity.rewind(i + 1);\n                return false;\n            }\n        }\n        return true;\n    } // skip(String):boolean\n\n    /** Skips markup. */\n    protected boolean skipMarkup(boolean balance) throws IOException {\n        if (DEBUG_BUFFER) { \n            fCurrentEntity.debugBufferIfNeeded(\"(skipMarkup: \");\n        }\n        int depth = 1;\n        boolean slashgt = false;\n        OUTER: while (true) {\n            if (fCurrentEntity.offset == fCurrentEntity.length) {\n                if (fCurrentEntity.load(0) == -1) {\n                    break OUTER;\n                }\n            }\n            while (fCurrentEntity.hasNext()) {\n                char c = fCurrentEntity.getNextChar();\n                if (balance && c == '<') {\n                    depth++;\n                }\n                else if (c == '>') {\n                    depth--;\n                    if (depth == 0) {\n                        break OUTER;\n                    }\n                }\n                else if (c == '/') {\n                    if (fCurrentEntity.offset == fCurrentEntity.length) {\n                        if (fCurrentEntity.load(0) == -1) {\n                            break OUTER;\n                        }\n                    }\n                    c = fCurrentEntity.getNextChar();\n                    if (c == '>') {\n                        slashgt = true;\n                        depth--;\n                        if (depth == 0) {\n                            break OUTER;\n                        }\n                    }\n                    else {\n                    \tfCurrentEntity.rewind();\n                    }\n                }\n                else if (c == '\\r' || c == '\\n') {\n                \tfCurrentEntity.rewind();\n                    skipNewlines();\n                }\n            }\n        }\n        if (DEBUG_BUFFER) { \n            fCurrentEntity.debugBufferIfNeeded(\")skipMarkup: \", \" -> \" + slashgt);\n        }\n        return slashgt;\n    } // skipMarkup():boolean\n\n    /** Skips whitespace. */\n    protected boolean skipSpaces() throws IOException {\n        if (DEBUG_BUFFER) { \n            fCurrentEntity.debugBufferIfNeeded(\"(skipSpaces: \");\n        }\n        boolean spaces = false;\n        while (true) {\n            if (fCurrentEntity.offset == fCurrentEntity.length) {\n                if (fCurrentEntity.load(0) == -1) {\n                    break;\n                }\n            }\n            char c = fCurrentEntity.getNextChar();\n            if (!Character.isWhitespace(c)) {\n            \tfCurrentEntity.rewind();\n                break;\n            }\n            spaces = true;\n            if (c == '\\r' || c == '\\n') {\n            \tfCurrentEntity.rewind();\n                skipNewlines();\n                continue;\n            }\n        }\n        if (DEBUG_BUFFER) { \n            fCurrentEntity.debugBufferIfNeeded(\")skipSpaces: \", \" -> \" + spaces);\n        }\n        return spaces;\n    } // skipSpaces()\n\n    /** Skips newlines and returns the number of newlines skipped. */\n    protected int skipNewlines() throws IOException {\n        if (DEBUG_BUFFER) { \n            fCurrentEntity.debugBufferIfNeeded(\"(skipNewlines: \");\n        }\n\n        if (!fCurrentEntity.hasNext()) {\n            if (fCurrentEntity.load(0) == -1) {\n                if (DEBUG_BUFFER) { \n                    fCurrentEntity.debugBufferIfNeeded(\")skipNewlines: \");\n                }\n                return 0;\n            }\n        }\n        char c = fCurrentEntity.getCurrentChar();\n        int newlines = 0;\n        int offset = fCurrentEntity.offset;\n        if (c == '\\n' || c == '\\r') {\n            do {\n                c = fCurrentEntity.getNextChar();\n                if (c == '\\r') {\n                    newlines++;\n                    if (fCurrentEntity.offset == fCurrentEntity.length) {\n                        offset = 0;\n                        fCurrentEntity.offset = newlines;\n                        if (fCurrentEntity.load(newlines) == -1) {\n                            break;\n                        }\n                    }\n                    if (fCurrentEntity.getCurrentChar() == '\\n') {\n                        fCurrentEntity.offset++;\n                        fCurrentEntity.characterOffset_++;\n                        offset++;\n                    }\n                }\n                else if (c == '\\n') {\n                    newlines++;\n                    if (fCurrentEntity.offset == fCurrentEntity.length) {\n                        offset = 0;\n                        fCurrentEntity.offset = newlines;\n                        if (fCurrentEntity.load(newlines) == -1) {\n                            break;\n                        }\n                    }\n                }\n                else {\n                    fCurrentEntity.rewind();\n                    break;\n                }\n            } while (fCurrentEntity.offset < fCurrentEntity.length - 1);\n            fCurrentEntity.incLine(newlines);\n        }\n        if (DEBUG_BUFFER) { \n            fCurrentEntity.debugBufferIfNeeded(\")skipNewlines: \", \" -> \" + newlines);\n        }\n        return newlines;\n    } // skipNewlines(int):int\n\n    // infoset utility methods\n\n    /** Returns an augmentations object with a location item added. */\n    protected final Augmentations locationAugs() {\n        HTMLAugmentations augs = null;\n        if (fAugmentations) {\n            fLocationItem.setValues(fBeginLineNumber, fBeginColumnNumber, \n                                    fBeginCharacterOffset, fEndLineNumber,\n                                    fEndColumnNumber, fEndCharacterOffset);\n            augs = fInfosetAugs;\n            augs.removeAllItems();\n            augs.putItem(AUGMENTATIONS, fLocationItem);\n        }\n        return augs;\n    } // locationAugs():Augmentations\n\n    /** Returns an augmentations object with a synthesized item added. */\n    protected final Augmentations synthesizedAugs() {\n        HTMLAugmentations augs = null;\n        if (fAugmentations) {\n            augs = fInfosetAugs;\n            augs.removeAllItems();\n            augs.putItem(AUGMENTATIONS, SYNTHESIZED_ITEM);\n        }\n        return augs;\n    } // synthesizedAugs():Augmentations\n\n    /** Returns an empty resource identifier. */\n    protected final XMLResourceIdentifier resourceId() {\n        /***/\n        fResourceId.clear();\n        return fResourceId;\n        /***\n        // NOTE: Unfortunately, the Xerces DOM parser classes expect a\n        //       non-null resource identifier object to be passed to\n        //       startGeneralEntity. -Ac\n        return null;\n        /***/\n    } // resourceId():XMLResourceIdentifier\n\n    //\n    // Protected static methods\n    //\n\n    /** Returns true if the name is a built-in XML general entity reference. */\n    protected static boolean builtinXmlRef(String name) {\n        return name.equals(\"amp\") || name.equals(\"lt\") || name.equals(\"gt\") ||\n               name.equals(\"quot\") || name.equals(\"apos\");\n    } // builtinXmlRef(String):boolean\n\n    //\n    // Private methods\n    //\n\n    /**\n     * Append a character to an XMLStringBuffer. The character is an int value, and can either be a\n     * single UTF-16 character or a supplementary character represented by two UTF-16 code points.\n     *\n     * @param str The XMLStringBuffer to append to.\n     * @param value The character value.\n     */\n    private void appendChar( XMLStringBuffer str, int value )\n    {\n        if ( value > Character.MAX_VALUE )\n        {\n            char[] chars = Character.toChars( value );\n\n            str.append( chars, 0, chars.length );\n        }\n        else\n        {\n            str.append( (char) value );\n        }\n    }\n\n    /**\n     * Append a character to a StringBuffer. The character is an int value, and can either be a\n     * single UTF-16 character or a supplementary character represented by two UTF-16 code points.\n     *\n     * @param str The StringBuffer to append to.\n     * @param value The character value.\n     */\n    private void appendChar( StringBuffer str, int value )\n    {\n        if ( value > Character.MAX_VALUE )\n        {\n            char[] chars = Character.toChars( value );\n\n            str.append( chars, 0, chars.length );\n        }\n        else\n        {\n            str.append( (char) value );\n        }\n    }\n\n    //\n    // Interfaces\n    //\n\n    /**\n     * Basic scanner interface.\n     *\n     * @author Andy Clark\n     */\n    public interface Scanner {\n\n        //\n        // Scanner methods\n        //\n\n        /** \n         * Scans part of the document. This interface allows scanning to\n         * be performed in a pulling manner.\n         *\n         * @param complete True if the scanner should not return until\n         *                 scanning is complete.\n         *\n         * @return True if additional scanning is required.\n         *\n         * @throws IOException Thrown if I/O error occurs.\n         */\n        public boolean scan(boolean complete) throws IOException;\n\n    } // interface Scanner\n\n    //\n    // Classes\n    //\n\n    /**\n     * Current entity.\n     *\n     * @author Andy Clark\n     */\n    public static class CurrentEntity {\n\n        //\n        // Data\n        //\n\n        /** Character stream. */\n        private Reader stream_;\n\n        /** Encoding. */\n        private String encoding;\n\n        /** Public identifier. */\n        public final String publicId;\n\n        /** Base system identifier. */\n        public final String baseSystemId;\n\n        /** Literal system identifier. */\n        public final String literalSystemId;\n\n        /** Expanded system identifier. */\n        public final String expandedSystemId;\n\n\t\t/** XML version. */\n\t\tpublic final String version = \"1.0\";\n\n        /** Line number. */\n        private int lineNumber_ = 1;\n\n        /** Column number. */\n        private int columnNumber_ = 1;\n        \n        /** Character offset in the file. */\n        public int characterOffset_ = 0;\n\n        // buffer\n\n        /** Character buffer. */\n        public char[] buffer = new char[DEFAULT_BUFFER_SIZE];\n\n        /** Offset into character buffer. */\n        public int offset = 0;\n\n        /** Length of characters read into character buffer. */\n        public int length = 0;\n        \n        private boolean endReached_ = false;\n\n        //\n        // Constructors\n        //\n\n        /** Constructs an entity from the specified stream. */\n        public CurrentEntity(Reader stream, String encoding, \n                             String publicId, String baseSystemId,\n                             String literalSystemId, String expandedSystemId) {\n            stream_ = stream;\n            this.encoding = encoding;\n            this.publicId = publicId;\n            this.baseSystemId = baseSystemId;\n            this.literalSystemId = literalSystemId;\n            this.expandedSystemId = expandedSystemId;\n        } // <init>(Reader,String,String,String,String)\n\n\t\tprivate char getCurrentChar() {\n        \treturn buffer[offset];\n        }\n\n        /**\n         * Gets the current character and moves to next one.\n         * @return\n         */\n        private char getNextChar() {\n\t        characterOffset_++;\n\t        columnNumber_++;\n        \treturn buffer[offset++];\n        }\n        private void closeQuietly() {\n            try {\n                stream_.close();\n            }\n            catch (IOException e) {\n                // ignore\n            }\n\t\t}\n\n\t\t/**\n         * Indicates if there are characters left.\n         */\n        boolean hasNext() {\n        \treturn offset < length;        \t\n        }\n\n        /** \n         * Loads a new chunk of data into the buffer and returns the number of\n         * characters loaded or -1 if no additional characters were loaded.\n         *\n         * @param offset The offset at which new characters should be loaded.\n         */\n        protected int load(int offset) throws IOException {\n            if (DEBUG_BUFFER) { \n                debugBufferIfNeeded(\"(load: \");\n            }\n            // resize buffer, if needed\n            if (offset == buffer.length) {\n                int adjust = buffer.length / 4;\n                char[] array = new char[buffer.length + adjust];\n                System.arraycopy(buffer, 0, array, 0, length);\n                buffer = array;\n            }\n            // read a block of characters\n            int count = stream_.read(buffer, offset, buffer.length - offset);\n            if (count == -1) {\n            \tendReached_ = true;\n            }\n            length = count != -1 ? count + offset : offset;\n            this.offset = offset;\n            if (DEBUG_BUFFER) { \n                debugBufferIfNeeded(\")load: \", \" -> \" + count);\n            }\n            return count;\n        } // load():int\n\n        /** Reads a single character. */\n        protected int read() throws IOException {\n            if (DEBUG_BUFFER) { \n                debugBufferIfNeeded(\"(read: \");\n            }\n            if (offset == length) {\n                if (endReached_) {\n                \treturn -1;\n                }\n                if (load(0) == -1) {\n                    if (DEBUG_BUFFER) { \n                        System.out.println(\")read: -> -1\");\n                    }\n                    return -1;\n                }\n            }\n            final char c = buffer[offset++];\n\t        characterOffset_++;\n\t        columnNumber_++;\n\n            if (DEBUG_BUFFER) { \n                debugBufferIfNeeded(\")read: \", \" -> \" + c);\n            }\n            return c;\n        } // read():int\n\n        /** Prints the contents of the character buffer to standard out. */\n        private void debugBufferIfNeeded(final String prefix) {\n        \tdebugBufferIfNeeded(prefix, \"\");\n        }\n        /** Prints the contents of the character buffer to standard out. */\n        private void debugBufferIfNeeded(final String prefix, final String suffix) {\n            if (DEBUG_BUFFER) {\n                System.out.print(prefix);\n                System.out.print('[');\n                System.out.print(length);\n                System.out.print(' ');\n                System.out.print(offset);\n                if (length > 0) {\n                    System.out.print(\" \\\"\");\n                    for (int i = 0; i < length; i++) {\n                        if (i == offset) {\n                            System.out.print('^');\n                        }\n                        char c = buffer[i];\n                        switch (c) {\n                            case '\\r': {\n                                System.out.print(\"\\\\r\");\n                                break;\n                            }\n                            case '\\n': {\n                                System.out.print(\"\\\\n\");\n                                break;\n                            }\n                            case '\\t': {\n                                System.out.print(\"\\\\t\");\n                                break;\n                            }\n                            case '\"': {\n                                System.out.print(\"\\\\\\\"\");\n                                break;\n                            }\n                            default: {\n                                System.out.print(c);\n                            }\n                        }\n                    }\n                    if (offset == length) {\n                        System.out.print('^');\n                    }\n                    System.out.print('\"');\n                }\n                System.out.print(']');\n                System.out.print(suffix);\n                System.out.println();\n            }\n        } // printBuffer()\n\n\t\tprivate void setStream(final InputStreamReader inputStreamReader) {\n            stream_ = inputStreamReader;\n            offset = length = characterOffset_ = 0;\n            lineNumber_ = columnNumber_ = 1;\n            encoding = inputStreamReader.getEncoding();\n\t\t}\n\t\t\n\t\t/**\n\t\t * Goes back, cancelling the effect of the previous read() call.\n\t\t */\n\t\tprivate void rewind() {\n\t        offset--;\n\t        characterOffset_--;\n\t        columnNumber_--;\n\t\t}\n        private void rewind(int i) {\n            offset -= i;\n            characterOffset_ -= i;\n            columnNumber_ -= i;\n\t\t}\n\n\t\tprivate void incLine() {\n            lineNumber_++;\n            columnNumber_ = 1;\n\t\t}\n\n\t\tprivate void incLine(int nbLines) {\n            lineNumber_ += nbLines;\n            columnNumber_ = 1;\n\t\t}\n\n\t\tpublic int getLineNumber() {\n\t\t\treturn lineNumber_;\n\t\t}\n\n\t\tprivate void resetBuffer(final XMLStringBuffer buffer, final int lineNumber,\n\t\t\t\tfinal int columnNumber, final int characterOffset) {\n        \tlineNumber_ = lineNumber;\n        \tcolumnNumber_ = columnNumber;\n        \tthis.characterOffset_ = characterOffset;\n        \tthis.buffer = buffer.ch;\n        \tthis.offset = buffer.offset;\n        \tthis.length = buffer.length;\n\t\t}\n\n\t\tprivate int getColumnNumber() {\n\t\t\treturn columnNumber_;\n\t\t}\n\n\t\tprivate void restorePosition(int originalOffset,\n\t\t\t\tint originalColumnNumber, int originalCharacterOffset) {\n\t        this.offset = originalOffset;\n\t        this.columnNumber_ = originalColumnNumber;\n\t        this.characterOffset_ = originalCharacterOffset;\n\t\t}\n\n\t\tprivate int getCharacterOffset() {\n\t\t\treturn characterOffset_;\n\t\t}\n    } // class CurrentEntity\n\n    /**\n     * The primary HTML document scanner.\n     *\n     * @author Andy Clark\n     */\n    public class ContentScanner \n        implements Scanner {\n\n        //\n        // Data\n        //\n\n        // temp vars\n\n        /** A qualified name. */\n        private final QName fQName = new QName();\n\n        /** Attributes. */\n        private final XMLAttributesImpl fAttributes = new XMLAttributesImpl();\n\n        //\n        // Scanner methods\n        //\n\n        /** Scan. */\n        public boolean scan(boolean complete) throws IOException {\n            boolean next;\n            do {\n                try {\n                    next = false;\n                    switch (fScannerState) {\n                        case STATE_CONTENT: {\n                            fBeginLineNumber = fCurrentEntity.getLineNumber();\n                            fBeginColumnNumber = fCurrentEntity.getColumnNumber();\n                            fBeginCharacterOffset = fCurrentEntity.getCharacterOffset();\n                            int c = fCurrentEntity.read();\n                            if (c == '<') {\n                                setScannerState(STATE_MARKUP_BRACKET);\n                                next = true;\n                            }\n                            else if (c == '&') {\n                                scanEntityRef(fStringBuffer, true);\n                            }\n                            else if (c == -1) {\n                                throw new EOFException();\n                            }\n                            else {\n                            \tfCurrentEntity.rewind();\n                                scanCharacters();\n                            }\n                            break;\n                        }\n                        case STATE_MARKUP_BRACKET: {\n                            int c = fCurrentEntity.read();\n                            if (c == '!') {\n                                if (skip(\"--\", false)) {\n                                    scanComment();\n                                }\n                                else if (skip(\"[CDATA[\", false)) {\n                                    scanCDATA();\n                                }\n                                else if (skip(\"DOCTYPE\", false)) {\n                                    scanDoctype();\n                                }\n                                else {\n                                    if (fReportErrors) {\n                                        fErrorReporter.reportError(\"HTML1002\", null);\n                                    }\n                                    skipMarkup(true);\n                                }\n                            }\n                            else if (c == '?') {\n                                scanPI();\n                            }\n                            else if (c == '/') {\n                                scanEndElement();\n                            }\n                            else if (c == -1) {\n                                if (fReportErrors) {\n                                    fErrorReporter.reportError(\"HTML1003\", null);\n                                }\n                                if (fDocumentHandler != null && fElementCount >= fElementDepth) {\n                                    fStringBuffer.clear();\n                                    fStringBuffer.append('<');\n                                    fDocumentHandler.characters(fStringBuffer, null);\n                                }\n                                throw new EOFException();\n                            }\n                            else {\n                            \tfCurrentEntity.rewind();\n                                fElementCount++;\n                                fSingleBoolean[0] = false;\n                                final String ename = scanStartElement(fSingleBoolean);\n                                final String enameLC = ename == null ? null : ename.toLowerCase();\n                                fBeginLineNumber = fCurrentEntity.getLineNumber();\n                                fBeginColumnNumber = fCurrentEntity.getColumnNumber();\n                                fBeginCharacterOffset = fCurrentEntity.getCharacterOffset();\n                                if (\"script\".equals(enameLC)) {\n                                \tscanScriptContent();\n                                }\n                                else if (!fAllowSelfclosingTags && !fAllowSelfclosingIframe && \"iframe\".equals(enameLC)) {\n                                \tscanUntilEndTag(\"iframe\");\n                                }\n                                else if (!fParseNoScriptContent && \"noscript\".equals(enameLC)) {\n                                \tscanUntilEndTag(\"noscript\");\n                                }\n                                else if (!fParseNoFramesContent && \"noframes\".equals(enameLC)) {\n                                \tscanUntilEndTag(\"noframes\");\n                                }\n                                else if (ename != null && !fSingleBoolean[0] \n                                    && HTMLElements.getElement(enameLC).isSpecial() \n                                    && (!ename.equalsIgnoreCase(\"TITLE\") || isEnded(enameLC))) {\n                                    setScanner(fSpecialScanner.setElementName(ename));\n                                    setScannerState(STATE_CONTENT);\n                                    return true;\n                                }\n                            }\n                            setScannerState(STATE_CONTENT);\n                            break;\n                        }\n                        case STATE_START_DOCUMENT: {\n                            if (fDocumentHandler != null && fElementCount >= fElementDepth) {\n                                if (DEBUG_CALLBACKS) {\n                                    System.out.println(\"startDocument()\");\n                                }\n                                XMLLocator locator = HTMLScanner.this;\n                                String encoding = fIANAEncoding;\n                                Augmentations augs = locationAugs();\n                                NamespaceContext nscontext = new NamespaceSupport();\n                                XercesBridge.getInstance().XMLDocumentHandler_startDocument(fDocumentHandler, locator, encoding, nscontext, augs);\n                            }\n                            if (fInsertDoctype && fDocumentHandler != null) {\n                                String root = HTMLElements.getElement(HTMLElements.HTML).name;\n                                root = modifyName(root, fNamesElems);\n                                String pubid = fDoctypePubid;\n                                String sysid = fDoctypeSysid;\n                                fDocumentHandler.doctypeDecl(root, pubid, sysid,\n                                                             synthesizedAugs());\n                            }\n                            setScannerState(STATE_CONTENT);\n                            break;\n                        }\n                        case STATE_END_DOCUMENT: {\n                            if (fDocumentHandler != null && fElementCount >= fElementDepth && complete) {\n                                if (DEBUG_CALLBACKS) {\n                                    System.out.println(\"endDocument()\");\n                                }\n                                fEndLineNumber = fCurrentEntity.getLineNumber();\n                                fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                                fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                                fDocumentHandler.endDocument(locationAugs());\n                            }\n                            return false;\n                        }\n                        default: {\n                            throw new RuntimeException(\"unknown scanner state: \"+fScannerState);\n                        }\n                    }\n                }\n                catch (EOFException e) {\n                    if (fCurrentEntityStack.empty()) {\n                        setScannerState(STATE_END_DOCUMENT);\n                    }\n                    else {\n                        fCurrentEntity = (CurrentEntity)fCurrentEntityStack.pop();\n                    }\n                    next = true;\n                }\n            } while (next || complete);\n            return true;\n        } // scan(boolean):boolean\n\n        /**\n         * Scans the content of <noscript>: it doesn't get parsed but is considered as plain text\n         * when feature {@link HTMLScanner#PARSE_NOSCRIPT_CONTENT} is set to false.\n         * @param the tag for which content is scanned (one of \"noscript\", \"noframes\", \"iframe\")\n         * @throws IOException\n         */\n        private void scanUntilEndTag(final String tagName) throws IOException {\n        \tfinal XMLStringBuffer buffer = new XMLStringBuffer();\n        \tfinal String end = \"/\" + tagName;\n        \tfinal int lengthToScan = tagName.length() + 2;\n        \t\n            while (true) {\n                int c = fCurrentEntity.read();\n                if (c == -1) {\n                    break;\n                }\n                if (c == '<') {\n                \tfinal String next = nextContent(lengthToScan) + \" \";\n                \tif (next.length() >= lengthToScan && end.equalsIgnoreCase(next.substring(0, end.length()))\n            \t\t\t&& ('>' == next.charAt(lengthToScan - 1) || Character.isWhitespace(next.charAt(lengthToScan - 1)))) {\n                \t\tfCurrentEntity.rewind();\n\t                    break;\n                \t}\n            \t}\n            \tif (c == '\\r' || c == '\\n') {\n            \t\tfCurrentEntity.rewind();\n                    int newlines = skipNewlines();\n                    for (int i = 0; i < newlines; i++) {\n                        buffer.append('\\n');\n                    }\n                }\n                else {\n                    appendChar(buffer, c);\n                }\n            }\n            if (buffer.length > 0 && fDocumentHandler != null) {\n                fEndLineNumber = fCurrentEntity.getLineNumber();\n                fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                fDocumentHandler.characters(buffer, locationAugs());\n            }\n        }\n        \n        private void scanScriptContent() throws IOException {\n\n        \tfinal XMLStringBuffer buffer = new XMLStringBuffer();\n            boolean waitForEndComment = false;\n            while (true) {\n                int c = fCurrentEntity.read();\n                if (c == -1) {\n                    break;\n                }\n                else if (c == '-' && endsWith(buffer, \"<!-\"))\n            \t{\n            \t\twaitForEndComment = endCommentAvailable();\n            \t}\n                else if (!waitForEndComment && c == '<') {\n                \tfinal String next = nextContent(8) + \" \";\n                \tif (next.length() >= 8 && \"/script\".equalsIgnoreCase(next.substring(0, 7))\n                \t\t\t&& ('>' == next.charAt(7) || Character.isWhitespace(next.charAt(7)))) {\n                \t\tfCurrentEntity.rewind();\n                        break;\n                \t}\n                }\n                else if (c == '>' && endsWith(buffer, \"--\"))  {\n               \t\twaitForEndComment = false;\n                }\n\n                if (c == '\\r' || c == '\\n') {\n                \tfCurrentEntity.rewind();\n                    int newlines = skipNewlines();\n                    for (int i = 0; i < newlines; i++) {\n                        buffer.append('\\n');\n                    }\n                }\n                else {\n                    appendChar(buffer, c);\n                }\n            }\n\n            if (fScriptStripCommentDelims) {\n            \treduceToContent(buffer, \"<!--\", \"-->\");\n            }\n            if (fScriptStripCDATADelims) {\n            \treduceToContent(buffer, \"<![CDATA[\", \"]]>\");\n            }\n\n            if (buffer.length > 0 && fDocumentHandler != null && fElementCount >= fElementDepth) {\n                if (DEBUG_CALLBACKS) {\n                    System.out.println(\"characters(\"+buffer+\")\");\n                }\n                fEndLineNumber = fCurrentEntity.getLineNumber();\n                fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                fDocumentHandler.characters(buffer, locationAugs());\n            }\n        }\n\n        \n        /**\n         * Reads the next characters WITHOUT impacting the buffer content\n         * up to current offset.\n         * @param len the number of characters to read\n         * @return the read string (length may be smaller if EOF is encountered)\n         */\n        protected String nextContent(int len) throws IOException {\n            final int originalOffset = fCurrentEntity.offset;\n            final int originalColumnNumber = fCurrentEntity.getColumnNumber();\n            final int originalCharacterOffset = fCurrentEntity.getCharacterOffset();\n            \n            char[] buff = new char[len];\n            int nbRead = 0;\n            for (nbRead=0; nbRead<len; ++nbRead) {\n    \t\t\t// read() should not clear the buffer\n    \t        if (fCurrentEntity.offset == fCurrentEntity.length) {\n    \t        \tif (fCurrentEntity.length == fCurrentEntity.buffer.length) {\n    \t        \t\tfCurrentEntity.load(fCurrentEntity.buffer.length);\n    \t        \t}\n    \t        \telse { // everything was already loaded\n    \t        \t\tbreak;\n    \t        \t}\n    \t        }\n    \t        \n    \t        int c = fCurrentEntity.read();\n    \t        if (c == -1) {\n    \t        \tbreak;\n    \t        }\n   \t        \tbuff[nbRead] = (char) c;\n    \t\t}\n\t        fCurrentEntity.restorePosition(originalOffset, originalColumnNumber, originalCharacterOffset);\n\t        return new String(buff, 0, nbRead);\n    \t}\n\n\t\t//\n        // Protected methods\n        //\n\n        /** Scans characters. */\n        protected void scanCharacters() throws IOException {\n            if (DEBUG_BUFFER) { \n                fCurrentEntity.debugBufferIfNeeded(\"(scanCharacters: \");\n            }\n            fStringBuffer.clear();  \n            while(true) { \n               int newlines = skipNewlines();\n               if (newlines == 0 && fCurrentEntity.offset == fCurrentEntity.length) {\n                   if (DEBUG_BUFFER) { \n                       fCurrentEntity.debugBufferIfNeeded(\")scanCharacters: \");\n                   }\n                   break;\n               }\n               char c;\n               int offset = fCurrentEntity.offset - newlines;\n               for (int i = offset; i < fCurrentEntity.offset; i++) {\n                   fCurrentEntity.buffer[i] = '\\n';\n               }\n               while (fCurrentEntity.hasNext()) {\n                   c = fCurrentEntity.getNextChar();\n                   if (c == '<' || c == '&' || c == '\\n' || c == '\\r') {\n                    \tfCurrentEntity.rewind();\n                        break;\n                    }\n                }\n                if (fCurrentEntity.offset > offset && \n                    fDocumentHandler != null && fElementCount >= fElementDepth) {\n                    if (DEBUG_CALLBACKS) {\n                    \tfinal XMLString xmlString = new XMLString(fCurrentEntity.buffer, offset, fCurrentEntity.offset - offset);\n                        System.out.println(\"characters(\" + xmlString + \")\");\n                    }\n                    fEndLineNumber = fCurrentEntity.getLineNumber();\n                    fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                    fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                    fStringBuffer.append(fCurrentEntity.buffer, offset, fCurrentEntity.offset - offset);\n                }\n                if (DEBUG_BUFFER) { \n                    fCurrentEntity.debugBufferIfNeeded(\")scanCharacters: \");\n                }\n\n                boolean hasNext = fCurrentEntity.offset  < fCurrentEntity.buffer.length;\n                int next = hasNext ? fCurrentEntity.getCurrentChar() : -1; \n                \n                if(next == '&' || next == '<' || next == -1) {\n                     break;\n                 }\n\n            } //end while\n\n            if(fStringBuffer.length != 0) {\n                fDocumentHandler.characters(fStringBuffer, locationAugs());\n            }\n\n        } // scanCharacters()\n\n        /** Scans a CDATA section. */\n        protected void scanCDATA() throws IOException {\n            if (DEBUG_BUFFER) { \n                fCurrentEntity.debugBufferIfNeeded(\"(scanCDATA: \");\n            }\n            fStringBuffer.clear();\n            if (fCDATASections) {\n                if (fDocumentHandler != null && fElementCount >= fElementDepth) {\n                    fEndLineNumber = fCurrentEntity.getLineNumber();\n                    fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                    fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                    if (DEBUG_CALLBACKS) {\n                        System.out.println(\"startCDATA()\");\n                    }\n                    fDocumentHandler.startCDATA(locationAugs());\n                }\n            }\n            else {\n                fStringBuffer.append(\"[CDATA[\");\n            }\n            boolean eof = scanMarkupContent(fStringBuffer, ']');\n            if (!fCDATASections) {\n                fStringBuffer.append(\"]]\");\n            }\n            if (fDocumentHandler != null && fElementCount >= fElementDepth) {\n                fEndLineNumber = fCurrentEntity.getLineNumber();\n                fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                if (fCDATASections) {\n                    if (DEBUG_CALLBACKS) {\n                        System.out.println(\"characters(\"+fStringBuffer+\")\");\n                    }\n                    fDocumentHandler.characters(fStringBuffer, locationAugs());\n                    if (DEBUG_CALLBACKS) {\n                        System.out.println(\"endCDATA()\");\n                    }\n                    fDocumentHandler.endCDATA(locationAugs());\n                }\n                else {\n                    if (DEBUG_CALLBACKS) {\n                        System.out.println(\"comment(\"+fStringBuffer+\")\");\n                    }\n                    fDocumentHandler.comment(fStringBuffer, locationAugs());\n                }\n            }\n            if (DEBUG_BUFFER) { \n                fCurrentEntity.debugBufferIfNeeded(\")scanCDATA: \");\n            }\n            if (eof) {\n                throw new EOFException();\n            }\n        } // scanCDATA()\n        \n        /** Scans a comment. */\n        protected void scanComment() throws IOException {\n            if (DEBUG_BUFFER) { \n                fCurrentEntity.debugBufferIfNeeded(\"(scanComment: \");\n            }\n            fEndLineNumber = fCurrentEntity.getLineNumber();\n            fEndColumnNumber = fCurrentEntity.getColumnNumber();\n            fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n        \tXMLStringBuffer buffer = new XMLStringBuffer();\n            boolean eof = scanMarkupContent(buffer, '-');\n            // no --> found, comment with end only with >\n            if (eof) {\n            \tfCurrentEntity.resetBuffer(buffer, fEndLineNumber, fEndColumnNumber, fEndCharacterOffset);\n            \tbuffer = new XMLStringBuffer(); // take a new one to avoid interactions\n            \twhile (true) {\n            \t\tint c = fCurrentEntity.read();\n                    if (c == -1) {\n                        if (fReportErrors) {\n                            fErrorReporter.reportError(\"HTML1007\", null);\n                        }\n                        eof = true;\n                        break;\n                    }\n                    else if (c != '>') {\n                        appendChar(buffer, c);\n                        continue;\n            \t\t}\n            \t\telse if (c == '\\n' || c == '\\r') {\n            \t\t\tfCurrentEntity.rewind();\n\t                    int newlines = skipNewlines();\n\t                    for (int i = 0; i < newlines; i++) {\n\t                    \tbuffer.append('\\n');\n\t                    }\n\t                    continue;\n\t                }\n                    eof = false;\n            \t\tbreak;\n            \t}\n            }\n            if (fDocumentHandler != null && fElementCount >= fElementDepth) {\n                if (DEBUG_CALLBACKS) {\n                    System.out.println(\"comment(\" + buffer + \")\");\n                }\n                fEndLineNumber = fCurrentEntity.getLineNumber();\n                fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                fDocumentHandler.comment(buffer, locationAugs());\n            }\n            if (DEBUG_BUFFER) { \n                fCurrentEntity.debugBufferIfNeeded(\")scanComment: \");\n            }\n            if (eof) {\n                throw new EOFException();\n            }\n        } // scanComment()\n\n        /** Scans markup content. */\n        protected boolean scanMarkupContent(XMLStringBuffer buffer, \n                                            char cend) throws IOException {\n            int c = -1;\n            OUTER: while (true) {\n                c = fCurrentEntity.read();\n                if (c == cend) {\n                    int count = 1;\n                    while (true) {\n                        c = fCurrentEntity.read();\n                        if (c == cend) {\n                            count++;\n                            continue;\n                        }\n                        break;\n                    }\n                    if (c == -1) {\n                        if (fReportErrors) {\n                            fErrorReporter.reportError(\"HTML1007\", null);\n                        }\n                        break OUTER;\n                    }\n                    if (count < 2) {\n                        buffer.append(cend);\n                        //if (c != -1) {\n                        fCurrentEntity.rewind();\n                        //}\n                        continue;\n                    }\n                    if (c != '>') {\n                        for (int i = 0; i < count; i++) {\n                            buffer.append(cend);\n                        }\n                        fCurrentEntity.rewind();\n                        continue;\n                    }\n                    for (int i = 0; i < count - 2; i++) {\n                        buffer.append(cend);\n                    }\n                    break;\n                }\n                else if (c == '\\n' || c == '\\r') {\n                \tfCurrentEntity.rewind();\n                    int newlines = skipNewlines();\n                    for (int i = 0; i < newlines; i++) {\n                        buffer.append('\\n');\n                    }\n                    continue;\n                }\n                else if (c == -1) {\n                    if (fReportErrors) {\n                        fErrorReporter.reportError(\"HTML1007\", null);\n                    }\n                    break;\n                }\n                appendChar(buffer, c);\n            }\n            return c == -1;\n        } // scanMarkupContent(XMLStringBuffer,char):boolean\n\n        /** Scans a processing instruction. */\n        protected void scanPI() throws IOException {\n            if (DEBUG_BUFFER) { \n                fCurrentEntity.debugBufferIfNeeded(\"(scanPI: \");\n            }\n            if (fReportErrors) {\n                fErrorReporter.reportWarning(\"HTML1008\", null);\n            }\n\n            // scan processing instruction\n            String target = scanName(true);\n            if (target != null && !target.equalsIgnoreCase(\"xml\")) {\n                while (true) {\n                    int c = fCurrentEntity.read();\n                    if (c == '\\r' || c == '\\n') {\n                        if (c == '\\r') {\n                            c = fCurrentEntity.read();\n                            if (c != '\\n') {\n                                fCurrentEntity.offset--;\n                                fCurrentEntity.characterOffset_--;\n                            }\n                        }\n                        fCurrentEntity.incLine();\n                        continue;\n                    }\n                    if (c == -1) {\n                        break;\n                    }\n                    if (c != ' ' && c != '\\t') {\n                    \tfCurrentEntity.rewind();\n                        break;\n                    }\n                }\n                fStringBuffer.clear();\n                while (true) {\n                    int c = fCurrentEntity.read();\n                    if (c == '?' || c == '/') {\n                        char c0 = (char)c;\n                        c = fCurrentEntity.read();\n                        if (c == '>' || c == -1) {\n                            break;\n                        }\n                        fStringBuffer.append(c0);\n                        fCurrentEntity.rewind();\n                        continue;\n                    }\n                    else if (c == '\\r' || c == '\\n') {\n                        fStringBuffer.append('\\n');\n                        if (c == '\\r') {\n                            c = fCurrentEntity.read();\n                            if (c != '\\n') {\n                                fCurrentEntity.offset--;\n                                fCurrentEntity.characterOffset_--;\n                            }\n                        }\n                        fCurrentEntity.incLine();\n                        continue;\n                    }\n                    else if (c == -1) {\n                        break;\n                    }\n                    else {\n                        appendChar(fStringBuffer, c);\n                    }\n                }\n                XMLString data = fStringBuffer;\n                if (fDocumentHandler != null) {\n                    fEndLineNumber = fCurrentEntity.getLineNumber();\n                    fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                    fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                    fDocumentHandler.processingInstruction(target, data, locationAugs());\n                }\n            }\n\n            // scan xml/text declaration\n            else {\n                int beginLineNumber = fBeginLineNumber;\n                int beginColumnNumber = fBeginColumnNumber;\n                int beginCharacterOffset = fBeginCharacterOffset;\n                fAttributes.removeAllAttributes();\n                int aindex = 0;\n                while (scanPseudoAttribute(fAttributes)) {\n                \t// if we haven't scanned a value, remove the entry as values have special signification\n                \tif (fAttributes.getValue(aindex).length() == 0) {\n                \t\tfAttributes.removeAttributeAt(aindex); \n                \t}\n                \telse {\n\t                    fAttributes.getName(aindex,fQName);\n\t                    fQName.rawname = fQName.rawname.toLowerCase();\n\t                    fAttributes.setName(aindex,fQName);\n\t                    aindex++;\n                \t}\n                }\n                if (fDocumentHandler != null) {\n                    String version = fAttributes.getValue(\"version\");\n                    String encoding = fAttributes.getValue(\"encoding\");\n                    String standalone = fAttributes.getValue(\"standalone\");\n\n                    // if the encoding is successfully changed, the stream will be processed again\n                    // with the right encoding an we will come here again but without need to change the encoding\n                    final boolean xmlDeclNow = fIgnoreSpecifiedCharset || !changeEncoding(encoding);\n                    if (xmlDeclNow) {\n\t                    fBeginLineNumber = beginLineNumber;\n\t                    fBeginColumnNumber = beginColumnNumber;\n\t                    fBeginCharacterOffset = beginCharacterOffset;\n\t                    fEndLineNumber = fCurrentEntity.getLineNumber();\n\t                    fEndColumnNumber = fCurrentEntity.getColumnNumber();\n\t                    fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n\t                    fDocumentHandler.xmlDecl(version, encoding, standalone,\n\t                                             locationAugs());\n                    }\n                }\n            }\n\n            if (DEBUG_BUFFER) { \n                fCurrentEntity.debugBufferIfNeeded(\")scanPI: \");\n            }\n        } // scanPI()\n\n        /** \n         * Scans a start element. \n         *\n         * @param empty Is used for a second return value to indicate whether\n         *              the start element tag is empty (e.g. \"/&gt;\").\n         */\n        protected String scanStartElement(boolean[] empty) throws IOException {\n            String ename = scanName(true);\n            int length = ename != null ? ename.length() : 0;\n            int c = length > 0 ? ename.charAt(0) : -1;\n            if (length == 0 || !((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))) {\n                if (fReportErrors) {\n                    fErrorReporter.reportError(\"HTML1009\", null);\n                }\n                if (fDocumentHandler != null && fElementCount >= fElementDepth) {\n                    fStringBuffer.clear();\n                    fStringBuffer.append('<');\n                    if (length > 0) {\n                        fStringBuffer.append(ename);\n                    }\n                    fDocumentHandler.characters(fStringBuffer, null);\n                }\n                return null;\n            }\n            ename = modifyName(ename, fNamesElems);\n            fAttributes.removeAllAttributes();\n            int beginLineNumber = fBeginLineNumber;\n            int beginColumnNumber = fBeginColumnNumber;\n            int beginCharacterOffset = fBeginCharacterOffset;\n            while (scanAttribute(fAttributes, empty)) {\n                // do nothing\n            }\n            fBeginLineNumber = beginLineNumber;\n            fBeginColumnNumber = beginColumnNumber;\n            fBeginCharacterOffset = beginCharacterOffset;\n            if (fByteStream != null && fElementDepth == -1) {\n                if (ename.equalsIgnoreCase(\"META\") && !fIgnoreSpecifiedCharset) {\n                    if (DEBUG_CHARSET) {\n                        System.out.println(\"+++ <META>\");\n                    }\n                    String httpEquiv = getValue(fAttributes, \"http-equiv\");\n                    if (httpEquiv != null && httpEquiv.equalsIgnoreCase(\"content-type\")) {\n                        if (DEBUG_CHARSET) {\n                            System.out.println(\"+++ @content-type: \\\"\"+httpEquiv+'\"');\n                        }\n                        String content = getValue(fAttributes, \"content\");\n                        if (content != null) {\n                        \tcontent = removeSpaces(content);\n                            int index1 = content.toLowerCase().indexOf(\"charset=\");\n                            if (index1 != -1) {\n                                final int index2 = content.indexOf(';', index1);\n                                final String charset = index2 != -1 ? content.substring(index1+8, index2) : content.substring(index1+8);\n                                changeEncoding(charset);\n                            }\n                        }\n                    }\n                    else {\n                        final String metaCharset = getValue(fAttributes, \"charset\");\n                        if (metaCharset != null) {\n                            changeEncoding(metaCharset);\n                        }\n                    }\n                }\n                else if (ename.equalsIgnoreCase(\"BODY\")) {\n                    fByteStream.clear();\n                    fByteStream = null;\n                }\n                else {\n                     HTMLElements.Element element = HTMLElements.getElement(ename);\n                     if (element.parent != null && element.parent.length > 0) {\n                         if (element.parent[0].code == HTMLElements.BODY) {\n                             fByteStream.clear();\n                             fByteStream = null;\n                         }\n                     }\n                }\n            }\n            if (fDocumentHandler != null && fElementCount >= fElementDepth) {\n                fQName.setValues(null, ename, ename, null);\n                if (DEBUG_CALLBACKS) {\n                    System.out.println(\"startElement(\"+fQName+','+fAttributes+\")\");\n                }\n                fEndLineNumber = fCurrentEntity.getLineNumber();\n                fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                if (empty[0]) {\n                    fDocumentHandler.emptyElement(fQName, fAttributes, locationAugs());\n                }\n                else {\n                    fDocumentHandler.startElement(fQName, fAttributes, locationAugs());\n                }\n            }\n            return ename;\n        } // scanStartElement():ename\n\n        /**\n         * Removes all spaces for the string (remember: JDK 1.3!)\n         */\n        private String removeSpaces(final String content) {\n        \tStringBuffer sb = null;\n        \tfor (int i=content.length()-1; i>=0; --i) {\n        \t\tif (Character.isWhitespace(content.charAt(i))) {\n        \t\t\tif (sb == null) {\n        \t\t\t\tsb = new StringBuffer(content);\n        \t\t\t}\n        \t\t\tsb.deleteCharAt(i);\n        \t\t}\n        \t}\n\t\t\treturn (sb == null) ? content : sb.toString();\n\t\t}\n\n\t\t/**\n         * Tries to change the encoding used to read the input stream to the specified one\n         * @param charset the charset that should be used\n         * @return <code>true</code> when the encoding has been changed\n         */\n\t\tprivate boolean changeEncoding(String charset) {\n\t\t\tif (charset == null || fByteStream == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcharset = charset.trim();\n\t\t\tboolean encodingChanged = false;\n\t\t\ttry {\n\t\t\t    String ianaEncoding = charset;\n\t\t\t    String javaEncoding = EncodingMap.getIANA2JavaMapping(ianaEncoding.toUpperCase(Locale.ENGLISH));\n\t\t\t    if (DEBUG_CHARSET) {\n\t\t\t        System.out.println(\"+++ ianaEncoding: \"+ianaEncoding);\n\t\t\t        System.out.println(\"+++ javaEncoding: \"+javaEncoding);\n\t\t\t    }\n\t\t\t    if (javaEncoding == null) {\n\t\t\t        javaEncoding = ianaEncoding;\n\t\t\t        if (fReportErrors) {\n\t\t\t            fErrorReporter.reportError(\"HTML1001\", new Object[]{ianaEncoding});\n\t\t\t        }\n\t\t\t    }\n\t\t\t    // patch: Marc Guillemot\n\t\t\t    if (!javaEncoding.equals(fJavaEncoding)) { \n\t\t\t      \tif (!isEncodingCompatible(javaEncoding, fJavaEncoding)) {\n\t\t\t            if (fReportErrors) {\n\t\t\t                fErrorReporter.reportError(\"HTML1015\", new Object[]{javaEncoding,fJavaEncoding});\n\t\t\t            }\n\t\t\t     \t}\n\t\t\t  \t\t// change the charset\n\t\t\t     \telse {\n\t\t\t            fIso8859Encoding = ianaEncoding == null \n\t\t\t                    || ianaEncoding.toUpperCase(Locale.ENGLISH).startsWith(\"ISO-8859\")\n\t\t\t                    || ianaEncoding.equalsIgnoreCase(fDefaultIANAEncoding);\n\t\t\t            fJavaEncoding = javaEncoding;\n\t\t\t            fCurrentEntity.setStream(new InputStreamReader(fByteStream, javaEncoding));\n\t\t\t            fByteStream.playback();\n\t\t\t            fElementDepth = fElementCount;\n\t\t\t            fElementCount = 0;\n\t                    encodingChanged = true;\n\t\t\t     \t}\n\t\t\t     }\n\t\t\t}\n\t\t\tcatch (UnsupportedEncodingException e) {\n\t\t\t    if (fReportErrors) {\n\t\t\t        fErrorReporter.reportError(\"HTML1010\", new Object[]{charset});\n\t\t\t    }\n\t\t\t    // NOTE: If the encoding change doesn't work, \n\t\t\t    //       then there's no point in continuing to \n\t\t\t    //       buffer the input stream.\n\t\t\t    fByteStream.clear();\n\t\t\t    fByteStream = null;\n\t\t\t}\n\t\t\treturn encodingChanged;\n\t\t}\n\n        /** \n         * Scans a real attribute. \n         *\n         * @param attributes The list of attributes.\n         * @param empty      Is used for a second return value to indicate \n         *                   whether the start element tag is empty \n         *                   (e.g. \"/&gt;\").\n         */\n        protected boolean scanAttribute(XMLAttributesImpl attributes,\n                                        boolean[] empty)\n            throws IOException {\n            return scanAttribute(attributes,empty,'/');\n        } // scanAttribute(XMLAttributesImpl,boolean[]):boolean\n\n        /** \n         * Scans a pseudo attribute. \n         *\n         * @param attributes The list of attributes.\n         */\n        protected boolean scanPseudoAttribute(XMLAttributesImpl attributes)\n            throws IOException {\n            return scanAttribute(attributes,fSingleBoolean,'?');\n        } // scanPseudoAttribute(XMLAttributesImpl):boolean\n\n        /** \n         * Scans an attribute, pseudo or real. \n         *\n         * @param attributes The list of attributes.\n         * @param empty      Is used for a second return value to indicate \n         *                   whether the start element tag is empty \n         *                   (e.g. \"/&gt;\").\n         * @param endc       The end character that appears before the\n         *                   closing angle bracket ('>').\n         */\n        protected boolean scanAttribute(XMLAttributesImpl attributes,\n                                        boolean[] empty, char endc)\n            throws IOException {\n            boolean skippedSpaces = skipSpaces();\n            fBeginLineNumber = fCurrentEntity.getLineNumber();\n            fBeginColumnNumber = fCurrentEntity.getColumnNumber();\n            fBeginCharacterOffset = fCurrentEntity.getCharacterOffset();\n            int c = fCurrentEntity.read();\n            if (c == -1) {\n                if (fReportErrors) {\n                    fErrorReporter.reportError(\"HTML1007\", null);\n                }\n                return false;\n            }\n            else if (c == '>') {\n                return false;\n            }\n            else if(c == '<') {\n              fCurrentEntity.rewind();\n              if(fReportErrors) {\n                fErrorReporter.reportError(\"HTML2001\", null);\n              }\n              return false;\n            }\n            fCurrentEntity.rewind();\n            String aname = scanName(false);\n            if(aname == null) {\n              empty[0] = skipMarkup(false);\n              return false;\n            }\n            if (!skippedSpaces && fReportErrors) {\n                fErrorReporter.reportError(\"HTML1013\", new Object[] { aname });\n            }\n            aname = modifyName(aname, fNamesAttrs);\n            skipSpaces();\n            c = fCurrentEntity.read();\n            if (c == -1) {\n                if (fReportErrors) {\n                    fErrorReporter.reportError(\"HTML1007\", null);\n                }\n                throw new EOFException();\n            }\n            if (c == '/' || c == '>') {\n                fQName.setValues(null, aname, aname, null);\n                attributes.addAttribute(fQName, \"CDATA\", \"\");\n                attributes.setSpecified(attributes.getLength()-1, true);\n                if (fAugmentations) {\n                    addLocationItem(attributes, attributes.getLength() - 1);\n                }\n                if (c == '/') {\n                \tfCurrentEntity.rewind();\n                    empty[0] = skipMarkup(false);\n                }\n                return false;\n            }\n            /***\n            // REVISIT: [Q] Why is this still here? -Ac\n            if (c == '/' || c == '>') {\n                if (c == '/') {\n                    fCurrentEntity.offset--;\n                    fCurrentEntity.columnNumber--;\n                    empty[0] = skipMarkup(false);\n                }\n                fQName.setValues(null, aname, aname, null);\n                attributes.addAttribute(fQName, \"CDATA\", \"\");\n                attributes.setSpecified(attributes.getLength()-1, true);\n                if (fAugmentations) {\n                    addLocationItem(attributes, attributes.getLength() - 1);\n                }\n                return false;\n            }\n            /***/\n            if (c == '=') {\n                skipSpaces();\n                c = fCurrentEntity.read();\n                if (c == -1) {\n                    if (fReportErrors) {\n                        fErrorReporter.reportError(\"HTML1007\", null);\n                    }\n                    throw new EOFException();\n                }\n                // Xiaowei/Ac: Fix for <a href=/cgi-bin/myscript>...</a>\n                if (c == '>') {\n                    fQName.setValues(null, aname, aname, null);\n                    attributes.addAttribute(fQName, \"CDATA\", \"\");\n                    attributes.setSpecified(attributes.getLength()-1, true);\n                    if (fAugmentations) {\n                        addLocationItem(attributes, attributes.getLength() - 1);\n                    }\n                    return false;\n                }\n                fStringBuffer.clear();\n                fNonNormAttr.clear();\n                if (c != '\\'' && c != '\"') {\n                \tfCurrentEntity.rewind();\n                    while (true) {\n                        c = fCurrentEntity.read();\n                        // Xiaowei/Ac: Fix for <a href=/broken/>...</a>\n                        if (Character.isWhitespace((char)c) || c == '>') {\n                            //fCharOffset--;\n                        \tfCurrentEntity.rewind();\n                            break;\n                        }\n                        if (c == -1) {\n                            if (fReportErrors) {\n                                fErrorReporter.reportError(\"HTML1007\", null);\n                            }\n                            throw new EOFException();\n                        }\n                        if (c == '&') {\n                            int ce = scanEntityRef(fStringBuffer2, false);\n                            if (ce != -1) {\n                                appendChar(fStringBuffer, ce);\n                            }\n                            else {\n                                fStringBuffer.append(fStringBuffer2);\n                            }\n                            fNonNormAttr.append(fStringBuffer2);\n                        }\n                        else {\n                            appendChar(fStringBuffer, c);\n                            appendChar(fNonNormAttr, c);\n                        }\n                    }\n                    fQName.setValues(null, aname, aname, null);\n                    String avalue = fStringBuffer.toString();\n                    attributes.addAttribute(fQName, \"CDATA\", avalue);\n\n                    int lastattr = attributes.getLength()-1;\n                    attributes.setSpecified(lastattr, true);\n                    attributes.setNonNormalizedValue(lastattr, fNonNormAttr.toString());\n                    if (fAugmentations) {\n                        addLocationItem(attributes, attributes.getLength() - 1);\n                    }\n                    return true;\n                }\n                char quote = (char)c;\n                boolean isStart = true;\n                boolean prevSpace = false;\n                do {\n                \tboolean acceptSpace = !fNormalizeAttributes || (!isStart && !prevSpace);\n                    c = fCurrentEntity.read();\n                    if (c == -1) {\n                        if (fReportErrors) {\n                            fErrorReporter.reportError(\"HTML1007\", null);\n                        }\n                        break;\n//                        throw new EOFException();\n                    }\n                    if (c == '&') {\n                    \tisStart = false;\n                        int ce = scanEntityRef(fStringBuffer2, false);\n                        if (ce != -1) {\n                            appendChar(fStringBuffer, ce);\n                        }\n                        else {\n                            fStringBuffer.append(fStringBuffer2);\n                        }\n                        fNonNormAttr.append(fStringBuffer2);\n                    }\n                    else if (c == ' ' || c == '\\t') {\n                    \tif (acceptSpace) {\n\t                        fStringBuffer.append(fNormalizeAttributes ? ' ' : (char)c);\n\t                    }\n                        fNonNormAttr.append((char)c);\n                    }\n                    else if (c == '\\r' || c == '\\n') {\n                        if (c == '\\r') {\n                            int c2 = fCurrentEntity.read();\n                            if (c2 == '\\n') {\n                                fNonNormAttr.append('\\r');\n                                c = c2;\n                            }\n                            else if (c2 != -1) {\n                            \tfCurrentEntity.rewind();\n                            }\n                        }\n                        if (acceptSpace) {\n\t                        fStringBuffer.append(fNormalizeAttributes ? ' ' : '\\n');\n\t                    }\n                        fCurrentEntity.incLine();\n                        fNonNormAttr.append((char)c);\n                    }\n                    else if (c != quote) {\n                    \tisStart = false;\n                        appendChar(fStringBuffer, c);\n                        appendChar(fNonNormAttr, c);\n                    }\n                    prevSpace = c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n                    isStart = isStart && prevSpace;\n                } while (c != quote);\n                \n                if (fNormalizeAttributes && fStringBuffer.length > 0) {\n                \t// trailing whitespace already normalized to single space\n       \t        \tif (fStringBuffer.ch[fStringBuffer.length - 1] == ' ') {\n           \t    \t\tfStringBuffer.length--;\n               \t\t}\n    \t        }\n\n                fQName.setValues(null, aname, aname, null);\n                String avalue = fStringBuffer.toString();\n                attributes.addAttribute(fQName, \"CDATA\", avalue);\n\n                int lastattr = attributes.getLength()-1;\n                attributes.setSpecified(lastattr, true);\n                attributes.setNonNormalizedValue(lastattr, fNonNormAttr.toString());\n                if (fAugmentations) {\n                    addLocationItem(attributes, attributes.getLength() - 1);\n                }\n            }\n            else {\n                fQName.setValues(null, aname, aname, null);\n                attributes.addAttribute(fQName, \"CDATA\", \"\");\n                attributes.setSpecified(attributes.getLength()-1, true);\n                fCurrentEntity.rewind();\n                if (fAugmentations) {\n                    addLocationItem(attributes, attributes.getLength() - 1);\n                }\n            }\n            return true;\n        } // scanAttribute(XMLAttributesImpl):boolean\n\n        /** Adds location augmentations to the specified attribute. */\n        protected void addLocationItem(XMLAttributes attributes, int index) {\n            fEndLineNumber = fCurrentEntity.getLineNumber();\n            fEndColumnNumber = fCurrentEntity.getColumnNumber();\n            fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n            LocationItem locationItem = new LocationItem();\n            locationItem.setValues(fBeginLineNumber, fBeginColumnNumber,\n                                   fBeginCharacterOffset, fEndLineNumber,\n                                   fEndColumnNumber, fEndCharacterOffset);\n            Augmentations augs = attributes.getAugmentations(index);\n            augs.putItem(AUGMENTATIONS, locationItem);\n        } // addLocationItem(XMLAttributes,int)\n\n        /** Scans an end element. */\n        protected void scanEndElement() throws IOException {\n            String ename = scanName(true);\n            if (fReportErrors && ename == null) {\n                fErrorReporter.reportError(\"HTML1012\", null);\n            }\n            skipMarkup(false);\n            if (ename != null) {\n                ename = modifyName(ename, fNamesElems);\n                if (fDocumentHandler != null && fElementCount >= fElementDepth) {\n                    fQName.setValues(null, ename, ename, null);\n                    if (DEBUG_CALLBACKS) {\n                        System.out.println(\"endElement(\"+fQName+\")\");\n                    }\n                    fEndLineNumber = fCurrentEntity.getLineNumber();\n                    fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                    fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                    fDocumentHandler.endElement(fQName, locationAugs());\n                }\n            }\n        } // scanEndElement()\n\n        //\n        // Private methods\n        //\n\n        /**\n         * Returns true if the given element has an end-tag.\n         */\n        private boolean isEnded(String ename) {\n            String content = new String(fCurrentEntity.buffer, fCurrentEntity.offset,\n                fCurrentEntity.length - fCurrentEntity.offset);\n            return content.toLowerCase().indexOf(\"</\" + ename.toLowerCase() + \">\") != -1;\n        }\n\n    } // class ContentScanner\n\n    /**\n     * Special scanner used for elements whose content needs to be scanned \n     * as plain text, ignoring markup such as elements and entity references.\n     * For example: &lt;SCRIPT&gt; and &lt;COMMENT&gt;.\n     *\n     * @author Andy Clark\n     */\n    public class SpecialScanner\n        implements Scanner {\n\n        //\n        // Data\n        //\n\n        /** Name of element whose content needs to be scanned as text. */\n        protected String fElementName;\n\n        /** True if &lt;style&gt; element. */\n        protected boolean fStyle;\n\n        /** True if &lt;textarea&gt; element. */\n        protected boolean fTextarea;\n\n        /** True if &lt;title&gt; element. */\n        protected boolean fTitle;\n\n        // temp vars\n\n        /** A qualified name. */\n        private final QName fQName = new QName();\n\n        /** A string buffer. */\n        private final XMLStringBuffer fStringBuffer = new XMLStringBuffer();\n\n        //\n        // Public methods\n        //\n\n        /** Sets the element name. */\n        public Scanner setElementName(String ename) {\n            fElementName = ename;\n            fStyle = fElementName.equalsIgnoreCase(\"STYLE\");\n            fTextarea = fElementName.equalsIgnoreCase(\"TEXTAREA\");\n            fTitle = fElementName.equalsIgnoreCase(\"TITLE\");\n            return this;\n        } // setElementName(String):Scanner\n\n        //\n        // Scanner methods\n        //\n\n        /** Scan. */\n        public boolean scan(boolean complete) throws IOException {\n            boolean next;\n            do {\n                try {\n                    next = false;\n                    switch (fScannerState) {\n                        case STATE_CONTENT: {\n                            fBeginLineNumber = fCurrentEntity.getLineNumber();\n                            fBeginColumnNumber = fCurrentEntity.getColumnNumber();\n                            fBeginCharacterOffset = fCurrentEntity.getCharacterOffset();\n                            int c = fCurrentEntity.read();\n                            if (c == '<') {\n                                setScannerState(STATE_MARKUP_BRACKET);\n                                continue;\n                            }\n                            if (c == '&') {\n                                if (fTextarea || fTitle) {\n                                    scanEntityRef(fStringBuffer, true);\n                                    continue;\n                                }\n                                fStringBuffer.clear();\n                                fStringBuffer.append('&');\n                            }\n                            else if (c == -1) {\n                                if (fReportErrors) {\n                                    fErrorReporter.reportError(\"HTML1007\", null);\n                                }\n                                throw new EOFException();\n                            }\n                            else {\n                            \tfCurrentEntity.rewind();\n                                fStringBuffer.clear();\n                            }\n                            scanCharacters(fStringBuffer, -1);\n                            break;\n                        } // case STATE_CONTENT\n                        case STATE_MARKUP_BRACKET: {\n                            int delimiter = -1;\n                            int c = fCurrentEntity.read();\n                            if (c == '/') {\n                                String ename = scanName(true);\n                                if (ename != null) {\n                                    if (ename.equalsIgnoreCase(fElementName)) {\n                                        if (fCurrentEntity.read() == '>') {\n                                            ename = modifyName(ename, fNamesElems);\n                                            if (fDocumentHandler != null && fElementCount >= fElementDepth) {\n                                                fQName.setValues(null, ename, ename, null);\n                                                if (DEBUG_CALLBACKS) {\n                                                    System.out.println(\"endElement(\"+fQName+\")\");\n                                                }\n                                                fEndLineNumber = fCurrentEntity.getLineNumber();\n                                                fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                                                fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                                                fDocumentHandler.endElement(fQName, locationAugs());\n                                            }\n                                            setScanner(fContentScanner);\n                                            setScannerState(STATE_CONTENT);\n                                            return true;\n                                        }\n                                      \tfCurrentEntity.rewind();\n                                    }\n                                    fStringBuffer.clear();\n                                    fStringBuffer.append(\"</\");\n                                    fStringBuffer.append(ename);\n                                }\n                                else {\n                                    fStringBuffer.clear();\n                                    fStringBuffer.append(\"</\");\n                                }\n                            }\n                            else {\n                                fStringBuffer.clear();\n                                fStringBuffer.append('<');\n                                appendChar(fStringBuffer, c);\n                            }\n                            scanCharacters(fStringBuffer, delimiter);\n                            setScannerState(STATE_CONTENT);\n                            break;\n                        } // case STATE_MARKUP_BRACKET\n                    } // switch\n                } // try\n                catch (EOFException e) {\n                    setScanner(fContentScanner);\n                    if (fCurrentEntityStack.empty()) {\n                        setScannerState(STATE_END_DOCUMENT);\n                    }\n                    else {\n                        fCurrentEntity = (CurrentEntity)fCurrentEntityStack.pop();\n                        setScannerState(STATE_CONTENT);\n                    }\n                    return true;\n                }\n            } // do\n            while (next || complete);\n            return true;\n        } // scan(boolean):boolean\n\n        //\n        // Protected methods\n        //\n\n        /** Scan characters. */\n        protected void scanCharacters(XMLStringBuffer buffer,\n                                      int delimiter) throws IOException {\n            if (DEBUG_BUFFER) { \n                fCurrentEntity.debugBufferIfNeeded(\"(scanCharacters, delimiter=\"+delimiter+\": \");\n            }\n            \n            while (true) {\n                int c = fCurrentEntity.read();\n\n                if (c == -1 || (c == '<' || c == '&')) {\n                    if (c != -1) {\n                    \tfCurrentEntity.rewind();\n                    }\n                    break;\n                }\n                // Patch supplied by Jonathan Baxter\n                else if (c == '\\r' || c == '\\n') {\n                \tfCurrentEntity.rewind();\n                    int newlines = skipNewlines();\n                    for (int i = 0; i < newlines; i++) {\n                        buffer.append('\\n');\n                    }\n                }\n                else {\n                    appendChar(buffer, c);\n                    if (c == '\\n') {\n                        fCurrentEntity.incLine();\n                    }\n                }\n            }\n\n            if (fStyle) {\n            \tif (fStyleStripCommentDelims) {\n            \t\treduceToContent(buffer, \"<!--\", \"-->\");\n            \t}\n            \tif (fStyleStripCDATADelims) {\n                \treduceToContent(buffer, \"<![CDATA[\", \"]]>\");\n            \t}\n            }\n\n            if (buffer.length > 0 && fDocumentHandler != null && fElementCount >= fElementDepth) {\n                if (DEBUG_CALLBACKS) {\n                    System.out.println(\"characters(\"+buffer+\")\");\n                }\n                fEndLineNumber = fCurrentEntity.getLineNumber();\n                fEndColumnNumber = fCurrentEntity.getColumnNumber();\n                fEndCharacterOffset = fCurrentEntity.getCharacterOffset();\n                fDocumentHandler.characters(buffer, locationAugs());\n            }\n            if (DEBUG_BUFFER) { \n                fCurrentEntity.debugBufferIfNeeded(\")scanCharacters: \");\n            }\n        } // scanCharacters(StringBuffer)\n    } // class SpecialScanner\n\n    /**\n     * A playback input stream. This class has the ability to save the bytes\n     * read from the underlying input stream and play the bytes back later.\n     * This class is used by the HTML scanner to switch encodings when a \n     * &lt;meta&gt; tag is detected that specifies a different encoding. \n     * <p>\n     * If the encoding is changed, then the scanner calls the \n     * <code>playback</code> method and re-scans the beginning of the HTML\n     * document again. This should not be too much of a performance problem\n     * because the &lt;meta&gt; tag appears at the beginning of the document.\n     * <p>\n     * If the &lt;body&gt; tag is reached without playing back the bytes,\n     * then the buffer can be cleared by calling the <code>clear</code>\n     * method. This stops the buffering of bytes and allows the memory used\n     * by the buffer to be reclaimed. \n     * <p>\n     * <strong>Note:</strong> \n     * If the buffer is never played back or cleared, this input stream\n     * will continue to buffer the entire stream. Therefore, it is very\n     * important to use this stream correctly.\n     *\n     * @author Andy Clark\n     */\n    public static class PlaybackInputStream\n        extends FilterInputStream {\n\n        //\n        // Constants\n        //\n\n        /** Set to true to debug playback. */\n        private static final boolean DEBUG_PLAYBACK = false;\n\n        //\n        // Data\n        //\n\n        // state\n\n        /** Playback mode. */\n        protected boolean fPlayback = false;\n\n        /** Buffer cleared. */\n        protected boolean fCleared = false;\n\n        /** Encoding detected. */\n        protected boolean fDetected = false;\n\n        // buffer info\n\n        /** Byte buffer. */\n        protected byte[] fByteBuffer = new byte[1024];\n\n        /** Offset into byte buffer during playback. */\n        protected int fByteOffset = 0;\n\n        /** Length of bytes read into byte buffer. */\n        protected int fByteLength = 0;\n\n        /** Pushback offset. */\n        public int fPushbackOffset = 0;\n\n        /** Pushback length. */\n        public int fPushbackLength = 0;\n\n        //\n        // Constructors\n        //\n\n        /** Constructor. */\n        public PlaybackInputStream(InputStream in) {\n            super(in);\n        } // <init>(InputStream)\n\n        //\n        // Public methods\n        //\n\n        /** Detect encoding. */\n        public void detectEncoding(String[] encodings) throws IOException {\n            if (fDetected) {\n                throw new IOException(\"Should not detect encoding twice.\");\n            }\n            fDetected = true;\n            int b1 = read();\n            if (b1 == -1) {\n                return;\n            }\n            int b2 = read();\n            if (b2 == -1) {\n                fPushbackLength = 1;\n                return;\n            }\n            // UTF-8 BOM: 0xEFBBBF\n            if (b1 == 0xEF && b2 == 0xBB) {\n                int b3 = read();\n                if (b3 == 0xBF) {\n                    fPushbackOffset = 3;\n                    encodings[0] = \"UTF-8\";\n                    encodings[1] = \"UTF8\";\n                    return;\n                }\n                fPushbackLength = 3;\n            }\n            // UTF-16 LE BOM: 0xFFFE\n            if (b1 == 0xFF && b2 == 0xFE) {\n                encodings[0] = \"UTF-16\";\n                encodings[1] = \"UnicodeLittleUnmarked\";\n                return;\n            }\n            // UTF-16 BE BOM: 0xFEFF\n            else if (b1 == 0xFE && b2 == 0xFF) {\n                encodings[0] = \"UTF-16\";\n                encodings[1] = \"UnicodeBigUnmarked\";\n                return;\n            }\n            // unknown\n            fPushbackLength = 2;\n        } // detectEncoding()\n\n        /** Playback buffer contents. */\n        public void playback() {\n            fPlayback = true;\n        } // playback()\n\n        /** \n         * Clears the buffer.\n         * <p>\n         * <strong>Note:</strong>\n         * The buffer cannot be cleared during playback. Therefore, calling\n         * this method during playback will not do anything. However, the\n         * buffer will be cleared automatically at the end of playback.\n         */\n        public void clear() {\n            if (!fPlayback) {\n                fCleared = true;\n                fByteBuffer = null;\n            }\n        } // clear()\n\n        //\n        // InputStream methods\n        //\n\n        /** Read a byte. */\n        public int read() throws IOException {\n            if (DEBUG_PLAYBACK) {\n                System.out.println(\"(read\");\n            }\n            if (fPushbackOffset < fPushbackLength) {\n                return fByteBuffer[fPushbackOffset++];\n            }\n            if (fCleared) {\n                return in.read();\n            }\n            if (fPlayback) {\n                int c = fByteBuffer[fByteOffset++];\n                if (fByteOffset == fByteLength) {\n                    fCleared = true;\n                    fByteBuffer = null;\n                }\n                if (DEBUG_PLAYBACK) {\n                    System.out.println(\")read -> \"+(char)c);\n                }\n                return c;\n            }\n            int c = in.read();\n            if (c != -1) {\n                if (fByteLength == fByteBuffer.length) {\n                    byte[] newarray = new byte[fByteLength + 1024];\n                    System.arraycopy(fByteBuffer, 0, newarray, 0, fByteLength);\n                    fByteBuffer = newarray;\n                }\n                fByteBuffer[fByteLength++] = (byte)c;\n            }\n            if (DEBUG_PLAYBACK) {\n                System.out.println(\")read -> \"+(char)c);\n            }\n            return c;\n        } // read():int\n\n        /** Read an array of bytes. */\n        public int read(byte[] array) throws IOException {\n            return read(array, 0, array.length);\n        } // read(byte[]):int\n\n        /** Read an array of bytes. */\n        public int read(byte[] array, int offset, int length) throws IOException {\n            if (DEBUG_PLAYBACK) {\n                System.out.println(\")read(\"+offset+','+length+')');\n            }\n            if (fPushbackOffset < fPushbackLength) {\n                int count = fPushbackLength - fPushbackOffset;\n                if (count > length) {\n                    count = length;\n                }\n                System.arraycopy(fByteBuffer, fPushbackOffset, array, offset, count);\n                fPushbackOffset += count;\n                return count;\n            }\n            if (fCleared) {\n                return in.read(array, offset, length);\n            }\n            if (fPlayback) {\n                if (fByteOffset + length > fByteLength) {\n                    length = fByteLength - fByteOffset;\n                }\n                System.arraycopy(fByteBuffer, fByteOffset, array, offset, length);\n                fByteOffset += length;\n                if (fByteOffset == fByteLength) {\n                    fCleared = true;\n                    fByteBuffer = null;\n                }\n                return length;\n            }\n            int count = in.read(array, offset, length);\n            if (count != -1) {\n                if (fByteLength + count > fByteBuffer.length) {\n                    byte[] newarray = new byte[fByteLength + count + 512];\n                    System.arraycopy(fByteBuffer, 0, newarray, 0, fByteLength);\n                    fByteBuffer = newarray;\n                }\n                System.arraycopy(array, offset, fByteBuffer, fByteLength, count);\n                fByteLength += count;\n            }\n            if (DEBUG_PLAYBACK) {\n                System.out.println(\")read(\"+offset+','+length+\") -> \"+count);\n            }\n            return count;\n        } // read(byte[]):int\n\n    } // class PlaybackInputStream\n\n    /**\n     * Location infoset item. \n     *\n     * @author Andy Clark\n     */\n    protected static class LocationItem implements HTMLEventInfo, Cloneable {\n\n        //\n        // Data\n        //\n\n        /** Beginning line number. */\n        protected int fBeginLineNumber;\n\n        /** Beginning column number. */\n        protected int fBeginColumnNumber;\n\n        /** Beginning character offset. */\n        protected int fBeginCharacterOffset;\n\n        /** Ending line number. */\n        protected int fEndLineNumber;\n\n        /** Ending column number. */\n        protected int fEndColumnNumber;\n\n        /** Ending character offset. */\n        protected int fEndCharacterOffset;\n\n        //\n        // Public methods\n        //\n        public LocationItem() {\n        \t// nothing\n        }\n\n        LocationItem(final LocationItem other) {\n\t\t\tsetValues(other.fBeginLineNumber, other.fBeginColumnNumber, other.fBeginCharacterOffset,\n\t\t\t\t\tother.fEndLineNumber, other.fEndColumnNumber, other.fEndCharacterOffset);\n\t\t}\n\n        /** Sets the values of this item. */\n        public void setValues(int beginLine, int beginColumn, int beginOffset,\n                              int endLine, int endColumn, int endOffset) {\n            fBeginLineNumber = beginLine;\n            fBeginColumnNumber = beginColumn;\n            fBeginCharacterOffset = beginOffset;\n            fEndLineNumber = endLine;\n            fEndColumnNumber = endColumn;\n            fEndCharacterOffset = endOffset;\n        } // setValues(int,int,int,int)\n\n        //\n        // HTMLEventInfo methods\n        //\n\n        // location information\n\n        /** Returns the line number of the beginning of this event.*/\n        public int getBeginLineNumber() {\n            return fBeginLineNumber;\n        } // getBeginLineNumber():int\n\n        /** Returns the column number of the beginning of this event.*/\n        public int getBeginColumnNumber() { \n            return fBeginColumnNumber;\n        } // getBeginColumnNumber():int\n\n        /** Returns the character offset of the beginning of this event.*/\n        public int getBeginCharacterOffset() { \n            return fBeginCharacterOffset;\n        } // getBeginCharacterOffset():int\n\n        /** Returns the line number of the end of this event.*/\n        public int getEndLineNumber() {\n            return fEndLineNumber;\n        } // getEndLineNumber():int\n\n        /** Returns the column number of the end of this event.*/\n        public int getEndColumnNumber() {\n            return fEndColumnNumber;\n        } // getEndColumnNumber():int\n\n        /** Returns the character offset of the end of this event.*/\n        public int getEndCharacterOffset() { \n            return fEndCharacterOffset;\n        } // getEndCharacterOffset():int\n\n        // other information\n\n        /** Returns true if this corresponding event was synthesized. */\n        public boolean isSynthesized() {\n            return false;\n        } // isSynthesize():boolean\n\n        //\n        // Object methods\n        //\n\n        /** Returns a string representation of this object. */\n        public String toString() {\n            StringBuffer str = new StringBuffer();\n            str.append(fBeginLineNumber);\n            str.append(':');\n            str.append(fBeginColumnNumber);\n            str.append(':');\n            str.append(fBeginCharacterOffset);\n            str.append(':');\n            str.append(fEndLineNumber);\n            str.append(':');\n            str.append(fEndColumnNumber);\n            str.append(':');\n            str.append(fEndCharacterOffset);\n            return str.toString();\n        } // toString():String\n\n    } // class LocationItem\n\n    /**\n     * To detect if 2 encoding are compatible, both must be able to read the meta tag specifying\n     * the new encoding. This means that the byte representation of some minimal html markup must\n     * be the same in both encodings\n     */ \n    boolean isEncodingCompatible(final String encoding1, final String encoding2) {\n\t\ttry {\n            try {\n                return canRoundtrip(encoding1, encoding2);\n            }\n            catch (final UnsupportedOperationException e) {\n                // if encoding1 only supports decode, we can test it the other way to only decode with it\n                try {\n                    return canRoundtrip(encoding2, encoding1);\n                }\n                catch (final UnsupportedOperationException e1) {\n                    // encoding2 only supports decode too. Time to give up.\n                    return false;\n                }\n            }\n\t\t}\n\t\tcatch (final UnsupportedEncodingException e) {\n\t\t\treturn false;\n\t\t}\n    }\n\n    private boolean canRoundtrip(final String encodeCharset, final String decodeCharset) throws UnsupportedEncodingException {\n        final String reference = \"<html><head><meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=\";\n        final byte[] bytesEncoding1 = reference.getBytes(encodeCharset);\n        final String referenceWithEncoding2 = new String(bytesEncoding1, decodeCharset);\n        return reference.equals(referenceWithEncoding2);\n    }\n\n    private boolean endsWith(final XMLStringBuffer buffer, final String string) {\n\t\tfinal int l = string.length();\n\t\tif (buffer.length < l) {\n\t\t\treturn false;\n\t\t}\n\t\tfinal String s = new String(buffer.ch, buffer.length-l, l);\n\t\treturn string.equals(s);\n\t}\n\n     /** Reads a single character, preserving the old buffer content */\n     protected int readPreservingBufferContent() throws IOException {\n         if (DEBUG_BUFFER) { \n             fCurrentEntity.debugBufferIfNeeded(\"(read: \");\n         }\n         if (fCurrentEntity.offset == fCurrentEntity.length) {\n             if (fCurrentEntity.load(fCurrentEntity.length) < 1) {\n                 if (DEBUG_BUFFER) { \n                     System.out.println(\")read: -> -1\");\n                 }\n                 return -1;\n             }\n         }\n         final char c = fCurrentEntity.getNextChar();\n         if (DEBUG_BUFFER) { \n             fCurrentEntity.debugBufferIfNeeded(\")read: \", \" -> \" + c);\n         }\n         return c;\n     } // readPreservingBufferContent():int\n\n     /**\n     * Indicates if the end comment --> is available, loading further data if needed, without to reset the buffer\n     */\n\tprivate boolean endCommentAvailable() throws IOException {\n\t\tint nbCaret = 0;\n        final int originalOffset = fCurrentEntity.offset;\n        final int originalColumnNumber = fCurrentEntity.getColumnNumber();\n        final int originalCharacterOffset = fCurrentEntity.getCharacterOffset();\n\n\t\twhile (true) {\n\t        int c = readPreservingBufferContent();\n\t        if (c == -1) {\n\t\t        fCurrentEntity.restorePosition(originalOffset, originalColumnNumber, originalCharacterOffset);\n\t        \treturn false;\n\t        }\n\t        else if (c == '>' && nbCaret >= 2) {\n\t\t        fCurrentEntity.restorePosition(originalOffset, originalColumnNumber, originalCharacterOffset);\n\t        \treturn true;\n\t        }\n\t        else if (c == '-') {\n\t        \tnbCaret++;\n\t        }\n\t        else {\n\t        \tnbCaret = 0;\n\t        }\n\t\t}\n\t}\n\n\t/**\n     * Reduces the buffer to the content between start and end marker when\n     * only whitespaces are found before the startMarker as well as after the end marker\n     */\n\tstatic void reduceToContent(final XMLStringBuffer buffer, final String startMarker, final String endMarker) {\n\t\tint i = 0;\n\t\tint startContent = -1;\n\t\tfinal int l1 = startMarker.length();\n\t\tfinal int l2 = endMarker.length();\n\t\twhile (i < buffer.length - l1 - l2) {\n\t\t\tfinal char c = buffer.ch[buffer.offset+i];\n\t\t\tif (Character.isWhitespace(c)) {\n\t\t\t\t++i;\n\t\t\t}\n\t\t\telse if (c == startMarker.charAt(0)\n\t\t\t\t&& startMarker.equals(new String(buffer.ch, buffer.offset+i, l1))) {\n\t\t\t\tstartContent = buffer.offset + i + l1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn; // start marker not found\n\t\t\t}\n\t\t}\n\t\tif (startContent == -1) { // start marker not found\n\t\t\treturn;\n\t\t}\n\t\t\n\t\ti = buffer.length - 1;\n\t\twhile (i > startContent + l2) {\n\t\t\tfinal char c = buffer.ch[buffer.offset+i];\n\t\t\tif (Character.isWhitespace(c)) {\n\t\t\t\t--i;\n\t\t\t}\n\t\t\telse if (c == endMarker.charAt(l2-1)\n\t\t\t\t&& endMarker.equals(new String(buffer.ch, buffer.offset+i-l2+1, l2))) {\n\t\t\t\t\n\t\t\t\tbuffer.length = buffer.offset + i - startContent - 2;\n\t\t\t\tbuffer.offset = startContent;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn; // start marker not found\n\t\t\t}\n\t\t}\n\t}\n} // class HTMLScanner\n"], "filenames": ["src/org/cyberneko/html/HTMLScanner.java"], "buggy_code_start_loc": [2591], "buggy_code_end_loc": [2592], "fixing_code_start_loc": [2591], "fixing_code_end_loc": [2592], "type": "CWE-400", "message": "org.cyberneko.html is an html parser written in Java. The fork of `org.cyberneko.html` used by Nokogiri (Rubygem) raises a `java.lang.OutOfMemoryError` exception when parsing ill-formed HTML markup. Users are advised to upgrade to `>= 1.9.22.noko2`. Note: The upstream library `org.cyberneko.html` is no longer maintained. Nokogiri uses its own fork of this library located at https://github.com/sparklemotion/nekohtml and this CVE applies only to that fork. Other forks of nekohtml may have a similar vulnerability.", "other": {"cve": {"id": "CVE-2022-24839", "sourceIdentifier": "security-advisories@github.com", "published": "2022-04-11T22:15:07.440", "lastModified": "2023-02-23T20:19:25.633", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "org.cyberneko.html is an html parser written in Java. The fork of `org.cyberneko.html` used by Nokogiri (Rubygem) raises a `java.lang.OutOfMemoryError` exception when parsing ill-formed HTML markup. Users are advised to upgrade to `>= 1.9.22.noko2`. Note: The upstream library `org.cyberneko.html` is no longer maintained. Nokogiri uses its own fork of this library located at https://github.com/sparklemotion/nekohtml and this CVE applies only to that fork. Other forks of nekohtml may have a similar vulnerability."}, {"lang": "es", "value": "org.cyberneko.html es un analizador de HTML escrito en Java. El fork de \"org.cyberneko.html\" usado por Nokogiri (Rubygem) lanza una excepci\u00f3n \"java.lang.OutOfMemoryError\" cuando analiza marcas HTML mal formadas. Es recomendado a usuarios actualizar a \"versiones posteriores a 1.9.22.noko2 incluy\u00e9ndola\". Nota: La biblioteca \"org.cyberneko.html\" ya no es mantenida. Nokogiri usa su propia bifurcaci\u00f3n de esta biblioteca ubicada en https://github.com/sparklemotion/nekohtml y esta CVE s\u00f3lo es aplicada a esa bifurcaci\u00f3n. Otros forks de nekohtml pueden presentar una vulnerabilidad similar"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nekohtml_project:nekohtml:*:*:*:*:*:nokogiri:*:*", "versionEndExcluding": "1.9.22.noko2", "matchCriteriaId": "478B44F1-2C38-4CCF-B692-AE9B56FBD745"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:weblogic_server:12.2.1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "F14A818F-AA16-4438-A3E4-E64C9287AC66"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:weblogic_server:12.2.1.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "4A5BB153-68E0-4DDA-87D1-0D9AB7F0A418"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:weblogic_server:14.1.1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "04BCDC24-4A21-473C-8733-0D9CFB38A752"}]}]}], "references": [{"url": "https://github.com/sparklemotion/nekohtml/commit/a800fce3b079def130ed42a408ff1d09f89e773d", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/sparklemotion/nekohtml/security/advisories/GHSA-9849-p7jc-9rmv", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujul2022.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sparklemotion/nekohtml/commit/a800fce3b079def130ed42a408ff1d09f89e773d"}}