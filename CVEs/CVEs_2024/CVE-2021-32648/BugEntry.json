{"buggy_code": ["<?php namespace October\\Rain\\Auth;\n\nuse Cookie;\nuse Session;\nuse Request;\nuse Illuminate\\Contracts\\Auth\\Authenticatable;\n\n/**\n * Authentication manager\n */\nclass Manager implements \\Illuminate\\Contracts\\Auth\\StatefulGuard\n{\n    use \\October\\Rain\\Support\\Traits\\Singleton;\n\n    /**\n     * @var Models\\User The currently logged in user\n     */\n    protected $user;\n\n    /**\n     * @var array In memory throttle cache [md5($userId.$ipAddress) => $this->throttleModel]\n     */\n    protected $throttle = [];\n\n    /**\n     * @var string User Model Class\n     */\n    protected $userModel = Models\\User::class;\n\n    /**\n     * @var string User Group Model Class\n     */\n    protected $groupModel = Models\\Group::class;\n\n    /**\n     * @var string Throttle Model Class\n     */\n    protected $throttleModel = Models\\Throttle::class;\n\n    /**\n     * @var bool Flag to enable login throttling\n     */\n    protected $useThrottle = true;\n\n    /**\n     * @var bool Internal flag to toggle using the session for the current authentication request\n     */\n    protected $useSession = true;\n\n    /**\n     * @var bool Flag to require users to be activated to login\n     */\n    protected $requireActivation = true;\n\n    /**\n     * @var string Key to store the auth session data in\n     */\n    protected $sessionKey = 'october_auth';\n\n    /**\n     * @var bool Indicates if the user was authenticated via a recaller cookie.\n     */\n    protected $viaRemember = false;\n\n    /**\n     * @var string The IP address of this request\n     */\n    public $ipAddress = '0.0.0.0';\n\n    /**\n     * Initializes the singleton\n     */\n    protected function init()\n    {\n        $this->ipAddress = Request::ip();\n    }\n\n    //\n    // User\n    //\n\n    /**\n     * Creates a new instance of the user model\n     *\n     * @return Models\\User\n     */\n    public function createUserModel()\n    {\n        $class = '\\\\'.ltrim($this->userModel, '\\\\');\n        return new $class();\n    }\n\n    /**\n     * Prepares a query derived from the user model.\n     *\n     * @return \\October\\Rain\\Database\\Builder $query\n     */\n    protected function createUserModelQuery()\n    {\n        $model = $this->createUserModel();\n        $query = $model->newQuery();\n        $this->extendUserQuery($query);\n\n        return $query;\n    }\n\n    /**\n     * Extend the query used for finding the user.\n     * @param \\October\\Rain\\Database\\Builder $query\n     * @return void\n     */\n    public function extendUserQuery($query)\n    {\n    }\n\n    /**\n     * Registers a user with the provided credentials with optional flags\n     * for activating the newly created user and automatically logging them in\n     *\n     * @param array $credentials\n     * @param bool $activate\n     * @param bool $autoLogin\n     * @return Models\\User\n     */\n    public function register(array $credentials, $activate = false, $autoLogin = true)\n    {\n        $user = $this->createUserModel();\n        $user->fill($credentials);\n        $user->save();\n\n        if ($activate) {\n            $user->attemptActivation($user->getActivationCode());\n        }\n\n        // Prevents revalidation of the password field\n        // on subsequent saves to this model object\n        $user->password = null;\n\n        if ($autoLogin) {\n            $this->user = $user;\n        }\n\n        return $user;\n    }\n\n    /**\n     * Sets the user\n     */\n    public function setUser(Authenticatable $user)\n    {\n        $this->user = $user;\n    }\n\n    /**\n     * Returns the current user, if any.\n     *\n     * @return mixed (Models\\User || null)\n     */\n    public function getUser()\n    {\n        if (is_null($this->user)) {\n            $this->check();\n        }\n\n        return $this->user;\n    }\n\n    /**\n     * Finds a user by the login value.\n     *\n     * @param string $id\n     * @return mixed (Models\\User || null)\n     */\n    public function findUserById($id)\n    {\n        $query = $this->createUserModelQuery();\n\n        $user = $query->find($id);\n\n        return $this->validateUserModel($user) ? $user : null;\n    }\n\n    /**\n     * Finds a user by the login value.\n     *\n     * @param string $login\n     * @return mixed (Models\\User || null)\n     */\n    public function findUserByLogin($login)\n    {\n        $model = $this->createUserModel();\n\n        $query = $this->createUserModelQuery();\n\n        $user = $query->where($model->getLoginName(), $login)->first();\n\n        return $this->validateUserModel($user) ? $user : null;\n    }\n\n    /**\n     * Finds a user by the given credentials.\n     *\n     * @param array $credentials The credentials to find a user by\n     * @throws AuthException If the credentials are invalid\n     * @return Models\\User The requested user\n     */\n    public function findUserByCredentials(array $credentials)\n    {\n        $model = $this->createUserModel();\n        $loginName = $model->getLoginName();\n\n        if (!array_key_exists($loginName, $credentials)) {\n            throw new AuthException(sprintf('Login attribute \"%s\" was not provided.', $loginName));\n        }\n\n        $query = $this->createUserModelQuery();\n        $hashableAttributes = $model->getHashableAttributes();\n        $hashedCredentials = [];\n\n        /*\n         * Build query from given credentials\n         */\n        foreach ($credentials as $credential => $value) {\n            // All excepted the hashed attributes\n            if (in_array($credential, $hashableAttributes)) {\n                $hashedCredentials = array_merge($hashedCredentials, [$credential => $value]);\n            }\n            else {\n                $query = $query->where($credential, '=', $value);\n            }\n        }\n\n        $user = $query->first();\n        if (!$this->validateUserModel($user)) {\n            throw new AuthException('A user was not found with the given credentials.');\n        }\n\n        /*\n         * Check the hashed credentials match\n         */\n        foreach ($hashedCredentials as $credential => $value) {\n            if (!$user->checkHashValue($credential, $value)) {\n                // Incorrect password\n                if ($credential == 'password') {\n                    throw new AuthException(sprintf(\n                        'A user was found to match all plain text credentials however hashed credential \"%s\" did not match.',\n                        $credential\n                    ));\n                }\n\n                // User not found\n                throw new AuthException('A user was not found with the given credentials.');\n            }\n        }\n\n        return $user;\n    }\n\n    /**\n     * Perform additional checks on the user model.\n     *\n     * @param $user\n     * @return boolean\n     */\n    protected function validateUserModel($user)\n    {\n        return $user instanceof $this->userModel;\n    }\n\n    //\n    // Throttle\n    //\n\n    /**\n     * Creates an instance of the throttle model\n     *\n     * @return Models\\Throttle\n     */\n    public function createThrottleModel()\n    {\n        $class = '\\\\'.ltrim($this->throttleModel, '\\\\');\n        return new $class();\n    }\n\n    /**\n     * Find a throttle record by login and ip address\n     *\n     * @param string $loginName\n     * @param string $ipAddress\n     * @return Models\\Throttle\n     */\n    public function findThrottleByLogin($loginName, $ipAddress)\n    {\n        $user = $this->findUserByLogin($loginName);\n        if (!$user) {\n            throw new AuthException(\"A user was not found with the given credentials.\");\n        }\n\n        $userId = $user->getKey();\n        return $this->findThrottleByUserId($userId, $ipAddress);\n    }\n\n    /**\n     * Find a throttle record by user id and ip address\n     *\n     * @param integer $userId\n     * @param string $ipAddress\n     * @return Models\\Throttle\n     */\n    public function findThrottleByUserId($userId, $ipAddress = null)\n    {\n        $cacheKey = md5($userId.$ipAddress);\n        if (isset($this->throttle[$cacheKey])) {\n            return $this->throttle[$cacheKey];\n        }\n\n        $model = $this->createThrottleModel();\n        $query = $model->where('user_id', '=', $userId);\n\n        if ($ipAddress) {\n            $query->where(function ($query) use ($ipAddress) {\n                $query->where('ip_address', '=', $ipAddress);\n                $query->orWhere('ip_address', '=', null);\n            });\n        }\n\n        if (!$throttle = $query->first()) {\n            $throttle = $this->createThrottleModel();\n            $throttle->user_id = $userId;\n            if ($ipAddress) {\n                $throttle->ip_address = $ipAddress;\n            }\n\n            $throttle->save();\n        }\n\n        return $this->throttle[$cacheKey] = $throttle;\n    }\n\n    //\n    // Business Logic\n    //\n\n    /**\n     * Attempt to authenticate a user using the given credentials.\n     *\n     * @param array $credentials The user login details\n     * @param bool $remember Store a non-expire cookie for the user\n     * @throws AuthException If authentication fails\n     * @return Models\\User The successfully logged in user\n     */\n    public function attempt(array $credentials = [], $remember = false)\n    {\n        return !!$this->authenticate($credentials, $remember);\n    }\n\n    /**\n     * Validate a user's credentials.\n     *\n     * @param  array  $credentials\n     * @return bool\n     */\n    public function validate(array $credentials = [])\n    {\n        return !!$this->validateInternal($credentials);\n    }\n\n    /**\n     * Validate a user's credentials, method used internally.\n     *\n     * @param  array  $credentials\n     * @return User\n     */\n    protected function validateInternal(array $credentials = [])\n    {\n        /*\n         * Default to the login name field or fallback to a hard-coded 'login' value\n         */\n        $loginName = $this->createUserModel()->getLoginName();\n        $loginCredentialKey = isset($credentials[$loginName]) ? $loginName : 'login';\n\n        if (empty($credentials[$loginCredentialKey])) {\n            throw new AuthException(sprintf('The \"%s\" attribute is required.', $loginCredentialKey));\n        }\n\n        if (empty($credentials['password'])) {\n            throw new AuthException('The password attribute is required.');\n        }\n\n        /*\n         * If the fallback 'login' was provided and did not match the necessary\n         * login name, swap it over\n         */\n        if ($loginCredentialKey !== $loginName) {\n            $credentials[$loginName] = $credentials[$loginCredentialKey];\n            unset($credentials[$loginCredentialKey]);\n        }\n\n        /*\n         * If throttling is enabled, check they are not locked out first and foremost.\n         */\n        if ($this->useThrottle) {\n            $throttle = $this->findThrottleByLogin($credentials[$loginName], $this->ipAddress);\n            $throttle->check();\n        }\n\n        /*\n         * Look up the user by authentication credentials.\n         */\n        try {\n            $user = $this->findUserByCredentials($credentials);\n        }\n        catch (AuthException $ex) {\n            if ($this->useThrottle) {\n                $throttle->addLoginAttempt();\n            }\n\n            throw $ex;\n        }\n\n        if ($this->useThrottle) {\n            $throttle->clearLoginAttempts();\n        }\n\n        return $user;\n    }\n\n    /**\n     * Attempts to authenticate the given user according to the passed credentials.\n     *\n     * @param array $credentials The user login details\n     * @param bool $remember Store a non-expire cookie for the user\n     */\n    public function authenticate(array $credentials, $remember = true)\n    {\n        $user = $this->validateInternal($credentials);\n\n        $user->clearResetPassword();\n\n        $this->login($user, $remember);\n\n        return $this->user;\n    }\n\n    /**\n     * Check to see if the user is logged in and activated, and hasn't been banned or suspended.\n     *\n     * @return bool\n     */\n    public function check()\n    {\n        if (is_null($this->user)) {\n            /*\n             * Check session first, follow by cookie\n             */\n            if ($sessionArray = Session::get($this->sessionKey)) {\n                $userArray = $sessionArray;\n            }\n            elseif ($cookieArray = Cookie::get($this->sessionKey)) {\n                $this->viaRemember = true;\n                /*\n                 * Shift gracefully to unserialized cookies\n                 * @todo Remove if statement below if year >= 2021 or build >= 475\n                 */\n                if (is_array($cookieArray)) {\n                    $userArray = $cookieArray;\n                }\n                else {\n                    $userArray = @json_decode($cookieArray, true);\n                }\n            }\n            else {\n                return false;\n            }\n\n            /*\n             * Check supplied session/cookie is an array (user id, persist code)\n             */\n            if (!is_array($userArray) || count($userArray) !== 2) {\n                return false;\n            }\n\n            list($id, $persistCode) = $userArray;\n\n            /*\n             * Look up user\n             */\n            if (!$user = $this->findUserById($id)) {\n                return false;\n            }\n\n            /*\n             * Confirm the persistence code is valid, otherwise reject\n             */\n            if (!$user->checkPersistCode($persistCode)) {\n                return false;\n            }\n\n            /*\n             * Pass\n             */\n            $this->user = $user;\n        }\n\n        /*\n         * Check cached user is activated\n         */\n        if (!($user = $this->getUser()) || ($this->requireActivation && !$user->is_activated)) {\n            return false;\n        }\n\n        /*\n         * Throttle check\n         */\n        if ($this->useThrottle) {\n            $throttle = $this->findThrottleByUserId($user->getKey(), $this->ipAddress);\n\n            if ($throttle->is_banned || $throttle->checkSuspended()) {\n                $this->logout();\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Determine if the current user is a guest.\n     *\n     * @return bool\n     */\n    public function guest()\n    {\n        return false;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        return $this->getUser();\n    }\n\n    /**\n     * Get the ID for the currently authenticated user.\n     *\n     * @return int|null\n     */\n    public function id()\n    {\n        if ($user = $this->getUser()) {\n            return $user->getAuthIdentifier();\n        }\n\n        return null;\n    }\n\n    /**\n     * Log a user into the application without sessions or cookies.\n     *\n     * @param  array  $credentials\n     * @return bool\n     */\n    public function once(array $credentials = [])\n    {\n        $this->useSession = false;\n\n        $user = $this->authenticate($credentials);\n\n        $this->useSession = true;\n\n        return !!$user;\n    }\n\n    /**\n     * Log the given user ID into the application without sessions or cookies.\n     *\n     * @param  mixed  $id\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|false\n     */\n    public function onceUsingId($id)\n    {\n        if (!is_null($user = $this->findUserById($id))) {\n            $this->setUser($user);\n\n            return $user;\n        }\n\n        return false;\n    }\n\n    /**\n     * Logs in the given user and sets properties\n     * in the session.\n     * @throws AuthException If the user is not activated and $this->requireActivation = true\n     */\n    public function login(Authenticatable $user, $remember = true)\n    {\n        /*\n         * Fire the 'beforeLogin' event\n         */\n        $user->beforeLogin();\n\n        /*\n         * Activation is required, user not activated\n         */\n        if ($this->requireActivation && !$user->is_activated) {\n            $login = $user->getLogin();\n            throw new AuthException(sprintf(\n                'Cannot login user \"%s\" as they are not activated.',\n                $login\n            ));\n        }\n\n        $this->user = $user;\n\n        /*\n         * Create session/cookie data to persist the session\n         */\n        if ($this->useSession) {\n            $toPersist = [$user->getKey(), $user->getPersistCode()];\n            Session::put($this->sessionKey, $toPersist);\n\n            if ($remember) {\n                Cookie::queue(Cookie::forever($this->sessionKey, json_encode($toPersist)));\n            }\n        }\n\n        /*\n         * Fire the 'afterLogin' event\n         */\n        $user->afterLogin();\n    }\n\n    /**\n     * Log the given user ID into the application.\n     *\n     * @param  mixed  $id\n     * @param  bool   $remember\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable\n     */\n    public function loginUsingId($id, $remember = false)\n    {\n        if (!is_null($user = $this->findUserById($id))) {\n            $this->login($user, $remember);\n\n            return $user;\n        }\n\n        return false;\n    }\n\n    /**\n     * Determine if the user was authenticated via \"remember me\" cookie.\n     *\n     * @return bool\n     */\n    public function viaRemember()\n    {\n        return $this->viaRemember;\n    }\n\n    /**\n     * Logs the current user out.\n     */\n    public function logout()\n    {\n        // Initialize the current auth session before trying to remove it\n        if (is_null($this->user) && !$this->check()) {\n            return;\n        }\n\n        if ($this->isImpersonator()) {\n            $this->user = $this->getImpersonator();\n            $this->stopImpersonate();\n            return;\n        }\n\n        if ($this->user) {\n            $this->user->setRememberToken(null);\n            $this->user->forceSave();\n        }\n\n        $this->user = null;\n\n        Session::invalidate();\n        Cookie::queue(Cookie::forget($this->sessionKey));\n    }\n\n    //\n    // Impersonation\n    //\n\n    /**\n     * Impersonates the given user and sets properties\n     * in the session but not the cookie.\n     */\n    public function impersonate($user)\n    {\n        $oldSession = Session::get($this->sessionKey);\n        $oldUser = !empty($oldSession[0]) ? $this->findUserById($oldSession[0]) : false;\n\n        /**\n         * @event model.auth.beforeImpersonate\n         * Called after the model is booted\n         *\n         * Example usage:\n         *\n         *     $model->bindEvent('model.auth.beforeImpersonate', function (\\October\\Rain\\Database\\Model|false $oldUser) use (\\October\\Rain\\Database\\Model $model) {\n         *         \\Log::info($oldUser->full_name . ' is now impersonating ' . $model->full_name);\n         *     });\n         *\n         */\n        $user->fireEvent('model.auth.beforeImpersonate', [$oldUser]);\n\n        $this->login($user, false);\n\n        if (!$this->isImpersonator()) {\n            Session::put($this->sessionKey.'_impersonate', $oldSession);\n        }\n    }\n\n    /**\n     * Stop the current session being impersonated and\n     * authenticate as the impersonator again\n     */\n    public function stopImpersonate()\n    {\n        $currentSession = Session::get($this->sessionKey);\n        $currentUser = !empty($currentSession[0]) ? $this->findUserById($currentSession[0]) : false;\n        $oldSession = Session::pull($this->sessionKey.'_impersonate');\n        $oldUser = !empty($oldSession[0]) ? $this->findUserById($oldSession[0]) : false;\n\n        if ($currentUser) {\n            /**\n             * @event model.auth.afterImpersonate\n             * Called after the model is booted\n             *\n             * Example usage:\n             *\n             *     $model->bindEvent('model.auth.afterImpersonate', function (\\October\\Rain\\Database\\Model|false $oldUser) use (\\October\\Rain\\Database\\Model $model) {\n             *         \\Log::info($oldUser->full_name . ' has stopped impersonating ' . $model->full_name);\n             *     });\n             *\n             */\n            $currentUser->fireEvent('model.auth.afterImpersonate', [$oldUser]);\n        }\n\n        Session::put($this->sessionKey, $oldSession);\n    }\n\n    /**\n     * Check to see if the current session is being impersonated\n     *\n     * @return bool\n     */\n    public function isImpersonator()\n    {\n        return !empty(Session::has($this->sessionKey.'_impersonate'));\n    }\n\n    /**\n     * Get the original user doing the impersonation\n     *\n     * @return mixed Returns the User model for the impersonator if able, false if not\n     */\n    public function getImpersonator()\n    {\n        $impersonateArray = Session::get($this->sessionKey.'_impersonate');\n\n        /*\n         * Check supplied session/cookie is an array (user id, persist code)\n         */\n        if (!is_array($impersonateArray) || count($impersonateArray) !== 2) {\n            return false;\n        }\n\n        $id = $impersonateArray[0];\n\n        return $this->createUserModel()->find($id);\n    }\n}\n", "<?php namespace October\\Rain\\Auth\\Models;\n\nuse InvalidArgumentException;\nuse October\\Rain\\Database\\Model;\n\n/**\n * Role model\n */\nclass Role extends Model\n{\n    use \\October\\Rain\\Database\\Traits\\Validation;\n\n    /**\n     * @var string The table associated with the model.\n     */\n    protected $table = 'roles';\n\n    /**\n     * @var array Validation rules\n     */\n    public $rules = [\n        'name' => 'required|between:4,16|unique:role',\n    ];\n\n    /**\n     * @var array Relations\n     */\n    public $hasMany = [\n        'users' => User::class\n    ];\n\n    /**\n     * @var array List of attribute names which are json encoded and decoded from the database.\n     */\n    protected $jsonable = ['permissions'];\n\n    /**\n     * @var array Allowed permissions values.\n     *\n     * Possible options:\n     *    0 => Remove.\n     *    1 => Add.\n     */\n    protected $allowedPermissionsValues = [0, 1];\n\n    /**\n     * @var array The attributes that aren't mass assignable.\n     */\n    protected $guarded = [];\n\n    /**\n     * See if a role has access to the passed permission(s).\n     *\n     * If multiple permissions are passed, the role must\n     * have access to all permissions passed through, unless the\n     * \"all\" flag is set to false.\n     *\n     * @param  string|array  $permissions\n     * @param  bool  $all\n     * @return bool\n     */\n    public function hasAccess($permissions, $all = true)\n    {\n        $rolePermissions = $this->permissions;\n\n        if (!is_array($permissions)) {\n            $permissions = (array) $permissions;\n        }\n\n        foreach ($permissions as $permission) {\n            // We will set a flag now for whether this permission was\n            // matched at all.\n            $matched = true;\n\n            // Now, let's check if the permission ends in a wildcard \"*\" symbol.\n            // If it does, we'll check through all the merged permissions to see\n            // if a permission exists which matches the wildcard.\n            if ((strlen($permission) > 1) && ends_with($permission, '*')) {\n                $matched = false;\n\n                foreach ($rolePermissions as $rolePermission => $value) {\n                    // Strip the '*' off the end of the permission.\n                    $checkPermission = substr($permission, 0, -1);\n\n                    // We will make sure that the merged permission does not\n                    // exactly match our permission, but starts with it.\n                    if ($checkPermission != $rolePermission && starts_with($rolePermission, $checkPermission) && $value == 1) {\n                        $matched = true;\n                        break;\n                    }\n                }\n            }\n            // Now, let's check if the permission starts in a wildcard \"*\" symbol.\n            // If it does, we'll check through all the merged permissions to see\n            // if a permission exists which matches the wildcard.\n            elseif ((strlen($permission) > 1) && starts_with($permission, '*')) {\n                $matched = false;\n\n                foreach ($rolePermissions as $rolePermission => $value) {\n                    // Strip the '*' off the start of the permission.\n                    $checkPermission = substr($permission, 1);\n\n                    // We will make sure that the merged permission does not\n                    // exactly match our permission, but ends with it.\n                    if ($checkPermission != $rolePermission && ends_with($rolePermission, $checkPermission) && $value == 1) {\n                        $matched = true;\n                        break;\n                    }\n                }\n            }\n            else {\n                $matched = false;\n\n                foreach ($rolePermissions as $rolePermission => $value) {\n                    // This time check if the rolePermission ends in wildcard \"*\" symbol.\n                    if ((strlen($rolePermission) > 1) && ends_with($rolePermission, '*')) {\n                        $matched = false;\n\n                        // Strip the '*' off the end of the permission.\n                        $checkGroupPermission = substr($rolePermission, 0, -1);\n\n                        // We will make sure that the merged permission does not\n                        // exactly match our permission, but starts with it.\n                        if ($checkGroupPermission != $permission && starts_with($permission, $checkGroupPermission) && $value == 1) {\n                            $matched = true;\n                            break;\n                        }\n                    }\n                    // Otherwise, we'll fallback to standard permissions checking where\n                    // we match that permissions explicitly exist.\n                    elseif ($permission == $rolePermission && $rolePermissions[$permission] == 1) {\n                        $matched = true;\n                        break;\n                    }\n                }\n            }\n\n            // Now, we will check if we have to match all\n            // permissions or any permission and return\n            // accordingly.\n            if ($all === true && $matched === false) {\n                return false;\n            }\n            elseif ($all === false && $matched === true) {\n                return true;\n            }\n        }\n\n        return !($all === false);\n    }\n\n    /**\n     * Returns if the user has access to any of the given permissions.\n     * @param array $permissions\n     * @return bool\n     */\n    public function hasAnyAccess(array $permissions)\n    {\n        return $this->hasAccess($permissions, false);\n    }\n\n    /**\n     * Validate the permissions when set.\n     * @param  array  $permissions\n     * @return void\n     */\n    public function setPermissionsAttribute($permissions)\n    {\n        $permissions = json_decode($permissions, true);\n        foreach ($permissions as $permission => $value) {\n            if (!in_array($value = (int) $value, $this->allowedPermissionsValues)) {\n                throw new InvalidArgumentException(sprintf(\n                    'Invalid value \"%s\" for permission \"%s\" given.',\n                    $value,\n                    $permission\n                ));\n            }\n\n            if ($value === 0) {\n                unset($permissions[$permission]);\n            }\n        }\n\n        $this->attributes['permissions'] = !empty($permissions) ? json_encode($permissions) : '';\n    }\n}\n", "<?php namespace October\\Rain\\Auth\\Models;\n\nuse Carbon\\Carbon;\nuse October\\Rain\\Auth\\AuthException;\nuse October\\Rain\\Database\\Model;\n\n/**\n * Throttle model\n */\nclass Throttle extends Model\n{\n    /**\n     * @var bool Throttling status.\n     */\n    protected $enabled = true;\n\n    /**\n     * @var string The table associated with the model.\n     */\n    protected $table = 'throttle';\n\n    /**\n     * @var array Relations\n     */\n    public $belongsTo = [\n        'user' => [User::class, 'key' => 'user_id']\n    ];\n\n    /**\n     * @var bool Indicates if the model should be timestamped.\n     */\n    public $timestamps = false;\n\n    /**\n     * The attributes that should be mutated to dates.\n     *\n     * @var array\n     */\n    protected $dates = ['last_attempt_at', 'suspended_at', 'banned_at'];\n\n    /**\n     * @var int Attempt limit.\n     */\n    protected static $attemptLimit = 5;\n\n    /**\n     * @var int Suspensions time in minutes.\n     */\n    protected static $suspensionTime = 15;\n\n    /**\n     * Returns the associated user with the throttler.\n     * @return User\n     */\n    public function getUser()\n    {\n        return $this->user()->getResults();\n    }\n\n    /**\n     * Get the current amount of attempts.\n     * @return int\n     */\n    public function getLoginAttempts()\n    {\n        if ($this->attempts > 0 and $this->last_attempt_at) {\n            $this->clearLoginAttemptsIfAllowed();\n        }\n\n        return $this->attempts;\n    }\n\n    /**\n     * Add a new login attempt.\n     * @return void\n     */\n    public function addLoginAttempt()\n    {\n        $this->attempts++;\n        $this->last_attempt_at = $this->freshTimestamp();\n\n        if ($this->getLoginAttempts() >= static::$attemptLimit) {\n            $this->suspend();\n        }\n        else {\n            $this->save();\n        }\n    }\n\n    /**\n     * Clear all login attempts\n     * @return void\n     */\n    public function clearLoginAttempts()\n    {\n        // If our login attempts is already at zero\n        // we do not need to do anything. Additionally,\n        // if we are suspended, we are not going to do\n        // anything either as clearing login attempts\n        // makes us unsuspended. We need to manually\n        // call unsuspend() in order to unsuspend.\n        if ($this->getLoginAttempts() == 0 or $this->is_suspended) {\n            return;\n        }\n\n        $this->attempts = 0;\n        $this->last_attempt_at = null;\n        $this->is_suspended = false;\n        $this->suspended_at = null;\n        $this->save();\n    }\n\n    /**\n     * Suspend the user associated with the throttle\n     * @return void\n     */\n    public function suspend()\n    {\n        if (!$this->is_suspended) {\n            $this->is_suspended = true;\n            $this->suspended_at = $this->freshTimestamp();\n            $this->save();\n        }\n    }\n\n    /**\n     * Unsuspend the user.\n     * @return void\n     */\n    public function unsuspend()\n    {\n        if ($this->is_suspended) {\n            $this->attempts = 0;\n            $this->last_attempt_at = null;\n            $this->is_suspended = false;\n            $this->suspended_at = null;\n            $this->save();\n        }\n    }\n\n    /**\n     * Check if the user is suspended.\n     * @return bool\n     */\n    public function checkSuspended()\n    {\n        if ($this->is_suspended && $this->suspended_at) {\n            $this->removeSuspensionIfAllowed();\n            return (bool) $this->is_suspended;\n        }\n\n        return false;\n    }\n\n    /**\n     * Ban the user.\n     * @return void\n     */\n    public function ban()\n    {\n        if (!$this->is_banned) {\n            $this->is_banned = true;\n            $this->banned_at = $this->freshTimestamp();\n            $this->save();\n        }\n    }\n\n    /**\n     * Unban the user.\n     * @return void\n     */\n    public function unban()\n    {\n        if ($this->is_banned) {\n            $this->is_banned = false;\n            $this->banned_at = null;\n            $this->save();\n        }\n    }\n\n    /**\n     * Check user throttle status.\n     * @return bool\n     * @throws AuthException\n     */\n    public function check()\n    {\n        if ($this->is_banned) {\n            throw new AuthException(sprintf(\n                'User [%s] has been banned.',\n                $this->user->getLogin()\n            ));\n        }\n\n        if ($this->checkSuspended()) {\n            throw new AuthException(sprintf(\n                'User [%s] has been suspended.',\n                $this->user->getLogin()\n            ));\n        }\n\n        return true;\n    }\n\n    /**\n     * Inspects the last attempt vs the suspension time\n     * (the time in which attempts must space before the\n     * account is suspended). If we can clear our attempts\n     * now, we'll do so and save.\n     *\n     * @return void\n     */\n    public function clearLoginAttemptsIfAllowed()\n    {\n        $lastAttempt = clone $this->last_attempt_at;\n\n        $suspensionTime = static::$suspensionTime;\n        $clearAttemptsAt = $lastAttempt->modify(\"+{$suspensionTime} minutes\");\n        $now = new Carbon;\n\n        if ($clearAttemptsAt <= $now) {\n            $this->attempts = 0;\n            $this->save();\n        }\n\n        unset($lastAttempt, $clearAttemptsAt, $now);\n    }\n\n    /**\n     * Inspects to see if the user can become unsuspended\n     * or not, based on the suspension time provided. If so,\n     * unsuspends.\n     *\n     * @return void\n     */\n    public function removeSuspensionIfAllowed()\n    {\n        $suspended = clone $this->suspended_at;\n\n        $suspensionTime = static::$suspensionTime;\n        $unsuspendAt = $suspended->modify(\"+{$suspensionTime} minutes\");\n        $now = new Carbon;\n\n        if ($unsuspendAt <= $now) {\n            $this->unsuspend();\n        }\n\n        unset($suspended, $unsuspendAt, $now);\n    }\n\n    /**\n     * Get mutator for the suspended property.\n     * @param  mixed  $suspended\n     * @return bool\n     */\n    public function getIsSuspendedAttribute($suspended)\n    {\n        return (bool) $suspended;\n    }\n\n    /**\n     * Get mutator for the banned property.\n     * @param  mixed  $banned\n     * @return bool\n     */\n    public function getIsBannedAttribute($banned)\n    {\n        return (bool) $banned;\n    }\n}\n", "<?php namespace October\\Rain\\Auth\\Models;\n\nuse Str;\nuse Hash;\nuse October\\Rain\\Database\\Model;\nuse InvalidArgumentException;\nuse Exception;\n\n/**\n * User model\n */\nclass User extends Model implements \\Illuminate\\Contracts\\Auth\\Authenticatable\n{\n    use \\October\\Rain\\Database\\Traits\\Hashable;\n    use \\October\\Rain\\Database\\Traits\\Purgeable;\n    use \\October\\Rain\\Database\\Traits\\Validation;\n\n    /**\n     * @var string The table associated with the model.\n     */\n    protected $table = 'users';\n\n    /**\n     * @var array Validation rules\n     */\n    public $rules = [\n        'email' => 'required|between:3,255|email|unique:users',\n        'password' => 'required:create|min:4|confirmed',\n        'password_confirmation' => 'required_with:password|min:4'\n    ];\n\n    /**\n     * @var array Relations\n     */\n    public $belongsToMany = [\n        'groups' => [Group::class, 'table' => 'users_groups']\n    ];\n\n    public $belongsTo = [\n        'role' => Role::class\n    ];\n\n    /**\n     * The attributes that should be mutated to dates.\n     *\n     * @var array\n     */\n    protected $dates = ['activated_at', 'last_login'];\n\n    /**\n     * @var array The attributes that should be hidden for arrays.\n     */\n    protected $hidden = ['password', 'reset_password_code', 'activation_code', 'persist_code'];\n\n    /**\n     * @var array The attributes that aren't mass assignable.\n     */\n    protected $guarded = ['is_superuser', 'reset_password_code', 'activation_code', 'persist_code', 'role_id'];\n\n    /**\n     * @var array List of attribute names which should be hashed using the Bcrypt hashing algorithm.\n     */\n    protected $hashable = ['password', 'persist_code'];\n\n    /**\n     * @var array List of attribute names which should not be saved to the database.\n     */\n    protected $purgeable = ['password_confirmation'];\n\n    /**\n     * @var array The array of custom attribute names.\n     */\n    public $attributeNames = [];\n\n    /**\n     * @var array The array of custom error messages.\n     */\n    public $customMessages = [];\n\n    /**\n     * @var array List of attribute names which are json encoded and decoded from the database.\n     */\n    protected $jsonable = ['permissions'];\n\n    /**\n     * Allowed permissions values.\n     *\n     * Possible options:\n     *   -1 => Deny (adds to array, but denies regardless of user's group).\n     *    0 => Remove.\n     *    1 => Add.\n     *\n     * @var array\n     */\n    protected $allowedPermissionsValues = [-1, 0, 1];\n\n    /**\n     * @var string The login attribute.\n     */\n    public static $loginAttribute = 'email';\n\n    /**\n     * @var string The column name of the \"remember me\" token.\n     */\n    protected $rememberTokenName = 'persist_code';\n\n    /**\n     * @var array The user merged permissions.\n     */\n    protected $mergedPermissions;\n\n    /**\n     * @return string Returns the name for the user's login.\n     */\n    public function getLoginName()\n    {\n        return static::$loginAttribute;\n    }\n\n    /**\n     * @return mixed Returns the user's login.\n     */\n    public function getLogin()\n    {\n        return $this->{$this->getLoginName()};\n    }\n\n    /**\n     * Checks if the user is a super user - has access to everything regardless of permissions.\n     * @return bool\n     */\n    public function isSuperUser()\n    {\n        return (bool) $this->is_superuser;\n    }\n\n    //\n    // Events\n    //\n\n    public function beforeLogin()\n    {\n    }\n\n    public function afterLogin()\n    {\n        $this->last_login = $this->freshTimestamp();\n        $this->forceSave();\n    }\n\n    /**\n     * Delete the user groups\n     * @return bool\n     */\n    public function afterDelete()\n    {\n        if ($this->hasRelation('groups')) {\n            $this->groups()->detach();\n        }\n    }\n\n    //\n    // Persistence (used by Cookies and Sessions)\n    //\n\n    /**\n     * Gets a code for when the user is persisted to a cookie or session which identifies the user.\n     * @return string\n     */\n    public function getPersistCode()\n    {\n        $this->persist_code = $this->getRandomString();\n\n        // Our code got hashed\n        $persistCode = $this->persist_code;\n\n        $this->forceSave();\n\n        return $persistCode;\n    }\n\n    /**\n     * Checks the given persist code.\n     * @param string $persistCode\n     * @return bool\n     */\n    public function checkPersistCode($persistCode)\n    {\n        if (!$persistCode || !$this->persist_code) {\n            return false;\n        }\n\n        return $persistCode == $this->persist_code;\n    }\n\n    //\n    // Activation\n    //\n\n    /**\n     * Get mutator for giving the activated property.\n     * @param mixed $activated\n     * @return bool\n     */\n    public function getIsActivatedAttribute($activated)\n    {\n        return (bool) $activated;\n    }\n\n    /**\n     * Get an activation code for the given user.\n     * @return string\n     */\n    public function getActivationCode()\n    {\n        $this->activation_code = $activationCode = $this->getRandomString();\n\n        $this->forceSave();\n\n        return $activationCode;\n    }\n\n    /**\n     * Attempts to activate the given user by checking the activate code. If the user is activated already, an Exception is thrown.\n     * @param string $activationCode\n     * @return bool\n     */\n    public function attemptActivation($activationCode)\n    {\n        if ($this->is_activated) {\n            throw new Exception('User is already active!');\n        }\n\n        if ($activationCode === $this->activation_code) {\n            $this->activation_code = null;\n            $this->is_activated = true;\n            $this->activated_at = $this->freshTimestamp();\n            $this->forceSave();\n            return true;\n        }\n\n        return false;\n    }\n\n    //\n    // Password\n    //\n\n    /**\n     * Checks the password passed matches the user's password.\n     * @param string $password\n     * @return bool\n     */\n    public function checkPassword($password)\n    {\n        return Hash::check($password, $this->password);\n    }\n\n    /**\n     * Get a reset password code for the given user.\n     * @return string\n     */\n    public function getResetPasswordCode()\n    {\n        $this->reset_password_code = $resetCode = $this->getRandomString();\n        $this->forceSave();\n        return $resetCode;\n    }\n\n    /**\n     * Checks if the provided user reset password code is valid without actually resetting the password.\n     * @param string $resetCode\n     * @return bool\n     */\n    public function checkResetPasswordCode($resetCode)\n    {\n        if (!$resetCode || !$this->reset_password_code) {\n            return false;\n        }\n\n        return ($this->reset_password_code == $resetCode);\n    }\n\n    /**\n     * Attempts to reset a user's password by matching the reset code generated with the user's.\n     * @param string $resetCode\n     * @param string $newPassword\n     * @return bool\n     */\n    public function attemptResetPassword($resetCode, $newPassword)\n    {\n        if ($this->checkResetPasswordCode($resetCode)) {\n            $this->password = $newPassword;\n            $this->reset_password_code = null;\n            return $this->forceSave();\n        }\n\n        return false;\n    }\n\n    /**\n     * Wipes out the data associated with resetting a password.\n     * @return void\n     */\n    public function clearResetPassword()\n    {\n        if ($this->reset_password_code) {\n            $this->reset_password_code = null;\n            $this->forceSave();\n        }\n    }\n\n    /**\n     * Protects the password from being reset to null.\n     */\n    public function setPasswordAttribute($value)\n    {\n        if ($this->exists && empty($value)) {\n            unset($this->attributes['password']);\n        }\n        else {\n            $this->attributes['password'] = $value;\n\n            // Password has changed, log out all users\n            $this->attributes['persist_code'] = null;\n        }\n    }\n\n    //\n    // Permissions, Groups & Role\n    //\n\n    /**\n     * Returns an array of groups which the given user belongs to.\n     * @return array\n     */\n    public function getGroups()\n    {\n        return $this->groups;\n    }\n\n    /**\n     * Returns the role assigned to this user.\n     * @return October\\Rain\\Auth\\Models\\Role\n     */\n    public function getRole()\n    {\n        return $this->role;\n    }\n\n    /**\n     * Adds the user to the given group.\n     * @param Group $group\n     * @return bool\n     */\n    public function addGroup($group)\n    {\n        if (!$this->inGroup($group)) {\n            $this->groups()->attach($group);\n            $this->reloadRelations('groups');\n        }\n\n        return true;\n    }\n\n    /**\n     * Removes the user from the given group.\n     * @param Group $group\n     * @return bool\n     */\n    public function removeGroup($group)\n    {\n        if ($this->inGroup($group)) {\n            $this->groups()->detach($group);\n            $this->reloadRelations('groups');\n        }\n\n        return true;\n    }\n\n    /**\n     * See if the user is in the given group.\n     * @param Group $group\n     * @return bool\n     */\n    public function inGroup($group)\n    {\n        foreach ($this->getGroups() as $_group) {\n            if ($_group->getKey() == $group->getKey()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns an array of merged permissions for each group the user is in.\n     * @return array\n     */\n    public function getMergedPermissions()\n    {\n        if (!$this->mergedPermissions) {\n            $permissions = [];\n\n            if (($role = $this->getRole()) && is_array($role->permissions)) {\n                $permissions = array_merge($permissions, $role->permissions);\n            }\n\n            if (is_array($this->permissions)) {\n                $permissions = array_merge($permissions, $this->permissions);\n            }\n\n            $this->mergedPermissions = $permissions;\n        }\n\n        return $this->mergedPermissions;\n    }\n\n    /**\n     * See if a user has access to the passed permission(s).\n     * Permissions are merged from all groups the user belongs to\n     * and then are checked against the passed permission(s).\n     *\n     * If multiple permissions are passed, the user must\n     * have access to all permissions passed through, unless the\n     * \"all\" flag is set to false.\n     *\n     * Super users have access no matter what.\n     *\n     * @param  string|array  $permissions\n     * @param  bool  $all\n     * @return bool\n     */\n    public function hasAccess($permissions, $all = true)\n    {\n        if ($this->isSuperUser()) {\n            return true;\n        }\n\n        return $this->hasPermission($permissions, $all);\n    }\n\n    /**\n     * See if a user has access to the passed permission(s).\n     * Permissions are merged from all groups the user belongs to\n     * and then are checked against the passed permission(s).\n     *\n     * If multiple permissions are passed, the user must\n     * have access to all permissions passed through, unless the\n     * \"all\" flag is set to false.\n     *\n     * Super users DON'T have access no matter what.\n     *\n     * @param  string|array  $permissions\n     * @param  bool  $all\n     * @return bool\n     */\n    public function hasPermission($permissions, $all = true)\n    {\n        $mergedPermissions = $this->getMergedPermissions();\n\n        if (!is_array($permissions)) {\n            $permissions = [$permissions];\n        }\n\n        foreach ($permissions as $permission) {\n            // We will set a flag now for whether this permission was\n            // matched at all.\n            $matched = true;\n\n            // Now, let's check if the permission ends in a wildcard \"*\" symbol.\n            // If it does, we'll check through all the merged permissions to see\n            // if a permission exists which matches the wildcard.\n            if ((strlen($permission) > 1) && ends_with($permission, '*')) {\n                $matched = false;\n\n                foreach ($mergedPermissions as $mergedPermission => $value) {\n                    // Strip the '*' off the end of the permission.\n                    $checkPermission = substr($permission, 0, -1);\n\n                    // We will make sure that the merged permission does not\n                    // exactly match our permission, but starts with it.\n                    if ($checkPermission != $mergedPermission && starts_with($mergedPermission, $checkPermission) && $value == 1) {\n                        $matched = true;\n                        break;\n                    }\n                }\n            }\n            elseif ((strlen($permission) > 1) && starts_with($permission, '*')) {\n                $matched = false;\n\n                foreach ($mergedPermissions as $mergedPermission => $value) {\n                    // Strip the '*' off the beginning of the permission.\n                    $checkPermission = substr($permission, 1);\n\n                    // We will make sure that the merged permission does not\n                    // exactly match our permission, but ends with it.\n                    if ($checkPermission != $mergedPermission && ends_with($mergedPermission, $checkPermission) && $value == 1) {\n                        $matched = true;\n                        break;\n                    }\n                }\n            }\n            else {\n                $matched = false;\n\n                foreach ($mergedPermissions as $mergedPermission => $value) {\n                    // This time check if the mergedPermission ends in wildcard \"*\" symbol.\n                    if ((strlen($mergedPermission) > 1) && ends_with($mergedPermission, '*')) {\n                        $matched = false;\n\n                        // Strip the '*' off the end of the permission.\n                        $checkMergedPermission = substr($mergedPermission, 0, -1);\n\n                        // We will make sure that the merged permission does not\n                        // exactly match our permission, but starts with it.\n                        if ($checkMergedPermission != $permission && starts_with($permission, $checkMergedPermission) && $value == 1) {\n                            $matched = true;\n                            break;\n                        }\n                    }\n\n                    // Otherwise, we'll fallback to standard permissions checking where\n                    // we match that permissions explicitly exist.\n                    elseif ($permission == $mergedPermission && $mergedPermissions[$permission] == 1) {\n                        $matched = true;\n                        break;\n                    }\n                }\n            }\n\n            // Now, we will check if we have to match all\n            // permissions or any permission and return\n            // accordingly.\n            if ($all === true && $matched === false) {\n                return false;\n            }\n            elseif ($all === false && $matched === true) {\n                return true;\n            }\n        }\n\n        return !($all === false);\n    }\n\n    /**\n     * Returns if the user has access to any of the given permissions.\n     * @param  array  $permissions\n     * @return bool\n     */\n    public function hasAnyAccess(array $permissions)\n    {\n        return $this->hasAccess($permissions, false);\n    }\n\n    /**\n     * Validate any set permissions.\n     * @param array $permissions\n     * @return void\n     */\n    public function setPermissionsAttribute($permissions)\n    {\n        $permissions = json_decode($permissions, true) ?: [];\n        foreach ($permissions as $permission => &$value) {\n            if (!in_array($value = (int) $value, $this->allowedPermissionsValues)) {\n                throw new InvalidArgumentException(sprintf(\n                    'Invalid value \"%s\" for permission \"%s\" given.',\n                    $value,\n                    $permission\n                ));\n            }\n\n            if ($value === 0) {\n                unset($permissions[$permission]);\n            }\n        }\n\n        $this->attributes['permissions'] = !empty($permissions) ? json_encode($permissions) : '';\n    }\n\n    //\n    // User Interface\n    //\n\n    /**\n     * Get the name of the unique identifier for the user.\n     * @return string\n     */\n    public function getAuthIdentifierName()\n    {\n        return $this->getKeyName();\n    }\n\n    /**\n     * Get the unique identifier for the user.\n     * @return mixed\n     */\n    public function getAuthIdentifier()\n    {\n        return $this->{$this->getAuthIdentifierName()};\n    }\n\n    /**\n     * Get the password for the user.\n     * @return string\n     */\n    public function getAuthPassword()\n    {\n        return $this->password;\n    }\n\n    /**\n     * Get the e-mail address where password reminders are sent.\n     * @return string\n     */\n    public function getReminderEmail()\n    {\n        return $this->email;\n    }\n\n    /**\n     * Get the token value for the \"remember me\" session.\n     * @return string\n     */\n    public function getRememberToken()\n    {\n        return $this->getPersistCode();\n    }\n\n    /**\n     * Set the token value for the \"remember me\" session.\n     * @param  string $value\n     * @return void\n     */\n    public function setRememberToken($value)\n    {\n        $this->persist_code = $value;\n    }\n\n    /**\n     * Get the column name for the \"remember me\" token.\n     * @return string\n     */\n    public function getRememberTokenName()\n    {\n        return $this->rememberTokenName;\n    }\n\n    //\n    // Helpers\n    //\n\n    /**\n     * Generate a random string\n     * @return string\n     */\n    public function getRandomString($length = 42)\n    {\n        return Str::random($length);\n    }\n}\n"], "fixing_code": ["<?php namespace October\\Rain\\Auth;\n\nuse Cookie;\nuse Session;\nuse Request;\nuse Illuminate\\Contracts\\Auth\\Authenticatable;\n\n/**\n * Authentication manager\n */\nclass Manager implements \\Illuminate\\Contracts\\Auth\\StatefulGuard\n{\n    use \\October\\Rain\\Support\\Traits\\Singleton;\n\n    /**\n     * @var Models\\User The currently logged in user\n     */\n    protected $user;\n\n    /**\n     * @var array In memory throttle cache [md5($userId.$ipAddress) => $this->throttleModel]\n     */\n    protected $throttle = [];\n\n    /**\n     * @var string User Model Class\n     */\n    protected $userModel = Models\\User::class;\n\n    /**\n     * @var string User Group Model Class\n     */\n    protected $groupModel = Models\\Group::class;\n\n    /**\n     * @var string Throttle Model Class\n     */\n    protected $throttleModel = Models\\Throttle::class;\n\n    /**\n     * @var bool Flag to enable login throttling\n     */\n    protected $useThrottle = true;\n\n    /**\n     * @var bool Internal flag to toggle using the session for the current authentication request\n     */\n    protected $useSession = true;\n\n    /**\n     * @var bool Flag to require users to be activated to login\n     */\n    protected $requireActivation = true;\n\n    /**\n     * @var string Key to store the auth session data in\n     */\n    protected $sessionKey = 'october_auth';\n\n    /**\n     * @var bool Indicates if the user was authenticated via a recaller cookie.\n     */\n    protected $viaRemember = false;\n\n    /**\n     * @var string The IP address of this request\n     */\n    public $ipAddress = '0.0.0.0';\n\n    /**\n     * Initializes the singleton\n     */\n    protected function init()\n    {\n        $this->ipAddress = Request::ip();\n    }\n\n    //\n    // User\n    //\n\n    /**\n     * Creates a new instance of the user model\n     *\n     * @return Models\\User\n     */\n    public function createUserModel()\n    {\n        $class = '\\\\'.ltrim($this->userModel, '\\\\');\n        return new $class();\n    }\n\n    /**\n     * Prepares a query derived from the user model.\n     *\n     * @return \\October\\Rain\\Database\\Builder $query\n     */\n    protected function createUserModelQuery()\n    {\n        $model = $this->createUserModel();\n        $query = $model->newQuery();\n        $this->extendUserQuery($query);\n\n        return $query;\n    }\n\n    /**\n     * Extend the query used for finding the user.\n     * @param \\October\\Rain\\Database\\Builder $query\n     * @return void\n     */\n    public function extendUserQuery($query)\n    {\n    }\n\n    /**\n     * Registers a user with the provided credentials with optional flags\n     * for activating the newly created user and automatically logging them in\n     *\n     * @param array $credentials\n     * @param bool $activate\n     * @param bool $autoLogin\n     * @return Models\\User\n     */\n    public function register(array $credentials, $activate = false, $autoLogin = true)\n    {\n        $user = $this->createUserModel();\n        $user->fill($credentials);\n        $user->save();\n\n        if ($activate) {\n            $user->attemptActivation($user->getActivationCode());\n        }\n\n        // Prevents revalidation of the password field\n        // on subsequent saves to this model object\n        $user->password = null;\n\n        if ($autoLogin) {\n            $this->user = $user;\n        }\n\n        return $user;\n    }\n\n    /**\n     * Sets the user\n     */\n    public function setUser(Authenticatable $user)\n    {\n        $this->user = $user;\n    }\n\n    /**\n     * Returns the current user, if any.\n     *\n     * @return mixed (Models\\User || null)\n     */\n    public function getUser()\n    {\n        if (is_null($this->user)) {\n            $this->check();\n        }\n\n        return $this->user;\n    }\n\n    /**\n     * Finds a user by the login value.\n     *\n     * @param string $id\n     * @return mixed (Models\\User || null)\n     */\n    public function findUserById($id)\n    {\n        $query = $this->createUserModelQuery();\n\n        $user = $query->find($id);\n\n        return $this->validateUserModel($user) ? $user : null;\n    }\n\n    /**\n     * Finds a user by the login value.\n     *\n     * @param string $login\n     * @return mixed (Models\\User || null)\n     */\n    public function findUserByLogin($login)\n    {\n        $model = $this->createUserModel();\n\n        $query = $this->createUserModelQuery();\n\n        $user = $query->where($model->getLoginName(), $login)->first();\n\n        return $this->validateUserModel($user) ? $user : null;\n    }\n\n    /**\n     * Finds a user by the given credentials.\n     *\n     * @param array $credentials The credentials to find a user by\n     * @throws AuthException If the credentials are invalid\n     * @return Models\\User The requested user\n     */\n    public function findUserByCredentials(array $credentials)\n    {\n        $model = $this->createUserModel();\n        $loginName = $model->getLoginName();\n\n        if (!array_key_exists($loginName, $credentials)) {\n            throw new AuthException(sprintf('Login attribute \"%s\" was not provided.', $loginName));\n        }\n\n        $query = $this->createUserModelQuery();\n        $hashableAttributes = $model->getHashableAttributes();\n        $hashedCredentials = [];\n\n        /*\n         * Build query from given credentials\n         */\n        foreach ($credentials as $credential => $value) {\n            // All excepted the hashed attributes\n            if (in_array($credential, $hashableAttributes)) {\n                $hashedCredentials = array_merge($hashedCredentials, [$credential => $value]);\n            }\n            else {\n                $query = $query->where($credential, '=', $value);\n            }\n        }\n\n        $user = $query->first();\n        if (!$this->validateUserModel($user)) {\n            throw new AuthException('A user was not found with the given credentials.');\n        }\n\n        /*\n         * Check the hashed credentials match\n         */\n        foreach ($hashedCredentials as $credential => $value) {\n            if (!$user->checkHashValue($credential, $value)) {\n                // Incorrect password\n                if ($credential === 'password') {\n                    throw new AuthException(sprintf(\n                        'A user was found to match all plain text credentials however hashed credential \"%s\" did not match.',\n                        $credential\n                    ));\n                }\n\n                // User not found\n                throw new AuthException('A user was not found with the given credentials.');\n            }\n        }\n\n        return $user;\n    }\n\n    /**\n     * Perform additional checks on the user model.\n     *\n     * @param $user\n     * @return boolean\n     */\n    protected function validateUserModel($user)\n    {\n        return $user instanceof $this->userModel;\n    }\n\n    //\n    // Throttle\n    //\n\n    /**\n     * Creates an instance of the throttle model\n     *\n     * @return Models\\Throttle\n     */\n    public function createThrottleModel()\n    {\n        $class = '\\\\'.ltrim($this->throttleModel, '\\\\');\n        return new $class();\n    }\n\n    /**\n     * Find a throttle record by login and ip address\n     *\n     * @param string $loginName\n     * @param string $ipAddress\n     * @return Models\\Throttle\n     */\n    public function findThrottleByLogin($loginName, $ipAddress)\n    {\n        $user = $this->findUserByLogin($loginName);\n        if (!$user) {\n            throw new AuthException(\"A user was not found with the given credentials.\");\n        }\n\n        $userId = $user->getKey();\n        return $this->findThrottleByUserId($userId, $ipAddress);\n    }\n\n    /**\n     * Find a throttle record by user id and ip address\n     *\n     * @param integer $userId\n     * @param string $ipAddress\n     * @return Models\\Throttle\n     */\n    public function findThrottleByUserId($userId, $ipAddress = null)\n    {\n        $cacheKey = md5($userId.$ipAddress);\n        if (isset($this->throttle[$cacheKey])) {\n            return $this->throttle[$cacheKey];\n        }\n\n        $model = $this->createThrottleModel();\n        $query = $model->where('user_id', '=', $userId);\n\n        if ($ipAddress) {\n            $query->where(function ($query) use ($ipAddress) {\n                $query->where('ip_address', '=', $ipAddress);\n                $query->orWhere('ip_address', '=', null);\n            });\n        }\n\n        if (!$throttle = $query->first()) {\n            $throttle = $this->createThrottleModel();\n            $throttle->user_id = $userId;\n            if ($ipAddress) {\n                $throttle->ip_address = $ipAddress;\n            }\n\n            $throttle->save();\n        }\n\n        return $this->throttle[$cacheKey] = $throttle;\n    }\n\n    //\n    // Business Logic\n    //\n\n    /**\n     * Attempt to authenticate a user using the given credentials.\n     *\n     * @param array $credentials The user login details\n     * @param bool $remember Store a non-expire cookie for the user\n     * @throws AuthException If authentication fails\n     * @return Models\\User The successfully logged in user\n     */\n    public function attempt(array $credentials = [], $remember = false)\n    {\n        return !!$this->authenticate($credentials, $remember);\n    }\n\n    /**\n     * Validate a user's credentials.\n     *\n     * @param  array  $credentials\n     * @return bool\n     */\n    public function validate(array $credentials = [])\n    {\n        return !!$this->validateInternal($credentials);\n    }\n\n    /**\n     * Validate a user's credentials, method used internally.\n     *\n     * @param  array  $credentials\n     * @return User\n     */\n    protected function validateInternal(array $credentials = [])\n    {\n        /*\n         * Default to the login name field or fallback to a hard-coded 'login' value\n         */\n        $loginName = $this->createUserModel()->getLoginName();\n        $loginCredentialKey = isset($credentials[$loginName]) ? $loginName : 'login';\n\n        if (empty($credentials[$loginCredentialKey])) {\n            throw new AuthException(sprintf('The \"%s\" attribute is required.', $loginCredentialKey));\n        }\n\n        if (empty($credentials['password'])) {\n            throw new AuthException('The password attribute is required.');\n        }\n\n        /*\n         * If the fallback 'login' was provided and did not match the necessary\n         * login name, swap it over\n         */\n        if ($loginCredentialKey !== $loginName) {\n            $credentials[$loginName] = $credentials[$loginCredentialKey];\n            unset($credentials[$loginCredentialKey]);\n        }\n\n        /*\n         * If throttling is enabled, check they are not locked out first and foremost.\n         */\n        if ($this->useThrottle) {\n            $throttle = $this->findThrottleByLogin($credentials[$loginName], $this->ipAddress);\n            $throttle->check();\n        }\n\n        /*\n         * Look up the user by authentication credentials.\n         */\n        try {\n            $user = $this->findUserByCredentials($credentials);\n        }\n        catch (AuthException $ex) {\n            if ($this->useThrottle) {\n                $throttle->addLoginAttempt();\n            }\n\n            throw $ex;\n        }\n\n        if ($this->useThrottle) {\n            $throttle->clearLoginAttempts();\n        }\n\n        return $user;\n    }\n\n    /**\n     * Attempts to authenticate the given user according to the passed credentials.\n     *\n     * @param array $credentials The user login details\n     * @param bool $remember Store a non-expire cookie for the user\n     */\n    public function authenticate(array $credentials, $remember = true)\n    {\n        $user = $this->validateInternal($credentials);\n\n        $user->clearResetPassword();\n\n        $this->login($user, $remember);\n\n        return $this->user;\n    }\n\n    /**\n     * Check to see if the user is logged in and activated, and hasn't been banned or suspended.\n     *\n     * @return bool\n     */\n    public function check()\n    {\n        if (is_null($this->user)) {\n            /*\n             * Check session first, follow by cookie\n             */\n            if ($sessionArray = Session::get($this->sessionKey)) {\n                $userArray = $sessionArray;\n            }\n            elseif ($cookieArray = Cookie::get($this->sessionKey)) {\n                $this->viaRemember = true;\n                /*\n                 * Shift gracefully to unserialized cookies\n                 * @todo Remove if statement below if year >= 2021 or build >= 475\n                 */\n                if (is_array($cookieArray)) {\n                    $userArray = $cookieArray;\n                }\n                else {\n                    $userArray = @json_decode($cookieArray, true);\n                }\n            }\n            else {\n                return false;\n            }\n\n            /*\n             * Check supplied session/cookie is an array (user id, persist code)\n             */\n            if (!is_array($userArray) || count($userArray) !== 2) {\n                return false;\n            }\n\n            list($id, $persistCode) = $userArray;\n\n            /*\n             * Look up user\n             */\n            if (!$user = $this->findUserById($id)) {\n                return false;\n            }\n\n            /*\n             * Confirm the persistence code is valid, otherwise reject\n             */\n            if (!$user->checkPersistCode($persistCode)) {\n                return false;\n            }\n\n            /*\n             * Pass\n             */\n            $this->user = $user;\n        }\n\n        /*\n         * Check cached user is activated\n         */\n        if (!($user = $this->getUser()) || ($this->requireActivation && !$user->is_activated)) {\n            return false;\n        }\n\n        /*\n         * Throttle check\n         */\n        if ($this->useThrottle) {\n            $throttle = $this->findThrottleByUserId($user->getKey(), $this->ipAddress);\n\n            if ($throttle->is_banned || $throttle->checkSuspended()) {\n                $this->logout();\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Determine if the current user is a guest.\n     *\n     * @return bool\n     */\n    public function guest()\n    {\n        return false;\n    }\n\n    /**\n     * Get the currently authenticated user.\n     *\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null\n     */\n    public function user()\n    {\n        return $this->getUser();\n    }\n\n    /**\n     * Get the ID for the currently authenticated user.\n     *\n     * @return int|null\n     */\n    public function id()\n    {\n        if ($user = $this->getUser()) {\n            return $user->getAuthIdentifier();\n        }\n\n        return null;\n    }\n\n    /**\n     * Log a user into the application without sessions or cookies.\n     *\n     * @param  array  $credentials\n     * @return bool\n     */\n    public function once(array $credentials = [])\n    {\n        $this->useSession = false;\n\n        $user = $this->authenticate($credentials);\n\n        $this->useSession = true;\n\n        return !!$user;\n    }\n\n    /**\n     * Log the given user ID into the application without sessions or cookies.\n     *\n     * @param  mixed  $id\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|false\n     */\n    public function onceUsingId($id)\n    {\n        if (!is_null($user = $this->findUserById($id))) {\n            $this->setUser($user);\n\n            return $user;\n        }\n\n        return false;\n    }\n\n    /**\n     * Logs in the given user and sets properties\n     * in the session.\n     * @throws AuthException If the user is not activated and $this->requireActivation = true\n     */\n    public function login(Authenticatable $user, $remember = true)\n    {\n        /*\n         * Fire the 'beforeLogin' event\n         */\n        $user->beforeLogin();\n\n        /*\n         * Activation is required, user not activated\n         */\n        if ($this->requireActivation && !$user->is_activated) {\n            $login = $user->getLogin();\n            throw new AuthException(sprintf(\n                'Cannot login user \"%s\" as they are not activated.',\n                $login\n            ));\n        }\n\n        $this->user = $user;\n\n        /*\n         * Create session/cookie data to persist the session\n         */\n        if ($this->useSession) {\n            $toPersist = [$user->getKey(), $user->getPersistCode()];\n            Session::put($this->sessionKey, $toPersist);\n\n            if ($remember) {\n                Cookie::queue(Cookie::forever($this->sessionKey, json_encode($toPersist)));\n            }\n        }\n\n        /*\n         * Fire the 'afterLogin' event\n         */\n        $user->afterLogin();\n    }\n\n    /**\n     * Log the given user ID into the application.\n     *\n     * @param  mixed  $id\n     * @param  bool   $remember\n     * @return \\Illuminate\\Contracts\\Auth\\Authenticatable\n     */\n    public function loginUsingId($id, $remember = false)\n    {\n        if (!is_null($user = $this->findUserById($id))) {\n            $this->login($user, $remember);\n\n            return $user;\n        }\n\n        return false;\n    }\n\n    /**\n     * Determine if the user was authenticated via \"remember me\" cookie.\n     *\n     * @return bool\n     */\n    public function viaRemember()\n    {\n        return $this->viaRemember;\n    }\n\n    /**\n     * Logs the current user out.\n     */\n    public function logout()\n    {\n        // Initialize the current auth session before trying to remove it\n        if (is_null($this->user) && !$this->check()) {\n            return;\n        }\n\n        if ($this->isImpersonator()) {\n            $this->user = $this->getImpersonator();\n            $this->stopImpersonate();\n            return;\n        }\n\n        if ($this->user) {\n            $this->user->setRememberToken(null);\n            $this->user->forceSave();\n        }\n\n        $this->user = null;\n\n        Session::invalidate();\n        Cookie::queue(Cookie::forget($this->sessionKey));\n    }\n\n    //\n    // Impersonation\n    //\n\n    /**\n     * Impersonates the given user and sets properties\n     * in the session but not the cookie.\n     */\n    public function impersonate($user)\n    {\n        $oldSession = Session::get($this->sessionKey);\n        $oldUser = !empty($oldSession[0]) ? $this->findUserById($oldSession[0]) : false;\n\n        /**\n         * @event model.auth.beforeImpersonate\n         * Called after the model is booted\n         *\n         * Example usage:\n         *\n         *     $model->bindEvent('model.auth.beforeImpersonate', function (\\October\\Rain\\Database\\Model|false $oldUser) use (\\October\\Rain\\Database\\Model $model) {\n         *         \\Log::info($oldUser->full_name . ' is now impersonating ' . $model->full_name);\n         *     });\n         *\n         */\n        $user->fireEvent('model.auth.beforeImpersonate', [$oldUser]);\n\n        $this->login($user, false);\n\n        if (!$this->isImpersonator()) {\n            Session::put($this->sessionKey.'_impersonate', $oldSession);\n        }\n    }\n\n    /**\n     * Stop the current session being impersonated and\n     * authenticate as the impersonator again\n     */\n    public function stopImpersonate()\n    {\n        $currentSession = Session::get($this->sessionKey);\n        $currentUser = !empty($currentSession[0]) ? $this->findUserById($currentSession[0]) : false;\n        $oldSession = Session::pull($this->sessionKey.'_impersonate');\n        $oldUser = !empty($oldSession[0]) ? $this->findUserById($oldSession[0]) : false;\n\n        if ($currentUser) {\n            /**\n             * @event model.auth.afterImpersonate\n             * Called after the model is booted\n             *\n             * Example usage:\n             *\n             *     $model->bindEvent('model.auth.afterImpersonate', function (\\October\\Rain\\Database\\Model|false $oldUser) use (\\October\\Rain\\Database\\Model $model) {\n             *         \\Log::info($oldUser->full_name . ' has stopped impersonating ' . $model->full_name);\n             *     });\n             *\n             */\n            $currentUser->fireEvent('model.auth.afterImpersonate', [$oldUser]);\n        }\n\n        Session::put($this->sessionKey, $oldSession);\n    }\n\n    /**\n     * Check to see if the current session is being impersonated\n     *\n     * @return bool\n     */\n    public function isImpersonator()\n    {\n        return !empty(Session::has($this->sessionKey.'_impersonate'));\n    }\n\n    /**\n     * Get the original user doing the impersonation\n     *\n     * @return mixed Returns the User model for the impersonator if able, false if not\n     */\n    public function getImpersonator()\n    {\n        $impersonateArray = Session::get($this->sessionKey.'_impersonate');\n\n        /*\n         * Check supplied session/cookie is an array (user id, persist code)\n         */\n        if (!is_array($impersonateArray) || count($impersonateArray) !== 2) {\n            return false;\n        }\n\n        $id = $impersonateArray[0];\n\n        return $this->createUserModel()->find($id);\n    }\n}\n", "<?php namespace October\\Rain\\Auth\\Models;\n\nuse InvalidArgumentException;\nuse October\\Rain\\Database\\Model;\n\n/**\n * Role model\n */\nclass Role extends Model\n{\n    use \\October\\Rain\\Database\\Traits\\Validation;\n\n    /**\n     * @var string The table associated with the model.\n     */\n    protected $table = 'roles';\n\n    /**\n     * @var array Validation rules\n     */\n    public $rules = [\n        'name' => 'required|between:4,16|unique:role',\n    ];\n\n    /**\n     * @var array Relations\n     */\n    public $hasMany = [\n        'users' => User::class\n    ];\n\n    /**\n     * @var array List of attribute names which are json encoded and decoded from the database.\n     */\n    protected $jsonable = ['permissions'];\n\n    /**\n     * @var array Allowed permissions values.\n     *\n     * Possible options:\n     *    0 => Remove.\n     *    1 => Add.\n     */\n    protected $allowedPermissionsValues = [0, 1];\n\n    /**\n     * @var array The attributes that aren't mass assignable.\n     */\n    protected $guarded = [];\n\n    /**\n     * See if a role has access to the passed permission(s).\n     *\n     * If multiple permissions are passed, the role must\n     * have access to all permissions passed through, unless the\n     * \"all\" flag is set to false.\n     *\n     * @param  string|array  $permissions\n     * @param  bool  $all\n     * @return bool\n     */\n    public function hasAccess($permissions, $all = true)\n    {\n        $rolePermissions = $this->permissions;\n\n        if (!is_array($permissions)) {\n            $permissions = (array) $permissions;\n        }\n\n        foreach ($permissions as $permission) {\n            // We will set a flag now for whether this permission was\n            // matched at all.\n            $matched = true;\n\n            // Now, let's check if the permission ends in a wildcard \"*\" symbol.\n            // If it does, we'll check through all the merged permissions to see\n            // if a permission exists which matches the wildcard.\n            if ((strlen($permission) > 1) && ends_with($permission, '*')) {\n                $matched = false;\n\n                foreach ($rolePermissions as $rolePermission => $value) {\n                    // Strip the '*' off the end of the permission.\n                    $checkPermission = substr($permission, 0, -1);\n\n                    // We will make sure that the merged permission does not\n                    // exactly match our permission, but starts with it.\n                    if ($checkPermission != $rolePermission && starts_with($rolePermission, $checkPermission) && $value === 1) {\n                        $matched = true;\n                        break;\n                    }\n                }\n            }\n            // Now, let's check if the permission starts in a wildcard \"*\" symbol.\n            // If it does, we'll check through all the merged permissions to see\n            // if a permission exists which matches the wildcard.\n            elseif ((strlen($permission) > 1) && starts_with($permission, '*')) {\n                $matched = false;\n\n                foreach ($rolePermissions as $rolePermission => $value) {\n                    // Strip the '*' off the start of the permission.\n                    $checkPermission = substr($permission, 1);\n\n                    // We will make sure that the merged permission does not\n                    // exactly match our permission, but ends with it.\n                    if ($checkPermission != $rolePermission && ends_with($rolePermission, $checkPermission) && $value === 1) {\n                        $matched = true;\n                        break;\n                    }\n                }\n            }\n            else {\n                $matched = false;\n\n                foreach ($rolePermissions as $rolePermission => $value) {\n                    // This time check if the rolePermission ends in wildcard \"*\" symbol.\n                    if ((strlen($rolePermission) > 1) && ends_with($rolePermission, '*')) {\n                        $matched = false;\n\n                        // Strip the '*' off the end of the permission.\n                        $checkGroupPermission = substr($rolePermission, 0, -1);\n\n                        // We will make sure that the merged permission does not\n                        // exactly match our permission, but starts with it.\n                        if ($checkGroupPermission != $permission && starts_with($permission, $checkGroupPermission) && $value === 1) {\n                            $matched = true;\n                            break;\n                        }\n                    }\n                    // Otherwise, we'll fallback to standard permissions checking where\n                    // we match that permissions explicitly exist.\n                    elseif ($permission === $rolePermission && $rolePermissions[$permission] === 1) {\n                        $matched = true;\n                        break;\n                    }\n                }\n            }\n\n            // Now, we will check if we have to match all\n            // permissions or any permission and return\n            // accordingly.\n            if ($all === true && $matched === false) {\n                return false;\n            }\n            elseif ($all === false && $matched === true) {\n                return true;\n            }\n        }\n\n        return !($all === false);\n    }\n\n    /**\n     * Returns if the user has access to any of the given permissions.\n     * @param array $permissions\n     * @return bool\n     */\n    public function hasAnyAccess(array $permissions)\n    {\n        return $this->hasAccess($permissions, false);\n    }\n\n    /**\n     * Validate the permissions when set.\n     * @param  array  $permissions\n     * @return void\n     */\n    public function setPermissionsAttribute($permissions)\n    {\n        $permissions = json_decode($permissions, true);\n        foreach ($permissions as $permission => $value) {\n            if (!in_array($value = (int) $value, $this->allowedPermissionsValues)) {\n                throw new InvalidArgumentException(sprintf(\n                    'Invalid value \"%s\" for permission \"%s\" given.',\n                    $value,\n                    $permission\n                ));\n            }\n\n            if ($value === 0) {\n                unset($permissions[$permission]);\n            }\n        }\n\n        $this->attributes['permissions'] = !empty($permissions) ? json_encode($permissions) : '';\n    }\n}\n", "<?php namespace October\\Rain\\Auth\\Models;\n\nuse Carbon\\Carbon;\nuse October\\Rain\\Auth\\AuthException;\nuse October\\Rain\\Database\\Model;\n\n/**\n * Throttle model\n */\nclass Throttle extends Model\n{\n    /**\n     * @var bool Throttling status.\n     */\n    protected $enabled = true;\n\n    /**\n     * @var string The table associated with the model.\n     */\n    protected $table = 'throttle';\n\n    /**\n     * @var array Relations\n     */\n    public $belongsTo = [\n        'user' => [User::class, 'key' => 'user_id']\n    ];\n\n    /**\n     * @var bool Indicates if the model should be timestamped.\n     */\n    public $timestamps = false;\n\n    /**\n     * The attributes that should be mutated to dates.\n     *\n     * @var array\n     */\n    protected $dates = ['last_attempt_at', 'suspended_at', 'banned_at'];\n\n    /**\n     * @var int Attempt limit.\n     */\n    protected static $attemptLimit = 5;\n\n    /**\n     * @var int Suspensions time in minutes.\n     */\n    protected static $suspensionTime = 15;\n\n    /**\n     * Returns the associated user with the throttler.\n     * @return User\n     */\n    public function getUser()\n    {\n        return $this->user()->getResults();\n    }\n\n    /**\n     * Get the current amount of attempts.\n     * @return int\n     */\n    public function getLoginAttempts()\n    {\n        if ($this->attempts > 0 and $this->last_attempt_at) {\n            $this->clearLoginAttemptsIfAllowed();\n        }\n\n        return $this->attempts;\n    }\n\n    /**\n     * Add a new login attempt.\n     * @return void\n     */\n    public function addLoginAttempt()\n    {\n        $this->attempts++;\n        $this->last_attempt_at = $this->freshTimestamp();\n\n        if ($this->getLoginAttempts() >= static::$attemptLimit) {\n            $this->suspend();\n        }\n        else {\n            $this->save();\n        }\n    }\n\n    /**\n     * Clear all login attempts\n     * @return void\n     */\n    public function clearLoginAttempts()\n    {\n        // If our login attempts is already at zero\n        // we do not need to do anything. Additionally,\n        // if we are suspended, we are not going to do\n        // anything either as clearing login attempts\n        // makes us unsuspended. We need to manually\n        // call unsuspend() in order to unsuspend.\n        if ($this->getLoginAttempts() === 0 or $this->is_suspended) {\n            return;\n        }\n\n        $this->attempts = 0;\n        $this->last_attempt_at = null;\n        $this->is_suspended = false;\n        $this->suspended_at = null;\n        $this->save();\n    }\n\n    /**\n     * Suspend the user associated with the throttle\n     * @return void\n     */\n    public function suspend()\n    {\n        if (!$this->is_suspended) {\n            $this->is_suspended = true;\n            $this->suspended_at = $this->freshTimestamp();\n            $this->save();\n        }\n    }\n\n    /**\n     * Unsuspend the user.\n     * @return void\n     */\n    public function unsuspend()\n    {\n        if ($this->is_suspended) {\n            $this->attempts = 0;\n            $this->last_attempt_at = null;\n            $this->is_suspended = false;\n            $this->suspended_at = null;\n            $this->save();\n        }\n    }\n\n    /**\n     * Check if the user is suspended.\n     * @return bool\n     */\n    public function checkSuspended()\n    {\n        if ($this->is_suspended && $this->suspended_at) {\n            $this->removeSuspensionIfAllowed();\n            return (bool) $this->is_suspended;\n        }\n\n        return false;\n    }\n\n    /**\n     * Ban the user.\n     * @return void\n     */\n    public function ban()\n    {\n        if (!$this->is_banned) {\n            $this->is_banned = true;\n            $this->banned_at = $this->freshTimestamp();\n            $this->save();\n        }\n    }\n\n    /**\n     * Unban the user.\n     * @return void\n     */\n    public function unban()\n    {\n        if ($this->is_banned) {\n            $this->is_banned = false;\n            $this->banned_at = null;\n            $this->save();\n        }\n    }\n\n    /**\n     * Check user throttle status.\n     * @return bool\n     * @throws AuthException\n     */\n    public function check()\n    {\n        if ($this->is_banned) {\n            throw new AuthException(sprintf(\n                'User [%s] has been banned.',\n                $this->user->getLogin()\n            ));\n        }\n\n        if ($this->checkSuspended()) {\n            throw new AuthException(sprintf(\n                'User [%s] has been suspended.',\n                $this->user->getLogin()\n            ));\n        }\n\n        return true;\n    }\n\n    /**\n     * Inspects the last attempt vs the suspension time\n     * (the time in which attempts must space before the\n     * account is suspended). If we can clear our attempts\n     * now, we'll do so and save.\n     *\n     * @return void\n     */\n    public function clearLoginAttemptsIfAllowed()\n    {\n        $lastAttempt = clone $this->last_attempt_at;\n\n        $suspensionTime = static::$suspensionTime;\n        $clearAttemptsAt = $lastAttempt->modify(\"+{$suspensionTime} minutes\");\n        $now = new Carbon;\n\n        if ($clearAttemptsAt <= $now) {\n            $this->attempts = 0;\n            $this->save();\n        }\n\n        unset($lastAttempt, $clearAttemptsAt, $now);\n    }\n\n    /**\n     * Inspects to see if the user can become unsuspended\n     * or not, based on the suspension time provided. If so,\n     * unsuspends.\n     *\n     * @return void\n     */\n    public function removeSuspensionIfAllowed()\n    {\n        $suspended = clone $this->suspended_at;\n\n        $suspensionTime = static::$suspensionTime;\n        $unsuspendAt = $suspended->modify(\"+{$suspensionTime} minutes\");\n        $now = new Carbon;\n\n        if ($unsuspendAt <= $now) {\n            $this->unsuspend();\n        }\n\n        unset($suspended, $unsuspendAt, $now);\n    }\n\n    /**\n     * Get mutator for the suspended property.\n     * @param  mixed  $suspended\n     * @return bool\n     */\n    public function getIsSuspendedAttribute($suspended)\n    {\n        return (bool) $suspended;\n    }\n\n    /**\n     * Get mutator for the banned property.\n     * @param  mixed  $banned\n     * @return bool\n     */\n    public function getIsBannedAttribute($banned)\n    {\n        return (bool) $banned;\n    }\n}\n", "<?php namespace October\\Rain\\Auth\\Models;\n\nuse Str;\nuse Hash;\nuse October\\Rain\\Database\\Model;\nuse InvalidArgumentException;\nuse Exception;\n\n/**\n * User model\n */\nclass User extends Model implements \\Illuminate\\Contracts\\Auth\\Authenticatable\n{\n    use \\October\\Rain\\Database\\Traits\\Hashable;\n    use \\October\\Rain\\Database\\Traits\\Purgeable;\n    use \\October\\Rain\\Database\\Traits\\Validation;\n\n    /**\n     * @var string The table associated with the model.\n     */\n    protected $table = 'users';\n\n    /**\n     * @var array Validation rules\n     */\n    public $rules = [\n        'email' => 'required|between:3,255|email|unique:users',\n        'password' => 'required:create|min:4|confirmed',\n        'password_confirmation' => 'required_with:password|min:4'\n    ];\n\n    /**\n     * @var array Relations\n     */\n    public $belongsToMany = [\n        'groups' => [Group::class, 'table' => 'users_groups']\n    ];\n\n    public $belongsTo = [\n        'role' => Role::class\n    ];\n\n    /**\n     * The attributes that should be mutated to dates.\n     *\n     * @var array\n     */\n    protected $dates = ['activated_at', 'last_login'];\n\n    /**\n     * @var array The attributes that should be hidden for arrays.\n     */\n    protected $hidden = ['password', 'reset_password_code', 'activation_code', 'persist_code'];\n\n    /**\n     * @var array The attributes that aren't mass assignable.\n     */\n    protected $guarded = ['is_superuser', 'reset_password_code', 'activation_code', 'persist_code', 'role_id'];\n\n    /**\n     * @var array List of attribute names which should be hashed using the Bcrypt hashing algorithm.\n     */\n    protected $hashable = ['password', 'persist_code'];\n\n    /**\n     * @var array List of attribute names which should not be saved to the database.\n     */\n    protected $purgeable = ['password_confirmation'];\n\n    /**\n     * @var array The array of custom attribute names.\n     */\n    public $attributeNames = [];\n\n    /**\n     * @var array The array of custom error messages.\n     */\n    public $customMessages = [];\n\n    /**\n     * @var array List of attribute names which are json encoded and decoded from the database.\n     */\n    protected $jsonable = ['permissions'];\n\n    /**\n     * Allowed permissions values.\n     *\n     * Possible options:\n     *   -1 => Deny (adds to array, but denies regardless of user's group).\n     *    0 => Remove.\n     *    1 => Add.\n     *\n     * @var array\n     */\n    protected $allowedPermissionsValues = [-1, 0, 1];\n\n    /**\n     * @var string The login attribute.\n     */\n    public static $loginAttribute = 'email';\n\n    /**\n     * @var string The column name of the \"remember me\" token.\n     */\n    protected $rememberTokenName = 'persist_code';\n\n    /**\n     * @var array The user merged permissions.\n     */\n    protected $mergedPermissions;\n\n    /**\n     * @return string Returns the name for the user's login.\n     */\n    public function getLoginName()\n    {\n        return static::$loginAttribute;\n    }\n\n    /**\n     * @return mixed Returns the user's login.\n     */\n    public function getLogin()\n    {\n        return $this->{$this->getLoginName()};\n    }\n\n    /**\n     * Checks if the user is a super user - has access to everything regardless of permissions.\n     * @return bool\n     */\n    public function isSuperUser()\n    {\n        return (bool) $this->is_superuser;\n    }\n\n    //\n    // Events\n    //\n\n    public function beforeLogin()\n    {\n    }\n\n    public function afterLogin()\n    {\n        $this->last_login = $this->freshTimestamp();\n        $this->forceSave();\n    }\n\n    /**\n     * Delete the user groups\n     * @return bool\n     */\n    public function afterDelete()\n    {\n        if ($this->hasRelation('groups')) {\n            $this->groups()->detach();\n        }\n    }\n\n    //\n    // Persistence (used by Cookies and Sessions)\n    //\n\n    /**\n     * Gets a code for when the user is persisted to a cookie or session which identifies the user.\n     * @return string\n     */\n    public function getPersistCode()\n    {\n        $this->persist_code = $this->getRandomString();\n\n        // Our code got hashed\n        $persistCode = $this->persist_code;\n\n        $this->forceSave();\n\n        return $persistCode;\n    }\n\n    /**\n     * Checks the given persist code.\n     * @param string $persistCode\n     * @return bool\n     */\n    public function checkPersistCode($persistCode)\n    {\n        if (!$persistCode || !$this->persist_code) {\n            return false;\n        }\n\n        return $persistCode === $this->persist_code;\n    }\n\n    //\n    // Activation\n    //\n\n    /**\n     * Get mutator for giving the activated property.\n     * @param mixed $activated\n     * @return bool\n     */\n    public function getIsActivatedAttribute($activated)\n    {\n        return (bool) $activated;\n    }\n\n    /**\n     * Get an activation code for the given user.\n     * @return string\n     */\n    public function getActivationCode()\n    {\n        $this->activation_code = $activationCode = $this->getRandomString();\n\n        $this->forceSave();\n\n        return $activationCode;\n    }\n\n    /**\n     * Attempts to activate the given user by checking the activate code. If the user is activated already, an Exception is thrown.\n     * @param string $activationCode\n     * @return bool\n     */\n    public function attemptActivation($activationCode)\n    {\n        if ($this->is_activated) {\n            throw new Exception('User is already active!');\n        }\n\n        if ($activationCode === $this->activation_code) {\n            $this->activation_code = null;\n            $this->is_activated = true;\n            $this->activated_at = $this->freshTimestamp();\n            $this->forceSave();\n            return true;\n        }\n\n        return false;\n    }\n\n    //\n    // Password\n    //\n\n    /**\n     * Checks the password passed matches the user's password.\n     * @param string $password\n     * @return bool\n     */\n    public function checkPassword($password)\n    {\n        return Hash::check($password, $this->password);\n    }\n\n    /**\n     * Get a reset password code for the given user.\n     * @return string\n     */\n    public function getResetPasswordCode()\n    {\n        $this->reset_password_code = $resetCode = $this->getRandomString();\n        $this->forceSave();\n        return $resetCode;\n    }\n\n    /**\n     * Checks if the provided user reset password code is valid without actually resetting the password.\n     * @param string $resetCode\n     * @return bool\n     */\n    public function checkResetPasswordCode($resetCode)\n    {\n        if (!$resetCode || !$this->reset_password_code) {\n            return false;\n        }\n\n        return ($this->reset_password_code === $resetCode);\n    }\n\n    /**\n     * Attempts to reset a user's password by matching the reset code generated with the user's.\n     * @param string $resetCode\n     * @param string $newPassword\n     * @return bool\n     */\n    public function attemptResetPassword($resetCode, $newPassword)\n    {\n        if ($this->checkResetPasswordCode($resetCode)) {\n            $this->password = $newPassword;\n            $this->reset_password_code = null;\n            return $this->forceSave();\n        }\n\n        return false;\n    }\n\n    /**\n     * Wipes out the data associated with resetting a password.\n     * @return void\n     */\n    public function clearResetPassword()\n    {\n        if ($this->reset_password_code) {\n            $this->reset_password_code = null;\n            $this->forceSave();\n        }\n    }\n\n    /**\n     * Protects the password from being reset to null.\n     */\n    public function setPasswordAttribute($value)\n    {\n        if ($this->exists && empty($value)) {\n            unset($this->attributes['password']);\n        }\n        else {\n            $this->attributes['password'] = $value;\n\n            // Password has changed, log out all users\n            $this->attributes['persist_code'] = null;\n        }\n    }\n\n    //\n    // Permissions, Groups & Role\n    //\n\n    /**\n     * Returns an array of groups which the given user belongs to.\n     * @return array\n     */\n    public function getGroups()\n    {\n        return $this->groups;\n    }\n\n    /**\n     * Returns the role assigned to this user.\n     * @return October\\Rain\\Auth\\Models\\Role\n     */\n    public function getRole()\n    {\n        return $this->role;\n    }\n\n    /**\n     * Adds the user to the given group.\n     * @param Group $group\n     * @return bool\n     */\n    public function addGroup($group)\n    {\n        if (!$this->inGroup($group)) {\n            $this->groups()->attach($group);\n            $this->reloadRelations('groups');\n        }\n\n        return true;\n    }\n\n    /**\n     * Removes the user from the given group.\n     * @param Group $group\n     * @return bool\n     */\n    public function removeGroup($group)\n    {\n        if ($this->inGroup($group)) {\n            $this->groups()->detach($group);\n            $this->reloadRelations('groups');\n        }\n\n        return true;\n    }\n\n    /**\n     * See if the user is in the given group.\n     * @param Group $group\n     * @return bool\n     */\n    public function inGroup($group)\n    {\n        foreach ($this->getGroups() as $_group) {\n            if ($_group->getKey() === $group->getKey()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns an array of merged permissions for each group the user is in.\n     * @return array\n     */\n    public function getMergedPermissions()\n    {\n        if (!$this->mergedPermissions) {\n            $permissions = [];\n\n            if (($role = $this->getRole()) && is_array($role->permissions)) {\n                $permissions = array_merge($permissions, $role->permissions);\n            }\n\n            if (is_array($this->permissions)) {\n                $permissions = array_merge($permissions, $this->permissions);\n            }\n\n            $this->mergedPermissions = $permissions;\n        }\n\n        return $this->mergedPermissions;\n    }\n\n    /**\n     * See if a user has access to the passed permission(s).\n     * Permissions are merged from all groups the user belongs to\n     * and then are checked against the passed permission(s).\n     *\n     * If multiple permissions are passed, the user must\n     * have access to all permissions passed through, unless the\n     * \"all\" flag is set to false.\n     *\n     * Super users have access no matter what.\n     *\n     * @param  string|array  $permissions\n     * @param  bool  $all\n     * @return bool\n     */\n    public function hasAccess($permissions, $all = true)\n    {\n        if ($this->isSuperUser()) {\n            return true;\n        }\n\n        return $this->hasPermission($permissions, $all);\n    }\n\n    /**\n     * See if a user has access to the passed permission(s).\n     * Permissions are merged from all groups the user belongs to\n     * and then are checked against the passed permission(s).\n     *\n     * If multiple permissions are passed, the user must\n     * have access to all permissions passed through, unless the\n     * \"all\" flag is set to false.\n     *\n     * Super users DON'T have access no matter what.\n     *\n     * @param  string|array  $permissions\n     * @param  bool  $all\n     * @return bool\n     */\n    public function hasPermission($permissions, $all = true)\n    {\n        $mergedPermissions = $this->getMergedPermissions();\n\n        if (!is_array($permissions)) {\n            $permissions = [$permissions];\n        }\n\n        foreach ($permissions as $permission) {\n            // We will set a flag now for whether this permission was\n            // matched at all.\n            $matched = true;\n\n            // Now, let's check if the permission ends in a wildcard \"*\" symbol.\n            // If it does, we'll check through all the merged permissions to see\n            // if a permission exists which matches the wildcard.\n            if ((strlen($permission) > 1) && ends_with($permission, '*')) {\n                $matched = false;\n\n                foreach ($mergedPermissions as $mergedPermission => $value) {\n                    // Strip the '*' off the end of the permission.\n                    $checkPermission = substr($permission, 0, -1);\n\n                    // We will make sure that the merged permission does not\n                    // exactly match our permission, but starts with it.\n                    if ($checkPermission != $mergedPermission && starts_with($mergedPermission, $checkPermission) && $value === 1) {\n                        $matched = true;\n                        break;\n                    }\n                }\n            }\n            elseif ((strlen($permission) > 1) && starts_with($permission, '*')) {\n                $matched = false;\n\n                foreach ($mergedPermissions as $mergedPermission => $value) {\n                    // Strip the '*' off the beginning of the permission.\n                    $checkPermission = substr($permission, 1);\n\n                    // We will make sure that the merged permission does not\n                    // exactly match our permission, but ends with it.\n                    if ($checkPermission != $mergedPermission && ends_with($mergedPermission, $checkPermission) && $value === 1) {\n                        $matched = true;\n                        break;\n                    }\n                }\n            }\n            else {\n                $matched = false;\n\n                foreach ($mergedPermissions as $mergedPermission => $value) {\n                    // This time check if the mergedPermission ends in wildcard \"*\" symbol.\n                    if ((strlen($mergedPermission) > 1) && ends_with($mergedPermission, '*')) {\n                        $matched = false;\n\n                        // Strip the '*' off the end of the permission.\n                        $checkMergedPermission = substr($mergedPermission, 0, -1);\n\n                        // We will make sure that the merged permission does not\n                        // exactly match our permission, but starts with it.\n                        if ($checkMergedPermission != $permission && starts_with($permission, $checkMergedPermission) && $value === 1) {\n                            $matched = true;\n                            break;\n                        }\n                    }\n\n                    // Otherwise, we'll fallback to standard permissions checking where\n                    // we match that permissions explicitly exist.\n                    elseif ($permission === $mergedPermission && $mergedPermissions[$permission] === 1) {\n                        $matched = true;\n                        break;\n                    }\n                }\n            }\n\n            // Now, we will check if we have to match all\n            // permissions or any permission and return\n            // accordingly.\n            if ($all === true && $matched === false) {\n                return false;\n            }\n            elseif ($all === false && $matched === true) {\n                return true;\n            }\n        }\n\n        return !($all === false);\n    }\n\n    /**\n     * Returns if the user has access to any of the given permissions.\n     * @param  array  $permissions\n     * @return bool\n     */\n    public function hasAnyAccess(array $permissions)\n    {\n        return $this->hasAccess($permissions, false);\n    }\n\n    /**\n     * Validate any set permissions.\n     * @param array $permissions\n     * @return void\n     */\n    public function setPermissionsAttribute($permissions)\n    {\n        $permissions = json_decode($permissions, true) ?: [];\n        foreach ($permissions as $permission => &$value) {\n            if (!in_array($value = (int) $value, $this->allowedPermissionsValues)) {\n                throw new InvalidArgumentException(sprintf(\n                    'Invalid value \"%s\" for permission \"%s\" given.',\n                    $value,\n                    $permission\n                ));\n            }\n\n            if ($value === 0) {\n                unset($permissions[$permission]);\n            }\n        }\n\n        $this->attributes['permissions'] = !empty($permissions) ? json_encode($permissions) : '';\n    }\n\n    //\n    // User Interface\n    //\n\n    /**\n     * Get the name of the unique identifier for the user.\n     * @return string\n     */\n    public function getAuthIdentifierName()\n    {\n        return $this->getKeyName();\n    }\n\n    /**\n     * Get the unique identifier for the user.\n     * @return mixed\n     */\n    public function getAuthIdentifier()\n    {\n        return $this->{$this->getAuthIdentifierName()};\n    }\n\n    /**\n     * Get the password for the user.\n     * @return string\n     */\n    public function getAuthPassword()\n    {\n        return $this->password;\n    }\n\n    /**\n     * Get the e-mail address where password reminders are sent.\n     * @return string\n     */\n    public function getReminderEmail()\n    {\n        return $this->email;\n    }\n\n    /**\n     * Get the token value for the \"remember me\" session.\n     * @return string\n     */\n    public function getRememberToken()\n    {\n        return $this->getPersistCode();\n    }\n\n    /**\n     * Set the token value for the \"remember me\" session.\n     * @param  string $value\n     * @return void\n     */\n    public function setRememberToken($value)\n    {\n        $this->persist_code = $value;\n    }\n\n    /**\n     * Get the column name for the \"remember me\" token.\n     * @return string\n     */\n    public function getRememberTokenName()\n    {\n        return $this->rememberTokenName;\n    }\n\n    //\n    // Helpers\n    //\n\n    /**\n     * Generate a random string\n     * @return string\n     */\n    public function getRandomString($length = 42)\n    {\n        return Str::random($length);\n    }\n}\n"], "filenames": ["src/Auth/Manager.php", "src/Auth/Models/Role.php", "src/Auth/Models/Throttle.php", "src/Auth/Models/User.php"], "buggy_code_start_loc": [244, 87, 102, 193], "buggy_code_end_loc": [245, 132, 103, 527], "fixing_code_start_loc": [244, 87, 102, 193], "fixing_code_end_loc": [245, 132, 103, 527], "type": "NVD-CWE-noinfo", "message": "octobercms in a CMS platform based on the Laravel PHP Framework. In affected versions of the october/system package an attacker can request an account password reset and then gain access to the account using a specially crafted request. The issue has been patched in Build 472 and v1.1.5.", "other": {"cve": {"id": "CVE-2021-32648", "sourceIdentifier": "security-advisories@github.com", "published": "2021-08-26T19:15:07.230", "lastModified": "2022-07-02T20:00:40.427", "vulnStatus": "Analyzed", "cisaExploitAdd": "2022-01-18", "cisaActionDue": "2022-02-01", "cisaRequiredAction": "Apply updates per vendor instructions.", "cisaVulnerabilityName": "October CMS Improper Authentication", "descriptions": [{"lang": "en", "value": "octobercms in a CMS platform based on the Laravel PHP Framework. In affected versions of the october/system package an attacker can request an account password reset and then gain access to the account using a specially crafted request. The issue has been patched in Build 472 and v1.1.5."}, {"lang": "es", "value": "octobercms en una plataforma CMS basada en el Framework PHP Laravel. En las versiones afectadas del paquete october/system un atacante puede solicitar el restablecimiento de la contrase\u00f1a de una cuenta y luego conseguir acceso a la misma mediante una petici\u00f3n especialmente dise\u00f1ada. El problema ha sido parcheado en la Build 472 y en la versi\u00f3n v1.1.5."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:octobercms:october:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.0.471", "versionEndExcluding": "1.0.472", "matchCriteriaId": "32CA477B-7437-4DB8-891D-05E1297E36FB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:octobercms:october:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.1.1", "versionEndExcluding": "1.1.5", "matchCriteriaId": "2E79163B-046D-4BA9-82C9-70AB3A000D69"}]}]}], "references": [{"url": "https://github.com/octobercms/library/commit/016a297b1bec55d2e53bc889458ed2cb5c3e9374", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/octobercms/library/commit/5bd1a28140b825baebe6becd4f7562299d3de3b9", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/octobercms/october/security/advisories/GHSA-mxr5-mc97-63rc", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/octobercms/library/commit/016a297b1bec55d2e53bc889458ed2cb5c3e9374"}}