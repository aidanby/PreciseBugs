{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%        SSSSS  TTTTT   AAA   TTTTT  IIIII  SSSSS  TTTTT  IIIII   CCCC        %\n%        SS       T    A   A    T      I    SS       T      I    C            %\n%         SSS     T    AAAAA    T      I     SSS     T      I    C            %\n%           SS    T    A   A    T      I       SS    T      I    C            %\n%        SSSSS    T    A   A    T    IIIII  SSSSS    T    IIIII   CCCC        %\n%                                                                             %\n%                                                                             %\n%                     MagickCore Image Statistical Methods                    %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/accelerate-private.h\"\n#include \"MagickCore/animate.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/compress.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/display.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/gem-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/magic.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/paint.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/random_.h\"\n#include \"MagickCore/random-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/segment.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/signature-private.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/timer.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/version.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     E v a l u a t e I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  EvaluateImage() applies a value to the image with an arithmetic, relational,\n%  or logical operator to an image. Use these operations to lighten or darken\n%  an image, to increase or decrease contrast in an image, or to produce the\n%  \"negative\" of an image.\n%\n%  The format of the EvaluateImage method is:\n%\n%      MagickBooleanType EvaluateImage(Image *image,\n%        const MagickEvaluateOperator op,const double value,\n%        ExceptionInfo *exception)\n%      MagickBooleanType EvaluateImages(Image *images,\n%        const MagickEvaluateOperator op,const double value,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o op: A channel op.\n%\n%    o value: A value value.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\ntypedef struct _PixelChannels\n{\n  double\n    channel[CompositePixelChannel];\n} PixelChannels;\n\nstatic PixelChannels **DestroyPixelThreadSet(PixelChannels **pixels)\n{\n  register ssize_t\n    i;\n\n  assert(pixels != (PixelChannels **) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (pixels[i] != (PixelChannels *) NULL)\n      pixels[i]=(PixelChannels *) RelinquishMagickMemory(pixels[i]);\n  pixels=(PixelChannels **) RelinquishMagickMemory(pixels);\n  return(pixels);\n}\n\nstatic PixelChannels **AcquirePixelThreadSet(const Image *image)\n{\n  PixelChannels\n    **pixels;\n\n  register ssize_t\n    i;\n\n  size_t\n    number_threads;\n\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  pixels=(PixelChannels **) AcquireQuantumMemory(number_threads,\n    sizeof(*pixels));\n  if (pixels == (PixelChannels **) NULL)\n    return((PixelChannels **) NULL);\n  (void) memset(pixels,0,number_threads*sizeof(*pixels));\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    register ssize_t\n      j;\n\n    pixels[i]=(PixelChannels *) AcquireQuantumMemory(image->columns,\n      sizeof(**pixels));\n    if (pixels[i] == (PixelChannels *) NULL)\n      return(DestroyPixelThreadSet(pixels));\n    for (j=0; j < (ssize_t) image->columns; j++)\n    {\n      register ssize_t\n        k;\n\n      for (k=0; k < MaxPixelChannels; k++)\n        pixels[i][j].channel[k]=0.0;\n    }\n  }\n  return(pixels);\n}\n\nstatic inline double EvaluateMax(const double x,const double y)\n{\n  if (x > y)\n    return(x);\n  return(y);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int IntensityCompare(const void *x,const void *y)\n{\n  const PixelChannels\n    *color_1,\n    *color_2;\n\n  double\n    distance;\n\n  register ssize_t\n    i;\n\n  color_1=(const PixelChannels *) x;\n  color_2=(const PixelChannels *) y;\n  distance=0.0;\n  for (i=0; i < MaxPixelChannels; i++)\n    distance+=color_1->channel[i]-(double) color_2->channel[i];\n  return(distance < 0 ? -1 : distance > 0 ? 1 : 0);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic double ApplyEvaluateOperator(RandomInfo *random_info,const Quantum pixel,\n  const MagickEvaluateOperator op,const double value)\n{\n  double\n    result;\n\n  result=0.0;\n  switch (op)\n  {\n    case UndefinedEvaluateOperator:\n      break;\n    case AbsEvaluateOperator:\n    {\n      result=(double) fabs((double) (pixel+value));\n      break;\n    }\n    case AddEvaluateOperator:\n    {\n      result=(double) (pixel+value);\n      break;\n    }\n    case AddModulusEvaluateOperator:\n    {\n      /*\n        This returns a 'floored modulus' of the addition which is a positive\n        result.  It differs from % or fmod() that returns a 'truncated modulus'\n        result, where floor() is replaced by trunc() and could return a\n        negative result (which is clipped).\n      */\n      result=pixel+value;\n      result-=(QuantumRange+1.0)*floor((double) result/(QuantumRange+1.0));\n      break;\n    }\n    case AndEvaluateOperator:\n    {\n      result=(double) ((size_t) pixel & (size_t) (value+0.5));\n      break;\n    }\n    case CosineEvaluateOperator:\n    {\n      result=(double) (QuantumRange*(0.5*cos((double) (2.0*MagickPI*\n        QuantumScale*pixel*value))+0.5));\n      break;\n    }\n    case DivideEvaluateOperator:\n    {\n      result=pixel/(value == 0.0 ? 1.0 : value);\n      break;\n    }\n    case ExponentialEvaluateOperator:\n    {\n      result=(double) (QuantumRange*exp((double) (value*QuantumScale*pixel)));\n      break;\n    }\n    case GaussianNoiseEvaluateOperator:\n    {\n      result=(double) GenerateDifferentialNoise(random_info,pixel,\n        GaussianNoise,value);\n      break;\n    }\n    case ImpulseNoiseEvaluateOperator:\n    {\n      result=(double) GenerateDifferentialNoise(random_info,pixel,ImpulseNoise,\n        value);\n      break;\n    }\n    case LaplacianNoiseEvaluateOperator:\n    {\n      result=(double) GenerateDifferentialNoise(random_info,pixel,\n        LaplacianNoise,value);\n      break;\n    }\n    case LeftShiftEvaluateOperator:\n    {\n      result=(double) ((size_t) pixel << (size_t) (value+0.5));\n      break;\n    }\n    case LogEvaluateOperator:\n    {\n      if ((QuantumScale*pixel) >= MagickEpsilon)\n        result=(double) (QuantumRange*log((double) (QuantumScale*value*pixel+\n          1.0))/log((double) (value+1.0)));\n      break;\n    }\n    case MaxEvaluateOperator:\n    {\n      result=(double) EvaluateMax((double) pixel,value);\n      break;\n    }\n    case MeanEvaluateOperator:\n    {\n      result=(double) (pixel+value);\n      break;\n    }\n    case MedianEvaluateOperator:\n    {\n      result=(double) (pixel+value);\n      break;\n    }\n    case MinEvaluateOperator:\n    {\n      result=(double) MagickMin((double) pixel,value);\n      break;\n    }\n    case MultiplicativeNoiseEvaluateOperator:\n    {\n      result=(double) GenerateDifferentialNoise(random_info,pixel,\n        MultiplicativeGaussianNoise,value);\n      break;\n    }\n    case MultiplyEvaluateOperator:\n    {\n      result=(double) (value*pixel);\n      break;\n    }\n    case OrEvaluateOperator:\n    {\n      result=(double) ((size_t) pixel | (size_t) (value+0.5));\n      break;\n    }\n    case PoissonNoiseEvaluateOperator:\n    {\n      result=(double) GenerateDifferentialNoise(random_info,pixel,PoissonNoise,\n        value);\n      break;\n    }\n    case PowEvaluateOperator:\n    {\n      result=(double) (QuantumRange*pow((double) (QuantumScale*pixel),(double)\n        value));\n      break;\n    }\n    case RightShiftEvaluateOperator:\n    {\n      result=(double) ((size_t) pixel >> (size_t) (value+0.5));\n      break;\n    }\n    case RootMeanSquareEvaluateOperator:\n    {\n      result=(double) (pixel*pixel+value);\n      break;\n    }\n    case SetEvaluateOperator:\n    {\n      result=value;\n      break;\n    }\n    case SineEvaluateOperator:\n    {\n      result=(double) (QuantumRange*(0.5*sin((double) (2.0*MagickPI*\n        QuantumScale*pixel*value))+0.5));\n      break;\n    }\n    case SubtractEvaluateOperator:\n    {\n      result=(double) (pixel-value);\n      break;\n    }\n    case SumEvaluateOperator:\n    {\n      result=(double) (pixel+value);\n      break;\n    }\n    case ThresholdEvaluateOperator:\n    {\n      result=(double) (((double) pixel <= value) ? 0 : QuantumRange);\n      break;\n    }\n    case ThresholdBlackEvaluateOperator:\n    {\n      result=(double) (((double) pixel <= value) ? 0 : pixel);\n      break;\n    }\n    case ThresholdWhiteEvaluateOperator:\n    {\n      result=(double) (((double) pixel > value) ? QuantumRange : pixel);\n      break;\n    }\n    case UniformNoiseEvaluateOperator:\n    {\n      result=(double) GenerateDifferentialNoise(random_info,pixel,UniformNoise,\n        value);\n      break;\n    }\n    case XorEvaluateOperator:\n    {\n      result=(double) ((size_t) pixel ^ (size_t) (value+0.5));\n      break;\n    }\n  }\n  return(result);\n}\n\nstatic Image *AcquireImageCanvas(const Image *images,ExceptionInfo *exception)\n{\n  const Image\n    *p,\n    *q;\n\n  size_t\n    columns,\n    rows;\n\n  q=images;\n  columns=images->columns;\n  rows=images->rows;\n  for (p=images; p != (Image *) NULL; p=p->next)\n  {\n    if (p->number_channels > q->number_channels)\n      q=p;\n    if (p->columns > columns)\n      columns=p->columns;\n    if (p->rows > rows)\n      rows=p->rows;\n  }\n  return(CloneImage(q,columns,rows,MagickTrue,exception));\n}\n\nMagickExport Image *EvaluateImages(const Image *images,\n  const MagickEvaluateOperator op,ExceptionInfo *exception)\n{\n#define EvaluateImageTag  \"Evaluate/Image\"\n\n  CacheView\n    *evaluate_view;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  PixelChannels\n    **magick_restrict evaluate_pixels;\n\n  RandomInfo\n    **magick_restrict random_info;\n\n  size_t\n    number_images;\n\n  ssize_t\n    y;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  unsigned long\n    key;\n#endif\n\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImageCanvas(images,exception);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  number_images=GetImageListLength(images);\n  evaluate_pixels=AcquirePixelThreadSet(images);\n  if (evaluate_pixels == (PixelChannels **) NULL)\n    {\n      image=DestroyImage(image);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",images->filename);\n      return((Image *) NULL);\n    }\n  /*\n    Evaluate image pixels.\n  */\n  status=MagickTrue;\n  progress=0;\n  random_info=AcquireRandomInfoThreadSet();\n  evaluate_view=AcquireAuthenticCacheView(image,exception);\n  if (op == MedianEvaluateOperator)\n    {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      key=GetRandomSecretKey(random_info[0]);\n      #pragma omp parallel for schedule(static) shared(progress,status) \\\n        magick_number_threads(image,images,image->rows,key == ~0UL)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        CacheView\n          *image_view;\n\n        const Image\n          *next;\n\n        const int\n          id = GetOpenMPThreadId();\n\n        register PixelChannels\n          *evaluate_pixel;\n\n        register Quantum\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        q=QueueCacheViewAuthenticPixels(evaluate_view,0,y,image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        evaluate_pixel=evaluate_pixels[id];\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          register ssize_t\n            j,\n            k;\n\n          for (j=0; j < (ssize_t) number_images; j++)\n            for (k=0; k < MaxPixelChannels; k++)\n              evaluate_pixel[j].channel[k]=0.0;\n          next=images;\n          for (j=0; j < (ssize_t) number_images; j++)\n          {\n            register const Quantum\n              *p;\n\n            register ssize_t\n              i;\n\n            image_view=AcquireVirtualCacheView(next,exception);\n            p=GetCacheViewVirtualPixels(image_view,x,y,1,1,exception);\n            if (p == (const Quantum *) NULL)\n              {\n                image_view=DestroyCacheView(image_view);\n                break;\n              }\n            for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n            {\n              PixelChannel channel = GetPixelChannelChannel(image,i);\n              PixelTrait evaluate_traits=GetPixelChannelTraits(image,channel);\n              PixelTrait traits = GetPixelChannelTraits(next,channel);\n              if ((traits == UndefinedPixelTrait) ||\n                  (evaluate_traits == UndefinedPixelTrait))\n                continue;\n              if ((traits & UpdatePixelTrait) == 0)\n                continue;\n              evaluate_pixel[j].channel[i]=ApplyEvaluateOperator(\n                random_info[id],GetPixelChannel(image,channel,p),op,\n                evaluate_pixel[j].channel[i]);\n            }\n            image_view=DestroyCacheView(image_view);\n            next=GetNextImageInList(next);\n          }\n          qsort((void *) evaluate_pixel,number_images,sizeof(*evaluate_pixel),\n            IntensityCompare);\n          for (k=0; k < (ssize_t) GetPixelChannels(image); k++)\n            q[k]=ClampToQuantum(evaluate_pixel[j/2].channel[k]);\n          q+=GetPixelChannels(image);\n        }\n        if (SyncCacheViewAuthenticPixels(evaluate_view,exception) == MagickFalse)\n          status=MagickFalse;\n        if (images->progress_monitor != (MagickProgressMonitor) NULL)\n          {\n            MagickBooleanType\n              proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n            #pragma omp atomic\n#endif\n            progress++;\n            proceed=SetImageProgress(images,EvaluateImageTag,progress,\n              image->rows);\n            if (proceed == MagickFalse)\n              status=MagickFalse;\n          }\n      }\n    }\n  else\n    {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      key=GetRandomSecretKey(random_info[0]);\n      #pragma omp parallel for schedule(static) shared(progress,status) \\\n        magick_number_threads(image,images,image->rows,key == ~0UL)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        CacheView\n          *image_view;\n\n        const Image\n          *next;\n\n        const int\n          id = GetOpenMPThreadId();\n\n        register ssize_t\n          i,\n          x;\n\n        register PixelChannels\n          *evaluate_pixel;\n\n        register Quantum\n          *magick_restrict q;\n\n        ssize_t\n          j;\n\n        if (status == MagickFalse)\n          continue;\n        q=QueueCacheViewAuthenticPixels(evaluate_view,0,y,image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        evaluate_pixel=evaluate_pixels[id];\n        for (j=0; j < (ssize_t) image->columns; j++)\n          for (i=0; i < MaxPixelChannels; i++)\n            evaluate_pixel[j].channel[i]=0.0;\n        next=images;\n        for (j=0; j < (ssize_t) number_images; j++)\n        {\n          register const Quantum\n            *p;\n\n          image_view=AcquireVirtualCacheView(next,exception);\n          p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,\n            exception);\n          if (p == (const Quantum *) NULL)\n            {\n              image_view=DestroyCacheView(image_view);\n              break;\n            }\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            register ssize_t\n              i;\n\n            for (i=0; i < (ssize_t) GetPixelChannels(next); i++)\n            {\n              PixelChannel channel = GetPixelChannelChannel(image,i);\n              PixelTrait traits = GetPixelChannelTraits(next,channel);\n              PixelTrait evaluate_traits=GetPixelChannelTraits(image,channel);\n              if ((traits == UndefinedPixelTrait) ||\n                  (evaluate_traits == UndefinedPixelTrait))\n                continue;\n              if ((traits & UpdatePixelTrait) == 0)\n                continue;\n              evaluate_pixel[x].channel[i]=ApplyEvaluateOperator(\n                random_info[id],GetPixelChannel(image,channel,p),j == 0 ?\n                AddEvaluateOperator : op,evaluate_pixel[x].channel[i]);\n            }\n            p+=GetPixelChannels(next);\n          }\n          image_view=DestroyCacheView(image_view);\n          next=GetNextImageInList(next);\n        }\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          register ssize_t\n             i;\n\n          switch (op)\n          {\n            case MeanEvaluateOperator:\n            {\n              for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n                evaluate_pixel[x].channel[i]/=(double) number_images;\n              break;\n            }\n            case MultiplyEvaluateOperator:\n            {\n              for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n              {\n                register ssize_t\n                  j;\n\n                for (j=0; j < (ssize_t) (number_images-1); j++)\n                  evaluate_pixel[x].channel[i]*=QuantumScale;\n              }\n              break;\n            }\n            case RootMeanSquareEvaluateOperator:\n            {\n              for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n                evaluate_pixel[x].channel[i]=sqrt(evaluate_pixel[x].channel[i]/\n                  number_images);\n              break;\n            }\n            default:\n              break;\n          }\n        }\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          register ssize_t\n            i;\n\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel = GetPixelChannelChannel(image,i);\n            PixelTrait traits = GetPixelChannelTraits(image,channel);\n            if (traits == UndefinedPixelTrait)\n              continue;\n            if ((traits & UpdatePixelTrait) == 0)\n              continue;\n            q[i]=ClampToQuantum(evaluate_pixel[x].channel[i]);\n          }\n          q+=GetPixelChannels(image);\n        }\n        if (SyncCacheViewAuthenticPixels(evaluate_view,exception) == MagickFalse)\n          status=MagickFalse;\n        if (images->progress_monitor != (MagickProgressMonitor) NULL)\n          {\n            MagickBooleanType\n              proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n            #pragma omp atomic\n#endif\n            progress++;\n            proceed=SetImageProgress(images,EvaluateImageTag,progress,\n              image->rows);\n            if (proceed == MagickFalse)\n              status=MagickFalse;\n          }\n      }\n    }\n  evaluate_view=DestroyCacheView(evaluate_view);\n  evaluate_pixels=DestroyPixelThreadSet(evaluate_pixels);\n  random_info=DestroyRandomInfoThreadSet(random_info);\n  if (status == MagickFalse)\n    image=DestroyImage(image);\n  return(image);\n}\n\nMagickExport MagickBooleanType EvaluateImage(Image *image,\n  const MagickEvaluateOperator op,const double value,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  RandomInfo\n    **magick_restrict random_info;\n\n  ssize_t\n    y;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  unsigned long\n    key;\n#endif\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  status=MagickTrue;\n  progress=0;\n  random_info=AcquireRandomInfoThreadSet();\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  key=GetRandomSecretKey(random_info[0]);\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,key == ~0UL)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        result;\n\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        if ((traits & CopyPixelTrait) != 0)\n          continue;\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        result=ApplyEvaluateOperator(random_info[id],q[i],op,value);\n        if (op == MeanEvaluateOperator)\n          result/=2.0;\n        q[i]=ClampToQuantum(result);\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,EvaluateImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  random_info=DestroyRandomInfoThreadSet(random_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     F u n c t i o n I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FunctionImage() applies a value to the image with an arithmetic, relational,\n%  or logical operator to an image. Use these operations to lighten or darken\n%  an image, to increase or decrease contrast in an image, or to produce the\n%  \"negative\" of an image.\n%\n%  The format of the FunctionImage method is:\n%\n%      MagickBooleanType FunctionImage(Image *image,\n%        const MagickFunction function,const ssize_t number_parameters,\n%        const double *parameters,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o function: A channel function.\n%\n%    o parameters: one or more parameters.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic Quantum ApplyFunction(Quantum pixel,const MagickFunction function,\n  const size_t number_parameters,const double *parameters,\n  ExceptionInfo *exception)\n{\n  double\n    result;\n\n  register ssize_t\n    i;\n\n  (void) exception;\n  result=0.0;\n  switch (function)\n  {\n    case PolynomialFunction:\n    {\n      /*\n        Polynomial: polynomial constants, highest to lowest order (e.g. c0*x^3+\n        c1*x^2+c2*x+c3).\n      */\n      result=0.0;\n      for (i=0; i < (ssize_t) number_parameters; i++)\n        result=result*QuantumScale*pixel+parameters[i];\n      result*=QuantumRange;\n      break;\n    }\n    case SinusoidFunction:\n    {\n      double\n        amplitude,\n        bias,\n        frequency,\n        phase;\n\n      /*\n        Sinusoid: frequency, phase, amplitude, bias.\n      */\n      frequency=(number_parameters >= 1) ? parameters[0] : 1.0;\n      phase=(number_parameters >= 2) ? parameters[1] : 0.0;\n      amplitude=(number_parameters >= 3) ? parameters[2] : 0.5;\n      bias=(number_parameters >= 4) ? parameters[3] : 0.5;\n      result=(double) (QuantumRange*(amplitude*sin((double) (2.0*\n        MagickPI*(frequency*QuantumScale*pixel+phase/360.0)))+bias));\n      break;\n    }\n    case ArcsinFunction:\n    {\n      double\n        bias,\n        center,\n        range,\n        width;\n\n      /*\n        Arcsin (peged at range limits for invalid results): width, center,\n        range, and bias.\n      */\n      width=(number_parameters >= 1) ? parameters[0] : 1.0;\n      center=(number_parameters >= 2) ? parameters[1] : 0.5;\n      range=(number_parameters >= 3) ? parameters[2] : 1.0;\n      bias=(number_parameters >= 4) ? parameters[3] : 0.5;\n      result=2.0/width*(QuantumScale*pixel-center);\n      if ( result <= -1.0 )\n        result=bias-range/2.0;\n      else\n        if (result >= 1.0)\n          result=bias+range/2.0;\n        else\n          result=(double) (range/MagickPI*asin((double) result)+bias);\n      result*=QuantumRange;\n      break;\n    }\n    case ArctanFunction:\n    {\n      double\n        center,\n        bias,\n        range,\n        slope;\n\n      /*\n        Arctan: slope, center, range, and bias.\n      */\n      slope=(number_parameters >= 1) ? parameters[0] : 1.0;\n      center=(number_parameters >= 2) ? parameters[1] : 0.5;\n      range=(number_parameters >= 3) ? parameters[2] : 1.0;\n      bias=(number_parameters >= 4) ? parameters[3] : 0.5;\n      result=(double) (MagickPI*slope*(QuantumScale*pixel-center));\n      result=(double) (QuantumRange*(range/MagickPI*atan((double)\n        result)+bias));\n      break;\n    }\n    case UndefinedFunction:\n      break;\n  }\n  return(ClampToQuantum(result));\n}\n\nMagickExport MagickBooleanType FunctionImage(Image *image,\n  const MagickFunction function,const size_t number_parameters,\n  const double *parameters,ExceptionInfo *exception)\n{\n#define FunctionImageTag  \"Function/Image \"\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n#if defined(MAGICKCORE_OPENCL_SUPPORT)\n  if (AccelerateFunctionImage(image,function,number_parameters,parameters,\n        exception) != MagickFalse)\n    return(MagickTrue);\n#endif\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        q[i]=ApplyFunction(q[i],function,number_parameters,parameters,\n          exception);\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,FunctionImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e E n t r o p y                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageEntropy() returns the entropy of one or more image channels.\n%\n%  The format of the GetImageEntropy method is:\n%\n%      MagickBooleanType GetImageEntropy(const Image *image,double *entropy,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o entropy: the average entropy of the selected channels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetImageEntropy(const Image *image,\n  double *entropy,ExceptionInfo *exception)\n{\n  ChannelStatistics\n    *channel_statistics;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  channel_statistics=GetImageStatistics(image,exception);\n  if (channel_statistics == (ChannelStatistics *) NULL)\n    return(MagickFalse);\n  *entropy=channel_statistics[CompositePixelChannel].entropy;\n  channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n    channel_statistics);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e E x t r e m a                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageExtrema() returns the extrema of one or more image channels.\n%\n%  The format of the GetImageExtrema method is:\n%\n%      MagickBooleanType GetImageExtrema(const Image *image,size_t *minima,\n%        size_t *maxima,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o minima: the minimum value in the channel.\n%\n%    o maxima: the maximum value in the channel.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetImageExtrema(const Image *image,\n  size_t *minima,size_t *maxima,ExceptionInfo *exception)\n{\n  double\n    max,\n    min;\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=GetImageRange(image,&min,&max,exception);\n  *minima=(size_t) ceil(min-0.5);\n  *maxima=(size_t) floor(max+0.5);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e K u r t o s i s                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageKurtosis() returns the kurtosis and skewness of one or more image\n%  channels.\n%\n%  The format of the GetImageKurtosis method is:\n%\n%      MagickBooleanType GetImageKurtosis(const Image *image,double *kurtosis,\n%        double *skewness,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o kurtosis: the kurtosis of the channel.\n%\n%    o skewness: the skewness of the channel.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetImageKurtosis(const Image *image,\n  double *kurtosis,double *skewness,ExceptionInfo *exception)\n{\n  ChannelStatistics\n    *channel_statistics;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  channel_statistics=GetImageStatistics(image,exception);\n  if (channel_statistics == (ChannelStatistics *) NULL)\n    return(MagickFalse);\n  *kurtosis=channel_statistics[CompositePixelChannel].kurtosis;\n  *skewness=channel_statistics[CompositePixelChannel].skewness;\n  channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n    channel_statistics);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e M e a n                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageMean() returns the mean and standard deviation of one or more image\n%  channels.\n%\n%  The format of the GetImageMean method is:\n%\n%      MagickBooleanType GetImageMean(const Image *image,double *mean,\n%        double *standard_deviation,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o mean: the average value in the channel.\n%\n%    o standard_deviation: the standard deviation of the channel.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetImageMean(const Image *image,double *mean,\n  double *standard_deviation,ExceptionInfo *exception)\n{\n  ChannelStatistics\n    *channel_statistics;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  channel_statistics=GetImageStatistics(image,exception);\n  if (channel_statistics == (ChannelStatistics *) NULL)\n    return(MagickFalse);\n  *mean=channel_statistics[CompositePixelChannel].mean;\n  *standard_deviation=\n    channel_statistics[CompositePixelChannel].standard_deviation;\n  channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n    channel_statistics);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e M o m e n t s                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageMoments() returns the normalized moments of one or more image\n%  channels.\n%\n%  The format of the GetImageMoments method is:\n%\n%      ChannelMoments *GetImageMoments(const Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic size_t GetImageChannels(const Image *image)\n{\n  register ssize_t\n    i;\n\n  size_t\n    channels;\n\n  channels=0;\n  for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n  {\n    PixelChannel channel = GetPixelChannelChannel(image,i);\n    PixelTrait traits = GetPixelChannelTraits(image,channel);\n    if (traits == UndefinedPixelTrait)\n      continue;\n    if ((traits & UpdatePixelTrait) == 0)\n      continue;\n    channels++;\n  }\n  return((size_t) (channels == 0 ? 1 : channels));\n}\n\nMagickExport ChannelMoments *GetImageMoments(const Image *image,\n  ExceptionInfo *exception)\n{\n#define MaxNumberImageMoments  8\n\n  CacheView\n    *image_view;\n\n  ChannelMoments\n    *channel_moments;\n\n  double\n    M00[MaxPixelChannels+1],\n    M01[MaxPixelChannels+1],\n    M02[MaxPixelChannels+1],\n    M03[MaxPixelChannels+1],\n    M10[MaxPixelChannels+1],\n    M11[MaxPixelChannels+1],\n    M12[MaxPixelChannels+1],\n    M20[MaxPixelChannels+1],\n    M21[MaxPixelChannels+1],\n    M22[MaxPixelChannels+1],\n    M30[MaxPixelChannels+1];\n\n  PointInfo\n    centroid[MaxPixelChannels+1];\n\n  ssize_t\n    channel,\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  channel_moments=(ChannelMoments *) AcquireQuantumMemory(MaxPixelChannels+1,\n    sizeof(*channel_moments));\n  if (channel_moments == (ChannelMoments *) NULL)\n    return(channel_moments);\n  (void) memset(channel_moments,0,(MaxPixelChannels+1)*\n    sizeof(*channel_moments));\n  (void) memset(centroid,0,sizeof(centroid));\n  (void) memset(M00,0,sizeof(M00));\n  (void) memset(M01,0,sizeof(M01));\n  (void) memset(M02,0,sizeof(M02));\n  (void) memset(M03,0,sizeof(M03));\n  (void) memset(M10,0,sizeof(M10));\n  (void) memset(M11,0,sizeof(M11));\n  (void) memset(M12,0,sizeof(M12));\n  (void) memset(M20,0,sizeof(M20));\n  (void) memset(M21,0,sizeof(M21));\n  (void) memset(M22,0,sizeof(M22));\n  (void) memset(M30,0,sizeof(M30));\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    /*\n      Compute center of mass (centroid).\n    */\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        M00[channel]+=QuantumScale*p[i];\n        M00[MaxPixelChannels]+=QuantumScale*p[i];\n        M10[channel]+=x*QuantumScale*p[i];\n        M10[MaxPixelChannels]+=x*QuantumScale*p[i];\n        M01[channel]+=y*QuantumScale*p[i];\n        M01[MaxPixelChannels]+=y*QuantumScale*p[i];\n      }\n      p+=GetPixelChannels(image);\n    }\n  }\n  for (channel=0; channel <= MaxPixelChannels; channel++)\n  {\n    /*\n       Compute center of mass (centroid).\n    */\n    if (M00[channel] < MagickEpsilon)\n      {\n        M00[channel]+=MagickEpsilon;\n        centroid[channel].x=(double) image->columns/2.0;\n        centroid[channel].y=(double) image->rows/2.0;\n        continue;\n      }\n    M00[channel]+=MagickEpsilon;\n    centroid[channel].x=M10[channel]/M00[channel];\n    centroid[channel].y=M01[channel]/M00[channel];\n  }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    /*\n      Compute the image moments.\n    */\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        M11[channel]+=(x-centroid[channel].x)*(y-centroid[channel].y)*\n          QuantumScale*p[i];\n        M11[MaxPixelChannels]+=(x-centroid[channel].x)*(y-centroid[channel].y)*\n          QuantumScale*p[i];\n        M20[channel]+=(x-centroid[channel].x)*(x-centroid[channel].x)*\n          QuantumScale*p[i];\n        M20[MaxPixelChannels]+=(x-centroid[channel].x)*(x-centroid[channel].x)*\n          QuantumScale*p[i];\n        M02[channel]+=(y-centroid[channel].y)*(y-centroid[channel].y)*\n          QuantumScale*p[i];\n        M02[MaxPixelChannels]+=(y-centroid[channel].y)*(y-centroid[channel].y)*\n          QuantumScale*p[i];\n        M21[channel]+=(x-centroid[channel].x)*(x-centroid[channel].x)*\n          (y-centroid[channel].y)*QuantumScale*p[i];\n        M21[MaxPixelChannels]+=(x-centroid[channel].x)*(x-centroid[channel].x)*\n          (y-centroid[channel].y)*QuantumScale*p[i];\n        M12[channel]+=(x-centroid[channel].x)*(y-centroid[channel].y)*\n          (y-centroid[channel].y)*QuantumScale*p[i];\n        M12[MaxPixelChannels]+=(x-centroid[channel].x)*(y-centroid[channel].y)*\n          (y-centroid[channel].y)*QuantumScale*p[i];\n        M22[channel]+=(x-centroid[channel].x)*(x-centroid[channel].x)*\n          (y-centroid[channel].y)*(y-centroid[channel].y)*QuantumScale*p[i];\n        M22[MaxPixelChannels]+=(x-centroid[channel].x)*(x-centroid[channel].x)*\n          (y-centroid[channel].y)*(y-centroid[channel].y)*QuantumScale*p[i];\n        M30[channel]+=(x-centroid[channel].x)*(x-centroid[channel].x)*\n          (x-centroid[channel].x)*QuantumScale*p[i];\n        M30[MaxPixelChannels]+=(x-centroid[channel].x)*(x-centroid[channel].x)*\n          (x-centroid[channel].x)*QuantumScale*p[i];\n        M03[channel]+=(y-centroid[channel].y)*(y-centroid[channel].y)*\n          (y-centroid[channel].y)*QuantumScale*p[i];\n        M03[MaxPixelChannels]+=(y-centroid[channel].y)*(y-centroid[channel].y)*\n          (y-centroid[channel].y)*QuantumScale*p[i];\n      }\n      p+=GetPixelChannels(image);\n    }\n  }\n  M00[MaxPixelChannels]/=GetImageChannels(image);\n  M01[MaxPixelChannels]/=GetImageChannels(image);\n  M02[MaxPixelChannels]/=GetImageChannels(image);\n  M03[MaxPixelChannels]/=GetImageChannels(image);\n  M10[MaxPixelChannels]/=GetImageChannels(image);\n  M11[MaxPixelChannels]/=GetImageChannels(image);\n  M12[MaxPixelChannels]/=GetImageChannels(image);\n  M20[MaxPixelChannels]/=GetImageChannels(image);\n  M21[MaxPixelChannels]/=GetImageChannels(image);\n  M22[MaxPixelChannels]/=GetImageChannels(image);\n  M30[MaxPixelChannels]/=GetImageChannels(image);\n  for (channel=0; channel <= MaxPixelChannels; channel++)\n  {\n    /*\n      Compute elliptical angle, major and minor axes, eccentricity, & intensity.\n    */\n    channel_moments[channel].centroid=centroid[channel];\n    channel_moments[channel].ellipse_axis.x=sqrt((2.0/M00[channel])*\n      ((M20[channel]+M02[channel])+sqrt(4.0*M11[channel]*M11[channel]+\n      (M20[channel]-M02[channel])*(M20[channel]-M02[channel]))));\n    channel_moments[channel].ellipse_axis.y=sqrt((2.0/M00[channel])*\n      ((M20[channel]+M02[channel])-sqrt(4.0*M11[channel]*M11[channel]+\n      (M20[channel]-M02[channel])*(M20[channel]-M02[channel]))));\n    channel_moments[channel].ellipse_angle=RadiansToDegrees(0.5*atan(2.0*\n      M11[channel]/(M20[channel]-M02[channel]+MagickEpsilon)));\n    if (fabs(M11[channel]) < MagickEpsilon)\n      {\n        if (fabs(M20[channel]-M02[channel]) < MagickEpsilon)\n          channel_moments[channel].ellipse_angle+=0.0;\n        else\n          if ((M20[channel]-M02[channel]) < 0.0)\n            channel_moments[channel].ellipse_angle+=90.0;\n          else\n            channel_moments[channel].ellipse_angle+=0.0;\n      }\n    else\n      if (M11[channel] < 0.0)\n        {\n          if (fabs(M20[channel]-M02[channel]) < MagickEpsilon)\n            channel_moments[channel].ellipse_angle+=0.0;\n          else\n            if ((M20[channel]-M02[channel]) < 0.0)\n              channel_moments[channel].ellipse_angle+=90.0;\n            else\n              channel_moments[channel].ellipse_angle+=180.0;\n        }\n      else\n        {\n          if (fabs(M20[channel]-M02[channel]) < MagickEpsilon)\n            channel_moments[channel].ellipse_angle+=0.0;\n          else\n            if ((M20[channel]-M02[channel]) < 0.0)\n              channel_moments[channel].ellipse_angle+=90.0;\n            else\n              channel_moments[channel].ellipse_angle+=0.0;\n       }\n    channel_moments[channel].ellipse_eccentricity=sqrt(1.0-(\n      channel_moments[channel].ellipse_axis.y/\n      (channel_moments[channel].ellipse_axis.x+MagickEpsilon)));\n    channel_moments[channel].ellipse_intensity=M00[channel]/\n      (MagickPI*channel_moments[channel].ellipse_axis.x*\n      channel_moments[channel].ellipse_axis.y+MagickEpsilon);\n  }\n  for (channel=0; channel <= MaxPixelChannels; channel++)\n  {\n    /*\n      Normalize image moments.\n    */\n    M10[channel]=0.0;\n    M01[channel]=0.0;\n    M11[channel]/=pow(M00[channel],1.0+(1.0+1.0)/2.0);\n    M20[channel]/=pow(M00[channel],1.0+(2.0+0.0)/2.0);\n    M02[channel]/=pow(M00[channel],1.0+(0.0+2.0)/2.0);\n    M21[channel]/=pow(M00[channel],1.0+(2.0+1.0)/2.0);\n    M12[channel]/=pow(M00[channel],1.0+(1.0+2.0)/2.0);\n    M22[channel]/=pow(M00[channel],1.0+(2.0+2.0)/2.0);\n    M30[channel]/=pow(M00[channel],1.0+(3.0+0.0)/2.0);\n    M03[channel]/=pow(M00[channel],1.0+(0.0+3.0)/2.0);\n    M00[channel]=1.0;\n  }\n  image_view=DestroyCacheView(image_view);\n  for (channel=0; channel <= MaxPixelChannels; channel++)\n  {\n    /*\n      Compute Hu invariant moments.\n    */\n    channel_moments[channel].invariant[0]=M20[channel]+M02[channel];\n    channel_moments[channel].invariant[1]=(M20[channel]-M02[channel])*\n      (M20[channel]-M02[channel])+4.0*M11[channel]*M11[channel];\n    channel_moments[channel].invariant[2]=(M30[channel]-3.0*M12[channel])*\n      (M30[channel]-3.0*M12[channel])+(3.0*M21[channel]-M03[channel])*\n      (3.0*M21[channel]-M03[channel]);\n    channel_moments[channel].invariant[3]=(M30[channel]+M12[channel])*\n      (M30[channel]+M12[channel])+(M21[channel]+M03[channel])*\n      (M21[channel]+M03[channel]);\n    channel_moments[channel].invariant[4]=(M30[channel]-3.0*M12[channel])*\n      (M30[channel]+M12[channel])*((M30[channel]+M12[channel])*\n      (M30[channel]+M12[channel])-3.0*(M21[channel]+M03[channel])*\n      (M21[channel]+M03[channel]))+(3.0*M21[channel]-M03[channel])*\n      (M21[channel]+M03[channel])*(3.0*(M30[channel]+M12[channel])*\n      (M30[channel]+M12[channel])-(M21[channel]+M03[channel])*\n      (M21[channel]+M03[channel]));\n    channel_moments[channel].invariant[5]=(M20[channel]-M02[channel])*\n      ((M30[channel]+M12[channel])*(M30[channel]+M12[channel])-\n      (M21[channel]+M03[channel])*(M21[channel]+M03[channel]))+\n      4.0*M11[channel]*(M30[channel]+M12[channel])*(M21[channel]+M03[channel]);\n    channel_moments[channel].invariant[6]=(3.0*M21[channel]-M03[channel])*\n      (M30[channel]+M12[channel])*((M30[channel]+M12[channel])*\n      (M30[channel]+M12[channel])-3.0*(M21[channel]+M03[channel])*\n      (M21[channel]+M03[channel]))-(M30[channel]-3*M12[channel])*\n      (M21[channel]+M03[channel])*(3.0*(M30[channel]+M12[channel])*\n      (M30[channel]+M12[channel])-(M21[channel]+M03[channel])*\n      (M21[channel]+M03[channel]));\n    channel_moments[channel].invariant[7]=M11[channel]*((M30[channel]+\n      M12[channel])*(M30[channel]+M12[channel])-(M03[channel]+M21[channel])*\n      (M03[channel]+M21[channel]))-(M20[channel]-M02[channel])*\n      (M30[channel]+M12[channel])*(M03[channel]+M21[channel]);\n  }\n  if (y < (ssize_t) image->rows)\n    channel_moments=(ChannelMoments *) RelinquishMagickMemory(channel_moments);\n  return(channel_moments);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e C h a n n e l P e r c e p t u a l H a s h                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImagePerceptualHash() returns the perceptual hash of one or more\n%  image channels.\n%\n%  The format of the GetImagePerceptualHash method is:\n%\n%      ChannelPerceptualHash *GetImagePerceptualHash(const Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline double MagickLog10(const double x)\n{\n#define Log10Epsilon  (1.0e-11)\n\n  if (fabs(x) < Log10Epsilon)\n    return(log10(Log10Epsilon));\n  return(log10(fabs(x)));\n}\n\nMagickExport ChannelPerceptualHash *GetImagePerceptualHash(const Image *image,\n  ExceptionInfo *exception)\n{\n  ChannelPerceptualHash\n    *perceptual_hash;\n\n  char\n    *colorspaces,\n    *q;\n\n  const char\n    *artifact;\n\n  MagickBooleanType\n    status;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  perceptual_hash=(ChannelPerceptualHash *) AcquireQuantumMemory(\n    MaxPixelChannels+1UL,sizeof(*perceptual_hash));\n  if (perceptual_hash == (ChannelPerceptualHash *) NULL)\n    return((ChannelPerceptualHash *) NULL);\n  artifact=GetImageArtifact(image,\"phash:colorspaces\");\n  if (artifact != NULL)\n    colorspaces=AcquireString(artifact);\n  else\n    colorspaces=AcquireString(\"sRGB,HCLp\");\n  perceptual_hash[0].number_colorspaces=0;\n  perceptual_hash[0].number_channels=0;\n  q=colorspaces;\n  for (i=0; (p=StringToken(\",\",&q)) != (char *) NULL; i++)\n  {\n    ChannelMoments\n      *moments;\n\n    Image\n      *hash_image;\n\n    size_t\n      j;\n\n    ssize_t\n      channel,\n      colorspace;\n\n    if (i >= MaximumNumberOfPerceptualColorspaces)\n      break;\n    colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,p);\n    if (colorspace < 0)\n      break;\n    perceptual_hash[0].colorspace[i]=(ColorspaceType) colorspace;\n    hash_image=BlurImage(image,0.0,1.0,exception);\n    if (hash_image == (Image *) NULL)\n      break;\n    hash_image->depth=8;\n    status=TransformImageColorspace(hash_image,(ColorspaceType) colorspace,\n      exception);\n    if (status == MagickFalse)\n      break;\n    moments=GetImageMoments(hash_image,exception);\n    perceptual_hash[0].number_colorspaces++;\n    perceptual_hash[0].number_channels+=GetImageChannels(hash_image);\n    hash_image=DestroyImage(hash_image);\n    if (moments == (ChannelMoments *) NULL)\n      break;\n    for (channel=0; channel <= MaxPixelChannels; channel++)\n      for (j=0; j < MaximumNumberOfImageMoments; j++)\n        perceptual_hash[channel].phash[i][j]=\n          (-MagickLog10(moments[channel].invariant[j]));\n    moments=(ChannelMoments *) RelinquishMagickMemory(moments);\n  }\n  colorspaces=DestroyString(colorspaces);\n  return(perceptual_hash);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e R a n g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageRange() returns the range of one or more image channels.\n%\n%  The format of the GetImageRange method is:\n%\n%      MagickBooleanType GetImageRange(const Image *image,double *minima,\n%        double *maxima,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o minima: the minimum value in the channel.\n%\n%    o maxima: the maximum value in the channel.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetImageRange(const Image *image,double *minima,\n  double *maxima,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    initialize,\n    status;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=MagickTrue;\n  initialize=MagickTrue;\n  *maxima=0.0;\n  *minima=0.0;\n  image_view=AcquireVirtualCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status,initialize) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    double\n      row_maxima = 0.0,\n      row_minima = 0.0;\n\n    MagickBooleanType\n      row_initialize;\n\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    row_initialize=MagickTrue;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n\t\t\t\tif (row_initialize != MagickFalse)\n          {\n            row_minima=(double) p[i];\n            row_maxima=(double) p[i];\n            row_initialize=MagickFalse;\n          }\n        else\n          {\n            if ((double) p[i] < row_minima)\n              row_minima=(double) p[i];\n            if ((double) p[i] > row_maxima)\n              row_maxima=(double) p[i];\n         }\n      }\n      p+=GetPixelChannels(image);\n    }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#pragma omp critical (MagickCore_GetImageRange)\n#endif\n    {\n      if (initialize != MagickFalse)\n        {\n          *minima=row_minima;\n          *maxima=row_maxima;\n          initialize=MagickFalse;\n        }\n      else\n        {\n          if (row_minima < *minima)\n            *minima=row_minima;\n          if (row_maxima > *maxima)\n            *maxima=row_maxima;\n        }\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e S t a t i s t i c s                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageStatistics() returns statistics for each channel in the image.  The\n%  statistics include the channel depth, its minima, maxima, mean, standard\n%  deviation, kurtosis and skewness.  You can access the red channel mean, for\n%  example, like this:\n%\n%      channel_statistics=GetImageStatistics(image,exception);\n%      red_mean=channel_statistics[RedPixelChannel].mean;\n%\n%  Use MagickRelinquishMemory() to free the statistics buffer.\n%\n%  The format of the GetImageStatistics method is:\n%\n%      ChannelStatistics *GetImageStatistics(const Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport ChannelStatistics *GetImageStatistics(const Image *image,\n  ExceptionInfo *exception)\n{\n  ChannelStatistics\n    *channel_statistics;\n\n  double\n    area,\n    *histogram,\n    standard_deviation;\n\n  MagickStatusType\n    status;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    i;\n\n  size_t\n    depth;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  histogram=(double *) AcquireQuantumMemory(MaxMap+1UL,GetPixelChannels(image)*\n    sizeof(*histogram));\n  channel_statistics=(ChannelStatistics *) AcquireQuantumMemory(\n    MaxPixelChannels+1,sizeof(*channel_statistics));\n  if ((channel_statistics == (ChannelStatistics *) NULL) ||\n      (histogram == (double *) NULL))\n    {\n      if (histogram != (double *) NULL)\n        histogram=(double *) RelinquishMagickMemory(histogram);\n      if (channel_statistics != (ChannelStatistics *) NULL)\n        channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n          channel_statistics);\n      return(channel_statistics);\n    }\n  (void) memset(channel_statistics,0,(MaxPixelChannels+1)*\n    sizeof(*channel_statistics));\n  for (i=0; i <= (ssize_t) MaxPixelChannels; i++)\n  {\n    channel_statistics[i].depth=1;\n    channel_statistics[i].maxima=(-MagickMaximumValue);\n    channel_statistics[i].minima=MagickMaximumValue;\n  }\n  (void) memset(histogram,0,(MaxMap+1)*GetPixelChannels(image)*\n    sizeof(*histogram));\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    /*\n      Compute pixel statistics.\n    */\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,p) <= (QuantumRange/2))\n        {\n          p+=GetPixelChannels(image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if (channel_statistics[channel].depth != MAGICKCORE_QUANTUM_DEPTH)\n          {\n            depth=channel_statistics[channel].depth;\n            range=GetQuantumRange(depth);\n            status=p[i] != ScaleAnyToQuantum(ScaleQuantumToAny(p[i],range),\n              range) ? MagickTrue : MagickFalse;\n            if (status != MagickFalse)\n              {\n                channel_statistics[channel].depth++;\n                i--;\n                continue;\n              }\n          }\n        if ((double) p[i] < channel_statistics[channel].minima)\n          channel_statistics[channel].minima=(double) p[i];\n        if ((double) p[i] > channel_statistics[channel].maxima)\n          channel_statistics[channel].maxima=(double) p[i];\n        channel_statistics[channel].sum+=p[i];\n        channel_statistics[channel].sum_squared+=(double) p[i]*p[i];\n        channel_statistics[channel].sum_cubed+=(double) p[i]*p[i]*p[i];\n        channel_statistics[channel].sum_fourth_power+=(double) p[i]*p[i]*p[i]*\n          p[i];\n        channel_statistics[channel].area++;\n        if ((double) p[i] < channel_statistics[CompositePixelChannel].minima)\n          channel_statistics[CompositePixelChannel].minima=(double) p[i];\n        if ((double) p[i] > channel_statistics[CompositePixelChannel].maxima)\n          channel_statistics[CompositePixelChannel].maxima=(double) p[i];\n        histogram[GetPixelChannels(image)*ScaleQuantumToMap(\n          ClampToQuantum((double) p[i]))+i]++;\n        channel_statistics[CompositePixelChannel].sum+=(double) p[i];\n        channel_statistics[CompositePixelChannel].sum_squared+=(double)\n          p[i]*p[i];\n        channel_statistics[CompositePixelChannel].sum_cubed+=(double)\n          p[i]*p[i]*p[i];\n        channel_statistics[CompositePixelChannel].sum_fourth_power+=(double)\n          p[i]*p[i]*p[i]*p[i];\n        channel_statistics[CompositePixelChannel].area++;\n      }\n      p+=GetPixelChannels(image);\n    }\n  }\n  for (i=0; i <= (ssize_t) MaxPixelChannels; i++)\n  {\n    /*\n      Normalize pixel statistics.\n    */\n    area=PerceptibleReciprocal(channel_statistics[i].area);\n    channel_statistics[i].sum*=area;\n    channel_statistics[i].sum_squared*=area;\n    channel_statistics[i].sum_cubed*=area;\n    channel_statistics[i].sum_fourth_power*=area;\n    channel_statistics[i].mean=channel_statistics[i].sum;\n    channel_statistics[i].variance=channel_statistics[i].sum_squared;\n    standard_deviation=sqrt(channel_statistics[i].variance-\n      (channel_statistics[i].mean*channel_statistics[i].mean));\n    standard_deviation=sqrt(PerceptibleReciprocal(channel_statistics[i].area-\n      1.0)*channel_statistics[i].area*standard_deviation*standard_deviation);\n    channel_statistics[i].standard_deviation=standard_deviation;\n  }\n  for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n  {\n    double\n      number_bins;\n\n    register ssize_t\n      j;\n\n    /*\n      Compute pixel entropy.\n    */\n    PixelChannel channel = GetPixelChannelChannel(image,i);\n    number_bins=0.0;\n    for (j=0; j <= (ssize_t) MaxMap; j++)\n      if (histogram[GetPixelChannels(image)*j+i] > 0.0)\n        number_bins++;\n    area=PerceptibleReciprocal(channel_statistics[channel].area);\n    for (j=0; j <= (ssize_t) MaxMap; j++)\n    {\n      double\n        count;\n\n      count=area*histogram[GetPixelChannels(image)*j+i];\n      channel_statistics[channel].entropy+=-count*MagickLog10(count)*\n        PerceptibleReciprocal(MagickLog10(number_bins));\n      channel_statistics[CompositePixelChannel].entropy+=-count*\n        MagickLog10(count)*PerceptibleReciprocal(MagickLog10(number_bins))/\n        GetPixelChannels(image);\n    }\n  }\n  histogram=(double *) RelinquishMagickMemory(histogram);\n  for (i=0; i <= (ssize_t) MaxPixelChannels; i++)\n  {\n    /*\n      Compute kurtosis & skewness statistics.\n    */\n    standard_deviation=PerceptibleReciprocal(\n      channel_statistics[i].standard_deviation);\n    channel_statistics[i].skewness=(channel_statistics[i].sum_cubed-3.0*\n      channel_statistics[i].mean*channel_statistics[i].sum_squared+2.0*\n      channel_statistics[i].mean*channel_statistics[i].mean*\n      channel_statistics[i].mean)*(standard_deviation*standard_deviation*\n      standard_deviation);\n    channel_statistics[i].kurtosis=(channel_statistics[i].sum_fourth_power-4.0*\n      channel_statistics[i].mean*channel_statistics[i].sum_cubed+6.0*\n      channel_statistics[i].mean*channel_statistics[i].mean*\n      channel_statistics[i].sum_squared-3.0*channel_statistics[i].mean*\n      channel_statistics[i].mean*1.0*channel_statistics[i].mean*\n      channel_statistics[i].mean)*(standard_deviation*standard_deviation*\n      standard_deviation*standard_deviation)-3.0;\n  }\n  channel_statistics[CompositePixelChannel].mean=0.0;\n  channel_statistics[CompositePixelChannel].standard_deviation=0.0;\n  channel_statistics[CompositePixelChannel].entropy=0.0;\n  for (i=0; i < (ssize_t) MaxPixelChannels; i++)\n  {\n    channel_statistics[CompositePixelChannel].mean+=\n      channel_statistics[i].mean;\n    channel_statistics[CompositePixelChannel].standard_deviation+=\n      channel_statistics[i].standard_deviation;\n    channel_statistics[CompositePixelChannel].entropy+=\n      channel_statistics[i].entropy;\n  }\n  channel_statistics[CompositePixelChannel].mean/=(double)\n    GetImageChannels(image);\n  channel_statistics[CompositePixelChannel].standard_deviation/=(double)\n    GetImageChannels(image);\n  channel_statistics[CompositePixelChannel].entropy/=(double)\n    GetImageChannels(image);\n  if (y < (ssize_t) image->rows)\n    channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n      channel_statistics);\n  return(channel_statistics);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     P o l y n o m i a l I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PolynomialImage() returns a new image where each pixel is the sum of the\n%  pixels in the image sequence after applying its corresponding terms\n%  (coefficient and degree pairs).\n%\n%  The format of the PolynomialImage method is:\n%\n%      Image *PolynomialImage(const Image *images,const size_t number_terms,\n%        const double *terms,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o images: the image sequence.\n%\n%    o number_terms: the number of terms in the list.  The actual list length\n%      is 2 x number_terms + 1 (the constant).\n%\n%    o terms: the list of polynomial coefficients and degree pairs and a\n%      constant.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *PolynomialImage(const Image *images,\n  const size_t number_terms,const double *terms,ExceptionInfo *exception)\n{\n#define PolynomialImageTag  \"Polynomial/Image\"\n\n  CacheView\n    *polynomial_view;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  PixelChannels\n    **magick_restrict polynomial_pixels;\n\n  size_t\n    number_images;\n\n  ssize_t\n    y;\n\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImageCanvas(images,exception);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  number_images=GetImageListLength(images);\n  polynomial_pixels=AcquirePixelThreadSet(images);\n  if (polynomial_pixels == (PixelChannels **) NULL)\n    {\n      image=DestroyImage(image);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",images->filename);\n      return((Image *) NULL);\n    }\n  /*\n    Polynomial image pixels.\n  */\n  status=MagickTrue;\n  progress=0;\n  polynomial_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    CacheView\n      *image_view;\n\n    const Image\n      *next;\n\n    const int\n      id = GetOpenMPThreadId();\n\n    register ssize_t\n      i,\n      x;\n\n    register PixelChannels\n      *polynomial_pixel;\n\n    register Quantum\n      *magick_restrict q;\n\n    ssize_t\n      j;\n\n    if (status == MagickFalse)\n      continue;\n    q=QueueCacheViewAuthenticPixels(polynomial_view,0,y,image->columns,1,\n      exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    polynomial_pixel=polynomial_pixels[id];\n    for (j=0; j < (ssize_t) image->columns; j++)\n      for (i=0; i < MaxPixelChannels; i++)\n        polynomial_pixel[j].channel[i]=0.0;\n    next=images;\n    for (j=0; j < (ssize_t) number_images; j++)\n    {\n      register const Quantum\n        *p;\n\n      if (j >= (ssize_t) number_terms)\n        continue;\n      image_view=AcquireVirtualCacheView(next,exception);\n      p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          image_view=DestroyCacheView(image_view);\n          break;\n        }\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        register ssize_t\n          i;\n\n        for (i=0; i < (ssize_t) GetPixelChannels(next); i++)\n        {\n          MagickRealType\n            coefficient,\n            degree;\n\n          PixelChannel channel = GetPixelChannelChannel(image,i);\n          PixelTrait traits = GetPixelChannelTraits(next,channel);\n          PixelTrait polynomial_traits=GetPixelChannelTraits(image,channel);\n          if ((traits == UndefinedPixelTrait) ||\n              (polynomial_traits == UndefinedPixelTrait))\n            continue;\n          if ((traits & UpdatePixelTrait) == 0)\n            continue;\n          coefficient=(MagickRealType) terms[2*j];\n          degree=(MagickRealType) terms[(j << 1)+1];\n          polynomial_pixel[x].channel[i]+=coefficient*\n            pow(QuantumScale*GetPixelChannel(image,channel,p),degree);\n        }\n        p+=GetPixelChannels(next);\n      }\n      image_view=DestroyCacheView(image_view);\n      next=GetNextImageInList(next);\n    }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        q[i]=ClampToQuantum(QuantumRange*polynomial_pixel[x].channel[i]);\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(polynomial_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (images->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(images,PolynomialImageTag,progress,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  polynomial_view=DestroyCacheView(polynomial_view);\n  polynomial_pixels=DestroyPixelThreadSet(polynomial_pixels);\n  if (status == MagickFalse)\n    image=DestroyImage(image);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     S t a t i s t i c I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  StatisticImage() makes each pixel the min / max / median / mode / etc. of\n%  the neighborhood of the specified width and height.\n%\n%  The format of the StatisticImage method is:\n%\n%      Image *StatisticImage(const Image *image,const StatisticType type,\n%        const size_t width,const size_t height,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o type: the statistic type (median, mode, etc.).\n%\n%    o width: the width of the pixel neighborhood.\n%\n%    o height: the height of the pixel neighborhood.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\ntypedef struct _SkipNode\n{\n  size_t\n    next[9],\n    count,\n    signature;\n} SkipNode;\n\ntypedef struct _SkipList\n{\n  ssize_t\n    level;\n\n  SkipNode\n    *nodes;\n} SkipList;\n\ntypedef struct _PixelList\n{\n  size_t\n    length,\n    seed;\n\n  SkipList\n    skip_list;\n\n  size_t\n    signature;\n} PixelList;\n\nstatic PixelList *DestroyPixelList(PixelList *pixel_list)\n{\n  if (pixel_list == (PixelList *) NULL)\n    return((PixelList *) NULL);\n  if (pixel_list->skip_list.nodes != (SkipNode *) NULL)\n    pixel_list->skip_list.nodes=(SkipNode *) RelinquishAlignedMemory(\n      pixel_list->skip_list.nodes);\n  pixel_list=(PixelList *) RelinquishMagickMemory(pixel_list);\n  return(pixel_list);\n}\n\nstatic PixelList **DestroyPixelListThreadSet(PixelList **pixel_list)\n{\n  register ssize_t\n    i;\n\n  assert(pixel_list != (PixelList **) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (pixel_list[i] != (PixelList *) NULL)\n      pixel_list[i]=DestroyPixelList(pixel_list[i]);\n  pixel_list=(PixelList **) RelinquishMagickMemory(pixel_list);\n  return(pixel_list);\n}\n\nstatic PixelList *AcquirePixelList(const size_t width,const size_t height)\n{\n  PixelList\n    *pixel_list;\n\n  pixel_list=(PixelList *) AcquireMagickMemory(sizeof(*pixel_list));\n  if (pixel_list == (PixelList *) NULL)\n    return(pixel_list);\n  (void) memset((void *) pixel_list,0,sizeof(*pixel_list));\n  pixel_list->length=width*height;\n  pixel_list->skip_list.nodes=(SkipNode *) AcquireAlignedMemory(65537UL,\n    sizeof(*pixel_list->skip_list.nodes));\n  if (pixel_list->skip_list.nodes == (SkipNode *) NULL)\n    return(DestroyPixelList(pixel_list));\n  (void) memset(pixel_list->skip_list.nodes,0,65537UL*\n    sizeof(*pixel_list->skip_list.nodes));\n  pixel_list->signature=MagickCoreSignature;\n  return(pixel_list);\n}\n\nstatic PixelList **AcquirePixelListThreadSet(const size_t width,\n  const size_t height)\n{\n  PixelList\n    **pixel_list;\n\n  register ssize_t\n    i;\n\n  size_t\n    number_threads;\n\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  pixel_list=(PixelList **) AcquireQuantumMemory(number_threads,\n    sizeof(*pixel_list));\n  if (pixel_list == (PixelList **) NULL)\n    return((PixelList **) NULL);\n  (void) memset(pixel_list,0,number_threads*sizeof(*pixel_list));\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    pixel_list[i]=AcquirePixelList(width,height);\n    if (pixel_list[i] == (PixelList *) NULL)\n      return(DestroyPixelListThreadSet(pixel_list));\n  }\n  return(pixel_list);\n}\n\nstatic void AddNodePixelList(PixelList *pixel_list,const size_t color)\n{\n  register SkipList\n    *p;\n\n  register ssize_t\n    level;\n\n  size_t\n    search,\n    update[9];\n\n  /*\n    Initialize the node.\n  */\n  p=(&pixel_list->skip_list);\n  p->nodes[color].signature=pixel_list->signature;\n  p->nodes[color].count=1;\n  /*\n    Determine where it belongs in the list.\n  */\n  search=65536UL;\n  for (level=p->level; level >= 0; level--)\n  {\n    while (p->nodes[search].next[level] < color)\n      search=p->nodes[search].next[level];\n    update[level]=search;\n  }\n  /*\n    Generate a pseudo-random level for this node.\n  */\n  for (level=0; ; level++)\n  {\n    pixel_list->seed=(pixel_list->seed*42893621L)+1L;\n    if ((pixel_list->seed & 0x300) != 0x300)\n      break;\n  }\n  if (level > 8)\n    level=8;\n  if (level > (p->level+2))\n    level=p->level+2;\n  /*\n    If we're raising the list's level, link back to the root node.\n  */\n  while (level > p->level)\n  {\n    p->level++;\n    update[p->level]=65536UL;\n  }\n  /*\n    Link the node into the skip-list.\n  */\n  do\n  {\n    p->nodes[color].next[level]=p->nodes[update[level]].next[level];\n    p->nodes[update[level]].next[level]=color;\n  } while (level-- > 0);\n}\n\nstatic inline void GetMaximumPixelList(PixelList *pixel_list,Quantum *pixel)\n{\n  register SkipList\n    *p;\n\n  size_t\n    color,\n    maximum;\n\n  ssize_t\n    count;\n\n  /*\n    Find the maximum value for each of the color.\n  */\n  p=(&pixel_list->skip_list);\n  color=65536L;\n  count=0;\n  maximum=p->nodes[color].next[0];\n  do\n  {\n    color=p->nodes[color].next[0];\n    if (color > maximum)\n      maximum=color;\n    count+=p->nodes[color].count;\n  } while (count < (ssize_t) pixel_list->length);\n  *pixel=ScaleShortToQuantum((unsigned short) maximum);\n}\n\nstatic inline void GetMeanPixelList(PixelList *pixel_list,Quantum *pixel)\n{\n  double\n    sum;\n\n  register SkipList\n    *p;\n\n  size_t\n    color;\n\n  ssize_t\n    count;\n\n  /*\n    Find the mean value for each of the color.\n  */\n  p=(&pixel_list->skip_list);\n  color=65536L;\n  count=0;\n  sum=0.0;\n  do\n  {\n    color=p->nodes[color].next[0];\n    sum+=(double) p->nodes[color].count*color;\n    count+=p->nodes[color].count;\n  } while (count < (ssize_t) pixel_list->length);\n  sum/=pixel_list->length;\n  *pixel=ScaleShortToQuantum((unsigned short) sum);\n}\n\nstatic inline void GetMedianPixelList(PixelList *pixel_list,Quantum *pixel)\n{\n  register SkipList\n    *p;\n\n  size_t\n    color;\n\n  ssize_t\n    count;\n\n  /*\n    Find the median value for each of the color.\n  */\n  p=(&pixel_list->skip_list);\n  color=65536L;\n  count=0;\n  do\n  {\n    color=p->nodes[color].next[0];\n    count+=p->nodes[color].count;\n  } while (count <= (ssize_t) (pixel_list->length >> 1));\n  *pixel=ScaleShortToQuantum((unsigned short) color);\n}\n\nstatic inline void GetMinimumPixelList(PixelList *pixel_list,Quantum *pixel)\n{\n  register SkipList\n    *p;\n\n  size_t\n    color,\n    minimum;\n\n  ssize_t\n    count;\n\n  /*\n    Find the minimum value for each of the color.\n  */\n  p=(&pixel_list->skip_list);\n  count=0;\n  color=65536UL;\n  minimum=p->nodes[color].next[0];\n  do\n  {\n    color=p->nodes[color].next[0];\n    if (color < minimum)\n      minimum=color;\n    count+=p->nodes[color].count;\n  } while (count < (ssize_t) pixel_list->length);\n  *pixel=ScaleShortToQuantum((unsigned short) minimum);\n}\n\nstatic inline void GetModePixelList(PixelList *pixel_list,Quantum *pixel)\n{\n  register SkipList\n    *p;\n\n  size_t\n    color,\n    max_count,\n    mode;\n\n  ssize_t\n    count;\n\n  /*\n    Make each pixel the 'predominant color' of the specified neighborhood.\n  */\n  p=(&pixel_list->skip_list);\n  color=65536L;\n  mode=color;\n  max_count=p->nodes[mode].count;\n  count=0;\n  do\n  {\n    color=p->nodes[color].next[0];\n    if (p->nodes[color].count > max_count)\n      {\n        mode=color;\n        max_count=p->nodes[mode].count;\n      }\n    count+=p->nodes[color].count;\n  } while (count < (ssize_t) pixel_list->length);\n  *pixel=ScaleShortToQuantum((unsigned short) mode);\n}\n\nstatic inline void GetNonpeakPixelList(PixelList *pixel_list,Quantum *pixel)\n{\n  register SkipList\n    *p;\n\n  size_t\n    color,\n    next,\n    previous;\n\n  ssize_t\n    count;\n\n  /*\n    Finds the non peak value for each of the colors.\n  */\n  p=(&pixel_list->skip_list);\n  color=65536L;\n  next=p->nodes[color].next[0];\n  count=0;\n  do\n  {\n    previous=color;\n    color=next;\n    next=p->nodes[color].next[0];\n    count+=p->nodes[color].count;\n  } while (count <= (ssize_t) (pixel_list->length >> 1));\n  if ((previous == 65536UL) && (next != 65536UL))\n    color=next;\n  else\n    if ((previous != 65536UL) && (next == 65536UL))\n      color=previous;\n  *pixel=ScaleShortToQuantum((unsigned short) color);\n}\n\nstatic inline void GetRootMeanSquarePixelList(PixelList *pixel_list,\n  Quantum *pixel)\n{\n  double\n    sum;\n\n  register SkipList\n    *p;\n\n  size_t\n    color;\n\n  ssize_t\n    count;\n\n  /*\n    Find the root mean square value for each of the color.\n  */\n  p=(&pixel_list->skip_list);\n  color=65536L;\n  count=0;\n  sum=0.0;\n  do\n  {\n    color=p->nodes[color].next[0];\n    sum+=(double) (p->nodes[color].count*color*color);\n    count+=p->nodes[color].count;\n  } while (count < (ssize_t) pixel_list->length);\n  sum/=pixel_list->length;\n  *pixel=ScaleShortToQuantum((unsigned short) sqrt(sum));\n}\n\nstatic inline void GetStandardDeviationPixelList(PixelList *pixel_list,\n  Quantum *pixel)\n{\n  double\n    sum,\n    sum_squared;\n\n  register SkipList\n    *p;\n\n  size_t\n    color;\n\n  ssize_t\n    count;\n\n  /*\n    Find the standard-deviation value for each of the color.\n  */\n  p=(&pixel_list->skip_list);\n  color=65536L;\n  count=0;\n  sum=0.0;\n  sum_squared=0.0;\n  do\n  {\n    register ssize_t\n      i;\n\n    color=p->nodes[color].next[0];\n    sum+=(double) p->nodes[color].count*color;\n    for (i=0; i < (ssize_t) p->nodes[color].count; i++)\n      sum_squared+=((double) color)*((double) color);\n    count+=p->nodes[color].count;\n  } while (count < (ssize_t) pixel_list->length);\n  sum/=pixel_list->length;\n  sum_squared/=pixel_list->length;\n  *pixel=ScaleShortToQuantum((unsigned short) sqrt(sum_squared-(sum*sum)));\n}\n\nstatic inline void InsertPixelList(const Quantum pixel,PixelList *pixel_list)\n{\n  size_t\n    signature;\n\n  unsigned short\n    index;\n\n  index=ScaleQuantumToShort(pixel);\n  signature=pixel_list->skip_list.nodes[index].signature;\n  if (signature == pixel_list->signature)\n    {\n      pixel_list->skip_list.nodes[index].count++;\n      return;\n    }\n  AddNodePixelList(pixel_list,index);\n}\n\nstatic void ResetPixelList(PixelList *pixel_list)\n{\n  int\n    level;\n\n  register SkipNode\n    *root;\n\n  register SkipList\n    *p;\n\n  /*\n    Reset the skip-list.\n  */\n  p=(&pixel_list->skip_list);\n  root=p->nodes+65536UL;\n  p->level=0;\n  for (level=0; level < 9; level++)\n    root->next[level]=65536UL;\n  pixel_list->seed=pixel_list->signature++;\n}\n\nMagickExport Image *StatisticImage(const Image *image,const StatisticType type,\n  const size_t width,const size_t height,ExceptionInfo *exception)\n{\n#define StatisticImageTag  \"Statistic/Image\"\n\n  CacheView\n    *image_view,\n    *statistic_view;\n\n  Image\n    *statistic_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  PixelList\n    **magick_restrict pixel_list;\n\n  ssize_t\n    center,\n    y;\n\n  /*\n    Initialize statistics image attributes.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  statistic_image=CloneImage(image,0,0,MagickTrue,\n    exception);\n  if (statistic_image == (Image *) NULL)\n    return((Image *) NULL);\n  status=SetImageStorageClass(statistic_image,DirectClass,exception);\n  if (status == MagickFalse)\n    {\n      statistic_image=DestroyImage(statistic_image);\n      return((Image *) NULL);\n    }\n  pixel_list=AcquirePixelListThreadSet(MagickMax(width,1),MagickMax(height,1));\n  if (pixel_list == (PixelList **) NULL)\n    {\n      statistic_image=DestroyImage(statistic_image);\n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  /*\n    Make each pixel the min / max / median / mode / etc. of the neighborhood.\n  */\n  center=(ssize_t) GetPixelChannels(image)*(image->columns+MagickMax(width,1))*\n    (MagickMax(height,1)/2L)+GetPixelChannels(image)*(MagickMax(width,1)/2L);\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  statistic_view=AcquireAuthenticCacheView(statistic_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,statistic_image,statistic_image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) statistic_image->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    register const Quantum\n      *magick_restrict p;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,-((ssize_t) MagickMax(width,1)/2L),y-\n      (ssize_t) (MagickMax(height,1)/2L),image->columns+MagickMax(width,1),\n      MagickMax(height,1),exception);\n    q=QueueCacheViewAuthenticPixels(statistic_view,0,y,statistic_image->columns,      1,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) statistic_image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        Quantum\n          pixel;\n\n        register const Quantum\n          *magick_restrict pixels;\n\n        register ssize_t\n          u;\n\n        ssize_t\n          v;\n\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        PixelTrait statistic_traits=GetPixelChannelTraits(statistic_image,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (statistic_traits == UndefinedPixelTrait))\n          continue;\n        if (((statistic_traits & CopyPixelTrait) != 0) ||\n            (GetPixelWriteMask(image,p) <= (QuantumRange/2)))\n          {\n            SetPixelChannel(statistic_image,channel,p[center+i],q);\n            continue;\n          }\n        if ((statistic_traits & UpdatePixelTrait) == 0)\n          continue;\n        pixels=p;\n        ResetPixelList(pixel_list[id]);\n        for (v=0; v < (ssize_t) MagickMax(height,1); v++)\n        {\n          for (u=0; u < (ssize_t) MagickMax(width,1); u++)\n          {\n            InsertPixelList(pixels[i],pixel_list[id]);\n            pixels+=GetPixelChannels(image);\n          }\n          pixels+=GetPixelChannels(image)*image->columns;\n        }\n        switch (type)\n        {\n          case GradientStatistic:\n          {\n            double\n              maximum,\n              minimum;\n\n            GetMinimumPixelList(pixel_list[id],&pixel);\n            minimum=(double) pixel;\n            GetMaximumPixelList(pixel_list[id],&pixel);\n            maximum=(double) pixel;\n            pixel=ClampToQuantum(MagickAbsoluteValue(maximum-minimum));\n            break;\n          }\n          case MaximumStatistic:\n          {\n            GetMaximumPixelList(pixel_list[id],&pixel);\n            break;\n          }\n          case MeanStatistic:\n          {\n            GetMeanPixelList(pixel_list[id],&pixel);\n            break;\n          }\n          case MedianStatistic:\n          default:\n          {\n            GetMedianPixelList(pixel_list[id],&pixel);\n            break;\n          }\n          case MinimumStatistic:\n          {\n            GetMinimumPixelList(pixel_list[id],&pixel);\n            break;\n          }\n          case ModeStatistic:\n          {\n            GetModePixelList(pixel_list[id],&pixel);\n            break;\n          }\n          case NonpeakStatistic:\n          {\n            GetNonpeakPixelList(pixel_list[id],&pixel);\n            break;\n          }\n          case RootMeanSquareStatistic:\n          {\n            GetRootMeanSquarePixelList(pixel_list[id],&pixel);\n            break;\n          }\n          case StandardDeviationStatistic:\n          {\n            GetStandardDeviationPixelList(pixel_list[id],&pixel);\n            break;\n          }\n        }\n        SetPixelChannel(statistic_image,channel,pixel,q);\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(statistic_image);\n    }\n    if (SyncCacheViewAuthenticPixels(statistic_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,StatisticImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  statistic_view=DestroyCacheView(statistic_view);\n  image_view=DestroyCacheView(image_view);\n  pixel_list=DestroyPixelListThreadSet(pixel_list);\n  if (status == MagickFalse)\n    statistic_image=DestroyImage(statistic_image);\n  return(statistic_image);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%        SSSSS  TTTTT   AAA   TTTTT  IIIII  SSSSS  TTTTT  IIIII   CCCC        %\n%        SS       T    A   A    T      I    SS       T      I    C            %\n%         SSS     T    AAAAA    T      I     SSS     T      I    C            %\n%           SS    T    A   A    T      I       SS    T      I    C            %\n%        SSSSS    T    A   A    T    IIIII  SSSSS    T    IIIII   CCCC        %\n%                                                                             %\n%                                                                             %\n%                     MagickCore Image Statistical Methods                    %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/accelerate-private.h\"\n#include \"MagickCore/animate.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/compress.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/display.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/gem-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/magic.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/paint.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/random_.h\"\n#include \"MagickCore/random-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/segment.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/signature-private.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/timer.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/version.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     E v a l u a t e I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  EvaluateImage() applies a value to the image with an arithmetic, relational,\n%  or logical operator to an image. Use these operations to lighten or darken\n%  an image, to increase or decrease contrast in an image, or to produce the\n%  \"negative\" of an image.\n%\n%  The format of the EvaluateImage method is:\n%\n%      MagickBooleanType EvaluateImage(Image *image,\n%        const MagickEvaluateOperator op,const double value,\n%        ExceptionInfo *exception)\n%      MagickBooleanType EvaluateImages(Image *images,\n%        const MagickEvaluateOperator op,const double value,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o op: A channel op.\n%\n%    o value: A value value.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\ntypedef struct _PixelChannels\n{\n  double\n    channel[CompositePixelChannel];\n} PixelChannels;\n\nstatic PixelChannels **DestroyPixelThreadSet(PixelChannels **pixels)\n{\n  register ssize_t\n    i;\n\n  assert(pixels != (PixelChannels **) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (pixels[i] != (PixelChannels *) NULL)\n      pixels[i]=(PixelChannels *) RelinquishMagickMemory(pixels[i]);\n  pixels=(PixelChannels **) RelinquishMagickMemory(pixels);\n  return(pixels);\n}\n\nstatic PixelChannels **AcquirePixelThreadSet(const Image *images)\n{\n  const Image\n    *next;\n\n  PixelChannels\n    **pixels;\n\n  register ssize_t\n    i;\n\n  size_t\n    columns,\n    number_threads;\n\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  pixels=(PixelChannels **) AcquireQuantumMemory(number_threads,\n    sizeof(*pixels));\n  if (pixels == (PixelChannels **) NULL)\n    return((PixelChannels **) NULL);\n  (void) memset(pixels,0,number_threads*sizeof(*pixels));\n  columns=images->columns;\n  for (next=images; next != (Image *) NULL; next=next->next)\n    columns=MagickMax(next->columns,columns);\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    register ssize_t\n      j;\n\n    pixels[i]=(PixelChannels *) AcquireQuantumMemory(columns,sizeof(**pixels));\n    if (pixels[i] == (PixelChannels *) NULL)\n      return(DestroyPixelThreadSet(pixels));\n    for (j=0; j < (ssize_t) columns; j++)\n    {\n      register ssize_t\n        k;\n\n      for (k=0; k < MaxPixelChannels; k++)\n        pixels[i][j].channel[k]=0.0;\n    }\n  }\n  return(pixels);\n}\n\nstatic inline double EvaluateMax(const double x,const double y)\n{\n  if (x > y)\n    return(x);\n  return(y);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int IntensityCompare(const void *x,const void *y)\n{\n  const PixelChannels\n    *color_1,\n    *color_2;\n\n  double\n    distance;\n\n  register ssize_t\n    i;\n\n  color_1=(const PixelChannels *) x;\n  color_2=(const PixelChannels *) y;\n  distance=0.0;\n  for (i=0; i < MaxPixelChannels; i++)\n    distance+=color_1->channel[i]-(double) color_2->channel[i];\n  return(distance < 0 ? -1 : distance > 0 ? 1 : 0);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic double ApplyEvaluateOperator(RandomInfo *random_info,const Quantum pixel,\n  const MagickEvaluateOperator op,const double value)\n{\n  double\n    result;\n\n  result=0.0;\n  switch (op)\n  {\n    case UndefinedEvaluateOperator:\n      break;\n    case AbsEvaluateOperator:\n    {\n      result=(double) fabs((double) (pixel+value));\n      break;\n    }\n    case AddEvaluateOperator:\n    {\n      result=(double) (pixel+value);\n      break;\n    }\n    case AddModulusEvaluateOperator:\n    {\n      /*\n        This returns a 'floored modulus' of the addition which is a positive\n        result.  It differs from % or fmod() that returns a 'truncated modulus'\n        result, where floor() is replaced by trunc() and could return a\n        negative result (which is clipped).\n      */\n      result=pixel+value;\n      result-=(QuantumRange+1.0)*floor((double) result/(QuantumRange+1.0));\n      break;\n    }\n    case AndEvaluateOperator:\n    {\n      result=(double) ((size_t) pixel & (size_t) (value+0.5));\n      break;\n    }\n    case CosineEvaluateOperator:\n    {\n      result=(double) (QuantumRange*(0.5*cos((double) (2.0*MagickPI*\n        QuantumScale*pixel*value))+0.5));\n      break;\n    }\n    case DivideEvaluateOperator:\n    {\n      result=pixel/(value == 0.0 ? 1.0 : value);\n      break;\n    }\n    case ExponentialEvaluateOperator:\n    {\n      result=(double) (QuantumRange*exp((double) (value*QuantumScale*pixel)));\n      break;\n    }\n    case GaussianNoiseEvaluateOperator:\n    {\n      result=(double) GenerateDifferentialNoise(random_info,pixel,\n        GaussianNoise,value);\n      break;\n    }\n    case ImpulseNoiseEvaluateOperator:\n    {\n      result=(double) GenerateDifferentialNoise(random_info,pixel,ImpulseNoise,\n        value);\n      break;\n    }\n    case LaplacianNoiseEvaluateOperator:\n    {\n      result=(double) GenerateDifferentialNoise(random_info,pixel,\n        LaplacianNoise,value);\n      break;\n    }\n    case LeftShiftEvaluateOperator:\n    {\n      result=(double) ((size_t) pixel << (size_t) (value+0.5));\n      break;\n    }\n    case LogEvaluateOperator:\n    {\n      if ((QuantumScale*pixel) >= MagickEpsilon)\n        result=(double) (QuantumRange*log((double) (QuantumScale*value*pixel+\n          1.0))/log((double) (value+1.0)));\n      break;\n    }\n    case MaxEvaluateOperator:\n    {\n      result=(double) EvaluateMax((double) pixel,value);\n      break;\n    }\n    case MeanEvaluateOperator:\n    {\n      result=(double) (pixel+value);\n      break;\n    }\n    case MedianEvaluateOperator:\n    {\n      result=(double) (pixel+value);\n      break;\n    }\n    case MinEvaluateOperator:\n    {\n      result=(double) MagickMin((double) pixel,value);\n      break;\n    }\n    case MultiplicativeNoiseEvaluateOperator:\n    {\n      result=(double) GenerateDifferentialNoise(random_info,pixel,\n        MultiplicativeGaussianNoise,value);\n      break;\n    }\n    case MultiplyEvaluateOperator:\n    {\n      result=(double) (value*pixel);\n      break;\n    }\n    case OrEvaluateOperator:\n    {\n      result=(double) ((size_t) pixel | (size_t) (value+0.5));\n      break;\n    }\n    case PoissonNoiseEvaluateOperator:\n    {\n      result=(double) GenerateDifferentialNoise(random_info,pixel,PoissonNoise,\n        value);\n      break;\n    }\n    case PowEvaluateOperator:\n    {\n      result=(double) (QuantumRange*pow((double) (QuantumScale*pixel),(double)\n        value));\n      break;\n    }\n    case RightShiftEvaluateOperator:\n    {\n      result=(double) ((size_t) pixel >> (size_t) (value+0.5));\n      break;\n    }\n    case RootMeanSquareEvaluateOperator:\n    {\n      result=(double) (pixel*pixel+value);\n      break;\n    }\n    case SetEvaluateOperator:\n    {\n      result=value;\n      break;\n    }\n    case SineEvaluateOperator:\n    {\n      result=(double) (QuantumRange*(0.5*sin((double) (2.0*MagickPI*\n        QuantumScale*pixel*value))+0.5));\n      break;\n    }\n    case SubtractEvaluateOperator:\n    {\n      result=(double) (pixel-value);\n      break;\n    }\n    case SumEvaluateOperator:\n    {\n      result=(double) (pixel+value);\n      break;\n    }\n    case ThresholdEvaluateOperator:\n    {\n      result=(double) (((double) pixel <= value) ? 0 : QuantumRange);\n      break;\n    }\n    case ThresholdBlackEvaluateOperator:\n    {\n      result=(double) (((double) pixel <= value) ? 0 : pixel);\n      break;\n    }\n    case ThresholdWhiteEvaluateOperator:\n    {\n      result=(double) (((double) pixel > value) ? QuantumRange : pixel);\n      break;\n    }\n    case UniformNoiseEvaluateOperator:\n    {\n      result=(double) GenerateDifferentialNoise(random_info,pixel,UniformNoise,\n        value);\n      break;\n    }\n    case XorEvaluateOperator:\n    {\n      result=(double) ((size_t) pixel ^ (size_t) (value+0.5));\n      break;\n    }\n  }\n  return(result);\n}\n\nstatic Image *AcquireImageCanvas(const Image *images,ExceptionInfo *exception)\n{\n  const Image\n    *p,\n    *q;\n\n  size_t\n    columns,\n    rows;\n\n  q=images;\n  columns=images->columns;\n  rows=images->rows;\n  for (p=images; p != (Image *) NULL; p=p->next)\n  {\n    if (p->number_channels > q->number_channels)\n      q=p;\n    if (p->columns > columns)\n      columns=p->columns;\n    if (p->rows > rows)\n      rows=p->rows;\n  }\n  return(CloneImage(q,columns,rows,MagickTrue,exception));\n}\n\nMagickExport Image *EvaluateImages(const Image *images,\n  const MagickEvaluateOperator op,ExceptionInfo *exception)\n{\n#define EvaluateImageTag  \"Evaluate/Image\"\n\n  CacheView\n    *evaluate_view;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  PixelChannels\n    **magick_restrict evaluate_pixels;\n\n  RandomInfo\n    **magick_restrict random_info;\n\n  size_t\n    number_images;\n\n  ssize_t\n    y;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  unsigned long\n    key;\n#endif\n\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImageCanvas(images,exception);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  number_images=GetImageListLength(images);\n  evaluate_pixels=AcquirePixelThreadSet(images);\n  if (evaluate_pixels == (PixelChannels **) NULL)\n    {\n      image=DestroyImage(image);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",images->filename);\n      return((Image *) NULL);\n    }\n  /*\n    Evaluate image pixels.\n  */\n  status=MagickTrue;\n  progress=0;\n  random_info=AcquireRandomInfoThreadSet();\n  evaluate_view=AcquireAuthenticCacheView(image,exception);\n  if (op == MedianEvaluateOperator)\n    {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      key=GetRandomSecretKey(random_info[0]);\n      #pragma omp parallel for schedule(static) shared(progress,status) \\\n        magick_number_threads(image,images,image->rows,key == ~0UL)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        CacheView\n          *image_view;\n\n        const Image\n          *next;\n\n        const int\n          id = GetOpenMPThreadId();\n\n        register PixelChannels\n          *evaluate_pixel;\n\n        register Quantum\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        q=QueueCacheViewAuthenticPixels(evaluate_view,0,y,image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        evaluate_pixel=evaluate_pixels[id];\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          register ssize_t\n            j,\n            k;\n\n          for (j=0; j < (ssize_t) number_images; j++)\n            for (k=0; k < MaxPixelChannels; k++)\n              evaluate_pixel[j].channel[k]=0.0;\n          next=images;\n          for (j=0; j < (ssize_t) number_images; j++)\n          {\n            register const Quantum\n              *p;\n\n            register ssize_t\n              i;\n\n            image_view=AcquireVirtualCacheView(next,exception);\n            p=GetCacheViewVirtualPixels(image_view,x,y,1,1,exception);\n            if (p == (const Quantum *) NULL)\n              {\n                image_view=DestroyCacheView(image_view);\n                break;\n              }\n            for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n            {\n              PixelChannel channel = GetPixelChannelChannel(image,i);\n              PixelTrait evaluate_traits=GetPixelChannelTraits(image,channel);\n              PixelTrait traits = GetPixelChannelTraits(next,channel);\n              if ((traits == UndefinedPixelTrait) ||\n                  (evaluate_traits == UndefinedPixelTrait))\n                continue;\n              if ((traits & UpdatePixelTrait) == 0)\n                continue;\n              evaluate_pixel[j].channel[i]=ApplyEvaluateOperator(\n                random_info[id],GetPixelChannel(image,channel,p),op,\n                evaluate_pixel[j].channel[i]);\n            }\n            image_view=DestroyCacheView(image_view);\n            next=GetNextImageInList(next);\n          }\n          qsort((void *) evaluate_pixel,number_images,sizeof(*evaluate_pixel),\n            IntensityCompare);\n          for (k=0; k < (ssize_t) GetPixelChannels(image); k++)\n            q[k]=ClampToQuantum(evaluate_pixel[j/2].channel[k]);\n          q+=GetPixelChannels(image);\n        }\n        if (SyncCacheViewAuthenticPixels(evaluate_view,exception) == MagickFalse)\n          status=MagickFalse;\n        if (images->progress_monitor != (MagickProgressMonitor) NULL)\n          {\n            MagickBooleanType\n              proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n            #pragma omp atomic\n#endif\n            progress++;\n            proceed=SetImageProgress(images,EvaluateImageTag,progress,\n              image->rows);\n            if (proceed == MagickFalse)\n              status=MagickFalse;\n          }\n      }\n    }\n  else\n    {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      key=GetRandomSecretKey(random_info[0]);\n      #pragma omp parallel for schedule(static) shared(progress,status) \\\n        magick_number_threads(image,images,image->rows,key == ~0UL)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        CacheView\n          *image_view;\n\n        const Image\n          *next;\n\n        const int\n          id = GetOpenMPThreadId();\n\n        register ssize_t\n          i,\n          x;\n\n        register PixelChannels\n          *evaluate_pixel;\n\n        register Quantum\n          *magick_restrict q;\n\n        ssize_t\n          j;\n\n        if (status == MagickFalse)\n          continue;\n        q=QueueCacheViewAuthenticPixels(evaluate_view,0,y,image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        evaluate_pixel=evaluate_pixels[id];\n        for (j=0; j < (ssize_t) image->columns; j++)\n          for (i=0; i < MaxPixelChannels; i++)\n            evaluate_pixel[j].channel[i]=0.0;\n        next=images;\n        for (j=0; j < (ssize_t) number_images; j++)\n        {\n          register const Quantum\n            *p;\n\n          image_view=AcquireVirtualCacheView(next,exception);\n          p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,\n            exception);\n          if (p == (const Quantum *) NULL)\n            {\n              image_view=DestroyCacheView(image_view);\n              break;\n            }\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            register ssize_t\n              i;\n\n            for (i=0; i < (ssize_t) GetPixelChannels(next); i++)\n            {\n              PixelChannel channel = GetPixelChannelChannel(image,i);\n              PixelTrait traits = GetPixelChannelTraits(next,channel);\n              PixelTrait evaluate_traits=GetPixelChannelTraits(image,channel);\n              if ((traits == UndefinedPixelTrait) ||\n                  (evaluate_traits == UndefinedPixelTrait))\n                continue;\n              if ((traits & UpdatePixelTrait) == 0)\n                continue;\n              evaluate_pixel[x].channel[i]=ApplyEvaluateOperator(\n                random_info[id],GetPixelChannel(image,channel,p),j == 0 ?\n                AddEvaluateOperator : op,evaluate_pixel[x].channel[i]);\n            }\n            p+=GetPixelChannels(next);\n          }\n          image_view=DestroyCacheView(image_view);\n          next=GetNextImageInList(next);\n        }\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          register ssize_t\n             i;\n\n          switch (op)\n          {\n            case MeanEvaluateOperator:\n            {\n              for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n                evaluate_pixel[x].channel[i]/=(double) number_images;\n              break;\n            }\n            case MultiplyEvaluateOperator:\n            {\n              for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n              {\n                register ssize_t\n                  j;\n\n                for (j=0; j < (ssize_t) (number_images-1); j++)\n                  evaluate_pixel[x].channel[i]*=QuantumScale;\n              }\n              break;\n            }\n            case RootMeanSquareEvaluateOperator:\n            {\n              for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n                evaluate_pixel[x].channel[i]=sqrt(evaluate_pixel[x].channel[i]/\n                  number_images);\n              break;\n            }\n            default:\n              break;\n          }\n        }\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          register ssize_t\n            i;\n\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel = GetPixelChannelChannel(image,i);\n            PixelTrait traits = GetPixelChannelTraits(image,channel);\n            if (traits == UndefinedPixelTrait)\n              continue;\n            if ((traits & UpdatePixelTrait) == 0)\n              continue;\n            q[i]=ClampToQuantum(evaluate_pixel[x].channel[i]);\n          }\n          q+=GetPixelChannels(image);\n        }\n        if (SyncCacheViewAuthenticPixels(evaluate_view,exception) == MagickFalse)\n          status=MagickFalse;\n        if (images->progress_monitor != (MagickProgressMonitor) NULL)\n          {\n            MagickBooleanType\n              proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n            #pragma omp atomic\n#endif\n            progress++;\n            proceed=SetImageProgress(images,EvaluateImageTag,progress,\n              image->rows);\n            if (proceed == MagickFalse)\n              status=MagickFalse;\n          }\n      }\n    }\n  evaluate_view=DestroyCacheView(evaluate_view);\n  evaluate_pixels=DestroyPixelThreadSet(evaluate_pixels);\n  random_info=DestroyRandomInfoThreadSet(random_info);\n  if (status == MagickFalse)\n    image=DestroyImage(image);\n  return(image);\n}\n\nMagickExport MagickBooleanType EvaluateImage(Image *image,\n  const MagickEvaluateOperator op,const double value,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  RandomInfo\n    **magick_restrict random_info;\n\n  ssize_t\n    y;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  unsigned long\n    key;\n#endif\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  status=MagickTrue;\n  progress=0;\n  random_info=AcquireRandomInfoThreadSet();\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  key=GetRandomSecretKey(random_info[0]);\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,key == ~0UL)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        result;\n\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        if ((traits & CopyPixelTrait) != 0)\n          continue;\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        result=ApplyEvaluateOperator(random_info[id],q[i],op,value);\n        if (op == MeanEvaluateOperator)\n          result/=2.0;\n        q[i]=ClampToQuantum(result);\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,EvaluateImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  random_info=DestroyRandomInfoThreadSet(random_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     F u n c t i o n I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FunctionImage() applies a value to the image with an arithmetic, relational,\n%  or logical operator to an image. Use these operations to lighten or darken\n%  an image, to increase or decrease contrast in an image, or to produce the\n%  \"negative\" of an image.\n%\n%  The format of the FunctionImage method is:\n%\n%      MagickBooleanType FunctionImage(Image *image,\n%        const MagickFunction function,const ssize_t number_parameters,\n%        const double *parameters,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o function: A channel function.\n%\n%    o parameters: one or more parameters.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic Quantum ApplyFunction(Quantum pixel,const MagickFunction function,\n  const size_t number_parameters,const double *parameters,\n  ExceptionInfo *exception)\n{\n  double\n    result;\n\n  register ssize_t\n    i;\n\n  (void) exception;\n  result=0.0;\n  switch (function)\n  {\n    case PolynomialFunction:\n    {\n      /*\n        Polynomial: polynomial constants, highest to lowest order (e.g. c0*x^3+\n        c1*x^2+c2*x+c3).\n      */\n      result=0.0;\n      for (i=0; i < (ssize_t) number_parameters; i++)\n        result=result*QuantumScale*pixel+parameters[i];\n      result*=QuantumRange;\n      break;\n    }\n    case SinusoidFunction:\n    {\n      double\n        amplitude,\n        bias,\n        frequency,\n        phase;\n\n      /*\n        Sinusoid: frequency, phase, amplitude, bias.\n      */\n      frequency=(number_parameters >= 1) ? parameters[0] : 1.0;\n      phase=(number_parameters >= 2) ? parameters[1] : 0.0;\n      amplitude=(number_parameters >= 3) ? parameters[2] : 0.5;\n      bias=(number_parameters >= 4) ? parameters[3] : 0.5;\n      result=(double) (QuantumRange*(amplitude*sin((double) (2.0*\n        MagickPI*(frequency*QuantumScale*pixel+phase/360.0)))+bias));\n      break;\n    }\n    case ArcsinFunction:\n    {\n      double\n        bias,\n        center,\n        range,\n        width;\n\n      /*\n        Arcsin (peged at range limits for invalid results): width, center,\n        range, and bias.\n      */\n      width=(number_parameters >= 1) ? parameters[0] : 1.0;\n      center=(number_parameters >= 2) ? parameters[1] : 0.5;\n      range=(number_parameters >= 3) ? parameters[2] : 1.0;\n      bias=(number_parameters >= 4) ? parameters[3] : 0.5;\n      result=2.0/width*(QuantumScale*pixel-center);\n      if ( result <= -1.0 )\n        result=bias-range/2.0;\n      else\n        if (result >= 1.0)\n          result=bias+range/2.0;\n        else\n          result=(double) (range/MagickPI*asin((double) result)+bias);\n      result*=QuantumRange;\n      break;\n    }\n    case ArctanFunction:\n    {\n      double\n        center,\n        bias,\n        range,\n        slope;\n\n      /*\n        Arctan: slope, center, range, and bias.\n      */\n      slope=(number_parameters >= 1) ? parameters[0] : 1.0;\n      center=(number_parameters >= 2) ? parameters[1] : 0.5;\n      range=(number_parameters >= 3) ? parameters[2] : 1.0;\n      bias=(number_parameters >= 4) ? parameters[3] : 0.5;\n      result=(double) (MagickPI*slope*(QuantumScale*pixel-center));\n      result=(double) (QuantumRange*(range/MagickPI*atan((double)\n        result)+bias));\n      break;\n    }\n    case UndefinedFunction:\n      break;\n  }\n  return(ClampToQuantum(result));\n}\n\nMagickExport MagickBooleanType FunctionImage(Image *image,\n  const MagickFunction function,const size_t number_parameters,\n  const double *parameters,ExceptionInfo *exception)\n{\n#define FunctionImageTag  \"Function/Image \"\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n#if defined(MAGICKCORE_OPENCL_SUPPORT)\n  if (AccelerateFunctionImage(image,function,number_parameters,parameters,\n        exception) != MagickFalse)\n    return(MagickTrue);\n#endif\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        q[i]=ApplyFunction(q[i],function,number_parameters,parameters,\n          exception);\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,FunctionImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e E n t r o p y                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageEntropy() returns the entropy of one or more image channels.\n%\n%  The format of the GetImageEntropy method is:\n%\n%      MagickBooleanType GetImageEntropy(const Image *image,double *entropy,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o entropy: the average entropy of the selected channels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetImageEntropy(const Image *image,\n  double *entropy,ExceptionInfo *exception)\n{\n  ChannelStatistics\n    *channel_statistics;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  channel_statistics=GetImageStatistics(image,exception);\n  if (channel_statistics == (ChannelStatistics *) NULL)\n    return(MagickFalse);\n  *entropy=channel_statistics[CompositePixelChannel].entropy;\n  channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n    channel_statistics);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e E x t r e m a                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageExtrema() returns the extrema of one or more image channels.\n%\n%  The format of the GetImageExtrema method is:\n%\n%      MagickBooleanType GetImageExtrema(const Image *image,size_t *minima,\n%        size_t *maxima,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o minima: the minimum value in the channel.\n%\n%    o maxima: the maximum value in the channel.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetImageExtrema(const Image *image,\n  size_t *minima,size_t *maxima,ExceptionInfo *exception)\n{\n  double\n    max,\n    min;\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=GetImageRange(image,&min,&max,exception);\n  *minima=(size_t) ceil(min-0.5);\n  *maxima=(size_t) floor(max+0.5);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e K u r t o s i s                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageKurtosis() returns the kurtosis and skewness of one or more image\n%  channels.\n%\n%  The format of the GetImageKurtosis method is:\n%\n%      MagickBooleanType GetImageKurtosis(const Image *image,double *kurtosis,\n%        double *skewness,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o kurtosis: the kurtosis of the channel.\n%\n%    o skewness: the skewness of the channel.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetImageKurtosis(const Image *image,\n  double *kurtosis,double *skewness,ExceptionInfo *exception)\n{\n  ChannelStatistics\n    *channel_statistics;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  channel_statistics=GetImageStatistics(image,exception);\n  if (channel_statistics == (ChannelStatistics *) NULL)\n    return(MagickFalse);\n  *kurtosis=channel_statistics[CompositePixelChannel].kurtosis;\n  *skewness=channel_statistics[CompositePixelChannel].skewness;\n  channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n    channel_statistics);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e M e a n                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageMean() returns the mean and standard deviation of one or more image\n%  channels.\n%\n%  The format of the GetImageMean method is:\n%\n%      MagickBooleanType GetImageMean(const Image *image,double *mean,\n%        double *standard_deviation,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o mean: the average value in the channel.\n%\n%    o standard_deviation: the standard deviation of the channel.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetImageMean(const Image *image,double *mean,\n  double *standard_deviation,ExceptionInfo *exception)\n{\n  ChannelStatistics\n    *channel_statistics;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  channel_statistics=GetImageStatistics(image,exception);\n  if (channel_statistics == (ChannelStatistics *) NULL)\n    return(MagickFalse);\n  *mean=channel_statistics[CompositePixelChannel].mean;\n  *standard_deviation=\n    channel_statistics[CompositePixelChannel].standard_deviation;\n  channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n    channel_statistics);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e M o m e n t s                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageMoments() returns the normalized moments of one or more image\n%  channels.\n%\n%  The format of the GetImageMoments method is:\n%\n%      ChannelMoments *GetImageMoments(const Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic size_t GetImageChannels(const Image *image)\n{\n  register ssize_t\n    i;\n\n  size_t\n    channels;\n\n  channels=0;\n  for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n  {\n    PixelChannel channel = GetPixelChannelChannel(image,i);\n    PixelTrait traits = GetPixelChannelTraits(image,channel);\n    if (traits == UndefinedPixelTrait)\n      continue;\n    if ((traits & UpdatePixelTrait) == 0)\n      continue;\n    channels++;\n  }\n  return((size_t) (channels == 0 ? 1 : channels));\n}\n\nMagickExport ChannelMoments *GetImageMoments(const Image *image,\n  ExceptionInfo *exception)\n{\n#define MaxNumberImageMoments  8\n\n  CacheView\n    *image_view;\n\n  ChannelMoments\n    *channel_moments;\n\n  double\n    M00[MaxPixelChannels+1],\n    M01[MaxPixelChannels+1],\n    M02[MaxPixelChannels+1],\n    M03[MaxPixelChannels+1],\n    M10[MaxPixelChannels+1],\n    M11[MaxPixelChannels+1],\n    M12[MaxPixelChannels+1],\n    M20[MaxPixelChannels+1],\n    M21[MaxPixelChannels+1],\n    M22[MaxPixelChannels+1],\n    M30[MaxPixelChannels+1];\n\n  PointInfo\n    centroid[MaxPixelChannels+1];\n\n  ssize_t\n    channel,\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  channel_moments=(ChannelMoments *) AcquireQuantumMemory(MaxPixelChannels+1,\n    sizeof(*channel_moments));\n  if (channel_moments == (ChannelMoments *) NULL)\n    return(channel_moments);\n  (void) memset(channel_moments,0,(MaxPixelChannels+1)*\n    sizeof(*channel_moments));\n  (void) memset(centroid,0,sizeof(centroid));\n  (void) memset(M00,0,sizeof(M00));\n  (void) memset(M01,0,sizeof(M01));\n  (void) memset(M02,0,sizeof(M02));\n  (void) memset(M03,0,sizeof(M03));\n  (void) memset(M10,0,sizeof(M10));\n  (void) memset(M11,0,sizeof(M11));\n  (void) memset(M12,0,sizeof(M12));\n  (void) memset(M20,0,sizeof(M20));\n  (void) memset(M21,0,sizeof(M21));\n  (void) memset(M22,0,sizeof(M22));\n  (void) memset(M30,0,sizeof(M30));\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    /*\n      Compute center of mass (centroid).\n    */\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        M00[channel]+=QuantumScale*p[i];\n        M00[MaxPixelChannels]+=QuantumScale*p[i];\n        M10[channel]+=x*QuantumScale*p[i];\n        M10[MaxPixelChannels]+=x*QuantumScale*p[i];\n        M01[channel]+=y*QuantumScale*p[i];\n        M01[MaxPixelChannels]+=y*QuantumScale*p[i];\n      }\n      p+=GetPixelChannels(image);\n    }\n  }\n  for (channel=0; channel <= MaxPixelChannels; channel++)\n  {\n    /*\n       Compute center of mass (centroid).\n    */\n    if (M00[channel] < MagickEpsilon)\n      {\n        M00[channel]+=MagickEpsilon;\n        centroid[channel].x=(double) image->columns/2.0;\n        centroid[channel].y=(double) image->rows/2.0;\n        continue;\n      }\n    M00[channel]+=MagickEpsilon;\n    centroid[channel].x=M10[channel]/M00[channel];\n    centroid[channel].y=M01[channel]/M00[channel];\n  }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    /*\n      Compute the image moments.\n    */\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        M11[channel]+=(x-centroid[channel].x)*(y-centroid[channel].y)*\n          QuantumScale*p[i];\n        M11[MaxPixelChannels]+=(x-centroid[channel].x)*(y-centroid[channel].y)*\n          QuantumScale*p[i];\n        M20[channel]+=(x-centroid[channel].x)*(x-centroid[channel].x)*\n          QuantumScale*p[i];\n        M20[MaxPixelChannels]+=(x-centroid[channel].x)*(x-centroid[channel].x)*\n          QuantumScale*p[i];\n        M02[channel]+=(y-centroid[channel].y)*(y-centroid[channel].y)*\n          QuantumScale*p[i];\n        M02[MaxPixelChannels]+=(y-centroid[channel].y)*(y-centroid[channel].y)*\n          QuantumScale*p[i];\n        M21[channel]+=(x-centroid[channel].x)*(x-centroid[channel].x)*\n          (y-centroid[channel].y)*QuantumScale*p[i];\n        M21[MaxPixelChannels]+=(x-centroid[channel].x)*(x-centroid[channel].x)*\n          (y-centroid[channel].y)*QuantumScale*p[i];\n        M12[channel]+=(x-centroid[channel].x)*(y-centroid[channel].y)*\n          (y-centroid[channel].y)*QuantumScale*p[i];\n        M12[MaxPixelChannels]+=(x-centroid[channel].x)*(y-centroid[channel].y)*\n          (y-centroid[channel].y)*QuantumScale*p[i];\n        M22[channel]+=(x-centroid[channel].x)*(x-centroid[channel].x)*\n          (y-centroid[channel].y)*(y-centroid[channel].y)*QuantumScale*p[i];\n        M22[MaxPixelChannels]+=(x-centroid[channel].x)*(x-centroid[channel].x)*\n          (y-centroid[channel].y)*(y-centroid[channel].y)*QuantumScale*p[i];\n        M30[channel]+=(x-centroid[channel].x)*(x-centroid[channel].x)*\n          (x-centroid[channel].x)*QuantumScale*p[i];\n        M30[MaxPixelChannels]+=(x-centroid[channel].x)*(x-centroid[channel].x)*\n          (x-centroid[channel].x)*QuantumScale*p[i];\n        M03[channel]+=(y-centroid[channel].y)*(y-centroid[channel].y)*\n          (y-centroid[channel].y)*QuantumScale*p[i];\n        M03[MaxPixelChannels]+=(y-centroid[channel].y)*(y-centroid[channel].y)*\n          (y-centroid[channel].y)*QuantumScale*p[i];\n      }\n      p+=GetPixelChannels(image);\n    }\n  }\n  M00[MaxPixelChannels]/=GetImageChannels(image);\n  M01[MaxPixelChannels]/=GetImageChannels(image);\n  M02[MaxPixelChannels]/=GetImageChannels(image);\n  M03[MaxPixelChannels]/=GetImageChannels(image);\n  M10[MaxPixelChannels]/=GetImageChannels(image);\n  M11[MaxPixelChannels]/=GetImageChannels(image);\n  M12[MaxPixelChannels]/=GetImageChannels(image);\n  M20[MaxPixelChannels]/=GetImageChannels(image);\n  M21[MaxPixelChannels]/=GetImageChannels(image);\n  M22[MaxPixelChannels]/=GetImageChannels(image);\n  M30[MaxPixelChannels]/=GetImageChannels(image);\n  for (channel=0; channel <= MaxPixelChannels; channel++)\n  {\n    /*\n      Compute elliptical angle, major and minor axes, eccentricity, & intensity.\n    */\n    channel_moments[channel].centroid=centroid[channel];\n    channel_moments[channel].ellipse_axis.x=sqrt((2.0/M00[channel])*\n      ((M20[channel]+M02[channel])+sqrt(4.0*M11[channel]*M11[channel]+\n      (M20[channel]-M02[channel])*(M20[channel]-M02[channel]))));\n    channel_moments[channel].ellipse_axis.y=sqrt((2.0/M00[channel])*\n      ((M20[channel]+M02[channel])-sqrt(4.0*M11[channel]*M11[channel]+\n      (M20[channel]-M02[channel])*(M20[channel]-M02[channel]))));\n    channel_moments[channel].ellipse_angle=RadiansToDegrees(0.5*atan(2.0*\n      M11[channel]/(M20[channel]-M02[channel]+MagickEpsilon)));\n    if (fabs(M11[channel]) < MagickEpsilon)\n      {\n        if (fabs(M20[channel]-M02[channel]) < MagickEpsilon)\n          channel_moments[channel].ellipse_angle+=0.0;\n        else\n          if ((M20[channel]-M02[channel]) < 0.0)\n            channel_moments[channel].ellipse_angle+=90.0;\n          else\n            channel_moments[channel].ellipse_angle+=0.0;\n      }\n    else\n      if (M11[channel] < 0.0)\n        {\n          if (fabs(M20[channel]-M02[channel]) < MagickEpsilon)\n            channel_moments[channel].ellipse_angle+=0.0;\n          else\n            if ((M20[channel]-M02[channel]) < 0.0)\n              channel_moments[channel].ellipse_angle+=90.0;\n            else\n              channel_moments[channel].ellipse_angle+=180.0;\n        }\n      else\n        {\n          if (fabs(M20[channel]-M02[channel]) < MagickEpsilon)\n            channel_moments[channel].ellipse_angle+=0.0;\n          else\n            if ((M20[channel]-M02[channel]) < 0.0)\n              channel_moments[channel].ellipse_angle+=90.0;\n            else\n              channel_moments[channel].ellipse_angle+=0.0;\n       }\n    channel_moments[channel].ellipse_eccentricity=sqrt(1.0-(\n      channel_moments[channel].ellipse_axis.y/\n      (channel_moments[channel].ellipse_axis.x+MagickEpsilon)));\n    channel_moments[channel].ellipse_intensity=M00[channel]/\n      (MagickPI*channel_moments[channel].ellipse_axis.x*\n      channel_moments[channel].ellipse_axis.y+MagickEpsilon);\n  }\n  for (channel=0; channel <= MaxPixelChannels; channel++)\n  {\n    /*\n      Normalize image moments.\n    */\n    M10[channel]=0.0;\n    M01[channel]=0.0;\n    M11[channel]/=pow(M00[channel],1.0+(1.0+1.0)/2.0);\n    M20[channel]/=pow(M00[channel],1.0+(2.0+0.0)/2.0);\n    M02[channel]/=pow(M00[channel],1.0+(0.0+2.0)/2.0);\n    M21[channel]/=pow(M00[channel],1.0+(2.0+1.0)/2.0);\n    M12[channel]/=pow(M00[channel],1.0+(1.0+2.0)/2.0);\n    M22[channel]/=pow(M00[channel],1.0+(2.0+2.0)/2.0);\n    M30[channel]/=pow(M00[channel],1.0+(3.0+0.0)/2.0);\n    M03[channel]/=pow(M00[channel],1.0+(0.0+3.0)/2.0);\n    M00[channel]=1.0;\n  }\n  image_view=DestroyCacheView(image_view);\n  for (channel=0; channel <= MaxPixelChannels; channel++)\n  {\n    /*\n      Compute Hu invariant moments.\n    */\n    channel_moments[channel].invariant[0]=M20[channel]+M02[channel];\n    channel_moments[channel].invariant[1]=(M20[channel]-M02[channel])*\n      (M20[channel]-M02[channel])+4.0*M11[channel]*M11[channel];\n    channel_moments[channel].invariant[2]=(M30[channel]-3.0*M12[channel])*\n      (M30[channel]-3.0*M12[channel])+(3.0*M21[channel]-M03[channel])*\n      (3.0*M21[channel]-M03[channel]);\n    channel_moments[channel].invariant[3]=(M30[channel]+M12[channel])*\n      (M30[channel]+M12[channel])+(M21[channel]+M03[channel])*\n      (M21[channel]+M03[channel]);\n    channel_moments[channel].invariant[4]=(M30[channel]-3.0*M12[channel])*\n      (M30[channel]+M12[channel])*((M30[channel]+M12[channel])*\n      (M30[channel]+M12[channel])-3.0*(M21[channel]+M03[channel])*\n      (M21[channel]+M03[channel]))+(3.0*M21[channel]-M03[channel])*\n      (M21[channel]+M03[channel])*(3.0*(M30[channel]+M12[channel])*\n      (M30[channel]+M12[channel])-(M21[channel]+M03[channel])*\n      (M21[channel]+M03[channel]));\n    channel_moments[channel].invariant[5]=(M20[channel]-M02[channel])*\n      ((M30[channel]+M12[channel])*(M30[channel]+M12[channel])-\n      (M21[channel]+M03[channel])*(M21[channel]+M03[channel]))+\n      4.0*M11[channel]*(M30[channel]+M12[channel])*(M21[channel]+M03[channel]);\n    channel_moments[channel].invariant[6]=(3.0*M21[channel]-M03[channel])*\n      (M30[channel]+M12[channel])*((M30[channel]+M12[channel])*\n      (M30[channel]+M12[channel])-3.0*(M21[channel]+M03[channel])*\n      (M21[channel]+M03[channel]))-(M30[channel]-3*M12[channel])*\n      (M21[channel]+M03[channel])*(3.0*(M30[channel]+M12[channel])*\n      (M30[channel]+M12[channel])-(M21[channel]+M03[channel])*\n      (M21[channel]+M03[channel]));\n    channel_moments[channel].invariant[7]=M11[channel]*((M30[channel]+\n      M12[channel])*(M30[channel]+M12[channel])-(M03[channel]+M21[channel])*\n      (M03[channel]+M21[channel]))-(M20[channel]-M02[channel])*\n      (M30[channel]+M12[channel])*(M03[channel]+M21[channel]);\n  }\n  if (y < (ssize_t) image->rows)\n    channel_moments=(ChannelMoments *) RelinquishMagickMemory(channel_moments);\n  return(channel_moments);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e C h a n n e l P e r c e p t u a l H a s h                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImagePerceptualHash() returns the perceptual hash of one or more\n%  image channels.\n%\n%  The format of the GetImagePerceptualHash method is:\n%\n%      ChannelPerceptualHash *GetImagePerceptualHash(const Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline double MagickLog10(const double x)\n{\n#define Log10Epsilon  (1.0e-11)\n\n  if (fabs(x) < Log10Epsilon)\n    return(log10(Log10Epsilon));\n  return(log10(fabs(x)));\n}\n\nMagickExport ChannelPerceptualHash *GetImagePerceptualHash(const Image *image,\n  ExceptionInfo *exception)\n{\n  ChannelPerceptualHash\n    *perceptual_hash;\n\n  char\n    *colorspaces,\n    *q;\n\n  const char\n    *artifact;\n\n  MagickBooleanType\n    status;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  perceptual_hash=(ChannelPerceptualHash *) AcquireQuantumMemory(\n    MaxPixelChannels+1UL,sizeof(*perceptual_hash));\n  if (perceptual_hash == (ChannelPerceptualHash *) NULL)\n    return((ChannelPerceptualHash *) NULL);\n  artifact=GetImageArtifact(image,\"phash:colorspaces\");\n  if (artifact != NULL)\n    colorspaces=AcquireString(artifact);\n  else\n    colorspaces=AcquireString(\"sRGB,HCLp\");\n  perceptual_hash[0].number_colorspaces=0;\n  perceptual_hash[0].number_channels=0;\n  q=colorspaces;\n  for (i=0; (p=StringToken(\",\",&q)) != (char *) NULL; i++)\n  {\n    ChannelMoments\n      *moments;\n\n    Image\n      *hash_image;\n\n    size_t\n      j;\n\n    ssize_t\n      channel,\n      colorspace;\n\n    if (i >= MaximumNumberOfPerceptualColorspaces)\n      break;\n    colorspace=ParseCommandOption(MagickColorspaceOptions,MagickFalse,p);\n    if (colorspace < 0)\n      break;\n    perceptual_hash[0].colorspace[i]=(ColorspaceType) colorspace;\n    hash_image=BlurImage(image,0.0,1.0,exception);\n    if (hash_image == (Image *) NULL)\n      break;\n    hash_image->depth=8;\n    status=TransformImageColorspace(hash_image,(ColorspaceType) colorspace,\n      exception);\n    if (status == MagickFalse)\n      break;\n    moments=GetImageMoments(hash_image,exception);\n    perceptual_hash[0].number_colorspaces++;\n    perceptual_hash[0].number_channels+=GetImageChannels(hash_image);\n    hash_image=DestroyImage(hash_image);\n    if (moments == (ChannelMoments *) NULL)\n      break;\n    for (channel=0; channel <= MaxPixelChannels; channel++)\n      for (j=0; j < MaximumNumberOfImageMoments; j++)\n        perceptual_hash[channel].phash[i][j]=\n          (-MagickLog10(moments[channel].invariant[j]));\n    moments=(ChannelMoments *) RelinquishMagickMemory(moments);\n  }\n  colorspaces=DestroyString(colorspaces);\n  return(perceptual_hash);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e R a n g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageRange() returns the range of one or more image channels.\n%\n%  The format of the GetImageRange method is:\n%\n%      MagickBooleanType GetImageRange(const Image *image,double *minima,\n%        double *maxima,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o minima: the minimum value in the channel.\n%\n%    o maxima: the maximum value in the channel.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetImageRange(const Image *image,double *minima,\n  double *maxima,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    initialize,\n    status;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=MagickTrue;\n  initialize=MagickTrue;\n  *maxima=0.0;\n  *minima=0.0;\n  image_view=AcquireVirtualCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status,initialize) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    double\n      row_maxima = 0.0,\n      row_minima = 0.0;\n\n    MagickBooleanType\n      row_initialize;\n\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    row_initialize=MagickTrue;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n\t\t\t\tif (row_initialize != MagickFalse)\n          {\n            row_minima=(double) p[i];\n            row_maxima=(double) p[i];\n            row_initialize=MagickFalse;\n          }\n        else\n          {\n            if ((double) p[i] < row_minima)\n              row_minima=(double) p[i];\n            if ((double) p[i] > row_maxima)\n              row_maxima=(double) p[i];\n         }\n      }\n      p+=GetPixelChannels(image);\n    }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#pragma omp critical (MagickCore_GetImageRange)\n#endif\n    {\n      if (initialize != MagickFalse)\n        {\n          *minima=row_minima;\n          *maxima=row_maxima;\n          initialize=MagickFalse;\n        }\n      else\n        {\n          if (row_minima < *minima)\n            *minima=row_minima;\n          if (row_maxima > *maxima)\n            *maxima=row_maxima;\n        }\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e S t a t i s t i c s                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageStatistics() returns statistics for each channel in the image.  The\n%  statistics include the channel depth, its minima, maxima, mean, standard\n%  deviation, kurtosis and skewness.  You can access the red channel mean, for\n%  example, like this:\n%\n%      channel_statistics=GetImageStatistics(image,exception);\n%      red_mean=channel_statistics[RedPixelChannel].mean;\n%\n%  Use MagickRelinquishMemory() to free the statistics buffer.\n%\n%  The format of the GetImageStatistics method is:\n%\n%      ChannelStatistics *GetImageStatistics(const Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport ChannelStatistics *GetImageStatistics(const Image *image,\n  ExceptionInfo *exception)\n{\n  ChannelStatistics\n    *channel_statistics;\n\n  double\n    area,\n    *histogram,\n    standard_deviation;\n\n  MagickStatusType\n    status;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    i;\n\n  size_t\n    depth;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  histogram=(double *) AcquireQuantumMemory(MaxMap+1UL,GetPixelChannels(image)*\n    sizeof(*histogram));\n  channel_statistics=(ChannelStatistics *) AcquireQuantumMemory(\n    MaxPixelChannels+1,sizeof(*channel_statistics));\n  if ((channel_statistics == (ChannelStatistics *) NULL) ||\n      (histogram == (double *) NULL))\n    {\n      if (histogram != (double *) NULL)\n        histogram=(double *) RelinquishMagickMemory(histogram);\n      if (channel_statistics != (ChannelStatistics *) NULL)\n        channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n          channel_statistics);\n      return(channel_statistics);\n    }\n  (void) memset(channel_statistics,0,(MaxPixelChannels+1)*\n    sizeof(*channel_statistics));\n  for (i=0; i <= (ssize_t) MaxPixelChannels; i++)\n  {\n    channel_statistics[i].depth=1;\n    channel_statistics[i].maxima=(-MagickMaximumValue);\n    channel_statistics[i].minima=MagickMaximumValue;\n  }\n  (void) memset(histogram,0,(MaxMap+1)*GetPixelChannels(image)*\n    sizeof(*histogram));\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    /*\n      Compute pixel statistics.\n    */\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,p) <= (QuantumRange/2))\n        {\n          p+=GetPixelChannels(image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if (channel_statistics[channel].depth != MAGICKCORE_QUANTUM_DEPTH)\n          {\n            depth=channel_statistics[channel].depth;\n            range=GetQuantumRange(depth);\n            status=p[i] != ScaleAnyToQuantum(ScaleQuantumToAny(p[i],range),\n              range) ? MagickTrue : MagickFalse;\n            if (status != MagickFalse)\n              {\n                channel_statistics[channel].depth++;\n                i--;\n                continue;\n              }\n          }\n        if ((double) p[i] < channel_statistics[channel].minima)\n          channel_statistics[channel].minima=(double) p[i];\n        if ((double) p[i] > channel_statistics[channel].maxima)\n          channel_statistics[channel].maxima=(double) p[i];\n        channel_statistics[channel].sum+=p[i];\n        channel_statistics[channel].sum_squared+=(double) p[i]*p[i];\n        channel_statistics[channel].sum_cubed+=(double) p[i]*p[i]*p[i];\n        channel_statistics[channel].sum_fourth_power+=(double) p[i]*p[i]*p[i]*\n          p[i];\n        channel_statistics[channel].area++;\n        if ((double) p[i] < channel_statistics[CompositePixelChannel].minima)\n          channel_statistics[CompositePixelChannel].minima=(double) p[i];\n        if ((double) p[i] > channel_statistics[CompositePixelChannel].maxima)\n          channel_statistics[CompositePixelChannel].maxima=(double) p[i];\n        histogram[GetPixelChannels(image)*ScaleQuantumToMap(\n          ClampToQuantum((double) p[i]))+i]++;\n        channel_statistics[CompositePixelChannel].sum+=(double) p[i];\n        channel_statistics[CompositePixelChannel].sum_squared+=(double)\n          p[i]*p[i];\n        channel_statistics[CompositePixelChannel].sum_cubed+=(double)\n          p[i]*p[i]*p[i];\n        channel_statistics[CompositePixelChannel].sum_fourth_power+=(double)\n          p[i]*p[i]*p[i]*p[i];\n        channel_statistics[CompositePixelChannel].area++;\n      }\n      p+=GetPixelChannels(image);\n    }\n  }\n  for (i=0; i <= (ssize_t) MaxPixelChannels; i++)\n  {\n    /*\n      Normalize pixel statistics.\n    */\n    area=PerceptibleReciprocal(channel_statistics[i].area);\n    channel_statistics[i].sum*=area;\n    channel_statistics[i].sum_squared*=area;\n    channel_statistics[i].sum_cubed*=area;\n    channel_statistics[i].sum_fourth_power*=area;\n    channel_statistics[i].mean=channel_statistics[i].sum;\n    channel_statistics[i].variance=channel_statistics[i].sum_squared;\n    standard_deviation=sqrt(channel_statistics[i].variance-\n      (channel_statistics[i].mean*channel_statistics[i].mean));\n    standard_deviation=sqrt(PerceptibleReciprocal(channel_statistics[i].area-\n      1.0)*channel_statistics[i].area*standard_deviation*standard_deviation);\n    channel_statistics[i].standard_deviation=standard_deviation;\n  }\n  for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n  {\n    double\n      number_bins;\n\n    register ssize_t\n      j;\n\n    /*\n      Compute pixel entropy.\n    */\n    PixelChannel channel = GetPixelChannelChannel(image,i);\n    number_bins=0.0;\n    for (j=0; j <= (ssize_t) MaxMap; j++)\n      if (histogram[GetPixelChannels(image)*j+i] > 0.0)\n        number_bins++;\n    area=PerceptibleReciprocal(channel_statistics[channel].area);\n    for (j=0; j <= (ssize_t) MaxMap; j++)\n    {\n      double\n        count;\n\n      count=area*histogram[GetPixelChannels(image)*j+i];\n      channel_statistics[channel].entropy+=-count*MagickLog10(count)*\n        PerceptibleReciprocal(MagickLog10(number_bins));\n      channel_statistics[CompositePixelChannel].entropy+=-count*\n        MagickLog10(count)*PerceptibleReciprocal(MagickLog10(number_bins))/\n        GetPixelChannels(image);\n    }\n  }\n  histogram=(double *) RelinquishMagickMemory(histogram);\n  for (i=0; i <= (ssize_t) MaxPixelChannels; i++)\n  {\n    /*\n      Compute kurtosis & skewness statistics.\n    */\n    standard_deviation=PerceptibleReciprocal(\n      channel_statistics[i].standard_deviation);\n    channel_statistics[i].skewness=(channel_statistics[i].sum_cubed-3.0*\n      channel_statistics[i].mean*channel_statistics[i].sum_squared+2.0*\n      channel_statistics[i].mean*channel_statistics[i].mean*\n      channel_statistics[i].mean)*(standard_deviation*standard_deviation*\n      standard_deviation);\n    channel_statistics[i].kurtosis=(channel_statistics[i].sum_fourth_power-4.0*\n      channel_statistics[i].mean*channel_statistics[i].sum_cubed+6.0*\n      channel_statistics[i].mean*channel_statistics[i].mean*\n      channel_statistics[i].sum_squared-3.0*channel_statistics[i].mean*\n      channel_statistics[i].mean*1.0*channel_statistics[i].mean*\n      channel_statistics[i].mean)*(standard_deviation*standard_deviation*\n      standard_deviation*standard_deviation)-3.0;\n  }\n  channel_statistics[CompositePixelChannel].mean=0.0;\n  channel_statistics[CompositePixelChannel].standard_deviation=0.0;\n  channel_statistics[CompositePixelChannel].entropy=0.0;\n  for (i=0; i < (ssize_t) MaxPixelChannels; i++)\n  {\n    channel_statistics[CompositePixelChannel].mean+=\n      channel_statistics[i].mean;\n    channel_statistics[CompositePixelChannel].standard_deviation+=\n      channel_statistics[i].standard_deviation;\n    channel_statistics[CompositePixelChannel].entropy+=\n      channel_statistics[i].entropy;\n  }\n  channel_statistics[CompositePixelChannel].mean/=(double)\n    GetImageChannels(image);\n  channel_statistics[CompositePixelChannel].standard_deviation/=(double)\n    GetImageChannels(image);\n  channel_statistics[CompositePixelChannel].entropy/=(double)\n    GetImageChannels(image);\n  if (y < (ssize_t) image->rows)\n    channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n      channel_statistics);\n  return(channel_statistics);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     P o l y n o m i a l I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PolynomialImage() returns a new image where each pixel is the sum of the\n%  pixels in the image sequence after applying its corresponding terms\n%  (coefficient and degree pairs).\n%\n%  The format of the PolynomialImage method is:\n%\n%      Image *PolynomialImage(const Image *images,const size_t number_terms,\n%        const double *terms,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o images: the image sequence.\n%\n%    o number_terms: the number of terms in the list.  The actual list length\n%      is 2 x number_terms + 1 (the constant).\n%\n%    o terms: the list of polynomial coefficients and degree pairs and a\n%      constant.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *PolynomialImage(const Image *images,\n  const size_t number_terms,const double *terms,ExceptionInfo *exception)\n{\n#define PolynomialImageTag  \"Polynomial/Image\"\n\n  CacheView\n    *polynomial_view;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  PixelChannels\n    **magick_restrict polynomial_pixels;\n\n  size_t\n    number_images;\n\n  ssize_t\n    y;\n\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImageCanvas(images,exception);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  number_images=GetImageListLength(images);\n  polynomial_pixels=AcquirePixelThreadSet(images);\n  if (polynomial_pixels == (PixelChannels **) NULL)\n    {\n      image=DestroyImage(image);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",images->filename);\n      return((Image *) NULL);\n    }\n  /*\n    Polynomial image pixels.\n  */\n  status=MagickTrue;\n  progress=0;\n  polynomial_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    CacheView\n      *image_view;\n\n    const Image\n      *next;\n\n    const int\n      id = GetOpenMPThreadId();\n\n    register ssize_t\n      i,\n      x;\n\n    register PixelChannels\n      *polynomial_pixel;\n\n    register Quantum\n      *magick_restrict q;\n\n    ssize_t\n      j;\n\n    if (status == MagickFalse)\n      continue;\n    q=QueueCacheViewAuthenticPixels(polynomial_view,0,y,image->columns,1,\n      exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    polynomial_pixel=polynomial_pixels[id];\n    for (j=0; j < (ssize_t) image->columns; j++)\n      for (i=0; i < MaxPixelChannels; i++)\n        polynomial_pixel[j].channel[i]=0.0;\n    next=images;\n    for (j=0; j < (ssize_t) number_images; j++)\n    {\n      register const Quantum\n        *p;\n\n      if (j >= (ssize_t) number_terms)\n        continue;\n      image_view=AcquireVirtualCacheView(next,exception);\n      p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        {\n          image_view=DestroyCacheView(image_view);\n          break;\n        }\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        register ssize_t\n          i;\n\n        for (i=0; i < (ssize_t) GetPixelChannels(next); i++)\n        {\n          MagickRealType\n            coefficient,\n            degree;\n\n          PixelChannel channel = GetPixelChannelChannel(image,i);\n          PixelTrait traits = GetPixelChannelTraits(next,channel);\n          PixelTrait polynomial_traits=GetPixelChannelTraits(image,channel);\n          if ((traits == UndefinedPixelTrait) ||\n              (polynomial_traits == UndefinedPixelTrait))\n            continue;\n          if ((traits & UpdatePixelTrait) == 0)\n            continue;\n          coefficient=(MagickRealType) terms[2*j];\n          degree=(MagickRealType) terms[(j << 1)+1];\n          polynomial_pixel[x].channel[i]+=coefficient*\n            pow(QuantumScale*GetPixelChannel(image,channel,p),degree);\n        }\n        p+=GetPixelChannels(next);\n      }\n      image_view=DestroyCacheView(image_view);\n      next=GetNextImageInList(next);\n    }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        q[i]=ClampToQuantum(QuantumRange*polynomial_pixel[x].channel[i]);\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(polynomial_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (images->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(images,PolynomialImageTag,progress,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  polynomial_view=DestroyCacheView(polynomial_view);\n  polynomial_pixels=DestroyPixelThreadSet(polynomial_pixels);\n  if (status == MagickFalse)\n    image=DestroyImage(image);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     S t a t i s t i c I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  StatisticImage() makes each pixel the min / max / median / mode / etc. of\n%  the neighborhood of the specified width and height.\n%\n%  The format of the StatisticImage method is:\n%\n%      Image *StatisticImage(const Image *image,const StatisticType type,\n%        const size_t width,const size_t height,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o type: the statistic type (median, mode, etc.).\n%\n%    o width: the width of the pixel neighborhood.\n%\n%    o height: the height of the pixel neighborhood.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\ntypedef struct _SkipNode\n{\n  size_t\n    next[9],\n    count,\n    signature;\n} SkipNode;\n\ntypedef struct _SkipList\n{\n  ssize_t\n    level;\n\n  SkipNode\n    *nodes;\n} SkipList;\n\ntypedef struct _PixelList\n{\n  size_t\n    length,\n    seed;\n\n  SkipList\n    skip_list;\n\n  size_t\n    signature;\n} PixelList;\n\nstatic PixelList *DestroyPixelList(PixelList *pixel_list)\n{\n  if (pixel_list == (PixelList *) NULL)\n    return((PixelList *) NULL);\n  if (pixel_list->skip_list.nodes != (SkipNode *) NULL)\n    pixel_list->skip_list.nodes=(SkipNode *) RelinquishAlignedMemory(\n      pixel_list->skip_list.nodes);\n  pixel_list=(PixelList *) RelinquishMagickMemory(pixel_list);\n  return(pixel_list);\n}\n\nstatic PixelList **DestroyPixelListThreadSet(PixelList **pixel_list)\n{\n  register ssize_t\n    i;\n\n  assert(pixel_list != (PixelList **) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (pixel_list[i] != (PixelList *) NULL)\n      pixel_list[i]=DestroyPixelList(pixel_list[i]);\n  pixel_list=(PixelList **) RelinquishMagickMemory(pixel_list);\n  return(pixel_list);\n}\n\nstatic PixelList *AcquirePixelList(const size_t width,const size_t height)\n{\n  PixelList\n    *pixel_list;\n\n  pixel_list=(PixelList *) AcquireMagickMemory(sizeof(*pixel_list));\n  if (pixel_list == (PixelList *) NULL)\n    return(pixel_list);\n  (void) memset((void *) pixel_list,0,sizeof(*pixel_list));\n  pixel_list->length=width*height;\n  pixel_list->skip_list.nodes=(SkipNode *) AcquireAlignedMemory(65537UL,\n    sizeof(*pixel_list->skip_list.nodes));\n  if (pixel_list->skip_list.nodes == (SkipNode *) NULL)\n    return(DestroyPixelList(pixel_list));\n  (void) memset(pixel_list->skip_list.nodes,0,65537UL*\n    sizeof(*pixel_list->skip_list.nodes));\n  pixel_list->signature=MagickCoreSignature;\n  return(pixel_list);\n}\n\nstatic PixelList **AcquirePixelListThreadSet(const size_t width,\n  const size_t height)\n{\n  PixelList\n    **pixel_list;\n\n  register ssize_t\n    i;\n\n  size_t\n    number_threads;\n\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  pixel_list=(PixelList **) AcquireQuantumMemory(number_threads,\n    sizeof(*pixel_list));\n  if (pixel_list == (PixelList **) NULL)\n    return((PixelList **) NULL);\n  (void) memset(pixel_list,0,number_threads*sizeof(*pixel_list));\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    pixel_list[i]=AcquirePixelList(width,height);\n    if (pixel_list[i] == (PixelList *) NULL)\n      return(DestroyPixelListThreadSet(pixel_list));\n  }\n  return(pixel_list);\n}\n\nstatic void AddNodePixelList(PixelList *pixel_list,const size_t color)\n{\n  register SkipList\n    *p;\n\n  register ssize_t\n    level;\n\n  size_t\n    search,\n    update[9];\n\n  /*\n    Initialize the node.\n  */\n  p=(&pixel_list->skip_list);\n  p->nodes[color].signature=pixel_list->signature;\n  p->nodes[color].count=1;\n  /*\n    Determine where it belongs in the list.\n  */\n  search=65536UL;\n  for (level=p->level; level >= 0; level--)\n  {\n    while (p->nodes[search].next[level] < color)\n      search=p->nodes[search].next[level];\n    update[level]=search;\n  }\n  /*\n    Generate a pseudo-random level for this node.\n  */\n  for (level=0; ; level++)\n  {\n    pixel_list->seed=(pixel_list->seed*42893621L)+1L;\n    if ((pixel_list->seed & 0x300) != 0x300)\n      break;\n  }\n  if (level > 8)\n    level=8;\n  if (level > (p->level+2))\n    level=p->level+2;\n  /*\n    If we're raising the list's level, link back to the root node.\n  */\n  while (level > p->level)\n  {\n    p->level++;\n    update[p->level]=65536UL;\n  }\n  /*\n    Link the node into the skip-list.\n  */\n  do\n  {\n    p->nodes[color].next[level]=p->nodes[update[level]].next[level];\n    p->nodes[update[level]].next[level]=color;\n  } while (level-- > 0);\n}\n\nstatic inline void GetMaximumPixelList(PixelList *pixel_list,Quantum *pixel)\n{\n  register SkipList\n    *p;\n\n  size_t\n    color,\n    maximum;\n\n  ssize_t\n    count;\n\n  /*\n    Find the maximum value for each of the color.\n  */\n  p=(&pixel_list->skip_list);\n  color=65536L;\n  count=0;\n  maximum=p->nodes[color].next[0];\n  do\n  {\n    color=p->nodes[color].next[0];\n    if (color > maximum)\n      maximum=color;\n    count+=p->nodes[color].count;\n  } while (count < (ssize_t) pixel_list->length);\n  *pixel=ScaleShortToQuantum((unsigned short) maximum);\n}\n\nstatic inline void GetMeanPixelList(PixelList *pixel_list,Quantum *pixel)\n{\n  double\n    sum;\n\n  register SkipList\n    *p;\n\n  size_t\n    color;\n\n  ssize_t\n    count;\n\n  /*\n    Find the mean value for each of the color.\n  */\n  p=(&pixel_list->skip_list);\n  color=65536L;\n  count=0;\n  sum=0.0;\n  do\n  {\n    color=p->nodes[color].next[0];\n    sum+=(double) p->nodes[color].count*color;\n    count+=p->nodes[color].count;\n  } while (count < (ssize_t) pixel_list->length);\n  sum/=pixel_list->length;\n  *pixel=ScaleShortToQuantum((unsigned short) sum);\n}\n\nstatic inline void GetMedianPixelList(PixelList *pixel_list,Quantum *pixel)\n{\n  register SkipList\n    *p;\n\n  size_t\n    color;\n\n  ssize_t\n    count;\n\n  /*\n    Find the median value for each of the color.\n  */\n  p=(&pixel_list->skip_list);\n  color=65536L;\n  count=0;\n  do\n  {\n    color=p->nodes[color].next[0];\n    count+=p->nodes[color].count;\n  } while (count <= (ssize_t) (pixel_list->length >> 1));\n  *pixel=ScaleShortToQuantum((unsigned short) color);\n}\n\nstatic inline void GetMinimumPixelList(PixelList *pixel_list,Quantum *pixel)\n{\n  register SkipList\n    *p;\n\n  size_t\n    color,\n    minimum;\n\n  ssize_t\n    count;\n\n  /*\n    Find the minimum value for each of the color.\n  */\n  p=(&pixel_list->skip_list);\n  count=0;\n  color=65536UL;\n  minimum=p->nodes[color].next[0];\n  do\n  {\n    color=p->nodes[color].next[0];\n    if (color < minimum)\n      minimum=color;\n    count+=p->nodes[color].count;\n  } while (count < (ssize_t) pixel_list->length);\n  *pixel=ScaleShortToQuantum((unsigned short) minimum);\n}\n\nstatic inline void GetModePixelList(PixelList *pixel_list,Quantum *pixel)\n{\n  register SkipList\n    *p;\n\n  size_t\n    color,\n    max_count,\n    mode;\n\n  ssize_t\n    count;\n\n  /*\n    Make each pixel the 'predominant color' of the specified neighborhood.\n  */\n  p=(&pixel_list->skip_list);\n  color=65536L;\n  mode=color;\n  max_count=p->nodes[mode].count;\n  count=0;\n  do\n  {\n    color=p->nodes[color].next[0];\n    if (p->nodes[color].count > max_count)\n      {\n        mode=color;\n        max_count=p->nodes[mode].count;\n      }\n    count+=p->nodes[color].count;\n  } while (count < (ssize_t) pixel_list->length);\n  *pixel=ScaleShortToQuantum((unsigned short) mode);\n}\n\nstatic inline void GetNonpeakPixelList(PixelList *pixel_list,Quantum *pixel)\n{\n  register SkipList\n    *p;\n\n  size_t\n    color,\n    next,\n    previous;\n\n  ssize_t\n    count;\n\n  /*\n    Finds the non peak value for each of the colors.\n  */\n  p=(&pixel_list->skip_list);\n  color=65536L;\n  next=p->nodes[color].next[0];\n  count=0;\n  do\n  {\n    previous=color;\n    color=next;\n    next=p->nodes[color].next[0];\n    count+=p->nodes[color].count;\n  } while (count <= (ssize_t) (pixel_list->length >> 1));\n  if ((previous == 65536UL) && (next != 65536UL))\n    color=next;\n  else\n    if ((previous != 65536UL) && (next == 65536UL))\n      color=previous;\n  *pixel=ScaleShortToQuantum((unsigned short) color);\n}\n\nstatic inline void GetRootMeanSquarePixelList(PixelList *pixel_list,\n  Quantum *pixel)\n{\n  double\n    sum;\n\n  register SkipList\n    *p;\n\n  size_t\n    color;\n\n  ssize_t\n    count;\n\n  /*\n    Find the root mean square value for each of the color.\n  */\n  p=(&pixel_list->skip_list);\n  color=65536L;\n  count=0;\n  sum=0.0;\n  do\n  {\n    color=p->nodes[color].next[0];\n    sum+=(double) (p->nodes[color].count*color*color);\n    count+=p->nodes[color].count;\n  } while (count < (ssize_t) pixel_list->length);\n  sum/=pixel_list->length;\n  *pixel=ScaleShortToQuantum((unsigned short) sqrt(sum));\n}\n\nstatic inline void GetStandardDeviationPixelList(PixelList *pixel_list,\n  Quantum *pixel)\n{\n  double\n    sum,\n    sum_squared;\n\n  register SkipList\n    *p;\n\n  size_t\n    color;\n\n  ssize_t\n    count;\n\n  /*\n    Find the standard-deviation value for each of the color.\n  */\n  p=(&pixel_list->skip_list);\n  color=65536L;\n  count=0;\n  sum=0.0;\n  sum_squared=0.0;\n  do\n  {\n    register ssize_t\n      i;\n\n    color=p->nodes[color].next[0];\n    sum+=(double) p->nodes[color].count*color;\n    for (i=0; i < (ssize_t) p->nodes[color].count; i++)\n      sum_squared+=((double) color)*((double) color);\n    count+=p->nodes[color].count;\n  } while (count < (ssize_t) pixel_list->length);\n  sum/=pixel_list->length;\n  sum_squared/=pixel_list->length;\n  *pixel=ScaleShortToQuantum((unsigned short) sqrt(sum_squared-(sum*sum)));\n}\n\nstatic inline void InsertPixelList(const Quantum pixel,PixelList *pixel_list)\n{\n  size_t\n    signature;\n\n  unsigned short\n    index;\n\n  index=ScaleQuantumToShort(pixel);\n  signature=pixel_list->skip_list.nodes[index].signature;\n  if (signature == pixel_list->signature)\n    {\n      pixel_list->skip_list.nodes[index].count++;\n      return;\n    }\n  AddNodePixelList(pixel_list,index);\n}\n\nstatic void ResetPixelList(PixelList *pixel_list)\n{\n  int\n    level;\n\n  register SkipNode\n    *root;\n\n  register SkipList\n    *p;\n\n  /*\n    Reset the skip-list.\n  */\n  p=(&pixel_list->skip_list);\n  root=p->nodes+65536UL;\n  p->level=0;\n  for (level=0; level < 9; level++)\n    root->next[level]=65536UL;\n  pixel_list->seed=pixel_list->signature++;\n}\n\nMagickExport Image *StatisticImage(const Image *image,const StatisticType type,\n  const size_t width,const size_t height,ExceptionInfo *exception)\n{\n#define StatisticImageTag  \"Statistic/Image\"\n\n  CacheView\n    *image_view,\n    *statistic_view;\n\n  Image\n    *statistic_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  PixelList\n    **magick_restrict pixel_list;\n\n  ssize_t\n    center,\n    y;\n\n  /*\n    Initialize statistics image attributes.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  statistic_image=CloneImage(image,0,0,MagickTrue,\n    exception);\n  if (statistic_image == (Image *) NULL)\n    return((Image *) NULL);\n  status=SetImageStorageClass(statistic_image,DirectClass,exception);\n  if (status == MagickFalse)\n    {\n      statistic_image=DestroyImage(statistic_image);\n      return((Image *) NULL);\n    }\n  pixel_list=AcquirePixelListThreadSet(MagickMax(width,1),MagickMax(height,1));\n  if (pixel_list == (PixelList **) NULL)\n    {\n      statistic_image=DestroyImage(statistic_image);\n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  /*\n    Make each pixel the min / max / median / mode / etc. of the neighborhood.\n  */\n  center=(ssize_t) GetPixelChannels(image)*(image->columns+MagickMax(width,1))*\n    (MagickMax(height,1)/2L)+GetPixelChannels(image)*(MagickMax(width,1)/2L);\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  statistic_view=AcquireAuthenticCacheView(statistic_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,statistic_image,statistic_image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) statistic_image->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    register const Quantum\n      *magick_restrict p;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,-((ssize_t) MagickMax(width,1)/2L),y-\n      (ssize_t) (MagickMax(height,1)/2L),image->columns+MagickMax(width,1),\n      MagickMax(height,1),exception);\n    q=QueueCacheViewAuthenticPixels(statistic_view,0,y,statistic_image->columns,      1,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) statistic_image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        Quantum\n          pixel;\n\n        register const Quantum\n          *magick_restrict pixels;\n\n        register ssize_t\n          u;\n\n        ssize_t\n          v;\n\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        PixelTrait statistic_traits=GetPixelChannelTraits(statistic_image,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (statistic_traits == UndefinedPixelTrait))\n          continue;\n        if (((statistic_traits & CopyPixelTrait) != 0) ||\n            (GetPixelWriteMask(image,p) <= (QuantumRange/2)))\n          {\n            SetPixelChannel(statistic_image,channel,p[center+i],q);\n            continue;\n          }\n        if ((statistic_traits & UpdatePixelTrait) == 0)\n          continue;\n        pixels=p;\n        ResetPixelList(pixel_list[id]);\n        for (v=0; v < (ssize_t) MagickMax(height,1); v++)\n        {\n          for (u=0; u < (ssize_t) MagickMax(width,1); u++)\n          {\n            InsertPixelList(pixels[i],pixel_list[id]);\n            pixels+=GetPixelChannels(image);\n          }\n          pixels+=GetPixelChannels(image)*image->columns;\n        }\n        switch (type)\n        {\n          case GradientStatistic:\n          {\n            double\n              maximum,\n              minimum;\n\n            GetMinimumPixelList(pixel_list[id],&pixel);\n            minimum=(double) pixel;\n            GetMaximumPixelList(pixel_list[id],&pixel);\n            maximum=(double) pixel;\n            pixel=ClampToQuantum(MagickAbsoluteValue(maximum-minimum));\n            break;\n          }\n          case MaximumStatistic:\n          {\n            GetMaximumPixelList(pixel_list[id],&pixel);\n            break;\n          }\n          case MeanStatistic:\n          {\n            GetMeanPixelList(pixel_list[id],&pixel);\n            break;\n          }\n          case MedianStatistic:\n          default:\n          {\n            GetMedianPixelList(pixel_list[id],&pixel);\n            break;\n          }\n          case MinimumStatistic:\n          {\n            GetMinimumPixelList(pixel_list[id],&pixel);\n            break;\n          }\n          case ModeStatistic:\n          {\n            GetModePixelList(pixel_list[id],&pixel);\n            break;\n          }\n          case NonpeakStatistic:\n          {\n            GetNonpeakPixelList(pixel_list[id],&pixel);\n            break;\n          }\n          case RootMeanSquareStatistic:\n          {\n            GetRootMeanSquarePixelList(pixel_list[id],&pixel);\n            break;\n          }\n          case StandardDeviationStatistic:\n          {\n            GetStandardDeviationPixelList(pixel_list[id],&pixel);\n            break;\n          }\n        }\n        SetPixelChannel(statistic_image,channel,pixel,q);\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(statistic_image);\n    }\n    if (SyncCacheViewAuthenticPixels(statistic_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,StatisticImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  statistic_view=DestroyCacheView(statistic_view);\n  image_view=DestroyCacheView(image_view);\n  pixel_list=DestroyPixelListThreadSet(pixel_list);\n  if (status == MagickFalse)\n    statistic_image=DestroyImage(statistic_image);\n  return(statistic_image);\n}\n"], "filenames": ["MagickCore/statistic.c"], "buggy_code_start_loc": [155], "buggy_code_end_loc": [182], "fixing_code_start_loc": [155], "fixing_code_end_loc": [188], "type": "CWE-787", "message": "ImageMagick 7.0.8-50 Q16 has a heap-based buffer overflow at MagickCore/statistic.c in EvaluateImages because of mishandling columns.", "other": {"cve": {"id": "CVE-2019-13300", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-05T01:15:10.250", "lastModified": "2023-02-23T15:06:54.653", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ImageMagick 7.0.8-50 Q16 has a heap-based buffer overflow at MagickCore/statistic.c in EvaluateImages because of mishandling columns."}, {"lang": "es", "value": "ImageMagick versi\u00f3n 7.0.8-50 Q16 tiene un desbordamiento de b\u00fafer basado en memoria din\u00e1mica (heap) en MagickCore/statistic.c en EvaluateImages debido a la gesti\u00f3n incorrecta de las columnas."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.8-50:q16:*:*:*:*:*:*", "matchCriteriaId": "25CCEA99-8329-46C6-9625-4FE15F24CF69"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00069.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/a906fe9298bf89e01d5272023db687935068849a", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/1586", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick6/commit/5e409ae7a389cdf2ed17469303be3f3f21cec450", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://usn.ubuntu.com/4192-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4712", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4715", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/a906fe9298bf89e01d5272023db687935068849a"}}