{"buggy_code": ["<?php\n\n/**\n * FusionInventory\n *\n * Copyright (C) 2010-2016 by the FusionInventory Development Team.\n *\n * http://www.fusioninventory.org/\n * https://github.com/fusioninventory/fusioninventory-for-glpi\n * http://forge.fusioninventory.org/\n *\n * ------------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of FusionInventory project.\n *\n * FusionInventory is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * FusionInventory is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with FusionInventory. If not, see <http://www.gnu.org/licenses/>.\n *\n * ------------------------------------------------------------------------\n *\n * This file is used to send the inventory to user browser.\n *\n * ------------------------------------------------------------------------\n *\n * @package   FusionInventory\n * @author    Vincent Mazzoni\n * @author    David Durieux\n * @copyright Copyright (c) 2010-2016 FusionInventory team\n * @license   AGPL License 3.0 or (at your option) any later version\n *            http://www.gnu.org/licenses/agpl-3.0-standalone.html\n * @link      http://www.fusioninventory.org/\n * @link      https://github.com/fusioninventory/fusioninventory-for-glpi\n *\n */\n\ninclude (\"../../../inc/includes.php\");\n\n//Session::checkRight('config', \"w\");\n\n$itemtype = $_GET['itemtype'];\n$function = $_GET['function'];\n$items_id = $_GET['items_id'];\n\nheader('Cache-control: private, must-revalidate'); /// IE BUG + SSL\nheader('Content-disposition: attachment; filename='.$_GET['filename']);\nheader('Content-type: text/plain');\n\n\ncall_user_func(['PluginFusioninventoryToolbox', $function], $items_id, $itemtype);\n\n", "<?php\n\n/**\n * FusionInventory\n *\n * Copyright (C) 2010-2016 by the FusionInventory Development Team.\n *\n * http://www.fusioninventory.org/\n * https://github.com/fusioninventory/fusioninventory-for-glpi\n * http://forge.fusioninventory.org/\n *\n * ------------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of FusionInventory project.\n *\n * FusionInventory is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * FusionInventory is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with FusionInventory. If not, see <http://www.gnu.org/licenses/>.\n *\n * ------------------------------------------------------------------------\n *\n * This file is used to manage the functions used in many classes.\n *\n * ------------------------------------------------------------------------\n *\n * @package   FusionInventory\n * @author    Vincent Mazzoni\n * @author    David Durieux\n * @copyright Copyright (c) 2010-2016 FusionInventory team\n * @license   AGPL License 3.0 or (at your option) any later version\n *            http://www.gnu.org/licenses/agpl-3.0-standalone.html\n * @link      http://www.fusioninventory.org/\n * @link      https://github.com/fusioninventory/fusioninventory-for-glpi\n *\n */\n\nif (!defined('GLPI_ROOT')) {\n   die(\"Sorry. You can't access directly to this file\");\n}\n\n/**\n * Manage the functions used in many classes.\n **/\nclass PluginFusioninventoryToolbox {\n\n\n   /**\n    * Log if extra debug enabled\n    *\n    * @param string $file\n    * @param string $message\n    */\n   static function logIfExtradebug($file, $message) {\n      $config = new PluginFusioninventoryConfig();\n      if (PluginFusioninventoryConfig::isExtradebugActive()) {\n         if (is_array($message)) {\n            $message = print_r($message, true);\n         }\n         Toolbox::logInFile($file, $message . \"\\n\", true);\n      }\n   }\n\n\n\n   /** Function get on http://www.php.net/manual/en/function.gzdecode.php#82930\n    *  used to uncompress gzip string\n    *\n    * @param string $data\n    * @param string $filename\n    * @param string $error\n    * @param null|integer $maxlength\n    * @return null|false|string\n    */\n   static function gzdecode($data, &$filename = '', &$error = '', $maxlength = null) {\n       $len = strlen($data);\n      if ($len < 18 || strcmp(substr($data, 0, 2), \"\\x1f\\x8b\")) {\n         $error = \"Not in GZIP format.\";\n         return null;  // Not GZIP format (See RFC 1952)\n      }\n       $method = ord(substr($data, 2, 1));  // Compression method\n       $flags  = ord(substr($data, 3, 1));  // Flags\n      if ($flags & 31 != $flags) {\n         $error = \"Reserved bits not allowed.\";\n         return null;\n      }\n       // NOTE: $mtime may be negative (PHP integer limitations)\n      //       $a_mtime = unpack(\"V\", substr($data, 4, 4));\n      //       $mtime = $a_mtime[1];\n       $headerlen = 10;\n       $extralen  = 0;\n       $extra     = \"\";\n      if ($flags & 4) {\n         // 2-byte length prefixed EXTRA data in header\n         if ($len - $headerlen - 2 < 8) {\n            return false;  // invalid\n         }\n         $a_extralen = unpack(\"v\", substr($data, 8, 2));\n         $extralen = $a_extralen[1];\n         if ($len - $headerlen - 2 - $extralen < 8) {\n            return false;  // invalid\n         }\n         $extra = substr($data, 10, $extralen);\n         $headerlen += 2 + $extralen;\n      }\n       $filenamelen = 0;\n       $filename = \"\";\n      if ($flags & 8) {\n         // C-style string\n         if ($len - $headerlen - 1 < 8) {\n            return false; // invalid\n         }\n         $filenamelen = strpos(substr($data, $headerlen), chr(0));\n         if ($filenamelen === false || $len - $headerlen - $filenamelen - 1 < 8) {\n            return false; // invalid\n         }\n         $filename = substr($data, $headerlen, $filenamelen);\n         $headerlen += $filenamelen + 1;\n      }\n       $commentlen = 0;\n       $comment = \"\";\n      if ($flags & 16) {\n         // C-style string COMMENT data in header\n         if ($len - $headerlen - 1 < 8) {\n            return false;    // invalid\n         }\n         $commentlen = strpos(substr($data, $headerlen), chr(0));\n         if ($commentlen === false || $len - $headerlen - $commentlen - 1 < 8) {\n            return false;    // Invalid header format\n         }\n         $comment = substr($data, $headerlen, $commentlen);\n         $headerlen += $commentlen + 1;\n      }\n       $headercrc = \"\";\n      if ($flags & 2) {\n         // 2-bytes (lowest order) of CRC32 on header present\n         if ($len - $headerlen - 2 < 8) {\n            return false;    // invalid\n         }\n         $calccrc = crc32(substr($data, 0, $headerlen)) & 0xffff;\n         $a_headercrc = unpack(\"v\", substr($data, $headerlen, 2));\n         $headercrc = $a_headercrc[1];\n         if ($headercrc != $calccrc) {\n            $error = \"Header checksum failed.\";\n            return false;    // Bad header CRC\n         }\n         $headerlen += 2;\n      }\n       // GZIP FOOTER\n       $a_datacrc = unpack(\"V\", substr($data, -8, 4));\n       $datacrc = sprintf('%u', $a_datacrc[1] & 0xFFFFFFFF);\n       $a_isize = unpack(\"V\", substr($data, -4));\n       $isize = $a_isize[1];\n       // decompression:\n       $bodylen = $len-$headerlen-8;\n      if ($bodylen < 1) {\n         // IMPLEMENTATION BUG!\n         return null;\n      }\n       $body = substr($data, $headerlen, $bodylen);\n       $data = \"\";\n      if ($bodylen > 0) {\n         switch ($method) {\n            case 8:\n               // Currently the only supported compression method:\n               $data = gzinflate($body, $maxlength);\n               break;\n            default:\n               $error = \"Unknown compression method.\";\n               return false;\n         }\n      }  // zero-byte body content is allowed\n       // Verifiy CRC32\n       $crc   = sprintf(\"%u\", crc32($data));\n       $crcOK = $crc == $datacrc;\n       $lenOK = $isize == strlen($data);\n      if (!$lenOK || !$crcOK) {\n         $error = ( $lenOK ? '' : 'Length check FAILED. ') . ( $crcOK ? '' : 'Checksum FAILED.');\n         return false;\n      }\n       return $data;\n   }\n\n\n   /**\n    * Merge 2 simpleXML objects\n    *\n    * @staticvar boolean $firstLoop\n    * @param object $simplexml_to simplexml instance source\n    * @param object $simplexml_from simplexml instance destination\n    */\n   static function appendSimplexml(&$simplexml_to, &$simplexml_from) {\n      static $firstLoop=true;\n\n      //Here adding attributes to parent\n      if ($firstLoop) {\n         foreach ($simplexml_from->attributes() as $attr_key => $attr_value) {\n            $simplexml_to->addAttribute($attr_key, $attr_value);\n         }\n      }\n      foreach ($simplexml_from->children() as $simplexml_child) {\n         $simplexml_temp = $simplexml_to->addChild($simplexml_child->getName(),\n                                                  (string)$simplexml_child);\n         foreach ($simplexml_child->attributes() as $attr_key => $attr_value) {\n            $simplexml_temp->addAttribute($attr_key, $attr_value);\n         }\n         $firstLoop=false;\n         self::appendSimplexml($simplexml_temp, $simplexml_child);\n      }\n      unset($firstLoop);\n   }\n\n\n   /**\n    * Clean XML, ie convert to be insert without problem into MySQL database\n    *\n    * @param object $xml SimpleXMLElement instance\n    * @return object SimpleXMLElement instance\n    */\n   function cleanXML($xml) {\n      $nodes = [];\n      foreach ($xml->children() as $key=>$value) {\n         if (!isset($nodes[$key])) {\n            $nodes[$key] = 0;\n         }\n         $nodes[$key]++;\n      }\n      foreach ($nodes as $key=>$nb) {\n         if ($nb < 2) {\n            unset($nodes[$key]);\n         }\n      }\n\n      if (count($xml) > 0) {\n         $i = 0;\n         foreach ($xml->children() as $key=>$value) {\n            if (count($value->children()) > 0) {\n               $this->cleanXML($value);\n            } else if (isset($nodes[$key])) {\n               $xml->$key->$i = Toolbox::clean_cross_side_scripting_deep(\n                                    Toolbox::addslashes_deep($value));\n               $i++;\n            } else {\n               $xml->$key = Toolbox::clean_cross_side_scripting_deep(\n                                 Toolbox::addslashes_deep($value));\n            }\n         }\n      }\n      return $xml;\n   }\n\n\n   /**\n    * Format XML, ie indent it for pretty printing\n    *\n    * @param object $xml simplexml instance\n    * @return string\n    */\n   static function formatXML($xml) {\n      $string     = str_replace(\"><\", \">\\n<\", $xml->asXML());\n      $token      = strtok($string, \"\\n\");\n      $result     = '';\n      $pad        = 0;\n      $matches    = [];\n      $indent     = 0;\n\n      while ($token !== false) {\n         // 1. open and closing tags on same line - no change\n         if (preg_match('/.+<\\/\\w[^>]*>$/', $token, $matches)) {\n            $indent=0;\n            // 2. closing tag - outdent now\n         } else if (preg_match('/^<\\/\\w/', $token, $matches)) {\n            $pad = $pad-3;\n            // 3. opening tag - don't pad this one, only subsequent tags\n         } else if (preg_match('/^<\\w[^>]*[^\\/]>.*$/', $token, $matches)) {\n            $indent=3;\n         } else {\n            $indent = 0;\n         }\n\n         $line    = Toolbox::str_pad($token, strlen($token)+$pad, '  ', STR_PAD_LEFT);\n         $result .= $line . \"\\n\";\n         $token   = strtok(\"\\n\");\n         $pad    += $indent;\n         $indent = 0;\n      }\n\n      return $result;\n   }\n\n\n   /**\n    * Write XML in a folder from an inventory by agent\n    *\n    * @param integer $items_id id of the unmanaged device\n    * @param string $xml xml informations (with XML structure)\n    * @param string $itemtype\n    */\n   static function writeXML($items_id, $xml, $itemtype) {\n\n      $folder = substr($items_id, 0, -1);\n      if (empty($folder)) {\n         $folder = '0';\n      }\n      if (!file_exists(PLUGIN_FUSIONINVENTORY_XML_DIR)) {\n         mkdir(PLUGIN_FUSIONINVENTORY_XML_DIR);\n      }\n      $itemtype_dir = PLUGIN_FUSIONINVENTORY_XML_DIR.strtolower($itemtype);\n      if (!file_exists($itemtype_dir)) {\n         mkdir($itemtype_dir);\n      }\n      if (!file_exists($itemtype_dir.\"/\".$folder)) {\n         mkdir($itemtype_dir.\"/\".$folder);\n      }\n      $file     = $itemtype_dir.\"/\".$folder.\"/\".$items_id.'.xml';\n      $fileopen = fopen($file, 'w');\n      fwrite($fileopen, $xml);\n      fclose($fileopen);\n   }\n\n\n   /**\n    * Add AUTHENTICATION string to XML node\n    *\n    * @param object $p_sxml_node XML node to authenticate\n    * @param integer $p_id Authenticate id\n    **/\n   function addAuth($p_sxml_node, $p_id) {\n      $pfConfigSecurity = new PluginFusioninventoryConfigSecurity();\n      if ($pfConfigSecurity->getFromDB($p_id)) {\n\n         $sxml_authentication = $p_sxml_node->addChild('AUTHENTICATION');\n\n         $sxml_authentication->addAttribute('ID', $p_id);\n         $sxml_authentication->addAttribute('VERSION',\n                    $pfConfigSecurity->getSNMPVersion($pfConfigSecurity->fields['snmpversion']));\n         if ($pfConfigSecurity->fields['snmpversion'] == '3') {\n            $sxml_authentication->addAttribute('USERNAME',\n                                               $pfConfigSecurity->fields['username']);\n            if ($pfConfigSecurity->fields['authentication'] != '0') {\n               $sxml_authentication->addAttribute('AUTHPROTOCOL',\n                      $pfConfigSecurity->getSNMPAuthProtocol(\n                              $pfConfigSecurity->fields['authentication']));\n            }\n            $sxml_authentication->addAttribute('AUTHPASSPHRASE',\n                                               $pfConfigSecurity->fields['auth_passphrase']);\n            if ($pfConfigSecurity->fields['encryption'] != '0') {\n               $sxml_authentication->addAttribute('PRIVPROTOCOL',\n                              $pfConfigSecurity->getSNMPEncryption(\n                                       $pfConfigSecurity->fields['encryption']));\n            }\n            $sxml_authentication->addAttribute('PRIVPASSPHRASE',\n                                                $pfConfigSecurity->fields['priv_passphrase']);\n         } else {\n            $sxml_authentication->addAttribute('COMMUNITY',\n                                               $pfConfigSecurity->fields['community']);\n         }\n      }\n   }\n\n\n   /**\n    * Add GET oids to XML node 'GET'\n    *\n    * @param object $p_sxml_node\n    * @param string $p_object\n    * @param string $p_oid\n    * @param string $p_link\n    * @param string $p_vlan\n    */\n   function addGet($p_sxml_node, $p_object, $p_oid, $p_link, $p_vlan) {\n      $sxml_get = $p_sxml_node->addChild('GET');\n         $sxml_get->addAttribute('OBJECT', $p_object);\n         $sxml_get->addAttribute('OID', $p_oid);\n         $sxml_get->addAttribute('VLAN', $p_vlan);\n         $sxml_get->addAttribute('LINK', $p_link);\n   }\n\n\n   /**\n    * Add WALK (multiple oids) oids to XML node 'WALK'\n    *\n    * @param object $p_sxml_node\n    * @param string $p_object\n    * @param string $p_oid\n    * @param string $p_link\n    * @param string $p_vlan\n    */\n   function addWalk($p_sxml_node, $p_object, $p_oid, $p_link, $p_vlan) {\n      $sxml_walk = $p_sxml_node->addChild('WALK');\n         $sxml_walk->addAttribute('OBJECT', $p_object);\n         $sxml_walk->addAttribute('OID', $p_oid);\n         $sxml_walk->addAttribute('VLAN', $p_vlan);\n         $sxml_walk->addAttribute('LINK', $p_link);\n   }\n\n\n   /**\n    * Get IP for device\n    *\n    * @param string $itemtype\n    * @param integer $items_id\n    * @return array\n    */\n   static function getIPforDevice($itemtype, $items_id) {\n      $NetworkPort = new NetworkPort();\n      $networkName = new NetworkName();\n      $iPAddress   = new IPAddress();\n\n      $a_ips = [];\n      $a_ports = $NetworkPort->find(\n            ['itemtype'           => $itemtype,\n             'items_id'           => $items_id,\n             'instantiation_type' => ['!=', 'NetworkPortLocal']]);\n      foreach ($a_ports as $a_port) {\n         $a_networknames = $networkName->find(\n               ['itemtype' => 'NetworkPort',\n                'items_id' => $a_port['id']]);\n         foreach ($a_networknames as $a_networkname) {\n            $a_ipaddresses = $iPAddress->find(\n                  ['itemtype' => 'NetworkName',\n                   'items_id' => $a_networkname['id']]);\n            foreach ($a_ipaddresses as $data) {\n               if ($data['name'] != '127.0.0.1'\n                       && $data['name'] != '::1') {\n                  $a_ips[$data['name']] = $data['name'];\n               }\n            }\n         }\n      }\n      return array_unique($a_ips);\n   }\n\n\n   // *********************** Functions used for inventory *********************** //\n\n\n   /**\n    * Check lock\n    *\n    * @param array $data\n    * @param array $db_data\n    * @param array $a_lockable\n    * @return array\n    */\n   static function checkLock($data, $db_data, $a_lockable = []) {\n      foreach ($a_lockable as $field) {\n         if (isset($data[$field])) {\n            unset($data[$field]);\n         }\n         if (isset($db_data[$field])) {\n            unset($db_data[$field]);\n         }\n      }\n      return [$data, $db_data];\n   }\n\n\n   /**\n    * Display data from serialized inventory field\n    *\n    * @param array $array\n    */\n   static function displaySerializedValues($array) {\n\n      foreach ($array as $key=>$value) {\n         echo \"<tr class='tab_bg_1'>\";\n         echo \"<th>\";\n         echo $key;\n         echo \"</th>\";\n         echo \"<td>\";\n         if (is_array($value)) {\n            echo \"<table class='tab_cadre' width='100%'>\";\n            PluginFusioninventoryToolbox::displaySerializedValues($value);\n            echo \"</table>\";\n         } else {\n            echo $value;\n         }\n         echo \"</td>\";\n         echo \"</tr>\";\n      }\n   }\n\n\n   /**\n    * Send serialized inventory to user browser (to download)\n    *\n    * @param integer $items_id\n    * @param string $itemtype\n    */\n   static function sendSerializedInventory($items_id, $itemtype) {\n      header('Content-type: text/plain');\n\n      if (call_user_func([$itemtype, 'canView'])) {\n         $item = new $itemtype();\n         $item->getFromDB($items_id);\n         echo gzuncompress($item->fields['serialized_inventory']);\n      } else {\n         Html::displayRightError();\n      }\n   }\n\n\n   /**\n    * Send the XML (last inventory) to user browser (to download)\n    *\n    * @param integer $items_id\n    * @param string $itemtype\n    */\n   static function sendXML($items_id, $itemtype) {\n      if (call_user_func([$itemtype, 'canView'])) {\n         $xml = file_get_contents(GLPI_PLUGIN_DOC_DIR.\"/fusioninventory/xml/\".$items_id);\n         echo $xml;\n      } else {\n         Html::displayRightError();\n      }\n\n   }\n\n\n   /**\n    *  This function fetch rows from a MySQL result in an array with each table as a key\n    *\n    *  example:\n    *  $query =\n    *     \"SELECT table_a.*,table_b.* \".\n    *     \"FROM table_b \".\n    *     \"LEFT JOIN table_a ON table_a.id = table_b.linked_id\";\n    *  $result = mysqli_query( $query );\n    *  print_r( fetchTableAssoc( $result ) )\n    *\n    *  output:\n    *  $results = Array\n    *     (\n    *        [0] => Array\n    *           (\n    *              [table_a] => Array\n    *                 (\n    *                    [id] => 1\n    *                 )\n    *              [table_b] => Array\n    *                 (\n    *                    [id] => 2\n    *                    [linked_id] => 1\n    *                 )\n    *           )\n    *           ...\n    *     )\n    *\n    * @param object $mysql_result\n    * @return array\n    */\n   static function fetchAssocByTable($mysql_result) {\n      $results = [];\n      //get fields header infos\n      $fields = mysqli_fetch_fields($mysql_result);\n      //associate row data as array[table][field]\n      while ($row = mysqli_fetch_row($mysql_result)) {\n         $result = [];\n         for ($i=0; $i < count( $row ); $i++) {\n            $tname = $fields[$i]->table;\n            $fname = $fields[$i]->name;\n            if (!isset($result[$tname])) {\n               $result[$tname] = [];\n            }\n            $result[$tname][$fname] = $row[$i];\n         }\n         if (count($result) > 0) {\n            $results[] = $result;\n         }\n      }\n      return $results;\n   }\n\n\n   /**\n    * Format a json in a pretty json\n    *\n    * @param string $json\n    * @return string\n    */\n   static function formatJson($json) {\n      $version = phpversion();\n\n      if (version_compare($version, '5.4', 'lt')) {\n         return pretty_json($json);\n      } else if (version_compare($version, '5.4', 'ge')) {\n         return json_encode(\n            json_decode($json, true),\n            JSON_PRETTY_PRINT\n         );\n      }\n   }\n\n\n   /**\n    * Dropdown for display hours\n    *\n    * @param string $name\n    * @param array $options\n    * @return string unique html element id\n    */\n   static function showHours($name, $options = []) {\n\n      $p['value']          = '';\n      $p['display']        = true;\n      $p['width']          = '80%';\n      $p['step']           = 5;\n      $p['begin']          = 0;\n      $p['end']            = (24 * 3600);\n\n      if (is_array($options) && count($options)) {\n         foreach ($options as $key => $val) {\n            $p[$key] = $val;\n         }\n      }\n      if ($p['step'] <= 0) {\n         $p['step'] = 5;\n      }\n\n      $values   = [];\n\n      $p['step'] = $p['step'] * 60; // to have in seconds\n      for ($s=$p['begin']; $s<=$p['end']; $s+=$p['step']) {\n         $values[$s] = PluginFusioninventoryToolbox::getHourMinute($s);\n      }\n      return Dropdown::showFromArray($name, $values, $p);\n   }\n\n\n   /**\n    * Get hour:minute from number of seconds\n    *\n    * @param integer $seconds\n    * @return string\n    */\n   static function getHourMinute($seconds) {\n      $hour = floor($seconds / 3600);\n      $minute = (($seconds - ((floor($seconds / 3600)) * 3600)) / 60);\n      return sprintf(\"%02s\", $hour).\":\".sprintf(\"%02s\", $minute);\n   }\n\n\n   /**\n    * Get information if allow_url_fopen is activated and display message if not\n    *\n    * @param integer $wakecomputer (1 if it's for wakeonlan, 0 if it's for task)\n    * @return boolean\n    */\n   static function isAllowurlfopen($wakecomputer = 0) {\n\n      if (!ini_get('allow_url_fopen')) {\n         echo \"<center>\";\n         echo \"<table class='tab_cadre' height='30' width='700'>\";\n         echo \"<tr class='tab_bg_1'>\";\n         echo \"<td align='center'><strong>\";\n         if ($wakecomputer == '0') {\n            echo __('PHP allow_url_fopen is off, remote can\\'t work').\" !\";\n         } else {\n            echo __('PHP allow_url_fopen is off, can\\'t wake agent to do inventory').\" !\";\n         }\n         echo \"</strong></td>\";\n         echo \"</tr>\";\n         echo \"</table>\";\n         echo \"</center>\";\n         echo \"<br/>\";\n         return false;\n      }\n      return true;\n   }\n\n\n   /**\n    * Execute a function as Fusioninventory user\n    *\n    * @param string|array $function\n    * @param array $args\n    * @return string the normaly returned value from executed callable\n    */\n   function executeAsFusioninventoryUser($function, array $args = []) {\n\n      $config = new PluginFusioninventoryConfig();\n      $user = new User();\n\n      // Backup _SESSION environment\n      $OLD_SESSION = [];\n\n      foreach (['glpiID', 'glpiname','glpiactiveentities_string',\n          'glpiactiveentities', 'glpiparententities'] as $session_key) {\n         if (isset($_SESSION[$session_key])) {\n            $OLD_SESSION[$session_key] = $_SESSION[$session_key];\n         }\n      }\n\n      // Configure impersonation\n      $users_id  = $config->getValue('users_id');\n      $user->getFromDB($users_id);\n\n      $_SESSION['glpiID']   = $users_id;\n      $_SESSION['glpiname'] = $user->getField('name');\n      $_SESSION['glpiactiveentities'] = getSonsOf('glpi_entities', 0);\n      $_SESSION['glpiactiveentities_string'] =\n         \"'\". implode( \"', '\", $_SESSION['glpiactiveentities'] ).\"'\";\n      $_SESSION['glpiparententities'] = [];\n\n      // Execute function with impersonated SESSION\n      $result = call_user_func_array($function, $args);\n\n      // Restore SESSION\n      foreach ($OLD_SESSION as $key => $value) {\n         $_SESSION[$key] = $value;\n      }\n      // Return function results\n      return $result;\n   }\n\n\n   /**\n   * Check if an item is inventoried by FusionInventory\n   *\n   * @since 9.2\n   * @param CommonDBTM $item the item to check\n   * @return boolean true if handle by FusionInventory\n   */\n   static function isAFusionInventoryDevice($item) {\n      $table = '';\n      switch ($item->getType()) {\n         case 'Computer':\n            $table = 'glpi_plugin_fusioninventory_inventorycomputercomputers';\n            $fk    = 'computers_id';\n            break;\n\n         case 'NetworkEquipment':\n            $table = 'glpi_plugin_fusioninventory_networkequipments';\n            $fk    = 'networkequipments_id';\n            break;\n\n         case 'Printer':\n            $table = 'glpi_plugin_fusioninventory_printers';\n            $fk    = 'printers_id';\n            break;\n\n      }\n      if ($table) {\n         return $item->isDynamic()\n            && countElementsInTable($table, [$fk => $item->getID()]);\n      } else {\n         return 0;\n      }\n   }\n\n\n   /**\n    * Get default value for state of devices (monitor, printer...)\n    *\n    * @param string type the type of inventory performed (values : computer, snmp)\n    * @param array $input\n    * @return array the fields with the states_id filled, is necessary\n    */\n   static function addDefaultStateIfNeeded($type, $input) {\n      $config = new PluginFusioninventoryConfig();\n      switch ($type) {\n         case 'computer':\n            if ($states_id_default = $config->getValue(\"states_id_default\")) {\n               $input['states_id'] = $states_id_default;\n            }\n            break;\n\n         case 'snmp':\n            if ($states_id_snmp_default = $config->getValue(\"states_id_snmp_default\")) {\n               $input['states_id'] = $states_id_snmp_default;\n            }\n            break;\n\n         default:\n            $state = false;\n            break;\n      }\n      return $input;\n   }\n\n   /**\n    * Add a location if required by a rule\n    * @since 9.2+2.0\n    *\n    * @param array $input fields of the asset being inventoried\n    * @param array $output output array in which the location should be added (optionnal)\n    * @return array the fields with the locations_id filled, is necessary\n    */\n   static function addLocation($input, $output = false) {\n      //manage location\n      $ruleLocation = new PluginFusioninventoryInventoryRuleLocationCollection();\n\n      // * Reload rules (required for unit tests)\n      $ruleLocation->getCollectionPart();\n\n      $dataLocation = $ruleLocation->processAllRules($input);\n      if (isset($dataLocation['locations_id'])) {\n         if ($output) {\n            $output['locations_id'] = $dataLocation['locations_id'];\n         } else {\n            $input['locations_id'] = $dataLocation['locations_id'];\n         }\n      }\n      return ($output?$output:$input);\n   }\n}\n"], "fixing_code": ["<?php\n\n/**\n * FusionInventory\n *\n * Copyright (C) 2010-2016 by the FusionInventory Development Team.\n *\n * http://www.fusioninventory.org/\n * https://github.com/fusioninventory/fusioninventory-for-glpi\n * http://forge.fusioninventory.org/\n *\n * ------------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of FusionInventory project.\n *\n * FusionInventory is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * FusionInventory is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with FusionInventory. If not, see <http://www.gnu.org/licenses/>.\n *\n * ------------------------------------------------------------------------\n *\n * This file is used to send the inventory to user browser.\n *\n * ------------------------------------------------------------------------\n *\n * @package   FusionInventory\n * @author    Vincent Mazzoni\n * @author    David Durieux\n * @copyright Copyright (c) 2010-2016 FusionInventory team\n * @license   AGPL License 3.0 or (at your option) any later version\n *            http://www.gnu.org/licenses/agpl-3.0-standalone.html\n * @link      http://www.fusioninventory.org/\n * @link      https://github.com/fusioninventory/fusioninventory-for-glpi\n *\n */\n\ninclude (\"../../../inc/includes.php\");\n\n//Session::checkRight('config', \"w\");\n\n$itemtype = $_GET['itemtype'];\n$items_id = $_GET['items_id'];\n\nheader('Cache-control: private, must-revalidate'); /// IE BUG + SSL\nheader('Content-disposition: attachment; filename='.$_GET['filename']);\nheader('Content-type: text/plain');\n\n\ncall_user_func(['PluginFusioninventoryToolbox', 'sendXML'], $items_id, $itemtype);\n\n", "<?php\n\n/**\n * FusionInventory\n *\n * Copyright (C) 2010-2016 by the FusionInventory Development Team.\n *\n * http://www.fusioninventory.org/\n * https://github.com/fusioninventory/fusioninventory-for-glpi\n * http://forge.fusioninventory.org/\n *\n * ------------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of FusionInventory project.\n *\n * FusionInventory is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * FusionInventory is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with FusionInventory. If not, see <http://www.gnu.org/licenses/>.\n *\n * ------------------------------------------------------------------------\n *\n * This file is used to manage the functions used in many classes.\n *\n * ------------------------------------------------------------------------\n *\n * @package   FusionInventory\n * @author    Vincent Mazzoni\n * @author    David Durieux\n * @copyright Copyright (c) 2010-2016 FusionInventory team\n * @license   AGPL License 3.0 or (at your option) any later version\n *            http://www.gnu.org/licenses/agpl-3.0-standalone.html\n * @link      http://www.fusioninventory.org/\n * @link      https://github.com/fusioninventory/fusioninventory-for-glpi\n *\n */\n\nif (!defined('GLPI_ROOT')) {\n   die(\"Sorry. You can't access directly to this file\");\n}\n\n/**\n * Manage the functions used in many classes.\n **/\nclass PluginFusioninventoryToolbox {\n\n\n   /**\n    * Log if extra debug enabled\n    *\n    * @param string $file\n    * @param string $message\n    */\n   static function logIfExtradebug($file, $message) {\n      $config = new PluginFusioninventoryConfig();\n      if (PluginFusioninventoryConfig::isExtradebugActive()) {\n         if (is_array($message)) {\n            $message = print_r($message, true);\n         }\n         Toolbox::logInFile($file, $message . \"\\n\", true);\n      }\n   }\n\n\n\n   /** Function get on http://www.php.net/manual/en/function.gzdecode.php#82930\n    *  used to uncompress gzip string\n    *\n    * @param string $data\n    * @param string $filename\n    * @param string $error\n    * @param null|integer $maxlength\n    * @return null|false|string\n    */\n   static function gzdecode($data, &$filename = '', &$error = '', $maxlength = null) {\n       $len = strlen($data);\n      if ($len < 18 || strcmp(substr($data, 0, 2), \"\\x1f\\x8b\")) {\n         $error = \"Not in GZIP format.\";\n         return null;  // Not GZIP format (See RFC 1952)\n      }\n       $method = ord(substr($data, 2, 1));  // Compression method\n       $flags  = ord(substr($data, 3, 1));  // Flags\n      if ($flags & 31 != $flags) {\n         $error = \"Reserved bits not allowed.\";\n         return null;\n      }\n       // NOTE: $mtime may be negative (PHP integer limitations)\n      //       $a_mtime = unpack(\"V\", substr($data, 4, 4));\n      //       $mtime = $a_mtime[1];\n       $headerlen = 10;\n       $extralen  = 0;\n       $extra     = \"\";\n      if ($flags & 4) {\n         // 2-byte length prefixed EXTRA data in header\n         if ($len - $headerlen - 2 < 8) {\n            return false;  // invalid\n         }\n         $a_extralen = unpack(\"v\", substr($data, 8, 2));\n         $extralen = $a_extralen[1];\n         if ($len - $headerlen - 2 - $extralen < 8) {\n            return false;  // invalid\n         }\n         $extra = substr($data, 10, $extralen);\n         $headerlen += 2 + $extralen;\n      }\n       $filenamelen = 0;\n       $filename = \"\";\n      if ($flags & 8) {\n         // C-style string\n         if ($len - $headerlen - 1 < 8) {\n            return false; // invalid\n         }\n         $filenamelen = strpos(substr($data, $headerlen), chr(0));\n         if ($filenamelen === false || $len - $headerlen - $filenamelen - 1 < 8) {\n            return false; // invalid\n         }\n         $filename = substr($data, $headerlen, $filenamelen);\n         $headerlen += $filenamelen + 1;\n      }\n       $commentlen = 0;\n       $comment = \"\";\n      if ($flags & 16) {\n         // C-style string COMMENT data in header\n         if ($len - $headerlen - 1 < 8) {\n            return false;    // invalid\n         }\n         $commentlen = strpos(substr($data, $headerlen), chr(0));\n         if ($commentlen === false || $len - $headerlen - $commentlen - 1 < 8) {\n            return false;    // Invalid header format\n         }\n         $comment = substr($data, $headerlen, $commentlen);\n         $headerlen += $commentlen + 1;\n      }\n       $headercrc = \"\";\n      if ($flags & 2) {\n         // 2-bytes (lowest order) of CRC32 on header present\n         if ($len - $headerlen - 2 < 8) {\n            return false;    // invalid\n         }\n         $calccrc = crc32(substr($data, 0, $headerlen)) & 0xffff;\n         $a_headercrc = unpack(\"v\", substr($data, $headerlen, 2));\n         $headercrc = $a_headercrc[1];\n         if ($headercrc != $calccrc) {\n            $error = \"Header checksum failed.\";\n            return false;    // Bad header CRC\n         }\n         $headerlen += 2;\n      }\n       // GZIP FOOTER\n       $a_datacrc = unpack(\"V\", substr($data, -8, 4));\n       $datacrc = sprintf('%u', $a_datacrc[1] & 0xFFFFFFFF);\n       $a_isize = unpack(\"V\", substr($data, -4));\n       $isize = $a_isize[1];\n       // decompression:\n       $bodylen = $len-$headerlen-8;\n      if ($bodylen < 1) {\n         // IMPLEMENTATION BUG!\n         return null;\n      }\n       $body = substr($data, $headerlen, $bodylen);\n       $data = \"\";\n      if ($bodylen > 0) {\n         switch ($method) {\n            case 8:\n               // Currently the only supported compression method:\n               $data = gzinflate($body, $maxlength);\n               break;\n            default:\n               $error = \"Unknown compression method.\";\n               return false;\n         }\n      }  // zero-byte body content is allowed\n       // Verifiy CRC32\n       $crc   = sprintf(\"%u\", crc32($data));\n       $crcOK = $crc == $datacrc;\n       $lenOK = $isize == strlen($data);\n      if (!$lenOK || !$crcOK) {\n         $error = ( $lenOK ? '' : 'Length check FAILED. ') . ( $crcOK ? '' : 'Checksum FAILED.');\n         return false;\n      }\n       return $data;\n   }\n\n\n   /**\n    * Merge 2 simpleXML objects\n    *\n    * @staticvar boolean $firstLoop\n    * @param object $simplexml_to simplexml instance source\n    * @param object $simplexml_from simplexml instance destination\n    */\n   static function appendSimplexml(&$simplexml_to, &$simplexml_from) {\n      static $firstLoop=true;\n\n      //Here adding attributes to parent\n      if ($firstLoop) {\n         foreach ($simplexml_from->attributes() as $attr_key => $attr_value) {\n            $simplexml_to->addAttribute($attr_key, $attr_value);\n         }\n      }\n      foreach ($simplexml_from->children() as $simplexml_child) {\n         $simplexml_temp = $simplexml_to->addChild($simplexml_child->getName(),\n                                                  (string)$simplexml_child);\n         foreach ($simplexml_child->attributes() as $attr_key => $attr_value) {\n            $simplexml_temp->addAttribute($attr_key, $attr_value);\n         }\n         $firstLoop=false;\n         self::appendSimplexml($simplexml_temp, $simplexml_child);\n      }\n      unset($firstLoop);\n   }\n\n\n   /**\n    * Clean XML, ie convert to be insert without problem into MySQL database\n    *\n    * @param object $xml SimpleXMLElement instance\n    * @return object SimpleXMLElement instance\n    */\n   function cleanXML($xml) {\n      $nodes = [];\n      foreach ($xml->children() as $key=>$value) {\n         if (!isset($nodes[$key])) {\n            $nodes[$key] = 0;\n         }\n         $nodes[$key]++;\n      }\n      foreach ($nodes as $key=>$nb) {\n         if ($nb < 2) {\n            unset($nodes[$key]);\n         }\n      }\n\n      if (count($xml) > 0) {\n         $i = 0;\n         foreach ($xml->children() as $key=>$value) {\n            if (count($value->children()) > 0) {\n               $this->cleanXML($value);\n            } else if (isset($nodes[$key])) {\n               $xml->$key->$i = Toolbox::clean_cross_side_scripting_deep(\n                                    Toolbox::addslashes_deep($value));\n               $i++;\n            } else {\n               $xml->$key = Toolbox::clean_cross_side_scripting_deep(\n                                 Toolbox::addslashes_deep($value));\n            }\n         }\n      }\n      return $xml;\n   }\n\n\n   /**\n    * Format XML, ie indent it for pretty printing\n    *\n    * @param object $xml simplexml instance\n    * @return string\n    */\n   static function formatXML($xml) {\n      $string     = str_replace(\"><\", \">\\n<\", $xml->asXML());\n      $token      = strtok($string, \"\\n\");\n      $result     = '';\n      $pad        = 0;\n      $matches    = [];\n      $indent     = 0;\n\n      while ($token !== false) {\n         // 1. open and closing tags on same line - no change\n         if (preg_match('/.+<\\/\\w[^>]*>$/', $token, $matches)) {\n            $indent=0;\n            // 2. closing tag - outdent now\n         } else if (preg_match('/^<\\/\\w/', $token, $matches)) {\n            $pad = $pad-3;\n            // 3. opening tag - don't pad this one, only subsequent tags\n         } else if (preg_match('/^<\\w[^>]*[^\\/]>.*$/', $token, $matches)) {\n            $indent=3;\n         } else {\n            $indent = 0;\n         }\n\n         $line    = Toolbox::str_pad($token, strlen($token)+$pad, '  ', STR_PAD_LEFT);\n         $result .= $line . \"\\n\";\n         $token   = strtok(\"\\n\");\n         $pad    += $indent;\n         $indent = 0;\n      }\n\n      return $result;\n   }\n\n\n   /**\n    * Write XML in a folder from an inventory by agent\n    *\n    * @param integer $items_id id of the unmanaged device\n    * @param string $xml xml informations (with XML structure)\n    * @param string $itemtype\n    */\n   static function writeXML($items_id, $xml, $itemtype) {\n\n      $folder = substr($items_id, 0, -1);\n      if (empty($folder)) {\n         $folder = '0';\n      }\n      if (!file_exists(PLUGIN_FUSIONINVENTORY_XML_DIR)) {\n         mkdir(PLUGIN_FUSIONINVENTORY_XML_DIR);\n      }\n      $itemtype_dir = PLUGIN_FUSIONINVENTORY_XML_DIR.strtolower($itemtype);\n      if (!file_exists($itemtype_dir)) {\n         mkdir($itemtype_dir);\n      }\n      if (!file_exists($itemtype_dir.\"/\".$folder)) {\n         mkdir($itemtype_dir.\"/\".$folder);\n      }\n      $file     = $itemtype_dir.\"/\".$folder.\"/\".$items_id.'.xml';\n      $fileopen = fopen($file, 'w');\n      fwrite($fileopen, $xml);\n      fclose($fileopen);\n   }\n\n\n   /**\n    * Add AUTHENTICATION string to XML node\n    *\n    * @param object $p_sxml_node XML node to authenticate\n    * @param integer $p_id Authenticate id\n    **/\n   function addAuth($p_sxml_node, $p_id) {\n      $pfConfigSecurity = new PluginFusioninventoryConfigSecurity();\n      if ($pfConfigSecurity->getFromDB($p_id)) {\n\n         $sxml_authentication = $p_sxml_node->addChild('AUTHENTICATION');\n\n         $sxml_authentication->addAttribute('ID', $p_id);\n         $sxml_authentication->addAttribute('VERSION',\n                    $pfConfigSecurity->getSNMPVersion($pfConfigSecurity->fields['snmpversion']));\n         if ($pfConfigSecurity->fields['snmpversion'] == '3') {\n            $sxml_authentication->addAttribute('USERNAME',\n                                               $pfConfigSecurity->fields['username']);\n            if ($pfConfigSecurity->fields['authentication'] != '0') {\n               $sxml_authentication->addAttribute('AUTHPROTOCOL',\n                      $pfConfigSecurity->getSNMPAuthProtocol(\n                              $pfConfigSecurity->fields['authentication']));\n            }\n            $sxml_authentication->addAttribute('AUTHPASSPHRASE',\n                                               $pfConfigSecurity->fields['auth_passphrase']);\n            if ($pfConfigSecurity->fields['encryption'] != '0') {\n               $sxml_authentication->addAttribute('PRIVPROTOCOL',\n                              $pfConfigSecurity->getSNMPEncryption(\n                                       $pfConfigSecurity->fields['encryption']));\n            }\n            $sxml_authentication->addAttribute('PRIVPASSPHRASE',\n                                                $pfConfigSecurity->fields['priv_passphrase']);\n         } else {\n            $sxml_authentication->addAttribute('COMMUNITY',\n                                               $pfConfigSecurity->fields['community']);\n         }\n      }\n   }\n\n\n   /**\n    * Add GET oids to XML node 'GET'\n    *\n    * @param object $p_sxml_node\n    * @param string $p_object\n    * @param string $p_oid\n    * @param string $p_link\n    * @param string $p_vlan\n    */\n   function addGet($p_sxml_node, $p_object, $p_oid, $p_link, $p_vlan) {\n      $sxml_get = $p_sxml_node->addChild('GET');\n         $sxml_get->addAttribute('OBJECT', $p_object);\n         $sxml_get->addAttribute('OID', $p_oid);\n         $sxml_get->addAttribute('VLAN', $p_vlan);\n         $sxml_get->addAttribute('LINK', $p_link);\n   }\n\n\n   /**\n    * Add WALK (multiple oids) oids to XML node 'WALK'\n    *\n    * @param object $p_sxml_node\n    * @param string $p_object\n    * @param string $p_oid\n    * @param string $p_link\n    * @param string $p_vlan\n    */\n   function addWalk($p_sxml_node, $p_object, $p_oid, $p_link, $p_vlan) {\n      $sxml_walk = $p_sxml_node->addChild('WALK');\n         $sxml_walk->addAttribute('OBJECT', $p_object);\n         $sxml_walk->addAttribute('OID', $p_oid);\n         $sxml_walk->addAttribute('VLAN', $p_vlan);\n         $sxml_walk->addAttribute('LINK', $p_link);\n   }\n\n\n   /**\n    * Get IP for device\n    *\n    * @param string $itemtype\n    * @param integer $items_id\n    * @return array\n    */\n   static function getIPforDevice($itemtype, $items_id) {\n      $NetworkPort = new NetworkPort();\n      $networkName = new NetworkName();\n      $iPAddress   = new IPAddress();\n\n      $a_ips = [];\n      $a_ports = $NetworkPort->find(\n            ['itemtype'           => $itemtype,\n             'items_id'           => $items_id,\n             'instantiation_type' => ['!=', 'NetworkPortLocal']]);\n      foreach ($a_ports as $a_port) {\n         $a_networknames = $networkName->find(\n               ['itemtype' => 'NetworkPort',\n                'items_id' => $a_port['id']]);\n         foreach ($a_networknames as $a_networkname) {\n            $a_ipaddresses = $iPAddress->find(\n                  ['itemtype' => 'NetworkName',\n                   'items_id' => $a_networkname['id']]);\n            foreach ($a_ipaddresses as $data) {\n               if ($data['name'] != '127.0.0.1'\n                       && $data['name'] != '::1') {\n                  $a_ips[$data['name']] = $data['name'];\n               }\n            }\n         }\n      }\n      return array_unique($a_ips);\n   }\n\n\n   // *********************** Functions used for inventory *********************** //\n\n\n   /**\n    * Check lock\n    *\n    * @param array $data\n    * @param array $db_data\n    * @param array $a_lockable\n    * @return array\n    */\n   static function checkLock($data, $db_data, $a_lockable = []) {\n      foreach ($a_lockable as $field) {\n         if (isset($data[$field])) {\n            unset($data[$field]);\n         }\n         if (isset($db_data[$field])) {\n            unset($db_data[$field]);\n         }\n      }\n      return [$data, $db_data];\n   }\n\n\n   /**\n    * Display data from serialized inventory field\n    *\n    * @param array $array\n    */\n   static function displaySerializedValues($array) {\n\n      foreach ($array as $key=>$value) {\n         echo \"<tr class='tab_bg_1'>\";\n         echo \"<th>\";\n         echo $key;\n         echo \"</th>\";\n         echo \"<td>\";\n         if (is_array($value)) {\n            echo \"<table class='tab_cadre' width='100%'>\";\n            PluginFusioninventoryToolbox::displaySerializedValues($value);\n            echo \"</table>\";\n         } else {\n            echo $value;\n         }\n         echo \"</td>\";\n         echo \"</tr>\";\n      }\n   }\n\n\n   /**\n    * Send serialized inventory to user browser (to download)\n    *\n    * @param integer $items_id\n    * @param string $itemtype\n    */\n   static function sendSerializedInventory($items_id, $itemtype) {\n      header('Content-type: text/plain');\n\n      if (call_user_func([$itemtype, 'canView'])) {\n         $item = new $itemtype();\n         $item->getFromDB($items_id);\n         echo gzuncompress($item->fields['serialized_inventory']);\n      } else {\n         Html::displayRightError();\n      }\n   }\n\n\n   /**\n    * Send the XML (last inventory) to user browser (to download)\n    *\n    * @param integer $items_id\n    * @param string $itemtype\n    */\n   static function sendXML($items_id, $itemtype) {\n      if (preg_match(\"/^([a-zA-Z]+)\\/(\\d+)\\/(\\d+)\\.xml$/\", $items_id)\n         && call_user_func([$itemtype, 'canView'])) {\n         $xml = file_get_contents(GLPI_PLUGIN_DOC_DIR.\"/fusioninventory/xml/\".$items_id);\n         echo $xml;\n      } else {\n         Html::displayRightError();\n      }\n\n   }\n\n\n   /**\n    *  This function fetch rows from a MySQL result in an array with each table as a key\n    *\n    *  example:\n    *  $query =\n    *     \"SELECT table_a.*,table_b.* \".\n    *     \"FROM table_b \".\n    *     \"LEFT JOIN table_a ON table_a.id = table_b.linked_id\";\n    *  $result = mysqli_query( $query );\n    *  print_r( fetchTableAssoc( $result ) )\n    *\n    *  output:\n    *  $results = Array\n    *     (\n    *        [0] => Array\n    *           (\n    *              [table_a] => Array\n    *                 (\n    *                    [id] => 1\n    *                 )\n    *              [table_b] => Array\n    *                 (\n    *                    [id] => 2\n    *                    [linked_id] => 1\n    *                 )\n    *           )\n    *           ...\n    *     )\n    *\n    * @param object $mysql_result\n    * @return array\n    */\n   static function fetchAssocByTable($mysql_result) {\n      $results = [];\n      //get fields header infos\n      $fields = mysqli_fetch_fields($mysql_result);\n      //associate row data as array[table][field]\n      while ($row = mysqli_fetch_row($mysql_result)) {\n         $result = [];\n         for ($i=0; $i < count( $row ); $i++) {\n            $tname = $fields[$i]->table;\n            $fname = $fields[$i]->name;\n            if (!isset($result[$tname])) {\n               $result[$tname] = [];\n            }\n            $result[$tname][$fname] = $row[$i];\n         }\n         if (count($result) > 0) {\n            $results[] = $result;\n         }\n      }\n      return $results;\n   }\n\n\n   /**\n    * Format a json in a pretty json\n    *\n    * @param string $json\n    * @return string\n    */\n   static function formatJson($json) {\n      $version = phpversion();\n\n      if (version_compare($version, '5.4', 'lt')) {\n         return pretty_json($json);\n      } else if (version_compare($version, '5.4', 'ge')) {\n         return json_encode(\n            json_decode($json, true),\n            JSON_PRETTY_PRINT\n         );\n      }\n   }\n\n\n   /**\n    * Dropdown for display hours\n    *\n    * @param string $name\n    * @param array $options\n    * @return string unique html element id\n    */\n   static function showHours($name, $options = []) {\n\n      $p['value']          = '';\n      $p['display']        = true;\n      $p['width']          = '80%';\n      $p['step']           = 5;\n      $p['begin']          = 0;\n      $p['end']            = (24 * 3600);\n\n      if (is_array($options) && count($options)) {\n         foreach ($options as $key => $val) {\n            $p[$key] = $val;\n         }\n      }\n      if ($p['step'] <= 0) {\n         $p['step'] = 5;\n      }\n\n      $values   = [];\n\n      $p['step'] = $p['step'] * 60; // to have in seconds\n      for ($s=$p['begin']; $s<=$p['end']; $s+=$p['step']) {\n         $values[$s] = PluginFusioninventoryToolbox::getHourMinute($s);\n      }\n      return Dropdown::showFromArray($name, $values, $p);\n   }\n\n\n   /**\n    * Get hour:minute from number of seconds\n    *\n    * @param integer $seconds\n    * @return string\n    */\n   static function getHourMinute($seconds) {\n      $hour = floor($seconds / 3600);\n      $minute = (($seconds - ((floor($seconds / 3600)) * 3600)) / 60);\n      return sprintf(\"%02s\", $hour).\":\".sprintf(\"%02s\", $minute);\n   }\n\n\n   /**\n    * Get information if allow_url_fopen is activated and display message if not\n    *\n    * @param integer $wakecomputer (1 if it's for wakeonlan, 0 if it's for task)\n    * @return boolean\n    */\n   static function isAllowurlfopen($wakecomputer = 0) {\n\n      if (!ini_get('allow_url_fopen')) {\n         echo \"<center>\";\n         echo \"<table class='tab_cadre' height='30' width='700'>\";\n         echo \"<tr class='tab_bg_1'>\";\n         echo \"<td align='center'><strong>\";\n         if ($wakecomputer == '0') {\n            echo __('PHP allow_url_fopen is off, remote can\\'t work').\" !\";\n         } else {\n            echo __('PHP allow_url_fopen is off, can\\'t wake agent to do inventory').\" !\";\n         }\n         echo \"</strong></td>\";\n         echo \"</tr>\";\n         echo \"</table>\";\n         echo \"</center>\";\n         echo \"<br/>\";\n         return false;\n      }\n      return true;\n   }\n\n\n   /**\n    * Execute a function as Fusioninventory user\n    *\n    * @param string|array $function\n    * @param array $args\n    * @return string the normaly returned value from executed callable\n    */\n   function executeAsFusioninventoryUser($function, array $args = []) {\n\n      $config = new PluginFusioninventoryConfig();\n      $user = new User();\n\n      // Backup _SESSION environment\n      $OLD_SESSION = [];\n\n      foreach (['glpiID', 'glpiname','glpiactiveentities_string',\n          'glpiactiveentities', 'glpiparententities'] as $session_key) {\n         if (isset($_SESSION[$session_key])) {\n            $OLD_SESSION[$session_key] = $_SESSION[$session_key];\n         }\n      }\n\n      // Configure impersonation\n      $users_id  = $config->getValue('users_id');\n      $user->getFromDB($users_id);\n\n      $_SESSION['glpiID']   = $users_id;\n      $_SESSION['glpiname'] = $user->getField('name');\n      $_SESSION['glpiactiveentities'] = getSonsOf('glpi_entities', 0);\n      $_SESSION['glpiactiveentities_string'] =\n         \"'\". implode( \"', '\", $_SESSION['glpiactiveentities'] ).\"'\";\n      $_SESSION['glpiparententities'] = [];\n\n      // Execute function with impersonated SESSION\n      $result = call_user_func_array($function, $args);\n\n      // Restore SESSION\n      foreach ($OLD_SESSION as $key => $value) {\n         $_SESSION[$key] = $value;\n      }\n      // Return function results\n      return $result;\n   }\n\n\n   /**\n   * Check if an item is inventoried by FusionInventory\n   *\n   * @since 9.2\n   * @param CommonDBTM $item the item to check\n   * @return boolean true if handle by FusionInventory\n   */\n   static function isAFusionInventoryDevice($item) {\n      $table = '';\n      switch ($item->getType()) {\n         case 'Computer':\n            $table = 'glpi_plugin_fusioninventory_inventorycomputercomputers';\n            $fk    = 'computers_id';\n            break;\n\n         case 'NetworkEquipment':\n            $table = 'glpi_plugin_fusioninventory_networkequipments';\n            $fk    = 'networkequipments_id';\n            break;\n\n         case 'Printer':\n            $table = 'glpi_plugin_fusioninventory_printers';\n            $fk    = 'printers_id';\n            break;\n\n      }\n      if ($table) {\n         return $item->isDynamic()\n            && countElementsInTable($table, [$fk => $item->getID()]);\n      } else {\n         return 0;\n      }\n   }\n\n\n   /**\n    * Get default value for state of devices (monitor, printer...)\n    *\n    * @param string type the type of inventory performed (values : computer, snmp)\n    * @param array $input\n    * @return array the fields with the states_id filled, is necessary\n    */\n   static function addDefaultStateIfNeeded($type, $input) {\n      $config = new PluginFusioninventoryConfig();\n      switch ($type) {\n         case 'computer':\n            if ($states_id_default = $config->getValue(\"states_id_default\")) {\n               $input['states_id'] = $states_id_default;\n            }\n            break;\n\n         case 'snmp':\n            if ($states_id_snmp_default = $config->getValue(\"states_id_snmp_default\")) {\n               $input['states_id'] = $states_id_snmp_default;\n            }\n            break;\n\n         default:\n            $state = false;\n            break;\n      }\n      return $input;\n   }\n\n   /**\n    * Add a location if required by a rule\n    * @since 9.2+2.0\n    *\n    * @param array $input fields of the asset being inventoried\n    * @param array $output output array in which the location should be added (optionnal)\n    * @return array the fields with the locations_id filled, is necessary\n    */\n   static function addLocation($input, $output = false) {\n      //manage location\n      $ruleLocation = new PluginFusioninventoryInventoryRuleLocationCollection();\n\n      // * Reload rules (required for unit tests)\n      $ruleLocation->getCollectionPart();\n\n      $dataLocation = $ruleLocation->processAllRules($input);\n      if (isset($dataLocation['locations_id'])) {\n         if ($output) {\n            $output['locations_id'] = $dataLocation['locations_id'];\n         } else {\n            $input['locations_id'] = $dataLocation['locations_id'];\n         }\n      }\n      return ($output?$output:$input);\n   }\n}\n"], "filenames": ["front/send_inventory.php", "inc/toolbox.class.php"], "buggy_code_start_loc": [53, 521], "buggy_code_end_loc": [62, 522], "fixing_code_start_loc": [52, 521], "fixing_code_end_loc": [61, 523], "type": "CWE-19", "message": "The FusionInventory plugin before 1.4 for GLPI 9.3.x and before 1.1 for GLPI 9.4.x mishandles sendXML actions.", "other": {"cve": {"id": "CVE-2019-10477", "sourceIdentifier": "cve@mitre.org", "published": "2019-03-29T14:29:00.530", "lastModified": "2019-04-01T19:25:30.453", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The FusionInventory plugin before 1.4 for GLPI 9.3.x and before 1.1 for GLPI 9.4.x mishandles sendXML actions."}, {"lang": "es", "value": "El plugin \"FusionInventory\", en versiones anteriores a la 1.4 para GLPI 9.3.x y en las anteriores a la 1.1 para GLPI 9.4.x, gestiona de manera incorrecta las acciones sendXML."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-19"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fusioninventory:fusioninventory:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.4", "matchCriteriaId": "0A68574C-AA9C-4825-8667-8D6E738A8513"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:a:glpi-project:glpi:*:*:*:*:*:*:*:*", "versionStartIncluding": "9.3.0", "versionEndIncluding": "9.3.3", "matchCriteriaId": "E4DB8EBF-93FD-4FBC-8D50-2334CE6ADE10"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fusioninventory:fusioninventory:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1", "matchCriteriaId": "14A28339-0224-4846-96D1-88898B2912EC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:a:glpi-project:glpi:*:*:*:*:*:*:*:*", "versionStartIncluding": "9.4.0", "versionEndIncluding": "9.4.1.1", "matchCriteriaId": "02BDFBF8-8EFC-43E2-B78D-2817AF6FCA58"}]}]}], "references": [{"url": "https://github.com/fusioninventory/fusioninventory-for-glpi/commit/0f777f85773b18f5252e79afa1929fcdc4858c3a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/fusioninventory/fusioninventory-for-glpi/compare/260a864...e1f776d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/fusioninventory/fusioninventory-for-glpi/compare/cec774a...baa4158", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/fusioninventory/fusioninventory-for-glpi/releases/tag/glpi9.3%2B1.4", "source": "cve@mitre.org", "tags": ["Product", "Third Party Advisory"]}, {"url": "https://github.com/fusioninventory/fusioninventory-for-glpi/releases/tag/glpi9.4%2B1.1", "source": "cve@mitre.org", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/fusioninventory/fusioninventory-for-glpi/commit/0f777f85773b18f5252e79afa1929fcdc4858c3a"}}