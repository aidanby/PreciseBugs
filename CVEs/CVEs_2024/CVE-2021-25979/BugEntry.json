{"buggy_code": ["// This module makes an instance of the [i18next](https://npmjs.org/package/i18next) npm module available\n// in Nunjucks templates via the `__t()` helper function. That function is also available on `req` objects\n// as `req.t()`. Any options passed to this module are passed on to `i18next`.\n//\n// `apos.i18n.i18next` can be used to directly access the `i18next` npm module instance if necessary.\n// It usually is not necessary. Use `req.t` if you need to localize in a route.\n\nconst i18next = require('i18next');\nconst fs = require('fs');\nconst _ = require('lodash');\nconst { stripIndent } = require('common-tags');\nconst ExpressSessionCookie = require('express-session/session/cookie');\n\nconst apostropheI18nDebugPlugin = {\n  type: 'postProcessor',\n  name: 'apostrophei18nDebugPlugin',\n  process(value, key, options, translator) {\n    // For ease of tracking down which phrases were\n    // actually passed through i18next\n    return `\ud83c\udf0d ${value}`;\n  }\n};\n\nmodule.exports = {\n  options: {\n    alias: 'i18n',\n    i18n: {\n      ns: 'apostrophe',\n      browser: true\n    }\n  },\n  async init(self) {\n    self.namespaces = {};\n    self.debug = process.env.APOS_DEBUG_I18N ? true : self.options.debug;\n    self.show = process.env.APOS_SHOW_I18N ? true : self.options.show;\n    self.locales = self.getLocales();\n    self.hostnamesInUse = Object.values(self.locales).find(locale => locale.hostname);\n    self.defaultLocale = self.options.defaultLocale || Object.keys(self.locales)[0];\n    // Lint the locale configurations\n    for (const [ key, options ] of Object.entries(self.locales)) {\n      if (!options) {\n        throw self.apos.error('invalid', `Locale \"${key}\" was not configured.`);\n      }\n      if (typeof key !== 'string' || !key.match(/^[a-zA-Z]/)) {\n        throw self.apos.error('invalid', `Locale names must begin with a non-numeric, \"word\" character (a-z or A-Z). Check locale \"${key}\".`);\n      }\n      if (options.prefix && !options.prefix.match(/^\\//)) {\n        throw self.apos.error('invalid', `Locale prefixes must begin with a forward slash (\"/\"). Check locale \"${key}\".`);\n      }\n      if (options.prefix && options.prefix.match(/\\/.*?\\//)) {\n        throw self.apos.error('invalid', `Locale prefixes must not contain more than one forward slash (\"/\").\\nUse hyphens as separators. Check locale \"${key}\".`);\n      }\n    }\n    // Make sure we have our own instance to avoid conflicts with other apos objects\n    self.i18next = i18next.createInstance({\n      fallbackLng: self.defaultLocale,\n      // Required to prevent the debugger from complaining\n      languages: Object.keys(self.locales),\n      // Added later, but required here\n      resources: {},\n      interpolation: {\n        // Nunjucks and Vue will already do this\n        escapeValue: false\n      },\n      defaultNS: 'default',\n      debug: self.debug\n    });\n    if (self.show) {\n      self.i18next.use(apostropheI18nDebugPlugin);\n    }\n    await self.i18next.init();\n    self.addInitialResources();\n    self.enableBrowserData();\n  },\n  handlers(self) {\n    return {\n      'apostrophe:modulesReady': {\n        addModal() {\n          self.addLocalizeModal();\n        }\n      },\n      '@apostrophecms/page:beforeSend': {\n        // Developers can link to alternate locales by iterating over\n        // `data.localizations` in any page template. Each element always has\n        // `locale`, `label` and `homePageUrl` properties. Each element also has an\n        // `available` property; if true, the current context document is available\n        // in that locale, `title` and a small number of other document properties are\n        // populated, and `_url` redirects to the context document in that locale.\n        //\n        // The array is provided in the order in which locales are configured.\n        // The current locale is included and has the property `current: true`.\n        async addLocalizations(req) {\n          const context = req.data.piece || req.data.page;\n          if (!context) {\n            return;\n          }\n          const manager = self.apos.doc.getManager(context.type);\n          if (!manager.isLocalized()) {\n            return;\n          }\n          const localizations = await self.apos.doc.db.find({\n            aposDocId: context.aposDocId,\n            aposMode: req.mode\n          }).project({\n            type: 1,\n            title: 1,\n            slug: 1,\n            aposLocale: 1,\n            aposMode: 1,\n            visibility: 1,\n            docPermissions: 1\n          }).toArray();\n          req.data.localizations = [];\n          for (const name of Object.keys(self.locales)) {\n            const localeReq = self.apos.util.cloneReq(req, {\n              locale: name\n            });\n            self.setPrefixUrls(localeReq);\n            const doc = localizations.find(doc => doc.aposLocale.split(':')[0] === name);\n            if (doc && self.apos.permission.can(req, 'view', doc)) {\n              doc.available = true;\n              doc._url = `${self.apos.prefix}${manager.action}/${context._id}/locale/${name}`;\n              if (doc._id === context._id) {\n                doc.current = true;\n              }\n            }\n            const info = doc || {};\n            info.locale = name;\n            info.label = self.locales[name].label;\n            info.homePageUrl = `${localeReq.prefix}/`;\n            req.data.localizations.push(info);\n          }\n        }\n      }\n    };\n  },\n  middleware(self) {\n    return {\n      async acceptCrossDomainSessionToken(req, res, next) {\n        let crossDomainSessionToken = req.query.aposCrossDomainSessionToken;\n        if (!crossDomainSessionToken) {\n          return next();\n        }\n        crossDomainSessionToken = self.apos.launder.string(crossDomainSessionToken);\n        try {\n          const sessionData = await self.apos.cache.get('@apostrophecms/i18n:cross-domain-sessions', crossDomainSessionToken);\n          for (const key of Object.keys(req.session)) {\n            delete req.session[key];\n          }\n          Object.assign(req.session, sessionData || {});\n          await self.apos.cache.set('@apostrophecms/i18n:cross-domain-sessions', crossDomainSessionToken, null);\n        } catch (e) {\n          self.apos.util.error(e);\n        }\n        // Since the req.session object at this stage is just\n        // a plain Javascript object, getters and setters of\n        // the Cookie prototype from the express-session module\n        // (like req.session.cookie.data) are unavailable and\n        // will return 'undefined' when called internally by the\n        // express-session module. This ends up corrupting the\n        // set-cookie headers generated by the express-session\n        // module, thus breaking sessions. The express-session\n        // module normally generates an instance of its Cookie\n        // prototype which contains these methods and expects\n        // that interface always to function properly. To ensure\n        // this, we re-instantiate req.session.cookie as an\n        // instance of the Cookie class from the express-session\n        // module to ensure that the sessions remain intact even\n        // across domains. Note that we use the cookie settings\n        // from the Apostrophe Express module to ensure that user\n        // defined cookie settings are respected.\n        const aposExpressModule = self.apos.modules['@apostrophecms/express'];\n        req.session.cookie = new ExpressSessionCookie(aposExpressModule.sessionOptions.cookie);\n        return res.redirect(self.apos.url.build(req.url, { aposCrossDomainSessionToken: null }));\n      },\n      locale(req, res, next) {\n        // Support for a single aposLocale query param that\n        // also contains the mode, which is likely to occur\n        // since we have the `aposLocale` property in docs\n        // structured that way\n        if (req.query.aposLocale && req.query.aposLocale.includes(':')) {\n          const parts = req.query.aposLocale.split(':');\n          req.query.aposLocale = parts[0];\n          req.query.aposMode = parts[1];\n        }\n        const validModes = [ 'draft', 'published' ];\n        let locale;\n        if (self.isValidLocale(req.query.aposLocale)) {\n          locale = req.query.aposLocale;\n        } else {\n          locale = self.matchLocale(req);\n        }\n        const localeOptions = self.locales[locale];\n        if (localeOptions.prefix) {\n          // Remove locale prefix so URL parsing can proceed normally from here\n          if (req.path === localeOptions.prefix) {\n            // Add / for home page\n            return res.redirect(`${req.url}/`);\n          }\n          if (req.path.substring(0, localeOptions.prefix.length + 1) === localeOptions.prefix + '/') {\n            req.path = req.path.replace(localeOptions.prefix, '');\n            req.url = req.url.replace(localeOptions.prefix, '');\n            const superRedirect = res.redirect;\n            res.redirect = function (status, url) {\n              if (arguments.length === 1) {\n                url = status;\n                status = 302;\n              }\n              if (!url.match(/^[a-zA-Z]+:/)) {\n                // We don't need all of req.prefix here because\n                // the global site prefix middleware already extended\n                // res.redirect once\n                url = localeOptions.prefix + url;\n              }\n              return superRedirect.call(this, status, url);\n            };\n          }\n        }\n        let mode;\n        if (validModes.includes(req.query.aposMode)) {\n          mode = req.query.aposMode;\n        } else {\n          mode = 'published';\n        }\n        req.locale = locale;\n        req.mode = mode;\n        self.setPrefixUrls(req);\n        if ((req.mode === 'draft') && (!self.apos.permission.can(req, 'view-draft'))) {\n          return res.status(403).send({\n            name: 'forbidden'\n          });\n        }\n        _.defaults(req.data, _.pick(req, 'baseUrl', 'baseUrlWithPrefix', 'absoluteUrl'));\n        return next();\n      },\n      localize(req, res, next) {\n        req.t = (key, options = {}) => {\n          return self.i18next.t(key, {\n            ...options,\n            lng: req.locale\n          });\n        };\n        req.__ = key => {\n          self.apos.util.warnDevOnce('old-i18n-req-helper', stripIndent`\n            The req.__() and res.__() functions are deprecated and do not localize in A3.\n            Use req.t instead.\n          `);\n          return key;\n        };\n        req.res.__ = req.__;\n        return next();\n      }\n    };\n  },\n  apiRoutes(self) {\n    return {\n      post: {\n        async locale(req) {\n          const sanitizedLocale = self.sanitizeLocaleName(req.body.locale);\n          // Clipboards transferring between locales needs to jump\n          // from LocalStorage to the cross-domain session cache\n          let clipboard = req.body.clipboard;\n          if (clipboard && ((typeof clipboard) !== 'string')) {\n            // Clipboard re-validation doesn't have to be more detailed here because\n            // on any actual paste attempt it will go through server side validation\n            // like any normal insert of a widget\n            clipboard = null;\n          }\n          const _id = self.apos.launder.id(req.body.contextDocId);\n          let doc;\n          const localeReq = req.clone({\n            locale: sanitizedLocale\n          });\n          if (_id) {\n            doc = await self.apos.doc.find(localeReq, {\n              aposDocId: _id.split(':')[0]\n            }).toObject();\n            if (!doc) {\n              const publishedLocaleReq = localeReq.clone({ mode: 'draft' });\n              doc = await self.apos.doc.find(publishedLocaleReq, {\n                aposDocId: _id.split(':')[0]\n              }).toObject();\n            }\n          }\n          if (!sanitizedLocale) {\n            throw self.apos.error('invalid');\n          }\n          const result = {};\n          if (doc && doc._url) {\n            result.redirectTo = doc && doc._url;\n          } else {\n            // No matching document, so as a fallback go to the home page\n            // with the appropriate prefix\n            result.redirectTo = localeReq.prefix;\n          };\n          if (self.locales[localeReq.locale].hostname !== self.locales[req.locale].hostname) {\n            const crossDomainSessionToken = self.apos.util.generateId();\n            const session = {\n              ...req.session,\n              aposCrossDomainClipboard: clipboard\n            };\n            await self.apos.cache.set('@apostrophecms/i18n:cross-domain-sessions', crossDomainSessionToken, session, 60 * 60);\n            result.redirectTo = self.apos.url.build(result.redirectTo, {\n              aposCrossDomainSessionToken: crossDomainSessionToken\n            });\n          }\n          return result;\n        },\n        // Fast bulk query for doc `ids` that exist in the given `locale`.\n        // `ids` may contain `_id` or `aposDocId` values.\n        //\n        // The response object contains `originalLocaleIds`, `newLocaleIds` and\n        // `aposDocIds` arrays. Any documents not existing in `locale`\n        // will not be included in these arrays.\n        //\n        // The original mode and locale are inferred from the given\n        // `ids`, or from the request.\n        //\n        // This route is a POST route because large numbers of ids\n        // might not be accepted as a query string.\n        async existInLocale(req) {\n          if (!req.user) {\n            throw self.apos.error('notfound');\n          }\n          const ids = self.apos.launder.ids(req.body.ids);\n          const locale = self.apos.launder.string(req.body.locale);\n          const originalLocale = (ids[0] && ids[0].split(':')[1]) || req.locale;\n          const originalMode = (ids[0] && ids[0].split(':')[2]) || req.mode;\n          const mode = self.apos.launder.string(req.body.mode, originalMode);\n          if (!self.isValidLocale(locale)) {\n            throw self.apos.error('invalid');\n          }\n          const found = await self.apos.doc.db.find({\n            aposLocale: `${locale}:${mode}`,\n            aposDocId: {\n              $in: ids.map(self.apos.doc.toAposDocId)\n            }\n          }).project({\n            _id: 1,\n            aposDocId: 1\n          }).toArray();\n          const result = {\n            originalLocaleIds: found.map(doc => `${doc.aposDocId}:${originalLocale}:${originalMode}`),\n            newLocaleIds: found.map(doc => doc._id),\n            aposDocIds: found.map(doc => doc.aposDocId)\n          };\n          return result;\n        }\n      }\n    };\n  },\n  methods(self) {\n    return {\n      // Add the i18next resources provided by the specified module,\n      // merging with any existing phrases for the same locales and namespaces\n      addResourcesForModule(module) {\n        if (!module.options.i18n) {\n          return;\n        }\n        const ns = module.options.i18n.ns || 'default';\n        self.namespaces[ns] = self.namespaces[ns] || {};\n        self.namespaces[ns].browser = self.namespaces[ns].browser || !!module.options.i18n.browser;\n        for (const entry of module.__meta.chain) {\n          const localizationsDir = `${entry.dirname}/i18n`;\n          if (!fs.existsSync(localizationsDir)) {\n            continue;\n          }\n          for (const localizationFile of fs.readdirSync(localizationsDir)) {\n            const data = JSON.parse(fs.readFileSync(`${localizationsDir}/${localizationFile}`));\n            const locale = localizationFile.replace('.json', '');\n            self.i18next.addResourceBundle(locale, ns, data, true, true);\n          }\n        }\n      },\n      // Adds i18next resources for modules initialized before the i18n module\n      // itself, called by init. Later modules call addResourcesForModule(self),\n      // making phrases available gradually as Apostrophe starts up\n      addInitialResources() {\n        for (const module of Object.values(self.apos.modules)) {\n          self.addResourcesForModule(module);\n        }\n      },\n      isValidLocale(locale) {\n        return locale && has(self.locales, locale);\n      },\n      // Return the best matching locale for the request based on the hostname\n      // and path prefix. If available the first locale matching both\n      // hostname and prefix is returned, otherwise the first matching locale\n      // that specifies only a hostname or only a prefix. If no matches are\n      // possible the default locale is returned.\n      matchLocale(req) {\n        const hostname = req.hostname;\n        let best = false;\n        for (const [ name, options ] of Object.entries(self.locales)) {\n          const matchedHostname = options.hostname\n            ? (hostname === options.hostname.split(':')[0]) : null;\n          const matchedPrefix = options.prefix\n            ? ((req.path === options.prefix) || req.path.startsWith(options.prefix + '/'))\n            : null;\n          if (options.hostname && options.prefix) {\n            if (matchedHostname && matchedPrefix) {\n              // Best possible match\n              return name;\n            }\n          } else if (options.hostname) {\n            if (matchedHostname) {\n              if (!best) {\n                best = name;\n              }\n            }\n          } else if (options.prefix) {\n            if (matchedPrefix) {\n              if (!best) {\n                best = name;\n              }\n            }\n          }\n        }\n        return best || self.defaultLocale;\n      },\n      // Infer `req.locale` and `req.mode` from `_id` if they were\n      // not set already by explicit query parameters. Conversely,\n      // if the appropriate query parameters were set, rewrite\n      // `_id` accordingly. Returns `_id`, after rewriting if appropriate.\n      inferIdLocaleAndMode(req, _id) {\n        let [ cuid, locale, mode ] = _id.split(':');\n        if (locale && mode) {\n          if (!req.query.aposLocale) {\n            req.locale = locale;\n          } else {\n            locale = req.locale;\n          }\n          if (!req.query.aposMode) {\n            req.mode = mode;\n          } else {\n            mode = req.mode;\n          }\n        } else {\n          // aposDocId was passed, complete the _id from whatever\n          // was in query params or defaults\n          locale = req.locale;\n          mode = req.mode;\n        }\n        if ((req.mode === 'draft') && (!self.apos.permission.can(req, 'view-draft'))) {\n          throw self.apos.error('forbidden');\n        }\n        if (_id.charAt(0) === '_') {\n          // A shortcut such as _home or _archive,\n          // will be interpreted later\n          return _id;\n        } else {\n          return `${cuid}:${locale}:${mode}`;\n        }\n      },\n      getBrowserData(req) {\n        const i18n = {\n          [req.locale]: self.getBrowserBundles(req.locale)\n        };\n        if (req.locale !== self.defaultLocale) {\n          i18n[self.defaultLocale] = self.getBrowserBundles(self.defaultLocale);\n        }\n        const result = {\n          i18n,\n          locale: req.locale,\n          defaultLocale: self.defaultLocale,\n          locales: self.locales,\n          debug: self.debug,\n          show: self.show,\n          action: self.action,\n          crossDomainClipboard: req.session.aposCrossDomainClipboard\n        };\n        if (req.session.aposCrossDomainClipboard) {\n          req.session.aposCrossDomainClipboard = null;\n        }\n        return result;\n      },\n      getBrowserBundles(locale) {\n        const i18n = {};\n        for (const [ name, options ] of Object.entries(self.namespaces)) {\n          if (options.browser) {\n            i18n[name] = self.i18next.getResourceBundle(locale, name);\n          }\n        }\n        return i18n;\n      },\n      getLocales() {\n        const locales = self.options.locales || {\n          en: {\n            label: 'English'\n          }\n        };\n        const taken = {};\n        let hostnamesCount = 0;\n        for (const [ name, options ] of Object.entries(locales)) {\n          const key = (options.hostname || '__none') + ':' + (options.prefix || '__none');\n          hostnamesCount += (options.hostname ? 1 : 0);\n          if (taken[key]) {\n            throw new Error(stripIndent`\n              @apostrophecms/i18n: the locale ${name} cannot be distinguished from\n              earlier locales. Make sure it is uniquely distinguished by its hostname\n              option, prefix option or a combination of the two. One locale per site\n              may be a default with neither hostname nor prefix, and one locale per\n              hostname may be a default for that hostname without a prefix.\n            `);\n          }\n          taken[key] = true;\n        }\n        if ((hostnamesCount > 0) && (hostnamesCount < Object.keys(locales).length) && (!self.apos.options.baseUrl)) {\n          throw new Error(stripIndent`\n            If some of your locales have hostnames, then they all must have\n            hostnames, or your top-level baseUrl option must be set.\n\n            In development, you can set baseUrl to http://localhost:3000\n            for testing purposes. In production it should always be set\n            to a real base URL for the site.\n          `);\n        }\n        // Make sure they are adequately distinguished by\n        // hostname and prefix\n        return locales;\n      },\n      sanitizeLocaleName(locale) {\n        locale = self.apos.launder.string(locale);\n        if (!has(self.locales, locale)) {\n          return null;\n        }\n        return locale;\n      },\n      addLocalizeModal() {\n        self.apos.modal.add(\n          `${self.__meta.name}:localize`,\n          self.getComponentName('localizeModal', 'AposI18nLocalize'),\n          { moduleName: self.__meta.name }\n        );\n      },\n      setPrefixUrls(req) {\n        // In a production-like environment, use req.hostname, otherwise the Host header\n        // to allow port numbers in dev.\n        //\n        // Watch out for modules that won't be set up if this is an afterInit task in an\n        // early module like the asset module\n        const host = (process.env.NODE_ENV === 'production') ? req.hostname : req.get('Host');\n        const fallbackBaseUrl = `${req.protocol}://${host}`;\n        if (self.hostnamesInUse) {\n          req.baseUrl = (self.apos.page && self.apos.page.getBaseUrl(req)) || fallbackBaseUrl;\n        } else {\n          req.baseUrl = self.apos.page && self.apos.page.getBaseUrl(req);\n        }\n        req.baseUrlWithPrefix = `${req.baseUrl}${self.apos.prefix}`;\n        req.absoluteUrl = req.baseUrlWithPrefix + req.url;\n        req.prefix = `${req.baseUrlWithPrefix}${self.locales[req.locale].prefix || ''}`;\n        if (!req.baseUrl) {\n          // Always set for bc, but in the absence of locale hostnames we\n          // set it later so it is not part of req.prefix\n          req.baseUrl = fallbackBaseUrl;\n        }\n      },\n      // Returns an Express route suitable for use in a module\n      // like a piece type or the page module. The returned route will\n      // expect req.params._id and req.params.toLocale and redirect,\n      // if possible, to the corresponding version in toLocale.\n      toLocaleRouteFactory(module) {\n        return async (req, res) => {\n          const _id = module.inferIdLocaleAndMode(req, req.params._id);\n          const toLocale = req.params.toLocale;\n          const localeReq = req.clone({\n            locale: toLocale\n          });\n          const corresponding = await module.find(localeReq, {\n            _id: `${_id.split(':')[0]}:${localeReq.locale}:${localeReq.mode}`\n          }).toObject();\n          if (!corresponding) {\n            return res.status(404).send('not found');\n          }\n          if (!corresponding._url) {\n            return res.status(400).send('invalid (has no URL)');\n          }\n          return res.redirect(corresponding._url);\n        };\n      }\n    };\n  }\n};\n\nfunction has(o, k) {\n  return Object.prototype.hasOwnProperty.call(o, k);\n}\n", "// This module allows other modules to create command line tasks.\n//\n// A command line task is invoked like this:\n//\n// node app @apostrophecms/migration:migrate\n//\n// Apostrophe is fully initialized before your task is run, except that it does\n// not listen for connections. So you may access all of its features in your\n// task.\n\n// Direct use of `console` makes sense here because we're implementing an\n// interaction at the CLI.\n\n/* eslint-disable no-console */\n\nconst _ = require('lodash');\nconst { stripIndent } = require('common-tags');\n\nmodule.exports = {\n  options: { alias: 'task' },\n  handlers(self) {\n    return {\n      'apostrophe:run': {\n        async runTask(isTask) {\n\n          if (!isTask) {\n            return;\n          }\n\n          let task;\n          const cmd = self.apos.argv._[0];\n          if (!cmd) {\n            throw new Error('There is no command line argument to serve as a task name, should never happen');\n          }\n\n          if (cmd === 'help') {\n\n            // list all tasks\n            if (self.apos.argv._.length === 1) {\n              self.usage();\n            }\n\n            // help with specific task\n            if (self.apos.argv._.length === 2) {\n              task = self.find(self.apos.argv._[1]);\n              if (!task) {\n                console.error('There is no such task.');\n                self.usage();\n              }\n              if (task.usage) {\n                console.log(`\\nTips for the ${task.fullName} task:\\n`);\n                console.log(task.usage);\n              } else {\n                console.log('That is a valid task, but it does not have a help message.');\n              }\n              process.exit(0);\n            }\n          }\n\n          task = self.find(cmd);\n\n          if (!task) {\n            console.error('\\nThere is no such task.');\n            self.usage();\n          }\n\n          try {\n            await task.task(self.apos.argv);\n          } catch (e) {\n            console.error(e);\n            process.exit(1);\n          }\n          process.exit(0);\n        }\n      }\n    };\n  },\n  methods(self) {\n    return {\n\n      // For use when you wish to execute an Apostrophe command line task from\n      // your code and continue, without using the command line or using the\n      // `child_process` module.\n      //\n      // Except for `name`, all arguments may be omitted.\n      //\n      // This is an async function and should be awaited.\n      //\n      // Examples (assume `products` extends `@apostrophecms/piece-type`):\n      //\n      // `await self.apos.task.invoke('@apostrophecms/user:add', [ 'admin', 'admin' ])`\n      //\n      // `await self.apos.task.invoke('products:generate', { total: 20 })`\n      //\n      // The `args` and `options` arguments may be completely omitted.\n      //\n      // If present, `args` contains an array of positional arguments to\n      // the task, **not including** the task name.\n      //\n      // If present, `options` contains the optional parameters that would\n      // normally be hyphenated, i.e. at the command line you might write\n      // `--total=20`.\n      //\n      // **Gotchas**\n      //\n      // If you can invoke a method directly rather than invoking a task, do\n      // that. This method is for cases where that option is not readily\n      // available.\n      //\n      // During the execution of the task, `self.apos.argv` will have a new,\n      // temporary value to accommodate tasks that inspect this property\n      // directly rather than examining their `argv` argument. `self.apos.argv`\n      // will be restored at the end of task execution.\n      //\n      // Some tasks may not be written to be \"good neighbors.\" For instance, a\n      // task developer might assume they can exit the process directly.\n\n      async invoke(name, args, options) {\n        const aposArgv = self.apos.argv;\n        if (Array.isArray(args)) {\n          args.splice(0, 0, name);\n        } else {\n          options = args;\n          args = [ name ];\n        }\n        const task = self.find(name);\n        const argv = {\n          _: args,\n          ...options || {}\n        };\n        self.apos.argv = argv;\n        await task.task(argv);\n        self.apos.argv = aposArgv;\n      },\n\n      // Identifies the task corresponding to the given command line argument.\n\n      find(fullName) {\n        const matches = fullName.match(/^(.*?):(.*)$/);\n        if (!matches) {\n          return false;\n        }\n        const moduleName = matches[1];\n        const name = matches[2];\n        if (!(self.apos.modules[moduleName] && _.has(self.apos.modules[moduleName].tasks, name))) {\n          return false;\n        }\n        const task = self.apos.modules[moduleName].tasks[name];\n        task.fullName = `${moduleName}:${name}`;\n        return task;\n      },\n\n      // Displays a usage message, including a list of available tasks,\n      // and exits the entire program with a nonzero status code.\n\n      usage() {\n        // Direct use of console makes sense in tasks. -Tom\n        console.error('\\nThe following tasks are available:\\n');\n        for (const [ moduleName, module ] of Object.entries(self.apos.modules)) {\n          for (const name of Object.keys(module.tasks)) {\n            console.error(`${moduleName}:${name}`);\n          }\n        }\n        console.error('\\nType:\\n');\n        console.error('node app help groupname:taskname\\n');\n        console.error('To get help with a specific task.\\n');\n        console.error('To launch the site, run with no arguments.');\n        process.exit(1);\n      },\n\n      // Return a `req` object suitable for command line tasks\n      // and unit tests. The `req` object returned is a mockup of a true Express\n      // `req` object.\n      //\n      // An `options` object may be passed. If `options.role` is set,\n      // it may be `anon` (no role and no req.user), `guest`, `contributor`,\n      // `editor`, or `admin`. For bc reasons, it defaults to `admin`.\n      //\n      // Other properties of `options` are assigned as properties of the\n      // returned `req` object before any initialization tasks such as computing\n      // `req.absoluteUrl`. This facilitates unit testing.\n\n      getReq(options) {\n        options = options || {};\n        options.role = options.role || 'admin';\n        const req = {\n          ...(options.role === 'anon' ? {} : {\n            user: {\n              title: 'System Task',\n              role: options.role\n            }\n          }),\n          res: {},\n          t(key, options = {}) {\n            return self.apos.i18n.i18next.t(key, {\n              ...options,\n              lng: req.locale\n            });\n          },\n          data: {},\n          protocol: 'http',\n          get: function (propName) {\n            return { Host: 'you-need-to-set-baseUrl-in-app-js.com' }[propName];\n          },\n          query: {},\n          url: '/',\n          locale: self.apos.argv.locale || self.apos.modules['@apostrophecms/i18n'].defaultLocale,\n          mode: 'published',\n          aposNeverLoad: {},\n          aposStack: [],\n          __(key) {\n            self.apos.util.warnDevOnce('old-i18n-req-helper', stripIndent`\n              The req.__() and res.__() functions are deprecated and do not localize in A3.\n              Use req.t instead.\n            `);\n            return key;\n          }\n        };\n        addCloneMethod(req);\n        req.res.__ = req.__;\n        const { role, ..._properties } = options || {};\n        Object.assign(req, _properties);\n        self.apos.i18n.setPrefixUrls(req);\n        return req;\n\n        function addCloneMethod(req) {\n          req.clone = (properties = {}) => {\n            const _req = {\n              ...req,\n              ...properties\n            };\n            self.apos.i18n.setPrefixUrls(_req);\n            addCloneMethod(_req);\n            return _req;\n          };\n        }\n      },\n\n      // Convenience wrapper for `getReq`. Returns a request\n      // object simulating an anonymous site visitor, with no role\n      // and no `req.user`.\n      getAnonReq(options) {\n        return self.getReq({\n          role: 'anon',\n          ...options\n        });\n      },\n\n      // Convenience wrapper for `getReq`. Returns a request\n      // object simulating a user with the guest role.\n      getGuestReq(options) {\n        return self.getReq({\n          role: 'guest',\n          ...options\n        });\n      },\n\n      // Convenience wrapper for `getReq`. Returns a request\n      // object simulating a user with the contributor role.\n      getContributorReq(options) {\n        return self.getReq({\n          role: 'contributor',\n          ...options\n        });\n      },\n\n      // Convenience wrapper for `getReq`. Returns a request\n      // object simulating a user with the editor role.\n      getEditorReq(options) {\n        return self.getReq({\n          role: 'editor',\n          ...options\n        });\n      },\n\n      // Convenience wrapper for `getReq`. Returns a request\n      // object simulating a user with the admin role.\n      getAdminReq(options) {\n        // For bc reasons this is the default behavior of getReq\n        return self.getReq(options);\n      }\n\n    };\n  }\n};\n"], "fixing_code": ["// This module makes an instance of the [i18next](https://npmjs.org/package/i18next) npm module available\n// in Nunjucks templates via the `__t()` helper function. That function is also available on `req` objects\n// as `req.t()`. Any options passed to this module are passed on to `i18next`.\n//\n// `apos.i18n.i18next` can be used to directly access the `i18next` npm module instance if necessary.\n// It usually is not necessary. Use `req.t` if you need to localize in a route.\n\nconst i18next = require('i18next');\nconst fs = require('fs');\nconst _ = require('lodash');\nconst { stripIndent } = require('common-tags');\nconst ExpressSessionCookie = require('express-session/session/cookie');\n\nconst apostropheI18nDebugPlugin = {\n  type: 'postProcessor',\n  name: 'apostrophei18nDebugPlugin',\n  process(value, key, options, translator) {\n    // For ease of tracking down which phrases were\n    // actually passed through i18next\n    return `\ud83c\udf0d ${value}`;\n  }\n};\n\nmodule.exports = {\n  options: {\n    alias: 'i18n',\n    i18n: {\n      ns: 'apostrophe',\n      browser: true\n    }\n  },\n  async init(self) {\n    self.namespaces = {};\n    self.debug = process.env.APOS_DEBUG_I18N ? true : self.options.debug;\n    self.show = process.env.APOS_SHOW_I18N ? true : self.options.show;\n    self.locales = self.getLocales();\n    self.hostnamesInUse = Object.values(self.locales).find(locale => locale.hostname);\n    self.defaultLocale = self.options.defaultLocale || Object.keys(self.locales)[0];\n    // Lint the locale configurations\n    for (const [ key, options ] of Object.entries(self.locales)) {\n      if (!options) {\n        throw self.apos.error('invalid', `Locale \"${key}\" was not configured.`);\n      }\n      if (typeof key !== 'string' || !key.match(/^[a-zA-Z]/)) {\n        throw self.apos.error('invalid', `Locale names must begin with a non-numeric, \"word\" character (a-z or A-Z). Check locale \"${key}\".`);\n      }\n      if (options.prefix && !options.prefix.match(/^\\//)) {\n        throw self.apos.error('invalid', `Locale prefixes must begin with a forward slash (\"/\"). Check locale \"${key}\".`);\n      }\n      if (options.prefix && options.prefix.match(/\\/.*?\\//)) {\n        throw self.apos.error('invalid', `Locale prefixes must not contain more than one forward slash (\"/\").\\nUse hyphens as separators. Check locale \"${key}\".`);\n      }\n    }\n    // Make sure we have our own instance to avoid conflicts with other apos objects\n    self.i18next = i18next.createInstance({\n      fallbackLng: self.defaultLocale,\n      // Required to prevent the debugger from complaining\n      languages: Object.keys(self.locales),\n      // Added later, but required here\n      resources: {},\n      interpolation: {\n        // Nunjucks and Vue will already do this\n        escapeValue: false\n      },\n      defaultNS: 'default',\n      debug: self.debug\n    });\n    if (self.show) {\n      self.i18next.use(apostropheI18nDebugPlugin);\n    }\n    await self.i18next.init();\n    self.addInitialResources();\n    self.enableBrowserData();\n  },\n  handlers(self) {\n    return {\n      'apostrophe:modulesReady': {\n        addModal() {\n          self.addLocalizeModal();\n        }\n      },\n      '@apostrophecms/page:beforeSend': {\n        // Developers can link to alternate locales by iterating over\n        // `data.localizations` in any page template. Each element always has\n        // `locale`, `label` and `homePageUrl` properties. Each element also has an\n        // `available` property; if true, the current context document is available\n        // in that locale, `title` and a small number of other document properties are\n        // populated, and `_url` redirects to the context document in that locale.\n        //\n        // The array is provided in the order in which locales are configured.\n        // The current locale is included and has the property `current: true`.\n        async addLocalizations(req) {\n          const context = req.data.piece || req.data.page;\n          if (!context) {\n            return;\n          }\n          const manager = self.apos.doc.getManager(context.type);\n          if (!manager.isLocalized()) {\n            return;\n          }\n          const localizations = await self.apos.doc.db.find({\n            aposDocId: context.aposDocId,\n            aposMode: req.mode\n          }).project({\n            type: 1,\n            title: 1,\n            slug: 1,\n            aposLocale: 1,\n            aposMode: 1,\n            visibility: 1,\n            docPermissions: 1\n          }).toArray();\n          req.data.localizations = [];\n          for (const name of Object.keys(self.locales)) {\n            const localeReq = self.apos.util.cloneReq(req, {\n              locale: name\n            });\n            self.setPrefixUrls(localeReq);\n            const doc = localizations.find(doc => doc.aposLocale.split(':')[0] === name);\n            if (doc && self.apos.permission.can(req, 'view', doc)) {\n              doc.available = true;\n              doc._url = `${self.apos.prefix}${manager.action}/${context._id}/locale/${name}`;\n              if (doc._id === context._id) {\n                doc.current = true;\n              }\n            }\n            const info = doc || {};\n            info.locale = name;\n            info.label = self.locales[name].label;\n            info.homePageUrl = `${localeReq.prefix}/`;\n            req.data.localizations.push(info);\n          }\n        }\n      }\n    };\n  },\n  middleware(self) {\n    return {\n      async acceptCrossDomainSessionToken(req, res, next) {\n        let crossDomainSessionToken = req.query.aposCrossDomainSessionToken;\n        if (!crossDomainSessionToken) {\n          return next();\n        }\n        crossDomainSessionToken = self.apos.launder.string(crossDomainSessionToken);\n        try {\n          const sessionData = await self.apos.cache.get('@apostrophecms/i18n:cross-domain-sessions', crossDomainSessionToken);\n          for (const key of Object.keys(req.session)) {\n            delete req.session[key];\n          }\n          Object.assign(req.session, sessionData || {});\n          await self.apos.cache.set('@apostrophecms/i18n:cross-domain-sessions', crossDomainSessionToken, null);\n        } catch (e) {\n          self.apos.util.error(e);\n        }\n        // Since the req.session object at this stage is just\n        // a plain Javascript object, getters and setters of\n        // the Cookie prototype from the express-session module\n        // (like req.session.cookie.data) are unavailable and\n        // will return 'undefined' when called internally by the\n        // express-session module. This ends up corrupting the\n        // set-cookie headers generated by the express-session\n        // module, thus breaking sessions. The express-session\n        // module normally generates an instance of its Cookie\n        // prototype which contains these methods and expects\n        // that interface always to function properly. To ensure\n        // this, we re-instantiate req.session.cookie as an\n        // instance of the Cookie class from the express-session\n        // module to ensure that the sessions remain intact even\n        // across domains. Note that we use the cookie settings\n        // from the Apostrophe Express module to ensure that user\n        // defined cookie settings are respected.\n        const aposExpressModule = self.apos.modules['@apostrophecms/express'];\n        req.session.cookie = new ExpressSessionCookie(aposExpressModule.sessionOptions.cookie);\n        return res.redirect(self.apos.url.build(req.url, { aposCrossDomainSessionToken: null }));\n      },\n      locale(req, res, next) {\n        // Support for a single aposLocale query param that\n        // also contains the mode, which is likely to occur\n        // since we have the `aposLocale` property in docs\n        // structured that way\n        if (req.query.aposLocale && req.query.aposLocale.includes(':')) {\n          const parts = req.query.aposLocale.split(':');\n          req.query.aposLocale = parts[0];\n          req.query.aposMode = parts[1];\n        }\n        const validModes = [ 'draft', 'published' ];\n        let locale;\n        if (self.isValidLocale(req.query.aposLocale)) {\n          locale = req.query.aposLocale;\n        } else {\n          locale = self.matchLocale(req);\n        }\n        const localeOptions = self.locales[locale];\n        if (localeOptions.prefix) {\n          // Remove locale prefix so URL parsing can proceed normally from here\n          if (req.path === localeOptions.prefix) {\n            // Add / for home page\n            return res.redirect(`${req.url}/`);\n          }\n          if (req.path.substring(0, localeOptions.prefix.length + 1) === localeOptions.prefix + '/') {\n            req.path = req.path.replace(localeOptions.prefix, '');\n            req.url = req.url.replace(localeOptions.prefix, '');\n            const superRedirect = res.redirect;\n            res.redirect = function (status, url) {\n              if (arguments.length === 1) {\n                url = status;\n                status = 302;\n              }\n              if (!url.match(/^[a-zA-Z]+:/)) {\n                // We don't need all of req.prefix here because\n                // the global site prefix middleware already extended\n                // res.redirect once\n                url = localeOptions.prefix + url;\n              }\n              return superRedirect.call(this, status, url);\n            };\n          }\n        }\n        let mode;\n        if (validModes.includes(req.query.aposMode)) {\n          mode = req.query.aposMode;\n        } else {\n          mode = 'published';\n        }\n        req.locale = locale;\n        req.mode = mode;\n        self.setPrefixUrls(req);\n        if ((req.mode === 'draft') && (!self.apos.permission.can(req, 'view-draft'))) {\n          return res.status(403).send({\n            name: 'forbidden'\n          });\n        }\n        _.defaults(req.data, _.pick(req, 'baseUrl', 'baseUrlWithPrefix', 'absoluteUrl'));\n        return next();\n      },\n      localize(req, res, next) {\n        req.t = (key, options = {}) => {\n          return self.i18next.t(key, {\n            ...options,\n            lng: req.locale\n          });\n        };\n        req.__ = key => {\n          self.apos.util.warnDevOnce('old-i18n-req-helper', stripIndent`\n            The req.__() and res.__() functions are deprecated and do not localize in A3.\n            Use req.t instead.\n          `);\n          return key;\n        };\n        req.res.__ = req.__;\n        return next();\n      }\n    };\n  },\n  apiRoutes(self) {\n    return {\n      post: {\n        async locale(req) {\n          const sanitizedLocale = self.sanitizeLocaleName(req.body.locale);\n          // Clipboards transferring between locales needs to jump\n          // from LocalStorage to the cross-domain session cache\n          let clipboard = req.body.clipboard;\n          if (clipboard && ((typeof clipboard) !== 'string')) {\n            // Clipboard re-validation doesn't have to be more detailed here because\n            // on any actual paste attempt it will go through server side validation\n            // like any normal insert of a widget\n            clipboard = null;\n          }\n          const _id = self.apos.launder.id(req.body.contextDocId);\n          let doc;\n          const localeReq = req.clone({\n            locale: sanitizedLocale\n          });\n          if (_id) {\n            doc = await self.apos.doc.find(localeReq, {\n              aposDocId: _id.split(':')[0]\n            }).toObject();\n            if (!doc) {\n              const publishedLocaleReq = localeReq.clone({ mode: 'draft' });\n              doc = await self.apos.doc.find(publishedLocaleReq, {\n                aposDocId: _id.split(':')[0]\n              }).toObject();\n            }\n          }\n          if (!sanitizedLocale) {\n            throw self.apos.error('invalid');\n          }\n          const result = {};\n          if (doc && doc._url) {\n            result.redirectTo = doc && doc._url;\n          } else {\n            // No matching document, so as a fallback go to the home page\n            // with the appropriate prefix\n            result.redirectTo = localeReq.prefix;\n          };\n          if (self.locales[localeReq.locale].hostname !== self.locales[req.locale].hostname) {\n            const crossDomainSessionToken = self.apos.util.generateId();\n            const session = {\n              ...req.session,\n              aposCrossDomainClipboard: clipboard\n            };\n            await self.apos.cache.set('@apostrophecms/i18n:cross-domain-sessions', crossDomainSessionToken, session, 60 * 60);\n            result.redirectTo = self.apos.url.build(result.redirectTo, {\n              aposCrossDomainSessionToken: crossDomainSessionToken\n            });\n          }\n          return result;\n        },\n        // Fast bulk query for doc `ids` that exist in the given `locale`.\n        // `ids` may contain `_id` or `aposDocId` values.\n        //\n        // The response object contains `originalLocaleIds`, `newLocaleIds` and\n        // `aposDocIds` arrays. Any documents not existing in `locale`\n        // will not be included in these arrays.\n        //\n        // The original mode and locale are inferred from the given\n        // `ids`, or from the request.\n        //\n        // This route is a POST route because large numbers of ids\n        // might not be accepted as a query string.\n        async existInLocale(req) {\n          if (!req.user) {\n            throw self.apos.error('notfound');\n          }\n          const ids = self.apos.launder.ids(req.body.ids);\n          const locale = self.apos.launder.string(req.body.locale);\n          const originalLocale = (ids[0] && ids[0].split(':')[1]) || req.locale;\n          const originalMode = (ids[0] && ids[0].split(':')[2]) || req.mode;\n          const mode = self.apos.launder.string(req.body.mode, originalMode);\n          if (!self.isValidLocale(locale)) {\n            throw self.apos.error('invalid');\n          }\n          const found = await self.apos.doc.db.find({\n            aposLocale: `${locale}:${mode}`,\n            aposDocId: {\n              $in: ids.map(self.apos.doc.toAposDocId)\n            }\n          }).project({\n            _id: 1,\n            aposDocId: 1\n          }).toArray();\n          const result = {\n            originalLocaleIds: found.map(doc => `${doc.aposDocId}:${originalLocale}:${originalMode}`),\n            newLocaleIds: found.map(doc => doc._id),\n            aposDocIds: found.map(doc => doc.aposDocId)\n          };\n          return result;\n        }\n      }\n    };\n  },\n  methods(self) {\n    return {\n      // Add the i18next resources provided by the specified module,\n      // merging with any existing phrases for the same locales and namespaces\n      addResourcesForModule(module) {\n        if (!module.options.i18n) {\n          return;\n        }\n        const ns = module.options.i18n.ns || 'default';\n        self.namespaces[ns] = self.namespaces[ns] || {};\n        self.namespaces[ns].browser = self.namespaces[ns].browser || !!module.options.i18n.browser;\n        for (const entry of module.__meta.chain) {\n          const localizationsDir = `${entry.dirname}/i18n`;\n          if (!fs.existsSync(localizationsDir)) {\n            continue;\n          }\n          for (const localizationFile of fs.readdirSync(localizationsDir)) {\n            const data = JSON.parse(fs.readFileSync(`${localizationsDir}/${localizationFile}`));\n            const locale = localizationFile.replace('.json', '');\n            self.i18next.addResourceBundle(locale, ns, data, true, true);\n          }\n        }\n      },\n      // Adds i18next resources for modules initialized before the i18n module\n      // itself, called by init. Later modules call addResourcesForModule(self),\n      // making phrases available gradually as Apostrophe starts up\n      addInitialResources() {\n        for (const module of Object.values(self.apos.modules)) {\n          self.addResourcesForModule(module);\n        }\n      },\n      isValidLocale(locale) {\n        return locale && has(self.locales, locale);\n      },\n      // Return the best matching locale for the request based on the hostname\n      // and path prefix. If available the first locale matching both\n      // hostname and prefix is returned, otherwise the first matching locale\n      // that specifies only a hostname or only a prefix. If no matches are\n      // possible the default locale is returned.\n      matchLocale(req) {\n        const hostname = req.hostname;\n        let best = false;\n        for (const [ name, options ] of Object.entries(self.locales)) {\n          const matchedHostname = options.hostname\n            ? (hostname === options.hostname.split(':')[0]) : null;\n          const matchedPrefix = options.prefix\n            ? ((req.path === options.prefix) || req.path.startsWith(options.prefix + '/'))\n            : null;\n          if (options.hostname && options.prefix) {\n            if (matchedHostname && matchedPrefix) {\n              // Best possible match\n              return name;\n            }\n          } else if (options.hostname) {\n            if (matchedHostname) {\n              if (!best) {\n                best = name;\n              }\n            }\n          } else if (options.prefix) {\n            if (matchedPrefix) {\n              if (!best) {\n                best = name;\n              }\n            }\n          }\n        }\n        return best || self.defaultLocale;\n      },\n      // Infer `req.locale` and `req.mode` from `_id` if they were\n      // not set already by explicit query parameters. Conversely,\n      // if the appropriate query parameters were set, rewrite\n      // `_id` accordingly. Returns `_id`, after rewriting if appropriate.\n      inferIdLocaleAndMode(req, _id) {\n        let [ cuid, locale, mode ] = _id.split(':');\n        if (locale && mode) {\n          if (!req.query.aposLocale) {\n            req.locale = locale;\n          } else {\n            locale = req.locale;\n          }\n          if (!req.query.aposMode) {\n            req.mode = mode;\n          } else {\n            mode = req.mode;\n          }\n        } else {\n          // aposDocId was passed, complete the _id from whatever\n          // was in query params or defaults\n          locale = req.locale;\n          mode = req.mode;\n        }\n        if ((req.mode === 'draft') && (!self.apos.permission.can(req, 'view-draft'))) {\n          throw self.apos.error('forbidden');\n        }\n        if (_id.charAt(0) === '_') {\n          // A shortcut such as _home or _archive,\n          // will be interpreted later\n          return _id;\n        } else {\n          return `${cuid}:${locale}:${mode}`;\n        }\n      },\n      getBrowserData(req) {\n        const i18n = {\n          [req.locale]: self.getBrowserBundles(req.locale)\n        };\n        if (req.locale !== self.defaultLocale) {\n          i18n[self.defaultLocale] = self.getBrowserBundles(self.defaultLocale);\n        }\n        const result = {\n          i18n,\n          locale: req.locale,\n          defaultLocale: self.defaultLocale,\n          locales: self.locales,\n          debug: self.debug,\n          show: self.show,\n          action: self.action,\n          crossDomainClipboard: req.session && req.session.aposCrossDomainClipboard\n        };\n        if (req.session && req.session.aposCrossDomainClipboard) {\n          req.session.aposCrossDomainClipboard = null;\n        }\n        return result;\n      },\n      getBrowserBundles(locale) {\n        const i18n = {};\n        for (const [ name, options ] of Object.entries(self.namespaces)) {\n          if (options.browser) {\n            i18n[name] = self.i18next.getResourceBundle(locale, name);\n          }\n        }\n        return i18n;\n      },\n      getLocales() {\n        const locales = self.options.locales || {\n          en: {\n            label: 'English'\n          }\n        };\n        const taken = {};\n        let hostnamesCount = 0;\n        for (const [ name, options ] of Object.entries(locales)) {\n          const key = (options.hostname || '__none') + ':' + (options.prefix || '__none');\n          hostnamesCount += (options.hostname ? 1 : 0);\n          if (taken[key]) {\n            throw new Error(stripIndent`\n              @apostrophecms/i18n: the locale ${name} cannot be distinguished from\n              earlier locales. Make sure it is uniquely distinguished by its hostname\n              option, prefix option or a combination of the two. One locale per site\n              may be a default with neither hostname nor prefix, and one locale per\n              hostname may be a default for that hostname without a prefix.\n            `);\n          }\n          taken[key] = true;\n        }\n        if ((hostnamesCount > 0) && (hostnamesCount < Object.keys(locales).length) && (!self.apos.options.baseUrl)) {\n          throw new Error(stripIndent`\n            If some of your locales have hostnames, then they all must have\n            hostnames, or your top-level baseUrl option must be set.\n\n            In development, you can set baseUrl to http://localhost:3000\n            for testing purposes. In production it should always be set\n            to a real base URL for the site.\n          `);\n        }\n        // Make sure they are adequately distinguished by\n        // hostname and prefix\n        return locales;\n      },\n      sanitizeLocaleName(locale) {\n        locale = self.apos.launder.string(locale);\n        if (!has(self.locales, locale)) {\n          return null;\n        }\n        return locale;\n      },\n      addLocalizeModal() {\n        self.apos.modal.add(\n          `${self.__meta.name}:localize`,\n          self.getComponentName('localizeModal', 'AposI18nLocalize'),\n          { moduleName: self.__meta.name }\n        );\n      },\n      setPrefixUrls(req) {\n        // In a production-like environment, use req.hostname, otherwise the Host header\n        // to allow port numbers in dev.\n        //\n        // Watch out for modules that won't be set up if this is an afterInit task in an\n        // early module like the asset module\n        const host = (process.env.NODE_ENV === 'production') ? req.hostname : req.get('Host');\n        const fallbackBaseUrl = `${req.protocol}://${host}`;\n        if (self.hostnamesInUse) {\n          req.baseUrl = (self.apos.page && self.apos.page.getBaseUrl(req)) || fallbackBaseUrl;\n        } else {\n          req.baseUrl = self.apos.page && self.apos.page.getBaseUrl(req);\n        }\n        req.baseUrlWithPrefix = `${req.baseUrl}${self.apos.prefix}`;\n        req.absoluteUrl = req.baseUrlWithPrefix + req.url;\n        req.prefix = `${req.baseUrlWithPrefix}${self.locales[req.locale].prefix || ''}`;\n        if (!req.baseUrl) {\n          // Always set for bc, but in the absence of locale hostnames we\n          // set it later so it is not part of req.prefix\n          req.baseUrl = fallbackBaseUrl;\n        }\n      },\n      // Returns an Express route suitable for use in a module\n      // like a piece type or the page module. The returned route will\n      // expect req.params._id and req.params.toLocale and redirect,\n      // if possible, to the corresponding version in toLocale.\n      toLocaleRouteFactory(module) {\n        return async (req, res) => {\n          const _id = module.inferIdLocaleAndMode(req, req.params._id);\n          const toLocale = req.params.toLocale;\n          const localeReq = req.clone({\n            locale: toLocale\n          });\n          const corresponding = await module.find(localeReq, {\n            _id: `${_id.split(':')[0]}:${localeReq.locale}:${localeReq.mode}`\n          }).toObject();\n          if (!corresponding) {\n            return res.status(404).send('not found');\n          }\n          if (!corresponding._url) {\n            return res.status(400).send('invalid (has no URL)');\n          }\n          return res.redirect(corresponding._url);\n        };\n      }\n    };\n  }\n};\n\nfunction has(o, k) {\n  return Object.prototype.hasOwnProperty.call(o, k);\n}\n", "// This module allows other modules to create command line tasks.\n//\n// A command line task is invoked like this:\n//\n// node app @apostrophecms/migration:migrate\n//\n// Apostrophe is fully initialized before your task is run, except that it does\n// not listen for connections. So you may access all of its features in your\n// task.\n\n// Direct use of `console` makes sense here because we're implementing an\n// interaction at the CLI.\n\n/* eslint-disable no-console */\n\nconst _ = require('lodash');\nconst { stripIndent } = require('common-tags');\n\nmodule.exports = {\n  options: { alias: 'task' },\n  handlers(self) {\n    return {\n      'apostrophe:run': {\n        async runTask(isTask) {\n\n          if (!isTask) {\n            return;\n          }\n\n          let task;\n          const cmd = self.apos.argv._[0];\n          if (!cmd) {\n            throw new Error('There is no command line argument to serve as a task name, should never happen');\n          }\n\n          if (cmd === 'help') {\n\n            // list all tasks\n            if (self.apos.argv._.length === 1) {\n              self.usage();\n            }\n\n            // help with specific task\n            if (self.apos.argv._.length === 2) {\n              task = self.find(self.apos.argv._[1]);\n              if (!task) {\n                console.error('There is no such task.');\n                self.usage();\n              }\n              if (task.usage) {\n                console.log(`\\nTips for the ${task.fullName} task:\\n`);\n                console.log(task.usage);\n              } else {\n                console.log('That is a valid task, but it does not have a help message.');\n              }\n              process.exit(0);\n            }\n          }\n\n          task = self.find(cmd);\n\n          if (!task) {\n            console.error('\\nThere is no such task.');\n            self.usage();\n          }\n\n          try {\n            await task.task(self.apos.argv);\n          } catch (e) {\n            console.error(e);\n            process.exit(1);\n          }\n          process.exit(0);\n        }\n      }\n    };\n  },\n  methods(self) {\n    return {\n\n      // For use when you wish to execute an Apostrophe command line task from\n      // your code and continue, without using the command line or using the\n      // `child_process` module.\n      //\n      // Except for `name`, all arguments may be omitted.\n      //\n      // This is an async function and should be awaited.\n      //\n      // Examples (assume `products` extends `@apostrophecms/piece-type`):\n      //\n      // `await self.apos.task.invoke('@apostrophecms/user:add', [ 'admin', 'admin' ])`\n      //\n      // `await self.apos.task.invoke('products:generate', { total: 20 })`\n      //\n      // The `args` and `options` arguments may be completely omitted.\n      //\n      // If present, `args` contains an array of positional arguments to\n      // the task, **not including** the task name.\n      //\n      // If present, `options` contains the optional parameters that would\n      // normally be hyphenated, i.e. at the command line you might write\n      // `--total=20`.\n      //\n      // **Gotchas**\n      //\n      // If you can invoke a method directly rather than invoking a task, do\n      // that. This method is for cases where that option is not readily\n      // available.\n      //\n      // During the execution of the task, `self.apos.argv` will have a new,\n      // temporary value to accommodate tasks that inspect this property\n      // directly rather than examining their `argv` argument. `self.apos.argv`\n      // will be restored at the end of task execution.\n      //\n      // Some tasks may not be written to be \"good neighbors.\" For instance, a\n      // task developer might assume they can exit the process directly.\n\n      async invoke(name, args, options) {\n        const aposArgv = self.apos.argv;\n        if (Array.isArray(args)) {\n          args.splice(0, 0, name);\n        } else {\n          options = args;\n          args = [ name ];\n        }\n        const task = self.find(name);\n        const argv = {\n          _: args,\n          ...options || {}\n        };\n        self.apos.argv = argv;\n        await task.task(argv);\n        self.apos.argv = aposArgv;\n      },\n\n      // Identifies the task corresponding to the given command line argument.\n\n      find(fullName) {\n        const matches = fullName.match(/^(.*?):(.*)$/);\n        if (!matches) {\n          return false;\n        }\n        const moduleName = matches[1];\n        const name = matches[2];\n        if (!(self.apos.modules[moduleName] && _.has(self.apos.modules[moduleName].tasks, name))) {\n          return false;\n        }\n        const task = self.apos.modules[moduleName].tasks[name];\n        task.fullName = `${moduleName}:${name}`;\n        return task;\n      },\n\n      // Displays a usage message, including a list of available tasks,\n      // and exits the entire program with a nonzero status code.\n\n      usage() {\n        // Direct use of console makes sense in tasks. -Tom\n        console.error('\\nThe following tasks are available:\\n');\n        for (const [ moduleName, module ] of Object.entries(self.apos.modules)) {\n          for (const name of Object.keys(module.tasks)) {\n            console.error(`${moduleName}:${name}`);\n          }\n        }\n        console.error('\\nType:\\n');\n        console.error('node app help groupname:taskname\\n');\n        console.error('To get help with a specific task.\\n');\n        console.error('To launch the site, run with no arguments.');\n        process.exit(1);\n      },\n\n      // Return a `req` object suitable for command line tasks\n      // and unit tests. The `req` object returned is a mockup of a true Express\n      // `req` object.\n      //\n      // An `options` object may be passed. If `options.role` is set,\n      // it may be `anon` (no role and no req.user), `guest`, `contributor`,\n      // `editor`, or `admin`. For bc reasons, it defaults to `admin`.\n      //\n      // Other properties of `options` are assigned as properties of the\n      // returned `req` object before any initialization tasks such as computing\n      // `req.absoluteUrl`. This facilitates unit testing.\n\n      getReq(options) {\n        options = options || {};\n        options.role = options.role || 'admin';\n        const req = {\n          ...(options.role === 'anon' ? {} : {\n            user: {\n              title: 'System Task',\n              role: options.role\n            }\n          }),\n          res: {},\n          t(key, options = {}) {\n            return self.apos.i18n.i18next.t(key, {\n              ...options,\n              lng: req.locale\n            });\n          },\n          data: {},\n          protocol: 'http',\n          get: function (propName) {\n            return { Host: 'you-need-to-set-baseUrl-in-app-js.com' }[propName];\n          },\n          query: {},\n          url: '/',\n          locale: self.apos.argv.locale || self.apos.modules['@apostrophecms/i18n'].defaultLocale,\n          mode: 'published',\n          aposNeverLoad: {},\n          aposStack: [],\n          __(key) {\n            self.apos.util.warnDevOnce('old-i18n-req-helper', stripIndent`\n              The req.__() and res.__() functions are deprecated and do not localize in A3.\n              Use req.t instead.\n            `);\n            return key;\n          },\n          session: {}\n        };\n        addCloneMethod(req);\n        req.res.__ = req.__;\n        const { role, ..._properties } = options || {};\n        Object.assign(req, _properties);\n        self.apos.i18n.setPrefixUrls(req);\n        return req;\n\n        function addCloneMethod(req) {\n          req.clone = (properties = {}) => {\n            const _req = {\n              ...req,\n              ...properties\n            };\n            self.apos.i18n.setPrefixUrls(_req);\n            addCloneMethod(_req);\n            return _req;\n          };\n        }\n      },\n\n      // Convenience wrapper for `getReq`. Returns a request\n      // object simulating an anonymous site visitor, with no role\n      // and no `req.user`.\n      getAnonReq(options) {\n        return self.getReq({\n          role: 'anon',\n          ...options\n        });\n      },\n\n      // Convenience wrapper for `getReq`. Returns a request\n      // object simulating a user with the guest role.\n      getGuestReq(options) {\n        return self.getReq({\n          role: 'guest',\n          ...options\n        });\n      },\n\n      // Convenience wrapper for `getReq`. Returns a request\n      // object simulating a user with the contributor role.\n      getContributorReq(options) {\n        return self.getReq({\n          role: 'contributor',\n          ...options\n        });\n      },\n\n      // Convenience wrapper for `getReq`. Returns a request\n      // object simulating a user with the editor role.\n      getEditorReq(options) {\n        return self.getReq({\n          role: 'editor',\n          ...options\n        });\n      },\n\n      // Convenience wrapper for `getReq`. Returns a request\n      // object simulating a user with the admin role.\n      getAdminReq(options) {\n        // For bc reasons this is the default behavior of getReq\n        return self.getReq(options);\n      }\n\n    };\n  }\n};\n"], "filenames": ["modules/@apostrophecms/i18n/index.js", "modules/@apostrophecms/task/index.js"], "buggy_code_start_loc": [470, 217], "buggy_code_end_loc": [473, 218], "fixing_code_start_loc": [470, 217], "fixing_code_end_loc": [473, 219], "type": "CWE-613", "message": "Apostrophe CMS versions prior to 3.3.1 did not invalidate existing login sessions when disabling a user account or changing the password, creating a situation in which a device compromised by a third party could not be locked out by those means. As a mitigation for older releases the user account in question can be archived (3.x) or moved to the trash (2.x and earlier) which does disable the existing session.", "other": {"cve": {"id": "CVE-2021-25979", "sourceIdentifier": "vulnerabilitylab@mend.io", "published": "2021-11-08T15:15:07.743", "lastModified": "2022-08-10T14:25:05.493", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Apostrophe CMS versions prior to 3.3.1 did not invalidate existing login sessions when disabling a user account or changing the password, creating a situation in which a device compromised by a third party could not be locked out by those means. As a mitigation for older releases the user account in question can be archived (3.x) or moved to the trash (2.x and earlier) which does disable the existing session."}, {"lang": "es", "value": "Las versiones de Apostrophe CMS anteriores a la 3.3.1 no invalidaban las sesiones de inicio de sesi\u00f3n existentes cuando se deshabilitaba una cuenta de usuario o se cambiaba la contrase\u00f1a, creando una situaci\u00f3n en la que un dispositivo comprometido por un tercero no pod\u00eda ser bloqueado por esos medios. Como mitigaci\u00f3n para las versiones anteriores, la cuenta de usuario en cuesti\u00f3n puede ser archivada (3.x) o movida a la papelera (2.x y anteriores), lo que desactiva la sesi\u00f3n existente"}], "metrics": {"cvssMetricV31": [{"source": "vulnerabilitylab@mend.io", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "nvd@nist.gov", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "vulnerabilitylab@mend.io", "type": "Primary", "description": [{"lang": "en", "value": "CWE-613"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-613"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apostrophecms:apostrophecms:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.63.0", "versionEndExcluding": "3.3.1", "matchCriteriaId": "4D9E1B8A-61D7-4910-AB6C-3B9629EDB1C4"}]}]}], "references": [{"url": "https://github.com/apostrophecms/apostrophe/commit/c211b211f9f4303a77a307cf41aac9b4ef8d2c7c", "source": "vulnerabilitylab@mend.io", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/apostrophecms/apostrophe/commit/c211b211f9f4303a77a307cf41aac9b4ef8d2c7c"}}