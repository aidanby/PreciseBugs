{"buggy_code": ["{-# LANGUAGE CPP #-}\n{-# LANGUAGE OverloadedStrings #-}\n{- |\nModule      : Text.Pandoc.Class.IO\nCopyright   : Copyright (C) 2016-2020 Jesse Rosenthal, John MacFarlane\nLicense     : GNU GPL, version 2 or above\n\nMaintainer  : Jesse Rosenthal <jrosenthal@jhu.edu>\nStability   : alpha\nPortability : portable\n\nDefault ways to perform @'PandocMonad'@ actions in a @'MonadIO'@ type.\n\nThese functions are used to make the @'PandocIO'@ type an instance of\n@'PandocMonad'@, but can be reused for any other MonadIO-conforming\ntypes.\n-}\nmodule Text.Pandoc.Class.IO\n  ( fileExists\n  , getCurrentTime\n  , getCurrentTimeZone\n  , getDataFileName\n  , getModificationTime\n  , glob\n  , logOutput\n  , logIOError\n  , lookupEnv\n  , newStdGen\n  , newUniqueHash\n  , openURL\n  , readFileLazy\n  , readFileStrict\n  , readStdinStrict\n  , extractMedia\n  , writeMedia\n ) where\n\nimport Control.Monad.Except (throwError)\nimport Control.Monad.IO.Class (MonadIO, liftIO)\nimport Data.ByteString.Base64 (decodeBase64Lenient)\nimport Data.ByteString.Lazy (toChunks)\nimport Data.Text (Text, pack, unpack)\nimport Data.Time (TimeZone, UTCTime)\nimport Data.Unique (hashUnique)\nimport Network.Connection (TLSSettings (TLSSettingsSimple))\nimport Network.HTTP.Client\n       (httpLbs, responseBody, responseHeaders,\n        Request(port, host, requestHeaders), parseRequest, newManager)\nimport Network.HTTP.Client.Internal (addProxy)\nimport Network.HTTP.Client.TLS (mkManagerSettings)\nimport Network.HTTP.Types.Header ( hContentType )\nimport Network.Socket (withSocketsDo)\nimport Network.URI (URI(..), parseURI, unEscapeString)\nimport System.Directory (createDirectoryIfMissing)\nimport System.Environment (getEnv)\nimport System.FilePath ((</>), takeDirectory, normalise)\nimport qualified System.FilePath.Posix as Posix\nimport System.IO (stderr)\nimport System.IO.Error\nimport System.Random (StdGen)\nimport Text.Pandoc.Class.CommonState (CommonState (..))\nimport Text.Pandoc.Class.PandocMonad\n       (PandocMonad, getsCommonState, getMediaBag, report)\nimport Text.Pandoc.Definition (Pandoc, Inline (Image))\nimport Text.Pandoc.Error (PandocError (..))\nimport Text.Pandoc.Logging (LogMessage (..), messageVerbosity, showLogMessage)\nimport Text.Pandoc.MIME (MimeType)\nimport Text.Pandoc.MediaBag (MediaBag, MediaItem(..), lookupMedia, mediaItems)\nimport Text.Pandoc.Walk (walk)\nimport qualified Control.Exception as E\nimport qualified Data.ByteString as B\nimport qualified Data.ByteString.Lazy as BL\nimport qualified Data.CaseInsensitive as CI\nimport qualified Data.Text as T\nimport qualified Data.Time\nimport qualified Data.Time.LocalTime\nimport qualified Data.Unique\nimport qualified System.Directory\nimport qualified System.Environment as Env\nimport qualified System.FilePath.Glob\nimport qualified System.Random\nimport qualified Text.Pandoc.UTF8 as UTF8\n#ifndef EMBED_DATA_FILES\nimport qualified Paths_pandoc as Paths\n#endif\n\n-- | Utility function to lift IO errors into 'PandocError's.\nliftIOError :: (PandocMonad m, MonadIO m) => (String -> IO a) -> String -> m a\nliftIOError f u = do\n  res <- liftIO $ tryIOError $ f u\n  case res of\n         Left e  -> throwError $ PandocIOError (pack u) e\n         Right r -> return r\n\n-- | Show potential IO errors to the user continuing execution anyway\nlogIOError :: (PandocMonad m, MonadIO m) => IO () -> m ()\nlogIOError f = do\n  res <- liftIO $ tryIOError f\n  case res of\n    Left e -> report $ IgnoredIOError $ pack $ E.displayException e\n    Right _ -> pure ()\n\n-- | Lookup an environment variable in the programs environment.\nlookupEnv :: MonadIO m => Text -> m (Maybe Text)\nlookupEnv = fmap (fmap pack) . liftIO . Env.lookupEnv . unpack\n\n-- | Get the current (UTC) time.\ngetCurrentTime :: MonadIO m => m UTCTime\ngetCurrentTime = liftIO Data.Time.getCurrentTime\n\n-- | Get the locale's time zone.\ngetCurrentTimeZone :: MonadIO m => m TimeZone\ngetCurrentTimeZone = liftIO Data.Time.LocalTime.getCurrentTimeZone\n\n-- | Return a new generator for random numbers.\nnewStdGen :: MonadIO m => m StdGen\nnewStdGen = liftIO System.Random.newStdGen\n\n-- | Return a new unique integer.\nnewUniqueHash :: MonadIO m => m Int\nnewUniqueHash = hashUnique <$> liftIO Data.Unique.newUnique\n\nopenURL :: (PandocMonad m, MonadIO m) => Text -> m (B.ByteString, Maybe MimeType)\nopenURL u\n | Just (URI{ uriScheme = \"data:\",\n              uriPath = upath }) <- parseURI (T.unpack u) = do\n     let (mime, rest) = break (== ',') $ unEscapeString upath\n     let contents = UTF8.fromString $ drop 1 rest\n     return (decodeBase64Lenient contents, Just (T.pack mime))\n | otherwise = do\n     let toReqHeader (n, v) = (CI.mk (UTF8.fromText n), UTF8.fromText v)\n     customHeaders <- map toReqHeader <$> getsCommonState stRequestHeaders\n     disableCertificateValidation <- getsCommonState stNoCheckCertificate\n     report $ Fetching u\n     res <- liftIO $ E.try $ withSocketsDo $ do\n       let parseReq = parseRequest\n       proxy <- tryIOError (getEnv \"http_proxy\")\n       let addProxy' x = case proxy of\n                            Left _ -> return x\n                            Right pr -> parseReq pr >>= \\r ->\n                                return (addProxy (host r) (port r) x)\n       req <- parseReq (unpack u) >>= addProxy'\n       let req' = req{requestHeaders = customHeaders ++ requestHeaders req}\n       let tlsSimple = TLSSettingsSimple disableCertificateValidation False False\n       let tlsManagerSettings = mkManagerSettings tlsSimple  Nothing\n       resp <- newManager tlsManagerSettings >>= httpLbs req'\n       return (B.concat $ toChunks $ responseBody resp,\n               UTF8.toText `fmap` lookup hContentType (responseHeaders resp))\n\n     case res of\n          Right r -> return r\n          Left e  -> throwError $ PandocHttpError u e\n\n-- | Read the lazy ByteString contents from a file path, raising an error on\n-- failure.\nreadFileLazy :: (PandocMonad m, MonadIO m) => FilePath -> m BL.ByteString\nreadFileLazy s = liftIOError BL.readFile s\n\n-- | Read the strict ByteString contents from a file path,\n-- raising an error on failure.\nreadFileStrict :: (PandocMonad m, MonadIO m) => FilePath -> m B.ByteString\nreadFileStrict s = liftIOError B.readFile s\n\n-- | Read the strict ByteString contents from stdin, raising\n-- an error on failure.\nreadStdinStrict :: (PandocMonad m, MonadIO m) => m B.ByteString\nreadStdinStrict = liftIOError (const B.getContents) \"stdin\"\n\n-- | Return a list of paths that match a glob, relative to the working\n-- directory. See 'System.FilePath.Glob' for the glob syntax.\nglob :: (PandocMonad m, MonadIO m) => String -> m [FilePath]\nglob = liftIOError System.FilePath.Glob.glob\n\n-- | Returns True if file exists.\nfileExists :: (PandocMonad m, MonadIO m) => FilePath -> m Bool\nfileExists = liftIOError System.Directory.doesFileExist\n\n-- | Returns the path of data file.\ngetDataFileName :: (PandocMonad m, MonadIO m) => FilePath -> m FilePath\n#ifdef EMBED_DATA_FILES\ngetDataFileName = return\n#else\ngetDataFileName = liftIOError Paths.getDataFileName\n#endif\n\n-- | Return the modification time of a file.\ngetModificationTime :: (PandocMonad m, MonadIO m) => FilePath -> m UTCTime\ngetModificationTime = liftIOError System.Directory.getModificationTime\n\n-- | Output a log message.\nlogOutput :: (PandocMonad m, MonadIO m) => LogMessage -> m ()\nlogOutput msg = liftIO $ do\n  UTF8.hPutStr stderr $\n      \"[\" <> T.pack (show (messageVerbosity msg)) <> \"] \"\n  alertIndent $ T.lines $ showLogMessage msg\n\n-- | Prints the list of lines to @stderr@, indenting every but the first\n-- line by two spaces.\nalertIndent :: [Text] -> IO ()\nalertIndent [] = return ()\nalertIndent (l:ls) = do\n  UTF8.hPutStrLn stderr l\n  mapM_ go ls\n  where go l' = do UTF8.hPutStr stderr \"  \"\n                   UTF8.hPutStrLn stderr l'\n\n-- | Extract media from the mediabag into a directory.\nextractMedia :: (PandocMonad m, MonadIO m) => FilePath -> Pandoc -> m Pandoc\nextractMedia dir d = do\n  media <- getMediaBag\n  let items = mediaItems media\n  if null items\n    then return d\n    else do\n      mapM_ (writeMedia dir) items\n      return $ walk (adjustImagePath dir media) d\n\n-- | Write the contents of a media bag to a path.\n-- If the path contains URI escape sequences (percent-encoding),\n-- these are resolved.\nwriteMedia :: (PandocMonad m, MonadIO m)\n           => FilePath\n           -> (FilePath, MimeType, BL.ByteString)\n           -> m ()\nwriteMedia dir (fp, _mt, bs) = do\n  -- we normalize to get proper path separators for the platform\n  let fullpath = normalise $ dir </> unEscapeString fp\n  liftIOError (createDirectoryIfMissing True) (takeDirectory fullpath)\n  report $ Extracting (T.pack fullpath)\n  logIOError $ BL.writeFile fullpath bs\n\n-- | If the given Inline element is an image with a @src@ path equal to\n-- one in the list of @paths@, then prepends @dir@ to the image source;\n-- returns the element unchanged otherwise.\nadjustImagePath :: FilePath -> MediaBag -> Inline -> Inline\nadjustImagePath dir mediabag (Image attr lab (src, tit)) =\n  case lookupMedia (T.unpack src) mediabag of\n    Nothing -> Image attr lab (src, tit)\n    Just item ->\n      let fullpath = dir Posix.</> mediaPath item\n      in  Image attr lab (T.pack fullpath, tit)\nadjustImagePath _ _ x = x\n", "{-# LANGUAGE CPP                        #-}\n{-# LANGUAGE OverloadedStrings          #-}\n{-# LANGUAGE DeriveDataTypeable         #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{- |\n   Module      : Text.Pandoc.MediaBag\n   Copyright   : Copyright (C) 2014-2015, 2017-2023 John MacFarlane\n   License     : GNU GPL, version 2 or above\n\n   Maintainer  : John MacFarlane <jgm@berkeley.edu>\n   Stability   : alpha\n   Portability : portable\n\nDefinition of a MediaBag object to hold binary resources, and an\ninterface for interacting with it.\n-}\nmodule Text.Pandoc.MediaBag (\n                     MediaItem(..),\n                     MediaBag,\n                     deleteMedia,\n                     lookupMedia,\n                     insertMedia,\n                     mediaDirectory,\n                     mediaItems\n                     ) where\nimport qualified Data.ByteString.Lazy as BL\nimport Data.Data (Data)\nimport qualified Data.Map as M\nimport Data.Maybe (fromMaybe, isNothing)\nimport Data.Typeable (Typeable)\nimport Network.URI (unEscapeString)\nimport System.FilePath\nimport qualified System.FilePath.Posix as Posix\nimport qualified System.FilePath.Windows as Windows\nimport Text.Pandoc.MIME (MimeType, getMimeTypeDef, extensionFromMimeType)\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Data.Digest.Pure.SHA (sha1, showDigest)\nimport Network.URI (URI (..), parseURI, isURI)\nimport Data.List (isInfixOf)\n\ndata MediaItem =\n  MediaItem\n  { mediaMimeType :: MimeType\n  , mediaPath :: FilePath\n  , mediaContents :: BL.ByteString\n  } deriving (Eq, Ord, Show, Data, Typeable)\n\n-- | A container for a collection of binary resources, with names and\n-- mime types.  Note that a 'MediaBag' is a Monoid, so 'mempty'\n-- can be used for an empty 'MediaBag', and '<>' can be used to append\n-- two 'MediaBag's.\nnewtype MediaBag = MediaBag (M.Map Text MediaItem)\n        deriving (Semigroup, Monoid, Data, Typeable)\n\ninstance Show MediaBag where\n  show bag = \"MediaBag \" ++ show (mediaDirectory bag)\n\n-- | We represent paths with /, in normalized form.  Percent-encoding\n-- is not resolved.\ncanonicalize :: FilePath -> Text\ncanonicalize fp\n  | isURI fp = T.pack fp\n  | otherwise = T.replace \"\\\\\" \"/\" . T.pack . normalise $ fp\n\n-- | Delete a media item from a 'MediaBag', or do nothing if no item corresponds\n-- to the given path.\ndeleteMedia :: FilePath       -- ^ relative path and canonical name of resource\n            -> MediaBag\n            -> MediaBag\ndeleteMedia fp (MediaBag mediamap) =\n  MediaBag $ M.delete (canonicalize fp) mediamap\n\n-- | Insert a media item into a 'MediaBag', replacing any existing\n-- value with the same name.\ninsertMedia :: FilePath       -- ^ relative path and canonical name of resource\n            -> Maybe MimeType -- ^ mime type (Nothing = determine from extension)\n            -> BL.ByteString  -- ^ contents of resource\n            -> MediaBag\n            -> MediaBag\ninsertMedia fp mbMime contents (MediaBag mediamap) =\n  MediaBag (M.insert fp' mediaItem mediamap)\n  where mediaItem = MediaItem{ mediaPath = newpath\n                             , mediaContents = contents\n                             , mediaMimeType = mt }\n        fp' = canonicalize fp\n        fp'' = unEscapeString $ T.unpack fp'\n        uri = parseURI fp\n        newpath = if Posix.isRelative fp''\n                       && Windows.isRelative fp''\n                       && isNothing uri\n                       && not (\"..\" `isInfixOf` fp'')\n                     then fp''\n                     else showDigest (sha1 contents) <> \".\" <> ext\n        fallback = case takeExtension fp'' of\n                        \".gz\" -> getMimeTypeDef $ dropExtension fp''\n                        _     -> getMimeTypeDef fp''\n        mt = fromMaybe fallback mbMime\n        path = maybe fp'' (unEscapeString . uriPath) uri\n        ext = case takeExtension path of\n                '.':e -> e\n                _ -> maybe \"\" T.unpack $ extensionFromMimeType mt\n\n-- | Lookup a media item in a 'MediaBag', returning mime type and contents.\nlookupMedia :: FilePath\n            -> MediaBag\n            -> Maybe MediaItem\nlookupMedia fp (MediaBag mediamap) = M.lookup (canonicalize fp) mediamap\n\n-- | Get a list of the file paths stored in a 'MediaBag', with\n-- their corresponding mime types and the lengths in bytes of the contents.\nmediaDirectory :: MediaBag -> [(FilePath, MimeType, Int)]\nmediaDirectory mediabag =\n  map (\\(fp, mt, bs) -> (fp, mt, fromIntegral (BL.length bs)))\n    (mediaItems mediabag)\n\nmediaItems :: MediaBag -> [(FilePath, MimeType, BL.ByteString)]\nmediaItems (MediaBag mediamap) =\n  map (\\item -> (mediaPath item, mediaMimeType item, mediaContents item))\n      (M.elems mediamap)\n", "{-# LANGUAGE OverloadedStrings #-}\nmodule Tests.MediaBag (tests) where\n\nimport Test.Tasty\nimport Test.Tasty.HUnit\n-- import Tests.Helpers\nimport Text.Pandoc.Class.IO (extractMedia)\nimport Text.Pandoc.Class (fillMediaBag, runIOorExplode)\nimport System.IO.Temp (withTempDirectory)\nimport Text.Pandoc.Shared (inDirectory)\nimport System.FilePath\nimport Text.Pandoc.Builder as B\nimport System.Directory (doesFileExist, copyFile)\n\ntests :: [TestTree]\ntests = [\n  testCase \"test fillMediaBag & extractMedia\" $\n      withTempDirectory \".\" \"extractMediaTest\" $ \\tmpdir -> inDirectory tmpdir $ do\n        copyFile \"../../test/lalune.jpg\" \"moon.jpg\"\n        let d = B.doc $\n                  B.para (B.image \"../../test/lalune.jpg\" \"\" mempty) <>\n                  B.para (B.image \"moon.jpg\" \"\" mempty) <>\n                  B.para (B.image \"data://image/png;base64,cHJpbnQgImhlbGxvIgo=;.lua+%2f%2e%2e%2f%2e%2e%2fa%2elua\" \"\" mempty) <>\n                  B.para (B.image \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\" \"\" mempty)\n        runIOorExplode $ do\n          fillMediaBag d\n          extractMedia \"foo\" d\n        exists1 <- doesFileExist (\"foo\" </> \"moon.jpg\")\n        assertBool \"file in directory is not extracted with original name\" exists1\n        exists2 <- doesFileExist (\"foo\" </> \"f9d88c3dbe18f6a7f5670e994a947d51216cdf0e.jpg\")\n        assertBool \"file above directory is not extracted with hashed name\" exists2\n        exists3 <- doesFileExist (\"foo\" </> \"2a0eaa89f43fada3e6c577beea4f2f8f53ab6a1d.lua\")\n        exists4 <- doesFileExist \"a.lua\"\n        assertBool \"data uri with malicious payload gets written outside of destination dir\"\n          (exists3 && not exists4)\n        exists5 <- doesFileExist (\"foo\" </> \"d5fceb6532643d0d84ffe09c40c481ecdf59e15a.gif\")\n        assertBool \"data uri with gif is not properly decoded\" exists5\n  ]\n"], "fixing_code": ["{-# LANGUAGE CPP #-}\n{-# LANGUAGE OverloadedStrings #-}\n{- |\nModule      : Text.Pandoc.Class.IO\nCopyright   : Copyright (C) 2016-2020 Jesse Rosenthal, John MacFarlane\nLicense     : GNU GPL, version 2 or above\n\nMaintainer  : Jesse Rosenthal <jrosenthal@jhu.edu>\nStability   : alpha\nPortability : portable\n\nDefault ways to perform @'PandocMonad'@ actions in a @'MonadIO'@ type.\n\nThese functions are used to make the @'PandocIO'@ type an instance of\n@'PandocMonad'@, but can be reused for any other MonadIO-conforming\ntypes.\n-}\nmodule Text.Pandoc.Class.IO\n  ( fileExists\n  , getCurrentTime\n  , getCurrentTimeZone\n  , getDataFileName\n  , getModificationTime\n  , glob\n  , logOutput\n  , logIOError\n  , lookupEnv\n  , newStdGen\n  , newUniqueHash\n  , openURL\n  , readFileLazy\n  , readFileStrict\n  , readStdinStrict\n  , extractMedia\n  , writeMedia\n ) where\n\nimport Control.Monad.Except (throwError)\nimport Control.Monad.IO.Class (MonadIO, liftIO)\nimport Data.ByteString.Base64 (decodeBase64Lenient)\nimport Data.ByteString.Lazy (toChunks)\nimport Data.Text (Text, pack, unpack)\nimport Data.Time (TimeZone, UTCTime)\nimport Data.Unique (hashUnique)\nimport Network.Connection (TLSSettings (TLSSettingsSimple))\nimport Network.HTTP.Client\n       (httpLbs, responseBody, responseHeaders,\n        Request(port, host, requestHeaders), parseRequest, newManager)\nimport Network.HTTP.Client.Internal (addProxy)\nimport Network.HTTP.Client.TLS (mkManagerSettings)\nimport Network.HTTP.Types.Header ( hContentType )\nimport Network.Socket (withSocketsDo)\nimport Network.URI (URI(..), parseURI, unEscapeString)\nimport System.Directory (createDirectoryIfMissing)\nimport System.Environment (getEnv)\nimport System.FilePath ((</>), takeDirectory, normalise)\nimport qualified System.FilePath.Posix as Posix\nimport System.IO (stderr)\nimport System.IO.Error\nimport System.Random (StdGen)\nimport Text.Pandoc.Class.CommonState (CommonState (..))\nimport Text.Pandoc.Class.PandocMonad\n       (PandocMonad, getsCommonState, getMediaBag, report)\nimport Text.Pandoc.Definition (Pandoc, Inline (Image))\nimport Text.Pandoc.Error (PandocError (..))\nimport Text.Pandoc.Logging (LogMessage (..), messageVerbosity, showLogMessage)\nimport Text.Pandoc.MIME (MimeType)\nimport Text.Pandoc.MediaBag (MediaBag, MediaItem(..), lookupMedia, mediaItems)\nimport Text.Pandoc.Walk (walk)\nimport qualified Control.Exception as E\nimport qualified Data.ByteString as B\nimport qualified Data.ByteString.Lazy as BL\nimport qualified Data.CaseInsensitive as CI\nimport qualified Data.Text as T\nimport qualified Data.Time\nimport qualified Data.Time.LocalTime\nimport qualified Data.Unique\nimport qualified System.Directory\nimport qualified System.Environment as Env\nimport qualified System.FilePath.Glob\nimport qualified System.Random\nimport qualified Text.Pandoc.UTF8 as UTF8\n#ifndef EMBED_DATA_FILES\nimport qualified Paths_pandoc as Paths\n#endif\n\n-- | Utility function to lift IO errors into 'PandocError's.\nliftIOError :: (PandocMonad m, MonadIO m) => (String -> IO a) -> String -> m a\nliftIOError f u = do\n  res <- liftIO $ tryIOError $ f u\n  case res of\n         Left e  -> throwError $ PandocIOError (pack u) e\n         Right r -> return r\n\n-- | Show potential IO errors to the user continuing execution anyway\nlogIOError :: (PandocMonad m, MonadIO m) => IO () -> m ()\nlogIOError f = do\n  res <- liftIO $ tryIOError f\n  case res of\n    Left e -> report $ IgnoredIOError $ pack $ E.displayException e\n    Right _ -> pure ()\n\n-- | Lookup an environment variable in the programs environment.\nlookupEnv :: MonadIO m => Text -> m (Maybe Text)\nlookupEnv = fmap (fmap pack) . liftIO . Env.lookupEnv . unpack\n\n-- | Get the current (UTC) time.\ngetCurrentTime :: MonadIO m => m UTCTime\ngetCurrentTime = liftIO Data.Time.getCurrentTime\n\n-- | Get the locale's time zone.\ngetCurrentTimeZone :: MonadIO m => m TimeZone\ngetCurrentTimeZone = liftIO Data.Time.LocalTime.getCurrentTimeZone\n\n-- | Return a new generator for random numbers.\nnewStdGen :: MonadIO m => m StdGen\nnewStdGen = liftIO System.Random.newStdGen\n\n-- | Return a new unique integer.\nnewUniqueHash :: MonadIO m => m Int\nnewUniqueHash = hashUnique <$> liftIO Data.Unique.newUnique\n\nopenURL :: (PandocMonad m, MonadIO m) => Text -> m (B.ByteString, Maybe MimeType)\nopenURL u\n | Just (URI{ uriScheme = \"data:\",\n              uriPath = upath }) <- parseURI (T.unpack u) = do\n     let (mime, rest) = break (== ',') $ unEscapeString upath\n     let contents = UTF8.fromString $ drop 1 rest\n     return (decodeBase64Lenient contents, Just (T.pack mime))\n | otherwise = do\n     let toReqHeader (n, v) = (CI.mk (UTF8.fromText n), UTF8.fromText v)\n     customHeaders <- map toReqHeader <$> getsCommonState stRequestHeaders\n     disableCertificateValidation <- getsCommonState stNoCheckCertificate\n     report $ Fetching u\n     res <- liftIO $ E.try $ withSocketsDo $ do\n       let parseReq = parseRequest\n       proxy <- tryIOError (getEnv \"http_proxy\")\n       let addProxy' x = case proxy of\n                            Left _ -> return x\n                            Right pr -> parseReq pr >>= \\r ->\n                                return (addProxy (host r) (port r) x)\n       req <- parseReq (unpack u) >>= addProxy'\n       let req' = req{requestHeaders = customHeaders ++ requestHeaders req}\n       let tlsSimple = TLSSettingsSimple disableCertificateValidation False False\n       let tlsManagerSettings = mkManagerSettings tlsSimple  Nothing\n       resp <- newManager tlsManagerSettings >>= httpLbs req'\n       return (B.concat $ toChunks $ responseBody resp,\n               UTF8.toText `fmap` lookup hContentType (responseHeaders resp))\n\n     case res of\n          Right r -> return r\n          Left e  -> throwError $ PandocHttpError u e\n\n-- | Read the lazy ByteString contents from a file path, raising an error on\n-- failure.\nreadFileLazy :: (PandocMonad m, MonadIO m) => FilePath -> m BL.ByteString\nreadFileLazy s = liftIOError BL.readFile s\n\n-- | Read the strict ByteString contents from a file path,\n-- raising an error on failure.\nreadFileStrict :: (PandocMonad m, MonadIO m) => FilePath -> m B.ByteString\nreadFileStrict s = liftIOError B.readFile s\n\n-- | Read the strict ByteString contents from stdin, raising\n-- an error on failure.\nreadStdinStrict :: (PandocMonad m, MonadIO m) => m B.ByteString\nreadStdinStrict = liftIOError (const B.getContents) \"stdin\"\n\n-- | Return a list of paths that match a glob, relative to the working\n-- directory. See 'System.FilePath.Glob' for the glob syntax.\nglob :: (PandocMonad m, MonadIO m) => String -> m [FilePath]\nglob = liftIOError System.FilePath.Glob.glob\n\n-- | Returns True if file exists.\nfileExists :: (PandocMonad m, MonadIO m) => FilePath -> m Bool\nfileExists = liftIOError System.Directory.doesFileExist\n\n-- | Returns the path of data file.\ngetDataFileName :: (PandocMonad m, MonadIO m) => FilePath -> m FilePath\n#ifdef EMBED_DATA_FILES\ngetDataFileName = return\n#else\ngetDataFileName = liftIOError Paths.getDataFileName\n#endif\n\n-- | Return the modification time of a file.\ngetModificationTime :: (PandocMonad m, MonadIO m) => FilePath -> m UTCTime\ngetModificationTime = liftIOError System.Directory.getModificationTime\n\n-- | Output a log message.\nlogOutput :: (PandocMonad m, MonadIO m) => LogMessage -> m ()\nlogOutput msg = liftIO $ do\n  UTF8.hPutStr stderr $\n      \"[\" <> T.pack (show (messageVerbosity msg)) <> \"] \"\n  alertIndent $ T.lines $ showLogMessage msg\n\n-- | Prints the list of lines to @stderr@, indenting every but the first\n-- line by two spaces.\nalertIndent :: [Text] -> IO ()\nalertIndent [] = return ()\nalertIndent (l:ls) = do\n  UTF8.hPutStrLn stderr l\n  mapM_ go ls\n  where go l' = do UTF8.hPutStr stderr \"  \"\n                   UTF8.hPutStrLn stderr l'\n\n-- | Extract media from the mediabag into a directory.\nextractMedia :: (PandocMonad m, MonadIO m) => FilePath -> Pandoc -> m Pandoc\nextractMedia dir d = do\n  media <- getMediaBag\n  let items = mediaItems media\n  if null items\n    then return d\n    else do\n      mapM_ (writeMedia dir) items\n      return $ walk (adjustImagePath dir media) d\n\n-- | Write the contents of a media bag to a path.\n-- If the path contains URI escape sequences (percent-encoding),\n-- these are resolved.\nwriteMedia :: (PandocMonad m, MonadIO m)\n           => FilePath\n           -> (FilePath, MimeType, BL.ByteString)\n           -> m ()\nwriteMedia dir (fp, _mt, bs) = do\n  -- we normalize to get proper path separators for the platform\n  -- we unescape URI encoding, but given how insertMedia\n  -- is written, we shouldn't have any % in a canonical media name...\n  let fullpath = normalise $ dir </> unEscapeString fp\n  liftIOError (createDirectoryIfMissing True) (takeDirectory fullpath)\n  report $ Extracting (T.pack fullpath)\n  logIOError $ BL.writeFile fullpath bs\n\n-- | If the given Inline element is an image with a @src@ path equal to\n-- one in the list of @paths@, then prepends @dir@ to the image source;\n-- returns the element unchanged otherwise.\nadjustImagePath :: FilePath -> MediaBag -> Inline -> Inline\nadjustImagePath dir mediabag (Image attr lab (src, tit)) =\n  case lookupMedia (T.unpack src) mediabag of\n    Nothing -> Image attr lab (src, tit)\n    Just item ->\n      let fullpath = dir Posix.</> mediaPath item\n      in  Image attr lab (T.pack fullpath, tit)\nadjustImagePath _ _ x = x\n", "{-# LANGUAGE CPP                        #-}\n{-# LANGUAGE OverloadedStrings          #-}\n{-# LANGUAGE DeriveDataTypeable         #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{- |\n   Module      : Text.Pandoc.MediaBag\n   Copyright   : Copyright (C) 2014-2015, 2017-2023 John MacFarlane\n   License     : GNU GPL, version 2 or above\n\n   Maintainer  : John MacFarlane <jgm@berkeley.edu>\n   Stability   : alpha\n   Portability : portable\n\nDefinition of a MediaBag object to hold binary resources, and an\ninterface for interacting with it.\n-}\nmodule Text.Pandoc.MediaBag (\n                     MediaItem(..),\n                     MediaBag,\n                     deleteMedia,\n                     lookupMedia,\n                     insertMedia,\n                     mediaDirectory,\n                     mediaItems\n                     ) where\nimport qualified Data.ByteString.Lazy as BL\nimport Data.Data (Data)\nimport qualified Data.Map as M\nimport Data.Maybe (fromMaybe, isNothing)\nimport Data.Typeable (Typeable)\nimport Network.URI (unEscapeString)\nimport System.FilePath\nimport qualified System.FilePath.Posix as Posix\nimport qualified System.FilePath.Windows as Windows\nimport Text.Pandoc.MIME (MimeType, getMimeTypeDef, extensionFromMimeType)\nimport Data.Text (Text)\nimport qualified Data.Text as T\nimport Data.Digest.Pure.SHA (sha1, showDigest)\nimport Network.URI (URI (..), parseURI, isURI)\nimport Data.List (isInfixOf)\n\ndata MediaItem =\n  MediaItem\n  { mediaMimeType :: MimeType\n  , mediaPath :: FilePath\n  , mediaContents :: BL.ByteString\n  } deriving (Eq, Ord, Show, Data, Typeable)\n\n-- | A container for a collection of binary resources, with names and\n-- mime types.  Note that a 'MediaBag' is a Monoid, so 'mempty'\n-- can be used for an empty 'MediaBag', and '<>' can be used to append\n-- two 'MediaBag's.\nnewtype MediaBag = MediaBag (M.Map Text MediaItem)\n        deriving (Semigroup, Monoid, Data, Typeable)\n\ninstance Show MediaBag where\n  show bag = \"MediaBag \" ++ show (mediaDirectory bag)\n\n-- | We represent paths with /, in normalized form.  Percent-encoding\n-- is not resolved.\ncanonicalize :: FilePath -> Text\ncanonicalize fp\n  | isURI fp = T.pack fp\n  | otherwise = T.replace \"\\\\\" \"/\" . T.pack . normalise $ fp\n\n-- | Delete a media item from a 'MediaBag', or do nothing if no item corresponds\n-- to the given path.\ndeleteMedia :: FilePath       -- ^ relative path and canonical name of resource\n            -> MediaBag\n            -> MediaBag\ndeleteMedia fp (MediaBag mediamap) =\n  MediaBag $ M.delete (canonicalize fp) mediamap\n\n-- | Insert a media item into a 'MediaBag', replacing any existing\n-- value with the same name.\ninsertMedia :: FilePath       -- ^ relative path and canonical name of resource\n            -> Maybe MimeType -- ^ mime type (Nothing = determine from extension)\n            -> BL.ByteString  -- ^ contents of resource\n            -> MediaBag\n            -> MediaBag\ninsertMedia fp mbMime contents (MediaBag mediamap) =\n  MediaBag (M.insert fp' mediaItem mediamap)\n  where mediaItem = MediaItem{ mediaPath = newpath\n                             , mediaContents = contents\n                             , mediaMimeType = mt }\n        fp' = canonicalize fp\n        fp'' = unEscapeString $ T.unpack fp'\n        uri = parseURI fp\n        newpath = if Posix.isRelative fp''\n                       && Windows.isRelative fp''\n                       && isNothing uri\n                       && not (\"..\" `isInfixOf` fp'')\n                       && '%' `notElem` fp''\n                     then fp''\n                     else showDigest (sha1 contents) <> ext\n        fallback = case takeExtension fp'' of\n                        \".gz\" -> getMimeTypeDef $ dropExtension fp''\n                        _     -> getMimeTypeDef fp''\n        mt = fromMaybe fallback mbMime\n        path = maybe fp'' (unEscapeString . uriPath) uri\n        ext = case takeExtension path of\n                '.':e | '%' `notElem` e -> '.':e\n                _ -> maybe \"\" (\\x -> '.':T.unpack x) $ extensionFromMimeType mt\n\n-- | Lookup a media item in a 'MediaBag', returning mime type and contents.\nlookupMedia :: FilePath\n            -> MediaBag\n            -> Maybe MediaItem\nlookupMedia fp (MediaBag mediamap) = M.lookup (canonicalize fp) mediamap\n\n-- | Get a list of the file paths stored in a 'MediaBag', with\n-- their corresponding mime types and the lengths in bytes of the contents.\nmediaDirectory :: MediaBag -> [(FilePath, MimeType, Int)]\nmediaDirectory mediabag =\n  map (\\(fp, mt, bs) -> (fp, mt, fromIntegral (BL.length bs)))\n    (mediaItems mediabag)\n\nmediaItems :: MediaBag -> [(FilePath, MimeType, BL.ByteString)]\nmediaItems (MediaBag mediamap) =\n  map (\\item -> (mediaPath item, mediaMimeType item, mediaContents item))\n      (M.elems mediamap)\n", "{-# LANGUAGE OverloadedStrings #-}\nmodule Tests.MediaBag (tests) where\n\nimport Test.Tasty\nimport Test.Tasty.HUnit\n-- import Tests.Helpers\nimport Text.Pandoc.Class.IO (extractMedia)\nimport Text.Pandoc.Class (fillMediaBag, runIOorExplode)\nimport System.IO.Temp (withTempDirectory)\nimport Text.Pandoc.Shared (inDirectory)\nimport System.FilePath\nimport Text.Pandoc.Builder as B\nimport System.Directory (doesFileExist, copyFile)\n\ntests :: [TestTree]\ntests = [\n  testCase \"test fillMediaBag & extractMedia\" $\n      withTempDirectory \".\" \"extractMediaTest\" $ \\tmpdir -> inDirectory tmpdir $ do\n        copyFile \"../../test/lalune.jpg\" \"moon.jpg\"\n        let d = B.doc $\n                  B.para (B.image \"../../test/lalune.jpg\" \"\" mempty) <>\n                  B.para (B.image \"moon.jpg\" \"\" mempty) <>\n                  B.para (B.image \"data:image/png;base64,cHJpbnQgImhlbGxvIgo=;.lua+%2f%2e%2e%2f%2e%2e%2fa%2elua\" \"\" mempty) <>\n                  B.para (B.image \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\" \"\" mempty)\n        runIOorExplode $ do\n          fillMediaBag d\n          extractMedia \"foo\" d\n        exists1 <- doesFileExist (\"foo\" </> \"moon.jpg\")\n        assertBool \"file in directory is not extracted with original name\" exists1\n        exists2 <- doesFileExist (\"foo\" </> \"f9d88c3dbe18f6a7f5670e994a947d51216cdf0e.jpg\")\n        assertBool \"file above directory is not extracted with hashed name\" exists2\n        exists3 <- doesFileExist (\"foo\" </> \"2a0eaa89f43fada3e6c577beea4f2f8f53ab6a1d.lua\")\n        exists4 <- doesFileExist \"a.lua\"\n        assertBool \"data uri with malicious payload gets written outside of destination dir\"\n          (exists3 && not exists4)\n        exists5 <- doesFileExist (\"foo\" </> \"d5fceb6532643d0d84ffe09c40c481ecdf59e15a.gif\")\n        assertBool \"data uri with gif is not properly decoded\" exists5\n        -- double-encoded version:\n        let e = B.doc $\n                  B.para (B.image \"data:image/png;base64,cHJpbnQgInB3bmVkIgo=;.lua+%252f%252e%252e%252f%252e%252e%252fb%252elua\" \"\" mempty)\n        runIOorExplode $ do\n          fillMediaBag e\n          extractMedia \"bar\" e\n        exists6 <- doesFileExist (\"bar\" </> \"772ceca21a2751863ec46cb23db0e7fc35b9cff8.png\")\n        exists7 <- doesFileExist \"b.lua\"\n        assertBool \"data uri with double-encoded malicious payload gets written outside of destination dir\"\n          (exists6 && not exists7)\n  ]\n"], "filenames": ["src/Text/Pandoc/Class/IO.hs", "src/Text/Pandoc/MediaBag.hs", "test/Tests/MediaBag.hs"], "buggy_code_start_loc": [226, 92, 23], "buggy_code_end_loc": [226, 103, 37], "fixing_code_start_loc": [227, 93, 23], "fixing_code_end_loc": [229, 104, 48], "type": "NVD-CWE-noinfo", "message": "Pandoc before 3.1.6 allows arbitrary file write: this can be triggered by providing a crafted image element in the input when generating files via the --extract-media option or outputting to PDF format. This allows an attacker to create or overwrite arbitrary files, depending on the privileges of the process running Pandoc. It only affects systems that pass untrusted user input to Pandoc and allow Pandoc to be used to produce a PDF or with the --extract-media option. NOTE: this issue exists because of an incomplete fix for CVE-2023-35936 (failure to properly account for double encoded path names).", "other": {"cve": {"id": "CVE-2023-38745", "sourceIdentifier": "cve@mitre.org", "published": "2023-07-25T04:15:10.633", "lastModified": "2023-08-03T13:43:26.167", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Pandoc before 3.1.6 allows arbitrary file write: this can be triggered by providing a crafted image element in the input when generating files via the --extract-media option or outputting to PDF format. This allows an attacker to create or overwrite arbitrary files, depending on the privileges of the process running Pandoc. It only affects systems that pass untrusted user input to Pandoc and allow Pandoc to be used to produce a PDF or with the --extract-media option. NOTE: this issue exists because of an incomplete fix for CVE-2023-35936 (failure to properly account for double encoded path names)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:U/C:N/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pandoc:pandoc:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.1.6", "matchCriteriaId": "537937D6-5E62-46CE-8C76-AD59C32F0A24"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/jgm/pandoc/commit/eddedbfc14916aa06fc01ff04b38aeb30ae2e625", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/jgm/pandoc/compare/3.1.5...3.1.6", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/07/msg00029.html", "source": "cve@mitre.org", "tags": ["Mailing List"]}]}, "github_commit_url": "https://github.com/jgm/pandoc/commit/eddedbfc14916aa06fc01ff04b38aeb30ae2e625"}}