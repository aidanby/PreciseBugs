{"buggy_code": ["//\n// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage cosign\n\nimport (\n\t\"context\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"runtime\"\n\t\"sync\"\n\n\t\"github.com/google/go-containerregistry/pkg/name\"\n\t\"github.com/in-toto/in-toto-golang/in_toto\"\n\t\"github.com/sigstore/cosign/v2/pkg/cosign/bundle\"\n\t\"github.com/sigstore/cosign/v2/pkg/oci\"\n\tociremote \"github.com/sigstore/cosign/v2/pkg/oci/remote\"\n\t\"golang.org/x/sync/errgroup\"\n)\n\ntype SignedPayload struct {\n\tBase64Signature  string\n\tPayload          []byte\n\tCert             *x509.Certificate\n\tChain            []*x509.Certificate\n\tBundle           *bundle.RekorBundle\n\tRFC3161Timestamp *bundle.RFC3161Timestamp\n}\n\ntype LocalSignedPayload struct {\n\tBase64Signature string              `json:\"base64Signature\"`\n\tCert            string              `json:\"cert,omitempty\"`\n\tBundle          *bundle.RekorBundle `json:\"rekorBundle,omitempty\"`\n}\n\ntype Signatures struct {\n\tKeyID string `json:\"keyid\"`\n\tSig   string `json:\"sig\"`\n}\n\ntype AttestationPayload struct {\n\tPayloadType string       `json:\"payloadType\"`\n\tPayLoad     string       `json:\"payload\"`\n\tSignatures  []Signatures `json:\"signatures\"`\n}\n\nconst (\n\tSignature   = \"signature\"\n\tSBOM        = \"sbom\"\n\tAttestation = \"attestation\"\n\tDigest      = \"digest\"\n)\n\nfunc FetchSignaturesForReference(_ context.Context, ref name.Reference, opts ...ociremote.Option) ([]SignedPayload, error) {\n\tsimg, err := ociremote.SignedEntity(ref, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsigs, err := simg.Signatures()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"remote image: %w\", err)\n\t}\n\tl, err := sigs.Get()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"fetching signatures: %w\", err)\n\t}\n\tif len(l) == 0 {\n\t\treturn nil, fmt.Errorf(\"no signatures associated with %s\", ref)\n\t}\n\n\tsignatures := make([]SignedPayload, len(l))\n\tvar g errgroup.Group\n\tg.SetLimit(runtime.NumCPU())\n\tfor i, sig := range l {\n\t\ti, sig := i, sig\n\t\tg.Go(func() error {\n\t\t\tvar err error\n\t\t\tsignatures[i].Payload, err = sig.Payload()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tsignatures[i].Base64Signature, err = sig.Base64Signature()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tsignatures[i].Cert, err = sig.Cert()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tsignatures[i].Chain, err = sig.Chain()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tsignatures[i].RFC3161Timestamp, err = sig.RFC3161Timestamp()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tsignatures[i].Bundle, err = sig.Bundle()\n\t\t\treturn err\n\t\t})\n\t}\n\tif err := g.Wait(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn signatures, nil\n}\n\nfunc FetchAttestationsForReference(_ context.Context, ref name.Reference, predicateType string, opts ...ociremote.Option) ([]AttestationPayload, error) {\n\tse, err := ociremote.SignedEntity(ref, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn FetchAttestations(se, predicateType)\n}\n\nfunc FetchAttestations(se oci.SignedEntity, predicateType string) ([]AttestationPayload, error) {\n\tatts, err := se.Attestations()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"remote image: %w\", err)\n\t}\n\tl, err := atts.Get()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"fetching attestations: %w\", err)\n\t}\n\tif len(l) == 0 {\n\t\treturn nil, errors.New(\"found no attestations\")\n\t}\n\n\tattestations := make([]AttestationPayload, 0, len(l))\n\tvar attMu sync.Mutex\n\n\tvar g errgroup.Group\n\tg.SetLimit(runtime.NumCPU())\n\n\tfor _, att := range l {\n\t\tatt := att\n\t\tg.Go(func() error {\n\t\t\trawPayload, err := att.Payload()\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"fetching payload: %w\", err)\n\t\t\t}\n\t\t\tvar payload AttestationPayload\n\t\t\tif err := json.Unmarshal(rawPayload, &payload); err != nil {\n\t\t\t\treturn fmt.Errorf(\"unmarshaling payload: %w\", err)\n\t\t\t}\n\n\t\t\tif predicateType != \"\" {\n\t\t\t\tvar decodedPayload []byte\n\t\t\t\tdecodedPayload, err = base64.StdEncoding.DecodeString(payload.PayLoad)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"decoding payload: %w\", err)\n\t\t\t\t}\n\t\t\t\tvar statement in_toto.Statement\n\t\t\t\tif err := json.Unmarshal(decodedPayload, &statement); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"unmarshaling statement: %w\", err)\n\t\t\t\t}\n\t\t\t\tif statement.PredicateType != predicateType {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tattMu.Lock()\n\t\t\tdefer attMu.Unlock()\n\t\t\tattestations = append(attestations, payload)\n\t\t\treturn nil\n\t\t})\n\t}\n\tif err := g.Wait(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(attestations) == 0 && predicateType != \"\" {\n\t\treturn nil, fmt.Errorf(\"no attestations with predicate type '%s' found\", predicateType)\n\t}\n\n\treturn attestations, nil\n}\n\n// FetchLocalSignedPayloadFromPath fetches a local signed payload from a path to a file\nfunc FetchLocalSignedPayloadFromPath(path string) (*LocalSignedPayload, error) {\n\tcontents, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"reading %s: %w\", path, err)\n\t}\n\tvar b *LocalSignedPayload\n\tif err := json.Unmarshal(contents, &b); err != nil {\n\t\treturn nil, err\n\t}\n\treturn b, nil\n}\n", "//\n// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build e2e\n// +build e2e\n\npackage test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/go-openapi/strfmt\"\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/google/go-containerregistry/pkg/authn\"\n\t\"github.com/google/go-containerregistry/pkg/name\"\n\t\"github.com/google/go-containerregistry/pkg/registry\"\n\t\"github.com/google/go-containerregistry/pkg/v1/random\"\n\t\"github.com/google/go-containerregistry/pkg/v1/remote\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\tk8s \"k8s.io/client-go/kubernetes\"\n\t\"k8s.io/client-go/tools/clientcmd\"\n\n\t// Initialize all known client auth plugins\n\t_ \"k8s.io/client-go/plugin/pkg/client/auth\"\n\n\t\"github.com/sigstore/cosign/v2/cmd/cosign/cli\"\n\t\"github.com/sigstore/cosign/v2/cmd/cosign/cli/attach\"\n\t\"github.com/sigstore/cosign/v2/cmd/cosign/cli/attest\"\n\t\"github.com/sigstore/cosign/v2/cmd/cosign/cli/download\"\n\t\"github.com/sigstore/cosign/v2/cmd/cosign/cli/generate\"\n\t\"github.com/sigstore/cosign/v2/cmd/cosign/cli/options\"\n\t\"github.com/sigstore/cosign/v2/cmd/cosign/cli/publickey\"\n\t\"github.com/sigstore/cosign/v2/cmd/cosign/cli/sign\"\n\tcliverify \"github.com/sigstore/cosign/v2/cmd/cosign/cli/verify\"\n\t\"github.com/sigstore/cosign/v2/internal/pkg/cosign/tsa\"\n\t\"github.com/sigstore/cosign/v2/internal/pkg/cosign/tsa/client\"\n\t\"github.com/sigstore/cosign/v2/pkg/cosign\"\n\t\"github.com/sigstore/cosign/v2/pkg/cosign/bundle\"\n\t\"github.com/sigstore/cosign/v2/pkg/cosign/env\"\n\t\"github.com/sigstore/cosign/v2/pkg/cosign/kubernetes\"\n\t\"github.com/sigstore/cosign/v2/pkg/oci/mutate\"\n\tociremote \"github.com/sigstore/cosign/v2/pkg/oci/remote\"\n\tsigs \"github.com/sigstore/cosign/v2/pkg/signature\"\n\t\"github.com/sigstore/sigstore/pkg/signature/payload\"\n\ttsaclient \"github.com/sigstore/timestamp-authority/pkg/client\"\n\t\"github.com/sigstore/timestamp-authority/pkg/server\"\n\t\"github.com/spf13/viper\"\n)\n\nconst (\n\tserverEnv = \"REKOR_SERVER\"\n\trekorURL  = \"https://rekor.sigstore.dev\"\n\tfulcioURL = \"https://fulcio.sigstore.dev\"\n)\n\nvar keyPass = []byte(\"hello\")\n\nvar passFunc = func(_ bool) ([]byte, error) {\n\treturn keyPass, nil\n}\n\nvar verify = func(keyRef, imageRef string, checkClaims bool, annotations map[string]interface{}, attachment string) error {\n\tcmd := cliverify.VerifyCommand{\n\t\tKeyRef:        keyRef,\n\t\tRekorURL:      rekorURL,\n\t\tCheckClaims:   checkClaims,\n\t\tAnnotations:   sigs.AnnotationsMap{Annotations: annotations},\n\t\tAttachment:    attachment,\n\t\tHashAlgorithm: crypto.SHA256,\n\t\tIgnoreTlog:    true,\n\t\tMaxWorkers:    10,\n\t}\n\n\targs := []string{imageRef}\n\n\treturn cmd.Exec(context.Background(), args)\n}\n\nvar verifyTSA = func(keyRef, imageRef string, checkClaims bool, annotations map[string]interface{}, attachment, tsaCertChain string, skipTlogVerify bool) error {\n\tcmd := cliverify.VerifyCommand{\n\t\tKeyRef:           keyRef,\n\t\tCheckClaims:      checkClaims,\n\t\tAnnotations:      sigs.AnnotationsMap{Annotations: annotations},\n\t\tAttachment:       attachment,\n\t\tHashAlgorithm:    crypto.SHA256,\n\t\tTSACertChainPath: tsaCertChain,\n\t\tIgnoreTlog:       skipTlogVerify,\n\t\tMaxWorkers:       10,\n\t}\n\n\targs := []string{imageRef}\n\n\treturn cmd.Exec(context.Background(), args)\n}\n\nvar verifyKeylessTSA = func(imageRef string, tsaCertChain string, skipSCT bool, skipTlogVerify bool) error {\n\tcmd := cliverify.VerifyCommand{\n\t\tCertVerifyOptions: options.CertVerifyOptions{\n\t\t\tCertOidcIssuerRegexp: \".*\",\n\t\t\tCertIdentityRegexp:   \".*\",\n\t\t},\n\t\tHashAlgorithm:    crypto.SHA256,\n\t\tTSACertChainPath: tsaCertChain,\n\t\tIgnoreSCT:        skipSCT,\n\t\tIgnoreTlog:       skipTlogVerify,\n\t\tMaxWorkers:       10,\n\t}\n\n\targs := []string{imageRef}\n\n\treturn cmd.Exec(context.Background(), args)\n}\n\n// Used to verify local images stored on disk\nvar verifyLocal = func(keyRef, path string, checkClaims bool, annotations map[string]interface{}, attachment string) error {\n\tcmd := cliverify.VerifyCommand{\n\t\tKeyRef:        keyRef,\n\t\tCheckClaims:   checkClaims,\n\t\tAnnotations:   sigs.AnnotationsMap{Annotations: annotations},\n\t\tAttachment:    attachment,\n\t\tHashAlgorithm: crypto.SHA256,\n\t\tLocalImage:    true,\n\t\tIgnoreTlog:    true,\n\t\tMaxWorkers:    10,\n\t}\n\n\targs := []string{path}\n\n\treturn cmd.Exec(context.Background(), args)\n}\n\nvar ro = &options.RootOptions{Timeout: options.DefaultTimeout}\n\nfunc TestSignVerify(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tctx := context.Background()\n\t// Verify should fail at first\n\tmustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\t// So should download\n\tmustErr(download.SignatureCmd(ctx, options.RegistryOptions{}, imgName), t)\n\n\t// Now sign the image\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tso := options.SignOptions{\n\t\tUpload: true,\n\t}\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\n\t// Now verify and download should work!\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\tmust(download.SignatureCmd(ctx, options.RegistryOptions{}, imgName), t)\n\n\t// Look for a specific annotation\n\tmustErr(verify(pubKeyPath, imgName, true, map[string]interface{}{\"foo\": \"bar\"}, \"\"), t)\n\n\tso.AnnotationOptions = options.AnnotationOptions{\n\t\tAnnotations: []string{\"foo=bar\"},\n\t}\n\t// Sign the image with an annotation\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\n\t// It should match this time.\n\tmust(verify(pubKeyPath, imgName, true, map[string]interface{}{\"foo\": \"bar\"}, \"\"), t)\n\n\t// But two doesn't work\n\tmustErr(verify(pubKeyPath, imgName, true, map[string]interface{}{\"foo\": \"bar\", \"baz\": \"bat\"}, \"\"), t)\n}\n\nfunc TestSignVerifyClean(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, _ = mkimage(t, imgName)\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tctx := context.Background()\n\n\t// Now sign the image\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tso := options.SignOptions{\n\t\tUpload: true,\n\t}\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\n\t// Now verify and download should work!\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\tmust(download.SignatureCmd(ctx, options.RegistryOptions{}, imgName), t)\n\n\t// Now clean signature from the given image\n\tmust(cli.CleanCmd(ctx, options.RegistryOptions{}, \"all\", imgName, true), t)\n\n\t// It doesn't work\n\tmustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n}\n\nfunc TestImportSignVerifyClean(t *testing.T) {\n\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, _ = mkimage(t, imgName)\n\n\t_, privKeyPath, pubKeyPath := importKeyPair(t, td)\n\n\tctx := context.Background()\n\n\t// Now sign the image\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tso := options.SignOptions{\n\t\tUpload: true,\n\t}\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\n\t// Now verify and download should work!\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\tmust(download.SignatureCmd(ctx, options.RegistryOptions{}, imgName), t)\n\n\t// Now clean signature from the given image\n\tmust(cli.CleanCmd(ctx, options.RegistryOptions{}, \"all\", imgName, true), t)\n\n\t// It doesn't work\n\tmustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n}\n\nfunc TestAttestVerify(t *testing.T) {\n\tattestVerify(t,\n\t\t\"slsaprovenance\",\n\t\t`{ \"buildType\": \"x\", \"builder\": { \"id\": \"2\" }, \"recipe\": {} }`,\n\t\t`predicate: builder: id: \"2\"`,\n\t\t`predicate: builder: id: \"1\"`,\n\t)\n}\n\nfunc TestAttestVerifySPDXJSON(t *testing.T) {\n\tattestationBytes, err := os.ReadFile(\"./testdata/bom-go-mod.spdx.json\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tattestVerify(t,\n\t\t\"spdxjson\",\n\t\tstring(attestationBytes),\n\t\t`predicate: spdxVersion: \"SPDX-2.2\"`,\n\t\t`predicate: spdxVersion: \"SPDX-9.9\"`,\n\t)\n}\n\nfunc TestAttestVerifyCycloneDXJSON(t *testing.T) {\n\tattestationBytes, err := os.ReadFile(\"./testdata/bom-go-mod.cyclonedx.json\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tattestVerify(t,\n\t\t\"cyclonedx\",\n\t\tstring(attestationBytes),\n\t\t`predicate: specVersion: \"1.4\"`,\n\t\t`predicate: specVersion: \"7.7\"`,\n\t)\n}\n\nfunc TestAttestVerifyURI(t *testing.T) {\n\tattestationBytes, err := os.ReadFile(\"./testdata/test-result.json\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tattestVerify(t,\n\t\t\"https://example.com/TestResult/v1\",\n\t\tstring(attestationBytes),\n\t\t`predicate: passed: true`,\n\t\t`predicate: passed: false\"`,\n\t)\n}\n\nfunc attestVerify(t *testing.T, predicateType, attestation, goodCue, badCue string) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\tvar imgName, attestationPath string\n\tif _, err := url.ParseRequestURI(predicateType); err == nil {\n\t\t// If the predicate type is URI, it cannot be included as image name and path.\n\t\timgName = path.Join(repo, \"cosign-attest-uri-e2e-image\")\n\t\tattestationPath = filepath.Join(td, \"cosign-attest-uri-e2e-attestation\")\n\t} else {\n\t\timgName = path.Join(repo, fmt.Sprintf(\"cosign-attest-%s-e2e-image\", predicateType))\n\t\tattestationPath = filepath.Join(td, fmt.Sprintf(\"cosign-attest-%s-e2e-attestation\", predicateType))\n\t}\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tctx := context.Background()\n\n\t// Verify should fail at first\n\tverifyAttestation := cliverify.VerifyAttestationCommand{\n\t\tKeyRef:     pubKeyPath,\n\t\tIgnoreTlog: true,\n\t\tMaxWorkers: 10,\n\t}\n\n\t// Fail case when using without type and policy flag\n\tmustErr(verifyAttestation.Exec(ctx, []string{imgName}), t)\n\n\tif err := os.WriteFile(attestationPath, []byte(attestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Now attest the image\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tattestCmd := attest.AttestCommand{\n\t\tKeyOpts:       ko,\n\t\tPredicatePath: attestationPath,\n\t\tPredicateType: predicateType,\n\t\tTimeout:       30 * time.Second,\n\t}\n\tmust(attestCmd.Exec(ctx, imgName), t)\n\n\t// Use cue to verify attestation\n\tpolicyPath := filepath.Join(td, \"policy.cue\")\n\tverifyAttestation.PredicateType = predicateType\n\tverifyAttestation.Policies = []string{policyPath}\n\n\t// Fail case\n\tif err := os.WriteFile(policyPath, []byte(badCue), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tmustErr(verifyAttestation.Exec(ctx, []string{imgName}), t)\n\n\t// Success case\n\tif err := os.WriteFile(policyPath, []byte(goodCue), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tmust(verifyAttestation.Exec(ctx, []string{imgName}), t)\n\n\t// Look for a specific annotation\n\tmustErr(verify(pubKeyPath, imgName, true, map[string]interface{}{\"foo\": \"bar\"}, \"\"), t)\n}\n\nfunc TestAttestationDownload(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-attest-download-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, _ := keypair(t, td)\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\n\tctx := context.Background()\n\n\tslsaAttestation := `{ \"buildType\": \"x\", \"builder\": { \"id\": \"2\" }, \"recipe\": {} }`\n\tslsaAttestationPath := filepath.Join(td, \"attestation.slsa.json\")\n\tif err := os.WriteFile(slsaAttestationPath, []byte(slsaAttestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvulnAttestation := `\n\t{\n    \"invocation\": {\n      \"parameters\": null,\n      \"uri\": \"invocation.example.com/cosign-testing\",\n      \"event_id\": \"\",\n      \"builder.id\": \"\"\n    },\n    \"scanner\": {\n      \"uri\": \"fakescanner.example.com/cosign-testing\",\n      \"version\": \"\",\n      \"db\": {\n        \"uri\": \"\",\n        \"version\": \"\"\n      },\n      \"result\": null\n    },\n    \"metadata\": {\n      \"scanStartedOn\": \"2022-04-12T00:00:00Z\",\n      \"scanFinishedOn\": \"2022-04-12T00:10:00Z\"\n    }\n}\n`\n\tvulnAttestationPath := filepath.Join(td, \"attestation.vuln.json\")\n\tif err := os.WriteFile(vulnAttestationPath, []byte(vulnAttestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tref, err := name.ParseReference(imgName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tregOpts := options.RegistryOptions{}\n\tociremoteOpts, err := regOpts.ClientOpts(ctx)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Attest to create a slsa attestation\n\tattestCommand := attest.AttestCommand{\n\t\tKeyOpts:       ko,\n\t\tPredicatePath: slsaAttestationPath,\n\t\tPredicateType: \"slsaprovenance\",\n\t\tTimeout:       30 * time.Second,\n\t\tReplace:       true,\n\t}\n\tmust(attestCommand.Exec(ctx, imgName), t)\n\n\t// Attest to create a vuln attestation\n\tattestCommand = attest.AttestCommand{\n\t\tKeyOpts:       ko,\n\t\tPredicatePath: vulnAttestationPath,\n\t\tPredicateType: \"vuln\",\n\t\tTimeout:       30 * time.Second,\n\t\tReplace:       true,\n\t}\n\tmust(attestCommand.Exec(ctx, imgName), t)\n\n\t// Call download.AttestationCmd() to ensure success\n\tattOpts := options.AttestationDownloadOptions{}\n\tmust(download.AttestationCmd(ctx, regOpts, attOpts, imgName), t)\n\n\tattestations, err := cosign.FetchAttestationsForReference(ctx, ref, attOpts.PredicateType, ociremoteOpts...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(attestations) != 2 {\n\t\tt.Fatal(fmt.Errorf(\"expected len(attestations) == 2, got %d\", len(attestations)))\n\t}\n}\n\nfunc TestAttestationDownloadWithPredicateType(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-attest-download-predicate-type-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, _ := keypair(t, td)\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\n\tctx := context.Background()\n\n\tslsaAttestation := `{ \"buildType\": \"x\", \"builder\": { \"id\": \"2\" }, \"recipe\": {} }`\n\tslsaAttestationPath := filepath.Join(td, \"attestation.slsa.json\")\n\tif err := os.WriteFile(slsaAttestationPath, []byte(slsaAttestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvulnAttestation := `\n\t{\n    \"invocation\": {\n      \"parameters\": null,\n      \"uri\": \"invocation.example.com/cosign-testing\",\n      \"event_id\": \"\",\n      \"builder.id\": \"\"\n    },\n    \"scanner\": {\n      \"uri\": \"fakescanner.example.com/cosign-testing\",\n      \"version\": \"\",\n      \"db\": {\n        \"uri\": \"\",\n        \"version\": \"\"\n      },\n      \"result\": null\n    },\n    \"metadata\": {\n      \"scanStartedOn\": \"2022-04-12T00:00:00Z\",\n      \"scanFinishedOn\": \"2022-04-12T00:10:00Z\"\n    }\n}\n`\n\tvulnAttestationPath := filepath.Join(td, \"attestation.vuln.json\")\n\tif err := os.WriteFile(vulnAttestationPath, []byte(vulnAttestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tref, err := name.ParseReference(imgName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tregOpts := options.RegistryOptions{}\n\tociremoteOpts, err := regOpts.ClientOpts(ctx)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Attest to create a slsa attestation\n\tattestCommand := attest.AttestCommand{\n\t\tKeyOpts:       ko,\n\t\tPredicatePath: slsaAttestationPath,\n\t\tPredicateType: \"slsaprovenance\",\n\t\tTimeout:       30 * time.Second,\n\t\tReplace:       true,\n\t}\n\tmust(attestCommand.Exec(ctx, imgName), t)\n\n\t// Attest to create a vuln attestation\n\tattestCommand = attest.AttestCommand{\n\t\tKeyOpts:       ko,\n\t\tPredicatePath: vulnAttestationPath,\n\t\tPredicateType: \"vuln\",\n\t\tTimeout:       30 * time.Second,\n\t\tReplace:       true,\n\t}\n\tmust(attestCommand.Exec(ctx, imgName), t)\n\n\t// Call download.AttestationCmd() to ensure success with --predicate-type\n\tattOpts := options.AttestationDownloadOptions{\n\t\tPredicateType: \"vuln\",\n\t}\n\tmust(download.AttestationCmd(ctx, regOpts, attOpts, imgName), t)\n\n\tpredicateType, _ := options.ParsePredicateType(attOpts.PredicateType)\n\tattestations, err := cosign.FetchAttestationsForReference(ctx, ref, predicateType, ociremoteOpts...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(attestations) != 1 {\n\t\tt.Fatal(fmt.Errorf(\"expected len(attestations) == 1, got %d\", len(attestations)))\n\t}\n}\n\nfunc TestAttestationDownloadWithBadPredicateType(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-attest-download-bad-type-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, _ := keypair(t, td)\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\n\tctx := context.Background()\n\n\tslsaAttestation := `{ \"buildType\": \"x\", \"builder\": { \"id\": \"2\" }, \"recipe\": {} }`\n\tslsaAttestationPath := filepath.Join(td, \"attestation.slsa.json\")\n\tif err := os.WriteFile(slsaAttestationPath, []byte(slsaAttestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tregOpts := options.RegistryOptions{}\n\n\t// Attest to create a slsa attestation\n\tattestCommand := attest.AttestCommand{\n\t\tKeyOpts:       ko,\n\t\tPredicatePath: slsaAttestationPath,\n\t\tPredicateType: \"slsaprovenance\",\n\t\tTimeout:       30 * time.Second,\n\t\tReplace:       true,\n\t}\n\tmust(attestCommand.Exec(ctx, imgName), t)\n\n\t// Call download.AttestationCmd() to ensure failure with non-existant --predicate-type\n\tattOpts := options.AttestationDownloadOptions{\n\t\tPredicateType: \"vuln\",\n\t}\n\tmustErr(download.AttestationCmd(ctx, regOpts, attOpts, imgName), t)\n}\n\nfunc TestAttestationReplaceCreate(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-attest-replace-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, _ := keypair(t, td)\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\n\tctx := context.Background()\n\n\tslsaAttestation := `{ \"buildType\": \"x\", \"builder\": { \"id\": \"2\" }, \"recipe\": {} }`\n\tslsaAttestationPath := filepath.Join(td, \"attestation.slsa.json\")\n\tif err := os.WriteFile(slsaAttestationPath, []byte(slsaAttestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tref, err := name.ParseReference(imgName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tregOpts := options.RegistryOptions{}\n\tociremoteOpts, err := regOpts.ClientOpts(ctx)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Attest with replace=true to create an attestation\n\tattestCommand := attest.AttestCommand{\n\t\tKeyOpts:       ko,\n\t\tPredicatePath: slsaAttestationPath,\n\t\tPredicateType: \"slsaprovenance\",\n\t\tTimeout:       30 * time.Second,\n\t\tReplace:       true,\n\t}\n\tmust(attestCommand.Exec(ctx, imgName), t)\n\n\t// Download and count the attestations\n\tattOpts := options.AttestationDownloadOptions{}\n\tattestations, err := cosign.FetchAttestationsForReference(ctx, ref, attOpts.PredicateType, ociremoteOpts...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(attestations) != 1 {\n\t\tt.Fatal(fmt.Errorf(\"expected len(attestations) == 1, got %d\", len(attestations)))\n\t}\n}\n\nfunc TestAttestationReplace(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-attest-replace-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, _ := keypair(t, td)\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\n\tctx := context.Background()\n\n\tslsaAttestation := `{ \"buildType\": \"x\", \"builder\": { \"id\": \"2\" }, \"recipe\": {} }`\n\tslsaAttestationPath := filepath.Join(td, \"attestation.slsa.json\")\n\tif err := os.WriteFile(slsaAttestationPath, []byte(slsaAttestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tref, err := name.ParseReference(imgName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tregOpts := options.RegistryOptions{}\n\tociremoteOpts, err := regOpts.ClientOpts(ctx)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Attest once with replace=false creating an attestation\n\tattestCommand := attest.AttestCommand{\n\t\tKeyOpts:       ko,\n\t\tPredicatePath: slsaAttestationPath,\n\t\tPredicateType: \"slsaprovenance\",\n\t\tTimeout:       30 * time.Second,\n\t}\n\tmust(attestCommand.Exec(ctx, imgName), t)\n\n\t// Download and count the attestations\n\tattOpts := options.AttestationDownloadOptions{}\n\tattestations, err := cosign.FetchAttestationsForReference(ctx, ref, attOpts.PredicateType, ociremoteOpts...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(attestations) != 1 {\n\t\tt.Fatal(fmt.Errorf(\"expected len(attestations) == 1, got %d\", len(attestations)))\n\t}\n\n\t// Attest again with replace=true, replacing the previous attestation\n\tattestCommand = attest.AttestCommand{\n\t\tKeyOpts:       ko,\n\t\tPredicatePath: slsaAttestationPath,\n\t\tPredicateType: \"slsaprovenance\",\n\t\tReplace:       true,\n\t\tTimeout:       30 * time.Second,\n\t}\n\tmust(attestCommand.Exec(ctx, imgName), t)\n\tattestations, err = cosign.FetchAttestationsForReference(ctx, ref, attOpts.PredicateType, ociremoteOpts...)\n\n\t// Download and count the attestations\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(attestations) != 1 {\n\t\tt.Fatal(fmt.Errorf(\"expected len(attestations) == 1, got %d\", len(attestations)))\n\t}\n\n\t// Attest once more replace=true using a different predicate, to ensure it adds a new attestation\n\tattestCommand = attest.AttestCommand{\n\t\tKeyOpts:       ko,\n\t\tPredicatePath: slsaAttestationPath,\n\t\tPredicateType: \"custom\",\n\t\tReplace:       true,\n\t\tTimeout:       30 * time.Second,\n\t}\n\tmust(attestCommand.Exec(ctx, imgName), t)\n\n\t// Download and count the attestations\n\tattestations, err = cosign.FetchAttestationsForReference(ctx, ref, attOpts.PredicateType, ociremoteOpts...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(attestations) != 2 {\n\t\tt.Fatal(fmt.Errorf(\"expected len(attestations) == 2, got %d\", len(attestations)))\n\t}\n}\n\nfunc TestAttestationRFC3161Timestamp(t *testing.T) {\n\t// TSA server needed to create timestamp\n\tviper.Set(\"timestamp-signer\", \"memory\")\n\tviper.Set(\"timestamp-signer-hash\", \"sha256\")\n\tapiServer := server.NewRestAPIServer(\"localhost\", 0, []string{\"http\"}, false, 10*time.Second, 10*time.Second)\n\tserver := httptest.NewServer(apiServer.GetHandler())\n\tt.Cleanup(server.Close)\n\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-attest-timestamp-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\n\tctx := context.Background()\n\n\tslsaAttestation := `{ \"buildType\": \"x\", \"builder\": { \"id\": \"2\" }, \"recipe\": {} }`\n\tslsaAttestationPath := filepath.Join(td, \"attestation.slsa.json\")\n\tif err := os.WriteFile(slsaAttestationPath, []byte(slsaAttestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tref, err := name.ParseReference(imgName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tregOpts := options.RegistryOptions{}\n\tociremoteOpts, err := regOpts.ClientOpts(ctx)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Attest with TSA and skipping tlog creating an attestation\n\tattestCommand := attest.AttestCommand{\n\t\tKeyOpts:       ko,\n\t\tPredicatePath: slsaAttestationPath,\n\t\tPredicateType: \"slsaprovenance\",\n\t\tTimeout:       30 * time.Second,\n\t\tTSAServerURL:  server.URL + \"/api/v1/timestamp\",\n\t\tTlogUpload:    false,\n\t}\n\tmust(attestCommand.Exec(ctx, imgName), t)\n\n\t// Download and count the attestations\n\tattOpts := options.AttestationDownloadOptions{}\n\tattestations, err := cosign.FetchAttestationsForReference(ctx, ref, attOpts.PredicateType, ociremoteOpts...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(attestations) != 1 {\n\t\tt.Fatal(fmt.Errorf(\"expected len(attestations) == 1, got %d\", len(attestations)))\n\t}\n\n\tclient, err := tsaclient.GetTimestampClient(server.URL)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tchain, err := client.Timestamp.GetTimestampCertChain(nil)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error getting timestamp chain: %v\", err)\n\t}\n\n\tfile, err := os.CreateTemp(os.TempDir(), \"tempfile\")\n\tif err != nil {\n\t\tt.Fatalf(\"error creating temp file: %v\", err)\n\t}\n\tdefer os.Remove(file.Name())\n\t_, err = file.WriteString(chain.Payload)\n\tif err != nil {\n\t\tt.Fatalf(\"error writing chain payload to temp file: %v\", err)\n\t}\n\n\tverifyAttestation := cliverify.VerifyAttestationCommand{\n\t\tKeyRef:           pubKeyPath,\n\t\tTSACertChainPath: file.Name(),\n\t\tIgnoreTlog:       true,\n\t\tPredicateType:    \"slsaprovenance\",\n\t\tMaxWorkers:       10,\n\t}\n\n\tmust(verifyAttestation.Exec(ctx, []string{imgName}), t)\n}\n\nfunc TestAttachWithRFC3161Timestamp(t *testing.T) {\n\tctx := context.Background()\n\t// TSA server needed to create timestamp\n\tviper.Set(\"timestamp-signer\", \"memory\")\n\tviper.Set(\"timestamp-signer-hash\", \"sha256\")\n\tapiServer := server.NewRestAPIServer(\"localhost\", 0, []string{\"http\"}, false, 10*time.Second, 10*time.Second)\n\tserver := httptest.NewServer(apiServer.GetHandler())\n\tt.Cleanup(server.Close)\n\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-attach-timestamp-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\tb := bytes.Buffer{}\n\tmust(generate.GenerateCmd(context.Background(), options.RegistryOptions{}, imgName, nil, &b), t)\n\n\trootCert, rootKey, _ := GenerateRootCa()\n\tsubCert, subKey, _ := GenerateSubordinateCa(rootCert, rootKey)\n\tleafCert, privKey, _ := GenerateLeafCert(\"subject@mail.com\", \"oidc-issuer\", subCert, subKey)\n\tpemRoot := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: rootCert.Raw})\n\tpemSub := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: subCert.Raw})\n\tpemLeaf := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: leafCert.Raw})\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tpayloadref := mkfile(b.String(), td, t)\n\n\th := sha256.Sum256(b.Bytes())\n\tsignature, _ := privKey.Sign(rand.Reader, h[:], crypto.SHA256)\n\tb64signature := base64.StdEncoding.EncodeToString([]byte(signature))\n\tsigRef := mkfile(b64signature, td, t)\n\tpemleafRef := mkfile(string(pemLeaf), td, t)\n\tpemrootRef := mkfile(string(pemRoot), td, t)\n\n\tcertchainRef := mkfile(string(append(pemSub[:], pemRoot[:]...)), td, t)\n\n\tt.Setenv(\"SIGSTORE_ROOT_FILE\", pemrootRef)\n\n\ttsclient, err := tsaclient.GetTimestampClient(server.URL)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tchain, err := tsclient.Timestamp.GetTimestampCertChain(nil)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error getting timestamp chain: %v\", err)\n\t}\n\n\tfile, err := os.CreateTemp(os.TempDir(), \"tempfile\")\n\tif err != nil {\n\t\tt.Fatalf(\"error creating temp file: %v\", err)\n\t}\n\tdefer os.Remove(file.Name())\n\t_, err = file.WriteString(chain.Payload)\n\tif err != nil {\n\t\tt.Fatalf(\"error writing chain payload to temp file: %v\", err)\n\t}\n\n\ttsBytes, err := tsa.GetTimestampedSignature(signature, client.NewTSAClient(server.URL+\"/api/v1/timestamp\"))\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error creating timestamp: %v\", err)\n\t}\n\trfc3161TSRef := mkfile(string(tsBytes), td, t)\n\n\t// Upload it!\n\terr = attach.SignatureCmd(ctx, options.RegistryOptions{}, sigRef, payloadref, pemleafRef, certchainRef, rfc3161TSRef, \"\", imgName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tmust(verifyKeylessTSA(imgName, file.Name(), true, true), t)\n}\n\nfunc TestAttachWithRekorBundle(t *testing.T) {\n\tctx := context.Background()\n\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-attach-timestamp-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\tb := bytes.Buffer{}\n\tmust(generate.GenerateCmd(context.Background(), options.RegistryOptions{}, imgName, nil, &b), t)\n\n\trootCert, rootKey, _ := GenerateRootCa()\n\tsubCert, subKey, _ := GenerateSubordinateCa(rootCert, rootKey)\n\tleafCert, privKey, _ := GenerateLeafCert(\"subject@mail.com\", \"oidc-issuer\", subCert, subKey)\n\tpemRoot := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: rootCert.Raw})\n\tpemSub := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: subCert.Raw})\n\tpemLeaf := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: leafCert.Raw})\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tpayloadref := mkfile(b.String(), td, t)\n\n\th := sha256.Sum256(b.Bytes())\n\tsignature, _ := privKey.Sign(rand.Reader, h[:], crypto.SHA256)\n\tb64signature := base64.StdEncoding.EncodeToString([]byte(signature))\n\tsigRef := mkfile(b64signature, td, t)\n\tpemleafRef := mkfile(string(pemLeaf), td, t)\n\tpemrootRef := mkfile(string(pemRoot), td, t)\n\n\tt.Setenv(\"SIGSTORE_ROOT_FILE\", pemrootRef)\n\n\tcertchainRef := mkfile(string(append(pemSub[:], pemRoot[:]...)), td, t)\n\n\tlocalPayload := cosign.LocalSignedPayload{\n\t\tBase64Signature: b64signature,\n\t\tCert:            string(pemLeaf),\n\t\tBundle: &bundle.RekorBundle{\n\t\t\tSignedEntryTimestamp: strfmt.Base64(\"MEUCIEDcarEwRYkrxE9ne+kzEVvUhnWaauYzxhUyXOLy1hwAAiEA4VdVCvNRs+D/5o33C2KBy+q2YX3lP4Y7nqRFU+K3hi0=\"),\n\t\t\tPayload: bundle.RekorPayload{\n\t\t\t\tBody:           \"REMOVED\",\n\t\t\t\tIntegratedTime: 1631646761,\n\t\t\t\tLogIndex:       693591,\n\t\t\t\tLogID:          \"c0d23d6ad406973f9559f3ba2d1ca01f84147d8ffc5b8445c224f98b9591801d\",\n\t\t\t},\n\t\t},\n\t}\n\n\tjsonBundle, err := json.Marshal(localPayload)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tbundlePath := filepath.Join(td, \"bundle.json\")\n\tif err := os.WriteFile(bundlePath, jsonBundle, 0644); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Upload it!\n\terr = attach.SignatureCmd(ctx, options.RegistryOptions{}, sigRef, payloadref, pemleafRef, certchainRef, \"\", bundlePath, imgName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestRekorBundle(t *testing.T) {\n\t// turn on the tlog\n\tdefer setenv(t, env.VariableExperimental.String(), \"1\")()\n\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tko := options.KeyOpts{\n\t\tKeyRef:   privKeyPath,\n\t\tPassFunc: passFunc,\n\t\tRekorURL: rekorURL,\n\t}\n\tso := options.SignOptions{\n\t\tUpload: true,\n\t}\n\n\t// Sign the image\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\t// Make sure verify works\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// Make sure offline verification works with bundling\n\t// use rekor prod since we have hardcoded the public key\n\tos.Setenv(serverEnv, \"notreal\")\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n}\n\nfunc TestRekorOutput(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\tbundlePath := filepath.Join(td, \"bundle.sig\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tko := options.KeyOpts{\n\t\tKeyRef:     privKeyPath,\n\t\tPassFunc:   passFunc,\n\t\tRekorURL:   rekorURL,\n\t\tBundlePath: bundlePath,\n\t}\n\tso := options.SignOptions{\n\t\tUpload: true,\n\t}\n\n\t// Sign the image\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\t// Make sure verify works\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\tif file, err := os.ReadFile(bundlePath); err != nil {\n\t\tt.Fatal(err)\n\t} else {\n\t\tvar localCosignPayload cosign.LocalSignedPayload\n\t\tif err := json.Unmarshal(file, &localCosignPayload); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\t// Make sure offline verification works with bundling\n\t// use rekor prod since we have hardcoded the public key\n\tos.Setenv(serverEnv, \"notreal\")\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n}\n\nfunc TestFulcioBundle(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tko := options.KeyOpts{\n\t\tKeyRef:    privKeyPath,\n\t\tPassFunc:  passFunc,\n\t\tRekorURL:  rekorURL,\n\t\tFulcioURL: fulcioURL,\n\t}\n\tso := options.SignOptions{\n\t\tUpload:           true,\n\t\tIssueCertificate: true,\n\t}\n\n\t// Sign the image\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\t// Make sure verify works\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// Make sure offline verification works with bundling\n\t// use rekor prod since we have hardcoded the public key\n\tos.Setenv(serverEnv, \"notreal\")\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n}\n\nfunc TestRFC3161Timestamp(t *testing.T) {\n\t// TSA server needed to create timestamp\n\tviper.Set(\"timestamp-signer\", \"memory\")\n\tviper.Set(\"timestamp-signer-hash\", \"sha256\")\n\tapiServer := server.NewRestAPIServer(\"localhost\", 0, []string{\"http\"}, false, 10*time.Second, 10*time.Second)\n\tserver := httptest.NewServer(apiServer.GetHandler())\n\tt.Cleanup(server.Close)\n\n\tclient, err := tsaclient.GetTimestampClient(server.URL)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tchain, err := client.Timestamp.GetTimestampCertChain(nil)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error getting timestamp chain: %v\", err)\n\t}\n\n\tfile, err := os.CreateTemp(os.TempDir(), \"tempfile\")\n\tif err != nil {\n\t\tt.Fatalf(\"error creating temp file: %v\", err)\n\t}\n\tdefer os.Remove(file.Name())\n\t_, err = file.WriteString(chain.Payload)\n\tif err != nil {\n\t\tt.Fatalf(\"error writing chain payload to temp file: %v\", err)\n\t}\n\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tko := options.KeyOpts{\n\t\tKeyRef:       privKeyPath,\n\t\tPassFunc:     passFunc,\n\t\tTSAServerURL: server.URL + \"/api/v1/timestamp\",\n\t}\n\tso := options.SignOptions{\n\t\tUpload:     true,\n\t\tTlogUpload: false,\n\t}\n\n\t// Sign the image\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\t// Make sure verify works against the TSA server\n\tmust(verifyTSA(pubKeyPath, imgName, true, nil, \"\", file.Name(), true), t)\n}\n\nfunc TestRekorBundleAndRFC3161Timestamp(t *testing.T) {\n\t// TSA server needed to create timestamp\n\tviper.Set(\"timestamp-signer\", \"memory\")\n\tviper.Set(\"timestamp-signer-hash\", \"sha256\")\n\tapiServer := server.NewRestAPIServer(\"localhost\", 0, []string{\"http\"}, false, 10*time.Second, 10*time.Second)\n\tserver := httptest.NewServer(apiServer.GetHandler())\n\tt.Cleanup(server.Close)\n\n\tclient, err := tsaclient.GetTimestampClient(server.URL)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tchain, err := client.Timestamp.GetTimestampCertChain(nil)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error getting timestamp chain: %v\", err)\n\t}\n\n\tfile, err := os.CreateTemp(os.TempDir(), \"tempfile\")\n\tif err != nil {\n\t\tt.Fatalf(\"error creating temp file: %v\", err)\n\t}\n\tdefer os.Remove(file.Name())\n\t_, err = file.WriteString(chain.Payload)\n\tif err != nil {\n\t\tt.Fatalf(\"error writing chain payload to temp file: %v\", err)\n\t}\n\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tko := options.KeyOpts{\n\t\tKeyRef:           privKeyPath,\n\t\tPassFunc:         passFunc,\n\t\tTSAServerURL:     server.URL + \"/api/v1/timestamp\",\n\t\tRekorURL:         rekorURL,\n\t\tSkipConfirmation: true,\n\t}\n\tso := options.SignOptions{\n\t\tUpload:     true,\n\t\tTlogUpload: true,\n\t}\n\n\t// Sign the image\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\t// Make sure verify works against the Rekor and TSA clients\n\tmust(verifyTSA(pubKeyPath, imgName, true, nil, \"\", file.Name(), false), t)\n}\n\nfunc TestDuplicateSign(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\tref, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tctx := context.Background()\n\t// Verify should fail at first\n\tmustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\t// So should download\n\tmustErr(download.SignatureCmd(ctx, options.RegistryOptions{}, imgName), t)\n\n\t// Now sign the image\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tso := options.SignOptions{\n\t\tUpload: true,\n\t}\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\n\t// Now verify and download should work!\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\tmust(download.SignatureCmd(ctx, options.RegistryOptions{}, imgName), t)\n\n\t// Signing again should work just fine...\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\n\tse, err := ociremote.SignedEntity(ref, ociremote.WithRemoteOptions(registryClientOpts(ctx)...))\n\tmust(err, t)\n\tsigs, err := se.Signatures()\n\tmust(err, t)\n\tsignatures, err := sigs.Get()\n\tmust(err, t)\n\n\tif len(signatures) > 1 {\n\t\tt.Errorf(\"expected there to only be one signature, got %v\", signatures)\n\t}\n}\n\nfunc TestKeyURLVerify(t *testing.T) {\n\t// TODO: re-enable once distroless images are being signed by the new client\n\tt.Skip()\n\t// Verify that an image can be verified via key url\n\tkeyRef := \"https://raw.githubusercontent.com/GoogleContainerTools/distroless/main/cosign.pub\"\n\timg := \"gcr.io/distroless/base:latest\"\n\n\tmust(verify(keyRef, img, true, nil, \"\"), t)\n}\n\nfunc TestGenerateKeyPairEnvVar(t *testing.T) {\n\tdefer setenv(t, \"COSIGN_PASSWORD\", \"foo\")()\n\tkeys, err := cosign.GenerateKeyPair(generate.GetPass)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, err := cosign.LoadPrivateKey(keys.PrivateBytes, []byte(\"foo\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestGenerateKeyPairK8s(t *testing.T) {\n\ttd := t.TempDir()\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := os.Chdir(td); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() {\n\t\tos.Chdir(wd)\n\t}()\n\tpassword := \"foo\"\n\tdefer setenv(t, \"COSIGN_PASSWORD\", password)()\n\tctx := context.Background()\n\tname := \"cosign-secret\"\n\tnamespace := \"default\"\n\tif err := kubernetes.KeyPairSecret(ctx, fmt.Sprintf(\"k8s://%s/%s\", namespace, name), generate.GetPass); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// make sure the secret actually exists\n\n\tcfg, err := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(\n\t\tclientcmd.NewDefaultClientConfigLoadingRules(), nil).ClientConfig()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclient, err := k8s.NewForConfig(cfg)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ts, err := client.CoreV1().Secrets(namespace).Get(ctx, name, metav1.GetOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif v, ok := s.Data[\"cosign.password\"]; !ok || string(v) != password {\n\t\tt.Fatalf(\"password is incorrect, got %v expected %v\", v, \"foo\")\n\t}\n}\n\nfunc TestMultipleSignatures(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\n\ttd1 := t.TempDir()\n\ttd2 := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, priv1, pub1 := keypair(t, td1)\n\t_, priv2, pub2 := keypair(t, td2)\n\n\t// Verify should fail at first for both keys\n\tmustErr(verify(pub1, imgName, true, nil, \"\"), t)\n\tmustErr(verify(pub2, imgName, true, nil, \"\"), t)\n\n\t// Now sign the image with one key\n\tko := options.KeyOpts{KeyRef: priv1, PassFunc: passFunc}\n\tso := options.SignOptions{\n\t\tUpload: true,\n\t}\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\t// Now verify should work with that one, but not the other\n\tmust(verify(pub1, imgName, true, nil, \"\"), t)\n\tmustErr(verify(pub2, imgName, true, nil, \"\"), t)\n\n\t// Now sign with the other key too\n\tko.KeyRef = priv2\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\n\t// Now verify should work with both\n\tmust(verify(pub1, imgName, true, nil, \"\"), t)\n\tmust(verify(pub2, imgName, true, nil, \"\"), t)\n}\n\nfunc TestSignBlob(t *testing.T) {\n\tblob := \"someblob\"\n\ttd1 := t.TempDir()\n\ttd2 := t.TempDir()\n\tt.Cleanup(func() {\n\t\tos.RemoveAll(td1)\n\t\tos.RemoveAll(td2)\n\t})\n\tbp := filepath.Join(td1, blob)\n\n\tif err := os.WriteFile(bp, []byte(blob), 0644); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, privKeyPath1, pubKeyPath1 := keypair(t, td1)\n\t_, _, pubKeyPath2 := keypair(t, td2)\n\n\tctx := context.Background()\n\n\tko1 := options.KeyOpts{\n\t\tKeyRef: pubKeyPath1,\n\t}\n\tko2 := options.KeyOpts{\n\t\tKeyRef: pubKeyPath2,\n\t}\n\t// Verify should fail on a bad input\n\tcmd1 := cliverify.VerifyBlobCmd{\n\t\tKeyOpts:    ko1,\n\t\tSigRef:     \"badsig\",\n\t\tIgnoreTlog: true,\n\t}\n\tcmd2 := cliverify.VerifyBlobCmd{\n\t\tKeyOpts:    ko2,\n\t\tSigRef:     \"badsig\",\n\t\tIgnoreTlog: true,\n\t}\n\tmustErr(cmd1.Exec(ctx, blob), t)\n\tmustErr(cmd2.Exec(ctx, blob), t)\n\n\t// Now sign the blob with one key\n\tko := options.KeyOpts{\n\t\tKeyRef:   privKeyPath1,\n\t\tPassFunc: passFunc,\n\t}\n\tsig, err := sign.SignBlobCmd(ro, ko, bp, true, \"\", \"\", false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Now verify should work with that one, but not the other\n\tcmd1.SigRef = string(sig)\n\tcmd2.SigRef = string(sig)\n\tmust(cmd1.Exec(ctx, bp), t)\n\tmustErr(cmd2.Exec(ctx, bp), t)\n}\n\nfunc TestSignBlobBundle(t *testing.T) {\n\tblob := \"someblob\"\n\ttd1 := t.TempDir()\n\tt.Cleanup(func() {\n\t\tos.RemoveAll(td1)\n\t})\n\tbp := filepath.Join(td1, blob)\n\tbundlePath := filepath.Join(td1, \"bundle.sig\")\n\n\tif err := os.WriteFile(bp, []byte(blob), 0644); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, privKeyPath1, pubKeyPath1 := keypair(t, td1)\n\n\tctx := context.Background()\n\n\tko1 := options.KeyOpts{\n\t\tKeyRef:     pubKeyPath1,\n\t\tBundlePath: bundlePath,\n\t}\n\t// Verify should fail on a bad input\n\tverifyBlobCmd := cliverify.VerifyBlobCmd{\n\t\tKeyOpts:    ko1,\n\t\tIgnoreTlog: true,\n\t}\n\tmustErr(verifyBlobCmd.Exec(ctx, bp), t)\n\n\t// Now sign the blob with one key\n\tko := options.KeyOpts{\n\t\tKeyRef:           privKeyPath1,\n\t\tPassFunc:         passFunc,\n\t\tBundlePath:       bundlePath,\n\t\tRekorURL:         rekorURL,\n\t\tSkipConfirmation: true,\n\t}\n\tif _, err := sign.SignBlobCmd(ro, ko, bp, true, \"\", \"\", false); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Now verify should work\n\tmust(verifyBlobCmd.Exec(ctx, bp), t)\n\n\t// Now we turn on the tlog and sign again\n\tif _, err := sign.SignBlobCmd(ro, ko, bp, true, \"\", \"\", true); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Point to a fake rekor server to make sure offline verification of the tlog entry works\n\tos.Setenv(serverEnv, \"notreal\")\n\tverifyBlobCmd.IgnoreTlog = false\n\tmust(verifyBlobCmd.Exec(ctx, bp), t)\n}\n\nfunc TestSignBlobRFC3161TimestampBundle(t *testing.T) {\n\t// TSA server needed to create timestamp\n\tviper.Set(\"timestamp-signer\", \"memory\")\n\tviper.Set(\"timestamp-signer-hash\", \"sha256\")\n\tapiServer := server.NewRestAPIServer(\"localhost\", 0, []string{\"http\"}, false, 10*time.Second, 10*time.Second)\n\tserver := httptest.NewServer(apiServer.GetHandler())\n\tt.Cleanup(server.Close)\n\n\tblob := \"someblob\"\n\ttd1 := t.TempDir()\n\tt.Cleanup(func() {\n\t\tos.RemoveAll(td1)\n\t})\n\tbp := filepath.Join(td1, blob)\n\tbundlePath := filepath.Join(td1, \"bundle.sig\")\n\ttsPath := filepath.Join(td1, \"rfc3161Timestamp.json\")\n\n\tif err := os.WriteFile(bp, []byte(blob), 0644); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tclient, err := tsaclient.GetTimestampClient(server.URL)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tchain, err := client.Timestamp.GetTimestampCertChain(nil)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error getting timestamp chain: %v\", err)\n\t}\n\n\tfile, err := os.CreateTemp(os.TempDir(), \"tempfile\")\n\tif err != nil {\n\t\tt.Fatalf(\"error creating temp file: %v\", err)\n\t}\n\tdefer os.Remove(file.Name())\n\t_, err = file.WriteString(chain.Payload)\n\tif err != nil {\n\t\tt.Fatalf(\"error writing chain payload to temp file: %v\", err)\n\t}\n\n\t_, privKeyPath1, pubKeyPath1 := keypair(t, td1)\n\n\tctx := context.Background()\n\n\tko1 := options.KeyOpts{\n\t\tKeyRef:               pubKeyPath1,\n\t\tBundlePath:           bundlePath,\n\t\tRFC3161TimestampPath: tsPath,\n\t\tTSACertChainPath:     file.Name(),\n\t}\n\t// Verify should fail on a bad input\n\tverifyBlobCmd := cliverify.VerifyBlobCmd{\n\t\tKeyOpts:    ko1,\n\t\tIgnoreTlog: true,\n\t}\n\tmustErr(verifyBlobCmd.Exec(ctx, bp), t)\n\n\t// Now sign the blob with one key\n\tko := options.KeyOpts{\n\t\tKeyRef:               privKeyPath1,\n\t\tPassFunc:             passFunc,\n\t\tBundlePath:           bundlePath,\n\t\tRFC3161TimestampPath: tsPath,\n\t\tTSAServerURL:         server.URL + \"/api/v1/timestamp\",\n\t\tRekorURL:             rekorURL,\n\t\tSkipConfirmation:     true,\n\t}\n\tif _, err := sign.SignBlobCmd(ro, ko, bp, true, \"\", \"\", false); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Now verify should work\n\tmust(verifyBlobCmd.Exec(ctx, bp), t)\n\n\t// Now we turn on the tlog and sign again\n\tif _, err := sign.SignBlobCmd(ro, ko, bp, true, \"\", \"\", true); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Point to a fake rekor server to make sure offline verification of the tlog entry works\n\tverifyBlobCmd.IgnoreTlog = false\n\tmust(verifyBlobCmd.Exec(ctx, bp), t)\n}\n\nfunc TestGenerate(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\t_, desc, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t// Generate the payload for the image, and check the digest.\n\tb := bytes.Buffer{}\n\tmust(generate.GenerateCmd(context.Background(), options.RegistryOptions{}, imgName, nil, &b), t)\n\tss := payload.SimpleContainerImage{}\n\tmust(json.Unmarshal(b.Bytes(), &ss), t)\n\n\tequals(desc.Digest.String(), ss.Critical.Image.DockerManifestDigest, t)\n\n\t// Now try with some annotations.\n\tb.Reset()\n\ta := map[string]interface{}{\"foo\": \"bar\"}\n\tmust(generate.GenerateCmd(context.Background(), options.RegistryOptions{}, imgName, a, &b), t)\n\tmust(json.Unmarshal(b.Bytes(), &ss), t)\n\n\tequals(desc.Digest.String(), ss.Critical.Image.DockerManifestDigest, t)\n\tequals(ss.Optional[\"foo\"], \"bar\", t)\n}\n\nfunc keypair(t *testing.T, td string) (*cosign.KeysBytes, string, string) {\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := os.Chdir(td); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() {\n\t\tos.Chdir(wd)\n\t}()\n\tkeys, err := cosign.GenerateKeyPair(passFunc)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tprivKeyPath := filepath.Join(td, \"cosign.key\")\n\tif err := os.WriteFile(privKeyPath, keys.PrivateBytes, 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpubKeyPath := filepath.Join(td, \"cosign.pub\")\n\tif err := os.WriteFile(pubKeyPath, keys.PublicBytes, 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn keys, privKeyPath, pubKeyPath\n}\n\nfunc importKeyPair(t *testing.T, td string) (*cosign.KeysBytes, string, string) {\n\n\tconst validrsa1 = `-----BEGIN RSA PRIVATE KEY-----\nMIIEogIBAAKCAQEAx5piWVlE62NnZ0UzJ8Z6oKiKOC4dbOZ1HsNhIRtqkM+Oq4G+\n25yq6P+0JU/Qvr9veOGEb3R/J9u8JBo+hv2i5X8OtgvP2V2pi6f1s6vK7L0+6uRb\n4YTT/UdMshaVf97MgEqbq41Jf/cuvh+3AV0tZ1BpixZg4aXMKpY6HUP69lbsu27o\nSUN1myMv7TSgZiV4CYs3l/gkEfpysBptWlcHRuw5RsB+C0RbjRtbJ/5VxmE/vd3M\nlafd5t1WSpMb8yf0a84u5NFaXwZ7CweMfXeOddS0yb19ShSuW3PPRadruBM1mq15\njs9GfagPxDS75Imcs+fA62lWvHxEujTGjYHxawIDAQABAoIBAH+sgLwmHa9zJfEo\nklAe5NFe/QpydN/ziXbkAnzqzH9URC3wD+TpkWj4JoK3Sw635NWtasjf+3XDV9S/\n9L7j/g5N91r6sziWcJykEsWaXXKQmm4lI6BdFjwsHyLKz1W7bZOiJXDWLu1rbrqu\nDqEQuLoc9WXCKrYrFy0maoXNtfla/1p05kKN0bMigcnnyAQ+xBTwoyco4tkIz5se\nIYxorz7qzXrkHQI+knz5BawmNe3ekoSaXUPoLoOR7TRTGsLteL5yukvWAi8S/0rE\ngftC+PZCQpoQhSUYq7wXe7RowJ1f+kXb7HsSedOTfTSW1D/pUb/uW+CcRKig42ZI\nI9H9TAECgYEA5XGBML6fJyWVqx64sHbUAjQsmQ0RwU6Zo7sqHIEPf6tYVYp7KtzK\nKOfi8seOOL5FSy4pjCo11Dzyrh9bn45RNmtjSYTgOnVPSoCfuRNfOcpG+/wCHjYf\nEjDvdrCpbg59kVUeaMeBDiyWAlM48HJAn8O7ez2U/iKQCyJmOIwFhSkCgYEA3rSz\nFi1NzqYWxWos4NBmg8iKcQ9SMkmPdgRLAs/WNnZJ8fdgJZwihevkXGytRGJEmav2\nGMKRx1g6ey8fjXTQH9WM8X/kJC5fv8wLHnUCH/K3Mcp9CYwn7PFvSnBr4kQoc/el\nbURhcF1+/opEC8vNX/Wk3zAG7Xs1PREXlH2SIHMCgYBV/3kgwBH/JkM25EjtO1yz\nhsLAivmAruk/SUO7c1RP0fVF+qW3pxHOyztxLALOmeJ3D1JbSubqKf377Zz17O3b\nq9yHDdrNjnKtxhAX2n7ytjJs+EQC9t4mf1kB761RpvTBqFnBhCWHHocLUA4jcW9v\ncnmu86IIrwO2aKpPv4vCIQKBgHU9gY3qOazRSOmSlJ+hdmZn+2G7pBTvHsQNTIPl\ncCrpqNHl3crO4GnKHkT9vVVjuiOAIKU2QNJFwzu4Og8Y8LvhizpTjoHxm9x3iV72\nUDELcJ+YrqyJCTe2flUcy96o7Pbn50GXnwgtYD6WAW6IUszyn2ITgYIhu4wzZEt6\ns6O7AoGAPTKbRA87L34LMlXyUBJma+etMARIP1zu8bXJ7hSJeMcog8zaLczN7ruT\npGAaLxggvtvuncMuTrG+cdmsR9SafSFKRS92NCxhOUonQ+NP6mLskIGzJZoQ5JvQ\nqGzRVIDGbNkrVHM0IsAtHRpC0rYrtZY+9OwiraGcsqUMLwwQdCA=\n-----END RSA PRIVATE KEY-----`\n\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := os.Chdir(td); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() {\n\t\tos.Chdir(wd)\n\t}()\n\n\terr = os.WriteFile(\"validrsa1.key\", []byte(validrsa1), 0600)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tkeys, err := cosign.ImportKeyPair(\"validrsa1.key\", passFunc)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tprivKeyPath := filepath.Join(td, \"import-cosign.key\")\n\tif err := os.WriteFile(privKeyPath, keys.PrivateBytes, 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpubKeyPath := filepath.Join(td, \"import-cosign.pub\")\n\tif err := os.WriteFile(pubKeyPath, keys.PublicBytes, 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn keys, privKeyPath, pubKeyPath\n\n}\n\nfunc TestUploadDownload(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\tctx := context.Background()\n\n\ttestCases := map[string]struct {\n\t\tsignature     string\n\t\tsignatureType attach.SignatureArgType\n\t\texpectedErr   bool\n\t}{\n\t\t\"stdin containing signature\": {\n\t\t\tsignature:     \"testsignatureraw\",\n\t\t\tsignatureType: attach.StdinSignature,\n\t\t\texpectedErr:   false,\n\t\t},\n\t\t\"file containing signature\": {\n\t\t\tsignature:     \"testsignaturefile\",\n\t\t\tsignatureType: attach.FileSignature,\n\t\t\texpectedErr:   false,\n\t\t},\n\t\t\"raw signature as argument\": {\n\t\t\tsignature:     \"testsignatureraw\",\n\t\t\tsignatureType: attach.RawSignature,\n\t\t\texpectedErr:   true,\n\t\t},\n\t\t\"empty signature as argument\": {\n\t\t\tsignature:     \"\",\n\t\t\tsignatureType: attach.RawSignature,\n\t\t\texpectedErr:   true,\n\t\t},\n\t}\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\tfor testName, testCase := range testCases {\n\t\tt.Run(testName, func(t *testing.T) {\n\t\t\tref, _, cleanup := mkimage(t, imgName)\n\t\t\tpayload := \"testpayload\"\n\t\t\tpayloadPath := mkfile(payload, td, t)\n\t\t\tsignature := base64.StdEncoding.EncodeToString([]byte(testCase.signature))\n\t\t\trestoreStdin := func() {}\n\n\t\t\tvar sigRef string\n\t\t\tif testCase.signatureType == attach.FileSignature {\n\t\t\t\tsigRef = mkfile(signature, td, t)\n\t\t\t} else if testCase.signatureType == attach.StdinSignature {\n\t\t\t\tsigRef = \"-\"\n\t\t\t\trestoreStdin = mockStdin(signature, td, t)\n\t\t\t} else {\n\t\t\t\tsigRef = signature\n\t\t\t}\n\t\t\t// Upload it!\n\t\t\terr := attach.SignatureCmd(ctx, options.RegistryOptions{}, sigRef, payloadPath, \"\", \"\", \"\", \"\", imgName)\n\t\t\tif testCase.expectedErr {\n\t\t\t\tmustErr(err, t)\n\t\t\t} else {\n\t\t\t\tmust(err, t)\n\t\t\t}\n\t\t\trestoreStdin()\n\n\t\t\t// Now download it!\n\t\t\tse, err := ociremote.SignedEntity(ref, ociremote.WithRemoteOptions(registryClientOpts(ctx)...))\n\t\t\tmust(err, t)\n\t\t\tsigs, err := se.Signatures()\n\t\t\tmust(err, t)\n\t\t\tsignatures, err := sigs.Get()\n\t\t\tmust(err, t)\n\n\t\t\tif testCase.expectedErr {\n\t\t\t\tif len(signatures) != 0 {\n\t\t\t\t\tt.Fatalf(\"unexpected signatures %d, wanted 0\", len(signatures))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif len(signatures) != 1 {\n\t\t\t\t\tt.Fatalf(\"unexpected signatures %d, wanted 1\", len(signatures))\n\t\t\t\t}\n\n\t\t\t\tif b64sig, err := signatures[0].Base64Signature(); err != nil {\n\t\t\t\t\tt.Fatalf(\"Base64Signature() = %v\", err)\n\t\t\t\t} else if diff := cmp.Diff(b64sig, signature); diff != \"\" {\n\t\t\t\t\tt.Error(diff)\n\t\t\t\t}\n\n\t\t\t\tif p, err := signatures[0].Payload(); err != nil {\n\t\t\t\t\tt.Fatalf(\"Payload() = %v\", err)\n\t\t\t\t} else if diff := cmp.Diff(p, []byte(payload)); diff != \"\" {\n\t\t\t\t\tt.Error(diff)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Now delete it!\n\t\t\tcleanup()\n\t\t})\n\t}\n}\n\nfunc TestSaveLoad(t *testing.T) {\n\ttests := []struct {\n\t\tdescription     string\n\t\tgetSignedEntity func(t *testing.T, n string) (name.Reference, *remote.Descriptor, func())\n\t}{\n\t\t{\n\t\t\tdescription:     \"save and load an image\",\n\t\t\tgetSignedEntity: mkimage,\n\t\t},\n\t\t{\n\t\t\tdescription:     \"save and load an image index\",\n\t\t\tgetSignedEntity: mkimageindex,\n\t\t},\n\t}\n\tfor i, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\trepo, stop := reg(t)\n\t\t\tdefer stop()\n\t\t\tkeysDir := t.TempDir()\n\n\t\t\timgName := path.Join(repo, fmt.Sprintf(\"save-load-%d\", i))\n\n\t\t\t_, _, cleanup := test.getSignedEntity(t, imgName)\n\t\t\tdefer cleanup()\n\n\t\t\t_, privKeyPath, pubKeyPath := keypair(t, keysDir)\n\n\t\t\tctx := context.Background()\n\t\t\t// Now sign the image and verify it\n\t\t\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\t\t\tso := options.SignOptions{\n\t\t\t\tUpload: true,\n\t\t\t}\n\t\t\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\t\t\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t\t\t// save the image to a temp dir\n\t\t\timageDir := t.TempDir()\n\t\t\tmust(cli.SaveCmd(ctx, options.SaveOptions{Directory: imageDir}, imgName), t)\n\n\t\t\t// verify the local image using a local key\n\t\t\tmust(verifyLocal(pubKeyPath, imageDir, true, nil, \"\"), t)\n\n\t\t\t// load the image from the temp dir into a new image and verify the new image\n\t\t\timgName2 := path.Join(repo, fmt.Sprintf(\"save-load-%d-2\", i))\n\t\t\tmust(cli.LoadCmd(ctx, options.LoadOptions{Directory: imageDir}, imgName2), t)\n\t\t\tmust(verify(pubKeyPath, imgName2, true, nil, \"\"), t)\n\t\t})\n\t}\n}\n\nfunc TestSaveLoadAttestation(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"save-load\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tctx := context.Background()\n\t// Now sign the image and verify it\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tso := options.SignOptions{\n\t\tUpload: true,\n\t}\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// now, append an attestation to the image\n\tslsaAttestation := `{ \"buildType\": \"x\", \"builder\": { \"id\": \"2\" }, \"recipe\": {} }`\n\tslsaAttestationPath := filepath.Join(td, \"attestation.slsa.json\")\n\tif err := os.WriteFile(slsaAttestationPath, []byte(slsaAttestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Now attest the image\n\tko = options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tattestCommand := attest.AttestCommand{\n\t\tKeyOpts:       ko,\n\t\tPredicatePath: slsaAttestationPath,\n\t\tPredicateType: \"slsaprovenance\",\n\t\tTimeout:       30 * time.Second,\n\t}\n\tmust(attestCommand.Exec(ctx, imgName), t)\n\n\t// save the image to a temp dir\n\timageDir := t.TempDir()\n\tmust(cli.SaveCmd(ctx, options.SaveOptions{Directory: imageDir}, imgName), t)\n\n\t// load the image from the temp dir into a new image and verify the new image\n\timgName2 := path.Join(repo, \"save-load-2\")\n\tmust(cli.LoadCmd(ctx, options.LoadOptions{Directory: imageDir}, imgName2), t)\n\tmust(verify(pubKeyPath, imgName2, true, nil, \"\"), t)\n\t// Use cue to verify attestation on the new image\n\tpolicyPath := filepath.Join(td, \"policy.cue\")\n\tverifyAttestation := cliverify.VerifyAttestationCommand{\n\t\tKeyRef:     pubKeyPath,\n\t\tIgnoreTlog: true,\n\t\tMaxWorkers: 10,\n\t}\n\tverifyAttestation.PredicateType = \"slsaprovenance\"\n\tverifyAttestation.Policies = []string{policyPath}\n\t// Success case (remote)\n\tcuePolicy := `predicate: builder: id: \"2\"`\n\tif err := os.WriteFile(policyPath, []byte(cuePolicy), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tmust(verifyAttestation.Exec(ctx, []string{imgName2}), t)\n\t// Success case (local)\n\tverifyAttestation.LocalImage = true\n\tmust(verifyAttestation.Exec(ctx, []string{imageDir}), t)\n}\n\nfunc TestAttachSBOM(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\tctx := context.Background()\n\n\timgName := path.Join(repo, \"sbom-image\")\n\timg, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\tout := bytes.Buffer{}\n\n\t_, errPl := download.SBOMCmd(ctx, options.RegistryOptions{}, options.SBOMDownloadOptions{Platform: \"darwin/amd64\"}, img.Name(), &out)\n\tif errPl == nil {\n\t\tt.Fatalf(\"Expected error when passing Platform to single arch image\")\n\t}\n\t_, err := download.SBOMCmd(ctx, options.RegistryOptions{}, options.SBOMDownloadOptions{}, img.Name(), &out)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error\")\n\t}\n\tt.Log(out.String())\n\tout.Reset()\n\n\t// Upload it!\n\tmust(attach.SBOMCmd(ctx, options.RegistryOptions{}, options.RegistryExperimentalOptions{}, \"./testdata/bom-go-mod.spdx\", \"spdx\", imgName), t)\n\n\tsboms, err := download.SBOMCmd(ctx, options.RegistryOptions{}, options.SBOMDownloadOptions{}, imgName, &out)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Log(out.String())\n\tif len(sboms) != 1 {\n\t\tt.Fatalf(\"Expected one sbom, got %d\", len(sboms))\n\t}\n\twant, err := os.ReadFile(\"./testdata/bom-go-mod.spdx\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif diff := cmp.Diff(string(want), sboms[0]); diff != \"\" {\n\t\tt.Errorf(\"diff: %s\", diff)\n\t}\n\n\t// Generate key pairs to sign the sbom\n\ttd1 := t.TempDir()\n\ttd2 := t.TempDir()\n\t_, privKeyPath1, pubKeyPath1 := keypair(t, td1)\n\t_, _, pubKeyPath2 := keypair(t, td2)\n\n\t// Verify should fail on a bad input\n\tmustErr(verify(pubKeyPath1, imgName, true, nil, \"sbom\"), t)\n\tmustErr(verify(pubKeyPath2, imgName, true, nil, \"sbom\"), t)\n\n\t// Now sign the sbom with one key\n\tko1 := options.KeyOpts{KeyRef: privKeyPath1, PassFunc: passFunc}\n\tso := options.SignOptions{\n\t\tUpload:     true,\n\t\tAttachment: \"sbom\",\n\t}\n\tmust(sign.SignCmd(ro, ko1, so, []string{imgName}), t)\n\n\t// Now verify should work with that one, but not the other\n\tmust(verify(pubKeyPath1, imgName, true, nil, \"sbom\"), t)\n\tmustErr(verify(pubKeyPath2, imgName, true, nil, \"sbom\"), t)\n}\n\nfunc TestAttachSBOM_bom_flag(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\tctx := context.Background()\n\tbomData, err := os.ReadFile(\"./testdata/bom-go-mod.spdx\")\n\tmust(err, t)\n\n\ttestCases := map[string]struct {\n\t\tbom         string\n\t\tbomType     attach.SignatureArgType\n\t\texpectedErr bool\n\t}{\n\t\t\"stdin containing bom\": {\n\t\t\tbom:         string(bomData),\n\t\t\tbomType:     attach.StdinSignature,\n\t\t\texpectedErr: false,\n\t\t},\n\t\t\"file containing bom\": {\n\t\t\tbom:         string(bomData),\n\t\t\tbomType:     attach.FileSignature,\n\t\t\texpectedErr: false,\n\t\t},\n\t\t\"raw bom as argument\": {\n\t\t\tbom:         string(bomData),\n\t\t\tbomType:     attach.RawSignature,\n\t\t\texpectedErr: true,\n\t\t},\n\t\t\"empty bom as argument\": {\n\t\t\tbom:         \"\",\n\t\t\tbomType:     attach.RawSignature,\n\t\t\texpectedErr: true,\n\t\t},\n\t}\n\n\tfor testName, testCase := range testCases {\n\t\tt.Run(testName, func(t *testing.T) {\n\t\t\timgName := path.Join(repo, \"sbom-image\")\n\t\t\timg, _, cleanup := mkimage(t, imgName)\n\t\t\tvar sbomRef string\n\t\t\trestoreStdin := func() {}\n\t\t\tif testCase.bomType == attach.FileSignature {\n\t\t\t\tsbomRef = mkfile(testCase.bom, td, t)\n\t\t\t} else if testCase.bomType == attach.StdinSignature {\n\t\t\t\tsbomRef = \"-\"\n\t\t\t\trestoreStdin = mockStdin(testCase.bom, td, t)\n\t\t\t} else {\n\t\t\t\tsbomRef = testCase.bom\n\t\t\t}\n\n\t\t\tout := bytes.Buffer{}\n\t\t\t_, errPl := download.SBOMCmd(ctx, options.RegistryOptions{}, options.SBOMDownloadOptions{Platform: \"darwin/amd64\"}, img.Name(), &out)\n\t\t\tif errPl == nil {\n\t\t\t\tt.Fatalf(\"Expected error when passing Platform to single arch image\")\n\t\t\t}\n\t\t\t_, err := download.SBOMCmd(ctx, options.RegistryOptions{}, options.SBOMDownloadOptions{}, img.Name(), &out)\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(\"Expected error\")\n\t\t\t}\n\t\t\tt.Log(out.String())\n\t\t\tout.Reset()\n\n\t\t\t// Upload it!\n\t\t\terr = attach.SBOMCmd(ctx, options.RegistryOptions{}, options.RegistryExperimentalOptions{}, sbomRef, \"spdx\", imgName)\n\t\t\trestoreStdin()\n\n\t\t\tif testCase.expectedErr {\n\t\t\t\tmustErr(err, t)\n\t\t\t} else {\n\t\t\t\tsboms, err := download.SBOMCmd(ctx, options.RegistryOptions{}, options.SBOMDownloadOptions{}, imgName, &out)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tt.Log(out.String())\n\t\t\t\tif len(sboms) != 1 {\n\t\t\t\t\tt.Fatalf(\"Expected one sbom, got %d\", len(sboms))\n\t\t\t\t}\n\t\t\t\twant, err := os.ReadFile(\"./testdata/bom-go-mod.spdx\")\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif diff := cmp.Diff(string(want), sboms[0]); diff != \"\" {\n\t\t\t\t\tt.Errorf(\"diff: %s\", diff)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcleanup()\n\t\t})\n\t}\n}\n\nfunc setenv(t *testing.T, k, v string) func() {\n\tif err := os.Setenv(k, v); err != nil {\n\t\tt.Fatalf(\"error setting env: %v\", err)\n\t}\n\treturn func() {\n\t\tos.Unsetenv(k)\n\t}\n}\n\nfunc TestTlog(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\t// Verify should fail at first\n\tmustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// Now sign the image without the tlog\n\tko := options.KeyOpts{\n\t\tKeyRef:   privKeyPath,\n\t\tPassFunc: passFunc,\n\t\tRekorURL: rekorURL,\n\t}\n\tso := options.SignOptions{\n\t\tUpload: true,\n\t}\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\n\t// Now verify should work!\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// TODO: priyawadhwa@ to figure out how to add an entry to the tlog without using keyless signing\n\t// We could add an --upload-tlog flag, but it's a bit weird since we have a --no-upload-tlog flag too right now.\n\n\t// Verify shouldn't work since we haven't put anything in it yet.\n\t// mustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// // Sign again with the tlog env var on\n\t// must(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\t// // And now verify works!\n\t// must(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n}\n\nfunc TestNoTlog(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\t// Verify should fail at first\n\tmustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// Now sign the image without the tlog\n\tko := options.KeyOpts{\n\t\tKeyRef:   privKeyPath,\n\t\tPassFunc: passFunc,\n\t\tRekorURL: rekorURL,\n\t}\n\tso := options.SignOptions{\n\t\tUpload: true,\n\t}\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\n\t// Now verify should work!\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// TODO: Uncomment once we have a way to tell `cosign verify` that we want to verify with a public key\n\t// and a tlog entry\n\n\t// // Sign again and make sure tlog upload is set to false\n\t// so = options.SignOptions{\n\t// \tTlogUpload: false,\n\t// }\n\t// must(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\t// // And verify it still fails.\n\t// mustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n}\n\nfunc TestGetPublicKeyCustomOut(t *testing.T) {\n\ttd := t.TempDir()\n\tkeys, privKeyPath, _ := keypair(t, td)\n\tctx := context.Background()\n\n\toutFile := \"output.pub\"\n\toutPath := filepath.Join(td, outFile)\n\toutWriter, err := os.OpenFile(outPath, os.O_WRONLY|os.O_CREATE, 0600)\n\tmust(err, t)\n\n\tpk := publickey.Pkopts{\n\t\tKeyRef: privKeyPath,\n\t}\n\tmust(publickey.GetPublicKey(ctx, pk, publickey.NamedWriter{Name: outPath, Writer: outWriter}, passFunc), t)\n\n\toutput, err := os.ReadFile(outPath)\n\tmust(err, t)\n\tequals(keys.PublicBytes, output, t)\n}\n\nfunc mockStdin(contents, td string, t *testing.T) func() {\n\torigin := os.Stdin\n\n\tp := mkfile(contents, td, t)\n\tf, err := os.Open(p)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tos.Stdin = f\n\n\treturn func() { os.Stdin = origin }\n}\n\nfunc mkfile(contents, td string, t *testing.T) string {\n\tf, err := os.CreateTemp(td, \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer f.Close()\n\tif _, err := f.Write([]byte(contents)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn f.Name()\n}\n\nfunc mkimage(t *testing.T, n string) (name.Reference, *remote.Descriptor, func()) {\n\tref, err := name.ParseReference(n, name.WeakValidation)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\timg, err := random.Image(512, 5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tregClientOpts := registryClientOpts(context.Background())\n\n\tif err := remote.Write(ref, img, regClientOpts...); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tremoteImage, err := remote.Get(ref, regClientOpts...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcleanup := func() {\n\t\t_ = remote.Delete(ref, regClientOpts...)\n\t\tref, _ := ociremote.SignatureTag(ref.Context().Digest(remoteImage.Descriptor.Digest.String()), ociremote.WithRemoteOptions(regClientOpts...))\n\t\t_ = remote.Delete(ref, regClientOpts...)\n\t}\n\treturn ref, remoteImage, cleanup\n}\n\nfunc mkimageindex(t *testing.T, n string) (name.Reference, *remote.Descriptor, func()) {\n\tref, err := name.ParseReference(n, name.WeakValidation)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tii, err := random.Index(512, 5, 4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tregClientOpts := registryClientOpts(context.Background())\n\n\tif err := remote.WriteIndex(ref, ii, regClientOpts...); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tremoteIndex, err := remote.Get(ref, regClientOpts...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcleanup := func() {\n\t\t_ = remote.Delete(ref, regClientOpts...)\n\t\tref, _ := ociremote.SignatureTag(ref.Context().Digest(remoteIndex.Descriptor.Digest.String()), ociremote.WithRemoteOptions(regClientOpts...))\n\t\t_ = remote.Delete(ref, regClientOpts...)\n\t}\n\treturn ref, remoteIndex, cleanup\n}\n\nfunc must(err error, t *testing.T) {\n\tt.Helper()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc mustErr(err error, t *testing.T) {\n\tt.Helper()\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n}\n\nfunc equals(v1, v2 interface{}, t *testing.T) {\n\tif diff := cmp.Diff(v1, v2); diff != \"\" {\n\t\tt.Error(diff)\n\t}\n}\n\nfunc reg(t *testing.T) (string, func()) {\n\trepo := os.Getenv(\"COSIGN_TEST_REPO\")\n\tif repo != \"\" {\n\t\treturn repo, func() {}\n\t}\n\n\tt.Log(\"COSIGN_TEST_REPO unset, using fake registry\")\n\tr := httptest.NewServer(registry.New())\n\tu, err := url.Parse(r.URL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn u.Host, r.Close\n}\n\nfunc registryClientOpts(ctx context.Context) []remote.Option {\n\treturn []remote.Option{\n\t\tremote.WithAuthFromKeychain(authn.DefaultKeychain),\n\t\tremote.WithContext(ctx),\n\t}\n}\n\n// If a signature has a bundle, but *not for that signature*, cosign verification should fail.\n// This test is pretty long, so here are the basic points:\n//  1. Sign image1 with a keypair, store entry in rekor\n//  2. Sign image2 with keypair, DO NOT store entry in rekor\n//  3. Take the bundle from image1 and store it on the signature in image2\n//  4. Verification of image2 should now fail, since the bundle is for a different signature\nfunc TestInvalidBundle(t *testing.T) {\n\tregName, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timg1 := path.Join(regName, \"cosign-e2e\")\n\n\timgRef, _, cleanup := mkimage(t, img1)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tctx := context.Background()\n\n\t// Sign image1 and store the entry in rekor\n\t// (we're just using it for its bundle)\n\tremoteOpts := ociremote.WithRemoteOptions(registryClientOpts(ctx)...)\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc, RekorURL: rekorURL}\n\tso := options.SignOptions{\n\t\tUpload:           true,\n\t\tTlogUpload:       true,\n\t\tSkipConfirmation: true,\n\t}\n\tmust(sign.SignCmd(ro, ko, so, []string{img1}), t)\n\t// verify image1\n\tmust(verify(pubKeyPath, img1, true, nil, \"\"), t)\n\t// extract the bundle from image1\n\tsi, err := ociremote.SignedImage(imgRef, remoteOpts)\n\tmust(err, t)\n\timgSigs, err := si.Signatures()\n\tmust(err, t)\n\tsigs, err := imgSigs.Get()\n\tmust(err, t)\n\tif l := len(sigs); l != 1 {\n\t\tt.Error(\"expected one signature\")\n\t}\n\tbund, err := sigs[0].Bundle()\n\tmust(err, t)\n\tif bund == nil {\n\t\tt.Fail()\n\t}\n\n\t// Now, we move on to image2\n\t// Sign image2 and DO NOT store the entry in rekor\n\tdefer setenv(t, env.VariableExperimental.String(), \"0\")()\n\timg2 := path.Join(regName, \"unrelated\")\n\timgRef2, _, cleanup := mkimage(t, img2)\n\tdefer cleanup()\n\tso = options.SignOptions{\n\t\tUpload:     true,\n\t\tTlogUpload: false,\n\t}\n\tmust(sign.SignCmd(ro, ko, so, []string{img2}), t)\n\tmust(verify(pubKeyPath, img2, true, nil, \"\"), t)\n\n\tsi2, err := ociremote.SignedEntity(imgRef2, remoteOpts)\n\tmust(err, t)\n\tsigs2, err := si2.Signatures()\n\tmust(err, t)\n\tgottenSigs2, err := sigs2.Get()\n\tmust(err, t)\n\tif len(gottenSigs2) != 1 {\n\t\tt.Fatal(\"there should be one signature\")\n\t}\n\tsigsTag, err := ociremote.SignatureTag(imgRef2)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// At this point, we would mutate the signature to add the bundle annotation\n\t// since we don't have a function for it at the moment, mock this by deleting the signature\n\t// and pushing a new signature with the additional bundle annotation\n\tif err := remote.Delete(sigsTag); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tmustErr(verify(pubKeyPath, img2, true, nil, \"\"), t)\n\n\tnewSig, err := mutate.Signature(gottenSigs2[0], mutate.WithBundle(bund))\n\tmust(err, t)\n\tsi2, err = ociremote.SignedEntity(imgRef2, remoteOpts)\n\tmust(err, t)\n\tnewImage, err := mutate.AttachSignatureToEntity(si2, newSig)\n\tmust(err, t)\n\tif err := ociremote.WriteSignatures(sigsTag.Repository, newImage); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// veriyfing image2 now should fail\n\tcmd := cliverify.VerifyCommand{\n\t\tKeyRef:        pubKeyPath,\n\t\tRekorURL:      rekorURL,\n\t\tCheckClaims:   true,\n\t\tHashAlgorithm: crypto.SHA256,\n\t\tMaxWorkers:    10,\n\t}\n\targs := []string{img2}\n\tmustErr(cmd.Exec(context.Background(), args), t)\n}\n\nfunc TestAttestBlobSignVerify(t *testing.T) {\n\tblob := \"someblob\"\n\tpredicate := `{ \"buildType\": \"x\", \"builder\": { \"id\": \"2\" }, \"recipe\": {} }`\n\tpredicateType := \"slsaprovenance\"\n\n\ttd1 := t.TempDir()\n\tt.Cleanup(func() {\n\t\tos.RemoveAll(td1)\n\t})\n\n\tbp := filepath.Join(td1, blob)\n\tif err := os.WriteFile(bp, []byte(blob), 0644); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tanotherBlob := filepath.Join(td1, \"another-blob\")\n\tif err := os.WriteFile(anotherBlob, []byte(\"another-blob\"), 0644); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpredicatePath := filepath.Join(td1, \"predicate\")\n\tif err := os.WriteFile(predicatePath, []byte(predicate), 0644); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\toutputSignature := filepath.Join(td1, \"signature\")\n\n\t_, privKeyPath1, pubKeyPath1 := keypair(t, td1)\n\n\tctx := context.Background()\n\tko := options.KeyOpts{\n\t\tKeyRef: pubKeyPath1,\n\t}\n\tblobVerifyAttestationCmd := cliverify.VerifyBlobAttestationCommand{\n\t\tKeyOpts:       ko,\n\t\tSignaturePath: outputSignature,\n\t\tPredicateType: predicateType,\n\t\tIgnoreTlog:    true,\n\t\tCheckClaims:   true,\n\t}\n\t// Verify should fail on a bad input\n\tmustErr(blobVerifyAttestationCmd.Exec(ctx, bp), t)\n\n\t// Now attest the blob with the private key\n\tko = options.KeyOpts{\n\t\tKeyRef:   privKeyPath1,\n\t\tPassFunc: passFunc,\n\t}\n\tattestBlobCmd := attest.AttestBlobCommand{\n\t\tKeyOpts:         ko,\n\t\tPredicatePath:   predicatePath,\n\t\tPredicateType:   predicateType,\n\t\tOutputSignature: outputSignature,\n\t}\n\tmust(attestBlobCmd.Exec(ctx, bp), t)\n\n\t// Now verify should work\n\tmust(blobVerifyAttestationCmd.Exec(ctx, bp), t)\n\n\t// Make sure we fail with the wrong predicate type\n\tblobVerifyAttestationCmd.PredicateType = \"custom\"\n\tmustErr(blobVerifyAttestationCmd.Exec(ctx, bp), t)\n\n\t// Make sure we fail with the wrong blob (set the predicate type back)\n\tblobVerifyAttestationCmd.PredicateType = predicateType\n\tmustErr(blobVerifyAttestationCmd.Exec(ctx, anotherBlob), t)\n}\n\nfunc TestOffline(t *testing.T) {\n\tregName, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timg1 := path.Join(regName, \"cosign-e2e\")\n\n\timgRef, _, cleanup := mkimage(t, img1)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tctx := context.Background()\n\n\t// Sign image1 and store the entry in rekor\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc, RekorURL: rekorURL}\n\tso := options.SignOptions{\n\t\tUpload:           true,\n\t\tTlogUpload:       true,\n\t\tSkipConfirmation: true,\n\t}\n\tmust(sign.SignCmd(ro, ko, so, []string{img1}), t)\n\t// verify image1 online and offline\n\tmust(verify(pubKeyPath, img1, true, nil, \"\"), t)\n\tverifyCmd := &cliverify.VerifyCommand{\n\t\tKeyRef:      pubKeyPath,\n\t\tOffline:     true,\n\t\tCheckClaims: true,\n\t\tMaxWorkers:  10,\n\t}\n\tmust(verifyCmd.Exec(ctx, []string{img1}), t)\n\n\t// Get signatures\n\tsi, err := ociremote.SignedEntity(imgRef)\n\tmust(err, t)\n\tsigs, err := si.Signatures()\n\tmust(err, t)\n\tgottenSigs, err := sigs.Get()\n\tmust(err, t)\n\n\tfakeBundle := &bundle.RekorBundle{\n\t\tSignedEntryTimestamp: []byte(\"\"),\n\t\tPayload: bundle.RekorPayload{\n\t\t\tBody: \"\",\n\t\t},\n\t}\n\tnewSig, err := mutate.Signature(gottenSigs[0], mutate.WithBundle(fakeBundle))\n\tmust(err, t)\n\n\tsigsTag, err := ociremote.SignatureTag(imgRef)\n\tif err := remote.Delete(sigsTag); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tsi, err = ociremote.SignedEntity(imgRef)\n\tmust(err, t)\n\tnewImage, err := mutate.AttachSignatureToEntity(si, newSig)\n\tmust(err, t)\n\n\tmustErr(verify(pubKeyPath, img1, true, nil, \"\"), t)\n\tif err := ociremote.WriteSignatures(sigsTag.Repository, newImage); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Confirm offline verification fails\n\tmustErr(verifyCmd.Exec(ctx, []string{img1}), t)\n}\n"], "fixing_code": ["//\n// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage cosign\n\nimport (\n\t\"context\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"runtime\"\n\t\"sync\"\n\n\t\"github.com/google/go-containerregistry/pkg/name\"\n\t\"github.com/in-toto/in-toto-golang/in_toto\"\n\t\"github.com/sigstore/cosign/v2/pkg/cosign/bundle\"\n\t\"github.com/sigstore/cosign/v2/pkg/oci\"\n\tociremote \"github.com/sigstore/cosign/v2/pkg/oci/remote\"\n\t\"golang.org/x/sync/errgroup\"\n)\n\nconst maxAllowedSigsOrAtts = 100\n\ntype SignedPayload struct {\n\tBase64Signature  string\n\tPayload          []byte\n\tCert             *x509.Certificate\n\tChain            []*x509.Certificate\n\tBundle           *bundle.RekorBundle\n\tRFC3161Timestamp *bundle.RFC3161Timestamp\n}\n\ntype LocalSignedPayload struct {\n\tBase64Signature string              `json:\"base64Signature\"`\n\tCert            string              `json:\"cert,omitempty\"`\n\tBundle          *bundle.RekorBundle `json:\"rekorBundle,omitempty\"`\n}\n\ntype Signatures struct {\n\tKeyID string `json:\"keyid\"`\n\tSig   string `json:\"sig\"`\n}\n\ntype AttestationPayload struct {\n\tPayloadType string       `json:\"payloadType\"`\n\tPayLoad     string       `json:\"payload\"`\n\tSignatures  []Signatures `json:\"signatures\"`\n}\n\nconst (\n\tSignature   = \"signature\"\n\tSBOM        = \"sbom\"\n\tAttestation = \"attestation\"\n\tDigest      = \"digest\"\n)\n\nfunc FetchSignaturesForReference(_ context.Context, ref name.Reference, opts ...ociremote.Option) ([]SignedPayload, error) {\n\tsimg, err := ociremote.SignedEntity(ref, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsigs, err := simg.Signatures()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"remote image: %w\", err)\n\t}\n\tl, err := sigs.Get()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"fetching signatures: %w\", err)\n\t}\n\tif len(l) == 0 {\n\t\treturn nil, fmt.Errorf(\"no signatures associated with %s\", ref)\n\t}\n\tif len(l) > maxAllowedSigsOrAtts {\n\t\treturn nil, fmt.Errorf(\"maximum number of signatures on an image is %d, found %d\", maxAllowedSigsOrAtts, len(l))\n\t}\n\n\tsignatures := make([]SignedPayload, len(l))\n\tvar g errgroup.Group\n\tg.SetLimit(runtime.NumCPU())\n\tfor i, sig := range l {\n\t\ti, sig := i, sig\n\t\tg.Go(func() error {\n\t\t\tvar err error\n\t\t\tsignatures[i].Payload, err = sig.Payload()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tsignatures[i].Base64Signature, err = sig.Base64Signature()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tsignatures[i].Cert, err = sig.Cert()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tsignatures[i].Chain, err = sig.Chain()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tsignatures[i].RFC3161Timestamp, err = sig.RFC3161Timestamp()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tsignatures[i].Bundle, err = sig.Bundle()\n\t\t\treturn err\n\t\t})\n\t}\n\tif err := g.Wait(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn signatures, nil\n}\n\nfunc FetchAttestationsForReference(_ context.Context, ref name.Reference, predicateType string, opts ...ociremote.Option) ([]AttestationPayload, error) {\n\tse, err := ociremote.SignedEntity(ref, opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn FetchAttestations(se, predicateType)\n}\n\nfunc FetchAttestations(se oci.SignedEntity, predicateType string) ([]AttestationPayload, error) {\n\tatts, err := se.Attestations()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"remote image: %w\", err)\n\t}\n\tl, err := atts.Get()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"fetching attestations: %w\", err)\n\t}\n\tif len(l) == 0 {\n\t\treturn nil, errors.New(\"found no attestations\")\n\t}\n\tif len(l) > maxAllowedSigsOrAtts {\n\t\terrMsg := fmt.Sprintf(\"maximum number of attestations on an image is %d, found %d\", maxAllowedSigsOrAtts, len(l))\n\t\treturn nil, errors.New(errMsg)\n\t}\n\n\tattestations := make([]AttestationPayload, 0, len(l))\n\tvar attMu sync.Mutex\n\n\tvar g errgroup.Group\n\tg.SetLimit(runtime.NumCPU())\n\n\tfor _, att := range l {\n\t\tatt := att\n\t\tg.Go(func() error {\n\t\t\trawPayload, err := att.Payload()\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"fetching payload: %w\", err)\n\t\t\t}\n\t\t\tvar payload AttestationPayload\n\t\t\tif err := json.Unmarshal(rawPayload, &payload); err != nil {\n\t\t\t\treturn fmt.Errorf(\"unmarshaling payload: %w\", err)\n\t\t\t}\n\n\t\t\tif predicateType != \"\" {\n\t\t\t\tvar decodedPayload []byte\n\t\t\t\tdecodedPayload, err = base64.StdEncoding.DecodeString(payload.PayLoad)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"decoding payload: %w\", err)\n\t\t\t\t}\n\t\t\t\tvar statement in_toto.Statement\n\t\t\t\tif err := json.Unmarshal(decodedPayload, &statement); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"unmarshaling statement: %w\", err)\n\t\t\t\t}\n\t\t\t\tif statement.PredicateType != predicateType {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tattMu.Lock()\n\t\t\tdefer attMu.Unlock()\n\t\t\tattestations = append(attestations, payload)\n\t\t\treturn nil\n\t\t})\n\t}\n\tif err := g.Wait(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(attestations) == 0 && predicateType != \"\" {\n\t\treturn nil, fmt.Errorf(\"no attestations with predicate type '%s' found\", predicateType)\n\t}\n\n\treturn attestations, nil\n}\n\n// FetchLocalSignedPayloadFromPath fetches a local signed payload from a path to a file\nfunc FetchLocalSignedPayloadFromPath(path string) (*LocalSignedPayload, error) {\n\tcontents, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"reading %s: %w\", path, err)\n\t}\n\tvar b *LocalSignedPayload\n\tif err := json.Unmarshal(contents, &b); err != nil {\n\t\treturn nil, err\n\t}\n\treturn b, nil\n}\n", "//\n// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build e2e\n// +build e2e\n\npackage test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/go-openapi/strfmt\"\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/google/go-containerregistry/pkg/authn\"\n\t\"github.com/google/go-containerregistry/pkg/name\"\n\t\"github.com/google/go-containerregistry/pkg/registry\"\n\t\"github.com/google/go-containerregistry/pkg/v1/random\"\n\t\"github.com/google/go-containerregistry/pkg/v1/remote\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\tk8s \"k8s.io/client-go/kubernetes\"\n\t\"k8s.io/client-go/tools/clientcmd\"\n\n\t// Initialize all known client auth plugins\n\t_ \"k8s.io/client-go/plugin/pkg/client/auth\"\n\n\t\"github.com/sigstore/cosign/v2/cmd/cosign/cli\"\n\t\"github.com/sigstore/cosign/v2/cmd/cosign/cli/attach\"\n\t\"github.com/sigstore/cosign/v2/cmd/cosign/cli/attest\"\n\t\"github.com/sigstore/cosign/v2/cmd/cosign/cli/download\"\n\t\"github.com/sigstore/cosign/v2/cmd/cosign/cli/generate\"\n\t\"github.com/sigstore/cosign/v2/cmd/cosign/cli/options\"\n\t\"github.com/sigstore/cosign/v2/cmd/cosign/cli/publickey\"\n\t\"github.com/sigstore/cosign/v2/cmd/cosign/cli/sign\"\n\tcliverify \"github.com/sigstore/cosign/v2/cmd/cosign/cli/verify\"\n\t\"github.com/sigstore/cosign/v2/internal/pkg/cosign/tsa\"\n\t\"github.com/sigstore/cosign/v2/internal/pkg/cosign/tsa/client\"\n\t\"github.com/sigstore/cosign/v2/pkg/cosign\"\n\t\"github.com/sigstore/cosign/v2/pkg/cosign/bundle\"\n\t\"github.com/sigstore/cosign/v2/pkg/cosign/env\"\n\t\"github.com/sigstore/cosign/v2/pkg/cosign/kubernetes\"\n\t\"github.com/sigstore/cosign/v2/pkg/oci/mutate\"\n\tociremote \"github.com/sigstore/cosign/v2/pkg/oci/remote\"\n\tsigs \"github.com/sigstore/cosign/v2/pkg/signature\"\n\t\"github.com/sigstore/sigstore/pkg/signature/payload\"\n\ttsaclient \"github.com/sigstore/timestamp-authority/pkg/client\"\n\t\"github.com/sigstore/timestamp-authority/pkg/server\"\n\t\"github.com/spf13/viper\"\n)\n\nconst (\n\tserverEnv = \"REKOR_SERVER\"\n\trekorURL  = \"https://rekor.sigstore.dev\"\n\tfulcioURL = \"https://fulcio.sigstore.dev\"\n)\n\nvar keyPass = []byte(\"hello\")\n\nvar passFunc = func(_ bool) ([]byte, error) {\n\treturn keyPass, nil\n}\n\nvar verify = func(keyRef, imageRef string, checkClaims bool, annotations map[string]interface{}, attachment string) error {\n\tcmd := cliverify.VerifyCommand{\n\t\tKeyRef:        keyRef,\n\t\tRekorURL:      rekorURL,\n\t\tCheckClaims:   checkClaims,\n\t\tAnnotations:   sigs.AnnotationsMap{Annotations: annotations},\n\t\tAttachment:    attachment,\n\t\tHashAlgorithm: crypto.SHA256,\n\t\tIgnoreTlog:    true,\n\t\tMaxWorkers:    10,\n\t}\n\n\targs := []string{imageRef}\n\n\treturn cmd.Exec(context.Background(), args)\n}\n\nvar verifyTSA = func(keyRef, imageRef string, checkClaims bool, annotations map[string]interface{}, attachment, tsaCertChain string, skipTlogVerify bool) error {\n\tcmd := cliverify.VerifyCommand{\n\t\tKeyRef:           keyRef,\n\t\tCheckClaims:      checkClaims,\n\t\tAnnotations:      sigs.AnnotationsMap{Annotations: annotations},\n\t\tAttachment:       attachment,\n\t\tHashAlgorithm:    crypto.SHA256,\n\t\tTSACertChainPath: tsaCertChain,\n\t\tIgnoreTlog:       skipTlogVerify,\n\t\tMaxWorkers:       10,\n\t}\n\n\targs := []string{imageRef}\n\n\treturn cmd.Exec(context.Background(), args)\n}\n\nvar verifyKeylessTSA = func(imageRef string, tsaCertChain string, skipSCT bool, skipTlogVerify bool) error {\n\tcmd := cliverify.VerifyCommand{\n\t\tCertVerifyOptions: options.CertVerifyOptions{\n\t\t\tCertOidcIssuerRegexp: \".*\",\n\t\t\tCertIdentityRegexp:   \".*\",\n\t\t},\n\t\tHashAlgorithm:    crypto.SHA256,\n\t\tTSACertChainPath: tsaCertChain,\n\t\tIgnoreSCT:        skipSCT,\n\t\tIgnoreTlog:       skipTlogVerify,\n\t\tMaxWorkers:       10,\n\t}\n\n\targs := []string{imageRef}\n\n\treturn cmd.Exec(context.Background(), args)\n}\n\n// Used to verify local images stored on disk\nvar verifyLocal = func(keyRef, path string, checkClaims bool, annotations map[string]interface{}, attachment string) error {\n\tcmd := cliverify.VerifyCommand{\n\t\tKeyRef:        keyRef,\n\t\tCheckClaims:   checkClaims,\n\t\tAnnotations:   sigs.AnnotationsMap{Annotations: annotations},\n\t\tAttachment:    attachment,\n\t\tHashAlgorithm: crypto.SHA256,\n\t\tLocalImage:    true,\n\t\tIgnoreTlog:    true,\n\t\tMaxWorkers:    10,\n\t}\n\n\targs := []string{path}\n\n\treturn cmd.Exec(context.Background(), args)\n}\n\nvar ro = &options.RootOptions{Timeout: options.DefaultTimeout}\n\nfunc TestSignVerify(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tctx := context.Background()\n\t// Verify should fail at first\n\tmustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\t// So should download\n\tmustErr(download.SignatureCmd(ctx, options.RegistryOptions{}, imgName), t)\n\n\t// Now sign the image\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tso := options.SignOptions{\n\t\tUpload: true,\n\t}\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\n\t// Now verify and download should work!\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\tmust(download.SignatureCmd(ctx, options.RegistryOptions{}, imgName), t)\n\n\t// Look for a specific annotation\n\tmustErr(verify(pubKeyPath, imgName, true, map[string]interface{}{\"foo\": \"bar\"}, \"\"), t)\n\n\tso.AnnotationOptions = options.AnnotationOptions{\n\t\tAnnotations: []string{\"foo=bar\"},\n\t}\n\t// Sign the image with an annotation\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\n\t// It should match this time.\n\tmust(verify(pubKeyPath, imgName, true, map[string]interface{}{\"foo\": \"bar\"}, \"\"), t)\n\n\t// But two doesn't work\n\tmustErr(verify(pubKeyPath, imgName, true, map[string]interface{}{\"foo\": \"bar\", \"baz\": \"bat\"}, \"\"), t)\n}\n\nfunc TestSignVerifyClean(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, _ = mkimage(t, imgName)\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tctx := context.Background()\n\n\t// Now sign the image\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tso := options.SignOptions{\n\t\tUpload: true,\n\t}\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\n\t// Now verify and download should work!\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\tmust(download.SignatureCmd(ctx, options.RegistryOptions{}, imgName), t)\n\n\t// Now clean signature from the given image\n\tmust(cli.CleanCmd(ctx, options.RegistryOptions{}, \"all\", imgName, true), t)\n\n\t// It doesn't work\n\tmustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n}\n\nfunc TestImportSignVerifyClean(t *testing.T) {\n\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, _ = mkimage(t, imgName)\n\n\t_, privKeyPath, pubKeyPath := importKeyPair(t, td)\n\n\tctx := context.Background()\n\n\t// Now sign the image\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tso := options.SignOptions{\n\t\tUpload: true,\n\t}\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\n\t// Now verify and download should work!\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\tmust(download.SignatureCmd(ctx, options.RegistryOptions{}, imgName), t)\n\n\t// Now clean signature from the given image\n\tmust(cli.CleanCmd(ctx, options.RegistryOptions{}, \"all\", imgName, true), t)\n\n\t// It doesn't work\n\tmustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n}\n\nfunc TestAttestVerify(t *testing.T) {\n\tattestVerify(t,\n\t\t\"slsaprovenance\",\n\t\t`{ \"buildType\": \"x\", \"builder\": { \"id\": \"2\" }, \"recipe\": {} }`,\n\t\t`predicate: builder: id: \"2\"`,\n\t\t`predicate: builder: id: \"1\"`,\n\t)\n}\n\nfunc TestAttestVerifySPDXJSON(t *testing.T) {\n\tattestationBytes, err := os.ReadFile(\"./testdata/bom-go-mod.spdx.json\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tattestVerify(t,\n\t\t\"spdxjson\",\n\t\tstring(attestationBytes),\n\t\t`predicate: spdxVersion: \"SPDX-2.2\"`,\n\t\t`predicate: spdxVersion: \"SPDX-9.9\"`,\n\t)\n}\n\nfunc TestAttestVerifyCycloneDXJSON(t *testing.T) {\n\tattestationBytes, err := os.ReadFile(\"./testdata/bom-go-mod.cyclonedx.json\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tattestVerify(t,\n\t\t\"cyclonedx\",\n\t\tstring(attestationBytes),\n\t\t`predicate: specVersion: \"1.4\"`,\n\t\t`predicate: specVersion: \"7.7\"`,\n\t)\n}\n\nfunc TestAttestVerifyURI(t *testing.T) {\n\tattestationBytes, err := os.ReadFile(\"./testdata/test-result.json\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tattestVerify(t,\n\t\t\"https://example.com/TestResult/v1\",\n\t\tstring(attestationBytes),\n\t\t`predicate: passed: true`,\n\t\t`predicate: passed: false\"`,\n\t)\n}\n\nfunc attestVerify(t *testing.T, predicateType, attestation, goodCue, badCue string) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\tvar imgName, attestationPath string\n\tif _, err := url.ParseRequestURI(predicateType); err == nil {\n\t\t// If the predicate type is URI, it cannot be included as image name and path.\n\t\timgName = path.Join(repo, \"cosign-attest-uri-e2e-image\")\n\t\tattestationPath = filepath.Join(td, \"cosign-attest-uri-e2e-attestation\")\n\t} else {\n\t\timgName = path.Join(repo, fmt.Sprintf(\"cosign-attest-%s-e2e-image\", predicateType))\n\t\tattestationPath = filepath.Join(td, fmt.Sprintf(\"cosign-attest-%s-e2e-attestation\", predicateType))\n\t}\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tctx := context.Background()\n\n\t// Verify should fail at first\n\tverifyAttestation := cliverify.VerifyAttestationCommand{\n\t\tKeyRef:     pubKeyPath,\n\t\tIgnoreTlog: true,\n\t\tMaxWorkers: 10,\n\t}\n\n\t// Fail case when using without type and policy flag\n\tmustErr(verifyAttestation.Exec(ctx, []string{imgName}), t)\n\n\tif err := os.WriteFile(attestationPath, []byte(attestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Now attest the image\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tattestCmd := attest.AttestCommand{\n\t\tKeyOpts:       ko,\n\t\tPredicatePath: attestationPath,\n\t\tPredicateType: predicateType,\n\t\tTimeout:       30 * time.Second,\n\t}\n\tmust(attestCmd.Exec(ctx, imgName), t)\n\n\t// Use cue to verify attestation\n\tpolicyPath := filepath.Join(td, \"policy.cue\")\n\tverifyAttestation.PredicateType = predicateType\n\tverifyAttestation.Policies = []string{policyPath}\n\n\t// Fail case\n\tif err := os.WriteFile(policyPath, []byte(badCue), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tmustErr(verifyAttestation.Exec(ctx, []string{imgName}), t)\n\n\t// Success case\n\tif err := os.WriteFile(policyPath, []byte(goodCue), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tmust(verifyAttestation.Exec(ctx, []string{imgName}), t)\n\n\t// Look for a specific annotation\n\tmustErr(verify(pubKeyPath, imgName, true, map[string]interface{}{\"foo\": \"bar\"}, \"\"), t)\n}\n\nfunc TestAttestationDownload(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-attest-download-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, _ := keypair(t, td)\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\n\tctx := context.Background()\n\n\tslsaAttestation := `{ \"buildType\": \"x\", \"builder\": { \"id\": \"2\" }, \"recipe\": {} }`\n\tslsaAttestationPath := filepath.Join(td, \"attestation.slsa.json\")\n\tif err := os.WriteFile(slsaAttestationPath, []byte(slsaAttestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvulnAttestation := `\n\t{\n    \"invocation\": {\n      \"parameters\": null,\n      \"uri\": \"invocation.example.com/cosign-testing\",\n      \"event_id\": \"\",\n      \"builder.id\": \"\"\n    },\n    \"scanner\": {\n      \"uri\": \"fakescanner.example.com/cosign-testing\",\n      \"version\": \"\",\n      \"db\": {\n        \"uri\": \"\",\n        \"version\": \"\"\n      },\n      \"result\": null\n    },\n    \"metadata\": {\n      \"scanStartedOn\": \"2022-04-12T00:00:00Z\",\n      \"scanFinishedOn\": \"2022-04-12T00:10:00Z\"\n    }\n}\n`\n\tvulnAttestationPath := filepath.Join(td, \"attestation.vuln.json\")\n\tif err := os.WriteFile(vulnAttestationPath, []byte(vulnAttestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tref, err := name.ParseReference(imgName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tregOpts := options.RegistryOptions{}\n\tociremoteOpts, err := regOpts.ClientOpts(ctx)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Attest to create a slsa attestation\n\tattestCommand := attest.AttestCommand{\n\t\tKeyOpts:       ko,\n\t\tPredicatePath: slsaAttestationPath,\n\t\tPredicateType: \"slsaprovenance\",\n\t\tTimeout:       30 * time.Second,\n\t\tReplace:       true,\n\t}\n\tmust(attestCommand.Exec(ctx, imgName), t)\n\n\t// Attest to create a vuln attestation\n\tattestCommand = attest.AttestCommand{\n\t\tKeyOpts:       ko,\n\t\tPredicatePath: vulnAttestationPath,\n\t\tPredicateType: \"vuln\",\n\t\tTimeout:       30 * time.Second,\n\t\tReplace:       true,\n\t}\n\tmust(attestCommand.Exec(ctx, imgName), t)\n\n\t// Call download.AttestationCmd() to ensure success\n\tattOpts := options.AttestationDownloadOptions{}\n\tmust(download.AttestationCmd(ctx, regOpts, attOpts, imgName), t)\n\n\tattestations, err := cosign.FetchAttestationsForReference(ctx, ref, attOpts.PredicateType, ociremoteOpts...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(attestations) != 2 {\n\t\tt.Fatal(fmt.Errorf(\"expected len(attestations) == 2, got %d\", len(attestations)))\n\t}\n}\n\nfunc TestAttestationDownloadWithPredicateType(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-attest-download-predicate-type-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, _ := keypair(t, td)\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\n\tctx := context.Background()\n\n\tslsaAttestation := `{ \"buildType\": \"x\", \"builder\": { \"id\": \"2\" }, \"recipe\": {} }`\n\tslsaAttestationPath := filepath.Join(td, \"attestation.slsa.json\")\n\tif err := os.WriteFile(slsaAttestationPath, []byte(slsaAttestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvulnAttestation := `\n\t{\n    \"invocation\": {\n      \"parameters\": null,\n      \"uri\": \"invocation.example.com/cosign-testing\",\n      \"event_id\": \"\",\n      \"builder.id\": \"\"\n    },\n    \"scanner\": {\n      \"uri\": \"fakescanner.example.com/cosign-testing\",\n      \"version\": \"\",\n      \"db\": {\n        \"uri\": \"\",\n        \"version\": \"\"\n      },\n      \"result\": null\n    },\n    \"metadata\": {\n      \"scanStartedOn\": \"2022-04-12T00:00:00Z\",\n      \"scanFinishedOn\": \"2022-04-12T00:10:00Z\"\n    }\n}\n`\n\tvulnAttestationPath := filepath.Join(td, \"attestation.vuln.json\")\n\tif err := os.WriteFile(vulnAttestationPath, []byte(vulnAttestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tref, err := name.ParseReference(imgName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tregOpts := options.RegistryOptions{}\n\tociremoteOpts, err := regOpts.ClientOpts(ctx)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Attest to create a slsa attestation\n\tattestCommand := attest.AttestCommand{\n\t\tKeyOpts:       ko,\n\t\tPredicatePath: slsaAttestationPath,\n\t\tPredicateType: \"slsaprovenance\",\n\t\tTimeout:       30 * time.Second,\n\t\tReplace:       true,\n\t}\n\tmust(attestCommand.Exec(ctx, imgName), t)\n\n\t// Attest to create a vuln attestation\n\tattestCommand = attest.AttestCommand{\n\t\tKeyOpts:       ko,\n\t\tPredicatePath: vulnAttestationPath,\n\t\tPredicateType: \"vuln\",\n\t\tTimeout:       30 * time.Second,\n\t\tReplace:       true,\n\t}\n\tmust(attestCommand.Exec(ctx, imgName), t)\n\n\t// Call download.AttestationCmd() to ensure success with --predicate-type\n\tattOpts := options.AttestationDownloadOptions{\n\t\tPredicateType: \"vuln\",\n\t}\n\tmust(download.AttestationCmd(ctx, regOpts, attOpts, imgName), t)\n\n\tpredicateType, _ := options.ParsePredicateType(attOpts.PredicateType)\n\tattestations, err := cosign.FetchAttestationsForReference(ctx, ref, predicateType, ociremoteOpts...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(attestations) != 1 {\n\t\tt.Fatal(fmt.Errorf(\"expected len(attestations) == 1, got %d\", len(attestations)))\n\t}\n}\n\nfunc TestAttestationDownloadWithBadPredicateType(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-attest-download-bad-type-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, _ := keypair(t, td)\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\n\tctx := context.Background()\n\n\tslsaAttestation := `{ \"buildType\": \"x\", \"builder\": { \"id\": \"2\" }, \"recipe\": {} }`\n\tslsaAttestationPath := filepath.Join(td, \"attestation.slsa.json\")\n\tif err := os.WriteFile(slsaAttestationPath, []byte(slsaAttestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tregOpts := options.RegistryOptions{}\n\n\t// Attest to create a slsa attestation\n\tattestCommand := attest.AttestCommand{\n\t\tKeyOpts:       ko,\n\t\tPredicatePath: slsaAttestationPath,\n\t\tPredicateType: \"slsaprovenance\",\n\t\tTimeout:       30 * time.Second,\n\t\tReplace:       true,\n\t}\n\tmust(attestCommand.Exec(ctx, imgName), t)\n\n\t// Call download.AttestationCmd() to ensure failure with non-existant --predicate-type\n\tattOpts := options.AttestationDownloadOptions{\n\t\tPredicateType: \"vuln\",\n\t}\n\tmustErr(download.AttestationCmd(ctx, regOpts, attOpts, imgName), t)\n}\n\nfunc TestAttestationReplaceCreate(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-attest-replace-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, _ := keypair(t, td)\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\n\tctx := context.Background()\n\n\tslsaAttestation := `{ \"buildType\": \"x\", \"builder\": { \"id\": \"2\" }, \"recipe\": {} }`\n\tslsaAttestationPath := filepath.Join(td, \"attestation.slsa.json\")\n\tif err := os.WriteFile(slsaAttestationPath, []byte(slsaAttestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tref, err := name.ParseReference(imgName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tregOpts := options.RegistryOptions{}\n\tociremoteOpts, err := regOpts.ClientOpts(ctx)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Attest with replace=true to create an attestation\n\tattestCommand := attest.AttestCommand{\n\t\tKeyOpts:       ko,\n\t\tPredicatePath: slsaAttestationPath,\n\t\tPredicateType: \"slsaprovenance\",\n\t\tTimeout:       30 * time.Second,\n\t\tReplace:       true,\n\t}\n\tmust(attestCommand.Exec(ctx, imgName), t)\n\n\t// Download and count the attestations\n\tattOpts := options.AttestationDownloadOptions{}\n\tattestations, err := cosign.FetchAttestationsForReference(ctx, ref, attOpts.PredicateType, ociremoteOpts...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(attestations) != 1 {\n\t\tt.Fatal(fmt.Errorf(\"expected len(attestations) == 1, got %d\", len(attestations)))\n\t}\n}\n\nfunc TestExcessiveAttestations(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-attest-download-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, _ := keypair(t, td)\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\n\tctx := context.Background()\n\n\tslsaAttestation := `{ \"buildType\": \"x\", \"builder\": { \"id\": \"2\" }, \"recipe\": {} }`\n\tslsaAttestationPath := filepath.Join(td, \"attestation.slsa.json\")\n\tif err := os.WriteFile(slsaAttestationPath, []byte(slsaAttestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvulnAttestation := `\n\t{\n    \"invocation\": {\n      \"parameters\": null,\n      \"uri\": \"invocation.example.com/cosign-testing\",\n      \"event_id\": \"\",\n      \"builder.id\": \"\"\n    },\n    \"scanner\": {\n      \"uri\": \"fakescanner.example.com/cosign-testing\",\n      \"version\": \"\",\n      \"db\": {\n        \"uri\": \"\",\n        \"version\": \"\"\n      },\n      \"result\": null\n    },\n    \"metadata\": {\n      \"scanStartedOn\": \"2022-04-12T00:00:00Z\",\n      \"scanFinishedOn\": \"2022-04-12T00:10:00Z\"\n    }\n}\n`\n\tref, err := name.ParseReference(imgName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tregOpts := options.RegistryOptions{}\n\tociremoteOpts, err := regOpts.ClientOpts(ctx)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor i := 0; i < 102; i++ {\n\t\tvulnAttestationPath := filepath.Join(td, fmt.Sprintf(\"attestation-%d.vuln.json\", i))\n\t\tif err := os.WriteFile(vulnAttestationPath, []byte(vulnAttestation), 0600); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Attest to create a vuln attestation\n\t\tattestCommand := attest.AttestCommand{\n\t\t\tKeyOpts:       ko,\n\t\t\tPredicatePath: vulnAttestationPath,\n\t\t\tPredicateType: \"vuln\",\n\t\t\tTimeout:       30 * time.Second,\n\t\t\tReplace:       false,\n\t\t}\n\t\tmust(attestCommand.Exec(ctx, imgName), t)\n\t}\n\n\tattOpts := options.AttestationDownloadOptions{}\n\t_, err = cosign.FetchAttestationsForReference(ctx, ref, attOpts.PredicateType, ociremoteOpts...)\n\tif err == nil {\n\t\tt.Fatalf(\"Expected an error, but 'err' was 'nil'\")\n\t}\n\texpectedError := \"maximum number of attestations on an image is 100, found 102\"\n\tif err.Error() != expectedError {\n\t\tt.Errorf(\"Exted the error to be: '%s' but it was '%s'\", expectedError, err.Error())\n\t}\n}\n\nfunc TestAttestationReplace(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-attest-replace-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, _ := keypair(t, td)\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\n\tctx := context.Background()\n\n\tslsaAttestation := `{ \"buildType\": \"x\", \"builder\": { \"id\": \"2\" }, \"recipe\": {} }`\n\tslsaAttestationPath := filepath.Join(td, \"attestation.slsa.json\")\n\tif err := os.WriteFile(slsaAttestationPath, []byte(slsaAttestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tref, err := name.ParseReference(imgName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tregOpts := options.RegistryOptions{}\n\tociremoteOpts, err := regOpts.ClientOpts(ctx)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Attest once with replace=false creating an attestation\n\tattestCommand := attest.AttestCommand{\n\t\tKeyOpts:       ko,\n\t\tPredicatePath: slsaAttestationPath,\n\t\tPredicateType: \"slsaprovenance\",\n\t\tTimeout:       30 * time.Second,\n\t}\n\tmust(attestCommand.Exec(ctx, imgName), t)\n\n\t// Download and count the attestations\n\tattOpts := options.AttestationDownloadOptions{}\n\tattestations, err := cosign.FetchAttestationsForReference(ctx, ref, attOpts.PredicateType, ociremoteOpts...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(attestations) != 1 {\n\t\tt.Fatal(fmt.Errorf(\"expected len(attestations) == 1, got %d\", len(attestations)))\n\t}\n\n\t// Attest again with replace=true, replacing the previous attestation\n\tattestCommand = attest.AttestCommand{\n\t\tKeyOpts:       ko,\n\t\tPredicatePath: slsaAttestationPath,\n\t\tPredicateType: \"slsaprovenance\",\n\t\tReplace:       true,\n\t\tTimeout:       30 * time.Second,\n\t}\n\tmust(attestCommand.Exec(ctx, imgName), t)\n\tattestations, err = cosign.FetchAttestationsForReference(ctx, ref, attOpts.PredicateType, ociremoteOpts...)\n\n\t// Download and count the attestations\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(attestations) != 1 {\n\t\tt.Fatal(fmt.Errorf(\"expected len(attestations) == 1, got %d\", len(attestations)))\n\t}\n\n\t// Attest once more replace=true using a different predicate, to ensure it adds a new attestation\n\tattestCommand = attest.AttestCommand{\n\t\tKeyOpts:       ko,\n\t\tPredicatePath: slsaAttestationPath,\n\t\tPredicateType: \"custom\",\n\t\tReplace:       true,\n\t\tTimeout:       30 * time.Second,\n\t}\n\tmust(attestCommand.Exec(ctx, imgName), t)\n\n\t// Download and count the attestations\n\tattestations, err = cosign.FetchAttestationsForReference(ctx, ref, attOpts.PredicateType, ociremoteOpts...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(attestations) != 2 {\n\t\tt.Fatal(fmt.Errorf(\"expected len(attestations) == 2, got %d\", len(attestations)))\n\t}\n}\n\nfunc TestAttestationRFC3161Timestamp(t *testing.T) {\n\t// TSA server needed to create timestamp\n\tviper.Set(\"timestamp-signer\", \"memory\")\n\tviper.Set(\"timestamp-signer-hash\", \"sha256\")\n\tapiServer := server.NewRestAPIServer(\"localhost\", 0, []string{\"http\"}, false, 10*time.Second, 10*time.Second)\n\tserver := httptest.NewServer(apiServer.GetHandler())\n\tt.Cleanup(server.Close)\n\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-attest-timestamp-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\n\tctx := context.Background()\n\n\tslsaAttestation := `{ \"buildType\": \"x\", \"builder\": { \"id\": \"2\" }, \"recipe\": {} }`\n\tslsaAttestationPath := filepath.Join(td, \"attestation.slsa.json\")\n\tif err := os.WriteFile(slsaAttestationPath, []byte(slsaAttestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tref, err := name.ParseReference(imgName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tregOpts := options.RegistryOptions{}\n\tociremoteOpts, err := regOpts.ClientOpts(ctx)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Attest with TSA and skipping tlog creating an attestation\n\tattestCommand := attest.AttestCommand{\n\t\tKeyOpts:       ko,\n\t\tPredicatePath: slsaAttestationPath,\n\t\tPredicateType: \"slsaprovenance\",\n\t\tTimeout:       30 * time.Second,\n\t\tTSAServerURL:  server.URL + \"/api/v1/timestamp\",\n\t\tTlogUpload:    false,\n\t}\n\tmust(attestCommand.Exec(ctx, imgName), t)\n\n\t// Download and count the attestations\n\tattOpts := options.AttestationDownloadOptions{}\n\tattestations, err := cosign.FetchAttestationsForReference(ctx, ref, attOpts.PredicateType, ociremoteOpts...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(attestations) != 1 {\n\t\tt.Fatal(fmt.Errorf(\"expected len(attestations) == 1, got %d\", len(attestations)))\n\t}\n\n\tclient, err := tsaclient.GetTimestampClient(server.URL)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tchain, err := client.Timestamp.GetTimestampCertChain(nil)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error getting timestamp chain: %v\", err)\n\t}\n\n\tfile, err := os.CreateTemp(os.TempDir(), \"tempfile\")\n\tif err != nil {\n\t\tt.Fatalf(\"error creating temp file: %v\", err)\n\t}\n\tdefer os.Remove(file.Name())\n\t_, err = file.WriteString(chain.Payload)\n\tif err != nil {\n\t\tt.Fatalf(\"error writing chain payload to temp file: %v\", err)\n\t}\n\n\tverifyAttestation := cliverify.VerifyAttestationCommand{\n\t\tKeyRef:           pubKeyPath,\n\t\tTSACertChainPath: file.Name(),\n\t\tIgnoreTlog:       true,\n\t\tPredicateType:    \"slsaprovenance\",\n\t\tMaxWorkers:       10,\n\t}\n\n\tmust(verifyAttestation.Exec(ctx, []string{imgName}), t)\n}\n\nfunc TestAttachWithRFC3161Timestamp(t *testing.T) {\n\tctx := context.Background()\n\t// TSA server needed to create timestamp\n\tviper.Set(\"timestamp-signer\", \"memory\")\n\tviper.Set(\"timestamp-signer-hash\", \"sha256\")\n\tapiServer := server.NewRestAPIServer(\"localhost\", 0, []string{\"http\"}, false, 10*time.Second, 10*time.Second)\n\tserver := httptest.NewServer(apiServer.GetHandler())\n\tt.Cleanup(server.Close)\n\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-attach-timestamp-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\tb := bytes.Buffer{}\n\tmust(generate.GenerateCmd(context.Background(), options.RegistryOptions{}, imgName, nil, &b), t)\n\n\trootCert, rootKey, _ := GenerateRootCa()\n\tsubCert, subKey, _ := GenerateSubordinateCa(rootCert, rootKey)\n\tleafCert, privKey, _ := GenerateLeafCert(\"subject@mail.com\", \"oidc-issuer\", subCert, subKey)\n\tpemRoot := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: rootCert.Raw})\n\tpemSub := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: subCert.Raw})\n\tpemLeaf := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: leafCert.Raw})\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tpayloadref := mkfile(b.String(), td, t)\n\n\th := sha256.Sum256(b.Bytes())\n\tsignature, _ := privKey.Sign(rand.Reader, h[:], crypto.SHA256)\n\tb64signature := base64.StdEncoding.EncodeToString([]byte(signature))\n\tsigRef := mkfile(b64signature, td, t)\n\tpemleafRef := mkfile(string(pemLeaf), td, t)\n\tpemrootRef := mkfile(string(pemRoot), td, t)\n\n\tcertchainRef := mkfile(string(append(pemSub[:], pemRoot[:]...)), td, t)\n\n\tt.Setenv(\"SIGSTORE_ROOT_FILE\", pemrootRef)\n\n\ttsclient, err := tsaclient.GetTimestampClient(server.URL)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tchain, err := tsclient.Timestamp.GetTimestampCertChain(nil)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error getting timestamp chain: %v\", err)\n\t}\n\n\tfile, err := os.CreateTemp(os.TempDir(), \"tempfile\")\n\tif err != nil {\n\t\tt.Fatalf(\"error creating temp file: %v\", err)\n\t}\n\tdefer os.Remove(file.Name())\n\t_, err = file.WriteString(chain.Payload)\n\tif err != nil {\n\t\tt.Fatalf(\"error writing chain payload to temp file: %v\", err)\n\t}\n\n\ttsBytes, err := tsa.GetTimestampedSignature(signature, client.NewTSAClient(server.URL+\"/api/v1/timestamp\"))\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error creating timestamp: %v\", err)\n\t}\n\trfc3161TSRef := mkfile(string(tsBytes), td, t)\n\n\t// Upload it!\n\terr = attach.SignatureCmd(ctx, options.RegistryOptions{}, sigRef, payloadref, pemleafRef, certchainRef, rfc3161TSRef, \"\", imgName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tmust(verifyKeylessTSA(imgName, file.Name(), true, true), t)\n}\n\nfunc TestAttachWithRekorBundle(t *testing.T) {\n\tctx := context.Background()\n\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-attach-timestamp-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\tb := bytes.Buffer{}\n\tmust(generate.GenerateCmd(context.Background(), options.RegistryOptions{}, imgName, nil, &b), t)\n\n\trootCert, rootKey, _ := GenerateRootCa()\n\tsubCert, subKey, _ := GenerateSubordinateCa(rootCert, rootKey)\n\tleafCert, privKey, _ := GenerateLeafCert(\"subject@mail.com\", \"oidc-issuer\", subCert, subKey)\n\tpemRoot := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: rootCert.Raw})\n\tpemSub := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: subCert.Raw})\n\tpemLeaf := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: leafCert.Raw})\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tpayloadref := mkfile(b.String(), td, t)\n\n\th := sha256.Sum256(b.Bytes())\n\tsignature, _ := privKey.Sign(rand.Reader, h[:], crypto.SHA256)\n\tb64signature := base64.StdEncoding.EncodeToString([]byte(signature))\n\tsigRef := mkfile(b64signature, td, t)\n\tpemleafRef := mkfile(string(pemLeaf), td, t)\n\tpemrootRef := mkfile(string(pemRoot), td, t)\n\n\tt.Setenv(\"SIGSTORE_ROOT_FILE\", pemrootRef)\n\n\tcertchainRef := mkfile(string(append(pemSub[:], pemRoot[:]...)), td, t)\n\n\tlocalPayload := cosign.LocalSignedPayload{\n\t\tBase64Signature: b64signature,\n\t\tCert:            string(pemLeaf),\n\t\tBundle: &bundle.RekorBundle{\n\t\t\tSignedEntryTimestamp: strfmt.Base64(\"MEUCIEDcarEwRYkrxE9ne+kzEVvUhnWaauYzxhUyXOLy1hwAAiEA4VdVCvNRs+D/5o33C2KBy+q2YX3lP4Y7nqRFU+K3hi0=\"),\n\t\t\tPayload: bundle.RekorPayload{\n\t\t\t\tBody:           \"REMOVED\",\n\t\t\t\tIntegratedTime: 1631646761,\n\t\t\t\tLogIndex:       693591,\n\t\t\t\tLogID:          \"c0d23d6ad406973f9559f3ba2d1ca01f84147d8ffc5b8445c224f98b9591801d\",\n\t\t\t},\n\t\t},\n\t}\n\n\tjsonBundle, err := json.Marshal(localPayload)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tbundlePath := filepath.Join(td, \"bundle.json\")\n\tif err := os.WriteFile(bundlePath, jsonBundle, 0644); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Upload it!\n\terr = attach.SignatureCmd(ctx, options.RegistryOptions{}, sigRef, payloadref, pemleafRef, certchainRef, \"\", bundlePath, imgName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestRekorBundle(t *testing.T) {\n\t// turn on the tlog\n\tdefer setenv(t, env.VariableExperimental.String(), \"1\")()\n\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tko := options.KeyOpts{\n\t\tKeyRef:   privKeyPath,\n\t\tPassFunc: passFunc,\n\t\tRekorURL: rekorURL,\n\t}\n\tso := options.SignOptions{\n\t\tUpload: true,\n\t}\n\n\t// Sign the image\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\t// Make sure verify works\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// Make sure offline verification works with bundling\n\t// use rekor prod since we have hardcoded the public key\n\tos.Setenv(serverEnv, \"notreal\")\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n}\n\nfunc TestRekorOutput(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\tbundlePath := filepath.Join(td, \"bundle.sig\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tko := options.KeyOpts{\n\t\tKeyRef:     privKeyPath,\n\t\tPassFunc:   passFunc,\n\t\tRekorURL:   rekorURL,\n\t\tBundlePath: bundlePath,\n\t}\n\tso := options.SignOptions{\n\t\tUpload: true,\n\t}\n\n\t// Sign the image\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\t// Make sure verify works\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\tif file, err := os.ReadFile(bundlePath); err != nil {\n\t\tt.Fatal(err)\n\t} else {\n\t\tvar localCosignPayload cosign.LocalSignedPayload\n\t\tif err := json.Unmarshal(file, &localCosignPayload); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\t// Make sure offline verification works with bundling\n\t// use rekor prod since we have hardcoded the public key\n\tos.Setenv(serverEnv, \"notreal\")\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n}\n\nfunc TestFulcioBundle(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tko := options.KeyOpts{\n\t\tKeyRef:    privKeyPath,\n\t\tPassFunc:  passFunc,\n\t\tRekorURL:  rekorURL,\n\t\tFulcioURL: fulcioURL,\n\t}\n\tso := options.SignOptions{\n\t\tUpload:           true,\n\t\tIssueCertificate: true,\n\t}\n\n\t// Sign the image\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\t// Make sure verify works\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// Make sure offline verification works with bundling\n\t// use rekor prod since we have hardcoded the public key\n\tos.Setenv(serverEnv, \"notreal\")\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n}\n\nfunc TestRFC3161Timestamp(t *testing.T) {\n\t// TSA server needed to create timestamp\n\tviper.Set(\"timestamp-signer\", \"memory\")\n\tviper.Set(\"timestamp-signer-hash\", \"sha256\")\n\tapiServer := server.NewRestAPIServer(\"localhost\", 0, []string{\"http\"}, false, 10*time.Second, 10*time.Second)\n\tserver := httptest.NewServer(apiServer.GetHandler())\n\tt.Cleanup(server.Close)\n\n\tclient, err := tsaclient.GetTimestampClient(server.URL)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tchain, err := client.Timestamp.GetTimestampCertChain(nil)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error getting timestamp chain: %v\", err)\n\t}\n\n\tfile, err := os.CreateTemp(os.TempDir(), \"tempfile\")\n\tif err != nil {\n\t\tt.Fatalf(\"error creating temp file: %v\", err)\n\t}\n\tdefer os.Remove(file.Name())\n\t_, err = file.WriteString(chain.Payload)\n\tif err != nil {\n\t\tt.Fatalf(\"error writing chain payload to temp file: %v\", err)\n\t}\n\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tko := options.KeyOpts{\n\t\tKeyRef:       privKeyPath,\n\t\tPassFunc:     passFunc,\n\t\tTSAServerURL: server.URL + \"/api/v1/timestamp\",\n\t}\n\tso := options.SignOptions{\n\t\tUpload:     true,\n\t\tTlogUpload: false,\n\t}\n\n\t// Sign the image\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\t// Make sure verify works against the TSA server\n\tmust(verifyTSA(pubKeyPath, imgName, true, nil, \"\", file.Name(), true), t)\n}\n\nfunc TestRekorBundleAndRFC3161Timestamp(t *testing.T) {\n\t// TSA server needed to create timestamp\n\tviper.Set(\"timestamp-signer\", \"memory\")\n\tviper.Set(\"timestamp-signer-hash\", \"sha256\")\n\tapiServer := server.NewRestAPIServer(\"localhost\", 0, []string{\"http\"}, false, 10*time.Second, 10*time.Second)\n\tserver := httptest.NewServer(apiServer.GetHandler())\n\tt.Cleanup(server.Close)\n\n\tclient, err := tsaclient.GetTimestampClient(server.URL)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tchain, err := client.Timestamp.GetTimestampCertChain(nil)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error getting timestamp chain: %v\", err)\n\t}\n\n\tfile, err := os.CreateTemp(os.TempDir(), \"tempfile\")\n\tif err != nil {\n\t\tt.Fatalf(\"error creating temp file: %v\", err)\n\t}\n\tdefer os.Remove(file.Name())\n\t_, err = file.WriteString(chain.Payload)\n\tif err != nil {\n\t\tt.Fatalf(\"error writing chain payload to temp file: %v\", err)\n\t}\n\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tko := options.KeyOpts{\n\t\tKeyRef:           privKeyPath,\n\t\tPassFunc:         passFunc,\n\t\tTSAServerURL:     server.URL + \"/api/v1/timestamp\",\n\t\tRekorURL:         rekorURL,\n\t\tSkipConfirmation: true,\n\t}\n\tso := options.SignOptions{\n\t\tUpload:     true,\n\t\tTlogUpload: true,\n\t}\n\n\t// Sign the image\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\t// Make sure verify works against the Rekor and TSA clients\n\tmust(verifyTSA(pubKeyPath, imgName, true, nil, \"\", file.Name(), false), t)\n}\n\nfunc TestDuplicateSign(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\tref, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tctx := context.Background()\n\t// Verify should fail at first\n\tmustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\t// So should download\n\tmustErr(download.SignatureCmd(ctx, options.RegistryOptions{}, imgName), t)\n\n\t// Now sign the image\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tso := options.SignOptions{\n\t\tUpload: true,\n\t}\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\n\t// Now verify and download should work!\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\tmust(download.SignatureCmd(ctx, options.RegistryOptions{}, imgName), t)\n\n\t// Signing again should work just fine...\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\n\tse, err := ociremote.SignedEntity(ref, ociremote.WithRemoteOptions(registryClientOpts(ctx)...))\n\tmust(err, t)\n\tsigs, err := se.Signatures()\n\tmust(err, t)\n\tsignatures, err := sigs.Get()\n\tmust(err, t)\n\n\tif len(signatures) > 1 {\n\t\tt.Errorf(\"expected there to only be one signature, got %v\", signatures)\n\t}\n}\n\nfunc TestExcessiveSignatures(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\tctx := context.Background()\n\n\tfor i := 0; i < 102; i++ {\n\t\t_, privKeyPath, _ := keypair(t, td)\n\n\t\t// Sign the image\n\t\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\t\tso := options.SignOptions{\n\t\t\tUpload: true,\n\t\t}\n\t\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\t}\n\terr := download.SignatureCmd(ctx, options.RegistryOptions{}, imgName)\n\tif err == nil {\n\t\tt.Fatal(\"Expected an error, but 'err' was 'nil'\")\n\t}\n\texpectedErr := \"maximum number of signatures on an image is 100, found 102\"\n\tif err.Error() != expectedErr {\n\t\tt.Fatalf(\"Expected the error '%s', but got the error '%s'\", expectedErr, err.Error())\n\t}\n}\n\nfunc TestKeyURLVerify(t *testing.T) {\n\t// TODO: re-enable once distroless images are being signed by the new client\n\tt.Skip()\n\t// Verify that an image can be verified via key url\n\tkeyRef := \"https://raw.githubusercontent.com/GoogleContainerTools/distroless/main/cosign.pub\"\n\timg := \"gcr.io/distroless/base:latest\"\n\n\tmust(verify(keyRef, img, true, nil, \"\"), t)\n}\n\nfunc TestGenerateKeyPairEnvVar(t *testing.T) {\n\tdefer setenv(t, \"COSIGN_PASSWORD\", \"foo\")()\n\tkeys, err := cosign.GenerateKeyPair(generate.GetPass)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, err := cosign.LoadPrivateKey(keys.PrivateBytes, []byte(\"foo\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestGenerateKeyPairK8s(t *testing.T) {\n\ttd := t.TempDir()\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := os.Chdir(td); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() {\n\t\tos.Chdir(wd)\n\t}()\n\tpassword := \"foo\"\n\tdefer setenv(t, \"COSIGN_PASSWORD\", password)()\n\tctx := context.Background()\n\tname := \"cosign-secret\"\n\tnamespace := \"default\"\n\tif err := kubernetes.KeyPairSecret(ctx, fmt.Sprintf(\"k8s://%s/%s\", namespace, name), generate.GetPass); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// make sure the secret actually exists\n\n\tcfg, err := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(\n\t\tclientcmd.NewDefaultClientConfigLoadingRules(), nil).ClientConfig()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclient, err := k8s.NewForConfig(cfg)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ts, err := client.CoreV1().Secrets(namespace).Get(ctx, name, metav1.GetOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif v, ok := s.Data[\"cosign.password\"]; !ok || string(v) != password {\n\t\tt.Fatalf(\"password is incorrect, got %v expected %v\", v, \"foo\")\n\t}\n}\n\nfunc TestMultipleSignatures(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\n\ttd1 := t.TempDir()\n\ttd2 := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, priv1, pub1 := keypair(t, td1)\n\t_, priv2, pub2 := keypair(t, td2)\n\n\t// Verify should fail at first for both keys\n\tmustErr(verify(pub1, imgName, true, nil, \"\"), t)\n\tmustErr(verify(pub2, imgName, true, nil, \"\"), t)\n\n\t// Now sign the image with one key\n\tko := options.KeyOpts{KeyRef: priv1, PassFunc: passFunc}\n\tso := options.SignOptions{\n\t\tUpload: true,\n\t}\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\t// Now verify should work with that one, but not the other\n\tmust(verify(pub1, imgName, true, nil, \"\"), t)\n\tmustErr(verify(pub2, imgName, true, nil, \"\"), t)\n\n\t// Now sign with the other key too\n\tko.KeyRef = priv2\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\n\t// Now verify should work with both\n\tmust(verify(pub1, imgName, true, nil, \"\"), t)\n\tmust(verify(pub2, imgName, true, nil, \"\"), t)\n}\n\nfunc TestSignBlob(t *testing.T) {\n\tblob := \"someblob\"\n\ttd1 := t.TempDir()\n\ttd2 := t.TempDir()\n\tt.Cleanup(func() {\n\t\tos.RemoveAll(td1)\n\t\tos.RemoveAll(td2)\n\t})\n\tbp := filepath.Join(td1, blob)\n\n\tif err := os.WriteFile(bp, []byte(blob), 0644); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, privKeyPath1, pubKeyPath1 := keypair(t, td1)\n\t_, _, pubKeyPath2 := keypair(t, td2)\n\n\tctx := context.Background()\n\n\tko1 := options.KeyOpts{\n\t\tKeyRef: pubKeyPath1,\n\t}\n\tko2 := options.KeyOpts{\n\t\tKeyRef: pubKeyPath2,\n\t}\n\t// Verify should fail on a bad input\n\tcmd1 := cliverify.VerifyBlobCmd{\n\t\tKeyOpts:    ko1,\n\t\tSigRef:     \"badsig\",\n\t\tIgnoreTlog: true,\n\t}\n\tcmd2 := cliverify.VerifyBlobCmd{\n\t\tKeyOpts:    ko2,\n\t\tSigRef:     \"badsig\",\n\t\tIgnoreTlog: true,\n\t}\n\tmustErr(cmd1.Exec(ctx, blob), t)\n\tmustErr(cmd2.Exec(ctx, blob), t)\n\n\t// Now sign the blob with one key\n\tko := options.KeyOpts{\n\t\tKeyRef:   privKeyPath1,\n\t\tPassFunc: passFunc,\n\t}\n\tsig, err := sign.SignBlobCmd(ro, ko, bp, true, \"\", \"\", false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Now verify should work with that one, but not the other\n\tcmd1.SigRef = string(sig)\n\tcmd2.SigRef = string(sig)\n\tmust(cmd1.Exec(ctx, bp), t)\n\tmustErr(cmd2.Exec(ctx, bp), t)\n}\n\nfunc TestSignBlobBundle(t *testing.T) {\n\tblob := \"someblob\"\n\ttd1 := t.TempDir()\n\tt.Cleanup(func() {\n\t\tos.RemoveAll(td1)\n\t})\n\tbp := filepath.Join(td1, blob)\n\tbundlePath := filepath.Join(td1, \"bundle.sig\")\n\n\tif err := os.WriteFile(bp, []byte(blob), 0644); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, privKeyPath1, pubKeyPath1 := keypair(t, td1)\n\n\tctx := context.Background()\n\n\tko1 := options.KeyOpts{\n\t\tKeyRef:     pubKeyPath1,\n\t\tBundlePath: bundlePath,\n\t}\n\t// Verify should fail on a bad input\n\tverifyBlobCmd := cliverify.VerifyBlobCmd{\n\t\tKeyOpts:    ko1,\n\t\tIgnoreTlog: true,\n\t}\n\tmustErr(verifyBlobCmd.Exec(ctx, bp), t)\n\n\t// Now sign the blob with one key\n\tko := options.KeyOpts{\n\t\tKeyRef:           privKeyPath1,\n\t\tPassFunc:         passFunc,\n\t\tBundlePath:       bundlePath,\n\t\tRekorURL:         rekorURL,\n\t\tSkipConfirmation: true,\n\t}\n\tif _, err := sign.SignBlobCmd(ro, ko, bp, true, \"\", \"\", false); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Now verify should work\n\tmust(verifyBlobCmd.Exec(ctx, bp), t)\n\n\t// Now we turn on the tlog and sign again\n\tif _, err := sign.SignBlobCmd(ro, ko, bp, true, \"\", \"\", true); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Point to a fake rekor server to make sure offline verification of the tlog entry works\n\tos.Setenv(serverEnv, \"notreal\")\n\tverifyBlobCmd.IgnoreTlog = false\n\tmust(verifyBlobCmd.Exec(ctx, bp), t)\n}\n\nfunc TestSignBlobRFC3161TimestampBundle(t *testing.T) {\n\t// TSA server needed to create timestamp\n\tviper.Set(\"timestamp-signer\", \"memory\")\n\tviper.Set(\"timestamp-signer-hash\", \"sha256\")\n\tapiServer := server.NewRestAPIServer(\"localhost\", 0, []string{\"http\"}, false, 10*time.Second, 10*time.Second)\n\tserver := httptest.NewServer(apiServer.GetHandler())\n\tt.Cleanup(server.Close)\n\n\tblob := \"someblob\"\n\ttd1 := t.TempDir()\n\tt.Cleanup(func() {\n\t\tos.RemoveAll(td1)\n\t})\n\tbp := filepath.Join(td1, blob)\n\tbundlePath := filepath.Join(td1, \"bundle.sig\")\n\ttsPath := filepath.Join(td1, \"rfc3161Timestamp.json\")\n\n\tif err := os.WriteFile(bp, []byte(blob), 0644); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tclient, err := tsaclient.GetTimestampClient(server.URL)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tchain, err := client.Timestamp.GetTimestampCertChain(nil)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error getting timestamp chain: %v\", err)\n\t}\n\n\tfile, err := os.CreateTemp(os.TempDir(), \"tempfile\")\n\tif err != nil {\n\t\tt.Fatalf(\"error creating temp file: %v\", err)\n\t}\n\tdefer os.Remove(file.Name())\n\t_, err = file.WriteString(chain.Payload)\n\tif err != nil {\n\t\tt.Fatalf(\"error writing chain payload to temp file: %v\", err)\n\t}\n\n\t_, privKeyPath1, pubKeyPath1 := keypair(t, td1)\n\n\tctx := context.Background()\n\n\tko1 := options.KeyOpts{\n\t\tKeyRef:               pubKeyPath1,\n\t\tBundlePath:           bundlePath,\n\t\tRFC3161TimestampPath: tsPath,\n\t\tTSACertChainPath:     file.Name(),\n\t}\n\t// Verify should fail on a bad input\n\tverifyBlobCmd := cliverify.VerifyBlobCmd{\n\t\tKeyOpts:    ko1,\n\t\tIgnoreTlog: true,\n\t}\n\tmustErr(verifyBlobCmd.Exec(ctx, bp), t)\n\n\t// Now sign the blob with one key\n\tko := options.KeyOpts{\n\t\tKeyRef:               privKeyPath1,\n\t\tPassFunc:             passFunc,\n\t\tBundlePath:           bundlePath,\n\t\tRFC3161TimestampPath: tsPath,\n\t\tTSAServerURL:         server.URL + \"/api/v1/timestamp\",\n\t\tRekorURL:             rekorURL,\n\t\tSkipConfirmation:     true,\n\t}\n\tif _, err := sign.SignBlobCmd(ro, ko, bp, true, \"\", \"\", false); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Now verify should work\n\tmust(verifyBlobCmd.Exec(ctx, bp), t)\n\n\t// Now we turn on the tlog and sign again\n\tif _, err := sign.SignBlobCmd(ro, ko, bp, true, \"\", \"\", true); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Point to a fake rekor server to make sure offline verification of the tlog entry works\n\tverifyBlobCmd.IgnoreTlog = false\n\tmust(verifyBlobCmd.Exec(ctx, bp), t)\n}\n\nfunc TestGenerate(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\t_, desc, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t// Generate the payload for the image, and check the digest.\n\tb := bytes.Buffer{}\n\tmust(generate.GenerateCmd(context.Background(), options.RegistryOptions{}, imgName, nil, &b), t)\n\tss := payload.SimpleContainerImage{}\n\tmust(json.Unmarshal(b.Bytes(), &ss), t)\n\n\tequals(desc.Digest.String(), ss.Critical.Image.DockerManifestDigest, t)\n\n\t// Now try with some annotations.\n\tb.Reset()\n\ta := map[string]interface{}{\"foo\": \"bar\"}\n\tmust(generate.GenerateCmd(context.Background(), options.RegistryOptions{}, imgName, a, &b), t)\n\tmust(json.Unmarshal(b.Bytes(), &ss), t)\n\n\tequals(desc.Digest.String(), ss.Critical.Image.DockerManifestDigest, t)\n\tequals(ss.Optional[\"foo\"], \"bar\", t)\n}\n\nfunc keypair(t *testing.T, td string) (*cosign.KeysBytes, string, string) {\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := os.Chdir(td); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() {\n\t\tos.Chdir(wd)\n\t}()\n\tkeys, err := cosign.GenerateKeyPair(passFunc)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tprivKeyPath := filepath.Join(td, \"cosign.key\")\n\tif err := os.WriteFile(privKeyPath, keys.PrivateBytes, 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpubKeyPath := filepath.Join(td, \"cosign.pub\")\n\tif err := os.WriteFile(pubKeyPath, keys.PublicBytes, 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn keys, privKeyPath, pubKeyPath\n}\n\nfunc importKeyPair(t *testing.T, td string) (*cosign.KeysBytes, string, string) {\n\n\tconst validrsa1 = `-----BEGIN RSA PRIVATE KEY-----\nMIIEogIBAAKCAQEAx5piWVlE62NnZ0UzJ8Z6oKiKOC4dbOZ1HsNhIRtqkM+Oq4G+\n25yq6P+0JU/Qvr9veOGEb3R/J9u8JBo+hv2i5X8OtgvP2V2pi6f1s6vK7L0+6uRb\n4YTT/UdMshaVf97MgEqbq41Jf/cuvh+3AV0tZ1BpixZg4aXMKpY6HUP69lbsu27o\nSUN1myMv7TSgZiV4CYs3l/gkEfpysBptWlcHRuw5RsB+C0RbjRtbJ/5VxmE/vd3M\nlafd5t1WSpMb8yf0a84u5NFaXwZ7CweMfXeOddS0yb19ShSuW3PPRadruBM1mq15\njs9GfagPxDS75Imcs+fA62lWvHxEujTGjYHxawIDAQABAoIBAH+sgLwmHa9zJfEo\nklAe5NFe/QpydN/ziXbkAnzqzH9URC3wD+TpkWj4JoK3Sw635NWtasjf+3XDV9S/\n9L7j/g5N91r6sziWcJykEsWaXXKQmm4lI6BdFjwsHyLKz1W7bZOiJXDWLu1rbrqu\nDqEQuLoc9WXCKrYrFy0maoXNtfla/1p05kKN0bMigcnnyAQ+xBTwoyco4tkIz5se\nIYxorz7qzXrkHQI+knz5BawmNe3ekoSaXUPoLoOR7TRTGsLteL5yukvWAi8S/0rE\ngftC+PZCQpoQhSUYq7wXe7RowJ1f+kXb7HsSedOTfTSW1D/pUb/uW+CcRKig42ZI\nI9H9TAECgYEA5XGBML6fJyWVqx64sHbUAjQsmQ0RwU6Zo7sqHIEPf6tYVYp7KtzK\nKOfi8seOOL5FSy4pjCo11Dzyrh9bn45RNmtjSYTgOnVPSoCfuRNfOcpG+/wCHjYf\nEjDvdrCpbg59kVUeaMeBDiyWAlM48HJAn8O7ez2U/iKQCyJmOIwFhSkCgYEA3rSz\nFi1NzqYWxWos4NBmg8iKcQ9SMkmPdgRLAs/WNnZJ8fdgJZwihevkXGytRGJEmav2\nGMKRx1g6ey8fjXTQH9WM8X/kJC5fv8wLHnUCH/K3Mcp9CYwn7PFvSnBr4kQoc/el\nbURhcF1+/opEC8vNX/Wk3zAG7Xs1PREXlH2SIHMCgYBV/3kgwBH/JkM25EjtO1yz\nhsLAivmAruk/SUO7c1RP0fVF+qW3pxHOyztxLALOmeJ3D1JbSubqKf377Zz17O3b\nq9yHDdrNjnKtxhAX2n7ytjJs+EQC9t4mf1kB761RpvTBqFnBhCWHHocLUA4jcW9v\ncnmu86IIrwO2aKpPv4vCIQKBgHU9gY3qOazRSOmSlJ+hdmZn+2G7pBTvHsQNTIPl\ncCrpqNHl3crO4GnKHkT9vVVjuiOAIKU2QNJFwzu4Og8Y8LvhizpTjoHxm9x3iV72\nUDELcJ+YrqyJCTe2flUcy96o7Pbn50GXnwgtYD6WAW6IUszyn2ITgYIhu4wzZEt6\ns6O7AoGAPTKbRA87L34LMlXyUBJma+etMARIP1zu8bXJ7hSJeMcog8zaLczN7ruT\npGAaLxggvtvuncMuTrG+cdmsR9SafSFKRS92NCxhOUonQ+NP6mLskIGzJZoQ5JvQ\nqGzRVIDGbNkrVHM0IsAtHRpC0rYrtZY+9OwiraGcsqUMLwwQdCA=\n-----END RSA PRIVATE KEY-----`\n\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := os.Chdir(td); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() {\n\t\tos.Chdir(wd)\n\t}()\n\n\terr = os.WriteFile(\"validrsa1.key\", []byte(validrsa1), 0600)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tkeys, err := cosign.ImportKeyPair(\"validrsa1.key\", passFunc)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tprivKeyPath := filepath.Join(td, \"import-cosign.key\")\n\tif err := os.WriteFile(privKeyPath, keys.PrivateBytes, 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpubKeyPath := filepath.Join(td, \"import-cosign.pub\")\n\tif err := os.WriteFile(pubKeyPath, keys.PublicBytes, 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn keys, privKeyPath, pubKeyPath\n\n}\n\nfunc TestUploadDownload(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\tctx := context.Background()\n\n\ttestCases := map[string]struct {\n\t\tsignature     string\n\t\tsignatureType attach.SignatureArgType\n\t\texpectedErr   bool\n\t}{\n\t\t\"stdin containing signature\": {\n\t\t\tsignature:     \"testsignatureraw\",\n\t\t\tsignatureType: attach.StdinSignature,\n\t\t\texpectedErr:   false,\n\t\t},\n\t\t\"file containing signature\": {\n\t\t\tsignature:     \"testsignaturefile\",\n\t\t\tsignatureType: attach.FileSignature,\n\t\t\texpectedErr:   false,\n\t\t},\n\t\t\"raw signature as argument\": {\n\t\t\tsignature:     \"testsignatureraw\",\n\t\t\tsignatureType: attach.RawSignature,\n\t\t\texpectedErr:   true,\n\t\t},\n\t\t\"empty signature as argument\": {\n\t\t\tsignature:     \"\",\n\t\t\tsignatureType: attach.RawSignature,\n\t\t\texpectedErr:   true,\n\t\t},\n\t}\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\tfor testName, testCase := range testCases {\n\t\tt.Run(testName, func(t *testing.T) {\n\t\t\tref, _, cleanup := mkimage(t, imgName)\n\t\t\tpayload := \"testpayload\"\n\t\t\tpayloadPath := mkfile(payload, td, t)\n\t\t\tsignature := base64.StdEncoding.EncodeToString([]byte(testCase.signature))\n\t\t\trestoreStdin := func() {}\n\n\t\t\tvar sigRef string\n\t\t\tif testCase.signatureType == attach.FileSignature {\n\t\t\t\tsigRef = mkfile(signature, td, t)\n\t\t\t} else if testCase.signatureType == attach.StdinSignature {\n\t\t\t\tsigRef = \"-\"\n\t\t\t\trestoreStdin = mockStdin(signature, td, t)\n\t\t\t} else {\n\t\t\t\tsigRef = signature\n\t\t\t}\n\t\t\t// Upload it!\n\t\t\terr := attach.SignatureCmd(ctx, options.RegistryOptions{}, sigRef, payloadPath, \"\", \"\", \"\", \"\", imgName)\n\t\t\tif testCase.expectedErr {\n\t\t\t\tmustErr(err, t)\n\t\t\t} else {\n\t\t\t\tmust(err, t)\n\t\t\t}\n\t\t\trestoreStdin()\n\n\t\t\t// Now download it!\n\t\t\tse, err := ociremote.SignedEntity(ref, ociremote.WithRemoteOptions(registryClientOpts(ctx)...))\n\t\t\tmust(err, t)\n\t\t\tsigs, err := se.Signatures()\n\t\t\tmust(err, t)\n\t\t\tsignatures, err := sigs.Get()\n\t\t\tmust(err, t)\n\n\t\t\tif testCase.expectedErr {\n\t\t\t\tif len(signatures) != 0 {\n\t\t\t\t\tt.Fatalf(\"unexpected signatures %d, wanted 0\", len(signatures))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif len(signatures) != 1 {\n\t\t\t\t\tt.Fatalf(\"unexpected signatures %d, wanted 1\", len(signatures))\n\t\t\t\t}\n\n\t\t\t\tif b64sig, err := signatures[0].Base64Signature(); err != nil {\n\t\t\t\t\tt.Fatalf(\"Base64Signature() = %v\", err)\n\t\t\t\t} else if diff := cmp.Diff(b64sig, signature); diff != \"\" {\n\t\t\t\t\tt.Error(diff)\n\t\t\t\t}\n\n\t\t\t\tif p, err := signatures[0].Payload(); err != nil {\n\t\t\t\t\tt.Fatalf(\"Payload() = %v\", err)\n\t\t\t\t} else if diff := cmp.Diff(p, []byte(payload)); diff != \"\" {\n\t\t\t\t\tt.Error(diff)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Now delete it!\n\t\t\tcleanup()\n\t\t})\n\t}\n}\n\nfunc TestSaveLoad(t *testing.T) {\n\ttests := []struct {\n\t\tdescription     string\n\t\tgetSignedEntity func(t *testing.T, n string) (name.Reference, *remote.Descriptor, func())\n\t}{\n\t\t{\n\t\t\tdescription:     \"save and load an image\",\n\t\t\tgetSignedEntity: mkimage,\n\t\t},\n\t\t{\n\t\t\tdescription:     \"save and load an image index\",\n\t\t\tgetSignedEntity: mkimageindex,\n\t\t},\n\t}\n\tfor i, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\trepo, stop := reg(t)\n\t\t\tdefer stop()\n\t\t\tkeysDir := t.TempDir()\n\n\t\t\timgName := path.Join(repo, fmt.Sprintf(\"save-load-%d\", i))\n\n\t\t\t_, _, cleanup := test.getSignedEntity(t, imgName)\n\t\t\tdefer cleanup()\n\n\t\t\t_, privKeyPath, pubKeyPath := keypair(t, keysDir)\n\n\t\t\tctx := context.Background()\n\t\t\t// Now sign the image and verify it\n\t\t\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\t\t\tso := options.SignOptions{\n\t\t\t\tUpload: true,\n\t\t\t}\n\t\t\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\t\t\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t\t\t// save the image to a temp dir\n\t\t\timageDir := t.TempDir()\n\t\t\tmust(cli.SaveCmd(ctx, options.SaveOptions{Directory: imageDir}, imgName), t)\n\n\t\t\t// verify the local image using a local key\n\t\t\tmust(verifyLocal(pubKeyPath, imageDir, true, nil, \"\"), t)\n\n\t\t\t// load the image from the temp dir into a new image and verify the new image\n\t\t\timgName2 := path.Join(repo, fmt.Sprintf(\"save-load-%d-2\", i))\n\t\t\tmust(cli.LoadCmd(ctx, options.LoadOptions{Directory: imageDir}, imgName2), t)\n\t\t\tmust(verify(pubKeyPath, imgName2, true, nil, \"\"), t)\n\t\t})\n\t}\n}\n\nfunc TestSaveLoadAttestation(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"save-load\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tctx := context.Background()\n\t// Now sign the image and verify it\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tso := options.SignOptions{\n\t\tUpload: true,\n\t}\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// now, append an attestation to the image\n\tslsaAttestation := `{ \"buildType\": \"x\", \"builder\": { \"id\": \"2\" }, \"recipe\": {} }`\n\tslsaAttestationPath := filepath.Join(td, \"attestation.slsa.json\")\n\tif err := os.WriteFile(slsaAttestationPath, []byte(slsaAttestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Now attest the image\n\tko = options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tattestCommand := attest.AttestCommand{\n\t\tKeyOpts:       ko,\n\t\tPredicatePath: slsaAttestationPath,\n\t\tPredicateType: \"slsaprovenance\",\n\t\tTimeout:       30 * time.Second,\n\t}\n\tmust(attestCommand.Exec(ctx, imgName), t)\n\n\t// save the image to a temp dir\n\timageDir := t.TempDir()\n\tmust(cli.SaveCmd(ctx, options.SaveOptions{Directory: imageDir}, imgName), t)\n\n\t// load the image from the temp dir into a new image and verify the new image\n\timgName2 := path.Join(repo, \"save-load-2\")\n\tmust(cli.LoadCmd(ctx, options.LoadOptions{Directory: imageDir}, imgName2), t)\n\tmust(verify(pubKeyPath, imgName2, true, nil, \"\"), t)\n\t// Use cue to verify attestation on the new image\n\tpolicyPath := filepath.Join(td, \"policy.cue\")\n\tverifyAttestation := cliverify.VerifyAttestationCommand{\n\t\tKeyRef:     pubKeyPath,\n\t\tIgnoreTlog: true,\n\t\tMaxWorkers: 10,\n\t}\n\tverifyAttestation.PredicateType = \"slsaprovenance\"\n\tverifyAttestation.Policies = []string{policyPath}\n\t// Success case (remote)\n\tcuePolicy := `predicate: builder: id: \"2\"`\n\tif err := os.WriteFile(policyPath, []byte(cuePolicy), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tmust(verifyAttestation.Exec(ctx, []string{imgName2}), t)\n\t// Success case (local)\n\tverifyAttestation.LocalImage = true\n\tmust(verifyAttestation.Exec(ctx, []string{imageDir}), t)\n}\n\nfunc TestAttachSBOM(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\tctx := context.Background()\n\n\timgName := path.Join(repo, \"sbom-image\")\n\timg, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\tout := bytes.Buffer{}\n\n\t_, errPl := download.SBOMCmd(ctx, options.RegistryOptions{}, options.SBOMDownloadOptions{Platform: \"darwin/amd64\"}, img.Name(), &out)\n\tif errPl == nil {\n\t\tt.Fatalf(\"Expected error when passing Platform to single arch image\")\n\t}\n\t_, err := download.SBOMCmd(ctx, options.RegistryOptions{}, options.SBOMDownloadOptions{}, img.Name(), &out)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error\")\n\t}\n\tt.Log(out.String())\n\tout.Reset()\n\n\t// Upload it!\n\tmust(attach.SBOMCmd(ctx, options.RegistryOptions{}, options.RegistryExperimentalOptions{}, \"./testdata/bom-go-mod.spdx\", \"spdx\", imgName), t)\n\n\tsboms, err := download.SBOMCmd(ctx, options.RegistryOptions{}, options.SBOMDownloadOptions{}, imgName, &out)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Log(out.String())\n\tif len(sboms) != 1 {\n\t\tt.Fatalf(\"Expected one sbom, got %d\", len(sboms))\n\t}\n\twant, err := os.ReadFile(\"./testdata/bom-go-mod.spdx\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif diff := cmp.Diff(string(want), sboms[0]); diff != \"\" {\n\t\tt.Errorf(\"diff: %s\", diff)\n\t}\n\n\t// Generate key pairs to sign the sbom\n\ttd1 := t.TempDir()\n\ttd2 := t.TempDir()\n\t_, privKeyPath1, pubKeyPath1 := keypair(t, td1)\n\t_, _, pubKeyPath2 := keypair(t, td2)\n\n\t// Verify should fail on a bad input\n\tmustErr(verify(pubKeyPath1, imgName, true, nil, \"sbom\"), t)\n\tmustErr(verify(pubKeyPath2, imgName, true, nil, \"sbom\"), t)\n\n\t// Now sign the sbom with one key\n\tko1 := options.KeyOpts{KeyRef: privKeyPath1, PassFunc: passFunc}\n\tso := options.SignOptions{\n\t\tUpload:     true,\n\t\tAttachment: \"sbom\",\n\t}\n\tmust(sign.SignCmd(ro, ko1, so, []string{imgName}), t)\n\n\t// Now verify should work with that one, but not the other\n\tmust(verify(pubKeyPath1, imgName, true, nil, \"sbom\"), t)\n\tmustErr(verify(pubKeyPath2, imgName, true, nil, \"sbom\"), t)\n}\n\nfunc TestAttachSBOM_bom_flag(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\tctx := context.Background()\n\tbomData, err := os.ReadFile(\"./testdata/bom-go-mod.spdx\")\n\tmust(err, t)\n\n\ttestCases := map[string]struct {\n\t\tbom         string\n\t\tbomType     attach.SignatureArgType\n\t\texpectedErr bool\n\t}{\n\t\t\"stdin containing bom\": {\n\t\t\tbom:         string(bomData),\n\t\t\tbomType:     attach.StdinSignature,\n\t\t\texpectedErr: false,\n\t\t},\n\t\t\"file containing bom\": {\n\t\t\tbom:         string(bomData),\n\t\t\tbomType:     attach.FileSignature,\n\t\t\texpectedErr: false,\n\t\t},\n\t\t\"raw bom as argument\": {\n\t\t\tbom:         string(bomData),\n\t\t\tbomType:     attach.RawSignature,\n\t\t\texpectedErr: true,\n\t\t},\n\t\t\"empty bom as argument\": {\n\t\t\tbom:         \"\",\n\t\t\tbomType:     attach.RawSignature,\n\t\t\texpectedErr: true,\n\t\t},\n\t}\n\n\tfor testName, testCase := range testCases {\n\t\tt.Run(testName, func(t *testing.T) {\n\t\t\timgName := path.Join(repo, \"sbom-image\")\n\t\t\timg, _, cleanup := mkimage(t, imgName)\n\t\t\tvar sbomRef string\n\t\t\trestoreStdin := func() {}\n\t\t\tif testCase.bomType == attach.FileSignature {\n\t\t\t\tsbomRef = mkfile(testCase.bom, td, t)\n\t\t\t} else if testCase.bomType == attach.StdinSignature {\n\t\t\t\tsbomRef = \"-\"\n\t\t\t\trestoreStdin = mockStdin(testCase.bom, td, t)\n\t\t\t} else {\n\t\t\t\tsbomRef = testCase.bom\n\t\t\t}\n\n\t\t\tout := bytes.Buffer{}\n\t\t\t_, errPl := download.SBOMCmd(ctx, options.RegistryOptions{}, options.SBOMDownloadOptions{Platform: \"darwin/amd64\"}, img.Name(), &out)\n\t\t\tif errPl == nil {\n\t\t\t\tt.Fatalf(\"Expected error when passing Platform to single arch image\")\n\t\t\t}\n\t\t\t_, err := download.SBOMCmd(ctx, options.RegistryOptions{}, options.SBOMDownloadOptions{}, img.Name(), &out)\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(\"Expected error\")\n\t\t\t}\n\t\t\tt.Log(out.String())\n\t\t\tout.Reset()\n\n\t\t\t// Upload it!\n\t\t\terr = attach.SBOMCmd(ctx, options.RegistryOptions{}, options.RegistryExperimentalOptions{}, sbomRef, \"spdx\", imgName)\n\t\t\trestoreStdin()\n\n\t\t\tif testCase.expectedErr {\n\t\t\t\tmustErr(err, t)\n\t\t\t} else {\n\t\t\t\tsboms, err := download.SBOMCmd(ctx, options.RegistryOptions{}, options.SBOMDownloadOptions{}, imgName, &out)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tt.Log(out.String())\n\t\t\t\tif len(sboms) != 1 {\n\t\t\t\t\tt.Fatalf(\"Expected one sbom, got %d\", len(sboms))\n\t\t\t\t}\n\t\t\t\twant, err := os.ReadFile(\"./testdata/bom-go-mod.spdx\")\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif diff := cmp.Diff(string(want), sboms[0]); diff != \"\" {\n\t\t\t\t\tt.Errorf(\"diff: %s\", diff)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcleanup()\n\t\t})\n\t}\n}\n\nfunc setenv(t *testing.T, k, v string) func() {\n\tif err := os.Setenv(k, v); err != nil {\n\t\tt.Fatalf(\"error setting env: %v\", err)\n\t}\n\treturn func() {\n\t\tos.Unsetenv(k)\n\t}\n}\n\nfunc TestTlog(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\t// Verify should fail at first\n\tmustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// Now sign the image without the tlog\n\tko := options.KeyOpts{\n\t\tKeyRef:   privKeyPath,\n\t\tPassFunc: passFunc,\n\t\tRekorURL: rekorURL,\n\t}\n\tso := options.SignOptions{\n\t\tUpload: true,\n\t}\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\n\t// Now verify should work!\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// TODO: priyawadhwa@ to figure out how to add an entry to the tlog without using keyless signing\n\t// We could add an --upload-tlog flag, but it's a bit weird since we have a --no-upload-tlog flag too right now.\n\n\t// Verify shouldn't work since we haven't put anything in it yet.\n\t// mustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// // Sign again with the tlog env var on\n\t// must(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\t// // And now verify works!\n\t// must(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n}\n\nfunc TestNoTlog(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\t// Verify should fail at first\n\tmustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// Now sign the image without the tlog\n\tko := options.KeyOpts{\n\t\tKeyRef:   privKeyPath,\n\t\tPassFunc: passFunc,\n\t\tRekorURL: rekorURL,\n\t}\n\tso := options.SignOptions{\n\t\tUpload: true,\n\t}\n\tmust(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\n\t// Now verify should work!\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// TODO: Uncomment once we have a way to tell `cosign verify` that we want to verify with a public key\n\t// and a tlog entry\n\n\t// // Sign again and make sure tlog upload is set to false\n\t// so = options.SignOptions{\n\t// \tTlogUpload: false,\n\t// }\n\t// must(sign.SignCmd(ro, ko, so, []string{imgName}), t)\n\t// // And verify it still fails.\n\t// mustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n}\n\nfunc TestGetPublicKeyCustomOut(t *testing.T) {\n\ttd := t.TempDir()\n\tkeys, privKeyPath, _ := keypair(t, td)\n\tctx := context.Background()\n\n\toutFile := \"output.pub\"\n\toutPath := filepath.Join(td, outFile)\n\toutWriter, err := os.OpenFile(outPath, os.O_WRONLY|os.O_CREATE, 0600)\n\tmust(err, t)\n\n\tpk := publickey.Pkopts{\n\t\tKeyRef: privKeyPath,\n\t}\n\tmust(publickey.GetPublicKey(ctx, pk, publickey.NamedWriter{Name: outPath, Writer: outWriter}, passFunc), t)\n\n\toutput, err := os.ReadFile(outPath)\n\tmust(err, t)\n\tequals(keys.PublicBytes, output, t)\n}\n\nfunc mockStdin(contents, td string, t *testing.T) func() {\n\torigin := os.Stdin\n\n\tp := mkfile(contents, td, t)\n\tf, err := os.Open(p)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tos.Stdin = f\n\n\treturn func() { os.Stdin = origin }\n}\n\nfunc mkfile(contents, td string, t *testing.T) string {\n\tf, err := os.CreateTemp(td, \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer f.Close()\n\tif _, err := f.Write([]byte(contents)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn f.Name()\n}\n\nfunc mkimage(t *testing.T, n string) (name.Reference, *remote.Descriptor, func()) {\n\tref, err := name.ParseReference(n, name.WeakValidation)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\timg, err := random.Image(512, 5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tregClientOpts := registryClientOpts(context.Background())\n\n\tif err := remote.Write(ref, img, regClientOpts...); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tremoteImage, err := remote.Get(ref, regClientOpts...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcleanup := func() {\n\t\t_ = remote.Delete(ref, regClientOpts...)\n\t\tref, _ := ociremote.SignatureTag(ref.Context().Digest(remoteImage.Descriptor.Digest.String()), ociremote.WithRemoteOptions(regClientOpts...))\n\t\t_ = remote.Delete(ref, regClientOpts...)\n\t}\n\treturn ref, remoteImage, cleanup\n}\n\nfunc mkimageindex(t *testing.T, n string) (name.Reference, *remote.Descriptor, func()) {\n\tref, err := name.ParseReference(n, name.WeakValidation)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tii, err := random.Index(512, 5, 4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tregClientOpts := registryClientOpts(context.Background())\n\n\tif err := remote.WriteIndex(ref, ii, regClientOpts...); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tremoteIndex, err := remote.Get(ref, regClientOpts...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcleanup := func() {\n\t\t_ = remote.Delete(ref, regClientOpts...)\n\t\tref, _ := ociremote.SignatureTag(ref.Context().Digest(remoteIndex.Descriptor.Digest.String()), ociremote.WithRemoteOptions(regClientOpts...))\n\t\t_ = remote.Delete(ref, regClientOpts...)\n\t}\n\treturn ref, remoteIndex, cleanup\n}\n\nfunc must(err error, t *testing.T) {\n\tt.Helper()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc mustErr(err error, t *testing.T) {\n\tt.Helper()\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n}\n\nfunc equals(v1, v2 interface{}, t *testing.T) {\n\tif diff := cmp.Diff(v1, v2); diff != \"\" {\n\t\tt.Error(diff)\n\t}\n}\n\nfunc reg(t *testing.T) (string, func()) {\n\trepo := os.Getenv(\"COSIGN_TEST_REPO\")\n\tif repo != \"\" {\n\t\treturn repo, func() {}\n\t}\n\n\tt.Log(\"COSIGN_TEST_REPO unset, using fake registry\")\n\tr := httptest.NewServer(registry.New())\n\tu, err := url.Parse(r.URL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn u.Host, r.Close\n}\n\nfunc registryClientOpts(ctx context.Context) []remote.Option {\n\treturn []remote.Option{\n\t\tremote.WithAuthFromKeychain(authn.DefaultKeychain),\n\t\tremote.WithContext(ctx),\n\t}\n}\n\n// If a signature has a bundle, but *not for that signature*, cosign verification should fail.\n// This test is pretty long, so here are the basic points:\n//  1. Sign image1 with a keypair, store entry in rekor\n//  2. Sign image2 with keypair, DO NOT store entry in rekor\n//  3. Take the bundle from image1 and store it on the signature in image2\n//  4. Verification of image2 should now fail, since the bundle is for a different signature\nfunc TestInvalidBundle(t *testing.T) {\n\tregName, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timg1 := path.Join(regName, \"cosign-e2e\")\n\n\timgRef, _, cleanup := mkimage(t, img1)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tctx := context.Background()\n\n\t// Sign image1 and store the entry in rekor\n\t// (we're just using it for its bundle)\n\tremoteOpts := ociremote.WithRemoteOptions(registryClientOpts(ctx)...)\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc, RekorURL: rekorURL}\n\tso := options.SignOptions{\n\t\tUpload:           true,\n\t\tTlogUpload:       true,\n\t\tSkipConfirmation: true,\n\t}\n\tmust(sign.SignCmd(ro, ko, so, []string{img1}), t)\n\t// verify image1\n\tmust(verify(pubKeyPath, img1, true, nil, \"\"), t)\n\t// extract the bundle from image1\n\tsi, err := ociremote.SignedImage(imgRef, remoteOpts)\n\tmust(err, t)\n\timgSigs, err := si.Signatures()\n\tmust(err, t)\n\tsigs, err := imgSigs.Get()\n\tmust(err, t)\n\tif l := len(sigs); l != 1 {\n\t\tt.Error(\"expected one signature\")\n\t}\n\tbund, err := sigs[0].Bundle()\n\tmust(err, t)\n\tif bund == nil {\n\t\tt.Fail()\n\t}\n\n\t// Now, we move on to image2\n\t// Sign image2 and DO NOT store the entry in rekor\n\tdefer setenv(t, env.VariableExperimental.String(), \"0\")()\n\timg2 := path.Join(regName, \"unrelated\")\n\timgRef2, _, cleanup := mkimage(t, img2)\n\tdefer cleanup()\n\tso = options.SignOptions{\n\t\tUpload:     true,\n\t\tTlogUpload: false,\n\t}\n\tmust(sign.SignCmd(ro, ko, so, []string{img2}), t)\n\tmust(verify(pubKeyPath, img2, true, nil, \"\"), t)\n\n\tsi2, err := ociremote.SignedEntity(imgRef2, remoteOpts)\n\tmust(err, t)\n\tsigs2, err := si2.Signatures()\n\tmust(err, t)\n\tgottenSigs2, err := sigs2.Get()\n\tmust(err, t)\n\tif len(gottenSigs2) != 1 {\n\t\tt.Fatal(\"there should be one signature\")\n\t}\n\tsigsTag, err := ociremote.SignatureTag(imgRef2)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// At this point, we would mutate the signature to add the bundle annotation\n\t// since we don't have a function for it at the moment, mock this by deleting the signature\n\t// and pushing a new signature with the additional bundle annotation\n\tif err := remote.Delete(sigsTag); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tmustErr(verify(pubKeyPath, img2, true, nil, \"\"), t)\n\n\tnewSig, err := mutate.Signature(gottenSigs2[0], mutate.WithBundle(bund))\n\tmust(err, t)\n\tsi2, err = ociremote.SignedEntity(imgRef2, remoteOpts)\n\tmust(err, t)\n\tnewImage, err := mutate.AttachSignatureToEntity(si2, newSig)\n\tmust(err, t)\n\tif err := ociremote.WriteSignatures(sigsTag.Repository, newImage); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// veriyfing image2 now should fail\n\tcmd := cliverify.VerifyCommand{\n\t\tKeyRef:        pubKeyPath,\n\t\tRekorURL:      rekorURL,\n\t\tCheckClaims:   true,\n\t\tHashAlgorithm: crypto.SHA256,\n\t\tMaxWorkers:    10,\n\t}\n\targs := []string{img2}\n\tmustErr(cmd.Exec(context.Background(), args), t)\n}\n\nfunc TestAttestBlobSignVerify(t *testing.T) {\n\tblob := \"someblob\"\n\tpredicate := `{ \"buildType\": \"x\", \"builder\": { \"id\": \"2\" }, \"recipe\": {} }`\n\tpredicateType := \"slsaprovenance\"\n\n\ttd1 := t.TempDir()\n\tt.Cleanup(func() {\n\t\tos.RemoveAll(td1)\n\t})\n\n\tbp := filepath.Join(td1, blob)\n\tif err := os.WriteFile(bp, []byte(blob), 0644); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tanotherBlob := filepath.Join(td1, \"another-blob\")\n\tif err := os.WriteFile(anotherBlob, []byte(\"another-blob\"), 0644); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpredicatePath := filepath.Join(td1, \"predicate\")\n\tif err := os.WriteFile(predicatePath, []byte(predicate), 0644); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\toutputSignature := filepath.Join(td1, \"signature\")\n\n\t_, privKeyPath1, pubKeyPath1 := keypair(t, td1)\n\n\tctx := context.Background()\n\tko := options.KeyOpts{\n\t\tKeyRef: pubKeyPath1,\n\t}\n\tblobVerifyAttestationCmd := cliverify.VerifyBlobAttestationCommand{\n\t\tKeyOpts:       ko,\n\t\tSignaturePath: outputSignature,\n\t\tPredicateType: predicateType,\n\t\tIgnoreTlog:    true,\n\t\tCheckClaims:   true,\n\t}\n\t// Verify should fail on a bad input\n\tmustErr(blobVerifyAttestationCmd.Exec(ctx, bp), t)\n\n\t// Now attest the blob with the private key\n\tko = options.KeyOpts{\n\t\tKeyRef:   privKeyPath1,\n\t\tPassFunc: passFunc,\n\t}\n\tattestBlobCmd := attest.AttestBlobCommand{\n\t\tKeyOpts:         ko,\n\t\tPredicatePath:   predicatePath,\n\t\tPredicateType:   predicateType,\n\t\tOutputSignature: outputSignature,\n\t}\n\tmust(attestBlobCmd.Exec(ctx, bp), t)\n\n\t// Now verify should work\n\tmust(blobVerifyAttestationCmd.Exec(ctx, bp), t)\n\n\t// Make sure we fail with the wrong predicate type\n\tblobVerifyAttestationCmd.PredicateType = \"custom\"\n\tmustErr(blobVerifyAttestationCmd.Exec(ctx, bp), t)\n\n\t// Make sure we fail with the wrong blob (set the predicate type back)\n\tblobVerifyAttestationCmd.PredicateType = predicateType\n\tmustErr(blobVerifyAttestationCmd.Exec(ctx, anotherBlob), t)\n}\n\nfunc TestOffline(t *testing.T) {\n\tregName, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timg1 := path.Join(regName, \"cosign-e2e\")\n\n\timgRef, _, cleanup := mkimage(t, img1)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tctx := context.Background()\n\n\t// Sign image1 and store the entry in rekor\n\tko := options.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc, RekorURL: rekorURL}\n\tso := options.SignOptions{\n\t\tUpload:           true,\n\t\tTlogUpload:       true,\n\t\tSkipConfirmation: true,\n\t}\n\tmust(sign.SignCmd(ro, ko, so, []string{img1}), t)\n\t// verify image1 online and offline\n\tmust(verify(pubKeyPath, img1, true, nil, \"\"), t)\n\tverifyCmd := &cliverify.VerifyCommand{\n\t\tKeyRef:      pubKeyPath,\n\t\tOffline:     true,\n\t\tCheckClaims: true,\n\t\tMaxWorkers:  10,\n\t}\n\tmust(verifyCmd.Exec(ctx, []string{img1}), t)\n\n\t// Get signatures\n\tsi, err := ociremote.SignedEntity(imgRef)\n\tmust(err, t)\n\tsigs, err := si.Signatures()\n\tmust(err, t)\n\tgottenSigs, err := sigs.Get()\n\tmust(err, t)\n\n\tfakeBundle := &bundle.RekorBundle{\n\t\tSignedEntryTimestamp: []byte(\"\"),\n\t\tPayload: bundle.RekorPayload{\n\t\t\tBody: \"\",\n\t\t},\n\t}\n\tnewSig, err := mutate.Signature(gottenSigs[0], mutate.WithBundle(fakeBundle))\n\tmust(err, t)\n\n\tsigsTag, err := ociremote.SignatureTag(imgRef)\n\tif err := remote.Delete(sigsTag); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tsi, err = ociremote.SignedEntity(imgRef)\n\tmust(err, t)\n\tnewImage, err := mutate.AttachSignatureToEntity(si, newSig)\n\tmust(err, t)\n\n\tmustErr(verify(pubKeyPath, img1, true, nil, \"\"), t)\n\tif err := ociremote.WriteSignatures(sigsTag.Repository, newImage); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Confirm offline verification fails\n\tmustErr(verifyCmd.Exec(ctx, []string{img1}), t)\n}\n"], "filenames": ["pkg/cosign/fetch.go", "test/e2e_test.go"], "buggy_code_start_loc": [36, 663], "buggy_code_end_loc": [146, 1253], "fixing_code_start_loc": [37, 664], "fixing_code_end_loc": [156, 1368], "type": "CWE-835", "message": "Cosign is a sigstore signing tool for OCI containers. Cosign is susceptible to a denial of service by an attacker controlled registry. An attacker who controls a remote registry can return a high number of attestations and/or signatures to Cosign and cause Cosign to enter a long loop resulting in an endless data attack. The root cause is that Cosign loops through all attestations fetched from the remote registry in pkg/cosign.FetchAttestations. The attacker needs to compromise the registry or make a request to a registry they control. When doing so, the attacker must return a high number of attestations in the response to Cosign. The result will be that the attacker can cause Cosign to go into a long or infinite loop that will prevent other users from verifying their data. In Kyvernos case, an attacker whose privileges are limited to making requests to the cluster can make a request with an image reference to their own registry, trigger the infinite loop and deny other users from completing their admission requests. Alternatively, the attacker can obtain control of the registry used by an organization and return a high number of attestations instead the expected number of attestations. The issue can be mitigated rather simply by setting a limit to the limit of attestations that Cosign will loop through. The limit does not need to be high to be within the vast majority of use cases and still prevent the endless data attack. This issue has been patched in version 2.2.1 and users are advised to upgrade.", "other": {"cve": {"id": "CVE-2023-46737", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-07T18:15:09.283", "lastModified": "2023-11-14T20:07:50.573", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cosign is a sigstore signing tool for OCI containers. Cosign is susceptible to a denial of service by an attacker controlled registry. An attacker who controls a remote registry can return a high number of attestations and/or signatures to Cosign and cause Cosign to enter a long loop resulting in an endless data attack. The root cause is that Cosign loops through all attestations fetched from the remote registry in pkg/cosign.FetchAttestations. The attacker needs to compromise the registry or make a request to a registry they control. When doing so, the attacker must return a high number of attestations in the response to Cosign. The result will be that the attacker can cause Cosign to go into a long or infinite loop that will prevent other users from verifying their data. In Kyvernos case, an attacker whose privileges are limited to making requests to the cluster can make a request with an image reference to their own registry, trigger the infinite loop and deny other users from completing their admission requests. Alternatively, the attacker can obtain control of the registry used by an organization and return a high number of attestations instead the expected number of attestations. The issue can be mitigated rather simply by setting a limit to the limit of attestations that Cosign will loop through. The limit does not need to be high to be within the vast majority of use cases and still prevent the endless data attack. This issue has been patched in version 2.2.1 and users are advised to upgrade."}, {"lang": "es", "value": "Cosign es una herramienta de firma de sigstore para contenedores OCI. Cosign es susceptible a una denegaci\u00f3n de servicio por parte de un registro controlado por un atacante. Un atacante que controla un registro remoto puede devolver una gran cantidad de certificaciones y/o firmas a Cosign y hacer que Cosign entre en un bucle largo que resulte en un ataque de datos interminable. La causa principal es que Cosign recorre todas las certificaciones obtenidas del registro remoto en pkg/cosign.FetchAttestations. El atacante necesita comprometer el registro o realizar una solicitud a un registro que controla. Al hacerlo, el atacante debe devolver una gran cantidad de certificaciones en la respuesta a Cosign. El resultado ser\u00e1 que el atacante puede hacer que Cosign entre en un bucle largo o infinito que impedir\u00e1 que otros usuarios verifiquen sus datos. En el caso de Kyvernos, un atacante cuyos privilegios se limitan a realizar solicitudes al cl\u00faster puede realizar una solicitud con una referencia de imagen a su propio registro, desencadenar el bucle infinito y negar que otros usuarios completen sus solicitudes de admisi\u00f3n. Alternativamente, el atacante puede obtener el control del registro utilizado por una organizaci\u00f3n y devolver una gran cantidad de certificaciones en lugar de la cantidad esperada de certificaciones. El problema se puede mitigar simplemente estableciendo un l\u00edmite al l\u00edmite de certificaciones que recorrer\u00e1 Cosign. No es necesario que el l\u00edmite sea alto para estar dentro de la gran mayor\u00eda de los casos de uso y aun as\u00ed evitar ataques interminables a los datos. Este problema se solucion\u00f3 en la versi\u00f3n 2.2.1 y se recomienda a los usuarios que actualicen."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.1, "baseSeverity": "LOW"}, "exploitabilityScore": 1.6, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sigstore:cosign:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.2.1", "matchCriteriaId": "8000584C-3846-4095-9DEE-59F9AE915CF7"}]}]}], "references": [{"url": "https://github.com/sigstore/cosign/commit/8ac891ff0e29ddc67965423bee8f826219c6eb0f", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/sigstore/cosign/security/advisories/GHSA-vfp6-jrw2-99g9", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/sigstore/cosign/commit/8ac891ff0e29ddc67965423bee8f826219c6eb0f"}}