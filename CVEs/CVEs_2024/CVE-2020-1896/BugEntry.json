{"buggy_code": ["/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include \"JSLibInternal.h\"\n\n#include \"hermes/Support/Base64vlq.h\"\n#include \"hermes/VM/Callable.h\"\n#include \"hermes/VM/JSArray.h\"\n#include \"hermes/VM/JSArrayBuffer.h\"\n#include \"hermes/VM/JSLib.h\"\n#include \"hermes/VM/Operations.h\"\n#include \"hermes/VM/StackFrame-inline.h\"\n#include \"hermes/VM/StringView.h\"\n\n#include <random>\n\nnamespace hermes {\nnamespace vm {\n\n/// Set the parent of an object failing silently on any error.\nCallResult<HermesValue>\nsilentObjectSetPrototypeOf(void *, Runtime *runtime, NativeArgs args) {\n  JSObject *O = dyn_vmcast<JSObject>(args.getArg(0));\n  if (!O)\n    return HermesValue::encodeUndefinedValue();\n\n  JSObject *parent;\n  HermesValue V = args.getArg(1);\n  if (V.isNull())\n    parent = nullptr;\n  else if (V.isObject())\n    parent = vmcast<JSObject>(V);\n  else\n    return HermesValue::encodeUndefinedValue();\n\n  (void)JSObject::setParent(O, runtime, parent);\n\n  // Ignore exceptions.\n  runtime->clearThrownValue();\n\n  return HermesValue::encodeUndefinedValue();\n}\n\n/// ES6.0 12.2.9.3 Runtime Semantics: GetTemplateObject ( templateLiteral )\n/// Given a template literal, return a template object that looks like this:\n/// [cookedString0, cookedString1, ..., raw: [rawString0, rawString1]].\n/// This object is frozen, as well as the 'raw' object nested inside.\n/// We only pass the parts from the template literal that are needed to\n/// construct this object. That is, the raw strings and cooked strings.\n/// Arguments: \\p templateObjID is the unique id associated with the template\n/// object. \\p dup is a boolean, when it is true, cooked strings are the same as\n/// raw strings. Then raw strings are passed. Finally cooked strings are\n/// optionally passed if \\p dup is true.\nCallResult<HermesValue>\nhermesBuiltinGetTemplateObject(void *, Runtime *runtime, NativeArgs args) {\n  if (LLVM_UNLIKELY(args.getArgCount() < 3)) {\n    return runtime->raiseTypeError(\"At least three arguments expected\");\n  }\n  if (LLVM_UNLIKELY(!args.getArg(0).isNumber())) {\n    return runtime->raiseTypeError(\"First argument should be a number\");\n  }\n  if (LLVM_UNLIKELY(!args.getArg(1).isBool())) {\n    return runtime->raiseTypeError(\"Second argument should be a bool\");\n  }\n\n  GCScope gcScope{runtime};\n\n  // Try finding the template object in the template object cache.\n  uint32_t templateObjID = args.getArg(0).getNumberAs<uint32_t>();\n  auto savedCB = runtime->getStackFrames().begin()->getSavedCodeBlock();\n  if (LLVM_UNLIKELY(!savedCB)) {\n    return runtime->raiseTypeError(\"Cannot be called from native code\");\n  }\n  RuntimeModule *runtimeModule = savedCB->getRuntimeModule();\n  JSObject *cachedTemplateObj =\n      runtimeModule->findCachedTemplateObject(templateObjID);\n  if (cachedTemplateObj) {\n    return HermesValue::encodeObjectValue(cachedTemplateObj);\n  }\n\n  bool dup = args.getArg(1).getBool();\n  if (LLVM_UNLIKELY(!dup && args.getArgCount() % 2 == 1)) {\n    return runtime->raiseTypeError(\n        \"There must be the same number of raw and cooked strings.\");\n  }\n  uint32_t count = dup ? args.getArgCount() - 2 : args.getArgCount() / 2 - 1;\n\n  // Create template object and raw object.\n  auto arrRes = JSArray::create(runtime, count, 0);\n  if (LLVM_UNLIKELY(arrRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto rawObj = runtime->makeHandle<JSObject>(arrRes->getHermesValue());\n  auto arrRes2 = JSArray::create(runtime, count, 0);\n  if (LLVM_UNLIKELY(arrRes2 == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto templateObj = runtime->makeHandle<JSObject>(arrRes2->getHermesValue());\n\n  // Set cooked and raw strings as elements in template object and raw object,\n  // respectively.\n  DefinePropertyFlags dpf = DefinePropertyFlags::getDefaultNewPropertyFlags();\n  dpf.writable = 0;\n  dpf.configurable = 0;\n  MutableHandle<> idx{runtime};\n  MutableHandle<> rawValue{runtime};\n  MutableHandle<> cookedValue{runtime};\n  uint32_t cookedBegin = dup ? 2 : 2 + count;\n  auto marker = gcScope.createMarker();\n  for (uint32_t i = 0; i < count; ++i) {\n    idx = HermesValue::encodeNumberValue(i);\n\n    cookedValue = args.getArg(cookedBegin + i);\n    auto putRes = JSObject::defineOwnComputedPrimitive(\n        templateObj, runtime, idx, dpf, cookedValue);\n    assert(\n        putRes != ExecutionStatus::EXCEPTION && *putRes &&\n        \"Failed to set cooked value to template object.\");\n\n    rawValue = args.getArg(2 + i);\n    putRes = JSObject::defineOwnComputedPrimitive(\n        rawObj, runtime, idx, dpf, rawValue);\n    assert(\n        putRes != ExecutionStatus::EXCEPTION && *putRes &&\n        \"Failed to set raw value to raw object.\");\n\n    gcScope.flushToMarker(marker);\n  }\n  // Make 'length' property on the raw object read-only.\n  DefinePropertyFlags readOnlyDPF{};\n  readOnlyDPF.setWritable = 1;\n  readOnlyDPF.setConfigurable = 1;\n  readOnlyDPF.writable = 0;\n  readOnlyDPF.configurable = 0;\n  auto readOnlyRes = JSObject::defineOwnProperty(\n      rawObj,\n      runtime,\n      Predefined::getSymbolID(Predefined::length),\n      readOnlyDPF,\n      Runtime::getUndefinedValue(),\n      PropOpFlags().plusThrowOnError());\n  if (LLVM_UNLIKELY(readOnlyRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (LLVM_UNLIKELY(!*readOnlyRes)) {\n    return runtime->raiseTypeError(\n        \"Failed to set 'length' property on the raw object read-only.\");\n  }\n  JSObject::preventExtensions(rawObj.get());\n\n  // Set raw object as a read-only non-enumerable property of the template\n  // object.\n  PropertyFlags constantPF{};\n  constantPF.writable = 0;\n  constantPF.configurable = 0;\n  constantPF.enumerable = 0;\n  auto putNewRes = JSObject::defineNewOwnProperty(\n      templateObj,\n      runtime,\n      Predefined::getSymbolID(Predefined::raw),\n      constantPF,\n      rawObj);\n  if (LLVM_UNLIKELY(putNewRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  // Make 'length' property on the template object read-only.\n  readOnlyRes = JSObject::defineOwnProperty(\n      templateObj,\n      runtime,\n      Predefined::getSymbolID(Predefined::length),\n      readOnlyDPF,\n      Runtime::getUndefinedValue(),\n      PropOpFlags().plusThrowOnError());\n  if (LLVM_UNLIKELY(readOnlyRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (LLVM_UNLIKELY(!*readOnlyRes)) {\n    return runtime->raiseTypeError(\n        \"Failed to set 'length' property on the raw object read-only.\");\n  }\n  JSObject::preventExtensions(templateObj.get());\n\n  // Cache the template object.\n  runtimeModule->cacheTemplateObject(templateObjID, templateObj);\n\n  return templateObj.getHermesValue();\n}\n\n/// If the first argument is not an object, throw a type error with the second\n/// argument as a message.\n///\n/// \\code\n///   HermesBuiltin.ensureObject = function(value, errorMessage) {...}\n/// \\endcode\nCallResult<HermesValue>\nhermesBuiltinEnsureObject(void *, Runtime *runtime, NativeArgs args) {\n  if (LLVM_LIKELY(args.getArg(0).isObject()))\n    return HermesValue::encodeUndefinedValue();\n\n  return runtime->raiseTypeError(args.getArgHandle(1));\n}\n\n/// Throw a type error with the argument as a message.\n///\n/// \\code\n///   HermesBuiltin.throwTypeError = function(errorMessage) {...}\n/// \\endcode\nCallResult<HermesValue>\nhermesBuiltinThrowTypeError(void *, Runtime *runtime, NativeArgs args) {\n  return runtime->raiseTypeError(args.getArgHandle(0));\n}\n\n/// Set the isDelegated flag on the GeneratorInnerFunction which calls\n/// this function.\n/// \\pre the caller must be an interpreted GeneratorInnerFunction\n/// \\return `undefined`\nCallResult<HermesValue>\nhermesBuiltinGeneratorSetDelegated(void *, Runtime *runtime, NativeArgs args) {\n  auto *gen = dyn_vmcast_or_null<GeneratorInnerFunction>(\n      runtime->getCurrentFrame().getPreviousFrame().getCalleeClosure());\n  if (!gen) {\n    return runtime->raiseTypeError(\n        \"generatorSetDelegated can only be called as part of yield*\");\n  }\n  gen->setIsDelegated(true);\n  return HermesValue::encodeUndefinedValue();\n}\n\nnamespace {\n\nCallResult<HermesValue> copyDataPropertiesSlowPath_RJS(\n    Runtime *runtime,\n    Handle<JSObject> target,\n    Handle<JSObject> from,\n    Handle<JSObject> excludedItems) {\n  assert(\n      from->isProxyObject() &&\n      \"copyDataPropertiesSlowPath_RJS is only for Proxy\");\n\n  // 5. Let keys be ? from.[[OwnPropertyKeys]]().\n  auto cr = JSProxy::getOwnPropertyKeys(\n      from,\n      runtime,\n      OwnKeysFlags()\n          .plusIncludeSymbols()\n          .plusIncludeNonSymbols()\n          .plusIncludeNonEnumerable());\n  if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto keys = *cr;\n\n  MutableHandle<> nextKeyHandle{runtime};\n  MutableHandle<> propValueHandle{runtime};\n  GCScopeMarkerRAII marker{runtime};\n  // 6. For each element nextKey of keys in List order, do\n  for (uint32_t nextKeyIdx = 0, endIdx = keys->getEndIndex();\n       nextKeyIdx < endIdx;\n       ++nextKeyIdx) {\n    marker.flush();\n    nextKeyHandle = keys->at(runtime, nextKeyIdx);\n    // b. For each element e of excludedItems in List order, do\n    //   i. If SameValue(e, nextKey) is true, then\n    //     1. Set excluded to true.\n    if (excludedItems) {\n      assert(\n          !excludedItems->isProxyObject() &&\n          \"internal excludedItems object is a proxy\");\n      ComputedPropertyDescriptor desc;\n      CallResult<bool> cr = JSObject::getOwnComputedPrimitiveDescriptor(\n          excludedItems,\n          runtime,\n          nextKeyHandle,\n          JSObject::IgnoreProxy::Yes,\n          desc);\n      if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      if (*cr)\n        continue;\n    }\n\n    //   i. Let desc be ? from.[[GetOwnProperty]](nextKey).\n    ComputedPropertyDescriptor desc;\n    CallResult<bool> crb =\n        JSProxy::getOwnProperty(from, runtime, nextKeyHandle, desc, nullptr);\n    if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n      return ExecutionStatus::EXCEPTION;\n    //   ii. If desc is not undefined and desc.[[Enumerable]] is true, then\n    if (*crb && desc.flags.enumerable) {\n      //     1. Let propValue be ? Get(from, nextKey).\n      CallResult<HermesValue> crv =\n          JSProxy::getComputed(from, runtime, nextKeyHandle, from);\n      if (LLVM_UNLIKELY(crv == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      propValueHandle = *crv;\n      //     2. Perform ! CreateDataProperty(target, nextKey, propValue).\n      crb = JSObject::defineOwnComputed(\n          target,\n          runtime,\n          nextKeyHandle,\n          DefinePropertyFlags::getDefaultNewPropertyFlags(),\n          propValueHandle);\n      if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      assert(\n          crb != ExecutionStatus::EXCEPTION && *crb &&\n          \"CreateDataProperty failed\");\n    }\n  }\n  return target.getHermesValue();\n}\n\n} // namespace\n\n/// \\code\n///   HermesBuiltin.copyDataProperties =\n///         function (target, source, excludedItems) {}\n/// \\endcode\n///\n/// Copy all enumerable own properties of object \\p source, that are not also\n/// properties of \\p excludedItems, into \\p target, which must be an object, and\n/// return \\p target. If \\p excludedItems is not specified, it is assumed\n/// to be empty.\nCallResult<HermesValue>\nhermesBuiltinCopyDataProperties(void *, Runtime *runtime, NativeArgs args) {\n  GCScope gcScope{runtime};\n\n  // 1. Assert: Type(target) is Object.\n  Handle<JSObject> target = args.dyncastArg<JSObject>(0);\n  // To be safe, ignore non-objects.\n  if (!target)\n    return HermesValue::encodeUndefinedValue();\n\n  // 3. If source is undefined or null, return target.\n  Handle<> untypedSource = args.getArgHandle(1);\n  if (untypedSource->isNull() || untypedSource->isUndefined())\n    return target.getHermesValue();\n\n  // 4. Let from be ! ToObject(source).\n  Handle<JSObject> source = untypedSource->isObject()\n      ? Handle<JSObject>::vmcast(untypedSource)\n      : Handle<JSObject>::vmcast(\n            runtime->makeHandle(*toObject(runtime, untypedSource)));\n\n  // 2. Assert: excludedItems is a List of property keys.\n  // In Hermes, excludedItems is represented as a JSObject, created by\n  // bytecode emitted by the compiler, whose keys are the excluded\n  // propertyKyes\n  Handle<JSObject> excludedItems = args.dyncastArg<JSObject>(2);\n  assert(\n      (!excludedItems || !excludedItems->isProxyObject()) &&\n      \"excludedItems internal List is a Proxy\");\n\n  if (source->isProxyObject()) {\n    return copyDataPropertiesSlowPath_RJS(\n        runtime, target, source, excludedItems);\n  }\n\n  MutableHandle<> nameHandle{runtime};\n  MutableHandle<> valueHandle{runtime};\n\n  // Process all named properties/symbols.\n  bool success = JSObject::forEachOwnPropertyWhile(\n      source,\n      runtime,\n      // indexedCB.\n      [&source, &target, &excludedItems, &nameHandle, &valueHandle](\n          Runtime *runtime, uint32_t index, ComputedPropertyDescriptor desc) {\n        if (!desc.flags.enumerable)\n          return true;\n\n        nameHandle = HermesValue::encodeNumberValue(index);\n\n        if (excludedItems) {\n          assert(\n              !excludedItems->isProxyObject() &&\n              \"internal excludedItems object is a proxy\");\n          ComputedPropertyDescriptor xdesc;\n          auto cr = JSObject::getOwnComputedPrimitiveDescriptor(\n              excludedItems,\n              runtime,\n              nameHandle,\n              JSObject::IgnoreProxy::Yes,\n              xdesc);\n          if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n            return false;\n          if (*cr)\n            return true;\n        }\n\n        valueHandle = JSObject::getOwnIndexed(*source, runtime, index);\n\n        if (LLVM_UNLIKELY(\n                JSObject::defineOwnComputedPrimitive(\n                    target,\n                    runtime,\n                    nameHandle,\n                    DefinePropertyFlags::getDefaultNewPropertyFlags(),\n                    valueHandle) == ExecutionStatus::EXCEPTION)) {\n          return false;\n        }\n\n        return true;\n      },\n      // namedCB.\n      [&source, &target, &excludedItems, &valueHandle](\n          Runtime *runtime, SymbolID sym, NamedPropertyDescriptor desc) {\n        if (!desc.flags.enumerable)\n          return true;\n        if (InternalProperty::isInternal(sym))\n          return true;\n\n        // Skip excluded items.\n        if (excludedItems) {\n          auto cr = JSObject::hasNamedOrIndexed(excludedItems, runtime, sym);\n          assert(\n              cr != ExecutionStatus::EXCEPTION &&\n              \"hasNamedOrIndex failed, which can only happen with a proxy, \"\n              \"but excludedItems should never be a proxy\");\n          if (*cr)\n            return true;\n        }\n\n        auto cr =\n            JSObject::getNamedPropertyValue_RJS(source, runtime, source, desc);\n        if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n          return false;\n\n        valueHandle = *cr;\n\n        if (LLVM_UNLIKELY(\n                JSObject::defineOwnProperty(\n                    target,\n                    runtime,\n                    sym,\n                    DefinePropertyFlags::getDefaultNewPropertyFlags(),\n                    valueHandle) == ExecutionStatus::EXCEPTION)) {\n          return false;\n        }\n\n        return true;\n      });\n\n  if (LLVM_UNLIKELY(!success))\n    return ExecutionStatus::EXCEPTION;\n\n  return target.getHermesValue();\n}\n\n/// \\code\n///   HermesBuiltin.copyRestArgs = function (from) {}\n/// \\endcode\n/// Copy the callers parameters starting from index \\c from (where the first\n/// parameter is index 0) into a JSArray.\nCallResult<HermesValue>\nhermesBuiltinCopyRestArgs(void *, Runtime *runtime, NativeArgs args) {\n  GCScopeMarkerRAII marker{runtime};\n\n  // Obtain the caller's stack frame.\n  auto frames = runtime->getStackFrames();\n  auto it = frames.begin();\n  ++it;\n  // Check for the extremely unlikely case where there is no caller frame.\n  if (LLVM_UNLIKELY(it == frames.end()))\n    return HermesValue::encodeUndefinedValue();\n\n  // \"from\" should be a number.\n  if (!args.getArg(0).isNumber())\n    return HermesValue::encodeUndefinedValue();\n  uint32_t from = truncateToUInt32(args.getArg(0).getNumber());\n\n  uint32_t argCount = it->getArgCount();\n  uint32_t length = from <= argCount ? argCount - from : 0;\n\n  auto cr = JSArray::create(runtime, length, length);\n  if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n    return ExecutionStatus::EXCEPTION;\n  auto array = runtime->makeHandle(std::move(*cr));\n  JSArray::setStorageEndIndex(array, runtime, length);\n\n  for (uint32_t i = 0; i != length; ++i) {\n    array->unsafeSetExistingElementAt(\n        array.get(), runtime, i, it->getArgRef(from));\n    ++from;\n  }\n\n  return array.getHermesValue();\n}\n\n/// \\code\n///   HermesBuiltin.arraySpread = function(target, source, nextIndex) {}\n/// /endcode\n/// ES9.0 12.2.5.2\n/// Iterate the iterable source (as if using a for-of) and copy the values from\n/// the spread source into the target array, starting at `nextIndex`.\n/// \\return the next empty index in the array to use for additional properties.\nCallResult<HermesValue>\nhermesBuiltinArraySpread(void *, Runtime *runtime, NativeArgs args) {\n  Handle<JSArray> target = args.dyncastArg<JSArray>(0);\n  // To be safe, check for non-arrays.\n  if (!target) {\n    return runtime->raiseTypeError(\n        \"HermesBuiltin.arraySpread requires an array target\");\n  }\n\n  MutableHandle<> nextValue{runtime};\n\n  Handle<JSArray> arr = args.dyncastArg<JSArray>(1);\n  if (arr) {\n    // Copying from an array, first check and make sure that\n    // `arr[Symbol.iterator]` hasn't been changed by the user.\n    NamedPropertyDescriptor desc;\n    PseudoHandle<JSObject> propObj =\n        createPseudoHandle(JSObject::getNamedDescriptor(\n            arr,\n            runtime,\n            Predefined::getSymbolID(Predefined::SymbolIterator),\n            desc));\n    if (LLVM_LIKELY(propObj) && LLVM_LIKELY(!desc.flags.proxyObject)) {\n      PseudoHandle<> slotValue = createPseudoHandle(\n          JSObject::getNamedSlotValue(propObj.get(), runtime, desc));\n      propObj.invalidate();\n      if (LLVM_LIKELY(\n              slotValue->getRaw() == runtime->arrayPrototypeValues.getRaw())) {\n        slotValue.invalidate();\n        auto nextIndex = args.getArg(2).getNumberAs<JSArray::size_type>();\n        MutableHandle<> idxHandle{runtime};\n        for (JSArray::size_type i = 0; i < JSArray::getLength(*arr); ++i) {\n          // Fast path: look up the property in indexed storage.\n          nextValue = arr->at(runtime, i);\n          if (LLVM_UNLIKELY(nextValue->isEmpty())) {\n            // Slow path, just run the full getComputed_RJS path.\n            // Runs when there is a hole, accessor, non-regular property, etc.\n            GCScopeMarkerRAII marker{runtime};\n            idxHandle = HermesValue::encodeNumberValue(i);\n            CallResult<HermesValue> valueRes =\n                JSObject::getComputed_RJS(arr, runtime, idxHandle);\n            if (LLVM_UNLIKELY(valueRes == ExecutionStatus::EXCEPTION)) {\n              return ExecutionStatus::EXCEPTION;\n            }\n            nextValue = *valueRes;\n          }\n          // It is valid to use setElementAt here because we know that\n          // `target` was created immediately prior to running the spread\n          // and no non-standard properties were added to it,\n          // because the only actions that can be performed between array\n          // creation and running this spread are DefineOwnProperty calls with\n          // standard flags (as well as other spread operations, which do the\n          // same thing).\n          JSArray::setElementAt(target, runtime, nextIndex, nextValue);\n          ++nextIndex;\n        }\n\n        if (LLVM_UNLIKELY(\n                JSArray::setLengthProperty(target, runtime, nextIndex) ==\n                ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n\n        return HermesValue::encodeNumberValue(nextIndex);\n      }\n    }\n  }\n\n  // 3. Let iteratorRecord be ? GetIterator(spreadObj).\n  auto iteratorRecordRes = getIterator(runtime, args.getArgHandle(1));\n  if (LLVM_UNLIKELY(iteratorRecordRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  IteratorRecord iteratorRecord = *iteratorRecordRes;\n\n  MutableHandle<> nextIndex{runtime, args.getArg(2)};\n\n  // 4. Repeat,\n  for (GCScopeMarkerRAII marker{runtime}; /* nothing */; marker.flush()) {\n    // a. Let next be ? IteratorStep(iteratorRecord).\n    auto nextRes = iteratorStep(runtime, iteratorRecord);\n    if (LLVM_UNLIKELY(nextRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    Handle<JSObject> next = *nextRes;\n\n    // b. If next is false, return nextIndex.\n    if (!next) {\n      return nextIndex.getHermesValue();\n    }\n    // c. Let nextValue be ? IteratorValue(next).\n    auto nextItemRes = JSObject::getNamed_RJS(\n        next, runtime, Predefined::getSymbolID(Predefined::value));\n    if (LLVM_UNLIKELY(nextItemRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    nextValue = *nextItemRes;\n\n    // d. Let status be CreateDataProperty(array,\n    //    ToString(ToUint32(nextIndex)), nextValue).\n    // e. Assert: status is true.\n    if (LLVM_UNLIKELY(\n            JSArray::putComputed_RJS(target, runtime, nextIndex, nextValue) ==\n            ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n\n    // f. Let nextIndex be nextIndex + 1.\n    nextIndex = HermesValue::encodeNumberValue(nextIndex->getNumber() + 1);\n  }\n\n  return nextIndex.getHermesValue();\n}\n\n/// \\code\n///   HermesBuiltin.apply = function(fn, argArray, thisVal(opt)) {}\n/// /endcode\n/// Faster version of Function.prototype.apply which does not use its `this`\n/// argument.\n/// `argArray` must be a JSArray with no getters.\n/// Equivalent to fn.apply(thisVal, argArray) if thisVal is provided.\n/// If thisVal is not provided, equivalent to running `new fn` and passing the\n/// arguments in argArray.\nCallResult<HermesValue>\nhermesBuiltinApply(void *, Runtime *runtime, NativeArgs args) {\n  GCScopeMarkerRAII marker{runtime};\n\n  Handle<Callable> fn = args.dyncastArg<Callable>(0);\n  if (LLVM_UNLIKELY(!fn)) {\n    return runtime->raiseTypeErrorForValue(\n        args.getArgHandle(0), \" is not a function\");\n  }\n\n  Handle<JSArray> argArray = args.dyncastArg<JSArray>(1);\n  if (LLVM_UNLIKELY(!argArray)) {\n    return runtime->raiseTypeError(\"args must be an array\");\n  }\n\n  uint32_t len = JSArray::getLength(*argArray);\n\n  bool isConstructor = args.getArgCount() == 2;\n\n  MutableHandle<> thisVal{runtime};\n  if (isConstructor) {\n    auto thisValRes = Callable::createThisForConstruct(fn, runtime);\n    if (LLVM_UNLIKELY(thisValRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    thisVal = *thisValRes;\n  } else {\n    thisVal = args.getArg(2);\n  }\n\n  ScopedNativeCallFrame newFrame{\n      runtime, len, *fn, isConstructor, thisVal.getHermesValue()};\n  for (uint32_t i = 0; i < len; ++i) {\n    newFrame->getArgRef(i) = argArray->at(runtime, i);\n  }\n  return isConstructor ? Callable::construct(fn, runtime, thisVal)\n                       : Callable::call(fn, runtime);\n}\n\n/// HermesBuiltin.exportAll(exports, source) will copy exported named\n/// properties from `source` to `exports`, defining them on `exports` as\n/// non-configurable.\n/// Note that the default exported property on `source` is ignored,\n/// as are non-enumerable properties on `source`.\nCallResult<HermesValue>\nhermesBuiltinExportAll(void *, Runtime *runtime, NativeArgs args) {\n  Handle<JSObject> exports = args.dyncastArg<JSObject>(0);\n  if (LLVM_UNLIKELY(!exports)) {\n    return runtime->raiseTypeError(\n        \"exportAll() exports argument must be object\");\n  }\n\n  Handle<JSObject> source = args.dyncastArg<JSObject>(1);\n  if (LLVM_UNLIKELY(!source)) {\n    return runtime->raiseTypeError(\n        \"exportAll() source argument must be object\");\n  }\n\n  MutableHandle<> propertyHandle{runtime};\n\n  auto dpf = DefinePropertyFlags::getDefaultNewPropertyFlags();\n  dpf.configurable = 0;\n\n  CallResult<bool> defineRes{ExecutionStatus::EXCEPTION};\n\n  // Iterate the named properties excluding those which use Symbols.\n  bool result = HiddenClass::forEachPropertyWhile(\n      runtime->makeHandle(source->getClass(runtime)),\n      runtime,\n      [&source, &exports, &propertyHandle, &dpf, &defineRes](\n          Runtime *runtime, SymbolID id, NamedPropertyDescriptor desc) {\n        if (!desc.flags.enumerable)\n          return true;\n\n        if (id == Predefined::getSymbolID(Predefined::defaultExport)) {\n          return true;\n        }\n\n        propertyHandle = JSObject::getNamedSlotValue(*source, runtime, desc);\n        defineRes = JSObject::defineOwnProperty(\n            exports, runtime, id, dpf, propertyHandle);\n        if (LLVM_UNLIKELY(defineRes == ExecutionStatus::EXCEPTION)) {\n          return false;\n        }\n\n        return true;\n      });\n  if (LLVM_UNLIKELY(!result)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  return HermesValue::encodeUndefinedValue();\n}\n\nvoid createHermesBuiltins(\n    Runtime *runtime,\n    llvm::MutableArrayRef<NativeFunction *> builtins) {\n  auto defineInternMethod = [&](BuiltinMethod::Enum builtinIndex,\n                                Predefined::Str symID,\n                                NativeFunctionPtr func,\n                                uint8_t count = 0) {\n    auto method = NativeFunction::create(\n        runtime,\n        Handle<JSObject>::vmcast(&runtime->functionPrototype),\n        nullptr /* context */,\n        func,\n        Predefined::getSymbolID(symID),\n        count,\n        Runtime::makeNullHandle<JSObject>());\n\n    assert(builtins[builtinIndex] == nullptr && \"builtin already defined\");\n    builtins[builtinIndex] = *method;\n  };\n\n  // HermesBuiltin function properties\n  namespace P = Predefined;\n  namespace B = BuiltinMethod;\n  defineInternMethod(\n      B::HermesBuiltin_silentSetPrototypeOf,\n      P::silentSetPrototypeOf,\n      silentObjectSetPrototypeOf,\n      2);\n  defineInternMethod(\n      B::HermesBuiltin_getTemplateObject,\n      P::getTemplateObject,\n      hermesBuiltinGetTemplateObject);\n  defineInternMethod(\n      B::HermesBuiltin_ensureObject,\n      P::ensureObject,\n      hermesBuiltinEnsureObject,\n      2);\n  defineInternMethod(\n      B::HermesBuiltin_throwTypeError,\n      P::throwTypeError,\n      hermesBuiltinThrowTypeError,\n      1);\n  defineInternMethod(\n      B::HermesBuiltin_generatorSetDelegated,\n      P::generatorSetDelegated,\n      hermesBuiltinGeneratorSetDelegated,\n      1);\n  defineInternMethod(\n      B::HermesBuiltin_copyDataProperties,\n      P::copyDataProperties,\n      hermesBuiltinCopyDataProperties,\n      3);\n  defineInternMethod(\n      B::HermesBuiltin_copyRestArgs,\n      P::copyRestArgs,\n      hermesBuiltinCopyRestArgs,\n      1);\n  defineInternMethod(\n      B::HermesBuiltin_arraySpread,\n      P::arraySpread,\n      hermesBuiltinArraySpread,\n      2);\n  defineInternMethod(B::HermesBuiltin_apply, P::apply, hermesBuiltinApply, 2);\n  defineInternMethod(\n      B::HermesBuiltin_exportAll, P::exportAll, hermesBuiltinExportAll);\n  defineInternMethod(\n      B::HermesBuiltin_exponentiationOperator,\n      P::exponentiationOperator,\n      mathPow);\n\n  // Define the 'requireFast' function, which takes a number argument.\n  defineInternMethod(\n      B::HermesBuiltin_requireFast, P::requireFast, requireFast, 1);\n}\n\n} // namespace vm\n} // namespace hermes\n", "/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n//RUN: %hermes -O -target=HBC %s | %FileCheck --match-full-lines %s\n\nfunction func() {\n    print(arguments.length);\n}\n\ntry {\n    var a = []\n    a[8*1024*1024] = 100;\n    func.apply(null, a);\n} catch(e) {\n    print(\"caught:\", e.name, e.message);\n}\n//CHECK: caught: RangeError {{.*}}\n\nvar x = [];\nx.length = 4294967295;\n\nfor (var i = 0; i < 20; i++) {\n    x[i] = i;\n}\ntry {\n  func.apply(99, x);\n} catch (e) {\n    print(\"caught:\", e.name, e.message);\n}\n//CHECK: caught: RangeError {{.*}}\n"], "fixing_code": ["/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include \"JSLibInternal.h\"\n\n#include \"hermes/Support/Base64vlq.h\"\n#include \"hermes/VM/Callable.h\"\n#include \"hermes/VM/JSArray.h\"\n#include \"hermes/VM/JSArrayBuffer.h\"\n#include \"hermes/VM/JSLib.h\"\n#include \"hermes/VM/Operations.h\"\n#include \"hermes/VM/StackFrame-inline.h\"\n#include \"hermes/VM/StringView.h\"\n\n#include <random>\n\nnamespace hermes {\nnamespace vm {\n\n/// Set the parent of an object failing silently on any error.\nCallResult<HermesValue>\nsilentObjectSetPrototypeOf(void *, Runtime *runtime, NativeArgs args) {\n  JSObject *O = dyn_vmcast<JSObject>(args.getArg(0));\n  if (!O)\n    return HermesValue::encodeUndefinedValue();\n\n  JSObject *parent;\n  HermesValue V = args.getArg(1);\n  if (V.isNull())\n    parent = nullptr;\n  else if (V.isObject())\n    parent = vmcast<JSObject>(V);\n  else\n    return HermesValue::encodeUndefinedValue();\n\n  (void)JSObject::setParent(O, runtime, parent);\n\n  // Ignore exceptions.\n  runtime->clearThrownValue();\n\n  return HermesValue::encodeUndefinedValue();\n}\n\n/// ES6.0 12.2.9.3 Runtime Semantics: GetTemplateObject ( templateLiteral )\n/// Given a template literal, return a template object that looks like this:\n/// [cookedString0, cookedString1, ..., raw: [rawString0, rawString1]].\n/// This object is frozen, as well as the 'raw' object nested inside.\n/// We only pass the parts from the template literal that are needed to\n/// construct this object. That is, the raw strings and cooked strings.\n/// Arguments: \\p templateObjID is the unique id associated with the template\n/// object. \\p dup is a boolean, when it is true, cooked strings are the same as\n/// raw strings. Then raw strings are passed. Finally cooked strings are\n/// optionally passed if \\p dup is true.\nCallResult<HermesValue>\nhermesBuiltinGetTemplateObject(void *, Runtime *runtime, NativeArgs args) {\n  if (LLVM_UNLIKELY(args.getArgCount() < 3)) {\n    return runtime->raiseTypeError(\"At least three arguments expected\");\n  }\n  if (LLVM_UNLIKELY(!args.getArg(0).isNumber())) {\n    return runtime->raiseTypeError(\"First argument should be a number\");\n  }\n  if (LLVM_UNLIKELY(!args.getArg(1).isBool())) {\n    return runtime->raiseTypeError(\"Second argument should be a bool\");\n  }\n\n  GCScope gcScope{runtime};\n\n  // Try finding the template object in the template object cache.\n  uint32_t templateObjID = args.getArg(0).getNumberAs<uint32_t>();\n  auto savedCB = runtime->getStackFrames().begin()->getSavedCodeBlock();\n  if (LLVM_UNLIKELY(!savedCB)) {\n    return runtime->raiseTypeError(\"Cannot be called from native code\");\n  }\n  RuntimeModule *runtimeModule = savedCB->getRuntimeModule();\n  JSObject *cachedTemplateObj =\n      runtimeModule->findCachedTemplateObject(templateObjID);\n  if (cachedTemplateObj) {\n    return HermesValue::encodeObjectValue(cachedTemplateObj);\n  }\n\n  bool dup = args.getArg(1).getBool();\n  if (LLVM_UNLIKELY(!dup && args.getArgCount() % 2 == 1)) {\n    return runtime->raiseTypeError(\n        \"There must be the same number of raw and cooked strings.\");\n  }\n  uint32_t count = dup ? args.getArgCount() - 2 : args.getArgCount() / 2 - 1;\n\n  // Create template object and raw object.\n  auto arrRes = JSArray::create(runtime, count, 0);\n  if (LLVM_UNLIKELY(arrRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto rawObj = runtime->makeHandle<JSObject>(arrRes->getHermesValue());\n  auto arrRes2 = JSArray::create(runtime, count, 0);\n  if (LLVM_UNLIKELY(arrRes2 == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto templateObj = runtime->makeHandle<JSObject>(arrRes2->getHermesValue());\n\n  // Set cooked and raw strings as elements in template object and raw object,\n  // respectively.\n  DefinePropertyFlags dpf = DefinePropertyFlags::getDefaultNewPropertyFlags();\n  dpf.writable = 0;\n  dpf.configurable = 0;\n  MutableHandle<> idx{runtime};\n  MutableHandle<> rawValue{runtime};\n  MutableHandle<> cookedValue{runtime};\n  uint32_t cookedBegin = dup ? 2 : 2 + count;\n  auto marker = gcScope.createMarker();\n  for (uint32_t i = 0; i < count; ++i) {\n    idx = HermesValue::encodeNumberValue(i);\n\n    cookedValue = args.getArg(cookedBegin + i);\n    auto putRes = JSObject::defineOwnComputedPrimitive(\n        templateObj, runtime, idx, dpf, cookedValue);\n    assert(\n        putRes != ExecutionStatus::EXCEPTION && *putRes &&\n        \"Failed to set cooked value to template object.\");\n\n    rawValue = args.getArg(2 + i);\n    putRes = JSObject::defineOwnComputedPrimitive(\n        rawObj, runtime, idx, dpf, rawValue);\n    assert(\n        putRes != ExecutionStatus::EXCEPTION && *putRes &&\n        \"Failed to set raw value to raw object.\");\n\n    gcScope.flushToMarker(marker);\n  }\n  // Make 'length' property on the raw object read-only.\n  DefinePropertyFlags readOnlyDPF{};\n  readOnlyDPF.setWritable = 1;\n  readOnlyDPF.setConfigurable = 1;\n  readOnlyDPF.writable = 0;\n  readOnlyDPF.configurable = 0;\n  auto readOnlyRes = JSObject::defineOwnProperty(\n      rawObj,\n      runtime,\n      Predefined::getSymbolID(Predefined::length),\n      readOnlyDPF,\n      Runtime::getUndefinedValue(),\n      PropOpFlags().plusThrowOnError());\n  if (LLVM_UNLIKELY(readOnlyRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (LLVM_UNLIKELY(!*readOnlyRes)) {\n    return runtime->raiseTypeError(\n        \"Failed to set 'length' property on the raw object read-only.\");\n  }\n  JSObject::preventExtensions(rawObj.get());\n\n  // Set raw object as a read-only non-enumerable property of the template\n  // object.\n  PropertyFlags constantPF{};\n  constantPF.writable = 0;\n  constantPF.configurable = 0;\n  constantPF.enumerable = 0;\n  auto putNewRes = JSObject::defineNewOwnProperty(\n      templateObj,\n      runtime,\n      Predefined::getSymbolID(Predefined::raw),\n      constantPF,\n      rawObj);\n  if (LLVM_UNLIKELY(putNewRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  // Make 'length' property on the template object read-only.\n  readOnlyRes = JSObject::defineOwnProperty(\n      templateObj,\n      runtime,\n      Predefined::getSymbolID(Predefined::length),\n      readOnlyDPF,\n      Runtime::getUndefinedValue(),\n      PropOpFlags().plusThrowOnError());\n  if (LLVM_UNLIKELY(readOnlyRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (LLVM_UNLIKELY(!*readOnlyRes)) {\n    return runtime->raiseTypeError(\n        \"Failed to set 'length' property on the raw object read-only.\");\n  }\n  JSObject::preventExtensions(templateObj.get());\n\n  // Cache the template object.\n  runtimeModule->cacheTemplateObject(templateObjID, templateObj);\n\n  return templateObj.getHermesValue();\n}\n\n/// If the first argument is not an object, throw a type error with the second\n/// argument as a message.\n///\n/// \\code\n///   HermesBuiltin.ensureObject = function(value, errorMessage) {...}\n/// \\endcode\nCallResult<HermesValue>\nhermesBuiltinEnsureObject(void *, Runtime *runtime, NativeArgs args) {\n  if (LLVM_LIKELY(args.getArg(0).isObject()))\n    return HermesValue::encodeUndefinedValue();\n\n  return runtime->raiseTypeError(args.getArgHandle(1));\n}\n\n/// Throw a type error with the argument as a message.\n///\n/// \\code\n///   HermesBuiltin.throwTypeError = function(errorMessage) {...}\n/// \\endcode\nCallResult<HermesValue>\nhermesBuiltinThrowTypeError(void *, Runtime *runtime, NativeArgs args) {\n  return runtime->raiseTypeError(args.getArgHandle(0));\n}\n\n/// Set the isDelegated flag on the GeneratorInnerFunction which calls\n/// this function.\n/// \\pre the caller must be an interpreted GeneratorInnerFunction\n/// \\return `undefined`\nCallResult<HermesValue>\nhermesBuiltinGeneratorSetDelegated(void *, Runtime *runtime, NativeArgs args) {\n  auto *gen = dyn_vmcast_or_null<GeneratorInnerFunction>(\n      runtime->getCurrentFrame().getPreviousFrame().getCalleeClosure());\n  if (!gen) {\n    return runtime->raiseTypeError(\n        \"generatorSetDelegated can only be called as part of yield*\");\n  }\n  gen->setIsDelegated(true);\n  return HermesValue::encodeUndefinedValue();\n}\n\nnamespace {\n\nCallResult<HermesValue> copyDataPropertiesSlowPath_RJS(\n    Runtime *runtime,\n    Handle<JSObject> target,\n    Handle<JSObject> from,\n    Handle<JSObject> excludedItems) {\n  assert(\n      from->isProxyObject() &&\n      \"copyDataPropertiesSlowPath_RJS is only for Proxy\");\n\n  // 5. Let keys be ? from.[[OwnPropertyKeys]]().\n  auto cr = JSProxy::getOwnPropertyKeys(\n      from,\n      runtime,\n      OwnKeysFlags()\n          .plusIncludeSymbols()\n          .plusIncludeNonSymbols()\n          .plusIncludeNonEnumerable());\n  if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto keys = *cr;\n\n  MutableHandle<> nextKeyHandle{runtime};\n  MutableHandle<> propValueHandle{runtime};\n  GCScopeMarkerRAII marker{runtime};\n  // 6. For each element nextKey of keys in List order, do\n  for (uint32_t nextKeyIdx = 0, endIdx = keys->getEndIndex();\n       nextKeyIdx < endIdx;\n       ++nextKeyIdx) {\n    marker.flush();\n    nextKeyHandle = keys->at(runtime, nextKeyIdx);\n    // b. For each element e of excludedItems in List order, do\n    //   i. If SameValue(e, nextKey) is true, then\n    //     1. Set excluded to true.\n    if (excludedItems) {\n      assert(\n          !excludedItems->isProxyObject() &&\n          \"internal excludedItems object is a proxy\");\n      ComputedPropertyDescriptor desc;\n      CallResult<bool> cr = JSObject::getOwnComputedPrimitiveDescriptor(\n          excludedItems,\n          runtime,\n          nextKeyHandle,\n          JSObject::IgnoreProxy::Yes,\n          desc);\n      if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      if (*cr)\n        continue;\n    }\n\n    //   i. Let desc be ? from.[[GetOwnProperty]](nextKey).\n    ComputedPropertyDescriptor desc;\n    CallResult<bool> crb =\n        JSProxy::getOwnProperty(from, runtime, nextKeyHandle, desc, nullptr);\n    if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n      return ExecutionStatus::EXCEPTION;\n    //   ii. If desc is not undefined and desc.[[Enumerable]] is true, then\n    if (*crb && desc.flags.enumerable) {\n      //     1. Let propValue be ? Get(from, nextKey).\n      CallResult<HermesValue> crv =\n          JSProxy::getComputed(from, runtime, nextKeyHandle, from);\n      if (LLVM_UNLIKELY(crv == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      propValueHandle = *crv;\n      //     2. Perform ! CreateDataProperty(target, nextKey, propValue).\n      crb = JSObject::defineOwnComputed(\n          target,\n          runtime,\n          nextKeyHandle,\n          DefinePropertyFlags::getDefaultNewPropertyFlags(),\n          propValueHandle);\n      if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n        return ExecutionStatus::EXCEPTION;\n      assert(\n          crb != ExecutionStatus::EXCEPTION && *crb &&\n          \"CreateDataProperty failed\");\n    }\n  }\n  return target.getHermesValue();\n}\n\n} // namespace\n\n/// \\code\n///   HermesBuiltin.copyDataProperties =\n///         function (target, source, excludedItems) {}\n/// \\endcode\n///\n/// Copy all enumerable own properties of object \\p source, that are not also\n/// properties of \\p excludedItems, into \\p target, which must be an object, and\n/// return \\p target. If \\p excludedItems is not specified, it is assumed\n/// to be empty.\nCallResult<HermesValue>\nhermesBuiltinCopyDataProperties(void *, Runtime *runtime, NativeArgs args) {\n  GCScope gcScope{runtime};\n\n  // 1. Assert: Type(target) is Object.\n  Handle<JSObject> target = args.dyncastArg<JSObject>(0);\n  // To be safe, ignore non-objects.\n  if (!target)\n    return HermesValue::encodeUndefinedValue();\n\n  // 3. If source is undefined or null, return target.\n  Handle<> untypedSource = args.getArgHandle(1);\n  if (untypedSource->isNull() || untypedSource->isUndefined())\n    return target.getHermesValue();\n\n  // 4. Let from be ! ToObject(source).\n  Handle<JSObject> source = untypedSource->isObject()\n      ? Handle<JSObject>::vmcast(untypedSource)\n      : Handle<JSObject>::vmcast(\n            runtime->makeHandle(*toObject(runtime, untypedSource)));\n\n  // 2. Assert: excludedItems is a List of property keys.\n  // In Hermes, excludedItems is represented as a JSObject, created by\n  // bytecode emitted by the compiler, whose keys are the excluded\n  // propertyKyes\n  Handle<JSObject> excludedItems = args.dyncastArg<JSObject>(2);\n  assert(\n      (!excludedItems || !excludedItems->isProxyObject()) &&\n      \"excludedItems internal List is a Proxy\");\n\n  if (source->isProxyObject()) {\n    return copyDataPropertiesSlowPath_RJS(\n        runtime, target, source, excludedItems);\n  }\n\n  MutableHandle<> nameHandle{runtime};\n  MutableHandle<> valueHandle{runtime};\n\n  // Process all named properties/symbols.\n  bool success = JSObject::forEachOwnPropertyWhile(\n      source,\n      runtime,\n      // indexedCB.\n      [&source, &target, &excludedItems, &nameHandle, &valueHandle](\n          Runtime *runtime, uint32_t index, ComputedPropertyDescriptor desc) {\n        if (!desc.flags.enumerable)\n          return true;\n\n        nameHandle = HermesValue::encodeNumberValue(index);\n\n        if (excludedItems) {\n          assert(\n              !excludedItems->isProxyObject() &&\n              \"internal excludedItems object is a proxy\");\n          ComputedPropertyDescriptor xdesc;\n          auto cr = JSObject::getOwnComputedPrimitiveDescriptor(\n              excludedItems,\n              runtime,\n              nameHandle,\n              JSObject::IgnoreProxy::Yes,\n              xdesc);\n          if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n            return false;\n          if (*cr)\n            return true;\n        }\n\n        valueHandle = JSObject::getOwnIndexed(*source, runtime, index);\n\n        if (LLVM_UNLIKELY(\n                JSObject::defineOwnComputedPrimitive(\n                    target,\n                    runtime,\n                    nameHandle,\n                    DefinePropertyFlags::getDefaultNewPropertyFlags(),\n                    valueHandle) == ExecutionStatus::EXCEPTION)) {\n          return false;\n        }\n\n        return true;\n      },\n      // namedCB.\n      [&source, &target, &excludedItems, &valueHandle](\n          Runtime *runtime, SymbolID sym, NamedPropertyDescriptor desc) {\n        if (!desc.flags.enumerable)\n          return true;\n        if (InternalProperty::isInternal(sym))\n          return true;\n\n        // Skip excluded items.\n        if (excludedItems) {\n          auto cr = JSObject::hasNamedOrIndexed(excludedItems, runtime, sym);\n          assert(\n              cr != ExecutionStatus::EXCEPTION &&\n              \"hasNamedOrIndex failed, which can only happen with a proxy, \"\n              \"but excludedItems should never be a proxy\");\n          if (*cr)\n            return true;\n        }\n\n        auto cr =\n            JSObject::getNamedPropertyValue_RJS(source, runtime, source, desc);\n        if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n          return false;\n\n        valueHandle = *cr;\n\n        if (LLVM_UNLIKELY(\n                JSObject::defineOwnProperty(\n                    target,\n                    runtime,\n                    sym,\n                    DefinePropertyFlags::getDefaultNewPropertyFlags(),\n                    valueHandle) == ExecutionStatus::EXCEPTION)) {\n          return false;\n        }\n\n        return true;\n      });\n\n  if (LLVM_UNLIKELY(!success))\n    return ExecutionStatus::EXCEPTION;\n\n  return target.getHermesValue();\n}\n\n/// \\code\n///   HermesBuiltin.copyRestArgs = function (from) {}\n/// \\endcode\n/// Copy the callers parameters starting from index \\c from (where the first\n/// parameter is index 0) into a JSArray.\nCallResult<HermesValue>\nhermesBuiltinCopyRestArgs(void *, Runtime *runtime, NativeArgs args) {\n  GCScopeMarkerRAII marker{runtime};\n\n  // Obtain the caller's stack frame.\n  auto frames = runtime->getStackFrames();\n  auto it = frames.begin();\n  ++it;\n  // Check for the extremely unlikely case where there is no caller frame.\n  if (LLVM_UNLIKELY(it == frames.end()))\n    return HermesValue::encodeUndefinedValue();\n\n  // \"from\" should be a number.\n  if (!args.getArg(0).isNumber())\n    return HermesValue::encodeUndefinedValue();\n  uint32_t from = truncateToUInt32(args.getArg(0).getNumber());\n\n  uint32_t argCount = it->getArgCount();\n  uint32_t length = from <= argCount ? argCount - from : 0;\n\n  auto cr = JSArray::create(runtime, length, length);\n  if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION))\n    return ExecutionStatus::EXCEPTION;\n  auto array = runtime->makeHandle(std::move(*cr));\n  JSArray::setStorageEndIndex(array, runtime, length);\n\n  for (uint32_t i = 0; i != length; ++i) {\n    array->unsafeSetExistingElementAt(\n        array.get(), runtime, i, it->getArgRef(from));\n    ++from;\n  }\n\n  return array.getHermesValue();\n}\n\n/// \\code\n///   HermesBuiltin.arraySpread = function(target, source, nextIndex) {}\n/// /endcode\n/// ES9.0 12.2.5.2\n/// Iterate the iterable source (as if using a for-of) and copy the values from\n/// the spread source into the target array, starting at `nextIndex`.\n/// \\return the next empty index in the array to use for additional properties.\nCallResult<HermesValue>\nhermesBuiltinArraySpread(void *, Runtime *runtime, NativeArgs args) {\n  Handle<JSArray> target = args.dyncastArg<JSArray>(0);\n  // To be safe, check for non-arrays.\n  if (!target) {\n    return runtime->raiseTypeError(\n        \"HermesBuiltin.arraySpread requires an array target\");\n  }\n\n  MutableHandle<> nextValue{runtime};\n\n  Handle<JSArray> arr = args.dyncastArg<JSArray>(1);\n  if (arr) {\n    // Copying from an array, first check and make sure that\n    // `arr[Symbol.iterator]` hasn't been changed by the user.\n    NamedPropertyDescriptor desc;\n    PseudoHandle<JSObject> propObj =\n        createPseudoHandle(JSObject::getNamedDescriptor(\n            arr,\n            runtime,\n            Predefined::getSymbolID(Predefined::SymbolIterator),\n            desc));\n    if (LLVM_LIKELY(propObj) && LLVM_LIKELY(!desc.flags.proxyObject)) {\n      PseudoHandle<> slotValue = createPseudoHandle(\n          JSObject::getNamedSlotValue(propObj.get(), runtime, desc));\n      propObj.invalidate();\n      if (LLVM_LIKELY(\n              slotValue->getRaw() == runtime->arrayPrototypeValues.getRaw())) {\n        slotValue.invalidate();\n        auto nextIndex = args.getArg(2).getNumberAs<JSArray::size_type>();\n        MutableHandle<> idxHandle{runtime};\n        for (JSArray::size_type i = 0; i < JSArray::getLength(*arr); ++i) {\n          // Fast path: look up the property in indexed storage.\n          nextValue = arr->at(runtime, i);\n          if (LLVM_UNLIKELY(nextValue->isEmpty())) {\n            // Slow path, just run the full getComputed_RJS path.\n            // Runs when there is a hole, accessor, non-regular property, etc.\n            GCScopeMarkerRAII marker{runtime};\n            idxHandle = HermesValue::encodeNumberValue(i);\n            CallResult<HermesValue> valueRes =\n                JSObject::getComputed_RJS(arr, runtime, idxHandle);\n            if (LLVM_UNLIKELY(valueRes == ExecutionStatus::EXCEPTION)) {\n              return ExecutionStatus::EXCEPTION;\n            }\n            nextValue = *valueRes;\n          }\n          // It is valid to use setElementAt here because we know that\n          // `target` was created immediately prior to running the spread\n          // and no non-standard properties were added to it,\n          // because the only actions that can be performed between array\n          // creation and running this spread are DefineOwnProperty calls with\n          // standard flags (as well as other spread operations, which do the\n          // same thing).\n          JSArray::setElementAt(target, runtime, nextIndex, nextValue);\n          ++nextIndex;\n        }\n\n        if (LLVM_UNLIKELY(\n                JSArray::setLengthProperty(target, runtime, nextIndex) ==\n                ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n\n        return HermesValue::encodeNumberValue(nextIndex);\n      }\n    }\n  }\n\n  // 3. Let iteratorRecord be ? GetIterator(spreadObj).\n  auto iteratorRecordRes = getIterator(runtime, args.getArgHandle(1));\n  if (LLVM_UNLIKELY(iteratorRecordRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  IteratorRecord iteratorRecord = *iteratorRecordRes;\n\n  MutableHandle<> nextIndex{runtime, args.getArg(2)};\n\n  // 4. Repeat,\n  for (GCScopeMarkerRAII marker{runtime}; /* nothing */; marker.flush()) {\n    // a. Let next be ? IteratorStep(iteratorRecord).\n    auto nextRes = iteratorStep(runtime, iteratorRecord);\n    if (LLVM_UNLIKELY(nextRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    Handle<JSObject> next = *nextRes;\n\n    // b. If next is false, return nextIndex.\n    if (!next) {\n      return nextIndex.getHermesValue();\n    }\n    // c. Let nextValue be ? IteratorValue(next).\n    auto nextItemRes = JSObject::getNamed_RJS(\n        next, runtime, Predefined::getSymbolID(Predefined::value));\n    if (LLVM_UNLIKELY(nextItemRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    nextValue = *nextItemRes;\n\n    // d. Let status be CreateDataProperty(array,\n    //    ToString(ToUint32(nextIndex)), nextValue).\n    // e. Assert: status is true.\n    if (LLVM_UNLIKELY(\n            JSArray::putComputed_RJS(target, runtime, nextIndex, nextValue) ==\n            ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n\n    // f. Let nextIndex be nextIndex + 1.\n    nextIndex = HermesValue::encodeNumberValue(nextIndex->getNumber() + 1);\n  }\n\n  return nextIndex.getHermesValue();\n}\n\n/// \\code\n///   HermesBuiltin.apply = function(fn, argArray, thisVal(opt)) {}\n/// /endcode\n/// Faster version of Function.prototype.apply which does not use its `this`\n/// argument.\n/// `argArray` must be a JSArray with no getters.\n/// Equivalent to fn.apply(thisVal, argArray) if thisVal is provided.\n/// If thisVal is not provided, equivalent to running `new fn` and passing the\n/// arguments in argArray.\nCallResult<HermesValue>\nhermesBuiltinApply(void *, Runtime *runtime, NativeArgs args) {\n  GCScopeMarkerRAII marker{runtime};\n\n  Handle<Callable> fn = args.dyncastArg<Callable>(0);\n  if (LLVM_UNLIKELY(!fn)) {\n    return runtime->raiseTypeErrorForValue(\n        args.getArgHandle(0), \" is not a function\");\n  }\n\n  Handle<JSArray> argArray = args.dyncastArg<JSArray>(1);\n  if (LLVM_UNLIKELY(!argArray)) {\n    return runtime->raiseTypeError(\"args must be an array\");\n  }\n\n  uint32_t len = JSArray::getLength(*argArray);\n\n  bool isConstructor = args.getArgCount() == 2;\n\n  MutableHandle<> thisVal{runtime};\n  if (isConstructor) {\n    auto thisValRes = Callable::createThisForConstruct(fn, runtime);\n    if (LLVM_UNLIKELY(thisValRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    thisVal = *thisValRes;\n  } else {\n    thisVal = args.getArg(2);\n  }\n\n  ScopedNativeCallFrame newFrame{\n      runtime, len, *fn, isConstructor, thisVal.getHermesValue()};\n  if (LLVM_UNLIKELY(newFrame.overflowed()))\n    return runtime->raiseStackOverflow(Runtime::StackOverflowKind::NativeStack);\n\n  for (uint32_t i = 0; i < len; ++i) {\n    newFrame->getArgRef(i) = argArray->at(runtime, i);\n  }\n  return isConstructor ? Callable::construct(fn, runtime, thisVal)\n                       : Callable::call(fn, runtime);\n}\n\n/// HermesBuiltin.exportAll(exports, source) will copy exported named\n/// properties from `source` to `exports`, defining them on `exports` as\n/// non-configurable.\n/// Note that the default exported property on `source` is ignored,\n/// as are non-enumerable properties on `source`.\nCallResult<HermesValue>\nhermesBuiltinExportAll(void *, Runtime *runtime, NativeArgs args) {\n  Handle<JSObject> exports = args.dyncastArg<JSObject>(0);\n  if (LLVM_UNLIKELY(!exports)) {\n    return runtime->raiseTypeError(\n        \"exportAll() exports argument must be object\");\n  }\n\n  Handle<JSObject> source = args.dyncastArg<JSObject>(1);\n  if (LLVM_UNLIKELY(!source)) {\n    return runtime->raiseTypeError(\n        \"exportAll() source argument must be object\");\n  }\n\n  MutableHandle<> propertyHandle{runtime};\n\n  auto dpf = DefinePropertyFlags::getDefaultNewPropertyFlags();\n  dpf.configurable = 0;\n\n  CallResult<bool> defineRes{ExecutionStatus::EXCEPTION};\n\n  // Iterate the named properties excluding those which use Symbols.\n  bool result = HiddenClass::forEachPropertyWhile(\n      runtime->makeHandle(source->getClass(runtime)),\n      runtime,\n      [&source, &exports, &propertyHandle, &dpf, &defineRes](\n          Runtime *runtime, SymbolID id, NamedPropertyDescriptor desc) {\n        if (!desc.flags.enumerable)\n          return true;\n\n        if (id == Predefined::getSymbolID(Predefined::defaultExport)) {\n          return true;\n        }\n\n        propertyHandle = JSObject::getNamedSlotValue(*source, runtime, desc);\n        defineRes = JSObject::defineOwnProperty(\n            exports, runtime, id, dpf, propertyHandle);\n        if (LLVM_UNLIKELY(defineRes == ExecutionStatus::EXCEPTION)) {\n          return false;\n        }\n\n        return true;\n      });\n  if (LLVM_UNLIKELY(!result)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  return HermesValue::encodeUndefinedValue();\n}\n\nvoid createHermesBuiltins(\n    Runtime *runtime,\n    llvm::MutableArrayRef<NativeFunction *> builtins) {\n  auto defineInternMethod = [&](BuiltinMethod::Enum builtinIndex,\n                                Predefined::Str symID,\n                                NativeFunctionPtr func,\n                                uint8_t count = 0) {\n    auto method = NativeFunction::create(\n        runtime,\n        Handle<JSObject>::vmcast(&runtime->functionPrototype),\n        nullptr /* context */,\n        func,\n        Predefined::getSymbolID(symID),\n        count,\n        Runtime::makeNullHandle<JSObject>());\n\n    assert(builtins[builtinIndex] == nullptr && \"builtin already defined\");\n    builtins[builtinIndex] = *method;\n  };\n\n  // HermesBuiltin function properties\n  namespace P = Predefined;\n  namespace B = BuiltinMethod;\n  defineInternMethod(\n      B::HermesBuiltin_silentSetPrototypeOf,\n      P::silentSetPrototypeOf,\n      silentObjectSetPrototypeOf,\n      2);\n  defineInternMethod(\n      B::HermesBuiltin_getTemplateObject,\n      P::getTemplateObject,\n      hermesBuiltinGetTemplateObject);\n  defineInternMethod(\n      B::HermesBuiltin_ensureObject,\n      P::ensureObject,\n      hermesBuiltinEnsureObject,\n      2);\n  defineInternMethod(\n      B::HermesBuiltin_throwTypeError,\n      P::throwTypeError,\n      hermesBuiltinThrowTypeError,\n      1);\n  defineInternMethod(\n      B::HermesBuiltin_generatorSetDelegated,\n      P::generatorSetDelegated,\n      hermesBuiltinGeneratorSetDelegated,\n      1);\n  defineInternMethod(\n      B::HermesBuiltin_copyDataProperties,\n      P::copyDataProperties,\n      hermesBuiltinCopyDataProperties,\n      3);\n  defineInternMethod(\n      B::HermesBuiltin_copyRestArgs,\n      P::copyRestArgs,\n      hermesBuiltinCopyRestArgs,\n      1);\n  defineInternMethod(\n      B::HermesBuiltin_arraySpread,\n      P::arraySpread,\n      hermesBuiltinArraySpread,\n      2);\n  defineInternMethod(B::HermesBuiltin_apply, P::apply, hermesBuiltinApply, 2);\n  defineInternMethod(\n      B::HermesBuiltin_exportAll, P::exportAll, hermesBuiltinExportAll);\n  defineInternMethod(\n      B::HermesBuiltin_exponentiationOperator,\n      P::exponentiationOperator,\n      mathPow);\n\n  // Define the 'requireFast' function, which takes a number argument.\n  defineInternMethod(\n      B::HermesBuiltin_requireFast, P::requireFast, requireFast, 1);\n}\n\n} // namespace vm\n} // namespace hermes\n", "/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n//RUN: %hermes -O -target=HBC %s | %FileCheck --match-full-lines %s\n\nfunction func() {\n    print(arguments.length);\n}\n\ntry {\n    var a = []\n    a[8*1024*1024] = 100;\n    func.apply(null, a);\n} catch(e) {\n    print(\"caught:\", e.name, e.message);\n}\n//CHECK: caught: RangeError {{.*}}\n\nvar x = [];\nx.length = 4294967295;\n\nfor (var i = 0; i < 20; i++) {\n    x[i] = i;\n}\ntry {\n  func.apply(99, x);\n} catch (e) {\n    print(\"caught:\", e.name, e.message);\n}\n//CHECK: caught: RangeError {{.*}}\n\ntry {\n  v0 = [1.1];\n  function v1() {\n    v1(...v0);\n  }\n  v1();\n} catch (e) {\n    print(\"caught:\", e.name, e.message);\n}\n//CHECK: caught: RangeError {{.*}}\n"], "filenames": ["lib/VM/JSLib/HermesBuiltin.cpp", "test/hermes/stack-overflow-apply.js"], "buggy_code_start_loc": [655, 34], "buggy_code_end_loc": [655, 34], "fixing_code_start_loc": [656, 35], "fixing_code_end_loc": [659, 46], "type": "CWE-787", "message": "A stack overflow vulnerability in Facebook Hermes 'builtin apply' prior to commit 86543ac47e59c522976b5632b8bf9a2a4583c7d2 (https://github.com/facebook/hermes/commit/86543ac47e59c522976b5632b8bf9a2a4583c7d2) allows attackers to potentially execute arbitrary code via crafted JavaScript. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected.", "other": {"cve": {"id": "CVE-2020-1896", "sourceIdentifier": "cve-assign@fb.com", "published": "2021-02-02T07:15:13.333", "lastModified": "2021-03-26T19:17:17.620", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A stack overflow vulnerability in Facebook Hermes 'builtin apply' prior to commit 86543ac47e59c522976b5632b8bf9a2a4583c7d2 (https://github.com/facebook/hermes/commit/86543ac47e59c522976b5632b8bf9a2a4583c7d2) allows attackers to potentially execute arbitrary code via crafted JavaScript. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected."}, {"lang": "es", "value": "Una vulnerabilidad de desbordamiento de la pila en Facebook Hermes 'builtin apply' anterior al commit 86543ac47e59c522976b5632b8bf9a2a4583c7d2 (https://github.com/facebook/hermes/commit/86543ac47e59c522976b5632b8bf9a2a4583c7d2) permite ejecutar un JavaScript potencialmente arbitrario. Tome en cuenta que esto solo es explotable si la aplicaci\u00f3n que usa Hermes permite una evaluaci\u00f3n de JavaScript no confiable. Por lo tanto, la mayor\u00eda de las aplicaciones React Native no est\u00e1n afectadas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-121"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hermes:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.5.0", "matchCriteriaId": "CD236EB4-8261-478C-8244-5E4646753E44"}]}]}], "references": [{"url": "https://github.com/facebook/hermes/commit/86543ac47e59c522976b5632b8bf9a2a4583c7d2", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.facebook.com/security/advisories/cve-2020-1896", "source": "cve-assign@fb.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/facebook/hermes/commit/86543ac47e59c522976b5632b8bf9a2a4583c7d2"}}