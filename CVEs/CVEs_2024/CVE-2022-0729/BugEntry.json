{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * Backtracking regular expression implementation.\n *\n * This file is included in \"regexp.c\".\n *\n * NOTICE:\n *\n * This is NOT the original regular expression code as written by Henry\n * Spencer.  This code has been modified specifically for use with the VIM\n * editor, and should not be used separately from Vim.  If you want a good\n * regular expression library, get the original code.  The copyright notice\n * that follows is from the original.\n *\n * END NOTICE\n *\n *\tCopyright (c) 1986 by University of Toronto.\n *\tWritten by Henry Spencer.  Not derived from licensed software.\n *\n *\tPermission is granted to anyone to use this software for any\n *\tpurpose on any computer system, and to redistribute it freely,\n *\tsubject to the following restrictions:\n *\n *\t1. The author is not responsible for the consequences of use of\n *\t\tthis software, no matter how awful, even if they arise\n *\t\tfrom defects in it.\n *\n *\t2. The origin of this software must not be misrepresented, either\n *\t\tby explicit claim or by omission.\n *\n *\t3. Altered versions must be plainly marked as such, and must not\n *\t\tbe misrepresented as being the original software.\n *\n * Beware that some of this code is subtly aware of the way operator\n * precedence is structured in regular expressions.  Serious changes in\n * regular-expression syntax might require a total rethink.\n *\n * Changes have been made by Tony Andrews, Olaf 'Rhialto' Seibert, Robert\n * Webb, Ciaran McCreesh and Bram Moolenaar.\n * Named character class support added by Walter Briscoe (1998 Jul 01)\n */\n\n/*\n * The \"internal use only\" fields in regexp.h are present to pass info from\n * compile to execute that permits the execute phase to run lots faster on\n * simple cases.  They are:\n *\n * regstart\tchar that must begin a match; NUL if none obvious; Can be a\n *\t\tmulti-byte character.\n * reganch\tis the match anchored (at beginning-of-line only)?\n * regmust\tstring (pointer into program) that match must include, or NULL\n * regmlen\tlength of regmust string\n * regflags\tRF_ values or'ed together\n *\n * Regstart and reganch permit very fast decisions on suitable starting points\n * for a match, cutting down the work a lot.  Regmust permits fast rejection\n * of lines that cannot possibly match.  The regmust tests are costly enough\n * that vim_regcomp() supplies a regmust only if the r.e. contains something\n * potentially expensive (at present, the only such thing detected is * or +\n * at the start of the r.e., which can involve a lot of backup).  Regmlen is\n * supplied because the test in vim_regexec() needs it and vim_regcomp() is\n * computing it anyway.\n */\n\n/*\n * Structure for regexp \"program\".  This is essentially a linear encoding\n * of a nondeterministic finite-state machine (aka syntax charts or\n * \"railroad normal form\" in parsing technology).  Each node is an opcode\n * plus a \"next\" pointer, possibly plus an operand.  \"Next\" pointers of\n * all nodes except BRANCH and BRACES_COMPLEX implement concatenation; a \"next\"\n * pointer with a BRANCH on both ends of it is connecting two alternatives.\n * (Here we have one of the subtle syntax dependencies:\tan individual BRANCH\n * (as opposed to a collection of them) is never concatenated with anything\n * because of operator precedence).  The \"next\" pointer of a BRACES_COMPLEX\n * node points to the node after the stuff to be repeated.\n * The operand of some types of node is a literal string; for others, it is a\n * node leading into a sub-FSM.  In particular, the operand of a BRANCH node\n * is the first node of the branch.\n * (NB this is *not* a tree structure: the tail of the branch connects to the\n * thing following the set of BRANCHes.)\n *\n * pattern\tis coded like:\n *\n *\t\t\t  +-----------------+\n *\t\t\t  |\t\t    V\n * <aa>\\|<bb>\tBRANCH <aa> BRANCH <bb> --> END\n *\t\t     |\t    ^\t |\t    ^\n *\t\t     +------+\t +----------+\n *\n *\n *\t\t       +------------------+\n *\t\t       V\t\t  |\n * <aa>*\tBRANCH BRANCH <aa> --> BACK BRANCH --> NOTHING --> END\n *\t\t     |\t    |\t\t    ^\t\t\t   ^\n *\t\t     |\t    +---------------+\t\t\t   |\n *\t\t     +---------------------------------------------+\n *\n *\n *\t\t       +----------------------+\n *\t\t       V\t\t      |\n * <aa>\\+\tBRANCH <aa> --> BRANCH --> BACK  BRANCH --> NOTHING --> END\n *\t\t     |\t\t     |\t\t ^\t\t\t^\n *\t\t     |\t\t     +-----------+\t\t\t|\n *\t\t     +--------------------------------------------------+\n *\n *\n *\t\t\t\t\t+-------------------------+\n *\t\t\t\t\tV\t\t\t  |\n * <aa>\\{}\tBRANCH BRACE_LIMITS --> BRACE_COMPLEX <aa> --> BACK  END\n *\t\t     |\t\t\t\t    |\t\t     ^\n *\t\t     |\t\t\t\t    +----------------+\n *\t\t     +-----------------------------------------------+\n *\n *\n * <aa>\\@!<bb>\tBRANCH NOMATCH <aa> --> END  <bb> --> END\n *\t\t     |\t     |\t\t      ^       ^\n *\t\t     |\t     +----------------+       |\n *\t\t     +--------------------------------+\n *\n *\t\t\t\t\t\t      +---------+\n *\t\t\t\t\t\t      |\t\tV\n * \\z[abc]\tBRANCH BRANCH  a  BRANCH  b  BRANCH  c\tBRANCH\tNOTHING --> END\n *\t\t     |\t    |\t       |\t  |\t^\t\t    ^\n *\t\t     |\t    |\t       |\t  +-----+\t\t    |\n *\t\t     |\t    |\t       +----------------+\t\t    |\n *\t\t     |\t    +---------------------------+\t\t    |\n *\t\t     +------------------------------------------------------+\n *\n * They all start with a BRANCH for \"\\|\" alternatives, even when there is only\n * one alternative.\n */\n\n/*\n * The opcodes are:\n */\n\n// definition\tnumber\t\t   opnd?    meaning\n#define END\t\t0\t//\tEnd of program or NOMATCH operand.\n#define BOL\t\t1\t//\tMatch \"\" at beginning of line.\n#define EOL\t\t2\t//\tMatch \"\" at end of line.\n#define BRANCH\t\t3\t// node Match this alternative, or the\n\t\t\t\t//\tnext...\n#define BACK\t\t4\t//\tMatch \"\", \"next\" ptr points backward.\n#define EXACTLY\t\t5\t// str\tMatch this string.\n#define NOTHING\t\t6\t//\tMatch empty string.\n#define STAR\t\t7\t// node Match this (simple) thing 0 or more\n\t\t\t\t//\ttimes.\n#define PLUS\t\t8\t// node Match this (simple) thing 1 or more\n\t\t\t\t//\ttimes.\n#define MATCH\t\t9\t// node match the operand zero-width\n#define NOMATCH\t\t10\t// node check for no match with operand\n#define BEHIND\t\t11\t// node look behind for a match with operand\n#define NOBEHIND\t12\t// node look behind for no match with operand\n#define SUBPAT\t\t13\t// node match the operand here\n#define BRACE_SIMPLE\t14\t// node Match this (simple) thing between m and\n\t\t\t\t//\tn times (\\{m,n\\}).\n#define BOW\t\t15\t//\tMatch \"\" after [^a-zA-Z0-9_]\n#define EOW\t\t16\t//\tMatch \"\" at    [^a-zA-Z0-9_]\n#define BRACE_LIMITS\t17\t// nr nr  define the min & max for BRACE_SIMPLE\n\t\t\t\t//\tand BRACE_COMPLEX.\n#define NEWL\t\t18\t//\tMatch line-break\n#define BHPOS\t\t19\t//\tEnd position for BEHIND or NOBEHIND\n\n\n// character classes: 20-48 normal, 50-78 include a line-break\n#define ADD_NL\t\t30\n#define FIRST_NL\tANY + ADD_NL\n#define ANY\t\t20\t//\tMatch any one character.\n#define ANYOF\t\t21\t// str\tMatch any character in this string.\n#define ANYBUT\t\t22\t// str\tMatch any character not in this\n\t\t\t\t//\tstring.\n#define IDENT\t\t23\t//\tMatch identifier char\n#define SIDENT\t\t24\t//\tMatch identifier char but no digit\n#define KWORD\t\t25\t//\tMatch keyword char\n#define SKWORD\t\t26\t//\tMatch word char but no digit\n#define FNAME\t\t27\t//\tMatch file name char\n#define SFNAME\t\t28\t//\tMatch file name char but no digit\n#define PRINT\t\t29\t//\tMatch printable char\n#define SPRINT\t\t30\t//\tMatch printable char but no digit\n#define WHITE\t\t31\t//\tMatch whitespace char\n#define NWHITE\t\t32\t//\tMatch non-whitespace char\n#define DIGIT\t\t33\t//\tMatch digit char\n#define NDIGIT\t\t34\t//\tMatch non-digit char\n#define HEX\t\t35\t//\tMatch hex char\n#define NHEX\t\t36\t//\tMatch non-hex char\n#define OCTAL\t\t37\t//\tMatch octal char\n#define NOCTAL\t\t38\t//\tMatch non-octal char\n#define WORD\t\t39\t//\tMatch word char\n#define NWORD\t\t40\t//\tMatch non-word char\n#define HEAD\t\t41\t//\tMatch head char\n#define NHEAD\t\t42\t//\tMatch non-head char\n#define ALPHA\t\t43\t//\tMatch alpha char\n#define NALPHA\t\t44\t//\tMatch non-alpha char\n#define LOWER\t\t45\t//\tMatch lowercase char\n#define NLOWER\t\t46\t//\tMatch non-lowercase char\n#define UPPER\t\t47\t//\tMatch uppercase char\n#define NUPPER\t\t48\t//\tMatch non-uppercase char\n#define LAST_NL\t\tNUPPER + ADD_NL\n#define WITH_NL(op)\t((op) >= FIRST_NL && (op) <= LAST_NL)\n\n#define MOPEN\t\t80  // -89\t Mark this point in input as start of\n\t\t\t\t//\t \\( subexpr.  MOPEN + 0 marks start of\n\t\t\t\t//\t match.\n#define MCLOSE\t\t90  // -99\t Analogous to MOPEN.  MCLOSE + 0 marks\n\t\t\t\t//\t end of match.\n#define BACKREF\t\t100 // -109 node Match same string again \\1-\\9\n\n#ifdef FEAT_SYN_HL\n# define ZOPEN\t\t110 // -119\t Mark this point in input as start of\n\t\t\t\t//\t \\z( subexpr.\n# define ZCLOSE\t\t120 // -129\t Analogous to ZOPEN.\n# define ZREF\t\t130 // -139 node Match external submatch \\z1-\\z9\n#endif\n\n#define BRACE_COMPLEX\t140 // -149 node Match nodes between m & n times\n\n#define NOPEN\t\t150\t//\tMark this point in input as start of\n\t\t\t\t//\t\\%( subexpr.\n#define NCLOSE\t\t151\t//\tAnalogous to NOPEN.\n\n#define MULTIBYTECODE\t200\t// mbc\tMatch one multi-byte character\n#define RE_BOF\t\t201\t//\tMatch \"\" at beginning of file.\n#define RE_EOF\t\t202\t//\tMatch \"\" at end of file.\n#define CURSOR\t\t203\t//\tMatch location of cursor.\n\n#define RE_LNUM\t\t204\t// nr cmp  Match line number\n#define RE_COL\t\t205\t// nr cmp  Match column number\n#define RE_VCOL\t\t206\t// nr cmp  Match virtual column number\n\n#define RE_MARK\t\t207\t// mark cmp  Match mark position\n#define RE_VISUAL\t208\t//\tMatch Visual area\n#define RE_COMPOSING\t209\t// any composing characters\n\n/*\n * Flags to be passed up and down.\n */\n#define HASWIDTH\t0x1\t// Known never to match null string.\n#define SIMPLE\t\t0x2\t// Simple enough to be STAR/PLUS operand.\n#define SPSTART\t\t0x4\t// Starts with * or +.\n#define HASNL\t\t0x8\t// Contains some \\n.\n#define HASLOOKBH\t0x10\t// Contains \"\\@<=\" or \"\\@<!\".\n#define WORST\t\t0\t// Worst case.\n\nstatic int\tnum_complex_braces; // Complex \\{...} count\nstatic char_u\t*regcode;\t// Code-emit pointer, or JUST_CALC_SIZE\nstatic long\tregsize;\t// Code size.\nstatic int\treg_toolong;\t// TRUE when offset out of range\nstatic char_u\thad_endbrace[NSUBEXP];\t// flags, TRUE if end of () found\nstatic long\tbrace_min[10];\t// Minimums for complex brace repeats\nstatic long\tbrace_max[10];\t// Maximums for complex brace repeats\nstatic int\tbrace_count[10]; // Current counts for complex brace repeats\nstatic int\tone_exactly = FALSE;\t// only do one char for EXACTLY\n\n// When making changes to classchars also change nfa_classcodes.\nstatic char_u\t*classchars = (char_u *)\".iIkKfFpPsSdDxXoOwWhHaAlLuU\";\nstatic int\tclasscodes[] = {\n    ANY, IDENT, SIDENT, KWORD, SKWORD,\n    FNAME, SFNAME, PRINT, SPRINT,\n    WHITE, NWHITE, DIGIT, NDIGIT,\n    HEX, NHEX, OCTAL, NOCTAL,\n    WORD, NWORD, HEAD, NHEAD,\n    ALPHA, NALPHA, LOWER, NLOWER,\n    UPPER, NUPPER\n};\n\n/*\n * When regcode is set to this value, code is not emitted and size is computed\n * instead.\n */\n#define JUST_CALC_SIZE\t((char_u *) -1)\n\n// Values for rs_state in regitem_T.\ntypedef enum regstate_E\n{\n    RS_NOPEN = 0\t// NOPEN and NCLOSE\n    , RS_MOPEN\t\t// MOPEN + [0-9]\n    , RS_MCLOSE\t\t// MCLOSE + [0-9]\n#ifdef FEAT_SYN_HL\n    , RS_ZOPEN\t\t// ZOPEN + [0-9]\n    , RS_ZCLOSE\t\t// ZCLOSE + [0-9]\n#endif\n    , RS_BRANCH\t\t// BRANCH\n    , RS_BRCPLX_MORE\t// BRACE_COMPLEX and trying one more match\n    , RS_BRCPLX_LONG\t// BRACE_COMPLEX and trying longest match\n    , RS_BRCPLX_SHORT\t// BRACE_COMPLEX and trying shortest match\n    , RS_NOMATCH\t// NOMATCH\n    , RS_BEHIND1\t// BEHIND / NOBEHIND matching rest\n    , RS_BEHIND2\t// BEHIND / NOBEHIND matching behind part\n    , RS_STAR_LONG\t// STAR/PLUS/BRACE_SIMPLE longest match\n    , RS_STAR_SHORT\t// STAR/PLUS/BRACE_SIMPLE shortest match\n} regstate_T;\n\n/*\n * Structure used to save the current input state, when it needs to be\n * restored after trying a match.  Used by reg_save() and reg_restore().\n * Also stores the length of \"backpos\".\n */\ntypedef struct\n{\n    union\n    {\n\tchar_u\t*ptr;\t// rex.input pointer, for single-line regexp\n\tlpos_T\tpos;\t// rex.input pos, for multi-line regexp\n    } rs_u;\n    int\t\trs_len;\n} regsave_T;\n\n// struct to save start/end pointer/position in for \\(\\)\ntypedef struct\n{\n    union\n    {\n\tchar_u\t*ptr;\n\tlpos_T\tpos;\n    } se_u;\n} save_se_T;\n\n// used for BEHIND and NOBEHIND matching\ntypedef struct regbehind_S\n{\n    regsave_T\tsave_after;\n    regsave_T\tsave_behind;\n    int\t\tsave_need_clear_subexpr;\n    save_se_T   save_start[NSUBEXP];\n    save_se_T   save_end[NSUBEXP];\n} regbehind_T;\n\n/*\n * When there are alternatives a regstate_T is put on the regstack to remember\n * what we are doing.\n * Before it may be another type of item, depending on rs_state, to remember\n * more things.\n */\ntypedef struct regitem_S\n{\n    regstate_T\trs_state;\t// what we are doing, one of RS_ above\n    short\trs_no;\t\t// submatch nr or BEHIND/NOBEHIND\n    char_u\t*rs_scan;\t// current node in program\n    union\n    {\n\tsave_se_T  sesave;\n\tregsave_T  regsave;\n    } rs_un;\t\t\t// room for saving rex.input\n} regitem_T;\n\n\n// used for STAR, PLUS and BRACE_SIMPLE matching\ntypedef struct regstar_S\n{\n    int\t\tnextb;\t\t// next byte\n    int\t\tnextb_ic;\t// next byte reverse case\n    long\tcount;\n    long\tminval;\n    long\tmaxval;\n} regstar_T;\n\n// used to store input position when a BACK was encountered, so that we now if\n// we made any progress since the last time.\ntypedef struct backpos_S\n{\n    char_u\t*bp_scan;\t// \"scan\" where BACK was encountered\n    regsave_T\tbp_pos;\t\t// last input position\n} backpos_T;\n\n/*\n * \"regstack\" and \"backpos\" are used by regmatch().  They are kept over calls\n * to avoid invoking malloc() and free() often.\n * \"regstack\" is a stack with regitem_T items, sometimes preceded by regstar_T\n * or regbehind_T.\n * \"backpos_T\" is a table with backpos_T for BACK\n */\nstatic garray_T\tregstack = {0, 0, 0, 0, NULL};\nstatic garray_T\tbackpos = {0, 0, 0, 0, NULL};\n\nstatic regsave_T behind_pos;\n\n/*\n * Both for regstack and backpos tables we use the following strategy of\n * allocation (to reduce malloc/free calls):\n * - Initial size is fairly small.\n * - When needed, the tables are grown bigger (8 times at first, double after\n *   that).\n * - After executing the match we free the memory only if the array has grown.\n *   Thus the memory is kept allocated when it's at the initial size.\n * This makes it fast while not keeping a lot of memory allocated.\n * A three times speed increase was observed when using many simple patterns.\n */\n#define REGSTACK_INITIAL\t2048\n#define BACKPOS_INITIAL\t\t64\n\n/*\n * Opcode notes:\n *\n * BRANCH\tThe set of branches constituting a single choice are hooked\n *\t\ttogether with their \"next\" pointers, since precedence prevents\n *\t\tanything being concatenated to any individual branch.  The\n *\t\t\"next\" pointer of the last BRANCH in a choice points to the\n *\t\tthing following the whole choice.  This is also where the\n *\t\tfinal \"next\" pointer of each individual branch points; each\n *\t\tbranch starts with the operand node of a BRANCH node.\n *\n * BACK\t\tNormal \"next\" pointers all implicitly point forward; BACK\n *\t\texists to make loop structures possible.\n *\n * STAR,PLUS\t'=', and complex '*' and '+', are implemented as circular\n *\t\tBRANCH structures using BACK.  Simple cases (one character\n *\t\tper match) are implemented with STAR and PLUS for speed\n *\t\tand to minimize recursive plunges.\n *\n * BRACE_LIMITS\tThis is always followed by a BRACE_SIMPLE or BRACE_COMPLEX\n *\t\tnode, and defines the min and max limits to be used for that\n *\t\tnode.\n *\n * MOPEN,MCLOSE\t...are numbered at compile time.\n * ZOPEN,ZCLOSE\t...ditto\n */\n\n/*\n * A node is one char of opcode followed by two chars of \"next\" pointer.\n * \"Next\" pointers are stored as two 8-bit bytes, high order first.  The\n * value is a positive offset from the opcode of the node containing it.\n * An operand, if any, simply follows the node.  (Note that much of the\n * code generation knows about this implicit relationship.)\n *\n * Using two bytes for the \"next\" pointer is vast overkill for most things,\n * but allows patterns to get big without disasters.\n */\n#define OP(p)\t\t((int)*(p))\n#define NEXT(p)\t\t(((*((p) + 1) & 0377) << 8) + (*((p) + 2) & 0377))\n#define OPERAND(p)\t((p) + 3)\n// Obtain an operand that was stored as four bytes, MSB first.\n#define OPERAND_MIN(p)\t(((long)(p)[3] << 24) + ((long)(p)[4] << 16) \\\n\t\t\t+ ((long)(p)[5] << 8) + (long)(p)[6])\n// Obtain a second operand stored as four bytes.\n#define OPERAND_MAX(p)\tOPERAND_MIN((p) + 4)\n// Obtain a second single-byte operand stored after a four bytes operand.\n#define OPERAND_CMP(p)\t(p)[7]\n\nstatic char_u *reg(int paren, int *flagp);\n\n#ifdef BT_REGEXP_DUMP\nstatic void\tregdump(char_u *, bt_regprog_T *);\n#endif\n\nstatic int\tre_num_cmp(long_u val, char_u *scan);\n\n#ifdef DEBUG\nstatic char_u\t*regprop(char_u *);\n\nstatic int\tregnarrate = 0;\n#endif\n\n\n/*\n * Setup to parse the regexp.  Used once to get the length and once to do it.\n */\n    static void\nregcomp_start(\n    char_u\t*expr,\n    int\t\tre_flags)\t    // see vim_regcomp()\n{\n    initchr(expr);\n    if (re_flags & RE_MAGIC)\n\treg_magic = MAGIC_ON;\n    else\n\treg_magic = MAGIC_OFF;\n    reg_string = (re_flags & RE_STRING);\n    reg_strict = (re_flags & RE_STRICT);\n    get_cpo_flags();\n\n    num_complex_braces = 0;\n    regnpar = 1;\n    CLEAR_FIELD(had_endbrace);\n#ifdef FEAT_SYN_HL\n    regnzpar = 1;\n    re_has_z = 0;\n#endif\n    regsize = 0L;\n    reg_toolong = FALSE;\n    regflags = 0;\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n    had_eol = FALSE;\n#endif\n}\n\n/*\n * Return TRUE if MULTIBYTECODE should be used instead of EXACTLY for\n * character \"c\".\n */\n    static int\nuse_multibytecode(int c)\n{\n    return has_mbyte && (*mb_char2len)(c) > 1\n\t\t     && (re_multi_type(peekchr()) != NOT_MULTI\n\t\t\t     || (enc_utf8 && utf_iscomposing(c)));\n}\n\n/*\n * Emit (if appropriate) a byte of code\n */\n    static void\nregc(int b)\n{\n    if (regcode == JUST_CALC_SIZE)\n\tregsize++;\n    else\n\t*regcode++ = b;\n}\n\n/*\n * Emit (if appropriate) a multi-byte character of code\n */\n    static void\nregmbc(int c)\n{\n    if (!has_mbyte && c > 0xff)\n\treturn;\n    if (regcode == JUST_CALC_SIZE)\n\tregsize += (*mb_char2len)(c);\n    else\n\tregcode += (*mb_char2bytes)(c, regcode);\n}\n\n\n/*\n * Produce the bytes for equivalence class \"c\".\n * Currently only handles latin1, latin9 and utf-8.\n * NOTE: When changing this function, also change nfa_emit_equi_class()\n */\n    static void\nreg_equi_class(int c)\n{\n    if (enc_utf8 || STRCMP(p_enc, \"latin1\") == 0\n\t\t\t\t\t || STRCMP(p_enc, \"iso-8859-15\") == 0)\n    {\n\tswitch (c)\n\t{\n\t    // Do not use '\\300' style, it results in a negative number.\n\t    case 'A': case 0xc0: case 0xc1: case 0xc2: case 0xc3: case 0xc4:\n\t    case 0xc5: case 0x100: case 0x102: case 0x104: case 0x1cd:\n\t    case 0x1de: case 0x1e0: case 0x1fa: case 0x202: case 0x226:\n\t    case 0x23a: case 0x1e00: case 0x1ea0: case 0x1ea2: case 0x1ea4:\n\t    case 0x1ea6: case 0x1ea8: case 0x1eaa: case 0x1eac: case 0x1eae:\n\t    case 0x1eb0: case 0x1eb2: case 0x1eb4: case 0x1eb6:\n\t\t      regmbc('A'); regmbc(0xc0); regmbc(0xc1); regmbc(0xc2);\n\t\t      regmbc(0xc3); regmbc(0xc4); regmbc(0xc5);\n\t\t      regmbc(0x100); regmbc(0x102); regmbc(0x104);\n\t\t      regmbc(0x1cd); regmbc(0x1de); regmbc(0x1e0);\n\t\t      regmbc(0x1fa); regmbc(0x202); regmbc(0x226);\n\t\t      regmbc(0x23a); regmbc(0x1e00); regmbc(0x1ea0);\n\t\t      regmbc(0x1ea2); regmbc(0x1ea4); regmbc(0x1ea6);\n\t\t      regmbc(0x1ea8); regmbc(0x1eaa); regmbc(0x1eac);\n\t\t      regmbc(0x1eae); regmbc(0x1eb0); regmbc(0x1eb2);\n\t\t      regmbc(0x1eb4); regmbc(0x1eb6);\n\t\t      return;\n\t    case 'B': case 0x181: case 0x243: case 0x1e02:\n\t    case 0x1e04: case 0x1e06:\n\t\t      regmbc('B');\n\t\t      regmbc(0x181); regmbc(0x243); regmbc(0x1e02);\n\t\t      regmbc(0x1e04); regmbc(0x1e06);\n\t\t      return;\n\t    case 'C': case 0xc7:\n\t    case 0x106: case 0x108: case 0x10a: case 0x10c: case 0x187:\n\t    case 0x23b: case 0x1e08: case 0xa792:\n\t\t      regmbc('C'); regmbc(0xc7);\n\t\t      regmbc(0x106); regmbc(0x108); regmbc(0x10a);\n\t\t      regmbc(0x10c); regmbc(0x187); regmbc(0x23b);\n\t\t      regmbc(0x1e08); regmbc(0xa792);\n\t\t      return;\n\t    case 'D': case 0x10e: case 0x110: case 0x18a:\n\t    case 0x1e0a: case 0x1e0c: case 0x1e0e: case 0x1e10:\n\t    case 0x1e12:\n\t\t      regmbc('D'); regmbc(0x10e); regmbc(0x110);\n\t\t      regmbc(0x18a); regmbc(0x1e0a); regmbc(0x1e0c);\n\t\t      regmbc(0x1e0e); regmbc(0x1e10); regmbc(0x1e12);\n\t\t      return;\n\t    case 'E': case 0xc8: case 0xc9: case 0xca: case 0xcb:\n\t    case 0x112: case 0x114: case 0x116: case 0x118: case 0x11a:\n\t    case 0x204: case 0x206: case 0x228: case 0x246: case 0x1e14:\n\t    case 0x1e16: case 0x1e18: case 0x1e1a: case 0x1e1c:\n\t    case 0x1eb8: case 0x1eba: case 0x1ebc: case 0x1ebe:\n\t    case 0x1ec0: case 0x1ec2: case 0x1ec4: case 0x1ec6:\n\t\t      regmbc('E'); regmbc(0xc8); regmbc(0xc9);\n\t\t      regmbc(0xca); regmbc(0xcb); regmbc(0x112);\n\t\t      regmbc(0x114); regmbc(0x116); regmbc(0x118);\n\t\t      regmbc(0x11a); regmbc(0x204); regmbc(0x206);\n\t\t      regmbc(0x228); regmbc(0x246); regmbc(0x1e14);\n\t\t      regmbc(0x1e16); regmbc(0x1e18); regmbc(0x1e1a);\n\t\t      regmbc(0x1e1c); regmbc(0x1eb8); regmbc(0x1eba);\n\t\t      regmbc(0x1ebc); regmbc(0x1ebe); regmbc(0x1ec0);\n\t\t      regmbc(0x1ec2); regmbc(0x1ec4); regmbc(0x1ec6);\n\t\t      return;\n\t    case 'F': case 0x191: case 0x1e1e: case 0xa798:\n\t\t      regmbc('F'); regmbc(0x191); regmbc(0x1e1e);\n\t\t      regmbc(0xa798);\n\t\t      return;\n\t    case 'G': case 0x11c: case 0x11e: case 0x120:\n\t    case 0x122: case 0x193: case 0x1e4: case 0x1e6:\n\t    case 0x1f4: case 0x1e20: case 0xa7a0:\n\t\t      regmbc('G'); regmbc(0x11c); regmbc(0x11e);\n\t\t      regmbc(0x120); regmbc(0x122); regmbc(0x193);\n\t\t      regmbc(0x1e4); regmbc(0x1e6); regmbc(0x1f4);\n\t\t      regmbc(0x1e20); regmbc(0xa7a0);\n\t\t      return;\n\t    case 'H': case 0x124: case 0x126: case 0x21e:\n\t    case 0x1e22: case 0x1e24: case 0x1e26:\n\t    case 0x1e28: case 0x1e2a: case 0x2c67:\n\t\t      regmbc('H'); regmbc(0x124); regmbc(0x126);\n\t\t      regmbc(0x21e); regmbc(0x1e22); regmbc(0x1e24);\n\t\t      regmbc(0x1e26); regmbc(0x1e28); regmbc(0x1e2a);\n\t\t      regmbc(0x2c67);\n\t\t      return;\n\t    case 'I': case 0xcc: case 0xcd: case 0xce: case 0xcf:\n\t    case 0x128: case 0x12a: case 0x12c: case 0x12e:\n\t    case 0x130: case 0x197: case 0x1cf: case 0x208:\n\t    case 0x20a: case 0x1e2c: case 0x1e2e: case 0x1ec8:\n\t    case 0x1eca:\n\t\t      regmbc('I'); regmbc(0xcc); regmbc(0xcd);\n\t\t      regmbc(0xce); regmbc(0xcf); regmbc(0x128);\n\t\t      regmbc(0x12a); regmbc(0x12c); regmbc(0x12e);\n\t\t      regmbc(0x130); regmbc(0x197); regmbc(0x1cf);\n\t\t      regmbc(0x208); regmbc(0x20a); regmbc(0x1e2c);\n\t\t      regmbc(0x1e2e); regmbc(0x1ec8); regmbc(0x1eca);\n\t\t      return;\n\t    case 'J': case 0x134: case 0x248:\n\t\t      regmbc('J'); regmbc(0x134); regmbc(0x248);\n\t\t      return;\n\t    case 'K': case 0x136: case 0x198: case 0x1e8: case 0x1e30:\n\t    case 0x1e32: case 0x1e34: case 0x2c69: case 0xa740:\n\t\t      regmbc('K'); regmbc(0x136); regmbc(0x198);\n\t\t      regmbc(0x1e8); regmbc(0x1e30); regmbc(0x1e32);\n\t\t      regmbc(0x1e34); regmbc(0x2c69); regmbc(0xa740);\n\t\t      return;\n\t    case 'L': case 0x139: case 0x13b: case 0x13d: case 0x13f:\n\t    case 0x141: case 0x23d: case 0x1e36: case 0x1e38:\n\t    case 0x1e3a: case 0x1e3c: case 0x2c60:\n\t\t      regmbc('L'); regmbc(0x139); regmbc(0x13b);\n\t\t      regmbc(0x13d); regmbc(0x13f); regmbc(0x141);\n\t\t      regmbc(0x23d); regmbc(0x1e36); regmbc(0x1e38);\n\t\t      regmbc(0x1e3a); regmbc(0x1e3c); regmbc(0x2c60);\n\t\t      return;\n\t    case 'M': case 0x1e3e: case 0x1e40: case 0x1e42:\n\t\t      regmbc('M'); regmbc(0x1e3e); regmbc(0x1e40);\n\t\t      regmbc(0x1e42);\n\t\t      return;\n\t    case 'N': case 0xd1:\n\t    case 0x143: case 0x145: case 0x147: case 0x1f8:\n\t    case 0x1e44: case 0x1e46: case 0x1e48: case 0x1e4a:\n\t    case 0xa7a4:\n\t\t      regmbc('N'); regmbc(0xd1);\n\t\t      regmbc(0x143); regmbc(0x145); regmbc(0x147);\n\t\t      regmbc(0x1f8); regmbc(0x1e44); regmbc(0x1e46);\n\t\t      regmbc(0x1e48); regmbc(0x1e4a); regmbc(0xa7a4);\n\t\t      return;\n\t    case 'O': case 0xd2: case 0xd3: case 0xd4: case 0xd5: case 0xd6:\n\t    case 0xd8: case 0x14c: case 0x14e: case 0x150: case 0x19f:\n\t    case 0x1a0: case 0x1d1: case 0x1ea: case 0x1ec: case 0x1fe:\n\t    case 0x20c: case 0x20e: case 0x22a: case 0x22c: case 0x22e:\n\t    case 0x230: case 0x1e4c: case 0x1e4e: case 0x1e50: case 0x1e52:\n\t    case 0x1ecc: case 0x1ece: case 0x1ed0: case 0x1ed2: case 0x1ed4:\n\t    case 0x1ed6: case 0x1ed8: case 0x1eda: case 0x1edc: case 0x1ede:\n\t    case 0x1ee0: case 0x1ee2:\n\t\t      regmbc('O'); regmbc(0xd2); regmbc(0xd3); regmbc(0xd4);\n\t\t      regmbc(0xd5); regmbc(0xd6); regmbc(0xd8);\n\t\t      regmbc(0x14c); regmbc(0x14e); regmbc(0x150);\n\t\t      regmbc(0x19f); regmbc(0x1a0); regmbc(0x1d1);\n\t\t      regmbc(0x1ea); regmbc(0x1ec); regmbc(0x1fe);\n\t\t      regmbc(0x20c); regmbc(0x20e); regmbc(0x22a);\n\t\t      regmbc(0x22c); regmbc(0x22e); regmbc(0x230);\n\t\t      regmbc(0x1e4c); regmbc(0x1e4e); regmbc(0x1e50);\n\t\t      regmbc(0x1e52); regmbc(0x1ecc); regmbc(0x1ece);\n\t\t      regmbc(0x1ed0); regmbc(0x1ed2); regmbc(0x1ed4);\n\t\t      regmbc(0x1ed6); regmbc(0x1ed8); regmbc(0x1eda);\n\t\t      regmbc(0x1edc); regmbc(0x1ede); regmbc(0x1ee0);\n\t\t      regmbc(0x1ee2);\n\t\t      return;\n\t    case 'P': case 0x1a4: case 0x1e54: case 0x1e56: case 0x2c63:\n\t\t      regmbc('P'); regmbc(0x1a4); regmbc(0x1e54);\n\t\t      regmbc(0x1e56); regmbc(0x2c63);\n\t\t      return;\n\t    case 'Q': case 0x24a:\n\t\t      regmbc('Q'); regmbc(0x24a);\n\t\t      return;\n\t    case 'R': case 0x154: case 0x156: case 0x158: case 0x210:\n\t    case 0x212: case 0x24c: case 0x1e58: case 0x1e5a:\n\t    case 0x1e5c: case 0x1e5e: case 0x2c64: case 0xa7a6:\n\t\t      regmbc('R'); regmbc(0x154); regmbc(0x156);\n\t\t      regmbc(0x210); regmbc(0x212); regmbc(0x158);\n\t\t      regmbc(0x24c); regmbc(0x1e58); regmbc(0x1e5a);\n\t\t      regmbc(0x1e5c); regmbc(0x1e5e); regmbc(0x2c64);\n\t\t      regmbc(0xa7a6);\n\t\t      return;\n\t    case 'S': case 0x15a: case 0x15c: case 0x15e: case 0x160:\n\t    case 0x218: case 0x1e60: case 0x1e62: case 0x1e64:\n\t    case 0x1e66: case 0x1e68: case 0x2c7e: case 0xa7a8:\n\t\t      regmbc('S'); regmbc(0x15a); regmbc(0x15c);\n\t\t      regmbc(0x15e); regmbc(0x160); regmbc(0x218);\n\t\t      regmbc(0x1e60); regmbc(0x1e62); regmbc(0x1e64);\n\t\t      regmbc(0x1e66); regmbc(0x1e68); regmbc(0x2c7e);\n\t\t\t  regmbc(0xa7a8);\n\t\t      return;\n\t    case 'T': case 0x162: case 0x164: case 0x166: case 0x1ac:\n\t    case 0x1ae: case 0x21a: case 0x23e: case 0x1e6a: case 0x1e6c:\n\t    case 0x1e6e: case 0x1e70:\n\t\t      regmbc('T'); regmbc(0x162); regmbc(0x164);\n\t\t      regmbc(0x166); regmbc(0x1ac); regmbc(0x23e);\n\t\t      regmbc(0x1ae); regmbc(0x21a); regmbc(0x1e6a);\n\t\t      regmbc(0x1e6c); regmbc(0x1e6e); regmbc(0x1e70);\n\t\t      return;\n\t    case 'U': case 0xd9: case 0xda: case 0xdb: case 0xdc:\n\t    case 0x168: case 0x16a: case 0x16c: case 0x16e:\n\t    case 0x170: case 0x172: case 0x1af: case 0x1d3:\n\t    case 0x1d5: case 0x1d7: case 0x1d9: case 0x1db:\n\t    case 0x214: case 0x216: case 0x244: case 0x1e72:\n\t    case 0x1e74: case 0x1e76: case 0x1e78: case 0x1e7a:\n\t    case 0x1ee4: case 0x1ee6: case 0x1ee8: case 0x1eea:\n\t    case 0x1eec: case 0x1eee: case 0x1ef0:\n\t\t      regmbc('U'); regmbc(0xd9); regmbc(0xda);\n\t\t      regmbc(0xdb); regmbc(0xdc); regmbc(0x168);\n\t\t      regmbc(0x16a); regmbc(0x16c); regmbc(0x16e);\n\t\t      regmbc(0x170); regmbc(0x172); regmbc(0x1af);\n\t\t      regmbc(0x1d3); regmbc(0x1d5); regmbc(0x1d7);\n\t\t      regmbc(0x1d9); regmbc(0x1db); regmbc(0x214);\n\t\t      regmbc(0x216); regmbc(0x244); regmbc(0x1e72);\n\t\t      regmbc(0x1e74); regmbc(0x1e76); regmbc(0x1e78);\n\t\t      regmbc(0x1e7a); regmbc(0x1ee4); regmbc(0x1ee6);\n\t\t      regmbc(0x1ee8); regmbc(0x1eea); regmbc(0x1eec);\n\t\t      regmbc(0x1eee); regmbc(0x1ef0);\n\t\t      return;\n\t    case 'V': case 0x1b2: case 0x1e7c: case 0x1e7e:\n\t\t      regmbc('V'); regmbc(0x1b2); regmbc(0x1e7c);\n\t\t      regmbc(0x1e7e);\n\t\t      return;\n\t    case 'W': case 0x174: case 0x1e80: case 0x1e82:\n\t    case 0x1e84: case 0x1e86: case 0x1e88:\n\t\t      regmbc('W'); regmbc(0x174); regmbc(0x1e80);\n\t\t      regmbc(0x1e82); regmbc(0x1e84); regmbc(0x1e86);\n\t\t      regmbc(0x1e88);\n\t\t      return;\n\t    case 'X': case 0x1e8a: case 0x1e8c:\n\t\t      regmbc('X'); regmbc(0x1e8a); regmbc(0x1e8c);\n\t\t      return;\n\t    case 'Y': case 0xdd:\n\t    case 0x176: case 0x178: case 0x1b3: case 0x232: case 0x24e:\n\t    case 0x1e8e: case 0x1ef2: case 0x1ef6: case 0x1ef4: case 0x1ef8:\n\t\t      regmbc('Y'); regmbc(0xdd); regmbc(0x176);\n\t\t      regmbc(0x178); regmbc(0x1b3); regmbc(0x232);\n\t\t      regmbc(0x24e); regmbc(0x1e8e); regmbc(0x1ef2);\n\t\t      regmbc(0x1ef4); regmbc(0x1ef6); regmbc(0x1ef8);\n\t\t      return;\n\t    case 'Z': case 0x179: case 0x17b: case 0x17d: case 0x1b5:\n\t    case 0x1e90: case 0x1e92: case 0x1e94: case 0x2c6b:\n\t\t      regmbc('Z'); regmbc(0x179); regmbc(0x17b);\n\t\t      regmbc(0x17d); regmbc(0x1b5); regmbc(0x1e90);\n\t\t      regmbc(0x1e92); regmbc(0x1e94); regmbc(0x2c6b);\n\t\t      return;\n\t    case 'a': case 0xe0: case 0xe1: case 0xe2:\n\t    case 0xe3: case 0xe4: case 0xe5: case 0x101: case 0x103:\n\t    case 0x105: case 0x1ce: case 0x1df: case 0x1e1: case 0x1fb:\n\t    case 0x201: case 0x203: case 0x227: case 0x1d8f: case 0x1e01:\n\t    case 0x1e9a: case 0x1ea1: case 0x1ea3: case 0x1ea5:\n\t    case 0x1ea7: case 0x1ea9: case 0x1eab: case 0x1ead:\n\t    case 0x1eaf: case 0x1eb1: case 0x1eb3: case 0x1eb5:\n\t    case 0x1eb7: case 0x2c65:\n\t\t      regmbc('a'); regmbc(0xe0); regmbc(0xe1);\n\t\t      regmbc(0xe2); regmbc(0xe3); regmbc(0xe4);\n\t\t      regmbc(0xe5); regmbc(0x101); regmbc(0x103);\n\t\t      regmbc(0x105); regmbc(0x1ce); regmbc(0x1df);\n\t\t      regmbc(0x1e1); regmbc(0x1fb); regmbc(0x201);\n\t\t      regmbc(0x203); regmbc(0x227); regmbc(0x1d8f);\n\t\t      regmbc(0x1e01); regmbc(0x1e9a); regmbc(0x1ea1);\n\t\t      regmbc(0x1ea3); regmbc(0x1ea5); regmbc(0x1ea7);\n\t\t      regmbc(0x1ea9); regmbc(0x1eab); regmbc(0x1ead);\n\t\t      regmbc(0x1eaf); regmbc(0x1eb1); regmbc(0x1eb3);\n\t\t      regmbc(0x1eb5); regmbc(0x1eb7); regmbc(0x2c65);\n\t\t      return;\n\t    case 'b': case 0x180: case 0x253: case 0x1d6c: case 0x1d80:\n\t    case 0x1e03: case 0x1e05: case 0x1e07:\n\t\t      regmbc('b');\n\t\t      regmbc(0x180); regmbc(0x253); regmbc(0x1d6c);\n\t\t      regmbc(0x1d80); regmbc(0x1e03); regmbc(0x1e05);\n\t\t      regmbc(0x1e07);\n\t\t      return;\n\t    case 'c': case 0xe7:\n\t    case 0x107: case 0x109: case 0x10b: case 0x10d: case 0x188:\n\t    case 0x23c: case 0x1e09: case 0xa793: case 0xa794:\n\t\t      regmbc('c'); regmbc(0xe7); regmbc(0x107);\n\t\t      regmbc(0x109); regmbc(0x10b); regmbc(0x10d);\n\t\t      regmbc(0x188); regmbc(0x23c); regmbc(0x1e09);\n\t\t      regmbc(0xa793); regmbc(0xa794);\n\t\t      return;\n\t    case 'd': case 0x10f: case 0x111: case 0x257: case 0x1d6d:\n\t    case 0x1d81: case 0x1d91: case 0x1e0b: case 0x1e0d:\n\t    case 0x1e0f: case 0x1e11: case 0x1e13:\n\t\t      regmbc('d'); regmbc(0x10f); regmbc(0x111);\n\t\t      regmbc(0x257); regmbc(0x1d6d); regmbc(0x1d81);\n\t\t      regmbc(0x1d91); regmbc(0x1e0b); regmbc(0x1e0d);\n\t\t      regmbc(0x1e0f); regmbc(0x1e11); regmbc(0x1e13);\n\t\t      return;\n\t    case 'e': case 0xe8: case 0xe9: case 0xea: case 0xeb:\n\t    case 0x113: case 0x115: case 0x117: case 0x119:\n\t    case 0x11b: case 0x205: case 0x207: case 0x229:\n\t    case 0x247: case 0x1d92: case 0x1e15: case 0x1e17:\n\t    case 0x1e19: case 0x1e1b: case 0x1eb9: case 0x1ebb:\n\t    case 0x1e1d: case 0x1ebd: case 0x1ebf: case 0x1ec1:\n\t    case 0x1ec3: case 0x1ec5: case 0x1ec7:\n\t\t      regmbc('e'); regmbc(0xe8); regmbc(0xe9);\n\t\t      regmbc(0xea); regmbc(0xeb); regmbc(0x113);\n\t\t      regmbc(0x115); regmbc(0x117); regmbc(0x119);\n\t\t      regmbc(0x11b); regmbc(0x205); regmbc(0x207);\n\t\t      regmbc(0x229); regmbc(0x247); regmbc(0x1d92);\n\t\t      regmbc(0x1e15); regmbc(0x1e17); regmbc(0x1e19);\n\t\t      regmbc(0x1e1b); regmbc(0x1e1d); regmbc(0x1eb9);\n\t\t      regmbc(0x1ebb); regmbc(0x1ebd); regmbc(0x1ebf);\n\t\t      regmbc(0x1ec1); regmbc(0x1ec3); regmbc(0x1ec5);\n\t\t      regmbc(0x1ec7);\n\t\t      return;\n\t    case 'f': case 0x192: case 0x1d6e: case 0x1d82:\n\t    case 0x1e1f: case 0xa799:\n\t\t     regmbc('f'); regmbc(0x192); regmbc(0x1d6e);\n\t\t     regmbc(0x1d82); regmbc(0x1e1f); regmbc(0xa799);\n\t\t     return;\n\t    case 'g': case 0x11d: case 0x11f: case 0x121: case 0x123:\n\t    case 0x1e5: case 0x1e7: case 0x260: case 0x1f5: case 0x1d83:\n\t    case 0x1e21: case 0xa7a1:\n\t\t      regmbc('g'); regmbc(0x11d); regmbc(0x11f);\n\t\t      regmbc(0x121); regmbc(0x123); regmbc(0x1e5);\n\t\t      regmbc(0x1e7); regmbc(0x1f5); regmbc(0x260);\n\t\t      regmbc(0x1d83); regmbc(0x1e21); regmbc(0xa7a1);\n\t\t      return;\n\t    case 'h': case 0x125: case 0x127: case 0x21f: case 0x1e23:\n\t    case 0x1e25: case 0x1e27: case 0x1e29: case 0x1e2b:\n\t    case 0x1e96: case 0x2c68: case 0xa795:\n\t\t      regmbc('h'); regmbc(0x125); regmbc(0x127);\n\t\t      regmbc(0x21f); regmbc(0x1e23); regmbc(0x1e25);\n\t\t      regmbc(0x1e27); regmbc(0x1e29); regmbc(0x1e2b);\n\t\t      regmbc(0x1e96); regmbc(0x2c68); regmbc(0xa795);\n\t\t      return;\n\t    case 'i': case 0xec: case 0xed: case 0xee: case 0xef:\n\t    case 0x129: case 0x12b: case 0x12d: case 0x12f:\n\t    case 0x1d0: case 0x209: case 0x20b: case 0x268:\n\t    case 0x1d96: case 0x1e2d: case 0x1e2f: case 0x1ec9:\n\t    case 0x1ecb:\n\t\t      regmbc('i'); regmbc(0xec); regmbc(0xed);\n\t\t      regmbc(0xee); regmbc(0xef); regmbc(0x129);\n\t\t      regmbc(0x12b); regmbc(0x12d); regmbc(0x12f);\n\t\t      regmbc(0x1d0); regmbc(0x209); regmbc(0x20b);\n\t\t      regmbc(0x268); regmbc(0x1d96); regmbc(0x1e2d);\n\t\t      regmbc(0x1e2f); regmbc(0x1ec9); regmbc(0x1ecb);\n\t\t      return;\n\t    case 'j': case 0x135: case 0x1f0: case 0x249:\n\t\t      regmbc('j'); regmbc(0x135); regmbc(0x1f0);\n\t\t      regmbc(0x249);\n\t\t      return;\n\t    case 'k': case 0x137: case 0x199: case 0x1e9:\n\t    case 0x1d84: case 0x1e31: case 0x1e33: case 0x1e35:\n\t    case 0x2c6a: case 0xa741:\n\t\t      regmbc('k'); regmbc(0x137); regmbc(0x199);\n\t\t      regmbc(0x1e9); regmbc(0x1d84); regmbc(0x1e31);\n\t\t      regmbc(0x1e33); regmbc(0x1e35); regmbc(0x2c6a);\n\t\t      regmbc(0xa741);\n\t\t      return;\n\t    case 'l': case 0x13a: case 0x13c: case 0x13e:\n\t    case 0x140: case 0x142: case 0x19a: case 0x1e37:\n\t    case 0x1e39: case 0x1e3b: case 0x1e3d: case 0x2c61:\n\t\t      regmbc('l'); regmbc(0x13a); regmbc(0x13c);\n\t\t      regmbc(0x13e); regmbc(0x140); regmbc(0x142);\n\t\t      regmbc(0x19a); regmbc(0x1e37); regmbc(0x1e39);\n\t\t      regmbc(0x1e3b); regmbc(0x1e3d); regmbc(0x2c61);\n\t\t      return;\n\t    case 'm': case 0x1d6f: case 0x1e3f: case 0x1e41: case 0x1e43:\n\t\t      regmbc('m'); regmbc(0x1d6f); regmbc(0x1e3f);\n\t\t      regmbc(0x1e41); regmbc(0x1e43);\n\t\t      return;\n\t    case 'n': case 0xf1: case 0x144: case 0x146: case 0x148:\n\t    case 0x149: case 0x1f9: case 0x1d70: case 0x1d87:\n\t    case 0x1e45: case 0x1e47: case 0x1e49: case 0x1e4b:\n\t    case 0xa7a5:\n\t\t      regmbc('n'); regmbc(0xf1); regmbc(0x144);\n\t\t      regmbc(0x146); regmbc(0x148); regmbc(0x149);\n\t\t      regmbc(0x1f9); regmbc(0x1d70); regmbc(0x1d87);\n\t\t      regmbc(0x1e45); regmbc(0x1e47); regmbc(0x1e49);\n\t\t      regmbc(0x1e4b); regmbc(0xa7a5);\n\t\t      return;\n\t    case 'o': case 0xf2: case 0xf3: case 0xf4: case 0xf5:\n\t    case 0xf6: case 0xf8: case 0x14d: case 0x14f: case 0x151:\n\t    case 0x1a1: case 0x1d2: case 0x1eb: case 0x1ed: case 0x1ff:\n\t    case 0x20d: case 0x20f: case 0x22b: case 0x22d: case 0x22f:\n\t    case 0x231: case 0x275: case 0x1e4d: case 0x1e4f:\n\t    case 0x1e51: case 0x1e53: case 0x1ecd: case 0x1ecf:\n\t    case 0x1ed1: case 0x1ed3: case 0x1ed5: case 0x1ed7:\n\t    case 0x1ed9: case 0x1edb: case 0x1edd: case 0x1edf:\n\t    case 0x1ee1: case 0x1ee3:\n\t\t      regmbc('o'); regmbc(0xf2); regmbc(0xf3);\n\t\t      regmbc(0xf4); regmbc(0xf5); regmbc(0xf6);\n\t\t      regmbc(0xf8); regmbc(0x14d); regmbc(0x14f);\n\t\t      regmbc(0x151); regmbc(0x1a1); regmbc(0x1d2);\n\t\t      regmbc(0x1eb); regmbc(0x1ed); regmbc(0x1ff);\n\t\t      regmbc(0x20d); regmbc(0x20f); regmbc(0x22b);\n\t\t      regmbc(0x22d); regmbc(0x22f); regmbc(0x231);\n\t\t      regmbc(0x275); regmbc(0x1e4d); regmbc(0x1e4f);\n\t\t      regmbc(0x1e51); regmbc(0x1e53); regmbc(0x1ecd);\n\t\t      regmbc(0x1ecf); regmbc(0x1ed1); regmbc(0x1ed3);\n\t\t      regmbc(0x1ed5); regmbc(0x1ed7); regmbc(0x1ed9);\n\t\t      regmbc(0x1edb); regmbc(0x1edd); regmbc(0x1edf);\n\t\t      regmbc(0x1ee1); regmbc(0x1ee3);\n\t\t      return;\n\t    case 'p': case 0x1a5: case 0x1d71: case 0x1d88: case 0x1d7d:\n\t    case 0x1e55: case 0x1e57:\n\t\t      regmbc('p'); regmbc(0x1a5); regmbc(0x1d71);\n\t\t      regmbc(0x1d7d); regmbc(0x1d88); regmbc(0x1e55);\n\t\t      regmbc(0x1e57);\n\t\t      return;\n\t    case 'q': case 0x24b: case 0x2a0:\n\t\t      regmbc('q'); regmbc(0x24b); regmbc(0x2a0);\n\t\t      return;\n\t    case 'r': case 0x155: case 0x157: case 0x159: case 0x211:\n\t    case 0x213: case 0x24d: case 0x27d: case 0x1d72: case 0x1d73:\n\t    case 0x1d89: case 0x1e59: case 0x1e5b: case 0x1e5d: case 0x1e5f:\n\t    case 0xa7a7:\n\t\t      regmbc('r'); regmbc(0x155); regmbc(0x157);\n\t\t      regmbc(0x159); regmbc(0x211); regmbc(0x213);\n\t\t      regmbc(0x24d); regmbc(0x1d72); regmbc(0x1d73);\n\t\t      regmbc(0x1d89); regmbc(0x1e59); regmbc(0x27d);\n\t\t      regmbc(0x1e5b); regmbc(0x1e5d); regmbc(0x1e5f);\n\t\t      regmbc(0xa7a7);\n\t\t      return;\n\t    case 's': case 0x15b: case 0x15d: case 0x15f: case 0x161:\n\t    case 0x1e61: case 0x219: case 0x23f: case 0x1d74: case 0x1d8a:\n\t    case 0x1e63: case 0x1e65: case 0x1e67: case 0x1e69: case 0xa7a9:\n\t\t      regmbc('s'); regmbc(0x15b); regmbc(0x15d);\n\t\t      regmbc(0x15f); regmbc(0x161); regmbc(0x23f);\n\t\t      regmbc(0x219); regmbc(0x1d74); regmbc(0x1d8a);\n\t\t      regmbc(0x1e61); regmbc(0x1e63); regmbc(0x1e65);\n\t\t      regmbc(0x1e67); regmbc(0x1e69); regmbc(0xa7a9);\n\t\t      return;\n\t    case 't': case 0x163: case 0x165: case 0x167: case 0x1ab:\n\t    case 0x1ad: case 0x21b: case 0x288: case 0x1d75: case 0x1e6b:\n\t    case 0x1e6d: case 0x1e6f: case 0x1e71: case 0x1e97: case 0x2c66:\n\t\t      regmbc('t'); regmbc(0x163); regmbc(0x165);\n\t\t      regmbc(0x167); regmbc(0x1ab); regmbc(0x21b);\n\t\t      regmbc(0x1ad); regmbc(0x288); regmbc(0x1d75);\n\t\t      regmbc(0x1e6b); regmbc(0x1e6d); regmbc(0x1e6f);\n\t\t      regmbc(0x1e71); regmbc(0x1e97); regmbc(0x2c66);\n\t\t      return;\n\t    case 'u': case 0xf9: case 0xfa: case 0xfb: case 0xfc:\n\t    case 0x169: case 0x16b: case 0x16d: case 0x16f:\n\t    case 0x171: case 0x173: case 0x1b0: case 0x1d4:\n\t    case 0x1d6: case 0x1d8: case 0x1da: case 0x1dc:\n\t    case 0x215: case 0x217: case 0x289: case 0x1e73:\n\t    case 0x1d7e: case 0x1d99: case 0x1e75: case 0x1e77:\n\t    case 0x1e79: case 0x1e7b: case 0x1ee5: case 0x1ee7:\n\t    case 0x1ee9: case 0x1eeb: case 0x1eed: case 0x1eef:\n\t    case 0x1ef1:\n\t\t      regmbc('u'); regmbc(0xf9); regmbc(0xfa);\n\t\t      regmbc(0xfb); regmbc(0xfc); regmbc(0x169);\n\t\t      regmbc(0x16b); regmbc(0x16d); regmbc(0x16f);\n\t\t      regmbc(0x171); regmbc(0x173); regmbc(0x1d6);\n\t\t      regmbc(0x1d8); regmbc(0x1da); regmbc(0x1dc);\n\t\t      regmbc(0x215); regmbc(0x217); regmbc(0x1b0);\n\t\t      regmbc(0x1d4); regmbc(0x289); regmbc(0x1d7e);\n\t\t      regmbc(0x1d99); regmbc(0x1e73); regmbc(0x1e75);\n\t\t      regmbc(0x1e77); regmbc(0x1e79); regmbc(0x1e7b);\n\t\t      regmbc(0x1ee5); regmbc(0x1ee7); regmbc(0x1ee9);\n\t\t      regmbc(0x1eeb); regmbc(0x1eed); regmbc(0x1eef);\n\t\t      regmbc(0x1ef1);\n\t\t      return;\n\t    case 'v': case 0x28b: case 0x1d8c: case 0x1e7d: case 0x1e7f:\n\t\t      regmbc('v'); regmbc(0x28b); regmbc(0x1d8c);\n\t\t      regmbc(0x1e7d); regmbc(0x1e7f);\n\t\t      return;\n\t    case 'w': case 0x175: case 0x1e81: case 0x1e83:\n\t    case 0x1e85: case 0x1e87: case 0x1e89: case 0x1e98:\n\t\t      regmbc('w'); regmbc(0x175); regmbc(0x1e81);\n\t\t      regmbc(0x1e83); regmbc(0x1e85); regmbc(0x1e87);\n\t\t      regmbc(0x1e89); regmbc(0x1e98);\n\t\t      return;\n\t    case 'x': case 0x1e8b: case 0x1e8d:\n\t\t      regmbc('x'); regmbc(0x1e8b); regmbc(0x1e8d);\n\t\t      return;\n\t    case 'y': case 0xfd: case 0xff: case 0x177: case 0x1b4:\n\t    case 0x233: case 0x24f: case 0x1e8f: case 0x1e99: case 0x1ef3:\n\t    case 0x1ef5: case 0x1ef7: case 0x1ef9:\n\t\t      regmbc('y'); regmbc(0xfd); regmbc(0xff);\n\t\t      regmbc(0x177); regmbc(0x1b4); regmbc(0x233);\n\t\t      regmbc(0x24f); regmbc(0x1e8f); regmbc(0x1e99);\n\t\t      regmbc(0x1ef3); regmbc(0x1ef5); regmbc(0x1ef7);\n\t\t      regmbc(0x1ef9);\n\t\t      return;\n\t    case 'z': case 0x17a: case 0x17c: case 0x17e: case 0x1b6:\n\t    case 0x1d76: case 0x1d8e: case 0x1e91: case 0x1e93:\n\t    case 0x1e95: case 0x2c6c:\n\t\t      regmbc('z'); regmbc(0x17a); regmbc(0x17c);\n\t\t      regmbc(0x17e); regmbc(0x1b6); regmbc(0x1d76);\n\t\t      regmbc(0x1d8e); regmbc(0x1e91); regmbc(0x1e93);\n\t\t      regmbc(0x1e95); regmbc(0x2c6c);\n\t\t      return;\n\t}\n    }\n    regmbc(c);\n}\n\n/*\n * Emit a node.\n * Return pointer to generated code.\n */\n    static char_u *\nregnode(int op)\n{\n    char_u  *ret;\n\n    ret = regcode;\n    if (ret == JUST_CALC_SIZE)\n\tregsize += 3;\n    else\n    {\n\t*regcode++ = op;\n\t*regcode++ = NUL;\t\t// Null \"next\" pointer.\n\t*regcode++ = NUL;\n    }\n    return ret;\n}\n\n/*\n * Write a long as four bytes at \"p\" and return pointer to the next char.\n */\n    static char_u *\nre_put_long(char_u *p, long_u val)\n{\n    *p++ = (char_u) ((val >> 24) & 0377);\n    *p++ = (char_u) ((val >> 16) & 0377);\n    *p++ = (char_u) ((val >> 8) & 0377);\n    *p++ = (char_u) (val & 0377);\n    return p;\n}\n\n/*\n * regnext - dig the \"next\" pointer out of a node\n * Returns NULL when calculating size, when there is no next item and when\n * there is an error.\n */\n    static char_u *\nregnext(char_u *p)\n{\n    int\t    offset;\n\n    if (p == JUST_CALC_SIZE || reg_toolong)\n\treturn NULL;\n\n    offset = NEXT(p);\n    if (offset == 0)\n\treturn NULL;\n\n    if (OP(p) == BACK)\n\treturn p - offset;\n    else\n\treturn p + offset;\n}\n\n/*\n * Set the next-pointer at the end of a node chain.\n */\n    static void\nregtail(char_u *p, char_u *val)\n{\n    char_u\t*scan;\n    char_u\t*temp;\n    int\t\toffset;\n\n    if (p == JUST_CALC_SIZE)\n\treturn;\n\n    // Find last node.\n    scan = p;\n    for (;;)\n    {\n\ttemp = regnext(scan);\n\tif (temp == NULL)\n\t    break;\n\tscan = temp;\n    }\n\n    if (OP(scan) == BACK)\n\toffset = (int)(scan - val);\n    else\n\toffset = (int)(val - scan);\n    // When the offset uses more than 16 bits it can no longer fit in the two\n    // bytes available.  Use a global flag to avoid having to check return\n    // values in too many places.\n    if (offset > 0xffff)\n\treg_toolong = TRUE;\n    else\n    {\n\t*(scan + 1) = (char_u) (((unsigned)offset >> 8) & 0377);\n\t*(scan + 2) = (char_u) (offset & 0377);\n    }\n}\n\n/*\n * Like regtail, on item after a BRANCH; nop if none.\n */\n    static void\nregoptail(char_u *p, char_u *val)\n{\n    // When op is neither BRANCH nor BRACE_COMPLEX0-9, it is \"operandless\"\n    if (p == NULL || p == JUST_CALC_SIZE\n\t    || (OP(p) != BRANCH\n\t\t&& (OP(p) < BRACE_COMPLEX || OP(p) > BRACE_COMPLEX + 9)))\n\treturn;\n    regtail(OPERAND(p), val);\n}\n\n/*\n * Insert an operator in front of already-emitted operand\n *\n * Means relocating the operand.\n */\n    static void\nreginsert(int op, char_u *opnd)\n{\n    char_u\t*src;\n    char_u\t*dst;\n    char_u\t*place;\n\n    if (regcode == JUST_CALC_SIZE)\n    {\n\tregsize += 3;\n\treturn;\n    }\n    src = regcode;\n    regcode += 3;\n    dst = regcode;\n    while (src > opnd)\n\t*--dst = *--src;\n\n    place = opnd;\t\t// Op node, where operand used to be.\n    *place++ = op;\n    *place++ = NUL;\n    *place = NUL;\n}\n\n/*\n * Insert an operator in front of already-emitted operand.\n * Add a number to the operator.\n */\n    static void\nreginsert_nr(int op, long val, char_u *opnd)\n{\n    char_u\t*src;\n    char_u\t*dst;\n    char_u\t*place;\n\n    if (regcode == JUST_CALC_SIZE)\n    {\n\tregsize += 7;\n\treturn;\n    }\n    src = regcode;\n    regcode += 7;\n    dst = regcode;\n    while (src > opnd)\n\t*--dst = *--src;\n\n    place = opnd;\t\t// Op node, where operand used to be.\n    *place++ = op;\n    *place++ = NUL;\n    *place++ = NUL;\n    re_put_long(place, (long_u)val);\n}\n\n/*\n * Insert an operator in front of already-emitted operand.\n * The operator has the given limit values as operands.  Also set next pointer.\n *\n * Means relocating the operand.\n */\n    static void\nreginsert_limits(\n    int\t\top,\n    long\tminval,\n    long\tmaxval,\n    char_u\t*opnd)\n{\n    char_u\t*src;\n    char_u\t*dst;\n    char_u\t*place;\n\n    if (regcode == JUST_CALC_SIZE)\n    {\n\tregsize += 11;\n\treturn;\n    }\n    src = regcode;\n    regcode += 11;\n    dst = regcode;\n    while (src > opnd)\n\t*--dst = *--src;\n\n    place = opnd;\t\t// Op node, where operand used to be.\n    *place++ = op;\n    *place++ = NUL;\n    *place++ = NUL;\n    place = re_put_long(place, (long_u)minval);\n    place = re_put_long(place, (long_u)maxval);\n    regtail(opnd, place);\n}\n\n/*\n * Return TRUE if the back reference is legal. We must have seen the close\n * brace.\n * TODO: Should also check that we don't refer to something that is repeated\n * (+*=): what instance of the repetition should we match?\n */\n    static int\nseen_endbrace(int refnum)\n{\n    if (!had_endbrace[refnum])\n    {\n\tchar_u *p;\n\n\t// Trick: check if \"@<=\" or \"@<!\" follows, in which case\n\t// the \\1 can appear before the referenced match.\n\tfor (p = regparse; *p != NUL; ++p)\n\t    if (p[0] == '@' && p[1] == '<' && (p[2] == '!' || p[2] == '='))\n\t\tbreak;\n\tif (*p == NUL)\n\t{\n\t    emsg(_(e_illegal_back_reference));\n\t    rc_did_emsg = TRUE;\n\t    return FALSE;\n\t}\n    }\n    return TRUE;\n}\n\n/*\n * Parse the lowest level.\n *\n * Optimization:  gobbles an entire sequence of ordinary characters so that\n * it can turn them into a single node, which is smaller to store and\n * faster to run.  Don't do this when one_exactly is set.\n */\n    static char_u *\nregatom(int *flagp)\n{\n    char_u\t    *ret;\n    int\t\t    flags;\n    int\t\t    c;\n    char_u\t    *p;\n    int\t\t    extra = 0;\n    int\t\t    save_prev_at_start = prev_at_start;\n\n    *flagp = WORST;\t\t// Tentatively.\n\n    c = getchr();\n    switch (c)\n    {\n      case Magic('^'):\n\tret = regnode(BOL);\n\tbreak;\n\n      case Magic('$'):\n\tret = regnode(EOL);\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n\thad_eol = TRUE;\n#endif\n\tbreak;\n\n      case Magic('<'):\n\tret = regnode(BOW);\n\tbreak;\n\n      case Magic('>'):\n\tret = regnode(EOW);\n\tbreak;\n\n      case Magic('_'):\n\tc = no_Magic(getchr());\n\tif (c == '^')\t\t// \"\\_^\" is start-of-line\n\t{\n\t    ret = regnode(BOL);\n\t    break;\n\t}\n\tif (c == '$')\t\t// \"\\_$\" is end-of-line\n\t{\n\t    ret = regnode(EOL);\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n\t    had_eol = TRUE;\n#endif\n\t    break;\n\t}\n\n\textra = ADD_NL;\n\t*flagp |= HASNL;\n\n\t// \"\\_[\" is character range plus newline\n\tif (c == '[')\n\t    goto collection;\n\n\t// \"\\_x\" is character class plus newline\n\t// FALLTHROUGH\n\n\t// Character classes.\n      case Magic('.'):\n      case Magic('i'):\n      case Magic('I'):\n      case Magic('k'):\n      case Magic('K'):\n      case Magic('f'):\n      case Magic('F'):\n      case Magic('p'):\n      case Magic('P'):\n      case Magic('s'):\n      case Magic('S'):\n      case Magic('d'):\n      case Magic('D'):\n      case Magic('x'):\n      case Magic('X'):\n      case Magic('o'):\n      case Magic('O'):\n      case Magic('w'):\n      case Magic('W'):\n      case Magic('h'):\n      case Magic('H'):\n      case Magic('a'):\n      case Magic('A'):\n      case Magic('l'):\n      case Magic('L'):\n      case Magic('u'):\n      case Magic('U'):\n\tp = vim_strchr(classchars, no_Magic(c));\n\tif (p == NULL)\n\t    EMSG_RET_NULL(_(e_invalid_use_of_underscore));\n\n\t// When '.' is followed by a composing char ignore the dot, so that\n\t// the composing char is matched here.\n\tif (enc_utf8 && c == Magic('.') && utf_iscomposing(peekchr()))\n\t{\n\t    c = getchr();\n\t    goto do_multibyte;\n\t}\n\tret = regnode(classcodes[p - classchars] + extra);\n\t*flagp |= HASWIDTH | SIMPLE;\n\tbreak;\n\n      case Magic('n'):\n\tif (reg_string)\n\t{\n\t    // In a string \"\\n\" matches a newline character.\n\t    ret = regnode(EXACTLY);\n\t    regc(NL);\n\t    regc(NUL);\n\t    *flagp |= HASWIDTH | SIMPLE;\n\t}\n\telse\n\t{\n\t    // In buffer text \"\\n\" matches the end of a line.\n\t    ret = regnode(NEWL);\n\t    *flagp |= HASWIDTH | HASNL;\n\t}\n\tbreak;\n\n      case Magic('('):\n\tif (one_exactly)\n\t    EMSG_ONE_RET_NULL;\n\tret = reg(REG_PAREN, &flags);\n\tif (ret == NULL)\n\t    return NULL;\n\t*flagp |= flags & (HASWIDTH | SPSTART | HASNL | HASLOOKBH);\n\tbreak;\n\n      case NUL:\n      case Magic('|'):\n      case Magic('&'):\n      case Magic(')'):\n\tif (one_exactly)\n\t    EMSG_ONE_RET_NULL;\n\t// Supposed to be caught earlier.\n\tIEMSG_RET_NULL(_(e_internal_error_in_regexp));\n\t// NOTREACHED\n\n      case Magic('='):\n      case Magic('?'):\n      case Magic('+'):\n      case Magic('@'):\n      case Magic('{'):\n      case Magic('*'):\n\tc = no_Magic(c);\n\tEMSG3_RET_NULL(_(e_str_chr_follows_nothing),\n\t\t(c == '*' ? reg_magic >= MAGIC_ON : reg_magic == MAGIC_ALL), c);\n\t// NOTREACHED\n\n      case Magic('~'):\t\t// previous substitute pattern\n\t    if (reg_prev_sub != NULL)\n\t    {\n\t\tchar_u\t    *lp;\n\n\t\tret = regnode(EXACTLY);\n\t\tlp = reg_prev_sub;\n\t\twhile (*lp != NUL)\n\t\t    regc(*lp++);\n\t\tregc(NUL);\n\t\tif (*reg_prev_sub != NUL)\n\t\t{\n\t\t    *flagp |= HASWIDTH;\n\t\t    if ((lp - reg_prev_sub) == 1)\n\t\t\t*flagp |= SIMPLE;\n\t\t}\n\t    }\n\t    else\n\t\tEMSG_RET_NULL(_(e_no_previous_substitute_regular_expression));\n\t    break;\n\n      case Magic('1'):\n      case Magic('2'):\n      case Magic('3'):\n      case Magic('4'):\n      case Magic('5'):\n      case Magic('6'):\n      case Magic('7'):\n      case Magic('8'):\n      case Magic('9'):\n\t    {\n\t\tint\t\t    refnum;\n\n\t\trefnum = c - Magic('0');\n\t\tif (!seen_endbrace(refnum))\n\t\t    return NULL;\n\t\tret = regnode(BACKREF + refnum);\n\t    }\n\t    break;\n\n      case Magic('z'):\n\t{\n\t    c = no_Magic(getchr());\n\t    switch (c)\n\t    {\n#ifdef FEAT_SYN_HL\n\t\tcase '(': if ((reg_do_extmatch & REX_SET) == 0)\n\t\t\t      EMSG_RET_NULL(_(e_z_not_allowed_here));\n\t\t\t  if (one_exactly)\n\t\t\t      EMSG_ONE_RET_NULL;\n\t\t\t  ret = reg(REG_ZPAREN, &flags);\n\t\t\t  if (ret == NULL)\n\t\t\t      return NULL;\n\t\t\t  *flagp |= flags & (HASWIDTH|SPSTART|HASNL|HASLOOKBH);\n\t\t\t  re_has_z = REX_SET;\n\t\t\t  break;\n\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9': if ((reg_do_extmatch & REX_USE) == 0)\n\t\t\t      EMSG_RET_NULL(_(e_z1_z9_not_allowed_here));\n\t\t\t  ret = regnode(ZREF + c - '0');\n\t\t\t  re_has_z = REX_USE;\n\t\t\t  break;\n#endif\n\n\t\tcase 's': ret = regnode(MOPEN + 0);\n\t\t\t  if (re_mult_next(\"\\\\zs\") == FAIL)\n\t\t\t      return NULL;\n\t\t\t  break;\n\n\t\tcase 'e': ret = regnode(MCLOSE + 0);\n\t\t\t  if (re_mult_next(\"\\\\ze\") == FAIL)\n\t\t\t      return NULL;\n\t\t\t  break;\n\n\t\tdefault:  EMSG_RET_NULL(_(e_invalid_character_after_bsl_z));\n\t    }\n\t}\n\tbreak;\n\n      case Magic('%'):\n\t{\n\t    c = no_Magic(getchr());\n\t    switch (c)\n\t    {\n\t\t// () without a back reference\n\t\tcase '(':\n\t\t    if (one_exactly)\n\t\t\tEMSG_ONE_RET_NULL;\n\t\t    ret = reg(REG_NPAREN, &flags);\n\t\t    if (ret == NULL)\n\t\t\treturn NULL;\n\t\t    *flagp |= flags & (HASWIDTH | SPSTART | HASNL | HASLOOKBH);\n\t\t    break;\n\n\t\t// Catch \\%^ and \\%$ regardless of where they appear in the\n\t\t// pattern -- regardless of whether or not it makes sense.\n\t\tcase '^':\n\t\t    ret = regnode(RE_BOF);\n\t\t    break;\n\n\t\tcase '$':\n\t\t    ret = regnode(RE_EOF);\n\t\t    break;\n\n\t\tcase '#':\n\t\t    ret = regnode(CURSOR);\n\t\t    break;\n\n\t\tcase 'V':\n\t\t    ret = regnode(RE_VISUAL);\n\t\t    break;\n\n\t\tcase 'C':\n\t\t    ret = regnode(RE_COMPOSING);\n\t\t    break;\n\n\t\t// \\%[abc]: Emit as a list of branches, all ending at the last\n\t\t// branch which matches nothing.\n\t\tcase '[':\n\t\t\t  if (one_exactly)\t// doesn't nest\n\t\t\t      EMSG_ONE_RET_NULL;\n\t\t\t  {\n\t\t\t      char_u\t*lastbranch;\n\t\t\t      char_u\t*lastnode = NULL;\n\t\t\t      char_u\t*br;\n\n\t\t\t      ret = NULL;\n\t\t\t      while ((c = getchr()) != ']')\n\t\t\t      {\n\t\t\t\t  if (c == NUL)\n\t\t\t\t      EMSG2_RET_NULL(_(e_missing_sb_after_str),\n\t\t\t\t\t\t      reg_magic == MAGIC_ALL);\n\t\t\t\t  br = regnode(BRANCH);\n\t\t\t\t  if (ret == NULL)\n\t\t\t\t      ret = br;\n\t\t\t\t  else\n\t\t\t\t  {\n\t\t\t\t      regtail(lastnode, br);\n\t\t\t\t      if (reg_toolong)\n\t\t\t\t\t  return NULL;\n\t\t\t\t  }\n\n\t\t\t\t  ungetchr();\n\t\t\t\t  one_exactly = TRUE;\n\t\t\t\t  lastnode = regatom(flagp);\n\t\t\t\t  one_exactly = FALSE;\n\t\t\t\t  if (lastnode == NULL)\n\t\t\t\t      return NULL;\n\t\t\t      }\n\t\t\t      if (ret == NULL)\n\t\t\t\t  EMSG2_RET_NULL(_(e_empty_str_brackets),\n\t\t\t\t\t\t      reg_magic == MAGIC_ALL);\n\t\t\t      lastbranch = regnode(BRANCH);\n\t\t\t      br = regnode(NOTHING);\n\t\t\t      if (ret != JUST_CALC_SIZE)\n\t\t\t      {\n\t\t\t\t  regtail(lastnode, br);\n\t\t\t\t  regtail(lastbranch, br);\n\t\t\t\t  // connect all branches to the NOTHING\n\t\t\t\t  // branch at the end\n\t\t\t\t  for (br = ret; br != lastnode; )\n\t\t\t\t  {\n\t\t\t\t      if (OP(br) == BRANCH)\n\t\t\t\t      {\n\t\t\t\t\t  regtail(br, lastbranch);\n\t\t\t\t\t  if (reg_toolong)\n\t\t\t\t\t      return NULL;\n\t\t\t\t\t  br = OPERAND(br);\n\t\t\t\t      }\n\t\t\t\t      else\n\t\t\t\t\t  br = regnext(br);\n\t\t\t\t  }\n\t\t\t      }\n\t\t\t      *flagp &= ~(HASWIDTH | SIMPLE);\n\t\t\t      break;\n\t\t\t  }\n\n\t\tcase 'd':   // %d123 decimal\n\t\tcase 'o':   // %o123 octal\n\t\tcase 'x':   // %xab hex 2\n\t\tcase 'u':   // %uabcd hex 4\n\t\tcase 'U':   // %U1234abcd hex 8\n\t\t\t  {\n\t\t\t      long i;\n\n\t\t\t      switch (c)\n\t\t\t      {\n\t\t\t\t  case 'd': i = getdecchrs(); break;\n\t\t\t\t  case 'o': i = getoctchrs(); break;\n\t\t\t\t  case 'x': i = gethexchrs(2); break;\n\t\t\t\t  case 'u': i = gethexchrs(4); break;\n\t\t\t\t  case 'U': i = gethexchrs(8); break;\n\t\t\t\t  default:  i = -1; break;\n\t\t\t      }\n\n\t\t\t      if (i < 0 || i > INT_MAX)\n\t\t\t\t  EMSG2_RET_NULL(\n\t\t\t\t\t    _(e_invalid_character_after_str_2),\n\t\t\t\t\t\t       reg_magic == MAGIC_ALL);\n\t\t\t      if (use_multibytecode(i))\n\t\t\t\t  ret = regnode(MULTIBYTECODE);\n\t\t\t      else\n\t\t\t\t  ret = regnode(EXACTLY);\n\t\t\t      if (i == 0)\n\t\t\t\t  regc(0x0a);\n\t\t\t      else\n\t\t\t\t  regmbc(i);\n\t\t\t      regc(NUL);\n\t\t\t      *flagp |= HASWIDTH;\n\t\t\t      break;\n\t\t\t  }\n\n\t\tdefault:\n\t\t\t  if (VIM_ISDIGIT(c) || c == '<' || c == '>'\n\t\t\t\t\t\t|| c == '\\'' || c == '.')\n\t\t\t  {\n\t\t\t      long_u\tn = 0;\n\t\t\t      int\tcmp;\n\t\t\t      int\tcur = FALSE;\n\n\t\t\t      cmp = c;\n\t\t\t      if (cmp == '<' || cmp == '>')\n\t\t\t\t  c = getchr();\n\t\t\t      if (no_Magic(c) == '.')\n\t\t\t      {\n\t\t\t\t  cur = TRUE;\n\t\t\t\t  c = getchr();\n\t\t\t      }\n\t\t\t      while (VIM_ISDIGIT(c))\n\t\t\t      {\n\t\t\t\t  n = n * 10 + (c - '0');\n\t\t\t\t  c = getchr();\n\t\t\t      }\n\t\t\t      if (c == '\\'' && n == 0)\n\t\t\t      {\n\t\t\t\t  // \"\\%'m\", \"\\%<'m\" and \"\\%>'m\": Mark\n\t\t\t\t  c = getchr();\n\t\t\t\t  ret = regnode(RE_MARK);\n\t\t\t\t  if (ret == JUST_CALC_SIZE)\n\t\t\t\t      regsize += 2;\n\t\t\t\t  else\n\t\t\t\t  {\n\t\t\t\t      *regcode++ = c;\n\t\t\t\t      *regcode++ = cmp;\n\t\t\t\t  }\n\t\t\t\t  break;\n\t\t\t      }\n\t\t\t      else if (c == 'l' || c == 'c' || c == 'v')\n\t\t\t      {\n\t\t\t\t  if (cur && n)\n\t\t\t\t  {\n\t\t\t\t    semsg(_(e_regexp_number_after_dot_pos_search), no_Magic(c));\n\t\t\t\t    rc_did_emsg = TRUE;\n\t\t\t\t    return NULL;\n\t\t\t\t  }\n\t\t\t\t  if (c == 'l')\n\t\t\t\t  {\n\t\t\t\t      if (cur)\n\t\t\t\t\t  n = curwin->w_cursor.lnum;\n\t\t\t\t      ret = regnode(RE_LNUM);\n\t\t\t\t      if (save_prev_at_start)\n\t\t\t\t\t  at_start = TRUE;\n\t\t\t\t  }\n\t\t\t\t  else if (c == 'c')\n\t\t\t\t  {\n\t\t\t\t      if (cur)\n\t\t\t\t      {\n\t\t\t\t\t  n = curwin->w_cursor.col;\n\t\t\t\t\t  n++;\n\t\t\t\t      }\n\t\t\t\t      ret = regnode(RE_COL);\n\t\t\t\t  }\n\t\t\t\t  else\n\t\t\t\t  {\n\t\t\t\t      if (cur)\n\t\t\t\t      {\n\t\t\t\t\t  colnr_T vcol = 0;\n\n\t\t\t\t\t  getvvcol(curwin, &curwin->w_cursor,\n\t\t\t\t\t\t\t    NULL, NULL, &vcol);\n\t\t\t\t\t  ++vcol;\n\t\t\t\t\t  n = vcol;\n\t\t\t\t      }\n\t\t\t\t      ret = regnode(RE_VCOL);\n\t\t\t\t  }\n\t\t\t\t  if (ret == JUST_CALC_SIZE)\n\t\t\t\t      regsize += 5;\n\t\t\t\t  else\n\t\t\t\t  {\n\t\t\t\t      // put the number and the optional\n\t\t\t\t      // comparator after the opcode\n\t\t\t\t      regcode = re_put_long(regcode, n);\n\t\t\t\t      *regcode++ = cmp;\n\t\t\t\t  }\n\t\t\t\t  break;\n\t\t\t      }\n\t\t\t  }\n\n\t\t\t  EMSG2_RET_NULL(_(e_invalid_character_after_str),\n\t\t\t\t\t\t      reg_magic == MAGIC_ALL);\n\t    }\n\t}\n\tbreak;\n\n      case Magic('['):\ncollection:\n\t{\n\t    char_u\t*lp;\n\n\t    // If there is no matching ']', we assume the '[' is a normal\n\t    // character.  This makes 'incsearch' and \":help [\" work.\n\t    lp = skip_anyof(regparse);\n\t    if (*lp == ']')\t// there is a matching ']'\n\t    {\n\t\tint\tstartc = -1;\t// > 0 when next '-' is a range\n\t\tint\tendc;\n\n\t\t// In a character class, different parsing rules apply.\n\t\t// Not even \\ is special anymore, nothing is.\n\t\tif (*regparse == '^')\t    // Complement of range.\n\t\t{\n\t\t    ret = regnode(ANYBUT + extra);\n\t\t    regparse++;\n\t\t}\n\t\telse\n\t\t    ret = regnode(ANYOF + extra);\n\n\t\t// At the start ']' and '-' mean the literal character.\n\t\tif (*regparse == ']' || *regparse == '-')\n\t\t{\n\t\t    startc = *regparse;\n\t\t    regc(*regparse++);\n\t\t}\n\n\t\twhile (*regparse != NUL && *regparse != ']')\n\t\t{\n\t\t    if (*regparse == '-')\n\t\t    {\n\t\t\t++regparse;\n\t\t\t// The '-' is not used for a range at the end and\n\t\t\t// after or before a '\\n'.\n\t\t\tif (*regparse == ']' || *regparse == NUL\n\t\t\t\t|| startc == -1\n\t\t\t\t|| (regparse[0] == '\\\\' && regparse[1] == 'n'))\n\t\t\t{\n\t\t\t    regc('-');\n\t\t\t    startc = '-';\t// [--x] is a range\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Also accept \"a-[.z.]\"\n\t\t\t    endc = 0;\n\t\t\t    if (*regparse == '[')\n\t\t\t\tendc = get_coll_element(&regparse);\n\t\t\t    if (endc == 0)\n\t\t\t    {\n\t\t\t\tif (has_mbyte)\n\t\t\t\t    endc = mb_ptr2char_adv(&regparse);\n\t\t\t\telse\n\t\t\t\t    endc = *regparse++;\n\t\t\t    }\n\n\t\t\t    // Handle \\o40, \\x20 and \\u20AC style sequences\n\t\t\t    if (endc == '\\\\' && !reg_cpo_lit && !reg_cpo_bsl)\n\t\t\t\tendc = coll_get_char();\n\n\t\t\t    if (startc > endc)\n\t\t\t\tEMSG_RET_NULL(_(e_reverse_range_in_character_class));\n\t\t\t    if (has_mbyte && ((*mb_char2len)(startc) > 1\n\t\t\t\t\t\t || (*mb_char2len)(endc) > 1))\n\t\t\t    {\n\t\t\t\t// Limit to a range of 256 chars.\n\t\t\t\tif (endc > startc + 256)\n\t\t\t\t    EMSG_RET_NULL(_(e_range_too_large_in_character_class));\n\t\t\t\twhile (++startc <= endc)\n\t\t\t\t    regmbc(startc);\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\twhile (++startc <= endc)\n\t\t\t\t    regc(startc);\n\t\t\t    }\n\t\t\t    startc = -1;\n\t\t\t}\n\t\t    }\n\t\t    // Only \"\\]\", \"\\^\", \"\\]\" and \"\\\\\" are special in Vi.  Vim\n\t\t    // accepts \"\\t\", \"\\e\", etc., but only when the 'l' flag in\n\t\t    // 'cpoptions' is not included.\n\t\t    // Posix doesn't recognize backslash at all.\n\t\t    else if (*regparse == '\\\\'\n\t\t\t    && !reg_cpo_bsl\n\t\t\t    && (vim_strchr(REGEXP_INRANGE, regparse[1]) != NULL\n\t\t\t\t|| (!reg_cpo_lit\n\t\t\t\t    && vim_strchr(REGEXP_ABBR,\n\t\t\t\t\t\t       regparse[1]) != NULL)))\n\t\t    {\n\t\t\tregparse++;\n\t\t\tif (*regparse == 'n')\n\t\t\t{\n\t\t\t    // '\\n' in range: also match NL\n\t\t\t    if (ret != JUST_CALC_SIZE)\n\t\t\t    {\n\t\t\t\t// Using \\n inside [^] does not change what\n\t\t\t\t// matches. \"[^\\n]\" is the same as \".\".\n\t\t\t\tif (*ret == ANYOF)\n\t\t\t\t{\n\t\t\t\t    *ret = ANYOF + ADD_NL;\n\t\t\t\t    *flagp |= HASNL;\n\t\t\t\t}\n\t\t\t\t// else: must have had a \\n already\n\t\t\t    }\n\t\t\t    regparse++;\n\t\t\t    startc = -1;\n\t\t\t}\n\t\t\telse if (*regparse == 'd'\n\t\t\t\t|| *regparse == 'o'\n\t\t\t\t|| *regparse == 'x'\n\t\t\t\t|| *regparse == 'u'\n\t\t\t\t|| *regparse == 'U')\n\t\t\t{\n\t\t\t    startc = coll_get_char();\n\t\t\t    if (startc == 0)\n\t\t\t\tregc(0x0a);\n\t\t\t    else\n\t\t\t\tregmbc(startc);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    startc = backslash_trans(*regparse++);\n\t\t\t    regc(startc);\n\t\t\t}\n\t\t    }\n\t\t    else if (*regparse == '[')\n\t\t    {\n\t\t\tint c_class;\n\t\t\tint cu;\n\n\t\t\tc_class = get_char_class(&regparse);\n\t\t\tstartc = -1;\n\t\t\t// Characters assumed to be 8 bits!\n\t\t\tswitch (c_class)\n\t\t\t{\n\t\t\t    case CLASS_NONE:\n\t\t\t\tc_class = get_equi_class(&regparse);\n\t\t\t\tif (c_class != 0)\n\t\t\t\t{\n\t\t\t\t    // produce equivalence class\n\t\t\t\t    reg_equi_class(c_class);\n\t\t\t\t}\n\t\t\t\telse if ((c_class =\n\t\t\t\t\t    get_coll_element(&regparse)) != 0)\n\t\t\t\t{\n\t\t\t\t    // produce a collating element\n\t\t\t\t    regmbc(c_class);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    // literal '[', allow [[-x] as a range\n\t\t\t\t    startc = *regparse++;\n\t\t\t\t    regc(startc);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t    case CLASS_ALNUM:\n\t\t\t\tfor (cu = 1; cu < 128; cu++)\n\t\t\t\t    if (isalnum(cu))\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t    case CLASS_ALPHA:\n\t\t\t\tfor (cu = 1; cu < 128; cu++)\n\t\t\t\t    if (isalpha(cu))\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t    case CLASS_BLANK:\n\t\t\t\tregc(' ');\n\t\t\t\tregc('\\t');\n\t\t\t\tbreak;\n\t\t\t    case CLASS_CNTRL:\n\t\t\t\tfor (cu = 1; cu <= 127; cu++)\n\t\t\t\t    if (iscntrl(cu))\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t    case CLASS_DIGIT:\n\t\t\t\tfor (cu = 1; cu <= 127; cu++)\n\t\t\t\t    if (VIM_ISDIGIT(cu))\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t    case CLASS_GRAPH:\n\t\t\t\tfor (cu = 1; cu <= 127; cu++)\n\t\t\t\t    if (isgraph(cu))\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t    case CLASS_LOWER:\n\t\t\t\tfor (cu = 1; cu <= 255; cu++)\n\t\t\t\t    if (MB_ISLOWER(cu) && cu != 170\n\t\t\t\t\t\t\t\t && cu != 186)\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t    case CLASS_PRINT:\n\t\t\t\tfor (cu = 1; cu <= 255; cu++)\n\t\t\t\t    if (vim_isprintc(cu))\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t    case CLASS_PUNCT:\n\t\t\t\tfor (cu = 1; cu < 128; cu++)\n\t\t\t\t    if (ispunct(cu))\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t    case CLASS_SPACE:\n\t\t\t\tfor (cu = 9; cu <= 13; cu++)\n\t\t\t\t    regc(cu);\n\t\t\t\tregc(' ');\n\t\t\t\tbreak;\n\t\t\t    case CLASS_UPPER:\n\t\t\t\tfor (cu = 1; cu <= 255; cu++)\n\t\t\t\t    if (MB_ISUPPER(cu))\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t    case CLASS_XDIGIT:\n\t\t\t\tfor (cu = 1; cu <= 255; cu++)\n\t\t\t\t    if (vim_isxdigit(cu))\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t    case CLASS_TAB:\n\t\t\t\tregc('\\t');\n\t\t\t\tbreak;\n\t\t\t    case CLASS_RETURN:\n\t\t\t\tregc('\\r');\n\t\t\t\tbreak;\n\t\t\t    case CLASS_BACKSPACE:\n\t\t\t\tregc('\\b');\n\t\t\t\tbreak;\n\t\t\t    case CLASS_ESCAPE:\n\t\t\t\tregc('\\033');\n\t\t\t\tbreak;\n\t\t\t    case CLASS_IDENT:\n\t\t\t\tfor (cu = 1; cu <= 255; cu++)\n\t\t\t\t    if (vim_isIDc(cu))\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t    case CLASS_KEYWORD:\n\t\t\t\tfor (cu = 1; cu <= 255; cu++)\n\t\t\t\t    if (reg_iswordc(cu))\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t    case CLASS_FNAME:\n\t\t\t\tfor (cu = 1; cu <= 255; cu++)\n\t\t\t\t    if (vim_isfilec(cu))\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t{\n\t\t\t    int\tlen;\n\n\t\t\t    // produce a multibyte character, including any\n\t\t\t    // following composing characters\n\t\t\t    startc = mb_ptr2char(regparse);\n\t\t\t    len = (*mb_ptr2len)(regparse);\n\t\t\t    if (enc_utf8 && utf_char2len(startc) != len)\n\t\t\t\tstartc = -1;\t// composing chars\n\t\t\t    while (--len >= 0)\n\t\t\t\tregc(*regparse++);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    startc = *regparse++;\n\t\t\t    regc(startc);\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tregc(NUL);\n\t\tprevchr_len = 1;\t// last char was the ']'\n\t\tif (*regparse != ']')\n\t\t    EMSG_RET_NULL(_(e_too_many_brackets));  // Cannot happen?\n\t\tskipchr();\t    // let's be friends with the lexer again\n\t\t*flagp |= HASWIDTH | SIMPLE;\n\t\tbreak;\n\t    }\n\t    else if (reg_strict)\n\t\tEMSG2_RET_NULL(_(e_missing_rsb_after_str_lsb),\n\t\t\t\t\t\t\treg_magic > MAGIC_OFF);\n\t}\n\t// FALLTHROUGH\n\n      default:\n\t{\n\t    int\t\tlen;\n\n\t    // A multi-byte character is handled as a separate atom if it's\n\t    // before a multi and when it's a composing char.\n\t    if (use_multibytecode(c))\n\t    {\ndo_multibyte:\n\t\tret = regnode(MULTIBYTECODE);\n\t\tregmbc(c);\n\t\t*flagp |= HASWIDTH | SIMPLE;\n\t\tbreak;\n\t    }\n\n\t    ret = regnode(EXACTLY);\n\n\t    // Append characters as long as:\n\t    // - there is no following multi, we then need the character in\n\t    //   front of it as a single character operand\n\t    // - not running into a Magic character\n\t    // - \"one_exactly\" is not set\n\t    // But always emit at least one character.  Might be a Multi,\n\t    // e.g., a \"[\" without matching \"]\".\n\t    for (len = 0; c != NUL && (len == 0\n\t\t\t|| (re_multi_type(peekchr()) == NOT_MULTI\n\t\t\t    && !one_exactly\n\t\t\t    && !is_Magic(c))); ++len)\n\t    {\n\t\tc = no_Magic(c);\n\t\tif (has_mbyte)\n\t\t{\n\t\t    regmbc(c);\n\t\t    if (enc_utf8)\n\t\t    {\n\t\t\tint\tl;\n\n\t\t\t// Need to get composing character too.\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t    l = utf_ptr2len(regparse);\n\t\t\t    if (!UTF_COMPOSINGLIKE(regparse, regparse + l))\n\t\t\t\tbreak;\n\t\t\t    regmbc(utf_ptr2char(regparse));\n\t\t\t    skipchr();\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    regc(c);\n\t\tc = getchr();\n\t    }\n\t    ungetchr();\n\n\t    regc(NUL);\n\t    *flagp |= HASWIDTH;\n\t    if (len == 1)\n\t\t*flagp |= SIMPLE;\n\t}\n\tbreak;\n    }\n\n    return ret;\n}\n\n/*\n * Parse something followed by possible [*+=].\n *\n * Note that the branching code sequences used for = and the general cases\n * of * and + are somewhat optimized:  they use the same NOTHING node as\n * both the endmarker for their branch list and the body of the last branch.\n * It might seem that this node could be dispensed with entirely, but the\n * endmarker role is not redundant.\n */\n    static char_u *\nregpiece(int *flagp)\n{\n    char_u\t    *ret;\n    int\t\t    op;\n    char_u\t    *next;\n    int\t\t    flags;\n    long\t    minval;\n    long\t    maxval;\n\n    ret = regatom(&flags);\n    if (ret == NULL)\n\treturn NULL;\n\n    op = peekchr();\n    if (re_multi_type(op) == NOT_MULTI)\n    {\n\t*flagp = flags;\n\treturn ret;\n    }\n    // default flags\n    *flagp = (WORST | SPSTART | (flags & (HASNL | HASLOOKBH)));\n\n    skipchr();\n    switch (op)\n    {\n\tcase Magic('*'):\n\t    if (flags & SIMPLE)\n\t\treginsert(STAR, ret);\n\t    else\n\t    {\n\t\t// Emit x* as (x&|), where & means \"self\".\n\t\treginsert(BRANCH, ret); // Either x\n\t\tregoptail(ret, regnode(BACK));\t// and loop\n\t\tregoptail(ret, ret);\t// back\n\t\tregtail(ret, regnode(BRANCH));\t// or\n\t\tregtail(ret, regnode(NOTHING)); // null.\n\t    }\n\t    break;\n\n\tcase Magic('+'):\n\t    if (flags & SIMPLE)\n\t\treginsert(PLUS, ret);\n\t    else\n\t    {\n\t\t// Emit x+ as x(&|), where & means \"self\".\n\t\tnext = regnode(BRANCH); // Either\n\t\tregtail(ret, next);\n\t\tregtail(regnode(BACK), ret);\t// loop back\n\t\tregtail(next, regnode(BRANCH)); // or\n\t\tregtail(ret, regnode(NOTHING)); // null.\n\t    }\n\t    *flagp = (WORST | HASWIDTH | (flags & (HASNL | HASLOOKBH)));\n\t    break;\n\n\tcase Magic('@'):\n\t    {\n\t\tint\tlop = END;\n\t\tlong\tnr;\n\n\t\tnr = getdecchrs();\n\t\tswitch (no_Magic(getchr()))\n\t\t{\n\t\t    case '=': lop = MATCH; break;\t\t  // \\@=\n\t\t    case '!': lop = NOMATCH; break;\t\t  // \\@!\n\t\t    case '>': lop = SUBPAT; break;\t\t  // \\@>\n\t\t    case '<': switch (no_Magic(getchr()))\n\t\t\t      {\n\t\t\t\t  case '=': lop = BEHIND; break;   // \\@<=\n\t\t\t\t  case '!': lop = NOBEHIND; break; // \\@<!\n\t\t\t      }\n\t\t}\n\t\tif (lop == END)\n\t\t    EMSG2_RET_NULL(_(e_invalid_character_after_str_at),\n\t\t\t\t\t\t      reg_magic == MAGIC_ALL);\n\t\t// Look behind must match with behind_pos.\n\t\tif (lop == BEHIND || lop == NOBEHIND)\n\t\t{\n\t\t    regtail(ret, regnode(BHPOS));\n\t\t    *flagp |= HASLOOKBH;\n\t\t}\n\t\tregtail(ret, regnode(END)); // operand ends\n\t\tif (lop == BEHIND || lop == NOBEHIND)\n\t\t{\n\t\t    if (nr < 0)\n\t\t\tnr = 0; // no limit is same as zero limit\n\t\t    reginsert_nr(lop, nr, ret);\n\t\t}\n\t\telse\n\t\t    reginsert(lop, ret);\n\t\tbreak;\n\t    }\n\n\tcase Magic('?'):\n\tcase Magic('='):\n\t    // Emit x= as (x|)\n\t    reginsert(BRANCH, ret);\t\t// Either x\n\t    regtail(ret, regnode(BRANCH));\t// or\n\t    next = regnode(NOTHING);\t\t// null.\n\t    regtail(ret, next);\n\t    regoptail(ret, next);\n\t    break;\n\n\tcase Magic('{'):\n\t    if (!read_limits(&minval, &maxval))\n\t\treturn NULL;\n\t    if (flags & SIMPLE)\n\t    {\n\t\treginsert(BRACE_SIMPLE, ret);\n\t\treginsert_limits(BRACE_LIMITS, minval, maxval, ret);\n\t    }\n\t    else\n\t    {\n\t\tif (num_complex_braces >= 10)\n\t\t    EMSG2_RET_NULL(_(e_too_many_complex_str_curly),\n\t\t\t\t\t\t      reg_magic == MAGIC_ALL);\n\t\treginsert(BRACE_COMPLEX + num_complex_braces, ret);\n\t\tregoptail(ret, regnode(BACK));\n\t\tregoptail(ret, ret);\n\t\treginsert_limits(BRACE_LIMITS, minval, maxval, ret);\n\t\t++num_complex_braces;\n\t    }\n\t    if (minval > 0 && maxval > 0)\n\t\t*flagp = (HASWIDTH | (flags & (HASNL | HASLOOKBH)));\n\t    break;\n    }\n    if (re_multi_type(peekchr()) != NOT_MULTI)\n    {\n\t// Can't have a multi follow a multi.\n\tif (peekchr() == Magic('*'))\n\t    EMSG2_RET_NULL(_(e_nested_str), reg_magic >= MAGIC_ON);\n\tEMSG3_RET_NULL(_(e_nested_str_chr), reg_magic == MAGIC_ALL,\n\t\t\t\t\t\t\t  no_Magic(peekchr()));\n    }\n\n    return ret;\n}\n\n/*\n * Parse one alternative of an | or & operator.\n * Implements the concatenation operator.\n */\n    static char_u *\nregconcat(int *flagp)\n{\n    char_u\t*first = NULL;\n    char_u\t*chain = NULL;\n    char_u\t*latest;\n    int\t\tflags;\n    int\t\tcont = TRUE;\n\n    *flagp = WORST;\t\t// Tentatively.\n\n    while (cont)\n    {\n\tswitch (peekchr())\n\t{\n\t    case NUL:\n\t    case Magic('|'):\n\t    case Magic('&'):\n\t    case Magic(')'):\n\t\t\t    cont = FALSE;\n\t\t\t    break;\n\t    case Magic('Z'):\n\t\t\t    regflags |= RF_ICOMBINE;\n\t\t\t    skipchr_keepstart();\n\t\t\t    break;\n\t    case Magic('c'):\n\t\t\t    regflags |= RF_ICASE;\n\t\t\t    skipchr_keepstart();\n\t\t\t    break;\n\t    case Magic('C'):\n\t\t\t    regflags |= RF_NOICASE;\n\t\t\t    skipchr_keepstart();\n\t\t\t    break;\n\t    case Magic('v'):\n\t\t\t    reg_magic = MAGIC_ALL;\n\t\t\t    skipchr_keepstart();\n\t\t\t    curchr = -1;\n\t\t\t    break;\n\t    case Magic('m'):\n\t\t\t    reg_magic = MAGIC_ON;\n\t\t\t    skipchr_keepstart();\n\t\t\t    curchr = -1;\n\t\t\t    break;\n\t    case Magic('M'):\n\t\t\t    reg_magic = MAGIC_OFF;\n\t\t\t    skipchr_keepstart();\n\t\t\t    curchr = -1;\n\t\t\t    break;\n\t    case Magic('V'):\n\t\t\t    reg_magic = MAGIC_NONE;\n\t\t\t    skipchr_keepstart();\n\t\t\t    curchr = -1;\n\t\t\t    break;\n\t    default:\n\t\t\t    latest = regpiece(&flags);\n\t\t\t    if (latest == NULL || reg_toolong)\n\t\t\t\treturn NULL;\n\t\t\t    *flagp |= flags & (HASWIDTH | HASNL | HASLOOKBH);\n\t\t\t    if (chain == NULL)\t// First piece.\n\t\t\t\t*flagp |= flags & SPSTART;\n\t\t\t    else\n\t\t\t\tregtail(chain, latest);\n\t\t\t    chain = latest;\n\t\t\t    if (first == NULL)\n\t\t\t\tfirst = latest;\n\t\t\t    break;\n\t}\n    }\n    if (first == NULL)\t\t// Loop ran zero times.\n\tfirst = regnode(NOTHING);\n    return first;\n}\n\n/*\n * Parse one alternative of an | operator.\n * Implements the & operator.\n */\n    static char_u *\nregbranch(int *flagp)\n{\n    char_u\t*ret;\n    char_u\t*chain = NULL;\n    char_u\t*latest;\n    int\t\tflags;\n\n    *flagp = WORST | HASNL;\t\t// Tentatively.\n\n    ret = regnode(BRANCH);\n    for (;;)\n    {\n\tlatest = regconcat(&flags);\n\tif (latest == NULL)\n\t    return NULL;\n\t// If one of the branches has width, the whole thing has.  If one of\n\t// the branches anchors at start-of-line, the whole thing does.\n\t// If one of the branches uses look-behind, the whole thing does.\n\t*flagp |= flags & (HASWIDTH | SPSTART | HASLOOKBH);\n\t// If one of the branches doesn't match a line-break, the whole thing\n\t// doesn't.\n\t*flagp &= ~HASNL | (flags & HASNL);\n\tif (chain != NULL)\n\t    regtail(chain, latest);\n\tif (peekchr() != Magic('&'))\n\t    break;\n\tskipchr();\n\tregtail(latest, regnode(END)); // operand ends\n\tif (reg_toolong)\n\t    break;\n\treginsert(MATCH, latest);\n\tchain = latest;\n    }\n\n    return ret;\n}\n\n/*\n * Parse regular expression, i.e. main body or parenthesized thing.\n *\n * Caller must absorb opening parenthesis.\n *\n * Combining parenthesis handling with the base level of regular expression\n * is a trifle forced, but the need to tie the tails of the branches to what\n * follows makes it hard to avoid.\n */\n    static char_u *\nreg(\n    int\t\tparen,\t// REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN\n    int\t\t*flagp)\n{\n    char_u\t*ret;\n    char_u\t*br;\n    char_u\t*ender;\n    int\t\tparno = 0;\n    int\t\tflags;\n\n    *flagp = HASWIDTH;\t\t// Tentatively.\n\n#ifdef FEAT_SYN_HL\n    if (paren == REG_ZPAREN)\n    {\n\t// Make a ZOPEN node.\n\tif (regnzpar >= NSUBEXP)\n\t    EMSG_RET_NULL(_(e_too_many_z));\n\tparno = regnzpar;\n\tregnzpar++;\n\tret = regnode(ZOPEN + parno);\n    }\n    else\n#endif\n\tif (paren == REG_PAREN)\n    {\n\t// Make a MOPEN node.\n\tif (regnpar >= NSUBEXP)\n\t    EMSG2_RET_NULL(_(e_too_many_str_open), reg_magic == MAGIC_ALL);\n\tparno = regnpar;\n\t++regnpar;\n\tret = regnode(MOPEN + parno);\n    }\n    else if (paren == REG_NPAREN)\n    {\n\t// Make a NOPEN node.\n\tret = regnode(NOPEN);\n    }\n    else\n\tret = NULL;\n\n    // Pick up the branches, linking them together.\n    br = regbranch(&flags);\n    if (br == NULL)\n\treturn NULL;\n    if (ret != NULL)\n\tregtail(ret, br);\t// [MZ]OPEN -> first.\n    else\n\tret = br;\n    // If one of the branches can be zero-width, the whole thing can.\n    // If one of the branches has * at start or matches a line-break, the\n    // whole thing can.\n    if (!(flags & HASWIDTH))\n\t*flagp &= ~HASWIDTH;\n    *flagp |= flags & (SPSTART | HASNL | HASLOOKBH);\n    while (peekchr() == Magic('|'))\n    {\n\tskipchr();\n\tbr = regbranch(&flags);\n\tif (br == NULL || reg_toolong)\n\t    return NULL;\n\tregtail(ret, br);\t// BRANCH -> BRANCH.\n\tif (!(flags & HASWIDTH))\n\t    *flagp &= ~HASWIDTH;\n\t*flagp |= flags & (SPSTART | HASNL | HASLOOKBH);\n    }\n\n    // Make a closing node, and hook it on the end.\n    ender = regnode(\n#ifdef FEAT_SYN_HL\n\t    paren == REG_ZPAREN ? ZCLOSE + parno :\n#endif\n\t    paren == REG_PAREN ? MCLOSE + parno :\n\t    paren == REG_NPAREN ? NCLOSE : END);\n    regtail(ret, ender);\n\n    // Hook the tails of the branches to the closing node.\n    for (br = ret; br != NULL; br = regnext(br))\n\tregoptail(br, ender);\n\n    // Check for proper termination.\n    if (paren != REG_NOPAREN && getchr() != Magic(')'))\n    {\n#ifdef FEAT_SYN_HL\n\tif (paren == REG_ZPAREN)\n\t    EMSG_RET_NULL(_(e_unmatched_z));\n\telse\n#endif\n\t    if (paren == REG_NPAREN)\n\t    EMSG2_RET_NULL(_(e_unmatched_str_percent_open), reg_magic == MAGIC_ALL);\n\telse\n\t    EMSG2_RET_NULL(_(e_unmatched_str_open), reg_magic == MAGIC_ALL);\n    }\n    else if (paren == REG_NOPAREN && peekchr() != NUL)\n    {\n\tif (curchr == Magic(')'))\n\t    EMSG2_RET_NULL(_(e_unmatched_str_close), reg_magic == MAGIC_ALL);\n\telse\n\t    EMSG_RET_NULL(_(e_trailing_characters));\t// \"Can't happen\".\n\t// NOTREACHED\n    }\n    // Here we set the flag allowing back references to this set of\n    // parentheses.\n    if (paren == REG_PAREN)\n\thad_endbrace[parno] = TRUE;\t// have seen the close paren\n    return ret;\n}\n\n/*\n * bt_regcomp() - compile a regular expression into internal code for the\n * traditional back track matcher.\n * Returns the program in allocated space.  Returns NULL for an error.\n *\n * We can't allocate space until we know how big the compiled form will be,\n * but we can't compile it (and thus know how big it is) until we've got a\n * place to put the code.  So we cheat:  we compile it twice, once with code\n * generation turned off and size counting turned on, and once \"for real\".\n * This also means that we don't allocate space until we are sure that the\n * thing really will compile successfully, and we never have to move the\n * code and thus invalidate pointers into it.  (Note that it has to be in\n * one piece because vim_free() must be able to free it all.)\n *\n * Whether upper/lower case is to be ignored is decided when executing the\n * program, it does not matter here.\n *\n * Beware that the optimization-preparation code in here knows about some\n * of the structure of the compiled regexp.\n * \"re_flags\": RE_MAGIC and/or RE_STRING.\n */\n    static regprog_T *\nbt_regcomp(char_u *expr, int re_flags)\n{\n    bt_regprog_T    *r;\n    char_u\t*scan;\n    char_u\t*longest;\n    int\t\tlen;\n    int\t\tflags;\n\n    if (expr == NULL)\n\tIEMSG_RET_NULL(_(e_null_argument));\n\n    init_class_tab();\n\n    // First pass: determine size, legality.\n    regcomp_start(expr, re_flags);\n    regcode = JUST_CALC_SIZE;\n    regc(REGMAGIC);\n    if (reg(REG_NOPAREN, &flags) == NULL)\n\treturn NULL;\n\n    // Allocate space.\n    r = alloc(offsetof(bt_regprog_T, program) + regsize);\n    if (r == NULL)\n\treturn NULL;\n    r->re_in_use = FALSE;\n\n    // Second pass: emit code.\n    regcomp_start(expr, re_flags);\n    regcode = r->program;\n    regc(REGMAGIC);\n    if (reg(REG_NOPAREN, &flags) == NULL || reg_toolong)\n    {\n\tvim_free(r);\n\tif (reg_toolong)\n\t    EMSG_RET_NULL(_(e_pattern_too_long));\n\treturn NULL;\n    }\n\n    // Dig out information for optimizations.\n    r->regstart = NUL;\t\t// Worst-case defaults.\n    r->reganch = 0;\n    r->regmust = NULL;\n    r->regmlen = 0;\n    r->regflags = regflags;\n    if (flags & HASNL)\n\tr->regflags |= RF_HASNL;\n    if (flags & HASLOOKBH)\n\tr->regflags |= RF_LOOKBH;\n#ifdef FEAT_SYN_HL\n    // Remember whether this pattern has any \\z specials in it.\n    r->reghasz = re_has_z;\n#endif\n    scan = r->program + 1;\t// First BRANCH.\n    if (OP(regnext(scan)) == END)   // Only one top-level choice.\n    {\n\tscan = OPERAND(scan);\n\n\t// Starting-point info.\n\tif (OP(scan) == BOL || OP(scan) == RE_BOF)\n\t{\n\t    r->reganch++;\n\t    scan = regnext(scan);\n\t}\n\n\tif (OP(scan) == EXACTLY)\n\t{\n\t    if (has_mbyte)\n\t\tr->regstart = (*mb_ptr2char)(OPERAND(scan));\n\t    else\n\t\tr->regstart = *OPERAND(scan);\n\t}\n\telse if ((OP(scan) == BOW\n\t\t    || OP(scan) == EOW\n\t\t    || OP(scan) == NOTHING\n\t\t    || OP(scan) == MOPEN + 0 || OP(scan) == NOPEN\n\t\t    || OP(scan) == MCLOSE + 0 || OP(scan) == NCLOSE)\n\t\t && OP(regnext(scan)) == EXACTLY)\n\t{\n\t    if (has_mbyte)\n\t\tr->regstart = (*mb_ptr2char)(OPERAND(regnext(scan)));\n\t    else\n\t\tr->regstart = *OPERAND(regnext(scan));\n\t}\n\n\t// If there's something expensive in the r.e., find the longest\n\t// literal string that must appear and make it the regmust.  Resolve\n\t// ties in favor of later strings, since the regstart check works\n\t// with the beginning of the r.e. and avoiding duplication\n\t// strengthens checking.  Not a strong reason, but sufficient in the\n\t// absence of others.\n\n\t// When the r.e. starts with BOW, it is faster to look for a regmust\n\t// first. Used a lot for \"#\" and \"*\" commands. (Added by mool).\n\tif ((flags & SPSTART || OP(scan) == BOW || OP(scan) == EOW)\n\t\t\t\t\t\t\t  && !(flags & HASNL))\n\t{\n\t    longest = NULL;\n\t    len = 0;\n\t    for (; scan != NULL; scan = regnext(scan))\n\t\tif (OP(scan) == EXACTLY && STRLEN(OPERAND(scan)) >= (size_t)len)\n\t\t{\n\t\t    longest = OPERAND(scan);\n\t\t    len = (int)STRLEN(OPERAND(scan));\n\t\t}\n\t    r->regmust = longest;\n\t    r->regmlen = len;\n\t}\n    }\n#ifdef BT_REGEXP_DUMP\n    regdump(expr, r);\n#endif\n    r->engine = &bt_regengine;\n    return (regprog_T *)r;\n}\n\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n/*\n * Check if during the previous call to vim_regcomp the EOL item \"$\" has been\n * found.  This is messy, but it works fine.\n */\n    int\nvim_regcomp_had_eol(void)\n{\n    return had_eol;\n}\n#endif\n\n/*\n * Get a number after a backslash that is inside [].\n * When nothing is recognized return a backslash.\n */\n    static int\ncoll_get_char(void)\n{\n    long\tnr = -1;\n\n    switch (*regparse++)\n    {\n\tcase 'd': nr = getdecchrs(); break;\n\tcase 'o': nr = getoctchrs(); break;\n\tcase 'x': nr = gethexchrs(2); break;\n\tcase 'u': nr = gethexchrs(4); break;\n\tcase 'U': nr = gethexchrs(8); break;\n    }\n    if (nr < 0 || nr > INT_MAX)\n    {\n\t// If getting the number fails be backwards compatible: the character\n\t// is a backslash.\n\t--regparse;\n\tnr = '\\\\';\n    }\n    return nr;\n}\n\n/*\n * Free a compiled regexp program, returned by bt_regcomp().\n */\n    static void\nbt_regfree(regprog_T *prog)\n{\n    vim_free(prog);\n}\n\n#define ADVANCE_REGINPUT() MB_PTR_ADV(rex.input)\n\n/*\n * The arguments from BRACE_LIMITS are stored here.  They are actually local\n * to regmatch(), but they are here to reduce the amount of stack space used\n * (it can be called recursively many times).\n */\nstatic long\tbl_minval;\nstatic long\tbl_maxval;\n\n/*\n * Save the input line and position in a regsave_T.\n */\n    static void\nreg_save(regsave_T *save, garray_T *gap)\n{\n    if (REG_MULTI)\n    {\n\tsave->rs_u.pos.col = (colnr_T)(rex.input - rex.line);\n\tsave->rs_u.pos.lnum = rex.lnum;\n    }\n    else\n\tsave->rs_u.ptr = rex.input;\n    save->rs_len = gap->ga_len;\n}\n\n/*\n * Restore the input line and position from a regsave_T.\n */\n    static void\nreg_restore(regsave_T *save, garray_T *gap)\n{\n    if (REG_MULTI)\n    {\n\tif (rex.lnum != save->rs_u.pos.lnum)\n\t{\n\t    // only call reg_getline() when the line number changed to save\n\t    // a bit of time\n\t    rex.lnum = save->rs_u.pos.lnum;\n\t    rex.line = reg_getline(rex.lnum);\n\t}\n\trex.input = rex.line + save->rs_u.pos.col;\n    }\n    else\n\trex.input = save->rs_u.ptr;\n    gap->ga_len = save->rs_len;\n}\n\n/*\n * Return TRUE if current position is equal to saved position.\n */\n    static int\nreg_save_equal(regsave_T *save)\n{\n    if (REG_MULTI)\n\treturn rex.lnum == save->rs_u.pos.lnum\n\t\t\t\t  && rex.input == rex.line + save->rs_u.pos.col;\n    return rex.input == save->rs_u.ptr;\n}\n\n// Save the sub-expressions before attempting a match.\n#define save_se(savep, posp, pp) \\\n    REG_MULTI ? save_se_multi((savep), (posp)) : save_se_one((savep), (pp))\n\n// After a failed match restore the sub-expressions.\n#define restore_se(savep, posp, pp) { \\\n    if (REG_MULTI) \\\n\t*(posp) = (savep)->se_u.pos; \\\n    else \\\n\t*(pp) = (savep)->se_u.ptr; }\n\n/*\n * Tentatively set the sub-expression start to the current position (after\n * calling regmatch() they will have changed).  Need to save the existing\n * values for when there is no match.\n * Use se_save() to use pointer (save_se_multi()) or position (save_se_one()),\n * depending on REG_MULTI.\n */\n    static void\nsave_se_multi(save_se_T *savep, lpos_T *posp)\n{\n    savep->se_u.pos = *posp;\n    posp->lnum = rex.lnum;\n    posp->col = (colnr_T)(rex.input - rex.line);\n}\n\n    static void\nsave_se_one(save_se_T *savep, char_u **pp)\n{\n    savep->se_u.ptr = *pp;\n    *pp = rex.input;\n}\n\n/*\n * regrepeat - repeatedly match something simple, return how many.\n * Advances rex.input (and rex.lnum) to just after the matched chars.\n */\n    static int\nregrepeat(\n    char_u\t*p,\n    long\tmaxcount)   // maximum number of matches allowed\n{\n    long\tcount = 0;\n    char_u\t*scan;\n    char_u\t*opnd;\n    int\t\tmask;\n    int\t\ttestval = 0;\n\n    scan = rex.input;\t    // Make local copy of rex.input for speed.\n    opnd = OPERAND(p);\n    switch (OP(p))\n    {\n      case ANY:\n      case ANY + ADD_NL:\n\twhile (count < maxcount)\n\t{\n\t    // Matching anything means we continue until end-of-line (or\n\t    // end-of-file for ANY + ADD_NL), only limited by maxcount.\n\t    while (*scan != NUL && count < maxcount)\n\t    {\n\t\t++count;\n\t\tMB_PTR_ADV(scan);\n\t    }\n\t    if (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n\t\t\t\t      || rex.reg_line_lbr || count == maxcount)\n\t\tbreak;\n\t    ++count;\t\t// count the line-break\n\t    reg_nextline();\n\t    scan = rex.input;\n\t    if (got_int)\n\t\tbreak;\n\t}\n\tbreak;\n\n      case IDENT:\n      case IDENT + ADD_NL:\n\ttestval = TRUE;\n\t// FALLTHROUGH\n      case SIDENT:\n      case SIDENT + ADD_NL:\n\twhile (count < maxcount)\n\t{\n\t    if (vim_isIDc(PTR2CHAR(scan)) && (testval || !VIM_ISDIGIT(*scan)))\n\t    {\n\t\tMB_PTR_ADV(scan);\n\t    }\n\t    else if (*scan == NUL)\n\t    {\n\t\tif (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n\t\t\t\t\t\t\t   || rex.reg_line_lbr)\n\t\t    break;\n\t\treg_nextline();\n\t\tscan = rex.input;\n\t\tif (got_int)\n\t\t    break;\n\t    }\n\t    else if (rex.reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p)))\n\t\t++scan;\n\t    else\n\t\tbreak;\n\t    ++count;\n\t}\n\tbreak;\n\n      case KWORD:\n      case KWORD + ADD_NL:\n\ttestval = TRUE;\n\t// FALLTHROUGH\n      case SKWORD:\n      case SKWORD + ADD_NL:\n\twhile (count < maxcount)\n\t{\n\t    if (vim_iswordp_buf(scan, rex.reg_buf)\n\t\t\t\t\t  && (testval || !VIM_ISDIGIT(*scan)))\n\t    {\n\t\tMB_PTR_ADV(scan);\n\t    }\n\t    else if (*scan == NUL)\n\t    {\n\t\tif (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n\t\t\t\t\t\t\t   || rex.reg_line_lbr)\n\t\t    break;\n\t\treg_nextline();\n\t\tscan = rex.input;\n\t\tif (got_int)\n\t\t    break;\n\t    }\n\t    else if (rex.reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p)))\n\t\t++scan;\n\t    else\n\t\tbreak;\n\t    ++count;\n\t}\n\tbreak;\n\n      case FNAME:\n      case FNAME + ADD_NL:\n\ttestval = TRUE;\n\t// FALLTHROUGH\n      case SFNAME:\n      case SFNAME + ADD_NL:\n\twhile (count < maxcount)\n\t{\n\t    if (vim_isfilec(PTR2CHAR(scan)) && (testval || !VIM_ISDIGIT(*scan)))\n\t    {\n\t\tMB_PTR_ADV(scan);\n\t    }\n\t    else if (*scan == NUL)\n\t    {\n\t\tif (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n\t\t\t\t\t\t\t   || rex.reg_line_lbr)\n\t\t    break;\n\t\treg_nextline();\n\t\tscan = rex.input;\n\t\tif (got_int)\n\t\t    break;\n\t    }\n\t    else if (rex.reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p)))\n\t\t++scan;\n\t    else\n\t\tbreak;\n\t    ++count;\n\t}\n\tbreak;\n\n      case PRINT:\n      case PRINT + ADD_NL:\n\ttestval = TRUE;\n\t// FALLTHROUGH\n      case SPRINT:\n      case SPRINT + ADD_NL:\n\twhile (count < maxcount)\n\t{\n\t    if (*scan == NUL)\n\t    {\n\t\tif (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n\t\t\t\t\t\t\t   || rex.reg_line_lbr)\n\t\t    break;\n\t\treg_nextline();\n\t\tscan = rex.input;\n\t\tif (got_int)\n\t\t    break;\n\t    }\n\t    else if (vim_isprintc(PTR2CHAR(scan)) == 1\n\t\t\t\t\t  && (testval || !VIM_ISDIGIT(*scan)))\n\t    {\n\t\tMB_PTR_ADV(scan);\n\t    }\n\t    else if (rex.reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p)))\n\t\t++scan;\n\t    else\n\t\tbreak;\n\t    ++count;\n\t}\n\tbreak;\n\n      case WHITE:\n      case WHITE + ADD_NL:\n\ttestval = mask = RI_WHITE;\ndo_class:\n\twhile (count < maxcount)\n\t{\n\t    int\t\tl;\n\n\t    if (*scan == NUL)\n\t    {\n\t\tif (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n\t\t\t\t\t\t\t   || rex.reg_line_lbr)\n\t\t    break;\n\t\treg_nextline();\n\t\tscan = rex.input;\n\t\tif (got_int)\n\t\t    break;\n\t    }\n\t    else if (has_mbyte && (l = (*mb_ptr2len)(scan)) > 1)\n\t    {\n\t\tif (testval != 0)\n\t\t    break;\n\t\tscan += l;\n\t    }\n\t    else if ((class_tab[*scan] & mask) == testval)\n\t\t++scan;\n\t    else if (rex.reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p)))\n\t\t++scan;\n\t    else\n\t\tbreak;\n\t    ++count;\n\t}\n\tbreak;\n\n      case NWHITE:\n      case NWHITE + ADD_NL:\n\tmask = RI_WHITE;\n\tgoto do_class;\n      case DIGIT:\n      case DIGIT + ADD_NL:\n\ttestval = mask = RI_DIGIT;\n\tgoto do_class;\n      case NDIGIT:\n      case NDIGIT + ADD_NL:\n\tmask = RI_DIGIT;\n\tgoto do_class;\n      case HEX:\n      case HEX + ADD_NL:\n\ttestval = mask = RI_HEX;\n\tgoto do_class;\n      case NHEX:\n      case NHEX + ADD_NL:\n\tmask = RI_HEX;\n\tgoto do_class;\n      case OCTAL:\n      case OCTAL + ADD_NL:\n\ttestval = mask = RI_OCTAL;\n\tgoto do_class;\n      case NOCTAL:\n      case NOCTAL + ADD_NL:\n\tmask = RI_OCTAL;\n\tgoto do_class;\n      case WORD:\n      case WORD + ADD_NL:\n\ttestval = mask = RI_WORD;\n\tgoto do_class;\n      case NWORD:\n      case NWORD + ADD_NL:\n\tmask = RI_WORD;\n\tgoto do_class;\n      case HEAD:\n      case HEAD + ADD_NL:\n\ttestval = mask = RI_HEAD;\n\tgoto do_class;\n      case NHEAD:\n      case NHEAD + ADD_NL:\n\tmask = RI_HEAD;\n\tgoto do_class;\n      case ALPHA:\n      case ALPHA + ADD_NL:\n\ttestval = mask = RI_ALPHA;\n\tgoto do_class;\n      case NALPHA:\n      case NALPHA + ADD_NL:\n\tmask = RI_ALPHA;\n\tgoto do_class;\n      case LOWER:\n      case LOWER + ADD_NL:\n\ttestval = mask = RI_LOWER;\n\tgoto do_class;\n      case NLOWER:\n      case NLOWER + ADD_NL:\n\tmask = RI_LOWER;\n\tgoto do_class;\n      case UPPER:\n      case UPPER + ADD_NL:\n\ttestval = mask = RI_UPPER;\n\tgoto do_class;\n      case NUPPER:\n      case NUPPER + ADD_NL:\n\tmask = RI_UPPER;\n\tgoto do_class;\n\n      case EXACTLY:\n\t{\n\t    int\t    cu, cl;\n\n\t    // This doesn't do a multi-byte character, because a MULTIBYTECODE\n\t    // would have been used for it.  It does handle single-byte\n\t    // characters, such as latin1.\n\t    if (rex.reg_ic)\n\t    {\n\t\tcu = MB_TOUPPER(*opnd);\n\t\tcl = MB_TOLOWER(*opnd);\n\t\twhile (count < maxcount && (*scan == cu || *scan == cl))\n\t\t{\n\t\t    count++;\n\t\t    scan++;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tcu = *opnd;\n\t\twhile (count < maxcount && *scan == cu)\n\t\t{\n\t\t    count++;\n\t\t    scan++;\n\t\t}\n\t    }\n\t    break;\n\t}\n\n      case MULTIBYTECODE:\n\t{\n\t    int\t\ti, len, cf = 0;\n\n\t    // Safety check (just in case 'encoding' was changed since\n\t    // compiling the program).\n\t    if ((len = (*mb_ptr2len)(opnd)) > 1)\n\t    {\n\t\tif (rex.reg_ic && enc_utf8)\n\t\t    cf = utf_fold(utf_ptr2char(opnd));\n\t\twhile (count < maxcount && (*mb_ptr2len)(scan) >= len)\n\t\t{\n\t\t    for (i = 0; i < len; ++i)\n\t\t\tif (opnd[i] != scan[i])\n\t\t\t    break;\n\t\t    if (i < len && (!rex.reg_ic || !enc_utf8\n\t\t\t\t\t|| utf_fold(utf_ptr2char(scan)) != cf))\n\t\t\tbreak;\n\t\t    scan += len;\n\t\t    ++count;\n\t\t}\n\t    }\n\t}\n\tbreak;\n\n      case ANYOF:\n      case ANYOF + ADD_NL:\n\ttestval = TRUE;\n\t// FALLTHROUGH\n\n      case ANYBUT:\n      case ANYBUT + ADD_NL:\n\twhile (count < maxcount)\n\t{\n\t    int len;\n\n\t    if (*scan == NUL)\n\t    {\n\t\tif (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n\t\t\t\t\t\t\t   || rex.reg_line_lbr)\n\t\t    break;\n\t\treg_nextline();\n\t\tscan = rex.input;\n\t\tif (got_int)\n\t\t    break;\n\t    }\n\t    else if (rex.reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p)))\n\t\t++scan;\n\t    else if (has_mbyte && (len = (*mb_ptr2len)(scan)) > 1)\n\t    {\n\t\tif ((cstrchr(opnd, (*mb_ptr2char)(scan)) == NULL) == testval)\n\t\t    break;\n\t\tscan += len;\n\t    }\n\t    else\n\t    {\n\t\tif ((cstrchr(opnd, *scan) == NULL) == testval)\n\t\t    break;\n\t\t++scan;\n\t    }\n\t    ++count;\n\t}\n\tbreak;\n\n      case NEWL:\n\twhile (count < maxcount\n\t\t&& ((*scan == NUL && rex.lnum <= rex.reg_maxline\n\t\t\t\t       && !rex.reg_line_lbr && REG_MULTI)\n\t\t    || (*scan == '\\n' && rex.reg_line_lbr)))\n\t{\n\t    count++;\n\t    if (rex.reg_line_lbr)\n\t\tADVANCE_REGINPUT();\n\t    else\n\t\treg_nextline();\n\t    scan = rex.input;\n\t    if (got_int)\n\t\tbreak;\n\t}\n\tbreak;\n\n      default:\t\t\t// Oh dear.  Called inappropriately.\n\tiemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\tprintf(\"Called regrepeat with op code %d\\n\", OP(p));\n#endif\n\tbreak;\n    }\n\n    rex.input = scan;\n\n    return (int)count;\n}\n\n/*\n * Push an item onto the regstack.\n * Returns pointer to new item.  Returns NULL when out of memory.\n */\n    static regitem_T *\nregstack_push(regstate_T state, char_u *scan)\n{\n    regitem_T\t*rp;\n\n    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n    {\n\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\treturn NULL;\n    }\n    if (ga_grow(&regstack, sizeof(regitem_T)) == FAIL)\n\treturn NULL;\n\n    rp = (regitem_T *)((char *)regstack.ga_data + regstack.ga_len);\n    rp->rs_state = state;\n    rp->rs_scan = scan;\n\n    regstack.ga_len += sizeof(regitem_T);\n    return rp;\n}\n\n/*\n * Pop an item from the regstack.\n */\n    static void\nregstack_pop(char_u **scan)\n{\n    regitem_T\t*rp;\n\n    rp = (regitem_T *)((char *)regstack.ga_data + regstack.ga_len) - 1;\n    *scan = rp->rs_scan;\n\n    regstack.ga_len -= sizeof(regitem_T);\n}\n\n/*\n * Save the current subexpr to \"bp\", so that they can be restored\n * later by restore_subexpr().\n */\n    static void\nsave_subexpr(regbehind_T *bp)\n{\n    int i;\n\n    // When \"rex.need_clear_subexpr\" is set we don't need to save the values,\n    // only remember that this flag needs to be set again when restoring.\n    bp->save_need_clear_subexpr = rex.need_clear_subexpr;\n    if (!rex.need_clear_subexpr)\n    {\n\tfor (i = 0; i < NSUBEXP; ++i)\n\t{\n\t    if (REG_MULTI)\n\t    {\n\t\tbp->save_start[i].se_u.pos = rex.reg_startpos[i];\n\t\tbp->save_end[i].se_u.pos = rex.reg_endpos[i];\n\t    }\n\t    else\n\t    {\n\t\tbp->save_start[i].se_u.ptr = rex.reg_startp[i];\n\t\tbp->save_end[i].se_u.ptr = rex.reg_endp[i];\n\t    }\n\t}\n    }\n}\n\n/*\n * Restore the subexpr from \"bp\".\n */\n    static void\nrestore_subexpr(regbehind_T *bp)\n{\n    int i;\n\n    // Only need to restore saved values when they are not to be cleared.\n    rex.need_clear_subexpr = bp->save_need_clear_subexpr;\n    if (!rex.need_clear_subexpr)\n    {\n\tfor (i = 0; i < NSUBEXP; ++i)\n\t{\n\t    if (REG_MULTI)\n\t    {\n\t\trex.reg_startpos[i] = bp->save_start[i].se_u.pos;\n\t\trex.reg_endpos[i] = bp->save_end[i].se_u.pos;\n\t    }\n\t    else\n\t    {\n\t\trex.reg_startp[i] = bp->save_start[i].se_u.ptr;\n\t\trex.reg_endp[i] = bp->save_end[i].se_u.ptr;\n\t    }\n\t}\n    }\n}\n\n/*\n * regmatch - main matching routine\n *\n * Conceptually the strategy is simple: Check to see whether the current node\n * matches, push an item onto the regstack and loop to see whether the rest\n * matches, and then act accordingly.  In practice we make some effort to\n * avoid using the regstack, in particular by going through \"ordinary\" nodes\n * (that don't need to know whether the rest of the match failed) by a nested\n * loop.\n *\n * Returns TRUE when there is a match.  Leaves rex.input and rex.lnum just after\n * the last matched character.\n * Returns FALSE when there is no match.  Leaves rex.input and rex.lnum in an\n * undefined state!\n */\n    static int\nregmatch(\n    char_u\t*scan,\t\t    // Current node.\n    proftime_T\t*tm UNUSED,\t    // timeout limit or NULL\n    int\t\t*timed_out UNUSED)  // flag set on timeout or NULL\n{\n  char_u\t*next;\t\t// Next node.\n  int\t\top;\n  int\t\tc;\n  regitem_T\t*rp;\n  int\t\tno;\n  int\t\tstatus;\t\t// one of the RA_ values:\n#ifdef FEAT_RELTIME\n  int\t\ttm_count = 0;\n#endif\n\n  // Make \"regstack\" and \"backpos\" empty.  They are allocated and freed in\n  // bt_regexec_both() to reduce malloc()/free() calls.\n  regstack.ga_len = 0;\n  backpos.ga_len = 0;\n\n  // Repeat until \"regstack\" is empty.\n  for (;;)\n  {\n    // Some patterns may take a long time to match, e.g., \"\\([a-z]\\+\\)\\+Q\".\n    // Allow interrupting them with CTRL-C.\n    fast_breakcheck();\n\n#ifdef DEBUG\n    if (scan != NULL && regnarrate)\n    {\n\tmch_errmsg((char *)regprop(scan));\n\tmch_errmsg(\"(\\n\");\n    }\n#endif\n\n    // Repeat for items that can be matched sequentially, without using the\n    // regstack.\n    for (;;)\n    {\n\tif (got_int || scan == NULL)\n\t{\n\t    status = RA_FAIL;\n\t    break;\n\t}\n#ifdef FEAT_RELTIME\n\t// Check for timeout once in a 100 times to avoid overhead.\n\tif (tm != NULL && ++tm_count == 100)\n\t{\n\t    tm_count = 0;\n\t    if (profile_passed_limit(tm))\n\t    {\n\t\tif (timed_out != NULL)\n\t\t    *timed_out = TRUE;\n\t\tstatus = RA_FAIL;\n\t\tbreak;\n\t    }\n\t}\n#endif\n\tstatus = RA_CONT;\n\n#ifdef DEBUG\n\tif (regnarrate)\n\t{\n\t    mch_errmsg((char *)regprop(scan));\n\t    mch_errmsg(\"...\\n\");\n# ifdef FEAT_SYN_HL\n\t    if (re_extmatch_in != NULL)\n\t    {\n\t\tint i;\n\n\t\tmch_errmsg(_(\"External submatches:\\n\"));\n\t\tfor (i = 0; i < NSUBEXP; i++)\n\t\t{\n\t\t    mch_errmsg(\"    \\\"\");\n\t\t    if (re_extmatch_in->matches[i] != NULL)\n\t\t\tmch_errmsg((char *)re_extmatch_in->matches[i]);\n\t\t    mch_errmsg(\"\\\"\\n\");\n\t\t}\n\t    }\n# endif\n\t}\n#endif\n\tnext = regnext(scan);\n\n\top = OP(scan);\n\t// Check for character class with NL added.\n\tif (!rex.reg_line_lbr && WITH_NL(op) && REG_MULTI\n\t\t\t     && *rex.input == NUL && rex.lnum <= rex.reg_maxline)\n\t{\n\t    reg_nextline();\n\t}\n\telse if (rex.reg_line_lbr && WITH_NL(op) && *rex.input == '\\n')\n\t{\n\t    ADVANCE_REGINPUT();\n\t}\n\telse\n\t{\n\t  if (WITH_NL(op))\n\t      op -= ADD_NL;\n\t  if (has_mbyte)\n\t      c = (*mb_ptr2char)(rex.input);\n\t  else\n\t      c = *rex.input;\n\t  switch (op)\n\t  {\n\t  case BOL:\n\t    if (rex.input != rex.line)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case EOL:\n\t    if (c != NUL)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_BOF:\n\t    // We're not at the beginning of the file when below the first\n\t    // line where we started, not at the start of the line or we\n\t    // didn't start at the first line of the buffer.\n\t    if (rex.lnum != 0 || rex.input != rex.line\n\t\t\t\t       || (REG_MULTI && rex.reg_firstlnum > 1))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_EOF:\n\t    if (rex.lnum != rex.reg_maxline || c != NUL)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case CURSOR:\n\t    // Check if the buffer is in a window and compare the\n\t    // rex.reg_win->w_cursor position to the match position.\n\t    if (rex.reg_win == NULL\n\t\t    || (rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t != rex.reg_win->w_cursor.lnum)\n\t\t    || ((colnr_T)(rex.input - rex.line)\n\t\t\t\t\t\t != rex.reg_win->w_cursor.col))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_MARK:\n\t    // Compare the mark position to the match position.\n\t    {\n\t\tint\tmark = OPERAND(scan)[0];\n\t\tint\tcmp = OPERAND(scan)[1];\n\t\tpos_T\t*pos;\n\n\t\tpos = getmark_buf(rex.reg_buf, mark, FALSE);\n\t\tif (pos == NULL\t\t     // mark doesn't exist\n\t\t\t|| pos->lnum <= 0)   // mark isn't set in reg_buf\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t\telse\n\t\t{\n\t\t    colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t\t  && pos->col == MAXCOL\n\t\t\t\t      ? (colnr_T)STRLEN(reg_getline(\n\t\t\t\t\t\tpos->lnum - rex.reg_firstlnum))\n\t\t\t\t      : pos->col;\n\n\t\t    if ((pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t? (pos_col == (colnr_T)(rex.input - rex.line)\n\t\t\t\t    ? (cmp == '<' || cmp == '>')\n\t\t\t\t    : (pos_col < (colnr_T)(rex.input - rex.line)\n\t\t\t\t\t? cmp != '>'\n\t\t\t\t\t: cmp != '<'))\n\t\t\t\t: (pos->lnum < rex.lnum + rex.reg_firstlnum\n\t\t\t\t    ? cmp != '>'\n\t\t\t\t    : cmp != '<')))\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t    }\n\t    break;\n\n\t  case RE_VISUAL:\n\t    if (!reg_match_visual())\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_LNUM:\n\t    if (!REG_MULTI || !re_num_cmp((long_u)(rex.lnum + rex.reg_firstlnum),\n\t\t\t\t\t\t\t\t\tscan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_COL:\n\t    if (!re_num_cmp((long_u)(rex.input - rex.line) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_VCOL:\n\t    if (!re_num_cmp((long_u)win_linetabsize(\n\t\t\t    rex.reg_win == NULL ? curwin : rex.reg_win,\n\t\t\t    rex.line, (colnr_T)(rex.input - rex.line)) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case BOW:\t// \\<word; rex.input points to w\n\t    if (c == NUL)\t// Can't match at end of line\n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class;\n\n\t\t// Get class of current and previous char (if it exists).\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tif (this_class <= 1)\n\t\t    status = RA_NOMATCH;  // not on a word at all\n\t\telse if (reg_prev_class() == this_class)\n\t\t    status = RA_NOMATCH;  // previous char is in same word\n\t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(c, rex.reg_buf) || (rex.input > rex.line\n\t\t\t\t&& vim_iswordc_buf(rex.input[-1], rex.reg_buf)))\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break;\n\n\t  case EOW:\t// word\\>; rex.input points after d\n\t    if (rex.input == rex.line)    // Can't match at start of line\n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class, prev_class;\n\n\t\t// Get class of current and previous char (if it exists).\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tprev_class = reg_prev_class();\n\t\tif (this_class == prev_class\n\t\t\t|| prev_class == 0 || prev_class == 1)\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(rex.input[-1], rex.reg_buf)\n\t\t\t|| (rex.input[0] != NUL\n\t\t\t\t\t   && vim_iswordc_buf(c, rex.reg_buf)))\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break; // Matched with EOW\n\n\t  case ANY:\n\t    // ANY does not match new lines.\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case IDENT:\n\t    if (!vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SIDENT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case KWORD:\n\t    if (!vim_iswordp_buf(rex.input, rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SKWORD:\n\t    if (VIM_ISDIGIT(*rex.input)\n\t\t\t\t    || !vim_iswordp_buf(rex.input, rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case FNAME:\n\t    if (!vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SFNAME:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case PRINT:\n\t    if (!vim_isprintc(PTR2CHAR(rex.input)))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SPRINT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isprintc(PTR2CHAR(rex.input)))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case WHITE:\n\t    if (!VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NWHITE:\n\t    if (c == NUL || VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case DIGIT:\n\t    if (!ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NDIGIT:\n\t    if (c == NUL || ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case HEX:\n\t    if (!ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NHEX:\n\t    if (c == NUL || ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case OCTAL:\n\t    if (!ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NOCTAL:\n\t    if (c == NUL || ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case WORD:\n\t    if (!ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NWORD:\n\t    if (c == NUL || ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case HEAD:\n\t    if (!ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NHEAD:\n\t    if (c == NUL || ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case ALPHA:\n\t    if (!ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NALPHA:\n\t    if (c == NUL || ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case LOWER:\n\t    if (!ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NLOWER:\n\t    if (c == NUL || ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case UPPER:\n\t    if (!ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NUPPER:\n\t    if (c == NUL || ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case EXACTLY:\n\t    {\n\t\tint\tlen;\n\t\tchar_u\t*opnd;\n\n\t\topnd = OPERAND(scan);\n\t\t// Inline the first byte, for speed.\n\t\tif (*opnd != *rex.input\n\t\t\t&& (!rex.reg_ic\n\t\t\t    || (!enc_utf8\n\t\t\t      && MB_TOLOWER(*opnd) != MB_TOLOWER(*rex.input))))\n\t\t    status = RA_NOMATCH;\n\t\telse if (*opnd == NUL)\n\t\t{\n\t\t    // match empty string always works; happens when \"~\" is\n\t\t    // empty.\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (opnd[1] == NUL && !(enc_utf8 && rex.reg_ic))\n\t\t    {\n\t\t\tlen = 1;\t// matched a single byte above\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Need to match first byte again for multi-byte.\n\t\t\tlen = (int)STRLEN(opnd);\n\t\t\tif (cstrncmp(opnd, rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\t\t    }\n\t\t    // Check for following composing character, unless %C\n\t\t    // follows (skips over all composing chars).\n\t\t    if (status != RA_NOMATCH\n\t\t\t    && enc_utf8\n\t\t\t    && UTF_COMPOSINGLIKE(rex.input, rex.input + len)\n\t\t\t    && !rex.reg_icombine\n\t\t\t    && OP(next) != RE_COMPOSING)\n\t\t    {\n\t\t\t// raaron: This code makes a composing character get\n\t\t\t// ignored, which is the correct behavior (sometimes)\n\t\t\t// for voweled Hebrew texts.\n\t\t\tstatus = RA_NOMATCH;\n\t\t    }\n\t\t    if (status != RA_NOMATCH)\n\t\t\trex.input += len;\n\t\t}\n\t    }\n\t    break;\n\n\t  case ANYOF:\n\t  case ANYBUT:\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else if ((cstrchr(OPERAND(scan), c) == NULL) == (op == ANYOF))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case MULTIBYTECODE:\n\t    if (has_mbyte)\n\t    {\n\t\tint\ti, len;\n\t\tchar_u\t*opnd;\n\t\tint\topndc = 0, inpc;\n\n\t\topnd = OPERAND(scan);\n\t\t// Safety check (just in case 'encoding' was changed since\n\t\t// compiling the program).\n\t\tif ((len = (*mb_ptr2len)(opnd)) < 2)\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    break;\n\t\t}\n\t\tif (enc_utf8)\n\t\t    opndc = utf_ptr2char(opnd);\n\t\tif (enc_utf8 && utf_iscomposing(opndc))\n\t\t{\n\t\t    // When only a composing char is given match at any\n\t\t    // position where that composing char appears.\n\t\t    status = RA_NOMATCH;\n\t\t    for (i = 0; rex.input[i] != NUL;\n\t\t\t\t\t\ti += utf_ptr2len(rex.input + i))\n\t\t    {\n\t\t\tinpc = utf_ptr2char(rex.input + i);\n\t\t\tif (!utf_iscomposing(inpc))\n\t\t\t{\n\t\t\t    if (i > 0)\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (opndc == inpc)\n\t\t\t{\n\t\t\t    // Include all following composing chars.\n\t\t\t    len = i + utfc_ptr2len(rex.input + i);\n\t\t\t    status = RA_MATCH;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    for (i = 0; i < len; ++i)\n\t\t\tif (opnd[i] != rex.input[i])\n\t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    break;\n\t\t\t}\n\t\trex.input += len;\n\t    }\n\t    else\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_COMPOSING:\n\t    if (enc_utf8)\n\t    {\n\t\t// Skip composing characters.\n\t\twhile (utf_iscomposing(utf_ptr2char(rex.input)))\n\t\t    MB_CPTR_ADV(rex.input);\n\t    }\n\t    break;\n\n\t  case NOTHING:\n\t    break;\n\n\t  case BACK:\n\t    {\n\t\tint\t\ti;\n\t\tbackpos_T\t*bp;\n\n\t\t// When we run into BACK we need to check if we don't keep\n\t\t// looping without matching any input.  The second and later\n\t\t// times a BACK is encountered it fails if the input is still\n\t\t// at the same position as the previous time.\n\t\t// The positions are stored in \"backpos\" and found by the\n\t\t// current value of \"scan\", the position in the RE program.\n\t\tbp = (backpos_T *)backpos.ga_data;\n\t\tfor (i = 0; i < backpos.ga_len; ++i)\n\t\t    if (bp[i].bp_scan == scan)\n\t\t\tbreak;\n\t\tif (i == backpos.ga_len)\n\t\t{\n\t\t    // First time at this BACK, make room to store the pos.\n\t\t    if (ga_grow(&backpos, 1) == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\t// get \"ga_data\" again, it may have changed\n\t\t\tbp = (backpos_T *)backpos.ga_data;\n\t\t\tbp[i].bp_scan = scan;\n\t\t\t++backpos.ga_len;\n\t\t    }\n\t\t}\n\t\telse if (reg_save_equal(&bp[i].bp_pos))\n\t\t    // Still at same position as last time, fail.\n\t\t    status = RA_NOMATCH;\n\n\t\tif (status != RA_FAIL && status != RA_NOMATCH)\n\t\t    reg_save(&bp[i].bp_pos, &backpos);\n\t    }\n\t    break;\n\n\t  case MOPEN + 0:   // Match start: \\zs\n\t  case MOPEN + 1:   // \\(\n\t  case MOPEN + 2:\n\t  case MOPEN + 3:\n\t  case MOPEN + 4:\n\t  case MOPEN + 5:\n\t  case MOPEN + 6:\n\t  case MOPEN + 7:\n\t  case MOPEN + 8:\n\t  case MOPEN + 9:\n\t    {\n\t\tno = op - MOPEN;\n\t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MOPEN, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &rex.reg_startpos[no],\n\t\t\t\t\t\t\t  &rex.reg_startp[no]);\n\t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\t    break;\n\n\t  case NOPEN:\t    // \\%(\n\t  case NCLOSE:\t    // \\) after \\%(\n\t\tif (regstack_push(RS_NOPEN, scan) == NULL)\n\t\t    status = RA_FAIL;\n\t\t// We simply continue and handle the result when done.\n\t\tbreak;\n\n#ifdef FEAT_SYN_HL\n\t  case ZOPEN + 1:\n\t  case ZOPEN + 2:\n\t  case ZOPEN + 3:\n\t  case ZOPEN + 4:\n\t  case ZOPEN + 5:\n\t  case ZOPEN + 6:\n\t  case ZOPEN + 7:\n\t  case ZOPEN + 8:\n\t  case ZOPEN + 9:\n\t    {\n\t\tno = op - ZOPEN;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZOPEN, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_startzpos[no],\n\t\t\t\t\t\t\t     &reg_startzp[no]);\n\t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\t    break;\n#endif\n\n\t  case MCLOSE + 0:  // Match end: \\ze\n\t  case MCLOSE + 1:  // \\)\n\t  case MCLOSE + 2:\n\t  case MCLOSE + 3:\n\t  case MCLOSE + 4:\n\t  case MCLOSE + 5:\n\t  case MCLOSE + 6:\n\t  case MCLOSE + 7:\n\t  case MCLOSE + 8:\n\t  case MCLOSE + 9:\n\t    {\n\t\tno = op - MCLOSE;\n\t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &rex.reg_endpos[no],\n\t\t\t\t\t\t\t    &rex.reg_endp[no]);\n\t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case ZCLOSE + 1:  // \\) after \\z(\n\t  case ZCLOSE + 2:\n\t  case ZCLOSE + 3:\n\t  case ZCLOSE + 4:\n\t  case ZCLOSE + 5:\n\t  case ZCLOSE + 6:\n\t  case ZCLOSE + 7:\n\t  case ZCLOSE + 8:\n\t  case ZCLOSE + 9:\n\t    {\n\t\tno = op - ZCLOSE;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_endzpos[no],\n\t\t\t\t\t\t\t      &reg_endzp[no]);\n\t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\t    break;\n#endif\n\n\t  case BACKREF + 1:\n\t  case BACKREF + 2:\n\t  case BACKREF + 3:\n\t  case BACKREF + 4:\n\t  case BACKREF + 5:\n\t  case BACKREF + 6:\n\t  case BACKREF + 7:\n\t  case BACKREF + 8:\n\t  case BACKREF + 9:\n\t    {\n\t\tint\t\tlen;\n\n\t\tno = op - BACKREF;\n\t\tcleanup_subexpr();\n\t\tif (!REG_MULTI)\t\t// Single-line regexp\n\t\t{\n\t\t    if (rex.reg_startp[no] == NULL || rex.reg_endp[no] == NULL)\n\t\t    {\n\t\t\t// Backref was not set: Match an empty string.\n\t\t\tlen = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Compare current input with back-ref in the same\n\t\t\t// line.\n\t\t\tlen = (int)(rex.reg_endp[no] - rex.reg_startp[no]);\n\t\t\tif (cstrncmp(rex.reg_startp[no], rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\t\t    }\n\t\t}\n\t\telse\t\t\t\t// Multi-line regexp\n\t\t{\n\t\t    if (rex.reg_startpos[no].lnum < 0\n\t\t\t\t\t\t|| rex.reg_endpos[no].lnum < 0)\n\t\t    {\n\t\t\t// Backref was not set: Match an empty string.\n\t\t\tlen = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (rex.reg_startpos[no].lnum == rex.lnum\n\t\t\t\t&& rex.reg_endpos[no].lnum == rex.lnum)\n\t\t\t{\n\t\t\t    // Compare back-ref within the current line.\n\t\t\t    len = rex.reg_endpos[no].col\n\t\t\t\t\t\t    - rex.reg_startpos[no].col;\n\t\t\t    if (cstrncmp(rex.line + rex.reg_startpos[no].col,\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\t\tstatus = RA_NOMATCH;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Messy situation: Need to compare between two\n\t\t\t    // lines.\n\t\t\t    int r = match_with_backref(\n\t\t\t\t\t    rex.reg_startpos[no].lnum,\n\t\t\t\t\t    rex.reg_startpos[no].col,\n\t\t\t\t\t    rex.reg_endpos[no].lnum,\n\t\t\t\t\t    rex.reg_endpos[no].col,\n\t\t\t\t\t    &len);\n\n\t\t\t    if (r != RA_MATCH)\n\t\t\t\tstatus = r;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t// Matched the backref, skip over it.\n\t\trex.input += len;\n\t    }\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case ZREF + 1:\n\t  case ZREF + 2:\n\t  case ZREF + 3:\n\t  case ZREF + 4:\n\t  case ZREF + 5:\n\t  case ZREF + 6:\n\t  case ZREF + 7:\n\t  case ZREF + 8:\n\t  case ZREF + 9:\n\t    {\n\t\tint\tlen;\n\n\t\tcleanup_zsubexpr();\n\t\tno = op - ZREF;\n\t\tif (re_extmatch_in != NULL\n\t\t\t&& re_extmatch_in->matches[no] != NULL)\n\t\t{\n\t\t    len = (int)STRLEN(re_extmatch_in->matches[no]);\n\t\t    if (cstrncmp(re_extmatch_in->matches[no],\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\tstatus = RA_NOMATCH;\n\t\t    else\n\t\t\trex.input += len;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Backref was not set: Match an empty string.\n\t\t}\n\t    }\n\t    break;\n#endif\n\n\t  case BRANCH:\n\t    {\n\t\tif (OP(next) != BRANCH) // No choice.\n\t\t    next = OPERAND(scan);\t// Avoid recursion.\n\t\telse\n\t\t{\n\t\t    rp = regstack_push(RS_BRANCH, scan);\n\t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t\tstatus = RA_BREAK;\t// rest is below\n\t\t}\n\t    }\n\t    break;\n\n\t  case BRACE_LIMITS:\n\t    {\n\t\tif (OP(next) == BRACE_SIMPLE)\n\t\t{\n\t\t    bl_minval = OPERAND_MIN(scan);\n\t\t    bl_maxval = OPERAND_MAX(scan);\n\t\t}\n\t\telse if (OP(next) >= BRACE_COMPLEX\n\t\t\t&& OP(next) < BRACE_COMPLEX + 10)\n\t\t{\n\t\t    no = OP(next) - BRACE_COMPLEX;\n\t\t    brace_min[no] = OPERAND_MIN(scan);\n\t\t    brace_max[no] = OPERAND_MAX(scan);\n\t\t    brace_count[no] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    internal_error(\"BRACE_LIMITS\");\n\t\t    status = RA_FAIL;\n\t\t}\n\t    }\n\t    break;\n\n\t  case BRACE_COMPLEX + 0:\n\t  case BRACE_COMPLEX + 1:\n\t  case BRACE_COMPLEX + 2:\n\t  case BRACE_COMPLEX + 3:\n\t  case BRACE_COMPLEX + 4:\n\t  case BRACE_COMPLEX + 5:\n\t  case BRACE_COMPLEX + 6:\n\t  case BRACE_COMPLEX + 7:\n\t  case BRACE_COMPLEX + 8:\n\t  case BRACE_COMPLEX + 9:\n\t    {\n\t\tno = op - BRACE_COMPLEX;\n\t\t++brace_count[no];\n\n\t\t// If not matched enough times yet, try one more\n\t\tif (brace_count[no] <= (brace_min[no] <= brace_max[no]\n\t\t\t\t\t     ? brace_min[no] : brace_max[no]))\n\t\t{\n\t\t    rp = regstack_push(RS_BRCPLX_MORE, scan);\n\t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\trp->rs_no = no;\n\t\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tnext = OPERAND(scan);\n\t\t\t// We continue and handle the result when done.\n\t\t    }\n\t\t    break;\n\t\t}\n\n\t\t// If matched enough times, may try matching some more\n\t\tif (brace_min[no] <= brace_max[no])\n\t\t{\n\t\t    // Range is the normal way around, use longest match\n\t\t    if (brace_count[no] <= brace_max[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_LONG, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    rp->rs_no = no;\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t    next = OPERAND(scan);\n\t\t\t    // We continue and handle the result when done.\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Range is backwards, use shortest match first\n\t\t    if (brace_count[no] <= brace_min[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t    // We continue and handle the result when done.\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\t  case BRACE_SIMPLE:\n\t  case STAR:\n\t  case PLUS:\n\t    {\n\t\tregstar_T\trst;\n\n\t\t// Lookahead to avoid useless match attempts when we know\n\t\t// what character comes next.\n\t\tif (OP(next) == EXACTLY)\n\t\t{\n\t\t    rst.nextb = *OPERAND(next);\n\t\t    if (rex.reg_ic)\n\t\t    {\n\t\t\tif (MB_ISUPPER(rst.nextb))\n\t\t\t    rst.nextb_ic = MB_TOLOWER(rst.nextb);\n\t\t\telse\n\t\t\t    rst.nextb_ic = MB_TOUPPER(rst.nextb);\n\t\t    }\n\t\t    else\n\t\t\trst.nextb_ic = rst.nextb;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.nextb = NUL;\n\t\t    rst.nextb_ic = NUL;\n\t\t}\n\t\tif (op != BRACE_SIMPLE)\n\t\t{\n\t\t    rst.minval = (op == STAR) ? 0 : 1;\n\t\t    rst.maxval = MAX_LIMIT;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.minval = bl_minval;\n\t\t    rst.maxval = bl_maxval;\n\t\t}\n\n\t\t// When maxval > minval, try matching as much as possible, up\n\t\t// to maxval.  When maxval < minval, try matching at least the\n\t\t// minimal number (since the range is backwards, that's also\n\t\t// maxval!).\n\t\trst.count = regrepeat(OPERAND(scan), rst.maxval);\n\t\tif (got_int)\n\t\t{\n\t\t    status = RA_FAIL;\n\t\t    break;\n\t\t}\n\t\tif (rst.minval <= rst.maxval\n\t\t\t  ? rst.count >= rst.minval : rst.count >= rst.maxval)\n\t\t{\n\t\t    // It could match.  Prepare for trying to match what\n\t\t    // follows.  The code is below.  Parameters are stored in\n\t\t    // a regstar_T on the regstack.\n\t\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n\t\t    {\n\t\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\t\t\tstatus = RA_FAIL;\n\t\t    }\n\t\t    else if (ga_grow(&regstack, sizeof(regstar_T)) == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\tregstack.ga_len += sizeof(regstar_T);\n\t\t\trp = regstack_push(rst.minval <= rst.maxval\n\t\t\t\t\t? RS_STAR_LONG : RS_STAR_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    *(((regstar_T *)rp) - 1) = rst;\n\t\t\t    status = RA_BREAK;\t    // skip the restore bits\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    status = RA_NOMATCH;\n\n\t    }\n\t    break;\n\n\t  case NOMATCH:\n\t  case MATCH:\n\t  case SUBPAT:\n\t    rp = regstack_push(RS_NOMATCH, scan);\n\t    if (rp == NULL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\trp->rs_no = op;\n\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\tnext = OPERAND(scan);\n\t\t// We continue and handle the result when done.\n\t    }\n\t    break;\n\n\t  case BEHIND:\n\t  case NOBEHIND:\n\t    // Need a bit of room to store extra positions.\n\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n\t    {\n\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\t\tstatus = RA_FAIL;\n\t    }\n\t    else if (ga_grow(&regstack, sizeof(regbehind_T)) == FAIL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\tregstack.ga_len += sizeof(regbehind_T);\n\t\trp = regstack_push(RS_BEHIND1, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    // Need to save the subexpr to be able to restore them\n\t\t    // when there is a match but we don't use it.\n\t\t    save_subexpr(((regbehind_T *)rp) - 1);\n\n\t\t    rp->rs_no = op;\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t    // First try if what follows matches.  If it does then we\n\t\t    // check the behind match by looping.\n\t\t}\n\t    }\n\t    break;\n\n\t  case BHPOS:\n\t    if (REG_MULTI)\n\t    {\n\t\tif (behind_pos.rs_u.pos.col != (colnr_T)(rex.input - rex.line)\n\t\t\t|| behind_pos.rs_u.pos.lnum != rex.lnum)\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    else if (behind_pos.rs_u.ptr != rex.input)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case NEWL:\n\t    if ((c != NUL || !REG_MULTI || rex.lnum > rex.reg_maxline\n\t\t\t     || rex.reg_line_lbr)\n\t\t\t\t\t   && (c != '\\n' || !rex.reg_line_lbr))\n\t\tstatus = RA_NOMATCH;\n\t    else if (rex.reg_line_lbr)\n\t\tADVANCE_REGINPUT();\n\t    else\n\t\treg_nextline();\n\t    break;\n\n\t  case END:\n\t    status = RA_MATCH;\t// Success!\n\t    break;\n\n\t  default:\n\t    iemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\t    printf(\"Illegal op code %d\\n\", op);\n#endif\n\t    status = RA_FAIL;\n\t    break;\n\t  }\n\t}\n\n\t// If we can't continue sequentially, break the inner loop.\n\tif (status != RA_CONT)\n\t    break;\n\n\t// Continue in inner loop, advance to next item.\n\tscan = next;\n\n    } // end of inner loop\n\n    // If there is something on the regstack execute the code for the state.\n    // If the state is popped then loop and use the older state.\n    while (regstack.ga_len > 0 && status != RA_FAIL)\n    {\n\trp = (regitem_T *)((char *)regstack.ga_data + regstack.ga_len) - 1;\n\tswitch (rp->rs_state)\n\t{\n\t  case RS_NOPEN:\n\t    // Result is passed on as-is, simply pop the state.\n\t    regstack_pop(&scan);\n\t    break;\n\n\t  case RS_MOPEN:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &rex.reg_startpos[rp->rs_no],\n\t\t\t\t\t\t  &rex.reg_startp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case RS_ZOPEN:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_startzpos[rp->rs_no],\n\t\t\t\t\t\t &reg_startzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#endif\n\n\t  case RS_MCLOSE:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &rex.reg_endpos[rp->rs_no],\n\t\t\t\t\t\t    &rex.reg_endp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case RS_ZCLOSE:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_endzpos[rp->rs_no],\n\t\t\t\t\t\t   &reg_endzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#endif\n\n\t  case RS_BRANCH:\n\t    if (status == RA_MATCH)\n\t\t// this branch matched, use it\n\t\tregstack_pop(&scan);\n\t    else\n\t    {\n\t\tif (status != RA_BREAK)\n\t\t{\n\t\t    // After a non-matching branch: try next one.\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t    scan = rp->rs_scan;\n\t\t}\n\t\tif (scan == NULL || OP(scan) != BRANCH)\n\t\t{\n\t\t    // no more branches, didn't find a match\n\t\t    status = RA_NOMATCH;\n\t\t    regstack_pop(&scan);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Prepare to try a branch.\n\t\t    rp->rs_scan = regnext(scan);\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t    scan = OPERAND(scan);\n\t\t}\n\t    }\n\t    break;\n\n\t  case RS_BRCPLX_MORE:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\t--brace_count[rp->rs_no];\t// decrement match count\n\t    }\n\t    regstack_pop(&scan);\n\t    break;\n\n\t  case RS_BRCPLX_LONG:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\t// There was no match, but we did find enough matches.\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\t--brace_count[rp->rs_no];\n\t\t// continue with the items after \"\\{}\"\n\t\tstatus = RA_CONT;\n\t    }\n\t    regstack_pop(&scan);\n\t    if (status == RA_CONT)\n\t\tscan = regnext(scan);\n\t    break;\n\n\t  case RS_BRCPLX_SHORT:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t\t// There was no match, try to match one more item.\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t    regstack_pop(&scan);\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\tscan = OPERAND(scan);\n\t\tstatus = RA_CONT;\n\t    }\n\t    break;\n\n\t  case RS_NOMATCH:\n\t    // Pop the state.  If the operand matches for NOMATCH or\n\t    // doesn't match for MATCH/SUBPAT, we fail.  Otherwise backup,\n\t    // except for SUBPAT, and continue with the next item.\n\t    if (status == (rp->rs_no == NOMATCH ? RA_MATCH : RA_NOMATCH))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t    {\n\t\tstatus = RA_CONT;\n\t\tif (rp->rs_no != SUBPAT)\t// zero-width\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t    }\n\t    regstack_pop(&scan);\n\t    if (status == RA_CONT)\n\t\tscan = regnext(scan);\n\t    break;\n\n\t  case RS_BEHIND1:\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\t    }\n\t    else\n\t    {\n\t\t// The stuff after BEHIND/NOBEHIND matches.  Now try if\n\t\t// the behind part does (not) match before the current\n\t\t// position in the input.  This must be done at every\n\t\t// position in the input and checking if the match ends at\n\t\t// the current position.\n\n\t\t// save the position after the found match for next\n\t\treg_save(&(((regbehind_T *)rp) - 1)->save_after, &backpos);\n\n\t\t// Start looking for a match with operand at the current\n\t\t// position.  Go back one character until we find the\n\t\t// result, hitting the start of the line or the previous\n\t\t// line (for multi-line matching).\n\t\t// Set behind_pos to where the match should end, BHPOS\n\t\t// will match it.  Save the current value.\n\t\t(((regbehind_T *)rp) - 1)->save_behind = behind_pos;\n\t\tbehind_pos = rp->rs_un.regsave;\n\n\t\trp->rs_state = RS_BEHIND2;\n\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\tscan = OPERAND(rp->rs_scan) + 4;\n\t    }\n\t    break;\n\n\t  case RS_BEHIND2:\n\t    // Looping for BEHIND / NOBEHIND match.\n\t    if (status == RA_MATCH && reg_save_equal(&behind_pos))\n\t    {\n\t\t// found a match that ends where \"next\" started\n\t\tbehind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n\t\tif (rp->rs_no == BEHIND)\n\t\t    reg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\t\t\t\t\t\t\t\t    &backpos);\n\t\telse\n\t\t{\n\t\t    // But we didn't want a match.  Need to restore the\n\t\t    // subexpr, because what follows matched, so they have\n\t\t    // been set.\n\t\t    status = RA_NOMATCH;\n\t\t    restore_subexpr(((regbehind_T *)rp) - 1);\n\t\t}\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\t    }\n\t    else\n\t    {\n\t\tlong limit;\n\n\t\t// No match or a match that doesn't end where we want it: Go\n\t\t// back one character.  May go to previous line once.\n\t\tno = OK;\n\t\tlimit = OPERAND_MIN(rp->rs_scan);\n\t\tif (REG_MULTI)\n\t\t{\n\t\t    if (limit > 0\n\t\t\t    && ((rp->rs_un.regsave.rs_u.pos.lnum\n\t\t\t\t\t\t    < behind_pos.rs_u.pos.lnum\n\t\t\t\t    ? (colnr_T)STRLEN(rex.line)\n\t\t\t\t    : behind_pos.rs_u.pos.col)\n\t\t\t\t- rp->rs_un.regsave.rs_u.pos.col >= limit))\n\t\t\tno = FAIL;\n\t\t    else if (rp->rs_un.regsave.rs_u.pos.col == 0)\n\t\t    {\n\t\t\tif (rp->rs_un.regsave.rs_u.pos.lnum\n\t\t\t\t\t< behind_pos.rs_u.pos.lnum\n\t\t\t\t|| reg_getline(\n\t\t\t\t\t--rp->rs_un.regsave.rs_u.pos.lnum)\n\t\t\t\t\t\t\t\t  == NULL)\n\t\t\t    no = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t\t    rp->rs_un.regsave.rs_u.pos.col =\n\t\t\t\t\t\t (colnr_T)STRLEN(rex.line);\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t{\n\t\t\t    char_u *line =\n\t\t\t\t  reg_getline(rp->rs_un.regsave.rs_u.pos.lnum);\n\n\t\t\t    rp->rs_un.regsave.rs_u.pos.col -=\n\t\t\t\t(*mb_head_off)(line, line\n\t\t\t\t    + rp->rs_un.regsave.rs_u.pos.col - 1) + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t    --rp->rs_un.regsave.rs_u.pos.col;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (rp->rs_un.regsave.rs_u.ptr == rex.line)\n\t\t\tno = FAIL;\n\t\t    else\n\t\t    {\n\t\t\tMB_PTR_BACK(rex.line, rp->rs_un.regsave.rs_u.ptr);\n\t\t\tif (limit > 0 && (long)(behind_pos.rs_u.ptr\n\t\t\t\t     - rp->rs_un.regsave.rs_u.ptr) > limit)\n\t\t\t    no = FAIL;\n\t\t    }\n\t\t}\n\t\tif (no == OK)\n\t\t{\n\t\t    // Advanced, prepare for finding match again.\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t    scan = OPERAND(rp->rs_scan) + 4;\n\t\t    if (status == RA_MATCH)\n\t\t    {\n\t\t\t// We did match, so subexpr may have been changed,\n\t\t\t// need to restore them for the next try.\n\t\t\tstatus = RA_NOMATCH;\n\t\t\trestore_subexpr(((regbehind_T *)rp) - 1);\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Can't advance.  For NOBEHIND that's a match.\n\t\t    behind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n\t\t    if (rp->rs_no == NOBEHIND)\n\t\t    {\n\t\t\treg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\t\t\t\t\t\t\t\t    &backpos);\n\t\t\tstatus = RA_MATCH;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// We do want a proper match.  Need to restore the\n\t\t\t// subexpr if we had a match, because they may have\n\t\t\t// been set.\n\t\t\tif (status == RA_MATCH)\n\t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    restore_subexpr(((regbehind_T *)rp) - 1);\n\t\t\t}\n\t\t    }\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regbehind_T);\n\t\t}\n\t    }\n\t    break;\n\n\t  case RS_STAR_LONG:\n\t  case RS_STAR_SHORT:\n\t    {\n\t\tregstar_T\t    *rst = ((regstar_T *)rp) - 1;\n\n\t\tif (status == RA_MATCH)\n\t\t{\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regstar_T);\n\t\t    break;\n\t\t}\n\n\t\t// Tried once already, restore input pointers.\n\t\tif (status != RA_BREAK)\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\n\t\t// Repeat until we found a position where it could match.\n\t\tfor (;;)\n\t\t{\n\t\t    if (status != RA_BREAK)\n\t\t    {\n\t\t\t// Tried first position already, advance.\n\t\t\tif (rp->rs_state == RS_STAR_LONG)\n\t\t\t{\n\t\t\t    // Trying for longest match, but couldn't or\n\t\t\t    // didn't match -- back up one char.\n\t\t\t    if (--rst->count < rst->minval)\n\t\t\t\tbreak;\n\t\t\t    if (rex.input == rex.line)\n\t\t\t    {\n\t\t\t\t// backup to last char of previous line\n\t\t\t\t--rex.lnum;\n\t\t\t\trex.line = reg_getline(rex.lnum);\n\t\t\t\t// Just in case regrepeat() didn't count\n\t\t\t\t// right.\n\t\t\t\tif (rex.line == NULL)\n\t\t\t\t    break;\n\t\t\t\trex.input = rex.line + STRLEN(rex.line);\n\t\t\t\tfast_breakcheck();\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tMB_PTR_BACK(rex.line, rex.input);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Range is backwards, use shortest match first.\n\t\t\t    // Careful: maxval and minval are exchanged!\n\t\t\t    // Couldn't or didn't match: try advancing one\n\t\t\t    // char.\n\t\t\t    if (rst->count == rst->minval\n\t\t\t\t  || regrepeat(OPERAND(rp->rs_scan), 1L) == 0)\n\t\t\t\tbreak;\n\t\t\t    ++rst->count;\n\t\t\t}\n\t\t\tif (got_int)\n\t\t\t    break;\n\t\t    }\n\t\t    else\n\t\t\tstatus = RA_NOMATCH;\n\n\t\t    // If it could match, try it.\n\t\t    if (rst->nextb == NUL || *rex.input == rst->nextb\n\t\t\t\t\t     || *rex.input == rst->nextb_ic)\n\t\t    {\n\t\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tscan = regnext(rp->rs_scan);\n\t\t\tstatus = RA_CONT;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (status != RA_CONT)\n\t\t{\n\t\t    // Failed.\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regstar_T);\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t    }\n\t    break;\n\t}\n\n\t// If we want to continue the inner loop or didn't pop a state\n\t// continue matching loop\n\tif (status == RA_CONT || rp == (regitem_T *)\n\t\t\t     ((char *)regstack.ga_data + regstack.ga_len) - 1)\n\t    break;\n    }\n\n    // May need to continue with the inner loop, starting at \"scan\".\n    if (status == RA_CONT)\n\tcontinue;\n\n    // If the regstack is empty or something failed we are done.\n    if (regstack.ga_len == 0 || status == RA_FAIL)\n    {\n\tif (scan == NULL)\n\t{\n\t    // We get here only if there's trouble -- normally \"case END\" is\n\t    // the terminating point.\n\t    iemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\t    printf(\"Premature EOL\\n\");\n#endif\n\t}\n\treturn (status == RA_MATCH);\n    }\n\n  } // End of loop until the regstack is empty.\n\n  // NOTREACHED\n}\n\n/*\n * regtry - try match of \"prog\" with at rex.line[\"col\"].\n * Returns 0 for failure, number of lines contained in the match otherwise.\n */\n    static long\nregtry(\n    bt_regprog_T\t*prog,\n    colnr_T\t\tcol,\n    proftime_T\t\t*tm,\t\t// timeout limit or NULL\n    int\t\t\t*timed_out)\t// flag set on timeout or NULL\n{\n    rex.input = rex.line + col;\n    rex.need_clear_subexpr = TRUE;\n#ifdef FEAT_SYN_HL\n    // Clear the external match subpointers if necessary.\n    rex.need_clear_zsubexpr = (prog->reghasz == REX_SET);\n#endif\n\n    if (regmatch(prog->program + 1, tm, timed_out) == 0)\n\treturn 0;\n\n    cleanup_subexpr();\n    if (REG_MULTI)\n    {\n\tif (rex.reg_startpos[0].lnum < 0)\n\t{\n\t    rex.reg_startpos[0].lnum = 0;\n\t    rex.reg_startpos[0].col = col;\n\t}\n\tif (rex.reg_endpos[0].lnum < 0)\n\t{\n\t    rex.reg_endpos[0].lnum = rex.lnum;\n\t    rex.reg_endpos[0].col = (int)(rex.input - rex.line);\n\t}\n\telse\n\t    // Use line number of \"\\ze\".\n\t    rex.lnum = rex.reg_endpos[0].lnum;\n    }\n    else\n    {\n\tif (rex.reg_startp[0] == NULL)\n\t    rex.reg_startp[0] = rex.line + col;\n\tif (rex.reg_endp[0] == NULL)\n\t    rex.reg_endp[0] = rex.input;\n    }\n#ifdef FEAT_SYN_HL\n    // Package any found \\z(...\\) matches for export. Default is none.\n    unref_extmatch(re_extmatch_out);\n    re_extmatch_out = NULL;\n\n    if (prog->reghasz == REX_SET)\n    {\n\tint\t\ti;\n\n\tcleanup_zsubexpr();\n\tre_extmatch_out = make_extmatch();\n\tif (re_extmatch_out == NULL)\n\t    return 0;\n\tfor (i = 0; i < NSUBEXP; i++)\n\t{\n\t    if (REG_MULTI)\n\t    {\n\t\t// Only accept single line matches.\n\t\tif (reg_startzpos[i].lnum >= 0\n\t\t\t&& reg_endzpos[i].lnum == reg_startzpos[i].lnum\n\t\t\t&& reg_endzpos[i].col >= reg_startzpos[i].col)\n\t\t    re_extmatch_out->matches[i] =\n\t\t\tvim_strnsave(reg_getline(reg_startzpos[i].lnum)\n\t\t\t\t\t\t       + reg_startzpos[i].col,\n\t\t\t\t   reg_endzpos[i].col - reg_startzpos[i].col);\n\t    }\n\t    else\n\t    {\n\t\tif (reg_startzp[i] != NULL && reg_endzp[i] != NULL)\n\t\t    re_extmatch_out->matches[i] =\n\t\t\t    vim_strnsave(reg_startzp[i],\n\t\t\t\t\t\treg_endzp[i] - reg_startzp[i]);\n\t    }\n\t}\n    }\n#endif\n    return 1 + rex.lnum;\n}\n\n/*\n * Match a regexp against a string (\"line\" points to the string) or multiple\n * lines (if \"line\" is NULL, use reg_getline()).\n * Returns 0 for failure, number of lines contained in the match otherwise.\n */\n    static long\nbt_regexec_both(\n    char_u\t*line,\n    colnr_T\tcol,\t\t// column to start looking for match\n    proftime_T\t*tm,\t\t// timeout limit or NULL\n    int\t\t*timed_out)\t// flag set on timeout or NULL\n{\n    bt_regprog_T    *prog;\n    char_u\t    *s;\n    long\t    retval = 0L;\n\n    // Create \"regstack\" and \"backpos\" if they are not allocated yet.\n    // We allocate *_INITIAL amount of bytes first and then set the grow size\n    // to much bigger value to avoid many malloc calls in case of deep regular\n    // expressions.\n    if (regstack.ga_data == NULL)\n    {\n\t// Use an item size of 1 byte, since we push different things\n\t// onto the regstack.\n\tga_init2(&regstack, 1, REGSTACK_INITIAL);\n\t(void)ga_grow(&regstack, REGSTACK_INITIAL);\n\tregstack.ga_growsize = REGSTACK_INITIAL * 8;\n    }\n\n    if (backpos.ga_data == NULL)\n    {\n\tga_init2(&backpos, sizeof(backpos_T), BACKPOS_INITIAL);\n\t(void)ga_grow(&backpos, BACKPOS_INITIAL);\n\tbackpos.ga_growsize = BACKPOS_INITIAL * 8;\n    }\n\n    if (REG_MULTI)\n    {\n\tprog = (bt_regprog_T *)rex.reg_mmatch->regprog;\n\tline = reg_getline((linenr_T)0);\n\trex.reg_startpos = rex.reg_mmatch->startpos;\n\trex.reg_endpos = rex.reg_mmatch->endpos;\n    }\n    else\n    {\n\tprog = (bt_regprog_T *)rex.reg_match->regprog;\n\trex.reg_startp = rex.reg_match->startp;\n\trex.reg_endp = rex.reg_match->endp;\n    }\n\n    // Be paranoid...\n    if (prog == NULL || line == NULL)\n    {\n\tiemsg(_(e_null_argument));\n\tgoto theend;\n    }\n\n    // Check validity of program.\n    if (prog_magic_wrong())\n\tgoto theend;\n\n    // If the start column is past the maximum column: no need to try.\n    if (rex.reg_maxcol > 0 && col >= rex.reg_maxcol)\n\tgoto theend;\n\n    // If pattern contains \"\\c\" or \"\\C\": overrule value of rex.reg_ic\n    if (prog->regflags & RF_ICASE)\n\trex.reg_ic = TRUE;\n    else if (prog->regflags & RF_NOICASE)\n\trex.reg_ic = FALSE;\n\n    // If pattern contains \"\\Z\" overrule value of rex.reg_icombine\n    if (prog->regflags & RF_ICOMBINE)\n\trex.reg_icombine = TRUE;\n\n    // If there is a \"must appear\" string, look for it.\n    if (prog->regmust != NULL)\n    {\n\tint c;\n\n\tif (has_mbyte)\n\t    c = (*mb_ptr2char)(prog->regmust);\n\telse\n\t    c = *prog->regmust;\n\ts = line + col;\n\n\t// This is used very often, esp. for \":global\".  Use three versions of\n\t// the loop to avoid overhead of conditions.\n\tif (!rex.reg_ic && !has_mbyte)\n\t    while ((s = vim_strbyte(s, c)) != NULL)\n\t    {\n\t\tif (cstrncmp(s, prog->regmust, &prog->regmlen) == 0)\n\t\t    break;\t\t// Found it.\n\t\t++s;\n\t    }\n\telse if (!rex.reg_ic || (!enc_utf8 && mb_char2len(c) > 1))\n\t    while ((s = vim_strchr(s, c)) != NULL)\n\t    {\n\t\tif (cstrncmp(s, prog->regmust, &prog->regmlen) == 0)\n\t\t    break;\t\t// Found it.\n\t\tMB_PTR_ADV(s);\n\t    }\n\telse\n\t    while ((s = cstrchr(s, c)) != NULL)\n\t    {\n\t\tif (cstrncmp(s, prog->regmust, &prog->regmlen) == 0)\n\t\t    break;\t\t// Found it.\n\t\tMB_PTR_ADV(s);\n\t    }\n\tif (s == NULL)\t\t// Not present.\n\t    goto theend;\n    }\n\n    rex.line = line;\n    rex.lnum = 0;\n    reg_toolong = FALSE;\n\n    // Simplest case: Anchored match need be tried only once.\n    if (prog->reganch)\n    {\n\tint\tc;\n\n\tif (has_mbyte)\n\t    c = (*mb_ptr2char)(rex.line + col);\n\telse\n\t    c = rex.line[col];\n\tif (prog->regstart == NUL\n\t\t|| prog->regstart == c\n\t\t|| (rex.reg_ic\n\t\t    && (((enc_utf8 && utf_fold(prog->regstart) == utf_fold(c)))\n\t\t\t|| (c < 255 && prog->regstart < 255 &&\n\t\t\t    MB_TOLOWER(prog->regstart) == MB_TOLOWER(c)))))\n\t    retval = regtry(prog, col, tm, timed_out);\n\telse\n\t    retval = 0;\n    }\n    else\n    {\n#ifdef FEAT_RELTIME\n\tint tm_count = 0;\n#endif\n\t// Messy cases:  unanchored match.\n\twhile (!got_int)\n\t{\n\t    if (prog->regstart != NUL)\n\t    {\n\t\t// Skip until the char we know it must start with.\n\t\t// Used often, do some work to avoid call overhead.\n\t\tif (!rex.reg_ic && !has_mbyte)\n\t\t    s = vim_strbyte(rex.line + col, prog->regstart);\n\t\telse\n\t\t    s = cstrchr(rex.line + col, prog->regstart);\n\t\tif (s == NULL)\n\t\t{\n\t\t    retval = 0;\n\t\t    break;\n\t\t}\n\t\tcol = (int)(s - rex.line);\n\t    }\n\n\t    // Check for maximum column to try.\n\t    if (rex.reg_maxcol > 0 && col >= rex.reg_maxcol)\n\t    {\n\t\tretval = 0;\n\t\tbreak;\n\t    }\n\n\t    retval = regtry(prog, col, tm, timed_out);\n\t    if (retval > 0)\n\t\tbreak;\n\n\t    // if not currently on the first line, get it again\n\t    if (rex.lnum != 0)\n\t    {\n\t\trex.lnum = 0;\n\t\trex.line = reg_getline((linenr_T)0);\n\t    }\n\t    if (rex.line[col] == NUL)\n\t\tbreak;\n\t    if (has_mbyte)\n\t\tcol += (*mb_ptr2len)(rex.line + col);\n\t    else\n\t\t++col;\n#ifdef FEAT_RELTIME\n\t    // Check for timeout once in a twenty times to avoid overhead.\n\t    if (tm != NULL && ++tm_count == 20)\n\t    {\n\t\ttm_count = 0;\n\t\tif (profile_passed_limit(tm))\n\t\t{\n\t\t    if (timed_out != NULL)\n\t\t\t*timed_out = TRUE;\n\t\t    break;\n\t\t}\n\t    }\n#endif\n\t}\n    }\n\ntheend:\n    // Free \"reg_tofree\" when it's a bit big.\n    // Free regstack and backpos if they are bigger than their initial size.\n    if (reg_tofreelen > 400)\n\tVIM_CLEAR(reg_tofree);\n    if (regstack.ga_maxlen > REGSTACK_INITIAL)\n\tga_clear(&regstack);\n    if (backpos.ga_maxlen > BACKPOS_INITIAL)\n\tga_clear(&backpos);\n\n    if (retval > 0)\n    {\n\t// Make sure the end is never before the start.  Can happen when \\zs\n\t// and \\ze are used.\n\tif (REG_MULTI)\n\t{\n\t    lpos_T *start = &rex.reg_mmatch->startpos[0];\n\t    lpos_T *end = &rex.reg_mmatch->endpos[0];\n\n\t    if (end->lnum < start->lnum\n\t\t\t|| (end->lnum == start->lnum && end->col < start->col))\n\t\trex.reg_mmatch->endpos[0] = rex.reg_mmatch->startpos[0];\n\t}\n\telse\n\t{\n\t    if (rex.reg_match->endp[0] < rex.reg_match->startp[0])\n\t\trex.reg_match->endp[0] = rex.reg_match->startp[0];\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Match a regexp against a string.\n * \"rmp->regprog\" is a compiled regexp as returned by vim_regcomp().\n * Uses curbuf for line count and 'iskeyword'.\n * if \"line_lbr\" is TRUE  consider a \"\\n\" in \"line\" to be a line break.\n *\n * Returns 0 for failure, number of lines contained in the match otherwise.\n */\n    static int\nbt_regexec_nl(\n    regmatch_T\t*rmp,\n    char_u\t*line,\t// string to match against\n    colnr_T\tcol,\t// column to start looking for match\n    int\t\tline_lbr)\n{\n    rex.reg_match = rmp;\n    rex.reg_mmatch = NULL;\n    rex.reg_maxline = 0;\n    rex.reg_line_lbr = line_lbr;\n    rex.reg_buf = curbuf;\n    rex.reg_win = NULL;\n    rex.reg_ic = rmp->rm_ic;\n    rex.reg_icombine = FALSE;\n    rex.reg_maxcol = 0;\n\n    return bt_regexec_both(line, col, NULL, NULL);\n}\n\n/*\n * Match a regexp against multiple lines.\n * \"rmp->regprog\" is a compiled regexp as returned by vim_regcomp().\n * Uses curbuf for line count and 'iskeyword'.\n *\n * Return zero if there is no match.  Return number of lines contained in the\n * match otherwise.\n */\n    static long\nbt_regexec_multi(\n    regmmatch_T\t*rmp,\n    win_T\t*win,\t\t// window in which to search or NULL\n    buf_T\t*buf,\t\t// buffer in which to search\n    linenr_T\tlnum,\t\t// nr of line to start looking for match\n    colnr_T\tcol,\t\t// column to start looking for match\n    proftime_T\t*tm,\t\t// timeout limit or NULL\n    int\t\t*timed_out)\t// flag set on timeout or NULL\n{\n    init_regexec_multi(rmp, win, buf, lnum);\n    return bt_regexec_both(NULL, col, tm, timed_out);\n}\n\n/*\n * Compare a number with the operand of RE_LNUM, RE_COL or RE_VCOL.\n */\n    static int\nre_num_cmp(long_u val, char_u *scan)\n{\n    long_u  n = OPERAND_MIN(scan);\n\n    if (OPERAND_CMP(scan) == '>')\n\treturn val > n;\n    if (OPERAND_CMP(scan) == '<')\n\treturn val < n;\n    return val == n;\n}\n\n#ifdef BT_REGEXP_DUMP\n\n/*\n * regdump - dump a regexp onto stdout in vaguely comprehensible form\n */\n    static void\nregdump(char_u *pattern, bt_regprog_T *r)\n{\n    char_u  *s;\n    int\t    op = EXACTLY;\t// Arbitrary non-END op.\n    char_u  *next;\n    char_u  *end = NULL;\n    FILE    *f;\n\n#ifdef BT_REGEXP_LOG\n    f = fopen(\"bt_regexp_log.log\", \"a\");\n#else\n    f = stdout;\n#endif\n    if (f == NULL)\n\treturn;\n    fprintf(f, \"-------------------------------------\\n\\r\\nregcomp(%s):\\r\\n\", pattern);\n\n    s = r->program + 1;\n    // Loop until we find the END that isn't before a referred next (an END\n    // can also appear in a NOMATCH operand).\n    while (op != END || s <= end)\n    {\n\top = OP(s);\n\tfprintf(f, \"%2d%s\", (int)(s - r->program), regprop(s)); // Where, what.\n\tnext = regnext(s);\n\tif (next == NULL)\t// Next ptr.\n\t    fprintf(f, \"(0)\");\n\telse\n\t    fprintf(f, \"(%d)\", (int)((s - r->program) + (next - s)));\n\tif (end < next)\n\t    end = next;\n\tif (op == BRACE_LIMITS)\n\t{\n\t    // Two ints\n\t    fprintf(f, \" minval %ld, maxval %ld\", OPERAND_MIN(s), OPERAND_MAX(s));\n\t    s += 8;\n\t}\n\telse if (op == BEHIND || op == NOBEHIND)\n\t{\n\t    // one int\n\t    fprintf(f, \" count %ld\", OPERAND_MIN(s));\n\t    s += 4;\n\t}\n\telse if (op == RE_LNUM || op == RE_COL || op == RE_VCOL)\n\t{\n\t    // one int plus comparator\n\t    fprintf(f, \" count %ld\", OPERAND_MIN(s));\n\t    s += 5;\n\t}\n\ts += 3;\n\tif (op == ANYOF || op == ANYOF + ADD_NL\n\t\t|| op == ANYBUT || op == ANYBUT + ADD_NL\n\t\t|| op == EXACTLY)\n\t{\n\t    // Literal string, where present.\n\t    fprintf(f, \"\\nxxxxxxxxx\\n\");\n\t    while (*s != NUL)\n\t\tfprintf(f, \"%c\", *s++);\n\t    fprintf(f, \"\\nxxxxxxxxx\\n\");\n\t    s++;\n\t}\n\tfprintf(f, \"\\r\\n\");\n    }\n\n    // Header fields of interest.\n    if (r->regstart != NUL)\n\tfprintf(f, \"start `%s' 0x%x; \", r->regstart < 256\n\t\t? (char *)transchar(r->regstart)\n\t\t: \"multibyte\", r->regstart);\n    if (r->reganch)\n\tfprintf(f, \"anchored; \");\n    if (r->regmust != NULL)\n\tfprintf(f, \"must have \\\"%s\\\"\", r->regmust);\n    fprintf(f, \"\\r\\n\");\n\n#ifdef BT_REGEXP_LOG\n    fclose(f);\n#endif\n}\n#endif\t    // BT_REGEXP_DUMP\n\n#ifdef DEBUG\n/*\n * regprop - printable representation of opcode\n */\n    static char_u *\nregprop(char_u *op)\n{\n    char\t    *p;\n    static char\t    buf[50];\n\n    STRCPY(buf, \":\");\n\n    switch ((int) OP(op))\n    {\n      case BOL:\n\tp = \"BOL\";\n\tbreak;\n      case EOL:\n\tp = \"EOL\";\n\tbreak;\n      case RE_BOF:\n\tp = \"BOF\";\n\tbreak;\n      case RE_EOF:\n\tp = \"EOF\";\n\tbreak;\n      case CURSOR:\n\tp = \"CURSOR\";\n\tbreak;\n      case RE_VISUAL:\n\tp = \"RE_VISUAL\";\n\tbreak;\n      case RE_LNUM:\n\tp = \"RE_LNUM\";\n\tbreak;\n      case RE_MARK:\n\tp = \"RE_MARK\";\n\tbreak;\n      case RE_COL:\n\tp = \"RE_COL\";\n\tbreak;\n      case RE_VCOL:\n\tp = \"RE_VCOL\";\n\tbreak;\n      case BOW:\n\tp = \"BOW\";\n\tbreak;\n      case EOW:\n\tp = \"EOW\";\n\tbreak;\n      case ANY:\n\tp = \"ANY\";\n\tbreak;\n      case ANY + ADD_NL:\n\tp = \"ANY+NL\";\n\tbreak;\n      case ANYOF:\n\tp = \"ANYOF\";\n\tbreak;\n      case ANYOF + ADD_NL:\n\tp = \"ANYOF+NL\";\n\tbreak;\n      case ANYBUT:\n\tp = \"ANYBUT\";\n\tbreak;\n      case ANYBUT + ADD_NL:\n\tp = \"ANYBUT+NL\";\n\tbreak;\n      case IDENT:\n\tp = \"IDENT\";\n\tbreak;\n      case IDENT + ADD_NL:\n\tp = \"IDENT+NL\";\n\tbreak;\n      case SIDENT:\n\tp = \"SIDENT\";\n\tbreak;\n      case SIDENT + ADD_NL:\n\tp = \"SIDENT+NL\";\n\tbreak;\n      case KWORD:\n\tp = \"KWORD\";\n\tbreak;\n      case KWORD + ADD_NL:\n\tp = \"KWORD+NL\";\n\tbreak;\n      case SKWORD:\n\tp = \"SKWORD\";\n\tbreak;\n      case SKWORD + ADD_NL:\n\tp = \"SKWORD+NL\";\n\tbreak;\n      case FNAME:\n\tp = \"FNAME\";\n\tbreak;\n      case FNAME + ADD_NL:\n\tp = \"FNAME+NL\";\n\tbreak;\n      case SFNAME:\n\tp = \"SFNAME\";\n\tbreak;\n      case SFNAME + ADD_NL:\n\tp = \"SFNAME+NL\";\n\tbreak;\n      case PRINT:\n\tp = \"PRINT\";\n\tbreak;\n      case PRINT + ADD_NL:\n\tp = \"PRINT+NL\";\n\tbreak;\n      case SPRINT:\n\tp = \"SPRINT\";\n\tbreak;\n      case SPRINT + ADD_NL:\n\tp = \"SPRINT+NL\";\n\tbreak;\n      case WHITE:\n\tp = \"WHITE\";\n\tbreak;\n      case WHITE + ADD_NL:\n\tp = \"WHITE+NL\";\n\tbreak;\n      case NWHITE:\n\tp = \"NWHITE\";\n\tbreak;\n      case NWHITE + ADD_NL:\n\tp = \"NWHITE+NL\";\n\tbreak;\n      case DIGIT:\n\tp = \"DIGIT\";\n\tbreak;\n      case DIGIT + ADD_NL:\n\tp = \"DIGIT+NL\";\n\tbreak;\n      case NDIGIT:\n\tp = \"NDIGIT\";\n\tbreak;\n      case NDIGIT + ADD_NL:\n\tp = \"NDIGIT+NL\";\n\tbreak;\n      case HEX:\n\tp = \"HEX\";\n\tbreak;\n      case HEX + ADD_NL:\n\tp = \"HEX+NL\";\n\tbreak;\n      case NHEX:\n\tp = \"NHEX\";\n\tbreak;\n      case NHEX + ADD_NL:\n\tp = \"NHEX+NL\";\n\tbreak;\n      case OCTAL:\n\tp = \"OCTAL\";\n\tbreak;\n      case OCTAL + ADD_NL:\n\tp = \"OCTAL+NL\";\n\tbreak;\n      case NOCTAL:\n\tp = \"NOCTAL\";\n\tbreak;\n      case NOCTAL + ADD_NL:\n\tp = \"NOCTAL+NL\";\n\tbreak;\n      case WORD:\n\tp = \"WORD\";\n\tbreak;\n      case WORD + ADD_NL:\n\tp = \"WORD+NL\";\n\tbreak;\n      case NWORD:\n\tp = \"NWORD\";\n\tbreak;\n      case NWORD + ADD_NL:\n\tp = \"NWORD+NL\";\n\tbreak;\n      case HEAD:\n\tp = \"HEAD\";\n\tbreak;\n      case HEAD + ADD_NL:\n\tp = \"HEAD+NL\";\n\tbreak;\n      case NHEAD:\n\tp = \"NHEAD\";\n\tbreak;\n      case NHEAD + ADD_NL:\n\tp = \"NHEAD+NL\";\n\tbreak;\n      case ALPHA:\n\tp = \"ALPHA\";\n\tbreak;\n      case ALPHA + ADD_NL:\n\tp = \"ALPHA+NL\";\n\tbreak;\n      case NALPHA:\n\tp = \"NALPHA\";\n\tbreak;\n      case NALPHA + ADD_NL:\n\tp = \"NALPHA+NL\";\n\tbreak;\n      case LOWER:\n\tp = \"LOWER\";\n\tbreak;\n      case LOWER + ADD_NL:\n\tp = \"LOWER+NL\";\n\tbreak;\n      case NLOWER:\n\tp = \"NLOWER\";\n\tbreak;\n      case NLOWER + ADD_NL:\n\tp = \"NLOWER+NL\";\n\tbreak;\n      case UPPER:\n\tp = \"UPPER\";\n\tbreak;\n      case UPPER + ADD_NL:\n\tp = \"UPPER+NL\";\n\tbreak;\n      case NUPPER:\n\tp = \"NUPPER\";\n\tbreak;\n      case NUPPER + ADD_NL:\n\tp = \"NUPPER+NL\";\n\tbreak;\n      case BRANCH:\n\tp = \"BRANCH\";\n\tbreak;\n      case EXACTLY:\n\tp = \"EXACTLY\";\n\tbreak;\n      case NOTHING:\n\tp = \"NOTHING\";\n\tbreak;\n      case BACK:\n\tp = \"BACK\";\n\tbreak;\n      case END:\n\tp = \"END\";\n\tbreak;\n      case MOPEN + 0:\n\tp = \"MATCH START\";\n\tbreak;\n      case MOPEN + 1:\n      case MOPEN + 2:\n      case MOPEN + 3:\n      case MOPEN + 4:\n      case MOPEN + 5:\n      case MOPEN + 6:\n      case MOPEN + 7:\n      case MOPEN + 8:\n      case MOPEN + 9:\n\tsprintf(buf + STRLEN(buf), \"MOPEN%d\", OP(op) - MOPEN);\n\tp = NULL;\n\tbreak;\n      case MCLOSE + 0:\n\tp = \"MATCH END\";\n\tbreak;\n      case MCLOSE + 1:\n      case MCLOSE + 2:\n      case MCLOSE + 3:\n      case MCLOSE + 4:\n      case MCLOSE + 5:\n      case MCLOSE + 6:\n      case MCLOSE + 7:\n      case MCLOSE + 8:\n      case MCLOSE + 9:\n\tsprintf(buf + STRLEN(buf), \"MCLOSE%d\", OP(op) - MCLOSE);\n\tp = NULL;\n\tbreak;\n      case BACKREF + 1:\n      case BACKREF + 2:\n      case BACKREF + 3:\n      case BACKREF + 4:\n      case BACKREF + 5:\n      case BACKREF + 6:\n      case BACKREF + 7:\n      case BACKREF + 8:\n      case BACKREF + 9:\n\tsprintf(buf + STRLEN(buf), \"BACKREF%d\", OP(op) - BACKREF);\n\tp = NULL;\n\tbreak;\n      case NOPEN:\n\tp = \"NOPEN\";\n\tbreak;\n      case NCLOSE:\n\tp = \"NCLOSE\";\n\tbreak;\n#ifdef FEAT_SYN_HL\n      case ZOPEN + 1:\n      case ZOPEN + 2:\n      case ZOPEN + 3:\n      case ZOPEN + 4:\n      case ZOPEN + 5:\n      case ZOPEN + 6:\n      case ZOPEN + 7:\n      case ZOPEN + 8:\n      case ZOPEN + 9:\n\tsprintf(buf + STRLEN(buf), \"ZOPEN%d\", OP(op) - ZOPEN);\n\tp = NULL;\n\tbreak;\n      case ZCLOSE + 1:\n      case ZCLOSE + 2:\n      case ZCLOSE + 3:\n      case ZCLOSE + 4:\n      case ZCLOSE + 5:\n      case ZCLOSE + 6:\n      case ZCLOSE + 7:\n      case ZCLOSE + 8:\n      case ZCLOSE + 9:\n\tsprintf(buf + STRLEN(buf), \"ZCLOSE%d\", OP(op) - ZCLOSE);\n\tp = NULL;\n\tbreak;\n      case ZREF + 1:\n      case ZREF + 2:\n      case ZREF + 3:\n      case ZREF + 4:\n      case ZREF + 5:\n      case ZREF + 6:\n      case ZREF + 7:\n      case ZREF + 8:\n      case ZREF + 9:\n\tsprintf(buf + STRLEN(buf), \"ZREF%d\", OP(op) - ZREF);\n\tp = NULL;\n\tbreak;\n#endif\n      case STAR:\n\tp = \"STAR\";\n\tbreak;\n      case PLUS:\n\tp = \"PLUS\";\n\tbreak;\n      case NOMATCH:\n\tp = \"NOMATCH\";\n\tbreak;\n      case MATCH:\n\tp = \"MATCH\";\n\tbreak;\n      case BEHIND:\n\tp = \"BEHIND\";\n\tbreak;\n      case NOBEHIND:\n\tp = \"NOBEHIND\";\n\tbreak;\n      case SUBPAT:\n\tp = \"SUBPAT\";\n\tbreak;\n      case BRACE_LIMITS:\n\tp = \"BRACE_LIMITS\";\n\tbreak;\n      case BRACE_SIMPLE:\n\tp = \"BRACE_SIMPLE\";\n\tbreak;\n      case BRACE_COMPLEX + 0:\n      case BRACE_COMPLEX + 1:\n      case BRACE_COMPLEX + 2:\n      case BRACE_COMPLEX + 3:\n      case BRACE_COMPLEX + 4:\n      case BRACE_COMPLEX + 5:\n      case BRACE_COMPLEX + 6:\n      case BRACE_COMPLEX + 7:\n      case BRACE_COMPLEX + 8:\n      case BRACE_COMPLEX + 9:\n\tsprintf(buf + STRLEN(buf), \"BRACE_COMPLEX%d\", OP(op) - BRACE_COMPLEX);\n\tp = NULL;\n\tbreak;\n      case MULTIBYTECODE:\n\tp = \"MULTIBYTECODE\";\n\tbreak;\n      case NEWL:\n\tp = \"NEWL\";\n\tbreak;\n      default:\n\tsprintf(buf + STRLEN(buf), \"corrupt %d\", OP(op));\n\tp = NULL;\n\tbreak;\n    }\n    if (p != NULL)\n\tSTRCAT(buf, p);\n    return (char_u *)buf;\n}\n#endif\t    // DEBUG\n", "\" Tests for regexp in utf8 encoding\n\nfunc s:equivalence_test()\n  let str = \"A\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u0100\u0102\u0104\u01cd\u01de\u01e0\u01fa\u0202\u0226\u023a\u1e00\u1ea0\u1ea2\u1ea4\u1ea6\u1ea8\u1eaa\u1eac\u1eae\u1eb0\u1eb2\u1eb4\u1eb6 B\u0181\u0243\u1e02\u1e04\u1e06 C\u00c7\u0106\u0108\u010a\u010c\u0187\u023b\u1e08\ua792 D\u010e\u0110\u018a\u1e0a\u1e0c\u1e0e\u1e10\u1e12 E\u00c8\u00c9\u00ca\u00cb\u0112\u0114\u0116\u0118\u011a\u0204\u0206\u0228\u0246\u1e14\u1e16\u1e18\u1e1a\u1e1c\u1eb8\u1eba\u1ebc\u1ebe\u1ec0\u1ec2\u1ec4\u1ec6 F\u0191\u1e1e\ua798 G\u011c\u011e\u0120\u0122\u0193\u01e4\u01e6\u01f4\u1e20\ua7a0 H\u0124\u0126\u021e\u1e22\u1e24\u1e26\u1e28\u1e2a\u2c67 I\u00cc\u00cd\u00ce\u00cf\u0128\u012a\u012c\u012e\u0130\u0197\u01cf\u0208\u020a\u1e2c\u1e2e\u1ec8\u1eca J\u0134\u0248 K\u0136\u0198\u01e8\u1e30\u1e32\u1e34\u2c69\ua740 L\u0139\u013b\u013d\u013f\u0141\u023d\u1e36\u1e38\u1e3a\u1e3c\u2c60 M\u1e3e\u1e40\u1e42 N\u00d1\u0143\u0145\u0147\u01f8\u1e44\u1e46\u1e48\u1e4a\ua7a4 O\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u014c\u014e\u0150\u019f\u01a0\u01d1\u01ea\u01ec\u01fe\u020c\u020e\u022a\u022c\u022e\u0230\u1e4c\u1e4e\u1e50\u1e52\u1ecc\u1ece\u1ed0\u1ed2\u1ed4\u1ed6\u1ed8\u1eda\u1edc\u1ede\u1ee0\u1ee2 P\u01a4\u1e54\u1e56\u2c63 Q\u024a R\u0154\u0156\u0158\u0210\u0212\u024c\u1e58\u1e5a\u1e5c\u1e5e\u2c64\ua7a6 S\u015a\u015c\u015e\u0160\u0218\u1e60\u1e62\u1e64\u1e66\u1e68\u2c7e\ua7a8 T\u0162\u0164\u0166\u01ac\u01ae\u021a\u023e\u1e6a\u1e6c\u1e6e\u1e70 U\u00d9\u00da\u00db\u00dc\u0168\u016a\u016c\u016e\u0170\u01af\u01d5\u01d9\u01db\u01d3\u01d7\u0214\u0216\u0244\u1e72\u1e74\u1e76\u1e78\u1e7a\u1ee4\u1ee6\u1ee8\u1eea\u1eec\u1eee\u1ef0  V\u01b2\u1e7c\u1e7e W\u0174\u1e80\u1e82\u1e84\u1e86\u1e88 X\u1e8a\u1e8c Y\u00dd\u0176\u0178\u01b3\u0232\u024e\u1e8e\u1ef2\u1ef4\u1ef6\u1ef8 Z\u0179\u017b\u017d\u01b5\u1e90\u1e92\u1e94\u2c6b a\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u0101\u0103\u0105\u01ce\u01df\u01e1\u01fb\u0203\u0227\u1d8f\u1e01\u1e9a\u1ea1\u1ea3\u1ea5\u1ea7\u1ea9\u1eab\u1ead\u1eaf\u1eb1\u1eb3\u1eb5\u1eb7\u2c65 b\u0180\u0253\u1d6c\u1d80\u1e03\u1e05\u1e07 c\u00e7\u0107\u0109\u010b\u010d\u0188\u023c\u1e09\ua793\ua794 d\u010f\u0111\u0257\u1d6d\u1d81\u1d91\u1e0b\u1e0d\u1e0f\u1e11\u1e13 e\u00e8\u00e9\u00ea\u00eb\u0113\u0115\u0117\u0119\u011b\u0205\u0207\u0229\u0247\u1d92\u1e15\u1e17\u1e19\u1e1b\u1e1d\u1eb9\u1ebb\u1ebd\u1ebf\u1ec1\u1ec3\u1ec5\u1ec7 f\u0192\u1d6e\u1d82\u1e1f\ua799 g\u011d\u011f\u0121\u0123\u01e5\u01e7\u01f5\u0260\u1d83\u1e21\ua7a1 h\u0125\u0127\u021f\u1e23\u1e25\u1e27\u1e29\u1e2b\u1e96\u2c68\ua795 i\u00ec\u00ed\u00ee\u00ef\u0129\u012b\u012d\u012f\u01d0\u0209\u020b\u0268\u1d96\u1e2d\u1e2f\u1ec9\u1ecb j\u0135\u01f0\u0249 k\u0137\u0199\u01e9\u1d84\u1e31\u1e33\u1e35\u2c6a\ua741 l\u013a\u013c\u013e\u0140\u0142\u019a\u1e37\u1e39\u1e3b\u1e3d\u2c61 m\u1d6f\u1e3f\u1e41\u1e43 n\u00f1\u0144\u0146\u0148\u0149\u01f9\u1d70\u1d87\u1e45\u1e47\u1e49\u1e4b\ua7a5 o\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u014d\u014f\u0151\u01a1\u01d2\u01eb\u01ed\u01ff\u020d\u020f\u022b\u022d\u022f\u0231\u0275\u1e4d\u1e4f\u1e51\u1e53\u1ecd\u1ecf\u1ed1\u1ed3\u1ed5\u1ed7\u1ed9\u1edb\u1edd\u1edf\u1ee1\u1ee3 p\u01a5\u1d71\u1d7d\u1d88\u1e55\u1e57 q\u024b\u02a0 r\u0155\u0157\u0159\u0211\u0213\u024d\u027d\u1d72\u1d73\u1d89\u1e5b\u1e5d\u1e5f\ua7a7 s\u015b\u015d\u015f\u0161\u0219\u023f\u1d74\u1d8a\u1e61\u1e63\u1e65\u1e67\u1e69\ua7a9 t\u0163\u0165\u0167\u01ab\u01ad\u021b\u0288\u1d75\u1e6b\u1e6d\u1e6f\u1e71\u1e97\u2c66 u\u00f9\u00fa\u00fb\u00fc\u0169\u016b\u016d\u016f\u0171\u0173\u01da\u01d6\u01b0\u01d4\u01d8\u01dc\u0215\u0217\u0289\u1d7e\u1d99\u1e73\u1e75\u1e77\u1e79\u1e7b\u1ee5\u1ee7\u1ee9\u1eeb\u1eed\u1eef\u1ef1 v\u028b\u1d8c\u1e7d\u1e7f w\u0175\u1e81\u1e83\u1e85\u1e87\u1e89\u1e98 x\u1e8b\u1e8d y\u00fd\u00ff\u0177\u01b4\u0233\u024f\u1e8f\u1e99\u1ef3\u1ef5\u1ef7\u1ef9 z\u017a\u017c\u017e\u01b6\u1d76\u1d8e\u1e91\u1e93\u1e95\u2c6c\"\n  let groups = split(str)\n  for group1 in groups\n      for c in split(group1, '\\zs')\n\t\" next statement confirms that equivalence class matches every\n\t\" character in group\n        call assert_match('^[[=' .. c .. '=]]*$', group1)\n        for group2 in groups\n          if group2 != group1\n\t    \" next statement converts that equivalence class doesn't match\n\t    \" character in any other group\n            call assert_equal(-1, match(group2, '[[=' .. c .. '=]]'), c)\n          endif\n        endfor\n      endfor\n  endfor\nendfunc\n\nfunc Test_equivalence_re1()\n  set re=1\n  call s:equivalence_test()\n  set re=0\nendfunc\n\nfunc Test_equivalence_re2()\n  set re=2\n  call s:equivalence_test()\n  set re=0\nendfunc\n\nfunc s:classes_test()\n  if has('win32')\n    set iskeyword=@,48-57,_,192-255\n  endif\n  set isprint=@,161-255\n  call assert_equal('Mot\u00f6rhead', matchstr('Mot\u00f6rhead', '[[:print:]]\\+'))\n\n  let alnumchars = ''\n  let alphachars = ''\n  let backspacechar = ''\n  let blankchars = ''\n  let cntrlchars = ''\n  let digitchars = ''\n  let escapechar = ''\n  let graphchars = ''\n  let lowerchars = ''\n  let printchars = ''\n  let punctchars = ''\n  let returnchar = ''\n  let spacechars = ''\n  let tabchar = ''\n  let upperchars = ''\n  let xdigitchars = ''\n  let identchars = ''\n  let identchars1 = ''\n  let kwordchars = ''\n  let kwordchars1 = ''\n  let fnamechars = ''\n  let fnamechars1 = ''\n  let i = 1\n  while i <= 255\n    let c = nr2char(i)\n    if c =~ '[[:alpha:]]'\n      let alphachars .= c\n    endif\n    if c =~ '[[:alnum:]]'\n      let alnumchars .= c\n    endif\n    if c =~ '[[:backspace:]]'\n      let backspacechar .= c\n    endif\n    if c =~ '[[:blank:]]'\n      let blankchars .= c\n    endif\n    if c =~ '[[:cntrl:]]'\n      let cntrlchars .= c\n    endif\n    if c =~ '[[:digit:]]'\n      let digitchars .= c\n    endif\n    if c =~ '[[:escape:]]'\n      let escapechar .= c\n    endif\n    if c =~ '[[:graph:]]'\n      let graphchars .= c\n    endif\n    if c =~ '[[:lower:]]'\n      let lowerchars .= c\n    endif\n    if c =~ '[[:print:]]'\n      let printchars .= c\n    endif\n    if c =~ '[[:punct:]]'\n      let punctchars .= c\n    endif\n    if c =~ '[[:return:]]'\n      let returnchar .= c\n    endif\n    if c =~ '[[:space:]]'\n      let spacechars .= c\n    endif\n    if c =~ '[[:tab:]]'\n      let tabchar .= c\n    endif\n    if c =~ '[[:upper:]]'\n      let upperchars .= c\n    endif\n    if c =~ '[[:xdigit:]]'\n      let xdigitchars .= c\n    endif\n    if c =~ '[[:ident:]]'\n      let identchars .= c\n    endif\n    if c =~ '\\i'\n      let identchars1 .= c\n    endif\n    if c =~ '[[:keyword:]]'\n      let kwordchars .= c\n    endif\n    if c =~ '\\k'\n      let kwordchars1 .= c\n    endif\n    if c =~ '[[:fname:]]'\n      let fnamechars .= c\n    endif\n    if c =~ '\\f'\n      let fnamechars1 .= c\n    endif\n    let i += 1\n  endwhile\n\n  call assert_equal('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', alphachars)\n  call assert_equal('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', alnumchars)\n  call assert_equal(\"\\b\", backspacechar)\n  call assert_equal(\"\\t \", blankchars)\n  call assert_equal(\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\b\\t\\n\\x0b\\f\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\e\\x1c\\x1d\\x1e\\x1f\\x7f\", cntrlchars)\n  call assert_equal(\"0123456789\", digitchars)\n  call assert_equal(\"\\<Esc>\", escapechar)\n  call assert_equal('!\"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~', graphchars)\n  call assert_equal('abcdefghijklmnopqrstuvwxyz\u00b5\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00ff', lowerchars)\n  call assert_equal(' !\"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u00a0\u00a1\u00a2\u00a3\u00a4\u00a5\u00a6\u00a7\u00a8\u00a9\u00aa\u00ab\u00ac\u00ad\u00ae\u00af\u00b0\u00b1\u00b2\u00b3\u00b4\u00b5\u00b6\u00b7\u00b8\u00b9\u00ba\u00bb\u00bc\u00bd\u00be\u00bf\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d7\u00d8\u00d9\u00da\u00db\u00dc\u00dd\u00de\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f7\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00ff', printchars)\n  call assert_equal('!\"#$%&''()*+,-./:;<=>?@[\\]^_`{|}~', punctchars)\n  call assert_equal('ABCDEFGHIJKLMNOPQRSTUVWXYZ\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u00d9\u00da\u00db\u00dc\u00dd\u00de', upperchars)\n  call assert_equal(\"\\r\", returnchar)\n  call assert_equal(\"\\t\\n\\x0b\\f\\r \", spacechars)\n  call assert_equal(\"\\t\", tabchar)\n  call assert_equal('0123456789ABCDEFabcdef', xdigitchars)\n\n  if has('win32')\n    let identchars_ok = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\u0080\u0081\u0082\u0083\u0084\u0085\u0086\u0087\u0088\u0089\u008a\u008b\u008c\u008d\u008e\u008f\u0090\u0091\u0092\u0093\u0094\u0095\u0096\u0097\u0098\u0099\u009a\u009b\u009c\u009d\u009e\u009f\u00a0\u00a1\u00a2\u00a3\u00a4\u00a5\u00a6\u00a7\u00b5\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u00d9\u00da\u00db\u00dc\u00dd\u00de\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00ff'\n    let kwordchars_ok = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\u00b5\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d7\u00d8\u00d9\u00da\u00db\u00dc\u00dd\u00de\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f7\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00ff'\n  else\n    let identchars_ok = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\u00b5\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d7\u00d8\u00d9\u00da\u00db\u00dc\u00dd\u00de\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f7\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00ff'\n    let kwordchars_ok = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\u00b5\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d7\u00d8\u00d9\u00da\u00db\u00dc\u00dd\u00de\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f7\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00ff'\n  endif\n\n  if has('win32')\n    let fnamechars_ok = '!#$%+,-./0123456789:=@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]_abcdefghijklmnopqrstuvwxyz{}~\u00a0\u00a1\u00a2\u00a3\u00a4\u00a5\u00a6\u00a7\u00a8\u00a9\u00aa\u00ab\u00ac\u00ad\u00ae\u00af\u00b0\u00b1\u00b2\u00b3\u00b4\u00b5\u00b6\u00b7\u00b8\u00b9\u00ba\u00bb\u00bc\u00bd\u00be\u00bf\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d7\u00d8\u00d9\u00da\u00db\u00dc\u00dd\u00de\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f7\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00ff'\n  elseif has('amiga')\n    let fnamechars_ok = '$+,-./0123456789:ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~\u00a0\u00a1\u00a2\u00a3\u00a4\u00a5\u00a6\u00a7\u00a8\u00a9\u00aa\u00ab\u00ac\u00ad\u00ae\u00af\u00b0\u00b1\u00b2\u00b3\u00b4\u00b5\u00b6\u00b7\u00b8\u00b9\u00ba\u00bb\u00bc\u00bd\u00be\u00bf\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d7\u00d8\u00d9\u00da\u00db\u00dc\u00dd\u00de\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f7\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00ff'\n  elseif has('vms')\n    let fnamechars_ok = '#$%+,-./0123456789:;<>ABCDEFGHIJKLMNOPQRSTUVWXYZ[]_abcdefghijklmnopqrstuvwxyz~\u00a0\u00a1\u00a2\u00a3\u00a4\u00a5\u00a6\u00a7\u00a8\u00a9\u00aa\u00ab\u00ac\u00ad\u00ae\u00af\u00b0\u00b1\u00b2\u00b3\u00b4\u00b5\u00b6\u00b7\u00b8\u00b9\u00ba\u00bb\u00bc\u00bd\u00be\u00bf\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d7\u00d8\u00d9\u00da\u00db\u00dc\u00dd\u00de\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f7\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00ff'\n  else\n    let fnamechars_ok = '#$%+,-./0123456789=ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~\u00a0\u00a1\u00a2\u00a3\u00a4\u00a5\u00a6\u00a7\u00a8\u00a9\u00aa\u00ab\u00ac\u00ad\u00ae\u00af\u00b0\u00b1\u00b2\u00b3\u00b4\u00b5\u00b6\u00b7\u00b8\u00b9\u00ba\u00bb\u00bc\u00bd\u00be\u00bf\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d7\u00d8\u00d9\u00da\u00db\u00dc\u00dd\u00de\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f7\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00ff'\n  endif\n\n  call assert_equal(identchars_ok, identchars)\n  call assert_equal(kwordchars_ok, kwordchars)\n  call assert_equal(fnamechars_ok, fnamechars)\n\n  call assert_equal(identchars1, identchars)\n  call assert_equal(kwordchars1, kwordchars)\n  call assert_equal(fnamechars1, fnamechars)\nendfunc\n\nfunc Test_classes_re1()\n  set re=1\n  call s:classes_test()\n  set re=0\nendfunc\n\nfunc Test_classes_re2()\n  set re=2\n  call s:classes_test()\n  set re=0\nendfunc\n\nfunc Test_reversed_range()\n  for re in range(0, 2)\n    exe 'set re=' . re\n    call assert_fails('call match(\"abc def\", \"[c-a]\")', 'E944:', re)\n  endfor\n  set re=0\nendfunc\n\nfunc Test_large_class()\n  set re=1\n  call assert_fails('call match(\"abc def\", \"[\\u3000-\\u4000]\")', 'E945:')\n  set re=2\n  call assert_equal(0, 'abc def' =~# '[\\u3000-\\u4000]')\n  call assert_equal(1, \"\\u3042\" =~# '[\\u3000-\\u4000]')\n  set re=0\nendfunc\n\nfunc Test_optmatch_toolong()\n  set re=1\n  \" Can only handle about 8000 characters.\n  let pat = '\\\\%[' .. repeat('x', 9000) .. ']'\n  call assert_fails('call match(\"abc def\", \"' .. pat .. '\")', 'E339:')\n  set re=0\nendfunc\n\n\" Test for regexp patterns with multi-byte support, using utf-8.\nfunc Test_multibyte_chars()\n  \" tl is a List of Lists with:\n  \"    2: test auto/old/new  0: test auto/old  1: test auto/new\n  \"    regexp pattern\n  \"    text to test the pattern on\n  \"    expected match (optional)\n  \"    expected submatch 1 (optional)\n  \"    expected submatch 2 (optional)\n  \"    etc.\n  \"  When there is no match use only the first two items.\n  let tl = []\n\n  \" Multi-byte character tests. These will fail unless vim is compiled\n  \" with Multibyte (FEAT_MBYTE) or BIG/HUGE features.\n  call add(tl, [2, '[[:alpha:][=a=]]\\+', '879 aia\u00e3\u00e2aiuvna ', 'aia\u00e3\u00e2aiuvna'])\n  call add(tl, [2, '[[=a=]]\\+', 'dda\u00e3\u00e2bcd', 'a\u00e3\u00e2'])\t\t\t\t\t\t\t\t\" equivalence classes\n  call add(tl, [2, '[^\u0e21 ]\\+', '\u0e21\u0e21 oijasoifjos ifjoisj f osij j \u0e21\u0e21\u0e21\u0e21\u0e21 abcd', 'oijasoifjos'])\n  call add(tl, [2, ' [^ ]\\+', 'start \u0e21abcd\u0e21 ', ' \u0e21abcd\u0e21'])\n  call add(tl, [2, '[\u0e21[:alpha:][=a=]]\\+', '879 aia\u00e3\u0e21\u00e2\u0e21aiuvna ', 'aia\u00e3\u0e21\u00e2\u0e21aiuvna'])\n\n  \" this is not a normal \"i\" but 0xec\n  call add(tl, [2, '\\p\\+', '\u00eca', '\u00eca'])\n  call add(tl, [2, '\\p*', 'a\u3042', 'a\u3042'])\n\n  \" Test recognition of some character classes\n  call add(tl, [2, '\\i\\+', '&*\u00a8xx ', 'xx'])\n  call add(tl, [2, '\\f\\+', '&*\u009ffname ', 'fname'])\n\n  \" Test composing character matching\n  call add(tl, [2, '.\u0e21', 'x\u0e21\u0e48x y\u0e21y', 'y\u0e21'])\n  call add(tl, [2, '.\u0e21\u0e48', 'x\u0e21\u0e48x y\u0e21y', 'x\u0e21\u0e48'])\n  call add(tl, [2, \"\\u05b9\", \" x\\u05b9 \", \"x\\u05b9\"])\n  call add(tl, [2, \".\\u05b9\", \" x\\u05b9 \", \"x\\u05b9\"])\n  call add(tl, [2, \"\\u05b9\\u05bb\", \" x\\u05b9\\u05bb \", \"x\\u05b9\\u05bb\"])\n  call add(tl, [2, \".\\u05b9\\u05bb\", \" x\\u05b9\\u05bb \", \"x\\u05b9\\u05bb\"])\n  call add(tl, [2, \"\\u05bb\\u05b9\", \" x\\u05b9\\u05bb \", \"x\\u05b9\\u05bb\"])\n  call add(tl, [2, \".\\u05bb\\u05b9\", \" x\\u05b9\\u05bb \", \"x\\u05b9\\u05bb\"])\n  call add(tl, [2, \"\\u05b9\", \" y\\u05bb x\\u05b9 \", \"x\\u05b9\"])\n  call add(tl, [2, \".\\u05b9\", \" y\\u05bb x\\u05b9 \", \"x\\u05b9\"])\n  call add(tl, [2, \"\\u05b9\", \" y\\u05bb\\u05b9 x\\u05b9 \", \"y\\u05bb\\u05b9\"])\n  call add(tl, [2, \".\\u05b9\", \" y\\u05bb\\u05b9 x\\u05b9 \", \"y\\u05bb\\u05b9\"])\n  call add(tl, [1, \"\\u05b9\\u05bb\", \" y\\u05b9 x\\u05b9\\u05bb \", \"x\\u05b9\\u05bb\"])\n  call add(tl, [2, \".\\u05b9\\u05bb\", \" y\\u05bb x\\u05b9\\u05bb \", \"x\\u05b9\\u05bb\"])\n  call add(tl, [2, \"a\", \"ca\\u0300t\"])\n  call add(tl, [2, \"ca\", \"ca\\u0300t\"])\n  call add(tl, [2, \"a\\u0300\", \"ca\\u0300t\", \"a\\u0300\"])\n  call add(tl, [2, 'a\\%C', \"ca\\u0300t\", \"a\\u0300\"])\n  call add(tl, [2, 'ca\\%C', \"ca\\u0300t\", \"ca\\u0300\"])\n  call add(tl, [2, 'ca\\%Ct', \"ca\\u0300t\", \"ca\\u0300t\"])\n\n  \" Test \\Z\n  call add(tl, [2, '\u00fa\\Z', 'x'])\n  call add(tl, [2, '\u05d9\u05d4\u05d5\u05d4\\Z', '\u05d9\u05d4\u05d5\u05d4', '\u05d9\u05d4\u05d5\u05d4'])\n  call add(tl, [2, '\u05d9\u05b0\u05d4\u05d5\u05b8\u05d4\\Z', '\u05d9\u05d4\u05d5\u05d4', '\u05d9\u05d4\u05d5\u05d4'])\n  call add(tl, [2, '\u05d9\u05d4\u05d5\u05d4\\Z', '\u05d9\u05b0\u05d4\u05d5\u05b8\u05d4', '\u05d9\u05b0\u05d4\u05d5\u05b8\u05d4'])\n  call add(tl, [2, '\u05d9\u05b0\u05d4\u05d5\u05b8\u05d4\\Z', '\u05d9\u05b0\u05d4\u05d5\u05b8\u05d4', '\u05d9\u05b0\u05d4\u05d5\u05b8\u05d4'])\n  call add(tl, [2, '\u05d9\u05b0\\Z', '\u05d5\u05b0\u05d9\u05b7', '\u05d9\u05b7'])\n  call add(tl, [2, \"\u05e7\\u200d\\u05b9x\\\\Z\", \"x\u05e7\\u200d\\u05b9xy\", \"\u05e7\\u200d\\u05b9x\"])\n  call add(tl, [2, \"\u05e7\\u200d\\u05b9x\\\\Z\", \"x\u05e7\\u200dxy\", \"\u05e7\\u200dx\"])\n  call add(tl, [2, \"\u05e7\\u200dx\\\\Z\", \"x\u05e7\\u200d\\u05b9xy\", \"\u05e7\\u200d\\u05b9x\"])\n  call add(tl, [2, \"\u05e7\\u200dx\\\\Z\", \"x\u05e7\\u200dxy\", \"\u05e7\\u200dx\"])\n  call add(tl, [2, \"\\u05b9\\\\Z\", \"xyz\"])\n  call add(tl, [2, \"\\\\Z\\u05b9\", \"xyz\"])\n  call add(tl, [2, \"\\u05b9\\\\Z\", \"xy\\u05b9z\", \"y\\u05b9\"])\n  call add(tl, [2, \"\\\\Z\\u05b9\", \"xy\\u05b9z\", \"y\\u05b9\"])\n  call add(tl, [1, \"\\u05b9\\\\+\\\\Z\", \"xy\\u05b9z\\u05b9 \", \"y\\u05b9z\\u05b9\"])\n  call add(tl, [1, \"\\\\Z\\u05b9\\\\+\", \"xy\\u05b9z\\u05b9 \", \"y\\u05b9z\\u05b9\"])\n\n  \" Combining different tests and features\n  call add(tl, [2, '[^[=a=]]\\+', 'dda\u00e3\u00e2bcd', 'dd'])\n\n  \" Run the tests\n  for t in tl\n    let re = t[0]\n    let pat = t[1]\n    let text = t[2]\n    let matchidx = 3\n    for engine in [0, 1, 2]\n      if engine == 2 && re == 0 || engine == 1 && re == 1\n        continue\n      endif\n      let &regexpengine = engine\n      try\n        let l = matchlist(text, pat)\n      catch\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat .\n\t\t    \\ '\\\", text: \\\"' . text .\n\t\t    \\ '\\\", caused an exception: \\\"' . v:exception . '\\\"')\n      endtry\n      \" check the match itself\n      if len(l) == 0 && len(t) > matchidx\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat .\n\t\t    \\ '\\\", text: \\\"' . text .\n\t\t    \\ '\\\", did not match, expected: \\\"' . t[matchidx] . '\\\"')\n      elseif len(l) > 0 && len(t) == matchidx\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat .\n\t\t    \\ '\\\", text: \\\"' . text . '\\\", match: \\\"' . l[0] .\n\t\t    \\ '\\\", expected no match')\n      elseif len(t) > matchidx && l[0] != t[matchidx]\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat .\n\t\t    \\ '\\\", text: \\\"' . text . '\\\", match: \\\"' . l[0] .\n\t\t    \\ '\\\", expected: \\\"' . t[matchidx] . '\\\"')\n      else\n        \" Test passed\n      endif\n      if len(l) > 0\n        \" check all the nine submatches\n        for i in range(1, 9)\n          if len(t) <= matchidx + i\n            let e = ''\n          else\n            let e = t[matchidx + i]\n          endif\n          if l[i] != e\n            call assert_report('Error ' . engine . ': pat: \\\"' . pat .\n                  \\ '\\\", text: \\\"' . text . '\\\", submatch ' . i .\n                  \\ ': \\\"' . l[i] . '\\\", expected: \\\"' . e . '\\\"')\n          endif\n        endfor\n        unlet i\n      endif\n    endfor\n  endfor\n  set regexpengine&\nendfunc\n\n\" check that 'ambiwidth' does not change the meaning of \\p\nfunc Test_ambiwidth()\n  set regexpengine=1 ambiwidth=single\n  call assert_equal(0, match(\"\\u00EC\", '\\p'))\n  set regexpengine=1 ambiwidth=double\n  call assert_equal(0, match(\"\\u00EC\", '\\p'))\n  set regexpengine=2 ambiwidth=single\n  call assert_equal(0, match(\"\\u00EC\", '\\p'))\n  set regexpengine=2 ambiwidth=double\n  call assert_equal(0, match(\"\\u00EC\", '\\p'))\n  set regexpengine& ambiwidth&\nendfunc\n\nfunc Run_regexp_ignore_case()\n  call assert_equal('iI\u0130', substitute('iI\u0130', '\\([iI\u0130]\\)', '\\1', 'g'))\n\n  call assert_equal('iIx', substitute('iI\u0130', '\\c\\([\u0130]\\)', 'x', 'g'))\n  call assert_equal('xx\u0130', substitute('iI\u0130', '\\(i\\c\\)', 'x', 'g'))\n  call assert_equal('iIx', substitute('iI\u0130', '\\(\u0130\\c\\)', 'x', 'g'))\n  call assert_equal('iIx', substitute('iI\u0130', '\\c\\(\\%u0130\\)', 'x', 'g'))\n  call assert_equal('iIx', substitute('iI\u0130', '\\c\\([\\u0130]\\)', 'x', 'g'))\n  call assert_equal('iIx', substitute('iI\u0130', '\\c\\([\\u012f-\\u0131]\\)', 'x', 'g'))\nendfunc\n\nfunc Test_regexp_ignore_case()\n  set regexpengine=1\n  call Run_regexp_ignore_case()\n  set regexpengine=2\n  call Run_regexp_ignore_case()\n  set regexpengine&\nendfunc\n\n\" Tests for regexp with multi-byte encoding and various magic settings\nfunc Run_regexp_multibyte_magic()\n  let text =<< trim END\n    1 a aa abb abbccc\n    2 d dd dee deefff\n    3 g gg ghh ghhiii\n    4 j jj jkk jkklll\n    5 m mm mnn mnnooo\n    6 x ^aa$ x\n    7 (a)(b) abbaa\n    8 axx [ab]xx\n    9 \u0e2b\u0e21\u0e48x \u0e2d\u0e21x\n    a \u0e2d\u0e21x \u0e2b\u0e21\u0e48x\n    b \u3061\u30ab\u30e8\u306f\n    c x \u00ac\u20acx\n    d \u5929\u4f7fx\n    e \ufffd\ufffd\ufffd\ufffd\ufffd\ufffdy\n    f \ufffd\ufffd\ufffd\ufffd\ufffd\ufffdz\n    g a\u5577bb\n    j 0123\u2764x\n    k combinations\n    l \u00e4\u00f6 \u00fc\u03b1\u0304\u0306\u0301\n  END\n\n  new\n  call setline(1, text)\n  exe 'normal /a*b\\{2}c\\+/e' .. \"\\<CR>x\"\n  call assert_equal('1 a aa abb abbcc', getline('.'))\n  exe 'normal /\\Md\\*e\\{2}f\\+/e' .. \"\\<CR>x\"\n  call assert_equal('2 d dd dee deeff', getline('.'))\n  set nomagic\n  exe 'normal /g\\*h\\{2}i\\+/e' .. \"\\<CR>x\"\n  call assert_equal('3 g gg ghh ghhii', getline('.'))\n  exe 'normal /\\mj*k\\{2}l\\+/e' .. \"\\<CR>x\"\n  call assert_equal('4 j jj jkk jkkll', getline('.'))\n  exe 'normal /\\vm*n{2}o+/e' .. \"\\<CR>x\"\n  call assert_equal('5 m mm mnn mnnoo', getline('.'))\n  exe 'normal /\\V^aa$/' .. \"\\<CR>x\"\n  call assert_equal('6 x aa$ x', getline('.'))\n  set magic\n  exe 'normal /\\v(a)(b)\\2\\1\\1/e' .. \"\\<CR>x\"\n  call assert_equal('7 (a)(b) abba', getline('.'))\n  exe 'normal /\\V[ab]\\(\\[xy]\\)\\1' .. \"\\<CR>x\"\n  call assert_equal('8 axx ab]xx', getline('.'))\n\n  \" search for multi-byte without composing char\n  exe 'normal /\u0e21' .. \"\\<CR>x\"\n  call assert_equal('9 \u0e2b\u0e21\u0e48x \u0e2dx', getline('.'))\n\n  \" search for multi-byte with composing char\n  exe 'normal /\u0e21\u0e48' .. \"\\<CR>x\"\n  call assert_equal('a \u0e2d\u0e21x \u0e2bx', getline('.'))\n\n  \" find word by change of word class\n  exe 'normal /\u3061\\<\u30ab\u30e8\\>\u306f' .. \"\\<CR>x\"\n  call assert_equal('b \u30ab\u30e8\u306f', getline('.'))\n\n  \" Test \\%u, [\\u] and friends\n  \" c\n  exe 'normal /\\%u20ac' .. \"\\<CR>x\"\n  call assert_equal('c x \u00acx', getline('.'))\n  \" d\n  exe 'normal /[\\u4f7f\\u5929]\\+' .. \"\\<CR>x\"\n  call assert_equal('d \u4f7fx', getline('.'))\n  \" e\n  exe 'normal /\\%U12345678' .. \"\\<CR>x\"\n  call assert_equal('e y', getline('.'))\n  \" f\n  exe 'normal /[\\U1234abcd\\u1234\\uabcd]' .. \"\\<CR>x\"\n  call assert_equal('f z', getline('.'))\n  \" g\n  exe 'normal /\\%d21879b' .. \"\\<CR>x\"\n  call assert_equal('g abb', getline('.'))\n\n  \" j Test backwards search from a multi-byte char\n  exe \"normal /x\\<CR>x?.\\<CR>x\"\n  call assert_equal('j 012\u2764', getline('.'))\n  \" k\n  let @w=':%s#comb[i]nations#\u0153\u0304\u1e63\u0301m\u0325\u0304\u03b1\u0304\u0306\u0301#g'\n  @w\n  call assert_equal('k \u0153\u0304\u1e63\u0301m\u0325\u0304\u03b1\u0304\u0306\u0301', getline(18))\n\n  close!\nendfunc\n\nfunc Test_regexp_multibyte_magic()\n  set regexpengine=1\n  call Run_regexp_multibyte_magic()\n  set regexpengine=2\n  call Run_regexp_multibyte_magic()\n  set regexpengine&\nendfunc\n\n\" Test for 7.3.192\n\" command \":s/ \\?/ /g\" splits multi-byte characters into bytes\nfunc Test_split_multibyte_to_bytes()\n  new\n  call setline(1, 'l \u00e4\u00f6 \u00fc\u03b1\u0304\u0306\u0301')\n  s/ \\?/ /g\n  call assert_equal(' l \u00e4 \u00f6 \u00fc \u03b1\u0304\u0306\u0301', getline(1))\n  close!\nendfunc\n\n\" Test for matchstr() with multibyte characters\nfunc Test_matchstr_multibyte()\n  new\n  call assert_equal('\u05d1', matchstr(\"\u05d0\u05d1\u05d2\u05d3\", \".\", 0, 2))\n  call assert_equal('\u05d1\u05d2', matchstr(\"\u05d0\u05d1\u05d2\u05d3\", \"..\", 0, 2))\n  call assert_equal('\u05d0', matchstr(\"\u05d0\u05d1\u05d2\u05d3\", \".\", 0, 0))\n  call assert_equal('\u05d2', matchstr(\"\u05d0\u05d1\u05d2\u05d3\", \".\", 4, -1))\n  close!\nendfunc\n\n\" Test for 7.4.636\n\" A search with end offset gets stuck at end of file.\nfunc Test_search_with_end_offset()\n  new\n  call setline(1, ['', 'dog(a', 'cat('])\n  exe \"normal /(/e+\\<CR>\"\n  normal n\"ayn\n  call assert_equal(\"a\\ncat(\", @a)\n  close!\nendfunc\n\n\" Check that \"^\" matches even when the line starts with a combining char\nfunc Test_match_start_of_line_combining()\n  new\n  call setline(1, ['', \"\\u05ae\", ''])\n  exe \"normal gg/^\\<CR>\"\n  call assert_equal(2, getcurpos()[1])\n  bwipe!\nendfunc\n\n\" Check that [[:upper:]] matches for automatic engine\nfunc Test_match_char_class_upper()\n  new\n  let _engine=&regexpengine\n\n  \" Test 1: [[:upper:]]\\{2,\\}\n  set regexpengine=0\n  call setline(1, ['05. \u041f\u0415\u0421\u041d\u042f \u041e \u0413\u0415\u0420\u041e\u042f\u0425 \u043c\u0443\u0437. \u0410. \u0414\u0430\u0432\u0438\u0434\u0435\u043d\u043a\u043e, \u041c. \u041a\u043e\u0432\u0430\u043b\u044f \u0438 \u0411. \u0428\u0435\u0445\u0442\u0435\u0440\u0430 ...', '05. PJESNJA O GJEROJAKH mus. A. Davidjenko, M. Kovalja i B. Shjekhtjera ...'])\n  call cursor(1,1)\n  let search_cmd='norm /\\<[[:upper:]]\\{2,\\}\\>' .. \"\\<CR>\"\n  exe search_cmd\n  call assert_equal(4, searchcount().total, 'TEST 1')\n  set regexpengine=1\n  exe search_cmd\n  call assert_equal(2, searchcount().total, 'TEST 1')\n  set regexpengine=2\n  exe search_cmd\n  call assert_equal(4, searchcount().total, 'TEST 1')\n\n  \" Test 2: [[:upper:]].\\+\n  let search_cmd='norm /\\<[[:upper:]].\\+\\>' .. \"\\<CR>\"\n  set regexpengine=0\n  exe search_cmd\n  call assert_equal(2, searchcount().total, 'TEST 2')\n  set regexpengine=1\n  exe search_cmd\n  call assert_equal(1, searchcount().total, 'TEST 2')\n  set regexpengine=2\n  exe search_cmd\n  call assert_equal(2, searchcount().total, 'TEST 2')\n\n  \" Test 3: [[:lower:]]\\+\n  let search_cmd='norm /\\<[[:lower:]]\\+\\>' .. \"\\<CR>\"\n  set regexpengine=0\n  exe search_cmd\n  call assert_equal(4, searchcount().total, 'TEST 3 lower')\n  set regexpengine=1\n  exe search_cmd\n  call assert_equal(2, searchcount().total, 'TEST 3 lower')\n  set regexpengine=2\n  exe search_cmd\n  call assert_equal(4, searchcount().total, 'TEST 3 lower')\n\n  \" clean up\n  let &regexpengine=_engine\n  bwipe!\nendfunc\n\nfunc Test_match_invalid_byte()\n  call writefile(0z630a.765d30aa0a.2e0a.790a.4030, 'Xinvalid')\n  new\n  source Xinvalid\n  bwipe!\n  call delete('Xinvalid')\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4439,\n/**/\n    4438,\n/**/\n    4437,\n/**/\n    4436,\n/**/\n    4435,\n/**/\n    4434,\n/**/\n    4433,\n/**/\n    4432,\n/**/\n    4431,\n/**/\n    4430,\n/**/\n    4429,\n/**/\n    4428,\n/**/\n    4427,\n/**/\n    4426,\n/**/\n    4425,\n/**/\n    4424,\n/**/\n    4423,\n/**/\n    4422,\n/**/\n    4421,\n/**/\n    4420,\n/**/\n    4419,\n/**/\n    4418,\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * Backtracking regular expression implementation.\n *\n * This file is included in \"regexp.c\".\n *\n * NOTICE:\n *\n * This is NOT the original regular expression code as written by Henry\n * Spencer.  This code has been modified specifically for use with the VIM\n * editor, and should not be used separately from Vim.  If you want a good\n * regular expression library, get the original code.  The copyright notice\n * that follows is from the original.\n *\n * END NOTICE\n *\n *\tCopyright (c) 1986 by University of Toronto.\n *\tWritten by Henry Spencer.  Not derived from licensed software.\n *\n *\tPermission is granted to anyone to use this software for any\n *\tpurpose on any computer system, and to redistribute it freely,\n *\tsubject to the following restrictions:\n *\n *\t1. The author is not responsible for the consequences of use of\n *\t\tthis software, no matter how awful, even if they arise\n *\t\tfrom defects in it.\n *\n *\t2. The origin of this software must not be misrepresented, either\n *\t\tby explicit claim or by omission.\n *\n *\t3. Altered versions must be plainly marked as such, and must not\n *\t\tbe misrepresented as being the original software.\n *\n * Beware that some of this code is subtly aware of the way operator\n * precedence is structured in regular expressions.  Serious changes in\n * regular-expression syntax might require a total rethink.\n *\n * Changes have been made by Tony Andrews, Olaf 'Rhialto' Seibert, Robert\n * Webb, Ciaran McCreesh and Bram Moolenaar.\n * Named character class support added by Walter Briscoe (1998 Jul 01)\n */\n\n/*\n * The \"internal use only\" fields in regexp.h are present to pass info from\n * compile to execute that permits the execute phase to run lots faster on\n * simple cases.  They are:\n *\n * regstart\tchar that must begin a match; NUL if none obvious; Can be a\n *\t\tmulti-byte character.\n * reganch\tis the match anchored (at beginning-of-line only)?\n * regmust\tstring (pointer into program) that match must include, or NULL\n * regmlen\tlength of regmust string\n * regflags\tRF_ values or'ed together\n *\n * Regstart and reganch permit very fast decisions on suitable starting points\n * for a match, cutting down the work a lot.  Regmust permits fast rejection\n * of lines that cannot possibly match.  The regmust tests are costly enough\n * that vim_regcomp() supplies a regmust only if the r.e. contains something\n * potentially expensive (at present, the only such thing detected is * or +\n * at the start of the r.e., which can involve a lot of backup).  Regmlen is\n * supplied because the test in vim_regexec() needs it and vim_regcomp() is\n * computing it anyway.\n */\n\n/*\n * Structure for regexp \"program\".  This is essentially a linear encoding\n * of a nondeterministic finite-state machine (aka syntax charts or\n * \"railroad normal form\" in parsing technology).  Each node is an opcode\n * plus a \"next\" pointer, possibly plus an operand.  \"Next\" pointers of\n * all nodes except BRANCH and BRACES_COMPLEX implement concatenation; a \"next\"\n * pointer with a BRANCH on both ends of it is connecting two alternatives.\n * (Here we have one of the subtle syntax dependencies:\tan individual BRANCH\n * (as opposed to a collection of them) is never concatenated with anything\n * because of operator precedence).  The \"next\" pointer of a BRACES_COMPLEX\n * node points to the node after the stuff to be repeated.\n * The operand of some types of node is a literal string; for others, it is a\n * node leading into a sub-FSM.  In particular, the operand of a BRANCH node\n * is the first node of the branch.\n * (NB this is *not* a tree structure: the tail of the branch connects to the\n * thing following the set of BRANCHes.)\n *\n * pattern\tis coded like:\n *\n *\t\t\t  +-----------------+\n *\t\t\t  |\t\t    V\n * <aa>\\|<bb>\tBRANCH <aa> BRANCH <bb> --> END\n *\t\t     |\t    ^\t |\t    ^\n *\t\t     +------+\t +----------+\n *\n *\n *\t\t       +------------------+\n *\t\t       V\t\t  |\n * <aa>*\tBRANCH BRANCH <aa> --> BACK BRANCH --> NOTHING --> END\n *\t\t     |\t    |\t\t    ^\t\t\t   ^\n *\t\t     |\t    +---------------+\t\t\t   |\n *\t\t     +---------------------------------------------+\n *\n *\n *\t\t       +----------------------+\n *\t\t       V\t\t      |\n * <aa>\\+\tBRANCH <aa> --> BRANCH --> BACK  BRANCH --> NOTHING --> END\n *\t\t     |\t\t     |\t\t ^\t\t\t^\n *\t\t     |\t\t     +-----------+\t\t\t|\n *\t\t     +--------------------------------------------------+\n *\n *\n *\t\t\t\t\t+-------------------------+\n *\t\t\t\t\tV\t\t\t  |\n * <aa>\\{}\tBRANCH BRACE_LIMITS --> BRACE_COMPLEX <aa> --> BACK  END\n *\t\t     |\t\t\t\t    |\t\t     ^\n *\t\t     |\t\t\t\t    +----------------+\n *\t\t     +-----------------------------------------------+\n *\n *\n * <aa>\\@!<bb>\tBRANCH NOMATCH <aa> --> END  <bb> --> END\n *\t\t     |\t     |\t\t      ^       ^\n *\t\t     |\t     +----------------+       |\n *\t\t     +--------------------------------+\n *\n *\t\t\t\t\t\t      +---------+\n *\t\t\t\t\t\t      |\t\tV\n * \\z[abc]\tBRANCH BRANCH  a  BRANCH  b  BRANCH  c\tBRANCH\tNOTHING --> END\n *\t\t     |\t    |\t       |\t  |\t^\t\t    ^\n *\t\t     |\t    |\t       |\t  +-----+\t\t    |\n *\t\t     |\t    |\t       +----------------+\t\t    |\n *\t\t     |\t    +---------------------------+\t\t    |\n *\t\t     +------------------------------------------------------+\n *\n * They all start with a BRANCH for \"\\|\" alternatives, even when there is only\n * one alternative.\n */\n\n/*\n * The opcodes are:\n */\n\n// definition\tnumber\t\t   opnd?    meaning\n#define END\t\t0\t//\tEnd of program or NOMATCH operand.\n#define BOL\t\t1\t//\tMatch \"\" at beginning of line.\n#define EOL\t\t2\t//\tMatch \"\" at end of line.\n#define BRANCH\t\t3\t// node Match this alternative, or the\n\t\t\t\t//\tnext...\n#define BACK\t\t4\t//\tMatch \"\", \"next\" ptr points backward.\n#define EXACTLY\t\t5\t// str\tMatch this string.\n#define NOTHING\t\t6\t//\tMatch empty string.\n#define STAR\t\t7\t// node Match this (simple) thing 0 or more\n\t\t\t\t//\ttimes.\n#define PLUS\t\t8\t// node Match this (simple) thing 1 or more\n\t\t\t\t//\ttimes.\n#define MATCH\t\t9\t// node match the operand zero-width\n#define NOMATCH\t\t10\t// node check for no match with operand\n#define BEHIND\t\t11\t// node look behind for a match with operand\n#define NOBEHIND\t12\t// node look behind for no match with operand\n#define SUBPAT\t\t13\t// node match the operand here\n#define BRACE_SIMPLE\t14\t// node Match this (simple) thing between m and\n\t\t\t\t//\tn times (\\{m,n\\}).\n#define BOW\t\t15\t//\tMatch \"\" after [^a-zA-Z0-9_]\n#define EOW\t\t16\t//\tMatch \"\" at    [^a-zA-Z0-9_]\n#define BRACE_LIMITS\t17\t// nr nr  define the min & max for BRACE_SIMPLE\n\t\t\t\t//\tand BRACE_COMPLEX.\n#define NEWL\t\t18\t//\tMatch line-break\n#define BHPOS\t\t19\t//\tEnd position for BEHIND or NOBEHIND\n\n\n// character classes: 20-48 normal, 50-78 include a line-break\n#define ADD_NL\t\t30\n#define FIRST_NL\tANY + ADD_NL\n#define ANY\t\t20\t//\tMatch any one character.\n#define ANYOF\t\t21\t// str\tMatch any character in this string.\n#define ANYBUT\t\t22\t// str\tMatch any character not in this\n\t\t\t\t//\tstring.\n#define IDENT\t\t23\t//\tMatch identifier char\n#define SIDENT\t\t24\t//\tMatch identifier char but no digit\n#define KWORD\t\t25\t//\tMatch keyword char\n#define SKWORD\t\t26\t//\tMatch word char but no digit\n#define FNAME\t\t27\t//\tMatch file name char\n#define SFNAME\t\t28\t//\tMatch file name char but no digit\n#define PRINT\t\t29\t//\tMatch printable char\n#define SPRINT\t\t30\t//\tMatch printable char but no digit\n#define WHITE\t\t31\t//\tMatch whitespace char\n#define NWHITE\t\t32\t//\tMatch non-whitespace char\n#define DIGIT\t\t33\t//\tMatch digit char\n#define NDIGIT\t\t34\t//\tMatch non-digit char\n#define HEX\t\t35\t//\tMatch hex char\n#define NHEX\t\t36\t//\tMatch non-hex char\n#define OCTAL\t\t37\t//\tMatch octal char\n#define NOCTAL\t\t38\t//\tMatch non-octal char\n#define WORD\t\t39\t//\tMatch word char\n#define NWORD\t\t40\t//\tMatch non-word char\n#define HEAD\t\t41\t//\tMatch head char\n#define NHEAD\t\t42\t//\tMatch non-head char\n#define ALPHA\t\t43\t//\tMatch alpha char\n#define NALPHA\t\t44\t//\tMatch non-alpha char\n#define LOWER\t\t45\t//\tMatch lowercase char\n#define NLOWER\t\t46\t//\tMatch non-lowercase char\n#define UPPER\t\t47\t//\tMatch uppercase char\n#define NUPPER\t\t48\t//\tMatch non-uppercase char\n#define LAST_NL\t\tNUPPER + ADD_NL\n#define WITH_NL(op)\t((op) >= FIRST_NL && (op) <= LAST_NL)\n\n#define MOPEN\t\t80  // -89\t Mark this point in input as start of\n\t\t\t\t//\t \\( subexpr.  MOPEN + 0 marks start of\n\t\t\t\t//\t match.\n#define MCLOSE\t\t90  // -99\t Analogous to MOPEN.  MCLOSE + 0 marks\n\t\t\t\t//\t end of match.\n#define BACKREF\t\t100 // -109 node Match same string again \\1-\\9\n\n#ifdef FEAT_SYN_HL\n# define ZOPEN\t\t110 // -119\t Mark this point in input as start of\n\t\t\t\t//\t \\z( subexpr.\n# define ZCLOSE\t\t120 // -129\t Analogous to ZOPEN.\n# define ZREF\t\t130 // -139 node Match external submatch \\z1-\\z9\n#endif\n\n#define BRACE_COMPLEX\t140 // -149 node Match nodes between m & n times\n\n#define NOPEN\t\t150\t//\tMark this point in input as start of\n\t\t\t\t//\t\\%( subexpr.\n#define NCLOSE\t\t151\t//\tAnalogous to NOPEN.\n\n#define MULTIBYTECODE\t200\t// mbc\tMatch one multi-byte character\n#define RE_BOF\t\t201\t//\tMatch \"\" at beginning of file.\n#define RE_EOF\t\t202\t//\tMatch \"\" at end of file.\n#define CURSOR\t\t203\t//\tMatch location of cursor.\n\n#define RE_LNUM\t\t204\t// nr cmp  Match line number\n#define RE_COL\t\t205\t// nr cmp  Match column number\n#define RE_VCOL\t\t206\t// nr cmp  Match virtual column number\n\n#define RE_MARK\t\t207\t// mark cmp  Match mark position\n#define RE_VISUAL\t208\t//\tMatch Visual area\n#define RE_COMPOSING\t209\t// any composing characters\n\n/*\n * Flags to be passed up and down.\n */\n#define HASWIDTH\t0x1\t// Known never to match null string.\n#define SIMPLE\t\t0x2\t// Simple enough to be STAR/PLUS operand.\n#define SPSTART\t\t0x4\t// Starts with * or +.\n#define HASNL\t\t0x8\t// Contains some \\n.\n#define HASLOOKBH\t0x10\t// Contains \"\\@<=\" or \"\\@<!\".\n#define WORST\t\t0\t// Worst case.\n\nstatic int\tnum_complex_braces; // Complex \\{...} count\nstatic char_u\t*regcode;\t// Code-emit pointer, or JUST_CALC_SIZE\nstatic long\tregsize;\t// Code size.\nstatic int\treg_toolong;\t// TRUE when offset out of range\nstatic char_u\thad_endbrace[NSUBEXP];\t// flags, TRUE if end of () found\nstatic long\tbrace_min[10];\t// Minimums for complex brace repeats\nstatic long\tbrace_max[10];\t// Maximums for complex brace repeats\nstatic int\tbrace_count[10]; // Current counts for complex brace repeats\nstatic int\tone_exactly = FALSE;\t// only do one char for EXACTLY\n\n// When making changes to classchars also change nfa_classcodes.\nstatic char_u\t*classchars = (char_u *)\".iIkKfFpPsSdDxXoOwWhHaAlLuU\";\nstatic int\tclasscodes[] = {\n    ANY, IDENT, SIDENT, KWORD, SKWORD,\n    FNAME, SFNAME, PRINT, SPRINT,\n    WHITE, NWHITE, DIGIT, NDIGIT,\n    HEX, NHEX, OCTAL, NOCTAL,\n    WORD, NWORD, HEAD, NHEAD,\n    ALPHA, NALPHA, LOWER, NLOWER,\n    UPPER, NUPPER\n};\n\n/*\n * When regcode is set to this value, code is not emitted and size is computed\n * instead.\n */\n#define JUST_CALC_SIZE\t((char_u *) -1)\n\n// Values for rs_state in regitem_T.\ntypedef enum regstate_E\n{\n    RS_NOPEN = 0\t// NOPEN and NCLOSE\n    , RS_MOPEN\t\t// MOPEN + [0-9]\n    , RS_MCLOSE\t\t// MCLOSE + [0-9]\n#ifdef FEAT_SYN_HL\n    , RS_ZOPEN\t\t// ZOPEN + [0-9]\n    , RS_ZCLOSE\t\t// ZCLOSE + [0-9]\n#endif\n    , RS_BRANCH\t\t// BRANCH\n    , RS_BRCPLX_MORE\t// BRACE_COMPLEX and trying one more match\n    , RS_BRCPLX_LONG\t// BRACE_COMPLEX and trying longest match\n    , RS_BRCPLX_SHORT\t// BRACE_COMPLEX and trying shortest match\n    , RS_NOMATCH\t// NOMATCH\n    , RS_BEHIND1\t// BEHIND / NOBEHIND matching rest\n    , RS_BEHIND2\t// BEHIND / NOBEHIND matching behind part\n    , RS_STAR_LONG\t// STAR/PLUS/BRACE_SIMPLE longest match\n    , RS_STAR_SHORT\t// STAR/PLUS/BRACE_SIMPLE shortest match\n} regstate_T;\n\n/*\n * Structure used to save the current input state, when it needs to be\n * restored after trying a match.  Used by reg_save() and reg_restore().\n * Also stores the length of \"backpos\".\n */\ntypedef struct\n{\n    union\n    {\n\tchar_u\t*ptr;\t// rex.input pointer, for single-line regexp\n\tlpos_T\tpos;\t// rex.input pos, for multi-line regexp\n    } rs_u;\n    int\t\trs_len;\n} regsave_T;\n\n// struct to save start/end pointer/position in for \\(\\)\ntypedef struct\n{\n    union\n    {\n\tchar_u\t*ptr;\n\tlpos_T\tpos;\n    } se_u;\n} save_se_T;\n\n// used for BEHIND and NOBEHIND matching\ntypedef struct regbehind_S\n{\n    regsave_T\tsave_after;\n    regsave_T\tsave_behind;\n    int\t\tsave_need_clear_subexpr;\n    save_se_T   save_start[NSUBEXP];\n    save_se_T   save_end[NSUBEXP];\n} regbehind_T;\n\n/*\n * When there are alternatives a regstate_T is put on the regstack to remember\n * what we are doing.\n * Before it may be another type of item, depending on rs_state, to remember\n * more things.\n */\ntypedef struct regitem_S\n{\n    regstate_T\trs_state;\t// what we are doing, one of RS_ above\n    short\trs_no;\t\t// submatch nr or BEHIND/NOBEHIND\n    char_u\t*rs_scan;\t// current node in program\n    union\n    {\n\tsave_se_T  sesave;\n\tregsave_T  regsave;\n    } rs_un;\t\t\t// room for saving rex.input\n} regitem_T;\n\n\n// used for STAR, PLUS and BRACE_SIMPLE matching\ntypedef struct regstar_S\n{\n    int\t\tnextb;\t\t// next byte\n    int\t\tnextb_ic;\t// next byte reverse case\n    long\tcount;\n    long\tminval;\n    long\tmaxval;\n} regstar_T;\n\n// used to store input position when a BACK was encountered, so that we now if\n// we made any progress since the last time.\ntypedef struct backpos_S\n{\n    char_u\t*bp_scan;\t// \"scan\" where BACK was encountered\n    regsave_T\tbp_pos;\t\t// last input position\n} backpos_T;\n\n/*\n * \"regstack\" and \"backpos\" are used by regmatch().  They are kept over calls\n * to avoid invoking malloc() and free() often.\n * \"regstack\" is a stack with regitem_T items, sometimes preceded by regstar_T\n * or regbehind_T.\n * \"backpos_T\" is a table with backpos_T for BACK\n */\nstatic garray_T\tregstack = {0, 0, 0, 0, NULL};\nstatic garray_T\tbackpos = {0, 0, 0, 0, NULL};\n\nstatic regsave_T behind_pos;\n\n/*\n * Both for regstack and backpos tables we use the following strategy of\n * allocation (to reduce malloc/free calls):\n * - Initial size is fairly small.\n * - When needed, the tables are grown bigger (8 times at first, double after\n *   that).\n * - After executing the match we free the memory only if the array has grown.\n *   Thus the memory is kept allocated when it's at the initial size.\n * This makes it fast while not keeping a lot of memory allocated.\n * A three times speed increase was observed when using many simple patterns.\n */\n#define REGSTACK_INITIAL\t2048\n#define BACKPOS_INITIAL\t\t64\n\n/*\n * Opcode notes:\n *\n * BRANCH\tThe set of branches constituting a single choice are hooked\n *\t\ttogether with their \"next\" pointers, since precedence prevents\n *\t\tanything being concatenated to any individual branch.  The\n *\t\t\"next\" pointer of the last BRANCH in a choice points to the\n *\t\tthing following the whole choice.  This is also where the\n *\t\tfinal \"next\" pointer of each individual branch points; each\n *\t\tbranch starts with the operand node of a BRANCH node.\n *\n * BACK\t\tNormal \"next\" pointers all implicitly point forward; BACK\n *\t\texists to make loop structures possible.\n *\n * STAR,PLUS\t'=', and complex '*' and '+', are implemented as circular\n *\t\tBRANCH structures using BACK.  Simple cases (one character\n *\t\tper match) are implemented with STAR and PLUS for speed\n *\t\tand to minimize recursive plunges.\n *\n * BRACE_LIMITS\tThis is always followed by a BRACE_SIMPLE or BRACE_COMPLEX\n *\t\tnode, and defines the min and max limits to be used for that\n *\t\tnode.\n *\n * MOPEN,MCLOSE\t...are numbered at compile time.\n * ZOPEN,ZCLOSE\t...ditto\n */\n\n/*\n * A node is one char of opcode followed by two chars of \"next\" pointer.\n * \"Next\" pointers are stored as two 8-bit bytes, high order first.  The\n * value is a positive offset from the opcode of the node containing it.\n * An operand, if any, simply follows the node.  (Note that much of the\n * code generation knows about this implicit relationship.)\n *\n * Using two bytes for the \"next\" pointer is vast overkill for most things,\n * but allows patterns to get big without disasters.\n */\n#define OP(p)\t\t((int)*(p))\n#define NEXT(p)\t\t(((*((p) + 1) & 0377) << 8) + (*((p) + 2) & 0377))\n#define OPERAND(p)\t((p) + 3)\n// Obtain an operand that was stored as four bytes, MSB first.\n#define OPERAND_MIN(p)\t(((long)(p)[3] << 24) + ((long)(p)[4] << 16) \\\n\t\t\t+ ((long)(p)[5] << 8) + (long)(p)[6])\n// Obtain a second operand stored as four bytes.\n#define OPERAND_MAX(p)\tOPERAND_MIN((p) + 4)\n// Obtain a second single-byte operand stored after a four bytes operand.\n#define OPERAND_CMP(p)\t(p)[7]\n\nstatic char_u *reg(int paren, int *flagp);\n\n#ifdef BT_REGEXP_DUMP\nstatic void\tregdump(char_u *, bt_regprog_T *);\n#endif\n\nstatic int\tre_num_cmp(long_u val, char_u *scan);\n\n#ifdef DEBUG\nstatic char_u\t*regprop(char_u *);\n\nstatic int\tregnarrate = 0;\n#endif\n\n\n/*\n * Setup to parse the regexp.  Used once to get the length and once to do it.\n */\n    static void\nregcomp_start(\n    char_u\t*expr,\n    int\t\tre_flags)\t    // see vim_regcomp()\n{\n    initchr(expr);\n    if (re_flags & RE_MAGIC)\n\treg_magic = MAGIC_ON;\n    else\n\treg_magic = MAGIC_OFF;\n    reg_string = (re_flags & RE_STRING);\n    reg_strict = (re_flags & RE_STRICT);\n    get_cpo_flags();\n\n    num_complex_braces = 0;\n    regnpar = 1;\n    CLEAR_FIELD(had_endbrace);\n#ifdef FEAT_SYN_HL\n    regnzpar = 1;\n    re_has_z = 0;\n#endif\n    regsize = 0L;\n    reg_toolong = FALSE;\n    regflags = 0;\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n    had_eol = FALSE;\n#endif\n}\n\n/*\n * Return TRUE if MULTIBYTECODE should be used instead of EXACTLY for\n * character \"c\".\n */\n    static int\nuse_multibytecode(int c)\n{\n    return has_mbyte && (*mb_char2len)(c) > 1\n\t\t     && (re_multi_type(peekchr()) != NOT_MULTI\n\t\t\t     || (enc_utf8 && utf_iscomposing(c)));\n}\n\n/*\n * Emit (if appropriate) a byte of code\n */\n    static void\nregc(int b)\n{\n    if (regcode == JUST_CALC_SIZE)\n\tregsize++;\n    else\n\t*regcode++ = b;\n}\n\n/*\n * Emit (if appropriate) a multi-byte character of code\n */\n    static void\nregmbc(int c)\n{\n    if (!has_mbyte && c > 0xff)\n\treturn;\n    if (regcode == JUST_CALC_SIZE)\n\tregsize += (*mb_char2len)(c);\n    else\n\tregcode += (*mb_char2bytes)(c, regcode);\n}\n\n\n/*\n * Produce the bytes for equivalence class \"c\".\n * Currently only handles latin1, latin9 and utf-8.\n * NOTE: When changing this function, also change nfa_emit_equi_class()\n */\n    static void\nreg_equi_class(int c)\n{\n    if (enc_utf8 || STRCMP(p_enc, \"latin1\") == 0\n\t\t\t\t\t || STRCMP(p_enc, \"iso-8859-15\") == 0)\n    {\n\tswitch (c)\n\t{\n\t    // Do not use '\\300' style, it results in a negative number.\n\t    case 'A': case 0xc0: case 0xc1: case 0xc2: case 0xc3: case 0xc4:\n\t    case 0xc5: case 0x100: case 0x102: case 0x104: case 0x1cd:\n\t    case 0x1de: case 0x1e0: case 0x1fa: case 0x202: case 0x226:\n\t    case 0x23a: case 0x1e00: case 0x1ea0: case 0x1ea2: case 0x1ea4:\n\t    case 0x1ea6: case 0x1ea8: case 0x1eaa: case 0x1eac: case 0x1eae:\n\t    case 0x1eb0: case 0x1eb2: case 0x1eb4: case 0x1eb6:\n\t\t      regmbc('A'); regmbc(0xc0); regmbc(0xc1); regmbc(0xc2);\n\t\t      regmbc(0xc3); regmbc(0xc4); regmbc(0xc5);\n\t\t      regmbc(0x100); regmbc(0x102); regmbc(0x104);\n\t\t      regmbc(0x1cd); regmbc(0x1de); regmbc(0x1e0);\n\t\t      regmbc(0x1fa); regmbc(0x202); regmbc(0x226);\n\t\t      regmbc(0x23a); regmbc(0x1e00); regmbc(0x1ea0);\n\t\t      regmbc(0x1ea2); regmbc(0x1ea4); regmbc(0x1ea6);\n\t\t      regmbc(0x1ea8); regmbc(0x1eaa); regmbc(0x1eac);\n\t\t      regmbc(0x1eae); regmbc(0x1eb0); regmbc(0x1eb2);\n\t\t      regmbc(0x1eb4); regmbc(0x1eb6);\n\t\t      return;\n\t    case 'B': case 0x181: case 0x243: case 0x1e02:\n\t    case 0x1e04: case 0x1e06:\n\t\t      regmbc('B');\n\t\t      regmbc(0x181); regmbc(0x243); regmbc(0x1e02);\n\t\t      regmbc(0x1e04); regmbc(0x1e06);\n\t\t      return;\n\t    case 'C': case 0xc7:\n\t    case 0x106: case 0x108: case 0x10a: case 0x10c: case 0x187:\n\t    case 0x23b: case 0x1e08: case 0xa792:\n\t\t      regmbc('C'); regmbc(0xc7);\n\t\t      regmbc(0x106); regmbc(0x108); regmbc(0x10a);\n\t\t      regmbc(0x10c); regmbc(0x187); regmbc(0x23b);\n\t\t      regmbc(0x1e08); regmbc(0xa792);\n\t\t      return;\n\t    case 'D': case 0x10e: case 0x110: case 0x18a:\n\t    case 0x1e0a: case 0x1e0c: case 0x1e0e: case 0x1e10:\n\t    case 0x1e12:\n\t\t      regmbc('D'); regmbc(0x10e); regmbc(0x110);\n\t\t      regmbc(0x18a); regmbc(0x1e0a); regmbc(0x1e0c);\n\t\t      regmbc(0x1e0e); regmbc(0x1e10); regmbc(0x1e12);\n\t\t      return;\n\t    case 'E': case 0xc8: case 0xc9: case 0xca: case 0xcb:\n\t    case 0x112: case 0x114: case 0x116: case 0x118: case 0x11a:\n\t    case 0x204: case 0x206: case 0x228: case 0x246: case 0x1e14:\n\t    case 0x1e16: case 0x1e18: case 0x1e1a: case 0x1e1c:\n\t    case 0x1eb8: case 0x1eba: case 0x1ebc: case 0x1ebe:\n\t    case 0x1ec0: case 0x1ec2: case 0x1ec4: case 0x1ec6:\n\t\t      regmbc('E'); regmbc(0xc8); regmbc(0xc9);\n\t\t      regmbc(0xca); regmbc(0xcb); regmbc(0x112);\n\t\t      regmbc(0x114); regmbc(0x116); regmbc(0x118);\n\t\t      regmbc(0x11a); regmbc(0x204); regmbc(0x206);\n\t\t      regmbc(0x228); regmbc(0x246); regmbc(0x1e14);\n\t\t      regmbc(0x1e16); regmbc(0x1e18); regmbc(0x1e1a);\n\t\t      regmbc(0x1e1c); regmbc(0x1eb8); regmbc(0x1eba);\n\t\t      regmbc(0x1ebc); regmbc(0x1ebe); regmbc(0x1ec0);\n\t\t      regmbc(0x1ec2); regmbc(0x1ec4); regmbc(0x1ec6);\n\t\t      return;\n\t    case 'F': case 0x191: case 0x1e1e: case 0xa798:\n\t\t      regmbc('F'); regmbc(0x191); regmbc(0x1e1e);\n\t\t      regmbc(0xa798);\n\t\t      return;\n\t    case 'G': case 0x11c: case 0x11e: case 0x120:\n\t    case 0x122: case 0x193: case 0x1e4: case 0x1e6:\n\t    case 0x1f4: case 0x1e20: case 0xa7a0:\n\t\t      regmbc('G'); regmbc(0x11c); regmbc(0x11e);\n\t\t      regmbc(0x120); regmbc(0x122); regmbc(0x193);\n\t\t      regmbc(0x1e4); regmbc(0x1e6); regmbc(0x1f4);\n\t\t      regmbc(0x1e20); regmbc(0xa7a0);\n\t\t      return;\n\t    case 'H': case 0x124: case 0x126: case 0x21e:\n\t    case 0x1e22: case 0x1e24: case 0x1e26:\n\t    case 0x1e28: case 0x1e2a: case 0x2c67:\n\t\t      regmbc('H'); regmbc(0x124); regmbc(0x126);\n\t\t      regmbc(0x21e); regmbc(0x1e22); regmbc(0x1e24);\n\t\t      regmbc(0x1e26); regmbc(0x1e28); regmbc(0x1e2a);\n\t\t      regmbc(0x2c67);\n\t\t      return;\n\t    case 'I': case 0xcc: case 0xcd: case 0xce: case 0xcf:\n\t    case 0x128: case 0x12a: case 0x12c: case 0x12e:\n\t    case 0x130: case 0x197: case 0x1cf: case 0x208:\n\t    case 0x20a: case 0x1e2c: case 0x1e2e: case 0x1ec8:\n\t    case 0x1eca:\n\t\t      regmbc('I'); regmbc(0xcc); regmbc(0xcd);\n\t\t      regmbc(0xce); regmbc(0xcf); regmbc(0x128);\n\t\t      regmbc(0x12a); regmbc(0x12c); regmbc(0x12e);\n\t\t      regmbc(0x130); regmbc(0x197); regmbc(0x1cf);\n\t\t      regmbc(0x208); regmbc(0x20a); regmbc(0x1e2c);\n\t\t      regmbc(0x1e2e); regmbc(0x1ec8); regmbc(0x1eca);\n\t\t      return;\n\t    case 'J': case 0x134: case 0x248:\n\t\t      regmbc('J'); regmbc(0x134); regmbc(0x248);\n\t\t      return;\n\t    case 'K': case 0x136: case 0x198: case 0x1e8: case 0x1e30:\n\t    case 0x1e32: case 0x1e34: case 0x2c69: case 0xa740:\n\t\t      regmbc('K'); regmbc(0x136); regmbc(0x198);\n\t\t      regmbc(0x1e8); regmbc(0x1e30); regmbc(0x1e32);\n\t\t      regmbc(0x1e34); regmbc(0x2c69); regmbc(0xa740);\n\t\t      return;\n\t    case 'L': case 0x139: case 0x13b: case 0x13d: case 0x13f:\n\t    case 0x141: case 0x23d: case 0x1e36: case 0x1e38:\n\t    case 0x1e3a: case 0x1e3c: case 0x2c60:\n\t\t      regmbc('L'); regmbc(0x139); regmbc(0x13b);\n\t\t      regmbc(0x13d); regmbc(0x13f); regmbc(0x141);\n\t\t      regmbc(0x23d); regmbc(0x1e36); regmbc(0x1e38);\n\t\t      regmbc(0x1e3a); regmbc(0x1e3c); regmbc(0x2c60);\n\t\t      return;\n\t    case 'M': case 0x1e3e: case 0x1e40: case 0x1e42:\n\t\t      regmbc('M'); regmbc(0x1e3e); regmbc(0x1e40);\n\t\t      regmbc(0x1e42);\n\t\t      return;\n\t    case 'N': case 0xd1:\n\t    case 0x143: case 0x145: case 0x147: case 0x1f8:\n\t    case 0x1e44: case 0x1e46: case 0x1e48: case 0x1e4a:\n\t    case 0xa7a4:\n\t\t      regmbc('N'); regmbc(0xd1);\n\t\t      regmbc(0x143); regmbc(0x145); regmbc(0x147);\n\t\t      regmbc(0x1f8); regmbc(0x1e44); regmbc(0x1e46);\n\t\t      regmbc(0x1e48); regmbc(0x1e4a); regmbc(0xa7a4);\n\t\t      return;\n\t    case 'O': case 0xd2: case 0xd3: case 0xd4: case 0xd5: case 0xd6:\n\t    case 0xd8: case 0x14c: case 0x14e: case 0x150: case 0x19f:\n\t    case 0x1a0: case 0x1d1: case 0x1ea: case 0x1ec: case 0x1fe:\n\t    case 0x20c: case 0x20e: case 0x22a: case 0x22c: case 0x22e:\n\t    case 0x230: case 0x1e4c: case 0x1e4e: case 0x1e50: case 0x1e52:\n\t    case 0x1ecc: case 0x1ece: case 0x1ed0: case 0x1ed2: case 0x1ed4:\n\t    case 0x1ed6: case 0x1ed8: case 0x1eda: case 0x1edc: case 0x1ede:\n\t    case 0x1ee0: case 0x1ee2:\n\t\t      regmbc('O'); regmbc(0xd2); regmbc(0xd3); regmbc(0xd4);\n\t\t      regmbc(0xd5); regmbc(0xd6); regmbc(0xd8);\n\t\t      regmbc(0x14c); regmbc(0x14e); regmbc(0x150);\n\t\t      regmbc(0x19f); regmbc(0x1a0); regmbc(0x1d1);\n\t\t      regmbc(0x1ea); regmbc(0x1ec); regmbc(0x1fe);\n\t\t      regmbc(0x20c); regmbc(0x20e); regmbc(0x22a);\n\t\t      regmbc(0x22c); regmbc(0x22e); regmbc(0x230);\n\t\t      regmbc(0x1e4c); regmbc(0x1e4e); regmbc(0x1e50);\n\t\t      regmbc(0x1e52); regmbc(0x1ecc); regmbc(0x1ece);\n\t\t      regmbc(0x1ed0); regmbc(0x1ed2); regmbc(0x1ed4);\n\t\t      regmbc(0x1ed6); regmbc(0x1ed8); regmbc(0x1eda);\n\t\t      regmbc(0x1edc); regmbc(0x1ede); regmbc(0x1ee0);\n\t\t      regmbc(0x1ee2);\n\t\t      return;\n\t    case 'P': case 0x1a4: case 0x1e54: case 0x1e56: case 0x2c63:\n\t\t      regmbc('P'); regmbc(0x1a4); regmbc(0x1e54);\n\t\t      regmbc(0x1e56); regmbc(0x2c63);\n\t\t      return;\n\t    case 'Q': case 0x24a:\n\t\t      regmbc('Q'); regmbc(0x24a);\n\t\t      return;\n\t    case 'R': case 0x154: case 0x156: case 0x158: case 0x210:\n\t    case 0x212: case 0x24c: case 0x1e58: case 0x1e5a:\n\t    case 0x1e5c: case 0x1e5e: case 0x2c64: case 0xa7a6:\n\t\t      regmbc('R'); regmbc(0x154); regmbc(0x156);\n\t\t      regmbc(0x210); regmbc(0x212); regmbc(0x158);\n\t\t      regmbc(0x24c); regmbc(0x1e58); regmbc(0x1e5a);\n\t\t      regmbc(0x1e5c); regmbc(0x1e5e); regmbc(0x2c64);\n\t\t      regmbc(0xa7a6);\n\t\t      return;\n\t    case 'S': case 0x15a: case 0x15c: case 0x15e: case 0x160:\n\t    case 0x218: case 0x1e60: case 0x1e62: case 0x1e64:\n\t    case 0x1e66: case 0x1e68: case 0x2c7e: case 0xa7a8:\n\t\t      regmbc('S'); regmbc(0x15a); regmbc(0x15c);\n\t\t      regmbc(0x15e); regmbc(0x160); regmbc(0x218);\n\t\t      regmbc(0x1e60); regmbc(0x1e62); regmbc(0x1e64);\n\t\t      regmbc(0x1e66); regmbc(0x1e68); regmbc(0x2c7e);\n\t\t\t  regmbc(0xa7a8);\n\t\t      return;\n\t    case 'T': case 0x162: case 0x164: case 0x166: case 0x1ac:\n\t    case 0x1ae: case 0x21a: case 0x23e: case 0x1e6a: case 0x1e6c:\n\t    case 0x1e6e: case 0x1e70:\n\t\t      regmbc('T'); regmbc(0x162); regmbc(0x164);\n\t\t      regmbc(0x166); regmbc(0x1ac); regmbc(0x23e);\n\t\t      regmbc(0x1ae); regmbc(0x21a); regmbc(0x1e6a);\n\t\t      regmbc(0x1e6c); regmbc(0x1e6e); regmbc(0x1e70);\n\t\t      return;\n\t    case 'U': case 0xd9: case 0xda: case 0xdb: case 0xdc:\n\t    case 0x168: case 0x16a: case 0x16c: case 0x16e:\n\t    case 0x170: case 0x172: case 0x1af: case 0x1d3:\n\t    case 0x1d5: case 0x1d7: case 0x1d9: case 0x1db:\n\t    case 0x214: case 0x216: case 0x244: case 0x1e72:\n\t    case 0x1e74: case 0x1e76: case 0x1e78: case 0x1e7a:\n\t    case 0x1ee4: case 0x1ee6: case 0x1ee8: case 0x1eea:\n\t    case 0x1eec: case 0x1eee: case 0x1ef0:\n\t\t      regmbc('U'); regmbc(0xd9); regmbc(0xda);\n\t\t      regmbc(0xdb); regmbc(0xdc); regmbc(0x168);\n\t\t      regmbc(0x16a); regmbc(0x16c); regmbc(0x16e);\n\t\t      regmbc(0x170); regmbc(0x172); regmbc(0x1af);\n\t\t      regmbc(0x1d3); regmbc(0x1d5); regmbc(0x1d7);\n\t\t      regmbc(0x1d9); regmbc(0x1db); regmbc(0x214);\n\t\t      regmbc(0x216); regmbc(0x244); regmbc(0x1e72);\n\t\t      regmbc(0x1e74); regmbc(0x1e76); regmbc(0x1e78);\n\t\t      regmbc(0x1e7a); regmbc(0x1ee4); regmbc(0x1ee6);\n\t\t      regmbc(0x1ee8); regmbc(0x1eea); regmbc(0x1eec);\n\t\t      regmbc(0x1eee); regmbc(0x1ef0);\n\t\t      return;\n\t    case 'V': case 0x1b2: case 0x1e7c: case 0x1e7e:\n\t\t      regmbc('V'); regmbc(0x1b2); regmbc(0x1e7c);\n\t\t      regmbc(0x1e7e);\n\t\t      return;\n\t    case 'W': case 0x174: case 0x1e80: case 0x1e82:\n\t    case 0x1e84: case 0x1e86: case 0x1e88:\n\t\t      regmbc('W'); regmbc(0x174); regmbc(0x1e80);\n\t\t      regmbc(0x1e82); regmbc(0x1e84); regmbc(0x1e86);\n\t\t      regmbc(0x1e88);\n\t\t      return;\n\t    case 'X': case 0x1e8a: case 0x1e8c:\n\t\t      regmbc('X'); regmbc(0x1e8a); regmbc(0x1e8c);\n\t\t      return;\n\t    case 'Y': case 0xdd:\n\t    case 0x176: case 0x178: case 0x1b3: case 0x232: case 0x24e:\n\t    case 0x1e8e: case 0x1ef2: case 0x1ef6: case 0x1ef4: case 0x1ef8:\n\t\t      regmbc('Y'); regmbc(0xdd); regmbc(0x176);\n\t\t      regmbc(0x178); regmbc(0x1b3); regmbc(0x232);\n\t\t      regmbc(0x24e); regmbc(0x1e8e); regmbc(0x1ef2);\n\t\t      regmbc(0x1ef4); regmbc(0x1ef6); regmbc(0x1ef8);\n\t\t      return;\n\t    case 'Z': case 0x179: case 0x17b: case 0x17d: case 0x1b5:\n\t    case 0x1e90: case 0x1e92: case 0x1e94: case 0x2c6b:\n\t\t      regmbc('Z'); regmbc(0x179); regmbc(0x17b);\n\t\t      regmbc(0x17d); regmbc(0x1b5); regmbc(0x1e90);\n\t\t      regmbc(0x1e92); regmbc(0x1e94); regmbc(0x2c6b);\n\t\t      return;\n\t    case 'a': case 0xe0: case 0xe1: case 0xe2:\n\t    case 0xe3: case 0xe4: case 0xe5: case 0x101: case 0x103:\n\t    case 0x105: case 0x1ce: case 0x1df: case 0x1e1: case 0x1fb:\n\t    case 0x201: case 0x203: case 0x227: case 0x1d8f: case 0x1e01:\n\t    case 0x1e9a: case 0x1ea1: case 0x1ea3: case 0x1ea5:\n\t    case 0x1ea7: case 0x1ea9: case 0x1eab: case 0x1ead:\n\t    case 0x1eaf: case 0x1eb1: case 0x1eb3: case 0x1eb5:\n\t    case 0x1eb7: case 0x2c65:\n\t\t      regmbc('a'); regmbc(0xe0); regmbc(0xe1);\n\t\t      regmbc(0xe2); regmbc(0xe3); regmbc(0xe4);\n\t\t      regmbc(0xe5); regmbc(0x101); regmbc(0x103);\n\t\t      regmbc(0x105); regmbc(0x1ce); regmbc(0x1df);\n\t\t      regmbc(0x1e1); regmbc(0x1fb); regmbc(0x201);\n\t\t      regmbc(0x203); regmbc(0x227); regmbc(0x1d8f);\n\t\t      regmbc(0x1e01); regmbc(0x1e9a); regmbc(0x1ea1);\n\t\t      regmbc(0x1ea3); regmbc(0x1ea5); regmbc(0x1ea7);\n\t\t      regmbc(0x1ea9); regmbc(0x1eab); regmbc(0x1ead);\n\t\t      regmbc(0x1eaf); regmbc(0x1eb1); regmbc(0x1eb3);\n\t\t      regmbc(0x1eb5); regmbc(0x1eb7); regmbc(0x2c65);\n\t\t      return;\n\t    case 'b': case 0x180: case 0x253: case 0x1d6c: case 0x1d80:\n\t    case 0x1e03: case 0x1e05: case 0x1e07:\n\t\t      regmbc('b');\n\t\t      regmbc(0x180); regmbc(0x253); regmbc(0x1d6c);\n\t\t      regmbc(0x1d80); regmbc(0x1e03); regmbc(0x1e05);\n\t\t      regmbc(0x1e07);\n\t\t      return;\n\t    case 'c': case 0xe7:\n\t    case 0x107: case 0x109: case 0x10b: case 0x10d: case 0x188:\n\t    case 0x23c: case 0x1e09: case 0xa793: case 0xa794:\n\t\t      regmbc('c'); regmbc(0xe7); regmbc(0x107);\n\t\t      regmbc(0x109); regmbc(0x10b); regmbc(0x10d);\n\t\t      regmbc(0x188); regmbc(0x23c); regmbc(0x1e09);\n\t\t      regmbc(0xa793); regmbc(0xa794);\n\t\t      return;\n\t    case 'd': case 0x10f: case 0x111: case 0x257: case 0x1d6d:\n\t    case 0x1d81: case 0x1d91: case 0x1e0b: case 0x1e0d:\n\t    case 0x1e0f: case 0x1e11: case 0x1e13:\n\t\t      regmbc('d'); regmbc(0x10f); regmbc(0x111);\n\t\t      regmbc(0x257); regmbc(0x1d6d); regmbc(0x1d81);\n\t\t      regmbc(0x1d91); regmbc(0x1e0b); regmbc(0x1e0d);\n\t\t      regmbc(0x1e0f); regmbc(0x1e11); regmbc(0x1e13);\n\t\t      return;\n\t    case 'e': case 0xe8: case 0xe9: case 0xea: case 0xeb:\n\t    case 0x113: case 0x115: case 0x117: case 0x119:\n\t    case 0x11b: case 0x205: case 0x207: case 0x229:\n\t    case 0x247: case 0x1d92: case 0x1e15: case 0x1e17:\n\t    case 0x1e19: case 0x1e1b: case 0x1eb9: case 0x1ebb:\n\t    case 0x1e1d: case 0x1ebd: case 0x1ebf: case 0x1ec1:\n\t    case 0x1ec3: case 0x1ec5: case 0x1ec7:\n\t\t      regmbc('e'); regmbc(0xe8); regmbc(0xe9);\n\t\t      regmbc(0xea); regmbc(0xeb); regmbc(0x113);\n\t\t      regmbc(0x115); regmbc(0x117); regmbc(0x119);\n\t\t      regmbc(0x11b); regmbc(0x205); regmbc(0x207);\n\t\t      regmbc(0x229); regmbc(0x247); regmbc(0x1d92);\n\t\t      regmbc(0x1e15); regmbc(0x1e17); regmbc(0x1e19);\n\t\t      regmbc(0x1e1b); regmbc(0x1e1d); regmbc(0x1eb9);\n\t\t      regmbc(0x1ebb); regmbc(0x1ebd); regmbc(0x1ebf);\n\t\t      regmbc(0x1ec1); regmbc(0x1ec3); regmbc(0x1ec5);\n\t\t      regmbc(0x1ec7);\n\t\t      return;\n\t    case 'f': case 0x192: case 0x1d6e: case 0x1d82:\n\t    case 0x1e1f: case 0xa799:\n\t\t     regmbc('f'); regmbc(0x192); regmbc(0x1d6e);\n\t\t     regmbc(0x1d82); regmbc(0x1e1f); regmbc(0xa799);\n\t\t     return;\n\t    case 'g': case 0x11d: case 0x11f: case 0x121: case 0x123:\n\t    case 0x1e5: case 0x1e7: case 0x260: case 0x1f5: case 0x1d83:\n\t    case 0x1e21: case 0xa7a1:\n\t\t      regmbc('g'); regmbc(0x11d); regmbc(0x11f);\n\t\t      regmbc(0x121); regmbc(0x123); regmbc(0x1e5);\n\t\t      regmbc(0x1e7); regmbc(0x1f5); regmbc(0x260);\n\t\t      regmbc(0x1d83); regmbc(0x1e21); regmbc(0xa7a1);\n\t\t      return;\n\t    case 'h': case 0x125: case 0x127: case 0x21f: case 0x1e23:\n\t    case 0x1e25: case 0x1e27: case 0x1e29: case 0x1e2b:\n\t    case 0x1e96: case 0x2c68: case 0xa795:\n\t\t      regmbc('h'); regmbc(0x125); regmbc(0x127);\n\t\t      regmbc(0x21f); regmbc(0x1e23); regmbc(0x1e25);\n\t\t      regmbc(0x1e27); regmbc(0x1e29); regmbc(0x1e2b);\n\t\t      regmbc(0x1e96); regmbc(0x2c68); regmbc(0xa795);\n\t\t      return;\n\t    case 'i': case 0xec: case 0xed: case 0xee: case 0xef:\n\t    case 0x129: case 0x12b: case 0x12d: case 0x12f:\n\t    case 0x1d0: case 0x209: case 0x20b: case 0x268:\n\t    case 0x1d96: case 0x1e2d: case 0x1e2f: case 0x1ec9:\n\t    case 0x1ecb:\n\t\t      regmbc('i'); regmbc(0xec); regmbc(0xed);\n\t\t      regmbc(0xee); regmbc(0xef); regmbc(0x129);\n\t\t      regmbc(0x12b); regmbc(0x12d); regmbc(0x12f);\n\t\t      regmbc(0x1d0); regmbc(0x209); regmbc(0x20b);\n\t\t      regmbc(0x268); regmbc(0x1d96); regmbc(0x1e2d);\n\t\t      regmbc(0x1e2f); regmbc(0x1ec9); regmbc(0x1ecb);\n\t\t      return;\n\t    case 'j': case 0x135: case 0x1f0: case 0x249:\n\t\t      regmbc('j'); regmbc(0x135); regmbc(0x1f0);\n\t\t      regmbc(0x249);\n\t\t      return;\n\t    case 'k': case 0x137: case 0x199: case 0x1e9:\n\t    case 0x1d84: case 0x1e31: case 0x1e33: case 0x1e35:\n\t    case 0x2c6a: case 0xa741:\n\t\t      regmbc('k'); regmbc(0x137); regmbc(0x199);\n\t\t      regmbc(0x1e9); regmbc(0x1d84); regmbc(0x1e31);\n\t\t      regmbc(0x1e33); regmbc(0x1e35); regmbc(0x2c6a);\n\t\t      regmbc(0xa741);\n\t\t      return;\n\t    case 'l': case 0x13a: case 0x13c: case 0x13e:\n\t    case 0x140: case 0x142: case 0x19a: case 0x1e37:\n\t    case 0x1e39: case 0x1e3b: case 0x1e3d: case 0x2c61:\n\t\t      regmbc('l'); regmbc(0x13a); regmbc(0x13c);\n\t\t      regmbc(0x13e); regmbc(0x140); regmbc(0x142);\n\t\t      regmbc(0x19a); regmbc(0x1e37); regmbc(0x1e39);\n\t\t      regmbc(0x1e3b); regmbc(0x1e3d); regmbc(0x2c61);\n\t\t      return;\n\t    case 'm': case 0x1d6f: case 0x1e3f: case 0x1e41: case 0x1e43:\n\t\t      regmbc('m'); regmbc(0x1d6f); regmbc(0x1e3f);\n\t\t      regmbc(0x1e41); regmbc(0x1e43);\n\t\t      return;\n\t    case 'n': case 0xf1: case 0x144: case 0x146: case 0x148:\n\t    case 0x149: case 0x1f9: case 0x1d70: case 0x1d87:\n\t    case 0x1e45: case 0x1e47: case 0x1e49: case 0x1e4b:\n\t    case 0xa7a5:\n\t\t      regmbc('n'); regmbc(0xf1); regmbc(0x144);\n\t\t      regmbc(0x146); regmbc(0x148); regmbc(0x149);\n\t\t      regmbc(0x1f9); regmbc(0x1d70); regmbc(0x1d87);\n\t\t      regmbc(0x1e45); regmbc(0x1e47); regmbc(0x1e49);\n\t\t      regmbc(0x1e4b); regmbc(0xa7a5);\n\t\t      return;\n\t    case 'o': case 0xf2: case 0xf3: case 0xf4: case 0xf5:\n\t    case 0xf6: case 0xf8: case 0x14d: case 0x14f: case 0x151:\n\t    case 0x1a1: case 0x1d2: case 0x1eb: case 0x1ed: case 0x1ff:\n\t    case 0x20d: case 0x20f: case 0x22b: case 0x22d: case 0x22f:\n\t    case 0x231: case 0x275: case 0x1e4d: case 0x1e4f:\n\t    case 0x1e51: case 0x1e53: case 0x1ecd: case 0x1ecf:\n\t    case 0x1ed1: case 0x1ed3: case 0x1ed5: case 0x1ed7:\n\t    case 0x1ed9: case 0x1edb: case 0x1edd: case 0x1edf:\n\t    case 0x1ee1: case 0x1ee3:\n\t\t      regmbc('o'); regmbc(0xf2); regmbc(0xf3);\n\t\t      regmbc(0xf4); regmbc(0xf5); regmbc(0xf6);\n\t\t      regmbc(0xf8); regmbc(0x14d); regmbc(0x14f);\n\t\t      regmbc(0x151); regmbc(0x1a1); regmbc(0x1d2);\n\t\t      regmbc(0x1eb); regmbc(0x1ed); regmbc(0x1ff);\n\t\t      regmbc(0x20d); regmbc(0x20f); regmbc(0x22b);\n\t\t      regmbc(0x22d); regmbc(0x22f); regmbc(0x231);\n\t\t      regmbc(0x275); regmbc(0x1e4d); regmbc(0x1e4f);\n\t\t      regmbc(0x1e51); regmbc(0x1e53); regmbc(0x1ecd);\n\t\t      regmbc(0x1ecf); regmbc(0x1ed1); regmbc(0x1ed3);\n\t\t      regmbc(0x1ed5); regmbc(0x1ed7); regmbc(0x1ed9);\n\t\t      regmbc(0x1edb); regmbc(0x1edd); regmbc(0x1edf);\n\t\t      regmbc(0x1ee1); regmbc(0x1ee3);\n\t\t      return;\n\t    case 'p': case 0x1a5: case 0x1d71: case 0x1d88: case 0x1d7d:\n\t    case 0x1e55: case 0x1e57:\n\t\t      regmbc('p'); regmbc(0x1a5); regmbc(0x1d71);\n\t\t      regmbc(0x1d7d); regmbc(0x1d88); regmbc(0x1e55);\n\t\t      regmbc(0x1e57);\n\t\t      return;\n\t    case 'q': case 0x24b: case 0x2a0:\n\t\t      regmbc('q'); regmbc(0x24b); regmbc(0x2a0);\n\t\t      return;\n\t    case 'r': case 0x155: case 0x157: case 0x159: case 0x211:\n\t    case 0x213: case 0x24d: case 0x27d: case 0x1d72: case 0x1d73:\n\t    case 0x1d89: case 0x1e59: case 0x1e5b: case 0x1e5d: case 0x1e5f:\n\t    case 0xa7a7:\n\t\t      regmbc('r'); regmbc(0x155); regmbc(0x157);\n\t\t      regmbc(0x159); regmbc(0x211); regmbc(0x213);\n\t\t      regmbc(0x24d); regmbc(0x1d72); regmbc(0x1d73);\n\t\t      regmbc(0x1d89); regmbc(0x1e59); regmbc(0x27d);\n\t\t      regmbc(0x1e5b); regmbc(0x1e5d); regmbc(0x1e5f);\n\t\t      regmbc(0xa7a7);\n\t\t      return;\n\t    case 's': case 0x15b: case 0x15d: case 0x15f: case 0x161:\n\t    case 0x1e61: case 0x219: case 0x23f: case 0x1d74: case 0x1d8a:\n\t    case 0x1e63: case 0x1e65: case 0x1e67: case 0x1e69: case 0xa7a9:\n\t\t      regmbc('s'); regmbc(0x15b); regmbc(0x15d);\n\t\t      regmbc(0x15f); regmbc(0x161); regmbc(0x23f);\n\t\t      regmbc(0x219); regmbc(0x1d74); regmbc(0x1d8a);\n\t\t      regmbc(0x1e61); regmbc(0x1e63); regmbc(0x1e65);\n\t\t      regmbc(0x1e67); regmbc(0x1e69); regmbc(0xa7a9);\n\t\t      return;\n\t    case 't': case 0x163: case 0x165: case 0x167: case 0x1ab:\n\t    case 0x1ad: case 0x21b: case 0x288: case 0x1d75: case 0x1e6b:\n\t    case 0x1e6d: case 0x1e6f: case 0x1e71: case 0x1e97: case 0x2c66:\n\t\t      regmbc('t'); regmbc(0x163); regmbc(0x165);\n\t\t      regmbc(0x167); regmbc(0x1ab); regmbc(0x21b);\n\t\t      regmbc(0x1ad); regmbc(0x288); regmbc(0x1d75);\n\t\t      regmbc(0x1e6b); regmbc(0x1e6d); regmbc(0x1e6f);\n\t\t      regmbc(0x1e71); regmbc(0x1e97); regmbc(0x2c66);\n\t\t      return;\n\t    case 'u': case 0xf9: case 0xfa: case 0xfb: case 0xfc:\n\t    case 0x169: case 0x16b: case 0x16d: case 0x16f:\n\t    case 0x171: case 0x173: case 0x1b0: case 0x1d4:\n\t    case 0x1d6: case 0x1d8: case 0x1da: case 0x1dc:\n\t    case 0x215: case 0x217: case 0x289: case 0x1e73:\n\t    case 0x1d7e: case 0x1d99: case 0x1e75: case 0x1e77:\n\t    case 0x1e79: case 0x1e7b: case 0x1ee5: case 0x1ee7:\n\t    case 0x1ee9: case 0x1eeb: case 0x1eed: case 0x1eef:\n\t    case 0x1ef1:\n\t\t      regmbc('u'); regmbc(0xf9); regmbc(0xfa);\n\t\t      regmbc(0xfb); regmbc(0xfc); regmbc(0x169);\n\t\t      regmbc(0x16b); regmbc(0x16d); regmbc(0x16f);\n\t\t      regmbc(0x171); regmbc(0x173); regmbc(0x1d6);\n\t\t      regmbc(0x1d8); regmbc(0x1da); regmbc(0x1dc);\n\t\t      regmbc(0x215); regmbc(0x217); regmbc(0x1b0);\n\t\t      regmbc(0x1d4); regmbc(0x289); regmbc(0x1d7e);\n\t\t      regmbc(0x1d99); regmbc(0x1e73); regmbc(0x1e75);\n\t\t      regmbc(0x1e77); regmbc(0x1e79); regmbc(0x1e7b);\n\t\t      regmbc(0x1ee5); regmbc(0x1ee7); regmbc(0x1ee9);\n\t\t      regmbc(0x1eeb); regmbc(0x1eed); regmbc(0x1eef);\n\t\t      regmbc(0x1ef1);\n\t\t      return;\n\t    case 'v': case 0x28b: case 0x1d8c: case 0x1e7d: case 0x1e7f:\n\t\t      regmbc('v'); regmbc(0x28b); regmbc(0x1d8c);\n\t\t      regmbc(0x1e7d); regmbc(0x1e7f);\n\t\t      return;\n\t    case 'w': case 0x175: case 0x1e81: case 0x1e83:\n\t    case 0x1e85: case 0x1e87: case 0x1e89: case 0x1e98:\n\t\t      regmbc('w'); regmbc(0x175); regmbc(0x1e81);\n\t\t      regmbc(0x1e83); regmbc(0x1e85); regmbc(0x1e87);\n\t\t      regmbc(0x1e89); regmbc(0x1e98);\n\t\t      return;\n\t    case 'x': case 0x1e8b: case 0x1e8d:\n\t\t      regmbc('x'); regmbc(0x1e8b); regmbc(0x1e8d);\n\t\t      return;\n\t    case 'y': case 0xfd: case 0xff: case 0x177: case 0x1b4:\n\t    case 0x233: case 0x24f: case 0x1e8f: case 0x1e99: case 0x1ef3:\n\t    case 0x1ef5: case 0x1ef7: case 0x1ef9:\n\t\t      regmbc('y'); regmbc(0xfd); regmbc(0xff);\n\t\t      regmbc(0x177); regmbc(0x1b4); regmbc(0x233);\n\t\t      regmbc(0x24f); regmbc(0x1e8f); regmbc(0x1e99);\n\t\t      regmbc(0x1ef3); regmbc(0x1ef5); regmbc(0x1ef7);\n\t\t      regmbc(0x1ef9);\n\t\t      return;\n\t    case 'z': case 0x17a: case 0x17c: case 0x17e: case 0x1b6:\n\t    case 0x1d76: case 0x1d8e: case 0x1e91: case 0x1e93:\n\t    case 0x1e95: case 0x2c6c:\n\t\t      regmbc('z'); regmbc(0x17a); regmbc(0x17c);\n\t\t      regmbc(0x17e); regmbc(0x1b6); regmbc(0x1d76);\n\t\t      regmbc(0x1d8e); regmbc(0x1e91); regmbc(0x1e93);\n\t\t      regmbc(0x1e95); regmbc(0x2c6c);\n\t\t      return;\n\t}\n    }\n    regmbc(c);\n}\n\n/*\n * Emit a node.\n * Return pointer to generated code.\n */\n    static char_u *\nregnode(int op)\n{\n    char_u  *ret;\n\n    ret = regcode;\n    if (ret == JUST_CALC_SIZE)\n\tregsize += 3;\n    else\n    {\n\t*regcode++ = op;\n\t*regcode++ = NUL;\t\t// Null \"next\" pointer.\n\t*regcode++ = NUL;\n    }\n    return ret;\n}\n\n/*\n * Write a long as four bytes at \"p\" and return pointer to the next char.\n */\n    static char_u *\nre_put_long(char_u *p, long_u val)\n{\n    *p++ = (char_u) ((val >> 24) & 0377);\n    *p++ = (char_u) ((val >> 16) & 0377);\n    *p++ = (char_u) ((val >> 8) & 0377);\n    *p++ = (char_u) (val & 0377);\n    return p;\n}\n\n/*\n * regnext - dig the \"next\" pointer out of a node\n * Returns NULL when calculating size, when there is no next item and when\n * there is an error.\n */\n    static char_u *\nregnext(char_u *p)\n{\n    int\t    offset;\n\n    if (p == JUST_CALC_SIZE || reg_toolong)\n\treturn NULL;\n\n    offset = NEXT(p);\n    if (offset == 0)\n\treturn NULL;\n\n    if (OP(p) == BACK)\n\treturn p - offset;\n    else\n\treturn p + offset;\n}\n\n/*\n * Set the next-pointer at the end of a node chain.\n */\n    static void\nregtail(char_u *p, char_u *val)\n{\n    char_u\t*scan;\n    char_u\t*temp;\n    int\t\toffset;\n\n    if (p == JUST_CALC_SIZE)\n\treturn;\n\n    // Find last node.\n    scan = p;\n    for (;;)\n    {\n\ttemp = regnext(scan);\n\tif (temp == NULL)\n\t    break;\n\tscan = temp;\n    }\n\n    if (OP(scan) == BACK)\n\toffset = (int)(scan - val);\n    else\n\toffset = (int)(val - scan);\n    // When the offset uses more than 16 bits it can no longer fit in the two\n    // bytes available.  Use a global flag to avoid having to check return\n    // values in too many places.\n    if (offset > 0xffff)\n\treg_toolong = TRUE;\n    else\n    {\n\t*(scan + 1) = (char_u) (((unsigned)offset >> 8) & 0377);\n\t*(scan + 2) = (char_u) (offset & 0377);\n    }\n}\n\n/*\n * Like regtail, on item after a BRANCH; nop if none.\n */\n    static void\nregoptail(char_u *p, char_u *val)\n{\n    // When op is neither BRANCH nor BRACE_COMPLEX0-9, it is \"operandless\"\n    if (p == NULL || p == JUST_CALC_SIZE\n\t    || (OP(p) != BRANCH\n\t\t&& (OP(p) < BRACE_COMPLEX || OP(p) > BRACE_COMPLEX + 9)))\n\treturn;\n    regtail(OPERAND(p), val);\n}\n\n/*\n * Insert an operator in front of already-emitted operand\n *\n * Means relocating the operand.\n */\n    static void\nreginsert(int op, char_u *opnd)\n{\n    char_u\t*src;\n    char_u\t*dst;\n    char_u\t*place;\n\n    if (regcode == JUST_CALC_SIZE)\n    {\n\tregsize += 3;\n\treturn;\n    }\n    src = regcode;\n    regcode += 3;\n    dst = regcode;\n    while (src > opnd)\n\t*--dst = *--src;\n\n    place = opnd;\t\t// Op node, where operand used to be.\n    *place++ = op;\n    *place++ = NUL;\n    *place = NUL;\n}\n\n/*\n * Insert an operator in front of already-emitted operand.\n * Add a number to the operator.\n */\n    static void\nreginsert_nr(int op, long val, char_u *opnd)\n{\n    char_u\t*src;\n    char_u\t*dst;\n    char_u\t*place;\n\n    if (regcode == JUST_CALC_SIZE)\n    {\n\tregsize += 7;\n\treturn;\n    }\n    src = regcode;\n    regcode += 7;\n    dst = regcode;\n    while (src > opnd)\n\t*--dst = *--src;\n\n    place = opnd;\t\t// Op node, where operand used to be.\n    *place++ = op;\n    *place++ = NUL;\n    *place++ = NUL;\n    re_put_long(place, (long_u)val);\n}\n\n/*\n * Insert an operator in front of already-emitted operand.\n * The operator has the given limit values as operands.  Also set next pointer.\n *\n * Means relocating the operand.\n */\n    static void\nreginsert_limits(\n    int\t\top,\n    long\tminval,\n    long\tmaxval,\n    char_u\t*opnd)\n{\n    char_u\t*src;\n    char_u\t*dst;\n    char_u\t*place;\n\n    if (regcode == JUST_CALC_SIZE)\n    {\n\tregsize += 11;\n\treturn;\n    }\n    src = regcode;\n    regcode += 11;\n    dst = regcode;\n    while (src > opnd)\n\t*--dst = *--src;\n\n    place = opnd;\t\t// Op node, where operand used to be.\n    *place++ = op;\n    *place++ = NUL;\n    *place++ = NUL;\n    place = re_put_long(place, (long_u)minval);\n    place = re_put_long(place, (long_u)maxval);\n    regtail(opnd, place);\n}\n\n/*\n * Return TRUE if the back reference is legal. We must have seen the close\n * brace.\n * TODO: Should also check that we don't refer to something that is repeated\n * (+*=): what instance of the repetition should we match?\n */\n    static int\nseen_endbrace(int refnum)\n{\n    if (!had_endbrace[refnum])\n    {\n\tchar_u *p;\n\n\t// Trick: check if \"@<=\" or \"@<!\" follows, in which case\n\t// the \\1 can appear before the referenced match.\n\tfor (p = regparse; *p != NUL; ++p)\n\t    if (p[0] == '@' && p[1] == '<' && (p[2] == '!' || p[2] == '='))\n\t\tbreak;\n\tif (*p == NUL)\n\t{\n\t    emsg(_(e_illegal_back_reference));\n\t    rc_did_emsg = TRUE;\n\t    return FALSE;\n\t}\n    }\n    return TRUE;\n}\n\n/*\n * Parse the lowest level.\n *\n * Optimization:  gobbles an entire sequence of ordinary characters so that\n * it can turn them into a single node, which is smaller to store and\n * faster to run.  Don't do this when one_exactly is set.\n */\n    static char_u *\nregatom(int *flagp)\n{\n    char_u\t    *ret;\n    int\t\t    flags;\n    int\t\t    c;\n    char_u\t    *p;\n    int\t\t    extra = 0;\n    int\t\t    save_prev_at_start = prev_at_start;\n\n    *flagp = WORST;\t\t// Tentatively.\n\n    c = getchr();\n    switch (c)\n    {\n      case Magic('^'):\n\tret = regnode(BOL);\n\tbreak;\n\n      case Magic('$'):\n\tret = regnode(EOL);\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n\thad_eol = TRUE;\n#endif\n\tbreak;\n\n      case Magic('<'):\n\tret = regnode(BOW);\n\tbreak;\n\n      case Magic('>'):\n\tret = regnode(EOW);\n\tbreak;\n\n      case Magic('_'):\n\tc = no_Magic(getchr());\n\tif (c == '^')\t\t// \"\\_^\" is start-of-line\n\t{\n\t    ret = regnode(BOL);\n\t    break;\n\t}\n\tif (c == '$')\t\t// \"\\_$\" is end-of-line\n\t{\n\t    ret = regnode(EOL);\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n\t    had_eol = TRUE;\n#endif\n\t    break;\n\t}\n\n\textra = ADD_NL;\n\t*flagp |= HASNL;\n\n\t// \"\\_[\" is character range plus newline\n\tif (c == '[')\n\t    goto collection;\n\n\t// \"\\_x\" is character class plus newline\n\t// FALLTHROUGH\n\n\t// Character classes.\n      case Magic('.'):\n      case Magic('i'):\n      case Magic('I'):\n      case Magic('k'):\n      case Magic('K'):\n      case Magic('f'):\n      case Magic('F'):\n      case Magic('p'):\n      case Magic('P'):\n      case Magic('s'):\n      case Magic('S'):\n      case Magic('d'):\n      case Magic('D'):\n      case Magic('x'):\n      case Magic('X'):\n      case Magic('o'):\n      case Magic('O'):\n      case Magic('w'):\n      case Magic('W'):\n      case Magic('h'):\n      case Magic('H'):\n      case Magic('a'):\n      case Magic('A'):\n      case Magic('l'):\n      case Magic('L'):\n      case Magic('u'):\n      case Magic('U'):\n\tp = vim_strchr(classchars, no_Magic(c));\n\tif (p == NULL)\n\t    EMSG_RET_NULL(_(e_invalid_use_of_underscore));\n\n\t// When '.' is followed by a composing char ignore the dot, so that\n\t// the composing char is matched here.\n\tif (enc_utf8 && c == Magic('.') && utf_iscomposing(peekchr()))\n\t{\n\t    c = getchr();\n\t    goto do_multibyte;\n\t}\n\tret = regnode(classcodes[p - classchars] + extra);\n\t*flagp |= HASWIDTH | SIMPLE;\n\tbreak;\n\n      case Magic('n'):\n\tif (reg_string)\n\t{\n\t    // In a string \"\\n\" matches a newline character.\n\t    ret = regnode(EXACTLY);\n\t    regc(NL);\n\t    regc(NUL);\n\t    *flagp |= HASWIDTH | SIMPLE;\n\t}\n\telse\n\t{\n\t    // In buffer text \"\\n\" matches the end of a line.\n\t    ret = regnode(NEWL);\n\t    *flagp |= HASWIDTH | HASNL;\n\t}\n\tbreak;\n\n      case Magic('('):\n\tif (one_exactly)\n\t    EMSG_ONE_RET_NULL;\n\tret = reg(REG_PAREN, &flags);\n\tif (ret == NULL)\n\t    return NULL;\n\t*flagp |= flags & (HASWIDTH | SPSTART | HASNL | HASLOOKBH);\n\tbreak;\n\n      case NUL:\n      case Magic('|'):\n      case Magic('&'):\n      case Magic(')'):\n\tif (one_exactly)\n\t    EMSG_ONE_RET_NULL;\n\t// Supposed to be caught earlier.\n\tIEMSG_RET_NULL(_(e_internal_error_in_regexp));\n\t// NOTREACHED\n\n      case Magic('='):\n      case Magic('?'):\n      case Magic('+'):\n      case Magic('@'):\n      case Magic('{'):\n      case Magic('*'):\n\tc = no_Magic(c);\n\tEMSG3_RET_NULL(_(e_str_chr_follows_nothing),\n\t\t(c == '*' ? reg_magic >= MAGIC_ON : reg_magic == MAGIC_ALL), c);\n\t// NOTREACHED\n\n      case Magic('~'):\t\t// previous substitute pattern\n\t    if (reg_prev_sub != NULL)\n\t    {\n\t\tchar_u\t    *lp;\n\n\t\tret = regnode(EXACTLY);\n\t\tlp = reg_prev_sub;\n\t\twhile (*lp != NUL)\n\t\t    regc(*lp++);\n\t\tregc(NUL);\n\t\tif (*reg_prev_sub != NUL)\n\t\t{\n\t\t    *flagp |= HASWIDTH;\n\t\t    if ((lp - reg_prev_sub) == 1)\n\t\t\t*flagp |= SIMPLE;\n\t\t}\n\t    }\n\t    else\n\t\tEMSG_RET_NULL(_(e_no_previous_substitute_regular_expression));\n\t    break;\n\n      case Magic('1'):\n      case Magic('2'):\n      case Magic('3'):\n      case Magic('4'):\n      case Magic('5'):\n      case Magic('6'):\n      case Magic('7'):\n      case Magic('8'):\n      case Magic('9'):\n\t    {\n\t\tint\t\t    refnum;\n\n\t\trefnum = c - Magic('0');\n\t\tif (!seen_endbrace(refnum))\n\t\t    return NULL;\n\t\tret = regnode(BACKREF + refnum);\n\t    }\n\t    break;\n\n      case Magic('z'):\n\t{\n\t    c = no_Magic(getchr());\n\t    switch (c)\n\t    {\n#ifdef FEAT_SYN_HL\n\t\tcase '(': if ((reg_do_extmatch & REX_SET) == 0)\n\t\t\t      EMSG_RET_NULL(_(e_z_not_allowed_here));\n\t\t\t  if (one_exactly)\n\t\t\t      EMSG_ONE_RET_NULL;\n\t\t\t  ret = reg(REG_ZPAREN, &flags);\n\t\t\t  if (ret == NULL)\n\t\t\t      return NULL;\n\t\t\t  *flagp |= flags & (HASWIDTH|SPSTART|HASNL|HASLOOKBH);\n\t\t\t  re_has_z = REX_SET;\n\t\t\t  break;\n\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9': if ((reg_do_extmatch & REX_USE) == 0)\n\t\t\t      EMSG_RET_NULL(_(e_z1_z9_not_allowed_here));\n\t\t\t  ret = regnode(ZREF + c - '0');\n\t\t\t  re_has_z = REX_USE;\n\t\t\t  break;\n#endif\n\n\t\tcase 's': ret = regnode(MOPEN + 0);\n\t\t\t  if (re_mult_next(\"\\\\zs\") == FAIL)\n\t\t\t      return NULL;\n\t\t\t  break;\n\n\t\tcase 'e': ret = regnode(MCLOSE + 0);\n\t\t\t  if (re_mult_next(\"\\\\ze\") == FAIL)\n\t\t\t      return NULL;\n\t\t\t  break;\n\n\t\tdefault:  EMSG_RET_NULL(_(e_invalid_character_after_bsl_z));\n\t    }\n\t}\n\tbreak;\n\n      case Magic('%'):\n\t{\n\t    c = no_Magic(getchr());\n\t    switch (c)\n\t    {\n\t\t// () without a back reference\n\t\tcase '(':\n\t\t    if (one_exactly)\n\t\t\tEMSG_ONE_RET_NULL;\n\t\t    ret = reg(REG_NPAREN, &flags);\n\t\t    if (ret == NULL)\n\t\t\treturn NULL;\n\t\t    *flagp |= flags & (HASWIDTH | SPSTART | HASNL | HASLOOKBH);\n\t\t    break;\n\n\t\t// Catch \\%^ and \\%$ regardless of where they appear in the\n\t\t// pattern -- regardless of whether or not it makes sense.\n\t\tcase '^':\n\t\t    ret = regnode(RE_BOF);\n\t\t    break;\n\n\t\tcase '$':\n\t\t    ret = regnode(RE_EOF);\n\t\t    break;\n\n\t\tcase '#':\n\t\t    ret = regnode(CURSOR);\n\t\t    break;\n\n\t\tcase 'V':\n\t\t    ret = regnode(RE_VISUAL);\n\t\t    break;\n\n\t\tcase 'C':\n\t\t    ret = regnode(RE_COMPOSING);\n\t\t    break;\n\n\t\t// \\%[abc]: Emit as a list of branches, all ending at the last\n\t\t// branch which matches nothing.\n\t\tcase '[':\n\t\t\t  if (one_exactly)\t// doesn't nest\n\t\t\t      EMSG_ONE_RET_NULL;\n\t\t\t  {\n\t\t\t      char_u\t*lastbranch;\n\t\t\t      char_u\t*lastnode = NULL;\n\t\t\t      char_u\t*br;\n\n\t\t\t      ret = NULL;\n\t\t\t      while ((c = getchr()) != ']')\n\t\t\t      {\n\t\t\t\t  if (c == NUL)\n\t\t\t\t      EMSG2_RET_NULL(_(e_missing_sb_after_str),\n\t\t\t\t\t\t      reg_magic == MAGIC_ALL);\n\t\t\t\t  br = regnode(BRANCH);\n\t\t\t\t  if (ret == NULL)\n\t\t\t\t      ret = br;\n\t\t\t\t  else\n\t\t\t\t  {\n\t\t\t\t      regtail(lastnode, br);\n\t\t\t\t      if (reg_toolong)\n\t\t\t\t\t  return NULL;\n\t\t\t\t  }\n\n\t\t\t\t  ungetchr();\n\t\t\t\t  one_exactly = TRUE;\n\t\t\t\t  lastnode = regatom(flagp);\n\t\t\t\t  one_exactly = FALSE;\n\t\t\t\t  if (lastnode == NULL)\n\t\t\t\t      return NULL;\n\t\t\t      }\n\t\t\t      if (ret == NULL)\n\t\t\t\t  EMSG2_RET_NULL(_(e_empty_str_brackets),\n\t\t\t\t\t\t      reg_magic == MAGIC_ALL);\n\t\t\t      lastbranch = regnode(BRANCH);\n\t\t\t      br = regnode(NOTHING);\n\t\t\t      if (ret != JUST_CALC_SIZE)\n\t\t\t      {\n\t\t\t\t  regtail(lastnode, br);\n\t\t\t\t  regtail(lastbranch, br);\n\t\t\t\t  // connect all branches to the NOTHING\n\t\t\t\t  // branch at the end\n\t\t\t\t  for (br = ret; br != lastnode; )\n\t\t\t\t  {\n\t\t\t\t      if (OP(br) == BRANCH)\n\t\t\t\t      {\n\t\t\t\t\t  regtail(br, lastbranch);\n\t\t\t\t\t  if (reg_toolong)\n\t\t\t\t\t      return NULL;\n\t\t\t\t\t  br = OPERAND(br);\n\t\t\t\t      }\n\t\t\t\t      else\n\t\t\t\t\t  br = regnext(br);\n\t\t\t\t  }\n\t\t\t      }\n\t\t\t      *flagp &= ~(HASWIDTH | SIMPLE);\n\t\t\t      break;\n\t\t\t  }\n\n\t\tcase 'd':   // %d123 decimal\n\t\tcase 'o':   // %o123 octal\n\t\tcase 'x':   // %xab hex 2\n\t\tcase 'u':   // %uabcd hex 4\n\t\tcase 'U':   // %U1234abcd hex 8\n\t\t\t  {\n\t\t\t      long i;\n\n\t\t\t      switch (c)\n\t\t\t      {\n\t\t\t\t  case 'd': i = getdecchrs(); break;\n\t\t\t\t  case 'o': i = getoctchrs(); break;\n\t\t\t\t  case 'x': i = gethexchrs(2); break;\n\t\t\t\t  case 'u': i = gethexchrs(4); break;\n\t\t\t\t  case 'U': i = gethexchrs(8); break;\n\t\t\t\t  default:  i = -1; break;\n\t\t\t      }\n\n\t\t\t      if (i < 0 || i > INT_MAX)\n\t\t\t\t  EMSG2_RET_NULL(\n\t\t\t\t\t    _(e_invalid_character_after_str_2),\n\t\t\t\t\t\t       reg_magic == MAGIC_ALL);\n\t\t\t      if (use_multibytecode(i))\n\t\t\t\t  ret = regnode(MULTIBYTECODE);\n\t\t\t      else\n\t\t\t\t  ret = regnode(EXACTLY);\n\t\t\t      if (i == 0)\n\t\t\t\t  regc(0x0a);\n\t\t\t      else\n\t\t\t\t  regmbc(i);\n\t\t\t      regc(NUL);\n\t\t\t      *flagp |= HASWIDTH;\n\t\t\t      break;\n\t\t\t  }\n\n\t\tdefault:\n\t\t\t  if (VIM_ISDIGIT(c) || c == '<' || c == '>'\n\t\t\t\t\t\t|| c == '\\'' || c == '.')\n\t\t\t  {\n\t\t\t      long_u\tn = 0;\n\t\t\t      int\tcmp;\n\t\t\t      int\tcur = FALSE;\n\n\t\t\t      cmp = c;\n\t\t\t      if (cmp == '<' || cmp == '>')\n\t\t\t\t  c = getchr();\n\t\t\t      if (no_Magic(c) == '.')\n\t\t\t      {\n\t\t\t\t  cur = TRUE;\n\t\t\t\t  c = getchr();\n\t\t\t      }\n\t\t\t      while (VIM_ISDIGIT(c))\n\t\t\t      {\n\t\t\t\t  n = n * 10 + (c - '0');\n\t\t\t\t  c = getchr();\n\t\t\t      }\n\t\t\t      if (c == '\\'' && n == 0)\n\t\t\t      {\n\t\t\t\t  // \"\\%'m\", \"\\%<'m\" and \"\\%>'m\": Mark\n\t\t\t\t  c = getchr();\n\t\t\t\t  ret = regnode(RE_MARK);\n\t\t\t\t  if (ret == JUST_CALC_SIZE)\n\t\t\t\t      regsize += 2;\n\t\t\t\t  else\n\t\t\t\t  {\n\t\t\t\t      *regcode++ = c;\n\t\t\t\t      *regcode++ = cmp;\n\t\t\t\t  }\n\t\t\t\t  break;\n\t\t\t      }\n\t\t\t      else if (c == 'l' || c == 'c' || c == 'v')\n\t\t\t      {\n\t\t\t\t  if (cur && n)\n\t\t\t\t  {\n\t\t\t\t    semsg(_(e_regexp_number_after_dot_pos_search), no_Magic(c));\n\t\t\t\t    rc_did_emsg = TRUE;\n\t\t\t\t    return NULL;\n\t\t\t\t  }\n\t\t\t\t  if (c == 'l')\n\t\t\t\t  {\n\t\t\t\t      if (cur)\n\t\t\t\t\t  n = curwin->w_cursor.lnum;\n\t\t\t\t      ret = regnode(RE_LNUM);\n\t\t\t\t      if (save_prev_at_start)\n\t\t\t\t\t  at_start = TRUE;\n\t\t\t\t  }\n\t\t\t\t  else if (c == 'c')\n\t\t\t\t  {\n\t\t\t\t      if (cur)\n\t\t\t\t      {\n\t\t\t\t\t  n = curwin->w_cursor.col;\n\t\t\t\t\t  n++;\n\t\t\t\t      }\n\t\t\t\t      ret = regnode(RE_COL);\n\t\t\t\t  }\n\t\t\t\t  else\n\t\t\t\t  {\n\t\t\t\t      if (cur)\n\t\t\t\t      {\n\t\t\t\t\t  colnr_T vcol = 0;\n\n\t\t\t\t\t  getvvcol(curwin, &curwin->w_cursor,\n\t\t\t\t\t\t\t    NULL, NULL, &vcol);\n\t\t\t\t\t  ++vcol;\n\t\t\t\t\t  n = vcol;\n\t\t\t\t      }\n\t\t\t\t      ret = regnode(RE_VCOL);\n\t\t\t\t  }\n\t\t\t\t  if (ret == JUST_CALC_SIZE)\n\t\t\t\t      regsize += 5;\n\t\t\t\t  else\n\t\t\t\t  {\n\t\t\t\t      // put the number and the optional\n\t\t\t\t      // comparator after the opcode\n\t\t\t\t      regcode = re_put_long(regcode, n);\n\t\t\t\t      *regcode++ = cmp;\n\t\t\t\t  }\n\t\t\t\t  break;\n\t\t\t      }\n\t\t\t  }\n\n\t\t\t  EMSG2_RET_NULL(_(e_invalid_character_after_str),\n\t\t\t\t\t\t      reg_magic == MAGIC_ALL);\n\t    }\n\t}\n\tbreak;\n\n      case Magic('['):\ncollection:\n\t{\n\t    char_u\t*lp;\n\n\t    // If there is no matching ']', we assume the '[' is a normal\n\t    // character.  This makes 'incsearch' and \":help [\" work.\n\t    lp = skip_anyof(regparse);\n\t    if (*lp == ']')\t// there is a matching ']'\n\t    {\n\t\tint\tstartc = -1;\t// > 0 when next '-' is a range\n\t\tint\tendc;\n\n\t\t// In a character class, different parsing rules apply.\n\t\t// Not even \\ is special anymore, nothing is.\n\t\tif (*regparse == '^')\t    // Complement of range.\n\t\t{\n\t\t    ret = regnode(ANYBUT + extra);\n\t\t    regparse++;\n\t\t}\n\t\telse\n\t\t    ret = regnode(ANYOF + extra);\n\n\t\t// At the start ']' and '-' mean the literal character.\n\t\tif (*regparse == ']' || *regparse == '-')\n\t\t{\n\t\t    startc = *regparse;\n\t\t    regc(*regparse++);\n\t\t}\n\n\t\twhile (*regparse != NUL && *regparse != ']')\n\t\t{\n\t\t    if (*regparse == '-')\n\t\t    {\n\t\t\t++regparse;\n\t\t\t// The '-' is not used for a range at the end and\n\t\t\t// after or before a '\\n'.\n\t\t\tif (*regparse == ']' || *regparse == NUL\n\t\t\t\t|| startc == -1\n\t\t\t\t|| (regparse[0] == '\\\\' && regparse[1] == 'n'))\n\t\t\t{\n\t\t\t    regc('-');\n\t\t\t    startc = '-';\t// [--x] is a range\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Also accept \"a-[.z.]\"\n\t\t\t    endc = 0;\n\t\t\t    if (*regparse == '[')\n\t\t\t\tendc = get_coll_element(&regparse);\n\t\t\t    if (endc == 0)\n\t\t\t    {\n\t\t\t\tif (has_mbyte)\n\t\t\t\t    endc = mb_ptr2char_adv(&regparse);\n\t\t\t\telse\n\t\t\t\t    endc = *regparse++;\n\t\t\t    }\n\n\t\t\t    // Handle \\o40, \\x20 and \\u20AC style sequences\n\t\t\t    if (endc == '\\\\' && !reg_cpo_lit && !reg_cpo_bsl)\n\t\t\t\tendc = coll_get_char();\n\n\t\t\t    if (startc > endc)\n\t\t\t\tEMSG_RET_NULL(_(e_reverse_range_in_character_class));\n\t\t\t    if (has_mbyte && ((*mb_char2len)(startc) > 1\n\t\t\t\t\t\t || (*mb_char2len)(endc) > 1))\n\t\t\t    {\n\t\t\t\t// Limit to a range of 256 chars.\n\t\t\t\tif (endc > startc + 256)\n\t\t\t\t    EMSG_RET_NULL(_(e_range_too_large_in_character_class));\n\t\t\t\twhile (++startc <= endc)\n\t\t\t\t    regmbc(startc);\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\twhile (++startc <= endc)\n\t\t\t\t    regc(startc);\n\t\t\t    }\n\t\t\t    startc = -1;\n\t\t\t}\n\t\t    }\n\t\t    // Only \"\\]\", \"\\^\", \"\\]\" and \"\\\\\" are special in Vi.  Vim\n\t\t    // accepts \"\\t\", \"\\e\", etc., but only when the 'l' flag in\n\t\t    // 'cpoptions' is not included.\n\t\t    // Posix doesn't recognize backslash at all.\n\t\t    else if (*regparse == '\\\\'\n\t\t\t    && !reg_cpo_bsl\n\t\t\t    && (vim_strchr(REGEXP_INRANGE, regparse[1]) != NULL\n\t\t\t\t|| (!reg_cpo_lit\n\t\t\t\t    && vim_strchr(REGEXP_ABBR,\n\t\t\t\t\t\t       regparse[1]) != NULL)))\n\t\t    {\n\t\t\tregparse++;\n\t\t\tif (*regparse == 'n')\n\t\t\t{\n\t\t\t    // '\\n' in range: also match NL\n\t\t\t    if (ret != JUST_CALC_SIZE)\n\t\t\t    {\n\t\t\t\t// Using \\n inside [^] does not change what\n\t\t\t\t// matches. \"[^\\n]\" is the same as \".\".\n\t\t\t\tif (*ret == ANYOF)\n\t\t\t\t{\n\t\t\t\t    *ret = ANYOF + ADD_NL;\n\t\t\t\t    *flagp |= HASNL;\n\t\t\t\t}\n\t\t\t\t// else: must have had a \\n already\n\t\t\t    }\n\t\t\t    regparse++;\n\t\t\t    startc = -1;\n\t\t\t}\n\t\t\telse if (*regparse == 'd'\n\t\t\t\t|| *regparse == 'o'\n\t\t\t\t|| *regparse == 'x'\n\t\t\t\t|| *regparse == 'u'\n\t\t\t\t|| *regparse == 'U')\n\t\t\t{\n\t\t\t    startc = coll_get_char();\n\t\t\t    if (startc == 0)\n\t\t\t\tregc(0x0a);\n\t\t\t    else\n\t\t\t\tregmbc(startc);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    startc = backslash_trans(*regparse++);\n\t\t\t    regc(startc);\n\t\t\t}\n\t\t    }\n\t\t    else if (*regparse == '[')\n\t\t    {\n\t\t\tint c_class;\n\t\t\tint cu;\n\n\t\t\tc_class = get_char_class(&regparse);\n\t\t\tstartc = -1;\n\t\t\t// Characters assumed to be 8 bits!\n\t\t\tswitch (c_class)\n\t\t\t{\n\t\t\t    case CLASS_NONE:\n\t\t\t\tc_class = get_equi_class(&regparse);\n\t\t\t\tif (c_class != 0)\n\t\t\t\t{\n\t\t\t\t    // produce equivalence class\n\t\t\t\t    reg_equi_class(c_class);\n\t\t\t\t}\n\t\t\t\telse if ((c_class =\n\t\t\t\t\t    get_coll_element(&regparse)) != 0)\n\t\t\t\t{\n\t\t\t\t    // produce a collating element\n\t\t\t\t    regmbc(c_class);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    // literal '[', allow [[-x] as a range\n\t\t\t\t    startc = *regparse++;\n\t\t\t\t    regc(startc);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t    case CLASS_ALNUM:\n\t\t\t\tfor (cu = 1; cu < 128; cu++)\n\t\t\t\t    if (isalnum(cu))\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t    case CLASS_ALPHA:\n\t\t\t\tfor (cu = 1; cu < 128; cu++)\n\t\t\t\t    if (isalpha(cu))\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t    case CLASS_BLANK:\n\t\t\t\tregc(' ');\n\t\t\t\tregc('\\t');\n\t\t\t\tbreak;\n\t\t\t    case CLASS_CNTRL:\n\t\t\t\tfor (cu = 1; cu <= 127; cu++)\n\t\t\t\t    if (iscntrl(cu))\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t    case CLASS_DIGIT:\n\t\t\t\tfor (cu = 1; cu <= 127; cu++)\n\t\t\t\t    if (VIM_ISDIGIT(cu))\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t    case CLASS_GRAPH:\n\t\t\t\tfor (cu = 1; cu <= 127; cu++)\n\t\t\t\t    if (isgraph(cu))\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t    case CLASS_LOWER:\n\t\t\t\tfor (cu = 1; cu <= 255; cu++)\n\t\t\t\t    if (MB_ISLOWER(cu) && cu != 170\n\t\t\t\t\t\t\t\t && cu != 186)\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t    case CLASS_PRINT:\n\t\t\t\tfor (cu = 1; cu <= 255; cu++)\n\t\t\t\t    if (vim_isprintc(cu))\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t    case CLASS_PUNCT:\n\t\t\t\tfor (cu = 1; cu < 128; cu++)\n\t\t\t\t    if (ispunct(cu))\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t    case CLASS_SPACE:\n\t\t\t\tfor (cu = 9; cu <= 13; cu++)\n\t\t\t\t    regc(cu);\n\t\t\t\tregc(' ');\n\t\t\t\tbreak;\n\t\t\t    case CLASS_UPPER:\n\t\t\t\tfor (cu = 1; cu <= 255; cu++)\n\t\t\t\t    if (MB_ISUPPER(cu))\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t    case CLASS_XDIGIT:\n\t\t\t\tfor (cu = 1; cu <= 255; cu++)\n\t\t\t\t    if (vim_isxdigit(cu))\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t    case CLASS_TAB:\n\t\t\t\tregc('\\t');\n\t\t\t\tbreak;\n\t\t\t    case CLASS_RETURN:\n\t\t\t\tregc('\\r');\n\t\t\t\tbreak;\n\t\t\t    case CLASS_BACKSPACE:\n\t\t\t\tregc('\\b');\n\t\t\t\tbreak;\n\t\t\t    case CLASS_ESCAPE:\n\t\t\t\tregc('\\033');\n\t\t\t\tbreak;\n\t\t\t    case CLASS_IDENT:\n\t\t\t\tfor (cu = 1; cu <= 255; cu++)\n\t\t\t\t    if (vim_isIDc(cu))\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t    case CLASS_KEYWORD:\n\t\t\t\tfor (cu = 1; cu <= 255; cu++)\n\t\t\t\t    if (reg_iswordc(cu))\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t    case CLASS_FNAME:\n\t\t\t\tfor (cu = 1; cu <= 255; cu++)\n\t\t\t\t    if (vim_isfilec(cu))\n\t\t\t\t\tregmbc(cu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t{\n\t\t\t    int\tlen;\n\n\t\t\t    // produce a multibyte character, including any\n\t\t\t    // following composing characters\n\t\t\t    startc = mb_ptr2char(regparse);\n\t\t\t    len = (*mb_ptr2len)(regparse);\n\t\t\t    if (enc_utf8 && utf_char2len(startc) != len)\n\t\t\t\tstartc = -1;\t// composing chars\n\t\t\t    while (--len >= 0)\n\t\t\t\tregc(*regparse++);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    startc = *regparse++;\n\t\t\t    regc(startc);\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tregc(NUL);\n\t\tprevchr_len = 1;\t// last char was the ']'\n\t\tif (*regparse != ']')\n\t\t    EMSG_RET_NULL(_(e_too_many_brackets));  // Cannot happen?\n\t\tskipchr();\t    // let's be friends with the lexer again\n\t\t*flagp |= HASWIDTH | SIMPLE;\n\t\tbreak;\n\t    }\n\t    else if (reg_strict)\n\t\tEMSG2_RET_NULL(_(e_missing_rsb_after_str_lsb),\n\t\t\t\t\t\t\treg_magic > MAGIC_OFF);\n\t}\n\t// FALLTHROUGH\n\n      default:\n\t{\n\t    int\t\tlen;\n\n\t    // A multi-byte character is handled as a separate atom if it's\n\t    // before a multi and when it's a composing char.\n\t    if (use_multibytecode(c))\n\t    {\ndo_multibyte:\n\t\tret = regnode(MULTIBYTECODE);\n\t\tregmbc(c);\n\t\t*flagp |= HASWIDTH | SIMPLE;\n\t\tbreak;\n\t    }\n\n\t    ret = regnode(EXACTLY);\n\n\t    // Append characters as long as:\n\t    // - there is no following multi, we then need the character in\n\t    //   front of it as a single character operand\n\t    // - not running into a Magic character\n\t    // - \"one_exactly\" is not set\n\t    // But always emit at least one character.  Might be a Multi,\n\t    // e.g., a \"[\" without matching \"]\".\n\t    for (len = 0; c != NUL && (len == 0\n\t\t\t|| (re_multi_type(peekchr()) == NOT_MULTI\n\t\t\t    && !one_exactly\n\t\t\t    && !is_Magic(c))); ++len)\n\t    {\n\t\tc = no_Magic(c);\n\t\tif (has_mbyte)\n\t\t{\n\t\t    regmbc(c);\n\t\t    if (enc_utf8)\n\t\t    {\n\t\t\tint\tl;\n\n\t\t\t// Need to get composing character too.\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t    l = utf_ptr2len(regparse);\n\t\t\t    if (!UTF_COMPOSINGLIKE(regparse, regparse + l))\n\t\t\t\tbreak;\n\t\t\t    regmbc(utf_ptr2char(regparse));\n\t\t\t    skipchr();\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    regc(c);\n\t\tc = getchr();\n\t    }\n\t    ungetchr();\n\n\t    regc(NUL);\n\t    *flagp |= HASWIDTH;\n\t    if (len == 1)\n\t\t*flagp |= SIMPLE;\n\t}\n\tbreak;\n    }\n\n    return ret;\n}\n\n/*\n * Parse something followed by possible [*+=].\n *\n * Note that the branching code sequences used for = and the general cases\n * of * and + are somewhat optimized:  they use the same NOTHING node as\n * both the endmarker for their branch list and the body of the last branch.\n * It might seem that this node could be dispensed with entirely, but the\n * endmarker role is not redundant.\n */\n    static char_u *\nregpiece(int *flagp)\n{\n    char_u\t    *ret;\n    int\t\t    op;\n    char_u\t    *next;\n    int\t\t    flags;\n    long\t    minval;\n    long\t    maxval;\n\n    ret = regatom(&flags);\n    if (ret == NULL)\n\treturn NULL;\n\n    op = peekchr();\n    if (re_multi_type(op) == NOT_MULTI)\n    {\n\t*flagp = flags;\n\treturn ret;\n    }\n    // default flags\n    *flagp = (WORST | SPSTART | (flags & (HASNL | HASLOOKBH)));\n\n    skipchr();\n    switch (op)\n    {\n\tcase Magic('*'):\n\t    if (flags & SIMPLE)\n\t\treginsert(STAR, ret);\n\t    else\n\t    {\n\t\t// Emit x* as (x&|), where & means \"self\".\n\t\treginsert(BRANCH, ret); // Either x\n\t\tregoptail(ret, regnode(BACK));\t// and loop\n\t\tregoptail(ret, ret);\t// back\n\t\tregtail(ret, regnode(BRANCH));\t// or\n\t\tregtail(ret, regnode(NOTHING)); // null.\n\t    }\n\t    break;\n\n\tcase Magic('+'):\n\t    if (flags & SIMPLE)\n\t\treginsert(PLUS, ret);\n\t    else\n\t    {\n\t\t// Emit x+ as x(&|), where & means \"self\".\n\t\tnext = regnode(BRANCH); // Either\n\t\tregtail(ret, next);\n\t\tregtail(regnode(BACK), ret);\t// loop back\n\t\tregtail(next, regnode(BRANCH)); // or\n\t\tregtail(ret, regnode(NOTHING)); // null.\n\t    }\n\t    *flagp = (WORST | HASWIDTH | (flags & (HASNL | HASLOOKBH)));\n\t    break;\n\n\tcase Magic('@'):\n\t    {\n\t\tint\tlop = END;\n\t\tlong\tnr;\n\n\t\tnr = getdecchrs();\n\t\tswitch (no_Magic(getchr()))\n\t\t{\n\t\t    case '=': lop = MATCH; break;\t\t  // \\@=\n\t\t    case '!': lop = NOMATCH; break;\t\t  // \\@!\n\t\t    case '>': lop = SUBPAT; break;\t\t  // \\@>\n\t\t    case '<': switch (no_Magic(getchr()))\n\t\t\t      {\n\t\t\t\t  case '=': lop = BEHIND; break;   // \\@<=\n\t\t\t\t  case '!': lop = NOBEHIND; break; // \\@<!\n\t\t\t      }\n\t\t}\n\t\tif (lop == END)\n\t\t    EMSG2_RET_NULL(_(e_invalid_character_after_str_at),\n\t\t\t\t\t\t      reg_magic == MAGIC_ALL);\n\t\t// Look behind must match with behind_pos.\n\t\tif (lop == BEHIND || lop == NOBEHIND)\n\t\t{\n\t\t    regtail(ret, regnode(BHPOS));\n\t\t    *flagp |= HASLOOKBH;\n\t\t}\n\t\tregtail(ret, regnode(END)); // operand ends\n\t\tif (lop == BEHIND || lop == NOBEHIND)\n\t\t{\n\t\t    if (nr < 0)\n\t\t\tnr = 0; // no limit is same as zero limit\n\t\t    reginsert_nr(lop, nr, ret);\n\t\t}\n\t\telse\n\t\t    reginsert(lop, ret);\n\t\tbreak;\n\t    }\n\n\tcase Magic('?'):\n\tcase Magic('='):\n\t    // Emit x= as (x|)\n\t    reginsert(BRANCH, ret);\t\t// Either x\n\t    regtail(ret, regnode(BRANCH));\t// or\n\t    next = regnode(NOTHING);\t\t// null.\n\t    regtail(ret, next);\n\t    regoptail(ret, next);\n\t    break;\n\n\tcase Magic('{'):\n\t    if (!read_limits(&minval, &maxval))\n\t\treturn NULL;\n\t    if (flags & SIMPLE)\n\t    {\n\t\treginsert(BRACE_SIMPLE, ret);\n\t\treginsert_limits(BRACE_LIMITS, minval, maxval, ret);\n\t    }\n\t    else\n\t    {\n\t\tif (num_complex_braces >= 10)\n\t\t    EMSG2_RET_NULL(_(e_too_many_complex_str_curly),\n\t\t\t\t\t\t      reg_magic == MAGIC_ALL);\n\t\treginsert(BRACE_COMPLEX + num_complex_braces, ret);\n\t\tregoptail(ret, regnode(BACK));\n\t\tregoptail(ret, ret);\n\t\treginsert_limits(BRACE_LIMITS, minval, maxval, ret);\n\t\t++num_complex_braces;\n\t    }\n\t    if (minval > 0 && maxval > 0)\n\t\t*flagp = (HASWIDTH | (flags & (HASNL | HASLOOKBH)));\n\t    break;\n    }\n    if (re_multi_type(peekchr()) != NOT_MULTI)\n    {\n\t// Can't have a multi follow a multi.\n\tif (peekchr() == Magic('*'))\n\t    EMSG2_RET_NULL(_(e_nested_str), reg_magic >= MAGIC_ON);\n\tEMSG3_RET_NULL(_(e_nested_str_chr), reg_magic == MAGIC_ALL,\n\t\t\t\t\t\t\t  no_Magic(peekchr()));\n    }\n\n    return ret;\n}\n\n/*\n * Parse one alternative of an | or & operator.\n * Implements the concatenation operator.\n */\n    static char_u *\nregconcat(int *flagp)\n{\n    char_u\t*first = NULL;\n    char_u\t*chain = NULL;\n    char_u\t*latest;\n    int\t\tflags;\n    int\t\tcont = TRUE;\n\n    *flagp = WORST;\t\t// Tentatively.\n\n    while (cont)\n    {\n\tswitch (peekchr())\n\t{\n\t    case NUL:\n\t    case Magic('|'):\n\t    case Magic('&'):\n\t    case Magic(')'):\n\t\t\t    cont = FALSE;\n\t\t\t    break;\n\t    case Magic('Z'):\n\t\t\t    regflags |= RF_ICOMBINE;\n\t\t\t    skipchr_keepstart();\n\t\t\t    break;\n\t    case Magic('c'):\n\t\t\t    regflags |= RF_ICASE;\n\t\t\t    skipchr_keepstart();\n\t\t\t    break;\n\t    case Magic('C'):\n\t\t\t    regflags |= RF_NOICASE;\n\t\t\t    skipchr_keepstart();\n\t\t\t    break;\n\t    case Magic('v'):\n\t\t\t    reg_magic = MAGIC_ALL;\n\t\t\t    skipchr_keepstart();\n\t\t\t    curchr = -1;\n\t\t\t    break;\n\t    case Magic('m'):\n\t\t\t    reg_magic = MAGIC_ON;\n\t\t\t    skipchr_keepstart();\n\t\t\t    curchr = -1;\n\t\t\t    break;\n\t    case Magic('M'):\n\t\t\t    reg_magic = MAGIC_OFF;\n\t\t\t    skipchr_keepstart();\n\t\t\t    curchr = -1;\n\t\t\t    break;\n\t    case Magic('V'):\n\t\t\t    reg_magic = MAGIC_NONE;\n\t\t\t    skipchr_keepstart();\n\t\t\t    curchr = -1;\n\t\t\t    break;\n\t    default:\n\t\t\t    latest = regpiece(&flags);\n\t\t\t    if (latest == NULL || reg_toolong)\n\t\t\t\treturn NULL;\n\t\t\t    *flagp |= flags & (HASWIDTH | HASNL | HASLOOKBH);\n\t\t\t    if (chain == NULL)\t// First piece.\n\t\t\t\t*flagp |= flags & SPSTART;\n\t\t\t    else\n\t\t\t\tregtail(chain, latest);\n\t\t\t    chain = latest;\n\t\t\t    if (first == NULL)\n\t\t\t\tfirst = latest;\n\t\t\t    break;\n\t}\n    }\n    if (first == NULL)\t\t// Loop ran zero times.\n\tfirst = regnode(NOTHING);\n    return first;\n}\n\n/*\n * Parse one alternative of an | operator.\n * Implements the & operator.\n */\n    static char_u *\nregbranch(int *flagp)\n{\n    char_u\t*ret;\n    char_u\t*chain = NULL;\n    char_u\t*latest;\n    int\t\tflags;\n\n    *flagp = WORST | HASNL;\t\t// Tentatively.\n\n    ret = regnode(BRANCH);\n    for (;;)\n    {\n\tlatest = regconcat(&flags);\n\tif (latest == NULL)\n\t    return NULL;\n\t// If one of the branches has width, the whole thing has.  If one of\n\t// the branches anchors at start-of-line, the whole thing does.\n\t// If one of the branches uses look-behind, the whole thing does.\n\t*flagp |= flags & (HASWIDTH | SPSTART | HASLOOKBH);\n\t// If one of the branches doesn't match a line-break, the whole thing\n\t// doesn't.\n\t*flagp &= ~HASNL | (flags & HASNL);\n\tif (chain != NULL)\n\t    regtail(chain, latest);\n\tif (peekchr() != Magic('&'))\n\t    break;\n\tskipchr();\n\tregtail(latest, regnode(END)); // operand ends\n\tif (reg_toolong)\n\t    break;\n\treginsert(MATCH, latest);\n\tchain = latest;\n    }\n\n    return ret;\n}\n\n/*\n * Parse regular expression, i.e. main body or parenthesized thing.\n *\n * Caller must absorb opening parenthesis.\n *\n * Combining parenthesis handling with the base level of regular expression\n * is a trifle forced, but the need to tie the tails of the branches to what\n * follows makes it hard to avoid.\n */\n    static char_u *\nreg(\n    int\t\tparen,\t// REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN\n    int\t\t*flagp)\n{\n    char_u\t*ret;\n    char_u\t*br;\n    char_u\t*ender;\n    int\t\tparno = 0;\n    int\t\tflags;\n\n    *flagp = HASWIDTH;\t\t// Tentatively.\n\n#ifdef FEAT_SYN_HL\n    if (paren == REG_ZPAREN)\n    {\n\t// Make a ZOPEN node.\n\tif (regnzpar >= NSUBEXP)\n\t    EMSG_RET_NULL(_(e_too_many_z));\n\tparno = regnzpar;\n\tregnzpar++;\n\tret = regnode(ZOPEN + parno);\n    }\n    else\n#endif\n\tif (paren == REG_PAREN)\n    {\n\t// Make a MOPEN node.\n\tif (regnpar >= NSUBEXP)\n\t    EMSG2_RET_NULL(_(e_too_many_str_open), reg_magic == MAGIC_ALL);\n\tparno = regnpar;\n\t++regnpar;\n\tret = regnode(MOPEN + parno);\n    }\n    else if (paren == REG_NPAREN)\n    {\n\t// Make a NOPEN node.\n\tret = regnode(NOPEN);\n    }\n    else\n\tret = NULL;\n\n    // Pick up the branches, linking them together.\n    br = regbranch(&flags);\n    if (br == NULL)\n\treturn NULL;\n    if (ret != NULL)\n\tregtail(ret, br);\t// [MZ]OPEN -> first.\n    else\n\tret = br;\n    // If one of the branches can be zero-width, the whole thing can.\n    // If one of the branches has * at start or matches a line-break, the\n    // whole thing can.\n    if (!(flags & HASWIDTH))\n\t*flagp &= ~HASWIDTH;\n    *flagp |= flags & (SPSTART | HASNL | HASLOOKBH);\n    while (peekchr() == Magic('|'))\n    {\n\tskipchr();\n\tbr = regbranch(&flags);\n\tif (br == NULL || reg_toolong)\n\t    return NULL;\n\tregtail(ret, br);\t// BRANCH -> BRANCH.\n\tif (!(flags & HASWIDTH))\n\t    *flagp &= ~HASWIDTH;\n\t*flagp |= flags & (SPSTART | HASNL | HASLOOKBH);\n    }\n\n    // Make a closing node, and hook it on the end.\n    ender = regnode(\n#ifdef FEAT_SYN_HL\n\t    paren == REG_ZPAREN ? ZCLOSE + parno :\n#endif\n\t    paren == REG_PAREN ? MCLOSE + parno :\n\t    paren == REG_NPAREN ? NCLOSE : END);\n    regtail(ret, ender);\n\n    // Hook the tails of the branches to the closing node.\n    for (br = ret; br != NULL; br = regnext(br))\n\tregoptail(br, ender);\n\n    // Check for proper termination.\n    if (paren != REG_NOPAREN && getchr() != Magic(')'))\n    {\n#ifdef FEAT_SYN_HL\n\tif (paren == REG_ZPAREN)\n\t    EMSG_RET_NULL(_(e_unmatched_z));\n\telse\n#endif\n\t    if (paren == REG_NPAREN)\n\t    EMSG2_RET_NULL(_(e_unmatched_str_percent_open), reg_magic == MAGIC_ALL);\n\telse\n\t    EMSG2_RET_NULL(_(e_unmatched_str_open), reg_magic == MAGIC_ALL);\n    }\n    else if (paren == REG_NOPAREN && peekchr() != NUL)\n    {\n\tif (curchr == Magic(')'))\n\t    EMSG2_RET_NULL(_(e_unmatched_str_close), reg_magic == MAGIC_ALL);\n\telse\n\t    EMSG_RET_NULL(_(e_trailing_characters));\t// \"Can't happen\".\n\t// NOTREACHED\n    }\n    // Here we set the flag allowing back references to this set of\n    // parentheses.\n    if (paren == REG_PAREN)\n\thad_endbrace[parno] = TRUE;\t// have seen the close paren\n    return ret;\n}\n\n/*\n * bt_regcomp() - compile a regular expression into internal code for the\n * traditional back track matcher.\n * Returns the program in allocated space.  Returns NULL for an error.\n *\n * We can't allocate space until we know how big the compiled form will be,\n * but we can't compile it (and thus know how big it is) until we've got a\n * place to put the code.  So we cheat:  we compile it twice, once with code\n * generation turned off and size counting turned on, and once \"for real\".\n * This also means that we don't allocate space until we are sure that the\n * thing really will compile successfully, and we never have to move the\n * code and thus invalidate pointers into it.  (Note that it has to be in\n * one piece because vim_free() must be able to free it all.)\n *\n * Whether upper/lower case is to be ignored is decided when executing the\n * program, it does not matter here.\n *\n * Beware that the optimization-preparation code in here knows about some\n * of the structure of the compiled regexp.\n * \"re_flags\": RE_MAGIC and/or RE_STRING.\n */\n    static regprog_T *\nbt_regcomp(char_u *expr, int re_flags)\n{\n    bt_regprog_T    *r;\n    char_u\t*scan;\n    char_u\t*longest;\n    int\t\tlen;\n    int\t\tflags;\n\n    if (expr == NULL)\n\tIEMSG_RET_NULL(_(e_null_argument));\n\n    init_class_tab();\n\n    // First pass: determine size, legality.\n    regcomp_start(expr, re_flags);\n    regcode = JUST_CALC_SIZE;\n    regc(REGMAGIC);\n    if (reg(REG_NOPAREN, &flags) == NULL)\n\treturn NULL;\n\n    // Allocate space.\n    r = alloc(offsetof(bt_regprog_T, program) + regsize);\n    if (r == NULL)\n\treturn NULL;\n    r->re_in_use = FALSE;\n\n    // Second pass: emit code.\n    regcomp_start(expr, re_flags);\n    regcode = r->program;\n    regc(REGMAGIC);\n    if (reg(REG_NOPAREN, &flags) == NULL || reg_toolong)\n    {\n\tvim_free(r);\n\tif (reg_toolong)\n\t    EMSG_RET_NULL(_(e_pattern_too_long));\n\treturn NULL;\n    }\n\n    // Dig out information for optimizations.\n    r->regstart = NUL;\t\t// Worst-case defaults.\n    r->reganch = 0;\n    r->regmust = NULL;\n    r->regmlen = 0;\n    r->regflags = regflags;\n    if (flags & HASNL)\n\tr->regflags |= RF_HASNL;\n    if (flags & HASLOOKBH)\n\tr->regflags |= RF_LOOKBH;\n#ifdef FEAT_SYN_HL\n    // Remember whether this pattern has any \\z specials in it.\n    r->reghasz = re_has_z;\n#endif\n    scan = r->program + 1;\t// First BRANCH.\n    if (OP(regnext(scan)) == END)   // Only one top-level choice.\n    {\n\tscan = OPERAND(scan);\n\n\t// Starting-point info.\n\tif (OP(scan) == BOL || OP(scan) == RE_BOF)\n\t{\n\t    r->reganch++;\n\t    scan = regnext(scan);\n\t}\n\n\tif (OP(scan) == EXACTLY)\n\t{\n\t    if (has_mbyte)\n\t\tr->regstart = (*mb_ptr2char)(OPERAND(scan));\n\t    else\n\t\tr->regstart = *OPERAND(scan);\n\t}\n\telse if ((OP(scan) == BOW\n\t\t    || OP(scan) == EOW\n\t\t    || OP(scan) == NOTHING\n\t\t    || OP(scan) == MOPEN + 0 || OP(scan) == NOPEN\n\t\t    || OP(scan) == MCLOSE + 0 || OP(scan) == NCLOSE)\n\t\t && OP(regnext(scan)) == EXACTLY)\n\t{\n\t    if (has_mbyte)\n\t\tr->regstart = (*mb_ptr2char)(OPERAND(regnext(scan)));\n\t    else\n\t\tr->regstart = *OPERAND(regnext(scan));\n\t}\n\n\t// If there's something expensive in the r.e., find the longest\n\t// literal string that must appear and make it the regmust.  Resolve\n\t// ties in favor of later strings, since the regstart check works\n\t// with the beginning of the r.e. and avoiding duplication\n\t// strengthens checking.  Not a strong reason, but sufficient in the\n\t// absence of others.\n\n\t// When the r.e. starts with BOW, it is faster to look for a regmust\n\t// first. Used a lot for \"#\" and \"*\" commands. (Added by mool).\n\tif ((flags & SPSTART || OP(scan) == BOW || OP(scan) == EOW)\n\t\t\t\t\t\t\t  && !(flags & HASNL))\n\t{\n\t    longest = NULL;\n\t    len = 0;\n\t    for (; scan != NULL; scan = regnext(scan))\n\t\tif (OP(scan) == EXACTLY && STRLEN(OPERAND(scan)) >= (size_t)len)\n\t\t{\n\t\t    longest = OPERAND(scan);\n\t\t    len = (int)STRLEN(OPERAND(scan));\n\t\t}\n\t    r->regmust = longest;\n\t    r->regmlen = len;\n\t}\n    }\n#ifdef BT_REGEXP_DUMP\n    regdump(expr, r);\n#endif\n    r->engine = &bt_regengine;\n    return (regprog_T *)r;\n}\n\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n/*\n * Check if during the previous call to vim_regcomp the EOL item \"$\" has been\n * found.  This is messy, but it works fine.\n */\n    int\nvim_regcomp_had_eol(void)\n{\n    return had_eol;\n}\n#endif\n\n/*\n * Get a number after a backslash that is inside [].\n * When nothing is recognized return a backslash.\n */\n    static int\ncoll_get_char(void)\n{\n    long\tnr = -1;\n\n    switch (*regparse++)\n    {\n\tcase 'd': nr = getdecchrs(); break;\n\tcase 'o': nr = getoctchrs(); break;\n\tcase 'x': nr = gethexchrs(2); break;\n\tcase 'u': nr = gethexchrs(4); break;\n\tcase 'U': nr = gethexchrs(8); break;\n    }\n    if (nr < 0 || nr > INT_MAX)\n    {\n\t// If getting the number fails be backwards compatible: the character\n\t// is a backslash.\n\t--regparse;\n\tnr = '\\\\';\n    }\n    return nr;\n}\n\n/*\n * Free a compiled regexp program, returned by bt_regcomp().\n */\n    static void\nbt_regfree(regprog_T *prog)\n{\n    vim_free(prog);\n}\n\n#define ADVANCE_REGINPUT() MB_PTR_ADV(rex.input)\n\n/*\n * The arguments from BRACE_LIMITS are stored here.  They are actually local\n * to regmatch(), but they are here to reduce the amount of stack space used\n * (it can be called recursively many times).\n */\nstatic long\tbl_minval;\nstatic long\tbl_maxval;\n\n/*\n * Save the input line and position in a regsave_T.\n */\n    static void\nreg_save(regsave_T *save, garray_T *gap)\n{\n    if (REG_MULTI)\n    {\n\tsave->rs_u.pos.col = (colnr_T)(rex.input - rex.line);\n\tsave->rs_u.pos.lnum = rex.lnum;\n    }\n    else\n\tsave->rs_u.ptr = rex.input;\n    save->rs_len = gap->ga_len;\n}\n\n/*\n * Restore the input line and position from a regsave_T.\n */\n    static void\nreg_restore(regsave_T *save, garray_T *gap)\n{\n    if (REG_MULTI)\n    {\n\tif (rex.lnum != save->rs_u.pos.lnum)\n\t{\n\t    // only call reg_getline() when the line number changed to save\n\t    // a bit of time\n\t    rex.lnum = save->rs_u.pos.lnum;\n\t    rex.line = reg_getline(rex.lnum);\n\t}\n\trex.input = rex.line + save->rs_u.pos.col;\n    }\n    else\n\trex.input = save->rs_u.ptr;\n    gap->ga_len = save->rs_len;\n}\n\n/*\n * Return TRUE if current position is equal to saved position.\n */\n    static int\nreg_save_equal(regsave_T *save)\n{\n    if (REG_MULTI)\n\treturn rex.lnum == save->rs_u.pos.lnum\n\t\t\t\t  && rex.input == rex.line + save->rs_u.pos.col;\n    return rex.input == save->rs_u.ptr;\n}\n\n// Save the sub-expressions before attempting a match.\n#define save_se(savep, posp, pp) \\\n    REG_MULTI ? save_se_multi((savep), (posp)) : save_se_one((savep), (pp))\n\n// After a failed match restore the sub-expressions.\n#define restore_se(savep, posp, pp) { \\\n    if (REG_MULTI) \\\n\t*(posp) = (savep)->se_u.pos; \\\n    else \\\n\t*(pp) = (savep)->se_u.ptr; }\n\n/*\n * Tentatively set the sub-expression start to the current position (after\n * calling regmatch() they will have changed).  Need to save the existing\n * values for when there is no match.\n * Use se_save() to use pointer (save_se_multi()) or position (save_se_one()),\n * depending on REG_MULTI.\n */\n    static void\nsave_se_multi(save_se_T *savep, lpos_T *posp)\n{\n    savep->se_u.pos = *posp;\n    posp->lnum = rex.lnum;\n    posp->col = (colnr_T)(rex.input - rex.line);\n}\n\n    static void\nsave_se_one(save_se_T *savep, char_u **pp)\n{\n    savep->se_u.ptr = *pp;\n    *pp = rex.input;\n}\n\n/*\n * regrepeat - repeatedly match something simple, return how many.\n * Advances rex.input (and rex.lnum) to just after the matched chars.\n */\n    static int\nregrepeat(\n    char_u\t*p,\n    long\tmaxcount)   // maximum number of matches allowed\n{\n    long\tcount = 0;\n    char_u\t*scan;\n    char_u\t*opnd;\n    int\t\tmask;\n    int\t\ttestval = 0;\n\n    scan = rex.input;\t    // Make local copy of rex.input for speed.\n    opnd = OPERAND(p);\n    switch (OP(p))\n    {\n      case ANY:\n      case ANY + ADD_NL:\n\twhile (count < maxcount)\n\t{\n\t    // Matching anything means we continue until end-of-line (or\n\t    // end-of-file for ANY + ADD_NL), only limited by maxcount.\n\t    while (*scan != NUL && count < maxcount)\n\t    {\n\t\t++count;\n\t\tMB_PTR_ADV(scan);\n\t    }\n\t    if (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n\t\t\t\t      || rex.reg_line_lbr || count == maxcount)\n\t\tbreak;\n\t    ++count;\t\t// count the line-break\n\t    reg_nextline();\n\t    scan = rex.input;\n\t    if (got_int)\n\t\tbreak;\n\t}\n\tbreak;\n\n      case IDENT:\n      case IDENT + ADD_NL:\n\ttestval = TRUE;\n\t// FALLTHROUGH\n      case SIDENT:\n      case SIDENT + ADD_NL:\n\twhile (count < maxcount)\n\t{\n\t    if (vim_isIDc(PTR2CHAR(scan)) && (testval || !VIM_ISDIGIT(*scan)))\n\t    {\n\t\tMB_PTR_ADV(scan);\n\t    }\n\t    else if (*scan == NUL)\n\t    {\n\t\tif (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n\t\t\t\t\t\t\t   || rex.reg_line_lbr)\n\t\t    break;\n\t\treg_nextline();\n\t\tscan = rex.input;\n\t\tif (got_int)\n\t\t    break;\n\t    }\n\t    else if (rex.reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p)))\n\t\t++scan;\n\t    else\n\t\tbreak;\n\t    ++count;\n\t}\n\tbreak;\n\n      case KWORD:\n      case KWORD + ADD_NL:\n\ttestval = TRUE;\n\t// FALLTHROUGH\n      case SKWORD:\n      case SKWORD + ADD_NL:\n\twhile (count < maxcount)\n\t{\n\t    if (vim_iswordp_buf(scan, rex.reg_buf)\n\t\t\t\t\t  && (testval || !VIM_ISDIGIT(*scan)))\n\t    {\n\t\tMB_PTR_ADV(scan);\n\t    }\n\t    else if (*scan == NUL)\n\t    {\n\t\tif (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n\t\t\t\t\t\t\t   || rex.reg_line_lbr)\n\t\t    break;\n\t\treg_nextline();\n\t\tscan = rex.input;\n\t\tif (got_int)\n\t\t    break;\n\t    }\n\t    else if (rex.reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p)))\n\t\t++scan;\n\t    else\n\t\tbreak;\n\t    ++count;\n\t}\n\tbreak;\n\n      case FNAME:\n      case FNAME + ADD_NL:\n\ttestval = TRUE;\n\t// FALLTHROUGH\n      case SFNAME:\n      case SFNAME + ADD_NL:\n\twhile (count < maxcount)\n\t{\n\t    if (vim_isfilec(PTR2CHAR(scan)) && (testval || !VIM_ISDIGIT(*scan)))\n\t    {\n\t\tMB_PTR_ADV(scan);\n\t    }\n\t    else if (*scan == NUL)\n\t    {\n\t\tif (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n\t\t\t\t\t\t\t   || rex.reg_line_lbr)\n\t\t    break;\n\t\treg_nextline();\n\t\tscan = rex.input;\n\t\tif (got_int)\n\t\t    break;\n\t    }\n\t    else if (rex.reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p)))\n\t\t++scan;\n\t    else\n\t\tbreak;\n\t    ++count;\n\t}\n\tbreak;\n\n      case PRINT:\n      case PRINT + ADD_NL:\n\ttestval = TRUE;\n\t// FALLTHROUGH\n      case SPRINT:\n      case SPRINT + ADD_NL:\n\twhile (count < maxcount)\n\t{\n\t    if (*scan == NUL)\n\t    {\n\t\tif (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n\t\t\t\t\t\t\t   || rex.reg_line_lbr)\n\t\t    break;\n\t\treg_nextline();\n\t\tscan = rex.input;\n\t\tif (got_int)\n\t\t    break;\n\t    }\n\t    else if (vim_isprintc(PTR2CHAR(scan)) == 1\n\t\t\t\t\t  && (testval || !VIM_ISDIGIT(*scan)))\n\t    {\n\t\tMB_PTR_ADV(scan);\n\t    }\n\t    else if (rex.reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p)))\n\t\t++scan;\n\t    else\n\t\tbreak;\n\t    ++count;\n\t}\n\tbreak;\n\n      case WHITE:\n      case WHITE + ADD_NL:\n\ttestval = mask = RI_WHITE;\ndo_class:\n\twhile (count < maxcount)\n\t{\n\t    int\t\tl;\n\n\t    if (*scan == NUL)\n\t    {\n\t\tif (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n\t\t\t\t\t\t\t   || rex.reg_line_lbr)\n\t\t    break;\n\t\treg_nextline();\n\t\tscan = rex.input;\n\t\tif (got_int)\n\t\t    break;\n\t    }\n\t    else if (has_mbyte && (l = (*mb_ptr2len)(scan)) > 1)\n\t    {\n\t\tif (testval != 0)\n\t\t    break;\n\t\tscan += l;\n\t    }\n\t    else if ((class_tab[*scan] & mask) == testval)\n\t\t++scan;\n\t    else if (rex.reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p)))\n\t\t++scan;\n\t    else\n\t\tbreak;\n\t    ++count;\n\t}\n\tbreak;\n\n      case NWHITE:\n      case NWHITE + ADD_NL:\n\tmask = RI_WHITE;\n\tgoto do_class;\n      case DIGIT:\n      case DIGIT + ADD_NL:\n\ttestval = mask = RI_DIGIT;\n\tgoto do_class;\n      case NDIGIT:\n      case NDIGIT + ADD_NL:\n\tmask = RI_DIGIT;\n\tgoto do_class;\n      case HEX:\n      case HEX + ADD_NL:\n\ttestval = mask = RI_HEX;\n\tgoto do_class;\n      case NHEX:\n      case NHEX + ADD_NL:\n\tmask = RI_HEX;\n\tgoto do_class;\n      case OCTAL:\n      case OCTAL + ADD_NL:\n\ttestval = mask = RI_OCTAL;\n\tgoto do_class;\n      case NOCTAL:\n      case NOCTAL + ADD_NL:\n\tmask = RI_OCTAL;\n\tgoto do_class;\n      case WORD:\n      case WORD + ADD_NL:\n\ttestval = mask = RI_WORD;\n\tgoto do_class;\n      case NWORD:\n      case NWORD + ADD_NL:\n\tmask = RI_WORD;\n\tgoto do_class;\n      case HEAD:\n      case HEAD + ADD_NL:\n\ttestval = mask = RI_HEAD;\n\tgoto do_class;\n      case NHEAD:\n      case NHEAD + ADD_NL:\n\tmask = RI_HEAD;\n\tgoto do_class;\n      case ALPHA:\n      case ALPHA + ADD_NL:\n\ttestval = mask = RI_ALPHA;\n\tgoto do_class;\n      case NALPHA:\n      case NALPHA + ADD_NL:\n\tmask = RI_ALPHA;\n\tgoto do_class;\n      case LOWER:\n      case LOWER + ADD_NL:\n\ttestval = mask = RI_LOWER;\n\tgoto do_class;\n      case NLOWER:\n      case NLOWER + ADD_NL:\n\tmask = RI_LOWER;\n\tgoto do_class;\n      case UPPER:\n      case UPPER + ADD_NL:\n\ttestval = mask = RI_UPPER;\n\tgoto do_class;\n      case NUPPER:\n      case NUPPER + ADD_NL:\n\tmask = RI_UPPER;\n\tgoto do_class;\n\n      case EXACTLY:\n\t{\n\t    int\t    cu, cl;\n\n\t    // This doesn't do a multi-byte character, because a MULTIBYTECODE\n\t    // would have been used for it.  It does handle single-byte\n\t    // characters, such as latin1.\n\t    if (rex.reg_ic)\n\t    {\n\t\tcu = MB_TOUPPER(*opnd);\n\t\tcl = MB_TOLOWER(*opnd);\n\t\twhile (count < maxcount && (*scan == cu || *scan == cl))\n\t\t{\n\t\t    count++;\n\t\t    scan++;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tcu = *opnd;\n\t\twhile (count < maxcount && *scan == cu)\n\t\t{\n\t\t    count++;\n\t\t    scan++;\n\t\t}\n\t    }\n\t    break;\n\t}\n\n      case MULTIBYTECODE:\n\t{\n\t    int\t\ti, len, cf = 0;\n\n\t    // Safety check (just in case 'encoding' was changed since\n\t    // compiling the program).\n\t    if ((len = (*mb_ptr2len)(opnd)) > 1)\n\t    {\n\t\tif (rex.reg_ic && enc_utf8)\n\t\t    cf = utf_fold(utf_ptr2char(opnd));\n\t\twhile (count < maxcount && (*mb_ptr2len)(scan) >= len)\n\t\t{\n\t\t    for (i = 0; i < len; ++i)\n\t\t\tif (opnd[i] != scan[i])\n\t\t\t    break;\n\t\t    if (i < len && (!rex.reg_ic || !enc_utf8\n\t\t\t\t\t|| utf_fold(utf_ptr2char(scan)) != cf))\n\t\t\tbreak;\n\t\t    scan += len;\n\t\t    ++count;\n\t\t}\n\t    }\n\t}\n\tbreak;\n\n      case ANYOF:\n      case ANYOF + ADD_NL:\n\ttestval = TRUE;\n\t// FALLTHROUGH\n\n      case ANYBUT:\n      case ANYBUT + ADD_NL:\n\twhile (count < maxcount)\n\t{\n\t    int len;\n\n\t    if (*scan == NUL)\n\t    {\n\t\tif (!REG_MULTI || !WITH_NL(OP(p)) || rex.lnum > rex.reg_maxline\n\t\t\t\t\t\t\t   || rex.reg_line_lbr)\n\t\t    break;\n\t\treg_nextline();\n\t\tscan = rex.input;\n\t\tif (got_int)\n\t\t    break;\n\t    }\n\t    else if (rex.reg_line_lbr && *scan == '\\n' && WITH_NL(OP(p)))\n\t\t++scan;\n\t    else if (has_mbyte && (len = (*mb_ptr2len)(scan)) > 1)\n\t    {\n\t\tif ((cstrchr(opnd, (*mb_ptr2char)(scan)) == NULL) == testval)\n\t\t    break;\n\t\tscan += len;\n\t    }\n\t    else\n\t    {\n\t\tif ((cstrchr(opnd, *scan) == NULL) == testval)\n\t\t    break;\n\t\t++scan;\n\t    }\n\t    ++count;\n\t}\n\tbreak;\n\n      case NEWL:\n\twhile (count < maxcount\n\t\t&& ((*scan == NUL && rex.lnum <= rex.reg_maxline\n\t\t\t\t       && !rex.reg_line_lbr && REG_MULTI)\n\t\t    || (*scan == '\\n' && rex.reg_line_lbr)))\n\t{\n\t    count++;\n\t    if (rex.reg_line_lbr)\n\t\tADVANCE_REGINPUT();\n\t    else\n\t\treg_nextline();\n\t    scan = rex.input;\n\t    if (got_int)\n\t\tbreak;\n\t}\n\tbreak;\n\n      default:\t\t\t// Oh dear.  Called inappropriately.\n\tiemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\tprintf(\"Called regrepeat with op code %d\\n\", OP(p));\n#endif\n\tbreak;\n    }\n\n    rex.input = scan;\n\n    return (int)count;\n}\n\n/*\n * Push an item onto the regstack.\n * Returns pointer to new item.  Returns NULL when out of memory.\n */\n    static regitem_T *\nregstack_push(regstate_T state, char_u *scan)\n{\n    regitem_T\t*rp;\n\n    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n    {\n\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\treturn NULL;\n    }\n    if (ga_grow(&regstack, sizeof(regitem_T)) == FAIL)\n\treturn NULL;\n\n    rp = (regitem_T *)((char *)regstack.ga_data + regstack.ga_len);\n    rp->rs_state = state;\n    rp->rs_scan = scan;\n\n    regstack.ga_len += sizeof(regitem_T);\n    return rp;\n}\n\n/*\n * Pop an item from the regstack.\n */\n    static void\nregstack_pop(char_u **scan)\n{\n    regitem_T\t*rp;\n\n    rp = (regitem_T *)((char *)regstack.ga_data + regstack.ga_len) - 1;\n    *scan = rp->rs_scan;\n\n    regstack.ga_len -= sizeof(regitem_T);\n}\n\n/*\n * Save the current subexpr to \"bp\", so that they can be restored\n * later by restore_subexpr().\n */\n    static void\nsave_subexpr(regbehind_T *bp)\n{\n    int i;\n\n    // When \"rex.need_clear_subexpr\" is set we don't need to save the values,\n    // only remember that this flag needs to be set again when restoring.\n    bp->save_need_clear_subexpr = rex.need_clear_subexpr;\n    if (!rex.need_clear_subexpr)\n    {\n\tfor (i = 0; i < NSUBEXP; ++i)\n\t{\n\t    if (REG_MULTI)\n\t    {\n\t\tbp->save_start[i].se_u.pos = rex.reg_startpos[i];\n\t\tbp->save_end[i].se_u.pos = rex.reg_endpos[i];\n\t    }\n\t    else\n\t    {\n\t\tbp->save_start[i].se_u.ptr = rex.reg_startp[i];\n\t\tbp->save_end[i].se_u.ptr = rex.reg_endp[i];\n\t    }\n\t}\n    }\n}\n\n/*\n * Restore the subexpr from \"bp\".\n */\n    static void\nrestore_subexpr(regbehind_T *bp)\n{\n    int i;\n\n    // Only need to restore saved values when they are not to be cleared.\n    rex.need_clear_subexpr = bp->save_need_clear_subexpr;\n    if (!rex.need_clear_subexpr)\n    {\n\tfor (i = 0; i < NSUBEXP; ++i)\n\t{\n\t    if (REG_MULTI)\n\t    {\n\t\trex.reg_startpos[i] = bp->save_start[i].se_u.pos;\n\t\trex.reg_endpos[i] = bp->save_end[i].se_u.pos;\n\t    }\n\t    else\n\t    {\n\t\trex.reg_startp[i] = bp->save_start[i].se_u.ptr;\n\t\trex.reg_endp[i] = bp->save_end[i].se_u.ptr;\n\t    }\n\t}\n    }\n}\n\n/*\n * regmatch - main matching routine\n *\n * Conceptually the strategy is simple: Check to see whether the current node\n * matches, push an item onto the regstack and loop to see whether the rest\n * matches, and then act accordingly.  In practice we make some effort to\n * avoid using the regstack, in particular by going through \"ordinary\" nodes\n * (that don't need to know whether the rest of the match failed) by a nested\n * loop.\n *\n * Returns TRUE when there is a match.  Leaves rex.input and rex.lnum just after\n * the last matched character.\n * Returns FALSE when there is no match.  Leaves rex.input and rex.lnum in an\n * undefined state!\n */\n    static int\nregmatch(\n    char_u\t*scan,\t\t    // Current node.\n    proftime_T\t*tm UNUSED,\t    // timeout limit or NULL\n    int\t\t*timed_out UNUSED)  // flag set on timeout or NULL\n{\n  char_u\t*next;\t\t// Next node.\n  int\t\top;\n  int\t\tc;\n  regitem_T\t*rp;\n  int\t\tno;\n  int\t\tstatus;\t\t// one of the RA_ values:\n#ifdef FEAT_RELTIME\n  int\t\ttm_count = 0;\n#endif\n\n  // Make \"regstack\" and \"backpos\" empty.  They are allocated and freed in\n  // bt_regexec_both() to reduce malloc()/free() calls.\n  regstack.ga_len = 0;\n  backpos.ga_len = 0;\n\n  // Repeat until \"regstack\" is empty.\n  for (;;)\n  {\n    // Some patterns may take a long time to match, e.g., \"\\([a-z]\\+\\)\\+Q\".\n    // Allow interrupting them with CTRL-C.\n    fast_breakcheck();\n\n#ifdef DEBUG\n    if (scan != NULL && regnarrate)\n    {\n\tmch_errmsg((char *)regprop(scan));\n\tmch_errmsg(\"(\\n\");\n    }\n#endif\n\n    // Repeat for items that can be matched sequentially, without using the\n    // regstack.\n    for (;;)\n    {\n\tif (got_int || scan == NULL)\n\t{\n\t    status = RA_FAIL;\n\t    break;\n\t}\n#ifdef FEAT_RELTIME\n\t// Check for timeout once in a 100 times to avoid overhead.\n\tif (tm != NULL && ++tm_count == 100)\n\t{\n\t    tm_count = 0;\n\t    if (profile_passed_limit(tm))\n\t    {\n\t\tif (timed_out != NULL)\n\t\t    *timed_out = TRUE;\n\t\tstatus = RA_FAIL;\n\t\tbreak;\n\t    }\n\t}\n#endif\n\tstatus = RA_CONT;\n\n#ifdef DEBUG\n\tif (regnarrate)\n\t{\n\t    mch_errmsg((char *)regprop(scan));\n\t    mch_errmsg(\"...\\n\");\n# ifdef FEAT_SYN_HL\n\t    if (re_extmatch_in != NULL)\n\t    {\n\t\tint i;\n\n\t\tmch_errmsg(_(\"External submatches:\\n\"));\n\t\tfor (i = 0; i < NSUBEXP; i++)\n\t\t{\n\t\t    mch_errmsg(\"    \\\"\");\n\t\t    if (re_extmatch_in->matches[i] != NULL)\n\t\t\tmch_errmsg((char *)re_extmatch_in->matches[i]);\n\t\t    mch_errmsg(\"\\\"\\n\");\n\t\t}\n\t    }\n# endif\n\t}\n#endif\n\tnext = regnext(scan);\n\n\top = OP(scan);\n\t// Check for character class with NL added.\n\tif (!rex.reg_line_lbr && WITH_NL(op) && REG_MULTI\n\t\t\t     && *rex.input == NUL && rex.lnum <= rex.reg_maxline)\n\t{\n\t    reg_nextline();\n\t}\n\telse if (rex.reg_line_lbr && WITH_NL(op) && *rex.input == '\\n')\n\t{\n\t    ADVANCE_REGINPUT();\n\t}\n\telse\n\t{\n\t  if (WITH_NL(op))\n\t      op -= ADD_NL;\n\t  if (has_mbyte)\n\t      c = (*mb_ptr2char)(rex.input);\n\t  else\n\t      c = *rex.input;\n\t  switch (op)\n\t  {\n\t  case BOL:\n\t    if (rex.input != rex.line)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case EOL:\n\t    if (c != NUL)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_BOF:\n\t    // We're not at the beginning of the file when below the first\n\t    // line where we started, not at the start of the line or we\n\t    // didn't start at the first line of the buffer.\n\t    if (rex.lnum != 0 || rex.input != rex.line\n\t\t\t\t       || (REG_MULTI && rex.reg_firstlnum > 1))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_EOF:\n\t    if (rex.lnum != rex.reg_maxline || c != NUL)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case CURSOR:\n\t    // Check if the buffer is in a window and compare the\n\t    // rex.reg_win->w_cursor position to the match position.\n\t    if (rex.reg_win == NULL\n\t\t    || (rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t != rex.reg_win->w_cursor.lnum)\n\t\t    || ((colnr_T)(rex.input - rex.line)\n\t\t\t\t\t\t != rex.reg_win->w_cursor.col))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_MARK:\n\t    // Compare the mark position to the match position.\n\t    {\n\t\tint\tmark = OPERAND(scan)[0];\n\t\tint\tcmp = OPERAND(scan)[1];\n\t\tpos_T\t*pos;\n\n\t\tpos = getmark_buf(rex.reg_buf, mark, FALSE);\n\t\tif (pos == NULL\t\t     // mark doesn't exist\n\t\t\t|| pos->lnum <= 0)   // mark isn't set in reg_buf\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t\telse\n\t\t{\n\t\t    colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t\t  && pos->col == MAXCOL\n\t\t\t\t      ? (colnr_T)STRLEN(reg_getline(\n\t\t\t\t\t\tpos->lnum - rex.reg_firstlnum))\n\t\t\t\t      : pos->col;\n\n\t\t    if ((pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t? (pos_col == (colnr_T)(rex.input - rex.line)\n\t\t\t\t    ? (cmp == '<' || cmp == '>')\n\t\t\t\t    : (pos_col < (colnr_T)(rex.input - rex.line)\n\t\t\t\t\t? cmp != '>'\n\t\t\t\t\t: cmp != '<'))\n\t\t\t\t: (pos->lnum < rex.lnum + rex.reg_firstlnum\n\t\t\t\t    ? cmp != '>'\n\t\t\t\t    : cmp != '<')))\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t    }\n\t    break;\n\n\t  case RE_VISUAL:\n\t    if (!reg_match_visual())\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_LNUM:\n\t    if (!REG_MULTI || !re_num_cmp((long_u)(rex.lnum + rex.reg_firstlnum),\n\t\t\t\t\t\t\t\t\tscan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_COL:\n\t    if (!re_num_cmp((long_u)(rex.input - rex.line) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_VCOL:\n\t    if (!re_num_cmp((long_u)win_linetabsize(\n\t\t\t    rex.reg_win == NULL ? curwin : rex.reg_win,\n\t\t\t    rex.line, (colnr_T)(rex.input - rex.line)) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case BOW:\t// \\<word; rex.input points to w\n\t    if (c == NUL)\t// Can't match at end of line\n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class;\n\n\t\t// Get class of current and previous char (if it exists).\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tif (this_class <= 1)\n\t\t    status = RA_NOMATCH;  // not on a word at all\n\t\telse if (reg_prev_class() == this_class)\n\t\t    status = RA_NOMATCH;  // previous char is in same word\n\t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(c, rex.reg_buf) || (rex.input > rex.line\n\t\t\t\t&& vim_iswordc_buf(rex.input[-1], rex.reg_buf)))\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break;\n\n\t  case EOW:\t// word\\>; rex.input points after d\n\t    if (rex.input == rex.line)    // Can't match at start of line\n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class, prev_class;\n\n\t\t// Get class of current and previous char (if it exists).\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tprev_class = reg_prev_class();\n\t\tif (this_class == prev_class\n\t\t\t|| prev_class == 0 || prev_class == 1)\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(rex.input[-1], rex.reg_buf)\n\t\t\t|| (rex.input[0] != NUL\n\t\t\t\t\t   && vim_iswordc_buf(c, rex.reg_buf)))\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break; // Matched with EOW\n\n\t  case ANY:\n\t    // ANY does not match new lines.\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case IDENT:\n\t    if (!vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SIDENT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case KWORD:\n\t    if (!vim_iswordp_buf(rex.input, rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SKWORD:\n\t    if (VIM_ISDIGIT(*rex.input)\n\t\t\t\t    || !vim_iswordp_buf(rex.input, rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case FNAME:\n\t    if (!vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SFNAME:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case PRINT:\n\t    if (!vim_isprintc(PTR2CHAR(rex.input)))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SPRINT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isprintc(PTR2CHAR(rex.input)))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case WHITE:\n\t    if (!VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NWHITE:\n\t    if (c == NUL || VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case DIGIT:\n\t    if (!ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NDIGIT:\n\t    if (c == NUL || ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case HEX:\n\t    if (!ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NHEX:\n\t    if (c == NUL || ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case OCTAL:\n\t    if (!ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NOCTAL:\n\t    if (c == NUL || ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case WORD:\n\t    if (!ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NWORD:\n\t    if (c == NUL || ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case HEAD:\n\t    if (!ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NHEAD:\n\t    if (c == NUL || ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case ALPHA:\n\t    if (!ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NALPHA:\n\t    if (c == NUL || ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case LOWER:\n\t    if (!ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NLOWER:\n\t    if (c == NUL || ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case UPPER:\n\t    if (!ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NUPPER:\n\t    if (c == NUL || ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case EXACTLY:\n\t    {\n\t\tint\tlen;\n\t\tchar_u\t*opnd;\n\n\t\topnd = OPERAND(scan);\n\t\t// Inline the first byte, for speed.\n\t\tif (*opnd != *rex.input\n\t\t\t&& (!rex.reg_ic\n\t\t\t    || (!enc_utf8\n\t\t\t      && MB_TOLOWER(*opnd) != MB_TOLOWER(*rex.input))))\n\t\t    status = RA_NOMATCH;\n\t\telse if (*opnd == NUL)\n\t\t{\n\t\t    // match empty string always works; happens when \"~\" is\n\t\t    // empty.\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (opnd[1] == NUL && !(enc_utf8 && rex.reg_ic))\n\t\t    {\n\t\t\tlen = 1;\t// matched a single byte above\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Need to match first byte again for multi-byte.\n\t\t\tlen = (int)STRLEN(opnd);\n\t\t\tif (cstrncmp(opnd, rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\t\t    }\n\t\t    // Check for following composing character, unless %C\n\t\t    // follows (skips over all composing chars).\n\t\t    if (status != RA_NOMATCH\n\t\t\t    && enc_utf8\n\t\t\t    && UTF_COMPOSINGLIKE(rex.input, rex.input + len)\n\t\t\t    && !rex.reg_icombine\n\t\t\t    && OP(next) != RE_COMPOSING)\n\t\t    {\n\t\t\t// raaron: This code makes a composing character get\n\t\t\t// ignored, which is the correct behavior (sometimes)\n\t\t\t// for voweled Hebrew texts.\n\t\t\tstatus = RA_NOMATCH;\n\t\t    }\n\t\t    if (status != RA_NOMATCH)\n\t\t\trex.input += len;\n\t\t}\n\t    }\n\t    break;\n\n\t  case ANYOF:\n\t  case ANYBUT:\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else if ((cstrchr(OPERAND(scan), c) == NULL) == (op == ANYOF))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case MULTIBYTECODE:\n\t    if (has_mbyte)\n\t    {\n\t\tint\ti, len;\n\t\tchar_u\t*opnd;\n\t\tint\topndc = 0, inpc;\n\n\t\topnd = OPERAND(scan);\n\t\t// Safety check (just in case 'encoding' was changed since\n\t\t// compiling the program).\n\t\tif ((len = (*mb_ptr2len)(opnd)) < 2)\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    break;\n\t\t}\n\t\tif (enc_utf8)\n\t\t    opndc = utf_ptr2char(opnd);\n\t\tif (enc_utf8 && utf_iscomposing(opndc))\n\t\t{\n\t\t    // When only a composing char is given match at any\n\t\t    // position where that composing char appears.\n\t\t    status = RA_NOMATCH;\n\t\t    for (i = 0; rex.input[i] != NUL;\n\t\t\t\t\t\ti += utf_ptr2len(rex.input + i))\n\t\t    {\n\t\t\tinpc = utf_ptr2char(rex.input + i);\n\t\t\tif (!utf_iscomposing(inpc))\n\t\t\t{\n\t\t\t    if (i > 0)\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (opndc == inpc)\n\t\t\t{\n\t\t\t    // Include all following composing chars.\n\t\t\t    len = i + utfc_ptr2len(rex.input + i);\n\t\t\t    status = RA_MATCH;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    for (i = 0; i < len; ++i)\n\t\t\tif (opnd[i] != rex.input[i])\n\t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    break;\n\t\t\t}\n\t\trex.input += len;\n\t    }\n\t    else\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_COMPOSING:\n\t    if (enc_utf8)\n\t    {\n\t\t// Skip composing characters.\n\t\twhile (utf_iscomposing(utf_ptr2char(rex.input)))\n\t\t    MB_CPTR_ADV(rex.input);\n\t    }\n\t    break;\n\n\t  case NOTHING:\n\t    break;\n\n\t  case BACK:\n\t    {\n\t\tint\t\ti;\n\t\tbackpos_T\t*bp;\n\n\t\t// When we run into BACK we need to check if we don't keep\n\t\t// looping without matching any input.  The second and later\n\t\t// times a BACK is encountered it fails if the input is still\n\t\t// at the same position as the previous time.\n\t\t// The positions are stored in \"backpos\" and found by the\n\t\t// current value of \"scan\", the position in the RE program.\n\t\tbp = (backpos_T *)backpos.ga_data;\n\t\tfor (i = 0; i < backpos.ga_len; ++i)\n\t\t    if (bp[i].bp_scan == scan)\n\t\t\tbreak;\n\t\tif (i == backpos.ga_len)\n\t\t{\n\t\t    // First time at this BACK, make room to store the pos.\n\t\t    if (ga_grow(&backpos, 1) == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\t// get \"ga_data\" again, it may have changed\n\t\t\tbp = (backpos_T *)backpos.ga_data;\n\t\t\tbp[i].bp_scan = scan;\n\t\t\t++backpos.ga_len;\n\t\t    }\n\t\t}\n\t\telse if (reg_save_equal(&bp[i].bp_pos))\n\t\t    // Still at same position as last time, fail.\n\t\t    status = RA_NOMATCH;\n\n\t\tif (status != RA_FAIL && status != RA_NOMATCH)\n\t\t    reg_save(&bp[i].bp_pos, &backpos);\n\t    }\n\t    break;\n\n\t  case MOPEN + 0:   // Match start: \\zs\n\t  case MOPEN + 1:   // \\(\n\t  case MOPEN + 2:\n\t  case MOPEN + 3:\n\t  case MOPEN + 4:\n\t  case MOPEN + 5:\n\t  case MOPEN + 6:\n\t  case MOPEN + 7:\n\t  case MOPEN + 8:\n\t  case MOPEN + 9:\n\t    {\n\t\tno = op - MOPEN;\n\t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MOPEN, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &rex.reg_startpos[no],\n\t\t\t\t\t\t\t  &rex.reg_startp[no]);\n\t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\t    break;\n\n\t  case NOPEN:\t    // \\%(\n\t  case NCLOSE:\t    // \\) after \\%(\n\t\tif (regstack_push(RS_NOPEN, scan) == NULL)\n\t\t    status = RA_FAIL;\n\t\t// We simply continue and handle the result when done.\n\t\tbreak;\n\n#ifdef FEAT_SYN_HL\n\t  case ZOPEN + 1:\n\t  case ZOPEN + 2:\n\t  case ZOPEN + 3:\n\t  case ZOPEN + 4:\n\t  case ZOPEN + 5:\n\t  case ZOPEN + 6:\n\t  case ZOPEN + 7:\n\t  case ZOPEN + 8:\n\t  case ZOPEN + 9:\n\t    {\n\t\tno = op - ZOPEN;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZOPEN, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_startzpos[no],\n\t\t\t\t\t\t\t     &reg_startzp[no]);\n\t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\t    break;\n#endif\n\n\t  case MCLOSE + 0:  // Match end: \\ze\n\t  case MCLOSE + 1:  // \\)\n\t  case MCLOSE + 2:\n\t  case MCLOSE + 3:\n\t  case MCLOSE + 4:\n\t  case MCLOSE + 5:\n\t  case MCLOSE + 6:\n\t  case MCLOSE + 7:\n\t  case MCLOSE + 8:\n\t  case MCLOSE + 9:\n\t    {\n\t\tno = op - MCLOSE;\n\t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &rex.reg_endpos[no],\n\t\t\t\t\t\t\t    &rex.reg_endp[no]);\n\t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case ZCLOSE + 1:  // \\) after \\z(\n\t  case ZCLOSE + 2:\n\t  case ZCLOSE + 3:\n\t  case ZCLOSE + 4:\n\t  case ZCLOSE + 5:\n\t  case ZCLOSE + 6:\n\t  case ZCLOSE + 7:\n\t  case ZCLOSE + 8:\n\t  case ZCLOSE + 9:\n\t    {\n\t\tno = op - ZCLOSE;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_endzpos[no],\n\t\t\t\t\t\t\t      &reg_endzp[no]);\n\t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\t    break;\n#endif\n\n\t  case BACKREF + 1:\n\t  case BACKREF + 2:\n\t  case BACKREF + 3:\n\t  case BACKREF + 4:\n\t  case BACKREF + 5:\n\t  case BACKREF + 6:\n\t  case BACKREF + 7:\n\t  case BACKREF + 8:\n\t  case BACKREF + 9:\n\t    {\n\t\tint\t\tlen;\n\n\t\tno = op - BACKREF;\n\t\tcleanup_subexpr();\n\t\tif (!REG_MULTI)\t\t// Single-line regexp\n\t\t{\n\t\t    if (rex.reg_startp[no] == NULL || rex.reg_endp[no] == NULL)\n\t\t    {\n\t\t\t// Backref was not set: Match an empty string.\n\t\t\tlen = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Compare current input with back-ref in the same\n\t\t\t// line.\n\t\t\tlen = (int)(rex.reg_endp[no] - rex.reg_startp[no]);\n\t\t\tif (cstrncmp(rex.reg_startp[no], rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\t\t    }\n\t\t}\n\t\telse\t\t\t\t// Multi-line regexp\n\t\t{\n\t\t    if (rex.reg_startpos[no].lnum < 0\n\t\t\t\t\t\t|| rex.reg_endpos[no].lnum < 0)\n\t\t    {\n\t\t\t// Backref was not set: Match an empty string.\n\t\t\tlen = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (rex.reg_startpos[no].lnum == rex.lnum\n\t\t\t\t&& rex.reg_endpos[no].lnum == rex.lnum)\n\t\t\t{\n\t\t\t    // Compare back-ref within the current line.\n\t\t\t    len = rex.reg_endpos[no].col\n\t\t\t\t\t\t    - rex.reg_startpos[no].col;\n\t\t\t    if (cstrncmp(rex.line + rex.reg_startpos[no].col,\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\t\tstatus = RA_NOMATCH;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Messy situation: Need to compare between two\n\t\t\t    // lines.\n\t\t\t    int r = match_with_backref(\n\t\t\t\t\t    rex.reg_startpos[no].lnum,\n\t\t\t\t\t    rex.reg_startpos[no].col,\n\t\t\t\t\t    rex.reg_endpos[no].lnum,\n\t\t\t\t\t    rex.reg_endpos[no].col,\n\t\t\t\t\t    &len);\n\n\t\t\t    if (r != RA_MATCH)\n\t\t\t\tstatus = r;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t// Matched the backref, skip over it.\n\t\trex.input += len;\n\t    }\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case ZREF + 1:\n\t  case ZREF + 2:\n\t  case ZREF + 3:\n\t  case ZREF + 4:\n\t  case ZREF + 5:\n\t  case ZREF + 6:\n\t  case ZREF + 7:\n\t  case ZREF + 8:\n\t  case ZREF + 9:\n\t    {\n\t\tint\tlen;\n\n\t\tcleanup_zsubexpr();\n\t\tno = op - ZREF;\n\t\tif (re_extmatch_in != NULL\n\t\t\t&& re_extmatch_in->matches[no] != NULL)\n\t\t{\n\t\t    len = (int)STRLEN(re_extmatch_in->matches[no]);\n\t\t    if (cstrncmp(re_extmatch_in->matches[no],\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\tstatus = RA_NOMATCH;\n\t\t    else\n\t\t\trex.input += len;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Backref was not set: Match an empty string.\n\t\t}\n\t    }\n\t    break;\n#endif\n\n\t  case BRANCH:\n\t    {\n\t\tif (OP(next) != BRANCH) // No choice.\n\t\t    next = OPERAND(scan);\t// Avoid recursion.\n\t\telse\n\t\t{\n\t\t    rp = regstack_push(RS_BRANCH, scan);\n\t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t\tstatus = RA_BREAK;\t// rest is below\n\t\t}\n\t    }\n\t    break;\n\n\t  case BRACE_LIMITS:\n\t    {\n\t\tif (OP(next) == BRACE_SIMPLE)\n\t\t{\n\t\t    bl_minval = OPERAND_MIN(scan);\n\t\t    bl_maxval = OPERAND_MAX(scan);\n\t\t}\n\t\telse if (OP(next) >= BRACE_COMPLEX\n\t\t\t&& OP(next) < BRACE_COMPLEX + 10)\n\t\t{\n\t\t    no = OP(next) - BRACE_COMPLEX;\n\t\t    brace_min[no] = OPERAND_MIN(scan);\n\t\t    brace_max[no] = OPERAND_MAX(scan);\n\t\t    brace_count[no] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    internal_error(\"BRACE_LIMITS\");\n\t\t    status = RA_FAIL;\n\t\t}\n\t    }\n\t    break;\n\n\t  case BRACE_COMPLEX + 0:\n\t  case BRACE_COMPLEX + 1:\n\t  case BRACE_COMPLEX + 2:\n\t  case BRACE_COMPLEX + 3:\n\t  case BRACE_COMPLEX + 4:\n\t  case BRACE_COMPLEX + 5:\n\t  case BRACE_COMPLEX + 6:\n\t  case BRACE_COMPLEX + 7:\n\t  case BRACE_COMPLEX + 8:\n\t  case BRACE_COMPLEX + 9:\n\t    {\n\t\tno = op - BRACE_COMPLEX;\n\t\t++brace_count[no];\n\n\t\t// If not matched enough times yet, try one more\n\t\tif (brace_count[no] <= (brace_min[no] <= brace_max[no]\n\t\t\t\t\t     ? brace_min[no] : brace_max[no]))\n\t\t{\n\t\t    rp = regstack_push(RS_BRCPLX_MORE, scan);\n\t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\trp->rs_no = no;\n\t\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tnext = OPERAND(scan);\n\t\t\t// We continue and handle the result when done.\n\t\t    }\n\t\t    break;\n\t\t}\n\n\t\t// If matched enough times, may try matching some more\n\t\tif (brace_min[no] <= brace_max[no])\n\t\t{\n\t\t    // Range is the normal way around, use longest match\n\t\t    if (brace_count[no] <= brace_max[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_LONG, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    rp->rs_no = no;\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t    next = OPERAND(scan);\n\t\t\t    // We continue and handle the result when done.\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Range is backwards, use shortest match first\n\t\t    if (brace_count[no] <= brace_min[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t    // We continue and handle the result when done.\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\t  case BRACE_SIMPLE:\n\t  case STAR:\n\t  case PLUS:\n\t    {\n\t\tregstar_T\trst;\n\n\t\t// Lookahead to avoid useless match attempts when we know\n\t\t// what character comes next.\n\t\tif (OP(next) == EXACTLY)\n\t\t{\n\t\t    rst.nextb = *OPERAND(next);\n\t\t    if (rex.reg_ic)\n\t\t    {\n\t\t\tif (MB_ISUPPER(rst.nextb))\n\t\t\t    rst.nextb_ic = MB_TOLOWER(rst.nextb);\n\t\t\telse\n\t\t\t    rst.nextb_ic = MB_TOUPPER(rst.nextb);\n\t\t    }\n\t\t    else\n\t\t\trst.nextb_ic = rst.nextb;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.nextb = NUL;\n\t\t    rst.nextb_ic = NUL;\n\t\t}\n\t\tif (op != BRACE_SIMPLE)\n\t\t{\n\t\t    rst.minval = (op == STAR) ? 0 : 1;\n\t\t    rst.maxval = MAX_LIMIT;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.minval = bl_minval;\n\t\t    rst.maxval = bl_maxval;\n\t\t}\n\n\t\t// When maxval > minval, try matching as much as possible, up\n\t\t// to maxval.  When maxval < minval, try matching at least the\n\t\t// minimal number (since the range is backwards, that's also\n\t\t// maxval!).\n\t\trst.count = regrepeat(OPERAND(scan), rst.maxval);\n\t\tif (got_int)\n\t\t{\n\t\t    status = RA_FAIL;\n\t\t    break;\n\t\t}\n\t\tif (rst.minval <= rst.maxval\n\t\t\t  ? rst.count >= rst.minval : rst.count >= rst.maxval)\n\t\t{\n\t\t    // It could match.  Prepare for trying to match what\n\t\t    // follows.  The code is below.  Parameters are stored in\n\t\t    // a regstar_T on the regstack.\n\t\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n\t\t    {\n\t\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\t\t\tstatus = RA_FAIL;\n\t\t    }\n\t\t    else if (ga_grow(&regstack, sizeof(regstar_T)) == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\tregstack.ga_len += sizeof(regstar_T);\n\t\t\trp = regstack_push(rst.minval <= rst.maxval\n\t\t\t\t\t? RS_STAR_LONG : RS_STAR_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    *(((regstar_T *)rp) - 1) = rst;\n\t\t\t    status = RA_BREAK;\t    // skip the restore bits\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    status = RA_NOMATCH;\n\n\t    }\n\t    break;\n\n\t  case NOMATCH:\n\t  case MATCH:\n\t  case SUBPAT:\n\t    rp = regstack_push(RS_NOMATCH, scan);\n\t    if (rp == NULL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\trp->rs_no = op;\n\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\tnext = OPERAND(scan);\n\t\t// We continue and handle the result when done.\n\t    }\n\t    break;\n\n\t  case BEHIND:\n\t  case NOBEHIND:\n\t    // Need a bit of room to store extra positions.\n\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n\t    {\n\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\t\tstatus = RA_FAIL;\n\t    }\n\t    else if (ga_grow(&regstack, sizeof(regbehind_T)) == FAIL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\tregstack.ga_len += sizeof(regbehind_T);\n\t\trp = regstack_push(RS_BEHIND1, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    // Need to save the subexpr to be able to restore them\n\t\t    // when there is a match but we don't use it.\n\t\t    save_subexpr(((regbehind_T *)rp) - 1);\n\n\t\t    rp->rs_no = op;\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t    // First try if what follows matches.  If it does then we\n\t\t    // check the behind match by looping.\n\t\t}\n\t    }\n\t    break;\n\n\t  case BHPOS:\n\t    if (REG_MULTI)\n\t    {\n\t\tif (behind_pos.rs_u.pos.col != (colnr_T)(rex.input - rex.line)\n\t\t\t|| behind_pos.rs_u.pos.lnum != rex.lnum)\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    else if (behind_pos.rs_u.ptr != rex.input)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case NEWL:\n\t    if ((c != NUL || !REG_MULTI || rex.lnum > rex.reg_maxline\n\t\t\t     || rex.reg_line_lbr)\n\t\t\t\t\t   && (c != '\\n' || !rex.reg_line_lbr))\n\t\tstatus = RA_NOMATCH;\n\t    else if (rex.reg_line_lbr)\n\t\tADVANCE_REGINPUT();\n\t    else\n\t\treg_nextline();\n\t    break;\n\n\t  case END:\n\t    status = RA_MATCH;\t// Success!\n\t    break;\n\n\t  default:\n\t    iemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\t    printf(\"Illegal op code %d\\n\", op);\n#endif\n\t    status = RA_FAIL;\n\t    break;\n\t  }\n\t}\n\n\t// If we can't continue sequentially, break the inner loop.\n\tif (status != RA_CONT)\n\t    break;\n\n\t// Continue in inner loop, advance to next item.\n\tscan = next;\n\n    } // end of inner loop\n\n    // If there is something on the regstack execute the code for the state.\n    // If the state is popped then loop and use the older state.\n    while (regstack.ga_len > 0 && status != RA_FAIL)\n    {\n\trp = (regitem_T *)((char *)regstack.ga_data + regstack.ga_len) - 1;\n\tswitch (rp->rs_state)\n\t{\n\t  case RS_NOPEN:\n\t    // Result is passed on as-is, simply pop the state.\n\t    regstack_pop(&scan);\n\t    break;\n\n\t  case RS_MOPEN:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &rex.reg_startpos[rp->rs_no],\n\t\t\t\t\t\t  &rex.reg_startp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case RS_ZOPEN:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_startzpos[rp->rs_no],\n\t\t\t\t\t\t &reg_startzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#endif\n\n\t  case RS_MCLOSE:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &rex.reg_endpos[rp->rs_no],\n\t\t\t\t\t\t    &rex.reg_endp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case RS_ZCLOSE:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_endzpos[rp->rs_no],\n\t\t\t\t\t\t   &reg_endzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#endif\n\n\t  case RS_BRANCH:\n\t    if (status == RA_MATCH)\n\t\t// this branch matched, use it\n\t\tregstack_pop(&scan);\n\t    else\n\t    {\n\t\tif (status != RA_BREAK)\n\t\t{\n\t\t    // After a non-matching branch: try next one.\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t    scan = rp->rs_scan;\n\t\t}\n\t\tif (scan == NULL || OP(scan) != BRANCH)\n\t\t{\n\t\t    // no more branches, didn't find a match\n\t\t    status = RA_NOMATCH;\n\t\t    regstack_pop(&scan);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Prepare to try a branch.\n\t\t    rp->rs_scan = regnext(scan);\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t    scan = OPERAND(scan);\n\t\t}\n\t    }\n\t    break;\n\n\t  case RS_BRCPLX_MORE:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\t--brace_count[rp->rs_no];\t// decrement match count\n\t    }\n\t    regstack_pop(&scan);\n\t    break;\n\n\t  case RS_BRCPLX_LONG:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\t// There was no match, but we did find enough matches.\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\t--brace_count[rp->rs_no];\n\t\t// continue with the items after \"\\{}\"\n\t\tstatus = RA_CONT;\n\t    }\n\t    regstack_pop(&scan);\n\t    if (status == RA_CONT)\n\t\tscan = regnext(scan);\n\t    break;\n\n\t  case RS_BRCPLX_SHORT:\n\t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status == RA_NOMATCH)\n\t\t// There was no match, try to match one more item.\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t    regstack_pop(&scan);\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\tscan = OPERAND(scan);\n\t\tstatus = RA_CONT;\n\t    }\n\t    break;\n\n\t  case RS_NOMATCH:\n\t    // Pop the state.  If the operand matches for NOMATCH or\n\t    // doesn't match for MATCH/SUBPAT, we fail.  Otherwise backup,\n\t    // except for SUBPAT, and continue with the next item.\n\t    if (status == (rp->rs_no == NOMATCH ? RA_MATCH : RA_NOMATCH))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t    {\n\t\tstatus = RA_CONT;\n\t\tif (rp->rs_no != SUBPAT)\t// zero-width\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t    }\n\t    regstack_pop(&scan);\n\t    if (status == RA_CONT)\n\t\tscan = regnext(scan);\n\t    break;\n\n\t  case RS_BEHIND1:\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\t    }\n\t    else\n\t    {\n\t\t// The stuff after BEHIND/NOBEHIND matches.  Now try if\n\t\t// the behind part does (not) match before the current\n\t\t// position in the input.  This must be done at every\n\t\t// position in the input and checking if the match ends at\n\t\t// the current position.\n\n\t\t// save the position after the found match for next\n\t\treg_save(&(((regbehind_T *)rp) - 1)->save_after, &backpos);\n\n\t\t// Start looking for a match with operand at the current\n\t\t// position.  Go back one character until we find the\n\t\t// result, hitting the start of the line or the previous\n\t\t// line (for multi-line matching).\n\t\t// Set behind_pos to where the match should end, BHPOS\n\t\t// will match it.  Save the current value.\n\t\t(((regbehind_T *)rp) - 1)->save_behind = behind_pos;\n\t\tbehind_pos = rp->rs_un.regsave;\n\n\t\trp->rs_state = RS_BEHIND2;\n\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\tscan = OPERAND(rp->rs_scan) + 4;\n\t    }\n\t    break;\n\n\t  case RS_BEHIND2:\n\t    // Looping for BEHIND / NOBEHIND match.\n\t    if (status == RA_MATCH && reg_save_equal(&behind_pos))\n\t    {\n\t\t// found a match that ends where \"next\" started\n\t\tbehind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n\t\tif (rp->rs_no == BEHIND)\n\t\t    reg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\t\t\t\t\t\t\t\t    &backpos);\n\t\telse\n\t\t{\n\t\t    // But we didn't want a match.  Need to restore the\n\t\t    // subexpr, because what follows matched, so they have\n\t\t    // been set.\n\t\t    status = RA_NOMATCH;\n\t\t    restore_subexpr(((regbehind_T *)rp) - 1);\n\t\t}\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\t    }\n\t    else\n\t    {\n\t\tlong limit;\n\n\t\t// No match or a match that doesn't end where we want it: Go\n\t\t// back one character.  May go to previous line once.\n\t\tno = OK;\n\t\tlimit = OPERAND_MIN(rp->rs_scan);\n\t\tif (REG_MULTI)\n\t\t{\n\t\t    if (limit > 0\n\t\t\t    && ((rp->rs_un.regsave.rs_u.pos.lnum\n\t\t\t\t\t\t    < behind_pos.rs_u.pos.lnum\n\t\t\t\t    ? (colnr_T)STRLEN(rex.line)\n\t\t\t\t    : behind_pos.rs_u.pos.col)\n\t\t\t\t- rp->rs_un.regsave.rs_u.pos.col >= limit))\n\t\t\tno = FAIL;\n\t\t    else if (rp->rs_un.regsave.rs_u.pos.col == 0)\n\t\t    {\n\t\t\tif (rp->rs_un.regsave.rs_u.pos.lnum\n\t\t\t\t\t< behind_pos.rs_u.pos.lnum\n\t\t\t\t|| reg_getline(\n\t\t\t\t\t--rp->rs_un.regsave.rs_u.pos.lnum)\n\t\t\t\t\t\t\t\t  == NULL)\n\t\t\t    no = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t\t    rp->rs_un.regsave.rs_u.pos.col =\n\t\t\t\t\t\t (colnr_T)STRLEN(rex.line);\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t{\n\t\t\t    char_u *line =\n\t\t\t\t  reg_getline(rp->rs_un.regsave.rs_u.pos.lnum);\n\n\t\t\t    rp->rs_un.regsave.rs_u.pos.col -=\n\t\t\t\t(*mb_head_off)(line, line\n\t\t\t\t    + rp->rs_un.regsave.rs_u.pos.col - 1) + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t    --rp->rs_un.regsave.rs_u.pos.col;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (rp->rs_un.regsave.rs_u.ptr == rex.line)\n\t\t\tno = FAIL;\n\t\t    else\n\t\t    {\n\t\t\tMB_PTR_BACK(rex.line, rp->rs_un.regsave.rs_u.ptr);\n\t\t\tif (limit > 0 && (long)(behind_pos.rs_u.ptr\n\t\t\t\t     - rp->rs_un.regsave.rs_u.ptr) > limit)\n\t\t\t    no = FAIL;\n\t\t    }\n\t\t}\n\t\tif (no == OK)\n\t\t{\n\t\t    // Advanced, prepare for finding match again.\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t    scan = OPERAND(rp->rs_scan) + 4;\n\t\t    if (status == RA_MATCH)\n\t\t    {\n\t\t\t// We did match, so subexpr may have been changed,\n\t\t\t// need to restore them for the next try.\n\t\t\tstatus = RA_NOMATCH;\n\t\t\trestore_subexpr(((regbehind_T *)rp) - 1);\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Can't advance.  For NOBEHIND that's a match.\n\t\t    behind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n\t\t    if (rp->rs_no == NOBEHIND)\n\t\t    {\n\t\t\treg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\t\t\t\t\t\t\t\t    &backpos);\n\t\t\tstatus = RA_MATCH;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// We do want a proper match.  Need to restore the\n\t\t\t// subexpr if we had a match, because they may have\n\t\t\t// been set.\n\t\t\tif (status == RA_MATCH)\n\t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    restore_subexpr(((regbehind_T *)rp) - 1);\n\t\t\t}\n\t\t    }\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regbehind_T);\n\t\t}\n\t    }\n\t    break;\n\n\t  case RS_STAR_LONG:\n\t  case RS_STAR_SHORT:\n\t    {\n\t\tregstar_T\t    *rst = ((regstar_T *)rp) - 1;\n\n\t\tif (status == RA_MATCH)\n\t\t{\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regstar_T);\n\t\t    break;\n\t\t}\n\n\t\t// Tried once already, restore input pointers.\n\t\tif (status != RA_BREAK)\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\n\t\t// Repeat until we found a position where it could match.\n\t\tfor (;;)\n\t\t{\n\t\t    if (status != RA_BREAK)\n\t\t    {\n\t\t\t// Tried first position already, advance.\n\t\t\tif (rp->rs_state == RS_STAR_LONG)\n\t\t\t{\n\t\t\t    // Trying for longest match, but couldn't or\n\t\t\t    // didn't match -- back up one char.\n\t\t\t    if (--rst->count < rst->minval)\n\t\t\t\tbreak;\n\t\t\t    if (rex.input == rex.line)\n\t\t\t    {\n\t\t\t\t// backup to last char of previous line\n\t\t\t\tif (rex.lnum == 0)\n\t\t\t\t{\n\t\t\t\t    status = RA_NOMATCH;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t\t--rex.lnum;\n\t\t\t\trex.line = reg_getline(rex.lnum);\n\t\t\t\t// Just in case regrepeat() didn't count\n\t\t\t\t// right.\n\t\t\t\tif (rex.line == NULL)\n\t\t\t\t    break;\n\t\t\t\trex.input = rex.line + STRLEN(rex.line);\n\t\t\t\tfast_breakcheck();\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tMB_PTR_BACK(rex.line, rex.input);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Range is backwards, use shortest match first.\n\t\t\t    // Careful: maxval and minval are exchanged!\n\t\t\t    // Couldn't or didn't match: try advancing one\n\t\t\t    // char.\n\t\t\t    if (rst->count == rst->minval\n\t\t\t\t  || regrepeat(OPERAND(rp->rs_scan), 1L) == 0)\n\t\t\t\tbreak;\n\t\t\t    ++rst->count;\n\t\t\t}\n\t\t\tif (got_int)\n\t\t\t    break;\n\t\t    }\n\t\t    else\n\t\t\tstatus = RA_NOMATCH;\n\n\t\t    // If it could match, try it.\n\t\t    if (rst->nextb == NUL || *rex.input == rst->nextb\n\t\t\t\t\t     || *rex.input == rst->nextb_ic)\n\t\t    {\n\t\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tscan = regnext(rp->rs_scan);\n\t\t\tstatus = RA_CONT;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (status != RA_CONT)\n\t\t{\n\t\t    // Failed.\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regstar_T);\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t    }\n\t    break;\n\t}\n\n\t// If we want to continue the inner loop or didn't pop a state\n\t// continue matching loop\n\tif (status == RA_CONT || rp == (regitem_T *)\n\t\t\t     ((char *)regstack.ga_data + regstack.ga_len) - 1)\n\t    break;\n    }\n\n    // May need to continue with the inner loop, starting at \"scan\".\n    if (status == RA_CONT)\n\tcontinue;\n\n    // If the regstack is empty or something failed we are done.\n    if (regstack.ga_len == 0 || status == RA_FAIL)\n    {\n\tif (scan == NULL)\n\t{\n\t    // We get here only if there's trouble -- normally \"case END\" is\n\t    // the terminating point.\n\t    iemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\t    printf(\"Premature EOL\\n\");\n#endif\n\t}\n\treturn (status == RA_MATCH);\n    }\n\n  } // End of loop until the regstack is empty.\n\n  // NOTREACHED\n}\n\n/*\n * regtry - try match of \"prog\" with at rex.line[\"col\"].\n * Returns 0 for failure, number of lines contained in the match otherwise.\n */\n    static long\nregtry(\n    bt_regprog_T\t*prog,\n    colnr_T\t\tcol,\n    proftime_T\t\t*tm,\t\t// timeout limit or NULL\n    int\t\t\t*timed_out)\t// flag set on timeout or NULL\n{\n    rex.input = rex.line + col;\n    rex.need_clear_subexpr = TRUE;\n#ifdef FEAT_SYN_HL\n    // Clear the external match subpointers if necessary.\n    rex.need_clear_zsubexpr = (prog->reghasz == REX_SET);\n#endif\n\n    if (regmatch(prog->program + 1, tm, timed_out) == 0)\n\treturn 0;\n\n    cleanup_subexpr();\n    if (REG_MULTI)\n    {\n\tif (rex.reg_startpos[0].lnum < 0)\n\t{\n\t    rex.reg_startpos[0].lnum = 0;\n\t    rex.reg_startpos[0].col = col;\n\t}\n\tif (rex.reg_endpos[0].lnum < 0)\n\t{\n\t    rex.reg_endpos[0].lnum = rex.lnum;\n\t    rex.reg_endpos[0].col = (int)(rex.input - rex.line);\n\t}\n\telse\n\t    // Use line number of \"\\ze\".\n\t    rex.lnum = rex.reg_endpos[0].lnum;\n    }\n    else\n    {\n\tif (rex.reg_startp[0] == NULL)\n\t    rex.reg_startp[0] = rex.line + col;\n\tif (rex.reg_endp[0] == NULL)\n\t    rex.reg_endp[0] = rex.input;\n    }\n#ifdef FEAT_SYN_HL\n    // Package any found \\z(...\\) matches for export. Default is none.\n    unref_extmatch(re_extmatch_out);\n    re_extmatch_out = NULL;\n\n    if (prog->reghasz == REX_SET)\n    {\n\tint\t\ti;\n\n\tcleanup_zsubexpr();\n\tre_extmatch_out = make_extmatch();\n\tif (re_extmatch_out == NULL)\n\t    return 0;\n\tfor (i = 0; i < NSUBEXP; i++)\n\t{\n\t    if (REG_MULTI)\n\t    {\n\t\t// Only accept single line matches.\n\t\tif (reg_startzpos[i].lnum >= 0\n\t\t\t&& reg_endzpos[i].lnum == reg_startzpos[i].lnum\n\t\t\t&& reg_endzpos[i].col >= reg_startzpos[i].col)\n\t\t    re_extmatch_out->matches[i] =\n\t\t\tvim_strnsave(reg_getline(reg_startzpos[i].lnum)\n\t\t\t\t\t\t       + reg_startzpos[i].col,\n\t\t\t\t   reg_endzpos[i].col - reg_startzpos[i].col);\n\t    }\n\t    else\n\t    {\n\t\tif (reg_startzp[i] != NULL && reg_endzp[i] != NULL)\n\t\t    re_extmatch_out->matches[i] =\n\t\t\t    vim_strnsave(reg_startzp[i],\n\t\t\t\t\t\treg_endzp[i] - reg_startzp[i]);\n\t    }\n\t}\n    }\n#endif\n    return 1 + rex.lnum;\n}\n\n/*\n * Match a regexp against a string (\"line\" points to the string) or multiple\n * lines (if \"line\" is NULL, use reg_getline()).\n * Returns 0 for failure, number of lines contained in the match otherwise.\n */\n    static long\nbt_regexec_both(\n    char_u\t*line,\n    colnr_T\tcol,\t\t// column to start looking for match\n    proftime_T\t*tm,\t\t// timeout limit or NULL\n    int\t\t*timed_out)\t// flag set on timeout or NULL\n{\n    bt_regprog_T    *prog;\n    char_u\t    *s;\n    long\t    retval = 0L;\n\n    // Create \"regstack\" and \"backpos\" if they are not allocated yet.\n    // We allocate *_INITIAL amount of bytes first and then set the grow size\n    // to much bigger value to avoid many malloc calls in case of deep regular\n    // expressions.\n    if (regstack.ga_data == NULL)\n    {\n\t// Use an item size of 1 byte, since we push different things\n\t// onto the regstack.\n\tga_init2(&regstack, 1, REGSTACK_INITIAL);\n\t(void)ga_grow(&regstack, REGSTACK_INITIAL);\n\tregstack.ga_growsize = REGSTACK_INITIAL * 8;\n    }\n\n    if (backpos.ga_data == NULL)\n    {\n\tga_init2(&backpos, sizeof(backpos_T), BACKPOS_INITIAL);\n\t(void)ga_grow(&backpos, BACKPOS_INITIAL);\n\tbackpos.ga_growsize = BACKPOS_INITIAL * 8;\n    }\n\n    if (REG_MULTI)\n    {\n\tprog = (bt_regprog_T *)rex.reg_mmatch->regprog;\n\tline = reg_getline((linenr_T)0);\n\trex.reg_startpos = rex.reg_mmatch->startpos;\n\trex.reg_endpos = rex.reg_mmatch->endpos;\n    }\n    else\n    {\n\tprog = (bt_regprog_T *)rex.reg_match->regprog;\n\trex.reg_startp = rex.reg_match->startp;\n\trex.reg_endp = rex.reg_match->endp;\n    }\n\n    // Be paranoid...\n    if (prog == NULL || line == NULL)\n    {\n\tiemsg(_(e_null_argument));\n\tgoto theend;\n    }\n\n    // Check validity of program.\n    if (prog_magic_wrong())\n\tgoto theend;\n\n    // If the start column is past the maximum column: no need to try.\n    if (rex.reg_maxcol > 0 && col >= rex.reg_maxcol)\n\tgoto theend;\n\n    // If pattern contains \"\\c\" or \"\\C\": overrule value of rex.reg_ic\n    if (prog->regflags & RF_ICASE)\n\trex.reg_ic = TRUE;\n    else if (prog->regflags & RF_NOICASE)\n\trex.reg_ic = FALSE;\n\n    // If pattern contains \"\\Z\" overrule value of rex.reg_icombine\n    if (prog->regflags & RF_ICOMBINE)\n\trex.reg_icombine = TRUE;\n\n    // If there is a \"must appear\" string, look for it.\n    if (prog->regmust != NULL)\n    {\n\tint c;\n\n\tif (has_mbyte)\n\t    c = (*mb_ptr2char)(prog->regmust);\n\telse\n\t    c = *prog->regmust;\n\ts = line + col;\n\n\t// This is used very often, esp. for \":global\".  Use three versions of\n\t// the loop to avoid overhead of conditions.\n\tif (!rex.reg_ic && !has_mbyte)\n\t    while ((s = vim_strbyte(s, c)) != NULL)\n\t    {\n\t\tif (cstrncmp(s, prog->regmust, &prog->regmlen) == 0)\n\t\t    break;\t\t// Found it.\n\t\t++s;\n\t    }\n\telse if (!rex.reg_ic || (!enc_utf8 && mb_char2len(c) > 1))\n\t    while ((s = vim_strchr(s, c)) != NULL)\n\t    {\n\t\tif (cstrncmp(s, prog->regmust, &prog->regmlen) == 0)\n\t\t    break;\t\t// Found it.\n\t\tMB_PTR_ADV(s);\n\t    }\n\telse\n\t    while ((s = cstrchr(s, c)) != NULL)\n\t    {\n\t\tif (cstrncmp(s, prog->regmust, &prog->regmlen) == 0)\n\t\t    break;\t\t// Found it.\n\t\tMB_PTR_ADV(s);\n\t    }\n\tif (s == NULL)\t\t// Not present.\n\t    goto theend;\n    }\n\n    rex.line = line;\n    rex.lnum = 0;\n    reg_toolong = FALSE;\n\n    // Simplest case: Anchored match need be tried only once.\n    if (prog->reganch)\n    {\n\tint\tc;\n\n\tif (has_mbyte)\n\t    c = (*mb_ptr2char)(rex.line + col);\n\telse\n\t    c = rex.line[col];\n\tif (prog->regstart == NUL\n\t\t|| prog->regstart == c\n\t\t|| (rex.reg_ic\n\t\t    && (((enc_utf8 && utf_fold(prog->regstart) == utf_fold(c)))\n\t\t\t|| (c < 255 && prog->regstart < 255 &&\n\t\t\t    MB_TOLOWER(prog->regstart) == MB_TOLOWER(c)))))\n\t    retval = regtry(prog, col, tm, timed_out);\n\telse\n\t    retval = 0;\n    }\n    else\n    {\n#ifdef FEAT_RELTIME\n\tint tm_count = 0;\n#endif\n\t// Messy cases:  unanchored match.\n\twhile (!got_int)\n\t{\n\t    if (prog->regstart != NUL)\n\t    {\n\t\t// Skip until the char we know it must start with.\n\t\t// Used often, do some work to avoid call overhead.\n\t\tif (!rex.reg_ic && !has_mbyte)\n\t\t    s = vim_strbyte(rex.line + col, prog->regstart);\n\t\telse\n\t\t    s = cstrchr(rex.line + col, prog->regstart);\n\t\tif (s == NULL)\n\t\t{\n\t\t    retval = 0;\n\t\t    break;\n\t\t}\n\t\tcol = (int)(s - rex.line);\n\t    }\n\n\t    // Check for maximum column to try.\n\t    if (rex.reg_maxcol > 0 && col >= rex.reg_maxcol)\n\t    {\n\t\tretval = 0;\n\t\tbreak;\n\t    }\n\n\t    retval = regtry(prog, col, tm, timed_out);\n\t    if (retval > 0)\n\t\tbreak;\n\n\t    // if not currently on the first line, get it again\n\t    if (rex.lnum != 0)\n\t    {\n\t\trex.lnum = 0;\n\t\trex.line = reg_getline((linenr_T)0);\n\t    }\n\t    if (rex.line[col] == NUL)\n\t\tbreak;\n\t    if (has_mbyte)\n\t\tcol += (*mb_ptr2len)(rex.line + col);\n\t    else\n\t\t++col;\n#ifdef FEAT_RELTIME\n\t    // Check for timeout once in a twenty times to avoid overhead.\n\t    if (tm != NULL && ++tm_count == 20)\n\t    {\n\t\ttm_count = 0;\n\t\tif (profile_passed_limit(tm))\n\t\t{\n\t\t    if (timed_out != NULL)\n\t\t\t*timed_out = TRUE;\n\t\t    break;\n\t\t}\n\t    }\n#endif\n\t}\n    }\n\ntheend:\n    // Free \"reg_tofree\" when it's a bit big.\n    // Free regstack and backpos if they are bigger than their initial size.\n    if (reg_tofreelen > 400)\n\tVIM_CLEAR(reg_tofree);\n    if (regstack.ga_maxlen > REGSTACK_INITIAL)\n\tga_clear(&regstack);\n    if (backpos.ga_maxlen > BACKPOS_INITIAL)\n\tga_clear(&backpos);\n\n    if (retval > 0)\n    {\n\t// Make sure the end is never before the start.  Can happen when \\zs\n\t// and \\ze are used.\n\tif (REG_MULTI)\n\t{\n\t    lpos_T *start = &rex.reg_mmatch->startpos[0];\n\t    lpos_T *end = &rex.reg_mmatch->endpos[0];\n\n\t    if (end->lnum < start->lnum\n\t\t\t|| (end->lnum == start->lnum && end->col < start->col))\n\t\trex.reg_mmatch->endpos[0] = rex.reg_mmatch->startpos[0];\n\t}\n\telse\n\t{\n\t    if (rex.reg_match->endp[0] < rex.reg_match->startp[0])\n\t\trex.reg_match->endp[0] = rex.reg_match->startp[0];\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Match a regexp against a string.\n * \"rmp->regprog\" is a compiled regexp as returned by vim_regcomp().\n * Uses curbuf for line count and 'iskeyword'.\n * if \"line_lbr\" is TRUE  consider a \"\\n\" in \"line\" to be a line break.\n *\n * Returns 0 for failure, number of lines contained in the match otherwise.\n */\n    static int\nbt_regexec_nl(\n    regmatch_T\t*rmp,\n    char_u\t*line,\t// string to match against\n    colnr_T\tcol,\t// column to start looking for match\n    int\t\tline_lbr)\n{\n    rex.reg_match = rmp;\n    rex.reg_mmatch = NULL;\n    rex.reg_maxline = 0;\n    rex.reg_line_lbr = line_lbr;\n    rex.reg_buf = curbuf;\n    rex.reg_win = NULL;\n    rex.reg_ic = rmp->rm_ic;\n    rex.reg_icombine = FALSE;\n    rex.reg_maxcol = 0;\n\n    return bt_regexec_both(line, col, NULL, NULL);\n}\n\n/*\n * Match a regexp against multiple lines.\n * \"rmp->regprog\" is a compiled regexp as returned by vim_regcomp().\n * Uses curbuf for line count and 'iskeyword'.\n *\n * Return zero if there is no match.  Return number of lines contained in the\n * match otherwise.\n */\n    static long\nbt_regexec_multi(\n    regmmatch_T\t*rmp,\n    win_T\t*win,\t\t// window in which to search or NULL\n    buf_T\t*buf,\t\t// buffer in which to search\n    linenr_T\tlnum,\t\t// nr of line to start looking for match\n    colnr_T\tcol,\t\t// column to start looking for match\n    proftime_T\t*tm,\t\t// timeout limit or NULL\n    int\t\t*timed_out)\t// flag set on timeout or NULL\n{\n    init_regexec_multi(rmp, win, buf, lnum);\n    return bt_regexec_both(NULL, col, tm, timed_out);\n}\n\n/*\n * Compare a number with the operand of RE_LNUM, RE_COL or RE_VCOL.\n */\n    static int\nre_num_cmp(long_u val, char_u *scan)\n{\n    long_u  n = OPERAND_MIN(scan);\n\n    if (OPERAND_CMP(scan) == '>')\n\treturn val > n;\n    if (OPERAND_CMP(scan) == '<')\n\treturn val < n;\n    return val == n;\n}\n\n#ifdef BT_REGEXP_DUMP\n\n/*\n * regdump - dump a regexp onto stdout in vaguely comprehensible form\n */\n    static void\nregdump(char_u *pattern, bt_regprog_T *r)\n{\n    char_u  *s;\n    int\t    op = EXACTLY;\t// Arbitrary non-END op.\n    char_u  *next;\n    char_u  *end = NULL;\n    FILE    *f;\n\n#ifdef BT_REGEXP_LOG\n    f = fopen(\"bt_regexp_log.log\", \"a\");\n#else\n    f = stdout;\n#endif\n    if (f == NULL)\n\treturn;\n    fprintf(f, \"-------------------------------------\\n\\r\\nregcomp(%s):\\r\\n\", pattern);\n\n    s = r->program + 1;\n    // Loop until we find the END that isn't before a referred next (an END\n    // can also appear in a NOMATCH operand).\n    while (op != END || s <= end)\n    {\n\top = OP(s);\n\tfprintf(f, \"%2d%s\", (int)(s - r->program), regprop(s)); // Where, what.\n\tnext = regnext(s);\n\tif (next == NULL)\t// Next ptr.\n\t    fprintf(f, \"(0)\");\n\telse\n\t    fprintf(f, \"(%d)\", (int)((s - r->program) + (next - s)));\n\tif (end < next)\n\t    end = next;\n\tif (op == BRACE_LIMITS)\n\t{\n\t    // Two ints\n\t    fprintf(f, \" minval %ld, maxval %ld\", OPERAND_MIN(s), OPERAND_MAX(s));\n\t    s += 8;\n\t}\n\telse if (op == BEHIND || op == NOBEHIND)\n\t{\n\t    // one int\n\t    fprintf(f, \" count %ld\", OPERAND_MIN(s));\n\t    s += 4;\n\t}\n\telse if (op == RE_LNUM || op == RE_COL || op == RE_VCOL)\n\t{\n\t    // one int plus comparator\n\t    fprintf(f, \" count %ld\", OPERAND_MIN(s));\n\t    s += 5;\n\t}\n\ts += 3;\n\tif (op == ANYOF || op == ANYOF + ADD_NL\n\t\t|| op == ANYBUT || op == ANYBUT + ADD_NL\n\t\t|| op == EXACTLY)\n\t{\n\t    // Literal string, where present.\n\t    fprintf(f, \"\\nxxxxxxxxx\\n\");\n\t    while (*s != NUL)\n\t\tfprintf(f, \"%c\", *s++);\n\t    fprintf(f, \"\\nxxxxxxxxx\\n\");\n\t    s++;\n\t}\n\tfprintf(f, \"\\r\\n\");\n    }\n\n    // Header fields of interest.\n    if (r->regstart != NUL)\n\tfprintf(f, \"start `%s' 0x%x; \", r->regstart < 256\n\t\t? (char *)transchar(r->regstart)\n\t\t: \"multibyte\", r->regstart);\n    if (r->reganch)\n\tfprintf(f, \"anchored; \");\n    if (r->regmust != NULL)\n\tfprintf(f, \"must have \\\"%s\\\"\", r->regmust);\n    fprintf(f, \"\\r\\n\");\n\n#ifdef BT_REGEXP_LOG\n    fclose(f);\n#endif\n}\n#endif\t    // BT_REGEXP_DUMP\n\n#ifdef DEBUG\n/*\n * regprop - printable representation of opcode\n */\n    static char_u *\nregprop(char_u *op)\n{\n    char\t    *p;\n    static char\t    buf[50];\n\n    STRCPY(buf, \":\");\n\n    switch ((int) OP(op))\n    {\n      case BOL:\n\tp = \"BOL\";\n\tbreak;\n      case EOL:\n\tp = \"EOL\";\n\tbreak;\n      case RE_BOF:\n\tp = \"BOF\";\n\tbreak;\n      case RE_EOF:\n\tp = \"EOF\";\n\tbreak;\n      case CURSOR:\n\tp = \"CURSOR\";\n\tbreak;\n      case RE_VISUAL:\n\tp = \"RE_VISUAL\";\n\tbreak;\n      case RE_LNUM:\n\tp = \"RE_LNUM\";\n\tbreak;\n      case RE_MARK:\n\tp = \"RE_MARK\";\n\tbreak;\n      case RE_COL:\n\tp = \"RE_COL\";\n\tbreak;\n      case RE_VCOL:\n\tp = \"RE_VCOL\";\n\tbreak;\n      case BOW:\n\tp = \"BOW\";\n\tbreak;\n      case EOW:\n\tp = \"EOW\";\n\tbreak;\n      case ANY:\n\tp = \"ANY\";\n\tbreak;\n      case ANY + ADD_NL:\n\tp = \"ANY+NL\";\n\tbreak;\n      case ANYOF:\n\tp = \"ANYOF\";\n\tbreak;\n      case ANYOF + ADD_NL:\n\tp = \"ANYOF+NL\";\n\tbreak;\n      case ANYBUT:\n\tp = \"ANYBUT\";\n\tbreak;\n      case ANYBUT + ADD_NL:\n\tp = \"ANYBUT+NL\";\n\tbreak;\n      case IDENT:\n\tp = \"IDENT\";\n\tbreak;\n      case IDENT + ADD_NL:\n\tp = \"IDENT+NL\";\n\tbreak;\n      case SIDENT:\n\tp = \"SIDENT\";\n\tbreak;\n      case SIDENT + ADD_NL:\n\tp = \"SIDENT+NL\";\n\tbreak;\n      case KWORD:\n\tp = \"KWORD\";\n\tbreak;\n      case KWORD + ADD_NL:\n\tp = \"KWORD+NL\";\n\tbreak;\n      case SKWORD:\n\tp = \"SKWORD\";\n\tbreak;\n      case SKWORD + ADD_NL:\n\tp = \"SKWORD+NL\";\n\tbreak;\n      case FNAME:\n\tp = \"FNAME\";\n\tbreak;\n      case FNAME + ADD_NL:\n\tp = \"FNAME+NL\";\n\tbreak;\n      case SFNAME:\n\tp = \"SFNAME\";\n\tbreak;\n      case SFNAME + ADD_NL:\n\tp = \"SFNAME+NL\";\n\tbreak;\n      case PRINT:\n\tp = \"PRINT\";\n\tbreak;\n      case PRINT + ADD_NL:\n\tp = \"PRINT+NL\";\n\tbreak;\n      case SPRINT:\n\tp = \"SPRINT\";\n\tbreak;\n      case SPRINT + ADD_NL:\n\tp = \"SPRINT+NL\";\n\tbreak;\n      case WHITE:\n\tp = \"WHITE\";\n\tbreak;\n      case WHITE + ADD_NL:\n\tp = \"WHITE+NL\";\n\tbreak;\n      case NWHITE:\n\tp = \"NWHITE\";\n\tbreak;\n      case NWHITE + ADD_NL:\n\tp = \"NWHITE+NL\";\n\tbreak;\n      case DIGIT:\n\tp = \"DIGIT\";\n\tbreak;\n      case DIGIT + ADD_NL:\n\tp = \"DIGIT+NL\";\n\tbreak;\n      case NDIGIT:\n\tp = \"NDIGIT\";\n\tbreak;\n      case NDIGIT + ADD_NL:\n\tp = \"NDIGIT+NL\";\n\tbreak;\n      case HEX:\n\tp = \"HEX\";\n\tbreak;\n      case HEX + ADD_NL:\n\tp = \"HEX+NL\";\n\tbreak;\n      case NHEX:\n\tp = \"NHEX\";\n\tbreak;\n      case NHEX + ADD_NL:\n\tp = \"NHEX+NL\";\n\tbreak;\n      case OCTAL:\n\tp = \"OCTAL\";\n\tbreak;\n      case OCTAL + ADD_NL:\n\tp = \"OCTAL+NL\";\n\tbreak;\n      case NOCTAL:\n\tp = \"NOCTAL\";\n\tbreak;\n      case NOCTAL + ADD_NL:\n\tp = \"NOCTAL+NL\";\n\tbreak;\n      case WORD:\n\tp = \"WORD\";\n\tbreak;\n      case WORD + ADD_NL:\n\tp = \"WORD+NL\";\n\tbreak;\n      case NWORD:\n\tp = \"NWORD\";\n\tbreak;\n      case NWORD + ADD_NL:\n\tp = \"NWORD+NL\";\n\tbreak;\n      case HEAD:\n\tp = \"HEAD\";\n\tbreak;\n      case HEAD + ADD_NL:\n\tp = \"HEAD+NL\";\n\tbreak;\n      case NHEAD:\n\tp = \"NHEAD\";\n\tbreak;\n      case NHEAD + ADD_NL:\n\tp = \"NHEAD+NL\";\n\tbreak;\n      case ALPHA:\n\tp = \"ALPHA\";\n\tbreak;\n      case ALPHA + ADD_NL:\n\tp = \"ALPHA+NL\";\n\tbreak;\n      case NALPHA:\n\tp = \"NALPHA\";\n\tbreak;\n      case NALPHA + ADD_NL:\n\tp = \"NALPHA+NL\";\n\tbreak;\n      case LOWER:\n\tp = \"LOWER\";\n\tbreak;\n      case LOWER + ADD_NL:\n\tp = \"LOWER+NL\";\n\tbreak;\n      case NLOWER:\n\tp = \"NLOWER\";\n\tbreak;\n      case NLOWER + ADD_NL:\n\tp = \"NLOWER+NL\";\n\tbreak;\n      case UPPER:\n\tp = \"UPPER\";\n\tbreak;\n      case UPPER + ADD_NL:\n\tp = \"UPPER+NL\";\n\tbreak;\n      case NUPPER:\n\tp = \"NUPPER\";\n\tbreak;\n      case NUPPER + ADD_NL:\n\tp = \"NUPPER+NL\";\n\tbreak;\n      case BRANCH:\n\tp = \"BRANCH\";\n\tbreak;\n      case EXACTLY:\n\tp = \"EXACTLY\";\n\tbreak;\n      case NOTHING:\n\tp = \"NOTHING\";\n\tbreak;\n      case BACK:\n\tp = \"BACK\";\n\tbreak;\n      case END:\n\tp = \"END\";\n\tbreak;\n      case MOPEN + 0:\n\tp = \"MATCH START\";\n\tbreak;\n      case MOPEN + 1:\n      case MOPEN + 2:\n      case MOPEN + 3:\n      case MOPEN + 4:\n      case MOPEN + 5:\n      case MOPEN + 6:\n      case MOPEN + 7:\n      case MOPEN + 8:\n      case MOPEN + 9:\n\tsprintf(buf + STRLEN(buf), \"MOPEN%d\", OP(op) - MOPEN);\n\tp = NULL;\n\tbreak;\n      case MCLOSE + 0:\n\tp = \"MATCH END\";\n\tbreak;\n      case MCLOSE + 1:\n      case MCLOSE + 2:\n      case MCLOSE + 3:\n      case MCLOSE + 4:\n      case MCLOSE + 5:\n      case MCLOSE + 6:\n      case MCLOSE + 7:\n      case MCLOSE + 8:\n      case MCLOSE + 9:\n\tsprintf(buf + STRLEN(buf), \"MCLOSE%d\", OP(op) - MCLOSE);\n\tp = NULL;\n\tbreak;\n      case BACKREF + 1:\n      case BACKREF + 2:\n      case BACKREF + 3:\n      case BACKREF + 4:\n      case BACKREF + 5:\n      case BACKREF + 6:\n      case BACKREF + 7:\n      case BACKREF + 8:\n      case BACKREF + 9:\n\tsprintf(buf + STRLEN(buf), \"BACKREF%d\", OP(op) - BACKREF);\n\tp = NULL;\n\tbreak;\n      case NOPEN:\n\tp = \"NOPEN\";\n\tbreak;\n      case NCLOSE:\n\tp = \"NCLOSE\";\n\tbreak;\n#ifdef FEAT_SYN_HL\n      case ZOPEN + 1:\n      case ZOPEN + 2:\n      case ZOPEN + 3:\n      case ZOPEN + 4:\n      case ZOPEN + 5:\n      case ZOPEN + 6:\n      case ZOPEN + 7:\n      case ZOPEN + 8:\n      case ZOPEN + 9:\n\tsprintf(buf + STRLEN(buf), \"ZOPEN%d\", OP(op) - ZOPEN);\n\tp = NULL;\n\tbreak;\n      case ZCLOSE + 1:\n      case ZCLOSE + 2:\n      case ZCLOSE + 3:\n      case ZCLOSE + 4:\n      case ZCLOSE + 5:\n      case ZCLOSE + 6:\n      case ZCLOSE + 7:\n      case ZCLOSE + 8:\n      case ZCLOSE + 9:\n\tsprintf(buf + STRLEN(buf), \"ZCLOSE%d\", OP(op) - ZCLOSE);\n\tp = NULL;\n\tbreak;\n      case ZREF + 1:\n      case ZREF + 2:\n      case ZREF + 3:\n      case ZREF + 4:\n      case ZREF + 5:\n      case ZREF + 6:\n      case ZREF + 7:\n      case ZREF + 8:\n      case ZREF + 9:\n\tsprintf(buf + STRLEN(buf), \"ZREF%d\", OP(op) - ZREF);\n\tp = NULL;\n\tbreak;\n#endif\n      case STAR:\n\tp = \"STAR\";\n\tbreak;\n      case PLUS:\n\tp = \"PLUS\";\n\tbreak;\n      case NOMATCH:\n\tp = \"NOMATCH\";\n\tbreak;\n      case MATCH:\n\tp = \"MATCH\";\n\tbreak;\n      case BEHIND:\n\tp = \"BEHIND\";\n\tbreak;\n      case NOBEHIND:\n\tp = \"NOBEHIND\";\n\tbreak;\n      case SUBPAT:\n\tp = \"SUBPAT\";\n\tbreak;\n      case BRACE_LIMITS:\n\tp = \"BRACE_LIMITS\";\n\tbreak;\n      case BRACE_SIMPLE:\n\tp = \"BRACE_SIMPLE\";\n\tbreak;\n      case BRACE_COMPLEX + 0:\n      case BRACE_COMPLEX + 1:\n      case BRACE_COMPLEX + 2:\n      case BRACE_COMPLEX + 3:\n      case BRACE_COMPLEX + 4:\n      case BRACE_COMPLEX + 5:\n      case BRACE_COMPLEX + 6:\n      case BRACE_COMPLEX + 7:\n      case BRACE_COMPLEX + 8:\n      case BRACE_COMPLEX + 9:\n\tsprintf(buf + STRLEN(buf), \"BRACE_COMPLEX%d\", OP(op) - BRACE_COMPLEX);\n\tp = NULL;\n\tbreak;\n      case MULTIBYTECODE:\n\tp = \"MULTIBYTECODE\";\n\tbreak;\n      case NEWL:\n\tp = \"NEWL\";\n\tbreak;\n      default:\n\tsprintf(buf + STRLEN(buf), \"corrupt %d\", OP(op));\n\tp = NULL;\n\tbreak;\n    }\n    if (p != NULL)\n\tSTRCAT(buf, p);\n    return (char_u *)buf;\n}\n#endif\t    // DEBUG\n", "\" Tests for regexp in utf8 encoding\n\nfunc s:equivalence_test()\n  let str = \"A\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0414\u0496\u0414\u04ee\u0414\u201e\u0417\u049a\u0417\u04bb\u0417\u00a0\u0417\u04d9\u0418\u04ee\u0418\u04b0\u0418\u04d9\u0431\u0451\u0496\u0431\u04d9\u00a0\u0431\u04d9\u045e\u0431\u04d9\u04e8\u0431\u04d9\u04b0\u0431\u04d9\u0401\u0431\u04d9\u04d8\u0431\u04d9\u00ac\u0431\u04d9\u00ae\u0431\u04d9\u00b0\u0431\u04d9\u0406\u0431\u04d9\u0499\u0431\u04d9\u00b6 B\u0416\u0492\u0419\u0493\u0431\u0451\u04ee\u0431\u0451\u201e\u0431\u0451\u04b6 C\u0413\u04ae\u0414\u04b6\u0414\u04b2\u0414\u04a0\u0414\u04a2\u0416\u04ae\u0418\u00bb\u0431\u0451\u04b2\u043a\u04bb\u2019 D\u0414\u04ba\u0414\u0497\u0416\u04a0\u0431\u0451\u04a0\u0431\u0451\u04a2\u0431\u0451\u04ba\u0431\u0451\u0497\u0431\u0451\u2019 E\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0414\u2019\u0414\u201d\u0414\u2013\u0414\u04b3\u0414\u04a1\u0418\u201e\u0418\u04b6\u0418\u0401\u0419\u04b6\u0431\u0451\u201d\u0431\u0451\u2013\u0431\u0451\u04b3\u0431\u0451\u04a1\u0431\u0451\u04a3\u0431\u04d9\u0451\u0431\u04d9\u04d9\u0431\u04d9\u0458\u0431\u04d9\u04ab\u0431\u00bb\u0496\u0431\u00bb\u04ee\u0431\u00bb\u201e\u0431\u00bb\u04b6 F\u0416\u2018\u0431\u0451\u04bb\u043a\u04bb\u04b3 G\u0414\u04a3\u0414\u04bb\u0414\u00a0\u0414\u045e\u0416\u201c\u0417\u04e8\u0417\u04b0\u0417\u0499\u0431\u0451\u00a0\u043a\u04bb\u00a0 H\u0414\u04e8\u0414\u04b0\u0418\u04bb\u0431\u0451\u045e\u0431\u0451\u04e8\u0431\u0451\u04b0\u0431\u0451\u0401\u0431\u0451\u04d8\u0432\u04b1\u00a7 I\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0414\u0401\u0414\u04d8\u0414\u00ac\u0414\u00ae\u0414\u00b0\u0416\u2014\u0417\u04b8\u0418\u04b2\u0418\u04a0\u0431\u0451\u00ac\u0431\u0451\u00ae\u0431\u00bb\u04b2\u0431\u00bb\u04a0 J\u0414\u0499\u0419\u04b2 K\u0414\u00b6\u0416\u04b3\u0417\u0401\u0431\u0451\u00b0\u0431\u0451\u0406\u0431\u0451\u0499\u0432\u04b1\u00a9\u043a\u049b\u0496 L\u0414\u2116\u0414\u00bb\u0414\u04aa\u0414\u049d\u0415\u0492\u0418\u04aa\u0431\u0451\u00b6\u0431\u0451\u0451\u0431\u0451\u04d9\u0431\u0451\u0458\u0432\u04b1\u00a0 M\u0431\u0451\u04ab\u0431\u2116\u0496\u0431\u2116\u04ee N\u0413\u2018\u0415\u0493\u0415\u2026\u0415\u04ae\u0417\u0451\u0431\u2116\u201e\u0431\u2116\u04b6\u0431\u2116\u04b2\u0431\u2116\u04a0\u043a\u04bb\u04e8 O\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u04b3\u0415\u04a2\u0415\u04ba\u0415\u0497\u0416\u04b9\u0416\u00a0\u0417\u2018\u0417\u04d8\u0417\u00ac\u0417\u04ab\u0418\u04a2\u0418\u04ba\u0418\u04d8\u0418\u00ac\u0418\u00ae\u0418\u00b0\u0431\u2116\u04a2\u0431\u2116\u04ba\u0431\u2116\u0497\u0431\u2116\u2019\u0431\u00bb\u04a2\u0431\u00bb\u04ba\u0431\u00bb\u0497\u0431\u00bb\u2019\u0431\u00bb\u201d\u0431\u00bb\u2013\u0431\u00bb\u04b3\u0431\u00bb\u04a1\u0431\u00bb\u04a3\u0431\u00bb\u04bb\u0431\u00bb\u00a0\u0431\u00bb\u045e P\u0416\u04e8\u0431\u2116\u201d\u0431\u2116\u2013\u0432\u04b1\u0408 Q\u0419\u04a0 R\u0415\u201d\u0415\u2013\u0415\u04b3\u0418\u0497\u0418\u2019\u0419\u04a2\u0431\u2116\u04b3\u0431\u2116\u04a1\u0431\u2116\u04a3\u0431\u2116\u04bb\u0432\u04b1\u04e8\u043a\u04bb\u04b0 S\u0415\u04a1\u0415\u04a3\u0415\u04bb\u0415\u00a0\u0418\u04b3\u0431\u2116\u00a0\u0431\u2116\u045e\u0431\u2116\u04e8\u0431\u2116\u04b0\u0431\u2116\u0401\u0432\u04b1\u04ab\u043a\u04bb\u0401 T\u0415\u045e\u0415\u04e8\u0415\u04b0\u0416\u00ac\u0416\u00ae\u0418\u04a1\u0418\u04ab\u0431\u2116\u04d8\u0431\u2116\u00ac\u0431\u2116\u00ae\u0431\u2116\u00b0 U\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0415\u0401\u0415\u04d8\u0415\u00ac\u0415\u00ae\u0415\u00b0\u0416\u049c\u0417\u2022\u0417\u04b7\u0417\u04e3\u0417\u201c\u0417\u2014\u0418\u201d\u0418\u2013\u0419\u201e\u0431\u2116\u0406\u0431\u2116\u0499\u0431\u2116\u00b6\u0431\u2116\u0451\u0431\u2116\u04d9\u0431\u00bb\u04e8\u0431\u00bb\u04b0\u0431\u00bb\u0401\u0431\u00bb\u04d8\u0431\u00bb\u00ac\u0431\u00bb\u00ae\u0431\u00bb\u00b0  V\u0416\u0406\u0431\u2116\u0458\u0431\u2116\u04ab W\u0415\u0499\u0431\u04d9\u0496\u0431\u04d9\u04ee\u0431\u04d9\u201e\u0431\u04d9\u04b6\u0431\u04d9\u04b2 X\u0431\u04d9\u04a0\u0431\u04d9\u04a2 Y\u0413\u049b\u0415\u00b6\u0415\u0451\u0416\u0456\u0418\u0406\u0419\u04ba\u0431\u04d9\u04ba\u0431\u00bb\u0406\u0431\u00bb\u0499\u0431\u00bb\u00b6\u0431\u00bb\u0451 Z\u0415\u2116\u0415\u00bb\u0415\u04aa\u0416\u04e9\u0431\u04d9\u0497\u0431\u04d9\u2019\u0431\u04d9\u201d\u0432\u04b1\u00ab a\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0414\u0492\u0414\u0493\u0414\u2026\u0417\u04ba\u0417\u04b9\u0417\u040e\u0417\u00bb\u0418\u0493\u0418\u00a7\u0431\u00b6\u04b8\u0431\u0451\u0492\u0431\u04d9\u04a1\u0431\u04d9\u040e\u0431\u04d9\u0408\u0431\u04d9\u0498\u0431\u04d9\u00a7\u0431\u04d9\u00a9\u0431\u04d9\u00ab\u0431\u04d9\u04ef\u0431\u04d9\u049c\u0431\u04d9\u04b1\u0431\u04d9\u0456\u0431\u04d9\u04e9\u0431\u04d9\u00b7\u0432\u04b1\u0498 b\u0416\u0496\u0419\u201c\u0431\u04e9\u00ac\u0431\u00b6\u0496\u0431\u0451\u0493\u0431\u0451\u2026\u0431\u0451\u04ae c\u0413\u00a7\u0414\u04ae\u0414\u04af\u0414\u04e2\u0414\u049a\u0416\u04b2\u0418\u0458\u0431\u0451\u04af\u043a\u04bb\u201c\u043a\u04bb\u201d d\u0414\u04b8\u0414\u2018\u0419\u2014\u0431\u04e9\u04ef\u0431\u00b6\u0492\u0431\u00b6\u2018\u0431\u0451\u04e2\u0431\u0451\u049a\u0431\u0451\u04b8\u0431\u0451\u2018\u0431\u0451\u201c e\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0414\u201c\u0414\u2022\u0414\u2014\u0414\u04b7\u0414\u04e3\u0418\u2026\u0418\u04ae\u0418\u00a9\u0419\u04ae\u0431\u00b6\u2019\u0431\u0451\u2022\u0431\u0451\u2014\u0431\u0451\u04b7\u0431\u0451\u04e3\u0431\u0451\u049b\u0431\u04d9\u2116\u0431\u04d9\u00bb\u0431\u04d9\u04aa\u0431\u04d9\u049d\u0431\u00bb\u0492\u0431\u00bb\u0493\u0431\u00bb\u2026\u0431\u00bb\u04ae f\u0416\u2019\u0431\u04e9\u00ae\u0431\u00b6\u04ee\u0431\u0451\u04b9\u043a\u04bb\u04b7 g\u0414\u049b\u0414\u04b9\u0414\u040e\u0414\u0408\u0417\u0498\u0417\u00a7\u0417\u04e9\u0419\u00a0\u0431\u00b6\u0493\u0431\u0451\u040e\u043a\u04bb\u040e h\u0414\u0498\u0414\u00a7\u0418\u04b9\u0431\u0451\u0408\u0431\u0451\u0498\u0431\u0451\u00a7\u0431\u0451\u00a9\u0431\u0451\u00ab\u0431\u04d9\u2013\u0432\u04b1\u0401\u043a\u04bb\u2022 i\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0414\u00a9\u0414\u00ab\u0414\u04ef\u0414\u049c\u0417\u0497\u0418\u04af\u0418\u04e2\u0419\u0401\u0431\u00b6\u2013\u0431\u0451\u04ef\u0431\u0451\u049c\u0431\u00bb\u04af\u0431\u00bb\u04e2 j\u0414\u04e9\u0417\u00b0\u0419\u04af k\u0414\u00b7\u0416\u04b7\u0417\u00a9\u0431\u00b6\u201e\u0431\u0451\u04b1\u0431\u0451\u0456\u0431\u0451\u04e9\u0432\u04b1\u04d8\u043a\u049b\u0492 l\u0414\u04d9\u0414\u0458\u0414\u04ab\u0415\u0496\u0415\u04ee\u0416\u04a1\u0431\u0451\u00b7\u0431\u0451\u2116\u0431\u0451\u00bb\u0431\u0451\u04aa\u0432\u04b1\u040e m\u0431\u04e9\u049c\u0431\u0451\u049d\u0431\u2116\u0492\u0431\u2116\u0493 n\u0413\u04b1\u0415\u201e\u0415\u04b6\u0415\u04b2\u0415\u04af\u0417\u2116\u0431\u04e9\u00b0\u0431\u00b6\u04ae\u0431\u2116\u2026\u0431\u2116\u04ae\u0431\u2116\u04af\u0431\u2116\u04e2\u043a\u04bb\u0498 o\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u0451\u0415\u049a\u0415\u04b8\u0415\u2018\u0416\u040e\u0417\u2019\u0417\u00ab\u0417\u04ef\u0417\u049d\u0418\u049a\u0418\u04b8\u0418\u00ab\u0418\u04ef\u0418\u049c\u0418\u04b1\u0419\u04e9\u0431\u2116\u049a\u0431\u2116\u04b8\u0431\u2116\u2018\u0431\u2116\u201c\u0431\u00bb\u049a\u0431\u00bb\u04b8\u0431\u00bb\u2018\u0431\u00bb\u201c\u0431\u00bb\u2022\u0431\u00bb\u2014\u0431\u00bb\u04b7\u0431\u00bb\u04e3\u0431\u00bb\u049b\u0431\u00bb\u04b9\u0431\u00bb\u040e\u0431\u00bb\u0408 p\u0416\u0498\u0431\u04e9\u04b1\u0431\u04e9\u04aa\u0431\u00b6\u04b2\u0431\u2116\u2022\u0431\u2116\u2014 q\u0419\u04e2\u041a\u00a0 r\u0415\u2022\u0415\u2014\u0415\u04b7\u0418\u2018\u0418\u201c\u0419\u049a\u0419\u04aa\u0431\u04e9\u0406\u0431\u04e9\u0456\u0431\u00b6\u04af\u0431\u2116\u04e3\u0431\u2116\u049b\u0431\u2116\u04b9\u043a\u04bb\u00a7 s\u0415\u04e3\u0415\u049b\u0415\u04b9\u0415\u040e\u0418\u04b7\u0418\u049d\u0431\u04e9\u0499\u0431\u00b6\u04a0\u0431\u2116\u040e\u0431\u2116\u0408\u0431\u2116\u0498\u0431\u2116\u00a7\u0431\u2116\u00a9\u043a\u04bb\u00a9 t\u0415\u0408\u0415\u0498\u0415\u00a7\u0416\u00ab\u0416\u04ef\u0418\u04e3\u041a\u04b2\u0431\u04e9\u04e9\u0431\u2116\u00ab\u0431\u2116\u04ef\u0431\u2116\u049c\u0431\u2116\u04b1\u0431\u04d9\u2014\u0432\u04b1\u04b0 u\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0415\u00a9\u0415\u00ab\u0415\u04ef\u0415\u049c\u0415\u04b1\u0415\u0456\u0417\u04a1\u0417\u2013\u0416\u00b0\u0417\u201d\u0417\u04b3\u0417\u04a3\u0418\u2022\u0418\u2014\u041a\u04af\u0431\u04e9\u04ab\u0431\u00b6\u04b7\u0431\u2116\u0456\u0431\u2116\u04e9\u0431\u2116\u00b7\u0431\u2116\u2116\u0431\u2116\u00bb\u0431\u00bb\u0498\u0431\u00bb\u00a7\u0431\u00bb\u00a9\u0431\u00bb\u00ab\u0431\u00bb\u04ef\u0431\u00bb\u049c\u0431\u00bb\u04b1 v\u041a\u04e2\u0431\u00b6\u04a2\u0431\u2116\u04aa\u0431\u2116\u049d w\u0415\u04e9\u0431\u04d9\u0492\u0431\u04d9\u0493\u0431\u04d9\u2026\u0431\u04d9\u04ae\u0431\u04d9\u04af\u0431\u04d9\u04b3 x\u0431\u04d9\u04e2\u0431\u04d9\u049a y\u0413\u04aa\u0413\u049d\u0415\u00b7\u0416\u0499\u0418\u0456\u0419\u04b8\u0431\u04d9\u04b8\u0431\u04d9\u04b7\u0431\u00bb\u0456\u0431\u00bb\u04e9\u0431\u00bb\u00b7\u0431\u00bb\u2116 z\u0415\u04d9\u0415\u0458\u0415\u04ab\u0416\u00b6\u0431\u04e9\u00b6\u0431\u00b6\u04ba\u0431\u04d9\u2018\u0431\u04d9\u201c\u0431\u04d9\u2022\u0432\u04b1\u00ac\"\n  let groups = split(str)\n  for group1 in groups\n      for c in split(group1, '\\zs')\n\t\" next statement confirms that equivalence class matches every\n\t\" character in group\n        call assert_match('^[[=' .. c .. '=]]*$', group1)\n        for group2 in groups\n          if group2 != group1\n\t    \" next statement converts that equivalence class doesn't match\n\t    \" character in any other group\n            call assert_equal(-1, match(group2, '[[=' .. c .. '=]]'), c)\n          endif\n        endfor\n      endfor\n  endfor\nendfunc\n\nfunc Test_equivalence_re1()\n  set re=1\n  call s:equivalence_test()\n  set re=0\nendfunc\n\nfunc Test_equivalence_re2()\n  set re=2\n  call s:equivalence_test()\n  set re=0\nendfunc\n\nfunc s:classes_test()\n  if has('win32')\n    set iskeyword=@,48-57,_,192-255\n  endif\n  set isprint=@,161-255\n  call assert_equal('Mot\u0413\u00b6rhead', matchstr('Mot\u0413\u00b6rhead', '[[:print:]]\\+'))\n\n  let alnumchars = ''\n  let alphachars = ''\n  let backspacechar = ''\n  let blankchars = ''\n  let cntrlchars = ''\n  let digitchars = ''\n  let escapechar = ''\n  let graphchars = ''\n  let lowerchars = ''\n  let printchars = ''\n  let punctchars = ''\n  let returnchar = ''\n  let spacechars = ''\n  let tabchar = ''\n  let upperchars = ''\n  let xdigitchars = ''\n  let identchars = ''\n  let identchars1 = ''\n  let kwordchars = ''\n  let kwordchars1 = ''\n  let fnamechars = ''\n  let fnamechars1 = ''\n  let i = 1\n  while i <= 255\n    let c = nr2char(i)\n    if c =~ '[[:alpha:]]'\n      let alphachars .= c\n    endif\n    if c =~ '[[:alnum:]]'\n      let alnumchars .= c\n    endif\n    if c =~ '[[:backspace:]]'\n      let backspacechar .= c\n    endif\n    if c =~ '[[:blank:]]'\n      let blankchars .= c\n    endif\n    if c =~ '[[:cntrl:]]'\n      let cntrlchars .= c\n    endif\n    if c =~ '[[:digit:]]'\n      let digitchars .= c\n    endif\n    if c =~ '[[:escape:]]'\n      let escapechar .= c\n    endif\n    if c =~ '[[:graph:]]'\n      let graphchars .= c\n    endif\n    if c =~ '[[:lower:]]'\n      let lowerchars .= c\n    endif\n    if c =~ '[[:print:]]'\n      let printchars .= c\n    endif\n    if c =~ '[[:punct:]]'\n      let punctchars .= c\n    endif\n    if c =~ '[[:return:]]'\n      let returnchar .= c\n    endif\n    if c =~ '[[:space:]]'\n      let spacechars .= c\n    endif\n    if c =~ '[[:tab:]]'\n      let tabchar .= c\n    endif\n    if c =~ '[[:upper:]]'\n      let upperchars .= c\n    endif\n    if c =~ '[[:xdigit:]]'\n      let xdigitchars .= c\n    endif\n    if c =~ '[[:ident:]]'\n      let identchars .= c\n    endif\n    if c =~ '\\i'\n      let identchars1 .= c\n    endif\n    if c =~ '[[:keyword:]]'\n      let kwordchars .= c\n    endif\n    if c =~ '\\k'\n      let kwordchars1 .= c\n    endif\n    if c =~ '[[:fname:]]'\n      let fnamechars .= c\n    endif\n    if c =~ '\\f'\n      let fnamechars1 .= c\n    endif\n    let i += 1\n  endwhile\n\n  call assert_equal('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', alphachars)\n  call assert_equal('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', alnumchars)\n  call assert_equal(\"\\b\", backspacechar)\n  call assert_equal(\"\\t \", blankchars)\n  call assert_equal(\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\b\\t\\n\\x0b\\f\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\e\\x1c\\x1d\\x1e\\x1f\\x7f\", cntrlchars)\n  call assert_equal(\"0123456789\", digitchars)\n  call assert_equal(\"\\<Esc>\", escapechar)\n  call assert_equal('!\"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~', graphchars)\n  call assert_equal('abcdefghijklmnopqrstuvwxyz\u0412\u04e9\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d', lowerchars)\n  call assert_equal(' !\"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u0412\u00a0\u0412\u040e\u0412\u045e\u0412\u0408\u0412\u04e8\u0412\u0498\u0412\u04b0\u0412\u00a7\u0412\u0401\u0412\u00a9\u0412\u04d8\u0412\u00ab\u0412\u00ac\u0412\u04ef\u0412\u00ae\u0412\u049c\u0412\u00b0\u0412\u04b1\u0412\u0406\u0412\u0456\u0412\u0499\u0412\u04e9\u0412\u00b6\u0412\u00b7\u0412\u0451\u0412\u2116\u0412\u04d9\u0412\u00bb\u0412\u0458\u0412\u04aa\u0412\u04ab\u0412\u049d\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u2014\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u00b7\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d', printchars)\n  call assert_equal('!\"#$%&''()*+,-./:;<=>?@[\\]^_`{|}~', punctchars)\n  call assert_equal('ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb', upperchars)\n  call assert_equal(\"\\r\", returnchar)\n  call assert_equal(\"\\t\\n\\x0b\\f\\r \", spacechars)\n  call assert_equal(\"\\t\", tabchar)\n  call assert_equal('0123456789ABCDEFabcdef', xdigitchars)\n\n  if has('win32')\n    let identchars_ok = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\u0412\u0496\u0412\u0492\u0412\u04ee\u0412\u0493\u0412\u201e\u0412\u2026\u0412\u04b6\u0412\u04ae\u0412\u04b2\u0412\u04af\u0412\u04a0\u0412\u04e2\u0412\u04a2\u0412\u049a\u0412\u04ba\u0412\u04b8\u0412\u0497\u0412\u2018\u0412\u2019\u0412\u201c\u0412\u201d\u0412\u2022\u0412\u2013\u0412\u2014\u0412\u04b3\u0412\u04b7\u0412\u04a1\u0412\u04e3\u0412\u04a3\u0412\u049b\u0412\u04bb\u0412\u04b9\u0412\u00a0\u0412\u040e\u0412\u045e\u0412\u0408\u0412\u04e8\u0412\u0498\u0412\u04b0\u0412\u00a7\u0412\u04e9\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d'\n    let kwordchars_ok = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\u0412\u04e9\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u2014\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u00b7\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d'\n  else\n    let identchars_ok = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\u0412\u04e9\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u2014\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u00b7\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d'\n    let kwordchars_ok = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\u0412\u04e9\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u2014\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u00b7\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d'\n  endif\n\n  if has('win32')\n    let fnamechars_ok = '!#$%+,-./0123456789:=@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]_abcdefghijklmnopqrstuvwxyz{}~\u0412\u00a0\u0412\u040e\u0412\u045e\u0412\u0408\u0412\u04e8\u0412\u0498\u0412\u04b0\u0412\u00a7\u0412\u0401\u0412\u00a9\u0412\u04d8\u0412\u00ab\u0412\u00ac\u0412\u04ef\u0412\u00ae\u0412\u049c\u0412\u00b0\u0412\u04b1\u0412\u0406\u0412\u0456\u0412\u0499\u0412\u04e9\u0412\u00b6\u0412\u00b7\u0412\u0451\u0412\u2116\u0412\u04d9\u0412\u00bb\u0412\u0458\u0412\u04aa\u0412\u04ab\u0412\u049d\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u2014\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u00b7\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d'\n  elseif has('amiga')\n    let fnamechars_ok = '$+,-./0123456789:ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~\u0412\u00a0\u0412\u040e\u0412\u045e\u0412\u0408\u0412\u04e8\u0412\u0498\u0412\u04b0\u0412\u00a7\u0412\u0401\u0412\u00a9\u0412\u04d8\u0412\u00ab\u0412\u00ac\u0412\u04ef\u0412\u00ae\u0412\u049c\u0412\u00b0\u0412\u04b1\u0412\u0406\u0412\u0456\u0412\u0499\u0412\u04e9\u0412\u00b6\u0412\u00b7\u0412\u0451\u0412\u2116\u0412\u04d9\u0412\u00bb\u0412\u0458\u0412\u04aa\u0412\u04ab\u0412\u049d\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u2014\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u00b7\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d'\n  elseif has('vms')\n    let fnamechars_ok = '#$%+,-./0123456789:;<>ABCDEFGHIJKLMNOPQRSTUVWXYZ[]_abcdefghijklmnopqrstuvwxyz~\u0412\u00a0\u0412\u040e\u0412\u045e\u0412\u0408\u0412\u04e8\u0412\u0498\u0412\u04b0\u0412\u00a7\u0412\u0401\u0412\u00a9\u0412\u04d8\u0412\u00ab\u0412\u00ac\u0412\u04ef\u0412\u00ae\u0412\u049c\u0412\u00b0\u0412\u04b1\u0412\u0406\u0412\u0456\u0412\u0499\u0412\u04e9\u0412\u00b6\u0412\u00b7\u0412\u0451\u0412\u2116\u0412\u04d9\u0412\u00bb\u0412\u0458\u0412\u04aa\u0412\u04ab\u0412\u049d\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u2014\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u00b7\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d'\n  else\n    let fnamechars_ok = '#$%+,-./0123456789=ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~\u0412\u00a0\u0412\u040e\u0412\u045e\u0412\u0408\u0412\u04e8\u0412\u0498\u0412\u04b0\u0412\u00a7\u0412\u0401\u0412\u00a9\u0412\u04d8\u0412\u00ab\u0412\u00ac\u0412\u04ef\u0412\u00ae\u0412\u049c\u0412\u00b0\u0412\u04b1\u0412\u0406\u0412\u0456\u0412\u0499\u0412\u04e9\u0412\u00b6\u0412\u00b7\u0412\u0451\u0412\u2116\u0412\u04d9\u0412\u00bb\u0412\u0458\u0412\u04aa\u0412\u04ab\u0412\u049d\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u2014\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u00b7\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d'\n  endif\n\n  call assert_equal(identchars_ok, identchars)\n  call assert_equal(kwordchars_ok, kwordchars)\n  call assert_equal(fnamechars_ok, fnamechars)\n\n  call assert_equal(identchars1, identchars)\n  call assert_equal(kwordchars1, kwordchars)\n  call assert_equal(fnamechars1, fnamechars)\nendfunc\n\nfunc Test_classes_re1()\n  set re=1\n  call s:classes_test()\n  set re=0\nendfunc\n\nfunc Test_classes_re2()\n  set re=2\n  call s:classes_test()\n  set re=0\nendfunc\n\nfunc Test_reversed_range()\n  for re in range(0, 2)\n    exe 'set re=' . re\n    call assert_fails('call match(\"abc def\", \"[c-a]\")', 'E944:', re)\n  endfor\n  set re=0\nendfunc\n\nfunc Test_large_class()\n  set re=1\n  call assert_fails('call match(\"abc def\", \"[\\u3000-\\u4000]\")', 'E945:')\n  set re=2\n  call assert_equal(0, 'abc def' =~# '[\\u3000-\\u4000]')\n  call assert_equal(1, \"\\u3042\" =~# '[\\u3000-\\u4000]')\n  set re=0\nendfunc\n\nfunc Test_optmatch_toolong()\n  set re=1\n  \" Can only handle about 8000 characters.\n  let pat = '\\\\%[' .. repeat('x', 9000) .. ']'\n  call assert_fails('call match(\"abc def\", \"' .. pat .. '\")', 'E339:')\n  set re=0\nendfunc\n\n\" Test for regexp patterns with multi-byte support, using utf-8.\nfunc Test_multibyte_chars()\n  \" tl is a List of Lists with:\n  \"    2: test auto/old/new  0: test auto/old  1: test auto/new\n  \"    regexp pattern\n  \"    text to test the pattern on\n  \"    expected match (optional)\n  \"    expected submatch 1 (optional)\n  \"    expected submatch 2 (optional)\n  \"    etc.\n  \"  When there is no match use only the first two items.\n  let tl = []\n\n  \" Multi-byte character tests. These will fail unless vim is compiled\n  \" with Multibyte (FEAT_MBYTE) or BIG/HUGE features.\n  call add(tl, [2, '[[:alpha:][=a=]]\\+', '879 aia\u0413\u0408\u0413\u045eaiuvna ', 'aia\u0413\u0408\u0413\u045eaiuvna'])\n  call add(tl, [2, '[[=a=]]\\+', 'dda\u0413\u0408\u0413\u045ebcd', 'a\u0413\u0408\u0413\u045e'])\t\t\t\t\t\t\t\t\" equivalence classes\n  call add(tl, [2, '[^\u0430\u0451\u040e ]\\+', '\u0430\u0451\u040e\u0430\u0451\u040e oijasoifjos ifjoisj f osij j \u0430\u0451\u040e\u0430\u0451\u040e\u0430\u0451\u040e\u0430\u0451\u040e\u0430\u0451\u040e abcd', 'oijasoifjos'])\n  call add(tl, [2, ' [^ ]\\+', 'start \u0430\u0451\u040eabcd\u0430\u0451\u040e ', ' \u0430\u0451\u040eabcd\u0430\u0451\u040e'])\n  call add(tl, [2, '[\u0430\u0451\u040e[:alpha:][=a=]]\\+', '879 aia\u0413\u0408\u0430\u0451\u040e\u0413\u045e\u0430\u0451\u040eaiuvna ', 'aia\u0413\u0408\u0430\u0451\u040e\u0413\u045e\u0430\u0451\u040eaiuvna'])\n\n  \" this is not a normal \"i\" but 0xec\n  call add(tl, [2, '\\p\\+', '\u0413\u00aca', '\u0413\u00aca'])\n  call add(tl, [2, '\\p*', 'a\u0433\u0492\u04ee', 'a\u0433\u0492\u04ee'])\n\n  \" Test recognition of some character classes\n  call add(tl, [2, '\\i\\+', '&*\u0412\u0401xx ', 'xx'])\n  call add(tl, [2, '\\f\\+', '&*\u0412\u04b9fname ', 'fname'])\n\n  \" Test composing character matching\n  call add(tl, [2, '.\u0430\u0451\u040e', 'x\u0430\u0451\u040e\u0430\u2116\u04b2x y\u0430\u0451\u040ey', 'y\u0430\u0451\u040e'])\n  call add(tl, [2, '.\u0430\u0451\u040e\u0430\u2116\u04b2', 'x\u0430\u0451\u040e\u0430\u2116\u04b2x y\u0430\u0451\u040ey', 'x\u0430\u0451\u040e\u0430\u2116\u04b2'])\n  call add(tl, [2, \"\\u05b9\", \" x\\u05b9 \", \"x\\u05b9\"])\n  call add(tl, [2, \".\\u05b9\", \" x\\u05b9 \", \"x\\u05b9\"])\n  call add(tl, [2, \"\\u05b9\\u05bb\", \" x\\u05b9\\u05bb \", \"x\\u05b9\\u05bb\"])\n  call add(tl, [2, \".\\u05b9\\u05bb\", \" x\\u05b9\\u05bb \", \"x\\u05b9\\u05bb\"])\n  call add(tl, [2, \"\\u05bb\\u05b9\", \" x\\u05b9\\u05bb \", \"x\\u05b9\\u05bb\"])\n  call add(tl, [2, \".\\u05bb\\u05b9\", \" x\\u05b9\\u05bb \", \"x\\u05b9\\u05bb\"])\n  call add(tl, [2, \"\\u05b9\", \" y\\u05bb x\\u05b9 \", \"x\\u05b9\"])\n  call add(tl, [2, \".\\u05b9\", \" y\\u05bb x\\u05b9 \", \"x\\u05b9\"])\n  call add(tl, [2, \"\\u05b9\", \" y\\u05bb\\u05b9 x\\u05b9 \", \"y\\u05bb\\u05b9\"])\n  call add(tl, [2, \".\\u05b9\", \" y\\u05bb\\u05b9 x\\u05b9 \", \"y\\u05bb\\u05b9\"])\n  call add(tl, [1, \"\\u05b9\\u05bb\", \" y\\u05b9 x\\u05b9\\u05bb \", \"x\\u05b9\\u05bb\"])\n  call add(tl, [2, \".\\u05b9\\u05bb\", \" y\\u05bb x\\u05b9\\u05bb \", \"x\\u05b9\\u05bb\"])\n  call add(tl, [2, \"a\", \"ca\\u0300t\"])\n  call add(tl, [2, \"ca\", \"ca\\u0300t\"])\n  call add(tl, [2, \"a\\u0300\", \"ca\\u0300t\", \"a\\u0300\"])\n  call add(tl, [2, 'a\\%C', \"ca\\u0300t\", \"a\\u0300\"])\n  call add(tl, [2, 'ca\\%C', \"ca\\u0300t\", \"ca\\u0300\"])\n  call add(tl, [2, 'ca\\%Ct', \"ca\\u0300t\", \"ca\\u0300t\"])\n\n  \" Test \\Z\n  call add(tl, [2, '\u0413\u04d9\\Z', 'x'])\n  call add(tl, [2, '\u0427\u04b7\u0427\u201d\u0427\u2022\u0427\u201d\\Z', '\u0427\u04b7\u0427\u201d\u0427\u2022\u0427\u201d', '\u0427\u04b7\u0427\u201d\u0427\u2022\u0427\u201d'])\n  call add(tl, [2, '\u0427\u04b7\u0426\u00b0\u0427\u201d\u0427\u2022\u0426\u0451\u0427\u201d\\Z', '\u0427\u04b7\u0427\u201d\u0427\u2022\u0427\u201d', '\u0427\u04b7\u0427\u201d\u0427\u2022\u0427\u201d'])\n  call add(tl, [2, '\u0427\u04b7\u0427\u201d\u0427\u2022\u0427\u201d\\Z', '\u0427\u04b7\u0426\u00b0\u0427\u201d\u0427\u2022\u0426\u0451\u0427\u201d', '\u0427\u04b7\u0426\u00b0\u0427\u201d\u0427\u2022\u0426\u0451\u0427\u201d'])\n  call add(tl, [2, '\u0427\u04b7\u0426\u00b0\u0427\u201d\u0427\u2022\u0426\u0451\u0427\u201d\\Z', '\u0427\u04b7\u0426\u00b0\u0427\u201d\u0427\u2022\u0426\u0451\u0427\u201d', '\u0427\u04b7\u0426\u00b0\u0427\u201d\u0427\u2022\u0426\u0451\u0427\u201d'])\n  call add(tl, [2, '\u0427\u04b7\u0426\u00b0\\Z', '\u0427\u2022\u0426\u00b0\u0427\u04b7\u0426\u00b7', '\u0427\u04b7\u0426\u00b7'])\n  call add(tl, [2, \"\u0427\u00a7\\u200d\\u05b9x\\\\Z\", \"x\u0427\u00a7\\u200d\\u05b9xy\", \"\u0427\u00a7\\u200d\\u05b9x\"])\n  call add(tl, [2, \"\u0427\u00a7\\u200d\\u05b9x\\\\Z\", \"x\u0427\u00a7\\u200dxy\", \"\u0427\u00a7\\u200dx\"])\n  call add(tl, [2, \"\u0427\u00a7\\u200dx\\\\Z\", \"x\u0427\u00a7\\u200d\\u05b9xy\", \"\u0427\u00a7\\u200d\\u05b9x\"])\n  call add(tl, [2, \"\u0427\u00a7\\u200dx\\\\Z\", \"x\u0427\u00a7\\u200dxy\", \"\u0427\u00a7\\u200dx\"])\n  call add(tl, [2, \"\\u05b9\\\\Z\", \"xyz\"])\n  call add(tl, [2, \"\\\\Z\\u05b9\", \"xyz\"])\n  call add(tl, [2, \"\\u05b9\\\\Z\", \"xy\\u05b9z\", \"y\\u05b9\"])\n  call add(tl, [2, \"\\\\Z\\u05b9\", \"xy\\u05b9z\", \"y\\u05b9\"])\n  call add(tl, [1, \"\\u05b9\\\\+\\\\Z\", \"xy\\u05b9z\\u05b9 \", \"y\\u05b9z\\u05b9\"])\n  call add(tl, [1, \"\\\\Z\\u05b9\\\\+\", \"xy\\u05b9z\\u05b9 \", \"y\\u05b9z\\u05b9\"])\n\n  \" Combining different tests and features\n  call add(tl, [2, '[^[=a=]]\\+', 'dda\u0413\u0408\u0413\u045ebcd', 'dd'])\n\n  \" Run the tests\n  for t in tl\n    let re = t[0]\n    let pat = t[1]\n    let text = t[2]\n    let matchidx = 3\n    for engine in [0, 1, 2]\n      if engine == 2 && re == 0 || engine == 1 && re == 1\n        continue\n      endif\n      let &regexpengine = engine\n      try\n        let l = matchlist(text, pat)\n      catch\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat .\n\t\t    \\ '\\\", text: \\\"' . text .\n\t\t    \\ '\\\", caused an exception: \\\"' . v:exception . '\\\"')\n      endtry\n      \" check the match itself\n      if len(l) == 0 && len(t) > matchidx\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat .\n\t\t    \\ '\\\", text: \\\"' . text .\n\t\t    \\ '\\\", did not match, expected: \\\"' . t[matchidx] . '\\\"')\n      elseif len(l) > 0 && len(t) == matchidx\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat .\n\t\t    \\ '\\\", text: \\\"' . text . '\\\", match: \\\"' . l[0] .\n\t\t    \\ '\\\", expected no match')\n      elseif len(t) > matchidx && l[0] != t[matchidx]\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat .\n\t\t    \\ '\\\", text: \\\"' . text . '\\\", match: \\\"' . l[0] .\n\t\t    \\ '\\\", expected: \\\"' . t[matchidx] . '\\\"')\n      else\n        \" Test passed\n      endif\n      if len(l) > 0\n        \" check all the nine submatches\n        for i in range(1, 9)\n          if len(t) <= matchidx + i\n            let e = ''\n          else\n            let e = t[matchidx + i]\n          endif\n          if l[i] != e\n            call assert_report('Error ' . engine . ': pat: \\\"' . pat .\n                  \\ '\\\", text: \\\"' . text . '\\\", submatch ' . i .\n                  \\ ': \\\"' . l[i] . '\\\", expected: \\\"' . e . '\\\"')\n          endif\n        endfor\n        unlet i\n      endif\n    endfor\n  endfor\n  set regexpengine&\nendfunc\n\n\" check that 'ambiwidth' does not change the meaning of \\p\nfunc Test_ambiwidth()\n  set regexpengine=1 ambiwidth=single\n  call assert_equal(0, match(\"\\u00EC\", '\\p'))\n  set regexpengine=1 ambiwidth=double\n  call assert_equal(0, match(\"\\u00EC\", '\\p'))\n  set regexpengine=2 ambiwidth=single\n  call assert_equal(0, match(\"\\u00EC\", '\\p'))\n  set regexpengine=2 ambiwidth=double\n  call assert_equal(0, match(\"\\u00EC\", '\\p'))\n  set regexpengine& ambiwidth&\nendfunc\n\nfunc Run_regexp_ignore_case()\n  call assert_equal('iI\u0414\u00b0', substitute('iI\u0414\u00b0', '\\([iI\u0414\u00b0]\\)', '\\1', 'g'))\n\n  call assert_equal('iIx', substitute('iI\u0414\u00b0', '\\c\\([\u0414\u00b0]\\)', 'x', 'g'))\n  call assert_equal('xx\u0414\u00b0', substitute('iI\u0414\u00b0', '\\(i\\c\\)', 'x', 'g'))\n  call assert_equal('iIx', substitute('iI\u0414\u00b0', '\\(\u0414\u00b0\\c\\)', 'x', 'g'))\n  call assert_equal('iIx', substitute('iI\u0414\u00b0', '\\c\\(\\%u0130\\)', 'x', 'g'))\n  call assert_equal('iIx', substitute('iI\u0414\u00b0', '\\c\\([\\u0130]\\)', 'x', 'g'))\n  call assert_equal('iIx', substitute('iI\u0414\u00b0', '\\c\\([\\u012f-\\u0131]\\)', 'x', 'g'))\nendfunc\n\nfunc Test_regexp_ignore_case()\n  set regexpengine=1\n  call Run_regexp_ignore_case()\n  set regexpengine=2\n  call Run_regexp_ignore_case()\n  set regexpengine&\nendfunc\n\n\" Tests for regexp with multi-byte encoding and various magic settings\nfunc Run_regexp_multibyte_magic()\n  let text =<< trim END\n    1 a aa abb abbccc\n    2 d dd dee deefff\n    3 g gg ghh ghhiii\n    4 j jj jkk jkklll\n    5 m mm mnn mnnooo\n    6 x ^aa$ x\n    7 (a)(b) abbaa\n    8 axx [ab]xx\n    9 \u0430\u0451\u00ab\u0430\u0451\u040e\u0430\u2116\u04b2x \u0430\u0451\u04ef\u0430\u0451\u040ex\n    a \u0430\u0451\u04ef\u0430\u0451\u040ex \u0430\u0451\u00ab\u0430\u0451\u040e\u0430\u2116\u04b2x\n    b \u0433\u0492\u040e\u0433\u04ee\u00ab\u0433\u0493\u0401\u0433\u0492\u049c\n    c x \u0412\u00ac\u0432\u04ee\u00acx\n    d \u0435\u04e8\u00a9\u0434\u04aa\u049dx\n    e \u044c\u2019\u049a\u2026\u04b7\u0451y\n    f \u044c\u2019\u049a\u04a0\u049c\u049az\n    g a\u0435\u2022\u00b7bb\n    j 0123\u0432\u049b\u04e8x\n    k combinations\n    l \u0413\u04e8\u0413\u00b6 \u0413\u0458\u041e\u04b1\u041c\u201e\u041c\u04b6\u041c\u0492\n  END\n\n  new\n  call setline(1, text)\n  exe 'normal /a*b\\{2}c\\+/e' .. \"\\<CR>x\"\n  call assert_equal('1 a aa abb abbcc', getline('.'))\n  exe 'normal /\\Md\\*e\\{2}f\\+/e' .. \"\\<CR>x\"\n  call assert_equal('2 d dd dee deeff', getline('.'))\n  set nomagic\n  exe 'normal /g\\*h\\{2}i\\+/e' .. \"\\<CR>x\"\n  call assert_equal('3 g gg ghh ghhii', getline('.'))\n  exe 'normal /\\mj*k\\{2}l\\+/e' .. \"\\<CR>x\"\n  call assert_equal('4 j jj jkk jkkll', getline('.'))\n  exe 'normal /\\vm*n{2}o+/e' .. \"\\<CR>x\"\n  call assert_equal('5 m mm mnn mnnoo', getline('.'))\n  exe 'normal /\\V^aa$/' .. \"\\<CR>x\"\n  call assert_equal('6 x aa$ x', getline('.'))\n  set magic\n  exe 'normal /\\v(a)(b)\\2\\1\\1/e' .. \"\\<CR>x\"\n  call assert_equal('7 (a)(b) abba', getline('.'))\n  exe 'normal /\\V[ab]\\(\\[xy]\\)\\1' .. \"\\<CR>x\"\n  call assert_equal('8 axx ab]xx', getline('.'))\n\n  \" search for multi-byte without composing char\n  exe 'normal /\u0430\u0451\u040e' .. \"\\<CR>x\"\n  call assert_equal('9 \u0430\u0451\u00ab\u0430\u0451\u040e\u0430\u2116\u04b2x \u0430\u0451\u04efx', getline('.'))\n\n  \" search for multi-byte with composing char\n  exe 'normal /\u0430\u0451\u040e\u0430\u2116\u04b2' .. \"\\<CR>x\"\n  call assert_equal('a \u0430\u0451\u04ef\u0430\u0451\u040ex \u0430\u0451\u00abx', getline('.'))\n\n  \" find word by change of word class\n  exe 'normal /\u0433\u0492\u040e\\<\u0433\u04ee\u00ab\u0433\u0493\u0401\\>\u0433\u0492\u049c' .. \"\\<CR>x\"\n  call assert_equal('b \u0433\u04ee\u00ab\u0433\u0493\u0401\u0433\u0492\u049c', getline('.'))\n\n  \" Test \\%u, [\\u] and friends\n  \" c\n  exe 'normal /\\%u20ac' .. \"\\<CR>x\"\n  call assert_equal('c x \u0412\u00acx', getline('.'))\n  \" d\n  exe 'normal /[\\u4f7f\\u5929]\\+' .. \"\\<CR>x\"\n  call assert_equal('d \u0434\u04aa\u049dx', getline('.'))\n  \" e\n  exe 'normal /\\%U12345678' .. \"\\<CR>x\"\n  call assert_equal('e y', getline('.'))\n  \" f\n  exe 'normal /[\\U1234abcd\\u1234\\uabcd]' .. \"\\<CR>x\"\n  call assert_equal('f z', getline('.'))\n  \" g\n  exe 'normal /\\%d21879b' .. \"\\<CR>x\"\n  call assert_equal('g abb', getline('.'))\n\n  \" j Test backwards search from a multi-byte char\n  exe \"normal /x\\<CR>x?.\\<CR>x\"\n  call assert_equal('j 012\u0432\u049b\u04e8', getline('.'))\n  \" k\n  let @w=':%s#comb[i]nations#\u0415\u201c\u041c\u201e\u0431\u2116\u0408\u041c\u0492m\u041c\u0498\u041c\u201e\u041e\u04b1\u041c\u201e\u041c\u04b6\u041c\u0492#g'\n  @w\n  call assert_equal('k \u0415\u201c\u041c\u201e\u0431\u2116\u0408\u041c\u0492m\u041c\u0498\u041c\u201e\u041e\u04b1\u041c\u201e\u041c\u04b6\u041c\u0492', getline(18))\n\n  close!\nendfunc\n\nfunc Test_regexp_multibyte_magic()\n  set regexpengine=1\n  call Run_regexp_multibyte_magic()\n  set regexpengine=2\n  call Run_regexp_multibyte_magic()\n  set regexpengine&\nendfunc\n\n\" Test for 7.3.192\n\" command \":s/ \\?/ /g\" splits multi-byte characters into bytes\nfunc Test_split_multibyte_to_bytes()\n  new\n  call setline(1, 'l \u0413\u04e8\u0413\u00b6 \u0413\u0458\u041e\u04b1\u041c\u201e\u041c\u04b6\u041c\u0492')\n  s/ \\?/ /g\n  call assert_equal(' l \u0413\u04e8 \u0413\u00b6 \u0413\u0458 \u041e\u04b1\u041c\u201e\u041c\u04b6\u041c\u0492', getline(1))\n  close!\nendfunc\n\n\" Test for matchstr() with multibyte characters\nfunc Test_matchstr_multibyte()\n  new\n  call assert_equal('\u0427\u2018', matchstr(\"\u0427\u0497\u0427\u2018\u0427\u2019\u0427\u201c\", \".\", 0, 2))\n  call assert_equal('\u0427\u2018\u0427\u2019', matchstr(\"\u0427\u0497\u0427\u2018\u0427\u2019\u0427\u201c\", \"..\", 0, 2))\n  call assert_equal('\u0427\u0497', matchstr(\"\u0427\u0497\u0427\u2018\u0427\u2019\u0427\u201c\", \".\", 0, 0))\n  call assert_equal('\u0427\u2019', matchstr(\"\u0427\u0497\u0427\u2018\u0427\u2019\u0427\u201c\", \".\", 4, -1))\n  close!\nendfunc\n\n\" Test for 7.4.636\n\" A search with end offset gets stuck at end of file.\nfunc Test_search_with_end_offset()\n  new\n  call setline(1, ['', 'dog(a', 'cat('])\n  exe \"normal /(/e+\\<CR>\"\n  normal n\"ayn\n  call assert_equal(\"a\\ncat(\", @a)\n  close!\nendfunc\n\n\" Check that \"^\" matches even when the line starts with a combining char\nfunc Test_match_start_of_line_combining()\n  new\n  call setline(1, ['', \"\\u05ae\", ''])\n  exe \"normal gg/^\\<CR>\"\n  call assert_equal(2, getcurpos()[1])\n  bwipe!\nendfunc\n\n\" Check that [[:upper:]] matches for automatic engine\nfunc Test_match_char_class_upper()\n  new\n\n  \" Test 1: [[:upper:]]\\{2,\\}\n  set regexpengine=0\n  call setline(1, ['05. \u0420\u04b9\u0420\u2022\u0420\u040e\u0420\u049b\u0420\u049c \u0420\u04bb \u0420\u201c\u0420\u2022\u0420\u00a0\u0420\u04bb\u0420\u049c\u0420\u0498 \u0420\u0458\u0421\u0493\u0420\u00b7. \u0420\u0497. \u0420\u201d\u0420\u00b0\u0420\u0406\u0420\u0451\u0420\u0499\u0420\u04e9\u0420\u04aa\u0420\u04d9\u0420\u04ab, \u0420\u04a3. \u0420\u04a1\u0420\u04ab\u0420\u0406\u0420\u00b0\u0420\u00bb\u0421\u04b8 \u0420\u0451 \u0420\u2018. \u0420\u0401\u0420\u04e9\u0421\u2026\u0421\u04ee\u0420\u04e9\u0421\u0496\u0420\u00b0 ...', '05. PJESNJA O GJEROJAKH mus. A. Davidjenko, M. Kovalja i B. Shjekhtjera ...'])\n  call cursor(1,1)\n  let search_cmd='norm /\\<[[:upper:]]\\{2,\\}\\>' .. \"\\<CR>\"\n  exe search_cmd\n  call assert_equal(4, searchcount().total, 'TEST 1')\n  set regexpengine=1\n  exe search_cmd\n  call assert_equal(2, searchcount().total, 'TEST 1')\n  set regexpengine=2\n  exe search_cmd\n  call assert_equal(4, searchcount().total, 'TEST 1')\n\n  \" Test 2: [[:upper:]].\\+\n  let search_cmd='norm /\\<[[:upper:]].\\+\\>' .. \"\\<CR>\"\n  set regexpengine=0\n  exe search_cmd\n  call assert_equal(2, searchcount().total, 'TEST 2')\n  set regexpengine=1\n  exe search_cmd\n  call assert_equal(1, searchcount().total, 'TEST 2')\n  set regexpengine=2\n  exe search_cmd\n  call assert_equal(2, searchcount().total, 'TEST 2')\n\n  \" Test 3: [[:lower:]]\\+\n  let search_cmd='norm /\\<[[:lower:]]\\+\\>' .. \"\\<CR>\"\n  set regexpengine=0\n  exe search_cmd\n  call assert_equal(4, searchcount().total, 'TEST 3 lower')\n  set regexpengine=1\n  exe search_cmd\n  call assert_equal(2, searchcount().total, 'TEST 3 lower')\n  set regexpengine=2\n  exe search_cmd\n  call assert_equal(4, searchcount().total, 'TEST 3 lower')\n\n  \" clean up\n  set regexpengine=0\n  bwipe!\nendfunc\n\nfunc Test_match_invalid_byte()\n  call writefile(0z630a.765d30aa0a.2e0a.790a.4030, 'Xinvalid')\n  new\n  source Xinvalid\n  bwipe!\n  call delete('Xinvalid')\nendfunc\n\nfunc Test_match_too_complicated()\n  set regexpengine=1\n  exe \"vsplit \\xeb\\xdb\\x99\"\n  silent! buf \\&\\zs*\\zs*0\n  bwipe!\n  set regexpengine=0\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4440,\n/**/\n    4439,\n/**/\n    4438,\n/**/\n    4437,\n/**/\n    4436,\n/**/\n    4435,\n/**/\n    4434,\n/**/\n    4433,\n/**/\n    4432,\n/**/\n    4431,\n/**/\n    4430,\n/**/\n    4429,\n/**/\n    4428,\n/**/\n    4427,\n/**/\n    4426,\n/**/\n    4425,\n/**/\n    4424,\n/**/\n    4423,\n/**/\n    4422,\n/**/\n    4421,\n/**/\n    4420,\n/**/\n    4419,\n/**/\n    4418,\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/regexp_bt.c", "src/testdir/test_regexp_utf8.vim", "src/version.c"], "buggy_code_start_loc": [4617, 4, 752], "buggy_code_end_loc": [4617, 564, 752], "fixing_code_start_loc": [4618, 4, 753], "fixing_code_end_loc": [4623, 572, 755], "type": "CWE-823", "message": "Use of Out-of-range Pointer Offset in GitHub repository vim/vim prior to 8.2.4440.", "other": {"cve": {"id": "CVE-2022-0729", "sourceIdentifier": "security@huntr.dev", "published": "2022-02-23T14:15:08.123", "lastModified": "2022-12-14T16:58:30.277", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Use of Out-of-range Pointer Offset in GitHub repository vim/vim prior to 8.2.4440."}, {"lang": "es", "value": "Un Uso de un Desplazamiento de Puntero Fuera de Rango en el repositorio de GitHub vim/vim versiones anteriores a 8.2.4440"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-823"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.4440", "matchCriteriaId": "CB180646-76A6-41DA-A3CE-471B7DFF2AF5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionEndExcluding": "13.0", "matchCriteriaId": "71E032AD-F827-4944-9699-BB1E6D4233FC"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2022/Oct/28", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/Oct/41", "source": "security@huntr.dev", "tags": ["Mailing List", "Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/6456fae9ba8e72c74b2c0c499eaf09974604ff30", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/f3f3d992-7bd6-4ee5-a502-ae0e5f8016ea", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00018.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/7ZLEHVP4LNAGER4ZDGUDS5V5YVQD6INF/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HBUYQBZ6GWAWJRWP7AODJ4KHW5BCKDVP/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213488", "source": "security@huntr.dev", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/6456fae9ba8e72c74b2c0c499eaf09974604ff30"}}