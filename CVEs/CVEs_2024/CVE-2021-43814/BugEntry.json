{"buggy_code": ["// SPDX-FileCopyrightText: 2012-2018 pancake <pancake@nopcode.org>\n// SPDX-FileCopyrightText: 2012-2018 Fedor Sakharov <fedor.sakharov@gmail.com>\n// SPDX-License-Identifier: LGPL-3.0-only\n\n#define D0 if (1)\n#define D1 if (1)\n\n#include <errno.h>\n\n#define DWARF_DUMP 0\n\n#if DWARF_DUMP\n#define DBGFD stdout\n#else\n#define DBGFD NULL\n#endif\n\n#include <rz_bin.h>\n#include <rz_bin_dwarf.h>\n#include <rz_core.h>\n\n#define STANDARD_OPERAND_COUNT_DWARF2 9\n#define STANDARD_OPERAND_COUNT_DWARF3 12\n#define RZ_BIN_DWARF_INFO             1\n\n#define READ8(buf) \\\n\t(((buf) + 1 < buf_end) ? *((ut8 *)(buf)) : 0); \\\n\t(buf)++\n#define READ16(buf) \\\n\t(((buf) + sizeof(ut16) < buf_end) ? rz_read_ble16(buf, big_endian) : 0); \\\n\t(buf) += sizeof(ut16)\n#define READ32(buf) \\\n\t(((buf) + sizeof(ut32) < buf_end) ? rz_read_ble32(buf, big_endian) : 0); \\\n\t(buf) += sizeof(ut32)\n#define READ64(buf) \\\n\t(((buf) + sizeof(ut64) < buf_end) ? rz_read_ble64(buf, big_endian) : 0); \\\n\t(buf) += sizeof(ut64)\n\nstatic const char *dwarf_tag_name_encodings[] = {\n\t[DW_TAG_null_entry] = \"DW_TAG_null_entry\",\n\t[DW_TAG_array_type] = \"DW_TAG_array_type\",\n\t[DW_TAG_class_type] = \"DW_TAG_class_type\",\n\t[DW_TAG_entry_point] = \"DW_TAG_entry_point\",\n\t[DW_TAG_enumeration_type] = \"DW_TAG_enumeration_type\",\n\t[DW_TAG_formal_parameter] = \"DW_TAG_formal_parameter\",\n\t[DW_TAG_imported_declaration] = \"DW_TAG_imported_declaration\",\n\t[DW_TAG_label] = \"DW_TAG_label\",\n\t[DW_TAG_lexical_block] = \"DW_TAG_lexical_block\",\n\t[DW_TAG_member] = \"DW_TAG_member\",\n\t[DW_TAG_pointer_type] = \"DW_TAG_pointer_type\",\n\t[DW_TAG_reference_type] = \"DW_TAG_reference_type\",\n\t[DW_TAG_compile_unit] = \"DW_TAG_compile_unit\",\n\t[DW_TAG_string_type] = \"DW_TAG_string_type\",\n\t[DW_TAG_structure_type] = \"DW_TAG_structure_type\",\n\t[DW_TAG_subroutine_type] = \"DW_TAG_subroutine_type\",\n\t[DW_TAG_typedef] = \"DW_TAG_typedef\",\n\t[DW_TAG_union_type] = \"DW_TAG_union_type\",\n\t[DW_TAG_unspecified_parameters] = \"DW_TAG_unspecified_parameters\",\n\t[DW_TAG_variant] = \"DW_TAG_variant\",\n\t[DW_TAG_common_block] = \"DW_TAG_common_block\",\n\t[DW_TAG_common_inclusion] = \"DW_TAG_common_inclusion\",\n\t[DW_TAG_inheritance] = \"DW_TAG_inheritance\",\n\t[DW_TAG_inlined_subroutine] = \"DW_TAG_inlined_subroutine\",\n\t[DW_TAG_module] = \"DW_TAG_module\",\n\t[DW_TAG_ptr_to_member_type] = \"DW_TAG_ptr_to_member_type\",\n\t[DW_TAG_set_type] = \"DW_TAG_set_type\",\n\t[DW_TAG_subrange_type] = \"DW_TAG_subrange_type\",\n\t[DW_TAG_with_stmt] = \"DW_TAG_with_stmt\",\n\t[DW_TAG_access_declaration] = \"DW_TAG_access_declaration\",\n\t[DW_TAG_base_type] = \"DW_TAG_base_type\",\n\t[DW_TAG_catch_block] = \"DW_TAG_catch_block\",\n\t[DW_TAG_const_type] = \"DW_TAG_const_type\",\n\t[DW_TAG_constant] = \"DW_TAG_constant\",\n\t[DW_TAG_enumerator] = \"DW_TAG_enumerator\",\n\t[DW_TAG_file_type] = \"DW_TAG_file_type\",\n\t[DW_TAG_friend] = \"DW_TAG_friend\",\n\t[DW_TAG_namelist] = \"DW_TAG_namelist\",\n\t[DW_TAG_namelist_item] = \"DW_TAG_namelist_item\",\n\t[DW_TAG_packed_type] = \"DW_TAG_packed_type\",\n\t[DW_TAG_subprogram] = \"DW_TAG_subprogram\",\n\t[DW_TAG_template_type_param] = \"DW_TAG_template_type_param\",\n\t[DW_TAG_template_value_param] = \"DW_TAG_template_value_param\",\n\t[DW_TAG_thrown_type] = \"DW_TAG_thrown_type\",\n\t[DW_TAG_try_block] = \"DW_TAG_try_block\",\n\t[DW_TAG_variant_part] = \"DW_TAG_variant_part\",\n\t[DW_TAG_variable] = \"DW_TAG_variable\",\n\t[DW_TAG_volatile_type] = \"DW_TAG_volatile_type\",\n\t[DW_TAG_dwarf_procedure] = \"DW_TAG_dwarf_procedure\",\n\t[DW_TAG_restrict_type] = \"DW_TAG_restrict_type\",\n\t[DW_TAG_interface_type] = \"DW_TAG_interface_type\",\n\t[DW_TAG_namespace] = \"DW_TAG_namespace\",\n\t[DW_TAG_imported_module] = \"DW_TAG_imported_module\",\n\t[DW_TAG_unspecified_type] = \"DW_TAG_unspecified_type\",\n\t[DW_TAG_partial_unit] = \"DW_TAG_partial_unit\",\n\t[DW_TAG_imported_unit] = \"DW_TAG_imported_unit\",\n\t[DW_TAG_mutable_type] = \"DW_TAG_mutable_type\",\n\t[DW_TAG_condition] = \"DW_TAG_condition\",\n\t[DW_TAG_shared_type] = \"DW_TAG_shared_type\",\n\t[DW_TAG_type_unit] = \"DW_TAG_type_unit\",\n\t[DW_TAG_rvalue_reference_type] = \"DW_TAG_rvalue_reference_type\",\n\t[DW_TAG_template_alias] = \"DW_TAG_template_alias\",\n\t[DW_TAG_LAST] = \"DW_TAG_LAST\",\n};\n\nstatic const char *dwarf_attr_encodings[] = {\n\t[DW_AT_sibling] = \"DW_AT_siblings\",\n\t[DW_AT_location] = \"DW_AT_location\",\n\t[DW_AT_name] = \"DW_AT_name\",\n\t[DW_AT_ordering] = \"DW_AT_ordering\",\n\t[DW_AT_byte_size] = \"DW_AT_byte_size\",\n\t[DW_AT_bit_size] = \"DW_AT_bit_size\",\n\t[DW_AT_stmt_list] = \"DW_AT_stmt_list\",\n\t[DW_AT_low_pc] = \"DW_AT_low_pc\",\n\t[DW_AT_high_pc] = \"DW_AT_high_pc\",\n\t[DW_AT_language] = \"DW_AT_language\",\n\t[DW_AT_discr] = \"DW_AT_discr\",\n\t[DW_AT_discr_value] = \"DW_AT_discr_value\",\n\t[DW_AT_visibility] = \"DW_AT_visibility\",\n\t[DW_AT_import] = \"DW_AT_import\",\n\t[DW_AT_string_length] = \"DW_AT_string_length\",\n\t[DW_AT_common_reference] = \"DW_AT_common_reference\",\n\t[DW_AT_comp_dir] = \"DW_AT_comp_dir\",\n\t[DW_AT_const_value] = \"DW_AT_const_value\",\n\t[DW_AT_containing_type] = \"DW_AT_containing_type\",\n\t[DW_AT_default_value] = \"DW_AT_default_value\",\n\t[DW_AT_inline] = \"DW_AT_inline\",\n\t[DW_AT_is_optional] = \"DW_AT_is_optional\",\n\t[DW_AT_lower_bound] = \"DW_AT_lower_bound\",\n\t[DW_AT_producer] = \"DW_AT_producer\",\n\t[DW_AT_prototyped] = \"DW_AT_prototyped\",\n\t[DW_AT_return_addr] = \"DW_AT_return_addr\",\n\t[DW_AT_start_scope] = \"DW_AT_start_scope\",\n\t[DW_AT_stride_size] = \"DW_AT_stride_size\",\n\t[DW_AT_upper_bound] = \"DW_AT_upper_bound\",\n\t[DW_AT_abstract_origin] = \"DW_AT_abstract_origin\",\n\t[DW_AT_accessibility] = \"DW_AT_accessibility\",\n\t[DW_AT_address_class] = \"DW_AT_address_class\",\n\t[DW_AT_artificial] = \"DW_AT_artificial\",\n\t[DW_AT_base_types] = \"DW_AT_base_types\",\n\t[DW_AT_calling_convention] = \"DW_AT_calling_convention\",\n\t[DW_AT_count] = \"DW_AT_count\",\n\t[DW_AT_data_member_location] = \"DW_AT_data_member_location\",\n\t[DW_AT_decl_column] = \"DW_AT_decl_column\",\n\t[DW_AT_decl_file] = \"DW_AT_decl_file\",\n\t[DW_AT_decl_line] = \"DW_AT_decl_line\",\n\t[DW_AT_declaration] = \"DW_AT_declaration\",\n\t[DW_AT_discr_list] = \"DW_AT_discr_list\",\n\t[DW_AT_encoding] = \"DW_AT_encoding\",\n\t[DW_AT_external] = \"DW_AT_external\",\n\t[DW_AT_frame_base] = \"DW_AT_frame_base\",\n\t[DW_AT_friend] = \"DW_AT_friend\",\n\t[DW_AT_identifier_case] = \"DW_AT_identifier_case\",\n\t[DW_AT_macro_info] = \"DW_AT_macro_info\",\n\t[DW_AT_namelist_item] = \"DW_AT_namelist_item\",\n\t[DW_AT_priority] = \"DW_AT_priority\",\n\t[DW_AT_segment] = \"DW_AT_segment\",\n\t[DW_AT_specification] = \"DW_AT_specification\",\n\t[DW_AT_static_link] = \"DW_AT_static_link\",\n\t[DW_AT_type] = \"DW_AT_type\",\n\t[DW_AT_use_location] = \"DW_AT_use_location\",\n\t[DW_AT_variable_parameter] = \"DW_AT_variable_parameter\",\n\t[DW_AT_virtuality] = \"DW_AT_virtuality\",\n\t[DW_AT_vtable_elem_location] = \"DW_AT_vtable_elem_location\",\n\t[DW_AT_allocated] = \"DW_AT_allocated\",\n\t[DW_AT_associated] = \"DW_AT_associated\",\n\t[DW_AT_data_location] = \"DW_AT_data_location\",\n\t[DW_AT_byte_stride] = \"DW_AT_byte_stride\",\n\t[DW_AT_entry_pc] = \"DW_AT_entry_pc\",\n\t[DW_AT_use_UTF8] = \"DW_AT_use_UTF8\",\n\t[DW_AT_extension] = \"DW_AT_extension\",\n\t[DW_AT_ranges] = \"DW_AT_ranges\",\n\t[DW_AT_trampoline] = \"DW_AT_trampoline\",\n\t[DW_AT_call_column] = \"DW_AT_call_column\",\n\t[DW_AT_call_file] = \"DW_AT_call_file\",\n\t[DW_AT_call_line] = \"DW_AT_call_line\",\n\t[DW_AT_description] = \"DW_AT_description\",\n\t[DW_AT_binary_scale] = \"DW_AT_binary_scale\",\n\t[DW_AT_decimal_scale] = \"DW_AT_decimal_scale\",\n\t[DW_AT_small] = \"DW_AT_small\",\n\t[DW_AT_decimal_sign] = \"DW_AT_decimal_sign\",\n\t[DW_AT_digit_count] = \"DW_AT_digit_count\",\n\t[DW_AT_picture_string] = \"DW_AT_picture_string\",\n\t[DW_AT_mutable] = \"DW_AT_mutable\",\n\t[DW_AT_threads_scaled] = \"DW_AT_threads_scaled\",\n\t[DW_AT_explicit] = \"DW_AT_explicit\",\n\t[DW_AT_object_pointer] = \"DW_AT_object_pointer\",\n\t[DW_AT_endianity] = \"DW_AT_endianity\",\n\t[DW_AT_elemental] = \"DW_AT_elemental\",\n\t[DW_AT_pure] = \"DW_AT_pure\",\n\t[DW_AT_recursive] = \"DW_AT_recursive\",\n\t[DW_AT_signature] = \"DW_AT_signature\",\n\t[DW_AT_main_subprogram] = \"DW_AT_main_subprogram\",\n\t[DW_AT_data_bit_offset] = \"DW_AT_data_big_offset\",\n\t[DW_AT_const_expr] = \"DW_AT_const_expr\",\n\t[DW_AT_enum_class] = \"DW_AT_enum_class\",\n\t[DW_AT_linkage_name] = \"DW_AT_linkage_name\",\n\t[DW_AT_string_length_bit_size] = \"DW_AT_string_length_bit_size\",\n\t[DW_AT_string_length_byte_size] = \"DW_AT_string_length_byte_size\",\n\t[DW_AT_rank] = \"DW_AT_rank\",\n\t[DW_AT_str_offsets_base] = \"DW_AT_str_offsets_base\",\n\t[DW_AT_addr_base] = \"DW_AT_addr_base\",\n\t[DW_AT_rnglists_base] = \"DW_AT_rnglists_base\",\n\t[DW_AT_dwo_name] = \"DW_AT_dwo_name\",\n\t[DW_AT_reference] = \"DW_AT_reference\",\n\t[DW_AT_rvalue_reference] = \"DW_AT_rvalue_reference\",\n\t[DW_AT_macros] = \"DW_AT_macros\",\n\t[DW_AT_call_all_calls] = \"DW_AT_call_all_calls\",\n\t[DW_AT_call_all_source_calls] = \"DW_AT_call_all_source_calls\",\n\t[DW_AT_call_all_tail_calls] = \"DW_AT_call_all_tail_calls\",\n\t[DW_AT_call_return_pc] = \"DW_AT_call_return_pc\",\n\t[DW_AT_call_value] = \"DW_AT_call_value\",\n\t[DW_AT_call_origin] = \"DW_AT_call_origin\",\n\t[DW_AT_call_parameter] = \"DW_AT_call_parameter\",\n\t[DW_AT_call_pc] = \"DW_AT_call_pc\",\n\t[DW_AT_call_tail_call] = \"DW_AT_call_tail_call\",\n\t[DW_AT_call_target] = \"DW_AT_call_target\",\n\t[DW_AT_call_target_clobbered] = \"DW_AT_call_target_clobbered\",\n\t[DW_AT_call_data_location] = \"DW_AT_call_data_location\",\n\t[DW_AT_call_data_value] = \"DW_AT_call_data_value\",\n\t[DW_AT_noreturn] = \"DW_AT_noreturn\",\n\t[DW_AT_alignment] = \"DW_AT_alignment\",\n\t[DW_AT_export_symbols] = \"DW_AT_export_symbols\",\n\t[DW_AT_deleted] = \"DW_AT_deleted\",\n\t[DW_AT_defaulted] = \"DW_AT_defaulted\",\n\t[DW_AT_loclists_base] = \"DW_AT_loclists_base\"\n};\n\nstatic const char *dwarf_attr_form_encodings[] = {\n\t[DW_FORM_addr] = \"DW_FORM_addr\",\n\t[DW_FORM_block2] = \"DW_FORM_block2\",\n\t[DW_FORM_block4] = \"DW_FORM_block4\",\n\t[DW_FORM_data2] = \"DW_FORM_data2\",\n\t[DW_FORM_data4] = \"DW_FORM_data4\",\n\t[DW_FORM_data8] = \"DW_FORM_data8\",\n\t[DW_FORM_string] = \"DW_FORM_string\",\n\t[DW_FORM_block] = \"DW_FORM_block\",\n\t[DW_FORM_block1] = \"DW_FORM_block1\",\n\t[DW_FORM_data1] = \"DW_FORM_data1\",\n\t[DW_FORM_flag] = \"DW_FORM_flag\",\n\t[DW_FORM_sdata] = \"DW_FORM_sdata\",\n\t[DW_FORM_strp] = \"DW_FORM_strp\",\n\t[DW_FORM_udata] = \"DW_FORM_udata\",\n\t[DW_FORM_ref_addr] = \"DW_FORM_ref_addr\",\n\t[DW_FORM_ref1] = \"DW_FORM_ref1\",\n\t[DW_FORM_ref2] = \"DW_FORM_ref2\",\n\t[DW_FORM_ref4] = \"DW_FORM_ref4\",\n\t[DW_FORM_ref8] = \"DW_FORM_ref8\",\n\t[DW_FORM_ref_udata] = \"DW_FORM_ref_udata\",\n\t[DW_FORM_indirect] = \"DW_FORM_indirect\",\n\t[DW_FORM_sec_offset] = \"DW_FORM_sec_offset\",\n\t[DW_FORM_exprloc] = \"DW_FORM_exprloc\",\n\t[DW_FORM_flag_present] = \"DW_FORM_flag_present\",\n\t[DW_FORM_strx] = \"DW_FORM_strx\",\n\t[DW_FORM_addrx] = \"DW_FORM_addrx\",\n\t[DW_FORM_ref_sup4] = \"DW_FORM_ref_sup4\",\n\t[DW_FORM_strp_sup] = \"DW_FORM_strp_sup\",\n\t[DW_FORM_data16] = \"DW_FORM_data16\",\n\t[DW_FORM_line_ptr] = \"DW_FORM_line_ptr\",\n\t[DW_FORM_ref_sig8] = \"DW_FORM_ref_sig8\",\n\t[DW_FORM_implicit_const] = \"DW_FORM_implicit_const\",\n\t[DW_FORM_loclistx] = \"DW_FORM_loclistx\",\n\t[DW_FORM_rnglistx] = \"DW_FORM_rnglistx\",\n\t[DW_FORM_ref_sup8] = \"DW_FORM_ref_sup8\",\n\t[DW_FORM_strx1] = \"DW_FORM_strx1\",\n\t[DW_FORM_strx2] = \"DW_FORM_strx2\",\n\t[DW_FORM_strx3] = \"DW_FORM_strx3\",\n\t[DW_FORM_strx4] = \"DW_FORM_strx4\",\n\t[DW_FORM_addrx1] = \"DW_FORM_addrx1\",\n\t[DW_FORM_addrx2] = \"DW_FORM_addrx2\",\n\t[DW_FORM_addrx3] = \"DW_FORM_addrx3\",\n\t[DW_FORM_addrx4] = \"DW_FORM_addrx4\",\n};\n\nstatic const char *dwarf_langs[] = {\n\t[DW_LANG_C89] = \"C89\",\n\t[DW_LANG_C] = \"C\",\n\t[DW_LANG_Ada83] = \"Ada83\",\n\t[DW_LANG_C_plus_plus] = \"C++\",\n\t[DW_LANG_Cobol74] = \"Cobol74\",\n\t[DW_LANG_Cobol85] = \"Cobol85\",\n\t[DW_LANG_Fortran77] = \"Fortran77\",\n\t[DW_LANG_Fortran90] = \"Fortran90\",\n\t[DW_LANG_Pascal83] = \"Pascal83\",\n\t[DW_LANG_Modula2] = \"Modula2\",\n\t[DW_LANG_Java] = \"Java\",\n\t[DW_LANG_C99] = \"C99\",\n\t[DW_LANG_Ada95] = \"Ada95\",\n\t[DW_LANG_Fortran95] = \"Fortran95\",\n\t[DW_LANG_PLI] = \"PLI\",\n\t[DW_LANG_ObjC] = \"ObjC\",\n\t[DW_LANG_ObjC_plus_plus] = \"ObjC_plus_plus\",\n\t[DW_LANG_UPC] = \"UPC\",\n\t[DW_LANG_D] = \"D\",\n\t[DW_LANG_Python] = \"Python\",\n\t[DW_LANG_Rust] = \"Rust\",\n\t[DW_LANG_C11] = \"C11\",\n\t[DW_LANG_Swift] = \"Swift\",\n\t[DW_LANG_Julia] = \"Julia\",\n\t[DW_LANG_Dylan] = \"Dylan\",\n\t[DW_LANG_C_plus_plus_14] = \"C++14\",\n\t[DW_LANG_Fortran03] = \"Fortran03\",\n\t[DW_LANG_Fortran08] = \"Fortran08\"\n};\n\nstatic const char *dwarf_unit_types[] = {\n\t[DW_UT_compile] = \"DW_UT_compile\",\n\t[DW_UT_type] = \"DW_UT_type\",\n\t[DW_UT_partial] = \"DW_UT_partial\",\n\t[DW_UT_skeleton] = \"DW_UT_skeleton\",\n\t[DW_UT_split_compile] = \"DW_UT_split_compile\",\n\t[DW_UT_split_type] = \"DW_UT_split_type\",\n\t[DW_UT_lo_user] = \"DW_UT_lo_user\",\n\t[DW_UT_hi_user] = \"DW_UT_hi_user\",\n};\n\nRZ_API const char *rz_bin_dwarf_get_tag_name(ut64 tag) {\n\tif (tag >= DW_TAG_LAST) {\n\t\treturn NULL;\n\t}\n\treturn dwarf_tag_name_encodings[tag];\n}\n\nRZ_API const char *rz_bin_dwarf_get_attr_name(ut64 attr_code) {\n\tif (attr_code < RZ_ARRAY_SIZE(dwarf_attr_encodings)) {\n\t\treturn dwarf_attr_encodings[attr_code];\n\t}\n\t// the below codes are much sparser, so putting them in an array would require a lot of\n\t// unused memory\n\tswitch (attr_code) {\n\tcase DW_AT_lo_user:\n\t\treturn \"DW_AT_lo_user\";\n\tcase DW_AT_MIPS_linkage_name:\n\t\treturn \"DW_AT_MIPS_linkage_name\";\n\tcase DW_AT_GNU_call_site_value:\n\t\treturn \"DW_AT_GNU_call_site_value\";\n\tcase DW_AT_GNU_call_site_data_value:\n\t\treturn \"DW_AT_GNU_call_site_data_value\";\n\tcase DW_AT_GNU_call_site_target:\n\t\treturn \"DW_AT_GNU_call_site_target\";\n\tcase DW_AT_GNU_call_site_target_clobbered:\n\t\treturn \"DW_AT_GNU_call_site_target_clobbered\";\n\tcase DW_AT_GNU_tail_call:\n\t\treturn \"DW_AT_GNU_tail_call\";\n\tcase DW_AT_GNU_all_tail_call_sites:\n\t\treturn \"DW_AT_GNU_all_tail_call_sites\";\n\tcase DW_AT_GNU_all_call_sites:\n\t\treturn \"DW_AT_GNU_all_call_sites\";\n\tcase DW_AT_GNU_all_source_call_sites:\n\t\treturn \"DW_AT_GNU_all_source_call_sites\";\n\tcase DW_AT_GNU_macros:\n\t\treturn \"DW_AT_GNU_macros\";\n\tcase DW_AT_GNU_deleted:\n\t\treturn \"DW_AT_GNU_deleted\";\n\tcase DW_AT_GNU_dwo_name:\n\t\treturn \"DW_AT_GNU_dwo_name\";\n\tcase DW_AT_GNU_dwo_id:\n\t\treturn \"DW_AT_GNU_dwo_id\";\n\tcase DW_AT_GNU_ranges_base:\n\t\treturn \"DW_AT_GNU_ranges_base\";\n\tcase DW_AT_GNU_addr_base:\n\t\treturn \"DW_AT_GNU_addr_base\";\n\tcase DW_AT_GNU_pubnames:\n\t\treturn \"DW_AT_GNU_pubnames\";\n\tcase DW_AT_GNU_pubtypes:\n\t\treturn \"DW_AT_GNU_pubtypes\";\n\tcase DW_AT_hi_user:\n\t\treturn \"DW_AT_hi_user\";\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nRZ_API const char *rz_bin_dwarf_get_attr_form_name(ut64 form_code) {\n\tif (form_code < DW_FORM_addr || form_code > DW_FORM_addrx4) {\n\t\treturn NULL;\n\t}\n\treturn dwarf_attr_form_encodings[form_code];\n}\n\nRZ_API const char *rz_bin_dwarf_get_unit_type_name(ut64 unit_type) {\n\tif (!unit_type || unit_type > DW_UT_split_type) {\n\t\treturn NULL;\n\t}\n\treturn dwarf_unit_types[unit_type];\n}\n\nRZ_API const char *rz_bin_dwarf_get_lang_name(ut64 lang) {\n\tif (lang >= RZ_ARRAY_SIZE(dwarf_langs)) {\n\t\treturn NULL;\n\t}\n\treturn dwarf_langs[lang];\n}\n\nstatic int abbrev_cmp(const void *a, const void *b) {\n\tconst RzBinDwarfAbbrevDecl *first = a;\n\tconst RzBinDwarfAbbrevDecl *second = b;\n\n\tif (first->offset > second->offset) {\n\t\treturn 1;\n\t} else if (first->offset < second->offset) {\n\t\treturn -1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\n/**\n * \\brief Read an \"initial length\" value, as specified by dwarf.\n * This also determines whether it is 64bit or 32bit and reads 4 or 12 bytes respectively.\n */\nstatic inline ut64 dwarf_read_initial_length(RZ_OUT bool *is_64bit, bool big_endian, const ut8 **buf, const ut8 *buf_end) {\n\tut64 r = READ32(*buf);\n\tif (r == DWARF_INIT_LEN_64) {\n\t\tr = READ64(*buf);\n\t\t*is_64bit = true;\n\t} else {\n\t\t*is_64bit = false;\n\t}\n\treturn r;\n}\n\n/**\n * @brief Reads 64/32 bit unsigned based on format\n *\n * @param is_64bit Format of the comp unit\n * @param buf Pointer to the buffer to read from, to update after read\n * @param buf_end To check the boundary /for READ macro/\n * @return ut64 Read value\n */\nstatic inline ut64 dwarf_read_offset(bool is_64bit, bool big_endian, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tif (is_64bit) {\n\t\tresult = READ64(*buf);\n\t} else {\n\t\tresult = READ32(*buf);\n\t}\n\treturn result;\n}\n\nstatic inline ut64 dwarf_read_address(size_t size, bool big_endian, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tswitch (size) {\n\tcase 2:\n\t\tresult = READ16(*buf);\n\t\tbreak;\n\tcase 4:\n\t\tresult = READ32(*buf);\n\t\tbreak;\n\tcase 8:\n\t\tresult = READ64(*buf);\n\t\tbreak;\n\tdefault:\n\t\tresult = 0;\n\t\t*buf += size;\n\t\teprintf(\"Weird dwarf address size: %zu.\", size);\n\t}\n\treturn result;\n}\n\nstatic void line_header_fini(RzBinDwarfLineHeader *hdr) {\n\tif (hdr) {\n\t\tfor (size_t i = 0; i < hdr->file_names_count; i++) {\n\t\t\tfree(hdr->file_names[i].name);\n\t\t}\n\n\t\tfree(hdr->std_opcode_lengths);\n\t\tfree(hdr->file_names);\n\n\t\tif (hdr->include_dirs) {\n\t\t\tfor (size_t i = 0; i < hdr->include_dirs_count; i++) {\n\t\t\t\tfree(hdr->include_dirs[i]);\n\t\t\t}\n\t\t\tfree(hdr->include_dirs);\n\t\t}\n\t}\n}\n\n// Parses source file header of DWARF version <= 4\nstatic const ut8 *parse_line_header_source(RzBinFile *bf, const ut8 *buf, const ut8 *buf_end, RzBinDwarfLineHeader *hdr) {\n\tRzPVector incdirs;\n\trz_pvector_init(&incdirs, free);\n\twhile (buf + 1 < buf_end) {\n\t\tsize_t maxlen = RZ_MIN((size_t)(buf_end - buf) - 1, 0xfff);\n\t\tsize_t len = rz_str_nlen((const char *)buf, maxlen);\n\t\tchar *str = rz_str_ndup((const char *)buf, len);\n\t\tif (len < 1 || len >= 0xfff || !str) {\n\t\t\tbuf += 1;\n\t\t\tfree(str);\n\t\t\tbreak;\n\t\t}\n\t\trz_pvector_push(&incdirs, str);\n\t\tbuf += len + 1;\n\t}\n\thdr->include_dirs_count = rz_pvector_len(&incdirs);\n\thdr->include_dirs = (char **)rz_pvector_flush(&incdirs);\n\trz_pvector_fini(&incdirs);\n\n\tRzVector file_names;\n\trz_vector_init(&file_names, sizeof(RzBinDwarfLineFileEntry), NULL, NULL);\n\twhile (buf + 1 < buf_end) {\n\t\tconst char *filename = (const char *)buf;\n\t\tsize_t maxlen = RZ_MIN((size_t)(buf_end - buf - 1), 0xfff);\n\t\tut64 id_idx, mod_time, file_len;\n\t\tsize_t len = rz_str_nlen(filename, maxlen);\n\n\t\tif (!len) {\n\t\t\tbuf++;\n\t\t\tbreak;\n\t\t}\n\t\tbuf += len + 1;\n\t\tif (buf >= buf_end) {\n\t\t\tbuf = NULL;\n\t\t\tgoto beach;\n\t\t}\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &id_idx, NULL);\n\t\tif (buf >= buf_end) {\n\t\t\tbuf = NULL;\n\t\t\tgoto beach;\n\t\t}\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &mod_time, NULL);\n\t\tif (buf >= buf_end) {\n\t\t\tbuf = NULL;\n\t\t\tgoto beach;\n\t\t}\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &file_len, NULL);\n\t\tif (buf >= buf_end) {\n\t\t\tbuf = NULL;\n\t\t\tgoto beach;\n\t\t}\n\t\tRzBinDwarfLineFileEntry *entry = rz_vector_push(&file_names, NULL);\n\t\tentry->name = strdup(filename);\n\t\tentry->id_idx = id_idx;\n\t\tentry->mod_time = mod_time;\n\t\tentry->file_len = file_len;\n\t}\n\thdr->file_names_count = rz_vector_len(&file_names);\n\thdr->file_names = rz_vector_flush(&file_names);\n\trz_vector_fini(&file_names);\n\nbeach:\n\treturn buf;\n}\n\n/**\n * \\param info if not NULL, filenames can get resolved to absolute paths using the compilation unit dirs from it\n */\nRZ_API char *rz_bin_dwarf_line_header_get_full_file_path(RZ_NULLABLE const RzBinDwarfDebugInfo *info, const RzBinDwarfLineHeader *header, ut64 file_index) {\n\trz_return_val_if_fail(header, NULL);\n\tif (file_index >= header->file_names_count) {\n\t\treturn NULL;\n\t}\n\tRzBinDwarfLineFileEntry *file = &header->file_names[file_index];\n\tif (!file->name) {\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Dwarf standard does not seem to specify the exact separator (slash/backslash) of paths\n\t * so apparently it is target-dependent. However we have yet to see a Windows binary that\n\t * also contains dwarf and contains backslashes. The ones we have seen from MinGW have regular\n\t * slashes.\n\t * And since there seems to be no way to reliable check whether the target uses slashes\n\t * or backslashes anyway, we will simply use slashes always here.\n\t */\n\n\tconst char *comp_dir = info ? ht_up_find(info->line_info_offset_comp_dir, header->offset, NULL) : NULL;\n\tconst char *include_dir = NULL;\n\tchar *own_str = NULL;\n\tif (file->id_idx > 0 && file->id_idx - 1 < header->include_dirs_count) {\n\t\tinclude_dir = header->include_dirs[file->id_idx - 1];\n\t\tif (include_dir && include_dir[0] != '/' && comp_dir) {\n\t\t\tinclude_dir = own_str = rz_str_newf(\"%s/%s/\", comp_dir, include_dir);\n\t\t}\n\t} else {\n\t\tinclude_dir = comp_dir;\n\t}\n\tif (!include_dir) {\n\t\tinclude_dir = \"./\";\n\t}\n\tchar *r = rz_str_newf(\"%s/%s\", include_dir, file->name);\n\tfree(own_str);\n\treturn r;\n}\n\nRZ_API RzBinDwarfLineFileCache rz_bin_dwarf_line_header_new_file_cache(const RzBinDwarfLineHeader *hdr) {\n\treturn RZ_NEWS0(char *, hdr->file_names_count);\n}\n\nRZ_API void rz_bin_dwarf_line_header_free_file_cache(const RzBinDwarfLineHeader *hdr, RzBinDwarfLineFileCache fnc) {\n\tif (!fnc) {\n\t\treturn;\n\t}\n\tfor (size_t i = 0; i < hdr->file_names_count; i++) {\n\t\tfree(fnc[i]);\n\t}\n\tfree(fnc);\n}\n\nstatic const char *get_full_file_path(const RzBinDwarfDebugInfo *info, const RzBinDwarfLineHeader *header,\n\tRZ_NULLABLE RzBinDwarfLineFileCache cache, ut64 file_index) {\n\tif (file_index >= header->file_names_count) {\n\t\treturn NULL;\n\t}\n\tif (!cache) {\n\t\treturn header->file_names[file_index].name;\n\t}\n\tif (!cache[file_index]) {\n\t\tcache[file_index] = rz_bin_dwarf_line_header_get_full_file_path(info, header, file_index);\n\t}\n\treturn cache[file_index];\n}\n\nRZ_API ut64 rz_bin_dwarf_line_header_get_adj_opcode(const RzBinDwarfLineHeader *header, ut8 opcode) {\n\trz_return_val_if_fail(header, 0);\n\treturn opcode - header->opcode_base;\n}\n\nRZ_API ut64 rz_bin_dwarf_line_header_get_spec_op_advance_pc(const RzBinDwarfLineHeader *header, ut8 opcode) {\n\trz_return_val_if_fail(header, 0);\n\tif (!header->line_range) {\n\t\t// to dodge division by zero\n\t\treturn 0;\n\t}\n\tut8 adj_opcode = rz_bin_dwarf_line_header_get_adj_opcode(header, opcode);\n\treturn (adj_opcode / header->line_range) * header->min_inst_len;\n}\n\nRZ_API st64 rz_bin_dwarf_line_header_get_spec_op_advance_line(const RzBinDwarfLineHeader *header, ut8 opcode) {\n\trz_return_val_if_fail(header, 0);\n\tif (!header->line_range) {\n\t\t// to dodge division by zero\n\t\treturn 0;\n\t}\n\tut8 adj_opcode = rz_bin_dwarf_line_header_get_adj_opcode(header, opcode);\n\treturn header->line_base + (adj_opcode % header->line_range);\n}\n\nstatic const ut8 *parse_line_header(\n\tRzBinFile *bf, const ut8 *buf, const ut8 *buf_end,\n\tRzBinDwarfLineHeader *hdr, ut64 offset_cur, bool big_endian) {\n\trz_return_val_if_fail(hdr && bf && buf && buf_end, NULL);\n\n\thdr->offset = offset_cur;\n\thdr->is_64bit = false;\n\thdr->unit_length = dwarf_read_initial_length(&hdr->is_64bit, big_endian, &buf, buf_end);\n\thdr->version = READ16(buf);\n\n\tif (hdr->version == 5) {\n\t\thdr->address_size = READ8(buf);\n\t\thdr->segment_selector_size = READ8(buf);\n\t}\n\n\thdr->header_length = dwarf_read_offset(hdr->is_64bit, big_endian, &buf, buf_end);\n\n\tconst ut8 *tmp_buf = buf; // So I can skip parsing DWARF 5 headers for now\n\n\tif (buf_end - buf < 8) {\n\t\treturn NULL;\n\t}\n\thdr->min_inst_len = READ8(buf);\n\tif (hdr->version >= 4) {\n\t\thdr->max_ops_per_inst = READ8(buf);\n\t}\n\thdr->default_is_stmt = READ8(buf);\n\thdr->line_base = (st8)READ8(buf);\n\thdr->line_range = READ8(buf);\n\thdr->opcode_base = READ8(buf);\n\n\thdr->file_names = NULL;\n\n\tif (hdr->opcode_base > 1) {\n\t\thdr->std_opcode_lengths = calloc(sizeof(ut8), hdr->opcode_base - 1);\n\t\tfor (size_t i = 1; i < hdr->opcode_base; i++) {\n\t\t\tif (buf + 2 > buf_end) {\n\t\t\t\thdr->opcode_base = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thdr->std_opcode_lengths[i - 1] = READ8(buf);\n\t\t}\n\t} else {\n\t\thdr->std_opcode_lengths = NULL;\n\t}\n\t// TODO finish parsing of source files out of DWARF 5 header\n\t// for now we skip\n\tif (hdr->version == 5) {\n\t\ttmp_buf += hdr->header_length;\n\t\treturn tmp_buf;\n\t}\n\n\tif (hdr->version <= 4) {\n\t\tbuf = parse_line_header_source(bf, buf, buf_end, hdr);\n\t} else {\n\t\tbuf = NULL;\n\t}\n\n\treturn buf;\n}\n\nRZ_API void rz_bin_dwarf_line_op_fini(RzBinDwarfLineOp *op) {\n\trz_return_if_fail(op);\n\tif (op->type == RZ_BIN_DWARF_LINE_OP_TYPE_EXT && op->opcode == DW_LNE_define_file) {\n\t\tfree(op->args.define_file.filename);\n\t}\n}\n\nstatic const ut8 *parse_ext_opcode(RzBinDwarfLineOp *op, const RzBinDwarfLineHeader *hdr, const ut8 *obuf, size_t len,\n\tbool big_endian, ut8 target_addr_size) {\n\trz_return_val_if_fail(op && hdr && obuf, NULL);\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + len;\n\n\tut64 op_len;\n\tbuf = rz_uleb128(buf, len, &op_len, NULL);\n\t// op_len must fit and be at least 1 (for the opcode byte)\n\tif (!buf || buf >= buf_end || !op_len || buf_end - buf < op_len) {\n\t\treturn NULL;\n\t}\n\n\tut8 opcode = *buf++;\n\top->type = RZ_BIN_DWARF_LINE_OP_TYPE_EXT;\n\top->opcode = opcode;\n\n\tswitch (opcode) {\n\tcase DW_LNE_set_address: {\n\t\tut8 addr_size = hdr->address_size;\n\t\tif (hdr->version < 5) { // address_size in header only starting with Dwarf 5\n\t\t\taddr_size = target_addr_size;\n\t\t}\n\t\top->args.set_address = dwarf_read_address(addr_size, big_endian, &buf, buf_end);\n\t\tbreak;\n\t}\n\tcase DW_LNE_define_file: {\n\t\tsize_t fn_len = rz_str_nlen((const char *)buf, buf_end - buf);\n\t\tchar *fn = malloc(fn_len + 1);\n\t\tif (!fn) {\n\t\t\treturn NULL;\n\t\t}\n\t\tmemcpy(fn, buf, fn_len);\n\t\tfn[fn_len] = 0;\n\t\top->args.define_file.filename = fn;\n\t\tbuf += fn_len + 1;\n\t\tif (buf + 1 < buf_end) {\n\t\t\tbuf = rz_uleb128(buf, buf_end - buf, &op->args.define_file.dir_index, NULL);\n\t\t}\n\t\tif (buf && buf + 1 < buf_end) {\n\t\t\tbuf = rz_uleb128(buf, buf_end - buf, NULL, NULL);\n\t\t}\n\t\tif (buf && buf + 1 < buf_end) {\n\t\t\tbuf = rz_uleb128(buf, buf_end - buf, NULL, NULL);\n\t\t}\n\t\tbreak;\n\t}\n\tcase DW_LNE_set_discriminator:\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &op->args.set_discriminator, NULL);\n\t\tbreak;\n\tcase DW_LNE_end_sequence:\n\tdefault:\n\t\tbuf += op_len - 1;\n\t\tbreak;\n\t}\n\treturn buf;\n}\n\n/**\n * \\return the number of leb128 args the std opcode takes, EXCEPT for DW_LNS_fixed_advance_pc! (see Dwarf spec)\n */\nstatic size_t std_opcode_args_count(const RzBinDwarfLineHeader *hdr, ut8 opcode) {\n\tif (!opcode || opcode > hdr->opcode_base - 1 || !hdr->std_opcode_lengths) {\n\t\treturn 0;\n\t}\n\treturn hdr->std_opcode_lengths[opcode - 1];\n}\n\nstatic const ut8 *parse_std_opcode(RzBinDwarfLineOp *op, const RzBinDwarfLineHeader *hdr, const ut8 *obuf, size_t len, ut8 opcode, bool big_endian) {\n\trz_return_val_if_fail(op && hdr && obuf, NULL);\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + len;\n\n\top->type = RZ_BIN_DWARF_LINE_OP_TYPE_STD;\n\top->opcode = opcode;\n\tswitch (opcode) {\n\tcase DW_LNS_advance_pc:\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &op->args.advance_pc, NULL);\n\t\tbreak;\n\tcase DW_LNS_advance_line:\n\t\tbuf = rz_leb128(buf, buf_end - buf, &op->args.advance_line);\n\t\tbreak;\n\tcase DW_LNS_set_file:\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &op->args.set_file, NULL);\n\t\tbreak;\n\tcase DW_LNS_set_column:\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &op->args.set_column, NULL);\n\t\tbreak;\n\tcase DW_LNS_fixed_advance_pc:\n\t\top->args.fixed_advance_pc = READ16(buf);\n\t\tbreak;\n\tcase DW_LNS_set_isa:\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &op->args.set_isa, NULL);\n\t\tbreak;\n\n\t// known opcodes that take no args\n\tcase DW_LNS_copy:\n\tcase DW_LNS_negate_stmt:\n\tcase DW_LNS_set_basic_block:\n\tcase DW_LNS_const_add_pc:\n\tcase DW_LNS_set_prologue_end:\n\tcase DW_LNS_set_epilogue_begin:\n\t\tbreak;\n\n\t// unknown operands, skip the number of args given in the header.\n\tdefault: {\n\t\tsize_t args_count = std_opcode_args_count(hdr, opcode);\n\t\tfor (size_t i = 0; i < args_count; i++) {\n\t\t\tbuf = rz_uleb128(buf, buf_end - buf, &op->args.advance_pc, NULL);\n\t\t\tif (!buf) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t}\n\treturn buf;\n}\n\nRZ_API void rz_bin_dwarf_line_header_reset_regs(const RzBinDwarfLineHeader *hdr, RzBinDwarfSMRegisters *regs) {\n\trz_return_if_fail(hdr && regs);\n\tregs->address = 0;\n\tregs->file = 1;\n\tregs->line = 1;\n\tregs->column = 0;\n\tregs->is_stmt = hdr->default_is_stmt;\n\tregs->basic_block = DWARF_FALSE;\n\tregs->end_sequence = DWARF_FALSE;\n\tregs->prologue_end = DWARF_FALSE;\n\tregs->epilogue_begin = DWARF_FALSE;\n\tregs->isa = 0;\n}\n\nstatic void store_line_sample(RzBinSourceLineInfoBuilder *bob, const RzBinDwarfLineHeader *hdr, RzBinDwarfSMRegisters *regs,\n\tRZ_NULLABLE RzBinDwarfDebugInfo *info, RZ_NULLABLE RzBinDwarfLineFileCache fnc) {\n\tconst char *file = NULL;\n\tif (regs->file) {\n\t\tfile = get_full_file_path(info, hdr, fnc, regs->file - 1);\n\t}\n\trz_bin_source_line_info_builder_push_sample(bob, regs->address, (ut32)regs->line, (ut32)regs->column, file);\n}\n\n/**\n * \\brief Execute a single line op on regs and optionally store the resulting line info in bob\n * \\param fnc if not null, filenames will be resolved to their full paths using this cache.\n */\nRZ_API bool rz_bin_dwarf_line_op_run(const RzBinDwarfLineHeader *hdr, RzBinDwarfSMRegisters *regs, RzBinDwarfLineOp *op,\n\tRZ_NULLABLE RzBinSourceLineInfoBuilder *bob, RZ_NULLABLE RzBinDwarfDebugInfo *info, RZ_NULLABLE RzBinDwarfLineFileCache fnc) {\n\trz_return_val_if_fail(hdr && regs && op, false);\n\tswitch (op->type) {\n\tcase RZ_BIN_DWARF_LINE_OP_TYPE_STD:\n\t\tswitch (op->opcode) {\n\t\tcase DW_LNS_copy:\n\t\t\tif (bob) {\n\t\t\t\tstore_line_sample(bob, hdr, regs, info, fnc);\n\t\t\t}\n\t\t\tregs->basic_block = DWARF_FALSE;\n\t\t\tbreak;\n\t\tcase DW_LNS_advance_pc:\n\t\t\tregs->address += op->args.advance_pc * hdr->min_inst_len;\n\t\t\tbreak;\n\t\tcase DW_LNS_advance_line:\n\t\t\tregs->line += op->args.advance_line;\n\t\t\tbreak;\n\t\tcase DW_LNS_set_file:\n\t\t\tregs->file = op->args.set_file;\n\t\t\tbreak;\n\t\tcase DW_LNS_set_column:\n\t\t\tregs->column = op->args.set_column;\n\t\t\tbreak;\n\t\tcase DW_LNS_negate_stmt:\n\t\t\tregs->is_stmt = regs->is_stmt ? DWARF_FALSE : DWARF_TRUE;\n\t\t\tbreak;\n\t\tcase DW_LNS_set_basic_block:\n\t\t\tregs->basic_block = DWARF_TRUE;\n\t\t\tbreak;\n\t\tcase DW_LNS_const_add_pc:\n\t\t\tregs->address += rz_bin_dwarf_line_header_get_spec_op_advance_pc(hdr, 255);\n\t\t\tbreak;\n\t\tcase DW_LNS_fixed_advance_pc:\n\t\t\tregs->address += op->args.fixed_advance_pc;\n\t\t\tbreak;\n\t\tcase DW_LNS_set_prologue_end:\n\t\t\tregs->prologue_end = ~0;\n\t\t\tbreak;\n\t\tcase DW_LNS_set_epilogue_begin:\n\t\t\tregs->epilogue_begin = ~0;\n\t\t\tbreak;\n\t\tcase DW_LNS_set_isa:\n\t\t\tregs->isa = op->args.set_isa;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase RZ_BIN_DWARF_LINE_OP_TYPE_EXT:\n\t\tswitch (op->opcode) {\n\t\tcase DW_LNE_end_sequence:\n\t\t\tregs->end_sequence = DWARF_TRUE;\n\t\t\tif (bob) {\n\t\t\t\t// closing entry\n\t\t\t\trz_bin_source_line_info_builder_push_sample(bob, regs->address, 0, 0, NULL);\n\t\t\t}\n\t\t\trz_bin_dwarf_line_header_reset_regs(hdr, regs);\n\t\t\tbreak;\n\t\tcase DW_LNE_set_address:\n\t\t\tregs->address = op->args.set_address;\n\t\t\tbreak;\n\t\tcase DW_LNE_define_file:\n\t\t\tbreak;\n\t\tcase DW_LNE_set_discriminator:\n\t\t\tregs->discriminator = op->args.set_discriminator;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase RZ_BIN_DWARF_LINE_OP_TYPE_SPEC:\n\t\tregs->address += rz_bin_dwarf_line_header_get_spec_op_advance_pc(hdr, op->opcode);\n\t\tregs->line += rz_bin_dwarf_line_header_get_spec_op_advance_line(hdr, op->opcode);\n\t\tif (bob) {\n\t\t\tstore_line_sample(bob, hdr, regs, info, fnc);\n\t\t}\n\t\tregs->basic_block = DWARF_FALSE;\n\t\tregs->prologue_end = DWARF_FALSE;\n\t\tregs->epilogue_begin = DWARF_FALSE;\n\t\tregs->discriminator = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic size_t parse_opcodes(const ut8 *obuf,\n\tsize_t len, const RzBinDwarfLineHeader *hdr, RzVector *ops_out,\n\tRzBinDwarfSMRegisters *regs, RZ_NULLABLE RzBinSourceLineInfoBuilder *bob, RZ_NULLABLE RzBinDwarfDebugInfo *info,\n\tRZ_NULLABLE RzBinDwarfLineFileCache fnc, bool big_endian, ut8 target_addr_size) {\n\tconst ut8 *buf, *buf_end;\n\tut8 opcode;\n\n\tif (!obuf || !len) {\n\t\treturn 0;\n\t}\n\tbuf = obuf;\n\tbuf_end = obuf + len;\n\n\twhile (buf < buf_end) {\n\t\topcode = *buf++;\n\t\tRzBinDwarfLineOp op = { 0 };\n\t\tif (!opcode) {\n\t\t\tbuf = parse_ext_opcode(&op, hdr, buf, (buf_end - buf), big_endian, target_addr_size);\n\t\t} else if (opcode >= hdr->opcode_base) {\n\t\t\t// special opcode without args, no further parsing needed\n\t\t\top.type = RZ_BIN_DWARF_LINE_OP_TYPE_SPEC;\n\t\t\top.opcode = opcode;\n\t\t} else {\n\t\t\tbuf = parse_std_opcode(&op, hdr, buf, (buf_end - buf), opcode, big_endian);\n\t\t}\n\t\tif (!buf) {\n\t\t\tbreak;\n\t\t}\n\t\tif (bob) {\n\t\t\trz_bin_dwarf_line_op_run(hdr, regs, &op, bob, info, fnc);\n\t\t}\n\t\tif (ops_out) {\n\t\t\trz_vector_push(ops_out, &op);\n\t\t} else {\n\t\t\trz_bin_dwarf_line_op_fini(&op);\n\t\t}\n\t}\n\tif (!buf) {\n\t\treturn 0;\n\t}\n\treturn (size_t)(buf - obuf); // number of bytes we've moved by\n}\n\nstatic void line_unit_free(RzBinDwarfLineUnit *unit) {\n\tif (!unit) {\n\t\treturn;\n\t}\n\tline_header_fini(&unit->header);\n\tif (unit->ops) {\n\t\tfor (size_t i = 0; i < unit->ops_count; i++) {\n\t\t\trz_bin_dwarf_line_op_fini(&unit->ops[i]);\n\t\t}\n\t\tfree(unit->ops);\n\t}\n\tfree(unit);\n}\n\nstatic RzBinDwarfLineInfo *parse_line_raw(RzBinFile *binfile, const ut8 *obuf,\n\tut64 len, RzBinDwarfLineInfoMask mask, bool big_endian, RZ_NULLABLE RzBinDwarfDebugInfo *info) {\n\t// Dwarf 3 Standard 6.2 Line Number Information\n\trz_return_val_if_fail(binfile && obuf, NULL);\n\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_start = buf;\n\tconst ut8 *buf_end = obuf + len;\n\tconst ut8 *tmpbuf = NULL;\n\tut64 buf_size;\n\n\t// Dwarf < 5 needs this size to be supplied from outside\n\tRzBinObject *o = binfile->o;\n\tut8 target_addr_size = o && o->info && o->info->bits ? o->info->bits / 8 : 4;\n\n\tRzBinDwarfLineInfo *li = RZ_NEW0(RzBinDwarfLineInfo);\n\tif (!li) {\n\t\treturn NULL;\n\t}\n\tli->units = rz_list_newf((RzListFree)line_unit_free);\n\tif (!li->units) {\n\t\tfree(li);\n\t\treturn NULL;\n\t}\n\n\tRzBinSourceLineInfoBuilder bob;\n\tif (mask & RZ_BIN_DWARF_LINE_INFO_MASK_LINES) {\n\t\trz_bin_source_line_info_builder_init(&bob);\n\t}\n\n\t// each iteration we read one header AKA comp. unit\n\twhile (buf <= buf_end) {\n\t\tRzBinDwarfLineUnit *unit = RZ_NEW0(RzBinDwarfLineUnit);\n\t\tif (!unit) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// How much did we read from the compilation unit\n\t\tsize_t bytes_read = 0;\n\t\t// calculate how much we've read by parsing header\n\t\t// because header unit_length includes itself\n\t\tbuf_size = buf_end - buf;\n\n\t\ttmpbuf = buf;\n\t\tbuf = parse_line_header(binfile, buf, buf_end, &unit->header, buf - buf_start, big_endian);\n\t\tif (!buf) {\n\t\t\tline_unit_free(unit);\n\t\t\tbreak;\n\t\t}\n\n\t\tbytes_read = buf - tmpbuf;\n\n\t\tRzBinDwarfSMRegisters regs;\n\t\trz_bin_dwarf_line_header_reset_regs(&unit->header, &regs);\n\n\t\t// If there is more bytes in the buffer than size of the header\n\t\t// It means that there has to be another header/comp.unit\n\t\tbuf_size = RZ_MIN(buf_size, unit->header.unit_length + (unit->header.is_64bit * 8 + 4)); // length field + rest of the unit\n\t\tif (buf_size <= bytes_read) {\n\t\t\t// no info or truncated\n\t\t\tline_unit_free(unit);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf_size > (buf_end - buf) + bytes_read || buf > buf_end) {\n\t\t\tline_unit_free(unit);\n\t\t\tbreak;\n\t\t}\n\t\tsize_t tmp_read = 0;\n\n\t\tRzVector ops;\n\t\tif (mask & RZ_BIN_DWARF_LINE_INFO_MASK_OPS) {\n\t\t\trz_vector_init(&ops, sizeof(RzBinDwarfLineOp), NULL, NULL);\n\t\t}\n\n\t\tRzBinDwarfLineFileCache fnc = NULL;\n\t\tif (mask & RZ_BIN_DWARF_LINE_INFO_MASK_LINES) {\n\t\t\tfnc = rz_bin_dwarf_line_header_new_file_cache(&unit->header);\n\t\t}\n\n\t\t// we read the whole compilation unit (that might be composed of more sequences)\n\t\tdo {\n\t\t\t// reads one whole sequence\n\t\t\ttmp_read = parse_opcodes(buf, buf_size - bytes_read, &unit->header,\n\t\t\t\t(mask & RZ_BIN_DWARF_LINE_INFO_MASK_OPS) ? &ops : NULL, &regs,\n\t\t\t\t(mask & RZ_BIN_DWARF_LINE_INFO_MASK_LINES) ? &bob : NULL,\n\t\t\t\tinfo, fnc, big_endian, target_addr_size);\n\t\t\tbytes_read += tmp_read;\n\t\t\tbuf += tmp_read; // Move in the buffer forward\n\t\t} while (bytes_read < buf_size && tmp_read != 0); // if nothing is read -> error, exit\n\n\t\trz_bin_dwarf_line_header_free_file_cache(&unit->header, fnc);\n\n\t\tif (mask & RZ_BIN_DWARF_LINE_INFO_MASK_OPS) {\n\t\t\tunit->ops_count = rz_vector_len(&ops);\n\t\t\tunit->ops = rz_vector_flush(&ops);\n\t\t\trz_vector_fini(&ops);\n\t\t}\n\n\t\tif (!tmp_read) {\n\t\t\tline_unit_free(unit);\n\t\t\tbreak;\n\t\t}\n\t\trz_list_push(li->units, unit);\n\t}\n\tif (mask & RZ_BIN_DWARF_LINE_INFO_MASK_LINES) {\n\t\tli->lines = rz_bin_source_line_info_builder_build_and_fini(&bob);\n\t}\n\treturn li;\n}\n\nRZ_API void rz_bin_dwarf_arange_set_free(RzBinDwarfARangeSet *set) {\n\tif (!set) {\n\t\treturn;\n\t}\n\tfree(set->aranges);\n\tfree(set);\n}\n\nstatic RzList /*<RzBinDwarfARangeSet>*/ *parse_aranges_raw(const ut8 *obuf, size_t obuf_sz, bool big_endian) {\n\trz_return_val_if_fail(obuf, NULL);\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = buf + obuf_sz;\n\n\tRzList *r = rz_list_newf((RzListFree)rz_bin_dwarf_arange_set_free);\n\tif (!r) {\n\t\treturn NULL;\n\t}\n\n\t// DWARF 3 Standard Section 6.1.2 Lookup by Address\n\t// also useful to grep for display_debug_aranges in binutils\n\twhile (buf < buf_end) {\n\t\tconst ut8 *start = buf;\n\t\tbool is_64bit;\n\t\tut64 unit_length = dwarf_read_initial_length(&is_64bit, big_endian, &buf, buf_end);\n\t\t// Sanity check: length must be at least the minimal size of the remaining header fields\n\t\t// and at maximum the remaining buffer size.\n\t\tsize_t header_rest_size = 2 + (is_64bit ? 8 : 4) + 1 + 1;\n\t\tif (unit_length < header_rest_size || unit_length > buf_end - buf) {\n\t\t\tbreak;\n\t\t}\n\t\tconst ut8 *next_set_buf = buf + unit_length;\n\t\tRzBinDwarfARangeSet *set = RZ_NEW(RzBinDwarfARangeSet);\n\t\tif (!set) {\n\t\t\tbreak;\n\t\t}\n\t\tset->unit_length = unit_length;\n\t\tset->is_64bit = is_64bit;\n\t\tset->version = READ16(buf);\n\t\tset->debug_info_offset = dwarf_read_offset(set->is_64bit, big_endian, &buf, buf_end);\n\t\tset->address_size = READ8(buf);\n\t\tset->segment_size = READ8(buf);\n\t\tunit_length -= header_rest_size;\n\t\tif (!set->address_size) {\n\t\t\tfree(set);\n\t\t\tbreak;\n\t\t}\n\n\t\t// align to 2*addr_size\n\t\tsize_t off = buf - start;\n\t\tsize_t pad = rz_num_align_delta(off, 2 * set->address_size);\n\t\tif (pad > unit_length || pad > buf_end - buf) {\n\t\t\tfree(set);\n\t\t\tbreak;\n\t\t}\n\t\tbuf += pad;\n\t\tunit_length -= pad;\n\n\t\tsize_t arange_size = 2 * set->address_size;\n\t\tset->aranges_count = unit_length / arange_size;\n\t\tif (!set->aranges_count) {\n\t\t\tfree(set);\n\t\t\tbreak;\n\t\t}\n\t\tset->aranges = RZ_NEWS0(RzBinDwarfARange, set->aranges_count);\n\t\tif (!set->aranges) {\n\t\t\tfree(set);\n\t\t\tbreak;\n\t\t}\n\t\tsize_t i;\n\t\tfor (i = 0; i < set->aranges_count; i++) {\n\t\t\tset->aranges[i].addr = dwarf_read_address(set->address_size, big_endian, &buf, buf_end);\n\t\t\tset->aranges[i].length = dwarf_read_address(set->address_size, big_endian, &buf, buf_end);\n\t\t\tif (!set->aranges[i].addr && !set->aranges[i].length) {\n\t\t\t\t// last entry has two 0s\n\t\t\t\ti++; // so i will be the total count of read entries\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tset->aranges_count = i;\n\t\tbuf = next_set_buf;\n\t\trz_list_push(r, set);\n\t}\n\n\treturn r;\n}\n\nstatic void free_ht_comp_dir(HtUPKv *kv) {\n\tfree(kv->value);\n}\n\nstatic bool init_debug_info(RzBinDwarfDebugInfo *inf) {\n\tinf->comp_units = RZ_NEWS0(RzBinDwarfCompUnit, DEBUG_INFO_CAPACITY);\n\tif (!inf->comp_units) {\n\t\treturn false;\n\t}\n\tinf->lookup_table = ht_up_new0();\n\tif (!inf->lookup_table) {\n\t\tgoto wurzelbert_comp_units;\n\t}\n\tinf->line_info_offset_comp_dir = ht_up_new(NULL, free_ht_comp_dir, NULL);\n\tif (!inf->line_info_offset_comp_dir) {\n\t\tgoto wurzelbert_lookup_table;\n\t}\n\tinf->capacity = DEBUG_INFO_CAPACITY;\n\tinf->count = 0;\n\treturn true;\nwurzelbert_lookup_table:\n\tht_up_free(inf->lookup_table);\nwurzelbert_comp_units:\n\tfree(inf->comp_units);\n\treturn false;\n}\n\nstatic int init_die(RzBinDwarfDie *die, ut64 abbr_code, ut64 attr_count) {\n\tif (!die) {\n\t\treturn -1;\n\t}\n\tdie->attr_values = calloc(sizeof(RzBinDwarfAttrValue), attr_count);\n\tif (!die->attr_values) {\n\t\treturn -1;\n\t}\n\tdie->abbrev_code = abbr_code;\n\tdie->capacity = attr_count;\n\tdie->count = 0;\n\treturn 0;\n}\n\nstatic int init_comp_unit(RzBinDwarfCompUnit *cu) {\n\tif (!cu) {\n\t\treturn -EINVAL;\n\t}\n\tcu->dies = calloc(sizeof(RzBinDwarfDie), COMP_UNIT_CAPACITY);\n\tif (!cu->dies) {\n\t\treturn -ENOMEM;\n\t}\n\tcu->capacity = COMP_UNIT_CAPACITY;\n\tcu->count = 0;\n\treturn 0;\n}\n\nstatic int expand_cu(RzBinDwarfCompUnit *cu) {\n\tRzBinDwarfDie *tmp;\n\n\tif (!cu || cu->capacity == 0 || cu->capacity != cu->count) {\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = (RzBinDwarfDie *)realloc(cu->dies,\n\t\tcu->capacity * 2 * sizeof(RzBinDwarfDie));\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset((ut8 *)tmp + cu->capacity * sizeof(RzBinDwarfDie),\n\t\t0, cu->capacity * sizeof(RzBinDwarfDie));\n\tcu->dies = tmp;\n\tcu->capacity *= 2;\n\n\treturn 0;\n}\n\nstatic int init_abbrev_decl(RzBinDwarfAbbrevDecl *ad) {\n\tif (!ad) {\n\t\treturn -EINVAL;\n\t}\n\tad->defs = calloc(sizeof(RzBinDwarfAttrDef), ABBREV_DECL_CAP);\n\n\tif (!ad->defs) {\n\t\treturn -ENOMEM;\n\t}\n\n\tad->capacity = ABBREV_DECL_CAP;\n\tad->count = 0;\n\n\treturn 0;\n}\n\nstatic int expand_abbrev_decl(RzBinDwarfAbbrevDecl *ad) {\n\tRzBinDwarfAttrDef *tmp;\n\n\tif (!ad || !ad->capacity || ad->capacity != ad->count) {\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = (RzBinDwarfAttrDef *)realloc(ad->defs,\n\t\tad->capacity * 2 * sizeof(RzBinDwarfAttrDef));\n\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\n\t// Set the area in the buffer past the length to 0\n\tmemset((ut8 *)tmp + ad->capacity * sizeof(RzBinDwarfAttrDef),\n\t\t0, ad->capacity * sizeof(RzBinDwarfAttrDef));\n\tad->defs = tmp;\n\tad->capacity *= 2;\n\n\treturn 0;\n}\n\nstatic int init_debug_abbrev(RzBinDwarfDebugAbbrev *da) {\n\tif (!da) {\n\t\treturn -EINVAL;\n\t}\n\tda->decls = calloc(sizeof(RzBinDwarfAbbrevDecl), DEBUG_ABBREV_CAP);\n\tif (!da->decls) {\n\t\treturn -ENOMEM;\n\t}\n\tda->capacity = DEBUG_ABBREV_CAP;\n\tda->count = 0;\n\n\treturn 0;\n}\n\nstatic int expand_debug_abbrev(RzBinDwarfDebugAbbrev *da) {\n\tRzBinDwarfAbbrevDecl *tmp;\n\n\tif (!da || da->capacity == 0 || da->capacity != da->count) {\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = (RzBinDwarfAbbrevDecl *)realloc(da->decls,\n\t\tda->capacity * 2 * sizeof(RzBinDwarfAbbrevDecl));\n\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\tmemset((ut8 *)tmp + da->capacity * sizeof(RzBinDwarfAbbrevDecl),\n\t\t0, da->capacity * sizeof(RzBinDwarfAbbrevDecl));\n\n\tda->decls = tmp;\n\tda->capacity *= 2;\n\n\treturn 0;\n}\n\nRZ_API void rz_bin_dwarf_debug_abbrev_free(RzBinDwarfDebugAbbrev *da) {\n\tsize_t i;\n\tif (!da) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < da->count; i++) {\n\t\tRZ_FREE(da->decls[i].defs);\n\t}\n\tRZ_FREE(da->decls);\n\tfree(da);\n}\n\nRZ_API void rz_bin_dwarf_line_info_free(RzBinDwarfLineInfo *li) {\n\tif (!li) {\n\t\treturn;\n\t}\n\trz_list_free(li->units);\n\trz_bin_source_line_info_free(li->lines);\n\tfree(li);\n}\n\nstatic void free_attr_value(RzBinDwarfAttrValue *val) {\n\t// TODO adjust to new forms, now we're leaking\n\tif (!val) {\n\t\treturn;\n\t}\n\tswitch (val->attr_form) {\n\tcase DW_FORM_strp:\n\tcase DW_FORM_string:\n\t\tRZ_FREE(val->string.content);\n\t\tbreak;\n\tcase DW_FORM_exprloc:\n\tcase DW_FORM_block:\n\tcase DW_FORM_block1:\n\tcase DW_FORM_block2:\n\tcase DW_FORM_block4:\n\t\tRZ_FREE(val->block.data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t};\n}\n\nstatic void free_die(RzBinDwarfDie *die) {\n\tsize_t i;\n\tif (!die) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < die->count; i++) {\n\t\tfree_attr_value(&die->attr_values[i]);\n\t}\n\tRZ_FREE(die->attr_values);\n}\n\nstatic void free_comp_unit(RzBinDwarfCompUnit *cu) {\n\tsize_t i;\n\tif (!cu) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < cu->count; i++) {\n\t\tif (cu->dies) {\n\t\t\tfree_die(&cu->dies[i]);\n\t\t}\n\t}\n\tRZ_FREE(cu->dies);\n}\n\nRZ_API void rz_bin_dwarf_debug_info_free(RzBinDwarfDebugInfo *inf) {\n\tif (!inf) {\n\t\treturn;\n\t}\n\tfor (size_t i = 0; i < inf->count; i++) {\n\t\tfree_comp_unit(&inf->comp_units[i]);\n\t}\n\tht_up_free(inf->line_info_offset_comp_dir);\n\tht_up_free(inf->lookup_table);\n\tfree(inf->comp_units);\n\tfree(inf);\n}\n\nstatic const ut8 *fill_block_data(const ut8 *buf, const ut8 *buf_end, RzBinDwarfBlock *block) {\n\tblock->data = calloc(sizeof(ut8), block->length);\n\tif (!block->data) {\n\t\treturn NULL;\n\t}\n\t/* Maybe unroll this as an optimization in future? */\n\tif (block->data) {\n\t\tsize_t j = 0;\n\t\tfor (j = 0; j < block->length; j++) {\n\t\t\tblock->data[j] = READ8(buf);\n\t\t}\n\t}\n\treturn buf;\n}\n\n/**\n * This function is quite incomplete and requires lot of work\n * With parsing various new FORM values\n * @brief Parses attribute value based on its definition\n *        and stores it into `value`\n *\n * @param obuf\n * @param obuf_len Buffer max capacity\n * @param def Attribute definition\n * @param value Parsed value storage\n * @param hdr Current unit header\n * @param debug_str Ptr to string section start\n * @param debug_str_len Length of the string section\n * @return const ut8* Updated buffer\n */\nstatic const ut8 *parse_attr_value(const ut8 *obuf, int obuf_len,\n\tRzBinDwarfAttrDef *def, RzBinDwarfAttrValue *value,\n\tconst RzBinDwarfCompUnitHdr *hdr,\n\tconst ut8 *debug_str, size_t debug_str_len,\n\tbool big_endian) {\n\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + obuf_len;\n\tsize_t j;\n\n\trz_return_val_if_fail(def && value && hdr && obuf && obuf_len >= 1, NULL);\n\n\tvalue->attr_form = def->attr_form;\n\tvalue->attr_name = def->attr_name;\n\tvalue->block.data = NULL;\n\tvalue->string.content = NULL;\n\tvalue->string.offset = 0;\n\n\t// http://www.dwarfstd.org/doc/DWARF4.pdf#page=161&zoom=100,0,560\n\tswitch (def->attr_form) {\n\tcase DW_FORM_addr:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tswitch (hdr->address_size) {\n\t\tcase 1:\n\t\t\tvalue->address = READ8(buf);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvalue->address = READ16(buf);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tvalue->address = READ32(buf);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tvalue->address = READ64(buf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf(\"DWARF: Unexpected pointer size: %u\\n\", (unsigned)hdr->address_size);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_data1:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ8(buf);\n\t\tbreak;\n\tcase DW_FORM_data2:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ16(buf);\n\t\tbreak;\n\tcase DW_FORM_data4:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ32(buf);\n\t\tbreak;\n\tcase DW_FORM_data8:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ64(buf);\n\t\tbreak;\n\tcase DW_FORM_data16: // TODO Fix this, right now I just read the data, but I need to make storage for it\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ64(buf);\n\t\tvalue->uconstant = READ64(buf);\n\t\tbreak;\n\tcase DW_FORM_sdata:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tbuf = rz_leb128(buf, buf_end - buf, &value->sconstant);\n\t\tbreak;\n\tcase DW_FORM_udata:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &value->uconstant, NULL);\n\t\tbreak;\n\tcase DW_FORM_string:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.content = *buf ? strdup((const char *)buf) : NULL;\n\t\tbuf += (strlen((const char *)buf) + 1);\n\t\tbreak;\n\tcase DW_FORM_block1:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ8(buf);\n\t\tbuf = fill_block_data(buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_block2:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ16(buf);\n\t\tif (value->block.length > 0) {\n\t\t\tvalue->block.data = calloc(sizeof(ut8), value->block.length);\n\t\t\tif (!value->block.data) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tvalue->block.data[j] = READ8(buf);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block4:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ32(buf);\n\t\tbuf = fill_block_data(buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_block: // variable length ULEB128\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &value->block.length, NULL);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = fill_block_data(buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_flag:\n\t\tvalue->kind = DW_AT_KIND_FLAG;\n\t\tvalue->flag = READ8(buf);\n\t\tbreak;\n\t// offset in .debug_str\n\tcase DW_FORM_strp:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = dwarf_read_offset(hdr->is_64bit, big_endian, &buf, buf_end);\n\t\tif (debug_str && value->string.offset < debug_str_len) {\n\t\t\tvalue->string.content =\n\t\t\t\tstrdup((const char *)(debug_str + value->string.offset));\n\t\t} else {\n\t\t\tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t}\n\t\tbreak;\n\t// offset in .debug_info\n\tcase DW_FORM_ref_addr:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = dwarf_read_offset(hdr->is_64bit, big_endian, &buf, buf_end);\n\t\tbreak;\n\t// This type of reference is an offset from the first byte of the compilation\n\t// header for the compilation unit containing the reference\n\tcase DW_FORM_ref1:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ8(buf);\n\t\tbreak;\n\tcase DW_FORM_ref2:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ16(buf);\n\t\tbreak;\n\tcase DW_FORM_ref4:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ32(buf);\n\t\tbreak;\n\tcase DW_FORM_ref8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ64(buf);\n\t\tbreak;\n\tcase DW_FORM_ref_udata:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\t// uleb128 is enough to fit into ut64?\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &value->reference, NULL);\n\t\tvalue->reference += hdr->unit_offset;\n\t\tbreak;\n\t// offset in a section other than .debug_info or .debug_str\n\tcase DW_FORM_sec_offset:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = dwarf_read_offset(hdr->is_64bit, big_endian, &buf, buf_end);\n\t\tbreak;\n\tcase DW_FORM_exprloc:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &value->block.length, NULL);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = fill_block_data(buf, buf_end, &value->block);\n\t\tbreak;\n\t// this means that the flag is present, nothing is read\n\tcase DW_FORM_flag_present:\n\t\tvalue->kind = DW_AT_KIND_FLAG;\n\t\tvalue->flag = true;\n\t\tbreak;\n\tcase DW_FORM_ref_sig8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ64(buf);\n\t\tbreak;\n\t// offset into .debug_line_str section, can't parse the section now, so we just skip\n\tcase DW_FORM_strx:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\t// value->string.offset = dwarf_read_offset (hdr->is_64bit, big_endian, &buf, buf_end);\n\t\t// if (debug_str && value->string.offset < debug_line_str_len) {\n\t\t// \tvalue->string.content =\n\t\t// \t\tstrdup ((const char *)(debug_str + value->string.offset));\n\t\t// } else {\n\t\t// \tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t// }\n\t\tbreak;\n\tcase DW_FORM_strx1:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ8(buf);\n\t\tbreak;\n\tcase DW_FORM_strx2:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ16(buf);\n\t\tbreak;\n\tcase DW_FORM_strx3: // TODO Add 3 byte int read\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_strx4:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ32(buf);\n\t\tbreak;\n\tcase DW_FORM_implicit_const:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = def->special;\n\t\tbreak;\n\t/*  addrx* forms : The index is relative to the value of the\n\t\tDW_AT_addr_base attribute of the associated compilation unit.\n\t    index into an array of addresses in the .debug_addr section.*/\n\tcase DW_FORM_addrx:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &value->address, NULL);\n\t\tbreak;\n\tcase DW_FORM_addrx1:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ8(buf);\n\t\tbreak;\n\tcase DW_FORM_addrx2:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ16(buf);\n\t\tbreak;\n\tcase DW_FORM_addrx3:\n\t\t// I need to add 3byte endianess free read here TODO\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_addrx4:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ32(buf);\n\t\tbreak;\n\tcase DW_FORM_line_ptr: // offset in a section .debug_line_str\n\tcase DW_FORM_strp_sup: // offset in a section .debug_line_str\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = dwarf_read_offset(hdr->is_64bit, big_endian, &buf, buf_end);\n\t\t// if (debug_str && value->string.offset < debug_line_str_len) {\n\t\t// \tvalue->string.content =\n\t\t// \t\tstrdupsts\n\t\tbreak;\n\t// offset in the supplementary object file\n\tcase DW_FORM_ref_sup4:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ32(buf);\n\t\tbreak;\n\tcase DW_FORM_ref_sup8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ64(buf);\n\t\tbreak;\n\t// An index into the .debug_loc\n\tcase DW_FORM_loclistx:\n\t\tvalue->kind = DW_AT_KIND_LOCLISTPTR;\n\t\tvalue->reference = dwarf_read_offset(hdr->is_64bit, big_endian, &buf, buf_end);\n\t\tbreak;\n\t\t// An index into the .debug_rnglists\n\tcase DW_FORM_rnglistx:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &value->address, NULL);\n\t\tbreak;\n\tdefault:\n\t\teprintf(\"Unknown DW_FORM 0x%02\" PFMT64x \"\\n\", def->attr_form);\n\t\tvalue->uconstant = 0;\n\t\treturn NULL;\n\t}\n\treturn buf;\n}\n\n/**\n * \\param buf Start of the DIE data\n * \\param buf_end\n * \\param info debug info where the line_info_offset_comp_dir will be populated if such an entry is found\n * \\param abbrev Abbreviation of the DIE\n * \\param hdr Unit header\n * \\param die DIE to store the parsed info into\n * \\param debug_str Ptr to string section start\n * \\param debug_str_len Length of the string section\n * \\return const ut8* Updated buffer\n */\nstatic const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RzBinDwarfDebugInfo *info, RzBinDwarfAbbrevDecl *abbrev,\n\tRzBinDwarfCompUnitHdr *hdr, RzBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, bool big_endian) {\n\tsize_t i;\n\tconst char *comp_dir = NULL;\n\tut64 line_info_offset = UT64_MAX;\n\tfor (i = 0; i < abbrev->count - 1; i++) {\n\t\tmemset(&die->attr_values[i], 0, sizeof(die->attr_values[i]));\n\n\t\tbuf = parse_attr_value(buf, buf_end - buf, &abbrev->defs[i],\n\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len, big_endian);\n\n\t\tRzBinDwarfAttrValue *attribute = &die->attr_values[i];\n\n\t\tif (attribute->attr_name == DW_AT_comp_dir && (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string) && attribute->string.content) {\n\t\t\tcomp_dir = attribute->string.content;\n\t\t}\n\t\tif (attribute->attr_name == DW_AT_stmt_list) {\n\t\t\tif (attribute->kind == DW_AT_KIND_CONSTANT) {\n\t\t\t\tline_info_offset = attribute->uconstant;\n\t\t\t} else if (attribute->kind == DW_AT_KIND_REFERENCE) {\n\t\t\t\tline_info_offset = attribute->reference;\n\t\t\t}\n\t\t}\n\t\tdie->count++;\n\t}\n\n\t// If this is a compilation unit dir attribute, we want to cache it so the line info parsing\n\t// which will need this info can quickly look it up.\n\tif (comp_dir && line_info_offset != UT64_MAX) {\n\t\tchar *name = strdup(comp_dir);\n\t\tif (name) {\n\t\t\tif (!ht_up_insert(info->line_info_offset_comp_dir, line_info_offset, name)) {\n\t\t\t\tfree(name);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn buf;\n}\n\n/**\n * @brief Reads throught comp_unit buffer and parses all its DIEntries\n *\n * @param buf_start Start of the compilation unit data\n * @param unit Unit to store the newly parsed information\n * @param abbrevs Parsed abbrev section info of *all* abbreviations\n * @param first_abbr_idx index for first abbrev of the current comp unit in abbrev array\n * @param debug_str Ptr to string section start\n * @param debug_str_len Length of the string section\n *\n * @return const ut8* Update buffer\n */\nstatic const ut8 *parse_comp_unit(RzBinDwarfDebugInfo *info, const ut8 *buf_start,\n\tRzBinDwarfCompUnit *unit, const RzBinDwarfDebugAbbrev *abbrevs,\n\tsize_t first_abbr_idx, const ut8 *debug_str, size_t debug_str_len, bool big_endian) {\n\n\tconst ut8 *buf = buf_start;\n\tconst ut8 *buf_end = buf_start + unit->hdr.length - unit->hdr.header_size;\n\n\twhile (buf && buf < buf_end && buf >= buf_start) {\n\t\tif (unit->count && unit->capacity == unit->count) {\n\t\t\texpand_cu(unit);\n\t\t}\n\t\tRzBinDwarfDie *die = &unit->dies[unit->count];\n\t\t// add header size to the offset;\n\t\tdie->offset = buf - buf_start + unit->hdr.header_size + unit->offset;\n\t\tdie->offset += unit->hdr.is_64bit ? 12 : 4;\n\n\t\t// DIE starts with ULEB128 with the abbreviation code\n\t\tut64 abbr_code;\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &abbr_code, NULL);\n\n\t\tif (abbr_code > abbrevs->count || !buf) { // something invalid\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (buf >= buf_end) {\n\t\t\tunit->count++; // we wanna store this entry too, usually the last one is null_entry\n\t\t\treturn buf; // return the buffer to parse next compilation units\n\t\t}\n\t\t// there can be \"null\" entries that have abbr_code == 0\n\t\tif (!abbr_code) {\n\t\t\tunit->count++;\n\t\t\tcontinue;\n\t\t}\n\t\tut64 abbr_idx = first_abbr_idx + abbr_code;\n\n\t\tif (abbrevs->count < abbr_idx) {\n\t\t\treturn NULL;\n\t\t}\n\t\tRzBinDwarfAbbrevDecl *abbrev = &abbrevs->decls[abbr_idx - 1];\n\n\t\tif (init_die(die, abbr_code, abbrev->count)) {\n\t\t\treturn NULL; // error\n\t\t}\n\t\tdie->tag = abbrev->tag;\n\t\tdie->has_children = abbrev->has_children;\n\n\t\tbuf = parse_die(buf, buf_end, info, abbrev, &unit->hdr, die, debug_str, debug_str_len, big_endian);\n\t\tif (!buf) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tunit->count++;\n\t}\n\treturn buf;\n}\n\n/**\n * @brief Reads all information about compilation unit header\n *\n * @param buf Start of the buffer\n * @param buf_end Upper bound of the buffer\n * @param unit Unit to read information into\n * @return ut8* Advanced position in a buffer\n */\nstatic const ut8 *info_comp_unit_read_hdr(const ut8 *buf, const ut8 *buf_end, RzBinDwarfCompUnitHdr *hdr, bool big_endian) {\n\t// 32-bit vs 64-bit dwarf formats\n\t// http://www.dwarfstd.org/doc/Dwarf3.pdf section 7.4\n\thdr->length = READ32(buf);\n\tif (hdr->length == (ut32)DWARF_INIT_LEN_64) { // then its 64bit\n\t\thdr->length = READ64(buf);\n\t\thdr->is_64bit = true;\n\t}\n\tconst ut8 *tmp = buf; // to calculate header size\n\thdr->version = READ16(buf);\n\tif (hdr->version == 5) {\n\t\thdr->unit_type = READ8(buf);\n\t\thdr->address_size = READ8(buf);\n\t\thdr->abbrev_offset = dwarf_read_offset(hdr->is_64bit, big_endian, &buf, buf_end);\n\n\t\tif (hdr->unit_type == DW_UT_skeleton || hdr->unit_type == DW_UT_split_compile) {\n\t\t\thdr->dwo_id = READ8(buf);\n\t\t} else if (hdr->unit_type == DW_UT_type || hdr->unit_type == DW_UT_split_type) {\n\t\t\thdr->type_sig = READ64(buf);\n\t\t\thdr->type_offset = dwarf_read_offset(hdr->is_64bit, big_endian, &buf, buf_end);\n\t\t}\n\t} else {\n\t\thdr->abbrev_offset = dwarf_read_offset(hdr->is_64bit, big_endian, &buf, buf_end);\n\t\thdr->address_size = READ8(buf);\n\t}\n\thdr->header_size = buf - tmp; // header size excluding length field\n\treturn buf;\n}\nstatic int expand_info(RzBinDwarfDebugInfo *info) {\n\trz_return_val_if_fail(info && info->capacity == info->count, -1);\n\n\tRzBinDwarfCompUnit *tmp = realloc(info->comp_units,\n\t\tinfo->capacity * 2 * sizeof(RzBinDwarfCompUnit));\n\tif (!tmp) {\n\t\treturn -1;\n\t}\n\n\tmemset((ut8 *)tmp + info->capacity * sizeof(RzBinDwarfCompUnit),\n\t\t0, info->capacity * sizeof(RzBinDwarfCompUnit));\n\n\tinfo->comp_units = tmp;\n\tinfo->capacity *= 2;\n\n\treturn 0;\n}\n\n/**\n * @brief Parses whole .debug_info section\n *\n * @param da Parsed Abbreviations\n * @param obuf .debug_info section buffer start\n * @param len length of the section buffer\n * @param debug_str start of the .debug_str section\n * @param debug_str_len length of the debug_str section\n * @param big_endian\n * @return RZ_API* parse_info_raw Parsed information\n */\nstatic RzBinDwarfDebugInfo *parse_info_raw(RzBinDwarfDebugAbbrev *da,\n\tconst ut8 *obuf, size_t len,\n\tconst ut8 *debug_str, size_t debug_str_len, bool big_endian) {\n\n\trz_return_val_if_fail(da && obuf, false);\n\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + len;\n\n\tRzBinDwarfDebugInfo *info = RZ_NEW0(RzBinDwarfDebugInfo);\n\tif (!info) {\n\t\treturn NULL;\n\t}\n\tif (!init_debug_info(info)) {\n\t\tgoto cleanup;\n\t}\n\tint unit_idx = 0;\n\n\twhile (buf < buf_end) {\n\t\tif (info->count >= info->capacity) {\n\t\t\tif (expand_info(info)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tRzBinDwarfCompUnit *unit = &info->comp_units[unit_idx];\n\t\tif (init_comp_unit(unit) < 0) {\n\t\t\tunit_idx--;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tinfo->count++;\n\n\t\tunit->offset = buf - obuf;\n\t\t// small redundancy, because it was easiest solution at a time\n\t\tunit->hdr.unit_offset = buf - obuf;\n\n\t\tbuf = info_comp_unit_read_hdr(buf, buf_end, &unit->hdr, big_endian);\n\n\t\tif (unit->hdr.length > len) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (da->decls->count >= da->capacity) {\n\t\t\teprintf(\"WARNING: malformed dwarf have not enough buckets for decls.\\n\");\n\t\t}\n\t\trz_warn_if_fail(da->count <= da->capacity);\n\n\t\t// find abbrev start for current comp unit\n\t\t// we could also do naive, ((char *)da->decls) + abbrev_offset,\n\t\t// but this is more bulletproof to invalid DWARF\n\t\tRzBinDwarfAbbrevDecl key = { .offset = unit->hdr.abbrev_offset };\n\t\tRzBinDwarfAbbrevDecl *abbrev_start = bsearch(&key, da->decls, da->count, sizeof(key), abbrev_cmp);\n\t\tif (!abbrev_start) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\t// They point to the same array object, so should be def. behaviour\n\t\tsize_t first_abbr_idx = abbrev_start - da->decls;\n\n\t\tbuf = parse_comp_unit(info, buf, unit, da, first_abbr_idx, debug_str, debug_str_len, big_endian);\n\n\t\tif (!buf) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tunit_idx++;\n\t}\n\n\treturn info;\n\ncleanup:\n\trz_bin_dwarf_debug_info_free(info);\n\treturn NULL;\n}\n\nstatic RzBinDwarfDebugAbbrev *parse_abbrev_raw(const ut8 *obuf, size_t len) {\n\tconst ut8 *buf = obuf, *buf_end = obuf + len;\n\tut64 tmp, attr_code, attr_form, offset;\n\tst64 special;\n\tut8 has_children;\n\tRzBinDwarfAbbrevDecl *tmpdecl;\n\n\t// XXX - Set a suitable value here.\n\tif (!obuf || len < 3) {\n\t\treturn NULL;\n\t}\n\tRzBinDwarfDebugAbbrev *da = RZ_NEW0(RzBinDwarfDebugAbbrev);\n\n\tinit_debug_abbrev(da);\n\n\twhile (buf && buf + 1 < buf_end) {\n\t\toffset = buf - obuf;\n\t\tbuf = rz_uleb128(buf, (size_t)(buf_end - buf), &tmp, NULL);\n\t\tif (!buf || !tmp || buf >= buf_end) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (da->count == da->capacity) {\n\t\t\texpand_debug_abbrev(da);\n\t\t}\n\t\ttmpdecl = &da->decls[da->count];\n\t\tinit_abbrev_decl(tmpdecl);\n\n\t\ttmpdecl->code = tmp;\n\t\tbuf = rz_uleb128(buf, (size_t)(buf_end - buf), &tmp, NULL);\n\t\ttmpdecl->tag = tmp;\n\n\t\ttmpdecl->offset = offset;\n\t\tif (buf >= buf_end) {\n\t\t\tbreak;\n\t\t}\n\t\thas_children = READ8(buf);\n\t\ttmpdecl->has_children = has_children;\n\t\tdo {\n\t\t\tif (tmpdecl->count == tmpdecl->capacity) {\n\t\t\t\texpand_abbrev_decl(tmpdecl);\n\t\t\t}\n\t\t\tbuf = rz_uleb128(buf, (size_t)(buf_end - buf), &attr_code, NULL);\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf = rz_uleb128(buf, (size_t)(buf_end - buf), &attr_form, NULL);\n\t\t\t// http://www.dwarfstd.org/doc/DWARF5.pdf#page=225\n\t\t\tif (attr_form == DW_FORM_implicit_const) {\n\t\t\t\tbuf = rz_leb128(buf, (size_t)(buf_end - buf), &special);\n\t\t\t\ttmpdecl->defs[tmpdecl->count].special = special;\n\t\t\t}\n\t\t\ttmpdecl->defs[tmpdecl->count].attr_name = attr_code;\n\t\t\ttmpdecl->defs[tmpdecl->count].attr_form = attr_form;\n\t\t\ttmpdecl->count++;\n\t\t} while (attr_code && attr_form);\n\n\t\tda->count++;\n\t}\n\treturn da;\n}\n\nRzBinSection *getsection(RzBinFile *binfile, const char *sn) {\n\trz_return_val_if_fail(binfile && sn, NULL);\n\tRzListIter *iter;\n\tRzBinSection *section = NULL;\n\tRzBinObject *o = binfile->o;\n\tif (!o || !o->sections) {\n\t\treturn NULL;\n\t}\n\trz_list_foreach (o->sections, iter, section) {\n\t\tif (!section->name) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(section->name, sn)) {\n\t\t\treturn section;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic ut8 *get_section_bytes(RzBinFile *binfile, const char *sect_name, size_t *len) {\n\trz_return_val_if_fail(binfile && sect_name && len, NULL);\n\tRzBinSection *section = getsection(binfile, sect_name);\n\tif (!section) {\n\t\treturn NULL;\n\t}\n\tif (section->size > binfile->size) {\n\t\treturn NULL;\n\t}\n\t*len = section->size;\n\tut8 *buf = calloc(1, *len);\n\trz_buf_read_at(binfile->buf, section->paddr, buf, *len);\n\treturn buf;\n}\n\n/**\n * @brief Parses .debug_info section\n *\n * @param da Parsed abbreviations\n * @param bin\n * @return RzBinDwarfDebugInfo* Parsed information, NULL if error\n */\nRZ_API RzBinDwarfDebugInfo *rz_bin_dwarf_parse_info(RzBinFile *binfile, RzBinDwarfDebugAbbrev *da) {\n\trz_return_val_if_fail(binfile && da, NULL);\n\tRzBinSection *section = getsection(binfile, \"debug_info\");\n\tif (!section) {\n\t\treturn NULL;\n\t}\n\n\tRzBinDwarfDebugInfo *info = NULL;\n\tut64 debug_str_len = 0;\n\tut8 *debug_str_buf = NULL;\n\n\tRzBinSection *debug_str = debug_str = getsection(binfile, \"debug_str\");\n\tif (debug_str) {\n\t\tdebug_str_len = debug_str->size;\n\t\tdebug_str_buf = RZ_NEWS0(ut8, debug_str_len + 1);\n\t\tif (!debug_str_buf) {\n\t\t\tgoto cave;\n\t\t}\n\t\tst64 ret = rz_buf_read_at(binfile->buf, debug_str->paddr,\n\t\t\tdebug_str_buf, debug_str_len);\n\t\tif (!ret) {\n\t\t\tgoto cave_debug_str_buf;\n\t\t}\n\t}\n\n\tut64 len = section->size;\n\tif (!len) {\n\t\tgoto cave_debug_str_buf;\n\t}\n\tut8 *buf = RZ_NEWS0(ut8, len);\n\tif (!buf) {\n\t\tgoto cave_debug_str_buf;\n\t}\n\tif (!rz_buf_read_at(binfile->buf, section->paddr, buf, len)) {\n\t\tgoto cave_buf;\n\t}\n\tinfo = parse_info_raw(da, buf, len, debug_str_buf, debug_str_len,\n\t\tbinfile->o && binfile->o->info && binfile->o->info->big_endian);\n\tif (!info) {\n\t\tgoto cave_buf;\n\t}\n\n\t// build hashtable after whole parsing because of possible relocations\n\tif (info) {\n\t\tsize_t i, j;\n\t\tfor (i = 0; i < info->count; i++) {\n\t\t\tRzBinDwarfCompUnit *unit = &info->comp_units[i];\n\t\t\tfor (j = 0; j < unit->count; j++) {\n\t\t\t\tRzBinDwarfDie *die = &unit->dies[j];\n\t\t\t\tht_up_insert(info->lookup_table, die->offset, die); // optimization for further processing}\n\t\t\t}\n\t\t}\n\t}\ncave_buf:\n\tfree(buf);\ncave_debug_str_buf:\n\tfree(debug_str_buf);\ncave:\n\treturn info;\n}\n\n/**\n * \\param info if not NULL, filenames can get resolved to absolute paths using the compilation unit dirs from it\n */\nRZ_API RzBinDwarfLineInfo *rz_bin_dwarf_parse_line(RzBinFile *binfile, RZ_NULLABLE RzBinDwarfDebugInfo *info, RzBinDwarfLineInfoMask mask) {\n\trz_return_val_if_fail(binfile, NULL);\n\tRzBinSection *section = getsection(binfile, \"debug_line\");\n\tif (!section) {\n\t\treturn NULL;\n\t}\n\tut64 len = section->size;\n\tif (len < 1) {\n\t\treturn NULL;\n\t}\n\tut8 *buf = RZ_NEWS0(ut8, len + 1);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tint ret = rz_buf_read_at(binfile->buf, section->paddr, buf, len);\n\tif (ret != len) {\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\t// Actually parse the section\n\tRzBinDwarfLineInfo *r = parse_line_raw(binfile, buf, len, mask, binfile->o && binfile->o->info && binfile->o->info->big_endian, info);\n\tfree(buf);\n\treturn r;\n}\n\nRZ_API RzList /*<RzBinDwarfARangeSet>*/ *rz_bin_dwarf_parse_aranges(RzBinFile *binfile) {\n\trz_return_val_if_fail(binfile, NULL);\n\tRzBinSection *section = getsection(binfile, \"debug_aranges\");\n\tif (!section) {\n\t\treturn NULL;\n\t}\n\tsize_t len = section->size;\n\tif (!len) {\n\t\treturn NULL;\n\t}\n\tut8 *buf = RZ_NEWS0(ut8, len);\n\tint ret = rz_buf_read_at(binfile->buf, section->paddr, buf, len);\n\tif (!ret) {\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tRzList *r = parse_aranges_raw(buf, len, binfile->o && binfile->o->info && binfile->o->info->big_endian);\n\tfree(buf);\n\treturn r;\n}\n\nRZ_API RzBinDwarfDebugAbbrev *rz_bin_dwarf_parse_abbrev(RzBinFile *binfile) {\n\trz_return_val_if_fail(binfile, NULL);\n\tsize_t len = 0;\n\tut8 *buf = get_section_bytes(binfile, \"debug_abbrev\", &len);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tRzBinDwarfDebugAbbrev *abbrevs = parse_abbrev_raw(buf, len);\n\tfree(buf);\n\treturn abbrevs;\n}\n\nstatic inline ut64 get_max_offset(size_t addr_size) {\n\tswitch (addr_size) {\n\tcase 2:\n\t\treturn UT16_MAX;\n\tcase 4:\n\t\treturn UT32_MAX;\n\tcase 8:\n\t\treturn UT64_MAX;\n\t}\n\treturn 0;\n}\n\nstatic inline RzBinDwarfLocList *create_loc_list(ut64 offset) {\n\tRzBinDwarfLocList *list = RZ_NEW0(RzBinDwarfLocList);\n\tif (list) {\n\t\tlist->list = rz_list_new();\n\t\tlist->offset = offset;\n\t}\n\treturn list;\n}\n\nstatic inline RzBinDwarfLocRange *create_loc_range(ut64 start, ut64 end, RzBinDwarfBlock *block) {\n\tRzBinDwarfLocRange *range = RZ_NEW0(RzBinDwarfLocRange);\n\tif (range) {\n\t\trange->start = start;\n\t\trange->end = end;\n\t\trange->expression = block;\n\t}\n\treturn range;\n}\n\nstatic void free_loc_table_list(RzBinDwarfLocList *loc_list) {\n\tRzListIter *iter;\n\tRzBinDwarfLocRange *range;\n\trz_list_foreach (loc_list->list, iter, range) {\n\t\tfree(range->expression->data);\n\t\tfree(range->expression);\n\t\tfree(range);\n\t}\n\trz_list_free(loc_list->list);\n\tfree(loc_list);\n}\n\nstatic HtUP *parse_loc_raw(HtUP /*<offset, List *<LocListEntry>*/ *loc_table, const ut8 *buf, size_t len, size_t addr_size,\n\tbool big_endian) {\n\t/* GNU has their own extensions GNU locviews that we can't parse */\n\tconst ut8 *const buf_start = buf;\n\tconst ut8 *buf_end = buf + len;\n\t/* for recognizing Base address entry */\n\tut64 max_offset = get_max_offset(addr_size);\n\n\tut64 address_base = 0; /* remember base of the loclist */\n\tut64 list_offset = 0;\n\n\tRzBinDwarfLocList *loc_list = NULL;\n\tRzBinDwarfLocRange *range = NULL;\n\twhile (buf && buf < buf_end) {\n\t\tut64 start_addr = dwarf_read_address(addr_size, big_endian, &buf, buf_end);\n\t\tut64 end_addr = dwarf_read_address(addr_size, big_endian, &buf, buf_end);\n\n\t\tif (start_addr == 0 && end_addr == 0) { /* end of list entry: 0, 0 */\n\t\t\tif (loc_list) {\n\t\t\t\tht_up_insert(loc_table, loc_list->offset, loc_list);\n\t\t\t\tlist_offset = buf - buf_start;\n\t\t\t\tloc_list = NULL;\n\t\t\t}\n\t\t\taddress_base = 0;\n\t\t\tcontinue;\n\t\t} else if (start_addr == max_offset && end_addr != max_offset) {\n\t\t\t/* base address, DWARF2 doesn't have this type of entry, these entries shouldn't\n\t\t\t   be in the list, they are just informational entries for further parsing (address_base) */\n\t\t\taddress_base = end_addr;\n\t\t} else { /* location list entry: */\n\t\t\tif (!loc_list) {\n\t\t\t\tloc_list = create_loc_list(list_offset);\n\t\t\t}\n\t\t\t/* TODO in future parse expressions to better structure in dwarf.c and not in dwarf_process.c */\n\t\t\tRzBinDwarfBlock *block = RZ_NEW0(RzBinDwarfBlock);\n\t\t\tblock->length = READ16(buf);\n\t\t\tbuf = fill_block_data(buf, buf_end, block);\n\t\t\trange = create_loc_range(start_addr + address_base, end_addr + address_base, block);\n\t\t\tif (!range) {\n\t\t\t\tfree(block);\n\t\t\t}\n\t\t\trz_list_append(loc_list->list, range);\n\t\t\trange = NULL;\n\t\t}\n\t}\n\t/* if for some reason end of list is missing, then loc_list would leak */\n\tif (loc_list) {\n\t\tfree_loc_table_list(loc_list);\n\t}\n\treturn loc_table;\n}\n\n/**\n * @brief Parses out the .debug_loc section into a table that maps each list as\n *        offset of a list -> LocationList\n *\n * @param binfile\n * @param addr_size machine address size used in executable (necessary for parsing)\n * @return RZ_API*\n */\nRZ_API HtUP /*<offset, RzBinDwarfLocList*/ *rz_bin_dwarf_parse_loc(RzBinFile *binfile, int addr_size) {\n\trz_return_val_if_fail(binfile, NULL);\n\t/* The standarparse_loc_raw_frame, not sure why is that */\n\tsize_t len = 0;\n\tut8 *buf = get_section_bytes(binfile, \"debug_loc\", &len);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tHtUP /*<offset, RzBinDwarfLocList*/ *loc_table = ht_up_new0();\n\tif (!loc_table) {\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tloc_table = parse_loc_raw(loc_table, buf, len, addr_size, binfile->o && binfile->o->info && binfile->o->info->big_endian);\n\tfree(buf);\n\treturn loc_table;\n}\n\nstatic void free_loc_table_entry(HtUPKv *kv) {\n\tif (kv) {\n\t\tfree_loc_table_list(kv->value);\n\t}\n}\n\nRZ_API void rz_bin_dwarf_loc_free(HtUP /*<offset, RzBinDwarfLocList*>*/ *loc_table) {\n\trz_return_if_fail(loc_table);\n\tloc_table->opt.freefn = free_loc_table_entry;\n\tht_up_free(loc_table);\n}\n", "NAME=ELF: negative vnext crash\nFILE=bins/elf/analysis/6921737e-08e3-11e6-998c-a8ddd566ab1c.jpg\nCMDS=q!\nEXPECT=<<EOF\nEOF\nRUN\n\nNAME=pseudo-crash\nFILE==\nCMDS=e asm.pseudo=1; e asm.arch=x86; e asm.bits=64; wx 7299; pdj 1\nEXPECT=<<EOF\n[{\"offset\":0,\"esil\":\"cf,?{,18446744073709551515,rip,=,}\",\"refptr\":false,\"fcn_addr\":0,\"fcn_last\":0,\"size\":2,\"opcode\":\"if (((unsigned) var) < 0) goto 0xffffffffffffff9b\",\"disasm\":\"jb 0xffffffffffffff9b\",\"bytes\":\"7299\",\"family\":\"cpu\",\"type\":\"cjmp\",\"reloc\":false,\"type_num\":2147483649,\"type2_num\":0,\"jump\":-101,\"fail\":2}]\nEOF\nRUN\n\nNAME=ELF: ld-uclibc\nFILE=bins/elf/ld-uClibc-0.9.33.2.so\nCMDS=<<EOF\nii\niij\nEOF\nEXPECT=<<EOF\nnth vaddr bind type lib name \n-----------------------------\n[]\nEOF\nRUN\n"], "fixing_code": ["// SPDX-FileCopyrightText: 2012-2018 pancake <pancake@nopcode.org>\n// SPDX-FileCopyrightText: 2012-2018 Fedor Sakharov <fedor.sakharov@gmail.com>\n// SPDX-License-Identifier: LGPL-3.0-only\n\n#define D0 if (1)\n#define D1 if (1)\n\n#include <errno.h>\n\n#define DWARF_DUMP 0\n\n#if DWARF_DUMP\n#define DBGFD stdout\n#else\n#define DBGFD NULL\n#endif\n\n#include <rz_bin.h>\n#include <rz_bin_dwarf.h>\n#include <rz_core.h>\n\n#define STANDARD_OPERAND_COUNT_DWARF2 9\n#define STANDARD_OPERAND_COUNT_DWARF3 12\n#define RZ_BIN_DWARF_INFO             1\n\n#define READ8(buf) \\\n\t(((buf) + 1 < buf_end) ? *((ut8 *)(buf)) : 0); \\\n\t(buf)++\n#define READ16(buf) \\\n\t(((buf) + sizeof(ut16) < buf_end) ? rz_read_ble16(buf, big_endian) : 0); \\\n\t(buf) += sizeof(ut16)\n#define READ32(buf) \\\n\t(((buf) + sizeof(ut32) < buf_end) ? rz_read_ble32(buf, big_endian) : 0); \\\n\t(buf) += sizeof(ut32)\n#define READ64(buf) \\\n\t(((buf) + sizeof(ut64) < buf_end) ? rz_read_ble64(buf, big_endian) : 0); \\\n\t(buf) += sizeof(ut64)\n\nstatic const char *dwarf_tag_name_encodings[] = {\n\t[DW_TAG_null_entry] = \"DW_TAG_null_entry\",\n\t[DW_TAG_array_type] = \"DW_TAG_array_type\",\n\t[DW_TAG_class_type] = \"DW_TAG_class_type\",\n\t[DW_TAG_entry_point] = \"DW_TAG_entry_point\",\n\t[DW_TAG_enumeration_type] = \"DW_TAG_enumeration_type\",\n\t[DW_TAG_formal_parameter] = \"DW_TAG_formal_parameter\",\n\t[DW_TAG_imported_declaration] = \"DW_TAG_imported_declaration\",\n\t[DW_TAG_label] = \"DW_TAG_label\",\n\t[DW_TAG_lexical_block] = \"DW_TAG_lexical_block\",\n\t[DW_TAG_member] = \"DW_TAG_member\",\n\t[DW_TAG_pointer_type] = \"DW_TAG_pointer_type\",\n\t[DW_TAG_reference_type] = \"DW_TAG_reference_type\",\n\t[DW_TAG_compile_unit] = \"DW_TAG_compile_unit\",\n\t[DW_TAG_string_type] = \"DW_TAG_string_type\",\n\t[DW_TAG_structure_type] = \"DW_TAG_structure_type\",\n\t[DW_TAG_subroutine_type] = \"DW_TAG_subroutine_type\",\n\t[DW_TAG_typedef] = \"DW_TAG_typedef\",\n\t[DW_TAG_union_type] = \"DW_TAG_union_type\",\n\t[DW_TAG_unspecified_parameters] = \"DW_TAG_unspecified_parameters\",\n\t[DW_TAG_variant] = \"DW_TAG_variant\",\n\t[DW_TAG_common_block] = \"DW_TAG_common_block\",\n\t[DW_TAG_common_inclusion] = \"DW_TAG_common_inclusion\",\n\t[DW_TAG_inheritance] = \"DW_TAG_inheritance\",\n\t[DW_TAG_inlined_subroutine] = \"DW_TAG_inlined_subroutine\",\n\t[DW_TAG_module] = \"DW_TAG_module\",\n\t[DW_TAG_ptr_to_member_type] = \"DW_TAG_ptr_to_member_type\",\n\t[DW_TAG_set_type] = \"DW_TAG_set_type\",\n\t[DW_TAG_subrange_type] = \"DW_TAG_subrange_type\",\n\t[DW_TAG_with_stmt] = \"DW_TAG_with_stmt\",\n\t[DW_TAG_access_declaration] = \"DW_TAG_access_declaration\",\n\t[DW_TAG_base_type] = \"DW_TAG_base_type\",\n\t[DW_TAG_catch_block] = \"DW_TAG_catch_block\",\n\t[DW_TAG_const_type] = \"DW_TAG_const_type\",\n\t[DW_TAG_constant] = \"DW_TAG_constant\",\n\t[DW_TAG_enumerator] = \"DW_TAG_enumerator\",\n\t[DW_TAG_file_type] = \"DW_TAG_file_type\",\n\t[DW_TAG_friend] = \"DW_TAG_friend\",\n\t[DW_TAG_namelist] = \"DW_TAG_namelist\",\n\t[DW_TAG_namelist_item] = \"DW_TAG_namelist_item\",\n\t[DW_TAG_packed_type] = \"DW_TAG_packed_type\",\n\t[DW_TAG_subprogram] = \"DW_TAG_subprogram\",\n\t[DW_TAG_template_type_param] = \"DW_TAG_template_type_param\",\n\t[DW_TAG_template_value_param] = \"DW_TAG_template_value_param\",\n\t[DW_TAG_thrown_type] = \"DW_TAG_thrown_type\",\n\t[DW_TAG_try_block] = \"DW_TAG_try_block\",\n\t[DW_TAG_variant_part] = \"DW_TAG_variant_part\",\n\t[DW_TAG_variable] = \"DW_TAG_variable\",\n\t[DW_TAG_volatile_type] = \"DW_TAG_volatile_type\",\n\t[DW_TAG_dwarf_procedure] = \"DW_TAG_dwarf_procedure\",\n\t[DW_TAG_restrict_type] = \"DW_TAG_restrict_type\",\n\t[DW_TAG_interface_type] = \"DW_TAG_interface_type\",\n\t[DW_TAG_namespace] = \"DW_TAG_namespace\",\n\t[DW_TAG_imported_module] = \"DW_TAG_imported_module\",\n\t[DW_TAG_unspecified_type] = \"DW_TAG_unspecified_type\",\n\t[DW_TAG_partial_unit] = \"DW_TAG_partial_unit\",\n\t[DW_TAG_imported_unit] = \"DW_TAG_imported_unit\",\n\t[DW_TAG_mutable_type] = \"DW_TAG_mutable_type\",\n\t[DW_TAG_condition] = \"DW_TAG_condition\",\n\t[DW_TAG_shared_type] = \"DW_TAG_shared_type\",\n\t[DW_TAG_type_unit] = \"DW_TAG_type_unit\",\n\t[DW_TAG_rvalue_reference_type] = \"DW_TAG_rvalue_reference_type\",\n\t[DW_TAG_template_alias] = \"DW_TAG_template_alias\",\n\t[DW_TAG_LAST] = \"DW_TAG_LAST\",\n};\n\nstatic const char *dwarf_attr_encodings[] = {\n\t[DW_AT_sibling] = \"DW_AT_siblings\",\n\t[DW_AT_location] = \"DW_AT_location\",\n\t[DW_AT_name] = \"DW_AT_name\",\n\t[DW_AT_ordering] = \"DW_AT_ordering\",\n\t[DW_AT_byte_size] = \"DW_AT_byte_size\",\n\t[DW_AT_bit_size] = \"DW_AT_bit_size\",\n\t[DW_AT_stmt_list] = \"DW_AT_stmt_list\",\n\t[DW_AT_low_pc] = \"DW_AT_low_pc\",\n\t[DW_AT_high_pc] = \"DW_AT_high_pc\",\n\t[DW_AT_language] = \"DW_AT_language\",\n\t[DW_AT_discr] = \"DW_AT_discr\",\n\t[DW_AT_discr_value] = \"DW_AT_discr_value\",\n\t[DW_AT_visibility] = \"DW_AT_visibility\",\n\t[DW_AT_import] = \"DW_AT_import\",\n\t[DW_AT_string_length] = \"DW_AT_string_length\",\n\t[DW_AT_common_reference] = \"DW_AT_common_reference\",\n\t[DW_AT_comp_dir] = \"DW_AT_comp_dir\",\n\t[DW_AT_const_value] = \"DW_AT_const_value\",\n\t[DW_AT_containing_type] = \"DW_AT_containing_type\",\n\t[DW_AT_default_value] = \"DW_AT_default_value\",\n\t[DW_AT_inline] = \"DW_AT_inline\",\n\t[DW_AT_is_optional] = \"DW_AT_is_optional\",\n\t[DW_AT_lower_bound] = \"DW_AT_lower_bound\",\n\t[DW_AT_producer] = \"DW_AT_producer\",\n\t[DW_AT_prototyped] = \"DW_AT_prototyped\",\n\t[DW_AT_return_addr] = \"DW_AT_return_addr\",\n\t[DW_AT_start_scope] = \"DW_AT_start_scope\",\n\t[DW_AT_stride_size] = \"DW_AT_stride_size\",\n\t[DW_AT_upper_bound] = \"DW_AT_upper_bound\",\n\t[DW_AT_abstract_origin] = \"DW_AT_abstract_origin\",\n\t[DW_AT_accessibility] = \"DW_AT_accessibility\",\n\t[DW_AT_address_class] = \"DW_AT_address_class\",\n\t[DW_AT_artificial] = \"DW_AT_artificial\",\n\t[DW_AT_base_types] = \"DW_AT_base_types\",\n\t[DW_AT_calling_convention] = \"DW_AT_calling_convention\",\n\t[DW_AT_count] = \"DW_AT_count\",\n\t[DW_AT_data_member_location] = \"DW_AT_data_member_location\",\n\t[DW_AT_decl_column] = \"DW_AT_decl_column\",\n\t[DW_AT_decl_file] = \"DW_AT_decl_file\",\n\t[DW_AT_decl_line] = \"DW_AT_decl_line\",\n\t[DW_AT_declaration] = \"DW_AT_declaration\",\n\t[DW_AT_discr_list] = \"DW_AT_discr_list\",\n\t[DW_AT_encoding] = \"DW_AT_encoding\",\n\t[DW_AT_external] = \"DW_AT_external\",\n\t[DW_AT_frame_base] = \"DW_AT_frame_base\",\n\t[DW_AT_friend] = \"DW_AT_friend\",\n\t[DW_AT_identifier_case] = \"DW_AT_identifier_case\",\n\t[DW_AT_macro_info] = \"DW_AT_macro_info\",\n\t[DW_AT_namelist_item] = \"DW_AT_namelist_item\",\n\t[DW_AT_priority] = \"DW_AT_priority\",\n\t[DW_AT_segment] = \"DW_AT_segment\",\n\t[DW_AT_specification] = \"DW_AT_specification\",\n\t[DW_AT_static_link] = \"DW_AT_static_link\",\n\t[DW_AT_type] = \"DW_AT_type\",\n\t[DW_AT_use_location] = \"DW_AT_use_location\",\n\t[DW_AT_variable_parameter] = \"DW_AT_variable_parameter\",\n\t[DW_AT_virtuality] = \"DW_AT_virtuality\",\n\t[DW_AT_vtable_elem_location] = \"DW_AT_vtable_elem_location\",\n\t[DW_AT_allocated] = \"DW_AT_allocated\",\n\t[DW_AT_associated] = \"DW_AT_associated\",\n\t[DW_AT_data_location] = \"DW_AT_data_location\",\n\t[DW_AT_byte_stride] = \"DW_AT_byte_stride\",\n\t[DW_AT_entry_pc] = \"DW_AT_entry_pc\",\n\t[DW_AT_use_UTF8] = \"DW_AT_use_UTF8\",\n\t[DW_AT_extension] = \"DW_AT_extension\",\n\t[DW_AT_ranges] = \"DW_AT_ranges\",\n\t[DW_AT_trampoline] = \"DW_AT_trampoline\",\n\t[DW_AT_call_column] = \"DW_AT_call_column\",\n\t[DW_AT_call_file] = \"DW_AT_call_file\",\n\t[DW_AT_call_line] = \"DW_AT_call_line\",\n\t[DW_AT_description] = \"DW_AT_description\",\n\t[DW_AT_binary_scale] = \"DW_AT_binary_scale\",\n\t[DW_AT_decimal_scale] = \"DW_AT_decimal_scale\",\n\t[DW_AT_small] = \"DW_AT_small\",\n\t[DW_AT_decimal_sign] = \"DW_AT_decimal_sign\",\n\t[DW_AT_digit_count] = \"DW_AT_digit_count\",\n\t[DW_AT_picture_string] = \"DW_AT_picture_string\",\n\t[DW_AT_mutable] = \"DW_AT_mutable\",\n\t[DW_AT_threads_scaled] = \"DW_AT_threads_scaled\",\n\t[DW_AT_explicit] = \"DW_AT_explicit\",\n\t[DW_AT_object_pointer] = \"DW_AT_object_pointer\",\n\t[DW_AT_endianity] = \"DW_AT_endianity\",\n\t[DW_AT_elemental] = \"DW_AT_elemental\",\n\t[DW_AT_pure] = \"DW_AT_pure\",\n\t[DW_AT_recursive] = \"DW_AT_recursive\",\n\t[DW_AT_signature] = \"DW_AT_signature\",\n\t[DW_AT_main_subprogram] = \"DW_AT_main_subprogram\",\n\t[DW_AT_data_bit_offset] = \"DW_AT_data_big_offset\",\n\t[DW_AT_const_expr] = \"DW_AT_const_expr\",\n\t[DW_AT_enum_class] = \"DW_AT_enum_class\",\n\t[DW_AT_linkage_name] = \"DW_AT_linkage_name\",\n\t[DW_AT_string_length_bit_size] = \"DW_AT_string_length_bit_size\",\n\t[DW_AT_string_length_byte_size] = \"DW_AT_string_length_byte_size\",\n\t[DW_AT_rank] = \"DW_AT_rank\",\n\t[DW_AT_str_offsets_base] = \"DW_AT_str_offsets_base\",\n\t[DW_AT_addr_base] = \"DW_AT_addr_base\",\n\t[DW_AT_rnglists_base] = \"DW_AT_rnglists_base\",\n\t[DW_AT_dwo_name] = \"DW_AT_dwo_name\",\n\t[DW_AT_reference] = \"DW_AT_reference\",\n\t[DW_AT_rvalue_reference] = \"DW_AT_rvalue_reference\",\n\t[DW_AT_macros] = \"DW_AT_macros\",\n\t[DW_AT_call_all_calls] = \"DW_AT_call_all_calls\",\n\t[DW_AT_call_all_source_calls] = \"DW_AT_call_all_source_calls\",\n\t[DW_AT_call_all_tail_calls] = \"DW_AT_call_all_tail_calls\",\n\t[DW_AT_call_return_pc] = \"DW_AT_call_return_pc\",\n\t[DW_AT_call_value] = \"DW_AT_call_value\",\n\t[DW_AT_call_origin] = \"DW_AT_call_origin\",\n\t[DW_AT_call_parameter] = \"DW_AT_call_parameter\",\n\t[DW_AT_call_pc] = \"DW_AT_call_pc\",\n\t[DW_AT_call_tail_call] = \"DW_AT_call_tail_call\",\n\t[DW_AT_call_target] = \"DW_AT_call_target\",\n\t[DW_AT_call_target_clobbered] = \"DW_AT_call_target_clobbered\",\n\t[DW_AT_call_data_location] = \"DW_AT_call_data_location\",\n\t[DW_AT_call_data_value] = \"DW_AT_call_data_value\",\n\t[DW_AT_noreturn] = \"DW_AT_noreturn\",\n\t[DW_AT_alignment] = \"DW_AT_alignment\",\n\t[DW_AT_export_symbols] = \"DW_AT_export_symbols\",\n\t[DW_AT_deleted] = \"DW_AT_deleted\",\n\t[DW_AT_defaulted] = \"DW_AT_defaulted\",\n\t[DW_AT_loclists_base] = \"DW_AT_loclists_base\"\n};\n\nstatic const char *dwarf_attr_form_encodings[] = {\n\t[DW_FORM_addr] = \"DW_FORM_addr\",\n\t[DW_FORM_block2] = \"DW_FORM_block2\",\n\t[DW_FORM_block4] = \"DW_FORM_block4\",\n\t[DW_FORM_data2] = \"DW_FORM_data2\",\n\t[DW_FORM_data4] = \"DW_FORM_data4\",\n\t[DW_FORM_data8] = \"DW_FORM_data8\",\n\t[DW_FORM_string] = \"DW_FORM_string\",\n\t[DW_FORM_block] = \"DW_FORM_block\",\n\t[DW_FORM_block1] = \"DW_FORM_block1\",\n\t[DW_FORM_data1] = \"DW_FORM_data1\",\n\t[DW_FORM_flag] = \"DW_FORM_flag\",\n\t[DW_FORM_sdata] = \"DW_FORM_sdata\",\n\t[DW_FORM_strp] = \"DW_FORM_strp\",\n\t[DW_FORM_udata] = \"DW_FORM_udata\",\n\t[DW_FORM_ref_addr] = \"DW_FORM_ref_addr\",\n\t[DW_FORM_ref1] = \"DW_FORM_ref1\",\n\t[DW_FORM_ref2] = \"DW_FORM_ref2\",\n\t[DW_FORM_ref4] = \"DW_FORM_ref4\",\n\t[DW_FORM_ref8] = \"DW_FORM_ref8\",\n\t[DW_FORM_ref_udata] = \"DW_FORM_ref_udata\",\n\t[DW_FORM_indirect] = \"DW_FORM_indirect\",\n\t[DW_FORM_sec_offset] = \"DW_FORM_sec_offset\",\n\t[DW_FORM_exprloc] = \"DW_FORM_exprloc\",\n\t[DW_FORM_flag_present] = \"DW_FORM_flag_present\",\n\t[DW_FORM_strx] = \"DW_FORM_strx\",\n\t[DW_FORM_addrx] = \"DW_FORM_addrx\",\n\t[DW_FORM_ref_sup4] = \"DW_FORM_ref_sup4\",\n\t[DW_FORM_strp_sup] = \"DW_FORM_strp_sup\",\n\t[DW_FORM_data16] = \"DW_FORM_data16\",\n\t[DW_FORM_line_ptr] = \"DW_FORM_line_ptr\",\n\t[DW_FORM_ref_sig8] = \"DW_FORM_ref_sig8\",\n\t[DW_FORM_implicit_const] = \"DW_FORM_implicit_const\",\n\t[DW_FORM_loclistx] = \"DW_FORM_loclistx\",\n\t[DW_FORM_rnglistx] = \"DW_FORM_rnglistx\",\n\t[DW_FORM_ref_sup8] = \"DW_FORM_ref_sup8\",\n\t[DW_FORM_strx1] = \"DW_FORM_strx1\",\n\t[DW_FORM_strx2] = \"DW_FORM_strx2\",\n\t[DW_FORM_strx3] = \"DW_FORM_strx3\",\n\t[DW_FORM_strx4] = \"DW_FORM_strx4\",\n\t[DW_FORM_addrx1] = \"DW_FORM_addrx1\",\n\t[DW_FORM_addrx2] = \"DW_FORM_addrx2\",\n\t[DW_FORM_addrx3] = \"DW_FORM_addrx3\",\n\t[DW_FORM_addrx4] = \"DW_FORM_addrx4\",\n};\n\nstatic const char *dwarf_langs[] = {\n\t[DW_LANG_C89] = \"C89\",\n\t[DW_LANG_C] = \"C\",\n\t[DW_LANG_Ada83] = \"Ada83\",\n\t[DW_LANG_C_plus_plus] = \"C++\",\n\t[DW_LANG_Cobol74] = \"Cobol74\",\n\t[DW_LANG_Cobol85] = \"Cobol85\",\n\t[DW_LANG_Fortran77] = \"Fortran77\",\n\t[DW_LANG_Fortran90] = \"Fortran90\",\n\t[DW_LANG_Pascal83] = \"Pascal83\",\n\t[DW_LANG_Modula2] = \"Modula2\",\n\t[DW_LANG_Java] = \"Java\",\n\t[DW_LANG_C99] = \"C99\",\n\t[DW_LANG_Ada95] = \"Ada95\",\n\t[DW_LANG_Fortran95] = \"Fortran95\",\n\t[DW_LANG_PLI] = \"PLI\",\n\t[DW_LANG_ObjC] = \"ObjC\",\n\t[DW_LANG_ObjC_plus_plus] = \"ObjC_plus_plus\",\n\t[DW_LANG_UPC] = \"UPC\",\n\t[DW_LANG_D] = \"D\",\n\t[DW_LANG_Python] = \"Python\",\n\t[DW_LANG_Rust] = \"Rust\",\n\t[DW_LANG_C11] = \"C11\",\n\t[DW_LANG_Swift] = \"Swift\",\n\t[DW_LANG_Julia] = \"Julia\",\n\t[DW_LANG_Dylan] = \"Dylan\",\n\t[DW_LANG_C_plus_plus_14] = \"C++14\",\n\t[DW_LANG_Fortran03] = \"Fortran03\",\n\t[DW_LANG_Fortran08] = \"Fortran08\"\n};\n\nstatic const char *dwarf_unit_types[] = {\n\t[DW_UT_compile] = \"DW_UT_compile\",\n\t[DW_UT_type] = \"DW_UT_type\",\n\t[DW_UT_partial] = \"DW_UT_partial\",\n\t[DW_UT_skeleton] = \"DW_UT_skeleton\",\n\t[DW_UT_split_compile] = \"DW_UT_split_compile\",\n\t[DW_UT_split_type] = \"DW_UT_split_type\",\n\t[DW_UT_lo_user] = \"DW_UT_lo_user\",\n\t[DW_UT_hi_user] = \"DW_UT_hi_user\",\n};\n\nRZ_API const char *rz_bin_dwarf_get_tag_name(ut64 tag) {\n\tif (tag >= DW_TAG_LAST) {\n\t\treturn NULL;\n\t}\n\treturn dwarf_tag_name_encodings[tag];\n}\n\nRZ_API const char *rz_bin_dwarf_get_attr_name(ut64 attr_code) {\n\tif (attr_code < RZ_ARRAY_SIZE(dwarf_attr_encodings)) {\n\t\treturn dwarf_attr_encodings[attr_code];\n\t}\n\t// the below codes are much sparser, so putting them in an array would require a lot of\n\t// unused memory\n\tswitch (attr_code) {\n\tcase DW_AT_lo_user:\n\t\treturn \"DW_AT_lo_user\";\n\tcase DW_AT_MIPS_linkage_name:\n\t\treturn \"DW_AT_MIPS_linkage_name\";\n\tcase DW_AT_GNU_call_site_value:\n\t\treturn \"DW_AT_GNU_call_site_value\";\n\tcase DW_AT_GNU_call_site_data_value:\n\t\treturn \"DW_AT_GNU_call_site_data_value\";\n\tcase DW_AT_GNU_call_site_target:\n\t\treturn \"DW_AT_GNU_call_site_target\";\n\tcase DW_AT_GNU_call_site_target_clobbered:\n\t\treturn \"DW_AT_GNU_call_site_target_clobbered\";\n\tcase DW_AT_GNU_tail_call:\n\t\treturn \"DW_AT_GNU_tail_call\";\n\tcase DW_AT_GNU_all_tail_call_sites:\n\t\treturn \"DW_AT_GNU_all_tail_call_sites\";\n\tcase DW_AT_GNU_all_call_sites:\n\t\treturn \"DW_AT_GNU_all_call_sites\";\n\tcase DW_AT_GNU_all_source_call_sites:\n\t\treturn \"DW_AT_GNU_all_source_call_sites\";\n\tcase DW_AT_GNU_macros:\n\t\treturn \"DW_AT_GNU_macros\";\n\tcase DW_AT_GNU_deleted:\n\t\treturn \"DW_AT_GNU_deleted\";\n\tcase DW_AT_GNU_dwo_name:\n\t\treturn \"DW_AT_GNU_dwo_name\";\n\tcase DW_AT_GNU_dwo_id:\n\t\treturn \"DW_AT_GNU_dwo_id\";\n\tcase DW_AT_GNU_ranges_base:\n\t\treturn \"DW_AT_GNU_ranges_base\";\n\tcase DW_AT_GNU_addr_base:\n\t\treturn \"DW_AT_GNU_addr_base\";\n\tcase DW_AT_GNU_pubnames:\n\t\treturn \"DW_AT_GNU_pubnames\";\n\tcase DW_AT_GNU_pubtypes:\n\t\treturn \"DW_AT_GNU_pubtypes\";\n\tcase DW_AT_hi_user:\n\t\treturn \"DW_AT_hi_user\";\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nRZ_API const char *rz_bin_dwarf_get_attr_form_name(ut64 form_code) {\n\tif (form_code < DW_FORM_addr || form_code > DW_FORM_addrx4) {\n\t\treturn NULL;\n\t}\n\treturn dwarf_attr_form_encodings[form_code];\n}\n\nRZ_API const char *rz_bin_dwarf_get_unit_type_name(ut64 unit_type) {\n\tif (!unit_type || unit_type > DW_UT_split_type) {\n\t\treturn NULL;\n\t}\n\treturn dwarf_unit_types[unit_type];\n}\n\nRZ_API const char *rz_bin_dwarf_get_lang_name(ut64 lang) {\n\tif (lang >= RZ_ARRAY_SIZE(dwarf_langs)) {\n\t\treturn NULL;\n\t}\n\treturn dwarf_langs[lang];\n}\n\nstatic int abbrev_cmp(const void *a, const void *b) {\n\tconst RzBinDwarfAbbrevDecl *first = a;\n\tconst RzBinDwarfAbbrevDecl *second = b;\n\n\tif (first->offset > second->offset) {\n\t\treturn 1;\n\t} else if (first->offset < second->offset) {\n\t\treturn -1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\n/**\n * \\brief Read an \"initial length\" value, as specified by dwarf.\n * This also determines whether it is 64bit or 32bit and reads 4 or 12 bytes respectively.\n */\nstatic inline ut64 dwarf_read_initial_length(RZ_OUT bool *is_64bit, bool big_endian, const ut8 **buf, const ut8 *buf_end) {\n\tut64 r = READ32(*buf);\n\tif (r == DWARF_INIT_LEN_64) {\n\t\tr = READ64(*buf);\n\t\t*is_64bit = true;\n\t} else {\n\t\t*is_64bit = false;\n\t}\n\treturn r;\n}\n\n/**\n * @brief Reads 64/32 bit unsigned based on format\n *\n * @param is_64bit Format of the comp unit\n * @param buf Pointer to the buffer to read from, to update after read\n * @param buf_end To check the boundary /for READ macro/\n * @return ut64 Read value\n */\nstatic inline ut64 dwarf_read_offset(bool is_64bit, bool big_endian, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tif (is_64bit) {\n\t\tresult = READ64(*buf);\n\t} else {\n\t\tresult = READ32(*buf);\n\t}\n\treturn result;\n}\n\nstatic inline ut64 dwarf_read_address(size_t size, bool big_endian, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tswitch (size) {\n\tcase 2:\n\t\tresult = READ16(*buf);\n\t\tbreak;\n\tcase 4:\n\t\tresult = READ32(*buf);\n\t\tbreak;\n\tcase 8:\n\t\tresult = READ64(*buf);\n\t\tbreak;\n\tdefault:\n\t\tresult = 0;\n\t\t*buf += size;\n\t\teprintf(\"Weird dwarf address size: %zu.\", size);\n\t}\n\treturn result;\n}\n\nstatic void line_header_fini(RzBinDwarfLineHeader *hdr) {\n\tif (hdr) {\n\t\tfor (size_t i = 0; i < hdr->file_names_count; i++) {\n\t\t\tfree(hdr->file_names[i].name);\n\t\t}\n\n\t\tfree(hdr->std_opcode_lengths);\n\t\tfree(hdr->file_names);\n\n\t\tif (hdr->include_dirs) {\n\t\t\tfor (size_t i = 0; i < hdr->include_dirs_count; i++) {\n\t\t\t\tfree(hdr->include_dirs[i]);\n\t\t\t}\n\t\t\tfree(hdr->include_dirs);\n\t\t}\n\t}\n}\n\n// Parses source file header of DWARF version <= 4\nstatic const ut8 *parse_line_header_source(RzBinFile *bf, const ut8 *buf, const ut8 *buf_end, RzBinDwarfLineHeader *hdr) {\n\tRzPVector incdirs;\n\trz_pvector_init(&incdirs, free);\n\twhile (buf + 1 < buf_end) {\n\t\tsize_t maxlen = RZ_MIN((size_t)(buf_end - buf) - 1, 0xfff);\n\t\tsize_t len = rz_str_nlen((const char *)buf, maxlen);\n\t\tchar *str = rz_str_ndup((const char *)buf, len);\n\t\tif (len < 1 || len >= 0xfff || !str) {\n\t\t\tbuf += 1;\n\t\t\tfree(str);\n\t\t\tbreak;\n\t\t}\n\t\trz_pvector_push(&incdirs, str);\n\t\tbuf += len + 1;\n\t}\n\thdr->include_dirs_count = rz_pvector_len(&incdirs);\n\thdr->include_dirs = (char **)rz_pvector_flush(&incdirs);\n\trz_pvector_fini(&incdirs);\n\n\tRzVector file_names;\n\trz_vector_init(&file_names, sizeof(RzBinDwarfLineFileEntry), NULL, NULL);\n\twhile (buf + 1 < buf_end) {\n\t\tconst char *filename = (const char *)buf;\n\t\tsize_t maxlen = RZ_MIN((size_t)(buf_end - buf - 1), 0xfff);\n\t\tut64 id_idx, mod_time, file_len;\n\t\tsize_t len = rz_str_nlen(filename, maxlen);\n\n\t\tif (!len) {\n\t\t\tbuf++;\n\t\t\tbreak;\n\t\t}\n\t\tbuf += len + 1;\n\t\tif (buf >= buf_end) {\n\t\t\tbuf = NULL;\n\t\t\tgoto beach;\n\t\t}\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &id_idx, NULL);\n\t\tif (buf >= buf_end) {\n\t\t\tbuf = NULL;\n\t\t\tgoto beach;\n\t\t}\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &mod_time, NULL);\n\t\tif (buf >= buf_end) {\n\t\t\tbuf = NULL;\n\t\t\tgoto beach;\n\t\t}\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &file_len, NULL);\n\t\tif (buf >= buf_end) {\n\t\t\tbuf = NULL;\n\t\t\tgoto beach;\n\t\t}\n\t\tRzBinDwarfLineFileEntry *entry = rz_vector_push(&file_names, NULL);\n\t\tentry->name = strdup(filename);\n\t\tentry->id_idx = id_idx;\n\t\tentry->mod_time = mod_time;\n\t\tentry->file_len = file_len;\n\t}\n\thdr->file_names_count = rz_vector_len(&file_names);\n\thdr->file_names = rz_vector_flush(&file_names);\n\trz_vector_fini(&file_names);\n\nbeach:\n\treturn buf;\n}\n\n/**\n * \\param info if not NULL, filenames can get resolved to absolute paths using the compilation unit dirs from it\n */\nRZ_API char *rz_bin_dwarf_line_header_get_full_file_path(RZ_NULLABLE const RzBinDwarfDebugInfo *info, const RzBinDwarfLineHeader *header, ut64 file_index) {\n\trz_return_val_if_fail(header, NULL);\n\tif (file_index >= header->file_names_count) {\n\t\treturn NULL;\n\t}\n\tRzBinDwarfLineFileEntry *file = &header->file_names[file_index];\n\tif (!file->name) {\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Dwarf standard does not seem to specify the exact separator (slash/backslash) of paths\n\t * so apparently it is target-dependent. However we have yet to see a Windows binary that\n\t * also contains dwarf and contains backslashes. The ones we have seen from MinGW have regular\n\t * slashes.\n\t * And since there seems to be no way to reliable check whether the target uses slashes\n\t * or backslashes anyway, we will simply use slashes always here.\n\t */\n\n\tconst char *comp_dir = info ? ht_up_find(info->line_info_offset_comp_dir, header->offset, NULL) : NULL;\n\tconst char *include_dir = NULL;\n\tchar *own_str = NULL;\n\tif (file->id_idx > 0 && file->id_idx - 1 < header->include_dirs_count) {\n\t\tinclude_dir = header->include_dirs[file->id_idx - 1];\n\t\tif (include_dir && include_dir[0] != '/' && comp_dir) {\n\t\t\tinclude_dir = own_str = rz_str_newf(\"%s/%s/\", comp_dir, include_dir);\n\t\t}\n\t} else {\n\t\tinclude_dir = comp_dir;\n\t}\n\tif (!include_dir) {\n\t\tinclude_dir = \"./\";\n\t}\n\tchar *r = rz_str_newf(\"%s/%s\", include_dir, file->name);\n\tfree(own_str);\n\treturn r;\n}\n\nRZ_API RzBinDwarfLineFileCache rz_bin_dwarf_line_header_new_file_cache(const RzBinDwarfLineHeader *hdr) {\n\treturn RZ_NEWS0(char *, hdr->file_names_count);\n}\n\nRZ_API void rz_bin_dwarf_line_header_free_file_cache(const RzBinDwarfLineHeader *hdr, RzBinDwarfLineFileCache fnc) {\n\tif (!fnc) {\n\t\treturn;\n\t}\n\tfor (size_t i = 0; i < hdr->file_names_count; i++) {\n\t\tfree(fnc[i]);\n\t}\n\tfree(fnc);\n}\n\nstatic const char *get_full_file_path(const RzBinDwarfDebugInfo *info, const RzBinDwarfLineHeader *header,\n\tRZ_NULLABLE RzBinDwarfLineFileCache cache, ut64 file_index) {\n\tif (file_index >= header->file_names_count) {\n\t\treturn NULL;\n\t}\n\tif (!cache) {\n\t\treturn header->file_names[file_index].name;\n\t}\n\tif (!cache[file_index]) {\n\t\tcache[file_index] = rz_bin_dwarf_line_header_get_full_file_path(info, header, file_index);\n\t}\n\treturn cache[file_index];\n}\n\nRZ_API ut64 rz_bin_dwarf_line_header_get_adj_opcode(const RzBinDwarfLineHeader *header, ut8 opcode) {\n\trz_return_val_if_fail(header, 0);\n\treturn opcode - header->opcode_base;\n}\n\nRZ_API ut64 rz_bin_dwarf_line_header_get_spec_op_advance_pc(const RzBinDwarfLineHeader *header, ut8 opcode) {\n\trz_return_val_if_fail(header, 0);\n\tif (!header->line_range) {\n\t\t// to dodge division by zero\n\t\treturn 0;\n\t}\n\tut8 adj_opcode = rz_bin_dwarf_line_header_get_adj_opcode(header, opcode);\n\treturn (adj_opcode / header->line_range) * header->min_inst_len;\n}\n\nRZ_API st64 rz_bin_dwarf_line_header_get_spec_op_advance_line(const RzBinDwarfLineHeader *header, ut8 opcode) {\n\trz_return_val_if_fail(header, 0);\n\tif (!header->line_range) {\n\t\t// to dodge division by zero\n\t\treturn 0;\n\t}\n\tut8 adj_opcode = rz_bin_dwarf_line_header_get_adj_opcode(header, opcode);\n\treturn header->line_base + (adj_opcode % header->line_range);\n}\n\nstatic const ut8 *parse_line_header(\n\tRzBinFile *bf, const ut8 *buf, const ut8 *buf_end,\n\tRzBinDwarfLineHeader *hdr, ut64 offset_cur, bool big_endian) {\n\trz_return_val_if_fail(hdr && bf && buf && buf_end, NULL);\n\n\thdr->offset = offset_cur;\n\thdr->is_64bit = false;\n\thdr->unit_length = dwarf_read_initial_length(&hdr->is_64bit, big_endian, &buf, buf_end);\n\thdr->version = READ16(buf);\n\n\tif (hdr->version == 5) {\n\t\thdr->address_size = READ8(buf);\n\t\thdr->segment_selector_size = READ8(buf);\n\t}\n\n\thdr->header_length = dwarf_read_offset(hdr->is_64bit, big_endian, &buf, buf_end);\n\n\tconst ut8 *tmp_buf = buf; // So I can skip parsing DWARF 5 headers for now\n\n\tif (buf_end - buf < 8) {\n\t\treturn NULL;\n\t}\n\thdr->min_inst_len = READ8(buf);\n\tif (hdr->version >= 4) {\n\t\thdr->max_ops_per_inst = READ8(buf);\n\t}\n\thdr->default_is_stmt = READ8(buf);\n\thdr->line_base = (st8)READ8(buf);\n\thdr->line_range = READ8(buf);\n\thdr->opcode_base = READ8(buf);\n\n\thdr->file_names = NULL;\n\n\tif (hdr->opcode_base > 1) {\n\t\thdr->std_opcode_lengths = calloc(sizeof(ut8), hdr->opcode_base - 1);\n\t\tfor (size_t i = 1; i < hdr->opcode_base; i++) {\n\t\t\tif (buf + 2 > buf_end) {\n\t\t\t\thdr->opcode_base = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thdr->std_opcode_lengths[i - 1] = READ8(buf);\n\t\t}\n\t} else {\n\t\thdr->std_opcode_lengths = NULL;\n\t}\n\t// TODO finish parsing of source files out of DWARF 5 header\n\t// for now we skip\n\tif (hdr->version == 5) {\n\t\ttmp_buf += hdr->header_length;\n\t\treturn tmp_buf;\n\t}\n\n\tif (hdr->version <= 4) {\n\t\tbuf = parse_line_header_source(bf, buf, buf_end, hdr);\n\t} else {\n\t\tbuf = NULL;\n\t}\n\n\treturn buf;\n}\n\nRZ_API void rz_bin_dwarf_line_op_fini(RzBinDwarfLineOp *op) {\n\trz_return_if_fail(op);\n\tif (op->type == RZ_BIN_DWARF_LINE_OP_TYPE_EXT && op->opcode == DW_LNE_define_file) {\n\t\tfree(op->args.define_file.filename);\n\t}\n}\n\nstatic const ut8 *parse_ext_opcode(RzBinDwarfLineOp *op, const RzBinDwarfLineHeader *hdr, const ut8 *obuf, size_t len,\n\tbool big_endian, ut8 target_addr_size) {\n\trz_return_val_if_fail(op && hdr && obuf, NULL);\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + len;\n\n\tut64 op_len;\n\tbuf = rz_uleb128(buf, len, &op_len, NULL);\n\t// op_len must fit and be at least 1 (for the opcode byte)\n\tif (!buf || buf >= buf_end || !op_len || buf_end - buf < op_len) {\n\t\treturn NULL;\n\t}\n\n\tut8 opcode = *buf++;\n\top->type = RZ_BIN_DWARF_LINE_OP_TYPE_EXT;\n\top->opcode = opcode;\n\n\tswitch (opcode) {\n\tcase DW_LNE_set_address: {\n\t\tut8 addr_size = hdr->address_size;\n\t\tif (hdr->version < 5) { // address_size in header only starting with Dwarf 5\n\t\t\taddr_size = target_addr_size;\n\t\t}\n\t\top->args.set_address = dwarf_read_address(addr_size, big_endian, &buf, buf_end);\n\t\tbreak;\n\t}\n\tcase DW_LNE_define_file: {\n\t\tsize_t fn_len = rz_str_nlen((const char *)buf, buf_end - buf);\n\t\tchar *fn = malloc(fn_len + 1);\n\t\tif (!fn) {\n\t\t\treturn NULL;\n\t\t}\n\t\tmemcpy(fn, buf, fn_len);\n\t\tfn[fn_len] = 0;\n\t\top->args.define_file.filename = fn;\n\t\tbuf += fn_len + 1;\n\t\tif (buf + 1 < buf_end) {\n\t\t\tbuf = rz_uleb128(buf, buf_end - buf, &op->args.define_file.dir_index, NULL);\n\t\t}\n\t\tif (buf && buf + 1 < buf_end) {\n\t\t\tbuf = rz_uleb128(buf, buf_end - buf, NULL, NULL);\n\t\t}\n\t\tif (buf && buf + 1 < buf_end) {\n\t\t\tbuf = rz_uleb128(buf, buf_end - buf, NULL, NULL);\n\t\t}\n\t\tbreak;\n\t}\n\tcase DW_LNE_set_discriminator:\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &op->args.set_discriminator, NULL);\n\t\tbreak;\n\tcase DW_LNE_end_sequence:\n\tdefault:\n\t\tbuf += op_len - 1;\n\t\tbreak;\n\t}\n\treturn buf;\n}\n\n/**\n * \\return the number of leb128 args the std opcode takes, EXCEPT for DW_LNS_fixed_advance_pc! (see Dwarf spec)\n */\nstatic size_t std_opcode_args_count(const RzBinDwarfLineHeader *hdr, ut8 opcode) {\n\tif (!opcode || opcode > hdr->opcode_base - 1 || !hdr->std_opcode_lengths) {\n\t\treturn 0;\n\t}\n\treturn hdr->std_opcode_lengths[opcode - 1];\n}\n\nstatic const ut8 *parse_std_opcode(RzBinDwarfLineOp *op, const RzBinDwarfLineHeader *hdr, const ut8 *obuf, size_t len, ut8 opcode, bool big_endian) {\n\trz_return_val_if_fail(op && hdr && obuf, NULL);\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + len;\n\n\top->type = RZ_BIN_DWARF_LINE_OP_TYPE_STD;\n\top->opcode = opcode;\n\tswitch (opcode) {\n\tcase DW_LNS_advance_pc:\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &op->args.advance_pc, NULL);\n\t\tbreak;\n\tcase DW_LNS_advance_line:\n\t\tbuf = rz_leb128(buf, buf_end - buf, &op->args.advance_line);\n\t\tbreak;\n\tcase DW_LNS_set_file:\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &op->args.set_file, NULL);\n\t\tbreak;\n\tcase DW_LNS_set_column:\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &op->args.set_column, NULL);\n\t\tbreak;\n\tcase DW_LNS_fixed_advance_pc:\n\t\top->args.fixed_advance_pc = READ16(buf);\n\t\tbreak;\n\tcase DW_LNS_set_isa:\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &op->args.set_isa, NULL);\n\t\tbreak;\n\n\t// known opcodes that take no args\n\tcase DW_LNS_copy:\n\tcase DW_LNS_negate_stmt:\n\tcase DW_LNS_set_basic_block:\n\tcase DW_LNS_const_add_pc:\n\tcase DW_LNS_set_prologue_end:\n\tcase DW_LNS_set_epilogue_begin:\n\t\tbreak;\n\n\t// unknown operands, skip the number of args given in the header.\n\tdefault: {\n\t\tsize_t args_count = std_opcode_args_count(hdr, opcode);\n\t\tfor (size_t i = 0; i < args_count; i++) {\n\t\t\tbuf = rz_uleb128(buf, buf_end - buf, &op->args.advance_pc, NULL);\n\t\t\tif (!buf) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t}\n\treturn buf;\n}\n\nRZ_API void rz_bin_dwarf_line_header_reset_regs(const RzBinDwarfLineHeader *hdr, RzBinDwarfSMRegisters *regs) {\n\trz_return_if_fail(hdr && regs);\n\tregs->address = 0;\n\tregs->file = 1;\n\tregs->line = 1;\n\tregs->column = 0;\n\tregs->is_stmt = hdr->default_is_stmt;\n\tregs->basic_block = DWARF_FALSE;\n\tregs->end_sequence = DWARF_FALSE;\n\tregs->prologue_end = DWARF_FALSE;\n\tregs->epilogue_begin = DWARF_FALSE;\n\tregs->isa = 0;\n}\n\nstatic void store_line_sample(RzBinSourceLineInfoBuilder *bob, const RzBinDwarfLineHeader *hdr, RzBinDwarfSMRegisters *regs,\n\tRZ_NULLABLE RzBinDwarfDebugInfo *info, RZ_NULLABLE RzBinDwarfLineFileCache fnc) {\n\tconst char *file = NULL;\n\tif (regs->file) {\n\t\tfile = get_full_file_path(info, hdr, fnc, regs->file - 1);\n\t}\n\trz_bin_source_line_info_builder_push_sample(bob, regs->address, (ut32)regs->line, (ut32)regs->column, file);\n}\n\n/**\n * \\brief Execute a single line op on regs and optionally store the resulting line info in bob\n * \\param fnc if not null, filenames will be resolved to their full paths using this cache.\n */\nRZ_API bool rz_bin_dwarf_line_op_run(const RzBinDwarfLineHeader *hdr, RzBinDwarfSMRegisters *regs, RzBinDwarfLineOp *op,\n\tRZ_NULLABLE RzBinSourceLineInfoBuilder *bob, RZ_NULLABLE RzBinDwarfDebugInfo *info, RZ_NULLABLE RzBinDwarfLineFileCache fnc) {\n\trz_return_val_if_fail(hdr && regs && op, false);\n\tswitch (op->type) {\n\tcase RZ_BIN_DWARF_LINE_OP_TYPE_STD:\n\t\tswitch (op->opcode) {\n\t\tcase DW_LNS_copy:\n\t\t\tif (bob) {\n\t\t\t\tstore_line_sample(bob, hdr, regs, info, fnc);\n\t\t\t}\n\t\t\tregs->basic_block = DWARF_FALSE;\n\t\t\tbreak;\n\t\tcase DW_LNS_advance_pc:\n\t\t\tregs->address += op->args.advance_pc * hdr->min_inst_len;\n\t\t\tbreak;\n\t\tcase DW_LNS_advance_line:\n\t\t\tregs->line += op->args.advance_line;\n\t\t\tbreak;\n\t\tcase DW_LNS_set_file:\n\t\t\tregs->file = op->args.set_file;\n\t\t\tbreak;\n\t\tcase DW_LNS_set_column:\n\t\t\tregs->column = op->args.set_column;\n\t\t\tbreak;\n\t\tcase DW_LNS_negate_stmt:\n\t\t\tregs->is_stmt = regs->is_stmt ? DWARF_FALSE : DWARF_TRUE;\n\t\t\tbreak;\n\t\tcase DW_LNS_set_basic_block:\n\t\t\tregs->basic_block = DWARF_TRUE;\n\t\t\tbreak;\n\t\tcase DW_LNS_const_add_pc:\n\t\t\tregs->address += rz_bin_dwarf_line_header_get_spec_op_advance_pc(hdr, 255);\n\t\t\tbreak;\n\t\tcase DW_LNS_fixed_advance_pc:\n\t\t\tregs->address += op->args.fixed_advance_pc;\n\t\t\tbreak;\n\t\tcase DW_LNS_set_prologue_end:\n\t\t\tregs->prologue_end = ~0;\n\t\t\tbreak;\n\t\tcase DW_LNS_set_epilogue_begin:\n\t\t\tregs->epilogue_begin = ~0;\n\t\t\tbreak;\n\t\tcase DW_LNS_set_isa:\n\t\t\tregs->isa = op->args.set_isa;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase RZ_BIN_DWARF_LINE_OP_TYPE_EXT:\n\t\tswitch (op->opcode) {\n\t\tcase DW_LNE_end_sequence:\n\t\t\tregs->end_sequence = DWARF_TRUE;\n\t\t\tif (bob) {\n\t\t\t\t// closing entry\n\t\t\t\trz_bin_source_line_info_builder_push_sample(bob, regs->address, 0, 0, NULL);\n\t\t\t}\n\t\t\trz_bin_dwarf_line_header_reset_regs(hdr, regs);\n\t\t\tbreak;\n\t\tcase DW_LNE_set_address:\n\t\t\tregs->address = op->args.set_address;\n\t\t\tbreak;\n\t\tcase DW_LNE_define_file:\n\t\t\tbreak;\n\t\tcase DW_LNE_set_discriminator:\n\t\t\tregs->discriminator = op->args.set_discriminator;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase RZ_BIN_DWARF_LINE_OP_TYPE_SPEC:\n\t\tregs->address += rz_bin_dwarf_line_header_get_spec_op_advance_pc(hdr, op->opcode);\n\t\tregs->line += rz_bin_dwarf_line_header_get_spec_op_advance_line(hdr, op->opcode);\n\t\tif (bob) {\n\t\t\tstore_line_sample(bob, hdr, regs, info, fnc);\n\t\t}\n\t\tregs->basic_block = DWARF_FALSE;\n\t\tregs->prologue_end = DWARF_FALSE;\n\t\tregs->epilogue_begin = DWARF_FALSE;\n\t\tregs->discriminator = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic size_t parse_opcodes(const ut8 *obuf,\n\tsize_t len, const RzBinDwarfLineHeader *hdr, RzVector *ops_out,\n\tRzBinDwarfSMRegisters *regs, RZ_NULLABLE RzBinSourceLineInfoBuilder *bob, RZ_NULLABLE RzBinDwarfDebugInfo *info,\n\tRZ_NULLABLE RzBinDwarfLineFileCache fnc, bool big_endian, ut8 target_addr_size) {\n\tconst ut8 *buf, *buf_end;\n\tut8 opcode;\n\n\tif (!obuf || !len) {\n\t\treturn 0;\n\t}\n\tbuf = obuf;\n\tbuf_end = obuf + len;\n\n\twhile (buf < buf_end) {\n\t\topcode = *buf++;\n\t\tRzBinDwarfLineOp op = { 0 };\n\t\tif (!opcode) {\n\t\t\tbuf = parse_ext_opcode(&op, hdr, buf, (buf_end - buf), big_endian, target_addr_size);\n\t\t} else if (opcode >= hdr->opcode_base) {\n\t\t\t// special opcode without args, no further parsing needed\n\t\t\top.type = RZ_BIN_DWARF_LINE_OP_TYPE_SPEC;\n\t\t\top.opcode = opcode;\n\t\t} else {\n\t\t\tbuf = parse_std_opcode(&op, hdr, buf, (buf_end - buf), opcode, big_endian);\n\t\t}\n\t\tif (!buf) {\n\t\t\tbreak;\n\t\t}\n\t\tif (bob) {\n\t\t\trz_bin_dwarf_line_op_run(hdr, regs, &op, bob, info, fnc);\n\t\t}\n\t\tif (ops_out) {\n\t\t\trz_vector_push(ops_out, &op);\n\t\t} else {\n\t\t\trz_bin_dwarf_line_op_fini(&op);\n\t\t}\n\t}\n\tif (!buf) {\n\t\treturn 0;\n\t}\n\treturn (size_t)(buf - obuf); // number of bytes we've moved by\n}\n\nstatic void line_unit_free(RzBinDwarfLineUnit *unit) {\n\tif (!unit) {\n\t\treturn;\n\t}\n\tline_header_fini(&unit->header);\n\tif (unit->ops) {\n\t\tfor (size_t i = 0; i < unit->ops_count; i++) {\n\t\t\trz_bin_dwarf_line_op_fini(&unit->ops[i]);\n\t\t}\n\t\tfree(unit->ops);\n\t}\n\tfree(unit);\n}\n\nstatic RzBinDwarfLineInfo *parse_line_raw(RzBinFile *binfile, const ut8 *obuf,\n\tut64 len, RzBinDwarfLineInfoMask mask, bool big_endian, RZ_NULLABLE RzBinDwarfDebugInfo *info) {\n\t// Dwarf 3 Standard 6.2 Line Number Information\n\trz_return_val_if_fail(binfile && obuf, NULL);\n\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_start = buf;\n\tconst ut8 *buf_end = obuf + len;\n\tconst ut8 *tmpbuf = NULL;\n\tut64 buf_size;\n\n\t// Dwarf < 5 needs this size to be supplied from outside\n\tRzBinObject *o = binfile->o;\n\tut8 target_addr_size = o && o->info && o->info->bits ? o->info->bits / 8 : 4;\n\n\tRzBinDwarfLineInfo *li = RZ_NEW0(RzBinDwarfLineInfo);\n\tif (!li) {\n\t\treturn NULL;\n\t}\n\tli->units = rz_list_newf((RzListFree)line_unit_free);\n\tif (!li->units) {\n\t\tfree(li);\n\t\treturn NULL;\n\t}\n\n\tRzBinSourceLineInfoBuilder bob;\n\tif (mask & RZ_BIN_DWARF_LINE_INFO_MASK_LINES) {\n\t\trz_bin_source_line_info_builder_init(&bob);\n\t}\n\n\t// each iteration we read one header AKA comp. unit\n\twhile (buf <= buf_end) {\n\t\tRzBinDwarfLineUnit *unit = RZ_NEW0(RzBinDwarfLineUnit);\n\t\tif (!unit) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// How much did we read from the compilation unit\n\t\tsize_t bytes_read = 0;\n\t\t// calculate how much we've read by parsing header\n\t\t// because header unit_length includes itself\n\t\tbuf_size = buf_end - buf;\n\n\t\ttmpbuf = buf;\n\t\tbuf = parse_line_header(binfile, buf, buf_end, &unit->header, buf - buf_start, big_endian);\n\t\tif (!buf) {\n\t\t\tline_unit_free(unit);\n\t\t\tbreak;\n\t\t}\n\n\t\tbytes_read = buf - tmpbuf;\n\n\t\tRzBinDwarfSMRegisters regs;\n\t\trz_bin_dwarf_line_header_reset_regs(&unit->header, &regs);\n\n\t\t// If there is more bytes in the buffer than size of the header\n\t\t// It means that there has to be another header/comp.unit\n\t\tbuf_size = RZ_MIN(buf_size, unit->header.unit_length + (unit->header.is_64bit * 8 + 4)); // length field + rest of the unit\n\t\tif (buf_size <= bytes_read) {\n\t\t\t// no info or truncated\n\t\t\tline_unit_free(unit);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf_size > (buf_end - buf) + bytes_read || buf > buf_end) {\n\t\t\tline_unit_free(unit);\n\t\t\tbreak;\n\t\t}\n\t\tsize_t tmp_read = 0;\n\n\t\tRzVector ops;\n\t\tif (mask & RZ_BIN_DWARF_LINE_INFO_MASK_OPS) {\n\t\t\trz_vector_init(&ops, sizeof(RzBinDwarfLineOp), NULL, NULL);\n\t\t}\n\n\t\tRzBinDwarfLineFileCache fnc = NULL;\n\t\tif (mask & RZ_BIN_DWARF_LINE_INFO_MASK_LINES) {\n\t\t\tfnc = rz_bin_dwarf_line_header_new_file_cache(&unit->header);\n\t\t}\n\n\t\t// we read the whole compilation unit (that might be composed of more sequences)\n\t\tdo {\n\t\t\t// reads one whole sequence\n\t\t\ttmp_read = parse_opcodes(buf, buf_size - bytes_read, &unit->header,\n\t\t\t\t(mask & RZ_BIN_DWARF_LINE_INFO_MASK_OPS) ? &ops : NULL, &regs,\n\t\t\t\t(mask & RZ_BIN_DWARF_LINE_INFO_MASK_LINES) ? &bob : NULL,\n\t\t\t\tinfo, fnc, big_endian, target_addr_size);\n\t\t\tbytes_read += tmp_read;\n\t\t\tbuf += tmp_read; // Move in the buffer forward\n\t\t} while (bytes_read < buf_size && tmp_read != 0); // if nothing is read -> error, exit\n\n\t\trz_bin_dwarf_line_header_free_file_cache(&unit->header, fnc);\n\n\t\tif (mask & RZ_BIN_DWARF_LINE_INFO_MASK_OPS) {\n\t\t\tunit->ops_count = rz_vector_len(&ops);\n\t\t\tunit->ops = rz_vector_flush(&ops);\n\t\t\trz_vector_fini(&ops);\n\t\t}\n\n\t\tif (!tmp_read) {\n\t\t\tline_unit_free(unit);\n\t\t\tbreak;\n\t\t}\n\t\trz_list_push(li->units, unit);\n\t}\n\tif (mask & RZ_BIN_DWARF_LINE_INFO_MASK_LINES) {\n\t\tli->lines = rz_bin_source_line_info_builder_build_and_fini(&bob);\n\t}\n\treturn li;\n}\n\nRZ_API void rz_bin_dwarf_arange_set_free(RzBinDwarfARangeSet *set) {\n\tif (!set) {\n\t\treturn;\n\t}\n\tfree(set->aranges);\n\tfree(set);\n}\n\nstatic RzList /*<RzBinDwarfARangeSet>*/ *parse_aranges_raw(const ut8 *obuf, size_t obuf_sz, bool big_endian) {\n\trz_return_val_if_fail(obuf, NULL);\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = buf + obuf_sz;\n\n\tRzList *r = rz_list_newf((RzListFree)rz_bin_dwarf_arange_set_free);\n\tif (!r) {\n\t\treturn NULL;\n\t}\n\n\t// DWARF 3 Standard Section 6.1.2 Lookup by Address\n\t// also useful to grep for display_debug_aranges in binutils\n\twhile (buf < buf_end) {\n\t\tconst ut8 *start = buf;\n\t\tbool is_64bit;\n\t\tut64 unit_length = dwarf_read_initial_length(&is_64bit, big_endian, &buf, buf_end);\n\t\t// Sanity check: length must be at least the minimal size of the remaining header fields\n\t\t// and at maximum the remaining buffer size.\n\t\tsize_t header_rest_size = 2 + (is_64bit ? 8 : 4) + 1 + 1;\n\t\tif (unit_length < header_rest_size || unit_length > buf_end - buf) {\n\t\t\tbreak;\n\t\t}\n\t\tconst ut8 *next_set_buf = buf + unit_length;\n\t\tRzBinDwarfARangeSet *set = RZ_NEW(RzBinDwarfARangeSet);\n\t\tif (!set) {\n\t\t\tbreak;\n\t\t}\n\t\tset->unit_length = unit_length;\n\t\tset->is_64bit = is_64bit;\n\t\tset->version = READ16(buf);\n\t\tset->debug_info_offset = dwarf_read_offset(set->is_64bit, big_endian, &buf, buf_end);\n\t\tset->address_size = READ8(buf);\n\t\tset->segment_size = READ8(buf);\n\t\tunit_length -= header_rest_size;\n\t\tif (!set->address_size) {\n\t\t\tfree(set);\n\t\t\tbreak;\n\t\t}\n\n\t\t// align to 2*addr_size\n\t\tsize_t off = buf - start;\n\t\tsize_t pad = rz_num_align_delta(off, 2 * set->address_size);\n\t\tif (pad > unit_length || pad > buf_end - buf) {\n\t\t\tfree(set);\n\t\t\tbreak;\n\t\t}\n\t\tbuf += pad;\n\t\tunit_length -= pad;\n\n\t\tsize_t arange_size = 2 * set->address_size;\n\t\tset->aranges_count = unit_length / arange_size;\n\t\tif (!set->aranges_count) {\n\t\t\tfree(set);\n\t\t\tbreak;\n\t\t}\n\t\tset->aranges = RZ_NEWS0(RzBinDwarfARange, set->aranges_count);\n\t\tif (!set->aranges) {\n\t\t\tfree(set);\n\t\t\tbreak;\n\t\t}\n\t\tsize_t i;\n\t\tfor (i = 0; i < set->aranges_count; i++) {\n\t\t\tset->aranges[i].addr = dwarf_read_address(set->address_size, big_endian, &buf, buf_end);\n\t\t\tset->aranges[i].length = dwarf_read_address(set->address_size, big_endian, &buf, buf_end);\n\t\t\tif (!set->aranges[i].addr && !set->aranges[i].length) {\n\t\t\t\t// last entry has two 0s\n\t\t\t\ti++; // so i will be the total count of read entries\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tset->aranges_count = i;\n\t\tbuf = next_set_buf;\n\t\trz_list_push(r, set);\n\t}\n\n\treturn r;\n}\n\nstatic void free_ht_comp_dir(HtUPKv *kv) {\n\tfree(kv->value);\n}\n\nstatic bool init_debug_info(RzBinDwarfDebugInfo *inf) {\n\tinf->comp_units = RZ_NEWS0(RzBinDwarfCompUnit, DEBUG_INFO_CAPACITY);\n\tif (!inf->comp_units) {\n\t\treturn false;\n\t}\n\tinf->lookup_table = ht_up_new0();\n\tif (!inf->lookup_table) {\n\t\tgoto wurzelbert_comp_units;\n\t}\n\tinf->line_info_offset_comp_dir = ht_up_new(NULL, free_ht_comp_dir, NULL);\n\tif (!inf->line_info_offset_comp_dir) {\n\t\tgoto wurzelbert_lookup_table;\n\t}\n\tinf->capacity = DEBUG_INFO_CAPACITY;\n\tinf->count = 0;\n\treturn true;\nwurzelbert_lookup_table:\n\tht_up_free(inf->lookup_table);\nwurzelbert_comp_units:\n\tfree(inf->comp_units);\n\treturn false;\n}\n\nstatic int init_die(RzBinDwarfDie *die, ut64 abbr_code, ut64 attr_count) {\n\tif (!die) {\n\t\treturn -1;\n\t}\n\tif (attr_count) {\n\t\tdie->attr_values = calloc(sizeof(RzBinDwarfAttrValue), attr_count);\n\t\tif (!die->attr_values) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tdie->attr_values = NULL;\n\t}\n\tdie->abbrev_code = abbr_code;\n\tdie->capacity = attr_count;\n\tdie->count = 0;\n\treturn 0;\n}\n\nstatic int init_comp_unit(RzBinDwarfCompUnit *cu) {\n\tif (!cu) {\n\t\treturn -EINVAL;\n\t}\n\tcu->dies = calloc(sizeof(RzBinDwarfDie), COMP_UNIT_CAPACITY);\n\tif (!cu->dies) {\n\t\treturn -ENOMEM;\n\t}\n\tcu->capacity = COMP_UNIT_CAPACITY;\n\tcu->count = 0;\n\treturn 0;\n}\n\nstatic int expand_cu(RzBinDwarfCompUnit *cu) {\n\tRzBinDwarfDie *tmp;\n\n\tif (!cu || cu->capacity == 0 || cu->capacity != cu->count) {\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = (RzBinDwarfDie *)realloc(cu->dies,\n\t\tcu->capacity * 2 * sizeof(RzBinDwarfDie));\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset((ut8 *)tmp + cu->capacity * sizeof(RzBinDwarfDie),\n\t\t0, cu->capacity * sizeof(RzBinDwarfDie));\n\tcu->dies = tmp;\n\tcu->capacity *= 2;\n\n\treturn 0;\n}\n\nstatic int init_abbrev_decl(RzBinDwarfAbbrevDecl *ad) {\n\tif (!ad) {\n\t\treturn -EINVAL;\n\t}\n\tad->defs = calloc(sizeof(RzBinDwarfAttrDef), ABBREV_DECL_CAP);\n\n\tif (!ad->defs) {\n\t\treturn -ENOMEM;\n\t}\n\n\tad->capacity = ABBREV_DECL_CAP;\n\tad->count = 0;\n\n\treturn 0;\n}\n\nstatic int expand_abbrev_decl(RzBinDwarfAbbrevDecl *ad) {\n\tRzBinDwarfAttrDef *tmp;\n\n\tif (!ad || !ad->capacity || ad->capacity != ad->count) {\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = (RzBinDwarfAttrDef *)realloc(ad->defs,\n\t\tad->capacity * 2 * sizeof(RzBinDwarfAttrDef));\n\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\n\t// Set the area in the buffer past the length to 0\n\tmemset((ut8 *)tmp + ad->capacity * sizeof(RzBinDwarfAttrDef),\n\t\t0, ad->capacity * sizeof(RzBinDwarfAttrDef));\n\tad->defs = tmp;\n\tad->capacity *= 2;\n\n\treturn 0;\n}\n\nstatic int init_debug_abbrev(RzBinDwarfDebugAbbrev *da) {\n\tif (!da) {\n\t\treturn -EINVAL;\n\t}\n\tda->decls = calloc(sizeof(RzBinDwarfAbbrevDecl), DEBUG_ABBREV_CAP);\n\tif (!da->decls) {\n\t\treturn -ENOMEM;\n\t}\n\tda->capacity = DEBUG_ABBREV_CAP;\n\tda->count = 0;\n\n\treturn 0;\n}\n\nstatic int expand_debug_abbrev(RzBinDwarfDebugAbbrev *da) {\n\tRzBinDwarfAbbrevDecl *tmp;\n\n\tif (!da || da->capacity == 0 || da->capacity != da->count) {\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = (RzBinDwarfAbbrevDecl *)realloc(da->decls,\n\t\tda->capacity * 2 * sizeof(RzBinDwarfAbbrevDecl));\n\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\tmemset((ut8 *)tmp + da->capacity * sizeof(RzBinDwarfAbbrevDecl),\n\t\t0, da->capacity * sizeof(RzBinDwarfAbbrevDecl));\n\n\tda->decls = tmp;\n\tda->capacity *= 2;\n\n\treturn 0;\n}\n\nRZ_API void rz_bin_dwarf_debug_abbrev_free(RzBinDwarfDebugAbbrev *da) {\n\tsize_t i;\n\tif (!da) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < da->count; i++) {\n\t\tRZ_FREE(da->decls[i].defs);\n\t}\n\tRZ_FREE(da->decls);\n\tfree(da);\n}\n\nRZ_API void rz_bin_dwarf_line_info_free(RzBinDwarfLineInfo *li) {\n\tif (!li) {\n\t\treturn;\n\t}\n\trz_list_free(li->units);\n\trz_bin_source_line_info_free(li->lines);\n\tfree(li);\n}\n\nstatic void free_attr_value(RzBinDwarfAttrValue *val) {\n\t// TODO adjust to new forms, now we're leaking\n\tif (!val) {\n\t\treturn;\n\t}\n\tswitch (val->attr_form) {\n\tcase DW_FORM_strp:\n\tcase DW_FORM_string:\n\t\tRZ_FREE(val->string.content);\n\t\tbreak;\n\tcase DW_FORM_exprloc:\n\tcase DW_FORM_block:\n\tcase DW_FORM_block1:\n\tcase DW_FORM_block2:\n\tcase DW_FORM_block4:\n\t\tRZ_FREE(val->block.data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t};\n}\n\nstatic void free_die(RzBinDwarfDie *die) {\n\tsize_t i;\n\tif (!die) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < die->count; i++) {\n\t\tfree_attr_value(&die->attr_values[i]);\n\t}\n\tRZ_FREE(die->attr_values);\n}\n\nstatic void free_comp_unit(RzBinDwarfCompUnit *cu) {\n\tsize_t i;\n\tif (!cu) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < cu->count; i++) {\n\t\tif (cu->dies) {\n\t\t\tfree_die(&cu->dies[i]);\n\t\t}\n\t}\n\tRZ_FREE(cu->dies);\n}\n\nRZ_API void rz_bin_dwarf_debug_info_free(RzBinDwarfDebugInfo *inf) {\n\tif (!inf) {\n\t\treturn;\n\t}\n\tfor (size_t i = 0; i < inf->count; i++) {\n\t\tfree_comp_unit(&inf->comp_units[i]);\n\t}\n\tht_up_free(inf->line_info_offset_comp_dir);\n\tht_up_free(inf->lookup_table);\n\tfree(inf->comp_units);\n\tfree(inf);\n}\n\nstatic const ut8 *fill_block_data(const ut8 *buf, const ut8 *buf_end, RzBinDwarfBlock *block) {\n\tblock->data = calloc(sizeof(ut8), block->length);\n\tif (!block->data) {\n\t\treturn NULL;\n\t}\n\t/* Maybe unroll this as an optimization in future? */\n\tif (block->data) {\n\t\tsize_t j = 0;\n\t\tfor (j = 0; j < block->length; j++) {\n\t\t\tblock->data[j] = READ8(buf);\n\t\t}\n\t}\n\treturn buf;\n}\n\n/**\n * This function is quite incomplete and requires lot of work\n * With parsing various new FORM values\n * @brief Parses attribute value based on its definition\n *        and stores it into `value`\n *\n * @param obuf\n * @param obuf_len Buffer max capacity\n * @param def Attribute definition\n * @param value Parsed value storage\n * @param hdr Current unit header\n * @param debug_str Ptr to string section start\n * @param debug_str_len Length of the string section\n * @return const ut8* Updated buffer\n */\nstatic const ut8 *parse_attr_value(const ut8 *obuf, int obuf_len,\n\tRzBinDwarfAttrDef *def, RzBinDwarfAttrValue *value,\n\tconst RzBinDwarfCompUnitHdr *hdr,\n\tconst ut8 *debug_str, size_t debug_str_len,\n\tbool big_endian) {\n\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + obuf_len;\n\tsize_t j;\n\n\trz_return_val_if_fail(def && value && hdr && obuf && obuf_len >= 1, NULL);\n\n\tvalue->attr_form = def->attr_form;\n\tvalue->attr_name = def->attr_name;\n\tvalue->block.data = NULL;\n\tvalue->string.content = NULL;\n\tvalue->string.offset = 0;\n\n\t// http://www.dwarfstd.org/doc/DWARF4.pdf#page=161&zoom=100,0,560\n\tswitch (def->attr_form) {\n\tcase DW_FORM_addr:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tswitch (hdr->address_size) {\n\t\tcase 1:\n\t\t\tvalue->address = READ8(buf);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvalue->address = READ16(buf);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tvalue->address = READ32(buf);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tvalue->address = READ64(buf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf(\"DWARF: Unexpected pointer size: %u\\n\", (unsigned)hdr->address_size);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_data1:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ8(buf);\n\t\tbreak;\n\tcase DW_FORM_data2:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ16(buf);\n\t\tbreak;\n\tcase DW_FORM_data4:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ32(buf);\n\t\tbreak;\n\tcase DW_FORM_data8:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ64(buf);\n\t\tbreak;\n\tcase DW_FORM_data16: // TODO Fix this, right now I just read the data, but I need to make storage for it\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ64(buf);\n\t\tvalue->uconstant = READ64(buf);\n\t\tbreak;\n\tcase DW_FORM_sdata:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tbuf = rz_leb128(buf, buf_end - buf, &value->sconstant);\n\t\tbreak;\n\tcase DW_FORM_udata:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &value->uconstant, NULL);\n\t\tbreak;\n\tcase DW_FORM_string:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.content = *buf ? strdup((const char *)buf) : NULL;\n\t\tbuf += (strlen((const char *)buf) + 1);\n\t\tbreak;\n\tcase DW_FORM_block1:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ8(buf);\n\t\tbuf = fill_block_data(buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_block2:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ16(buf);\n\t\tif (value->block.length > 0) {\n\t\t\tvalue->block.data = calloc(sizeof(ut8), value->block.length);\n\t\t\tif (!value->block.data) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tvalue->block.data[j] = READ8(buf);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block4:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ32(buf);\n\t\tbuf = fill_block_data(buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_block: // variable length ULEB128\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &value->block.length, NULL);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = fill_block_data(buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_flag:\n\t\tvalue->kind = DW_AT_KIND_FLAG;\n\t\tvalue->flag = READ8(buf);\n\t\tbreak;\n\t// offset in .debug_str\n\tcase DW_FORM_strp:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = dwarf_read_offset(hdr->is_64bit, big_endian, &buf, buf_end);\n\t\tif (debug_str && value->string.offset < debug_str_len) {\n\t\t\tvalue->string.content =\n\t\t\t\tstrdup((const char *)(debug_str + value->string.offset));\n\t\t} else {\n\t\t\tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t}\n\t\tbreak;\n\t// offset in .debug_info\n\tcase DW_FORM_ref_addr:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = dwarf_read_offset(hdr->is_64bit, big_endian, &buf, buf_end);\n\t\tbreak;\n\t// This type of reference is an offset from the first byte of the compilation\n\t// header for the compilation unit containing the reference\n\tcase DW_FORM_ref1:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ8(buf);\n\t\tbreak;\n\tcase DW_FORM_ref2:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ16(buf);\n\t\tbreak;\n\tcase DW_FORM_ref4:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ32(buf);\n\t\tbreak;\n\tcase DW_FORM_ref8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ64(buf);\n\t\tbreak;\n\tcase DW_FORM_ref_udata:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\t// uleb128 is enough to fit into ut64?\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &value->reference, NULL);\n\t\tvalue->reference += hdr->unit_offset;\n\t\tbreak;\n\t// offset in a section other than .debug_info or .debug_str\n\tcase DW_FORM_sec_offset:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = dwarf_read_offset(hdr->is_64bit, big_endian, &buf, buf_end);\n\t\tbreak;\n\tcase DW_FORM_exprloc:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &value->block.length, NULL);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = fill_block_data(buf, buf_end, &value->block);\n\t\tbreak;\n\t// this means that the flag is present, nothing is read\n\tcase DW_FORM_flag_present:\n\t\tvalue->kind = DW_AT_KIND_FLAG;\n\t\tvalue->flag = true;\n\t\tbreak;\n\tcase DW_FORM_ref_sig8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ64(buf);\n\t\tbreak;\n\t// offset into .debug_line_str section, can't parse the section now, so we just skip\n\tcase DW_FORM_strx:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\t// value->string.offset = dwarf_read_offset (hdr->is_64bit, big_endian, &buf, buf_end);\n\t\t// if (debug_str && value->string.offset < debug_line_str_len) {\n\t\t// \tvalue->string.content =\n\t\t// \t\tstrdup ((const char *)(debug_str + value->string.offset));\n\t\t// } else {\n\t\t// \tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t// }\n\t\tbreak;\n\tcase DW_FORM_strx1:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ8(buf);\n\t\tbreak;\n\tcase DW_FORM_strx2:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ16(buf);\n\t\tbreak;\n\tcase DW_FORM_strx3: // TODO Add 3 byte int read\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_strx4:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ32(buf);\n\t\tbreak;\n\tcase DW_FORM_implicit_const:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = def->special;\n\t\tbreak;\n\t/*  addrx* forms : The index is relative to the value of the\n\t\tDW_AT_addr_base attribute of the associated compilation unit.\n\t    index into an array of addresses in the .debug_addr section.*/\n\tcase DW_FORM_addrx:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &value->address, NULL);\n\t\tbreak;\n\tcase DW_FORM_addrx1:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ8(buf);\n\t\tbreak;\n\tcase DW_FORM_addrx2:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ16(buf);\n\t\tbreak;\n\tcase DW_FORM_addrx3:\n\t\t// I need to add 3byte endianess free read here TODO\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_addrx4:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ32(buf);\n\t\tbreak;\n\tcase DW_FORM_line_ptr: // offset in a section .debug_line_str\n\tcase DW_FORM_strp_sup: // offset in a section .debug_line_str\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = dwarf_read_offset(hdr->is_64bit, big_endian, &buf, buf_end);\n\t\t// if (debug_str && value->string.offset < debug_line_str_len) {\n\t\t// \tvalue->string.content =\n\t\t// \t\tstrdupsts\n\t\tbreak;\n\t// offset in the supplementary object file\n\tcase DW_FORM_ref_sup4:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ32(buf);\n\t\tbreak;\n\tcase DW_FORM_ref_sup8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ64(buf);\n\t\tbreak;\n\t// An index into the .debug_loc\n\tcase DW_FORM_loclistx:\n\t\tvalue->kind = DW_AT_KIND_LOCLISTPTR;\n\t\tvalue->reference = dwarf_read_offset(hdr->is_64bit, big_endian, &buf, buf_end);\n\t\tbreak;\n\t\t// An index into the .debug_rnglists\n\tcase DW_FORM_rnglistx:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &value->address, NULL);\n\t\tbreak;\n\tdefault:\n\t\teprintf(\"Unknown DW_FORM 0x%02\" PFMT64x \"\\n\", def->attr_form);\n\t\tvalue->uconstant = 0;\n\t\treturn NULL;\n\t}\n\treturn buf;\n}\n\n/**\n * \\param buf Start of the DIE data\n * \\param buf_end\n * \\param info debug info where the line_info_offset_comp_dir will be populated if such an entry is found\n * \\param abbrev Abbreviation of the DIE\n * \\param hdr Unit header\n * \\param die DIE to store the parsed info into\n * \\param debug_str Ptr to string section start\n * \\param debug_str_len Length of the string section\n * \\return const ut8* Updated buffer\n */\nstatic const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RzBinDwarfDebugInfo *info, RzBinDwarfAbbrevDecl *abbrev,\n\tRzBinDwarfCompUnitHdr *hdr, RzBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, bool big_endian) {\n\tsize_t i;\n\tconst char *comp_dir = NULL;\n\tut64 line_info_offset = UT64_MAX;\n\tif (abbrev->count) {\n\t\tfor (i = 0; i < abbrev->count - 1; i++) {\n\t\t\tmemset(&die->attr_values[i], 0, sizeof(die->attr_values[i]));\n\n\t\t\tbuf = parse_attr_value(buf, buf_end - buf, &abbrev->defs[i],\n\t\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len, big_endian);\n\n\t\t\tRzBinDwarfAttrValue *attribute = &die->attr_values[i];\n\n\t\t\tif (attribute->attr_name == DW_AT_comp_dir && (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string) && attribute->string.content) {\n\t\t\t\tcomp_dir = attribute->string.content;\n\t\t\t}\n\t\t\tif (attribute->attr_name == DW_AT_stmt_list) {\n\t\t\t\tif (attribute->kind == DW_AT_KIND_CONSTANT) {\n\t\t\t\t\tline_info_offset = attribute->uconstant;\n\t\t\t\t} else if (attribute->kind == DW_AT_KIND_REFERENCE) {\n\t\t\t\t\tline_info_offset = attribute->reference;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdie->count++;\n\t\t}\n\t}\n\n\t// If this is a compilation unit dir attribute, we want to cache it so the line info parsing\n\t// which will need this info can quickly look it up.\n\tif (comp_dir && line_info_offset != UT64_MAX) {\n\t\tchar *name = strdup(comp_dir);\n\t\tif (name) {\n\t\t\tif (!ht_up_insert(info->line_info_offset_comp_dir, line_info_offset, name)) {\n\t\t\t\tfree(name);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn buf;\n}\n\n/**\n * @brief Reads throught comp_unit buffer and parses all its DIEntries\n *\n * @param buf_start Start of the compilation unit data\n * @param unit Unit to store the newly parsed information\n * @param abbrevs Parsed abbrev section info of *all* abbreviations\n * @param first_abbr_idx index for first abbrev of the current comp unit in abbrev array\n * @param debug_str Ptr to string section start\n * @param debug_str_len Length of the string section\n *\n * @return const ut8* Update buffer\n */\nstatic const ut8 *parse_comp_unit(RzBinDwarfDebugInfo *info, const ut8 *buf_start,\n\tRzBinDwarfCompUnit *unit, const RzBinDwarfDebugAbbrev *abbrevs,\n\tsize_t first_abbr_idx, const ut8 *debug_str, size_t debug_str_len, bool big_endian) {\n\n\tconst ut8 *buf = buf_start;\n\tconst ut8 *buf_end = buf_start + unit->hdr.length - unit->hdr.header_size;\n\n\twhile (buf && buf < buf_end && buf >= buf_start) {\n\t\tif (unit->count && unit->capacity == unit->count) {\n\t\t\texpand_cu(unit);\n\t\t}\n\t\tRzBinDwarfDie *die = &unit->dies[unit->count];\n\t\t// add header size to the offset;\n\t\tdie->offset = buf - buf_start + unit->hdr.header_size + unit->offset;\n\t\tdie->offset += unit->hdr.is_64bit ? 12 : 4;\n\n\t\t// DIE starts with ULEB128 with the abbreviation code\n\t\tut64 abbr_code;\n\t\tbuf = rz_uleb128(buf, buf_end - buf, &abbr_code, NULL);\n\n\t\tif (abbr_code > abbrevs->count || !buf) { // something invalid\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (buf >= buf_end) {\n\t\t\tunit->count++; // we wanna store this entry too, usually the last one is null_entry\n\t\t\treturn buf; // return the buffer to parse next compilation units\n\t\t}\n\t\t// there can be \"null\" entries that have abbr_code == 0\n\t\tif (!abbr_code) {\n\t\t\tunit->count++;\n\t\t\tcontinue;\n\t\t}\n\t\tut64 abbr_idx = first_abbr_idx + abbr_code;\n\n\t\tif (abbrevs->count < abbr_idx) {\n\t\t\treturn NULL;\n\t\t}\n\t\tRzBinDwarfAbbrevDecl *abbrev = &abbrevs->decls[abbr_idx - 1];\n\n\t\tif (init_die(die, abbr_code, abbrev->count)) {\n\t\t\treturn NULL; // error\n\t\t}\n\t\tdie->tag = abbrev->tag;\n\t\tdie->has_children = abbrev->has_children;\n\n\t\tbuf = parse_die(buf, buf_end, info, abbrev, &unit->hdr, die, debug_str, debug_str_len, big_endian);\n\t\tif (!buf) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tunit->count++;\n\t}\n\treturn buf;\n}\n\n/**\n * @brief Reads all information about compilation unit header\n *\n * @param buf Start of the buffer\n * @param buf_end Upper bound of the buffer\n * @param unit Unit to read information into\n * @return ut8* Advanced position in a buffer\n */\nstatic const ut8 *info_comp_unit_read_hdr(const ut8 *buf, const ut8 *buf_end, RzBinDwarfCompUnitHdr *hdr, bool big_endian) {\n\t// 32-bit vs 64-bit dwarf formats\n\t// http://www.dwarfstd.org/doc/Dwarf3.pdf section 7.4\n\thdr->length = READ32(buf);\n\tif (hdr->length == (ut32)DWARF_INIT_LEN_64) { // then its 64bit\n\t\thdr->length = READ64(buf);\n\t\thdr->is_64bit = true;\n\t}\n\tconst ut8 *tmp = buf; // to calculate header size\n\thdr->version = READ16(buf);\n\tif (hdr->version == 5) {\n\t\thdr->unit_type = READ8(buf);\n\t\thdr->address_size = READ8(buf);\n\t\thdr->abbrev_offset = dwarf_read_offset(hdr->is_64bit, big_endian, &buf, buf_end);\n\n\t\tif (hdr->unit_type == DW_UT_skeleton || hdr->unit_type == DW_UT_split_compile) {\n\t\t\thdr->dwo_id = READ8(buf);\n\t\t} else if (hdr->unit_type == DW_UT_type || hdr->unit_type == DW_UT_split_type) {\n\t\t\thdr->type_sig = READ64(buf);\n\t\t\thdr->type_offset = dwarf_read_offset(hdr->is_64bit, big_endian, &buf, buf_end);\n\t\t}\n\t} else {\n\t\thdr->abbrev_offset = dwarf_read_offset(hdr->is_64bit, big_endian, &buf, buf_end);\n\t\thdr->address_size = READ8(buf);\n\t}\n\thdr->header_size = buf - tmp; // header size excluding length field\n\treturn buf;\n}\nstatic int expand_info(RzBinDwarfDebugInfo *info) {\n\trz_return_val_if_fail(info && info->capacity == info->count, -1);\n\n\tRzBinDwarfCompUnit *tmp = realloc(info->comp_units,\n\t\tinfo->capacity * 2 * sizeof(RzBinDwarfCompUnit));\n\tif (!tmp) {\n\t\treturn -1;\n\t}\n\n\tmemset((ut8 *)tmp + info->capacity * sizeof(RzBinDwarfCompUnit),\n\t\t0, info->capacity * sizeof(RzBinDwarfCompUnit));\n\n\tinfo->comp_units = tmp;\n\tinfo->capacity *= 2;\n\n\treturn 0;\n}\n\n/**\n * @brief Parses whole .debug_info section\n *\n * @param da Parsed Abbreviations\n * @param obuf .debug_info section buffer start\n * @param len length of the section buffer\n * @param debug_str start of the .debug_str section\n * @param debug_str_len length of the debug_str section\n * @param big_endian\n * @return RZ_API* parse_info_raw Parsed information\n */\nstatic RzBinDwarfDebugInfo *parse_info_raw(RzBinDwarfDebugAbbrev *da,\n\tconst ut8 *obuf, size_t len,\n\tconst ut8 *debug_str, size_t debug_str_len, bool big_endian) {\n\n\trz_return_val_if_fail(da && obuf, false);\n\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + len;\n\n\tRzBinDwarfDebugInfo *info = RZ_NEW0(RzBinDwarfDebugInfo);\n\tif (!info) {\n\t\treturn NULL;\n\t}\n\tif (!init_debug_info(info)) {\n\t\tgoto cleanup;\n\t}\n\tint unit_idx = 0;\n\n\twhile (buf < buf_end) {\n\t\tif (info->count >= info->capacity) {\n\t\t\tif (expand_info(info)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tRzBinDwarfCompUnit *unit = &info->comp_units[unit_idx];\n\t\tif (init_comp_unit(unit) < 0) {\n\t\t\tunit_idx--;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tinfo->count++;\n\n\t\tunit->offset = buf - obuf;\n\t\t// small redundancy, because it was easiest solution at a time\n\t\tunit->hdr.unit_offset = buf - obuf;\n\n\t\tbuf = info_comp_unit_read_hdr(buf, buf_end, &unit->hdr, big_endian);\n\n\t\tif (unit->hdr.length > len) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (da->decls->count >= da->capacity) {\n\t\t\teprintf(\"WARNING: malformed dwarf have not enough buckets for decls.\\n\");\n\t\t}\n\t\trz_warn_if_fail(da->count <= da->capacity);\n\n\t\t// find abbrev start for current comp unit\n\t\t// we could also do naive, ((char *)da->decls) + abbrev_offset,\n\t\t// but this is more bulletproof to invalid DWARF\n\t\tRzBinDwarfAbbrevDecl key = { .offset = unit->hdr.abbrev_offset };\n\t\tRzBinDwarfAbbrevDecl *abbrev_start = bsearch(&key, da->decls, da->count, sizeof(key), abbrev_cmp);\n\t\tif (!abbrev_start) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\t// They point to the same array object, so should be def. behaviour\n\t\tsize_t first_abbr_idx = abbrev_start - da->decls;\n\n\t\tbuf = parse_comp_unit(info, buf, unit, da, first_abbr_idx, debug_str, debug_str_len, big_endian);\n\n\t\tif (!buf) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tunit_idx++;\n\t}\n\n\treturn info;\n\ncleanup:\n\trz_bin_dwarf_debug_info_free(info);\n\treturn NULL;\n}\n\nstatic RzBinDwarfDebugAbbrev *parse_abbrev_raw(const ut8 *obuf, size_t len) {\n\tconst ut8 *buf = obuf, *buf_end = obuf + len;\n\tut64 tmp, attr_code, attr_form, offset;\n\tst64 special;\n\tut8 has_children;\n\tRzBinDwarfAbbrevDecl *tmpdecl;\n\n\t// XXX - Set a suitable value here.\n\tif (!obuf || len < 3) {\n\t\treturn NULL;\n\t}\n\tRzBinDwarfDebugAbbrev *da = RZ_NEW0(RzBinDwarfDebugAbbrev);\n\n\tinit_debug_abbrev(da);\n\n\twhile (buf && buf + 1 < buf_end) {\n\t\toffset = buf - obuf;\n\t\tbuf = rz_uleb128(buf, (size_t)(buf_end - buf), &tmp, NULL);\n\t\tif (!buf || !tmp || buf >= buf_end) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (da->count == da->capacity) {\n\t\t\texpand_debug_abbrev(da);\n\t\t}\n\t\ttmpdecl = &da->decls[da->count];\n\t\tinit_abbrev_decl(tmpdecl);\n\n\t\ttmpdecl->code = tmp;\n\t\tbuf = rz_uleb128(buf, (size_t)(buf_end - buf), &tmp, NULL);\n\t\ttmpdecl->tag = tmp;\n\n\t\ttmpdecl->offset = offset;\n\t\tif (buf >= buf_end) {\n\t\t\tbreak;\n\t\t}\n\t\thas_children = READ8(buf);\n\t\ttmpdecl->has_children = has_children;\n\t\tdo {\n\t\t\tif (tmpdecl->count == tmpdecl->capacity) {\n\t\t\t\texpand_abbrev_decl(tmpdecl);\n\t\t\t}\n\t\t\tbuf = rz_uleb128(buf, (size_t)(buf_end - buf), &attr_code, NULL);\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf = rz_uleb128(buf, (size_t)(buf_end - buf), &attr_form, NULL);\n\t\t\t// http://www.dwarfstd.org/doc/DWARF5.pdf#page=225\n\t\t\tif (attr_form == DW_FORM_implicit_const) {\n\t\t\t\tbuf = rz_leb128(buf, (size_t)(buf_end - buf), &special);\n\t\t\t\ttmpdecl->defs[tmpdecl->count].special = special;\n\t\t\t}\n\t\t\ttmpdecl->defs[tmpdecl->count].attr_name = attr_code;\n\t\t\ttmpdecl->defs[tmpdecl->count].attr_form = attr_form;\n\t\t\ttmpdecl->count++;\n\t\t} while (attr_code && attr_form);\n\n\t\tda->count++;\n\t}\n\treturn da;\n}\n\nRzBinSection *getsection(RzBinFile *binfile, const char *sn) {\n\trz_return_val_if_fail(binfile && sn, NULL);\n\tRzListIter *iter;\n\tRzBinSection *section = NULL;\n\tRzBinObject *o = binfile->o;\n\tif (!o || !o->sections) {\n\t\treturn NULL;\n\t}\n\trz_list_foreach (o->sections, iter, section) {\n\t\tif (!section->name) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr(section->name, sn)) {\n\t\t\treturn section;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic ut8 *get_section_bytes(RzBinFile *binfile, const char *sect_name, size_t *len) {\n\trz_return_val_if_fail(binfile && sect_name && len, NULL);\n\tRzBinSection *section = getsection(binfile, sect_name);\n\tif (!section) {\n\t\treturn NULL;\n\t}\n\tif (section->size > binfile->size) {\n\t\treturn NULL;\n\t}\n\t*len = section->size;\n\tut8 *buf = calloc(1, *len);\n\trz_buf_read_at(binfile->buf, section->paddr, buf, *len);\n\treturn buf;\n}\n\n/**\n * @brief Parses .debug_info section\n *\n * @param da Parsed abbreviations\n * @param bin\n * @return RzBinDwarfDebugInfo* Parsed information, NULL if error\n */\nRZ_API RzBinDwarfDebugInfo *rz_bin_dwarf_parse_info(RzBinFile *binfile, RzBinDwarfDebugAbbrev *da) {\n\trz_return_val_if_fail(binfile && da, NULL);\n\tRzBinSection *section = getsection(binfile, \"debug_info\");\n\tif (!section) {\n\t\treturn NULL;\n\t}\n\n\tRzBinDwarfDebugInfo *info = NULL;\n\tut64 debug_str_len = 0;\n\tut8 *debug_str_buf = NULL;\n\n\tRzBinSection *debug_str = debug_str = getsection(binfile, \"debug_str\");\n\tif (debug_str) {\n\t\tdebug_str_len = debug_str->size;\n\t\tdebug_str_buf = RZ_NEWS0(ut8, debug_str_len + 1);\n\t\tif (!debug_str_buf) {\n\t\t\tgoto cave;\n\t\t}\n\t\tst64 ret = rz_buf_read_at(binfile->buf, debug_str->paddr,\n\t\t\tdebug_str_buf, debug_str_len);\n\t\tif (!ret) {\n\t\t\tgoto cave_debug_str_buf;\n\t\t}\n\t}\n\n\tut64 len = section->size;\n\tif (!len) {\n\t\tgoto cave_debug_str_buf;\n\t}\n\tut8 *buf = RZ_NEWS0(ut8, len);\n\tif (!buf) {\n\t\tgoto cave_debug_str_buf;\n\t}\n\tif (!rz_buf_read_at(binfile->buf, section->paddr, buf, len)) {\n\t\tgoto cave_buf;\n\t}\n\tinfo = parse_info_raw(da, buf, len, debug_str_buf, debug_str_len,\n\t\tbinfile->o && binfile->o->info && binfile->o->info->big_endian);\n\tif (!info) {\n\t\tgoto cave_buf;\n\t}\n\n\t// build hashtable after whole parsing because of possible relocations\n\tif (info) {\n\t\tsize_t i, j;\n\t\tfor (i = 0; i < info->count; i++) {\n\t\t\tRzBinDwarfCompUnit *unit = &info->comp_units[i];\n\t\t\tfor (j = 0; j < unit->count; j++) {\n\t\t\t\tRzBinDwarfDie *die = &unit->dies[j];\n\t\t\t\tht_up_insert(info->lookup_table, die->offset, die); // optimization for further processing}\n\t\t\t}\n\t\t}\n\t}\ncave_buf:\n\tfree(buf);\ncave_debug_str_buf:\n\tfree(debug_str_buf);\ncave:\n\treturn info;\n}\n\n/**\n * \\param info if not NULL, filenames can get resolved to absolute paths using the compilation unit dirs from it\n */\nRZ_API RzBinDwarfLineInfo *rz_bin_dwarf_parse_line(RzBinFile *binfile, RZ_NULLABLE RzBinDwarfDebugInfo *info, RzBinDwarfLineInfoMask mask) {\n\trz_return_val_if_fail(binfile, NULL);\n\tRzBinSection *section = getsection(binfile, \"debug_line\");\n\tif (!section) {\n\t\treturn NULL;\n\t}\n\tut64 len = section->size;\n\tif (len < 1) {\n\t\treturn NULL;\n\t}\n\tut8 *buf = RZ_NEWS0(ut8, len + 1);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tint ret = rz_buf_read_at(binfile->buf, section->paddr, buf, len);\n\tif (ret != len) {\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\t// Actually parse the section\n\tRzBinDwarfLineInfo *r = parse_line_raw(binfile, buf, len, mask, binfile->o && binfile->o->info && binfile->o->info->big_endian, info);\n\tfree(buf);\n\treturn r;\n}\n\nRZ_API RzList /*<RzBinDwarfARangeSet>*/ *rz_bin_dwarf_parse_aranges(RzBinFile *binfile) {\n\trz_return_val_if_fail(binfile, NULL);\n\tRzBinSection *section = getsection(binfile, \"debug_aranges\");\n\tif (!section) {\n\t\treturn NULL;\n\t}\n\tsize_t len = section->size;\n\tif (!len) {\n\t\treturn NULL;\n\t}\n\tut8 *buf = RZ_NEWS0(ut8, len);\n\tint ret = rz_buf_read_at(binfile->buf, section->paddr, buf, len);\n\tif (!ret) {\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tRzList *r = parse_aranges_raw(buf, len, binfile->o && binfile->o->info && binfile->o->info->big_endian);\n\tfree(buf);\n\treturn r;\n}\n\nRZ_API RzBinDwarfDebugAbbrev *rz_bin_dwarf_parse_abbrev(RzBinFile *binfile) {\n\trz_return_val_if_fail(binfile, NULL);\n\tsize_t len = 0;\n\tut8 *buf = get_section_bytes(binfile, \"debug_abbrev\", &len);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tRzBinDwarfDebugAbbrev *abbrevs = parse_abbrev_raw(buf, len);\n\tfree(buf);\n\treturn abbrevs;\n}\n\nstatic inline ut64 get_max_offset(size_t addr_size) {\n\tswitch (addr_size) {\n\tcase 2:\n\t\treturn UT16_MAX;\n\tcase 4:\n\t\treturn UT32_MAX;\n\tcase 8:\n\t\treturn UT64_MAX;\n\t}\n\treturn 0;\n}\n\nstatic inline RzBinDwarfLocList *create_loc_list(ut64 offset) {\n\tRzBinDwarfLocList *list = RZ_NEW0(RzBinDwarfLocList);\n\tif (list) {\n\t\tlist->list = rz_list_new();\n\t\tlist->offset = offset;\n\t}\n\treturn list;\n}\n\nstatic inline RzBinDwarfLocRange *create_loc_range(ut64 start, ut64 end, RzBinDwarfBlock *block) {\n\tRzBinDwarfLocRange *range = RZ_NEW0(RzBinDwarfLocRange);\n\tif (range) {\n\t\trange->start = start;\n\t\trange->end = end;\n\t\trange->expression = block;\n\t}\n\treturn range;\n}\n\nstatic void free_loc_table_list(RzBinDwarfLocList *loc_list) {\n\tRzListIter *iter;\n\tRzBinDwarfLocRange *range;\n\trz_list_foreach (loc_list->list, iter, range) {\n\t\tfree(range->expression->data);\n\t\tfree(range->expression);\n\t\tfree(range);\n\t}\n\trz_list_free(loc_list->list);\n\tfree(loc_list);\n}\n\nstatic HtUP *parse_loc_raw(HtUP /*<offset, List *<LocListEntry>*/ *loc_table, const ut8 *buf, size_t len, size_t addr_size,\n\tbool big_endian) {\n\t/* GNU has their own extensions GNU locviews that we can't parse */\n\tconst ut8 *const buf_start = buf;\n\tconst ut8 *buf_end = buf + len;\n\t/* for recognizing Base address entry */\n\tut64 max_offset = get_max_offset(addr_size);\n\n\tut64 address_base = 0; /* remember base of the loclist */\n\tut64 list_offset = 0;\n\n\tRzBinDwarfLocList *loc_list = NULL;\n\tRzBinDwarfLocRange *range = NULL;\n\twhile (buf && buf < buf_end) {\n\t\tut64 start_addr = dwarf_read_address(addr_size, big_endian, &buf, buf_end);\n\t\tut64 end_addr = dwarf_read_address(addr_size, big_endian, &buf, buf_end);\n\n\t\tif (start_addr == 0 && end_addr == 0) { /* end of list entry: 0, 0 */\n\t\t\tif (loc_list) {\n\t\t\t\tht_up_insert(loc_table, loc_list->offset, loc_list);\n\t\t\t\tlist_offset = buf - buf_start;\n\t\t\t\tloc_list = NULL;\n\t\t\t}\n\t\t\taddress_base = 0;\n\t\t\tcontinue;\n\t\t} else if (start_addr == max_offset && end_addr != max_offset) {\n\t\t\t/* base address, DWARF2 doesn't have this type of entry, these entries shouldn't\n\t\t\t   be in the list, they are just informational entries for further parsing (address_base) */\n\t\t\taddress_base = end_addr;\n\t\t} else { /* location list entry: */\n\t\t\tif (!loc_list) {\n\t\t\t\tloc_list = create_loc_list(list_offset);\n\t\t\t}\n\t\t\t/* TODO in future parse expressions to better structure in dwarf.c and not in dwarf_process.c */\n\t\t\tRzBinDwarfBlock *block = RZ_NEW0(RzBinDwarfBlock);\n\t\t\tblock->length = READ16(buf);\n\t\t\tbuf = fill_block_data(buf, buf_end, block);\n\t\t\trange = create_loc_range(start_addr + address_base, end_addr + address_base, block);\n\t\t\tif (!range) {\n\t\t\t\tfree(block);\n\t\t\t}\n\t\t\trz_list_append(loc_list->list, range);\n\t\t\trange = NULL;\n\t\t}\n\t}\n\t/* if for some reason end of list is missing, then loc_list would leak */\n\tif (loc_list) {\n\t\tfree_loc_table_list(loc_list);\n\t}\n\treturn loc_table;\n}\n\n/**\n * @brief Parses out the .debug_loc section into a table that maps each list as\n *        offset of a list -> LocationList\n *\n * @param binfile\n * @param addr_size machine address size used in executable (necessary for parsing)\n * @return RZ_API*\n */\nRZ_API HtUP /*<offset, RzBinDwarfLocList*/ *rz_bin_dwarf_parse_loc(RzBinFile *binfile, int addr_size) {\n\trz_return_val_if_fail(binfile, NULL);\n\t/* The standarparse_loc_raw_frame, not sure why is that */\n\tsize_t len = 0;\n\tut8 *buf = get_section_bytes(binfile, \"debug_loc\", &len);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tHtUP /*<offset, RzBinDwarfLocList*/ *loc_table = ht_up_new0();\n\tif (!loc_table) {\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tloc_table = parse_loc_raw(loc_table, buf, len, addr_size, binfile->o && binfile->o->info && binfile->o->info->big_endian);\n\tfree(buf);\n\treturn loc_table;\n}\n\nstatic void free_loc_table_entry(HtUPKv *kv) {\n\tif (kv) {\n\t\tfree_loc_table_list(kv->value);\n\t}\n}\n\nRZ_API void rz_bin_dwarf_loc_free(HtUP /*<offset, RzBinDwarfLocList*>*/ *loc_table) {\n\trz_return_if_fail(loc_table);\n\tloc_table->opt.freefn = free_loc_table_entry;\n\tht_up_free(loc_table);\n}\n", "NAME=ELF: negative vnext crash\nFILE=bins/elf/analysis/6921737e-08e3-11e6-998c-a8ddd566ab1c.jpg\nCMDS=q!\nEXPECT=<<EOF\nEOF\nRUN\n\nNAME=pseudo-crash\nFILE==\nCMDS=e asm.pseudo=1; e asm.arch=x86; e asm.bits=64; wx 7299; pdj 1\nEXPECT=<<EOF\n[{\"offset\":0,\"esil\":\"cf,?{,18446744073709551515,rip,=,}\",\"refptr\":false,\"fcn_addr\":0,\"fcn_last\":0,\"size\":2,\"opcode\":\"if (((unsigned) var) < 0) goto 0xffffffffffffff9b\",\"disasm\":\"jb 0xffffffffffffff9b\",\"bytes\":\"7299\",\"family\":\"cpu\",\"type\":\"cjmp\",\"reloc\":false,\"type_num\":2147483649,\"type2_num\":0,\"jump\":-101,\"fail\":2}]\nEOF\nRUN\n\nNAME=ELF: ld-uclibc\nFILE=bins/elf/ld-uClibc-0.9.33.2.so\nCMDS=<<EOF\nii\niij\nEOF\nEXPECT=<<EOF\nnth vaddr bind type lib name \n-----------------------------\n[]\nEOF\nRUN\n\nNAME=ELF/Dwarf: abbrev empty\nFILE=bins/elf/dwarf_fuzzed_abbrev_empty\nCMDS=<<EOF\naaa\nEOF\nEXPECT=\nRUN\n"], "filenames": ["librz/bin/dwarf.c", "test/db/formats/elf/crash"], "buggy_code_start_loc": [1223, 27], "buggy_code_end_loc": [1748, 27], "fixing_code_start_loc": [1223, 28], "fixing_code_end_loc": [1754, 36], "type": "CWE-787", "message": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. In versions up to and including 0.3.1 there is a heap-based out of bounds write in parse_die() when reversing an AMD64 ELF binary with DWARF debug info. When a malicious AMD64 ELF binary is opened by a victim user, Rizin may crash or execute unintended actions. No workaround are known and users are advised to upgrade.", "other": {"cve": {"id": "CVE-2021-43814", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-13T20:15:07.640", "lastModified": "2021-12-22T21:29:35.347", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. In versions up to and including 0.3.1 there is a heap-based out of bounds write in parse_die() when reversing an AMD64 ELF binary with DWARF debug info. When a malicious AMD64 ELF binary is opened by a victim user, Rizin may crash or execute unintended actions. No workaround are known and users are advised to upgrade."}, {"lang": "es", "value": "Rizin es un marco de trabajo de ingenier\u00eda inversa de tipo UNIX y un conjunto de herramientas de l\u00ednea de comandos. En versiones hasta 0.3.1 incluy\u00e9ndola, se presenta una escritura fuera de l\u00edmites en la regi\u00f3n heap de la memoria en la funci\u00f3n parse_die() cuando es invertido un binario ELF AMD64 con informaci\u00f3n de depuraci\u00f3n DWARF. Cuando un usuario v\u00edctima abre un binario ELF AMD64 malicioso, Rizin puede bloquearse o ejecutar acciones no deseadas. No se conocen soluciones y se aconseja a los usuarios que actualicen"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rizin:rizin:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.3.1", "matchCriteriaId": "DDF54820-3CA2-49DC-9B65-DF480E8AF596"}]}]}], "references": [{"url": "https://github.com/rizinorg/rizin/commit/aa6917772d2f32e5a7daab25a46c72df0b5ea406", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rizinorg/rizin/issues/2083", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/rizinorg/rizin/security/advisories/GHSA-hqqp-vjcm-mw8r", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rizinorg/rizin/commit/aa6917772d2f32e5a7daab25a46c72df0b5ea406"}}