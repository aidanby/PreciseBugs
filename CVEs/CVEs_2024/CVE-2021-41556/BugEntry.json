{"buggy_code": ["/*\n    see copyright notice in squirrel.h\n*/\n#include \"sqpcheader.h\"\n#include \"sqvm.h\"\n#include \"sqtable.h\"\n#include \"sqclass.h\"\n#include \"sqfuncproto.h\"\n#include \"sqclosure.h\"\n\n\n\nSQClass::SQClass(SQSharedState *ss,SQClass *base)\n{\n    _base = base;\n    _typetag = 0;\n    _hook = NULL;\n    _udsize = 0;\n    _locked = false;\n    _constructoridx = -1;\n    if(_base) {\n        _constructoridx = _base->_constructoridx;\n        _udsize = _base->_udsize;\n        _defaultvalues.copy(base->_defaultvalues);\n        _methods.copy(base->_methods);\n        _COPY_VECTOR(_metamethods,base->_metamethods,MT_LAST);\n        __ObjAddRef(_base);\n    }\n    _members = base?base->_members->Clone() : SQTable::Create(ss,0);\n    __ObjAddRef(_members);\n\n    INIT_CHAIN();\n    ADD_TO_CHAIN(&_sharedstate->_gc_chain, this);\n}\n\nvoid SQClass::Finalize() {\n    _attributes.Null();\n    _NULL_SQOBJECT_VECTOR(_defaultvalues,_defaultvalues.size());\n    _methods.resize(0);\n    _NULL_SQOBJECT_VECTOR(_metamethods,MT_LAST);\n    __ObjRelease(_members);\n    if(_base) {\n        __ObjRelease(_base);\n    }\n}\n\nSQClass::~SQClass()\n{\n    REMOVE_FROM_CHAIN(&_sharedstate->_gc_chain, this);\n    Finalize();\n}\n\nbool SQClass::NewSlot(SQSharedState *ss,const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic)\n{\n    SQObjectPtr temp;\n    bool belongs_to_static_table = sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE || bstatic;\n    if(_locked && !belongs_to_static_table)\n        return false; //the class already has an instance so cannot be modified\n    if(_members->Get(key,temp) && _isfield(temp)) //overrides the default value\n    {\n        _defaultvalues[_member_idx(temp)].val = val;\n        return true;\n    }\n    if(belongs_to_static_table) {\n        SQInteger mmidx;\n        if((sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE) &&\n            (mmidx = ss->GetMetaMethodIdxByName(key)) != -1) {\n            _metamethods[mmidx] = val;\n        }\n        else {\n            SQObjectPtr theval = val;\n            if(_base && sq_type(val) == OT_CLOSURE) {\n                theval = _closure(val)->Clone();\n                _closure(theval)->_base = _base;\n                __ObjAddRef(_base); //ref for the closure\n            }\n            if(sq_type(temp) == OT_NULL) {\n                bool isconstructor;\n                SQVM::IsEqual(ss->_constructoridx, key, isconstructor);\n                if(isconstructor) {\n                    _constructoridx = (SQInteger)_methods.size();\n                }\n                SQClassMember m;\n                m.val = theval;\n                _members->NewSlot(key,SQObjectPtr(_make_method_idx(_methods.size())));\n                _methods.push_back(m);\n            }\n            else {\n                _methods[_member_idx(temp)].val = theval;\n            }\n        }\n        return true;\n    }\n    SQClassMember m;\n    m.val = val;\n    _members->NewSlot(key,SQObjectPtr(_make_field_idx(_defaultvalues.size())));\n    _defaultvalues.push_back(m);\n    return true;\n}\n\nSQInstance *SQClass::CreateInstance()\n{\n    if(!_locked) Lock();\n    return SQInstance::Create(_opt_ss(this),this);\n}\n\nSQInteger SQClass::Next(const SQObjectPtr &refpos, SQObjectPtr &outkey, SQObjectPtr &outval)\n{\n    SQObjectPtr oval;\n    SQInteger idx = _members->Next(false,refpos,outkey,oval);\n    if(idx != -1) {\n        if(_ismethod(oval)) {\n            outval = _methods[_member_idx(oval)].val;\n        }\n        else {\n            SQObjectPtr &o = _defaultvalues[_member_idx(oval)].val;\n            outval = _realval(o);\n        }\n    }\n    return idx;\n}\n\nbool SQClass::SetAttributes(const SQObjectPtr &key,const SQObjectPtr &val)\n{\n    SQObjectPtr idx;\n    if(_members->Get(key,idx)) {\n        if(_isfield(idx))\n            _defaultvalues[_member_idx(idx)].attrs = val;\n        else\n            _methods[_member_idx(idx)].attrs = val;\n        return true;\n    }\n    return false;\n}\n\nbool SQClass::GetAttributes(const SQObjectPtr &key,SQObjectPtr &outval)\n{\n    SQObjectPtr idx;\n    if(_members->Get(key,idx)) {\n        outval = (_isfield(idx)?_defaultvalues[_member_idx(idx)].attrs:_methods[_member_idx(idx)].attrs);\n        return true;\n    }\n    return false;\n}\n\n///////////////////////////////////////////////////////////////////////\nvoid SQInstance::Init(SQSharedState *ss)\n{\n    _userpointer = NULL;\n    _hook = NULL;\n    __ObjAddRef(_class);\n    _delegate = _class->_members;\n    INIT_CHAIN();\n    ADD_TO_CHAIN(&_sharedstate->_gc_chain, this);\n}\n\nSQInstance::SQInstance(SQSharedState *ss, SQClass *c, SQInteger memsize)\n{\n    _memsize = memsize;\n    _class = c;\n    SQUnsignedInteger nvalues = _class->_defaultvalues.size();\n    for(SQUnsignedInteger n = 0; n < nvalues; n++) {\n        new (&_values[n]) SQObjectPtr(_class->_defaultvalues[n].val);\n    }\n    Init(ss);\n}\n\nSQInstance::SQInstance(SQSharedState *ss, SQInstance *i, SQInteger memsize)\n{\n    _memsize = memsize;\n    _class = i->_class;\n    SQUnsignedInteger nvalues = _class->_defaultvalues.size();\n    for(SQUnsignedInteger n = 0; n < nvalues; n++) {\n        new (&_values[n]) SQObjectPtr(i->_values[n]);\n    }\n    Init(ss);\n}\n\nvoid SQInstance::Finalize()\n{\n    SQUnsignedInteger nvalues = _class->_defaultvalues.size();\n    __ObjRelease(_class);\n    _NULL_SQOBJECT_VECTOR(_values,nvalues);\n}\n\nSQInstance::~SQInstance()\n{\n    REMOVE_FROM_CHAIN(&_sharedstate->_gc_chain, this);\n    if(_class){ Finalize(); } //if _class is null it was already finalized by the GC\n}\n\nbool SQInstance::GetMetaMethod(SQVM* SQ_UNUSED_ARG(v),SQMetaMethod mm,SQObjectPtr &res)\n{\n    if(sq_type(_class->_metamethods[mm]) != OT_NULL) {\n        res = _class->_metamethods[mm];\n        return true;\n    }\n    return false;\n}\n\nbool SQInstance::InstanceOf(SQClass *trg)\n{\n    SQClass *parent = _class;\n    while(parent != NULL) {\n        if(parent == trg)\n            return true;\n        parent = parent->_base;\n    }\n    return false;\n}\n", "/*  see copyright notice in squirrel.h */\n#ifndef _SQCLASS_H_\n#define _SQCLASS_H_\n\nstruct SQInstance;\n\nstruct SQClassMember {\n    SQObjectPtr val;\n    SQObjectPtr attrs;\n    void Null() {\n        val.Null();\n        attrs.Null();\n    }\n};\n\ntypedef sqvector<SQClassMember> SQClassMemberVec;\n\n#define MEMBER_TYPE_METHOD 0x01000000\n#define MEMBER_TYPE_FIELD 0x02000000\n\n#define _ismethod(o) (_integer(o)&MEMBER_TYPE_METHOD)\n#define _isfield(o) (_integer(o)&MEMBER_TYPE_FIELD)\n#define _make_method_idx(i) ((SQInteger)(MEMBER_TYPE_METHOD|i))\n#define _make_field_idx(i) ((SQInteger)(MEMBER_TYPE_FIELD|i))\n#define _member_type(o) (_integer(o)&0xFF000000)\n#define _member_idx(o) (_integer(o)&0x00FFFFFF)\n\nstruct SQClass : public CHAINABLE_OBJ\n{\n    SQClass(SQSharedState *ss,SQClass *base);\npublic:\n    static SQClass* Create(SQSharedState *ss,SQClass *base) {\n        SQClass *newclass = (SQClass *)SQ_MALLOC(sizeof(SQClass));\n        new (newclass) SQClass(ss, base);\n        return newclass;\n    }\n    ~SQClass();\n    bool NewSlot(SQSharedState *ss, const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic);\n    bool Get(const SQObjectPtr &key,SQObjectPtr &val) {\n        if(_members->Get(key,val)) {\n            if(_isfield(val)) {\n                SQObjectPtr &o = _defaultvalues[_member_idx(val)].val;\n                val = _realval(o);\n            }\n            else {\n                val = _methods[_member_idx(val)].val;\n            }\n            return true;\n        }\n        return false;\n    }\n    bool GetConstructor(SQObjectPtr &ctor)\n    {\n        if(_constructoridx != -1) {\n            ctor = _methods[_constructoridx].val;\n            return true;\n        }\n        return false;\n    }\n    bool SetAttributes(const SQObjectPtr &key,const SQObjectPtr &val);\n    bool GetAttributes(const SQObjectPtr &key,SQObjectPtr &outval);\n    void Lock() { _locked = true; if(_base) _base->Lock(); }\n    void Release() {\n        if (_hook) { _hook(_typetag,0);}\n        sq_delete(this, SQClass);\n    }\n    void Finalize();\n#ifndef NO_GARBAGE_COLLECTOR\n    void Mark(SQCollectable ** );\n    SQObjectType GetType() {return OT_CLASS;}\n#endif\n    SQInteger Next(const SQObjectPtr &refpos, SQObjectPtr &outkey, SQObjectPtr &outval);\n    SQInstance *CreateInstance();\n    SQTable *_members;\n    SQClass *_base;\n    SQClassMemberVec _defaultvalues;\n    SQClassMemberVec _methods;\n    SQObjectPtr _metamethods[MT_LAST];\n    SQObjectPtr _attributes;\n    SQUserPointer _typetag;\n    SQRELEASEHOOK _hook;\n    bool _locked;\n    SQInteger _constructoridx;\n    SQInteger _udsize;\n};\n\n#define calcinstancesize(_theclass_) \\\n    (_theclass_->_udsize + sq_aligning(sizeof(SQInstance) +  (sizeof(SQObjectPtr)*(_theclass_->_defaultvalues.size()>0?_theclass_->_defaultvalues.size()-1:0))))\n\nstruct SQInstance : public SQDelegable\n{\n    void Init(SQSharedState *ss);\n    SQInstance(SQSharedState *ss, SQClass *c, SQInteger memsize);\n    SQInstance(SQSharedState *ss, SQInstance *c, SQInteger memsize);\npublic:\n    static SQInstance* Create(SQSharedState *ss,SQClass *theclass) {\n\n        SQInteger size = calcinstancesize(theclass);\n        SQInstance *newinst = (SQInstance *)SQ_MALLOC(size);\n        new (newinst) SQInstance(ss, theclass,size);\n        if(theclass->_udsize) {\n            newinst->_userpointer = ((unsigned char *)newinst) + (size - theclass->_udsize);\n        }\n        return newinst;\n    }\n    SQInstance *Clone(SQSharedState *ss)\n    {\n        SQInteger size = calcinstancesize(_class);\n        SQInstance *newinst = (SQInstance *)SQ_MALLOC(size);\n        new (newinst) SQInstance(ss, this,size);\n        if(_class->_udsize) {\n            newinst->_userpointer = ((unsigned char *)newinst) + (size - _class->_udsize);\n        }\n        return newinst;\n    }\n    ~SQInstance();\n    bool Get(const SQObjectPtr &key,SQObjectPtr &val)  {\n        if(_class->_members->Get(key,val)) {\n            if(_isfield(val)) {\n                SQObjectPtr &o = _values[_member_idx(val)];\n                val = _realval(o);\n            }\n            else {\n                val = _class->_methods[_member_idx(val)].val;\n            }\n            return true;\n        }\n        return false;\n    }\n    bool Set(const SQObjectPtr &key,const SQObjectPtr &val) {\n        SQObjectPtr idx;\n        if(_class->_members->Get(key,idx) && _isfield(idx)) {\n            _values[_member_idx(idx)] = val;\n            return true;\n        }\n        return false;\n    }\n    void Release() {\n        _uiRef++;\n        if (_hook) { _hook(_userpointer,0);}\n        _uiRef--;\n        if(_uiRef > 0) return;\n        SQInteger size = _memsize;\n        this->~SQInstance();\n        SQ_FREE(this, size);\n    }\n    void Finalize();\n#ifndef NO_GARBAGE_COLLECTOR\n    void Mark(SQCollectable ** );\n    SQObjectType GetType() {return OT_INSTANCE;}\n#endif\n    bool InstanceOf(SQClass *trg);\n    bool GetMetaMethod(SQVM *v,SQMetaMethod mm,SQObjectPtr &res);\n\n    SQClass *_class;\n    SQUserPointer _userpointer;\n    SQRELEASEHOOK _hook;\n    SQInteger _memsize;\n    SQObjectPtr _values[1];\n};\n\n#endif //_SQCLASS_H_\n"], "fixing_code": ["/*\n    see copyright notice in squirrel.h\n*/\n#include \"sqpcheader.h\"\n#include \"sqvm.h\"\n#include \"sqtable.h\"\n#include \"sqclass.h\"\n#include \"sqfuncproto.h\"\n#include \"sqclosure.h\"\n\n\n\nSQClass::SQClass(SQSharedState *ss,SQClass *base)\n{\n    _base = base;\n    _typetag = 0;\n    _hook = NULL;\n    _udsize = 0;\n    _locked = false;\n    _constructoridx = -1;\n    if(_base) {\n        _constructoridx = _base->_constructoridx;\n        _udsize = _base->_udsize;\n        _defaultvalues.copy(base->_defaultvalues);\n        _methods.copy(base->_methods);\n        _COPY_VECTOR(_metamethods,base->_metamethods,MT_LAST);\n        __ObjAddRef(_base);\n    }\n    _members = base?base->_members->Clone() : SQTable::Create(ss,0);\n    __ObjAddRef(_members);\n\n    INIT_CHAIN();\n    ADD_TO_CHAIN(&_sharedstate->_gc_chain, this);\n}\n\nvoid SQClass::Finalize() {\n    _attributes.Null();\n    _NULL_SQOBJECT_VECTOR(_defaultvalues,_defaultvalues.size());\n    _methods.resize(0);\n    _NULL_SQOBJECT_VECTOR(_metamethods,MT_LAST);\n    __ObjRelease(_members);\n    if(_base) {\n        __ObjRelease(_base);\n    }\n}\n\nSQClass::~SQClass()\n{\n    REMOVE_FROM_CHAIN(&_sharedstate->_gc_chain, this);\n    Finalize();\n}\n\nbool SQClass::NewSlot(SQSharedState *ss,const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic)\n{\n    SQObjectPtr temp;\n    bool belongs_to_static_table = sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE || bstatic;\n    if(_locked && !belongs_to_static_table)\n        return false; //the class already has an instance so cannot be modified\n    if(_members->Get(key,temp) && _isfield(temp)) //overrides the default value\n    {\n        _defaultvalues[_member_idx(temp)].val = val;\n        return true;\n    }\n\tif (_members->CountUsed() >= MEMBER_MAX_COUNT) {\n\t\treturn false;\n\t}\n    if(belongs_to_static_table) {\n        SQInteger mmidx;\n        if((sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE) &&\n            (mmidx = ss->GetMetaMethodIdxByName(key)) != -1) {\n            _metamethods[mmidx] = val;\n        }\n        else {\n            SQObjectPtr theval = val;\n            if(_base && sq_type(val) == OT_CLOSURE) {\n                theval = _closure(val)->Clone();\n                _closure(theval)->_base = _base;\n                __ObjAddRef(_base); //ref for the closure\n            }\n            if(sq_type(temp) == OT_NULL) {\n                bool isconstructor;\n                SQVM::IsEqual(ss->_constructoridx, key, isconstructor);\n                if(isconstructor) {\n                    _constructoridx = (SQInteger)_methods.size();\n                }\n                SQClassMember m;\n                m.val = theval;\n                _members->NewSlot(key,SQObjectPtr(_make_method_idx(_methods.size())));\n                _methods.push_back(m);\n            }\n            else {\n                _methods[_member_idx(temp)].val = theval;\n            }\n        }\n        return true;\n    }\n    SQClassMember m;\n    m.val = val;\n    _members->NewSlot(key,SQObjectPtr(_make_field_idx(_defaultvalues.size())));\n    _defaultvalues.push_back(m);\n    return true;\n}\n\nSQInstance *SQClass::CreateInstance()\n{\n    if(!_locked) Lock();\n    return SQInstance::Create(_opt_ss(this),this);\n}\n\nSQInteger SQClass::Next(const SQObjectPtr &refpos, SQObjectPtr &outkey, SQObjectPtr &outval)\n{\n    SQObjectPtr oval;\n    SQInteger idx = _members->Next(false,refpos,outkey,oval);\n    if(idx != -1) {\n        if(_ismethod(oval)) {\n            outval = _methods[_member_idx(oval)].val;\n        }\n        else {\n            SQObjectPtr &o = _defaultvalues[_member_idx(oval)].val;\n            outval = _realval(o);\n        }\n    }\n    return idx;\n}\n\nbool SQClass::SetAttributes(const SQObjectPtr &key,const SQObjectPtr &val)\n{\n    SQObjectPtr idx;\n    if(_members->Get(key,idx)) {\n        if(_isfield(idx))\n            _defaultvalues[_member_idx(idx)].attrs = val;\n        else\n            _methods[_member_idx(idx)].attrs = val;\n        return true;\n    }\n    return false;\n}\n\nbool SQClass::GetAttributes(const SQObjectPtr &key,SQObjectPtr &outval)\n{\n    SQObjectPtr idx;\n    if(_members->Get(key,idx)) {\n        outval = (_isfield(idx)?_defaultvalues[_member_idx(idx)].attrs:_methods[_member_idx(idx)].attrs);\n        return true;\n    }\n    return false;\n}\n\n///////////////////////////////////////////////////////////////////////\nvoid SQInstance::Init(SQSharedState *ss)\n{\n    _userpointer = NULL;\n    _hook = NULL;\n    __ObjAddRef(_class);\n    _delegate = _class->_members;\n    INIT_CHAIN();\n    ADD_TO_CHAIN(&_sharedstate->_gc_chain, this);\n}\n\nSQInstance::SQInstance(SQSharedState *ss, SQClass *c, SQInteger memsize)\n{\n    _memsize = memsize;\n    _class = c;\n    SQUnsignedInteger nvalues = _class->_defaultvalues.size();\n    for(SQUnsignedInteger n = 0; n < nvalues; n++) {\n        new (&_values[n]) SQObjectPtr(_class->_defaultvalues[n].val);\n    }\n    Init(ss);\n}\n\nSQInstance::SQInstance(SQSharedState *ss, SQInstance *i, SQInteger memsize)\n{\n    _memsize = memsize;\n    _class = i->_class;\n    SQUnsignedInteger nvalues = _class->_defaultvalues.size();\n    for(SQUnsignedInteger n = 0; n < nvalues; n++) {\n        new (&_values[n]) SQObjectPtr(i->_values[n]);\n    }\n    Init(ss);\n}\n\nvoid SQInstance::Finalize()\n{\n    SQUnsignedInteger nvalues = _class->_defaultvalues.size();\n    __ObjRelease(_class);\n    _NULL_SQOBJECT_VECTOR(_values,nvalues);\n}\n\nSQInstance::~SQInstance()\n{\n    REMOVE_FROM_CHAIN(&_sharedstate->_gc_chain, this);\n    if(_class){ Finalize(); } //if _class is null it was already finalized by the GC\n}\n\nbool SQInstance::GetMetaMethod(SQVM* SQ_UNUSED_ARG(v),SQMetaMethod mm,SQObjectPtr &res)\n{\n    if(sq_type(_class->_metamethods[mm]) != OT_NULL) {\n        res = _class->_metamethods[mm];\n        return true;\n    }\n    return false;\n}\n\nbool SQInstance::InstanceOf(SQClass *trg)\n{\n    SQClass *parent = _class;\n    while(parent != NULL) {\n        if(parent == trg)\n            return true;\n        parent = parent->_base;\n    }\n    return false;\n}\n", "/*  see copyright notice in squirrel.h */\n#ifndef _SQCLASS_H_\n#define _SQCLASS_H_\n\nstruct SQInstance;\n\nstruct SQClassMember {\n    SQObjectPtr val;\n    SQObjectPtr attrs;\n    void Null() {\n        val.Null();\n        attrs.Null();\n    }\n};\n\ntypedef sqvector<SQClassMember> SQClassMemberVec;\n\n#define MEMBER_TYPE_METHOD 0x01000000\n#define MEMBER_TYPE_FIELD 0x02000000\n#define MEMBER_MAX_COUNT 0x00FFFFFF\n\n#define _ismethod(o) (_integer(o)&MEMBER_TYPE_METHOD)\n#define _isfield(o) (_integer(o)&MEMBER_TYPE_FIELD)\n#define _make_method_idx(i) ((SQInteger)(MEMBER_TYPE_METHOD|i))\n#define _make_field_idx(i) ((SQInteger)(MEMBER_TYPE_FIELD|i))\n#define _member_type(o) (_integer(o)&0xFF000000)\n#define _member_idx(o) (_integer(o)&0x00FFFFFF)\n\nstruct SQClass : public CHAINABLE_OBJ\n{\n    SQClass(SQSharedState *ss,SQClass *base);\npublic:\n    static SQClass* Create(SQSharedState *ss,SQClass *base) {\n        SQClass *newclass = (SQClass *)SQ_MALLOC(sizeof(SQClass));\n        new (newclass) SQClass(ss, base);\n        return newclass;\n    }\n    ~SQClass();\n    bool NewSlot(SQSharedState *ss, const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic);\n    bool Get(const SQObjectPtr &key,SQObjectPtr &val) {\n        if(_members->Get(key,val)) {\n            if(_isfield(val)) {\n                SQObjectPtr &o = _defaultvalues[_member_idx(val)].val;\n                val = _realval(o);\n            }\n            else {\n                val = _methods[_member_idx(val)].val;\n            }\n            return true;\n        }\n        return false;\n    }\n    bool GetConstructor(SQObjectPtr &ctor)\n    {\n        if(_constructoridx != -1) {\n            ctor = _methods[_constructoridx].val;\n            return true;\n        }\n        return false;\n    }\n    bool SetAttributes(const SQObjectPtr &key,const SQObjectPtr &val);\n    bool GetAttributes(const SQObjectPtr &key,SQObjectPtr &outval);\n    void Lock() { _locked = true; if(_base) _base->Lock(); }\n    void Release() {\n        if (_hook) { _hook(_typetag,0);}\n        sq_delete(this, SQClass);\n    }\n    void Finalize();\n#ifndef NO_GARBAGE_COLLECTOR\n    void Mark(SQCollectable ** );\n    SQObjectType GetType() {return OT_CLASS;}\n#endif\n    SQInteger Next(const SQObjectPtr &refpos, SQObjectPtr &outkey, SQObjectPtr &outval);\n    SQInstance *CreateInstance();\n    SQTable *_members;\n    SQClass *_base;\n    SQClassMemberVec _defaultvalues;\n    SQClassMemberVec _methods;\n    SQObjectPtr _metamethods[MT_LAST];\n    SQObjectPtr _attributes;\n    SQUserPointer _typetag;\n    SQRELEASEHOOK _hook;\n    bool _locked;\n    SQInteger _constructoridx;\n    SQInteger _udsize;\n};\n\n#define calcinstancesize(_theclass_) \\\n    (_theclass_->_udsize + sq_aligning(sizeof(SQInstance) +  (sizeof(SQObjectPtr)*(_theclass_->_defaultvalues.size()>0?_theclass_->_defaultvalues.size()-1:0))))\n\nstruct SQInstance : public SQDelegable\n{\n    void Init(SQSharedState *ss);\n    SQInstance(SQSharedState *ss, SQClass *c, SQInteger memsize);\n    SQInstance(SQSharedState *ss, SQInstance *c, SQInteger memsize);\npublic:\n    static SQInstance* Create(SQSharedState *ss,SQClass *theclass) {\n\n        SQInteger size = calcinstancesize(theclass);\n        SQInstance *newinst = (SQInstance *)SQ_MALLOC(size);\n        new (newinst) SQInstance(ss, theclass,size);\n        if(theclass->_udsize) {\n            newinst->_userpointer = ((unsigned char *)newinst) + (size - theclass->_udsize);\n        }\n        return newinst;\n    }\n    SQInstance *Clone(SQSharedState *ss)\n    {\n        SQInteger size = calcinstancesize(_class);\n        SQInstance *newinst = (SQInstance *)SQ_MALLOC(size);\n        new (newinst) SQInstance(ss, this,size);\n        if(_class->_udsize) {\n            newinst->_userpointer = ((unsigned char *)newinst) + (size - _class->_udsize);\n        }\n        return newinst;\n    }\n    ~SQInstance();\n    bool Get(const SQObjectPtr &key,SQObjectPtr &val)  {\n        if(_class->_members->Get(key,val)) {\n            if(_isfield(val)) {\n                SQObjectPtr &o = _values[_member_idx(val)];\n                val = _realval(o);\n            }\n            else {\n                val = _class->_methods[_member_idx(val)].val;\n            }\n            return true;\n        }\n        return false;\n    }\n    bool Set(const SQObjectPtr &key,const SQObjectPtr &val) {\n        SQObjectPtr idx;\n        if(_class->_members->Get(key,idx) && _isfield(idx)) {\n            _values[_member_idx(idx)] = val;\n            return true;\n        }\n        return false;\n    }\n    void Release() {\n        _uiRef++;\n        if (_hook) { _hook(_userpointer,0);}\n        _uiRef--;\n        if(_uiRef > 0) return;\n        SQInteger size = _memsize;\n        this->~SQInstance();\n        SQ_FREE(this, size);\n    }\n    void Finalize();\n#ifndef NO_GARBAGE_COLLECTOR\n    void Mark(SQCollectable ** );\n    SQObjectType GetType() {return OT_INSTANCE;}\n#endif\n    bool InstanceOf(SQClass *trg);\n    bool GetMetaMethod(SQVM *v,SQMetaMethod mm,SQObjectPtr &res);\n\n    SQClass *_class;\n    SQUserPointer _userpointer;\n    SQRELEASEHOOK _hook;\n    SQInteger _memsize;\n    SQObjectPtr _values[1];\n};\n\n#endif //_SQCLASS_H_\n"], "filenames": ["squirrel/sqclass.cpp", "squirrel/sqclass.h"], "buggy_code_start_loc": [63, 19], "buggy_code_end_loc": [63, 19], "fixing_code_start_loc": [64, 20], "fixing_code_end_loc": [67, 21], "type": "CWE-125", "message": "sqclass.cpp in Squirrel through 2.2.5 and 3.x through 3.1 allows an out-of-bounds read (in the core interpreter) that can lead to Code Execution. If a victim executes an attacker-controlled squirrel script, it is possible for the attacker to break out of the squirrel script sandbox even if all dangerous functionality such as File System functions has been disabled. An attacker might abuse this bug to target (for example) Cloud services that allow customization via SquirrelScripts, or distribute malware through video games that embed a Squirrel Engine.", "other": {"cve": {"id": "CVE-2021-41556", "sourceIdentifier": "cve@mitre.org", "published": "2022-07-28T21:15:08.057", "lastModified": "2022-12-09T16:35:44.033", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "sqclass.cpp in Squirrel through 2.2.5 and 3.x through 3.1 allows an out-of-bounds read (in the core interpreter) that can lead to Code Execution. If a victim executes an attacker-controlled squirrel script, it is possible for the attacker to break out of the squirrel script sandbox even if all dangerous functionality such as File System functions has been disabled. An attacker might abuse this bug to target (for example) Cloud services that allow customization via SquirrelScripts, or distribute malware through video games that embed a Squirrel Engine."}, {"lang": "es", "value": "El archivo sqclass.cpp en Squirrel versiones hasta 2.2.5 y 3.x hasta 3.1 permite una lectura fuera de l\u00edmites (en el int\u00e9rprete del n\u00facleo) que puede conllevar a una ejecuci\u00f3n de c\u00f3digo. Si una v\u00edctima ejecuta un script de Squirrel controlado por un atacante, es posible que el atacante salga del sandbox del script de Squirrel incluso si toda la funcionalidad peligrosa, como las funciones del sistema de archivos, ha sido deshabilitada. Un atacante podr\u00eda abusar de este fallo para dirigirse (por ejemplo) a servicios en la nube que permitan la personalizaci\u00f3n por medio de SquirrelScripts, o distribuir malware mediante videojuegos que incorporen un Squirrel Engine"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:squirrel-lang:squirrel:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.2.5", "matchCriteriaId": "27238A56-A2B2-4A34-8BF6-3AD58BB93126"}, {"vulnerable": true, "criteria": "cpe:2.3:a:squirrel-lang:squirrel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0", "versionEndIncluding": "3.1", "matchCriteriaId": "E46EF8F0-BDBD-478E-9C80-F16555DB3FC0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "http://www.squirrel-lang.org/#download", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://blog.sonarsource.com/squirrel-vm-sandbox-escape/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/albertodemichelis/squirrel/commit/23a0620658714b996d20da3d4dd1a0dcf9b0bd98", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BV7SJJ44AGAX4ILIVPREIXPJ2GOG3FKV/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/M3FQILX7UUEERSDPMZP3MKGTMY2E7ESU/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/albertodemichelis/squirrel/commit/23a0620658714b996d20da3d4dd1a0dcf9b0bd98"}}