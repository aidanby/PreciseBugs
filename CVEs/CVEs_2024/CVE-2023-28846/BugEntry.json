{"buggy_code": ["module Unpoly\n  module Rails\n    ##\n    # Installs a `before_action` into all controllers which echoes the\n    # request's URL as a response header `X-Up-Location` and the request's\n    # HTTP method as `X-Up-Method`.\n    #\n    # The Unpoly frontend requires these headers to detect redirects,\n    # which are otherwise undetectable for an AJAX client.\n    module RequestEchoHeaders\n\n      def self.included(base)\n        if base.respond_to?(:before_action)\n          base.before_action :set_up_request_echo_headers\n        else\n          base.before_filter :set_up_request_echo_headers\n        end\n      end\n\n      private\n      \n      def set_up_request_echo_headers\n        response.headers['X-Up-Location'] = up.request_url_without_up_params\n        response.headers['X-Up-Method'] = request.method\n      end\n\n      ::ActionController::Base.send(:include, self)\n\n    end\n  end\nend\n", "describe Unpoly::Rails::Controller, type: :request do\n\n  def controller_eval(headers: {}, &expression)\n    BindingTestController.next_eval_proc = expression\n    get '/binding_test/eval', params: {}, headers: headers\n    if (error = controller.eval_error)\n      raise error\n    else\n      controller.eval_result\n    end\n  end\n\n  matcher :match_json do |expected|\n    match do |actual_json|\n      # Convert to JSON to stringify keys in arrays\n      expected = expected.to_json unless expected.is_a?(String)\n      expected_parsed = JSON.parse(expected)\n      expect(actual_json).to be_a(String)\n      actual_parsed = JSON.parse(actual_json)\n      expect(actual_parsed).to eq(expected_parsed)\n    end\n  end\n\n  matcher :expose_helper_method do |helper_name|\n    match do |controller_class|\n      # The helper_method macro defines a method for the controller._helpers module.\n      # This module is eventually included in views.\n      # https://github.com/rails/rails/blob/157920aead96865e3135f496c09ace607d5620dc/actionpack/lib/abstract_controller/helpers.rb#L60\n      helper_module = controller_class._helpers\n      view_like_klass = Class.new { include helper_module }\n      view_like = view_like_klass.new\n      expect(view_like).to respond_to(helper_name)\n    end\n  end\n\n  shared_examples_for 'time field' do |reader:, header:|\n    it \"returns the value of the #{header} request header, parsed from epoch seconds to a Time object\" do\n      result = controller_eval(headers: { header => '1608714891' }, &reader)\n      expect(result).to eq(Time.at(1608714891))\n    end\n\n    it \"returns nil if no #{header} request header is set\" do\n      result = controller_eval(&reader)\n      expect(result).to be_nil\n    end\n  end\n\n  shared_examples_for 'string field' do |reader:, header:|\n    it \"returns the value of the #{header} request header\" do\n      result = controller_eval(headers: { header => 'header value' }, &reader)\n      expect(result).to eq('header value')\n    end\n\n    it \"returns nil if no #{header} request header is set\" do\n      result = controller_eval(&reader)\n      expect(result).to be_nil\n    end\n  end\n\n  shared_examples_for 'hash field' do |reader:, header:|\n    it \"returns value of the #{header} request header, parsed as JSON\" do\n      result = controller_eval(headers: { header => '{ \"foo\": \"bar\" }'}, &reader)\n      expect(result).to respond_to(:[])\n      expect(result['foo']).to eq('bar')\n    end\n\n    it \"allows to access the hash with symbol keys instead of string keys\" do\n      result = controller_eval(headers: { header => '{ \"foo\": \"bar\" }'}, &reader)\n      expect(result[:foo]).to eq('bar')\n    end\n\n    it \"returns an empty hash if no #{header} request header is set\" do\n      result = controller_eval(&reader)\n      expect(result.to_h).to eq({})\n    end\n  end\n\n  describe 'up?' do\n\n    it 'is available as a helper method' do\n      expect(BindingTestController).to expose_helper_method(:up?)\n    end\n\n    it 'returns true if the request has an X-Up-Target header' do\n      result = controller_eval(headers: { 'X-Up-Target' => 'body' }) do\n        up?\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns false if the request has no X-Up-Target header' do\n      result = controller_eval do\n        up?\n      end\n      expect(result).to eq(false)\n    end\n\n  end\n\n  describe 'up' do\n\n    it 'is available as a helper method' do\n      expect(BindingTestController).to expose_helper_method(:up?)\n    end\n\n  end\n\n  describe 'up.version' do\n\n    it_behaves_like 'string field',\n      header: 'X-Up-Version',\n      reader: -> { up.version }\n\n  end\n\n  describe 'up.target' do\n\n    it_behaves_like 'string field',\n      header: 'X-Up-Target',\n      reader: -> { up.target }\n\n  end\n\n  describe 'up.target=' do\n\n    it 'sends the given target as an X-Up-Target response header' do\n      controller_eval(headers: { 'X-Up-Target': '.client' }) do\n        up.target = '.server'\n      end\n\n      expect(response.headers['X-Up-Target']).to eq('.server')\n    end\n\n    it \"sends no X-Up-Target header if the target wasn't changed (the client might have something more generic like :main)\" do\n      controller_eval(headers: { 'X-Up-Target': '.client' }) do\n      end\n\n      expect(response.headers['X-Up-Target']).to be_blank\n    end\n\n    it 'sends no X-Up-Target header if the target was set to the existing value from the request' do\n      controller_eval(headers: { 'X-Up-Target': '.client' }) do\n        up.target = '.client'\n      end\n\n      expect(response.headers['X-Up-Target']).to be_blank\n    end\n\n    it 'returns the given target in subsequent calls to up.target' do\n      result = controller_eval(headers: { 'X-Up-Target': '.client' }) do\n        up.target = '.server'\n        up.target\n      end\n\n      expect(result).to eq('.server')\n    end\n\n    it 'returns the given target in subsequent calls to up.fail_target' do\n      result = controller_eval(headers: { 'X-Up-Target': '.client' }) do\n        up.target = '.server'\n        up.fail_target\n      end\n\n      expect(result).to eq('.server')\n    end\n\n  end\n\n  describe 'up.render_nothing' do\n\n    it 'renders an empty response' do\n      controller_eval do\n        up.render_nothing\n      end\n\n      expect(response.body).to be_blank\n    end\n\n    it 'sets an X-Up-Target: :none header to prevent matching errors on the client' do\n      controller_eval do\n        up.render_nothing\n      end\n\n      expect(response.headers['X-Up-Target']).to eq(':none')\n    end\n\n    it 'responds with a 200 OK status' do\n      controller_eval do\n        up.render_nothing\n      end\n\n      expect(response.status).to eq(200)\n    end\n\n    it 'allows to pass a different status code with :status option' do\n      controller_eval do\n        up.render_nothing(status: :bad_request)\n      end\n\n      expect(response.status).to eq(400)\n    end\n\n  end\n\n  describe 'up.fail_target=' do\n\n    it 'is not defined, as the target provided through up.target=() is used for all render cases' do\n      expect do\n        controller_eval(headers: { 'X-Up-Target': '.client' }) do\n          up.fail_target = '.server'\n        end\n      end.to raise_error(NoMethodError)\n\n    end\n\n  end\n\n  describe 'up.fail_target' do\n\n    it_behaves_like 'string field',\n      header: 'X-Up-Fail-Target',\n      reader: -> { up.fail_target }\n\n  end\n\n  describe 'up.target?' do\n\n    it 'returns true if the tested CSS selector is requested via Unpoly' do\n      result = controller_eval(headers: { 'X-Up-Target': '.foo' }) do\n        up.target?('.foo')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns false if Unpoly is requesting another CSS selector' do\n      result = controller_eval(headers: { 'X-Up-Target': '.bar' }) do\n        up.target?('.foo')\n      end\n      expect(result).to eq(false)\n    end\n\n    it 'returns true if the request is not an Unpoly request' do\n      result = controller_eval do\n        up.target?('.foo')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if the request is an Unpoly request, but does not reveal a target for better cacheability' do\n      result = controller_eval(headers: { 'X-Up-Version': '1.0.0' }) do\n        up.target?('.foo')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if testing a custom selector, and Unpoly requests \"body\"' do\n      result = controller_eval(headers: { 'X-Up-Target': 'body' }) do\n        up.target?('foo')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if testing a custom selector, and Unpoly requests \"html\"' do\n      result = controller_eval(headers: { 'X-Up-Target': 'html' }) do\n        up.target?('foo')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if testing \"body\", and Unpoly requests \"html\"' do\n      result = controller_eval(headers: { 'X-Up-Target': 'html' }) do\n        up.target?('body')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if testing \"head\", and Unpoly requests \"html\"' do\n      result = controller_eval( headers: { 'X-Up-Target': 'html' }) do\n        up.target?('head')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns false if the tested CSS selector is \"head\" but Unpoly requests \"body\"' do\n      result = controller_eval(headers: { 'X-Up-Target': 'body' }) do\n        up.target?('head')\n      end\n      expect(result).to eq(false)\n    end\n\n    it 'returns false if the tested CSS selector is \"title\" but Unpoly requests \"body\"' do\n      result = controller_eval(headers: { 'X-Up-Target': 'body' }) do\n        up.target?('title')\n      end\n      expect(result).to eq(false)\n    end\n\n    it 'returns false if the tested CSS selector is \"meta\" but Unpoly requests \"body\"' do\n      result = controller_eval(headers: { 'X-Up-Target': 'body' }) do\n        up.target?('meta')\n      end\n      expect(result).to eq(false)\n    end\n\n    it 'returns true if the tested CSS selector is \"head\", and Unpoly requests \"html\"' do\n      result = controller_eval(headers: { 'X-Up-Target': 'html' }) do\n        up.target?('head')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if the tested CSS selector is \"title\", Unpoly requests \"html\"' do\n      result = controller_eval(headers: { 'X-Up-Target': 'html' }) do\n        up.target?('title')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if the tested CSS selector is \"meta\", and Unpoly requests \"html\"' do\n      result = controller_eval(headers: { 'X-Up-Target': 'html' }) do\n        up.target?('meta')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if the tested CSS selector is included in a comma-separated group of requested selectors' do\n      result = controller_eval(headers: { 'X-Up-Target': '.foo, .bar, .baz' }) do\n        up.target?('.bar')\n      end\n      expect(result).to eq(true)\n    end\n\n\n  end\n\n  describe 'up.fail_target?' do\n\n    it 'returns false if the tested CSS selector only matches the X-Up-Target header' do\n      result = controller_eval(headers: { 'X-Up-Target': '.foo', 'X-Up-Fail-Target': '.bar' }) do\n        up.fail_target?('.foo')\n      end\n      expect(result).to eq(false)\n    end\n\n    it 'returns true if the tested CSS selector matches the X-Up-Fail-Target header' do\n      result = controller_eval(headers: { 'X-Up-Target': '.foo', 'X-Up-Fail-Target': '.bar' }) do\n        up.fail_target?('.bar')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if the request is not an Unpoly request' do\n      result = controller_eval do\n        up.fail_target?('.foo')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if the request is an Unpoly request, but does not reveal a target for better cacheability' do\n      result = controller_eval(headers: { 'X-Up-Version': '1.0.0' }) do\n        up.fail_target?('.foo')\n      end\n      expect(result).to eq(true)\n    end\n\n  end\n\n  describe 'up.any_target?' do\n\n    let :headers do\n      { 'X-Up-Target' => '.success',\n        'X-Up-Fail-Target' => '.failure' }\n    end\n\n    it 'returns true if the tested CSS selector is the target for a successful response' do\n      result = controller_eval(headers: headers) do\n        up.any_target?('.success')\n      end\n      expect(result).to be(true)\n    end\n\n    it 'returns true if the tested CSS selector is the target for a failed response' do\n      result = controller_eval(headers: headers) do\n        up.any_target?('.failure')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns false if the tested CSS selector is a target for neither successful nor failed response' do\n      result = controller_eval(headers: headers) do\n        up.any_target?('.other')\n      end\n      expect(result).to eq(false)\n    end\n\n  end\n\n  describe 'up.validate?' do\n\n    it 'returns true the request is an Unpoly validation call' do\n      result = controller_eval(headers: { 'X-Up-Validate' => 'user[email]' }) do\n        up.validate?\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns false if the request is not an Unpoly validation call' do\n      result = controller_eval do\n        up.validate?\n      end\n      expect(result).to eq(false)\n    end\n\n  end\n\n  describe 'up.validate' do\n\n    it_behaves_like 'string field',\n      header: 'X-Up-Validate',\n      reader: -> { up.validate }\n\n  end\n\n  describe 'up.mode' do\n\n    it_behaves_like 'string field',\n      header: 'X-Up-Mode',\n      reader: -> { up.mode }\n\n  end\n\n  describe 'up.fail_mode' do\n\n    it_behaves_like 'string field',\n      header: 'X-Up-Fail-Mode',\n      reader: -> { up.fail_mode }\n\n  end\n\n  describe 'up.context' do\n\n    it_behaves_like 'hash field',\n      header: 'X-Up-Context',\n      reader: -> { up.context }\n\n  end\n\n  describe 'up.context[]=' do\n\n    it 'sends a changed context hash as an X-Up-Context response header' do\n      controller_eval(headers: { 'X-Up-Context': { 'foo': 'fooValue' }.to_json }) do\n        up.context[:bar] = 'barValue'\n      end\n\n      expect(response.headers['X-Up-Context']).to match_json(bar: 'barValue')\n    end\n\n    it 'escapes high-ASCII characters in the header value, so we can transport it over HTTP' do\n      controller_eval(headers: { 'X-Up-Context': { 'foo': 'fooValue' }.to_json }) do\n        up.context[:bar] = 'x\u00e4y'\n      end\n\n      expect(response.headers['X-Up-Context']).to match_json('{\"bar\": \"x\\\\u00e4y\"}')\n    end\n\n    it 'changes the value for subsequent calls of up.context[]' do\n      value = controller_eval do\n        up.context[:bar] = 'barValue'\n        up.context[:bar]\n      end\n\n      expect(value).to eq('barValue')\n    end\n\n    it 'changes the value for subsequent calls of up.fail_context[], since context updates will be applied to whatever layer ends up being updated' do\n      value = controller_eval do\n        up.context[:bar] = 'barValue'\n        up.fail_context[:bar]\n      end\n\n      expect(value).to eq('barValue')\n    end\n\n    it 'does not send an X-Up-Context response header if the context did not change' do\n      controller_eval(headers: { 'X-Up-Context': { foo: 'fooValue' }.to_json }) do\n      end\n\n      expect(response.headers['X-Up-Context']).to be_nil\n    end\n\n    it 'sends mutated sub-arrays as an X-Up-Context response header' do\n      controller_eval(headers: { 'X-Up-Context': { foo: [1, 2, 3] }.to_json }) do\n        up.context[:foo] << 4\n      end\n\n      expect(response.headers['X-Up-Context']).to match_json(foo: [1, 2, 3, 4])\n    end\n\n    it 'sends mutated sub-hashes as an X-Up-Context response header' do\n      controller_eval(headers: { 'X-Up-Context': { foo: { bar: 'barValue'} }.to_json }) do\n        up.context[:foo][:baz] = 'bazValue'\n      end\n\n      expect(response.headers['X-Up-Context']).to match_json(foo: { bar: 'barValue', baz: 'bazValue' })\n    end\n\n  end\n\n  describe 'up.context.replace' do\n\n    it 'replaces the entire context on the client' do\n      controller_eval do\n        up.context.replace(foo: 'fooValue')\n      end\n\n      expect(response.headers['X-Up-Context']).to match_json(foo: 'fooValue')\n    end\n\n    it 'nilifies keys that no longer exist (since the frontend merges)' do\n      controller_eval(headers: { 'X-Up-Context': { 'foo': 'fooValue' }.to_json }) do\n        up.context.replace(bar: 'barValue')\n      end\n\n      expect(response.headers['X-Up-Context']).to match_json(foo: nil, bar: 'barValue')\n    end\n\n  end\n\n  describe 'up.context.delete' do\n\n    it 'updates the key with a null value' do\n      controller_eval(headers: { 'X-Up-Context': { 'foo': 'fooValue' }.to_json }) do\n        up.context.delete(:foo)\n      end\n\n      expect(response.headers['X-Up-Context']).to match_json(foo: nil)\n    end\n\n  end\n\n  describe 'up.fail_context' do\n\n    subject { controller.up.fail_context }\n\n    it_behaves_like 'hash field',\n      header: 'X-Up-Fail-Context',\n      reader: -> { up.fail_context }\n\n  end\n\n  describe 'up.fail_context[]=' do\n\n    it 'sends a changed context hash as an X-Up-Context response header' do\n      controller_eval(headers: { 'X-Up-Context': { 'foo': 'fooValue' }.to_json }) do\n        up.fail_context[:bar] = 'barValue'\n      end\n\n      expect(response.headers['X-Up-Context']).to match_json(\n        bar: 'barValue'\n      )\n    end\n\n    it 'changes the value for subsequent calls of up.fail_context[]' do\n      value = controller_eval do\n        up.fail_context[:bar] = 'barValue'\n        up.fail_context[:bar]\n      end\n\n      expect(value).to eq('barValue')\n    end\n\n    it 'changes the value for subsequent calls of up.context[], since context updates will be applied to whatever layer ends up being updated' do\n      value = controller_eval do\n        up.fail_context[:bar] = 'barValue'\n        up.context[:bar]\n      end\n\n      expect(value).to eq('barValue')\n    end\n\n    it 'sends mutated sub-arrays as an X-Up-Context response header' do\n      controller_eval(headers: { 'X-Up-Fail-Context': { foo: [1, 2, 3] }.to_json }) do\n        up.fail_context[:foo] << 4\n      end\n\n      expect(response.headers['X-Up-Context']).to match_json(foo: [1, 2, 3, 4])\n    end\n\n    it 'sends mutated sub-hashes as an X-Up-Context response header' do\n      controller_eval(headers: { 'X-Up-Fail-Context': { foo: { bar: 'barValue'} }.to_json }) do\n        up.fail_context[:foo][:baz] = 'bazValue'\n      end\n\n      expect(response.headers['X-Up-Context']).to match_json(foo: { bar: 'barValue', baz: 'bazValue' })\n    end\n\n  end\n\n  describe 'up.cache.clear' do\n\n    it 'sets an `X-Up-Clear-Cache: *` header' do\n      controller_eval do\n        up.cache.clear\n      end\n\n      expect(response.headers['X-Up-Clear-Cache']).to eq('*')\n    end\n\n    it 'sets an X-Up-Clear-Cache header with the given URL pattern' do\n      controller_eval do\n        up.cache.clear('/foo/*')\n      end\n\n      expect(response.headers['X-Up-Clear-Cache']).to eq('/foo/*')\n   end\n\n  end\n\n  describe 'up.cache.keep' do\n\n    it 'sets an `X-Up-Clear-Cache: false` header' do\n      controller_eval do\n        up.cache.keep\n      end\n\n      expect(response.headers['X-Up-Clear-Cache']).to eq('false')\n    end\n\n  end\n\n  describe 'up.emit' do\n\n    it 'adds an entry into the X-Up-Events response header' do\n      controller_eval do\n        up.emit('my:event', { 'foo' => 'bar' })\n      end\n\n      expect(response.headers['X-Up-Events']).to match_json([\n        { type: 'my:event', foo: 'bar' }\n      ])\n    end\n\n    it 'adds multiple entries to the X-Up-Events response headers' do\n      controller_eval do\n        up.emit('my:event', { 'foo' => 'bar' })\n        up.emit('other:event', { 'bam' => 'baz' })\n      end\n\n      expect(response.headers['X-Up-Events']).to match_json([\n        { foo: 'bar', type: 'my:event' },\n        { bam: 'baz', type: 'other:event' }\n      ])\n    end\n\n    it 'escapes high-ASCII characters in the header value, so we can transport it over HTTP' do\n      controller_eval(headers: { 'X-Up-Mode': 'modal' }) do\n        up.layer.accept('x\u00e4y')\n      end\n\n      controller_eval do\n        up.emit('my:event', { 'foo' => 'x\u00e4y' })\n      end\n\n      expect(response.headers['X-Up-Events']).to eq('[{\"foo\":\"x\\\\u00e4y\",\"type\":\"my:event\"}]')\n    end\n\n  end\n\n  describe 'up.layer.emit' do\n\n    it 'adds an entry into the X-Up-Events response header with { layer: \"current\" } option' do\n      controller_eval do\n        up.layer.emit('my:event', { 'foo' => 'bar' })\n      end\n\n      expect(response.headers['X-Up-Events']).to match_json([\n        { type: 'my:event', foo: 'bar', layer: 'current' }\n      ])\n    end\n\n  end\n\n  describe 'up.layer.mode' do\n\n    it 'returns the value of the X-Up-Mode header' do\n      result = controller_eval(headers: { 'X-Up-Mode': 'foo' }) do\n        up.layer.mode\n      end\n      expect(result).to eq('foo')\n    end\n\n  end\n\n  describe 'up.layer.root?' do\n\n    it 'returns true if the X-Up-Mode header is \"root\"' do\n      result = controller_eval(headers: { 'X-Up-Mode': 'root' }) do\n        up.layer.root?\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if the request is a full page load without Unpoly (which always replaces the entire page)' do\n      result = controller_eval do\n        up.layer.root?\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if the frontend does not reveal its mode for better cacheability' do\n      result = controller_eval(headers: { 'X-Up-Version': '1.0.0' }) do\n        up.layer.root?\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns false if the X-Up-Mode header is not \"root\"' do\n      result = controller_eval(headers: { 'X-Up-Mode': 'drawer' }) do\n        up.layer.root?\n      end\n      expect(result).to eq(false)\n    end\n\n  end\n\n  describe 'up.layer.overlay?' do\n\n    it 'returns true if the X-Up-Mode header is \"overlay\"' do\n      result = controller_eval(headers: { 'X-Up-Mode': 'overlay' }) do\n        up.layer.overlay?\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns false if the request is a full page load (which always replaces the entire page)' do\n      result = controller_eval do\n        up.layer.overlay?\n      end\n      expect(result).to eq(false)\n    end\n\n    it 'returns false if the X-Up-Mode header is \"root\"' do\n      result = controller_eval(headers: { 'X-Up-Mode': 'root' }) do\n        up.layer.overlay?\n      end\n      expect(result).to eq(false)\n    end\n\n  end\n\n  describe 'up.layer.context' do\n\n    it 'returns the parsed JSON object from the X-Up-Context header' do\n      result = controller_eval(headers: { 'X-Up-Context': { 'foo' => 'bar' }.to_json}) do\n        up.layer.context.to_h\n      end\n      expect(result).to eq('foo' => 'bar')\n    end\n\n  end\n\n  describe 'up.layer.accept' do\n\n    it 'sets an X-Up-Accept-Layer response header with the given value' do\n      controller_eval(headers: { 'X-Up-Mode': 'modal' }) do\n        up.layer.accept('foo')\n      end\n\n      expect(response.headers['X-Up-Accept-Layer']).to eq('\"foo\"')\n    end\n\n    it 'sets an X-Up-Accept-Layer response header with a null value if no value is given' do\n      controller_eval(headers: { 'X-Up-Mode': 'modal' }) do\n        up.layer.accept\n      end\n\n      expect(response.headers['X-Up-Accept-Layer']).to eq('null')\n    end\n\n    it 'raises an error when updating the root layer' do\n      accept_root = lambda do\n        controller_eval(headers: { 'X-Up-Mode': 'root' }) do\n          up.layer.accept('foo')\n        end\n      end\n\n      expect(accept_root).to raise_error(/cannot accept/i)\n    end\n\n    it 'escapes high-ASCII characters in the header value, so we can transport it over HTTP' do\n      controller_eval(headers: { 'X-Up-Mode': 'modal' }) do\n        up.layer.accept('x\u00e4y')\n      end\n\n      expect(response.headers['X-Up-Accept-Layer']).to eq('\"x\\\\u00e4y\"')\n    end\n\n  end\n\n  describe 'up.layer.dismiss' do\n\n    it 'sets an X-Up-Dismiss-Layer response header with the given value' do\n      controller_eval(headers: { 'X-Up-Mode': 'modal' }) do\n        up.layer.dismiss('foo')\n      end\n\n      expect(response.headers['X-Up-Dismiss-Layer']).to eq('\"foo\"')\n    end\n\n    it 'sets an X-Up-Dismiss-Layer response header with a null value if no value is given' do\n      controller_eval(headers: { 'X-Up-Mode': 'modal' }) do\n        up.layer.dismiss\n      end\n\n      expect(response.headers['X-Up-Dismiss-Layer']).to eq('null')\n    end\n\n    it 'raises an error when updating the root layer' do\n      dismiss_root = lambda do\n        controller_eval(headers: { 'X-Up-Mode': 'root' }) do\n          up.layer.dismiss('foo')\n        end\n      end\n\n      expect(dismiss_root).to raise_error(/cannot dismiss/i)\n    end\n\n    it 'escapes high-ASCII characters in the header value, so we can transport it over HTTP' do\n      controller_eval(headers: { 'X-Up-Mode': 'modal' }) do\n        up.layer.dismiss('x\u00e4y')\n      end\n\n      expect(response.headers['X-Up-Dismiss-Layer']).to eq('\"x\\\\u00e4y\"')\n    end\n\n  end\n\n  describe 'up.fail_layer.mode' do\n\n    it 'returns the value of the X-Up-Fail-Mode header' do\n      result = controller_eval(headers: { 'X-Up-Fail-Mode': 'foo' }) do\n        up.fail_layer.mode\n      end\n      expect(result).to eq('foo')\n    end\n\n  end\n\n  describe 'up.fail_layer.root?' do\n\n    it 'returns true if the X-Up-Fail-Mode header is \"root\"' do\n      result = controller_eval(headers: { 'X-Up-Fail-Mode': 'root' }) do\n        up.fail_layer.root?\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if the request is a full page load (which always replaces the entire page)' do\n      result = controller_eval do\n        up.fail_layer.root?\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns false if the X-Up-Fail-Mode header is not \"root\"' do\n      result = controller_eval(headers: { 'X-Up-Fail-Mode': 'drawer' }) do\n        up.fail_layer.root?\n      end\n      expect(result).to eq(false)\n    end\n\n  end\n\n  describe 'up.fail_layer.overlay?' do\n\n    it 'returns true if the X-Up-Fail-Mode header is \"overlay\"' do\n      result = controller_eval(headers: { 'X-Up-Fail-Mode': 'overlay' }) do\n        up.fail_layer.overlay?\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns false if the request is a full page load (which always replaces the entire page)' do\n      result = controller_eval do\n        up.fail_layer.overlay?\n      end\n      expect(result).to eq(false)\n    end\n\n    it 'returns false if the X-Up-Fail-Mode header is \"root\"' do\n      result = controller_eval(headers: { 'X-Up-Fail-Mode': 'root' }) do\n        up.fail_layer.overlay?\n      end\n      expect(result).to eq(false)\n    end\n\n  end\n\n  describe 'up.fail_layer.context' do\n\n    it 'returns the parsed JSON object from the X-Up-Fail-Context header' do\n      result = controller_eval(headers: { 'X-Up-Fail-Context': { 'foo' => 'bar' }.to_json}) do\n        up.fail_layer.context.to_h\n      end\n      expect(result).to eq('foo' => 'bar')\n    end\n\n  end\n\n  describe 'up.title=' do\n\n    it 'sets an X-Up-Title header to push a document title to the client' do\n      controller_eval do\n        up.title = 'Title from controller'\n      end\n      expect(response.headers['X-Up-Title']).to eq('Title from controller')\n    end\n\n  end\n\n  describe 'up.reload_from_time' do\n\n    include_examples 'time field',\n      header: 'X-Up-Reload-From-Time',\n      reader: -> { up.reload_from_time }\n\n  end\n\n  describe 'up.reload?' do\n\n    it 'returns true if an X-Up-Reload-From-Time header is given' do\n      result = controller_eval(headers: { 'X-Up-Reload-From-Time': '1608714891' }) do\n        up.reload?\n      end\n\n      expect(result).to eq(true)\n    end\n\n    it 'returns false if no X-Up-Reload-From-Time header is given' do\n      result = controller_eval do\n        up.reload?\n      end\n\n      expect(result).to eq(false)\n    end\n\n  end\n\n  describe 'up.safe_callback' do\n\n    it 'prepends the CSP nonce to the given JavaScript string' do\n      result = controller_eval do\n        up.safe_callback('alert()')\n      end\n\n      expect(result).to eq('nonce-secret alert()')\n    end\n\n  end\n\n  describe 'redirect_to' do\n\n    it 'preserves Unpoly-related headers for the redirect' do\n      get '/binding_test/redirect1', headers: { 'X-Up-Target' => '.foo' }\n      expect(response).to be_redirect\n      follow_redirect!\n      expect(response.body).to eq('.foo')\n      expect(response.headers['X-Up-Events']).to match_json([\n        { type: 'event1' }\n      ])\n      expect(response.headers['X-Up-Clear-Cache']).to eq('*')\n    end\n\n    it 'preserves Unpoly-releated headers over multiple redirects' do\n      get '/binding_test/redirect0', headers: { 'X-Up-Target' => '.foo' }\n      expect(response).to be_redirect\n      follow_redirect!\n      expect(response).to be_redirect\n      follow_redirect!\n      expect(response.body).to eq('.foo')\n      expect(response.headers['X-Up-Events']).to match_json([\n        { type: 'event0' },\n        { type: 'event1' },\n      ])\n    end\n\n    it 'does not change the history' do\n      get '/binding_test/redirect1', headers: { 'X-Up-Target' => '.foo' }\n      expect(response).to be_redirect\n      follow_redirect!\n      expect(response.headers['X-Up-Location']).to end_with('/redirect2')\n    end\n\n  end\n\n  describe 'echoing of the request location' do\n\n    it 'echoes the current path in an X-Up-Location response header' do\n      get '/binding_test/text'\n      expect(response.headers['X-Up-Location']).to end_with('/binding_test/text')\n    end\n\n    it 'echoes the current path after a redirect' do\n      get '/binding_test/redirect1'\n      expect(response).to be_redirect\n      follow_redirect!\n      expect(response.headers['X-Up-Location']).to end_with('/binding_test/redirect2')\n    end\n\n    it 'echoes the current path with query params' do\n      get '/binding_test/text?foo=bar'\n      expect(response.headers['X-Up-Location']).to end_with('/binding_test/text?foo=bar')\n    end\n\n    it 'removes _up-* params' do\n      get '/binding_test/text?_up_1=x&foo=bar&_up_2=y'\n      expect(response.headers['X-Up-Location']).to end_with('/binding_test/text?foo=bar')\n    end\n\n    it 'does not mangle array params (BUGFIX)' do\n      get '/binding_test/text?foo%5B%5D=bar&foo%5B%5D=qux&_up_location=up_location'\n      expect(response.headers['X-Up-Location']).to end_with('/binding_test/text?foo%5B%5D=bar&foo%5B%5D=qux')\n    end\n\n  end\n\n  describe 'echoing of the request method' do\n\n    it 'echoes the current request method in an X-Up-Method response header' do\n      get '/binding_test/text'\n      expect(response.headers['X-Up-Method']).to eq('GET')\n    end\n\n    it 'echoes the current path after a redirect' do\n      put '/binding_test/redirect1'\n      expect(response).to be_redirect\n      follow_redirect!\n      expect(response.headers['X-Up-Method']).to eq('GET')\n    end\n\n    it 'echoes a non-GET request method' do\n      put '/binding_test/text'\n      expect(response.headers['X-Up-Method']).to eq('PUT')\n    end\n\n  end\n\n  describe 'request method cookie' do\n\n    describe 'if the request is both non-GET and not a fragment update' do\n\n      it 'echoes the request method in an _up_method cookie ' do\n        put '/binding_test/text'\n        expect(cookies['_up_method']).to eq('PUT')\n      end\n\n    end\n\n    describe 'if the request is not a fragment update, but GET' do\n\n      it 'does not set the cookie' do\n        get '/binding_test/text'\n        expect(cookies['_up_method']).to be_blank\n      end\n\n      it 'deletes an existing cookie' do\n        cookies['_up_method'] = 'PUT'\n        get '/binding_test/text'\n        expect(cookies['_up_method']).to be_blank\n      end\n\n    end\n\n    describe 'if the request is non-GET but a fragment update' do\n\n      it 'does not set the cookie' do\n        get '/binding_test/text', headers: { 'X-Up-Target' => '.target '}\n        expect(cookies['_up_method']).to be_blank\n      end\n\n      it 'deletes an existing cookie' do\n        cookies['_up_method'] = 'PUT'\n        get '/binding_test/text', headers: { 'X-Up-Target' => '.target' }\n        expect(cookies['_up_method']).to be_blank\n      end\n\n    end\n\n  end\n\nend\n\n"], "fixing_code": ["module Unpoly\n  module Rails\n    ##\n    # Installs a `before_action` into all controllers which echoes the\n    # request's URL as a response header `X-Up-Location` and the request's\n    # HTTP method as `X-Up-Method`.\n    #\n    # The Unpoly frontend requires these headers to detect redirects,\n    # which are otherwise undetectable for an AJAX client.\n    module RequestEchoHeaders\n\n      def self.included(base)\n        if base.respond_to?(:before_action)\n          base.before_action :set_up_request_echo_headers\n        else\n          base.before_filter :set_up_request_echo_headers\n        end\n      end\n\n      private\n\n      def set_up_request_echo_headers\n        request_url_without_up_params = up.request_url_without_up_params\n        unless request_url_without_up_params == request.original_url\n          response.headers['X-Up-Location'] = up.request_url_without_up_params\n        end\n\n        response.headers['X-Up-Method'] = request.method\n      end\n\n      ::ActionController::Base.send(:include, self)\n\n    end\n  end\nend\n", "describe Unpoly::Rails::Controller, type: :request do\n\n  def controller_eval(headers: {}, &expression)\n    BindingTestController.next_eval_proc = expression\n    get '/binding_test/eval', params: {}, headers: headers\n    if (error = controller.eval_error)\n      raise error\n    else\n      controller.eval_result\n    end\n  end\n\n  matcher :match_json do |expected|\n    match do |actual_json|\n      # Convert to JSON to stringify keys in arrays\n      expected = expected.to_json unless expected.is_a?(String)\n      expected_parsed = JSON.parse(expected)\n      expect(actual_json).to be_a(String)\n      actual_parsed = JSON.parse(actual_json)\n      expect(actual_parsed).to eq(expected_parsed)\n    end\n  end\n\n  matcher :expose_helper_method do |helper_name|\n    match do |controller_class|\n      # The helper_method macro defines a method for the controller._helpers module.\n      # This module is eventually included in views.\n      # https://github.com/rails/rails/blob/157920aead96865e3135f496c09ace607d5620dc/actionpack/lib/abstract_controller/helpers.rb#L60\n      helper_module = controller_class._helpers\n      view_like_klass = Class.new { include helper_module }\n      view_like = view_like_klass.new\n      expect(view_like).to respond_to(helper_name)\n    end\n  end\n\n  shared_examples_for 'time field' do |reader:, header:|\n    it \"returns the value of the #{header} request header, parsed from epoch seconds to a Time object\" do\n      result = controller_eval(headers: { header => '1608714891' }, &reader)\n      expect(result).to eq(Time.at(1608714891))\n    end\n\n    it \"returns nil if no #{header} request header is set\" do\n      result = controller_eval(&reader)\n      expect(result).to be_nil\n    end\n  end\n\n  shared_examples_for 'string field' do |reader:, header:|\n    it \"returns the value of the #{header} request header\" do\n      result = controller_eval(headers: { header => 'header value' }, &reader)\n      expect(result).to eq('header value')\n    end\n\n    it \"returns nil if no #{header} request header is set\" do\n      result = controller_eval(&reader)\n      expect(result).to be_nil\n    end\n  end\n\n  shared_examples_for 'hash field' do |reader:, header:|\n    it \"returns value of the #{header} request header, parsed as JSON\" do\n      result = controller_eval(headers: { header => '{ \"foo\": \"bar\" }'}, &reader)\n      expect(result).to respond_to(:[])\n      expect(result['foo']).to eq('bar')\n    end\n\n    it \"allows to access the hash with symbol keys instead of string keys\" do\n      result = controller_eval(headers: { header => '{ \"foo\": \"bar\" }'}, &reader)\n      expect(result[:foo]).to eq('bar')\n    end\n\n    it \"returns an empty hash if no #{header} request header is set\" do\n      result = controller_eval(&reader)\n      expect(result.to_h).to eq({})\n    end\n  end\n\n  describe 'up?' do\n\n    it 'is available as a helper method' do\n      expect(BindingTestController).to expose_helper_method(:up?)\n    end\n\n    it 'returns true if the request has an X-Up-Target header' do\n      result = controller_eval(headers: { 'X-Up-Target' => 'body' }) do\n        up?\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns false if the request has no X-Up-Target header' do\n      result = controller_eval do\n        up?\n      end\n      expect(result).to eq(false)\n    end\n\n  end\n\n  describe 'up' do\n\n    it 'is available as a helper method' do\n      expect(BindingTestController).to expose_helper_method(:up?)\n    end\n\n  end\n\n  describe 'up.version' do\n\n    it_behaves_like 'string field',\n      header: 'X-Up-Version',\n      reader: -> { up.version }\n\n  end\n\n  describe 'up.target' do\n\n    it_behaves_like 'string field',\n      header: 'X-Up-Target',\n      reader: -> { up.target }\n\n  end\n\n  describe 'up.target=' do\n\n    it 'sends the given target as an X-Up-Target response header' do\n      controller_eval(headers: { 'X-Up-Target': '.client' }) do\n        up.target = '.server'\n      end\n\n      expect(response.headers['X-Up-Target']).to eq('.server')\n    end\n\n    it \"sends no X-Up-Target header if the target wasn't changed (the client might have something more generic like :main)\" do\n      controller_eval(headers: { 'X-Up-Target': '.client' }) do\n      end\n\n      expect(response.headers['X-Up-Target']).to be_blank\n    end\n\n    it 'sends no X-Up-Target header if the target was set to the existing value from the request' do\n      controller_eval(headers: { 'X-Up-Target': '.client' }) do\n        up.target = '.client'\n      end\n\n      expect(response.headers['X-Up-Target']).to be_blank\n    end\n\n    it 'returns the given target in subsequent calls to up.target' do\n      result = controller_eval(headers: { 'X-Up-Target': '.client' }) do\n        up.target = '.server'\n        up.target\n      end\n\n      expect(result).to eq('.server')\n    end\n\n    it 'returns the given target in subsequent calls to up.fail_target' do\n      result = controller_eval(headers: { 'X-Up-Target': '.client' }) do\n        up.target = '.server'\n        up.fail_target\n      end\n\n      expect(result).to eq('.server')\n    end\n\n  end\n\n  describe 'up.render_nothing' do\n\n    it 'renders an empty response' do\n      controller_eval do\n        up.render_nothing\n      end\n\n      expect(response.body).to be_blank\n    end\n\n    it 'sets an X-Up-Target: :none header to prevent matching errors on the client' do\n      controller_eval do\n        up.render_nothing\n      end\n\n      expect(response.headers['X-Up-Target']).to eq(':none')\n    end\n\n    it 'responds with a 200 OK status' do\n      controller_eval do\n        up.render_nothing\n      end\n\n      expect(response.status).to eq(200)\n    end\n\n    it 'allows to pass a different status code with :status option' do\n      controller_eval do\n        up.render_nothing(status: :bad_request)\n      end\n\n      expect(response.status).to eq(400)\n    end\n\n  end\n\n  describe 'up.fail_target=' do\n\n    it 'is not defined, as the target provided through up.target=() is used for all render cases' do\n      expect do\n        controller_eval(headers: { 'X-Up-Target': '.client' }) do\n          up.fail_target = '.server'\n        end\n      end.to raise_error(NoMethodError)\n\n    end\n\n  end\n\n  describe 'up.fail_target' do\n\n    it_behaves_like 'string field',\n      header: 'X-Up-Fail-Target',\n      reader: -> { up.fail_target }\n\n  end\n\n  describe 'up.target?' do\n\n    it 'returns true if the tested CSS selector is requested via Unpoly' do\n      result = controller_eval(headers: { 'X-Up-Target': '.foo' }) do\n        up.target?('.foo')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns false if Unpoly is requesting another CSS selector' do\n      result = controller_eval(headers: { 'X-Up-Target': '.bar' }) do\n        up.target?('.foo')\n      end\n      expect(result).to eq(false)\n    end\n\n    it 'returns true if the request is not an Unpoly request' do\n      result = controller_eval do\n        up.target?('.foo')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if the request is an Unpoly request, but does not reveal a target for better cacheability' do\n      result = controller_eval(headers: { 'X-Up-Version': '1.0.0' }) do\n        up.target?('.foo')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if testing a custom selector, and Unpoly requests \"body\"' do\n      result = controller_eval(headers: { 'X-Up-Target': 'body' }) do\n        up.target?('foo')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if testing a custom selector, and Unpoly requests \"html\"' do\n      result = controller_eval(headers: { 'X-Up-Target': 'html' }) do\n        up.target?('foo')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if testing \"body\", and Unpoly requests \"html\"' do\n      result = controller_eval(headers: { 'X-Up-Target': 'html' }) do\n        up.target?('body')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if testing \"head\", and Unpoly requests \"html\"' do\n      result = controller_eval( headers: { 'X-Up-Target': 'html' }) do\n        up.target?('head')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns false if the tested CSS selector is \"head\" but Unpoly requests \"body\"' do\n      result = controller_eval(headers: { 'X-Up-Target': 'body' }) do\n        up.target?('head')\n      end\n      expect(result).to eq(false)\n    end\n\n    it 'returns false if the tested CSS selector is \"title\" but Unpoly requests \"body\"' do\n      result = controller_eval(headers: { 'X-Up-Target': 'body' }) do\n        up.target?('title')\n      end\n      expect(result).to eq(false)\n    end\n\n    it 'returns false if the tested CSS selector is \"meta\" but Unpoly requests \"body\"' do\n      result = controller_eval(headers: { 'X-Up-Target': 'body' }) do\n        up.target?('meta')\n      end\n      expect(result).to eq(false)\n    end\n\n    it 'returns true if the tested CSS selector is \"head\", and Unpoly requests \"html\"' do\n      result = controller_eval(headers: { 'X-Up-Target': 'html' }) do\n        up.target?('head')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if the tested CSS selector is \"title\", Unpoly requests \"html\"' do\n      result = controller_eval(headers: { 'X-Up-Target': 'html' }) do\n        up.target?('title')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if the tested CSS selector is \"meta\", and Unpoly requests \"html\"' do\n      result = controller_eval(headers: { 'X-Up-Target': 'html' }) do\n        up.target?('meta')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if the tested CSS selector is included in a comma-separated group of requested selectors' do\n      result = controller_eval(headers: { 'X-Up-Target': '.foo, .bar, .baz' }) do\n        up.target?('.bar')\n      end\n      expect(result).to eq(true)\n    end\n\n\n  end\n\n  describe 'up.fail_target?' do\n\n    it 'returns false if the tested CSS selector only matches the X-Up-Target header' do\n      result = controller_eval(headers: { 'X-Up-Target': '.foo', 'X-Up-Fail-Target': '.bar' }) do\n        up.fail_target?('.foo')\n      end\n      expect(result).to eq(false)\n    end\n\n    it 'returns true if the tested CSS selector matches the X-Up-Fail-Target header' do\n      result = controller_eval(headers: { 'X-Up-Target': '.foo', 'X-Up-Fail-Target': '.bar' }) do\n        up.fail_target?('.bar')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if the request is not an Unpoly request' do\n      result = controller_eval do\n        up.fail_target?('.foo')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if the request is an Unpoly request, but does not reveal a target for better cacheability' do\n      result = controller_eval(headers: { 'X-Up-Version': '1.0.0' }) do\n        up.fail_target?('.foo')\n      end\n      expect(result).to eq(true)\n    end\n\n  end\n\n  describe 'up.any_target?' do\n\n    let :headers do\n      { 'X-Up-Target' => '.success',\n        'X-Up-Fail-Target' => '.failure' }\n    end\n\n    it 'returns true if the tested CSS selector is the target for a successful response' do\n      result = controller_eval(headers: headers) do\n        up.any_target?('.success')\n      end\n      expect(result).to be(true)\n    end\n\n    it 'returns true if the tested CSS selector is the target for a failed response' do\n      result = controller_eval(headers: headers) do\n        up.any_target?('.failure')\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns false if the tested CSS selector is a target for neither successful nor failed response' do\n      result = controller_eval(headers: headers) do\n        up.any_target?('.other')\n      end\n      expect(result).to eq(false)\n    end\n\n  end\n\n  describe 'up.validate?' do\n\n    it 'returns true the request is an Unpoly validation call' do\n      result = controller_eval(headers: { 'X-Up-Validate' => 'user[email]' }) do\n        up.validate?\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns false if the request is not an Unpoly validation call' do\n      result = controller_eval do\n        up.validate?\n      end\n      expect(result).to eq(false)\n    end\n\n  end\n\n  describe 'up.validate' do\n\n    it_behaves_like 'string field',\n      header: 'X-Up-Validate',\n      reader: -> { up.validate }\n\n  end\n\n  describe 'up.mode' do\n\n    it_behaves_like 'string field',\n      header: 'X-Up-Mode',\n      reader: -> { up.mode }\n\n  end\n\n  describe 'up.fail_mode' do\n\n    it_behaves_like 'string field',\n      header: 'X-Up-Fail-Mode',\n      reader: -> { up.fail_mode }\n\n  end\n\n  describe 'up.context' do\n\n    it_behaves_like 'hash field',\n      header: 'X-Up-Context',\n      reader: -> { up.context }\n\n  end\n\n  describe 'up.context[]=' do\n\n    it 'sends a changed context hash as an X-Up-Context response header' do\n      controller_eval(headers: { 'X-Up-Context': { 'foo': 'fooValue' }.to_json }) do\n        up.context[:bar] = 'barValue'\n      end\n\n      expect(response.headers['X-Up-Context']).to match_json(bar: 'barValue')\n    end\n\n    it 'escapes high-ASCII characters in the header value, so we can transport it over HTTP' do\n      controller_eval(headers: { 'X-Up-Context': { 'foo': 'fooValue' }.to_json }) do\n        up.context[:bar] = 'x\u00e4y'\n      end\n\n      expect(response.headers['X-Up-Context']).to match_json('{\"bar\": \"x\\\\u00e4y\"}')\n    end\n\n    it 'changes the value for subsequent calls of up.context[]' do\n      value = controller_eval do\n        up.context[:bar] = 'barValue'\n        up.context[:bar]\n      end\n\n      expect(value).to eq('barValue')\n    end\n\n    it 'changes the value for subsequent calls of up.fail_context[], since context updates will be applied to whatever layer ends up being updated' do\n      value = controller_eval do\n        up.context[:bar] = 'barValue'\n        up.fail_context[:bar]\n      end\n\n      expect(value).to eq('barValue')\n    end\n\n    it 'does not send an X-Up-Context response header if the context did not change' do\n      controller_eval(headers: { 'X-Up-Context': { foo: 'fooValue' }.to_json }) do\n      end\n\n      expect(response.headers['X-Up-Context']).to be_nil\n    end\n\n    it 'sends mutated sub-arrays as an X-Up-Context response header' do\n      controller_eval(headers: { 'X-Up-Context': { foo: [1, 2, 3] }.to_json }) do\n        up.context[:foo] << 4\n      end\n\n      expect(response.headers['X-Up-Context']).to match_json(foo: [1, 2, 3, 4])\n    end\n\n    it 'sends mutated sub-hashes as an X-Up-Context response header' do\n      controller_eval(headers: { 'X-Up-Context': { foo: { bar: 'barValue'} }.to_json }) do\n        up.context[:foo][:baz] = 'bazValue'\n      end\n\n      expect(response.headers['X-Up-Context']).to match_json(foo: { bar: 'barValue', baz: 'bazValue' })\n    end\n\n  end\n\n  describe 'up.context.replace' do\n\n    it 'replaces the entire context on the client' do\n      controller_eval do\n        up.context.replace(foo: 'fooValue')\n      end\n\n      expect(response.headers['X-Up-Context']).to match_json(foo: 'fooValue')\n    end\n\n    it 'nilifies keys that no longer exist (since the frontend merges)' do\n      controller_eval(headers: { 'X-Up-Context': { 'foo': 'fooValue' }.to_json }) do\n        up.context.replace(bar: 'barValue')\n      end\n\n      expect(response.headers['X-Up-Context']).to match_json(foo: nil, bar: 'barValue')\n    end\n\n  end\n\n  describe 'up.context.delete' do\n\n    it 'updates the key with a null value' do\n      controller_eval(headers: { 'X-Up-Context': { 'foo': 'fooValue' }.to_json }) do\n        up.context.delete(:foo)\n      end\n\n      expect(response.headers['X-Up-Context']).to match_json(foo: nil)\n    end\n\n  end\n\n  describe 'up.fail_context' do\n\n    subject { controller.up.fail_context }\n\n    it_behaves_like 'hash field',\n      header: 'X-Up-Fail-Context',\n      reader: -> { up.fail_context }\n\n  end\n\n  describe 'up.fail_context[]=' do\n\n    it 'sends a changed context hash as an X-Up-Context response header' do\n      controller_eval(headers: { 'X-Up-Context': { 'foo': 'fooValue' }.to_json }) do\n        up.fail_context[:bar] = 'barValue'\n      end\n\n      expect(response.headers['X-Up-Context']).to match_json(\n        bar: 'barValue'\n      )\n    end\n\n    it 'changes the value for subsequent calls of up.fail_context[]' do\n      value = controller_eval do\n        up.fail_context[:bar] = 'barValue'\n        up.fail_context[:bar]\n      end\n\n      expect(value).to eq('barValue')\n    end\n\n    it 'changes the value for subsequent calls of up.context[], since context updates will be applied to whatever layer ends up being updated' do\n      value = controller_eval do\n        up.fail_context[:bar] = 'barValue'\n        up.context[:bar]\n      end\n\n      expect(value).to eq('barValue')\n    end\n\n    it 'sends mutated sub-arrays as an X-Up-Context response header' do\n      controller_eval(headers: { 'X-Up-Fail-Context': { foo: [1, 2, 3] }.to_json }) do\n        up.fail_context[:foo] << 4\n      end\n\n      expect(response.headers['X-Up-Context']).to match_json(foo: [1, 2, 3, 4])\n    end\n\n    it 'sends mutated sub-hashes as an X-Up-Context response header' do\n      controller_eval(headers: { 'X-Up-Fail-Context': { foo: { bar: 'barValue'} }.to_json }) do\n        up.fail_context[:foo][:baz] = 'bazValue'\n      end\n\n      expect(response.headers['X-Up-Context']).to match_json(foo: { bar: 'barValue', baz: 'bazValue' })\n    end\n\n  end\n\n  describe 'up.cache.clear' do\n\n    it 'sets an `X-Up-Clear-Cache: *` header' do\n      controller_eval do\n        up.cache.clear\n      end\n\n      expect(response.headers['X-Up-Clear-Cache']).to eq('*')\n    end\n\n    it 'sets an X-Up-Clear-Cache header with the given URL pattern' do\n      controller_eval do\n        up.cache.clear('/foo/*')\n      end\n\n      expect(response.headers['X-Up-Clear-Cache']).to eq('/foo/*')\n   end\n\n  end\n\n  describe 'up.cache.keep' do\n\n    it 'sets an `X-Up-Clear-Cache: false` header' do\n      controller_eval do\n        up.cache.keep\n      end\n\n      expect(response.headers['X-Up-Clear-Cache']).to eq('false')\n    end\n\n  end\n\n  describe 'up.emit' do\n\n    it 'adds an entry into the X-Up-Events response header' do\n      controller_eval do\n        up.emit('my:event', { 'foo' => 'bar' })\n      end\n\n      expect(response.headers['X-Up-Events']).to match_json([\n        { type: 'my:event', foo: 'bar' }\n      ])\n    end\n\n    it 'adds multiple entries to the X-Up-Events response headers' do\n      controller_eval do\n        up.emit('my:event', { 'foo' => 'bar' })\n        up.emit('other:event', { 'bam' => 'baz' })\n      end\n\n      expect(response.headers['X-Up-Events']).to match_json([\n        { foo: 'bar', type: 'my:event' },\n        { bam: 'baz', type: 'other:event' }\n      ])\n    end\n\n    it 'escapes high-ASCII characters in the header value, so we can transport it over HTTP' do\n      controller_eval(headers: { 'X-Up-Mode': 'modal' }) do\n        up.layer.accept('x\u00e4y')\n      end\n\n      controller_eval do\n        up.emit('my:event', { 'foo' => 'x\u00e4y' })\n      end\n\n      expect(response.headers['X-Up-Events']).to eq('[{\"foo\":\"x\\\\u00e4y\",\"type\":\"my:event\"}]')\n    end\n\n  end\n\n  describe 'up.layer.emit' do\n\n    it 'adds an entry into the X-Up-Events response header with { layer: \"current\" } option' do\n      controller_eval do\n        up.layer.emit('my:event', { 'foo' => 'bar' })\n      end\n\n      expect(response.headers['X-Up-Events']).to match_json([\n        { type: 'my:event', foo: 'bar', layer: 'current' }\n      ])\n    end\n\n  end\n\n  describe 'up.layer.mode' do\n\n    it 'returns the value of the X-Up-Mode header' do\n      result = controller_eval(headers: { 'X-Up-Mode': 'foo' }) do\n        up.layer.mode\n      end\n      expect(result).to eq('foo')\n    end\n\n  end\n\n  describe 'up.layer.root?' do\n\n    it 'returns true if the X-Up-Mode header is \"root\"' do\n      result = controller_eval(headers: { 'X-Up-Mode': 'root' }) do\n        up.layer.root?\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if the request is a full page load without Unpoly (which always replaces the entire page)' do\n      result = controller_eval do\n        up.layer.root?\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if the frontend does not reveal its mode for better cacheability' do\n      result = controller_eval(headers: { 'X-Up-Version': '1.0.0' }) do\n        up.layer.root?\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns false if the X-Up-Mode header is not \"root\"' do\n      result = controller_eval(headers: { 'X-Up-Mode': 'drawer' }) do\n        up.layer.root?\n      end\n      expect(result).to eq(false)\n    end\n\n  end\n\n  describe 'up.layer.overlay?' do\n\n    it 'returns true if the X-Up-Mode header is \"overlay\"' do\n      result = controller_eval(headers: { 'X-Up-Mode': 'overlay' }) do\n        up.layer.overlay?\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns false if the request is a full page load (which always replaces the entire page)' do\n      result = controller_eval do\n        up.layer.overlay?\n      end\n      expect(result).to eq(false)\n    end\n\n    it 'returns false if the X-Up-Mode header is \"root\"' do\n      result = controller_eval(headers: { 'X-Up-Mode': 'root' }) do\n        up.layer.overlay?\n      end\n      expect(result).to eq(false)\n    end\n\n  end\n\n  describe 'up.layer.context' do\n\n    it 'returns the parsed JSON object from the X-Up-Context header' do\n      result = controller_eval(headers: { 'X-Up-Context': { 'foo' => 'bar' }.to_json}) do\n        up.layer.context.to_h\n      end\n      expect(result).to eq('foo' => 'bar')\n    end\n\n  end\n\n  describe 'up.layer.accept' do\n\n    it 'sets an X-Up-Accept-Layer response header with the given value' do\n      controller_eval(headers: { 'X-Up-Mode': 'modal' }) do\n        up.layer.accept('foo')\n      end\n\n      expect(response.headers['X-Up-Accept-Layer']).to eq('\"foo\"')\n    end\n\n    it 'sets an X-Up-Accept-Layer response header with a null value if no value is given' do\n      controller_eval(headers: { 'X-Up-Mode': 'modal' }) do\n        up.layer.accept\n      end\n\n      expect(response.headers['X-Up-Accept-Layer']).to eq('null')\n    end\n\n    it 'raises an error when updating the root layer' do\n      accept_root = lambda do\n        controller_eval(headers: { 'X-Up-Mode': 'root' }) do\n          up.layer.accept('foo')\n        end\n      end\n\n      expect(accept_root).to raise_error(/cannot accept/i)\n    end\n\n    it 'escapes high-ASCII characters in the header value, so we can transport it over HTTP' do\n      controller_eval(headers: { 'X-Up-Mode': 'modal' }) do\n        up.layer.accept('x\u00e4y')\n      end\n\n      expect(response.headers['X-Up-Accept-Layer']).to eq('\"x\\\\u00e4y\"')\n    end\n\n  end\n\n  describe 'up.layer.dismiss' do\n\n    it 'sets an X-Up-Dismiss-Layer response header with the given value' do\n      controller_eval(headers: { 'X-Up-Mode': 'modal' }) do\n        up.layer.dismiss('foo')\n      end\n\n      expect(response.headers['X-Up-Dismiss-Layer']).to eq('\"foo\"')\n    end\n\n    it 'sets an X-Up-Dismiss-Layer response header with a null value if no value is given' do\n      controller_eval(headers: { 'X-Up-Mode': 'modal' }) do\n        up.layer.dismiss\n      end\n\n      expect(response.headers['X-Up-Dismiss-Layer']).to eq('null')\n    end\n\n    it 'raises an error when updating the root layer' do\n      dismiss_root = lambda do\n        controller_eval(headers: { 'X-Up-Mode': 'root' }) do\n          up.layer.dismiss('foo')\n        end\n      end\n\n      expect(dismiss_root).to raise_error(/cannot dismiss/i)\n    end\n\n    it 'escapes high-ASCII characters in the header value, so we can transport it over HTTP' do\n      controller_eval(headers: { 'X-Up-Mode': 'modal' }) do\n        up.layer.dismiss('x\u00e4y')\n      end\n\n      expect(response.headers['X-Up-Dismiss-Layer']).to eq('\"x\\\\u00e4y\"')\n    end\n\n  end\n\n  describe 'up.fail_layer.mode' do\n\n    it 'returns the value of the X-Up-Fail-Mode header' do\n      result = controller_eval(headers: { 'X-Up-Fail-Mode': 'foo' }) do\n        up.fail_layer.mode\n      end\n      expect(result).to eq('foo')\n    end\n\n  end\n\n  describe 'up.fail_layer.root?' do\n\n    it 'returns true if the X-Up-Fail-Mode header is \"root\"' do\n      result = controller_eval(headers: { 'X-Up-Fail-Mode': 'root' }) do\n        up.fail_layer.root?\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns true if the request is a full page load (which always replaces the entire page)' do\n      result = controller_eval do\n        up.fail_layer.root?\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns false if the X-Up-Fail-Mode header is not \"root\"' do\n      result = controller_eval(headers: { 'X-Up-Fail-Mode': 'drawer' }) do\n        up.fail_layer.root?\n      end\n      expect(result).to eq(false)\n    end\n\n  end\n\n  describe 'up.fail_layer.overlay?' do\n\n    it 'returns true if the X-Up-Fail-Mode header is \"overlay\"' do\n      result = controller_eval(headers: { 'X-Up-Fail-Mode': 'overlay' }) do\n        up.fail_layer.overlay?\n      end\n      expect(result).to eq(true)\n    end\n\n    it 'returns false if the request is a full page load (which always replaces the entire page)' do\n      result = controller_eval do\n        up.fail_layer.overlay?\n      end\n      expect(result).to eq(false)\n    end\n\n    it 'returns false if the X-Up-Fail-Mode header is \"root\"' do\n      result = controller_eval(headers: { 'X-Up-Fail-Mode': 'root' }) do\n        up.fail_layer.overlay?\n      end\n      expect(result).to eq(false)\n    end\n\n  end\n\n  describe 'up.fail_layer.context' do\n\n    it 'returns the parsed JSON object from the X-Up-Fail-Context header' do\n      result = controller_eval(headers: { 'X-Up-Fail-Context': { 'foo' => 'bar' }.to_json}) do\n        up.fail_layer.context.to_h\n      end\n      expect(result).to eq('foo' => 'bar')\n    end\n\n  end\n\n  describe 'up.title=' do\n\n    it 'sets an X-Up-Title header to push a document title to the client' do\n      controller_eval do\n        up.title = 'Title from controller'\n      end\n      expect(response.headers['X-Up-Title']).to eq('Title from controller')\n    end\n\n  end\n\n  describe 'up.reload_from_time' do\n\n    include_examples 'time field',\n      header: 'X-Up-Reload-From-Time',\n      reader: -> { up.reload_from_time }\n\n  end\n\n  describe 'up.reload?' do\n\n    it 'returns true if an X-Up-Reload-From-Time header is given' do\n      result = controller_eval(headers: { 'X-Up-Reload-From-Time': '1608714891' }) do\n        up.reload?\n      end\n\n      expect(result).to eq(true)\n    end\n\n    it 'returns false if no X-Up-Reload-From-Time header is given' do\n      result = controller_eval do\n        up.reload?\n      end\n\n      expect(result).to eq(false)\n    end\n\n  end\n\n  describe 'up.safe_callback' do\n\n    it 'prepends the CSP nonce to the given JavaScript string' do\n      result = controller_eval do\n        up.safe_callback('alert()')\n      end\n\n      expect(result).to eq('nonce-secret alert()')\n    end\n\n  end\n\n  describe 'redirect_to' do\n\n    it 'preserves Unpoly-related headers for the redirect' do\n      get '/binding_test/redirect1', headers: { 'X-Up-Target' => '.foo' }\n      expect(response).to be_redirect\n      follow_redirect!\n      expect(response.body).to eq('.foo')\n      expect(response.headers['X-Up-Events']).to match_json([\n        { type: 'event1' }\n      ])\n      expect(response.headers['X-Up-Clear-Cache']).to eq('*')\n    end\n\n    it 'preserves Unpoly-releated headers over multiple redirects' do\n      get '/binding_test/redirect0', headers: { 'X-Up-Target' => '.foo' }\n      expect(response).to be_redirect\n      follow_redirect!\n      expect(response).to be_redirect\n      follow_redirect!\n      expect(response.body).to eq('.foo')\n      expect(response.headers['X-Up-Events']).to match_json([\n        { type: 'event0' },\n        { type: 'event1' },\n      ])\n    end\n\n    it 'does not change the history' do\n      get '/binding_test/redirect1', headers: { 'X-Up-Target' => '.foo' }\n      expect(response).to be_redirect\n      follow_redirect!\n      expect(response.headers['X-Up-Location']).to end_with('/redirect2')\n    end\n\n  end\n\n  describe 'echoing of the request location' do\n\n    it 'does not echo the current path in an X-Up-Location response header to prevent the user-controlled request URL from exceeding the maximum response header size' do\n      get '/binding_test/text'\n      expect(response.headers['X-Up-Location']).to be_nil\n    end\n\n    describe 'when the request URL contains query params prefixed with \"_up-\"' do\n\n      it 'removes params prefixed with \"_up-\"' do\n        get '/binding_test/text?_up_1&_up_2=y'\n        expect(response.headers['X-Up-Location']).to end_with('/binding_test/text')\n      end\n\n      it 'keeps params not prefixed with \"_up-\"' do\n        get '/binding_test/text?_up_1=x&foo=bar&_up_2=y'\n        expect(response.headers['X-Up-Location']).to end_with('/binding_test/text?foo=bar')\n      end\n\n      it 'does not mangle array params (BUGFIX)' do\n        get '/binding_test/text?_up_1=x&foo%5B%5D=bar&foo%5B%5D=qux&_up_location=up_location'\n        expect(response.headers['X-Up-Location']).to end_with('/binding_test/text?foo%5B%5D=bar&foo%5B%5D=qux')\n      end\n\n    end\n\n  end\n\n  describe 'echoing of the request method' do\n\n    it 'echoes the current request method in an X-Up-Method response header' do\n      get '/binding_test/text'\n      expect(response.headers['X-Up-Method']).to eq('GET')\n    end\n\n    it 'echoes the current path after a redirect' do\n      put '/binding_test/redirect1'\n      expect(response).to be_redirect\n      follow_redirect!\n      expect(response.headers['X-Up-Method']).to eq('GET')\n    end\n\n    it 'echoes a non-GET request method' do\n      put '/binding_test/text'\n      expect(response.headers['X-Up-Method']).to eq('PUT')\n    end\n\n  end\n\n  describe 'request method cookie' do\n\n    describe 'if the request is both non-GET and not a fragment update' do\n\n      it 'echoes the request method in an _up_method cookie ' do\n        put '/binding_test/text'\n        expect(cookies['_up_method']).to eq('PUT')\n      end\n\n    end\n\n    describe 'if the request is not a fragment update, but GET' do\n\n      it 'does not set the cookie' do\n        get '/binding_test/text'\n        expect(cookies['_up_method']).to be_blank\n      end\n\n      it 'deletes an existing cookie' do\n        cookies['_up_method'] = 'PUT'\n        get '/binding_test/text'\n        expect(cookies['_up_method']).to be_blank\n      end\n\n    end\n\n    describe 'if the request is non-GET but a fragment update' do\n\n      it 'does not set the cookie' do\n        get '/binding_test/text', headers: { 'X-Up-Target' => '.target '}\n        expect(cookies['_up_method']).to be_blank\n      end\n\n      it 'deletes an existing cookie' do\n        cookies['_up_method'] = 'PUT'\n        get '/binding_test/text', headers: { 'X-Up-Target' => '.target' }\n        expect(cookies['_up_method']).to be_blank\n      end\n\n    end\n\n  end\n\nend\n\n"], "filenames": ["lib/unpoly/rails/request_echo_headers.rb", "spec/unpoly/rails/controller_spec.rb"], "buggy_code_start_loc": [21, 998], "buggy_code_end_loc": [24, 1023], "fixing_code_start_loc": [21, 998], "fixing_code_end_loc": [28, 1020], "type": "CWE-400", "message": "Unpoly is a JavaScript framework for server-side web applications. There is a possible Denial of Service (DoS) vulnerability in the `unpoly-rails` gem that implements the Unpoly server protocol for Rails applications. This issues affects Rails applications that operate as an upstream of a load balancer's that uses passive health checks. The `unpoly-rails` gem echoes the request URL as an `X-Up-Location` response header. By making a request with exceedingly long URLs (paths or query string), an attacker can cause unpoly-rails to write a exceedingly large response header. If the response header is too large to be parsed by a load balancer downstream of the Rails application, it may cause the load balancer to remove the upstream from a load balancing group. This causes that application instance to become unavailable until a configured timeout is reached or until an active healthcheck succeeds. This issue has been fixed and released as version 2.7.2.2 which is available via RubyGems and GitHub. Users unable to upgrade may: Configure your load balancer to use active health checks, e.g. by periodically requesting a route with a known response that indicates healthiness; Configure your load balancer so the maximum size of response headers is at least twice the maximum size of a URL; or instead of changing your server configuration you may also configure your Rails application to delete redundant `X-Up-Location` headers set by unpoly-rails.", "other": {"cve": {"id": "CVE-2023-28846", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-30T20:15:07.780", "lastModified": "2023-04-07T18:28:49.723", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Unpoly is a JavaScript framework for server-side web applications. There is a possible Denial of Service (DoS) vulnerability in the `unpoly-rails` gem that implements the Unpoly server protocol for Rails applications. This issues affects Rails applications that operate as an upstream of a load balancer's that uses passive health checks. The `unpoly-rails` gem echoes the request URL as an `X-Up-Location` response header. By making a request with exceedingly long URLs (paths or query string), an attacker can cause unpoly-rails to write a exceedingly large response header. If the response header is too large to be parsed by a load balancer downstream of the Rails application, it may cause the load balancer to remove the upstream from a load balancing group. This causes that application instance to become unavailable until a configured timeout is reached or until an active healthcheck succeeds. This issue has been fixed and released as version 2.7.2.2 which is available via RubyGems and GitHub. Users unable to upgrade may: Configure your load balancer to use active health checks, e.g. by periodically requesting a route with a known response that indicates healthiness; Configure your load balancer so the maximum size of response headers is at least twice the maximum size of a URL; or instead of changing your server configuration you may also configure your Rails application to delete redundant `X-Up-Location` headers set by unpoly-rails."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:unpoly:unpoly-rails:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.2.2", "matchCriteriaId": "5C96F0D3-A1B4-496C-802A-F86FDCFC8B7D"}]}]}], "references": [{"url": "https://docs.nginx.com/nginx/admin-guide/load-balancer/http-health-check/#passive-health-checks", "source": "security-advisories@github.com", "tags": ["Technical Description"]}, {"url": "https://github.com/unpoly/unpoly-rails/", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/unpoly/unpoly-rails/commit/cd9ad0007daceeb3b2354fdcab4f88350427bf16", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/unpoly/unpoly-rails/security/advisories/GHSA-m875-3xf6-mf78", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://makandracards.com/operations/537537-nginx-proxy-buffer-tuning", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://tryhexadecimal.com/guides/http/414-request-uri-too-long", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://unpoly.com/up.protocol", "source": "security-advisories@github.com", "tags": ["Product"]}]}, "github_commit_url": "https://github.com/unpoly/unpoly-rails/commit/cd9ad0007daceeb3b2354fdcab4f88350427bf16"}}