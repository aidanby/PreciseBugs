{"buggy_code": ["/*\n * This file is part of Espruino, a JavaScript interpreter for Microcontrollers\n *\n * Copyright (C) 2013 Gordon Williams <gw@pur3.co.uk>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * ----------------------------------------------------------------------------\n * Lexer (convert JsVar strings into a series of tokens)\n * ----------------------------------------------------------------------------\n */\n#include \"jslex.h\"\n\nJsLex *lex;\n\nJsLex *jslSetLex(JsLex *l) {\n  JsLex *old = lex;\n  lex = l;\n  return old;\n}\n\nvoid jslCharPosFree(JslCharPos *pos) {\n  jsvStringIteratorFree(&pos->it);\n}\n\nJslCharPos jslCharPosClone(JslCharPos *pos) {\n  JslCharPos p;\n  p.it = jsvStringIteratorClone(&pos->it);\n  p.currCh = pos->currCh;\n  return p;\n}\n\n/// Return the next character (do not move to the next character)\nstatic ALWAYS_INLINE char jslNextCh() {\n  return (char)(lex->it.ptr ? READ_FLASH_UINT8(&lex->it.ptr[lex->it.charIdx]) : 0);\n}\n\n/// Move on to the next character\nstatic void NO_INLINE jslGetNextCh() {\n  lex->currCh = jslNextCh();\n\n  /** NOTE: In this next bit, we DON'T LOCK OR UNLOCK.\n   * The String iterator we're basing on does, so every\n   * time we touch the iterator we have to re-lock it\n   */\n  lex->it.charIdx++;\n  if (lex->it.charIdx >= lex->it.charsInVar) {\n    lex->it.charIdx -= lex->it.charsInVar;\n    if (lex->it.var && jsvGetLastChild(lex->it.var)) {\n      lex->it.var = _jsvGetAddressOf(jsvGetLastChild(lex->it.var));\n      lex->it.ptr = &lex->it.var->varData.str[0];\n      lex->it.varIndex += lex->it.charsInVar;\n      lex->it.charsInVar = jsvGetCharactersInVar(lex->it.var);\n    } else {\n      lex->it.var = 0;\n      lex->it.ptr = 0;\n      lex->it.varIndex += lex->it.charsInVar;\n      lex->it.charsInVar = 0;\n    }\n  }\n}\n\nstatic ALWAYS_INLINE void jslTokenAppendChar(char ch) {\n  /* Add character to buffer but check it isn't too big.\n   * Also Leave ONE character at the end for null termination */\n  if (lex->tokenl < JSLEX_MAX_TOKEN_LENGTH-1) {\n    lex->token[lex->tokenl++] = ch;\n  }\n}\n\nstatic bool jslIsToken(const char *token, int startOffset) {\n  int i;\n  for (i=startOffset;i<lex->tokenl;i++) {\n    if (lex->token[i]!=token[i]) return false;\n    // if token is smaller than lex->token, there will be a null char\n    // which will be different from the token\n  }\n  return token[lex->tokenl] == 0; // only match if token ends now\n}\n\ntypedef enum {\n  JSLJT_ID,\n  JSLJT_NUMBER,\n  JSLJT_STRING,\n  JSLJT_SINGLECHAR,\n\n  JSLJT_EXCLAMATION,\n  JSLJT_PLUS,\n  JSLJT_MINUS,\n  JSLJT_AND,\n  JSLJT_OR,\n  JSLJT_PERCENT,\n  JSLJT_STAR,\n  JSLJT_TOPHAT,\n  JSLJT_FORWARDSLASH,\n  JSLJT_LESSTHAN,\n  JSLJT_EQUAL,\n  JSLJT_GREATERTHAN,\n} PACKED_FLAGS jslJumpTableEnum;\n\n#define jslJumpTableStart 33 // '!' - the first handled character\n#define jslJumpTableEnd 124 // '|' - the last handled character\nconst jslJumpTableEnum jslJumpTable[jslJumpTableEnd+1-jslJumpTableStart] = {\n    // 33\n    JSLJT_EXCLAMATION, // !\n    JSLJT_STRING, // \"\n    JSLJT_SINGLECHAR, // #\n    JSLJT_ID, // $\n    JSLJT_PERCENT, // %\n    JSLJT_AND, // &\n    JSLJT_STRING, // '\n    JSLJT_SINGLECHAR, // (\n    JSLJT_SINGLECHAR, // )\n    JSLJT_STAR, // *\n    JSLJT_PLUS, // +\n    JSLJT_SINGLECHAR, // ,\n    JSLJT_MINUS, // -\n    JSLJT_NUMBER, // . - special :/\n    JSLJT_FORWARDSLASH, // /\n    // 48\n    JSLJT_NUMBER, // 0\n    JSLJT_NUMBER, // 1\n    JSLJT_NUMBER, // 2\n    JSLJT_NUMBER, // 3\n    JSLJT_NUMBER, // 4\n    JSLJT_NUMBER, // 5\n    JSLJT_NUMBER, // 6\n    JSLJT_NUMBER, // 7\n    JSLJT_NUMBER, // 8\n    JSLJT_NUMBER, // 9\n    JSLJT_SINGLECHAR, // :\n    JSLJT_SINGLECHAR, // ;\n    JSLJT_LESSTHAN, // <\n    JSLJT_EQUAL, // =\n    JSLJT_GREATERTHAN, // >\n    JSLJT_SINGLECHAR, // ?\n    // 64\n    JSLJT_SINGLECHAR, // @\n    JSLJT_ID, // A\n    JSLJT_ID, // B\n    JSLJT_ID, // C\n    JSLJT_ID, // D\n    JSLJT_ID, // E\n    JSLJT_ID, // F\n    JSLJT_ID, // G\n    JSLJT_ID, // H\n    JSLJT_ID, // I\n    JSLJT_ID, // J\n    JSLJT_ID, // K\n    JSLJT_ID, // L\n    JSLJT_ID, // M\n    JSLJT_ID, // N\n    JSLJT_ID, // O\n    JSLJT_ID, // P\n    JSLJT_ID, // Q\n    JSLJT_ID, // R\n    JSLJT_ID, // S\n    JSLJT_ID, // T\n    JSLJT_ID, // U\n    JSLJT_ID, // V\n    JSLJT_ID, // W\n    JSLJT_ID, // X\n    JSLJT_ID, // Y\n    JSLJT_ID, // Z\n    JSLJT_SINGLECHAR, // [\n    JSLJT_SINGLECHAR, // \\ char\n    JSLJT_SINGLECHAR, // ]\n    JSLJT_TOPHAT, // ^\n    JSLJT_ID, // _\n    // 96\n    JSLJT_STRING, // `\n    JSLJT_ID, // A lowercase\n    JSLJT_ID, // B lowercase\n    JSLJT_ID, // C lowercase\n    JSLJT_ID, // D lowercase\n    JSLJT_ID, // E lowercase\n    JSLJT_ID, // F lowercase\n    JSLJT_ID, // G lowercase\n    JSLJT_ID, // H lowercase\n    JSLJT_ID, // I lowercase\n    JSLJT_ID, // J lowercase\n    JSLJT_ID, // K lowercase\n    JSLJT_ID, // L lowercase\n    JSLJT_ID, // M lowercase\n    JSLJT_ID, // N lowercase\n    JSLJT_ID, // O lowercase\n    JSLJT_ID, // P lowercase\n    JSLJT_ID, // Q lowercase\n    JSLJT_ID, // R lowercase\n    JSLJT_ID, // S lowercase\n    JSLJT_ID, // T lowercase\n    JSLJT_ID, // U lowercase\n    JSLJT_ID, // V lowercase\n    JSLJT_ID, // W lowercase\n    JSLJT_ID, // X lowercase\n    JSLJT_ID, // Y lowercase\n    JSLJT_ID, // Z lowercase\n    JSLJT_SINGLECHAR, // {\n    JSLJT_OR, // |\n    // everything past here is handled as a single char\n    //  JSLJT_SINGLECHAR, // }\n    //  JSLJT_SINGLECHAR, // ~\n};\n\n// handle a single char\nstatic ALWAYS_INLINE void jslSingleChar() {\n  lex->tk = (unsigned char)lex->currCh;\n  jslGetNextCh();\n}\n\nstatic void jslLexString() {\n  char delim = lex->currCh;\n  lex->tokenValue = jsvNewFromEmptyString();\n  if (!lex->tokenValue) {\n    lex->tk = LEX_EOF;\n    return;\n  }\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, lex->tokenValue, 0);\n  // strings...\n  jslGetNextCh();\n  while (lex->currCh && lex->currCh!=delim) {\n    if (lex->currCh == '\\\\') {\n      jslGetNextCh();\n      char ch = lex->currCh;\n      switch (lex->currCh) {\n      case 'n'  : ch = 0x0A; jslGetNextCh(); break;\n      case 'b'  : ch = 0x08; jslGetNextCh(); break;\n      case 'f'  : ch = 0x0C; jslGetNextCh(); break;\n      case 'r'  : ch = 0x0D; jslGetNextCh(); break;\n      case 't'  : ch = 0x09; jslGetNextCh(); break;\n      case 'v'  : ch = 0x0B; jslGetNextCh(); break;\n      case 'u' :\n      case 'x' : { // hex digits\n        char buf[5] = \"0x??\";\n        if (lex->currCh == 'u') {\n          // We don't support unicode, so we just take the bottom 8 bits\n          // of the unicode character\n          jslGetNextCh();\n          jslGetNextCh();\n        }\n        jslGetNextCh();\n        buf[2] = lex->currCh; jslGetNextCh();\n        buf[3] = lex->currCh; jslGetNextCh();\n        ch = (char)stringToInt(buf);\n      } break;\n      default:\n        if (lex->currCh>='0' && lex->currCh<='7') {\n          // octal digits\n          char buf[5] = \"0\";\n          buf[1] = lex->currCh;\n          int n=2;\n          jslGetNextCh();\n          if (lex->currCh>='0' && lex->currCh<='7') {\n            buf[n++] = lex->currCh; jslGetNextCh();\n            if (lex->currCh>='0' && lex->currCh<='7') {\n              buf[n++] = lex->currCh; jslGetNextCh();\n            }\n          }\n          buf[n]=0;\n          ch = (char)stringToInt(buf);\n        } else {\n          // for anything else, just push the character through\n          jslGetNextCh();\n        }\n        break;\n      }\n      jslTokenAppendChar(ch);\n      jsvStringIteratorAppend(&it, ch);\n    } else if (lex->currCh=='\\n' && delim!='`') {\n      /* Was a newline - this is now allowed\n       * unless we're a template string */\n      break;\n    } else {\n      jslTokenAppendChar(lex->currCh);\n      jsvStringIteratorAppend(&it, lex->currCh);\n      jslGetNextCh();\n    }\n  }\n  jsvStringIteratorFree(&it);\n  if (delim=='`')\n    lex->tk = LEX_TEMPLATE_LITERAL;\n  else lex->tk = LEX_STR;\n  // unfinished strings\n  if (lex->currCh!=delim)\n    lex->tk++; // +1 gets you to 'unfinished X'\n  jslGetNextCh();\n}\n\nstatic void jslLexRegex() {\n  lex->tokenValue = jsvNewFromEmptyString();\n  if (!lex->tokenValue) {\n    lex->tk = LEX_EOF;\n    return;\n  }\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, lex->tokenValue, 0);\n  jsvStringIteratorAppend(&it, '/');\n  // strings...\n  jslGetNextCh();\n  while (lex->currCh && lex->currCh!='/') {\n    if (lex->currCh == '\\\\') {\n      jsvStringIteratorAppend(&it, lex->currCh);\n      jslGetNextCh();\n    } else if (lex->currCh=='\\n') {\n      /* Was a newline - this is now allowed\n       * unless we're a template string */\n      break;\n    }\n    jsvStringIteratorAppend(&it, lex->currCh);\n    jslGetNextCh();\n  }\n  lex->tk = LEX_REGEX;\n  if (lex->currCh!='/') {\n    lex->tk++; // +1 gets you to 'unfinished X'\n  } else {\n    jsvStringIteratorAppend(&it, '/');\n    jslGetNextCh();\n    // regex modifiers\n    while (lex->currCh=='g' ||\n        lex->currCh=='i' ||\n        lex->currCh=='m' ||\n        lex->currCh=='y' ||\n        lex->currCh=='u') {\n      jslTokenAppendChar(lex->currCh);\n      jsvStringIteratorAppend(&it, lex->currCh);\n      jslGetNextCh();\n    }\n  }\n  jsvStringIteratorFree(&it);\n}\n\nvoid jslGetNextToken() {\n  jslGetNextToken_start:\n  // Skip whitespace\n  while (isWhitespace(lex->currCh))\n    jslGetNextCh();\n  // Search for comments\n  if (lex->currCh=='/') {\n    // newline comments\n    if (jslNextCh()=='/') {\n      while (lex->currCh && lex->currCh!='\\n') jslGetNextCh();\n      jslGetNextCh();\n      goto jslGetNextToken_start;\n    }\n    // block comments\n    if (jslNextCh()=='*') {\n      jslGetNextCh();\n      jslGetNextCh();\n      while (lex->currCh && !(lex->currCh=='*' && jslNextCh()=='/'))\n        jslGetNextCh();\n      if (!lex->currCh) {\n        lex->tk = LEX_UNFINISHED_COMMENT;\n        return; /* an unfinished multi-line comment. When in interactive console,\n                   detect this and make sure we accept new lines */\n      }\n      jslGetNextCh();\n      jslGetNextCh();\n      goto jslGetNextToken_start;\n    }\n  }\n  int lastToken = lex->tk;\n  lex->tk = LEX_EOF;\n  lex->tokenl = 0; // clear token string\n  if (lex->tokenValue) {\n    jsvUnLock(lex->tokenValue);\n    lex->tokenValue = 0;\n  }\n  // record beginning of this token\n  lex->tokenLastStart = jsvStringIteratorGetIndex(&lex->tokenStart.it) - 1;\n  /* we don't lock here, because we know that the string itself will be locked\n   * because of lex->sourceVar */\n  lex->tokenStart.it = lex->it;\n  lex->tokenStart.currCh = lex->currCh;\n  // tokens\n  if (((unsigned char)lex->currCh) < jslJumpTableStart ||\n      ((unsigned char)lex->currCh) > jslJumpTableEnd) {\n    // if unhandled by the jump table, just pass it through as a single character\n    jslSingleChar();\n  } else {\n    switch(jslJumpTable[((unsigned char)lex->currCh) - jslJumpTableStart]) {\n    case JSLJT_ID: {\n      while (isAlpha(lex->currCh) || isNumeric(lex->currCh) || lex->currCh=='$') {\n        jslTokenAppendChar(lex->currCh);\n        jslGetNextCh();\n      }\n      lex->tk = LEX_ID;\n      // We do fancy stuff here to reduce number of compares (hopefully GCC creates a jump table)\n      switch (lex->token[0]) {\n      case 'b': if (jslIsToken(\"break\", 1)) lex->tk = LEX_R_BREAK;\n      break;\n      case 'c': if (jslIsToken(\"case\", 1)) lex->tk = LEX_R_CASE;\n      else if (jslIsToken(\"catch\", 1)) lex->tk = LEX_R_CATCH;\n      else if (jslIsToken(\"class\", 1)) lex->tk = LEX_R_CLASS;\n      else if (jslIsToken(\"const\", 1)) lex->tk = LEX_R_CONST;\n      else if (jslIsToken(\"continue\", 1)) lex->tk = LEX_R_CONTINUE;\n      break;\n      case 'd': if (jslIsToken(\"default\", 1)) lex->tk = LEX_R_DEFAULT;\n      else if (jslIsToken(\"delete\", 1)) lex->tk = LEX_R_DELETE;\n      else if (jslIsToken(\"do\", 1)) lex->tk = LEX_R_DO;\n      else if (jslIsToken(\"debugger\", 1)) lex->tk = LEX_R_DEBUGGER;\n      break;\n      case 'e': if (jslIsToken(\"else\", 1)) lex->tk = LEX_R_ELSE;\n      else if (jslIsToken(\"extends\", 1)) lex->tk = LEX_R_EXTENDS;\n      break;\n      case 'f': if (jslIsToken(\"false\", 1)) lex->tk = LEX_R_FALSE;\n      else if (jslIsToken(\"finally\", 1)) lex->tk = LEX_R_FINALLY;\n      else if (jslIsToken(\"for\", 1)) lex->tk = LEX_R_FOR;\n      else if (jslIsToken(\"function\", 1)) lex->tk = LEX_R_FUNCTION;\n      break;\n      case 'i': if (jslIsToken(\"if\", 1)) lex->tk = LEX_R_IF;\n      else if (jslIsToken(\"in\", 1)) lex->tk = LEX_R_IN;\n      else if (jslIsToken(\"instanceof\", 1)) lex->tk = LEX_R_INSTANCEOF;\n      break;\n      case 'l': if (jslIsToken(\"let\", 1)) lex->tk = LEX_R_LET;\n      break;\n      case 'n': if (jslIsToken(\"new\", 1)) lex->tk = LEX_R_NEW;\n      else if (jslIsToken(\"null\", 1)) lex->tk = LEX_R_NULL;\n      break;\n      case 'r': if (jslIsToken(\"return\", 1)) lex->tk = LEX_R_RETURN;\n      break;\n      case 's': if (jslIsToken(\"static\", 1)) lex->tk = LEX_R_STATIC;\n      else if (jslIsToken(\"super\", 1)) lex->tk = LEX_R_SUPER;\n      else if (jslIsToken(\"switch\", 1)) lex->tk = LEX_R_SWITCH;\n      break;\n      case 't': if (jslIsToken(\"this\", 1)) lex->tk = LEX_R_THIS;\n      else if (jslIsToken(\"throw\", 1)) lex->tk = LEX_R_THROW;\n      else if (jslIsToken(\"true\", 1)) lex->tk = LEX_R_TRUE;\n      else if (jslIsToken(\"try\", 1)) lex->tk = LEX_R_TRY;\n      else if (jslIsToken(\"typeof\", 1)) lex->tk = LEX_R_TYPEOF;\n      break;\n      case 'u': if (jslIsToken(\"undefined\", 1)) lex->tk = LEX_R_UNDEFINED;\n      break;\n      case 'w': if (jslIsToken(\"while\", 1)) lex->tk = LEX_R_WHILE;\n      break;\n      case 'v': if (jslIsToken(\"var\", 1)) lex->tk = LEX_R_VAR;\n      else if (jslIsToken(\"void\", 1)) lex->tk = LEX_R_VOID;\n      break;\n      default: break;\n      } break;\n      case JSLJT_NUMBER: {\n        // TODO: check numbers aren't the wrong format\n        bool canBeFloating = true;\n        if (lex->currCh=='.') {\n          jslGetNextCh();\n          if (isNumeric(lex->currCh)) {\n            // it is a float\n            lex->tk = LEX_FLOAT;\n            jslTokenAppendChar('.');\n          } else {\n            // it wasn't a number after all\n            lex->tk = '.';\n            break;\n          }\n        } else {\n          if (lex->currCh=='0') {\n            jslTokenAppendChar(lex->currCh);\n            jslGetNextCh();\n            if ((lex->currCh=='x' || lex->currCh=='X') ||\n                (lex->currCh=='b' || lex->currCh=='B') ||\n                (lex->currCh=='o' || lex->currCh=='O')) {\n              canBeFloating = false;\n              jslTokenAppendChar(lex->currCh); jslGetNextCh();\n            }\n          }\n          lex->tk = LEX_INT;\n          while (isNumeric(lex->currCh) || (!canBeFloating && isHexadecimal(lex->currCh))) {\n            jslTokenAppendChar(lex->currCh);\n            jslGetNextCh();\n          }\n          if (canBeFloating && lex->currCh=='.') {\n            lex->tk = LEX_FLOAT;\n            jslTokenAppendChar('.');\n            jslGetNextCh();\n          }\n        }\n        // parse fractional part\n        if (lex->tk == LEX_FLOAT) {\n          while (isNumeric(lex->currCh)) {\n            jslTokenAppendChar(lex->currCh);\n            jslGetNextCh();\n          }\n        }\n        // do fancy e-style floating point\n        if (canBeFloating && (lex->currCh=='e'||lex->currCh=='E')) {\n          lex->tk = LEX_FLOAT;\n          jslTokenAppendChar(lex->currCh); jslGetNextCh();\n          if (lex->currCh=='-' || lex->currCh=='+') { jslTokenAppendChar(lex->currCh); jslGetNextCh(); }\n          while (isNumeric(lex->currCh)) {\n            jslTokenAppendChar(lex->currCh); jslGetNextCh();\n          }\n        }\n      } break;\n      case JSLJT_STRING: jslLexString(); break;\n      case JSLJT_EXCLAMATION: jslSingleChar();\n      if (lex->currCh=='=') { // !=\n        lex->tk = LEX_NEQUAL;\n        jslGetNextCh();\n        if (lex->currCh=='=') { // !==\n          lex->tk = LEX_NTYPEEQUAL;\n          jslGetNextCh();\n        }\n      } break;\n      case JSLJT_PLUS: jslSingleChar();\n      if (lex->currCh=='=') {\n        lex->tk = LEX_PLUSEQUAL;\n        jslGetNextCh();\n      } else if (lex->currCh=='+') {\n        lex->tk = LEX_PLUSPLUS;\n        jslGetNextCh();\n      } break;\n      case JSLJT_MINUS: jslSingleChar();\n      if (lex->currCh=='=') {\n        lex->tk = LEX_MINUSEQUAL;\n        jslGetNextCh();\n      } else if (lex->currCh=='-') {\n        lex->tk = LEX_MINUSMINUS;\n        jslGetNextCh();\n      } break;\n      case JSLJT_AND: jslSingleChar();\n      if (lex->currCh=='=') {\n        lex->tk = LEX_ANDEQUAL;\n        jslGetNextCh();\n      } else if (lex->currCh=='&') {\n        lex->tk = LEX_ANDAND;\n        jslGetNextCh();\n      } break;\n      case JSLJT_OR: jslSingleChar();\n      if (lex->currCh=='=') {\n        lex->tk = LEX_OREQUAL;\n        jslGetNextCh();\n      } else if (lex->currCh=='|') {\n        lex->tk = LEX_OROR;\n        jslGetNextCh();\n      } break;\n      case JSLJT_TOPHAT: jslSingleChar();\n      if (lex->currCh=='=') {\n        lex->tk = LEX_XOREQUAL;\n        jslGetNextCh();\n      } break;\n      case JSLJT_STAR: jslSingleChar();\n      if (lex->currCh=='=') {\n        lex->tk = LEX_MULEQUAL;\n        jslGetNextCh();\n      } break;\n      case JSLJT_FORWARDSLASH:\n      // yay! JS is so awesome.\n      if (lastToken==LEX_EOF ||\n          lastToken=='!' ||\n          lastToken=='%' ||\n          lastToken=='&' ||\n          lastToken=='*' ||\n          lastToken=='+' ||\n          lastToken=='-' ||\n          lastToken=='/' ||\n          lastToken=='<' ||\n          lastToken=='=' ||\n          lastToken=='>' ||\n          lastToken=='?' ||\n          (lastToken>=_LEX_OPERATOR_START && lastToken<=_LEX_OPERATOR_END) ||\n          (lastToken>=_LEX_R_LIST_START && lastToken<=_LEX_R_LIST_END) || // keywords\n          lastToken==LEX_R_CASE ||\n          lastToken==LEX_R_NEW ||\n          lastToken=='[' ||\n          lastToken=='{' ||\n          lastToken=='}' ||\n          lastToken=='(' ||\n          lastToken==',' ||\n          lastToken==';' ||\n          lastToken==':' ||\n          lastToken==LEX_ARROW_FUNCTION) {\n        // EOF operator keyword case new [ { } ( , ; : =>\n        // phew. We're a regex\n        jslLexRegex();\n      } else {\n        jslSingleChar();\n        if (lex->currCh=='=') {\n          lex->tk = LEX_DIVEQUAL;\n          jslGetNextCh();\n        }\n      } break;\n      case JSLJT_PERCENT: jslSingleChar();\n      if (lex->currCh=='=') {\n        lex->tk = LEX_MODEQUAL;\n        jslGetNextCh();\n      } break;\n      case JSLJT_EQUAL: jslSingleChar();\n      if (lex->currCh=='=') { // ==\n        lex->tk = LEX_EQUAL;\n        jslGetNextCh();\n        if (lex->currCh=='=') { // ===\n          lex->tk = LEX_TYPEEQUAL;\n          jslGetNextCh();\n        }\n      } else if (lex->currCh=='>') { // =>\n        lex->tk = LEX_ARROW_FUNCTION;\n        jslGetNextCh();\n      } break;\n      case JSLJT_LESSTHAN: jslSingleChar();\n      if (lex->currCh=='=') { // <=\n        lex->tk = LEX_LEQUAL;\n        jslGetNextCh();\n      } else if (lex->currCh=='<') { // <<\n        lex->tk = LEX_LSHIFT;\n        jslGetNextCh();\n        if (lex->currCh=='=') { // <<=\n          lex->tk = LEX_LSHIFTEQUAL;\n          jslGetNextCh();\n        }\n      } break;\n      case JSLJT_GREATERTHAN: jslSingleChar();\n      if (lex->currCh=='=') { // >=\n        lex->tk = LEX_GEQUAL;\n        jslGetNextCh();\n      } else if (lex->currCh=='>') { // >>\n        lex->tk = LEX_RSHIFT;\n        jslGetNextCh();\n        if (lex->currCh=='=') { // >>=\n          lex->tk = LEX_RSHIFTEQUAL;\n          jslGetNextCh();\n        } else if (lex->currCh=='>') { // >>>\n          jslGetNextCh();\n          if (lex->currCh=='=') { // >>>=\n            lex->tk = LEX_RSHIFTUNSIGNEDEQUAL;\n            jslGetNextCh();\n          } else {\n            lex->tk = LEX_RSHIFTUNSIGNED;\n          }\n        }\n      } break;\n\n      case JSLJT_SINGLECHAR: jslSingleChar(); break;\n      default: assert(0);break;\n    }\n    }\n  }\n}\n\nstatic ALWAYS_INLINE void jslPreload() {\n  // set up..\n  jslGetNextCh();\n  jslGetNextToken();\n}\n\nvoid jslInit(JsVar *var) {\n  lex->sourceVar = jsvLockAgain(var);\n  // reset stuff\n  lex->tk = 0;\n  lex->tokenStart.it.var = 0;\n  lex->tokenStart.currCh = 0;\n  lex->tokenLastStart = 0;\n  lex->tokenl = 0;\n  lex->tokenValue = 0;\n  lex->lineNumberOffset = 0;\n  // set up iterator\n  jsvStringIteratorNew(&lex->it, lex->sourceVar, 0);\n  jsvUnLock(lex->it.var); // see jslGetNextCh\n  jslPreload();\n}\n\nvoid jslKill() {\n  lex->tk = LEX_EOF; // safety ;)\n  if (lex->it.var) jsvLockAgain(lex->it.var); // see jslGetNextCh\n  jsvStringIteratorFree(&lex->it);\n  if (lex->tokenValue) {\n    jsvUnLock(lex->tokenValue);\n    lex->tokenValue = 0;\n  }\n  jsvUnLock(lex->sourceVar);\n  lex->tokenStart.it.var = 0;\n  lex->tokenStart.currCh = 0;\n}\n\nvoid jslSeekTo(size_t seekToChar) {\n  if (lex->it.var) jsvLockAgain(lex->it.var); // see jslGetNextCh\n  jsvStringIteratorFree(&lex->it);\n  jsvStringIteratorNew(&lex->it, lex->sourceVar, seekToChar);\n  jsvUnLock(lex->it.var); // see jslGetNextCh\n  lex->tokenStart.it.var = 0;\n  lex->tokenStart.currCh = 0;\n  jslPreload();\n}\n\nvoid jslSeekToP(JslCharPos *seekToChar) {\n  if (lex->it.var) jsvLockAgain(lex->it.var); // see jslGetNextCh\n  jsvStringIteratorFree(&lex->it);\n  lex->it = jsvStringIteratorClone(&seekToChar->it);\n  jsvUnLock(lex->it.var); // see jslGetNextCh\n  lex->currCh = seekToChar->currCh;\n  lex->tokenStart.it.var = 0;\n  lex->tokenStart.currCh = 0;\n  jslGetNextToken();\n}\n\nvoid jslReset() {\n  jslSeekTo(0);\n}\n\n\n\n/** When printing out a function, with pretokenise a\n * character could end up being a special token. This\n * handles that case. */\nvoid jslFunctionCharAsString(unsigned char ch, char *str, size_t len) {\n  if (ch >= LEX_TOKEN_START) {\n    jslTokenAsString(ch, str, len);\n  } else {\n    str[0] = (char)ch;\n    str[1] = 0;\n  }\n}\n\nvoid jslTokenAsString(int token, char *str, size_t len) {\n  // see JS_ERROR_TOKEN_BUF_SIZE\n  if (token>32 && token<128) {\n    assert(len>=4);\n    str[0] = '\\'';\n    str[1] = (char)token;\n    str[2] = '\\'';\n    str[3] = 0;\n    return;\n  }\n\n  switch (token) {\n  case LEX_EOF : strncpy(str, \"EOF\", len); return;\n  case LEX_ID : strncpy(str, \"ID\", len); return;\n  case LEX_INT : strncpy(str, \"INT\", len); return;\n  case LEX_FLOAT : strncpy(str, \"FLOAT\", len); return;\n  case LEX_STR : strncpy(str, \"STRING\", len); return;\n  case LEX_UNFINISHED_STR : strncpy(str, \"UNFINISHED STRING\", len); return;\n  case LEX_TEMPLATE_LITERAL : strncpy(str, \"TEMPLATE LITERAL\", len); return;\n  case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy(str, \"UNFINISHED TEMPLATE LITERAL\", len); return;\n  case LEX_REGEX : strncpy(str, \"REGEX\", len); return;\n  case LEX_UNFINISHED_REGEX : strncpy(str, \"UNFINISHED REGEX\", len); return;\n  case LEX_UNFINISHED_COMMENT : strncpy(str, \"UNFINISHED COMMENT\", len); return;\n  }\n  if (token>=_LEX_OPERATOR_START && token<_LEX_R_LIST_END) {\n    const char tokenNames[] =\n        /* LEX_EQUAL      :   */ \"==\\0\"\n        /* LEX_TYPEEQUAL  :   */ \"===\\0\"\n        /* LEX_NEQUAL     :   */ \"!=\\0\"\n        /* LEX_NTYPEEQUAL :   */ \"!==\\0\"\n        /* LEX_LEQUAL    :    */ \"<=\\0\"\n        /* LEX_LSHIFT     :   */ \"<<\\0\"\n        /* LEX_LSHIFTEQUAL :  */ \"<<=\\0\"\n        /* LEX_GEQUAL      :  */ \">=\\0\"\n        /* LEX_RSHIFT      :  */ \">>\\0\"\n        /* LEX_RSHIFTUNSIGNED */ \">>>\\0\"\n        /* LEX_RSHIFTEQUAL :  */ \">>=\\0\"\n        /* LEX_RSHIFTUNSIGNEDEQUAL */ \">>>=\\0\"\n        /* LEX_PLUSEQUAL   :  */ \"+=\\0\"\n        /* LEX_MINUSEQUAL  :  */ \"-=\\0\"\n        /* LEX_PLUSPLUS :     */ \"++\\0\"\n        /* LEX_MINUSMINUS     */ \"--\\0\"\n        /* LEX_MULEQUAL :     */ \"*=\\0\"\n        /* LEX_DIVEQUAL :     */ \"/=\\0\"\n        /* LEX_MODEQUAL :     */ \"%=\\0\"\n        /* LEX_ANDEQUAL :     */ \"&=\\0\"\n        /* LEX_ANDAND :       */ \"&&\\0\"\n        /* LEX_OREQUAL :      */ \"|=\\0\"\n        /* LEX_OROR :         */ \"||\\0\"\n        /* LEX_XOREQUAL :     */ \"^=\\0\"\n        /* LEX_ARROW_FUNCTION */ \"=>\\0\"\n\n        // reserved words\n        /*LEX_R_IF :       */ \"if\\0\"\n        /*LEX_R_ELSE :     */ \"else\\0\"\n        /*LEX_R_DO :       */ \"do\\0\"\n        /*LEX_R_WHILE :    */ \"while\\0\"\n        /*LEX_R_FOR :      */ \"for\\0\"\n        /*LEX_R_BREAK :    */ \"return\\0\"\n        /*LEX_R_CONTINUE   */ \"continue\\0\"\n        /*LEX_R_FUNCTION   */ \"function\\0\"\n        /*LEX_R_RETURN     */ \"return\\0\"\n        /*LEX_R_VAR :      */ \"var\\0\"\n        /*LEX_R_LET :      */ \"let\\0\"\n        /*LEX_R_CONST :    */ \"const\\0\"\n        /*LEX_R_THIS :     */ \"this\\0\"\n        /*LEX_R_THROW :    */ \"throw\\0\"\n        /*LEX_R_TRY :      */ \"try\\0\"\n        /*LEX_R_CATCH :    */ \"catch\\0\"\n        /*LEX_R_FINALLY :  */ \"finally\\0\"\n        /*LEX_R_TRUE :     */ \"true\\0\"\n        /*LEX_R_FALSE :    */ \"false\\0\"\n        /*LEX_R_NULL :     */ \"null\\0\"\n        /*LEX_R_UNDEFINED  */ \"undefined\\0\"\n        /*LEX_R_NEW :      */ \"new\\0\"\n        /*LEX_R_IN :       */ \"in\\0\"\n        /*LEX_R_INSTANCEOF */ \"instanceof\\0\"\n        /*LEX_R_SWITCH     */ \"switch\\0\"\n        /*LEX_R_CASE       */ \"case\\0\"\n        /*LEX_R_DEFAULT    */ \"default\\0\"\n        /*LEX_R_DELETE     */ \"delete\\0\"\n        /*LEX_R_TYPEOF :   */ \"typeof\\0\"\n        /*LEX_R_VOID :     */ \"void\\0\"\n        /*LEX_R_DEBUGGER : */ \"debugger\\0\"\n        /*LEX_R_CLASS :    */ \"class\\0\"\n        /*LEX_R_EXTENDS :  */ \"extends\\0\"\n        /*LEX_R_SUPER :  */   \"super\\0\"\n        /*LEX_R_STATIC :   */ \"static\\0\"\n        ;\n    unsigned int p = 0;\n    int n = token-_LEX_OPERATOR_START;\n    while (n>0 && p<sizeof(tokenNames)) {\n      while (tokenNames[p] && p<sizeof(tokenNames)) p++;\n      p++; // skip the zero\n      n--; // next token\n    }\n    assert(n==0);\n    strncpy(str, &tokenNames[p], len);\n    return;\n  }\n\n  assert(len>=10);\n  espruino_snprintf(str, len, \"?[%d]\", token);\n}\n\nvoid jslGetTokenString(char *str, size_t len) {\n  if (lex->tk == LEX_ID) {\n    espruino_snprintf(str, len, \"ID:%s\", jslGetTokenValueAsString());\n  } else if (lex->tk == LEX_STR) {\n    espruino_snprintf(str, len, \"String:'%s'\", jslGetTokenValueAsString());\n  } else\n    jslTokenAsString(lex->tk, str, len);\n}\n\nchar *jslGetTokenValueAsString() {\n  assert(lex->tokenl < JSLEX_MAX_TOKEN_LENGTH);\n  lex->token[lex->tokenl]  = 0; // add final null\n  return lex->token;\n}\n\nint jslGetTokenLength() {\n  return lex->tokenl;\n}\n\nJsVar *jslGetTokenValueAsVar() {\n  if (lex->tokenValue) {\n    return jsvLockAgain(lex->tokenValue);\n  } else {\n    assert(lex->tokenl < JSLEX_MAX_TOKEN_LENGTH);\n    lex->token[lex->tokenl]  = 0; // add final null\n    return jsvNewFromString(lex->token);\n  }\n}\n\nbool jslIsIDOrReservedWord() {\n  return lex->tk == LEX_ID ||\n         (lex->tk >= _LEX_R_LIST_START && lex->tk <= _LEX_R_LIST_END);\n}\n\n/* Match failed - report error message */\nstatic void jslMatchError(int expected_tk) {\n  char gotStr[30];\n  char expStr[30];\n  jslGetTokenString(gotStr, sizeof(gotStr));\n  jslTokenAsString(expected_tk, expStr, sizeof(expStr));\n\n  size_t oldPos = lex->tokenLastStart;\n  lex->tokenLastStart = jsvStringIteratorGetIndex(&lex->tokenStart.it)-1;\n  jsExceptionHere(JSET_SYNTAXERROR, \"Got %s expected %s\", gotStr, expStr);\n  lex->tokenLastStart = oldPos;\n  // Sod it, skip this token anyway - stops us looping\n  jslGetNextToken();\n}\n\n/// Match, and return true on success, false on failure\nbool jslMatch(int expected_tk) {\n  if (lex->tk != expected_tk) {\n    jslMatchError(expected_tk);\n    return false;\n  }\n  jslGetNextToken();\n  return true;\n}\n\nJsVar *jslNewTokenisedStringFromLexer(JslCharPos *charFrom, size_t charTo) {\n  // New method - tokenise functions\n  // save old lex\n  JsLex *oldLex = lex;\n  JsLex newLex;\n  lex = &newLex;\n  // work out length\n  size_t length = 0;\n  jslInit(oldLex->sourceVar);\n  jslSeekToP(charFrom);\n  int lastTk = LEX_EOF;\n  while (lex->tk!=LEX_EOF && jsvStringIteratorGetIndex(&lex->it)<=charTo+1) {\n    if ((lex->tk==LEX_ID || lex->tk==LEX_FLOAT || lex->tk==LEX_INT) &&\n        ( lastTk==LEX_ID ||  lastTk==LEX_FLOAT ||  lastTk==LEX_INT)) {\n      jsExceptionHere(JSET_SYNTAXERROR, \"ID/number following ID/number isn't valid JS\");\n      length = 0;\n      break;\n    }\n    if (lex->tk==LEX_ID ||\n        lex->tk==LEX_INT ||\n        lex->tk==LEX_FLOAT ||\n        lex->tk==LEX_STR ||\n        lex->tk==LEX_TEMPLATE_LITERAL) {\n      length += jsvStringIteratorGetIndex(&lex->it)-jsvStringIteratorGetIndex(&lex->tokenStart.it);\n    } else {\n      length++;\n    }\n    lastTk = lex->tk;\n    jslGetNextToken();\n  }\n\n  // Try and create a flat string first\n  JsVar *var = jsvNewStringOfLength((unsigned int)length, NULL);\n  if (var) { // out of memory\n    JsvStringIterator dstit;\n    jsvStringIteratorNew(&dstit, var, 0);\n    // now start appending\n    jslSeekToP(charFrom);\n    while (lex->tk!=LEX_EOF && jsvStringIteratorGetIndex(&lex->it)<=charTo+1) {\n      if (lex->tk==LEX_ID ||\n          lex->tk==LEX_INT ||\n          lex->tk==LEX_FLOAT ||\n          lex->tk==LEX_STR ||\n          lex->tk==LEX_TEMPLATE_LITERAL) {\n        jsvStringIteratorSetCharAndNext(&dstit, lex->tokenStart.currCh);\n        JsvStringIterator it = jsvStringIteratorClone(&lex->tokenStart.it);\n        while (jsvStringIteratorGetIndex(&it)+1 < jsvStringIteratorGetIndex(&lex->it)) {\n          jsvStringIteratorSetCharAndNext(&dstit, jsvStringIteratorGetChar(&it));\n          jsvStringIteratorNext(&it);\n        }\n        jsvStringIteratorFree(&it);\n      } else {\n        jsvStringIteratorSetCharAndNext(&dstit, (char)lex->tk);\n      }\n      lastTk = lex->tk;\n      jslGetNextToken();\n    }\n    jsvStringIteratorFree(&dstit);\n  }\n  // restore lex\n  jslKill();\n  lex = oldLex;\n\n  return var;\n}\n\nJsVar *jslNewStringFromLexer(JslCharPos *charFrom, size_t charTo) {\n  // Original method - just copy it verbatim\n  size_t maxLength = charTo + 1 - jsvStringIteratorGetIndex(&charFrom->it);\n  assert(maxLength>0); // will fail if 0\n  // Try and create a flat string first\n  JsVar *var = 0;\n  if (maxLength > JSV_FLAT_STRING_BREAK_EVEN) {\n    var = jsvNewFlatStringOfLength((unsigned int)maxLength);\n    if (var) {\n      // Flat string\n      char *flatPtr = jsvGetFlatStringPointer(var);\n      *(flatPtr++) = charFrom->currCh;\n      JsvStringIterator it = jsvStringIteratorClone(&charFrom->it);\n      while (jsvStringIteratorHasChar(&it) && (--maxLength>0)) {\n        *(flatPtr++) = jsvStringIteratorGetChar(&it);\n        jsvStringIteratorNext(&it);\n      }\n      jsvStringIteratorFree(&it);\n      return var;\n    }\n  }\n  // Non-flat string...\n  var = jsvNewFromEmptyString();\n  if (!var) { // out of memory\n    return 0;\n  }\n\n  //jsvAppendStringVar(var, lex->sourceVar, charFrom->it->index, (int)(charTo-charFrom));\n  JsVar *block = jsvLockAgain(var);\n  block->varData.str[0] = charFrom->currCh;\n  size_t blockChars = 1;\n\n  size_t l = maxLength;\n  // now start appending\n  JsvStringIterator it = jsvStringIteratorClone(&charFrom->it);\n  while (jsvStringIteratorHasChar(&it) && (--maxLength>0)) {\n    char ch = jsvStringIteratorGetChar(&it);\n    if (blockChars >= jsvGetMaxCharactersInVar(block)) {\n      jsvSetCharactersInVar(block, blockChars);\n      JsVar *next = jsvNewWithFlags(JSV_STRING_EXT_0);\n      if (!next) break; // out of memory\n      // we don't ref, because  StringExts are never reffed as they only have one owner (and ALWAYS have an owner)\n      jsvSetLastChild(block, jsvGetRef(next));\n      jsvUnLock(block);\n      block = next;\n      blockChars=0; // it's new, so empty\n    }\n    block->varData.str[blockChars++] = ch;\n    jsvStringIteratorNext(&it);\n  }\n  jsvSetCharactersInVar(block, blockChars);\n  jsvUnLock(block);\n  // Just make sure we only assert if there's a bug here. If we just ran out of memory or at end of string it's ok\n  assert((l == jsvGetStringLength(var)) || (jsErrorFlags&JSERR_MEMORY) || !jsvStringIteratorHasChar(&it));\n  jsvStringIteratorFree(&it);\n\n\n  return var;\n}\n\n/// Return the line number at the current character position (this isn't fast as it searches the string)\nunsigned int jslGetLineNumber() {\n  size_t line;\n  size_t col;\n  jsvGetLineAndCol(lex->sourceVar, jsvStringIteratorGetIndex(&lex->tokenStart.it)-1, &line, &col);\n  return (unsigned int)line;\n}\n\n/// Do we need a space between these two characters when printing a function's text?\nbool jslNeedSpaceBetween(unsigned char lastch, unsigned char ch) {\n  return (lastch>=_LEX_R_LIST_START || ch>=_LEX_R_LIST_START) &&\n         (lastch>=_LEX_R_LIST_START || isAlpha((char)lastch) || isNumeric((char)lastch)) &&\n         (ch>=_LEX_R_LIST_START || isAlpha((char)ch) || isNumeric((char)ch));\n}\n\nvoid jslPrintPosition(vcbprintf_callback user_callback, void *user_data, size_t tokenPos) {\n  size_t line,col;\n  jsvGetLineAndCol(lex->sourceVar, tokenPos, &line, &col);\n  if (lex->lineNumberOffset)\n    line += (size_t)lex->lineNumberOffset - 1;\n  cbprintf(user_callback, user_data, \"line %d col %d\\n\", line, col);\n}\n\nvoid jslPrintTokenLineMarker(vcbprintf_callback user_callback, void *user_data, size_t tokenPos, char *prefix) {\n  size_t line = 1,col = 1;\n  jsvGetLineAndCol(lex->sourceVar, tokenPos, &line, &col);\n  size_t startOfLine = jsvGetIndexFromLineAndCol(lex->sourceVar, line, 1);\n  size_t lineLength = jsvGetCharsOnLine(lex->sourceVar, line);\n  size_t prefixLength = 0;\n\n  if (prefix) {\n    user_callback(prefix, user_data);\n    prefixLength = strlen(prefix);\n  }\n\n  if (lineLength>60 && tokenPos-startOfLine>30) {\n    cbprintf(user_callback, user_data, \"...\");\n    size_t skipChars = tokenPos-30 - startOfLine;\n    startOfLine += 3+skipChars;\n    if (skipChars<=col)\n      col -= skipChars;\n    else\n      col = 0;\n    lineLength -= skipChars;\n  }\n\n  // print the string until the end of the line, or 60 chars (whichever is less)\n  int chars = 0;\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, lex->sourceVar, startOfLine);\n  unsigned char lastch = 0;\n  while (jsvStringIteratorHasChar(&it) && chars<60) {\n    unsigned char ch = (unsigned char)jsvStringIteratorGetChar(&it);\n    if (ch == '\\n') break;\n    if (jslNeedSpaceBetween(lastch, ch)) {\n      col++;\n      user_callback(\" \", user_data);\n    }\n    char buf[32];\n    jslFunctionCharAsString(ch, buf, sizeof(buf));\n    size_t len = strlen(buf);\n    col += len-1;\n    user_callback(buf, user_data);\n    chars++;\n    lastch = ch;\n    jsvStringIteratorNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n\n  if (lineLength > 60)\n    user_callback(\"...\", user_data);\n  user_callback(\"\\n\", user_data);\n  col += prefixLength;\n  while (col-- > 1) user_callback(\" \", user_data);\n  user_callback(\"^\\n\", user_data);\n}\n\n"], "fixing_code": ["/*\n * This file is part of Espruino, a JavaScript interpreter for Microcontrollers\n *\n * Copyright (C) 2013 Gordon Williams <gw@pur3.co.uk>\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * ----------------------------------------------------------------------------\n * Lexer (convert JsVar strings into a series of tokens)\n * ----------------------------------------------------------------------------\n */\n#include \"jslex.h\"\n\nJsLex *lex;\n\nJsLex *jslSetLex(JsLex *l) {\n  JsLex *old = lex;\n  lex = l;\n  return old;\n}\n\nvoid jslCharPosFree(JslCharPos *pos) {\n  jsvStringIteratorFree(&pos->it);\n}\n\nJslCharPos jslCharPosClone(JslCharPos *pos) {\n  JslCharPos p;\n  p.it = jsvStringIteratorClone(&pos->it);\n  p.currCh = pos->currCh;\n  return p;\n}\n\n/// Return the next character (do not move to the next character)\nstatic ALWAYS_INLINE char jslNextCh() {\n  return (char)(lex->it.ptr ? READ_FLASH_UINT8(&lex->it.ptr[lex->it.charIdx]) : 0);\n}\n\n/// Move on to the next character\nstatic void NO_INLINE jslGetNextCh() {\n  lex->currCh = jslNextCh();\n\n  /** NOTE: In this next bit, we DON'T LOCK OR UNLOCK.\n   * The String iterator we're basing on does, so every\n   * time we touch the iterator we have to re-lock it\n   */\n  lex->it.charIdx++;\n  if (lex->it.charIdx >= lex->it.charsInVar) {\n    lex->it.charIdx -= lex->it.charsInVar;\n    if (lex->it.var && jsvGetLastChild(lex->it.var)) {\n      lex->it.var = _jsvGetAddressOf(jsvGetLastChild(lex->it.var));\n      lex->it.ptr = &lex->it.var->varData.str[0];\n      lex->it.varIndex += lex->it.charsInVar;\n      lex->it.charsInVar = jsvGetCharactersInVar(lex->it.var);\n    } else {\n      lex->it.var = 0;\n      lex->it.ptr = 0;\n      lex->it.varIndex += lex->it.charsInVar;\n      lex->it.charsInVar = 0;\n    }\n  }\n}\n\nstatic ALWAYS_INLINE void jslTokenAppendChar(char ch) {\n  /* Add character to buffer but check it isn't too big.\n   * Also Leave ONE character at the end for null termination */\n  if (lex->tokenl < JSLEX_MAX_TOKEN_LENGTH-1) {\n    lex->token[lex->tokenl++] = ch;\n  }\n}\n\nstatic bool jslIsToken(const char *token, int startOffset) {\n  int i;\n  for (i=startOffset;i<lex->tokenl;i++) {\n    if (lex->token[i]!=token[i]) return false;\n    // if token is smaller than lex->token, there will be a null char\n    // which will be different from the token\n  }\n  return token[lex->tokenl] == 0; // only match if token ends now\n}\n\ntypedef enum {\n  JSLJT_ID,\n  JSLJT_NUMBER,\n  JSLJT_STRING,\n  JSLJT_SINGLECHAR,\n\n  JSLJT_EXCLAMATION,\n  JSLJT_PLUS,\n  JSLJT_MINUS,\n  JSLJT_AND,\n  JSLJT_OR,\n  JSLJT_PERCENT,\n  JSLJT_STAR,\n  JSLJT_TOPHAT,\n  JSLJT_FORWARDSLASH,\n  JSLJT_LESSTHAN,\n  JSLJT_EQUAL,\n  JSLJT_GREATERTHAN,\n} PACKED_FLAGS jslJumpTableEnum;\n\n#define jslJumpTableStart 33 // '!' - the first handled character\n#define jslJumpTableEnd 124 // '|' - the last handled character\nconst jslJumpTableEnum jslJumpTable[jslJumpTableEnd+1-jslJumpTableStart] = {\n    // 33\n    JSLJT_EXCLAMATION, // !\n    JSLJT_STRING, // \"\n    JSLJT_SINGLECHAR, // #\n    JSLJT_ID, // $\n    JSLJT_PERCENT, // %\n    JSLJT_AND, // &\n    JSLJT_STRING, // '\n    JSLJT_SINGLECHAR, // (\n    JSLJT_SINGLECHAR, // )\n    JSLJT_STAR, // *\n    JSLJT_PLUS, // +\n    JSLJT_SINGLECHAR, // ,\n    JSLJT_MINUS, // -\n    JSLJT_NUMBER, // . - special :/\n    JSLJT_FORWARDSLASH, // /\n    // 48\n    JSLJT_NUMBER, // 0\n    JSLJT_NUMBER, // 1\n    JSLJT_NUMBER, // 2\n    JSLJT_NUMBER, // 3\n    JSLJT_NUMBER, // 4\n    JSLJT_NUMBER, // 5\n    JSLJT_NUMBER, // 6\n    JSLJT_NUMBER, // 7\n    JSLJT_NUMBER, // 8\n    JSLJT_NUMBER, // 9\n    JSLJT_SINGLECHAR, // :\n    JSLJT_SINGLECHAR, // ;\n    JSLJT_LESSTHAN, // <\n    JSLJT_EQUAL, // =\n    JSLJT_GREATERTHAN, // >\n    JSLJT_SINGLECHAR, // ?\n    // 64\n    JSLJT_SINGLECHAR, // @\n    JSLJT_ID, // A\n    JSLJT_ID, // B\n    JSLJT_ID, // C\n    JSLJT_ID, // D\n    JSLJT_ID, // E\n    JSLJT_ID, // F\n    JSLJT_ID, // G\n    JSLJT_ID, // H\n    JSLJT_ID, // I\n    JSLJT_ID, // J\n    JSLJT_ID, // K\n    JSLJT_ID, // L\n    JSLJT_ID, // M\n    JSLJT_ID, // N\n    JSLJT_ID, // O\n    JSLJT_ID, // P\n    JSLJT_ID, // Q\n    JSLJT_ID, // R\n    JSLJT_ID, // S\n    JSLJT_ID, // T\n    JSLJT_ID, // U\n    JSLJT_ID, // V\n    JSLJT_ID, // W\n    JSLJT_ID, // X\n    JSLJT_ID, // Y\n    JSLJT_ID, // Z\n    JSLJT_SINGLECHAR, // [\n    JSLJT_SINGLECHAR, // \\ char\n    JSLJT_SINGLECHAR, // ]\n    JSLJT_TOPHAT, // ^\n    JSLJT_ID, // _\n    // 96\n    JSLJT_STRING, // `\n    JSLJT_ID, // A lowercase\n    JSLJT_ID, // B lowercase\n    JSLJT_ID, // C lowercase\n    JSLJT_ID, // D lowercase\n    JSLJT_ID, // E lowercase\n    JSLJT_ID, // F lowercase\n    JSLJT_ID, // G lowercase\n    JSLJT_ID, // H lowercase\n    JSLJT_ID, // I lowercase\n    JSLJT_ID, // J lowercase\n    JSLJT_ID, // K lowercase\n    JSLJT_ID, // L lowercase\n    JSLJT_ID, // M lowercase\n    JSLJT_ID, // N lowercase\n    JSLJT_ID, // O lowercase\n    JSLJT_ID, // P lowercase\n    JSLJT_ID, // Q lowercase\n    JSLJT_ID, // R lowercase\n    JSLJT_ID, // S lowercase\n    JSLJT_ID, // T lowercase\n    JSLJT_ID, // U lowercase\n    JSLJT_ID, // V lowercase\n    JSLJT_ID, // W lowercase\n    JSLJT_ID, // X lowercase\n    JSLJT_ID, // Y lowercase\n    JSLJT_ID, // Z lowercase\n    JSLJT_SINGLECHAR, // {\n    JSLJT_OR, // |\n    // everything past here is handled as a single char\n    //  JSLJT_SINGLECHAR, // }\n    //  JSLJT_SINGLECHAR, // ~\n};\n\n// handle a single char\nstatic ALWAYS_INLINE void jslSingleChar() {\n  lex->tk = (unsigned char)lex->currCh;\n  jslGetNextCh();\n}\n\nstatic void jslLexString() {\n  char delim = lex->currCh;\n  lex->tokenValue = jsvNewFromEmptyString();\n  if (!lex->tokenValue) {\n    lex->tk = LEX_EOF;\n    return;\n  }\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, lex->tokenValue, 0);\n  // strings...\n  jslGetNextCh();\n  while (lex->currCh && lex->currCh!=delim) {\n    if (lex->currCh == '\\\\') {\n      jslGetNextCh();\n      char ch = lex->currCh;\n      switch (lex->currCh) {\n      case 'n'  : ch = 0x0A; jslGetNextCh(); break;\n      case 'b'  : ch = 0x08; jslGetNextCh(); break;\n      case 'f'  : ch = 0x0C; jslGetNextCh(); break;\n      case 'r'  : ch = 0x0D; jslGetNextCh(); break;\n      case 't'  : ch = 0x09; jslGetNextCh(); break;\n      case 'v'  : ch = 0x0B; jslGetNextCh(); break;\n      case 'u' :\n      case 'x' : { // hex digits\n        char buf[5] = \"0x??\";\n        if (lex->currCh == 'u') {\n          // We don't support unicode, so we just take the bottom 8 bits\n          // of the unicode character\n          jslGetNextCh();\n          jslGetNextCh();\n        }\n        jslGetNextCh();\n        buf[2] = lex->currCh; jslGetNextCh();\n        buf[3] = lex->currCh; jslGetNextCh();\n        ch = (char)stringToInt(buf);\n      } break;\n      default:\n        if (lex->currCh>='0' && lex->currCh<='7') {\n          // octal digits\n          char buf[5] = \"0\";\n          buf[1] = lex->currCh;\n          int n=2;\n          jslGetNextCh();\n          if (lex->currCh>='0' && lex->currCh<='7') {\n            buf[n++] = lex->currCh; jslGetNextCh();\n            if (lex->currCh>='0' && lex->currCh<='7') {\n              buf[n++] = lex->currCh; jslGetNextCh();\n            }\n          }\n          buf[n]=0;\n          ch = (char)stringToInt(buf);\n        } else {\n          // for anything else, just push the character through\n          jslGetNextCh();\n        }\n        break;\n      }\n      jslTokenAppendChar(ch);\n      jsvStringIteratorAppend(&it, ch);\n    } else if (lex->currCh=='\\n' && delim!='`') {\n      /* Was a newline - this is now allowed\n       * unless we're a template string */\n      break;\n    } else {\n      jslTokenAppendChar(lex->currCh);\n      jsvStringIteratorAppend(&it, lex->currCh);\n      jslGetNextCh();\n    }\n  }\n  jsvStringIteratorFree(&it);\n  if (delim=='`')\n    lex->tk = LEX_TEMPLATE_LITERAL;\n  else lex->tk = LEX_STR;\n  // unfinished strings\n  if (lex->currCh!=delim)\n    lex->tk++; // +1 gets you to 'unfinished X'\n  jslGetNextCh();\n}\n\nstatic void jslLexRegex() {\n  lex->tokenValue = jsvNewFromEmptyString();\n  if (!lex->tokenValue) {\n    lex->tk = LEX_EOF;\n    return;\n  }\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, lex->tokenValue, 0);\n  jsvStringIteratorAppend(&it, '/');\n  // strings...\n  jslGetNextCh();\n  while (lex->currCh && lex->currCh!='/') {\n    if (lex->currCh == '\\\\') {\n      jsvStringIteratorAppend(&it, lex->currCh);\n      jslGetNextCh();\n    } else if (lex->currCh=='\\n') {\n      /* Was a newline - this is now allowed\n       * unless we're a template string */\n      break;\n    }\n    jsvStringIteratorAppend(&it, lex->currCh);\n    jslGetNextCh();\n  }\n  lex->tk = LEX_REGEX;\n  if (lex->currCh!='/') {\n    lex->tk++; // +1 gets you to 'unfinished X'\n  } else {\n    jsvStringIteratorAppend(&it, '/');\n    jslGetNextCh();\n    // regex modifiers\n    while (lex->currCh=='g' ||\n        lex->currCh=='i' ||\n        lex->currCh=='m' ||\n        lex->currCh=='y' ||\n        lex->currCh=='u') {\n      jslTokenAppendChar(lex->currCh);\n      jsvStringIteratorAppend(&it, lex->currCh);\n      jslGetNextCh();\n    }\n  }\n  jsvStringIteratorFree(&it);\n}\n\nvoid jslGetNextToken() {\n  jslGetNextToken_start:\n  // Skip whitespace\n  while (isWhitespace(lex->currCh))\n    jslGetNextCh();\n  // Search for comments\n  if (lex->currCh=='/') {\n    // newline comments\n    if (jslNextCh()=='/') {\n      while (lex->currCh && lex->currCh!='\\n') jslGetNextCh();\n      jslGetNextCh();\n      goto jslGetNextToken_start;\n    }\n    // block comments\n    if (jslNextCh()=='*') {\n      jslGetNextCh();\n      jslGetNextCh();\n      while (lex->currCh && !(lex->currCh=='*' && jslNextCh()=='/'))\n        jslGetNextCh();\n      if (!lex->currCh) {\n        lex->tk = LEX_UNFINISHED_COMMENT;\n        return; /* an unfinished multi-line comment. When in interactive console,\n                   detect this and make sure we accept new lines */\n      }\n      jslGetNextCh();\n      jslGetNextCh();\n      goto jslGetNextToken_start;\n    }\n  }\n  int lastToken = lex->tk;\n  lex->tk = LEX_EOF;\n  lex->tokenl = 0; // clear token string\n  if (lex->tokenValue) {\n    jsvUnLock(lex->tokenValue);\n    lex->tokenValue = 0;\n  }\n  // record beginning of this token\n  lex->tokenLastStart = jsvStringIteratorGetIndex(&lex->tokenStart.it) - 1;\n  /* we don't lock here, because we know that the string itself will be locked\n   * because of lex->sourceVar */\n  lex->tokenStart.it = lex->it;\n  lex->tokenStart.currCh = lex->currCh;\n  // tokens\n  if (((unsigned char)lex->currCh) < jslJumpTableStart ||\n      ((unsigned char)lex->currCh) > jslJumpTableEnd) {\n    // if unhandled by the jump table, just pass it through as a single character\n    jslSingleChar();\n  } else {\n    switch(jslJumpTable[((unsigned char)lex->currCh) - jslJumpTableStart]) {\n    case JSLJT_ID: {\n      while (isAlpha(lex->currCh) || isNumeric(lex->currCh) || lex->currCh=='$') {\n        jslTokenAppendChar(lex->currCh);\n        jslGetNextCh();\n      }\n      lex->tk = LEX_ID;\n      // We do fancy stuff here to reduce number of compares (hopefully GCC creates a jump table)\n      switch (lex->token[0]) {\n      case 'b': if (jslIsToken(\"break\", 1)) lex->tk = LEX_R_BREAK;\n      break;\n      case 'c': if (jslIsToken(\"case\", 1)) lex->tk = LEX_R_CASE;\n      else if (jslIsToken(\"catch\", 1)) lex->tk = LEX_R_CATCH;\n      else if (jslIsToken(\"class\", 1)) lex->tk = LEX_R_CLASS;\n      else if (jslIsToken(\"const\", 1)) lex->tk = LEX_R_CONST;\n      else if (jslIsToken(\"continue\", 1)) lex->tk = LEX_R_CONTINUE;\n      break;\n      case 'd': if (jslIsToken(\"default\", 1)) lex->tk = LEX_R_DEFAULT;\n      else if (jslIsToken(\"delete\", 1)) lex->tk = LEX_R_DELETE;\n      else if (jslIsToken(\"do\", 1)) lex->tk = LEX_R_DO;\n      else if (jslIsToken(\"debugger\", 1)) lex->tk = LEX_R_DEBUGGER;\n      break;\n      case 'e': if (jslIsToken(\"else\", 1)) lex->tk = LEX_R_ELSE;\n      else if (jslIsToken(\"extends\", 1)) lex->tk = LEX_R_EXTENDS;\n      break;\n      case 'f': if (jslIsToken(\"false\", 1)) lex->tk = LEX_R_FALSE;\n      else if (jslIsToken(\"finally\", 1)) lex->tk = LEX_R_FINALLY;\n      else if (jslIsToken(\"for\", 1)) lex->tk = LEX_R_FOR;\n      else if (jslIsToken(\"function\", 1)) lex->tk = LEX_R_FUNCTION;\n      break;\n      case 'i': if (jslIsToken(\"if\", 1)) lex->tk = LEX_R_IF;\n      else if (jslIsToken(\"in\", 1)) lex->tk = LEX_R_IN;\n      else if (jslIsToken(\"instanceof\", 1)) lex->tk = LEX_R_INSTANCEOF;\n      break;\n      case 'l': if (jslIsToken(\"let\", 1)) lex->tk = LEX_R_LET;\n      break;\n      case 'n': if (jslIsToken(\"new\", 1)) lex->tk = LEX_R_NEW;\n      else if (jslIsToken(\"null\", 1)) lex->tk = LEX_R_NULL;\n      break;\n      case 'r': if (jslIsToken(\"return\", 1)) lex->tk = LEX_R_RETURN;\n      break;\n      case 's': if (jslIsToken(\"static\", 1)) lex->tk = LEX_R_STATIC;\n      else if (jslIsToken(\"super\", 1)) lex->tk = LEX_R_SUPER;\n      else if (jslIsToken(\"switch\", 1)) lex->tk = LEX_R_SWITCH;\n      break;\n      case 't': if (jslIsToken(\"this\", 1)) lex->tk = LEX_R_THIS;\n      else if (jslIsToken(\"throw\", 1)) lex->tk = LEX_R_THROW;\n      else if (jslIsToken(\"true\", 1)) lex->tk = LEX_R_TRUE;\n      else if (jslIsToken(\"try\", 1)) lex->tk = LEX_R_TRY;\n      else if (jslIsToken(\"typeof\", 1)) lex->tk = LEX_R_TYPEOF;\n      break;\n      case 'u': if (jslIsToken(\"undefined\", 1)) lex->tk = LEX_R_UNDEFINED;\n      break;\n      case 'w': if (jslIsToken(\"while\", 1)) lex->tk = LEX_R_WHILE;\n      break;\n      case 'v': if (jslIsToken(\"var\", 1)) lex->tk = LEX_R_VAR;\n      else if (jslIsToken(\"void\", 1)) lex->tk = LEX_R_VOID;\n      break;\n      default: break;\n      } break;\n      case JSLJT_NUMBER: {\n        // TODO: check numbers aren't the wrong format\n        bool canBeFloating = true;\n        if (lex->currCh=='.') {\n          jslGetNextCh();\n          if (isNumeric(lex->currCh)) {\n            // it is a float\n            lex->tk = LEX_FLOAT;\n            jslTokenAppendChar('.');\n          } else {\n            // it wasn't a number after all\n            lex->tk = '.';\n            break;\n          }\n        } else {\n          if (lex->currCh=='0') {\n            jslTokenAppendChar(lex->currCh);\n            jslGetNextCh();\n            if ((lex->currCh=='x' || lex->currCh=='X') ||\n                (lex->currCh=='b' || lex->currCh=='B') ||\n                (lex->currCh=='o' || lex->currCh=='O')) {\n              canBeFloating = false;\n              jslTokenAppendChar(lex->currCh); jslGetNextCh();\n            }\n          }\n          lex->tk = LEX_INT;\n          while (isNumeric(lex->currCh) || (!canBeFloating && isHexadecimal(lex->currCh))) {\n            jslTokenAppendChar(lex->currCh);\n            jslGetNextCh();\n          }\n          if (canBeFloating && lex->currCh=='.') {\n            lex->tk = LEX_FLOAT;\n            jslTokenAppendChar('.');\n            jslGetNextCh();\n          }\n        }\n        // parse fractional part\n        if (lex->tk == LEX_FLOAT) {\n          while (isNumeric(lex->currCh)) {\n            jslTokenAppendChar(lex->currCh);\n            jslGetNextCh();\n          }\n        }\n        // do fancy e-style floating point\n        if (canBeFloating && (lex->currCh=='e'||lex->currCh=='E')) {\n          lex->tk = LEX_FLOAT;\n          jslTokenAppendChar(lex->currCh); jslGetNextCh();\n          if (lex->currCh=='-' || lex->currCh=='+') { jslTokenAppendChar(lex->currCh); jslGetNextCh(); }\n          while (isNumeric(lex->currCh)) {\n            jslTokenAppendChar(lex->currCh); jslGetNextCh();\n          }\n        }\n      } break;\n      case JSLJT_STRING: jslLexString(); break;\n      case JSLJT_EXCLAMATION: jslSingleChar();\n      if (lex->currCh=='=') { // !=\n        lex->tk = LEX_NEQUAL;\n        jslGetNextCh();\n        if (lex->currCh=='=') { // !==\n          lex->tk = LEX_NTYPEEQUAL;\n          jslGetNextCh();\n        }\n      } break;\n      case JSLJT_PLUS: jslSingleChar();\n      if (lex->currCh=='=') {\n        lex->tk = LEX_PLUSEQUAL;\n        jslGetNextCh();\n      } else if (lex->currCh=='+') {\n        lex->tk = LEX_PLUSPLUS;\n        jslGetNextCh();\n      } break;\n      case JSLJT_MINUS: jslSingleChar();\n      if (lex->currCh=='=') {\n        lex->tk = LEX_MINUSEQUAL;\n        jslGetNextCh();\n      } else if (lex->currCh=='-') {\n        lex->tk = LEX_MINUSMINUS;\n        jslGetNextCh();\n      } break;\n      case JSLJT_AND: jslSingleChar();\n      if (lex->currCh=='=') {\n        lex->tk = LEX_ANDEQUAL;\n        jslGetNextCh();\n      } else if (lex->currCh=='&') {\n        lex->tk = LEX_ANDAND;\n        jslGetNextCh();\n      } break;\n      case JSLJT_OR: jslSingleChar();\n      if (lex->currCh=='=') {\n        lex->tk = LEX_OREQUAL;\n        jslGetNextCh();\n      } else if (lex->currCh=='|') {\n        lex->tk = LEX_OROR;\n        jslGetNextCh();\n      } break;\n      case JSLJT_TOPHAT: jslSingleChar();\n      if (lex->currCh=='=') {\n        lex->tk = LEX_XOREQUAL;\n        jslGetNextCh();\n      } break;\n      case JSLJT_STAR: jslSingleChar();\n      if (lex->currCh=='=') {\n        lex->tk = LEX_MULEQUAL;\n        jslGetNextCh();\n      } break;\n      case JSLJT_FORWARDSLASH:\n      // yay! JS is so awesome.\n      if (lastToken==LEX_EOF ||\n          lastToken=='!' ||\n          lastToken=='%' ||\n          lastToken=='&' ||\n          lastToken=='*' ||\n          lastToken=='+' ||\n          lastToken=='-' ||\n          lastToken=='/' ||\n          lastToken=='<' ||\n          lastToken=='=' ||\n          lastToken=='>' ||\n          lastToken=='?' ||\n          (lastToken>=_LEX_OPERATOR_START && lastToken<=_LEX_OPERATOR_END) ||\n          (lastToken>=_LEX_R_LIST_START && lastToken<=_LEX_R_LIST_END) || // keywords\n          lastToken==LEX_R_CASE ||\n          lastToken==LEX_R_NEW ||\n          lastToken=='[' ||\n          lastToken=='{' ||\n          lastToken=='}' ||\n          lastToken=='(' ||\n          lastToken==',' ||\n          lastToken==';' ||\n          lastToken==':' ||\n          lastToken==LEX_ARROW_FUNCTION) {\n        // EOF operator keyword case new [ { } ( , ; : =>\n        // phew. We're a regex\n        jslLexRegex();\n      } else {\n        jslSingleChar();\n        if (lex->currCh=='=') {\n          lex->tk = LEX_DIVEQUAL;\n          jslGetNextCh();\n        }\n      } break;\n      case JSLJT_PERCENT: jslSingleChar();\n      if (lex->currCh=='=') {\n        lex->tk = LEX_MODEQUAL;\n        jslGetNextCh();\n      } break;\n      case JSLJT_EQUAL: jslSingleChar();\n      if (lex->currCh=='=') { // ==\n        lex->tk = LEX_EQUAL;\n        jslGetNextCh();\n        if (lex->currCh=='=') { // ===\n          lex->tk = LEX_TYPEEQUAL;\n          jslGetNextCh();\n        }\n      } else if (lex->currCh=='>') { // =>\n        lex->tk = LEX_ARROW_FUNCTION;\n        jslGetNextCh();\n      } break;\n      case JSLJT_LESSTHAN: jslSingleChar();\n      if (lex->currCh=='=') { // <=\n        lex->tk = LEX_LEQUAL;\n        jslGetNextCh();\n      } else if (lex->currCh=='<') { // <<\n        lex->tk = LEX_LSHIFT;\n        jslGetNextCh();\n        if (lex->currCh=='=') { // <<=\n          lex->tk = LEX_LSHIFTEQUAL;\n          jslGetNextCh();\n        }\n      } break;\n      case JSLJT_GREATERTHAN: jslSingleChar();\n      if (lex->currCh=='=') { // >=\n        lex->tk = LEX_GEQUAL;\n        jslGetNextCh();\n      } else if (lex->currCh=='>') { // >>\n        lex->tk = LEX_RSHIFT;\n        jslGetNextCh();\n        if (lex->currCh=='=') { // >>=\n          lex->tk = LEX_RSHIFTEQUAL;\n          jslGetNextCh();\n        } else if (lex->currCh=='>') { // >>>\n          jslGetNextCh();\n          if (lex->currCh=='=') { // >>>=\n            lex->tk = LEX_RSHIFTUNSIGNEDEQUAL;\n            jslGetNextCh();\n          } else {\n            lex->tk = LEX_RSHIFTUNSIGNED;\n          }\n        }\n      } break;\n\n      case JSLJT_SINGLECHAR: jslSingleChar(); break;\n      default: assert(0);break;\n    }\n    }\n  }\n}\n\nstatic ALWAYS_INLINE void jslPreload() {\n  // set up..\n  jslGetNextCh();\n  jslGetNextToken();\n}\n\nvoid jslInit(JsVar *var) {\n  lex->sourceVar = jsvLockAgain(var);\n  // reset stuff\n  lex->tk = 0;\n  lex->tokenStart.it.var = 0;\n  lex->tokenStart.currCh = 0;\n  lex->tokenLastStart = 0;\n  lex->tokenl = 0;\n  lex->tokenValue = 0;\n  lex->lineNumberOffset = 0;\n  // set up iterator\n  jsvStringIteratorNew(&lex->it, lex->sourceVar, 0);\n  jsvUnLock(lex->it.var); // see jslGetNextCh\n  jslPreload();\n}\n\nvoid jslKill() {\n  lex->tk = LEX_EOF; // safety ;)\n  if (lex->it.var) jsvLockAgain(lex->it.var); // see jslGetNextCh\n  jsvStringIteratorFree(&lex->it);\n  if (lex->tokenValue) {\n    jsvUnLock(lex->tokenValue);\n    lex->tokenValue = 0;\n  }\n  jsvUnLock(lex->sourceVar);\n  lex->tokenStart.it.var = 0;\n  lex->tokenStart.currCh = 0;\n}\n\nvoid jslSeekTo(size_t seekToChar) {\n  if (lex->it.var) jsvLockAgain(lex->it.var); // see jslGetNextCh\n  jsvStringIteratorFree(&lex->it);\n  jsvStringIteratorNew(&lex->it, lex->sourceVar, seekToChar);\n  jsvUnLock(lex->it.var); // see jslGetNextCh\n  lex->tokenStart.it.var = 0;\n  lex->tokenStart.currCh = 0;\n  jslPreload();\n}\n\nvoid jslSeekToP(JslCharPos *seekToChar) {\n  if (lex->it.var) jsvLockAgain(lex->it.var); // see jslGetNextCh\n  jsvStringIteratorFree(&lex->it);\n  lex->it = jsvStringIteratorClone(&seekToChar->it);\n  jsvUnLock(lex->it.var); // see jslGetNextCh\n  lex->currCh = seekToChar->currCh;\n  lex->tokenStart.it.var = 0;\n  lex->tokenStart.currCh = 0;\n  jslGetNextToken();\n}\n\nvoid jslReset() {\n  jslSeekTo(0);\n}\n\n\n\n/** When printing out a function, with pretokenise a\n * character could end up being a special token. This\n * handles that case. */\nvoid jslFunctionCharAsString(unsigned char ch, char *str, size_t len) {\n  if (ch >= LEX_TOKEN_START) {\n    jslTokenAsString(ch, str, len);\n  } else {\n    str[0] = (char)ch;\n    str[1] = 0;\n  }\n}\n\nvoid jslTokenAsString(int token, char *str, size_t len) {\n  assert(len>28); // size of largest string\n  // see JS_ERROR_TOKEN_BUF_SIZE\n  if (token>32 && token<128) {\n    assert(len>=4);\n    str[0] = '\\'';\n    str[1] = (char)token;\n    str[2] = '\\'';\n    str[3] = 0;\n    return;\n  }\n\n\n  switch (token) {\n  case LEX_EOF : strcpy(str, \"EOF\"); return;\n  case LEX_ID : strcpy(str, \"ID\"); return;\n  case LEX_INT : strcpy(str, \"INT\"); return;\n  case LEX_FLOAT : strcpy(str, \"FLOAT\"); return;\n  case LEX_STR : strcpy(str, \"STRING\"); return;\n  case LEX_UNFINISHED_STR : strcpy(str, \"UNFINISHED STRING\"); return;\n  case LEX_TEMPLATE_LITERAL : strcpy(str, \"TEMPLATE LITERAL\"); return;\n  case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy(str, \"UNFINISHED TEMPLATE LITERAL\"); return;\n  case LEX_REGEX : strcpy(str, \"REGEX\"); return;\n  case LEX_UNFINISHED_REGEX : strcpy(str, \"UNFINISHED REGEX\"); return;\n  case LEX_UNFINISHED_COMMENT : strcpy(str, \"UNFINISHED COMMENT\"); return;\n  }\n  if (token>=_LEX_OPERATOR_START && token<_LEX_R_LIST_END) {\n    const char tokenNames[] =\n        /* LEX_EQUAL      :   */ \"==\\0\"\n        /* LEX_TYPEEQUAL  :   */ \"===\\0\"\n        /* LEX_NEQUAL     :   */ \"!=\\0\"\n        /* LEX_NTYPEEQUAL :   */ \"!==\\0\"\n        /* LEX_LEQUAL    :    */ \"<=\\0\"\n        /* LEX_LSHIFT     :   */ \"<<\\0\"\n        /* LEX_LSHIFTEQUAL :  */ \"<<=\\0\"\n        /* LEX_GEQUAL      :  */ \">=\\0\"\n        /* LEX_RSHIFT      :  */ \">>\\0\"\n        /* LEX_RSHIFTUNSIGNED */ \">>>\\0\"\n        /* LEX_RSHIFTEQUAL :  */ \">>=\\0\"\n        /* LEX_RSHIFTUNSIGNEDEQUAL */ \">>>=\\0\"\n        /* LEX_PLUSEQUAL   :  */ \"+=\\0\"\n        /* LEX_MINUSEQUAL  :  */ \"-=\\0\"\n        /* LEX_PLUSPLUS :     */ \"++\\0\"\n        /* LEX_MINUSMINUS     */ \"--\\0\"\n        /* LEX_MULEQUAL :     */ \"*=\\0\"\n        /* LEX_DIVEQUAL :     */ \"/=\\0\"\n        /* LEX_MODEQUAL :     */ \"%=\\0\"\n        /* LEX_ANDEQUAL :     */ \"&=\\0\"\n        /* LEX_ANDAND :       */ \"&&\\0\"\n        /* LEX_OREQUAL :      */ \"|=\\0\"\n        /* LEX_OROR :         */ \"||\\0\"\n        /* LEX_XOREQUAL :     */ \"^=\\0\"\n        /* LEX_ARROW_FUNCTION */ \"=>\\0\"\n\n        // reserved words\n        /*LEX_R_IF :       */ \"if\\0\"\n        /*LEX_R_ELSE :     */ \"else\\0\"\n        /*LEX_R_DO :       */ \"do\\0\"\n        /*LEX_R_WHILE :    */ \"while\\0\"\n        /*LEX_R_FOR :      */ \"for\\0\"\n        /*LEX_R_BREAK :    */ \"return\\0\"\n        /*LEX_R_CONTINUE   */ \"continue\\0\"\n        /*LEX_R_FUNCTION   */ \"function\\0\"\n        /*LEX_R_RETURN     */ \"return\\0\"\n        /*LEX_R_VAR :      */ \"var\\0\"\n        /*LEX_R_LET :      */ \"let\\0\"\n        /*LEX_R_CONST :    */ \"const\\0\"\n        /*LEX_R_THIS :     */ \"this\\0\"\n        /*LEX_R_THROW :    */ \"throw\\0\"\n        /*LEX_R_TRY :      */ \"try\\0\"\n        /*LEX_R_CATCH :    */ \"catch\\0\"\n        /*LEX_R_FINALLY :  */ \"finally\\0\"\n        /*LEX_R_TRUE :     */ \"true\\0\"\n        /*LEX_R_FALSE :    */ \"false\\0\"\n        /*LEX_R_NULL :     */ \"null\\0\"\n        /*LEX_R_UNDEFINED  */ \"undefined\\0\"\n        /*LEX_R_NEW :      */ \"new\\0\"\n        /*LEX_R_IN :       */ \"in\\0\"\n        /*LEX_R_INSTANCEOF */ \"instanceof\\0\"\n        /*LEX_R_SWITCH     */ \"switch\\0\"\n        /*LEX_R_CASE       */ \"case\\0\"\n        /*LEX_R_DEFAULT    */ \"default\\0\"\n        /*LEX_R_DELETE     */ \"delete\\0\"\n        /*LEX_R_TYPEOF :   */ \"typeof\\0\"\n        /*LEX_R_VOID :     */ \"void\\0\"\n        /*LEX_R_DEBUGGER : */ \"debugger\\0\"\n        /*LEX_R_CLASS :    */ \"class\\0\"\n        /*LEX_R_EXTENDS :  */ \"extends\\0\"\n        /*LEX_R_SUPER :  */   \"super\\0\"\n        /*LEX_R_STATIC :   */ \"static\\0\"\n        ;\n    unsigned int p = 0;\n    int n = token-_LEX_OPERATOR_START;\n    while (n>0 && p<sizeof(tokenNames)) {\n      while (tokenNames[p] && p<sizeof(tokenNames)) p++;\n      p++; // skip the zero\n      n--; // next token\n    }\n    assert(n==0);\n    strcpy(str, &tokenNames[p]);\n    return;\n  }\n\n  espruino_snprintf(str, len, \"?[%d]\", token);\n}\n\nvoid jslGetTokenString(char *str, size_t len) {\n  if (lex->tk == LEX_ID) {\n    espruino_snprintf(str, len, \"ID:%s\", jslGetTokenValueAsString());\n  } else if (lex->tk == LEX_STR) {\n    espruino_snprintf(str, len, \"String:'%s'\", jslGetTokenValueAsString());\n  } else\n    jslTokenAsString(lex->tk, str, len);\n}\n\nchar *jslGetTokenValueAsString() {\n  assert(lex->tokenl < JSLEX_MAX_TOKEN_LENGTH);\n  lex->token[lex->tokenl]  = 0; // add final null\n  return lex->token;\n}\n\nint jslGetTokenLength() {\n  return lex->tokenl;\n}\n\nJsVar *jslGetTokenValueAsVar() {\n  if (lex->tokenValue) {\n    return jsvLockAgain(lex->tokenValue);\n  } else {\n    assert(lex->tokenl < JSLEX_MAX_TOKEN_LENGTH);\n    lex->token[lex->tokenl]  = 0; // add final null\n    return jsvNewFromString(lex->token);\n  }\n}\n\nbool jslIsIDOrReservedWord() {\n  return lex->tk == LEX_ID ||\n         (lex->tk >= _LEX_R_LIST_START && lex->tk <= _LEX_R_LIST_END);\n}\n\n/* Match failed - report error message */\nstatic void jslMatchError(int expected_tk) {\n  char gotStr[30];\n  char expStr[30];\n  jslGetTokenString(gotStr, sizeof(gotStr));\n  jslTokenAsString(expected_tk, expStr, sizeof(expStr));\n\n  size_t oldPos = lex->tokenLastStart;\n  lex->tokenLastStart = jsvStringIteratorGetIndex(&lex->tokenStart.it)-1;\n  jsExceptionHere(JSET_SYNTAXERROR, \"Got %s expected %s\", gotStr, expStr);\n  lex->tokenLastStart = oldPos;\n  // Sod it, skip this token anyway - stops us looping\n  jslGetNextToken();\n}\n\n/// Match, and return true on success, false on failure\nbool jslMatch(int expected_tk) {\n  if (lex->tk != expected_tk) {\n    jslMatchError(expected_tk);\n    return false;\n  }\n  jslGetNextToken();\n  return true;\n}\n\nJsVar *jslNewTokenisedStringFromLexer(JslCharPos *charFrom, size_t charTo) {\n  // New method - tokenise functions\n  // save old lex\n  JsLex *oldLex = lex;\n  JsLex newLex;\n  lex = &newLex;\n  // work out length\n  size_t length = 0;\n  jslInit(oldLex->sourceVar);\n  jslSeekToP(charFrom);\n  int lastTk = LEX_EOF;\n  while (lex->tk!=LEX_EOF && jsvStringIteratorGetIndex(&lex->it)<=charTo+1) {\n    if ((lex->tk==LEX_ID || lex->tk==LEX_FLOAT || lex->tk==LEX_INT) &&\n        ( lastTk==LEX_ID ||  lastTk==LEX_FLOAT ||  lastTk==LEX_INT)) {\n      jsExceptionHere(JSET_SYNTAXERROR, \"ID/number following ID/number isn't valid JS\");\n      length = 0;\n      break;\n    }\n    if (lex->tk==LEX_ID ||\n        lex->tk==LEX_INT ||\n        lex->tk==LEX_FLOAT ||\n        lex->tk==LEX_STR ||\n        lex->tk==LEX_TEMPLATE_LITERAL) {\n      length += jsvStringIteratorGetIndex(&lex->it)-jsvStringIteratorGetIndex(&lex->tokenStart.it);\n    } else {\n      length++;\n    }\n    lastTk = lex->tk;\n    jslGetNextToken();\n  }\n\n  // Try and create a flat string first\n  JsVar *var = jsvNewStringOfLength((unsigned int)length, NULL);\n  if (var) { // out of memory\n    JsvStringIterator dstit;\n    jsvStringIteratorNew(&dstit, var, 0);\n    // now start appending\n    jslSeekToP(charFrom);\n    while (lex->tk!=LEX_EOF && jsvStringIteratorGetIndex(&lex->it)<=charTo+1) {\n      if (lex->tk==LEX_ID ||\n          lex->tk==LEX_INT ||\n          lex->tk==LEX_FLOAT ||\n          lex->tk==LEX_STR ||\n          lex->tk==LEX_TEMPLATE_LITERAL) {\n        jsvStringIteratorSetCharAndNext(&dstit, lex->tokenStart.currCh);\n        JsvStringIterator it = jsvStringIteratorClone(&lex->tokenStart.it);\n        while (jsvStringIteratorGetIndex(&it)+1 < jsvStringIteratorGetIndex(&lex->it)) {\n          jsvStringIteratorSetCharAndNext(&dstit, jsvStringIteratorGetChar(&it));\n          jsvStringIteratorNext(&it);\n        }\n        jsvStringIteratorFree(&it);\n      } else {\n        jsvStringIteratorSetCharAndNext(&dstit, (char)lex->tk);\n      }\n      lastTk = lex->tk;\n      jslGetNextToken();\n    }\n    jsvStringIteratorFree(&dstit);\n  }\n  // restore lex\n  jslKill();\n  lex = oldLex;\n\n  return var;\n}\n\nJsVar *jslNewStringFromLexer(JslCharPos *charFrom, size_t charTo) {\n  // Original method - just copy it verbatim\n  size_t maxLength = charTo + 1 - jsvStringIteratorGetIndex(&charFrom->it);\n  assert(maxLength>0); // will fail if 0\n  // Try and create a flat string first\n  JsVar *var = 0;\n  if (maxLength > JSV_FLAT_STRING_BREAK_EVEN) {\n    var = jsvNewFlatStringOfLength((unsigned int)maxLength);\n    if (var) {\n      // Flat string\n      char *flatPtr = jsvGetFlatStringPointer(var);\n      *(flatPtr++) = charFrom->currCh;\n      JsvStringIterator it = jsvStringIteratorClone(&charFrom->it);\n      while (jsvStringIteratorHasChar(&it) && (--maxLength>0)) {\n        *(flatPtr++) = jsvStringIteratorGetChar(&it);\n        jsvStringIteratorNext(&it);\n      }\n      jsvStringIteratorFree(&it);\n      return var;\n    }\n  }\n  // Non-flat string...\n  var = jsvNewFromEmptyString();\n  if (!var) { // out of memory\n    return 0;\n  }\n\n  //jsvAppendStringVar(var, lex->sourceVar, charFrom->it->index, (int)(charTo-charFrom));\n  JsVar *block = jsvLockAgain(var);\n  block->varData.str[0] = charFrom->currCh;\n  size_t blockChars = 1;\n\n  size_t l = maxLength;\n  // now start appending\n  JsvStringIterator it = jsvStringIteratorClone(&charFrom->it);\n  while (jsvStringIteratorHasChar(&it) && (--maxLength>0)) {\n    char ch = jsvStringIteratorGetChar(&it);\n    if (blockChars >= jsvGetMaxCharactersInVar(block)) {\n      jsvSetCharactersInVar(block, blockChars);\n      JsVar *next = jsvNewWithFlags(JSV_STRING_EXT_0);\n      if (!next) break; // out of memory\n      // we don't ref, because  StringExts are never reffed as they only have one owner (and ALWAYS have an owner)\n      jsvSetLastChild(block, jsvGetRef(next));\n      jsvUnLock(block);\n      block = next;\n      blockChars=0; // it's new, so empty\n    }\n    block->varData.str[blockChars++] = ch;\n    jsvStringIteratorNext(&it);\n  }\n  jsvSetCharactersInVar(block, blockChars);\n  jsvUnLock(block);\n  // Just make sure we only assert if there's a bug here. If we just ran out of memory or at end of string it's ok\n  assert((l == jsvGetStringLength(var)) || (jsErrorFlags&JSERR_MEMORY) || !jsvStringIteratorHasChar(&it));\n  jsvStringIteratorFree(&it);\n\n\n  return var;\n}\n\n/// Return the line number at the current character position (this isn't fast as it searches the string)\nunsigned int jslGetLineNumber() {\n  size_t line;\n  size_t col;\n  jsvGetLineAndCol(lex->sourceVar, jsvStringIteratorGetIndex(&lex->tokenStart.it)-1, &line, &col);\n  return (unsigned int)line;\n}\n\n/// Do we need a space between these two characters when printing a function's text?\nbool jslNeedSpaceBetween(unsigned char lastch, unsigned char ch) {\n  return (lastch>=_LEX_R_LIST_START || ch>=_LEX_R_LIST_START) &&\n         (lastch>=_LEX_R_LIST_START || isAlpha((char)lastch) || isNumeric((char)lastch)) &&\n         (ch>=_LEX_R_LIST_START || isAlpha((char)ch) || isNumeric((char)ch));\n}\n\nvoid jslPrintPosition(vcbprintf_callback user_callback, void *user_data, size_t tokenPos) {\n  size_t line,col;\n  jsvGetLineAndCol(lex->sourceVar, tokenPos, &line, &col);\n  if (lex->lineNumberOffset)\n    line += (size_t)lex->lineNumberOffset - 1;\n  cbprintf(user_callback, user_data, \"line %d col %d\\n\", line, col);\n}\n\nvoid jslPrintTokenLineMarker(vcbprintf_callback user_callback, void *user_data, size_t tokenPos, char *prefix) {\n  size_t line = 1,col = 1;\n  jsvGetLineAndCol(lex->sourceVar, tokenPos, &line, &col);\n  size_t startOfLine = jsvGetIndexFromLineAndCol(lex->sourceVar, line, 1);\n  size_t lineLength = jsvGetCharsOnLine(lex->sourceVar, line);\n  size_t prefixLength = 0;\n\n  if (prefix) {\n    user_callback(prefix, user_data);\n    prefixLength = strlen(prefix);\n  }\n\n  if (lineLength>60 && tokenPos-startOfLine>30) {\n    cbprintf(user_callback, user_data, \"...\");\n    size_t skipChars = tokenPos-30 - startOfLine;\n    startOfLine += 3+skipChars;\n    if (skipChars<=col)\n      col -= skipChars;\n    else\n      col = 0;\n    lineLength -= skipChars;\n  }\n\n  // print the string until the end of the line, or 60 chars (whichever is less)\n  int chars = 0;\n  JsvStringIterator it;\n  jsvStringIteratorNew(&it, lex->sourceVar, startOfLine);\n  unsigned char lastch = 0;\n  while (jsvStringIteratorHasChar(&it) && chars<60) {\n    unsigned char ch = (unsigned char)jsvStringIteratorGetChar(&it);\n    if (ch == '\\n') break;\n    if (jslNeedSpaceBetween(lastch, ch)) {\n      col++;\n      user_callback(\" \", user_data);\n    }\n    char buf[32];\n    jslFunctionCharAsString(ch, buf, sizeof(buf));\n    size_t len = strlen(buf);\n    col += len-1;\n    user_callback(buf, user_data);\n    chars++;\n    lastch = ch;\n    jsvStringIteratorNext(&it);\n  }\n  jsvStringIteratorFree(&it);\n\n  if (lineLength > 60)\n    user_callback(\"...\", user_data);\n  user_callback(\"\\n\", user_data);\n  col += prefixLength;\n  while (col-- > 1) user_callback(\" \", user_data);\n  user_callback(\"^\\n\", user_data);\n}\n\n"], "filenames": ["src/jslex.c"], "buggy_code_start_loc": [715], "buggy_code_end_loc": [817], "fixing_code_start_loc": [716], "fixing_code_end_loc": [817], "type": "CWE-787", "message": "Espruino before 1.99 allows attackers to cause a denial of service (application crash) and potential Information Disclosure with a user crafted input file via a Buffer Overflow during syntax parsing because strncpy is misused in jslex.c.", "other": {"cve": {"id": "CVE-2018-11593", "sourceIdentifier": "cve@mitre.org", "published": "2018-05-31T16:29:00.393", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Espruino before 1.99 allows attackers to cause a denial of service (application crash) and potential Information Disclosure with a user crafted input file via a Buffer Overflow during syntax parsing because strncpy is misused in jslex.c."}, {"lang": "es", "value": "Espruino en versiones anteriores a la 1.99 permite que los atacantes provoquen una denegaci\u00f3n de servicio (cierre inesperado de la aplicaci\u00f3n) y, posiblemente, una divulgaci\u00f3n de informaci\u00f3n con un archivo de entrada manipulado por el usuario mediante un desbordamiento de b\u00fafer durante el an\u00e1lisis sint\u00e1ctico porque strncpy se emplea incorrectamente en jslex.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:espruino:espruino:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.99", "matchCriteriaId": "0AC819A2-4289-44FA-9EBB-12DC6DB5455F"}]}]}], "references": [{"url": "https://github.com/espruino/Espruino/commit/bed844f109b6c222816740555068de2e101e8018", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/espruino/Espruino/files/2019228/eh_0.txt", "source": "cve@mitre.org", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://github.com/espruino/Espruino/issues/1426", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/espruino/Espruino/commit/bed844f109b6c222816740555068de2e101e8018"}}