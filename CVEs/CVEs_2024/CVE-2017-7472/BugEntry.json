{"buggy_code": ["/* Userspace key control operations\n *\n * Copyright (C) 2004-5 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/key.h>\n#include <linux/keyctl.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n\n#define KEY_MAX_DESC_SIZE 4096\n\nstatic int key_get_type_from_user(char *type,\n\t\t\t\t  const char __user *_type,\n\t\t\t\t  unsigned len)\n{\n\tint ret;\n\n\tret = strncpy_from_user(type, _type, len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0 || ret >= len)\n\t\treturn -EINVAL;\n\tif (type[0] == '.')\n\t\treturn -EPERM;\n\ttype[len - 1] = '\\0';\n\treturn 0;\n}\n\n/*\n * Extract the description of a new key from userspace and either add it as a\n * new key to the specified keyring or update a matching key in that keyring.\n *\n * If the description is NULL or an empty string, the key type is asked to\n * generate one from the payload.\n *\n * The keyring must be writable so that we can attach the key to it.\n *\n * If successful, the new key's serial number is returned, otherwise an error\n * code is returned.\n */\nSYSCALL_DEFINE5(add_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst void __user *, _payload,\n\t\tsize_t, plen,\n\t\tkey_serial_t, ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tchar type[32], *description;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t/* draw all the data into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdescription = NULL;\n\tif (_description) {\n\t\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(description)) {\n\t\t\tret = PTR_ERR(description);\n\t\t\tgoto error;\n\t\t}\n\t\tif (!*description) {\n\t\t\tkfree(description);\n\t\t\tdescription = NULL;\n\t\t} else if ((description[0] == '.') &&\n\t\t\t   (strncmp(type, \"keyring\", 7) == 0)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto error2;\n\t\t}\n\t}\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\n\tif (_payload) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!payload) {\n\t\t\tif (plen <= PAGE_SIZE)\n\t\t\t\tgoto error2;\n\t\t\tpayload = vmalloc(plen);\n\t\t\tif (!payload)\n\t\t\t\tgoto error2;\n\t\t}\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error3;\n\t}\n\n\t/* find the target keyring (which must be writable) */\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error3;\n\t}\n\n\t/* create or update the requested key and add it to the target\n\t * keyring */\n\tkey_ref = key_create_or_update(keyring_ref, type, description,\n\t\t\t\t       payload, plen, KEY_PERM_UNDEF,\n\t\t\t\t       KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key_ref)) {\n\t\tret = key_ref_to_ptr(key_ref)->serial;\n\t\tkey_ref_put(key_ref);\n\t}\n\telse {\n\t\tret = PTR_ERR(key_ref);\n\t}\n\n\tkey_ref_put(keyring_ref);\n error3:\n\tkvfree(payload);\n error2:\n\tkfree(description);\n error:\n\treturn ret;\n}\n\n/*\n * Search the process keyrings and keyring trees linked from those for a\n * matching key.  Keyrings must have appropriate Search permission to be\n * searched.\n *\n * If a key is found, it will be attached to the destination keyring if there's\n * one specified and the serial number of the key will be returned.\n *\n * If no key is found, /sbin/request-key will be invoked if _callout_info is\n * non-NULL in an attempt to create a key.  The _callout_info string will be\n * passed to /sbin/request-key to aid with completing the request.  If the\n * _callout_info string is \"\" then it will be changed to \"-\".\n */\nSYSCALL_DEFINE4(request_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst char __user *, _callout_info,\n\t\tkey_serial_t, destringid)\n{\n\tstruct key_type *ktype;\n\tstruct key *key;\n\tkey_ref_t dest_ref;\n\tsize_t callout_len;\n\tchar type[32], *description, *callout_info;\n\tlong ret;\n\n\t/* pull the type into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* pull the description into kernel space */\n\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\tif (IS_ERR(description)) {\n\t\tret = PTR_ERR(description);\n\t\tgoto error;\n\t}\n\n\t/* pull the callout info into kernel space */\n\tcallout_info = NULL;\n\tcallout_len = 0;\n\tif (_callout_info) {\n\t\tcallout_info = strndup_user(_callout_info, PAGE_SIZE);\n\t\tif (IS_ERR(callout_info)) {\n\t\t\tret = PTR_ERR(callout_info);\n\t\t\tgoto error2;\n\t\t}\n\t\tcallout_len = strlen(callout_info);\n\t}\n\n\t/* get the destination keyring if specified */\n\tdest_ref = NULL;\n\tif (destringid) {\n\t\tdest_ref = lookup_user_key(destringid, KEY_LOOKUP_CREATE,\n\t\t\t\t\t   KEY_NEED_WRITE);\n\t\tif (IS_ERR(dest_ref)) {\n\t\t\tret = PTR_ERR(dest_ref);\n\t\t\tgoto error3;\n\t\t}\n\t}\n\n\t/* find the key type */\n\tktype = key_type_lookup(type);\n\tif (IS_ERR(ktype)) {\n\t\tret = PTR_ERR(ktype);\n\t\tgoto error4;\n\t}\n\n\t/* do the search */\n\tkey = request_key_and_link(ktype, description, callout_info,\n\t\t\t\t   callout_len, NULL, key_ref_to_ptr(dest_ref),\n\t\t\t\t   KEY_ALLOC_IN_QUOTA);\n\tif (IS_ERR(key)) {\n\t\tret = PTR_ERR(key);\n\t\tgoto error5;\n\t}\n\n\t/* wait for the key to finish being constructed */\n\tret = wait_for_key_construction(key, 1);\n\tif (ret < 0)\n\t\tgoto error6;\n\n\tret = key->serial;\n\nerror6:\n \tkey_put(key);\nerror5:\n\tkey_type_put(ktype);\nerror4:\n\tkey_ref_put(dest_ref);\nerror3:\n\tkfree(callout_info);\nerror2:\n\tkfree(description);\nerror:\n\treturn ret;\n}\n\n/*\n * Get the ID of the specified process keyring.\n *\n * The requested keyring must have search permission to be found.\n *\n * If successful, the ID of the requested keyring will be returned.\n */\nlong keyctl_get_keyring_ID(key_serial_t id, int create)\n{\n\tkey_ref_t key_ref;\n\tunsigned long lflags;\n\tlong ret;\n\n\tlflags = create ? KEY_LOOKUP_CREATE : 0;\n\tkey_ref = lookup_user_key(id, lflags, KEY_NEED_SEARCH);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tret = key_ref_to_ptr(key_ref)->serial;\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Join a (named) session keyring.\n *\n * Create and join an anonymous session keyring or join a named session\n * keyring, creating it if necessary.  A named session keyring must have Search\n * permission for it to be joined.  Session keyrings without this permit will\n * be skipped over.  It is not permitted for userspace to create or join\n * keyrings whose name begin with a dot.\n *\n * If successful, the ID of the joined session keyring will be returned.\n */\nlong keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\n\t/* fetch the name from userspace */\n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = -EPERM;\n\t\tif (name[0] == '.')\n\t\t\tgoto error_name;\n\t}\n\n\t/* join the session */\n\tret = join_session_keyring(name);\nerror_name:\n\tkfree(name);\nerror:\n\treturn ret;\n}\n\n/*\n * Update a key's data payload from the given data.\n *\n * The key must grant the caller Write permission and the key type must support\n * updating for this to work.  A negative key can be positively instantiated\n * with this call.\n *\n * If successful, 0 will be returned.  If the key type does not support\n * updating, then -EOPNOTSUPP will be returned.\n */\nlong keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\tif (_payload) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\n\t/* find the target key (which must be writable) */\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\t/* update the key */\n\tret = key_update(key_ref, payload, plen);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkfree(payload);\nerror:\n\treturn ret;\n}\n\n/*\n * Revoke a key.\n *\n * The key must be grant the caller Write or Setattr permission for this to\n * work.  The key type should give up its quota claim when revoked.  The key\n * and any links to the key will be automatically garbage collected after a\n * certain amount of time (/proc/sys/kernel/keys/gc_delay).\n *\n * Keys with KEY_FLAG_KEEP set should not be revoked.\n *\n * If successful, 0 is returned.\n */\nlong keyctl_revoke_key(key_serial_t id)\n{\n\tkey_ref_t key_ref;\n\tstruct key *key;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tif (ret != -EACCES)\n\t\t\tgoto error;\n\t\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SETATTR);\n\t\tif (IS_ERR(key_ref)) {\n\t\t\tret = PTR_ERR(key_ref);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_revoke(key);\n\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Invalidate a key.\n *\n * The key must be grant the caller Invalidate permission for this to work.\n * The key and any links to the key will be automatically garbage collected\n * immediately.\n *\n * Keys with KEY_FLAG_KEEP set should not be invalidated.\n *\n * If successful, 0 is returned.\n */\nlong keyctl_invalidate_key(key_serial_t id)\n{\n\tkey_ref_t key_ref;\n\tstruct key *key;\n\tlong ret;\n\n\tkenter(\"%d\", id);\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SEARCH);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\n\t\t/* Root is permitted to invalidate certain special keys */\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tkey_ref = lookup_user_key(id, 0, 0);\n\t\t\tif (IS_ERR(key_ref))\n\t\t\t\tgoto error;\n\t\t\tif (test_bit(KEY_FLAG_ROOT_CAN_INVAL,\n\t\t\t\t     &key_ref_to_ptr(key_ref)->flags))\n\t\t\t\tgoto invalidate;\n\t\t\tgoto error_put;\n\t\t}\n\n\t\tgoto error;\n\t}\n\ninvalidate:\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_invalidate(key);\nerror_put:\n\tkey_ref_put(key_ref);\nerror:\n\tkleave(\" = %ld\", ret);\n\treturn ret;\n}\n\n/*\n * Clear the specified keyring, creating an empty process keyring if one of the\n * special keyring IDs is used.\n *\n * The keyring must grant the caller Write permission and not have\n * KEY_FLAG_KEEP set for this to work.  If successful, 0 will be returned.\n */\nlong keyctl_keyring_clear(key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref;\n\tstruct key *keyring;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\n\t\t/* Root is permitted to invalidate certain special keyrings */\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tkeyring_ref = lookup_user_key(ringid, 0, 0);\n\t\t\tif (IS_ERR(keyring_ref))\n\t\t\t\tgoto error;\n\t\t\tif (test_bit(KEY_FLAG_ROOT_CAN_CLEAR,\n\t\t\t\t     &key_ref_to_ptr(keyring_ref)->flags))\n\t\t\t\tgoto clear;\n\t\t\tgoto error_put;\n\t\t}\n\n\t\tgoto error;\n\t}\n\nclear:\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags))\n\t\tret = -EPERM;\n\telse\n\t\tret = keyring_clear(keyring);\nerror_put:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Create a link from a keyring to a key if there's no matching key in the\n * keyring, otherwise replace the link to the matching key with a link to the\n * new key.\n *\n * The key must grant the caller Link permission and the the keyring must grant\n * the caller Write permission.  Furthermore, if an additional link is created,\n * the keyring's quota will be extended.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_keyring_link(key_serial_t id, key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error;\n\t}\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE, KEY_NEED_LINK);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\tret = key_link(key_ref_to_ptr(keyring_ref), key_ref_to_ptr(key_ref));\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Unlink a key from a keyring.\n *\n * The keyring must grant the caller Write permission for this to work; the key\n * itself need not grant the caller anything.  If the last link to a key is\n * removed then that key will be scheduled for destruction.\n *\n * Keys or keyrings with KEY_FLAG_KEEP set should not be unlinked.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_keyring_unlink(key_serial_t id, key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tstruct key *keyring, *key;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error;\n\t}\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_FOR_UNLINK, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey = key_ref_to_ptr(key_ref);\n\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags) &&\n\t    test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tret = key_unlink(keyring, key);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Return a description of a key to userspace.\n *\n * The key must grant the caller View permission for this to work.\n *\n * If there's a buffer, we place up to buflen bytes of data into it formatted\n * in the following way:\n *\n *\ttype;uid;gid;perm;description<NUL>\n *\n * If successful, we return the amount of description available, irrespective\n * of how much we may have copied into the buffer.\n */\nlong keyctl_describe_key(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *infobuf;\n\tlong ret;\n\tint desclen, infolen;\n\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\t/* viewing a key under construction is permitted if we have the\n\t\t * authorisation token handy */\n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(keyid,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  0);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tdesclen = strlen(key->description);\n\n\t/* calculate how much information we're going to return */\n\tret = -ENOMEM;\n\tinfobuf = kasprintf(GFP_KERNEL,\n\t\t\t    \"%s;%d;%d;%08x;\",\n\t\t\t    key->type->name,\n\t\t\t    from_kuid_munged(current_user_ns(), key->uid),\n\t\t\t    from_kgid_munged(current_user_ns(), key->gid),\n\t\t\t    key->perm);\n\tif (!infobuf)\n\t\tgoto error2;\n\tinfolen = strlen(infobuf);\n\tret = infolen + desclen + 1;\n\n\t/* consider returning the data */\n\tif (buffer && buflen >= ret) {\n\t\tif (copy_to_user(buffer, infobuf, infolen) != 0 ||\n\t\t    copy_to_user(buffer + infolen, key->description,\n\t\t\t\t desclen + 1) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\tkfree(infobuf);\nerror2:\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Search the specified keyring and any keyrings it links to for a matching\n * key.  Only keyrings that grant the caller Search permission will be searched\n * (this includes the starting keyring).  Only keys with Search permission can\n * be found.\n *\n * If successful, the found key will be linked to the destination keyring if\n * supplied and the key has Link permission, and the found key ID will be\n * returned.\n */\nlong keyctl_keyring_search(key_serial_t ringid,\n\t\t\t   const char __user *_type,\n\t\t\t   const char __user *_description,\n\t\t\t   key_serial_t destringid)\n{\n\tstruct key_type *ktype;\n\tkey_ref_t keyring_ref, key_ref, dest_ref;\n\tchar type[32], *description;\n\tlong ret;\n\n\t/* pull the type and description into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\tif (IS_ERR(description)) {\n\t\tret = PTR_ERR(description);\n\t\tgoto error;\n\t}\n\n\t/* get the keyring at which to begin the search */\n\tkeyring_ref = lookup_user_key(ringid, 0, KEY_NEED_SEARCH);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error2;\n\t}\n\n\t/* get the destination keyring if specified */\n\tdest_ref = NULL;\n\tif (destringid) {\n\t\tdest_ref = lookup_user_key(destringid, KEY_LOOKUP_CREATE,\n\t\t\t\t\t   KEY_NEED_WRITE);\n\t\tif (IS_ERR(dest_ref)) {\n\t\t\tret = PTR_ERR(dest_ref);\n\t\t\tgoto error3;\n\t\t}\n\t}\n\n\t/* find the key type */\n\tktype = key_type_lookup(type);\n\tif (IS_ERR(ktype)) {\n\t\tret = PTR_ERR(ktype);\n\t\tgoto error4;\n\t}\n\n\t/* do the search */\n\tkey_ref = keyring_search(keyring_ref, ktype, description);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\n\t\t/* treat lack or presence of a negative key the same */\n\t\tif (ret == -EAGAIN)\n\t\t\tret = -ENOKEY;\n\t\tgoto error5;\n\t}\n\n\t/* link the resulting key to the destination keyring if we can */\n\tif (dest_ref) {\n\t\tret = key_permission(key_ref, KEY_NEED_LINK);\n\t\tif (ret < 0)\n\t\t\tgoto error6;\n\n\t\tret = key_link(key_ref_to_ptr(dest_ref), key_ref_to_ptr(key_ref));\n\t\tif (ret < 0)\n\t\t\tgoto error6;\n\t}\n\n\tret = key_ref_to_ptr(key_ref)->serial;\n\nerror6:\n\tkey_ref_put(key_ref);\nerror5:\n\tkey_type_put(ktype);\nerror4:\n\tkey_ref_put(dest_ref);\nerror3:\n\tkey_ref_put(keyring_ref);\nerror2:\n\tkfree(description);\nerror:\n\treturn ret;\n}\n\n/*\n * Read a key's payload.\n *\n * The key must either grant the caller Read permission, or it must grant the\n * caller Search permission when searched for from the process keyrings.\n *\n * If successful, we place up to buflen bytes of data into the buffer, if one\n * is provided, and return the amount of data that is available in the key,\n * irrespective of how much we copied into the buffer.\n */\nlong keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\t/* find the key first */\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* see if we can read it directly */\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\n\t/* we can't; see if it's searchable from this process's keyrings\n\t * - we automatically take account of the fact that it may be\n\t *   dangling off an instantiation key\n\t */\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\n\n\t/* the key is probably readable - now try to read it */\ncan_read_key:\n\tret = -EOPNOTSUPP;\n\tif (key->type->read) {\n\t\t/* Read the data with the semaphore held (since we might sleep)\n\t\t * to protect against the key being updated or revoked.\n\t\t */\n\t\tdown_read(&key->sem);\n\t\tret = key_validate(key);\n\t\tif (ret == 0)\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\tup_read(&key->sem);\n\t}\n\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}\n\n/*\n * Change the ownership of a key\n *\n * The key must grant the caller Setattr permission for this to work, though\n * the key need not be fully instantiated yet.  For the UID to be changed, or\n * for the GID to be changed to a group the caller is not a member of, the\n * caller must have sysadmin capability.  If either uid or gid is -1 then that\n * attribute is not changed.\n *\n * If the UID is to be changed, the new user must have sufficient quota to\n * accept the key.  The quota deduction will be removed from the old user to\n * the new user should the attribute be changed.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_chown_key(key_serial_t id, uid_t user, gid_t group)\n{\n\tstruct key_user *newowner, *zapowner = NULL;\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tuid = make_kuid(current_user_ns(), user);\n\tgid = make_kgid(current_user_ns(), group);\n\tret = -EINVAL;\n\tif ((user != (uid_t) -1) && !uid_valid(uid))\n\t\tgoto error;\n\tif ((group != (gid_t) -1) && !gid_valid(gid))\n\t\tgoto error;\n\n\tret = 0;\n\tif (user == (uid_t) -1 && group == (gid_t) -1)\n\t\tgoto error;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* make the changes with the locks held to prevent chown/chown races */\n\tret = -EACCES;\n\tdown_write(&key->sem);\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t/* only the sysadmin can chown a key to some other UID */\n\t\tif (user != (uid_t) -1 && !uid_eq(key->uid, uid))\n\t\t\tgoto error_put;\n\n\t\t/* only the sysadmin can set the key's GID to a group other\n\t\t * than one of those that the current process subscribes to */\n\t\tif (group != (gid_t) -1 && !gid_eq(gid, key->gid) && !in_group_p(gid))\n\t\t\tgoto error_put;\n\t}\n\n\t/* change the UID */\n\tif (user != (uid_t) -1 && !uid_eq(uid, key->uid)) {\n\t\tret = -ENOMEM;\n\t\tnewowner = key_user_lookup(uid);\n\t\tif (!newowner)\n\t\t\tgoto error_put;\n\n\t\t/* transfer the quota burden to the new user */\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tunsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\t\tkey_quota_root_maxkeys : key_quota_maxkeys;\n\t\t\tunsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\t\tspin_lock(&newowner->lock);\n\t\t\tif (newowner->qnkeys + 1 >= maxkeys ||\n\t\t\t    newowner->qnbytes + key->quotalen >= maxbytes ||\n\t\t\t    newowner->qnbytes + key->quotalen <\n\t\t\t    newowner->qnbytes)\n\t\t\t\tgoto quota_overrun;\n\n\t\t\tnewowner->qnkeys++;\n\t\t\tnewowner->qnbytes += key->quotalen;\n\t\t\tspin_unlock(&newowner->lock);\n\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n\t\tatomic_inc(&newowner->nkeys);\n\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\t\tatomic_inc(&newowner->nikeys);\n\t\t}\n\n\t\tzapowner = key->user;\n\t\tkey->user = newowner;\n\t\tkey->uid = uid;\n\t}\n\n\t/* change the GID */\n\tif (group != (gid_t) -1)\n\t\tkey->gid = gid;\n\n\tret = 0;\n\nerror_put:\n\tup_write(&key->sem);\n\tkey_put(key);\n\tif (zapowner)\n\t\tkey_user_put(zapowner);\nerror:\n\treturn ret;\n\nquota_overrun:\n\tspin_unlock(&newowner->lock);\n\tzapowner = newowner;\n\tret = -EDQUOT;\n\tgoto error_put;\n}\n\n/*\n * Change the permission mask on a key.\n *\n * The key must grant the caller Setattr permission for this to work, though\n * the key need not be fully instantiated yet.  If the caller does not have\n * sysadmin capability, it may only change the permission on keys that it owns.\n */\nlong keyctl_setperm_key(key_serial_t id, key_perm_t perm)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (perm & ~(KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL))\n\t\tgoto error;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* make the changes with the locks held to prevent chown/chmod races */\n\tret = -EACCES;\n\tdown_write(&key->sem);\n\n\t/* if we're not the sysadmin, we can only change a key that we own */\n\tif (capable(CAP_SYS_ADMIN) || uid_eq(key->uid, current_fsuid())) {\n\t\tkey->perm = perm;\n\t\tret = 0;\n\t}\n\n\tup_write(&key->sem);\n\tkey_put(key);\nerror:\n\treturn ret;\n}\n\n/*\n * Get the destination keyring for instantiation and check that the caller has\n * Write permission on it.\n */\nstatic long get_instantiation_keyring(key_serial_t ringid,\n\t\t\t\t      struct request_key_auth *rka,\n\t\t\t\t      struct key **_dest_keyring)\n{\n\tkey_ref_t dkref;\n\n\t*_dest_keyring = NULL;\n\n\t/* just return a NULL pointer if we weren't asked to make a link */\n\tif (ringid == 0)\n\t\treturn 0;\n\n\t/* if a specific keyring is nominated by ID, then use that */\n\tif (ringid > 0) {\n\t\tdkref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\t\tif (IS_ERR(dkref))\n\t\t\treturn PTR_ERR(dkref);\n\t\t*_dest_keyring = key_ref_to_ptr(dkref);\n\t\treturn 0;\n\t}\n\n\tif (ringid == KEY_SPEC_REQKEY_AUTH_KEY)\n\t\treturn -EINVAL;\n\n\t/* otherwise specify the destination keyring recorded in the\n\t * authorisation key (any KEY_SPEC_*_KEYRING) */\n\tif (ringid >= KEY_SPEC_REQUESTOR_KEYRING) {\n\t\t*_dest_keyring = key_get(rka->dest_keyring);\n\t\treturn 0;\n\t}\n\n\treturn -ENOKEY;\n}\n\n/*\n * Change the request_key authorisation key on the current process.\n */\nstatic int keyctl_change_reqkey_auth(struct key *key)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tkey_put(new->request_key_auth);\n\tnew->request_key_auth = key_get(key);\n\n\treturn commit_creds(new);\n}\n\n/*\n * Instantiate a key with the specified payload and link the key into the\n * destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_instantiate_key_common(key_serial_t id,\n\t\t\t\t   struct iov_iter *from,\n\t\t\t\t   key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tsize_t plen = from ? iov_iter_count(from) : 0;\n\tvoid *payload;\n\tlong ret;\n\n\tkenter(\"%d,,%zu,%d\", id, plen, ringid);\n\n\tif (!plen)\n\t\tfrom = NULL;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t/* the appropriate instantiation authorisation key must have been\n\t * assumed before calling this */\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\n\tif (from) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload) {\n\t\t\tif (plen <= PAGE_SIZE)\n\t\t\t\tgoto error;\n\t\t\tpayload = vmalloc(plen);\n\t\t\tif (!payload)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tret = -EFAULT;\n\t\tif (!copy_from_iter_full(payload, plen, from))\n\t\t\tgoto error2;\n\t}\n\n\t/* find the destination keyring amongst those belonging to the\n\t * requesting task */\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\n\t/* instantiate the key and link it into a keyring */\n\tret = key_instantiate_and_link(rka->target_key, payload, plen,\n\t\t\t\t       dest_keyring, instkey);\n\n\tkey_put(dest_keyring);\n\n\t/* discard the assumed authority if it's just been disabled by\n\t * instantiation of the key */\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\n\nerror2:\n\tkvfree(payload);\nerror:\n\treturn ret;\n}\n\n/*\n * Instantiate a key with the specified payload and link the key into the\n * destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_instantiate_key(key_serial_t id,\n\t\t\t    const void __user *_payload,\n\t\t\t    size_t plen,\n\t\t\t    key_serial_t ringid)\n{\n\tif (_payload && plen) {\n\t\tstruct iovec iov;\n\t\tstruct iov_iter from;\n\t\tint ret;\n\n\t\tret = import_single_range(WRITE, (void __user *)_payload, plen,\n\t\t\t\t\t  &iov, &from);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\n\t\treturn keyctl_instantiate_key_common(id, &from, ringid);\n\t}\n\n\treturn keyctl_instantiate_key_common(id, NULL, ringid);\n}\n\n/*\n * Instantiate a key with the specified multipart payload and link the key into\n * the destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_instantiate_key_iov(key_serial_t id,\n\t\t\t\tconst struct iovec __user *_payload_iov,\n\t\t\t\tunsigned ioc,\n\t\t\t\tkey_serial_t ringid)\n{\n\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;\n\tstruct iov_iter from;\n\tlong ret;\n\n\tif (!_payload_iov)\n\t\tioc = 0;\n\n\tret = import_iovec(WRITE, _payload_iov, ioc,\n\t\t\t\t    ARRAY_SIZE(iovstack), &iov, &from);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = keyctl_instantiate_key_common(id, &from, ringid);\n\tkfree(iov);\n\treturn ret;\n}\n\n/*\n * Negatively instantiate the key with the given timeout (in seconds) and link\n * the key into the destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * The key and any links to the key will be automatically garbage collected\n * after the timeout expires.\n *\n * Negative keys are used to rate limit repeated request_key() calls by causing\n * them to return -ENOKEY until the negative key expires.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_negate_key(key_serial_t id, unsigned timeout, key_serial_t ringid)\n{\n\treturn keyctl_reject_key(id, timeout, ENOKEY, ringid);\n}\n\n/*\n * Negatively instantiate the key with the given timeout (in seconds) and error\n * code and link the key into the destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * The key and any links to the key will be automatically garbage collected\n * after the timeout expires.\n *\n * Negative keys are used to rate limit repeated request_key() calls by causing\n * them to return the specified error code until the negative key expires.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_reject_key(key_serial_t id, unsigned timeout, unsigned error,\n\t\t       key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tlong ret;\n\n\tkenter(\"%d,%u,%u,%d\", id, timeout, error, ringid);\n\n\t/* must be a valid error code and mustn't be a kernel special */\n\tif (error <= 0 ||\n\t    error >= MAX_ERRNO ||\n\t    error == ERESTARTSYS ||\n\t    error == ERESTARTNOINTR ||\n\t    error == ERESTARTNOHAND ||\n\t    error == ERESTART_RESTARTBLOCK)\n\t\treturn -EINVAL;\n\n\t/* the appropriate instantiation authorisation key must have been\n\t * assumed before calling this */\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t/* find the destination keyring if present (which must also be\n\t * writable) */\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* instantiate the key and link it into a keyring */\n\tret = key_reject_and_link(rka->target_key, timeout, error,\n\t\t\t\t  dest_keyring, instkey);\n\n\tkey_put(dest_keyring);\n\n\t/* discard the assumed authority if it's just been disabled by\n\t * instantiation of the key */\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\n\nerror:\n\treturn ret;\n}\n\n/*\n * Read or set the default keyring in which request_key() will cache keys and\n * return the old setting.\n *\n * If a process keyring is specified then this will be created if it doesn't\n * yet exist.  The old setting will be returned if successful.\n */\nlong keyctl_set_reqkey_keyring(int reqkey_defl)\n{\n\tstruct cred *new;\n\tint ret, old_setting;\n\n\told_setting = current_cred_xxx(jit_keyring);\n\n\tif (reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE)\n\t\treturn old_setting;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tswitch (reqkey_defl) {\n\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\tret = install_thread_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\tret = install_process_keyring_to_cred(new);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -EEXIST)\n\t\t\t\tgoto error;\n\t\t\tret = 0;\n\t\t}\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_DEFAULT:\n\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_NO_CHANGE:\n\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\nset:\n\tnew->jit_keyring = reqkey_defl;\n\tcommit_creds(new);\n\treturn old_setting;\nerror:\n\tabort_creds(new);\n\treturn ret;\n}\n\n/*\n * Set or clear the timeout on a key.\n *\n * Either the key must grant the caller Setattr permission or else the caller\n * must hold an instantiation authorisation token for the key.\n *\n * The timeout is either 0 to clear the timeout, or a number of seconds from\n * the current time.  The key and any links to the key will be automatically\n * garbage collected after the timeout expires.\n *\n * Keys with KEY_FLAG_KEEP set should not be timed out.\n *\n * If successful, 0 is returned.\n */\nlong keyctl_set_timeout(key_serial_t id, unsigned timeout)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\t/* setting the timeout on a key under construction is permitted\n\t\t * if we have the authorisation token handy */\n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(id);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(id,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  0);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_set_timeout(key, timeout);\n\tkey_put(key);\n\nerror:\n\treturn ret;\n}\n\n/*\n * Assume (or clear) the authority to instantiate the specified key.\n *\n * This sets the authoritative token currently in force for key instantiation.\n * This must be done for a key to be instantiated.  It has the effect of making\n * available all the keys from the caller of the request_key() that created a\n * key to request_key() calls made by the caller of this function.\n *\n * The caller must have the instantiation key in their process keyrings with a\n * Search permission grant available to the caller.\n *\n * If the ID given is 0, then the setting will be cleared and 0 returned.\n *\n * If the ID given has a matching an authorisation key, then that key will be\n * set and its ID will be returned.  The authorisation key can be read to get\n * the callout information passed to request_key().\n */\nlong keyctl_assume_authority(key_serial_t id)\n{\n\tstruct key *authkey;\n\tlong ret;\n\n\t/* special key IDs aren't permitted */\n\tret = -EINVAL;\n\tif (id < 0)\n\t\tgoto error;\n\n\t/* we divest ourselves of authority if given an ID of 0 */\n\tif (id == 0) {\n\t\tret = keyctl_change_reqkey_auth(NULL);\n\t\tgoto error;\n\t}\n\n\t/* attempt to assume the authority temporarily granted to us whilst we\n\t * instantiate the specified key\n\t * - the authorisation key must be in the current task's keyrings\n\t *   somewhere\n\t */\n\tauthkey = key_get_instantiation_authkey(id);\n\tif (IS_ERR(authkey)) {\n\t\tret = PTR_ERR(authkey);\n\t\tgoto error;\n\t}\n\n\tret = keyctl_change_reqkey_auth(authkey);\n\tif (ret < 0)\n\t\tgoto error;\n\tkey_put(authkey);\n\n\tret = authkey->serial;\nerror:\n\treturn ret;\n}\n\n/*\n * Get a key's the LSM security label.\n *\n * The key must grant the caller View permission for this to work.\n *\n * If there's a buffer, then up to buflen bytes of data will be placed into it.\n *\n * If successful, the amount of information available will be returned,\n * irrespective of how much was copied (including the terminal NUL).\n */\nlong keyctl_get_security(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *context;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\tif (PTR_ERR(key_ref) != -EACCES)\n\t\t\treturn PTR_ERR(key_ref);\n\n\t\t/* viewing a key under construction is also permitted if we\n\t\t * have the authorisation token handy */\n\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\tif (IS_ERR(instkey))\n\t\t\treturn PTR_ERR(instkey);\n\t\tkey_put(instkey);\n\n\t\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, 0);\n\t\tif (IS_ERR(key_ref))\n\t\t\treturn PTR_ERR(key_ref);\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\tret = security_key_getsecurity(key, &context);\n\tif (ret == 0) {\n\t\t/* if no information was returned, give userspace an empty\n\t\t * string */\n\t\tret = 1;\n\t\tif (buffer && buflen > 0 &&\n\t\t    copy_to_user(buffer, \"\", 1) != 0)\n\t\t\tret = -EFAULT;\n\t} else if (ret > 0) {\n\t\t/* return as much data as there's room for */\n\t\tif (buffer && buflen > 0) {\n\t\t\tif (buflen > ret)\n\t\t\t\tbuflen = ret;\n\n\t\t\tif (copy_to_user(buffer, context, buflen) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(context);\n\t}\n\n\tkey_ref_put(key_ref);\n\treturn ret;\n}\n\n/*\n * Attempt to install the calling process's session keyring on the process's\n * parent process.\n *\n * The keyring must exist and must grant the caller LINK permission, and the\n * parent process must be single-threaded and must have the same effective\n * ownership as this process and mustn't be SUID/SGID.\n *\n * The keyring will be emplaced on the parent when it next resumes userspace.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_session_to_parent(void)\n{\n\tstruct task_struct *me, *parent;\n\tconst struct cred *mycred, *pcred;\n\tstruct callback_head *newwork, *oldwork;\n\tkey_ref_t keyring_r;\n\tstruct cred *cred;\n\tint ret;\n\n\tkeyring_r = lookup_user_key(KEY_SPEC_SESSION_KEYRING, 0, KEY_NEED_LINK);\n\tif (IS_ERR(keyring_r))\n\t\treturn PTR_ERR(keyring_r);\n\n\tret = -ENOMEM;\n\n\t/* our parent is going to need a new cred struct, a new tgcred struct\n\t * and new security data, so we allocate them here to prevent ENOMEM in\n\t * our parent */\n\tcred = cred_alloc_blank();\n\tif (!cred)\n\t\tgoto error_keyring;\n\tnewwork = &cred->rcu;\n\n\tcred->session_keyring = key_ref_to_ptr(keyring_r);\n\tkeyring_r = NULL;\n\tinit_task_work(newwork, key_change_session_keyring);\n\n\tme = current;\n\trcu_read_lock();\n\twrite_lock_irq(&tasklist_lock);\n\n\tret = -EPERM;\n\toldwork = NULL;\n\tparent = me->real_parent;\n\n\t/* the parent mustn't be init and mustn't be a kernel thread */\n\tif (parent->pid <= 1 || !parent->mm)\n\t\tgoto unlock;\n\n\t/* the parent must be single threaded */\n\tif (!thread_group_empty(parent))\n\t\tgoto unlock;\n\n\t/* the parent and the child must have different session keyrings or\n\t * there's no point */\n\tmycred = current_cred();\n\tpcred = __task_cred(parent);\n\tif (mycred == pcred ||\n\t    mycred->session_keyring == pcred->session_keyring) {\n\t\tret = 0;\n\t\tgoto unlock;\n\t}\n\n\t/* the parent must have the same effective ownership and mustn't be\n\t * SUID/SGID */\n\tif (!uid_eq(pcred->uid,\t mycred->euid) ||\n\t    !uid_eq(pcred->euid, mycred->euid) ||\n\t    !uid_eq(pcred->suid, mycred->euid) ||\n\t    !gid_eq(pcred->gid,\t mycred->egid) ||\n\t    !gid_eq(pcred->egid, mycred->egid) ||\n\t    !gid_eq(pcred->sgid, mycred->egid))\n\t\tgoto unlock;\n\n\t/* the keyrings must have the same UID */\n\tif ((pcred->session_keyring &&\n\t     !uid_eq(pcred->session_keyring->uid, mycred->euid)) ||\n\t    !uid_eq(mycred->session_keyring->uid, mycred->euid))\n\t\tgoto unlock;\n\n\t/* cancel an already pending keyring replacement */\n\toldwork = task_work_cancel(parent, key_change_session_keyring);\n\n\t/* the replacement session keyring is applied just prior to userspace\n\t * restarting */\n\tret = task_work_add(parent, newwork, true);\n\tif (!ret)\n\t\tnewwork = NULL;\nunlock:\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\tif (oldwork)\n\t\tput_cred(container_of(oldwork, struct cred, rcu));\n\tif (newwork)\n\t\tput_cred(cred);\n\treturn ret;\n\nerror_keyring:\n\tkey_ref_put(keyring_r);\n\treturn ret;\n}\n\n/*\n * The key control system call\n */\nSYSCALL_DEFINE5(keyctl, int, option, unsigned long, arg2, unsigned long, arg3,\n\t\tunsigned long, arg4, unsigned long, arg5)\n{\n\tswitch (option) {\n\tcase KEYCTL_GET_KEYRING_ID:\n\t\treturn keyctl_get_keyring_ID((key_serial_t) arg2,\n\t\t\t\t\t     (int) arg3);\n\n\tcase KEYCTL_JOIN_SESSION_KEYRING:\n\t\treturn keyctl_join_session_keyring((const char __user *) arg2);\n\n\tcase KEYCTL_UPDATE:\n\t\treturn keyctl_update_key((key_serial_t) arg2,\n\t\t\t\t\t (const void __user *) arg3,\n\t\t\t\t\t (size_t) arg4);\n\n\tcase KEYCTL_REVOKE:\n\t\treturn keyctl_revoke_key((key_serial_t) arg2);\n\n\tcase KEYCTL_DESCRIBE:\n\t\treturn keyctl_describe_key((key_serial_t) arg2,\n\t\t\t\t\t   (char __user *) arg3,\n\t\t\t\t\t   (unsigned) arg4);\n\n\tcase KEYCTL_CLEAR:\n\t\treturn keyctl_keyring_clear((key_serial_t) arg2);\n\n\tcase KEYCTL_LINK:\n\t\treturn keyctl_keyring_link((key_serial_t) arg2,\n\t\t\t\t\t   (key_serial_t) arg3);\n\n\tcase KEYCTL_UNLINK:\n\t\treturn keyctl_keyring_unlink((key_serial_t) arg2,\n\t\t\t\t\t     (key_serial_t) arg3);\n\n\tcase KEYCTL_SEARCH:\n\t\treturn keyctl_keyring_search((key_serial_t) arg2,\n\t\t\t\t\t     (const char __user *) arg3,\n\t\t\t\t\t     (const char __user *) arg4,\n\t\t\t\t\t     (key_serial_t) arg5);\n\n\tcase KEYCTL_READ:\n\t\treturn keyctl_read_key((key_serial_t) arg2,\n\t\t\t\t       (char __user *) arg3,\n\t\t\t\t       (size_t) arg4);\n\n\tcase KEYCTL_CHOWN:\n\t\treturn keyctl_chown_key((key_serial_t) arg2,\n\t\t\t\t\t(uid_t) arg3,\n\t\t\t\t\t(gid_t) arg4);\n\n\tcase KEYCTL_SETPERM:\n\t\treturn keyctl_setperm_key((key_serial_t) arg2,\n\t\t\t\t\t  (key_perm_t) arg3);\n\n\tcase KEYCTL_INSTANTIATE:\n\t\treturn keyctl_instantiate_key((key_serial_t) arg2,\n\t\t\t\t\t      (const void __user *) arg3,\n\t\t\t\t\t      (size_t) arg4,\n\t\t\t\t\t      (key_serial_t) arg5);\n\n\tcase KEYCTL_NEGATE:\n\t\treturn keyctl_negate_key((key_serial_t) arg2,\n\t\t\t\t\t (unsigned) arg3,\n\t\t\t\t\t (key_serial_t) arg4);\n\n\tcase KEYCTL_SET_REQKEY_KEYRING:\n\t\treturn keyctl_set_reqkey_keyring(arg2);\n\n\tcase KEYCTL_SET_TIMEOUT:\n\t\treturn keyctl_set_timeout((key_serial_t) arg2,\n\t\t\t\t\t  (unsigned) arg3);\n\n\tcase KEYCTL_ASSUME_AUTHORITY:\n\t\treturn keyctl_assume_authority((key_serial_t) arg2);\n\n\tcase KEYCTL_GET_SECURITY:\n\t\treturn keyctl_get_security((key_serial_t) arg2,\n\t\t\t\t\t   (char __user *) arg3,\n\t\t\t\t\t   (size_t) arg4);\n\n\tcase KEYCTL_SESSION_TO_PARENT:\n\t\treturn keyctl_session_to_parent();\n\n\tcase KEYCTL_REJECT:\n\t\treturn keyctl_reject_key((key_serial_t) arg2,\n\t\t\t\t\t (unsigned) arg3,\n\t\t\t\t\t (unsigned) arg4,\n\t\t\t\t\t (key_serial_t) arg5);\n\n\tcase KEYCTL_INSTANTIATE_IOV:\n\t\treturn keyctl_instantiate_key_iov(\n\t\t\t(key_serial_t) arg2,\n\t\t\t(const struct iovec __user *) arg3,\n\t\t\t(unsigned) arg4,\n\t\t\t(key_serial_t) arg5);\n\n\tcase KEYCTL_INVALIDATE:\n\t\treturn keyctl_invalidate_key((key_serial_t) arg2);\n\n\tcase KEYCTL_GET_PERSISTENT:\n\t\treturn keyctl_get_persistent((uid_t)arg2, (key_serial_t)arg3);\n\n\tcase KEYCTL_DH_COMPUTE:\n\t\treturn keyctl_dh_compute((struct keyctl_dh_params __user *) arg2,\n\t\t\t\t\t (char __user *) arg3, (size_t) arg4,\n\t\t\t\t\t (void __user *) arg5);\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n", "/* Manage a process's keyrings\n *\n * Copyright (C) 2004-2005, 2008 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/sched/user.h>\n#include <linux/keyctl.h>\n#include <linux/fs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/user_namespace.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n\n/* Session keyring create vs join semaphore */\nstatic DEFINE_MUTEX(key_session_mutex);\n\n/* User keyring creation semaphore */\nstatic DEFINE_MUTEX(key_user_keyring_mutex);\n\n/* The root user's tracking struct */\nstruct key_user root_key_user = {\n\t.usage\t\t= ATOMIC_INIT(3),\n\t.cons_lock\t= __MUTEX_INITIALIZER(root_key_user.cons_lock),\n\t.lock\t\t= __SPIN_LOCK_UNLOCKED(root_key_user.lock),\n\t.nkeys\t\t= ATOMIC_INIT(2),\n\t.nikeys\t\t= ATOMIC_INIT(2),\n\t.uid\t\t= GLOBAL_ROOT_UID,\n};\n\n/*\n * Install the user and user session keyrings for the current process's UID.\n */\nint install_user_keyrings(void)\n{\n\tstruct user_struct *user;\n\tconst struct cred *cred;\n\tstruct key *uid_keyring, *session_keyring;\n\tkey_perm_t user_keyring_perm;\n\tchar buf[20];\n\tint ret;\n\tuid_t uid;\n\n\tuser_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL;\n\tcred = current_cred();\n\tuser = cred->user;\n\tuid = from_kuid(cred->user_ns, user->uid);\n\n\tkenter(\"%p{%u}\", user, uid);\n\n\tif (user->uid_keyring && user->session_keyring) {\n\t\tkleave(\" = 0 [exist]\");\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&key_user_keyring_mutex);\n\tret = 0;\n\n\tif (!user->uid_keyring) {\n\t\t/* get the UID-specific keyring\n\t\t * - there may be one in existence already as it may have been\n\t\t *   pinned by a session, but the user_struct pointing to it\n\t\t *   may have been destroyed by setuid */\n\t\tsprintf(buf, \"_uid.%u\", uid);\n\n\t\tuid_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(uid_keyring)) {\n\t\t\tuid_keyring = keyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t\t    cred, user_keyring_perm,\n\t\t\t\t\t\t    KEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t\t    NULL, NULL);\n\t\t\tif (IS_ERR(uid_keyring)) {\n\t\t\t\tret = PTR_ERR(uid_keyring);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t/* get a default session keyring (which might also exist\n\t\t * already) */\n\t\tsprintf(buf, \"_uid_ses.%u\", uid);\n\n\t\tsession_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(session_keyring)) {\n\t\t\tsession_keyring =\n\t\t\t\tkeyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t      cred, user_keyring_perm,\n\t\t\t\t\t      KEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t      NULL, NULL);\n\t\t\tif (IS_ERR(session_keyring)) {\n\t\t\t\tret = PTR_ERR(session_keyring);\n\t\t\t\tgoto error_release;\n\t\t\t}\n\n\t\t\t/* we install a link from the user session keyring to\n\t\t\t * the user keyring */\n\t\t\tret = key_link(session_keyring, uid_keyring);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_release_both;\n\t\t}\n\n\t\t/* install the keyrings */\n\t\tuser->uid_keyring = uid_keyring;\n\t\tuser->session_keyring = session_keyring;\n\t}\n\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = 0\");\n\treturn 0;\n\nerror_release_both:\n\tkey_put(session_keyring);\nerror_release:\n\tkey_put(uid_keyring);\nerror:\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Install a fresh thread keyring directly to new credentials.  This keyring is\n * allowed to overrun the quota.\n */\nint install_thread_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tkeyring = keyring_alloc(\"_tid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->thread_keyring = keyring;\n\treturn 0;\n}\n\n/*\n * Install a fresh thread keyring, discarding the old one.\n */\nstatic int install_thread_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tBUG_ON(new->thread_keyring);\n\n\tret = install_thread_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}\n\n/*\n * Install a process keyring directly to a credentials struct.\n *\n * Returns -EEXIST if there was already a process keyring, 0 if one installed,\n * and other value on any other error\n */\nint install_process_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->process_keyring)\n\t\treturn -EEXIST;\n\n\tkeyring = keyring_alloc(\"_pid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->process_keyring = keyring;\n\treturn 0;\n}\n\n/*\n * Make sure a process keyring is installed for the current process.  The\n * existing process keyring is not replaced.\n *\n * Returns 0 if there is a process keyring by the end of this function, some\n * error otherwise.\n */\nstatic int install_process_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_process_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret != -EEXIST ? ret : 0;\n\t}\n\n\treturn commit_creds(new);\n}\n\n/*\n * Install a session keyring directly to a credentials struct.\n */\nint install_session_keyring_to_cred(struct cred *cred, struct key *keyring)\n{\n\tunsigned long flags;\n\tstruct key *old;\n\n\tmight_sleep();\n\n\t/* create an empty session keyring */\n\tif (!keyring) {\n\t\tflags = KEY_ALLOC_QUOTA_OVERRUN;\n\t\tif (cred->session_keyring)\n\t\t\tflags = KEY_ALLOC_IN_QUOTA;\n\n\t\tkeyring = keyring_alloc(\"_ses\", cred->uid, cred->gid, cred,\n\t\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\t\tflags, NULL, NULL);\n\t\tif (IS_ERR(keyring))\n\t\t\treturn PTR_ERR(keyring);\n\t} else {\n\t\t__key_get(keyring);\n\t}\n\n\t/* install the keyring */\n\told = cred->session_keyring;\n\trcu_assign_pointer(cred->session_keyring, keyring);\n\n\tif (old)\n\t\tkey_put(old);\n\n\treturn 0;\n}\n\n/*\n * Install a session keyring, discarding the old one.  If a keyring is not\n * supplied, an empty one is invented.\n */\nstatic int install_session_keyring(struct key *keyring)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_session_keyring_to_cred(new, keyring);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}\n\n/*\n * Handle the fsuid changing.\n */\nvoid key_fsuid_changed(struct task_struct *tsk)\n{\n\t/* update the ownership of the thread keyring */\n\tBUG_ON(!tsk->cred);\n\tif (tsk->cred->thread_keyring) {\n\t\tdown_write(&tsk->cred->thread_keyring->sem);\n\t\ttsk->cred->thread_keyring->uid = tsk->cred->fsuid;\n\t\tup_write(&tsk->cred->thread_keyring->sem);\n\t}\n}\n\n/*\n * Handle the fsgid changing.\n */\nvoid key_fsgid_changed(struct task_struct *tsk)\n{\n\t/* update the ownership of the thread keyring */\n\tBUG_ON(!tsk->cred);\n\tif (tsk->cred->thread_keyring) {\n\t\tdown_write(&tsk->cred->thread_keyring->sem);\n\t\ttsk->cred->thread_keyring->gid = tsk->cred->fsgid;\n\t\tup_write(&tsk->cred->thread_keyring->sem);\n\t}\n}\n\n/*\n * Search the process keyrings attached to the supplied cred for the first\n * matching key.\n *\n * The search criteria are the type and the match function.  The description is\n * given to the match function as a parameter, but doesn't otherwise influence\n * the search.  Typically the match function will compare the description\n * parameter to the key's description.\n *\n * This can only search keyrings that grant Search permission to the supplied\n * credentials.  Keyrings linked to searched keyrings will also be searched if\n * they grant Search permission too.  Keys can only be found if they grant\n * Search permission to the credentials.\n *\n * Returns a pointer to the key with the key usage count incremented if\n * successful, -EAGAIN if we didn't find any matching key or -ENOKEY if we only\n * matched negative keys.\n *\n * In the case of a successful return, the possession attribute is set on the\n * returned key reference.\n */\nkey_ref_t search_my_process_keyrings(struct keyring_search_context *ctx)\n{\n\tkey_ref_t key_ref, ret, err;\n\n\t/* we want to return -EAGAIN or -ENOKEY if any of the keyrings were\n\t * searchable, but we failed to find a key or we found a negative key;\n\t * otherwise we want to return a sample error (probably -EACCES) if\n\t * none of the keyrings were searchable\n\t *\n\t * in terms of priority: success > -ENOKEY > -EAGAIN > other error\n\t */\n\tkey_ref = NULL;\n\tret = NULL;\n\terr = ERR_PTR(-EAGAIN);\n\n\t/* search the thread keyring first */\n\tif (ctx->cred->thread_keyring) {\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(ctx->cred->thread_keyring, 1), ctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* search the process keyring second */\n\tif (ctx->cred->process_keyring) {\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(ctx->cred->process_keyring, 1), ctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* search the session keyring */\n\tif (ctx->cred->session_keyring) {\n\t\trcu_read_lock();\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(rcu_dereference(ctx->cred->session_keyring), 1),\n\t\t\tctx);\n\t\trcu_read_unlock();\n\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* or search the user-session keyring */\n\telse if (ctx->cred->user->session_keyring) {\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(ctx->cred->user->session_keyring, 1),\n\t\t\tctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no key - decide on the error we're going to go for */\n\tkey_ref = ret ? ret : err;\n\nfound:\n\treturn key_ref;\n}\n\n/*\n * Search the process keyrings attached to the supplied cred for the first\n * matching key in the manner of search_my_process_keyrings(), but also search\n * the keys attached to the assumed authorisation key using its credentials if\n * one is available.\n *\n * Return same as search_my_process_keyrings().\n */\nkey_ref_t search_process_keyrings(struct keyring_search_context *ctx)\n{\n\tstruct request_key_auth *rka;\n\tkey_ref_t key_ref, ret = ERR_PTR(-EACCES), err;\n\n\tmight_sleep();\n\n\tkey_ref = search_my_process_keyrings(ctx);\n\tif (!IS_ERR(key_ref))\n\t\tgoto found;\n\terr = key_ref;\n\n\t/* if this process has an instantiation authorisation key, then we also\n\t * search the keyrings of the process mentioned there\n\t * - we don't permit access to request_key auth keys via this method\n\t */\n\tif (ctx->cred->request_key_auth &&\n\t    ctx->cred == current_cred() &&\n\t    ctx->index_key.type != &key_type_request_key_auth\n\t    ) {\n\t\tconst struct cred *cred = ctx->cred;\n\n\t\t/* defend against the auth key being revoked */\n\t\tdown_read(&cred->request_key_auth->sem);\n\n\t\tif (key_validate(ctx->cred->request_key_auth) == 0) {\n\t\t\trka = ctx->cred->request_key_auth->payload.data[0];\n\n\t\t\tctx->cred = rka->cred;\n\t\t\tkey_ref = search_process_keyrings(ctx);\n\t\t\tctx->cred = cred;\n\n\t\t\tup_read(&cred->request_key_auth->sem);\n\n\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\tgoto found;\n\n\t\t\tret = key_ref;\n\t\t} else {\n\t\t\tup_read(&cred->request_key_auth->sem);\n\t\t}\n\t}\n\n\t/* no key - decide on the error we're going to go for */\n\tif (err == ERR_PTR(-ENOKEY) || ret == ERR_PTR(-ENOKEY))\n\t\tkey_ref = ERR_PTR(-ENOKEY);\n\telse if (err == ERR_PTR(-EACCES))\n\t\tkey_ref = ret;\n\telse\n\t\tkey_ref = err;\n\nfound:\n\treturn key_ref;\n}\n\n/*\n * See if the key we're looking at is the target key.\n */\nbool lookup_user_key_possessed(const struct key *key,\n\t\t\t       const struct key_match_data *match_data)\n{\n\treturn key == match_data->raw_data;\n}\n\n/*\n * Look up a key ID given us by userspace with a given permissions mask to get\n * the key it refers to.\n *\n * Flags can be passed to request that special keyrings be created if referred\n * to directly, to permit partially constructed keys to be found and to skip\n * validity and permission checks on the found key.\n *\n * Returns a pointer to the key with an incremented usage count if successful;\n * -EINVAL if the key ID is invalid; -ENOKEY if the key ID does not correspond\n * to a key or the best found key was a negative key; -EKEYREVOKED or\n * -EKEYEXPIRED if the best found key was revoked or expired; -EACCES if the\n * found key doesn't grant the requested permit or the LSM denied access to it;\n * or -ENOMEM if a special keyring couldn't be created.\n *\n * In the case of a successful return, the possession attribute is set on the\n * returned key reference.\n */\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    !test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = current_kernel_time().tv_sec;\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}\n\n/*\n * Join the named keyring as the session keyring if possible else attempt to\n * create a new one of that name and join that.\n *\n * If the name is NULL, an empty anonymous keyring will be installed as the\n * session keyring.\n *\n * Named session keyrings are joined with a semaphore held to prevent the\n * keyrings from going away whilst the attempt is made to going them and also\n * to prevent a race in creating compatible session keyrings.\n */\nlong join_session_keyring(const char *name)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\tstruct key *keyring;\n\tlong ret, serial;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\n\t/* if no name is provided, install an anonymous keyring */\n\tif (!name) {\n\t\tret = install_session_keyring_to_cred(new, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tserial = new->session_keyring->serial;\n\t\tret = commit_creds(new);\n\t\tif (ret == 0)\n\t\t\tret = serial;\n\t\tgoto okay;\n\t}\n\n\t/* allow the user to join or create a named keyring */\n\tmutex_lock(&key_session_mutex);\n\n\t/* look for an existing keyring of this name */\n\tkeyring = find_keyring_by_name(name, false);\n\tif (PTR_ERR(keyring) == -ENOKEY) {\n\t\t/* not found - try and create a new one */\n\t\tkeyring = keyring_alloc(\n\t\t\tname, old->uid, old->gid, old,\n\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,\n\t\t\tKEY_ALLOC_IN_QUOTA, NULL, NULL);\n\t\tif (IS_ERR(keyring)) {\n\t\t\tret = PTR_ERR(keyring);\n\t\t\tgoto error2;\n\t\t}\n\t} else if (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto error2;\n\t} else if (keyring == new->session_keyring) {\n\t\tkey_put(keyring);\n\t\tret = 0;\n\t\tgoto error2;\n\t}\n\n\t/* we've got a keyring - now to install it */\n\tret = install_session_keyring_to_cred(new, keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\n\tcommit_creds(new);\n\tmutex_unlock(&key_session_mutex);\n\n\tret = keyring->serial;\n\tkey_put(keyring);\nokay:\n\treturn ret;\n\nerror2:\n\tmutex_unlock(&key_session_mutex);\nerror:\n\tabort_creds(new);\n\treturn ret;\n}\n\n/*\n * Replace a process's session keyring on behalf of one of its children when\n * the target  process is about to resume userspace execution.\n */\nvoid key_change_session_keyring(struct callback_head *twork)\n{\n\tconst struct cred *old = current_cred();\n\tstruct cred *new = container_of(twork, struct cred, rcu);\n\n\tif (unlikely(current->flags & PF_EXITING)) {\n\t\tput_cred(new);\n\t\treturn;\n\t}\n\n\tnew->  uid\t= old->  uid;\n\tnew-> euid\t= old-> euid;\n\tnew-> suid\t= old-> suid;\n\tnew->fsuid\t= old->fsuid;\n\tnew->  gid\t= old->  gid;\n\tnew-> egid\t= old-> egid;\n\tnew-> sgid\t= old-> sgid;\n\tnew->fsgid\t= old->fsgid;\n\tnew->user\t= get_uid(old->user);\n\tnew->user_ns\t= get_user_ns(old->user_ns);\n\tnew->group_info\t= get_group_info(old->group_info);\n\n\tnew->securebits\t= old->securebits;\n\tnew->cap_inheritable\t= old->cap_inheritable;\n\tnew->cap_permitted\t= old->cap_permitted;\n\tnew->cap_effective\t= old->cap_effective;\n\tnew->cap_ambient\t= old->cap_ambient;\n\tnew->cap_bset\t\t= old->cap_bset;\n\n\tnew->jit_keyring\t= old->jit_keyring;\n\tnew->thread_keyring\t= key_get(old->thread_keyring);\n\tnew->process_keyring\t= key_get(old->process_keyring);\n\n\tsecurity_transfer_creds(new, old);\n\n\tcommit_creds(new);\n}\n\n/*\n * Make sure that root's user and user-session keyrings exist.\n */\nstatic int __init init_root_keyring(void)\n{\n\treturn install_user_keyrings();\n}\n\nlate_initcall(init_root_keyring);\n"], "fixing_code": ["/* Userspace key control operations\n *\n * Copyright (C) 2004-5 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/key.h>\n#include <linux/keyctl.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n\n#define KEY_MAX_DESC_SIZE 4096\n\nstatic int key_get_type_from_user(char *type,\n\t\t\t\t  const char __user *_type,\n\t\t\t\t  unsigned len)\n{\n\tint ret;\n\n\tret = strncpy_from_user(type, _type, len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0 || ret >= len)\n\t\treturn -EINVAL;\n\tif (type[0] == '.')\n\t\treturn -EPERM;\n\ttype[len - 1] = '\\0';\n\treturn 0;\n}\n\n/*\n * Extract the description of a new key from userspace and either add it as a\n * new key to the specified keyring or update a matching key in that keyring.\n *\n * If the description is NULL or an empty string, the key type is asked to\n * generate one from the payload.\n *\n * The keyring must be writable so that we can attach the key to it.\n *\n * If successful, the new key's serial number is returned, otherwise an error\n * code is returned.\n */\nSYSCALL_DEFINE5(add_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst void __user *, _payload,\n\t\tsize_t, plen,\n\t\tkey_serial_t, ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tchar type[32], *description;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t/* draw all the data into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdescription = NULL;\n\tif (_description) {\n\t\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(description)) {\n\t\t\tret = PTR_ERR(description);\n\t\t\tgoto error;\n\t\t}\n\t\tif (!*description) {\n\t\t\tkfree(description);\n\t\t\tdescription = NULL;\n\t\t} else if ((description[0] == '.') &&\n\t\t\t   (strncmp(type, \"keyring\", 7) == 0)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto error2;\n\t\t}\n\t}\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\n\tif (_payload) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!payload) {\n\t\t\tif (plen <= PAGE_SIZE)\n\t\t\t\tgoto error2;\n\t\t\tpayload = vmalloc(plen);\n\t\t\tif (!payload)\n\t\t\t\tgoto error2;\n\t\t}\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error3;\n\t}\n\n\t/* find the target keyring (which must be writable) */\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error3;\n\t}\n\n\t/* create or update the requested key and add it to the target\n\t * keyring */\n\tkey_ref = key_create_or_update(keyring_ref, type, description,\n\t\t\t\t       payload, plen, KEY_PERM_UNDEF,\n\t\t\t\t       KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key_ref)) {\n\t\tret = key_ref_to_ptr(key_ref)->serial;\n\t\tkey_ref_put(key_ref);\n\t}\n\telse {\n\t\tret = PTR_ERR(key_ref);\n\t}\n\n\tkey_ref_put(keyring_ref);\n error3:\n\tkvfree(payload);\n error2:\n\tkfree(description);\n error:\n\treturn ret;\n}\n\n/*\n * Search the process keyrings and keyring trees linked from those for a\n * matching key.  Keyrings must have appropriate Search permission to be\n * searched.\n *\n * If a key is found, it will be attached to the destination keyring if there's\n * one specified and the serial number of the key will be returned.\n *\n * If no key is found, /sbin/request-key will be invoked if _callout_info is\n * non-NULL in an attempt to create a key.  The _callout_info string will be\n * passed to /sbin/request-key to aid with completing the request.  If the\n * _callout_info string is \"\" then it will be changed to \"-\".\n */\nSYSCALL_DEFINE4(request_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst char __user *, _callout_info,\n\t\tkey_serial_t, destringid)\n{\n\tstruct key_type *ktype;\n\tstruct key *key;\n\tkey_ref_t dest_ref;\n\tsize_t callout_len;\n\tchar type[32], *description, *callout_info;\n\tlong ret;\n\n\t/* pull the type into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* pull the description into kernel space */\n\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\tif (IS_ERR(description)) {\n\t\tret = PTR_ERR(description);\n\t\tgoto error;\n\t}\n\n\t/* pull the callout info into kernel space */\n\tcallout_info = NULL;\n\tcallout_len = 0;\n\tif (_callout_info) {\n\t\tcallout_info = strndup_user(_callout_info, PAGE_SIZE);\n\t\tif (IS_ERR(callout_info)) {\n\t\t\tret = PTR_ERR(callout_info);\n\t\t\tgoto error2;\n\t\t}\n\t\tcallout_len = strlen(callout_info);\n\t}\n\n\t/* get the destination keyring if specified */\n\tdest_ref = NULL;\n\tif (destringid) {\n\t\tdest_ref = lookup_user_key(destringid, KEY_LOOKUP_CREATE,\n\t\t\t\t\t   KEY_NEED_WRITE);\n\t\tif (IS_ERR(dest_ref)) {\n\t\t\tret = PTR_ERR(dest_ref);\n\t\t\tgoto error3;\n\t\t}\n\t}\n\n\t/* find the key type */\n\tktype = key_type_lookup(type);\n\tif (IS_ERR(ktype)) {\n\t\tret = PTR_ERR(ktype);\n\t\tgoto error4;\n\t}\n\n\t/* do the search */\n\tkey = request_key_and_link(ktype, description, callout_info,\n\t\t\t\t   callout_len, NULL, key_ref_to_ptr(dest_ref),\n\t\t\t\t   KEY_ALLOC_IN_QUOTA);\n\tif (IS_ERR(key)) {\n\t\tret = PTR_ERR(key);\n\t\tgoto error5;\n\t}\n\n\t/* wait for the key to finish being constructed */\n\tret = wait_for_key_construction(key, 1);\n\tif (ret < 0)\n\t\tgoto error6;\n\n\tret = key->serial;\n\nerror6:\n \tkey_put(key);\nerror5:\n\tkey_type_put(ktype);\nerror4:\n\tkey_ref_put(dest_ref);\nerror3:\n\tkfree(callout_info);\nerror2:\n\tkfree(description);\nerror:\n\treturn ret;\n}\n\n/*\n * Get the ID of the specified process keyring.\n *\n * The requested keyring must have search permission to be found.\n *\n * If successful, the ID of the requested keyring will be returned.\n */\nlong keyctl_get_keyring_ID(key_serial_t id, int create)\n{\n\tkey_ref_t key_ref;\n\tunsigned long lflags;\n\tlong ret;\n\n\tlflags = create ? KEY_LOOKUP_CREATE : 0;\n\tkey_ref = lookup_user_key(id, lflags, KEY_NEED_SEARCH);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tret = key_ref_to_ptr(key_ref)->serial;\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Join a (named) session keyring.\n *\n * Create and join an anonymous session keyring or join a named session\n * keyring, creating it if necessary.  A named session keyring must have Search\n * permission for it to be joined.  Session keyrings without this permit will\n * be skipped over.  It is not permitted for userspace to create or join\n * keyrings whose name begin with a dot.\n *\n * If successful, the ID of the joined session keyring will be returned.\n */\nlong keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\n\t/* fetch the name from userspace */\n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = -EPERM;\n\t\tif (name[0] == '.')\n\t\t\tgoto error_name;\n\t}\n\n\t/* join the session */\n\tret = join_session_keyring(name);\nerror_name:\n\tkfree(name);\nerror:\n\treturn ret;\n}\n\n/*\n * Update a key's data payload from the given data.\n *\n * The key must grant the caller Write permission and the key type must support\n * updating for this to work.  A negative key can be positively instantiated\n * with this call.\n *\n * If successful, 0 will be returned.  If the key type does not support\n * updating, then -EOPNOTSUPP will be returned.\n */\nlong keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\tif (_payload) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\n\t/* find the target key (which must be writable) */\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\t/* update the key */\n\tret = key_update(key_ref, payload, plen);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkfree(payload);\nerror:\n\treturn ret;\n}\n\n/*\n * Revoke a key.\n *\n * The key must be grant the caller Write or Setattr permission for this to\n * work.  The key type should give up its quota claim when revoked.  The key\n * and any links to the key will be automatically garbage collected after a\n * certain amount of time (/proc/sys/kernel/keys/gc_delay).\n *\n * Keys with KEY_FLAG_KEEP set should not be revoked.\n *\n * If successful, 0 is returned.\n */\nlong keyctl_revoke_key(key_serial_t id)\n{\n\tkey_ref_t key_ref;\n\tstruct key *key;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tif (ret != -EACCES)\n\t\t\tgoto error;\n\t\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SETATTR);\n\t\tif (IS_ERR(key_ref)) {\n\t\t\tret = PTR_ERR(key_ref);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_revoke(key);\n\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Invalidate a key.\n *\n * The key must be grant the caller Invalidate permission for this to work.\n * The key and any links to the key will be automatically garbage collected\n * immediately.\n *\n * Keys with KEY_FLAG_KEEP set should not be invalidated.\n *\n * If successful, 0 is returned.\n */\nlong keyctl_invalidate_key(key_serial_t id)\n{\n\tkey_ref_t key_ref;\n\tstruct key *key;\n\tlong ret;\n\n\tkenter(\"%d\", id);\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SEARCH);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\n\t\t/* Root is permitted to invalidate certain special keys */\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tkey_ref = lookup_user_key(id, 0, 0);\n\t\t\tif (IS_ERR(key_ref))\n\t\t\t\tgoto error;\n\t\t\tif (test_bit(KEY_FLAG_ROOT_CAN_INVAL,\n\t\t\t\t     &key_ref_to_ptr(key_ref)->flags))\n\t\t\t\tgoto invalidate;\n\t\t\tgoto error_put;\n\t\t}\n\n\t\tgoto error;\n\t}\n\ninvalidate:\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_invalidate(key);\nerror_put:\n\tkey_ref_put(key_ref);\nerror:\n\tkleave(\" = %ld\", ret);\n\treturn ret;\n}\n\n/*\n * Clear the specified keyring, creating an empty process keyring if one of the\n * special keyring IDs is used.\n *\n * The keyring must grant the caller Write permission and not have\n * KEY_FLAG_KEEP set for this to work.  If successful, 0 will be returned.\n */\nlong keyctl_keyring_clear(key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref;\n\tstruct key *keyring;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\n\t\t/* Root is permitted to invalidate certain special keyrings */\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tkeyring_ref = lookup_user_key(ringid, 0, 0);\n\t\t\tif (IS_ERR(keyring_ref))\n\t\t\t\tgoto error;\n\t\t\tif (test_bit(KEY_FLAG_ROOT_CAN_CLEAR,\n\t\t\t\t     &key_ref_to_ptr(keyring_ref)->flags))\n\t\t\t\tgoto clear;\n\t\t\tgoto error_put;\n\t\t}\n\n\t\tgoto error;\n\t}\n\nclear:\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags))\n\t\tret = -EPERM;\n\telse\n\t\tret = keyring_clear(keyring);\nerror_put:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Create a link from a keyring to a key if there's no matching key in the\n * keyring, otherwise replace the link to the matching key with a link to the\n * new key.\n *\n * The key must grant the caller Link permission and the the keyring must grant\n * the caller Write permission.  Furthermore, if an additional link is created,\n * the keyring's quota will be extended.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_keyring_link(key_serial_t id, key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error;\n\t}\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE, KEY_NEED_LINK);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\tret = key_link(key_ref_to_ptr(keyring_ref), key_ref_to_ptr(key_ref));\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Unlink a key from a keyring.\n *\n * The keyring must grant the caller Write permission for this to work; the key\n * itself need not grant the caller anything.  If the last link to a key is\n * removed then that key will be scheduled for destruction.\n *\n * Keys or keyrings with KEY_FLAG_KEEP set should not be unlinked.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_keyring_unlink(key_serial_t id, key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tstruct key *keyring, *key;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error;\n\t}\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_FOR_UNLINK, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey = key_ref_to_ptr(key_ref);\n\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags) &&\n\t    test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tret = key_unlink(keyring, key);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Return a description of a key to userspace.\n *\n * The key must grant the caller View permission for this to work.\n *\n * If there's a buffer, we place up to buflen bytes of data into it formatted\n * in the following way:\n *\n *\ttype;uid;gid;perm;description<NUL>\n *\n * If successful, we return the amount of description available, irrespective\n * of how much we may have copied into the buffer.\n */\nlong keyctl_describe_key(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *infobuf;\n\tlong ret;\n\tint desclen, infolen;\n\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\t/* viewing a key under construction is permitted if we have the\n\t\t * authorisation token handy */\n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(keyid,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  0);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tdesclen = strlen(key->description);\n\n\t/* calculate how much information we're going to return */\n\tret = -ENOMEM;\n\tinfobuf = kasprintf(GFP_KERNEL,\n\t\t\t    \"%s;%d;%d;%08x;\",\n\t\t\t    key->type->name,\n\t\t\t    from_kuid_munged(current_user_ns(), key->uid),\n\t\t\t    from_kgid_munged(current_user_ns(), key->gid),\n\t\t\t    key->perm);\n\tif (!infobuf)\n\t\tgoto error2;\n\tinfolen = strlen(infobuf);\n\tret = infolen + desclen + 1;\n\n\t/* consider returning the data */\n\tif (buffer && buflen >= ret) {\n\t\tif (copy_to_user(buffer, infobuf, infolen) != 0 ||\n\t\t    copy_to_user(buffer + infolen, key->description,\n\t\t\t\t desclen + 1) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\tkfree(infobuf);\nerror2:\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Search the specified keyring and any keyrings it links to for a matching\n * key.  Only keyrings that grant the caller Search permission will be searched\n * (this includes the starting keyring).  Only keys with Search permission can\n * be found.\n *\n * If successful, the found key will be linked to the destination keyring if\n * supplied and the key has Link permission, and the found key ID will be\n * returned.\n */\nlong keyctl_keyring_search(key_serial_t ringid,\n\t\t\t   const char __user *_type,\n\t\t\t   const char __user *_description,\n\t\t\t   key_serial_t destringid)\n{\n\tstruct key_type *ktype;\n\tkey_ref_t keyring_ref, key_ref, dest_ref;\n\tchar type[32], *description;\n\tlong ret;\n\n\t/* pull the type and description into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\tif (IS_ERR(description)) {\n\t\tret = PTR_ERR(description);\n\t\tgoto error;\n\t}\n\n\t/* get the keyring at which to begin the search */\n\tkeyring_ref = lookup_user_key(ringid, 0, KEY_NEED_SEARCH);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error2;\n\t}\n\n\t/* get the destination keyring if specified */\n\tdest_ref = NULL;\n\tif (destringid) {\n\t\tdest_ref = lookup_user_key(destringid, KEY_LOOKUP_CREATE,\n\t\t\t\t\t   KEY_NEED_WRITE);\n\t\tif (IS_ERR(dest_ref)) {\n\t\t\tret = PTR_ERR(dest_ref);\n\t\t\tgoto error3;\n\t\t}\n\t}\n\n\t/* find the key type */\n\tktype = key_type_lookup(type);\n\tif (IS_ERR(ktype)) {\n\t\tret = PTR_ERR(ktype);\n\t\tgoto error4;\n\t}\n\n\t/* do the search */\n\tkey_ref = keyring_search(keyring_ref, ktype, description);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\n\t\t/* treat lack or presence of a negative key the same */\n\t\tif (ret == -EAGAIN)\n\t\t\tret = -ENOKEY;\n\t\tgoto error5;\n\t}\n\n\t/* link the resulting key to the destination keyring if we can */\n\tif (dest_ref) {\n\t\tret = key_permission(key_ref, KEY_NEED_LINK);\n\t\tif (ret < 0)\n\t\t\tgoto error6;\n\n\t\tret = key_link(key_ref_to_ptr(dest_ref), key_ref_to_ptr(key_ref));\n\t\tif (ret < 0)\n\t\t\tgoto error6;\n\t}\n\n\tret = key_ref_to_ptr(key_ref)->serial;\n\nerror6:\n\tkey_ref_put(key_ref);\nerror5:\n\tkey_type_put(ktype);\nerror4:\n\tkey_ref_put(dest_ref);\nerror3:\n\tkey_ref_put(keyring_ref);\nerror2:\n\tkfree(description);\nerror:\n\treturn ret;\n}\n\n/*\n * Read a key's payload.\n *\n * The key must either grant the caller Read permission, or it must grant the\n * caller Search permission when searched for from the process keyrings.\n *\n * If successful, we place up to buflen bytes of data into the buffer, if one\n * is provided, and return the amount of data that is available in the key,\n * irrespective of how much we copied into the buffer.\n */\nlong keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\t/* find the key first */\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* see if we can read it directly */\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\n\t/* we can't; see if it's searchable from this process's keyrings\n\t * - we automatically take account of the fact that it may be\n\t *   dangling off an instantiation key\n\t */\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\n\n\t/* the key is probably readable - now try to read it */\ncan_read_key:\n\tret = -EOPNOTSUPP;\n\tif (key->type->read) {\n\t\t/* Read the data with the semaphore held (since we might sleep)\n\t\t * to protect against the key being updated or revoked.\n\t\t */\n\t\tdown_read(&key->sem);\n\t\tret = key_validate(key);\n\t\tif (ret == 0)\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\tup_read(&key->sem);\n\t}\n\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}\n\n/*\n * Change the ownership of a key\n *\n * The key must grant the caller Setattr permission for this to work, though\n * the key need not be fully instantiated yet.  For the UID to be changed, or\n * for the GID to be changed to a group the caller is not a member of, the\n * caller must have sysadmin capability.  If either uid or gid is -1 then that\n * attribute is not changed.\n *\n * If the UID is to be changed, the new user must have sufficient quota to\n * accept the key.  The quota deduction will be removed from the old user to\n * the new user should the attribute be changed.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_chown_key(key_serial_t id, uid_t user, gid_t group)\n{\n\tstruct key_user *newowner, *zapowner = NULL;\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tuid = make_kuid(current_user_ns(), user);\n\tgid = make_kgid(current_user_ns(), group);\n\tret = -EINVAL;\n\tif ((user != (uid_t) -1) && !uid_valid(uid))\n\t\tgoto error;\n\tif ((group != (gid_t) -1) && !gid_valid(gid))\n\t\tgoto error;\n\n\tret = 0;\n\tif (user == (uid_t) -1 && group == (gid_t) -1)\n\t\tgoto error;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* make the changes with the locks held to prevent chown/chown races */\n\tret = -EACCES;\n\tdown_write(&key->sem);\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t/* only the sysadmin can chown a key to some other UID */\n\t\tif (user != (uid_t) -1 && !uid_eq(key->uid, uid))\n\t\t\tgoto error_put;\n\n\t\t/* only the sysadmin can set the key's GID to a group other\n\t\t * than one of those that the current process subscribes to */\n\t\tif (group != (gid_t) -1 && !gid_eq(gid, key->gid) && !in_group_p(gid))\n\t\t\tgoto error_put;\n\t}\n\n\t/* change the UID */\n\tif (user != (uid_t) -1 && !uid_eq(uid, key->uid)) {\n\t\tret = -ENOMEM;\n\t\tnewowner = key_user_lookup(uid);\n\t\tif (!newowner)\n\t\t\tgoto error_put;\n\n\t\t/* transfer the quota burden to the new user */\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tunsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\t\tkey_quota_root_maxkeys : key_quota_maxkeys;\n\t\t\tunsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\t\tspin_lock(&newowner->lock);\n\t\t\tif (newowner->qnkeys + 1 >= maxkeys ||\n\t\t\t    newowner->qnbytes + key->quotalen >= maxbytes ||\n\t\t\t    newowner->qnbytes + key->quotalen <\n\t\t\t    newowner->qnbytes)\n\t\t\t\tgoto quota_overrun;\n\n\t\t\tnewowner->qnkeys++;\n\t\t\tnewowner->qnbytes += key->quotalen;\n\t\t\tspin_unlock(&newowner->lock);\n\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n\t\tatomic_inc(&newowner->nkeys);\n\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\t\tatomic_inc(&newowner->nikeys);\n\t\t}\n\n\t\tzapowner = key->user;\n\t\tkey->user = newowner;\n\t\tkey->uid = uid;\n\t}\n\n\t/* change the GID */\n\tif (group != (gid_t) -1)\n\t\tkey->gid = gid;\n\n\tret = 0;\n\nerror_put:\n\tup_write(&key->sem);\n\tkey_put(key);\n\tif (zapowner)\n\t\tkey_user_put(zapowner);\nerror:\n\treturn ret;\n\nquota_overrun:\n\tspin_unlock(&newowner->lock);\n\tzapowner = newowner;\n\tret = -EDQUOT;\n\tgoto error_put;\n}\n\n/*\n * Change the permission mask on a key.\n *\n * The key must grant the caller Setattr permission for this to work, though\n * the key need not be fully instantiated yet.  If the caller does not have\n * sysadmin capability, it may only change the permission on keys that it owns.\n */\nlong keyctl_setperm_key(key_serial_t id, key_perm_t perm)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (perm & ~(KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL))\n\t\tgoto error;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* make the changes with the locks held to prevent chown/chmod races */\n\tret = -EACCES;\n\tdown_write(&key->sem);\n\n\t/* if we're not the sysadmin, we can only change a key that we own */\n\tif (capable(CAP_SYS_ADMIN) || uid_eq(key->uid, current_fsuid())) {\n\t\tkey->perm = perm;\n\t\tret = 0;\n\t}\n\n\tup_write(&key->sem);\n\tkey_put(key);\nerror:\n\treturn ret;\n}\n\n/*\n * Get the destination keyring for instantiation and check that the caller has\n * Write permission on it.\n */\nstatic long get_instantiation_keyring(key_serial_t ringid,\n\t\t\t\t      struct request_key_auth *rka,\n\t\t\t\t      struct key **_dest_keyring)\n{\n\tkey_ref_t dkref;\n\n\t*_dest_keyring = NULL;\n\n\t/* just return a NULL pointer if we weren't asked to make a link */\n\tif (ringid == 0)\n\t\treturn 0;\n\n\t/* if a specific keyring is nominated by ID, then use that */\n\tif (ringid > 0) {\n\t\tdkref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\t\tif (IS_ERR(dkref))\n\t\t\treturn PTR_ERR(dkref);\n\t\t*_dest_keyring = key_ref_to_ptr(dkref);\n\t\treturn 0;\n\t}\n\n\tif (ringid == KEY_SPEC_REQKEY_AUTH_KEY)\n\t\treturn -EINVAL;\n\n\t/* otherwise specify the destination keyring recorded in the\n\t * authorisation key (any KEY_SPEC_*_KEYRING) */\n\tif (ringid >= KEY_SPEC_REQUESTOR_KEYRING) {\n\t\t*_dest_keyring = key_get(rka->dest_keyring);\n\t\treturn 0;\n\t}\n\n\treturn -ENOKEY;\n}\n\n/*\n * Change the request_key authorisation key on the current process.\n */\nstatic int keyctl_change_reqkey_auth(struct key *key)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tkey_put(new->request_key_auth);\n\tnew->request_key_auth = key_get(key);\n\n\treturn commit_creds(new);\n}\n\n/*\n * Instantiate a key with the specified payload and link the key into the\n * destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_instantiate_key_common(key_serial_t id,\n\t\t\t\t   struct iov_iter *from,\n\t\t\t\t   key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tsize_t plen = from ? iov_iter_count(from) : 0;\n\tvoid *payload;\n\tlong ret;\n\n\tkenter(\"%d,,%zu,%d\", id, plen, ringid);\n\n\tif (!plen)\n\t\tfrom = NULL;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t/* the appropriate instantiation authorisation key must have been\n\t * assumed before calling this */\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\n\tif (from) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload) {\n\t\t\tif (plen <= PAGE_SIZE)\n\t\t\t\tgoto error;\n\t\t\tpayload = vmalloc(plen);\n\t\t\tif (!payload)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tret = -EFAULT;\n\t\tif (!copy_from_iter_full(payload, plen, from))\n\t\t\tgoto error2;\n\t}\n\n\t/* find the destination keyring amongst those belonging to the\n\t * requesting task */\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\n\t/* instantiate the key and link it into a keyring */\n\tret = key_instantiate_and_link(rka->target_key, payload, plen,\n\t\t\t\t       dest_keyring, instkey);\n\n\tkey_put(dest_keyring);\n\n\t/* discard the assumed authority if it's just been disabled by\n\t * instantiation of the key */\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\n\nerror2:\n\tkvfree(payload);\nerror:\n\treturn ret;\n}\n\n/*\n * Instantiate a key with the specified payload and link the key into the\n * destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_instantiate_key(key_serial_t id,\n\t\t\t    const void __user *_payload,\n\t\t\t    size_t plen,\n\t\t\t    key_serial_t ringid)\n{\n\tif (_payload && plen) {\n\t\tstruct iovec iov;\n\t\tstruct iov_iter from;\n\t\tint ret;\n\n\t\tret = import_single_range(WRITE, (void __user *)_payload, plen,\n\t\t\t\t\t  &iov, &from);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\n\t\treturn keyctl_instantiate_key_common(id, &from, ringid);\n\t}\n\n\treturn keyctl_instantiate_key_common(id, NULL, ringid);\n}\n\n/*\n * Instantiate a key with the specified multipart payload and link the key into\n * the destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_instantiate_key_iov(key_serial_t id,\n\t\t\t\tconst struct iovec __user *_payload_iov,\n\t\t\t\tunsigned ioc,\n\t\t\t\tkey_serial_t ringid)\n{\n\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;\n\tstruct iov_iter from;\n\tlong ret;\n\n\tif (!_payload_iov)\n\t\tioc = 0;\n\n\tret = import_iovec(WRITE, _payload_iov, ioc,\n\t\t\t\t    ARRAY_SIZE(iovstack), &iov, &from);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = keyctl_instantiate_key_common(id, &from, ringid);\n\tkfree(iov);\n\treturn ret;\n}\n\n/*\n * Negatively instantiate the key with the given timeout (in seconds) and link\n * the key into the destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * The key and any links to the key will be automatically garbage collected\n * after the timeout expires.\n *\n * Negative keys are used to rate limit repeated request_key() calls by causing\n * them to return -ENOKEY until the negative key expires.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_negate_key(key_serial_t id, unsigned timeout, key_serial_t ringid)\n{\n\treturn keyctl_reject_key(id, timeout, ENOKEY, ringid);\n}\n\n/*\n * Negatively instantiate the key with the given timeout (in seconds) and error\n * code and link the key into the destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * The key and any links to the key will be automatically garbage collected\n * after the timeout expires.\n *\n * Negative keys are used to rate limit repeated request_key() calls by causing\n * them to return the specified error code until the negative key expires.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_reject_key(key_serial_t id, unsigned timeout, unsigned error,\n\t\t       key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tlong ret;\n\n\tkenter(\"%d,%u,%u,%d\", id, timeout, error, ringid);\n\n\t/* must be a valid error code and mustn't be a kernel special */\n\tif (error <= 0 ||\n\t    error >= MAX_ERRNO ||\n\t    error == ERESTARTSYS ||\n\t    error == ERESTARTNOINTR ||\n\t    error == ERESTARTNOHAND ||\n\t    error == ERESTART_RESTARTBLOCK)\n\t\treturn -EINVAL;\n\n\t/* the appropriate instantiation authorisation key must have been\n\t * assumed before calling this */\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t/* find the destination keyring if present (which must also be\n\t * writable) */\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* instantiate the key and link it into a keyring */\n\tret = key_reject_and_link(rka->target_key, timeout, error,\n\t\t\t\t  dest_keyring, instkey);\n\n\tkey_put(dest_keyring);\n\n\t/* discard the assumed authority if it's just been disabled by\n\t * instantiation of the key */\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\n\nerror:\n\treturn ret;\n}\n\n/*\n * Read or set the default keyring in which request_key() will cache keys and\n * return the old setting.\n *\n * If a thread or process keyring is specified then it will be created if it\n * doesn't yet exist.  The old setting will be returned if successful.\n */\nlong keyctl_set_reqkey_keyring(int reqkey_defl)\n{\n\tstruct cred *new;\n\tint ret, old_setting;\n\n\told_setting = current_cred_xxx(jit_keyring);\n\n\tif (reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE)\n\t\treturn old_setting;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tswitch (reqkey_defl) {\n\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\tret = install_thread_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\tret = install_process_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_DEFAULT:\n\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_NO_CHANGE:\n\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\nset:\n\tnew->jit_keyring = reqkey_defl;\n\tcommit_creds(new);\n\treturn old_setting;\nerror:\n\tabort_creds(new);\n\treturn ret;\n}\n\n/*\n * Set or clear the timeout on a key.\n *\n * Either the key must grant the caller Setattr permission or else the caller\n * must hold an instantiation authorisation token for the key.\n *\n * The timeout is either 0 to clear the timeout, or a number of seconds from\n * the current time.  The key and any links to the key will be automatically\n * garbage collected after the timeout expires.\n *\n * Keys with KEY_FLAG_KEEP set should not be timed out.\n *\n * If successful, 0 is returned.\n */\nlong keyctl_set_timeout(key_serial_t id, unsigned timeout)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\t/* setting the timeout on a key under construction is permitted\n\t\t * if we have the authorisation token handy */\n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(id);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(id,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  0);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_set_timeout(key, timeout);\n\tkey_put(key);\n\nerror:\n\treturn ret;\n}\n\n/*\n * Assume (or clear) the authority to instantiate the specified key.\n *\n * This sets the authoritative token currently in force for key instantiation.\n * This must be done for a key to be instantiated.  It has the effect of making\n * available all the keys from the caller of the request_key() that created a\n * key to request_key() calls made by the caller of this function.\n *\n * The caller must have the instantiation key in their process keyrings with a\n * Search permission grant available to the caller.\n *\n * If the ID given is 0, then the setting will be cleared and 0 returned.\n *\n * If the ID given has a matching an authorisation key, then that key will be\n * set and its ID will be returned.  The authorisation key can be read to get\n * the callout information passed to request_key().\n */\nlong keyctl_assume_authority(key_serial_t id)\n{\n\tstruct key *authkey;\n\tlong ret;\n\n\t/* special key IDs aren't permitted */\n\tret = -EINVAL;\n\tif (id < 0)\n\t\tgoto error;\n\n\t/* we divest ourselves of authority if given an ID of 0 */\n\tif (id == 0) {\n\t\tret = keyctl_change_reqkey_auth(NULL);\n\t\tgoto error;\n\t}\n\n\t/* attempt to assume the authority temporarily granted to us whilst we\n\t * instantiate the specified key\n\t * - the authorisation key must be in the current task's keyrings\n\t *   somewhere\n\t */\n\tauthkey = key_get_instantiation_authkey(id);\n\tif (IS_ERR(authkey)) {\n\t\tret = PTR_ERR(authkey);\n\t\tgoto error;\n\t}\n\n\tret = keyctl_change_reqkey_auth(authkey);\n\tif (ret < 0)\n\t\tgoto error;\n\tkey_put(authkey);\n\n\tret = authkey->serial;\nerror:\n\treturn ret;\n}\n\n/*\n * Get a key's the LSM security label.\n *\n * The key must grant the caller View permission for this to work.\n *\n * If there's a buffer, then up to buflen bytes of data will be placed into it.\n *\n * If successful, the amount of information available will be returned,\n * irrespective of how much was copied (including the terminal NUL).\n */\nlong keyctl_get_security(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *context;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\tif (PTR_ERR(key_ref) != -EACCES)\n\t\t\treturn PTR_ERR(key_ref);\n\n\t\t/* viewing a key under construction is also permitted if we\n\t\t * have the authorisation token handy */\n\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\tif (IS_ERR(instkey))\n\t\t\treturn PTR_ERR(instkey);\n\t\tkey_put(instkey);\n\n\t\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, 0);\n\t\tif (IS_ERR(key_ref))\n\t\t\treturn PTR_ERR(key_ref);\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\tret = security_key_getsecurity(key, &context);\n\tif (ret == 0) {\n\t\t/* if no information was returned, give userspace an empty\n\t\t * string */\n\t\tret = 1;\n\t\tif (buffer && buflen > 0 &&\n\t\t    copy_to_user(buffer, \"\", 1) != 0)\n\t\t\tret = -EFAULT;\n\t} else if (ret > 0) {\n\t\t/* return as much data as there's room for */\n\t\tif (buffer && buflen > 0) {\n\t\t\tif (buflen > ret)\n\t\t\t\tbuflen = ret;\n\n\t\t\tif (copy_to_user(buffer, context, buflen) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(context);\n\t}\n\n\tkey_ref_put(key_ref);\n\treturn ret;\n}\n\n/*\n * Attempt to install the calling process's session keyring on the process's\n * parent process.\n *\n * The keyring must exist and must grant the caller LINK permission, and the\n * parent process must be single-threaded and must have the same effective\n * ownership as this process and mustn't be SUID/SGID.\n *\n * The keyring will be emplaced on the parent when it next resumes userspace.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_session_to_parent(void)\n{\n\tstruct task_struct *me, *parent;\n\tconst struct cred *mycred, *pcred;\n\tstruct callback_head *newwork, *oldwork;\n\tkey_ref_t keyring_r;\n\tstruct cred *cred;\n\tint ret;\n\n\tkeyring_r = lookup_user_key(KEY_SPEC_SESSION_KEYRING, 0, KEY_NEED_LINK);\n\tif (IS_ERR(keyring_r))\n\t\treturn PTR_ERR(keyring_r);\n\n\tret = -ENOMEM;\n\n\t/* our parent is going to need a new cred struct, a new tgcred struct\n\t * and new security data, so we allocate them here to prevent ENOMEM in\n\t * our parent */\n\tcred = cred_alloc_blank();\n\tif (!cred)\n\t\tgoto error_keyring;\n\tnewwork = &cred->rcu;\n\n\tcred->session_keyring = key_ref_to_ptr(keyring_r);\n\tkeyring_r = NULL;\n\tinit_task_work(newwork, key_change_session_keyring);\n\n\tme = current;\n\trcu_read_lock();\n\twrite_lock_irq(&tasklist_lock);\n\n\tret = -EPERM;\n\toldwork = NULL;\n\tparent = me->real_parent;\n\n\t/* the parent mustn't be init and mustn't be a kernel thread */\n\tif (parent->pid <= 1 || !parent->mm)\n\t\tgoto unlock;\n\n\t/* the parent must be single threaded */\n\tif (!thread_group_empty(parent))\n\t\tgoto unlock;\n\n\t/* the parent and the child must have different session keyrings or\n\t * there's no point */\n\tmycred = current_cred();\n\tpcred = __task_cred(parent);\n\tif (mycred == pcred ||\n\t    mycred->session_keyring == pcred->session_keyring) {\n\t\tret = 0;\n\t\tgoto unlock;\n\t}\n\n\t/* the parent must have the same effective ownership and mustn't be\n\t * SUID/SGID */\n\tif (!uid_eq(pcred->uid,\t mycred->euid) ||\n\t    !uid_eq(pcred->euid, mycred->euid) ||\n\t    !uid_eq(pcred->suid, mycred->euid) ||\n\t    !gid_eq(pcred->gid,\t mycred->egid) ||\n\t    !gid_eq(pcred->egid, mycred->egid) ||\n\t    !gid_eq(pcred->sgid, mycred->egid))\n\t\tgoto unlock;\n\n\t/* the keyrings must have the same UID */\n\tif ((pcred->session_keyring &&\n\t     !uid_eq(pcred->session_keyring->uid, mycred->euid)) ||\n\t    !uid_eq(mycred->session_keyring->uid, mycred->euid))\n\t\tgoto unlock;\n\n\t/* cancel an already pending keyring replacement */\n\toldwork = task_work_cancel(parent, key_change_session_keyring);\n\n\t/* the replacement session keyring is applied just prior to userspace\n\t * restarting */\n\tret = task_work_add(parent, newwork, true);\n\tif (!ret)\n\t\tnewwork = NULL;\nunlock:\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\tif (oldwork)\n\t\tput_cred(container_of(oldwork, struct cred, rcu));\n\tif (newwork)\n\t\tput_cred(cred);\n\treturn ret;\n\nerror_keyring:\n\tkey_ref_put(keyring_r);\n\treturn ret;\n}\n\n/*\n * The key control system call\n */\nSYSCALL_DEFINE5(keyctl, int, option, unsigned long, arg2, unsigned long, arg3,\n\t\tunsigned long, arg4, unsigned long, arg5)\n{\n\tswitch (option) {\n\tcase KEYCTL_GET_KEYRING_ID:\n\t\treturn keyctl_get_keyring_ID((key_serial_t) arg2,\n\t\t\t\t\t     (int) arg3);\n\n\tcase KEYCTL_JOIN_SESSION_KEYRING:\n\t\treturn keyctl_join_session_keyring((const char __user *) arg2);\n\n\tcase KEYCTL_UPDATE:\n\t\treturn keyctl_update_key((key_serial_t) arg2,\n\t\t\t\t\t (const void __user *) arg3,\n\t\t\t\t\t (size_t) arg4);\n\n\tcase KEYCTL_REVOKE:\n\t\treturn keyctl_revoke_key((key_serial_t) arg2);\n\n\tcase KEYCTL_DESCRIBE:\n\t\treturn keyctl_describe_key((key_serial_t) arg2,\n\t\t\t\t\t   (char __user *) arg3,\n\t\t\t\t\t   (unsigned) arg4);\n\n\tcase KEYCTL_CLEAR:\n\t\treturn keyctl_keyring_clear((key_serial_t) arg2);\n\n\tcase KEYCTL_LINK:\n\t\treturn keyctl_keyring_link((key_serial_t) arg2,\n\t\t\t\t\t   (key_serial_t) arg3);\n\n\tcase KEYCTL_UNLINK:\n\t\treturn keyctl_keyring_unlink((key_serial_t) arg2,\n\t\t\t\t\t     (key_serial_t) arg3);\n\n\tcase KEYCTL_SEARCH:\n\t\treturn keyctl_keyring_search((key_serial_t) arg2,\n\t\t\t\t\t     (const char __user *) arg3,\n\t\t\t\t\t     (const char __user *) arg4,\n\t\t\t\t\t     (key_serial_t) arg5);\n\n\tcase KEYCTL_READ:\n\t\treturn keyctl_read_key((key_serial_t) arg2,\n\t\t\t\t       (char __user *) arg3,\n\t\t\t\t       (size_t) arg4);\n\n\tcase KEYCTL_CHOWN:\n\t\treturn keyctl_chown_key((key_serial_t) arg2,\n\t\t\t\t\t(uid_t) arg3,\n\t\t\t\t\t(gid_t) arg4);\n\n\tcase KEYCTL_SETPERM:\n\t\treturn keyctl_setperm_key((key_serial_t) arg2,\n\t\t\t\t\t  (key_perm_t) arg3);\n\n\tcase KEYCTL_INSTANTIATE:\n\t\treturn keyctl_instantiate_key((key_serial_t) arg2,\n\t\t\t\t\t      (const void __user *) arg3,\n\t\t\t\t\t      (size_t) arg4,\n\t\t\t\t\t      (key_serial_t) arg5);\n\n\tcase KEYCTL_NEGATE:\n\t\treturn keyctl_negate_key((key_serial_t) arg2,\n\t\t\t\t\t (unsigned) arg3,\n\t\t\t\t\t (key_serial_t) arg4);\n\n\tcase KEYCTL_SET_REQKEY_KEYRING:\n\t\treturn keyctl_set_reqkey_keyring(arg2);\n\n\tcase KEYCTL_SET_TIMEOUT:\n\t\treturn keyctl_set_timeout((key_serial_t) arg2,\n\t\t\t\t\t  (unsigned) arg3);\n\n\tcase KEYCTL_ASSUME_AUTHORITY:\n\t\treturn keyctl_assume_authority((key_serial_t) arg2);\n\n\tcase KEYCTL_GET_SECURITY:\n\t\treturn keyctl_get_security((key_serial_t) arg2,\n\t\t\t\t\t   (char __user *) arg3,\n\t\t\t\t\t   (size_t) arg4);\n\n\tcase KEYCTL_SESSION_TO_PARENT:\n\t\treturn keyctl_session_to_parent();\n\n\tcase KEYCTL_REJECT:\n\t\treturn keyctl_reject_key((key_serial_t) arg2,\n\t\t\t\t\t (unsigned) arg3,\n\t\t\t\t\t (unsigned) arg4,\n\t\t\t\t\t (key_serial_t) arg5);\n\n\tcase KEYCTL_INSTANTIATE_IOV:\n\t\treturn keyctl_instantiate_key_iov(\n\t\t\t(key_serial_t) arg2,\n\t\t\t(const struct iovec __user *) arg3,\n\t\t\t(unsigned) arg4,\n\t\t\t(key_serial_t) arg5);\n\n\tcase KEYCTL_INVALIDATE:\n\t\treturn keyctl_invalidate_key((key_serial_t) arg2);\n\n\tcase KEYCTL_GET_PERSISTENT:\n\t\treturn keyctl_get_persistent((uid_t)arg2, (key_serial_t)arg3);\n\n\tcase KEYCTL_DH_COMPUTE:\n\t\treturn keyctl_dh_compute((struct keyctl_dh_params __user *) arg2,\n\t\t\t\t\t (char __user *) arg3, (size_t) arg4,\n\t\t\t\t\t (void __user *) arg5);\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n", "/* Manage a process's keyrings\n *\n * Copyright (C) 2004-2005, 2008 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/sched/user.h>\n#include <linux/keyctl.h>\n#include <linux/fs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/user_namespace.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n\n/* Session keyring create vs join semaphore */\nstatic DEFINE_MUTEX(key_session_mutex);\n\n/* User keyring creation semaphore */\nstatic DEFINE_MUTEX(key_user_keyring_mutex);\n\n/* The root user's tracking struct */\nstruct key_user root_key_user = {\n\t.usage\t\t= ATOMIC_INIT(3),\n\t.cons_lock\t= __MUTEX_INITIALIZER(root_key_user.cons_lock),\n\t.lock\t\t= __SPIN_LOCK_UNLOCKED(root_key_user.lock),\n\t.nkeys\t\t= ATOMIC_INIT(2),\n\t.nikeys\t\t= ATOMIC_INIT(2),\n\t.uid\t\t= GLOBAL_ROOT_UID,\n};\n\n/*\n * Install the user and user session keyrings for the current process's UID.\n */\nint install_user_keyrings(void)\n{\n\tstruct user_struct *user;\n\tconst struct cred *cred;\n\tstruct key *uid_keyring, *session_keyring;\n\tkey_perm_t user_keyring_perm;\n\tchar buf[20];\n\tint ret;\n\tuid_t uid;\n\n\tuser_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL;\n\tcred = current_cred();\n\tuser = cred->user;\n\tuid = from_kuid(cred->user_ns, user->uid);\n\n\tkenter(\"%p{%u}\", user, uid);\n\n\tif (user->uid_keyring && user->session_keyring) {\n\t\tkleave(\" = 0 [exist]\");\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&key_user_keyring_mutex);\n\tret = 0;\n\n\tif (!user->uid_keyring) {\n\t\t/* get the UID-specific keyring\n\t\t * - there may be one in existence already as it may have been\n\t\t *   pinned by a session, but the user_struct pointing to it\n\t\t *   may have been destroyed by setuid */\n\t\tsprintf(buf, \"_uid.%u\", uid);\n\n\t\tuid_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(uid_keyring)) {\n\t\t\tuid_keyring = keyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t\t    cred, user_keyring_perm,\n\t\t\t\t\t\t    KEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t\t    NULL, NULL);\n\t\t\tif (IS_ERR(uid_keyring)) {\n\t\t\t\tret = PTR_ERR(uid_keyring);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t/* get a default session keyring (which might also exist\n\t\t * already) */\n\t\tsprintf(buf, \"_uid_ses.%u\", uid);\n\n\t\tsession_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(session_keyring)) {\n\t\t\tsession_keyring =\n\t\t\t\tkeyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t      cred, user_keyring_perm,\n\t\t\t\t\t      KEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t      NULL, NULL);\n\t\t\tif (IS_ERR(session_keyring)) {\n\t\t\t\tret = PTR_ERR(session_keyring);\n\t\t\t\tgoto error_release;\n\t\t\t}\n\n\t\t\t/* we install a link from the user session keyring to\n\t\t\t * the user keyring */\n\t\t\tret = key_link(session_keyring, uid_keyring);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_release_both;\n\t\t}\n\n\t\t/* install the keyrings */\n\t\tuser->uid_keyring = uid_keyring;\n\t\tuser->session_keyring = session_keyring;\n\t}\n\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = 0\");\n\treturn 0;\n\nerror_release_both:\n\tkey_put(session_keyring);\nerror_release:\n\tkey_put(uid_keyring);\nerror:\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Install a thread keyring to the given credentials struct if it didn't have\n * one already.  This is allowed to overrun the quota.\n *\n * Return: 0 if a thread keyring is now present; -errno on failure.\n */\nint install_thread_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->thread_keyring)\n\t\treturn 0;\n\n\tkeyring = keyring_alloc(\"_tid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->thread_keyring = keyring;\n\treturn 0;\n}\n\n/*\n * Install a thread keyring to the current task if it didn't have one already.\n *\n * Return: 0 if a thread keyring is now present; -errno on failure.\n */\nstatic int install_thread_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_thread_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}\n\n/*\n * Install a process keyring to the given credentials struct if it didn't have\n * one already.  This is allowed to overrun the quota.\n *\n * Return: 0 if a process keyring is now present; -errno on failure.\n */\nint install_process_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->process_keyring)\n\t\treturn 0;\n\n\tkeyring = keyring_alloc(\"_pid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->process_keyring = keyring;\n\treturn 0;\n}\n\n/*\n * Install a process keyring to the current task if it didn't have one already.\n *\n * Return: 0 if a process keyring is now present; -errno on failure.\n */\nstatic int install_process_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_process_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}\n\n/*\n * Install the given keyring as the session keyring of the given credentials\n * struct, replacing the existing one if any.  If the given keyring is NULL,\n * then install a new anonymous session keyring.\n *\n * Return: 0 on success; -errno on failure.\n */\nint install_session_keyring_to_cred(struct cred *cred, struct key *keyring)\n{\n\tunsigned long flags;\n\tstruct key *old;\n\n\tmight_sleep();\n\n\t/* create an empty session keyring */\n\tif (!keyring) {\n\t\tflags = KEY_ALLOC_QUOTA_OVERRUN;\n\t\tif (cred->session_keyring)\n\t\t\tflags = KEY_ALLOC_IN_QUOTA;\n\n\t\tkeyring = keyring_alloc(\"_ses\", cred->uid, cred->gid, cred,\n\t\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\t\tflags, NULL, NULL);\n\t\tif (IS_ERR(keyring))\n\t\t\treturn PTR_ERR(keyring);\n\t} else {\n\t\t__key_get(keyring);\n\t}\n\n\t/* install the keyring */\n\told = cred->session_keyring;\n\trcu_assign_pointer(cred->session_keyring, keyring);\n\n\tif (old)\n\t\tkey_put(old);\n\n\treturn 0;\n}\n\n/*\n * Install the given keyring as the session keyring of the current task,\n * replacing the existing one if any.  If the given keyring is NULL, then\n * install a new anonymous session keyring.\n *\n * Return: 0 on success; -errno on failure.\n */\nstatic int install_session_keyring(struct key *keyring)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_session_keyring_to_cred(new, keyring);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}\n\n/*\n * Handle the fsuid changing.\n */\nvoid key_fsuid_changed(struct task_struct *tsk)\n{\n\t/* update the ownership of the thread keyring */\n\tBUG_ON(!tsk->cred);\n\tif (tsk->cred->thread_keyring) {\n\t\tdown_write(&tsk->cred->thread_keyring->sem);\n\t\ttsk->cred->thread_keyring->uid = tsk->cred->fsuid;\n\t\tup_write(&tsk->cred->thread_keyring->sem);\n\t}\n}\n\n/*\n * Handle the fsgid changing.\n */\nvoid key_fsgid_changed(struct task_struct *tsk)\n{\n\t/* update the ownership of the thread keyring */\n\tBUG_ON(!tsk->cred);\n\tif (tsk->cred->thread_keyring) {\n\t\tdown_write(&tsk->cred->thread_keyring->sem);\n\t\ttsk->cred->thread_keyring->gid = tsk->cred->fsgid;\n\t\tup_write(&tsk->cred->thread_keyring->sem);\n\t}\n}\n\n/*\n * Search the process keyrings attached to the supplied cred for the first\n * matching key.\n *\n * The search criteria are the type and the match function.  The description is\n * given to the match function as a parameter, but doesn't otherwise influence\n * the search.  Typically the match function will compare the description\n * parameter to the key's description.\n *\n * This can only search keyrings that grant Search permission to the supplied\n * credentials.  Keyrings linked to searched keyrings will also be searched if\n * they grant Search permission too.  Keys can only be found if they grant\n * Search permission to the credentials.\n *\n * Returns a pointer to the key with the key usage count incremented if\n * successful, -EAGAIN if we didn't find any matching key or -ENOKEY if we only\n * matched negative keys.\n *\n * In the case of a successful return, the possession attribute is set on the\n * returned key reference.\n */\nkey_ref_t search_my_process_keyrings(struct keyring_search_context *ctx)\n{\n\tkey_ref_t key_ref, ret, err;\n\n\t/* we want to return -EAGAIN or -ENOKEY if any of the keyrings were\n\t * searchable, but we failed to find a key or we found a negative key;\n\t * otherwise we want to return a sample error (probably -EACCES) if\n\t * none of the keyrings were searchable\n\t *\n\t * in terms of priority: success > -ENOKEY > -EAGAIN > other error\n\t */\n\tkey_ref = NULL;\n\tret = NULL;\n\terr = ERR_PTR(-EAGAIN);\n\n\t/* search the thread keyring first */\n\tif (ctx->cred->thread_keyring) {\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(ctx->cred->thread_keyring, 1), ctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* search the process keyring second */\n\tif (ctx->cred->process_keyring) {\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(ctx->cred->process_keyring, 1), ctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* search the session keyring */\n\tif (ctx->cred->session_keyring) {\n\t\trcu_read_lock();\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(rcu_dereference(ctx->cred->session_keyring), 1),\n\t\t\tctx);\n\t\trcu_read_unlock();\n\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* or search the user-session keyring */\n\telse if (ctx->cred->user->session_keyring) {\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(ctx->cred->user->session_keyring, 1),\n\t\t\tctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no key - decide on the error we're going to go for */\n\tkey_ref = ret ? ret : err;\n\nfound:\n\treturn key_ref;\n}\n\n/*\n * Search the process keyrings attached to the supplied cred for the first\n * matching key in the manner of search_my_process_keyrings(), but also search\n * the keys attached to the assumed authorisation key using its credentials if\n * one is available.\n *\n * Return same as search_my_process_keyrings().\n */\nkey_ref_t search_process_keyrings(struct keyring_search_context *ctx)\n{\n\tstruct request_key_auth *rka;\n\tkey_ref_t key_ref, ret = ERR_PTR(-EACCES), err;\n\n\tmight_sleep();\n\n\tkey_ref = search_my_process_keyrings(ctx);\n\tif (!IS_ERR(key_ref))\n\t\tgoto found;\n\terr = key_ref;\n\n\t/* if this process has an instantiation authorisation key, then we also\n\t * search the keyrings of the process mentioned there\n\t * - we don't permit access to request_key auth keys via this method\n\t */\n\tif (ctx->cred->request_key_auth &&\n\t    ctx->cred == current_cred() &&\n\t    ctx->index_key.type != &key_type_request_key_auth\n\t    ) {\n\t\tconst struct cred *cred = ctx->cred;\n\n\t\t/* defend against the auth key being revoked */\n\t\tdown_read(&cred->request_key_auth->sem);\n\n\t\tif (key_validate(ctx->cred->request_key_auth) == 0) {\n\t\t\trka = ctx->cred->request_key_auth->payload.data[0];\n\n\t\t\tctx->cred = rka->cred;\n\t\t\tkey_ref = search_process_keyrings(ctx);\n\t\t\tctx->cred = cred;\n\n\t\t\tup_read(&cred->request_key_auth->sem);\n\n\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\tgoto found;\n\n\t\t\tret = key_ref;\n\t\t} else {\n\t\t\tup_read(&cred->request_key_auth->sem);\n\t\t}\n\t}\n\n\t/* no key - decide on the error we're going to go for */\n\tif (err == ERR_PTR(-ENOKEY) || ret == ERR_PTR(-ENOKEY))\n\t\tkey_ref = ERR_PTR(-ENOKEY);\n\telse if (err == ERR_PTR(-EACCES))\n\t\tkey_ref = ret;\n\telse\n\t\tkey_ref = err;\n\nfound:\n\treturn key_ref;\n}\n\n/*\n * See if the key we're looking at is the target key.\n */\nbool lookup_user_key_possessed(const struct key *key,\n\t\t\t       const struct key_match_data *match_data)\n{\n\treturn key == match_data->raw_data;\n}\n\n/*\n * Look up a key ID given us by userspace with a given permissions mask to get\n * the key it refers to.\n *\n * Flags can be passed to request that special keyrings be created if referred\n * to directly, to permit partially constructed keys to be found and to skip\n * validity and permission checks on the found key.\n *\n * Returns a pointer to the key with an incremented usage count if successful;\n * -EINVAL if the key ID is invalid; -ENOKEY if the key ID does not correspond\n * to a key or the best found key was a negative key; -EKEYREVOKED or\n * -EKEYEXPIRED if the best found key was revoked or expired; -EACCES if the\n * found key doesn't grant the requested permit or the LSM denied access to it;\n * or -ENOMEM if a special keyring couldn't be created.\n *\n * In the case of a successful return, the possession attribute is set on the\n * returned key reference.\n */\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    !test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = current_kernel_time().tv_sec;\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}\n\n/*\n * Join the named keyring as the session keyring if possible else attempt to\n * create a new one of that name and join that.\n *\n * If the name is NULL, an empty anonymous keyring will be installed as the\n * session keyring.\n *\n * Named session keyrings are joined with a semaphore held to prevent the\n * keyrings from going away whilst the attempt is made to going them and also\n * to prevent a race in creating compatible session keyrings.\n */\nlong join_session_keyring(const char *name)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\tstruct key *keyring;\n\tlong ret, serial;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\n\t/* if no name is provided, install an anonymous keyring */\n\tif (!name) {\n\t\tret = install_session_keyring_to_cred(new, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tserial = new->session_keyring->serial;\n\t\tret = commit_creds(new);\n\t\tif (ret == 0)\n\t\t\tret = serial;\n\t\tgoto okay;\n\t}\n\n\t/* allow the user to join or create a named keyring */\n\tmutex_lock(&key_session_mutex);\n\n\t/* look for an existing keyring of this name */\n\tkeyring = find_keyring_by_name(name, false);\n\tif (PTR_ERR(keyring) == -ENOKEY) {\n\t\t/* not found - try and create a new one */\n\t\tkeyring = keyring_alloc(\n\t\t\tname, old->uid, old->gid, old,\n\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,\n\t\t\tKEY_ALLOC_IN_QUOTA, NULL, NULL);\n\t\tif (IS_ERR(keyring)) {\n\t\t\tret = PTR_ERR(keyring);\n\t\t\tgoto error2;\n\t\t}\n\t} else if (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto error2;\n\t} else if (keyring == new->session_keyring) {\n\t\tkey_put(keyring);\n\t\tret = 0;\n\t\tgoto error2;\n\t}\n\n\t/* we've got a keyring - now to install it */\n\tret = install_session_keyring_to_cred(new, keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\n\tcommit_creds(new);\n\tmutex_unlock(&key_session_mutex);\n\n\tret = keyring->serial;\n\tkey_put(keyring);\nokay:\n\treturn ret;\n\nerror2:\n\tmutex_unlock(&key_session_mutex);\nerror:\n\tabort_creds(new);\n\treturn ret;\n}\n\n/*\n * Replace a process's session keyring on behalf of one of its children when\n * the target  process is about to resume userspace execution.\n */\nvoid key_change_session_keyring(struct callback_head *twork)\n{\n\tconst struct cred *old = current_cred();\n\tstruct cred *new = container_of(twork, struct cred, rcu);\n\n\tif (unlikely(current->flags & PF_EXITING)) {\n\t\tput_cred(new);\n\t\treturn;\n\t}\n\n\tnew->  uid\t= old->  uid;\n\tnew-> euid\t= old-> euid;\n\tnew-> suid\t= old-> suid;\n\tnew->fsuid\t= old->fsuid;\n\tnew->  gid\t= old->  gid;\n\tnew-> egid\t= old-> egid;\n\tnew-> sgid\t= old-> sgid;\n\tnew->fsgid\t= old->fsgid;\n\tnew->user\t= get_uid(old->user);\n\tnew->user_ns\t= get_user_ns(old->user_ns);\n\tnew->group_info\t= get_group_info(old->group_info);\n\n\tnew->securebits\t= old->securebits;\n\tnew->cap_inheritable\t= old->cap_inheritable;\n\tnew->cap_permitted\t= old->cap_permitted;\n\tnew->cap_effective\t= old->cap_effective;\n\tnew->cap_ambient\t= old->cap_ambient;\n\tnew->cap_bset\t\t= old->cap_bset;\n\n\tnew->jit_keyring\t= old->jit_keyring;\n\tnew->thread_keyring\t= key_get(old->thread_keyring);\n\tnew->process_keyring\t= key_get(old->process_keyring);\n\n\tsecurity_transfer_creds(new, old);\n\n\tcommit_creds(new);\n}\n\n/*\n * Make sure that root's user and user-session keyrings exist.\n */\nstatic int __init init_root_keyring(void)\n{\n\treturn install_user_keyrings();\n}\n\nlate_initcall(init_root_keyring);\n"], "filenames": ["security/keys/keyctl.c", "security/keys/process_keys.c"], "buggy_code_start_loc": [1261, 131], "buggy_code_end_loc": [1292, 259], "fixing_code_start_loc": [1261, 131], "fixing_code_end_loc": [1289, 269], "type": "CWE-404", "message": "The KEYS subsystem in the Linux kernel before 4.10.13 allows local users to cause a denial of service (memory consumption) via a series of KEY_REQKEY_DEFL_THREAD_KEYRING keyctl_set_reqkey_keyring calls.", "other": {"cve": {"id": "CVE-2017-7472", "sourceIdentifier": "secalert@redhat.com", "published": "2017-05-11T19:29:00.163", "lastModified": "2023-02-12T23:30:04.230", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The KEYS subsystem in the Linux kernel before 4.10.13 allows local users to cause a denial of service (memory consumption) via a series of KEY_REQKEY_DEFL_THREAD_KEYRING keyctl_set_reqkey_keyring calls."}, {"lang": "es", "value": "El subsistema KEYS en el kernel de Linux anterior a 4.10.13 permite a los usuarios locales causar una denegaci\u00f3n de servicio (consumo de memoria) a trav\u00e9s de una serie de llamadas KEY_REQKEY_DEFL_THREAD_KEYRING keyctl_set_reqkey_keyring."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-404"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.10.12", "matchCriteriaId": "A1467C00-A66E-4711-9C37-A5FE885B7BA6"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=c9f838d104fed6f2f61d68164712e3204bf5271b", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2018-01/msg00007.html", "source": "secalert@redhat.com"}, {"url": "http://openwall.com/lists/oss-security/2017/05/11/1", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/98422", "source": "secalert@redhat.com"}, {"url": "http://www.securitytracker.com/id/1038471", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2018:0151", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2018:0152", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2018:0181", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.novell.com/show_bug.cgi?id=1034862", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1442086", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/torvalds/linux/commit/c9f838d104fed6f2f61d68164712e3204bf5271b", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lkml.org/lkml/2017/4/1/235", "source": "secalert@redhat.com", "tags": ["Broken Link"]}, {"url": "https://lkml.org/lkml/2017/4/3/724", "source": "secalert@redhat.com", "tags": ["Broken Link"]}, {"url": "https://www.exploit-db.com/exploits/42136/", "source": "secalert@redhat.com"}, {"url": "https://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.10.13", "source": "secalert@redhat.com", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/c9f838d104fed6f2f61d68164712e3204bf5271b"}}