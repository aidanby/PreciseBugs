{"buggy_code": ["from __future__ import annotations\n\nimport base64\nimport html\nimport logging\nimport os\nimport pathlib\nimport pickle\nimport random\nimport re\nimport string\nfrom io import StringIO\nfrom typing import Optional, Union\n\nfrom packaging.version import Version\n\nfrom mlflow.exceptions import INVALID_PARAMETER_VALUE, MlflowException\n\nCARD_PICKLE_NAME = \"card.pkl\"\nCARD_HTML_NAME = \"card.html\"\n\n_PP_VARIABLE_LINK_REGEX = re.compile(r'<a\\s+href=\"?(?P<href>#pp_var_[-0-9]+)\"?\\s*>')\n\n\n_logger = logging.getLogger(__name__)\n\n\nclass CardTab:\n    def __init__(self, name: str, template: str) -> None:\n        \"\"\"\n        Construct a step card tab with supported HTML template.\n\n        :param name: a string representing the name of the tab.\n        :param template: a string representing the HTML template for the card content.\n        \"\"\"\n        import jinja2\n        from jinja2 import meta as jinja2_meta\n\n        self.name = name\n        self.template = template\n\n        j2_env = jinja2.Environment()\n        self._variables = jinja2_meta.find_undeclared_variables(j2_env.parse(template))\n        self._context = {}\n\n    def add_html(self, name: str, html_content: str) -> CardTab:\n        \"\"\"\n        Adds html to the CardTab.\n\n        :param name: String, name of the variable in the Jinja2 template\n        :param html_content: String, the html to replace the named template variable\n        :return: the updated card instance\n        \"\"\"\n        if name not in self._variables:\n            raise MlflowException(\n                f\"{name} is not a valid template variable defined in template: '{self.template}'\",\n                error_code=INVALID_PARAMETER_VALUE,\n            )\n        self._context[name] = html_content\n        return self\n\n    def add_markdown(self, name: str, markdown: str) -> CardTab:\n        \"\"\"\n        Adds markdown to the card replacing the variable name in the CardTab template.\n\n        :param name: name of the variable in the CardTab Jinja2 template\n        :param markdown: the markdown content\n        :return: the updated card tab instance\n        \"\"\"\n        from markdown import markdown as md_to_html\n\n        self.add_html(name, md_to_html(markdown))\n        return self\n\n    def add_image(\n        self,\n        name: str,\n        image_file_path: str,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n    ) -> None:\n        if not os.path.exists(image_file_path):\n            self.add_html(name, \"Image Unavailable\")\n            _logger.warning(f\"Unable to locate image file {image_file_path} to render {name}.\")\n            return\n\n        with open(image_file_path, \"rb\") as f:\n            base64_str = base64.b64encode(f.read()).decode(\"utf-8\")\n\n        image_type = pathlib.Path(image_file_path).suffix[1:]\n\n        width_style = f'width=\"{width}\"' if width else \"\"\n        height_style = f'height=\"{width}\"' if height else \"\"\n        img_html = (\n            f'<img src=\"data:image/{image_type};base64, {base64_str}\" '\n            f\"{width_style} {height_style} />\"\n        )\n        self.add_html(name, img_html)\n\n    def add_pandas_profile(self, name: str, profile: str) -> CardTab:\n        \"\"\"\n        Add a new tab representing the provided pandas profile to the card.\n\n        :param name: name of the variable in the Jinja2 template\n        :param profile: html string to render profile in the step card\n        :return: the updated card instance\n        \"\"\"\n        try:\n            profile_iframe = (\n                \"<iframe srcdoc='{src}' width='100%' height='500' frameborder='0'></iframe>\"\n            ).format(src=html.escape(profile))\n        except Exception as e:\n            profile_iframe = f\"Unable to create data profile. Error found:\\n{e}\"\n        self.add_html(name, profile_iframe)\n        return self\n\n    def to_html(self) -> str:\n        \"\"\"\n        Returns a rendered HTML representing the content of the tab.\n\n        :return: a HTML string\n        \"\"\"\n        import jinja2\n\n        j2_env = jinja2.Environment(loader=jinja2.BaseLoader()).from_string(self.template)\n        return j2_env.render({**self._context})\n\n\nclass BaseCard:\n    def __init__(self, recipe_name: str, step_name: str) -> None:\n        \"\"\"\n        BaseCard Constructor\n\n        :param recipe_name: a string representing name of the recipe.\n        :param step_name: a string representing the name of the step.\n        \"\"\"\n        self._recipe_name = recipe_name\n        self._step_name = step_name\n        self._template_name = \"base.html\"\n\n        self._string_builder = StringIO()\n        self._tabs = []\n\n    def add_tab(self, name, html_template) -> CardTab:\n        \"\"\"\n        Add a new tab with arbitrary content.\n\n        :param name: a string representing the name of the tab.\n        :param html_template: a string representing the HTML template for the card content.\n        \"\"\"\n        tab = CardTab(name, html_template)\n        self._tabs.append((name, tab))\n        return tab\n\n    def get_tab(self, name) -> Union[CardTab, None]:\n        \"\"\"\n        Returns an existing tab with the specified name. Returns None if not found.\n\n        :param name: a string representing the name of the tab.\n        \"\"\"\n        for key, tab in self._tabs:\n            if key == name:\n                return tab\n        return None\n\n    def add_text(self, text: str) -> BaseCard:\n        \"\"\"\n        Add text to the textual representation of this card.\n\n        :param text: a string text\n        :return: the updated card instance\n        \"\"\"\n        self._string_builder.write(text)\n        return self\n\n    def to_html(self) -> str:\n        \"\"\"\n        This funtion renders the Jinja2 template based on the provided context so far.\n\n        :return: a HTML string\n        \"\"\"\n        import jinja2\n\n        def get_random_id(length=6):\n            return \"\".join(\n                random.choice(string.ascii_lowercase + string.digits) for _ in range(length)\n            )\n\n        base_template_path = os.path.join(os.path.dirname(__file__), \"templates\")\n        j2_env = jinja2.Environment(loader=jinja2.FileSystemLoader(base_template_path))\n        tab_list = [(name, tab.to_html()) for name, tab in self._tabs]\n        page_id = get_random_id()\n        return j2_env.get_template(self._template_name).render(\n            {\n                \"HEADER_TITLE\": f\"{self._step_name.capitalize()}@{self._recipe_name}\",\n                \"TABLINK\": f\"tablink-{page_id}\",\n                \"CONTENT\": f\"content-{page_id}\",\n                \"BUTTON_CONTAINER\": f\"button-container-{page_id}\",\n                \"tab_list\": tab_list,\n            }\n        )\n\n    def to_text(self) -> str:\n        \"\"\"\n        :return: the textual representation of the card.\n        \"\"\"\n        return self._string_builder.getvalue()\n\n    def save_as_html(self, path) -> None:\n        if os.path.isdir(path):\n            path = os.path.join(path, CARD_HTML_NAME)\n        with open(path, \"w\", encoding=\"utf-8\") as f:\n            f.write(self.to_html())\n\n    def save(self, path: str) -> None:\n        if os.path.isdir(path):\n            path = os.path.join(path, CARD_PICKLE_NAME)\n        with open(path, \"wb\") as out:\n            pickle.dump(self, out)\n\n    @staticmethod\n    def load(path):\n        if os.path.isdir(path):\n            path = os.path.join(path, CARD_PICKLE_NAME)\n        with open(path, \"rb\") as f:\n            return pickle.load(f)\n\n    @staticmethod\n    def render_table(table, columns=None, hide_index=True):\n        \"\"\"\n        Renders a table-like object as an HTML table.\n\n        :param table: Table-like object (e.g. pandas DataFrame, 2D numpy array, list of tuples).\n        :param columns: Column names to use. If `table` doesn't have column names, this argument\n            provides names for the columns. Otherwise, only the specified columns will be included\n            in the output HTML table.\n        :param hide_index: Hide index column when rendering.\n        \"\"\"\n        import pandas as pd\n        from pandas.io.formats.style import Styler\n\n        if not isinstance(table, Styler):\n            table = pd.DataFrame(table, columns=columns).style\n\n        pandas_version = Version(pd.__version__)\n\n        styler = table.set_table_attributes('style=\"border-collapse:collapse\"').set_table_styles(\n            [\n                {\n                    \"selector\": \"table, th, td\",\n                    \"props\": [\n                        (\"border\", \"1px solid grey\"),\n                        (\"text-align\", \"left\"),\n                        (\"padding\", \"5px\"),\n                    ],\n                },\n            ]\n        )\n        if hide_index:\n            rendered_table = (\n                styler.hide(axis=\"index\").to_html()\n                if pandas_version >= Version(\"1.4.0\")\n                else styler.hide_index().render()\n            )\n        else:\n            rendered_table = (\n                styler.to_html() if pandas_version >= Version(\"1.4.0\") else styler.render()\n            )\n        return f'<div style=\"max-height: 500px; overflow: scroll;\">{rendered_table}</div>'\n\n\nclass FailureCard(BaseCard):\n    \"\"\"\n    Step card providing information about a failed step execution, including a stacktrace.\n\n    TODO: Migrate the failure card to a tab-based card, removing this class and its associated\n          HTML template in the process.\n    \"\"\"\n\n    def __init__(\n        self, recipe_name: str, step_name: str, failure_traceback: str, output_directory: str\n    ):\n        super().__init__(\n            recipe_name=recipe_name,\n            step_name=step_name,\n        )\n        self.add_tab(\"Step Status\", \"{{ STEP_STATUS }}\").add_html(\n            \"STEP_STATUS\",\n            '<p><strong>Step status: <span style=\"color:red\">Failed</span></strong></p>',\n        )\n        self.add_tab(\n            \"Stacktrace\", \"<div class='stacktrace-container'>{{ STACKTRACE }}</div>\"\n        ).add_html(\"STACKTRACE\", f'<p style=\"margin-top:0px\"><code>{failure_traceback}</code></p>')\n        warning_output_path = os.path.join(output_directory, \"warning_logs.txt\")\n        if os.path.exists(warning_output_path):\n            with open(warning_output_path) as f:\n                self.add_tab(\"Warning Logs\", \"{{ STEP_WARNINGS }}\").add_html(\n                    \"STEP_WARNINGS\", f\"<pre>{f.read()}</pre>\"\n                )\n"], "fixing_code": ["from __future__ import annotations\n\nimport base64\nimport html\nimport logging\nimport os\nimport pathlib\nimport pickle\nimport random\nimport re\nimport string\nfrom io import StringIO\nfrom typing import Optional, Union\n\nfrom packaging.version import Version\n\nfrom mlflow.exceptions import INVALID_PARAMETER_VALUE, MlflowException\n\nCARD_PICKLE_NAME = \"card.pkl\"\nCARD_HTML_NAME = \"card.html\"\n\n_PP_VARIABLE_LINK_REGEX = re.compile(r'<a\\s+href=\"?(?P<href>#pp_var_[-0-9]+)\"?\\s*>')\n\n\n_logger = logging.getLogger(__name__)\n\n\nclass CardTab:\n    def __init__(self, name: str, template: str) -> None:\n        \"\"\"\n        Construct a step card tab with supported HTML template.\n\n        :param name: a string representing the name of the tab.\n        :param template: a string representing the HTML template for the card content.\n        \"\"\"\n        import jinja2\n        from jinja2 import meta as jinja2_meta\n\n        self.name = name\n        self.template = template\n\n        j2_env = jinja2.Environment()\n        self._variables = jinja2_meta.find_undeclared_variables(j2_env.parse(template))\n        self._context = {}\n\n    def add_html(self, name: str, html_content: str) -> CardTab:\n        \"\"\"\n        Adds html to the CardTab.\n\n        :param name: String, name of the variable in the Jinja2 template\n        :param html_content: String, the html to replace the named template variable\n        :return: the updated card instance\n        \"\"\"\n        if name not in self._variables:\n            raise MlflowException(\n                f\"{name} is not a valid template variable defined in template: '{self.template}'\",\n                error_code=INVALID_PARAMETER_VALUE,\n            )\n        self._context[name] = html_content\n        return self\n\n    def add_markdown(self, name: str, markdown: str) -> CardTab:\n        \"\"\"\n        Adds markdown to the card replacing the variable name in the CardTab template.\n\n        :param name: name of the variable in the CardTab Jinja2 template\n        :param markdown: the markdown content\n        :return: the updated card tab instance\n        \"\"\"\n        from markdown import markdown as md_to_html\n\n        self.add_html(name, md_to_html(markdown))\n        return self\n\n    def add_image(\n        self,\n        name: str,\n        image_file_path: str,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n    ) -> None:\n        if not os.path.exists(image_file_path):\n            self.add_html(name, \"Image Unavailable\")\n            _logger.warning(f\"Unable to locate image file {image_file_path} to render {name}.\")\n            return\n\n        with open(image_file_path, \"rb\") as f:\n            base64_str = base64.b64encode(f.read()).decode(\"utf-8\")\n\n        image_type = pathlib.Path(image_file_path).suffix[1:]\n\n        width_style = f'width=\"{width}\"' if width else \"\"\n        height_style = f'height=\"{width}\"' if height else \"\"\n        img_html = (\n            f'<img src=\"data:image/{image_type};base64, {base64_str}\" '\n            f\"{width_style} {height_style} />\"\n        )\n        self.add_html(name, img_html)\n\n    def add_pandas_profile(self, name: str, profile: str) -> CardTab:\n        \"\"\"\n        Add a new tab representing the provided pandas profile to the card.\n\n        :param name: name of the variable in the Jinja2 template\n        :param profile: html string to render profile in the step card\n        :return: the updated card instance\n        \"\"\"\n        try:\n            profile_iframe = (\n                \"<iframe srcdoc='{src}' width='100%' height='500' frameborder='0'></iframe>\"\n            ).format(src=html.escape(profile))\n        except Exception as e:\n            profile_iframe = f\"Unable to create data profile. Error found:\\n{e}\"\n        self.add_html(name, profile_iframe)\n        return self\n\n    def to_html(self) -> str:\n        \"\"\"\n        Returns a rendered HTML representing the content of the tab.\n\n        :return: a HTML string\n        \"\"\"\n        from jinja2 import BaseLoader\n        from jinja2.sandbox import SandboxedEnvironment\n\n        j2_env = SandboxedEnvironment(loader=BaseLoader()).from_string(self.template)\n        return j2_env.render({**self._context})\n\n\nclass BaseCard:\n    def __init__(self, recipe_name: str, step_name: str) -> None:\n        \"\"\"\n        BaseCard Constructor\n\n        :param recipe_name: a string representing name of the recipe.\n        :param step_name: a string representing the name of the step.\n        \"\"\"\n        self._recipe_name = recipe_name\n        self._step_name = step_name\n        self._template_name = \"base.html\"\n\n        self._string_builder = StringIO()\n        self._tabs = []\n\n    def add_tab(self, name, html_template) -> CardTab:\n        \"\"\"\n        Add a new tab with arbitrary content.\n\n        :param name: a string representing the name of the tab.\n        :param html_template: a string representing the HTML template for the card content.\n        \"\"\"\n        tab = CardTab(name, html_template)\n        self._tabs.append((name, tab))\n        return tab\n\n    def get_tab(self, name) -> Union[CardTab, None]:\n        \"\"\"\n        Returns an existing tab with the specified name. Returns None if not found.\n\n        :param name: a string representing the name of the tab.\n        \"\"\"\n        for key, tab in self._tabs:\n            if key == name:\n                return tab\n        return None\n\n    def add_text(self, text: str) -> BaseCard:\n        \"\"\"\n        Add text to the textual representation of this card.\n\n        :param text: a string text\n        :return: the updated card instance\n        \"\"\"\n        self._string_builder.write(text)\n        return self\n\n    def to_html(self) -> str:\n        \"\"\"\n        This funtion renders the Jinja2 template based on the provided context so far.\n\n        :return: a HTML string\n        \"\"\"\n        import jinja2\n\n        def get_random_id(length=6):\n            return \"\".join(\n                random.choice(string.ascii_lowercase + string.digits) for _ in range(length)\n            )\n\n        base_template_path = os.path.join(os.path.dirname(__file__), \"templates\")\n        j2_env = jinja2.Environment(loader=jinja2.FileSystemLoader(base_template_path))\n        tab_list = [(name, tab.to_html()) for name, tab in self._tabs]\n        page_id = get_random_id()\n        return j2_env.get_template(self._template_name).render(\n            {\n                \"HEADER_TITLE\": f\"{self._step_name.capitalize()}@{self._recipe_name}\",\n                \"TABLINK\": f\"tablink-{page_id}\",\n                \"CONTENT\": f\"content-{page_id}\",\n                \"BUTTON_CONTAINER\": f\"button-container-{page_id}\",\n                \"tab_list\": tab_list,\n            }\n        )\n\n    def to_text(self) -> str:\n        \"\"\"\n        :return: the textual representation of the card.\n        \"\"\"\n        return self._string_builder.getvalue()\n\n    def save_as_html(self, path) -> None:\n        if os.path.isdir(path):\n            path = os.path.join(path, CARD_HTML_NAME)\n        with open(path, \"w\", encoding=\"utf-8\") as f:\n            f.write(self.to_html())\n\n    def save(self, path: str) -> None:\n        if os.path.isdir(path):\n            path = os.path.join(path, CARD_PICKLE_NAME)\n        with open(path, \"wb\") as out:\n            pickle.dump(self, out)\n\n    @staticmethod\n    def load(path):\n        if os.path.isdir(path):\n            path = os.path.join(path, CARD_PICKLE_NAME)\n        with open(path, \"rb\") as f:\n            return pickle.load(f)\n\n    @staticmethod\n    def render_table(table, columns=None, hide_index=True):\n        \"\"\"\n        Renders a table-like object as an HTML table.\n\n        :param table: Table-like object (e.g. pandas DataFrame, 2D numpy array, list of tuples).\n        :param columns: Column names to use. If `table` doesn't have column names, this argument\n            provides names for the columns. Otherwise, only the specified columns will be included\n            in the output HTML table.\n        :param hide_index: Hide index column when rendering.\n        \"\"\"\n        import pandas as pd\n        from pandas.io.formats.style import Styler\n\n        if not isinstance(table, Styler):\n            table = pd.DataFrame(table, columns=columns).style\n\n        pandas_version = Version(pd.__version__)\n\n        styler = table.set_table_attributes('style=\"border-collapse:collapse\"').set_table_styles(\n            [\n                {\n                    \"selector\": \"table, th, td\",\n                    \"props\": [\n                        (\"border\", \"1px solid grey\"),\n                        (\"text-align\", \"left\"),\n                        (\"padding\", \"5px\"),\n                    ],\n                },\n            ]\n        )\n        if hide_index:\n            rendered_table = (\n                styler.hide(axis=\"index\").to_html()\n                if pandas_version >= Version(\"1.4.0\")\n                else styler.hide_index().render()\n            )\n        else:\n            rendered_table = (\n                styler.to_html() if pandas_version >= Version(\"1.4.0\") else styler.render()\n            )\n        return f'<div style=\"max-height: 500px; overflow: scroll;\">{rendered_table}</div>'\n\n\nclass FailureCard(BaseCard):\n    \"\"\"\n    Step card providing information about a failed step execution, including a stacktrace.\n\n    TODO: Migrate the failure card to a tab-based card, removing this class and its associated\n          HTML template in the process.\n    \"\"\"\n\n    def __init__(\n        self, recipe_name: str, step_name: str, failure_traceback: str, output_directory: str\n    ):\n        super().__init__(\n            recipe_name=recipe_name,\n            step_name=step_name,\n        )\n        self.add_tab(\"Step Status\", \"{{ STEP_STATUS }}\").add_html(\n            \"STEP_STATUS\",\n            '<p><strong>Step status: <span style=\"color:red\">Failed</span></strong></p>',\n        )\n        self.add_tab(\n            \"Stacktrace\", \"<div class='stacktrace-container'>{{ STACKTRACE }}</div>\"\n        ).add_html(\"STACKTRACE\", f'<p style=\"margin-top:0px\"><code>{failure_traceback}</code></p>')\n        warning_output_path = os.path.join(output_directory, \"warning_logs.txt\")\n        if os.path.exists(warning_output_path):\n            with open(warning_output_path) as f:\n                self.add_tab(\"Warning Logs\", \"{{ STEP_WARNINGS }}\").add_html(\n                    \"STEP_WARNINGS\", f\"<pre>{f.read()}</pre>\"\n                )\n"], "filenames": ["mlflow/recipes/cards/__init__.py"], "buggy_code_start_loc": [123], "buggy_code_end_loc": [126], "fixing_code_start_loc": [123], "fixing_code_end_loc": [127], "type": "CWE-1336", "message": "Improper Neutralization of Special Elements Used in a Template Engine in GitHub repository mlflow/mlflow prior to 2.9.2.", "other": {"cve": {"id": "CVE-2023-6709", "sourceIdentifier": "security@huntr.dev", "published": "2023-12-12T04:15:07.083", "lastModified": "2023-12-13T21:12:45.867", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Neutralization of Special Elements Used in a Template Engine in GitHub repository mlflow/mlflow prior to 2.9.2."}, {"lang": "es", "value": "Neutralizaci\u00f3n inadecuada de elementos especiales utilizados en un motor de plantillas en el repositorio de GitHub mlflow/mlflow anterior a 2.9.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 6.0}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1336"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lfprojects:mlflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.9.2", "matchCriteriaId": "6B5585E2-CC70-4BED-AA89-B791F081ACFC"}]}]}], "references": [{"url": "https://github.com/mlflow/mlflow/commit/432b8ccf27fd3a76df4ba79bb1bec62118a85625", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.com/bounties/9e4cc07b-6fff-421b-89bd-9445ef61d34d", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Mitigation", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mlflow/mlflow/commit/432b8ccf27fd3a76df4ba79bb1bec62118a85625"}}