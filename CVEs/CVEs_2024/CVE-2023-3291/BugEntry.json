{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / MP3 reframer filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/avparse.h>\n#include <gpac/constants.h>\n#include <gpac/filters.h>\n\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_RFMP3)\n\ntypedef struct\n{\n\tu64 pos;\n\tDouble duration;\n} MP3Idx;\n\ntypedef struct\n{\n\t//filter args\n\tDouble index;\n\tBool expart, forcemp3;\n\n\t//only one input pid declared\n\tGF_FilterPid *ipid;\n\t//only one output pid declared\n\tGF_FilterPid *opid;\n\n\tGF_BitStream *bs;\n\tu64 file_pos, cts, prev_cts;\n\tu32 sr, nb_ch, codecid;\n\tGF_Fraction64 duration;\n\tDouble start_range;\n\tBool in_seek;\n\tu32 timescale;\n\tBool is_playing;\n\tBool is_file;\n\tBool initial_play_done, file_loaded;\n\n\tu32 hdr;\n\n\tu8 *mp3_buffer;\n\tu32 mp3_buffer_size, mp3_buffer_alloc, resume_from;\n\tu64 byte_offset;\n\n\tGF_FilterPacket *src_pck;\n\n\tBool recompute_cts;\n\tMP3Idx *indexes;\n\tu32 index_alloc_size, index_size;\n\n\tu32 tag_size;\n\tu8 *id3_buffer;\n\tu32 id3_buffer_size, id3_buffer_alloc;\n\n\tGF_FilterPid *vpid;\n\tBool copy_props;\n\n\tBool is_sync;\n} GF_MP3DmxCtx;\n\n\n\n\nGF_Err mp3_dmx_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tconst GF_PropertyValue *p;\n\tGF_MP3DmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tctx->ipid = NULL;\n\t\tif (ctx->opid) {\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tctx->ipid = pid;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\tif (p) ctx->timescale = p->value.uint;\n\n\tp = gf_filter_pid_get_property_str(pid, \"nocts\");\n\tif (p && p->value.boolean) ctx->recompute_cts = GF_TRUE;\n\telse ctx->recompute_cts = GF_FALSE;\n\n\tif (ctx->timescale && !ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\t\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_STREAM_TYPE);\n\t\tif (!p || (p->value.uint==GF_STREAM_FILE)) {\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_AUDIO));\n\t\t}\n\t}\n\tif (ctx->timescale) ctx->copy_props = GF_TRUE;\n\treturn GF_OK;\n}\n\nstatic void mp3_dmx_check_dur(GF_Filter *filter, GF_MP3DmxCtx *ctx)\n{\n\tFILE *stream;\n\tu64 duration, cur_dur;\n\ts32 prev_sr = -1;\n\tconst GF_PropertyValue *p;\n\tif (!ctx->opid || ctx->timescale || ctx->file_loaded) return;\n\n\tif (ctx->index<=0) {\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILEPATH);\n\tif (!p || !p->value.string || !strncmp(p->value.string, \"gmem://\", 7)) {\n\t\tctx->is_file = GF_FALSE;\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\tctx->is_file = GF_TRUE;\n\n\tstream = gf_fopen_ex(p->value.string, NULL, \"rb\", GF_TRUE);\n\tif (!stream) {\n\t\tif (gf_fileio_is_main_thread(p->value.string))\n\t\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tctx->index_size = 0;\n\n\tduration = 0;\n\tcur_dur = 0;\n\twhile (1) {\n\t\tu32 sr, dur;\n\t\tu64 pos;\n\t\tu32 hdr = gf_mp3_get_next_header(stream);\n\t\tif (!hdr) break;\n\t\tsr = gf_mp3_sampling_rate(hdr);\n\n\t\tif ((prev_sr>=0) && (prev_sr != sr)) {\n\t\t\tduration *= sr;\n\t\t\tduration /= prev_sr;\n\n\t\t\tcur_dur *= sr;\n\t\t\tcur_dur /= prev_sr;\n\t\t}\n\t\tprev_sr = sr;\n\t\tdur = gf_mp3_window_size(hdr);\n\t\tduration += dur;\n\t\tcur_dur += dur;\n\t\tpos = gf_ftell(stream);\n\t\tif (cur_dur > ctx->index * prev_sr) {\n\t\t\tif (!ctx->index_alloc_size) ctx->index_alloc_size = 10;\n\t\t\telse if (ctx->index_alloc_size == ctx->index_size) ctx->index_alloc_size *= 2;\n\t\t\tctx->indexes = gf_realloc(ctx->indexes, sizeof(MP3Idx)*ctx->index_alloc_size);\n\t\t\tctx->indexes[ctx->index_size].pos = pos - 4;\n\t\t\tctx->indexes[ctx->index_size].duration = (Double) duration;\n\t\t\tctx->indexes[ctx->index_size].duration /= prev_sr;\n\t\t\tctx->index_size ++;\n\t\t\tcur_dur = 0;\n\t\t}\n\n\t\tpos = gf_ftell(stream);\n\t\tgf_fseek(stream, pos + gf_mp3_frame_size(hdr) - 4, SEEK_SET);\n\t}\n\tgf_fclose(stream);\n\n\tif (!ctx->duration.num || (ctx->duration.num  * prev_sr != duration * ctx->duration.den)) {\n\t\tctx->duration.num = (s32) duration;\n\t\tctx->duration.den = prev_sr ;\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);\n\tif (p && p->value.boolean) ctx->file_loaded = GF_TRUE;\n}\n\n\n#include <gpac/utf.h>\nstatic void id3dmx_set_string(GF_FilterPid *apid, char *name, u8 *buf, Bool is_dyn)\n{\n\tif ((buf[0]==0xFF) || (buf[0]==0xFE)) {\n\t\tconst u16 *sptr = (u16 *) (buf+2);\n\t\tu32 len = UTF8_MAX_BYTES_PER_CHAR * gf_utf8_wcslen(sptr);\n\t\tchar *tmp = gf_malloc(len+1);\n\t\tlen = gf_utf8_wcstombs(tmp, len, &sptr);\n\t\tif (len != GF_UTF8_FAIL) {\n\t\t\ttmp[len] = 0;\n\t\t\tif (is_dyn) {\n\t\t\t\tgf_filter_pid_set_property_dyn(apid, name, &PROP_STRING(tmp) );\n\t\t\t} else {\n\t\t\t\tgf_filter_pid_set_property_str(apid, name, &PROP_STRING(tmp) );\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MP3Dmx] Corrupted ID3 text frame %s\\n\", name));\n\t\t}\n\t\tgf_free(tmp);\n\t} else {\n\t\tif (is_dyn) {\n\t\t\tgf_filter_pid_set_property_dyn(apid, name, &PROP_STRING(buf) );\n\t\t} else {\n\t\t\tgf_filter_pid_set_property_str(apid, name, &PROP_STRING(buf) );\n\t\t}\n\t}\n}\n\nvoid id3dmx_flush(GF_Filter *filter, u8 *id3_buf, u32 id3_buf_size, GF_FilterPid *audio_pid, GF_FilterPid **video_pid_p)\n{\n\tGF_BitStream *bs = gf_bs_new(id3_buf, id3_buf_size, GF_BITSTREAM_READ);\n\tchar *sep_desc;\n\tchar *_buf=NULL;\n\tu32 buf_alloc=0;\n\tgf_bs_skip_bytes(bs, 3);\n\t/*u8 major = */gf_bs_read_u8(bs);\n\t/*u8 minor = */gf_bs_read_u8(bs);\n\t/*u8 unsync = */gf_bs_read_int(bs, 1);\n\tu8 ext_hdr = gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 6);\n\tu32 size = gf_id3_read_size(bs);\n\n\n\tif (ext_hdr) {\n\n\t}\n\n\twhile (size && (gf_bs_available(bs)>=10) ) {\n\t\tchar *buf;\n\t\tchar szTag[1024];\n\t\tchar *sep;\n\t\ts32 tag_idx;\n\t\tu32 pic_size;\n\t\t//u32 pic_type;\n\t\tu32 ftag = gf_bs_read_u32(bs);\n\t\tu32 fsize = gf_id3_read_size(bs);\n\t\t/*u16 fflags = */gf_bs_read_u16(bs);\n\n\t\tsize -= 10;\n\t\tif (!fsize)\n\t\t\tbreak;\n\n\t\tif (size<fsize) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MP3Dmx] Broken ID3 frame tag %s, size %d but remaining bytes %d\\n\", gf_4cc_to_str(ftag), fsize, size));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (buf_alloc<=fsize) {\n\t\t\t_buf = gf_realloc(_buf, fsize+3);\n\t\t\tbuf_alloc = fsize+3;\n\t\t}\n\t\t//read into _buf+1 so that buf+1 is always %2 mem aligned as it can be loaded as unsigned short\n\t\tgf_bs_read_data(bs, _buf+1, fsize);\n\t\t_buf[fsize+1]=0;\n\t\t_buf[fsize+2]=0;\n\t\tbuf = _buf+1;\n\n\t\ttag_idx = gf_itags_find_by_id3tag(ftag);\n\n\t\tif (ftag==GF_ID3V2_FRAME_TXXX) {\n\t\t\tsep = memchr(buf, 0, fsize);\n\t\t\tif (sep) {\n\t\t\t\tif (!stricmp(buf+1, \"comment\")) {\n\t\t\t\t\tid3dmx_set_string(audio_pid, \"comment\", sep+1, GF_FALSE);\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(szTag, \"tag_\");\n\t\t\t\t\tstrncat(szTag, buf+1, 1019);\n\t\t\t\t\tid3dmx_set_string(audio_pid, szTag, sep+1, GF_TRUE);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ftag == GF_ID3V2_FRAME_APIC) {\n\t\t\t//first char is text encoding\n\t\t\t//then mime\n\t\t\tsep = memchr(buf+1, 0, fsize-1);\n\t\t\t/*pic_type = sep[1];*/\n\t\t\tsep_desc = memchr(sep+2, 0, fsize-1);\n\n\t\t\tif (sep_desc) {\n\t\t\t\tGF_Err e;\n\t\t\t\tpic_size = (u32) ( (sep_desc + 1) - buf);\n\t\t\t\tpic_size = fsize - pic_size;\n\n\t\t\t\tif (video_pid_p) {\n\t\t\t\t\te = gf_filter_pid_raw_new(filter, NULL, NULL, buf+1, NULL, sep_desc+1, pic_size, GF_FALSE, video_pid_p);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MP3Dmx] error setting up video pid for cover art: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t\t}\n\t\t\t\t\tif (*video_pid_p) {\n\t\t\t\t\t\tu8 *out_buffer;\n\t\t\t\t\t\tGF_FilterPacket *dst_pck;\n\t\t\t\t\t\tgf_filter_pid_set_name(*video_pid_p, \"CoverArt\");\n\t\t\t\t\t\tgf_filter_pid_set_property(*video_pid_p, GF_PROP_PID_COVER_ART, &PROP_BOOL(GF_TRUE));\n\t\t\t\t\t\tdst_pck = gf_filter_pck_new_alloc(*video_pid_p, pic_size, &out_buffer);\n\t\t\t\t\t\tif (dst_pck) {\n\t\t\t\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\t\t\t\t\t\t\tmemcpy(out_buffer, sep_desc+1, pic_size);\n\t\t\t\t\t\t\tgf_filter_pck_send(dst_pck);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgf_filter_pid_set_eos(*video_pid_p);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgf_filter_pid_set_property(audio_pid, GF_PROP_PID_COVER_ART, &PROP_DATA(sep_desc+1, pic_size) );\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (tag_idx>=0) {\n\t\t\tconst char *tag_name = gf_itags_get_name((u32) tag_idx);\n\t\t\tid3dmx_set_string(audio_pid, (char *) tag_name, buf+1, GF_FALSE);\n\t\t} else {\n\t\t\tsprintf(szTag, \"tag_%s\", gf_4cc_to_str(ftag));\n\t\t\tif ((ftag>>24) == 'T') {\n\t\t\t\tid3dmx_set_string(audio_pid, szTag, buf+1, GF_TRUE);\n\t\t\t} else {\n\t\t\t\tgf_filter_pid_set_property_dyn(audio_pid, szTag, &PROP_DATA(buf, fsize) );\n\t\t\t}\n\t\t}\n\t\tsize -= fsize;\n\t}\n\tgf_bs_del(bs);\n\tif (_buf) gf_free(_buf);\n}\nstatic void mp3_dmx_flush_id3(GF_Filter *filter, GF_MP3DmxCtx *ctx)\n{\n\tid3dmx_flush(filter, ctx->id3_buffer, ctx->id3_buffer_size, ctx->opid, ctx->expart ? &ctx->vpid : NULL);\n\tctx->id3_buffer_size = 0;\n}\n\nstatic void mp3_dmx_check_pid(GF_Filter *filter, GF_MP3DmxCtx *ctx)\n{\n\tu32 sr, codec_id;\n\n\tif (!ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tmp3_dmx_check_dur(filter, ctx);\n\t}\n\n\tcodec_id = gf_mp3_object_type_indication(ctx->hdr);\n\tswitch (gf_mp3_layer(ctx->hdr)) {\n\tcase 3:\n\t\tif (ctx->forcemp3) {\n\t\t\tcodec_id = GF_CODECID_MPEG_AUDIO;\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\tcodec_id = GF_CODECID_MPEG_AUDIO_L1;\n\t\tbreak;\n\t}\n\n\tif ((ctx->sr == gf_mp3_sampling_rate(ctx->hdr)) && (ctx->nb_ch == gf_mp3_num_channels(ctx->hdr) )\n\t\t&& (ctx->codecid == codec_id )\n\t\t&& !ctx->copy_props\n\t)\n\t\treturn;\n\n\tctx->copy_props = GF_FALSE;\n\t//copy properties at init or reconfig\n\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\tconst GF_PropertyValue *p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_STREAM_TYPE);\n\tif (!p || (p->value.uint==GF_STREAM_FILE)) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_AUDIO));\n\t}\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL );\n\tif (ctx->is_file && ctx->index) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, & PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD) );\n\t}\n\tif (ctx->duration.num)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\tif (!ctx->timescale)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CAN_DATAREF, & PROP_BOOL(GF_TRUE ) );\n\n\tif (!ctx->timescale) gf_filter_pid_set_name(ctx->opid, \"audio\");\n\n\tctx->nb_ch = gf_mp3_num_channels(ctx->hdr);\n\n\tsr = gf_mp3_sampling_rate(ctx->hdr);\n\n\tif (!ctx->timescale) {\n\t\t//we change sample rate, change cts\n\t\tif (ctx->cts && ctx->sr && (ctx->sr != sr)) {\n\t\t\tctx->cts = gf_timestamp_rescale(ctx->cts, ctx->sr, sr);\n\t\t}\n\t}\n\tctx->sr = sr;\n\tctx->codecid = codec_id;\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, & PROP_UINT(ctx->timescale ? ctx->timescale : sr));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLE_RATE, & PROP_UINT(sr));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_NUM_CHANNELS, & PROP_UINT(ctx->nb_ch) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(ctx->codecid ) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLES_PER_FRAME, & PROP_UINT(gf_mp3_window_size(ctx->hdr) ) );\n\n\tif (!gf_sys_is_test_mode() ) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_BITRATE, & PROP_UINT(gf_mp3_bit_rate(ctx->hdr) ) );\n\t}\n\n\tif (ctx->id3_buffer_size)\n\t\tmp3_dmx_flush_id3(filter, ctx);\n\n}\n\nstatic Bool mp3_dmx_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 i;\n\tGF_FilterEvent fevt;\n\tGF_MP3DmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (evt->base.on_pid != ctx->opid) return GF_TRUE;\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->is_playing = GF_TRUE;\n\t\t}\n\t\tif (! ctx->is_file) {\n\t\t\tif (evt->play.start_range || ctx->initial_play_done) {\n\t\t\t\tctx->mp3_buffer_size = 0;\n\t\t\t\tctx->resume_from = 0;\n\t\t\t}\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tmp3_dmx_check_dur(filter, ctx);\n\n\t\tctx->start_range = evt->play.start_range;\n\t\tctx->in_seek = GF_TRUE;\n\t\tctx->file_pos = 0;\n\t\tif (ctx->start_range) {\n\t\t\tfor (i=1; i<ctx->index_size; i++) {\n\t\t\t\tif (ctx->indexes[i].duration>ctx->start_range) {\n\t\t\t\t\tctx->cts = (u64) (ctx->indexes[i-1].duration * ctx->sr);\n\t\t\t\t\tctx->file_pos = ctx->indexes[i-1].pos;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ctx->initial_play_done) {\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t//seek will not change the current source state, don't send a seek\n\t\t\tif (!ctx->file_pos)\n\t\t\t\treturn GF_TRUE;\n\t\t}\n\t\tctx->mp3_buffer_size = 0;\n\t\tctx->resume_from = 0;\n\t\t//post a seek\n\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\tfevt.seek.start_offset = ctx->file_pos;\n\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\n\tcase GF_FEVT_STOP:\n\t\tctx->is_playing = GF_FALSE;\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = NULL;\n\t\tctx->cts = 0;\n\t\t//don't cancel event\n\t\treturn GF_FALSE;\n\n\tcase GF_FEVT_SET_SPEED:\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tbreak;\n\t}\n\t//by default don't cancel event - to rework once we have downloading in place\n\treturn GF_FALSE;\n}\n\nstatic GFINLINE void mp3_dmx_update_cts(GF_MP3DmxCtx *ctx)\n{\n\tu32 nb_samp = gf_mp3_window_size(ctx->hdr);\n\tif (ctx->timescale) {\n\t\tu64 inc = nb_samp;\n\t\tinc *= ctx->timescale;\n\t\tinc /= ctx->sr;\n\t\tctx->cts += inc;\n\t} else {\n\t\tctx->cts += nb_samp;\n\t}\n}\n\nGF_Err mp3_dmx_process(GF_Filter *filter)\n{\n\tGF_MP3DmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tBool is_eos;\n\tu8 *data, *output;\n\tu8 *start;\n\tu32 pck_size, remain, prev_pck_size;\n\tu64 cts;\n\nrestart:\n\tcts = GF_FILTER_NO_TS;\n\tis_eos = GF_FALSE;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tmp3_dmx_check_dur(filter, ctx);\n\n\tif (ctx->opid && !ctx->is_playing)\n\t\treturn GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tif (!ctx->mp3_buffer_size) {\n\t\t\t\tif (ctx->opid)\n\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = NULL;\n\t\t\t\treturn GF_EOS;\n\t\t\t}\n\t\t\tis_eos = GF_TRUE;\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tprev_pck_size = ctx->mp3_buffer_size;\n\tif (pck && !ctx->resume_from) {\n\t\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\tu64 byte_offset = gf_filter_pck_get_byte_offset(pck);\n\t\t\tif (!ctx->mp3_buffer_size) {\n\t\t\t\tctx->byte_offset = byte_offset;\n\t\t\t} else if (ctx->byte_offset + ctx->mp3_buffer_size != byte_offset) {\n\t\t\t\tctx->byte_offset = GF_FILTER_NO_BO;\n\t\t\t\tif ((byte_offset != GF_FILTER_NO_BO) && (byte_offset>ctx->mp3_buffer_size) ) {\n\t\t\t\t\tctx->byte_offset = byte_offset - ctx->mp3_buffer_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->mp3_buffer_size + pck_size > ctx->mp3_buffer_alloc) {\n\t\t\tctx->mp3_buffer_alloc = ctx->mp3_buffer_size + pck_size;\n\t\t\tctx->mp3_buffer = gf_realloc(ctx->mp3_buffer, ctx->mp3_buffer_alloc);\n\t\t}\n\t\tmemcpy(ctx->mp3_buffer + ctx->mp3_buffer_size, data, pck_size);\n\t\tctx->mp3_buffer_size += pck_size;\n\t}\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (ctx->timescale && pck) {\n\t\tcts = gf_filter_pck_get_cts(pck);\n\t\t//init cts at first packet\n\t\tif (!ctx->cts && (cts != GF_FILTER_NO_TS))\n\t\t\tctx->cts = cts;\n\t}\n\n\tif (cts == GF_FILTER_NO_TS) {\n\t\t//avoids updating cts\n\t\tprev_pck_size = 0;\n\t}\n\n\tremain = ctx->mp3_buffer_size;\n\tstart = ctx->mp3_buffer;\n\n\tif (ctx->resume_from) {\n\t\tstart += ctx->resume_from - 1;\n\t\tremain -= ctx->resume_from - 1;\n\t\tctx->resume_from = 0;\n\t}\n\n\twhile (remain) {\n\t\tu8 *sync;\n\t\tBool skip_id3v1=GF_FALSE;\n\t\tu32 bytes_skipped=0, size, nb_samp, bytes_to_drop=0;;\n\n\t\tif (!ctx->tag_size && (remain>3)) {\n\n\t\t\t/* Did we read an ID3v2 ? */\n\t\t\tif (start[0] == 'I' && start[1] == 'D' && start[2] == '3') {\n\t\t\t\tif (remain<10)\n\t\t\t\t\treturn GF_OK;\n\n\t\t\t\tctx->tag_size = ((start[9] & 0x7f) + ((start[8] & 0x7f) << 7) + ((start[7] & 0x7f) << 14) + ((start[6] & 0x7f) << 21));\n\n\t\t\t\tbytes_to_drop = 10;\n\t\t\t\tif (ctx->id3_buffer_alloc < ctx->tag_size+10) {\n\t\t\t\t\tctx->id3_buffer = gf_realloc(ctx->id3_buffer, ctx->tag_size+10);\n\t\t\t\t\tctx->id3_buffer_alloc = ctx->tag_size+10;\n\t\t\t\t}\n\t\t\t\tmemcpy(ctx->id3_buffer, start, 10);\n\t\t\t\tctx->id3_buffer_size = 10;\n\t\t\t\tgoto drop_byte;\n\t\t\t}\n\t\t}\n\t\tif (ctx->tag_size) {\n\t\t\tif (ctx->tag_size>remain) {\n\t\t\t\tbytes_to_drop = remain;\n\t\t\t\tctx->tag_size-=remain;\n\t\t\t} else {\n\t\t\t\tbytes_to_drop = ctx->tag_size;\n\t\t\t\tctx->tag_size = 0;\n\t\t\t}\n\t\t\tmemcpy(ctx->id3_buffer + ctx->id3_buffer_size, start, bytes_to_drop);\n\t\t\tctx->id3_buffer_size += bytes_to_drop;\n\n\t\t\tif (!ctx->tag_size && ctx->opid) {\n\t\t\t\tmp3_dmx_flush_id3(filter, ctx);\n\t\t\t}\n\t\t\tgoto drop_byte;\n\n\t\t}\n\n\t\tctx->hdr = gf_mp3_get_next_header_mem(start, remain, &bytes_skipped);\n\n\t\t//couldn't find sync byte in this packet\n\t\tif (!ctx->hdr) {\n\t\t\tbreak;\n\t\t}\n\t\tsync = start + bytes_skipped;\n\n\t\tsize = gf_mp3_frame_size(ctx->hdr);\n\n\n\t\t//ready to send packet\n\t\tif (size + 1 < remain-bytes_skipped) {\n\t\t\t//make sure we are sync!\n\t\t\tif (sync[size] !=0xFF) {\n\t\t\t\tif ((sync[size]=='T') && (sync[size+1]=='A') && (sync[size+2]=='G')) {\n\t\t\t\t\tskip_id3v1=GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(ctx->is_sync ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MP3Dmx] invalid frame, resyncing\\n\"));\n\t\t\t\t\tctx->is_sync = GF_FALSE;\n\t\t\t\t\tgoto drop_byte;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//otherwise wait for next frame, unless if end of stream\n\t\telse if (pck) {\n\t\t\tbreak;\n\t\t}\n\t\t//ready to send packet\n\t\tmp3_dmx_check_pid(filter, ctx);\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = (u32) (sync - ctx->mp3_buffer + 1);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tctx->is_sync = GF_TRUE;\n\n\t\tnb_samp = gf_mp3_window_size(ctx->hdr);\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_samples_at_seek = (u64) (ctx->start_range * ctx->sr);\n\t\t\tif (ctx->cts + nb_samp >= nb_samples_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + nb_samp ) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tbytes_to_drop = bytes_skipped + size;\n\t\tif (ctx->timescale && !prev_pck_size && (cts != GF_FILTER_NO_TS) ) {\n\t\t\tctx->cts = cts;\n\t\t\tcts = GF_FILTER_NO_TS;\n\t\t}\n\n\t\tif (!ctx->in_seek) {\n\t\t\tif (bytes_skipped + size > remain) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[MP3Dmx] truncated frame of size %u (remains %d)\\n\", size, remain-bytes_skipped));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, size, &output);\n\t\t\tif (!dst_pck) break;\n\t\t\tmemcpy(output, sync, size);\n\n\t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\t\tif (ctx->timescale && (ctx->timescale!=ctx->sr))\n\t\t\t\tgf_filter_pck_set_duration(dst_pck, (u32) gf_timestamp_rescale(nb_samp, ctx->sr, ctx->timescale) );\n\t\t\telse\n\t\t\t\tgf_filter_pck_set_duration(dst_pck, nb_samp);\n\t\t\tgf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\n\t\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, ctx->byte_offset + bytes_skipped);\n\t\t\t}\n\n\t\t\tgf_filter_pck_send(dst_pck);\n\t\t}\n\t\tmp3_dmx_update_cts(ctx);\n\n\t\t//TODO, parse id3v1 ??\n\t\tif (skip_id3v1)\n\t\t\tbytes_to_drop+=128;\n\n\t\t//truncated last frame\n\t\tif (bytes_to_drop>remain) {\n\t\t\tif (!is_eos) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[MP3Dmx] truncated frame!\\n\"));\n\t\t\t}\n\t\t\tbytes_to_drop=remain;\n\t\t}\n\ndrop_byte:\n\t\tif (!bytes_to_drop) {\n\t\t\tbytes_to_drop = 1;\n\t\t}\n\t\tstart += bytes_to_drop;\n\t\tremain -= bytes_to_drop;\n\n\t\tif (prev_pck_size) {\n\t\t\tif (prev_pck_size > bytes_to_drop) prev_pck_size -= bytes_to_drop;\n\t\t\telse {\n\t\t\t\tprev_pck_size=0;\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = pck;\n\t\t\t\tif (pck)\n\t\t\t\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\t\t}\n\t\t}\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO)\n\t\t\tctx->byte_offset += bytes_to_drop;\n\t}\n\n\tif (!pck) {\n\t\tctx->mp3_buffer_size = 0;\n\t\t//avoid recursive call\n\t\tgoto restart;\n\t} else {\n\t\tif (remain) {\n\t\t\tmemmove(ctx->mp3_buffer, start, remain);\n\t\t}\n\t\tctx->mp3_buffer_size = remain;\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err mp3_dmx_initialize(GF_Filter *filter)\n{\n\tGF_MP3DmxCtx *ctx = gf_filter_get_udta(filter);\n\t//in test mode we keep strict signaling, eg MPEG-2 layer 3 is still mpeg2 audio\n\tif (gf_sys_is_test_mode()) ctx->forcemp3 = GF_FALSE;\n\treturn GF_OK;\n}\n\nstatic void mp3_dmx_finalize(GF_Filter *filter)\n{\n\tGF_MP3DmxCtx *ctx = gf_filter_get_udta(filter);\n\tif (ctx->bs) gf_bs_del(ctx->bs);\n\tif (ctx->indexes) gf_free(ctx->indexes);\n\tif (ctx->mp3_buffer) gf_free(ctx->mp3_buffer);\n\tif (ctx->id3_buffer) gf_free(ctx->id3_buffer);\n\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n}\n\n\nstatic const char *mp3_dmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)\n{\n\tu32 nb_frames=0;\n\tu32 pos=0;\n\tu32 prev_pos=0;\n\ts32 prev_sr_idx=-1;\n\ts32 prev_ch=-1;\n\ts32 prev_layer=-1;\n\ts32 init_pos = -1;\n\tBool has_id3 = GF_FALSE;\n\n\t/* Check for ID3 */\n\tif (size>= 10) {\n\t\tif (data[0] == 'I' && data[1] == 'D' && data[2] == '3') {\n\t\t\tu32 tag_size = ((data[9] & 0x7f) + ((data[8] & 0x7f) << 7) + ((data[7] & 0x7f) << 14) + ((data[6] & 0x7f) << 21));\n\n\t\t\tif (tag_size+10>size) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"ID3 tag detected size %d but probe data only %d bytes, will rely on file extension (try increasing probe size using --block_size)\\n\", tag_size+10, size));\n\t\t\t\t*score = GF_FPROBE_EXT_MATCH;\n\t\t\t\treturn \"mp3|mp2|mp1\";\n\t\t\t}\n\t\t\tdata += tag_size+10;\n\t\t\tsize -= tag_size+10;\n\t\t\thas_id3 = GF_TRUE;\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tu32 hdr = gf_mp3_get_next_header_mem(data, size, &pos);\n\t\tif (!hdr) break;\n\n\t\tif (init_pos<0) init_pos = pos;\n\n\t\tif (gf_mp3_version(hdr) > 3)\n\t\t\tbreak;\n\t\t//check sample rate\n\t\tu8 val = (hdr >> 10) & 0x3;\n\t\tif (val>2)\n\t\t\tbreak;\n\t\tu32 fsize = gf_mp3_frame_size(hdr);\n\t\tif (prev_pos && pos) {\n\t\t\tnb_frames=0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (prev_sr_idx>=0) {\n\t\t\tif ((u8) prev_sr_idx != val) {\n\t\t\t\tnb_frames=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprev_sr_idx = val;\n\n\t\tval = gf_mp3_num_channels(hdr);\n\t\tif (prev_ch>=0) {\n\t\t\tif ((u8) prev_ch != val) {\n\t\t\t\tnb_frames=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprev_ch = val;\n\n\t\tval = gf_mp3_layer(hdr);\n\t\tif (prev_layer>=0) {\n\t\t\tif ((u8) prev_layer != val) {\n\t\t\t\tnb_frames=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprev_layer = val;\n\n\t\tif (fsize + pos > size) {\n\t\t\tnb_frames++;\n\t\t\tbreak;\n\t\t}\n\n\t\tprev_pos = pos;\n\t\tnb_frames++;\n\t\tif (nb_frames>4) break;\n\t\tif (size < fsize + pos) break;\n\t\tsize -= fsize + pos;\n\t\tdata += fsize + pos;\n\t}\n\n\tif (nb_frames>=2) {\n\t\t*score = (init_pos==0) ? GF_FPROBE_SUPPORTED : GF_FPROBE_MAYBE_NOT_SUPPORTED;\n\t\treturn \"audio/mp3\";\n\t}\n\tif (nb_frames && has_id3) {\n\t\t*score = GF_FPROBE_MAYBE_SUPPORTED;\n\t\treturn \"audio/mp3\";\n\t}\n\treturn NULL;\n}\n\nstatic const GF_FilterCapability MP3DmxCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"mp3|mp2|mp1\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"audio/mp3|audio/x-mp3\"),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_MPEG_AUDIO),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_PART3),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_MPEG_AUDIO_L1),\n\tCAP_BOOL(GF_CAPS_OUTPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_BOOL(GF_CAPS_INPUT,GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG_AUDIO),\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_PART3),\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG_AUDIO_L1),\n\tCAP_BOOL(GF_CAPS_OUTPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n\t//also declare generic file output for embedded files (cover art & co), but explicit to skip this cap in chain resolution\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_UINT(GF_CAPS_OUTPUT | GF_CAPFLAG_LOADED_FILTER ,GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE)\n};\n\n\n\n#define OFFS(_n)\t#_n, offsetof(GF_MP3DmxCtx, _n)\nstatic const GF_FilterArgs MP3DmxArgs[] =\n{\n\t{ OFFS(index), \"indexing window length\", GF_PROP_DOUBLE, \"1.0\", NULL, 0},\n\t{ OFFS(expart), \"expose pictures as a dedicated video PID\", GF_PROP_BOOL, \"false\", NULL, 0},\n\t{ OFFS(forcemp3), \"force mp3 signaling for MPEG-2 Audio layer 3\", GF_PROP_BOOL, \"true\", NULL, GF_ARG_HINT_EXPERT},\n\t{0}\n};\n\n\nGF_FilterRegister MP3DmxRegister = {\n\t.name = \"rfmp3\",\n\tGF_FS_SET_DESCRIPTION(\"MP3 reframer\")\n\tGF_FS_SET_HELP(\"This filter parses MPEG-1/2 audio files/data and outputs corresponding audio PID and frames.\")\n\t.private_size = sizeof(GF_MP3DmxCtx),\n\t.args = MP3DmxArgs,\n\t.initialize = mp3_dmx_initialize,\n\t.finalize = mp3_dmx_finalize,\n\tSETCAPS(MP3DmxCaps),\n\t.configure_pid = mp3_dmx_configure_pid,\n\t.process = mp3_dmx_process,\n\t.probe_data = mp3_dmx_probe_data,\n\t.process_event = mp3_dmx_process_event\n};\n\n\nconst GF_FilterRegister *rfmp3_register(GF_FilterSession *session)\n{\n\treturn &MP3DmxRegister;\n}\n#else\nconst GF_FilterRegister *rfmp3_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif // #if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_RFMP3)\n\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / MP3 reframer filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/avparse.h>\n#include <gpac/constants.h>\n#include <gpac/filters.h>\n\n#if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_RFMP3)\n\ntypedef struct\n{\n\tu64 pos;\n\tDouble duration;\n} MP3Idx;\n\ntypedef struct\n{\n\t//filter args\n\tDouble index;\n\tBool expart, forcemp3;\n\n\t//only one input pid declared\n\tGF_FilterPid *ipid;\n\t//only one output pid declared\n\tGF_FilterPid *opid;\n\n\tGF_BitStream *bs;\n\tu64 file_pos, cts, prev_cts;\n\tu32 sr, nb_ch, codecid;\n\tGF_Fraction64 duration;\n\tDouble start_range;\n\tBool in_seek;\n\tu32 timescale;\n\tBool is_playing;\n\tBool is_file;\n\tBool initial_play_done, file_loaded;\n\n\tu32 hdr;\n\n\tu8 *mp3_buffer;\n\tu32 mp3_buffer_size, mp3_buffer_alloc, resume_from;\n\tu64 byte_offset;\n\n\tGF_FilterPacket *src_pck;\n\n\tBool recompute_cts;\n\tMP3Idx *indexes;\n\tu32 index_alloc_size, index_size;\n\n\tu32 tag_size;\n\tu8 *id3_buffer;\n\tu32 id3_buffer_size, id3_buffer_alloc;\n\n\tGF_FilterPid *vpid;\n\tBool copy_props;\n\n\tBool is_sync;\n} GF_MP3DmxCtx;\n\n\n\n\nGF_Err mp3_dmx_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tconst GF_PropertyValue *p;\n\tGF_MP3DmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tctx->ipid = NULL;\n\t\tif (ctx->opid) {\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tctx->ipid = pid;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\tif (p) ctx->timescale = p->value.uint;\n\n\tp = gf_filter_pid_get_property_str(pid, \"nocts\");\n\tif (p && p->value.boolean) ctx->recompute_cts = GF_TRUE;\n\telse ctx->recompute_cts = GF_FALSE;\n\n\tif (ctx->timescale && !ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\t\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_STREAM_TYPE);\n\t\tif (!p || (p->value.uint==GF_STREAM_FILE)) {\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_AUDIO));\n\t\t}\n\t}\n\tif (ctx->timescale) ctx->copy_props = GF_TRUE;\n\treturn GF_OK;\n}\n\nstatic void mp3_dmx_check_dur(GF_Filter *filter, GF_MP3DmxCtx *ctx)\n{\n\tFILE *stream;\n\tu64 duration, cur_dur;\n\ts32 prev_sr = -1;\n\tconst GF_PropertyValue *p;\n\tif (!ctx->opid || ctx->timescale || ctx->file_loaded) return;\n\n\tif (ctx->index<=0) {\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILEPATH);\n\tif (!p || !p->value.string || !strncmp(p->value.string, \"gmem://\", 7)) {\n\t\tctx->is_file = GF_FALSE;\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\tctx->is_file = GF_TRUE;\n\n\tstream = gf_fopen_ex(p->value.string, NULL, \"rb\", GF_TRUE);\n\tif (!stream) {\n\t\tif (gf_fileio_is_main_thread(p->value.string))\n\t\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\n\tctx->index_size = 0;\n\n\tduration = 0;\n\tcur_dur = 0;\n\twhile (1) {\n\t\tu32 sr, dur;\n\t\tu64 pos;\n\t\tu32 hdr = gf_mp3_get_next_header(stream);\n\t\tif (!hdr) break;\n\t\tsr = gf_mp3_sampling_rate(hdr);\n\n\t\tif ((prev_sr>=0) && (prev_sr != sr)) {\n\t\t\tduration *= sr;\n\t\t\tduration /= prev_sr;\n\n\t\t\tcur_dur *= sr;\n\t\t\tcur_dur /= prev_sr;\n\t\t}\n\t\tprev_sr = sr;\n\t\tdur = gf_mp3_window_size(hdr);\n\t\tduration += dur;\n\t\tcur_dur += dur;\n\t\tpos = gf_ftell(stream);\n\t\tif (cur_dur > ctx->index * prev_sr) {\n\t\t\tif (!ctx->index_alloc_size) ctx->index_alloc_size = 10;\n\t\t\telse if (ctx->index_alloc_size == ctx->index_size) ctx->index_alloc_size *= 2;\n\t\t\tctx->indexes = gf_realloc(ctx->indexes, sizeof(MP3Idx)*ctx->index_alloc_size);\n\t\t\tctx->indexes[ctx->index_size].pos = pos - 4;\n\t\t\tctx->indexes[ctx->index_size].duration = (Double) duration;\n\t\t\tctx->indexes[ctx->index_size].duration /= prev_sr;\n\t\t\tctx->index_size ++;\n\t\t\tcur_dur = 0;\n\t\t}\n\n\t\tpos = gf_ftell(stream);\n\t\tgf_fseek(stream, pos + gf_mp3_frame_size(hdr) - 4, SEEK_SET);\n\t}\n\tgf_fclose(stream);\n\n\tif (!ctx->duration.num || (ctx->duration.num  * prev_sr != duration * ctx->duration.den)) {\n\t\tctx->duration.num = (s32) duration;\n\t\tctx->duration.den = prev_sr ;\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);\n\tif (p && p->value.boolean) ctx->file_loaded = GF_TRUE;\n}\n\n\n#include <gpac/utf.h>\nstatic void id3dmx_set_string(GF_FilterPid *apid, char *name, u8 *buf, Bool is_dyn)\n{\n\tif ((buf[0]==0xFF) || (buf[0]==0xFE)) {\n\t\tconst u16 *sptr = (u16 *) (buf+2);\n\t\tu32 len = UTF8_MAX_BYTES_PER_CHAR * gf_utf8_wcslen(sptr);\n\t\tchar *tmp = gf_malloc(len+1);\n\t\tlen = gf_utf8_wcstombs(tmp, len, &sptr);\n\t\tif (len != GF_UTF8_FAIL) {\n\t\t\ttmp[len] = 0;\n\t\t\tif (is_dyn) {\n\t\t\t\tgf_filter_pid_set_property_dyn(apid, name, &PROP_STRING(tmp) );\n\t\t\t} else {\n\t\t\t\tgf_filter_pid_set_property_str(apid, name, &PROP_STRING(tmp) );\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MP3Dmx] Corrupted ID3 text frame %s\\n\", name));\n\t\t}\n\t\tgf_free(tmp);\n\t} else {\n\t\tif (is_dyn) {\n\t\t\tgf_filter_pid_set_property_dyn(apid, name, &PROP_STRING(buf) );\n\t\t} else {\n\t\t\tgf_filter_pid_set_property_str(apid, name, &PROP_STRING(buf) );\n\t\t}\n\t}\n}\n\nvoid id3dmx_flush(GF_Filter *filter, u8 *id3_buf, u32 id3_buf_size, GF_FilterPid *audio_pid, GF_FilterPid **video_pid_p)\n{\n\tGF_BitStream *bs = gf_bs_new(id3_buf, id3_buf_size, GF_BITSTREAM_READ);\n\tchar *sep_desc;\n\tchar *_buf=NULL;\n\tu32 buf_alloc=0;\n\tgf_bs_skip_bytes(bs, 3);\n\t/*u8 major = */gf_bs_read_u8(bs);\n\t/*u8 minor = */gf_bs_read_u8(bs);\n\t/*u8 unsync = */gf_bs_read_int(bs, 1);\n\tu8 ext_hdr = gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 6);\n\tu32 size = gf_id3_read_size(bs);\n\n\n\tif (ext_hdr) {\n\n\t}\n\n\twhile (size && (gf_bs_available(bs)>=10) ) {\n\t\tchar *buf;\n\t\tchar szTag[1024];\n\t\tchar *sep;\n\t\ts32 tag_idx;\n\t\tu32 pic_size;\n\t\t//u32 pic_type;\n\t\tu32 ftag = gf_bs_read_u32(bs);\n\t\tu32 fsize = gf_id3_read_size(bs);\n\t\t/*u16 fflags = */gf_bs_read_u16(bs);\n\n\t\tsize -= 10;\n\t\tif (!fsize)\n\t\t\tbreak;\n\n\t\tif (size<fsize) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MP3Dmx] Broken ID3 frame tag %s, size %d but remaining bytes %d\\n\", gf_4cc_to_str(ftag), fsize, size));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (buf_alloc <= fsize+2) {\n\t\t\t_buf = gf_realloc(_buf, fsize+3);\n\t\t\tbuf_alloc = fsize+3;\n\t\t}\n\t\t//read into _buf+1 so that buf+1 is always %2 mem aligned as it can be loaded as unsigned short\n\t\tgf_bs_read_data(bs, _buf+1, fsize);\n\t\t_buf[fsize+1]=0;\n\t\t_buf[fsize+2]=0;\n\t\tbuf = _buf+1;\n\n\t\ttag_idx = gf_itags_find_by_id3tag(ftag);\n\n\t\tif (ftag==GF_ID3V2_FRAME_TXXX) {\n\t\t\tsep = memchr(buf, 0, fsize);\n\t\t\tif (sep) {\n\t\t\t\tif (!stricmp(buf+1, \"comment\")) {\n\t\t\t\t\tid3dmx_set_string(audio_pid, \"comment\", sep+1, GF_FALSE);\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(szTag, \"tag_\");\n\t\t\t\t\tstrncat(szTag, buf+1, 1019);\n\t\t\t\t\tid3dmx_set_string(audio_pid, szTag, sep+1, GF_TRUE);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ftag == GF_ID3V2_FRAME_APIC) {\n\t\t\t//first char is text encoding\n\t\t\t//then mime\n\t\t\tsep = memchr(buf+1, 0, fsize-1);\n\t\t\t/*pic_type = sep[1];*/\n\t\t\tsep_desc = memchr(sep+2, 0, fsize-1);\n\n\t\t\tif (sep_desc) {\n\t\t\t\tGF_Err e;\n\t\t\t\tpic_size = (u32) ( (sep_desc + 1) - buf);\n\t\t\t\tpic_size = fsize - pic_size;\n\n\t\t\t\tif (video_pid_p) {\n\t\t\t\t\te = gf_filter_pid_raw_new(filter, NULL, NULL, buf+1, NULL, sep_desc+1, pic_size, GF_FALSE, video_pid_p);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MP3Dmx] error setting up video pid for cover art: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t\t}\n\t\t\t\t\tif (*video_pid_p) {\n\t\t\t\t\t\tu8 *out_buffer;\n\t\t\t\t\t\tGF_FilterPacket *dst_pck;\n\t\t\t\t\t\tgf_filter_pid_set_name(*video_pid_p, \"CoverArt\");\n\t\t\t\t\t\tgf_filter_pid_set_property(*video_pid_p, GF_PROP_PID_COVER_ART, &PROP_BOOL(GF_TRUE));\n\t\t\t\t\t\tdst_pck = gf_filter_pck_new_alloc(*video_pid_p, pic_size, &out_buffer);\n\t\t\t\t\t\tif (dst_pck) {\n\t\t\t\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\t\t\t\t\t\t\tmemcpy(out_buffer, sep_desc+1, pic_size);\n\t\t\t\t\t\t\tgf_filter_pck_send(dst_pck);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgf_filter_pid_set_eos(*video_pid_p);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgf_filter_pid_set_property(audio_pid, GF_PROP_PID_COVER_ART, &PROP_DATA(sep_desc+1, pic_size) );\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (tag_idx>=0) {\n\t\t\tconst char *tag_name = gf_itags_get_name((u32) tag_idx);\n\t\t\tid3dmx_set_string(audio_pid, (char *) tag_name, buf+1, GF_FALSE);\n\t\t} else {\n\t\t\tsprintf(szTag, \"tag_%s\", gf_4cc_to_str(ftag));\n\t\t\tif ((ftag>>24) == 'T') {\n\t\t\t\tid3dmx_set_string(audio_pid, szTag, buf+1, GF_TRUE);\n\t\t\t} else {\n\t\t\t\tgf_filter_pid_set_property_dyn(audio_pid, szTag, &PROP_DATA(buf, fsize) );\n\t\t\t}\n\t\t}\n\t\tsize -= fsize;\n\t}\n\tgf_bs_del(bs);\n\tif (_buf) gf_free(_buf);\n}\nstatic void mp3_dmx_flush_id3(GF_Filter *filter, GF_MP3DmxCtx *ctx)\n{\n\tid3dmx_flush(filter, ctx->id3_buffer, ctx->id3_buffer_size, ctx->opid, ctx->expart ? &ctx->vpid : NULL);\n\tctx->id3_buffer_size = 0;\n}\n\nstatic void mp3_dmx_check_pid(GF_Filter *filter, GF_MP3DmxCtx *ctx)\n{\n\tu32 sr, codec_id;\n\n\tif (!ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tmp3_dmx_check_dur(filter, ctx);\n\t}\n\n\tcodec_id = gf_mp3_object_type_indication(ctx->hdr);\n\tswitch (gf_mp3_layer(ctx->hdr)) {\n\tcase 3:\n\t\tif (ctx->forcemp3) {\n\t\t\tcodec_id = GF_CODECID_MPEG_AUDIO;\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\tcodec_id = GF_CODECID_MPEG_AUDIO_L1;\n\t\tbreak;\n\t}\n\n\tif ((ctx->sr == gf_mp3_sampling_rate(ctx->hdr)) && (ctx->nb_ch == gf_mp3_num_channels(ctx->hdr) )\n\t\t&& (ctx->codecid == codec_id )\n\t\t&& !ctx->copy_props\n\t)\n\t\treturn;\n\n\tctx->copy_props = GF_FALSE;\n\t//copy properties at init or reconfig\n\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\tconst GF_PropertyValue *p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_STREAM_TYPE);\n\tif (!p || (p->value.uint==GF_STREAM_FILE)) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_AUDIO));\n\t}\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL );\n\tif (ctx->is_file && ctx->index) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, & PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD) );\n\t}\n\tif (ctx->duration.num)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\tif (!ctx->timescale)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CAN_DATAREF, & PROP_BOOL(GF_TRUE ) );\n\n\tif (!ctx->timescale) gf_filter_pid_set_name(ctx->opid, \"audio\");\n\n\tctx->nb_ch = gf_mp3_num_channels(ctx->hdr);\n\n\tsr = gf_mp3_sampling_rate(ctx->hdr);\n\n\tif (!ctx->timescale) {\n\t\t//we change sample rate, change cts\n\t\tif (ctx->cts && ctx->sr && (ctx->sr != sr)) {\n\t\t\tctx->cts = gf_timestamp_rescale(ctx->cts, ctx->sr, sr);\n\t\t}\n\t}\n\tctx->sr = sr;\n\tctx->codecid = codec_id;\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, & PROP_UINT(ctx->timescale ? ctx->timescale : sr));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLE_RATE, & PROP_UINT(sr));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_NUM_CHANNELS, & PROP_UINT(ctx->nb_ch) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(ctx->codecid ) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLES_PER_FRAME, & PROP_UINT(gf_mp3_window_size(ctx->hdr) ) );\n\n\tif (!gf_sys_is_test_mode() ) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_BITRATE, & PROP_UINT(gf_mp3_bit_rate(ctx->hdr) ) );\n\t}\n\n\tif (ctx->id3_buffer_size)\n\t\tmp3_dmx_flush_id3(filter, ctx);\n\n}\n\nstatic Bool mp3_dmx_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 i;\n\tGF_FilterEvent fevt;\n\tGF_MP3DmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (evt->base.on_pid != ctx->opid) return GF_TRUE;\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->is_playing = GF_TRUE;\n\t\t}\n\t\tif (! ctx->is_file) {\n\t\t\tif (evt->play.start_range || ctx->initial_play_done) {\n\t\t\t\tctx->mp3_buffer_size = 0;\n\t\t\t\tctx->resume_from = 0;\n\t\t\t}\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tmp3_dmx_check_dur(filter, ctx);\n\n\t\tctx->start_range = evt->play.start_range;\n\t\tctx->in_seek = GF_TRUE;\n\t\tctx->file_pos = 0;\n\t\tif (ctx->start_range) {\n\t\t\tfor (i=1; i<ctx->index_size; i++) {\n\t\t\t\tif (ctx->indexes[i].duration>ctx->start_range) {\n\t\t\t\t\tctx->cts = (u64) (ctx->indexes[i-1].duration * ctx->sr);\n\t\t\t\t\tctx->file_pos = ctx->indexes[i-1].pos;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ctx->initial_play_done) {\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t//seek will not change the current source state, don't send a seek\n\t\t\tif (!ctx->file_pos)\n\t\t\t\treturn GF_TRUE;\n\t\t}\n\t\tctx->mp3_buffer_size = 0;\n\t\tctx->resume_from = 0;\n\t\t//post a seek\n\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\tfevt.seek.start_offset = ctx->file_pos;\n\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\n\tcase GF_FEVT_STOP:\n\t\tctx->is_playing = GF_FALSE;\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = NULL;\n\t\tctx->cts = 0;\n\t\t//don't cancel event\n\t\treturn GF_FALSE;\n\n\tcase GF_FEVT_SET_SPEED:\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tbreak;\n\t}\n\t//by default don't cancel event - to rework once we have downloading in place\n\treturn GF_FALSE;\n}\n\nstatic GFINLINE void mp3_dmx_update_cts(GF_MP3DmxCtx *ctx)\n{\n\tu32 nb_samp = gf_mp3_window_size(ctx->hdr);\n\tif (ctx->timescale) {\n\t\tu64 inc = nb_samp;\n\t\tinc *= ctx->timescale;\n\t\tinc /= ctx->sr;\n\t\tctx->cts += inc;\n\t} else {\n\t\tctx->cts += nb_samp;\n\t}\n}\n\nGF_Err mp3_dmx_process(GF_Filter *filter)\n{\n\tGF_MP3DmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tBool is_eos;\n\tu8 *data, *output;\n\tu8 *start;\n\tu32 pck_size, remain, prev_pck_size;\n\tu64 cts;\n\nrestart:\n\tcts = GF_FILTER_NO_TS;\n\tis_eos = GF_FALSE;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tmp3_dmx_check_dur(filter, ctx);\n\n\tif (ctx->opid && !ctx->is_playing)\n\t\treturn GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tif (!ctx->mp3_buffer_size) {\n\t\t\t\tif (ctx->opid)\n\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = NULL;\n\t\t\t\treturn GF_EOS;\n\t\t\t}\n\t\t\tis_eos = GF_TRUE;\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tprev_pck_size = ctx->mp3_buffer_size;\n\tif (pck && !ctx->resume_from) {\n\t\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\tu64 byte_offset = gf_filter_pck_get_byte_offset(pck);\n\t\t\tif (!ctx->mp3_buffer_size) {\n\t\t\t\tctx->byte_offset = byte_offset;\n\t\t\t} else if (ctx->byte_offset + ctx->mp3_buffer_size != byte_offset) {\n\t\t\t\tctx->byte_offset = GF_FILTER_NO_BO;\n\t\t\t\tif ((byte_offset != GF_FILTER_NO_BO) && (byte_offset>ctx->mp3_buffer_size) ) {\n\t\t\t\t\tctx->byte_offset = byte_offset - ctx->mp3_buffer_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->mp3_buffer_size + pck_size > ctx->mp3_buffer_alloc) {\n\t\t\tctx->mp3_buffer_alloc = ctx->mp3_buffer_size + pck_size;\n\t\t\tctx->mp3_buffer = gf_realloc(ctx->mp3_buffer, ctx->mp3_buffer_alloc);\n\t\t}\n\t\tmemcpy(ctx->mp3_buffer + ctx->mp3_buffer_size, data, pck_size);\n\t\tctx->mp3_buffer_size += pck_size;\n\t}\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (ctx->timescale && pck) {\n\t\tcts = gf_filter_pck_get_cts(pck);\n\t\t//init cts at first packet\n\t\tif (!ctx->cts && (cts != GF_FILTER_NO_TS))\n\t\t\tctx->cts = cts;\n\t}\n\n\tif (cts == GF_FILTER_NO_TS) {\n\t\t//avoids updating cts\n\t\tprev_pck_size = 0;\n\t}\n\n\tremain = ctx->mp3_buffer_size;\n\tstart = ctx->mp3_buffer;\n\n\tif (ctx->resume_from) {\n\t\tstart += ctx->resume_from - 1;\n\t\tremain -= ctx->resume_from - 1;\n\t\tctx->resume_from = 0;\n\t}\n\n\twhile (remain) {\n\t\tu8 *sync;\n\t\tBool skip_id3v1=GF_FALSE;\n\t\tu32 bytes_skipped=0, size, nb_samp, bytes_to_drop=0;;\n\n\t\tif (!ctx->tag_size && (remain>3)) {\n\n\t\t\t/* Did we read an ID3v2 ? */\n\t\t\tif (start[0] == 'I' && start[1] == 'D' && start[2] == '3') {\n\t\t\t\tif (remain<10)\n\t\t\t\t\treturn GF_OK;\n\n\t\t\t\tctx->tag_size = ((start[9] & 0x7f) + ((start[8] & 0x7f) << 7) + ((start[7] & 0x7f) << 14) + ((start[6] & 0x7f) << 21));\n\n\t\t\t\tbytes_to_drop = 10;\n\t\t\t\tif (ctx->id3_buffer_alloc < ctx->tag_size+10) {\n\t\t\t\t\tctx->id3_buffer = gf_realloc(ctx->id3_buffer, ctx->tag_size+10);\n\t\t\t\t\tctx->id3_buffer_alloc = ctx->tag_size+10;\n\t\t\t\t}\n\t\t\t\tmemcpy(ctx->id3_buffer, start, 10);\n\t\t\t\tctx->id3_buffer_size = 10;\n\t\t\t\tgoto drop_byte;\n\t\t\t}\n\t\t}\n\t\tif (ctx->tag_size) {\n\t\t\tif (ctx->tag_size>remain) {\n\t\t\t\tbytes_to_drop = remain;\n\t\t\t\tctx->tag_size-=remain;\n\t\t\t} else {\n\t\t\t\tbytes_to_drop = ctx->tag_size;\n\t\t\t\tctx->tag_size = 0;\n\t\t\t}\n\t\t\tmemcpy(ctx->id3_buffer + ctx->id3_buffer_size, start, bytes_to_drop);\n\t\t\tctx->id3_buffer_size += bytes_to_drop;\n\n\t\t\tif (!ctx->tag_size && ctx->opid) {\n\t\t\t\tmp3_dmx_flush_id3(filter, ctx);\n\t\t\t}\n\t\t\tgoto drop_byte;\n\n\t\t}\n\n\t\tctx->hdr = gf_mp3_get_next_header_mem(start, remain, &bytes_skipped);\n\n\t\t//couldn't find sync byte in this packet\n\t\tif (!ctx->hdr) {\n\t\t\tbreak;\n\t\t}\n\t\tsync = start + bytes_skipped;\n\n\t\tsize = gf_mp3_frame_size(ctx->hdr);\n\n\n\t\t//ready to send packet\n\t\tif (size + 1 < remain-bytes_skipped) {\n\t\t\t//make sure we are sync!\n\t\t\tif (sync[size] !=0xFF) {\n\t\t\t\tif ((sync[size]=='T') && (sync[size+1]=='A') && (sync[size+2]=='G')) {\n\t\t\t\t\tskip_id3v1=GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(ctx->is_sync ? GF_LOG_WARNING : GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MP3Dmx] invalid frame, resyncing\\n\"));\n\t\t\t\t\tctx->is_sync = GF_FALSE;\n\t\t\t\t\tgoto drop_byte;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//otherwise wait for next frame, unless if end of stream\n\t\telse if (pck) {\n\t\t\tbreak;\n\t\t}\n\t\t//ready to send packet\n\t\tmp3_dmx_check_pid(filter, ctx);\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = (u32) (sync - ctx->mp3_buffer + 1);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tctx->is_sync = GF_TRUE;\n\n\t\tnb_samp = gf_mp3_window_size(ctx->hdr);\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_samples_at_seek = (u64) (ctx->start_range * ctx->sr);\n\t\t\tif (ctx->cts + nb_samp >= nb_samples_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + nb_samp ) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tbytes_to_drop = bytes_skipped + size;\n\t\tif (ctx->timescale && !prev_pck_size && (cts != GF_FILTER_NO_TS) ) {\n\t\t\tctx->cts = cts;\n\t\t\tcts = GF_FILTER_NO_TS;\n\t\t}\n\n\t\tif (!ctx->in_seek) {\n\t\t\tif (bytes_skipped + size > remain) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[MP3Dmx] truncated frame of size %u (remains %d)\\n\", size, remain-bytes_skipped));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, size, &output);\n\t\t\tif (!dst_pck) break;\n\t\t\tmemcpy(output, sync, size);\n\n\t\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\t\tif (ctx->timescale && (ctx->timescale!=ctx->sr))\n\t\t\t\tgf_filter_pck_set_duration(dst_pck, (u32) gf_timestamp_rescale(nb_samp, ctx->sr, ctx->timescale) );\n\t\t\telse\n\t\t\t\tgf_filter_pck_set_duration(dst_pck, nb_samp);\n\t\t\tgf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\n\t\t\tif (ctx->byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, ctx->byte_offset + bytes_skipped);\n\t\t\t}\n\n\t\t\tgf_filter_pck_send(dst_pck);\n\t\t}\n\t\tmp3_dmx_update_cts(ctx);\n\n\t\t//TODO, parse id3v1 ??\n\t\tif (skip_id3v1)\n\t\t\tbytes_to_drop+=128;\n\n\t\t//truncated last frame\n\t\tif (bytes_to_drop>remain) {\n\t\t\tif (!is_eos) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[MP3Dmx] truncated frame!\\n\"));\n\t\t\t}\n\t\t\tbytes_to_drop=remain;\n\t\t}\n\ndrop_byte:\n\t\tif (!bytes_to_drop) {\n\t\t\tbytes_to_drop = 1;\n\t\t}\n\t\tstart += bytes_to_drop;\n\t\tremain -= bytes_to_drop;\n\n\t\tif (prev_pck_size) {\n\t\t\tif (prev_pck_size > bytes_to_drop) prev_pck_size -= bytes_to_drop;\n\t\t\telse {\n\t\t\t\tprev_pck_size=0;\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\t\tctx->src_pck = pck;\n\t\t\t\tif (pck)\n\t\t\t\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\t\t}\n\t\t}\n\t\tif (ctx->byte_offset != GF_FILTER_NO_BO)\n\t\t\tctx->byte_offset += bytes_to_drop;\n\t}\n\n\tif (!pck) {\n\t\tctx->mp3_buffer_size = 0;\n\t\t//avoid recursive call\n\t\tgoto restart;\n\t} else {\n\t\tif (remain) {\n\t\t\tmemmove(ctx->mp3_buffer, start, remain);\n\t\t}\n\t\tctx->mp3_buffer_size = remain;\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err mp3_dmx_initialize(GF_Filter *filter)\n{\n\tGF_MP3DmxCtx *ctx = gf_filter_get_udta(filter);\n\t//in test mode we keep strict signaling, eg MPEG-2 layer 3 is still mpeg2 audio\n\tif (gf_sys_is_test_mode()) ctx->forcemp3 = GF_FALSE;\n\treturn GF_OK;\n}\n\nstatic void mp3_dmx_finalize(GF_Filter *filter)\n{\n\tGF_MP3DmxCtx *ctx = gf_filter_get_udta(filter);\n\tif (ctx->bs) gf_bs_del(ctx->bs);\n\tif (ctx->indexes) gf_free(ctx->indexes);\n\tif (ctx->mp3_buffer) gf_free(ctx->mp3_buffer);\n\tif (ctx->id3_buffer) gf_free(ctx->id3_buffer);\n\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n}\n\n\nstatic const char *mp3_dmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)\n{\n\tu32 nb_frames=0;\n\tu32 pos=0;\n\tu32 prev_pos=0;\n\ts32 prev_sr_idx=-1;\n\ts32 prev_ch=-1;\n\ts32 prev_layer=-1;\n\ts32 init_pos = -1;\n\tBool has_id3 = GF_FALSE;\n\n\t/* Check for ID3 */\n\tif (size>= 10) {\n\t\tif (data[0] == 'I' && data[1] == 'D' && data[2] == '3') {\n\t\t\tu32 tag_size = ((data[9] & 0x7f) + ((data[8] & 0x7f) << 7) + ((data[7] & 0x7f) << 14) + ((data[6] & 0x7f) << 21));\n\n\t\t\tif (tag_size+10>size) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"ID3 tag detected size %d but probe data only %d bytes, will rely on file extension (try increasing probe size using --block_size)\\n\", tag_size+10, size));\n\t\t\t\t*score = GF_FPROBE_EXT_MATCH;\n\t\t\t\treturn \"mp3|mp2|mp1\";\n\t\t\t}\n\t\t\tdata += tag_size+10;\n\t\t\tsize -= tag_size+10;\n\t\t\thas_id3 = GF_TRUE;\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tu32 hdr = gf_mp3_get_next_header_mem(data, size, &pos);\n\t\tif (!hdr) break;\n\n\t\tif (init_pos<0) init_pos = pos;\n\n\t\tif (gf_mp3_version(hdr) > 3)\n\t\t\tbreak;\n\t\t//check sample rate\n\t\tu8 val = (hdr >> 10) & 0x3;\n\t\tif (val>2)\n\t\t\tbreak;\n\t\tu32 fsize = gf_mp3_frame_size(hdr);\n\t\tif (prev_pos && pos) {\n\t\t\tnb_frames=0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (prev_sr_idx>=0) {\n\t\t\tif ((u8) prev_sr_idx != val) {\n\t\t\t\tnb_frames=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprev_sr_idx = val;\n\n\t\tval = gf_mp3_num_channels(hdr);\n\t\tif (prev_ch>=0) {\n\t\t\tif ((u8) prev_ch != val) {\n\t\t\t\tnb_frames=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprev_ch = val;\n\n\t\tval = gf_mp3_layer(hdr);\n\t\tif (prev_layer>=0) {\n\t\t\tif ((u8) prev_layer != val) {\n\t\t\t\tnb_frames=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprev_layer = val;\n\n\t\tif (fsize + pos > size) {\n\t\t\tnb_frames++;\n\t\t\tbreak;\n\t\t}\n\n\t\tprev_pos = pos;\n\t\tnb_frames++;\n\t\tif (nb_frames>4) break;\n\t\tif (size < fsize + pos) break;\n\t\tsize -= fsize + pos;\n\t\tdata += fsize + pos;\n\t}\n\n\tif (nb_frames>=2) {\n\t\t*score = (init_pos==0) ? GF_FPROBE_SUPPORTED : GF_FPROBE_MAYBE_NOT_SUPPORTED;\n\t\treturn \"audio/mp3\";\n\t}\n\tif (nb_frames && has_id3) {\n\t\t*score = GF_FPROBE_MAYBE_SUPPORTED;\n\t\treturn \"audio/mp3\";\n\t}\n\treturn NULL;\n}\n\nstatic const GF_FilterCapability MP3DmxCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"mp3|mp2|mp1\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"audio/mp3|audio/x-mp3\"),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_MPEG_AUDIO),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_MPEG2_PART3),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_MPEG_AUDIO_L1),\n\tCAP_BOOL(GF_CAPS_OUTPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_BOOL(GF_CAPS_INPUT,GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG_AUDIO),\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG2_PART3),\n\tCAP_UINT(GF_CAPS_INPUT_OUTPUT,GF_PROP_PID_CODECID, GF_CODECID_MPEG_AUDIO_L1),\n\tCAP_BOOL(GF_CAPS_OUTPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n\t//also declare generic file output for embedded files (cover art & co), but explicit to skip this cap in chain resolution\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_UINT(GF_CAPS_OUTPUT | GF_CAPFLAG_LOADED_FILTER ,GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE)\n};\n\n\n\n#define OFFS(_n)\t#_n, offsetof(GF_MP3DmxCtx, _n)\nstatic const GF_FilterArgs MP3DmxArgs[] =\n{\n\t{ OFFS(index), \"indexing window length\", GF_PROP_DOUBLE, \"1.0\", NULL, 0},\n\t{ OFFS(expart), \"expose pictures as a dedicated video PID\", GF_PROP_BOOL, \"false\", NULL, 0},\n\t{ OFFS(forcemp3), \"force mp3 signaling for MPEG-2 Audio layer 3\", GF_PROP_BOOL, \"true\", NULL, GF_ARG_HINT_EXPERT},\n\t{0}\n};\n\n\nGF_FilterRegister MP3DmxRegister = {\n\t.name = \"rfmp3\",\n\tGF_FS_SET_DESCRIPTION(\"MP3 reframer\")\n\tGF_FS_SET_HELP(\"This filter parses MPEG-1/2 audio files/data and outputs corresponding audio PID and frames.\")\n\t.private_size = sizeof(GF_MP3DmxCtx),\n\t.args = MP3DmxArgs,\n\t.initialize = mp3_dmx_initialize,\n\t.finalize = mp3_dmx_finalize,\n\tSETCAPS(MP3DmxCaps),\n\t.configure_pid = mp3_dmx_configure_pid,\n\t.process = mp3_dmx_process,\n\t.probe_data = mp3_dmx_probe_data,\n\t.process_event = mp3_dmx_process_event\n};\n\n\nconst GF_FilterRegister *rfmp3_register(GF_FilterSession *session)\n{\n\treturn &MP3DmxRegister;\n}\n#else\nconst GF_FilterRegister *rfmp3_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif // #if !defined(GPAC_DISABLE_AV_PARSERS) && !defined(GPAC_DISABLE_RFMP3)\n\n"], "filenames": ["src/filters/reframe_mp3.c"], "buggy_code_start_loc": [268], "buggy_code_end_loc": [269], "fixing_code_start_loc": [268], "fixing_code_end_loc": [269], "type": "CWE-122", "message": "Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to 2.2.2.", "other": {"cve": {"id": "CVE-2023-3291", "sourceIdentifier": "security@huntr.dev", "published": "2023-06-16T02:15:08.473", "lastModified": "2023-07-15T04:15:12.797", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to 2.2.2."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer de pila en el repositorio gpac/gpac de GitHub en versiones anteriores a 2.2.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 2.5}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.2.2", "matchCriteriaId": "DBF31B7B-F4C7-40C0-9245-09FECA1A8164"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/6a748ccc3f76ff10e3ae43014967ea4b0c088aaf", "source": "security@huntr.dev", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://huntr.dev/bounties/526954e6-8683-4697-bfa2-886c3204a1d5", "source": "security@huntr.dev", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5452", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/6a748ccc3f76ff10e3ae43014967ea4b0c088aaf"}}