{"buggy_code": [".. index:: type\n\n.. _types:\n\nTypes\n#####\n\nVyper is a statically typed language. The type of each variable (state and local) must be specified or at least known at compile-time. Vyper provides several elementary types which can be combined to form complex types.\n\nIn addition, types can interact with each other in expressions containing operators.\n\n.. index:: ! value\n\nValue Types\n===========\n\nThe following types are also called value types because variables of these\ntypes will always be passed by value, i.e. they are always copied when they\nare used as function arguments or in assignments.\n\n.. index:: ! bool, ! true, ! false\n\nBoolean\n-------\n\n**Keyword:** ``bool``\n\nA boolean is a type to store a logical/truth value.\n\nValues\n******\n\nThe only possible values are the constants ``True`` and ``False``.\n\nOperators\n*********\n\n====================  ===================\nOperator              Description\n====================  ===================\n``not x``             Logical negation\n``x and y``           Logical conjunction\n``x or y``            Logical disjunction\n``x == y``            Equality\n``x != y``            Inequality\n====================  ===================\n\nShort-circuiting of boolean operators (``or`` and ``and``) is consistent with\nthe behavior of Python.\n\n.. index:: ! intN, ! int, ! signed integer\n\nSigned Integer (N bit)\n------------------------\n\n**Keyword:** ``intN`` (e.g., ``int128``)\n\nA signed integer which can store positive and negative integers. ``N`` must be a multiple of 8 between 8 and 256 (inclusive).\n\nValues\n******\n\nSigned integer values between -2\\ :sup:`N-1` and (2\\ :sup:`N-1` - 1), inclusive.\n\nInteger literals cannot have a decimal point even if the decimal value is zero. For example, ``2.0`` cannot be interpreted as an integer.\n\nOperators\n*********\n\nComparisons\n^^^^^^^^^^^\n\nComparisons return a boolean value.\n\n==========  ================\nOperator    Description\n==========  ================\n``x < y``   Less than\n``x <= y``  Less than or equal to\n``x == y``  Equals\n``x != y``  Does not equal\n``x >= y``  Greater than or equal to\n``x > y``   Greater than\n==========  ================\n\n``x`` and ``y`` must both be of the same type.\n\nArithmetic Operators\n^^^^^^^^^^^^^^^^^^^^\n\n=============  ======================\nOperator       Description\n=============  ======================\n``x + y``      Addition\n``x - y``      Subtraction\n``-x``         Unary minus/Negation\n``x * y``      Multiplication\n``x / y``      Division\n``x**y``       Exponentiation\n``x % y``      Modulo\n=============  ======================\n\n``x`` and ``y`` must both be of the same type.\n\nBitwise Operators\n^^^^^^^^^^^^^^^^^\n\n=============  ======================\nOperator       Description\n=============  ======================\n``x & y``      Bitwise and\n``x | y``      Bitwise or\n``x ^ y``      Bitwise xor\n=============  ======================\n\n``x`` and ``y`` must be of the same type.\n\nShifts\n^^^^^^^^^^^^^^^^^\n\n=============  ======================\nOperator       Description\n=============  ======================\n``x << y``     Left shift\n``x >> y``     Right shift\n=============  ======================\n\nShifting is only available for 256-bit wide types. That is, ``x`` must be ``int256``, and ``y`` can be any unsigned integer. The right shift for ``int256`` compiles to a signed right shift (EVM ``SAR`` instruction).\n\n\n.. note::\n   While at runtime shifts are unchecked (that is, they can be for any number of bits), to prevent common mistakes, the compiler is stricter at compile-time and will prevent out of bounds shifts. For instance, at runtime, ``1 << 257`` will evaluate to ``0``, while that expression at compile-time will raise an ``OverflowException``.\n\n\n.. index:: ! uint, ! uintN, ! unsigned integer\n\nUnsigned Integer (N bit)\n--------------------------\n\n**Keyword:** ``uintN`` (e.g., ``uint8``)\n\nA unsigned integer which can store positive integers. ``N`` must be a multiple of 8 between 8 and 256 (inclusive).\n\nValues\n******\n\nInteger values between 0 and (2\\ :sup:`N`-1).\n\nInteger literals cannot have a decimal point even if the decimal value is zero. For example, ``2.0`` cannot be interpreted as an integer.\n\n.. note::\n    Integer literals are interpreted as ``int256`` by default. In cases where ``uint8`` is more appropriate, such as assignment, the literal might be interpreted as ``uint8``. Example: ``_variable: uint8 = _literal``. In order to explicitly cast a literal to a ``uint8`` use ``convert(_literal, uint8)``.\n\nOperators\n*********\n\nComparisons\n^^^^^^^^^^^\n\nComparisons return a boolean value.\n\n==========  ================\nOperator    Description\n==========  ================\n``x < y``   Less than\n``x <= y``  Less than or equal to\n``x == y``  Equals\n``x != y``  Does not equal\n``x >= y``  Greater than or equal to\n``x > y``   Greater than\n==========  ================\n\n``x`` and ``y`` must be of the same type.\n\nArithmetic Operators\n^^^^^^^^^^^^^^^^^^^^\n\n===========================  ======================\nOperator                     Description\n===========================  ======================\n``x + y``                    Addition\n``x - y``                    Subtraction\n``x * y``                    Multiplication\n``x / y``                    Division\n``x**y``                     Exponentiation\n``x % y``                    Modulo\n===========================  ======================\n\n``x`` and ``y`` must be of the same type.\n\nBitwise Operators\n^^^^^^^^^^^^^^^^^\n\n=============  ======================\nOperator       Description\n=============  ======================\n``x & y``      Bitwise and\n``x | y``      Bitwise or\n``x ^ y``      Bitwise xor\n``~x``         Bitwise not\n=============  ======================\n\n``x`` and ``y`` must be of the same type.\n\n.. note::\n    The Bitwise ``not`` operator is currently only available for ``uint256`` type.\n\nShifts\n^^^^^^^^^^^^^^^^^\n\n=============  ======================\nOperator       Description\n=============  ======================\n``x << y``     Left shift\n``x >> y``     Right shift\n=============  ======================\n\nShifting is only available for 256-bit wide types. That is, ``x`` must be ``uint256``, and ``y`` can be any unsigned integer. The right shift for ``uint256`` compiles to a signed right shift (EVM ``SHR`` instruction).\n\n\n.. note::\n   While at runtime shifts are unchecked (that is, they can be for any number of bits), to prevent common mistakes, the compiler is stricter at compile-time and will prevent out of bounds shifts. For instance, at runtime, ``1 << 257`` will evaluate to ``0``, while that expression at compile-time will raise an ``OverflowException``.\n\n\n\nDecimals\n--------\n\n**Keyword:** ``decimal``\n\nA decimal is a type to store a decimal fixed point value.\n\nValues\n******\n\nA value with a precision of 10 decimal places between -18707220957835557353007165858768422651595.9365500928 (-2\\ :sup:`167` / 10\\ :sup:`10`) and 18707220957835557353007165858768422651595.9365500927 ((2\\ :sup:`167` - 1) / 10\\ :sup:`10`).\n\nIn order for a literal to be interpreted as ``decimal`` it must include a decimal point.\n\nThe ABI type (for computing method identifiers) of ``decimal`` is ``fixed168x10``.\n\nOperators\n*********\n\nComparisons\n^^^^^^^^^^^\n\nComparisons return a boolean value.\n\n==========  ================\nOperator    Description\n==========  ================\n``x < y``   Less than\n``x <= y``  Less or equal\n``x == y``  Equals\n``x != y``  Does not equal\n``x >= y``  Greater or equal\n``x > y``   Greater than\n==========  ================\n\n``x`` and ``y`` must be of the type ``decimal``.\n\nArithmetic Operators\n^^^^^^^^^^^^^^^^^^^^\n\n=============  ==========================================\nOperator       Description\n=============  ==========================================\n``x + y``      Addition\n``x - y``      Subtraction\n``-x``         Unary minus/Negation\n``x * y``      Multiplication\n``x / y``      Division\n``x % y``      Modulo\n=============  ==========================================\n\n``x`` and ``y`` must be of the type ``decimal``.\n\n.. _address:\n\nAddress\n-------\n\n**Keyword:** ``address``\n\nThe address type holds an Ethereum address.\n\nValues\n******\n\nAn address type can hold an Ethereum address which equates to 20 bytes or 160 bits. Address literals must be written in hexadecimal notation with a leading ``0x`` and must be `checksummed <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md>`_.\n\n.. _members-of-addresses:\n\nMembers\n^^^^^^^\n\n=============== =========== ==========================================================================\nMember          Type        Description\n=============== =========== ==========================================================================\n``balance``     ``uint256`` Balance of an address\n``codehash``    ``bytes32`` Keccak of code at an address, ``EMPTY_BYTES32`` if no contract is deployed\n``codesize``    ``uint256`` Size of code deployed at an address, in bytes\n``is_contract`` ``bool``    Boolean indicating if a contract is deployed at an address\n``code``        ``Bytes``   Contract bytecode\n=============== =========== ==========================================================================\n\nSyntax as follows: ``_address.<member>``, where ``_address`` is of the type ``address`` and ``<member>`` is one of the above keywords.\n\n.. note::\n\n    Operations such as ``SELFDESTRUCT`` and ``CREATE2`` allow for the removal and replacement of bytecode at an address. You should never assume that values of address members will not change in the future.\n\n.. note::\n\n    ``_address.code`` requires the usage of :func:`slice <slice>` to explicitly extract a section of contract bytecode. If the extracted section exceeds the bounds of bytecode, this will throw. You can check the size of ``_address.code`` using ``_address.codesize``.\n\nM-byte-wide Fixed Size Byte Array\n----------------------\n\n**Keyword:** ``bytesM``\nThis is an M-byte-wide byte array that is otherwise similar to dynamically sized byte arrays. On an ABI level, it is annotated as bytesM (e.g., bytes32).\n\n**Example:**\n::\n\n    # Declaration\n    hash: bytes32\n    # Assignment\n    self.hash = _hash\n\n    some_method_id: bytes4 = 0x01abcdef\n\nOperators\n*********\n\n====================================  ============================================================\nKeyword                               Description\n====================================  ============================================================\n``keccak256(x)``                      Return the keccak256 hash as bytes32.\n``concat(x, ...)``                    Concatenate multiple inputs.\n``slice(x, start=_start, len=_len)``  Return a slice of ``_len`` starting at ``_start``.\n====================================  ============================================================\n\nWhere ``x`` is a byte array and ``_start`` as well as ``_len`` are integer values.\n\n.. index:: !bytes\n\nByte Arrays\n-----------\n\n**Keyword:** ``Bytes``\n\nA byte array with a max size.\n\nThe syntax being ``Bytes[maxLen]``, where ``maxLen`` is an integer which denotes the maximum number of bytes.\nOn the ABI level the Fixed-size bytes array is annotated as ``bytes``.\n\nBytes literals may be given as bytes strings.\n\n.. code-block:: python\n\n    bytes_string: Bytes[100] = b\"\\x01\"\n\n.. index:: !string\n\nStrings\n-------\n\n**Keyword:** ``String``\n\nFixed-size strings can hold strings with equal or fewer characters than the maximum length of the string.\nOn the ABI level the Fixed-size bytes array is annotated as ``string``.\n\n.. code-block:: python\n\n    example_str: String[100] = \"Test String\"\n\nEnums\n-----\n\n**Keyword:** ``enum``\n\nEnums are custom defined types. An enum must have at least one member, and can hold up to a maximum of 256 members.\nThe members are represented by ``uint256`` values in the form of 2\\ :sup:`n` where ``n`` is the index of the member in the range ``0 <= n <= 255``.\n\n.. code-block:: python\n\n    # Defining an enum with two members\n    enum Roles:\n        ADMIN\n        USER\n\n    # Declaring an enum variable\n    role: Roles = Roles.ADMIN\n\n    # Returning a member\n    return Roles.ADMIN\n\nOperators\n*********\n\nComparisons\n^^^^^^^^^^^\n\nComparisons return a boolean value.\n\n============== ================\nOperator       Description\n============== ================\n``x == y``     Equals\n``x != y``     Does not equal\n``x in y``     x is in y\n``x not in y`` x is not in y\n============== ================\n\nBitwise Operators\n^^^^^^^^^^^^^^^^^\n\n=============  ======================\nOperator       Description\n=============  ======================\n``x & y``      Bitwise and\n``x | y``      Bitwise or\n``x ^ y``      Bitwise xor\n``~x``         Bitwise not\n=============  ======================\n\nEnum members can be combined using the above bitwise operators. While enum members have values that are power of two, enum member combinations may not.\n\nThe ``in`` and ``not in`` operators can be used in conjunction with enum member combinations to check for membership.\n\n.. code-block:: python\n\n    enum Roles:\n        MANAGER\n        ADMIN\n        USER\n\n    # Check for membership\n    @external\n    def foo(a: Roles) -> bool:\n        return a in (Roles.MANAGER | Roles.USER)\n\n    # Check not in\n    @external\n    def bar(a: Roles) -> bool:\n        return a not in (Roles.MANAGER | Roles.USER)\n\nNote that ``in`` is not the same as strict equality (``==``). ``in`` checks that *any* of the flags on two enum objects are simultaneously set, while ``==`` checks that two enum objects are bit-for-bit equal.\n\nThe following code uses bitwise operations to add and revoke permissions from a given ``Roles`` object.\n\n.. code-block:: python\n    @external\n    def add_user(a: Roles) -> Roles:\n        ret: Roles = a\n        ret |= Roles.USER  # set the USER bit to 1\n        return ret\n\n    @external\n    def revoke_user(a: Roles) -> Roles:\n        ret: Roles = a\n        ret &= ~Roles.USER  # set the USER bit to 0\n        return ret\n\n    @external\n    def flip_user(a: Roles) -> Roles:\n        ret: Roles = a\n        ret ^= Roles.USER  # flip the user bit between 0 and 1\n        return ret\n\n.. index:: !reference\n\nReference Types\n===============\n\nReference types are those whose components can be assigned to in-place without copying. For instance, array and struct members can be individually assigned to without overwriting the whole data structure.\n\n.. note::\n\n  In terms of the calling convention, reference types are passed by value, not by reference. That means that, a calling function does not need to worry about a callee modifying the data of a passed structure.\n\n.. index:: !arrays\n\nFixed-size Lists\n----------------\n\nFixed-size lists hold a finite number of elements which belong to a specified type.\n\nLists can be declared with ``_name: _ValueType[_Integer]``, except ``Bytes[N]``, ``String[N]`` and enums.\n\n.. code-block:: python\n\n    # Defining a list\n    exampleList: int128[3]\n\n    # Setting values\n    exampleList = [10, 11, 12]\n    exampleList[2] = 42\n\n    # Returning a value\n    return exampleList[0]\n\nMultidimensional lists are also possible. The notation for the declaration is reversed compared to some other languages, but the access notation is not reversed.\n\nA two dimensional list can be declared with ``_name: _ValueType[inner_size][outer_size]``. Elements can be accessed with ``_name[outer_index][inner_index]``.\n\n.. code-block:: python\n\n    # Defining a list with 2 rows and 5 columns and set all values to 0\n    exampleList2D: int128[5][2] = empty(int128[5][2])\n\n    # Setting a value for row the first row (0) and last column (4)\n    exampleList2D[0][4] = 42\n\n    # Setting values\n    exampleList2D = [[10, 11, 12, 13, 14], [16, 17, 18, 19, 20]]\n\n    # Returning the value in row 0 column 4 (in this case 14)\n    return exampleList2D[0][4]\n\n.. index:: !dynarrays\n\nDynamic Arrays\n----------------\n\nDynamic arrays represent bounded arrays whose length can be modified at runtime, up to a bound specified in the type. They can be declared with ``_name: DynArray[_Type, _Integer]``, where ``_Type`` can be of value type or reference type (except mappings).\n\n.. code-block:: python\n\n    # Defining a list\n    exampleList: DynArray[int128, 3]\n\n    # Setting values\n    exampleList = []\n    # exampleList.pop()  # would revert!\n    exampleList.append(42)  # exampleList now has length 1\n    exampleList.append(120)  # exampleList now has length 2\n    exampleList.append(356)  # exampleList now has length 3\n    # exampleList.append(1)  # would revert!\n\n    myValue: int128 = exampleList.pop()  # myValue == 356, exampleList now has length 2\n\n    # myValue = exampleList[2]  # would revert!\n\n    # Returning a value\n    return exampleList[0]\n\n\n.. note::\n    Attempting to access data past the runtime length of an array, ``pop()`` an empty array or ``append()`` to a full array will result in a runtime ``REVERT``. Attempting to pass an array in calldata which is larger than the array bound will result in a runtime ``REVERT``.\n\n.. note::\n    To keep code easy to reason about, modifying an array while using it as an iterator is disallowed by the language. For instance, the following usage is not allowed:\n\n    .. code-block:: python\n\n        for item in self.my_array:\n            self.my_array[0] = item\n\nIn the ABI, they are represented as ``_Type[]``. For instance, ``DynArray[int128, 3]`` gets represented as ``int128[]``, and ``DynArray[DynArray[int128, 3], 3]`` gets represented as ``int128[][]``.\n\n.. _types-struct:\n\nStructs\n-------\n\nStructs are custom defined types that can group several variables.\n\nStruct types can be used inside mappings and arrays. Structs can contain arrays and other structs, but not mappings.\n\nStruct members can be accessed via ``struct.argname``.\n\n.. code-block:: python\n\n    # Defining a struct\n    struct MyStruct:\n        value1: int128\n        value2: decimal\n\n    # Declaring a struct variable\n    exampleStruct: MyStruct = MyStruct({value1: 1, value2: 2.0})\n\n    # Accessing a value\n    exampleStruct.value1 = 1\n\n.. index:: !mapping\n\nMappings\n--------\n\nMappings are `hash tables <https://en.wikipedia.org/wiki/Hash_table>`_ that are virtually initialized such that every possible key exists and is mapped to a value whose byte-representation is all zeros: a type's :ref:`default value <types-initial>`.\n\nThe key data is not stored in a mapping. Instead, its ``keccak256`` hash is used to look up a value. For this reason, mappings do not have a length or a concept of a key or value being \"set\".\n\nMapping types are declared as ``HashMap[_KeyType, _ValueType]``.\n\n* ``_KeyType`` can be any base or bytes type. Mappings, arrays or structs are not supported as key types.\n* ``_ValueType`` can actually be any type, including mappings.\n\n.. note::\n    Mappings are only allowed as state variables.\n\n.. code-block:: python\n\n   # Defining a mapping\n   exampleMapping: HashMap[int128, decimal]\n\n   # Accessing a value\n   exampleMapping[0] = 10.1\n\n.. note::\n\n    Mappings have no concept of length and so cannot be iterated over.\n\n.. index:: !initial\n\n.. _types-initial:\n\nInitial Values\n==============\n\nUnlike most programming languages, Vyper does not have a concept of ``null``. Instead, every variable type has a default value. To check if a variable is empty, you must compare it to the default value for its given type.\n\nTo reset a variable to its default value, assign to it the built-in ``empty()`` function which constructs a zero value for that type.\n\n.. note::\n\n    Memory variables must be assigned a value at the time they are declared.\n\nHere you can find a list of all types and default values:\n\n=========== ======================================================================\nType        Default Value\n=========== ======================================================================\n``address`` ``0x0000000000000000000000000000000000000000``\n``bool``    ``False``\n``bytes32`` ``0x0000000000000000000000000000000000000000000000000000000000000000``\n``decimal`` ``0.0``\n``uint8``   ``0``\n``int128``  ``0``\n``int256``  ``0``\n``uint256`` ``0``\n=========== ======================================================================\n\n.. note::\n    In ``Bytes``, the array starts with the bytes all set to ``'\\x00'``.\n\n.. note::\n    In reference types, all the type's members are set to their initial values.\n\n\n.. _type_conversions:\n\nType Conversions\n================\n\nAll type conversions in Vyper must be made explicitly using the built-in ``convert(a: atype, btype)`` function. Type conversions in Vyper are designed to be safe and intuitive. All type conversions will check that the input is in bounds for the output type. The general principles are:\n\n* Except for conversions involving decimals and bools, the input is bit-for-bit preserved.\n* Conversions to bool map all nonzero inputs to 1.\n* When converting from decimals to integers, the input is truncated towards zero.\n* ``address`` types are treated as ``uint160``, except conversions with signed integers and decimals are not allowed.\n* Converting between right-padded (``bytes``, ``Bytes``, ``String``) and left-padded types, results in a rotation to convert the padding. For instance, converting from ``bytes20`` to ``address`` would result in rotating the input by 12 bytes to the right.\n* Converting between signed and unsigned integers reverts if the input is negative.\n* Narrowing conversions (e.g., ``int256 -> int128``) check that the input is in bounds for the output type.\n* Converting between bytes and int types results in sign-extension if the output type is signed. For instance, converting ``0xff`` (``bytes1``) to ``int8`` returns ``-1``.\n* Converting between bytes and int types which have different sizes follows the rule of going through the closest integer type, first. For instance, ``bytes1 -> int16`` is like ``bytes1 -> int8 -> int16`` (signextend, then widen). ``uint8 -> bytes20`` is like ``uint8 -> uint160 -> bytes20`` (rotate left 12 bytes).\n* Enums can be converted to and from ``uint256`` only.\n\nA small Python reference implementation is maintained as part of Vyper's test suite, it can be found `here <https://github.com/vyperlang/vyper/blob/c4c6afd07801a0cc0038cdd4007cc43860c54193/tests/parser/functions/test_convert.py#L318>`_. The motivation and more detailed discussion of the rules can be found `here <https://github.com/vyperlang/vyper/issues/2507>`_.\n", "import pytest\n\nfrom vyper.compiler import compile_code\nfrom vyper.exceptions import StorageLayoutException\n\n\ndef test_storage_layout_overrides():\n    code = \"\"\"\na: uint256\nb: uint256\"\"\"\n\n    storage_layout_overrides = {\n        \"a\": {\"type\": \"uint256\", \"slot\": 1},\n        \"b\": {\"type\": \"uint256\", \"slot\": 0},\n    }\n\n    expected_output = {\"storage_layout\": storage_layout_overrides, \"code_layout\": {}}\n\n    out = compile_code(\n        code, output_formats=[\"layout\"], storage_layout_override=storage_layout_overrides\n    )\n\n    assert out[\"layout\"] == expected_output\n\n\ndef test_storage_layout_for_more_complex():\n    code = \"\"\"\nfoo: HashMap[address, uint256]\n\n@external\n@nonreentrant(\"foo\")\ndef public_foo1():\n    pass\n\n@external\n@nonreentrant(\"foo\")\ndef public_foo2():\n    pass\n\n\n@internal\n@nonreentrant(\"bar\")\ndef _bar():\n    pass\n\n# mix it up a little\nbaz: Bytes[65]\nbar: uint256\n\n@external\n@nonreentrant(\"bar\")\ndef public_bar():\n    pass\n\n@external\n@nonreentrant(\"foo\")\ndef public_foo3():\n    pass\n    \"\"\"\n\n    storage_layout_override = {\n        \"nonreentrant.foo\": {\"type\": \"nonreentrant lock\", \"slot\": 8},\n        \"nonreentrant.bar\": {\"type\": \"nonreentrant lock\", \"slot\": 7},\n        \"foo\": {\"type\": \"HashMap[address, uint256]\", \"slot\": 1},\n        \"baz\": {\"type\": \"Bytes[65]\", \"slot\": 2},\n        \"bar\": {\"type\": \"uint256\", \"slot\": 6},\n    }\n\n    expected_output = {\"storage_layout\": storage_layout_override, \"code_layout\": {}}\n\n    out = compile_code(\n        code, output_formats=[\"layout\"], storage_layout_override=storage_layout_override\n    )\n\n    assert out[\"layout\"] == expected_output\n\n\ndef test_simple_collision():\n    code = \"\"\"\nname: public(String[64])\nsymbol: public(String[32])\"\"\"\n\n    storage_layout_override = {\n        \"name\": {\"slot\": 0, \"type\": \"String[64]\"},\n        \"symbol\": {\"slot\": 1, \"type\": \"String[32]\"},\n    }\n\n    with pytest.raises(\n        StorageLayoutException,\n        match=\"Storage collision! Tried to assign 'symbol' to slot 1\"\n        \" but it has already been reserved by 'name'\",\n    ):\n        compile_code(\n            code, output_formats=[\"layout\"], storage_layout_override=storage_layout_override\n        )\n\n\ndef test_incomplete_overrides():\n    code = \"\"\"\nname: public(String[64])\nsymbol: public(String[32])\"\"\"\n\n    storage_layout_override = {\"name\": {\"slot\": 0, \"type\": \"String[64]\"}}\n\n    with pytest.raises(\n        StorageLayoutException,\n        match=\"Could not find storage_slot for symbol. \"\n        \"Have you used the correct storage layout file?\",\n    ):\n        compile_code(\n            code, output_formats=[\"layout\"], storage_layout_override=storage_layout_override\n        )\n", "code = \"\"\"\n\nstruct StructOne:\n    a: String[33]\n    b: uint256[3]\n\nstruct StructTwo:\n    a: Bytes[5]\n    b: int128[2]\n    c: String[64]\n\na: public(StructOne)\nb: public(uint256[2])\nc: public(Bytes[32])\nd: public(int128[4])\nfoo: public(HashMap[uint256, uint256[3]])\ndyn_array: DynArray[uint256, 3]\ne: public(String[47])\nf: public(int256[1])\ng: public(StructTwo[2])\nh: public(int256[1])\n\n\n@external\ndef __init__():\n    self.a = StructOne({a: \"ok\", b: [4,5,6]})\n    self.b = [7, 8]\n    self.c = b\"thisisthirtytwobytesokhowdoyoudo\"\n    self.d = [-1, -2, -3, -4]\n    self.e = \"A realllllly long string but we wont use it all\"\n    self.f = [33]\n    self.g = [\n        StructTwo({a: b\"hello\", b: [-66, 420], c: \"another string\"}),\n        StructTwo({\n            a: b\"gbye\",\n            b: [1337, 888],\n            c: \"whatifthisstringtakesuptheentirelengthwouldthatbesobadidothinkso\"\n        })\n    ]\n    self.dyn_array = [1, 2, 3]\n    self.h =  [123456789]\n    self.foo[0] = [987, 654, 321]\n    self.foo[1] = [123, 456, 789]\n\n@external\n@nonreentrant('lock')\ndef with_lock():\n    pass\n\n\n@external\n@nonreentrant('otherlock')\ndef with_other_lock():\n    pass\n\"\"\"\n\n\ndef test_storage_slots(get_contract):\n    c = get_contract(code)\n    assert c.a() == (\"ok\", [4, 5, 6])\n    assert [c.b(i) for i in range(2)] == [7, 8]\n    assert c.c() == b\"thisisthirtytwobytesokhowdoyoudo\"\n    assert [c.d(i) for i in range(4)] == [-1, -2, -3, -4]\n    assert c.e() == \"A realllllly long string but we wont use it all\"\n    assert c.f(0) == 33\n    assert c.g(0) == (b\"hello\", [-66, 420], \"another string\")\n    assert c.g(1) == (\n        b\"gbye\",\n        [1337, 888],\n        \"whatifthisstringtakesuptheentirelengthwouldthatbesobadidothinkso\",\n    )\n    assert [c.foo(0, i) for i in range(3)] == [987, 654, 321]\n    assert [c.foo(1, i) for i in range(3)] == [123, 456, 789]\n    assert c.h(0) == 123456789\n\n\ndef test_reentrancy_lock(get_contract):\n    c = get_contract(code)\n\n    # if re-entrancy locks are incorrectly placed within storage, these\n    # calls will either revert or correupt the data that we read later\n    c.with_lock()\n    c.with_other_lock()\n\n    assert c.a() == (\"ok\", [4, 5, 6])\n    assert [c.b(i) for i in range(2)] == [7, 8]\n    assert c.c() == b\"thisisthirtytwobytesokhowdoyoudo\"\n    assert [c.d(i) for i in range(4)] == [-1, -2, -3, -4]\n    assert c.e() == \"A realllllly long string but we wont use it all\"\n    assert c.f(0) == 33\n    assert c.g(0) == (b\"hello\", [-66, 420], \"another string\")\n    assert c.g(1) == (\n        b\"gbye\",\n        [1337, 888],\n        \"whatifthisstringtakesuptheentirelengthwouldthatbesobadidothinkso\",\n    )\n    assert [c.foo(0, i) for i in range(3)] == [987, 654, 321]\n    assert [c.foo(1, i) for i in range(3)] == [123, 456, 789]\n    assert c.h(0) == 123456789\n", "# TODO this doesn't really belong in \"validation\"\nimport math\nfrom typing import Dict, List\n\nfrom vyper import ast as vy_ast\nfrom vyper.exceptions import StorageLayoutException\nfrom vyper.semantics.analysis.base import CodeOffset, StorageSlot\nfrom vyper.typing import StorageLayout\n\n\ndef set_data_positions(\n    vyper_module: vy_ast.Module, storage_layout_overrides: StorageLayout = None\n) -> StorageLayout:\n    \"\"\"\n    Parse the annotated Vyper AST, determine data positions for all variables,\n    and annotate the AST nodes with the position data.\n\n    Arguments\n    ---------\n    vyper_module : vy_ast.Module\n        Top-level Vyper AST node that has already been annotated with type data.\n    \"\"\"\n    code_offsets = set_code_offsets(vyper_module)\n    storage_slots = (\n        set_storage_slots_with_overrides(vyper_module, storage_layout_overrides)\n        if storage_layout_overrides is not None\n        else set_storage_slots(vyper_module)\n    )\n\n    return {\"storage_layout\": storage_slots, \"code_layout\": code_offsets}\n\n\nclass StorageAllocator:\n    \"\"\"\n    Keep track of which storage slots have been used. If there is a collision of\n    storage slots, this will raise an error and fail to compile\n    \"\"\"\n\n    def __init__(self):\n        self.occupied_slots: Dict[int, str] = {}\n\n    def reserve_slot_range(self, first_slot: int, n_slots: int, var_name: str) -> None:\n        \"\"\"\n        Reserves `n_slots` storage slots, starting at slot `first_slot`\n        This will raise an error if a storage slot has already been allocated.\n        It is responsibility of calling function to ensure first_slot is an int\n        \"\"\"\n        list_to_check = [x + first_slot for x in range(n_slots)]\n        self._reserve_slots(list_to_check, var_name)\n\n    def _reserve_slots(self, slots: List[int], var_name: str) -> None:\n        for slot in slots:\n            self._reserve_slot(slot, var_name)\n\n    def _reserve_slot(self, slot: int, var_name: str) -> None:\n        if slot < 0 or slot >= 2**256:\n            raise StorageLayoutException(\n                f\"Invalid storage slot for var {var_name}, out of bounds: {slot}\"\n            )\n        if slot in self.occupied_slots:\n            collided_var = self.occupied_slots[slot]\n            raise StorageLayoutException(\n                f\"Storage collision! Tried to assign '{var_name}' to slot {slot} but it has \"\n                f\"already been reserved by '{collided_var}'\"\n            )\n        self.occupied_slots[slot] = var_name\n\n\ndef set_storage_slots_with_overrides(\n    vyper_module: vy_ast.Module, storage_layout_overrides: StorageLayout\n) -> StorageLayout:\n    \"\"\"\n    Parse module-level Vyper AST to calculate the layout of storage variables.\n    Returns the layout as a dict of variable name -> variable info\n    \"\"\"\n\n    ret: Dict[str, Dict] = {}\n    reserved_slots = StorageAllocator()\n\n    # Search through function definitions to find non-reentrant functions\n    for node in vyper_module.get_children(vy_ast.FunctionDef):\n        type_ = node._metadata[\"type\"]\n\n        # Ignore functions without non-reentrant\n        if type_.nonreentrant is None:\n            continue\n\n        variable_name = f\"nonreentrant.{type_.nonreentrant}\"\n\n        # re-entrant key was already identified\n        if variable_name in ret:\n            _slot = ret[variable_name][\"slot\"]\n            type_.set_reentrancy_key_position(StorageSlot(_slot))\n            continue\n\n        # Expect to find this variable within the storage layout override\n        if variable_name in storage_layout_overrides:\n            reentrant_slot = storage_layout_overrides[variable_name][\"slot\"]\n            # Ensure that this slot has not been used, and prevents other storage variables\n            # from using the same slot\n            reserved_slots.reserve_slot_range(reentrant_slot, 1, variable_name)\n\n            type_.set_reentrancy_key_position(StorageSlot(reentrant_slot))\n\n            ret[variable_name] = {\"type\": \"nonreentrant lock\", \"slot\": reentrant_slot}\n        else:\n            raise StorageLayoutException(\n                f\"Could not find storage_slot for {variable_name}. \"\n                \"Have you used the correct storage layout file?\",\n                node,\n            )\n\n    # Iterate through variables\n    for node in vyper_module.get_children(vy_ast.VariableDecl):\n        # Ignore immutable parameters\n        if node.get(\"annotation.func.id\") == \"immutable\":\n            continue\n\n        varinfo = node.target._metadata[\"varinfo\"]\n\n        # Expect to find this variable within the storage layout overrides\n        if node.target.id in storage_layout_overrides:\n            var_slot = storage_layout_overrides[node.target.id][\"slot\"]\n            # Calculate how many storage slots are required\n            storage_length = math.ceil(varinfo.typ.size_in_bytes / 32)\n            # Ensure that all required storage slots are reserved, and prevents other variables\n            # from using these slots\n            reserved_slots.reserve_slot_range(var_slot, storage_length, node.target.id)\n            varinfo.set_position(StorageSlot(var_slot))\n\n            ret[node.target.id] = {\"type\": str(varinfo.typ), \"slot\": var_slot}\n        else:\n            raise StorageLayoutException(\n                f\"Could not find storage_slot for {node.target.id}. \"\n                \"Have you used the correct storage layout file?\",\n                node,\n            )\n\n    return ret\n\n\ndef set_storage_slots(vyper_module: vy_ast.Module) -> StorageLayout:\n    \"\"\"\n    Parse module-level Vyper AST to calculate the layout of storage variables.\n    Returns the layout as a dict of variable name -> variable info\n    \"\"\"\n    # Allocate storage slots from 0\n    # note storage is word-addressable, not byte-addressable\n    storage_slot = 0\n\n    ret: Dict[str, Dict] = {}\n\n    for node in vyper_module.get_children(vy_ast.FunctionDef):\n        type_ = node._metadata[\"type\"]\n        if type_.nonreentrant is None:\n            continue\n\n        variable_name = f\"nonreentrant.{type_.nonreentrant}\"\n\n        # a nonreentrant key can appear many times in a module but it\n        # only takes one slot. after the first time we see it, do not\n        # increment the storage slot.\n        if variable_name in ret:\n            _slot = ret[variable_name][\"slot\"]\n            type_.set_reentrancy_key_position(StorageSlot(_slot))\n            continue\n\n        type_.set_reentrancy_key_position(StorageSlot(storage_slot))\n\n        # TODO this could have better typing but leave it untyped until\n        # we nail down the format better\n        ret[variable_name] = {\"type\": \"nonreentrant lock\", \"slot\": storage_slot}\n\n        # TODO use one byte - or bit - per reentrancy key\n        # requires either an extra SLOAD or caching the value of the\n        # location in memory at entrance\n        storage_slot += 1\n\n    for node in vyper_module.get_children(vy_ast.VariableDecl):\n        # skip non-storage variables\n        if node.is_constant or node.is_immutable:\n            continue\n\n        varinfo = node.target._metadata[\"varinfo\"]\n        varinfo.set_position(StorageSlot(storage_slot))\n\n        type_ = varinfo.typ\n\n        # this could have better typing but leave it untyped until\n        # we understand the use case better\n        ret[node.target.id] = {\"type\": str(type_), \"slot\": storage_slot}\n\n        # CMC 2021-07-23 note that HashMaps get assigned a slot here.\n        # I'm not sure if it's safe to avoid allocating that slot\n        # for HashMaps because downstream code might use the slot\n        # ID as a salt.\n        storage_slot += math.ceil(type_.size_in_bytes / 32)\n\n    return ret\n\n\ndef set_calldata_offsets(fn_node: vy_ast.FunctionDef) -> None:\n    pass\n\n\ndef set_memory_offsets(fn_node: vy_ast.FunctionDef) -> None:\n    pass\n\n\ndef set_code_offsets(vyper_module: vy_ast.Module) -> Dict:\n    ret = {}\n    offset = 0\n\n    for node in vyper_module.get_children(vy_ast.VariableDecl, filters={\"is_immutable\": True}):\n        varinfo = node.target._metadata[\"varinfo\"]\n        type_ = varinfo.typ\n        varinfo.set_position(CodeOffset(offset))\n\n        len_ = math.ceil(type_.size_in_bytes / 32) * 32\n\n        # this could have better typing but leave it untyped until\n        # we understand the use case better\n        ret[node.target.id] = {\"type\": str(type_), \"offset\": offset, \"length\": len_}\n\n        offset += len_\n\n    return ret\n", "from typing import Any, Dict, Optional, Tuple, Union\n\nfrom vyper import ast as vy_ast\nfrom vyper.abi_types import ABI_DynamicArray, ABI_StaticArray, ABI_Tuple, ABIType\nfrom vyper.exceptions import ArrayIndexException, InvalidType, StructureException\nfrom vyper.semantics.types.base import VyperType\nfrom vyper.semantics.types.primitives import IntegerT\nfrom vyper.semantics.types.shortcuts import UINT256_T\nfrom vyper.semantics.types.utils import get_index_value, type_from_annotation\n\n\nclass _SubscriptableT(VyperType):\n    \"\"\"\n    Base class for subscriptable types such as arrays and mappings.\n\n    Attributes\n    ----------\n    key_type: VyperType\n        Type representing the index for this object.\n    value_type : VyperType\n        Type representing the value(s) contained in this object.\n    \"\"\"\n\n    def __init__(self, key_type: VyperType, value_type: VyperType) -> None:\n        super().__init__()\n        self.key_type = key_type\n        self.value_type = value_type\n\n    @property\n    def getter_signature(self) -> Tuple[Tuple, Optional[VyperType]]:\n        child_keys, return_type = self.value_type.getter_signature\n        return (self.key_type,) + child_keys, return_type\n\n    def validate_index_type(self, node):\n        # TODO: break this cycle\n        from vyper.semantics.analysis.utils import validate_expected_type\n\n        validate_expected_type(node, self.key_type)\n\n\nclass HashMapT(_SubscriptableT):\n    _id = \"HashMap\"\n\n    _equality_attrs = (\"key_type\", \"value_type\")\n\n    def __repr__(self):\n        return f\"HashMap[{self.key_type}, {self.value_type}]\"\n\n    # TODO not sure this is used?\n    def compare_type(self, other):\n        return (\n            super().compare_type(other)\n            and self.key_type == other.key_type\n            and self.value_type == other.value_type\n        )\n\n    def get_subscripted_type(self, node):\n        return self.value_type\n\n    @classmethod\n    def from_annotation(cls, node: Union[vy_ast.Name, vy_ast.Call, vy_ast.Subscript]) -> \"HashMapT\":\n        if (\n            not isinstance(node, vy_ast.Subscript)\n            or not isinstance(node.slice, vy_ast.Index)\n            or not isinstance(node.slice.value, vy_ast.Tuple)\n            or len(node.slice.value.elements) != 2\n        ):\n            raise StructureException(\n                (\n                    \"HashMap must be defined with a key type and a value type, \"\n                    \"e.g. my_hashmap: HashMap[k, v]\"\n                ),\n                node,\n            )\n        # if location != DataLocation.STORAGE or is_immutable:\n        #    raise StructureException(\"HashMap can only be declared as a storage variable\", node)\n\n        k_ast, v_ast = node.slice.value.elements\n        key_type = type_from_annotation(k_ast)\n        if not key_type._as_hashmap_key:\n            raise InvalidType(\"can only use primitive types as HashMap key!\", k_ast)\n\n        value_type = type_from_annotation(v_ast)\n\n        return cls(key_type, value_type)\n\n\nclass _SequenceT(_SubscriptableT):\n    \"\"\"\n    Private base class for sequence types (i.e., index is an int)\n\n    Arguments\n    ---------\n    length : int\n        Number of items in the type.\n    \"\"\"\n\n    _equality_attrs: tuple = (\"value_type\", \"length\")\n\n    _is_array_type: bool = True\n\n    def __init__(self, value_type: VyperType, length: int):\n        if not 0 < length < 2**256:\n            raise InvalidType(\"Array length is invalid\")\n\n        super().__init__(UINT256_T, value_type)\n        self.length = length\n\n    @property\n    def count(self):\n        \"\"\"\n        Alias for API compatibility\n        \"\"\"\n        return self.length\n\n    def validate_index_type(self, node):\n        # TODO break this cycle\n        from vyper.semantics.analysis.utils import validate_expected_type\n\n        if isinstance(node, vy_ast.Int):\n            if node.value < 0:\n                raise ArrayIndexException(\"Vyper does not support negative indexing\", node)\n            if node.value >= self.length:\n                raise ArrayIndexException(\"Index out of range\", node)\n\n        validate_expected_type(node, IntegerT.any())\n\n    def get_subscripted_type(self, node):\n        return self.value_type\n\n\n# override value at `k` with `val`, but inserting it before other keys\n# for formatting reasons. besides insertion order, equivalent to\n# `{k: val, **xs}`\ndef _set_first_key(xs: Dict[str, Any], k: str, val: Any) -> dict:\n    xs.pop(k, None)\n    return {k: val, **xs}\n\n\nclass SArrayT(_SequenceT):\n    \"\"\"\n    Static array type\n    \"\"\"\n\n    def __init__(self, value_type: VyperType, length: int) -> None:\n        super().__init__(value_type, length)\n\n    def __repr__(self):\n        return f\"{self.value_type}[{self.length}]\"\n\n    @property\n    def _as_array(self):\n        # a static array is arrayable if its value_type is arrayble.\n        return self.value_type._as_array\n\n    @property\n    def abi_type(self) -> ABIType:\n        return ABI_StaticArray(self.value_type.abi_type, self.length)\n\n    def to_abi_arg(self, name: str = \"\") -> Dict[str, Any]:\n        ret = self.value_type.to_abi_arg()\n        # modify the child name in place\n        ret[\"type\"] += f\"[{self.length}]\"\n        return _set_first_key(ret, \"name\", name)\n\n    # TODO rename to `memory_bytes_required`\n    @property\n    def size_in_bytes(self):\n        return self.value_type.size_in_bytes * self.length\n\n    @property\n    def subtype(self):\n        \"\"\"\n        Alias for API compatibility with codegen\n        \"\"\"\n        return self.value_type\n\n    def get_subscripted_type(self, node):\n        return self.value_type\n\n    def compare_type(self, other):\n        if not isinstance(self, type(other)):\n            return False\n        if self.length != other.length:\n            return False\n        return self.value_type.compare_type(other.value_type)\n\n    @classmethod\n    def from_annotation(cls, node: vy_ast.Subscript) -> \"SArrayT\":\n        if not isinstance(node, vy_ast.Subscript) or not isinstance(node.slice, vy_ast.Index):\n            raise StructureException(\n                \"Arrays must be defined with base type and length, e.g. bool[5]\", node\n            )\n\n        value_type = type_from_annotation(node.value)\n\n        if not value_type._as_array:\n            raise StructureException(f\"arrays of {value_type} are not allowed!\")\n\n        # note: validates index is a vy_ast.Int.\n        length = get_index_value(node.slice)\n        return cls(value_type, length)\n\n\nclass DArrayT(_SequenceT):\n    \"\"\"\n    Dynamic array type\n    \"\"\"\n\n    _valid_literal = (vy_ast.List,)\n    _as_array = True\n    _id = \"DynArray\"\n\n    def __init__(self, value_type: VyperType, length: int) -> None:\n        super().__init__(value_type, length)\n\n        from vyper.semantics.types.function import MemberFunctionT\n\n        self.add_member(\"append\", MemberFunctionT(self, \"append\", [self.value_type], None, True))\n        self.add_member(\"pop\", MemberFunctionT(self, \"pop\", [], self.value_type, True))\n\n    def __repr__(self):\n        return f\"DynArray[{self.value_type}, {self.length}]\"\n\n    @property\n    def subtype(self):\n        \"\"\"\n        Alias for backwards compatibility.\n        \"\"\"\n        return self.value_type\n\n    @property\n    def count(self):\n        \"\"\"\n        Alias for backwards compatibility.\n        \"\"\"\n        return self.length\n\n    @property\n    def abi_type(self) -> ABIType:\n        return ABI_DynamicArray(self.value_type.abi_type, self.length)\n\n    def to_abi_arg(self, name: str = \"\") -> Dict[str, Any]:\n        ret = self.value_type.to_abi_arg()\n        # modify the child name in place.\n        ret[\"type\"] += \"[]\"\n        return _set_first_key(ret, \"name\", name)\n\n    # TODO rename me to memory_bytes_required\n    @property\n    def size_in_bytes(self):\n        # one length word + size of the array items\n        return 32 + self.value_type.size_in_bytes * self.length\n\n    def compare_type(self, other):\n        # TODO allow static array to be assigned to dyn array?\n        # if not isinstance(other, (DArrayT, SArrayT)):\n        if not isinstance(self, type(other)):\n            return False\n        if self.length < other.length:\n            return False\n        return self.value_type.compare_type(other.value_type)\n\n    @classmethod\n    def from_annotation(cls, node: vy_ast.Subscript) -> \"DArrayT\":\n        if (\n            not isinstance(node, vy_ast.Subscript)\n            or not isinstance(node.slice, vy_ast.Index)\n            or not isinstance(node.slice.value, vy_ast.Tuple)\n            or not isinstance(node.slice.value.elements[1], vy_ast.Int)\n            or len(node.slice.value.elements) != 2\n        ):\n            raise StructureException(\n                \"DynArray must be defined with base type and max length, e.g. DynArray[bool, 5]\",\n                node,\n            )\n\n        value_type = type_from_annotation(node.slice.value.elements[0])\n        if not value_type._as_darray:\n            raise StructureException(f\"Arrays of {value_type} are not allowed\", node)\n\n        max_length = node.slice.value.elements[1].value\n        return cls(value_type, max_length)\n\n\nclass TupleT(VyperType):\n    \"\"\"\n    Tuple type definition.\n\n    This class is used to represent multiple return values from\n    functions.\n    \"\"\"\n\n    _equality_attrs = (\"members\",)\n\n    def __init__(self, member_types: Tuple[VyperType, ...]) -> None:\n        super().__init__()\n        self.member_types = member_types\n        self.key_type = UINT256_T  # API Compatibility\n\n    def __repr__(self):\n        return \"(\" + \", \".join(repr(t) for t in self.member_types) + \")\"\n\n    @property\n    def length(self):\n        return len(self.member_types)\n\n    def tuple_members(self):\n        return [v for (_k, v) in self.tuple_items()]\n\n    def tuple_keys(self):\n        return [k for (k, _v) in self.tuple_items()]\n\n    def tuple_items(self):\n        return list(enumerate(self.member_types))\n\n    @classmethod\n    def from_annotation(cls, node: vy_ast.Tuple) -> VyperType:\n        values = node.elements\n        types = tuple(type_from_annotation(v) for v in values)\n        return cls(types)\n\n    @property\n    def abi_type(self) -> ABIType:\n        return ABI_Tuple([t.abi_type for t in self.member_types])\n\n    def to_abi_arg(self, name: str = \"\") -> dict:\n        components = [t.to_abi_arg() for t in self.member_types]\n        return {\"name\": name, \"type\": \"tuple\", \"components\": components}\n\n    @property\n    def size_in_bytes(self):\n        return sum(i.size_in_bytes for i in self.member_types)\n\n    def validate_index_type(self, node):\n        if not isinstance(node, vy_ast.Int):\n            raise InvalidType(\"Tuple indexes must be literals\", node)\n        if node.value < 0:\n            raise ArrayIndexException(\"Vyper does not support negative indexing\", node)\n        if node.value >= self.length:\n            raise ArrayIndexException(\"Index out of range\", node)\n\n    def get_subscripted_type(self, node):\n        return self.member_types[node.value]\n\n    def compare_type(self, other):\n        if not isinstance(self, type(other)):\n            return False\n        if self.length != other.length:\n            return False\n        return all(a.compare_type(b) for (a, b) in zip(self.member_types, other.member_types))\n"], "fixing_code": [".. index:: type\n\n.. _types:\n\nTypes\n#####\n\nVyper is a statically typed language. The type of each variable (state and local) must be specified or at least known at compile-time. Vyper provides several elementary types which can be combined to form complex types.\n\nIn addition, types can interact with each other in expressions containing operators.\n\n.. index:: ! value\n\nValue Types\n===========\n\nThe following types are also called value types because variables of these\ntypes will always be passed by value, i.e. they are always copied when they\nare used as function arguments or in assignments.\n\n.. index:: ! bool, ! true, ! false\n\nBoolean\n-------\n\n**Keyword:** ``bool``\n\nA boolean is a type to store a logical/truth value.\n\nValues\n******\n\nThe only possible values are the constants ``True`` and ``False``.\n\nOperators\n*********\n\n====================  ===================\nOperator              Description\n====================  ===================\n``not x``             Logical negation\n``x and y``           Logical conjunction\n``x or y``            Logical disjunction\n``x == y``            Equality\n``x != y``            Inequality\n====================  ===================\n\nShort-circuiting of boolean operators (``or`` and ``and``) is consistent with\nthe behavior of Python.\n\n.. index:: ! intN, ! int, ! signed integer\n\nSigned Integer (N bit)\n------------------------\n\n**Keyword:** ``intN`` (e.g., ``int128``)\n\nA signed integer which can store positive and negative integers. ``N`` must be a multiple of 8 between 8 and 256 (inclusive).\n\nValues\n******\n\nSigned integer values between -2\\ :sup:`N-1` and (2\\ :sup:`N-1` - 1), inclusive.\n\nInteger literals cannot have a decimal point even if the decimal value is zero. For example, ``2.0`` cannot be interpreted as an integer.\n\nOperators\n*********\n\nComparisons\n^^^^^^^^^^^\n\nComparisons return a boolean value.\n\n==========  ================\nOperator    Description\n==========  ================\n``x < y``   Less than\n``x <= y``  Less than or equal to\n``x == y``  Equals\n``x != y``  Does not equal\n``x >= y``  Greater than or equal to\n``x > y``   Greater than\n==========  ================\n\n``x`` and ``y`` must both be of the same type.\n\nArithmetic Operators\n^^^^^^^^^^^^^^^^^^^^\n\n=============  ======================\nOperator       Description\n=============  ======================\n``x + y``      Addition\n``x - y``      Subtraction\n``-x``         Unary minus/Negation\n``x * y``      Multiplication\n``x / y``      Division\n``x**y``       Exponentiation\n``x % y``      Modulo\n=============  ======================\n\n``x`` and ``y`` must both be of the same type.\n\nBitwise Operators\n^^^^^^^^^^^^^^^^^\n\n=============  ======================\nOperator       Description\n=============  ======================\n``x & y``      Bitwise and\n``x | y``      Bitwise or\n``x ^ y``      Bitwise xor\n=============  ======================\n\n``x`` and ``y`` must be of the same type.\n\nShifts\n^^^^^^^^^^^^^^^^^\n\n=============  ======================\nOperator       Description\n=============  ======================\n``x << y``     Left shift\n``x >> y``     Right shift\n=============  ======================\n\nShifting is only available for 256-bit wide types. That is, ``x`` must be ``int256``, and ``y`` can be any unsigned integer. The right shift for ``int256`` compiles to a signed right shift (EVM ``SAR`` instruction).\n\n\n.. note::\n   While at runtime shifts are unchecked (that is, they can be for any number of bits), to prevent common mistakes, the compiler is stricter at compile-time and will prevent out of bounds shifts. For instance, at runtime, ``1 << 257`` will evaluate to ``0``, while that expression at compile-time will raise an ``OverflowException``.\n\n\n.. index:: ! uint, ! uintN, ! unsigned integer\n\nUnsigned Integer (N bit)\n--------------------------\n\n**Keyword:** ``uintN`` (e.g., ``uint8``)\n\nA unsigned integer which can store positive integers. ``N`` must be a multiple of 8 between 8 and 256 (inclusive).\n\nValues\n******\n\nInteger values between 0 and (2\\ :sup:`N`-1).\n\nInteger literals cannot have a decimal point even if the decimal value is zero. For example, ``2.0`` cannot be interpreted as an integer.\n\n.. note::\n    Integer literals are interpreted as ``int256`` by default. In cases where ``uint8`` is more appropriate, such as assignment, the literal might be interpreted as ``uint8``. Example: ``_variable: uint8 = _literal``. In order to explicitly cast a literal to a ``uint8`` use ``convert(_literal, uint8)``.\n\nOperators\n*********\n\nComparisons\n^^^^^^^^^^^\n\nComparisons return a boolean value.\n\n==========  ================\nOperator    Description\n==========  ================\n``x < y``   Less than\n``x <= y``  Less than or equal to\n``x == y``  Equals\n``x != y``  Does not equal\n``x >= y``  Greater than or equal to\n``x > y``   Greater than\n==========  ================\n\n``x`` and ``y`` must be of the same type.\n\nArithmetic Operators\n^^^^^^^^^^^^^^^^^^^^\n\n===========================  ======================\nOperator                     Description\n===========================  ======================\n``x + y``                    Addition\n``x - y``                    Subtraction\n``x * y``                    Multiplication\n``x / y``                    Division\n``x**y``                     Exponentiation\n``x % y``                    Modulo\n===========================  ======================\n\n``x`` and ``y`` must be of the same type.\n\nBitwise Operators\n^^^^^^^^^^^^^^^^^\n\n=============  ======================\nOperator       Description\n=============  ======================\n``x & y``      Bitwise and\n``x | y``      Bitwise or\n``x ^ y``      Bitwise xor\n``~x``         Bitwise not\n=============  ======================\n\n``x`` and ``y`` must be of the same type.\n\n.. note::\n    The Bitwise ``not`` operator is currently only available for ``uint256`` type.\n\nShifts\n^^^^^^^^^^^^^^^^^\n\n=============  ======================\nOperator       Description\n=============  ======================\n``x << y``     Left shift\n``x >> y``     Right shift\n=============  ======================\n\nShifting is only available for 256-bit wide types. That is, ``x`` must be ``uint256``, and ``y`` can be any unsigned integer. The right shift for ``uint256`` compiles to a signed right shift (EVM ``SHR`` instruction).\n\n\n.. note::\n   While at runtime shifts are unchecked (that is, they can be for any number of bits), to prevent common mistakes, the compiler is stricter at compile-time and will prevent out of bounds shifts. For instance, at runtime, ``1 << 257`` will evaluate to ``0``, while that expression at compile-time will raise an ``OverflowException``.\n\n\n\nDecimals\n--------\n\n**Keyword:** ``decimal``\n\nA decimal is a type to store a decimal fixed point value.\n\nValues\n******\n\nA value with a precision of 10 decimal places between -18707220957835557353007165858768422651595.9365500928 (-2\\ :sup:`167` / 10\\ :sup:`10`) and 18707220957835557353007165858768422651595.9365500927 ((2\\ :sup:`167` - 1) / 10\\ :sup:`10`).\n\nIn order for a literal to be interpreted as ``decimal`` it must include a decimal point.\n\nThe ABI type (for computing method identifiers) of ``decimal`` is ``fixed168x10``.\n\nOperators\n*********\n\nComparisons\n^^^^^^^^^^^\n\nComparisons return a boolean value.\n\n==========  ================\nOperator    Description\n==========  ================\n``x < y``   Less than\n``x <= y``  Less or equal\n``x == y``  Equals\n``x != y``  Does not equal\n``x >= y``  Greater or equal\n``x > y``   Greater than\n==========  ================\n\n``x`` and ``y`` must be of the type ``decimal``.\n\nArithmetic Operators\n^^^^^^^^^^^^^^^^^^^^\n\n=============  ==========================================\nOperator       Description\n=============  ==========================================\n``x + y``      Addition\n``x - y``      Subtraction\n``-x``         Unary minus/Negation\n``x * y``      Multiplication\n``x / y``      Division\n``x % y``      Modulo\n=============  ==========================================\n\n``x`` and ``y`` must be of the type ``decimal``.\n\n.. _address:\n\nAddress\n-------\n\n**Keyword:** ``address``\n\nThe address type holds an Ethereum address.\n\nValues\n******\n\nAn address type can hold an Ethereum address which equates to 20 bytes or 160 bits. Address literals must be written in hexadecimal notation with a leading ``0x`` and must be `checksummed <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md>`_.\n\n.. _members-of-addresses:\n\nMembers\n^^^^^^^\n\n=============== =========== ==========================================================================\nMember          Type        Description\n=============== =========== ==========================================================================\n``balance``     ``uint256`` Balance of an address\n``codehash``    ``bytes32`` Keccak of code at an address, ``EMPTY_BYTES32`` if no contract is deployed\n``codesize``    ``uint256`` Size of code deployed at an address, in bytes\n``is_contract`` ``bool``    Boolean indicating if a contract is deployed at an address\n``code``        ``Bytes``   Contract bytecode\n=============== =========== ==========================================================================\n\nSyntax as follows: ``_address.<member>``, where ``_address`` is of the type ``address`` and ``<member>`` is one of the above keywords.\n\n.. note::\n\n    Operations such as ``SELFDESTRUCT`` and ``CREATE2`` allow for the removal and replacement of bytecode at an address. You should never assume that values of address members will not change in the future.\n\n.. note::\n\n    ``_address.code`` requires the usage of :func:`slice <slice>` to explicitly extract a section of contract bytecode. If the extracted section exceeds the bounds of bytecode, this will throw. You can check the size of ``_address.code`` using ``_address.codesize``.\n\nM-byte-wide Fixed Size Byte Array\n----------------------\n\n**Keyword:** ``bytesM``\nThis is an M-byte-wide byte array that is otherwise similar to dynamically sized byte arrays. On an ABI level, it is annotated as bytesM (e.g., bytes32).\n\n**Example:**\n::\n\n    # Declaration\n    hash: bytes32\n    # Assignment\n    self.hash = _hash\n\n    some_method_id: bytes4 = 0x01abcdef\n\nOperators\n*********\n\n====================================  ============================================================\nKeyword                               Description\n====================================  ============================================================\n``keccak256(x)``                      Return the keccak256 hash as bytes32.\n``concat(x, ...)``                    Concatenate multiple inputs.\n``slice(x, start=_start, len=_len)``  Return a slice of ``_len`` starting at ``_start``.\n====================================  ============================================================\n\nWhere ``x`` is a byte array and ``_start`` as well as ``_len`` are integer values.\n\n.. index:: !bytes\n\nByte Arrays\n-----------\n\n**Keyword:** ``Bytes``\n\nA byte array with a max size.\n\nThe syntax being ``Bytes[maxLen]``, where ``maxLen`` is an integer which denotes the maximum number of bytes.\nOn the ABI level the Fixed-size bytes array is annotated as ``bytes``.\n\nBytes literals may be given as bytes strings.\n\n.. code-block:: python\n\n    bytes_string: Bytes[100] = b\"\\x01\"\n\n.. index:: !string\n\nStrings\n-------\n\n**Keyword:** ``String``\n\nFixed-size strings can hold strings with equal or fewer characters than the maximum length of the string.\nOn the ABI level the Fixed-size bytes array is annotated as ``string``.\n\n.. code-block:: python\n\n    example_str: String[100] = \"Test String\"\n\nEnums\n-----\n\n**Keyword:** ``enum``\n\nEnums are custom defined types. An enum must have at least one member, and can hold up to a maximum of 256 members.\nThe members are represented by ``uint256`` values in the form of 2\\ :sup:`n` where ``n`` is the index of the member in the range ``0 <= n <= 255``.\n\n.. code-block:: python\n\n    # Defining an enum with two members\n    enum Roles:\n        ADMIN\n        USER\n\n    # Declaring an enum variable\n    role: Roles = Roles.ADMIN\n\n    # Returning a member\n    return Roles.ADMIN\n\nOperators\n*********\n\nComparisons\n^^^^^^^^^^^\n\nComparisons return a boolean value.\n\n============== ================\nOperator       Description\n============== ================\n``x == y``     Equals\n``x != y``     Does not equal\n``x in y``     x is in y\n``x not in y`` x is not in y\n============== ================\n\nBitwise Operators\n^^^^^^^^^^^^^^^^^\n\n=============  ======================\nOperator       Description\n=============  ======================\n``x & y``      Bitwise and\n``x | y``      Bitwise or\n``x ^ y``      Bitwise xor\n``~x``         Bitwise not\n=============  ======================\n\nEnum members can be combined using the above bitwise operators. While enum members have values that are power of two, enum member combinations may not.\n\nThe ``in`` and ``not in`` operators can be used in conjunction with enum member combinations to check for membership.\n\n.. code-block:: python\n\n    enum Roles:\n        MANAGER\n        ADMIN\n        USER\n\n    # Check for membership\n    @external\n    def foo(a: Roles) -> bool:\n        return a in (Roles.MANAGER | Roles.USER)\n\n    # Check not in\n    @external\n    def bar(a: Roles) -> bool:\n        return a not in (Roles.MANAGER | Roles.USER)\n\nNote that ``in`` is not the same as strict equality (``==``). ``in`` checks that *any* of the flags on two enum objects are simultaneously set, while ``==`` checks that two enum objects are bit-for-bit equal.\n\nThe following code uses bitwise operations to add and revoke permissions from a given ``Roles`` object.\n\n.. code-block:: python\n    @external\n    def add_user(a: Roles) -> Roles:\n        ret: Roles = a\n        ret |= Roles.USER  # set the USER bit to 1\n        return ret\n\n    @external\n    def revoke_user(a: Roles) -> Roles:\n        ret: Roles = a\n        ret &= ~Roles.USER  # set the USER bit to 0\n        return ret\n\n    @external\n    def flip_user(a: Roles) -> Roles:\n        ret: Roles = a\n        ret ^= Roles.USER  # flip the user bit between 0 and 1\n        return ret\n\n.. index:: !reference\n\nReference Types\n===============\n\nReference types are those whose components can be assigned to in-place without copying. For instance, array and struct members can be individually assigned to without overwriting the whole data structure.\n\n.. note::\n\n  In terms of the calling convention, reference types are passed by value, not by reference. That means that, a calling function does not need to worry about a callee modifying the data of a passed structure.\n\n.. index:: !arrays\n\nFixed-size Lists\n----------------\n\nFixed-size lists hold a finite number of elements which belong to a specified type.\n\nLists can be declared with ``_name: _ValueType[_Integer]``, except ``Bytes[N]``, ``String[N]`` and enums.\n\n.. code-block:: python\n\n    # Defining a list\n    exampleList: int128[3]\n\n    # Setting values\n    exampleList = [10, 11, 12]\n    exampleList[2] = 42\n\n    # Returning a value\n    return exampleList[0]\n\nMultidimensional lists are also possible. The notation for the declaration is reversed compared to some other languages, but the access notation is not reversed.\n\nA two dimensional list can be declared with ``_name: _ValueType[inner_size][outer_size]``. Elements can be accessed with ``_name[outer_index][inner_index]``.\n\n.. code-block:: python\n\n    # Defining a list with 2 rows and 5 columns and set all values to 0\n    exampleList2D: int128[5][2] = empty(int128[5][2])\n\n    # Setting a value for row the first row (0) and last column (4)\n    exampleList2D[0][4] = 42\n\n    # Setting values\n    exampleList2D = [[10, 11, 12, 13, 14], [16, 17, 18, 19, 20]]\n\n    # Returning the value in row 0 column 4 (in this case 14)\n    return exampleList2D[0][4]\n\n.. note::\n    Defining an array in storage whose size is significantly larger than ``2**64`` can result in security vulnerabilities due to risk of overflow.\n\n.. index:: !dynarrays\n\nDynamic Arrays\n----------------\n\nDynamic arrays represent bounded arrays whose length can be modified at runtime, up to a bound specified in the type. They can be declared with ``_name: DynArray[_Type, _Integer]``, where ``_Type`` can be of value type or reference type (except mappings).\n\n.. code-block:: python\n\n    # Defining a list\n    exampleList: DynArray[int128, 3]\n\n    # Setting values\n    exampleList = []\n    # exampleList.pop()  # would revert!\n    exampleList.append(42)  # exampleList now has length 1\n    exampleList.append(120)  # exampleList now has length 2\n    exampleList.append(356)  # exampleList now has length 3\n    # exampleList.append(1)  # would revert!\n\n    myValue: int128 = exampleList.pop()  # myValue == 356, exampleList now has length 2\n\n    # myValue = exampleList[2]  # would revert!\n\n    # Returning a value\n    return exampleList[0]\n\n\n.. note::\n    Attempting to access data past the runtime length of an array, ``pop()`` an empty array or ``append()`` to a full array will result in a runtime ``REVERT``. Attempting to pass an array in calldata which is larger than the array bound will result in a runtime ``REVERT``.\n\n.. note::\n    To keep code easy to reason about, modifying an array while using it as an iterator is disallowed by the language. For instance, the following usage is not allowed:\n\n    .. code-block:: python\n\n        for item in self.my_array:\n            self.my_array[0] = item\n\nIn the ABI, they are represented as ``_Type[]``. For instance, ``DynArray[int128, 3]`` gets represented as ``int128[]``, and ``DynArray[DynArray[int128, 3], 3]`` gets represented as ``int128[][]``.\n\n.. note::\n    Defining a dynamic array in storage whose size is significantly larger than ``2**64`` can result in security vulnerabilities due to risk of overflow.\n\n\n.. _types-struct:\n\nStructs\n-------\n\nStructs are custom defined types that can group several variables.\n\nStruct types can be used inside mappings and arrays. Structs can contain arrays and other structs, but not mappings.\n\nStruct members can be accessed via ``struct.argname``.\n\n.. code-block:: python\n\n    # Defining a struct\n    struct MyStruct:\n        value1: int128\n        value2: decimal\n\n    # Declaring a struct variable\n    exampleStruct: MyStruct = MyStruct({value1: 1, value2: 2.0})\n\n    # Accessing a value\n    exampleStruct.value1 = 1\n\n.. index:: !mapping\n\nMappings\n--------\n\nMappings are `hash tables <https://en.wikipedia.org/wiki/Hash_table>`_ that are virtually initialized such that every possible key exists and is mapped to a value whose byte-representation is all zeros: a type's :ref:`default value <types-initial>`.\n\nThe key data is not stored in a mapping. Instead, its ``keccak256`` hash is used to look up a value. For this reason, mappings do not have a length or a concept of a key or value being \"set\".\n\nMapping types are declared as ``HashMap[_KeyType, _ValueType]``.\n\n* ``_KeyType`` can be any base or bytes type. Mappings, arrays or structs are not supported as key types.\n* ``_ValueType`` can actually be any type, including mappings.\n\n.. note::\n    Mappings are only allowed as state variables.\n\n.. code-block:: python\n\n   # Defining a mapping\n   exampleMapping: HashMap[int128, decimal]\n\n   # Accessing a value\n   exampleMapping[0] = 10.1\n\n.. note::\n\n    Mappings have no concept of length and so cannot be iterated over.\n\n.. index:: !initial\n\n.. _types-initial:\n\nInitial Values\n==============\n\nUnlike most programming languages, Vyper does not have a concept of ``null``. Instead, every variable type has a default value. To check if a variable is empty, you must compare it to the default value for its given type.\n\nTo reset a variable to its default value, assign to it the built-in ``empty()`` function which constructs a zero value for that type.\n\n.. note::\n\n    Memory variables must be assigned a value at the time they are declared.\n\nHere you can find a list of all types and default values:\n\n=========== ======================================================================\nType        Default Value\n=========== ======================================================================\n``address`` ``0x0000000000000000000000000000000000000000``\n``bool``    ``False``\n``bytes32`` ``0x0000000000000000000000000000000000000000000000000000000000000000``\n``decimal`` ``0.0``\n``uint8``   ``0``\n``int128``  ``0``\n``int256``  ``0``\n``uint256`` ``0``\n=========== ======================================================================\n\n.. note::\n    In ``Bytes``, the array starts with the bytes all set to ``'\\x00'``.\n\n.. note::\n    In reference types, all the type's members are set to their initial values.\n\n\n.. _type_conversions:\n\nType Conversions\n================\n\nAll type conversions in Vyper must be made explicitly using the built-in ``convert(a: atype, btype)`` function. Type conversions in Vyper are designed to be safe and intuitive. All type conversions will check that the input is in bounds for the output type. The general principles are:\n\n* Except for conversions involving decimals and bools, the input is bit-for-bit preserved.\n* Conversions to bool map all nonzero inputs to 1.\n* When converting from decimals to integers, the input is truncated towards zero.\n* ``address`` types are treated as ``uint160``, except conversions with signed integers and decimals are not allowed.\n* Converting between right-padded (``bytes``, ``Bytes``, ``String``) and left-padded types, results in a rotation to convert the padding. For instance, converting from ``bytes20`` to ``address`` would result in rotating the input by 12 bytes to the right.\n* Converting between signed and unsigned integers reverts if the input is negative.\n* Narrowing conversions (e.g., ``int256 -> int128``) check that the input is in bounds for the output type.\n* Converting between bytes and int types results in sign-extension if the output type is signed. For instance, converting ``0xff`` (``bytes1``) to ``int8`` returns ``-1``.\n* Converting between bytes and int types which have different sizes follows the rule of going through the closest integer type, first. For instance, ``bytes1 -> int16`` is like ``bytes1 -> int8 -> int16`` (signextend, then widen). ``uint8 -> bytes20`` is like ``uint8 -> uint160 -> bytes20`` (rotate left 12 bytes).\n* Enums can be converted to and from ``uint256`` only.\n\nA small Python reference implementation is maintained as part of Vyper's test suite, it can be found `here <https://github.com/vyperlang/vyper/blob/c4c6afd07801a0cc0038cdd4007cc43860c54193/tests/parser/functions/test_convert.py#L318>`_. The motivation and more detailed discussion of the rules can be found `here <https://github.com/vyperlang/vyper/issues/2507>`_.\n", "import pytest\n\nfrom vyper.compiler import compile_code\nfrom vyper.exceptions import StorageLayoutException\n\n\ndef test_storage_layout_overrides():\n    code = \"\"\"\na: uint256\nb: uint256\"\"\"\n\n    storage_layout_overrides = {\n        \"a\": {\"type\": \"uint256\", \"slot\": 1},\n        \"b\": {\"type\": \"uint256\", \"slot\": 0},\n    }\n\n    expected_output = {\"storage_layout\": storage_layout_overrides, \"code_layout\": {}}\n\n    out = compile_code(\n        code, output_formats=[\"layout\"], storage_layout_override=storage_layout_overrides\n    )\n\n    assert out[\"layout\"] == expected_output\n\n\ndef test_storage_layout_for_more_complex():\n    code = \"\"\"\nfoo: HashMap[address, uint256]\n\n@external\n@nonreentrant(\"foo\")\ndef public_foo1():\n    pass\n\n@external\n@nonreentrant(\"foo\")\ndef public_foo2():\n    pass\n\n\n@internal\n@nonreentrant(\"bar\")\ndef _bar():\n    pass\n\n# mix it up a little\nbaz: Bytes[65]\nbar: uint256\n\n@external\n@nonreentrant(\"bar\")\ndef public_bar():\n    pass\n\n@external\n@nonreentrant(\"foo\")\ndef public_foo3():\n    pass\n    \"\"\"\n\n    storage_layout_override = {\n        \"nonreentrant.foo\": {\"type\": \"nonreentrant lock\", \"slot\": 8},\n        \"nonreentrant.bar\": {\"type\": \"nonreentrant lock\", \"slot\": 7},\n        \"foo\": {\"type\": \"HashMap[address, uint256]\", \"slot\": 1},\n        \"baz\": {\"type\": \"Bytes[65]\", \"slot\": 2},\n        \"bar\": {\"type\": \"uint256\", \"slot\": 6},\n    }\n\n    expected_output = {\"storage_layout\": storage_layout_override, \"code_layout\": {}}\n\n    out = compile_code(\n        code, output_formats=[\"layout\"], storage_layout_override=storage_layout_override\n    )\n\n    assert out[\"layout\"] == expected_output\n\n\ndef test_simple_collision():\n    code = \"\"\"\nname: public(String[64])\nsymbol: public(String[32])\"\"\"\n\n    storage_layout_override = {\n        \"name\": {\"slot\": 0, \"type\": \"String[64]\"},\n        \"symbol\": {\"slot\": 1, \"type\": \"String[32]\"},\n    }\n\n    with pytest.raises(\n        StorageLayoutException,\n        match=\"Storage collision! Tried to assign 'symbol' to slot 1\"\n        \" but it has already been reserved by 'name'\",\n    ):\n        compile_code(\n            code, output_formats=[\"layout\"], storage_layout_override=storage_layout_override\n        )\n\n\ndef test_overflow():\n    code = \"\"\"\nx: uint256[2]\n    \"\"\"\n\n    storage_layout_override = {\"x\": {\"slot\": 2**256 - 1, \"type\": \"uint256[2]\"}}\n\n    with pytest.raises(\n        StorageLayoutException, match=f\"Invalid storage slot for var x, out of bounds: {2**256}\\n\"\n    ):\n        compile_code(\n            code, output_formats=[\"layout\"], storage_layout_override=storage_layout_override\n        )\n\n\ndef test_incomplete_overrides():\n    code = \"\"\"\nname: public(String[64])\nsymbol: public(String[32])\"\"\"\n\n    storage_layout_override = {\"name\": {\"slot\": 0, \"type\": \"String[64]\"}}\n\n    with pytest.raises(\n        StorageLayoutException,\n        match=\"Could not find storage_slot for symbol. \"\n        \"Have you used the correct storage layout file?\",\n    ):\n        compile_code(\n            code, output_formats=[\"layout\"], storage_layout_override=storage_layout_override\n        )\n", "import pytest\n\nfrom vyper.exceptions import StorageLayoutException\n\ncode = \"\"\"\n\nstruct StructOne:\n    a: String[33]\n    b: uint256[3]\n\nstruct StructTwo:\n    a: Bytes[5]\n    b: int128[2]\n    c: String[64]\n\na: public(StructOne)\nb: public(uint256[2])\nc: public(Bytes[32])\nd: public(int128[4])\nfoo: public(HashMap[uint256, uint256[3]])\ndyn_array: DynArray[uint256, 3]\ne: public(String[47])\nf: public(int256[1])\ng: public(StructTwo[2])\nh: public(int256[1])\n\n\n@external\ndef __init__():\n    self.a = StructOne({a: \"ok\", b: [4,5,6]})\n    self.b = [7, 8]\n    self.c = b\"thisisthirtytwobytesokhowdoyoudo\"\n    self.d = [-1, -2, -3, -4]\n    self.e = \"A realllllly long string but we wont use it all\"\n    self.f = [33]\n    self.g = [\n        StructTwo({a: b\"hello\", b: [-66, 420], c: \"another string\"}),\n        StructTwo({\n            a: b\"gbye\",\n            b: [1337, 888],\n            c: \"whatifthisstringtakesuptheentirelengthwouldthatbesobadidothinkso\"\n        })\n    ]\n    self.dyn_array = [1, 2, 3]\n    self.h =  [123456789]\n    self.foo[0] = [987, 654, 321]\n    self.foo[1] = [123, 456, 789]\n\n@external\n@nonreentrant('lock')\ndef with_lock():\n    pass\n\n\n@external\n@nonreentrant('otherlock')\ndef with_other_lock():\n    pass\n\"\"\"\n\n\ndef test_storage_slots(get_contract):\n    c = get_contract(code)\n    assert c.a() == (\"ok\", [4, 5, 6])\n    assert [c.b(i) for i in range(2)] == [7, 8]\n    assert c.c() == b\"thisisthirtytwobytesokhowdoyoudo\"\n    assert [c.d(i) for i in range(4)] == [-1, -2, -3, -4]\n    assert c.e() == \"A realllllly long string but we wont use it all\"\n    assert c.f(0) == 33\n    assert c.g(0) == (b\"hello\", [-66, 420], \"another string\")\n    assert c.g(1) == (\n        b\"gbye\",\n        [1337, 888],\n        \"whatifthisstringtakesuptheentirelengthwouldthatbesobadidothinkso\",\n    )\n    assert [c.foo(0, i) for i in range(3)] == [987, 654, 321]\n    assert [c.foo(1, i) for i in range(3)] == [123, 456, 789]\n    assert c.h(0) == 123456789\n\n\ndef test_reentrancy_lock(get_contract):\n    c = get_contract(code)\n\n    # if re-entrancy locks are incorrectly placed within storage, these\n    # calls will either revert or correupt the data that we read later\n    c.with_lock()\n    c.with_other_lock()\n\n    assert c.a() == (\"ok\", [4, 5, 6])\n    assert [c.b(i) for i in range(2)] == [7, 8]\n    assert c.c() == b\"thisisthirtytwobytesokhowdoyoudo\"\n    assert [c.d(i) for i in range(4)] == [-1, -2, -3, -4]\n    assert c.e() == \"A realllllly long string but we wont use it all\"\n    assert c.f(0) == 33\n    assert c.g(0) == (b\"hello\", [-66, 420], \"another string\")\n    assert c.g(1) == (\n        b\"gbye\",\n        [1337, 888],\n        \"whatifthisstringtakesuptheentirelengthwouldthatbesobadidothinkso\",\n    )\n    assert [c.foo(0, i) for i in range(3)] == [987, 654, 321]\n    assert [c.foo(1, i) for i in range(3)] == [123, 456, 789]\n    assert c.h(0) == 123456789\n\n\ndef test_allocator_overflow(get_contract):\n    code = \"\"\"\nx: uint256\ny: uint256[max_value(uint256)]\n    \"\"\"\n    with pytest.raises(\n        StorageLayoutException,\n        match=f\"Invalid storage slot for var y, tried to allocate slots 1 through {2**256}\\n\",\n    ):\n        get_contract(code)\n", "# TODO this doesn't really belong in \"validation\"\nimport math\nfrom typing import Dict, List\n\nfrom vyper import ast as vy_ast\nfrom vyper.exceptions import StorageLayoutException\nfrom vyper.semantics.analysis.base import CodeOffset, StorageSlot\nfrom vyper.typing import StorageLayout\nfrom vyper.utils import ceil32\n\n\ndef set_data_positions(\n    vyper_module: vy_ast.Module, storage_layout_overrides: StorageLayout = None\n) -> StorageLayout:\n    \"\"\"\n    Parse the annotated Vyper AST, determine data positions for all variables,\n    and annotate the AST nodes with the position data.\n\n    Arguments\n    ---------\n    vyper_module : vy_ast.Module\n        Top-level Vyper AST node that has already been annotated with type data.\n    \"\"\"\n    code_offsets = set_code_offsets(vyper_module)\n    storage_slots = (\n        set_storage_slots_with_overrides(vyper_module, storage_layout_overrides)\n        if storage_layout_overrides is not None\n        else set_storage_slots(vyper_module)\n    )\n\n    return {\"storage_layout\": storage_slots, \"code_layout\": code_offsets}\n\n\nclass StorageAllocator:\n    \"\"\"\n    Keep track of which storage slots have been used. If there is a collision of\n    storage slots, this will raise an error and fail to compile\n    \"\"\"\n\n    def __init__(self):\n        self.occupied_slots: Dict[int, str] = {}\n\n    def reserve_slot_range(self, first_slot: int, n_slots: int, var_name: str) -> None:\n        \"\"\"\n        Reserves `n_slots` storage slots, starting at slot `first_slot`\n        This will raise an error if a storage slot has already been allocated.\n        It is responsibility of calling function to ensure first_slot is an int\n        \"\"\"\n        list_to_check = [x + first_slot for x in range(n_slots)]\n        self._reserve_slots(list_to_check, var_name)\n\n    def _reserve_slots(self, slots: List[int], var_name: str) -> None:\n        for slot in slots:\n            self._reserve_slot(slot, var_name)\n\n    def _reserve_slot(self, slot: int, var_name: str) -> None:\n        if slot < 0 or slot >= 2**256:\n            raise StorageLayoutException(\n                f\"Invalid storage slot for var {var_name}, out of bounds: {slot}\"\n            )\n        if slot in self.occupied_slots:\n            collided_var = self.occupied_slots[slot]\n            raise StorageLayoutException(\n                f\"Storage collision! Tried to assign '{var_name}' to slot {slot} but it has \"\n                f\"already been reserved by '{collided_var}'\"\n            )\n        self.occupied_slots[slot] = var_name\n\n\ndef set_storage_slots_with_overrides(\n    vyper_module: vy_ast.Module, storage_layout_overrides: StorageLayout\n) -> StorageLayout:\n    \"\"\"\n    Parse module-level Vyper AST to calculate the layout of storage variables.\n    Returns the layout as a dict of variable name -> variable info\n    \"\"\"\n\n    ret: Dict[str, Dict] = {}\n    reserved_slots = StorageAllocator()\n\n    # Search through function definitions to find non-reentrant functions\n    for node in vyper_module.get_children(vy_ast.FunctionDef):\n        type_ = node._metadata[\"type\"]\n\n        # Ignore functions without non-reentrant\n        if type_.nonreentrant is None:\n            continue\n\n        variable_name = f\"nonreentrant.{type_.nonreentrant}\"\n\n        # re-entrant key was already identified\n        if variable_name in ret:\n            _slot = ret[variable_name][\"slot\"]\n            type_.set_reentrancy_key_position(StorageSlot(_slot))\n            continue\n\n        # Expect to find this variable within the storage layout override\n        if variable_name in storage_layout_overrides:\n            reentrant_slot = storage_layout_overrides[variable_name][\"slot\"]\n            # Ensure that this slot has not been used, and prevents other storage variables\n            # from using the same slot\n            reserved_slots.reserve_slot_range(reentrant_slot, 1, variable_name)\n\n            type_.set_reentrancy_key_position(StorageSlot(reentrant_slot))\n\n            ret[variable_name] = {\"type\": \"nonreentrant lock\", \"slot\": reentrant_slot}\n        else:\n            raise StorageLayoutException(\n                f\"Could not find storage_slot for {variable_name}. \"\n                \"Have you used the correct storage layout file?\",\n                node,\n            )\n\n    # Iterate through variables\n    for node in vyper_module.get_children(vy_ast.VariableDecl):\n        # Ignore immutable parameters\n        if node.get(\"annotation.func.id\") == \"immutable\":\n            continue\n\n        varinfo = node.target._metadata[\"varinfo\"]\n\n        # Expect to find this variable within the storage layout overrides\n        if node.target.id in storage_layout_overrides:\n            var_slot = storage_layout_overrides[node.target.id][\"slot\"]\n            storage_length = varinfo.typ.storage_size_in_words\n            # Ensure that all required storage slots are reserved, and prevents other variables\n            # from using these slots\n            reserved_slots.reserve_slot_range(var_slot, storage_length, node.target.id)\n            varinfo.set_position(StorageSlot(var_slot))\n\n            ret[node.target.id] = {\"type\": str(varinfo.typ), \"slot\": var_slot}\n        else:\n            raise StorageLayoutException(\n                f\"Could not find storage_slot for {node.target.id}. \"\n                \"Have you used the correct storage layout file?\",\n                node,\n            )\n\n    return ret\n\n\nclass SimpleStorageAllocator:\n    def __init__(self, starting_slot: int = 0):\n        self._slot = starting_slot\n\n    def allocate_slot(self, n, var_name):\n        ret = self._slot\n        if self._slot + n >= 2**256:\n            raise StorageLayoutException(\n                f\"Invalid storage slot for var {var_name}, tried to allocate\"\n                f\" slots {self._slot} through {self._slot + n}\"\n            )\n        self._slot += n\n        return ret\n\n\ndef set_storage_slots(vyper_module: vy_ast.Module) -> StorageLayout:\n    \"\"\"\n    Parse module-level Vyper AST to calculate the layout of storage variables.\n    Returns the layout as a dict of variable name -> variable info\n    \"\"\"\n    # Allocate storage slots from 0\n    # note storage is word-addressable, not byte-addressable\n    allocator = SimpleStorageAllocator()\n\n    ret: Dict[str, Dict] = {}\n\n    for node in vyper_module.get_children(vy_ast.FunctionDef):\n        type_ = node._metadata[\"type\"]\n        if type_.nonreentrant is None:\n            continue\n\n        variable_name = f\"nonreentrant.{type_.nonreentrant}\"\n\n        # a nonreentrant key can appear many times in a module but it\n        # only takes one slot. after the first time we see it, do not\n        # increment the storage slot.\n        if variable_name in ret:\n            _slot = ret[variable_name][\"slot\"]\n            type_.set_reentrancy_key_position(StorageSlot(_slot))\n            continue\n\n        # TODO use one byte - or bit - per reentrancy key\n        # requires either an extra SLOAD or caching the value of the\n        # location in memory at entrance\n        slot = allocator.allocate_slot(1, variable_name)\n\n        type_.set_reentrancy_key_position(StorageSlot(slot))\n\n        # TODO this could have better typing but leave it untyped until\n        # we nail down the format better\n        ret[variable_name] = {\"type\": \"nonreentrant lock\", \"slot\": slot}\n\n\n    for node in vyper_module.get_children(vy_ast.VariableDecl):\n        # skip non-storage variables\n        if node.is_constant or node.is_immutable:\n            continue\n\n        varinfo = node.target._metadata[\"varinfo\"]\n        type_ = varinfo.typ\n\n        # CMC 2021-07-23 note that HashMaps get assigned a slot here.\n        # I'm not sure if it's safe to avoid allocating that slot\n        # for HashMaps because downstream code might use the slot\n        # ID as a salt.\n        n_slots = type_.storage_size_in_words\n        slot = allocator.allocate_slot(n_slots, node.target.id)\n\n        varinfo.set_position(StorageSlot(slot))\n\n        # this could have better typing but leave it untyped until\n        # we understand the use case better\n        ret[node.target.id] = {\"type\": str(type_), \"slot\": slot}\n\n    return ret\n\n\ndef set_calldata_offsets(fn_node: vy_ast.FunctionDef) -> None:\n    pass\n\n\ndef set_memory_offsets(fn_node: vy_ast.FunctionDef) -> None:\n    pass\n\n\ndef set_code_offsets(vyper_module: vy_ast.Module) -> Dict:\n    ret = {}\n    offset = 0\n\n    for node in vyper_module.get_children(vy_ast.VariableDecl, filters={\"is_immutable\": True}):\n        varinfo = node.target._metadata[\"varinfo\"]\n        type_ = varinfo.typ\n        varinfo.set_position(CodeOffset(offset))\n\n        len_ = ceil32(type_.size_in_bytes)\n\n        # this could have better typing but leave it untyped until\n        # we understand the use case better\n        ret[node.target.id] = {\"type\": str(type_), \"offset\": offset, \"length\": len_}\n\n        offset += len_\n\n    return ret\n", "from typing import Any, Dict, Optional, Tuple, Union\n\nfrom vyper import ast as vy_ast\nfrom vyper.abi_types import ABI_DynamicArray, ABI_StaticArray, ABI_Tuple, ABIType\nfrom vyper.exceptions import ArrayIndexException, InvalidType, StructureException\nfrom vyper.semantics.types.base import VyperType\nfrom vyper.semantics.types.primitives import IntegerT\nfrom vyper.semantics.types.shortcuts import UINT256_T\nfrom vyper.semantics.types.utils import get_index_value, type_from_annotation\n\n\nclass _SubscriptableT(VyperType):\n    \"\"\"\n    Base class for subscriptable types such as arrays and mappings.\n\n    Attributes\n    ----------\n    key_type: VyperType\n        Type representing the index for this object.\n    value_type : VyperType\n        Type representing the value(s) contained in this object.\n    \"\"\"\n\n    def __init__(self, key_type: VyperType, value_type: VyperType) -> None:\n        super().__init__()\n        self.key_type = key_type\n        self.value_type = value_type\n\n    @property\n    def getter_signature(self) -> Tuple[Tuple, Optional[VyperType]]:\n        child_keys, return_type = self.value_type.getter_signature\n        return (self.key_type,) + child_keys, return_type\n\n    def validate_index_type(self, node):\n        # TODO: break this cycle\n        from vyper.semantics.analysis.utils import validate_expected_type\n\n        validate_expected_type(node, self.key_type)\n\n\nclass HashMapT(_SubscriptableT):\n    _id = \"HashMap\"\n\n    _equality_attrs = (\"key_type\", \"value_type\")\n\n    def __repr__(self):\n        return f\"HashMap[{self.key_type}, {self.value_type}]\"\n\n    # TODO not sure this is used?\n    def compare_type(self, other):\n        return (\n            super().compare_type(other)\n            and self.key_type == other.key_type\n            and self.value_type == other.value_type\n        )\n\n    def get_subscripted_type(self, node):\n        return self.value_type\n\n    @classmethod\n    def from_annotation(cls, node: Union[vy_ast.Name, vy_ast.Call, vy_ast.Subscript]) -> \"HashMapT\":\n        if (\n            not isinstance(node, vy_ast.Subscript)\n            or not isinstance(node.slice, vy_ast.Index)\n            or not isinstance(node.slice.value, vy_ast.Tuple)\n            or len(node.slice.value.elements) != 2\n        ):\n            raise StructureException(\n                (\n                    \"HashMap must be defined with a key type and a value type, \"\n                    \"e.g. my_hashmap: HashMap[k, v]\"\n                ),\n                node,\n            )\n        # if location != DataLocation.STORAGE or is_immutable:\n        #    raise StructureException(\"HashMap can only be declared as a storage variable\", node)\n\n        k_ast, v_ast = node.slice.value.elements\n        key_type = type_from_annotation(k_ast)\n        if not key_type._as_hashmap_key:\n            raise InvalidType(\"can only use primitive types as HashMap key!\", k_ast)\n\n        value_type = type_from_annotation(v_ast)\n\n        return cls(key_type, value_type)\n\n\nclass _SequenceT(_SubscriptableT):\n    \"\"\"\n    Private base class for sequence types (i.e., index is an int)\n\n    Arguments\n    ---------\n    length : int\n        Number of items in the type.\n    \"\"\"\n\n    _equality_attrs: tuple = (\"value_type\", \"length\")\n\n    _is_array_type: bool = True\n\n    def __init__(self, value_type: VyperType, length: int):\n        if not 0 < length < 2**256:\n            raise InvalidType(\"Array length is invalid\")\n\n        if length >= 2**64:\n            warnings.warn(\"Use of large arrays can be unsafe!\")\n\n        super().__init__(UINT256_T, value_type)\n        self.length = length\n\n    @property\n    def count(self):\n        \"\"\"\n        Alias for API compatibility\n        \"\"\"\n        return self.length\n\n    def validate_index_type(self, node):\n        # TODO break this cycle\n        from vyper.semantics.analysis.utils import validate_expected_type\n\n        if isinstance(node, vy_ast.Int):\n            if node.value < 0:\n                raise ArrayIndexException(\"Vyper does not support negative indexing\", node)\n            if node.value >= self.length:\n                raise ArrayIndexException(\"Index out of range\", node)\n\n        validate_expected_type(node, IntegerT.any())\n\n    def get_subscripted_type(self, node):\n        return self.value_type\n\n\n# override value at `k` with `val`, but inserting it before other keys\n# for formatting reasons. besides insertion order, equivalent to\n# `{k: val, **xs}`\ndef _set_first_key(xs: Dict[str, Any], k: str, val: Any) -> dict:\n    xs.pop(k, None)\n    return {k: val, **xs}\n\n\nclass SArrayT(_SequenceT):\n    \"\"\"\n    Static array type\n    \"\"\"\n\n    def __init__(self, value_type: VyperType, length: int) -> None:\n        super().__init__(value_type, length)\n\n    def __repr__(self):\n        return f\"{self.value_type}[{self.length}]\"\n\n    @property\n    def _as_array(self):\n        # a static array is arrayable if its value_type is arrayble.\n        return self.value_type._as_array\n\n    @property\n    def abi_type(self) -> ABIType:\n        return ABI_StaticArray(self.value_type.abi_type, self.length)\n\n    def to_abi_arg(self, name: str = \"\") -> Dict[str, Any]:\n        ret = self.value_type.to_abi_arg()\n        # modify the child name in place\n        ret[\"type\"] += f\"[{self.length}]\"\n        return _set_first_key(ret, \"name\", name)\n\n    # TODO rename to `memory_bytes_required`\n    @property\n    def size_in_bytes(self):\n        return self.value_type.size_in_bytes * self.length\n\n    @property\n    def subtype(self):\n        \"\"\"\n        Alias for API compatibility with codegen\n        \"\"\"\n        return self.value_type\n\n    def get_subscripted_type(self, node):\n        return self.value_type\n\n    def compare_type(self, other):\n        if not isinstance(self, type(other)):\n            return False\n        if self.length != other.length:\n            return False\n        return self.value_type.compare_type(other.value_type)\n\n    @classmethod\n    def from_annotation(cls, node: vy_ast.Subscript) -> \"SArrayT\":\n        if not isinstance(node, vy_ast.Subscript) or not isinstance(node.slice, vy_ast.Index):\n            raise StructureException(\n                \"Arrays must be defined with base type and length, e.g. bool[5]\", node\n            )\n\n        value_type = type_from_annotation(node.value)\n\n        if not value_type._as_array:\n            raise StructureException(f\"arrays of {value_type} are not allowed!\")\n\n        # note: validates index is a vy_ast.Int.\n        length = get_index_value(node.slice)\n        return cls(value_type, length)\n\n\nclass DArrayT(_SequenceT):\n    \"\"\"\n    Dynamic array type\n    \"\"\"\n\n    _valid_literal = (vy_ast.List,)\n    _as_array = True\n    _id = \"DynArray\"\n\n    def __init__(self, value_type: VyperType, length: int) -> None:\n        super().__init__(value_type, length)\n\n        from vyper.semantics.types.function import MemberFunctionT\n\n        self.add_member(\"append\", MemberFunctionT(self, \"append\", [self.value_type], None, True))\n        self.add_member(\"pop\", MemberFunctionT(self, \"pop\", [], self.value_type, True))\n\n    def __repr__(self):\n        return f\"DynArray[{self.value_type}, {self.length}]\"\n\n    @property\n    def subtype(self):\n        \"\"\"\n        Alias for backwards compatibility.\n        \"\"\"\n        return self.value_type\n\n    @property\n    def count(self):\n        \"\"\"\n        Alias for backwards compatibility.\n        \"\"\"\n        return self.length\n\n    @property\n    def abi_type(self) -> ABIType:\n        return ABI_DynamicArray(self.value_type.abi_type, self.length)\n\n    def to_abi_arg(self, name: str = \"\") -> Dict[str, Any]:\n        ret = self.value_type.to_abi_arg()\n        # modify the child name in place.\n        ret[\"type\"] += \"[]\"\n        return _set_first_key(ret, \"name\", name)\n\n    # TODO rename me to memory_bytes_required\n    @property\n    def size_in_bytes(self):\n        # one length word + size of the array items\n        return 32 + self.value_type.size_in_bytes * self.length\n\n    def compare_type(self, other):\n        # TODO allow static array to be assigned to dyn array?\n        # if not isinstance(other, (DArrayT, SArrayT)):\n        if not isinstance(self, type(other)):\n            return False\n        if self.length < other.length:\n            return False\n        return self.value_type.compare_type(other.value_type)\n\n    @classmethod\n    def from_annotation(cls, node: vy_ast.Subscript) -> \"DArrayT\":\n        if (\n            not isinstance(node, vy_ast.Subscript)\n            or not isinstance(node.slice, vy_ast.Index)\n            or not isinstance(node.slice.value, vy_ast.Tuple)\n            or not isinstance(node.slice.value.elements[1], vy_ast.Int)\n            or len(node.slice.value.elements) != 2\n        ):\n            raise StructureException(\n                \"DynArray must be defined with base type and max length, e.g. DynArray[bool, 5]\",\n                node,\n            )\n\n        value_type = type_from_annotation(node.slice.value.elements[0])\n        if not value_type._as_darray:\n            raise StructureException(f\"Arrays of {value_type} are not allowed\", node)\n\n        max_length = node.slice.value.elements[1].value\n        return cls(value_type, max_length)\n\n\nclass TupleT(VyperType):\n    \"\"\"\n    Tuple type definition.\n\n    This class is used to represent multiple return values from\n    functions.\n    \"\"\"\n\n    _equality_attrs = (\"members\",)\n\n    def __init__(self, member_types: Tuple[VyperType, ...]) -> None:\n        super().__init__()\n        self.member_types = member_types\n        self.key_type = UINT256_T  # API Compatibility\n\n    def __repr__(self):\n        return \"(\" + \", \".join(repr(t) for t in self.member_types) + \")\"\n\n    @property\n    def length(self):\n        return len(self.member_types)\n\n    def tuple_members(self):\n        return [v for (_k, v) in self.tuple_items()]\n\n    def tuple_keys(self):\n        return [k for (k, _v) in self.tuple_items()]\n\n    def tuple_items(self):\n        return list(enumerate(self.member_types))\n\n    @classmethod\n    def from_annotation(cls, node: vy_ast.Tuple) -> VyperType:\n        values = node.elements\n        types = tuple(type_from_annotation(v) for v in values)\n        return cls(types)\n\n    @property\n    def abi_type(self) -> ABIType:\n        return ABI_Tuple([t.abi_type for t in self.member_types])\n\n    def to_abi_arg(self, name: str = \"\") -> dict:\n        components = [t.to_abi_arg() for t in self.member_types]\n        return {\"name\": name, \"type\": \"tuple\", \"components\": components}\n\n    @property\n    def size_in_bytes(self):\n        return sum(i.size_in_bytes for i in self.member_types)\n\n    def validate_index_type(self, node):\n        if not isinstance(node, vy_ast.Int):\n            raise InvalidType(\"Tuple indexes must be literals\", node)\n        if node.value < 0:\n            raise ArrayIndexException(\"Vyper does not support negative indexing\", node)\n        if node.value >= self.length:\n            raise ArrayIndexException(\"Index out of range\", node)\n\n    def get_subscripted_type(self, node):\n        return self.member_types[node.value]\n\n    def compare_type(self, other):\n        if not isinstance(self, type(other)):\n            return False\n        if self.length != other.length:\n            return False\n        return all(a.compare_type(b) for (a, b) in zip(self.member_types, other.member_types))\n"], "filenames": ["docs/types.rst", "tests/cli/outputs/test_storage_layout_overrides.py", "tests/functional/test_storage_slots.py", "vyper/semantics/analysis/data_positions.py", "vyper/semantics/types/subscriptable.py"], "buggy_code_start_loc": [522, 97, 0, 8, 105], "buggy_code_end_loc": [562, 97, 99, 220, 105], "fixing_code_start_loc": [523, 98, 1, 9, 106], "fixing_code_end_loc": [570, 113, 116, 237, 109], "type": "CWE-193", "message": "Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). Contracts containing large arrays might underallocate the number of slots they need by 1. Prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`. The intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. Roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed by 1. If `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed by 1. This issue is patched in version 0.3.8.", "other": {"cve": {"id": "CVE-2023-46247", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-13T20:15:49.360", "lastModified": "2023-12-19T02:27:51.333", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine (EVM). Contracts containing large arrays might underallocate the number of slots they need by 1. Prior to v0.3.8, the calculation to determine how many slots a storage variable needed used `math.ceil(type_.size_in_bytes / 32)`. The intermediate floating point step can produce a rounding error if there are enough bits set in the IEEE-754 mantissa. Roughly speaking, if `type_.size_in_bytes` is large (> 2**46), and slightly less than a power of 2, the calculation can overestimate how many slots are needed by 1. If `type_.size_in_bytes` is slightly more than a power of 2, the calculation can underestimate how many slots are needed by 1. This issue is patched in version 0.3.8."}, {"lang": "es", "value": "Vyper es un lenguaje de contrato inteligente pit\u00f3nico para la m\u00e1quina virtual Ethereum (EVM). Los contratos que contienen matrices grandes podr\u00edan subasignar la cantidad de ranuras que necesitan en 1. Antes de v0.3.8, el c\u00e1lculo para determinar cu\u00e1ntas ranuras necesitaba una variable de almacenamiento usaba `math.ceil(type_.size_in_bytes / 32)`. El paso de punto flotante intermedio puede producir un error de redondeo si hay suficientes bits configurados en la mantisa IEEE-754. En t\u00e9rminos generales, si `type_.size_in_bytes` es grande (&gt; 2**46) y ligeramente menor que una potencia de 2, el c\u00e1lculo puede sobrestimar cu\u00e1ntas ranuras se necesitan por 1. Si `type_.size_in_bytes` es ligeramente mayor que una potencia de 2, el c\u00e1lculo puede subestimar cu\u00e1ntas ranuras se necesitan por 1. Este problema se solucion\u00f3 en la versi\u00f3n 0.3.8."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-193"}, {"lang": "en", "value": "CWE-682"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vyperlang:vyper:*:*:*:*:*:python:*:*", "versionEndExcluding": "0.3.8", "matchCriteriaId": "CE735083-742D-4FFC-922C-71E242E471F3"}]}]}], "references": [{"url": "https://github.com/vyperlang/vyper/blob/6020b8bbf66b062d299d87bc7e4eddc4c9d1c157/vyper/semantics/validation/data_positions.py#L197", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/vyperlang/vyper/security/advisories/GHSA-6m97-7527-mh74", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vyperlang/vyper/commit/0bb7203b584e771b23536ba065a6efda457161bb"}}