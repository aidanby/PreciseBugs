{"buggy_code": ["/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * I/O Stream Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <assert.h>\n#if defined(HAVE_FCNTL_H)\n#include <fcntl.h>\n#endif\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#if defined(HAVE_UNISTD_H)\n#include <unistd.h>\n#endif\n#if defined(WIN32) || defined(HAVE_IO_H)\n#include <io.h>\n#endif\n\n#include \"jasper/jas_types.h\"\n#include \"jasper/jas_stream.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_math.h\"\n\n/******************************************************************************\\\n* Local function prototypes.\n\\******************************************************************************/\n\nstatic int jas_strtoopenmode(const char *s);\nstatic void jas_stream_destroy(jas_stream_t *stream);\nstatic jas_stream_t *jas_stream_create(void);\nstatic void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,\n  int bufsize);\n\nstatic int mem_read(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic int mem_write(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic long mem_seek(jas_stream_obj_t *obj, long offset, int origin);\nstatic int mem_close(jas_stream_obj_t *obj);\n\nstatic int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic long sfile_seek(jas_stream_obj_t *obj, long offset, int origin);\nstatic int sfile_close(jas_stream_obj_t *obj);\n\nstatic int file_read(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic int file_write(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic long file_seek(jas_stream_obj_t *obj, long offset, int origin);\nstatic int file_close(jas_stream_obj_t *obj);\n\n/******************************************************************************\\\n* Local data.\n\\******************************************************************************/\n\nstatic jas_stream_ops_t jas_stream_fileops = {\n\tfile_read,\n\tfile_write,\n\tfile_seek,\n\tfile_close\n};\n\nstatic jas_stream_ops_t jas_stream_sfileops = {\n\tsfile_read,\n\tsfile_write,\n\tsfile_seek,\n\tsfile_close\n};\n\nstatic jas_stream_ops_t jas_stream_memops = {\n\tmem_read,\n\tmem_write,\n\tmem_seek,\n\tmem_close\n};\n\n/******************************************************************************\\\n* Code for opening and closing streams.\n\\******************************************************************************/\n\nstatic jas_stream_t *jas_stream_create()\n{\n\tjas_stream_t *stream;\n\n\tif (!(stream = jas_malloc(sizeof(jas_stream_t)))) {\n\t\treturn 0;\n\t}\n\tstream->openmode_ = 0;\n\tstream->bufmode_ = 0;\n\tstream->flags_ = 0;\n\tstream->bufbase_ = 0;\n\tstream->bufstart_ = 0;\n\tstream->bufsize_ = 0;\n\tstream->ptr_ = 0;\n\tstream->cnt_ = 0;\n\tstream->ops_ = 0;\n\tstream->obj_ = 0;\n\tstream->rwcnt_ = 0;\n\tstream->rwlimit_ = -1;\n\n\treturn stream;\n}\n\njas_stream_t *jas_stream_memopen(char *buf, int bufsize)\n{\n\tjas_stream_t *stream;\n\tjas_stream_memobj_t *obj;\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A stream associated with a memory buffer is always opened\n\tfor both reading and writing in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Since the stream data is already resident in memory, buffering\n\tis not necessary. */\n\t/* But... It still may be faster to use buffering anyways. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\t/* Select the operations for a memory stream. */\n\tstream->ops_ = &jas_stream_memops;\n\n\t/* Allocate memory for the underlying memory stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_memobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tstream->obj_ = (void *) obj;\n\n\t/* Initialize a few important members of the memory stream object. */\n\tobj->myalloc_ = 0;\n\tobj->buf_ = 0;\n\n\t/* If the buffer size specified is nonpositive, then the buffer\n\tis allocated internally and automatically grown as needed. */\n\tif (bufsize <= 0) {\n\t\tobj->bufsize_ = 1024;\n\t\tobj->growable_ = 1;\n\t} else {\n\t\tobj->bufsize_ = bufsize;\n\t\tobj->growable_ = 0;\n\t}\n\tif (buf) {\n\t\tobj->buf_ = (unsigned char *) buf;\n\t} else {\n\t\tobj->buf_ = jas_malloc(obj->bufsize_);\n\t\tobj->myalloc_ = 1;\n\t}\n\tif (!obj->buf_) {\n\t\tjas_stream_close(stream);\n\t\treturn 0;\n\t}\n\n\tif (bufsize > 0 && buf) {\n\t\t/* If a buffer was supplied by the caller and its length is positive,\n\t\t  make the associated buffer data appear in the stream initially. */\n\t\tobj->len_ = bufsize;\n\t} else {\n\t\t/* The stream is initially empty. */\n\t\tobj->len_ = 0;\n\t}\n\tobj->pos_ = 0;\n\t\n\treturn stream;\n}\n\njas_stream_t *jas_stream_fopen(const char *filename, const char *mode)\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\tint openflags;\n\n\t/* Allocate a stream object. */\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* Parse the mode string. */\n\tstream->openmode_ = jas_strtoopenmode(mode);\n\n\t/* Determine the correct flags to use for opening the file. */\n\tif ((stream->openmode_ & JAS_STREAM_READ) &&\n\t  (stream->openmode_ & JAS_STREAM_WRITE)) {\n\t\topenflags = O_RDWR;\n\t} else if (stream->openmode_ & JAS_STREAM_READ) {\n\t\topenflags = O_RDONLY;\n\t} else if (stream->openmode_ & JAS_STREAM_WRITE) {\n\t\topenflags = O_WRONLY;\n\t} else {\n\t\topenflags = 0;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_APPEND) {\n\t\topenflags |= O_APPEND;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_BINARY) {\n\t\topenflags |= O_BINARY;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_CREATE) {\n\t\topenflags |= O_CREAT | O_TRUNC;\n\t}\n\n\t/* Allocate space for the underlying file stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = -1;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = (void *) obj;\n\n\t/* Select the operations for a file stream object. */\n\tstream->ops_ = &jas_stream_fileops;\n\n\t/* Open the underlying file. */\n\tif ((obj->fd = open(filename, openflags, JAS_STREAM_PERMS)) < 0) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\n\t/* By default, use full buffering for this type of stream. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\treturn stream;\n}\n\njas_stream_t *jas_stream_freopen(const char *path, const char *mode, FILE *fp)\n{\n\tjas_stream_t *stream;\n\tint openflags;\n\n\t/* Eliminate compiler warning about unused variable. */\n\tpath = 0;\n\n\t/* Allocate a stream object. */\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* Parse the mode string. */\n\tstream->openmode_ = jas_strtoopenmode(mode);\n\n\t/* Determine the correct flags to use for opening the file. */\n\tif ((stream->openmode_ & JAS_STREAM_READ) &&\n\t  (stream->openmode_ & JAS_STREAM_WRITE)) {\n\t\topenflags = O_RDWR;\n\t} else if (stream->openmode_ & JAS_STREAM_READ) {\n\t\topenflags = O_RDONLY;\n\t} else if (stream->openmode_ & JAS_STREAM_WRITE) {\n\t\topenflags = O_WRONLY;\n\t} else {\n\t\topenflags = 0;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_APPEND) {\n\t\topenflags |= O_APPEND;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_BINARY) {\n\t\topenflags |= O_BINARY;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_CREATE) {\n\t\topenflags |= O_CREAT | O_TRUNC;\n\t}\n\n\tstream->obj_ = JAS_CAST(void *, fp);\n\n\t/* Select the operations for a file stream object. */\n\tstream->ops_ = &jas_stream_sfileops;\n\n\t/* By default, use full buffering for this type of stream. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\treturn stream;\n}\n\njas_stream_t *jas_stream_tmpfile()\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A temporary file stream is always opened for both reading and\n\twriting in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Allocate memory for the underlying temporary file object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = -1;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = obj;\n\n\t/* Choose a file name. */\n\ttmpnam(obj->pathname);\n\n\t/* Open the underlying file. */\n\tif ((obj->fd = open(obj->pathname, O_CREAT | O_EXCL | O_RDWR | O_TRUNC | O_BINARY,\n\t  JAS_STREAM_PERMS)) < 0) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\n\t/* Unlink the file so that it will disappear if the program\n\tterminates abnormally. */\n\t/* Under UNIX, one can unlink an open file and continue to do I/O\n\ton it.  Not all operating systems support this functionality, however.\n\tFor example, under Microsoft Windows the unlink operation will fail,\n\tsince the file is open. */\n\tif (unlink(obj->pathname)) {\n\t\t/* We will try unlinking the file again after it is closed. */\n\t\tobj->flags |= JAS_STREAM_FILEOBJ_DELONCLOSE;\n\t}\n\n\t/* Use full buffering. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\tstream->ops_ = &jas_stream_fileops;\n\n\treturn stream;\n}\n\njas_stream_t *jas_stream_fdopen(int fd, const char *mode)\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\n\t/* Allocate a stream object. */\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* Parse the mode string. */\n\tstream->openmode_ = jas_strtoopenmode(mode);\n\n#if defined(WIN32)\n\t/* Argh!!!  Someone ought to banish text mode (i.e., O_TEXT) to the\n\t  greatest depths of purgatory! */\n\t/* Ensure that the file descriptor is in binary mode, if the caller\n\t  has specified the binary mode flag.  Arguably, the caller ought to\n\t  take care of this, but text mode is a ugly wart anyways, so we save\n\t  the caller some grief by handling this within the stream library. */\n\t/* This ugliness is mainly for the benefit of those who run the\n\t  JasPer software under Windows from shells that insist on opening\n\t  files in text mode.  For example, in the Cygwin environment,\n\t  shells often open files in text mode when I/O redirection is\n\t  used.  Grr... */\n\tif (stream->openmode_ & JAS_STREAM_BINARY) {\n\t\tsetmode(fd, O_BINARY);\n\t}\n#endif\n\n\t/* Allocate space for the underlying file stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = fd;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = (void *) obj;\n\n\t/* Do not close the underlying file descriptor when the stream is\n\tclosed. */\n\tobj->flags |= JAS_STREAM_FILEOBJ_NOCLOSE;\n\n\t/* By default, use full buffering for this type of stream. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\t/* Select the operations for a file stream object. */\n\tstream->ops_ = &jas_stream_fileops;\n\n\treturn stream;\n}\n\nstatic void jas_stream_destroy(jas_stream_t *stream)\n{\n\t/* If the memory for the buffer was allocated with malloc, free\n\tthis memory. */\n\tif ((stream->bufmode_ & JAS_STREAM_FREEBUF) && stream->bufbase_) {\n\t\tjas_free(stream->bufbase_);\n\t\tstream->bufbase_ = 0;\n\t}\n\tjas_free(stream);\n}\n\nint jas_stream_close(jas_stream_t *stream)\n{\n\t/* Flush buffer if necessary. */\n\tjas_stream_flush(stream);\n\n\t/* Close the underlying stream object. */\n\t(*stream->ops_->close_)(stream->obj_);\n\n\tjas_stream_destroy(stream);\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Code for reading and writing streams.\n\\******************************************************************************/\n\nint jas_stream_getc_func(jas_stream_t *stream)\n{\n\tassert(stream->ptr_ - stream->bufbase_ <= stream->bufsize_ +\n\t  JAS_STREAM_MAXPUTBACK);\n\treturn jas_stream_getc_macro(stream);\n}\n\nint jas_stream_putc_func(jas_stream_t *stream, int c)\n{\n\tassert(stream->ptr_ - stream->bufstart_ <= stream->bufsize_);\n\treturn jas_stream_putc_macro(stream, c);\n}\n\nint jas_stream_ungetc(jas_stream_t *stream, int c)\n{\n\tif (!stream->ptr_ || stream->ptr_ == stream->bufbase_) {\n\t\treturn -1;\n\t}\n\n\t/* Reset the EOF indicator (since we now have at least one character\n\t  to read). */\n\tstream->flags_ &= ~JAS_STREAM_EOF;\n\n\t--stream->rwcnt_;\n\t--stream->ptr_;\n\t++stream->cnt_;\n\t*stream->ptr_ = c;\n\treturn 0;\n}\n\nint jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n{\n\tint n;\n\tint c;\n\tchar *bufptr;\n\n\tbufptr = buf;\n\n\tn = 0;\n\twhile (n < cnt) {\n\t\tif ((c = jas_stream_getc(stream)) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t*bufptr++ = c;\n\t\t++n;\n\t}\n\n\treturn n;\n}\n\nint jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)\n{\n\tint n;\n\tconst char *bufptr;\n\n\tbufptr = buf;\n\n\tn = 0;\n\twhile (n < cnt) {\n\t\tif (jas_stream_putc(stream, *bufptr) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t++bufptr;\n\t\t++n;\n\t}\n\n\treturn n;\n}\n\n/* Note: This function uses a fixed size buffer.  Therefore, it cannot\n  handle invocations that will produce more output than can be held\n  by the buffer. */\nint jas_stream_printf(jas_stream_t *stream, const char *fmt, ...)\n{\n\tva_list ap;\n\tchar buf[4096];\n\tint ret;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(buf, sizeof buf, fmt, ap);\n\tjas_stream_puts(stream, buf);\n\tva_end(ap);\n\treturn ret;\n}\n\nint jas_stream_puts(jas_stream_t *stream, const char *s)\n{\n\twhile (*s != '\\0') {\n\t\tif (jas_stream_putc_macro(stream, *s) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\t++s;\n\t}\n\treturn 0;\n}\n\nchar *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n{\n\tint c;\n\tchar *bufptr;\n\tassert(bufsize > 0);\n\n\tbufptr = buf;\n\twhile (bufsize > 1) {\n\t\tif ((c = jas_stream_getc(stream)) == EOF) {\n\t\t\tbreak;\n\t\t}\n\t\t*bufptr++ = c;\n\t\t--bufsize;\n\t\tif (c == '\\n') {\n\t\t\tbreak;\n\t\t}\n\t}\n\t*bufptr = '\\0';\n\treturn buf;\n}\n\nint jas_stream_gobble(jas_stream_t *stream, int n)\n{\n\tint m;\n\tm = n;\n\tfor (m = n; m > 0; --m) {\n\t\tif (jas_stream_getc(stream) == EOF) {\n\t\t\treturn n - m;\n\t\t}\n\t}\n\treturn n;\n}\n\nint jas_stream_pad(jas_stream_t *stream, int n, int c)\n{\n\tint m;\n\tm = n;\n\tfor (m = n; m > 0; --m) {\n\t\tif (jas_stream_putc(stream, c) == EOF)\n\t\t\treturn n - m;\n\t}\n\treturn n;\n}\n\n/******************************************************************************\\\n* Code for getting and setting the stream position.\n\\******************************************************************************/\n\nint jas_stream_isseekable(jas_stream_t *stream)\n{\n\tif (stream->ops_ == &jas_stream_memops) {\n\t\treturn 1;\n\t} else if (stream->ops_ == &jas_stream_fileops) {\n\t\tif ((*stream->ops_->seek_)(stream->obj_, 0, SEEK_CUR) < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nint jas_stream_rewind(jas_stream_t *stream)\n{\n\treturn jas_stream_seek(stream, 0, SEEK_SET);\n}\n\nlong jas_stream_seek(jas_stream_t *stream, long offset, int origin)\n{\n\tlong newpos;\n\n\t/* The buffer cannot be in use for both reading and writing. */\n\tassert(!((stream->bufmode_ & JAS_STREAM_RDBUF) && (stream->bufmode_ &\n\t  JAS_STREAM_WRBUF)));\n\n\t/* Reset the EOF indicator (since we may not be at the EOF anymore). */\n\tstream->flags_ &= ~JAS_STREAM_EOF;\n\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\tif (origin == SEEK_CUR) {\n\t\t\toffset -= stream->cnt_;\n\t\t}\n\t} else if (stream->bufmode_ & JAS_STREAM_WRBUF) {\n\t\tif (jas_stream_flush(stream)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tstream->cnt_ = 0;\n\tstream->ptr_ = stream->bufstart_;\n\tstream->bufmode_ &= ~(JAS_STREAM_RDBUF | JAS_STREAM_WRBUF);\n\n\tif ((newpos = (*stream->ops_->seek_)(stream->obj_, offset, origin))\n\t  < 0) {\n\t\treturn -1;\n\t}\n\n\treturn newpos;\n}\n\nlong jas_stream_tell(jas_stream_t *stream)\n{\n\tint adjust;\n\tint offset;\n\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\tadjust = -stream->cnt_;\n\t} else if (stream->bufmode_ & JAS_STREAM_WRBUF) {\n\t\tadjust = stream->ptr_ - stream->bufstart_;\n\t} else {\n\t\tadjust = 0;\n\t}\n\n\tif ((offset = (*stream->ops_->seek_)(stream->obj_, 0, SEEK_CUR)) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn offset + adjust;\n}\n\n/******************************************************************************\\\n* Buffer initialization code.\n\\******************************************************************************/\n\nstatic void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,\n  int bufsize)\n{\n\t/* If this function is being called, the buffer should not have been\n\t  initialized yet. */\n\tassert(!stream->bufbase_);\n\n\tif (bufmode != JAS_STREAM_UNBUF) {\n\t\t/* The full- or line-buffered mode is being employed. */\n\t\tif (!buf) {\n\t\t\t/* The caller has not specified a buffer to employ, so allocate\n\t\t\t  one. */\n\t\t\tif ((stream->bufbase_ = jas_malloc(JAS_STREAM_BUFSIZE +\n\t\t\t  JAS_STREAM_MAXPUTBACK))) {\n\t\t\t\tstream->bufmode_ |= JAS_STREAM_FREEBUF;\n\t\t\t\tstream->bufsize_ = JAS_STREAM_BUFSIZE;\n\t\t\t} else {\n\t\t\t\t/* The buffer allocation has failed.  Resort to unbuffered\n\t\t\t\t  operation. */\n\t\t\t\tstream->bufbase_ = stream->tinybuf_;\n\t\t\t\tstream->bufsize_ = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t/* The caller has specified a buffer to employ. */\n\t\t\t/* The buffer must be large enough to accommodate maximum\n\t\t\t  putback. */\n\t\t\tassert(bufsize > JAS_STREAM_MAXPUTBACK);\n\t\t\tstream->bufbase_ = JAS_CAST(uchar *, buf);\n\t\t\tstream->bufsize_ = bufsize - JAS_STREAM_MAXPUTBACK;\n\t\t}\n\t} else {\n\t\t/* The unbuffered mode is being employed. */\n\t\t/* A buffer should not have been supplied by the caller. */\n\t\tassert(!buf);\n\t\t/* Use a trivial one-character buffer. */\n\t\tstream->bufbase_ = stream->tinybuf_;\n\t\tstream->bufsize_ = 1;\n\t}\n\tstream->bufstart_ = &stream->bufbase_[JAS_STREAM_MAXPUTBACK];\n\tstream->ptr_ = stream->bufstart_;\n\tstream->cnt_ = 0;\n\tstream->bufmode_ |= bufmode & JAS_STREAM_BUFMODEMASK;\n}\n\n/******************************************************************************\\\n* Buffer filling and flushing code.\n\\******************************************************************************/\n\nint jas_stream_flush(jas_stream_t *stream)\n{\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\treturn 0;\n\t}\n\treturn jas_stream_flushbuf(stream, EOF);\n}\n\nint jas_stream_fillbuf(jas_stream_t *stream, int getflag)\n{\n\tint c;\n\n\t/* The stream must not be in an error or EOF state. */\n\tif ((stream->flags_ & (JAS_STREAM_ERRMASK)) != 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The stream must be open for reading. */\n\tif ((stream->openmode_ & JAS_STREAM_READ) == 0) {\n\t\treturn EOF;\n\t}\n\n\t/* Make a half-hearted attempt to confirm that the buffer is not\n\tcurrently being used for writing.  This check is not intended\n\tto be foolproof! */\n\tassert((stream->bufmode_ & JAS_STREAM_WRBUF) == 0);\n\n\tassert(stream->ptr_ - stream->bufstart_ <= stream->bufsize_);\n\n\t/* Mark the buffer as being used for reading. */\n\tstream->bufmode_ |= JAS_STREAM_RDBUF;\n\n\t/* Read new data into the buffer. */\n\tstream->ptr_ = stream->bufstart_;\n\tif ((stream->cnt_ = (*stream->ops_->read_)(stream->obj_,\n\t  (char *) stream->bufstart_, stream->bufsize_)) <= 0) {\n\t\tif (stream->cnt_ < 0) {\n\t\t\tstream->flags_ |= JAS_STREAM_ERR;\n\t\t} else {\n\t\t\tstream->flags_ |= JAS_STREAM_EOF;\n\t\t}\n\t\tstream->cnt_ = 0;\n\t\treturn EOF;\n\t}\n\n\tassert(stream->cnt_ > 0);\n\t/* Get or peek at the first character in the buffer. */\n\tc = (getflag) ? jas_stream_getc2(stream) : (*stream->ptr_);\n\n\treturn c;\n}\n\nint jas_stream_flushbuf(jas_stream_t *stream, int c)\n{\n\tint len;\n\tint n;\n\n\t/* The stream should not be in an error or EOF state. */\n\tif ((stream->flags_ & (JAS_STREAM_ERRMASK)) != 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The stream must be open for writing. */\n\tif ((stream->openmode_ & (JAS_STREAM_WRITE | JAS_STREAM_APPEND)) == 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The buffer should not currently be in use for reading. */\n\tassert(!(stream->bufmode_ & JAS_STREAM_RDBUF));\n\n\t/* Note: Do not use the quantity stream->cnt to determine the number\n\tof characters in the buffer!  Depending on how this function was\n\tcalled, the stream->cnt value may be \"off-by-one\". */\n\tlen = stream->ptr_ - stream->bufstart_;\n\tif (len > 0) {\n\t\tn = (*stream->ops_->write_)(stream->obj_, (char *)\n\t\t  stream->bufstart_, len);\n\t\tif (n != len) {\n\t\t\tstream->flags_ |= JAS_STREAM_ERR;\n\t\t\treturn EOF;\n\t\t}\n\t}\n\tstream->cnt_ = stream->bufsize_;\n\tstream->ptr_ = stream->bufstart_;\n\n\tstream->bufmode_ |= JAS_STREAM_WRBUF;\n\n\tif (c != EOF) {\n\t\tassert(stream->cnt_ > 0);\n\t\treturn jas_stream_putc2(stream, c);\n\t}\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Miscellaneous code.\n\\******************************************************************************/\n\nstatic int jas_strtoopenmode(const char *s)\n{\n\tint openmode = 0;\n\twhile (*s != '\\0') {\n\t\tswitch (*s) {\n\t\tcase 'r':\n\t\t\topenmode |= JAS_STREAM_READ;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\topenmode |= JAS_STREAM_WRITE | JAS_STREAM_CREATE;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\topenmode |= JAS_STREAM_BINARY;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\topenmode |= JAS_STREAM_APPEND;\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\topenmode |= JAS_STREAM_READ | JAS_STREAM_WRITE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t++s;\n\t}\n\treturn openmode;\n}\n\nint jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)\n{\n\tint all;\n\tint c;\n\tint m;\n\n\tall = (n < 0) ? 1 : 0;\n\n\tm = n;\n\twhile (all || m > 0) {\n\t\tif ((c = jas_stream_getc_macro(in)) == EOF) {\n\t\t\t/* The next character of input could not be read. */\n\t\t\t/* Return with an error if an I/O error occured\n\t\t\t  (not including EOF) or if an explicit copy count\n\t\t\t  was specified. */\n\t\t\treturn (!all || jas_stream_error(in)) ? (-1) : 0;\n\t\t}\n\t\tif (jas_stream_putc_macro(out, c) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\t--m;\n\t}\n\treturn 0;\n}\n\nlong jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)\n{\n\tint old;\n\n\told = stream->rwcnt_;\n\tstream->rwcnt_ = rwcnt;\n\treturn old;\n}\n\nint jas_stream_display(jas_stream_t *stream, FILE *fp, int n)\n{\n\tunsigned char buf[16];\n\tint i;\n\tint j;\n\tint m;\n\tint c;\n\tint display;\n\tint cnt;\n\n\tcnt = n - (n % 16);\n\tdisplay = 1;\n\n\tfor (i = 0; i < n; i += 16) {\n\t\tif (n > 16 && i > 0) {\n\t\t\tdisplay = (i >= cnt) ? 1 : 0;\n\t\t}\n\t\tif (display) {\n\t\t\tfprintf(fp, \"%08x:\", i);\n\t\t}\n\t\tm = JAS_MIN(n - i, 16);\n\t\tfor (j = 0; j < m; ++j) {\n\t\t\tif ((c = jas_stream_getc(stream)) == EOF) {\n\t\t\t\tabort();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbuf[j] = c;\n\t\t}\n\t\tif (display) {\n\t\t\tfor (j = 0; j < m; ++j) {\n\t\t\t\tfprintf(fp, \" %02x\", buf[j]);\n\t\t\t}\n\t\t\tfputc(' ', fp);\n\t\t\tfor (; j < 16; ++j) {\n\t\t\t\tfprintf(fp, \"   \");\n\t\t\t}\n\t\t\tfor (j = 0; j < m; ++j) {\n\t\t\t\tif (isprint(buf[j])) {\n\t\t\t\t\tfputc(buf[j], fp);\n\t\t\t\t} else {\n\t\t\t\t\tfputc(' ', fp);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(fp, \"\\n\");\n\t\t}\n\n\n\t}\n\treturn 0;\n}\n\nlong jas_stream_length(jas_stream_t *stream)\n{\n\tlong oldpos;\n\tlong pos;\n\tif ((oldpos = jas_stream_tell(stream)) < 0) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_seek(stream, 0, SEEK_END) < 0) {\n\t\treturn -1;\n\t}\n\tif ((pos = jas_stream_tell(stream)) < 0) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_seek(stream, oldpos, SEEK_SET) < 0) {\n\t\treturn -1;\n\t}\n\treturn pos;\n}\n\n/******************************************************************************\\\n* Memory stream object.\n\\******************************************************************************/\n\nstatic int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tint n;\n\tassert(cnt >= 0);\n\tassert(buf);\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tn = m->len_ - m->pos_;\n\tcnt = JAS_MIN(n, cnt);\n\tmemcpy(buf, &m->buf_[m->pos_], cnt);\n\tm->pos_ += cnt;\n\treturn cnt;\n}\n\nstatic int mem_resize(jas_stream_memobj_t *m, int bufsize)\n{\n\tunsigned char *buf;\n\n\tassert(m->buf_);\n\tassert(bufsize >= 0);\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char)))) {\n\t\treturn -1;\n\t}\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}\n\nstatic int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tint n;\n\tint ret;\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tlong newbufsize;\n\tlong newpos;\n\n\tassert(buf);\n\tassert(cnt >= 0);\n\tnewpos = m->pos_ + cnt;\n\tif (newpos > m->bufsize_ && m->growable_) {\n\t\tnewbufsize = m->bufsize_;\n\t\twhile (newbufsize < newpos) {\n\t\t\tnewbufsize <<= 1;\n\t\t\tassert(newbufsize >= 0);\n\t\t}\n\t\tif (mem_resize(m, newbufsize)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (m->pos_ > m->len_) {\n\t\t/* The current position is beyond the end of the file, so\n\t\t  pad the file to the current position with zeros. */\n\t\tn = JAS_MIN(m->pos_, m->bufsize_) - m->len_;\n\t\tif (n > 0) {\n\t\t\tmemset(&m->buf_[m->len_], 0, n);\n\t\t\tm->len_ += n;\n\t\t}\n\t\tif (m->pos_ != m->len_) {\n\t\t\t/* The buffer is not big enough. */\n\t\t\treturn 0;\n\t\t}\n\t}\n\tn = m->bufsize_ - m->pos_;\n\tret = JAS_MIN(n, cnt);\n\tif (ret > 0) {\n\t\tmemcpy(&m->buf_[m->pos_], buf, ret);\n\t\tm->pos_ += ret;\n\t}\n\tif (m->pos_ > m->len_) {\n\t\tm->len_ = m->pos_;\n\t}\n\tassert(ret == cnt);\n\treturn ret;\n}\n\nstatic long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tlong newpos;\n\n\tswitch (origin) {\n\tcase SEEK_SET:\n\t\tnewpos = offset;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tnewpos = m->len_ - offset;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tnewpos = m->pos_ + offset;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\tif (newpos < 0) {\n\t\treturn -1;\n\t}\n\tm->pos_ = newpos;\n\n\treturn m->pos_;\n}\n\nstatic int mem_close(jas_stream_obj_t *obj)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tif (m->myalloc_ && m->buf_) {\n\t\tjas_free(m->buf_);\n\t\tm->buf_ = 0;\n\t}\n\tjas_free(obj);\n\treturn 0;\n}\n\n/******************************************************************************\\\n* File stream object.\n\\******************************************************************************/\n\nstatic int file_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tjas_stream_fileobj_t *fileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\treturn read(fileobj->fd, buf, cnt);\n}\n\nstatic int file_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tjas_stream_fileobj_t *fileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\treturn write(fileobj->fd, buf, cnt);\n}\n\nstatic long file_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tjas_stream_fileobj_t *fileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\treturn lseek(fileobj->fd, offset, origin);\n}\n\nstatic int file_close(jas_stream_obj_t *obj)\n{\n\tjas_stream_fileobj_t *fileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\tint ret;\n\tret = close(fileobj->fd);\n\tif (fileobj->flags & JAS_STREAM_FILEOBJ_DELONCLOSE) {\n\t\tunlink(fileobj->pathname);\n\t}\n\tjas_free(fileobj);\n\treturn ret;\n}\n\n/******************************************************************************\\\n* Stdio file stream object.\n\\******************************************************************************/\n\nstatic int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tFILE *fp;\n\tfp = JAS_CAST(FILE *, obj);\n\treturn fread(buf, 1, cnt, fp);\n}\n\nstatic int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tFILE *fp;\n\tfp = JAS_CAST(FILE *, obj);\n\treturn fwrite(buf, 1, cnt, fp);\n}\n\nstatic long sfile_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tFILE *fp;\n\tfp = JAS_CAST(FILE *, obj);\n\treturn fseek(fp, offset, origin);\n}\n\nstatic int sfile_close(jas_stream_obj_t *obj)\n{\n\tFILE *fp;\n\tfp = JAS_CAST(FILE *, obj);\n\treturn fclose(fp);\n}\n"], "fixing_code": ["/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * I/O Stream Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <assert.h>\n#if defined(HAVE_FCNTL_H)\n#include <fcntl.h>\n#endif\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <ctype.h>\n#if defined(HAVE_UNISTD_H)\n#include <unistd.h>\n#endif\n#if defined(WIN32) || defined(HAVE_IO_H)\n#include <io.h>\n#endif\n\n#include \"jasper/jas_types.h\"\n#include \"jasper/jas_stream.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_math.h\"\n\n/******************************************************************************\\\n* Local function prototypes.\n\\******************************************************************************/\n\nstatic int jas_strtoopenmode(const char *s);\nstatic void jas_stream_destroy(jas_stream_t *stream);\nstatic jas_stream_t *jas_stream_create(void);\nstatic void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,\n  int bufsize);\n\nstatic int mem_read(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic int mem_write(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic long mem_seek(jas_stream_obj_t *obj, long offset, int origin);\nstatic int mem_close(jas_stream_obj_t *obj);\n\nstatic int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic long sfile_seek(jas_stream_obj_t *obj, long offset, int origin);\nstatic int sfile_close(jas_stream_obj_t *obj);\n\nstatic int file_read(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic int file_write(jas_stream_obj_t *obj, char *buf, int cnt);\nstatic long file_seek(jas_stream_obj_t *obj, long offset, int origin);\nstatic int file_close(jas_stream_obj_t *obj);\n\n/******************************************************************************\\\n* Local data.\n\\******************************************************************************/\n\nstatic jas_stream_ops_t jas_stream_fileops = {\n\tfile_read,\n\tfile_write,\n\tfile_seek,\n\tfile_close\n};\n\nstatic jas_stream_ops_t jas_stream_sfileops = {\n\tsfile_read,\n\tsfile_write,\n\tsfile_seek,\n\tsfile_close\n};\n\nstatic jas_stream_ops_t jas_stream_memops = {\n\tmem_read,\n\tmem_write,\n\tmem_seek,\n\tmem_close\n};\n\n/******************************************************************************\\\n* Code for opening and closing streams.\n\\******************************************************************************/\n\nstatic jas_stream_t *jas_stream_create()\n{\n\tjas_stream_t *stream;\n\n\tif (!(stream = jas_malloc(sizeof(jas_stream_t)))) {\n\t\treturn 0;\n\t}\n\tstream->openmode_ = 0;\n\tstream->bufmode_ = 0;\n\tstream->flags_ = 0;\n\tstream->bufbase_ = 0;\n\tstream->bufstart_ = 0;\n\tstream->bufsize_ = 0;\n\tstream->ptr_ = 0;\n\tstream->cnt_ = 0;\n\tstream->ops_ = 0;\n\tstream->obj_ = 0;\n\tstream->rwcnt_ = 0;\n\tstream->rwlimit_ = -1;\n\n\treturn stream;\n}\n\njas_stream_t *jas_stream_memopen(char *buf, int bufsize)\n{\n\tjas_stream_t *stream;\n\tjas_stream_memobj_t *obj;\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A stream associated with a memory buffer is always opened\n\tfor both reading and writing in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Since the stream data is already resident in memory, buffering\n\tis not necessary. */\n\t/* But... It still may be faster to use buffering anyways. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\t/* Select the operations for a memory stream. */\n\tstream->ops_ = &jas_stream_memops;\n\n\t/* Allocate memory for the underlying memory stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_memobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tstream->obj_ = (void *) obj;\n\n\t/* Initialize a few important members of the memory stream object. */\n\tobj->myalloc_ = 0;\n\tobj->buf_ = 0;\n\n\t/* If the buffer size specified is nonpositive, then the buffer\n\tis allocated internally and automatically grown as needed. */\n\tif (bufsize <= 0) {\n\t\tobj->bufsize_ = 1024;\n\t\tobj->growable_ = 1;\n\t} else {\n\t\tobj->bufsize_ = bufsize;\n\t\tobj->growable_ = 0;\n\t}\n\tif (buf) {\n\t\tobj->buf_ = (unsigned char *) buf;\n\t} else {\n\t\tobj->buf_ = jas_malloc(obj->bufsize_);\n\t\tobj->myalloc_ = 1;\n\t}\n\tif (!obj->buf_) {\n\t\tjas_stream_close(stream);\n\t\treturn 0;\n\t}\n\n\tif (bufsize > 0 && buf) {\n\t\t/* If a buffer was supplied by the caller and its length is positive,\n\t\t  make the associated buffer data appear in the stream initially. */\n\t\tobj->len_ = bufsize;\n\t} else {\n\t\t/* The stream is initially empty. */\n\t\tobj->len_ = 0;\n\t}\n\tobj->pos_ = 0;\n\t\n\treturn stream;\n}\n\njas_stream_t *jas_stream_fopen(const char *filename, const char *mode)\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\tint openflags;\n\n\t/* Allocate a stream object. */\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* Parse the mode string. */\n\tstream->openmode_ = jas_strtoopenmode(mode);\n\n\t/* Determine the correct flags to use for opening the file. */\n\tif ((stream->openmode_ & JAS_STREAM_READ) &&\n\t  (stream->openmode_ & JAS_STREAM_WRITE)) {\n\t\topenflags = O_RDWR;\n\t} else if (stream->openmode_ & JAS_STREAM_READ) {\n\t\topenflags = O_RDONLY;\n\t} else if (stream->openmode_ & JAS_STREAM_WRITE) {\n\t\topenflags = O_WRONLY;\n\t} else {\n\t\topenflags = 0;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_APPEND) {\n\t\topenflags |= O_APPEND;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_BINARY) {\n\t\topenflags |= O_BINARY;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_CREATE) {\n\t\topenflags |= O_CREAT | O_TRUNC;\n\t}\n\n\t/* Allocate space for the underlying file stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = -1;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = (void *) obj;\n\n\t/* Select the operations for a file stream object. */\n\tstream->ops_ = &jas_stream_fileops;\n\n\t/* Open the underlying file. */\n\tif ((obj->fd = open(filename, openflags, JAS_STREAM_PERMS)) < 0) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\n\t/* By default, use full buffering for this type of stream. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\treturn stream;\n}\n\njas_stream_t *jas_stream_freopen(const char *path, const char *mode, FILE *fp)\n{\n\tjas_stream_t *stream;\n\tint openflags;\n\n\t/* Eliminate compiler warning about unused variable. */\n\tpath = 0;\n\n\t/* Allocate a stream object. */\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* Parse the mode string. */\n\tstream->openmode_ = jas_strtoopenmode(mode);\n\n\t/* Determine the correct flags to use for opening the file. */\n\tif ((stream->openmode_ & JAS_STREAM_READ) &&\n\t  (stream->openmode_ & JAS_STREAM_WRITE)) {\n\t\topenflags = O_RDWR;\n\t} else if (stream->openmode_ & JAS_STREAM_READ) {\n\t\topenflags = O_RDONLY;\n\t} else if (stream->openmode_ & JAS_STREAM_WRITE) {\n\t\topenflags = O_WRONLY;\n\t} else {\n\t\topenflags = 0;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_APPEND) {\n\t\topenflags |= O_APPEND;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_BINARY) {\n\t\topenflags |= O_BINARY;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_CREATE) {\n\t\topenflags |= O_CREAT | O_TRUNC;\n\t}\n\n\tstream->obj_ = JAS_CAST(void *, fp);\n\n\t/* Select the operations for a file stream object. */\n\tstream->ops_ = &jas_stream_sfileops;\n\n\t/* By default, use full buffering for this type of stream. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\treturn stream;\n}\n\njas_stream_t *jas_stream_tmpfile()\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A temporary file stream is always opened for both reading and\n\twriting in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Allocate memory for the underlying temporary file object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = -1;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = obj;\n\n\t/* Choose a file name. */\n\ttmpnam(obj->pathname);\n\n\t/* Open the underlying file. */\n\tif ((obj->fd = open(obj->pathname, O_CREAT | O_EXCL | O_RDWR | O_TRUNC | O_BINARY,\n\t  JAS_STREAM_PERMS)) < 0) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\n\t/* Unlink the file so that it will disappear if the program\n\tterminates abnormally. */\n\t/* Under UNIX, one can unlink an open file and continue to do I/O\n\ton it.  Not all operating systems support this functionality, however.\n\tFor example, under Microsoft Windows the unlink operation will fail,\n\tsince the file is open. */\n\tif (unlink(obj->pathname)) {\n\t\t/* We will try unlinking the file again after it is closed. */\n\t\tobj->flags |= JAS_STREAM_FILEOBJ_DELONCLOSE;\n\t}\n\n\t/* Use full buffering. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\tstream->ops_ = &jas_stream_fileops;\n\n\treturn stream;\n}\n\njas_stream_t *jas_stream_fdopen(int fd, const char *mode)\n{\n\tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\n\t/* Allocate a stream object. */\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* Parse the mode string. */\n\tstream->openmode_ = jas_strtoopenmode(mode);\n\n#if defined(WIN32)\n\t/* Argh!!!  Someone ought to banish text mode (i.e., O_TEXT) to the\n\t  greatest depths of purgatory! */\n\t/* Ensure that the file descriptor is in binary mode, if the caller\n\t  has specified the binary mode flag.  Arguably, the caller ought to\n\t  take care of this, but text mode is a ugly wart anyways, so we save\n\t  the caller some grief by handling this within the stream library. */\n\t/* This ugliness is mainly for the benefit of those who run the\n\t  JasPer software under Windows from shells that insist on opening\n\t  files in text mode.  For example, in the Cygwin environment,\n\t  shells often open files in text mode when I/O redirection is\n\t  used.  Grr... */\n\tif (stream->openmode_ & JAS_STREAM_BINARY) {\n\t\tsetmode(fd, O_BINARY);\n\t}\n#endif\n\n\t/* Allocate space for the underlying file stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = fd;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = (void *) obj;\n\n\t/* Do not close the underlying file descriptor when the stream is\n\tclosed. */\n\tobj->flags |= JAS_STREAM_FILEOBJ_NOCLOSE;\n\n\t/* By default, use full buffering for this type of stream. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\t/* Select the operations for a file stream object. */\n\tstream->ops_ = &jas_stream_fileops;\n\n\treturn stream;\n}\n\nstatic void jas_stream_destroy(jas_stream_t *stream)\n{\n\t/* If the memory for the buffer was allocated with malloc, free\n\tthis memory. */\n\tif ((stream->bufmode_ & JAS_STREAM_FREEBUF) && stream->bufbase_) {\n\t\tjas_free(stream->bufbase_);\n\t\tstream->bufbase_ = 0;\n\t}\n\tjas_free(stream);\n}\n\nint jas_stream_close(jas_stream_t *stream)\n{\n\t/* Flush buffer if necessary. */\n\tjas_stream_flush(stream);\n\n\t/* Close the underlying stream object. */\n\t(*stream->ops_->close_)(stream->obj_);\n\n\tjas_stream_destroy(stream);\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Code for reading and writing streams.\n\\******************************************************************************/\n\nint jas_stream_getc_func(jas_stream_t *stream)\n{\n\tassert(stream->ptr_ - stream->bufbase_ <= stream->bufsize_ +\n\t  JAS_STREAM_MAXPUTBACK);\n\treturn jas_stream_getc_macro(stream);\n}\n\nint jas_stream_putc_func(jas_stream_t *stream, int c)\n{\n\tassert(stream->ptr_ - stream->bufstart_ <= stream->bufsize_);\n\treturn jas_stream_putc_macro(stream, c);\n}\n\nint jas_stream_ungetc(jas_stream_t *stream, int c)\n{\n\tif (!stream->ptr_ || stream->ptr_ == stream->bufbase_) {\n\t\treturn -1;\n\t}\n\n\t/* Reset the EOF indicator (since we now have at least one character\n\t  to read). */\n\tstream->flags_ &= ~JAS_STREAM_EOF;\n\n\t--stream->rwcnt_;\n\t--stream->ptr_;\n\t++stream->cnt_;\n\t*stream->ptr_ = c;\n\treturn 0;\n}\n\nint jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n{\n\tint n;\n\tint c;\n\tchar *bufptr;\n\n\tbufptr = buf;\n\n\tn = 0;\n\twhile (n < cnt) {\n\t\tif ((c = jas_stream_getc(stream)) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t*bufptr++ = c;\n\t\t++n;\n\t}\n\n\treturn n;\n}\n\nint jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)\n{\n\tint n;\n\tconst char *bufptr;\n\n\tbufptr = buf;\n\n\tn = 0;\n\twhile (n < cnt) {\n\t\tif (jas_stream_putc(stream, *bufptr) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t++bufptr;\n\t\t++n;\n\t}\n\n\treturn n;\n}\n\n/* Note: This function uses a fixed size buffer.  Therefore, it cannot\n  handle invocations that will produce more output than can be held\n  by the buffer. */\nint jas_stream_printf(jas_stream_t *stream, const char *fmt, ...)\n{\n\tva_list ap;\n\tchar buf[4096];\n\tint ret;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(buf, sizeof buf, fmt, ap);\n\tjas_stream_puts(stream, buf);\n\tva_end(ap);\n\treturn ret;\n}\n\nint jas_stream_puts(jas_stream_t *stream, const char *s)\n{\n\twhile (*s != '\\0') {\n\t\tif (jas_stream_putc_macro(stream, *s) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\t++s;\n\t}\n\treturn 0;\n}\n\nchar *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n{\n\tint c;\n\tchar *bufptr;\n\tassert(bufsize > 0);\n\n\tbufptr = buf;\n\twhile (bufsize > 1) {\n\t\tif ((c = jas_stream_getc(stream)) == EOF) {\n\t\t\tbreak;\n\t\t}\n\t\t*bufptr++ = c;\n\t\t--bufsize;\n\t\tif (c == '\\n') {\n\t\t\tbreak;\n\t\t}\n\t}\n\t*bufptr = '\\0';\n\treturn buf;\n}\n\nint jas_stream_gobble(jas_stream_t *stream, int n)\n{\n\tint m;\n\tm = n;\n\tfor (m = n; m > 0; --m) {\n\t\tif (jas_stream_getc(stream) == EOF) {\n\t\t\treturn n - m;\n\t\t}\n\t}\n\treturn n;\n}\n\nint jas_stream_pad(jas_stream_t *stream, int n, int c)\n{\n\tint m;\n\tm = n;\n\tfor (m = n; m > 0; --m) {\n\t\tif (jas_stream_putc(stream, c) == EOF)\n\t\t\treturn n - m;\n\t}\n\treturn n;\n}\n\n/******************************************************************************\\\n* Code for getting and setting the stream position.\n\\******************************************************************************/\n\nint jas_stream_isseekable(jas_stream_t *stream)\n{\n\tif (stream->ops_ == &jas_stream_memops) {\n\t\treturn 1;\n\t} else if (stream->ops_ == &jas_stream_fileops) {\n\t\tif ((*stream->ops_->seek_)(stream->obj_, 0, SEEK_CUR) < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nint jas_stream_rewind(jas_stream_t *stream)\n{\n\treturn jas_stream_seek(stream, 0, SEEK_SET);\n}\n\nlong jas_stream_seek(jas_stream_t *stream, long offset, int origin)\n{\n\tlong newpos;\n\n\t/* The buffer cannot be in use for both reading and writing. */\n\tassert(!((stream->bufmode_ & JAS_STREAM_RDBUF) && (stream->bufmode_ &\n\t  JAS_STREAM_WRBUF)));\n\n\t/* Reset the EOF indicator (since we may not be at the EOF anymore). */\n\tstream->flags_ &= ~JAS_STREAM_EOF;\n\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\tif (origin == SEEK_CUR) {\n\t\t\toffset -= stream->cnt_;\n\t\t}\n\t} else if (stream->bufmode_ & JAS_STREAM_WRBUF) {\n\t\tif (jas_stream_flush(stream)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tstream->cnt_ = 0;\n\tstream->ptr_ = stream->bufstart_;\n\tstream->bufmode_ &= ~(JAS_STREAM_RDBUF | JAS_STREAM_WRBUF);\n\n\tif ((newpos = (*stream->ops_->seek_)(stream->obj_, offset, origin))\n\t  < 0) {\n\t\treturn -1;\n\t}\n\n\treturn newpos;\n}\n\nlong jas_stream_tell(jas_stream_t *stream)\n{\n\tint adjust;\n\tint offset;\n\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\tadjust = -stream->cnt_;\n\t} else if (stream->bufmode_ & JAS_STREAM_WRBUF) {\n\t\tadjust = stream->ptr_ - stream->bufstart_;\n\t} else {\n\t\tadjust = 0;\n\t}\n\n\tif ((offset = (*stream->ops_->seek_)(stream->obj_, 0, SEEK_CUR)) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn offset + adjust;\n}\n\n/******************************************************************************\\\n* Buffer initialization code.\n\\******************************************************************************/\n\nstatic void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,\n  int bufsize)\n{\n\t/* If this function is being called, the buffer should not have been\n\t  initialized yet. */\n\tassert(!stream->bufbase_);\n\n\tif (bufmode != JAS_STREAM_UNBUF) {\n\t\t/* The full- or line-buffered mode is being employed. */\n\t\tif (!buf) {\n\t\t\t/* The caller has not specified a buffer to employ, so allocate\n\t\t\t  one. */\n\t\t\tif ((stream->bufbase_ = jas_malloc(JAS_STREAM_BUFSIZE +\n\t\t\t  JAS_STREAM_MAXPUTBACK))) {\n\t\t\t\tstream->bufmode_ |= JAS_STREAM_FREEBUF;\n\t\t\t\tstream->bufsize_ = JAS_STREAM_BUFSIZE;\n\t\t\t} else {\n\t\t\t\t/* The buffer allocation has failed.  Resort to unbuffered\n\t\t\t\t  operation. */\n\t\t\t\tstream->bufbase_ = stream->tinybuf_;\n\t\t\t\tstream->bufsize_ = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t/* The caller has specified a buffer to employ. */\n\t\t\t/* The buffer must be large enough to accommodate maximum\n\t\t\t  putback. */\n\t\t\tassert(bufsize > JAS_STREAM_MAXPUTBACK);\n\t\t\tstream->bufbase_ = JAS_CAST(uchar *, buf);\n\t\t\tstream->bufsize_ = bufsize - JAS_STREAM_MAXPUTBACK;\n\t\t}\n\t} else {\n\t\t/* The unbuffered mode is being employed. */\n\t\t/* A buffer should not have been supplied by the caller. */\n\t\tassert(!buf);\n\t\t/* Use a trivial one-character buffer. */\n\t\tstream->bufbase_ = stream->tinybuf_;\n\t\tstream->bufsize_ = 1;\n\t}\n\tstream->bufstart_ = &stream->bufbase_[JAS_STREAM_MAXPUTBACK];\n\tstream->ptr_ = stream->bufstart_;\n\tstream->cnt_ = 0;\n\tstream->bufmode_ |= bufmode & JAS_STREAM_BUFMODEMASK;\n}\n\n/******************************************************************************\\\n* Buffer filling and flushing code.\n\\******************************************************************************/\n\nint jas_stream_flush(jas_stream_t *stream)\n{\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\treturn 0;\n\t}\n\treturn jas_stream_flushbuf(stream, EOF);\n}\n\nint jas_stream_fillbuf(jas_stream_t *stream, int getflag)\n{\n\tint c;\n\n\t/* The stream must not be in an error or EOF state. */\n\tif ((stream->flags_ & (JAS_STREAM_ERRMASK)) != 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The stream must be open for reading. */\n\tif ((stream->openmode_ & JAS_STREAM_READ) == 0) {\n\t\treturn EOF;\n\t}\n\n\t/* Make a half-hearted attempt to confirm that the buffer is not\n\tcurrently being used for writing.  This check is not intended\n\tto be foolproof! */\n\tassert((stream->bufmode_ & JAS_STREAM_WRBUF) == 0);\n\n\tassert(stream->ptr_ - stream->bufstart_ <= stream->bufsize_);\n\n\t/* Mark the buffer as being used for reading. */\n\tstream->bufmode_ |= JAS_STREAM_RDBUF;\n\n\t/* Read new data into the buffer. */\n\tstream->ptr_ = stream->bufstart_;\n\tif ((stream->cnt_ = (*stream->ops_->read_)(stream->obj_,\n\t  (char *) stream->bufstart_, stream->bufsize_)) <= 0) {\n\t\tif (stream->cnt_ < 0) {\n\t\t\tstream->flags_ |= JAS_STREAM_ERR;\n\t\t} else {\n\t\t\tstream->flags_ |= JAS_STREAM_EOF;\n\t\t}\n\t\tstream->cnt_ = 0;\n\t\treturn EOF;\n\t}\n\n\tassert(stream->cnt_ > 0);\n\t/* Get or peek at the first character in the buffer. */\n\tc = (getflag) ? jas_stream_getc2(stream) : (*stream->ptr_);\n\n\treturn c;\n}\n\nint jas_stream_flushbuf(jas_stream_t *stream, int c)\n{\n\tint len;\n\tint n;\n\n\t/* The stream should not be in an error or EOF state. */\n\tif ((stream->flags_ & (JAS_STREAM_ERRMASK)) != 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The stream must be open for writing. */\n\tif ((stream->openmode_ & (JAS_STREAM_WRITE | JAS_STREAM_APPEND)) == 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The buffer should not currently be in use for reading. */\n\tassert(!(stream->bufmode_ & JAS_STREAM_RDBUF));\n\n\t/* Note: Do not use the quantity stream->cnt to determine the number\n\tof characters in the buffer!  Depending on how this function was\n\tcalled, the stream->cnt value may be \"off-by-one\". */\n\tlen = stream->ptr_ - stream->bufstart_;\n\tif (len > 0) {\n\t\tn = (*stream->ops_->write_)(stream->obj_, (char *)\n\t\t  stream->bufstart_, len);\n\t\tif (n != len) {\n\t\t\tstream->flags_ |= JAS_STREAM_ERR;\n\t\t\treturn EOF;\n\t\t}\n\t}\n\tstream->cnt_ = stream->bufsize_;\n\tstream->ptr_ = stream->bufstart_;\n\n\tstream->bufmode_ |= JAS_STREAM_WRBUF;\n\n\tif (c != EOF) {\n\t\tassert(stream->cnt_ > 0);\n\t\treturn jas_stream_putc2(stream, c);\n\t}\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Miscellaneous code.\n\\******************************************************************************/\n\nstatic int jas_strtoopenmode(const char *s)\n{\n\tint openmode = 0;\n\twhile (*s != '\\0') {\n\t\tswitch (*s) {\n\t\tcase 'r':\n\t\t\topenmode |= JAS_STREAM_READ;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\topenmode |= JAS_STREAM_WRITE | JAS_STREAM_CREATE;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\topenmode |= JAS_STREAM_BINARY;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\topenmode |= JAS_STREAM_APPEND;\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\topenmode |= JAS_STREAM_READ | JAS_STREAM_WRITE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t++s;\n\t}\n\treturn openmode;\n}\n\nint jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)\n{\n\tint all;\n\tint c;\n\tint m;\n\n\tall = (n < 0) ? 1 : 0;\n\n\tm = n;\n\twhile (all || m > 0) {\n\t\tif ((c = jas_stream_getc_macro(in)) == EOF) {\n\t\t\t/* The next character of input could not be read. */\n\t\t\t/* Return with an error if an I/O error occured\n\t\t\t  (not including EOF) or if an explicit copy count\n\t\t\t  was specified. */\n\t\t\treturn (!all || jas_stream_error(in)) ? (-1) : 0;\n\t\t}\n\t\tif (jas_stream_putc_macro(out, c) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\t--m;\n\t}\n\treturn 0;\n}\n\nlong jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)\n{\n\tint old;\n\n\told = stream->rwcnt_;\n\tstream->rwcnt_ = rwcnt;\n\treturn old;\n}\n\nint jas_stream_display(jas_stream_t *stream, FILE *fp, int n)\n{\n\tunsigned char buf[16];\n\tint i;\n\tint j;\n\tint m;\n\tint c;\n\tint display;\n\tint cnt;\n\n\tcnt = n - (n % 16);\n\tdisplay = 1;\n\n\tfor (i = 0; i < n; i += 16) {\n\t\tif (n > 16 && i > 0) {\n\t\t\tdisplay = (i >= cnt) ? 1 : 0;\n\t\t}\n\t\tif (display) {\n\t\t\tfprintf(fp, \"%08x:\", i);\n\t\t}\n\t\tm = JAS_MIN(n - i, 16);\n\t\tfor (j = 0; j < m; ++j) {\n\t\t\tif ((c = jas_stream_getc(stream)) == EOF) {\n\t\t\t\tabort();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbuf[j] = c;\n\t\t}\n\t\tif (display) {\n\t\t\tfor (j = 0; j < m; ++j) {\n\t\t\t\tfprintf(fp, \" %02x\", buf[j]);\n\t\t\t}\n\t\t\tfputc(' ', fp);\n\t\t\tfor (; j < 16; ++j) {\n\t\t\t\tfprintf(fp, \"   \");\n\t\t\t}\n\t\t\tfor (j = 0; j < m; ++j) {\n\t\t\t\tif (isprint(buf[j])) {\n\t\t\t\t\tfputc(buf[j], fp);\n\t\t\t\t} else {\n\t\t\t\t\tfputc(' ', fp);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfprintf(fp, \"\\n\");\n\t\t}\n\n\n\t}\n\treturn 0;\n}\n\nlong jas_stream_length(jas_stream_t *stream)\n{\n\tlong oldpos;\n\tlong pos;\n\tif ((oldpos = jas_stream_tell(stream)) < 0) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_seek(stream, 0, SEEK_END) < 0) {\n\t\treturn -1;\n\t}\n\tif ((pos = jas_stream_tell(stream)) < 0) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_seek(stream, oldpos, SEEK_SET) < 0) {\n\t\treturn -1;\n\t}\n\treturn pos;\n}\n\n/******************************************************************************\\\n* Memory stream object.\n\\******************************************************************************/\n\nstatic int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tint n;\n\tassert(cnt >= 0);\n\tassert(buf);\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tn = m->len_ - m->pos_;\n\tcnt = JAS_MIN(n, cnt);\n\tmemcpy(buf, &m->buf_[m->pos_], cnt);\n\tm->pos_ += cnt;\n\treturn cnt;\n}\n\nstatic int mem_resize(jas_stream_memobj_t *m, int bufsize)\n{\n\tunsigned char *buf;\n\n\t//assert(m->buf_);\n\tassert(bufsize >= 0);\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n\t  bufsize) {\n\t\treturn -1;\n\t}\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}\n\nstatic int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tint n;\n\tint ret;\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tlong newbufsize;\n\tlong newpos;\n\n\tassert(buf);\n\tassert(cnt >= 0);\n\tnewpos = m->pos_ + cnt;\n\tif (newpos > m->bufsize_ && m->growable_) {\n\t\tnewbufsize = m->bufsize_;\n\t\twhile (newbufsize < newpos) {\n\t\t\tnewbufsize <<= 1;\n\t\t\tassert(newbufsize >= 0);\n\t\t}\n\t\tif (mem_resize(m, newbufsize)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (m->pos_ > m->len_) {\n\t\t/* The current position is beyond the end of the file, so\n\t\t  pad the file to the current position with zeros. */\n\t\tn = JAS_MIN(m->pos_, m->bufsize_) - m->len_;\n\t\tif (n > 0) {\n\t\t\tmemset(&m->buf_[m->len_], 0, n);\n\t\t\tm->len_ += n;\n\t\t}\n\t\tif (m->pos_ != m->len_) {\n\t\t\t/* The buffer is not big enough. */\n\t\t\treturn 0;\n\t\t}\n\t}\n\tn = m->bufsize_ - m->pos_;\n\tret = JAS_MIN(n, cnt);\n\tif (ret > 0) {\n\t\tmemcpy(&m->buf_[m->pos_], buf, ret);\n\t\tm->pos_ += ret;\n\t}\n\tif (m->pos_ > m->len_) {\n\t\tm->len_ = m->pos_;\n\t}\n\tassert(ret == cnt);\n\treturn ret;\n}\n\nstatic long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tlong newpos;\n\n\tswitch (origin) {\n\tcase SEEK_SET:\n\t\tnewpos = offset;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tnewpos = m->len_ - offset;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tnewpos = m->pos_ + offset;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\tif (newpos < 0) {\n\t\treturn -1;\n\t}\n\tm->pos_ = newpos;\n\n\treturn m->pos_;\n}\n\nstatic int mem_close(jas_stream_obj_t *obj)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tif (m->myalloc_ && m->buf_) {\n\t\tjas_free(m->buf_);\n\t\tm->buf_ = 0;\n\t}\n\tjas_free(obj);\n\treturn 0;\n}\n\n/******************************************************************************\\\n* File stream object.\n\\******************************************************************************/\n\nstatic int file_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tjas_stream_fileobj_t *fileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\treturn read(fileobj->fd, buf, cnt);\n}\n\nstatic int file_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tjas_stream_fileobj_t *fileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\treturn write(fileobj->fd, buf, cnt);\n}\n\nstatic long file_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tjas_stream_fileobj_t *fileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\treturn lseek(fileobj->fd, offset, origin);\n}\n\nstatic int file_close(jas_stream_obj_t *obj)\n{\n\tjas_stream_fileobj_t *fileobj = JAS_CAST(jas_stream_fileobj_t *, obj);\n\tint ret;\n\tret = close(fileobj->fd);\n\tif (fileobj->flags & JAS_STREAM_FILEOBJ_DELONCLOSE) {\n\t\tunlink(fileobj->pathname);\n\t}\n\tjas_free(fileobj);\n\treturn ret;\n}\n\n/******************************************************************************\\\n* Stdio file stream object.\n\\******************************************************************************/\n\nstatic int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tFILE *fp;\n\tfp = JAS_CAST(FILE *, obj);\n\treturn fread(buf, 1, cnt, fp);\n}\n\nstatic int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tFILE *fp;\n\tfp = JAS_CAST(FILE *, obj);\n\treturn fwrite(buf, 1, cnt, fp);\n}\n\nstatic long sfile_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tFILE *fp;\n\tfp = JAS_CAST(FILE *, obj);\n\treturn fseek(fp, offset, origin);\n}\n\nstatic int sfile_close(jas_stream_obj_t *obj)\n{\n\tFILE *fp;\n\tfp = JAS_CAST(FILE *, obj);\n\treturn fclose(fp);\n}\n"], "filenames": ["src/libjasper/base/jas_stream.c"], "buggy_code_start_loc": [996], "buggy_code_end_loc": [999], "fixing_code_start_loc": [996], "fixing_code_end_loc": [1000], "type": "CWE-415", "message": "Double free vulnerability in the mem_close function in jas_stream.c in JasPer before 1.900.10 allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via a crafted BMP image to the imginfo command.", "other": {"cve": {"id": "CVE-2016-8693", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-15T19:59:00.923", "lastModified": "2018-10-30T16:27:37.467", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Double free vulnerability in the mem_close function in jas_stream.c in JasPer before 1.900.10 allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via a crafted BMP image to the imginfo command."}, {"lang": "es", "value": "Vulnerabilidad de liberaci\u00f3n doble en la funci\u00f3n mem_close en jas_stream.c en JasPer en versiones anteriores a 1.900.10 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (ca\u00edda) o posiblemente ejecutar c\u00f3digo arbitrario a trav\u00e9s de una imagen BMP manipulada al comando imginfo."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jasper_project:jasper:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.900.5", "matchCriteriaId": "889A552E-6A6B-4CD4-9062-D409691344A0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.2:*:*:*:*:*:*:*", "matchCriteriaId": "03117DF1-3BEC-4B8D-AD63-DBBDB2126081"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:23:*:*:*:*:*:*:*", "matchCriteriaId": "E79AB8DD-C907-4038-A931-1A5A4CFB6A5B"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2016-11/msg00010.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2017/dsa-3785", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2016/08/23/6", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/10/16/14", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/93587", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1208", "source": "cve@mitre.org"}, {"url": "https://blogs.gentoo.org/ago/2016/10/16/jasper-double-free-in-mem_close-jas_stream-c/", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1385507", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/mdadams/jasper/commit/44a524e367597af58d6265ae2014468b334d0309", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/22FCKKHQCQ3S6TZY5G44EFDTMWOJXJRD/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mdadams/jasper/commit/44a524e367597af58d6265ae2014468b334d0309"}}