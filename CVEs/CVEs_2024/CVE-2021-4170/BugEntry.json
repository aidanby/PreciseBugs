{"buggy_code": ["/**\n * Created by SpeedProg on 05.04.2015.\n */\n/* global Bloodhound, language, Modernizr, tinymce, getPath */\n\nif ($(\"#description\").length) {\n    tinymce.init({\n        selector: \"#description\",\n        plugins: 'code',\n        branding: false,\n        menubar: \"edit view format\",\n        language: language\n    });\n}\n\nif ($(\".tiny_editor\").length) {\n    tinymce.init({\n        selector: \".tiny_editor\",\n        plugins: 'code',\n        branding: false,\n        menubar: \"edit view format\",\n        language: language\n    });\n}\n\n$(\".datepicker\").datepicker({\n    format: \"yyyy-mm-dd\",\n    language: language\n}).on(\"change\", function () {\n    // Show localized date over top of the standard YYYY-MM-DD date\n    var pubDate;\n    var results = /(\\d{4})[-\\/\\\\](\\d{1,2})[-\\/\\\\](\\d{1,2})/.exec(this.value); // YYYY-MM-DD\n    if (results) {\n        pubDate = new Date(results[1], parseInt(results[2], 10) - 1, results[3]) || new Date(this.value);\n        $(this).next('input')\n            .val(pubDate.toLocaleDateString(language))\n            .removeClass(\"hidden\");\n    }\n}).trigger(\"change\");\n\n$(\".datepicker_delete\").click(function() {\n    var inputs = $(this).parent().siblings('input');\n    $(inputs[0]).data('datepicker').clearDates();\n    $(inputs[1]).addClass('hidden');\n});\n\n\n/*\nTakes a prefix, query typeahead callback, Bloodhound typeahead adapter\n and returns the completions it gets from the bloodhound engine prefixed.\n */\nfunction prefixedSource(prefix, query, cb, source) {\n    function async(retArray) {\n        retArray = retArray || [];\n        var matches = [];\n        for (var i = 0; i < retArray.length; i++) {\n            var obj = {name : prefix + retArray[i].name};\n            matches.push(obj);\n        }\n        cb(matches);\n    }\n    source.search(query, cb, async);\n}\n\nfunction sourceSplit(query, cb, split, source) {\n    var tokens = query.split(split);\n    var currentSource = tokens[tokens.length - 1].trim();\n\n    tokens.splice(tokens.length - 1, 1); // remove last element\n    var prefix = \"\";\n    var newSplit;\n    if (split === \"&\") {\n        newSplit = \" \" + split + \" \";\n    } else {\n        newSplit = split + \" \";\n    }\n    for (var i = 0; i < tokens.length; i++) {\n        prefix += tokens[i].trim() + newSplit;\n    }\n    prefixedSource(prefix, currentSource, cb, source);\n}\n\nvar authors = new Bloodhound({\n    name: \"authors\",\n    identify: function(obj) { return obj.name; },\n    datumTokenizer: function datumTokenizer(datum) {\n        return [datum.name];\n    },\n    queryTokenizer: Bloodhound.tokenizers.whitespace,\n    remote: {\n        url: getPath() + \"/get_authors_json?q=%QUERY\",\n        wildcard: '%QUERY',\n    },\n});\n\n$(\".form-group #bookAuthor\").typeahead(\n    {\n        highlight: true,\n        minLength: 1,\n        hint: true\n    }, {\n        name: \"authors\",\n        display: 'name',\n        source: function source(query, cb, asyncResults) {\n            return sourceSplit(query, cb, \"&\", authors);\n        }\n    }\n);\n\n\nvar series = new Bloodhound({\n    name: \"series\",\n    datumTokenizer: function datumTokenizer(datum) {\n        return [datum.name];\n    },\n    // queryTokenizer: Bloodhound.tokenizers.whitespace,\n    queryTokenizer: function queryTokenizer(query) {\n        return [query];\n    },\n    remote: {\n        url: getPath() + \"/get_series_json?q=%QUERY\",\n        wildcard: '%QUERY',\n        /*replace: function replace(url, query) {\n            return url + encodeURIComponent(query);\n        }*/\n    }\n});\n$(\".form-group #series\").typeahead(\n    {\n        highlight: true,\n        minLength: 0,\n        hint: true\n    }, {\n        name: \"series\",\n        displayKey: \"name\",\n        source: series\n    }\n);\n\nvar tags = new Bloodhound({\n    name: \"tags\",\n    datumTokenizer: function datumTokenizer(datum) {\n        return [datum.name];\n    },\n    queryTokenizer: function queryTokenizer(query) {\n        var tokens = query.split(\",\");\n        tokens = [tokens[tokens.length - 1].trim()];\n        return tokens;\n    },\n    remote: {\n        url: getPath() + \"/get_tags_json?q=%QUERY\",\n        wildcard: '%QUERY'\n    }\n});\n\n$(\".form-group #tags\").typeahead(\n    {\n        highlight: true,\n        minLength: 0,\n        hint: true\n    }, {\n        name: \"tags\",\n        display: \"name\",\n        source: function source(query, cb, asyncResults) {\n            return sourceSplit(query, cb, \",\", tags);\n        }\n    }\n);\n\nvar languages = new Bloodhound({\n    name: \"languages\",\n    datumTokenizer: function datumTokenizer(datum) {\n        return [datum.name];\n    },\n    queryTokenizer: function queryTokenizer(query) {\n        return [query];\n    },\n    remote: {\n        url: getPath() + \"/get_languages_json?q=%QUERY\",\n        wildcard: '%QUERY'\n        /*replace: function replace(url, query) {\n            return url + encodeURIComponent(query);\n        }*/\n    }\n});\n\n$(\".form-group #languages\").typeahead(\n    {\n        highlight: true, minLength: 0,\n        hint: true\n    }, {\n        name: \"languages\",\n        display: \"name\",\n        source: function source(query, cb, asyncResults) {\n            return sourceSplit(query, cb, \",\", languages);\n        }\n    }\n);\n\nvar publishers = new Bloodhound({\n    name: \"publisher\",\n    datumTokenizer: function datumTokenizer(datum) {\n        return [datum.name];\n    },\n    queryTokenizer: Bloodhound.tokenizers.whitespace,\n    remote: {\n        url: getPath() + \"/get_publishers_json?q=%QUERY\",\n        wildcard: '%QUERY'\n    }\n});\n\n$(\".form-group #publisher\").typeahead(\n    {\n        highlight: true, minLength: 0,\n        hint: true\n    }, {\n        name: \"publishers\",\n        displayKey: \"name\",\n        source: publishers\n    }\n);\n\n$(\"#search\").on(\"change input.typeahead:selected\", function(event) {\n    if (event.target.type === \"search\" && event.target.tagName === \"INPUT\") {\n        return;\n    }\n    var form = $(\"form\").serialize();\n    $.getJSON( getPath() + \"/get_matching_tags\", form, function( data ) {\n        $(\".tags_click\").each(function() {\n            if ($.inArray(parseInt($(this).val(), 10), data.tags) === -1) {\n                if (!$(this).prop(\"selected\")) {\n                    $(this).prop(\"disabled\", true);\n                }\n            } else {\n                $(this).prop(\"disabled\", false);\n            }\n        });\n        $(\"#include_tag option:selected\").each(function () {\n            $(\"#exclude_tag\").find(\"[value=\" + $(this).val() + \"]\").prop(\"disabled\", true);\n        });\n        $(\"#include_tag\").selectpicker(\"refresh\");\n        $(\"#exclude_tag\").selectpicker(\"refresh\");\n    });\n});\n\n$(\"#btn-upload-format\").on(\"change\", function () {\n    var filename = $(this).val();\n    if (filename.substring(3, 11) === \"fakepath\") {\n        filename = filename.substring(12);\n    } // Remove c:\\fake at beginning from localhost chrome\n    $(\"#upload-format\").html(filename);\n});\n\n$(\"#btn-upload-cover\").on(\"change\", function () {\n    var filename = $(this).val();\n    if (filename.substring(3, 11) === \"fakepath\") {\n        filename = filename.substring(12);\n    } // Remove c:\\fake at beginning from localhost chrome\n    $(\"#upload-cover\").html(filename);\n});\n\n$(\"#xchange\").click(function () {\n    this.blur();\n    var title = $(\"#book_title\").val();\n    $(\"#book_title\").val($(\"#bookAuthor\").val());\n    $(\"#bookAuthor\").val(title);\n});\n\n"], "fixing_code": ["/**\n * Created by SpeedProg on 05.04.2015.\n */\n/* global Bloodhound, language, Modernizr, tinymce, getPath */\n\nif ($(\"#description\").length) {\n    tinymce.init({\n        selector: \"#description\",\n        plugins: 'code',\n        branding: false,\n        menubar: \"edit view format\",\n        language: language\n    });\n}\n\nif ($(\".tiny_editor\").length) {\n    tinymce.init({\n        selector: \".tiny_editor\",\n        plugins: 'code',\n        branding: false,\n        menubar: \"edit view format\",\n        language: language\n    });\n}\n\n$(\".datepicker\").datepicker({\n    format: \"yyyy-mm-dd\",\n    language: language\n}).on(\"change\", function () {\n    // Show localized date over top of the standard YYYY-MM-DD date\n    var pubDate;\n    var results = /(\\d{4})[-\\/\\\\](\\d{1,2})[-\\/\\\\](\\d{1,2})/.exec(this.value); // YYYY-MM-DD\n    if (results) {\n        pubDate = new Date(results[1], parseInt(results[2], 10) - 1, results[3]) || new Date(this.value);\n        $(this).next('input')\n            .val(pubDate.toLocaleDateString(language))\n            .removeClass(\"hidden\");\n    }\n}).trigger(\"change\");\n\n$(\".datepicker_delete\").click(function() {\n    var inputs = $(this).parent().siblings('input');\n    $(inputs[0]).data('datepicker').clearDates();\n    $(inputs[1]).addClass('hidden');\n});\n\n\n/*\nTakes a prefix, query typeahead callback, Bloodhound typeahead adapter\n and returns the completions it gets from the bloodhound engine prefixed.\n */\nfunction prefixedSource(prefix, query, cb, source) {\n    function async(retArray) {\n        retArray = retArray || [];\n        var matches = [];\n        for (var i = 0; i < retArray.length; i++) {\n            var obj = {name : prefix + retArray[i].name};\n            matches.push(obj);\n        }\n        cb(matches);\n    }\n    source.search(query, cb, async);\n}\n\nfunction sourceSplit(query, cb, split, source) {\n    var tokens = query.split(split);\n    var currentSource = tokens[tokens.length - 1].trim();\n\n    tokens.splice(tokens.length - 1, 1); // remove last element\n    var prefix = \"\";\n    var newSplit;\n    if (split === \"&\") {\n        newSplit = \" \" + split + \" \";\n    } else {\n        newSplit = split + \" \";\n    }\n    for (var i = 0; i < tokens.length; i++) {\n        prefix += tokens[i].trim() + newSplit;\n    }\n    prefixedSource(prefix, currentSource, cb, source);\n}\n\nvar authors = new Bloodhound({\n    name: \"authors\",\n    identify: function(obj) { return obj.name; },\n    datumTokenizer: function datumTokenizer(datum) {\n        return [datum.name];\n    },\n    queryTokenizer: Bloodhound.tokenizers.whitespace,\n    remote: {\n        url: getPath() + \"/get_authors_json?q=%QUERY\",\n        wildcard: '%QUERY',\n    },\n});\n\n$(\".form-group #bookAuthor\").typeahead(\n    {\n        highlight: true,\n        minLength: 1,\n        hint: true\n    }, {\n        name: \"authors\",\n        display: 'name',\n        source: function source(query, cb, asyncResults) {\n            return sourceSplit(query, cb, \"&\", authors);\n        }\n    }\n);\n\n\nvar series = new Bloodhound({\n    name: \"series\",\n    datumTokenizer: function datumTokenizer(datum) {\n        return [datum.name];\n    },\n    // queryTokenizer: Bloodhound.tokenizers.whitespace,\n    queryTokenizer: function queryTokenizer(query) {\n        return [query];\n    },\n    remote: {\n        url: getPath() + \"/get_series_json?q=%QUERY\",\n        wildcard: '%QUERY',\n        /*replace: function replace(url, query) {\n            return url + encodeURIComponent(query);\n        }*/\n    }\n});\n$(\".form-group #series\").typeahead(\n    {\n        highlight: true,\n        minLength: 0,\n        hint: true\n    }, {\n        name: \"series\",\n        displayKey: \"name\",\n        source: series\n    }\n);\n\nvar tags = new Bloodhound({\n    name: \"tags\",\n    datumTokenizer: function datumTokenizer(datum) {\n        return [datum.name];\n    },\n    queryTokenizer: function queryTokenizer(query) {\n        var tokens = query.split(\",\");\n        tokens = [tokens[tokens.length - 1].trim()];\n        return tokens;\n    },\n    remote: {\n        url: getPath() + \"/get_tags_json?q=%QUERY\",\n        wildcard: '%QUERY'\n    }\n});\n\n$(\".form-group #tags\").typeahead(\n    {\n        highlight: true,\n        minLength: 0,\n        hint: true\n    }, {\n        name: \"tags\",\n        display: \"name\",\n        source: function source(query, cb, asyncResults) {\n            return sourceSplit(query, cb, \",\", tags);\n        }\n    }\n);\n\nvar languages = new Bloodhound({\n    name: \"languages\",\n    datumTokenizer: function datumTokenizer(datum) {\n        return [datum.name];\n    },\n    queryTokenizer: function queryTokenizer(query) {\n        return [query];\n    },\n    remote: {\n        url: getPath() + \"/get_languages_json?q=%QUERY\",\n        wildcard: '%QUERY'\n        /*replace: function replace(url, query) {\n            return url + encodeURIComponent(query);\n        }*/\n    }\n});\n\n$(\".form-group #languages\").typeahead(\n    {\n        highlight: true, minLength: 0,\n        hint: true\n    }, {\n        name: \"languages\",\n        display: \"name\",\n        source: function source(query, cb, asyncResults) {\n            return sourceSplit(query, cb, \",\", languages);\n        }\n    }\n);\n\nvar publishers = new Bloodhound({\n    name: \"publisher\",\n    datumTokenizer: function datumTokenizer(datum) {\n        return [datum.name];\n    },\n    queryTokenizer: Bloodhound.tokenizers.whitespace,\n    remote: {\n        url: getPath() + \"/get_publishers_json?q=%QUERY\",\n        wildcard: '%QUERY'\n    }\n});\n\n$(\".form-group #publisher\").typeahead(\n    {\n        highlight: true, minLength: 0,\n        hint: true\n    }, {\n        name: \"publishers\",\n        displayKey: \"name\",\n        source: publishers\n    }\n);\n\n$(\"#search\").on(\"change input.typeahead:selected\", function(event) {\n    if (event.target.type === \"search\" && event.target.tagName === \"INPUT\") {\n        return;\n    }\n    var form = $(\"form\").serialize();\n    $.getJSON( getPath() + \"/get_matching_tags\", form, function( data ) {\n        $(\".tags_click\").each(function() {\n            if ($.inArray(parseInt($(this).val(), 10), data.tags) === -1) {\n                if (!$(this).prop(\"selected\")) {\n                    $(this).prop(\"disabled\", true);\n                }\n            } else {\n                $(this).prop(\"disabled\", false);\n            }\n        });\n        $(\"#include_tag option:selected\").each(function () {\n            $(\"#exclude_tag\").find(\"[value=\" + $(this).val() + \"]\").prop(\"disabled\", true);\n        });\n        $(\"#include_tag\").selectpicker(\"refresh\");\n        $(\"#exclude_tag\").selectpicker(\"refresh\");\n    });\n});\n\n$(\"#btn-upload-format\").on(\"change\", function () {\n    var filename = $(this).val();\n    if (filename.substring(3, 11) === \"fakepath\") {\n        filename = filename.substring(12);\n    } // Remove c:\\fake at beginning from localhost chrome\n    $(\"#upload-format\").text(filename);\n});\n\n$(\"#btn-upload-cover\").on(\"change\", function () {\n    var filename = $(this).val();\n    if (filename.substring(3, 11) === \"fakepath\") {\n        filename = filename.substring(12);\n    } // Remove c:\\fake at beginning from localhost chrome\n    $(\"#upload-cover\").text(filename);\n});\n\n$(\"#xchange\").click(function () {\n    this.blur();\n    var title = $(\"#book_title\").val();\n    $(\"#book_title\").val($(\"#bookAuthor\").val());\n    $(\"#bookAuthor\").val(title);\n});\n\n"], "filenames": ["cps/static/js/edit_books.js"], "buggy_code_start_loc": [251], "buggy_code_end_loc": [260], "fixing_code_start_loc": [251], "fixing_code_end_loc": [260], "type": "CWE-79", "message": "calibre-web is vulnerable to Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "other": {"cve": {"id": "CVE-2021-4170", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-16T21:15:07.900", "lastModified": "2022-01-22T03:12:41.697", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "calibre-web is vulnerable to Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"}, {"lang": "es", "value": "calibre-web es vulnerable a una Neutralizaci\u00f3n Inapropiada de Entradas Durante la Generaci\u00f3n de P\u00e1ginas Web (\"Cross-site Scripting\")"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.1, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:calibre-web_project:calibre-web:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.6.15", "matchCriteriaId": "3F8C0D67-A1E0-42E6-A31D-5590125DEADB"}]}]}], "references": [{"url": "https://github.com/janeczku/calibre-web/commit/7ad419dc8c12180e842a82118f4866ac3d074bc5", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/ff395101-e392-401d-ab4f-579c63fbf6a0", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/janeczku/calibre-web/commit/7ad419dc8c12180e842a82118f4866ac3d074bc5"}}