{"buggy_code": ["<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace CustomerManagementFrameworkBundle\\CustomerList\\Exporter;\n\nuse CustomerManagementFrameworkBundle\\Model\\CustomerInterface;\nuse Pimcore\\Model\\DataObject\\ClassDefinition;\nuse Pimcore\\Model\\DataObject\\Listing\\Concrete;\n\nabstract class AbstractExporter implements ExporterInterface\n{\n    /**\n     * @var string\n     */\n    protected $name;\n\n    /**\n     * @var Concrete\n     */\n    protected $listing;\n\n    /**\n     * Properties to export\n     *\n     * @var array\n     */\n    protected $properties;\n\n    /**\n     * @var bool\n     */\n    protected $exportSegmentsAsColumns;\n\n    /**\n     * remember column order of segment column headers if $exportSegmentsAsColumns is enabled\n     *\n     * @var array\n     */\n    protected $segmentColumnOrder = [];\n\n    const COLUMNS = 'columns';\n    const ROWS = 'rows';\n    const SEGMENT_IDS = 'segmentIds';\n\n    /**\n     * @param string $name\n     * @param array $properties\n     * @param bool $exportSegmentsAsColumns\n     */\n    public function __construct($name, array $properties, $exportSegmentsAsColumns)\n    {\n        $this->setName($name);\n        $this->setProperties($properties);\n        $this->setExportSegmentsAsColumns($exportSegmentsAsColumns);\n    }\n\n    /**\n     * @return string\n     */\n    public function getName()\n    {\n        return $this->name;\n    }\n\n    /**\n     * @param string $name\n     */\n    public function setName($name)\n    {\n        $this->name = $name;\n    }\n\n    /**\n     * @return array\n     */\n    public function getProperties()\n    {\n        return $this->properties;\n    }\n\n    /**\n     * @param array $properties\n     */\n    public function setProperties(array $properties)\n    {\n        $this->properties = $properties;\n    }\n\n    /**\n     * @return Concrete\n     */\n    public function getListing()\n    {\n        return $this->listing;\n    }\n\n    /**\n     * @param Concrete $listing\n     */\n    public function setListing(Concrete $listing)\n    {\n        $this->listing = $listing;\n    }\n\n    /**\n     * Run the export\n     */\n    public function getExportData()\n    {\n        if (null === $this->listing) {\n            throw new \\RuntimeException('Listing is not set');\n        }\n\n        $rows = [];\n        $allSegmentIds = [];\n        /** @var CustomerInterface $customer */\n        foreach ($this->listing as $customer) {\n            $classDefinition = $customer->getClass();\n            $row = [self::COLUMNS => [], self::SEGMENT_IDS => []];\n            foreach ($this->properties as $property) {\n                if ($fd = $classDefinition->getFieldDefinition($property)) {\n                    $value = $fd->getForCsvExport($customer);\n                } else {\n                    $getter = 'get'.ucfirst($property);\n                    $value = $customer->$getter();\n                }\n\n                $row[self::COLUMNS][] = (string) $value;\n            }\n\n            if ($this->getExportSegmentsAsColumns()) {\n                if ($segments = $customer->getAllSegments()) {\n                    foreach ($segments as $segment) {\n                        $row[self::SEGMENT_IDS][] = $segment->getId();\n                        $allSegmentIds[] = $segment->getId();\n                    }\n                }\n            }\n\n            $rows[] = $row;\n        }\n\n        return [\n            self::ROWS => $rows,\n            self::SEGMENT_IDS => array_unique($allSegmentIds)\n        ];\n    }\n\n    /**\n     * @return bool\n     */\n    public function getExportSegmentsAsColumns()\n    {\n        return $this->exportSegmentsAsColumns;\n    }\n\n    /**\n     * @param bool $exportSegmentsAsColumns\n     */\n    public function setExportSegmentsAsColumns($exportSegmentsAsColumns)\n    {\n        $this->exportSegmentsAsColumns = $exportSegmentsAsColumns;\n    }\n\n    /**\n     * @param array $exportData\n     *\n     * @return array\n     */\n    protected function getHeaderTitles(array $exportData)\n    {\n        $titles = [];\n        foreach ($this->properties as $property) {\n            $definition = $this->getPropertyDefinition($property);\n            if ($definition) {\n                $titles[] = $definition->getTitle();\n            } else {\n                $titles[] = $property;\n            }\n        }\n\n        if ($this->getExportSegmentsAsColumns() && sizeof($exportData[self::SEGMENT_IDS])) {\n            $list = \\Pimcore::getContainer()->get('cmf.segment_manager')->getSegments();\n            array_walk($exportData[self::SEGMENT_IDS], 'intval');\n            $list->addConditionParam('o_id in(' . implode(', ', $exportData[self::SEGMENT_IDS]) .')');\n            $list->setOrderKey('concat(o_path, o_key)', false);\n\n            $i = sizeof($titles);\n            foreach ($list as $item) {\n                $segmentName = [];\n                if ($group = $item->getGroup()) {\n                    $segmentName[] = $group->getName() ?: $group->getReference();\n                }\n                $segmentName[] = $item->getName() ?: $item->getReference();\n                $title = 'Segment ' . implode(':', $segmentName);\n                $titles[] = $title;\n                $this->segmentColumnOrder[$item->getId()] = $i;\n                $i++;\n            }\n        }\n\n        return $titles;\n    }\n\n    /**\n     * @param array $exportData\n     *\n     * @return array\n     */\n    protected function getExportRows(array $exportData)\n    {\n        return $exportData[self::ROWS];\n    }\n\n    protected function getColumnValuesFromExportRow($exportRow)\n    {\n        $columns = $exportRow[self::COLUMNS];\n\n        if (is_array($exportRow[self::SEGMENT_IDS])) {\n            foreach ($this->segmentColumnOrder as $column) {\n                $columns[$column] = 0;\n            }\n            foreach ($exportRow[self::SEGMENT_IDS] as $id) {\n                $columns[$this->segmentColumnOrder[$id]] = '1';\n            }\n        }\n\n        return $columns;\n    }\n\n    /**\n     * @return $this\n     */\n    abstract protected function render(array $exportData);\n\n    /**\n     * @param string $property\n     *\n     * @return ClassDefinition\\Data|null\n     */\n    protected function getPropertyDefinition($property)\n    {\n        $classDefinition = ClassDefinition::getById($this->listing->getClassId());\n\n        return $classDefinition->getFieldDefinition($property);\n    }\n}\n"], "fixing_code": ["<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace CustomerManagementFrameworkBundle\\CustomerList\\Exporter;\n\nuse CustomerManagementFrameworkBundle\\Model\\CustomerInterface;\nuse Pimcore\\Model\\DataObject\\ClassDefinition;\nuse Pimcore\\Model\\DataObject\\Listing\\Concrete;\nuse Pimcore\\Model\\Element\\Service;\n\nabstract class AbstractExporter implements ExporterInterface\n{\n    /**\n     * @var string\n     */\n    protected $name;\n\n    /**\n     * @var Concrete\n     */\n    protected $listing;\n\n    /**\n     * Properties to export\n     *\n     * @var array\n     */\n    protected $properties;\n\n    /**\n     * @var bool\n     */\n    protected $exportSegmentsAsColumns;\n\n    /**\n     * remember column order of segment column headers if $exportSegmentsAsColumns is enabled\n     *\n     * @var array\n     */\n    protected $segmentColumnOrder = [];\n\n    const COLUMNS = 'columns';\n    const ROWS = 'rows';\n    const SEGMENT_IDS = 'segmentIds';\n\n    /**\n     * @param string $name\n     * @param array $properties\n     * @param bool $exportSegmentsAsColumns\n     */\n    public function __construct($name, array $properties, $exportSegmentsAsColumns)\n    {\n        $this->setName($name);\n        $this->setProperties($properties);\n        $this->setExportSegmentsAsColumns($exportSegmentsAsColumns);\n    }\n\n    /**\n     * @return string\n     */\n    public function getName()\n    {\n        return $this->name;\n    }\n\n    /**\n     * @param string $name\n     */\n    public function setName($name)\n    {\n        $this->name = $name;\n    }\n\n    /**\n     * @return array\n     */\n    public function getProperties()\n    {\n        return $this->properties;\n    }\n\n    /**\n     * @param array $properties\n     */\n    public function setProperties(array $properties)\n    {\n        $this->properties = $properties;\n    }\n\n    /**\n     * @return Concrete\n     */\n    public function getListing()\n    {\n        return $this->listing;\n    }\n\n    /**\n     * @param Concrete $listing\n     */\n    public function setListing(Concrete $listing)\n    {\n        $this->listing = $listing;\n    }\n\n    /**\n     * Run the export\n     */\n    public function getExportData()\n    {\n        if (null === $this->listing) {\n            throw new \\RuntimeException('Listing is not set');\n        }\n\n        $rows = [];\n        $allSegmentIds = [];\n        /** @var CustomerInterface $customer */\n        foreach ($this->listing as $customer) {\n            $classDefinition = $customer->getClass();\n            $row = [self::COLUMNS => [], self::SEGMENT_IDS => []];\n            foreach ($this->properties as $property) {\n                if ($fd = $classDefinition->getFieldDefinition($property)) {\n                    $value = $fd->getForCsvExport($customer);\n                } else {\n                    $getter = 'get'.ucfirst($property);\n                    $value = $customer->$getter();\n                }\n\n                $row[self::COLUMNS][] = (string) $value;\n            }\n\n            if ($this->getExportSegmentsAsColumns()) {\n                if ($segments = $customer->getAllSegments()) {\n                    foreach ($segments as $segment) {\n                        $row[self::SEGMENT_IDS][] = $segment->getId();\n                        $allSegmentIds[] = $segment->getId();\n                    }\n                }\n            }\n\n            $row[self::COLUMNS] = Service::escapeCsvRecord($row[self::COLUMNS]);\n            $row[self::SEGMENT_IDS] = Service::escapeCsvRecord($row[self::SEGMENT_IDS]);\n            $rows[] = $row;\n        }\n\n        return [\n            self::ROWS => $rows,\n            self::SEGMENT_IDS => array_unique($allSegmentIds)\n        ];\n    }\n\n    /**\n     * @return bool\n     */\n    public function getExportSegmentsAsColumns()\n    {\n        return $this->exportSegmentsAsColumns;\n    }\n\n    /**\n     * @param bool $exportSegmentsAsColumns\n     */\n    public function setExportSegmentsAsColumns($exportSegmentsAsColumns)\n    {\n        $this->exportSegmentsAsColumns = $exportSegmentsAsColumns;\n    }\n\n    /**\n     * @param array $exportData\n     *\n     * @return array\n     */\n    protected function getHeaderTitles(array $exportData)\n    {\n        $titles = [];\n        foreach ($this->properties as $property) {\n            $definition = $this->getPropertyDefinition($property);\n            if ($definition) {\n                $titles[] = $definition->getTitle();\n            } else {\n                $titles[] = $property;\n            }\n        }\n\n        if ($this->getExportSegmentsAsColumns() && sizeof($exportData[self::SEGMENT_IDS])) {\n            $list = \\Pimcore::getContainer()->get('cmf.segment_manager')->getSegments();\n            array_walk($exportData[self::SEGMENT_IDS], 'intval');\n            $list->addConditionParam('o_id in(' . implode(', ', $exportData[self::SEGMENT_IDS]) .')');\n            $list->setOrderKey('concat(o_path, o_key)', false);\n\n            $i = sizeof($titles);\n            foreach ($list as $item) {\n                $segmentName = [];\n                if ($group = $item->getGroup()) {\n                    $segmentName[] = $group->getName() ?: $group->getReference();\n                }\n                $segmentName[] = $item->getName() ?: $item->getReference();\n                $title = 'Segment ' . implode(':', $segmentName);\n                $titles[] = $title;\n                $this->segmentColumnOrder[$item->getId()] = $i;\n                $i++;\n            }\n        }\n\n        return $titles;\n    }\n\n    /**\n     * @param array $exportData\n     *\n     * @return array\n     */\n    protected function getExportRows(array $exportData)\n    {\n        return $exportData[self::ROWS];\n    }\n\n    protected function getColumnValuesFromExportRow($exportRow)\n    {\n        $columns = $exportRow[self::COLUMNS];\n\n        if (is_array($exportRow[self::SEGMENT_IDS])) {\n            foreach ($this->segmentColumnOrder as $column) {\n                $columns[$column] = 0;\n            }\n            foreach ($exportRow[self::SEGMENT_IDS] as $id) {\n                $columns[$this->segmentColumnOrder[$id]] = '1';\n            }\n        }\n\n        return $columns;\n    }\n\n    /**\n     * @return $this\n     */\n    abstract protected function render(array $exportData);\n\n    /**\n     * @param string $property\n     *\n     * @return ClassDefinition\\Data|null\n     */\n    protected function getPropertyDefinition($property)\n    {\n        $classDefinition = ClassDefinition::getById($this->listing->getClassId());\n\n        return $classDefinition->getFieldDefinition($property);\n    }\n}\n"], "filenames": ["src/CustomerList/Exporter/AbstractExporter.php"], "buggy_code_start_loc": [20], "buggy_code_end_loc": [151], "fixing_code_start_loc": [21], "fixing_code_end_loc": [155], "type": "CWE-1236", "message": "Improper Neutralization of Formula Elements in a CSV File in GitHub repository pimcore/customer-data-framework prior to 3.3.9.", "other": {"cve": {"id": "CVE-2023-2629", "sourceIdentifier": "security@huntr.dev", "published": "2023-05-10T16:15:10.660", "lastModified": "2023-05-31T14:02:09.597", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Neutralization of Formula Elements in a CSV File in GitHub repository pimcore/customer-data-framework prior to 3.3.9."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:C/C:L/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 2.7}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1236"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pimcore:customer_management_framework:*:*:*:*:*:pimcore:*:*", "versionEndExcluding": "3.3.9", "matchCriteriaId": "11F1B8A1-060A-495D-81D3-46BF6E471CFB"}]}]}], "references": [{"url": "https://github.com/pimcore/customer-data-framework/commit/4e0105c3a78d20686a0c010faef27d2297b98803", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/821ff465-4754-42d1-9376-813c17f16a01", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pimcore/customer-data-framework/commit/4e0105c3a78d20686a0c010faef27d2297b98803"}}