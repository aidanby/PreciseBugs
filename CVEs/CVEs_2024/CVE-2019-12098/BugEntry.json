{"buggy_code": ["/*\n * Copyright (c) 1997 - 2008 Kungliga Tekniska H\u00f6gskolan\n * (Royal Institute of Technology, Stockholm, Sweden).\n * All rights reserved.\n *\n * Portions Copyright (c) 2009 Apple Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the Institute nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"krb5_locl.h\"\n#ifndef WIN32\n#include <heim-ipc.h>\n#endif /* WIN32 */\n\ntypedef struct krb5_get_init_creds_ctx {\n    KDCOptions flags;\n    krb5_creds cred;\n    krb5_addresses *addrs;\n    krb5_enctype *etypes;\n    krb5_preauthtype *pre_auth_types;\n    char *in_tkt_service;\n    unsigned nonce;\n    unsigned pk_nonce;\n\n    krb5_data req_buffer;\n    AS_REQ as_req;\n    int pa_counter;\n\n    /* password and keytab_data is freed on completion */\n    char *password;\n    krb5_keytab_key_proc_args *keytab_data;\n\n    krb5_pointer *keyseed;\n    krb5_s2k_proc keyproc;\n\n    krb5_get_init_creds_tristate req_pac;\n\n    krb5_pk_init_ctx pk_init_ctx;\n    int ic_flags;\n\n    struct {\n\tunsigned change_password:1;\n    } runflags;\n\n    int used_pa_types;\n#define  USED_PKINIT\t1\n#define  USED_PKINIT_W2K\t2\n#define  USED_ENC_TS_GUESS\t4\n#define  USED_ENC_TS_INFO\t8\n\n    METHOD_DATA md;\n    KRB_ERROR error;\n    AS_REP as_rep;\n    EncKDCRepPart enc_part;\n\n    krb5_prompter_fct prompter;\n    void *prompter_data;\n\n    struct pa_info_data *ppaid;\n    struct fast_state {\n\tenum PA_FX_FAST_REQUEST_enum type;\n\tunsigned int flags;\n#define KRB5_FAST_REPLY_KEY_USE_TO_ENCRYPT_THE_REPLY 1\n#define KRB5_FAST_REPLY_KEY_USE_IN_TRANSACTION 2\n#define KRB5_FAST_KDC_REPLY_KEY_REPLACED 4\n#define KRB5_FAST_REPLY_REPLY_VERIFED 8\n#define KRB5_FAST_STRONG 16\n#define KRB5_FAST_EXPECTED 32 /* in exchange with KDC, fast was discovered */\n#define KRB5_FAST_REQUIRED 64 /* fast required by action of caller */\n#define KRB5_FAST_DISABLED 128\n#define KRB5_FAST_AP_ARMOR_SERVICE 256\n\tkrb5_keyblock *reply_key;\n\tkrb5_ccache armor_ccache;\n\tkrb5_principal armor_service;\n\tkrb5_crypto armor_crypto;\n\tkrb5_keyblock armor_key;\n\tkrb5_keyblock *strengthen_key;\n    } fast_state;\n} krb5_get_init_creds_ctx;\n\n\nstruct pa_info_data {\n    krb5_enctype etype;\n    krb5_salt salt;\n    krb5_data *s2kparams;\n};\n\nstatic void\nfree_paid(krb5_context context, struct pa_info_data *ppaid)\n{\n    krb5_free_salt(context, ppaid->salt);\n    if (ppaid->s2kparams)\n\tkrb5_free_data(context, ppaid->s2kparams);\n}\n\nstatic krb5_error_code KRB5_CALLCONV\ndefault_s2k_func(krb5_context context, krb5_enctype type,\n\t\t krb5_const_pointer keyseed,\n\t\t krb5_salt salt, krb5_data *s2kparms,\n\t\t krb5_keyblock **key)\n{\n    krb5_error_code ret;\n    krb5_data password;\n    krb5_data opaque;\n\n    _krb5_debug(context, 5, \"krb5_get_init_creds: using default_s2k_func\");\n\n    password.data = rk_UNCONST(keyseed);\n    password.length = strlen(keyseed);\n    if (s2kparms)\n\topaque = *s2kparms;\n    else\n\tkrb5_data_zero(&opaque);\n\n    *key = malloc(sizeof(**key));\n    if (*key == NULL)\n\treturn ENOMEM;\n    ret = krb5_string_to_key_data_salt_opaque(context, type, password,\n\t\t\t\t\t      salt, opaque, *key);\n    if (ret) {\n\tfree(*key);\n\t*key = NULL;\n    }\n    return ret;\n}\n\nstatic void\nfree_init_creds_ctx(krb5_context context, krb5_init_creds_context ctx)\n{\n    if (ctx->etypes)\n\tfree(ctx->etypes);\n    if (ctx->pre_auth_types)\n\tfree (ctx->pre_auth_types);\n    if (ctx->in_tkt_service)\n\tfree(ctx->in_tkt_service);\n    if (ctx->keytab_data)\n\tfree(ctx->keytab_data);\n    if (ctx->password) {\n\tmemset(ctx->password, 0, strlen(ctx->password));\n\tfree(ctx->password);\n    }\n    /*\n     * FAST state (we don't close the armor_ccache because we might have\n     * to destroy it, and how would we know? also, the caller should\n     * take care of cleaning up the armor_ccache).\n     */\n    if (ctx->fast_state.armor_service)\n\tkrb5_free_principal(context, ctx->fast_state.armor_service);\n    if (ctx->fast_state.armor_crypto)\n\tkrb5_crypto_destroy(context, ctx->fast_state.armor_crypto);\n    if (ctx->fast_state.strengthen_key)\n\tkrb5_free_keyblock(context, ctx->fast_state.strengthen_key);\n    krb5_free_keyblock_contents(context, &ctx->fast_state.armor_key);\n\n    krb5_data_free(&ctx->req_buffer);\n    krb5_free_cred_contents(context, &ctx->cred);\n    free_METHOD_DATA(&ctx->md);\n    free_AS_REP(&ctx->as_rep);\n    free_EncKDCRepPart(&ctx->enc_part);\n    free_KRB_ERROR(&ctx->error);\n    free_AS_REQ(&ctx->as_req);\n    if (ctx->ppaid) {\n\tfree_paid(context, ctx->ppaid);\n\tfree(ctx->ppaid);\n    }\n    memset(ctx, 0, sizeof(*ctx));\n}\n\nstatic int\nget_config_time (krb5_context context,\n\t\t const char *realm,\n\t\t const char *name,\n\t\t int def)\n{\n    int ret;\n\n    ret = krb5_config_get_time (context, NULL,\n\t\t\t\t\"realms\",\n\t\t\t\trealm,\n\t\t\t\tname,\n\t\t\t\tNULL);\n    if (ret >= 0)\n\treturn ret;\n    ret = krb5_config_get_time (context, NULL,\n\t\t\t\t\"libdefaults\",\n\t\t\t\tname,\n\t\t\t\tNULL);\n    if (ret >= 0)\n\treturn ret;\n    return def;\n}\n\nstatic krb5_error_code\ninit_cred (krb5_context context,\n\t   krb5_creds *cred,\n\t   krb5_principal client,\n\t   krb5_deltat start_time,\n\t   krb5_get_init_creds_opt *options)\n{\n    krb5_error_code ret;\n    int tmp;\n    krb5_timestamp now;\n\n    krb5_timeofday (context, &now);\n\n    memset (cred, 0, sizeof(*cred));\n\n    if (client)\n\tret = krb5_copy_principal(context, client, &cred->client);\n    else\n\tret = krb5_get_default_principal(context, &cred->client);\n    if (ret)\n        goto out;\n\n    if (start_time)\n\tcred->times.starttime  = now + start_time;\n\n    if (options->flags & KRB5_GET_INIT_CREDS_OPT_TKT_LIFE)\n\ttmp = options->tkt_life;\n    else\n\ttmp = KRB5_TKT_LIFETIME_DEFAULT;\n    cred->times.endtime = now + tmp;\n\n    if ((options->flags & KRB5_GET_INIT_CREDS_OPT_RENEW_LIFE)) {\n\tif (options->renew_life > 0)\n\t    tmp = options->renew_life;\n\telse\n\t    tmp = KRB5_TKT_RENEW_LIFETIME_DEFAULT;\n\tcred->times.renew_till = now + tmp;\n    }\n\n    return 0;\n\nout:\n    krb5_free_cred_contents (context, cred);\n    return ret;\n}\n\n/*\n * Print a message (str) to the user about the expiration in `lr'\n */\n\nstatic void\nreport_expiration (krb5_context context,\n\t\t   krb5_prompter_fct prompter,\n\t\t   krb5_data *data,\n\t\t   const char *str,\n\t\t   time_t now)\n{\n    char *p = NULL;\n\n    if (asprintf(&p, \"%s%s\", str, ctime(&now)) < 0 || p == NULL)\n\treturn;\n    (*prompter)(context, data, NULL, p, 0, NULL);\n    free(p);\n}\n\n/*\n * Check the context, and in the case there is a expiration warning,\n * use the prompter to print the warning.\n *\n * @param context A Kerberos 5 context.\n * @param options An GIC options structure\n * @param ctx The krb5_init_creds_context check for expiration.\n */\n\nkrb5_error_code\nkrb5_process_last_request(krb5_context context,\n\t\t\t  krb5_get_init_creds_opt *options,\n\t\t\t  krb5_init_creds_context ctx)\n{\n    krb5_const_realm realm;\n    LastReq *lr;\n    krb5_boolean reported = FALSE;\n    krb5_timestamp sec;\n    time_t t;\n    size_t i;\n\n    /*\n     * First check if there is a API consumer.\n     */\n\n    realm = krb5_principal_get_realm (context, ctx->cred.client);\n    lr = &ctx->enc_part.last_req;\n\n    if (options && options->opt_private && options->opt_private->lr.func) {\n\tkrb5_last_req_entry **lre;\n\n\tlre = calloc(lr->len + 1, sizeof(*lre));\n\tif (lre == NULL)\n\t    return krb5_enomem(context);\n\tfor (i = 0; i < lr->len; i++) {\n\t    lre[i] = calloc(1, sizeof(*lre[i]));\n\t    if (lre[i] == NULL)\n\t\tbreak;\n\t    lre[i]->lr_type = lr->val[i].lr_type;\n\t    lre[i]->value = lr->val[i].lr_value;\n\t}\n\n\t(*options->opt_private->lr.func)(context, lre,\n\t\t\t\t\t options->opt_private->lr.ctx);\n\n\tfor (i = 0; i < lr->len; i++)\n\t    free(lre[i]);\n\tfree(lre);\n    }\n\n    /*\n     * Now check if we should prompt the user\n     */\n\n    if (ctx->prompter == NULL)\n        return 0;\n\n    krb5_timeofday (context, &sec);\n\n    t = sec + get_config_time (context,\n\t\t\t       realm,\n\t\t\t       \"warn_pwexpire\",\n\t\t\t       7 * 24 * 60 * 60);\n\n    for (i = 0; i < lr->len; ++i) {\n\tif (lr->val[i].lr_value <= t) {\n\t    switch (lr->val[i].lr_type) {\n\t    case LR_PW_EXPTIME :\n\t\treport_expiration(context, ctx->prompter,\n\t\t\t\t  ctx->prompter_data,\n\t\t\t\t  \"Your password will expire at \",\n\t\t\t\t  lr->val[i].lr_value);\n\t\treported = TRUE;\n\t\tbreak;\n\t    case LR_ACCT_EXPTIME :\n\t\treport_expiration(context, ctx->prompter,\n\t\t\t\t  ctx->prompter_data,\n\t\t\t\t  \"Your account will expire at \",\n\t\t\t\t  lr->val[i].lr_value);\n\t\treported = TRUE;\n\t\tbreak;\n            default:\n                break;\n\t    }\n\t}\n    }\n\n    if (!reported\n\t&& ctx->enc_part.key_expiration\n\t&& *ctx->enc_part.key_expiration <= t) {\n        report_expiration(context, ctx->prompter,\n\t\t\t  ctx->prompter_data,\n\t\t\t  \"Your password/account will expire at \",\n\t\t\t  *ctx->enc_part.key_expiration);\n    }\n    return 0;\n}\n\nstatic krb5_addresses no_addrs = { 0, NULL };\n\nstatic krb5_error_code\nget_init_creds_common(krb5_context context,\n\t\t      krb5_principal client,\n\t\t      krb5_deltat start_time,\n\t\t      krb5_get_init_creds_opt *options,\n\t\t      krb5_init_creds_context ctx)\n{\n    krb5_get_init_creds_opt *default_opt = NULL;\n    krb5_error_code ret;\n    krb5_enctype *etypes;\n    krb5_preauthtype *pre_auth_types;\n\n    memset(ctx, 0, sizeof(*ctx));\n\n    if (options == NULL) {\n\tconst char *realm = krb5_principal_get_realm(context, client);\n\n        krb5_get_init_creds_opt_alloc (context, &default_opt);\n\toptions = default_opt;\n\tkrb5_get_init_creds_opt_set_default_flags(context, NULL, realm, options);\n    }\n\n    if (options->opt_private) {\n\tif (options->opt_private->password) {\n\t    ret = krb5_init_creds_set_password(context, ctx,\n\t\t\t\t\t       options->opt_private->password);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\tctx->keyproc = options->opt_private->key_proc;\n\tctx->req_pac = options->opt_private->req_pac;\n\tctx->pk_init_ctx = options->opt_private->pk_init_ctx;\n\tctx->ic_flags = options->opt_private->flags;\n    } else\n\tctx->req_pac = KRB5_INIT_CREDS_TRISTATE_UNSET;\n\n    if (ctx->keyproc == NULL)\n\tctx->keyproc = default_s2k_func;\n\n    /* Enterprise name implicitly turns on canonicalize */\n    if ((ctx->ic_flags & KRB5_INIT_CREDS_CANONICALIZE) ||\n\tkrb5_principal_get_type(context, client) == KRB5_NT_ENTERPRISE_PRINCIPAL)\n\tctx->flags.canonicalize = 1;\n\n    ctx->pre_auth_types = NULL;\n    ctx->addrs = NULL;\n    ctx->etypes = NULL;\n    ctx->pre_auth_types = NULL;\n\n    ret = init_cred(context, &ctx->cred, client, start_time, options);\n    if (ret) {\n\tif (default_opt)\n\t    krb5_get_init_creds_opt_free(context, default_opt);\n\treturn ret;\n    }\n\n    ret = krb5_init_creds_set_service(context, ctx, NULL);\n    if (ret)\n\tgoto out;\n\n    if (options->flags & KRB5_GET_INIT_CREDS_OPT_FORWARDABLE)\n\tctx->flags.forwardable = options->forwardable;\n\n    if (options->flags & KRB5_GET_INIT_CREDS_OPT_PROXIABLE)\n\tctx->flags.proxiable = options->proxiable;\n\n    if (start_time)\n\tctx->flags.postdated = 1;\n    if (ctx->cred.times.renew_till)\n\tctx->flags.renewable = 1;\n    if (options->flags & KRB5_GET_INIT_CREDS_OPT_ADDRESS_LIST) {\n\tctx->addrs = options->address_list;\n    } else if (options->opt_private) {\n\tswitch (options->opt_private->addressless) {\n\tcase KRB5_INIT_CREDS_TRISTATE_UNSET:\n#if KRB5_ADDRESSLESS_DEFAULT == TRUE\n\t    ctx->addrs = &no_addrs;\n#else\n\t    ctx->addrs = NULL;\n#endif\n\t    break;\n\tcase KRB5_INIT_CREDS_TRISTATE_FALSE:\n\t    ctx->addrs = NULL;\n\t    break;\n\tcase KRB5_INIT_CREDS_TRISTATE_TRUE:\n\t    ctx->addrs = &no_addrs;\n\t    break;\n\t}\n    }\n    if (options->flags & KRB5_GET_INIT_CREDS_OPT_ETYPE_LIST) {\n\tif (ctx->etypes)\n\t    free(ctx->etypes);\n\n\tetypes = malloc((options->etype_list_length + 1)\n\t\t\t* sizeof(krb5_enctype));\n\tif (etypes == NULL) {\n\t    ret = krb5_enomem(context);\n\t    goto out;\n\t}\n\tmemcpy (etypes, options->etype_list,\n\t\toptions->etype_list_length * sizeof(krb5_enctype));\n\tetypes[options->etype_list_length] = ETYPE_NULL;\n\tctx->etypes = etypes;\n    }\n    if (options->flags & KRB5_GET_INIT_CREDS_OPT_PREAUTH_LIST) {\n\tpre_auth_types = malloc((options->preauth_list_length + 1)\n\t\t\t\t* sizeof(krb5_preauthtype));\n\tif (pre_auth_types == NULL) {\n\t    ret = krb5_enomem(context);\n\t    goto out;\n\t}\n\tmemcpy (pre_auth_types, options->preauth_list,\n\t\toptions->preauth_list_length * sizeof(krb5_preauthtype));\n\tpre_auth_types[options->preauth_list_length] = KRB5_PADATA_NONE;\n\tctx->pre_auth_types = pre_auth_types;\n    }\n    if (options->flags & KRB5_GET_INIT_CREDS_OPT_ANONYMOUS)\n\tctx->flags.request_anonymous = options->anonymous;\n    if (default_opt)\n        krb5_get_init_creds_opt_free(context, default_opt);\n    return 0;\n out:\n    if (default_opt)\n\tkrb5_get_init_creds_opt_free(context, default_opt);\n    return ret;\n}\n\nstatic krb5_error_code\nchange_password (krb5_context context,\n\t\t krb5_principal client,\n\t\t const char *password,\n\t\t char *newpw,\n\t\t size_t newpw_sz,\n\t\t krb5_prompter_fct prompter,\n\t\t void *data,\n\t\t krb5_get_init_creds_opt *old_options)\n{\n    krb5_prompt prompts[2];\n    krb5_error_code ret;\n    krb5_creds cpw_cred;\n    char buf1[BUFSIZ], buf2[BUFSIZ];\n    krb5_data password_data[2];\n    int result_code;\n    krb5_data result_code_string;\n    krb5_data result_string;\n    char *p;\n    krb5_get_init_creds_opt *options;\n\n    heim_assert(prompter != NULL, \"unexpected NULL prompter\");\n\n    memset (&cpw_cred, 0, sizeof(cpw_cred));\n\n    ret = krb5_get_init_creds_opt_alloc(context, &options);\n    if (ret)\n        return ret;\n    krb5_get_init_creds_opt_set_tkt_life (options, 60);\n    krb5_get_init_creds_opt_set_forwardable (options, FALSE);\n    krb5_get_init_creds_opt_set_proxiable (options, FALSE);\n    if (old_options &&\n        (old_options->flags & KRB5_GET_INIT_CREDS_OPT_PREAUTH_LIST))\n\tkrb5_get_init_creds_opt_set_preauth_list(options,\n\t\t\t\t\t\t old_options->preauth_list,\n\t\t\t\t\t\t old_options->preauth_list_length);\n    if (old_options &&\n        (old_options->flags & KRB5_GET_INIT_CREDS_OPT_CHANGE_PASSWORD_PROMPT))\n        krb5_get_init_creds_opt_set_change_password_prompt(options,\n                                                           old_options->change_password_prompt);\n\n    krb5_data_zero (&result_code_string);\n    krb5_data_zero (&result_string);\n\n    ret = krb5_get_init_creds_password (context,\n\t\t\t\t\t&cpw_cred,\n\t\t\t\t\tclient,\n\t\t\t\t\tpassword,\n\t\t\t\t\tprompter,\n\t\t\t\t\tdata,\n\t\t\t\t\t0,\n\t\t\t\t\t\"kadmin/changepw\",\n\t\t\t\t\toptions);\n    krb5_get_init_creds_opt_free(context, options);\n    if (ret)\n\tgoto out;\n\n    for(;;) {\n\tpassword_data[0].data   = buf1;\n\tpassword_data[0].length = sizeof(buf1);\n\n\tprompts[0].hidden = 1;\n\tprompts[0].prompt = \"New password: \";\n\tprompts[0].reply  = &password_data[0];\n\tprompts[0].type   = KRB5_PROMPT_TYPE_NEW_PASSWORD;\n\n\tpassword_data[1].data   = buf2;\n\tpassword_data[1].length = sizeof(buf2);\n\n\tprompts[1].hidden = 1;\n\tprompts[1].prompt = \"Repeat new password: \";\n\tprompts[1].reply  = &password_data[1];\n\tprompts[1].type   = KRB5_PROMPT_TYPE_NEW_PASSWORD_AGAIN;\n\n\tret = (*prompter) (context, data, NULL, \"Changing password\",\n\t\t\t   2, prompts);\n\tif (ret) {\n\t    memset (buf1, 0, sizeof(buf1));\n\t    memset (buf2, 0, sizeof(buf2));\n\t    goto out;\n\t}\n\n\tif (strcmp (buf1, buf2) == 0)\n\t    break;\n\tmemset (buf1, 0, sizeof(buf1));\n\tmemset (buf2, 0, sizeof(buf2));\n    }\n\n    ret = krb5_set_password (context,\n\t\t\t     &cpw_cred,\n\t\t\t     buf1,\n\t\t\t     client,\n\t\t\t     &result_code,\n\t\t\t     &result_code_string,\n\t\t\t     &result_string);\n    if (ret)\n\tgoto out;\n    if (asprintf(&p, \"%s: %.*s\\n\",\n\t\t result_code ? \"Error\" : \"Success\",\n\t\t (int)result_string.length,\n\t\t result_string.length > 0 ? (char*)result_string.data : \"\") < 0)\n    {\n\tret = ENOMEM;\n\tgoto out;\n    }\n\n    /* return the result */\n    (*prompter) (context, data, NULL, p, 0, NULL);\n\n    free (p);\n    if (result_code == 0) {\n\tstrlcpy (newpw, buf1, newpw_sz);\n\tret = 0;\n    } else {\n\tret = ENOTTY;\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"failed changing password\", \"\"));\n    }\n\nout:\n    memset (buf1, 0, sizeof(buf1));\n    memset (buf2, 0, sizeof(buf2));\n    krb5_data_free (&result_string);\n    krb5_data_free (&result_code_string);\n    krb5_free_cred_contents (context, &cpw_cred);\n    return ret;\n}\n\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_keyblock_key_proc (krb5_context context,\n\t\t\tkrb5_keytype type,\n\t\t\tkrb5_data *salt,\n\t\t\tkrb5_const_pointer keyseed,\n\t\t\tkrb5_keyblock **key)\n{\n    return krb5_copy_keyblock (context, keyseed, key);\n}\n\n/*\n *\n */\n\nstatic krb5_error_code\ninit_as_req (krb5_context context,\n\t     KDCOptions opts,\n\t     const krb5_creds *creds,\n\t     const krb5_addresses *addrs,\n\t     const krb5_enctype *etypes,\n\t     AS_REQ *a)\n{\n    krb5_error_code ret;\n\n    memset(a, 0, sizeof(*a));\n\n    a->pvno = 5;\n    a->msg_type = krb_as_req;\n    a->req_body.kdc_options = opts;\n    a->req_body.cname = malloc(sizeof(*a->req_body.cname));\n    if (a->req_body.cname == NULL) {\n\tret = krb5_enomem(context);\n\tgoto fail;\n    }\n    a->req_body.sname = malloc(sizeof(*a->req_body.sname));\n    if (a->req_body.sname == NULL) {\n\tret = krb5_enomem(context);\n\tgoto fail;\n    }\n\n    ret = _krb5_principal2principalname (a->req_body.cname, creds->client);\n    if (ret)\n\tgoto fail;\n    ret = copy_Realm(&creds->client->realm, &a->req_body.realm);\n    if (ret)\n\tgoto fail;\n\n    ret = _krb5_principal2principalname (a->req_body.sname, creds->server);\n    if (ret)\n\tgoto fail;\n\n    if(creds->times.starttime) {\n\ta->req_body.from = malloc(sizeof(*a->req_body.from));\n\tif (a->req_body.from == NULL) {\n\t    ret = krb5_enomem(context);\n\t    goto fail;\n\t}\n\t*a->req_body.from = creds->times.starttime;\n    }\n    if(creds->times.endtime){\n\tif ((ALLOC(a->req_body.till, 1)) != NULL)\n            *a->req_body.till = creds->times.endtime;\n        else {\n            ret = krb5_enomem(context);\n            goto fail;\n        }\n    }\n    if(creds->times.renew_till){\n\ta->req_body.rtime = malloc(sizeof(*a->req_body.rtime));\n\tif (a->req_body.rtime == NULL) {\n\t    ret = krb5_enomem(context);\n\t    goto fail;\n\t}\n\t*a->req_body.rtime = creds->times.renew_till;\n    }\n    a->req_body.nonce = 0;\n    ret = _krb5_init_etype(context,\n\t\t\t   KRB5_PDU_AS_REQUEST,\n\t\t\t   &a->req_body.etype.len,\n\t\t\t   &a->req_body.etype.val,\n\t\t\t   etypes);\n    if (ret)\n\tgoto fail;\n\n    /*\n     * This means no addresses\n     */\n\n    if (addrs && addrs->len == 0) {\n\ta->req_body.addresses = NULL;\n    } else {\n\ta->req_body.addresses = malloc(sizeof(*a->req_body.addresses));\n\tif (a->req_body.addresses == NULL) {\n\t    ret = krb5_enomem(context);\n\t    goto fail;\n\t}\n\n\tif (addrs)\n\t    ret = krb5_copy_addresses(context, addrs, a->req_body.addresses);\n\telse {\n\t    ret = krb5_get_all_client_addrs (context, a->req_body.addresses);\n\t    if(ret == 0 && a->req_body.addresses->len == 0) {\n\t\tfree(a->req_body.addresses);\n\t\ta->req_body.addresses = NULL;\n\t    }\n\t}\n\tif (ret)\n\t    goto fail;\n    }\n\n    a->req_body.enc_authorization_data = NULL;\n    a->req_body.additional_tickets = NULL;\n\n    a->padata = NULL;\n\n    return 0;\n fail:\n    free_AS_REQ(a);\n    memset(a, 0, sizeof(*a));\n    return ret;\n}\n\n\nstatic krb5_error_code\nset_paid(struct pa_info_data *paid, krb5_context context,\n\t krb5_enctype etype,\n\t krb5_salttype salttype, void *salt_string, size_t salt_len,\n\t krb5_data *s2kparams)\n{\n    paid->etype = etype;\n    paid->salt.salttype = salttype;\n    paid->salt.saltvalue.data = malloc(salt_len + 1);\n    if (paid->salt.saltvalue.data == NULL) {\n\tkrb5_clear_error_message(context);\n\treturn ENOMEM;\n    }\n    memcpy(paid->salt.saltvalue.data, salt_string, salt_len);\n    ((char *)paid->salt.saltvalue.data)[salt_len] = '\\0';\n    paid->salt.saltvalue.length = salt_len;\n    if (s2kparams) {\n\tkrb5_error_code ret;\n\n\tret = krb5_copy_data(context, s2kparams, &paid->s2kparams);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    krb5_free_salt(context, paid->salt);\n\t    return ret;\n\t}\n    } else\n\tpaid->s2kparams = NULL;\n\n    return 0;\n}\n\nstatic struct pa_info_data *\npa_etype_info2(krb5_context context,\n\t       const krb5_principal client,\n\t       const AS_REQ *asreq,\n\t       struct pa_info_data *paid,\n\t       heim_octet_string *data)\n{\n    krb5_error_code ret;\n    ETYPE_INFO2 e;\n    size_t sz;\n    size_t i, j;\n\n    memset(&e, 0, sizeof(e));\n    ret = decode_ETYPE_INFO2(data->data, data->length, &e, &sz);\n    if (ret)\n\tgoto out;\n    if (e.len == 0)\n\tgoto out;\n    for (j = 0; j < asreq->req_body.etype.len; j++) {\n\tfor (i = 0; i < e.len; i++) {\n\t    if (asreq->req_body.etype.val[j] == e.val[i].etype) {\n\t\tkrb5_salt salt;\n\t\tif (e.val[i].salt == NULL)\n\t\t    ret = krb5_get_pw_salt(context, client, &salt);\n\t\telse {\n\t\t    salt.saltvalue.data = *e.val[i].salt;\n\t\t    salt.saltvalue.length = strlen(*e.val[i].salt);\n\t\t    ret = 0;\n\t\t}\n\t\tif (ret == 0)\n\t\t    ret = set_paid(paid, context, e.val[i].etype,\n\t\t\t\t   KRB5_PW_SALT,\n\t\t\t\t   salt.saltvalue.data,\n\t\t\t\t   salt.saltvalue.length,\n\t\t\t\t   e.val[i].s2kparams);\n\t\tif (e.val[i].salt == NULL)\n\t\t    krb5_free_salt(context, salt);\n\t\tif (ret == 0) {\n\t\t    free_ETYPE_INFO2(&e);\n\t\t    return paid;\n\t\t}\n\t    }\n\t}\n    }\n out:\n    free_ETYPE_INFO2(&e);\n    return NULL;\n}\n\nstatic struct pa_info_data *\npa_etype_info(krb5_context context,\n\t      const krb5_principal client,\n\t      const AS_REQ *asreq,\n\t      struct pa_info_data *paid,\n\t      heim_octet_string *data)\n{\n    krb5_error_code ret;\n    ETYPE_INFO e;\n    size_t sz;\n    size_t i, j;\n\n    memset(&e, 0, sizeof(e));\n    ret = decode_ETYPE_INFO(data->data, data->length, &e, &sz);\n    if (ret)\n\tgoto out;\n    if (e.len == 0)\n\tgoto out;\n    for (j = 0; j < asreq->req_body.etype.len; j++) {\n\tfor (i = 0; i < e.len; i++) {\n\t    if (asreq->req_body.etype.val[j] == e.val[i].etype) {\n\t\tkrb5_salt salt;\n\t\tsalt.salttype = KRB5_PW_SALT;\n\t\tif (e.val[i].salt == NULL)\n\t\t    ret = krb5_get_pw_salt(context, client, &salt);\n\t\telse {\n\t\t    salt.saltvalue = *e.val[i].salt;\n\t\t    ret = 0;\n\t\t}\n\t\tif (e.val[i].salttype)\n\t\t    salt.salttype = *e.val[i].salttype;\n\t\tif (ret == 0) {\n\t\t    ret = set_paid(paid, context, e.val[i].etype,\n\t\t\t\t   salt.salttype,\n\t\t\t\t   salt.saltvalue.data,\n\t\t\t\t   salt.saltvalue.length,\n\t\t\t\t   NULL);\n\t\t    if (e.val[i].salt == NULL)\n\t\t\tkrb5_free_salt(context, salt);\n\t\t}\n\t\tif (ret == 0) {\n\t\t    free_ETYPE_INFO(&e);\n\t\t    return paid;\n\t\t}\n\t    }\n\t}\n    }\n out:\n    free_ETYPE_INFO(&e);\n    return NULL;\n}\n\nstatic struct pa_info_data *\npa_pw_or_afs3_salt(krb5_context context,\n\t\t   const krb5_principal client,\n\t\t   const AS_REQ *asreq,\n\t\t   struct pa_info_data *paid,\n\t\t   heim_octet_string *data)\n{\n    krb5_error_code ret;\n    if (paid->etype == KRB5_ENCTYPE_NULL)\n\treturn NULL;\n    ret = set_paid(paid, context,\n\t\t   paid->etype,\n\t\t   paid->salt.salttype,\n\t\t   data->data,\n\t\t   data->length,\n\t\t   NULL);\n    if (ret)\n\treturn NULL;\n    return paid;\n}\n\n\nstruct pa_info {\n    krb5_preauthtype type;\n    struct pa_info_data *(*salt_info)(krb5_context,\n\t\t\t\t      const krb5_principal,\n\t\t\t\t      const AS_REQ *,\n\t\t\t\t      struct pa_info_data *,\n\t\t\t\t      heim_octet_string *);\n};\n\nstatic struct pa_info pa_prefs[] = {\n    { KRB5_PADATA_ETYPE_INFO2, pa_etype_info2 },\n    { KRB5_PADATA_ETYPE_INFO, pa_etype_info },\n    { KRB5_PADATA_PW_SALT, pa_pw_or_afs3_salt },\n    { KRB5_PADATA_AFS3_SALT, pa_pw_or_afs3_salt }\n};\n\nstatic PA_DATA *\nfind_pa_data(const METHOD_DATA *md, unsigned type)\n{\n    size_t i;\n    if (md == NULL)\n\treturn NULL;\n    for (i = 0; i < md->len; i++)\n\tif (md->val[i].padata_type == type)\n\t    return &md->val[i];\n    return NULL;\n}\n\nstatic struct pa_info_data *\nprocess_pa_info(krb5_context context,\n\t\tconst krb5_principal client,\n\t\tconst AS_REQ *asreq,\n\t\tstruct pa_info_data *paid,\n\t\tMETHOD_DATA *md)\n{\n    struct pa_info_data *p = NULL;\n    size_t i;\n\n    for (i = 0; p == NULL && i < sizeof(pa_prefs)/sizeof(pa_prefs[0]); i++) {\n\tPA_DATA *pa = find_pa_data(md, pa_prefs[i].type);\n\tif (pa == NULL)\n\t    continue;\n\tpaid->salt.salttype = (krb5_salttype)pa_prefs[i].type;\n\tp = (*pa_prefs[i].salt_info)(context, client, asreq,\n\t\t\t\t     paid, &pa->padata_value);\n    }\n    return p;\n}\n\nstatic krb5_error_code\nmake_pa_enc_timestamp(krb5_context context, METHOD_DATA *md,\n\t\t      krb5_enctype etype, krb5_keyblock *key)\n{\n    PA_ENC_TS_ENC p;\n    unsigned char *buf;\n    size_t buf_size;\n    size_t len = 0;\n    EncryptedData encdata;\n    krb5_error_code ret;\n    int32_t usec;\n    int usec2;\n    krb5_crypto crypto;\n\n    krb5_us_timeofday (context, &p.patimestamp, &usec);\n    usec2         = usec;\n    p.pausec      = &usec2;\n\n    ASN1_MALLOC_ENCODE(PA_ENC_TS_ENC, buf, buf_size, &p, &len, ret);\n    if (ret)\n\treturn ret;\n    if(buf_size != len)\n\tkrb5_abortx(context, \"internal error in ASN.1 encoder\");\n\n    ret = krb5_crypto_init(context, key, 0, &crypto);\n    if (ret) {\n\tfree(buf);\n\treturn ret;\n    }\n    ret = krb5_encrypt_EncryptedData(context,\n\t\t\t\t     crypto,\n\t\t\t\t     KRB5_KU_PA_ENC_TIMESTAMP,\n\t\t\t\t     buf,\n\t\t\t\t     len,\n\t\t\t\t     0,\n\t\t\t\t     &encdata);\n    free(buf);\n    krb5_crypto_destroy(context, crypto);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(EncryptedData, buf, buf_size, &encdata, &len, ret);\n    free_EncryptedData(&encdata);\n    if (ret)\n\treturn ret;\n    if(buf_size != len)\n\tkrb5_abortx(context, \"internal error in ASN.1 encoder\");\n\n    ret = krb5_padata_add(context, md, KRB5_PADATA_ENC_TIMESTAMP, buf, len);\n    if (ret)\n\tfree(buf);\n    return ret;\n}\n\nstatic krb5_error_code\nadd_enc_ts_padata(krb5_context context,\n\t\t  METHOD_DATA *md,\n\t\t  krb5_principal client,\n\t\t  krb5_s2k_proc keyproc,\n\t\t  krb5_const_pointer keyseed,\n\t\t  krb5_enctype *enctypes,\n\t\t  unsigned netypes,\n\t\t  krb5_salt *salt,\n\t\t  krb5_data *s2kparams)\n{\n    krb5_error_code ret;\n    krb5_salt salt2;\n    krb5_enctype *ep;\n    size_t i;\n\n    if(salt == NULL) {\n\t/* default to standard salt */\n\tret = krb5_get_pw_salt (context, client, &salt2);\n\tif (ret)\n\t    return ret;\n\tsalt = &salt2;\n    }\n    if (!enctypes) {\n\tenctypes = context->etypes;\n\tnetypes = 0;\n\tfor (ep = enctypes; *ep != (krb5_enctype)ETYPE_NULL; ep++)\n\t    netypes++;\n    }\n\n    for (i = 0; i < netypes; ++i) {\n\tkrb5_keyblock *key;\n\n\t_krb5_debug(context, 5, \"krb5_get_init_creds: using ENC-TS with enctype %d\", enctypes[i]);\n\n\tret = (*keyproc)(context, enctypes[i], keyseed,\n\t\t\t *salt, s2kparams, &key);\n\tif (ret)\n\t    continue;\n\tret = make_pa_enc_timestamp (context, md, enctypes[i], key);\n\tkrb5_free_keyblock (context, key);\n\tif (ret)\n\t    return ret;\n    }\n    if(salt == &salt2)\n\tkrb5_free_salt(context, salt2);\n    return 0;\n}\n\nstatic krb5_error_code\npa_data_to_md_ts_enc(krb5_context context,\n\t\t     const AS_REQ *a,\n\t\t     const krb5_principal client,\n\t\t     krb5_get_init_creds_ctx *ctx,\n\t\t     struct pa_info_data *ppaid,\n\t\t     METHOD_DATA *md)\n{\n    if (ctx->keyproc == NULL || ctx->keyseed == NULL)\n\treturn 0;\n\n    if (ppaid) {\n\tadd_enc_ts_padata(context, md, client,\n\t\t\t  ctx->keyproc, ctx->keyseed,\n\t\t\t  &ppaid->etype, 1,\n\t\t\t  &ppaid->salt, ppaid->s2kparams);\n    } else {\n\tkrb5_salt salt;\n\n\t_krb5_debug(context, 5, \"krb5_get_init_creds: pa-info not found, guessing salt\");\n\n\t/* make a v5 salted pa-data */\n\tadd_enc_ts_padata(context, md, client,\n\t\t\t  ctx->keyproc, ctx->keyseed,\n\t\t\t  a->req_body.etype.val, a->req_body.etype.len,\n\t\t\t  NULL, NULL);\n\n\t/* make a v4 salted pa-data */\n\tsalt.salttype = KRB5_PW_SALT;\n\tkrb5_data_zero(&salt.saltvalue);\n\tadd_enc_ts_padata(context, md, client,\n\t\t\t  ctx->keyproc, ctx->keyseed,\n\t\t\t  a->req_body.etype.val, a->req_body.etype.len,\n\t\t\t  &salt, NULL);\n    }\n    return 0;\n}\n\nstatic krb5_error_code\npa_data_to_key_plain(krb5_context context,\n\t\t     const krb5_principal client,\n\t\t     krb5_get_init_creds_ctx *ctx,\n\t\t     krb5_salt salt,\n\t\t     krb5_data *s2kparams,\n\t\t     krb5_enctype etype,\n\t\t     krb5_keyblock **key)\n{\n    krb5_error_code ret;\n\n    ret = (*ctx->keyproc)(context, etype, ctx->keyseed,\n\t\t\t   salt, s2kparams, key);\n    return ret;\n}\n\n\nstatic krb5_error_code\npa_data_to_md_pkinit(krb5_context context,\n\t\t     const AS_REQ *a,\n\t\t     const krb5_principal client,\n\t\t     int win2k,\n\t\t     krb5_get_init_creds_ctx *ctx,\n\t\t     METHOD_DATA *md)\n{\n    if (ctx->pk_init_ctx == NULL)\n\treturn 0;\n#ifdef PKINIT\n    return _krb5_pk_mk_padata(context,\n\t\t\t      ctx->pk_init_ctx,\n\t\t\t      ctx->ic_flags,\n\t\t\t      win2k,\n\t\t\t      &a->req_body,\n\t\t\t      ctx->pk_nonce,\n\t\t\t      md);\n#else\n    krb5_set_error_message(context, EINVAL,\n\t\t\t   N_(\"no support for PKINIT compiled in\", \"\"));\n    return EINVAL;\n#endif\n}\n\nstatic krb5_error_code\npa_data_add_pac_request(krb5_context context,\n\t\t\tkrb5_get_init_creds_ctx *ctx,\n\t\t\tMETHOD_DATA *md)\n{\n    size_t len = 0, length;\n    krb5_error_code ret;\n    PA_PAC_REQUEST req;\n    void *buf;\n\n    switch (ctx->req_pac) {\n    case KRB5_INIT_CREDS_TRISTATE_UNSET:\n\treturn 0; /* don't bother */\n    case KRB5_INIT_CREDS_TRISTATE_TRUE:\n\treq.include_pac = 1;\n\tbreak;\n    case KRB5_INIT_CREDS_TRISTATE_FALSE:\n\treq.include_pac = 0;\n    }\n\n    ASN1_MALLOC_ENCODE(PA_PAC_REQUEST, buf, length,\n\t\t       &req, &len, ret);\n    if (ret)\n\treturn ret;\n    if(len != length)\n\tkrb5_abortx(context, \"internal error in ASN.1 encoder\");\n\n    ret = krb5_padata_add(context, md, KRB5_PADATA_PA_PAC_REQUEST, buf, len);\n    if (ret)\n\tfree(buf);\n\n    return 0;\n}\n\n/*\n * Assumes caller always will free `out_md', even on error.\n */\n\nstatic krb5_error_code\nprocess_pa_data_to_md(krb5_context context,\n\t\t      const krb5_creds *creds,\n\t\t      const AS_REQ *a,\n\t\t      krb5_get_init_creds_ctx *ctx,\n\t\t      METHOD_DATA *in_md,\n\t\t      METHOD_DATA **out_md,\n\t\t      krb5_prompter_fct prompter,\n\t\t      void *prompter_data)\n{\n    krb5_error_code ret;\n\n    ALLOC(*out_md, 1);\n    if (*out_md == NULL)\n\treturn krb5_enomem(context);\n\n    (*out_md)->len = 0;\n    (*out_md)->val = NULL;\n\n    if (_krb5_have_debug(context, 5)) {\n\tunsigned i;\n\t_krb5_debug(context, 5, \"KDC send %d patypes\", in_md->len);\n\tfor (i = 0; i < in_md->len; i++)\n\t    _krb5_debug(context, 5, \"KDC send PA-DATA type: %d\", in_md->val[i].padata_type);\n    }\n\n    /*\n     * Make sure we don't sent both ENC-TS and PK-INIT pa data, no\n     * need to expose our password protecting our PKCS12 key.\n     */\n\n    if (ctx->pk_init_ctx) {\n\n \t_krb5_debug(context, 5, \"krb5_get_init_creds: \"\n\t\t    \"prepareing PKINIT padata (%s)\",\n \t\t    (ctx->used_pa_types & USED_PKINIT_W2K) ? \"win2k\" : \"ietf\");\n\n \tif (ctx->used_pa_types & USED_PKINIT_W2K) {\n \t    krb5_set_error_message(context, KRB5_GET_IN_TKT_LOOP,\n \t\t\t\t   \"Already tried pkinit, looping\");\n \t    return KRB5_GET_IN_TKT_LOOP;\n \t}\n\n\tret = pa_data_to_md_pkinit(context, a, creds->client,\n\t\t\t\t   (ctx->used_pa_types & USED_PKINIT),\n\t\t\t\t   ctx, *out_md);\n\tif (ret)\n\t    return ret;\n\n\tif (ctx->used_pa_types & USED_PKINIT)\n\t    ctx->used_pa_types |= USED_PKINIT_W2K;\n \telse\n \t    ctx->used_pa_types |= USED_PKINIT;\n\n    } else if (in_md->len != 0) {\n\tstruct pa_info_data *paid, *ppaid;\n \tunsigned flag;\n\n\tpaid = calloc(1, sizeof(*paid));\n        if (paid == NULL)\n            return krb5_enomem(context);\n\n\tpaid->etype = KRB5_ENCTYPE_NULL;\n\tppaid = process_pa_info(context, creds->client, a, paid, in_md);\n\n \tif (ppaid)\n \t    flag = USED_ENC_TS_INFO;\n \telse\n \t    flag = USED_ENC_TS_GUESS;\n\n \tif (ctx->used_pa_types & flag) {\n \t    if (ppaid)\n \t\tfree_paid(context, ppaid);\n            free(paid);\n \t    krb5_set_error_message(context, KRB5_GET_IN_TKT_LOOP,\n \t\t\t\t   \"Already tried ENC-TS-%s, looping\",\n \t\t\t\t   flag == USED_ENC_TS_INFO ? \"info\" : \"guess\");\n \t    return KRB5_GET_IN_TKT_LOOP;\n \t}\n\n\tpa_data_to_md_ts_enc(context, a, creds->client, ctx, ppaid, *out_md);\n\n\tctx->used_pa_types |= flag;\n\n\tif (ppaid) {\n\t    if (ctx->ppaid) {\n\t\tfree_paid(context, ctx->ppaid);\n\t\tfree(ctx->ppaid);\n\t    }\n\t    ctx->ppaid = ppaid;\n\t} else\n\t    free(paid);\n    }\n\n    pa_data_add_pac_request(context, ctx, *out_md);\n\n    if ((ctx->fast_state.flags & KRB5_FAST_DISABLED) == 0) {\n \tret = krb5_padata_add(context, *out_md, KRB5_PADATA_REQ_ENC_PA_REP, NULL, 0);\n \tif (ret)\n \t    return ret;\n    }\n\n    if ((*out_md)->len == 0) {\n\tfree(*out_md);\n\t*out_md = NULL;\n    }\n\n    return 0;\n}\n\nstatic krb5_error_code\nprocess_pa_data_to_key(krb5_context context,\n\t\t       krb5_get_init_creds_ctx *ctx,\n\t\t       krb5_creds *creds,\n\t\t       AS_REQ *a,\n\t\t       AS_REP *rep,\n\t\t       const krb5_krbhst_info *hi,\n\t\t       krb5_keyblock **key)\n{\n    struct pa_info_data paid, *ppaid = NULL;\n    krb5_error_code ret;\n    krb5_enctype etype;\n    PA_DATA *pa;\n\n    memset(&paid, 0, sizeof(paid));\n\n    etype = rep->enc_part.etype;\n\n    if (rep->padata) {\n\tpaid.etype = etype;\n\tppaid = process_pa_info(context, creds->client, a, &paid,\n\t\t\t\trep->padata);\n    }\n    if (ppaid == NULL)\n\tppaid = ctx->ppaid;\n    if (ppaid == NULL) {\n\tret = krb5_get_pw_salt (context, creds->client, &paid.salt);\n\tif (ret)\n\t    return ret;\n\tpaid.etype = etype;\n\tpaid.s2kparams = NULL;\n\tppaid = &paid;\n    }\n\n    pa = NULL;\n    if (rep->padata) {\n\tint idx = 0;\n\tpa = krb5_find_padata(rep->padata->val,\n\t\t\t      rep->padata->len,\n\t\t\t      KRB5_PADATA_PK_AS_REP,\n\t\t\t      &idx);\n\tif (pa == NULL) {\n\t    idx = 0;\n\t    pa = krb5_find_padata(rep->padata->val,\n\t\t\t\t  rep->padata->len,\n\t\t\t\t  KRB5_PADATA_PK_AS_REP_19,\n\t\t\t\t  &idx);\n\t}\n    }\n    if (pa && ctx->pk_init_ctx) {\n#ifdef PKINIT\n\t_krb5_debug(context, 5, \"krb5_get_init_creds: using PKINIT\");\n\n\tret = _krb5_pk_rd_pa_reply(context,\n\t\t\t\t   a->req_body.realm,\n\t\t\t\t   ctx->pk_init_ctx,\n\t\t\t\t   etype,\n\t\t\t\t   hi,\n\t\t\t\t   ctx->pk_nonce,\n\t\t\t\t   &ctx->req_buffer,\n\t\t\t\t   pa,\n\t\t\t\t   key);\n#else\n\tret = EINVAL;\n\tkrb5_set_error_message(context, ret, N_(\"no support for PKINIT compiled in\", \"\"));\n#endif\n    } else if (ctx->keyseed) {\n \t_krb5_debug(context, 5, \"krb5_get_init_creds: using keyproc\");\n\tret = pa_data_to_key_plain(context, creds->client, ctx,\n\t\t\t\t   ppaid->salt, ppaid->s2kparams, etype, key);\n    } else {\n\tret = EINVAL;\n\tkrb5_set_error_message(context, ret, N_(\"No usable pa data type\", \"\"));\n    }\n\n    free_paid(context, &paid);\n    return ret;\n}\n\n/**\n * Start a new context to get a new initial credential.\n *\n * @param context A Kerberos 5 context.\n * @param client The Kerberos principal to get the credential for, if\n *     NULL is given, the default principal is used as determined by\n *     krb5_get_default_principal().\n * @param prompter\n * @param prompter_data\n * @param start_time the time the ticket should start to be valid or 0 for now.\n * @param options a options structure, can be NULL for default options.\n * @param rctx A new allocated free with krb5_init_creds_free().\n *\n * @return 0 for success or an Kerberos 5 error code, see krb5_get_error_message().\n *\n * @ingroup krb5_credential\n */\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_init_creds_init(krb5_context context,\n\t\t     krb5_principal client,\n\t\t     krb5_prompter_fct prompter,\n\t\t     void *prompter_data,\n\t\t     krb5_deltat start_time,\n\t\t     krb5_get_init_creds_opt *options,\n\t\t     krb5_init_creds_context *rctx)\n{\n    krb5_init_creds_context ctx;\n    krb5_error_code ret;\n\n    *rctx = NULL;\n\n    ctx = calloc(1, sizeof(*ctx));\n    if (ctx == NULL)\n\treturn krb5_enomem(context);\n\n    ret = get_init_creds_common(context, client, start_time, options, ctx);\n    if (ret) {\n\tfree(ctx);\n\treturn ret;\n    }\n\n    /* Set a new nonce. */\n    krb5_generate_random_block (&ctx->nonce, sizeof(ctx->nonce));\n    ctx->nonce &= 0x7fffffff;\n    /* XXX these just needs to be the same when using Windows PK-INIT */\n    ctx->pk_nonce = ctx->nonce;\n\n    ctx->prompter = prompter;\n    ctx->prompter_data = prompter_data;\n\n    *rctx = ctx;\n\n    return ret;\n}\n\n/**\n * Sets the service that the is requested. This call is only neede for\n * special initial tickets, by default the a krbtgt is fetched in the default realm.\n *\n * @param context a Kerberos 5 context.\n * @param ctx a krb5_init_creds_context context.\n * @param service the service given as a string, for example\n *        \"kadmind/admin\". If NULL, the default krbtgt in the clients\n *        realm is set.\n *\n * @return 0 for success, or an Kerberos 5 error code, see krb5_get_error_message().\n * @ingroup krb5_credential\n */\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_init_creds_set_service(krb5_context context,\n\t\t\t    krb5_init_creds_context ctx,\n\t\t\t    const char *service)\n{\n    krb5_const_realm client_realm;\n    krb5_principal principal;\n    krb5_error_code ret;\n\n    client_realm = krb5_principal_get_realm (context, ctx->cred.client);\n\n    if (service) {\n\tret = krb5_parse_name (context, service, &principal);\n\tif (ret)\n\t    return ret;\n\tkrb5_principal_set_realm (context, principal, client_realm);\n    } else {\n\tret = krb5_make_principal(context, &principal,\n\t\t\t\t  client_realm, KRB5_TGS_NAME, client_realm,\n\t\t\t\t  NULL);\n\tif (ret)\n\t    return ret;\n    }\n\n    /*\n     * This is for Windows RODC that are picky about what name type\n     * the server principal have, and the really strange part is that\n     * they are picky about the AS-REQ name type and not the TGS-REQ\n     * later. Oh well.\n     */\n\n    if (krb5_principal_is_krbtgt(context, principal))\n\tkrb5_principal_set_type(context, principal, KRB5_NT_SRV_INST);\n\n    krb5_free_principal(context, ctx->cred.server);\n    ctx->cred.server = principal;\n\n    return 0;\n}\n\n/**\n * Sets the password that will use for the request.\n *\n * @param context a Kerberos 5 context.\n * @param ctx ctx krb5_init_creds_context context.\n * @param password the password to use.\n *\n * @return 0 for success, or an Kerberos 5 error code, see krb5_get_error_message().\n * @ingroup krb5_credential\n */\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_init_creds_set_password(krb5_context context,\n\t\t\t     krb5_init_creds_context ctx,\n\t\t\t     const char *password)\n{\n    if (ctx->password) {\n\tmemset(ctx->password, 0, strlen(ctx->password));\n\tfree(ctx->password);\n    }\n    if (password) {\n\tctx->password = strdup(password);\n\tif (ctx->password == NULL)\n\t    return krb5_enomem(context);\n\tctx->keyseed = (void *) ctx->password;\n    } else {\n\tctx->keyseed = NULL;\n\tctx->password = NULL;\n    }\n\n    return 0;\n}\n\nstatic krb5_error_code KRB5_CALLCONV\nkeytab_key_proc(krb5_context context, krb5_enctype enctype,\n\t\tkrb5_const_pointer keyseed,\n\t\tkrb5_salt salt, krb5_data *s2kparms,\n\t\tkrb5_keyblock **key)\n{\n    krb5_keytab_key_proc_args *args  = rk_UNCONST(keyseed);\n    krb5_keytab keytab = args->keytab;\n    krb5_principal principal = args->principal;\n    krb5_error_code ret;\n    krb5_keytab real_keytab;\n    krb5_keytab_entry entry;\n\n    if(keytab == NULL)\n\tkrb5_kt_default(context, &real_keytab);\n    else\n\treal_keytab = keytab;\n\n    ret = krb5_kt_get_entry (context, real_keytab, principal,\n\t\t\t     0, enctype, &entry);\n\n    if (keytab == NULL)\n\tkrb5_kt_close (context, real_keytab);\n\n    if (ret)\n\treturn ret;\n\n    ret = krb5_copy_keyblock (context, &entry.keyblock, key);\n    krb5_kt_free_entry(context, &entry);\n    return ret;\n}\n\n\n/**\n * Set the keytab to use for authentication.\n *\n * @param context a Kerberos 5 context.\n * @param ctx ctx krb5_init_creds_context context.\n * @param keytab the keytab to read the key from.\n *\n * @return 0 for success, or an Kerberos 5 error code, see krb5_get_error_message().\n * @ingroup krb5_credential\n */\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_init_creds_set_keytab(krb5_context context,\n\t\t\t   krb5_init_creds_context ctx,\n\t\t\t   krb5_keytab keytab)\n{\n    krb5_keytab_key_proc_args *a;\n    krb5_keytab_entry entry;\n    krb5_kt_cursor cursor;\n    krb5_enctype *etypes = NULL;\n    krb5_error_code ret;\n    size_t netypes = 0;\n    int kvno = 0, found = 0;\n\n    a = malloc(sizeof(*a));\n    if (a == NULL)\n\treturn krb5_enomem(context);\n\n    a->principal = ctx->cred.client;\n    a->keytab    = keytab;\n\n    ctx->keytab_data = a;\n    ctx->keyseed = (void *)a;\n    ctx->keyproc = keytab_key_proc;\n\n    /*\n     * We need to the KDC what enctypes we support for this keytab,\n     * esp if the keytab is really a password based entry, then the\n     * KDC might have more enctypes in the database then what we have\n     * in the keytab.\n     */\n\n    ret = krb5_kt_start_seq_get(context, keytab, &cursor);\n    if(ret)\n\tgoto out;\n\n    while(krb5_kt_next_entry(context, keytab, &entry, &cursor) == 0){\n\tvoid *ptr;\n\n\tif (!krb5_principal_compare(context, entry.principal, ctx->cred.client))\n\t    goto next;\n\n\tfound = 1;\n\n\t/* check if we ahve this kvno already */\n\tif (entry.vno > kvno) {\n\t    /* remove old list of etype */\n\t    if (etypes)\n\t\tfree(etypes);\n\t    etypes = NULL;\n\t    netypes = 0;\n\t    kvno = entry.vno;\n\t} else if (entry.vno != kvno)\n\t    goto next;\n\n\t/* check if enctype is supported */\n\tif (krb5_enctype_valid(context, entry.keyblock.keytype) != 0)\n\t    goto next;\n\n\t/* add enctype to supported list */\n\tptr = realloc(etypes, sizeof(etypes[0]) * (netypes + 2));\n\tif (ptr == NULL) {\n\t    free(etypes);\n\t    ret = krb5_enomem(context);\n\t    goto out;\n\t}\n\n\tetypes = ptr;\n\tetypes[netypes] = entry.keyblock.keytype;\n\tetypes[netypes + 1] = ETYPE_NULL;\n\tnetypes++;\n    next:\n\tkrb5_kt_free_entry(context, &entry);\n    }\n    krb5_kt_end_seq_get(context, keytab, &cursor);\n\n    if (etypes) {\n\tif (ctx->etypes)\n\t    free(ctx->etypes);\n\tctx->etypes = etypes;\n    }\n\n out:\n    if (!found) {\n\tif (ret == 0)\n\t    ret = KRB5_KT_NOTFOUND;\n\t_krb5_kt_principal_not_found(context, ret, keytab, ctx->cred.client, 0, 0);\n    }\n\n    return ret;\n}\n\nstatic krb5_error_code KRB5_CALLCONV\nkeyblock_key_proc(krb5_context context, krb5_enctype enctype,\n\t\t  krb5_const_pointer keyseed,\n\t\t  krb5_salt salt, krb5_data *s2kparms,\n\t\t  krb5_keyblock **key)\n{\n    return krb5_copy_keyblock (context, keyseed, key);\n}\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_init_creds_set_keyblock(krb5_context context,\n\t\t\t     krb5_init_creds_context ctx,\n\t\t\t     krb5_keyblock *keyblock)\n{\n    ctx->keyseed = (void *)keyblock;\n    ctx->keyproc = keyblock_key_proc;\n\n    return 0;\n}\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_init_creds_set_fast_ccache(krb5_context context,\n\t\t\t\tkrb5_init_creds_context ctx,\n\t\t\t\tkrb5_ccache fast_ccache)\n{\n    ctx->fast_state.armor_ccache = fast_ccache;\n    ctx->fast_state.flags |= KRB5_FAST_REQUIRED;\n    return 0;\n}\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_init_creds_set_fast_ap_armor_service(krb5_context context,\n\t\t\t\t\t  krb5_init_creds_context ctx,\n\t\t\t\t\t  krb5_const_principal armor_service)\n{\n    krb5_error_code ret;\n\n    if (ctx->fast_state.armor_service)\n\tkrb5_free_principal(context, ctx->fast_state.armor_service);\n    if (armor_service) {\n\tret = krb5_copy_principal(context, armor_service, &ctx->fast_state.armor_service);\n\tif (ret)\n\t    return ret;\n    } else {\n\tctx->fast_state.armor_service = NULL;\n    }\n    ctx->fast_state.flags |= KRB5_FAST_REQUIRED | KRB5_FAST_AP_ARMOR_SERVICE;\n    return 0;\n}\n\n/*\n * FAST\n */\n\nstatic krb5_error_code\ncheck_fast(krb5_context context, struct fast_state *state)\n{\n    if (state->flags & KRB5_FAST_EXPECTED) {\n\tkrb5_set_error_message(context, KRB5KRB_AP_ERR_MODIFIED,\n\t\t\t       \"Expected FAST, but no FAST \"\n\t\t\t       \"was in the response from the KDC\");\n\treturn KRB5KRB_AP_ERR_MODIFIED;\n    }\n    return 0;\n}\n\n\nstatic krb5_error_code\nfast_unwrap_as_rep(krb5_context context, int32_t nonce,\n\t\t   krb5_data *chksumdata,\n\t\t   struct fast_state *state, AS_REP *rep)\n{\n    PA_FX_FAST_REPLY fxfastrep;\n    KrbFastResponse fastrep;\n    krb5_error_code ret;\n    PA_DATA *pa = NULL;\n    int idx = 0;\n\n    if (state->armor_crypto == NULL || rep->padata == NULL)\n\treturn check_fast(context, state);\n\n    /* find PA_FX_FAST_REPLY */\n\n    pa = krb5_find_padata(rep->padata->val, rep->padata->len,\n\t\t\t  KRB5_PADATA_FX_FAST, &idx);\n    if (pa == NULL)\n\treturn check_fast(context, state);\n\n    memset(&fxfastrep, 0, sizeof(fxfastrep));\n    memset(&fastrep, 0, sizeof(fastrep));\n\n    ret = decode_PA_FX_FAST_REPLY(pa->padata_value.data, pa->padata_value.length, &fxfastrep, NULL);\n    if (ret)\n\treturn ret;\n\n    if (fxfastrep.element == choice_PA_FX_FAST_REPLY_armored_data) {\n\tkrb5_data data;\n\tret = krb5_decrypt_EncryptedData(context,\n\t\t\t\t\t state->armor_crypto,\n\t\t\t\t\t KRB5_KU_FAST_REP,\n\t\t\t\t\t &fxfastrep.u.armored_data.enc_fast_rep,\n\t\t\t\t\t &data);\n\tif (ret)\n\t    goto out;\n\n\tret = decode_KrbFastResponse(data.data, data.length, &fastrep, NULL);\n\tkrb5_data_free(&data);\n\tif (ret)\n\t    goto out;\n\n    } else {\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\n    free_METHOD_DATA(rep->padata);\n    ret = copy_METHOD_DATA(&fastrep.padata, rep->padata);\n    if (ret)\n\tgoto out;\n\n    if (fastrep.strengthen_key) {\n\tif (state->strengthen_key)\n\t    krb5_free_keyblock(context, state->strengthen_key);\n\n\tret = krb5_copy_keyblock(context, fastrep.strengthen_key, &state->strengthen_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (nonce != fastrep.nonce) {\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n    if (fastrep.finished) {\n\tPrincipalName cname;\n\tkrb5_realm crealm = NULL;\n\n\tif (chksumdata == NULL) {\n\t    ret = KRB5KDC_ERR_PREAUTH_FAILED;\n\t    goto out;\n\t}\n\n\tret = krb5_verify_checksum(context, state->armor_crypto,\n\t\t\t\t   KRB5_KU_FAST_FINISHED,\n\t\t\t\t   chksumdata->data, chksumdata->length,\n\t\t\t\t   &fastrep.finished->ticket_checksum);\n\tif (ret)\n\t    goto out;\n\n\t/* update */\n\tret = copy_Realm(&fastrep.finished->crealm, &crealm);\n\tif (ret)\n\t    goto out;\n\tfree_Realm(&rep->crealm);\n\trep->crealm = crealm;\n\n\tret = copy_PrincipalName(&fastrep.finished->cname, &cname);\n\tif (ret)\n\t    goto out;\n\tfree_PrincipalName(&rep->cname);\n\trep->cname = cname;\n\t\n#if 0 /* store authenticated checksum as kdc-offset */\n\tfastrep->finished.timestamp;\n\tfastrep->finished.usec = 0;\n#endif\n\n    } else if (chksumdata) {\n\t/* expected fastrep.finish but didn't get it */\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n out:\n    free_PA_FX_FAST_REPLY(&fxfastrep);\n\n    return ret;\n}\n\nstatic krb5_error_code\nfast_unwrap_error(krb5_context context, struct fast_state *state, KRB_ERROR *error)\n{\n    if (state->armor_crypto == NULL)\n\treturn check_fast(context, state);\n\n    return 0;\n}\n\nkrb5_error_code\n_krb5_make_fast_ap_fxarmor(krb5_context context,\n\t\t\t   krb5_ccache armor_ccache,\n\t\t\t   krb5_data *armor_value,\n\t\t\t   krb5_keyblock *armor_key,\n\t\t\t   krb5_crypto *armor_crypto)\n{\n    krb5_auth_context auth_context = NULL;\n    krb5_creds cred, *credp = NULL;\n    krb5_error_code ret;\n    krb5_data empty;\n\n    krb5_data_zero(&empty);\n\n    memset(&cred, 0, sizeof(cred));\n\n    ret = krb5_auth_con_init (context, &auth_context);\n    if (ret)\n\tgoto out;\n    \n    ret = krb5_cc_get_principal(context, armor_ccache, &cred.client);\n    if (ret)\n\tgoto out;\n    \n    ret = krb5_make_principal(context, &cred.server,\n\t\t\t      cred.client->realm,\n\t\t\t      KRB5_TGS_NAME,\n\t\t\t      cred.client->realm,\n\t\t\t      NULL);\n    if (ret) {\n\tkrb5_free_principal(context, cred.client);\n\tgoto out;\n    }\n    \n    ret = krb5_get_credentials(context, 0, armor_ccache, &cred, &credp);\n    krb5_free_principal(context, cred.server);\n    krb5_free_principal(context, cred.client);\n    if (ret)\n\tgoto out;\n    \n    ret = krb5_auth_con_add_AuthorizationData(context, auth_context, KRB5_PADATA_FX_FAST_ARMOR, &empty);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_mk_req_extended(context,\n\t\t\t       &auth_context,\n\t\t\t       AP_OPTS_USE_SUBKEY,\n\t\t\t       NULL,\n\t\t\t       credp,\n\t\t\t       armor_value);\n    krb5_free_creds(context, credp);\n    if (ret)\n\tgoto out;\n    \n    ret = _krb5_fast_armor_key(context,\n\t\t\t       auth_context->local_subkey,\n\t\t\t       auth_context->keyblock,\n\t\t\t       armor_key,\n\t\t\t       armor_crypto);\n    if (ret)\n\tgoto out;\n\n out:\n    krb5_auth_con_free(context, auth_context);\n    return ret;\n}\n\n#ifndef WIN32\nstatic heim_base_once_t armor_service_once = HEIM_BASE_ONCE_INIT;\nstatic heim_ipc armor_service = NULL;\n\nstatic void\nfast_armor_init_ipc(void *ctx)\n{\n    heim_ipc *ipc = ctx;\n    heim_ipc_init_context(\"ANY:org.h5l.armor-service\", ipc);\n}\n#endif /* WIN32 */\n\n\nstatic krb5_error_code\nmake_fast_ap_fxarmor(krb5_context context,\n\t\t     struct fast_state *state,\n\t\t     const char *realm,\n\t\t     KrbFastArmor **armor)\n{\n    KrbFastArmor *fxarmor = NULL;\n    krb5_error_code ret;\n\n    if (state->armor_crypto)\n\tkrb5_crypto_destroy(context, state->armor_crypto);\n    krb5_free_keyblock_contents(context, &state->armor_key);\n\n\n    ALLOC(fxarmor, 1);\n    if (fxarmor == NULL)\n\treturn krb5_enomem(context);\n\n    if (state->flags & KRB5_FAST_AP_ARMOR_SERVICE) {\n#ifdef WIN32\n\tkrb5_set_error_message(context, ENOTSUP, \"Fast armor IPC service not supportted yet on Windows\");\n\tret = ENOTSUP;\n        goto out;\n#else /* WIN32 */\n\tKERB_ARMOR_SERVICE_REPLY msg;\n\tkrb5_data request, reply;\n\n\theim_base_once_f(&armor_service_once, &armor_service, fast_armor_init_ipc);\n\tif (armor_service == NULL) {\n\t    krb5_set_error_message(context, ENOENT, \"Failed to open fast armor service\");\n            ret = ENOENT;\n\t    goto out;\n\t}\n\n\tkrb5_data_zero(&reply);\n\n\trequest.data = rk_UNCONST(realm);\n\trequest.length = strlen(realm);\n\n\tret = heim_ipc_call(armor_service, &request, &reply, NULL);\n\theim_release(send);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"Failed to get armor service credential\");\n\t    goto out;\n\t}\n\n\tret = decode_KERB_ARMOR_SERVICE_REPLY(reply.data, reply.length, &msg, NULL);\n\tkrb5_data_free(&reply);\n\tif (ret)\n\t    goto out;\n\n\tret = copy_KrbFastArmor(fxarmor, &msg.armor);\n\tif (ret) {\n\t    free_KERB_ARMOR_SERVICE_REPLY(&msg);\n\t    goto out;\n\t}\n\n\tret = krb5_copy_keyblock_contents(context, &msg.armor_key, &state->armor_key);\n\tfree_KERB_ARMOR_SERVICE_REPLY(&msg);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_crypto_init(context, &state->armor_key, 0, &state->armor_crypto);\n\tif (ret)\n\t    goto out;\n#endif /* WIN32 */\n    } else {\n\n\tfxarmor->armor_type = 1;\n\n\tret = _krb5_make_fast_ap_fxarmor(context,\n\t\t\t\t\t state->armor_ccache,\n\t\t\t\t\t &fxarmor->armor_value,\n\t\t\t\t\t &state->armor_key,\n\t\t\t\t\t &state->armor_crypto);\n\tif (ret)\n\t    goto out;\n    }\n    \n\n    *armor = fxarmor;\n    fxarmor = NULL;\n out:\n    if (fxarmor) {\n\tfree_KrbFastArmor(fxarmor);\n\tfree(fxarmor);\n    }\n    return ret;\n}\n\nstatic krb5_error_code\nfast_wrap_req(krb5_context context, struct fast_state *state, KDC_REQ *req)\n{\n    KrbFastArmor *fxarmor = NULL;\n    PA_FX_FAST_REQUEST fxreq;\n    krb5_error_code ret;\n    KrbFastReq fastreq;\n    krb5_data data;\n    size_t size;\n\n    if (state->flags & KRB5_FAST_DISABLED) {\n\t_krb5_debug(context, 10, \"fast disabled, not doing any fast wrapping\");\n\treturn 0;\n    }\n\n    memset(&fxreq, 0, sizeof(fxreq));\n    memset(&fastreq, 0, sizeof(fastreq));\n    krb5_data_zero(&data);\n\n    if (state->armor_crypto == NULL) {\n\tif (state->armor_ccache) {\n\t    /*\n\t     * Instead of keeping state in FX_COOKIE in the KDC, we\n\t     * rebuild a new armor key for every request, because this\n\t     * is what the MIT KDC expect and RFC6113 is vage about\n\t     * what the behavior should be.\n\t     */\n\t    state->type = choice_PA_FX_FAST_REQUEST_armored_data;\n\t} else {\n\t    return check_fast(context, state);\n\t}\n    }\n\n    state->flags |= KRB5_FAST_EXPECTED;\n\n    fastreq.fast_options.hide_client_names = 1;\n\n    ret = copy_KDC_REQ_BODY(&req->req_body, &fastreq.req_body);\n    free_KDC_REQ_BODY(&req->req_body);\n\n    req->req_body.realm = strdup(KRB5_ANON_REALM);\n    if ((ALLOC(req->req_body.cname, 1)) != NULL) {\n        req->req_body.cname->name_type = KRB5_NT_WELLKNOWN;\n    if ((ALLOC(req->req_body.cname->name_string.val, 2)) != NULL) {\n        req->req_body.cname->name_string.len = 2;\n        req->req_body.cname->name_string.val[0] = strdup(KRB5_WELLKNOWN_NAME);\n        req->req_body.cname->name_string.val[1] = strdup(KRB5_ANON_NAME);\n        if (req->req_body.cname->name_string.val[0] == NULL ||\n            req->req_body.cname->name_string.val[1] == NULL)\n            ret = krb5_enomem(context);\n      } else\n          ret = krb5_enomem(context);\n    } else\n        ret = krb5_enomem(context);\n    if ((ALLOC(req->req_body.till, 1)) != NULL)\n        *req->req_body.till = 0;\n    else\n        ret = krb5_enomem(context);\n    if (ret)\n        goto out;\n\n    if (req->padata) {\n\tret = copy_METHOD_DATA(req->padata, &fastreq.padata);\n\tfree_METHOD_DATA(req->padata);\n    } else {\n\tif ((ALLOC(req->padata, 1)) == NULL)\n            ret = krb5_enomem(context);\n    }\n    if (ret)\n        goto out;\n\n    ASN1_MALLOC_ENCODE(KrbFastReq, data.data, data.length, &fastreq, &size, ret);\n    if (ret)\n\tgoto out;\n    heim_assert(data.length == size, \"ASN.1 internal error\");\n\n    fxreq.element = state->type;\n\n    if (state->type == choice_PA_FX_FAST_REQUEST_armored_data) {\n\tsize_t len;\n\tvoid *buf;\n\n\tret = make_fast_ap_fxarmor(context, state, fastreq.req_body.realm, &fxreq.u.armored_data.armor);\n\tif (ret)\n\t    goto out;\n\n\theim_assert(state->armor_crypto != NULL, \"FAST armor key missing when FAST started\");\n\n\tASN1_MALLOC_ENCODE(KDC_REQ_BODY, buf, len, &req->req_body, &size, ret);\n\tif (ret)\n\t    goto out;\n\theim_assert(len == size, \"ASN.1 internal error\");\n\n\tret = krb5_create_checksum(context, state->armor_crypto,\n\t\t\t\t   KRB5_KU_FAST_REQ_CHKSUM, 0,\n\t\t\t\t   buf, len, \n\t\t\t\t   &fxreq.u.armored_data.req_checksum);\n\tfree(buf);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_encrypt_EncryptedData(context, state->armor_crypto,\n\t\t\t\t\t KRB5_KU_FAST_ENC,\n\t\t\t\t\t data.data,\n\t\t\t\t\t data.length,\n\t\t\t\t\t 0,\n\t\t\t\t\t &fxreq.u.armored_data.enc_fast_req);\n\tkrb5_data_free(&data);\n        if (ret)\n            goto out;\n\n    } else {\n\tkrb5_data_free(&data);\n\theim_assert(false, \"unknown FAST type, internal error\");\n    }\n\n    ASN1_MALLOC_ENCODE(PA_FX_FAST_REQUEST, data.data, data.length, &fxreq, &size, ret);\n    if (ret)\n\tgoto out;\n    heim_assert(data.length == size, \"ASN.1 internal error\");\n\n\n    ret = krb5_padata_add(context, req->padata, KRB5_PADATA_FX_FAST, data.data, data.length);\n    if (ret)\n\tgoto out;\n    krb5_data_zero(&data);\n\n out:\n    free_PA_FX_FAST_REQUEST(&fxreq);\n    free_KrbFastReq(&fastreq);\n    if (fxarmor) {\n\tfree_KrbFastArmor(fxarmor);\n\tfree(fxarmor);\n    }\n    krb5_data_free(&data);\n\n    return ret;\n}\n\n\n/**\n * The core loop if krb5_get_init_creds() function family. Create the\n * packets and have the caller send them off to the KDC.\n *\n * If the caller want all work been done for them, use\n * krb5_init_creds_get() instead.\n *\n * @param context a Kerberos 5 context.\n * @param ctx ctx krb5_init_creds_context context.\n * @param in input data from KDC, first round it should be reset by krb5_data_zer().\n * @param out reply to KDC.\n * @param hostinfo KDC address info, first round it can be NULL.\n * @param flags status of the round, if\n *        KRB5_INIT_CREDS_STEP_FLAG_CONTINUE is set, continue one more round.\n *\n * @return 0 for success, or an Kerberos 5 error code, see\n *     krb5_get_error_message().\n *\n * @ingroup krb5_credential\n */\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_init_creds_step(krb5_context context,\n\t\t     krb5_init_creds_context ctx,\n\t\t     krb5_data *in,\n\t\t     krb5_data *out,\n\t\t     krb5_krbhst_info *hostinfo,\n\t\t     unsigned int *flags)\n{\n    krb5_error_code ret;\n    size_t len = 0;\n    size_t size;\n    AS_REQ req2;\n\n    krb5_data_zero(out);\n\n    if (ctx->as_req.req_body.cname == NULL) {\n\tret = init_as_req(context, ctx->flags, &ctx->cred,\n\t\t\t  ctx->addrs, ctx->etypes, &ctx->as_req);\n\tif (ret) {\n\t    free_init_creds_ctx(context, ctx);\n\t    return ret;\n\t}\n    }\n\n#define MAX_PA_COUNTER 10\n    if (ctx->pa_counter > MAX_PA_COUNTER) {\n\tkrb5_set_error_message(context, KRB5_GET_IN_TKT_LOOP,\n\t\t\t       N_(\"Looping %d times while getting \"\n\t\t\t\t  \"initial credentials\", \"\"),\n\t\t\t       ctx->pa_counter);\n\treturn KRB5_GET_IN_TKT_LOOP;\n    }\n    ctx->pa_counter++;\n\n    _krb5_debug(context, 5, \"krb5_get_init_creds: loop %d\", ctx->pa_counter);\n\n    /* Lets process the input packet */\n    if (in && in->length) {\n\tkrb5_kdc_rep rep;\n\n\tmemset(&rep, 0, sizeof(rep));\n\n\t_krb5_debug(context, 5, \"krb5_get_init_creds: processing input\");\n\n\tret = decode_AS_REP(in->data, in->length, &rep.kdc_rep, &size);\n\tif (ret == 0) {\n\t    unsigned eflags = EXTRACT_TICKET_AS_REQ | EXTRACT_TICKET_TIMESYNC;\n\t    krb5_data data;\n\n\t    /*\n\t     * Unwrap AS-REP\n\t     */\n\t    ASN1_MALLOC_ENCODE(Ticket, data.data, data.length,\n\t\t\t       &rep.kdc_rep.ticket, &size, ret);\n\t    if (ret)\n\t\tgoto out;\n\t    heim_assert(data.length == size, \"ASN.1 internal error\");\n\n\t    ret = fast_unwrap_as_rep(context, ctx->nonce, &data,\n\t\t\t\t     &ctx->fast_state, &rep.kdc_rep);\n\t    krb5_data_free(&data);\n\t    if (ret)\n\t\tgoto out;\n\n\t    /*\n\t     * Now check and extract the ticket\n\t     */\n\n\t    if (ctx->flags.canonicalize) {\n\t\teflags |= EXTRACT_TICKET_ALLOW_SERVER_MISMATCH;\n\t\teflags |= EXTRACT_TICKET_MATCH_REALM;\n\t    }\n\t    if (ctx->ic_flags & KRB5_INIT_CREDS_NO_C_CANON_CHECK)\n\t\teflags |= EXTRACT_TICKET_ALLOW_CNAME_MISMATCH;\n\n\t    ret = process_pa_data_to_key(context, ctx, &ctx->cred,\n\t\t\t\t\t &ctx->as_req, &rep.kdc_rep,\n\t\t\t\t\t hostinfo, &ctx->fast_state.reply_key);\n\t    if (ret) {\n\t\tfree_AS_REP(&rep.kdc_rep);\n\t\tgoto out;\n\t    }\n\n\t    _krb5_debug(context, 5, \"krb5_get_init_creds: extracting ticket\");\n\n\t    ret = _krb5_extract_ticket(context,\n\t\t\t\t       &rep,\n\t\t\t\t       &ctx->cred,\n\t\t\t\t       ctx->fast_state.reply_key,\n\t\t\t\t       NULL,\n\t\t\t\t       KRB5_KU_AS_REP_ENC_PART,\n\t\t\t\t       NULL,\n\t\t\t\t       ctx->nonce,\n\t\t\t\t       eflags,\n\t\t\t\t       &ctx->req_buffer,\n\t\t\t\t       NULL,\n\t\t\t\t       NULL);\n\t    if (ret == 0)\n\t\tret = copy_EncKDCRepPart(&rep.enc_part, &ctx->enc_part);\n\n\t    krb5_free_keyblock(context, ctx->fast_state.reply_key);\n\t    ctx->fast_state.reply_key = NULL;\n\t    *flags = 0;\n\n\t    free_AS_REP(&rep.kdc_rep);\n\t    free_EncASRepPart(&rep.enc_part);\n\n\t    return ret;\n\n\t} else {\n\t    /* let's try to parse it as a KRB-ERROR */\n\n\t    _krb5_debug(context, 5, \"krb5_get_init_creds: got an error\");\n\n\t    free_KRB_ERROR(&ctx->error);\n\n\t    ret = krb5_rd_error(context, in, &ctx->error);\n\t    if(ret && in->length && ((char*)in->data)[0] == 4)\n\t\tret = KRB5KRB_AP_ERR_V4_REPLY;\n\t    if (ret) {\n\t\t_krb5_debug(context, 5, \"krb5_get_init_creds: failed to read error\");\n\t\tgoto out;\n\t    }\n\n\t    /*\n\t     * Unwrap KRB-ERROR\n\t     */\n\t    ret = fast_unwrap_error(context, &ctx->fast_state, &ctx->error);\n\t    if (ret)\n\t\tgoto out;\n\n\t    /*\n\t     *\n\t     */\n\n\t    ret = krb5_error_from_rd_error(context, &ctx->error, &ctx->cred);\n\n\t    _krb5_debug(context, 5, \"krb5_get_init_creds: KRB-ERROR %d\", ret);\n\n\t    /*\n\t     * If no preauth was set and KDC requires it, give it one\n\t     * more try.\n\t     */\n\n\t    if (ret == KRB5KDC_ERR_PREAUTH_REQUIRED) {\n\n\t        free_METHOD_DATA(&ctx->md);\n\t        memset(&ctx->md, 0, sizeof(ctx->md));\n\n\t\tif (ctx->error.e_data) {\n\t\t    ret = decode_METHOD_DATA(ctx->error.e_data->data,\n\t\t\t\t\t     ctx->error.e_data->length,\n\t\t\t\t\t     &ctx->md,\n\t\t\t\t\t     NULL);\n\t\t    if (ret)\n\t\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t\t       N_(\"Failed to decode METHOD-DATA\", \"\"));\n\t\t} else {\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t   N_(\"Preauth required but no preauth \"\n\t\t\t\t\t      \"options send by KDC\", \"\"));\n\t\t}\n\t    } else if (ret == KRB5KRB_AP_ERR_SKEW && context->kdc_sec_offset == 0) {\n\t\t/*\n\t\t * Try adapt to timeskrew when we are using pre-auth, and\n\t\t * if there was a time skew, try again.\n\t\t */\n\t\tkrb5_set_real_time(context, ctx->error.stime, -1);\n\t\tif (context->kdc_sec_offset)\n\t\t    ret = 0;\n\n\t\t_krb5_debug(context, 10, \"init_creds: err skew updateing kdc offset to %d\",\n\t\t\t    context->kdc_sec_offset);\n\n\t\tctx->used_pa_types = 0;\n\n\t    } else if (ret == KRB5_KDC_ERR_WRONG_REALM && ctx->flags.canonicalize) {\n\t        /* client referal to a new realm */\n\n\t\tif (ctx->error.crealm == NULL) {\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t   N_(\"Got a client referral, not but no realm\", \"\"));\n\t\t    goto out;\n\t\t}\n\t\t_krb5_debug(context, 5,\n\t\t\t    \"krb5_get_init_creds: got referal to realm %s\",\n\t\t\t    *ctx->error.crealm);\n\n\t\tret = krb5_principal_set_realm(context,\n\t\t\t\t\t       ctx->cred.client,\n\t\t\t\t\t       *ctx->error.crealm);\n\t\tif (ret)\n\t\t    goto out;\n\n\t\tif (krb5_principal_is_krbtgt(context, ctx->cred.server)) {\n\t\t    ret = krb5_init_creds_set_service(context, ctx, NULL);\n\t\t    if (ret)\n\t\t\tgoto out;\n\t\t}\n\n\t\tfree_AS_REQ(&ctx->as_req);\n\t\tmemset(&ctx->as_req, 0, sizeof(ctx->as_req));\n\n\t\tctx->used_pa_types = 0;\n\t    } else if (ret == KRB5KDC_ERR_KEY_EXP && ctx->runflags.change_password == 0 && ctx->prompter) {\n\t\tchar buf2[1024];\n\n\t\tctx->runflags.change_password = 1;\n\n\t\tctx->prompter(context, ctx->prompter_data, NULL, N_(\"Password has expired\", \"\"), 0, NULL);\n\n\n\t\t/* try to avoid recursion */\n\t\tif (ctx->in_tkt_service != NULL && strcmp(ctx->in_tkt_service, \"kadmin/changepw\") == 0)\n\t\t    goto out;\n\n                /* don't try to change password where then where none */\n                if (ctx->prompter == NULL)\n                    goto out;\n\n\t\tret = change_password(context,\n\t\t\t\t      ctx->cred.client,\n\t\t\t\t      ctx->password,\n\t\t\t\t      buf2,\n\t\t\t\t      sizeof(buf2),\n\t\t\t\t      ctx->prompter,\n\t\t\t\t      ctx->prompter_data,\n\t\t\t\t      NULL);\n\t\tif (ret)\n\t\t    goto out;\n\n\t\tkrb5_init_creds_set_password(context, ctx, buf2);\n\n \t\tctx->used_pa_types = 0;\n\t\tret = 0;\n\n \t    } else if (ret == KRB5KDC_ERR_PREAUTH_FAILED) {\n \n \t\tif (ctx->fast_state.flags & KRB5_FAST_DISABLED)\n \t\t    goto out;\n \t\tif (ctx->fast_state.flags & (KRB5_FAST_REQUIRED | KRB5_FAST_EXPECTED))\n \t\t    goto out;\n \n \t\t_krb5_debug(context, 10, \"preauth failed with FAST, \"\n\t\t\t    \"and told by KD or user, trying w/o FAST\");\n \n \t\tctx->fast_state.flags |= KRB5_FAST_DISABLED;\n \t\tctx->used_pa_types = 0;\n\t\tret = 0;\n\t    }\n\t    if (ret)\n\t\tgoto out;\n\t}\n    }\n\n    if (ctx->as_req.req_body.cname == NULL) {\n\tret = init_as_req(context, ctx->flags, &ctx->cred,\n\t\t\t  ctx->addrs, ctx->etypes, &ctx->as_req);\n\tif (ret) {\n\t    free_init_creds_ctx(context, ctx);\n\t    return ret;\n\t}\n    }\n\n    if (ctx->as_req.padata) {\n\tfree_METHOD_DATA(ctx->as_req.padata);\n\tfree(ctx->as_req.padata);\n\tctx->as_req.padata = NULL;\n    }\n\n    /* Set a new nonce. */\n    ctx->as_req.req_body.nonce = ctx->nonce;\n\n    /* fill_in_md_data */\n    ret = process_pa_data_to_md(context, &ctx->cred, &ctx->as_req, ctx,\n\t\t\t\t&ctx->md, &ctx->as_req.padata,\n\t\t\t\tctx->prompter, ctx->prompter_data);\n    if (ret)\n\tgoto out;\n\n    /*\n     * Wrap with FAST\n     */\n    copy_AS_REQ(&ctx->as_req, &req2);\n\n    ret = fast_wrap_req(context, &ctx->fast_state, &req2);\n    if (ret) {\n\tfree_AS_REQ(&req2);\n\tgoto out;\n    }\n\n    krb5_data_free(&ctx->req_buffer);\n\n    ASN1_MALLOC_ENCODE(AS_REQ,\n\t\t       ctx->req_buffer.data, ctx->req_buffer.length,\n\t\t       &req2, &len, ret);\n    free_AS_REQ(&req2);\n    if (ret)\n\tgoto out;\n    if(len != ctx->req_buffer.length)\n\tkrb5_abortx(context, \"internal error in ASN.1 encoder\");\n\n    out->data = ctx->req_buffer.data;\n    out->length = ctx->req_buffer.length;\n\n    *flags = KRB5_INIT_CREDS_STEP_FLAG_CONTINUE;\n\n    return 0;\n out:\n    return ret;\n}\n\n/**\n * Extract the newly acquired credentials from krb5_init_creds_context\n * context.\n *\n * @param context A Kerberos 5 context.\n * @param ctx\n * @param cred credentials, free with krb5_free_cred_contents().\n *\n * @return 0 for sucess or An Kerberos error code, see krb5_get_error_message().\n */\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_init_creds_get_creds(krb5_context context,\n\t\t\t  krb5_init_creds_context ctx,\n\t\t\t  krb5_creds *cred)\n{\n    return krb5_copy_creds_contents(context, &ctx->cred, cred);\n}\n\n/**\n * Get the last error from the transaction.\n *\n * @return Returns 0 or an error code\n *\n * @ingroup krb5_credential\n */\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_init_creds_get_error(krb5_context context,\n\t\t\t  krb5_init_creds_context ctx,\n\t\t\t  KRB_ERROR *error)\n{\n    krb5_error_code ret;\n\n    ret = copy_KRB_ERROR(&ctx->error, error);\n    if (ret)\n\tkrb5_enomem(context);\n\n    return ret;\n}\n\n/**\n *\n * @ingroup krb5_credential\n */\n\nkrb5_error_code\nkrb5_init_creds_store(krb5_context context,\n\t\t      krb5_init_creds_context ctx,\n\t\t      krb5_ccache id)\n{\n    krb5_error_code ret;\n\n    if (ctx->cred.client == NULL) {\n\tret = KRB5KDC_ERR_PREAUTH_REQUIRED;\n\tkrb5_set_error_message(context, ret, \"init creds not completed yet\");\n\treturn ret;\n    }\n\n    ret = krb5_cc_initialize(context, id, ctx->cred.client);\n    if (ret)\n\treturn ret;\n\n    ret = krb5_cc_store_cred(context, id, &ctx->cred);\n    if (ret)\n\treturn ret;\n\n    if (ctx->cred.flags.b.enc_pa_rep) {\n\tkrb5_data data = { 3, rk_UNCONST(\"yes\") };\n\tret = krb5_cc_set_config(context, id, ctx->cred.server,\n\t\t\t\t \"fast_avail\", &data);\n\tif (ret)\n\t    return ret;\n    }\n\n    return ret;\n}\n\n/**\n * Free the krb5_init_creds_context allocated by krb5_init_creds_init().\n *\n * @param context A Kerberos 5 context.\n * @param ctx The krb5_init_creds_context to free.\n *\n * @ingroup krb5_credential\n */\n\nKRB5_LIB_FUNCTION void KRB5_LIB_CALL\nkrb5_init_creds_free(krb5_context context,\n\t\t     krb5_init_creds_context ctx)\n{\n    free_init_creds_ctx(context, ctx);\n    free(ctx);\n}\n\n/**\n * Get new credentials as setup by the krb5_init_creds_context.\n *\n * @param context A Kerberos 5 context.\n * @param ctx The krb5_init_creds_context to process.\n *\n * @ingroup krb5_credential\n */\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_init_creds_get(krb5_context context, krb5_init_creds_context ctx)\n{\n    krb5_sendto_ctx stctx = NULL;\n    krb5_krbhst_info *hostinfo = NULL;\n    krb5_error_code ret;\n    krb5_data in, out;\n    unsigned int flags = 0;\n\n    krb5_data_zero(&in);\n    krb5_data_zero(&out);\n\n    ret = krb5_sendto_ctx_alloc(context, &stctx);\n    if (ret)\n\tgoto out;\n    krb5_sendto_ctx_set_func(stctx, _krb5_kdc_retry, NULL);\n\n    while (1) {\n\tflags = 0;\n\tret = krb5_init_creds_step(context, ctx, &in, &out, hostinfo, &flags);\n\tkrb5_data_free(&in);\n\tif (ret)\n\t    goto out;\n\n\tif ((flags & 1) == 0)\n\t    break;\n\n\tret = krb5_sendto_context (context, stctx, &out,\n\t\t\t\t   ctx->cred.client->realm, &in);\n    \tif (ret)\n\t    goto out;\n\n    }\n\n out:\n    if (stctx)\n\tkrb5_sendto_ctx_free(context, stctx);\n\n    return ret;\n}\n\n/**\n * Get new credentials using password.\n *\n * @ingroup krb5_credential\n */\n\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_get_init_creds_password(krb5_context context,\n\t\t\t     krb5_creds *creds,\n\t\t\t     krb5_principal client,\n\t\t\t     const char *password,\n\t\t\t     krb5_prompter_fct prompter,\n\t\t\t     void *data,\n\t\t\t     krb5_deltat start_time,\n\t\t\t     const char *in_tkt_service,\n\t\t\t     krb5_get_init_creds_opt *options)\n{\n    krb5_init_creds_context ctx;\n    char buf[BUFSIZ], buf2[BUFSIZ];\n    krb5_error_code ret;\n    int chpw = 0;\n\n again:\n    ret = krb5_init_creds_init(context, client, prompter, data, start_time, options, &ctx);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_init_creds_set_service(context, ctx, in_tkt_service);\n    if (ret)\n\tgoto out;\n\n    if (prompter != NULL && ctx->password == NULL && password == NULL) {\n\tkrb5_prompt prompt;\n\tkrb5_data password_data;\n\tchar *p, *q = NULL;\n\tint aret;\n\n\tret = krb5_unparse_name(context, client, &p);\n\tif (ret)\n\t    goto out;\n\n\taret = asprintf(&q, \"%s's Password: \", p);\n\tfree (p);\n\tif (aret == -1 || q == NULL) {\n\t    ret = krb5_enomem(context);\n\t    goto out;\n\t}\n\tprompt.prompt = q;\n\tpassword_data.data   = buf;\n\tpassword_data.length = sizeof(buf);\n\tprompt.hidden = 1;\n\tprompt.reply  = &password_data;\n\tprompt.type   = KRB5_PROMPT_TYPE_PASSWORD;\n\n\tret = (*prompter) (context, data, NULL, NULL, 1, &prompt);\n\tfree (q);\n\tif (ret) {\n\t    memset (buf, 0, sizeof(buf));\n\t    ret = KRB5_LIBOS_PWDINTR;\n\t    krb5_clear_error_message (context);\n\t    goto out;\n\t}\n\tpassword = password_data.data;\n    }\n\n    if (password) {\n\tret = krb5_init_creds_set_password(context, ctx, password);\n\tif (ret)\n\t    goto out;\n    }\n\n    ret = krb5_init_creds_get(context, ctx);\n\n    if (ret == 0)\n\tkrb5_process_last_request(context, options, ctx);\n\n\n    if (ret == KRB5KDC_ERR_KEY_EXPIRED && chpw == 0) {\n\t/* try to avoid recursion */\n\tif (in_tkt_service != NULL && strcmp(in_tkt_service, \"kadmin/changepw\") == 0)\n\t   goto out;\n\n\t/* don't try to change password where then where none */\n\tif (prompter == NULL)\n\t    goto out;\n\n\tif ((options->flags & KRB5_GET_INIT_CREDS_OPT_CHANGE_PASSWORD_PROMPT) &&\n            !options->change_password_prompt)\n\t\tgoto out;\n\n\tret = change_password (context,\n\t\t\t       client,\n\t\t\t       ctx->password,\n\t\t\t       buf2,\n\t\t\t       sizeof(buf2),\n\t\t\t       prompter,\n\t\t\t       data,\n\t\t\t       options);\n\tif (ret)\n\t    goto out;\n\tpassword = buf2;\n\tchpw = 1;\n\tkrb5_init_creds_free(context, ctx);\n\tgoto again;\n    }\n\n out:\n    if (ret == 0)\n\tkrb5_init_creds_get_creds(context, ctx, creds);\n\n    if (ctx)\n\tkrb5_init_creds_free(context, ctx);\n\n    memset(buf, 0, sizeof(buf));\n    memset(buf2, 0, sizeof(buf2));\n    return ret;\n}\n\n/**\n * Get new credentials using keyblock.\n *\n * @ingroup krb5_credential\n */\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_get_init_creds_keyblock(krb5_context context,\n\t\t\t     krb5_creds *creds,\n\t\t\t     krb5_principal client,\n\t\t\t     krb5_keyblock *keyblock,\n\t\t\t     krb5_deltat start_time,\n\t\t\t     const char *in_tkt_service,\n\t\t\t     krb5_get_init_creds_opt *options)\n{\n    krb5_init_creds_context ctx;\n    krb5_error_code ret;\n\n    memset(creds, 0, sizeof(*creds));\n\n    ret = krb5_init_creds_init(context, client, NULL, NULL, start_time, options, &ctx);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_init_creds_set_service(context, ctx, in_tkt_service);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_init_creds_set_keyblock(context, ctx, keyblock);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_init_creds_get(context, ctx);\n\n    if (ret == 0)\n        krb5_process_last_request(context, options, ctx);\n\n out:\n    if (ret == 0)\n\tkrb5_init_creds_get_creds(context, ctx, creds);\n\n    if (ctx)\n\tkrb5_init_creds_free(context, ctx);\n\n    return ret;\n}\n\n/**\n * Get new credentials using keytab.\n *\n * @ingroup krb5_credential\n */\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_get_init_creds_keytab(krb5_context context,\n\t\t\t   krb5_creds *creds,\n\t\t\t   krb5_principal client,\n\t\t\t   krb5_keytab keytab,\n\t\t\t   krb5_deltat start_time,\n\t\t\t   const char *in_tkt_service,\n\t\t\t   krb5_get_init_creds_opt *options)\n{\n    krb5_init_creds_context ctx;\n    krb5_keytab_entry ktent;\n    krb5_error_code ret;\n\n    memset(&ktent, 0, sizeof(ktent));\n    memset(creds, 0, sizeof(*creds));\n\n    if (strcmp(client->realm, \"\") == 0) {\n        /*\n         * Referral realm.  We have a keytab, so pick a realm by\n         * matching in the keytab.\n         */\n        ret = krb5_kt_get_entry(context, keytab, client, 0, 0, &ktent);\n        if (ret == 0)\n            client = ktent.principal;\n    }\n\n    ret = krb5_init_creds_init(context, client, NULL, NULL, start_time, options, &ctx);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_init_creds_set_service(context, ctx, in_tkt_service);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_init_creds_set_keytab(context, ctx, keytab);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_init_creds_get(context, ctx);\n    if (ret == 0)\n        krb5_process_last_request(context, options, ctx);\n\n out:\n    krb5_kt_free_entry(context, &ktent);\n    if (ret == 0)\n\tkrb5_init_creds_get_creds(context, ctx, creds);\n\n    if (ctx)\n\tkrb5_init_creds_free(context, ctx);\n\n    return ret;\n}\n", "/*\n * Copyright (c) 1997-2016 Kungliga Tekniska H\u00f6gskolan\n * (Royal Institute of Technology, Stockholm, Sweden).\n * All rights reserved.\n *\n * Portions Copyright (c) 2009 Apple Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the Institute nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n/* $Id$ */\n\n#ifndef __KRB5_LOCL_H__\n#define __KRB5_LOCL_H__\n\n#include <config.h>\n#include <roken.h>\n\n#include <ctype.h>\n\n#ifdef HAVE_POLL_H\n#include <sys/poll.h>\n#endif\n\n#include <krb5-types.h>\n\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_MMAN_H\n#include <sys/mman.h>\n#endif\n\n#if defined(HAVE_SYS_IOCTL_H) && SunOS != 40\n#include <sys/ioctl.h>\n#endif\n#ifdef HAVE_PWD_H\n#undef _POSIX_PTHREAD_SEMANTICS\n/* This gets us the 5-arg getpwnam_r on Solaris 9.  */\n#define _POSIX_PTHREAD_SEMANTICS\n#include <pwd.h>\n#endif\n\n#ifdef HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n#ifdef _AIX\nstruct mbuf;\n#endif\n#ifdef HAVE_SYS_FILIO_H\n#include <sys/filio.h>\n#endif\n#ifdef HAVE_SYS_FILE_H\n#include <sys/file.h>\n#endif\n\n#include <com_err.h>\n\n#include <heimbase.h>\n\n#define HEIMDAL_TEXTDOMAIN \"heimdal_krb5\"\n\n#ifdef LIBINTL\n#include <libintl.h>\n#define N_(x,y) dgettext(HEIMDAL_TEXTDOMAIN, x)\n#else\n#define N_(x,y) (x)\n#define bindtextdomain(package, localedir)\n#endif\n\n\n#ifdef HAVE_CRYPT_H\n#undef des_encrypt\n#define des_encrypt wingless_pigs_mostly_fail_to_fly\n#include <crypt.h>\n#undef des_encrypt\n#endif\n\n#ifdef HAVE_DOOR_CREATE\n#include <door.h>\n#endif\n\n#include <parse_time.h>\n#include <base64.h>\n\n#include <wind.h>\n\n/*\n * We use OpenSSL for EC, but to do this we need to disable cross-references\n * between OpenSSL and hcrypto bn.h and such.  Source files that use OpenSSL EC\n * must define HEIM_NO_CRYPTO_HDRS before including this file.\n */\n#define HC_DEPRECATED_CRYPTO\n#ifndef HEIM_NO_CRYPTO_HDRS\n#include \"crypto-headers.h\"\n#endif\n\n\n#include <krb5_asn1.h>\n#include <pkinit_asn1.h>\n\nstruct send_to_kdc;\n\n/* XXX glue for pkinit */\nstruct hx509_certs_data;\nstruct krb5_pk_identity;\nstruct krb5_pk_cert;\nstruct ContentInfo;\nstruct AlgorithmIdentifier;\ntypedef struct krb5_pk_init_ctx_data *krb5_pk_init_ctx;\nstruct krb5_dh_moduli;\n\n/* v4 glue */\nstruct _krb5_krb_auth_data;\n\n#include <der.h>\n\n#include <krb5.h>\n#include <krb5_err.h>\n#include <asn1_err.h>\n#ifdef PKINIT\n#include <hx509.h>\n#endif\n\n#include \"crypto.h\"\n\n#include <krb5-private.h>\n\n#include \"heim_threads.h\"\n\n#define ALLOC(X, N) (X) = calloc((N), sizeof(*(X)))\n#define ALLOC_SEQ(X, N) do { (X)->len = (N); ALLOC((X)->val, (N)); } while(0)\n\n#ifndef __func__\n#define __func__ \"unknown-function\"\n#endif\n\n#define krb5_einval(context, argnum) _krb5_einval((context), __func__, (argnum))\n\n#ifndef PATH_SEP\n#define PATH_SEP \":\"\n#endif\n\n/* should this be public? */\n#define KEYTAB_DEFAULT \"FILE:\" SYSCONFDIR \"/krb5.keytab\"\n#define KEYTAB_DEFAULT_MODIFY \"FILE:\" SYSCONFDIR \"/krb5.keytab\"\n\n\n#define MODULI_FILE SYSCONFDIR \"/krb5.moduli\"\n\n#ifndef O_BINARY\n#define O_BINARY 0\n#endif\n\n#ifndef O_CLOEXEC\n#define O_CLOEXEC 0\n#endif\n\n#ifndef SOCK_CLOEXEC\n#define SOCK_CLOEXEC 0\n#endif\n\n\n#define KRB5_BUFSIZ 2048\n\ntypedef enum {\n    KRB5_INIT_CREDS_TRISTATE_UNSET = 0,\n    KRB5_INIT_CREDS_TRISTATE_TRUE,\n    KRB5_INIT_CREDS_TRISTATE_FALSE\n} krb5_get_init_creds_tristate;\n\nstruct _krb5_get_init_creds_opt_private {\n    int refcount;\n    /* ENC_TIMESTAMP */\n    const char *password;\n    krb5_s2k_proc key_proc;\n    /* PA_PAC_REQUEST */\n    krb5_get_init_creds_tristate req_pac;\n    /* PKINIT */\n    krb5_pk_init_ctx pk_init_ctx;\n    krb5_get_init_creds_tristate addressless;\n    int flags;\n#define KRB5_INIT_CREDS_CANONICALIZE\t\t1\n#define KRB5_INIT_CREDS_NO_C_CANON_CHECK\t2\n#define KRB5_INIT_CREDS_NO_C_NO_EKU_CHECK\t4\n    struct {\n        krb5_gic_process_last_req func;\n        void *ctx;\n    } lr;\n};\n\ntypedef uint32_t krb5_enctype_set;\n\ntypedef struct krb5_context_data {\n    krb5_enctype *etypes;\n    krb5_enctype *cfg_etypes;\n    krb5_enctype *etypes_des;/* deprecated */\n    krb5_enctype *as_etypes;\n    krb5_enctype *tgs_etypes;\n    krb5_enctype *permitted_enctypes;\n    char **default_realms;\n    time_t max_skew;\n    time_t kdc_timeout;\n    time_t host_timeout;\n    unsigned max_retries;\n    int32_t kdc_sec_offset;\n    int32_t kdc_usec_offset;\n    krb5_config_section *cf;\n    struct et_list *et_list;\n    struct krb5_log_facility *warn_dest;\n    struct krb5_log_facility *debug_dest;\n    const krb5_cc_ops **cc_ops;\n    int num_cc_ops;\n    const char *http_proxy;\n    const char *time_fmt;\n    krb5_boolean log_utc;\n    const char *default_keytab;\n    const char *default_keytab_modify;\n    krb5_boolean use_admin_kdc;\n    krb5_addresses *extra_addresses;\n    krb5_boolean scan_interfaces;\t/* `ifconfig -a' */\n    krb5_boolean srv_lookup;\t\t/* do SRV lookups */\n    krb5_boolean srv_try_txt;\t\t/* try TXT records also */\n    int32_t fcache_vno;\t\t\t/* create cache files w/ this\n                                           version */\n    int num_kt_types;\t\t\t/* # of registered keytab types */\n    struct krb5_keytab_data *kt_types;  /* registered keytab types */\n    const char *date_fmt;\n    char *error_string;\n    krb5_error_code error_code;\n    krb5_addresses *ignore_addresses;\n    char *default_cc_name;\n    char *default_cc_name_env;\n    int default_cc_name_set;\n    HEIMDAL_MUTEX mutex;\t\t/* protects error_string */\n    int large_msg_size;\n    int max_msg_size;\n    int tgs_negative_timeout;\t\t/* timeout for TGS negative cache */\n    int flags;\n#define KRB5_CTX_F_DNS_CANONICALIZE_HOSTNAME\t1\n#define KRB5_CTX_F_CHECK_PAC\t\t\t2\n#define KRB5_CTX_F_HOMEDIR_ACCESS\t\t4\n#define KRB5_CTX_F_SOCKETS_INITIALIZED          8\n#define KRB5_CTX_F_RD_REQ_IGNORE\t\t16\n#define KRB5_CTX_F_FCACHE_STRICT_CHECKING\t32\n    struct send_to_kdc *send_to_kdc;\n#ifdef PKINIT\n    hx509_context hx509ctx;\n#endif\n    unsigned int num_kdc_requests;\n    krb5_name_canon_rule name_canon_rules;\n} krb5_context_data;\n\n#ifndef KRB5_USE_PATH_TOKENS\n#define KRB5_DEFAULT_CCNAME_FILE \"FILE:/tmp/krb5cc_%{uid}\"\n#define KRB5_DEFAULT_CCNAME_DIR \"DIR:/tmp/krb5cc_%{uid}_dir/\"\n#else\n#define KRB5_DEFAULT_CCNAME_FILE \"FILE:%{TEMP}/krb5cc_%{uid}\"\n#define KRB5_DEFAULT_CCNAME_DIR \"DIR:%{TEMP}/krb5cc_%{uid}_dir/\"\n#endif\n#define KRB5_DEFAULT_CCNAME_API \"API:\"\n#define KRB5_DEFAULT_CCNAME_KCM_KCM \"KCM:%{uid}\"\n#define KRB5_DEFAULT_CCNAME_KCM_API \"API:%{uid}\"\n\n#define EXTRACT_TICKET_ALLOW_CNAME_MISMATCH\t\t1\n#define EXTRACT_TICKET_ALLOW_SERVER_MISMATCH\t\t2\n#define EXTRACT_TICKET_MATCH_REALM\t\t\t4\n#define EXTRACT_TICKET_AS_REQ\t\t\t\t8\n#define EXTRACT_TICKET_TIMESYNC\t\t\t\t16\n\n/*\n * Configurable options\n */\n\n#ifndef KRB5_DEFAULT_CCTYPE\n#ifdef __APPLE__\n#define KRB5_DEFAULT_CCTYPE (&krb5_acc_ops)\n#else\n#define KRB5_DEFAULT_CCTYPE (&krb5_fcc_ops)\n#endif\n#endif\n\n#ifndef KRB5_ADDRESSLESS_DEFAULT\n#define KRB5_ADDRESSLESS_DEFAULT TRUE\n#endif\n\n#ifndef KRB5_FORWARDABLE_DEFAULT\n#define KRB5_FORWARDABLE_DEFAULT TRUE\n#endif\n\n#ifndef KRB5_CONFIGURATION_CHANGE_NOTIFY_NAME\n#define KRB5_CONFIGURATION_CHANGE_NOTIFY_NAME \"org.h5l.Kerberos.configuration-changed\"\n#endif\n\n#ifndef KRB5_FALLBACK_DEFAULT\n#define KRB5_FALLBACK_DEFAULT TRUE\n#endif\n\n#ifndef KRB5_TKT_LIFETIME_DEFAULT\n# define KRB5_TKT_LIFETIME_DEFAULT        15778800  /* seconds */\n#endif\n\n#ifndef KRB5_TKT_RENEW_LIFETIME_DEFAULT\n# define KRB5_TKT_RENEW_LIFETIME_DEFAULT  15778800  /* seconds */\n#endif\n\n#ifdef PKINIT\n\nstruct krb5_pk_identity {\n    hx509_verify_ctx verify_ctx;\n    hx509_certs certs;\n    hx509_cert cert;\n    hx509_certs anchors;\n    hx509_certs certpool;\n    hx509_revoke_ctx revokectx;\n    int flags;\n#define PKINIT_BTMM 1\n};\n\nenum krb5_pk_type {\n    PKINIT_WIN2K = 1,\n    PKINIT_27 = 2\n};\n\nenum keyex_enum { USE_RSA, USE_DH, USE_ECDH };\n\nstruct krb5_pk_init_ctx_data {\n    struct krb5_pk_identity *id;\n    enum keyex_enum keyex;\n    union {\n\tDH *dh;\n        void *eckey;\n    } u;\n    krb5_data *clientDHNonce;\n    struct krb5_dh_moduli **m;\n    hx509_peer_info peer;\n    enum krb5_pk_type type;\n    unsigned int require_binding:1;\n    unsigned int require_eku:1;\n    unsigned int require_krbtgt_otherName:1;\n    unsigned int require_hostname_match:1;\n    unsigned int trustedCertifiers:1;\n    unsigned int anonymous:1;\n};\n\n#endif /* PKINIT */\n\n#define ISTILDE(x) (x == '~')\n#ifdef _WIN32\n# define ISPATHSEP(x) (x == '/' || x =='\\\\')\n#else\n# define ISPATHSEP(x) (x == '/')\n#endif\n\n/* _krb5_principal_is_anonymous() */\n#define KRB5_ANON_MATCH_AUTHENTICATED\t1 /* authenticated with anon flag */\n#define KRB5_ANON_MATCH_UNAUTHENTICATED\t2 /* anonymous PKINIT */\n#define KRB5_ANON_MATCH_ANY\t\t( KRB5_ANON_MATCH_AUTHENTICATED | KRB5_ANON_MATCH_UNAUTHENTICATED )\n\n#endif /* __KRB5_LOCL_H__ */\n", "/*\n * Copyright (c) 2003 - 2016 Kungliga Tekniska H\u00f6gskolan\n * (Royal Institute of Technology, Stockholm, Sweden).\n * All rights reserved.\n *\n * Portions Copyright (c) 2009 Apple Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the Institute nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"krb5_locl.h\"\n\nstruct krb5_dh_moduli {\n    char *name;\n    unsigned long bits;\n    heim_integer p;\n    heim_integer g;\n    heim_integer q;\n};\n\n#ifdef PKINIT\n\n#include <cms_asn1.h>\n#include <pkcs8_asn1.h>\n#include <pkcs9_asn1.h>\n#include <pkcs12_asn1.h>\n#include <pkinit_asn1.h>\n#include <asn1_err.h>\n\n#include <der.h>\n\nstruct krb5_pk_cert {\n    hx509_cert cert;\n};\n\nstatic void\npk_copy_error(krb5_context context,\n\t      hx509_context hx509ctx,\n\t      int hxret,\n\t      const char *fmt,\n\t      ...)\n    __attribute__ ((__format__ (__printf__, 4, 5)));\n\n/*\n *\n */\n\nKRB5_LIB_FUNCTION void KRB5_LIB_CALL\n_krb5_pk_cert_free(struct krb5_pk_cert *cert)\n{\n    if (cert->cert) {\n\thx509_cert_free(cert->cert);\n    }\n    free(cert);\n}\n\nstatic krb5_error_code\nBN_to_integer(krb5_context context, BIGNUM *bn, heim_integer *integer)\n{\n    integer->length = BN_num_bytes(bn);\n    integer->data = malloc(integer->length);\n    if (integer->data == NULL) {\n\tkrb5_clear_error_message(context);\n\treturn ENOMEM;\n    }\n    BN_bn2bin(bn, integer->data);\n    integer->negative = BN_is_negative(bn);\n    return 0;\n}\n\nstatic BIGNUM *\ninteger_to_BN(krb5_context context, const char *field, const heim_integer *f)\n{\n    BIGNUM *bn;\n\n    bn = BN_bin2bn((const unsigned char *)f->data, f->length, NULL);\n    if (bn == NULL) {\n\tkrb5_set_error_message(context, ENOMEM,\n\t\t\t       N_(\"PKINIT: parsing BN failed %s\", \"\"), field);\n\treturn NULL;\n    }\n    BN_set_negative(bn, f->negative);\n    return bn;\n}\n\nstatic krb5_error_code\nselect_dh_group(krb5_context context, DH *dh, unsigned long bits,\n\t\tstruct krb5_dh_moduli **moduli)\n{\n    const struct krb5_dh_moduli *m;\n\n    if (bits == 0) {\n\tm = moduli[1]; /* XXX */\n\tif (m == NULL)\n\t    m = moduli[0]; /* XXX */\n    } else {\n\tint i;\n\tfor (i = 0; moduli[i] != NULL; i++) {\n\t    if (bits < moduli[i]->bits)\n\t\tbreak;\n\t}\n\tif (moduli[i] == NULL) {\n\t    krb5_set_error_message(context, EINVAL,\n\t\t\t\t   N_(\"Did not find a DH group parameter \"\n\t\t\t\t      \"matching requirement of %lu bits\", \"\"),\n\t\t\t\t   bits);\n\t    return EINVAL;\n\t}\n\tm = moduli[i];\n    }\n\n    dh->p = integer_to_BN(context, \"p\", &m->p);\n    if (dh->p == NULL)\n\treturn ENOMEM;\n    dh->g = integer_to_BN(context, \"g\", &m->g);\n    if (dh->g == NULL)\n\treturn ENOMEM;\n    dh->q = integer_to_BN(context, \"q\", &m->q);\n    if (dh->q == NULL)\n\treturn ENOMEM;\n\n    return 0;\n}\n\nstruct certfind {\n    const char *type;\n    const heim_oid *oid;\n};\n\n/*\n * Try searchin the key by to use by first looking for for PK-INIT\n * EKU, then the Microsoft smart card EKU and last, no special EKU at all.\n */\n\nstatic krb5_error_code\nfind_cert(krb5_context context, struct krb5_pk_identity *id,\n\t  hx509_query *q, hx509_cert *cert)\n{\n    struct certfind cf[4] = {\n\t{ \"MobileMe EKU\", NULL },\n\t{ \"PKINIT EKU\", NULL },\n\t{ \"MS EKU\", NULL },\n\t{ \"any (or no)\", NULL }\n    };\n    int ret = HX509_CERT_NOT_FOUND;\n    size_t i, start = 1;\n    unsigned oids[] = { 1, 2, 840, 113635, 100, 3, 2, 1 };\n    const heim_oid mobileMe = { sizeof(oids)/sizeof(oids[0]), oids };\n\n\n    if (id->flags & PKINIT_BTMM)\n\tstart = 0;\n\n    cf[0].oid = &mobileMe;\n    cf[1].oid = &asn1_oid_id_pkekuoid;\n    cf[2].oid = &asn1_oid_id_pkinit_ms_eku;\n    cf[3].oid = NULL;\n\n    for (i = start; i < sizeof(cf)/sizeof(cf[0]); i++) {\n\tret = hx509_query_match_eku(q, cf[i].oid);\n\tif (ret) {\n\t    pk_copy_error(context, context->hx509ctx, ret,\n\t\t\t  \"Failed setting %s OID\", cf[i].type);\n\t    return ret;\n\t}\n\n\tret = hx509_certs_find(context->hx509ctx, id->certs, q, cert);\n\tif (ret == 0)\n\t    break;\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"Failed finding certificate with %s OID\", cf[i].type);\n    }\n    return ret;\n}\n\n\nstatic krb5_error_code\ncreate_signature(krb5_context context,\n\t\t const heim_oid *eContentType,\n\t\t krb5_data *eContent,\n\t\t struct krb5_pk_identity *id,\n\t\t hx509_peer_info peer,\n\t\t krb5_data *sd_data)\n{\n    int ret, flags = 0;\n\n    if (id->cert == NULL)\n\tflags |= HX509_CMS_SIGNATURE_NO_SIGNER;\n\n    ret = hx509_cms_create_signed_1(context->hx509ctx,\n\t\t\t\t    flags,\n\t\t\t\t    eContentType,\n\t\t\t\t    eContent->data,\n\t\t\t\t    eContent->length,\n\t\t\t\t    NULL,\n\t\t\t\t    id->cert,\n\t\t\t\t    peer,\n\t\t\t\t    NULL,\n\t\t\t\t    id->certs,\n\t\t\t\t    sd_data);\n    if (ret) {\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"Create CMS signedData\");\n\treturn ret;\n    }\n\n    return 0;\n}\n\nstatic int\ncert2epi(hx509_context context, void *ctx, hx509_cert c)\n{\n    ExternalPrincipalIdentifiers *ids = ctx;\n    ExternalPrincipalIdentifier id;\n    hx509_name subject = NULL;\n    void *p;\n    int ret;\n\n    if (ids->len > 10)\n\treturn 0;\n\n    memset(&id, 0, sizeof(id));\n\n    ret = hx509_cert_get_subject(c, &subject);\n    if (ret)\n\treturn ret;\n\n    if (hx509_name_is_null_p(subject) != 0) {\n\n\tid.subjectName = calloc(1, sizeof(*id.subjectName));\n\tif (id.subjectName == NULL) {\n\t    hx509_name_free(&subject);\n\t    free_ExternalPrincipalIdentifier(&id);\n\t    return ENOMEM;\n\t}\n\n\tret = hx509_name_binary(subject, id.subjectName);\n\tif (ret) {\n\t    hx509_name_free(&subject);\n\t    free_ExternalPrincipalIdentifier(&id);\n\t    return ret;\n\t}\n    }\n    hx509_name_free(&subject);\n\n\n    id.issuerAndSerialNumber = calloc(1, sizeof(*id.issuerAndSerialNumber));\n    if (id.issuerAndSerialNumber == NULL) {\n\tfree_ExternalPrincipalIdentifier(&id);\n\treturn ENOMEM;\n    }\n\n    {\n\tIssuerAndSerialNumber iasn;\n\thx509_name issuer;\n\tsize_t size = 0;\n\n\tmemset(&iasn, 0, sizeof(iasn));\n\n\tret = hx509_cert_get_issuer(c, &issuer);\n\tif (ret) {\n\t    free_ExternalPrincipalIdentifier(&id);\n\t    return ret;\n\t}\n\n\tret = hx509_name_to_Name(issuer, &iasn.issuer);\n\thx509_name_free(&issuer);\n\tif (ret) {\n\t    free_ExternalPrincipalIdentifier(&id);\n\t    return ret;\n\t}\n\n\tret = hx509_cert_get_serialnumber(c, &iasn.serialNumber);\n\tif (ret) {\n\t    free_IssuerAndSerialNumber(&iasn);\n\t    free_ExternalPrincipalIdentifier(&id);\n\t    return ret;\n\t}\n\n\tASN1_MALLOC_ENCODE(IssuerAndSerialNumber,\n\t\t\t   id.issuerAndSerialNumber->data,\n\t\t\t   id.issuerAndSerialNumber->length,\n\t\t\t   &iasn, &size, ret);\n\tfree_IssuerAndSerialNumber(&iasn);\n\tif (ret) {\n            free_ExternalPrincipalIdentifier(&id);\n\t    return ret;\n        }\n\tif (id.issuerAndSerialNumber->length != size)\n\t    abort();\n    }\n\n    id.subjectKeyIdentifier = NULL;\n\n    p = realloc(ids->val, sizeof(ids->val[0]) * (ids->len + 1));\n    if (p == NULL) {\n\tfree_ExternalPrincipalIdentifier(&id);\n\treturn ENOMEM;\n    }\n\n    ids->val = p;\n    ids->val[ids->len] = id;\n    ids->len++;\n\n    return 0;\n}\n\nstatic krb5_error_code\nbuild_edi(krb5_context context,\n\t  hx509_context hx509ctx,\n\t  hx509_certs certs,\n\t  ExternalPrincipalIdentifiers *ids)\n{\n    return hx509_certs_iter_f(hx509ctx, certs, cert2epi, ids);\n}\n\nstatic krb5_error_code\nbuild_auth_pack(krb5_context context,\n\t\tunsigned nonce,\n\t\tkrb5_pk_init_ctx ctx,\n\t\tconst KDC_REQ_BODY *body,\n\t\tAuthPack *a)\n{\n    size_t buf_size, len = 0;\n    krb5_error_code ret;\n    void *buf;\n    krb5_timestamp sec;\n    int32_t usec;\n    Checksum checksum;\n\n    krb5_clear_error_message(context);\n\n    memset(&checksum, 0, sizeof(checksum));\n\n    krb5_us_timeofday(context, &sec, &usec);\n    a->pkAuthenticator.ctime = sec;\n    a->pkAuthenticator.nonce = nonce;\n\n    ASN1_MALLOC_ENCODE(KDC_REQ_BODY, buf, buf_size, body, &len, ret);\n    if (ret)\n\treturn ret;\n    if (buf_size != len)\n\tkrb5_abortx(context, \"internal error in ASN.1 encoder\");\n\n    ret = krb5_create_checksum(context,\n\t\t\t       NULL,\n\t\t\t       0,\n\t\t\t       CKSUMTYPE_SHA1,\n\t\t\t       buf,\n\t\t\t       len,\n\t\t\t       &checksum);\n    free(buf);\n    if (ret)\n\treturn ret;\n\n    ALLOC(a->pkAuthenticator.paChecksum, 1);\n    if (a->pkAuthenticator.paChecksum == NULL) {\n\treturn krb5_enomem(context);\n    }\n\n    ret = krb5_data_copy(a->pkAuthenticator.paChecksum,\n\t\t\t checksum.checksum.data, checksum.checksum.length);\n    free_Checksum(&checksum);\n    if (ret)\n\treturn ret;\n\n    if (ctx->keyex == USE_DH || ctx->keyex == USE_ECDH) {\n\tconst char *moduli_file;\n\tunsigned long dh_min_bits;\n\tkrb5_data dhbuf;\n\tsize_t size = 0;\n\n\tkrb5_data_zero(&dhbuf);\n\n\n\n\tmoduli_file = krb5_config_get_string(context, NULL,\n\t\t\t\t\t     \"libdefaults\",\n\t\t\t\t\t     \"moduli\",\n\t\t\t\t\t     NULL);\n\n\tdh_min_bits =\n\t    krb5_config_get_int_default(context, NULL, 0,\n\t\t\t\t\t\"libdefaults\",\n\t\t\t\t\t\"pkinit_dh_min_bits\",\n\t\t\t\t\tNULL);\n\n\tret = _krb5_parse_moduli(context, moduli_file, &ctx->m);\n\tif (ret)\n\t    return ret;\n\n\tctx->u.dh = DH_new();\n\tif (ctx->u.dh == NULL)\n\t    return krb5_enomem(context);\n\n\tret = select_dh_group(context, ctx->u.dh, dh_min_bits, ctx->m);\n\tif (ret)\n\t    return ret;\n\n\tif (DH_generate_key(ctx->u.dh) != 1) {\n\t    krb5_set_error_message(context, ENOMEM,\n\t\t\t\t   N_(\"pkinit: failed to generate DH key\", \"\"));\n\t    return ENOMEM;\n\t}\n\n\n\tif (1 /* support_cached_dh */) {\n\t    ALLOC(a->clientDHNonce, 1);\n\t    if (a->clientDHNonce == NULL) {\n\t\tkrb5_clear_error_message(context);\n\t\treturn ENOMEM;\n\t    }\n\t    ret = krb5_data_alloc(a->clientDHNonce, 40);\n\t    if (a->clientDHNonce == NULL) {\n\t\tkrb5_clear_error_message(context);\n\t\treturn ret;\n\t    }\n\t    RAND_bytes(a->clientDHNonce->data, a->clientDHNonce->length);\n\t    ret = krb5_copy_data(context, a->clientDHNonce,\n\t\t\t\t &ctx->clientDHNonce);\n\t    if (ret)\n\t\treturn ret;\n\t}\n\n\tALLOC(a->clientPublicValue, 1);\n\tif (a->clientPublicValue == NULL)\n\t    return ENOMEM;\n\n\tif (ctx->keyex == USE_DH) {\n\t    DH *dh = ctx->u.dh;\n\t    DomainParameters dp;\n\t    heim_integer dh_pub_key;\n\n\t    ret = der_copy_oid(&asn1_oid_id_dhpublicnumber,\n\t\t\t       &a->clientPublicValue->algorithm.algorithm);\n\t    if (ret)\n\t\treturn ret;\n\n\t    memset(&dp, 0, sizeof(dp));\n\n\t    ret = BN_to_integer(context, dh->p, &dp.p);\n\t    if (ret) {\n\t\tfree_DomainParameters(&dp);\n\t\treturn ret;\n\t    }\n\t    ret = BN_to_integer(context, dh->g, &dp.g);\n\t    if (ret) {\n\t\tfree_DomainParameters(&dp);\n\t\treturn ret;\n\t    }\n\t    dp.q = calloc(1, sizeof(*dp.q));\n\t    if (dp.q == NULL) {\n\t\tfree_DomainParameters(&dp);\n\t\treturn ENOMEM;\n\t    }\n\t    ret = BN_to_integer(context, dh->q, dp.q);\n\t    if (ret) {\n\t\tfree_DomainParameters(&dp);\n\t\treturn ret;\n\t    }\n\t    dp.j = NULL;\n\t    dp.validationParms = NULL;\n\n\t    a->clientPublicValue->algorithm.parameters =\n\t\tmalloc(sizeof(*a->clientPublicValue->algorithm.parameters));\n\t    if (a->clientPublicValue->algorithm.parameters == NULL) {\n\t\tfree_DomainParameters(&dp);\n\t\treturn ret;\n\t    }\n\n\t    ASN1_MALLOC_ENCODE(DomainParameters,\n\t\t\t       a->clientPublicValue->algorithm.parameters->data,\n\t\t\t       a->clientPublicValue->algorithm.parameters->length,\n\t\t\t       &dp, &size, ret);\n\t    free_DomainParameters(&dp);\n\t    if (ret)\n\t\treturn ret;\n\t    if (size != a->clientPublicValue->algorithm.parameters->length)\n\t\tkrb5_abortx(context, \"Internal ASN1 encoder error\");\n\n\t    ret = BN_to_integer(context, dh->pub_key, &dh_pub_key);\n\t    if (ret)\n\t\treturn ret;\n\n\t    ASN1_MALLOC_ENCODE(DHPublicKey, dhbuf.data, dhbuf.length,\n\t\t\t       &dh_pub_key, &size, ret);\n\t    der_free_heim_integer(&dh_pub_key);\n\t    if (ret)\n\t\treturn ret;\n\t    if (size != dhbuf.length)\n\t\tkrb5_abortx(context, \"asn1 internal error\");\n            a->clientPublicValue->subjectPublicKey.length = dhbuf.length * 8;\n            a->clientPublicValue->subjectPublicKey.data = dhbuf.data;\n\t} else if (ctx->keyex == USE_ECDH) {\n            ret = _krb5_build_authpack_subjectPK_EC(context, ctx, a);\n            if (ret)\n                return ret;\n\t} else\n\t    krb5_abortx(context, \"internal error\");\n    }\n\n    {\n\ta->supportedCMSTypes = calloc(1, sizeof(*a->supportedCMSTypes));\n\tif (a->supportedCMSTypes == NULL)\n\t    return ENOMEM;\n\n\tret = hx509_crypto_available(context->hx509ctx, HX509_SELECT_ALL,\n\t\t\t\t     ctx->id->cert,\n\t\t\t\t     &a->supportedCMSTypes->val,\n\t\t\t\t     &a->supportedCMSTypes->len);\n\tif (ret)\n\t    return ret;\n    }\n\n    return ret;\n}\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\n_krb5_pk_mk_ContentInfo(krb5_context context,\n\t\t\tconst krb5_data *buf,\n\t\t\tconst heim_oid *oid,\n\t\t\tstruct ContentInfo *content_info)\n{\n    krb5_error_code ret;\n\n    ret = der_copy_oid(oid, &content_info->contentType);\n    if (ret)\n\treturn ret;\n    ALLOC(content_info->content, 1);\n    if (content_info->content == NULL)\n\treturn ENOMEM;\n    content_info->content->data = malloc(buf->length);\n    if (content_info->content->data == NULL)\n\treturn ENOMEM;\n    memcpy(content_info->content->data, buf->data, buf->length);\n    content_info->content->length = buf->length;\n    return 0;\n}\n\nstatic krb5_error_code\npk_mk_padata(krb5_context context,\n\t     krb5_pk_init_ctx ctx,\n\t     const KDC_REQ_BODY *req_body,\n\t     unsigned nonce,\n\t     METHOD_DATA *md)\n{\n    struct ContentInfo content_info;\n    krb5_error_code ret;\n    const heim_oid *oid = NULL;\n    size_t size = 0;\n    krb5_data buf, sd_buf;\n    int pa_type = -1;\n\n    krb5_data_zero(&buf);\n    krb5_data_zero(&sd_buf);\n    memset(&content_info, 0, sizeof(content_info));\n\n    if (ctx->type == PKINIT_WIN2K) {\n\tAuthPack_Win2k ap;\n\tkrb5_timestamp sec;\n\tint32_t usec;\n\n\tmemset(&ap, 0, sizeof(ap));\n\n\t/* fill in PKAuthenticator */\n\tret = copy_PrincipalName(req_body->sname, &ap.pkAuthenticator.kdcName);\n\tif (ret) {\n\t    free_AuthPack_Win2k(&ap);\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\tret = copy_Realm(&req_body->realm, &ap.pkAuthenticator.kdcRealm);\n\tif (ret) {\n\t    free_AuthPack_Win2k(&ap);\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tkrb5_us_timeofday(context, &sec, &usec);\n\tap.pkAuthenticator.ctime = sec;\n\tap.pkAuthenticator.cusec = usec;\n\tap.pkAuthenticator.nonce = nonce;\n\n\tASN1_MALLOC_ENCODE(AuthPack_Win2k, buf.data, buf.length,\n\t\t\t   &ap, &size, ret);\n\tfree_AuthPack_Win2k(&ap);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"Failed encoding AuthPackWin: %d\", \"\"),\n\t\t\t\t   (int)ret);\n\t    goto out;\n\t}\n\tif (buf.length != size)\n\t    krb5_abortx(context, \"internal ASN1 encoder error\");\n\n\toid = &asn1_oid_id_pkcs7_data;\n    } else if (ctx->type == PKINIT_27) {\n\tAuthPack ap;\n\n\tmemset(&ap, 0, sizeof(ap));\n\n\tret = build_auth_pack(context, nonce, ctx, req_body, &ap);\n\tif (ret) {\n\t    free_AuthPack(&ap);\n\t    goto out;\n\t}\n\n\tASN1_MALLOC_ENCODE(AuthPack, buf.data, buf.length, &ap, &size, ret);\n\tfree_AuthPack(&ap);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"Failed encoding AuthPack: %d\", \"\"),\n\t\t\t\t   (int)ret);\n\t    goto out;\n\t}\n\tif (buf.length != size)\n\t    krb5_abortx(context, \"internal ASN1 encoder error\");\n\n\toid = &asn1_oid_id_pkauthdata;\n    } else\n\tkrb5_abortx(context, \"internal pkinit error\");\n\n    ret = create_signature(context, oid, &buf, ctx->id,\n\t\t\t   ctx->peer, &sd_buf);\n    krb5_data_free(&buf);\n    if (ret)\n\tgoto out;\n\n    ret = hx509_cms_wrap_ContentInfo(&asn1_oid_id_pkcs7_signedData, &sd_buf, &buf);\n    krb5_data_free(&sd_buf);\n    if (ret) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"ContentInfo wrapping of signedData failed\",\"\"));\n\tgoto out;\n    }\n\n    if (ctx->type == PKINIT_WIN2K) {\n\tPA_PK_AS_REQ_Win2k winreq;\n\n\tpa_type = KRB5_PADATA_PK_AS_REQ_WIN;\n\n\tmemset(&winreq, 0, sizeof(winreq));\n\n\twinreq.signed_auth_pack = buf;\n\n\tASN1_MALLOC_ENCODE(PA_PK_AS_REQ_Win2k, buf.data, buf.length,\n\t\t\t   &winreq, &size, ret);\n\tfree_PA_PK_AS_REQ_Win2k(&winreq);\n\n    } else if (ctx->type == PKINIT_27) {\n\tPA_PK_AS_REQ req;\n\n\tpa_type = KRB5_PADATA_PK_AS_REQ;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.signedAuthPack = buf;\n\n\tif (ctx->trustedCertifiers) {\n\n\t    req.trustedCertifiers = calloc(1, sizeof(*req.trustedCertifiers));\n\t    if (req.trustedCertifiers == NULL) {\n\t\tret = krb5_enomem(context);\n\t\tfree_PA_PK_AS_REQ(&req);\n\t\tgoto out;\n\t    }\n\t    ret = build_edi(context, context->hx509ctx,\n\t\t\t    ctx->id->anchors, req.trustedCertifiers);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       N_(\"pk-init: failed to build \"\n\t\t\t\t\t  \"trustedCertifiers\", \"\"));\n\t\tfree_PA_PK_AS_REQ(&req);\n\t\tgoto out;\n\t    }\n\t}\n\treq.kdcPkId = NULL;\n\n\tASN1_MALLOC_ENCODE(PA_PK_AS_REQ, buf.data, buf.length,\n\t\t\t   &req, &size, ret);\n\n\tfree_PA_PK_AS_REQ(&req);\n\n    } else\n\tkrb5_abortx(context, \"internal pkinit error\");\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"PA-PK-AS-REQ %d\", (int)ret);\n\tgoto out;\n    }\n    if (buf.length != size)\n\tkrb5_abortx(context, \"Internal ASN1 encoder error\");\n\n    ret = krb5_padata_add(context, md, pa_type, buf.data, buf.length);\n    if (ret)\n\tfree(buf.data);\n\n    if (ret == 0)\n    \tkrb5_padata_add(context, md, KRB5_PADATA_PK_AS_09_BINDING, NULL, 0);\n\n out:\n    free_ContentInfo(&content_info);\n\n    return ret;\n}\n\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\n_krb5_pk_mk_padata(krb5_context context,\n\t\t   void *c,\n\t\t   int ic_flags,\n\t\t   int win2k,\n\t\t   const KDC_REQ_BODY *req_body,\n\t\t   unsigned nonce,\n\t\t   METHOD_DATA *md)\n{\n    krb5_pk_init_ctx ctx = c;\n    int win2k_compat;\n\n    if (ctx->id->certs == NULL && ctx->anonymous == 0) {\n\tkrb5_set_error_message(context, HEIM_PKINIT_NO_PRIVATE_KEY,\n\t\t\t       N_(\"PKINIT: No user certificate given\", \"\"));\n\treturn HEIM_PKINIT_NO_PRIVATE_KEY;\n    }\n\n    win2k_compat = krb5_config_get_bool_default(context, NULL,\n\t\t\t\t\t\twin2k,\n\t\t\t\t\t\t\"realms\",\n\t\t\t\t\t\treq_body->realm,\n\t\t\t\t\t\t\"pkinit_win2k\",\n\t\t\t\t\t\tNULL);\n\n    if (win2k_compat) {\n\tctx->require_binding =\n\t    krb5_config_get_bool_default(context, NULL,\n\t\t\t\t\t TRUE,\n\t\t\t\t\t \"realms\",\n\t\t\t\t\t req_body->realm,\n\t\t\t\t\t \"pkinit_win2k_require_binding\",\n\t\t\t\t\t NULL);\n\tctx->type = PKINIT_WIN2K;\n    } else\n\tctx->type = PKINIT_27;\n\n    ctx->require_eku =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     TRUE,\n\t\t\t\t     \"realms\",\n\t\t\t\t     req_body->realm,\n\t\t\t\t     \"pkinit_require_eku\",\n\t\t\t\t     NULL);\n    if (ic_flags & KRB5_INIT_CREDS_NO_C_NO_EKU_CHECK)\n\tctx->require_eku = 0;\n    if (ctx->id->flags & PKINIT_BTMM)\n\tctx->require_eku = 0;\n\n    ctx->require_krbtgt_otherName =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     TRUE,\n\t\t\t\t     \"realms\",\n\t\t\t\t     req_body->realm,\n\t\t\t\t     \"pkinit_require_krbtgt_otherName\",\n\t\t\t\t     NULL);\n\n    ctx->require_hostname_match =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     FALSE,\n\t\t\t\t     \"realms\",\n\t\t\t\t     req_body->realm,\n\t\t\t\t     \"pkinit_require_hostname_match\",\n\t\t\t\t     NULL);\n\n    ctx->trustedCertifiers =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     TRUE,\n\t\t\t\t     \"realms\",\n\t\t\t\t     req_body->realm,\n\t\t\t\t     \"pkinit_trustedCertifiers\",\n\t\t\t\t     NULL);\n\n    return pk_mk_padata(context, ctx, req_body, nonce, md);\n}\n\nstatic krb5_error_code\npk_verify_sign(krb5_context context,\n\t       const void *data,\n\t       size_t length,\n\t       struct krb5_pk_identity *id,\n\t       heim_oid *contentType,\n\t       krb5_data *content,\n\t       struct krb5_pk_cert **signer)\n{\n    hx509_certs signer_certs;\n    int ret, flags = 0;\n\n    /* BTMM is broken in Leo and SnowLeo */\n    if (id->flags & PKINIT_BTMM) {\n\tflags |= HX509_CMS_VS_ALLOW_DATA_OID_MISMATCH;\n\tflags |= HX509_CMS_VS_NO_KU_CHECK;\n\tflags |= HX509_CMS_VS_NO_VALIDATE;\n    }\n\n    *signer = NULL;\n\n    ret = hx509_cms_verify_signed(context->hx509ctx,\n\t\t\t\t  id->verify_ctx,\n\t\t\t\t  flags,\n\t\t\t\t  data,\n\t\t\t\t  length,\n\t\t\t\t  NULL,\n\t\t\t\t  id->certpool,\n\t\t\t\t  contentType,\n\t\t\t\t  content,\n\t\t\t\t  &signer_certs);\n    if (ret) {\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"CMS verify signed failed\");\n\treturn ret;\n    }\n\n    *signer = calloc(1, sizeof(**signer));\n    if (*signer == NULL) {\n\tkrb5_clear_error_message(context);\n\tret = ENOMEM;\n\tgoto out;\n    }\n\n    ret = hx509_get_one_cert(context->hx509ctx, signer_certs, &(*signer)->cert);\n    if (ret) {\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"Failed to get on of the signer certs\");\n\tgoto out;\n    }\n\n out:\n    hx509_certs_free(&signer_certs);\n    if (ret) {\n\tif (*signer) {\n\t    hx509_cert_free((*signer)->cert);\n\t    free(*signer);\n\t    *signer = NULL;\n\t}\n    }\n\n    return ret;\n}\n\nstatic krb5_error_code\nget_reply_key_win(krb5_context context,\n\t\t  const krb5_data *content,\n\t\t  unsigned nonce,\n\t\t  krb5_keyblock **key)\n{\n    ReplyKeyPack_Win2k key_pack;\n    krb5_error_code ret;\n    size_t size;\n\n    ret = decode_ReplyKeyPack_Win2k(content->data,\n\t\t\t\t    content->length,\n\t\t\t\t    &key_pack,\n\t\t\t\t    &size);\n    if (ret) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"PKINIT decoding reply key failed\", \"\"));\n\tfree_ReplyKeyPack_Win2k(&key_pack);\n\treturn ret;\n    }\n\n    if ((unsigned)key_pack.nonce != nonce) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"PKINIT enckey nonce is wrong\", \"\"));\n\tfree_ReplyKeyPack_Win2k(&key_pack);\n\treturn KRB5KRB_AP_ERR_MODIFIED;\n    }\n\n    *key = malloc (sizeof (**key));\n    if (*key == NULL) {\n\tfree_ReplyKeyPack_Win2k(&key_pack);\n\treturn krb5_enomem(context);\n    }\n\n    ret = copy_EncryptionKey(&key_pack.replyKey, *key);\n    free_ReplyKeyPack_Win2k(&key_pack);\n    if (ret) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"PKINIT failed copying reply key\", \"\"));\n\tfree(*key);\n\t*key = NULL;\n    }\n\n    return ret;\n}\n\nstatic krb5_error_code\nget_reply_key(krb5_context context,\n\t      const krb5_data *content,\n\t      const krb5_data *req_buffer,\n\t      krb5_keyblock **key)\n{\n    ReplyKeyPack key_pack;\n    krb5_error_code ret;\n    size_t size;\n\n    ret = decode_ReplyKeyPack(content->data,\n\t\t\t      content->length,\n\t\t\t      &key_pack,\n\t\t\t      &size);\n    if (ret) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"PKINIT decoding reply key failed\", \"\"));\n\tfree_ReplyKeyPack(&key_pack);\n\treturn ret;\n    }\n\n    {\n\tkrb5_crypto crypto;\n\n\t/*\n\t * XXX Verify kp.replyKey is a allowed enctype in the\n\t * configuration file\n\t */\n\n\tret = krb5_crypto_init(context, &key_pack.replyKey, 0, &crypto);\n\tif (ret) {\n\t    free_ReplyKeyPack(&key_pack);\n\t    return ret;\n\t}\n\n\tret = krb5_verify_checksum(context, crypto, 6,\n\t\t\t\t   req_buffer->data, req_buffer->length,\n\t\t\t\t   &key_pack.asChecksum);\n\tkrb5_crypto_destroy(context, crypto);\n\tif (ret) {\n\t    free_ReplyKeyPack(&key_pack);\n\t    return ret;\n\t}\n    }\n\n    *key = malloc (sizeof (**key));\n    if (*key == NULL) {\n\tfree_ReplyKeyPack(&key_pack);\n\treturn krb5_enomem(context);\n    }\n\n    ret = copy_EncryptionKey(&key_pack.replyKey, *key);\n    free_ReplyKeyPack(&key_pack);\n    if (ret) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"PKINIT failed copying reply key\", \"\"));\n\tfree(*key);\n\t*key = NULL;\n    }\n\n    return ret;\n}\n\n\nstatic krb5_error_code\npk_verify_host(krb5_context context,\n\t       const char *realm,\n\t       const krb5_krbhst_info *hi,\n\t       struct krb5_pk_init_ctx_data *ctx,\n\t       struct krb5_pk_cert *host)\n{\n    krb5_error_code ret = 0;\n\n    if (ctx->require_eku) {\n\tret = hx509_cert_check_eku(context->hx509ctx, host->cert,\n\t\t\t\t   &asn1_oid_id_pkkdcekuoid, 0);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"No PK-INIT KDC EKU in kdc certificate\", \"\"));\n\t    return ret;\n\t}\n    }\n    if (ctx->require_krbtgt_otherName) {\n\thx509_octet_string_list list;\n\tsize_t i;\n\tint matched = 0;\n\n\tret = hx509_cert_find_subjectAltName_otherName(context->hx509ctx,\n\t\t\t\t\t\t       host->cert,\n\t\t\t\t\t\t       &asn1_oid_id_pkinit_san,\n\t\t\t\t\t\t       &list);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"Failed to find the PK-INIT \"\n\t\t\t\t      \"subjectAltName in the KDC \"\n\t\t\t\t      \"certificate\", \"\"));\n\n\t    return ret;\n\t}\n\n\t/*\n\t * subjectAltNames are multi-valued, and a single KDC may serve\n\t * multiple realms. The SAN validation here must accept\n\t * the KDC's cert if *any* of the SANs match the expected KDC.\n\t * It is OK for *some* of the SANs to not match, provided at least\n\t * one does.\n\t */\n\tfor (i = 0; matched == 0 && i < list.len; i++) {\n\t    KRB5PrincipalName r;\n\n\t    ret = decode_KRB5PrincipalName(list.val[i].data,\n\t\t\t\t\t   list.val[i].length,\n\t\t\t\t\t   &r,\n\t\t\t\t\t   NULL);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       N_(\"Failed to decode the PK-INIT \"\n\t\t\t\t\t  \"subjectAltName in the \"\n\t\t\t\t\t  \"KDC certificate\", \"\"));\n\n\t\tbreak;\n\t    }\n\n\t    if (r.principalName.name_string.len == 2 &&\n\t\tstrcmp(r.principalName.name_string.val[0], KRB5_TGS_NAME) == 0\n\t\t&& strcmp(r.principalName.name_string.val[1], realm) == 0\n\t\t&& strcmp(r.realm, realm) == 0)\n\t\tmatched = 1;\n\n\t    free_KRB5PrincipalName(&r);\n\t}\n\thx509_free_octet_string_list(&list);\n\tif (matched == 0) {\n\t    ret = KRB5_KDC_ERR_INVALID_CERTIFICATE;\n\t    /* XXX: Lost in translation... */\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"KDC have wrong realm name in \"\n\t\t\t\t      \"the certificate\", \"\"));\n\t}\n    }\n    if (ret)\n\treturn ret;\n\n    if (hi) {\n\tret = hx509_verify_hostname(context->hx509ctx, host->cert,\n\t\t\t\t    ctx->require_hostname_match,\n\t\t\t\t    HX509_HN_HOSTNAME,\n\t\t\t\t    hi->hostname,\n\t\t\t\t    hi->ai->ai_addr, hi->ai->ai_addrlen);\n\n\tif (ret)\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"Address mismatch in \"\n\t\t\t\t      \"the KDC certificate\", \"\"));\n    }\n    return ret;\n}\n\nstatic krb5_error_code\npk_rd_pa_reply_enckey(krb5_context context,\n\t\t      int type,\n\t\t      const heim_octet_string *indata,\n\t\t      const heim_oid *dataType,\n\t\t      const char *realm,\n\t\t      krb5_pk_init_ctx ctx,\n\t\t      krb5_enctype etype,\n\t\t      const krb5_krbhst_info *hi,\n\t       \t      unsigned nonce,\n\t\t      const krb5_data *req_buffer,\n\t       \t      PA_DATA *pa,\n\t       \t      krb5_keyblock **key)\n{\n    krb5_error_code ret;\n    struct krb5_pk_cert *host = NULL;\n    krb5_data content;\n    heim_oid contentType = { 0, NULL };\n    int flags = HX509_CMS_UE_DONT_REQUIRE_KU_ENCIPHERMENT;\n\n    if (der_heim_oid_cmp(&asn1_oid_id_pkcs7_envelopedData, dataType)) {\n\tkrb5_set_error_message(context, EINVAL,\n\t\t\t       N_(\"PKINIT: Invalid content type\", \"\"));\n\treturn EINVAL;\n    }\n\n    if (ctx->type == PKINIT_WIN2K)\n\tflags |= HX509_CMS_UE_ALLOW_WEAK;\n\n    ret = hx509_cms_unenvelope(context->hx509ctx,\n\t\t\t       ctx->id->certs,\n\t\t\t       flags,\n\t\t\t       indata->data,\n\t\t\t       indata->length,\n\t\t\t       NULL,\n\t\t\t       0,\n\t\t\t       &contentType,\n\t\t\t       &content);\n    if (ret) {\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"Failed to unenvelope CMS data in PK-INIT reply\");\n\treturn ret;\n    }\n    der_free_oid(&contentType);\n\n    /* win2k uses ContentInfo */\n    if (type == PKINIT_WIN2K) {\n\theim_oid type2;\n\theim_octet_string out;\n\n\tret = hx509_cms_unwrap_ContentInfo(&content, &type2, &out, NULL);\n\tif (ret) {\n\t    /* windows LH with interesting CMS packets */\n\t    size_t ph = 1 + der_length_len(content.length);\n\t    unsigned char *ptr = malloc(content.length + ph);\n\t    size_t l;\n\n\t    memcpy(ptr + ph, content.data, content.length);\n\n\t    ret = der_put_length_and_tag (ptr + ph - 1, ph, content.length,\n\t\t\t\t\t  ASN1_C_UNIV, CONS, UT_Sequence, &l);\n\t    if (ret) {\n                free(ptr);\n\t\treturn ret;\n            }\n\t    free(content.data);\n\t    content.data = ptr;\n\t    content.length += ph;\n\n\t    ret = hx509_cms_unwrap_ContentInfo(&content, &type2, &out, NULL);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\tif (der_heim_oid_cmp(&type2, &asn1_oid_id_pkcs7_signedData)) {\n\t    ret = EINVAL; /* XXX */\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"PKINIT: Invalid content type\", \"\"));\n\t    der_free_oid(&type2);\n\t    der_free_octet_string(&out);\n\t    goto out;\n\t}\n\tder_free_oid(&type2);\n\tkrb5_data_free(&content);\n\tret = krb5_data_copy(&content, out.data, out.length);\n\tder_free_octet_string(&out);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"malloc: out of memory\", \"\"));\n\t    goto out;\n\t}\n    }\n\n    ret = pk_verify_sign(context,\n\t\t\t content.data,\n\t\t\t content.length,\n\t\t\t ctx->id,\n\t\t\t &contentType,\n\t\t\t &content,\n\t\t\t &host);\n    if (ret)\n\tgoto out;\n\n    /* make sure that it is the kdc's certificate */\n    ret = pk_verify_host(context, realm, hi, ctx, host);\n    if (ret) {\n\tgoto out;\n    }\n\n#if 0\n    if (type == PKINIT_WIN2K) {\n\tif (der_heim_oid_cmp(&contentType, &asn1_oid_id_pkcs7_data) != 0) {\n\t    ret = KRB5KRB_AP_ERR_MSG_TYPE;\n\t    krb5_set_error_message(context, ret, \"PKINIT: reply key, wrong oid\");\n\t    goto out;\n\t}\n    } else {\n\tif (der_heim_oid_cmp(&contentType, &asn1_oid_id_pkrkeydata) != 0) {\n\t    ret = KRB5KRB_AP_ERR_MSG_TYPE;\n\t    krb5_set_error_message(context, ret, \"PKINIT: reply key, wrong oid\");\n\t    goto out;\n\t}\n    }\n#endif\n\n    switch(type) {\n    case PKINIT_WIN2K:\n\tret = get_reply_key(context, &content, req_buffer, key);\n\tif (ret != 0 && ctx->require_binding == 0)\n\t    ret = get_reply_key_win(context, &content, nonce, key);\n\tbreak;\n    case PKINIT_27:\n\tret = get_reply_key(context, &content, req_buffer, key);\n\tbreak;\n    }\n    if (ret)\n\tgoto out;\n\n    /* XXX compare given etype with key->etype */\n\n out:\n    if (host)\n\t_krb5_pk_cert_free(host);\n    der_free_oid(&contentType);\n    krb5_data_free(&content);\n\n    return ret;\n}\n\nstatic krb5_error_code\npk_rd_pa_reply_dh(krb5_context context,\n\t\t  const heim_octet_string *indata,\n\t\t  const heim_oid *dataType,\n\t\t  const char *realm,\n\t\t  krb5_pk_init_ctx ctx,\n\t\t  krb5_enctype etype,\n\t\t  const krb5_krbhst_info *hi,\n\t\t  const DHNonce *c_n,\n\t\t  const DHNonce *k_n,\n                  unsigned nonce,\n                  PA_DATA *pa,\n                  krb5_keyblock **key)\n{\n    const unsigned char *p;\n    unsigned char *dh_gen_key = NULL;\n    struct krb5_pk_cert *host = NULL;\n    BIGNUM *kdc_dh_pubkey = NULL;\n    KDCDHKeyInfo kdc_dh_info;\n    heim_oid contentType = { 0, NULL };\n    krb5_data content;\n    krb5_error_code ret;\n    int dh_gen_keylen = 0;\n    size_t size;\n\n    krb5_data_zero(&content);\n    memset(&kdc_dh_info, 0, sizeof(kdc_dh_info));\n\n    if (der_heim_oid_cmp(&asn1_oid_id_pkcs7_signedData, dataType)) {\n\tkrb5_set_error_message(context, EINVAL,\n\t\t\t       N_(\"PKINIT: Invalid content type\", \"\"));\n\treturn EINVAL;\n    }\n\n    ret = pk_verify_sign(context,\n\t\t\t indata->data,\n\t\t\t indata->length,\n\t\t\t ctx->id,\n\t\t\t &contentType,\n\t\t\t &content,\n\t\t\t &host);\n    if (ret)\n\tgoto out;\n\n    /* make sure that it is the kdc's certificate */\n    ret = pk_verify_host(context, realm, hi, ctx, host);\n    if (ret)\n\tgoto out;\n\n    if (der_heim_oid_cmp(&contentType, &asn1_oid_id_pkdhkeydata)) {\n\tret = KRB5KRB_AP_ERR_MSG_TYPE;\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"pkinit - dh reply contains wrong oid\", \"\"));\n\tgoto out;\n    }\n\n    ret = decode_KDCDHKeyInfo(content.data,\n\t\t\t      content.length,\n\t\t\t      &kdc_dh_info,\n\t\t\t      &size);\n\n    if (ret) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"pkinit - failed to decode \"\n\t\t\t\t  \"KDC DH Key Info\", \"\"));\n\tgoto out;\n    }\n\n    if (kdc_dh_info.nonce != nonce) {\n\tret = KRB5KRB_AP_ERR_MODIFIED;\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"PKINIT: DH nonce is wrong\", \"\"));\n\tgoto out;\n    }\n\n    if (kdc_dh_info.dhKeyExpiration) {\n\tif (k_n == NULL) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"pkinit; got key expiration \"\n\t\t\t\t      \"without server nonce\", \"\"));\n\t    goto out;\n\t}\n\tif (c_n == NULL) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"pkinit; got DH reuse but no \"\n\t\t\t\t      \"client nonce\", \"\"));\n\t    goto out;\n\t}\n    } else {\n\tif (k_n) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"pkinit: got server nonce \"\n\t\t\t\t      \"without key expiration\", \"\"));\n\t    goto out;\n\t}\n\tc_n = NULL;\n    }\n\n\n    p = kdc_dh_info.subjectPublicKey.data;\n    size = (kdc_dh_info.subjectPublicKey.length + 7) / 8;\n\n    if (ctx->keyex == USE_DH) {\n\tDHPublicKey k;\n\tret = decode_DHPublicKey(p, size, &k, NULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"pkinit: can't decode \"\n\t\t\t\t      \"without key expiration\", \"\"));\n\t    goto out;\n\t}\n\n\tkdc_dh_pubkey = integer_to_BN(context, \"DHPublicKey\", &k);\n\tfree_DHPublicKey(&k);\n\tif (kdc_dh_pubkey == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\n\n\tsize = DH_size(ctx->u.dh);\n\n\tdh_gen_key = malloc(size);\n\tif (dh_gen_key == NULL) {\n\t    ret = krb5_enomem(context);\n\t    goto out;\n\t}\n\n\tdh_gen_keylen = DH_compute_key(dh_gen_key, kdc_dh_pubkey, ctx->u.dh);\n\tif (dh_gen_keylen == -1) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    dh_gen_keylen = 0;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"PKINIT: Can't compute Diffie-Hellman key\", \"\"));\n\t    goto out;\n\t}\n\tif (dh_gen_keylen < (int)size) {\n\t    size -= dh_gen_keylen;\n\t    memmove(dh_gen_key + size, dh_gen_key, dh_gen_keylen);\n\t    memset(dh_gen_key, 0, size);\n\t}\n\n    } else {\n        ret = _krb5_pk_rd_pa_reply_ecdh_compute_key(context, ctx, p,\n                                                    size, &dh_gen_key,\n                                                    &dh_gen_keylen);\n        if (ret)\n          goto out;\n    }\n\n    if (dh_gen_keylen <= 0) {\n\tret = EINVAL;\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"PKINIT: resulting DH key <= 0\", \"\"));\n\tdh_gen_keylen = 0;\n\tgoto out;\n    }\n\n    *key = malloc (sizeof (**key));\n    if (*key == NULL) {\n\tret = krb5_enomem(context);\n\tgoto out;\n    }\n\n    ret = _krb5_pk_octetstring2key(context,\n\t\t\t\t   etype,\n\t\t\t\t   dh_gen_key, dh_gen_keylen,\n\t\t\t\t   c_n, k_n,\n\t\t\t\t   *key);\n    if (ret) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"PKINIT: can't create key from DH key\", \"\"));\n\tfree(*key);\n\t*key = NULL;\n\tgoto out;\n    }\n\n out:\n    if (kdc_dh_pubkey)\n\tBN_free(kdc_dh_pubkey);\n    if (dh_gen_key) {\n\tmemset(dh_gen_key, 0, dh_gen_keylen);\n\tfree(dh_gen_key);\n    }\n    if (host)\n\t_krb5_pk_cert_free(host);\n    if (content.data)\n\tkrb5_data_free(&content);\n    der_free_oid(&contentType);\n    free_KDCDHKeyInfo(&kdc_dh_info);\n\n    return ret;\n}\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\n_krb5_pk_rd_pa_reply(krb5_context context,\n\t\t     const char *realm,\n\t\t     void *c,\n\t\t     krb5_enctype etype,\n\t\t     const krb5_krbhst_info *hi,\n\t\t     unsigned nonce,\n\t\t     const krb5_data *req_buffer,\n\t\t     PA_DATA *pa,\n\t\t     krb5_keyblock **key)\n{\n    krb5_pk_init_ctx ctx = c;\n    krb5_error_code ret;\n    size_t size;\n\n    /* Check for IETF PK-INIT first */\n    if (ctx->type == PKINIT_27) {\n\tPA_PK_AS_REP rep;\n\theim_octet_string os, data;\n\theim_oid oid;\n\n\tif (pa->padata_type != KRB5_PADATA_PK_AS_REP) {\n\t    krb5_set_error_message(context, EINVAL,\n\t\t\t\t   N_(\"PKINIT: wrong padata recv\", \"\"));\n\t    return EINVAL;\n\t}\n\n\tret = decode_PA_PK_AS_REP(pa->padata_value.data,\n\t\t\t\t  pa->padata_value.length,\n\t\t\t\t  &rep,\n\t\t\t\t  &size);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"Failed to decode pkinit AS rep\", \"\"));\n\t    return ret;\n\t}\n\n\tswitch (rep.element) {\n\tcase choice_PA_PK_AS_REP_dhInfo:\n\t    _krb5_debug(context, 5, \"krb5_get_init_creds: using pkinit dh\");\n\t    os = rep.u.dhInfo.dhSignedData;\n\t    break;\n\tcase choice_PA_PK_AS_REP_encKeyPack:\n\t    _krb5_debug(context, 5, \"krb5_get_init_creds: using kinit enc reply key\");\n\t    os = rep.u.encKeyPack;\n\t    break;\n\tdefault: {\n\t    PA_PK_AS_REP_BTMM btmm;\n\t    free_PA_PK_AS_REP(&rep);\n\t    memset(&rep, 0, sizeof(rep));\n\n\t    _krb5_debug(context, 5, \"krb5_get_init_creds: using BTMM kinit enc reply key\");\n\n\t    ret = decode_PA_PK_AS_REP_BTMM(pa->padata_value.data,\n\t\t\t\t\t   pa->padata_value.length,\n\t\t\t\t\t   &btmm,\n\t\t\t\t\t   &size);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, EINVAL,\n\t\t\t\t       N_(\"PKINIT: -27 reply \"\n\t\t\t\t\t  \"invalid content type\", \"\"));\n\t\treturn EINVAL;\n\t    }\n\n\t    if (btmm.dhSignedData || btmm.encKeyPack == NULL) {\n\t\tfree_PA_PK_AS_REP_BTMM(&btmm);\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       N_(\"DH mode not supported for BTMM mode\", \"\"));\n\t\treturn ret;\n\t    }\n\n\t    /*\n\t     * Transform to IETF style PK-INIT reply so that free works below\n\t     */\n\n\t    rep.element = choice_PA_PK_AS_REP_encKeyPack;\n\t    rep.u.encKeyPack.data = btmm.encKeyPack->data;\n\t    rep.u.encKeyPack.length = btmm.encKeyPack->length;\n\t    btmm.encKeyPack->data = NULL;\n\t    btmm.encKeyPack->length = 0;\n\t    free_PA_PK_AS_REP_BTMM(&btmm);\n\t    os = rep.u.encKeyPack;\n\t}\n\t}\n\n\tret = hx509_cms_unwrap_ContentInfo(&os, &oid, &data, NULL);\n\tif (ret) {\n\t    free_PA_PK_AS_REP(&rep);\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"PKINIT: failed to unwrap CI\", \"\"));\n\t    return ret;\n\t}\n\n\tswitch (rep.element) {\n\tcase choice_PA_PK_AS_REP_dhInfo:\n\t    ret = pk_rd_pa_reply_dh(context, &data, &oid, realm, ctx, etype, hi,\n\t\t\t\t    ctx->clientDHNonce,\n\t\t\t\t    rep.u.dhInfo.serverDHNonce,\n\t\t\t\t    nonce, pa, key);\n\t    break;\n\tcase choice_PA_PK_AS_REP_encKeyPack:\n\t    ret = pk_rd_pa_reply_enckey(context, PKINIT_27, &data, &oid, realm,\n\t\t\t\t\tctx, etype, hi, nonce, req_buffer, pa, key);\n\t    break;\n\tdefault:\n\t    krb5_abortx(context, \"pk-init as-rep case not possible to happen\");\n\t}\n\tder_free_octet_string(&data);\n\tder_free_oid(&oid);\n\tfree_PA_PK_AS_REP(&rep);\n\n    } else if (ctx->type == PKINIT_WIN2K) {\n\tPA_PK_AS_REP_Win2k w2krep;\n\n\t/* Check for Windows encoding of the AS-REP pa data */\n\n#if 0 /* should this be ? */\n\tif (pa->padata_type != KRB5_PADATA_PK_AS_REP) {\n\t    krb5_set_error_message(context, EINVAL,\n\t\t\t\t   \"PKINIT: wrong padata recv\");\n\t    return EINVAL;\n\t}\n#endif\n\n\tmemset(&w2krep, 0, sizeof(w2krep));\n\n\tret = decode_PA_PK_AS_REP_Win2k(pa->padata_value.data,\n\t\t\t\t\tpa->padata_value.length,\n\t\t\t\t\t&w2krep,\n\t\t\t\t\t&size);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"PKINIT: Failed decoding windows \"\n\t\t\t\t      \"pkinit reply %d\", \"\"), (int)ret);\n\t    return ret;\n\t}\n\n\tkrb5_clear_error_message(context);\n\n\tswitch (w2krep.element) {\n\tcase choice_PA_PK_AS_REP_Win2k_encKeyPack: {\n\t    heim_octet_string data;\n\t    heim_oid oid;\n\n\t    ret = hx509_cms_unwrap_ContentInfo(&w2krep.u.encKeyPack,\n\t\t\t\t\t       &oid, &data, NULL);\n\t    free_PA_PK_AS_REP_Win2k(&w2krep);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       N_(\"PKINIT: failed to unwrap CI\", \"\"));\n\t\treturn ret;\n\t    }\n\n\t    ret = pk_rd_pa_reply_enckey(context, PKINIT_WIN2K, &data, &oid, realm,\n\t\t\t\t\tctx, etype, hi, nonce, req_buffer, pa, key);\n\t    der_free_octet_string(&data);\n\t    der_free_oid(&oid);\n\n\t    break;\n\t}\n\tdefault:\n\t    free_PA_PK_AS_REP_Win2k(&w2krep);\n\t    ret = EINVAL;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"PKINIT: win2k reply invalid \"\n\t\t\t\t      \"content type\", \"\"));\n\t    break;\n\t}\n\n    } else {\n\tret = EINVAL;\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"PKINIT: unknown reply type\", \"\"));\n    }\n\n    return ret;\n}\n\nstruct prompter {\n    krb5_context context;\n    krb5_prompter_fct prompter;\n    void *prompter_data;\n};\n\nstatic int\nhx_pass_prompter(void *data, const hx509_prompt *prompter)\n{\n    krb5_error_code ret;\n    krb5_prompt prompt;\n    krb5_data password_data;\n    struct prompter *p = data;\n\n    password_data.data   = prompter->reply.data;\n    password_data.length = prompter->reply.length;\n\n    prompt.prompt = prompter->prompt;\n    prompt.hidden = hx509_prompt_hidden(prompter->type);\n    prompt.reply  = &password_data;\n\n    switch (prompter->type) {\n    case HX509_PROMPT_TYPE_INFO:\n\tprompt.type   = KRB5_PROMPT_TYPE_INFO;\n\tbreak;\n    case HX509_PROMPT_TYPE_PASSWORD:\n    case HX509_PROMPT_TYPE_QUESTION:\n    default:\n\tprompt.type   = KRB5_PROMPT_TYPE_PASSWORD;\n\tbreak;\n    }\n\n    ret = (*p->prompter)(p->context, p->prompter_data, NULL, NULL, 1, &prompt);\n    if (ret) {\n\tmemset (prompter->reply.data, 0, prompter->reply.length);\n\treturn 1;\n    }\n    return 0;\n}\n\nstatic krb5_error_code\n_krb5_pk_set_user_id(krb5_context context,\n\t\t     krb5_principal principal,\n\t\t     krb5_pk_init_ctx ctx,\n\t\t     struct hx509_certs_data *certs)\n{\n    hx509_certs c = hx509_certs_ref(certs);\n    hx509_query *q = NULL;\n    int ret;\n\n    if (ctx->id->certs)\n\thx509_certs_free(&ctx->id->certs);\n    if (ctx->id->cert) {\n\thx509_cert_free(ctx->id->cert);\n\tctx->id->cert = NULL;\n    }\n\n    ctx->id->certs = c;\n    ctx->anonymous = 0;\n\n    ret = hx509_query_alloc(context->hx509ctx, &q);\n    if (ret) {\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"Allocate query to find signing certificate\");\n\treturn ret;\n    }\n\n    hx509_query_match_option(q, HX509_QUERY_OPTION_PRIVATE_KEY);\n    hx509_query_match_option(q, HX509_QUERY_OPTION_KU_DIGITALSIGNATURE);\n\n    if (principal && strncmp(\"LKDC:SHA1.\", krb5_principal_get_realm(context, principal), 9) == 0) {\n\tctx->id->flags |= PKINIT_BTMM;\n    }\n\n    ret = find_cert(context, ctx->id, q, &ctx->id->cert);\n    hx509_query_free(context->hx509ctx, q);\n\n    if (ret == 0 && _krb5_have_debug(context, 2)) {\n\thx509_name name;\n\tchar *str, *sn;\n\theim_integer i;\n\n\tret = hx509_cert_get_subject(ctx->id->cert, &name);\n\tif (ret)\n\t    goto out;\n\n\tret = hx509_name_to_string(name, &str);\n\thx509_name_free(&name);\n\tif (ret)\n\t    goto out;\n\n\tret = hx509_cert_get_serialnumber(ctx->id->cert, &i);\n\tif (ret) {\n\t    free(str);\n\t    goto out;\n\t}\n\n\tret = der_print_hex_heim_integer(&i, &sn);\n\tder_free_heim_integer(&i);\n\tif (ret) {\n\t    free(name);\n\t    goto out;\n\t}\n\n\t_krb5_debug(context, 2, \"using cert: subject: %s sn: %s\", str, sn);\n\tfree(str);\n\tfree(sn);\n    }\n out:\n\n    return ret;\n}\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\n_krb5_pk_load_id(krb5_context context,\n\t\t struct krb5_pk_identity **ret_id,\n\t\t const char *user_id,\n\t\t const char *anchor_id,\n\t\t char * const *chain_list,\n\t\t char * const *revoke_list,\n\t\t krb5_prompter_fct prompter,\n\t\t void *prompter_data,\n\t\t char *password)\n{\n    struct krb5_pk_identity *id = NULL;\n    struct prompter p;\n    int ret;\n\n    *ret_id = NULL;\n\n    if (anchor_id == NULL) {\n\tkrb5_set_error_message(context, HEIM_PKINIT_NO_VALID_CA,\n\t\t\t       N_(\"PKINIT: No anchor given\", \"\"));\n\treturn HEIM_PKINIT_NO_VALID_CA;\n    }\n\n    /* load cert */\n\n    id = calloc(1, sizeof(*id));\n    if (id == NULL)\n\treturn krb5_enomem(context);\n\n    if (user_id) {\n\thx509_lock lock;\n\n\tret = hx509_lock_init(context->hx509ctx, &lock);\n\tif (ret) {\n\t    pk_copy_error(context, context->hx509ctx, ret, \"Failed init lock\");\n\t    goto out;\n\t}\n\n\tif (password && password[0])\n\t    hx509_lock_add_password(lock, password);\n\n\tif (prompter) {\n\t    p.context = context;\n\t    p.prompter = prompter;\n\t    p.prompter_data = prompter_data;\n\n\t    ret = hx509_lock_set_prompter(lock, hx_pass_prompter, &p);\n\t    if (ret) {\n\t\thx509_lock_free(lock);\n\t\tgoto out;\n\t    }\n\t}\n\n\tret = hx509_certs_init(context->hx509ctx, user_id, 0, lock, &id->certs);\n        hx509_lock_free(lock);\n\tif (ret) {\n\t    pk_copy_error(context, context->hx509ctx, ret,\n\t\t\t  \"Failed to init cert certs\");\n\t    goto out;\n\t}\n    } else {\n\tid->certs = NULL;\n    }\n\n    ret = hx509_certs_init(context->hx509ctx, anchor_id, 0, NULL, &id->anchors);\n    if (ret) {\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"Failed to init anchors\");\n\tgoto out;\n    }\n\n    ret = hx509_certs_init(context->hx509ctx, \"MEMORY:pkinit-cert-chain\",\n\t\t\t   0, NULL, &id->certpool);\n    if (ret) {\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"Failed to init chain\");\n\tgoto out;\n    }\n\n    while (chain_list && *chain_list) {\n\tret = hx509_certs_append(context->hx509ctx, id->certpool,\n\t\t\t\t NULL, *chain_list);\n\tif (ret) {\n\t    pk_copy_error(context, context->hx509ctx, ret,\n\t\t\t  \"Failed to laod chain %s\",\n\t\t\t  *chain_list);\n\t    goto out;\n\t}\n\tchain_list++;\n    }\n\n    if (revoke_list) {\n\tret = hx509_revoke_init(context->hx509ctx, &id->revokectx);\n\tif (ret) {\n\t    pk_copy_error(context, context->hx509ctx, ret,\n\t\t\t  \"Failed init revoke list\");\n\t    goto out;\n\t}\n\n\twhile (*revoke_list) {\n\t    ret = hx509_revoke_add_crl(context->hx509ctx,\n\t\t\t\t       id->revokectx,\n\t\t\t\t       *revoke_list);\n\t    if (ret) {\n\t\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t\t      \"Failed load revoke list\");\n\t\tgoto out;\n\t    }\n\t    revoke_list++;\n\t}\n    } else\n\thx509_context_set_missing_revoke(context->hx509ctx, 1);\n\n    ret = hx509_verify_init_ctx(context->hx509ctx, &id->verify_ctx);\n    if (ret) {\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"Failed init verify context\");\n\tgoto out;\n    }\n\n    hx509_verify_attach_anchors(id->verify_ctx, id->anchors);\n    hx509_verify_attach_revoke(id->verify_ctx, id->revokectx);\n\n out:\n    if (ret) {\n\thx509_verify_destroy_ctx(id->verify_ctx);\n\thx509_certs_free(&id->certs);\n\thx509_certs_free(&id->anchors);\n\thx509_certs_free(&id->certpool);\n\thx509_revoke_free(&id->revokectx);\n\tfree(id);\n    } else\n\t*ret_id = id;\n\n    return ret;\n}\n\n/*\n *\n */\n\nstatic void\npk_copy_error(krb5_context context,\n\t      hx509_context hx509ctx,\n\t      int hxret,\n\t      const char *fmt,\n\t      ...)\n{\n    va_list va;\n    char *s, *f;\n    int ret;\n\n    va_start(va, fmt);\n    ret = vasprintf(&f, fmt, va);\n    va_end(va);\n    if (ret == -1 || f == NULL) {\n\tkrb5_clear_error_message(context);\n\treturn;\n    }\n\n    s = hx509_get_error_string(hx509ctx, hxret);\n    if (s == NULL) {\n\tkrb5_clear_error_message(context);\n\tfree(f);\n\treturn;\n    }\n    krb5_set_error_message(context, hxret, \"%s: %s\", f, s);\n    free(s);\n    free(f);\n}\n\nstatic int\nparse_integer(krb5_context context, char **p, const char *file, int lineno,\n\t      const char *name, heim_integer *integer)\n{\n    int ret;\n    char *p1;\n    p1 = strsep(p, \" \\t\");\n    if (p1 == NULL) {\n\tkrb5_set_error_message(context, EINVAL,\n\t\t\t       N_(\"moduli file %s missing %s on line %d\", \"\"),\n\t\t\t       file, name, lineno);\n\treturn EINVAL;\n    }\n    ret = der_parse_hex_heim_integer(p1, integer);\n    if (ret) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"moduli file %s failed parsing %s \"\n\t\t\t\t  \"on line %d\", \"\"),\n\t\t\t       file, name, lineno);\n\treturn ret;\n    }\n\n    return 0;\n}\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\n_krb5_parse_moduli_line(krb5_context context,\n\t\t\tconst char *file,\n\t\t\tint lineno,\n\t\t\tchar *p,\n\t\t\tstruct krb5_dh_moduli **m)\n{\n    struct krb5_dh_moduli *m1;\n    char *p1;\n    int ret;\n\n    *m = NULL;\n\n    m1 = calloc(1, sizeof(*m1));\n    if (m1 == NULL)\n\treturn krb5_enomem(context);\n\n    while (isspace((unsigned char)*p))\n\tp++;\n    if (*p  == '#') {\n        free(m1);\n\treturn 0;\n    }\n    ret = EINVAL;\n\n    p1 = strsep(&p, \" \\t\");\n    if (p1 == NULL) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"moduli file %s missing name on line %d\", \"\"),\n\t\t\t       file, lineno);\n\tgoto out;\n    }\n    m1->name = strdup(p1);\n    if (m1->name == NULL) {\n\tret = krb5_enomem(context);\n\tgoto out;\n    }\n\n    p1 = strsep(&p, \" \\t\");\n    if (p1 == NULL) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"moduli file %s missing bits on line %d\", \"\"),\n\t\t\t       file, lineno);\n\tgoto out;\n    }\n\n    m1->bits = atoi(p1);\n    if (m1->bits == 0) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"moduli file %s have un-parsable \"\n\t\t\t\t  \"bits on line %d\", \"\"), file, lineno);\n\tgoto out;\n    }\n\n    ret = parse_integer(context, &p, file, lineno, \"p\", &m1->p);\n    if (ret)\n\tgoto out;\n    ret = parse_integer(context, &p, file, lineno, \"g\", &m1->g);\n    if (ret)\n\tgoto out;\n    ret = parse_integer(context, &p, file, lineno, \"q\", &m1->q);\n    if (ret)\n\tgoto out;\n\n    *m = m1;\n\n    return 0;\n out:\n    free(m1->name);\n    der_free_heim_integer(&m1->p);\n    der_free_heim_integer(&m1->g);\n    der_free_heim_integer(&m1->q);\n    free(m1);\n    return ret;\n}\n\nKRB5_LIB_FUNCTION void KRB5_LIB_CALL\n_krb5_free_moduli(struct krb5_dh_moduli **moduli)\n{\n    int i;\n    for (i = 0; moduli[i] != NULL; i++) {\n\tfree(moduli[i]->name);\n\tder_free_heim_integer(&moduli[i]->p);\n\tder_free_heim_integer(&moduli[i]->g);\n\tder_free_heim_integer(&moduli[i]->q);\n\tfree(moduli[i]);\n    }\n    free(moduli);\n}\n\nstatic const char *default_moduli_RFC2412_MODP_group2 =\n    /* name */\n    \"RFC2412-MODP-group2 \"\n    /* bits */\n    \"1024 \"\n    /* p */\n    \"FFFFFFFF\" \"FFFFFFFF\" \"C90FDAA2\" \"2168C234\" \"C4C6628B\" \"80DC1CD1\"\n    \"29024E08\" \"8A67CC74\" \"020BBEA6\" \"3B139B22\" \"514A0879\" \"8E3404DD\"\n    \"EF9519B3\" \"CD3A431B\" \"302B0A6D\" \"F25F1437\" \"4FE1356D\" \"6D51C245\"\n    \"E485B576\" \"625E7EC6\" \"F44C42E9\" \"A637ED6B\" \"0BFF5CB6\" \"F406B7ED\"\n    \"EE386BFB\" \"5A899FA5\" \"AE9F2411\" \"7C4B1FE6\" \"49286651\" \"ECE65381\"\n    \"FFFFFFFF\" \"FFFFFFFF \"\n    /* g */\n    \"02 \"\n    /* q */\n    \"7FFFFFFF\" \"FFFFFFFF\" \"E487ED51\" \"10B4611A\" \"62633145\" \"C06E0E68\"\n    \"94812704\" \"4533E63A\" \"0105DF53\" \"1D89CD91\" \"28A5043C\" \"C71A026E\"\n    \"F7CA8CD9\" \"E69D218D\" \"98158536\" \"F92F8A1B\" \"A7F09AB6\" \"B6A8E122\"\n    \"F242DABB\" \"312F3F63\" \"7A262174\" \"D31BF6B5\" \"85FFAE5B\" \"7A035BF6\"\n    \"F71C35FD\" \"AD44CFD2\" \"D74F9208\" \"BE258FF3\" \"24943328\" \"F67329C0\"\n    \"FFFFFFFF\" \"FFFFFFFF\";\n\nstatic const char *default_moduli_rfc3526_MODP_group14 =\n    /* name */\n    \"rfc3526-MODP-group14 \"\n    /* bits */\n    \"1760 \"\n    /* p */\n    \"FFFFFFFF\" \"FFFFFFFF\" \"C90FDAA2\" \"2168C234\" \"C4C6628B\" \"80DC1CD1\"\n    \"29024E08\" \"8A67CC74\" \"020BBEA6\" \"3B139B22\" \"514A0879\" \"8E3404DD\"\n    \"EF9519B3\" \"CD3A431B\" \"302B0A6D\" \"F25F1437\" \"4FE1356D\" \"6D51C245\"\n    \"E485B576\" \"625E7EC6\" \"F44C42E9\" \"A637ED6B\" \"0BFF5CB6\" \"F406B7ED\"\n    \"EE386BFB\" \"5A899FA5\" \"AE9F2411\" \"7C4B1FE6\" \"49286651\" \"ECE45B3D\"\n    \"C2007CB8\" \"A163BF05\" \"98DA4836\" \"1C55D39A\" \"69163FA8\" \"FD24CF5F\"\n    \"83655D23\" \"DCA3AD96\" \"1C62F356\" \"208552BB\" \"9ED52907\" \"7096966D\"\n    \"670C354E\" \"4ABC9804\" \"F1746C08\" \"CA18217C\" \"32905E46\" \"2E36CE3B\"\n    \"E39E772C\" \"180E8603\" \"9B2783A2\" \"EC07A28F\" \"B5C55DF0\" \"6F4C52C9\"\n    \"DE2BCBF6\" \"95581718\" \"3995497C\" \"EA956AE5\" \"15D22618\" \"98FA0510\"\n    \"15728E5A\" \"8AACAA68\" \"FFFFFFFF\" \"FFFFFFFF \"\n    /* g */\n    \"02 \"\n    /* q */\n    \"7FFFFFFF\" \"FFFFFFFF\" \"E487ED51\" \"10B4611A\" \"62633145\" \"C06E0E68\"\n    \"94812704\" \"4533E63A\" \"0105DF53\" \"1D89CD91\" \"28A5043C\" \"C71A026E\"\n    \"F7CA8CD9\" \"E69D218D\" \"98158536\" \"F92F8A1B\" \"A7F09AB6\" \"B6A8E122\"\n    \"F242DABB\" \"312F3F63\" \"7A262174\" \"D31BF6B5\" \"85FFAE5B\" \"7A035BF6\"\n    \"F71C35FD\" \"AD44CFD2\" \"D74F9208\" \"BE258FF3\" \"24943328\" \"F6722D9E\"\n    \"E1003E5C\" \"50B1DF82\" \"CC6D241B\" \"0E2AE9CD\" \"348B1FD4\" \"7E9267AF\"\n    \"C1B2AE91\" \"EE51D6CB\" \"0E3179AB\" \"1042A95D\" \"CF6A9483\" \"B84B4B36\"\n    \"B3861AA7\" \"255E4C02\" \"78BA3604\" \"650C10BE\" \"19482F23\" \"171B671D\"\n    \"F1CF3B96\" \"0C074301\" \"CD93C1D1\" \"7603D147\" \"DAE2AEF8\" \"37A62964\"\n    \"EF15E5FB\" \"4AAC0B8C\" \"1CCAA4BE\" \"754AB572\" \"8AE9130C\" \"4C7D0288\"\n    \"0AB9472D\" \"45565534\" \"7FFFFFFF\" \"FFFFFFFF\";\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\n_krb5_parse_moduli(krb5_context context, const char *file,\n\t\t   struct krb5_dh_moduli ***moduli)\n{\n    /* name bits P G Q */\n    krb5_error_code ret;\n    struct krb5_dh_moduli **m = NULL, **m2;\n    char buf[4096];\n    FILE *f;\n    int lineno = 0, n = 0;\n\n    *moduli = NULL;\n\n    m = calloc(1, sizeof(m[0]) * 3);\n    if (m == NULL)\n\treturn krb5_enomem(context);\n\n    strlcpy(buf, default_moduli_rfc3526_MODP_group14, sizeof(buf));\n    ret = _krb5_parse_moduli_line(context, \"builtin\", 1, buf,  &m[0]);\n    if (ret) {\n\t_krb5_free_moduli(m);\n\treturn ret;\n    }\n    n++;\n\n    strlcpy(buf, default_moduli_RFC2412_MODP_group2, sizeof(buf));\n    ret = _krb5_parse_moduli_line(context, \"builtin\", 1, buf,  &m[1]);\n    if (ret) {\n\t_krb5_free_moduli(m);\n\treturn ret;\n    }\n    n++;\n\n\n    if (file == NULL)\n\tfile = MODULI_FILE;\n\n#ifdef KRB5_USE_PATH_TOKENS\n    {\n        char * exp_file;\n\n\tif (_krb5_expand_path_tokens(context, file, 1, &exp_file) == 0) {\n            f = fopen(exp_file, \"r\");\n            krb5_xfree(exp_file);\n        } else {\n            f = NULL;\n        }\n    }\n#else\n    f = fopen(file, \"r\");\n#endif\n\n    if (f == NULL) {\n\t*moduli = m;\n\treturn 0;\n    }\n    rk_cloexec_file(f);\n\n    while(fgets(buf, sizeof(buf), f) != NULL) {\n\tstruct krb5_dh_moduli *element;\n\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tlineno++;\n\n\tm2 = realloc(m, (n + 2) * sizeof(m[0]));\n\tif (m2 == NULL) {\n\t    _krb5_free_moduli(m);\n\t    return krb5_enomem(context);\n\t}\n\tm = m2;\n\n\tm[n] = NULL;\n\n\tret = _krb5_parse_moduli_line(context, file, lineno, buf,  &element);\n\tif (ret) {\n\t    _krb5_free_moduli(m);\n\t    return ret;\n\t}\n\tif (element == NULL)\n\t    continue;\n\n\tm[n] = element;\n\tm[n + 1] = NULL;\n\tn++;\n    }\n    *moduli = m;\n    return 0;\n}\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\n_krb5_dh_group_ok(krb5_context context, unsigned long bits,\n\t\t  heim_integer *p, heim_integer *g, heim_integer *q,\n\t\t  struct krb5_dh_moduli **moduli,\n\t\t  char **name)\n{\n    int i;\n\n    if (name)\n\t*name = NULL;\n\n    for (i = 0; moduli[i] != NULL; i++) {\n\tif (der_heim_integer_cmp(&moduli[i]->g, g) == 0 &&\n\t    der_heim_integer_cmp(&moduli[i]->p, p) == 0 &&\n\t    (q == NULL || der_heim_integer_cmp(&moduli[i]->q, q) == 0))\n\t    {\n\t\tif (bits && bits > moduli[i]->bits) {\n\t\t    krb5_set_error_message(context,\n\t\t\t\t\t   KRB5_KDC_ERR_DH_KEY_PARAMETERS_NOT_ACCEPTED,\n\t\t\t\t\t   N_(\"PKINIT: DH group parameter %s \"\n\t\t\t\t\t      \"no accepted, not enough bits \"\n\t\t\t\t\t      \"generated\", \"\"),\n\t\t\t\t\t   moduli[i]->name);\n\t\t    return KRB5_KDC_ERR_DH_KEY_PARAMETERS_NOT_ACCEPTED;\n\t\t}\n\t\tif (name)\n\t\t    *name = strdup(moduli[i]->name);\n\t\treturn 0;\n\t    }\n    }\n    krb5_set_error_message(context,\n\t\t\t   KRB5_KDC_ERR_DH_KEY_PARAMETERS_NOT_ACCEPTED,\n\t\t\t   N_(\"PKINIT: DH group parameter no ok\", \"\"));\n    return KRB5_KDC_ERR_DH_KEY_PARAMETERS_NOT_ACCEPTED;\n}\n#endif /* PKINIT */\n\nKRB5_LIB_FUNCTION void KRB5_LIB_CALL\n_krb5_get_init_creds_opt_free_pkinit(krb5_get_init_creds_opt *opt)\n{\n#ifdef PKINIT\n    krb5_pk_init_ctx ctx;\n\n    if (opt->opt_private == NULL || opt->opt_private->pk_init_ctx == NULL)\n\treturn;\n    ctx = opt->opt_private->pk_init_ctx;\n    switch (ctx->keyex) {\n    case USE_DH:\n\tif (ctx->u.dh)\n\t    DH_free(ctx->u.dh);\n\tbreak;\n    case USE_RSA:\n\tbreak;\n    case USE_ECDH:\n\tif (ctx->u.eckey)\n            _krb5_pk_eckey_free(ctx->u.eckey);\n\tbreak;\n    }\n    if (ctx->id) {\n\thx509_verify_destroy_ctx(ctx->id->verify_ctx);\n\thx509_certs_free(&ctx->id->certs);\n\thx509_cert_free(ctx->id->cert);\n\thx509_certs_free(&ctx->id->anchors);\n\thx509_certs_free(&ctx->id->certpool);\n\n\tif (ctx->clientDHNonce) {\n\t    krb5_free_data(NULL, ctx->clientDHNonce);\n\t    ctx->clientDHNonce = NULL;\n\t}\n\tif (ctx->m)\n\t    _krb5_free_moduli(ctx->m);\n\tfree(ctx->id);\n\tctx->id = NULL;\n    }\n    free(opt->opt_private->pk_init_ctx);\n    opt->opt_private->pk_init_ctx = NULL;\n#endif\n}\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_get_init_creds_opt_set_pkinit(krb5_context context,\n\t\t\t\t   krb5_get_init_creds_opt *opt,\n\t\t\t\t   krb5_principal principal,\n\t\t\t\t   const char *user_id,\n\t\t\t\t   const char *x509_anchors,\n\t\t\t\t   char * const * pool,\n\t\t\t\t   char * const * pki_revoke,\n\t\t\t\t   int flags,\n\t\t\t\t   krb5_prompter_fct prompter,\n\t\t\t\t   void *prompter_data,\n\t\t\t\t   char *password)\n{\n#ifdef PKINIT\n    krb5_error_code ret;\n    char *anchors = NULL;\n\n    if (opt->opt_private == NULL) {\n\tkrb5_set_error_message(context, EINVAL,\n\t\t\t       N_(\"PKINIT: on non extendable opt\", \"\"));\n\treturn EINVAL;\n    }\n\n    opt->opt_private->pk_init_ctx =\n\tcalloc(1, sizeof(*opt->opt_private->pk_init_ctx));\n    if (opt->opt_private->pk_init_ctx == NULL)\n\treturn krb5_enomem(context);\n    opt->opt_private->pk_init_ctx->require_binding = 0;\n    opt->opt_private->pk_init_ctx->require_eku = 1;\n    opt->opt_private->pk_init_ctx->require_krbtgt_otherName = 1;\n    opt->opt_private->pk_init_ctx->peer = NULL;\n\n    /* XXX implement krb5_appdefault_strings  */\n    if (pool == NULL)\n\tpool = krb5_config_get_strings(context, NULL,\n\t\t\t\t       \"appdefaults\",\n\t\t\t\t       \"pkinit_pool\",\n\t\t\t\t       NULL);\n\n    if (pki_revoke == NULL)\n\tpki_revoke = krb5_config_get_strings(context, NULL,\n\t\t\t\t\t     \"appdefaults\",\n\t\t\t\t\t     \"pkinit_revoke\",\n\t\t\t\t\t     NULL);\n\n    if (x509_anchors == NULL) {\n\tkrb5_appdefault_string(context, \"kinit\",\n\t\t\t       krb5_principal_get_realm(context, principal),\n\t\t\t       \"pkinit_anchors\", NULL, &anchors);\n\tx509_anchors = anchors;\n    }\n\n    if (flags & KRB5_GIC_OPT_PKINIT_ANONYMOUS)\n\topt->opt_private->pk_init_ctx->anonymous = 1;\n\n    ret = _krb5_pk_load_id(context,\n\t\t\t   &opt->opt_private->pk_init_ctx->id,\n\t\t\t   user_id,\n\t\t\t   x509_anchors,\n\t\t\t   pool,\n\t\t\t   pki_revoke,\n\t\t\t   prompter,\n\t\t\t   prompter_data,\n\t\t\t   password);\n    if (ret) {\n\tfree(opt->opt_private->pk_init_ctx);\n\topt->opt_private->pk_init_ctx = NULL;\n\treturn ret;\n    }\n\n    if (opt->opt_private->pk_init_ctx->id->certs) {\n\t_krb5_pk_set_user_id(context,\n\t\t\t     principal,\n\t\t\t     opt->opt_private->pk_init_ctx,\n\t\t\t     opt->opt_private->pk_init_ctx->id->certs);\n    } else\n\topt->opt_private->pk_init_ctx->id->cert = NULL;\n\n    if ((flags & KRB5_GIC_OPT_PKINIT_USE_ENCKEY) == 0) {\n\thx509_context hx509ctx = context->hx509ctx;\n\thx509_cert cert = opt->opt_private->pk_init_ctx->id->cert;\n\n\topt->opt_private->pk_init_ctx->keyex = USE_DH;\n\n\t/*\n\t * If its a ECDSA certs, lets select ECDSA as the keyex algorithm.\n\t */\n\tif (cert) {\n\t    AlgorithmIdentifier alg;\n\n\t    ret = hx509_cert_get_SPKI_AlgorithmIdentifier(hx509ctx, cert, &alg);\n\t    if (ret == 0) {\n\t\tif (der_heim_oid_cmp(&alg.algorithm, &asn1_oid_id_ecPublicKey) == 0)\n\t\t    opt->opt_private->pk_init_ctx->keyex = USE_ECDH;\n\t\tfree_AlgorithmIdentifier(&alg);\n\t    }\n\t}\n\n    } else {\n\topt->opt_private->pk_init_ctx->keyex = USE_RSA;\n\n\tif (opt->opt_private->pk_init_ctx->id->certs == NULL) {\n\t    krb5_set_error_message(context, EINVAL,\n\t\t\t\t   N_(\"No anonymous pkinit support in RSA mode\", \"\"));\n\t    return EINVAL;\n\t}\n    }\n\n    return 0;\n#else\n    krb5_set_error_message(context, EINVAL,\n\t\t\t   N_(\"no support for PKINIT compiled in\", \"\"));\n    return EINVAL;\n#endif\n}\n\nkrb5_error_code KRB5_LIB_FUNCTION\nkrb5_get_init_creds_opt_set_pkinit_user_certs(krb5_context context,\n\t\t\t\t\t      krb5_get_init_creds_opt *opt,\n\t\t\t\t\t      struct hx509_certs_data *certs)\n{\n#ifdef PKINIT\n    if (opt->opt_private == NULL) {\n\tkrb5_set_error_message(context, EINVAL,\n\t\t\t       N_(\"PKINIT: on non extendable opt\", \"\"));\n\treturn EINVAL;\n    }\n    if (opt->opt_private->pk_init_ctx == NULL) {\n\tkrb5_set_error_message(context, EINVAL,\n\t\t\t       N_(\"PKINIT: on pkinit context\", \"\"));\n\treturn EINVAL;\n    }\n\n    _krb5_pk_set_user_id(context, NULL, opt->opt_private->pk_init_ctx, certs);\n\n    return 0;\n#else\n    krb5_set_error_message(context, EINVAL,\n\t\t\t   N_(\"no support for PKINIT compiled in\", \"\"));\n    return EINVAL;\n#endif\n}\n\n#ifdef PKINIT\n\nstatic int\nget_ms_san(hx509_context context, hx509_cert cert, char **upn)\n{\n    hx509_octet_string_list list;\n    int ret;\n\n    *upn = NULL;\n\n    ret = hx509_cert_find_subjectAltName_otherName(context,\n\t\t\t\t\t\t   cert,\n\t\t\t\t\t\t   &asn1_oid_id_pkinit_ms_san,\n\t\t\t\t\t\t   &list);\n    if (ret)\n\treturn 0;\n\n    if (list.len > 0 && list.val[0].length > 0)\n\tret = decode_MS_UPN_SAN(list.val[0].data, list.val[0].length,\n\t\t\t\tupn, NULL);\n    else\n\tret = 1;\n    hx509_free_octet_string_list(&list);\n\n    return ret;\n}\n\nstatic int\nfind_ms_san(hx509_context context, hx509_cert cert, void *ctx)\n{\n    char *upn;\n    int ret;\n\n    ret = get_ms_san(context, cert, &upn);\n    if (ret == 0)\n\tfree(upn);\n    return ret;\n}\n\n\n\n#endif\n\n/*\n * Private since it need to be redesigned using krb5_get_init_creds()\n */\n\nKRB5_LIB_FUNCTION krb5_error_code  KRB5_LIB_CALL\nkrb5_pk_enterprise_cert(krb5_context context,\n\t\t\tconst char *user_id,\n\t\t\tkrb5_const_realm realm,\n\t\t\tkrb5_principal *principal,\n\t\t\tstruct hx509_certs_data **res)\n{\n#ifdef PKINIT\n    krb5_error_code ret;\n    hx509_certs certs, result;\n    hx509_cert cert = NULL;\n    hx509_query *q;\n    char *name;\n\n    *principal = NULL;\n    if (res)\n\t*res = NULL;\n\n    if (user_id == NULL) {\n\tkrb5_set_error_message(context, ENOENT, \"no user id\");\n\treturn ENOENT;\n    }\n\n    ret = hx509_certs_init(context->hx509ctx, user_id, 0, NULL, &certs);\n    if (ret) {\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"Failed to init cert certs\");\n\tgoto out;\n    }\n\n    ret = hx509_query_alloc(context->hx509ctx, &q);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"out of memory\");\n\thx509_certs_free(&certs);\n\tgoto out;\n    }\n\n    hx509_query_match_option(q, HX509_QUERY_OPTION_PRIVATE_KEY);\n    hx509_query_match_option(q, HX509_QUERY_OPTION_KU_DIGITALSIGNATURE);\n    hx509_query_match_eku(q, &asn1_oid_id_pkinit_ms_eku);\n    hx509_query_match_cmp_func(q, find_ms_san, NULL);\n\n    ret = hx509_certs_filter(context->hx509ctx, certs, q, &result);\n    hx509_query_free(context->hx509ctx, q);\n    hx509_certs_free(&certs);\n    if (ret) {\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"Failed to find PKINIT certificate\");\n\treturn ret;\n    }\n\n    ret = hx509_get_one_cert(context->hx509ctx, result, &cert);\n    hx509_certs_free(&result);\n    if (ret) {\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"Failed to get one cert\");\n\tgoto out;\n    }\n\n    ret = get_ms_san(context->hx509ctx, cert, &name);\n    if (ret) {\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"Failed to get MS SAN\");\n\tgoto out;\n    }\n\n    ret = krb5_make_principal(context, principal, realm, name, NULL);\n    free(name);\n    if (ret)\n\tgoto out;\n\n    krb5_principal_set_type(context, *principal, KRB5_NT_ENTERPRISE_PRINCIPAL);\n\n    if (res) {\n\tret = hx509_certs_init(context->hx509ctx, \"MEMORY:\", 0, NULL, res);\n\tif (ret)\n\t    goto out;\n\n\tret = hx509_certs_add(context->hx509ctx, *res, cert);\n\tif (ret) {\n\t    hx509_certs_free(res);\n\t    goto out;\n\t}\n    }\n\n out:\n    hx509_cert_free(cert);\n\n    return ret;\n#else\n    krb5_set_error_message(context, EINVAL,\n\t\t\t   N_(\"no support for PKINIT compiled in\", \"\"));\n    return EINVAL;\n#endif\n}\n"], "fixing_code": ["/*\n * Copyright (c) 1997 - 2008 Kungliga Tekniska H\u00f6gskolan\n * (Royal Institute of Technology, Stockholm, Sweden).\n * All rights reserved.\n *\n * Portions Copyright (c) 2009 Apple Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the Institute nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"krb5_locl.h\"\n#ifndef WIN32\n#include <heim-ipc.h>\n#endif /* WIN32 */\n\ntypedef struct krb5_get_init_creds_ctx {\n    KDCOptions flags;\n    krb5_creds cred;\n    krb5_addresses *addrs;\n    krb5_enctype *etypes;\n    krb5_preauthtype *pre_auth_types;\n    char *in_tkt_service;\n    unsigned nonce;\n    unsigned pk_nonce;\n\n    krb5_data req_buffer;\n    AS_REQ as_req;\n    int pa_counter;\n\n    /* password and keytab_data is freed on completion */\n    char *password;\n    krb5_keytab_key_proc_args *keytab_data;\n\n    krb5_pointer *keyseed;\n    krb5_s2k_proc keyproc;\n\n    krb5_get_init_creds_tristate req_pac;\n\n    krb5_pk_init_ctx pk_init_ctx;\n    int ic_flags;\n\n    struct {\n\tunsigned change_password:1;\n    } runflags;\n\n    int used_pa_types;\n#define  USED_PKINIT\t1\n#define  USED_PKINIT_W2K\t2\n#define  USED_ENC_TS_GUESS\t4\n#define  USED_ENC_TS_INFO\t8\n\n    METHOD_DATA md;\n    KRB_ERROR error;\n    AS_REP as_rep;\n    EncKDCRepPart enc_part;\n\n    krb5_prompter_fct prompter;\n    void *prompter_data;\n\n    struct pa_info_data *ppaid;\n    struct fast_state {\n\tenum PA_FX_FAST_REQUEST_enum type;\n\tunsigned int flags;\n#define KRB5_FAST_REPLY_KEY_USE_TO_ENCRYPT_THE_REPLY 1\n#define KRB5_FAST_REPLY_KEY_USE_IN_TRANSACTION 2\n#define KRB5_FAST_KDC_REPLY_KEY_REPLACED 4\n#define KRB5_FAST_REPLY_REPLY_VERIFED 8\n#define KRB5_FAST_STRONG 16\n#define KRB5_FAST_EXPECTED 32 /* in exchange with KDC, fast was discovered */\n#define KRB5_FAST_REQUIRED 64 /* fast required by action of caller */\n#define KRB5_FAST_DISABLED 128\n#define KRB5_FAST_AP_ARMOR_SERVICE 256\n\tkrb5_keyblock *reply_key;\n\tkrb5_ccache armor_ccache;\n\tkrb5_principal armor_service;\n\tkrb5_crypto armor_crypto;\n\tkrb5_keyblock armor_key;\n\tkrb5_keyblock *strengthen_key;\n    } fast_state;\n} krb5_get_init_creds_ctx;\n\n\nstruct pa_info_data {\n    krb5_enctype etype;\n    krb5_salt salt;\n    krb5_data *s2kparams;\n};\n\nstatic void\nfree_paid(krb5_context context, struct pa_info_data *ppaid)\n{\n    krb5_free_salt(context, ppaid->salt);\n    if (ppaid->s2kparams)\n\tkrb5_free_data(context, ppaid->s2kparams);\n}\n\nstatic krb5_error_code KRB5_CALLCONV\ndefault_s2k_func(krb5_context context, krb5_enctype type,\n\t\t krb5_const_pointer keyseed,\n\t\t krb5_salt salt, krb5_data *s2kparms,\n\t\t krb5_keyblock **key)\n{\n    krb5_error_code ret;\n    krb5_data password;\n    krb5_data opaque;\n\n    _krb5_debug(context, 5, \"krb5_get_init_creds: using default_s2k_func\");\n\n    password.data = rk_UNCONST(keyseed);\n    password.length = strlen(keyseed);\n    if (s2kparms)\n\topaque = *s2kparms;\n    else\n\tkrb5_data_zero(&opaque);\n\n    *key = malloc(sizeof(**key));\n    if (*key == NULL)\n\treturn ENOMEM;\n    ret = krb5_string_to_key_data_salt_opaque(context, type, password,\n\t\t\t\t\t      salt, opaque, *key);\n    if (ret) {\n\tfree(*key);\n\t*key = NULL;\n    }\n    return ret;\n}\n\nstatic void\nfree_init_creds_ctx(krb5_context context, krb5_init_creds_context ctx)\n{\n    if (ctx->etypes)\n\tfree(ctx->etypes);\n    if (ctx->pre_auth_types)\n\tfree (ctx->pre_auth_types);\n    if (ctx->in_tkt_service)\n\tfree(ctx->in_tkt_service);\n    if (ctx->keytab_data)\n\tfree(ctx->keytab_data);\n    if (ctx->password) {\n\tmemset(ctx->password, 0, strlen(ctx->password));\n\tfree(ctx->password);\n    }\n    /*\n     * FAST state (we don't close the armor_ccache because we might have\n     * to destroy it, and how would we know? also, the caller should\n     * take care of cleaning up the armor_ccache).\n     */\n    if (ctx->fast_state.armor_service)\n\tkrb5_free_principal(context, ctx->fast_state.armor_service);\n    if (ctx->fast_state.armor_crypto)\n\tkrb5_crypto_destroy(context, ctx->fast_state.armor_crypto);\n    if (ctx->fast_state.strengthen_key)\n\tkrb5_free_keyblock(context, ctx->fast_state.strengthen_key);\n    krb5_free_keyblock_contents(context, &ctx->fast_state.armor_key);\n\n    krb5_data_free(&ctx->req_buffer);\n    krb5_free_cred_contents(context, &ctx->cred);\n    free_METHOD_DATA(&ctx->md);\n    free_AS_REP(&ctx->as_rep);\n    free_EncKDCRepPart(&ctx->enc_part);\n    free_KRB_ERROR(&ctx->error);\n    free_AS_REQ(&ctx->as_req);\n    if (ctx->ppaid) {\n\tfree_paid(context, ctx->ppaid);\n\tfree(ctx->ppaid);\n    }\n    memset(ctx, 0, sizeof(*ctx));\n}\n\nstatic int\nget_config_time (krb5_context context,\n\t\t const char *realm,\n\t\t const char *name,\n\t\t int def)\n{\n    int ret;\n\n    ret = krb5_config_get_time (context, NULL,\n\t\t\t\t\"realms\",\n\t\t\t\trealm,\n\t\t\t\tname,\n\t\t\t\tNULL);\n    if (ret >= 0)\n\treturn ret;\n    ret = krb5_config_get_time (context, NULL,\n\t\t\t\t\"libdefaults\",\n\t\t\t\tname,\n\t\t\t\tNULL);\n    if (ret >= 0)\n\treturn ret;\n    return def;\n}\n\nstatic krb5_error_code\ninit_cred (krb5_context context,\n\t   krb5_creds *cred,\n\t   krb5_principal client,\n\t   krb5_deltat start_time,\n\t   krb5_get_init_creds_opt *options)\n{\n    krb5_error_code ret;\n    int tmp;\n    krb5_timestamp now;\n\n    krb5_timeofday (context, &now);\n\n    memset (cred, 0, sizeof(*cred));\n\n    if (client)\n\tret = krb5_copy_principal(context, client, &cred->client);\n    else\n\tret = krb5_get_default_principal(context, &cred->client);\n    if (ret)\n        goto out;\n\n    if (start_time)\n\tcred->times.starttime  = now + start_time;\n\n    if (options->flags & KRB5_GET_INIT_CREDS_OPT_TKT_LIFE)\n\ttmp = options->tkt_life;\n    else\n\ttmp = KRB5_TKT_LIFETIME_DEFAULT;\n    cred->times.endtime = now + tmp;\n\n    if ((options->flags & KRB5_GET_INIT_CREDS_OPT_RENEW_LIFE)) {\n\tif (options->renew_life > 0)\n\t    tmp = options->renew_life;\n\telse\n\t    tmp = KRB5_TKT_RENEW_LIFETIME_DEFAULT;\n\tcred->times.renew_till = now + tmp;\n    }\n\n    return 0;\n\nout:\n    krb5_free_cred_contents (context, cred);\n    return ret;\n}\n\n/*\n * Print a message (str) to the user about the expiration in `lr'\n */\n\nstatic void\nreport_expiration (krb5_context context,\n\t\t   krb5_prompter_fct prompter,\n\t\t   krb5_data *data,\n\t\t   const char *str,\n\t\t   time_t now)\n{\n    char *p = NULL;\n\n    if (asprintf(&p, \"%s%s\", str, ctime(&now)) < 0 || p == NULL)\n\treturn;\n    (*prompter)(context, data, NULL, p, 0, NULL);\n    free(p);\n}\n\n/*\n * Check the context, and in the case there is a expiration warning,\n * use the prompter to print the warning.\n *\n * @param context A Kerberos 5 context.\n * @param options An GIC options structure\n * @param ctx The krb5_init_creds_context check for expiration.\n */\n\nkrb5_error_code\nkrb5_process_last_request(krb5_context context,\n\t\t\t  krb5_get_init_creds_opt *options,\n\t\t\t  krb5_init_creds_context ctx)\n{\n    krb5_const_realm realm;\n    LastReq *lr;\n    krb5_boolean reported = FALSE;\n    krb5_timestamp sec;\n    time_t t;\n    size_t i;\n\n    /*\n     * First check if there is a API consumer.\n     */\n\n    realm = krb5_principal_get_realm (context, ctx->cred.client);\n    lr = &ctx->enc_part.last_req;\n\n    if (options && options->opt_private && options->opt_private->lr.func) {\n\tkrb5_last_req_entry **lre;\n\n\tlre = calloc(lr->len + 1, sizeof(*lre));\n\tif (lre == NULL)\n\t    return krb5_enomem(context);\n\tfor (i = 0; i < lr->len; i++) {\n\t    lre[i] = calloc(1, sizeof(*lre[i]));\n\t    if (lre[i] == NULL)\n\t\tbreak;\n\t    lre[i]->lr_type = lr->val[i].lr_type;\n\t    lre[i]->value = lr->val[i].lr_value;\n\t}\n\n\t(*options->opt_private->lr.func)(context, lre,\n\t\t\t\t\t options->opt_private->lr.ctx);\n\n\tfor (i = 0; i < lr->len; i++)\n\t    free(lre[i]);\n\tfree(lre);\n    }\n\n    /*\n     * Now check if we should prompt the user\n     */\n\n    if (ctx->prompter == NULL)\n        return 0;\n\n    krb5_timeofday (context, &sec);\n\n    t = sec + get_config_time (context,\n\t\t\t       realm,\n\t\t\t       \"warn_pwexpire\",\n\t\t\t       7 * 24 * 60 * 60);\n\n    for (i = 0; i < lr->len; ++i) {\n\tif (lr->val[i].lr_value <= t) {\n\t    switch (lr->val[i].lr_type) {\n\t    case LR_PW_EXPTIME :\n\t\treport_expiration(context, ctx->prompter,\n\t\t\t\t  ctx->prompter_data,\n\t\t\t\t  \"Your password will expire at \",\n\t\t\t\t  lr->val[i].lr_value);\n\t\treported = TRUE;\n\t\tbreak;\n\t    case LR_ACCT_EXPTIME :\n\t\treport_expiration(context, ctx->prompter,\n\t\t\t\t  ctx->prompter_data,\n\t\t\t\t  \"Your account will expire at \",\n\t\t\t\t  lr->val[i].lr_value);\n\t\treported = TRUE;\n\t\tbreak;\n            default:\n                break;\n\t    }\n\t}\n    }\n\n    if (!reported\n\t&& ctx->enc_part.key_expiration\n\t&& *ctx->enc_part.key_expiration <= t) {\n        report_expiration(context, ctx->prompter,\n\t\t\t  ctx->prompter_data,\n\t\t\t  \"Your password/account will expire at \",\n\t\t\t  *ctx->enc_part.key_expiration);\n    }\n    return 0;\n}\n\nstatic krb5_addresses no_addrs = { 0, NULL };\n\nstatic krb5_error_code\nget_init_creds_common(krb5_context context,\n\t\t      krb5_principal client,\n\t\t      krb5_deltat start_time,\n\t\t      krb5_get_init_creds_opt *options,\n\t\t      krb5_init_creds_context ctx)\n{\n    krb5_get_init_creds_opt *default_opt = NULL;\n    krb5_error_code ret;\n    krb5_enctype *etypes;\n    krb5_preauthtype *pre_auth_types;\n\n    memset(ctx, 0, sizeof(*ctx));\n\n    if (options == NULL) {\n\tconst char *realm = krb5_principal_get_realm(context, client);\n\n        krb5_get_init_creds_opt_alloc (context, &default_opt);\n\toptions = default_opt;\n\tkrb5_get_init_creds_opt_set_default_flags(context, NULL, realm, options);\n    }\n\n    if (options->opt_private) {\n\tif (options->opt_private->password) {\n\t    ret = krb5_init_creds_set_password(context, ctx,\n\t\t\t\t\t       options->opt_private->password);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\n\tctx->keyproc = options->opt_private->key_proc;\n\tctx->req_pac = options->opt_private->req_pac;\n\tctx->pk_init_ctx = options->opt_private->pk_init_ctx;\n\tctx->ic_flags = options->opt_private->flags;\n    } else\n\tctx->req_pac = KRB5_INIT_CREDS_TRISTATE_UNSET;\n\n    if (ctx->keyproc == NULL)\n\tctx->keyproc = default_s2k_func;\n\n    /* Enterprise name implicitly turns on canonicalize */\n    if ((ctx->ic_flags & KRB5_INIT_CREDS_CANONICALIZE) ||\n\tkrb5_principal_get_type(context, client) == KRB5_NT_ENTERPRISE_PRINCIPAL)\n\tctx->flags.canonicalize = 1;\n\n    ctx->pre_auth_types = NULL;\n    ctx->addrs = NULL;\n    ctx->etypes = NULL;\n    ctx->pre_auth_types = NULL;\n\n    ret = init_cred(context, &ctx->cred, client, start_time, options);\n    if (ret) {\n\tif (default_opt)\n\t    krb5_get_init_creds_opt_free(context, default_opt);\n\treturn ret;\n    }\n\n    ret = krb5_init_creds_set_service(context, ctx, NULL);\n    if (ret)\n\tgoto out;\n\n    if (options->flags & KRB5_GET_INIT_CREDS_OPT_FORWARDABLE)\n\tctx->flags.forwardable = options->forwardable;\n\n    if (options->flags & KRB5_GET_INIT_CREDS_OPT_PROXIABLE)\n\tctx->flags.proxiable = options->proxiable;\n\n    if (start_time)\n\tctx->flags.postdated = 1;\n    if (ctx->cred.times.renew_till)\n\tctx->flags.renewable = 1;\n    if (options->flags & KRB5_GET_INIT_CREDS_OPT_ADDRESS_LIST) {\n\tctx->addrs = options->address_list;\n    } else if (options->opt_private) {\n\tswitch (options->opt_private->addressless) {\n\tcase KRB5_INIT_CREDS_TRISTATE_UNSET:\n#if KRB5_ADDRESSLESS_DEFAULT == TRUE\n\t    ctx->addrs = &no_addrs;\n#else\n\t    ctx->addrs = NULL;\n#endif\n\t    break;\n\tcase KRB5_INIT_CREDS_TRISTATE_FALSE:\n\t    ctx->addrs = NULL;\n\t    break;\n\tcase KRB5_INIT_CREDS_TRISTATE_TRUE:\n\t    ctx->addrs = &no_addrs;\n\t    break;\n\t}\n    }\n    if (options->flags & KRB5_GET_INIT_CREDS_OPT_ETYPE_LIST) {\n\tif (ctx->etypes)\n\t    free(ctx->etypes);\n\n\tetypes = malloc((options->etype_list_length + 1)\n\t\t\t* sizeof(krb5_enctype));\n\tif (etypes == NULL) {\n\t    ret = krb5_enomem(context);\n\t    goto out;\n\t}\n\tmemcpy (etypes, options->etype_list,\n\t\toptions->etype_list_length * sizeof(krb5_enctype));\n\tetypes[options->etype_list_length] = ETYPE_NULL;\n\tctx->etypes = etypes;\n    }\n    if (options->flags & KRB5_GET_INIT_CREDS_OPT_PREAUTH_LIST) {\n\tpre_auth_types = malloc((options->preauth_list_length + 1)\n\t\t\t\t* sizeof(krb5_preauthtype));\n\tif (pre_auth_types == NULL) {\n\t    ret = krb5_enomem(context);\n\t    goto out;\n\t}\n\tmemcpy (pre_auth_types, options->preauth_list,\n\t\toptions->preauth_list_length * sizeof(krb5_preauthtype));\n\tpre_auth_types[options->preauth_list_length] = KRB5_PADATA_NONE;\n\tctx->pre_auth_types = pre_auth_types;\n    }\n    if (options->flags & KRB5_GET_INIT_CREDS_OPT_ANONYMOUS)\n\tctx->flags.request_anonymous = options->anonymous;\n    if (default_opt)\n        krb5_get_init_creds_opt_free(context, default_opt);\n    return 0;\n out:\n    if (default_opt)\n\tkrb5_get_init_creds_opt_free(context, default_opt);\n    return ret;\n}\n\nstatic krb5_error_code\nchange_password (krb5_context context,\n\t\t krb5_principal client,\n\t\t const char *password,\n\t\t char *newpw,\n\t\t size_t newpw_sz,\n\t\t krb5_prompter_fct prompter,\n\t\t void *data,\n\t\t krb5_get_init_creds_opt *old_options)\n{\n    krb5_prompt prompts[2];\n    krb5_error_code ret;\n    krb5_creds cpw_cred;\n    char buf1[BUFSIZ], buf2[BUFSIZ];\n    krb5_data password_data[2];\n    int result_code;\n    krb5_data result_code_string;\n    krb5_data result_string;\n    char *p;\n    krb5_get_init_creds_opt *options;\n\n    heim_assert(prompter != NULL, \"unexpected NULL prompter\");\n\n    memset (&cpw_cred, 0, sizeof(cpw_cred));\n\n    ret = krb5_get_init_creds_opt_alloc(context, &options);\n    if (ret)\n        return ret;\n    krb5_get_init_creds_opt_set_tkt_life (options, 60);\n    krb5_get_init_creds_opt_set_forwardable (options, FALSE);\n    krb5_get_init_creds_opt_set_proxiable (options, FALSE);\n    if (old_options &&\n        (old_options->flags & KRB5_GET_INIT_CREDS_OPT_PREAUTH_LIST))\n\tkrb5_get_init_creds_opt_set_preauth_list(options,\n\t\t\t\t\t\t old_options->preauth_list,\n\t\t\t\t\t\t old_options->preauth_list_length);\n    if (old_options &&\n        (old_options->flags & KRB5_GET_INIT_CREDS_OPT_CHANGE_PASSWORD_PROMPT))\n        krb5_get_init_creds_opt_set_change_password_prompt(options,\n                                                           old_options->change_password_prompt);\n\n    krb5_data_zero (&result_code_string);\n    krb5_data_zero (&result_string);\n\n    ret = krb5_get_init_creds_password (context,\n\t\t\t\t\t&cpw_cred,\n\t\t\t\t\tclient,\n\t\t\t\t\tpassword,\n\t\t\t\t\tprompter,\n\t\t\t\t\tdata,\n\t\t\t\t\t0,\n\t\t\t\t\t\"kadmin/changepw\",\n\t\t\t\t\toptions);\n    krb5_get_init_creds_opt_free(context, options);\n    if (ret)\n\tgoto out;\n\n    for(;;) {\n\tpassword_data[0].data   = buf1;\n\tpassword_data[0].length = sizeof(buf1);\n\n\tprompts[0].hidden = 1;\n\tprompts[0].prompt = \"New password: \";\n\tprompts[0].reply  = &password_data[0];\n\tprompts[0].type   = KRB5_PROMPT_TYPE_NEW_PASSWORD;\n\n\tpassword_data[1].data   = buf2;\n\tpassword_data[1].length = sizeof(buf2);\n\n\tprompts[1].hidden = 1;\n\tprompts[1].prompt = \"Repeat new password: \";\n\tprompts[1].reply  = &password_data[1];\n\tprompts[1].type   = KRB5_PROMPT_TYPE_NEW_PASSWORD_AGAIN;\n\n\tret = (*prompter) (context, data, NULL, \"Changing password\",\n\t\t\t   2, prompts);\n\tif (ret) {\n\t    memset (buf1, 0, sizeof(buf1));\n\t    memset (buf2, 0, sizeof(buf2));\n\t    goto out;\n\t}\n\n\tif (strcmp (buf1, buf2) == 0)\n\t    break;\n\tmemset (buf1, 0, sizeof(buf1));\n\tmemset (buf2, 0, sizeof(buf2));\n    }\n\n    ret = krb5_set_password (context,\n\t\t\t     &cpw_cred,\n\t\t\t     buf1,\n\t\t\t     client,\n\t\t\t     &result_code,\n\t\t\t     &result_code_string,\n\t\t\t     &result_string);\n    if (ret)\n\tgoto out;\n    if (asprintf(&p, \"%s: %.*s\\n\",\n\t\t result_code ? \"Error\" : \"Success\",\n\t\t (int)result_string.length,\n\t\t result_string.length > 0 ? (char*)result_string.data : \"\") < 0)\n    {\n\tret = ENOMEM;\n\tgoto out;\n    }\n\n    /* return the result */\n    (*prompter) (context, data, NULL, p, 0, NULL);\n\n    free (p);\n    if (result_code == 0) {\n\tstrlcpy (newpw, buf1, newpw_sz);\n\tret = 0;\n    } else {\n\tret = ENOTTY;\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"failed changing password\", \"\"));\n    }\n\nout:\n    memset (buf1, 0, sizeof(buf1));\n    memset (buf2, 0, sizeof(buf2));\n    krb5_data_free (&result_string);\n    krb5_data_free (&result_code_string);\n    krb5_free_cred_contents (context, &cpw_cred);\n    return ret;\n}\n\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_keyblock_key_proc (krb5_context context,\n\t\t\tkrb5_keytype type,\n\t\t\tkrb5_data *salt,\n\t\t\tkrb5_const_pointer keyseed,\n\t\t\tkrb5_keyblock **key)\n{\n    return krb5_copy_keyblock (context, keyseed, key);\n}\n\n/*\n *\n */\n\nstatic krb5_error_code\ninit_as_req (krb5_context context,\n\t     KDCOptions opts,\n\t     const krb5_creds *creds,\n\t     const krb5_addresses *addrs,\n\t     const krb5_enctype *etypes,\n\t     AS_REQ *a)\n{\n    krb5_error_code ret;\n\n    memset(a, 0, sizeof(*a));\n\n    a->pvno = 5;\n    a->msg_type = krb_as_req;\n    a->req_body.kdc_options = opts;\n    a->req_body.cname = malloc(sizeof(*a->req_body.cname));\n    if (a->req_body.cname == NULL) {\n\tret = krb5_enomem(context);\n\tgoto fail;\n    }\n    a->req_body.sname = malloc(sizeof(*a->req_body.sname));\n    if (a->req_body.sname == NULL) {\n\tret = krb5_enomem(context);\n\tgoto fail;\n    }\n\n    ret = _krb5_principal2principalname (a->req_body.cname, creds->client);\n    if (ret)\n\tgoto fail;\n    ret = copy_Realm(&creds->client->realm, &a->req_body.realm);\n    if (ret)\n\tgoto fail;\n\n    ret = _krb5_principal2principalname (a->req_body.sname, creds->server);\n    if (ret)\n\tgoto fail;\n\n    if(creds->times.starttime) {\n\ta->req_body.from = malloc(sizeof(*a->req_body.from));\n\tif (a->req_body.from == NULL) {\n\t    ret = krb5_enomem(context);\n\t    goto fail;\n\t}\n\t*a->req_body.from = creds->times.starttime;\n    }\n    if(creds->times.endtime){\n\tif ((ALLOC(a->req_body.till, 1)) != NULL)\n            *a->req_body.till = creds->times.endtime;\n        else {\n            ret = krb5_enomem(context);\n            goto fail;\n        }\n    }\n    if(creds->times.renew_till){\n\ta->req_body.rtime = malloc(sizeof(*a->req_body.rtime));\n\tif (a->req_body.rtime == NULL) {\n\t    ret = krb5_enomem(context);\n\t    goto fail;\n\t}\n\t*a->req_body.rtime = creds->times.renew_till;\n    }\n    a->req_body.nonce = 0;\n    ret = _krb5_init_etype(context,\n\t\t\t   KRB5_PDU_AS_REQUEST,\n\t\t\t   &a->req_body.etype.len,\n\t\t\t   &a->req_body.etype.val,\n\t\t\t   etypes);\n    if (ret)\n\tgoto fail;\n\n    /*\n     * This means no addresses\n     */\n\n    if (addrs && addrs->len == 0) {\n\ta->req_body.addresses = NULL;\n    } else {\n\ta->req_body.addresses = malloc(sizeof(*a->req_body.addresses));\n\tif (a->req_body.addresses == NULL) {\n\t    ret = krb5_enomem(context);\n\t    goto fail;\n\t}\n\n\tif (addrs)\n\t    ret = krb5_copy_addresses(context, addrs, a->req_body.addresses);\n\telse {\n\t    ret = krb5_get_all_client_addrs (context, a->req_body.addresses);\n\t    if(ret == 0 && a->req_body.addresses->len == 0) {\n\t\tfree(a->req_body.addresses);\n\t\ta->req_body.addresses = NULL;\n\t    }\n\t}\n\tif (ret)\n\t    goto fail;\n    }\n\n    a->req_body.enc_authorization_data = NULL;\n    a->req_body.additional_tickets = NULL;\n\n    a->padata = NULL;\n\n    return 0;\n fail:\n    free_AS_REQ(a);\n    memset(a, 0, sizeof(*a));\n    return ret;\n}\n\n\nstatic krb5_error_code\nset_paid(struct pa_info_data *paid, krb5_context context,\n\t krb5_enctype etype,\n\t krb5_salttype salttype, void *salt_string, size_t salt_len,\n\t krb5_data *s2kparams)\n{\n    paid->etype = etype;\n    paid->salt.salttype = salttype;\n    paid->salt.saltvalue.data = malloc(salt_len + 1);\n    if (paid->salt.saltvalue.data == NULL) {\n\tkrb5_clear_error_message(context);\n\treturn ENOMEM;\n    }\n    memcpy(paid->salt.saltvalue.data, salt_string, salt_len);\n    ((char *)paid->salt.saltvalue.data)[salt_len] = '\\0';\n    paid->salt.saltvalue.length = salt_len;\n    if (s2kparams) {\n\tkrb5_error_code ret;\n\n\tret = krb5_copy_data(context, s2kparams, &paid->s2kparams);\n\tif (ret) {\n\t    krb5_clear_error_message(context);\n\t    krb5_free_salt(context, paid->salt);\n\t    return ret;\n\t}\n    } else\n\tpaid->s2kparams = NULL;\n\n    return 0;\n}\n\nstatic struct pa_info_data *\npa_etype_info2(krb5_context context,\n\t       const krb5_principal client,\n\t       const AS_REQ *asreq,\n\t       struct pa_info_data *paid,\n\t       heim_octet_string *data)\n{\n    krb5_error_code ret;\n    ETYPE_INFO2 e;\n    size_t sz;\n    size_t i, j;\n\n    memset(&e, 0, sizeof(e));\n    ret = decode_ETYPE_INFO2(data->data, data->length, &e, &sz);\n    if (ret)\n\tgoto out;\n    if (e.len == 0)\n\tgoto out;\n    for (j = 0; j < asreq->req_body.etype.len; j++) {\n\tfor (i = 0; i < e.len; i++) {\n\t    if (asreq->req_body.etype.val[j] == e.val[i].etype) {\n\t\tkrb5_salt salt;\n\t\tif (e.val[i].salt == NULL)\n\t\t    ret = krb5_get_pw_salt(context, client, &salt);\n\t\telse {\n\t\t    salt.saltvalue.data = *e.val[i].salt;\n\t\t    salt.saltvalue.length = strlen(*e.val[i].salt);\n\t\t    ret = 0;\n\t\t}\n\t\tif (ret == 0)\n\t\t    ret = set_paid(paid, context, e.val[i].etype,\n\t\t\t\t   KRB5_PW_SALT,\n\t\t\t\t   salt.saltvalue.data,\n\t\t\t\t   salt.saltvalue.length,\n\t\t\t\t   e.val[i].s2kparams);\n\t\tif (e.val[i].salt == NULL)\n\t\t    krb5_free_salt(context, salt);\n\t\tif (ret == 0) {\n\t\t    free_ETYPE_INFO2(&e);\n\t\t    return paid;\n\t\t}\n\t    }\n\t}\n    }\n out:\n    free_ETYPE_INFO2(&e);\n    return NULL;\n}\n\nstatic struct pa_info_data *\npa_etype_info(krb5_context context,\n\t      const krb5_principal client,\n\t      const AS_REQ *asreq,\n\t      struct pa_info_data *paid,\n\t      heim_octet_string *data)\n{\n    krb5_error_code ret;\n    ETYPE_INFO e;\n    size_t sz;\n    size_t i, j;\n\n    memset(&e, 0, sizeof(e));\n    ret = decode_ETYPE_INFO(data->data, data->length, &e, &sz);\n    if (ret)\n\tgoto out;\n    if (e.len == 0)\n\tgoto out;\n    for (j = 0; j < asreq->req_body.etype.len; j++) {\n\tfor (i = 0; i < e.len; i++) {\n\t    if (asreq->req_body.etype.val[j] == e.val[i].etype) {\n\t\tkrb5_salt salt;\n\t\tsalt.salttype = KRB5_PW_SALT;\n\t\tif (e.val[i].salt == NULL)\n\t\t    ret = krb5_get_pw_salt(context, client, &salt);\n\t\telse {\n\t\t    salt.saltvalue = *e.val[i].salt;\n\t\t    ret = 0;\n\t\t}\n\t\tif (e.val[i].salttype)\n\t\t    salt.salttype = *e.val[i].salttype;\n\t\tif (ret == 0) {\n\t\t    ret = set_paid(paid, context, e.val[i].etype,\n\t\t\t\t   salt.salttype,\n\t\t\t\t   salt.saltvalue.data,\n\t\t\t\t   salt.saltvalue.length,\n\t\t\t\t   NULL);\n\t\t    if (e.val[i].salt == NULL)\n\t\t\tkrb5_free_salt(context, salt);\n\t\t}\n\t\tif (ret == 0) {\n\t\t    free_ETYPE_INFO(&e);\n\t\t    return paid;\n\t\t}\n\t    }\n\t}\n    }\n out:\n    free_ETYPE_INFO(&e);\n    return NULL;\n}\n\nstatic struct pa_info_data *\npa_pw_or_afs3_salt(krb5_context context,\n\t\t   const krb5_principal client,\n\t\t   const AS_REQ *asreq,\n\t\t   struct pa_info_data *paid,\n\t\t   heim_octet_string *data)\n{\n    krb5_error_code ret;\n    if (paid->etype == KRB5_ENCTYPE_NULL)\n\treturn NULL;\n    ret = set_paid(paid, context,\n\t\t   paid->etype,\n\t\t   paid->salt.salttype,\n\t\t   data->data,\n\t\t   data->length,\n\t\t   NULL);\n    if (ret)\n\treturn NULL;\n    return paid;\n}\n\n\nstruct pa_info {\n    krb5_preauthtype type;\n    struct pa_info_data *(*salt_info)(krb5_context,\n\t\t\t\t      const krb5_principal,\n\t\t\t\t      const AS_REQ *,\n\t\t\t\t      struct pa_info_data *,\n\t\t\t\t      heim_octet_string *);\n};\n\nstatic struct pa_info pa_prefs[] = {\n    { KRB5_PADATA_ETYPE_INFO2, pa_etype_info2 },\n    { KRB5_PADATA_ETYPE_INFO, pa_etype_info },\n    { KRB5_PADATA_PW_SALT, pa_pw_or_afs3_salt },\n    { KRB5_PADATA_AFS3_SALT, pa_pw_or_afs3_salt }\n};\n\nstatic PA_DATA *\nfind_pa_data(const METHOD_DATA *md, unsigned type)\n{\n    size_t i;\n    if (md == NULL)\n\treturn NULL;\n    for (i = 0; i < md->len; i++)\n\tif (md->val[i].padata_type == type)\n\t    return &md->val[i];\n    return NULL;\n}\n\nstatic struct pa_info_data *\nprocess_pa_info(krb5_context context,\n\t\tconst krb5_principal client,\n\t\tconst AS_REQ *asreq,\n\t\tstruct pa_info_data *paid,\n\t\tMETHOD_DATA *md)\n{\n    struct pa_info_data *p = NULL;\n    size_t i;\n\n    for (i = 0; p == NULL && i < sizeof(pa_prefs)/sizeof(pa_prefs[0]); i++) {\n\tPA_DATA *pa = find_pa_data(md, pa_prefs[i].type);\n\tif (pa == NULL)\n\t    continue;\n\tpaid->salt.salttype = (krb5_salttype)pa_prefs[i].type;\n\tp = (*pa_prefs[i].salt_info)(context, client, asreq,\n\t\t\t\t     paid, &pa->padata_value);\n    }\n    return p;\n}\n\nstatic krb5_error_code\nmake_pa_enc_timestamp(krb5_context context, METHOD_DATA *md,\n\t\t      krb5_enctype etype, krb5_keyblock *key)\n{\n    PA_ENC_TS_ENC p;\n    unsigned char *buf;\n    size_t buf_size;\n    size_t len = 0;\n    EncryptedData encdata;\n    krb5_error_code ret;\n    int32_t usec;\n    int usec2;\n    krb5_crypto crypto;\n\n    krb5_us_timeofday (context, &p.patimestamp, &usec);\n    usec2         = usec;\n    p.pausec      = &usec2;\n\n    ASN1_MALLOC_ENCODE(PA_ENC_TS_ENC, buf, buf_size, &p, &len, ret);\n    if (ret)\n\treturn ret;\n    if(buf_size != len)\n\tkrb5_abortx(context, \"internal error in ASN.1 encoder\");\n\n    ret = krb5_crypto_init(context, key, 0, &crypto);\n    if (ret) {\n\tfree(buf);\n\treturn ret;\n    }\n    ret = krb5_encrypt_EncryptedData(context,\n\t\t\t\t     crypto,\n\t\t\t\t     KRB5_KU_PA_ENC_TIMESTAMP,\n\t\t\t\t     buf,\n\t\t\t\t     len,\n\t\t\t\t     0,\n\t\t\t\t     &encdata);\n    free(buf);\n    krb5_crypto_destroy(context, crypto);\n    if (ret)\n\treturn ret;\n\n    ASN1_MALLOC_ENCODE(EncryptedData, buf, buf_size, &encdata, &len, ret);\n    free_EncryptedData(&encdata);\n    if (ret)\n\treturn ret;\n    if(buf_size != len)\n\tkrb5_abortx(context, \"internal error in ASN.1 encoder\");\n\n    ret = krb5_padata_add(context, md, KRB5_PADATA_ENC_TIMESTAMP, buf, len);\n    if (ret)\n\tfree(buf);\n    return ret;\n}\n\nstatic krb5_error_code\nadd_enc_ts_padata(krb5_context context,\n\t\t  METHOD_DATA *md,\n\t\t  krb5_principal client,\n\t\t  krb5_s2k_proc keyproc,\n\t\t  krb5_const_pointer keyseed,\n\t\t  krb5_enctype *enctypes,\n\t\t  unsigned netypes,\n\t\t  krb5_salt *salt,\n\t\t  krb5_data *s2kparams)\n{\n    krb5_error_code ret;\n    krb5_salt salt2;\n    krb5_enctype *ep;\n    size_t i;\n\n    if(salt == NULL) {\n\t/* default to standard salt */\n\tret = krb5_get_pw_salt (context, client, &salt2);\n\tif (ret)\n\t    return ret;\n\tsalt = &salt2;\n    }\n    if (!enctypes) {\n\tenctypes = context->etypes;\n\tnetypes = 0;\n\tfor (ep = enctypes; *ep != (krb5_enctype)ETYPE_NULL; ep++)\n\t    netypes++;\n    }\n\n    for (i = 0; i < netypes; ++i) {\n\tkrb5_keyblock *key;\n\n\t_krb5_debug(context, 5, \"krb5_get_init_creds: using ENC-TS with enctype %d\", enctypes[i]);\n\n\tret = (*keyproc)(context, enctypes[i], keyseed,\n\t\t\t *salt, s2kparams, &key);\n\tif (ret)\n\t    continue;\n\tret = make_pa_enc_timestamp (context, md, enctypes[i], key);\n\tkrb5_free_keyblock (context, key);\n\tif (ret)\n\t    return ret;\n    }\n    if(salt == &salt2)\n\tkrb5_free_salt(context, salt2);\n    return 0;\n}\n\nstatic krb5_error_code\npa_data_to_md_ts_enc(krb5_context context,\n\t\t     const AS_REQ *a,\n\t\t     const krb5_principal client,\n\t\t     krb5_get_init_creds_ctx *ctx,\n\t\t     struct pa_info_data *ppaid,\n\t\t     METHOD_DATA *md)\n{\n    if (ctx->keyproc == NULL || ctx->keyseed == NULL)\n\treturn 0;\n\n    if (ppaid) {\n\tadd_enc_ts_padata(context, md, client,\n\t\t\t  ctx->keyproc, ctx->keyseed,\n\t\t\t  &ppaid->etype, 1,\n\t\t\t  &ppaid->salt, ppaid->s2kparams);\n    } else {\n\tkrb5_salt salt;\n\n\t_krb5_debug(context, 5, \"krb5_get_init_creds: pa-info not found, guessing salt\");\n\n\t/* make a v5 salted pa-data */\n\tadd_enc_ts_padata(context, md, client,\n\t\t\t  ctx->keyproc, ctx->keyseed,\n\t\t\t  a->req_body.etype.val, a->req_body.etype.len,\n\t\t\t  NULL, NULL);\n\n\t/* make a v4 salted pa-data */\n\tsalt.salttype = KRB5_PW_SALT;\n\tkrb5_data_zero(&salt.saltvalue);\n\tadd_enc_ts_padata(context, md, client,\n\t\t\t  ctx->keyproc, ctx->keyseed,\n\t\t\t  a->req_body.etype.val, a->req_body.etype.len,\n\t\t\t  &salt, NULL);\n    }\n    return 0;\n}\n\nstatic krb5_error_code\npa_data_to_key_plain(krb5_context context,\n\t\t     const krb5_principal client,\n\t\t     krb5_get_init_creds_ctx *ctx,\n\t\t     krb5_salt salt,\n\t\t     krb5_data *s2kparams,\n\t\t     krb5_enctype etype,\n\t\t     krb5_keyblock **key)\n{\n    krb5_error_code ret;\n\n    ret = (*ctx->keyproc)(context, etype, ctx->keyseed,\n\t\t\t   salt, s2kparams, key);\n    return ret;\n}\n\n\nstatic krb5_error_code\npa_data_to_md_pkinit(krb5_context context,\n\t\t     const AS_REQ *a,\n\t\t     const krb5_principal client,\n\t\t     int win2k,\n\t\t     krb5_get_init_creds_ctx *ctx,\n\t\t     METHOD_DATA *md)\n{\n    if (ctx->pk_init_ctx == NULL)\n\treturn 0;\n#ifdef PKINIT\n    return _krb5_pk_mk_padata(context,\n\t\t\t      ctx->pk_init_ctx,\n\t\t\t      ctx->ic_flags,\n\t\t\t      win2k,\n\t\t\t      &a->req_body,\n\t\t\t      ctx->pk_nonce,\n\t\t\t      md);\n#else\n    krb5_set_error_message(context, EINVAL,\n\t\t\t   N_(\"no support for PKINIT compiled in\", \"\"));\n    return EINVAL;\n#endif\n}\n\nstatic krb5_error_code\npa_data_add_pac_request(krb5_context context,\n\t\t\tkrb5_get_init_creds_ctx *ctx,\n\t\t\tMETHOD_DATA *md)\n{\n    size_t len = 0, length;\n    krb5_error_code ret;\n    PA_PAC_REQUEST req;\n    void *buf;\n\n    switch (ctx->req_pac) {\n    case KRB5_INIT_CREDS_TRISTATE_UNSET:\n\treturn 0; /* don't bother */\n    case KRB5_INIT_CREDS_TRISTATE_TRUE:\n\treq.include_pac = 1;\n\tbreak;\n    case KRB5_INIT_CREDS_TRISTATE_FALSE:\n\treq.include_pac = 0;\n    }\n\n    ASN1_MALLOC_ENCODE(PA_PAC_REQUEST, buf, length,\n\t\t       &req, &len, ret);\n    if (ret)\n\treturn ret;\n    if(len != length)\n\tkrb5_abortx(context, \"internal error in ASN.1 encoder\");\n\n    ret = krb5_padata_add(context, md, KRB5_PADATA_PA_PAC_REQUEST, buf, len);\n    if (ret)\n\tfree(buf);\n\n    return 0;\n}\n\n/*\n * Assumes caller always will free `out_md', even on error.\n */\n\nstatic krb5_error_code\nprocess_pa_data_to_md(krb5_context context,\n\t\t      const krb5_creds *creds,\n\t\t      const AS_REQ *a,\n\t\t      krb5_get_init_creds_ctx *ctx,\n\t\t      METHOD_DATA *in_md,\n\t\t      METHOD_DATA **out_md,\n\t\t      krb5_prompter_fct prompter,\n\t\t      void *prompter_data)\n{\n    krb5_error_code ret;\n\n    ALLOC(*out_md, 1);\n    if (*out_md == NULL)\n\treturn krb5_enomem(context);\n\n    (*out_md)->len = 0;\n    (*out_md)->val = NULL;\n\n    if (_krb5_have_debug(context, 5)) {\n\tunsigned i;\n\t_krb5_debug(context, 5, \"KDC send %d patypes\", in_md->len);\n\tfor (i = 0; i < in_md->len; i++)\n\t    _krb5_debug(context, 5, \"KDC send PA-DATA type: %d\", in_md->val[i].padata_type);\n    }\n\n    /*\n     * Make sure we don't sent both ENC-TS and PK-INIT pa data, no\n     * need to expose our password protecting our PKCS12 key.\n     */\n\n    if (ctx->pk_init_ctx) {\n\n \t_krb5_debug(context, 5, \"krb5_get_init_creds: \"\n\t\t    \"prepareing PKINIT padata (%s)\",\n \t\t    (ctx->used_pa_types & USED_PKINIT_W2K) ? \"win2k\" : \"ietf\");\n\n \tif (ctx->used_pa_types & USED_PKINIT_W2K) {\n \t    krb5_set_error_message(context, KRB5_GET_IN_TKT_LOOP,\n \t\t\t\t   \"Already tried pkinit, looping\");\n \t    return KRB5_GET_IN_TKT_LOOP;\n \t}\n\n\tret = pa_data_to_md_pkinit(context, a, creds->client,\n\t\t\t\t   (ctx->used_pa_types & USED_PKINIT),\n\t\t\t\t   ctx, *out_md);\n\tif (ret)\n\t    return ret;\n\n\tif (ctx->used_pa_types & USED_PKINIT)\n\t    ctx->used_pa_types |= USED_PKINIT_W2K;\n \telse\n \t    ctx->used_pa_types |= USED_PKINIT;\n\n    } else if (in_md->len != 0) {\n\tstruct pa_info_data *paid, *ppaid;\n \tunsigned flag;\n\n\tpaid = calloc(1, sizeof(*paid));\n        if (paid == NULL)\n            return krb5_enomem(context);\n\n\tpaid->etype = KRB5_ENCTYPE_NULL;\n\tppaid = process_pa_info(context, creds->client, a, paid, in_md);\n\n \tif (ppaid)\n \t    flag = USED_ENC_TS_INFO;\n \telse\n \t    flag = USED_ENC_TS_GUESS;\n\n \tif (ctx->used_pa_types & flag) {\n \t    if (ppaid)\n \t\tfree_paid(context, ppaid);\n            free(paid);\n \t    krb5_set_error_message(context, KRB5_GET_IN_TKT_LOOP,\n \t\t\t\t   \"Already tried ENC-TS-%s, looping\",\n \t\t\t\t   flag == USED_ENC_TS_INFO ? \"info\" : \"guess\");\n \t    return KRB5_GET_IN_TKT_LOOP;\n \t}\n\n\tpa_data_to_md_ts_enc(context, a, creds->client, ctx, ppaid, *out_md);\n\n\tctx->used_pa_types |= flag;\n\n\tif (ppaid) {\n\t    if (ctx->ppaid) {\n\t\tfree_paid(context, ctx->ppaid);\n\t\tfree(ctx->ppaid);\n\t    }\n\t    ctx->ppaid = ppaid;\n\t} else\n\t    free(paid);\n    }\n\n    pa_data_add_pac_request(context, ctx, *out_md);\n\n    if ((ctx->fast_state.flags & KRB5_FAST_DISABLED) == 0) {\n \tret = krb5_padata_add(context, *out_md, KRB5_PADATA_REQ_ENC_PA_REP, NULL, 0);\n \tif (ret)\n \t    return ret;\n    }\n\n    if ((*out_md)->len == 0) {\n\tfree(*out_md);\n\t*out_md = NULL;\n    }\n\n    return 0;\n}\n\nstatic krb5_error_code\nprocess_pa_data_to_key(krb5_context context,\n\t\t       krb5_get_init_creds_ctx *ctx,\n\t\t       krb5_creds *creds,\n\t\t       AS_REQ *a,\n\t\t       AS_REP *rep,\n\t\t       const krb5_krbhst_info *hi,\n\t\t       krb5_keyblock **key)\n{\n    struct pa_info_data paid, *ppaid = NULL;\n    krb5_error_code ret;\n    krb5_enctype etype;\n    PA_DATA *pa;\n\n    memset(&paid, 0, sizeof(paid));\n\n    etype = rep->enc_part.etype;\n\n    if (rep->padata) {\n\tpaid.etype = etype;\n\tppaid = process_pa_info(context, creds->client, a, &paid,\n\t\t\t\trep->padata);\n    }\n    if (ppaid == NULL)\n\tppaid = ctx->ppaid;\n    if (ppaid == NULL) {\n\tret = krb5_get_pw_salt (context, creds->client, &paid.salt);\n\tif (ret)\n\t    return ret;\n\tpaid.etype = etype;\n\tpaid.s2kparams = NULL;\n\tppaid = &paid;\n    }\n\n    pa = NULL;\n    if (rep->padata) {\n\tint idx = 0;\n\tpa = krb5_find_padata(rep->padata->val,\n\t\t\t      rep->padata->len,\n\t\t\t      KRB5_PADATA_PK_AS_REP,\n\t\t\t      &idx);\n\tif (pa == NULL) {\n\t    idx = 0;\n\t    pa = krb5_find_padata(rep->padata->val,\n\t\t\t\t  rep->padata->len,\n\t\t\t\t  KRB5_PADATA_PK_AS_REP_19,\n\t\t\t\t  &idx);\n\t}\n    }\n    if (pa && ctx->pk_init_ctx) {\n#ifdef PKINIT\n\t_krb5_debug(context, 5, \"krb5_get_init_creds: using PKINIT\");\n\n\tret = _krb5_pk_rd_pa_reply(context,\n\t\t\t\t   a->req_body.realm,\n\t\t\t\t   ctx->pk_init_ctx,\n\t\t\t\t   etype,\n\t\t\t\t   hi,\n\t\t\t\t   ctx->pk_nonce,\n\t\t\t\t   &ctx->req_buffer,\n\t\t\t\t   pa,\n\t\t\t\t   key);\n#else\n\tret = EINVAL;\n\tkrb5_set_error_message(context, ret, N_(\"no support for PKINIT compiled in\", \"\"));\n#endif\n    } else if (ctx->keyseed) {\n \t_krb5_debug(context, 5, \"krb5_get_init_creds: using keyproc\");\n\tret = pa_data_to_key_plain(context, creds->client, ctx,\n\t\t\t\t   ppaid->salt, ppaid->s2kparams, etype, key);\n    } else {\n\tret = EINVAL;\n\tkrb5_set_error_message(context, ret, N_(\"No usable pa data type\", \"\"));\n    }\n\n    free_paid(context, &paid);\n    return ret;\n}\n\n/**\n * Start a new context to get a new initial credential.\n *\n * @param context A Kerberos 5 context.\n * @param client The Kerberos principal to get the credential for, if\n *     NULL is given, the default principal is used as determined by\n *     krb5_get_default_principal().\n * @param prompter\n * @param prompter_data\n * @param start_time the time the ticket should start to be valid or 0 for now.\n * @param options a options structure, can be NULL for default options.\n * @param rctx A new allocated free with krb5_init_creds_free().\n *\n * @return 0 for success or an Kerberos 5 error code, see krb5_get_error_message().\n *\n * @ingroup krb5_credential\n */\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_init_creds_init(krb5_context context,\n\t\t     krb5_principal client,\n\t\t     krb5_prompter_fct prompter,\n\t\t     void *prompter_data,\n\t\t     krb5_deltat start_time,\n\t\t     krb5_get_init_creds_opt *options,\n\t\t     krb5_init_creds_context *rctx)\n{\n    krb5_init_creds_context ctx;\n    krb5_error_code ret;\n\n    *rctx = NULL;\n\n    ctx = calloc(1, sizeof(*ctx));\n    if (ctx == NULL)\n\treturn krb5_enomem(context);\n\n    ret = get_init_creds_common(context, client, start_time, options, ctx);\n    if (ret) {\n\tfree(ctx);\n\treturn ret;\n    }\n\n    /* Set a new nonce. */\n    krb5_generate_random_block (&ctx->nonce, sizeof(ctx->nonce));\n    ctx->nonce &= 0x7fffffff;\n    /* XXX these just needs to be the same when using Windows PK-INIT */\n    ctx->pk_nonce = ctx->nonce;\n\n    ctx->prompter = prompter;\n    ctx->prompter_data = prompter_data;\n\n    *rctx = ctx;\n\n    return ret;\n}\n\n/**\n * Sets the service that the is requested. This call is only neede for\n * special initial tickets, by default the a krbtgt is fetched in the default realm.\n *\n * @param context a Kerberos 5 context.\n * @param ctx a krb5_init_creds_context context.\n * @param service the service given as a string, for example\n *        \"kadmind/admin\". If NULL, the default krbtgt in the clients\n *        realm is set.\n *\n * @return 0 for success, or an Kerberos 5 error code, see krb5_get_error_message().\n * @ingroup krb5_credential\n */\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_init_creds_set_service(krb5_context context,\n\t\t\t    krb5_init_creds_context ctx,\n\t\t\t    const char *service)\n{\n    krb5_const_realm client_realm;\n    krb5_principal principal;\n    krb5_error_code ret;\n\n    client_realm = krb5_principal_get_realm (context, ctx->cred.client);\n\n    if (service) {\n\tret = krb5_parse_name (context, service, &principal);\n\tif (ret)\n\t    return ret;\n\tkrb5_principal_set_realm (context, principal, client_realm);\n    } else {\n\tret = krb5_make_principal(context, &principal,\n\t\t\t\t  client_realm, KRB5_TGS_NAME, client_realm,\n\t\t\t\t  NULL);\n\tif (ret)\n\t    return ret;\n    }\n\n    /*\n     * This is for Windows RODC that are picky about what name type\n     * the server principal have, and the really strange part is that\n     * they are picky about the AS-REQ name type and not the TGS-REQ\n     * later. Oh well.\n     */\n\n    if (krb5_principal_is_krbtgt(context, principal))\n\tkrb5_principal_set_type(context, principal, KRB5_NT_SRV_INST);\n\n    krb5_free_principal(context, ctx->cred.server);\n    ctx->cred.server = principal;\n\n    return 0;\n}\n\n/**\n * Sets the password that will use for the request.\n *\n * @param context a Kerberos 5 context.\n * @param ctx ctx krb5_init_creds_context context.\n * @param password the password to use.\n *\n * @return 0 for success, or an Kerberos 5 error code, see krb5_get_error_message().\n * @ingroup krb5_credential\n */\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_init_creds_set_password(krb5_context context,\n\t\t\t     krb5_init_creds_context ctx,\n\t\t\t     const char *password)\n{\n    if (ctx->password) {\n\tmemset(ctx->password, 0, strlen(ctx->password));\n\tfree(ctx->password);\n    }\n    if (password) {\n\tctx->password = strdup(password);\n\tif (ctx->password == NULL)\n\t    return krb5_enomem(context);\n\tctx->keyseed = (void *) ctx->password;\n    } else {\n\tctx->keyseed = NULL;\n\tctx->password = NULL;\n    }\n\n    return 0;\n}\n\nstatic krb5_error_code KRB5_CALLCONV\nkeytab_key_proc(krb5_context context, krb5_enctype enctype,\n\t\tkrb5_const_pointer keyseed,\n\t\tkrb5_salt salt, krb5_data *s2kparms,\n\t\tkrb5_keyblock **key)\n{\n    krb5_keytab_key_proc_args *args  = rk_UNCONST(keyseed);\n    krb5_keytab keytab = args->keytab;\n    krb5_principal principal = args->principal;\n    krb5_error_code ret;\n    krb5_keytab real_keytab;\n    krb5_keytab_entry entry;\n\n    if(keytab == NULL)\n\tkrb5_kt_default(context, &real_keytab);\n    else\n\treal_keytab = keytab;\n\n    ret = krb5_kt_get_entry (context, real_keytab, principal,\n\t\t\t     0, enctype, &entry);\n\n    if (keytab == NULL)\n\tkrb5_kt_close (context, real_keytab);\n\n    if (ret)\n\treturn ret;\n\n    ret = krb5_copy_keyblock (context, &entry.keyblock, key);\n    krb5_kt_free_entry(context, &entry);\n    return ret;\n}\n\n\n/**\n * Set the keytab to use for authentication.\n *\n * @param context a Kerberos 5 context.\n * @param ctx ctx krb5_init_creds_context context.\n * @param keytab the keytab to read the key from.\n *\n * @return 0 for success, or an Kerberos 5 error code, see krb5_get_error_message().\n * @ingroup krb5_credential\n */\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_init_creds_set_keytab(krb5_context context,\n\t\t\t   krb5_init_creds_context ctx,\n\t\t\t   krb5_keytab keytab)\n{\n    krb5_keytab_key_proc_args *a;\n    krb5_keytab_entry entry;\n    krb5_kt_cursor cursor;\n    krb5_enctype *etypes = NULL;\n    krb5_error_code ret;\n    size_t netypes = 0;\n    int kvno = 0, found = 0;\n\n    a = malloc(sizeof(*a));\n    if (a == NULL)\n\treturn krb5_enomem(context);\n\n    a->principal = ctx->cred.client;\n    a->keytab    = keytab;\n\n    ctx->keytab_data = a;\n    ctx->keyseed = (void *)a;\n    ctx->keyproc = keytab_key_proc;\n\n    /*\n     * We need to the KDC what enctypes we support for this keytab,\n     * esp if the keytab is really a password based entry, then the\n     * KDC might have more enctypes in the database then what we have\n     * in the keytab.\n     */\n\n    ret = krb5_kt_start_seq_get(context, keytab, &cursor);\n    if(ret)\n\tgoto out;\n\n    while(krb5_kt_next_entry(context, keytab, &entry, &cursor) == 0){\n\tvoid *ptr;\n\n\tif (!krb5_principal_compare(context, entry.principal, ctx->cred.client))\n\t    goto next;\n\n\tfound = 1;\n\n\t/* check if we ahve this kvno already */\n\tif (entry.vno > kvno) {\n\t    /* remove old list of etype */\n\t    if (etypes)\n\t\tfree(etypes);\n\t    etypes = NULL;\n\t    netypes = 0;\n\t    kvno = entry.vno;\n\t} else if (entry.vno != kvno)\n\t    goto next;\n\n\t/* check if enctype is supported */\n\tif (krb5_enctype_valid(context, entry.keyblock.keytype) != 0)\n\t    goto next;\n\n\t/* add enctype to supported list */\n\tptr = realloc(etypes, sizeof(etypes[0]) * (netypes + 2));\n\tif (ptr == NULL) {\n\t    free(etypes);\n\t    ret = krb5_enomem(context);\n\t    goto out;\n\t}\n\n\tetypes = ptr;\n\tetypes[netypes] = entry.keyblock.keytype;\n\tetypes[netypes + 1] = ETYPE_NULL;\n\tnetypes++;\n    next:\n\tkrb5_kt_free_entry(context, &entry);\n    }\n    krb5_kt_end_seq_get(context, keytab, &cursor);\n\n    if (etypes) {\n\tif (ctx->etypes)\n\t    free(ctx->etypes);\n\tctx->etypes = etypes;\n    }\n\n out:\n    if (!found) {\n\tif (ret == 0)\n\t    ret = KRB5_KT_NOTFOUND;\n\t_krb5_kt_principal_not_found(context, ret, keytab, ctx->cred.client, 0, 0);\n    }\n\n    return ret;\n}\n\nstatic krb5_error_code KRB5_CALLCONV\nkeyblock_key_proc(krb5_context context, krb5_enctype enctype,\n\t\t  krb5_const_pointer keyseed,\n\t\t  krb5_salt salt, krb5_data *s2kparms,\n\t\t  krb5_keyblock **key)\n{\n    return krb5_copy_keyblock (context, keyseed, key);\n}\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_init_creds_set_keyblock(krb5_context context,\n\t\t\t     krb5_init_creds_context ctx,\n\t\t\t     krb5_keyblock *keyblock)\n{\n    ctx->keyseed = (void *)keyblock;\n    ctx->keyproc = keyblock_key_proc;\n\n    return 0;\n}\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_init_creds_set_fast_ccache(krb5_context context,\n\t\t\t\tkrb5_init_creds_context ctx,\n\t\t\t\tkrb5_ccache fast_ccache)\n{\n    ctx->fast_state.armor_ccache = fast_ccache;\n    ctx->fast_state.flags |= KRB5_FAST_REQUIRED;\n    return 0;\n}\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_init_creds_set_fast_ap_armor_service(krb5_context context,\n\t\t\t\t\t  krb5_init_creds_context ctx,\n\t\t\t\t\t  krb5_const_principal armor_service)\n{\n    krb5_error_code ret;\n\n    if (ctx->fast_state.armor_service)\n\tkrb5_free_principal(context, ctx->fast_state.armor_service);\n    if (armor_service) {\n\tret = krb5_copy_principal(context, armor_service, &ctx->fast_state.armor_service);\n\tif (ret)\n\t    return ret;\n    } else {\n\tctx->fast_state.armor_service = NULL;\n    }\n    ctx->fast_state.flags |= KRB5_FAST_REQUIRED | KRB5_FAST_AP_ARMOR_SERVICE;\n    return 0;\n}\n\n/*\n * FAST\n */\n\nstatic krb5_error_code\ncheck_fast(krb5_context context, struct fast_state *state)\n{\n    if (state->flags & KRB5_FAST_EXPECTED) {\n\tkrb5_set_error_message(context, KRB5KRB_AP_ERR_MODIFIED,\n\t\t\t       \"Expected FAST, but no FAST \"\n\t\t\t       \"was in the response from the KDC\");\n\treturn KRB5KRB_AP_ERR_MODIFIED;\n    }\n    return 0;\n}\n\n\nstatic krb5_error_code\nfast_unwrap_as_rep(krb5_context context, int32_t nonce,\n\t\t   krb5_data *chksumdata,\n\t\t   struct fast_state *state, AS_REP *rep)\n{\n    PA_FX_FAST_REPLY fxfastrep;\n    KrbFastResponse fastrep;\n    krb5_error_code ret;\n    PA_DATA *pa = NULL;\n    int idx = 0;\n\n    if (state->armor_crypto == NULL || rep->padata == NULL)\n\treturn check_fast(context, state);\n\n    /* find PA_FX_FAST_REPLY */\n\n    pa = krb5_find_padata(rep->padata->val, rep->padata->len,\n\t\t\t  KRB5_PADATA_FX_FAST, &idx);\n    if (pa == NULL)\n\treturn check_fast(context, state);\n\n    memset(&fxfastrep, 0, sizeof(fxfastrep));\n    memset(&fastrep, 0, sizeof(fastrep));\n\n    ret = decode_PA_FX_FAST_REPLY(pa->padata_value.data, pa->padata_value.length, &fxfastrep, NULL);\n    if (ret)\n\treturn ret;\n\n    if (fxfastrep.element == choice_PA_FX_FAST_REPLY_armored_data) {\n\tkrb5_data data;\n\tret = krb5_decrypt_EncryptedData(context,\n\t\t\t\t\t state->armor_crypto,\n\t\t\t\t\t KRB5_KU_FAST_REP,\n\t\t\t\t\t &fxfastrep.u.armored_data.enc_fast_rep,\n\t\t\t\t\t &data);\n\tif (ret)\n\t    goto out;\n\n\tret = decode_KrbFastResponse(data.data, data.length, &fastrep, NULL);\n\tkrb5_data_free(&data);\n\tif (ret)\n\t    goto out;\n\n    } else {\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n\n    free_METHOD_DATA(rep->padata);\n    ret = copy_METHOD_DATA(&fastrep.padata, rep->padata);\n    if (ret)\n\tgoto out;\n\n    if (fastrep.strengthen_key) {\n\tif (state->strengthen_key)\n\t    krb5_free_keyblock(context, state->strengthen_key);\n\n\tret = krb5_copy_keyblock(context, fastrep.strengthen_key, &state->strengthen_key);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (nonce != fastrep.nonce) {\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n\tgoto out;\n    }\n    if (fastrep.finished) {\n\tPrincipalName cname;\n\tkrb5_realm crealm = NULL;\n\n\tif (chksumdata == NULL) {\n\t    ret = KRB5KDC_ERR_PREAUTH_FAILED;\n\t    goto out;\n\t}\n\n\tret = krb5_verify_checksum(context, state->armor_crypto,\n\t\t\t\t   KRB5_KU_FAST_FINISHED,\n\t\t\t\t   chksumdata->data, chksumdata->length,\n\t\t\t\t   &fastrep.finished->ticket_checksum);\n\tif (ret)\n\t    goto out;\n\n\t/* update */\n\tret = copy_Realm(&fastrep.finished->crealm, &crealm);\n\tif (ret)\n\t    goto out;\n\tfree_Realm(&rep->crealm);\n\trep->crealm = crealm;\n\n\tret = copy_PrincipalName(&fastrep.finished->cname, &cname);\n\tif (ret)\n\t    goto out;\n\tfree_PrincipalName(&rep->cname);\n\trep->cname = cname;\n\t\n#if 0 /* store authenticated checksum as kdc-offset */\n\tfastrep->finished.timestamp;\n\tfastrep->finished.usec = 0;\n#endif\n\n    } else if (chksumdata) {\n\t/* expected fastrep.finish but didn't get it */\n\tret = KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n out:\n    free_PA_FX_FAST_REPLY(&fxfastrep);\n\n    return ret;\n}\n\nstatic krb5_error_code\nfast_unwrap_error(krb5_context context, struct fast_state *state, KRB_ERROR *error)\n{\n    if (state->armor_crypto == NULL)\n\treturn check_fast(context, state);\n\n    return 0;\n}\n\nkrb5_error_code\n_krb5_make_fast_ap_fxarmor(krb5_context context,\n\t\t\t   krb5_ccache armor_ccache,\n\t\t\t   krb5_data *armor_value,\n\t\t\t   krb5_keyblock *armor_key,\n\t\t\t   krb5_crypto *armor_crypto)\n{\n    krb5_auth_context auth_context = NULL;\n    krb5_creds cred, *credp = NULL;\n    krb5_error_code ret;\n    krb5_data empty;\n\n    krb5_data_zero(&empty);\n\n    memset(&cred, 0, sizeof(cred));\n\n    ret = krb5_auth_con_init (context, &auth_context);\n    if (ret)\n\tgoto out;\n    \n    ret = krb5_cc_get_principal(context, armor_ccache, &cred.client);\n    if (ret)\n\tgoto out;\n    \n    ret = krb5_make_principal(context, &cred.server,\n\t\t\t      cred.client->realm,\n\t\t\t      KRB5_TGS_NAME,\n\t\t\t      cred.client->realm,\n\t\t\t      NULL);\n    if (ret) {\n\tkrb5_free_principal(context, cred.client);\n\tgoto out;\n    }\n    \n    ret = krb5_get_credentials(context, 0, armor_ccache, &cred, &credp);\n    krb5_free_principal(context, cred.server);\n    krb5_free_principal(context, cred.client);\n    if (ret)\n\tgoto out;\n    \n    ret = krb5_auth_con_add_AuthorizationData(context, auth_context, KRB5_PADATA_FX_FAST_ARMOR, &empty);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_mk_req_extended(context,\n\t\t\t       &auth_context,\n\t\t\t       AP_OPTS_USE_SUBKEY,\n\t\t\t       NULL,\n\t\t\t       credp,\n\t\t\t       armor_value);\n    krb5_free_creds(context, credp);\n    if (ret)\n\tgoto out;\n    \n    ret = _krb5_fast_armor_key(context,\n\t\t\t       auth_context->local_subkey,\n\t\t\t       auth_context->keyblock,\n\t\t\t       armor_key,\n\t\t\t       armor_crypto);\n    if (ret)\n\tgoto out;\n\n out:\n    krb5_auth_con_free(context, auth_context);\n    return ret;\n}\n\n#ifndef WIN32\nstatic heim_base_once_t armor_service_once = HEIM_BASE_ONCE_INIT;\nstatic heim_ipc armor_service = NULL;\n\nstatic void\nfast_armor_init_ipc(void *ctx)\n{\n    heim_ipc *ipc = ctx;\n    heim_ipc_init_context(\"ANY:org.h5l.armor-service\", ipc);\n}\n#endif /* WIN32 */\n\n\nstatic krb5_error_code\nmake_fast_ap_fxarmor(krb5_context context,\n\t\t     struct fast_state *state,\n\t\t     const char *realm,\n\t\t     KrbFastArmor **armor)\n{\n    KrbFastArmor *fxarmor = NULL;\n    krb5_error_code ret;\n\n    if (state->armor_crypto)\n\tkrb5_crypto_destroy(context, state->armor_crypto);\n    krb5_free_keyblock_contents(context, &state->armor_key);\n\n\n    ALLOC(fxarmor, 1);\n    if (fxarmor == NULL)\n\treturn krb5_enomem(context);\n\n    if (state->flags & KRB5_FAST_AP_ARMOR_SERVICE) {\n#ifdef WIN32\n\tkrb5_set_error_message(context, ENOTSUP, \"Fast armor IPC service not supportted yet on Windows\");\n\tret = ENOTSUP;\n        goto out;\n#else /* WIN32 */\n\tKERB_ARMOR_SERVICE_REPLY msg;\n\tkrb5_data request, reply;\n\n\theim_base_once_f(&armor_service_once, &armor_service, fast_armor_init_ipc);\n\tif (armor_service == NULL) {\n\t    krb5_set_error_message(context, ENOENT, \"Failed to open fast armor service\");\n            ret = ENOENT;\n\t    goto out;\n\t}\n\n\tkrb5_data_zero(&reply);\n\n\trequest.data = rk_UNCONST(realm);\n\trequest.length = strlen(realm);\n\n\tret = heim_ipc_call(armor_service, &request, &reply, NULL);\n\theim_release(send);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret, \"Failed to get armor service credential\");\n\t    goto out;\n\t}\n\n\tret = decode_KERB_ARMOR_SERVICE_REPLY(reply.data, reply.length, &msg, NULL);\n\tkrb5_data_free(&reply);\n\tif (ret)\n\t    goto out;\n\n\tret = copy_KrbFastArmor(fxarmor, &msg.armor);\n\tif (ret) {\n\t    free_KERB_ARMOR_SERVICE_REPLY(&msg);\n\t    goto out;\n\t}\n\n\tret = krb5_copy_keyblock_contents(context, &msg.armor_key, &state->armor_key);\n\tfree_KERB_ARMOR_SERVICE_REPLY(&msg);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_crypto_init(context, &state->armor_key, 0, &state->armor_crypto);\n\tif (ret)\n\t    goto out;\n#endif /* WIN32 */\n    } else {\n\n\tfxarmor->armor_type = 1;\n\n\tret = _krb5_make_fast_ap_fxarmor(context,\n\t\t\t\t\t state->armor_ccache,\n\t\t\t\t\t &fxarmor->armor_value,\n\t\t\t\t\t &state->armor_key,\n\t\t\t\t\t &state->armor_crypto);\n\tif (ret)\n\t    goto out;\n    }\n    \n\n    *armor = fxarmor;\n    fxarmor = NULL;\n out:\n    if (fxarmor) {\n\tfree_KrbFastArmor(fxarmor);\n\tfree(fxarmor);\n    }\n    return ret;\n}\n\nstatic krb5_error_code\nfast_wrap_req(krb5_context context, struct fast_state *state, KDC_REQ *req)\n{\n    KrbFastArmor *fxarmor = NULL;\n    PA_FX_FAST_REQUEST fxreq;\n    krb5_error_code ret;\n    KrbFastReq fastreq;\n    krb5_data data;\n    size_t size;\n\n    if (state->flags & KRB5_FAST_DISABLED) {\n\t_krb5_debug(context, 10, \"fast disabled, not doing any fast wrapping\");\n\treturn 0;\n    }\n\n    memset(&fxreq, 0, sizeof(fxreq));\n    memset(&fastreq, 0, sizeof(fastreq));\n    krb5_data_zero(&data);\n\n    if (state->armor_crypto == NULL) {\n\tif (state->armor_ccache) {\n\t    /*\n\t     * Instead of keeping state in FX_COOKIE in the KDC, we\n\t     * rebuild a new armor key for every request, because this\n\t     * is what the MIT KDC expect and RFC6113 is vage about\n\t     * what the behavior should be.\n\t     */\n\t    state->type = choice_PA_FX_FAST_REQUEST_armored_data;\n\t} else {\n\t    return check_fast(context, state);\n\t}\n    }\n\n    state->flags |= KRB5_FAST_EXPECTED;\n\n    fastreq.fast_options.hide_client_names = 1;\n\n    ret = copy_KDC_REQ_BODY(&req->req_body, &fastreq.req_body);\n    free_KDC_REQ_BODY(&req->req_body);\n\n    req->req_body.realm = strdup(KRB5_ANON_REALM);\n    if ((ALLOC(req->req_body.cname, 1)) != NULL) {\n        req->req_body.cname->name_type = KRB5_NT_WELLKNOWN;\n    if ((ALLOC(req->req_body.cname->name_string.val, 2)) != NULL) {\n        req->req_body.cname->name_string.len = 2;\n        req->req_body.cname->name_string.val[0] = strdup(KRB5_WELLKNOWN_NAME);\n        req->req_body.cname->name_string.val[1] = strdup(KRB5_ANON_NAME);\n        if (req->req_body.cname->name_string.val[0] == NULL ||\n            req->req_body.cname->name_string.val[1] == NULL)\n            ret = krb5_enomem(context);\n      } else\n          ret = krb5_enomem(context);\n    } else\n        ret = krb5_enomem(context);\n    if ((ALLOC(req->req_body.till, 1)) != NULL)\n        *req->req_body.till = 0;\n    else\n        ret = krb5_enomem(context);\n    if (ret)\n        goto out;\n\n    if (req->padata) {\n\tret = copy_METHOD_DATA(req->padata, &fastreq.padata);\n\tfree_METHOD_DATA(req->padata);\n    } else {\n\tif ((ALLOC(req->padata, 1)) == NULL)\n            ret = krb5_enomem(context);\n    }\n    if (ret)\n        goto out;\n\n    ASN1_MALLOC_ENCODE(KrbFastReq, data.data, data.length, &fastreq, &size, ret);\n    if (ret)\n\tgoto out;\n    heim_assert(data.length == size, \"ASN.1 internal error\");\n\n    fxreq.element = state->type;\n\n    if (state->type == choice_PA_FX_FAST_REQUEST_armored_data) {\n\tsize_t len;\n\tvoid *buf;\n\n\tret = make_fast_ap_fxarmor(context, state, fastreq.req_body.realm, &fxreq.u.armored_data.armor);\n\tif (ret)\n\t    goto out;\n\n\theim_assert(state->armor_crypto != NULL, \"FAST armor key missing when FAST started\");\n\n\tASN1_MALLOC_ENCODE(KDC_REQ_BODY, buf, len, &req->req_body, &size, ret);\n\tif (ret)\n\t    goto out;\n\theim_assert(len == size, \"ASN.1 internal error\");\n\n\tret = krb5_create_checksum(context, state->armor_crypto,\n\t\t\t\t   KRB5_KU_FAST_REQ_CHKSUM, 0,\n\t\t\t\t   buf, len, \n\t\t\t\t   &fxreq.u.armored_data.req_checksum);\n\tfree(buf);\n\tif (ret)\n\t    goto out;\n\n\tret = krb5_encrypt_EncryptedData(context, state->armor_crypto,\n\t\t\t\t\t KRB5_KU_FAST_ENC,\n\t\t\t\t\t data.data,\n\t\t\t\t\t data.length,\n\t\t\t\t\t 0,\n\t\t\t\t\t &fxreq.u.armored_data.enc_fast_req);\n\tkrb5_data_free(&data);\n        if (ret)\n            goto out;\n\n    } else {\n\tkrb5_data_free(&data);\n\theim_assert(false, \"unknown FAST type, internal error\");\n    }\n\n    ASN1_MALLOC_ENCODE(PA_FX_FAST_REQUEST, data.data, data.length, &fxreq, &size, ret);\n    if (ret)\n\tgoto out;\n    heim_assert(data.length == size, \"ASN.1 internal error\");\n\n\n    ret = krb5_padata_add(context, req->padata, KRB5_PADATA_FX_FAST, data.data, data.length);\n    if (ret)\n\tgoto out;\n    krb5_data_zero(&data);\n\n out:\n    free_PA_FX_FAST_REQUEST(&fxreq);\n    free_KrbFastReq(&fastreq);\n    if (fxarmor) {\n\tfree_KrbFastArmor(fxarmor);\n\tfree(fxarmor);\n    }\n    krb5_data_free(&data);\n\n    return ret;\n}\n\n\n/**\n * The core loop if krb5_get_init_creds() function family. Create the\n * packets and have the caller send them off to the KDC.\n *\n * If the caller want all work been done for them, use\n * krb5_init_creds_get() instead.\n *\n * @param context a Kerberos 5 context.\n * @param ctx ctx krb5_init_creds_context context.\n * @param in input data from KDC, first round it should be reset by krb5_data_zer().\n * @param out reply to KDC.\n * @param hostinfo KDC address info, first round it can be NULL.\n * @param flags status of the round, if\n *        KRB5_INIT_CREDS_STEP_FLAG_CONTINUE is set, continue one more round.\n *\n * @return 0 for success, or an Kerberos 5 error code, see\n *     krb5_get_error_message().\n *\n * @ingroup krb5_credential\n */\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_init_creds_step(krb5_context context,\n\t\t     krb5_init_creds_context ctx,\n\t\t     krb5_data *in,\n\t\t     krb5_data *out,\n\t\t     krb5_krbhst_info *hostinfo,\n\t\t     unsigned int *flags)\n{\n    krb5_error_code ret;\n    size_t len = 0;\n    size_t size;\n    AS_REQ req2;\n\n    krb5_data_zero(out);\n\n    if (ctx->as_req.req_body.cname == NULL) {\n\tret = init_as_req(context, ctx->flags, &ctx->cred,\n\t\t\t  ctx->addrs, ctx->etypes, &ctx->as_req);\n\tif (ret) {\n\t    free_init_creds_ctx(context, ctx);\n\t    return ret;\n\t}\n    }\n\n#define MAX_PA_COUNTER 10\n    if (ctx->pa_counter > MAX_PA_COUNTER) {\n\tkrb5_set_error_message(context, KRB5_GET_IN_TKT_LOOP,\n\t\t\t       N_(\"Looping %d times while getting \"\n\t\t\t\t  \"initial credentials\", \"\"),\n\t\t\t       ctx->pa_counter);\n\treturn KRB5_GET_IN_TKT_LOOP;\n    }\n    ctx->pa_counter++;\n\n    _krb5_debug(context, 5, \"krb5_get_init_creds: loop %d\", ctx->pa_counter);\n\n    /* Lets process the input packet */\n    if (in && in->length) {\n\tkrb5_kdc_rep rep;\n\n\tmemset(&rep, 0, sizeof(rep));\n\n\t_krb5_debug(context, 5, \"krb5_get_init_creds: processing input\");\n\n\tret = decode_AS_REP(in->data, in->length, &rep.kdc_rep, &size);\n\tif (ret == 0) {\n\t    unsigned eflags = EXTRACT_TICKET_AS_REQ | EXTRACT_TICKET_TIMESYNC;\n\t    krb5_data data;\n\n\t    /*\n\t     * Unwrap AS-REP\n\t     */\n\t    ASN1_MALLOC_ENCODE(Ticket, data.data, data.length,\n\t\t\t       &rep.kdc_rep.ticket, &size, ret);\n\t    if (ret)\n\t\tgoto out;\n\t    heim_assert(data.length == size, \"ASN.1 internal error\");\n\n\t    ret = fast_unwrap_as_rep(context, ctx->nonce, &data,\n\t\t\t\t     &ctx->fast_state, &rep.kdc_rep);\n\t    krb5_data_free(&data);\n\t    if (ret)\n\t\tgoto out;\n\n\t    /*\n\t     * Now check and extract the ticket\n\t     */\n\n\t    if (ctx->flags.canonicalize) {\n\t\teflags |= EXTRACT_TICKET_ALLOW_SERVER_MISMATCH;\n\t\teflags |= EXTRACT_TICKET_MATCH_REALM;\n\t    }\n\t    if (ctx->ic_flags & KRB5_INIT_CREDS_NO_C_CANON_CHECK)\n\t\teflags |= EXTRACT_TICKET_ALLOW_CNAME_MISMATCH;\n\n\t    ret = process_pa_data_to_key(context, ctx, &ctx->cred,\n\t\t\t\t\t &ctx->as_req, &rep.kdc_rep,\n\t\t\t\t\t hostinfo, &ctx->fast_state.reply_key);\n\t    if (ret) {\n\t\tfree_AS_REP(&rep.kdc_rep);\n\t\tgoto out;\n\t    }\n\n\t    _krb5_debug(context, 5, \"krb5_get_init_creds: extracting ticket\");\n\n\t    ret = _krb5_extract_ticket(context,\n\t\t\t\t       &rep,\n\t\t\t\t       &ctx->cred,\n\t\t\t\t       ctx->fast_state.reply_key,\n\t\t\t\t       NULL,\n\t\t\t\t       KRB5_KU_AS_REP_ENC_PART,\n\t\t\t\t       NULL,\n\t\t\t\t       ctx->nonce,\n\t\t\t\t       eflags,\n\t\t\t\t       &ctx->req_buffer,\n\t\t\t\t       NULL,\n\t\t\t\t       NULL);\n\t    if (ret == 0 && ctx->pk_init_ctx) {\n\t\tPA_DATA *pa_pkinit_kx;\n\t\tint idx = 0;\n\n\t\tpa_pkinit_kx =\n\t\t    krb5_find_padata(rep.kdc_rep.padata->val,\n\t\t\t\t     rep.kdc_rep.padata->len,\n\t\t\t\t     KRB5_PADATA_PKINIT_KX,\n\t\t\t\t     &idx);\n\n\t\tret = _krb5_pk_kx_confirm(context, ctx->pk_init_ctx,\n\t\t\t\t\t  ctx->fast_state.reply_key,\n\t\t\t\t\t  &ctx->cred.session,\n\t\t\t\t\t  pa_pkinit_kx);\n\t\tif (ret)\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t   N_(\"Failed to confirm PA-PKINIT-KX\", \"\"));\n\t\telse if (pa_pkinit_kx != NULL)\n\t\t    ctx->ic_flags |= KRB5_INIT_CREDS_PKINIT_KX_VALID;\n\t    }\n\t    if (ret == 0)\n\t\tret = copy_EncKDCRepPart(&rep.enc_part, &ctx->enc_part);\n\n\t    krb5_free_keyblock(context, ctx->fast_state.reply_key);\n\t    ctx->fast_state.reply_key = NULL;\n\t    *flags = 0;\n\n\t    free_AS_REP(&rep.kdc_rep);\n\t    free_EncASRepPart(&rep.enc_part);\n\n\t    return ret;\n\n\t} else {\n\t    /* let's try to parse it as a KRB-ERROR */\n\n\t    _krb5_debug(context, 5, \"krb5_get_init_creds: got an error\");\n\n\t    free_KRB_ERROR(&ctx->error);\n\n\t    ret = krb5_rd_error(context, in, &ctx->error);\n\t    if(ret && in->length && ((char*)in->data)[0] == 4)\n\t\tret = KRB5KRB_AP_ERR_V4_REPLY;\n\t    if (ret) {\n\t\t_krb5_debug(context, 5, \"krb5_get_init_creds: failed to read error\");\n\t\tgoto out;\n\t    }\n\n\t    /*\n\t     * Unwrap KRB-ERROR\n\t     */\n\t    ret = fast_unwrap_error(context, &ctx->fast_state, &ctx->error);\n\t    if (ret)\n\t\tgoto out;\n\n\t    /*\n\t     *\n\t     */\n\n\t    ret = krb5_error_from_rd_error(context, &ctx->error, &ctx->cred);\n\n\t    _krb5_debug(context, 5, \"krb5_get_init_creds: KRB-ERROR %d\", ret);\n\n\t    /*\n\t     * If no preauth was set and KDC requires it, give it one\n\t     * more try.\n\t     */\n\n\t    if (ret == KRB5KDC_ERR_PREAUTH_REQUIRED) {\n\n\t        free_METHOD_DATA(&ctx->md);\n\t        memset(&ctx->md, 0, sizeof(ctx->md));\n\n\t\tif (ctx->error.e_data) {\n\t\t    ret = decode_METHOD_DATA(ctx->error.e_data->data,\n\t\t\t\t\t     ctx->error.e_data->length,\n\t\t\t\t\t     &ctx->md,\n\t\t\t\t\t     NULL);\n\t\t    if (ret)\n\t\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t\t       N_(\"Failed to decode METHOD-DATA\", \"\"));\n\t\t} else {\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t   N_(\"Preauth required but no preauth \"\n\t\t\t\t\t      \"options send by KDC\", \"\"));\n\t\t}\n\t    } else if (ret == KRB5KRB_AP_ERR_SKEW && context->kdc_sec_offset == 0) {\n\t\t/*\n\t\t * Try adapt to timeskrew when we are using pre-auth, and\n\t\t * if there was a time skew, try again.\n\t\t */\n\t\tkrb5_set_real_time(context, ctx->error.stime, -1);\n\t\tif (context->kdc_sec_offset)\n\t\t    ret = 0;\n\n\t\t_krb5_debug(context, 10, \"init_creds: err skew updateing kdc offset to %d\",\n\t\t\t    context->kdc_sec_offset);\n\n\t\tctx->used_pa_types = 0;\n\n\t    } else if (ret == KRB5_KDC_ERR_WRONG_REALM && ctx->flags.canonicalize) {\n\t        /* client referal to a new realm */\n\n\t\tif (ctx->error.crealm == NULL) {\n\t\t    krb5_set_error_message(context, ret,\n\t\t\t\t\t   N_(\"Got a client referral, not but no realm\", \"\"));\n\t\t    goto out;\n\t\t}\n\t\t_krb5_debug(context, 5,\n\t\t\t    \"krb5_get_init_creds: got referal to realm %s\",\n\t\t\t    *ctx->error.crealm);\n\n\t\tret = krb5_principal_set_realm(context,\n\t\t\t\t\t       ctx->cred.client,\n\t\t\t\t\t       *ctx->error.crealm);\n\t\tif (ret)\n\t\t    goto out;\n\n\t\tif (krb5_principal_is_krbtgt(context, ctx->cred.server)) {\n\t\t    ret = krb5_init_creds_set_service(context, ctx, NULL);\n\t\t    if (ret)\n\t\t\tgoto out;\n\t\t}\n\n\t\tfree_AS_REQ(&ctx->as_req);\n\t\tmemset(&ctx->as_req, 0, sizeof(ctx->as_req));\n\n\t\tctx->used_pa_types = 0;\n\t    } else if (ret == KRB5KDC_ERR_KEY_EXP && ctx->runflags.change_password == 0 && ctx->prompter) {\n\t\tchar buf2[1024];\n\n\t\tctx->runflags.change_password = 1;\n\n\t\tctx->prompter(context, ctx->prompter_data, NULL, N_(\"Password has expired\", \"\"), 0, NULL);\n\n\n\t\t/* try to avoid recursion */\n\t\tif (ctx->in_tkt_service != NULL && strcmp(ctx->in_tkt_service, \"kadmin/changepw\") == 0)\n\t\t    goto out;\n\n                /* don't try to change password where then where none */\n                if (ctx->prompter == NULL)\n                    goto out;\n\n\t\tret = change_password(context,\n\t\t\t\t      ctx->cred.client,\n\t\t\t\t      ctx->password,\n\t\t\t\t      buf2,\n\t\t\t\t      sizeof(buf2),\n\t\t\t\t      ctx->prompter,\n\t\t\t\t      ctx->prompter_data,\n\t\t\t\t      NULL);\n\t\tif (ret)\n\t\t    goto out;\n\n\t\tkrb5_init_creds_set_password(context, ctx, buf2);\n\n \t\tctx->used_pa_types = 0;\n\t\tret = 0;\n\n \t    } else if (ret == KRB5KDC_ERR_PREAUTH_FAILED) {\n \n \t\tif (ctx->fast_state.flags & KRB5_FAST_DISABLED)\n \t\t    goto out;\n \t\tif (ctx->fast_state.flags & (KRB5_FAST_REQUIRED | KRB5_FAST_EXPECTED))\n \t\t    goto out;\n \n \t\t_krb5_debug(context, 10, \"preauth failed with FAST, \"\n\t\t\t    \"and told by KD or user, trying w/o FAST\");\n \n \t\tctx->fast_state.flags |= KRB5_FAST_DISABLED;\n \t\tctx->used_pa_types = 0;\n\t\tret = 0;\n\t    }\n\t    if (ret)\n\t\tgoto out;\n\t}\n    }\n\n    if (ctx->as_req.req_body.cname == NULL) {\n\tret = init_as_req(context, ctx->flags, &ctx->cred,\n\t\t\t  ctx->addrs, ctx->etypes, &ctx->as_req);\n\tif (ret) {\n\t    free_init_creds_ctx(context, ctx);\n\t    return ret;\n\t}\n    }\n\n    if (ctx->as_req.padata) {\n\tfree_METHOD_DATA(ctx->as_req.padata);\n\tfree(ctx->as_req.padata);\n\tctx->as_req.padata = NULL;\n    }\n\n    /* Set a new nonce. */\n    ctx->as_req.req_body.nonce = ctx->nonce;\n\n    /* fill_in_md_data */\n    ret = process_pa_data_to_md(context, &ctx->cred, &ctx->as_req, ctx,\n\t\t\t\t&ctx->md, &ctx->as_req.padata,\n\t\t\t\tctx->prompter, ctx->prompter_data);\n    if (ret)\n\tgoto out;\n\n    /*\n     * Wrap with FAST\n     */\n    copy_AS_REQ(&ctx->as_req, &req2);\n\n    ret = fast_wrap_req(context, &ctx->fast_state, &req2);\n    if (ret) {\n\tfree_AS_REQ(&req2);\n\tgoto out;\n    }\n\n    krb5_data_free(&ctx->req_buffer);\n\n    ASN1_MALLOC_ENCODE(AS_REQ,\n\t\t       ctx->req_buffer.data, ctx->req_buffer.length,\n\t\t       &req2, &len, ret);\n    free_AS_REQ(&req2);\n    if (ret)\n\tgoto out;\n    if(len != ctx->req_buffer.length)\n\tkrb5_abortx(context, \"internal error in ASN.1 encoder\");\n\n    out->data = ctx->req_buffer.data;\n    out->length = ctx->req_buffer.length;\n\n    *flags = KRB5_INIT_CREDS_STEP_FLAG_CONTINUE;\n\n    return 0;\n out:\n    return ret;\n}\n\n/**\n * Extract the newly acquired credentials from krb5_init_creds_context\n * context.\n *\n * @param context A Kerberos 5 context.\n * @param ctx\n * @param cred credentials, free with krb5_free_cred_contents().\n *\n * @return 0 for sucess or An Kerberos error code, see krb5_get_error_message().\n */\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_init_creds_get_creds(krb5_context context,\n\t\t\t  krb5_init_creds_context ctx,\n\t\t\t  krb5_creds *cred)\n{\n    return krb5_copy_creds_contents(context, &ctx->cred, cred);\n}\n\n/**\n * Get the last error from the transaction.\n *\n * @return Returns 0 or an error code\n *\n * @ingroup krb5_credential\n */\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_init_creds_get_error(krb5_context context,\n\t\t\t  krb5_init_creds_context ctx,\n\t\t\t  KRB_ERROR *error)\n{\n    krb5_error_code ret;\n\n    ret = copy_KRB_ERROR(&ctx->error, error);\n    if (ret)\n\tkrb5_enomem(context);\n\n    return ret;\n}\n\n/**\n *\n * @ingroup krb5_credential\n */\n\nkrb5_error_code\nkrb5_init_creds_store(krb5_context context,\n\t\t      krb5_init_creds_context ctx,\n\t\t      krb5_ccache id)\n{\n    krb5_error_code ret;\n\n    if (ctx->cred.client == NULL) {\n\tret = KRB5KDC_ERR_PREAUTH_REQUIRED;\n\tkrb5_set_error_message(context, ret, \"init creds not completed yet\");\n\treturn ret;\n    }\n\n    ret = krb5_cc_initialize(context, id, ctx->cred.client);\n    if (ret)\n\treturn ret;\n\n    ret = krb5_cc_store_cred(context, id, &ctx->cred);\n    if (ret)\n\treturn ret;\n\n    if (ctx->cred.flags.b.enc_pa_rep) {\n\tkrb5_data data = { 3, rk_UNCONST(\"yes\") };\n\tret = krb5_cc_set_config(context, id, ctx->cred.server,\n\t\t\t\t \"fast_avail\", &data);\n\tif (ret)\n\t    return ret;\n    }\n\n    return ret;\n}\n\n/**\n * Free the krb5_init_creds_context allocated by krb5_init_creds_init().\n *\n * @param context A Kerberos 5 context.\n * @param ctx The krb5_init_creds_context to free.\n *\n * @ingroup krb5_credential\n */\n\nKRB5_LIB_FUNCTION void KRB5_LIB_CALL\nkrb5_init_creds_free(krb5_context context,\n\t\t     krb5_init_creds_context ctx)\n{\n    free_init_creds_ctx(context, ctx);\n    free(ctx);\n}\n\n/**\n * Get new credentials as setup by the krb5_init_creds_context.\n *\n * @param context A Kerberos 5 context.\n * @param ctx The krb5_init_creds_context to process.\n *\n * @ingroup krb5_credential\n */\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_init_creds_get(krb5_context context, krb5_init_creds_context ctx)\n{\n    krb5_sendto_ctx stctx = NULL;\n    krb5_krbhst_info *hostinfo = NULL;\n    krb5_error_code ret;\n    krb5_data in, out;\n    unsigned int flags = 0;\n\n    krb5_data_zero(&in);\n    krb5_data_zero(&out);\n\n    ret = krb5_sendto_ctx_alloc(context, &stctx);\n    if (ret)\n\tgoto out;\n    krb5_sendto_ctx_set_func(stctx, _krb5_kdc_retry, NULL);\n\n    while (1) {\n\tflags = 0;\n\tret = krb5_init_creds_step(context, ctx, &in, &out, hostinfo, &flags);\n\tkrb5_data_free(&in);\n\tif (ret)\n\t    goto out;\n\n\tif ((flags & 1) == 0)\n\t    break;\n\n\tret = krb5_sendto_context (context, stctx, &out,\n\t\t\t\t   ctx->cred.client->realm, &in);\n    \tif (ret)\n\t    goto out;\n\n    }\n\n out:\n    if (stctx)\n\tkrb5_sendto_ctx_free(context, stctx);\n\n    return ret;\n}\n\n/**\n * Get new credentials using password.\n *\n * @ingroup krb5_credential\n */\n\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_get_init_creds_password(krb5_context context,\n\t\t\t     krb5_creds *creds,\n\t\t\t     krb5_principal client,\n\t\t\t     const char *password,\n\t\t\t     krb5_prompter_fct prompter,\n\t\t\t     void *data,\n\t\t\t     krb5_deltat start_time,\n\t\t\t     const char *in_tkt_service,\n\t\t\t     krb5_get_init_creds_opt *options)\n{\n    krb5_init_creds_context ctx;\n    char buf[BUFSIZ], buf2[BUFSIZ];\n    krb5_error_code ret;\n    int chpw = 0;\n\n again:\n    ret = krb5_init_creds_init(context, client, prompter, data, start_time, options, &ctx);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_init_creds_set_service(context, ctx, in_tkt_service);\n    if (ret)\n\tgoto out;\n\n    if (prompter != NULL && ctx->password == NULL && password == NULL) {\n\tkrb5_prompt prompt;\n\tkrb5_data password_data;\n\tchar *p, *q = NULL;\n\tint aret;\n\n\tret = krb5_unparse_name(context, client, &p);\n\tif (ret)\n\t    goto out;\n\n\taret = asprintf(&q, \"%s's Password: \", p);\n\tfree (p);\n\tif (aret == -1 || q == NULL) {\n\t    ret = krb5_enomem(context);\n\t    goto out;\n\t}\n\tprompt.prompt = q;\n\tpassword_data.data   = buf;\n\tpassword_data.length = sizeof(buf);\n\tprompt.hidden = 1;\n\tprompt.reply  = &password_data;\n\tprompt.type   = KRB5_PROMPT_TYPE_PASSWORD;\n\n\tret = (*prompter) (context, data, NULL, NULL, 1, &prompt);\n\tfree (q);\n\tif (ret) {\n\t    memset (buf, 0, sizeof(buf));\n\t    ret = KRB5_LIBOS_PWDINTR;\n\t    krb5_clear_error_message (context);\n\t    goto out;\n\t}\n\tpassword = password_data.data;\n    }\n\n    if (password) {\n\tret = krb5_init_creds_set_password(context, ctx, password);\n\tif (ret)\n\t    goto out;\n    }\n\n    ret = krb5_init_creds_get(context, ctx);\n\n    if (ret == 0)\n\tkrb5_process_last_request(context, options, ctx);\n\n\n    if (ret == KRB5KDC_ERR_KEY_EXPIRED && chpw == 0) {\n\t/* try to avoid recursion */\n\tif (in_tkt_service != NULL && strcmp(in_tkt_service, \"kadmin/changepw\") == 0)\n\t   goto out;\n\n\t/* don't try to change password where then where none */\n\tif (prompter == NULL)\n\t    goto out;\n\n\tif ((options->flags & KRB5_GET_INIT_CREDS_OPT_CHANGE_PASSWORD_PROMPT) &&\n            !options->change_password_prompt)\n\t\tgoto out;\n\n\tret = change_password (context,\n\t\t\t       client,\n\t\t\t       ctx->password,\n\t\t\t       buf2,\n\t\t\t       sizeof(buf2),\n\t\t\t       prompter,\n\t\t\t       data,\n\t\t\t       options);\n\tif (ret)\n\t    goto out;\n\tpassword = buf2;\n\tchpw = 1;\n\tkrb5_init_creds_free(context, ctx);\n\tgoto again;\n    }\n\n out:\n    if (ret == 0)\n\tkrb5_init_creds_get_creds(context, ctx, creds);\n\n    if (ctx)\n\tkrb5_init_creds_free(context, ctx);\n\n    memset(buf, 0, sizeof(buf));\n    memset(buf2, 0, sizeof(buf2));\n    return ret;\n}\n\n/**\n * Get new credentials using keyblock.\n *\n * @ingroup krb5_credential\n */\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_get_init_creds_keyblock(krb5_context context,\n\t\t\t     krb5_creds *creds,\n\t\t\t     krb5_principal client,\n\t\t\t     krb5_keyblock *keyblock,\n\t\t\t     krb5_deltat start_time,\n\t\t\t     const char *in_tkt_service,\n\t\t\t     krb5_get_init_creds_opt *options)\n{\n    krb5_init_creds_context ctx;\n    krb5_error_code ret;\n\n    memset(creds, 0, sizeof(*creds));\n\n    ret = krb5_init_creds_init(context, client, NULL, NULL, start_time, options, &ctx);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_init_creds_set_service(context, ctx, in_tkt_service);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_init_creds_set_keyblock(context, ctx, keyblock);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_init_creds_get(context, ctx);\n\n    if (ret == 0)\n        krb5_process_last_request(context, options, ctx);\n\n out:\n    if (ret == 0)\n\tkrb5_init_creds_get_creds(context, ctx, creds);\n\n    if (ctx)\n\tkrb5_init_creds_free(context, ctx);\n\n    return ret;\n}\n\n/**\n * Get new credentials using keytab.\n *\n * @ingroup krb5_credential\n */\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_get_init_creds_keytab(krb5_context context,\n\t\t\t   krb5_creds *creds,\n\t\t\t   krb5_principal client,\n\t\t\t   krb5_keytab keytab,\n\t\t\t   krb5_deltat start_time,\n\t\t\t   const char *in_tkt_service,\n\t\t\t   krb5_get_init_creds_opt *options)\n{\n    krb5_init_creds_context ctx;\n    krb5_keytab_entry ktent;\n    krb5_error_code ret;\n\n    memset(&ktent, 0, sizeof(ktent));\n    memset(creds, 0, sizeof(*creds));\n\n    if (strcmp(client->realm, \"\") == 0) {\n        /*\n         * Referral realm.  We have a keytab, so pick a realm by\n         * matching in the keytab.\n         */\n        ret = krb5_kt_get_entry(context, keytab, client, 0, 0, &ktent);\n        if (ret == 0)\n            client = ktent.principal;\n    }\n\n    ret = krb5_init_creds_init(context, client, NULL, NULL, start_time, options, &ctx);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_init_creds_set_service(context, ctx, in_tkt_service);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_init_creds_set_keytab(context, ctx, keytab);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_init_creds_get(context, ctx);\n    if (ret == 0)\n        krb5_process_last_request(context, options, ctx);\n\n out:\n    krb5_kt_free_entry(context, &ktent);\n    if (ret == 0)\n\tkrb5_init_creds_get_creds(context, ctx, creds);\n\n    if (ctx)\n\tkrb5_init_creds_free(context, ctx);\n\n    return ret;\n}\n", "/*\n * Copyright (c) 1997-2016 Kungliga Tekniska H\u00f6gskolan\n * (Royal Institute of Technology, Stockholm, Sweden).\n * All rights reserved.\n *\n * Portions Copyright (c) 2009 Apple Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the Institute nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n/* $Id$ */\n\n#ifndef __KRB5_LOCL_H__\n#define __KRB5_LOCL_H__\n\n#include <config.h>\n#include <roken.h>\n\n#include <ctype.h>\n\n#ifdef HAVE_POLL_H\n#include <sys/poll.h>\n#endif\n\n#include <krb5-types.h>\n\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_MMAN_H\n#include <sys/mman.h>\n#endif\n\n#if defined(HAVE_SYS_IOCTL_H) && SunOS != 40\n#include <sys/ioctl.h>\n#endif\n#ifdef HAVE_PWD_H\n#undef _POSIX_PTHREAD_SEMANTICS\n/* This gets us the 5-arg getpwnam_r on Solaris 9.  */\n#define _POSIX_PTHREAD_SEMANTICS\n#include <pwd.h>\n#endif\n\n#ifdef HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n#ifdef _AIX\nstruct mbuf;\n#endif\n#ifdef HAVE_SYS_FILIO_H\n#include <sys/filio.h>\n#endif\n#ifdef HAVE_SYS_FILE_H\n#include <sys/file.h>\n#endif\n\n#include <com_err.h>\n\n#include <heimbase.h>\n\n#define HEIMDAL_TEXTDOMAIN \"heimdal_krb5\"\n\n#ifdef LIBINTL\n#include <libintl.h>\n#define N_(x,y) dgettext(HEIMDAL_TEXTDOMAIN, x)\n#else\n#define N_(x,y) (x)\n#define bindtextdomain(package, localedir)\n#endif\n\n\n#ifdef HAVE_CRYPT_H\n#undef des_encrypt\n#define des_encrypt wingless_pigs_mostly_fail_to_fly\n#include <crypt.h>\n#undef des_encrypt\n#endif\n\n#ifdef HAVE_DOOR_CREATE\n#include <door.h>\n#endif\n\n#include <parse_time.h>\n#include <base64.h>\n\n#include <wind.h>\n\n/*\n * We use OpenSSL for EC, but to do this we need to disable cross-references\n * between OpenSSL and hcrypto bn.h and such.  Source files that use OpenSSL EC\n * must define HEIM_NO_CRYPTO_HDRS before including this file.\n */\n#define HC_DEPRECATED_CRYPTO\n#ifndef HEIM_NO_CRYPTO_HDRS\n#include \"crypto-headers.h\"\n#endif\n\n\n#include <krb5_asn1.h>\n#include <pkinit_asn1.h>\n\nstruct send_to_kdc;\n\n/* XXX glue for pkinit */\nstruct hx509_certs_data;\nstruct krb5_pk_identity;\nstruct krb5_pk_cert;\nstruct ContentInfo;\nstruct AlgorithmIdentifier;\ntypedef struct krb5_pk_init_ctx_data *krb5_pk_init_ctx;\nstruct krb5_dh_moduli;\n\n/* v4 glue */\nstruct _krb5_krb_auth_data;\n\n#include <der.h>\n\n#include <krb5.h>\n#include <krb5_err.h>\n#include <asn1_err.h>\n#ifdef PKINIT\n#include <hx509.h>\n#endif\n\n#include \"crypto.h\"\n\n#include <krb5-private.h>\n\n#include \"heim_threads.h\"\n\n#define ALLOC(X, N) (X) = calloc((N), sizeof(*(X)))\n#define ALLOC_SEQ(X, N) do { (X)->len = (N); ALLOC((X)->val, (N)); } while(0)\n\n#ifndef __func__\n#define __func__ \"unknown-function\"\n#endif\n\n#define krb5_einval(context, argnum) _krb5_einval((context), __func__, (argnum))\n\n#ifndef PATH_SEP\n#define PATH_SEP \":\"\n#endif\n\n/* should this be public? */\n#define KEYTAB_DEFAULT \"FILE:\" SYSCONFDIR \"/krb5.keytab\"\n#define KEYTAB_DEFAULT_MODIFY \"FILE:\" SYSCONFDIR \"/krb5.keytab\"\n\n\n#define MODULI_FILE SYSCONFDIR \"/krb5.moduli\"\n\n#ifndef O_BINARY\n#define O_BINARY 0\n#endif\n\n#ifndef O_CLOEXEC\n#define O_CLOEXEC 0\n#endif\n\n#ifndef SOCK_CLOEXEC\n#define SOCK_CLOEXEC 0\n#endif\n\n\n#define KRB5_BUFSIZ 2048\n\ntypedef enum {\n    KRB5_INIT_CREDS_TRISTATE_UNSET = 0,\n    KRB5_INIT_CREDS_TRISTATE_TRUE,\n    KRB5_INIT_CREDS_TRISTATE_FALSE\n} krb5_get_init_creds_tristate;\n\nstruct _krb5_get_init_creds_opt_private {\n    int refcount;\n    /* ENC_TIMESTAMP */\n    const char *password;\n    krb5_s2k_proc key_proc;\n    /* PA_PAC_REQUEST */\n    krb5_get_init_creds_tristate req_pac;\n    /* PKINIT */\n    krb5_pk_init_ctx pk_init_ctx;\n    krb5_get_init_creds_tristate addressless;\n    int flags;\n#define KRB5_INIT_CREDS_CANONICALIZE\t\t1\n#define KRB5_INIT_CREDS_NO_C_CANON_CHECK\t2\n#define KRB5_INIT_CREDS_NO_C_NO_EKU_CHECK\t4\n#define KRB5_INIT_CREDS_PKINIT_KX_VALID\t\t32\n    struct {\n        krb5_gic_process_last_req func;\n        void *ctx;\n    } lr;\n};\n\ntypedef uint32_t krb5_enctype_set;\n\ntypedef struct krb5_context_data {\n    krb5_enctype *etypes;\n    krb5_enctype *cfg_etypes;\n    krb5_enctype *etypes_des;/* deprecated */\n    krb5_enctype *as_etypes;\n    krb5_enctype *tgs_etypes;\n    krb5_enctype *permitted_enctypes;\n    char **default_realms;\n    time_t max_skew;\n    time_t kdc_timeout;\n    time_t host_timeout;\n    unsigned max_retries;\n    int32_t kdc_sec_offset;\n    int32_t kdc_usec_offset;\n    krb5_config_section *cf;\n    struct et_list *et_list;\n    struct krb5_log_facility *warn_dest;\n    struct krb5_log_facility *debug_dest;\n    const krb5_cc_ops **cc_ops;\n    int num_cc_ops;\n    const char *http_proxy;\n    const char *time_fmt;\n    krb5_boolean log_utc;\n    const char *default_keytab;\n    const char *default_keytab_modify;\n    krb5_boolean use_admin_kdc;\n    krb5_addresses *extra_addresses;\n    krb5_boolean scan_interfaces;\t/* `ifconfig -a' */\n    krb5_boolean srv_lookup;\t\t/* do SRV lookups */\n    krb5_boolean srv_try_txt;\t\t/* try TXT records also */\n    int32_t fcache_vno;\t\t\t/* create cache files w/ this\n                                           version */\n    int num_kt_types;\t\t\t/* # of registered keytab types */\n    struct krb5_keytab_data *kt_types;  /* registered keytab types */\n    const char *date_fmt;\n    char *error_string;\n    krb5_error_code error_code;\n    krb5_addresses *ignore_addresses;\n    char *default_cc_name;\n    char *default_cc_name_env;\n    int default_cc_name_set;\n    HEIMDAL_MUTEX mutex;\t\t/* protects error_string */\n    int large_msg_size;\n    int max_msg_size;\n    int tgs_negative_timeout;\t\t/* timeout for TGS negative cache */\n    int flags;\n#define KRB5_CTX_F_DNS_CANONICALIZE_HOSTNAME\t1\n#define KRB5_CTX_F_CHECK_PAC\t\t\t2\n#define KRB5_CTX_F_HOMEDIR_ACCESS\t\t4\n#define KRB5_CTX_F_SOCKETS_INITIALIZED          8\n#define KRB5_CTX_F_RD_REQ_IGNORE\t\t16\n#define KRB5_CTX_F_FCACHE_STRICT_CHECKING\t32\n    struct send_to_kdc *send_to_kdc;\n#ifdef PKINIT\n    hx509_context hx509ctx;\n#endif\n    unsigned int num_kdc_requests;\n    krb5_name_canon_rule name_canon_rules;\n} krb5_context_data;\n\n#ifndef KRB5_USE_PATH_TOKENS\n#define KRB5_DEFAULT_CCNAME_FILE \"FILE:/tmp/krb5cc_%{uid}\"\n#define KRB5_DEFAULT_CCNAME_DIR \"DIR:/tmp/krb5cc_%{uid}_dir/\"\n#else\n#define KRB5_DEFAULT_CCNAME_FILE \"FILE:%{TEMP}/krb5cc_%{uid}\"\n#define KRB5_DEFAULT_CCNAME_DIR \"DIR:%{TEMP}/krb5cc_%{uid}_dir/\"\n#endif\n#define KRB5_DEFAULT_CCNAME_API \"API:\"\n#define KRB5_DEFAULT_CCNAME_KCM_KCM \"KCM:%{uid}\"\n#define KRB5_DEFAULT_CCNAME_KCM_API \"API:%{uid}\"\n\n#define EXTRACT_TICKET_ALLOW_CNAME_MISMATCH\t\t1\n#define EXTRACT_TICKET_ALLOW_SERVER_MISMATCH\t\t2\n#define EXTRACT_TICKET_MATCH_REALM\t\t\t4\n#define EXTRACT_TICKET_AS_REQ\t\t\t\t8\n#define EXTRACT_TICKET_TIMESYNC\t\t\t\t16\n\n/*\n * Configurable options\n */\n\n#ifndef KRB5_DEFAULT_CCTYPE\n#ifdef __APPLE__\n#define KRB5_DEFAULT_CCTYPE (&krb5_acc_ops)\n#else\n#define KRB5_DEFAULT_CCTYPE (&krb5_fcc_ops)\n#endif\n#endif\n\n#ifndef KRB5_ADDRESSLESS_DEFAULT\n#define KRB5_ADDRESSLESS_DEFAULT TRUE\n#endif\n\n#ifndef KRB5_FORWARDABLE_DEFAULT\n#define KRB5_FORWARDABLE_DEFAULT TRUE\n#endif\n\n#ifndef KRB5_CONFIGURATION_CHANGE_NOTIFY_NAME\n#define KRB5_CONFIGURATION_CHANGE_NOTIFY_NAME \"org.h5l.Kerberos.configuration-changed\"\n#endif\n\n#ifndef KRB5_FALLBACK_DEFAULT\n#define KRB5_FALLBACK_DEFAULT TRUE\n#endif\n\n#ifndef KRB5_TKT_LIFETIME_DEFAULT\n# define KRB5_TKT_LIFETIME_DEFAULT        15778800  /* seconds */\n#endif\n\n#ifndef KRB5_TKT_RENEW_LIFETIME_DEFAULT\n# define KRB5_TKT_RENEW_LIFETIME_DEFAULT  15778800  /* seconds */\n#endif\n\n#ifdef PKINIT\n\nstruct krb5_pk_identity {\n    hx509_verify_ctx verify_ctx;\n    hx509_certs certs;\n    hx509_cert cert;\n    hx509_certs anchors;\n    hx509_certs certpool;\n    hx509_revoke_ctx revokectx;\n    int flags;\n#define PKINIT_BTMM 1\n};\n\nenum krb5_pk_type {\n    PKINIT_WIN2K = 1,\n    PKINIT_27 = 2\n};\n\nenum keyex_enum { USE_RSA, USE_DH, USE_ECDH };\n\nstruct krb5_pk_init_ctx_data {\n    struct krb5_pk_identity *id;\n    enum keyex_enum keyex;\n    union {\n\tDH *dh;\n        void *eckey;\n    } u;\n    krb5_data *clientDHNonce;\n    struct krb5_dh_moduli **m;\n    hx509_peer_info peer;\n    enum krb5_pk_type type;\n    unsigned int require_binding:1;\n    unsigned int require_eku:1;\n    unsigned int require_krbtgt_otherName:1;\n    unsigned int require_hostname_match:1;\n    unsigned int trustedCertifiers:1;\n    unsigned int anonymous:1;\n};\n\n#endif /* PKINIT */\n\n#define ISTILDE(x) (x == '~')\n#ifdef _WIN32\n# define ISPATHSEP(x) (x == '/' || x =='\\\\')\n#else\n# define ISPATHSEP(x) (x == '/')\n#endif\n\n/* _krb5_principal_is_anonymous() */\n#define KRB5_ANON_MATCH_AUTHENTICATED\t1 /* authenticated with anon flag */\n#define KRB5_ANON_MATCH_UNAUTHENTICATED\t2 /* anonymous PKINIT */\n#define KRB5_ANON_MATCH_ANY\t\t( KRB5_ANON_MATCH_AUTHENTICATED | KRB5_ANON_MATCH_UNAUTHENTICATED )\n\n#endif /* __KRB5_LOCL_H__ */\n", "/*\n * Copyright (c) 2003 - 2016 Kungliga Tekniska H\u00f6gskolan\n * (Royal Institute of Technology, Stockholm, Sweden).\n * All rights reserved.\n *\n * Portions Copyright (c) 2009 Apple Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the Institute nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"krb5_locl.h\"\n\nstruct krb5_dh_moduli {\n    char *name;\n    unsigned long bits;\n    heim_integer p;\n    heim_integer g;\n    heim_integer q;\n};\n\n#ifdef PKINIT\n\n#include <cms_asn1.h>\n#include <pkcs8_asn1.h>\n#include <pkcs9_asn1.h>\n#include <pkcs12_asn1.h>\n#include <pkinit_asn1.h>\n#include <asn1_err.h>\n\n#include <der.h>\n\nstruct krb5_pk_cert {\n    hx509_cert cert;\n};\n\nstatic void\npk_copy_error(krb5_context context,\n\t      hx509_context hx509ctx,\n\t      int hxret,\n\t      const char *fmt,\n\t      ...)\n    __attribute__ ((__format__ (__printf__, 4, 5)));\n\n/*\n *\n */\n\nKRB5_LIB_FUNCTION void KRB5_LIB_CALL\n_krb5_pk_cert_free(struct krb5_pk_cert *cert)\n{\n    if (cert->cert) {\n\thx509_cert_free(cert->cert);\n    }\n    free(cert);\n}\n\nstatic krb5_error_code\nBN_to_integer(krb5_context context, BIGNUM *bn, heim_integer *integer)\n{\n    integer->length = BN_num_bytes(bn);\n    integer->data = malloc(integer->length);\n    if (integer->data == NULL) {\n\tkrb5_clear_error_message(context);\n\treturn ENOMEM;\n    }\n    BN_bn2bin(bn, integer->data);\n    integer->negative = BN_is_negative(bn);\n    return 0;\n}\n\nstatic BIGNUM *\ninteger_to_BN(krb5_context context, const char *field, const heim_integer *f)\n{\n    BIGNUM *bn;\n\n    bn = BN_bin2bn((const unsigned char *)f->data, f->length, NULL);\n    if (bn == NULL) {\n\tkrb5_set_error_message(context, ENOMEM,\n\t\t\t       N_(\"PKINIT: parsing BN failed %s\", \"\"), field);\n\treturn NULL;\n    }\n    BN_set_negative(bn, f->negative);\n    return bn;\n}\n\nstatic krb5_error_code\nselect_dh_group(krb5_context context, DH *dh, unsigned long bits,\n\t\tstruct krb5_dh_moduli **moduli)\n{\n    const struct krb5_dh_moduli *m;\n\n    if (bits == 0) {\n\tm = moduli[1]; /* XXX */\n\tif (m == NULL)\n\t    m = moduli[0]; /* XXX */\n    } else {\n\tint i;\n\tfor (i = 0; moduli[i] != NULL; i++) {\n\t    if (bits < moduli[i]->bits)\n\t\tbreak;\n\t}\n\tif (moduli[i] == NULL) {\n\t    krb5_set_error_message(context, EINVAL,\n\t\t\t\t   N_(\"Did not find a DH group parameter \"\n\t\t\t\t      \"matching requirement of %lu bits\", \"\"),\n\t\t\t\t   bits);\n\t    return EINVAL;\n\t}\n\tm = moduli[i];\n    }\n\n    dh->p = integer_to_BN(context, \"p\", &m->p);\n    if (dh->p == NULL)\n\treturn ENOMEM;\n    dh->g = integer_to_BN(context, \"g\", &m->g);\n    if (dh->g == NULL)\n\treturn ENOMEM;\n    dh->q = integer_to_BN(context, \"q\", &m->q);\n    if (dh->q == NULL)\n\treturn ENOMEM;\n\n    return 0;\n}\n\nstruct certfind {\n    const char *type;\n    const heim_oid *oid;\n};\n\n/*\n * Try searchin the key by to use by first looking for for PK-INIT\n * EKU, then the Microsoft smart card EKU and last, no special EKU at all.\n */\n\nstatic krb5_error_code\nfind_cert(krb5_context context, struct krb5_pk_identity *id,\n\t  hx509_query *q, hx509_cert *cert)\n{\n    struct certfind cf[4] = {\n\t{ \"MobileMe EKU\", NULL },\n\t{ \"PKINIT EKU\", NULL },\n\t{ \"MS EKU\", NULL },\n\t{ \"any (or no)\", NULL }\n    };\n    int ret = HX509_CERT_NOT_FOUND;\n    size_t i, start = 1;\n    unsigned oids[] = { 1, 2, 840, 113635, 100, 3, 2, 1 };\n    const heim_oid mobileMe = { sizeof(oids)/sizeof(oids[0]), oids };\n\n\n    if (id->flags & PKINIT_BTMM)\n\tstart = 0;\n\n    cf[0].oid = &mobileMe;\n    cf[1].oid = &asn1_oid_id_pkekuoid;\n    cf[2].oid = &asn1_oid_id_pkinit_ms_eku;\n    cf[3].oid = NULL;\n\n    for (i = start; i < sizeof(cf)/sizeof(cf[0]); i++) {\n\tret = hx509_query_match_eku(q, cf[i].oid);\n\tif (ret) {\n\t    pk_copy_error(context, context->hx509ctx, ret,\n\t\t\t  \"Failed setting %s OID\", cf[i].type);\n\t    return ret;\n\t}\n\n\tret = hx509_certs_find(context->hx509ctx, id->certs, q, cert);\n\tif (ret == 0)\n\t    break;\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"Failed finding certificate with %s OID\", cf[i].type);\n    }\n    return ret;\n}\n\n\nstatic krb5_error_code\ncreate_signature(krb5_context context,\n\t\t const heim_oid *eContentType,\n\t\t krb5_data *eContent,\n\t\t struct krb5_pk_identity *id,\n\t\t hx509_peer_info peer,\n\t\t krb5_data *sd_data)\n{\n    int ret, flags = 0;\n\n    if (id->cert == NULL)\n\tflags |= HX509_CMS_SIGNATURE_NO_SIGNER;\n\n    ret = hx509_cms_create_signed_1(context->hx509ctx,\n\t\t\t\t    flags,\n\t\t\t\t    eContentType,\n\t\t\t\t    eContent->data,\n\t\t\t\t    eContent->length,\n\t\t\t\t    NULL,\n\t\t\t\t    id->cert,\n\t\t\t\t    peer,\n\t\t\t\t    NULL,\n\t\t\t\t    id->certs,\n\t\t\t\t    sd_data);\n    if (ret) {\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"Create CMS signedData\");\n\treturn ret;\n    }\n\n    return 0;\n}\n\nstatic int\ncert2epi(hx509_context context, void *ctx, hx509_cert c)\n{\n    ExternalPrincipalIdentifiers *ids = ctx;\n    ExternalPrincipalIdentifier id;\n    hx509_name subject = NULL;\n    void *p;\n    int ret;\n\n    if (ids->len > 10)\n\treturn 0;\n\n    memset(&id, 0, sizeof(id));\n\n    ret = hx509_cert_get_subject(c, &subject);\n    if (ret)\n\treturn ret;\n\n    if (hx509_name_is_null_p(subject) != 0) {\n\n\tid.subjectName = calloc(1, sizeof(*id.subjectName));\n\tif (id.subjectName == NULL) {\n\t    hx509_name_free(&subject);\n\t    free_ExternalPrincipalIdentifier(&id);\n\t    return ENOMEM;\n\t}\n\n\tret = hx509_name_binary(subject, id.subjectName);\n\tif (ret) {\n\t    hx509_name_free(&subject);\n\t    free_ExternalPrincipalIdentifier(&id);\n\t    return ret;\n\t}\n    }\n    hx509_name_free(&subject);\n\n\n    id.issuerAndSerialNumber = calloc(1, sizeof(*id.issuerAndSerialNumber));\n    if (id.issuerAndSerialNumber == NULL) {\n\tfree_ExternalPrincipalIdentifier(&id);\n\treturn ENOMEM;\n    }\n\n    {\n\tIssuerAndSerialNumber iasn;\n\thx509_name issuer;\n\tsize_t size = 0;\n\n\tmemset(&iasn, 0, sizeof(iasn));\n\n\tret = hx509_cert_get_issuer(c, &issuer);\n\tif (ret) {\n\t    free_ExternalPrincipalIdentifier(&id);\n\t    return ret;\n\t}\n\n\tret = hx509_name_to_Name(issuer, &iasn.issuer);\n\thx509_name_free(&issuer);\n\tif (ret) {\n\t    free_ExternalPrincipalIdentifier(&id);\n\t    return ret;\n\t}\n\n\tret = hx509_cert_get_serialnumber(c, &iasn.serialNumber);\n\tif (ret) {\n\t    free_IssuerAndSerialNumber(&iasn);\n\t    free_ExternalPrincipalIdentifier(&id);\n\t    return ret;\n\t}\n\n\tASN1_MALLOC_ENCODE(IssuerAndSerialNumber,\n\t\t\t   id.issuerAndSerialNumber->data,\n\t\t\t   id.issuerAndSerialNumber->length,\n\t\t\t   &iasn, &size, ret);\n\tfree_IssuerAndSerialNumber(&iasn);\n\tif (ret) {\n            free_ExternalPrincipalIdentifier(&id);\n\t    return ret;\n        }\n\tif (id.issuerAndSerialNumber->length != size)\n\t    abort();\n    }\n\n    id.subjectKeyIdentifier = NULL;\n\n    p = realloc(ids->val, sizeof(ids->val[0]) * (ids->len + 1));\n    if (p == NULL) {\n\tfree_ExternalPrincipalIdentifier(&id);\n\treturn ENOMEM;\n    }\n\n    ids->val = p;\n    ids->val[ids->len] = id;\n    ids->len++;\n\n    return 0;\n}\n\nstatic krb5_error_code\nbuild_edi(krb5_context context,\n\t  hx509_context hx509ctx,\n\t  hx509_certs certs,\n\t  ExternalPrincipalIdentifiers *ids)\n{\n    return hx509_certs_iter_f(hx509ctx, certs, cert2epi, ids);\n}\n\nstatic krb5_error_code\nbuild_auth_pack(krb5_context context,\n\t\tunsigned nonce,\n\t\tkrb5_pk_init_ctx ctx,\n\t\tconst KDC_REQ_BODY *body,\n\t\tAuthPack *a)\n{\n    size_t buf_size, len = 0;\n    krb5_error_code ret;\n    void *buf;\n    krb5_timestamp sec;\n    int32_t usec;\n    Checksum checksum;\n\n    krb5_clear_error_message(context);\n\n    memset(&checksum, 0, sizeof(checksum));\n\n    krb5_us_timeofday(context, &sec, &usec);\n    a->pkAuthenticator.ctime = sec;\n    a->pkAuthenticator.nonce = nonce;\n\n    ASN1_MALLOC_ENCODE(KDC_REQ_BODY, buf, buf_size, body, &len, ret);\n    if (ret)\n\treturn ret;\n    if (buf_size != len)\n\tkrb5_abortx(context, \"internal error in ASN.1 encoder\");\n\n    ret = krb5_create_checksum(context,\n\t\t\t       NULL,\n\t\t\t       0,\n\t\t\t       CKSUMTYPE_SHA1,\n\t\t\t       buf,\n\t\t\t       len,\n\t\t\t       &checksum);\n    free(buf);\n    if (ret)\n\treturn ret;\n\n    ALLOC(a->pkAuthenticator.paChecksum, 1);\n    if (a->pkAuthenticator.paChecksum == NULL) {\n\treturn krb5_enomem(context);\n    }\n\n    ret = krb5_data_copy(a->pkAuthenticator.paChecksum,\n\t\t\t checksum.checksum.data, checksum.checksum.length);\n    free_Checksum(&checksum);\n    if (ret)\n\treturn ret;\n\n    if (ctx->keyex == USE_DH || ctx->keyex == USE_ECDH) {\n\tconst char *moduli_file;\n\tunsigned long dh_min_bits;\n\tkrb5_data dhbuf;\n\tsize_t size = 0;\n\n\tkrb5_data_zero(&dhbuf);\n\n\n\n\tmoduli_file = krb5_config_get_string(context, NULL,\n\t\t\t\t\t     \"libdefaults\",\n\t\t\t\t\t     \"moduli\",\n\t\t\t\t\t     NULL);\n\n\tdh_min_bits =\n\t    krb5_config_get_int_default(context, NULL, 0,\n\t\t\t\t\t\"libdefaults\",\n\t\t\t\t\t\"pkinit_dh_min_bits\",\n\t\t\t\t\tNULL);\n\n\tret = _krb5_parse_moduli(context, moduli_file, &ctx->m);\n\tif (ret)\n\t    return ret;\n\n\tctx->u.dh = DH_new();\n\tif (ctx->u.dh == NULL)\n\t    return krb5_enomem(context);\n\n\tret = select_dh_group(context, ctx->u.dh, dh_min_bits, ctx->m);\n\tif (ret)\n\t    return ret;\n\n\tif (DH_generate_key(ctx->u.dh) != 1) {\n\t    krb5_set_error_message(context, ENOMEM,\n\t\t\t\t   N_(\"pkinit: failed to generate DH key\", \"\"));\n\t    return ENOMEM;\n\t}\n\n\n\tif (1 /* support_cached_dh */) {\n\t    ALLOC(a->clientDHNonce, 1);\n\t    if (a->clientDHNonce == NULL) {\n\t\tkrb5_clear_error_message(context);\n\t\treturn ENOMEM;\n\t    }\n\t    ret = krb5_data_alloc(a->clientDHNonce, 40);\n\t    if (a->clientDHNonce == NULL) {\n\t\tkrb5_clear_error_message(context);\n\t\treturn ret;\n\t    }\n\t    RAND_bytes(a->clientDHNonce->data, a->clientDHNonce->length);\n\t    ret = krb5_copy_data(context, a->clientDHNonce,\n\t\t\t\t &ctx->clientDHNonce);\n\t    if (ret)\n\t\treturn ret;\n\t}\n\n\tALLOC(a->clientPublicValue, 1);\n\tif (a->clientPublicValue == NULL)\n\t    return ENOMEM;\n\n\tif (ctx->keyex == USE_DH) {\n\t    DH *dh = ctx->u.dh;\n\t    DomainParameters dp;\n\t    heim_integer dh_pub_key;\n\n\t    ret = der_copy_oid(&asn1_oid_id_dhpublicnumber,\n\t\t\t       &a->clientPublicValue->algorithm.algorithm);\n\t    if (ret)\n\t\treturn ret;\n\n\t    memset(&dp, 0, sizeof(dp));\n\n\t    ret = BN_to_integer(context, dh->p, &dp.p);\n\t    if (ret) {\n\t\tfree_DomainParameters(&dp);\n\t\treturn ret;\n\t    }\n\t    ret = BN_to_integer(context, dh->g, &dp.g);\n\t    if (ret) {\n\t\tfree_DomainParameters(&dp);\n\t\treturn ret;\n\t    }\n\t    dp.q = calloc(1, sizeof(*dp.q));\n\t    if (dp.q == NULL) {\n\t\tfree_DomainParameters(&dp);\n\t\treturn ENOMEM;\n\t    }\n\t    ret = BN_to_integer(context, dh->q, dp.q);\n\t    if (ret) {\n\t\tfree_DomainParameters(&dp);\n\t\treturn ret;\n\t    }\n\t    dp.j = NULL;\n\t    dp.validationParms = NULL;\n\n\t    a->clientPublicValue->algorithm.parameters =\n\t\tmalloc(sizeof(*a->clientPublicValue->algorithm.parameters));\n\t    if (a->clientPublicValue->algorithm.parameters == NULL) {\n\t\tfree_DomainParameters(&dp);\n\t\treturn ret;\n\t    }\n\n\t    ASN1_MALLOC_ENCODE(DomainParameters,\n\t\t\t       a->clientPublicValue->algorithm.parameters->data,\n\t\t\t       a->clientPublicValue->algorithm.parameters->length,\n\t\t\t       &dp, &size, ret);\n\t    free_DomainParameters(&dp);\n\t    if (ret)\n\t\treturn ret;\n\t    if (size != a->clientPublicValue->algorithm.parameters->length)\n\t\tkrb5_abortx(context, \"Internal ASN1 encoder error\");\n\n\t    ret = BN_to_integer(context, dh->pub_key, &dh_pub_key);\n\t    if (ret)\n\t\treturn ret;\n\n\t    ASN1_MALLOC_ENCODE(DHPublicKey, dhbuf.data, dhbuf.length,\n\t\t\t       &dh_pub_key, &size, ret);\n\t    der_free_heim_integer(&dh_pub_key);\n\t    if (ret)\n\t\treturn ret;\n\t    if (size != dhbuf.length)\n\t\tkrb5_abortx(context, \"asn1 internal error\");\n            a->clientPublicValue->subjectPublicKey.length = dhbuf.length * 8;\n            a->clientPublicValue->subjectPublicKey.data = dhbuf.data;\n\t} else if (ctx->keyex == USE_ECDH) {\n            ret = _krb5_build_authpack_subjectPK_EC(context, ctx, a);\n            if (ret)\n                return ret;\n\t} else\n\t    krb5_abortx(context, \"internal error\");\n    }\n\n    {\n\ta->supportedCMSTypes = calloc(1, sizeof(*a->supportedCMSTypes));\n\tif (a->supportedCMSTypes == NULL)\n\t    return ENOMEM;\n\n\tret = hx509_crypto_available(context->hx509ctx, HX509_SELECT_ALL,\n\t\t\t\t     ctx->id->cert,\n\t\t\t\t     &a->supportedCMSTypes->val,\n\t\t\t\t     &a->supportedCMSTypes->len);\n\tif (ret)\n\t    return ret;\n    }\n\n    return ret;\n}\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\n_krb5_pk_mk_ContentInfo(krb5_context context,\n\t\t\tconst krb5_data *buf,\n\t\t\tconst heim_oid *oid,\n\t\t\tstruct ContentInfo *content_info)\n{\n    krb5_error_code ret;\n\n    ret = der_copy_oid(oid, &content_info->contentType);\n    if (ret)\n\treturn ret;\n    ALLOC(content_info->content, 1);\n    if (content_info->content == NULL)\n\treturn ENOMEM;\n    content_info->content->data = malloc(buf->length);\n    if (content_info->content->data == NULL)\n\treturn ENOMEM;\n    memcpy(content_info->content->data, buf->data, buf->length);\n    content_info->content->length = buf->length;\n    return 0;\n}\n\nstatic krb5_error_code\npk_mk_padata(krb5_context context,\n\t     krb5_pk_init_ctx ctx,\n\t     const KDC_REQ_BODY *req_body,\n\t     unsigned nonce,\n\t     METHOD_DATA *md)\n{\n    struct ContentInfo content_info;\n    krb5_error_code ret;\n    const heim_oid *oid = NULL;\n    size_t size = 0;\n    krb5_data buf, sd_buf;\n    int pa_type = -1;\n\n    krb5_data_zero(&buf);\n    krb5_data_zero(&sd_buf);\n    memset(&content_info, 0, sizeof(content_info));\n\n    if (ctx->type == PKINIT_WIN2K) {\n\tAuthPack_Win2k ap;\n\tkrb5_timestamp sec;\n\tint32_t usec;\n\n\tmemset(&ap, 0, sizeof(ap));\n\n\t/* fill in PKAuthenticator */\n\tret = copy_PrincipalName(req_body->sname, &ap.pkAuthenticator.kdcName);\n\tif (ret) {\n\t    free_AuthPack_Win2k(&ap);\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\tret = copy_Realm(&req_body->realm, &ap.pkAuthenticator.kdcRealm);\n\tif (ret) {\n\t    free_AuthPack_Win2k(&ap);\n\t    krb5_clear_error_message(context);\n\t    goto out;\n\t}\n\n\tkrb5_us_timeofday(context, &sec, &usec);\n\tap.pkAuthenticator.ctime = sec;\n\tap.pkAuthenticator.cusec = usec;\n\tap.pkAuthenticator.nonce = nonce;\n\n\tASN1_MALLOC_ENCODE(AuthPack_Win2k, buf.data, buf.length,\n\t\t\t   &ap, &size, ret);\n\tfree_AuthPack_Win2k(&ap);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"Failed encoding AuthPackWin: %d\", \"\"),\n\t\t\t\t   (int)ret);\n\t    goto out;\n\t}\n\tif (buf.length != size)\n\t    krb5_abortx(context, \"internal ASN1 encoder error\");\n\n\toid = &asn1_oid_id_pkcs7_data;\n    } else if (ctx->type == PKINIT_27) {\n\tAuthPack ap;\n\n\tmemset(&ap, 0, sizeof(ap));\n\n\tret = build_auth_pack(context, nonce, ctx, req_body, &ap);\n\tif (ret) {\n\t    free_AuthPack(&ap);\n\t    goto out;\n\t}\n\n\tASN1_MALLOC_ENCODE(AuthPack, buf.data, buf.length, &ap, &size, ret);\n\tfree_AuthPack(&ap);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"Failed encoding AuthPack: %d\", \"\"),\n\t\t\t\t   (int)ret);\n\t    goto out;\n\t}\n\tif (buf.length != size)\n\t    krb5_abortx(context, \"internal ASN1 encoder error\");\n\n\toid = &asn1_oid_id_pkauthdata;\n    } else\n\tkrb5_abortx(context, \"internal pkinit error\");\n\n    ret = create_signature(context, oid, &buf, ctx->id,\n\t\t\t   ctx->peer, &sd_buf);\n    krb5_data_free(&buf);\n    if (ret)\n\tgoto out;\n\n    ret = hx509_cms_wrap_ContentInfo(&asn1_oid_id_pkcs7_signedData, &sd_buf, &buf);\n    krb5_data_free(&sd_buf);\n    if (ret) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"ContentInfo wrapping of signedData failed\",\"\"));\n\tgoto out;\n    }\n\n    if (ctx->type == PKINIT_WIN2K) {\n\tPA_PK_AS_REQ_Win2k winreq;\n\n\tpa_type = KRB5_PADATA_PK_AS_REQ_WIN;\n\n\tmemset(&winreq, 0, sizeof(winreq));\n\n\twinreq.signed_auth_pack = buf;\n\n\tASN1_MALLOC_ENCODE(PA_PK_AS_REQ_Win2k, buf.data, buf.length,\n\t\t\t   &winreq, &size, ret);\n\tfree_PA_PK_AS_REQ_Win2k(&winreq);\n\n    } else if (ctx->type == PKINIT_27) {\n\tPA_PK_AS_REQ req;\n\n\tpa_type = KRB5_PADATA_PK_AS_REQ;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.signedAuthPack = buf;\n\n\tif (ctx->trustedCertifiers) {\n\n\t    req.trustedCertifiers = calloc(1, sizeof(*req.trustedCertifiers));\n\t    if (req.trustedCertifiers == NULL) {\n\t\tret = krb5_enomem(context);\n\t\tfree_PA_PK_AS_REQ(&req);\n\t\tgoto out;\n\t    }\n\t    ret = build_edi(context, context->hx509ctx,\n\t\t\t    ctx->id->anchors, req.trustedCertifiers);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       N_(\"pk-init: failed to build \"\n\t\t\t\t\t  \"trustedCertifiers\", \"\"));\n\t\tfree_PA_PK_AS_REQ(&req);\n\t\tgoto out;\n\t    }\n\t}\n\treq.kdcPkId = NULL;\n\n\tASN1_MALLOC_ENCODE(PA_PK_AS_REQ, buf.data, buf.length,\n\t\t\t   &req, &size, ret);\n\n\tfree_PA_PK_AS_REQ(&req);\n\n    } else\n\tkrb5_abortx(context, \"internal pkinit error\");\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"PA-PK-AS-REQ %d\", (int)ret);\n\tgoto out;\n    }\n    if (buf.length != size)\n\tkrb5_abortx(context, \"Internal ASN1 encoder error\");\n\n    ret = krb5_padata_add(context, md, pa_type, buf.data, buf.length);\n    if (ret)\n\tfree(buf.data);\n\n    if (ret == 0)\n    \tkrb5_padata_add(context, md, KRB5_PADATA_PK_AS_09_BINDING, NULL, 0);\n\n out:\n    free_ContentInfo(&content_info);\n\n    return ret;\n}\n\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\n_krb5_pk_mk_padata(krb5_context context,\n\t\t   void *c,\n\t\t   int ic_flags,\n\t\t   int win2k,\n\t\t   const KDC_REQ_BODY *req_body,\n\t\t   unsigned nonce,\n\t\t   METHOD_DATA *md)\n{\n    krb5_pk_init_ctx ctx = c;\n    int win2k_compat;\n\n    if (ctx->id->certs == NULL && ctx->anonymous == 0) {\n\tkrb5_set_error_message(context, HEIM_PKINIT_NO_PRIVATE_KEY,\n\t\t\t       N_(\"PKINIT: No user certificate given\", \"\"));\n\treturn HEIM_PKINIT_NO_PRIVATE_KEY;\n    }\n\n    win2k_compat = krb5_config_get_bool_default(context, NULL,\n\t\t\t\t\t\twin2k,\n\t\t\t\t\t\t\"realms\",\n\t\t\t\t\t\treq_body->realm,\n\t\t\t\t\t\t\"pkinit_win2k\",\n\t\t\t\t\t\tNULL);\n\n    if (win2k_compat) {\n\tctx->require_binding =\n\t    krb5_config_get_bool_default(context, NULL,\n\t\t\t\t\t TRUE,\n\t\t\t\t\t \"realms\",\n\t\t\t\t\t req_body->realm,\n\t\t\t\t\t \"pkinit_win2k_require_binding\",\n\t\t\t\t\t NULL);\n\tctx->type = PKINIT_WIN2K;\n    } else\n\tctx->type = PKINIT_27;\n\n    ctx->require_eku =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     TRUE,\n\t\t\t\t     \"realms\",\n\t\t\t\t     req_body->realm,\n\t\t\t\t     \"pkinit_require_eku\",\n\t\t\t\t     NULL);\n    if (ic_flags & KRB5_INIT_CREDS_NO_C_NO_EKU_CHECK)\n\tctx->require_eku = 0;\n    if (ctx->id->flags & PKINIT_BTMM)\n\tctx->require_eku = 0;\n\n    ctx->require_krbtgt_otherName =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     TRUE,\n\t\t\t\t     \"realms\",\n\t\t\t\t     req_body->realm,\n\t\t\t\t     \"pkinit_require_krbtgt_otherName\",\n\t\t\t\t     NULL);\n\n    ctx->require_hostname_match =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     FALSE,\n\t\t\t\t     \"realms\",\n\t\t\t\t     req_body->realm,\n\t\t\t\t     \"pkinit_require_hostname_match\",\n\t\t\t\t     NULL);\n\n    ctx->trustedCertifiers =\n\tkrb5_config_get_bool_default(context, NULL,\n\t\t\t\t     TRUE,\n\t\t\t\t     \"realms\",\n\t\t\t\t     req_body->realm,\n\t\t\t\t     \"pkinit_trustedCertifiers\",\n\t\t\t\t     NULL);\n\n    return pk_mk_padata(context, ctx, req_body, nonce, md);\n}\n\nstatic krb5_error_code\npk_verify_sign(krb5_context context,\n\t       const void *data,\n\t       size_t length,\n\t       struct krb5_pk_identity *id,\n\t       heim_oid *contentType,\n\t       krb5_data *content,\n\t       struct krb5_pk_cert **signer)\n{\n    hx509_certs signer_certs;\n    int ret, flags = 0;\n\n    /* BTMM is broken in Leo and SnowLeo */\n    if (id->flags & PKINIT_BTMM) {\n\tflags |= HX509_CMS_VS_ALLOW_DATA_OID_MISMATCH;\n\tflags |= HX509_CMS_VS_NO_KU_CHECK;\n\tflags |= HX509_CMS_VS_NO_VALIDATE;\n    }\n\n    *signer = NULL;\n\n    ret = hx509_cms_verify_signed(context->hx509ctx,\n\t\t\t\t  id->verify_ctx,\n\t\t\t\t  flags,\n\t\t\t\t  data,\n\t\t\t\t  length,\n\t\t\t\t  NULL,\n\t\t\t\t  id->certpool,\n\t\t\t\t  contentType,\n\t\t\t\t  content,\n\t\t\t\t  &signer_certs);\n    if (ret) {\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"CMS verify signed failed\");\n\treturn ret;\n    }\n\n    *signer = calloc(1, sizeof(**signer));\n    if (*signer == NULL) {\n\tkrb5_clear_error_message(context);\n\tret = ENOMEM;\n\tgoto out;\n    }\n\n    ret = hx509_get_one_cert(context->hx509ctx, signer_certs, &(*signer)->cert);\n    if (ret) {\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"Failed to get on of the signer certs\");\n\tgoto out;\n    }\n\n out:\n    hx509_certs_free(&signer_certs);\n    if (ret) {\n\tif (*signer) {\n\t    hx509_cert_free((*signer)->cert);\n\t    free(*signer);\n\t    *signer = NULL;\n\t}\n    }\n\n    return ret;\n}\n\nstatic krb5_error_code\nget_reply_key_win(krb5_context context,\n\t\t  const krb5_data *content,\n\t\t  unsigned nonce,\n\t\t  krb5_keyblock **key)\n{\n    ReplyKeyPack_Win2k key_pack;\n    krb5_error_code ret;\n    size_t size;\n\n    ret = decode_ReplyKeyPack_Win2k(content->data,\n\t\t\t\t    content->length,\n\t\t\t\t    &key_pack,\n\t\t\t\t    &size);\n    if (ret) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"PKINIT decoding reply key failed\", \"\"));\n\tfree_ReplyKeyPack_Win2k(&key_pack);\n\treturn ret;\n    }\n\n    if ((unsigned)key_pack.nonce != nonce) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"PKINIT enckey nonce is wrong\", \"\"));\n\tfree_ReplyKeyPack_Win2k(&key_pack);\n\treturn KRB5KRB_AP_ERR_MODIFIED;\n    }\n\n    *key = malloc (sizeof (**key));\n    if (*key == NULL) {\n\tfree_ReplyKeyPack_Win2k(&key_pack);\n\treturn krb5_enomem(context);\n    }\n\n    ret = copy_EncryptionKey(&key_pack.replyKey, *key);\n    free_ReplyKeyPack_Win2k(&key_pack);\n    if (ret) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"PKINIT failed copying reply key\", \"\"));\n\tfree(*key);\n\t*key = NULL;\n    }\n\n    return ret;\n}\n\nstatic krb5_error_code\nget_reply_key(krb5_context context,\n\t      const krb5_data *content,\n\t      const krb5_data *req_buffer,\n\t      krb5_keyblock **key)\n{\n    ReplyKeyPack key_pack;\n    krb5_error_code ret;\n    size_t size;\n\n    ret = decode_ReplyKeyPack(content->data,\n\t\t\t      content->length,\n\t\t\t      &key_pack,\n\t\t\t      &size);\n    if (ret) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"PKINIT decoding reply key failed\", \"\"));\n\tfree_ReplyKeyPack(&key_pack);\n\treturn ret;\n    }\n\n    {\n\tkrb5_crypto crypto;\n\n\t/*\n\t * XXX Verify kp.replyKey is a allowed enctype in the\n\t * configuration file\n\t */\n\n\tret = krb5_crypto_init(context, &key_pack.replyKey, 0, &crypto);\n\tif (ret) {\n\t    free_ReplyKeyPack(&key_pack);\n\t    return ret;\n\t}\n\n\tret = krb5_verify_checksum(context, crypto, 6,\n\t\t\t\t   req_buffer->data, req_buffer->length,\n\t\t\t\t   &key_pack.asChecksum);\n\tkrb5_crypto_destroy(context, crypto);\n\tif (ret) {\n\t    free_ReplyKeyPack(&key_pack);\n\t    return ret;\n\t}\n    }\n\n    *key = malloc (sizeof (**key));\n    if (*key == NULL) {\n\tfree_ReplyKeyPack(&key_pack);\n\treturn krb5_enomem(context);\n    }\n\n    ret = copy_EncryptionKey(&key_pack.replyKey, *key);\n    free_ReplyKeyPack(&key_pack);\n    if (ret) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"PKINIT failed copying reply key\", \"\"));\n\tfree(*key);\n\t*key = NULL;\n    }\n\n    return ret;\n}\n\n\nstatic krb5_error_code\npk_verify_host(krb5_context context,\n\t       const char *realm,\n\t       const krb5_krbhst_info *hi,\n\t       struct krb5_pk_init_ctx_data *ctx,\n\t       struct krb5_pk_cert *host)\n{\n    krb5_error_code ret = 0;\n\n    if (ctx->require_eku) {\n\tret = hx509_cert_check_eku(context->hx509ctx, host->cert,\n\t\t\t\t   &asn1_oid_id_pkkdcekuoid, 0);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"No PK-INIT KDC EKU in kdc certificate\", \"\"));\n\t    return ret;\n\t}\n    }\n    if (ctx->require_krbtgt_otherName) {\n\thx509_octet_string_list list;\n\tsize_t i;\n\tint matched = 0;\n\n\tret = hx509_cert_find_subjectAltName_otherName(context->hx509ctx,\n\t\t\t\t\t\t       host->cert,\n\t\t\t\t\t\t       &asn1_oid_id_pkinit_san,\n\t\t\t\t\t\t       &list);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"Failed to find the PK-INIT \"\n\t\t\t\t      \"subjectAltName in the KDC \"\n\t\t\t\t      \"certificate\", \"\"));\n\n\t    return ret;\n\t}\n\n\t/*\n\t * subjectAltNames are multi-valued, and a single KDC may serve\n\t * multiple realms. The SAN validation here must accept\n\t * the KDC's cert if *any* of the SANs match the expected KDC.\n\t * It is OK for *some* of the SANs to not match, provided at least\n\t * one does.\n\t */\n\tfor (i = 0; matched == 0 && i < list.len; i++) {\n\t    KRB5PrincipalName r;\n\n\t    ret = decode_KRB5PrincipalName(list.val[i].data,\n\t\t\t\t\t   list.val[i].length,\n\t\t\t\t\t   &r,\n\t\t\t\t\t   NULL);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       N_(\"Failed to decode the PK-INIT \"\n\t\t\t\t\t  \"subjectAltName in the \"\n\t\t\t\t\t  \"KDC certificate\", \"\"));\n\n\t\tbreak;\n\t    }\n\n\t    if (r.principalName.name_string.len == 2 &&\n\t\tstrcmp(r.principalName.name_string.val[0], KRB5_TGS_NAME) == 0\n\t\t&& strcmp(r.principalName.name_string.val[1], realm) == 0\n\t\t&& strcmp(r.realm, realm) == 0)\n\t\tmatched = 1;\n\n\t    free_KRB5PrincipalName(&r);\n\t}\n\thx509_free_octet_string_list(&list);\n\tif (matched == 0) {\n\t    ret = KRB5_KDC_ERR_INVALID_CERTIFICATE;\n\t    /* XXX: Lost in translation... */\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"KDC have wrong realm name in \"\n\t\t\t\t      \"the certificate\", \"\"));\n\t}\n    }\n    if (ret)\n\treturn ret;\n\n    if (hi) {\n\tret = hx509_verify_hostname(context->hx509ctx, host->cert,\n\t\t\t\t    ctx->require_hostname_match,\n\t\t\t\t    HX509_HN_HOSTNAME,\n\t\t\t\t    hi->hostname,\n\t\t\t\t    hi->ai->ai_addr, hi->ai->ai_addrlen);\n\n\tif (ret)\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"Address mismatch in \"\n\t\t\t\t      \"the KDC certificate\", \"\"));\n    }\n    return ret;\n}\n\nstatic krb5_error_code\npk_rd_pa_reply_enckey(krb5_context context,\n\t\t      int type,\n\t\t      const heim_octet_string *indata,\n\t\t      const heim_oid *dataType,\n\t\t      const char *realm,\n\t\t      krb5_pk_init_ctx ctx,\n\t\t      krb5_enctype etype,\n\t\t      const krb5_krbhst_info *hi,\n\t       \t      unsigned nonce,\n\t\t      const krb5_data *req_buffer,\n\t       \t      PA_DATA *pa,\n\t       \t      krb5_keyblock **key)\n{\n    krb5_error_code ret;\n    struct krb5_pk_cert *host = NULL;\n    krb5_data content;\n    heim_oid contentType = { 0, NULL };\n    int flags = HX509_CMS_UE_DONT_REQUIRE_KU_ENCIPHERMENT;\n\n    if (der_heim_oid_cmp(&asn1_oid_id_pkcs7_envelopedData, dataType)) {\n\tkrb5_set_error_message(context, EINVAL,\n\t\t\t       N_(\"PKINIT: Invalid content type\", \"\"));\n\treturn EINVAL;\n    }\n\n    if (ctx->type == PKINIT_WIN2K)\n\tflags |= HX509_CMS_UE_ALLOW_WEAK;\n\n    ret = hx509_cms_unenvelope(context->hx509ctx,\n\t\t\t       ctx->id->certs,\n\t\t\t       flags,\n\t\t\t       indata->data,\n\t\t\t       indata->length,\n\t\t\t       NULL,\n\t\t\t       0,\n\t\t\t       &contentType,\n\t\t\t       &content);\n    if (ret) {\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"Failed to unenvelope CMS data in PK-INIT reply\");\n\treturn ret;\n    }\n    der_free_oid(&contentType);\n\n    /* win2k uses ContentInfo */\n    if (type == PKINIT_WIN2K) {\n\theim_oid type2;\n\theim_octet_string out;\n\n\tret = hx509_cms_unwrap_ContentInfo(&content, &type2, &out, NULL);\n\tif (ret) {\n\t    /* windows LH with interesting CMS packets */\n\t    size_t ph = 1 + der_length_len(content.length);\n\t    unsigned char *ptr = malloc(content.length + ph);\n\t    size_t l;\n\n\t    memcpy(ptr + ph, content.data, content.length);\n\n\t    ret = der_put_length_and_tag (ptr + ph - 1, ph, content.length,\n\t\t\t\t\t  ASN1_C_UNIV, CONS, UT_Sequence, &l);\n\t    if (ret) {\n                free(ptr);\n\t\treturn ret;\n            }\n\t    free(content.data);\n\t    content.data = ptr;\n\t    content.length += ph;\n\n\t    ret = hx509_cms_unwrap_ContentInfo(&content, &type2, &out, NULL);\n\t    if (ret)\n\t\tgoto out;\n\t}\n\tif (der_heim_oid_cmp(&type2, &asn1_oid_id_pkcs7_signedData)) {\n\t    ret = EINVAL; /* XXX */\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"PKINIT: Invalid content type\", \"\"));\n\t    der_free_oid(&type2);\n\t    der_free_octet_string(&out);\n\t    goto out;\n\t}\n\tder_free_oid(&type2);\n\tkrb5_data_free(&content);\n\tret = krb5_data_copy(&content, out.data, out.length);\n\tder_free_octet_string(&out);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"malloc: out of memory\", \"\"));\n\t    goto out;\n\t}\n    }\n\n    ret = pk_verify_sign(context,\n\t\t\t content.data,\n\t\t\t content.length,\n\t\t\t ctx->id,\n\t\t\t &contentType,\n\t\t\t &content,\n\t\t\t &host);\n    if (ret)\n\tgoto out;\n\n    /* make sure that it is the kdc's certificate */\n    ret = pk_verify_host(context, realm, hi, ctx, host);\n    if (ret) {\n\tgoto out;\n    }\n\n#if 0\n    if (type == PKINIT_WIN2K) {\n\tif (der_heim_oid_cmp(&contentType, &asn1_oid_id_pkcs7_data) != 0) {\n\t    ret = KRB5KRB_AP_ERR_MSG_TYPE;\n\t    krb5_set_error_message(context, ret, \"PKINIT: reply key, wrong oid\");\n\t    goto out;\n\t}\n    } else {\n\tif (der_heim_oid_cmp(&contentType, &asn1_oid_id_pkrkeydata) != 0) {\n\t    ret = KRB5KRB_AP_ERR_MSG_TYPE;\n\t    krb5_set_error_message(context, ret, \"PKINIT: reply key, wrong oid\");\n\t    goto out;\n\t}\n    }\n#endif\n\n    switch(type) {\n    case PKINIT_WIN2K:\n\tret = get_reply_key(context, &content, req_buffer, key);\n\tif (ret != 0 && ctx->require_binding == 0)\n\t    ret = get_reply_key_win(context, &content, nonce, key);\n\tbreak;\n    case PKINIT_27:\n\tret = get_reply_key(context, &content, req_buffer, key);\n\tbreak;\n    }\n    if (ret)\n\tgoto out;\n\n    /* XXX compare given etype with key->etype */\n\n out:\n    if (host)\n\t_krb5_pk_cert_free(host);\n    der_free_oid(&contentType);\n    krb5_data_free(&content);\n\n    return ret;\n}\n\n/*\n * RFC 8062 section 7:\n *\n *  The client then decrypts the KDC contribution key and verifies that\n *  the ticket session key in the returned ticket is the combined key of\n *  the KDC contribution key and the reply key.\n */\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\n_krb5_pk_kx_confirm(krb5_context context,\n\t\t    krb5_pk_init_ctx ctx,\n\t\t    krb5_keyblock *reply_key,\n\t\t    krb5_keyblock *session_key,\n\t\t    PA_DATA *pa_pkinit_kx)\n{\n    krb5_error_code ret;\n    EncryptedData ed;\n    krb5_keyblock ck, sk_verify;\n    krb5_crypto ck_crypto = NULL;\n    krb5_crypto rk_crypto = NULL;\n    size_t len;\n    krb5_data data;\n    krb5_data p1 = { sizeof(\"PKINIT\") - 1, \"PKINIT\" };\n    krb5_data p2 = { sizeof(\"KEYEXCHANGE\") - 1, \"KEYEXCHANGE\" };\n\n    heim_assert(ctx != NULL, \"PKINIT context is non-NULL\");\n    heim_assert(reply_key != NULL, \"reply key is non-NULL\");\n    heim_assert(session_key != NULL, \"session key is non-NULL\");\n\n    /* PA-PKINIT-KX is optional unless anonymous */\n    if (pa_pkinit_kx == NULL)\n\treturn ctx->anonymous ? KRB5_KDCREP_MODIFIED : 0;\n\n    memset(&ed, 0, sizeof(ed));\n    krb5_keyblock_zero(&ck);\n    krb5_keyblock_zero(&sk_verify);\n    krb5_data_zero(&data);\n\n    ret = decode_EncryptedData(pa_pkinit_kx->padata_value.data,\n\t\t\t       pa_pkinit_kx->padata_value.length,\n\t\t\t       &ed, &len);\n    if (ret)\n\tgoto out;\n\n    if (len != pa_pkinit_kx->padata_value.length) {\n\tret = KRB5_KDCREP_MODIFIED;\n\tgoto out;\n    }\n\n    ret = krb5_crypto_init(context, reply_key, 0, &rk_crypto);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_decrypt_EncryptedData(context, rk_crypto,\n\t\t\t\t     KRB5_KU_PA_PKINIT_KX,\n\t\t\t\t     &ed, &data);\n    if (ret)\n\tgoto out;\n\n    ret = decode_EncryptionKey(data.data, data.length,\n\t\t\t       &ck, &len);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_crypto_init(context, &ck, 0, &ck_crypto);\n    if (ret)\n\tgoto out;\n\n    ret = krb5_crypto_fx_cf2(context, ck_crypto, rk_crypto,\n\t\t\t     &p1, &p2, session_key->keytype,\n\t\t\t     &sk_verify);\n    if (ret)\n\tgoto out;\n\n    if (sk_verify.keytype != session_key->keytype ||\n\tkrb5_data_ct_cmp(&sk_verify.keyvalue, &session_key->keyvalue) != 0) {\n\tret = KRB5_KDCREP_MODIFIED;\n\tgoto out;\n    }\n\nout:\n    free_EncryptedData(&ed);\n    krb5_free_keyblock_contents(context, &ck);\n    krb5_free_keyblock_contents(context, &sk_verify);\n    if (ck_crypto)\n\tkrb5_crypto_destroy(context, ck_crypto);\n    if (rk_crypto)\n\tkrb5_crypto_destroy(context, rk_crypto);\n    krb5_data_free(&data);\n\n    return ret;\n}\n\nstatic krb5_error_code\npk_rd_pa_reply_dh(krb5_context context,\n\t\t  const heim_octet_string *indata,\n\t\t  const heim_oid *dataType,\n\t\t  const char *realm,\n\t\t  krb5_pk_init_ctx ctx,\n\t\t  krb5_enctype etype,\n\t\t  const krb5_krbhst_info *hi,\n\t\t  const DHNonce *c_n,\n\t\t  const DHNonce *k_n,\n                  unsigned nonce,\n                  PA_DATA *pa,\n                  krb5_keyblock **key)\n{\n    const unsigned char *p;\n    unsigned char *dh_gen_key = NULL;\n    struct krb5_pk_cert *host = NULL;\n    BIGNUM *kdc_dh_pubkey = NULL;\n    KDCDHKeyInfo kdc_dh_info;\n    heim_oid contentType = { 0, NULL };\n    krb5_data content;\n    krb5_error_code ret;\n    int dh_gen_keylen = 0;\n    size_t size;\n\n    krb5_data_zero(&content);\n    memset(&kdc_dh_info, 0, sizeof(kdc_dh_info));\n\n    if (der_heim_oid_cmp(&asn1_oid_id_pkcs7_signedData, dataType)) {\n\tkrb5_set_error_message(context, EINVAL,\n\t\t\t       N_(\"PKINIT: Invalid content type\", \"\"));\n\treturn EINVAL;\n    }\n\n    ret = pk_verify_sign(context,\n\t\t\t indata->data,\n\t\t\t indata->length,\n\t\t\t ctx->id,\n\t\t\t &contentType,\n\t\t\t &content,\n\t\t\t &host);\n    if (ret)\n\tgoto out;\n\n    /* make sure that it is the kdc's certificate */\n    ret = pk_verify_host(context, realm, hi, ctx, host);\n    if (ret)\n\tgoto out;\n\n    if (der_heim_oid_cmp(&contentType, &asn1_oid_id_pkdhkeydata)) {\n\tret = KRB5KRB_AP_ERR_MSG_TYPE;\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"pkinit - dh reply contains wrong oid\", \"\"));\n\tgoto out;\n    }\n\n    ret = decode_KDCDHKeyInfo(content.data,\n\t\t\t      content.length,\n\t\t\t      &kdc_dh_info,\n\t\t\t      &size);\n\n    if (ret) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"pkinit - failed to decode \"\n\t\t\t\t  \"KDC DH Key Info\", \"\"));\n\tgoto out;\n    }\n\n    if (kdc_dh_info.nonce != nonce) {\n\tret = KRB5KRB_AP_ERR_MODIFIED;\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"PKINIT: DH nonce is wrong\", \"\"));\n\tgoto out;\n    }\n\n    if (kdc_dh_info.dhKeyExpiration) {\n\tif (k_n == NULL) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"pkinit; got key expiration \"\n\t\t\t\t      \"without server nonce\", \"\"));\n\t    goto out;\n\t}\n\tif (c_n == NULL) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"pkinit; got DH reuse but no \"\n\t\t\t\t      \"client nonce\", \"\"));\n\t    goto out;\n\t}\n    } else {\n\tif (k_n) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"pkinit: got server nonce \"\n\t\t\t\t      \"without key expiration\", \"\"));\n\t    goto out;\n\t}\n\tc_n = NULL;\n    }\n\n\n    p = kdc_dh_info.subjectPublicKey.data;\n    size = (kdc_dh_info.subjectPublicKey.length + 7) / 8;\n\n    if (ctx->keyex == USE_DH) {\n\tDHPublicKey k;\n\tret = decode_DHPublicKey(p, size, &k, NULL);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"pkinit: can't decode \"\n\t\t\t\t      \"without key expiration\", \"\"));\n\t    goto out;\n\t}\n\n\tkdc_dh_pubkey = integer_to_BN(context, \"DHPublicKey\", &k);\n\tfree_DHPublicKey(&k);\n\tif (kdc_dh_pubkey == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\n\n\tsize = DH_size(ctx->u.dh);\n\n\tdh_gen_key = malloc(size);\n\tif (dh_gen_key == NULL) {\n\t    ret = krb5_enomem(context);\n\t    goto out;\n\t}\n\n\tdh_gen_keylen = DH_compute_key(dh_gen_key, kdc_dh_pubkey, ctx->u.dh);\n\tif (dh_gen_keylen == -1) {\n\t    ret = KRB5KRB_ERR_GENERIC;\n\t    dh_gen_keylen = 0;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"PKINIT: Can't compute Diffie-Hellman key\", \"\"));\n\t    goto out;\n\t}\n\tif (dh_gen_keylen < (int)size) {\n\t    size -= dh_gen_keylen;\n\t    memmove(dh_gen_key + size, dh_gen_key, dh_gen_keylen);\n\t    memset(dh_gen_key, 0, size);\n\t}\n\n    } else {\n        ret = _krb5_pk_rd_pa_reply_ecdh_compute_key(context, ctx, p,\n                                                    size, &dh_gen_key,\n                                                    &dh_gen_keylen);\n        if (ret)\n          goto out;\n    }\n\n    if (dh_gen_keylen <= 0) {\n\tret = EINVAL;\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"PKINIT: resulting DH key <= 0\", \"\"));\n\tdh_gen_keylen = 0;\n\tgoto out;\n    }\n\n    *key = malloc (sizeof (**key));\n    if (*key == NULL) {\n\tret = krb5_enomem(context);\n\tgoto out;\n    }\n\n    ret = _krb5_pk_octetstring2key(context,\n\t\t\t\t   etype,\n\t\t\t\t   dh_gen_key, dh_gen_keylen,\n\t\t\t\t   c_n, k_n,\n\t\t\t\t   *key);\n    if (ret) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"PKINIT: can't create key from DH key\", \"\"));\n\tfree(*key);\n\t*key = NULL;\n\tgoto out;\n    }\n\n out:\n    if (kdc_dh_pubkey)\n\tBN_free(kdc_dh_pubkey);\n    if (dh_gen_key) {\n\tmemset(dh_gen_key, 0, dh_gen_keylen);\n\tfree(dh_gen_key);\n    }\n    if (host)\n\t_krb5_pk_cert_free(host);\n    if (content.data)\n\tkrb5_data_free(&content);\n    der_free_oid(&contentType);\n    free_KDCDHKeyInfo(&kdc_dh_info);\n\n    return ret;\n}\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\n_krb5_pk_rd_pa_reply(krb5_context context,\n\t\t     const char *realm,\n\t\t     void *c,\n\t\t     krb5_enctype etype,\n\t\t     const krb5_krbhst_info *hi,\n\t\t     unsigned nonce,\n\t\t     const krb5_data *req_buffer,\n\t\t     PA_DATA *pa,\n\t\t     krb5_keyblock **key)\n{\n    krb5_pk_init_ctx ctx = c;\n    krb5_error_code ret;\n    size_t size;\n\n    /* Check for IETF PK-INIT first */\n    if (ctx->type == PKINIT_27) {\n\tPA_PK_AS_REP rep;\n\theim_octet_string os, data;\n\theim_oid oid;\n\n\tif (pa->padata_type != KRB5_PADATA_PK_AS_REP) {\n\t    krb5_set_error_message(context, EINVAL,\n\t\t\t\t   N_(\"PKINIT: wrong padata recv\", \"\"));\n\t    return EINVAL;\n\t}\n\n\tret = decode_PA_PK_AS_REP(pa->padata_value.data,\n\t\t\t\t  pa->padata_value.length,\n\t\t\t\t  &rep,\n\t\t\t\t  &size);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"Failed to decode pkinit AS rep\", \"\"));\n\t    return ret;\n\t}\n\n\tswitch (rep.element) {\n\tcase choice_PA_PK_AS_REP_dhInfo:\n\t    _krb5_debug(context, 5, \"krb5_get_init_creds: using pkinit dh\");\n\t    os = rep.u.dhInfo.dhSignedData;\n\t    break;\n\tcase choice_PA_PK_AS_REP_encKeyPack:\n\t    _krb5_debug(context, 5, \"krb5_get_init_creds: using kinit enc reply key\");\n\t    os = rep.u.encKeyPack;\n\t    break;\n\tdefault: {\n\t    PA_PK_AS_REP_BTMM btmm;\n\t    free_PA_PK_AS_REP(&rep);\n\t    memset(&rep, 0, sizeof(rep));\n\n\t    _krb5_debug(context, 5, \"krb5_get_init_creds: using BTMM kinit enc reply key\");\n\n\t    ret = decode_PA_PK_AS_REP_BTMM(pa->padata_value.data,\n\t\t\t\t\t   pa->padata_value.length,\n\t\t\t\t\t   &btmm,\n\t\t\t\t\t   &size);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, EINVAL,\n\t\t\t\t       N_(\"PKINIT: -27 reply \"\n\t\t\t\t\t  \"invalid content type\", \"\"));\n\t\treturn EINVAL;\n\t    }\n\n\t    if (btmm.dhSignedData || btmm.encKeyPack == NULL) {\n\t\tfree_PA_PK_AS_REP_BTMM(&btmm);\n\t\tret = EINVAL;\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       N_(\"DH mode not supported for BTMM mode\", \"\"));\n\t\treturn ret;\n\t    }\n\n\t    /*\n\t     * Transform to IETF style PK-INIT reply so that free works below\n\t     */\n\n\t    rep.element = choice_PA_PK_AS_REP_encKeyPack;\n\t    rep.u.encKeyPack.data = btmm.encKeyPack->data;\n\t    rep.u.encKeyPack.length = btmm.encKeyPack->length;\n\t    btmm.encKeyPack->data = NULL;\n\t    btmm.encKeyPack->length = 0;\n\t    free_PA_PK_AS_REP_BTMM(&btmm);\n\t    os = rep.u.encKeyPack;\n\t}\n\t}\n\n\tret = hx509_cms_unwrap_ContentInfo(&os, &oid, &data, NULL);\n\tif (ret) {\n\t    free_PA_PK_AS_REP(&rep);\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"PKINIT: failed to unwrap CI\", \"\"));\n\t    return ret;\n\t}\n\n\tswitch (rep.element) {\n\tcase choice_PA_PK_AS_REP_dhInfo:\n\t    ret = pk_rd_pa_reply_dh(context, &data, &oid, realm, ctx, etype, hi,\n\t\t\t\t    ctx->clientDHNonce,\n\t\t\t\t    rep.u.dhInfo.serverDHNonce,\n\t\t\t\t    nonce, pa, key);\n\t    break;\n\tcase choice_PA_PK_AS_REP_encKeyPack:\n\t    ret = pk_rd_pa_reply_enckey(context, PKINIT_27, &data, &oid, realm,\n\t\t\t\t\tctx, etype, hi, nonce, req_buffer, pa, key);\n\t    break;\n\tdefault:\n\t    krb5_abortx(context, \"pk-init as-rep case not possible to happen\");\n\t}\n\tder_free_octet_string(&data);\n\tder_free_oid(&oid);\n\tfree_PA_PK_AS_REP(&rep);\n\n    } else if (ctx->type == PKINIT_WIN2K) {\n\tPA_PK_AS_REP_Win2k w2krep;\n\n\t/* Check for Windows encoding of the AS-REP pa data */\n\n#if 0 /* should this be ? */\n\tif (pa->padata_type != KRB5_PADATA_PK_AS_REP) {\n\t    krb5_set_error_message(context, EINVAL,\n\t\t\t\t   \"PKINIT: wrong padata recv\");\n\t    return EINVAL;\n\t}\n#endif\n\n\tmemset(&w2krep, 0, sizeof(w2krep));\n\n\tret = decode_PA_PK_AS_REP_Win2k(pa->padata_value.data,\n\t\t\t\t\tpa->padata_value.length,\n\t\t\t\t\t&w2krep,\n\t\t\t\t\t&size);\n\tif (ret) {\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"PKINIT: Failed decoding windows \"\n\t\t\t\t      \"pkinit reply %d\", \"\"), (int)ret);\n\t    return ret;\n\t}\n\n\tkrb5_clear_error_message(context);\n\n\tswitch (w2krep.element) {\n\tcase choice_PA_PK_AS_REP_Win2k_encKeyPack: {\n\t    heim_octet_string data;\n\t    heim_oid oid;\n\n\t    ret = hx509_cms_unwrap_ContentInfo(&w2krep.u.encKeyPack,\n\t\t\t\t\t       &oid, &data, NULL);\n\t    free_PA_PK_AS_REP_Win2k(&w2krep);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret,\n\t\t\t\t       N_(\"PKINIT: failed to unwrap CI\", \"\"));\n\t\treturn ret;\n\t    }\n\n\t    ret = pk_rd_pa_reply_enckey(context, PKINIT_WIN2K, &data, &oid, realm,\n\t\t\t\t\tctx, etype, hi, nonce, req_buffer, pa, key);\n\t    der_free_octet_string(&data);\n\t    der_free_oid(&oid);\n\n\t    break;\n\t}\n\tdefault:\n\t    free_PA_PK_AS_REP_Win2k(&w2krep);\n\t    ret = EINVAL;\n\t    krb5_set_error_message(context, ret,\n\t\t\t\t   N_(\"PKINIT: win2k reply invalid \"\n\t\t\t\t      \"content type\", \"\"));\n\t    break;\n\t}\n\n    } else {\n\tret = EINVAL;\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"PKINIT: unknown reply type\", \"\"));\n    }\n\n    return ret;\n}\n\nstruct prompter {\n    krb5_context context;\n    krb5_prompter_fct prompter;\n    void *prompter_data;\n};\n\nstatic int\nhx_pass_prompter(void *data, const hx509_prompt *prompter)\n{\n    krb5_error_code ret;\n    krb5_prompt prompt;\n    krb5_data password_data;\n    struct prompter *p = data;\n\n    password_data.data   = prompter->reply.data;\n    password_data.length = prompter->reply.length;\n\n    prompt.prompt = prompter->prompt;\n    prompt.hidden = hx509_prompt_hidden(prompter->type);\n    prompt.reply  = &password_data;\n\n    switch (prompter->type) {\n    case HX509_PROMPT_TYPE_INFO:\n\tprompt.type   = KRB5_PROMPT_TYPE_INFO;\n\tbreak;\n    case HX509_PROMPT_TYPE_PASSWORD:\n    case HX509_PROMPT_TYPE_QUESTION:\n    default:\n\tprompt.type   = KRB5_PROMPT_TYPE_PASSWORD;\n\tbreak;\n    }\n\n    ret = (*p->prompter)(p->context, p->prompter_data, NULL, NULL, 1, &prompt);\n    if (ret) {\n\tmemset (prompter->reply.data, 0, prompter->reply.length);\n\treturn 1;\n    }\n    return 0;\n}\n\nstatic krb5_error_code\n_krb5_pk_set_user_id(krb5_context context,\n\t\t     krb5_principal principal,\n\t\t     krb5_pk_init_ctx ctx,\n\t\t     struct hx509_certs_data *certs)\n{\n    hx509_certs c = hx509_certs_ref(certs);\n    hx509_query *q = NULL;\n    int ret;\n\n    if (ctx->id->certs)\n\thx509_certs_free(&ctx->id->certs);\n    if (ctx->id->cert) {\n\thx509_cert_free(ctx->id->cert);\n\tctx->id->cert = NULL;\n    }\n\n    ctx->id->certs = c;\n    ctx->anonymous = 0;\n\n    ret = hx509_query_alloc(context->hx509ctx, &q);\n    if (ret) {\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"Allocate query to find signing certificate\");\n\treturn ret;\n    }\n\n    hx509_query_match_option(q, HX509_QUERY_OPTION_PRIVATE_KEY);\n    hx509_query_match_option(q, HX509_QUERY_OPTION_KU_DIGITALSIGNATURE);\n\n    if (principal && strncmp(\"LKDC:SHA1.\", krb5_principal_get_realm(context, principal), 9) == 0) {\n\tctx->id->flags |= PKINIT_BTMM;\n    }\n\n    ret = find_cert(context, ctx->id, q, &ctx->id->cert);\n    hx509_query_free(context->hx509ctx, q);\n\n    if (ret == 0 && _krb5_have_debug(context, 2)) {\n\thx509_name name;\n\tchar *str, *sn;\n\theim_integer i;\n\n\tret = hx509_cert_get_subject(ctx->id->cert, &name);\n\tif (ret)\n\t    goto out;\n\n\tret = hx509_name_to_string(name, &str);\n\thx509_name_free(&name);\n\tif (ret)\n\t    goto out;\n\n\tret = hx509_cert_get_serialnumber(ctx->id->cert, &i);\n\tif (ret) {\n\t    free(str);\n\t    goto out;\n\t}\n\n\tret = der_print_hex_heim_integer(&i, &sn);\n\tder_free_heim_integer(&i);\n\tif (ret) {\n\t    free(name);\n\t    goto out;\n\t}\n\n\t_krb5_debug(context, 2, \"using cert: subject: %s sn: %s\", str, sn);\n\tfree(str);\n\tfree(sn);\n    }\n out:\n\n    return ret;\n}\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\n_krb5_pk_load_id(krb5_context context,\n\t\t struct krb5_pk_identity **ret_id,\n\t\t const char *user_id,\n\t\t const char *anchor_id,\n\t\t char * const *chain_list,\n\t\t char * const *revoke_list,\n\t\t krb5_prompter_fct prompter,\n\t\t void *prompter_data,\n\t\t char *password)\n{\n    struct krb5_pk_identity *id = NULL;\n    struct prompter p;\n    int ret;\n\n    *ret_id = NULL;\n\n    if (anchor_id == NULL) {\n\tkrb5_set_error_message(context, HEIM_PKINIT_NO_VALID_CA,\n\t\t\t       N_(\"PKINIT: No anchor given\", \"\"));\n\treturn HEIM_PKINIT_NO_VALID_CA;\n    }\n\n    /* load cert */\n\n    id = calloc(1, sizeof(*id));\n    if (id == NULL)\n\treturn krb5_enomem(context);\n\n    if (user_id) {\n\thx509_lock lock;\n\n\tret = hx509_lock_init(context->hx509ctx, &lock);\n\tif (ret) {\n\t    pk_copy_error(context, context->hx509ctx, ret, \"Failed init lock\");\n\t    goto out;\n\t}\n\n\tif (password && password[0])\n\t    hx509_lock_add_password(lock, password);\n\n\tif (prompter) {\n\t    p.context = context;\n\t    p.prompter = prompter;\n\t    p.prompter_data = prompter_data;\n\n\t    ret = hx509_lock_set_prompter(lock, hx_pass_prompter, &p);\n\t    if (ret) {\n\t\thx509_lock_free(lock);\n\t\tgoto out;\n\t    }\n\t}\n\n\tret = hx509_certs_init(context->hx509ctx, user_id, 0, lock, &id->certs);\n        hx509_lock_free(lock);\n\tif (ret) {\n\t    pk_copy_error(context, context->hx509ctx, ret,\n\t\t\t  \"Failed to init cert certs\");\n\t    goto out;\n\t}\n    } else {\n\tid->certs = NULL;\n    }\n\n    ret = hx509_certs_init(context->hx509ctx, anchor_id, 0, NULL, &id->anchors);\n    if (ret) {\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"Failed to init anchors\");\n\tgoto out;\n    }\n\n    ret = hx509_certs_init(context->hx509ctx, \"MEMORY:pkinit-cert-chain\",\n\t\t\t   0, NULL, &id->certpool);\n    if (ret) {\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"Failed to init chain\");\n\tgoto out;\n    }\n\n    while (chain_list && *chain_list) {\n\tret = hx509_certs_append(context->hx509ctx, id->certpool,\n\t\t\t\t NULL, *chain_list);\n\tif (ret) {\n\t    pk_copy_error(context, context->hx509ctx, ret,\n\t\t\t  \"Failed to laod chain %s\",\n\t\t\t  *chain_list);\n\t    goto out;\n\t}\n\tchain_list++;\n    }\n\n    if (revoke_list) {\n\tret = hx509_revoke_init(context->hx509ctx, &id->revokectx);\n\tif (ret) {\n\t    pk_copy_error(context, context->hx509ctx, ret,\n\t\t\t  \"Failed init revoke list\");\n\t    goto out;\n\t}\n\n\twhile (*revoke_list) {\n\t    ret = hx509_revoke_add_crl(context->hx509ctx,\n\t\t\t\t       id->revokectx,\n\t\t\t\t       *revoke_list);\n\t    if (ret) {\n\t\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t\t      \"Failed load revoke list\");\n\t\tgoto out;\n\t    }\n\t    revoke_list++;\n\t}\n    } else\n\thx509_context_set_missing_revoke(context->hx509ctx, 1);\n\n    ret = hx509_verify_init_ctx(context->hx509ctx, &id->verify_ctx);\n    if (ret) {\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"Failed init verify context\");\n\tgoto out;\n    }\n\n    hx509_verify_attach_anchors(id->verify_ctx, id->anchors);\n    hx509_verify_attach_revoke(id->verify_ctx, id->revokectx);\n\n out:\n    if (ret) {\n\thx509_verify_destroy_ctx(id->verify_ctx);\n\thx509_certs_free(&id->certs);\n\thx509_certs_free(&id->anchors);\n\thx509_certs_free(&id->certpool);\n\thx509_revoke_free(&id->revokectx);\n\tfree(id);\n    } else\n\t*ret_id = id;\n\n    return ret;\n}\n\n/*\n *\n */\n\nstatic void\npk_copy_error(krb5_context context,\n\t      hx509_context hx509ctx,\n\t      int hxret,\n\t      const char *fmt,\n\t      ...)\n{\n    va_list va;\n    char *s, *f;\n    int ret;\n\n    va_start(va, fmt);\n    ret = vasprintf(&f, fmt, va);\n    va_end(va);\n    if (ret == -1 || f == NULL) {\n\tkrb5_clear_error_message(context);\n\treturn;\n    }\n\n    s = hx509_get_error_string(hx509ctx, hxret);\n    if (s == NULL) {\n\tkrb5_clear_error_message(context);\n\tfree(f);\n\treturn;\n    }\n    krb5_set_error_message(context, hxret, \"%s: %s\", f, s);\n    free(s);\n    free(f);\n}\n\nstatic int\nparse_integer(krb5_context context, char **p, const char *file, int lineno,\n\t      const char *name, heim_integer *integer)\n{\n    int ret;\n    char *p1;\n    p1 = strsep(p, \" \\t\");\n    if (p1 == NULL) {\n\tkrb5_set_error_message(context, EINVAL,\n\t\t\t       N_(\"moduli file %s missing %s on line %d\", \"\"),\n\t\t\t       file, name, lineno);\n\treturn EINVAL;\n    }\n    ret = der_parse_hex_heim_integer(p1, integer);\n    if (ret) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"moduli file %s failed parsing %s \"\n\t\t\t\t  \"on line %d\", \"\"),\n\t\t\t       file, name, lineno);\n\treturn ret;\n    }\n\n    return 0;\n}\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\n_krb5_parse_moduli_line(krb5_context context,\n\t\t\tconst char *file,\n\t\t\tint lineno,\n\t\t\tchar *p,\n\t\t\tstruct krb5_dh_moduli **m)\n{\n    struct krb5_dh_moduli *m1;\n    char *p1;\n    int ret;\n\n    *m = NULL;\n\n    m1 = calloc(1, sizeof(*m1));\n    if (m1 == NULL)\n\treturn krb5_enomem(context);\n\n    while (isspace((unsigned char)*p))\n\tp++;\n    if (*p  == '#') {\n        free(m1);\n\treturn 0;\n    }\n    ret = EINVAL;\n\n    p1 = strsep(&p, \" \\t\");\n    if (p1 == NULL) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"moduli file %s missing name on line %d\", \"\"),\n\t\t\t       file, lineno);\n\tgoto out;\n    }\n    m1->name = strdup(p1);\n    if (m1->name == NULL) {\n\tret = krb5_enomem(context);\n\tgoto out;\n    }\n\n    p1 = strsep(&p, \" \\t\");\n    if (p1 == NULL) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"moduli file %s missing bits on line %d\", \"\"),\n\t\t\t       file, lineno);\n\tgoto out;\n    }\n\n    m1->bits = atoi(p1);\n    if (m1->bits == 0) {\n\tkrb5_set_error_message(context, ret,\n\t\t\t       N_(\"moduli file %s have un-parsable \"\n\t\t\t\t  \"bits on line %d\", \"\"), file, lineno);\n\tgoto out;\n    }\n\n    ret = parse_integer(context, &p, file, lineno, \"p\", &m1->p);\n    if (ret)\n\tgoto out;\n    ret = parse_integer(context, &p, file, lineno, \"g\", &m1->g);\n    if (ret)\n\tgoto out;\n    ret = parse_integer(context, &p, file, lineno, \"q\", &m1->q);\n    if (ret)\n\tgoto out;\n\n    *m = m1;\n\n    return 0;\n out:\n    free(m1->name);\n    der_free_heim_integer(&m1->p);\n    der_free_heim_integer(&m1->g);\n    der_free_heim_integer(&m1->q);\n    free(m1);\n    return ret;\n}\n\nKRB5_LIB_FUNCTION void KRB5_LIB_CALL\n_krb5_free_moduli(struct krb5_dh_moduli **moduli)\n{\n    int i;\n    for (i = 0; moduli[i] != NULL; i++) {\n\tfree(moduli[i]->name);\n\tder_free_heim_integer(&moduli[i]->p);\n\tder_free_heim_integer(&moduli[i]->g);\n\tder_free_heim_integer(&moduli[i]->q);\n\tfree(moduli[i]);\n    }\n    free(moduli);\n}\n\nstatic const char *default_moduli_RFC2412_MODP_group2 =\n    /* name */\n    \"RFC2412-MODP-group2 \"\n    /* bits */\n    \"1024 \"\n    /* p */\n    \"FFFFFFFF\" \"FFFFFFFF\" \"C90FDAA2\" \"2168C234\" \"C4C6628B\" \"80DC1CD1\"\n    \"29024E08\" \"8A67CC74\" \"020BBEA6\" \"3B139B22\" \"514A0879\" \"8E3404DD\"\n    \"EF9519B3\" \"CD3A431B\" \"302B0A6D\" \"F25F1437\" \"4FE1356D\" \"6D51C245\"\n    \"E485B576\" \"625E7EC6\" \"F44C42E9\" \"A637ED6B\" \"0BFF5CB6\" \"F406B7ED\"\n    \"EE386BFB\" \"5A899FA5\" \"AE9F2411\" \"7C4B1FE6\" \"49286651\" \"ECE65381\"\n    \"FFFFFFFF\" \"FFFFFFFF \"\n    /* g */\n    \"02 \"\n    /* q */\n    \"7FFFFFFF\" \"FFFFFFFF\" \"E487ED51\" \"10B4611A\" \"62633145\" \"C06E0E68\"\n    \"94812704\" \"4533E63A\" \"0105DF53\" \"1D89CD91\" \"28A5043C\" \"C71A026E\"\n    \"F7CA8CD9\" \"E69D218D\" \"98158536\" \"F92F8A1B\" \"A7F09AB6\" \"B6A8E122\"\n    \"F242DABB\" \"312F3F63\" \"7A262174\" \"D31BF6B5\" \"85FFAE5B\" \"7A035BF6\"\n    \"F71C35FD\" \"AD44CFD2\" \"D74F9208\" \"BE258FF3\" \"24943328\" \"F67329C0\"\n    \"FFFFFFFF\" \"FFFFFFFF\";\n\nstatic const char *default_moduli_rfc3526_MODP_group14 =\n    /* name */\n    \"rfc3526-MODP-group14 \"\n    /* bits */\n    \"1760 \"\n    /* p */\n    \"FFFFFFFF\" \"FFFFFFFF\" \"C90FDAA2\" \"2168C234\" \"C4C6628B\" \"80DC1CD1\"\n    \"29024E08\" \"8A67CC74\" \"020BBEA6\" \"3B139B22\" \"514A0879\" \"8E3404DD\"\n    \"EF9519B3\" \"CD3A431B\" \"302B0A6D\" \"F25F1437\" \"4FE1356D\" \"6D51C245\"\n    \"E485B576\" \"625E7EC6\" \"F44C42E9\" \"A637ED6B\" \"0BFF5CB6\" \"F406B7ED\"\n    \"EE386BFB\" \"5A899FA5\" \"AE9F2411\" \"7C4B1FE6\" \"49286651\" \"ECE45B3D\"\n    \"C2007CB8\" \"A163BF05\" \"98DA4836\" \"1C55D39A\" \"69163FA8\" \"FD24CF5F\"\n    \"83655D23\" \"DCA3AD96\" \"1C62F356\" \"208552BB\" \"9ED52907\" \"7096966D\"\n    \"670C354E\" \"4ABC9804\" \"F1746C08\" \"CA18217C\" \"32905E46\" \"2E36CE3B\"\n    \"E39E772C\" \"180E8603\" \"9B2783A2\" \"EC07A28F\" \"B5C55DF0\" \"6F4C52C9\"\n    \"DE2BCBF6\" \"95581718\" \"3995497C\" \"EA956AE5\" \"15D22618\" \"98FA0510\"\n    \"15728E5A\" \"8AACAA68\" \"FFFFFFFF\" \"FFFFFFFF \"\n    /* g */\n    \"02 \"\n    /* q */\n    \"7FFFFFFF\" \"FFFFFFFF\" \"E487ED51\" \"10B4611A\" \"62633145\" \"C06E0E68\"\n    \"94812704\" \"4533E63A\" \"0105DF53\" \"1D89CD91\" \"28A5043C\" \"C71A026E\"\n    \"F7CA8CD9\" \"E69D218D\" \"98158536\" \"F92F8A1B\" \"A7F09AB6\" \"B6A8E122\"\n    \"F242DABB\" \"312F3F63\" \"7A262174\" \"D31BF6B5\" \"85FFAE5B\" \"7A035BF6\"\n    \"F71C35FD\" \"AD44CFD2\" \"D74F9208\" \"BE258FF3\" \"24943328\" \"F6722D9E\"\n    \"E1003E5C\" \"50B1DF82\" \"CC6D241B\" \"0E2AE9CD\" \"348B1FD4\" \"7E9267AF\"\n    \"C1B2AE91\" \"EE51D6CB\" \"0E3179AB\" \"1042A95D\" \"CF6A9483\" \"B84B4B36\"\n    \"B3861AA7\" \"255E4C02\" \"78BA3604\" \"650C10BE\" \"19482F23\" \"171B671D\"\n    \"F1CF3B96\" \"0C074301\" \"CD93C1D1\" \"7603D147\" \"DAE2AEF8\" \"37A62964\"\n    \"EF15E5FB\" \"4AAC0B8C\" \"1CCAA4BE\" \"754AB572\" \"8AE9130C\" \"4C7D0288\"\n    \"0AB9472D\" \"45565534\" \"7FFFFFFF\" \"FFFFFFFF\";\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\n_krb5_parse_moduli(krb5_context context, const char *file,\n\t\t   struct krb5_dh_moduli ***moduli)\n{\n    /* name bits P G Q */\n    krb5_error_code ret;\n    struct krb5_dh_moduli **m = NULL, **m2;\n    char buf[4096];\n    FILE *f;\n    int lineno = 0, n = 0;\n\n    *moduli = NULL;\n\n    m = calloc(1, sizeof(m[0]) * 3);\n    if (m == NULL)\n\treturn krb5_enomem(context);\n\n    strlcpy(buf, default_moduli_rfc3526_MODP_group14, sizeof(buf));\n    ret = _krb5_parse_moduli_line(context, \"builtin\", 1, buf,  &m[0]);\n    if (ret) {\n\t_krb5_free_moduli(m);\n\treturn ret;\n    }\n    n++;\n\n    strlcpy(buf, default_moduli_RFC2412_MODP_group2, sizeof(buf));\n    ret = _krb5_parse_moduli_line(context, \"builtin\", 1, buf,  &m[1]);\n    if (ret) {\n\t_krb5_free_moduli(m);\n\treturn ret;\n    }\n    n++;\n\n\n    if (file == NULL)\n\tfile = MODULI_FILE;\n\n#ifdef KRB5_USE_PATH_TOKENS\n    {\n        char * exp_file;\n\n\tif (_krb5_expand_path_tokens(context, file, 1, &exp_file) == 0) {\n            f = fopen(exp_file, \"r\");\n            krb5_xfree(exp_file);\n        } else {\n            f = NULL;\n        }\n    }\n#else\n    f = fopen(file, \"r\");\n#endif\n\n    if (f == NULL) {\n\t*moduli = m;\n\treturn 0;\n    }\n    rk_cloexec_file(f);\n\n    while(fgets(buf, sizeof(buf), f) != NULL) {\n\tstruct krb5_dh_moduli *element;\n\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tlineno++;\n\n\tm2 = realloc(m, (n + 2) * sizeof(m[0]));\n\tif (m2 == NULL) {\n\t    _krb5_free_moduli(m);\n\t    return krb5_enomem(context);\n\t}\n\tm = m2;\n\n\tm[n] = NULL;\n\n\tret = _krb5_parse_moduli_line(context, file, lineno, buf,  &element);\n\tif (ret) {\n\t    _krb5_free_moduli(m);\n\t    return ret;\n\t}\n\tif (element == NULL)\n\t    continue;\n\n\tm[n] = element;\n\tm[n + 1] = NULL;\n\tn++;\n    }\n    *moduli = m;\n    return 0;\n}\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\n_krb5_dh_group_ok(krb5_context context, unsigned long bits,\n\t\t  heim_integer *p, heim_integer *g, heim_integer *q,\n\t\t  struct krb5_dh_moduli **moduli,\n\t\t  char **name)\n{\n    int i;\n\n    if (name)\n\t*name = NULL;\n\n    for (i = 0; moduli[i] != NULL; i++) {\n\tif (der_heim_integer_cmp(&moduli[i]->g, g) == 0 &&\n\t    der_heim_integer_cmp(&moduli[i]->p, p) == 0 &&\n\t    (q == NULL || der_heim_integer_cmp(&moduli[i]->q, q) == 0))\n\t    {\n\t\tif (bits && bits > moduli[i]->bits) {\n\t\t    krb5_set_error_message(context,\n\t\t\t\t\t   KRB5_KDC_ERR_DH_KEY_PARAMETERS_NOT_ACCEPTED,\n\t\t\t\t\t   N_(\"PKINIT: DH group parameter %s \"\n\t\t\t\t\t      \"no accepted, not enough bits \"\n\t\t\t\t\t      \"generated\", \"\"),\n\t\t\t\t\t   moduli[i]->name);\n\t\t    return KRB5_KDC_ERR_DH_KEY_PARAMETERS_NOT_ACCEPTED;\n\t\t}\n\t\tif (name)\n\t\t    *name = strdup(moduli[i]->name);\n\t\treturn 0;\n\t    }\n    }\n    krb5_set_error_message(context,\n\t\t\t   KRB5_KDC_ERR_DH_KEY_PARAMETERS_NOT_ACCEPTED,\n\t\t\t   N_(\"PKINIT: DH group parameter no ok\", \"\"));\n    return KRB5_KDC_ERR_DH_KEY_PARAMETERS_NOT_ACCEPTED;\n}\n#endif /* PKINIT */\n\nKRB5_LIB_FUNCTION void KRB5_LIB_CALL\n_krb5_get_init_creds_opt_free_pkinit(krb5_get_init_creds_opt *opt)\n{\n#ifdef PKINIT\n    krb5_pk_init_ctx ctx;\n\n    if (opt->opt_private == NULL || opt->opt_private->pk_init_ctx == NULL)\n\treturn;\n    ctx = opt->opt_private->pk_init_ctx;\n    switch (ctx->keyex) {\n    case USE_DH:\n\tif (ctx->u.dh)\n\t    DH_free(ctx->u.dh);\n\tbreak;\n    case USE_RSA:\n\tbreak;\n    case USE_ECDH:\n\tif (ctx->u.eckey)\n            _krb5_pk_eckey_free(ctx->u.eckey);\n\tbreak;\n    }\n    if (ctx->id) {\n\thx509_verify_destroy_ctx(ctx->id->verify_ctx);\n\thx509_certs_free(&ctx->id->certs);\n\thx509_cert_free(ctx->id->cert);\n\thx509_certs_free(&ctx->id->anchors);\n\thx509_certs_free(&ctx->id->certpool);\n\n\tif (ctx->clientDHNonce) {\n\t    krb5_free_data(NULL, ctx->clientDHNonce);\n\t    ctx->clientDHNonce = NULL;\n\t}\n\tif (ctx->m)\n\t    _krb5_free_moduli(ctx->m);\n\tfree(ctx->id);\n\tctx->id = NULL;\n    }\n    free(opt->opt_private->pk_init_ctx);\n    opt->opt_private->pk_init_ctx = NULL;\n#endif\n}\n\nKRB5_LIB_FUNCTION krb5_error_code KRB5_LIB_CALL\nkrb5_get_init_creds_opt_set_pkinit(krb5_context context,\n\t\t\t\t   krb5_get_init_creds_opt *opt,\n\t\t\t\t   krb5_principal principal,\n\t\t\t\t   const char *user_id,\n\t\t\t\t   const char *x509_anchors,\n\t\t\t\t   char * const * pool,\n\t\t\t\t   char * const * pki_revoke,\n\t\t\t\t   int flags,\n\t\t\t\t   krb5_prompter_fct prompter,\n\t\t\t\t   void *prompter_data,\n\t\t\t\t   char *password)\n{\n#ifdef PKINIT\n    krb5_error_code ret;\n    char *anchors = NULL;\n\n    if (opt->opt_private == NULL) {\n\tkrb5_set_error_message(context, EINVAL,\n\t\t\t       N_(\"PKINIT: on non extendable opt\", \"\"));\n\treturn EINVAL;\n    }\n\n    opt->opt_private->pk_init_ctx =\n\tcalloc(1, sizeof(*opt->opt_private->pk_init_ctx));\n    if (opt->opt_private->pk_init_ctx == NULL)\n\treturn krb5_enomem(context);\n    opt->opt_private->pk_init_ctx->require_binding = 0;\n    opt->opt_private->pk_init_ctx->require_eku = 1;\n    opt->opt_private->pk_init_ctx->require_krbtgt_otherName = 1;\n    opt->opt_private->pk_init_ctx->peer = NULL;\n\n    /* XXX implement krb5_appdefault_strings  */\n    if (pool == NULL)\n\tpool = krb5_config_get_strings(context, NULL,\n\t\t\t\t       \"appdefaults\",\n\t\t\t\t       \"pkinit_pool\",\n\t\t\t\t       NULL);\n\n    if (pki_revoke == NULL)\n\tpki_revoke = krb5_config_get_strings(context, NULL,\n\t\t\t\t\t     \"appdefaults\",\n\t\t\t\t\t     \"pkinit_revoke\",\n\t\t\t\t\t     NULL);\n\n    if (x509_anchors == NULL) {\n\tkrb5_appdefault_string(context, \"kinit\",\n\t\t\t       krb5_principal_get_realm(context, principal),\n\t\t\t       \"pkinit_anchors\", NULL, &anchors);\n\tx509_anchors = anchors;\n    }\n\n    if (flags & KRB5_GIC_OPT_PKINIT_ANONYMOUS)\n\topt->opt_private->pk_init_ctx->anonymous = 1;\n\n    ret = _krb5_pk_load_id(context,\n\t\t\t   &opt->opt_private->pk_init_ctx->id,\n\t\t\t   user_id,\n\t\t\t   x509_anchors,\n\t\t\t   pool,\n\t\t\t   pki_revoke,\n\t\t\t   prompter,\n\t\t\t   prompter_data,\n\t\t\t   password);\n    if (ret) {\n\tfree(opt->opt_private->pk_init_ctx);\n\topt->opt_private->pk_init_ctx = NULL;\n\treturn ret;\n    }\n\n    if (opt->opt_private->pk_init_ctx->id->certs) {\n\t_krb5_pk_set_user_id(context,\n\t\t\t     principal,\n\t\t\t     opt->opt_private->pk_init_ctx,\n\t\t\t     opt->opt_private->pk_init_ctx->id->certs);\n    } else\n\topt->opt_private->pk_init_ctx->id->cert = NULL;\n\n    if ((flags & KRB5_GIC_OPT_PKINIT_USE_ENCKEY) == 0) {\n\thx509_context hx509ctx = context->hx509ctx;\n\thx509_cert cert = opt->opt_private->pk_init_ctx->id->cert;\n\n\topt->opt_private->pk_init_ctx->keyex = USE_DH;\n\n\t/*\n\t * If its a ECDSA certs, lets select ECDSA as the keyex algorithm.\n\t */\n\tif (cert) {\n\t    AlgorithmIdentifier alg;\n\n\t    ret = hx509_cert_get_SPKI_AlgorithmIdentifier(hx509ctx, cert, &alg);\n\t    if (ret == 0) {\n\t\tif (der_heim_oid_cmp(&alg.algorithm, &asn1_oid_id_ecPublicKey) == 0)\n\t\t    opt->opt_private->pk_init_ctx->keyex = USE_ECDH;\n\t\tfree_AlgorithmIdentifier(&alg);\n\t    }\n\t}\n\n    } else {\n\topt->opt_private->pk_init_ctx->keyex = USE_RSA;\n\n\tif (opt->opt_private->pk_init_ctx->id->certs == NULL) {\n\t    krb5_set_error_message(context, EINVAL,\n\t\t\t\t   N_(\"No anonymous pkinit support in RSA mode\", \"\"));\n\t    return EINVAL;\n\t}\n    }\n\n    return 0;\n#else\n    krb5_set_error_message(context, EINVAL,\n\t\t\t   N_(\"no support for PKINIT compiled in\", \"\"));\n    return EINVAL;\n#endif\n}\n\nkrb5_error_code KRB5_LIB_FUNCTION\nkrb5_get_init_creds_opt_set_pkinit_user_certs(krb5_context context,\n\t\t\t\t\t      krb5_get_init_creds_opt *opt,\n\t\t\t\t\t      struct hx509_certs_data *certs)\n{\n#ifdef PKINIT\n    if (opt->opt_private == NULL) {\n\tkrb5_set_error_message(context, EINVAL,\n\t\t\t       N_(\"PKINIT: on non extendable opt\", \"\"));\n\treturn EINVAL;\n    }\n    if (opt->opt_private->pk_init_ctx == NULL) {\n\tkrb5_set_error_message(context, EINVAL,\n\t\t\t       N_(\"PKINIT: on pkinit context\", \"\"));\n\treturn EINVAL;\n    }\n\n    _krb5_pk_set_user_id(context, NULL, opt->opt_private->pk_init_ctx, certs);\n\n    return 0;\n#else\n    krb5_set_error_message(context, EINVAL,\n\t\t\t   N_(\"no support for PKINIT compiled in\", \"\"));\n    return EINVAL;\n#endif\n}\n\n#ifdef PKINIT\n\nstatic int\nget_ms_san(hx509_context context, hx509_cert cert, char **upn)\n{\n    hx509_octet_string_list list;\n    int ret;\n\n    *upn = NULL;\n\n    ret = hx509_cert_find_subjectAltName_otherName(context,\n\t\t\t\t\t\t   cert,\n\t\t\t\t\t\t   &asn1_oid_id_pkinit_ms_san,\n\t\t\t\t\t\t   &list);\n    if (ret)\n\treturn 0;\n\n    if (list.len > 0 && list.val[0].length > 0)\n\tret = decode_MS_UPN_SAN(list.val[0].data, list.val[0].length,\n\t\t\t\tupn, NULL);\n    else\n\tret = 1;\n    hx509_free_octet_string_list(&list);\n\n    return ret;\n}\n\nstatic int\nfind_ms_san(hx509_context context, hx509_cert cert, void *ctx)\n{\n    char *upn;\n    int ret;\n\n    ret = get_ms_san(context, cert, &upn);\n    if (ret == 0)\n\tfree(upn);\n    return ret;\n}\n\n\n\n#endif\n\n/*\n * Private since it need to be redesigned using krb5_get_init_creds()\n */\n\nKRB5_LIB_FUNCTION krb5_error_code  KRB5_LIB_CALL\nkrb5_pk_enterprise_cert(krb5_context context,\n\t\t\tconst char *user_id,\n\t\t\tkrb5_const_realm realm,\n\t\t\tkrb5_principal *principal,\n\t\t\tstruct hx509_certs_data **res)\n{\n#ifdef PKINIT\n    krb5_error_code ret;\n    hx509_certs certs, result;\n    hx509_cert cert = NULL;\n    hx509_query *q;\n    char *name;\n\n    *principal = NULL;\n    if (res)\n\t*res = NULL;\n\n    if (user_id == NULL) {\n\tkrb5_set_error_message(context, ENOENT, \"no user id\");\n\treturn ENOENT;\n    }\n\n    ret = hx509_certs_init(context->hx509ctx, user_id, 0, NULL, &certs);\n    if (ret) {\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"Failed to init cert certs\");\n\tgoto out;\n    }\n\n    ret = hx509_query_alloc(context->hx509ctx, &q);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"out of memory\");\n\thx509_certs_free(&certs);\n\tgoto out;\n    }\n\n    hx509_query_match_option(q, HX509_QUERY_OPTION_PRIVATE_KEY);\n    hx509_query_match_option(q, HX509_QUERY_OPTION_KU_DIGITALSIGNATURE);\n    hx509_query_match_eku(q, &asn1_oid_id_pkinit_ms_eku);\n    hx509_query_match_cmp_func(q, find_ms_san, NULL);\n\n    ret = hx509_certs_filter(context->hx509ctx, certs, q, &result);\n    hx509_query_free(context->hx509ctx, q);\n    hx509_certs_free(&certs);\n    if (ret) {\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"Failed to find PKINIT certificate\");\n\treturn ret;\n    }\n\n    ret = hx509_get_one_cert(context->hx509ctx, result, &cert);\n    hx509_certs_free(&result);\n    if (ret) {\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"Failed to get one cert\");\n\tgoto out;\n    }\n\n    ret = get_ms_san(context->hx509ctx, cert, &name);\n    if (ret) {\n\tpk_copy_error(context, context->hx509ctx, ret,\n\t\t      \"Failed to get MS SAN\");\n\tgoto out;\n    }\n\n    ret = krb5_make_principal(context, principal, realm, name, NULL);\n    free(name);\n    if (ret)\n\tgoto out;\n\n    krb5_principal_set_type(context, *principal, KRB5_NT_ENTERPRISE_PRINCIPAL);\n\n    if (res) {\n\tret = hx509_certs_init(context->hx509ctx, \"MEMORY:\", 0, NULL, res);\n\tif (ret)\n\t    goto out;\n\n\tret = hx509_certs_add(context->hx509ctx, *res, cert);\n\tif (ret) {\n\t    hx509_certs_free(res);\n\t    goto out;\n\t}\n    }\n\n out:\n    hx509_cert_free(cert);\n\n    return ret;\n#else\n    krb5_set_error_message(context, EINVAL,\n\t\t\t   N_(\"no support for PKINIT compiled in\", \"\"));\n    return EINVAL;\n#endif\n}\n"], "filenames": ["lib/krb5/init_creds_pw.c", "lib/krb5/krb5_locl.h", "lib/krb5/pkinit.c"], "buggy_code_start_loc": [2269, 210, 1222], "buggy_code_end_loc": [2269, 210, 1222], "fixing_code_start_loc": [2270, 211, 1223], "fixing_code_end_loc": [2290, 212, 1315], "type": "NVD-CWE-noinfo", "message": "In the client side of Heimdal before 7.6.0, failure to verify anonymous PKINIT PA-PKINIT-KX key exchange permits a man-in-the-middle attack. This issue is in krb5_init_creds_step in lib/krb5/init_creds_pw.c.", "other": {"cve": {"id": "CVE-2019-12098", "sourceIdentifier": "cve@mitre.org", "published": "2019-05-15T23:29:00.277", "lastModified": "2022-04-22T20:10:49.620", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the client side of Heimdal before 7.6.0, failure to verify anonymous PKINIT PA-PKINIT-KX key exchange permits a man-in-the-middle attack. This issue is in krb5_init_creds_step in lib/krb5/init_creds_pw.c."}, {"lang": "es", "value": "En el lado del cliente de Heimdal anterior de la versi\u00f3n 7.6.0, el fallo  en la comprobaci\u00f3n an\u00f3nima del intercambio de claves PKINIT PA-PKINIT-KX permite un ataque de tipo  man-in-the-middle. Este problema est\u00e1 en krb5_init_creds_step en lib/krb5/init_creds_pw.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:heimdal_project:heimdal:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.6.0", "matchCriteriaId": "DB459E43-4BE7-4A64-A902-F0E235FE2AF5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensuse:backports_sle:15.0:-:*:*:*:*:*:*", "matchCriteriaId": "D83DA865-E4A6-4FBF-AA1B-A969EBA6B2AD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensuse:backports_sle:15.0:sp1:*:*:*:*:*:*", "matchCriteriaId": "40513095-7E6E-46B3-B604-C926F1BA3568"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.3:*:*:*:*:*:*:*", "matchCriteriaId": "5F65DAB0-3DAD-49FF-BC73-3581CC3D5BF3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-07/msg00002.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-07/msg00003.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00026.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.h5l.org/pipermail/heimdal-announce/2019-May/000009.html", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/heimdal/heimdal/commit/2f7f3d9960aa6ea21358bdf3687cee5149aa35cf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/heimdal/heimdal/compare/3e58559...bbafe72", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/heimdal/heimdal/releases/tag/heimdal-7.6.0", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GIXEDVVMPD6ZAJSMI2EZ7FNEIVNWE5PD/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/SLXXIF4LOQEAEDAF4UGP2AO6WDNTDFUB/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/Jun/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2019/dsa-4455", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/heimdal/heimdal/commit/2f7f3d9960aa6ea21358bdf3687cee5149aa35cf"}}