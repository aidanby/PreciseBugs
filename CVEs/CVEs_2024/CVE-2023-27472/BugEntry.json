{"buggy_code": ["<script lang=\"ts\">\n\timport jQuery from \"jquery\"\n\timport \"jstree\"\n\timport \"./treeview.css\"\n\n\timport type { Entity } from \"$lib/quickentity-types\"\n\timport { getReferencedLocalEntity } from \"$lib/utils\"\n\n\timport { createEventDispatcher, onMount } from \"svelte\"\n\timport { v4 } from \"uuid\"\n\timport json from \"$lib/json\"\n\timport isEqual from \"lodash/isEqual\"\n\n\texport let entity: Entity\n\texport let reverseReferences: Record<\n\t\tstring,\n\t\t{\n\t\t\ttype: string\n\t\t\tentity: string\n\t\t\tcontext?: string[]\n\t\t}[]\n\t>\n\n\texport let currentlySelected: string = null!\n\n\texport const elemID = \"tree-\" + v4().replaceAll(\"-\", \"\")\n\n\texport let tree: JSTree = null!\n\n\tconst dispatch = createEventDispatcher()\n\n\tconst icons = Object.entries({\n\t\t\"[assembly:/templates/gameplay/ai2/actors.template?/npcactor.entitytemplate].pc_entitytype\": \"far fa-user\",\n\t\t\"[assembly:/_pro/characters/templates/hero/agent47/agent47.template?/agent47_default.entitytemplate].pc_entitytype\": \"far fa-user-circle\",\n\t\t\"[assembly:/_pro/design/levelflow.template?/herospawn.entitytemplate].pc_entitytype\": \"far fa-user-circle\",\n\t\t\"[modules:/zglobaloutfitkit.class].pc_entitytype\": \"fas fa-tshirt\",\n\t\t\"[modules:/zroomentity.class].pc_entitytype\": \"fas fa-map-marker-alt\",\n\t\t\"[modules:/zboxvolumeentity.class].pc_entitytype\": \"far fa-square\",\n\t\t\"[modules:/zsoundbankentity.class].pc_entitytype\": \"fas fa-music\",\n\t\t\"[modules:/zcameraentity.class].pc_entitytype\": \"fas fa-camera\",\n\t\t\"[modules:/zsequenceentity.class].pc_entitytype\": \"fas fa-film\",\n\t\t\"[modules:/zhitmandamageovertime.class].pc_entitytype\": \"fas fa-skull-crossbones\",\n\t\t\"0059FBD4AEBCDED0\": \"far fa-comment\", // Hashes\n\n\t\t\"levelflow.template?/exit\": \"fas fa-sign-out-alt\",\n\t\tzitem: \"fas fa-wrench\", // Specific\n\n\t\tblockup: \"fas fa-cube\",\n\t\tsetpiece_container_body: \"fas fa-box-open\",\n\t\tsetpiece_trap: \"fas fa-skull-crossbones\",\n\t\tanimset: \"fas fa-running\",\n\t\temitter: \"fas fa-wifi\",\n\t\tsender: \"fas fa-wifi\",\n\t\tevent: \"fas fa-location-arrow\",\n\t\tdeath: \"fas fa-skull\",\n\t\tzone: \"far fa-square\", // Types\n\n\t\t\"foliage/\": \"fas fa-seedling\",\n\t\t\"vehicles/\": \"fas fa-car-side\",\n\t\t\"environment/\": \"far fa-map\",\n\t\t\"logic/\": \"fas fa-cogs\",\n\t\t\"design/\": \"fas fa-swatchbook\",\n\t\t\"modules:/\": \"fas fa-project-diagram\" // Paths\n\t})\n\n\tonMount(async () => {\n\t\tjQuery(\"#\" + elemID).jstree({\n\t\t\tcore: {\n\t\t\t\tmultiple: false,\n\t\t\t\tdata: [],\n\t\t\t\tthemes: {\n\t\t\t\t\tname: \"default\",\n\t\t\t\t\tdots: true,\n\t\t\t\t\ticons: true\n\t\t\t\t},\n\t\t\t\tcheck_callback: true\n\t\t\t},\n\t\t\tsearch: {\n\t\t\t\tfuzzy: true,\n\t\t\t\tshow_only_matches: true,\n\t\t\t\tclose_opened_onclear: false,\n\t\t\t\tsearch_callback: (search: string, node: { id: string }) => {\n\t\t\t\t\tif (search.startsWith(\":\")) {\n\t\t\t\t\t\tif (entity.entities[node.id]) {\n\t\t\t\t\t\t\treturn eval(search.slice(1))({ ...entity.entities[node.id], id: node.id })\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn (json.stringify(entity.entities[node.id] || entity.comments[Number(node.id.split(\"-\")[1])]) + node.id).toLowerCase().includes(search)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tsort: function (a: any, b: any) {\n\t\t\t\tif (\n\t\t\t\t\t(!(this.get_node(a).original ? this.get_node(a).original : this.get_node(a)).folder && !(this.get_node(b).original ? this.get_node(b).original : this.get_node(b)).folder) ||\n\t\t\t\t\t((this.get_node(a).original ? this.get_node(a).original : this.get_node(a)).folder && (this.get_node(b).original ? this.get_node(b).original : this.get_node(b)).folder)\n\t\t\t\t) {\n\t\t\t\t\treturn this.get_text(a).localeCompare(this.get_text(b), undefined, { numeric: true, sensitivity: \"base\" }) > 0 ? 1 : -1\n\t\t\t\t} else {\n\t\t\t\t\treturn (this.get_node(a).original ? this.get_node(a).original : this.get_node(a)).folder ? -1 : 1\n\t\t\t\t}\n\t\t\t},\n\t\t\tcontextmenu: {\n\t\t\t\tselect_node: false,\n\t\t\t\titems: (b: { id: string }, c: any) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\trename: {\n\t\t\t\t\t\t\tseparator_before: false,\n\t\t\t\t\t\t\tseparator_after: false,\n\t\t\t\t\t\t\t_disabled: false,\n\t\t\t\t\t\t\tlabel: \"Rename\",\n\t\t\t\t\t\t\ticon: \"far fa-pen-to-square\",\n\t\t\t\t\t\t\taction: function (b: { reference: string | HTMLElement | JQuery<HTMLElement> }) {\n\t\t\t\t\t\t\t\tvar c = jQuery.jstree!.reference(b.reference),\n\t\t\t\t\t\t\t\t\td = c.get_node(b.reference)\n\t\t\t\t\t\t\t\tc.edit(d)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tplugins: [\"contextmenu\", \"search\", \"sort\"]\n\t\t})\n\n\t\ttree = jQuery(\"#\" + elemID).jstree()\n\n\t\tjQuery(\"#\" + elemID).on(\"changed.jstree\", (...data) => {\n\t\t\tif (data[1].action == \"select_node\" && data[1].node.id != currentlySelected) {\n\t\t\t\tcurrentlySelected = data[1].node.id\n\t\t\t\tdispatch(\"selectionUpdate\", data)\n\t\t\t}\n\t\t})\n\t\tjQuery(\"#\" + elemID).on(\"rename_node.jstree\", (...data) => dispatch(\"nodeRenamed\", data))\n\t})\n\n\texport function refreshTree(\n\t\tentity: Entity,\n\t\treverseReferences: Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\ttype: string\n\t\t\t\tentity: string\n\t\t\t\tcontext?: string[]\n\t\t\t}[]\n\t\t>\n\t) {\n\t\ttree.settings!.core.data = []\n\n\t\tfor (let [entityID, entityData] of Object.entries(entity.entities)) {\n\t\t\ttree.settings!.core.data.push({\n\t\t\t\tid: String(entityID),\n\t\t\t\tparent: getReferencedLocalEntity(entityData.parent) || \"#\",\n\t\t\t\ticon:\n\t\t\t\t\tentityData.factory == \"[modules:/zentity.class].pc_entitytype\" && reverseReferences[entityID].some((a) => a.type == \"parent\")\n\t\t\t\t\t\t? \"far fa-folder\"\n\t\t\t\t\t\t: icons.find((a) => entityData.factory.includes(a[0]))\n\t\t\t\t\t\t? icons.find((a) => entityData.factory.includes(a[0]))![1]\n\t\t\t\t\t\t: \"far fa-file\",\n\t\t\t\ttext: `${entityData.name} (ref ${entityID})`,\n\t\t\t\tfolder: entityData.factory == \"[modules:/zentity.class].pc_entitytype\" && reverseReferences[entityID].some((a) => a.type == \"parent\") // for sorting and stuff\n\t\t\t})\n\t\t}\n\n\t\tlet index = 0\n\t\tfor (let entry of entity.comments) {\n\t\t\ttree.settings!.core.data.push({\n\t\t\t\tid: \"comment-\" + index,\n\t\t\t\tparent: getReferencedLocalEntity(entry.parent) || \"#\",\n\t\t\t\ticon: \"far fa-sticky-note\",\n\t\t\t\ttext: entry.name + \" (comment)\",\n\t\t\t\tfolder: false // for sorting and stuff\n\t\t\t})\n\n\t\t\tindex++\n\t\t}\n\n\t\tsetTimeout(() => {\n\t\t\ttry {\n\t\t\t\ttree.get_node(currentlySelected, true)[0].scrollIntoView()\n\t\t\t} catch {}\n\t\t}, 100)\n\n\t\ttree.refresh()\n\t}\n\n\tlet oldEntityNames: string[] = []\n\tlet oldComments = \"\"\n\tlet oldEntityCount = 0\n\n\t$: if (tree) {\n\t\tif (\n\t\t\t!isEqual(\n\t\t\t\tObject.values(entity.entities).map((a) => a.name),\n\t\t\t\toldEntityNames\n\t\t\t) ||\n\t\t\tObject.keys(entity.entities).length != oldEntityCount ||\n\t\t\tentity.comments.map((a) => a.parent + a.name).join(\"\") != oldComments\n\t\t) {\n\t\t\tif (Object.keys(entity.entities).every((entityID) => reverseReferences[entityID])) {\n\t\t\t\trefreshTree(entity, reverseReferences)\n\t\t\t\toldEntityNames = Object.values(entity.entities).map((a) => a.name)\n\t\t\t\toldEntityCount = Object.keys(entity.entities).length\n\t\t\t\toldComments = entity.comments.map((a) => a.parent + a.name).join(\"\")\n\t\t\t}\n\t\t}\n\t}\n</script>\n\n<div id={elemID} />\n", "<script lang=\"ts\">\n\timport jQuery from \"jquery\"\n\timport \"jstree\"\n\timport \"./treeview.css\"\n\n\timport type { Entity, FullRef, Ref, RefWithConstantValue, SubEntity } from \"$lib/quickentity-types\"\n\timport { changeReferenceToLocalEntity, genRandHex, getReferencedEntities, getReferencedExternalEntities, getReferencedLocalEntity, normaliseToHash, traverseEntityTree } from \"$lib/utils\"\n\n\timport { createEventDispatcher, onMount } from \"svelte\"\n\timport { v4 } from \"uuid\"\n\timport * as clipboard from \"@tauri-apps/api/clipboard\"\n\timport json from \"$lib/json\"\n\timport isEqual from \"lodash/isEqual\"\n\timport { gameServer } from \"$lib/in-vivo/gameServer\"\n\timport { addNotification, appSettings, intellisense, inVivoMetadata } from \"$lib/stores\"\n\timport { readTextFile } from \"@tauri-apps/api/fs\"\n\timport { join } from \"@tauri-apps/api/path\"\n\n\texport let entity: Entity\n\texport let reverseReferences: Record<\n\t\tstring,\n\t\t{\n\t\t\ttype: string\n\t\t\tentity: string\n\t\t\tcontext?: string[]\n\t\t}[]\n\t>\n\texport let inVivoExtensions: boolean\n\n\texport let currentlySelected: string = null!\n\texport let previouslySelected: string = null!\n\texport let editorIsValid: boolean\n\texport let autoHighlightEntities: boolean\n\n\texport const elemID = \"tree-\" + v4().replaceAll(\"-\", \"\")\n\n\texport let tree: JSTree = null!\n\n\texport let helpMenuOpen: boolean = false\n\texport let helpMenuFactory: string = \"\"\n\texport let helpMenuProps: SubEntity[\"properties\"] = {}\n\texport let helpMenuInputs: string[] = []\n\texport let helpMenuOutputs: string[] = []\n\n\tconst dispatch = createEventDispatcher()\n\n\tconst exists = async (path: string) => {\n\t\ttry {\n\t\t\treturn await tauriExists(path)\n\t\t} catch {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tconst icons = Object.entries({\n\t\t\"[assembly:/templates/gameplay/ai2/actors.template?/npcactor.entitytemplate].pc_entitytype\": \"far fa-user\",\n\t\t\"[assembly:/_pro/characters/templates/hero/agent47/agent47.template?/agent47_default.entitytemplate].pc_entitytype\": \"far fa-user-circle\",\n\t\t\"[assembly:/_pro/design/levelflow.template?/herospawn.entitytemplate].pc_entitytype\": \"far fa-user-circle\",\n\t\t\"[modules:/zglobaloutfitkit.class].pc_entitytype\": \"fas fa-tshirt\",\n\t\t\"[modules:/zroomentity.class].pc_entitytype\": \"fas fa-map-marker-alt\",\n\t\t\"[modules:/zboxvolumeentity.class].pc_entitytype\": \"far fa-square\",\n\t\t\"[modules:/zsoundbankentity.class].pc_entitytype\": \"fas fa-music\",\n\t\t\"[modules:/zcameraentity.class].pc_entitytype\": \"fas fa-camera\",\n\t\t\"[modules:/zsequenceentity.class].pc_entitytype\": \"fas fa-film\",\n\t\t\"[modules:/zhitmandamageovertime.class].pc_entitytype\": \"fas fa-skull-crossbones\",\n\t\t\"0059FBD4AEBCDED0\": \"far fa-comment\", // Hashes\n\n\t\t\"levelflow.template?/exit\": \"fas fa-sign-out-alt\",\n\t\tzitem: \"fas fa-wrench\", // Specific\n\n\t\tblockup: \"fas fa-cube\",\n\t\tsetpiece_container_body: \"fas fa-box-open\",\n\t\tsetpiece_trap: \"fas fa-skull-crossbones\",\n\t\tanimset: \"fas fa-running\",\n\t\temitter: \"fas fa-wifi\",\n\t\tsender: \"fas fa-wifi\",\n\t\tevent: \"fas fa-location-arrow\",\n\t\tdeath: \"fas fa-skull\",\n\t\tzone: \"far fa-square\", // Types\n\n\t\t\"foliage/\": \"fas fa-seedling\",\n\t\t\"vehicles/\": \"fas fa-car-side\",\n\t\t\"environment/\": \"far fa-map\",\n\t\t\"logic/\": \"fas fa-cogs\",\n\t\t\"design/\": \"fas fa-swatchbook\",\n\t\t\"modules:/\": \"fas fa-project-diagram\" // Paths\n\t})\n\n\tonMount(async () => {\n\t\tjQuery(\"#\" + elemID).jstree({\n\t\t\tcore: {\n\t\t\t\tmultiple: false,\n\t\t\t\tdata: [],\n\t\t\t\tthemes: {\n\t\t\t\t\tname: \"default\",\n\t\t\t\t\tdots: true,\n\t\t\t\t\ticons: true\n\t\t\t\t},\n\t\t\t\tcheck_callback: true\n\t\t\t},\n\t\t\tsearch: {\n\t\t\t\tfuzzy: true,\n\t\t\t\tshow_only_matches: true,\n\t\t\t\tclose_opened_onclear: false,\n\t\t\t\tsearch_callback: (search: string, node: { id: string }) => {\n\t\t\t\t\tif (search.startsWith(\":\")) {\n\t\t\t\t\t\tif (entity.entities[node.id]) {\n\t\t\t\t\t\t\treturn eval(search.slice(1))({ ...entity.entities[node.id], id: node.id })\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn (json.stringify(entity.entities[node.id] || entity.comments[Number(node.id.split(\"-\")[1])]) + node.id).toLowerCase().includes(search)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tsort: function (a: any, b: any) {\n\t\t\t\tif (\n\t\t\t\t\t(!(this.get_node(a).original ? this.get_node(a).original : this.get_node(a)).folder && !(this.get_node(b).original ? this.get_node(b).original : this.get_node(b)).folder) ||\n\t\t\t\t\t((this.get_node(a).original ? this.get_node(a).original : this.get_node(a)).folder && (this.get_node(b).original ? this.get_node(b).original : this.get_node(b)).folder)\n\t\t\t\t) {\n\t\t\t\t\treturn this.get_text(a).localeCompare(this.get_text(b), undefined, { numeric: true, sensitivity: \"base\" }) > 0 ? 1 : -1\n\t\t\t\t} else {\n\t\t\t\t\treturn (this.get_node(a).original ? this.get_node(a).original : this.get_node(a)).folder ? -1 : 1\n\t\t\t\t}\n\t\t\t},\n\t\t\tcontextmenu: {\n\t\t\t\tselect_node: false,\n\t\t\t\titems: (b: { id: string }, c: any) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcreate: {\n\t\t\t\t\t\t\tseparator_before: false,\n\t\t\t\t\t\t\tseparator_after: true,\n\t\t\t\t\t\t\t_disabled: false,\n\t\t\t\t\t\t\tlabel: \"Create\",\n\t\t\t\t\t\t\ticon: \"fas fa-plus\",\n\t\t\t\t\t\t\taction: function (b: { reference: string | HTMLElement | JQuery<HTMLElement> }) {\n\t\t\t\t\t\t\t\tvar c = jQuery.jstree!.reference(b.reference),\n\t\t\t\t\t\t\t\t\td = c.get_node(b.reference)\n\t\t\t\t\t\t\t\tc.create_node(d, {}, \"last\", function (a: any) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tc.edit(a)\n\t\t\t\t\t\t\t\t\t} catch (b) {\n\t\t\t\t\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t\t\t\t\tc.edit(a)\n\t\t\t\t\t\t\t\t\t\t}, 0)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreateComment: {\n\t\t\t\t\t\t\tseparator_before: false,\n\t\t\t\t\t\t\tseparator_after: true,\n\t\t\t\t\t\t\t_disabled: false,\n\t\t\t\t\t\t\tlabel: \"Add Comment\",\n\t\t\t\t\t\t\ticon: \"far fa-sticky-note\",\n\t\t\t\t\t\t\taction: function (b: { reference: string | HTMLElement | JQuery<HTMLElement> }) {\n\t\t\t\t\t\t\t\tentity.comments = [\n\t\t\t\t\t\t\t\t\t...entity.comments,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tparent: jQuery.jstree!.reference(b.reference).get_node(b.reference).id,\n\t\t\t\t\t\t\t\t\t\tname: \"New Comment\",\n\t\t\t\t\t\t\t\t\t\ttext: \"\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\trename: {\n\t\t\t\t\t\t\tseparator_before: false,\n\t\t\t\t\t\t\tseparator_after: false,\n\t\t\t\t\t\t\t_disabled: false,\n\t\t\t\t\t\t\tlabel: \"Rename\",\n\t\t\t\t\t\t\ticon: \"far fa-pen-to-square\",\n\t\t\t\t\t\t\taction: function (b: { reference: string | HTMLElement | JQuery<HTMLElement> }) {\n\t\t\t\t\t\t\t\tvar c = jQuery.jstree!.reference(b.reference),\n\t\t\t\t\t\t\t\t\td = c.get_node(b.reference)\n\t\t\t\t\t\t\t\tc.edit(d)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tremove: {\n\t\t\t\t\t\t\tseparator_before: false,\n\t\t\t\t\t\t\tseparator_after: false,\n\t\t\t\t\t\t\t_disabled: false,\n\t\t\t\t\t\t\tlabel: \"Delete\",\n\t\t\t\t\t\t\ticon: \"far fa-trash-can\",\n\t\t\t\t\t\t\taction: function (b: { reference: string | HTMLElement | JQuery<HTMLElement> }) {\n\t\t\t\t\t\t\t\tvar c = jQuery.jstree!.reference(b.reference),\n\t\t\t\t\t\t\t\t\td = c.get_node(b.reference)\n\t\t\t\t\t\t\t\tc.is_selected(d) ? c.delete_node(c.get_selected()) : c.delete_node(d)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t...(!inVivoExtensions || b.id.startsWith(\"comment\") || !gameServer.connected || !gameServer.lastAddress\n\t\t\t\t\t\t\t? {}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tinVivo: {\n\t\t\t\t\t\t\t\t\t\tseparator_before: true,\n\t\t\t\t\t\t\t\t\t\tseparator_after: false,\n\t\t\t\t\t\t\t\t\t\tlabel: \"In-Vivo\",\n\t\t\t\t\t\t\t\t\t\ticon: \"fas fa-right-left\",\n\t\t\t\t\t\t\t\t\t\taction: false,\n\t\t\t\t\t\t\t\t\t\tsubmenu: {\n\t\t\t\t\t\t\t\t\t\t\thighlight: {\n\t\t\t\t\t\t\t\t\t\t\t\tseparator_before: false,\n\t\t\t\t\t\t\t\t\t\t\t\tseparator_after: false,\n\t\t\t\t\t\t\t\t\t\t\t\tlabel: \"Highlight\",\n\t\t\t\t\t\t\t\t\t\t\t\ticon: \"fas fa-highlighter\",\n\t\t\t\t\t\t\t\t\t\t\t\taction: async (b: { reference: string | HTMLElement | JQuery<HTMLElement> }) => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet d = tree.get_node(b.reference)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tawait gameServer.highlightEntity(d.id, entity.entities[d.id])\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t$addNotification = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tkind: \"success\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttitle: \"Entity highlighted\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsubtitle: \"Check your game; the entity should now be displaying its bounding box.\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tmoveToPlayerPosition: {\n\t\t\t\t\t\t\t\t\t\t\t\tseparator_before: false,\n\t\t\t\t\t\t\t\t\t\t\t\tseparator_after: false,\n\t\t\t\t\t\t\t\t\t\t\t\tlabel: \"Move to Player Position\",\n\t\t\t\t\t\t\t\t\t\t\t\ticon: \"fas fa-location-dot\",\n\t\t\t\t\t\t\t\t\t\t\t\taction: async (b: { reference: string | HTMLElement | JQuery<HTMLElement> }) => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet d = tree.get_node(b.reference)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet playerPos = await gameServer.getPlayerPosition()\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tentity.entities[d.id].properties ??= {}\n\t\t\t\t\t\t\t\t\t\t\t\t\tentity.entities[d.id].properties!.m_mTransform ??= {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"SMatrix43\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\trotation: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tz: 0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tposition: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tz: 0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (entity.entities[d.id].properties!.m_eidParent) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tentity.entities[d.id].properties = Object.fromEntries(Object.entries(entity.entities[d.id].properties!).filter((a) => a[0] != \"m_eidParent\"))\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// TODO: this isn't always going to work so it should probably be hooked up to intellisense in case of aliases or such\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tentity.entities[d.id].properties!.m_eRoomBehaviour = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"ZSpatialEntity.ERoomBehaviour\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: \"ROOM_DYNAMIC\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tentity.entities[d.id].properties!.m_mTransform.value.position.x = playerPos.x\n\t\t\t\t\t\t\t\t\t\t\t\t\tentity.entities[d.id].properties!.m_mTransform.value.position.y = playerPos.y\n\t\t\t\t\t\t\t\t\t\t\t\t\tentity.entities[d.id].properties!.m_mTransform.value.position.z = playerPos.z\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tdispatch(\"entityUpdated\", d.id)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tawait gameServer.updateProperty(d.id, \"m_mTransform\", entity.entities[d.id].properties!.m_mTransform)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t$inVivoMetadata.entities[d.id] ??= {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdirtyPins: false,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdirtyUnchangeables: false,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdirtyExtensions: false,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdirtyProperties: [],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thasSetProperties: false\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t$inVivoMetadata.entities[d.id].dirtyProperties = $inVivoMetadata.entities[d.id].dirtyProperties.filter((a) => a != \"m_mTransform\")\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t$addNotification = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tkind: \"success\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttitle: \"Entity set to player position\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsubtitle: \"The m_mTransform property has been updated accordingly.\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tadjustRotationToPlayer: {\n\t\t\t\t\t\t\t\t\t\t\t\tseparator_before: false,\n\t\t\t\t\t\t\t\t\t\t\t\tseparator_after: false,\n\t\t\t\t\t\t\t\t\t\t\t\tlabel: \"Adjust Rotation to Player\",\n\t\t\t\t\t\t\t\t\t\t\t\ticon: \"fas fa-compass\",\n\t\t\t\t\t\t\t\t\t\t\t\taction: async (b: { reference: string | HTMLElement | JQuery<HTMLElement> }) => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet d = tree.get_node(b.reference)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet playerRot = await gameServer.getPlayerRotation()\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tentity.entities[d.id].properties ??= {}\n\t\t\t\t\t\t\t\t\t\t\t\t\tentity.entities[d.id].properties!.m_mTransform ??= {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"SMatrix43\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\trotation: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tz: 0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tposition: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tz: 0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tentity.entities[d.id].properties!.m_mTransform.value.rotation.x = playerRot.x\n\t\t\t\t\t\t\t\t\t\t\t\t\tentity.entities[d.id].properties!.m_mTransform.value.rotation.y = playerRot.y\n\t\t\t\t\t\t\t\t\t\t\t\t\tentity.entities[d.id].properties!.m_mTransform.value.rotation.z = playerRot.z\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tdispatch(\"entityUpdated\", d.id)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tawait gameServer.updateProperty(d.id, \"m_mTransform\", entity.entities[d.id].properties!.m_mTransform)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t$inVivoMetadata.entities[d.id] ??= {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdirtyPins: false,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdirtyUnchangeables: false,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdirtyExtensions: false,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdirtyProperties: [],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thasSetProperties: false\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t$inVivoMetadata.entities[d.id].dirtyProperties = $inVivoMetadata.entities[d.id].dirtyProperties.filter((a) => a != \"m_mTransform\")\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t$addNotification = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tkind: \"success\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttitle: \"Entity set to player rotation\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsubtitle: \"The m_mTransform property has been updated accordingly.\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t  }),\n\t\t\t\t\t\tccp: {\n\t\t\t\t\t\t\tseparator_before: true,\n\t\t\t\t\t\t\tseparator_after: false,\n\t\t\t\t\t\t\tlabel: \"Clipboard\",\n\t\t\t\t\t\t\ticon: \"far fa-clipboard\",\n\t\t\t\t\t\t\taction: false,\n\t\t\t\t\t\t\tsubmenu: {\n\t\t\t\t\t\t\t\tcopy: {\n\t\t\t\t\t\t\t\t\tseparator_before: false,\n\t\t\t\t\t\t\t\t\tseparator_after: false,\n\t\t\t\t\t\t\t\t\tlabel: \"Copy Entity\",\n\t\t\t\t\t\t\t\t\ticon: \"far fa-copy\",\n\t\t\t\t\t\t\t\t\taction: async (b: { reference: string | HTMLElement | JQuery<HTMLElement> }) => {\n\t\t\t\t\t\t\t\t\t\tlet d = tree.get_node(b.reference)\n\t\t\t\t\t\t\t\t\t\tlet copiedEntity: Record<string, any> = {}\n\n\t\t\t\t\t\t\t\t\t\tcopiedEntity[d.id] = json.parse(json.stringify(entity.entities[d.id]))\n\t\t\t\t\t\t\t\t\t\tObject.assign(\n\t\t\t\t\t\t\t\t\t\t\tcopiedEntity,\n\t\t\t\t\t\t\t\t\t\t\tjson.parse(json.stringify(Object.fromEntries([...new Set(traverseEntityTree(entity, d.id, reverseReferences))].map((a) => [a, entity.entities[a]]))))\n\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\t\tcopiedEntity.origin = entity.tempHash\n\n\t\t\t\t\t\t\t\t\t\tawait clipboard.writeText(json.stringify(copiedEntity))\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tpaste: {\n\t\t\t\t\t\t\t\t\tseparator_before: false,\n\t\t\t\t\t\t\t\t\t_disabled: false,\n\t\t\t\t\t\t\t\t\tseparator_after: false,\n\t\t\t\t\t\t\t\t\tlabel: \"Paste Entity\",\n\t\t\t\t\t\t\t\t\ticon: \"far fa-paste\",\n\t\t\t\t\t\t\t\t\taction: async (b: { reference: string | HTMLElement | JQuery<HTMLElement> }) => {\n\t\t\t\t\t\t\t\t\t\tlet d = tree.get_node(b.reference)\n\t\t\t\t\t\t\t\t\t\tlet pastedEntity = json.parse((await clipboard.readText())!)\n\n\t\t\t\t\t\t\t\t\t\tlet removeExternalRefs = pastedEntity.origin != entity.tempHash\n\t\t\t\t\t\t\t\t\t\tdelete pastedEntity.origin\n\n\t\t\t\t\t\t\t\t\t\tlet changedEntityIDs: Record<string, string> = {}\n\t\t\t\t\t\t\t\t\t\tfor (let ent of Object.entries(pastedEntity)) {\n\t\t\t\t\t\t\t\t\t\t\tchangedEntityIDs[ent[0]] = \"feed\" + genRandHex(12)\n\n\t\t\t\t\t\t\t\t\t\t\tpastedEntity[changedEntityIDs[ent[0]]] = ent[1]\n\t\t\t\t\t\t\t\t\t\t\tdelete pastedEntity[ent[0]]\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tlet paste: Record<string, SubEntity> = pastedEntity\n\n\t\t\t\t\t\t\t\t\t\tfor (let [entID, ent] of Object.entries(paste)) {\n\t\t\t\t\t\t\t\t\t\t\tconst localRef = getReferencedLocalEntity(ent.parent)\n\t\t\t\t\t\t\t\t\t\t\tent.parent = localRef && changedEntityIDs[localRef] ? changeReferenceToLocalEntity(ent.parent, changedEntityIDs[localRef]) : ent.parent\n\n\t\t\t\t\t\t\t\t\t\t\tfor (let ref of getReferencedEntities(ent)) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (changedEntityIDs[ref.entity]) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tswitch (ref.type) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"property\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Array.isArray(ent.properties![ref.context![0]].value)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.properties![ref.context![0]].value.splice(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.properties![ref.context![0]].value.findIndex((a: Ref) => getReferencedLocalEntity(a) == ref.entity),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchangeReferenceToLocalEntity(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.properties![ref.context![0]].value.find((a: Ref) => getReferencedLocalEntity(a) == ref.entity),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchangedEntityIDs[ref.entity]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.properties![ref.context![0]].value = changeReferenceToLocalEntity(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.properties![ref.context![0]].value,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchangedEntityIDs[ref.entity]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"platformSpecificProperty\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Array.isArray(ent.platformSpecificProperties![ref.context![0]][ref.context![1]].value)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.platformSpecificProperties![ref.context![0]][ref.context![1]].value.splice(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.platformSpecificProperties![ref.context![0]][ref.context![1]].value.findIndex(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(a: Ref) => getReferencedLocalEntity(a) == ref.entity\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchangeReferenceToLocalEntity(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.platformSpecificProperties![ref.context![0]][ref.context![1]].value.find(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(a: Ref) => getReferencedLocalEntity(a) == ref.entity\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchangedEntityIDs[ref.entity]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.platformSpecificProperties![ref.context![0]][ref.context![1]].value = changeReferenceToLocalEntity(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.platformSpecificProperties![ref.context![0]][ref.context![1]].value,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchangedEntityIDs[ref.entity]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"event\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet evtIndex = ent.events![ref.context![0]][ref.context![1]].findIndex(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(a) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgetReferencedLocalEntity(a && typeof a != \"string\" && Object.prototype.hasOwnProperty.call(a, \"value\") ? a.ref : (a as FullRef)) ==\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tref.entity\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet evt = ent.events![ref.context![0]][ref.context![1]][evtIndex]\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.events![ref.context![0]][ref.context![1]].splice(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tevtIndex,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tevt && typeof evt != \"string\" && Object.prototype.hasOwnProperty.call(evt, \"value\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tref: changeReferenceToLocalEntity(evt.ref, changedEntityIDs[ref.entity]),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: (evt as RefWithConstantValue).value\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: changeReferenceToLocalEntity(evt as FullRef, changedEntityIDs[ref.entity])\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"inputCopy\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet evt2Index = ent.inputCopying![ref.context![0]][ref.context![1]].findIndex(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(a) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgetReferencedLocalEntity(a && typeof a != \"string\" && Object.prototype.hasOwnProperty.call(a, \"value\") ? a.ref : (a as FullRef)) ==\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tref.entity\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet evt2 = ent.inputCopying![ref.context![0]][ref.context![1]][evt2Index]\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.inputCopying![ref.context![0]][ref.context![1]].splice(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tevt2Index,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tevt2 && typeof evt2 != \"string\" && Object.prototype.hasOwnProperty.call(evt2, \"value\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tref: changeReferenceToLocalEntity(evt2.ref, changedEntityIDs[ref.entity]),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: (evt2 as RefWithConstantValue).value\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: changeReferenceToLocalEntity(evt2 as FullRef, changedEntityIDs[ref.entity])\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"outputCopy\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet evt3Index = ent.outputCopying![ref.context![0]][ref.context![1]].findIndex(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(a) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgetReferencedLocalEntity(a && typeof a != \"string\" && Object.prototype.hasOwnProperty.call(a, \"value\") ? a.ref : (a as FullRef)) ==\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tref.entity\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet evt3 = ent.outputCopying![ref.context![0]][ref.context![1]][evt3Index]\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.outputCopying![ref.context![0]][ref.context![1]].splice(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tevt3Index,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tevt3 && typeof evt3 != \"string\" && Object.prototype.hasOwnProperty.call(evt3, \"value\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tref: changeReferenceToLocalEntity(evt3.ref, changedEntityIDs[ref.entity]),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: (evt3 as RefWithConstantValue).value\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: changeReferenceToLocalEntity(evt3 as FullRef, changedEntityIDs[ref.entity])\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"propertyAlias\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.propertyAliases![ref.context![0]].splice(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.propertyAliases![ref.context![0]].findIndex((a) => isEqual(a, { originalProperty: ref.context![1], originalEntity: ref.entity })),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject.assign(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.propertyAliases![ref.context![0]].find((a) => isEqual(a, { originalProperty: ref.context![1], originalEntity: ref.entity }))!,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\toriginalEntity: changedEntityIDs[ref.entity]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"exposedEntity\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.exposedEntities![ref.context![0]].refersTo.splice(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.exposedEntities![ref.context![0]].refersTo.findIndex((a) => getReferencedLocalEntity(a) == ref.entity),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchangeReferenceToLocalEntity(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.exposedEntities![ref.context![0]].refersTo.find((a) => getReferencedLocalEntity(a) == ref.entity)!,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchangedEntityIDs[ref.entity]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"exposedInterface\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.exposedInterfaces![ref.context![0]] = changedEntityIDs[ref.entity]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"subset\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.subsets![ref.context![0]].splice(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.subsets![ref.context![0]].findIndex((a) => getReferencedLocalEntity(a) == ref.entity),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchangedEntityIDs[ref.entity]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tif (removeExternalRefs) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor (let ref of getReferencedExternalEntities(ent, paste)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet localRef = getReferencedLocalEntity(ref.entity)\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (!localRef || !entity.entities[localRef]) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tswitch (ref.type) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"property\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Array.isArray(ent.properties![ref.context![0]].value)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.properties![ref.context![0]].value = ent.properties![ref.context![0]].value.filter((a: Ref) => !isEqual(a, ref.entity))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdelete ent.properties![ref.context![0]]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"platformSpecificProperty\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Array.isArray(ent.platformSpecificProperties![ref.context![0]][ref.context![1]].value)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.platformSpecificProperties![ref.context![0]][ref.context![1]].value = ent.platformSpecificProperties![ref.context![0]][\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tref.context![1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t].value.filter((a: Ref) => !isEqual(a, ref.entity))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdelete ent.platformSpecificProperties![ref.context![0]][ref.context![1]]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"event\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.events![ref.context![0]][ref.context![1]] = ent.events![ref.context![0]][ref.context![1]].filter(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(a) => !isEqual(a && typeof a != \"string\" && Object.prototype.hasOwnProperty.call(a, \"value\") ? a.ref : (a as FullRef), ref.entity)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"inputCopy\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.inputCopying![ref.context![0]][ref.context![1]] = ent.inputCopying![ref.context![0]][ref.context![1]].filter(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(a) => !isEqual(a && typeof a != \"string\" && Object.prototype.hasOwnProperty.call(a, \"value\") ? a.ref : (a as FullRef), ref.entity)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"outputCopy\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.outputCopying![ref.context![0]][ref.context![1]] = ent.outputCopying![ref.context![0]][ref.context![1]].filter(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(a) => !isEqual(a && typeof a != \"string\" && Object.prototype.hasOwnProperty.call(a, \"value\") ? a.ref : (a as FullRef), ref.entity)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"propertyAlias\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.propertyAliases![ref.context![0]] = ent.propertyAliases![ref.context![0]].filter(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(a) => !isEqual(a, { originalProperty: ref.context![1], originalEntity: ref.entity })\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"exposedEntity\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.exposedEntities![ref.context![0]].refersTo = ent.exposedEntities![ref.context![0]].refersTo.filter((a) => !isEqual(a, ref.entity))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"exposedInterface\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdelete ent.exposedInterfaces![ref.context![0]]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"subset\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.subsets![ref.context![0]] = ent.subsets![ref.context![0]].filter((a) => a != ref.entity)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tObject.assign(entity.entities, paste)\n\n\t\t\t\t\t\t\t\t\t\tentity.entities[Object.keys(paste)[0]].parent = changeReferenceToLocalEntity(entity.entities[Object.keys(paste)[0]].parent, d.id)\n\n\t\t\t\t\t\t\t\t\t\tdispatch(\"forceUpdateEntity\")\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcopyID: {\n\t\t\t\t\t\t\tseparator_before: false,\n\t\t\t\t\t\t\tseparator_after: false,\n\t\t\t\t\t\t\t_disabled: false,\n\t\t\t\t\t\t\tlabel: \"Copy ID\",\n\t\t\t\t\t\t\ticon: \"far fa-copy\",\n\t\t\t\t\t\t\taction: function (b: { reference: string | HTMLElement | JQuery<HTMLElement> }) {\n\t\t\t\t\t\t\t\tlet d = tree.get_node(b.reference)\n\n\t\t\t\t\t\t\t\tclipboard.writeText(d.id)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t...(!currentlySelected || !$appSettings.gameFileExtensions || b.id.startsWith(\"comment\")\n\t\t\t\t\t\t\t? {}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\thelp: {\n\t\t\t\t\t\t\t\t\t\tseparator_before: false,\n\t\t\t\t\t\t\t\t\t\tseparator_after: false,\n\t\t\t\t\t\t\t\t\t\t_disabled: false,\n\t\t\t\t\t\t\t\t\t\tlabel: \"Help\",\n\t\t\t\t\t\t\t\t\t\ticon: \"far fa-circle-question\",\n\t\t\t\t\t\t\t\t\t\taction: async function (b: { reference: string | HTMLElement | JQuery<HTMLElement> }) {\n\t\t\t\t\t\t\t\t\t\t\tlet d = tree.get_node(b.reference)\n\n\t\t\t\t\t\t\t\t\t\t\tlet entityID = d.id\n\t\t\t\t\t\t\t\t\t\t\tlet entityData = entity.entities[d.id]\n\n\t\t\t\t\t\t\t\t\t\t\thelpMenuFactory = entityData.factory\n\t\t\t\t\t\t\t\t\t\t\thelpMenuProps = {}\n\t\t\t\t\t\t\t\t\t\t\thelpMenuInputs = []\n\t\t\t\t\t\t\t\t\t\t\thelpMenuOutputs = []\n\n\t\t\t\t\t\t\t\t\t\t\tlet allFoundProperties = []\n\n\t\t\t\t\t\t\t\t\t\t\tfor (let factory of (await exists(await join($appSettings.gameFileExtensionsDataPath, \"ASET\", normaliseToHash(entityData.factory) + \".ASET.meta.JSON\")))\n\t\t\t\t\t\t\t\t\t\t\t\t? json\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.parse(await readTextFile(await join($appSettings.gameFileExtensionsDataPath, \"ASET\", normaliseToHash(entityData.factory) + \".ASET.meta.JSON\")))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.hash_reference_data.slice(0, -1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.map((a) => a.hash)\n\t\t\t\t\t\t\t\t\t\t\t\t: [normaliseToHash(entityData.factory)]) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (await exists(await join($appSettings.gameFileExtensionsDataPath, \"TEMP\", factory + \".TEMP.entity.json\"))) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tawait $intellisense.findProperties(await join($appSettings.gameFileExtensionsDataPath, \"TEMP\", factory + \".TEMP.entity.json\"), allFoundProperties)\n\t\t\t\t\t\t\t\t\t\t\t\t\tentityData.propertyAliases && allFoundProperties.push(...Object.keys(entityData.propertyAliases))\n\t\t\t\t\t\t\t\t\t\t\t\t} else if ($intellisense.knownCPPTProperties[factory]) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tallFoundProperties.push(...Object.keys($intellisense.knownCPPTProperties[factory]))\n\t\t\t\t\t\t\t\t\t\t\t\t} else if ($intellisense.allUICTs.has(factory)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tallFoundProperties.push(...Object.keys($intellisense.knownCPPTProperties[\"002C4526CC9753E6\"])) // All UI controls have the properties of ZUIControlEntity\n\t\t\t\t\t\t\t\t\t\t\t\t\tallFoundProperties.push(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t...Object.keys(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tjson.parse(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tawait readTextFile(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tawait join(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"./intellisense-data/UICB\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tjson\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.parse(await readTextFile(await join($appSettings.gameFileExtensionsDataPath, \"UICT\", factory + \".UICT.meta.JSON\")))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.hash_reference_data.filter((a) => a.hash != \"002C4526CC9753E6\")[0].hash + \".UICB.json\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t).properties\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t) // Get the specific properties from the UICB\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tallFoundProperties = [...new Set(allFoundProperties)]\n\n\t\t\t\t\t\t\t\t\t\t\thelpMenuProps = {}\n\n\t\t\t\t\t\t\t\t\t\t\tif ($intellisense.knownCPPTProperties[normaliseToHash(entityData.factory)]) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor (let foundProp of allFoundProperties) {\n\t\t\t\t\t\t\t\t\t\t\t\t\thelpMenuProps[foundProp] = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: $intellisense.knownCPPTProperties[normaliseToHash(entityData.factory)][foundProp][0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: $intellisense.knownCPPTProperties[normaliseToHash(entityData.factory)][foundProp][1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tfor (let foundProp of allFoundProperties) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet val = await $intellisense.findDefaultPropertyValue(entity.tempHash + \".TEMP.entity.json\", entityID, foundProp, entity, entityID)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (val) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thelpMenuProps[foundProp] = val\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tlet pins = { input: [], output: [] }\n\t\t\t\t\t\t\t\t\t\t\tawait $intellisense.getPins(entity, entityID, true, pins)\n\t\t\t\t\t\t\t\t\t\t\thelpMenuInputs = [...new Set(pins.input)]\n\t\t\t\t\t\t\t\t\t\t\thelpMenuOutputs = [...new Set(pins.output)]\n\n\t\t\t\t\t\t\t\t\t\t\thelpMenuOpen = true\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t  })\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tplugins: [\"contextmenu\", \"dnd\", \"search\", \"sort\"]\n\t\t})\n\n\t\ttree = jQuery(\"#\" + elemID).jstree()\n\n\t\tjQuery(\"#\" + elemID).on(\"changed.jstree\", (...data) => {\n\t\t\tif (data[1].action == \"select_node\" && data[1].node.id != currentlySelected) {\n\t\t\t\tif (editorIsValid) {\n\t\t\t\t\tpreviouslySelected = currentlySelected\n\t\t\t\t\tcurrentlySelected = data[1].node.id\n\n\t\t\t\t\tif (inVivoExtensions && autoHighlightEntities && gameServer.connected && gameServer.lastAddress && !data[1].node.id.startsWith(\"comment\")) {\n\t\t\t\t\t\tgameServer.highlightEntity(data[1].node.id, entity.entities[data[1].node.id])\n\t\t\t\t\t}\n\n\t\t\t\t\tdispatch(\"selectionUpdate\", data)\n\t\t\t\t} else {\n\t\t\t\t\ttree.deselect_node(data[1].node.id)\n\t\t\t\t\ttree.select_node(currentlySelected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tjQuery(\"#\" + elemID).on(\"move_node.jstree\", (...data) => dispatch(\"dragAndDrop\", data))\n\t\tjQuery(\"#\" + elemID).on(\"create_node.jstree\", (...data) => dispatch(\"nodeCreated\", data))\n\t\tjQuery(\"#\" + elemID).on(\"rename_node.jstree\", (...data) => dispatch(\"nodeRenamed\", data))\n\t\tjQuery(\"#\" + elemID).on(\"delete_node.jstree\", (...data) => dispatch(\"nodeDeleted\", data))\n\t})\n\n\texport function refreshTree(\n\t\tentity: Entity,\n\t\treverseReferences: Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\ttype: string\n\t\t\t\tentity: string\n\t\t\t\tcontext?: string[]\n\t\t\t}[]\n\t\t>\n\t) {\n\t\ttree.settings!.core.data = []\n\n\t\tfor (let [entityID, entityData] of Object.entries(entity.entities)) {\n\t\t\ttree.settings!.core.data.push({\n\t\t\t\tid: String(entityID),\n\t\t\t\tparent: getReferencedLocalEntity(entityData.parent) || \"#\",\n\t\t\t\ticon:\n\t\t\t\t\tentityData.factory == \"[modules:/zentity.class].pc_entitytype\" && reverseReferences[entityID].some((a) => a.type == \"parent\")\n\t\t\t\t\t\t? \"far fa-folder\"\n\t\t\t\t\t\t: icons.find((a) => entityData.factory.includes(a[0]))\n\t\t\t\t\t\t? icons.find((a) => entityData.factory.includes(a[0]))![1]\n\t\t\t\t\t\t: \"far fa-file\",\n\t\t\t\ttext: `${entityData.name} (ref ${entityID})`,\n\t\t\t\tfolder: entityData.factory == \"[modules:/zentity.class].pc_entitytype\" && reverseReferences[entityID].some((a) => a.type == \"parent\") // for sorting and stuff\n\t\t\t})\n\t\t}\n\n\t\tlet index = 0\n\t\tfor (let entry of entity.comments) {\n\t\t\ttree.settings!.core.data.push({\n\t\t\t\tid: \"comment-\" + index,\n\t\t\t\tparent: getReferencedLocalEntity(entry.parent) || \"#\",\n\t\t\t\ticon: \"far fa-sticky-note\",\n\t\t\t\ttext: entry.name + \" (comment)\",\n\t\t\t\tfolder: false // for sorting and stuff\n\t\t\t})\n\n\t\t\tindex++\n\t\t}\n\n\t\tsetTimeout(() => {\n\t\t\ttry {\n\t\t\t\ttree.get_node(currentlySelected, true)[0].scrollIntoView()\n\t\t\t} catch {}\n\t\t}, 100)\n\n\t\ttree.refresh()\n\t}\n\n\tlet oldEntityNames: string[] = []\n\tlet oldComments = \"\"\n\tlet oldEntityCount = 0\n\n\t$: if (tree) {\n\t\tif (\n\t\t\t!isEqual(\n\t\t\t\tObject.values(entity.entities).map((a) => a.name),\n\t\t\t\toldEntityNames\n\t\t\t) ||\n\t\t\tObject.keys(entity.entities).length != oldEntityCount ||\n\t\t\tentity.comments.map((a) => a.parent + a.name).join(\"\") != oldComments\n\t\t) {\n\t\t\tif (Object.keys(entity.entities).every((entityID) => reverseReferences[entityID])) {\n\t\t\t\trefreshTree(entity, reverseReferences)\n\t\t\t\toldEntityNames = Object.values(entity.entities).map((a) => a.name)\n\t\t\t\toldEntityCount = Object.keys(entity.entities).length\n\t\t\t\toldComments = entity.comments.map((a) => a.parent + a.name).join(\"\")\n\t\t\t}\n\t\t}\n\t}\n\n\texport function search(query: string) {\n\t\ttree.search(query.toLowerCase())\n\t}\n\n\texport function navigateTo(ent: string) {\n\t\ttree.deselect_node(currentlySelected)\n\t\ttree.select_node(ent)\n\t}\n\n\texport function deselect() {\n\t\ttree.deselect_all()\n\t\tcurrentlySelected = null!\n\t}\n\n\texport function getMatching(search: string) {\n\t\treturn tree.settings!.core.data.filter((node) => {\n\t\t\tif (search.startsWith(\":\")) {\n\t\t\t\tif (entity.entities[node.id]) {\n\t\t\t\t\treturn eval(search.slice(1))(entity.entities[node.id])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn (json.stringify(entity.entities[node.id] || entity.comments[Number(node.id.split(\"-\")[1])]) + node.id).toLowerCase().includes(search)\n\t\t\t}\n\t\t})\n\t}\n</script>\n\n<div id={elemID} />\n", "import type { Entity, FullRef, Ref, RefMaybeConstantValue, SubEntity } from \"$lib/quickentity-types\"\n\nimport Ajv from \"ajv\"\nimport cloneDeep from \"lodash/cloneDeep\"\nimport enums from \"$lib/enums.json\"\nimport isEqual from \"lodash/isEqual\"\nimport md5 from \"md5\"\nimport merge from \"lodash/merge\"\nimport propertyTypeSchemas from \"$lib/property-type-schemas.json\"\nimport schema from \"$lib/schema.json\"\n\nconst ajv = new Ajv({ keywords: [\"markdownDescription\"] }).compile(\n\tObject.assign({}, cloneDeep(schema), {\n\t\t$ref: \"#/definitions/SubEntity\"\n\t})\n)\n\nschema.definitions.SubEntity.properties.properties.additionalProperties = {\n\tanyOf: [\n\t\t...Object.entries(propertyTypeSchemas).map(([propType, valSchema]) => {\n\t\t\treturn merge({}, cloneDeep(schema.definitions.Property), {\n\t\t\t\tproperties: {\n\t\t\t\t\ttype: {\n\t\t\t\t\t\tconst: propType\n\t\t\t\t\t},\n\t\t\t\t\tvalue: valSchema\n\t\t\t\t},\n\t\t\t\tdefault: {\n\t\t\t\t\ttype: propType,\n\t\t\t\t\tvalue: valSchema.default\n\t\t\t\t}\n\t\t\t})\n\t\t}),\n\t\t...Object.entries(propertyTypeSchemas).map(([propType, valSchema]) => {\n\t\t\treturn merge({}, cloneDeep(schema.definitions.Property), {\n\t\t\t\tproperties: {\n\t\t\t\t\ttype: {\n\t\t\t\t\t\tconst: `TArray<${propType}>`\n\t\t\t\t\t},\n\t\t\t\t\tvalue: { type: \"array\", items: valSchema }\n\t\t\t\t},\n\t\t\t\tdefault: {\n\t\t\t\t\ttype: `TArray<${propType}>`,\n\t\t\t\t\tvalue: [valSchema.default]\n\t\t\t\t}\n\t\t\t})\n\t\t}),\n\t\t...Object.entries(enums).map(([propType, possibleValues]) => {\n\t\t\treturn merge({}, cloneDeep(schema.definitions.Property), {\n\t\t\t\tproperties: {\n\t\t\t\t\ttype: {\n\t\t\t\t\t\tconst: propType\n\t\t\t\t\t},\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\tenum: possibleValues\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdefault: {\n\t\t\t\t\ttype: propType,\n\t\t\t\t\tvalue: possibleValues[0]\n\t\t\t\t}\n\t\t\t})\n\t\t}),\n\t\t...Object.entries(enums).map(([propType, possibleValues]) => {\n\t\t\treturn merge({}, cloneDeep(schema.definitions.Property), {\n\t\t\t\tproperties: {\n\t\t\t\t\ttype: {\n\t\t\t\t\t\tconst: `TArray<${propType}>`\n\t\t\t\t\t},\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\titems: {\n\t\t\t\t\t\t\tenum: possibleValues\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdefault: {\n\t\t\t\t\ttype: `TArray<${propType}>`,\n\t\t\t\t\tvalue: [possibleValues[0]]\n\t\t\t\t}\n\t\t\t})\n\t\t}),\n\t\t{\n\t\t\t$ref: \"#/definitions/Property\"\n\t\t}\n\t]\n}\n\nschema.definitions.SubEntity.properties.platformSpecificProperties.additionalProperties.additionalProperties = cloneDeep(schema.definitions.SubEntity.properties.properties.additionalProperties)\nschema.definitions.PropertyOverride.properties.properties.additionalProperties = cloneDeep(schema.definitions.SubEntity.properties.properties.additionalProperties)\n\nexport const genRandHex = (size: number) => [...Array(size)].map(() => Math.floor(Math.random() * 16).toString(16)).join(\"\")\n\n/** Get the local entity ID referenced by a Ref. If the reference is external, returns false. If the reference is null, returns null. */\nexport function getReferencedLocalEntity(ref: Ref) {\n\tif (ref !== null && typeof ref != \"string\" && ref.externalScene) {\n\t\treturn false // External reference\n\t} else {\n\t\treturn ref !== null && typeof ref != \"string\" ? ref.ref : ref // Local reference\n\t}\n}\n\n/** Returns a modified Ref that points to a given local entity, keeping any exposed entity reference the same */\nexport function changeReferenceToLocalEntity(ref: Ref, ent: string) {\n\tif (typeof ref == \"string\" || ref === null) {\n\t\treturn ent\n\t} else {\n\t\treturn {\n\t\t\tref: ent,\n\t\t\texternalScene: null,\n\t\t\texposedEntity: ref.exposedEntity\n\t\t}\n\t}\n}\n\n/** Traverses the entity tree to find all entities logically parented under a given entity, returning their entity IDs. */\nexport function traverseEntityTree(\n\tentity: Entity,\n\tstartingPoint: string,\n\treverseReferences: Record<\n\t\tstring,\n\t\t{\n\t\t\ttype: string\n\t\t\tentity: string\n\t\t\tcontext?: string[]\n\t\t}[]\n\t>\n): string[] {\n\tconst copiedEntity = []\n\n\ttry {\n\t\tcopiedEntity.push(...reverseReferences[startingPoint].filter((a) => a.type == \"parent\").map((a) => a.entity))\n\n\t\tfor (const newEntity of copiedEntity) {\n\t\t\tcopiedEntity.push(...traverseEntityTree(entity, newEntity, reverseReferences))\n\t\t}\n\t} catch {}\n\n\treturn copiedEntity\n}\n\n/** Deletes all references to a given entity ID, mutating the passed entity. */\nexport function deleteReferencesToEntity(\n\tentity: Entity,\n\treverseReferences: Record<\n\t\tstring,\n\t\t{\n\t\t\ttype: string\n\t\t\tentity: string\n\t\t\tcontext?: string[]\n\t\t}[]\n\t>,\n\ttarget: string\n) {\n\tlet deleted = 0\n\n\tif (reverseReferences[target]) {\n\t\tfor (const ref of reverseReferences[target]) {\n\t\t\tif (entity.entities[ref.entity]) {\n\t\t\t\tswitch (ref.type) {\n\t\t\t\t\tcase \"property\":\n\t\t\t\t\t\tif (Array.isArray(entity.entities[ref.entity].properties![ref.context![0]].value)) {\n\t\t\t\t\t\t\tentity.entities[ref.entity].properties![ref.context![0]].value = entity.entities[ref.entity].properties![ref.context![0]].value.filter(\n\t\t\t\t\t\t\t\t(a: Ref) => getReferencedLocalEntity(a) != target\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdelete entity.entities[ref.entity].properties![ref.context![0]]\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdeleted++\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase \"platformSpecificProperty\":\n\t\t\t\t\t\tif (Array.isArray(entity.entities[ref.entity].platformSpecificProperties![ref.context![0]][ref.context![1]].value)) {\n\t\t\t\t\t\t\tentity.entities[ref.entity].platformSpecificProperties![ref.context![0]][ref.context![1]].value = entity.entities[ref.entity].platformSpecificProperties![ref.context![0]][\n\t\t\t\t\t\t\t\tref.context![1]\n\t\t\t\t\t\t\t].value.filter((a: Ref) => getReferencedLocalEntity(a) != target)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdelete entity.entities[ref.entity].platformSpecificProperties![ref.context![0]][ref.context![1]]\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdeleted++\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase \"event\":\n\t\t\t\t\t\tentity.entities[ref.entity].events![ref.context![0]][ref.context![1]] = entity.entities[ref.entity].events![ref.context![0]][ref.context![1]].filter(\n\t\t\t\t\t\t\t(a) => getReferencedLocalEntity(a && typeof a != \"string\" && Object.prototype.hasOwnProperty.call(a, \"value\") ? a.ref : (a as FullRef)) != target\n\t\t\t\t\t\t)\n\t\t\t\t\t\tdeleted++\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase \"inputCopy\":\n\t\t\t\t\t\tentity.entities[ref.entity].inputCopying![ref.context![0]][ref.context![1]] = entity.entities[ref.entity].inputCopying![ref.context![0]][ref.context![1]].filter(\n\t\t\t\t\t\t\t(a) => getReferencedLocalEntity(a && typeof a != \"string\" && Object.prototype.hasOwnProperty.call(a, \"value\") ? a.ref : (a as FullRef)) != target\n\t\t\t\t\t\t)\n\t\t\t\t\t\tdeleted++\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase \"outputCopy\":\n\t\t\t\t\t\tentity.entities[ref.entity].outputCopying![ref.context![0]][ref.context![1]] = entity.entities[ref.entity].outputCopying![ref.context![0]][ref.context![1]].filter(\n\t\t\t\t\t\t\t(a) => getReferencedLocalEntity(a && typeof a != \"string\" && Object.prototype.hasOwnProperty.call(a, \"value\") ? a.ref : (a as FullRef)) != target\n\t\t\t\t\t\t)\n\t\t\t\t\t\tdeleted++\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase \"propertyAlias\":\n\t\t\t\t\t\tentity.entities[ref.entity].propertyAliases![ref.context![0]] = entity.entities[ref.entity].propertyAliases![ref.context![0]].filter(\n\t\t\t\t\t\t\t(a) => !isEqual(a, { originalProperty: ref.context![1], originalEntity: target })\n\t\t\t\t\t\t)\n\t\t\t\t\t\tdeleted++\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase \"exposedEntity\":\n\t\t\t\t\t\tentity.entities[ref.entity].exposedEntities![ref.context![0]].refersTo = entity.entities[ref.entity].exposedEntities![ref.context![0]].refersTo.filter(\n\t\t\t\t\t\t\t(a) => getReferencedLocalEntity(a) != target\n\t\t\t\t\t\t)\n\t\t\t\t\t\tdeleted++\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase \"exposedInterface\":\n\t\t\t\t\t\tdelete entity.entities[ref.entity].exposedInterfaces![ref.context![0]]\n\t\t\t\t\t\tdeleted++\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase \"subset\":\n\t\t\t\t\t\tentity.entities[ref.entity].subsets![ref.context![0]] = entity.entities[ref.entity].subsets![ref.context![0]].filter((a) => a != target)\n\t\t\t\t\t\tdeleted++\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn deleted\n}\n\n/** Gets the referenced entities of an entity. */\nexport function getReferencedEntities(entityData: SubEntity): {\n\ttype: string\n\tentity: string\n\tcontext?: string[]\n}[] {\n\tconst refs = []\n\n\tconst localRef = getReferencedLocalEntity(entityData.parent)\n\tif (localRef) {\n\t\trefs.push({\n\t\t\ttype: \"parent\",\n\t\t\tentity: localRef\n\t\t})\n\t}\n\n\tif (entityData.properties) {\n\t\tfor (const [property, data] of Object.entries(entityData.properties)) {\n\t\t\tif (data.type == \"SEntityTemplateReference\" || data.type == \"TArray<SEntityTemplateReference>\") {\n\t\t\t\tfor (const value of data.type == \"SEntityTemplateReference\" ? [data.value] : data.value) {\n\t\t\t\t\tconst localRef = getReferencedLocalEntity(value)\n\t\t\t\t\tif (localRef) {\n\t\t\t\t\t\trefs.push({\n\t\t\t\t\t\t\ttype: \"property\",\n\t\t\t\t\t\t\tentity: localRef,\n\t\t\t\t\t\t\tcontext: [property]\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (entityData.platformSpecificProperties) {\n\t\tfor (const [platform, properties] of Object.entries(entityData.platformSpecificProperties)) {\n\t\t\tfor (const [property, data] of Object.entries(properties)) {\n\t\t\t\tif (data.type == \"SEntityTemplateReference\" || data.type == \"TArray<SEntityTemplateReference>\") {\n\t\t\t\t\tfor (const value of data.type == \"SEntityTemplateReference\" ? [data.value] : data.value) {\n\t\t\t\t\t\tconst localRef = getReferencedLocalEntity(value)\n\t\t\t\t\t\tif (localRef) {\n\t\t\t\t\t\t\trefs.push({\n\t\t\t\t\t\t\t\ttype: \"platformSpecificProperty\",\n\t\t\t\t\t\t\t\tentity: localRef,\n\t\t\t\t\t\t\t\tcontext: [platform, property]\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (const [type, data] of [\n\t\t[\"event\", entityData.events],\n\t\t[\"inputCopy\", entityData.inputCopying],\n\t\t[\"outputCopy\", entityData.outputCopying]\n\t] as [string, Record<string, Record<string, RefMaybeConstantValue[]>>][]) {\n\t\tif (data) {\n\t\t\tfor (const [event, x] of Object.entries(data)) {\n\t\t\t\tfor (const [trigger, ents] of Object.entries(x)) {\n\t\t\t\t\tfor (const ent of ents) {\n\t\t\t\t\t\tconst localRef = getReferencedLocalEntity(ent && typeof ent != \"string\" && Object.prototype.hasOwnProperty.call(ent, \"value\") ? ent.ref : (ent as FullRef))\n\t\t\t\t\t\tif (localRef) {\n\t\t\t\t\t\t\trefs.push({\n\t\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t\tentity: localRef,\n\t\t\t\t\t\t\t\tcontext: [event, trigger]\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (entityData.propertyAliases) {\n\t\tfor (const [property, aliases] of Object.entries(entityData.propertyAliases)) {\n\t\t\tfor (const alias of aliases) {\n\t\t\t\tconst localRef = getReferencedLocalEntity(alias.originalEntity)\n\t\t\t\tif (localRef) {\n\t\t\t\t\trefs.push({\n\t\t\t\t\t\ttype: \"propertyAlias\",\n\t\t\t\t\t\tentity: localRef,\n\t\t\t\t\t\tcontext: [property, alias.originalProperty]\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (entityData.exposedEntities) {\n\t\tfor (const [exposedEnt, data] of Object.entries(entityData.exposedEntities)) {\n\t\t\tfor (const target of data.refersTo) {\n\t\t\t\tconst localRef = getReferencedLocalEntity(target)\n\t\t\t\tif (localRef) {\n\t\t\t\t\trefs.push({\n\t\t\t\t\t\ttype: \"exposedEntity\",\n\t\t\t\t\t\tentity: localRef,\n\t\t\t\t\t\tcontext: [exposedEnt]\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (entityData.exposedInterfaces) {\n\t\tfor (const [exposedInterface, implementor] of Object.entries(entityData.exposedInterfaces)) {\n\t\t\tconst localRef = getReferencedLocalEntity(implementor)\n\t\t\tif (localRef) {\n\t\t\t\trefs.push({\n\t\t\t\t\ttype: \"exposedInterface\",\n\t\t\t\t\tentity: localRef,\n\t\t\t\t\tcontext: [exposedInterface]\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\tif (entityData.subsets) {\n\t\tfor (const [subset, entities] of Object.entries(entityData.subsets)) {\n\t\t\tfor (const ent of entities) {\n\t\t\t\trefs.push({\n\t\t\t\t\ttype: \"subset\",\n\t\t\t\t\tentity: ent,\n\t\t\t\t\tcontext: [subset]\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\treturn refs\n}\n\n/** Gets the referenced entities of a sub-entity that are not present in a set of sub-entities. */\nexport function getReferencedExternalEntities(\n\tentityData: SubEntity,\n\tentityToCheckWith: Record<string, SubEntity>\n): {\n\ttype: string\n\tentity: Ref\n\tcontext?: string[]\n}[] {\n\tconst refs = []\n\n\tconst localRef = getReferencedLocalEntity(entityData.parent)\n\tif (!localRef || !entityToCheckWith[localRef]) {\n\t\trefs.push({\n\t\t\ttype: \"parent\",\n\t\t\tentity: entityData.parent\n\t\t})\n\t}\n\n\tif (entityData.properties) {\n\t\tfor (const [property, data] of Object.entries(entityData.properties)) {\n\t\t\tif (data.type == \"SEntityTemplateReference\" || data.type == \"TArray<SEntityTemplateReference>\") {\n\t\t\t\tfor (const value of data.type == \"SEntityTemplateReference\" ? [data.value] : data.value) {\n\t\t\t\t\tconst localRef = getReferencedLocalEntity(value)\n\t\t\t\t\tif (!localRef || !entityToCheckWith[localRef]) {\n\t\t\t\t\t\trefs.push({\n\t\t\t\t\t\t\ttype: \"property\",\n\t\t\t\t\t\t\tentity: value,\n\t\t\t\t\t\t\tcontext: [property]\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (entityData.platformSpecificProperties) {\n\t\tfor (const [platform, properties] of Object.entries(entityData.platformSpecificProperties)) {\n\t\t\tfor (const [property, data] of Object.entries(properties)) {\n\t\t\t\tif (data.type == \"SEntityTemplateReference\" || data.type == \"TArray<SEntityTemplateReference>\") {\n\t\t\t\t\tfor (const value of data.type == \"SEntityTemplateReference\" ? [data.value] : data.value) {\n\t\t\t\t\t\tconst localRef = getReferencedLocalEntity(value)\n\t\t\t\t\t\tif (!localRef || !entityToCheckWith[localRef]) {\n\t\t\t\t\t\t\trefs.push({\n\t\t\t\t\t\t\t\ttype: \"platformSpecificProperty\",\n\t\t\t\t\t\t\t\tentity: value,\n\t\t\t\t\t\t\t\tcontext: [platform, property]\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (const [type, data] of [\n\t\t[\"event\", entityData.events],\n\t\t[\"inputCopy\", entityData.inputCopying],\n\t\t[\"outputCopy\", entityData.outputCopying]\n\t] as [string, Record<string, Record<string, RefMaybeConstantValue[]>>][]) {\n\t\tif (data) {\n\t\t\tfor (const [event, x] of Object.entries(data)) {\n\t\t\t\tfor (const [trigger, ents] of Object.entries(x)) {\n\t\t\t\t\tfor (const ent of ents) {\n\t\t\t\t\t\tconst localRef = getReferencedLocalEntity(ent && typeof ent != \"string\" && Object.prototype.hasOwnProperty.call(ent, \"value\") ? ent.ref : (ent as FullRef))\n\t\t\t\t\t\tif (!localRef || !entityToCheckWith[localRef]) {\n\t\t\t\t\t\t\trefs.push({\n\t\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t\tentity: ent && typeof ent != \"string\" && Object.prototype.hasOwnProperty.call(ent, \"value\") ? ent.ref : (ent as FullRef),\n\t\t\t\t\t\t\t\tcontext: [event, trigger]\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (entityData.propertyAliases) {\n\t\tfor (const [property, aliases] of Object.entries(entityData.propertyAliases)) {\n\t\t\tfor (const alias of aliases) {\n\t\t\t\tconst localRef = getReferencedLocalEntity(alias.originalEntity)\n\t\t\t\tif (!localRef || !entityToCheckWith[localRef]) {\n\t\t\t\t\trefs.push({\n\t\t\t\t\t\ttype: \"propertyAlias\",\n\t\t\t\t\t\tentity: alias.originalEntity,\n\t\t\t\t\t\tcontext: [property, alias.originalProperty]\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (entityData.exposedEntities) {\n\t\tfor (const [exposedEnt, data] of Object.entries(entityData.exposedEntities)) {\n\t\t\tfor (const target of data.refersTo) {\n\t\t\t\tconst localRef = getReferencedLocalEntity(target)\n\t\t\t\tif (!localRef || !entityToCheckWith[localRef]) {\n\t\t\t\t\trefs.push({\n\t\t\t\t\t\ttype: \"exposedEntity\",\n\t\t\t\t\t\tentity: target,\n\t\t\t\t\t\tcontext: [exposedEnt]\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (entityData.exposedInterfaces) {\n\t\tfor (const [exposedInterface, implementor] of Object.entries(entityData.exposedInterfaces)) {\n\t\t\tconst localRef = getReferencedLocalEntity(implementor)\n\t\t\tif (!localRef || !entityToCheckWith[localRef]) {\n\t\t\t\trefs.push({\n\t\t\t\t\ttype: \"exposedInterface\",\n\t\t\t\t\tentity: implementor,\n\t\t\t\t\tcontext: [exposedInterface]\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\tif (entityData.subsets) {\n\t\tfor (const [subset, entities] of Object.entries(entityData.subsets)) {\n\t\t\tfor (const ent of entities) {\n\t\t\t\tif (!entityToCheckWith[ent]) {\n\t\t\t\t\trefs.push({\n\t\t\t\t\t\ttype: \"subset\",\n\t\t\t\t\t\tentity: ent,\n\t\t\t\t\t\tcontext: [subset]\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn refs\n}\n\n/** Check the validity of an entity's references as well as matching it against the schema. Returns null if the entity is valid and a message if not. */\nexport function checkValidityOfEntity(entity: Entity, target: SubEntity): null | string {\n\t// Check that all referenced entities exist\n\tfor (const ref of getReferencedEntities(target)) {\n\t\tif (ref.entity == \"\") {\n\t\t\treturn \"Empty string used as reference\"\n\t\t}\n\n\t\tif (!entity.entities[ref.entity]) {\n\t\t\treturn `Referenced entity ${ref.entity} doesn't exist`\n\t\t}\n\t}\n\n\t// Check that schema is met\n\ttry {\n\t\tif (!ajv(target)) {\n\t\t\tconsole.log(\"Entity invalid by schema\", ajv.errors)\n\t\t\treturn \"Entity doesn't meet specifications\"\n\t\t}\n\t} catch {\n\t\treturn \"Entity doesn't meet specifications\"\n\t}\n\n\treturn null\n}\n\nexport function normaliseToHash(path: string): string {\n\tif (path.includes(\":\")) {\n\t\treturn (\"00\" + md5(path).slice(2, 16)).toUpperCase()\n\t}\n\n\treturn path\n}\n\nexport function getSchema() {\n\treturn cloneDeep(schema)\n}\n\nexport function changeEntityHashesToFriendly(entity: Entity, friendly: Record<string, string>) {\n\tentity.externalScenes = entity.externalScenes.map((a) => friendly[a] || a)\n\n\tentity.extraFactoryDependencies = entity.extraFactoryDependencies.map((a) => {\n\t\tif (typeof a == \"string\") {\n\t\t\treturn friendly[a] || a\n\t\t} else if (a) {\n\t\t\treturn {\n\t\t\t\tresource: friendly[a.resource] || a.resource,\n\t\t\t\tflag: a.flag\n\t\t\t}\n\t\t} else {\n\t\t\treturn a\n\t\t}\n\t})\n\n\tentity.extraBlueprintDependencies = entity.extraBlueprintDependencies.map((a) => {\n\t\tif (typeof a == \"string\") {\n\t\t\treturn friendly[a] || a\n\t\t} else if (a) {\n\t\t\treturn {\n\t\t\t\tresource: friendly[a.resource] || a.resource,\n\t\t\t\tflag: a.flag\n\t\t\t}\n\t\t} else {\n\t\t\treturn a\n\t\t}\n\t})\n\n\tfor (const subEntity of Object.values(entity.entities)) {\n\t\tsubEntity.factory = friendly[subEntity.factory] || subEntity.factory\n\t\tsubEntity.blueprint = friendly[subEntity.blueprint] || subEntity.blueprint\n\n\t\tif (subEntity.properties) {\n\t\t\tfor (const property of Object.values(subEntity.properties)) {\n\t\t\t\tif (property.type == \"ZRuntimeResourceID\") {\n\t\t\t\t\tif (typeof property.value == \"string\") {\n\t\t\t\t\t\tproperty.value = friendly[property.value] || property.value\n\t\t\t\t\t} else if (property.value) {\n\t\t\t\t\t\tproperty.value.resource = friendly[property.value.resource] || property.value.resource\n\t\t\t\t\t}\n\t\t\t\t} else if (property.type == \"TArray<ZRuntimeResourceID>\") {\n\t\t\t\t\tproperty.value = property.value.map((a) => {\n\t\t\t\t\t\tif (typeof a == \"string\") {\n\t\t\t\t\t\t\treturn friendly[a] || a\n\t\t\t\t\t\t} else if (a) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tresource: friendly[a.resource] || a.resource,\n\t\t\t\t\t\t\t\tflag: a.flag\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn a\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (subEntity.platformSpecificProperties) {\n\t\t\tfor (const properties of Object.values(subEntity.platformSpecificProperties)) {\n\t\t\t\tfor (const property of Object.values(properties)) {\n\t\t\t\t\tif (property.type == \"ZRuntimeResourceID\") {\n\t\t\t\t\t\tif (typeof property.value == \"string\") {\n\t\t\t\t\t\t\tproperty.value = friendly[property.value] || property.value\n\t\t\t\t\t\t} else if (property.value) {\n\t\t\t\t\t\t\tproperty.value.resource = friendly[property.value.resource] || property.value.resource\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (property.type == \"TArray<ZRuntimeResourceID>\") {\n\t\t\t\t\t\tproperty.value = property.value.map((a) => {\n\t\t\t\t\t\t\tif (typeof a == \"string\") {\n\t\t\t\t\t\t\t\treturn friendly[a] || a\n\t\t\t\t\t\t\t} else if (a) {\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tresource: friendly[a.resource] || a.resource,\n\t\t\t\t\t\t\t\t\tflag: a.flag\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn a\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function changeEntityHashesFromFriendly(entity: Entity, friendly: Record<string, string>) {\n\tchangeEntityHashesToFriendly(entity, Object.fromEntries(Object.entries(friendly).map((a) => [a[1], a[0]])))\n}\n"], "fixing_code": ["<script lang=\"ts\">\n\timport jQuery from \"jquery\"\n\timport \"jstree\"\n\timport \"./treeview.css\"\n\n\timport type { Entity } from \"$lib/quickentity-types\"\n\timport { getReferencedLocalEntity, sanitise } from \"$lib/utils\"\n\n\timport { createEventDispatcher, onMount } from \"svelte\"\n\timport { v4 } from \"uuid\"\n\timport json from \"$lib/json\"\n\timport isEqual from \"lodash/isEqual\"\n\n\texport let entity: Entity\n\texport let reverseReferences: Record<\n\t\tstring,\n\t\t{\n\t\t\ttype: string\n\t\t\tentity: string\n\t\t\tcontext?: string[]\n\t\t}[]\n\t>\n\n\texport let currentlySelected: string = null!\n\n\texport const elemID = \"tree-\" + v4().replaceAll(\"-\", \"\")\n\n\texport let tree: JSTree = null!\n\n\tconst dispatch = createEventDispatcher()\n\n\tconst icons = Object.entries({\n\t\t\"[assembly:/templates/gameplay/ai2/actors.template?/npcactor.entitytemplate].pc_entitytype\": \"far fa-user\",\n\t\t\"[assembly:/_pro/characters/templates/hero/agent47/agent47.template?/agent47_default.entitytemplate].pc_entitytype\": \"far fa-user-circle\",\n\t\t\"[assembly:/_pro/design/levelflow.template?/herospawn.entitytemplate].pc_entitytype\": \"far fa-user-circle\",\n\t\t\"[modules:/zglobaloutfitkit.class].pc_entitytype\": \"fas fa-tshirt\",\n\t\t\"[modules:/zroomentity.class].pc_entitytype\": \"fas fa-map-marker-alt\",\n\t\t\"[modules:/zboxvolumeentity.class].pc_entitytype\": \"far fa-square\",\n\t\t\"[modules:/zsoundbankentity.class].pc_entitytype\": \"fas fa-music\",\n\t\t\"[modules:/zcameraentity.class].pc_entitytype\": \"fas fa-camera\",\n\t\t\"[modules:/zsequenceentity.class].pc_entitytype\": \"fas fa-film\",\n\t\t\"[modules:/zhitmandamageovertime.class].pc_entitytype\": \"fas fa-skull-crossbones\",\n\t\t\"0059FBD4AEBCDED0\": \"far fa-comment\", // Hashes\n\n\t\t\"levelflow.template?/exit\": \"fas fa-sign-out-alt\",\n\t\tzitem: \"fas fa-wrench\", // Specific\n\n\t\tblockup: \"fas fa-cube\",\n\t\tsetpiece_container_body: \"fas fa-box-open\",\n\t\tsetpiece_trap: \"fas fa-skull-crossbones\",\n\t\tanimset: \"fas fa-running\",\n\t\temitter: \"fas fa-wifi\",\n\t\tsender: \"fas fa-wifi\",\n\t\tevent: \"fas fa-location-arrow\",\n\t\tdeath: \"fas fa-skull\",\n\t\tzone: \"far fa-square\", // Types\n\n\t\t\"foliage/\": \"fas fa-seedling\",\n\t\t\"vehicles/\": \"fas fa-car-side\",\n\t\t\"environment/\": \"far fa-map\",\n\t\t\"logic/\": \"fas fa-cogs\",\n\t\t\"design/\": \"fas fa-swatchbook\",\n\t\t\"modules:/\": \"fas fa-project-diagram\" // Paths\n\t})\n\n\tonMount(async () => {\n\t\tjQuery(\"#\" + elemID).jstree({\n\t\t\tcore: {\n\t\t\t\tmultiple: false,\n\t\t\t\tdata: [],\n\t\t\t\tthemes: {\n\t\t\t\t\tname: \"default\",\n\t\t\t\t\tdots: true,\n\t\t\t\t\ticons: true\n\t\t\t\t},\n\t\t\t\tcheck_callback: true,\n\t\t\t\tforce_text: true\n\t\t\t},\n\t\t\tsearch: {\n\t\t\t\tfuzzy: true,\n\t\t\t\tshow_only_matches: true,\n\t\t\t\tclose_opened_onclear: false,\n\t\t\t\tsearch_callback: (search: string, node: { id: string }) => {\n\t\t\t\t\tif (search.startsWith(\":\")) {\n\t\t\t\t\t\tif (entity.entities[node.id]) {\n\t\t\t\t\t\t\treturn eval(search.slice(1))({ ...entity.entities[node.id], id: node.id })\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn (json.stringify(entity.entities[node.id] || entity.comments[Number(node.id.split(\"-\")[1])]) + node.id).toLowerCase().includes(search)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tsort: function (a: any, b: any) {\n\t\t\t\tif (\n\t\t\t\t\t(!(this.get_node(a).original ? this.get_node(a).original : this.get_node(a)).folder && !(this.get_node(b).original ? this.get_node(b).original : this.get_node(b)).folder) ||\n\t\t\t\t\t((this.get_node(a).original ? this.get_node(a).original : this.get_node(a)).folder && (this.get_node(b).original ? this.get_node(b).original : this.get_node(b)).folder)\n\t\t\t\t) {\n\t\t\t\t\treturn this.get_text(a).localeCompare(this.get_text(b), undefined, { numeric: true, sensitivity: \"base\" }) > 0 ? 1 : -1\n\t\t\t\t} else {\n\t\t\t\t\treturn (this.get_node(a).original ? this.get_node(a).original : this.get_node(a)).folder ? -1 : 1\n\t\t\t\t}\n\t\t\t},\n\t\t\tcontextmenu: {\n\t\t\t\tselect_node: false,\n\t\t\t\titems: (b: { id: string }, c: any) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\trename: {\n\t\t\t\t\t\t\tseparator_before: false,\n\t\t\t\t\t\t\tseparator_after: false,\n\t\t\t\t\t\t\t_disabled: false,\n\t\t\t\t\t\t\tlabel: \"Rename\",\n\t\t\t\t\t\t\ticon: \"far fa-pen-to-square\",\n\t\t\t\t\t\t\taction: function (b: { reference: string | HTMLElement | JQuery<HTMLElement> }) {\n\t\t\t\t\t\t\t\tvar c = jQuery.jstree!.reference(b.reference),\n\t\t\t\t\t\t\t\t\td = c.get_node(b.reference)\n\t\t\t\t\t\t\t\tc.edit(d)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tplugins: [\"contextmenu\", \"search\", \"sort\"]\n\t\t})\n\n\t\ttree = jQuery(\"#\" + elemID).jstree()\n\n\t\tjQuery(\"#\" + elemID).on(\"changed.jstree\", (...data) => {\n\t\t\tif (data[1].action == \"select_node\" && data[1].node.id != currentlySelected) {\n\t\t\t\tcurrentlySelected = data[1].node.id\n\t\t\t\tdispatch(\"selectionUpdate\", data)\n\t\t\t}\n\t\t})\n\t\tjQuery(\"#\" + elemID).on(\"rename_node.jstree\", (...data) => dispatch(\"nodeRenamed\", data))\n\t})\n\n\texport function refreshTree(\n\t\tentity: Entity,\n\t\treverseReferences: Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\ttype: string\n\t\t\t\tentity: string\n\t\t\t\tcontext?: string[]\n\t\t\t}[]\n\t\t>\n\t) {\n\t\ttree.settings!.core.data = []\n\n\t\tfor (let [entityID, entityData] of Object.entries(entity.entities)) {\n\t\t\ttree.settings!.core.data.push({\n\t\t\t\tid: String(entityID),\n\t\t\t\tparent: getReferencedLocalEntity(entityData.parent) || \"#\",\n\t\t\t\ticon:\n\t\t\t\t\tentityData.factory == \"[modules:/zentity.class].pc_entitytype\" && reverseReferences[entityID].some((a) => a.type == \"parent\")\n\t\t\t\t\t\t? \"far fa-folder\"\n\t\t\t\t\t\t: icons.find((a) => entityData.factory.includes(a[0]))\n\t\t\t\t\t\t? icons.find((a) => entityData.factory.includes(a[0]))![1]\n\t\t\t\t\t\t: \"far fa-file\",\n\t\t\t\ttext: `${sanitise(entityData.name)} (ref ${entityID})`,\n\t\t\t\tfolder: entityData.factory == \"[modules:/zentity.class].pc_entitytype\" && reverseReferences[entityID].some((a) => a.type == \"parent\") // for sorting and stuff\n\t\t\t})\n\t\t}\n\n\t\tlet index = 0\n\t\tfor (let entry of entity.comments) {\n\t\t\ttree.settings!.core.data.push({\n\t\t\t\tid: \"comment-\" + index,\n\t\t\t\tparent: getReferencedLocalEntity(entry.parent) || \"#\",\n\t\t\t\ticon: \"far fa-sticky-note\",\n\t\t\t\ttext: sanitise(entry.name) + \" (comment)\",\n\t\t\t\tfolder: false // for sorting and stuff\n\t\t\t})\n\n\t\t\tindex++\n\t\t}\n\n\t\tsetTimeout(() => {\n\t\t\ttry {\n\t\t\t\ttree.get_node(currentlySelected, true)[0].scrollIntoView()\n\t\t\t} catch {}\n\t\t}, 100)\n\n\t\ttree.refresh()\n\t}\n\n\tlet oldEntityNames: string[] = []\n\tlet oldComments = \"\"\n\tlet oldEntityCount = 0\n\n\t$: if (tree) {\n\t\tif (\n\t\t\t!isEqual(\n\t\t\t\tObject.values(entity.entities).map((a) => a.name),\n\t\t\t\toldEntityNames\n\t\t\t) ||\n\t\t\tObject.keys(entity.entities).length != oldEntityCount ||\n\t\t\tentity.comments.map((a) => a.parent + a.name).join(\"\") != oldComments\n\t\t) {\n\t\t\tif (Object.keys(entity.entities).every((entityID) => reverseReferences[entityID])) {\n\t\t\t\trefreshTree(entity, reverseReferences)\n\t\t\t\toldEntityNames = Object.values(entity.entities).map((a) => a.name)\n\t\t\t\toldEntityCount = Object.keys(entity.entities).length\n\t\t\t\toldComments = entity.comments.map((a) => a.parent + a.name).join(\"\")\n\t\t\t}\n\t\t}\n\t}\n</script>\n\n<div id={elemID} />\n", "<script lang=\"ts\">\n\timport jQuery from \"jquery\"\n\timport \"jstree\"\n\timport \"./treeview.css\"\n\n\timport type { Entity, FullRef, Ref, RefWithConstantValue, SubEntity } from \"$lib/quickentity-types\"\n\timport { changeReferenceToLocalEntity, genRandHex, getReferencedEntities, getReferencedExternalEntities, getReferencedLocalEntity, normaliseToHash, sanitise, traverseEntityTree } from \"$lib/utils\"\n\n\timport { createEventDispatcher, onMount } from \"svelte\"\n\timport { v4 } from \"uuid\"\n\timport * as clipboard from \"@tauri-apps/api/clipboard\"\n\timport json from \"$lib/json\"\n\timport isEqual from \"lodash/isEqual\"\n\timport { gameServer } from \"$lib/in-vivo/gameServer\"\n\timport { addNotification, appSettings, intellisense, inVivoMetadata } from \"$lib/stores\"\n\timport { readTextFile } from \"@tauri-apps/api/fs\"\n\timport { join } from \"@tauri-apps/api/path\"\n\n\texport let entity: Entity\n\texport let reverseReferences: Record<\n\t\tstring,\n\t\t{\n\t\t\ttype: string\n\t\t\tentity: string\n\t\t\tcontext?: string[]\n\t\t}[]\n\t>\n\texport let inVivoExtensions: boolean\n\n\texport let currentlySelected: string = null!\n\texport let previouslySelected: string = null!\n\texport let editorIsValid: boolean\n\texport let autoHighlightEntities: boolean\n\n\texport const elemID = \"tree-\" + v4().replaceAll(\"-\", \"\")\n\n\texport let tree: JSTree = null!\n\n\texport let helpMenuOpen: boolean = false\n\texport let helpMenuFactory: string = \"\"\n\texport let helpMenuProps: SubEntity[\"properties\"] = {}\n\texport let helpMenuInputs: string[] = []\n\texport let helpMenuOutputs: string[] = []\n\n\tconst dispatch = createEventDispatcher()\n\n\tconst exists = async (path: string) => {\n\t\ttry {\n\t\t\treturn await tauriExists(path)\n\t\t} catch {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tconst icons = Object.entries({\n\t\t\"[assembly:/templates/gameplay/ai2/actors.template?/npcactor.entitytemplate].pc_entitytype\": \"far fa-user\",\n\t\t\"[assembly:/_pro/characters/templates/hero/agent47/agent47.template?/agent47_default.entitytemplate].pc_entitytype\": \"far fa-user-circle\",\n\t\t\"[assembly:/_pro/design/levelflow.template?/herospawn.entitytemplate].pc_entitytype\": \"far fa-user-circle\",\n\t\t\"[modules:/zglobaloutfitkit.class].pc_entitytype\": \"fas fa-tshirt\",\n\t\t\"[modules:/zroomentity.class].pc_entitytype\": \"fas fa-map-marker-alt\",\n\t\t\"[modules:/zboxvolumeentity.class].pc_entitytype\": \"far fa-square\",\n\t\t\"[modules:/zsoundbankentity.class].pc_entitytype\": \"fas fa-music\",\n\t\t\"[modules:/zcameraentity.class].pc_entitytype\": \"fas fa-camera\",\n\t\t\"[modules:/zsequenceentity.class].pc_entitytype\": \"fas fa-film\",\n\t\t\"[modules:/zhitmandamageovertime.class].pc_entitytype\": \"fas fa-skull-crossbones\",\n\t\t\"0059FBD4AEBCDED0\": \"far fa-comment\", // Hashes\n\n\t\t\"levelflow.template?/exit\": \"fas fa-sign-out-alt\",\n\t\tzitem: \"fas fa-wrench\", // Specific\n\n\t\tblockup: \"fas fa-cube\",\n\t\tsetpiece_container_body: \"fas fa-box-open\",\n\t\tsetpiece_trap: \"fas fa-skull-crossbones\",\n\t\tanimset: \"fas fa-running\",\n\t\temitter: \"fas fa-wifi\",\n\t\tsender: \"fas fa-wifi\",\n\t\tevent: \"fas fa-location-arrow\",\n\t\tdeath: \"fas fa-skull\",\n\t\tzone: \"far fa-square\", // Types\n\n\t\t\"foliage/\": \"fas fa-seedling\",\n\t\t\"vehicles/\": \"fas fa-car-side\",\n\t\t\"environment/\": \"far fa-map\",\n\t\t\"logic/\": \"fas fa-cogs\",\n\t\t\"design/\": \"fas fa-swatchbook\",\n\t\t\"modules:/\": \"fas fa-project-diagram\" // Paths\n\t})\n\n\tonMount(async () => {\n\t\tjQuery(\"#\" + elemID).jstree({\n\t\t\tcore: {\n\t\t\t\tmultiple: false,\n\t\t\t\tdata: [],\n\t\t\t\tthemes: {\n\t\t\t\t\tname: \"default\",\n\t\t\t\t\tdots: true,\n\t\t\t\t\ticons: true\n\t\t\t\t},\n\t\t\t\tcheck_callback: true,\n\t\t\t\tforce_text: true\n\t\t\t},\n\t\t\tsearch: {\n\t\t\t\tfuzzy: true,\n\t\t\t\tshow_only_matches: true,\n\t\t\t\tclose_opened_onclear: false,\n\t\t\t\tsearch_callback: (search: string, node: { id: string }) => {\n\t\t\t\t\tif (search.startsWith(\":\")) {\n\t\t\t\t\t\tif (entity.entities[node.id]) {\n\t\t\t\t\t\t\treturn eval(search.slice(1))({ ...entity.entities[node.id], id: node.id })\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn (json.stringify(entity.entities[node.id] || entity.comments[Number(node.id.split(\"-\")[1])]) + node.id).toLowerCase().includes(search)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tsort: function (a: any, b: any) {\n\t\t\t\tif (\n\t\t\t\t\t(!(this.get_node(a).original ? this.get_node(a).original : this.get_node(a)).folder && !(this.get_node(b).original ? this.get_node(b).original : this.get_node(b)).folder) ||\n\t\t\t\t\t((this.get_node(a).original ? this.get_node(a).original : this.get_node(a)).folder && (this.get_node(b).original ? this.get_node(b).original : this.get_node(b)).folder)\n\t\t\t\t) {\n\t\t\t\t\treturn this.get_text(a).localeCompare(this.get_text(b), undefined, { numeric: true, sensitivity: \"base\" }) > 0 ? 1 : -1\n\t\t\t\t} else {\n\t\t\t\t\treturn (this.get_node(a).original ? this.get_node(a).original : this.get_node(a)).folder ? -1 : 1\n\t\t\t\t}\n\t\t\t},\n\t\t\tcontextmenu: {\n\t\t\t\tselect_node: false,\n\t\t\t\titems: (b: { id: string }, c: any) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tcreate: {\n\t\t\t\t\t\t\tseparator_before: false,\n\t\t\t\t\t\t\tseparator_after: true,\n\t\t\t\t\t\t\t_disabled: false,\n\t\t\t\t\t\t\tlabel: \"Create\",\n\t\t\t\t\t\t\ticon: \"fas fa-plus\",\n\t\t\t\t\t\t\taction: function (b: { reference: string | HTMLElement | JQuery<HTMLElement> }) {\n\t\t\t\t\t\t\t\tvar c = jQuery.jstree!.reference(b.reference),\n\t\t\t\t\t\t\t\t\td = c.get_node(b.reference)\n\t\t\t\t\t\t\t\tc.create_node(d, {}, \"last\", function (a: any) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tc.edit(a)\n\t\t\t\t\t\t\t\t\t} catch (b) {\n\t\t\t\t\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t\t\t\t\tc.edit(a)\n\t\t\t\t\t\t\t\t\t\t}, 0)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreateComment: {\n\t\t\t\t\t\t\tseparator_before: false,\n\t\t\t\t\t\t\tseparator_after: true,\n\t\t\t\t\t\t\t_disabled: false,\n\t\t\t\t\t\t\tlabel: \"Add Comment\",\n\t\t\t\t\t\t\ticon: \"far fa-sticky-note\",\n\t\t\t\t\t\t\taction: function (b: { reference: string | HTMLElement | JQuery<HTMLElement> }) {\n\t\t\t\t\t\t\t\tentity.comments = [\n\t\t\t\t\t\t\t\t\t...entity.comments,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tparent: jQuery.jstree!.reference(b.reference).get_node(b.reference).id,\n\t\t\t\t\t\t\t\t\t\tname: \"New Comment\",\n\t\t\t\t\t\t\t\t\t\ttext: \"\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\trename: {\n\t\t\t\t\t\t\tseparator_before: false,\n\t\t\t\t\t\t\tseparator_after: false,\n\t\t\t\t\t\t\t_disabled: false,\n\t\t\t\t\t\t\tlabel: \"Rename\",\n\t\t\t\t\t\t\ticon: \"far fa-pen-to-square\",\n\t\t\t\t\t\t\taction: function (b: { reference: string | HTMLElement | JQuery<HTMLElement> }) {\n\t\t\t\t\t\t\t\tvar c = jQuery.jstree!.reference(b.reference),\n\t\t\t\t\t\t\t\t\td = c.get_node(b.reference)\n\t\t\t\t\t\t\t\tc.edit(d)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tremove: {\n\t\t\t\t\t\t\tseparator_before: false,\n\t\t\t\t\t\t\tseparator_after: false,\n\t\t\t\t\t\t\t_disabled: false,\n\t\t\t\t\t\t\tlabel: \"Delete\",\n\t\t\t\t\t\t\ticon: \"far fa-trash-can\",\n\t\t\t\t\t\t\taction: function (b: { reference: string | HTMLElement | JQuery<HTMLElement> }) {\n\t\t\t\t\t\t\t\tvar c = jQuery.jstree!.reference(b.reference),\n\t\t\t\t\t\t\t\t\td = c.get_node(b.reference)\n\t\t\t\t\t\t\t\tc.is_selected(d) ? c.delete_node(c.get_selected()) : c.delete_node(d)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t...(!inVivoExtensions || b.id.startsWith(\"comment\") || !gameServer.connected || !gameServer.lastAddress\n\t\t\t\t\t\t\t? {}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tinVivo: {\n\t\t\t\t\t\t\t\t\t\tseparator_before: true,\n\t\t\t\t\t\t\t\t\t\tseparator_after: false,\n\t\t\t\t\t\t\t\t\t\tlabel: \"In-Vivo\",\n\t\t\t\t\t\t\t\t\t\ticon: \"fas fa-right-left\",\n\t\t\t\t\t\t\t\t\t\taction: false,\n\t\t\t\t\t\t\t\t\t\tsubmenu: {\n\t\t\t\t\t\t\t\t\t\t\thighlight: {\n\t\t\t\t\t\t\t\t\t\t\t\tseparator_before: false,\n\t\t\t\t\t\t\t\t\t\t\t\tseparator_after: false,\n\t\t\t\t\t\t\t\t\t\t\t\tlabel: \"Highlight\",\n\t\t\t\t\t\t\t\t\t\t\t\ticon: \"fas fa-highlighter\",\n\t\t\t\t\t\t\t\t\t\t\t\taction: async (b: { reference: string | HTMLElement | JQuery<HTMLElement> }) => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet d = tree.get_node(b.reference)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tawait gameServer.highlightEntity(d.id, entity.entities[d.id])\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t$addNotification = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tkind: \"success\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttitle: \"Entity highlighted\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsubtitle: \"Check your game; the entity should now be displaying its bounding box.\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tmoveToPlayerPosition: {\n\t\t\t\t\t\t\t\t\t\t\t\tseparator_before: false,\n\t\t\t\t\t\t\t\t\t\t\t\tseparator_after: false,\n\t\t\t\t\t\t\t\t\t\t\t\tlabel: \"Move to Player Position\",\n\t\t\t\t\t\t\t\t\t\t\t\ticon: \"fas fa-location-dot\",\n\t\t\t\t\t\t\t\t\t\t\t\taction: async (b: { reference: string | HTMLElement | JQuery<HTMLElement> }) => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet d = tree.get_node(b.reference)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet playerPos = await gameServer.getPlayerPosition()\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tentity.entities[d.id].properties ??= {}\n\t\t\t\t\t\t\t\t\t\t\t\t\tentity.entities[d.id].properties!.m_mTransform ??= {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"SMatrix43\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\trotation: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tz: 0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tposition: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tz: 0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (entity.entities[d.id].properties!.m_eidParent) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tentity.entities[d.id].properties = Object.fromEntries(Object.entries(entity.entities[d.id].properties!).filter((a) => a[0] != \"m_eidParent\"))\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// TODO: this isn't always going to work so it should probably be hooked up to intellisense in case of aliases or such\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tentity.entities[d.id].properties!.m_eRoomBehaviour = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"ZSpatialEntity.ERoomBehaviour\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: \"ROOM_DYNAMIC\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tentity.entities[d.id].properties!.m_mTransform.value.position.x = playerPos.x\n\t\t\t\t\t\t\t\t\t\t\t\t\tentity.entities[d.id].properties!.m_mTransform.value.position.y = playerPos.y\n\t\t\t\t\t\t\t\t\t\t\t\t\tentity.entities[d.id].properties!.m_mTransform.value.position.z = playerPos.z\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tdispatch(\"entityUpdated\", d.id)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tawait gameServer.updateProperty(d.id, \"m_mTransform\", entity.entities[d.id].properties!.m_mTransform)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t$inVivoMetadata.entities[d.id] ??= {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdirtyPins: false,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdirtyUnchangeables: false,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdirtyExtensions: false,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdirtyProperties: [],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thasSetProperties: false\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t$inVivoMetadata.entities[d.id].dirtyProperties = $inVivoMetadata.entities[d.id].dirtyProperties.filter((a) => a != \"m_mTransform\")\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t$addNotification = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tkind: \"success\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttitle: \"Entity set to player position\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsubtitle: \"The m_mTransform property has been updated accordingly.\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tadjustRotationToPlayer: {\n\t\t\t\t\t\t\t\t\t\t\t\tseparator_before: false,\n\t\t\t\t\t\t\t\t\t\t\t\tseparator_after: false,\n\t\t\t\t\t\t\t\t\t\t\t\tlabel: \"Adjust Rotation to Player\",\n\t\t\t\t\t\t\t\t\t\t\t\ticon: \"fas fa-compass\",\n\t\t\t\t\t\t\t\t\t\t\t\taction: async (b: { reference: string | HTMLElement | JQuery<HTMLElement> }) => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet d = tree.get_node(b.reference)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet playerRot = await gameServer.getPlayerRotation()\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tentity.entities[d.id].properties ??= {}\n\t\t\t\t\t\t\t\t\t\t\t\t\tentity.entities[d.id].properties!.m_mTransform ??= {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: \"SMatrix43\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\trotation: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tz: 0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tposition: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tz: 0\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tentity.entities[d.id].properties!.m_mTransform.value.rotation.x = playerRot.x\n\t\t\t\t\t\t\t\t\t\t\t\t\tentity.entities[d.id].properties!.m_mTransform.value.rotation.y = playerRot.y\n\t\t\t\t\t\t\t\t\t\t\t\t\tentity.entities[d.id].properties!.m_mTransform.value.rotation.z = playerRot.z\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tdispatch(\"entityUpdated\", d.id)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tawait gameServer.updateProperty(d.id, \"m_mTransform\", entity.entities[d.id].properties!.m_mTransform)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t$inVivoMetadata.entities[d.id] ??= {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdirtyPins: false,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdirtyUnchangeables: false,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdirtyExtensions: false,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdirtyProperties: [],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thasSetProperties: false\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t$inVivoMetadata.entities[d.id].dirtyProperties = $inVivoMetadata.entities[d.id].dirtyProperties.filter((a) => a != \"m_mTransform\")\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t$addNotification = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tkind: \"success\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttitle: \"Entity set to player rotation\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsubtitle: \"The m_mTransform property has been updated accordingly.\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t  }),\n\t\t\t\t\t\tccp: {\n\t\t\t\t\t\t\tseparator_before: true,\n\t\t\t\t\t\t\tseparator_after: false,\n\t\t\t\t\t\t\tlabel: \"Clipboard\",\n\t\t\t\t\t\t\ticon: \"far fa-clipboard\",\n\t\t\t\t\t\t\taction: false,\n\t\t\t\t\t\t\tsubmenu: {\n\t\t\t\t\t\t\t\tcopy: {\n\t\t\t\t\t\t\t\t\tseparator_before: false,\n\t\t\t\t\t\t\t\t\tseparator_after: false,\n\t\t\t\t\t\t\t\t\tlabel: \"Copy Entity\",\n\t\t\t\t\t\t\t\t\ticon: \"far fa-copy\",\n\t\t\t\t\t\t\t\t\taction: async (b: { reference: string | HTMLElement | JQuery<HTMLElement> }) => {\n\t\t\t\t\t\t\t\t\t\tlet d = tree.get_node(b.reference)\n\t\t\t\t\t\t\t\t\t\tlet copiedEntity: Record<string, any> = {}\n\n\t\t\t\t\t\t\t\t\t\tcopiedEntity[d.id] = json.parse(json.stringify(entity.entities[d.id]))\n\t\t\t\t\t\t\t\t\t\tObject.assign(\n\t\t\t\t\t\t\t\t\t\t\tcopiedEntity,\n\t\t\t\t\t\t\t\t\t\t\tjson.parse(json.stringify(Object.fromEntries([...new Set(traverseEntityTree(entity, d.id, reverseReferences))].map((a) => [a, entity.entities[a]]))))\n\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\t\tcopiedEntity.origin = entity.tempHash\n\n\t\t\t\t\t\t\t\t\t\tawait clipboard.writeText(json.stringify(copiedEntity))\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tpaste: {\n\t\t\t\t\t\t\t\t\tseparator_before: false,\n\t\t\t\t\t\t\t\t\t_disabled: false,\n\t\t\t\t\t\t\t\t\tseparator_after: false,\n\t\t\t\t\t\t\t\t\tlabel: \"Paste Entity\",\n\t\t\t\t\t\t\t\t\ticon: \"far fa-paste\",\n\t\t\t\t\t\t\t\t\taction: async (b: { reference: string | HTMLElement | JQuery<HTMLElement> }) => {\n\t\t\t\t\t\t\t\t\t\tlet d = tree.get_node(b.reference)\n\t\t\t\t\t\t\t\t\t\tlet pastedEntity = json.parse((await clipboard.readText())!)\n\n\t\t\t\t\t\t\t\t\t\tlet removeExternalRefs = pastedEntity.origin != entity.tempHash\n\t\t\t\t\t\t\t\t\t\tdelete pastedEntity.origin\n\n\t\t\t\t\t\t\t\t\t\tlet changedEntityIDs: Record<string, string> = {}\n\t\t\t\t\t\t\t\t\t\tfor (let ent of Object.entries(pastedEntity)) {\n\t\t\t\t\t\t\t\t\t\t\tchangedEntityIDs[ent[0]] = \"feed\" + genRandHex(12)\n\n\t\t\t\t\t\t\t\t\t\t\tpastedEntity[changedEntityIDs[ent[0]]] = ent[1]\n\t\t\t\t\t\t\t\t\t\t\tdelete pastedEntity[ent[0]]\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tlet paste: Record<string, SubEntity> = pastedEntity\n\n\t\t\t\t\t\t\t\t\t\tfor (let [entID, ent] of Object.entries(paste)) {\n\t\t\t\t\t\t\t\t\t\t\tconst localRef = getReferencedLocalEntity(ent.parent)\n\t\t\t\t\t\t\t\t\t\t\tent.parent = localRef && changedEntityIDs[localRef] ? changeReferenceToLocalEntity(ent.parent, changedEntityIDs[localRef]) : ent.parent\n\n\t\t\t\t\t\t\t\t\t\t\tfor (let ref of getReferencedEntities(ent)) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (changedEntityIDs[ref.entity]) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tswitch (ref.type) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"property\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Array.isArray(ent.properties![ref.context![0]].value)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.properties![ref.context![0]].value.splice(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.properties![ref.context![0]].value.findIndex((a: Ref) => getReferencedLocalEntity(a) == ref.entity),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchangeReferenceToLocalEntity(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.properties![ref.context![0]].value.find((a: Ref) => getReferencedLocalEntity(a) == ref.entity),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchangedEntityIDs[ref.entity]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.properties![ref.context![0]].value = changeReferenceToLocalEntity(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.properties![ref.context![0]].value,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchangedEntityIDs[ref.entity]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"platformSpecificProperty\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Array.isArray(ent.platformSpecificProperties![ref.context![0]][ref.context![1]].value)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.platformSpecificProperties![ref.context![0]][ref.context![1]].value.splice(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.platformSpecificProperties![ref.context![0]][ref.context![1]].value.findIndex(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(a: Ref) => getReferencedLocalEntity(a) == ref.entity\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchangeReferenceToLocalEntity(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.platformSpecificProperties![ref.context![0]][ref.context![1]].value.find(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(a: Ref) => getReferencedLocalEntity(a) == ref.entity\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchangedEntityIDs[ref.entity]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.platformSpecificProperties![ref.context![0]][ref.context![1]].value = changeReferenceToLocalEntity(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.platformSpecificProperties![ref.context![0]][ref.context![1]].value,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchangedEntityIDs[ref.entity]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"event\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet evtIndex = ent.events![ref.context![0]][ref.context![1]].findIndex(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(a) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgetReferencedLocalEntity(a && typeof a != \"string\" && Object.prototype.hasOwnProperty.call(a, \"value\") ? a.ref : (a as FullRef)) ==\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tref.entity\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet evt = ent.events![ref.context![0]][ref.context![1]][evtIndex]\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.events![ref.context![0]][ref.context![1]].splice(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tevtIndex,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tevt && typeof evt != \"string\" && Object.prototype.hasOwnProperty.call(evt, \"value\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tref: changeReferenceToLocalEntity(evt.ref, changedEntityIDs[ref.entity]),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: (evt as RefWithConstantValue).value\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: changeReferenceToLocalEntity(evt as FullRef, changedEntityIDs[ref.entity])\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"inputCopy\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet evt2Index = ent.inputCopying![ref.context![0]][ref.context![1]].findIndex(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(a) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgetReferencedLocalEntity(a && typeof a != \"string\" && Object.prototype.hasOwnProperty.call(a, \"value\") ? a.ref : (a as FullRef)) ==\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tref.entity\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet evt2 = ent.inputCopying![ref.context![0]][ref.context![1]][evt2Index]\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.inputCopying![ref.context![0]][ref.context![1]].splice(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tevt2Index,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tevt2 && typeof evt2 != \"string\" && Object.prototype.hasOwnProperty.call(evt2, \"value\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tref: changeReferenceToLocalEntity(evt2.ref, changedEntityIDs[ref.entity]),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: (evt2 as RefWithConstantValue).value\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: changeReferenceToLocalEntity(evt2 as FullRef, changedEntityIDs[ref.entity])\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"outputCopy\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet evt3Index = ent.outputCopying![ref.context![0]][ref.context![1]].findIndex(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(a) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgetReferencedLocalEntity(a && typeof a != \"string\" && Object.prototype.hasOwnProperty.call(a, \"value\") ? a.ref : (a as FullRef)) ==\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tref.entity\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet evt3 = ent.outputCopying![ref.context![0]][ref.context![1]][evt3Index]\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.outputCopying![ref.context![0]][ref.context![1]].splice(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tevt3Index,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tevt3 && typeof evt3 != \"string\" && Object.prototype.hasOwnProperty.call(evt3, \"value\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tref: changeReferenceToLocalEntity(evt3.ref, changedEntityIDs[ref.entity]),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: (evt3 as RefWithConstantValue).value\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: changeReferenceToLocalEntity(evt3 as FullRef, changedEntityIDs[ref.entity])\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"propertyAlias\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.propertyAliases![ref.context![0]].splice(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.propertyAliases![ref.context![0]].findIndex((a) => isEqual(a, { originalProperty: ref.context![1], originalEntity: ref.entity })),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tObject.assign(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.propertyAliases![ref.context![0]].find((a) => isEqual(a, { originalProperty: ref.context![1], originalEntity: ref.entity }))!,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\toriginalEntity: changedEntityIDs[ref.entity]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"exposedEntity\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.exposedEntities![ref.context![0]].refersTo.splice(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.exposedEntities![ref.context![0]].refersTo.findIndex((a) => getReferencedLocalEntity(a) == ref.entity),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchangeReferenceToLocalEntity(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.exposedEntities![ref.context![0]].refersTo.find((a) => getReferencedLocalEntity(a) == ref.entity)!,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchangedEntityIDs[ref.entity]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"exposedInterface\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.exposedInterfaces![ref.context![0]] = changedEntityIDs[ref.entity]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"subset\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.subsets![ref.context![0]].splice(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.subsets![ref.context![0]].findIndex((a) => getReferencedLocalEntity(a) == ref.entity),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchangedEntityIDs[ref.entity]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tif (removeExternalRefs) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor (let ref of getReferencedExternalEntities(ent, paste)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet localRef = getReferencedLocalEntity(ref.entity)\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (!localRef || !entity.entities[localRef]) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tswitch (ref.type) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"property\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Array.isArray(ent.properties![ref.context![0]].value)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.properties![ref.context![0]].value = ent.properties![ref.context![0]].value.filter((a: Ref) => !isEqual(a, ref.entity))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdelete ent.properties![ref.context![0]]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"platformSpecificProperty\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Array.isArray(ent.platformSpecificProperties![ref.context![0]][ref.context![1]].value)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.platformSpecificProperties![ref.context![0]][ref.context![1]].value = ent.platformSpecificProperties![ref.context![0]][\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tref.context![1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t].value.filter((a: Ref) => !isEqual(a, ref.entity))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdelete ent.platformSpecificProperties![ref.context![0]][ref.context![1]]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"event\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.events![ref.context![0]][ref.context![1]] = ent.events![ref.context![0]][ref.context![1]].filter(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(a) => !isEqual(a && typeof a != \"string\" && Object.prototype.hasOwnProperty.call(a, \"value\") ? a.ref : (a as FullRef), ref.entity)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"inputCopy\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.inputCopying![ref.context![0]][ref.context![1]] = ent.inputCopying![ref.context![0]][ref.context![1]].filter(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(a) => !isEqual(a && typeof a != \"string\" && Object.prototype.hasOwnProperty.call(a, \"value\") ? a.ref : (a as FullRef), ref.entity)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"outputCopy\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.outputCopying![ref.context![0]][ref.context![1]] = ent.outputCopying![ref.context![0]][ref.context![1]].filter(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(a) => !isEqual(a && typeof a != \"string\" && Object.prototype.hasOwnProperty.call(a, \"value\") ? a.ref : (a as FullRef), ref.entity)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"propertyAlias\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.propertyAliases![ref.context![0]] = ent.propertyAliases![ref.context![0]].filter(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(a) => !isEqual(a, { originalProperty: ref.context![1], originalEntity: ref.entity })\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"exposedEntity\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.exposedEntities![ref.context![0]].refersTo = ent.exposedEntities![ref.context![0]].refersTo.filter((a) => !isEqual(a, ref.entity))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"exposedInterface\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdelete ent.exposedInterfaces![ref.context![0]]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase \"subset\":\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tent.subsets![ref.context![0]] = ent.subsets![ref.context![0]].filter((a) => a != ref.entity)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tObject.assign(entity.entities, paste)\n\n\t\t\t\t\t\t\t\t\t\tentity.entities[Object.keys(paste)[0]].parent = changeReferenceToLocalEntity(entity.entities[Object.keys(paste)[0]].parent, d.id)\n\n\t\t\t\t\t\t\t\t\t\tdispatch(\"forceUpdateEntity\")\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcopyID: {\n\t\t\t\t\t\t\tseparator_before: false,\n\t\t\t\t\t\t\tseparator_after: false,\n\t\t\t\t\t\t\t_disabled: false,\n\t\t\t\t\t\t\tlabel: \"Copy ID\",\n\t\t\t\t\t\t\ticon: \"far fa-copy\",\n\t\t\t\t\t\t\taction: function (b: { reference: string | HTMLElement | JQuery<HTMLElement> }) {\n\t\t\t\t\t\t\t\tlet d = tree.get_node(b.reference)\n\n\t\t\t\t\t\t\t\tclipboard.writeText(d.id)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t...(!currentlySelected || !$appSettings.gameFileExtensions || b.id.startsWith(\"comment\")\n\t\t\t\t\t\t\t? {}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\thelp: {\n\t\t\t\t\t\t\t\t\t\tseparator_before: false,\n\t\t\t\t\t\t\t\t\t\tseparator_after: false,\n\t\t\t\t\t\t\t\t\t\t_disabled: false,\n\t\t\t\t\t\t\t\t\t\tlabel: \"Help\",\n\t\t\t\t\t\t\t\t\t\ticon: \"far fa-circle-question\",\n\t\t\t\t\t\t\t\t\t\taction: async function (b: { reference: string | HTMLElement | JQuery<HTMLElement> }) {\n\t\t\t\t\t\t\t\t\t\t\tlet d = tree.get_node(b.reference)\n\n\t\t\t\t\t\t\t\t\t\t\tlet entityID = d.id\n\t\t\t\t\t\t\t\t\t\t\tlet entityData = entity.entities[d.id]\n\n\t\t\t\t\t\t\t\t\t\t\thelpMenuFactory = entityData.factory\n\t\t\t\t\t\t\t\t\t\t\thelpMenuProps = {}\n\t\t\t\t\t\t\t\t\t\t\thelpMenuInputs = []\n\t\t\t\t\t\t\t\t\t\t\thelpMenuOutputs = []\n\n\t\t\t\t\t\t\t\t\t\t\tlet allFoundProperties = []\n\n\t\t\t\t\t\t\t\t\t\t\tfor (let factory of (await exists(await join($appSettings.gameFileExtensionsDataPath, \"ASET\", normaliseToHash(entityData.factory) + \".ASET.meta.JSON\")))\n\t\t\t\t\t\t\t\t\t\t\t\t? json\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.parse(await readTextFile(await join($appSettings.gameFileExtensionsDataPath, \"ASET\", normaliseToHash(entityData.factory) + \".ASET.meta.JSON\")))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.hash_reference_data.slice(0, -1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.map((a) => a.hash)\n\t\t\t\t\t\t\t\t\t\t\t\t: [normaliseToHash(entityData.factory)]) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (await exists(await join($appSettings.gameFileExtensionsDataPath, \"TEMP\", factory + \".TEMP.entity.json\"))) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tawait $intellisense.findProperties(await join($appSettings.gameFileExtensionsDataPath, \"TEMP\", factory + \".TEMP.entity.json\"), allFoundProperties)\n\t\t\t\t\t\t\t\t\t\t\t\t\tentityData.propertyAliases && allFoundProperties.push(...Object.keys(entityData.propertyAliases))\n\t\t\t\t\t\t\t\t\t\t\t\t} else if ($intellisense.knownCPPTProperties[factory]) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tallFoundProperties.push(...Object.keys($intellisense.knownCPPTProperties[factory]))\n\t\t\t\t\t\t\t\t\t\t\t\t} else if ($intellisense.allUICTs.has(factory)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tallFoundProperties.push(...Object.keys($intellisense.knownCPPTProperties[\"002C4526CC9753E6\"])) // All UI controls have the properties of ZUIControlEntity\n\t\t\t\t\t\t\t\t\t\t\t\t\tallFoundProperties.push(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t...Object.keys(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tjson.parse(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tawait readTextFile(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tawait join(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"./intellisense-data/UICB\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tjson\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.parse(await readTextFile(await join($appSettings.gameFileExtensionsDataPath, \"UICT\", factory + \".UICT.meta.JSON\")))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.hash_reference_data.filter((a) => a.hash != \"002C4526CC9753E6\")[0].hash + \".UICB.json\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t).properties\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t) // Get the specific properties from the UICB\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tallFoundProperties = [...new Set(allFoundProperties)]\n\n\t\t\t\t\t\t\t\t\t\t\thelpMenuProps = {}\n\n\t\t\t\t\t\t\t\t\t\t\tif ($intellisense.knownCPPTProperties[normaliseToHash(entityData.factory)]) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor (let foundProp of allFoundProperties) {\n\t\t\t\t\t\t\t\t\t\t\t\t\thelpMenuProps[foundProp] = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype: $intellisense.knownCPPTProperties[normaliseToHash(entityData.factory)][foundProp][0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: $intellisense.knownCPPTProperties[normaliseToHash(entityData.factory)][foundProp][1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tfor (let foundProp of allFoundProperties) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet val = await $intellisense.findDefaultPropertyValue(entity.tempHash + \".TEMP.entity.json\", entityID, foundProp, entity, entityID)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (val) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thelpMenuProps[foundProp] = val\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tlet pins = { input: [], output: [] }\n\t\t\t\t\t\t\t\t\t\t\tawait $intellisense.getPins(entity, entityID, true, pins)\n\t\t\t\t\t\t\t\t\t\t\thelpMenuInputs = [...new Set(pins.input)]\n\t\t\t\t\t\t\t\t\t\t\thelpMenuOutputs = [...new Set(pins.output)]\n\n\t\t\t\t\t\t\t\t\t\t\thelpMenuOpen = true\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t  })\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tplugins: [\"contextmenu\", \"dnd\", \"search\", \"sort\"]\n\t\t})\n\n\t\ttree = jQuery(\"#\" + elemID).jstree()\n\n\t\tjQuery(\"#\" + elemID).on(\"changed.jstree\", (...data) => {\n\t\t\tif (data[1].action == \"select_node\" && data[1].node.id != currentlySelected) {\n\t\t\t\tif (editorIsValid) {\n\t\t\t\t\tpreviouslySelected = currentlySelected\n\t\t\t\t\tcurrentlySelected = data[1].node.id\n\n\t\t\t\t\tif (inVivoExtensions && autoHighlightEntities && gameServer.connected && gameServer.lastAddress && !data[1].node.id.startsWith(\"comment\")) {\n\t\t\t\t\t\tgameServer.highlightEntity(data[1].node.id, entity.entities[data[1].node.id])\n\t\t\t\t\t}\n\n\t\t\t\t\tdispatch(\"selectionUpdate\", data)\n\t\t\t\t} else {\n\t\t\t\t\ttree.deselect_node(data[1].node.id)\n\t\t\t\t\ttree.select_node(currentlySelected)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tjQuery(\"#\" + elemID).on(\"move_node.jstree\", (...data) => dispatch(\"dragAndDrop\", data))\n\t\tjQuery(\"#\" + elemID).on(\"create_node.jstree\", (...data) => dispatch(\"nodeCreated\", data))\n\t\tjQuery(\"#\" + elemID).on(\"rename_node.jstree\", (...data) => dispatch(\"nodeRenamed\", data))\n\t\tjQuery(\"#\" + elemID).on(\"delete_node.jstree\", (...data) => dispatch(\"nodeDeleted\", data))\n\t})\n\n\texport function refreshTree(\n\t\tentity: Entity,\n\t\treverseReferences: Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\ttype: string\n\t\t\t\tentity: string\n\t\t\t\tcontext?: string[]\n\t\t\t}[]\n\t\t>\n\t) {\n\t\ttree.settings!.core.data = []\n\n\t\tfor (let [entityID, entityData] of Object.entries(entity.entities)) {\n\t\t\ttree.settings!.core.data.push({\n\t\t\t\tid: String(entityID),\n\t\t\t\tparent: getReferencedLocalEntity(entityData.parent) || \"#\",\n\t\t\t\ticon:\n\t\t\t\t\tentityData.factory == \"[modules:/zentity.class].pc_entitytype\" && reverseReferences[entityID].some((a) => a.type == \"parent\")\n\t\t\t\t\t\t? \"far fa-folder\"\n\t\t\t\t\t\t: icons.find((a) => entityData.factory.includes(a[0]))\n\t\t\t\t\t\t? icons.find((a) => entityData.factory.includes(a[0]))![1]\n\t\t\t\t\t\t: \"far fa-file\",\n\t\t\t\ttext: `${sanitise(entityData.name)} (ref ${entityID})`,\n\t\t\t\tfolder: entityData.factory == \"[modules:/zentity.class].pc_entitytype\" && reverseReferences[entityID].some((a) => a.type == \"parent\") // for sorting and stuff\n\t\t\t})\n\t\t}\n\n\t\tlet index = 0\n\t\tfor (let entry of entity.comments) {\n\t\t\ttree.settings!.core.data.push({\n\t\t\t\tid: \"comment-\" + index,\n\t\t\t\tparent: getReferencedLocalEntity(entry.parent) || \"#\",\n\t\t\t\ticon: \"far fa-sticky-note\",\n\t\t\t\ttext: sanitise(entry.name) + \" (comment)\",\n\t\t\t\tfolder: false // for sorting and stuff\n\t\t\t})\n\n\t\t\tindex++\n\t\t}\n\n\t\tsetTimeout(() => {\n\t\t\ttry {\n\t\t\t\ttree.get_node(currentlySelected, true)[0].scrollIntoView()\n\t\t\t} catch {}\n\t\t}, 100)\n\n\t\ttree.refresh()\n\t}\n\n\tlet oldEntityNames: string[] = []\n\tlet oldComments = \"\"\n\tlet oldEntityCount = 0\n\n\t$: if (tree) {\n\t\tif (\n\t\t\t!isEqual(\n\t\t\t\tObject.values(entity.entities).map((a) => a.name),\n\t\t\t\toldEntityNames\n\t\t\t) ||\n\t\t\tObject.keys(entity.entities).length != oldEntityCount ||\n\t\t\tentity.comments.map((a) => a.parent + a.name).join(\"\") != oldComments\n\t\t) {\n\t\t\tif (Object.keys(entity.entities).every((entityID) => reverseReferences[entityID])) {\n\t\t\t\trefreshTree(entity, reverseReferences)\n\t\t\t\toldEntityNames = Object.values(entity.entities).map((a) => a.name)\n\t\t\t\toldEntityCount = Object.keys(entity.entities).length\n\t\t\t\toldComments = entity.comments.map((a) => a.parent + a.name).join(\"\")\n\t\t\t}\n\t\t}\n\t}\n\n\texport function search(query: string) {\n\t\ttree.search(query.toLowerCase())\n\t}\n\n\texport function navigateTo(ent: string) {\n\t\ttree.deselect_node(currentlySelected)\n\t\ttree.select_node(ent)\n\t}\n\n\texport function deselect() {\n\t\ttree.deselect_all()\n\t\tcurrentlySelected = null!\n\t}\n\n\texport function getMatching(search: string) {\n\t\treturn tree.settings!.core.data.filter((node) => {\n\t\t\tif (search.startsWith(\":\")) {\n\t\t\t\tif (entity.entities[node.id]) {\n\t\t\t\t\treturn eval(search.slice(1))(entity.entities[node.id])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn (json.stringify(entity.entities[node.id] || entity.comments[Number(node.id.split(\"-\")[1])]) + node.id).toLowerCase().includes(search)\n\t\t\t}\n\t\t})\n\t}\n</script>\n\n<div id={elemID} />\n", "import type { Entity, FullRef, Ref, RefMaybeConstantValue, SubEntity } from \"$lib/quickentity-types\"\n\nimport Ajv from \"ajv\"\nimport cloneDeep from \"lodash/cloneDeep\"\nimport enums from \"$lib/enums.json\"\nimport isEqual from \"lodash/isEqual\"\nimport md5 from \"md5\"\nimport merge from \"lodash/merge\"\nimport propertyTypeSchemas from \"$lib/property-type-schemas.json\"\nimport schema from \"$lib/schema.json\"\n\nconst ajv = new Ajv({ keywords: [\"markdownDescription\"] }).compile(\n\tObject.assign({}, cloneDeep(schema), {\n\t\t$ref: \"#/definitions/SubEntity\"\n\t})\n)\n\nschema.definitions.SubEntity.properties.properties.additionalProperties = {\n\tanyOf: [\n\t\t...Object.entries(propertyTypeSchemas).map(([propType, valSchema]) => {\n\t\t\treturn merge({}, cloneDeep(schema.definitions.Property), {\n\t\t\t\tproperties: {\n\t\t\t\t\ttype: {\n\t\t\t\t\t\tconst: propType\n\t\t\t\t\t},\n\t\t\t\t\tvalue: valSchema\n\t\t\t\t},\n\t\t\t\tdefault: {\n\t\t\t\t\ttype: propType,\n\t\t\t\t\tvalue: valSchema.default\n\t\t\t\t}\n\t\t\t})\n\t\t}),\n\t\t...Object.entries(propertyTypeSchemas).map(([propType, valSchema]) => {\n\t\t\treturn merge({}, cloneDeep(schema.definitions.Property), {\n\t\t\t\tproperties: {\n\t\t\t\t\ttype: {\n\t\t\t\t\t\tconst: `TArray<${propType}>`\n\t\t\t\t\t},\n\t\t\t\t\tvalue: { type: \"array\", items: valSchema }\n\t\t\t\t},\n\t\t\t\tdefault: {\n\t\t\t\t\ttype: `TArray<${propType}>`,\n\t\t\t\t\tvalue: [valSchema.default]\n\t\t\t\t}\n\t\t\t})\n\t\t}),\n\t\t...Object.entries(enums).map(([propType, possibleValues]) => {\n\t\t\treturn merge({}, cloneDeep(schema.definitions.Property), {\n\t\t\t\tproperties: {\n\t\t\t\t\ttype: {\n\t\t\t\t\t\tconst: propType\n\t\t\t\t\t},\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\tenum: possibleValues\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdefault: {\n\t\t\t\t\ttype: propType,\n\t\t\t\t\tvalue: possibleValues[0]\n\t\t\t\t}\n\t\t\t})\n\t\t}),\n\t\t...Object.entries(enums).map(([propType, possibleValues]) => {\n\t\t\treturn merge({}, cloneDeep(schema.definitions.Property), {\n\t\t\t\tproperties: {\n\t\t\t\t\ttype: {\n\t\t\t\t\t\tconst: `TArray<${propType}>`\n\t\t\t\t\t},\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\titems: {\n\t\t\t\t\t\t\tenum: possibleValues\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdefault: {\n\t\t\t\t\ttype: `TArray<${propType}>`,\n\t\t\t\t\tvalue: [possibleValues[0]]\n\t\t\t\t}\n\t\t\t})\n\t\t}),\n\t\t{\n\t\t\t$ref: \"#/definitions/Property\"\n\t\t}\n\t]\n}\n\nschema.definitions.SubEntity.properties.platformSpecificProperties.additionalProperties.additionalProperties = cloneDeep(schema.definitions.SubEntity.properties.properties.additionalProperties)\nschema.definitions.PropertyOverride.properties.properties.additionalProperties = cloneDeep(schema.definitions.SubEntity.properties.properties.additionalProperties)\n\nexport const genRandHex = (size: number) => [...Array(size)].map(() => Math.floor(Math.random() * 16).toString(16)).join(\"\")\n\n/** Get the local entity ID referenced by a Ref. If the reference is external, returns false. If the reference is null, returns null. */\nexport function getReferencedLocalEntity(ref: Ref) {\n\tif (ref !== null && typeof ref != \"string\" && ref.externalScene) {\n\t\treturn false // External reference\n\t} else {\n\t\treturn ref !== null && typeof ref != \"string\" ? ref.ref : ref // Local reference\n\t}\n}\n\n/** Returns a modified Ref that points to a given local entity, keeping any exposed entity reference the same */\nexport function changeReferenceToLocalEntity(ref: Ref, ent: string) {\n\tif (typeof ref == \"string\" || ref === null) {\n\t\treturn ent\n\t} else {\n\t\treturn {\n\t\t\tref: ent,\n\t\t\texternalScene: null,\n\t\t\texposedEntity: ref.exposedEntity\n\t\t}\n\t}\n}\n\n/** Traverses the entity tree to find all entities logically parented under a given entity, returning their entity IDs. */\nexport function traverseEntityTree(\n\tentity: Entity,\n\tstartingPoint: string,\n\treverseReferences: Record<\n\t\tstring,\n\t\t{\n\t\t\ttype: string\n\t\t\tentity: string\n\t\t\tcontext?: string[]\n\t\t}[]\n\t>\n): string[] {\n\tconst copiedEntity = []\n\n\ttry {\n\t\tcopiedEntity.push(...reverseReferences[startingPoint].filter((a) => a.type == \"parent\").map((a) => a.entity))\n\n\t\tfor (const newEntity of copiedEntity) {\n\t\t\tcopiedEntity.push(...traverseEntityTree(entity, newEntity, reverseReferences))\n\t\t}\n\t} catch {}\n\n\treturn copiedEntity\n}\n\n/** Deletes all references to a given entity ID, mutating the passed entity. */\nexport function deleteReferencesToEntity(\n\tentity: Entity,\n\treverseReferences: Record<\n\t\tstring,\n\t\t{\n\t\t\ttype: string\n\t\t\tentity: string\n\t\t\tcontext?: string[]\n\t\t}[]\n\t>,\n\ttarget: string\n) {\n\tlet deleted = 0\n\n\tif (reverseReferences[target]) {\n\t\tfor (const ref of reverseReferences[target]) {\n\t\t\tif (entity.entities[ref.entity]) {\n\t\t\t\tswitch (ref.type) {\n\t\t\t\t\tcase \"property\":\n\t\t\t\t\t\tif (Array.isArray(entity.entities[ref.entity].properties![ref.context![0]].value)) {\n\t\t\t\t\t\t\tentity.entities[ref.entity].properties![ref.context![0]].value = entity.entities[ref.entity].properties![ref.context![0]].value.filter(\n\t\t\t\t\t\t\t\t(a: Ref) => getReferencedLocalEntity(a) != target\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdelete entity.entities[ref.entity].properties![ref.context![0]]\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdeleted++\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase \"platformSpecificProperty\":\n\t\t\t\t\t\tif (Array.isArray(entity.entities[ref.entity].platformSpecificProperties![ref.context![0]][ref.context![1]].value)) {\n\t\t\t\t\t\t\tentity.entities[ref.entity].platformSpecificProperties![ref.context![0]][ref.context![1]].value = entity.entities[ref.entity].platformSpecificProperties![ref.context![0]][\n\t\t\t\t\t\t\t\tref.context![1]\n\t\t\t\t\t\t\t].value.filter((a: Ref) => getReferencedLocalEntity(a) != target)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdelete entity.entities[ref.entity].platformSpecificProperties![ref.context![0]][ref.context![1]]\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdeleted++\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase \"event\":\n\t\t\t\t\t\tentity.entities[ref.entity].events![ref.context![0]][ref.context![1]] = entity.entities[ref.entity].events![ref.context![0]][ref.context![1]].filter(\n\t\t\t\t\t\t\t(a) => getReferencedLocalEntity(a && typeof a != \"string\" && Object.prototype.hasOwnProperty.call(a, \"value\") ? a.ref : (a as FullRef)) != target\n\t\t\t\t\t\t)\n\t\t\t\t\t\tdeleted++\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase \"inputCopy\":\n\t\t\t\t\t\tentity.entities[ref.entity].inputCopying![ref.context![0]][ref.context![1]] = entity.entities[ref.entity].inputCopying![ref.context![0]][ref.context![1]].filter(\n\t\t\t\t\t\t\t(a) => getReferencedLocalEntity(a && typeof a != \"string\" && Object.prototype.hasOwnProperty.call(a, \"value\") ? a.ref : (a as FullRef)) != target\n\t\t\t\t\t\t)\n\t\t\t\t\t\tdeleted++\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase \"outputCopy\":\n\t\t\t\t\t\tentity.entities[ref.entity].outputCopying![ref.context![0]][ref.context![1]] = entity.entities[ref.entity].outputCopying![ref.context![0]][ref.context![1]].filter(\n\t\t\t\t\t\t\t(a) => getReferencedLocalEntity(a && typeof a != \"string\" && Object.prototype.hasOwnProperty.call(a, \"value\") ? a.ref : (a as FullRef)) != target\n\t\t\t\t\t\t)\n\t\t\t\t\t\tdeleted++\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase \"propertyAlias\":\n\t\t\t\t\t\tentity.entities[ref.entity].propertyAliases![ref.context![0]] = entity.entities[ref.entity].propertyAliases![ref.context![0]].filter(\n\t\t\t\t\t\t\t(a) => !isEqual(a, { originalProperty: ref.context![1], originalEntity: target })\n\t\t\t\t\t\t)\n\t\t\t\t\t\tdeleted++\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase \"exposedEntity\":\n\t\t\t\t\t\tentity.entities[ref.entity].exposedEntities![ref.context![0]].refersTo = entity.entities[ref.entity].exposedEntities![ref.context![0]].refersTo.filter(\n\t\t\t\t\t\t\t(a) => getReferencedLocalEntity(a) != target\n\t\t\t\t\t\t)\n\t\t\t\t\t\tdeleted++\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase \"exposedInterface\":\n\t\t\t\t\t\tdelete entity.entities[ref.entity].exposedInterfaces![ref.context![0]]\n\t\t\t\t\t\tdeleted++\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase \"subset\":\n\t\t\t\t\t\tentity.entities[ref.entity].subsets![ref.context![0]] = entity.entities[ref.entity].subsets![ref.context![0]].filter((a) => a != target)\n\t\t\t\t\t\tdeleted++\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn deleted\n}\n\n/** Gets the referenced entities of an entity. */\nexport function getReferencedEntities(entityData: SubEntity): {\n\ttype: string\n\tentity: string\n\tcontext?: string[]\n}[] {\n\tconst refs = []\n\n\tconst localRef = getReferencedLocalEntity(entityData.parent)\n\tif (localRef) {\n\t\trefs.push({\n\t\t\ttype: \"parent\",\n\t\t\tentity: localRef\n\t\t})\n\t}\n\n\tif (entityData.properties) {\n\t\tfor (const [property, data] of Object.entries(entityData.properties)) {\n\t\t\tif (data.type == \"SEntityTemplateReference\" || data.type == \"TArray<SEntityTemplateReference>\") {\n\t\t\t\tfor (const value of data.type == \"SEntityTemplateReference\" ? [data.value] : data.value) {\n\t\t\t\t\tconst localRef = getReferencedLocalEntity(value)\n\t\t\t\t\tif (localRef) {\n\t\t\t\t\t\trefs.push({\n\t\t\t\t\t\t\ttype: \"property\",\n\t\t\t\t\t\t\tentity: localRef,\n\t\t\t\t\t\t\tcontext: [property]\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (entityData.platformSpecificProperties) {\n\t\tfor (const [platform, properties] of Object.entries(entityData.platformSpecificProperties)) {\n\t\t\tfor (const [property, data] of Object.entries(properties)) {\n\t\t\t\tif (data.type == \"SEntityTemplateReference\" || data.type == \"TArray<SEntityTemplateReference>\") {\n\t\t\t\t\tfor (const value of data.type == \"SEntityTemplateReference\" ? [data.value] : data.value) {\n\t\t\t\t\t\tconst localRef = getReferencedLocalEntity(value)\n\t\t\t\t\t\tif (localRef) {\n\t\t\t\t\t\t\trefs.push({\n\t\t\t\t\t\t\t\ttype: \"platformSpecificProperty\",\n\t\t\t\t\t\t\t\tentity: localRef,\n\t\t\t\t\t\t\t\tcontext: [platform, property]\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (const [type, data] of [\n\t\t[\"event\", entityData.events],\n\t\t[\"inputCopy\", entityData.inputCopying],\n\t\t[\"outputCopy\", entityData.outputCopying]\n\t] as [string, Record<string, Record<string, RefMaybeConstantValue[]>>][]) {\n\t\tif (data) {\n\t\t\tfor (const [event, x] of Object.entries(data)) {\n\t\t\t\tfor (const [trigger, ents] of Object.entries(x)) {\n\t\t\t\t\tfor (const ent of ents) {\n\t\t\t\t\t\tconst localRef = getReferencedLocalEntity(ent && typeof ent != \"string\" && Object.prototype.hasOwnProperty.call(ent, \"value\") ? ent.ref : (ent as FullRef))\n\t\t\t\t\t\tif (localRef) {\n\t\t\t\t\t\t\trefs.push({\n\t\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t\tentity: localRef,\n\t\t\t\t\t\t\t\tcontext: [event, trigger]\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (entityData.propertyAliases) {\n\t\tfor (const [property, aliases] of Object.entries(entityData.propertyAliases)) {\n\t\t\tfor (const alias of aliases) {\n\t\t\t\tconst localRef = getReferencedLocalEntity(alias.originalEntity)\n\t\t\t\tif (localRef) {\n\t\t\t\t\trefs.push({\n\t\t\t\t\t\ttype: \"propertyAlias\",\n\t\t\t\t\t\tentity: localRef,\n\t\t\t\t\t\tcontext: [property, alias.originalProperty]\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (entityData.exposedEntities) {\n\t\tfor (const [exposedEnt, data] of Object.entries(entityData.exposedEntities)) {\n\t\t\tfor (const target of data.refersTo) {\n\t\t\t\tconst localRef = getReferencedLocalEntity(target)\n\t\t\t\tif (localRef) {\n\t\t\t\t\trefs.push({\n\t\t\t\t\t\ttype: \"exposedEntity\",\n\t\t\t\t\t\tentity: localRef,\n\t\t\t\t\t\tcontext: [exposedEnt]\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (entityData.exposedInterfaces) {\n\t\tfor (const [exposedInterface, implementor] of Object.entries(entityData.exposedInterfaces)) {\n\t\t\tconst localRef = getReferencedLocalEntity(implementor)\n\t\t\tif (localRef) {\n\t\t\t\trefs.push({\n\t\t\t\t\ttype: \"exposedInterface\",\n\t\t\t\t\tentity: localRef,\n\t\t\t\t\tcontext: [exposedInterface]\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\tif (entityData.subsets) {\n\t\tfor (const [subset, entities] of Object.entries(entityData.subsets)) {\n\t\t\tfor (const ent of entities) {\n\t\t\t\trefs.push({\n\t\t\t\t\ttype: \"subset\",\n\t\t\t\t\tentity: ent,\n\t\t\t\t\tcontext: [subset]\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\treturn refs\n}\n\n/** Gets the referenced entities of a sub-entity that are not present in a set of sub-entities. */\nexport function getReferencedExternalEntities(\n\tentityData: SubEntity,\n\tentityToCheckWith: Record<string, SubEntity>\n): {\n\ttype: string\n\tentity: Ref\n\tcontext?: string[]\n}[] {\n\tconst refs = []\n\n\tconst localRef = getReferencedLocalEntity(entityData.parent)\n\tif (!localRef || !entityToCheckWith[localRef]) {\n\t\trefs.push({\n\t\t\ttype: \"parent\",\n\t\t\tentity: entityData.parent\n\t\t})\n\t}\n\n\tif (entityData.properties) {\n\t\tfor (const [property, data] of Object.entries(entityData.properties)) {\n\t\t\tif (data.type == \"SEntityTemplateReference\" || data.type == \"TArray<SEntityTemplateReference>\") {\n\t\t\t\tfor (const value of data.type == \"SEntityTemplateReference\" ? [data.value] : data.value) {\n\t\t\t\t\tconst localRef = getReferencedLocalEntity(value)\n\t\t\t\t\tif (!localRef || !entityToCheckWith[localRef]) {\n\t\t\t\t\t\trefs.push({\n\t\t\t\t\t\t\ttype: \"property\",\n\t\t\t\t\t\t\tentity: value,\n\t\t\t\t\t\t\tcontext: [property]\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (entityData.platformSpecificProperties) {\n\t\tfor (const [platform, properties] of Object.entries(entityData.platformSpecificProperties)) {\n\t\t\tfor (const [property, data] of Object.entries(properties)) {\n\t\t\t\tif (data.type == \"SEntityTemplateReference\" || data.type == \"TArray<SEntityTemplateReference>\") {\n\t\t\t\t\tfor (const value of data.type == \"SEntityTemplateReference\" ? [data.value] : data.value) {\n\t\t\t\t\t\tconst localRef = getReferencedLocalEntity(value)\n\t\t\t\t\t\tif (!localRef || !entityToCheckWith[localRef]) {\n\t\t\t\t\t\t\trefs.push({\n\t\t\t\t\t\t\t\ttype: \"platformSpecificProperty\",\n\t\t\t\t\t\t\t\tentity: value,\n\t\t\t\t\t\t\t\tcontext: [platform, property]\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (const [type, data] of [\n\t\t[\"event\", entityData.events],\n\t\t[\"inputCopy\", entityData.inputCopying],\n\t\t[\"outputCopy\", entityData.outputCopying]\n\t] as [string, Record<string, Record<string, RefMaybeConstantValue[]>>][]) {\n\t\tif (data) {\n\t\t\tfor (const [event, x] of Object.entries(data)) {\n\t\t\t\tfor (const [trigger, ents] of Object.entries(x)) {\n\t\t\t\t\tfor (const ent of ents) {\n\t\t\t\t\t\tconst localRef = getReferencedLocalEntity(ent && typeof ent != \"string\" && Object.prototype.hasOwnProperty.call(ent, \"value\") ? ent.ref : (ent as FullRef))\n\t\t\t\t\t\tif (!localRef || !entityToCheckWith[localRef]) {\n\t\t\t\t\t\t\trefs.push({\n\t\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t\tentity: ent && typeof ent != \"string\" && Object.prototype.hasOwnProperty.call(ent, \"value\") ? ent.ref : (ent as FullRef),\n\t\t\t\t\t\t\t\tcontext: [event, trigger]\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (entityData.propertyAliases) {\n\t\tfor (const [property, aliases] of Object.entries(entityData.propertyAliases)) {\n\t\t\tfor (const alias of aliases) {\n\t\t\t\tconst localRef = getReferencedLocalEntity(alias.originalEntity)\n\t\t\t\tif (!localRef || !entityToCheckWith[localRef]) {\n\t\t\t\t\trefs.push({\n\t\t\t\t\t\ttype: \"propertyAlias\",\n\t\t\t\t\t\tentity: alias.originalEntity,\n\t\t\t\t\t\tcontext: [property, alias.originalProperty]\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (entityData.exposedEntities) {\n\t\tfor (const [exposedEnt, data] of Object.entries(entityData.exposedEntities)) {\n\t\t\tfor (const target of data.refersTo) {\n\t\t\t\tconst localRef = getReferencedLocalEntity(target)\n\t\t\t\tif (!localRef || !entityToCheckWith[localRef]) {\n\t\t\t\t\trefs.push({\n\t\t\t\t\t\ttype: \"exposedEntity\",\n\t\t\t\t\t\tentity: target,\n\t\t\t\t\t\tcontext: [exposedEnt]\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (entityData.exposedInterfaces) {\n\t\tfor (const [exposedInterface, implementor] of Object.entries(entityData.exposedInterfaces)) {\n\t\t\tconst localRef = getReferencedLocalEntity(implementor)\n\t\t\tif (!localRef || !entityToCheckWith[localRef]) {\n\t\t\t\trefs.push({\n\t\t\t\t\ttype: \"exposedInterface\",\n\t\t\t\t\tentity: implementor,\n\t\t\t\t\tcontext: [exposedInterface]\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\tif (entityData.subsets) {\n\t\tfor (const [subset, entities] of Object.entries(entityData.subsets)) {\n\t\t\tfor (const ent of entities) {\n\t\t\t\tif (!entityToCheckWith[ent]) {\n\t\t\t\t\trefs.push({\n\t\t\t\t\t\ttype: \"subset\",\n\t\t\t\t\t\tentity: ent,\n\t\t\t\t\t\tcontext: [subset]\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn refs\n}\n\n/** Check the validity of an entity's references as well as matching it against the schema. Returns null if the entity is valid and a message if not. */\nexport function checkValidityOfEntity(entity: Entity, target: SubEntity): null | string {\n\t// Check that all referenced entities exist\n\tfor (const ref of getReferencedEntities(target)) {\n\t\tif (ref.entity == \"\") {\n\t\t\treturn \"Empty string used as reference\"\n\t\t}\n\n\t\tif (!entity.entities[ref.entity]) {\n\t\t\treturn `Referenced entity ${ref.entity} doesn't exist`\n\t\t}\n\t}\n\n\t// Check that schema is met\n\ttry {\n\t\tif (!ajv(target)) {\n\t\t\tconsole.log(\"Entity invalid by schema\", ajv.errors)\n\t\t\treturn \"Entity doesn't meet specifications\"\n\t\t}\n\t} catch {\n\t\treturn \"Entity doesn't meet specifications\"\n\t}\n\n\treturn null\n}\n\nexport function normaliseToHash(path: string): string {\n\tif (path.includes(\":\")) {\n\t\treturn (\"00\" + md5(path).slice(2, 16)).toUpperCase()\n\t}\n\n\treturn path\n}\n\nexport function getSchema() {\n\treturn cloneDeep(schema)\n}\n\nexport function changeEntityHashesToFriendly(entity: Entity, friendly: Record<string, string>) {\n\tentity.externalScenes = entity.externalScenes.map((a) => friendly[a] || a)\n\n\tentity.extraFactoryDependencies = entity.extraFactoryDependencies.map((a) => {\n\t\tif (typeof a == \"string\") {\n\t\t\treturn friendly[a] || a\n\t\t} else if (a) {\n\t\t\treturn {\n\t\t\t\tresource: friendly[a.resource] || a.resource,\n\t\t\t\tflag: a.flag\n\t\t\t}\n\t\t} else {\n\t\t\treturn a\n\t\t}\n\t})\n\n\tentity.extraBlueprintDependencies = entity.extraBlueprintDependencies.map((a) => {\n\t\tif (typeof a == \"string\") {\n\t\t\treturn friendly[a] || a\n\t\t} else if (a) {\n\t\t\treturn {\n\t\t\t\tresource: friendly[a.resource] || a.resource,\n\t\t\t\tflag: a.flag\n\t\t\t}\n\t\t} else {\n\t\t\treturn a\n\t\t}\n\t})\n\n\tfor (const subEntity of Object.values(entity.entities)) {\n\t\tsubEntity.factory = friendly[subEntity.factory] || subEntity.factory\n\t\tsubEntity.blueprint = friendly[subEntity.blueprint] || subEntity.blueprint\n\n\t\tif (subEntity.properties) {\n\t\t\tfor (const property of Object.values(subEntity.properties)) {\n\t\t\t\tif (property.type == \"ZRuntimeResourceID\") {\n\t\t\t\t\tif (typeof property.value == \"string\") {\n\t\t\t\t\t\tproperty.value = friendly[property.value] || property.value\n\t\t\t\t\t} else if (property.value) {\n\t\t\t\t\t\tproperty.value.resource = friendly[property.value.resource] || property.value.resource\n\t\t\t\t\t}\n\t\t\t\t} else if (property.type == \"TArray<ZRuntimeResourceID>\") {\n\t\t\t\t\tproperty.value = property.value.map((a) => {\n\t\t\t\t\t\tif (typeof a == \"string\") {\n\t\t\t\t\t\t\treturn friendly[a] || a\n\t\t\t\t\t\t} else if (a) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tresource: friendly[a.resource] || a.resource,\n\t\t\t\t\t\t\t\tflag: a.flag\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn a\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (subEntity.platformSpecificProperties) {\n\t\t\tfor (const properties of Object.values(subEntity.platformSpecificProperties)) {\n\t\t\t\tfor (const property of Object.values(properties)) {\n\t\t\t\t\tif (property.type == \"ZRuntimeResourceID\") {\n\t\t\t\t\t\tif (typeof property.value == \"string\") {\n\t\t\t\t\t\t\tproperty.value = friendly[property.value] || property.value\n\t\t\t\t\t\t} else if (property.value) {\n\t\t\t\t\t\t\tproperty.value.resource = friendly[property.value.resource] || property.value.resource\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (property.type == \"TArray<ZRuntimeResourceID>\") {\n\t\t\t\t\t\tproperty.value = property.value.map((a) => {\n\t\t\t\t\t\t\tif (typeof a == \"string\") {\n\t\t\t\t\t\t\t\treturn friendly[a] || a\n\t\t\t\t\t\t\t} else if (a) {\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tresource: friendly[a.resource] || a.resource,\n\t\t\t\t\t\t\t\t\tflag: a.flag\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn a\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function changeEntityHashesFromFriendly(entity: Entity, friendly: Record<string, string>) {\n\tchangeEntityHashesToFriendly(entity, Object.fromEntries(Object.entries(friendly).map((a) => [a[1], a[0]])))\n}\n\nexport function sanitise(a: string) {\n\tconst sanitiser = new DOMParser().parseFromString(`<div></div>`, \"text/html\")\n\tsanitiser.querySelector(\"div\")!.innerText = a\n\n\treturn sanitiser.querySelector(\"div\")!.innerHTML\n}"], "filenames": ["src/lib/components/MinimalTree.svelte", "src/lib/components/Tree.svelte", "src/lib/utils.ts"], "buggy_code_start_loc": [7, 7, 633], "buggy_code_end_loc": [170, 766, 633], "fixing_code_start_loc": [7, 7, 634], "fixing_code_end_loc": [171, 767, 641], "type": "CWE-79", "message": "quickentity-editor-next is an open source, system local, video game asset editor. In affected versions HTML tags in entity names are not sanitised (XSS vulnerability). Allows arbitrary code execution within the browser sandbox, among other things, simply from loading a file containing a script tag in any entity name. This issue has been patched in version 1.28.1 of the application. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-27472", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-06T19:15:10.483", "lastModified": "2023-03-11T04:48:36.010", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "quickentity-editor-next is an open source, system local, video game asset editor. In affected versions HTML tags in entity names are not sanitised (XSS vulnerability). Allows arbitrary code execution within the browser sandbox, among other things, simply from loading a file containing a script tag in any entity name. This issue has been patched in version 1.28.1 of the application. Users are advised to upgrade. There are no known workarounds for this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.8}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:quickentity_editor_project:quickentity_editor:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.28.1", "matchCriteriaId": "019C7AFC-D59B-448A-8DCF-DC7075567F1A"}]}]}], "references": [{"url": "https://github.com/atampy25/quickentity-editor-next/commit/5303b45a20a6e4e9318729b8dd7bbf09b37b369d", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/atampy25/quickentity-editor-next/security/advisories/GHSA-22gc-rq5x-fxpw", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/atampy25/quickentity-editor-next/commit/5303b45a20a6e4e9318729b8dd7bbf09b37b369d"}}