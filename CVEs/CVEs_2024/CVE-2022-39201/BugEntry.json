{"buggy_code": ["package api\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\n\t\"github.com/grafana/grafana/pkg/api/datasource\"\n\t\"github.com/grafana/grafana/pkg/api/dtos\"\n\t\"github.com/grafana/grafana/pkg/api/response\"\n\t\"github.com/grafana/grafana/pkg/components/simplejson\"\n\t\"github.com/grafana/grafana/pkg/infra/log\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins/adapters\"\n\t\"github.com/grafana/grafana/pkg/services/datasources\"\n\t\"github.com/grafana/grafana/pkg/services/datasources/permissions\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util\"\n\t\"github.com/grafana/grafana/pkg/util/proxyutil\"\n\t\"github.com/grafana/grafana/pkg/web\"\n)\n\nvar datasourcesLogger = log.New(\"datasources\")\nvar secretsPluginError datasources.ErrDatasourceSecretsPluginUserFriendly\n\n// swagger:route GET /datasources datasources getDataSources\n//\n// Get all data sources.\n//\n// If you are running Grafana Enterprise and have Fine-grained access control enabled\n// you need to have a permission with action: `datasources:read` and scope: `datasources:*`.\n//\n// Responses:\n// 200: getDataSourcesResponse\n// 401: unauthorisedError\n// 403: forbiddenError\n// 500: internalServerError\nfunc (hs *HTTPServer) GetDataSources(c *models.ReqContext) response.Response {\n\tquery := datasources.GetDataSourcesQuery{OrgId: c.OrgId, DataSourceLimit: hs.Cfg.DataSourceLimit}\n\n\tif err := hs.DataSourcesService.GetDataSources(c.Req.Context(), &query); err != nil {\n\t\treturn response.Error(500, \"Failed to query datasources\", err)\n\t}\n\n\tfiltered, err := hs.filterDatasourcesByQueryPermission(c.Req.Context(), c.SignedInUser, query.Result)\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to query datasources\", err)\n\t}\n\n\tresult := make(dtos.DataSourceList, 0)\n\tfor _, ds := range filtered {\n\t\tdsItem := dtos.DataSourceListItemDTO{\n\t\t\tOrgId:     ds.OrgId,\n\t\t\tId:        ds.Id,\n\t\t\tUID:       ds.Uid,\n\t\t\tName:      ds.Name,\n\t\t\tUrl:       ds.Url,\n\t\t\tType:      ds.Type,\n\t\t\tTypeName:  ds.Type,\n\t\t\tAccess:    ds.Access,\n\t\t\tDatabase:  ds.Database,\n\t\t\tUser:      ds.User,\n\t\t\tBasicAuth: ds.BasicAuth,\n\t\t\tIsDefault: ds.IsDefault,\n\t\t\tJsonData:  ds.JsonData,\n\t\t\tReadOnly:  ds.ReadOnly,\n\t\t}\n\n\t\tif plugin, exists := hs.pluginStore.Plugin(c.Req.Context(), ds.Type); exists {\n\t\t\tdsItem.TypeLogoUrl = plugin.Info.Logos.Small\n\t\t\tdsItem.TypeName = plugin.Name\n\t\t} else {\n\t\t\tdsItem.TypeLogoUrl = \"public/img/icn-datasource.svg\"\n\t\t}\n\n\t\tresult = append(result, dsItem)\n\t}\n\n\tsort.Sort(result)\n\n\treturn response.JSON(http.StatusOK, &result)\n}\n\n// swagger:route GET /datasources/{id} datasources getDataSourceByID\n//\n// Get a single data source by Id.\n//\n// If you are running Grafana Enterprise and have Fine-grained access control enabled\n// you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).\n//\n// Please refer to [updated API](#/datasources/getDataSourceByUID) instead\n//\n// Deprecated: true\n//\n// Responses:\n// 200: getDataSourceResponse\n// 400: badRequestError\n// 401: unauthorisedError\n// 403: forbiddenError\n// 404: notFoundError\n// 500: internalServerError\nfunc (hs *HTTPServer) GetDataSourceById(c *models.ReqContext) response.Response {\n\tid, err := strconv.ParseInt(web.Params(c.Req)[\":id\"], 10, 64)\n\tif err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"id is invalid\", nil)\n\t}\n\tquery := datasources.GetDataSourceQuery{\n\t\tId:    id,\n\t\tOrgId: c.OrgId,\n\t}\n\n\tif err := hs.DataSourcesService.GetDataSource(c.Req.Context(), &query); err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceNotFound) {\n\t\t\treturn response.Error(404, \"Data source not found\", nil)\n\t\t}\n\t\tif errors.Is(err, datasources.ErrDataSourceIdentifierNotSet) {\n\t\t\treturn response.Error(400, \"Datasource id is missing\", nil)\n\t\t}\n\t\treturn response.Error(500, \"Failed to query datasources\", err)\n\t}\n\n\tdto := hs.convertModelToDtos(c.Req.Context(), query.Result)\n\n\t// Add accesscontrol metadata\n\tdto.AccessControl = hs.getAccessControlMetadata(c, c.OrgId, datasources.ScopePrefix, dto.UID)\n\n\treturn response.JSON(http.StatusOK, &dto)\n}\n\n// swagger:route DELETE /datasources/{id} datasources deleteDataSourceByID\n//\n// Delete an existing data source by id.\n//\n// If you are running Grafana Enterprise and have Fine-grained access control enabled\n// you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).\n//\n// Please refer to [updated API](#/datasources/deleteDataSourceByUID) instead\n//\n// Deprecated: true\n//\n// Responses:\n// 200: okResponse\n// 401: unauthorisedError\n// 404: notFoundError\n// 403: forbiddenError\n// 500: internalServerError\nfunc (hs *HTTPServer) DeleteDataSourceById(c *models.ReqContext) response.Response {\n\tid, err := strconv.ParseInt(web.Params(c.Req)[\":id\"], 10, 64)\n\tif err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"id is invalid\", err)\n\t}\n\n\tif id <= 0 {\n\t\treturn response.Error(400, \"Missing valid datasource id\", nil)\n\t}\n\n\tds, err := hs.getRawDataSourceById(c.Req.Context(), id, c.OrgId)\n\tif err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceNotFound) {\n\t\t\treturn response.Error(404, \"Data source not found\", nil)\n\t\t}\n\t\treturn response.Error(400, \"Failed to delete datasource\", nil)\n\t}\n\n\tif ds.ReadOnly {\n\t\treturn response.Error(403, \"Cannot delete read-only data source\", nil)\n\t}\n\n\tcmd := &datasources.DeleteDataSourceCommand{ID: id, OrgID: c.OrgId, Name: ds.Name}\n\n\terr = hs.DataSourcesService.DeleteDataSource(c.Req.Context(), cmd)\n\tif err != nil {\n\t\tif errors.As(err, &secretsPluginError) {\n\t\t\treturn response.Error(500, \"Failed to delete datasource: \"+err.Error(), err)\n\t\t}\n\t\treturn response.Error(500, \"Failed to delete datasource\", err)\n\t}\n\n\ths.Live.HandleDatasourceDelete(c.OrgId, ds.Uid)\n\n\treturn response.Success(\"Data source deleted\")\n}\n\n// swagger:route GET /datasources/uid/{uid} datasources getDataSourceByUID\n//\n// Get a single data source by UID.\n//\n// If you are running Grafana Enterprise and have Fine-grained access control enabled\n// you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).\n//\n// Responses:\n// 200: getDataSourceResponse\n// 400: badRequestError\n// 401: unauthorisedError\n// 403: forbiddenError\n// 404: notFoundError\n// 500: internalServerError\nfunc (hs *HTTPServer) GetDataSourceByUID(c *models.ReqContext) response.Response {\n\tds, err := hs.getRawDataSourceByUID(c.Req.Context(), web.Params(c.Req)[\":uid\"], c.OrgId)\n\n\tif err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceNotFound) {\n\t\t\treturn response.Error(http.StatusNotFound, \"Data source not found\", nil)\n\t\t}\n\t\treturn response.Error(http.StatusInternalServerError, \"Failed to query datasource\", err)\n\t}\n\n\tdto := hs.convertModelToDtos(c.Req.Context(), ds)\n\n\t// Add accesscontrol metadata\n\tdto.AccessControl = hs.getAccessControlMetadata(c, c.OrgId, datasources.ScopePrefix, dto.UID)\n\n\treturn response.JSON(http.StatusOK, &dto)\n}\n\n// swagger:route DELETE /datasources/uid/{uid} datasources deleteDataSourceByUID\n//\n// Delete an existing data source by UID.\n//\n// If you are running Grafana Enterprise and have Fine-grained access control enabled\n// you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).\n//\n// Responses:\n// 200: okResponse\n// 401: unauthorisedError\n// 403: forbiddenError\n// 404: notFoundError\n// 500: internalServerError\nfunc (hs *HTTPServer) DeleteDataSourceByUID(c *models.ReqContext) response.Response {\n\tuid := web.Params(c.Req)[\":uid\"]\n\n\tif uid == \"\" {\n\t\treturn response.Error(400, \"Missing datasource uid\", nil)\n\t}\n\n\tds, err := hs.getRawDataSourceByUID(c.Req.Context(), uid, c.OrgId)\n\tif err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceNotFound) {\n\t\t\treturn response.Error(404, \"Data source not found\", nil)\n\t\t}\n\t\treturn response.Error(400, \"Failed to delete datasource\", nil)\n\t}\n\n\tif ds.ReadOnly {\n\t\treturn response.Error(403, \"Cannot delete read-only data source\", nil)\n\t}\n\n\tcmd := &datasources.DeleteDataSourceCommand{UID: uid, OrgID: c.OrgId, Name: ds.Name}\n\n\terr = hs.DataSourcesService.DeleteDataSource(c.Req.Context(), cmd)\n\tif err != nil {\n\t\tif errors.As(err, &secretsPluginError) {\n\t\t\treturn response.Error(500, \"Failed to delete datasource: \"+err.Error(), err)\n\t\t}\n\t\treturn response.Error(500, \"Failed to delete datasource\", err)\n\t}\n\n\ths.Live.HandleDatasourceDelete(c.OrgId, ds.Uid)\n\n\treturn response.JSON(http.StatusOK, util.DynMap{\n\t\t\"message\": \"Data source deleted\",\n\t\t\"id\":      ds.Id,\n\t})\n}\n\n// swagger:route DELETE /datasources/name/{name} datasources deleteDataSourceByName\n//\n// Delete an existing data source by name.\n//\n// If you are running Grafana Enterprise and have Fine-grained access control enabled\n// you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).\n//\n// Responses:\n// 200: deleteDataSourceByNameResponse\n// 401: unauthorisedError\n// 403: forbiddenError\n// 404: notFoundError\n// 500: internalServerError\nfunc (hs *HTTPServer) DeleteDataSourceByName(c *models.ReqContext) response.Response {\n\tname := web.Params(c.Req)[\":name\"]\n\n\tif name == \"\" {\n\t\treturn response.Error(400, \"Missing valid datasource name\", nil)\n\t}\n\n\tgetCmd := &datasources.GetDataSourceQuery{Name: name, OrgId: c.OrgId}\n\tif err := hs.DataSourcesService.GetDataSource(c.Req.Context(), getCmd); err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceNotFound) {\n\t\t\treturn response.Error(404, \"Data source not found\", nil)\n\t\t}\n\t\treturn response.Error(500, \"Failed to delete datasource\", err)\n\t}\n\n\tif getCmd.Result.ReadOnly {\n\t\treturn response.Error(403, \"Cannot delete read-only data source\", nil)\n\t}\n\n\tcmd := &datasources.DeleteDataSourceCommand{Name: name, OrgID: c.OrgId}\n\terr := hs.DataSourcesService.DeleteDataSource(c.Req.Context(), cmd)\n\tif err != nil {\n\t\tif errors.As(err, &secretsPluginError) {\n\t\t\treturn response.Error(500, \"Failed to delete datasource: \"+err.Error(), err)\n\t\t}\n\t\treturn response.Error(500, \"Failed to delete datasource\", err)\n\t}\n\n\ths.Live.HandleDatasourceDelete(c.OrgId, getCmd.Result.Uid)\n\n\treturn response.JSON(http.StatusOK, util.DynMap{\n\t\t\"message\": \"Data source deleted\",\n\t\t\"id\":      getCmd.Result.Id,\n\t})\n}\n\nfunc validateURL(cmdType string, url string) response.Response {\n\tif _, err := datasource.ValidateURL(cmdType, url); err != nil {\n\t\tdatasourcesLogger.Error(\"Failed to validate URL\", \"url\", url)\n\t\treturn response.Error(http.StatusBadRequest, \"Validation error, invalid URL\", err)\n\t}\n\n\treturn nil\n}\n\n// validateJSONData prevents the user from adding a custom header with name that matches the auth proxy header name.\n// This is done to prevent data source proxy from being used to circumvent auth proxy.\n// For more context take a look at CVE-2022-35957\nfunc validateJSONData(jsonData *simplejson.Json, cfg *setting.Cfg) error {\n\tif jsonData == nil || !cfg.AuthProxyEnabled {\n\t\treturn nil\n\t}\n\n\tfor key, value := range jsonData.MustMap() {\n\t\tif strings.HasPrefix(key, \"httpHeaderName\") {\n\t\t\theader := fmt.Sprint(value)\n\t\t\tif http.CanonicalHeaderKey(header) == http.CanonicalHeaderKey(cfg.AuthProxyHeaderName) {\n\t\t\t\tdatasourcesLogger.Error(\"Forbidden to add a data source header with a name equal to auth proxy header name\", \"headerName\", key)\n\t\t\t\treturn errors.New(\"validation error, invalid header name specified\")\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// swagger:route POST /datasources datasources addDataSource\n//\n// Create a data source.\n//\n// By defining `password` and `basicAuthPassword` under secureJsonData property\n// Grafana encrypts them securely as an encrypted blob in the database.\n// The response then lists the encrypted fields under secureJsonFields.\n//\n// If you are running Grafana Enterprise and have Fine-grained access control enabled\n// you need to have a permission with action: `datasources:create`\n//\n// Responses:\n// 200: createOrUpdateDatasourceResponse\n// 401: unauthorisedError\n// 403: forbiddenError\n// 409: conflictError\n// 500: internalServerError\nfunc (hs *HTTPServer) AddDataSource(c *models.ReqContext) response.Response {\n\tcmd := datasources.AddDataSourceCommand{}\n\tif err := web.Bind(c.Req, &cmd); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\n\tdatasourcesLogger.Debug(\"Received command to add data source\", \"url\", cmd.Url)\n\tcmd.OrgId = c.OrgId\n\tcmd.UserId = c.UserId\n\tif cmd.Url != \"\" {\n\t\tif resp := validateURL(cmd.Type, cmd.Url); resp != nil {\n\t\t\treturn resp\n\t\t}\n\t}\n\tif err := validateJSONData(cmd.JsonData, hs.Cfg); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"Failed to add datasource\", err)\n\t}\n\n\tif err := hs.DataSourcesService.AddDataSource(c.Req.Context(), &cmd); err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceNameExists) || errors.Is(err, datasources.ErrDataSourceUidExists) {\n\t\t\treturn response.Error(409, err.Error(), err)\n\t\t}\n\n\t\tif errors.As(err, &secretsPluginError) {\n\t\t\treturn response.Error(500, \"Failed to add datasource: \"+err.Error(), err)\n\t\t}\n\n\t\treturn response.Error(500, \"Failed to add datasource\", err)\n\t}\n\n\tds := hs.convertModelToDtos(c.Req.Context(), cmd.Result)\n\treturn response.JSON(http.StatusOK, util.DynMap{\n\t\t\"message\":    \"Datasource added\",\n\t\t\"id\":         cmd.Result.Id,\n\t\t\"name\":       cmd.Result.Name,\n\t\t\"datasource\": ds,\n\t})\n}\n\n// swagger:route PUT /datasources/{id} datasources updateDataSourceByID\n//\n// Update an existing data source by its sequential ID.\n//\n// Similar to creating a data source, `password` and `basicAuthPassword` should be defined under\n// secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the\n// encrypted fields are listed under secureJsonFields section in the response.\n//\n// If you are running Grafana Enterprise and have Fine-grained access control enabled\n// you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).\n//\n// Please refer to [updated API](#/datasources/updateDataSourceByUID) instead\n//\n// Deprecated: true\n//\n// Responses:\n// 200: createOrUpdateDatasourceResponse\n// 401: unauthorisedError\n// 403: forbiddenError\n// 500: internalServerError\n\nfunc (hs *HTTPServer) UpdateDataSourceByID(c *models.ReqContext) response.Response {\n\tcmd := datasources.UpdateDataSourceCommand{}\n\tif err := web.Bind(c.Req, &cmd); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tdatasourcesLogger.Debug(\"Received command to update data source\", \"url\", cmd.Url)\n\tcmd.OrgId = c.OrgId\n\tvar err error\n\tif cmd.Id, err = strconv.ParseInt(web.Params(c.Req)[\":id\"], 10, 64); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"id is invalid\", err)\n\t}\n\tif resp := validateURL(cmd.Type, cmd.Url); resp != nil {\n\t\treturn resp\n\t}\n\tif err := validateJSONData(cmd.JsonData, hs.Cfg); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"Failed to update datasource\", err)\n\t}\n\n\tds, err := hs.getRawDataSourceById(c.Req.Context(), cmd.Id, cmd.OrgId)\n\tif err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceNotFound) {\n\t\t\treturn response.Error(404, \"Data source not found\", nil)\n\t\t}\n\t\treturn response.Error(500, \"Failed to update datasource\", err)\n\t}\n\treturn hs.updateDataSourceByID(c, ds, cmd)\n}\n\n// swagger:route PUT /datasources/uid/{uid} datasources updateDataSourceByUID\n//\n// Update an existing data source.\n//\n// Similar to creating a data source, `password` and `basicAuthPassword` should be defined under\n// secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the\n// encrypted fields are listed under secureJsonFields section in the response.\n//\n// If you are running Grafana Enterprise and have Fine-grained access control enabled\n// you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:1` (single data source).\n//\n// Responses:\n// 200: createOrUpdateDatasourceResponse\n// 401: unauthorisedError\n// 403: forbiddenError\n// 500: internalServerError\nfunc (hs *HTTPServer) UpdateDataSourceByUID(c *models.ReqContext) response.Response {\n\tcmd := datasources.UpdateDataSourceCommand{}\n\tif err := web.Bind(c.Req, &cmd); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tdatasourcesLogger.Debug(\"Received command to update data source\", \"url\", cmd.Url)\n\tcmd.OrgId = c.OrgId\n\tif resp := validateURL(cmd.Type, cmd.Url); resp != nil {\n\t\treturn resp\n\t}\n\tif err := validateJSONData(cmd.JsonData, hs.Cfg); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"Failed to update datasource\", err)\n\t}\n\n\tds, err := hs.getRawDataSourceByUID(c.Req.Context(), web.Params(c.Req)[\":uid\"], c.OrgId)\n\tif err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceNotFound) {\n\t\t\treturn response.Error(http.StatusNotFound, \"Data source not found\", nil)\n\t\t}\n\t\treturn response.Error(http.StatusInternalServerError, \"Failed to update datasource\", err)\n\t}\n\tcmd.Id = ds.Id\n\treturn hs.updateDataSourceByID(c, ds, cmd)\n}\n\nfunc (hs *HTTPServer) updateDataSourceByID(c *models.ReqContext, ds *datasources.DataSource, cmd datasources.UpdateDataSourceCommand) response.Response {\n\tif ds.ReadOnly {\n\t\treturn response.Error(403, \"Cannot update read-only data source\", nil)\n\t}\n\n\terr := hs.DataSourcesService.UpdateDataSource(c.Req.Context(), &cmd)\n\tif err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceUpdatingOldVersion) {\n\t\t\treturn response.Error(409, \"Datasource has already been updated by someone else. Please reload and try again\", err)\n\t\t}\n\n\t\tif errors.As(err, &secretsPluginError) {\n\t\t\treturn response.Error(500, \"Failed to update datasource: \"+err.Error(), err)\n\t\t}\n\t\treturn response.Error(500, \"Failed to update datasource\", err)\n\t}\n\n\tquery := datasources.GetDataSourceQuery{\n\t\tId:    cmd.Id,\n\t\tOrgId: c.OrgId,\n\t}\n\n\tif err := hs.DataSourcesService.GetDataSource(c.Req.Context(), &query); err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceNotFound) {\n\t\t\treturn response.Error(404, \"Data source not found\", nil)\n\t\t}\n\t\treturn response.Error(500, \"Failed to query datasource\", err)\n\t}\n\n\tdatasourceDTO := hs.convertModelToDtos(c.Req.Context(), query.Result)\n\n\ths.Live.HandleDatasourceUpdate(c.OrgId, datasourceDTO.UID)\n\n\treturn response.JSON(http.StatusOK, util.DynMap{\n\t\t\"message\":    \"Datasource updated\",\n\t\t\"id\":         cmd.Id,\n\t\t\"name\":       cmd.Name,\n\t\t\"datasource\": datasourceDTO,\n\t})\n}\n\nfunc (hs *HTTPServer) getRawDataSourceById(ctx context.Context, id int64, orgID int64) (*datasources.DataSource, error) {\n\tquery := datasources.GetDataSourceQuery{\n\t\tId:    id,\n\t\tOrgId: orgID,\n\t}\n\n\tif err := hs.DataSourcesService.GetDataSource(ctx, &query); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn query.Result, nil\n}\n\nfunc (hs *HTTPServer) getRawDataSourceByUID(ctx context.Context, uid string, orgID int64) (*datasources.DataSource, error) {\n\tquery := datasources.GetDataSourceQuery{\n\t\tUid:   uid,\n\t\tOrgId: orgID,\n\t}\n\n\tif err := hs.DataSourcesService.GetDataSource(ctx, &query); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn query.Result, nil\n}\n\n// swagger:route GET /datasources/name/{name} datasources getDataSourceByName\n//\n// Get a single data source by Name.\n//\n// If you are running Grafana Enterprise and have Fine-grained access control enabled\n// you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).\n//\n// Responses:\n// 200: getDataSourceResponse\n// 401: unauthorisedError\n// 403: forbiddenError\n// 500: internalServerError\nfunc (hs *HTTPServer) GetDataSourceByName(c *models.ReqContext) response.Response {\n\tquery := datasources.GetDataSourceQuery{Name: web.Params(c.Req)[\":name\"], OrgId: c.OrgId}\n\n\tif err := hs.DataSourcesService.GetDataSource(c.Req.Context(), &query); err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceNotFound) {\n\t\t\treturn response.Error(404, \"Data source not found\", nil)\n\t\t}\n\t\treturn response.Error(500, \"Failed to query datasources\", err)\n\t}\n\n\tdto := hs.convertModelToDtos(c.Req.Context(), query.Result)\n\treturn response.JSON(http.StatusOK, &dto)\n}\n\n// swagger:route GET /datasources/id/{name} datasources getDataSourceIdByName\n//\n// Get data source Id by Name.\n//\n// If you are running Grafana Enterprise and have Fine-grained access control enabled\n// you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).\n//\n// Responses:\n// 200: getDataSourceIDResponse\n// 401: unauthorisedError\n// 403: forbiddenError\n// 404: notFoundError\n// 500: internalServerError\nfunc (hs *HTTPServer) GetDataSourceIdByName(c *models.ReqContext) response.Response {\n\tquery := datasources.GetDataSourceQuery{Name: web.Params(c.Req)[\":name\"], OrgId: c.OrgId}\n\n\tif err := hs.DataSourcesService.GetDataSource(c.Req.Context(), &query); err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceNotFound) {\n\t\t\treturn response.Error(404, \"Data source not found\", nil)\n\t\t}\n\t\treturn response.Error(500, \"Failed to query datasources\", err)\n\t}\n\n\tds := query.Result\n\tdtos := dtos.AnyId{\n\t\tId: ds.Id,\n\t}\n\n\treturn response.JSON(http.StatusOK, &dtos)\n}\n\n// swagger:route GET /datasources/{id}/resources/{datasource_proxy_route} datasources callDatasourceResourceByID\n//\n// Fetch data source resources by Id.\n//\n// Please refer to [updated API](#/datasources/callDatasourceResourceWithUID) instead\n//\n// Deprecated: true\n//\n// Responses:\n// 200: okResponse\n// 400: badRequestError\n// 401: unauthorisedError\n// 403: forbiddenError\n// 404: notFoundError\n// 500: internalServerError\nfunc (hs *HTTPServer) CallDatasourceResource(c *models.ReqContext) {\n\tdatasourceID, err := strconv.ParseInt(web.Params(c.Req)[\":id\"], 10, 64)\n\tif err != nil {\n\t\tc.JsonApiErr(http.StatusBadRequest, \"id is invalid\", nil)\n\t\treturn\n\t}\n\tds, err := hs.DataSourceCache.GetDatasource(c.Req.Context(), datasourceID, c.SignedInUser, c.SkipCache)\n\tif err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceAccessDenied) {\n\t\t\tc.JsonApiErr(403, \"Access denied to datasource\", err)\n\t\t\treturn\n\t\t}\n\t\tc.JsonApiErr(500, \"Unable to load datasource meta data\", err)\n\t\treturn\n\t}\n\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), ds.Type)\n\tif !exists {\n\t\tc.JsonApiErr(500, \"Unable to find datasource plugin\", err)\n\t\treturn\n\t}\n\n\ths.callPluginResourceWithDataSource(c, plugin.ID, ds)\n}\n\n// swagger:route GET /datasources/uid/{uid}/resources/{datasource_proxy_route} datasources callDatasourceResourceWithUID\n//\n// Fetch data source resources.\n//\n// Responses:\n// 200: okResponse\n// 400: badRequestError\n// 401: unauthorisedError\n// 403: forbiddenError\n// 404: notFoundError\n// 500: internalServerError\nfunc (hs *HTTPServer) CallDatasourceResourceWithUID(c *models.ReqContext) {\n\tdsUID := web.Params(c.Req)[\":uid\"]\n\tif !util.IsValidShortUID(dsUID) {\n\t\tc.JsonApiErr(http.StatusBadRequest, \"UID is invalid\", nil)\n\t\treturn\n\t}\n\n\tds, err := hs.DataSourceCache.GetDatasourceByUID(c.Req.Context(), dsUID, c.SignedInUser, c.SkipCache)\n\tif err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceAccessDenied) {\n\t\t\tc.JsonApiErr(http.StatusForbidden, \"Access denied to datasource\", err)\n\t\t\treturn\n\t\t}\n\t\tc.JsonApiErr(http.StatusInternalServerError, \"Unable to load datasource meta data\", err)\n\t\treturn\n\t}\n\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), ds.Type)\n\tif !exists {\n\t\tc.JsonApiErr(http.StatusInternalServerError, \"Unable to find datasource plugin\", err)\n\t\treturn\n\t}\n\n\ths.callPluginResourceWithDataSource(c, plugin.ID, ds)\n}\n\nfunc (hs *HTTPServer) convertModelToDtos(ctx context.Context, ds *datasources.DataSource) dtos.DataSource {\n\tdto := dtos.DataSource{\n\t\tId:               ds.Id,\n\t\tUID:              ds.Uid,\n\t\tOrgId:            ds.OrgId,\n\t\tName:             ds.Name,\n\t\tUrl:              ds.Url,\n\t\tType:             ds.Type,\n\t\tAccess:           ds.Access,\n\t\tDatabase:         ds.Database,\n\t\tUser:             ds.User,\n\t\tBasicAuth:        ds.BasicAuth,\n\t\tBasicAuthUser:    ds.BasicAuthUser,\n\t\tWithCredentials:  ds.WithCredentials,\n\t\tIsDefault:        ds.IsDefault,\n\t\tJsonData:         ds.JsonData,\n\t\tSecureJsonFields: map[string]bool{},\n\t\tVersion:          ds.Version,\n\t\tReadOnly:         ds.ReadOnly,\n\t}\n\n\tsecrets, err := hs.DataSourcesService.DecryptedValues(ctx, ds)\n\tif err == nil {\n\t\tfor k, v := range secrets {\n\t\t\tif len(v) > 0 {\n\t\t\t\tdto.SecureJsonFields[k] = true\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdatasourcesLogger.Debug(\"Failed to retrieve datasource secrets to parse secure json fields\", \"error\", err)\n\t}\n\n\treturn dto\n}\n\n// swagger:route GET /datasources/uid/{uid}/health datasources checkDatasourceHealthWithUID\n//\n// Sends a health check request to the plugin datasource identified by the UID.\n//\n// Responses:\n// 200: okResponse\n// 400: badRequestError\n// 401: unauthorisedError\n// 403: forbiddenError\n// 500: internalServerError\nfunc (hs *HTTPServer) CheckDatasourceHealthWithUID(c *models.ReqContext) response.Response {\n\tdsUID := web.Params(c.Req)[\":uid\"]\n\tif !util.IsValidShortUID(dsUID) {\n\t\treturn response.Error(http.StatusBadRequest, \"UID is invalid\", nil)\n\t}\n\n\tds, err := hs.DataSourceCache.GetDatasourceByUID(c.Req.Context(), dsUID, c.SignedInUser, c.SkipCache)\n\tif err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceAccessDenied) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Access denied to datasource\", err)\n\t\t}\n\t\treturn response.Error(http.StatusInternalServerError, \"Unable to load datasource metadata\", err)\n\t}\n\treturn hs.checkDatasourceHealth(c, ds)\n}\n\n// swagger:route GET /datasources/{id}/health datasources checkDatasourceHealthByID\n//\n// Sends a health check request to the plugin datasource identified by the ID.\n//\n// Please refer to [updated API](#/datasources/checkDatasourceHealthWithUID) instead\n//\n// Deprecated: true\n//\n// Responses:\n// 200: okResponse\n// 400: badRequestError\n// 401: unauthorisedError\n// 403: forbiddenError\n// 500: internalServerError\nfunc (hs *HTTPServer) CheckDatasourceHealth(c *models.ReqContext) response.Response {\n\tdatasourceID, err := strconv.ParseInt(web.Params(c.Req)[\":id\"], 10, 64)\n\tif err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"id is invalid\", nil)\n\t}\n\n\tds, err := hs.DataSourceCache.GetDatasource(c.Req.Context(), datasourceID, c.SignedInUser, c.SkipCache)\n\tif err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceAccessDenied) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Access denied to datasource\", err)\n\t\t}\n\t\treturn response.Error(http.StatusInternalServerError, \"Unable to load datasource metadata\", err)\n\t}\n\treturn hs.checkDatasourceHealth(c, ds)\n}\n\nfunc (hs *HTTPServer) checkDatasourceHealth(c *models.ReqContext, ds *datasources.DataSource) response.Response {\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), ds.Type)\n\tif !exists {\n\t\treturn response.Error(http.StatusInternalServerError, \"Unable to find datasource plugin\", nil)\n\t}\n\n\tdsInstanceSettings, err := adapters.ModelToInstanceSettings(ds, hs.decryptSecureJsonDataFn(c.Req.Context()))\n\tif err != nil {\n\t\treturn response.Error(http.StatusInternalServerError, \"Unable to get datasource model\", err)\n\t}\n\treq := &backend.CheckHealthRequest{\n\t\tPluginContext: backend.PluginContext{\n\t\t\tUser:                       adapters.BackendUserFromSignedInUser(c.SignedInUser),\n\t\t\tOrgID:                      c.OrgId,\n\t\t\tPluginID:                   plugin.ID,\n\t\t\tDataSourceInstanceSettings: dsInstanceSettings,\n\t\t},\n\t\tHeaders: map[string]string{},\n\t}\n\n\tvar dsURL string\n\tif req.PluginContext.DataSourceInstanceSettings != nil {\n\t\tdsURL = req.PluginContext.DataSourceInstanceSettings.URL\n\t}\n\n\terr = hs.PluginRequestValidator.Validate(dsURL, c.Req)\n\tif err != nil {\n\t\treturn response.Error(http.StatusForbidden, \"Access denied\", err)\n\t}\n\n\tif hs.DataProxy.OAuthTokenService.IsOAuthPassThruEnabled(ds) {\n\t\tif token := hs.DataProxy.OAuthTokenService.GetCurrentOAuthToken(c.Req.Context(), c.SignedInUser); token != nil {\n\t\t\treq.Headers[\"Authorization\"] = fmt.Sprintf(\"%s %s\", token.Type(), token.AccessToken)\n\t\t\tidToken, ok := token.Extra(\"id_token\").(string)\n\t\t\tif ok && idToken != \"\" {\n\t\t\t\treq.Headers[\"X-ID-Token\"] = idToken\n\t\t\t}\n\t\t}\n\t}\n\n\tproxyutil.ClearCookieHeader(c.Req, ds.AllowedCookies())\n\tif cookieStr := c.Req.Header.Get(\"Cookie\"); cookieStr != \"\" {\n\t\treq.Headers[\"Cookie\"] = cookieStr\n\t}\n\n\tresp, err := hs.pluginClient.CheckHealth(c.Req.Context(), req)\n\tif err != nil {\n\t\treturn translatePluginRequestErrorToAPIError(err)\n\t}\n\n\tpayload := map[string]interface{}{\n\t\t\"status\":  resp.Status.String(),\n\t\t\"message\": resp.Message,\n\t}\n\n\t// Unmarshal JSONDetails if it's not empty.\n\tif len(resp.JSONDetails) > 0 {\n\t\tvar jsonDetails map[string]interface{}\n\t\terr = json.Unmarshal(resp.JSONDetails, &jsonDetails)\n\t\tif err != nil {\n\t\t\treturn response.Error(http.StatusInternalServerError, \"Failed to unmarshal detailed response from backend plugin\", err)\n\t\t}\n\n\t\tpayload[\"details\"] = jsonDetails\n\t}\n\n\tif resp.Status != backend.HealthStatusOk {\n\t\treturn response.JSON(http.StatusBadRequest, payload)\n\t}\n\n\treturn response.JSON(http.StatusOK, payload)\n}\n\nfunc (hs *HTTPServer) decryptSecureJsonDataFn(ctx context.Context) func(ds *datasources.DataSource) (map[string]string, error) {\n\treturn func(ds *datasources.DataSource) (map[string]string, error) {\n\t\treturn hs.DataSourcesService.DecryptedValues(ctx, ds)\n\t}\n}\n\nfunc (hs *HTTPServer) filterDatasourcesByQueryPermission(ctx context.Context, user *models.SignedInUser, ds []*datasources.DataSource) ([]*datasources.DataSource, error) {\n\tquery := datasources.DatasourcesPermissionFilterQuery{\n\t\tUser:        user,\n\t\tDatasources: ds,\n\t}\n\tquery.Result = ds\n\n\tif err := hs.DatasourcePermissionsService.FilterDatasourcesBasedOnQueryPermissions(ctx, &query); err != nil {\n\t\tif !errors.Is(err, permissions.ErrNotImplemented) {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn ds, nil\n\t}\n\n\treturn query.Result, nil\n}\n\n// swagger:parameters checkDatasourceHealthByID\ntype CheckDatasourceHealthByIDParams struct {\n\t// in:path\n\t// required:true\n\tDatasourceID string `json:\"id\"`\n}\n\n// swagger:parameters callDatasourceResourceByID\ntype CallDatasourceResourceByIDParams struct {\n\t// in:path\n\t// required:true\n\tDatasourceID string `json:\"id\"`\n}\n\n// swagger:parameters deleteDataSourceByID\ntype DeleteDataSourceByIDParams struct {\n\t// in:path\n\t// required:true\n\tDatasourceID string `json:\"id\"`\n}\n\n// swagger:parameters getDataSourceByID\ntype GetDataSourceByIDParams struct {\n\t// in:path\n\t// required:true\n\tDatasourceID string `json:\"id\"`\n}\n\n// swagger:parameters checkDatasourceHealthWithUID\ntype CheckDatasourceHealthWithUIDParams struct {\n\t// in:path\n\t// required:true\n\tDatasourceUID string `json:\"uid\"`\n}\n\n// swagger:parameters callDatasourceResourceWithUID\ntype CallDatasourceResourceWithUIDParams struct {\n\t// in:path\n\t// required:true\n\tDatasourceUID string `json:\"uid\"`\n}\n\n// swagger:parameters deleteDataSourceByUID\ntype DeleteDataSourceByUIDParams struct {\n\t// in:path\n\t// required:true\n\tDatasourceUID string `json:\"uid\"`\n}\n\n// swagger:parameters getDataSourceByUID\ntype GetDataSourceByUIDParams struct {\n\t// in:path\n\t// required:true\n\tDatasourceUID string `json:\"uid\"`\n}\n\n// swagger:parameters getDataSourceByName\ntype GetDataSourceByNameParams struct {\n\t// in:path\n\t// required:true\n\tDatasourceName string `json:\"name\"`\n}\n\n// swagger:parameters deleteDataSourceByName\ntype DeleteDataSourceByNameParams struct {\n\t// in:path\n\t// required:true\n\tDatasourceName string `json:\"name\"`\n}\n\n// swagger:parameters getDataSourceIdByName\ntype GetDataSourceIdByNameParams struct {\n\t// in:path\n\t// required:true\n\tDatasourceName string `json:\"name\"`\n}\n\n// swagger:parameters addDataSource\ntype AddDataSourceParams struct {\n\t// in:body\n\t// required:true\n\tBody datasources.AddDataSourceCommand\n}\n\n// swagger:parameters updateDataSourceByID\ntype UpdateDataSourceByIDParams struct {\n\t// in:body\n\t// required:true\n\tBody datasources.UpdateDataSourceCommand\n\t// in:path\n\t// required:true\n\tDatasourceID string `json:\"id\"`\n}\n\n// swagger:parameters updateDataSourceByUID\ntype UpdateDataSourceByUIDParams struct {\n\t// in:body\n\t// required:true\n\tBody datasources.UpdateDataSourceCommand\n\t// in:path\n\t// required:true\n\tDatasourceUID string `json:\"uid\"`\n}\n\n// swagger:response getDataSourcesResponse\ntype GetDataSourcesResponse struct {\n\t// The response message\n\t// in: body\n\tBody dtos.DataSourceList `json:\"body\"`\n}\n\n// swagger:response getDataSourceResponse\ntype GetDataSourceResponse struct {\n\t// The response message\n\t// in: body\n\tBody dtos.DataSource `json:\"body\"`\n}\n\n// swagger:response createOrUpdateDatasourceResponse\ntype CreateOrUpdateDatasourceResponse struct {\n\t// The response message\n\t// in: body\n\tBody struct {\n\t\t// ID Identifier of the new data source.\n\t\t// required: true\n\t\t// example: 65\n\t\tID int64 `json:\"id\"`\n\n\t\t// Name of the new data source.\n\t\t// required: true\n\t\t// example: My Data source\n\t\tName string `json:\"name\"`\n\n\t\t// Message Message of the deleted dashboard.\n\t\t// required: true\n\t\t// example: Data source added\n\t\tMessage string `json:\"message\"`\n\n\t\t// Datasource properties\n\t\t// required: true\n\t\tDatasource dtos.DataSource `json:\"datasource\"`\n\t} `json:\"body\"`\n}\n\n// swagger:response getDataSourceIDResponse\ntype GetDataSourceIDresponse struct {\n\t// The response message\n\t// in: body\n\tBody struct {\n\t\t// ID Identifier of the data source.\n\t\t// required: true\n\t\t// example: 65\n\t\tID int64 `json:\"id\"`\n\t} `json:\"body\"`\n}\n\n// swagger:response deleteDataSourceByNameResponse\ntype DeleteDataSourceByNameResponse struct {\n\t// The response message\n\t// in: body\n\tBody struct {\n\t\t// ID Identifier of the deleted data source.\n\t\t// required: true\n\t\t// example: 65\n\t\tID int64 `json:\"id\"`\n\n\t\t// Message Message of the deleted dashboard.\n\t\t// required: true\n\t\t// example: Dashboard My Dashboard deleted\n\t\tMessage string `json:\"message\"`\n\t} `json:\"body\"`\n}\n", "package api\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/grafana/grafana/pkg/services/datasources\"\n\t\"github.com/grafana/grafana/pkg/services/featuremgmt\"\n\t\"github.com/grafana/grafana/pkg/services/quota/quotatest\"\n\t\"github.com/grafana/grafana/pkg/web/webtest\"\n\n\t\"golang.org/x/oauth2\"\n\n\t\"github.com/grafana/grafana/pkg/models\"\n\tfakeDatasources \"github.com/grafana/grafana/pkg/services/datasources/fakes\"\n\t\"github.com/grafana/grafana/pkg/services/query\"\n)\n\nvar queryDatasourceInput = `{\n\"from\": \"\",\n\t\t\"to\": \"\",\n\t\t\"queries\": [\n\t\t\t{\n\t\t\t\t\"datasource\": {\n\t\t\t\t\t\"type\": \"datasource\",\n\t\t\t\t\t\"uid\": \"grafana\"\n\t\t\t\t},\n\t\t\t\t\"queryType\": \"randomWalk\",\n\t\t\t\t\"refId\": \"A\"\n\t\t\t}\n\t\t]\n\t}`\n\ntype fakePluginRequestValidator struct {\n\terr error\n}\n\ntype secretsErrorResponseBody struct {\n\tError   string `json:\"error\"`\n\tMessage string `json:\"message\"`\n}\n\nfunc (rv *fakePluginRequestValidator) Validate(dsURL string, req *http.Request) error {\n\treturn rv.err\n}\n\ntype fakeOAuthTokenService struct {\n\tpassThruEnabled bool\n\ttoken           *oauth2.Token\n}\n\nfunc (ts *fakeOAuthTokenService) GetCurrentOAuthToken(context.Context, *models.SignedInUser) *oauth2.Token {\n\treturn ts.token\n}\n\nfunc (ts *fakeOAuthTokenService) IsOAuthPassThruEnabled(*datasources.DataSource) bool {\n\treturn ts.passThruEnabled\n}\n\n// `/ds/query` endpoint test\nfunc TestAPIEndpoint_Metrics_QueryMetricsV2(t *testing.T) {\n\tqds := query.ProvideService(\n\t\tnil,\n\t\tnil,\n\t\tnil,\n\t\t&fakePluginRequestValidator{},\n\t\t&fakeDatasources.FakeDataSourceService{},\n\t\t&fakePluginClient{\n\t\t\tQueryDataHandlerFunc: func(ctx context.Context, req *backend.QueryDataRequest) (*backend.QueryDataResponse, error) {\n\t\t\t\tresp := backend.Responses{\n\t\t\t\t\t\"A\": backend.DataResponse{\n\t\t\t\t\t\tError: fmt.Errorf(\"query failed\"),\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn &backend.QueryDataResponse{Responses: resp}, nil\n\t\t\t},\n\t\t},\n\t\t&fakeOAuthTokenService{},\n\t)\n\tserverFeatureEnabled := SetupAPITestServer(t, func(hs *HTTPServer) {\n\t\ths.queryDataService = qds\n\t\ths.Features = featuremgmt.WithFeatures(featuremgmt.FlagDatasourceQueryMultiStatus, true)\n\t\ths.QuotaService = quotatest.NewQuotaServiceFake()\n\t})\n\tserverFeatureDisabled := SetupAPITestServer(t, func(hs *HTTPServer) {\n\t\ths.queryDataService = qds\n\t\ths.Features = featuremgmt.WithFeatures(featuremgmt.FlagDatasourceQueryMultiStatus, false)\n\t\ths.QuotaService = quotatest.NewQuotaServiceFake()\n\t})\n\n\tt.Run(\"Status code is 400 when data source response has an error and feature toggle is disabled\", func(t *testing.T) {\n\t\treq := serverFeatureDisabled.NewPostRequest(\"/api/ds/query\", strings.NewReader(queryDatasourceInput))\n\t\twebtest.RequestWithSignedInUser(req, &models.SignedInUser{UserId: 1, OrgId: 1, OrgRole: models.ROLE_VIEWER})\n\t\tresp, err := serverFeatureDisabled.SendJSON(req)\n\t\trequire.NoError(t, err)\n\t\trequire.NoError(t, resp.Body.Close())\n\t\trequire.Equal(t, http.StatusBadRequest, resp.StatusCode)\n\t})\n\n\tt.Run(\"Status code is 207 when data source response has an error and feature toggle is enabled\", func(t *testing.T) {\n\t\treq := serverFeatureEnabled.NewPostRequest(\"/api/ds/query\", strings.NewReader(queryDatasourceInput))\n\t\twebtest.RequestWithSignedInUser(req, &models.SignedInUser{UserId: 1, OrgId: 1, OrgRole: models.ROLE_VIEWER})\n\t\tresp, err := serverFeatureEnabled.SendJSON(req)\n\t\trequire.NoError(t, err)\n\t\trequire.NoError(t, resp.Body.Close())\n\t\trequire.Equal(t, http.StatusMultiStatus, resp.StatusCode)\n\t})\n}\n\nfunc TestAPIEndpoint_Metrics_PluginDecryptionFailure(t *testing.T) {\n\tqds := query.ProvideService(\n\t\tnil,\n\t\tnil,\n\t\tnil,\n\t\t&fakePluginRequestValidator{},\n\t\t&fakeDatasources.FakeDataSourceService{SimulatePluginFailure: true},\n\t\t&fakePluginClient{\n\t\t\tQueryDataHandlerFunc: func(ctx context.Context, req *backend.QueryDataRequest) (*backend.QueryDataResponse, error) {\n\t\t\t\tresp := backend.Responses{\n\t\t\t\t\t\"A\": backend.DataResponse{\n\t\t\t\t\t\tError: fmt.Errorf(\"query failed\"),\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn &backend.QueryDataResponse{Responses: resp}, nil\n\t\t\t},\n\t\t},\n\t\t&fakeOAuthTokenService{},\n\t)\n\thttpServer := SetupAPITestServer(t, func(hs *HTTPServer) {\n\t\ths.queryDataService = qds\n\t\ths.QuotaService = quotatest.NewQuotaServiceFake()\n\t})\n\n\tt.Run(\"Status code is 500 and a secrets plugin error is returned if there is a problem getting secrets from the remote plugin\", func(t *testing.T) {\n\t\treq := httpServer.NewPostRequest(\"/api/ds/query\", strings.NewReader(queryDatasourceInput))\n\t\twebtest.RequestWithSignedInUser(req, &models.SignedInUser{UserId: 1, OrgId: 1, OrgRole: models.ROLE_VIEWER})\n\t\tresp, err := httpServer.SendJSON(req)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, http.StatusInternalServerError, resp.StatusCode)\n\t\tbuf := new(bytes.Buffer)\n\t\t_, err = buf.ReadFrom(resp.Body)\n\t\trequire.NoError(t, err)\n\t\trequire.NoError(t, resp.Body.Close())\n\t\tvar resObj secretsErrorResponseBody\n\t\terr = json.Unmarshal(buf.Bytes(), &resObj)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, \"unknown error\", resObj.Error)\n\t\trequire.Contains(t, resObj.Message, \"Secrets Plugin error:\")\n\t})\n}\n", "package api\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"sync\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins/backendplugin\"\n\t\"github.com/grafana/grafana/pkg/services/contexthandler\"\n\t\"github.com/grafana/grafana/pkg/services/datasources\"\n\t\"github.com/grafana/grafana/pkg/util/proxyutil\"\n\t\"github.com/grafana/grafana/pkg/web\"\n)\n\n// CallResource passes a resource call from a plugin to the backend plugin.\n//\n// /api/plugins/:pluginId/resources/*\nfunc (hs *HTTPServer) CallResource(c *models.ReqContext) {\n\ths.callPluginResource(c, web.Params(c.Req)[\":pluginId\"])\n}\n\nfunc (hs *HTTPServer) callPluginResource(c *models.ReqContext, pluginID string) {\n\tpCtx, found, err := hs.PluginContextProvider.Get(c.Req.Context(), pluginID, c.SignedInUser)\n\tif err != nil {\n\t\tc.JsonApiErr(500, \"Failed to get plugin settings\", err)\n\t\treturn\n\t}\n\tif !found {\n\t\tc.JsonApiErr(404, \"Plugin not found\", nil)\n\t\treturn\n\t}\n\n\treq, err := hs.pluginResourceRequest(c)\n\tif err != nil {\n\t\tc.JsonApiErr(http.StatusBadRequest, \"Failed for create plugin resource request\", err)\n\t\treturn\n\t}\n\n\tif err = hs.makePluginResourceRequest(c.Resp, req, pCtx); err != nil {\n\t\thandleCallResourceError(err, c)\n\t}\n}\n\nfunc (hs *HTTPServer) callPluginResourceWithDataSource(c *models.ReqContext, pluginID string, ds *datasources.DataSource) {\n\tpCtx, found, err := hs.PluginContextProvider.GetWithDataSource(c.Req.Context(), pluginID, c.SignedInUser, ds)\n\tif err != nil {\n\t\tc.JsonApiErr(500, \"Failed to get plugin settings\", err)\n\t\treturn\n\t}\n\tif !found {\n\t\tc.JsonApiErr(404, \"Plugin not found\", nil)\n\t\treturn\n\t}\n\n\tvar dsURL string\n\tif pCtx.DataSourceInstanceSettings != nil {\n\t\tdsURL = pCtx.DataSourceInstanceSettings.URL\n\t}\n\n\terr = hs.PluginRequestValidator.Validate(dsURL, c.Req)\n\tif err != nil {\n\t\tc.JsonApiErr(http.StatusForbidden, \"Access denied\", err)\n\t\treturn\n\t}\n\n\treq, err := hs.pluginResourceRequest(c)\n\tif err != nil {\n\t\tc.JsonApiErr(http.StatusBadRequest, \"Failed for create plugin resource request\", err)\n\t\treturn\n\t}\n\n\tif hs.DataProxy.OAuthTokenService.IsOAuthPassThruEnabled(ds) {\n\t\tif token := hs.DataProxy.OAuthTokenService.GetCurrentOAuthToken(c.Req.Context(), c.SignedInUser); token != nil {\n\t\t\treq.Header.Add(\"Authorization\", fmt.Sprintf(\"%s %s\", token.Type(), token.AccessToken))\n\n\t\t\tidToken, ok := token.Extra(\"id_token\").(string)\n\t\t\tif ok && idToken != \"\" {\n\t\t\t\treq.Header.Add(\"X-ID-Token\", idToken)\n\t\t\t}\n\t\t}\n\t}\n\n\tif err = hs.makePluginResourceRequest(c.Resp, req, pCtx); err != nil {\n\t\thandleCallResourceError(err, c)\n\t}\n}\n\nfunc (hs *HTTPServer) pluginResourceRequest(c *models.ReqContext) (*http.Request, error) {\n\tclonedReq := c.Req.Clone(c.Req.Context())\n\trawURL := web.Params(c.Req)[\"*\"]\n\tif clonedReq.URL.RawQuery != \"\" {\n\t\trawURL += \"?\" + clonedReq.URL.RawQuery\n\t}\n\turlPath, err := url.Parse(rawURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclonedReq.URL = urlPath\n\n\treturn clonedReq, nil\n}\n\nfunc (hs *HTTPServer) makePluginResourceRequest(w http.ResponseWriter, req *http.Request, pCtx backend.PluginContext) error {\n\tkeepCookieModel := struct {\n\t\tKeepCookies []string `json:\"keepCookies\"`\n\t}{}\n\tif dis := pCtx.DataSourceInstanceSettings; dis != nil {\n\t\terr := json.Unmarshal(dis.JSONData, &keepCookieModel)\n\t\tif err != nil {\n\t\t\ths.log.Warn(\"failed to unpack JSONData in datasource instance settings\", \"err\", err)\n\t\t}\n\t}\n\n\tlist := contexthandler.AuthHTTPHeaderListFromContext(req.Context())\n\tif list != nil {\n\t\tfor _, name := range list.Items {\n\t\t\treq.Header.Del(name)\n\t\t}\n\t}\n\n\tproxyutil.ClearCookieHeader(req, keepCookieModel.KeepCookies)\n\tproxyutil.PrepareProxyRequest(req)\n\n\tbody, err := ioutil.ReadAll(req.Body)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read request body: %w\", err)\n\t}\n\n\tcrReq := &backend.CallResourceRequest{\n\t\tPluginContext: pCtx,\n\t\tPath:          req.URL.Path,\n\t\tMethod:        req.Method,\n\t\tURL:           req.URL.String(),\n\t\tHeaders:       req.Header,\n\t\tBody:          body,\n\t}\n\n\tchildCtx, cancel := context.WithCancel(req.Context())\n\tdefer cancel()\n\tstream := newCallResourceResponseStream(childCtx)\n\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\n\tdefer func() {\n\t\tif err := stream.Close(); err != nil {\n\t\t\ths.log.Warn(\"Failed to close plugin resource stream\", \"err\", err)\n\t\t}\n\t\twg.Wait()\n\t}()\n\n\tvar flushStreamErr error\n\tgo func() {\n\t\tflushStreamErr = hs.flushStream(stream, w)\n\t\twg.Done()\n\t}()\n\n\tif err := hs.pluginClient.CallResource(req.Context(), crReq, stream); err != nil {\n\t\treturn err\n\t}\n\n\treturn flushStreamErr\n}\n\nfunc (hs *HTTPServer) flushStream(stream callResourceClientResponseStream, w http.ResponseWriter) error {\n\tprocessedStreams := 0\n\n\tfor {\n\t\tresp, err := stream.Recv()\n\t\tif errors.Is(err, io.EOF) {\n\t\t\tif processedStreams == 0 {\n\t\t\t\treturn errors.New(\"received empty resource response\")\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\tif err != nil {\n\t\t\tif processedStreams == 0 {\n\t\t\t\treturn fmt.Errorf(\"%v: %w\", \"failed to receive response from resource call\", err)\n\t\t\t}\n\n\t\t\ths.log.Error(\"Failed to receive response from resource call\", \"err\", err)\n\t\t\treturn stream.Close()\n\t\t}\n\n\t\t// Expected that headers and status are only part of first stream\n\t\tif processedStreams == 0 && resp.Headers != nil {\n\t\t\t// Make sure a content type always is returned in response\n\t\t\tif _, exists := resp.Headers[\"Content-Type\"]; !exists {\n\t\t\t\tresp.Headers[\"Content-Type\"] = []string{\"application/json\"}\n\t\t\t}\n\n\t\t\tfor k, values := range resp.Headers {\n\t\t\t\t// Due to security reasons we don't want to forward\n\t\t\t\t// cookies from a backend plugin to clients/browsers.\n\t\t\t\tif k == \"Set-Cookie\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfor _, v := range values {\n\t\t\t\t\t// TODO: Figure out if we should use Set here instead\n\t\t\t\t\t// nolint:gocritic\n\t\t\t\t\tw.Header().Add(k, v)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tproxyutil.SetProxyResponseHeaders(w.Header())\n\n\t\t\tw.WriteHeader(resp.Status)\n\t\t}\n\n\t\tif _, err := w.Write(resp.Body); err != nil {\n\t\t\ths.log.Error(\"Failed to write resource response\", \"err\", err)\n\t\t}\n\n\t\tif flusher, ok := w.(http.Flusher); ok {\n\t\t\tflusher.Flush()\n\t\t}\n\t\tprocessedStreams++\n\t}\n}\n\nfunc handleCallResourceError(err error, reqCtx *models.ReqContext) {\n\tif errors.Is(err, backendplugin.ErrPluginUnavailable) {\n\t\treqCtx.JsonApiErr(503, \"Plugin unavailable\", err)\n\t\treturn\n\t}\n\n\tif errors.Is(err, backendplugin.ErrMethodNotImplemented) {\n\t\treqCtx.JsonApiErr(404, \"Not found\", err)\n\t\treturn\n\t}\n\n\treqCtx.JsonApiErr(500, \"Failed to call resource\", err)\n}\n\n// callResourceClientResponseStream is used for receiving resource call responses.\ntype callResourceClientResponseStream interface {\n\tRecv() (*backend.CallResourceResponse, error)\n\tClose() error\n}\n\ntype callResourceResponseStream struct {\n\tctx    context.Context\n\tstream chan *backend.CallResourceResponse\n\tclosed bool\n}\n\nfunc newCallResourceResponseStream(ctx context.Context) *callResourceResponseStream {\n\treturn &callResourceResponseStream{\n\t\tctx:    ctx,\n\t\tstream: make(chan *backend.CallResourceResponse),\n\t}\n}\n\nfunc (s *callResourceResponseStream) Send(res *backend.CallResourceResponse) error {\n\tif s.closed {\n\t\treturn errors.New(\"cannot send to a closed stream\")\n\t}\n\n\tselect {\n\tcase <-s.ctx.Done():\n\t\treturn errors.New(\"cancelled\")\n\tcase s.stream <- res:\n\t\treturn nil\n\t}\n}\n\nfunc (s *callResourceResponseStream) Recv() (*backend.CallResourceResponse, error) {\n\tselect {\n\tcase <-s.ctx.Done():\n\t\treturn nil, s.ctx.Err()\n\tcase res, ok := <-s.stream:\n\t\tif !ok {\n\t\t\treturn nil, io.EOF\n\t\t}\n\t\treturn res, nil\n\t}\n}\n\nfunc (s *callResourceResponseStream) Close() error {\n\tif s.closed {\n\t\treturn errors.New(\"cannot close a closed stream\")\n\t}\n\n\tclose(s.stream)\n\ts.closed = true\n\treturn nil\n}\n", "package pluginproxy\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"go.opentelemetry.io/otel/attribute\"\n\n\t\"github.com/grafana/grafana/pkg/api/datasource\"\n\t\"github.com/grafana/grafana/pkg/infra/httpclient\"\n\tglog \"github.com/grafana/grafana/pkg/infra/log\"\n\t\"github.com/grafana/grafana/pkg/infra/tracing\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\t\"github.com/grafana/grafana/pkg/services/datasources\"\n\t\"github.com/grafana/grafana/pkg/services/oauthtoken\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util\"\n\t\"github.com/grafana/grafana/pkg/util/proxyutil\"\n)\n\nvar (\n\tlogger = glog.New(\"data-proxy-log\")\n\tclient = newHTTPClient()\n)\n\ntype DataSourceProxy struct {\n\tds                 *datasources.DataSource\n\tctx                *models.ReqContext\n\ttargetUrl          *url.URL\n\tproxyPath          string\n\tmatchedRoute       *plugins.Route\n\tpluginRoutes       []*plugins.Route\n\tcfg                *setting.Cfg\n\tclientProvider     httpclient.Provider\n\toAuthTokenService  oauthtoken.OAuthTokenService\n\tdataSourcesService datasources.DataSourceService\n\ttracer             tracing.Tracer\n}\n\ntype httpClient interface {\n\tDo(req *http.Request) (*http.Response, error)\n}\n\n// NewDataSourceProxy creates a new Datasource proxy\nfunc NewDataSourceProxy(ds *datasources.DataSource, pluginRoutes []*plugins.Route, ctx *models.ReqContext,\n\tproxyPath string, cfg *setting.Cfg, clientProvider httpclient.Provider,\n\toAuthTokenService oauthtoken.OAuthTokenService, dsService datasources.DataSourceService,\n\ttracer tracing.Tracer) (*DataSourceProxy, error) {\n\ttargetURL, err := datasource.ValidateURL(ds.Type, ds.Url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &DataSourceProxy{\n\t\tds:                 ds,\n\t\tpluginRoutes:       pluginRoutes,\n\t\tctx:                ctx,\n\t\tproxyPath:          proxyPath,\n\t\ttargetUrl:          targetURL,\n\t\tcfg:                cfg,\n\t\tclientProvider:     clientProvider,\n\t\toAuthTokenService:  oAuthTokenService,\n\t\tdataSourcesService: dsService,\n\t\ttracer:             tracer,\n\t}, nil\n}\n\nfunc newHTTPClient() httpClient {\n\treturn &http.Client{\n\t\tTimeout:   30 * time.Second,\n\t\tTransport: &http.Transport{Proxy: http.ProxyFromEnvironment},\n\t}\n}\n\nfunc (proxy *DataSourceProxy) HandleRequest() {\n\tif err := proxy.validateRequest(); err != nil {\n\t\tproxy.ctx.JsonApiErr(403, err.Error(), nil)\n\t\treturn\n\t}\n\n\ttraceID := tracing.TraceIDFromContext(proxy.ctx.Req.Context(), false)\n\tproxyErrorLogger := logger.New(\n\t\t\"userId\", proxy.ctx.UserId,\n\t\t\"orgId\", proxy.ctx.OrgId,\n\t\t\"uname\", proxy.ctx.Login,\n\t\t\"path\", proxy.ctx.Req.URL.Path,\n\t\t\"remote_addr\", proxy.ctx.RemoteAddr(),\n\t\t\"referer\", proxy.ctx.Req.Referer(),\n\t\t\"traceID\", traceID,\n\t)\n\n\ttransport, err := proxy.dataSourcesService.GetHTTPTransport(proxy.ctx.Req.Context(), proxy.ds, proxy.clientProvider)\n\tif err != nil {\n\t\tproxy.ctx.JsonApiErr(400, \"Unable to load TLS certificate\", err)\n\t\treturn\n\t}\n\n\tmodifyResponse := func(resp *http.Response) error {\n\t\tif resp.StatusCode == 401 {\n\t\t\t// The data source rejected the request as unauthorized, convert to 400 (bad request)\n\t\t\tbody, err := ioutil.ReadAll(resp.Body)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to read data source response body: %w\", err)\n\t\t\t}\n\t\t\t_ = resp.Body.Close()\n\n\t\t\tproxyErrorLogger.Info(\"Authentication to data source failed\", \"body\", string(body), \"statusCode\",\n\t\t\t\tresp.StatusCode)\n\t\t\tmsg := \"Authentication to data source failed\"\n\t\t\t*resp = http.Response{\n\t\t\t\tStatusCode:    400,\n\t\t\t\tStatus:        \"Bad Request\",\n\t\t\t\tBody:          ioutil.NopCloser(strings.NewReader(msg)),\n\t\t\t\tContentLength: int64(len(msg)),\n\t\t\t\tHeader:        http.Header{},\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\treverseProxy := proxyutil.NewReverseProxy(\n\t\tproxyErrorLogger,\n\t\tproxy.director,\n\t\tproxyutil.WithTransport(transport),\n\t\tproxyutil.WithModifyResponse(modifyResponse),\n\t)\n\n\tproxy.logRequest()\n\tctx, span := proxy.tracer.Start(proxy.ctx.Req.Context(), \"datasource reverse proxy\")\n\tdefer span.End()\n\n\tproxy.ctx.Req = proxy.ctx.Req.WithContext(ctx)\n\n\tspan.SetAttributes(\"datasource_name\", proxy.ds.Name, attribute.Key(\"datasource_name\").String(proxy.ds.Name))\n\tspan.SetAttributes(\"datasource_type\", proxy.ds.Type, attribute.Key(\"datasource_type\").String(proxy.ds.Type))\n\tspan.SetAttributes(\"user\", proxy.ctx.SignedInUser.Login, attribute.Key(\"user\").String(proxy.ctx.SignedInUser.Login))\n\tspan.SetAttributes(\"org_id\", proxy.ctx.SignedInUser.OrgId, attribute.Key(\"org_id\").Int64(proxy.ctx.SignedInUser.OrgId))\n\n\tproxy.addTraceFromHeaderValue(span, \"X-Panel-Id\", \"panel_id\")\n\tproxy.addTraceFromHeaderValue(span, \"X-Dashboard-Id\", \"dashboard_id\")\n\n\tproxy.tracer.Inject(ctx, proxy.ctx.Req.Header, span)\n\n\treverseProxy.ServeHTTP(proxy.ctx.Resp, proxy.ctx.Req)\n}\n\nfunc (proxy *DataSourceProxy) addTraceFromHeaderValue(span tracing.Span, headerName string, tagName string) {\n\tpanelId := proxy.ctx.Req.Header.Get(headerName)\n\tdashId, err := strconv.Atoi(panelId)\n\tif err == nil {\n\t\tspan.SetAttributes(tagName, dashId, attribute.Key(tagName).Int(dashId))\n\t}\n}\n\nfunc (proxy *DataSourceProxy) director(req *http.Request) {\n\treq.URL.Scheme = proxy.targetUrl.Scheme\n\treq.URL.Host = proxy.targetUrl.Host\n\treq.Host = proxy.targetUrl.Host\n\n\treqQueryVals := req.URL.Query()\n\n\tswitch proxy.ds.Type {\n\tcase datasources.DS_INFLUXDB_08:\n\t\tpassword, err := proxy.dataSourcesService.DecryptedPassword(req.Context(), proxy.ds)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Error interpolating proxy url\", \"error\", err)\n\t\t\treturn\n\t\t}\n\n\t\treq.URL.RawPath = util.JoinURLFragments(proxy.targetUrl.Path, \"db/\"+proxy.ds.Database+\"/\"+proxy.proxyPath)\n\t\treqQueryVals.Add(\"u\", proxy.ds.User)\n\t\treqQueryVals.Add(\"p\", password)\n\t\treq.URL.RawQuery = reqQueryVals.Encode()\n\tcase datasources.DS_INFLUXDB:\n\t\tpassword, err := proxy.dataSourcesService.DecryptedPassword(req.Context(), proxy.ds)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Error interpolating proxy url\", \"error\", err)\n\t\t\treturn\n\t\t}\n\t\treq.URL.RawPath = util.JoinURLFragments(proxy.targetUrl.Path, proxy.proxyPath)\n\t\treq.URL.RawQuery = reqQueryVals.Encode()\n\t\tif !proxy.ds.BasicAuth {\n\t\t\treq.Header.Set(\n\t\t\t\t\"Authorization\",\n\t\t\t\tutil.GetBasicAuthHeader(proxy.ds.User, password),\n\t\t\t)\n\t\t}\n\tdefault:\n\t\treq.URL.RawPath = util.JoinURLFragments(proxy.targetUrl.Path, proxy.proxyPath)\n\t}\n\n\tunescapedPath, err := url.PathUnescape(req.URL.RawPath)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to unescape raw path\", \"rawPath\", req.URL.RawPath, \"error\", err)\n\t\treturn\n\t}\n\n\treq.URL.Path = unescapedPath\n\n\tif proxy.ds.BasicAuth {\n\t\tpassword, err := proxy.dataSourcesService.DecryptedBasicAuthPassword(req.Context(), proxy.ds)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Error interpolating proxy url\", \"error\", err)\n\t\t\treturn\n\t\t}\n\t\treq.Header.Set(\"Authorization\", util.GetBasicAuthHeader(proxy.ds.BasicAuthUser,\n\t\t\tpassword))\n\t}\n\n\tdsAuth := req.Header.Get(\"X-DS-Authorization\")\n\tif len(dsAuth) > 0 {\n\t\treq.Header.Del(\"X-DS-Authorization\")\n\t\treq.Header.Set(\"Authorization\", dsAuth)\n\t}\n\n\tapplyUserHeader(proxy.cfg.SendUserHeader, req, proxy.ctx.SignedInUser)\n\n\tproxyutil.ClearCookieHeader(req, proxy.ds.AllowedCookies())\n\treq.Header.Set(\"User-Agent\", fmt.Sprintf(\"Grafana/%s\", setting.BuildVersion))\n\n\tjsonData := make(map[string]interface{})\n\tif proxy.ds.JsonData != nil {\n\t\tjsonData, err = proxy.ds.JsonData.Map()\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Failed to get json data as map\", \"jsonData\", proxy.ds.JsonData, \"error\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\tif proxy.matchedRoute != nil {\n\t\tdecryptedValues, err := proxy.dataSourcesService.DecryptedValues(req.Context(), proxy.ds)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Error interpolating proxy url\", \"error\", err)\n\t\t\treturn\n\t\t}\n\n\t\tApplyRoute(req.Context(), req, proxy.proxyPath, proxy.matchedRoute, DSInfo{\n\t\t\tID:                      proxy.ds.Id,\n\t\t\tUpdated:                 proxy.ds.Updated,\n\t\t\tJSONData:                jsonData,\n\t\t\tDecryptedSecureJSONData: decryptedValues,\n\t\t}, proxy.cfg)\n\t}\n\n\tif proxy.oAuthTokenService.IsOAuthPassThruEnabled(proxy.ds) {\n\t\tif token := proxy.oAuthTokenService.GetCurrentOAuthToken(req.Context(), proxy.ctx.SignedInUser); token != nil {\n\t\t\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"%s %s\", token.Type(), token.AccessToken))\n\n\t\t\tidToken, ok := token.Extra(\"id_token\").(string)\n\t\t\tif ok && idToken != \"\" {\n\t\t\t\treq.Header.Set(\"X-ID-Token\", idToken)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (proxy *DataSourceProxy) validateRequest() error {\n\tif !checkWhiteList(proxy.ctx, proxy.targetUrl.Host) {\n\t\treturn errors.New(\"target URL is not a valid target\")\n\t}\n\n\tif proxy.ds.Type == datasources.DS_ES {\n\t\tif proxy.ctx.Req.Method == \"DELETE\" {\n\t\t\treturn errors.New(\"deletes not allowed on proxied Elasticsearch datasource\")\n\t\t}\n\t\tif proxy.ctx.Req.Method == \"PUT\" {\n\t\t\treturn errors.New(\"puts not allowed on proxied Elasticsearch datasource\")\n\t\t}\n\t\tif proxy.ctx.Req.Method == \"POST\" && proxy.proxyPath != \"_msearch\" {\n\t\t\treturn errors.New(\"posts not allowed on proxied Elasticsearch datasource except on /_msearch\")\n\t\t}\n\t}\n\n\t// found route if there are any\n\tfor _, route := range proxy.pluginRoutes {\n\t\t// method match\n\t\tif route.Method != \"\" && route.Method != \"*\" && route.Method != proxy.ctx.Req.Method {\n\t\t\tcontinue\n\t\t}\n\n\t\t// route match\n\t\tif !strings.HasPrefix(proxy.proxyPath, route.Path) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif route.ReqRole.IsValid() {\n\t\t\tif !proxy.ctx.HasUserRole(route.ReqRole) {\n\t\t\t\treturn errors.New(\"plugin proxy route access denied\")\n\t\t\t}\n\t\t}\n\n\t\tproxy.matchedRoute = route\n\t\treturn nil\n\t}\n\n\t// Trailing validation below this point for routes that were not matched\n\tif proxy.ds.Type == datasources.DS_PROMETHEUS {\n\t\tif proxy.ctx.Req.Method == \"DELETE\" {\n\t\t\treturn errors.New(\"non allow-listed DELETEs not allowed on proxied Prometheus datasource\")\n\t\t}\n\t\tif proxy.ctx.Req.Method == \"PUT\" {\n\t\t\treturn errors.New(\"non allow-listed PUTs not allowed on proxied Prometheus datasource\")\n\t\t}\n\t\tif proxy.ctx.Req.Method == \"POST\" {\n\t\t\treturn errors.New(\"non allow-listed POSTs not allowed on proxied Prometheus datasource\")\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (proxy *DataSourceProxy) logRequest() {\n\tif !proxy.cfg.DataProxyLogging {\n\t\treturn\n\t}\n\n\tvar body string\n\tif proxy.ctx.Req.Body != nil {\n\t\tbuffer, err := ioutil.ReadAll(proxy.ctx.Req.Body)\n\t\tif err == nil {\n\t\t\tproxy.ctx.Req.Body = ioutil.NopCloser(bytes.NewBuffer(buffer))\n\t\t\tbody = string(buffer)\n\t\t}\n\t}\n\n\tlogger.Info(\"Proxying incoming request\",\n\t\t\"userid\", proxy.ctx.UserId,\n\t\t\"orgid\", proxy.ctx.OrgId,\n\t\t\"username\", proxy.ctx.Login,\n\t\t\"datasource\", proxy.ds.Type,\n\t\t\"uri\", proxy.ctx.Req.RequestURI,\n\t\t\"method\", proxy.ctx.Req.Method,\n\t\t\"body\", body)\n}\n\nfunc checkWhiteList(c *models.ReqContext, host string) bool {\n\tif host != \"\" && len(setting.DataProxyWhiteList) > 0 {\n\t\tif _, exists := setting.DataProxyWhiteList[host]; !exists {\n\t\t\tc.JsonApiErr(403, \"Data proxy hostname and ip are not included in whitelist\", nil)\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n", "package httpclientprovider_test\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend/httpclient\"\n\t\"github.com/grafana/grafana/pkg/infra/httpclient/httpclientprovider\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestForwardedCookiesMiddleware(t *testing.T) {\n\ttcs := []struct {\n\t\tdesc                 string\n\t\tallowedCookies       []string\n\t\texpectedCookieHeader string\n\t}{\n\t\t{\n\t\t\tdesc:                 \"With nil allowedCookies should not populate Cookie header\",\n\t\t\tallowedCookies:       nil,\n\t\t\texpectedCookieHeader: \"\",\n\t\t},\n\t\t{\n\t\t\tdesc:                 \"With empty allowed cookies should not populate Cookie header\",\n\t\t\tallowedCookies:       []string{},\n\t\t\texpectedCookieHeader: \"\",\n\t\t},\n\t\t{\n\t\t\tdesc:                 \"When provided with allowed cookies should populate Cookie header\",\n\t\t\tallowedCookies:       []string{\"c1\", \"c3\"},\n\t\t\texpectedCookieHeader: \"c1=1; c3=3\",\n\t\t},\n\t}\n\n\tfor _, tc := range tcs {\n\t\tt.Run(tc.desc, func(t *testing.T) {\n\t\t\tctx := &testContext{}\n\t\t\tfinalRoundTripper := ctx.createRoundTripper()\n\t\t\tforwarded := []*http.Cookie{\n\t\t\t\t{Name: \"c1\", Value: \"1\"},\n\t\t\t\t{Name: \"c2\", Value: \"2\"},\n\t\t\t\t{Name: \"c3\", Value: \"3\"},\n\t\t\t}\n\t\t\tmw := httpclientprovider.ForwardedCookiesMiddleware(forwarded, tc.allowedCookies)\n\t\t\topts := httpclient.Options{}\n\t\t\trt := mw.CreateMiddleware(opts, finalRoundTripper)\n\t\t\trequire.NotNil(t, rt)\n\t\t\tmiddlewareName, ok := mw.(httpclient.MiddlewareName)\n\t\t\trequire.True(t, ok)\n\t\t\trequire.Equal(t, \"forwarded-cookies\", middlewareName.MiddlewareName())\n\n\t\t\treq, err := http.NewRequest(http.MethodGet, \"http://\", nil)\n\t\t\trequire.NoError(t, err)\n\t\t\tres, err := rt.RoundTrip(req)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, res)\n\t\t\tif res.Body != nil {\n\t\t\t\trequire.NoError(t, res.Body.Close())\n\t\t\t}\n\t\t\trequire.Len(t, ctx.callChain, 1)\n\t\t\trequire.ElementsMatch(t, []string{\"final\"}, ctx.callChain)\n\t\t\trequire.Equal(t, tc.expectedCookieHeader, ctx.req.Header.Get(\"Cookie\"))\n\t\t})\n\t}\n}\n", "package httpclientprovider\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend/httpclient\"\n\t\"github.com/grafana/grafana/pkg/util/proxyutil\"\n)\n\nconst ForwardedCookiesMiddlewareName = \"forwarded-cookies\"\n\n// ForwardedCookiesMiddleware middleware that sets Cookie header on the\n// outgoing request, if forwarded cookies configured/provided.\nfunc ForwardedCookiesMiddleware(forwardedCookies []*http.Cookie, allowedCookies []string) httpclient.Middleware {\n\treturn httpclient.NamedMiddlewareFunc(ForwardedCookiesMiddlewareName, func(opts httpclient.Options, next http.RoundTripper) http.RoundTripper {\n\t\treturn httpclient.RoundTripperFunc(func(req *http.Request) (*http.Response, error) {\n\t\t\tfor _, cookie := range forwardedCookies {\n\t\t\t\treq.AddCookie(cookie)\n\t\t\t}\n\t\t\tproxyutil.ClearCookieHeader(req, allowedCookies)\n\t\t\treturn next.RoundTrip(req)\n\t\t})\n\t})\n}\n", "package query\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/grafana/grafana/pkg/api/dtos\"\n\t\"github.com/grafana/grafana/pkg/components/simplejson\"\n\t\"github.com/grafana/grafana/pkg/expr\"\n\t\"github.com/grafana/grafana/pkg/infra/httpclient/httpclientprovider\"\n\t\"github.com/grafana/grafana/pkg/infra/log\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\t\"github.com/grafana/grafana/pkg/plugins/adapters\"\n\t\"github.com/grafana/grafana/pkg/services/datasources\"\n\t\"github.com/grafana/grafana/pkg/services/oauthtoken\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/tsdb/grafanads\"\n\t\"github.com/grafana/grafana/pkg/tsdb/legacydata\"\n\t\"github.com/grafana/grafana/pkg/util/proxyutil\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend/httpclient\"\n)\n\nfunc ProvideService(\n\tcfg *setting.Cfg,\n\tdataSourceCache datasources.CacheService,\n\texpressionService *expr.Service,\n\tpluginRequestValidator models.PluginRequestValidator,\n\tdataSourceService datasources.DataSourceService,\n\tpluginClient plugins.Client,\n\toAuthTokenService oauthtoken.OAuthTokenService,\n) *Service {\n\tg := &Service{\n\t\tcfg:                    cfg,\n\t\tdataSourceCache:        dataSourceCache,\n\t\texpressionService:      expressionService,\n\t\tpluginRequestValidator: pluginRequestValidator,\n\t\tdataSourceService:      dataSourceService,\n\t\tpluginClient:           pluginClient,\n\t\toAuthTokenService:      oAuthTokenService,\n\t\tlog:                    log.New(\"query_data\"),\n\t}\n\tg.log.Info(\"Query Service initialization\")\n\treturn g\n}\n\ntype Service struct {\n\tcfg                    *setting.Cfg\n\tdataSourceCache        datasources.CacheService\n\texpressionService      *expr.Service\n\tpluginRequestValidator models.PluginRequestValidator\n\tdataSourceService      datasources.DataSourceService\n\tpluginClient           plugins.Client\n\toAuthTokenService      oauthtoken.OAuthTokenService\n\tlog                    log.Logger\n}\n\n// Run Service.\nfunc (s *Service) Run(ctx context.Context) error {\n\t<-ctx.Done()\n\treturn ctx.Err()\n}\n\n// QueryData can process queries and return query responses.\nfunc (s *Service) QueryData(ctx context.Context, user *models.SignedInUser, skipCache bool, reqDTO dtos.MetricRequest, handleExpressions bool) (*backend.QueryDataResponse, error) {\n\tparsedReq, err := s.parseMetricRequest(ctx, user, skipCache, reqDTO)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif handleExpressions && parsedReq.hasExpression {\n\t\treturn s.handleExpressions(ctx, user, parsedReq)\n\t}\n\treturn s.handleQueryData(ctx, user, parsedReq)\n}\n\n// QueryData can process queries and return query responses.\nfunc (s *Service) QueryDataMultipleSources(ctx context.Context, user *models.SignedInUser, skipCache bool, reqDTO dtos.MetricRequest, handleExpressions bool) (*backend.QueryDataResponse, error) {\n\tbyDataSource := models.GroupQueriesByDataSource(reqDTO.Queries)\n\n\tif len(byDataSource) == 1 {\n\t\treturn s.QueryData(ctx, user, skipCache, reqDTO, handleExpressions)\n\t} else {\n\t\tresp := backend.NewQueryDataResponse()\n\n\t\tfor _, queries := range byDataSource {\n\t\t\tsubDTO := reqDTO.CloneWithQueries(queries)\n\n\t\t\tsubResp, err := s.QueryData(ctx, user, skipCache, subDTO, handleExpressions)\n\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tfor refId, queryResponse := range subResp.Responses {\n\t\t\t\tresp.Responses[refId] = queryResponse\n\t\t\t}\n\t\t}\n\n\t\treturn resp, nil\n\t}\n}\n\n// handleExpressions handles POST /api/ds/query when there is an expression.\nfunc (s *Service) handleExpressions(ctx context.Context, user *models.SignedInUser, parsedReq *parsedRequest) (*backend.QueryDataResponse, error) {\n\texprReq := expr.Request{\n\t\tOrgId:   user.OrgId,\n\t\tQueries: []expr.Query{},\n\t}\n\n\tfor _, pq := range parsedReq.parsedQueries {\n\t\tif pq.datasource == nil {\n\t\t\treturn nil, NewErrBadQuery(fmt.Sprintf(\"query mising datasource info: %s\", pq.query.RefID))\n\t\t}\n\n\t\texprReq.Queries = append(exprReq.Queries, expr.Query{\n\t\t\tJSON:          pq.query.JSON,\n\t\t\tInterval:      pq.query.Interval,\n\t\t\tRefID:         pq.query.RefID,\n\t\t\tMaxDataPoints: pq.query.MaxDataPoints,\n\t\t\tQueryType:     pq.query.QueryType,\n\t\t\tDataSource:    pq.datasource,\n\t\t\tTimeRange: expr.TimeRange{\n\t\t\t\tFrom: pq.query.TimeRange.From,\n\t\t\t\tTo:   pq.query.TimeRange.To,\n\t\t\t},\n\t\t})\n\t}\n\n\tqdr, err := s.expressionService.TransformData(ctx, &exprReq)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"expression request error: %w\", err)\n\t}\n\treturn qdr, nil\n}\n\nfunc (s *Service) handleQueryData(ctx context.Context, user *models.SignedInUser, parsedReq *parsedRequest) (*backend.QueryDataResponse, error) {\n\tds := parsedReq.parsedQueries[0].datasource\n\tif err := s.pluginRequestValidator.Validate(ds.Url, nil); err != nil {\n\t\treturn nil, datasources.ErrDataSourceAccessDenied\n\t}\n\n\tinstanceSettings, err := adapters.ModelToInstanceSettings(ds, s.decryptSecureJsonDataFn(ctx))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq := &backend.QueryDataRequest{\n\t\tPluginContext: backend.PluginContext{\n\t\t\tOrgID:                      ds.OrgId,\n\t\t\tPluginID:                   ds.Type,\n\t\t\tUser:                       adapters.BackendUserFromSignedInUser(user),\n\t\t\tDataSourceInstanceSettings: instanceSettings,\n\t\t},\n\t\tHeaders: map[string]string{},\n\t\tQueries: []backend.DataQuery{},\n\t}\n\n\tmiddlewares := []httpclient.Middleware{}\n\tif parsedReq.httpRequest != nil {\n\t\tmiddlewares = append(middlewares,\n\t\t\thttpclientprovider.ForwardedCookiesMiddleware(parsedReq.httpRequest.Cookies(), ds.AllowedCookies()),\n\t\t)\n\t}\n\n\tif s.oAuthTokenService.IsOAuthPassThruEnabled(ds) {\n\t\tif token := s.oAuthTokenService.GetCurrentOAuthToken(ctx, user); token != nil {\n\t\t\treq.Headers[\"Authorization\"] = fmt.Sprintf(\"%s %s\", token.Type(), token.AccessToken)\n\n\t\t\tidToken, ok := token.Extra(\"id_token\").(string)\n\t\t\tif ok && idToken != \"\" {\n\t\t\t\treq.Headers[\"X-ID-Token\"] = idToken\n\t\t\t}\n\t\t\tmiddlewares = append(middlewares, httpclientprovider.ForwardedOAuthIdentityMiddleware(token))\n\t\t}\n\t}\n\n\tif parsedReq.httpRequest != nil {\n\t\tproxyutil.ClearCookieHeader(parsedReq.httpRequest, ds.AllowedCookies())\n\t\tif cookieStr := parsedReq.httpRequest.Header.Get(\"Cookie\"); cookieStr != \"\" {\n\t\t\treq.Headers[\"Cookie\"] = cookieStr\n\t\t}\n\t}\n\n\tfor _, q := range parsedReq.parsedQueries {\n\t\treq.Queries = append(req.Queries, q.query)\n\t}\n\n\tctx = httpclient.WithContextualMiddleware(ctx, middlewares...)\n\n\treturn s.pluginClient.QueryData(ctx, req)\n}\n\ntype parsedQuery struct {\n\tdatasource *datasources.DataSource\n\tquery      backend.DataQuery\n}\n\ntype parsedRequest struct {\n\thasExpression bool\n\tparsedQueries []parsedQuery\n\thttpRequest   *http.Request\n}\n\nfunc (s *Service) parseMetricRequest(ctx context.Context, user *models.SignedInUser, skipCache bool, reqDTO dtos.MetricRequest) (*parsedRequest, error) {\n\tif len(reqDTO.Queries) == 0 {\n\t\treturn nil, NewErrBadQuery(\"no queries found\")\n\t}\n\n\ttimeRange := legacydata.NewDataTimeRange(reqDTO.From, reqDTO.To)\n\treq := &parsedRequest{\n\t\thasExpression: false,\n\t\tparsedQueries: []parsedQuery{},\n\t}\n\n\t// Parse the queries\n\tdatasourcesByUid := map[string]*datasources.DataSource{}\n\tfor _, query := range reqDTO.Queries {\n\t\tds, err := s.getDataSourceFromQuery(ctx, user, skipCache, query, datasourcesByUid)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif ds == nil {\n\t\t\treturn nil, NewErrBadQuery(\"invalid data source ID\")\n\t\t}\n\n\t\tdatasourcesByUid[ds.Uid] = ds\n\t\tif expr.IsDataSource(ds.Uid) {\n\t\t\treq.hasExpression = true\n\t\t}\n\n\t\ts.log.Debug(\"Processing metrics query\", \"query\", query)\n\n\t\tmodelJSON, err := query.MarshalJSON()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treq.parsedQueries = append(req.parsedQueries, parsedQuery{\n\t\t\tdatasource: ds,\n\t\t\tquery: backend.DataQuery{\n\t\t\t\tTimeRange: backend.TimeRange{\n\t\t\t\t\tFrom: timeRange.GetFromAsTimeUTC(),\n\t\t\t\t\tTo:   timeRange.GetToAsTimeUTC(),\n\t\t\t\t},\n\t\t\t\tRefID:         query.Get(\"refId\").MustString(\"A\"),\n\t\t\t\tMaxDataPoints: query.Get(\"maxDataPoints\").MustInt64(100),\n\t\t\t\tInterval:      time.Duration(query.Get(\"intervalMs\").MustInt64(1000)) * time.Millisecond,\n\t\t\t\tQueryType:     query.Get(\"queryType\").MustString(\"\"),\n\t\t\t\tJSON:          modelJSON,\n\t\t\t},\n\t\t})\n\t}\n\n\tif !req.hasExpression {\n\t\tif len(datasourcesByUid) > 1 {\n\t\t\t// We do not (yet) support mixed query type\n\t\t\treturn nil, NewErrBadQuery(\"all queries must use the same datasource\")\n\t\t}\n\t}\n\n\tif reqDTO.HTTPRequest != nil {\n\t\treq.httpRequest = reqDTO.HTTPRequest\n\t}\n\n\treturn req, nil\n}\n\nfunc (s *Service) getDataSourceFromQuery(ctx context.Context, user *models.SignedInUser, skipCache bool, query *simplejson.Json, history map[string]*datasources.DataSource) (*datasources.DataSource, error) {\n\tvar err error\n\tuid := query.Get(\"datasource\").Get(\"uid\").MustString()\n\n\t// before 8.3 special types could be sent as datasource (expr)\n\tif uid == \"\" {\n\t\tuid = query.Get(\"datasource\").MustString()\n\t}\n\n\t// check cache value\n\tds, ok := history[uid]\n\tif ok {\n\t\treturn ds, nil\n\t}\n\n\tif expr.IsDataSource(uid) {\n\t\treturn expr.DataSourceModel(), nil\n\t}\n\n\tif uid == grafanads.DatasourceUID {\n\t\treturn grafanads.DataSourceModel(user.OrgId), nil\n\t}\n\n\t// use datasourceId if it exists\n\tid := query.Get(\"datasourceId\").MustInt64(0)\n\tif id > 0 {\n\t\tds, err = s.dataSourceCache.GetDatasource(ctx, id, user, skipCache)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn ds, nil\n\t}\n\n\tif uid != \"\" {\n\t\tds, err = s.dataSourceCache.GetDatasourceByUID(ctx, uid, user, skipCache)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn ds, nil\n\t}\n\n\treturn nil, NewErrBadQuery(\"missing data source ID/UID\")\n}\n\nfunc (s *Service) decryptSecureJsonDataFn(ctx context.Context) func(ds *datasources.DataSource) (map[string]string, error) {\n\treturn func(ds *datasources.DataSource) (map[string]string, error) {\n\t\treturn s.dataSourceService.DecryptedValues(ctx, ds)\n\t}\n}\n", "package query_test\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\t\"github.com/stretchr/testify/require\"\n\t\"golang.org/x/oauth2\"\n\n\t\"github.com/grafana/grafana/pkg/api/dtos\"\n\t\"github.com/grafana/grafana/pkg/components/simplejson\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\tacmock \"github.com/grafana/grafana/pkg/services/accesscontrol/mock\"\n\t\"github.com/grafana/grafana/pkg/services/datasources\"\n\tdsSvc \"github.com/grafana/grafana/pkg/services/datasources/service\"\n\t\"github.com/grafana/grafana/pkg/services/featuremgmt\"\n\t\"github.com/grafana/grafana/pkg/services/query\"\n\t\"github.com/grafana/grafana/pkg/services/secrets/fakes\"\n\t\"github.com/grafana/grafana/pkg/services/secrets/kvstore\"\n\tsecretsManager \"github.com/grafana/grafana/pkg/services/secrets/manager\"\n)\n\nfunc TestQueryData(t *testing.T) {\n\tt.Run(\"it auth custom headers to the request\", func(t *testing.T) {\n\t\ttoken := &oauth2.Token{\n\t\t\tTokenType:   \"bearer\",\n\t\t\tAccessToken: \"access-token\",\n\t\t}\n\t\ttoken = token.WithExtra(map[string]interface{}{\"id_token\": \"id-token\"})\n\n\t\ttc := setup(t)\n\t\ttc.oauthTokenService.passThruEnabled = true\n\t\ttc.oauthTokenService.token = token\n\n\t\t_, err := tc.queryService.QueryData(context.Background(), nil, true, metricRequest(), false)\n\t\trequire.Nil(t, err)\n\n\t\texpected := map[string]string{\n\t\t\t\"Authorization\": \"Bearer access-token\",\n\t\t\t\"X-ID-Token\":    \"id-token\",\n\t\t}\n\t\trequire.Equal(t, expected, tc.pluginContext.req.Headers)\n\t})\n\n\tt.Run(\"it doesn't add cookie header to the request when keepCookies configured and no cookies provided\", func(t *testing.T) {\n\t\ttc := setup(t)\n\t\tjson, err := simplejson.NewJson([]byte(`{\"keepCookies\": [ \"foo\", \"bar\" ]}`))\n\t\trequire.NoError(t, err)\n\t\ttc.dataSourceCache.ds.JsonData = json\n\n\t\tmetricReq := metricRequest()\n\t\thttpReq, err := http.NewRequest(http.MethodGet, \"/\", nil)\n\t\trequire.NoError(t, err)\n\t\tmetricReq.HTTPRequest = httpReq\n\t\t_, err = tc.queryService.QueryData(context.Background(), nil, true, metricReq, false)\n\t\trequire.NoError(t, err)\n\n\t\trequire.Empty(t, tc.pluginContext.req.Headers)\n\t})\n\n\tt.Run(\"it adds cookie header to the request when keepCookies configured and cookie provided\", func(t *testing.T) {\n\t\ttc := setup(t)\n\t\tjson, err := simplejson.NewJson([]byte(`{\"keepCookies\": [ \"foo\", \"bar\" ]}`))\n\t\trequire.NoError(t, err)\n\t\ttc.dataSourceCache.ds.JsonData = json\n\n\t\tmetricReq := metricRequest()\n\t\thttpReq, err := http.NewRequest(http.MethodGet, \"/\", nil)\n\t\trequire.NoError(t, err)\n\t\thttpReq.AddCookie(&http.Cookie{Name: \"a\"})\n\t\thttpReq.AddCookie(&http.Cookie{Name: \"bar\", Value: \"rab\"})\n\t\thttpReq.AddCookie(&http.Cookie{Name: \"b\"})\n\t\thttpReq.AddCookie(&http.Cookie{Name: \"foo\", Value: \"oof\"})\n\t\thttpReq.AddCookie(&http.Cookie{Name: \"c\"})\n\t\tmetricReq.HTTPRequest = httpReq\n\t\t_, err = tc.queryService.QueryData(context.Background(), nil, true, metricReq, false)\n\t\trequire.NoError(t, err)\n\n\t\trequire.Equal(t, map[string]string{\"Cookie\": \"bar=rab; foo=oof\"}, tc.pluginContext.req.Headers)\n\t})\n}\n\nfunc setup(t *testing.T) *testContext {\n\tpc := &fakePluginClient{}\n\tdc := &fakeDataSourceCache{ds: &datasources.DataSource{}}\n\ttc := &fakeOAuthTokenService{}\n\trv := &fakePluginRequestValidator{}\n\n\tss := kvstore.SetupTestService(t)\n\tssvc := secretsManager.SetupTestService(t, fakes.NewFakeSecretsStore())\n\tds := dsSvc.ProvideService(nil, ssvc, ss, nil, featuremgmt.WithFeatures(), acmock.New(), acmock.NewMockedPermissionsService())\n\n\treturn &testContext{\n\t\tpluginContext:          pc,\n\t\tsecretStore:            ss,\n\t\tdataSourceCache:        dc,\n\t\toauthTokenService:      tc,\n\t\tpluginRequestValidator: rv,\n\t\tqueryService:           query.ProvideService(nil, dc, nil, rv, ds, pc, tc),\n\t}\n}\n\ntype testContext struct {\n\tpluginContext          *fakePluginClient\n\tsecretStore            kvstore.SecretsKVStore\n\tdataSourceCache        *fakeDataSourceCache\n\toauthTokenService      *fakeOAuthTokenService\n\tpluginRequestValidator *fakePluginRequestValidator\n\tqueryService           *query.Service\n}\n\nfunc metricRequest() dtos.MetricRequest {\n\tq, _ := simplejson.NewJson([]byte(`{\"datasourceId\":1}`))\n\treturn dtos.MetricRequest{\n\t\tFrom:    \"\",\n\t\tTo:      \"\",\n\t\tQueries: []*simplejson.Json{q},\n\t\tDebug:   false,\n\t}\n}\n\ntype fakePluginRequestValidator struct {\n\terr error\n}\n\nfunc (rv *fakePluginRequestValidator) Validate(dsURL string, req *http.Request) error {\n\treturn rv.err\n}\n\ntype fakeOAuthTokenService struct {\n\tpassThruEnabled bool\n\ttoken           *oauth2.Token\n}\n\nfunc (ts *fakeOAuthTokenService) GetCurrentOAuthToken(context.Context, *models.SignedInUser) *oauth2.Token {\n\treturn ts.token\n}\n\nfunc (ts *fakeOAuthTokenService) IsOAuthPassThruEnabled(*datasources.DataSource) bool {\n\treturn ts.passThruEnabled\n}\n\ntype fakeDataSourceCache struct {\n\tds *datasources.DataSource\n}\n\nfunc (c *fakeDataSourceCache) GetDatasource(ctx context.Context, datasourceID int64, user *models.SignedInUser, skipCache bool) (*datasources.DataSource, error) {\n\treturn c.ds, nil\n}\n\nfunc (c *fakeDataSourceCache) GetDatasourceByUID(ctx context.Context, datasourceUID string, user *models.SignedInUser, skipCache bool) (*datasources.DataSource, error) {\n\treturn c.ds, nil\n}\n\ntype fakePluginClient struct {\n\tplugins.Client\n\n\treq *backend.QueryDataRequest\n}\n\nfunc (c *fakePluginClient) QueryData(ctx context.Context, req *backend.QueryDataRequest) (*backend.QueryDataResponse, error) {\n\tc.req = req\n\treturn nil, nil\n}\n", "package proxyutil\n\nimport (\n\t\"net\"\n\t\"net/http\"\n)\n\n// PrepareProxyRequest prepares a request for being proxied.\n// Removes X-Forwarded-Host, X-Forwarded-Port, X-Forwarded-Proto headers.\n// Set X-Forwarded-For headers.\nfunc PrepareProxyRequest(req *http.Request) {\n\treq.Header.Del(\"X-Forwarded-Host\")\n\treq.Header.Del(\"X-Forwarded-Port\")\n\treq.Header.Del(\"X-Forwarded-Proto\")\n\n\tif req.RemoteAddr != \"\" {\n\t\tremoteAddr, _, err := net.SplitHostPort(req.RemoteAddr)\n\t\tif err != nil {\n\t\t\tremoteAddr = req.RemoteAddr\n\t\t}\n\t\tif req.Header.Get(\"X-Forwarded-For\") != \"\" {\n\t\t\treq.Header.Set(\"X-Forwarded-For\", req.Header.Get(\"X-Forwarded-For\")+\", \"+remoteAddr)\n\t\t} else {\n\t\t\treq.Header.Set(\"X-Forwarded-For\", remoteAddr)\n\t\t}\n\t}\n}\n\n// ClearCookieHeader clear cookie header, except for cookies specified to be kept.\nfunc ClearCookieHeader(req *http.Request, keepCookiesNames []string) {\n\tvar keepCookies []*http.Cookie\n\tfor _, c := range req.Cookies() {\n\t\tfor _, v := range keepCookiesNames {\n\t\t\tif c.Name == v {\n\t\t\t\tkeepCookies = append(keepCookies, c)\n\t\t\t}\n\t\t}\n\t}\n\n\treq.Header.Del(\"Cookie\")\n\tfor _, c := range keepCookies {\n\t\treq.AddCookie(c)\n\t}\n}\n\n// SetProxyResponseHeaders sets proxy response headers.\n// Sets Content-Security-Policy: sandbox\nfunc SetProxyResponseHeaders(header http.Header) {\n\theader.Set(\"Content-Security-Policy\", \"sandbox\")\n}\n", "package proxyutil\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestPrepareProxyRequest(t *testing.T) {\n\tt.Run(\"Prepare proxy request should clear X-Forwarded headers\", func(t *testing.T) {\n\t\treq, err := http.NewRequest(http.MethodGet, \"/\", nil)\n\t\trequire.NoError(t, err)\n\t\treq.Header.Set(\"X-Forwarded-Host\", \"host\")\n\t\treq.Header.Set(\"X-Forwarded-Port\", \"123\")\n\t\treq.Header.Set(\"X-Forwarded-Proto\", \"http1\")\n\n\t\tPrepareProxyRequest(req)\n\t\trequire.NotContains(t, req.Header, \"X-Forwarded-Host\")\n\t\trequire.NotContains(t, req.Header, \"X-Forwarded-Port\")\n\t\trequire.NotContains(t, req.Header, \"X-Forwarded-Proto\")\n\t})\n\n\tt.Run(\"Prepare proxy request should set X-Forwarded-For\", func(t *testing.T) {\n\t\treq, err := http.NewRequest(http.MethodGet, \"/\", nil)\n\t\treq.RemoteAddr = \"127.0.0.1:1234\"\n\t\trequire.NoError(t, err)\n\n\t\tPrepareProxyRequest(req)\n\t\trequire.Contains(t, req.Header, \"X-Forwarded-For\")\n\t\trequire.Equal(t, \"127.0.0.1\", req.Header.Get(\"X-Forwarded-For\"))\n\t})\n\n\tt.Run(\"Prepare proxy request should append client ip at the end of X-Forwarded-For\", func(t *testing.T) {\n\t\treq, err := http.NewRequest(http.MethodGet, \"/\", nil)\n\t\treq.RemoteAddr = \"127.0.0.1:1234\"\n\t\treq.Header.Set(\"X-Forwarded-For\", \"192.168.0.1\")\n\t\trequire.NoError(t, err)\n\n\t\tPrepareProxyRequest(req)\n\t\trequire.Contains(t, req.Header, \"X-Forwarded-For\")\n\t\trequire.Equal(t, \"192.168.0.1, 127.0.0.1\", req.Header.Get(\"X-Forwarded-For\"))\n\t})\n}\n\nfunc TestClearCookieHeader(t *testing.T) {\n\tt.Run(\"Clear cookie header should clear Cookie header\", func(t *testing.T) {\n\t\treq, err := http.NewRequest(http.MethodGet, \"/\", nil)\n\t\trequire.NoError(t, err)\n\t\treq.AddCookie(&http.Cookie{Name: \"cookie\"})\n\n\t\tClearCookieHeader(req, nil)\n\t\trequire.NotContains(t, req.Header, \"Cookie\")\n\t})\n\n\tt.Run(\"Clear cookie header with cookies to keep should clear Cookie header and keep cookies\", func(t *testing.T) {\n\t\treq, err := http.NewRequest(http.MethodGet, \"/\", nil)\n\t\trequire.NoError(t, err)\n\t\treq.AddCookie(&http.Cookie{Name: \"cookie1\"})\n\t\treq.AddCookie(&http.Cookie{Name: \"cookie2\"})\n\t\treq.AddCookie(&http.Cookie{Name: \"cookie3\"})\n\n\t\tClearCookieHeader(req, []string{\"cookie1\", \"cookie3\"})\n\t\trequire.Contains(t, req.Header, \"Cookie\")\n\t\trequire.Equal(t, \"cookie1=; cookie3=\", req.Header.Get(\"Cookie\"))\n\t})\n}\n"], "fixing_code": ["package api\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\n\t\"github.com/grafana/grafana/pkg/api/datasource\"\n\t\"github.com/grafana/grafana/pkg/api/dtos\"\n\t\"github.com/grafana/grafana/pkg/api/response\"\n\t\"github.com/grafana/grafana/pkg/components/simplejson\"\n\t\"github.com/grafana/grafana/pkg/infra/log\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins/adapters\"\n\t\"github.com/grafana/grafana/pkg/services/datasources\"\n\t\"github.com/grafana/grafana/pkg/services/datasources/permissions\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util\"\n\t\"github.com/grafana/grafana/pkg/util/proxyutil\"\n\t\"github.com/grafana/grafana/pkg/web\"\n)\n\nvar datasourcesLogger = log.New(\"datasources\")\nvar secretsPluginError datasources.ErrDatasourceSecretsPluginUserFriendly\n\n// swagger:route GET /datasources datasources getDataSources\n//\n// Get all data sources.\n//\n// If you are running Grafana Enterprise and have Fine-grained access control enabled\n// you need to have a permission with action: `datasources:read` and scope: `datasources:*`.\n//\n// Responses:\n// 200: getDataSourcesResponse\n// 401: unauthorisedError\n// 403: forbiddenError\n// 500: internalServerError\nfunc (hs *HTTPServer) GetDataSources(c *models.ReqContext) response.Response {\n\tquery := datasources.GetDataSourcesQuery{OrgId: c.OrgId, DataSourceLimit: hs.Cfg.DataSourceLimit}\n\n\tif err := hs.DataSourcesService.GetDataSources(c.Req.Context(), &query); err != nil {\n\t\treturn response.Error(500, \"Failed to query datasources\", err)\n\t}\n\n\tfiltered, err := hs.filterDatasourcesByQueryPermission(c.Req.Context(), c.SignedInUser, query.Result)\n\tif err != nil {\n\t\treturn response.Error(500, \"Failed to query datasources\", err)\n\t}\n\n\tresult := make(dtos.DataSourceList, 0)\n\tfor _, ds := range filtered {\n\t\tdsItem := dtos.DataSourceListItemDTO{\n\t\t\tOrgId:     ds.OrgId,\n\t\t\tId:        ds.Id,\n\t\t\tUID:       ds.Uid,\n\t\t\tName:      ds.Name,\n\t\t\tUrl:       ds.Url,\n\t\t\tType:      ds.Type,\n\t\t\tTypeName:  ds.Type,\n\t\t\tAccess:    ds.Access,\n\t\t\tDatabase:  ds.Database,\n\t\t\tUser:      ds.User,\n\t\t\tBasicAuth: ds.BasicAuth,\n\t\t\tIsDefault: ds.IsDefault,\n\t\t\tJsonData:  ds.JsonData,\n\t\t\tReadOnly:  ds.ReadOnly,\n\t\t}\n\n\t\tif plugin, exists := hs.pluginStore.Plugin(c.Req.Context(), ds.Type); exists {\n\t\t\tdsItem.TypeLogoUrl = plugin.Info.Logos.Small\n\t\t\tdsItem.TypeName = plugin.Name\n\t\t} else {\n\t\t\tdsItem.TypeLogoUrl = \"public/img/icn-datasource.svg\"\n\t\t}\n\n\t\tresult = append(result, dsItem)\n\t}\n\n\tsort.Sort(result)\n\n\treturn response.JSON(http.StatusOK, &result)\n}\n\n// swagger:route GET /datasources/{id} datasources getDataSourceByID\n//\n// Get a single data source by Id.\n//\n// If you are running Grafana Enterprise and have Fine-grained access control enabled\n// you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).\n//\n// Please refer to [updated API](#/datasources/getDataSourceByUID) instead\n//\n// Deprecated: true\n//\n// Responses:\n// 200: getDataSourceResponse\n// 400: badRequestError\n// 401: unauthorisedError\n// 403: forbiddenError\n// 404: notFoundError\n// 500: internalServerError\nfunc (hs *HTTPServer) GetDataSourceById(c *models.ReqContext) response.Response {\n\tid, err := strconv.ParseInt(web.Params(c.Req)[\":id\"], 10, 64)\n\tif err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"id is invalid\", nil)\n\t}\n\tquery := datasources.GetDataSourceQuery{\n\t\tId:    id,\n\t\tOrgId: c.OrgId,\n\t}\n\n\tif err := hs.DataSourcesService.GetDataSource(c.Req.Context(), &query); err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceNotFound) {\n\t\t\treturn response.Error(404, \"Data source not found\", nil)\n\t\t}\n\t\tif errors.Is(err, datasources.ErrDataSourceIdentifierNotSet) {\n\t\t\treturn response.Error(400, \"Datasource id is missing\", nil)\n\t\t}\n\t\treturn response.Error(500, \"Failed to query datasources\", err)\n\t}\n\n\tdto := hs.convertModelToDtos(c.Req.Context(), query.Result)\n\n\t// Add accesscontrol metadata\n\tdto.AccessControl = hs.getAccessControlMetadata(c, c.OrgId, datasources.ScopePrefix, dto.UID)\n\n\treturn response.JSON(http.StatusOK, &dto)\n}\n\n// swagger:route DELETE /datasources/{id} datasources deleteDataSourceByID\n//\n// Delete an existing data source by id.\n//\n// If you are running Grafana Enterprise and have Fine-grained access control enabled\n// you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).\n//\n// Please refer to [updated API](#/datasources/deleteDataSourceByUID) instead\n//\n// Deprecated: true\n//\n// Responses:\n// 200: okResponse\n// 401: unauthorisedError\n// 404: notFoundError\n// 403: forbiddenError\n// 500: internalServerError\nfunc (hs *HTTPServer) DeleteDataSourceById(c *models.ReqContext) response.Response {\n\tid, err := strconv.ParseInt(web.Params(c.Req)[\":id\"], 10, 64)\n\tif err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"id is invalid\", err)\n\t}\n\n\tif id <= 0 {\n\t\treturn response.Error(400, \"Missing valid datasource id\", nil)\n\t}\n\n\tds, err := hs.getRawDataSourceById(c.Req.Context(), id, c.OrgId)\n\tif err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceNotFound) {\n\t\t\treturn response.Error(404, \"Data source not found\", nil)\n\t\t}\n\t\treturn response.Error(400, \"Failed to delete datasource\", nil)\n\t}\n\n\tif ds.ReadOnly {\n\t\treturn response.Error(403, \"Cannot delete read-only data source\", nil)\n\t}\n\n\tcmd := &datasources.DeleteDataSourceCommand{ID: id, OrgID: c.OrgId, Name: ds.Name}\n\n\terr = hs.DataSourcesService.DeleteDataSource(c.Req.Context(), cmd)\n\tif err != nil {\n\t\tif errors.As(err, &secretsPluginError) {\n\t\t\treturn response.Error(500, \"Failed to delete datasource: \"+err.Error(), err)\n\t\t}\n\t\treturn response.Error(500, \"Failed to delete datasource\", err)\n\t}\n\n\ths.Live.HandleDatasourceDelete(c.OrgId, ds.Uid)\n\n\treturn response.Success(\"Data source deleted\")\n}\n\n// swagger:route GET /datasources/uid/{uid} datasources getDataSourceByUID\n//\n// Get a single data source by UID.\n//\n// If you are running Grafana Enterprise and have Fine-grained access control enabled\n// you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).\n//\n// Responses:\n// 200: getDataSourceResponse\n// 400: badRequestError\n// 401: unauthorisedError\n// 403: forbiddenError\n// 404: notFoundError\n// 500: internalServerError\nfunc (hs *HTTPServer) GetDataSourceByUID(c *models.ReqContext) response.Response {\n\tds, err := hs.getRawDataSourceByUID(c.Req.Context(), web.Params(c.Req)[\":uid\"], c.OrgId)\n\n\tif err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceNotFound) {\n\t\t\treturn response.Error(http.StatusNotFound, \"Data source not found\", nil)\n\t\t}\n\t\treturn response.Error(http.StatusInternalServerError, \"Failed to query datasource\", err)\n\t}\n\n\tdto := hs.convertModelToDtos(c.Req.Context(), ds)\n\n\t// Add accesscontrol metadata\n\tdto.AccessControl = hs.getAccessControlMetadata(c, c.OrgId, datasources.ScopePrefix, dto.UID)\n\n\treturn response.JSON(http.StatusOK, &dto)\n}\n\n// swagger:route DELETE /datasources/uid/{uid} datasources deleteDataSourceByUID\n//\n// Delete an existing data source by UID.\n//\n// If you are running Grafana Enterprise and have Fine-grained access control enabled\n// you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).\n//\n// Responses:\n// 200: okResponse\n// 401: unauthorisedError\n// 403: forbiddenError\n// 404: notFoundError\n// 500: internalServerError\nfunc (hs *HTTPServer) DeleteDataSourceByUID(c *models.ReqContext) response.Response {\n\tuid := web.Params(c.Req)[\":uid\"]\n\n\tif uid == \"\" {\n\t\treturn response.Error(400, \"Missing datasource uid\", nil)\n\t}\n\n\tds, err := hs.getRawDataSourceByUID(c.Req.Context(), uid, c.OrgId)\n\tif err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceNotFound) {\n\t\t\treturn response.Error(404, \"Data source not found\", nil)\n\t\t}\n\t\treturn response.Error(400, \"Failed to delete datasource\", nil)\n\t}\n\n\tif ds.ReadOnly {\n\t\treturn response.Error(403, \"Cannot delete read-only data source\", nil)\n\t}\n\n\tcmd := &datasources.DeleteDataSourceCommand{UID: uid, OrgID: c.OrgId, Name: ds.Name}\n\n\terr = hs.DataSourcesService.DeleteDataSource(c.Req.Context(), cmd)\n\tif err != nil {\n\t\tif errors.As(err, &secretsPluginError) {\n\t\t\treturn response.Error(500, \"Failed to delete datasource: \"+err.Error(), err)\n\t\t}\n\t\treturn response.Error(500, \"Failed to delete datasource\", err)\n\t}\n\n\ths.Live.HandleDatasourceDelete(c.OrgId, ds.Uid)\n\n\treturn response.JSON(http.StatusOK, util.DynMap{\n\t\t\"message\": \"Data source deleted\",\n\t\t\"id\":      ds.Id,\n\t})\n}\n\n// swagger:route DELETE /datasources/name/{name} datasources deleteDataSourceByName\n//\n// Delete an existing data source by name.\n//\n// If you are running Grafana Enterprise and have Fine-grained access control enabled\n// you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).\n//\n// Responses:\n// 200: deleteDataSourceByNameResponse\n// 401: unauthorisedError\n// 403: forbiddenError\n// 404: notFoundError\n// 500: internalServerError\nfunc (hs *HTTPServer) DeleteDataSourceByName(c *models.ReqContext) response.Response {\n\tname := web.Params(c.Req)[\":name\"]\n\n\tif name == \"\" {\n\t\treturn response.Error(400, \"Missing valid datasource name\", nil)\n\t}\n\n\tgetCmd := &datasources.GetDataSourceQuery{Name: name, OrgId: c.OrgId}\n\tif err := hs.DataSourcesService.GetDataSource(c.Req.Context(), getCmd); err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceNotFound) {\n\t\t\treturn response.Error(404, \"Data source not found\", nil)\n\t\t}\n\t\treturn response.Error(500, \"Failed to delete datasource\", err)\n\t}\n\n\tif getCmd.Result.ReadOnly {\n\t\treturn response.Error(403, \"Cannot delete read-only data source\", nil)\n\t}\n\n\tcmd := &datasources.DeleteDataSourceCommand{Name: name, OrgID: c.OrgId}\n\terr := hs.DataSourcesService.DeleteDataSource(c.Req.Context(), cmd)\n\tif err != nil {\n\t\tif errors.As(err, &secretsPluginError) {\n\t\t\treturn response.Error(500, \"Failed to delete datasource: \"+err.Error(), err)\n\t\t}\n\t\treturn response.Error(500, \"Failed to delete datasource\", err)\n\t}\n\n\ths.Live.HandleDatasourceDelete(c.OrgId, getCmd.Result.Uid)\n\n\treturn response.JSON(http.StatusOK, util.DynMap{\n\t\t\"message\": \"Data source deleted\",\n\t\t\"id\":      getCmd.Result.Id,\n\t})\n}\n\nfunc validateURL(cmdType string, url string) response.Response {\n\tif _, err := datasource.ValidateURL(cmdType, url); err != nil {\n\t\tdatasourcesLogger.Error(\"Failed to validate URL\", \"url\", url)\n\t\treturn response.Error(http.StatusBadRequest, \"Validation error, invalid URL\", err)\n\t}\n\n\treturn nil\n}\n\n// validateJSONData prevents the user from adding a custom header with name that matches the auth proxy header name.\n// This is done to prevent data source proxy from being used to circumvent auth proxy.\n// For more context take a look at CVE-2022-35957\nfunc validateJSONData(jsonData *simplejson.Json, cfg *setting.Cfg) error {\n\tif jsonData == nil || !cfg.AuthProxyEnabled {\n\t\treturn nil\n\t}\n\n\tfor key, value := range jsonData.MustMap() {\n\t\tif strings.HasPrefix(key, \"httpHeaderName\") {\n\t\t\theader := fmt.Sprint(value)\n\t\t\tif http.CanonicalHeaderKey(header) == http.CanonicalHeaderKey(cfg.AuthProxyHeaderName) {\n\t\t\t\tdatasourcesLogger.Error(\"Forbidden to add a data source header with a name equal to auth proxy header name\", \"headerName\", key)\n\t\t\t\treturn errors.New(\"validation error, invalid header name specified\")\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// swagger:route POST /datasources datasources addDataSource\n//\n// Create a data source.\n//\n// By defining `password` and `basicAuthPassword` under secureJsonData property\n// Grafana encrypts them securely as an encrypted blob in the database.\n// The response then lists the encrypted fields under secureJsonFields.\n//\n// If you are running Grafana Enterprise and have Fine-grained access control enabled\n// you need to have a permission with action: `datasources:create`\n//\n// Responses:\n// 200: createOrUpdateDatasourceResponse\n// 401: unauthorisedError\n// 403: forbiddenError\n// 409: conflictError\n// 500: internalServerError\nfunc (hs *HTTPServer) AddDataSource(c *models.ReqContext) response.Response {\n\tcmd := datasources.AddDataSourceCommand{}\n\tif err := web.Bind(c.Req, &cmd); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\n\tdatasourcesLogger.Debug(\"Received command to add data source\", \"url\", cmd.Url)\n\tcmd.OrgId = c.OrgId\n\tcmd.UserId = c.UserId\n\tif cmd.Url != \"\" {\n\t\tif resp := validateURL(cmd.Type, cmd.Url); resp != nil {\n\t\t\treturn resp\n\t\t}\n\t}\n\tif err := validateJSONData(cmd.JsonData, hs.Cfg); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"Failed to add datasource\", err)\n\t}\n\n\tif err := hs.DataSourcesService.AddDataSource(c.Req.Context(), &cmd); err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceNameExists) || errors.Is(err, datasources.ErrDataSourceUidExists) {\n\t\t\treturn response.Error(409, err.Error(), err)\n\t\t}\n\n\t\tif errors.As(err, &secretsPluginError) {\n\t\t\treturn response.Error(500, \"Failed to add datasource: \"+err.Error(), err)\n\t\t}\n\n\t\treturn response.Error(500, \"Failed to add datasource\", err)\n\t}\n\n\tds := hs.convertModelToDtos(c.Req.Context(), cmd.Result)\n\treturn response.JSON(http.StatusOK, util.DynMap{\n\t\t\"message\":    \"Datasource added\",\n\t\t\"id\":         cmd.Result.Id,\n\t\t\"name\":       cmd.Result.Name,\n\t\t\"datasource\": ds,\n\t})\n}\n\n// swagger:route PUT /datasources/{id} datasources updateDataSourceByID\n//\n// Update an existing data source by its sequential ID.\n//\n// Similar to creating a data source, `password` and `basicAuthPassword` should be defined under\n// secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the\n// encrypted fields are listed under secureJsonFields section in the response.\n//\n// If you are running Grafana Enterprise and have Fine-grained access control enabled\n// you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).\n//\n// Please refer to [updated API](#/datasources/updateDataSourceByUID) instead\n//\n// Deprecated: true\n//\n// Responses:\n// 200: createOrUpdateDatasourceResponse\n// 401: unauthorisedError\n// 403: forbiddenError\n// 500: internalServerError\n\nfunc (hs *HTTPServer) UpdateDataSourceByID(c *models.ReqContext) response.Response {\n\tcmd := datasources.UpdateDataSourceCommand{}\n\tif err := web.Bind(c.Req, &cmd); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tdatasourcesLogger.Debug(\"Received command to update data source\", \"url\", cmd.Url)\n\tcmd.OrgId = c.OrgId\n\tvar err error\n\tif cmd.Id, err = strconv.ParseInt(web.Params(c.Req)[\":id\"], 10, 64); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"id is invalid\", err)\n\t}\n\tif resp := validateURL(cmd.Type, cmd.Url); resp != nil {\n\t\treturn resp\n\t}\n\tif err := validateJSONData(cmd.JsonData, hs.Cfg); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"Failed to update datasource\", err)\n\t}\n\n\tds, err := hs.getRawDataSourceById(c.Req.Context(), cmd.Id, cmd.OrgId)\n\tif err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceNotFound) {\n\t\t\treturn response.Error(404, \"Data source not found\", nil)\n\t\t}\n\t\treturn response.Error(500, \"Failed to update datasource\", err)\n\t}\n\treturn hs.updateDataSourceByID(c, ds, cmd)\n}\n\n// swagger:route PUT /datasources/uid/{uid} datasources updateDataSourceByUID\n//\n// Update an existing data source.\n//\n// Similar to creating a data source, `password` and `basicAuthPassword` should be defined under\n// secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the\n// encrypted fields are listed under secureJsonFields section in the response.\n//\n// If you are running Grafana Enterprise and have Fine-grained access control enabled\n// you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:1` (single data source).\n//\n// Responses:\n// 200: createOrUpdateDatasourceResponse\n// 401: unauthorisedError\n// 403: forbiddenError\n// 500: internalServerError\nfunc (hs *HTTPServer) UpdateDataSourceByUID(c *models.ReqContext) response.Response {\n\tcmd := datasources.UpdateDataSourceCommand{}\n\tif err := web.Bind(c.Req, &cmd); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tdatasourcesLogger.Debug(\"Received command to update data source\", \"url\", cmd.Url)\n\tcmd.OrgId = c.OrgId\n\tif resp := validateURL(cmd.Type, cmd.Url); resp != nil {\n\t\treturn resp\n\t}\n\tif err := validateJSONData(cmd.JsonData, hs.Cfg); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"Failed to update datasource\", err)\n\t}\n\n\tds, err := hs.getRawDataSourceByUID(c.Req.Context(), web.Params(c.Req)[\":uid\"], c.OrgId)\n\tif err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceNotFound) {\n\t\t\treturn response.Error(http.StatusNotFound, \"Data source not found\", nil)\n\t\t}\n\t\treturn response.Error(http.StatusInternalServerError, \"Failed to update datasource\", err)\n\t}\n\tcmd.Id = ds.Id\n\treturn hs.updateDataSourceByID(c, ds, cmd)\n}\n\nfunc (hs *HTTPServer) updateDataSourceByID(c *models.ReqContext, ds *datasources.DataSource, cmd datasources.UpdateDataSourceCommand) response.Response {\n\tif ds.ReadOnly {\n\t\treturn response.Error(403, \"Cannot update read-only data source\", nil)\n\t}\n\n\terr := hs.DataSourcesService.UpdateDataSource(c.Req.Context(), &cmd)\n\tif err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceUpdatingOldVersion) {\n\t\t\treturn response.Error(409, \"Datasource has already been updated by someone else. Please reload and try again\", err)\n\t\t}\n\n\t\tif errors.As(err, &secretsPluginError) {\n\t\t\treturn response.Error(500, \"Failed to update datasource: \"+err.Error(), err)\n\t\t}\n\t\treturn response.Error(500, \"Failed to update datasource\", err)\n\t}\n\n\tquery := datasources.GetDataSourceQuery{\n\t\tId:    cmd.Id,\n\t\tOrgId: c.OrgId,\n\t}\n\n\tif err := hs.DataSourcesService.GetDataSource(c.Req.Context(), &query); err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceNotFound) {\n\t\t\treturn response.Error(404, \"Data source not found\", nil)\n\t\t}\n\t\treturn response.Error(500, \"Failed to query datasource\", err)\n\t}\n\n\tdatasourceDTO := hs.convertModelToDtos(c.Req.Context(), query.Result)\n\n\ths.Live.HandleDatasourceUpdate(c.OrgId, datasourceDTO.UID)\n\n\treturn response.JSON(http.StatusOK, util.DynMap{\n\t\t\"message\":    \"Datasource updated\",\n\t\t\"id\":         cmd.Id,\n\t\t\"name\":       cmd.Name,\n\t\t\"datasource\": datasourceDTO,\n\t})\n}\n\nfunc (hs *HTTPServer) getRawDataSourceById(ctx context.Context, id int64, orgID int64) (*datasources.DataSource, error) {\n\tquery := datasources.GetDataSourceQuery{\n\t\tId:    id,\n\t\tOrgId: orgID,\n\t}\n\n\tif err := hs.DataSourcesService.GetDataSource(ctx, &query); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn query.Result, nil\n}\n\nfunc (hs *HTTPServer) getRawDataSourceByUID(ctx context.Context, uid string, orgID int64) (*datasources.DataSource, error) {\n\tquery := datasources.GetDataSourceQuery{\n\t\tUid:   uid,\n\t\tOrgId: orgID,\n\t}\n\n\tif err := hs.DataSourcesService.GetDataSource(ctx, &query); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn query.Result, nil\n}\n\n// swagger:route GET /datasources/name/{name} datasources getDataSourceByName\n//\n// Get a single data source by Name.\n//\n// If you are running Grafana Enterprise and have Fine-grained access control enabled\n// you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).\n//\n// Responses:\n// 200: getDataSourceResponse\n// 401: unauthorisedError\n// 403: forbiddenError\n// 500: internalServerError\nfunc (hs *HTTPServer) GetDataSourceByName(c *models.ReqContext) response.Response {\n\tquery := datasources.GetDataSourceQuery{Name: web.Params(c.Req)[\":name\"], OrgId: c.OrgId}\n\n\tif err := hs.DataSourcesService.GetDataSource(c.Req.Context(), &query); err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceNotFound) {\n\t\t\treturn response.Error(404, \"Data source not found\", nil)\n\t\t}\n\t\treturn response.Error(500, \"Failed to query datasources\", err)\n\t}\n\n\tdto := hs.convertModelToDtos(c.Req.Context(), query.Result)\n\treturn response.JSON(http.StatusOK, &dto)\n}\n\n// swagger:route GET /datasources/id/{name} datasources getDataSourceIdByName\n//\n// Get data source Id by Name.\n//\n// If you are running Grafana Enterprise and have Fine-grained access control enabled\n// you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).\n//\n// Responses:\n// 200: getDataSourceIDResponse\n// 401: unauthorisedError\n// 403: forbiddenError\n// 404: notFoundError\n// 500: internalServerError\nfunc (hs *HTTPServer) GetDataSourceIdByName(c *models.ReqContext) response.Response {\n\tquery := datasources.GetDataSourceQuery{Name: web.Params(c.Req)[\":name\"], OrgId: c.OrgId}\n\n\tif err := hs.DataSourcesService.GetDataSource(c.Req.Context(), &query); err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceNotFound) {\n\t\t\treturn response.Error(404, \"Data source not found\", nil)\n\t\t}\n\t\treturn response.Error(500, \"Failed to query datasources\", err)\n\t}\n\n\tds := query.Result\n\tdtos := dtos.AnyId{\n\t\tId: ds.Id,\n\t}\n\n\treturn response.JSON(http.StatusOK, &dtos)\n}\n\n// swagger:route GET /datasources/{id}/resources/{datasource_proxy_route} datasources callDatasourceResourceByID\n//\n// Fetch data source resources by Id.\n//\n// Please refer to [updated API](#/datasources/callDatasourceResourceWithUID) instead\n//\n// Deprecated: true\n//\n// Responses:\n// 200: okResponse\n// 400: badRequestError\n// 401: unauthorisedError\n// 403: forbiddenError\n// 404: notFoundError\n// 500: internalServerError\nfunc (hs *HTTPServer) CallDatasourceResource(c *models.ReqContext) {\n\tdatasourceID, err := strconv.ParseInt(web.Params(c.Req)[\":id\"], 10, 64)\n\tif err != nil {\n\t\tc.JsonApiErr(http.StatusBadRequest, \"id is invalid\", nil)\n\t\treturn\n\t}\n\tds, err := hs.DataSourceCache.GetDatasource(c.Req.Context(), datasourceID, c.SignedInUser, c.SkipCache)\n\tif err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceAccessDenied) {\n\t\t\tc.JsonApiErr(403, \"Access denied to datasource\", err)\n\t\t\treturn\n\t\t}\n\t\tc.JsonApiErr(500, \"Unable to load datasource meta data\", err)\n\t\treturn\n\t}\n\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), ds.Type)\n\tif !exists {\n\t\tc.JsonApiErr(500, \"Unable to find datasource plugin\", err)\n\t\treturn\n\t}\n\n\ths.callPluginResourceWithDataSource(c, plugin.ID, ds)\n}\n\n// swagger:route GET /datasources/uid/{uid}/resources/{datasource_proxy_route} datasources callDatasourceResourceWithUID\n//\n// Fetch data source resources.\n//\n// Responses:\n// 200: okResponse\n// 400: badRequestError\n// 401: unauthorisedError\n// 403: forbiddenError\n// 404: notFoundError\n// 500: internalServerError\nfunc (hs *HTTPServer) CallDatasourceResourceWithUID(c *models.ReqContext) {\n\tdsUID := web.Params(c.Req)[\":uid\"]\n\tif !util.IsValidShortUID(dsUID) {\n\t\tc.JsonApiErr(http.StatusBadRequest, \"UID is invalid\", nil)\n\t\treturn\n\t}\n\n\tds, err := hs.DataSourceCache.GetDatasourceByUID(c.Req.Context(), dsUID, c.SignedInUser, c.SkipCache)\n\tif err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceAccessDenied) {\n\t\t\tc.JsonApiErr(http.StatusForbidden, \"Access denied to datasource\", err)\n\t\t\treturn\n\t\t}\n\t\tc.JsonApiErr(http.StatusInternalServerError, \"Unable to load datasource meta data\", err)\n\t\treturn\n\t}\n\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), ds.Type)\n\tif !exists {\n\t\tc.JsonApiErr(http.StatusInternalServerError, \"Unable to find datasource plugin\", err)\n\t\treturn\n\t}\n\n\ths.callPluginResourceWithDataSource(c, plugin.ID, ds)\n}\n\nfunc (hs *HTTPServer) convertModelToDtos(ctx context.Context, ds *datasources.DataSource) dtos.DataSource {\n\tdto := dtos.DataSource{\n\t\tId:               ds.Id,\n\t\tUID:              ds.Uid,\n\t\tOrgId:            ds.OrgId,\n\t\tName:             ds.Name,\n\t\tUrl:              ds.Url,\n\t\tType:             ds.Type,\n\t\tAccess:           ds.Access,\n\t\tDatabase:         ds.Database,\n\t\tUser:             ds.User,\n\t\tBasicAuth:        ds.BasicAuth,\n\t\tBasicAuthUser:    ds.BasicAuthUser,\n\t\tWithCredentials:  ds.WithCredentials,\n\t\tIsDefault:        ds.IsDefault,\n\t\tJsonData:         ds.JsonData,\n\t\tSecureJsonFields: map[string]bool{},\n\t\tVersion:          ds.Version,\n\t\tReadOnly:         ds.ReadOnly,\n\t}\n\n\tsecrets, err := hs.DataSourcesService.DecryptedValues(ctx, ds)\n\tif err == nil {\n\t\tfor k, v := range secrets {\n\t\t\tif len(v) > 0 {\n\t\t\t\tdto.SecureJsonFields[k] = true\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdatasourcesLogger.Debug(\"Failed to retrieve datasource secrets to parse secure json fields\", \"error\", err)\n\t}\n\n\treturn dto\n}\n\n// swagger:route GET /datasources/uid/{uid}/health datasources checkDatasourceHealthWithUID\n//\n// Sends a health check request to the plugin datasource identified by the UID.\n//\n// Responses:\n// 200: okResponse\n// 400: badRequestError\n// 401: unauthorisedError\n// 403: forbiddenError\n// 500: internalServerError\nfunc (hs *HTTPServer) CheckDatasourceHealthWithUID(c *models.ReqContext) response.Response {\n\tdsUID := web.Params(c.Req)[\":uid\"]\n\tif !util.IsValidShortUID(dsUID) {\n\t\treturn response.Error(http.StatusBadRequest, \"UID is invalid\", nil)\n\t}\n\n\tds, err := hs.DataSourceCache.GetDatasourceByUID(c.Req.Context(), dsUID, c.SignedInUser, c.SkipCache)\n\tif err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceAccessDenied) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Access denied to datasource\", err)\n\t\t}\n\t\treturn response.Error(http.StatusInternalServerError, \"Unable to load datasource metadata\", err)\n\t}\n\treturn hs.checkDatasourceHealth(c, ds)\n}\n\n// swagger:route GET /datasources/{id}/health datasources checkDatasourceHealthByID\n//\n// Sends a health check request to the plugin datasource identified by the ID.\n//\n// Please refer to [updated API](#/datasources/checkDatasourceHealthWithUID) instead\n//\n// Deprecated: true\n//\n// Responses:\n// 200: okResponse\n// 400: badRequestError\n// 401: unauthorisedError\n// 403: forbiddenError\n// 500: internalServerError\nfunc (hs *HTTPServer) CheckDatasourceHealth(c *models.ReqContext) response.Response {\n\tdatasourceID, err := strconv.ParseInt(web.Params(c.Req)[\":id\"], 10, 64)\n\tif err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"id is invalid\", nil)\n\t}\n\n\tds, err := hs.DataSourceCache.GetDatasource(c.Req.Context(), datasourceID, c.SignedInUser, c.SkipCache)\n\tif err != nil {\n\t\tif errors.Is(err, datasources.ErrDataSourceAccessDenied) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Access denied to datasource\", err)\n\t\t}\n\t\treturn response.Error(http.StatusInternalServerError, \"Unable to load datasource metadata\", err)\n\t}\n\treturn hs.checkDatasourceHealth(c, ds)\n}\n\nfunc (hs *HTTPServer) checkDatasourceHealth(c *models.ReqContext, ds *datasources.DataSource) response.Response {\n\tplugin, exists := hs.pluginStore.Plugin(c.Req.Context(), ds.Type)\n\tif !exists {\n\t\treturn response.Error(http.StatusInternalServerError, \"Unable to find datasource plugin\", nil)\n\t}\n\n\tdsInstanceSettings, err := adapters.ModelToInstanceSettings(ds, hs.decryptSecureJsonDataFn(c.Req.Context()))\n\tif err != nil {\n\t\treturn response.Error(http.StatusInternalServerError, \"Unable to get datasource model\", err)\n\t}\n\treq := &backend.CheckHealthRequest{\n\t\tPluginContext: backend.PluginContext{\n\t\t\tUser:                       adapters.BackendUserFromSignedInUser(c.SignedInUser),\n\t\t\tOrgID:                      c.OrgId,\n\t\t\tPluginID:                   plugin.ID,\n\t\t\tDataSourceInstanceSettings: dsInstanceSettings,\n\t\t},\n\t\tHeaders: map[string]string{},\n\t}\n\n\tvar dsURL string\n\tif req.PluginContext.DataSourceInstanceSettings != nil {\n\t\tdsURL = req.PluginContext.DataSourceInstanceSettings.URL\n\t}\n\n\terr = hs.PluginRequestValidator.Validate(dsURL, c.Req)\n\tif err != nil {\n\t\treturn response.Error(http.StatusForbidden, \"Access denied\", err)\n\t}\n\n\tif hs.DataProxy.OAuthTokenService.IsOAuthPassThruEnabled(ds) {\n\t\tif token := hs.DataProxy.OAuthTokenService.GetCurrentOAuthToken(c.Req.Context(), c.SignedInUser); token != nil {\n\t\t\treq.Headers[\"Authorization\"] = fmt.Sprintf(\"%s %s\", token.Type(), token.AccessToken)\n\t\t\tidToken, ok := token.Extra(\"id_token\").(string)\n\t\t\tif ok && idToken != \"\" {\n\t\t\t\treq.Headers[\"X-ID-Token\"] = idToken\n\t\t\t}\n\t\t}\n\t}\n\n\tproxyutil.ClearCookieHeader(c.Req, ds.AllowedCookies(), []string{hs.Cfg.LoginCookieName})\n\tif cookieStr := c.Req.Header.Get(\"Cookie\"); cookieStr != \"\" {\n\t\treq.Headers[\"Cookie\"] = cookieStr\n\t}\n\n\tresp, err := hs.pluginClient.CheckHealth(c.Req.Context(), req)\n\tif err != nil {\n\t\treturn translatePluginRequestErrorToAPIError(err)\n\t}\n\n\tpayload := map[string]interface{}{\n\t\t\"status\":  resp.Status.String(),\n\t\t\"message\": resp.Message,\n\t}\n\n\t// Unmarshal JSONDetails if it's not empty.\n\tif len(resp.JSONDetails) > 0 {\n\t\tvar jsonDetails map[string]interface{}\n\t\terr = json.Unmarshal(resp.JSONDetails, &jsonDetails)\n\t\tif err != nil {\n\t\t\treturn response.Error(http.StatusInternalServerError, \"Failed to unmarshal detailed response from backend plugin\", err)\n\t\t}\n\n\t\tpayload[\"details\"] = jsonDetails\n\t}\n\n\tif resp.Status != backend.HealthStatusOk {\n\t\treturn response.JSON(http.StatusBadRequest, payload)\n\t}\n\n\treturn response.JSON(http.StatusOK, payload)\n}\n\nfunc (hs *HTTPServer) decryptSecureJsonDataFn(ctx context.Context) func(ds *datasources.DataSource) (map[string]string, error) {\n\treturn func(ds *datasources.DataSource) (map[string]string, error) {\n\t\treturn hs.DataSourcesService.DecryptedValues(ctx, ds)\n\t}\n}\n\nfunc (hs *HTTPServer) filterDatasourcesByQueryPermission(ctx context.Context, user *models.SignedInUser, ds []*datasources.DataSource) ([]*datasources.DataSource, error) {\n\tquery := datasources.DatasourcesPermissionFilterQuery{\n\t\tUser:        user,\n\t\tDatasources: ds,\n\t}\n\tquery.Result = ds\n\n\tif err := hs.DatasourcePermissionsService.FilterDatasourcesBasedOnQueryPermissions(ctx, &query); err != nil {\n\t\tif !errors.Is(err, permissions.ErrNotImplemented) {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn ds, nil\n\t}\n\n\treturn query.Result, nil\n}\n\n// swagger:parameters checkDatasourceHealthByID\ntype CheckDatasourceHealthByIDParams struct {\n\t// in:path\n\t// required:true\n\tDatasourceID string `json:\"id\"`\n}\n\n// swagger:parameters callDatasourceResourceByID\ntype CallDatasourceResourceByIDParams struct {\n\t// in:path\n\t// required:true\n\tDatasourceID string `json:\"id\"`\n}\n\n// swagger:parameters deleteDataSourceByID\ntype DeleteDataSourceByIDParams struct {\n\t// in:path\n\t// required:true\n\tDatasourceID string `json:\"id\"`\n}\n\n// swagger:parameters getDataSourceByID\ntype GetDataSourceByIDParams struct {\n\t// in:path\n\t// required:true\n\tDatasourceID string `json:\"id\"`\n}\n\n// swagger:parameters checkDatasourceHealthWithUID\ntype CheckDatasourceHealthWithUIDParams struct {\n\t// in:path\n\t// required:true\n\tDatasourceUID string `json:\"uid\"`\n}\n\n// swagger:parameters callDatasourceResourceWithUID\ntype CallDatasourceResourceWithUIDParams struct {\n\t// in:path\n\t// required:true\n\tDatasourceUID string `json:\"uid\"`\n}\n\n// swagger:parameters deleteDataSourceByUID\ntype DeleteDataSourceByUIDParams struct {\n\t// in:path\n\t// required:true\n\tDatasourceUID string `json:\"uid\"`\n}\n\n// swagger:parameters getDataSourceByUID\ntype GetDataSourceByUIDParams struct {\n\t// in:path\n\t// required:true\n\tDatasourceUID string `json:\"uid\"`\n}\n\n// swagger:parameters getDataSourceByName\ntype GetDataSourceByNameParams struct {\n\t// in:path\n\t// required:true\n\tDatasourceName string `json:\"name\"`\n}\n\n// swagger:parameters deleteDataSourceByName\ntype DeleteDataSourceByNameParams struct {\n\t// in:path\n\t// required:true\n\tDatasourceName string `json:\"name\"`\n}\n\n// swagger:parameters getDataSourceIdByName\ntype GetDataSourceIdByNameParams struct {\n\t// in:path\n\t// required:true\n\tDatasourceName string `json:\"name\"`\n}\n\n// swagger:parameters addDataSource\ntype AddDataSourceParams struct {\n\t// in:body\n\t// required:true\n\tBody datasources.AddDataSourceCommand\n}\n\n// swagger:parameters updateDataSourceByID\ntype UpdateDataSourceByIDParams struct {\n\t// in:body\n\t// required:true\n\tBody datasources.UpdateDataSourceCommand\n\t// in:path\n\t// required:true\n\tDatasourceID string `json:\"id\"`\n}\n\n// swagger:parameters updateDataSourceByUID\ntype UpdateDataSourceByUIDParams struct {\n\t// in:body\n\t// required:true\n\tBody datasources.UpdateDataSourceCommand\n\t// in:path\n\t// required:true\n\tDatasourceUID string `json:\"uid\"`\n}\n\n// swagger:response getDataSourcesResponse\ntype GetDataSourcesResponse struct {\n\t// The response message\n\t// in: body\n\tBody dtos.DataSourceList `json:\"body\"`\n}\n\n// swagger:response getDataSourceResponse\ntype GetDataSourceResponse struct {\n\t// The response message\n\t// in: body\n\tBody dtos.DataSource `json:\"body\"`\n}\n\n// swagger:response createOrUpdateDatasourceResponse\ntype CreateOrUpdateDatasourceResponse struct {\n\t// The response message\n\t// in: body\n\tBody struct {\n\t\t// ID Identifier of the new data source.\n\t\t// required: true\n\t\t// example: 65\n\t\tID int64 `json:\"id\"`\n\n\t\t// Name of the new data source.\n\t\t// required: true\n\t\t// example: My Data source\n\t\tName string `json:\"name\"`\n\n\t\t// Message Message of the deleted dashboard.\n\t\t// required: true\n\t\t// example: Data source added\n\t\tMessage string `json:\"message\"`\n\n\t\t// Datasource properties\n\t\t// required: true\n\t\tDatasource dtos.DataSource `json:\"datasource\"`\n\t} `json:\"body\"`\n}\n\n// swagger:response getDataSourceIDResponse\ntype GetDataSourceIDresponse struct {\n\t// The response message\n\t// in: body\n\tBody struct {\n\t\t// ID Identifier of the data source.\n\t\t// required: true\n\t\t// example: 65\n\t\tID int64 `json:\"id\"`\n\t} `json:\"body\"`\n}\n\n// swagger:response deleteDataSourceByNameResponse\ntype DeleteDataSourceByNameResponse struct {\n\t// The response message\n\t// in: body\n\tBody struct {\n\t\t// ID Identifier of the deleted data source.\n\t\t// required: true\n\t\t// example: 65\n\t\tID int64 `json:\"id\"`\n\n\t\t// Message Message of the deleted dashboard.\n\t\t// required: true\n\t\t// example: Dashboard My Dashboard deleted\n\t\tMessage string `json:\"message\"`\n\t} `json:\"body\"`\n}\n", "package api\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/grafana/grafana/pkg/services/datasources\"\n\t\"github.com/grafana/grafana/pkg/services/featuremgmt\"\n\t\"github.com/grafana/grafana/pkg/services/quota/quotatest\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/web/webtest\"\n\n\t\"golang.org/x/oauth2\"\n\n\t\"github.com/grafana/grafana/pkg/models\"\n\tfakeDatasources \"github.com/grafana/grafana/pkg/services/datasources/fakes\"\n\t\"github.com/grafana/grafana/pkg/services/query\"\n)\n\nvar queryDatasourceInput = `{\n\"from\": \"\",\n\t\t\"to\": \"\",\n\t\t\"queries\": [\n\t\t\t{\n\t\t\t\t\"datasource\": {\n\t\t\t\t\t\"type\": \"datasource\",\n\t\t\t\t\t\"uid\": \"grafana\"\n\t\t\t\t},\n\t\t\t\t\"queryType\": \"randomWalk\",\n\t\t\t\t\"refId\": \"A\"\n\t\t\t}\n\t\t]\n\t}`\n\ntype fakePluginRequestValidator struct {\n\terr error\n}\n\ntype secretsErrorResponseBody struct {\n\tError   string `json:\"error\"`\n\tMessage string `json:\"message\"`\n}\n\nfunc (rv *fakePluginRequestValidator) Validate(dsURL string, req *http.Request) error {\n\treturn rv.err\n}\n\ntype fakeOAuthTokenService struct {\n\tpassThruEnabled bool\n\ttoken           *oauth2.Token\n}\n\nfunc (ts *fakeOAuthTokenService) GetCurrentOAuthToken(context.Context, *models.SignedInUser) *oauth2.Token {\n\treturn ts.token\n}\n\nfunc (ts *fakeOAuthTokenService) IsOAuthPassThruEnabled(*datasources.DataSource) bool {\n\treturn ts.passThruEnabled\n}\n\n// `/ds/query` endpoint test\nfunc TestAPIEndpoint_Metrics_QueryMetricsV2(t *testing.T) {\n\tqds := query.ProvideService(\n\t\tsetting.NewCfg(),\n\t\tnil,\n\t\tnil,\n\t\t&fakePluginRequestValidator{},\n\t\t&fakeDatasources.FakeDataSourceService{},\n\t\t&fakePluginClient{\n\t\t\tQueryDataHandlerFunc: func(ctx context.Context, req *backend.QueryDataRequest) (*backend.QueryDataResponse, error) {\n\t\t\t\tresp := backend.Responses{\n\t\t\t\t\t\"A\": backend.DataResponse{\n\t\t\t\t\t\tError: fmt.Errorf(\"query failed\"),\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn &backend.QueryDataResponse{Responses: resp}, nil\n\t\t\t},\n\t\t},\n\t\t&fakeOAuthTokenService{},\n\t)\n\tserverFeatureEnabled := SetupAPITestServer(t, func(hs *HTTPServer) {\n\t\ths.queryDataService = qds\n\t\ths.Features = featuremgmt.WithFeatures(featuremgmt.FlagDatasourceQueryMultiStatus, true)\n\t\ths.QuotaService = quotatest.NewQuotaServiceFake()\n\t})\n\tserverFeatureDisabled := SetupAPITestServer(t, func(hs *HTTPServer) {\n\t\ths.queryDataService = qds\n\t\ths.Features = featuremgmt.WithFeatures(featuremgmt.FlagDatasourceQueryMultiStatus, false)\n\t\ths.QuotaService = quotatest.NewQuotaServiceFake()\n\t})\n\n\tt.Run(\"Status code is 400 when data source response has an error and feature toggle is disabled\", func(t *testing.T) {\n\t\treq := serverFeatureDisabled.NewPostRequest(\"/api/ds/query\", strings.NewReader(queryDatasourceInput))\n\t\twebtest.RequestWithSignedInUser(req, &models.SignedInUser{UserId: 1, OrgId: 1, OrgRole: models.ROLE_VIEWER})\n\t\tresp, err := serverFeatureDisabled.SendJSON(req)\n\t\trequire.NoError(t, err)\n\t\trequire.NoError(t, resp.Body.Close())\n\t\trequire.Equal(t, http.StatusBadRequest, resp.StatusCode)\n\t})\n\n\tt.Run(\"Status code is 207 when data source response has an error and feature toggle is enabled\", func(t *testing.T) {\n\t\treq := serverFeatureEnabled.NewPostRequest(\"/api/ds/query\", strings.NewReader(queryDatasourceInput))\n\t\twebtest.RequestWithSignedInUser(req, &models.SignedInUser{UserId: 1, OrgId: 1, OrgRole: models.ROLE_VIEWER})\n\t\tresp, err := serverFeatureEnabled.SendJSON(req)\n\t\trequire.NoError(t, err)\n\t\trequire.NoError(t, resp.Body.Close())\n\t\trequire.Equal(t, http.StatusMultiStatus, resp.StatusCode)\n\t})\n}\n\nfunc TestAPIEndpoint_Metrics_PluginDecryptionFailure(t *testing.T) {\n\tqds := query.ProvideService(\n\t\tsetting.NewCfg(),\n\t\tnil,\n\t\tnil,\n\t\t&fakePluginRequestValidator{},\n\t\t&fakeDatasources.FakeDataSourceService{SimulatePluginFailure: true},\n\t\t&fakePluginClient{\n\t\t\tQueryDataHandlerFunc: func(ctx context.Context, req *backend.QueryDataRequest) (*backend.QueryDataResponse, error) {\n\t\t\t\tresp := backend.Responses{\n\t\t\t\t\t\"A\": backend.DataResponse{\n\t\t\t\t\t\tError: fmt.Errorf(\"query failed\"),\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn &backend.QueryDataResponse{Responses: resp}, nil\n\t\t\t},\n\t\t},\n\t\t&fakeOAuthTokenService{},\n\t)\n\thttpServer := SetupAPITestServer(t, func(hs *HTTPServer) {\n\t\ths.queryDataService = qds\n\t\ths.QuotaService = quotatest.NewQuotaServiceFake()\n\t})\n\n\tt.Run(\"Status code is 500 and a secrets plugin error is returned if there is a problem getting secrets from the remote plugin\", func(t *testing.T) {\n\t\treq := httpServer.NewPostRequest(\"/api/ds/query\", strings.NewReader(queryDatasourceInput))\n\t\twebtest.RequestWithSignedInUser(req, &models.SignedInUser{UserId: 1, OrgId: 1, OrgRole: models.ROLE_VIEWER})\n\t\tresp, err := httpServer.SendJSON(req)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, http.StatusInternalServerError, resp.StatusCode)\n\t\tbuf := new(bytes.Buffer)\n\t\t_, err = buf.ReadFrom(resp.Body)\n\t\trequire.NoError(t, err)\n\t\trequire.NoError(t, resp.Body.Close())\n\t\tvar resObj secretsErrorResponseBody\n\t\terr = json.Unmarshal(buf.Bytes(), &resObj)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, \"unknown error\", resObj.Error)\n\t\trequire.Contains(t, resObj.Message, \"Secrets Plugin error:\")\n\t})\n}\n", "package api\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"sync\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins/backendplugin\"\n\t\"github.com/grafana/grafana/pkg/services/datasources\"\n\t\"github.com/grafana/grafana/pkg/util/proxyutil\"\n\t\"github.com/grafana/grafana/pkg/web\"\n)\n\n// CallResource passes a resource call from a plugin to the backend plugin.\n//\n// /api/plugins/:pluginId/resources/*\nfunc (hs *HTTPServer) CallResource(c *models.ReqContext) {\n\ths.callPluginResource(c, web.Params(c.Req)[\":pluginId\"])\n}\n\nfunc (hs *HTTPServer) callPluginResource(c *models.ReqContext, pluginID string) {\n\tpCtx, found, err := hs.PluginContextProvider.Get(c.Req.Context(), pluginID, c.SignedInUser)\n\tif err != nil {\n\t\tc.JsonApiErr(500, \"Failed to get plugin settings\", err)\n\t\treturn\n\t}\n\tif !found {\n\t\tc.JsonApiErr(404, \"Plugin not found\", nil)\n\t\treturn\n\t}\n\n\treq, err := hs.pluginResourceRequest(c)\n\tif err != nil {\n\t\tc.JsonApiErr(http.StatusBadRequest, \"Failed for create plugin resource request\", err)\n\t\treturn\n\t}\n\n\tif err = hs.makePluginResourceRequest(c.Resp, req, pCtx); err != nil {\n\t\thandleCallResourceError(err, c)\n\t}\n}\n\nfunc (hs *HTTPServer) callPluginResourceWithDataSource(c *models.ReqContext, pluginID string, ds *datasources.DataSource) {\n\tpCtx, found, err := hs.PluginContextProvider.GetWithDataSource(c.Req.Context(), pluginID, c.SignedInUser, ds)\n\tif err != nil {\n\t\tc.JsonApiErr(500, \"Failed to get plugin settings\", err)\n\t\treturn\n\t}\n\tif !found {\n\t\tc.JsonApiErr(404, \"Plugin not found\", nil)\n\t\treturn\n\t}\n\n\tvar dsURL string\n\tif pCtx.DataSourceInstanceSettings != nil {\n\t\tdsURL = pCtx.DataSourceInstanceSettings.URL\n\t}\n\n\terr = hs.PluginRequestValidator.Validate(dsURL, c.Req)\n\tif err != nil {\n\t\tc.JsonApiErr(http.StatusForbidden, \"Access denied\", err)\n\t\treturn\n\t}\n\n\treq, err := hs.pluginResourceRequest(c)\n\tif err != nil {\n\t\tc.JsonApiErr(http.StatusBadRequest, \"Failed for create plugin resource request\", err)\n\t\treturn\n\t}\n\n\tif hs.DataProxy.OAuthTokenService.IsOAuthPassThruEnabled(ds) {\n\t\tif token := hs.DataProxy.OAuthTokenService.GetCurrentOAuthToken(c.Req.Context(), c.SignedInUser); token != nil {\n\t\t\treq.Header.Add(\"Authorization\", fmt.Sprintf(\"%s %s\", token.Type(), token.AccessToken))\n\n\t\t\tidToken, ok := token.Extra(\"id_token\").(string)\n\t\t\tif ok && idToken != \"\" {\n\t\t\t\treq.Header.Add(\"X-ID-Token\", idToken)\n\t\t\t}\n\t\t}\n\t}\n\n\tif err = hs.makePluginResourceRequest(c.Resp, req, pCtx); err != nil {\n\t\thandleCallResourceError(err, c)\n\t}\n}\n\nfunc (hs *HTTPServer) pluginResourceRequest(c *models.ReqContext) (*http.Request, error) {\n\tclonedReq := c.Req.Clone(c.Req.Context())\n\trawURL := web.Params(c.Req)[\"*\"]\n\tif clonedReq.URL.RawQuery != \"\" {\n\t\trawURL += \"?\" + clonedReq.URL.RawQuery\n\t}\n\turlPath, err := url.Parse(rawURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclonedReq.URL = urlPath\n\n\treturn clonedReq, nil\n}\n\nfunc (hs *HTTPServer) makePluginResourceRequest(w http.ResponseWriter, req *http.Request, pCtx backend.PluginContext) error {\n\tkeepCookieModel := struct {\n\t\tKeepCookies []string `json:\"keepCookies\"`\n\t}{}\n\tif dis := pCtx.DataSourceInstanceSettings; dis != nil {\n\t\terr := json.Unmarshal(dis.JSONData, &keepCookieModel)\n\t\tif err != nil {\n\t\t\ths.log.Warn(\"failed to unpack JSONData in datasource instance settings\", \"err\", err)\n\t\t}\n\t}\n\tproxyutil.ClearCookieHeader(req, keepCookieModel.KeepCookies, []string{hs.Cfg.LoginCookieName})\n\tproxyutil.PrepareProxyRequest(req)\n\n\tbody, err := ioutil.ReadAll(req.Body)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to read request body: %w\", err)\n\t}\n\n\tcrReq := &backend.CallResourceRequest{\n\t\tPluginContext: pCtx,\n\t\tPath:          req.URL.Path,\n\t\tMethod:        req.Method,\n\t\tURL:           req.URL.String(),\n\t\tHeaders:       req.Header,\n\t\tBody:          body,\n\t}\n\n\tchildCtx, cancel := context.WithCancel(req.Context())\n\tdefer cancel()\n\tstream := newCallResourceResponseStream(childCtx)\n\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\n\tdefer func() {\n\t\tif err := stream.Close(); err != nil {\n\t\t\ths.log.Warn(\"Failed to close plugin resource stream\", \"err\", err)\n\t\t}\n\t\twg.Wait()\n\t}()\n\n\tvar flushStreamErr error\n\tgo func() {\n\t\tflushStreamErr = hs.flushStream(stream, w)\n\t\twg.Done()\n\t}()\n\n\tif err := hs.pluginClient.CallResource(req.Context(), crReq, stream); err != nil {\n\t\treturn err\n\t}\n\n\treturn flushStreamErr\n}\n\nfunc (hs *HTTPServer) flushStream(stream callResourceClientResponseStream, w http.ResponseWriter) error {\n\tprocessedStreams := 0\n\n\tfor {\n\t\tresp, err := stream.Recv()\n\t\tif errors.Is(err, io.EOF) {\n\t\t\tif processedStreams == 0 {\n\t\t\t\treturn errors.New(\"received empty resource response\")\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\tif err != nil {\n\t\t\tif processedStreams == 0 {\n\t\t\t\treturn fmt.Errorf(\"%v: %w\", \"failed to receive response from resource call\", err)\n\t\t\t}\n\n\t\t\ths.log.Error(\"Failed to receive response from resource call\", \"err\", err)\n\t\t\treturn stream.Close()\n\t\t}\n\n\t\t// Expected that headers and status are only part of first stream\n\t\tif processedStreams == 0 && resp.Headers != nil {\n\t\t\t// Make sure a content type always is returned in response\n\t\t\tif _, exists := resp.Headers[\"Content-Type\"]; !exists {\n\t\t\t\tresp.Headers[\"Content-Type\"] = []string{\"application/json\"}\n\t\t\t}\n\n\t\t\tfor k, values := range resp.Headers {\n\t\t\t\t// Due to security reasons we don't want to forward\n\t\t\t\t// cookies from a backend plugin to clients/browsers.\n\t\t\t\tif k == \"Set-Cookie\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfor _, v := range values {\n\t\t\t\t\t// TODO: Figure out if we should use Set here instead\n\t\t\t\t\t// nolint:gocritic\n\t\t\t\t\tw.Header().Add(k, v)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tproxyutil.SetProxyResponseHeaders(w.Header())\n\n\t\t\tw.WriteHeader(resp.Status)\n\t\t}\n\n\t\tif _, err := w.Write(resp.Body); err != nil {\n\t\t\ths.log.Error(\"Failed to write resource response\", \"err\", err)\n\t\t}\n\n\t\tif flusher, ok := w.(http.Flusher); ok {\n\t\t\tflusher.Flush()\n\t\t}\n\t\tprocessedStreams++\n\t}\n}\n\nfunc handleCallResourceError(err error, reqCtx *models.ReqContext) {\n\tif errors.Is(err, backendplugin.ErrPluginUnavailable) {\n\t\treqCtx.JsonApiErr(503, \"Plugin unavailable\", err)\n\t\treturn\n\t}\n\n\tif errors.Is(err, backendplugin.ErrMethodNotImplemented) {\n\t\treqCtx.JsonApiErr(404, \"Not found\", err)\n\t\treturn\n\t}\n\n\treqCtx.JsonApiErr(500, \"Failed to call resource\", err)\n}\n\n// callResourceClientResponseStream is used for receiving resource call responses.\ntype callResourceClientResponseStream interface {\n\tRecv() (*backend.CallResourceResponse, error)\n\tClose() error\n}\n\ntype callResourceResponseStream struct {\n\tctx    context.Context\n\tstream chan *backend.CallResourceResponse\n\tclosed bool\n}\n\nfunc newCallResourceResponseStream(ctx context.Context) *callResourceResponseStream {\n\treturn &callResourceResponseStream{\n\t\tctx:    ctx,\n\t\tstream: make(chan *backend.CallResourceResponse),\n\t}\n}\n\nfunc (s *callResourceResponseStream) Send(res *backend.CallResourceResponse) error {\n\tif s.closed {\n\t\treturn errors.New(\"cannot send to a closed stream\")\n\t}\n\n\tselect {\n\tcase <-s.ctx.Done():\n\t\treturn errors.New(\"cancelled\")\n\tcase s.stream <- res:\n\t\treturn nil\n\t}\n}\n\nfunc (s *callResourceResponseStream) Recv() (*backend.CallResourceResponse, error) {\n\tselect {\n\tcase <-s.ctx.Done():\n\t\treturn nil, s.ctx.Err()\n\tcase res, ok := <-s.stream:\n\t\tif !ok {\n\t\t\treturn nil, io.EOF\n\t\t}\n\t\treturn res, nil\n\t}\n}\n\nfunc (s *callResourceResponseStream) Close() error {\n\tif s.closed {\n\t\treturn errors.New(\"cannot close a closed stream\")\n\t}\n\n\tclose(s.stream)\n\ts.closed = true\n\treturn nil\n}\n", "package pluginproxy\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"go.opentelemetry.io/otel/attribute\"\n\n\t\"github.com/grafana/grafana/pkg/api/datasource\"\n\t\"github.com/grafana/grafana/pkg/infra/httpclient\"\n\tglog \"github.com/grafana/grafana/pkg/infra/log\"\n\t\"github.com/grafana/grafana/pkg/infra/tracing\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\t\"github.com/grafana/grafana/pkg/services/datasources\"\n\t\"github.com/grafana/grafana/pkg/services/oauthtoken\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util\"\n\t\"github.com/grafana/grafana/pkg/util/proxyutil\"\n)\n\nvar (\n\tlogger = glog.New(\"data-proxy-log\")\n\tclient = newHTTPClient()\n)\n\ntype DataSourceProxy struct {\n\tds                 *datasources.DataSource\n\tctx                *models.ReqContext\n\ttargetUrl          *url.URL\n\tproxyPath          string\n\tmatchedRoute       *plugins.Route\n\tpluginRoutes       []*plugins.Route\n\tcfg                *setting.Cfg\n\tclientProvider     httpclient.Provider\n\toAuthTokenService  oauthtoken.OAuthTokenService\n\tdataSourcesService datasources.DataSourceService\n\ttracer             tracing.Tracer\n}\n\ntype httpClient interface {\n\tDo(req *http.Request) (*http.Response, error)\n}\n\n// NewDataSourceProxy creates a new Datasource proxy\nfunc NewDataSourceProxy(ds *datasources.DataSource, pluginRoutes []*plugins.Route, ctx *models.ReqContext,\n\tproxyPath string, cfg *setting.Cfg, clientProvider httpclient.Provider,\n\toAuthTokenService oauthtoken.OAuthTokenService, dsService datasources.DataSourceService,\n\ttracer tracing.Tracer) (*DataSourceProxy, error) {\n\ttargetURL, err := datasource.ValidateURL(ds.Type, ds.Url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &DataSourceProxy{\n\t\tds:                 ds,\n\t\tpluginRoutes:       pluginRoutes,\n\t\tctx:                ctx,\n\t\tproxyPath:          proxyPath,\n\t\ttargetUrl:          targetURL,\n\t\tcfg:                cfg,\n\t\tclientProvider:     clientProvider,\n\t\toAuthTokenService:  oAuthTokenService,\n\t\tdataSourcesService: dsService,\n\t\ttracer:             tracer,\n\t}, nil\n}\n\nfunc newHTTPClient() httpClient {\n\treturn &http.Client{\n\t\tTimeout:   30 * time.Second,\n\t\tTransport: &http.Transport{Proxy: http.ProxyFromEnvironment},\n\t}\n}\n\nfunc (proxy *DataSourceProxy) HandleRequest() {\n\tif err := proxy.validateRequest(); err != nil {\n\t\tproxy.ctx.JsonApiErr(403, err.Error(), nil)\n\t\treturn\n\t}\n\n\ttraceID := tracing.TraceIDFromContext(proxy.ctx.Req.Context(), false)\n\tproxyErrorLogger := logger.New(\n\t\t\"userId\", proxy.ctx.UserId,\n\t\t\"orgId\", proxy.ctx.OrgId,\n\t\t\"uname\", proxy.ctx.Login,\n\t\t\"path\", proxy.ctx.Req.URL.Path,\n\t\t\"remote_addr\", proxy.ctx.RemoteAddr(),\n\t\t\"referer\", proxy.ctx.Req.Referer(),\n\t\t\"traceID\", traceID,\n\t)\n\n\ttransport, err := proxy.dataSourcesService.GetHTTPTransport(proxy.ctx.Req.Context(), proxy.ds, proxy.clientProvider)\n\tif err != nil {\n\t\tproxy.ctx.JsonApiErr(400, \"Unable to load TLS certificate\", err)\n\t\treturn\n\t}\n\n\tmodifyResponse := func(resp *http.Response) error {\n\t\tif resp.StatusCode == 401 {\n\t\t\t// The data source rejected the request as unauthorized, convert to 400 (bad request)\n\t\t\tbody, err := ioutil.ReadAll(resp.Body)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to read data source response body: %w\", err)\n\t\t\t}\n\t\t\t_ = resp.Body.Close()\n\n\t\t\tproxyErrorLogger.Info(\"Authentication to data source failed\", \"body\", string(body), \"statusCode\",\n\t\t\t\tresp.StatusCode)\n\t\t\tmsg := \"Authentication to data source failed\"\n\t\t\t*resp = http.Response{\n\t\t\t\tStatusCode:    400,\n\t\t\t\tStatus:        \"Bad Request\",\n\t\t\t\tBody:          ioutil.NopCloser(strings.NewReader(msg)),\n\t\t\t\tContentLength: int64(len(msg)),\n\t\t\t\tHeader:        http.Header{},\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\treverseProxy := proxyutil.NewReverseProxy(\n\t\tproxyErrorLogger,\n\t\tproxy.director,\n\t\tproxyutil.WithTransport(transport),\n\t\tproxyutil.WithModifyResponse(modifyResponse),\n\t)\n\n\tproxy.logRequest()\n\tctx, span := proxy.tracer.Start(proxy.ctx.Req.Context(), \"datasource reverse proxy\")\n\tdefer span.End()\n\n\tproxy.ctx.Req = proxy.ctx.Req.WithContext(ctx)\n\n\tspan.SetAttributes(\"datasource_name\", proxy.ds.Name, attribute.Key(\"datasource_name\").String(proxy.ds.Name))\n\tspan.SetAttributes(\"datasource_type\", proxy.ds.Type, attribute.Key(\"datasource_type\").String(proxy.ds.Type))\n\tspan.SetAttributes(\"user\", proxy.ctx.SignedInUser.Login, attribute.Key(\"user\").String(proxy.ctx.SignedInUser.Login))\n\tspan.SetAttributes(\"org_id\", proxy.ctx.SignedInUser.OrgId, attribute.Key(\"org_id\").Int64(proxy.ctx.SignedInUser.OrgId))\n\n\tproxy.addTraceFromHeaderValue(span, \"X-Panel-Id\", \"panel_id\")\n\tproxy.addTraceFromHeaderValue(span, \"X-Dashboard-Id\", \"dashboard_id\")\n\n\tproxy.tracer.Inject(ctx, proxy.ctx.Req.Header, span)\n\n\treverseProxy.ServeHTTP(proxy.ctx.Resp, proxy.ctx.Req)\n}\n\nfunc (proxy *DataSourceProxy) addTraceFromHeaderValue(span tracing.Span, headerName string, tagName string) {\n\tpanelId := proxy.ctx.Req.Header.Get(headerName)\n\tdashId, err := strconv.Atoi(panelId)\n\tif err == nil {\n\t\tspan.SetAttributes(tagName, dashId, attribute.Key(tagName).Int(dashId))\n\t}\n}\n\nfunc (proxy *DataSourceProxy) director(req *http.Request) {\n\treq.URL.Scheme = proxy.targetUrl.Scheme\n\treq.URL.Host = proxy.targetUrl.Host\n\treq.Host = proxy.targetUrl.Host\n\n\treqQueryVals := req.URL.Query()\n\n\tswitch proxy.ds.Type {\n\tcase datasources.DS_INFLUXDB_08:\n\t\tpassword, err := proxy.dataSourcesService.DecryptedPassword(req.Context(), proxy.ds)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Error interpolating proxy url\", \"error\", err)\n\t\t\treturn\n\t\t}\n\n\t\treq.URL.RawPath = util.JoinURLFragments(proxy.targetUrl.Path, \"db/\"+proxy.ds.Database+\"/\"+proxy.proxyPath)\n\t\treqQueryVals.Add(\"u\", proxy.ds.User)\n\t\treqQueryVals.Add(\"p\", password)\n\t\treq.URL.RawQuery = reqQueryVals.Encode()\n\tcase datasources.DS_INFLUXDB:\n\t\tpassword, err := proxy.dataSourcesService.DecryptedPassword(req.Context(), proxy.ds)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Error interpolating proxy url\", \"error\", err)\n\t\t\treturn\n\t\t}\n\t\treq.URL.RawPath = util.JoinURLFragments(proxy.targetUrl.Path, proxy.proxyPath)\n\t\treq.URL.RawQuery = reqQueryVals.Encode()\n\t\tif !proxy.ds.BasicAuth {\n\t\t\treq.Header.Set(\n\t\t\t\t\"Authorization\",\n\t\t\t\tutil.GetBasicAuthHeader(proxy.ds.User, password),\n\t\t\t)\n\t\t}\n\tdefault:\n\t\treq.URL.RawPath = util.JoinURLFragments(proxy.targetUrl.Path, proxy.proxyPath)\n\t}\n\n\tunescapedPath, err := url.PathUnescape(req.URL.RawPath)\n\tif err != nil {\n\t\tlogger.Error(\"Failed to unescape raw path\", \"rawPath\", req.URL.RawPath, \"error\", err)\n\t\treturn\n\t}\n\n\treq.URL.Path = unescapedPath\n\n\tif proxy.ds.BasicAuth {\n\t\tpassword, err := proxy.dataSourcesService.DecryptedBasicAuthPassword(req.Context(), proxy.ds)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Error interpolating proxy url\", \"error\", err)\n\t\t\treturn\n\t\t}\n\t\treq.Header.Set(\"Authorization\", util.GetBasicAuthHeader(proxy.ds.BasicAuthUser,\n\t\t\tpassword))\n\t}\n\n\tdsAuth := req.Header.Get(\"X-DS-Authorization\")\n\tif len(dsAuth) > 0 {\n\t\treq.Header.Del(\"X-DS-Authorization\")\n\t\treq.Header.Set(\"Authorization\", dsAuth)\n\t}\n\n\tapplyUserHeader(proxy.cfg.SendUserHeader, req, proxy.ctx.SignedInUser)\n\n\tproxyutil.ClearCookieHeader(req, proxy.ds.AllowedCookies(), []string{proxy.cfg.LoginCookieName})\n\treq.Header.Set(\"User-Agent\", fmt.Sprintf(\"Grafana/%s\", setting.BuildVersion))\n\n\tjsonData := make(map[string]interface{})\n\tif proxy.ds.JsonData != nil {\n\t\tjsonData, err = proxy.ds.JsonData.Map()\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Failed to get json data as map\", \"jsonData\", proxy.ds.JsonData, \"error\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\tif proxy.matchedRoute != nil {\n\t\tdecryptedValues, err := proxy.dataSourcesService.DecryptedValues(req.Context(), proxy.ds)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Error interpolating proxy url\", \"error\", err)\n\t\t\treturn\n\t\t}\n\n\t\tApplyRoute(req.Context(), req, proxy.proxyPath, proxy.matchedRoute, DSInfo{\n\t\t\tID:                      proxy.ds.Id,\n\t\t\tUpdated:                 proxy.ds.Updated,\n\t\t\tJSONData:                jsonData,\n\t\t\tDecryptedSecureJSONData: decryptedValues,\n\t\t}, proxy.cfg)\n\t}\n\n\tif proxy.oAuthTokenService.IsOAuthPassThruEnabled(proxy.ds) {\n\t\tif token := proxy.oAuthTokenService.GetCurrentOAuthToken(req.Context(), proxy.ctx.SignedInUser); token != nil {\n\t\t\treq.Header.Set(\"Authorization\", fmt.Sprintf(\"%s %s\", token.Type(), token.AccessToken))\n\n\t\t\tidToken, ok := token.Extra(\"id_token\").(string)\n\t\t\tif ok && idToken != \"\" {\n\t\t\t\treq.Header.Set(\"X-ID-Token\", idToken)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (proxy *DataSourceProxy) validateRequest() error {\n\tif !checkWhiteList(proxy.ctx, proxy.targetUrl.Host) {\n\t\treturn errors.New(\"target URL is not a valid target\")\n\t}\n\n\tif proxy.ds.Type == datasources.DS_ES {\n\t\tif proxy.ctx.Req.Method == \"DELETE\" {\n\t\t\treturn errors.New(\"deletes not allowed on proxied Elasticsearch datasource\")\n\t\t}\n\t\tif proxy.ctx.Req.Method == \"PUT\" {\n\t\t\treturn errors.New(\"puts not allowed on proxied Elasticsearch datasource\")\n\t\t}\n\t\tif proxy.ctx.Req.Method == \"POST\" && proxy.proxyPath != \"_msearch\" {\n\t\t\treturn errors.New(\"posts not allowed on proxied Elasticsearch datasource except on /_msearch\")\n\t\t}\n\t}\n\n\t// found route if there are any\n\tfor _, route := range proxy.pluginRoutes {\n\t\t// method match\n\t\tif route.Method != \"\" && route.Method != \"*\" && route.Method != proxy.ctx.Req.Method {\n\t\t\tcontinue\n\t\t}\n\n\t\t// route match\n\t\tif !strings.HasPrefix(proxy.proxyPath, route.Path) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif route.ReqRole.IsValid() {\n\t\t\tif !proxy.ctx.HasUserRole(route.ReqRole) {\n\t\t\t\treturn errors.New(\"plugin proxy route access denied\")\n\t\t\t}\n\t\t}\n\n\t\tproxy.matchedRoute = route\n\t\treturn nil\n\t}\n\n\t// Trailing validation below this point for routes that were not matched\n\tif proxy.ds.Type == datasources.DS_PROMETHEUS {\n\t\tif proxy.ctx.Req.Method == \"DELETE\" {\n\t\t\treturn errors.New(\"non allow-listed DELETEs not allowed on proxied Prometheus datasource\")\n\t\t}\n\t\tif proxy.ctx.Req.Method == \"PUT\" {\n\t\t\treturn errors.New(\"non allow-listed PUTs not allowed on proxied Prometheus datasource\")\n\t\t}\n\t\tif proxy.ctx.Req.Method == \"POST\" {\n\t\t\treturn errors.New(\"non allow-listed POSTs not allowed on proxied Prometheus datasource\")\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (proxy *DataSourceProxy) logRequest() {\n\tif !proxy.cfg.DataProxyLogging {\n\t\treturn\n\t}\n\n\tvar body string\n\tif proxy.ctx.Req.Body != nil {\n\t\tbuffer, err := ioutil.ReadAll(proxy.ctx.Req.Body)\n\t\tif err == nil {\n\t\t\tproxy.ctx.Req.Body = ioutil.NopCloser(bytes.NewBuffer(buffer))\n\t\t\tbody = string(buffer)\n\t\t}\n\t}\n\n\tlogger.Info(\"Proxying incoming request\",\n\t\t\"userid\", proxy.ctx.UserId,\n\t\t\"orgid\", proxy.ctx.OrgId,\n\t\t\"username\", proxy.ctx.Login,\n\t\t\"datasource\", proxy.ds.Type,\n\t\t\"uri\", proxy.ctx.Req.RequestURI,\n\t\t\"method\", proxy.ctx.Req.Method,\n\t\t\"body\", body)\n}\n\nfunc checkWhiteList(c *models.ReqContext, host string) bool {\n\tif host != \"\" && len(setting.DataProxyWhiteList) > 0 {\n\t\tif _, exists := setting.DataProxyWhiteList[host]; !exists {\n\t\t\tc.JsonApiErr(403, \"Data proxy hostname and ip are not included in whitelist\", nil)\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n", "package httpclientprovider_test\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend/httpclient\"\n\t\"github.com/grafana/grafana/pkg/infra/httpclient/httpclientprovider\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestForwardedCookiesMiddleware(t *testing.T) {\n\ttcs := []struct {\n\t\tdesc                 string\n\t\tallowedCookies       []string\n\t\tdisallowedCookies    []string\n\t\texpectedCookieHeader string\n\t}{\n\t\t{\n\t\t\tdesc:                 \"With nil allowedCookies should not populate Cookie header\",\n\t\t\tallowedCookies:       nil,\n\t\t\texpectedCookieHeader: \"\",\n\t\t},\n\t\t{\n\t\t\tdesc:                 \"With empty allowed cookies should not populate Cookie header\",\n\t\t\tallowedCookies:       []string{},\n\t\t\texpectedCookieHeader: \"\",\n\t\t},\n\t\t{\n\t\t\tdesc:                 \"When provided with allowed cookies should populate Cookie header\",\n\t\t\tallowedCookies:       []string{\"c1\", \"c3\"},\n\t\t\texpectedCookieHeader: \"c1=1; c3=3\",\n\t\t},\n\t\t{\n\t\t\tdesc:                 \"When provided with allowed and not allowed cookies should populate Cookie header\",\n\t\t\tallowedCookies:       []string{\"c1\", \"c3\"},\n\t\t\tdisallowedCookies:    []string{\"c1\"},\n\t\t\texpectedCookieHeader: \"c3=3\",\n\t\t},\n\t}\n\n\tfor _, tc := range tcs {\n\t\tt.Run(tc.desc, func(t *testing.T) {\n\t\t\tctx := &testContext{}\n\t\t\tfinalRoundTripper := ctx.createRoundTripper()\n\t\t\tforwarded := []*http.Cookie{\n\t\t\t\t{Name: \"c1\", Value: \"1\"},\n\t\t\t\t{Name: \"c2\", Value: \"2\"},\n\t\t\t\t{Name: \"c3\", Value: \"3\"},\n\t\t\t}\n\t\t\tmw := httpclientprovider.ForwardedCookiesMiddleware(forwarded, tc.allowedCookies, tc.disallowedCookies)\n\t\t\topts := httpclient.Options{}\n\t\t\trt := mw.CreateMiddleware(opts, finalRoundTripper)\n\t\t\trequire.NotNil(t, rt)\n\t\t\tmiddlewareName, ok := mw.(httpclient.MiddlewareName)\n\t\t\trequire.True(t, ok)\n\t\t\trequire.Equal(t, \"forwarded-cookies\", middlewareName.MiddlewareName())\n\n\t\t\treq, err := http.NewRequest(http.MethodGet, \"http://\", nil)\n\t\t\trequire.NoError(t, err)\n\t\t\tres, err := rt.RoundTrip(req)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, res)\n\t\t\tif res.Body != nil {\n\t\t\t\trequire.NoError(t, res.Body.Close())\n\t\t\t}\n\t\t\trequire.Len(t, ctx.callChain, 1)\n\t\t\trequire.ElementsMatch(t, []string{\"final\"}, ctx.callChain)\n\t\t\trequire.Equal(t, tc.expectedCookieHeader, ctx.req.Header.Get(\"Cookie\"))\n\t\t})\n\t}\n}\n", "package httpclientprovider\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend/httpclient\"\n\t\"github.com/grafana/grafana/pkg/util/proxyutil\"\n)\n\nconst ForwardedCookiesMiddlewareName = \"forwarded-cookies\"\n\n// ForwardedCookiesMiddleware middleware that sets Cookie header on the\n// outgoing request, if forwarded cookies configured/provided.\nfunc ForwardedCookiesMiddleware(forwardedCookies []*http.Cookie, allowedCookies []string, disallowedCookies []string) httpclient.Middleware {\n\treturn httpclient.NamedMiddlewareFunc(ForwardedCookiesMiddlewareName, func(opts httpclient.Options, next http.RoundTripper) http.RoundTripper {\n\t\treturn httpclient.RoundTripperFunc(func(req *http.Request) (*http.Response, error) {\n\t\t\tfor _, cookie := range forwardedCookies {\n\t\t\t\treq.AddCookie(cookie)\n\t\t\t}\n\t\t\tproxyutil.ClearCookieHeader(req, allowedCookies, disallowedCookies)\n\t\t\treturn next.RoundTrip(req)\n\t\t})\n\t})\n}\n", "package query\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/grafana/grafana/pkg/api/dtos\"\n\t\"github.com/grafana/grafana/pkg/components/simplejson\"\n\t\"github.com/grafana/grafana/pkg/expr\"\n\t\"github.com/grafana/grafana/pkg/infra/httpclient/httpclientprovider\"\n\t\"github.com/grafana/grafana/pkg/infra/log\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\t\"github.com/grafana/grafana/pkg/plugins/adapters\"\n\t\"github.com/grafana/grafana/pkg/services/datasources\"\n\t\"github.com/grafana/grafana/pkg/services/oauthtoken\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/tsdb/grafanads\"\n\t\"github.com/grafana/grafana/pkg/tsdb/legacydata\"\n\t\"github.com/grafana/grafana/pkg/util/proxyutil\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend/httpclient\"\n)\n\nfunc ProvideService(\n\tcfg *setting.Cfg,\n\tdataSourceCache datasources.CacheService,\n\texpressionService *expr.Service,\n\tpluginRequestValidator models.PluginRequestValidator,\n\tdataSourceService datasources.DataSourceService,\n\tpluginClient plugins.Client,\n\toAuthTokenService oauthtoken.OAuthTokenService,\n) *Service {\n\tg := &Service{\n\t\tcfg:                    cfg,\n\t\tdataSourceCache:        dataSourceCache,\n\t\texpressionService:      expressionService,\n\t\tpluginRequestValidator: pluginRequestValidator,\n\t\tdataSourceService:      dataSourceService,\n\t\tpluginClient:           pluginClient,\n\t\toAuthTokenService:      oAuthTokenService,\n\t\tlog:                    log.New(\"query_data\"),\n\t}\n\tg.log.Info(\"Query Service initialization\")\n\treturn g\n}\n\ntype Service struct {\n\tcfg                    *setting.Cfg\n\tdataSourceCache        datasources.CacheService\n\texpressionService      *expr.Service\n\tpluginRequestValidator models.PluginRequestValidator\n\tdataSourceService      datasources.DataSourceService\n\tpluginClient           plugins.Client\n\toAuthTokenService      oauthtoken.OAuthTokenService\n\tlog                    log.Logger\n}\n\n// Run Service.\nfunc (s *Service) Run(ctx context.Context) error {\n\t<-ctx.Done()\n\treturn ctx.Err()\n}\n\n// QueryData can process queries and return query responses.\nfunc (s *Service) QueryData(ctx context.Context, user *models.SignedInUser, skipCache bool, reqDTO dtos.MetricRequest, handleExpressions bool) (*backend.QueryDataResponse, error) {\n\tparsedReq, err := s.parseMetricRequest(ctx, user, skipCache, reqDTO)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif handleExpressions && parsedReq.hasExpression {\n\t\treturn s.handleExpressions(ctx, user, parsedReq)\n\t}\n\treturn s.handleQueryData(ctx, user, parsedReq)\n}\n\n// QueryData can process queries and return query responses.\nfunc (s *Service) QueryDataMultipleSources(ctx context.Context, user *models.SignedInUser, skipCache bool, reqDTO dtos.MetricRequest, handleExpressions bool) (*backend.QueryDataResponse, error) {\n\tbyDataSource := models.GroupQueriesByDataSource(reqDTO.Queries)\n\n\tif len(byDataSource) == 1 {\n\t\treturn s.QueryData(ctx, user, skipCache, reqDTO, handleExpressions)\n\t} else {\n\t\tresp := backend.NewQueryDataResponse()\n\n\t\tfor _, queries := range byDataSource {\n\t\t\tsubDTO := reqDTO.CloneWithQueries(queries)\n\n\t\t\tsubResp, err := s.QueryData(ctx, user, skipCache, subDTO, handleExpressions)\n\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tfor refId, queryResponse := range subResp.Responses {\n\t\t\t\tresp.Responses[refId] = queryResponse\n\t\t\t}\n\t\t}\n\n\t\treturn resp, nil\n\t}\n}\n\n// handleExpressions handles POST /api/ds/query when there is an expression.\nfunc (s *Service) handleExpressions(ctx context.Context, user *models.SignedInUser, parsedReq *parsedRequest) (*backend.QueryDataResponse, error) {\n\texprReq := expr.Request{\n\t\tOrgId:   user.OrgId,\n\t\tQueries: []expr.Query{},\n\t}\n\n\tfor _, pq := range parsedReq.parsedQueries {\n\t\tif pq.datasource == nil {\n\t\t\treturn nil, NewErrBadQuery(fmt.Sprintf(\"query mising datasource info: %s\", pq.query.RefID))\n\t\t}\n\n\t\texprReq.Queries = append(exprReq.Queries, expr.Query{\n\t\t\tJSON:          pq.query.JSON,\n\t\t\tInterval:      pq.query.Interval,\n\t\t\tRefID:         pq.query.RefID,\n\t\t\tMaxDataPoints: pq.query.MaxDataPoints,\n\t\t\tQueryType:     pq.query.QueryType,\n\t\t\tDataSource:    pq.datasource,\n\t\t\tTimeRange: expr.TimeRange{\n\t\t\t\tFrom: pq.query.TimeRange.From,\n\t\t\t\tTo:   pq.query.TimeRange.To,\n\t\t\t},\n\t\t})\n\t}\n\n\tqdr, err := s.expressionService.TransformData(ctx, &exprReq)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"expression request error: %w\", err)\n\t}\n\treturn qdr, nil\n}\n\nfunc (s *Service) handleQueryData(ctx context.Context, user *models.SignedInUser, parsedReq *parsedRequest) (*backend.QueryDataResponse, error) {\n\tds := parsedReq.parsedQueries[0].datasource\n\tif err := s.pluginRequestValidator.Validate(ds.Url, nil); err != nil {\n\t\treturn nil, datasources.ErrDataSourceAccessDenied\n\t}\n\n\tinstanceSettings, err := adapters.ModelToInstanceSettings(ds, s.decryptSecureJsonDataFn(ctx))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq := &backend.QueryDataRequest{\n\t\tPluginContext: backend.PluginContext{\n\t\t\tOrgID:                      ds.OrgId,\n\t\t\tPluginID:                   ds.Type,\n\t\t\tUser:                       adapters.BackendUserFromSignedInUser(user),\n\t\t\tDataSourceInstanceSettings: instanceSettings,\n\t\t},\n\t\tHeaders: map[string]string{},\n\t\tQueries: []backend.DataQuery{},\n\t}\n\n\tmiddlewares := []httpclient.Middleware{}\n\tif parsedReq.httpRequest != nil {\n\t\tmiddlewares = append(middlewares,\n\t\t\thttpclientprovider.ForwardedCookiesMiddleware(parsedReq.httpRequest.Cookies(), ds.AllowedCookies(), []string{s.cfg.LoginCookieName}),\n\t\t)\n\t}\n\n\tif s.oAuthTokenService.IsOAuthPassThruEnabled(ds) {\n\t\tif token := s.oAuthTokenService.GetCurrentOAuthToken(ctx, user); token != nil {\n\t\t\treq.Headers[\"Authorization\"] = fmt.Sprintf(\"%s %s\", token.Type(), token.AccessToken)\n\n\t\t\tidToken, ok := token.Extra(\"id_token\").(string)\n\t\t\tif ok && idToken != \"\" {\n\t\t\t\treq.Headers[\"X-ID-Token\"] = idToken\n\t\t\t}\n\t\t\tmiddlewares = append(middlewares, httpclientprovider.ForwardedOAuthIdentityMiddleware(token))\n\t\t}\n\t}\n\n\tif parsedReq.httpRequest != nil {\n\t\tproxyutil.ClearCookieHeader(parsedReq.httpRequest, ds.AllowedCookies(), []string{s.cfg.LoginCookieName})\n\t\tif cookieStr := parsedReq.httpRequest.Header.Get(\"Cookie\"); cookieStr != \"\" {\n\t\t\treq.Headers[\"Cookie\"] = cookieStr\n\t\t}\n\t}\n\n\tfor _, q := range parsedReq.parsedQueries {\n\t\treq.Queries = append(req.Queries, q.query)\n\t}\n\n\tctx = httpclient.WithContextualMiddleware(ctx, middlewares...)\n\n\treturn s.pluginClient.QueryData(ctx, req)\n}\n\ntype parsedQuery struct {\n\tdatasource *datasources.DataSource\n\tquery      backend.DataQuery\n}\n\ntype parsedRequest struct {\n\thasExpression bool\n\tparsedQueries []parsedQuery\n\thttpRequest   *http.Request\n}\n\nfunc (s *Service) parseMetricRequest(ctx context.Context, user *models.SignedInUser, skipCache bool, reqDTO dtos.MetricRequest) (*parsedRequest, error) {\n\tif len(reqDTO.Queries) == 0 {\n\t\treturn nil, NewErrBadQuery(\"no queries found\")\n\t}\n\n\ttimeRange := legacydata.NewDataTimeRange(reqDTO.From, reqDTO.To)\n\treq := &parsedRequest{\n\t\thasExpression: false,\n\t\tparsedQueries: []parsedQuery{},\n\t}\n\n\t// Parse the queries\n\tdatasourcesByUid := map[string]*datasources.DataSource{}\n\tfor _, query := range reqDTO.Queries {\n\t\tds, err := s.getDataSourceFromQuery(ctx, user, skipCache, query, datasourcesByUid)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif ds == nil {\n\t\t\treturn nil, NewErrBadQuery(\"invalid data source ID\")\n\t\t}\n\n\t\tdatasourcesByUid[ds.Uid] = ds\n\t\tif expr.IsDataSource(ds.Uid) {\n\t\t\treq.hasExpression = true\n\t\t}\n\n\t\ts.log.Debug(\"Processing metrics query\", \"query\", query)\n\n\t\tmodelJSON, err := query.MarshalJSON()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treq.parsedQueries = append(req.parsedQueries, parsedQuery{\n\t\t\tdatasource: ds,\n\t\t\tquery: backend.DataQuery{\n\t\t\t\tTimeRange: backend.TimeRange{\n\t\t\t\t\tFrom: timeRange.GetFromAsTimeUTC(),\n\t\t\t\t\tTo:   timeRange.GetToAsTimeUTC(),\n\t\t\t\t},\n\t\t\t\tRefID:         query.Get(\"refId\").MustString(\"A\"),\n\t\t\t\tMaxDataPoints: query.Get(\"maxDataPoints\").MustInt64(100),\n\t\t\t\tInterval:      time.Duration(query.Get(\"intervalMs\").MustInt64(1000)) * time.Millisecond,\n\t\t\t\tQueryType:     query.Get(\"queryType\").MustString(\"\"),\n\t\t\t\tJSON:          modelJSON,\n\t\t\t},\n\t\t})\n\t}\n\n\tif !req.hasExpression {\n\t\tif len(datasourcesByUid) > 1 {\n\t\t\t// We do not (yet) support mixed query type\n\t\t\treturn nil, NewErrBadQuery(\"all queries must use the same datasource\")\n\t\t}\n\t}\n\n\tif reqDTO.HTTPRequest != nil {\n\t\treq.httpRequest = reqDTO.HTTPRequest\n\t}\n\n\treturn req, nil\n}\n\nfunc (s *Service) getDataSourceFromQuery(ctx context.Context, user *models.SignedInUser, skipCache bool, query *simplejson.Json, history map[string]*datasources.DataSource) (*datasources.DataSource, error) {\n\tvar err error\n\tuid := query.Get(\"datasource\").Get(\"uid\").MustString()\n\n\t// before 8.3 special types could be sent as datasource (expr)\n\tif uid == \"\" {\n\t\tuid = query.Get(\"datasource\").MustString()\n\t}\n\n\t// check cache value\n\tds, ok := history[uid]\n\tif ok {\n\t\treturn ds, nil\n\t}\n\n\tif expr.IsDataSource(uid) {\n\t\treturn expr.DataSourceModel(), nil\n\t}\n\n\tif uid == grafanads.DatasourceUID {\n\t\treturn grafanads.DataSourceModel(user.OrgId), nil\n\t}\n\n\t// use datasourceId if it exists\n\tid := query.Get(\"datasourceId\").MustInt64(0)\n\tif id > 0 {\n\t\tds, err = s.dataSourceCache.GetDatasource(ctx, id, user, skipCache)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn ds, nil\n\t}\n\n\tif uid != \"\" {\n\t\tds, err = s.dataSourceCache.GetDatasourceByUID(ctx, uid, user, skipCache)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn ds, nil\n\t}\n\n\treturn nil, NewErrBadQuery(\"missing data source ID/UID\")\n}\n\nfunc (s *Service) decryptSecureJsonDataFn(ctx context.Context) func(ds *datasources.DataSource) (map[string]string, error) {\n\treturn func(ds *datasources.DataSource) (map[string]string, error) {\n\t\treturn s.dataSourceService.DecryptedValues(ctx, ds)\n\t}\n}\n", "package query_test\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/grafana/grafana-plugin-sdk-go/backend\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/stretchr/testify/require\"\n\t\"golang.org/x/oauth2\"\n\n\t\"github.com/grafana/grafana/pkg/api/dtos\"\n\t\"github.com/grafana/grafana/pkg/components/simplejson\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/plugins\"\n\tacmock \"github.com/grafana/grafana/pkg/services/accesscontrol/mock\"\n\t\"github.com/grafana/grafana/pkg/services/datasources\"\n\tdsSvc \"github.com/grafana/grafana/pkg/services/datasources/service\"\n\t\"github.com/grafana/grafana/pkg/services/featuremgmt\"\n\t\"github.com/grafana/grafana/pkg/services/query\"\n\t\"github.com/grafana/grafana/pkg/services/secrets/fakes\"\n\t\"github.com/grafana/grafana/pkg/services/secrets/kvstore\"\n\tsecretsManager \"github.com/grafana/grafana/pkg/services/secrets/manager\"\n)\n\nfunc TestQueryData(t *testing.T) {\n\tt.Run(\"it auth custom headers to the request\", func(t *testing.T) {\n\t\ttoken := &oauth2.Token{\n\t\t\tTokenType:   \"bearer\",\n\t\t\tAccessToken: \"access-token\",\n\t\t}\n\t\ttoken = token.WithExtra(map[string]interface{}{\"id_token\": \"id-token\"})\n\n\t\ttc := setup(t)\n\t\ttc.oauthTokenService.passThruEnabled = true\n\t\ttc.oauthTokenService.token = token\n\n\t\t_, err := tc.queryService.QueryData(context.Background(), nil, true, metricRequest(), false)\n\t\trequire.Nil(t, err)\n\n\t\texpected := map[string]string{\n\t\t\t\"Authorization\": \"Bearer access-token\",\n\t\t\t\"X-ID-Token\":    \"id-token\",\n\t\t}\n\t\trequire.Equal(t, expected, tc.pluginContext.req.Headers)\n\t})\n\n\tt.Run(\"it doesn't add cookie header to the request when keepCookies configured and no cookies provided\", func(t *testing.T) {\n\t\ttc := setup(t)\n\t\tjson, err := simplejson.NewJson([]byte(`{\"keepCookies\": [ \"foo\", \"bar\" ]}`))\n\t\trequire.NoError(t, err)\n\t\ttc.dataSourceCache.ds.JsonData = json\n\n\t\tmetricReq := metricRequest()\n\t\thttpReq, err := http.NewRequest(http.MethodGet, \"/\", nil)\n\t\trequire.NoError(t, err)\n\t\tmetricReq.HTTPRequest = httpReq\n\t\t_, err = tc.queryService.QueryData(context.Background(), nil, true, metricReq, false)\n\t\trequire.NoError(t, err)\n\n\t\trequire.Empty(t, tc.pluginContext.req.Headers)\n\t})\n\n\tt.Run(\"it adds cookie header to the request when keepCookies configured and cookie provided\", func(t *testing.T) {\n\t\ttc := setup(t)\n\t\tjson, err := simplejson.NewJson([]byte(`{\"keepCookies\": [ \"foo\", \"bar\" ]}`))\n\t\trequire.NoError(t, err)\n\t\ttc.dataSourceCache.ds.JsonData = json\n\n\t\tmetricReq := metricRequest()\n\t\thttpReq, err := http.NewRequest(http.MethodGet, \"/\", nil)\n\t\trequire.NoError(t, err)\n\t\thttpReq.AddCookie(&http.Cookie{Name: \"a\"})\n\t\thttpReq.AddCookie(&http.Cookie{Name: \"bar\", Value: \"rab\"})\n\t\thttpReq.AddCookie(&http.Cookie{Name: \"b\"})\n\t\thttpReq.AddCookie(&http.Cookie{Name: \"foo\", Value: \"oof\"})\n\t\thttpReq.AddCookie(&http.Cookie{Name: \"c\"})\n\t\tmetricReq.HTTPRequest = httpReq\n\t\t_, err = tc.queryService.QueryData(context.Background(), nil, true, metricReq, false)\n\t\trequire.NoError(t, err)\n\n\t\trequire.Equal(t, map[string]string{\"Cookie\": \"bar=rab; foo=oof\"}, tc.pluginContext.req.Headers)\n\t})\n}\n\nfunc setup(t *testing.T) *testContext {\n\tpc := &fakePluginClient{}\n\tdc := &fakeDataSourceCache{ds: &datasources.DataSource{}}\n\ttc := &fakeOAuthTokenService{}\n\trv := &fakePluginRequestValidator{}\n\n\tss := kvstore.SetupTestService(t)\n\tssvc := secretsManager.SetupTestService(t, fakes.NewFakeSecretsStore())\n\tds := dsSvc.ProvideService(nil, ssvc, ss, nil, featuremgmt.WithFeatures(), acmock.New(), acmock.NewMockedPermissionsService())\n\n\treturn &testContext{\n\t\tpluginContext:          pc,\n\t\tsecretStore:            ss,\n\t\tdataSourceCache:        dc,\n\t\toauthTokenService:      tc,\n\t\tpluginRequestValidator: rv,\n\t\tqueryService:           query.ProvideService(setting.NewCfg(), dc, nil, rv, ds, pc, tc),\n\t}\n}\n\ntype testContext struct {\n\tpluginContext          *fakePluginClient\n\tsecretStore            kvstore.SecretsKVStore\n\tdataSourceCache        *fakeDataSourceCache\n\toauthTokenService      *fakeOAuthTokenService\n\tpluginRequestValidator *fakePluginRequestValidator\n\tqueryService           *query.Service\n}\n\nfunc metricRequest() dtos.MetricRequest {\n\tq, _ := simplejson.NewJson([]byte(`{\"datasourceId\":1}`))\n\treturn dtos.MetricRequest{\n\t\tFrom:    \"\",\n\t\tTo:      \"\",\n\t\tQueries: []*simplejson.Json{q},\n\t\tDebug:   false,\n\t}\n}\n\ntype fakePluginRequestValidator struct {\n\terr error\n}\n\nfunc (rv *fakePluginRequestValidator) Validate(dsURL string, req *http.Request) error {\n\treturn rv.err\n}\n\ntype fakeOAuthTokenService struct {\n\tpassThruEnabled bool\n\ttoken           *oauth2.Token\n}\n\nfunc (ts *fakeOAuthTokenService) GetCurrentOAuthToken(context.Context, *models.SignedInUser) *oauth2.Token {\n\treturn ts.token\n}\n\nfunc (ts *fakeOAuthTokenService) IsOAuthPassThruEnabled(*datasources.DataSource) bool {\n\treturn ts.passThruEnabled\n}\n\ntype fakeDataSourceCache struct {\n\tds *datasources.DataSource\n}\n\nfunc (c *fakeDataSourceCache) GetDatasource(ctx context.Context, datasourceID int64, user *models.SignedInUser, skipCache bool) (*datasources.DataSource, error) {\n\treturn c.ds, nil\n}\n\nfunc (c *fakeDataSourceCache) GetDatasourceByUID(ctx context.Context, datasourceUID string, user *models.SignedInUser, skipCache bool) (*datasources.DataSource, error) {\n\treturn c.ds, nil\n}\n\ntype fakePluginClient struct {\n\tplugins.Client\n\n\treq *backend.QueryDataRequest\n}\n\nfunc (c *fakePluginClient) QueryData(ctx context.Context, req *backend.QueryDataRequest) (*backend.QueryDataResponse, error) {\n\tc.req = req\n\treturn nil, nil\n}\n", "package proxyutil\n\nimport (\n\t\"net\"\n\t\"net/http\"\n\t\"sort\"\n)\n\n// PrepareProxyRequest prepares a request for being proxied.\n// Removes X-Forwarded-Host, X-Forwarded-Port, X-Forwarded-Proto headers.\n// Set X-Forwarded-For headers.\nfunc PrepareProxyRequest(req *http.Request) {\n\treq.Header.Del(\"X-Forwarded-Host\")\n\treq.Header.Del(\"X-Forwarded-Port\")\n\treq.Header.Del(\"X-Forwarded-Proto\")\n\n\tif req.RemoteAddr != \"\" {\n\t\tremoteAddr, _, err := net.SplitHostPort(req.RemoteAddr)\n\t\tif err != nil {\n\t\t\tremoteAddr = req.RemoteAddr\n\t\t}\n\t\tif req.Header.Get(\"X-Forwarded-For\") != \"\" {\n\t\t\treq.Header.Set(\"X-Forwarded-For\", req.Header.Get(\"X-Forwarded-For\")+\", \"+remoteAddr)\n\t\t} else {\n\t\t\treq.Header.Set(\"X-Forwarded-For\", remoteAddr)\n\t\t}\n\t}\n}\n\n// ClearCookieHeader clear cookie header, except for cookies specified to be kept (keepCookiesNames) if not in skipCookiesNames.\nfunc ClearCookieHeader(req *http.Request, keepCookiesNames []string, skipCookiesNames []string) {\n\tkeepCookies := map[string]*http.Cookie{}\n\tfor _, c := range req.Cookies() {\n\t\tfor _, v := range keepCookiesNames {\n\t\t\tif c.Name == v {\n\t\t\t\tkeepCookies[c.Name] = c\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, v := range skipCookiesNames {\n\t\tdelete(keepCookies, v)\n\t}\n\n\treq.Header.Del(\"Cookie\")\n\n\tsortedCookies := []string{}\n\tfor name := range keepCookies {\n\t\tsortedCookies = append(sortedCookies, name)\n\t}\n\tsort.Strings(sortedCookies)\n\n\tfor _, name := range sortedCookies {\n\t\tc := keepCookies[name]\n\t\treq.AddCookie(c)\n\t}\n}\n\n// SetProxyResponseHeaders sets proxy response headers.\n// Sets Content-Security-Policy: sandbox\nfunc SetProxyResponseHeaders(header http.Header) {\n\theader.Set(\"Content-Security-Policy\", \"sandbox\")\n}\n", "package proxyutil\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestPrepareProxyRequest(t *testing.T) {\n\tt.Run(\"Prepare proxy request should clear X-Forwarded headers\", func(t *testing.T) {\n\t\treq, err := http.NewRequest(http.MethodGet, \"/\", nil)\n\t\trequire.NoError(t, err)\n\t\treq.Header.Set(\"X-Forwarded-Host\", \"host\")\n\t\treq.Header.Set(\"X-Forwarded-Port\", \"123\")\n\t\treq.Header.Set(\"X-Forwarded-Proto\", \"http1\")\n\n\t\tPrepareProxyRequest(req)\n\t\trequire.NotContains(t, req.Header, \"X-Forwarded-Host\")\n\t\trequire.NotContains(t, req.Header, \"X-Forwarded-Port\")\n\t\trequire.NotContains(t, req.Header, \"X-Forwarded-Proto\")\n\t})\n\n\tt.Run(\"Prepare proxy request should set X-Forwarded-For\", func(t *testing.T) {\n\t\treq, err := http.NewRequest(http.MethodGet, \"/\", nil)\n\t\treq.RemoteAddr = \"127.0.0.1:1234\"\n\t\trequire.NoError(t, err)\n\n\t\tPrepareProxyRequest(req)\n\t\trequire.Contains(t, req.Header, \"X-Forwarded-For\")\n\t\trequire.Equal(t, \"127.0.0.1\", req.Header.Get(\"X-Forwarded-For\"))\n\t})\n\n\tt.Run(\"Prepare proxy request should append client ip at the end of X-Forwarded-For\", func(t *testing.T) {\n\t\treq, err := http.NewRequest(http.MethodGet, \"/\", nil)\n\t\treq.RemoteAddr = \"127.0.0.1:1234\"\n\t\treq.Header.Set(\"X-Forwarded-For\", \"192.168.0.1\")\n\t\trequire.NoError(t, err)\n\n\t\tPrepareProxyRequest(req)\n\t\trequire.Contains(t, req.Header, \"X-Forwarded-For\")\n\t\trequire.Equal(t, \"192.168.0.1, 127.0.0.1\", req.Header.Get(\"X-Forwarded-For\"))\n\t})\n}\n\nfunc TestClearCookieHeader(t *testing.T) {\n\tt.Run(\"Clear cookie header should clear Cookie header\", func(t *testing.T) {\n\t\treq, err := http.NewRequest(http.MethodGet, \"/\", nil)\n\t\trequire.NoError(t, err)\n\t\treq.AddCookie(&http.Cookie{Name: \"cookie\"})\n\n\t\tClearCookieHeader(req, nil, nil)\n\t\trequire.NotContains(t, req.Header, \"Cookie\")\n\t})\n\n\tt.Run(\"Clear cookie header with cookies to keep should clear Cookie header and keep cookies\", func(t *testing.T) {\n\t\treq, err := http.NewRequest(http.MethodGet, \"/\", nil)\n\t\trequire.NoError(t, err)\n\t\treq.AddCookie(&http.Cookie{Name: \"cookie1\"})\n\t\treq.AddCookie(&http.Cookie{Name: \"cookie2\"})\n\t\treq.AddCookie(&http.Cookie{Name: \"cookie3\"})\n\n\t\tClearCookieHeader(req, []string{\"cookie1\", \"cookie3\"}, nil)\n\t\trequire.Contains(t, req.Header, \"Cookie\")\n\t\trequire.Equal(t, \"cookie1=; cookie3=\", req.Header.Get(\"Cookie\"))\n\t})\n\n\tt.Run(\"Clear cookie header with cookies to keep and skip should clear Cookie header and keep cookies\", func(t *testing.T) {\n\t\treq, err := http.NewRequest(http.MethodGet, \"/\", nil)\n\t\trequire.NoError(t, err)\n\t\treq.AddCookie(&http.Cookie{Name: \"cookie1\"})\n\t\treq.AddCookie(&http.Cookie{Name: \"cookie2\"})\n\t\treq.AddCookie(&http.Cookie{Name: \"cookie3\"})\n\n\t\tClearCookieHeader(req, []string{\"cookie1\", \"cookie3\"}, []string{\"cookie3\"})\n\t\trequire.Contains(t, req.Header, \"Cookie\")\n\t\trequire.Equal(t, \"cookie1=\", req.Header.Get(\"Cookie\"))\n\t})\n}\n"], "filenames": ["pkg/api/datasources.go", "pkg/api/metrics_test.go", "pkg/api/plugin_resource.go", "pkg/api/pluginproxy/ds_proxy.go", "pkg/infra/httpclient/httpclientprovider/forwarded_cookie_middleware_test.go", "pkg/infra/httpclient/httpclientprovider/forwarded_cookies_middleware.go", "pkg/services/query/query.go", "pkg/services/query/query_test.go", "pkg/util/proxyutil/proxyutil.go", "pkg/util/proxyutil/proxyutil_test.go"], "buggy_code_start_loc": [829, 17, 18, 226, 15, 14, 165, 8, 5, 52], "buggy_code_end_loc": [830, 121, 131, 227, 45, 21, 183, 103, 42, 66], "fixing_code_start_loc": [829, 18, 17, 226, 16, 14, 165, 9, 6, 52], "fixing_code_end_loc": [830, 122, 122, 227, 52, 21, 183, 104, 55, 79], "type": "NVD-CWE-noinfo", "message": "Grafana is an open source observability and data visualization platform. Starting with version 5.0.0-beta1 and prior to versions 8.5.14 and 9.1.8, Grafana could leak the authentication cookie of users to plugins. The vulnerability impacts data source and plugin proxy endpoints under certain conditions. The destination plugin could receive a user's Grafana authentication cookie. Versions 9.1.8 and 8.5.14 contain a patch for this issue. There are no known workarounds.", "other": {"cve": {"id": "CVE-2022-39201", "sourceIdentifier": "security-advisories@github.com", "published": "2022-10-13T23:15:10.850", "lastModified": "2022-10-19T14:08:30.377", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Grafana is an open source observability and data visualization platform. Starting with version 5.0.0-beta1 and prior to versions 8.5.14 and 9.1.8, Grafana could leak the authentication cookie of users to plugins. The vulnerability impacts data source and plugin proxy endpoints under certain conditions. The destination plugin could receive a user's Grafana authentication cookie. Versions 9.1.8 and 8.5.14 contain a patch for this issue. There are no known workarounds."}, {"lang": "es", "value": "Grafana es una plataforma de c\u00f3digo abierto de observabilidad y visualizaci\u00f3n de datos. A partir de la versi\u00f3n 5.0.0-beta1 y versiones anteriores a 8.5.14 y 9.1.8, Grafana pod\u00eda filtrar la cookie de autenticaci\u00f3n de usuarios a los plugins. La vulnerabilidad afecta a los endpoints de la fuente de datos y del proxy del plugin bajo determinadas condiciones. El plugin de destino podr\u00eda recibir la cookie de autenticaci\u00f3n de Grafana de un usuario. Las versiones 9.1.8 y 8.5.14 contienen un parche para este problema. No se presentan mitigaciones conocidas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.1", "versionEndExcluding": "8.5.14", "matchCriteriaId": "149266FC-7D6C-4AB9-851C-F63549510405"}, {"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:*:*:*:*:*:*:*:*", "versionStartIncluding": "9.0.0", "versionEndExcluding": "9.1.8", "matchCriteriaId": "E8E1ACC7-F43B-4395-A1FD-44CAEB43430D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:5.0.0:-:*:*:*:*:*:*", "matchCriteriaId": "7D0F0AF7-BCA9-4FF3-BD21-01E7A129A30E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:5.0.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "9109F31C-C109-48D0-A928-D5E61B6A9547"}, {"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:5.0.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "60242F49-9899-4B4A-BD2B-99EF2B7DD22F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:5.0.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "98551C43-BD4C-40CD-92C5-6A3005022CF5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:5.0.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "E76F5633-7F85-4162-BA13-6F1D887ECE83"}, {"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:5.0.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "FF03FBD9-5AA0-4171-9EC7-84BFBCBE48D4"}]}]}], "references": [{"url": "https://github.com/grafana/grafana/commit/b571acc1dc130a33f24742c1f93b93216da6cf57", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/grafana/grafana/commit/c658816f5229d17f877579250c07799d3bbaebc9", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/grafana/grafana/releases/tag/v9.1.8", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/grafana/grafana/security/advisories/GHSA-x744-mm8v-vpgr", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/grafana/grafana/commit/b571acc1dc130a33f24742c1f93b93216da6cf57"}}