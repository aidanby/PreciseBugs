{"buggy_code": ["# Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n# pylint: disable=unidiomatic-typecheck\n\"\"\"API for defining graph functions with some additional eager semantics.\n\ndef_function.function wraps the function concept in function.py (\"defun\") to\nallow initializing `tf.Variable`s with subgraphs of the function. For example:\n\n```python\nclass M(tf.Module):\n  def __init__(self):\n    self.v_opinit = None\n    self.v_arginit = None\n\n  @tf.function\n  def __call__(self, x):\n    # Variables are only created on the first call to the function. This is a\n    # common pattern in layer libraries.\n    if self.v_opinit is None:\n      # self.v_opinit will outlive the function call, but `tf.ones` is traced as\n      # part of the function body before the `tf.Variable` object is\n      # created. This subgraph is easy to lift out of the function.\n      self.v_opinit = tf.Variable(tf.ones([]))\n\n      # If arguments feed into variable initialization, it can be very tricky to\n      # disentangle from the rest of the function. We don't attempt it.\n      self.v_arginit = tf.Variable(tf.ones(tf.shape(x)) * tf.constant(2.))\n    return self.v_opinit + self.v_arginit + x\n```\n\nThese patterns with \"defun\" throw an error asking the user to put the variable's\ninitializer in a lambda. With tf.function they work with eager semantics either\nby lifting the subgraph out of the function and using it to initialize the\nvariable, or by initializing variables on the first call to the function (if\nthey weren't already initialized by something else, e.g. a checkpoint API). The\nlatter requires tf.conds, and is not well supported by TF-XLA, so we only do it\nwhen necessary.\n\nSince these patterns are relatively common in layer libraries, we expose the\nwrapper in this file as `tf.function`. The function concept in function.py is an\ninternal implementation detail.\n\nIn order to support these variable initialization patterns, tf.function defines\na variable subtype (UnliftedInitializerVariable) which collects the input\nsubgraph. This type of variable replaces the regular variable type on the first\ntf.function trace. To exclude initializers from the function body (the `tf.ones`\nops above and associated assignment operations), tf.function traces a second\ntime if it sees variables on the first call.\n\"\"\"\n\nimport functools\nimport threading\nimport types as types_lib\nimport weakref\nimport six\n\nfrom google.protobuf import text_format as _text_format\nfrom google.protobuf.message import DecodeError\nfrom tensorflow.core.framework import attr_value_pb2\nfrom tensorflow.python.distribute.parallel_device import parallel_device\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.eager import function as function_lib\nfrom tensorflow.python.eager import lift_to_graph\nfrom tensorflow.python.eager import monitoring\nfrom tensorflow.python.framework import composite_tensor\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import func_graph as func_graph_module\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import control_flow_ops\nfrom tensorflow.python.ops import control_flow_util\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import random_ops\nfrom tensorflow.python.ops import resource_variable_ops\nfrom tensorflow.python.platform import tf_logging as logging\nfrom tensorflow.python.profiler import trace\nfrom tensorflow.python.training.tracking import base as trackable\nfrom tensorflow.python.types import core\nfrom tensorflow.python.util import deprecation\nfrom tensorflow.python.util import nest\nfrom tensorflow.python.util import object_identity\nfrom tensorflow.python.util import tf_decorator\nfrom tensorflow.python.util import traceback_utils\nfrom tensorflow.python.util.tf_export import tf_export\n\nFREQUENT_TRACING_WARNING_MAX_CALL_HISTORY = 10\nFREQUENT_TRACING_WARNING_THRESHOLD = 5\nFREQUENT_TRACING_WARNING_MAX_WARNING_PER_DETECTOR = 2\nALLOW_DYNAMIC_VARIABLE_CREATION = False\n\n_tf_function_counter = monitoring.Counter(\n    \"/tensorflow/core/tf_function_counter\",\n    \"Counter for the number of tf.functions created when Eager execution is \"\n    \"enabled.\",\n    # jit_compile is \"0\" or \"1\".\n    \"jit_compile\")\n\n\nclass _FrequentTracingDetector(object):\n  \"\"\"Class keeping track of how many recent calls triggered tracing.\"\"\"\n\n  __slots__ = [\"_calls_per_tracings\", \"_call_count\", \"_total_warning_count\"]\n\n  def __init__(self):\n    self._calls_per_tracings = []\n    self._total_warning_count = 0\n    self._call_count = 0\n\n  def called_with_tracing(self, function_name, omit_warning):\n    \"\"\"Updates the list of most recent calls' tracing information.\n\n    Warns the user when recent calls caused retracing too often.\n\n    Args:\n      function_name: the python function being traced.\n      omit_warning: If 'True', this call will not warn the user even if\n        retracing happens too often.\n    \"\"\"\n    self._call_count += 1\n    self._calls_per_tracings.append(1)\n\n    while self._calls_per_tracings:\n      if (self._call_count - self._calls_per_tracings[0] >\n          FREQUENT_TRACING_WARNING_MAX_CALL_HISTORY):\n        self._call_count -= self._calls_per_tracings.pop(0)\n      else:\n        break\n\n    if (omit_warning or self._total_warning_count >=\n        FREQUENT_TRACING_WARNING_MAX_WARNING_PER_DETECTOR):\n      return\n    if len(self._calls_per_tracings) >= FREQUENT_TRACING_WARNING_THRESHOLD:\n      self._total_warning_count += 1\n      logging.warning(\n          \"{} out of the last {} calls to {} triggered tf.function \"\n          \"retracing. Tracing is expensive and the excessive number of \"\n          \"tracings could be due to (1) creating @tf.function repeatedly in \"\n          \"a loop, (2) passing tensors with different shapes, (3) passing \"\n          \"Python objects instead of tensors. For (1), please define your \"\n          \"@tf.function outside of the loop. For (2), @tf.function has \"\n          \"experimental_relax_shapes=True option that relaxes argument \"\n          \"shapes that can avoid unnecessary retracing. For (3), please \"\n          \"refer to \"\n          \"https://www.tensorflow.org/guide/function#controlling_retracing\"\n          \" and https://www.tensorflow.org/api_docs/python/tf/function for \"\n          \" more details.\".format(\n              len(self._calls_per_tracings), self._call_count, function_name))\n\n  def called_without_tracing(self):\n    # We don't count tracing when users load a concrete function directly or\n    # call get_concrete_function, so the first call can be not a tracing call.\n    if not self._calls_per_tracings:\n      self._calls_per_tracings = [0]\n    self._calls_per_tracings[-1] += 1\n    self._call_count += 1\n\n\nclass _FrequentTracingDetectorManager(object):\n  \"\"\"Class for the management of all _FrequentTracingDetector objects.\"\"\"\n\n  __slots__ = [\"_detectors\", \"_lock\"]\n\n  def __init__(self):\n    self._detectors = weakref.WeakKeyDictionary()  # GUARDED_BY(self._lock)\n    self._lock = threading.Lock()\n\n  def _get_detector(self, key):\n    if key not in self._detectors:\n      self._detectors[key] = _FrequentTracingDetector()\n    return self._detectors[key]\n\n  def called_without_tracing(self, key):\n    with self._lock:\n      detector = self._get_detector(key)\n      detector.called_without_tracing()\n\n  def called_with_tracing(self, key, function_name, omit_warning):\n    with self._lock:\n      detector = self._get_detector(key)\n      detector.called_with_tracing(function_name, omit_warning)\n\n\n_frequent_tracing_detector_manager = _FrequentTracingDetectorManager()\n\n\nclass UnliftedInitializerVariable(resource_variable_ops.UninitializedVariable):\n  \"\"\"Variable which does not lift its initializer out of function context.\n\n  Instances of this variable, when created, build a graph which runs their\n  initializer inside a tf.cond(is_initialized) block.\n\n  This can only be created inside a defun called from (eventually) eager\n  mode. That is, non-function-building graphs are not supported.\n  \"\"\"\n\n  def __init__(self,\n               initial_value=None,\n               trainable=None,\n               caching_device=None,\n               name=None,\n               dtype=None,\n               constraint=None,\n               add_initializers_to=None,\n               lifted_initializer_graph=None,\n               synchronization=None,\n               aggregation=None,\n               shape=None,\n               **unused_kwargs):\n    \"\"\"Creates a variable.\n\n    Args:\n      initial_value: A `Tensor`, or Python object convertible to a `Tensor`,\n        which is the initial value for the Variable. The initial value must have\n        a shape specified unless `validate_shape` is set to False. Can also be a\n        callable with no argument that returns the initial value when called.\n        (Note that initializer functions from init_ops.py must first be bound\n         to a shape before being used here.)\n      trainable: If `True`, GradientTapes automatically watch uses of this\n        Variable.\n      caching_device: Optional device string or function describing where the\n        Variable should be cached for reading.  Defaults to the Variable's\n        device.  If not `None`, caches on another device.  Typical use is to\n        cache on the device where the Ops using the Variable reside, to\n        deduplicate copying through `Switch` and other conditional statements.\n      name: Optional name for the variable. Defaults to `'Variable'` and gets\n        uniquified automatically.\n      dtype: If set, initial_value will be converted to the given type.\n        If None, either the datatype will be kept (if initial_value is\n       a Tensor) or float32 will be used (if it is a Python object convertible\n       to a Tensor).\n      constraint: An optional projection function to be applied to the variable\n        after being updated by an `Optimizer` (e.g. used to implement norm\n        constraints or value constraints for layer weights). The function must\n        take as input the unprojected Tensor representing the value of the\n        variable and return the Tensor for the projected value\n        (which must have the same shape). Constraints are not safe to\n        use when doing asynchronous distributed training.\n      add_initializers_to: if not None and not in legacy graph mode, the\n        initializer tensor will be added to this map in addition to adding the\n        assignment to the function.\n      lifted_initializer_graph: FuncGraph to try to lift initializers to.\n      synchronization: Indicates when a distributed a variable will be\n        aggregated. Accepted values are constants defined in the class\n        `tf.VariableSynchronization`. By default the synchronization is set to\n        `AUTO` and the current `DistributionStrategy` chooses\n        when to synchronize.\n      aggregation: Indicates how a distributed variable will be aggregated.\n        Accepted values are constants defined in the class\n        `tf.VariableAggregation`.\n      shape: (optional) The shape of this variable. If None, the shape of\n        `initial_value` will be used. When setting this argument to\n        `tf.TensorShape(None)` (representing an unspecified shape), the variable\n        can be assigned with values of different shapes.\n\n    Raises:\n      ValueError: If the initial value is not specified, or does not have a\n        shape and `validate_shape` is `True`.\n      RuntimeError: If called outside of a function definition.\n    \"\"\"\n    with ops.init_scope():\n      self._in_graph_mode = not context.executing_eagerly()\n    if not ops.inside_function():\n      # If we've been init_scope()d out of the function definition nothing to do\n      # here; we can't really do the capturing or conditional logic.\n      resource_variable_ops.ResourceVariable.__init__(\n          self, initial_value=initial_value, trainable=trainable,\n          caching_device=caching_device, name=name, dtype=dtype,\n          constraint=constraint)\n      return\n    if initial_value is None:\n      raise ValueError(\"`initial_value` must be a Tensor or a Python \"\n                       \"object convertible to a Tensor. Got None.\")\n    init_from_fn = callable(initial_value)\n\n    if constraint is not None and not callable(constraint):\n      raise ValueError(f\"`constraint` with type {type(constraint)} must be a \"\n                       \"callable.\")\n\n    with ops.name_scope(name, \"Variable\", []\n                        if init_from_fn else [initial_value]) as scope_name:\n      with ops.name_scope(\"Initializer\"):\n        if init_from_fn:\n          initial_value = initial_value()\n        if isinstance(initial_value, trackable.CheckpointInitialValue):\n          self._maybe_initialize_trackable()\n          self._update_uid = initial_value.checkpoint_position.restore_uid\n          initial_value = initial_value.wrapped_value\n\n        initial_value = ops.convert_to_tensor(initial_value,\n                                              name=\"initial_value\", dtype=dtype)\n      assert initial_value is not None\n\n      # Don't use `shape or initial_value.shape` since TensorShape has\n      # overridden `__bool__`.\n      if shape is None:\n        shape = initial_value.shape\n\n    # Use the constructor for UninitializedVariable to start. Outside the name\n    # scope so we don't double up the prefix.\n    super(UnliftedInitializerVariable, self).__init__(\n        trainable=trainable,\n        caching_device=caching_device,\n        name=name,\n        shape=shape,\n        dtype=initial_value.dtype,\n        constraint=constraint,\n        synchronization=synchronization,\n        aggregation=aggregation,\n        extra_handle_data=initial_value,\n        **unused_kwargs)\n\n    with ops.name_scope(scope_name):\n      if self._in_graph_mode:\n        with ops.init_scope():\n          outer_graph = ops.get_default_graph()\n        func_graph = ops.get_default_graph()\n        function_placeholders = (\n            func_graph.inputs + func_graph.internal_captures)\n        placeholder_ops = set(\n            [tensor.op for tensor in function_placeholders])\n        lifted_initializer = lift_to_graph.lift_to_graph(\n            [initial_value], outer_graph,\n            disallowed_placeholders=placeholder_ops)[initial_value]\n        with ops.init_scope():\n          self._initial_value = lifted_initializer\n          with ops.name_scope(\"IsInitialized\"):\n            self._is_initialized_op = (\n                resource_variable_ops.var_is_initialized_op(self._handle))\n          if initial_value is not None:\n            with ops.name_scope(\"Assign\") as n, ops.colocate_with(self._handle):\n              self._initializer_op = resource_variable_ops.assign_variable_op(\n                  self._handle, lifted_initializer, name=n)\n      elif context.executing_eagerly():\n        # In this case, both current scope and init scope are eager.\n        # Assign_variable_op will be executed immediately. So we don't need to\n        # add it to \"add_initializers_to\" to lift it out.\n        with ops.name_scope(\"Assign\") as n, ops.colocate_with(self._handle):\n          resource_variable_ops.assign_variable_op(\n              self._handle, initial_value, name=n)\n      else:\n        # Init scope is eager but current scope is graph. We will lift out this\n        # variable by addint it into \"add_initializers_to\".\n        if add_initializers_to is not None:\n          add_initializers_to.append((self, initial_value))\n\n        def assign_fn():\n          with ops.name_scope(\"Assign\") as n, ops.colocate_with(self._handle):\n            resource_variable_ops.assign_variable_op(\n                self._handle,\n                initial_value,\n                name=n)\n            # Returning values to keep tf.cond happy.\n          return ops.convert_to_tensor(1)\n        def not_assign_fn():\n          return ops.convert_to_tensor(0)\n        # Note: this cond is always guaranteed to run because we're inside a\n        # defun which will insert automatic control dependencies. It will only\n        # execute assign_fn if lifting failed.\n        graph = ops.get_default_graph()\n\n        # Capture the handle ahead of time in order to avoid querying the shape\n        # of the handle which helps async execution performance\n        graph.capture(self._handle, shape=())\n        control_flow_ops.cond(\n            resource_variable_ops.var_is_initialized_op(self._handle),\n            not_assign_fn, assign_fn)\n\n\nRUN_FUNCTIONS_EAGERLY = False\n\n\n@deprecation.deprecated(\n    None,\n    \"Use `tf.config.run_functions_eagerly` instead of the experimental \"\n    \"version.\")\n@tf_export(\"config.experimental_run_functions_eagerly\")\ndef experimental_run_functions_eagerly(run_eagerly):\n  \"\"\"Enables / disables eager execution of `tf.function`s.\n\n  Calling `tf.config.experimental_run_functions_eagerly(True)` will make all\n  invocations of `tf.function` run eagerly instead of running as a traced graph\n  function.\n\n  See `tf.config.run_functions_eagerly` for an example.\n\n  Note: This flag has no effect on functions passed into tf.data transformations\n  as arguments. tf.data functions are never executed eagerly and are always\n  executed as a compiled Tensorflow Graph.\n\n  Args:\n    run_eagerly: Boolean. Whether to run functions eagerly.\n  \"\"\"\n  return run_functions_eagerly(run_eagerly)\n\n\n@tf_export(\"config.run_functions_eagerly\")\ndef run_functions_eagerly(run_eagerly):\n  \"\"\"Enables / disables eager execution of `tf.function`s.\n\n  Calling `tf.config.run_functions_eagerly(True)` will make all\n  invocations of `tf.function` run eagerly instead of running as a traced graph\n  function.\n\n  This can be useful for debugging.\n\n  >>> def my_func(a):\n  ...  print(\"Python side effect\")\n  ...  return a + a\n  >>> a_fn = tf.function(my_func)\n\n  >>> # A side effect the first time the function is traced\n  >>> a_fn(tf.constant(1))\n  Python side effect\n  <tf.Tensor: shape=(), dtype=int32, numpy=2>\n\n  >>> # No further side effect, as the traced function is called\n  >>> a_fn(tf.constant(2))\n  <tf.Tensor: shape=(), dtype=int32, numpy=4>\n\n  >>> # Now, switch to eager running\n  >>> tf.config.run_functions_eagerly(True)\n  >>> # Side effect, as the function is called directly\n  >>> a_fn(tf.constant(2))\n  Python side effect\n  <tf.Tensor: shape=(), dtype=int32, numpy=4>\n\n  >>> # Turn this back off\n  >>> tf.config.run_functions_eagerly(False)\n\n  Note: This flag has no effect on functions passed into tf.data transformations\n  as arguments. tf.data functions are never executed eagerly and are always\n  executed as a compiled Tensorflow Graph.\n\n  Args:\n    run_eagerly: Boolean. Whether to run functions eagerly.\n  \"\"\"\n  global RUN_FUNCTIONS_EAGERLY\n  RUN_FUNCTIONS_EAGERLY = bool(run_eagerly)\n\n\n@deprecation.deprecated(\n    None,\n    \"Use tf.config.functions_run_eagerly instead of the experimental version.\")\n@tf_export(\"config.experimental_functions_run_eagerly\")\ndef experimental_functions_run_eagerly():\n  \"\"\"Returns the value of the `experimental_run_functions_eagerly` setting.\"\"\"\n  return functions_run_eagerly()\n\n\n@tf_export(\"config.functions_run_eagerly\")\ndef functions_run_eagerly():\n  \"\"\"Returns the value of the `run_functions_eagerly` setting.\"\"\"\n  return RUN_FUNCTIONS_EAGERLY\n\n\ndef _evaluate_var_is_initialized(variables):\n  \"\"\"Compute booleans indicating whether each variable is initialized.\"\"\"\n  with ops.init_scope():\n    var_is_initialized = []\n    for v in variables:\n      var_is_initialized.append(\n          resource_variable_ops.var_is_initialized_op(v.handle))\n    try:\n      # Stack all the var_is_initialized values into one tensor and interpret\n      # the numpy value. This will reduce the number of RPCs between client and\n      # worker in the remote case.\n      return array_ops.stack(var_is_initialized).numpy()\n    except errors.UnimplementedError:\n      # Some devices do not support implicit copy-off to host. Fall back to\n      # variable-by-variable processing.\n      for index, v in enumerate(variables):\n        try:\n          numpy_value = var_is_initialized[index].numpy()\n        except errors.UnimplementedError:\n          # This is a variable on a parallel device; we'll extract its value on\n          # each replica and assert that they're identical.\n          components = parallel_device.unpack(var_is_initialized[index])\n          with ops.device(None):\n            components = array_ops.stack(components)\n            all_initialized = math_ops.reduce_all(components).numpy()\n            any_initialized = math_ops.reduce_any(components).numpy()\n          if all_initialized != any_initialized:\n            raise NotImplementedError(\n                f\"Some but not all components of a parallel variable {v!r} \"\n                \"were initialized between their creation in a tf.function and \"\n                \"the function's trace having completed. This is not \"\n                \"supported; consider initializing either all or none of the \"\n                \"components, or moving initialization out of the function.\")\n          numpy_value = all_initialized\n        var_is_initialized[index] = numpy_value\n  return var_is_initialized\n\n\nclass FunctionDeleter(object):\n\n  __slots__ = [\"func_graph\"]\n\n  def __init__(self, func_graph):\n    self.func_graph = func_graph\n\n  def __del__(self):\n    try:\n      func_graph_module.dismantle_func_graph(self.func_graph)\n    except:  # pylint: disable=bare-except\n      # Note: bare except here because this can be noisy at shutdown time.\n      pass\n\n\nclass OptionalXlaContext(object):\n  \"\"\"Wrapper for XLA context optionally applied under a context manager.\"\"\"\n\n  def __init__(self, is_compiled):\n    wrap = is_compiled and not control_flow_util.GraphOrParentsInXlaContext( \\\n              ops.get_default_graph())\n    self.xla_context = control_flow_ops.XLAControlFlowContext() \\\n        if wrap else None\n\n  def __enter__(self):\n    if self.xla_context:\n      self.xla_context.Enter()\n\n  def __exit__(self, t, value, traceback):\n    if self.xla_context:\n      self.xla_context.Exit()\n\n\n# TODO(mdan): Consider expose this type for instance type checking.\n@tf_export(\"__internal__.function.Function\", v1=[])\nclass Function(core.GenericFunction):\n  \"\"\"A `tf.types.experimental.GenericFunction` created by `tf.function`.\n\n  Currently, individual methods/attributes under this class are not guaranteed\n  by the TF API contract, and are subject to future changes.\n  \"\"\"\n\n  def __init__(self,\n               python_function,\n               name,\n               input_signature=None,\n               autograph=True,\n               jit_compile=None,\n               experimental_implements=None,\n               experimental_autograph_options=None,\n               experimental_relax_shapes=False,\n               experimental_follow_type_hints=None):\n    \"\"\"Initializes a `Function`.\n\n    Args:\n      python_function: the function to be wrapped.\n      name: the name given to it.\n      input_signature: See the documentation for `tf.function`.\n      autograph: See the documentation for `tf.function`.\n      jit_compile: See the documentation for `tf.function`.\n      experimental_implements: See the documentation for `tf.function`.\n      experimental_autograph_options: See the documentation for `tf.function`.\n      experimental_relax_shapes: See the documentation for `tf.function`.\n      experimental_follow_type_hints: See the documentation for `tf.function`.\n\n    Raises:\n      ValueError: if `input_signature` is not None and the `python_function`'s\n        argspec has keyword arguments.\n    \"\"\"\n    self._lock = threading.Lock()\n    self._python_function = python_function\n    self._function_spec = function_lib.FunctionSpec.from_function_and_signature(\n        python_function,\n        input_signature,\n        jit_compile=jit_compile,\n        experimental_follow_type_hints=experimental_follow_type_hints,\n    )\n    self._implements = experimental_implements\n    # If `True`, the function uses the rendezvous of the parent. This is only\n    # needed to support code where raw send/recv operations are inserted and\n    # when functions are run in graph mode where they may not be inlined.\n    self._shared_rendezvous = None\n    self._autograph = autograph\n    self._experimental_autograph_options = experimental_autograph_options\n    self._experimental_relax_shapes = experimental_relax_shapes\n    self._jit_compile = jit_compile\n    if experimental_follow_type_hints is None:\n      experimental_follow_type_hints = False\n    self._experimental_follow_type_hints = experimental_follow_type_hints\n    self._created_variables = None  # GUARDED_BY(self._lock)\n    self._stateful_fn = None  # GUARDED_BY(self._lock)\n    self._stateless_fn = None  # GUARDED_BY(self._lock)\n    self._descriptor_cache = weakref.WeakKeyDictionary()\n    self._name = name\n    self._input_signature = input_signature\n    self._key_for_call_stats = self._get_key_for_call_stats()\n    self._omit_frequent_tracing_warning = False\n    ops._tf_function_api_guage.get_cell().set(True)  # pylint: disable=protected-access\n\n  def __getstate__(self):\n    \"\"\"Custom pickling, to omit unpickleable objects.\"\"\"\n    result = self.__dict__.copy()\n    del result[\"_lock\"]\n    del result[\"_descriptor_cache\"]\n    del result[\"_key_for_call_stats\"]\n    return result\n\n  def __setstate__(self, state):\n    \"\"\"Restore from pickled state.\"\"\"\n    self.__dict__ = state\n    self._lock = threading.Lock()\n    self._descriptor_cache = weakref.WeakKeyDictionary()\n    self._key_for_call_stats = self._get_key_for_call_stats()\n\n  def _get_key_for_call_stats(self):\n    \"\"\"Returns key instance to track call stats and retracings.\n\n    The key instance a best-effort to preserve global consistency.\n    \"\"\"\n    target_function = self._python_function\n    # `__wrapped__` is a conventional Python attribute that a higher-order\n    # function keeps its original function's instance.  We also directly use\n    # this attribute for dealing with a class method.  See\n    # `bound_method_wrapper` in `function.py`.  If we don't use `__wrapped__`,\n    # all class methods will return the same `bound_method_wrapper` instance\n    # from this function.\n    while hasattr(target_function, \"__wrapped__\"):\n      target_function = target_function.__wrapped__\n\n    if hasattr(target_function, \"__func__\"):\n      target_function = target_function.__func__\n\n    if hasattr(target_function, \"__code__\"):\n      return target_function.__code__\n\n    return self._python_function\n\n  def _defun_with_scope(self, scope):\n    \"\"\"Creates a defun wrapped inside a variable creator scope.\"\"\"\n\n    weak_wrapped_fn = None\n    compile_with_xla = self._jit_compile\n\n    def wrapped_fn(*args, **kwds):\n      \"\"\"Wraps `self._python_function` in a variable creator scope.\"\"\"\n      # We register a variable creator with reduced priority. If an outer\n      # variable creator is just modifying keyword arguments to the variable\n      # constructor, this will work harmoniously. Since the `scope` registered\n      # here actually creates the variable, it taking priority would otherwise\n      # ignore the outer creator.\n      #\n      # If an outer variable creator calls the variable constructor manually,\n      # for example creating a MirroredVariable, then they won't call our\n      # creator. This means we won't be able to trace the initialization graph,\n      # and so variable initializers can't depend on function arguments. This is\n      # better than the alternative, tracing the initialization graph but giving\n      # the user a variable type they didn't want.\n      default_graph = ops.get_default_graph()\n      with default_graph._variable_creator_scope(scope, priority=50):  # pylint: disable=protected-access\n        # __wrapped__ allows AutoGraph to swap in a converted function. We give\n        # the function a weak reference to itself to avoid a reference cycle.\n        with OptionalXlaContext(compile_with_xla):\n          out = weak_wrapped_fn().__wrapped__(*args, **kwds)\n        return out\n\n    weak_wrapped_fn = weakref.ref(wrapped_fn)\n\n    return self._defun(tf_decorator.make_decorator(\n        self._python_function,\n        wrapped_fn))\n\n  def _create_implements_attribute(self):\n    \"\"\"Creates the attribute value corresponding to IMPLEMENTS_ATTRIBUTE_NAME.\"\"\"\n    attributes = {}\n    if isinstance(self._implements, str):\n      # First check if the IMPLEMENTS_ATTRIBUTE_NAME is specified as a\n      # NameAttrList. This is used when apart from the function name being\n      # implemented, a list of attributes is also being specified.\n      # The attributes are specified as key-value pairs in the NameAttrList\n      # of the corresponding AttrValue. The function name will be in the\n      # 'name' field of the NameAttrList. Else, it is just a string\n      # corresponding to the function name.\n      try:\n        implements_attr = six.ensure_text(self._implements, \"utf-8\")\n        attr_value = attr_value_pb2.AttrValue()\n        nameattrlist = attr_value_pb2.NameAttrList()\n        _text_format.Merge(implements_attr, nameattrlist)\n        attr_value.func.CopyFrom(nameattrlist)\n        attributes[function_lib.IMPLEMENTS_ATTRIBUTE_NAME] = attr_value\n      except (_text_format.ParseError, DecodeError):\n        attributes[function_lib.IMPLEMENTS_ATTRIBUTE_NAME] = self._implements\n    return attributes\n\n  def _defun(self, fn):\n    \"\"\"Returns a defun generated from the input function.\"\"\"\n    attributes = {}\n\n    if self._implements is not None:\n      attributes = self._create_implements_attribute()\n\n    share = self._shared_rendezvous\n    if share is not None:\n      attributes[function_lib.SHARED_RENDEZVOUS_ATTRIBUTE_NAME] = share\n\n    if self._jit_compile is not None:\n      attributes.update(_XlaMustCompile=bool(self._jit_compile))\n      if self._jit_compile:\n        attributes.update(_noinline=True)\n    if not attributes:\n      attributes = None\n    return function_lib.defun_with_attributes(\n        fn,\n        input_signature=self.input_signature,\n        attributes=attributes,\n        autograph=self._autograph,\n        jit_compile=self._jit_compile,\n        experimental_autograph_options=self._experimental_autograph_options,\n        experimental_follow_type_hints=self._experimental_follow_type_hints,\n        experimental_relax_shapes=self._experimental_relax_shapes)\n\n  def _initialize(self, args, kwds, add_initializers_to=None):\n    \"\"\"Initializes, on the first call.\n\n    Creates two `Function`s, one that will allow creation of variables\n    and one that won't.\n\n    Additionally runs a trace for the `Function` that allows creation\n    of variables.\n\n    Args:\n      args: Arguments to the underlying python callable.\n      kwds: Keyword arguments to the python callable.\n      add_initializers_to: Where to collect variable initializers, if not None.\n    \"\"\"\n\n    if self._input_signature is not None:\n      arglen = len(self._input_signature)\n      arg_names_len = len(self.function_spec.arg_names)\n      default_arg_len = len(self.function_spec.fullargspec.defaults or ())\n      required_arg_len = arg_names_len - default_arg_len\n      # The input signature must cover all required function arguments.\n      if arglen < required_arg_len:\n        missing_tensor_specs = self.function_spec.arg_names[\n            arglen:required_arg_len]\n        raise TypeError(\n            f\"The decorated function {self._name} has {required_arg_len} \"\n            f\"required argument(s), but tf.function was only passed an \"\n            f\"input_signature of length {arglen}. This covers {arglen} \"\n            f\"required argument(s): {self.function_spec.arg_names[:arglen]}, \"\n            f\"but TensorSpecs are still required for the remaining \"\n            f\"{len(missing_tensor_specs)} argument(s): {missing_tensor_specs}.\")\n\n    created_variables = []\n    lifted_initializer_graph = func_graph_module.FuncGraph(\"initializer\")\n\n    def variable_capturing_scope(unused_next_creator, **kwds):\n      \"\"\"Creates UnliftedInitializerVariables and saves references to them.\"\"\"\n      v = UnliftedInitializerVariable(\n          add_initializers_to=add_initializers_to,\n          lifted_initializer_graph=lifted_initializer_graph, **kwds)\n      created_variables.append(weakref.ref(v))\n      return v\n\n    self._created_variables = created_variables\n    self._stateful_fn = self._defun_with_scope(variable_capturing_scope)\n    self._stateful_fn._name = self._name  # pylint: disable=protected-access\n    # Force the definition of the function for these arguments\n    self._lifted_initializer_graph = lifted_initializer_graph\n    self._graph_deleter = FunctionDeleter(self._lifted_initializer_graph)\n    self._concrete_stateful_fn = (\n        self._stateful_fn._get_concrete_function_internal_garbage_collected(  # pylint: disable=protected-access\n            *args, **kwds))\n\n    def invalid_creator_scope(*unused_args, **unused_kwds):\n      \"\"\"Disables variable creation.\"\"\"\n      raise ValueError(\n          \"tf.function only supports singleton tf.Variables created on the \"\n          \"first call. Make sure the tf.Variable is only created once or \"\n          \"created outside tf.function. See \"\n          \"https://www.tensorflow.org/guide/function#creating_tfvariables \"\n          \"for more information.\")\n\n    self._stateless_fn = self._defun_with_scope(invalid_creator_scope)\n    self._stateless_fn._name = self._name  # pylint: disable=protected-access\n\n  def _clone(self, python_function):\n    \"\"\"Clone the function with different python function.\"\"\"\n    f = Function(\n        python_function=(self._python_function\n                         if python_function is None else python_function),\n        name=self._name,\n        input_signature=self._input_signature,\n        autograph=self._autograph,\n        jit_compile=self._jit_compile,\n        experimental_implements=self._implements,\n        experimental_autograph_options=self._experimental_autograph_options,\n        experimental_relax_shapes=self._experimental_relax_shapes,\n        experimental_follow_type_hints=self._experimental_follow_type_hints)\n\n    if self._shared_rendezvous:\n      f._shared_rendezvous = self._shared_rendezvous  # pylint: disable=protected-access\n\n    return f\n\n  def _decorate(self, decorator):\n    \"\"\"Allows the captured Python function to be decorated in place.\n\n    This method is only safe to call when the Function has not been called by a\n    user. It makes sense to use this method to push a decorator into the\n    function rather than wrapping the function in the decorator.\n\n    We use this in tf.Module to allow user annotated `tf.functions` to remain as\n    `Function` objects but still automatically enter the Module name_scope\n    when they are evaluated like all other methods.\n\n    Args:\n      decorator: A callable accepting a single argument which is the function\n        to decorate and returning a callable result.\n\n    Raises:\n      ValueError: If the function has been called a ValueError is raised.\n    \"\"\"\n    if self._stateful_fn is not None or self._stateless_fn is not None:\n      raise ValueError(\n          \"Functions cannot be decorated after they have been traced.\")\n\n    self._python_function = decorator(self._python_function)\n    self._function_spec = function_lib.FunctionSpec.from_function_and_signature(\n        self._python_function, self.input_signature)\n\n  # TODO: Remove this private method after updating all its uses\n  # A good moment to do this could be when the experimental label is removed\n  def _get_tracing_count(self):\n    return self.experimental_get_tracing_count()\n\n  def experimental_get_tracing_count(self):\n    \"\"\"Returns the number of times the function has been traced.\n\n    For more information on when a function is traced and when it is\n    traced multiple times see https://www.tensorflow.org/guide/function.\n    Example:\n\n    >>> @tf.function\n    ... def double(a):\n    ...   return a + a\n    >>> double(tf.constant(1))\n    >>> double(tf.constant(2))\n    >>> double.experimental_get_tracing_count()\n    1\n    >>> double(tf.constant(\"a\"))\n    >>> double.experimental_get_tracing_count()\n    2\n\n\n    The first time experimental_get_tracing_count is called\n    it returns 1, as the function is traced the first\n    time it is called, and the second time the same graph is used\n    since we're calling it with a parameter of the same type.\n\n    The second time experimental_get_tracing_count is called\n    it returns 2, as we called double with a\n    different argument type, and so it was traced again.\n\n    \"\"\"\n    result = self._stateless_fn.tracing_count if self._stateless_fn else 0\n    result += self._stateful_fn.tracing_count if self._stateful_fn else 0\n    return result\n\n  @property\n  def _run_functions_eagerly(self):\n    return RUN_FUNCTIONS_EAGERLY\n\n  @traceback_utils.filter_traceback\n  def __call__(self, *args, **kwds):\n    # Implements GenericFunction.__call__.\n    if self._run_functions_eagerly:\n      with trace.Trace(self._name, tf_function_call=\"eager\"):\n        return self._python_function(*args, **kwds)\n\n    # Only count the statistics the first time, before initialization took\n    # place.\n    if self._created_variables is None:\n      compiled = bool(self._jit_compile and\n                      not control_flow_util.GraphOrParentsInXlaContext(\n                          ops.get_default_graph()))\n      # For nested functions, increment the counter only when a function with\n      # jit_compile=True is called within a function with jit_compile=False. We\n      # count this special case to correctly record that both jit_compile=True\n      # and jit_compile=False is being used for parts of the outer function.\n      if ops.executing_eagerly_outside_functions() and (\n          context.executing_eagerly() or compiled):\n        # Labels must be strings in Python, so we convert 'compiled' to a string\n        _tf_function_counter.get_cell(str(int(compiled))).increase_by(1)\n\n    tracing_count = self.experimental_get_tracing_count()\n    with trace.Trace(self._name) as tm:\n      # TODO(cheshire): Do not duplicate the XLAControlFlowContext annotation.\n      compiler = \"xla\" if self._jit_compile else \"nonXla\"\n\n      with OptionalXlaContext(self._jit_compile):\n        result = self._call(*args, **kwds)\n\n      new_tracing_count = self.experimental_get_tracing_count()\n      without_tracing = (tracing_count == new_tracing_count)\n      execution_mode = \"notTraced\" if without_tracing else \"traced\"\n      tm.set_metadata(tf_function_call=execution_mode + \"-\" + compiler,\n                      tracing_count=new_tracing_count)\n\n    if context.executing_eagerly():\n      if without_tracing:\n        _frequent_tracing_detector_manager.called_without_tracing(\n            self._key_for_call_stats)\n      else:\n        _frequent_tracing_detector_manager.called_with_tracing(\n            self._key_for_call_stats, self._python_function,\n            self._omit_frequent_tracing_warning)\n\n    return result\n\n  def _call(self, *args, **kwds):\n    \"\"\"Calls the graph function.\"\"\"\n    self._lock.acquire()\n    if ALLOW_DYNAMIC_VARIABLE_CREATION:\n      condition = self._created_variables and self._stateful_fn is None\n    else:\n      condition = self._created_variables\n    if condition:\n      # Release the lock early so that multiple threads can perform the call\n      # in parallel.\n      self._lock.release()\n      # In this case we have created variables on the first call, so we run the\n      # defunned version which is guaranteed to never create variables.\n      return self._stateless_fn(*args, **kwds)  # pylint: disable=not-callable\n    elif self._stateful_fn is not None:\n      # Release the lock early so that multiple threads can perform the call\n      # in parallel.\n      self._lock.release()\n      # In this case we have not created variables on the first call. So we can\n      # run the first trace but we should fail if variables are created.\n      results = self._stateful_fn(*args, **kwds)\n      if self._created_variables and not ALLOW_DYNAMIC_VARIABLE_CREATION:\n        raise ValueError(\"Creating variables on a non-first call to a function\"\n                         \" decorated with tf.function.\")\n      return results\n\n    try:\n      # This is the first call of __call__, so we have to initialize.\n      initializers = []\n      self._initialize(args, kwds, add_initializers_to=initializers)\n    finally:\n      # At this point we know that the initialization is complete (or less\n      # interestingly an exception was raised) so we no longer need a lock.\n      self._lock.release()\n\n    if self._created_variables:\n      try:\n        # Attempt to initialize variables eagerly and without conds by lifting\n        # out initialization graphs. This is the only initialization strategy\n        # compatible with XLA at the moment.\n        self._initialize_uninitialized_variables(initializers)\n      except lift_to_graph.UnliftableError:\n        pass  # Fall through to cond-based initialization.\n      else:\n        # Lifting succeeded, so variables are initialized and we can run the\n        # stateless function.\n        return self._stateless_fn(*args, **kwds)\n    else:\n      _, _, _, filtered_flat_args = \\\n          self._stateful_fn._function_spec.canonicalize_function_inputs(  # pylint: disable=protected-access\n              *args, **kwds)\n      # If we did not create any variables the trace we have is good enough.\n      return self._concrete_stateful_fn._call_flat(\n          filtered_flat_args, self._concrete_stateful_fn.captured_inputs)  # pylint: disable=protected-access\n\n    def fn_with_cond(inner_args, inner_kwds, inner_filtered_flat_args):\n      \"\"\"Conditionally runs initialization if it's needed.\"\"\"\n      condition = True\n      for wr in self._created_variables:\n        variable = wr()\n        if variable is None:\n          raise ValueError(\n              \"A tf.Variable created inside your tf.function has been\"\n              \" garbage-collected. Your code needs to keep Python references\"\n              \" to variables created inside `tf.function`s.\\n\"\n              \"\\n\"\n              \"A common way to raise this error is to create and return a\"\n              \" variable only referenced inside your function:\\n\"\n              \"\\n\"\n              \"@tf.function\\n\"\n              \"def f():\\n\"\n              \"  v = tf.Variable(1.0)\\n\"\n              \"  return v\\n\"\n              \"\\n\"\n              \"v = f()  # Crashes with this error message!\\n\"\n              \"\\n\"\n              \"The reason this crashes is that @tf.function annotated\"\n              \" function returns a **`tf.Tensor`** with the **value** of the\"\n              \" variable when the function is called rather than the\"\n              \" variable instance itself. As such there is no code holding a\"\n              \" reference to the `v` created inside the function and Python\"\n              \" garbage collects it.\\n\"\n              \"\\n\"\n              \"The simplest way to fix this issue is to create variables\"\n              \" outside the function and capture them:\\n\"\n              \"\\n\"\n              \"v = tf.Variable(1.0)\\n\"\n              \"\\n\"\n              \"@tf.function\\n\"\n              \"def f():\\n\"\n              \"  return v\\n\"\n              \"\\n\"\n              \"f()  # <tf.Tensor: numpy=1.>\\n\"\n              \"v.assign_add(1.)\\n\"\n              \"f()  # <tf.Tensor: numpy=2.>\")\n        condition = math_ops.logical_and(\n            condition, resource_variable_ops.var_is_initialized_op(\n                variable.handle))\n      # We want to call stateless_fn if possible because it avoids recomputing\n      # potentially expensive initializers.\n      return control_flow_ops.cond(\n          condition,\n          lambda: self._stateless_fn(*inner_args, **inner_kwds),\n          functools.partial(\n              self._concrete_stateful_fn._call_flat,  # pylint: disable=protected-access\n              inner_filtered_flat_args,\n              captured_inputs=self._concrete_stateful_fn.captured_inputs))\n\n    # We've created variables and are unable to lift the initialization graphs,\n    # so we fall back to initializing with conds while running the function.\n    canon_args, canon_kwds, _, filtered_flat_args = \\\n        self._stateful_fn._function_spec.canonicalize_function_inputs(  # pylint: disable=protected-access\n            *args, **kwds)\n    return function_lib.defun(fn_with_cond)(canon_args, canon_kwds,\n                                            filtered_flat_args)\n\n  def experimental_get_compiler_ir(self, *args, **kwargs):\n    # Implements GenericFunction.experimental_get_compiler_ir\n    context.ensure_initialized()\n    if not self._jit_compile:\n      raise ValueError(\"Compiler IR can only be returned for functions marked \"\n                       \"with 'jit_compile=True'\")\n\n    concrete_fn = self.get_concrete_function(*args, **kwargs)\n    fn_name = concrete_fn.name\n\n    # pylint: disable=protected-access\n    _, _, _, filtered_flat_args = \\\n        concrete_fn._function_spec.canonicalize_function_inputs(\n            *args, **kwargs)\n\n    def compiler_ir_generator(stage=\"hlo\", device_name=None):\n      # TODO(cheshire): This is a hack to get the current \"preferred\" device,\n      # there is no current API to get it otherwise.\n      if device_name is None:\n        device_name = random_ops.random_normal([]).device\n      res_bytes = context.context().get_compiler_ir(\n          device_name=device_name,\n          stage=stage,\n          function_name=fn_name,\n          args=list(filtered_flat_args) + concrete_fn.captured_inputs)\n      if stage in (\"hlo_serialized\", \"optimized_hlo_serialized\",\n                   \"optimized_hlo_proto_serialized\"):\n        return res_bytes\n      else:\n        return res_bytes.decode(\"utf-8\")\n\n    return compiler_ir_generator\n\n  @property\n  def python_function(self):\n    \"\"\"The python function wrapped in this tf.function.\"\"\"\n    return self._python_function\n\n  @property\n  def input_signature(self):\n    return self._function_spec.input_signature\n\n  @property\n  def function_spec(self):\n    return self._function_spec\n\n  def pretty_printed_concrete_signatures(self, verbose=True):\n    joiner = \"\\n\\n\" if verbose else \"\\n\"\n    return joiner.join([\n        c.pretty_printed_signature(verbose=verbose)\n        for c in self._list_all_concrete_functions()\n    ])\n\n  def _initialize_uninitialized_variables(self, initializers):\n    \"\"\"Make and call a `ConcreteFunction` which initializes variables.\"\"\"\n\n    if not initializers:\n      return\n\n    var_is_initialized = _evaluate_var_is_initialized(\n        [v for v, _ in initializers])\n\n    # Note: using defun here avoids an infinite recursion.\n    # Most of the code in this function runs eagerly with init_scope, where\n    # autograph is not necessary.\n    @function_lib.defun(autograph=False)\n    def initialize_variables():\n      op_map = object_identity.ObjectIdentityDictionary()\n\n      inits = []\n      for (v, init), is_initialized in zip(initializers, var_is_initialized):\n        with ops.init_scope():\n          if is_initialized:\n            continue\n        inits.append(init)\n\n      if inits:\n        op_map = lift_to_graph.lift_to_graph(\n            inits, ops.get_default_graph(), op_map=op_map)\n      for (v, init), is_initialized in zip(initializers, var_is_initialized):\n        with ops.init_scope():\n          if is_initialized:\n            continue\n        v.assign(op_map[init], read_value=False)\n\n    with ops.init_scope():\n      return initialize_variables.get_concrete_function()()\n\n  def get_initialization_function(self, *args, **kwargs):\n    \"\"\"Returns a `ConcreteFunction` which initializes this function's variables.\n\n    Requires that this function hasn't been accessed yet through either calling\n    it or calling get_concrete_function. Fails if we cannot build an initializer\n    function which does not depend on the concrete values of the inputs to this\n    function.\n\n    Note that running this function will overwrite any values currently assigned\n    to variables, for example restores from a checkpoint.\n\n    Args:\n      *args: arguments to the underlying python callable.\n      **kwargs: keyword arguments to the python callable.\n\n    Returns:\n      A `ConcreteFunction` object which initializes the variables of this\n      function.\n\n    Raises:\n      RuntimeError: if called after the variables have been initialized.\n    \"\"\"\n    with self._lock:\n      if self._stateful_fn is not None:\n        raise RuntimeError(\n            \"get_initialization_function cannot be called after the function \"\n            \"has been used\")\n      # Here we trace the function, collect the initializers, and attempt to\n      # extract them and run them eagerly. Fail only if we cannot do so.\n      initializers = []\n      self._initialize(args, kwargs, add_initializers_to=initializers)\n\n    # Note: using defun here avoids an infinite recursion.\n    @function_lib.defun\n    def initialize_variables():\n      for v, init in initializers:\n        v.assign(\n            lift_to_graph.lift_to_graph([init], ops.get_default_graph())[init],\n            read_value=False)\n\n    return initialize_variables.get_concrete_function()\n\n  def _list_all_concrete_functions(self):\n    \"\"\"Returns all concrete functions.\"\"\"\n    if self.input_signature is not None:\n      self.get_concrete_function()\n    concrete_functions = []\n    # pylint: disable=protected-access\n    if self._stateful_fn:\n      concrete_functions.extend(\n          self._stateful_fn._function_cache.all_values())\n    if self._stateless_fn:\n      concrete_functions.extend(\n          self._stateless_fn._function_cache.all_values())\n    # pylint: enable=protected-access\n    return concrete_functions\n\n  def _list_all_concrete_functions_for_serialization(self):\n    \"\"\"Returns all concrete functions for serialization.\n\n    Returns:\n      A list of instances of `ConcreteFunction`.\n    \"\"\"\n    concrete_functions = self._list_all_concrete_functions()\n    seen_signatures = []\n    for concrete_function in concrete_functions:\n      signature = concrete_function.structured_input_signature\n      flattened = nest.flatten(signature)\n      if any(\n          isinstance(arg, func_graph_module.UnknownArgument)\n          for arg in flattened):\n        logging.info(\"Unsupported signature for serialization: %s.\", signature)\n        continue\n      equal_to_signature = functools.partial(\n          function_lib.is_same_structure, signature, check_values=True)\n      if not any(equal_to_signature(s) for s in seen_signatures):\n        seen_signatures.append(signature)\n\n    # Re-create concrete functions for these signatures. Re-creating ensures\n    # that if the cache key has changed, the function will be traced again.\n    concrete_functions = []\n    for args, kwargs in seen_signatures:\n      concrete_functions.append(self.get_concrete_function(*args, **kwargs))\n    return concrete_functions\n\n  def _get_concrete_function_garbage_collected(self, *args, **kwargs):\n    \"\"\"Returns a `ConcreteFunction` specialized to inputs and execution context.\n\n    Unlike `get_concrete_function(...)`, the graph will be deleted when the\n    returned function is deleted.  It's useful to avoid creating a reference\n    cycle when you know for sure that the graph will be no longer used without\n    the returned function.\n\n    Args:\n      *args: inputs to specialize on.\n      **kwargs: inputs to specialize on.\n\n    Returns:\n      A TensorFlow function which takes exactly one `tf.Tensor` per argument.\n\n    Raises:\n      ValueError: if this object has not yet been called on concrete values.\n    \"\"\"\n    with self._lock:\n      if self._stateful_fn is None:\n        initializers = []\n        self._initialize(args, kwargs, add_initializers_to=initializers)\n        self._initialize_uninitialized_variables(initializers)\n\n    if self._created_variables:\n      # In this case we have created variables on the first call, so we run the\n      # defunned version which is guaranteed to never create variables.\n      return self._stateless_fn._get_concrete_function_garbage_collected(  # pylint: disable=protected-access\n          *args, **kwargs)\n    elif self._stateful_fn is not None:\n      # In this case we have not created variables on the first call. So we can\n      # run the first trace but we should fail if variables are created.\n      concrete = self._stateful_fn._get_concrete_function_garbage_collected(  # pylint: disable=protected-access\n          *args, **kwargs)\n      if self._created_variables:\n        raise ValueError(\"Creating variables on a non-first call to a function\"\n                         \" decorated with tf.function.\")\n      return concrete\n\n  def get_concrete_function(self, *args, **kwargs):\n    # Implements GenericFunction.get_concrete_function.\n    concrete = self._get_concrete_function_garbage_collected(*args, **kwargs)\n    concrete._garbage_collector.release()  # pylint: disable=protected-access\n    return concrete\n\n  def __get__(self, instance, owner):\n    \"\"\"Makes it possible to defun instance methods.\"\"\"\n    del owner\n    # `instance` here is the instance that this `Function` was accessed through\n    # e.g., for\n    #\n    #   class Foo(object):\n    #\n    #     @function.defun\n    #     def bar(self):\n    #       ...\n    #\n    #   foo = Foo()\n    #   foo.bar()  # `foo.bar` is a `Function` instance\n    #\n    # then `instance` will be `foo` (and `owner` will be `Foo`).  For composite\n    # tensors, we can just treat `instance` as a normal parameter.  But for\n    # other types, we create a new instance of `Function` here to allow\n    # different instances each to create variables once, thereby allowing\n    # methods to be decorated with tf.function. Keeps a cache to avoid retracing\n    # the function every time the descriptor is accessed.\n    # TODO(mdan): Identify types which can just be parameters more generically.\n    #\n    # The check for instance._type_spec=None is used because certain classes\n    # (including subclasses of tf.linalg.LinearOperator) are subclasses of\n    # CompositeTensor but do not actually implement the required APIs.\n    # TODO(b/199278478): Fix those classes, then remove the check for\n    # `instance._type_spec is not None`.\n    if (isinstance(instance, composite_tensor.CompositeTensor) and\n        instance._type_spec is not None):  # pylint: disable=protected-access\n      return types_lib.MethodType(self, instance)\n    if instance not in self._descriptor_cache:\n      if instance is None:\n        return self\n      # TODO(mdan): If the CompositeTensor path works, do the same here.\n      # It's unclear whether we need the tf-decorator, or could just call\n      # MethodType(self.clone(), instance)\n      self._descriptor_cache[instance] = (\n          function_lib.class_method_to_instance_method(self, instance))\n    return self._descriptor_cache[instance]\n\n\n@tf_export(\"function\")\n@deprecation.deprecated_args(None,\n                             \"experimental_compile is deprecated, use \"\n                             \"jit_compile instead\", \"experimental_compile\")\ndef function(func=None,\n             input_signature=None,\n             autograph=True,\n             jit_compile=None,\n             experimental_implements=None,\n             experimental_autograph_options=None,\n             experimental_relax_shapes=False,\n             experimental_compile=None,\n             experimental_follow_type_hints=None) -> core.GenericFunction:\n  \"\"\"Compiles a function into a callable TensorFlow graph.\n\n  `tf.function` constructs a `tf.types.experimental.GenericFunction` that\n  executes a TensorFlow graph (`tf.Graph`) created by trace-compiling the\n  TensorFlow operations in `func`. More information on the topic can be found\n  in [Introduction to Graphs and tf.function]\n  (https://www.tensorflow.org/guide/intro_to_graphs).\n\n  See [Better Performance with tf.function]\n  (https://www.tensorflow.org/guide/function) for tips on performance and\n  known limitations.\n\n  Example usage:\n\n  >>> @tf.function\n  ... def f(x, y):\n  ...   return x ** 2 + y\n  >>> x = tf.constant([2, 3])\n  >>> y = tf.constant([3, -2])\n  >>> f(x, y)\n  <tf.Tensor: ... numpy=array([7, 7], ...)>\n\n  The trace-compilation allows non-TensorFlow operations to execute, but under\n  special conditions. In general, only TensorFlow operations are guaranteed to\n  run and create fresh results whenever the `GenericFunction` is called.\n\n  ## Features\n\n  `func` may use data-dependent control flow, including `if`, `for`, `while`\n  `break`, `continue` and `return` statements:\n\n  >>> @tf.function\n  ... def f(x):\n  ...   if tf.reduce_sum(x) > 0:\n  ...     return x * x\n  ...   else:\n  ...     return -x // 2\n  >>> f(tf.constant(-2))\n  <tf.Tensor: ... numpy=1>\n\n  `func`'s closure may include `tf.Tensor` and `tf.Variable` objects:\n\n  >>> @tf.function\n  ... def f():\n  ...   return x ** 2 + y\n  >>> x = tf.constant([-2, -3])\n  >>> y = tf.Variable([3, -2])\n  >>> f()\n  <tf.Tensor: ... numpy=array([7, 7], ...)>\n\n  `func` may also use ops with side effects, such as `tf.print`, `tf.Variable`\n  and others:\n\n  >>> v = tf.Variable(1)\n  >>> @tf.function\n  ... def f(x):\n  ...   for i in tf.range(x):\n  ...     v.assign_add(i)\n  >>> f(3)\n  >>> v\n  <tf.Variable ... numpy=4>\n\n  Important: Any Python side-effects (appending to a list, printing with\n  `print`, etc) will only happen once, when `func` is traced. To have\n  side-effects executed into your `tf.function` they need to be written\n  as TF ops:\n\n  >>> l = []\n  >>> @tf.function\n  ... def f(x):\n  ...   for i in x:\n  ...     l.append(i + 1)    # Caution! Will only happen once when tracing\n  >>> f(tf.constant([1, 2, 3]))\n  >>> l\n  [<tf.Tensor ...>]\n\n  Instead, use TensorFlow collections like `tf.TensorArray`:\n\n  >>> @tf.function\n  ... def f(x):\n  ...   ta = tf.TensorArray(dtype=tf.int32, size=0, dynamic_size=True)\n  ...   for i in range(len(x)):\n  ...     ta = ta.write(i, x[i] + 1)\n  ...   return ta.stack()\n  >>> f(tf.constant([1, 2, 3]))\n  <tf.Tensor: ..., numpy=array([2, 3, 4], ...)>\n\n  ## `tf.function` creates polymorphic callables\n\n  Internally, `tf.types.experimental.GenericFunction` may contain multiple\n  `tf.types.experimental.ConcreteFunction`s, each specialized to arguments with\n  different data types or shapes, since TensorFlow can perform more\n  optimizations on graphs of specific shapes, dtypes and values of constant\n  arguments. `tf.function` treats any pure Python values as opaque objects (best\n  thought of as compile-time constants), and builds a separate `tf.Graph` for\n  each set of Python arguments that it encounters.\n  For more information, see the\n  [tf.function guide](https://www.tensorflow.org/guide/function#rules_of_tracing)\n\n  Executing a `GenericFunction` will select and execute the appropriate\n  `ConcreteFunction` based on the argument types and values.\n\n  To obtain an individual `ConcreteFunction`, use the\n  `GenericFunction.get_concrete_function` method. It can be called with the\n  same arguments as `func` and returns a\n  `tf.types.experimental.ConcreteFunction`. `ConcreteFunction`s are backed by a\n  single `tf.Graph`:\n\n  >>> @tf.function\n  ... def f(x):\n  ...   return x + 1\n  >>> isinstance(f.get_concrete_function(1).graph, tf.Graph)\n  True\n\n  `ConcreteFunction`s can be executed just like `GenericFunction`s, but their\n  input is resticted to the types to which they're specialized.\n\n  ## Retracing\n\n  `ConcreteFunctions` are built (traced) on the fly, as the `GenericFunction` is\n  called with new TensorFlow types or shapes, or with new Python values as\n  arguments. When `GenericFunction` builds a new trace, it is said that `func`\n  is retraced. Retracing is a frequent performance concern for `tf.function` as\n  it can be considerably slower than executing a graph that's already been\n  traced. It is ideal to minimize the amount of retracing in your code.\n\n  Caution: Passing python scalars or lists as arguments to `tf.function` will\n  usually retrace. To avoid this, pass numeric arguments as Tensors whenever\n  possible:\n\n  >>> @tf.function\n  ... def f(x):\n  ...   return tf.abs(x)\n  >>> f1 = f.get_concrete_function(1)\n  >>> f2 = f.get_concrete_function(2)  # Slow - compiles new graph\n  >>> f1 is f2\n  False\n  >>> f1 = f.get_concrete_function(tf.constant(1))\n  >>> f2 = f.get_concrete_function(tf.constant(2))  # Fast - reuses f1\n  >>> f1 is f2\n  True\n\n  Python numerical arguments should only be used when they take few distinct\n  values, such as hyperparameters like the number of layers in a neural network.\n\n  ## Input signatures\n\n  For Tensor arguments, `GenericFunction`creates a new `ConcreteFunction` for\n  every unique set of input shapes and datatypes. The example below creates two\n  separate `ConcreteFunction`s, each specialized to a different shape:\n\n  >>> @tf.function\n  ... def f(x):\n  ...   return x + 1\n  >>> vector = tf.constant([1.0, 1.0])\n  >>> matrix = tf.constant([[3.0]])\n  >>> f.get_concrete_function(vector) is f.get_concrete_function(matrix)\n  False\n\n  An \"input signature\" can be optionally provided to `tf.function` to control\n  this process. The input signature specifies the shape and type of each\n  Tensor argument to the function using a `tf.TensorSpec` object. More general\n  shapes can be used. This ensures only one `ConcreteFunction` is created, and\n  restricts the `GenericFunction` to the specified shapes and types. It is\n  an effective way to limit retracing when Tensors have dynamic shapes.\n\n  >>> @tf.function(\n  ...     input_signature=[tf.TensorSpec(shape=None, dtype=tf.float32)])\n  ... def f(x):\n  ...   return x + 1\n  >>> vector = tf.constant([1.0, 1.0])\n  >>> matrix = tf.constant([[3.0]])\n  >>> f.get_concrete_function(vector) is f.get_concrete_function(matrix)\n  True\n\n  ## Variables may only be created once\n\n  `tf.function` only allows creating new `tf.Variable` objects when it is called\n  for the first time:\n\n  >>> class MyModule(tf.Module):\n  ...   def __init__(self):\n  ...     self.v = None\n  ...\n  ...   @tf.function\n  ...   def __call__(self, x):\n  ...     if self.v is None:\n  ...       self.v = tf.Variable(tf.ones_like(x))\n  ...     return self.v * x\n\n  In general, it is recommended to create `tf.Variable`s outside of\n  `tf.function`.\n  In simple cases, persisting state across `tf.function` boundaries may be\n  implemented using a pure functional style in which state is represented by\n  `tf.Tensor`s passed as arguments and returned as return values.\n\n  Contrast the two styles below:\n\n  >>> state = tf.Variable(1)\n  >>> @tf.function\n  ... def f(x):\n  ...   state.assign_add(x)\n  >>> f(tf.constant(2))  # Non-pure functional style\n  >>> state\n  <tf.Variable ... numpy=3>\n\n  >>> state = tf.constant(1)\n  >>> @tf.function\n  ... def f(state, x):\n  ...   state += x\n  ...   return state\n  >>> state = f(state, tf.constant(2))  # Pure functional style\n  >>> state\n  <tf.Tensor: ... numpy=3>\n\n  ## Python operations execute only once per trace\n\n  `func` may contain TensorFlow operations mixed with pure Python operations.\n  However, when the function is executed, only the TensorFlow operations will\n  run. The Python operations run only once, at trace time. If TensorFlow\n  operations depend on results from Pyhton operations, those results will be\n  frozen into the graph.\n\n  >>> @tf.function\n  ... def f(a, b):\n  ...   print('this runs at trace time; a is', a, 'and b is', b)\n  ...   return b\n  >>> f(1, tf.constant(1))\n  this runs at trace time; a is 1 and b is Tensor(\"...\", shape=(), dtype=int32)\n  <tf.Tensor: shape=(), dtype=int32, numpy=1>\n\n  >>> f(1, tf.constant(2))\n  <tf.Tensor: shape=(), dtype=int32, numpy=2>\n\n  >>> f(2, tf.constant(1))\n  this runs at trace time; a is 2 and b is Tensor(\"...\", shape=(), dtype=int32)\n  <tf.Tensor: shape=(), dtype=int32, numpy=1>\n\n  >>> f(2, tf.constant(2))\n  <tf.Tensor: shape=(), dtype=int32, numpy=2>\n\n  ## Using type annotations to improve performance\n\n  'experimental_follow_type_hints` can be used along with type annotations to\n  reduce retracing by automatically casting any Python values to `tf.Tensor`\n  (something that is not done by default, unless you use input signatures).\n\n  >>> @tf.function(experimental_follow_type_hints=True)\n  ... def f_with_hints(x: tf.Tensor):\n  ...   print('Tracing')\n  ...   return x\n  >>> @tf.function(experimental_follow_type_hints=False)\n  ... def f_no_hints(x: tf.Tensor):\n  ...   print('Tracing')\n  ...   return x\n  >>> f_no_hints(1)\n  Tracing\n  <tf.Tensor: shape=(), dtype=int32, numpy=1>\n  >>> f_no_hints(2)\n  Tracing\n  <tf.Tensor: shape=(), dtype=int32, numpy=2>\n  >>> f_with_hints(1)\n  Tracing\n  <tf.Tensor: shape=(), dtype=int32, numpy=1>\n  >>> f_with_hints(2)\n  <tf.Tensor: shape=(), dtype=int32, numpy=2>\n\n  Args:\n    func: the function to be compiled. If `func` is None, `tf.function` returns\n      a decorator that can be invoked with a single argument - `func`. In other\n      words, `tf.function(input_signature=...)(func)` is equivalent to\n      `tf.function(func, input_signature=...)`. The former can be used as\n      decorator.\n    input_signature: A possibly nested sequence of `tf.TensorSpec` objects\n      specifying the shapes and dtypes of the Tensors that will be supplied to\n      this function. If `None`, a separate function is instantiated for each\n      inferred input signature.  If input_signature is specified, every input to\n      `func` must be a `Tensor`, and `func` cannot accept `**kwargs`.\n    autograph: Whether autograph should be applied on `func` before tracing a\n      graph. Data-dependent control flow requires `autograph=True`. For more\n      information, see the [tf.function and AutoGraph guide](\n      https://www.tensorflow.org/guide/function#autograph_transformations).\n    jit_compile: If `True`, compiles the function using\n      [XLA](https://tensorflow.org/xla). XLA performs compiler optimizations,\n      such as fusion, and attempts to emit more efficient code. This may\n      drastically improve the performance. If set to `True`,\n      the whole function needs to be compilable by XLA, or an\n      `errors.InvalidArgumentError` is thrown.\n      If `None` (default), compiles the function with XLA when running on TPU\n      and goes through the regular function execution path when running on\n      other devices.\n      If `False`, executes the function without XLA compilation.  Set this value\n      to `False` when directly running a multi-device function on TPUs (e.g. two\n      TPU cores, one TPU core and its host CPU).\n      Not all functions are compilable, see a list of\n      [sharp corners](https://tensorflow.org/xla/known_issues).\n    experimental_implements: If provided, contains a name of a \"known\" function\n      this implements. For example \"mycompany.my_recurrent_cell\".\n      This is stored as an attribute in inference function,\n      which can then be detected when processing serialized function.\n      See [standardizing composite ops](https://github.com/tensorflow/community/blob/master/rfcs/20190610-standardizing-composite_ops.md)  # pylint: disable=line-too-long\n      for details.  For an example of utilizing this attribute see this\n      [example](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/compiler/mlir/lite/transforms/prepare_composite_functions_tf.cc)\n      The code above automatically detects and substitutes function that\n      implements \"embedded_matmul\" and allows TFLite to substitute its own\n      implementations. For instance, a tensorflow user can use this\n       attribute to mark that their function also implements\n      `embedded_matmul` (perhaps more efficiently!)\n      by specifying it using this parameter:\n      `@tf.function(experimental_implements=\"embedded_matmul\")`\n      This can either be specified as just the string name of the function or\n      a NameAttrList corresponding to a list of key-value attributes associated\n      with the function name. The name of the function will be in the 'name'\n      field of the NameAttrList. To define a formal TF op for this function\n      implements, try the experimental [composite TF](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/compiler/mlir/tfr)\n      project.\n    experimental_autograph_options: Optional tuple of\n      `tf.autograph.experimental.Feature` values.\n    experimental_relax_shapes: When True, `tf.function` may generate fewer,\n      graphs that are less specialized on input shapes.\n    experimental_compile: Deprecated alias to 'jit_compile'.\n    experimental_follow_type_hints: When True, the function may use type\n      annotations from `func` to optimize the tracing performance. For example,\n      arguments annotated with `tf.Tensor` will automatically be converted\n      to a Tensor.\n\n  Returns:\n     If `func` is not None, returns a `tf.types.experimental.GenericFunction`.\n     If `func` is None, returns a decorator that, when invoked with a single\n     `func` argument, returns a `tf.types.experimental.GenericFunction`.\n\n  Raises:\n     `ValueError` when attempting to use `jit_compile=True`, but XLA support is\n     not available.\n  \"\"\"\n  if func is not None:\n    function_lib.validate_python_function(func)\n  if input_signature is not None:\n    function_lib.validate_signature(input_signature)\n  if experimental_follow_type_hints is None:\n    experimental_follow_type_hints = False\n\n  def decorated(inner_function):\n    try:\n      name = inner_function.__name__\n    except AttributeError:\n      name = \"function\"\n    return tf_decorator.make_decorator(\n        inner_function,\n        decorator_name=\"tf.function\",\n        decorator_func=Function(\n            inner_function,\n            name,\n            input_signature=input_signature,\n            autograph=autograph,\n            experimental_autograph_options=experimental_autograph_options,\n            experimental_relax_shapes=experimental_relax_shapes,\n\n            # TODO(b/171825496): Update once `experimental_compile` is removed\n            # entirely in favor of 'jit_compile'.\n            jit_compile=deprecation.deprecated_argument_lookup(\n                \"jit_compile\",\n                jit_compile,\n                \"experimental_compile\",\n                experimental_compile),\n            experimental_implements=experimental_implements,\n            experimental_follow_type_hints=experimental_follow_type_hints))\n\n  # This code path is for the `foo = tf.function(foo, ...)` use case\n  if func is not None:\n    return decorated(func)\n\n  # This code path is for the\n  #\n  # @tf.function(...)\n  # def foo(...):\n  #    ...\n  #\n  # use case, which is equivalent to `foo = tf.function(...)(foo)`\n  return decorated\n", "# Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\nimport functools\nimport itertools\nimport pickle\nimport re\nimport sys\nimport unittest\nimport weakref\n\nfrom absl.testing import parameterized\nfrom six.moves import range\n\nfrom tensorflow.python.autograph.core import converter\nfrom tensorflow.python.eager import def_function\nfrom tensorflow.python.eager import lift_to_graph\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import extension_type\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import tensor_spec\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.module import module\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import control_flow_ops\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import random_ops\nfrom tensorflow.python.ops import resource_variable_ops\nfrom tensorflow.python.ops import variable_scope\nfrom tensorflow.python.ops import variables\nfrom tensorflow.python.platform import test\nfrom tensorflow.python.saved_model import save_context\nfrom tensorflow.python.saved_model import save_options\nfrom tensorflow.python.saved_model.load import load\nfrom tensorflow.python.saved_model.save import save\nfrom tensorflow.python.training.tracking.util import Checkpoint\n\n\ndef undecorated_function(x):\n  return x * 3.\n\n\nclass _HasDecoratedMethod(object):\n\n  @def_function.function\n  def f(self, x):\n    return x * 3.\n\n\nclass DefFunctionTest(test.TestCase, parameterized.TestCase):\n\n  def testNoVariables(self):\n\n    @def_function.function\n    def fn(x):\n      return 2 * x\n\n    self.assertAllEqual(fn(constant_op.constant(4.0)), 8.0)\n\n  def testFailIfVariablesAreCreatedMoreThanOnce(self):\n\n    @def_function.function\n    def fn(x):\n      return variables.Variable(1.0) + x\n\n    with self.assertRaises(ValueError):\n      fn(1.0)\n\n  def testFailIfVariablesAreCreatedMoreThanOnceNoWeakRef(self):\n    state = []\n\n    @def_function.function\n    def fn(x):\n      state.append(variables.Variable(1.0))\n      return state[-1] + x\n\n    with self.assertRaises(ValueError):\n      fn(1.0)\n\n  def testRange(self):\n\n    @def_function.function\n    def f(unused_x):\n      return 1.0\n\n    self.assertAllEqual(f(range(5)), 1.0)\n\n  def testCorrectVariableCreation(self):\n\n    state = []\n\n    @def_function.function\n    def fn(x):\n      if not state:\n        state.append(variables.Variable(2.0))\n      return state[0] * x\n\n    self.assertAllEqual(fn(constant_op.constant(1.0)), 2.0)\n    self.assertAllEqual(fn(constant_op.constant(3.0)), 6.0)\n\n  def testFunctionInitializer(self):\n\n    state = []\n\n    @def_function.function\n    def fn(x):\n      if not state:\n        state.append(variables.Variable(lambda: 2.0))\n      return state[0] * x\n\n    self.assertAllEqual(fn(constant_op.constant(1.0)), 2.0)\n\n  def testFunctionMultipleVariableInitializer(self):\n\n    state = []\n\n    @def_function.function\n    def fn(x):\n      if not state:\n        state.append(variables.Variable(lambda: 2.0))\n        state.append(variables.Variable(lambda: 5.0))\n      return state[0] * x, state[1] * x\n\n    self.assertAllEqual(fn(constant_op.constant(1.0)), [2.0, 5.0])\n\n  def testFunctionInitializationFunction(self):\n\n    state = []\n\n    @def_function.function\n    def fn(x):\n      if not state:\n        state.append(variables.Variable(2.0))\n      return state[0] * x\n\n    init_fn = fn.get_initialization_function(constant_op.constant(1.0))\n    self.assertLen(state, 1)\n    self.assertFalse(\n        resource_variable_ops.var_is_initialized_op(state[0].handle))\n    init_fn()\n    self.assertEqual(state[0].numpy(), 2.0)\n\n  def testVariableInitializerNotConstant(self):\n\n    state = []\n\n    @def_function.function\n    def fn(x):\n      if not state:\n        state.append(variables.Variable(2.0 * x))\n      return state[0] * x\n\n    self.assertAllEqual(fn(constant_op.constant(1.0)), 2.0)\n    self.assertAllEqual(fn(constant_op.constant(3.0)), 6.0)\n\n  def testLegacyGraphModeVariables(self):\n    with ops.Graph().as_default(), self.test_session() as sess:\n      state = []\n\n      @def_function.function\n      def fn(x):\n        if not state:\n          state.append(variables.Variable(2.0))\n        return state[0] * x\n\n      result = fn(3.0)\n\n      self.evaluate(variables.global_variables_initializer())\n      self.assertAllEqual(sess.run(state[0]), 2.0)\n      self.assertAllEqual(self.evaluate(result), 6.0)\n\n  def testLegacyGraphModeVariablesNonTrivialInitializer(self):\n    with ops.Graph().as_default(), self.test_session() as sess:\n      state = []\n\n      @def_function.function\n      def fn(x):\n        if not state:\n          two = constant_op.constant(2.0)\n          four = two * two\n          two_again = math_ops.sqrt(four)\n          state.append(variables.Variable(two_again + four))\n        return state[0] * x\n\n      result = fn(3.0)\n\n      self.evaluate(variables.global_variables_initializer())\n      self.assertAllEqual(sess.run(state[0]), 6.0)\n      self.assertAllEqual(self.evaluate(result), 18.0)\n\n  def testLegacyGraphModeInputDependentInitializerFails(self):\n    with ops.Graph().as_default():\n      state = []\n\n      @def_function.function\n      def fn(x):\n        if not state:\n          state.append(variables.Variable(2.0 * x))\n        return state[0] * x\n\n      with self.assertRaisesRegex(lift_to_graph.UnliftableError,\n                                  r'transitively.* mul .* x'):\n        fn(constant_op.constant(3.0))\n\n  def testMethod(self):\n\n    class MyModel(object):\n\n      def __init__(self):\n        self.var = None\n\n      @def_function.function\n      def apply(self, x):\n        if self.var is None:\n          self.var = variables.Variable(2.0)\n        return self.var * x\n\n    m0 = MyModel()\n    self.assertAllEqual(m0.apply(3.0), 6.0)\n    # Calling twice to exercise that we do not recreate variables.\n    m0.var.assign(3.0)\n    self.assertAllEqual(m0.apply(3.0), 9.0)\n\n    m1 = MyModel()\n    self.assertAllEqual(m1.apply(3.0), 6.0)\n\n  @unittest.expectedFailure\n  def testMethodAllowDynamicVariableWithoutGuards(self):\n\n    class Foo:\n\n      def __init__(self):\n        self._var = 0\n\n      def __call__(self, val):\n        self.compute(val)\n        return self._var\n\n      @def_function.function\n      def compute(self, val):\n        self._var = variables.Variable(val)\n\n    def_function.ALLOW_DYNAMIC_VARIABLE_CREATION = True\n    foo = Foo()\n    self.assertAllEqual(foo(0.3), 0.3)\n    self.assertAllEqual(\n        foo(0.9), 0.9, 'https://github.com/tensorflow/tensorflow/issues/27120')\n\n  def testMethodAllowDynamicVariable(self):\n\n    class Foo:\n\n      def __init__(self):\n        self._flag_keyed_vars = {}\n        self.trace_count = 0\n\n      def __call__(self, var_creation_flag):\n        self.compute(var_creation_flag)\n        return self._flag_keyed_vars[var_creation_flag]\n\n      @def_function.function\n      def compute(self, var_creation_flag):\n        self.trace_count += 1\n        if var_creation_flag not in self._flag_keyed_vars:\n          if var_creation_flag:\n            self._flag_keyed_vars[var_creation_flag] = variables.Variable(1.0)\n          else:\n            self._flag_keyed_vars[var_creation_flag] = variables.Variable(2.0)\n\n    def_function.ALLOW_DYNAMIC_VARIABLE_CREATION = True\n    foo = Foo()\n    self.assertAllEqual(foo(True), 1.0)\n    self.assertEqual(foo.trace_count, 2)\n    self.assertAllEqual(foo(True), 1.0)\n    self.assertEqual(foo.trace_count, 2)\n    self.assertAllEqual(foo(False), 2.0)\n    self.assertEqual(foo.trace_count, 3)\n\n  def testMethodNotAllowDynamicVariable(self):\n\n    class Foo:\n\n      def __init__(self):\n        self._flag_keyed_vars = {}\n        self.trace_count = 0\n\n      def __call__(self, var_creation_flag):\n        self.compute(var_creation_flag)\n        return self._flag_keyed_vars[var_creation_flag]\n\n      @def_function.function\n      def compute(self, var_creation_flag):\n        self.trace_count += 1\n        if var_creation_flag not in self._flag_keyed_vars:\n          if var_creation_flag:\n            self._flag_keyed_vars[var_creation_flag] = variables.Variable(1.0)\n          else:\n            self._flag_keyed_vars[var_creation_flag] = variables.Variable(2.0)\n\n    def_function.ALLOW_DYNAMIC_VARIABLE_CREATION = False\n    foo = Foo()\n    self.assertAllEqual(foo(True), 1.0)\n    self.assertEqual(foo.trace_count, 2)\n    self.assertAllEqual(foo(True), 1.0)\n    self.assertEqual(foo.trace_count, 2)\n    msg = 'singleton tf.Variable.*on the first call'\n    with self.assertRaisesRegex(ValueError, msg):\n      foo(False)\n    self.assertEqual(foo.trace_count, 3)\n\n  def testMethodExtensionType(self):\n\n    class MaskedTensor(extension_type.ExtensionType):\n      values: ops.Tensor\n      mask: ops.Tensor\n\n      @def_function.function\n      def with_default(self, default_value):\n        return array_ops.where_v2(self.mask, self.values, default_value)\n\n      @def_function.function\n      def sum(self):\n        # Use a loop & conditional to test that autograph works correctly.\n        result = 0\n        for i in range(array_ops.size(self.values)):\n          if self.mask[i]:\n            result += self.values[i]\n        return result\n\n    mt = MaskedTensor([1, 2, 3], [True, False, True])\n    self.assertAllEqual(mt.with_default(-1), [1, -1, 3])\n    self.assertAllEqual(mt.sum(), 4)\n\n  def test_functools_partial(self):\n    self.assertAllClose(\n        3.,\n        def_function.function(functools.partial(lambda x, y: x + y, 1.))(\n            constant_op.constant(2.)))\n\n  def test_functools_partial_new_default(self):\n    def f(x=3, y=7):\n      return x + y\n\n    func = def_function.function(functools.partial(f, y=6))\n    self.assertEqual(func().numpy(), 9)\n    self.assertEqual(func(y=8).numpy(), 11)\n\n  def test_functools_partial_keywords(self):\n    def f(x, y):\n      return x + y\n\n    func = def_function.function(\n        functools.partial(f, x=array_ops.zeros([1]), y=array_ops.zeros([1])))\n    self.assertAllEqual(func(), [0.0])\n\n  def test_functools_partial_single_positional(self):\n    def f(x, y):\n      return x + y\n\n    func = def_function.function(\n        functools.partial(f, constant_op.constant(1)))\n    self.assertAllEqual(func(5), 6)\n\n  def test_complicated_partial_with_defaults(self):\n\n    def identity(*args):\n      return args\n\n    def dynamic_unroll(core_fn,\n                       input_sequence,\n                       initial_state,\n                       sequence_length=None,\n                       parallel_iterations=1,\n                       swap_memory=False):\n      del core_fn\n      self.assertIs(None, sequence_length)\n      self.assertEqual(1, parallel_iterations)\n      self.assertTrue(swap_memory)\n      return input_sequence, initial_state\n\n    input_sequence = random_ops.random_uniform([1, 1, 1])\n    initial_state = random_ops.random_uniform([1, 1])\n\n    func = def_function.function(\n        functools.partial(dynamic_unroll, identity, swap_memory=True))\n    func(input_sequence, initial_state)\n\n  def test_unspecified_default_argument(self):\n    wrapped = def_function.function(\n        lambda x, y=2: x + y,\n        input_signature=[tensor_spec.TensorSpec((), dtypes.int32)])\n    self.assertEqual(3, wrapped(constant_op.constant(1)).numpy())\n\n  def test_concrete_function_from_signature(self):\n\n    @def_function.function(\n        input_signature=[tensor_spec.TensorSpec(None, dtypes.float32)])\n    def compute(x):\n      return 2. * x\n\n    concrete = compute.get_concrete_function()\n    self.assertAllClose(1., concrete(constant_op.constant(0.5)))\n    concrete = compute.get_concrete_function(\n        tensor_spec.TensorSpec(None, dtypes.float32))\n    self.assertAllClose(4., concrete(constant_op.constant(2.)))\n    signature_args, _ = concrete.structured_input_signature\n    self.assertEqual(signature_args,\n                     (tensor_spec.TensorSpec(\n                         None, dtypes.float32, name='x'),))\n\n  def testInputSignatureMissingTensorSpecsMethod(self):\n\n    class MyModule(module.Module):\n\n      def f1(self, arg1, arg2, arg3):\n        pass\n\n      def f2(self, arg1, arg2, arg3, **kwargs):\n        pass\n\n      def f3(self, arg1, arg2, arg3, arg4=4, **kwargs):\n        pass\n\n      def f4(self, arg1, arg2, arg3, *args):\n        pass\n\n      def f5(self, arg1, arg2, arg3, *args, **kwargs):\n        pass\n\n      def f6(self, arg1, arg4=4, **kwargs):\n        return arg1 + arg4\n\n    m = MyModule()\n    tf_func_dec = def_function.function(\n        input_signature=(tensor_spec.TensorSpec([], dtypes.int32),))\n    error_msg = 'TensorSpecs are still required.*arg2.*arg3'\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(m.f1)(1, 2, 3)\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(m.f2)(1, 2, 3)\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(m.f3)(1, 2, 3)\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(m.f4)(1, 2, 3)\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(m.f5)(1, 2, 3)\n\n    self.assertEqual(tf_func_dec(m.f6)(1).numpy(), 5)\n\n  def testInputSignatureMissingTensorSpecsFunction(self):\n    tf_func_dec = def_function.function(\n        input_signature=(tensor_spec.TensorSpec([], dtypes.int32),))\n    error_msg = 'TensorSpecs are still required.*arg2.*arg3'\n    # pylint: disable=unused-argument\n    def f1(arg1, arg2, arg3):\n      pass\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(f1)(1, 2, 3)\n\n    def f2(arg1, arg2, arg3, **kwargs):\n      pass\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(f2)(1, 2, 3)\n\n    def f3(arg1, arg2, arg3, arg4=4, **kwargs):\n      pass\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(f3)(1, 2, 3)\n\n    def f4(arg1, arg2, arg3, *args):\n      pass\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(f4)(1, 2, 3)\n\n    def f5(arg1, arg2, arg3, *args, **kwargs):\n      pass\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(f5)(1, 2, 3)\n    # pyline: enable=unused-argument\n\n    def f6(arg1, arg4=4, **kwargs):\n      return arg1 + arg4\n    self.assertEqual(tf_func_dec(f6)(1).numpy(), 5)\n\n  def testInputSignatureMissingTensorSpecsLambdaFunction(self):\n    tf_func_dec = def_function.function(\n        input_signature=(tensor_spec.TensorSpec([], dtypes.int32),))\n    error_msg = 'TensorSpecs are still required.*arg2.*arg3'\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(lambda ar1, arg2, arg3: None)(1, 2, 3)\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(lambda arg1, arg2, arg3, **kwargs: None)(1, 2, 3)\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(lambda arg1, arg2, arg3, arg4=4, **kwargs: None)(1, 2, 3)\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(lambda arg1, arg2, arg3, *args: None)(1, 2, 3)\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(lambda arg1, arg2, arg3, *args, **kwargs: None)(1, 2, 3)\n\n    self.assertEqual(\n        tf_func_dec(lambda arg1, arg4=4, **kwargs: arg1 + arg4)(1).numpy(), 5)\n\n  @parameterized.named_parameters(('_method', 'method'),\n                                  ('_function', 'function'),\n                                  ('_lambda_function', 'lambda_function'))\n  def testInputSignaturePartialFuncMissingTensorSpecs(self, func_type):\n    if func_type == 'method':\n      class MyModule(module.Module):\n\n        def f(self, arg1, arg2, arg3, arg4=4):\n          return arg1 + arg2 + arg3 + arg4\n      f = MyModule().f\n    elif func_type == 'function':\n      def f(arg1, arg2, arg3, arg4=4):\n        return arg1 + arg2 + arg3 + arg4\n    else:  # lambda_function\n      f = lambda arg1, arg2, arg3, arg4=4: arg1 + arg2 + arg3 + arg4\n\n    tf_func_dec = def_function.function(\n        input_signature=(tensor_spec.TensorSpec([], dtypes.int32),))\n    with self.assertRaisesRegex(TypeError,\n                                'TensorSpecs are still required.*arg3'):\n      tf_func_dec(functools.partial(f, 1))(2, 3)\n\n    with self.assertRaisesRegex(TypeError,\n                                'TensorSpecs are still required.*arg2.*arg3'):\n      tf_func_dec(functools.partial(f, arg4=5))(1, 2, 3)\n\n    with self.assertRaisesRegex(TypeError,\n                                'TensorSpecs are still required.*arg3'):\n      tf_func_dec(functools.partial(f, 1, arg4=5))(2, 3)\n\n    self.assertAllEqual(tf_func_dec(functools.partial(f, 1, 2, arg4=5))(3),\n                        array_ops.constant(11))\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_variable_naming(self):\n    class HasVars(module.Module):\n\n      def __init__(self):\n        self.x = None\n        self.y = None\n        self.z = None\n\n      @def_function.function\n      def make_x(self):\n        if self.x is None:\n          self.x = variables.Variable(1., name='v')\n\n      def make_y(self):\n        if self.y is None:\n          self.y = variables.Variable(1., name='v')\n\n      def make_z(self):\n        if self.z is None:\n          with ops.name_scope('z_scope', skip_on_eager=False):\n            self.z = variables.Variable(1., name='z')\n\n    root = HasVars()\n    root.make_x()\n    root.make_y()\n    root.make_z()\n    self.assertEqual('v:0', root.x.name)\n    self.assertEqual('z_scope/z:0', root.z.name)\n\n  def test_concrete_function_keyword_arguments(self):\n    @def_function.function\n    def f(x):\n      return x\n\n    conc = f.get_concrete_function(\n        tensor_spec.TensorSpec(None, dtypes.float32, 'y'))\n    conc(y=constant_op.constant(3.0))\n    signature_args, _ = conc.structured_input_signature\n    self.assertEqual('y', signature_args[0].name)\n\n    conc = f.get_concrete_function(tensor_spec.TensorSpec(None, dtypes.float32))\n    conc(x=constant_op.constant(3.0))\n    signature_args, _ = conc.structured_input_signature\n    self.assertEqual('x', signature_args[0].name)\n\n    @def_function.function\n    def g(x):\n      return x[0]\n\n    conc = g.get_concrete_function(\n        [tensor_spec.TensorSpec(None, dtypes.float32, 'z'), 2])\n    conc(z=constant_op.constant(3.0))\n    signature_args, _ = conc.structured_input_signature\n    self.assertEqual('z', signature_args[0][0].name)\n\n  def testRuntimeErrorNotSticky(self):\n\n    @def_function.function\n    def fail(i):\n      control_flow_ops.Assert(math_ops.equal(i, 0), ['ick'])\n\n    fail(constant_op.constant(0))  # OK\n    with self.assertRaises(errors.InvalidArgumentError):\n      fail(constant_op.constant(1))  # InvalidArgument: \"ick\"\n    fail(constant_op.constant(0))  # OK\n\n  def testUnderscoreName(self):\n\n    @def_function.function\n    def f(_):\n      return _ + _\n\n    self.assertAllEqual(2.0, f(constant_op.constant(1.0)))\n\n  def test_serialization_signature_cache(self):\n\n    @def_function.function\n    def f(x, y):\n      return x, y\n\n    f(constant_op.constant([[3., 4.]]), constant_op.constant([2.]))\n    f(constant_op.constant([[3, 4, 5]]), constant_op.constant([2]))\n\n    signatures_args = set()\n    concrete_functions = f._list_all_concrete_functions_for_serialization()\n    for concrete_function in concrete_functions:\n      args, kwargs = concrete_function.structured_input_signature\n      signatures_args.add(args)\n      self.assertEqual(dict(), kwargs)\n\n    self.assertEqual(\n        signatures_args,\n        set(((tensor_spec.TensorSpec([1, 2], dtypes.float32, name='x'),\n              tensor_spec.TensorSpec([1], dtypes.float32, name='y')),\n             (tensor_spec.TensorSpec([1, 3], dtypes.int32, name='x'),\n              tensor_spec.TensorSpec([1], dtypes.int32, name='y')))))\n\n  @test_util.assert_no_garbage_created\n  def testFunctionReferenceCycles(self):\n    fn = def_function.function(lambda x: 2. * x)\n    fn(constant_op.constant(4.0))\n    weak_fn = weakref.ref(fn)\n    del fn\n    # Tests that the weak reference we made to the function is now dead, which\n    # means the object has been deleted. This should be true as long as the\n    # function itself is not involved in a reference cycle.\n    self.assertIs(None, weak_fn())\n\n  @test_util.assert_no_garbage_created\n  def testMethodReferenceCycles(self):\n    has_decorated_method = _HasDecoratedMethod()\n    has_decorated_method.f(constant_op.constant(5.))\n    weak_fn = weakref.ref(has_decorated_method.f)\n    del has_decorated_method\n    # Tests that the weak reference we made to the function is now dead, which\n    # means the object has been deleted. This should be true as long as the\n    # function itself is not involved in a reference cycle.\n    self.assertIs(None, weak_fn())\n\n  @test_util.assert_no_new_pyobjects_executing_eagerly\n  def testErrorMessageWhenGraphTensorIsPassedToEager(self):\n\n    @def_function.function\n    def failing_function():\n      a = constant_op.constant(1.)\n\n      with ops.init_scope():\n        _ = a + a\n\n    with self.assertRaisesRegex(\n        TypeError, re.compile('def_function_test.*out of scope', re.DOTALL)):\n      failing_function()\n\n  def testSymbolicTensorIllegalCaptureCallTimeError(self):\n    x = None\n\n    @def_function.function\n    def f1(a):\n      nonlocal x\n      x = a\n      return a\n\n    @def_function.function\n    def f2(b):\n      return b + x\n\n    f1(constant_op.constant(1))\n    with self.assertRaisesRegex(\n        TypeError, re.compile('def_function_test.*out of scope', re.DOTALL)):\n      f2(constant_op.constant(2))\n\n  def testSymbolicTensorIllegalCaptureTraceTimeError(self):\n\n    @def_function.function\n    def f(inputs):\n      num_steps, _ = inputs.shape[:2]\n      outputs = []\n      for t in math_ops.range(num_steps):\n        outputs.append(inputs[t])\n      return outputs\n\n    with self.assertRaisesRegex(errors.InaccessibleTensorError, 'out of scope'):\n      f(array_ops.zeros(shape=(8, 42, 3)))\n\n  def testNonUniqueNamesGetConcreteFunction(self):\n    @def_function.function\n    def non_unique_arg_names(x, **kwargs):\n      a, b, c = x\n      d = kwargs['d']\n      return a + b + c + d\n\n    concrete = non_unique_arg_names.get_concrete_function(\n        (tensor_spec.TensorSpec(None, dtypes.float32),\n         tensor_spec.TensorSpec(None, dtypes.float32),\n         tensor_spec.TensorSpec(None, dtypes.float32)),\n        d=tensor_spec.TensorSpec(None, dtypes.float32))\n    self.assertAllClose(\n        10.,\n        concrete(x=constant_op.constant(1.),\n                 x_1=constant_op.constant(2.),\n                 x_2=constant_op.constant(3.),\n                 d=constant_op.constant(4.)))\n    self.assertAllClose(\n        10.,\n        concrete(constant_op.constant(1.),\n                 constant_op.constant(2.),\n                 constant_op.constant(3.),\n                 constant_op.constant(4.)))\n\n  def testVariableCreatorScope(self):\n    created_variables = []\n    captured_variables = []\n\n    @def_function.function\n    def f():\n      if not created_variables:\n        created_variables.append(variables.Variable(1.))\n      return created_variables[0] + 1.\n\n    def capture_creator(next_creator, **kwargs):\n      created = next_creator(**kwargs)\n      captured_variables.append(created)\n      return created\n\n    with variable_scope.variable_creator_scope(capture_creator):\n      f()\n    self.assertEqual(created_variables, captured_variables)\n\n  def testVarAlreadyInitializedNoClobbering(self):\n    v_holder = []\n\n    @def_function.function\n    def add_var(x):\n      if not v_holder:\n        v = variables.Variable([1., 2.])\n        v_holder.append(v)\n        already_initialized = variables.Variable(3.)\n        with ops.init_scope():\n          already_initialized.assign(10.)\n        v_holder.append(already_initialized)\n      return v_holder[0] + v_holder[1] + x\n\n    add_var.get_concrete_function(constant_op.constant(2.))\n    self.assertAllClose([13., 14.], add_var(constant_op.constant(2.)))\n\n  def testSameVariableTwice(self):\n    v = variables.Variable(1.0)\n\n    @def_function.function\n    def add(a, b):\n      return a + b\n\n    self.assertAllEqual(add(v, v), 2.0)\n\n  def testVariableUpdate(self):\n    v1 = variables.Variable(1.0)\n    v2 = variables.Variable(2.0)\n    v3 = variables.Variable(4, dtype=dtypes.int32)\n\n    trace_count = [0]\n\n    @def_function.function\n    def double_variable(x):\n      trace_count[0] += 1\n      x.assign_add(x.read_value())\n\n    self.assertEqual(trace_count[0], 0)\n    double_variable(v1)\n    self.assertEqual(trace_count[0], 1)\n    self.assertEqual(self.evaluate(v1), 2.0)\n    double_variable(v2)\n    # No retracing because v2's data type and shape are the same as v1\n    self.assertEqual(trace_count[0], 1)\n    self.assertEqual(self.evaluate(v2), 4.0)\n    double_variable(v3)\n    # Retracing because of data type change\n    self.assertEqual(trace_count[0], 2)\n    self.assertEqual(self.evaluate(v3), 8)\n\n  def testShapeCache(self):\n    @def_function.function\n    def func(x):\n      return 2 * x\n\n    func_a = func.get_concrete_function(\n        tensor_spec.TensorSpec([None], dtypes.int32))\n    func_b = func.get_concrete_function(\n        tensor_spec.TensorSpec([None], dtypes.int32))\n\n    self.assertIs(func_a, func_b)\n\n  def testCacheWithinSaveContext(self):\n\n    @def_function.function\n    def func(x):\n      return 2 * x\n\n    func_a = func.get_concrete_function(constant_op.constant(2.))\n    func_b = func.get_concrete_function(constant_op.constant(2.))\n\n    self.assertIs(func_a, func_b)\n\n    with save_context.save_context(\n        save_options.SaveOptions(experimental_variable_policy=save_options\n                                 .VariablePolicy.EXPAND_DISTRIBUTED_VARIABLES)):\n      func_c = func.get_concrete_function(constant_op.constant(2.))\n\n    with save_context.save_context(\n        save_options.SaveOptions(\n            experimental_variable_policy=save_options.VariablePolicy.NONE)):\n      func_d = func.get_concrete_function(constant_op.constant(2.))\n\n    self.assertIsNot(func_a, func_c)\n    self.assertIsNot(func_a, func_d)\n\n  def testInitializationInNestedCall(self):\n    v_holder = []\n\n    @def_function.function\n    def add_var(x):\n      if not v_holder:\n        v = variables.Variable([1., 2.])\n        v_holder.append(v)\n        already_initialized = variables.Variable(3.)\n        with ops.init_scope():\n          already_initialized.assign(10.)\n        v_holder.append(already_initialized)\n      return v_holder[0] + v_holder[1] + x\n\n    @def_function.function\n    def wrapper(x):\n      return add_var(x)\n\n    self.assertAllClose([13., 14.], wrapper(constant_op.constant(2.)))\n    v_holder[1].assign(11.)\n    self.assertAllClose([14., 15.], wrapper(constant_op.constant(2.)))\n\n  @test_util.run_gpu_only\n  def testDeviceAnnotationRespected(self):\n    a = []\n\n    @def_function.function()\n    def create_variable():\n      with ops.init_scope():\n        initial_value = random_ops.random_uniform(\n            (2, 2), maxval=1000000, dtype=dtypes.int64)\n\n      if not a:\n        with ops.device('CPU:0'):\n          a.append(resource_variable_ops.ResourceVariable(initial_value))\n\n      return a[0].read_value()\n\n    create_variable()\n    self.assertRegex(a[0].device, 'CPU')\n\n  @test_util.run_gpu_only\n  def testDeviceAnnotationForInitializerRespected(self):\n    a = []\n    initial_value = []\n\n    def initial_value_fn():\n      initial_value.append(random_ops.random_uniform((2, 3)))\n      return initial_value[0]\n\n    @def_function.function()\n    def create_variable():\n      with ops.init_scope():\n        if not a:\n          a.append(variables.Variable(initial_value_fn))\n\n    with ops.device('CPU:0'):\n      create_variable()\n    self.assertRegex(a[0].device, 'CPU')\n    self.assertRegex(initial_value[0].device, 'CPU')\n\n  def testDecorate(self):\n    func = def_function.function(lambda: 1)\n    def decorator(f):\n      return lambda: 1 + f()\n\n    func._decorate(decorator)\n    self.assertEqual(func().numpy(), 2)\n\n  @parameterized.parameters(*itertools.product(\n      (None, (tensor_spec.TensorSpec([]),)),  # input_signature\n      (True, False),                          # autograph\n      (None, converter.Feature.ALL),          # autograph_options\n      (None, 'foo.bar'),                      # implements\n      (None, True, False),                    # relax_shapes\n      (True, False),                          # compile\n      (True, False),                          # override_function\n  ))\n\n  def testClone(self, input_signature, autograph, autograph_options, implements,\n                relax_shapes, compile_, override_function):\n    original_py_function = lambda x: x\n\n    compile_ = False\n    func = def_function.function(\n        func=original_py_function,\n        input_signature=input_signature,\n        autograph=autograph,\n        experimental_implements=implements,\n        experimental_autograph_options=autograph_options,\n        experimental_relax_shapes=relax_shapes,\n        jit_compile=compile_)\n\n    if override_function:\n      cloned_py_function = lambda x: x + 1\n    else:\n      cloned_py_function = original_py_function\n\n    cloned = func._clone(python_function=cloned_py_function)\n\n    self.assertEqual(cloned_py_function, cloned._python_function)\n    self.assertEqual(func._name, cloned._name)\n    self.assertEqual(input_signature, cloned._input_signature)\n    self.assertEqual(autograph, cloned._autograph)\n    self.assertEqual(implements, cloned._implements)\n    self.assertEqual(autograph_options, cloned._experimental_autograph_options)\n    self.assertEqual(relax_shapes, cloned._experimental_relax_shapes)\n    self.assertEqual(compile_, cloned._jit_compile)\n\n    # This test does not run with XLA JIT support linked in so we can only check\n    # the output of the function if compile is disabled.\n    if not compile_:\n      x = array_ops.zeros([])\n      self.assertEqual(self.evaluate(cloned(x)),\n                       self.evaluate(cloned_py_function(x)))\n\n  def testLiftPlaceholderInitializedVariable(self):\n    with ops.Graph().as_default():\n      var_list = []\n\n      @def_function.function\n      def use_variable():\n        if not var_list:\n          initial_value = array_ops.placeholder(shape=[], dtype=dtypes.float32)\n          v = variables.Variable(initial_value)\n          var_list.append(v)\n        return var_list[0] + 1.\n\n      var_plus_one = use_variable()\n      with self.session() as session:\n        init_op = var_list[0].initializer\n        session.run(init_op, feed_dict={init_op.inputs[1]: 2.})\n        self.assertEqual(3., session.run(var_plus_one))\n\n  def testDecorate_rejectedAfterTrace(self):\n    func = def_function.function(lambda: 1)\n    self.assertEqual(func().numpy(), 1)\n    msg = 'Functions cannot be decorated after they have been traced.'\n    with self.assertRaisesRegex(ValueError, msg):\n      func._decorate(lambda f: f)\n\n  def testGetConcreteFunctionGraphLifetime(self):\n\n    @def_function.function\n    def func():\n      pass\n\n    graph = func.get_concrete_function().graph\n    del func\n\n    # If the graph is deleted, then an exception is raised on reading `captures`\n    self.assertEmpty(graph.captures)\n\n  @parameterized.parameters(*itertools.product(\n      (None, (tensor_spec.TensorSpec([]),)),  # input_signature\n      (True, False),  # autograph\n      (None, converter.Feature.ALL),  # autograph_options\n      (None, 'foo.bar'),  # implements\n      (None, True, False),  # relax_shapes\n  ))\n\n  def test_pickle(self, input_signature, autograph, autograph_options,\n                  implements, relax_shapes):\n    \"\"\"@function objects can be pickled and unpickled.\"\"\"\n    original_py_function = undecorated_function\n\n    func = def_function.function(\n        func=original_py_function,\n        input_signature=input_signature,\n        autograph=autograph,\n        experimental_implements=implements,\n        experimental_autograph_options=autograph_options,\n        experimental_relax_shapes=relax_shapes,\n    )\n\n    cloned = pickle.loads(pickle.dumps(func))\n\n    self.assertEqual(func._name, cloned._name)\n    self.assertEqual(input_signature, cloned._input_signature)\n    self.assertEqual(autograph, cloned._autograph)\n    self.assertEqual(implements, cloned._implements)\n    self.assertEqual(autograph_options, cloned._experimental_autograph_options)\n    self.assertEqual(relax_shapes, cloned._experimental_relax_shapes)\n\n    x = array_ops.ones([])\n    self.assertEqual(self.evaluate(cloned(x)), self.evaluate(func(x)))\n\n  def test_frequent_retracing_warning(self):\n    if sys.version_info[0] < 3:\n      self.skipTest('self.assertLogs() call is not available in Python 2.')\n\n    @def_function.function\n    def f(x):\n      return x\n\n    with self.assertLogs(level='WARN') as logs:\n      f(1)\n      f(2)\n      f(3)\n      f(4)\n      self.assertEmpty(logs.output)\n      f(5)\n\n    self.assertLen(logs.output, 1)\n    self.assertIn('Tracing is expensive', logs.output[0])\n\n  def test_frequent_retracing_warning_lambda(self):\n    if sys.version_info[0] < 3:\n      self.skipTest('self.assertLogs() call is not available in Python 2.')\n\n    f = def_function.function(lambda x: x)\n\n    with self.assertLogs(level='WARN') as logs:\n      f(1)\n      f(2)\n      f(3)\n      f(4)\n      f(5)\n\n    self.assertLen(logs.output, 1)\n    self.assertIn('Tracing is expensive', logs.output[0])\n\n  def test_frequent_retracing_warning_method(self):\n    if sys.version_info[0] < 3:\n      self.skipTest('self.assertLogs() call is not available in Python 2.')\n\n    class Foo(object):\n\n      @def_function.function\n      def f(self, x):\n        return x\n\n    f = Foo().f\n\n    with self.assertLogs(level='WARN') as logs:\n      f(1)\n      f(2)\n      f(3)\n      f(4)\n      f(5)\n\n    self.assertLen(logs.output, 1)\n    self.assertIn('Tracing is expensive', logs.output[0])\n\n  def test_frequent_retracing_warning_two_independent_tf_functions(self):\n    if sys.version_info[0] < 3:\n      self.skipTest('self.assertLogs() call is not available in Python 2.')\n\n    @def_function.function\n    def f(x):\n      return x\n\n    @def_function.function\n    def g(x):\n      return x\n\n    with self.assertLogs(level='WARN') as logs:\n      f(1)\n      f(2)\n      f(3)\n      f(4)\n      g(1)\n      g(2)\n      g(3)\n      g(4)\n      g(5)\n\n    self.assertLen(logs.output, 1)\n    self.assertIn('Tracing is expensive', logs.output[0])\n\n  def test_frequent_retracing_warning_nested(self):\n    if sys.version_info[0] < 3:\n      self.skipTest('self.assertLogs() call is not available in Python 2.')\n\n    @def_function.function\n    def inner(x):\n      return x + 1\n\n    @def_function.function\n    def outer1(x):\n      return inner(x) * 2\n\n    @def_function.function\n    def outer2(x):\n      return inner(x) * 3\n\n    with self.assertLogs(level='WARN') as logs:\n      inner(1)\n      inner(2)\n      inner(3)\n      inner(4)\n\n      outer1(5)\n      outer1(6)\n      outer1(7)\n      outer1(8)\n\n      outer2(9)\n      outer2(10)\n      outer2(11)\n      outer2(12)\n\n      self.assertEmpty(logs.output)\n\n      outer2(13)\n\n      self.assertLen(logs.output, 1)\n      self.assertIn('Tracing is expensive', logs.output[0])\n\n  def test_frequent_retracing_warning_on_reinstantiation(self):\n    if sys.version_info[0] < 3:\n      self.skipTest('self.assertLogs() call is not available in Python 2.')\n\n    with self.assertLogs(level='WARN') as logs:\n      for i in range(5):\n\n        @def_function.function\n        def f(x):\n          return x\n\n        f(i)\n\n        if i < 4:\n          self.assertEmpty(logs.output)\n\n    self.assertLen(logs.output, 1)\n    self.assertIn('Tracing is expensive', logs.output[0])\n\n  def test_restored_function_retracing_warning(self):\n\n    class Foo(Checkpoint):\n\n      @def_function.function\n      def __call__(self, x):\n        return x\n\n    f_flexible = Foo()\n    _ = f_flexible.__call__.get_concrete_function(\n        tensor_spec.TensorSpec(shape=[None], dtype=dtypes.int32))\n    tmp_dir = self.create_tempdir()\n    save(f_flexible, tmp_dir.full_path)\n    restored_f_flexible = load(tmp_dir.full_path)\n\n    f_fixed_shape = Foo()\n\n    with self.assertLogs(level='WARN') as logs:\n      restored_f_flexible(constant_op.constant([1], dtypes.int32))\n      restored_f_flexible(constant_op.constant([1, 2], dtypes.int32))\n      restored_f_flexible(constant_op.constant([1, 2, 3], dtypes.int32))\n      restored_f_flexible(constant_op.constant([1, 2, 3, 4], dtypes.int32))\n      restored_f_flexible(constant_op.constant([1, 2, 3, 4, 5], dtypes.int32))\n      self.assertEmpty(logs.output)\n\n      f_fixed_shape(constant_op.constant([1], dtypes.int32))\n      f_fixed_shape(constant_op.constant([1, 2], dtypes.int32))\n      f_fixed_shape(constant_op.constant([1, 2, 3], dtypes.int32))\n      f_fixed_shape(constant_op.constant([1, 2, 3, 4], dtypes.int32))\n      f_fixed_shape(constant_op.constant([1, 2, 3, 4, 5], dtypes.int32))\n      self.assertLen(logs.output, 1)\n      self.assertIn('Tracing is expensive', logs.output[0])\n\n  def test_retracing_warning_limits(self):\n\n    @def_function.function\n    def my_func(x):\n      return x\n\n    with self.assertLogs(level='WARN') as logs:\n      for i in range(10):\n        my_func(i)\n\n      self.assertLen(logs.output, 2)\n\n  def test_experimental_get_tracing_count_function(self):\n\n    @def_function.function\n    def double(a):\n      return a + a\n\n    double(constant_op.constant(1))\n    double(constant_op.constant(2))\n    self.assertAllEqual(double.experimental_get_tracing_count(), 1)\n    double(constant_op.constant('a'))\n    self.assertAllEqual(double.experimental_get_tracing_count(), 2)\n\n  def test_experimental_get_tracing_count_method(self):\n\n    class TestClass():\n\n      @def_function.function\n      def testDouble(self, a):\n        return a + a\n\n    obj1 = TestClass()\n    obj1.testDouble(constant_op.constant(1))\n    obj1.testDouble(constant_op.constant(2))\n    obj1.testDouble(constant_op.constant(1.1))\n    self.assertAllEqual(obj1.testDouble.experimental_get_tracing_count(), 2)\n    obj2 = TestClass()\n    obj2.testDouble(constant_op.constant(1))\n    obj2.testDouble(constant_op.constant(1.1))\n    obj2.testDouble(constant_op.constant('a'))\n    self.assertAllEqual(obj2.testDouble.experimental_get_tracing_count(), 3)\n    self.assertAllEqual(obj1.testDouble.experimental_get_tracing_count(), 2)\n\n\nif __name__ == '__main__':\n  ops.enable_eager_execution()\n  test.main()\n", "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n# pylint: disable=unidiomatic-typecheck\n\"\"\"Defun decorator for defining graph-mode functions.\"\"\"\n\nimport collections\nimport functools\nimport itertools\nimport pprint\nimport threading\nimport types as types_lib\nimport weakref\n\nimport numpy as np\nimport six\nfrom six.moves import map\n\nfrom tensorflow.core.framework import attr_value_pb2\nfrom tensorflow.core.framework import function_pb2\nfrom tensorflow.python import pywrap_tfe\nfrom tensorflow.python.client import pywrap_tf_session\nfrom tensorflow.python.eager import backprop\nfrom tensorflow.python.eager import backprop_util\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.eager import execute\nfrom tensorflow.python.eager import forwardprop_util\nfrom tensorflow.python.eager import function_trace_type\nfrom tensorflow.python.eager import monitoring\nfrom tensorflow.python.eager import tape\nfrom tensorflow.python.eager.graph_only_ops import graph_placeholder\nfrom tensorflow.python.framework import c_api_util\nfrom tensorflow.python.framework import composite_tensor\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import device as pydev\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import error_interpolation\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import func_graph as func_graph_module\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import tensor_shape\nfrom tensorflow.python.framework import tensor_spec\nfrom tensorflow.python.framework import type_spec\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import control_flow_ops\nfrom tensorflow.python.ops import default_gradient\nfrom tensorflow.python.ops import functional_ops\nfrom tensorflow.python.ops import gradients_util\nfrom tensorflow.python.ops import handle_data_util\nfrom tensorflow.python.ops import resource_variable_ops\nfrom tensorflow.python.platform import tf_logging as logging\nfrom tensorflow.python.profiler import trace\nfrom tensorflow.python.saved_model import save_context\nfrom tensorflow.python.types import core\nfrom tensorflow.python.util import _pywrap_utils\nfrom tensorflow.python.util import compat\nfrom tensorflow.python.util import function_utils\nfrom tensorflow.python.util import lazy_loader\nfrom tensorflow.python.util import memory\nfrom tensorflow.python.util import nest\nfrom tensorflow.python.util import object_identity\nfrom tensorflow.python.util import tf_decorator\nfrom tensorflow.python.util import tf_inspect\nfrom tensorflow.python.util.tf_export import tf_export\n\n# Loaded lazily due to a circular dependency (roughly\n# tf.function->autograph->->dataset->tf.function).\n# TODO(b/133251390): Use a regular import.\nag_ctx = lazy_loader.LazyLoader(\n    \"ag_ctx\", globals(),\n    \"tensorflow.python.autograph.core.ag_ctx\")\nnp_arrays = lazy_loader.LazyLoader(\n    \"np_arrays\", globals(),\n    \"tensorflow.python.ops.numpy_ops.np_arrays\")\n\n\nFORWARD_FUNCTION_ATTRIBUTE_NAME = \"forward_function_name\"\nBACKWARD_FUNCTION_ATTRIBUTE_NAME = \"backward_function_name\"\nIMPLEMENTS_ATTRIBUTE_NAME = \"_implements\"\nSHARED_RENDEZVOUS_ATTRIBUTE_NAME = \"shared_rendezvous\"\n# A temporary flag. Turning this on will allow tf.function to aggressively avoid\n# retracing ResourceVariable inputs. This feature will change tf.function's\n# Variable tracing behavior, hence we want to limit the potential blockers that\n# are not detected by Global TAP.\n# TODO(jiaweix): remove this flag and related args (b/198782192)\nENCODE_VARIABLES_BY_RESOURCE_ID = True\n# TODO(b/201533914): Remove this flag and related args\nUSE_FULL_TRACE_TYPE = False\n\n_graph_building_time_counter = monitoring.Counter(\n    \"/tensorflow/core/tf_function/graph_building_time_usecs\",\n    \"Time for tf.function to build a graph (us).\")\n\n\nCacheKey = collections.namedtuple(\"CacheKey\", [\n    \"input_signature\",\n    \"parent_graph\",\n    \"device_functions\",\n    \"colocation_stack\",\n    \"in_cross_replica_context\",\n    \"variable_policy\",\n    \"xla_context_id\",\n])\n\n\ndef _type_spec_for(x):\n  \"\"\"Returns a TypeSpec for `x`, or `None` if `x` doesn't have a TensorSpec.\"\"\"\n  if isinstance(x, ops.Tensor):\n    return tensor_spec.TensorSpec.from_tensor(x)\n  elif isinstance(x, type_spec.TypeSpec):\n    return x\n  elif isinstance(x, composite_tensor.CompositeTensor):\n    return x._type_spec  # pylint: disable=protected-access\n  else:\n    return None\n\n\ndef _is_type_subset(a, b):\n  \"\"\"Returns true if TypeSpec `b` is a subset of type `a` (or if a is None.)\"\"\"\n  if a is None:\n    return True\n  else:\n    return a.most_specific_compatible_type(b) == a\n\n\ndef _shape_relaxed_type_for_composite_tensor(x):\n  \"\"\"Returns a shape-relaxed TypeSpec for x (if composite) or x (if not).\"\"\"\n  if isinstance(x, composite_tensor.CompositeTensor):\n    # pylint: disable=protected-access\n    return x._type_spec._with_tensor_ranks_only()\n  else:\n    return x\n\n\ndef common_shape(x, y):\n  \"\"\"Find a `TensorShape` that is compatible with both `x` and `y`.\"\"\"\n  if x is None != y is None:\n    raise RuntimeError(\n        \"Cannot find a common shape when LHS shape is None but RHS shape \"\n        f\"is not (or vice versa): {x} vs. {y}.\")\n  if x is None:\n    return None  # The associated input was not a Tensor, no shape generated.\n  if not isinstance(x, tensor_shape.TensorShape):\n    raise TypeError(f\"`x` must be a TensorShape, got type {type(x)}.\")\n  if not isinstance(y, tensor_shape.TensorShape):\n    raise TypeError(f\"`y` must be a TensorShape, got type {type(y)}.\")\n  if x.rank != y.rank or x.rank is None:\n    return tensor_shape.TensorShape(None)\n  dims = []\n  for dim_x, dim_y in zip(x.dims, y.dims):\n    if (dim_x != dim_y\n        or tensor_shape.dimension_value(dim_x) is None\n        or tensor_shape.dimension_value(dim_y) is None):\n      dims.append(None)\n    else:\n      dims.append(tensor_shape.dimension_value(dim_x))\n  return tensor_shape.TensorShape(dims)\n\n\ndef is_same_structure(structure1,\n                      structure2,\n                      check_values=False):\n  \"\"\"Check two structures for equality, optionally of types and of values.\"\"\"\n  try:\n    nest.assert_same_structure(structure1, structure2, expand_composites=True)\n  except (ValueError, TypeError):\n    return False\n  if check_values:\n    flattened1 = nest.flatten(structure1, expand_composites=True)\n    flattened2 = nest.flatten(structure2, expand_composites=True)\n    # First check the types to avoid AttributeErrors.\n    if any(type(f1) != type(f2) for f1, f2 in zip(flattened1, flattened2)):\n      return False\n    return flattened1 == flattened2\n  return True\n\n\ndef _parse_func_attrs(attributes):\n  \"\"\"Convert the keyword arguments into function_def attributes.\n\n  Currently only support primitive types: bool, int, float and string.\n\n  Args:\n    attributes: the dictionary of attributes.\n  Returns:\n    A dict of attributes where the key is the name of attribute and the value\n      is the AttrValue proto.\n  Raises:\n    ValueError: If the kwargs contains unallowlisted name or unsupported value\n      types.\n  \"\"\"\n  attrs = {}\n  for key, value in attributes.items():\n    if isinstance(value, attr_value_pb2.AttrValue):\n      attrs[key] = value\n    # bool type check has to happen before int since bool is a subclass of int.\n    elif isinstance(value, bool):\n      attrs[key] = attr_value_pb2.AttrValue(b=value)\n    elif isinstance(value, int):\n      attrs[key] = attr_value_pb2.AttrValue(i=value)\n    elif isinstance(value, float):\n      attrs[key] = attr_value_pb2.AttrValue(f=value)\n    elif isinstance(value, (str, bytes, six.text_type)):\n      attrs[key] = attr_value_pb2.AttrValue(s=compat.as_bytes(value))\n    else:\n      raise ValueError(f\"Attribute {key} must be bool, int, float, string, or \"\n                       f\"AttrValue. Got {type(value)}.\")\n  return attrs\n\n\nclass _InterpolateFunctionError(object):\n  \"\"\"Context Manager that interpolates the exception from 'top_level_func'.\"\"\"\n\n  __slots__ = [\"_func\"]\n\n  def __init__(self, top_level_func):\n    self._func = top_level_func\n\n  def __enter__(self):\n    pass\n\n  def __exit__(self, typ, exc, tb):\n    if not exc or not isinstance(exc, errors.OpError):\n      return False\n    message = compat.as_text(exc.message)\n    _, tags = error_interpolation.parse_message(message)\n    g = None\n    func_stack = []\n    for t in tags:\n      if t.type == \"function_node\":\n        # TODO(mdan): Tests should cover this.\n        if t.name == compat.as_str(self._func.name):\n          g = self._func.graph\n        elif g:\n          next_func = g._get_function(t.name)  # pylint: disable=protected-access\n          if next_func is not None and isinstance(next_func,\n                                                  _EagerDefinedFunction):\n            g = next_func.graph\n        if g:\n          func_stack.append(g.name)\n        else:\n          func_stack.append(\"<unknown>\")\n    if g:\n      message = error_interpolation.interpolate(message, g)\n      if len(func_stack) >= 2:\n        message += \"\\n\\nFunction call stack:\\n\"\n        message += \" -> \".join(func_stack)\n        message += \"\\n\"\n      exc._message = message  # pylint: disable=protected-access\n    return False\n\n\n_function_callbacks = set()\n\n\ndef add_function_callback(function_callback):\n  \"\"\"Add a callback function for Function creation.\n\n  The callback function has the signature:\n\n    `def function_callback(function, name, graph, inputs, outputs):`\n\n  where:\n  - `function`: _EagerDefinedFunction being created before finalizing the graph.\n      Do not modify the function directly but instead modify the graph.\n  - `name`: name of the function.\n  - `graph`: Graph of the function.\n  - `inputs`: `tuple` of tensors used as inputs to the function.\n  - `outputs`: `tuple` of tensors used as outputs from the function.\n\n  The callback is at the top of the `_EagerDefinedFunction` construction, giving\n  callback an opportunity to make the last edits to the graph. Do not make\n  changes to `graph, inputs`, and `outputs` manually, but, instead, set the\n  `graph` as the default then define ops.\n\n  Repeated registration of the same callback function is idempotent.\n  After a callback is added, it can be removed with the\n  `remove_function_callback()` method.\n\n  Args:\n    function_callback: The callback to add.\n  \"\"\"\n  _function_callbacks.add(function_callback)\n\n\ndef remove_function_callback(function_callback):\n  \"\"\"Remove an already-added function callback.\n\n  See the doc string of `add_function_callback()` for more information.\n\n  Args:\n    function_callback: The callback to remove.\n  \"\"\"\n  _function_callbacks.remove(function_callback)\n\n\ndef clear_function_callbacks():\n  \"\"\"Clear all function callbacks, if any have been regisered.\"\"\"\n  _function_callbacks.clear()\n\n\n_FORWARD_PREFIX = \"__forward_\"\n_BACKWARD_PREFIX = \"__backward_\"\n_INFERENCE_PREFIX = \"__inference_\"\n\n\ndef _forward_name(n):\n  \"\"\"The name of a generated forward defun named n.\"\"\"\n  return \"%s%s_%s\" % (_FORWARD_PREFIX, n, ops.uid())\n\n\ndef _backward_name(n):\n  \"\"\"The name of a generated backward defun named n.\"\"\"\n  return \"%s%s_%s\" % (_BACKWARD_PREFIX, n, ops.uid())\n\n\ndef _inference_name(n):\n  \"\"\"The name of a forward-but-no-gradient defun named n.\"\"\"\n  return \"%s%s_%s\" % (_INFERENCE_PREFIX, n, ops.uid())\n\n\ndef _enclosing_xla_context():\n  \"\"\"Returns the XLAControlFlowContext, which exists inside a tpu.rewrite().\"\"\"\n  graph = ops.get_default_graph()\n  while graph is not None:\n    # pylint: disable=protected-access\n    context_ = graph._get_control_flow_context()\n    # pylint: enable=protected-access\n    while context_ is not None:\n      if isinstance(context_, control_flow_ops.XLAControlFlowContext):\n        return context_\n      context_ = context_.outer_context\n    # This may be a FuncGraph due to defuns or v2 control flow. We need to\n    # find the original graph with the XLAControlFlowContext.\n    graph = getattr(graph, \"outer_graph\", None)\n  return None\n\n\nclass _EagerDefinedFunctionDeleter(object):\n  \"\"\"Unregister function from eager context.\"\"\"\n\n  __slots__ = [\"name\"]\n\n  def __init__(self, name):\n    self.name = name\n\n  def __del__(self):\n    try:\n      context.remove_function(self.name)\n    except TypeError:\n      # Suppress some exceptions, mainly for the case when we're running on\n      # module deletion. Things that can go wrong include the context module\n      # already being unloaded, self._handle._handle_data no longer being\n      # valid, and so on. Printing warnings in these cases is silly\n      # (exceptions raised from __del__ are printed as warnings to stderr).\n      pass  # 'NoneType' object is not callable when the handle has been\n      # partially unloaded.\n    except AttributeError:\n      pass  # 'NoneType' object has no attribute 'eager_mode' when context has\n      # been unloaded. Will catch other module unloads as well.\n\n\nclass FunctionAlreadyGarbageCollectedError(Exception):\n\n  def __init__(self, function_name):\n    super(FunctionAlreadyGarbageCollectedError, self).__init__(\n        \"{} has already been garbage collected and cannot be called.\".format(\n            function_name))\n\n\n# TODO(apassos) get rid of this by splitting framework.function._DefinedFunction\n# so it doesn't have the definition-generating logic and is just a container for\n# an already-defined function.\nclass _EagerDefinedFunction(object):\n  \"\"\"Callable with the interface of `framework.function._DefinedFunction`.\n\n  `_EagerDefinedFunction` encapsulates a function definition and its properties,\n  and it provides a method for calling the encapsulated function. Some Ops\n  take functions as attributes, which have type `func`; an instance of this\n  class may be provided as the value of these `func` attributes.\n  \"\"\"\n\n  def __init__(self, name, graph, inputs, outputs, attrs):\n    \"\"\"Initializes an eager defined function.\n\n    Args:\n      name: str, the name for the created function.\n      graph: Graph, the graph containing the operations in the function\n      inputs: the tensors in the graph to be used as inputs to the function\n      outputs: the tensors in the graph which will be outputs from the function\n      attrs: dict mapping names of attributes to their AttrValue values\n    \"\"\"\n    for function_callback in _function_callbacks:\n      function_callback(self, name, graph, tuple(inputs), tuple(outputs))\n\n    input_ops = set(arg.op for arg in inputs)\n    operations = [op for op in graph.get_operations() if op not in input_ops]\n\n    graph_output_names = graph._output_names  # pylint: disable=protected-access\n    if (graph_output_names is not None and\n        all(ops.tensor_id(t) in graph_output_names for t in outputs)):\n      output_names = [\n          compat.as_bytes(graph_output_names[ops.tensor_id(t)]) for t in outputs\n      ]\n      if len(set(output_names)) != len(output_names):\n        # There are duplicate names for some reason, probably an invalid\n        # signature. Revert to auto-naming.\n        output_names = []\n    else:\n      output_names = []\n    fn = pywrap_tf_session.TF_GraphToFunction_wrapper(\n        graph._c_graph,  # pylint: disable=protected-access\n        compat.as_str(name),\n        False,\n        [o._c_op for o in operations],  # pylint: disable=protected-access\n        [t._as_tf_output() for t in inputs],  # pylint: disable=protected-access\n        [t._as_tf_output() for t in outputs],  # pylint: disable=protected-access\n        output_names,\n        [o._c_op for o in graph.control_outputs],  # pylint: disable=protected-access\n        [],  # control_output_names\n        None,\n        compat.as_str(\"\"))\n\n    for name, attr_value in attrs.items():\n      serialized = attr_value.SerializeToString()\n      # TODO(iga): this creates and deletes a new TF_Status for every attr.\n      # It might be worth creating a convenient way to re-use status.\n      pywrap_tf_session.TF_FunctionSetAttrValueProto(fn, compat.as_str(name),\n                                                     serialized)\n\n    # TODO(apassos) avoid creating a FunctionDef (specially to grab the\n    # signature, but also in general it's nice not to depend on it.\n    with c_api_util.tf_buffer() as buffer_:\n      pywrap_tf_session.TF_FunctionToFunctionDef(fn, buffer_)\n      proto_data = pywrap_tf_session.TF_GetBuffer(buffer_)\n    function_def = function_pb2.FunctionDef()\n    function_def.ParseFromString(compat.as_bytes(proto_data))\n    self._name = compat.as_bytes(function_def.signature.name)\n    with ops.init_scope():\n      if context.executing_eagerly():\n        context.ensure_initialized()\n        context.add_function(fn)\n        self._function_deleter = _EagerDefinedFunctionDeleter(self.name)\n        self._registered_on_context = True\n    self.definition = function_def\n    self.signature = function_def.signature\n    self._num_outputs = len(self.signature.output_arg)\n    self._output_types = [o.type for o in self.signature.output_arg]\n    self._output_shapes = [o.shape for o in outputs]\n    self._control_captures = graph.control_captures\n    # Shallow copy outputs since ConcreteFunction may mutate it.\n    self._func_graph_outputs = list(outputs)\n    self.grad_func_name = None\n    self.python_grad_func = None\n    self._c_func = c_api_util.ScopedTFFunction(fn)\n    self._grad_func = None\n    self.graph = graph\n    self._stateful_ops = tuple(op for op in operations if op._is_stateful)  # pylint: disable=protected-access\n\n  def add_to_graph(self, g=None):\n    \"\"\"Add the function to the current context or a graph, if supplied.\n\n    Args:\n      g: the graph to add the function to. If not supplied, the function will\n        be added to the current context.\n    \"\"\"\n    # pylint: disable=protected-access\n    if not g and context.executing_eagerly():\n      ctx = context.context()\n      if not ctx.has_function(self.name):\n        ctx.add_function_def(self.definition)\n    else:\n      if not g._is_function(self.name):\n        g._add_function(self)\n      for f in self.graph._functions.values():\n        if not g._is_function(f.name):\n          g._add_function(f)\n    # pylint: enable=protected-access\n\n  @property\n  def name(self):\n    return self._name\n\n  @property\n  def stateful_ops(self):\n    return self._stateful_ops\n\n  def call(self, ctx, args, cancellation_manager=None):\n    \"\"\"Calls this function with `args` as inputs.\n\n    `ConcreteFunction` execution respects device annotations only if the\n    function won't be compiled with xla.\n\n    Args:\n      ctx: a Context object\n      args: a list of arguments to supply this function with.\n      cancellation_manager: a `CancellationManager` object that can be used to\n        cancel function execution.\n\n    Returns:\n      The outputs of the function call.\n\n    Raises:\n      ValueError: if the number of arguments is incorrect.\n      FunctionAlreadyGarbageCollectedError: if the function is no longer\n        available to be called because it has been garbage collected.\n    \"\"\"\n    if len(args) != len(self.signature.input_arg):\n      raise ValueError(\n          f\"Signature specifies {len(list(self.signature.input_arg))} \"\n          f\"arguments, got: {len(args)}.\")\n\n    # If the `ScopedTFFunction` (accessed via `_c_func`) has already been\n    # cleaned up as a part of garbage collection, this `_EagerDefinedFunction`\n    # should also be garbage and is likely being called as part of a `__del__`\n    # elsewhere. In that case, there's nothing we can do, so we raise an\n    # exception for the caller to handle.\n    if self._c_func.has_been_garbage_collected:\n      raise FunctionAlreadyGarbageCollectedError(self.name)\n\n    function_call_options = ctx.function_call_options\n    if function_call_options.config_proto_serialized is None:\n      config = function_utils.get_disabled_rewriter_config()\n    else:\n      config = function_call_options.config_proto_serialized\n    executor_type = function_call_options.executor_type or \"\"\n\n    executing_eagerly = ctx.executing_eagerly()\n    attrs = (\"executor_type\", executor_type, \"config_proto\", config)\n    if executing_eagerly:\n      with _InterpolateFunctionError(self):\n        if cancellation_manager is None:\n          outputs = execute.execute(\n              str(self.signature.name),\n              num_outputs=self._num_outputs,\n              inputs=args,\n              attrs=attrs,\n              ctx=ctx)\n        else:\n          outputs = execute.execute_with_cancellation(\n              str(self.signature.name),\n              num_outputs=self._num_outputs,\n              inputs=args,\n              attrs=attrs,\n              ctx=ctx,\n              cancellation_manager=cancellation_manager)\n      # Replace empty list with None\n      outputs = outputs or None\n    else:\n      # TODO(akshayka): Either remove this if the FunctionLibraryRuntime\n      # creates `PartitionedCallOp` kernels by default, or remove the previous\n      # branch if a TPU kernel is registered for `PartitionedCall`.\n      with _InterpolateFunctionError(self):\n        with ops.control_dependencies(self._control_captures):\n          # The caller must use record_operation to record this operation in the\n          # eager case, so we enforce the same requirement for the non-eager\n          # case by explicitly pausing recording. We don't have a gradient\n          # registered for PartitionedCall, so recording this operation confuses\n          # forwardprop code (GradientTape manages to ignore it).\n          with tape.stop_recording():\n            outputs = functional_ops.partitioned_call(\n                args=args,\n                f=self,\n                tout=self._output_types,\n                executing_eagerly=executing_eagerly,\n                config=config,\n                executor_type=executor_type)\n\n    for i, func_graph_output in enumerate(self._func_graph_outputs):\n      handle_data_util.copy_handle_data(func_graph_output, outputs[i])\n    if executing_eagerly:\n      return outputs\n    else:\n      # TODO(b/128924522): This additional set_shape should not be\n      # necessary. ShapeRefiner likely needs to inspect handle_data. Remove this\n      # once that's done.\n      for i, shape in enumerate(self._output_shapes):\n        outputs[i].set_shape(shape)\n      return outputs\n\n\ndef _create_forward_backward_with_graph(attrs, forward_graph, backwards_graph):\n  \"\"\"Creates forward and backward functions from the function graphs.\"\"\"\n  forward_function_name = _forward_name(forward_graph.name)\n  common_attributes = dict(attrs)\n  # NB: forward and backward function need to drop \"_implements\".\n  # attribute, because their signature contains all the intermediate tensors\n  # that they compute. Thus they don't have a stable signature which can\n  # be directly optimized downstream.\n  # See for more details:\n  # https://github.com/tensorflow/community/blob/master/rfcs/20190610-standardizing-composite_ops.md#appendix-future-support-for-optimizing-gradient-functions\n  common_attributes.pop(IMPLEMENTS_ATTRIBUTE_NAME, None)\n  backward_function_attr = _parse_func_attrs(\n      {FORWARD_FUNCTION_ATTRIBUTE_NAME: forward_function_name})\n  backward_function_attr.update(common_attributes)\n  backward_function = ConcreteFunction(\n      backwards_graph, attrs=backward_function_attr)\n  forward_function_attr = _parse_func_attrs({\n      BACKWARD_FUNCTION_ATTRIBUTE_NAME:\n      backward_function.name})\n  forward_function_attr.update(common_attributes)\n  forward_function = _EagerDefinedFunction(\n      forward_function_name, forward_graph, forward_graph.inputs,\n      forward_graph.outputs, forward_function_attr)\n  return forward_function, backward_function\n\n\nclass _DelayedRewriteGradientFunctions(object):\n  \"\"\"Caches forward/backward functions with a delayed forward rewrite.\"\"\"\n\n  def __init__(self, func_graph, attrs, func_graph_deleter):\n    \"\"\"Construct an inference function and initialize caches.\"\"\"\n    # A map from the number of forward function outputs with accepted gradients\n    # to forward and backward functions, used to cache non-tape backward\n    # function generation.\n    self._cached_function_pairs = {}\n    self._func_graph = func_graph\n    self._inference_function = _EagerDefinedFunction(\n        _inference_name(self._func_graph.name), self._func_graph,\n        self._func_graph.inputs, self._func_graph.outputs, attrs)\n    self._attrs = attrs\n    self._gradient_name = None\n    # Note that the FuncGraph is mutated later, so we need to inspect it now to\n    # figure out the user-specified outputs of the inference function.\n    self._num_inference_outputs = len(self._func_graph.outputs)\n    self._func_graph_deleter = func_graph_deleter\n\n  def forward_backward(self, num_doutputs=None):\n    \"\"\"A possibly-cached pair of forward and backward functions.\"\"\"\n    if num_doutputs is None:\n      num_doutputs = self._num_inference_outputs\n    forward_backward = self._cached_function_pairs.get(num_doutputs)\n    if forward_backward is not None:\n      return forward_backward\n    forward, backward = self._construct_forward_backward(num_doutputs)\n    self._cached_function_pairs[num_doutputs] = (forward, backward)\n    return forward, backward\n\n  def _construct_forward_backward(self, num_doutputs):\n    \"\"\"Constructs a pair of forward and backward functions.\n\n    Args:\n      num_doutputs: The constructed backprop function will take output gradients\n        for the first `num_doutputs` outputs of the forward function. Defaults\n        to the number of outputs for the inference function, but when\n        higher-order gradients are computed this will increase to include side\n        outputs.\n\n    Returns:\n      A pair of (forward_function, backward_function):\n        forward_function: A re-generated inference function (an\n          _EagerDefinedFunction) to account for new side outputs, if any extra\n          were required when building the backward pass.\n        backward_function: A ConcreteFunction that Takes `num_doutputs`\n          arguments and returns gradients with respect to inputs of the forward\n          function.\n    \"\"\"\n    trainable_outputs = [\n        output for output in self._func_graph.outputs[:num_doutputs]\n        if backprop_util.IsTrainable(output)]\n\n    signature = []\n    for t in trainable_outputs:\n      signature.append(\n          tensor_spec.TensorSpec(*default_gradient.shape_and_dtype(t)))\n\n    def _backprop_function(*grad_ys):\n      with ops.device(None):\n        return gradients_util._GradientsHelper(  # pylint: disable=protected-access\n            trainable_outputs,\n            self._func_graph.inputs,\n            grad_ys=grad_ys,\n            src_graph=self._func_graph)\n\n    with self._func_graph.as_default():\n      backwards_graph = func_graph_module.FuncGraph(\n          _backward_name(self._func_graph.name))\n      func_graph_module.func_graph_from_py_func(\n          name=backwards_graph.name,\n          python_func=_backprop_function,\n          args=[], kwargs={},\n          signature=signature,\n          func_graph=backwards_graph)\n      backwards_graph_captures = backwards_graph.external_captures\n      captures_from_forward = [\n          c for c in backwards_graph_captures if\n          not isinstance(c, ops.EagerTensor) and c.graph is self._func_graph]\n\n      existing_outputs = object_identity.ObjectIdentitySet(\n          self._func_graph.outputs)\n      for capture in captures_from_forward:\n        if capture not in existing_outputs:\n          existing_outputs.add(capture)\n          self._func_graph.outputs.append(capture)\n\n      forward_function, backward_function = _create_forward_backward_with_graph(\n          self._attrs, self._func_graph, backwards_graph)\n      return forward_function, backward_function\n\n  def _rewrite_forward_and_call_backward(self, op, *doutputs):\n    \"\"\"Add outputs to the forward call and feed them to the grad function.\"\"\"\n    forward_function, backwards_function = self.forward_backward(len(doutputs))\n    if not backwards_function.outputs:\n      return backwards_function.structured_outputs\n    forward_function.add_to_graph(op.graph)\n\n    # pylint: disable=protected-access\n    # Rewrite an inference call op to be a forward call op\n    op._set_func_attr(\"f\", forward_function.name)\n    op._set_type_list_attr(\"Tout\", forward_function._output_types)\n    op._add_outputs(\n        forward_function._output_types[len(op.outputs):],\n        forward_function._output_shapes[len(op.outputs):])\n    for i in range(len(op.outputs)):\n      func_graph_output = forward_function._func_graph_outputs[i]\n      handle_data_util.copy_handle_data(func_graph_output, op.outputs[i])\n    # pylint: enable=protected-access\n\n    capture_mapping = dict(\n        zip((ops.tensor_id(t) for t in self._func_graph.outputs), op.outputs))\n    remapped_captures = [\n        capture_mapping.get(ops.tensor_id(capture), capture)\n        for capture in backwards_function.captured_inputs\n    ]\n\n    # Replace Nones with zeros since we're calling a graph function which\n    # expects numeric inputs.\n    cleaned_doutputs = []\n    for doutput, placeholder in zip(doutputs, self._func_graph.outputs):\n      if backprop_util.IsTrainable(placeholder):\n        if isinstance(doutput, ops.IndexedSlices):\n          # Gradient passed to a backward ConcreteFunction must be tf.Tensor,\n          # so we convert tf.IndexedSlices to tf.Tensor.\n          cleaned_doutputs.append(ops.convert_to_tensor(doutput))\n        elif doutput is not None:\n          cleaned_doutputs.append(doutput)\n        else:\n          cleaned_doutputs.append(default_gradient.zeros_like(placeholder))\n\n    # Compute the gradients using the side outputs\n    return backwards_function._call_flat(  # pylint: disable=protected-access\n        cleaned_doutputs, remapped_captures)\n\n  def get_gradient_function(self):\n    \"\"\"Returns gradient function.\n\n    The gradient rewrites an inference call op to a forward call op, but does\n    not modify a pre-existing forward call op. It then computes the gradient\n    from the output's gradients and the side outputs of the forward op.\n    \"\"\"\n    return self._rewrite_forward_and_call_backward\n\n  def forward(self, inference_args=None, input_tangents=None):\n    \"\"\"A forward function with only user-specified outputs.\n\n    The call operation for the returned inference function can be rewritten into\n    a forward function. This only happens if the backward function (from the\n    `backward` method) ends up being used to compute gradients.\n\n    This approach avoids constructing unnecessary graphs, but it only works if\n    we are calling this function when not executing eagerly.\n\n    Args:\n      inference_args: A flat list of Tensors, arguments to the inference\n        function. Unused, but taken for compatibility with\n        _TapeGradientFunctions.\n      input_tangents: A flat list of Tensors, jvps associated with\n        `inference_args`. Unused; if required, tape functions must be used\n        instead.\n\n    Returns:\n      An _EagerDefinedFunction.\n    \"\"\"\n    del inference_args  # unused\n    if input_tangents:\n      # This class does not support special-cased forwardprop. The arguments are\n      # here for compatibility with _TapeGradientFunctions.\n      raise errors.InternalError(\"unexpectedly got forwardprop information in \"\n                                 \"a class that does not support forwardprop.\")\n    return self._inference_function\n\n  def _backward(self, outputs):\n    \"\"\"Fetch a backward function for `outputs` from the forward function.\"\"\"\n    def _backward_function(*args):\n      call_op = outputs[0].op\n      return self._rewrite_forward_and_call_backward(call_op, *args)\n    return _backward_function, outputs\n\n  def record(self, flat_outputs, inference_args, input_tangents):\n    \"\"\"Record the function call operation.\n\n    _DelayedRewriteGradientFunctions supports only first-order backprop tape\n    gradients (and then only when graph building). It does not work with\n    higher-order tape gradients or forward autodiff, but does work with\n    higher-order symbolic gradients (tf.gradients).\n\n    Args:\n      flat_outputs: The result of running `forward`.\n      inference_args: A flat list of Tensors with inference inputs to the\n        operation.\n      input_tangents: A flat list of Tensors with input tangents consumed by the\n        operation.\n    \"\"\"\n    backward_function, to_record = self._backward(flat_outputs)\n    tape.record_operation(self._inference_function.signature.name,\n                          to_record, inference_args + input_tangents,\n                          backward_function)\n\n\n# Contains information about a forward function wrapped to compute jvps.\n_ForwardWrapper = collections.namedtuple(\n    \"_ForwardWrapper\", (\n        # The wrapper Graph.\n        \"graph\",\n        # A flat list of non-tangent Tensor outputs from the wrapped forward\n        # function.\n        \"outputs\",\n        # Indices for output tangents, same format as\n        # forwardprop_util.pack_tangents.\n        \"output_indices\",\n        # A flat list of tangents for `outputs`.\n        \"output_tangents\"))\n\n\nclass _TapeGradientFunctions(object):\n  \"\"\"Caches forward and backward functions compatible with eager gradients.\n\n  In contrast to the delayed-rewrite approach in\n  `_DelayedRewriteGradientFunctions` which only works with delayed execution,\n  the forward function generated by this class has a fixed set of outputs which\n  may be preserved by a tape in order to compute gradients later.\n\n  This class is abstract; its child classes differ in how many side outputs of\n  the forward function their backward function accepts gradients for, which\n  determines whether higher-order tape gradients are possible.\n  \"\"\"\n\n  def __init__(self, func_graph, attrs, func_graph_deleter,\n               forwardprop_input_indices, delayed_rewrite_functions,\n               need_gradients_for_jvps):\n    self._func_graph = func_graph\n    self._forward_graph = None\n    self._attrs = attrs\n    self._forward = None\n    self._backward = None\n    self._num_outputs = len(func_graph.outputs)\n    self._func_graph_deleter = func_graph_deleter\n    self._forwardprop_input_indices = forwardprop_input_indices\n    self._forwardprop_output_indices = None\n    self._num_forwardprop_outputs = 0\n    self._num_inference_outputs = len(func_graph.outputs)\n    self._num_trainable_inference_outputs = len(\n        [t for t in func_graph.outputs if backprop_util.IsTrainable(t)])\n    self._delayed_rewrite_functions = delayed_rewrite_functions\n    self._need_gradients_for_jvps = need_gradients_for_jvps\n\n  def _build_functions_for_outputs(\n      self, outputs, inference_args, input_tangents):\n    \"\"\"Forward+backward functions where the backward function sees `outputs`.\"\"\"\n    # First figure out which of `outputs` are trainable. We'll accept gradients\n    # for each of these in the backward function.\n    handles_to_variables = self._func_graph.variable_captures\n    trainable_outputs = []\n    trainable_indices = []\n    for index, output in enumerate(outputs):\n\n      if backprop_util.IsTrainable(output):\n        # Swap in the Variable object for resource handles if we can so\n        # sparse gradients work.\n        output = handles_to_variables.get(id(output), output)\n        trainable_outputs.append(output)\n        trainable_indices.append(index)\n\n    backwards_graph = func_graph_module.FuncGraph(\n        _backward_name(self._func_graph.name))\n    with backwards_graph.as_default():\n      gradients_wrt_outputs = []\n      for output in trainable_outputs:\n        gradient_shape, gradient_dtype = default_gradient.shape_and_dtype(\n            output)\n        gradient_placeholder = graph_placeholder(gradient_dtype, gradient_shape)\n        handle_data_util.copy_handle_data(output, gradient_placeholder)\n        gradients_wrt_outputs.append(gradient_placeholder)\n      with ops.device(None):\n        gradients_wrt_inputs = gradients_util._GradientsHelper(  # pylint: disable=protected-access\n            trainable_outputs,\n            self._func_graph.inputs,\n            grad_ys=gradients_wrt_outputs,\n            src_graph=self._func_graph)\n\n      if input_tangents:\n        # Convert IndexedSlices to dense tensors (as we do elsewhere for\n        # function gradients). Our C++ bindings don't know how to handle them\n        # currently.\n        gradients_wrt_inputs = nest.map_structure(\n            lambda x: ops.convert_to_tensor(x) if x is not None else None,\n            gradients_wrt_inputs)\n      captures_from_forward = [\n          c for c in backwards_graph.external_captures\n          if not isinstance(c, ops.EagerTensor) and c.graph is self._func_graph\n      ]\n      existing_outputs = object_identity.ObjectIdentitySet(\n          self._func_graph.outputs)\n      for capture in captures_from_forward:\n        if capture not in existing_outputs:\n          existing_outputs.add(capture)\n          self._func_graph.outputs.append(capture)\n\n    # The ordering of `backwards_graph.inputs` is important: inputs of\n    # `backward_function` correspond to outputs (including\n    # side outputs) of `self._tape_forward_function`.\n    backwards_graph.inputs = (\n        gradients_wrt_outputs + backwards_graph.internal_captures)\n    backwards_graph.outputs.extend(\n        grad\n        for grad in nest.flatten(gradients_wrt_inputs, expand_composites=True)\n        if grad is not None)\n    backwards_graph.structured_outputs = gradients_wrt_inputs\n\n    forward_function, backward_function = _create_forward_backward_with_graph(\n        self._attrs, self._func_graph, backwards_graph)\n\n    if not input_tangents:\n      # There is no need to special-case forwardprop, so we can return the\n      # forward+backward pair we've created without further wrapping.\n      return (forward_function, self._func_graph, backward_function,\n              # No forwardprop outputs.\n              None, 0)\n    forward_wrapper = self._wrap_forward_function_with_jvps(\n        forward_function, backward_function, inference_args, input_tangents)\n    (wrapped_backwards_graph,\n     forward_wrapper) = self._wrap_backward_function_with_jvp_backprop(\n         backward_function, gradients_wrt_outputs, forward_wrapper)\n    # Now that we've added new captures, we need to make sure forward outputs\n    # are in the same order the backward function expects them to be in:\n    # [inference outputs] + [jvps] + [side outputs] + [captures].\n    forward_wrapper = self._shuffle_forward_outputs(forward_wrapper)\n    (wrapped_forward_function,\n     wrapped_backward_function) = _create_forward_backward_with_graph(\n         self._attrs, forward_wrapper.graph, wrapped_backwards_graph)\n    if (len(inference_args) + len(input_tangents)\n        != len(forward_wrapper.graph.inputs)):\n      raise errors.InternalError(\n          f\"The forward graph had {len(forward_wrapper.graph.inputs)} inputs, \"\n          f\"but we expected {len(inference_args) + len(input_tangents)} \"\n          f\"({len(inference_args)} inference inputs and \"\n          f\"{len(input_tangents)} input tangents).\")\n    return (wrapped_forward_function, forward_wrapper.graph,\n            wrapped_backward_function, forward_wrapper.output_indices,\n            len(forward_wrapper.output_tangents))\n\n  def _wrap_forward_function_with_jvps(\n      self, forward_function, backward_function,\n      inference_args, input_tangents):\n    \"\"\"Adds inline JVP computation to a forward function.\"\"\"\n    forward_wrapper_graph = func_graph_module.FuncGraph(\n        _forward_name(self._func_graph.name))\n    with forward_wrapper_graph.as_default():\n      # Tell forward accumulators to free up space for new JVP computations,\n      # since one may be in the process of computing a JVP (if that computation\n      # triggered this function building).\n      #\n      # We'll make symbolic versions of input JVPs, run the forward function\n      # under forward accumulators to get symbolic output JVPs, then set those\n      # as outputs of the new wrapped forward function.\n      with forwardprop_util.push_forwardprop_state():\n        forward_captures = {\n            ops.tensor_id(internal): external\n            for external, internal in self._func_graph.captures}\n        for input_index, real_input in enumerate(self._func_graph.inputs):\n          # This loop is more or less equivalent to running tf.identity on each\n          # of self._func_graph.inputs. However, doing that also captures jvps\n          # for resource handles, which confuses the jvp capturing code below\n          # (since primal inputs are interwoven with jvp inputs).\n          input_placeholder = array_ops.placeholder(\n              dtype=real_input.dtype,\n              shape=real_input.shape)\n          capture = forward_captures.get(ops.tensor_id(real_input))\n          if capture is not None:\n            forward_wrapper_graph.add_capture(capture, input_placeholder)\n            if capture.dtype == dtypes.resource:\n              handle_data_util.copy_handle_data(capture, input_placeholder)\n          else:\n            forward_wrapper_graph.inputs.append(input_placeholder)\n        for inp, arg in zip(forward_wrapper_graph.inputs, inference_args):\n          tape.record_operation(\n              \"captured_value\", [inp], [arg],\n              backward_function=lambda x: [x],\n              forward_function=lambda x: [x])\n        num_inference_inputs = len(inference_args)\n        for tape_indices in self._forwardprop_input_indices:\n          for input_index, jvp_index in tape_indices:\n            input_placeholder = forward_wrapper_graph.inputs[input_index]\n            if len(forward_wrapper_graph.inputs) != jvp_index:\n              raise errors.InternalError(\n                  f\"Expected {jvp_index} forward graph inputs, \"\n                  f\"got {len(forward_wrapper_graph.inputs)}.\")\n            gradient_shape, gradient_dtype = default_gradient.shape_and_dtype(\n                input_placeholder)\n            jvp_placeholder = graph_placeholder(gradient_dtype, gradient_shape)\n            external_jvp = input_tangents[jvp_index - num_inference_inputs]\n            forward_wrapper_graph.add_capture(external_jvp, jvp_placeholder)\n            tensor_shape.TensorShape(\n                external_jvp.shape).assert_is_compatible_with(\n                    jvp_placeholder.shape)\n            tape.record_operation(\n                \"captured_value\",\n                [jvp_placeholder],\n                [external_jvp],\n                backward_function=lambda x: [x],\n                forward_function=lambda x: [x])\n        forward_inputs = forward_wrapper_graph.inputs[:num_inference_inputs]\n        gradient_function = (\n            self._delayed_rewrite_functions._rewrite_forward_and_call_backward)  # pylint: disable=protected-access\n        with ops.get_default_graph()._override_gradient_function(  # pylint: disable=protected-access\n            {\"PartitionedCall\": gradient_function,\n             \"StatefulPartitionedCall\": gradient_function}):\n          forward_outputs = forward_function.call(context.context(),\n                                                  forward_inputs)\n          if isinstance(forward_outputs, ops.Operation):\n            # _wrapped_backward_function expects a list, but if the function has\n            # no outputs its call() returns an Operation. We need to undo that\n            # so we don't cause problems later.\n            forward_outputs = []\n        py_backward, _ = self._wrap_backward_function(\n            self._func_graph, backward_function, forward_outputs)\n      # We will never request backward tape gradients for this operation\n      # directly since we're wrapping the call; forwardprop will call the\n      # backward function (and nested forward accumulators may build\n      # higher-order gradients), but any watching GradientTapes should ignore\n      # it.\n      #\n      # TODO(allenl): It might be better to explicitly stop backward recording\n      # so we don't use the second-order tape cases unnecessarily.\n      tape.record_operation_forwardprop_only(\n          forward_function.signature.name,\n          forward_outputs, forward_inputs, py_backward, None)\n      output_indices, output_tangents = (\n          pywrap_tfe.TFE_Py_PackJVPs(forward_outputs))\n      output_tangents = [forward_wrapper_graph.capture(t)\n                         for t in output_tangents]\n    return _ForwardWrapper(\n        graph=forward_wrapper_graph, outputs=forward_outputs,\n        output_indices=output_indices, output_tangents=output_tangents)\n\n  def _wrap_backward_function_with_jvp_backprop(\n      self, backward_function, gradients_wrt_outputs, forward_wrapper):\n    \"\"\"Wraps `backward_function` to include gradients for JVPs.\"\"\"\n    wrapped_backwards_graph = func_graph_module.FuncGraph(\n        _backward_name(self._func_graph.name))\n    with wrapped_backwards_graph.as_default():\n      py_backward, recorded_outputs = self._wrap_backward_function(\n          self._func_graph, backward_function, forward_wrapper.outputs)\n      trainable_index = 0\n      forward_doutputs = []\n      doutput_args = []\n      for output in recorded_outputs:\n        if backprop_util.IsTrainable(output):\n          doutput = gradients_wrt_outputs[trainable_index]\n          doutput_placeholder = graph_placeholder(doutput.dtype, doutput.shape)\n          doutput_args.append(doutput_placeholder)\n          forward_doutputs.append(doutput_placeholder)\n          trainable_index += 1\n        else:\n          doutput_args.append(None)\n\n      dinputs = py_backward(*doutput_args)\n      existing_outputs = object_identity.ObjectIdentitySet(\n          forward_wrapper.outputs + forward_wrapper.output_tangents)\n      num_processed_output_tangents = 0\n      gradients_wrt_output_tangents = []\n      tangent_doutputs = []\n      output_tangents = forward_wrapper.output_tangents\n      output_indices = forward_wrapper.output_indices\n      if self._need_gradients_for_jvps:\n        # TODO(allenl): Consider using a throwaway graph to avoid extra gradient\n        # evaluations; gradients for jvps may have common subgraphs.\n        while num_processed_output_tangents != len(output_tangents):\n          for output in output_tangents[num_processed_output_tangents:]:\n            gradient_shape, gradient_dtype = default_gradient.shape_and_dtype(\n                output)\n            placeholder = graph_placeholder(gradient_dtype, gradient_shape)\n            gradients_wrt_output_tangents.append(placeholder)\n            tangent_doutputs.append(placeholder)\n          num_processed_output_tangents = len(output_tangents)\n          with ops.device(None):\n            gradients_wrt_inputs = gradients_util._GradientsHelper(  # pylint: disable=protected-access\n                output_tangents,\n                forward_wrapper.graph.inputs,\n                grad_ys=gradients_wrt_output_tangents,\n                src_graph=forward_wrapper.graph)\n          dinputs = [\n              backprop.aggregate_indexed_slices_gradients((existing, new))\n              for existing, new in zip(dinputs, gradients_wrt_inputs)\n              if existing is not None or new is not None]\n          dinputs.extend(gradients_wrt_inputs[len(dinputs):])\n          captures_from_forward = [\n              c for c in wrapped_backwards_graph.external_captures\n              if (not isinstance(c, ops.EagerTensor)\n                  and c.graph is forward_wrapper.graph)]\n          for capture in captures_from_forward:\n            if capture not in existing_outputs:\n              existing_outputs.add(capture)\n              forward_wrapper.outputs.append(capture)\n          output_indices, output_tangents = (\n              forwardprop_util.pack_tangents(forward_wrapper.outputs))\n          output_tangents = [forward_wrapper.graph.capture(t)\n                             for t in output_tangents]\n          for t in output_tangents:\n            existing_outputs.add(t)\n    wrapped_backwards_graph.inputs = (\n        forward_doutputs[:self._num_trainable_inference_outputs]\n        + tangent_doutputs\n        + forward_doutputs[self._num_trainable_inference_outputs:]\n        + wrapped_backwards_graph.internal_captures)\n    wrapped_backwards_graph.structured_outputs = dinputs\n    wrapped_backwards_graph.outputs = [t for t in dinputs if t is not None]\n    return (wrapped_backwards_graph,\n            forward_wrapper._replace(output_indices=output_indices,\n                                     output_tangents=output_tangents))\n\n  def _shuffle_forward_outputs(self, forward_wrapper):\n    \"\"\"Reorders function outputs so captures are last.\"\"\"\n    def _index_map(original):\n      if original < self._num_inference_outputs:\n        return original\n      if original >= len(forward_wrapper.outputs):\n        return (original - len(forward_wrapper.outputs)\n                + self._num_inference_outputs)\n      return original + len(forward_wrapper.output_tangents)\n    output_indices = nest.map_structure(\n        _index_map, forward_wrapper.output_indices)\n    forward_wrapper.graph.outputs = (\n        forward_wrapper.outputs[:self._num_inference_outputs]\n        + forward_wrapper.output_tangents\n        + forward_wrapper.outputs[self._num_inference_outputs:])\n    return forward_wrapper._replace(output_indices=output_indices)\n\n  def forward(self, inference_args, input_tangents):\n    \"\"\"Construct or fetch a forward function with side-outputs.\n\n    When graph building without a tape active, symbolic gradients rely on\n    regenerating the backward function for higher-order gradients (to account\n    for new side outputs of the rewritten forward function call). Thus there is\n    no fixed backward function for this case. However, when a tape is active\n    (eager or graph building), we generate fixed backward and forward functions\n    at forward function call time.\n\n    This difference between the tape and non-tape cases is to avoid building\n    unneeded backward functions while graph building (where we may or may not\n    eventually need gradients).\n\n    Args:\n      inference_args: A flat list of Tensors, arguments to the inference\n        function.\n      input_tangents: A flat list of Tensors, jvps associated with\n        `inference_args`.\n\n    Returns:\n      A forward _EagerDefinedFunction.\n    \"\"\"\n    if self._forward is None:\n      (self._forward, self._forward_graph, self._backward,\n       self._forwardprop_output_indices, self._num_forwardprop_outputs) = (\n           self._forward_and_backward_functions(inference_args, input_tangents))\n    return self._forward\n\n  def _wrap_backward_function(self, forward_graph, backward, outputs):\n    \"\"\"Create a backward function given `outputs` from the forward function.\"\"\"\n    capture_mapping = dict(\n        zip((ops.tensor_id(t) for t in forward_graph.outputs), outputs))\n    captured_inputs = backward.captured_inputs\n    remapped_captures = [\n        capture_mapping.get(ops.tensor_id(capture), capture)\n        for capture in captured_inputs\n    ]\n    if any(t.graph is forward_graph for t in remapped_captures\n           if not isinstance(t, ops.EagerTensor)):\n      incorrect_mapping = [t for t in remapped_captures\n                           if (not isinstance(t, ops.EagerTensor) and\n                               t.graph is not forward_graph)]\n      raise errors.InternalError(\"Failed to map all backward graph captures to \"\n                                 \"the forward graph. Incorrectly mapped: \"\n                                 f\"{incorrect_mapping}.\")\n    # We may need to use zeros_like to get a zero for variant Tensors with\n    # unconnected gradients. We do that in advance so we don't have to hold on\n    # to the outputs themselves, which may not be needed otherwise.\n    variant_zeros_like = {}\n    backward_function_inputs = (len(backward.inputs) - len(captured_inputs))\n    recorded_outputs = []\n    trainable_recorded_outputs = 0\n    skip_positions = []\n    if self._num_forwardprop_outputs and not self._need_gradients_for_jvps:\n      relevant_outputs = (\n          outputs[:self._num_inference_outputs]\n          + outputs[self._num_inference_outputs\n                    + self._num_forwardprop_outputs:])\n    else:\n      relevant_outputs = outputs\n    for output_index, output in enumerate(relevant_outputs):\n      if trainable_recorded_outputs < backward_function_inputs:\n        recorded_outputs.append(output)\n      if backprop_util.IsTrainable(output):\n        trainable_recorded_outputs += 1\n      else:\n        skip_positions.append(output_index)\n      if output.dtype == dtypes.variant:\n        variant_zeros_like[output_index] = default_gradient.zeros_like(output)\n\n    def _backward_function_wrapper(*args):\n      \"\"\"Process output gradients and call the backward function.\"\"\"\n      if not backward.outputs:\n        return backward.structured_outputs\n\n      processed_args = []\n      input_index = 0\n      for output_index, arg in enumerate(args):\n        # Convert IndexedSlices to dense tensors. The IndexedSlices optimization\n        # is only really effective when doing tf.gather(variable) as the\n        # adjoint functions for most operations are unlikely to preserve the\n        # sparsity in IndexedSlices.\n        if isinstance(arg, ops.IndexedSlices):\n          arg = ops.convert_to_tensor(arg)\n        if output_index in skip_positions:\n          continue\n        if arg is None:\n          # We're calling a (non-polymorphic) ConcreteFunction, so we need to\n          # have a Tensor value for each Tensor we thought would be trainable\n          # based on its dtype, even if it ended up being unconnected.\n          input_placeholder = backward.inputs[\n              input_index]\n          if input_placeholder.dtype == dtypes.variant:\n            arg = variant_zeros_like[output_index]\n          else:\n            arg = array_ops.zeros(\n                *default_gradient.shape_and_dtype(input_placeholder))\n        processed_args.append(arg)\n        input_index += 1\n        if input_index >= backward_function_inputs:\n          break\n      return backward._call_flat(  # pylint: disable=protected-access\n          processed_args, remapped_captures)\n\n    return _backward_function_wrapper, recorded_outputs\n\n  def record(self, flat_outputs, inference_args, input_tangents):\n    \"\"\"Record the function call operation.\n\n    For backprop, indicates the backward function to use and which new Tensors\n    must be watched. For forwardprop from eager, the function call itself will\n    have produced tangents which need to be recorded.\n\n    Args:\n      flat_outputs: The result of running `forward`.\n      inference_args: A flat list of Tensors with inference inputs to the\n        operation.\n      input_tangents: A flat list of Tensors with input tangents consumed by the\n        operation.\n    \"\"\"\n    backward_function, to_record = self._wrap_backward_function(\n        self._forward_graph, self._backward, flat_outputs)\n    if self._forwardprop_output_indices:\n      tape.record_operation_backprop_only(\n          self._forward.signature.name,\n          to_record, inference_args,\n          backward_function)\n      tape.record_operation_forwardprop_only(\n          self._forward.signature.name,\n          flat_outputs, inference_args + input_tangents,\n          backward_function,\n          self._forwardprop_output_indices)\n    else:\n      tape.record_operation(self._forward.signature.name,\n                            to_record, inference_args + input_tangents,\n                            backward_function)\n\n\nclass _FirstOrderTapeGradientFunctions(_TapeGradientFunctions):\n  \"\"\"Caches tape-friendly functions for first-order gradients.\"\"\"\n\n  def __init__(self, func_graph, attrs, func_graph_deleter,\n               forwardprop_input_indices, delayed_rewrite_functions,\n               need_gradients_for_jvps):\n    super(_FirstOrderTapeGradientFunctions, self).__init__(\n        func_graph, attrs, func_graph_deleter, forwardprop_input_indices,\n        delayed_rewrite_functions, need_gradients_for_jvps)\n    self._func_graph_deleter = func_graph_deleter\n    self._forwardprop_input_indices = forwardprop_input_indices\n\n  def _forward_and_backward_functions(self, inference_args, input_tangents):\n    \"\"\"Shortcut for when only first-order gradients are required.\n\n    The returned backward function does not accept gradients with respect to\n    side output of forward_function. This is fine as long as the user can't\n    possibly request second order tape gradients, as when they've used a single\n    non-persistent GradientTape. Since we don't need the backward function to\n    take gradients with respect to side outputs, we can skip some potentially\n    slow graph building.\n\n    Args:\n      inference_args: A flat list of Tensors, arguments to the inference\n        function.\n      input_tangents: A flat list of Tensors, jvps associated with\n        `inference_args`.\n\n    Returns:\n      A tuple of (forward_function, backward_function):\n        forward_function: Takes the same inputs as the inference function, but\n          returns side outputs used by backward_function in addition to the\n          inference function's outputs.\n        backward_function: Takes side outputs from forward_function and\n          gradients with respect to the \"real\" outputs of forward_function and\n          returns gradients with respect to the inputs.\n    \"\"\"\n    outputs = self._func_graph.outputs[:self._num_inference_outputs]\n    return self._build_functions_for_outputs(\n        outputs, inference_args, input_tangents)\n\n\nclass _HigherOrderTapeGradientFunctions(_TapeGradientFunctions):\n  \"\"\"Caches tape-friendly functions for higher-order gradients.\"\"\"\n\n  # TODO(b/136189779): Cond/while under a tape may need similar logic. Consider\n  # generalizing if so.\n  def _forward_and_backward_functions(self, inference_args, input_tangents):\n    \"\"\"Forward and backward functions suitable for higher-order gradients.\n\n    Unlike in `_FirstOrderTapeGradientFunctions`, the backward function built by\n    this method accepts gradients for all of the outputs of the returned forward\n    function, including side outputs.\n\n    Args:\n      inference_args: A flat list of Tensors, arguments to the inference\n        function.\n      input_tangents: A flat list of Tensors, jvps associated with\n        `inference_args`.\n\n    Returns:\n      A tuple of (forward_function, backward_function):\n        forward_function: Takes the same inputs as the inference function, but\n          returns side outputs used by backward_function in addition to the\n          inference function's outputs.\n        backward_function: Takes side outputs from forward_function and\n          gradients with respect to all of its outputs, real and side. Returns\n          gradients with respect to the inputs.\n    \"\"\"\n    outputs = []\n    iteration_count = 0\n    # First we need to figure out how many side outputs from the forward pass\n    # will be required. We do this in a temporary graph to avoid actually\n    # running multiple copies of the backward pass (one per _GradientsHelper\n    # call).\n    #\n    # While computing gradients, the backward function captures Tensors from\n    # the forward function. We add these as side outputs of the original\n    # function. However, we then need to accept output gradients with respect\n    # to these side outputs for higher order gradients to work. Thus we loop\n    # until the number of outputs of the function stabilizes. Note that this\n    # is only required for tape gradients, where we need to declare in advance\n    # all of the forward op's outputs: symbolic gradients with tf.gradients\n    # instead rely on regenerating backward functions when higher-order\n    # gradients are requested.\n    while (len(outputs) < len(self._func_graph.outputs)\n           # It's possible for gradient generation to add new ops to the forward\n           # pass. If all of the new outputs are non-trainable, there's no\n           # reason to continue.\n           and any(backprop_util.IsTrainable(output)\n                   for output in self._func_graph.outputs[len(outputs):])):\n      iteration_count += 1\n      if iteration_count >= 20 and iteration_count % 5 == 0:\n        new_op_with_trainable_output = None\n        num_new_trainable_outputs = 0\n        for output in self._func_graph.outputs[len(outputs):]:\n          if backprop_util.IsTrainable(output):\n            num_new_trainable_outputs += 1\n            new_op_with_trainable_output = output.op\n        logging.warning(\n            (\"Determining side outputs for the function '{}' is taking longer \"\n             \"than expected ({} iterations, typically this converges in 5 or \"\n             \"so). This could indicate that a gradient registration is adding \"\n             \"new ops to the forward pass every time gradients are generated. \"\n             \"{} new trainable output(s) were added this iteration, one from \"\n             \"the following op:\\n {}\\nThis may indicate a TensorFlow bug, or \"\n             \"an issue in a tf.custom_gradient.\")\n            .format(\n                self._func_graph.name, iteration_count,\n                num_new_trainable_outputs, new_op_with_trainable_output))\n      outputs = list(self._func_graph.outputs)\n      self._build_functions_for_outputs(\n          outputs, inference_args, input_tangents)\n\n    (forward_function, forward_graph,\n     backward_function, output_indices, num_output_tangents) = (\n         self._build_functions_for_outputs(\n             outputs, inference_args, input_tangents))\n    if (len(self._func_graph.outputs) > len(outputs)\n        and any(backprop_util.IsTrainable(output)\n                for output in self._func_graph.outputs[len(outputs):])):\n      raise errors.InternalError(\n          \"Unexpectedly added new outputs to the forward function when \"\n          \"building the backward function: \"\n          f\"{self._func_graph.outputs[len(outputs):]}.\")\n    return (forward_function, forward_graph, backward_function, output_indices,\n            num_output_tangents)\n\n\nclass _ForwardBackwardCall(object):\n  \"\"\"Holds the state of a function call between execution and recording.\"\"\"\n\n  __slots__ = [\n      \"_functions\", \"_inference_args\", \"_input_tangents\", \"_tape_watching\"\n  ]\n\n  def __init__(self, functions, inference_args, input_tangents, tape_watching):\n    \"\"\"Collects information about the function call.\n\n    Args:\n      functions: An object which produces forward and backward functions, either\n        a _DelayedRewriteGradientFunctions or a _TapeGradientFunctions object.\n      inference_args: A flat list of Tensors, arguments to the inference\n        function.\n      input_tangents: A flat list of Tensors, jvps associated with\n        `inference_args`.\n      tape_watching: Boolean, with True indicating that recording is necessary.\n    \"\"\"\n    self._functions = functions\n    self._inference_args = inference_args\n    self._input_tangents = input_tangents\n    self._tape_watching = tape_watching\n\n  def forward(self):\n    \"\"\"Builds or retrieves a forward function for this call.\"\"\"\n    forward_function = self._functions.forward(\n        self._inference_args, self._input_tangents)\n    return forward_function, self._inference_args + self._input_tangents\n\n  def record(self, flat_outputs):\n    \"\"\"Given outputs from the execution of `forward`, records the operation.\"\"\"\n    if (self._tape_watching\n        and not isinstance(flat_outputs, ops.Operation)\n        and flat_outputs is not None):\n      # We only record function calls which have outputs, and then only when a\n      # tape is watching.\n      self._functions.record(\n          flat_outputs, self._inference_args, self._input_tangents)\n\n\n# Sentinel value used by with ConcreteFunction's structured signature to\n# indicate that a non-tensor parameter should use the value that was\n# specified when the concrete function was created.\n_BOUND_VALUE = object()\n\n\nclass ConcreteFunction(core.ConcreteFunction):\n  \"\"\"A `tf.types.experimental.ConcreteFunction` created from `tf.function`.\"\"\"\n\n  def __init__(self,\n               func_graph,\n               attrs=None,\n               shared_func_graph=True,\n               function_spec=None):\n    \"\"\"Initialize a `ConcreteFunction`.\n\n    Args:\n      func_graph: An instance of FuncGraph: the function body to wrap.\n      attrs: (optional) dict mapping names of attributes to their AttrValue\n        values. Attributes in `attrs` will be included in this function's\n        definition.\n     shared_func_graph: If False, the ConcreteFunction takes ownership of\n       `func_graph` and will break reference cycles when it is deleted. This\n       makes the FuncGraph inoperable.\n     function_spec: FunctionSpec for the original function.  If not specified,\n       then this ConcreteFunction may only be called using the flat signature.\n\n    Raises:\n      ValueError: If number of input_placeholders is not equal to the number\n        of function inputs.\n    \"\"\"\n    # _arg_keywords and _num_positional_args define the flat signature.  They\n    # are assigned after construction.\n    self._arg_keywords = None\n    self._num_positional_args = None\n\n    self._func_graph = func_graph\n    self._captured_inputs = self._func_graph.external_captures + self._func_graph.deferred_external_captures\n\n    # function_spec defines the structured signature.\n    self._set_function_spec(function_spec)\n\n    if attrs and IMPLEMENTS_ATTRIBUTE_NAME in attrs:\n      # The alternative is to silently drop \"implements\" tag\n      # but it seems likely it would lead to hard to catch bugs.\n      # Another alternative is to make func_body to preserve the order\n      # of arguments if variables are present. Yet another option\n      # is to automatically replace variables as arguments to functions\n      # to v.read_value() whenever \"implements\" tag is present\n      # Anytime we annotate existing function we probably want to wrap\n      # it with safe read_value for backward compatibility.\n      has_resource_vars = any(inp.dtype == dtypes.resource\n                              for inp in self.inputs)\n\n      assert not any((has_resource_vars, self._captured_inputs)), (\n          'Function {name} has \"{attr}={value}\" attribute and thus can not '\n          \"depend on any tensors outside of its signature or modify variables. \"\n          \"\\n\\nNote: variables are always captured and cause function \"\n          \"re-tracing for every variable called.\\n\"\n          \"  inputs: {inputs}\\n  captures: {captured}\\n\\n\"\n          \"To pass a variable to such function use  \"\n          \"use variable.read_value().\".format(\n              name=func_graph.name,\n              attr=IMPLEMENTS_ATTRIBUTE_NAME,\n              value=attrs[IMPLEMENTS_ATTRIBUTE_NAME],\n              inputs=self.inputs,\n              captured=self._captured_inputs))\n    self._output_shapes = tuple(\n        output.shape for output in self._func_graph.outputs)\n    self._attrs = _parse_func_attrs(attrs or {})\n\n    if shared_func_graph:\n      self._garbage_collector = None\n    else:\n      self._garbage_collector = ConcreteFunctionGarbageCollector(func_graph)\n\n    # Pairs of forward and backward functions used for computing gradients.\n    #\n    # These each get a reference to the FuncGraph deleter since they use the\n    # FuncGraph directly.\n    self._delayed_rewrite_functions = _DelayedRewriteGradientFunctions(\n        func_graph, self._attrs, self._garbage_collector)\n    self._first_order_tape_functions = {}\n    self._higher_order_tape_functions = {}\n    # Cache the inference function to avoid a (Python) function call when not\n    # building gradients.\n    self._inference_function = self._delayed_rewrite_functions.forward()\n\n  def _set_function_spec(self, function_spec):\n    \"\"\"Enables the structured signature by supplying a function_spec.\"\"\"\n    self._function_spec = None\n    self._pre_initialized_function_spec = function_spec\n\n    # Note: when ConcreteFunctions are built by recreate_function() in\n    # function_deserialization.py, they don't have a structured_input_signature\n    # yet.  In that case, _initialize_function_spec() gets called by\n    # _setup_functions_structures() in load.py.\n    if (function_spec is not None and\n        self.structured_input_signature is not None):\n      self._initialize_function_spec()\n\n  def _initialize_function_spec(self):\n    \"\"\"Updates `self._function_spec` to include varargs and bound variables.\n\n    Adds new positional arguments for any varargs (i.e., for args that are\n    in `structured_input_signature`, but not in the original fullargspec.args).\n\n    Replaces `defaults` and `kwonlydefaults` with the `_BOUND_VALUE`, for\n    all args and kwargs in `structured_input_signature`.\n\n    Sets `varkw` and `varargs` to None.\n    \"\"\"\n    if self._pre_initialized_function_spec is None:\n      return  # e.g., SavedBareConcreteFunction doesn't have function_spec yet.\n    assert not self._function_spec, \"already initialized\"\n    function_spec = self._pre_initialized_function_spec\n    args = function_spec.fullargspec.args\n    arg_specs, kwarg_specs = self.structured_input_signature\n    vararg_indices = range(len(function_spec.arg_names), len(arg_specs))\n    fullargspec = tf_inspect.FullArgSpec(\n        args=list(args) + [\"<arg{}>\".format(i + 1) for i in vararg_indices],\n        varargs=None,\n        varkw=None,\n        defaults=[_BOUND_VALUE] * len(arg_specs),\n        kwonlyargs=list(sorted(kwarg_specs)),\n        kwonlydefaults=dict((k, _BOUND_VALUE) for k in kwarg_specs),\n        annotations=function_spec.fullargspec.annotations)\n    self._function_spec = FunctionSpec(\n        fullargspec,\n        function_spec.is_method,\n        function_spec.input_signature,\n        function_spec.is_pure,\n        name=self._func_graph.name)\n\n  @property\n  def variables(self):\n    \"\"\"Sequence of variables for this function.\"\"\"\n    return tuple(self._func_graph.variables)\n\n  @property\n  def trainable_variables(self):\n    \"\"\"Sequence of trainable variables for this function.\"\"\"\n    return tuple(self._func_graph.trainable_variables)\n\n  def __call__(self, *args, **kwargs):\n    \"\"\"Executes the wrapped function.\n\n    ConcreteFunctions have two signatures:\n\n    * The signature of the original function wrapped by this ConcreteFunction.\n    * A flat signature, where each argument accepts a single Tensor.\n\n    The original function signature is generally preferred, but the flat input\n    signature is supported for backward compatibility.\n\n    ### Original Function Signature\n\n    When calling a ConcreteFunction with the signature of the original function,\n    each argument must match the type or value that was used when the\n    ConcreteFunction's graph was traced.  In particular:\n\n    * Tensor arguments (including CompositeTensors, such as RaggedTensor) must\n      have matching `TypeSpec`s.\n    * Non-Tensor arguments (such as booleans or ints) must have equal values.\n    * Nested arguments (such as lists, tuples, or dictionaries) must have the\n      same nesting structure; and each nested value must have a matching type\n      or value.\n\n    The default value for any arguments that were traced with non-Tensor values\n    is the value that was used in the trace.  Arguments that were traced with\n    tensor arguments do not have a default value (even if the original function\n    had a default value for that argument).\n\n    ### Flat Signature\n\n    When calling a ConcreteFunction with the flat signature, the arguments\n    correspond to the flattened component tensors of the arguments that were\n    used to construct the ConcreteFunction.  Parameter names are assigned based\n    on `TensorSpec.name` (when specified) or the original argument names (with\n    suffixes automatically added for nested arguments or composite tensors with\n    multiple components).\n\n    Args:\n      *args: Positional arguments to the concrete function.\n      **kwargs: Keyword arguments to the concrete function.\n\n    Returns:\n      The result of applying the TF function on the given Tensors.\n\n    Raises:\n      AssertionError: If this `ConcreteFunction` was not created through\n        `get_concrete_function`.\n      TypeError: If the arguments do not match the function's signature.\n    \"\"\"\n    return self._call_impl(args, kwargs)\n\n  def _call_impl(self, args, kwargs, cancellation_manager=None):\n    \"\"\"See `__call__` for details.\"\"\"\n    with trace.Trace(self._func_graph.name, tf_function_call=\"concrete\"):\n      # Construct the list of input tensors: check if the structured signature\n      # applies first; and if not, then use the flat signature.\n      if self._function_spec is not None:\n        try:\n          return self._call_with_structured_signature(args, kwargs,\n                                                      cancellation_manager)\n        except TypeError as structured_err:\n          try:\n            return self._call_with_flat_signature(args, kwargs,\n                                                  cancellation_manager)\n          except TypeError:\n            raise structured_err\n\n      return self._call_with_flat_signature(args, kwargs, cancellation_manager)\n\n  def _call_with_flat_signature(self, args, kwargs, cancellation_manager):\n    \"\"\"Executes the wrapped function with the flat signature.\n\n    Args:\n      args: Positional arguments to the concrete function.\n      kwargs: Keyword arguments to the concrete function.\n      cancellation_manager: A `CancellationManager` that can be used to cancel\n        function invocation.\n\n    Returns:\n      The result of applying the function on the Tensors/Variables contained in\n      `args` and `kwargs`.\n    Raises:\n      TypeError: if `args` and `kwargs` do not match the flat signature of this\n        `ConcreteFunction`.\n    \"\"\"\n    if len(args) > self._num_positional_args:\n      raise TypeError(\n          f\"{self._flat_signature_summary()} takes {self._num_positional_args} \"\n          f\"positional arguments, got {len(args)}.\")\n    args = list(args)\n    kwargs = dict(kwargs)\n    for keyword in self._arg_keywords[len(args):]:\n      try:\n        args.append(kwargs.pop(compat.as_str(keyword)))\n      except KeyError:\n        specified_keywords = (\n            list(self._arg_keywords[:len(args)]) + list(kwargs.keys()))\n        missing_required_args = sorted(\n            set(self._arg_keywords) - set(specified_keywords))\n        raise TypeError(f\"{self._flat_signature_summary()} missing required \"\n                        f\"arguments: {', '.join(missing_required_args)}.\")\n    if kwargs:\n      positional_arg_keywords = set(self._arg_keywords[:len(args)])\n      for unused_key in kwargs:\n        if unused_key in positional_arg_keywords:\n          raise TypeError(f\"{self._flat_signature_summary()} got two values \"\n                          f\"for '{unused_key}'.\")\n      raise TypeError(f\"{self._flat_signature_summary()} got unexpected \"\n                      f\"keyword arguments: {', '.join(sorted(kwargs))}.\")\n\n    for i, arg in enumerate(args):\n      if not isinstance(\n          arg, (ops.Tensor, resource_variable_ops.BaseResourceVariable)):\n        raise TypeError(f\"{self._flat_signature_summary()}: expected argument \"\n                        f\"#{i}(zero-based) to be a Tensor; \"\n                        f\"got {type(arg).__name__} ({arg}).\")\n    return self._call_flat(args, self.captured_inputs, cancellation_manager)\n\n  def _call_with_structured_signature(self, args, kwargs, cancellation_manager):\n    \"\"\"Executes the wrapped function with the structured signature.\n\n    Args:\n      args: Positional arguments to the concrete function.\n      kwargs: Keyword arguments to the concrete function.\n      cancellation_manager: A `CancellationManager` that can be used to cancel\n        function invocation.\n\n    Returns:\n      The result of applying the function on the Tensors/Variables contained in\n      `args` and `kwargs`.\n    Raises:\n      TypeError: if `args` and `kwargs` do not match the structured signature\n        of this `ConcreteFunction`.\n    \"\"\"\n    args, kwargs, _, filtered_flat_args = \\\n        self._function_spec.canonicalize_function_inputs(*args, **kwargs)\n    self._structured_signature_check_missing_args(args, kwargs)\n    self._structured_signature_check_unexpected_args(args, kwargs)\n    self._structured_signature_check_arg_types(args, kwargs)\n    return self._call_flat(\n        filtered_flat_args,\n        captured_inputs=self.captured_inputs,\n        cancellation_manager=cancellation_manager)\n\n  def _structured_signature_check_missing_args(self, args, kwargs):\n    \"\"\"Raises a TypeError if any args are missing.\"\"\"\n    arg_specs, kwarg_specs = self.structured_input_signature\n    missing_arguments = []\n    for i, (arg, spec) in enumerate(zip(args, arg_specs)):\n      if arg is _BOUND_VALUE and _contains_type_spec(spec):\n        missing_arguments.append(self._function_spec.arg_names[i])\n    for (name, arg) in kwargs.items():\n      if arg is _BOUND_VALUE and _contains_type_spec(kwarg_specs[name]):\n        missing_arguments.append(name)\n    if missing_arguments:\n      raise TypeError(f\"{self._structured_signature_summary()} missing \"\n                      \"required arguments: \"\n                      f\"{', '.join(sorted(missing_arguments))}.\")\n\n  def _structured_signature_check_unexpected_args(self, args, kwargs):\n    \"\"\"Raises a TypeError if there are any extra args.\"\"\"\n    arg_specs, kwarg_specs = self.structured_input_signature\n    if len(args) > len(arg_specs):\n      raise TypeError(\n          f\"{self._structured_signature_summary()} takes \"\n          f\"{len(self._function_spec.arg_names)} positional arguments but got \"\n          f\"{len(args)}.\")\n    if len(kwargs) > len(kwarg_specs):\n      extra_args = set(kwargs) - set(kwarg_specs)\n      raise TypeError(f\"{self._structured_signature_summary()} got unexpected \"\n                      f\"keyword arguments: {', '.join(extra_args)}.\")\n\n  def _structured_signature_check_arg_types(self, args, kwargs):\n    \"\"\"Raises a TypeError if any args have the wrong type.\"\"\"\n    # Check argument types\n    arg_specs, kwarg_specs = self.structured_input_signature\n    for i, (arg, spec) in enumerate(zip(args, arg_specs)):\n      name = self._function_spec.arg_names[i]\n      self._structured_signature_check_arg_type(arg, spec, name)\n    for (name, arg) in kwargs.items():\n      self._structured_signature_check_arg_type(arg, kwarg_specs[name], name)\n\n  def _structured_signature_check_arg_type(self, arg, spec, name):\n    \"\"\"Raise TypeError if `arg`'s type doesn't match `spec`.\"\"\"\n    if arg is _BOUND_VALUE:\n      return\n\n    # Check the overall nested structure of the argument.\n    try:\n      nest.assert_same_structure(arg, spec, expand_composites=True)\n    except (ValueError, TypeError):\n      try:\n        nest.assert_same_structure(arg, spec, expand_composites=False)\n        expected, got = spec, arg\n      except (ValueError, TypeError):\n        expected, got = _structure_summary(spec), _structure_summary(arg)\n      raise TypeError(f\"{self._structured_signature_summary()}: argument \"\n                      f\"{name} had incorrect type\\n\"\n                      f\"  expected: {expected}\\n\"\n                      f\"       got: {got}\")\n\n    # Check the type for each leaf in the nested structure.\n    arg_pieces = nest.flatten(arg, expand_composites=True)\n    spec_pieces = nest.flatten(spec, expand_composites=True)\n    for (arg_piece, spec_piece) in zip(arg_pieces, spec_pieces):\n      # TODO(mdan): Use consistent error messages.\n      if isinstance(spec_piece, tensor_spec.DenseSpec):\n        # TODO(edloper): Consider calling convert_to_tensor on non-tensor\n        # values here.  That would match the behavior of\n        # _call_concrete_function() in function_deserialization.py.  If\n        # we do, then we need to change the nest assert_same_structure and\n        # flatten calls above to use shallow variants.\n        tensor_types = (ops.Tensor, resource_variable_ops.BaseResourceVariable)\n        if not isinstance(arg_piece, tensor_types):\n          raise TypeError(f\"{self._structured_signature_summary()} expected a \"\n                          f\"Tensor in {name}, but got \"\n                          f\"{type(arg_piece).__name__} value {arg_piece}.\")\n      elif arg_piece is not _BOUND_VALUE:\n        try:\n          arg_matches_spec = bool(arg_piece == spec_piece)\n        except (ValueError, TypeError):\n          logging.vlog(1, \"Error matching value with spec\", exc_info=True)\n          arg_matches_spec = False\n        if not arg_matches_spec:\n          raise TypeError(\n              f\"ConcreteFunction {self._structured_signature_summary()} was \"\n              f\"constructed with {type(spec_piece).__name__} value \"\n              f\"{spec_piece} in {name}, but was called with \"\n              f\"{type(arg_piece).__name__} value {arg_piece}.\")\n\n  def _call_flat(self, args, captured_inputs, cancellation_manager=None):\n    \"\"\"Executes the wrapped function.\n\n    Args:\n      args: a list of Tensors or Variables. Arguments from the Python function\n        should be filtered before calling this method: objects aside from\n        Tensors, CompositeTensors, and Variables are ignored. Any\n        CompositeTensors should be expanded before calling this method.\n      captured_inputs: the captured inputs that are also part of the input args\n        to the actual execution. By default, it should be self._captured_inputs.\n      cancellation_manager: (Optional.) A `CancellationManager` that can be\n        used to cancel function invocation.\n\n    Returns:\n      The result of applying the TF function to `args`.\n\n    Raises:\n      ValueError: If `args` contains anything other than Tensors or Variables.\n    \"\"\"\n    ctx = context.context()\n    executing_eagerly = ctx.executing_eagerly()\n\n    # Copy saveable status of function's graph to current FuncGraph.\n    default_graph = ops.get_default_graph()\n    if default_graph.building_function and not self._func_graph.saveable:\n      default_graph.mark_as_unsaveable(self._func_graph.saving_errors)\n\n    if (tape.could_possibly_record() or\n        hasattr(default_graph, \"watch_variable\")):\n      for v in self._func_graph.variables:\n        resource_variable_ops.variable_accessed(v)\n\n    tensor_inputs = []\n    variables_used = set([])\n    for i, arg in enumerate(args):\n      if isinstance(arg, resource_variable_ops.BaseResourceVariable):\n        # We can pass a variable more than once, and in this case we need to\n        # pass its handle only once.\n        if id(arg.handle) in variables_used:\n          continue\n        resource_variable_ops.variable_accessed(arg)\n        tensor_inputs.append(arg.handle)\n        variables_used.add(id(arg.handle))\n      elif isinstance(arg, ops.Tensor):\n        tensor_inputs.append(arg)\n        if not executing_eagerly:\n          # If we're graph building, shape inference is on. We check for input\n          # compatibility up front to avoid hard to debug incompatibilities\n          # later.\n          graph_input_shape = tensor_shape.TensorShape(\n              self._func_graph.inputs[i].shape)\n          if not graph_input_shape.is_compatible_with(arg.shape):\n            if self._arg_keywords:\n              arg_name = \"'{}'\".format(self._arg_keywords[i])\n            else:\n              arg_name = \"with index {}\".format(i)\n            raise ValueError(\n                f\"The argument {arg_name} (value {arg}) is not compatible with \"\n                \"the shape this function was traced with. Expected shape \"\n                f\"{self._func_graph.inputs[i].shape}, but got shape \"\n                f\"{arg.shape}.\\n\\nIf you called get_concrete_function, you may \"\n                \"need to pass a tf.TensorSpec(..., shape=...) with a less \"\n                \"specific shape, having None on axes which can vary.\")\n      else:\n        raise ValueError(f\"{i:d}-th input {arg} must be a Tensor, got \"\n                         f\"{type(arg)} when calling {self._func_graph.name}.\")\n    args = tensor_inputs + captured_inputs\n    possible_gradient_type = gradients_util.PossibleTapeGradientTypes(args)\n    if (possible_gradient_type == gradients_util.POSSIBLE_GRADIENT_TYPES_NONE\n        and executing_eagerly):\n      # No tape is watching; skip to running the function.\n      return self._build_call_outputs(self._inference_function.call(\n          ctx, args, cancellation_manager=cancellation_manager))\n    forward_backward = self._select_forward_and_backward_functions(\n        args,\n        possible_gradient_type,\n        executing_eagerly)\n    forward_function, args_with_tangents = forward_backward.forward()\n    if executing_eagerly:\n      flat_outputs = forward_function.call(\n          ctx, args_with_tangents, cancellation_manager=cancellation_manager)\n    else:\n      with default_graph._override_gradient_function(  # pylint: disable=protected-access\n          {\"PartitionedCall\": self._get_gradient_function(),\n           \"StatefulPartitionedCall\": self._get_gradient_function()}):\n        flat_outputs = forward_function.call(ctx, args_with_tangents)\n    forward_backward.record(flat_outputs)\n    return self._build_call_outputs(flat_outputs)\n\n  def _experimental_with_cancellation_manager(self, cancellation_manager):\n    \"\"\"Returns a callable that invokes a cancellable version of this function.\n\n    Args:\n      cancellation_manager: A `CancellationManager` object that can be used to\n        cancel function invocation.\n\n    Returns:\n      A callable with the same signature as this concrete function.\n    \"\"\"\n\n    def cancellable_call(*args, **kwargs):\n      return self._call_impl(\n          args, kwargs, cancellation_manager=cancellation_manager)\n\n    return cancellable_call\n\n  @property\n  def name(self):\n    \"\"\"`ConcreteFunction` name.\"\"\"\n    return self._delayed_rewrite_functions.forward().name\n\n  @property\n  def graph(self):\n    \"\"\"Returns the graph from which this function was constructed.\"\"\"\n    return self._func_graph\n\n  @property\n  def inputs(self):\n    \"\"\"Returns tensors in `self.graph` corresponding to arguments.\"\"\"\n    return self._func_graph.inputs\n\n  @property\n  def structured_input_signature(self):\n    \"\"\"Returns structured signature for this concrete function.\n\n    Returns:\n      A tuple `(args, kwargs)`, where:\n\n        * `args` is a tuple that specifies the expected type or value each for\n          positional argument.\n        * `kwargs` is a dictionary that specifies the expected type or value\n          for each keyword-only argument.\n\n      The type or value for each argument is specified using one of the\n      following:\n\n        * A `tf.TypeSpec`, indicating that a Tensor or other TensorFlow-native\n          value is expected.\n        * A Python value, such as an integer, indicating that an equal value\n          is expected.\n        * A nested structure of `tf.TypeSpec`s and Python values, indicating\n          that a corresponding nested structure is expected.\n    \"\"\"\n    return self._func_graph.structured_input_signature\n\n  @property\n  def outputs(self):\n    \"\"\"Returns tensors in `self.graph` corresponding to returned tensors.\"\"\"\n    return self._func_graph.outputs\n\n  @property\n  def structured_outputs(self):\n    \"\"\"Returns outputs in `self.graph` as returned by the original function.\"\"\"\n    return self._func_graph.structured_outputs\n\n  def set_external_captures(self, captures):\n    \"\"\"Updates the function capture values.\n\n    The new values must have tensor types and shapes consistent with the\n    original captures of the concrete function, but it is allowed to change a\n    value captured with a deferred one and vice-versa.\n\n    Args:\n      captures: A list of tensors or closures. Tensors are value captures, and\n        closures are call-time (deferred captures).\n    \"\"\"\n    # TODO(wxinyi): 1. verify that the new captures' type spec is compatible\n    # with the original's. However, doing so requires MirroredVariable captures\n    # initialized. 2. replace the original/new captures/deferred\n    # captures in the wrapped graph. Doing such for a capture-to-deferred\n    # capture replacement requires more arguments than the deferred capture\n    # itself, e.g. default value, spec.\n    self._captured_inputs = captures\n\n  def replace_capture_with_deferred_capture(self,\n                                            tensor,\n                                            closure,\n                                            spec,\n                                            placeholder=None,\n                                            default_value=None):\n    \"\"\"Replaces existing capture `tensor` with a deferred capture `closure`.\n\n    This API replaces the capture `tensor` from the concrete function's captured\n    inputs list, and places the deferred capture `closure` in\n    its spot so the order of captured inputs is preserved. This is important\n    because the old `tensor` and the new `closure` will have the same internal\n    placeholder, which can be passed through the `placeholder` argument, or\n    skipped, in which case we find the placeholder from internal inputs by\n    indexing `tensor` in the external captured inputs list. Thus, it is\n    important that the new deferred capture has output spec (specified by the\n    `spec` argument) compatible with the internal placeholder (`placeholder`)\n    and the original capture (`tensor`).\n\n    For example,\n\n    ```python\n    bool_captured_tensor = tf.constant(True)\n    float_captured_tensor = tf.constant([3.], dtype=tf.float32)\n    value = tf.constant([2.], dtype=tf.float32)\n\n    @tf.function\n    def fn():\n      deferred_tensor = ops.get_default_graph().capture_call_time_value(\n          lambda: value,\n          tf.TensorSpec(shape=(1,), dtype=tf.float32))\n      if bool_captured_tensor:\n        return deferred_tensor\n      else:\n        return deferred_tensor + float_captured_tensor\n\n    concrete_fn = fn.get_concrete_function()\n    print(concrete_fn())  # tf.Tensor([2.], shape=(1,), dtype=float32)\n\n    new_bool_captured_tensor = constant_op.constant(False)\n    def bool_closure():\n      return new_bool_captured_tensor\n\n    concrete_fn.replace_capture_with_deferred_capture(\n        bool_captured_tensor,\n        bool_closure,\n        spec=tensor_spec.TensorSpec(shape=(), dtype=dtypes.bool))\n\n    print(concrete_fn())  # tf.Tensor([5.], shape=(1,), dtype=float32)\n    ```\n\n    Args:\n      tensor: Tensor already captured. This `tensor` should be listed in\n        concrete_function.captured_inputs except when it's empty such as when\n        the concrete function is restored from SavedModel.\n      closure: function which takes no arguments, to be evaluated at function\n        call time, returning a nest of tensors compatible with `spec`.\n      spec: nest of TypeSpec for the value to capture.\n      placeholder: optional. The internal placeholder corresponding to the\n        captured `tensor` and the new `closure`.\n      default_value: optional value to use in environments that cannot safely\n        evaluate closure.\n    \"\"\"\n    capture_index = None\n    for i, capture in enumerate(self._captured_inputs):\n      if id(tensor) == id(capture):\n        capture_index = i\n        break\n\n    if placeholder is None:\n      if capture_index is None:\n        raise ValueError(\n            f\"Did not find `tensor` argument {tensor} in the ConcreteFunction's\"\n            \" captured inputs list, and did not receive a placeholder argument.\"\n            \" Thus we're unable to infer the internal placeholder. \")\n\n      placeholder = self.inputs[-len(self._captured_inputs) + capture_index]\n\n    if not (spec.is_compatible_with(tensor) or\n            spec.is_compatible_with(placeholder)):\n      raise ValueError(\n          f\"Attempting to substitute closure with spec {spec} that's \"\n          f\"incompatible with the original capture {tensor} or the internal \"\n          f\"placeholder {placeholder}.\")\n\n    self._func_graph.replace_capture_with_deferred_capture(\n        tensor=tensor,\n        closure=closure,\n        spec=spec,\n        placeholder=placeholder,\n        default_value=default_value)\n\n    if capture_index is not None:\n      self._captured_inputs[capture_index] = closure\n\n  @property\n  def captured_inputs(self):\n    \"\"\"Returns external Tensors captured by this function.\n\n    self.__call__(*args) passes `args + self.captured_inputs` to the function.\n    \"\"\"\n    return nest.flatten(\n        [x() if callable(x) else x for x in self._captured_inputs],\n        expand_composites=True)\n\n  @property\n  def function_def(self):\n    \"\"\"Returns a `FunctionDef` object representing this function.\"\"\"\n    return self._delayed_rewrite_functions.forward().definition\n\n  @property\n  def output_shapes(self):\n    \"\"\"The function's output shapes.\"\"\"\n    return nest.map_structure(\n        lambda x: getattr(x, \"shape\", tensor_shape.TensorShape(None)),\n        composite_tensor.replace_composites_with_components(\n            self._func_graph.structured_outputs),\n        expand_composites=False)\n\n  @property\n  def output_dtypes(self):\n    # TODO(akshayka): Consider removing this.\n    return nest.map_structure(\n        lambda x: x.dtype if x is not None else None,\n        composite_tensor.replace_composites_with_components(\n            self._func_graph.structured_outputs),\n        expand_composites=False)\n\n  def add_to_graph(self, g=None):\n    \"\"\"Registers the function, adds it to the graph g or default graph.\n\n    Args:\n      g: If specified, registers the function with this graph. Defaults to the\n        current context (either the default graph or the eager context).\n    \"\"\"\n    # If we are not executing eagerly, adds the function to default graph if no\n    # graph is specified.\n    # In case of eager execution, function definition gets added to context\n    # during construction itself.\n\n    if not context.executing_eagerly() and not g:\n      g = ops.get_default_graph()\n    self._delayed_rewrite_functions.forward().add_to_graph(g)\n\n  def add_gradient_functions_to_graph(self, g=None):\n    \"\"\"Add forward/backward functions to graph `g` or the current context.\"\"\"\n    if not context.executing_eagerly() and not g:\n      g = ops.get_default_graph()\n    self._delayed_rewrite_functions.forward().add_to_graph(g)\n    forward_function, backward_function = (\n        self._delayed_rewrite_functions.forward_backward())\n    forward_function.add_to_graph(g)\n    backward_function.add_to_graph(g)\n\n  def _get_gradient_function(self):\n    \"\"\"Returns gradient function. It will be lazily created at first call.\"\"\"\n    return self._delayed_rewrite_functions._rewrite_forward_and_call_backward  # pylint: disable=protected-access\n\n  def _select_forward_and_backward_functions(\n      self, args, possible_gradient_type, executing_eagerly):\n    \"\"\"Selects forward and backward functions based on the calling context.\n\n    The forward function computes the \"real\" function outputs, `self._outputs`,\n    and any extra values needed by the corresponding backward function.\n\n    Args:\n      args: A flat list of Tensors with all of the inputs to the forward\n        function (including user-specified and captured inputs).\n      possible_gradient_type: One of gradients_util.POSSIBLE_GRADIENT_TYPES_*.\n      executing_eagerly: Boolean, the value of context.executing_eagerly().\n\n    Returns:\n      An object with a `forward` method returning a tuple of (forward_function :\n      _EagerDefinedFunction, augmented_arguments : List), and a corresponding\n      `record` method which takes outputs from the forward function and records\n      the operation. forward_function should be called with augmented_arguments.\n    \"\"\"\n    if executing_eagerly:\n      input_tangents = forwardprop_util.pack_tangents(args)\n    else:\n      input_tangents = forwardprop_util.TangentInfo()\n    need_gradients_for_jvps = tape.should_record_backprop(\n        input_tangents.tangents)\n    # Allows re-use of forward and backward function pairs depending on the\n    # tapes and forward accumulators watching its inputs.\n    cache_key = (need_gradients_for_jvps, input_tangents.indices)\n    if (possible_gradient_type\n        == gradients_util.POSSIBLE_GRADIENT_TYPES_FIRST_ORDER):\n      if input_tangents.indices or executing_eagerly:\n        # There is a single non-persistent tape active, so the user can only\n        # request first-order gradients from a tape. We can spend less time\n        # graph building since we know this.\n        #\n        # We may still end up computing higher-order gradients, but that'd be\n        # through `tf.gradients`, which can re-write the forward pass and so\n        # needs no preparation here.\n        functions = self._first_order_tape_functions.get(cache_key, None)\n        if functions is None:\n          functions = _FirstOrderTapeGradientFunctions(\n              self._func_graph, self._attrs, self._garbage_collector,\n              forwardprop_input_indices=input_tangents.indices,\n              delayed_rewrite_functions=self._delayed_rewrite_functions,\n              need_gradients_for_jvps=need_gradients_for_jvps)\n          self._first_order_tape_functions[cache_key] = functions\n        return _ForwardBackwardCall(\n            functions, args, input_tangents.tangents, tape_watching=True)\n      else:\n        # We can avoid computing second-order gradients in some cases by doing a\n        # delayed rewrite when graph building. Since we know we'll only compute\n        # first-order tape gradients, the delayed rewrite is safe: we won't need\n        # to tell the tape about side outputs.\n        #\n        # TODO(allenl): This case is really dirty. It would be better if we\n        # could temporarily pop all of the current tapes to avoid\n        # accidentally taking second-order gradients.\n        return _ForwardBackwardCall(\n            self._delayed_rewrite_functions, args, input_tangents.tangents,\n            tape_watching=True)\n    elif (possible_gradient_type\n          == gradients_util.POSSIBLE_GRADIENT_TYPES_HIGHER_ORDER):\n      # Either there's a persistent tape watching, or there are multiple nested\n      # tapes. Either way, the user may request higher-order gradients. We'll\n      # spend a bit more time and make sure higher-order gradients are correct.\n      functions = self._higher_order_tape_functions.get(\n          cache_key, None)\n      if functions is None:\n        functions = _HigherOrderTapeGradientFunctions(\n            self._func_graph, self._attrs, self._garbage_collector,\n            forwardprop_input_indices=input_tangents.indices,\n            delayed_rewrite_functions=self._delayed_rewrite_functions,\n            need_gradients_for_jvps=need_gradients_for_jvps)\n        self._higher_order_tape_functions[cache_key] = functions\n      return _ForwardBackwardCall(functions, args, input_tangents.tangents,\n                                  tape_watching=True)\n    # else possible_gradient_type == POSSIBLE_GRADIENT_TYPES_NONE, meaning no\n    # tape is recording.\n    return _ForwardBackwardCall(\n        self._delayed_rewrite_functions, args, input_tangents.tangents,\n        tape_watching=False)\n\n  def _build_call_outputs(self, result):\n    \"\"\"Maps the fdef output list to actual output structure.\n\n    Args:\n      result: Output lists defined by FunctionDef.\n    Returns:\n      The actual call output.\n    \"\"\"\n    # TODO(jlchu): call C++ version in function.cc when speed is improved\n    if self._func_graph.structured_outputs is None:\n      return result\n\n    # Replace outputs with results, skipping over any 'None' values.\n    outputs_list = nest.flatten(\n        self._func_graph.structured_outputs, expand_composites=True)\n    j = 0\n    for i, o in enumerate(outputs_list):\n      if o is not None:\n        handle_data_util.copy_handle_data(self.outputs[j], result[j])\n        outputs_list[i] = result[j]\n        j += 1\n    ret = nest.pack_sequence_as(self._func_graph.structured_outputs,\n                                outputs_list, expand_composites=True)\n    return ret\n\n  @property\n  def _as_name_attr_list(self):\n    \"\"\"Returns a `NameAttrList` representing this function.\"\"\"\n    ret = attr_value_pb2.NameAttrList(name=self.name)\n    for name, value in self._attrs.items():\n      ret.attr[name].CopyFrom(value)\n    return ret\n\n  def _structured_signature_summary(self, default_values=False):\n    \"\"\"Returns a string summarizing this function's structured signature.\n\n    Args:\n      default_values: If true, then include default values in the signature.\n\n    Returns:\n      A `string`.\n    \"\"\"\n    # Note: we can't just use self._funcion_spec.signature_summary(), because\n    # that would show \"_BOUND_VALUE\" as the default value for all arguments.\n    assert self._function_spec is not None\n    arg_specs, kwarg_specs = self.structured_input_signature\n    arg_names = list(self._function_spec.arg_names)\n\n    # If an explicit input_signature is provided to @tf.function, then any\n    # arguments with defaults that are not covered by that explicit signature\n    # are simply dropped from the signature.\n    # TODO(b/159639913) Look into whether dropping arguments with default values\n    # from the signature is the right thing to do.\n    arg_names = arg_names[:len(arg_specs)]\n\n    if default_values:\n      for i in range(len(arg_names)):\n        if not _contains_type_spec(arg_specs[i]):\n          arg_names[i] += \"={}\".format(arg_specs[i])\n    if kwarg_specs:\n      arg_names.append(\"*\")\n      for name, spec in kwarg_specs.items():\n        arg_names.append(name)\n        if default_values and not _contains_type_spec(spec):\n          arg_names[-1] += \"={}\".format(spec)\n    signature = f\"{self._func_graph.name}({', '.join(arg_names)})\"\n\n    return signature\n\n  def _flat_signature_summary(self):\n    \"\"\"Returns a string summarizing this function's flat signature.\"\"\"\n    assert self._arg_keywords is not None\n    assert self._num_positional_args is not None\n    arg_names = self._arg_keywords\n    if self._num_positional_args > len(arg_names):\n      arg_names.extend(\n          \"<arg{}>\".format(i + 1)\n          for i in range(len(arg_names), self._num_positional_args))\n    return f\"{self._func_graph.name}({', '.join(arg_names)})\"\n\n  def pretty_printed_signature(self, verbose=True):\n    \"\"\"Returns a string summarizing the signature of this concrete function.\"\"\"\n    if not verbose:\n      return self._structured_signature_summary(default_values=True)\n\n    def pretty_print_spec(spec):\n      \"\"\"Returns a string describing the spec for a single argument.\"\"\"\n      if isinstance(spec, tensor_spec.TensorSpec):\n        return \"{} Tensor, shape={}\".format(spec.dtype.name, spec.shape)\n      elif nest.is_sequence(spec):\n        pieces = nest.flatten(spec, expand_composites=False)\n        markers = [_Marker(\"<{}>\".format(i + 1)) for i in range(len(pieces))]\n        structure = nest.pack_sequence_as(spec, markers)\n        # Ensure dictionaries are sorted by key (for determinism)\n        result = pprint.pformat(structure, width=10000)\n        for (marker, piece) in zip(markers, pieces):\n          result += \"\\n      {}: {}\".format(marker, pretty_print_spec(piece))\n        return result\n      else:\n        return repr(spec)\n\n    lines = [self._structured_signature_summary(default_values=True)]\n    arg_specs, kwarg_specs = self.structured_input_signature\n    names = list(self._function_spec.arg_names)\n\n    # If an explicit input_signature is provided to @tf.function, then any\n    # arguments with defaults that are not covered by that explicit signature\n    # are simply dropped from the signature.\n    # TODO(b/159639913) Look into whether dropping arguments with default values\n    # from the signature is the right thing to do.\n\n    # Note: we can skip bound args, since we already displayed their bound\n    # value in the signature summary.\n    arg_details = []\n    for (name, spec) in zip(names[:len(arg_specs)], list(arg_specs)):\n      if _contains_type_spec(spec):\n        arg_details.append(\"    {}: {}\".format(name, pretty_print_spec(spec)))\n\n    if kwarg_specs:\n      for kwarg in sorted(kwarg_specs):\n        spec = kwarg_specs[kwarg]\n        if _contains_type_spec(spec):\n          arg_details.append(\"    {}: {}\".format(\n              kwarg, pretty_print_spec(spec)))\n\n    if arg_details:\n      lines.append(\"  Args:\")\n      lines.extend(arg_details)\n    lines.append(\"  Returns:\")\n\n    def spec_from_value(value):\n      # For loaded function, structured_outputs are already specs.\n      if isinstance(value, type_spec.TypeSpec):\n        return value\n      return type_spec.type_spec_from_value(value)\n\n    lines.append(\"    {}\".format(\n        pretty_print_spec(\n            nest.map_structure(spec_from_value, self.structured_outputs))))\n\n    return \"\\n\".join(lines)\n\n  def __repr__(self):\n    if self._function_spec is not None:\n      return \"<ConcreteFunction {} at 0x{:X}>\".format(\n          self.pretty_printed_signature(verbose=False), id(self))\n    elif not (self._num_positional_args is None or self._arg_keywords is None):\n      return \"<ConcreteFunction {} at 0x{:X}>\".format(\n          self._flat_signature_summary(), id(self))\n    else:\n      return object.__repr__(self)\n\n  def __str__(self):\n    if self._function_spec is not None:\n      return \"ConcreteFunction {}\".format(self.pretty_printed_signature())\n    else:\n      return self.__repr__()\n\n\n_pywrap_utils.RegisterType(\"Tensor\", ops.Tensor)\n_pywrap_utils.RegisterType(\"EagerTensor\", ops.EagerTensor)\n_pywrap_utils.RegisterType(\"IndexedSlices\", ops.IndexedSlices)\n\n\ndef _deterministic_dict_values(dictionary):\n  return tuple(dictionary[key] for key in sorted(dictionary))\n\n\nclass FunctionSpec(object):\n  \"\"\"Specification of how to bind arguments to a function.\"\"\"\n\n  @staticmethod\n  def from_function_and_signature(python_function,\n                                  input_signature,\n                                  is_pure=False,\n                                  experimental_follow_type_hints=False,\n                                  jit_compile=None):\n    \"\"\"Create a FunctionSpec instance given a python function and signature.\n\n    Args:\n      python_function: a function to inspect\n      input_signature: a signature of the function (None, if variable)\n      is_pure: if True all input arguments (including variables and constants)\n      will be converted to tensors and no variable changes allowed.\n      experimental_follow_type_hints: see `tf.function`\n      jit_compile: see `tf.function`\n\n    Returns:\n      instance of FunctionSpec\n    \"\"\"\n    fullargspec = tf_inspect.getfullargspec(python_function)\n    if (input_signature is not None and\n        set(fullargspec.kwonlyargs) - set(fullargspec.kwonlydefaults or ())):\n      nodefault_kwonlyargs = set(fullargspec.kwonlyargs)\n      if fullargspec.kwonlydefaults is not None:\n        nodefault_kwonlyargs -= set(fullargspec.kwonlydefaults)\n      raise ValueError(\"Cannot build TF function from \"\n                       f\"{python_function.__name__}: keyword-only arguments \"\n                       \"must have default values when input_signature is \"\n                       \"provided. Got keyword-only arguments without default \"\n                       f\"values: {sorted(nodefault_kwonlyargs)}.\")\n\n    # Checks if the `fullargspec` contains self or cls as its first argument.\n    is_method = tf_inspect.isanytargetmethod(python_function)\n\n    # Treat a wrapped partial function as a special case. For all arguments that\n    # were overridden with keywords in the partial:\n    #   - remove the corresponding arguments,\n    #   - remove the corresponding keywords.\n    _, unwrapped = tf_decorator.unwrap(python_function)\n    if isinstance(unwrapped, functools.partial):\n      # Also consider the Python3 case with kwonlydefaults.\n      if fullargspec.defaults or fullargspec.kwonlydefaults:\n        new_defaults = fullargspec.defaults\n        new_args = fullargspec.args\n        if fullargspec.defaults:\n          # To be able to canonicalize the function properly, we want to ignore\n          # default values that are overridden via a partial kwarg. For example:\n          #\n          #   def func(a, b, c, d=5, e=7):\n          #     return a, b, c, d, e\n          #   p_func = tf.function(functools.partial(func, 10, e=9))\n          #\n          # Here we want to drop from the defaults the parameter `e`. If we\n          # forwarded the call to the partial function with a default for `e`\n          # we would get an error for passing two values for one parameter.\n          #\n          # Note that this has a limitation: we can only override parameters at\n          # the end of the parameter list.\n          #\n          # In this case we want to end up with 3 arguments (b, c, d) and 1\n          # default value (5). We do this by constructing a mask where 0 stands\n          # for a value that was overridden by a partial kwarg. The seemingly\n          # complicated logic below does just that - for arguments (b, c, d, e)\n          # we would get a mask (1, 1, 1, 0).\n          old_args = fullargspec.args\n          old_defaults = fullargspec.defaults\n\n          no_default = object()\n          num_args_without_defaults = len(old_args) - len(old_defaults)\n          left_padding = tuple([no_default] * num_args_without_defaults)\n\n          args_with_defaults = zip(old_args, left_padding + old_defaults)\n\n          # Create a mask where 0 stands for args that had a partial kwarg\n          # defined.\n          non_keyword_defaults_mask = [\n              0 if key in unwrapped.keywords else 1 for key in old_args\n          ]\n          # Keep only arguments and defaults that were not kwargs of partial.\n          new_args_with_defaults = list(\n              itertools.compress(args_with_defaults, non_keyword_defaults_mask))\n          # Keep all args.\n          new_args = [arg for arg, _ in new_args_with_defaults]\n          # Keep only real default values.\n          new_defaults = [\n              default for _, default in new_args_with_defaults\n              if default is not no_default\n          ]\n        fullargspec = tf_inspect.FullArgSpec(\n            args=new_args,\n            varargs=fullargspec.varargs,\n            varkw=fullargspec.varkw,\n            defaults=new_defaults,\n            kwonlyargs=[],\n            kwonlydefaults={},\n            annotations=fullargspec.annotations)\n\n    # Get the function's name.  Remove functools.partial wrappers if necessary.\n    while isinstance(python_function, functools.partial):\n      python_function = python_function.func\n    name = getattr(python_function, \"__name__\", \"f\")\n\n    return FunctionSpec(\n        fullargspec,\n        is_method,\n        input_signature,\n        is_pure=is_pure,\n        jit_compile=jit_compile,\n        experimental_follow_type_hints=experimental_follow_type_hints,\n        name=name)\n\n  def __init__(self,\n               fullargspec,\n               is_method,\n               input_signature,\n               is_pure=False,\n               experimental_follow_type_hints=False,\n               name=None,\n               jit_compile=None):\n    \"\"\"Constructs a FunctionSpec describing a python function.\n\n    Args:\n      fullargspec: `tf_inspect.FullArgSpec` object describing the function.\n      is_method: True if the function is a method.\n      input_signature: a signature of the function (None, if variable)\n      is_pure: if True all input arguments (including variables and constants)\n        will be converted to tensors and no variable changes allowed.\n      experimental_follow_type_hints: see `tf.function`.\n      name: Name of the function\n      jit_compile: see `tf.function`.\n    \"\"\"\n    self._fullargspec = fullargspec\n    self._is_method = is_method\n    self._is_pure = is_pure\n    self._jit_compile = jit_compile\n    self._experimental_follow_type_hints = experimental_follow_type_hints\n\n    # TODO(edloper): Include name when serializing for SavedModel?\n    self._name = name or \"f\"\n\n    if self._is_method:\n      # Remove `self`: default arguments shouldn't be matched to it.\n      # TODO(b/127938157): Should this error out if there is no arg to\n      # be removed?\n      args = fullargspec.args[1:]\n    else:\n      args = fullargspec.args\n\n    # A cache mapping from argument name to index, for canonicalizing\n    # arguments that are called in a keyword-like fashion.\n    self._args_to_indices = {arg: i for i, arg in enumerate(args)}\n    self._arg_names = args\n\n    # A cache mapping from arg index to default value, for canonicalization.\n    default_values = fullargspec.defaults\n    offset = len(args) - len(default_values or [])\n    self._arg_indices_to_default_values = {\n        offset + index: default\n        for index, default in enumerate(default_values or [])\n    }\n    self._arg_indices_no_default_values = set(range(len(args))) - set(\n        self._arg_indices_to_default_values)\n    if input_signature is None:\n      self._input_signature = None\n    else:\n      self._input_signature = tuple(input_signature)\n      self._flat_input_signature = tuple(nest.flatten(input_signature,\n                                                      expand_composites=True))\n\n  @property\n  def fullargspec(self):\n    return self._fullargspec\n\n  @property\n  def is_method(self):\n    return self._is_method\n\n  @property\n  def args_to_indices(self):\n    return self._args_to_indices\n\n  @property\n  def kwargs_to_include(self):\n    return self._kwargs_to_include\n\n  @property\n  def input_signature(self):\n    return self._input_signature\n\n  @property\n  def flat_input_signature(self):\n    return self._flat_input_signature\n\n  @property\n  def is_pure(self):\n    return self._is_pure\n\n  @property\n  def jit_compile(self):\n    return self._jit_compile\n\n  @property\n  def arg_names(self):\n    return self._arg_names\n\n  @property\n  def vararg_name(self):\n    return self._fullargspec.varargs\n\n  @property\n  def varkw_name(self):\n    return self._fullargspec.varkw\n\n  def signature_summary(self, default_values=False):\n    \"\"\"Returns a string summarizing this function's signature.\n\n    Args:\n      default_values: If true, then include default values in the signature.\n\n    Returns:\n      A `string`.\n    \"\"\"\n    args = list(self._arg_names)\n    if default_values:\n      for (i, default) in self._arg_indices_to_default_values.items():\n        args[i] += \"={}\".format(default)\n    if self._fullargspec.kwonlyargs:\n      args.append(\"*\")\n      for arg_name in self._fullargspec.kwonlyargs:\n        args.append(arg_name)\n        if default_values and arg_name in self._fullargspec.kwonlydefaults:\n          args[-1] += \"={}\".format(self._fullargspec.kwonlydefaults[arg_name])\n    return f\"{self._name}({', '.join(args)})\"\n\n  def _to_tensor_or_tensor_spec(self, x):\n    return (x if isinstance(x, (ops.Tensor, tensor_spec.TensorSpec))\n            else ops.convert_to_tensor(x))\n\n  def _convert_variables_to_tensors(self, args, kwargs):\n    args = [self._to_tensor_or_tensor_spec(x) for x in args]\n    kwargs = {kw: self._to_tensor_or_tensor_spec(x)\n              for kw, x in kwargs.items()}\n    return tuple(args), kwargs\n\n  def _convert_annotated_args_to_tensors(self, args, kwargs):\n    \"\"\"Attempts to autobox arguments annotated as tf.Tensor.\"\"\"\n    if self.input_signature is not None:\n      return\n\n    args = list(args)\n    for i, arg in enumerate(args):\n      # See\n      # https://docs.python.org/3/library/inspect.html#inspect.getfullargspec\n      if i < len(self._fullargspec.args):\n        annotation_key = self._fullargspec.args[i]\n      else:\n        annotation_key = self._fullargspec.varargs\n      arg_annotation = self._fullargspec.annotations.get(annotation_key, None)\n\n      # TODO(rahulkamat): Change to TensorLike (here ans below)\n      if arg_annotation == ops.Tensor:\n        args[i] = self._to_tensor_or_tensor_spec(arg)\n\n    for kw, v in kwargs.items():\n      if kw in self._fullargspec.kwonlyargs or kw in self._fullargspec.args:\n        annotation_key = kw\n      else:\n        annotation_key = self._fullargspec.varkw\n      kwarg_annotation = self._fullargspec.annotations.get(annotation_key, None)\n      if kwarg_annotation == ops.Tensor:\n        kwargs[kw] = self._to_tensor_or_tensor_spec(v)\n    return tuple(args), kwargs\n\n  def _validate_inputs(self, flat_inputs):\n    \"\"\"Raises an error if inputs contain illegal values.\"\"\"\n    for inp in flat_inputs:\n      # TODO(b/183107079): Allow these once they're handled properly.\n      if isinstance(inp, weakref.ref):\n        raise ValueError(\n            f\"weakref input {inp} not supported for function {self._name}\")\n\n  def canonicalize_function_inputs(self, *args, **kwargs):\n    \"\"\"Canonicalizes `args` and `kwargs`.\n\n    Canonicalize the inputs to the Python function using a `FunctionSpec`\n    instance. In particular, we parse the varargs and kwargs that the\n    original function was called with into a tuple corresponding to the\n    Python function's positional (named) arguments and a dictionary\n    corresponding to its kwargs.  Missing default arguments are added.\n\n    If this `FunctionSpec` has an input signature, then it is used to convert\n    arguments to tensors; otherwise, any inputs containing numpy arrays are\n    converted to tensors.\n\n    Additionally, any inputs containing numpy arrays are converted to Tensors.\n\n    Args:\n      *args: The varargs this object was called with.\n      **kwargs: The keyword args this function was called with.\n\n    Returns:\n      A canonicalized ordering of the inputs, as well as full and filtered\n      (Tensors and Variables only) versions of their concatenated flattened\n      representations, represented by a tuple in the form (args, kwargs,\n      flat_args, filtered_flat_args). Here: `args` is a full list of bound\n      arguments, and `kwargs` contains only true keyword arguments, as opposed\n      to named arguments called in a keyword-like fashion.\n\n    Raises:\n      ValueError: If a keyword in `kwargs` cannot be matched with a positional\n        argument when an input signature is specified, or when the inputs\n        do not conform to the input signature.\n    \"\"\"\n    if self._is_pure:\n      args, kwargs = self._convert_variables_to_tensors(args, kwargs)\n    if self._experimental_follow_type_hints:\n      args, kwargs = self._convert_annotated_args_to_tensors(args, kwargs)\n    # Pre-calculate to reduce overhead\n    arglen = len(args)\n    if self._input_signature is not None:\n      if arglen > len(self._input_signature):\n        raise TypeError(f\"{self.signature_summary()} specifies \"\n                        f\"{len(self._input_signature)} positional arguments, \"\n                        f\"but got {arglen}.\")\n      for arg in six.iterkeys(kwargs):\n        index = self._args_to_indices.get(arg, None)\n        if index is None:\n          raise TypeError(f\"{self.signature_summary()} got unexpected keyword \"\n                          f\"argument `{arg}`.\")\n        if index >= len(self._input_signature):\n          raise TypeError(\n              f\"{self.signature_summary()} got keyword argument `{arg}` that \"\n              \"was not included in input_signature.\")\n\n    if not kwargs:\n      inputs = args\n      if self._arg_indices_to_default_values:\n        try:\n          inputs += tuple(self._arg_indices_to_default_values[i]\n                          for i in range(arglen, len(self._arg_names)))\n        except KeyError:\n          missing_args = [\n              self._arg_names[i]\n              for i in range(arglen, len(self._arg_names))\n              if i not in self._arg_indices_to_default_values\n          ]\n          raise TypeError(f\"{self.signature_summary()} missing required \"\n                          f\"arguments: {', '.join(missing_args)}.\")\n\n      if self._fullargspec.kwonlydefaults:\n        kwargs.update(self._fullargspec.kwonlydefaults)\n    else:\n      # Maps from index of arg to its corresponding value, according to `args`\n      # and `kwargs`; seeded with the default values for the named args that\n      # aren't in `args`.\n      arg_indices_to_values = {\n          index: default for index, default in six.iteritems(\n              self._arg_indices_to_default_values) if index >= arglen\n      }\n      consumed_args = []\n      missing_arg_indices = self._arg_indices_no_default_values - set(\n          range(arglen))\n      for arg, value in six.iteritems(kwargs):\n        index = self._args_to_indices.get(arg, None)\n        if index is not None:\n          if index < arglen:\n            raise TypeError(f\"{self.signature_summary()} got two values for \"\n                            f\"{arg!r}.\")\n          arg_indices_to_values[index] = value\n          # These arguments in 'kwargs' might also belong to\n          # positional arguments\n          missing_arg_indices.discard(index)\n          consumed_args.append(arg)\n      for arg in consumed_args:\n        # After this loop, `kwargs` will only contain keyword_only arguments,\n        # and all positional_or_keyword arguments have been moved to `inputs`.\n        kwargs.pop(arg)\n      inputs = args + _deterministic_dict_values(arg_indices_to_values)\n      # Exclude positional args with values\n      if missing_arg_indices:\n        missing_args = [self._arg_names[i] for i in sorted(missing_arg_indices)]\n        if len(missing_args) == 1:\n          raise TypeError(f\"{self.signature_summary()} missing 1 required \"\n                          f\"argument: {missing_args[0]}.\")\n        else:\n          raise TypeError(f\"{self.signature_summary()} missing required \"\n                          f\"arguments: {', '.join(missing_args)}.\")\n\n      if kwargs and self._input_signature is not None:\n        raise TypeError(\"Keyword arguments are not supported when \"\n                        \"input_signature is provided. Signature: \"\n                        f\"{self.signature_summary()}. Keyword arguments: \"\n                        f\"{kwargs}.\")\n\n      if self._fullargspec.kwonlydefaults:\n        for (kwarg, default) in self._fullargspec.kwonlydefaults.items():\n          kwargs.setdefault(kwarg, default)\n\n    if self._input_signature is None:\n      inputs, flat_inputs, filtered_flat_inputs = _convert_numpy_inputs(inputs)\n      kwargs, flat_kwargs, filtered_flat_kwargs = _convert_numpy_inputs(kwargs)\n      flat_inputs += flat_kwargs\n      filtered_flat_inputs += filtered_flat_kwargs\n    else:\n      inputs, flat_inputs, filtered_flat_inputs = _convert_inputs_to_signature(\n          inputs, self._input_signature, self._flat_input_signature)\n\n    self._validate_inputs(flat_inputs)\n\n    return inputs, kwargs, flat_inputs, filtered_flat_inputs\n\n\ndef _convert_numpy_inputs(inputs):\n  \"\"\"Convert numpy array inputs to tensors.\"\"\"\n  # We assume that any CompositeTensors have already converted their components\n  # from numpy arrays to Tensors, so we don't need to expand composites here for\n  # the numpy array conversion. Instead, we do so because the flattened inputs\n  # are eventually passed to ConcreteFunction()._call_flat, which requires\n  # expanded composites.\n  flat_inputs = nest.flatten(inputs, expand_composites=True)\n\n  # Check for NumPy arrays in arguments and convert them to Tensors.\n  # TODO(nareshmodi): Skip ndarray conversion to tensor altogether, perhaps\n  # finding a way to store them directly in the cache key (currently not\n  # possible since ndarrays are not hashable).\n  need_packing = False\n  filtered_flat_inputs = []\n  for index, value in enumerate(flat_inputs):\n    if isinstance(value,\n                  (ops.Tensor, resource_variable_ops.BaseResourceVariable)):\n      filtered_flat_inputs.append(value)\n    elif hasattr(value, \"__array__\") and not (\n        hasattr(value, \"_should_act_as_resource_variable\") or\n        isinstance(value, (np.str_, type, composite_tensor.CompositeTensor))):\n      # This case is equivalent to _is_ndarray(value) == True\n      a = value.__array__()\n      if not isinstance(a, np.ndarray):\n        raise TypeError(f\"The output of __array__ must be an np.ndarray, \"\n                        f\"got {type(a)} from {value}.\")\n      flat_inputs[index] = constant_op.constant(a)\n      filtered_flat_inputs.append(flat_inputs[index])\n      need_packing = True\n  if need_packing:\n    return (nest.pack_sequence_as(\n        structure=inputs, flat_sequence=flat_inputs,\n        expand_composites=True), flat_inputs, filtered_flat_inputs)\n  else:\n    return inputs, flat_inputs, filtered_flat_inputs\n\n\ndef _convert_inputs_to_signature(inputs, input_signature, flat_input_signature):\n  \"\"\"Convert inputs to pass into a function with an explicit signature.\"\"\"\n\n  def format_error_message(inputs, input_signature):\n    return (\"  inputs: (\\n\" + \"    \" + \",\\n    \".join(str(i) for i in inputs) +\n            \")\\n\" + \"  input_signature: (\\n\" + \"    \" +\n            \",\\n    \".join(str(i) for i in input_signature) + \")\")\n\n  try:\n    flatten_inputs = nest.flatten_up_to(\n        input_signature,\n        inputs[:len(input_signature)],\n        expand_composites=True,\n        check_types=False)  # lists are convert to tuples for `tf.data`.\n  except ValueError:\n    raise ValueError(\"Structure of Python function inputs does not match \"\n                     \"input_signature:\\n\"\n                     f\"{format_error_message(inputs, input_signature)}.\")\n\n  need_packing = False\n  for index, (value, spec) in enumerate(zip(flatten_inputs,\n                                            flat_input_signature)):\n    if (isinstance(spec, tensor_spec.TensorSpec) and\n        not _pywrap_utils.IsTensor(value)):\n      try:\n        flatten_inputs[index] = ops.convert_to_tensor(\n            value, dtype_hint=spec.dtype)\n        need_packing = True\n      except ValueError:\n        raise ValueError(\"When input_signature is provided, all inputs to \"\n                         \"the Python function must be convertible to \"\n                         \"tensors:\\n\"\n                         f\"{format_error_message(inputs, input_signature)}.\")\n\n  if any(not spec.is_compatible_with(other) for spec, other in zip(\n      flat_input_signature,\n      flatten_inputs)):\n    raise ValueError(\"Python inputs incompatible with input_signature:\\n\"\n                     f\"{format_error_message(inputs, input_signature)}.\")\n\n  if need_packing:\n    inputs = nest.pack_sequence_as(\n        structure=input_signature,\n        flat_sequence=flatten_inputs,\n        expand_composites=True)\n\n  flat_inputs = nest.flatten(inputs, expand_composites=True)\n\n  return (inputs, flat_inputs, [\n      t for t in flat_inputs\n      if isinstance(t, (ops.Tensor, resource_variable_ops.BaseResourceVariable))\n  ])\n\n\nclass FunctionCache(object):\n  \"\"\"A lightweight container for cached functions.\n  \"\"\"\n\n  __slots__ = [\n      \"missed\", \"primary\", \"arg_relaxed_specs\", \"arg_relaxed\",\n      \"_garbage_collectors\"\n  ]\n\n  def __init__(self):\n    # The set of functions that have been missed; entries are CacheKey with\n    # input_signature `None` (e.g. a \"call context key\")\n    self.missed = set()\n    # The primary cache, mapping a fully shaped CacheKey to a function.\n    self.primary = collections.OrderedDict()\n    # A cache key lookup, mapping a CacheKey generated without shape info to a\n    # flat list of `TypeSpec`s with relaxed shapes (one for each flattened\n    # argument). Arguments that are not Tensors or `CompositeTensor`s contain a\n    # `None` for the corresponding relaxed spec.\n    self.arg_relaxed_specs = collections.OrderedDict()\n    # The secondary cache, mapping a CacheKey generated without shape info to a\n    # function.\n    self.arg_relaxed = collections.OrderedDict()\n    # All OrderedDicts require manual garbage collection.\n    self._garbage_collectors = [\n        _FunctionGarbageCollector(self.primary),\n        _FunctionGarbageCollector(self.arg_relaxed),\n        _FunctionGarbageCollector(self.arg_relaxed_specs)]\n\n  def all_values(self):\n    \"\"\"A list of all `ConcreteFunction` instances held by this cache.\"\"\"\n    # We need to simultaneously make sure our returned concrete functions are\n    # unique *and* make sure they are returned in a deterministic order for\n    # serialization.\n    #\n    # TODO(b/174215821): It's likely that we ultimately would just prefer to\n    # choose the most specific concrete function shape given a set of\n    # arguments. If and when that is implemented, this logic can be revisited.\n    primary_functions = set(self.primary.values())\n    return list(self.primary.values()) + [\n        v for v in self.arg_relaxed.values() if v not in primary_functions]\n\n\n# TODO(mdan): Refactor this and clarify relationship with def_function.Function.\n# Right now, def_function.Function is the higher level implementation.\nclass Function(object):\n  \"\"\"Wrapper class for the graph functions defined for a Python function.\n\n  See the documentation for `defun` for more information on the semantics of\n  defined functions.\n\n  `Function` class is thread-compatible meaning that minimal usage of defuns\n  (defining and calling) is thread-safe, but if users call other methods or\n  invoke the base `python_function` themselves, external synchronization is\n  necessary.\n  In addition, Function is not reentrant, so recursive functions need to call\n  the wrapped function, not the wrapper.\n  \"\"\"\n\n  def __init__(self,\n               python_function,\n               name,\n               input_signature=None,\n               attributes=None,\n               autograph=True,\n               autograph_options=None,\n               experimental_relax_shapes=False,\n               capture_by_value=None,\n               jit_compile=None,\n               experimental_follow_type_hints=False):\n    \"\"\"Initializes a `Function`.\n\n    Args:\n      python_function: the function to be wrapped.\n      name: the name given to it.\n      input_signature: a possibly nested sequence of `TensorSpec` objects\n        specifying the input signature of this function. If `None`, a separate\n        function is instantiated for each inferred input signature.\n      attributes: dict, extra keyword arguments that will be added as attribute\n        of the function.\n      autograph: whether to use autograph to compile\n        `python_function`. See https://www.tensorflow.org/guide/autograph for\n        more information.\n      autograph_options: Experimental knobs to control behavior\n        `when autograph=True`. See https://www.tensorflow.org/guide/autograph\n        for more information.\n      experimental_relax_shapes: When true, argument shapes may be relaxed to\n        avoid unnecessary retracing.\n      capture_by_value: Experimental. Whether to capture resource variables by\n        value or reference. If None, will inherit from a parent context or\n        default to False.\n      jit_compile: Force-compile the function with XLA, cf.\n        def_function.Function doc on jit_compile.\n      experimental_follow_type_hints: See the documentation for `tf.function`.\n\n    Raises:\n      ValueError: if `input_signature` is not None and the `python_function`'s\n        argspec has keyword arguments.\n    \"\"\"\n    self._python_function = python_function\n    pure_function = attributes and IMPLEMENTS_ATTRIBUTE_NAME in attributes\n    self._function_spec = FunctionSpec.from_function_and_signature(\n        python_function,\n        input_signature,\n        is_pure=pure_function,\n        experimental_follow_type_hints=experimental_follow_type_hints)\n    self._name = name\n    self._autograph = autograph\n    self._autograph_options = autograph_options\n    self._experimental_relax_shapes = experimental_relax_shapes\n    self._function_cache = FunctionCache()\n    self._function_attributes = attributes or {}\n    self._capture_by_value = capture_by_value\n    self.tracing_count = 0\n    if self.input_signature is not None:\n      self._hashable_input_signature = hash(self.flat_input_signature)\n\n    self._lock = threading.Lock()\n    # _descriptor_cache is a of instance of a class to an instance-specific\n    # `Function`, used to make sure defun-decorated methods create different\n    # functions for each instance.\n    self._descriptor_cache = weakref.WeakKeyDictionary()\n    self._jit_compile = jit_compile\n    self._experimental_follow_type_hints = experimental_follow_type_hints\n\n  def __call__(self, *args, **kwargs):\n    \"\"\"Calls a graph function specialized to the inputs.\"\"\"\n    with self._lock:\n      (graph_function,\n       filtered_flat_args) = self._maybe_define_function(args, kwargs)\n    return graph_function._call_flat(\n        filtered_flat_args, captured_inputs=graph_function.captured_inputs)  # pylint: disable=protected-access\n\n  @property\n  def python_function(self):\n    \"\"\"Returns the wrapped Python function.\"\"\"\n    return self._python_function  # pylint: disable=protected-access\n\n  @property\n  def function_spec(self):\n    return self._function_spec\n\n  @property\n  def input_signature(self):\n    \"\"\"Returns the input signature.\"\"\"\n    return self._function_spec.input_signature\n\n  @property\n  def flat_input_signature(self):\n    \"\"\"Returns the flattened input signature.\"\"\"\n    return self._function_spec.flat_input_signature\n\n  def _get_concrete_function_internal_garbage_collected(self, *args, **kwargs):\n    \"\"\"Returns a concrete function which cleans up its graph function.\"\"\"\n    if self.input_signature:\n      args, kwargs = None, None\n    with self._lock:\n      graph_function, _ = self._maybe_define_function(args, kwargs)\n    return graph_function\n\n  def _get_concrete_function_internal(self, *args, **kwargs):\n    \"\"\"Bypasses error checking when getting a graph function.\"\"\"\n    graph_function = self._get_concrete_function_internal_garbage_collected(\n        *args, **kwargs)\n    # We're returning this concrete function to someone, and they may keep a\n    # reference to the FuncGraph without keeping a reference to the\n    # ConcreteFunction object. So we won't clean up the reference cycles\n    # manually and instead will leave them to Python's garbage collector.\n    graph_function._garbage_collector.release()  # pylint: disable=protected-access\n    return graph_function\n\n  def _get_concrete_function_garbage_collected(self, *args, **kwargs):\n    \"\"\"Returns a `ConcreteFunction` specialized to inputs and execution context.\n\n    Unlike `get_concrete_function(...)`, the graph will be deleted when the\n    returned function is deleted.  It's useful to avoid creating a reference\n    cycle when you know for sure that the graph will be no longer used without\n    the returned function.\n\n    Args:\n      *args: inputs to specialize on.\n      **kwargs: inputs to specialize on.\n    \"\"\"\n    if self.input_signature:\n      if kwargs:\n        raise ValueError(\"Cannot define a TensorFlow function from a Python \"\n                         \"function with keyword arguments when \"\n                         \"input_signature is provided, got keyword arguments \"\n                         f\"({kwargs}) with input_signature \"\n                         f\"({self.input_signature}).\")\n      if args:\n        # If args are provided, they must match the input signature.\n        if not is_same_structure(self.input_signature, args):\n          raise ValueError(\"Structure of Python function inputs does not match \"\n                           f\"input_signature: inputs ({args}), \"\n                           f\"input_signature ({self.input_signature}).\")\n        flat_inputs = nest.flatten(args, expand_composites=True)\n        if any(not isinstance(arg, (ops.Tensor, tensor_spec.DenseSpec,\n                                    resource_variable_ops.BaseResourceVariable))\n               for arg in flat_inputs):\n          raise ValueError(\"When input_signature is provided, all inputs to \"\n                           \"the Python function must be Tensors, Variables, \"\n                           \"tf.TensorSpec or tf.VariableSpec objects.\")\n        if any(not spec.is_compatible_with(other)\n               for spec, other in zip(self.flat_input_signature, flat_inputs)):\n          raise ValueError(\"Python inputs incompatible with input_signature: \"\n                           f\"inputs ({args}), input_signature \"\n                           f\"({self.input_signature}).\")\n      args, kwargs = None, None\n    with self._lock:\n      graph_function, _ = self._maybe_define_function(args, kwargs)\n      seen_names = set()\n      captured = object_identity.ObjectIdentitySet(\n          graph_function.graph.internal_captures)\n      # pylint: disable=protected-access\n      graph_function._arg_keywords = []\n      prefix_counts = {}\n      # pylint: enable=protected-access\n      num_positional = 0\n      for arg in graph_function.graph.inputs:\n        if arg in captured:\n          break\n        num_positional += 1\n        user_arg_name = compat.as_str(arg.op.get_attr(\"_user_specified_name\"))\n        proposal = user_arg_name\n        while proposal in seen_names:\n          index = prefix_counts.get(user_arg_name, 1)\n          proposal = \"{}_{}\".format(user_arg_name, index)\n          prefix_counts[user_arg_name] = index + 1\n        seen_names.add(proposal)\n        graph_function._arg_keywords.append(proposal)  # pylint: disable=protected-access\n      # Anything can be a positional argument, in the same order as .inputs\n      graph_function._num_positional_args = num_positional  # pylint: disable=protected-access\n      return graph_function\n\n  def get_concrete_function(self, *args, **kwargs):\n    \"\"\"Returns a `ConcreteFunction` specialized to inputs and execution context.\n\n    Args:\n      *args: inputs to specialize on. Can be concrete values (e.g. 1)\n         or `tf.Tensor` or `tf.TensorSpec`.\n      **kwargs: keyword inputs to specialize on. Concrete values (e.g. 1)\n         or `tf.Tensor` or `tf.TensorSpec`.\n    \"\"\"\n    graph_function = self._get_concrete_function_garbage_collected(\n        *args, **kwargs)\n    graph_function._garbage_collector.release()  # pylint: disable=protected-access\n    return graph_function\n\n  def __get__(self, instance, owner):\n    \"\"\"Makes it possible to defun instance methods.\"\"\"\n    del owner\n    # `instance` here is the instance that this `Function` was accessed through\n    # e.g., for\n    #\n    #   class Foo(object):\n    #\n    #     @function.defun\n    #     def bar(self):\n    #       ...\n    #\n    #   foo = Foo()\n    #   foo.bar()  # `foo.bar` is a `Function` instance\n    #\n    # then `instance` will be `foo` (and `owner` will be `Foo`).  We create a\n    # new instance of `Function` here to allow different instances each\n    # to create variables once, thereby allowing methods to be decorated with\n    # defun. Keeps a cache to avoid retracing the function every time the\n    # descriptor is accessed.\n    if instance not in self._descriptor_cache:\n      if instance is None:\n        return self\n      # If there is no instance-specific `Function` in the cache, we construct\n      # an instance-specific `Function` that uses a weak reference to the\n      # instance (so that the instance will be correctly gc'd).\n\n      # And finally add the wrapped function to the description cache\n      self._descriptor_cache[instance] = class_method_to_instance_method(\n          self, instance)\n\n    # Return the cached `Function` for the instance\n    return self._descriptor_cache[instance]\n\n  def _cache_key(self,\n                 args,\n                 kwargs,\n                 cache_key_context,\n                 include_tensor_ranks_only=False):\n    \"\"\"Computes the cache key given inputs and execution context.\"\"\"\n    if self.input_signature is None:\n      # We always use both args and kwargs to form input even if one is empty.\n      # This reduces ambiguity, for example, when args contains a dict and\n      # kwargs is empty.\n      inputs = (args, kwargs)\n      hashable_input_signature = function_trace_type.get_arg_spec(\n          inputs, include_tensor_ranks_only, ENCODE_VARIABLES_BY_RESOURCE_ID,\n          USE_FULL_TRACE_TYPE)\n    else:\n      del args, kwargs\n      assert not include_tensor_ranks_only\n      hashable_input_signature = self._hashable_input_signature\n\n    (parent_graph, device_functions, colocation_stack, in_cross_replica_context,\n     variable_policy, xla_context_id) = cache_key_context\n\n    return CacheKey(hashable_input_signature, parent_graph, device_functions,\n                    colocation_stack, in_cross_replica_context, variable_policy,\n                    xla_context_id)\n\n  def _cache_key_context(self):\n    \"\"\"Returns execution context.\"\"\"\n    ctx = context.context()\n\n    # Don't need to open an init_scope if the _cache_key call is in eager mode\n    # already.\n    executing_eagerly = ctx.executing_eagerly()\n    parent_graph = None\n    xla_context_id = 0\n    if not executing_eagerly:\n      # We want to force function retracing for each different\n      # XLAControlFlowContext, so add `xla_context_id` to the cache key.\n      xla_context = _enclosing_xla_context()\n      if xla_context is not None and \\\n            xla_context.RequiresUniqueFunctionRetracing():\n        xla_context_id = id(xla_context)\n\n      with ops.init_scope():\n        # The graph, or whether we're executing eagerly, should be a part of the\n        # cache key so we don't improperly capture tensors such as variables.\n        executing_eagerly = ctx.executing_eagerly()\n        parent_graph = None if executing_eagerly else ops.get_default_graph()\n\n    # pylint: disable=protected-access\n    default_graph = ops.get_default_graph()\n    # TODO(b/117617952): The current distribution strategy will affect graph\n    # building (e.g. accessing different variables from different devices) and\n    # so requires retracing for each device.\n    strategy_stack = default_graph._distribution_strategy_stack\n    uses_distribution_strategy = (\n        strategy_stack and\n        strategy_stack[-1].strategy.extended._retrace_functions_for_each_device\n    )\n    if executing_eagerly:\n      colocation_stack = ()\n      if uses_distribution_strategy:\n        device_functions = (pydev.merge_device(ctx.device_name),)\n      else:\n        device_functions = ()\n    else:\n      colocation_stack = tuple(default_graph._colocation_stack.peek_objs())\n      if (uses_distribution_strategy\n          or func_graph_module.device_stack_has_callable(\n              default_graph._device_function_stack)):\n        # Putting the device in the cache key ensures that call-site device\n        # annotations are respected.\n        device_functions = tuple(default_graph._device_functions_outer_to_inner)\n      else:\n        device_functions = ()\n\n    in_cross_replica_context = False\n    try:\n      in_cross_replica_context = (strategy_stack[-1].replica_context is None)  # pylint: disable=protected-access\n    except (AttributeError, IndexError):\n      pass\n\n    if save_context.in_save_context():\n      variable_policy = (\n          save_context.get_save_options().experimental_variable_policy)\n    else:\n      variable_policy = None\n\n    return (parent_graph, device_functions, colocation_stack,\n            in_cross_replica_context, variable_policy, xla_context_id)\n\n  def _create_graph_function(self, args, kwargs, override_flat_arg_shapes=None):\n    \"\"\"Create a `ConcreteFunction` from `args` and `kwargs`.\"\"\"\n    self.tracing_count += 1\n\n    if self.input_signature is None:\n      arglen = len(args)\n    else:\n      arglen = len(self.input_signature)\n    base_arg_names = self._function_spec.arg_names[:arglen]\n    num_missing_args = arglen - len(self._function_spec.arg_names)\n    missing_arg_names = [self._function_spec.vararg_name] * num_missing_args\n    # Produce a list of missing args of the form [\"arg_0\", \"arg_1\", ...],\n    # where arg is based on the self._function_spec.vararg_name.\n    missing_arg_names = [\n        \"%s_%d\" % (arg, i) for i, arg in enumerate(missing_arg_names)\n    ]\n    arg_names = base_arg_names + missing_arg_names\n    graph_function = ConcreteFunction(\n        func_graph_module.func_graph_from_py_func(\n            self._name,\n            self._python_function,\n            args,\n            kwargs,\n            self.input_signature,\n            autograph=self._autograph,\n            autograph_options=self._autograph_options,\n            arg_names=arg_names,\n            override_flat_arg_shapes=override_flat_arg_shapes,\n            capture_by_value=self._capture_by_value),\n        self._function_attributes,\n        function_spec=self.function_spec,\n        # Tell the ConcreteFunction to clean up its graph once it goes out of\n        # scope. This is not the default behavior since it gets used in some\n        # places (like Keras) where the FuncGraph lives longer than the\n        # ConcreteFunction.\n        shared_func_graph=False)\n    return graph_function\n\n  def _define_function_with_shape_relaxation(self, args, kwargs, flat_args,\n                                             filtered_flat_args,\n                                             cache_key_context):\n    \"\"\"Define a function, relaxing arg shapes to avoid unnecessary retracing.\"\"\"\n    flat_no_comp = nest.flatten((args, kwargs), expand_composites=False)\n\n    any_composite_args = any(\n        isinstance(x, composite_tensor.CompositeTensor) for x in flat_no_comp)\n\n    # Build a cache key where TensorShapes include only rank information (and\n    # not information about the size of each dimension).\n    if not any_composite_args:\n      rank_only_cache_key = self._cache_key(\n          args, kwargs, cache_key_context, include_tensor_ranks_only=True)\n    else:\n      # For the rank-only cache key, replace any composite tensors with\n      # shape-relaxed TypeSpecs.\n      (cache_key_args, cache_key_kwargs) = nest.map_structure(\n          _shape_relaxed_type_for_composite_tensor, (args, kwargs))\n      rank_only_cache_key = self._cache_key(\n          cache_key_args,\n          cache_key_kwargs,\n          cache_key_context,\n          include_tensor_ranks_only=True)\n\n    arg_specs = [_type_spec_for(x) for x in flat_no_comp]\n    relaxed_arg_specs = self._function_cache.arg_relaxed_specs.get(\n        rank_only_cache_key, None)\n    relaxed_arg_function = self._function_cache.arg_relaxed.get(\n        rank_only_cache_key, None)\n\n    if (relaxed_arg_function is not None\n        and all(_is_type_subset(x, y) for (x, y) in\n                zip(relaxed_arg_specs, arg_specs))):\n      return relaxed_arg_function, filtered_flat_args\n\n    if relaxed_arg_specs is None:\n      relaxed_arg_specs = arg_specs\n    else:\n      if len(arg_specs) != len(relaxed_arg_specs):\n        raise RuntimeError(\"Expected arg_specs len to match relaxed_arg_specs \"\n                           f\"len: {len(arg_specs):d} vs. \"\n                           f\"{len(relaxed_arg_specs):d}.\")\n      relaxed_arg_specs = [\n          x if x is None else x.most_specific_compatible_type(y)\n          for (x, y) in zip(arg_specs, relaxed_arg_specs)]\n    self._function_cache.arg_relaxed_specs[rank_only_cache_key] = (\n        relaxed_arg_specs)\n    relaxed_arg_shapes = [\n        x if x is None else x.shape\n        for x in nest.flatten(relaxed_arg_specs, expand_composites=True)]\n\n    if any_composite_args:\n      # Rebuild composite tensors with the relaxed TypeSpecs.  For example,\n      # if a tf.data iterator is passed as an argument, then we need to relax\n      # the TensorShapes in its element_spec.\n      (relaxed_arg_specs, relaxed_kwarg_specs) = nest.pack_sequence_as(\n          (args, kwargs), relaxed_arg_specs, expand_composites=False)\n      (args, kwargs) = nest.pack_sequence_as(\n          (relaxed_arg_specs, relaxed_kwarg_specs),\n          flat_args,\n          expand_composites=True)\n\n    graph_function = self._create_graph_function(\n        args, kwargs, override_flat_arg_shapes=relaxed_arg_shapes)\n    self._function_cache.arg_relaxed[rank_only_cache_key] = graph_function\n\n    return (graph_function, [\n        t for t in nest.flatten((args, kwargs), expand_composites=True)\n        if isinstance(t, (ops.Tensor,\n                          resource_variable_ops.BaseResourceVariable))\n    ])\n\n  def _maybe_define_function(self, args, kwargs):\n    \"\"\"Gets a function for these inputs, defining it if necessary.\n\n    `args` and `kwargs` can be None if this `Function` was created with an\n    `input_signature`.\n\n    Caller must hold self._lock.\n\n    Args:\n      args: The varargs for the Python function.\n      kwargs: The keyword args for the Python function.\n\n    Returns:\n      A graph function corresponding to the input signature implied by args and\n      kwargs, as well as filtered flattened inputs (only Tensors and Variables)\n      that the object should be called with.\n\n    Raises:\n      ValueError: If inputs are incompatible with the input signature.\n      TypeError: If the function inputs include non-hashable objects\n      RuntimeError: If there's an internal bug (inconsistency) in handling\n        shape relaxation retracing.\n    \"\"\"\n    if self.input_signature is None or args is not None or kwargs is not None:\n      args, kwargs, flat_args, filtered_flat_args = \\\n          self._function_spec.canonicalize_function_inputs(*args, **kwargs)\n    else:\n      flat_args, filtered_flat_args = [None], []\n\n    cache_key_context = self._cache_key_context()\n    cache_key = self._cache_key(args, kwargs, cache_key_context)\n\n    try:\n      hash(cache_key)\n    except TypeError as e:\n      raise TypeError(\n          \"Arguments supplied to `defun`-generated functions must be \"\n          f\"hashable.  Original error: {e}.\")\n\n    graph_function = self._function_cache.primary.get(cache_key, None)\n    if graph_function is not None:\n      return graph_function, filtered_flat_args\n\n    with monitoring.MonitoredTimer(_graph_building_time_counter.get_cell()):\n      with trace.Trace(\"tf.function-graph_building\"):\n        logging.vlog(1,\n                     \"Creating new FuncGraph for Python function %r (key: %r)\",\n                     self._python_function, cache_key)\n        logging.vlog(2, \"Python function signature [args: %s] [kwargs: %s]\",\n                     args, kwargs)\n\n        # pylint: disable=protected-access\n        call_context_key = cache_key._replace(input_signature=None)\n        # pylint: disable=protected-access\n\n        ag_status = (\n            ag_ctx.Status.ENABLED\n            if self._autograph else ag_ctx.Status.DISABLED)\n        with ag_ctx.ControlStatusCtx(\n            status=ag_status, options=self._autograph_options):\n\n          # Build a function with shape relaxation retracing if:\n          # 1. shape relaxation is explicitly enabled\n          # and 2. there's no provided input signature\n          # and 3. there's been a cache miss for this calling context\n          if (self._experimental_relax_shapes and\n              self.input_signature is None and\n              call_context_key in self._function_cache.missed):\n            return self._define_function_with_shape_relaxation(\n                args, kwargs, flat_args, filtered_flat_args, cache_key_context)\n\n          self._function_cache.missed.add(call_context_key)\n          graph_function = self._create_graph_function(args, kwargs)\n          self._function_cache.primary[cache_key] = graph_function\n\n          return graph_function, filtered_flat_args\n\n\ndef register(func, *args, **kwargs):\n  \"\"\"Register a specialization of a `Function` into the graph.\n\n  This won't actually call the function with the inputs, and only put the\n  function definition into graph. Register function with different input param\n  will result into multiple version of functions registered in graph.\n\n  Args:\n    func: the `Function` instance that generated by a @defun\n    *args: input arguments for the Python function.\n    **kwargs: input keyword arguments for the Python function.\n\n  Returns:\n    a `ConcreteFunction` object specialized to inputs and execution context.\n\n  Raises:\n    ValueError: When the input function is not a defun wrapped python function.\n  \"\"\"\n  if not isinstance(func, Function):\n    raise ValueError(\"Only defun function is allowed to be registered. \"\n                     f\"Got {func} with type {type(func)}.\")\n  concrete_func = func.get_concrete_function(*args, **kwargs)\n  concrete_func.add_to_graph()\n  concrete_func.add_gradient_functions_to_graph()\n  return concrete_func\n\n\ndef validate_signature(signature):\n  if not isinstance(signature, (tuple, list)):\n    raise TypeError(\"input_signature must be either a tuple or a list, got \"\n                    f\"{type(signature)}.\")\n\n  if any(not isinstance(arg, tensor_spec.DenseSpec)\n         for arg in nest.flatten(signature, expand_composites=True)):\n    bad_args = [arg for arg in nest.flatten(signature, expand_composites=True)\n                if not isinstance(arg, tensor_spec.DenseSpec)]\n    raise TypeError(\"input_signature must be a possibly nested sequence of \"\n                    f\"TensorSpec objects, got invalid args {bad_args} with \"\n                    f\"types {list(map(type, bad_args))}.\")\n\n\ndef validate_python_function(python_function):\n  if not callable(python_function):\n    raise TypeError(f\"{python_function} is not a callable object.\")\n\n\ndef defun(func=None,\n          input_signature=None,\n          autograph=True,\n          experimental_autograph_options=None,\n          experimental_relax_shapes=False):\n  \"\"\"Compiles a Python function into a callable TensorFlow graph.\n\n  `defun` (short for \"define function\") compiles a Python function\n  composed of TensorFlow operations into a callable that executes a `tf.Graph`\n  containing those operations. The callable produced by `defun` contains only\n  the subgraph of TensorFlow operations that were executed when the Python\n  function was called with a particular input signature, defined as a list\n  of the shapes and dtypes of the Python function's Tensor-valued arguments and\n  the values of its non-Tensor Python objects.\n\n  When eager execution is enabled, the ability to create graphs from Python\n  functions makes it possible to incrementally trade off debuggability and\n  interactivity for performance.  Functions compiled with `defun` cannot be\n  inspected with `pdb`; however, executing a graph\n  generated by `defun` sometimes takes less time and memory than eagerly\n  executing the corresponding Python function, since specifying computations as\n  graphs allows for optimizations like automatic buffer reuse and\n  parallelization among ops. Note that executing a `defun`-compiled function\n  incurs a small constant overhead, so eagerly executing sufficiently small\n  Python functions might take less time than executing their corresponding\n  `defun`-generated graphs.\n\n  For a Python function to be compatible with `defun`, all of its arguments must\n  be hashable Python objects or lists thereof. The function itself may not\n  modify the list/map structure of its arguments. Additionally, it must return\n  zero or more `tf.Tensor` objects. If the Python function returns\n  a `tf.Variable`, its compiled version will return the value of that variable\n  as a `tf.Tensor`.\n\n  Executing a graph generated by `defun` respects device annotations (i.e.,\n  all `with tf.device` directives present in a Python function will also be\n  present in its corresponding graph), but it is not yet possible to execute the\n  generated graphs across multiple machines.\n\n  _Example Usage_\n\n  ```python\n  import tensorflow as tf\n\n  tf.compat.v1.enable_eager_execution()\n\n  # A simple example.\n  def f(x, y):\n    return tf.reduce_mean(tf.multiply(x ** 2, 3) + y)\n\n  g = tf.contrib.eager.defun(f)\n\n  x = tf.constant([[2.0, 3.0]])\n  y = tf.constant([[3.0, -2.0]])\n\n  # `f` and `g` will return the same value, but `g` will be executed as a\n  # TensorFlow graph.\n  assert f(x, y).numpy() == g(x, y).numpy()\n\n  # `defun` is capable of compiling Python functions that close over Python\n  # objects, including Tensors and Variables.\n  @tf.contrib.eager.defun\n  def h():\n    return f(x, y)\n\n  assert (h().numpy() == f(x, y).numpy()).all()\n\n  # `defun` automatically lifts variables out of the graphs it creates,\n  # allowing you to compile the `call` methods of `tf.keras.layers.Layer` and\n  # `tf.keras.Model` objects.\n  class MyModel(tf.keras.Model):\n\n    def __init__(self, keep_probability=0.2):\n      super(MyModel, self).__init__()\n      self.dense1 = tf.keras.layers.Dense(4, activation=tf.nn.relu)\n      self.dense2 = tf.keras.layers.Dense(5, activation=tf.nn.softmax)\n      self.keep_probability = keep_probability\n\n    @tf.contrib.eager.defun\n    def call(self, inputs, training=True):\n      x = self.dense2(self.dense1(inputs))\n      if training:\n        return tf.nn.dropout(x, self.keep_probability)\n      else:\n        return x\n\n  model = MyModel()\n  model(x, training=True)  # executes a graph, with dropout\n  model(x, training=False) # executes a graph, without dropout\n\n  # `defun`-compiled functions are differentiable.\n  optimizer = tf.compat.v1.train.GradientDescentOptimizer(learning_rate=0.01)\n  with tf.GradientTape() as tape:\n    outputs = model(x)\n  gradient = tape.gradient(outputs, model.trainable_variables)\n  optimizer.apply_gradients((grad, var) for grad, var in zip(gradient,\n                            model.trainable_variables))\n  ```\n\n  When using `defun`, there are subtleties regarding inputs, Python control\n  flow, and variable creation that one should be aware of. For concreteness, let\n  `f` be a Python function that returns zero or more `tf.Tensor` objects and\n  let `F = defun(f)`. `F` builds a graph for each unique input signature it\n  sees, Python control flow is baked into graphs, and operations related to\n  variable initialization are automatically lifted out of the graphs that `F`\n  generates and placed in the eager context if executing eagerly or into an\n  outer graph otherwise.\n\n  _Input Signatures_\n\n  By default, `F = tf.contrib.eager.defun(f)` instantiates a separate graph\n  for every unique sequence of the shapes and dtypes of Tensor arguments and\n  the values of Python objects it is invoked with. For example, calling\n  `F(tf.random.uniform([2])` will execute a different graph than\n  `F(tf.random.uniform([3])` because the two inputs have different shapes.\n  The first time that `F(*args, **kwargs)` is called with a particular sequence\n  of Tensor shapes and dtypes and Python values, it constructs a graph by\n  tracing the execution of `f(*args, **kwargs)`; this graph is bound to an\n  input signature inferred from `(*args, **kwargs)` and cached for future reuse.\n\n  NumPy arrays passed as inputs to `F` are converted to `tf.Tensor` objects\n  before being passed to `f`, and are treated as Tensors for caching. This\n  allows a function to be called multiple times with NumPy arrays having\n  different values but the same shape and dtype without re-tracing each time.\n\n  `tf.contrib.eager.defun` caches graphs for your convenience, letting you\n  define TensorFlow functions without explicitly specifying their signatures.\n  However, this policy is conservative and potentially expensive; for example,\n  when different invocations of your function have differently-shaped Tensor\n  inputs, this policy might generate more graph functions than necessary. To\n  eliminate such costs, `tf.contrib.eager.defun` allows you to supply an\n  optional `input_signature` argument specifying the shapes and dtypes of the\n  inputs. In particular, the shapes may be partially unspecified, with `None`s\n  in the unknown dimensions.  When an input signature is provided,\n  `tf.contrib.eager.defun` will only instantiate a single graph for the\n  decorated Python function. The following is an example:\n\n  ```python\n  import tensorflow as tf\n\n  # The first `TensorSpec` below describes the shape and dtype of `words`,\n  # and the second describes the shape and dtype of `another_tensor`. Note that\n  # the last dimension of the `words` `TensorSpec` is left unspecified.\n  @tf.contrib.eager.defun(input_signature=[\n    tf.contrib.eager.TensorSpec(shape=[50, 300, None], dtype=tf.float32),\n    tf.contrib.eager.TensorSpec(shape=[300, 100], dtype=tf.float32)\n  ])\n  def my_sequence_model(words, another_tensor):\n    ...\n\n  # Note how the third dimension of the first input can vary freely.\n  words = tf.random.uniform(([50, 300, 10])\n  second_input = tf.random.uniform([300, 100])\n  my_sequence_model(words, second_input)\n\n  words = tf.random.uniform(([50, 300, 20])\n  my_sequence_model(words, second_input)\n\n  # Passing an input with an incompatible shape will raise an error.\n  words = tf.random.uniform(([50, 100, 20])\n  my_sequence_model(words, second_input)  # <---- This will raise an error.\n\n  ```\n\n  Python functions that are compiled with an `input_signature` must only accept\n  Tensors as arguments and must not take unnamed keyword arguments (**kwargs).\n\n  _Tracing_\n\n  Be aware that because `F` only logs TensorFlow operations, all the other\n  Python code that `f` executes will only shape the _construction_ of the graphs\n  that `F` executes: the Python code won't be executed when the graphs\n  themselves are executed, though it will be executed every time the Python\n  function is traced (and a given Python function might be traced multiple\n  times, once for each input signature it is invoked with). For example, whereas\n  the Python function\n\n  ```python\n  import tensorflow as tf\n  import numpy as np\n\n  tf.compat.v1.enable_eager_execution()\n\n  def add_noise():\n    return tf.eye(5) + np.random.randn(5, 5)\n  ```\n\n  will return a different output everytime it is invoked, the compiled function\n  `compiled = tf.contrib.eager.defun(add_noise)` will return the same value\n  every time it is called, since a particular random offset generated by NumPy\n  will be inserted into the graph as a TensorFlow constant. The solution is to\n  replace the call to `np.random.randn` with `tf.random.normal((5, 5))`.\n\n  _Python Side-Effects_\n\n  A corollary of the previous discussion on tracing is the following: If a\n  Python function `f` has Python side-effects, then executing `f` multiple times\n  will not necessarily be semantically equivalent to executing `F =\n  tf.contrib.eager.defun(f)` multiple times; this difference is due to the fact\n  that `defun` only captures the subgraph of TensorFlow operations that is\n  constructed when `f` is called in a graph-building context.\n\n  _Python Control Flow_\n\n  The structure of many machine learning computations depend upon whether one is\n  training or validating, and it is common to nest specialized logic under `if\n  training:` blocks. By mapping each input signature to a unique graph, `defun`\n  lets users transparently compile such code, as the following code snippet\n  demonstrates:\n\n  ```python\n  import tensorflow as tf\n\n  tf.compat.v1.enable_eager_execution()\n\n  @tf.contrib.eager.defun\n  def lossy_matmul(W, x, training=True):\n    outputs = tf.matmul(W, x)\n    if training:\n      outputs = tf.nn.dropout(outputs, keep_probability=0.2)\n    return outputs\n\n  W = tf.random.normal((3, 5))\n  x = tf.random.normal((5, 1))\n\n  # Executes a graph that applies dropout.\n  lossy_outputs = lossy_matmul(W, x, training=True)\n\n  # Executes a graph that does not apply dropout.\n  exact_outputs = lossy_matmul(W, x, training=False)\n  ```\n\n  _TensorFlow Control Flow_\n\n  When `autograph` is `True`, data-dependent control flow is allowed as well.\n  Control flow statements that depend on `Tensor` values are staged into\n  corresponding TensorFlow ops. For example, the following code will work as\n  expected:\n\n  ```python\n  @tf.contrib.eager.defun\n  def dynamic_rnn_loop(cell, seq):\n    state, output = cell.zero_state()\n    for input in seq:\n      state, output = cell(input, state)\n    return output\n  ```\n\n  For more information see `tf.autograph`.\n\n  _Variables_\n\n  TensorFlow operations related to variable creation and initialization are\n  automatically lifted out of the graphs generated by `defun`. In practice, this\n  implies that variable creation and initialization only happen the first time\n  `F` is called, and that variables are reused every time thereafter. Many\n  TensorFlow APIs, like `tf.keras.layers.Layer` objects, create variables the\n  first time they are called and reuse them thereafter. Automatic variable\n  lifting makes it possible to compile these APIs without extra effort, at the\n  cost of introducing a discrepancy between the semantics of executing Python\n  functions and their corresponding compiled functions. For example:\n\n  ```python\n  import tensorflow as tf\n\n  tf.compat.v1.enable_eager_execution()\n\n  def fn():\n    x = tf.Variable(0.0)\n    x.assign_add(1.0)\n    return x.read_value()\n\n  # `fn` is a Python function, so x is created, initialized, and destroyed upon\n  # every invocation\n  assert fn().numpy() == fn().numpy() == 1.0\n\n  compiled = tf.contrib.eager.defun(fn)\n\n  # Compiling `fn` with `defun` hoists all variables outside of the generated\n  # graph, so initialization happens exactly once.\n  assert compiled().numpy() == 1.0\n  assert compiled().numpy() == 2.0\n  ```\n\n  Finally, because each input signature is bound to a unique graph, if your\n  Python function constructs `tf.Variable` objects, then each graph constructed\n  for that Python function will reference a unique set of variables. To\n  circumvent this problem, we recommend against compiling Python functions that\n  create `tf.Variable` objects. Instead, Python functions should either\n  lexically close over `tf.Variable` objects or accept them as arguments,\n  preferably encapsulated in an object-oriented container. If you must create\n  variables inside your Python function and you want each graph generated for it\n  to reference the same set of variables, add logic to your Python function that\n  ensures that variables are only created the first time it is called and are\n  reused for every subsequent invocation; note that this is precisely what\n  `tf.keras.layers.Layer` objects do, so we recommend using them to represent\n  variable-bearing computations whenever possible.\n\n  Args:\n    func: function to be compiled. If `func` is None, returns a\n      decorator that can be invoked with a single argument - `func`. The\n      end result is equivalent to providing all the arguments up front.\n      In other words, defun(input_signature=...)(func) is equivalent to\n      defun(func, input_signature=...). The former allows\n      the following use case:\n        @tf.contrib.eager.defun(input_signature=...)\n        def foo(...):\n          ...\n\n    input_signature: A possibly nested sequence of\n      `tf.contrib.eager.TensorSpec` objects specifying the shapes and dtypes of\n      the Tensors that will be supplied to this function. If `None`, a separate\n      function is instantiated for each inferred input signature.  If a\n      signature is specified, every input to `func` must be a `Tensor`, and\n      `func` cannot accept `**kwargs`.\n    autograph: Whether `func` should be compiled before\n      constructing the graph. See https://www.tensorflow.org/guide/autograph\n      for more information.\n    experimental_autograph_options: Experimental knobs (in the form of a tuple\n      of tensorflow.autograph.Feature values) to control behavior when\n      autograph=True.\n    experimental_relax_shapes: When true, argument shapes may be relaxed to\n      avoid unnecessary retracing.\n\n  Returns:\n     If `func` is not None, returns a callable that will execute the compiled\n     function (and return zero or more `tf.Tensor` objects).\n     If `func` is None, returns a decorator that, when invoked with a single\n     `func` argument, returns a callable equivalent to the case above.\n\n  Raises:\n    TypeError: If `input_signature` is neither `None` nor a sequence of\n      `tf.contrib.eager.TensorSpec` objects.\n  \"\"\"\n  return defun_with_attributes(\n      func=func,\n      input_signature=input_signature,\n      autograph=autograph,\n      experimental_autograph_options=experimental_autograph_options,\n      experimental_relax_shapes=experimental_relax_shapes)\n\n\n@tf_export(\"__internal__.function.defun_with_attributes\", v1=[])\ndef defun_with_attributes(func=None,\n                          input_signature=None,\n                          attributes=None,\n                          autograph=True,\n                          experimental_autograph_options=None,\n                          jit_compile=None,\n                          experimental_relax_shapes=False,\n                          experimental_follow_type_hints=False):\n  \"\"\"Compiles a Python function into a callable TensorFlow graph.\n\n  This function supports adding extra function attributes. See detailed\n  documentation in defun(). Currently this is not exposed in public API since we\n  don't expect user to directly use attributes, and attribute won't work by\n  itself. This assumption might change in future.\n\n  Args:\n    func: function to be compiled.\n    input_signature: same as defun()'s input_signature.\n    attributes: A dictionary of arguments which will be added to function def as\n      attributes. Currently only support primitive types as value, and only\n      allowlisted attribute name is allowed. Unallowlisted attribute name or\n      unsupported value will result into ValueError. `func_name` is also one of\n      the allowlisted argument which is a python string, and sets the name for\n      this `ConcreteFunction` in the graph.\n    autograph: same as defun()'s autograph.\n    experimental_autograph_options: same as defun()'s\n      experimental_autograph_options.\n    jit_compile: same as defun()'s jit_compile.\n    experimental_relax_shapes: same as defun()'s experimental_relax_shapes\n    experimental_follow_type_hints: see `tf.function`.\n\n  Returns:\n    Same as the return value of defun, with attributes added to the function in\n    graph.\n  \"\"\"\n  if input_signature is not None:\n    validate_signature(input_signature)\n\n  # TODO(apassos): deal with captured global state. Deal with control flow.\n  def decorated(function):\n    try:\n      if attributes:\n        name = attributes.pop(\"func_name\", function.__name__)\n      else:\n        name = function.__name__\n    except AttributeError:\n      name = \"function\"\n    return tf_decorator.make_decorator(\n        function,\n        Function(\n            function,\n            name,\n            input_signature=input_signature,\n            attributes=attributes,\n            autograph=autograph,\n            autograph_options=experimental_autograph_options,\n            jit_compile=jit_compile,\n            experimental_relax_shapes=experimental_relax_shapes,\n            experimental_follow_type_hints=experimental_follow_type_hints))\n\n  # This code path is for the `foo = tfe.defun(foo, ...)` use case\n  if func is not None:\n    return decorated(func)\n\n  # This code path is for the\n  #\n  # @tfe.defun(...)\n  # def foo(...):\n  #    ...\n  #\n  # use case, which is equivalent to `foo = tfe.defun(...)(foo)`\n  return decorated\n\n\n# When a method is bound to objects of this type, it allows AutoGraph to\n# recover a weak reference the original method's self pointer, so that it can\n# execute it consistent with class_method_to_instance_method's\n# bound_method_wrapper.\n# TODO(b/119246461): This is not pretty. Use a descriptor instead?\nclass TfMethodTarget(object):\n  \"\"\"Binding target for methods replaced by function and defun.\"\"\"\n\n  __slots__ = (\"weakrefself_target__\", \"weakrefself_func__\")\n\n  def __init__(self, target, original_python_function):\n    self.weakrefself_target__ = target\n    self.weakrefself_func__ = weakref.ref(original_python_function)\n\n  @property\n  def target(self):\n    return self.weakrefself_target__()\n\n  @property\n  def target_class(self):\n    true_self = self.weakrefself_target__()\n    if tf_inspect.isclass(true_self):\n      # Class method\n      return true_self\n    else:\n      return true_self.__class__\n\n  def call(self, args, kwargs):\n    wrapped_fn = self.weakrefself_func__()\n    if tf_inspect.ismethod(wrapped_fn):\n      wrapped_fn = six.get_unbound_function(wrapped_fn)\n    return wrapped_fn(self.weakrefself_target__(), *args, **kwargs)\n\n\ndef class_method_to_instance_method(original_function, instance):\n  \"\"\"Constructs a new `Function` with `self` bound.\"\"\"\n  weak_instance = weakref.ref(instance)\n\n  # Note: while we could bind to a weakref proxy instead, that causes the\n  # bound method to be unhashable.\n  bound_method = types_lib.MethodType(\n      original_function.python_function,\n      TfMethodTarget(weak_instance, original_function.python_function))\n\n  # original_function is expected to be of one of the two `Function` types\n  # (defined either in function.py or def_function.py).\n  assert hasattr(original_function, \"_name\")\n  assert hasattr(original_function, \"_autograph\")\n  assert hasattr(original_function, \"_function_spec\")\n  assert hasattr(original_function, \"python_function\")\n\n  weak_bound_method_wrapper = None\n  def bound_method_wrapper(*args, **kwargs):\n    \"\"\"Wraps either a dummy MethodType or a converted AutoGraph function.\"\"\"\n    # __wrapped__ allows AutoGraph to swap in a converted function.\n    strong_bound_method_wrapper = weak_bound_method_wrapper()\n    wrapped_fn = strong_bound_method_wrapper.__wrapped__\n\n    if wrapped_fn is strong_bound_method_wrapper.__original_wrapped__:\n      # If __wrapped__ was not replaced, then call original_function.\n      # TODO(mdan): For better consistency, use the wrapper's call().\n      wrapped_fn = original_function.python_function\n      if tf_inspect.ismethod(wrapped_fn):\n        wrapped_fn = six.get_unbound_function(wrapped_fn)\n      return wrapped_fn(weak_instance(), *args, **kwargs)\n\n    # If __wrapped__ was replaced, then it is always an unbound function.\n    # However, the replacer is still responsible for attaching self properly.\n    # TODO(mdan): Is it possible to do it here instead?\n    return wrapped_fn(*args, **kwargs)\n  weak_bound_method_wrapper = weakref.ref(bound_method_wrapper)\n\n  # pylint: disable=protected-access\n  # We make a dummy MethodType object to generate the correct bound method\n  # signature. The actual call is to a function with a weak reference to\n  # `instance`.\n  instance_func = type(original_function)(\n      tf_decorator.make_decorator(bound_method, bound_method_wrapper),\n      name=original_function._name,\n      autograph=original_function._autograph,\n      input_signature=original_function.input_signature,\n      experimental_relax_shapes=original_function._experimental_relax_shapes,\n      jit_compile=original_function._jit_compile)\n  # pylint: enable=protected-access\n\n  # We wrap the the bound method with tf_decorator so inspection works correctly\n  wrapped_instance_func = tf_decorator.make_decorator(bound_method,\n                                                      instance_func)\n  return wrapped_instance_func\n\n\nclass _FunctionGarbageCollector(object):\n  \"\"\"Cleans up cycles when a defun goes out of scope.\"\"\"\n\n  __slots__ = [\"_cache\"]\n\n  def __init__(self, cache):\n    self._cache = cache\n\n  def __del__(self):\n    if func_graph_module is None or memory is None:\n      return\n    try:\n      while self._cache:\n        self._cache.popitem()\n      memory.dismantle_ordered_dict(self._cache)\n    except:  # pylint: disable=bare-except\n      pass\n\n\nclass ConcreteFunctionGarbageCollector(object):\n  \"\"\"Cleans up reference cycles when a `ConcreteFunction` goes out of scope.\"\"\"\n\n  __slots__ = [\"_func_graph\"]\n\n  def __init__(self, func_graph):\n    self._func_graph = func_graph\n\n  def release(self):\n    \"\"\"Call off the FuncGraph deletion.\"\"\"\n    self._func_graph = None\n\n  def __del__(self):\n    if func_graph_module is None or memory is None or self._func_graph is None:\n      return\n    try:\n      func_graph_module.dismantle_func_graph(self._func_graph)\n    except:  # pylint: disable=bare-except\n      pass\n\n\nclass _Marker(object):\n  \"\"\"Markers used to pretty-print nested args in function signatures.\"\"\"\n\n  __slots__ = [\"_s\"]\n\n  def __init__(self, s):\n    self._s = s\n\n  def __repr__(self):\n    return str(self._s)\n\n\ndef _structure_summary(structure):\n  \"\"\"Displays a summary of the nesting structure of the given value.\"\"\"\n\n  def type_name(x):\n    if isinstance(x, type_spec.TypeSpec):\n      return x.value_type.__name__\n    else:\n      return type(x).__name__\n\n  markers = [_Marker(type_name(v)) for v in nest.flatten(structure)]\n  return str(nest.pack_sequence_as(structure, markers))\n\n\ndef _contains_type_spec(value):\n  return any(isinstance(x, type_spec.TypeSpec) for x in nest.flatten(value))\n"], "fixing_code": ["# Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n# pylint: disable=unidiomatic-typecheck\n\"\"\"API for defining graph functions with some additional eager semantics.\n\ndef_function.function wraps the function concept in function.py (\"defun\") to\nallow initializing `tf.Variable`s with subgraphs of the function. For example:\n\n```python\nclass M(tf.Module):\n  def __init__(self):\n    self.v_opinit = None\n    self.v_arginit = None\n\n  @tf.function\n  def __call__(self, x):\n    # Variables are only created on the first call to the function. This is a\n    # common pattern in layer libraries.\n    if self.v_opinit is None:\n      # self.v_opinit will outlive the function call, but `tf.ones` is traced as\n      # part of the function body before the `tf.Variable` object is\n      # created. This subgraph is easy to lift out of the function.\n      self.v_opinit = tf.Variable(tf.ones([]))\n\n      # If arguments feed into variable initialization, it can be very tricky to\n      # disentangle from the rest of the function. We don't attempt it.\n      self.v_arginit = tf.Variable(tf.ones(tf.shape(x)) * tf.constant(2.))\n    return self.v_opinit + self.v_arginit + x\n```\n\nThese patterns with \"defun\" throw an error asking the user to put the variable's\ninitializer in a lambda. With tf.function they work with eager semantics either\nby lifting the subgraph out of the function and using it to initialize the\nvariable, or by initializing variables on the first call to the function (if\nthey weren't already initialized by something else, e.g. a checkpoint API). The\nlatter requires tf.conds, and is not well supported by TF-XLA, so we only do it\nwhen necessary.\n\nSince these patterns are relatively common in layer libraries, we expose the\nwrapper in this file as `tf.function`. The function concept in function.py is an\ninternal implementation detail.\n\nIn order to support these variable initialization patterns, tf.function defines\na variable subtype (UnliftedInitializerVariable) which collects the input\nsubgraph. This type of variable replaces the regular variable type on the first\ntf.function trace. To exclude initializers from the function body (the `tf.ones`\nops above and associated assignment operations), tf.function traces a second\ntime if it sees variables on the first call.\n\"\"\"\n\nimport functools\nimport threading\nimport types as types_lib\nimport weakref\nimport six\n\nfrom google.protobuf import text_format as _text_format\nfrom google.protobuf.message import DecodeError\nfrom tensorflow.core.framework import attr_value_pb2\nfrom tensorflow.python.distribute.parallel_device import parallel_device\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.eager import function as function_lib\nfrom tensorflow.python.eager import lift_to_graph\nfrom tensorflow.python.eager import monitoring\nfrom tensorflow.python.framework import composite_tensor\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import func_graph as func_graph_module\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import control_flow_ops\nfrom tensorflow.python.ops import control_flow_util\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import random_ops\nfrom tensorflow.python.ops import resource_variable_ops\nfrom tensorflow.python.platform import tf_logging as logging\nfrom tensorflow.python.profiler import trace\nfrom tensorflow.python.training.tracking import base as trackable\nfrom tensorflow.python.types import core\nfrom tensorflow.python.util import deprecation\nfrom tensorflow.python.util import nest\nfrom tensorflow.python.util import object_identity\nfrom tensorflow.python.util import tf_decorator\nfrom tensorflow.python.util import traceback_utils\nfrom tensorflow.python.util.tf_export import tf_export\n\nFREQUENT_TRACING_WARNING_MAX_CALL_HISTORY = 10\nFREQUENT_TRACING_WARNING_THRESHOLD = 5\nFREQUENT_TRACING_WARNING_MAX_WARNING_PER_DETECTOR = 2\nALLOW_DYNAMIC_VARIABLE_CREATION = False\n\n_tf_function_counter = monitoring.Counter(\n    \"/tensorflow/core/tf_function_counter\",\n    \"Counter for the number of tf.functions created when Eager execution is \"\n    \"enabled.\",\n    # jit_compile is \"0\" or \"1\".\n    \"jit_compile\")\n\n\nclass _FrequentTracingDetector(object):\n  \"\"\"Class keeping track of how many recent calls triggered tracing.\"\"\"\n\n  __slots__ = [\"_calls_per_tracings\", \"_call_count\", \"_total_warning_count\"]\n\n  def __init__(self):\n    self._calls_per_tracings = []\n    self._total_warning_count = 0\n    self._call_count = 0\n\n  def called_with_tracing(self, function_name, omit_warning):\n    \"\"\"Updates the list of most recent calls' tracing information.\n\n    Warns the user when recent calls caused retracing too often.\n\n    Args:\n      function_name: the python function being traced.\n      omit_warning: If 'True', this call will not warn the user even if\n        retracing happens too often.\n    \"\"\"\n    self._call_count += 1\n    self._calls_per_tracings.append(1)\n\n    while self._calls_per_tracings:\n      if (self._call_count - self._calls_per_tracings[0] >\n          FREQUENT_TRACING_WARNING_MAX_CALL_HISTORY):\n        self._call_count -= self._calls_per_tracings.pop(0)\n      else:\n        break\n\n    if (omit_warning or self._total_warning_count >=\n        FREQUENT_TRACING_WARNING_MAX_WARNING_PER_DETECTOR):\n      return\n    if len(self._calls_per_tracings) >= FREQUENT_TRACING_WARNING_THRESHOLD:\n      self._total_warning_count += 1\n      logging.warning(\n          \"{} out of the last {} calls to {} triggered tf.function \"\n          \"retracing. Tracing is expensive and the excessive number of \"\n          \"tracings could be due to (1) creating @tf.function repeatedly in \"\n          \"a loop, (2) passing tensors with different shapes, (3) passing \"\n          \"Python objects instead of tensors. For (1), please define your \"\n          \"@tf.function outside of the loop. For (2), @tf.function has \"\n          \"experimental_relax_shapes=True option that relaxes argument \"\n          \"shapes that can avoid unnecessary retracing. For (3), please \"\n          \"refer to \"\n          \"https://www.tensorflow.org/guide/function#controlling_retracing\"\n          \" and https://www.tensorflow.org/api_docs/python/tf/function for \"\n          \" more details.\".format(\n              len(self._calls_per_tracings), self._call_count, function_name))\n\n  def called_without_tracing(self):\n    # We don't count tracing when users load a concrete function directly or\n    # call get_concrete_function, so the first call can be not a tracing call.\n    if not self._calls_per_tracings:\n      self._calls_per_tracings = [0]\n    self._calls_per_tracings[-1] += 1\n    self._call_count += 1\n\n\nclass _FrequentTracingDetectorManager(object):\n  \"\"\"Class for the management of all _FrequentTracingDetector objects.\"\"\"\n\n  __slots__ = [\"_detectors\", \"_lock\"]\n\n  def __init__(self):\n    self._detectors = weakref.WeakKeyDictionary()  # GUARDED_BY(self._lock)\n    self._lock = threading.Lock()\n\n  def _get_detector(self, key):\n    if key not in self._detectors:\n      self._detectors[key] = _FrequentTracingDetector()\n    return self._detectors[key]\n\n  def called_without_tracing(self, key):\n    with self._lock:\n      detector = self._get_detector(key)\n      detector.called_without_tracing()\n\n  def called_with_tracing(self, key, function_name, omit_warning):\n    with self._lock:\n      detector = self._get_detector(key)\n      detector.called_with_tracing(function_name, omit_warning)\n\n\n_frequent_tracing_detector_manager = _FrequentTracingDetectorManager()\n\n\nclass UnliftedInitializerVariable(resource_variable_ops.UninitializedVariable):\n  \"\"\"Variable which does not lift its initializer out of function context.\n\n  Instances of this variable, when created, build a graph which runs their\n  initializer inside a tf.cond(is_initialized) block.\n\n  This can only be created inside a defun called from (eventually) eager\n  mode. That is, non-function-building graphs are not supported.\n  \"\"\"\n\n  def __init__(self,\n               initial_value=None,\n               trainable=None,\n               caching_device=None,\n               name=None,\n               dtype=None,\n               constraint=None,\n               add_initializers_to=None,\n               lifted_initializer_graph=None,\n               synchronization=None,\n               aggregation=None,\n               shape=None,\n               **unused_kwargs):\n    \"\"\"Creates a variable.\n\n    Args:\n      initial_value: A `Tensor`, or Python object convertible to a `Tensor`,\n        which is the initial value for the Variable. The initial value must have\n        a shape specified unless `validate_shape` is set to False. Can also be a\n        callable with no argument that returns the initial value when called.\n        (Note that initializer functions from init_ops.py must first be bound\n         to a shape before being used here.)\n      trainable: If `True`, GradientTapes automatically watch uses of this\n        Variable.\n      caching_device: Optional device string or function describing where the\n        Variable should be cached for reading.  Defaults to the Variable's\n        device.  If not `None`, caches on another device.  Typical use is to\n        cache on the device where the Ops using the Variable reside, to\n        deduplicate copying through `Switch` and other conditional statements.\n      name: Optional name for the variable. Defaults to `'Variable'` and gets\n        uniquified automatically.\n      dtype: If set, initial_value will be converted to the given type.\n        If None, either the datatype will be kept (if initial_value is\n       a Tensor) or float32 will be used (if it is a Python object convertible\n       to a Tensor).\n      constraint: An optional projection function to be applied to the variable\n        after being updated by an `Optimizer` (e.g. used to implement norm\n        constraints or value constraints for layer weights). The function must\n        take as input the unprojected Tensor representing the value of the\n        variable and return the Tensor for the projected value\n        (which must have the same shape). Constraints are not safe to\n        use when doing asynchronous distributed training.\n      add_initializers_to: if not None and not in legacy graph mode, the\n        initializer tensor will be added to this map in addition to adding the\n        assignment to the function.\n      lifted_initializer_graph: FuncGraph to try to lift initializers to.\n      synchronization: Indicates when a distributed a variable will be\n        aggregated. Accepted values are constants defined in the class\n        `tf.VariableSynchronization`. By default the synchronization is set to\n        `AUTO` and the current `DistributionStrategy` chooses\n        when to synchronize.\n      aggregation: Indicates how a distributed variable will be aggregated.\n        Accepted values are constants defined in the class\n        `tf.VariableAggregation`.\n      shape: (optional) The shape of this variable. If None, the shape of\n        `initial_value` will be used. When setting this argument to\n        `tf.TensorShape(None)` (representing an unspecified shape), the variable\n        can be assigned with values of different shapes.\n\n    Raises:\n      ValueError: If the initial value is not specified, or does not have a\n        shape and `validate_shape` is `True`.\n      RuntimeError: If called outside of a function definition.\n    \"\"\"\n    with ops.init_scope():\n      self._in_graph_mode = not context.executing_eagerly()\n    if not ops.inside_function():\n      # If we've been init_scope()d out of the function definition nothing to do\n      # here; we can't really do the capturing or conditional logic.\n      resource_variable_ops.ResourceVariable.__init__(\n          self, initial_value=initial_value, trainable=trainable,\n          caching_device=caching_device, name=name, dtype=dtype,\n          constraint=constraint)\n      return\n    if initial_value is None:\n      raise ValueError(\"`initial_value` must be a Tensor or a Python \"\n                       \"object convertible to a Tensor. Got None.\")\n    init_from_fn = callable(initial_value)\n\n    if constraint is not None and not callable(constraint):\n      raise ValueError(f\"`constraint` with type {type(constraint)} must be a \"\n                       \"callable.\")\n\n    with ops.name_scope(name, \"Variable\", []\n                        if init_from_fn else [initial_value]) as scope_name:\n      with ops.name_scope(\"Initializer\"):\n        if init_from_fn:\n          initial_value = initial_value()\n        if isinstance(initial_value, trackable.CheckpointInitialValue):\n          self._maybe_initialize_trackable()\n          self._update_uid = initial_value.checkpoint_position.restore_uid\n          initial_value = initial_value.wrapped_value\n\n        initial_value = ops.convert_to_tensor(initial_value,\n                                              name=\"initial_value\", dtype=dtype)\n      assert initial_value is not None\n\n      # Don't use `shape or initial_value.shape` since TensorShape has\n      # overridden `__bool__`.\n      if shape is None:\n        shape = initial_value.shape\n\n    # Use the constructor for UninitializedVariable to start. Outside the name\n    # scope so we don't double up the prefix.\n    super(UnliftedInitializerVariable, self).__init__(\n        trainable=trainable,\n        caching_device=caching_device,\n        name=name,\n        shape=shape,\n        dtype=initial_value.dtype,\n        constraint=constraint,\n        synchronization=synchronization,\n        aggregation=aggregation,\n        extra_handle_data=initial_value,\n        **unused_kwargs)\n\n    with ops.name_scope(scope_name):\n      if self._in_graph_mode:\n        with ops.init_scope():\n          outer_graph = ops.get_default_graph()\n        func_graph = ops.get_default_graph()\n        function_placeholders = (\n            func_graph.inputs + func_graph.internal_captures)\n        placeholder_ops = set(\n            [tensor.op for tensor in function_placeholders])\n        lifted_initializer = lift_to_graph.lift_to_graph(\n            [initial_value], outer_graph,\n            disallowed_placeholders=placeholder_ops)[initial_value]\n        with ops.init_scope():\n          self._initial_value = lifted_initializer\n          with ops.name_scope(\"IsInitialized\"):\n            self._is_initialized_op = (\n                resource_variable_ops.var_is_initialized_op(self._handle))\n          if initial_value is not None:\n            with ops.name_scope(\"Assign\") as n, ops.colocate_with(self._handle):\n              self._initializer_op = resource_variable_ops.assign_variable_op(\n                  self._handle, lifted_initializer, name=n)\n      elif context.executing_eagerly():\n        # In this case, both current scope and init scope are eager.\n        # Assign_variable_op will be executed immediately. So we don't need to\n        # add it to \"add_initializers_to\" to lift it out.\n        with ops.name_scope(\"Assign\") as n, ops.colocate_with(self._handle):\n          resource_variable_ops.assign_variable_op(\n              self._handle, initial_value, name=n)\n      else:\n        # Init scope is eager but current scope is graph. We will lift out this\n        # variable by addint it into \"add_initializers_to\".\n        if add_initializers_to is not None:\n          add_initializers_to.append((self, initial_value))\n\n        def assign_fn():\n          with ops.name_scope(\"Assign\") as n, ops.colocate_with(self._handle):\n            resource_variable_ops.assign_variable_op(\n                self._handle,\n                initial_value,\n                name=n)\n            # Returning values to keep tf.cond happy.\n          return ops.convert_to_tensor(1)\n        def not_assign_fn():\n          return ops.convert_to_tensor(0)\n        # Note: this cond is always guaranteed to run because we're inside a\n        # defun which will insert automatic control dependencies. It will only\n        # execute assign_fn if lifting failed.\n        graph = ops.get_default_graph()\n\n        # Capture the handle ahead of time in order to avoid querying the shape\n        # of the handle which helps async execution performance\n        graph.capture(self._handle, shape=())\n        control_flow_ops.cond(\n            resource_variable_ops.var_is_initialized_op(self._handle),\n            not_assign_fn, assign_fn)\n\n\nRUN_FUNCTIONS_EAGERLY = False\n\n\n@deprecation.deprecated(\n    None,\n    \"Use `tf.config.run_functions_eagerly` instead of the experimental \"\n    \"version.\")\n@tf_export(\"config.experimental_run_functions_eagerly\")\ndef experimental_run_functions_eagerly(run_eagerly):\n  \"\"\"Enables / disables eager execution of `tf.function`s.\n\n  Calling `tf.config.experimental_run_functions_eagerly(True)` will make all\n  invocations of `tf.function` run eagerly instead of running as a traced graph\n  function.\n\n  See `tf.config.run_functions_eagerly` for an example.\n\n  Note: This flag has no effect on functions passed into tf.data transformations\n  as arguments. tf.data functions are never executed eagerly and are always\n  executed as a compiled Tensorflow Graph.\n\n  Args:\n    run_eagerly: Boolean. Whether to run functions eagerly.\n  \"\"\"\n  return run_functions_eagerly(run_eagerly)\n\n\n@tf_export(\"config.run_functions_eagerly\")\ndef run_functions_eagerly(run_eagerly):\n  \"\"\"Enables / disables eager execution of `tf.function`s.\n\n  Calling `tf.config.run_functions_eagerly(True)` will make all\n  invocations of `tf.function` run eagerly instead of running as a traced graph\n  function.\n\n  This can be useful for debugging.\n\n  >>> def my_func(a):\n  ...  print(\"Python side effect\")\n  ...  return a + a\n  >>> a_fn = tf.function(my_func)\n\n  >>> # A side effect the first time the function is traced\n  >>> a_fn(tf.constant(1))\n  Python side effect\n  <tf.Tensor: shape=(), dtype=int32, numpy=2>\n\n  >>> # No further side effect, as the traced function is called\n  >>> a_fn(tf.constant(2))\n  <tf.Tensor: shape=(), dtype=int32, numpy=4>\n\n  >>> # Now, switch to eager running\n  >>> tf.config.run_functions_eagerly(True)\n  >>> # Side effect, as the function is called directly\n  >>> a_fn(tf.constant(2))\n  Python side effect\n  <tf.Tensor: shape=(), dtype=int32, numpy=4>\n\n  >>> # Turn this back off\n  >>> tf.config.run_functions_eagerly(False)\n\n  Note: This flag has no effect on functions passed into tf.data transformations\n  as arguments. tf.data functions are never executed eagerly and are always\n  executed as a compiled Tensorflow Graph.\n\n  Args:\n    run_eagerly: Boolean. Whether to run functions eagerly.\n  \"\"\"\n  global RUN_FUNCTIONS_EAGERLY\n  RUN_FUNCTIONS_EAGERLY = bool(run_eagerly)\n\n\n@deprecation.deprecated(\n    None,\n    \"Use tf.config.functions_run_eagerly instead of the experimental version.\")\n@tf_export(\"config.experimental_functions_run_eagerly\")\ndef experimental_functions_run_eagerly():\n  \"\"\"Returns the value of the `experimental_run_functions_eagerly` setting.\"\"\"\n  return functions_run_eagerly()\n\n\n@tf_export(\"config.functions_run_eagerly\")\ndef functions_run_eagerly():\n  \"\"\"Returns the value of the `run_functions_eagerly` setting.\"\"\"\n  return RUN_FUNCTIONS_EAGERLY\n\n\ndef _evaluate_var_is_initialized(variables):\n  \"\"\"Compute booleans indicating whether each variable is initialized.\"\"\"\n  with ops.init_scope():\n    var_is_initialized = []\n    for v in variables:\n      var_is_initialized.append(\n          resource_variable_ops.var_is_initialized_op(v.handle))\n    try:\n      # Stack all the var_is_initialized values into one tensor and interpret\n      # the numpy value. This will reduce the number of RPCs between client and\n      # worker in the remote case.\n      return array_ops.stack(var_is_initialized).numpy()\n    except errors.UnimplementedError:\n      # Some devices do not support implicit copy-off to host. Fall back to\n      # variable-by-variable processing.\n      for index, v in enumerate(variables):\n        try:\n          numpy_value = var_is_initialized[index].numpy()\n        except errors.UnimplementedError:\n          # This is a variable on a parallel device; we'll extract its value on\n          # each replica and assert that they're identical.\n          components = parallel_device.unpack(var_is_initialized[index])\n          with ops.device(None):\n            components = array_ops.stack(components)\n            all_initialized = math_ops.reduce_all(components).numpy()\n            any_initialized = math_ops.reduce_any(components).numpy()\n          if all_initialized != any_initialized:\n            raise NotImplementedError(\n                f\"Some but not all components of a parallel variable {v!r} \"\n                \"were initialized between their creation in a tf.function and \"\n                \"the function's trace having completed. This is not \"\n                \"supported; consider initializing either all or none of the \"\n                \"components, or moving initialization out of the function.\")\n          numpy_value = all_initialized\n        var_is_initialized[index] = numpy_value\n  return var_is_initialized\n\n\nclass FunctionDeleter(object):\n\n  __slots__ = [\"func_graph\"]\n\n  def __init__(self, func_graph):\n    self.func_graph = func_graph\n\n  def __del__(self):\n    try:\n      func_graph_module.dismantle_func_graph(self.func_graph)\n    except:  # pylint: disable=bare-except\n      # Note: bare except here because this can be noisy at shutdown time.\n      pass\n\n\nclass OptionalXlaContext(object):\n  \"\"\"Wrapper for XLA context optionally applied under a context manager.\"\"\"\n\n  def __init__(self, is_compiled):\n    wrap = is_compiled and not control_flow_util.GraphOrParentsInXlaContext( \\\n              ops.get_default_graph())\n    self.xla_context = control_flow_ops.XLAControlFlowContext() \\\n        if wrap else None\n\n  def __enter__(self):\n    if self.xla_context:\n      self.xla_context.Enter()\n\n  def __exit__(self, t, value, traceback):\n    if self.xla_context:\n      self.xla_context.Exit()\n\n\n# TODO(mdan): Consider expose this type for instance type checking.\n@tf_export(\"__internal__.function.Function\", v1=[])\nclass Function(core.GenericFunction):\n  \"\"\"A `tf.types.experimental.GenericFunction` created by `tf.function`.\n\n  Currently, individual methods/attributes under this class are not guaranteed\n  by the TF API contract, and are subject to future changes.\n  \"\"\"\n\n  def __init__(self,\n               python_function,\n               name,\n               input_signature=None,\n               autograph=True,\n               jit_compile=None,\n               experimental_implements=None,\n               experimental_autograph_options=None,\n               experimental_relax_shapes=False,\n               experimental_follow_type_hints=None):\n    \"\"\"Initializes a `Function`.\n\n    Args:\n      python_function: the function to be wrapped.\n      name: the name given to it.\n      input_signature: See the documentation for `tf.function`.\n      autograph: See the documentation for `tf.function`.\n      jit_compile: See the documentation for `tf.function`.\n      experimental_implements: See the documentation for `tf.function`.\n      experimental_autograph_options: See the documentation for `tf.function`.\n      experimental_relax_shapes: See the documentation for `tf.function`.\n      experimental_follow_type_hints: See the documentation for `tf.function`.\n\n    Raises:\n      ValueError: if `input_signature` is not None and the `python_function`'s\n        argspec has keyword arguments.\n    \"\"\"\n    self._lock = threading.RLock()\n    self._python_function = python_function\n    self._function_spec = function_lib.FunctionSpec.from_function_and_signature(\n        python_function,\n        input_signature,\n        jit_compile=jit_compile,\n        experimental_follow_type_hints=experimental_follow_type_hints,\n    )\n    self._implements = experimental_implements\n    # If `True`, the function uses the rendezvous of the parent. This is only\n    # needed to support code where raw send/recv operations are inserted and\n    # when functions are run in graph mode where they may not be inlined.\n    self._shared_rendezvous = None\n    self._autograph = autograph\n    self._experimental_autograph_options = experimental_autograph_options\n    self._experimental_relax_shapes = experimental_relax_shapes\n    self._jit_compile = jit_compile\n    if experimental_follow_type_hints is None:\n      experimental_follow_type_hints = False\n    self._experimental_follow_type_hints = experimental_follow_type_hints\n    self._created_variables = None  # GUARDED_BY(self._lock)\n    self._stateful_fn = None  # GUARDED_BY(self._lock)\n    self._stateless_fn = None  # GUARDED_BY(self._lock)\n    self._descriptor_cache = weakref.WeakKeyDictionary()\n    self._name = name\n    self._input_signature = input_signature\n    self._key_for_call_stats = self._get_key_for_call_stats()\n    self._omit_frequent_tracing_warning = False\n    ops._tf_function_api_guage.get_cell().set(True)  # pylint: disable=protected-access\n\n  def __getstate__(self):\n    \"\"\"Custom pickling, to omit unpickleable objects.\"\"\"\n    result = self.__dict__.copy()\n    del result[\"_lock\"]\n    del result[\"_descriptor_cache\"]\n    del result[\"_key_for_call_stats\"]\n    return result\n\n  def __setstate__(self, state):\n    \"\"\"Restore from pickled state.\"\"\"\n    self.__dict__ = state\n    self._lock = threading.RLock()\n    self._descriptor_cache = weakref.WeakKeyDictionary()\n    self._key_for_call_stats = self._get_key_for_call_stats()\n\n  def _get_key_for_call_stats(self):\n    \"\"\"Returns key instance to track call stats and retracings.\n\n    The key instance a best-effort to preserve global consistency.\n    \"\"\"\n    target_function = self._python_function\n    # `__wrapped__` is a conventional Python attribute that a higher-order\n    # function keeps its original function's instance.  We also directly use\n    # this attribute for dealing with a class method.  See\n    # `bound_method_wrapper` in `function.py`.  If we don't use `__wrapped__`,\n    # all class methods will return the same `bound_method_wrapper` instance\n    # from this function.\n    while hasattr(target_function, \"__wrapped__\"):\n      target_function = target_function.__wrapped__\n\n    if hasattr(target_function, \"__func__\"):\n      target_function = target_function.__func__\n\n    if hasattr(target_function, \"__code__\"):\n      return target_function.__code__\n\n    return self._python_function\n\n  def _defun_with_scope(self, scope):\n    \"\"\"Creates a defun wrapped inside a variable creator scope.\"\"\"\n\n    weak_wrapped_fn = None\n    compile_with_xla = self._jit_compile\n\n    def wrapped_fn(*args, **kwds):\n      \"\"\"Wraps `self._python_function` in a variable creator scope.\"\"\"\n      # We register a variable creator with reduced priority. If an outer\n      # variable creator is just modifying keyword arguments to the variable\n      # constructor, this will work harmoniously. Since the `scope` registered\n      # here actually creates the variable, it taking priority would otherwise\n      # ignore the outer creator.\n      #\n      # If an outer variable creator calls the variable constructor manually,\n      # for example creating a MirroredVariable, then they won't call our\n      # creator. This means we won't be able to trace the initialization graph,\n      # and so variable initializers can't depend on function arguments. This is\n      # better than the alternative, tracing the initialization graph but giving\n      # the user a variable type they didn't want.\n      default_graph = ops.get_default_graph()\n      with default_graph._variable_creator_scope(scope, priority=50):  # pylint: disable=protected-access\n        # __wrapped__ allows AutoGraph to swap in a converted function. We give\n        # the function a weak reference to itself to avoid a reference cycle.\n        with OptionalXlaContext(compile_with_xla):\n          out = weak_wrapped_fn().__wrapped__(*args, **kwds)\n        return out\n\n    weak_wrapped_fn = weakref.ref(wrapped_fn)\n\n    return self._defun(tf_decorator.make_decorator(\n        self._python_function,\n        wrapped_fn))\n\n  def _create_implements_attribute(self):\n    \"\"\"Creates the attribute value corresponding to IMPLEMENTS_ATTRIBUTE_NAME.\"\"\"\n    attributes = {}\n    if isinstance(self._implements, str):\n      # First check if the IMPLEMENTS_ATTRIBUTE_NAME is specified as a\n      # NameAttrList. This is used when apart from the function name being\n      # implemented, a list of attributes is also being specified.\n      # The attributes are specified as key-value pairs in the NameAttrList\n      # of the corresponding AttrValue. The function name will be in the\n      # 'name' field of the NameAttrList. Else, it is just a string\n      # corresponding to the function name.\n      try:\n        implements_attr = six.ensure_text(self._implements, \"utf-8\")\n        attr_value = attr_value_pb2.AttrValue()\n        nameattrlist = attr_value_pb2.NameAttrList()\n        _text_format.Merge(implements_attr, nameattrlist)\n        attr_value.func.CopyFrom(nameattrlist)\n        attributes[function_lib.IMPLEMENTS_ATTRIBUTE_NAME] = attr_value\n      except (_text_format.ParseError, DecodeError):\n        attributes[function_lib.IMPLEMENTS_ATTRIBUTE_NAME] = self._implements\n    return attributes\n\n  def _defun(self, fn):\n    \"\"\"Returns a defun generated from the input function.\"\"\"\n    attributes = {}\n\n    if self._implements is not None:\n      attributes = self._create_implements_attribute()\n\n    share = self._shared_rendezvous\n    if share is not None:\n      attributes[function_lib.SHARED_RENDEZVOUS_ATTRIBUTE_NAME] = share\n\n    if self._jit_compile is not None:\n      attributes.update(_XlaMustCompile=bool(self._jit_compile))\n      if self._jit_compile:\n        attributes.update(_noinline=True)\n    if not attributes:\n      attributes = None\n    return function_lib.defun_with_attributes(\n        fn,\n        input_signature=self.input_signature,\n        attributes=attributes,\n        autograph=self._autograph,\n        jit_compile=self._jit_compile,\n        experimental_autograph_options=self._experimental_autograph_options,\n        experimental_follow_type_hints=self._experimental_follow_type_hints,\n        experimental_relax_shapes=self._experimental_relax_shapes)\n\n  def _initialize(self, args, kwds, add_initializers_to=None):\n    \"\"\"Initializes, on the first call.\n\n    Creates two `Function`s, one that will allow creation of variables\n    and one that won't.\n\n    Additionally runs a trace for the `Function` that allows creation\n    of variables.\n\n    Args:\n      args: Arguments to the underlying python callable.\n      kwds: Keyword arguments to the python callable.\n      add_initializers_to: Where to collect variable initializers, if not None.\n    \"\"\"\n\n    if self._input_signature is not None:\n      arglen = len(self._input_signature)\n      arg_names_len = len(self.function_spec.arg_names)\n      default_arg_len = len(self.function_spec.fullargspec.defaults or ())\n      required_arg_len = arg_names_len - default_arg_len\n      # The input signature must cover all required function arguments.\n      if arglen < required_arg_len:\n        missing_tensor_specs = self.function_spec.arg_names[\n            arglen:required_arg_len]\n        raise TypeError(\n            f\"The decorated function {self._name} has {required_arg_len} \"\n            f\"required argument(s), but tf.function was only passed an \"\n            f\"input_signature of length {arglen}. This covers {arglen} \"\n            f\"required argument(s): {self.function_spec.arg_names[:arglen]}, \"\n            f\"but TensorSpecs are still required for the remaining \"\n            f\"{len(missing_tensor_specs)} argument(s): {missing_tensor_specs}.\")\n\n    created_variables = []\n    lifted_initializer_graph = func_graph_module.FuncGraph(\"initializer\")\n\n    def variable_capturing_scope(unused_next_creator, **kwds):\n      \"\"\"Creates UnliftedInitializerVariables and saves references to them.\"\"\"\n      v = UnliftedInitializerVariable(\n          add_initializers_to=add_initializers_to,\n          lifted_initializer_graph=lifted_initializer_graph, **kwds)\n      created_variables.append(weakref.ref(v))\n      return v\n\n    self._created_variables = created_variables\n    self._stateful_fn = self._defun_with_scope(variable_capturing_scope)\n    self._stateful_fn._name = self._name  # pylint: disable=protected-access\n    # Force the definition of the function for these arguments\n    self._lifted_initializer_graph = lifted_initializer_graph\n    self._graph_deleter = FunctionDeleter(self._lifted_initializer_graph)\n    self._concrete_stateful_fn = (\n        self._stateful_fn._get_concrete_function_internal_garbage_collected(  # pylint: disable=protected-access\n            *args, **kwds))\n\n    def invalid_creator_scope(*unused_args, **unused_kwds):\n      \"\"\"Disables variable creation.\"\"\"\n      raise ValueError(\n          \"tf.function only supports singleton tf.Variables created on the \"\n          \"first call. Make sure the tf.Variable is only created once or \"\n          \"created outside tf.function. See \"\n          \"https://www.tensorflow.org/guide/function#creating_tfvariables \"\n          \"for more information.\")\n\n    self._stateless_fn = self._defun_with_scope(invalid_creator_scope)\n    self._stateless_fn._name = self._name  # pylint: disable=protected-access\n\n  def _clone(self, python_function):\n    \"\"\"Clone the function with different python function.\"\"\"\n    f = Function(\n        python_function=(self._python_function\n                         if python_function is None else python_function),\n        name=self._name,\n        input_signature=self._input_signature,\n        autograph=self._autograph,\n        jit_compile=self._jit_compile,\n        experimental_implements=self._implements,\n        experimental_autograph_options=self._experimental_autograph_options,\n        experimental_relax_shapes=self._experimental_relax_shapes,\n        experimental_follow_type_hints=self._experimental_follow_type_hints)\n\n    if self._shared_rendezvous:\n      f._shared_rendezvous = self._shared_rendezvous  # pylint: disable=protected-access\n\n    return f\n\n  def _decorate(self, decorator):\n    \"\"\"Allows the captured Python function to be decorated in place.\n\n    This method is only safe to call when the Function has not been called by a\n    user. It makes sense to use this method to push a decorator into the\n    function rather than wrapping the function in the decorator.\n\n    We use this in tf.Module to allow user annotated `tf.functions` to remain as\n    `Function` objects but still automatically enter the Module name_scope\n    when they are evaluated like all other methods.\n\n    Args:\n      decorator: A callable accepting a single argument which is the function\n        to decorate and returning a callable result.\n\n    Raises:\n      ValueError: If the function has been called a ValueError is raised.\n    \"\"\"\n    if self._stateful_fn is not None or self._stateless_fn is not None:\n      raise ValueError(\n          \"Functions cannot be decorated after they have been traced.\")\n\n    self._python_function = decorator(self._python_function)\n    self._function_spec = function_lib.FunctionSpec.from_function_and_signature(\n        self._python_function, self.input_signature)\n\n  # TODO: Remove this private method after updating all its uses\n  # A good moment to do this could be when the experimental label is removed\n  def _get_tracing_count(self):\n    return self.experimental_get_tracing_count()\n\n  def experimental_get_tracing_count(self):\n    \"\"\"Returns the number of times the function has been traced.\n\n    For more information on when a function is traced and when it is\n    traced multiple times see https://www.tensorflow.org/guide/function.\n    Example:\n\n    >>> @tf.function\n    ... def double(a):\n    ...   return a + a\n    >>> double(tf.constant(1))\n    >>> double(tf.constant(2))\n    >>> double.experimental_get_tracing_count()\n    1\n    >>> double(tf.constant(\"a\"))\n    >>> double.experimental_get_tracing_count()\n    2\n\n\n    The first time experimental_get_tracing_count is called\n    it returns 1, as the function is traced the first\n    time it is called, and the second time the same graph is used\n    since we're calling it with a parameter of the same type.\n\n    The second time experimental_get_tracing_count is called\n    it returns 2, as we called double with a\n    different argument type, and so it was traced again.\n\n    \"\"\"\n    result = self._stateless_fn.tracing_count if self._stateless_fn else 0\n    result += self._stateful_fn.tracing_count if self._stateful_fn else 0\n    return result\n\n  @property\n  def _run_functions_eagerly(self):\n    return RUN_FUNCTIONS_EAGERLY\n\n  @traceback_utils.filter_traceback\n  def __call__(self, *args, **kwds):\n    # Implements GenericFunction.__call__.\n    if self._run_functions_eagerly:\n      with trace.Trace(self._name, tf_function_call=\"eager\"):\n        return self._python_function(*args, **kwds)\n\n    # Only count the statistics the first time, before initialization took\n    # place.\n    if self._created_variables is None:\n      compiled = bool(self._jit_compile and\n                      not control_flow_util.GraphOrParentsInXlaContext(\n                          ops.get_default_graph()))\n      # For nested functions, increment the counter only when a function with\n      # jit_compile=True is called within a function with jit_compile=False. We\n      # count this special case to correctly record that both jit_compile=True\n      # and jit_compile=False is being used for parts of the outer function.\n      if ops.executing_eagerly_outside_functions() and (\n          context.executing_eagerly() or compiled):\n        # Labels must be strings in Python, so we convert 'compiled' to a string\n        _tf_function_counter.get_cell(str(int(compiled))).increase_by(1)\n\n    tracing_count = self.experimental_get_tracing_count()\n    with trace.Trace(self._name) as tm:\n      # TODO(cheshire): Do not duplicate the XLAControlFlowContext annotation.\n      compiler = \"xla\" if self._jit_compile else \"nonXla\"\n\n      with OptionalXlaContext(self._jit_compile):\n        result = self._call(*args, **kwds)\n\n      new_tracing_count = self.experimental_get_tracing_count()\n      without_tracing = (tracing_count == new_tracing_count)\n      execution_mode = \"notTraced\" if without_tracing else \"traced\"\n      tm.set_metadata(tf_function_call=execution_mode + \"-\" + compiler,\n                      tracing_count=new_tracing_count)\n\n    if context.executing_eagerly():\n      if without_tracing:\n        _frequent_tracing_detector_manager.called_without_tracing(\n            self._key_for_call_stats)\n      else:\n        _frequent_tracing_detector_manager.called_with_tracing(\n            self._key_for_call_stats, self._python_function,\n            self._omit_frequent_tracing_warning)\n\n    return result\n\n  def _call(self, *args, **kwds):\n    \"\"\"Calls the graph function.\"\"\"\n    self._lock.acquire()\n    if ALLOW_DYNAMIC_VARIABLE_CREATION:\n      condition = self._created_variables and self._stateful_fn is None\n    else:\n      condition = self._created_variables\n    if condition:\n      # Release the lock early so that multiple threads can perform the call\n      # in parallel.\n      self._lock.release()\n      # In this case we have created variables on the first call, so we run the\n      # defunned version which is guaranteed to never create variables.\n      return self._stateless_fn(*args, **kwds)  # pylint: disable=not-callable\n    elif self._stateful_fn is not None:\n      # Release the lock early so that multiple threads can perform the call\n      # in parallel.\n      self._lock.release()\n      # In this case we have not created variables on the first call. So we can\n      # run the first trace but we should fail if variables are created.\n      results = self._stateful_fn(*args, **kwds)\n      if self._created_variables and not ALLOW_DYNAMIC_VARIABLE_CREATION:\n        raise ValueError(\"Creating variables on a non-first call to a function\"\n                         \" decorated with tf.function.\")\n      return results\n\n    try:\n      # This is the first call of __call__, so we have to initialize.\n      initializers = []\n      self._initialize(args, kwds, add_initializers_to=initializers)\n    finally:\n      # At this point we know that the initialization is complete (or less\n      # interestingly an exception was raised) so we no longer need a lock.\n      self._lock.release()\n\n    if self._created_variables:\n      try:\n        # Attempt to initialize variables eagerly and without conds by lifting\n        # out initialization graphs. This is the only initialization strategy\n        # compatible with XLA at the moment.\n        self._initialize_uninitialized_variables(initializers)\n      except lift_to_graph.UnliftableError:\n        pass  # Fall through to cond-based initialization.\n      else:\n        # Lifting succeeded, so variables are initialized and we can run the\n        # stateless function.\n        return self._stateless_fn(*args, **kwds)\n    else:\n      _, _, _, filtered_flat_args = \\\n          self._stateful_fn._function_spec.canonicalize_function_inputs(  # pylint: disable=protected-access\n              *args, **kwds)\n      # If we did not create any variables the trace we have is good enough.\n      return self._concrete_stateful_fn._call_flat(\n          filtered_flat_args, self._concrete_stateful_fn.captured_inputs)  # pylint: disable=protected-access\n\n    def fn_with_cond(inner_args, inner_kwds, inner_filtered_flat_args):\n      \"\"\"Conditionally runs initialization if it's needed.\"\"\"\n      condition = True\n      for wr in self._created_variables:\n        variable = wr()\n        if variable is None:\n          raise ValueError(\n              \"A tf.Variable created inside your tf.function has been\"\n              \" garbage-collected. Your code needs to keep Python references\"\n              \" to variables created inside `tf.function`s.\\n\"\n              \"\\n\"\n              \"A common way to raise this error is to create and return a\"\n              \" variable only referenced inside your function:\\n\"\n              \"\\n\"\n              \"@tf.function\\n\"\n              \"def f():\\n\"\n              \"  v = tf.Variable(1.0)\\n\"\n              \"  return v\\n\"\n              \"\\n\"\n              \"v = f()  # Crashes with this error message!\\n\"\n              \"\\n\"\n              \"The reason this crashes is that @tf.function annotated\"\n              \" function returns a **`tf.Tensor`** with the **value** of the\"\n              \" variable when the function is called rather than the\"\n              \" variable instance itself. As such there is no code holding a\"\n              \" reference to the `v` created inside the function and Python\"\n              \" garbage collects it.\\n\"\n              \"\\n\"\n              \"The simplest way to fix this issue is to create variables\"\n              \" outside the function and capture them:\\n\"\n              \"\\n\"\n              \"v = tf.Variable(1.0)\\n\"\n              \"\\n\"\n              \"@tf.function\\n\"\n              \"def f():\\n\"\n              \"  return v\\n\"\n              \"\\n\"\n              \"f()  # <tf.Tensor: numpy=1.>\\n\"\n              \"v.assign_add(1.)\\n\"\n              \"f()  # <tf.Tensor: numpy=2.>\")\n        condition = math_ops.logical_and(\n            condition, resource_variable_ops.var_is_initialized_op(\n                variable.handle))\n      # We want to call stateless_fn if possible because it avoids recomputing\n      # potentially expensive initializers.\n      return control_flow_ops.cond(\n          condition,\n          lambda: self._stateless_fn(*inner_args, **inner_kwds),\n          functools.partial(\n              self._concrete_stateful_fn._call_flat,  # pylint: disable=protected-access\n              inner_filtered_flat_args,\n              captured_inputs=self._concrete_stateful_fn.captured_inputs))\n\n    # We've created variables and are unable to lift the initialization graphs,\n    # so we fall back to initializing with conds while running the function.\n    canon_args, canon_kwds, _, filtered_flat_args = \\\n        self._stateful_fn._function_spec.canonicalize_function_inputs(  # pylint: disable=protected-access\n            *args, **kwds)\n    return function_lib.defun(fn_with_cond)(canon_args, canon_kwds,\n                                            filtered_flat_args)\n\n  def experimental_get_compiler_ir(self, *args, **kwargs):\n    # Implements GenericFunction.experimental_get_compiler_ir\n    context.ensure_initialized()\n    if not self._jit_compile:\n      raise ValueError(\"Compiler IR can only be returned for functions marked \"\n                       \"with 'jit_compile=True'\")\n\n    concrete_fn = self.get_concrete_function(*args, **kwargs)\n    fn_name = concrete_fn.name\n\n    # pylint: disable=protected-access\n    _, _, _, filtered_flat_args = \\\n        concrete_fn._function_spec.canonicalize_function_inputs(\n            *args, **kwargs)\n\n    def compiler_ir_generator(stage=\"hlo\", device_name=None):\n      # TODO(cheshire): This is a hack to get the current \"preferred\" device,\n      # there is no current API to get it otherwise.\n      if device_name is None:\n        device_name = random_ops.random_normal([]).device\n      res_bytes = context.context().get_compiler_ir(\n          device_name=device_name,\n          stage=stage,\n          function_name=fn_name,\n          args=list(filtered_flat_args) + concrete_fn.captured_inputs)\n      if stage in (\"hlo_serialized\", \"optimized_hlo_serialized\",\n                   \"optimized_hlo_proto_serialized\"):\n        return res_bytes\n      else:\n        return res_bytes.decode(\"utf-8\")\n\n    return compiler_ir_generator\n\n  @property\n  def python_function(self):\n    \"\"\"The python function wrapped in this tf.function.\"\"\"\n    return self._python_function\n\n  @property\n  def input_signature(self):\n    return self._function_spec.input_signature\n\n  @property\n  def function_spec(self):\n    return self._function_spec\n\n  def pretty_printed_concrete_signatures(self, verbose=True):\n    joiner = \"\\n\\n\" if verbose else \"\\n\"\n    return joiner.join([\n        c.pretty_printed_signature(verbose=verbose)\n        for c in self._list_all_concrete_functions()\n    ])\n\n  def _initialize_uninitialized_variables(self, initializers):\n    \"\"\"Make and call a `ConcreteFunction` which initializes variables.\"\"\"\n\n    if not initializers:\n      return\n\n    var_is_initialized = _evaluate_var_is_initialized(\n        [v for v, _ in initializers])\n\n    # Note: using defun here avoids an infinite recursion.\n    # Most of the code in this function runs eagerly with init_scope, where\n    # autograph is not necessary.\n    @function_lib.defun(autograph=False)\n    def initialize_variables():\n      op_map = object_identity.ObjectIdentityDictionary()\n\n      inits = []\n      for (v, init), is_initialized in zip(initializers, var_is_initialized):\n        with ops.init_scope():\n          if is_initialized:\n            continue\n        inits.append(init)\n\n      if inits:\n        op_map = lift_to_graph.lift_to_graph(\n            inits, ops.get_default_graph(), op_map=op_map)\n      for (v, init), is_initialized in zip(initializers, var_is_initialized):\n        with ops.init_scope():\n          if is_initialized:\n            continue\n        v.assign(op_map[init], read_value=False)\n\n    with ops.init_scope():\n      return initialize_variables.get_concrete_function()()\n\n  def get_initialization_function(self, *args, **kwargs):\n    \"\"\"Returns a `ConcreteFunction` which initializes this function's variables.\n\n    Requires that this function hasn't been accessed yet through either calling\n    it or calling get_concrete_function. Fails if we cannot build an initializer\n    function which does not depend on the concrete values of the inputs to this\n    function.\n\n    Note that running this function will overwrite any values currently assigned\n    to variables, for example restores from a checkpoint.\n\n    Args:\n      *args: arguments to the underlying python callable.\n      **kwargs: keyword arguments to the python callable.\n\n    Returns:\n      A `ConcreteFunction` object which initializes the variables of this\n      function.\n\n    Raises:\n      RuntimeError: if called after the variables have been initialized.\n    \"\"\"\n    with self._lock:\n      if self._stateful_fn is not None:\n        raise RuntimeError(\n            \"get_initialization_function cannot be called after the function \"\n            \"has been used\")\n      # Here we trace the function, collect the initializers, and attempt to\n      # extract them and run them eagerly. Fail only if we cannot do so.\n      initializers = []\n      self._initialize(args, kwargs, add_initializers_to=initializers)\n\n    # Note: using defun here avoids an infinite recursion.\n    @function_lib.defun\n    def initialize_variables():\n      for v, init in initializers:\n        v.assign(\n            lift_to_graph.lift_to_graph([init], ops.get_default_graph())[init],\n            read_value=False)\n\n    return initialize_variables.get_concrete_function()\n\n  def _list_all_concrete_functions(self):\n    \"\"\"Returns all concrete functions.\"\"\"\n    if self.input_signature is not None:\n      self.get_concrete_function()\n    concrete_functions = []\n    # pylint: disable=protected-access\n    if self._stateful_fn:\n      concrete_functions.extend(\n          self._stateful_fn._function_cache.all_values())\n    if self._stateless_fn:\n      concrete_functions.extend(\n          self._stateless_fn._function_cache.all_values())\n    # pylint: enable=protected-access\n    return concrete_functions\n\n  def _list_all_concrete_functions_for_serialization(self):\n    \"\"\"Returns all concrete functions for serialization.\n\n    Returns:\n      A list of instances of `ConcreteFunction`.\n    \"\"\"\n    concrete_functions = self._list_all_concrete_functions()\n    seen_signatures = []\n    for concrete_function in concrete_functions:\n      signature = concrete_function.structured_input_signature\n      flattened = nest.flatten(signature)\n      if any(\n          isinstance(arg, func_graph_module.UnknownArgument)\n          for arg in flattened):\n        logging.info(\"Unsupported signature for serialization: %s.\", signature)\n        continue\n      equal_to_signature = functools.partial(\n          function_lib.is_same_structure, signature, check_values=True)\n      if not any(equal_to_signature(s) for s in seen_signatures):\n        seen_signatures.append(signature)\n\n    # Re-create concrete functions for these signatures. Re-creating ensures\n    # that if the cache key has changed, the function will be traced again.\n    concrete_functions = []\n    for args, kwargs in seen_signatures:\n      concrete_functions.append(self.get_concrete_function(*args, **kwargs))\n    return concrete_functions\n\n  def _get_concrete_function_garbage_collected(self, *args, **kwargs):\n    \"\"\"Returns a `ConcreteFunction` specialized to inputs and execution context.\n\n    Unlike `get_concrete_function(...)`, the graph will be deleted when the\n    returned function is deleted.  It's useful to avoid creating a reference\n    cycle when you know for sure that the graph will be no longer used without\n    the returned function.\n\n    Args:\n      *args: inputs to specialize on.\n      **kwargs: inputs to specialize on.\n\n    Returns:\n      A TensorFlow function which takes exactly one `tf.Tensor` per argument.\n\n    Raises:\n      ValueError: if this object has not yet been called on concrete values.\n    \"\"\"\n    with self._lock:\n      if self._stateful_fn is None:\n        initializers = []\n        self._initialize(args, kwargs, add_initializers_to=initializers)\n        self._initialize_uninitialized_variables(initializers)\n\n    if self._created_variables:\n      # In this case we have created variables on the first call, so we run the\n      # defunned version which is guaranteed to never create variables.\n      return self._stateless_fn._get_concrete_function_garbage_collected(  # pylint: disable=protected-access\n          *args, **kwargs)\n    elif self._stateful_fn is not None:\n      # In this case we have not created variables on the first call. So we can\n      # run the first trace but we should fail if variables are created.\n      concrete = self._stateful_fn._get_concrete_function_garbage_collected(  # pylint: disable=protected-access\n          *args, **kwargs)\n      if self._created_variables:\n        raise ValueError(\"Creating variables on a non-first call to a function\"\n                         \" decorated with tf.function.\")\n      return concrete\n\n  def get_concrete_function(self, *args, **kwargs):\n    # Implements GenericFunction.get_concrete_function.\n    concrete = self._get_concrete_function_garbage_collected(*args, **kwargs)\n    concrete._garbage_collector.release()  # pylint: disable=protected-access\n    return concrete\n\n  def __get__(self, instance, owner):\n    \"\"\"Makes it possible to defun instance methods.\"\"\"\n    del owner\n    # `instance` here is the instance that this `Function` was accessed through\n    # e.g., for\n    #\n    #   class Foo(object):\n    #\n    #     @function.defun\n    #     def bar(self):\n    #       ...\n    #\n    #   foo = Foo()\n    #   foo.bar()  # `foo.bar` is a `Function` instance\n    #\n    # then `instance` will be `foo` (and `owner` will be `Foo`).  For composite\n    # tensors, we can just treat `instance` as a normal parameter.  But for\n    # other types, we create a new instance of `Function` here to allow\n    # different instances each to create variables once, thereby allowing\n    # methods to be decorated with tf.function. Keeps a cache to avoid retracing\n    # the function every time the descriptor is accessed.\n    # TODO(mdan): Identify types which can just be parameters more generically.\n    #\n    # The check for instance._type_spec=None is used because certain classes\n    # (including subclasses of tf.linalg.LinearOperator) are subclasses of\n    # CompositeTensor but do not actually implement the required APIs.\n    # TODO(b/199278478): Fix those classes, then remove the check for\n    # `instance._type_spec is not None`.\n    if (isinstance(instance, composite_tensor.CompositeTensor) and\n        instance._type_spec is not None):  # pylint: disable=protected-access\n      return types_lib.MethodType(self, instance)\n    if instance not in self._descriptor_cache:\n      if instance is None:\n        return self\n      # TODO(mdan): If the CompositeTensor path works, do the same here.\n      # It's unclear whether we need the tf-decorator, or could just call\n      # MethodType(self.clone(), instance)\n      self._descriptor_cache[instance] = (\n          function_lib.class_method_to_instance_method(self, instance))\n    return self._descriptor_cache[instance]\n\n\n@tf_export(\"function\")\n@deprecation.deprecated_args(None,\n                             \"experimental_compile is deprecated, use \"\n                             \"jit_compile instead\", \"experimental_compile\")\ndef function(func=None,\n             input_signature=None,\n             autograph=True,\n             jit_compile=None,\n             experimental_implements=None,\n             experimental_autograph_options=None,\n             experimental_relax_shapes=False,\n             experimental_compile=None,\n             experimental_follow_type_hints=None) -> core.GenericFunction:\n  \"\"\"Compiles a function into a callable TensorFlow graph.\n\n  `tf.function` constructs a `tf.types.experimental.GenericFunction` that\n  executes a TensorFlow graph (`tf.Graph`) created by trace-compiling the\n  TensorFlow operations in `func`. More information on the topic can be found\n  in [Introduction to Graphs and tf.function]\n  (https://www.tensorflow.org/guide/intro_to_graphs).\n\n  See [Better Performance with tf.function]\n  (https://www.tensorflow.org/guide/function) for tips on performance and\n  known limitations.\n\n  Example usage:\n\n  >>> @tf.function\n  ... def f(x, y):\n  ...   return x ** 2 + y\n  >>> x = tf.constant([2, 3])\n  >>> y = tf.constant([3, -2])\n  >>> f(x, y)\n  <tf.Tensor: ... numpy=array([7, 7], ...)>\n\n  The trace-compilation allows non-TensorFlow operations to execute, but under\n  special conditions. In general, only TensorFlow operations are guaranteed to\n  run and create fresh results whenever the `GenericFunction` is called.\n\n  ## Features\n\n  `func` may use data-dependent control flow, including `if`, `for`, `while`\n  `break`, `continue` and `return` statements:\n\n  >>> @tf.function\n  ... def f(x):\n  ...   if tf.reduce_sum(x) > 0:\n  ...     return x * x\n  ...   else:\n  ...     return -x // 2\n  >>> f(tf.constant(-2))\n  <tf.Tensor: ... numpy=1>\n\n  `func`'s closure may include `tf.Tensor` and `tf.Variable` objects:\n\n  >>> @tf.function\n  ... def f():\n  ...   return x ** 2 + y\n  >>> x = tf.constant([-2, -3])\n  >>> y = tf.Variable([3, -2])\n  >>> f()\n  <tf.Tensor: ... numpy=array([7, 7], ...)>\n\n  `func` may also use ops with side effects, such as `tf.print`, `tf.Variable`\n  and others:\n\n  >>> v = tf.Variable(1)\n  >>> @tf.function\n  ... def f(x):\n  ...   for i in tf.range(x):\n  ...     v.assign_add(i)\n  >>> f(3)\n  >>> v\n  <tf.Variable ... numpy=4>\n\n  Important: Any Python side-effects (appending to a list, printing with\n  `print`, etc) will only happen once, when `func` is traced. To have\n  side-effects executed into your `tf.function` they need to be written\n  as TF ops:\n\n  >>> l = []\n  >>> @tf.function\n  ... def f(x):\n  ...   for i in x:\n  ...     l.append(i + 1)    # Caution! Will only happen once when tracing\n  >>> f(tf.constant([1, 2, 3]))\n  >>> l\n  [<tf.Tensor ...>]\n\n  Instead, use TensorFlow collections like `tf.TensorArray`:\n\n  >>> @tf.function\n  ... def f(x):\n  ...   ta = tf.TensorArray(dtype=tf.int32, size=0, dynamic_size=True)\n  ...   for i in range(len(x)):\n  ...     ta = ta.write(i, x[i] + 1)\n  ...   return ta.stack()\n  >>> f(tf.constant([1, 2, 3]))\n  <tf.Tensor: ..., numpy=array([2, 3, 4], ...)>\n\n  ## `tf.function` creates polymorphic callables\n\n  Internally, `tf.types.experimental.GenericFunction` may contain multiple\n  `tf.types.experimental.ConcreteFunction`s, each specialized to arguments with\n  different data types or shapes, since TensorFlow can perform more\n  optimizations on graphs of specific shapes, dtypes and values of constant\n  arguments. `tf.function` treats any pure Python values as opaque objects (best\n  thought of as compile-time constants), and builds a separate `tf.Graph` for\n  each set of Python arguments that it encounters.\n  For more information, see the\n  [tf.function guide](https://www.tensorflow.org/guide/function#rules_of_tracing)\n\n  Executing a `GenericFunction` will select and execute the appropriate\n  `ConcreteFunction` based on the argument types and values.\n\n  To obtain an individual `ConcreteFunction`, use the\n  `GenericFunction.get_concrete_function` method. It can be called with the\n  same arguments as `func` and returns a\n  `tf.types.experimental.ConcreteFunction`. `ConcreteFunction`s are backed by a\n  single `tf.Graph`:\n\n  >>> @tf.function\n  ... def f(x):\n  ...   return x + 1\n  >>> isinstance(f.get_concrete_function(1).graph, tf.Graph)\n  True\n\n  `ConcreteFunction`s can be executed just like `GenericFunction`s, but their\n  input is resticted to the types to which they're specialized.\n\n  ## Retracing\n\n  `ConcreteFunctions` are built (traced) on the fly, as the `GenericFunction` is\n  called with new TensorFlow types or shapes, or with new Python values as\n  arguments. When `GenericFunction` builds a new trace, it is said that `func`\n  is retraced. Retracing is a frequent performance concern for `tf.function` as\n  it can be considerably slower than executing a graph that's already been\n  traced. It is ideal to minimize the amount of retracing in your code.\n\n  Caution: Passing python scalars or lists as arguments to `tf.function` will\n  usually retrace. To avoid this, pass numeric arguments as Tensors whenever\n  possible:\n\n  >>> @tf.function\n  ... def f(x):\n  ...   return tf.abs(x)\n  >>> f1 = f.get_concrete_function(1)\n  >>> f2 = f.get_concrete_function(2)  # Slow - compiles new graph\n  >>> f1 is f2\n  False\n  >>> f1 = f.get_concrete_function(tf.constant(1))\n  >>> f2 = f.get_concrete_function(tf.constant(2))  # Fast - reuses f1\n  >>> f1 is f2\n  True\n\n  Python numerical arguments should only be used when they take few distinct\n  values, such as hyperparameters like the number of layers in a neural network.\n\n  ## Input signatures\n\n  For Tensor arguments, `GenericFunction`creates a new `ConcreteFunction` for\n  every unique set of input shapes and datatypes. The example below creates two\n  separate `ConcreteFunction`s, each specialized to a different shape:\n\n  >>> @tf.function\n  ... def f(x):\n  ...   return x + 1\n  >>> vector = tf.constant([1.0, 1.0])\n  >>> matrix = tf.constant([[3.0]])\n  >>> f.get_concrete_function(vector) is f.get_concrete_function(matrix)\n  False\n\n  An \"input signature\" can be optionally provided to `tf.function` to control\n  this process. The input signature specifies the shape and type of each\n  Tensor argument to the function using a `tf.TensorSpec` object. More general\n  shapes can be used. This ensures only one `ConcreteFunction` is created, and\n  restricts the `GenericFunction` to the specified shapes and types. It is\n  an effective way to limit retracing when Tensors have dynamic shapes.\n\n  >>> @tf.function(\n  ...     input_signature=[tf.TensorSpec(shape=None, dtype=tf.float32)])\n  ... def f(x):\n  ...   return x + 1\n  >>> vector = tf.constant([1.0, 1.0])\n  >>> matrix = tf.constant([[3.0]])\n  >>> f.get_concrete_function(vector) is f.get_concrete_function(matrix)\n  True\n\n  ## Variables may only be created once\n\n  `tf.function` only allows creating new `tf.Variable` objects when it is called\n  for the first time:\n\n  >>> class MyModule(tf.Module):\n  ...   def __init__(self):\n  ...     self.v = None\n  ...\n  ...   @tf.function\n  ...   def __call__(self, x):\n  ...     if self.v is None:\n  ...       self.v = tf.Variable(tf.ones_like(x))\n  ...     return self.v * x\n\n  In general, it is recommended to create `tf.Variable`s outside of\n  `tf.function`.\n  In simple cases, persisting state across `tf.function` boundaries may be\n  implemented using a pure functional style in which state is represented by\n  `tf.Tensor`s passed as arguments and returned as return values.\n\n  Contrast the two styles below:\n\n  >>> state = tf.Variable(1)\n  >>> @tf.function\n  ... def f(x):\n  ...   state.assign_add(x)\n  >>> f(tf.constant(2))  # Non-pure functional style\n  >>> state\n  <tf.Variable ... numpy=3>\n\n  >>> state = tf.constant(1)\n  >>> @tf.function\n  ... def f(state, x):\n  ...   state += x\n  ...   return state\n  >>> state = f(state, tf.constant(2))  # Pure functional style\n  >>> state\n  <tf.Tensor: ... numpy=3>\n\n  ## Python operations execute only once per trace\n\n  `func` may contain TensorFlow operations mixed with pure Python operations.\n  However, when the function is executed, only the TensorFlow operations will\n  run. The Python operations run only once, at trace time. If TensorFlow\n  operations depend on results from Pyhton operations, those results will be\n  frozen into the graph.\n\n  >>> @tf.function\n  ... def f(a, b):\n  ...   print('this runs at trace time; a is', a, 'and b is', b)\n  ...   return b\n  >>> f(1, tf.constant(1))\n  this runs at trace time; a is 1 and b is Tensor(\"...\", shape=(), dtype=int32)\n  <tf.Tensor: shape=(), dtype=int32, numpy=1>\n\n  >>> f(1, tf.constant(2))\n  <tf.Tensor: shape=(), dtype=int32, numpy=2>\n\n  >>> f(2, tf.constant(1))\n  this runs at trace time; a is 2 and b is Tensor(\"...\", shape=(), dtype=int32)\n  <tf.Tensor: shape=(), dtype=int32, numpy=1>\n\n  >>> f(2, tf.constant(2))\n  <tf.Tensor: shape=(), dtype=int32, numpy=2>\n\n  ## Using type annotations to improve performance\n\n  'experimental_follow_type_hints` can be used along with type annotations to\n  reduce retracing by automatically casting any Python values to `tf.Tensor`\n  (something that is not done by default, unless you use input signatures).\n\n  >>> @tf.function(experimental_follow_type_hints=True)\n  ... def f_with_hints(x: tf.Tensor):\n  ...   print('Tracing')\n  ...   return x\n  >>> @tf.function(experimental_follow_type_hints=False)\n  ... def f_no_hints(x: tf.Tensor):\n  ...   print('Tracing')\n  ...   return x\n  >>> f_no_hints(1)\n  Tracing\n  <tf.Tensor: shape=(), dtype=int32, numpy=1>\n  >>> f_no_hints(2)\n  Tracing\n  <tf.Tensor: shape=(), dtype=int32, numpy=2>\n  >>> f_with_hints(1)\n  Tracing\n  <tf.Tensor: shape=(), dtype=int32, numpy=1>\n  >>> f_with_hints(2)\n  <tf.Tensor: shape=(), dtype=int32, numpy=2>\n\n  Args:\n    func: the function to be compiled. If `func` is None, `tf.function` returns\n      a decorator that can be invoked with a single argument - `func`. In other\n      words, `tf.function(input_signature=...)(func)` is equivalent to\n      `tf.function(func, input_signature=...)`. The former can be used as\n      decorator.\n    input_signature: A possibly nested sequence of `tf.TensorSpec` objects\n      specifying the shapes and dtypes of the Tensors that will be supplied to\n      this function. If `None`, a separate function is instantiated for each\n      inferred input signature.  If input_signature is specified, every input to\n      `func` must be a `Tensor`, and `func` cannot accept `**kwargs`.\n    autograph: Whether autograph should be applied on `func` before tracing a\n      graph. Data-dependent control flow requires `autograph=True`. For more\n      information, see the [tf.function and AutoGraph guide](\n      https://www.tensorflow.org/guide/function#autograph_transformations).\n    jit_compile: If `True`, compiles the function using\n      [XLA](https://tensorflow.org/xla). XLA performs compiler optimizations,\n      such as fusion, and attempts to emit more efficient code. This may\n      drastically improve the performance. If set to `True`,\n      the whole function needs to be compilable by XLA, or an\n      `errors.InvalidArgumentError` is thrown.\n      If `None` (default), compiles the function with XLA when running on TPU\n      and goes through the regular function execution path when running on\n      other devices.\n      If `False`, executes the function without XLA compilation.  Set this value\n      to `False` when directly running a multi-device function on TPUs (e.g. two\n      TPU cores, one TPU core and its host CPU).\n      Not all functions are compilable, see a list of\n      [sharp corners](https://tensorflow.org/xla/known_issues).\n    experimental_implements: If provided, contains a name of a \"known\" function\n      this implements. For example \"mycompany.my_recurrent_cell\".\n      This is stored as an attribute in inference function,\n      which can then be detected when processing serialized function.\n      See [standardizing composite ops](https://github.com/tensorflow/community/blob/master/rfcs/20190610-standardizing-composite_ops.md)  # pylint: disable=line-too-long\n      for details.  For an example of utilizing this attribute see this\n      [example](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/compiler/mlir/lite/transforms/prepare_composite_functions_tf.cc)\n      The code above automatically detects and substitutes function that\n      implements \"embedded_matmul\" and allows TFLite to substitute its own\n      implementations. For instance, a tensorflow user can use this\n       attribute to mark that their function also implements\n      `embedded_matmul` (perhaps more efficiently!)\n      by specifying it using this parameter:\n      `@tf.function(experimental_implements=\"embedded_matmul\")`\n      This can either be specified as just the string name of the function or\n      a NameAttrList corresponding to a list of key-value attributes associated\n      with the function name. The name of the function will be in the 'name'\n      field of the NameAttrList. To define a formal TF op for this function\n      implements, try the experimental [composite TF](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/compiler/mlir/tfr)\n      project.\n    experimental_autograph_options: Optional tuple of\n      `tf.autograph.experimental.Feature` values.\n    experimental_relax_shapes: When True, `tf.function` may generate fewer,\n      graphs that are less specialized on input shapes.\n    experimental_compile: Deprecated alias to 'jit_compile'.\n    experimental_follow_type_hints: When True, the function may use type\n      annotations from `func` to optimize the tracing performance. For example,\n      arguments annotated with `tf.Tensor` will automatically be converted\n      to a Tensor.\n\n  Returns:\n     If `func` is not None, returns a `tf.types.experimental.GenericFunction`.\n     If `func` is None, returns a decorator that, when invoked with a single\n     `func` argument, returns a `tf.types.experimental.GenericFunction`.\n\n  Raises:\n     `ValueError` when attempting to use `jit_compile=True`, but XLA support is\n     not available.\n  \"\"\"\n  if func is not None:\n    function_lib.validate_python_function(func)\n  if input_signature is not None:\n    function_lib.validate_signature(input_signature)\n  if experimental_follow_type_hints is None:\n    experimental_follow_type_hints = False\n\n  def decorated(inner_function):\n    try:\n      name = inner_function.__name__\n    except AttributeError:\n      name = \"function\"\n    return tf_decorator.make_decorator(\n        inner_function,\n        decorator_name=\"tf.function\",\n        decorator_func=Function(\n            inner_function,\n            name,\n            input_signature=input_signature,\n            autograph=autograph,\n            experimental_autograph_options=experimental_autograph_options,\n            experimental_relax_shapes=experimental_relax_shapes,\n\n            # TODO(b/171825496): Update once `experimental_compile` is removed\n            # entirely in favor of 'jit_compile'.\n            jit_compile=deprecation.deprecated_argument_lookup(\n                \"jit_compile\",\n                jit_compile,\n                \"experimental_compile\",\n                experimental_compile),\n            experimental_implements=experimental_implements,\n            experimental_follow_type_hints=experimental_follow_type_hints))\n\n  # This code path is for the `foo = tf.function(foo, ...)` use case\n  if func is not None:\n    return decorated(func)\n\n  # This code path is for the\n  #\n  # @tf.function(...)\n  # def foo(...):\n  #    ...\n  #\n  # use case, which is equivalent to `foo = tf.function(...)(foo)`\n  return decorated\n", "# Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\nimport functools\nimport itertools\nimport pickle\nimport re\nimport sys\nimport unittest\nimport weakref\n\nfrom absl.testing import parameterized\nfrom six.moves import range\n\nfrom tensorflow.python.autograph.core import converter\nfrom tensorflow.python.eager import backprop\nfrom tensorflow.python.eager import def_function\nfrom tensorflow.python.eager import lift_to_graph\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import extension_type\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import tensor_spec\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.module import module\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import cond_v2\nfrom tensorflow.python.ops import control_flow_ops\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import random_ops\nfrom tensorflow.python.ops import resource_variable_ops\nfrom tensorflow.python.ops import variable_scope\nfrom tensorflow.python.ops import variables\nfrom tensorflow.python.platform import test\nfrom tensorflow.python.saved_model import save_context\nfrom tensorflow.python.saved_model import save_options\nfrom tensorflow.python.saved_model.load import load\nfrom tensorflow.python.saved_model.save import save\nfrom tensorflow.python.training.tracking.util import Checkpoint\n\n\ndef undecorated_function(x):\n  return x * 3.\n\n\nclass _HasDecoratedMethod(object):\n\n  @def_function.function\n  def f(self, x):\n    return x * 3.\n\n\nclass DefFunctionTest(test.TestCase, parameterized.TestCase):\n\n  def testNoVariables(self):\n\n    @def_function.function\n    def fn(x):\n      return 2 * x\n\n    self.assertAllEqual(fn(constant_op.constant(4.0)), 8.0)\n\n  def testFailIfVariablesAreCreatedMoreThanOnce(self):\n\n    @def_function.function\n    def fn(x):\n      return variables.Variable(1.0) + x\n\n    with self.assertRaises(ValueError):\n      fn(1.0)\n\n  def testFailIfVariablesAreCreatedMoreThanOnceNoWeakRef(self):\n    state = []\n\n    @def_function.function\n    def fn(x):\n      state.append(variables.Variable(1.0))\n      return state[-1] + x\n\n    with self.assertRaises(ValueError):\n      fn(1.0)\n\n  def testRange(self):\n\n    @def_function.function\n    def f(unused_x):\n      return 1.0\n\n    self.assertAllEqual(f(range(5)), 1.0)\n\n  def testCorrectVariableCreation(self):\n\n    state = []\n\n    @def_function.function\n    def fn(x):\n      if not state:\n        state.append(variables.Variable(2.0))\n      return state[0] * x\n\n    self.assertAllEqual(fn(constant_op.constant(1.0)), 2.0)\n    self.assertAllEqual(fn(constant_op.constant(3.0)), 6.0)\n\n  def testFunctionInitializer(self):\n\n    state = []\n\n    @def_function.function\n    def fn(x):\n      if not state:\n        state.append(variables.Variable(lambda: 2.0))\n      return state[0] * x\n\n    self.assertAllEqual(fn(constant_op.constant(1.0)), 2.0)\n\n  def testFunctionMultipleVariableInitializer(self):\n\n    state = []\n\n    @def_function.function\n    def fn(x):\n      if not state:\n        state.append(variables.Variable(lambda: 2.0))\n        state.append(variables.Variable(lambda: 5.0))\n      return state[0] * x, state[1] * x\n\n    self.assertAllEqual(fn(constant_op.constant(1.0)), [2.0, 5.0])\n\n  def testFunctionInitializationFunction(self):\n\n    state = []\n\n    @def_function.function\n    def fn(x):\n      if not state:\n        state.append(variables.Variable(2.0))\n      return state[0] * x\n\n    init_fn = fn.get_initialization_function(constant_op.constant(1.0))\n    self.assertLen(state, 1)\n    self.assertFalse(\n        resource_variable_ops.var_is_initialized_op(state[0].handle))\n    init_fn()\n    self.assertEqual(state[0].numpy(), 2.0)\n\n  def testVariableInitializerNotConstant(self):\n\n    state = []\n\n    @def_function.function\n    def fn(x):\n      if not state:\n        state.append(variables.Variable(2.0 * x))\n      return state[0] * x\n\n    self.assertAllEqual(fn(constant_op.constant(1.0)), 2.0)\n    self.assertAllEqual(fn(constant_op.constant(3.0)), 6.0)\n\n  def testLegacyGraphModeVariables(self):\n    with ops.Graph().as_default(), self.test_session() as sess:\n      state = []\n\n      @def_function.function\n      def fn(x):\n        if not state:\n          state.append(variables.Variable(2.0))\n        return state[0] * x\n\n      result = fn(3.0)\n\n      self.evaluate(variables.global_variables_initializer())\n      self.assertAllEqual(sess.run(state[0]), 2.0)\n      self.assertAllEqual(self.evaluate(result), 6.0)\n\n  def testLegacyGraphModeVariablesNonTrivialInitializer(self):\n    with ops.Graph().as_default(), self.test_session() as sess:\n      state = []\n\n      @def_function.function\n      def fn(x):\n        if not state:\n          two = constant_op.constant(2.0)\n          four = two * two\n          two_again = math_ops.sqrt(four)\n          state.append(variables.Variable(two_again + four))\n        return state[0] * x\n\n      result = fn(3.0)\n\n      self.evaluate(variables.global_variables_initializer())\n      self.assertAllEqual(sess.run(state[0]), 6.0)\n      self.assertAllEqual(self.evaluate(result), 18.0)\n\n  def testLegacyGraphModeInputDependentInitializerFails(self):\n    with ops.Graph().as_default():\n      state = []\n\n      @def_function.function\n      def fn(x):\n        if not state:\n          state.append(variables.Variable(2.0 * x))\n        return state[0] * x\n\n      with self.assertRaisesRegex(lift_to_graph.UnliftableError,\n                                  r'transitively.* mul .* x'):\n        fn(constant_op.constant(3.0))\n\n  def testMethod(self):\n\n    class MyModel(object):\n\n      def __init__(self):\n        self.var = None\n\n      @def_function.function\n      def apply(self, x):\n        if self.var is None:\n          self.var = variables.Variable(2.0)\n        return self.var * x\n\n    m0 = MyModel()\n    self.assertAllEqual(m0.apply(3.0), 6.0)\n    # Calling twice to exercise that we do not recreate variables.\n    m0.var.assign(3.0)\n    self.assertAllEqual(m0.apply(3.0), 9.0)\n\n    m1 = MyModel()\n    self.assertAllEqual(m1.apply(3.0), 6.0)\n\n  @unittest.expectedFailure\n  def testMethodAllowDynamicVariableWithoutGuards(self):\n\n    class Foo:\n\n      def __init__(self):\n        self._var = 0\n\n      def __call__(self, val):\n        self.compute(val)\n        return self._var\n\n      @def_function.function\n      def compute(self, val):\n        self._var = variables.Variable(val)\n\n    def_function.ALLOW_DYNAMIC_VARIABLE_CREATION = True\n    foo = Foo()\n    self.assertAllEqual(foo(0.3), 0.3)\n    self.assertAllEqual(\n        foo(0.9), 0.9, 'https://github.com/tensorflow/tensorflow/issues/27120')\n\n  def testMethodAllowDynamicVariable(self):\n\n    class Foo:\n\n      def __init__(self):\n        self._flag_keyed_vars = {}\n        self.trace_count = 0\n\n      def __call__(self, var_creation_flag):\n        self.compute(var_creation_flag)\n        return self._flag_keyed_vars[var_creation_flag]\n\n      @def_function.function\n      def compute(self, var_creation_flag):\n        self.trace_count += 1\n        if var_creation_flag not in self._flag_keyed_vars:\n          if var_creation_flag:\n            self._flag_keyed_vars[var_creation_flag] = variables.Variable(1.0)\n          else:\n            self._flag_keyed_vars[var_creation_flag] = variables.Variable(2.0)\n\n    def_function.ALLOW_DYNAMIC_VARIABLE_CREATION = True\n    foo = Foo()\n    self.assertAllEqual(foo(True), 1.0)\n    self.assertEqual(foo.trace_count, 2)\n    self.assertAllEqual(foo(True), 1.0)\n    self.assertEqual(foo.trace_count, 2)\n    self.assertAllEqual(foo(False), 2.0)\n    self.assertEqual(foo.trace_count, 3)\n\n  def testMethodNotAllowDynamicVariable(self):\n\n    class Foo:\n\n      def __init__(self):\n        self._flag_keyed_vars = {}\n        self.trace_count = 0\n\n      def __call__(self, var_creation_flag):\n        self.compute(var_creation_flag)\n        return self._flag_keyed_vars[var_creation_flag]\n\n      @def_function.function\n      def compute(self, var_creation_flag):\n        self.trace_count += 1\n        if var_creation_flag not in self._flag_keyed_vars:\n          if var_creation_flag:\n            self._flag_keyed_vars[var_creation_flag] = variables.Variable(1.0)\n          else:\n            self._flag_keyed_vars[var_creation_flag] = variables.Variable(2.0)\n\n    def_function.ALLOW_DYNAMIC_VARIABLE_CREATION = False\n    foo = Foo()\n    self.assertAllEqual(foo(True), 1.0)\n    self.assertEqual(foo.trace_count, 2)\n    self.assertAllEqual(foo(True), 1.0)\n    self.assertEqual(foo.trace_count, 2)\n    msg = 'singleton tf.Variable.*on the first call'\n    with self.assertRaisesRegex(ValueError, msg):\n      foo(False)\n    self.assertEqual(foo.trace_count, 3)\n\n  def testMethodExtensionType(self):\n\n    class MaskedTensor(extension_type.ExtensionType):\n      values: ops.Tensor\n      mask: ops.Tensor\n\n      @def_function.function\n      def with_default(self, default_value):\n        return array_ops.where_v2(self.mask, self.values, default_value)\n\n      @def_function.function\n      def sum(self):\n        # Use a loop & conditional to test that autograph works correctly.\n        result = 0\n        for i in range(array_ops.size(self.values)):\n          if self.mask[i]:\n            result += self.values[i]\n        return result\n\n    mt = MaskedTensor([1, 2, 3], [True, False, True])\n    self.assertAllEqual(mt.with_default(-1), [1, -1, 3])\n    self.assertAllEqual(mt.sum(), 4)\n\n  def test_functools_partial(self):\n    self.assertAllClose(\n        3.,\n        def_function.function(functools.partial(lambda x, y: x + y, 1.))(\n            constant_op.constant(2.)))\n\n  def test_functools_partial_new_default(self):\n    def f(x=3, y=7):\n      return x + y\n\n    func = def_function.function(functools.partial(f, y=6))\n    self.assertEqual(func().numpy(), 9)\n    self.assertEqual(func(y=8).numpy(), 11)\n\n  def test_functools_partial_keywords(self):\n    def f(x, y):\n      return x + y\n\n    func = def_function.function(\n        functools.partial(f, x=array_ops.zeros([1]), y=array_ops.zeros([1])))\n    self.assertAllEqual(func(), [0.0])\n\n  def test_functools_partial_single_positional(self):\n    def f(x, y):\n      return x + y\n\n    func = def_function.function(\n        functools.partial(f, constant_op.constant(1)))\n    self.assertAllEqual(func(5), 6)\n\n  def test_complicated_partial_with_defaults(self):\n\n    def identity(*args):\n      return args\n\n    def dynamic_unroll(core_fn,\n                       input_sequence,\n                       initial_state,\n                       sequence_length=None,\n                       parallel_iterations=1,\n                       swap_memory=False):\n      del core_fn\n      self.assertIs(None, sequence_length)\n      self.assertEqual(1, parallel_iterations)\n      self.assertTrue(swap_memory)\n      return input_sequence, initial_state\n\n    input_sequence = random_ops.random_uniform([1, 1, 1])\n    initial_state = random_ops.random_uniform([1, 1])\n\n    func = def_function.function(\n        functools.partial(dynamic_unroll, identity, swap_memory=True))\n    func(input_sequence, initial_state)\n\n  def test_unspecified_default_argument(self):\n    wrapped = def_function.function(\n        lambda x, y=2: x + y,\n        input_signature=[tensor_spec.TensorSpec((), dtypes.int32)])\n    self.assertEqual(3, wrapped(constant_op.constant(1)).numpy())\n\n  def test_concrete_function_from_signature(self):\n\n    @def_function.function(\n        input_signature=[tensor_spec.TensorSpec(None, dtypes.float32)])\n    def compute(x):\n      return 2. * x\n\n    concrete = compute.get_concrete_function()\n    self.assertAllClose(1., concrete(constant_op.constant(0.5)))\n    concrete = compute.get_concrete_function(\n        tensor_spec.TensorSpec(None, dtypes.float32))\n    self.assertAllClose(4., concrete(constant_op.constant(2.)))\n    signature_args, _ = concrete.structured_input_signature\n    self.assertEqual(signature_args,\n                     (tensor_spec.TensorSpec(\n                         None, dtypes.float32, name='x'),))\n\n  def testInputSignatureMissingTensorSpecsMethod(self):\n\n    class MyModule(module.Module):\n\n      def f1(self, arg1, arg2, arg3):\n        pass\n\n      def f2(self, arg1, arg2, arg3, **kwargs):\n        pass\n\n      def f3(self, arg1, arg2, arg3, arg4=4, **kwargs):\n        pass\n\n      def f4(self, arg1, arg2, arg3, *args):\n        pass\n\n      def f5(self, arg1, arg2, arg3, *args, **kwargs):\n        pass\n\n      def f6(self, arg1, arg4=4, **kwargs):\n        return arg1 + arg4\n\n    m = MyModule()\n    tf_func_dec = def_function.function(\n        input_signature=(tensor_spec.TensorSpec([], dtypes.int32),))\n    error_msg = 'TensorSpecs are still required.*arg2.*arg3'\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(m.f1)(1, 2, 3)\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(m.f2)(1, 2, 3)\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(m.f3)(1, 2, 3)\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(m.f4)(1, 2, 3)\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(m.f5)(1, 2, 3)\n\n    self.assertEqual(tf_func_dec(m.f6)(1).numpy(), 5)\n\n  def testInputSignatureMissingTensorSpecsFunction(self):\n    tf_func_dec = def_function.function(\n        input_signature=(tensor_spec.TensorSpec([], dtypes.int32),))\n    error_msg = 'TensorSpecs are still required.*arg2.*arg3'\n    # pylint: disable=unused-argument\n    def f1(arg1, arg2, arg3):\n      pass\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(f1)(1, 2, 3)\n\n    def f2(arg1, arg2, arg3, **kwargs):\n      pass\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(f2)(1, 2, 3)\n\n    def f3(arg1, arg2, arg3, arg4=4, **kwargs):\n      pass\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(f3)(1, 2, 3)\n\n    def f4(arg1, arg2, arg3, *args):\n      pass\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(f4)(1, 2, 3)\n\n    def f5(arg1, arg2, arg3, *args, **kwargs):\n      pass\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(f5)(1, 2, 3)\n    # pyline: enable=unused-argument\n\n    def f6(arg1, arg4=4, **kwargs):\n      return arg1 + arg4\n    self.assertEqual(tf_func_dec(f6)(1).numpy(), 5)\n\n  def testInputSignatureMissingTensorSpecsLambdaFunction(self):\n    tf_func_dec = def_function.function(\n        input_signature=(tensor_spec.TensorSpec([], dtypes.int32),))\n    error_msg = 'TensorSpecs are still required.*arg2.*arg3'\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(lambda ar1, arg2, arg3: None)(1, 2, 3)\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(lambda arg1, arg2, arg3, **kwargs: None)(1, 2, 3)\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(lambda arg1, arg2, arg3, arg4=4, **kwargs: None)(1, 2, 3)\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(lambda arg1, arg2, arg3, *args: None)(1, 2, 3)\n\n    with self.assertRaisesRegex(TypeError, error_msg):\n      tf_func_dec(lambda arg1, arg2, arg3, *args, **kwargs: None)(1, 2, 3)\n\n    self.assertEqual(\n        tf_func_dec(lambda arg1, arg4=4, **kwargs: arg1 + arg4)(1).numpy(), 5)\n\n  @parameterized.named_parameters(('_method', 'method'),\n                                  ('_function', 'function'),\n                                  ('_lambda_function', 'lambda_function'))\n  def testInputSignaturePartialFuncMissingTensorSpecs(self, func_type):\n    if func_type == 'method':\n      class MyModule(module.Module):\n\n        def f(self, arg1, arg2, arg3, arg4=4):\n          return arg1 + arg2 + arg3 + arg4\n      f = MyModule().f\n    elif func_type == 'function':\n      def f(arg1, arg2, arg3, arg4=4):\n        return arg1 + arg2 + arg3 + arg4\n    else:  # lambda_function\n      f = lambda arg1, arg2, arg3, arg4=4: arg1 + arg2 + arg3 + arg4\n\n    tf_func_dec = def_function.function(\n        input_signature=(tensor_spec.TensorSpec([], dtypes.int32),))\n    with self.assertRaisesRegex(TypeError,\n                                'TensorSpecs are still required.*arg3'):\n      tf_func_dec(functools.partial(f, 1))(2, 3)\n\n    with self.assertRaisesRegex(TypeError,\n                                'TensorSpecs are still required.*arg2.*arg3'):\n      tf_func_dec(functools.partial(f, arg4=5))(1, 2, 3)\n\n    with self.assertRaisesRegex(TypeError,\n                                'TensorSpecs are still required.*arg3'):\n      tf_func_dec(functools.partial(f, 1, arg4=5))(2, 3)\n\n    self.assertAllEqual(tf_func_dec(functools.partial(f, 1, 2, arg4=5))(3),\n                        array_ops.constant(11))\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_variable_naming(self):\n    class HasVars(module.Module):\n\n      def __init__(self):\n        self.x = None\n        self.y = None\n        self.z = None\n\n      @def_function.function\n      def make_x(self):\n        if self.x is None:\n          self.x = variables.Variable(1., name='v')\n\n      def make_y(self):\n        if self.y is None:\n          self.y = variables.Variable(1., name='v')\n\n      def make_z(self):\n        if self.z is None:\n          with ops.name_scope('z_scope', skip_on_eager=False):\n            self.z = variables.Variable(1., name='z')\n\n    root = HasVars()\n    root.make_x()\n    root.make_y()\n    root.make_z()\n    self.assertEqual('v:0', root.x.name)\n    self.assertEqual('z_scope/z:0', root.z.name)\n\n  def test_concrete_function_keyword_arguments(self):\n    @def_function.function\n    def f(x):\n      return x\n\n    conc = f.get_concrete_function(\n        tensor_spec.TensorSpec(None, dtypes.float32, 'y'))\n    conc(y=constant_op.constant(3.0))\n    signature_args, _ = conc.structured_input_signature\n    self.assertEqual('y', signature_args[0].name)\n\n    conc = f.get_concrete_function(tensor_spec.TensorSpec(None, dtypes.float32))\n    conc(x=constant_op.constant(3.0))\n    signature_args, _ = conc.structured_input_signature\n    self.assertEqual('x', signature_args[0].name)\n\n    @def_function.function\n    def g(x):\n      return x[0]\n\n    conc = g.get_concrete_function(\n        [tensor_spec.TensorSpec(None, dtypes.float32, 'z'), 2])\n    conc(z=constant_op.constant(3.0))\n    signature_args, _ = conc.structured_input_signature\n    self.assertEqual('z', signature_args[0][0].name)\n\n  def testRuntimeErrorNotSticky(self):\n\n    @def_function.function\n    def fail(i):\n      control_flow_ops.Assert(math_ops.equal(i, 0), ['ick'])\n\n    fail(constant_op.constant(0))  # OK\n    with self.assertRaises(errors.InvalidArgumentError):\n      fail(constant_op.constant(1))  # InvalidArgument: \"ick\"\n    fail(constant_op.constant(0))  # OK\n\n  def testUnderscoreName(self):\n\n    @def_function.function\n    def f(_):\n      return _ + _\n\n    self.assertAllEqual(2.0, f(constant_op.constant(1.0)))\n\n  def test_serialization_signature_cache(self):\n\n    @def_function.function\n    def f(x, y):\n      return x, y\n\n    f(constant_op.constant([[3., 4.]]), constant_op.constant([2.]))\n    f(constant_op.constant([[3, 4, 5]]), constant_op.constant([2]))\n\n    signatures_args = set()\n    concrete_functions = f._list_all_concrete_functions_for_serialization()\n    for concrete_function in concrete_functions:\n      args, kwargs = concrete_function.structured_input_signature\n      signatures_args.add(args)\n      self.assertEqual(dict(), kwargs)\n\n    self.assertEqual(\n        signatures_args,\n        set(((tensor_spec.TensorSpec([1, 2], dtypes.float32, name='x'),\n              tensor_spec.TensorSpec([1], dtypes.float32, name='y')),\n             (tensor_spec.TensorSpec([1, 3], dtypes.int32, name='x'),\n              tensor_spec.TensorSpec([1], dtypes.int32, name='y')))))\n\n  @test_util.assert_no_garbage_created\n  def testFunctionReferenceCycles(self):\n    fn = def_function.function(lambda x: 2. * x)\n    fn(constant_op.constant(4.0))\n    weak_fn = weakref.ref(fn)\n    del fn\n    # Tests that the weak reference we made to the function is now dead, which\n    # means the object has been deleted. This should be true as long as the\n    # function itself is not involved in a reference cycle.\n    self.assertIs(None, weak_fn())\n\n  @test_util.assert_no_garbage_created\n  def testMethodReferenceCycles(self):\n    has_decorated_method = _HasDecoratedMethod()\n    has_decorated_method.f(constant_op.constant(5.))\n    weak_fn = weakref.ref(has_decorated_method.f)\n    del has_decorated_method\n    # Tests that the weak reference we made to the function is now dead, which\n    # means the object has been deleted. This should be true as long as the\n    # function itself is not involved in a reference cycle.\n    self.assertIs(None, weak_fn())\n\n  @test_util.assert_no_new_pyobjects_executing_eagerly\n  def testErrorMessageWhenGraphTensorIsPassedToEager(self):\n\n    @def_function.function\n    def failing_function():\n      a = constant_op.constant(1.)\n\n      with ops.init_scope():\n        _ = a + a\n\n    with self.assertRaisesRegex(\n        TypeError, re.compile('def_function_test.*out of scope', re.DOTALL)):\n      failing_function()\n\n  def testSymbolicTensorIllegalCaptureCallTimeError(self):\n    x = None\n\n    @def_function.function\n    def f1(a):\n      nonlocal x\n      x = a\n      return a\n\n    @def_function.function\n    def f2(b):\n      return b + x\n\n    f1(constant_op.constant(1))\n    with self.assertRaisesRegex(\n        TypeError, re.compile('def_function_test.*out of scope', re.DOTALL)):\n      f2(constant_op.constant(2))\n\n  def testSymbolicTensorIllegalCaptureTraceTimeError(self):\n\n    @def_function.function\n    def f(inputs):\n      num_steps, _ = inputs.shape[:2]\n      outputs = []\n      for t in math_ops.range(num_steps):\n        outputs.append(inputs[t])\n      return outputs\n\n    with self.assertRaisesRegex(errors.InaccessibleTensorError, 'out of scope'):\n      f(array_ops.zeros(shape=(8, 42, 3)))\n\n  def testNonUniqueNamesGetConcreteFunction(self):\n    @def_function.function\n    def non_unique_arg_names(x, **kwargs):\n      a, b, c = x\n      d = kwargs['d']\n      return a + b + c + d\n\n    concrete = non_unique_arg_names.get_concrete_function(\n        (tensor_spec.TensorSpec(None, dtypes.float32),\n         tensor_spec.TensorSpec(None, dtypes.float32),\n         tensor_spec.TensorSpec(None, dtypes.float32)),\n        d=tensor_spec.TensorSpec(None, dtypes.float32))\n    self.assertAllClose(\n        10.,\n        concrete(x=constant_op.constant(1.),\n                 x_1=constant_op.constant(2.),\n                 x_2=constant_op.constant(3.),\n                 d=constant_op.constant(4.)))\n    self.assertAllClose(\n        10.,\n        concrete(constant_op.constant(1.),\n                 constant_op.constant(2.),\n                 constant_op.constant(3.),\n                 constant_op.constant(4.)))\n\n  def testVariableCreatorScope(self):\n    created_variables = []\n    captured_variables = []\n\n    @def_function.function\n    def f():\n      if not created_variables:\n        created_variables.append(variables.Variable(1.))\n      return created_variables[0] + 1.\n\n    def capture_creator(next_creator, **kwargs):\n      created = next_creator(**kwargs)\n      captured_variables.append(created)\n      return created\n\n    with variable_scope.variable_creator_scope(capture_creator):\n      f()\n    self.assertEqual(created_variables, captured_variables)\n\n  def testVarAlreadyInitializedNoClobbering(self):\n    v_holder = []\n\n    @def_function.function\n    def add_var(x):\n      if not v_holder:\n        v = variables.Variable([1., 2.])\n        v_holder.append(v)\n        already_initialized = variables.Variable(3.)\n        with ops.init_scope():\n          already_initialized.assign(10.)\n        v_holder.append(already_initialized)\n      return v_holder[0] + v_holder[1] + x\n\n    add_var.get_concrete_function(constant_op.constant(2.))\n    self.assertAllClose([13., 14.], add_var(constant_op.constant(2.)))\n\n  def testSameVariableTwice(self):\n    v = variables.Variable(1.0)\n\n    @def_function.function\n    def add(a, b):\n      return a + b\n\n    self.assertAllEqual(add(v, v), 2.0)\n\n  def testVariableUpdate(self):\n    v1 = variables.Variable(1.0)\n    v2 = variables.Variable(2.0)\n    v3 = variables.Variable(4, dtype=dtypes.int32)\n\n    trace_count = [0]\n\n    @def_function.function\n    def double_variable(x):\n      trace_count[0] += 1\n      x.assign_add(x.read_value())\n\n    self.assertEqual(trace_count[0], 0)\n    double_variable(v1)\n    self.assertEqual(trace_count[0], 1)\n    self.assertEqual(self.evaluate(v1), 2.0)\n    double_variable(v2)\n    # No retracing because v2's data type and shape are the same as v1\n    self.assertEqual(trace_count[0], 1)\n    self.assertEqual(self.evaluate(v2), 4.0)\n    double_variable(v3)\n    # Retracing because of data type change\n    self.assertEqual(trace_count[0], 2)\n    self.assertEqual(self.evaluate(v3), 8)\n\n  def testShapeCache(self):\n    @def_function.function\n    def func(x):\n      return 2 * x\n\n    func_a = func.get_concrete_function(\n        tensor_spec.TensorSpec([None], dtypes.int32))\n    func_b = func.get_concrete_function(\n        tensor_spec.TensorSpec([None], dtypes.int32))\n\n    self.assertIs(func_a, func_b)\n\n  def testCacheWithinSaveContext(self):\n\n    @def_function.function\n    def func(x):\n      return 2 * x\n\n    func_a = func.get_concrete_function(constant_op.constant(2.))\n    func_b = func.get_concrete_function(constant_op.constant(2.))\n\n    self.assertIs(func_a, func_b)\n\n    with save_context.save_context(\n        save_options.SaveOptions(experimental_variable_policy=save_options\n                                 .VariablePolicy.EXPAND_DISTRIBUTED_VARIABLES)):\n      func_c = func.get_concrete_function(constant_op.constant(2.))\n\n    with save_context.save_context(\n        save_options.SaveOptions(\n            experimental_variable_policy=save_options.VariablePolicy.NONE)):\n      func_d = func.get_concrete_function(constant_op.constant(2.))\n\n    self.assertIsNot(func_a, func_c)\n    self.assertIsNot(func_a, func_d)\n\n  def testInitializationInNestedCall(self):\n    v_holder = []\n\n    @def_function.function\n    def add_var(x):\n      if not v_holder:\n        v = variables.Variable([1., 2.])\n        v_holder.append(v)\n        already_initialized = variables.Variable(3.)\n        with ops.init_scope():\n          already_initialized.assign(10.)\n        v_holder.append(already_initialized)\n      return v_holder[0] + v_holder[1] + x\n\n    @def_function.function\n    def wrapper(x):\n      return add_var(x)\n\n    self.assertAllClose([13., 14.], wrapper(constant_op.constant(2.)))\n    v_holder[1].assign(11.)\n    self.assertAllClose([14., 15.], wrapper(constant_op.constant(2.)))\n\n  @test_util.run_gpu_only\n  def testDeviceAnnotationRespected(self):\n    a = []\n\n    @def_function.function()\n    def create_variable():\n      with ops.init_scope():\n        initial_value = random_ops.random_uniform(\n            (2, 2), maxval=1000000, dtype=dtypes.int64)\n\n      if not a:\n        with ops.device('CPU:0'):\n          a.append(resource_variable_ops.ResourceVariable(initial_value))\n\n      return a[0].read_value()\n\n    create_variable()\n    self.assertRegex(a[0].device, 'CPU')\n\n  @test_util.run_gpu_only\n  def testDeviceAnnotationForInitializerRespected(self):\n    a = []\n    initial_value = []\n\n    def initial_value_fn():\n      initial_value.append(random_ops.random_uniform((2, 3)))\n      return initial_value[0]\n\n    @def_function.function()\n    def create_variable():\n      with ops.init_scope():\n        if not a:\n          a.append(variables.Variable(initial_value_fn))\n\n    with ops.device('CPU:0'):\n      create_variable()\n    self.assertRegex(a[0].device, 'CPU')\n    self.assertRegex(initial_value[0].device, 'CPU')\n\n  def testDecorate(self):\n    func = def_function.function(lambda: 1)\n    def decorator(f):\n      return lambda: 1 + f()\n\n    func._decorate(decorator)\n    self.assertEqual(func().numpy(), 2)\n\n  @parameterized.parameters(*itertools.product(\n      (None, (tensor_spec.TensorSpec([]),)),  # input_signature\n      (True, False),                          # autograph\n      (None, converter.Feature.ALL),          # autograph_options\n      (None, 'foo.bar'),                      # implements\n      (None, True, False),                    # relax_shapes\n      (True, False),                          # compile\n      (True, False),                          # override_function\n  ))\n\n  def testClone(self, input_signature, autograph, autograph_options, implements,\n                relax_shapes, compile_, override_function):\n    original_py_function = lambda x: x\n\n    compile_ = False\n    func = def_function.function(\n        func=original_py_function,\n        input_signature=input_signature,\n        autograph=autograph,\n        experimental_implements=implements,\n        experimental_autograph_options=autograph_options,\n        experimental_relax_shapes=relax_shapes,\n        jit_compile=compile_)\n\n    if override_function:\n      cloned_py_function = lambda x: x + 1\n    else:\n      cloned_py_function = original_py_function\n\n    cloned = func._clone(python_function=cloned_py_function)\n\n    self.assertEqual(cloned_py_function, cloned._python_function)\n    self.assertEqual(func._name, cloned._name)\n    self.assertEqual(input_signature, cloned._input_signature)\n    self.assertEqual(autograph, cloned._autograph)\n    self.assertEqual(implements, cloned._implements)\n    self.assertEqual(autograph_options, cloned._experimental_autograph_options)\n    self.assertEqual(relax_shapes, cloned._experimental_relax_shapes)\n    self.assertEqual(compile_, cloned._jit_compile)\n\n    # This test does not run with XLA JIT support linked in so we can only check\n    # the output of the function if compile is disabled.\n    if not compile_:\n      x = array_ops.zeros([])\n      self.assertEqual(self.evaluate(cloned(x)),\n                       self.evaluate(cloned_py_function(x)))\n\n  def testLiftPlaceholderInitializedVariable(self):\n    with ops.Graph().as_default():\n      var_list = []\n\n      @def_function.function\n      def use_variable():\n        if not var_list:\n          initial_value = array_ops.placeholder(shape=[], dtype=dtypes.float32)\n          v = variables.Variable(initial_value)\n          var_list.append(v)\n        return var_list[0] + 1.\n\n      var_plus_one = use_variable()\n      with self.session() as session:\n        init_op = var_list[0].initializer\n        session.run(init_op, feed_dict={init_op.inputs[1]: 2.})\n        self.assertEqual(3., session.run(var_plus_one))\n\n  def testDecorate_rejectedAfterTrace(self):\n    func = def_function.function(lambda: 1)\n    self.assertEqual(func().numpy(), 1)\n    msg = 'Functions cannot be decorated after they have been traced.'\n    with self.assertRaisesRegex(ValueError, msg):\n      func._decorate(lambda f: f)\n\n  def testGetConcreteFunctionGraphLifetime(self):\n\n    @def_function.function\n    def func():\n      pass\n\n    graph = func.get_concrete_function().graph\n    del func\n\n    # If the graph is deleted, then an exception is raised on reading `captures`\n    self.assertEmpty(graph.captures)\n\n  @parameterized.parameters(*itertools.product(\n      (None, (tensor_spec.TensorSpec([]),)),  # input_signature\n      (True, False),  # autograph\n      (None, converter.Feature.ALL),  # autograph_options\n      (None, 'foo.bar'),  # implements\n      (None, True, False),  # relax_shapes\n  ))\n\n  def test_pickle(self, input_signature, autograph, autograph_options,\n                  implements, relax_shapes):\n    \"\"\"@function objects can be pickled and unpickled.\"\"\"\n    original_py_function = undecorated_function\n\n    func = def_function.function(\n        func=original_py_function,\n        input_signature=input_signature,\n        autograph=autograph,\n        experimental_implements=implements,\n        experimental_autograph_options=autograph_options,\n        experimental_relax_shapes=relax_shapes,\n    )\n\n    cloned = pickle.loads(pickle.dumps(func))\n\n    self.assertEqual(func._name, cloned._name)\n    self.assertEqual(input_signature, cloned._input_signature)\n    self.assertEqual(autograph, cloned._autograph)\n    self.assertEqual(implements, cloned._implements)\n    self.assertEqual(autograph_options, cloned._experimental_autograph_options)\n    self.assertEqual(relax_shapes, cloned._experimental_relax_shapes)\n\n    x = array_ops.ones([])\n    self.assertEqual(self.evaluate(cloned(x)), self.evaluate(func(x)))\n\n  def test_frequent_retracing_warning(self):\n    if sys.version_info[0] < 3:\n      self.skipTest('self.assertLogs() call is not available in Python 2.')\n\n    @def_function.function\n    def f(x):\n      return x\n\n    with self.assertLogs(level='WARN') as logs:\n      f(1)\n      f(2)\n      f(3)\n      f(4)\n      self.assertEmpty(logs.output)\n      f(5)\n\n    self.assertLen(logs.output, 1)\n    self.assertIn('Tracing is expensive', logs.output[0])\n\n  def test_frequent_retracing_warning_lambda(self):\n    if sys.version_info[0] < 3:\n      self.skipTest('self.assertLogs() call is not available in Python 2.')\n\n    f = def_function.function(lambda x: x)\n\n    with self.assertLogs(level='WARN') as logs:\n      f(1)\n      f(2)\n      f(3)\n      f(4)\n      f(5)\n\n    self.assertLen(logs.output, 1)\n    self.assertIn('Tracing is expensive', logs.output[0])\n\n  def test_frequent_retracing_warning_method(self):\n    if sys.version_info[0] < 3:\n      self.skipTest('self.assertLogs() call is not available in Python 2.')\n\n    class Foo(object):\n\n      @def_function.function\n      def f(self, x):\n        return x\n\n    f = Foo().f\n\n    with self.assertLogs(level='WARN') as logs:\n      f(1)\n      f(2)\n      f(3)\n      f(4)\n      f(5)\n\n    self.assertLen(logs.output, 1)\n    self.assertIn('Tracing is expensive', logs.output[0])\n\n  def test_frequent_retracing_warning_two_independent_tf_functions(self):\n    if sys.version_info[0] < 3:\n      self.skipTest('self.assertLogs() call is not available in Python 2.')\n\n    @def_function.function\n    def f(x):\n      return x\n\n    @def_function.function\n    def g(x):\n      return x\n\n    with self.assertLogs(level='WARN') as logs:\n      f(1)\n      f(2)\n      f(3)\n      f(4)\n      g(1)\n      g(2)\n      g(3)\n      g(4)\n      g(5)\n\n    self.assertLen(logs.output, 1)\n    self.assertIn('Tracing is expensive', logs.output[0])\n\n  def test_frequent_retracing_warning_nested(self):\n    if sys.version_info[0] < 3:\n      self.skipTest('self.assertLogs() call is not available in Python 2.')\n\n    @def_function.function\n    def inner(x):\n      return x + 1\n\n    @def_function.function\n    def outer1(x):\n      return inner(x) * 2\n\n    @def_function.function\n    def outer2(x):\n      return inner(x) * 3\n\n    with self.assertLogs(level='WARN') as logs:\n      inner(1)\n      inner(2)\n      inner(3)\n      inner(4)\n\n      outer1(5)\n      outer1(6)\n      outer1(7)\n      outer1(8)\n\n      outer2(9)\n      outer2(10)\n      outer2(11)\n      outer2(12)\n\n      self.assertEmpty(logs.output)\n\n      outer2(13)\n\n      self.assertLen(logs.output, 1)\n      self.assertIn('Tracing is expensive', logs.output[0])\n\n  def test_frequent_retracing_warning_on_reinstantiation(self):\n    if sys.version_info[0] < 3:\n      self.skipTest('self.assertLogs() call is not available in Python 2.')\n\n    with self.assertLogs(level='WARN') as logs:\n      for i in range(5):\n\n        @def_function.function\n        def f(x):\n          return x\n\n        f(i)\n\n        if i < 4:\n          self.assertEmpty(logs.output)\n\n    self.assertLen(logs.output, 1)\n    self.assertIn('Tracing is expensive', logs.output[0])\n\n  def test_restored_function_retracing_warning(self):\n\n    class Foo(Checkpoint):\n\n      @def_function.function\n      def __call__(self, x):\n        return x\n\n    f_flexible = Foo()\n    _ = f_flexible.__call__.get_concrete_function(\n        tensor_spec.TensorSpec(shape=[None], dtype=dtypes.int32))\n    tmp_dir = self.create_tempdir()\n    save(f_flexible, tmp_dir.full_path)\n    restored_f_flexible = load(tmp_dir.full_path)\n\n    f_fixed_shape = Foo()\n\n    with self.assertLogs(level='WARN') as logs:\n      restored_f_flexible(constant_op.constant([1], dtypes.int32))\n      restored_f_flexible(constant_op.constant([1, 2], dtypes.int32))\n      restored_f_flexible(constant_op.constant([1, 2, 3], dtypes.int32))\n      restored_f_flexible(constant_op.constant([1, 2, 3, 4], dtypes.int32))\n      restored_f_flexible(constant_op.constant([1, 2, 3, 4, 5], dtypes.int32))\n      self.assertEmpty(logs.output)\n\n      f_fixed_shape(constant_op.constant([1], dtypes.int32))\n      f_fixed_shape(constant_op.constant([1, 2], dtypes.int32))\n      f_fixed_shape(constant_op.constant([1, 2, 3], dtypes.int32))\n      f_fixed_shape(constant_op.constant([1, 2, 3, 4], dtypes.int32))\n      f_fixed_shape(constant_op.constant([1, 2, 3, 4, 5], dtypes.int32))\n      self.assertLen(logs.output, 1)\n      self.assertIn('Tracing is expensive', logs.output[0])\n\n  def test_retracing_warning_limits(self):\n\n    @def_function.function\n    def my_func(x):\n      return x\n\n    with self.assertLogs(level='WARN') as logs:\n      for i in range(10):\n        my_func(i)\n\n      self.assertLen(logs.output, 2)\n\n  def test_experimental_get_tracing_count_function(self):\n\n    @def_function.function\n    def double(a):\n      return a + a\n\n    double(constant_op.constant(1))\n    double(constant_op.constant(2))\n    self.assertAllEqual(double.experimental_get_tracing_count(), 1)\n    double(constant_op.constant('a'))\n    self.assertAllEqual(double.experimental_get_tracing_count(), 2)\n\n  def test_experimental_get_tracing_count_method(self):\n\n    class TestClass():\n\n      @def_function.function\n      def testDouble(self, a):\n        return a + a\n\n    obj1 = TestClass()\n    obj1.testDouble(constant_op.constant(1))\n    obj1.testDouble(constant_op.constant(2))\n    obj1.testDouble(constant_op.constant(1.1))\n    self.assertAllEqual(obj1.testDouble.experimental_get_tracing_count(), 2)\n    obj2 = TestClass()\n    obj2.testDouble(constant_op.constant(1))\n    obj2.testDouble(constant_op.constant(1.1))\n    obj2.testDouble(constant_op.constant('a'))\n    self.assertAllEqual(obj2.testDouble.experimental_get_tracing_count(), 3)\n    self.assertAllEqual(obj1.testDouble.experimental_get_tracing_count(), 2)\n\n  def test_recursive_tf_function(self):\n\n    @def_function.function\n    def recursive_fn(n):\n      if n > 0:\n        return recursive_fn(n - 1)\n      return 1\n\n    self.assertEqual(recursive_fn(5).numpy(), 1)\n\n  def test_recursive_tf_function_with_gradients(self):\n\n    @def_function.function\n    def recursive_fn(n, x):\n      if n > 0:\n        return n * recursive_fn(n - 1, x)\n      else:\n        return x\n\n    x = variables.Variable(1.0)\n    with backprop.GradientTape() as tape:\n      g = recursive_fn(5, x)\n\n    dg_dx = tape.gradient(g, x)\n    self.assertEqual(dg_dx.numpy(), 120)\n\n  def test_recursive_python_function(self):\n\n    def recursive_py_fn(n):\n      if n > 0:\n        return recursive_py_fn(n - 1)\n      return 1\n\n    @def_function.function\n    def recursive_fn(n):\n      return recursive_py_fn(n)\n\n    self.assertEqual(recursive_fn(5).numpy(), 1)\n\n  def test_recursive_python_function_with_gradients(self):\n\n    def recursive_py_fn(n, x):\n      if n > 0:\n        return n * recursive_py_fn(n - 1, x)\n      return x\n\n    @def_function.function\n    def recursive_fn(n, x):\n      return recursive_py_fn(n, x)\n\n    x = variables.Variable(1.0)\n    with backprop.GradientTape() as tape:\n      g = recursive_fn(5, x)\n\n    dg_dx = tape.gradient(g, x)\n    self.assertEqual(dg_dx.numpy(), 120)\n\n  def test_recursive_tf_function_call_each_other(self):\n\n    @def_function.function\n    def recursive_fn1(n):\n      if n <= 1:\n        return 1\n      return recursive_fn2(n - 1)\n\n    @def_function.function\n    def recursive_fn2(n):\n      if n <= 1:\n        return 2\n      return recursive_fn1(n - 1)\n\n    self.assertEqual(recursive_fn1(5).numpy(), 1)\n    self.assertEqual(recursive_fn1(6).numpy(), 2)\n    self.assertEqual(recursive_fn2(5).numpy(), 2)\n    self.assertEqual(recursive_fn2(6).numpy(), 1)\n\n  def test_recursive_tf_function_call_each_other_with_gradients(self):\n\n    @def_function.function\n    def recursive_fn1(n, x):\n      if n <= 1:\n        return x\n      return n * recursive_fn2(n - 1, x)\n\n    @def_function.function\n    def recursive_fn2(n, x):\n      if n <= 1:\n        return 2 * x\n      return n * recursive_fn1(n - 1, x)\n\n    x = variables.Variable(1.0)\n    with backprop.GradientTape() as tape:\n      g1 = recursive_fn1(5, x)\n\n    dg1_dx = tape.gradient(g1, x)\n    self.assertEqual(dg1_dx.numpy(), 120)\n\n    with backprop.GradientTape() as tape:\n      g2 = recursive_fn2(5, x)\n\n    dg2_dx = tape.gradient(g2, x)\n    self.assertEqual(dg2_dx.numpy(), 240)\n\n  def test_recursive_tf_function_with_cond(self):\n    @def_function.function(autograph=False)\n    def recursive_fn(n):\n      return cond_v2.cond_v2(n > 0, recursive_fn(n - 1), 1)\n\n    with self.assertRaises(RecursionError):\n      recursive_fn(constant_op.constant(5))\n\n\nif __name__ == '__main__':\n  ops.enable_eager_execution()\n  test.main()\n", "# Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n# pylint: disable=unidiomatic-typecheck\n\"\"\"Defun decorator for defining graph-mode functions.\"\"\"\n\nimport collections\nimport functools\nimport itertools\nimport pprint\nimport threading\nimport types as types_lib\nimport weakref\n\nimport numpy as np\nimport six\nfrom six.moves import map\n\nfrom tensorflow.core.framework import attr_value_pb2\nfrom tensorflow.core.framework import function_pb2\nfrom tensorflow.python import pywrap_tfe\nfrom tensorflow.python.client import pywrap_tf_session\nfrom tensorflow.python.eager import backprop\nfrom tensorflow.python.eager import backprop_util\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.eager import execute\nfrom tensorflow.python.eager import forwardprop_util\nfrom tensorflow.python.eager import function_trace_type\nfrom tensorflow.python.eager import monitoring\nfrom tensorflow.python.eager import tape\nfrom tensorflow.python.eager.graph_only_ops import graph_placeholder\nfrom tensorflow.python.framework import c_api_util\nfrom tensorflow.python.framework import composite_tensor\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import device as pydev\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import error_interpolation\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import func_graph as func_graph_module\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import tensor_shape\nfrom tensorflow.python.framework import tensor_spec\nfrom tensorflow.python.framework import type_spec\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import control_flow_ops\nfrom tensorflow.python.ops import default_gradient\nfrom tensorflow.python.ops import functional_ops\nfrom tensorflow.python.ops import gradients_util\nfrom tensorflow.python.ops import handle_data_util\nfrom tensorflow.python.ops import resource_variable_ops\nfrom tensorflow.python.platform import tf_logging as logging\nfrom tensorflow.python.profiler import trace\nfrom tensorflow.python.saved_model import save_context\nfrom tensorflow.python.types import core\nfrom tensorflow.python.util import _pywrap_utils\nfrom tensorflow.python.util import compat\nfrom tensorflow.python.util import function_utils\nfrom tensorflow.python.util import lazy_loader\nfrom tensorflow.python.util import memory\nfrom tensorflow.python.util import nest\nfrom tensorflow.python.util import object_identity\nfrom tensorflow.python.util import tf_decorator\nfrom tensorflow.python.util import tf_inspect\nfrom tensorflow.python.util.tf_export import tf_export\n\n# Loaded lazily due to a circular dependency (roughly\n# tf.function->autograph->->dataset->tf.function).\n# TODO(b/133251390): Use a regular import.\nag_ctx = lazy_loader.LazyLoader(\n    \"ag_ctx\", globals(),\n    \"tensorflow.python.autograph.core.ag_ctx\")\nnp_arrays = lazy_loader.LazyLoader(\n    \"np_arrays\", globals(),\n    \"tensorflow.python.ops.numpy_ops.np_arrays\")\n\n\nFORWARD_FUNCTION_ATTRIBUTE_NAME = \"forward_function_name\"\nBACKWARD_FUNCTION_ATTRIBUTE_NAME = \"backward_function_name\"\nIMPLEMENTS_ATTRIBUTE_NAME = \"_implements\"\nSHARED_RENDEZVOUS_ATTRIBUTE_NAME = \"shared_rendezvous\"\n# A temporary flag. Turning this on will allow tf.function to aggressively avoid\n# retracing ResourceVariable inputs. This feature will change tf.function's\n# Variable tracing behavior, hence we want to limit the potential blockers that\n# are not detected by Global TAP.\n# TODO(jiaweix): remove this flag and related args (b/198782192)\nENCODE_VARIABLES_BY_RESOURCE_ID = True\n# TODO(b/201533914): Remove this flag and related args\nUSE_FULL_TRACE_TYPE = False\n\n_graph_building_time_counter = monitoring.Counter(\n    \"/tensorflow/core/tf_function/graph_building_time_usecs\",\n    \"Time for tf.function to build a graph (us).\")\n\n\nCacheKey = collections.namedtuple(\"CacheKey\", [\n    \"input_signature\",\n    \"parent_graph\",\n    \"device_functions\",\n    \"colocation_stack\",\n    \"in_cross_replica_context\",\n    \"variable_policy\",\n    \"xla_context_id\",\n])\n\n\ndef _type_spec_for(x):\n  \"\"\"Returns a TypeSpec for `x`, or `None` if `x` doesn't have a TensorSpec.\"\"\"\n  if isinstance(x, ops.Tensor):\n    return tensor_spec.TensorSpec.from_tensor(x)\n  elif isinstance(x, type_spec.TypeSpec):\n    return x\n  elif isinstance(x, composite_tensor.CompositeTensor):\n    return x._type_spec  # pylint: disable=protected-access\n  else:\n    return None\n\n\ndef _is_type_subset(a, b):\n  \"\"\"Returns true if TypeSpec `b` is a subset of type `a` (or if a is None.)\"\"\"\n  if a is None:\n    return True\n  else:\n    return a.most_specific_compatible_type(b) == a\n\n\ndef _shape_relaxed_type_for_composite_tensor(x):\n  \"\"\"Returns a shape-relaxed TypeSpec for x (if composite) or x (if not).\"\"\"\n  if isinstance(x, composite_tensor.CompositeTensor):\n    # pylint: disable=protected-access\n    return x._type_spec._with_tensor_ranks_only()\n  else:\n    return x\n\n\ndef common_shape(x, y):\n  \"\"\"Find a `TensorShape` that is compatible with both `x` and `y`.\"\"\"\n  if x is None != y is None:\n    raise RuntimeError(\n        \"Cannot find a common shape when LHS shape is None but RHS shape \"\n        f\"is not (or vice versa): {x} vs. {y}.\")\n  if x is None:\n    return None  # The associated input was not a Tensor, no shape generated.\n  if not isinstance(x, tensor_shape.TensorShape):\n    raise TypeError(f\"`x` must be a TensorShape, got type {type(x)}.\")\n  if not isinstance(y, tensor_shape.TensorShape):\n    raise TypeError(f\"`y` must be a TensorShape, got type {type(y)}.\")\n  if x.rank != y.rank or x.rank is None:\n    return tensor_shape.TensorShape(None)\n  dims = []\n  for dim_x, dim_y in zip(x.dims, y.dims):\n    if (dim_x != dim_y\n        or tensor_shape.dimension_value(dim_x) is None\n        or tensor_shape.dimension_value(dim_y) is None):\n      dims.append(None)\n    else:\n      dims.append(tensor_shape.dimension_value(dim_x))\n  return tensor_shape.TensorShape(dims)\n\n\ndef is_same_structure(structure1,\n                      structure2,\n                      check_values=False):\n  \"\"\"Check two structures for equality, optionally of types and of values.\"\"\"\n  try:\n    nest.assert_same_structure(structure1, structure2, expand_composites=True)\n  except (ValueError, TypeError):\n    return False\n  if check_values:\n    flattened1 = nest.flatten(structure1, expand_composites=True)\n    flattened2 = nest.flatten(structure2, expand_composites=True)\n    # First check the types to avoid AttributeErrors.\n    if any(type(f1) != type(f2) for f1, f2 in zip(flattened1, flattened2)):\n      return False\n    return flattened1 == flattened2\n  return True\n\n\ndef _parse_func_attrs(attributes):\n  \"\"\"Convert the keyword arguments into function_def attributes.\n\n  Currently only support primitive types: bool, int, float and string.\n\n  Args:\n    attributes: the dictionary of attributes.\n  Returns:\n    A dict of attributes where the key is the name of attribute and the value\n      is the AttrValue proto.\n  Raises:\n    ValueError: If the kwargs contains unallowlisted name or unsupported value\n      types.\n  \"\"\"\n  attrs = {}\n  for key, value in attributes.items():\n    if isinstance(value, attr_value_pb2.AttrValue):\n      attrs[key] = value\n    # bool type check has to happen before int since bool is a subclass of int.\n    elif isinstance(value, bool):\n      attrs[key] = attr_value_pb2.AttrValue(b=value)\n    elif isinstance(value, int):\n      attrs[key] = attr_value_pb2.AttrValue(i=value)\n    elif isinstance(value, float):\n      attrs[key] = attr_value_pb2.AttrValue(f=value)\n    elif isinstance(value, (str, bytes, six.text_type)):\n      attrs[key] = attr_value_pb2.AttrValue(s=compat.as_bytes(value))\n    else:\n      raise ValueError(f\"Attribute {key} must be bool, int, float, string, or \"\n                       f\"AttrValue. Got {type(value)}.\")\n  return attrs\n\n\nclass _InterpolateFunctionError(object):\n  \"\"\"Context Manager that interpolates the exception from 'top_level_func'.\"\"\"\n\n  __slots__ = [\"_func\"]\n\n  def __init__(self, top_level_func):\n    self._func = top_level_func\n\n  def __enter__(self):\n    pass\n\n  def __exit__(self, typ, exc, tb):\n    if not exc or not isinstance(exc, errors.OpError):\n      return False\n    message = compat.as_text(exc.message)\n    _, tags = error_interpolation.parse_message(message)\n    g = None\n    func_stack = []\n    for t in tags:\n      if t.type == \"function_node\":\n        # TODO(mdan): Tests should cover this.\n        if t.name == compat.as_str(self._func.name):\n          g = self._func.graph\n        elif g:\n          next_func = g._get_function(t.name)  # pylint: disable=protected-access\n          if next_func is not None and isinstance(next_func,\n                                                  _EagerDefinedFunction):\n            g = next_func.graph\n        if g:\n          func_stack.append(g.name)\n        else:\n          func_stack.append(\"<unknown>\")\n    if g:\n      message = error_interpolation.interpolate(message, g)\n      if len(func_stack) >= 2:\n        message += \"\\n\\nFunction call stack:\\n\"\n        message += \" -> \".join(func_stack)\n        message += \"\\n\"\n      exc._message = message  # pylint: disable=protected-access\n    return False\n\n\n_function_callbacks = set()\n\n\ndef add_function_callback(function_callback):\n  \"\"\"Add a callback function for Function creation.\n\n  The callback function has the signature:\n\n    `def function_callback(function, name, graph, inputs, outputs):`\n\n  where:\n  - `function`: _EagerDefinedFunction being created before finalizing the graph.\n      Do not modify the function directly but instead modify the graph.\n  - `name`: name of the function.\n  - `graph`: Graph of the function.\n  - `inputs`: `tuple` of tensors used as inputs to the function.\n  - `outputs`: `tuple` of tensors used as outputs from the function.\n\n  The callback is at the top of the `_EagerDefinedFunction` construction, giving\n  callback an opportunity to make the last edits to the graph. Do not make\n  changes to `graph, inputs`, and `outputs` manually, but, instead, set the\n  `graph` as the default then define ops.\n\n  Repeated registration of the same callback function is idempotent.\n  After a callback is added, it can be removed with the\n  `remove_function_callback()` method.\n\n  Args:\n    function_callback: The callback to add.\n  \"\"\"\n  _function_callbacks.add(function_callback)\n\n\ndef remove_function_callback(function_callback):\n  \"\"\"Remove an already-added function callback.\n\n  See the doc string of `add_function_callback()` for more information.\n\n  Args:\n    function_callback: The callback to remove.\n  \"\"\"\n  _function_callbacks.remove(function_callback)\n\n\ndef clear_function_callbacks():\n  \"\"\"Clear all function callbacks, if any have been regisered.\"\"\"\n  _function_callbacks.clear()\n\n\n_FORWARD_PREFIX = \"__forward_\"\n_BACKWARD_PREFIX = \"__backward_\"\n_INFERENCE_PREFIX = \"__inference_\"\n\n\ndef _forward_name(n):\n  \"\"\"The name of a generated forward defun named n.\"\"\"\n  return \"%s%s_%s\" % (_FORWARD_PREFIX, n, ops.uid())\n\n\ndef _backward_name(n):\n  \"\"\"The name of a generated backward defun named n.\"\"\"\n  return \"%s%s_%s\" % (_BACKWARD_PREFIX, n, ops.uid())\n\n\ndef _inference_name(n):\n  \"\"\"The name of a forward-but-no-gradient defun named n.\"\"\"\n  return \"%s%s_%s\" % (_INFERENCE_PREFIX, n, ops.uid())\n\n\ndef _enclosing_xla_context():\n  \"\"\"Returns the XLAControlFlowContext, which exists inside a tpu.rewrite().\"\"\"\n  graph = ops.get_default_graph()\n  while graph is not None:\n    # pylint: disable=protected-access\n    context_ = graph._get_control_flow_context()\n    # pylint: enable=protected-access\n    while context_ is not None:\n      if isinstance(context_, control_flow_ops.XLAControlFlowContext):\n        return context_\n      context_ = context_.outer_context\n    # This may be a FuncGraph due to defuns or v2 control flow. We need to\n    # find the original graph with the XLAControlFlowContext.\n    graph = getattr(graph, \"outer_graph\", None)\n  return None\n\n\nclass _EagerDefinedFunctionDeleter(object):\n  \"\"\"Unregister function from eager context.\"\"\"\n\n  __slots__ = [\"name\"]\n\n  def __init__(self, name):\n    self.name = name\n\n  def __del__(self):\n    try:\n      context.remove_function(self.name)\n    except TypeError:\n      # Suppress some exceptions, mainly for the case when we're running on\n      # module deletion. Things that can go wrong include the context module\n      # already being unloaded, self._handle._handle_data no longer being\n      # valid, and so on. Printing warnings in these cases is silly\n      # (exceptions raised from __del__ are printed as warnings to stderr).\n      pass  # 'NoneType' object is not callable when the handle has been\n      # partially unloaded.\n    except AttributeError:\n      pass  # 'NoneType' object has no attribute 'eager_mode' when context has\n      # been unloaded. Will catch other module unloads as well.\n\n\nclass FunctionAlreadyGarbageCollectedError(Exception):\n\n  def __init__(self, function_name):\n    super(FunctionAlreadyGarbageCollectedError, self).__init__(\n        \"{} has already been garbage collected and cannot be called.\".format(\n            function_name))\n\n\n# TODO(apassos) get rid of this by splitting framework.function._DefinedFunction\n# so it doesn't have the definition-generating logic and is just a container for\n# an already-defined function.\nclass _EagerDefinedFunction(object):\n  \"\"\"Callable with the interface of `framework.function._DefinedFunction`.\n\n  `_EagerDefinedFunction` encapsulates a function definition and its properties,\n  and it provides a method for calling the encapsulated function. Some Ops\n  take functions as attributes, which have type `func`; an instance of this\n  class may be provided as the value of these `func` attributes.\n  \"\"\"\n\n  def __init__(self, name, graph, inputs, outputs, attrs):\n    \"\"\"Initializes an eager defined function.\n\n    Args:\n      name: str, the name for the created function.\n      graph: Graph, the graph containing the operations in the function\n      inputs: the tensors in the graph to be used as inputs to the function\n      outputs: the tensors in the graph which will be outputs from the function\n      attrs: dict mapping names of attributes to their AttrValue values\n    \"\"\"\n    for function_callback in _function_callbacks:\n      function_callback(self, name, graph, tuple(inputs), tuple(outputs))\n\n    input_ops = set(arg.op for arg in inputs)\n    operations = [op for op in graph.get_operations() if op not in input_ops]\n\n    graph_output_names = graph._output_names  # pylint: disable=protected-access\n    if (graph_output_names is not None and\n        all(ops.tensor_id(t) in graph_output_names for t in outputs)):\n      output_names = [\n          compat.as_bytes(graph_output_names[ops.tensor_id(t)]) for t in outputs\n      ]\n      if len(set(output_names)) != len(output_names):\n        # There are duplicate names for some reason, probably an invalid\n        # signature. Revert to auto-naming.\n        output_names = []\n    else:\n      output_names = []\n    fn = pywrap_tf_session.TF_GraphToFunction_wrapper(\n        graph._c_graph,  # pylint: disable=protected-access\n        compat.as_str(name),\n        False,\n        [o._c_op for o in operations],  # pylint: disable=protected-access\n        [t._as_tf_output() for t in inputs],  # pylint: disable=protected-access\n        [t._as_tf_output() for t in outputs],  # pylint: disable=protected-access\n        output_names,\n        [o._c_op for o in graph.control_outputs],  # pylint: disable=protected-access\n        [],  # control_output_names\n        None,\n        compat.as_str(\"\"))\n\n    for name, attr_value in attrs.items():\n      serialized = attr_value.SerializeToString()\n      # TODO(iga): this creates and deletes a new TF_Status for every attr.\n      # It might be worth creating a convenient way to re-use status.\n      pywrap_tf_session.TF_FunctionSetAttrValueProto(fn, compat.as_str(name),\n                                                     serialized)\n\n    # TODO(apassos) avoid creating a FunctionDef (specially to grab the\n    # signature, but also in general it's nice not to depend on it.\n    with c_api_util.tf_buffer() as buffer_:\n      pywrap_tf_session.TF_FunctionToFunctionDef(fn, buffer_)\n      proto_data = pywrap_tf_session.TF_GetBuffer(buffer_)\n    function_def = function_pb2.FunctionDef()\n    function_def.ParseFromString(compat.as_bytes(proto_data))\n    self._name = compat.as_bytes(function_def.signature.name)\n    with ops.init_scope():\n      if context.executing_eagerly():\n        context.ensure_initialized()\n        context.add_function(fn)\n        self._function_deleter = _EagerDefinedFunctionDeleter(self.name)\n        self._registered_on_context = True\n    self.definition = function_def\n    self.signature = function_def.signature\n    self._num_outputs = len(self.signature.output_arg)\n    self._output_types = [o.type for o in self.signature.output_arg]\n    self._output_shapes = [o.shape for o in outputs]\n    self._control_captures = graph.control_captures\n    # Shallow copy outputs since ConcreteFunction may mutate it.\n    self._func_graph_outputs = list(outputs)\n    self.grad_func_name = None\n    self.python_grad_func = None\n    self._c_func = c_api_util.ScopedTFFunction(fn)\n    self._grad_func = None\n    self.graph = graph\n    self._stateful_ops = tuple(op for op in operations if op._is_stateful)  # pylint: disable=protected-access\n\n  def add_to_graph(self, g=None):\n    \"\"\"Add the function to the current context or a graph, if supplied.\n\n    Args:\n      g: the graph to add the function to. If not supplied, the function will\n        be added to the current context.\n    \"\"\"\n    # pylint: disable=protected-access\n    if not g and context.executing_eagerly():\n      ctx = context.context()\n      if not ctx.has_function(self.name):\n        ctx.add_function_def(self.definition)\n    else:\n      if not g._is_function(self.name):\n        g._add_function(self)\n      for f in self.graph._functions.values():\n        if not g._is_function(f.name):\n          g._add_function(f)\n    # pylint: enable=protected-access\n\n  @property\n  def name(self):\n    return self._name\n\n  @property\n  def stateful_ops(self):\n    return self._stateful_ops\n\n  def call(self, ctx, args, cancellation_manager=None):\n    \"\"\"Calls this function with `args` as inputs.\n\n    `ConcreteFunction` execution respects device annotations only if the\n    function won't be compiled with xla.\n\n    Args:\n      ctx: a Context object\n      args: a list of arguments to supply this function with.\n      cancellation_manager: a `CancellationManager` object that can be used to\n        cancel function execution.\n\n    Returns:\n      The outputs of the function call.\n\n    Raises:\n      ValueError: if the number of arguments is incorrect.\n      FunctionAlreadyGarbageCollectedError: if the function is no longer\n        available to be called because it has been garbage collected.\n    \"\"\"\n    if len(args) != len(self.signature.input_arg):\n      raise ValueError(\n          f\"Signature specifies {len(list(self.signature.input_arg))} \"\n          f\"arguments, got: {len(args)}.\")\n\n    # If the `ScopedTFFunction` (accessed via `_c_func`) has already been\n    # cleaned up as a part of garbage collection, this `_EagerDefinedFunction`\n    # should also be garbage and is likely being called as part of a `__del__`\n    # elsewhere. In that case, there's nothing we can do, so we raise an\n    # exception for the caller to handle.\n    if self._c_func.has_been_garbage_collected:\n      raise FunctionAlreadyGarbageCollectedError(self.name)\n\n    function_call_options = ctx.function_call_options\n    if function_call_options.config_proto_serialized is None:\n      config = function_utils.get_disabled_rewriter_config()\n    else:\n      config = function_call_options.config_proto_serialized\n    executor_type = function_call_options.executor_type or \"\"\n\n    executing_eagerly = ctx.executing_eagerly()\n    attrs = (\"executor_type\", executor_type, \"config_proto\", config)\n    if executing_eagerly:\n      with _InterpolateFunctionError(self):\n        if cancellation_manager is None:\n          outputs = execute.execute(\n              str(self.signature.name),\n              num_outputs=self._num_outputs,\n              inputs=args,\n              attrs=attrs,\n              ctx=ctx)\n        else:\n          outputs = execute.execute_with_cancellation(\n              str(self.signature.name),\n              num_outputs=self._num_outputs,\n              inputs=args,\n              attrs=attrs,\n              ctx=ctx,\n              cancellation_manager=cancellation_manager)\n      # Replace empty list with None\n      outputs = outputs or None\n    else:\n      # TODO(akshayka): Either remove this if the FunctionLibraryRuntime\n      # creates `PartitionedCallOp` kernels by default, or remove the previous\n      # branch if a TPU kernel is registered for `PartitionedCall`.\n      with _InterpolateFunctionError(self):\n        with ops.control_dependencies(self._control_captures):\n          # The caller must use record_operation to record this operation in the\n          # eager case, so we enforce the same requirement for the non-eager\n          # case by explicitly pausing recording. We don't have a gradient\n          # registered for PartitionedCall, so recording this operation confuses\n          # forwardprop code (GradientTape manages to ignore it).\n          with tape.stop_recording():\n            outputs = functional_ops.partitioned_call(\n                args=args,\n                f=self,\n                tout=self._output_types,\n                executing_eagerly=executing_eagerly,\n                config=config,\n                executor_type=executor_type)\n\n    for i, func_graph_output in enumerate(self._func_graph_outputs):\n      handle_data_util.copy_handle_data(func_graph_output, outputs[i])\n    if executing_eagerly:\n      return outputs\n    else:\n      # TODO(b/128924522): This additional set_shape should not be\n      # necessary. ShapeRefiner likely needs to inspect handle_data. Remove this\n      # once that's done.\n      for i, shape in enumerate(self._output_shapes):\n        outputs[i].set_shape(shape)\n      return outputs\n\n\ndef _create_forward_backward_with_graph(attrs, forward_graph, backwards_graph):\n  \"\"\"Creates forward and backward functions from the function graphs.\"\"\"\n  forward_function_name = _forward_name(forward_graph.name)\n  common_attributes = dict(attrs)\n  # NB: forward and backward function need to drop \"_implements\".\n  # attribute, because their signature contains all the intermediate tensors\n  # that they compute. Thus they don't have a stable signature which can\n  # be directly optimized downstream.\n  # See for more details:\n  # https://github.com/tensorflow/community/blob/master/rfcs/20190610-standardizing-composite_ops.md#appendix-future-support-for-optimizing-gradient-functions\n  common_attributes.pop(IMPLEMENTS_ATTRIBUTE_NAME, None)\n  backward_function_attr = _parse_func_attrs(\n      {FORWARD_FUNCTION_ATTRIBUTE_NAME: forward_function_name})\n  backward_function_attr.update(common_attributes)\n  backward_function = ConcreteFunction(\n      backwards_graph, attrs=backward_function_attr)\n  forward_function_attr = _parse_func_attrs({\n      BACKWARD_FUNCTION_ATTRIBUTE_NAME:\n      backward_function.name})\n  forward_function_attr.update(common_attributes)\n  forward_function = _EagerDefinedFunction(\n      forward_function_name, forward_graph, forward_graph.inputs,\n      forward_graph.outputs, forward_function_attr)\n  return forward_function, backward_function\n\n\nclass _DelayedRewriteGradientFunctions(object):\n  \"\"\"Caches forward/backward functions with a delayed forward rewrite.\"\"\"\n\n  def __init__(self, func_graph, attrs, func_graph_deleter):\n    \"\"\"Construct an inference function and initialize caches.\"\"\"\n    # A map from the number of forward function outputs with accepted gradients\n    # to forward and backward functions, used to cache non-tape backward\n    # function generation.\n    self._cached_function_pairs = {}\n    self._func_graph = func_graph\n    self._inference_function = _EagerDefinedFunction(\n        _inference_name(self._func_graph.name), self._func_graph,\n        self._func_graph.inputs, self._func_graph.outputs, attrs)\n    self._attrs = attrs\n    self._gradient_name = None\n    # Note that the FuncGraph is mutated later, so we need to inspect it now to\n    # figure out the user-specified outputs of the inference function.\n    self._num_inference_outputs = len(self._func_graph.outputs)\n    self._func_graph_deleter = func_graph_deleter\n\n  def forward_backward(self, num_doutputs=None):\n    \"\"\"A possibly-cached pair of forward and backward functions.\"\"\"\n    if num_doutputs is None:\n      num_doutputs = self._num_inference_outputs\n    forward_backward = self._cached_function_pairs.get(num_doutputs)\n    if forward_backward is not None:\n      return forward_backward\n    forward, backward = self._construct_forward_backward(num_doutputs)\n    self._cached_function_pairs[num_doutputs] = (forward, backward)\n    return forward, backward\n\n  def _construct_forward_backward(self, num_doutputs):\n    \"\"\"Constructs a pair of forward and backward functions.\n\n    Args:\n      num_doutputs: The constructed backprop function will take output gradients\n        for the first `num_doutputs` outputs of the forward function. Defaults\n        to the number of outputs for the inference function, but when\n        higher-order gradients are computed this will increase to include side\n        outputs.\n\n    Returns:\n      A pair of (forward_function, backward_function):\n        forward_function: A re-generated inference function (an\n          _EagerDefinedFunction) to account for new side outputs, if any extra\n          were required when building the backward pass.\n        backward_function: A ConcreteFunction that Takes `num_doutputs`\n          arguments and returns gradients with respect to inputs of the forward\n          function.\n    \"\"\"\n    trainable_outputs = [\n        output for output in self._func_graph.outputs[:num_doutputs]\n        if backprop_util.IsTrainable(output)]\n\n    signature = []\n    for t in trainable_outputs:\n      signature.append(\n          tensor_spec.TensorSpec(*default_gradient.shape_and_dtype(t)))\n\n    def _backprop_function(*grad_ys):\n      with ops.device(None):\n        return gradients_util._GradientsHelper(  # pylint: disable=protected-access\n            trainable_outputs,\n            self._func_graph.inputs,\n            grad_ys=grad_ys,\n            src_graph=self._func_graph)\n\n    with self._func_graph.as_default():\n      backwards_graph = func_graph_module.FuncGraph(\n          _backward_name(self._func_graph.name))\n      func_graph_module.func_graph_from_py_func(\n          name=backwards_graph.name,\n          python_func=_backprop_function,\n          args=[], kwargs={},\n          signature=signature,\n          func_graph=backwards_graph)\n      backwards_graph_captures = backwards_graph.external_captures\n      captures_from_forward = [\n          c for c in backwards_graph_captures if\n          not isinstance(c, ops.EagerTensor) and c.graph is self._func_graph]\n\n      existing_outputs = object_identity.ObjectIdentitySet(\n          self._func_graph.outputs)\n      for capture in captures_from_forward:\n        if capture not in existing_outputs:\n          existing_outputs.add(capture)\n          self._func_graph.outputs.append(capture)\n\n      forward_function, backward_function = _create_forward_backward_with_graph(\n          self._attrs, self._func_graph, backwards_graph)\n      return forward_function, backward_function\n\n  def _rewrite_forward_and_call_backward(self, op, *doutputs):\n    \"\"\"Add outputs to the forward call and feed them to the grad function.\"\"\"\n    forward_function, backwards_function = self.forward_backward(len(doutputs))\n    if not backwards_function.outputs:\n      return backwards_function.structured_outputs\n    forward_function.add_to_graph(op.graph)\n\n    # pylint: disable=protected-access\n    # Rewrite an inference call op to be a forward call op\n    op._set_func_attr(\"f\", forward_function.name)\n    op._set_type_list_attr(\"Tout\", forward_function._output_types)\n    op._add_outputs(\n        forward_function._output_types[len(op.outputs):],\n        forward_function._output_shapes[len(op.outputs):])\n    for i in range(len(op.outputs)):\n      func_graph_output = forward_function._func_graph_outputs[i]\n      handle_data_util.copy_handle_data(func_graph_output, op.outputs[i])\n    # pylint: enable=protected-access\n\n    capture_mapping = dict(\n        zip((ops.tensor_id(t) for t in self._func_graph.outputs), op.outputs))\n    remapped_captures = [\n        capture_mapping.get(ops.tensor_id(capture), capture)\n        for capture in backwards_function.captured_inputs\n    ]\n\n    # Replace Nones with zeros since we're calling a graph function which\n    # expects numeric inputs.\n    cleaned_doutputs = []\n    for doutput, placeholder in zip(doutputs, self._func_graph.outputs):\n      if backprop_util.IsTrainable(placeholder):\n        if isinstance(doutput, ops.IndexedSlices):\n          # Gradient passed to a backward ConcreteFunction must be tf.Tensor,\n          # so we convert tf.IndexedSlices to tf.Tensor.\n          cleaned_doutputs.append(ops.convert_to_tensor(doutput))\n        elif doutput is not None:\n          cleaned_doutputs.append(doutput)\n        else:\n          cleaned_doutputs.append(default_gradient.zeros_like(placeholder))\n\n    # Compute the gradients using the side outputs\n    return backwards_function._call_flat(  # pylint: disable=protected-access\n        cleaned_doutputs, remapped_captures)\n\n  def get_gradient_function(self):\n    \"\"\"Returns gradient function.\n\n    The gradient rewrites an inference call op to a forward call op, but does\n    not modify a pre-existing forward call op. It then computes the gradient\n    from the output's gradients and the side outputs of the forward op.\n    \"\"\"\n    return self._rewrite_forward_and_call_backward\n\n  def forward(self, inference_args=None, input_tangents=None):\n    \"\"\"A forward function with only user-specified outputs.\n\n    The call operation for the returned inference function can be rewritten into\n    a forward function. This only happens if the backward function (from the\n    `backward` method) ends up being used to compute gradients.\n\n    This approach avoids constructing unnecessary graphs, but it only works if\n    we are calling this function when not executing eagerly.\n\n    Args:\n      inference_args: A flat list of Tensors, arguments to the inference\n        function. Unused, but taken for compatibility with\n        _TapeGradientFunctions.\n      input_tangents: A flat list of Tensors, jvps associated with\n        `inference_args`. Unused; if required, tape functions must be used\n        instead.\n\n    Returns:\n      An _EagerDefinedFunction.\n    \"\"\"\n    del inference_args  # unused\n    if input_tangents:\n      # This class does not support special-cased forwardprop. The arguments are\n      # here for compatibility with _TapeGradientFunctions.\n      raise errors.InternalError(\"unexpectedly got forwardprop information in \"\n                                 \"a class that does not support forwardprop.\")\n    return self._inference_function\n\n  def _backward(self, outputs):\n    \"\"\"Fetch a backward function for `outputs` from the forward function.\"\"\"\n    def _backward_function(*args):\n      call_op = outputs[0].op\n      return self._rewrite_forward_and_call_backward(call_op, *args)\n    return _backward_function, outputs\n\n  def record(self, flat_outputs, inference_args, input_tangents):\n    \"\"\"Record the function call operation.\n\n    _DelayedRewriteGradientFunctions supports only first-order backprop tape\n    gradients (and then only when graph building). It does not work with\n    higher-order tape gradients or forward autodiff, but does work with\n    higher-order symbolic gradients (tf.gradients).\n\n    Args:\n      flat_outputs: The result of running `forward`.\n      inference_args: A flat list of Tensors with inference inputs to the\n        operation.\n      input_tangents: A flat list of Tensors with input tangents consumed by the\n        operation.\n    \"\"\"\n    backward_function, to_record = self._backward(flat_outputs)\n    tape.record_operation(self._inference_function.signature.name,\n                          to_record, inference_args + input_tangents,\n                          backward_function)\n\n\n# Contains information about a forward function wrapped to compute jvps.\n_ForwardWrapper = collections.namedtuple(\n    \"_ForwardWrapper\", (\n        # The wrapper Graph.\n        \"graph\",\n        # A flat list of non-tangent Tensor outputs from the wrapped forward\n        # function.\n        \"outputs\",\n        # Indices for output tangents, same format as\n        # forwardprop_util.pack_tangents.\n        \"output_indices\",\n        # A flat list of tangents for `outputs`.\n        \"output_tangents\"))\n\n\nclass _TapeGradientFunctions(object):\n  \"\"\"Caches forward and backward functions compatible with eager gradients.\n\n  In contrast to the delayed-rewrite approach in\n  `_DelayedRewriteGradientFunctions` which only works with delayed execution,\n  the forward function generated by this class has a fixed set of outputs which\n  may be preserved by a tape in order to compute gradients later.\n\n  This class is abstract; its child classes differ in how many side outputs of\n  the forward function their backward function accepts gradients for, which\n  determines whether higher-order tape gradients are possible.\n  \"\"\"\n\n  def __init__(self, func_graph, attrs, func_graph_deleter,\n               forwardprop_input_indices, delayed_rewrite_functions,\n               need_gradients_for_jvps):\n    self._func_graph = func_graph\n    self._forward_graph = None\n    self._attrs = attrs\n    self._forward = None\n    self._backward = None\n    self._num_outputs = len(func_graph.outputs)\n    self._func_graph_deleter = func_graph_deleter\n    self._forwardprop_input_indices = forwardprop_input_indices\n    self._forwardprop_output_indices = None\n    self._num_forwardprop_outputs = 0\n    self._num_inference_outputs = len(func_graph.outputs)\n    self._num_trainable_inference_outputs = len(\n        [t for t in func_graph.outputs if backprop_util.IsTrainable(t)])\n    self._delayed_rewrite_functions = delayed_rewrite_functions\n    self._need_gradients_for_jvps = need_gradients_for_jvps\n\n  def _build_functions_for_outputs(\n      self, outputs, inference_args, input_tangents):\n    \"\"\"Forward+backward functions where the backward function sees `outputs`.\"\"\"\n    # First figure out which of `outputs` are trainable. We'll accept gradients\n    # for each of these in the backward function.\n    handles_to_variables = self._func_graph.variable_captures\n    trainable_outputs = []\n    trainable_indices = []\n    for index, output in enumerate(outputs):\n\n      if backprop_util.IsTrainable(output):\n        # Swap in the Variable object for resource handles if we can so\n        # sparse gradients work.\n        output = handles_to_variables.get(id(output), output)\n        trainable_outputs.append(output)\n        trainable_indices.append(index)\n\n    backwards_graph = func_graph_module.FuncGraph(\n        _backward_name(self._func_graph.name))\n    with backwards_graph.as_default():\n      gradients_wrt_outputs = []\n      for output in trainable_outputs:\n        gradient_shape, gradient_dtype = default_gradient.shape_and_dtype(\n            output)\n        gradient_placeholder = graph_placeholder(gradient_dtype, gradient_shape)\n        handle_data_util.copy_handle_data(output, gradient_placeholder)\n        gradients_wrt_outputs.append(gradient_placeholder)\n      with ops.device(None):\n        gradients_wrt_inputs = gradients_util._GradientsHelper(  # pylint: disable=protected-access\n            trainable_outputs,\n            self._func_graph.inputs,\n            grad_ys=gradients_wrt_outputs,\n            src_graph=self._func_graph)\n\n      if input_tangents:\n        # Convert IndexedSlices to dense tensors (as we do elsewhere for\n        # function gradients). Our C++ bindings don't know how to handle them\n        # currently.\n        gradients_wrt_inputs = nest.map_structure(\n            lambda x: ops.convert_to_tensor(x) if x is not None else None,\n            gradients_wrt_inputs)\n      captures_from_forward = [\n          c for c in backwards_graph.external_captures\n          if not isinstance(c, ops.EagerTensor) and c.graph is self._func_graph\n      ]\n      existing_outputs = object_identity.ObjectIdentitySet(\n          self._func_graph.outputs)\n      for capture in captures_from_forward:\n        if capture not in existing_outputs:\n          existing_outputs.add(capture)\n          self._func_graph.outputs.append(capture)\n\n    # The ordering of `backwards_graph.inputs` is important: inputs of\n    # `backward_function` correspond to outputs (including\n    # side outputs) of `self._tape_forward_function`.\n    backwards_graph.inputs = (\n        gradients_wrt_outputs + backwards_graph.internal_captures)\n    backwards_graph.outputs.extend(\n        grad\n        for grad in nest.flatten(gradients_wrt_inputs, expand_composites=True)\n        if grad is not None)\n    backwards_graph.structured_outputs = gradients_wrt_inputs\n\n    forward_function, backward_function = _create_forward_backward_with_graph(\n        self._attrs, self._func_graph, backwards_graph)\n\n    if not input_tangents:\n      # There is no need to special-case forwardprop, so we can return the\n      # forward+backward pair we've created without further wrapping.\n      return (forward_function, self._func_graph, backward_function,\n              # No forwardprop outputs.\n              None, 0)\n    forward_wrapper = self._wrap_forward_function_with_jvps(\n        forward_function, backward_function, inference_args, input_tangents)\n    (wrapped_backwards_graph,\n     forward_wrapper) = self._wrap_backward_function_with_jvp_backprop(\n         backward_function, gradients_wrt_outputs, forward_wrapper)\n    # Now that we've added new captures, we need to make sure forward outputs\n    # are in the same order the backward function expects them to be in:\n    # [inference outputs] + [jvps] + [side outputs] + [captures].\n    forward_wrapper = self._shuffle_forward_outputs(forward_wrapper)\n    (wrapped_forward_function,\n     wrapped_backward_function) = _create_forward_backward_with_graph(\n         self._attrs, forward_wrapper.graph, wrapped_backwards_graph)\n    if (len(inference_args) + len(input_tangents)\n        != len(forward_wrapper.graph.inputs)):\n      raise errors.InternalError(\n          f\"The forward graph had {len(forward_wrapper.graph.inputs)} inputs, \"\n          f\"but we expected {len(inference_args) + len(input_tangents)} \"\n          f\"({len(inference_args)} inference inputs and \"\n          f\"{len(input_tangents)} input tangents).\")\n    return (wrapped_forward_function, forward_wrapper.graph,\n            wrapped_backward_function, forward_wrapper.output_indices,\n            len(forward_wrapper.output_tangents))\n\n  def _wrap_forward_function_with_jvps(\n      self, forward_function, backward_function,\n      inference_args, input_tangents):\n    \"\"\"Adds inline JVP computation to a forward function.\"\"\"\n    forward_wrapper_graph = func_graph_module.FuncGraph(\n        _forward_name(self._func_graph.name))\n    with forward_wrapper_graph.as_default():\n      # Tell forward accumulators to free up space for new JVP computations,\n      # since one may be in the process of computing a JVP (if that computation\n      # triggered this function building).\n      #\n      # We'll make symbolic versions of input JVPs, run the forward function\n      # under forward accumulators to get symbolic output JVPs, then set those\n      # as outputs of the new wrapped forward function.\n      with forwardprop_util.push_forwardprop_state():\n        forward_captures = {\n            ops.tensor_id(internal): external\n            for external, internal in self._func_graph.captures}\n        for input_index, real_input in enumerate(self._func_graph.inputs):\n          # This loop is more or less equivalent to running tf.identity on each\n          # of self._func_graph.inputs. However, doing that also captures jvps\n          # for resource handles, which confuses the jvp capturing code below\n          # (since primal inputs are interwoven with jvp inputs).\n          input_placeholder = array_ops.placeholder(\n              dtype=real_input.dtype,\n              shape=real_input.shape)\n          capture = forward_captures.get(ops.tensor_id(real_input))\n          if capture is not None:\n            forward_wrapper_graph.add_capture(capture, input_placeholder)\n            if capture.dtype == dtypes.resource:\n              handle_data_util.copy_handle_data(capture, input_placeholder)\n          else:\n            forward_wrapper_graph.inputs.append(input_placeholder)\n        for inp, arg in zip(forward_wrapper_graph.inputs, inference_args):\n          tape.record_operation(\n              \"captured_value\", [inp], [arg],\n              backward_function=lambda x: [x],\n              forward_function=lambda x: [x])\n        num_inference_inputs = len(inference_args)\n        for tape_indices in self._forwardprop_input_indices:\n          for input_index, jvp_index in tape_indices:\n            input_placeholder = forward_wrapper_graph.inputs[input_index]\n            if len(forward_wrapper_graph.inputs) != jvp_index:\n              raise errors.InternalError(\n                  f\"Expected {jvp_index} forward graph inputs, \"\n                  f\"got {len(forward_wrapper_graph.inputs)}.\")\n            gradient_shape, gradient_dtype = default_gradient.shape_and_dtype(\n                input_placeholder)\n            jvp_placeholder = graph_placeholder(gradient_dtype, gradient_shape)\n            external_jvp = input_tangents[jvp_index - num_inference_inputs]\n            forward_wrapper_graph.add_capture(external_jvp, jvp_placeholder)\n            tensor_shape.TensorShape(\n                external_jvp.shape).assert_is_compatible_with(\n                    jvp_placeholder.shape)\n            tape.record_operation(\n                \"captured_value\",\n                [jvp_placeholder],\n                [external_jvp],\n                backward_function=lambda x: [x],\n                forward_function=lambda x: [x])\n        forward_inputs = forward_wrapper_graph.inputs[:num_inference_inputs]\n        gradient_function = (\n            self._delayed_rewrite_functions._rewrite_forward_and_call_backward)  # pylint: disable=protected-access\n        with ops.get_default_graph()._override_gradient_function(  # pylint: disable=protected-access\n            {\"PartitionedCall\": gradient_function,\n             \"StatefulPartitionedCall\": gradient_function}):\n          forward_outputs = forward_function.call(context.context(),\n                                                  forward_inputs)\n          if isinstance(forward_outputs, ops.Operation):\n            # _wrapped_backward_function expects a list, but if the function has\n            # no outputs its call() returns an Operation. We need to undo that\n            # so we don't cause problems later.\n            forward_outputs = []\n        py_backward, _ = self._wrap_backward_function(\n            self._func_graph, backward_function, forward_outputs)\n      # We will never request backward tape gradients for this operation\n      # directly since we're wrapping the call; forwardprop will call the\n      # backward function (and nested forward accumulators may build\n      # higher-order gradients), but any watching GradientTapes should ignore\n      # it.\n      #\n      # TODO(allenl): It might be better to explicitly stop backward recording\n      # so we don't use the second-order tape cases unnecessarily.\n      tape.record_operation_forwardprop_only(\n          forward_function.signature.name,\n          forward_outputs, forward_inputs, py_backward, None)\n      output_indices, output_tangents = (\n          pywrap_tfe.TFE_Py_PackJVPs(forward_outputs))\n      output_tangents = [forward_wrapper_graph.capture(t)\n                         for t in output_tangents]\n    return _ForwardWrapper(\n        graph=forward_wrapper_graph, outputs=forward_outputs,\n        output_indices=output_indices, output_tangents=output_tangents)\n\n  def _wrap_backward_function_with_jvp_backprop(\n      self, backward_function, gradients_wrt_outputs, forward_wrapper):\n    \"\"\"Wraps `backward_function` to include gradients for JVPs.\"\"\"\n    wrapped_backwards_graph = func_graph_module.FuncGraph(\n        _backward_name(self._func_graph.name))\n    with wrapped_backwards_graph.as_default():\n      py_backward, recorded_outputs = self._wrap_backward_function(\n          self._func_graph, backward_function, forward_wrapper.outputs)\n      trainable_index = 0\n      forward_doutputs = []\n      doutput_args = []\n      for output in recorded_outputs:\n        if backprop_util.IsTrainable(output):\n          doutput = gradients_wrt_outputs[trainable_index]\n          doutput_placeholder = graph_placeholder(doutput.dtype, doutput.shape)\n          doutput_args.append(doutput_placeholder)\n          forward_doutputs.append(doutput_placeholder)\n          trainable_index += 1\n        else:\n          doutput_args.append(None)\n\n      dinputs = py_backward(*doutput_args)\n      existing_outputs = object_identity.ObjectIdentitySet(\n          forward_wrapper.outputs + forward_wrapper.output_tangents)\n      num_processed_output_tangents = 0\n      gradients_wrt_output_tangents = []\n      tangent_doutputs = []\n      output_tangents = forward_wrapper.output_tangents\n      output_indices = forward_wrapper.output_indices\n      if self._need_gradients_for_jvps:\n        # TODO(allenl): Consider using a throwaway graph to avoid extra gradient\n        # evaluations; gradients for jvps may have common subgraphs.\n        while num_processed_output_tangents != len(output_tangents):\n          for output in output_tangents[num_processed_output_tangents:]:\n            gradient_shape, gradient_dtype = default_gradient.shape_and_dtype(\n                output)\n            placeholder = graph_placeholder(gradient_dtype, gradient_shape)\n            gradients_wrt_output_tangents.append(placeholder)\n            tangent_doutputs.append(placeholder)\n          num_processed_output_tangents = len(output_tangents)\n          with ops.device(None):\n            gradients_wrt_inputs = gradients_util._GradientsHelper(  # pylint: disable=protected-access\n                output_tangents,\n                forward_wrapper.graph.inputs,\n                grad_ys=gradients_wrt_output_tangents,\n                src_graph=forward_wrapper.graph)\n          dinputs = [\n              backprop.aggregate_indexed_slices_gradients((existing, new))\n              for existing, new in zip(dinputs, gradients_wrt_inputs)\n              if existing is not None or new is not None]\n          dinputs.extend(gradients_wrt_inputs[len(dinputs):])\n          captures_from_forward = [\n              c for c in wrapped_backwards_graph.external_captures\n              if (not isinstance(c, ops.EagerTensor)\n                  and c.graph is forward_wrapper.graph)]\n          for capture in captures_from_forward:\n            if capture not in existing_outputs:\n              existing_outputs.add(capture)\n              forward_wrapper.outputs.append(capture)\n          output_indices, output_tangents = (\n              forwardprop_util.pack_tangents(forward_wrapper.outputs))\n          output_tangents = [forward_wrapper.graph.capture(t)\n                             for t in output_tangents]\n          for t in output_tangents:\n            existing_outputs.add(t)\n    wrapped_backwards_graph.inputs = (\n        forward_doutputs[:self._num_trainable_inference_outputs]\n        + tangent_doutputs\n        + forward_doutputs[self._num_trainable_inference_outputs:]\n        + wrapped_backwards_graph.internal_captures)\n    wrapped_backwards_graph.structured_outputs = dinputs\n    wrapped_backwards_graph.outputs = [t for t in dinputs if t is not None]\n    return (wrapped_backwards_graph,\n            forward_wrapper._replace(output_indices=output_indices,\n                                     output_tangents=output_tangents))\n\n  def _shuffle_forward_outputs(self, forward_wrapper):\n    \"\"\"Reorders function outputs so captures are last.\"\"\"\n    def _index_map(original):\n      if original < self._num_inference_outputs:\n        return original\n      if original >= len(forward_wrapper.outputs):\n        return (original - len(forward_wrapper.outputs)\n                + self._num_inference_outputs)\n      return original + len(forward_wrapper.output_tangents)\n    output_indices = nest.map_structure(\n        _index_map, forward_wrapper.output_indices)\n    forward_wrapper.graph.outputs = (\n        forward_wrapper.outputs[:self._num_inference_outputs]\n        + forward_wrapper.output_tangents\n        + forward_wrapper.outputs[self._num_inference_outputs:])\n    return forward_wrapper._replace(output_indices=output_indices)\n\n  def forward(self, inference_args, input_tangents):\n    \"\"\"Construct or fetch a forward function with side-outputs.\n\n    When graph building without a tape active, symbolic gradients rely on\n    regenerating the backward function for higher-order gradients (to account\n    for new side outputs of the rewritten forward function call). Thus there is\n    no fixed backward function for this case. However, when a tape is active\n    (eager or graph building), we generate fixed backward and forward functions\n    at forward function call time.\n\n    This difference between the tape and non-tape cases is to avoid building\n    unneeded backward functions while graph building (where we may or may not\n    eventually need gradients).\n\n    Args:\n      inference_args: A flat list of Tensors, arguments to the inference\n        function.\n      input_tangents: A flat list of Tensors, jvps associated with\n        `inference_args`.\n\n    Returns:\n      A forward _EagerDefinedFunction.\n    \"\"\"\n    if self._forward is None:\n      (self._forward, self._forward_graph, self._backward,\n       self._forwardprop_output_indices, self._num_forwardprop_outputs) = (\n           self._forward_and_backward_functions(inference_args, input_tangents))\n    return self._forward\n\n  def _wrap_backward_function(self, forward_graph, backward, outputs):\n    \"\"\"Create a backward function given `outputs` from the forward function.\"\"\"\n    capture_mapping = dict(\n        zip((ops.tensor_id(t) for t in forward_graph.outputs), outputs))\n    captured_inputs = backward.captured_inputs\n    remapped_captures = [\n        capture_mapping.get(ops.tensor_id(capture), capture)\n        for capture in captured_inputs\n    ]\n    if any(t.graph is forward_graph for t in remapped_captures\n           if not isinstance(t, ops.EagerTensor)):\n      incorrect_mapping = [t for t in remapped_captures\n                           if (not isinstance(t, ops.EagerTensor) and\n                               t.graph is not forward_graph)]\n      raise errors.InternalError(\"Failed to map all backward graph captures to \"\n                                 \"the forward graph. Incorrectly mapped: \"\n                                 f\"{incorrect_mapping}.\")\n    # We may need to use zeros_like to get a zero for variant Tensors with\n    # unconnected gradients. We do that in advance so we don't have to hold on\n    # to the outputs themselves, which may not be needed otherwise.\n    variant_zeros_like = {}\n    backward_function_inputs = (len(backward.inputs) - len(captured_inputs))\n    recorded_outputs = []\n    trainable_recorded_outputs = 0\n    skip_positions = []\n    if self._num_forwardprop_outputs and not self._need_gradients_for_jvps:\n      relevant_outputs = (\n          outputs[:self._num_inference_outputs]\n          + outputs[self._num_inference_outputs\n                    + self._num_forwardprop_outputs:])\n    else:\n      relevant_outputs = outputs\n    for output_index, output in enumerate(relevant_outputs):\n      if trainable_recorded_outputs < backward_function_inputs:\n        recorded_outputs.append(output)\n      if backprop_util.IsTrainable(output):\n        trainable_recorded_outputs += 1\n      else:\n        skip_positions.append(output_index)\n      if output.dtype == dtypes.variant:\n        variant_zeros_like[output_index] = default_gradient.zeros_like(output)\n\n    def _backward_function_wrapper(*args):\n      \"\"\"Process output gradients and call the backward function.\"\"\"\n      if not backward.outputs:\n        return backward.structured_outputs\n\n      processed_args = []\n      input_index = 0\n      for output_index, arg in enumerate(args):\n        # Convert IndexedSlices to dense tensors. The IndexedSlices optimization\n        # is only really effective when doing tf.gather(variable) as the\n        # adjoint functions for most operations are unlikely to preserve the\n        # sparsity in IndexedSlices.\n        if isinstance(arg, ops.IndexedSlices):\n          arg = ops.convert_to_tensor(arg)\n        if output_index in skip_positions:\n          continue\n        if arg is None:\n          # We're calling a (non-polymorphic) ConcreteFunction, so we need to\n          # have a Tensor value for each Tensor we thought would be trainable\n          # based on its dtype, even if it ended up being unconnected.\n          input_placeholder = backward.inputs[\n              input_index]\n          if input_placeholder.dtype == dtypes.variant:\n            arg = variant_zeros_like[output_index]\n          else:\n            arg = array_ops.zeros(\n                *default_gradient.shape_and_dtype(input_placeholder))\n        processed_args.append(arg)\n        input_index += 1\n        if input_index >= backward_function_inputs:\n          break\n      return backward._call_flat(  # pylint: disable=protected-access\n          processed_args, remapped_captures)\n\n    return _backward_function_wrapper, recorded_outputs\n\n  def record(self, flat_outputs, inference_args, input_tangents):\n    \"\"\"Record the function call operation.\n\n    For backprop, indicates the backward function to use and which new Tensors\n    must be watched. For forwardprop from eager, the function call itself will\n    have produced tangents which need to be recorded.\n\n    Args:\n      flat_outputs: The result of running `forward`.\n      inference_args: A flat list of Tensors with inference inputs to the\n        operation.\n      input_tangents: A flat list of Tensors with input tangents consumed by the\n        operation.\n    \"\"\"\n    backward_function, to_record = self._wrap_backward_function(\n        self._forward_graph, self._backward, flat_outputs)\n    if self._forwardprop_output_indices:\n      tape.record_operation_backprop_only(\n          self._forward.signature.name,\n          to_record, inference_args,\n          backward_function)\n      tape.record_operation_forwardprop_only(\n          self._forward.signature.name,\n          flat_outputs, inference_args + input_tangents,\n          backward_function,\n          self._forwardprop_output_indices)\n    else:\n      tape.record_operation(self._forward.signature.name,\n                            to_record, inference_args + input_tangents,\n                            backward_function)\n\n\nclass _FirstOrderTapeGradientFunctions(_TapeGradientFunctions):\n  \"\"\"Caches tape-friendly functions for first-order gradients.\"\"\"\n\n  def __init__(self, func_graph, attrs, func_graph_deleter,\n               forwardprop_input_indices, delayed_rewrite_functions,\n               need_gradients_for_jvps):\n    super(_FirstOrderTapeGradientFunctions, self).__init__(\n        func_graph, attrs, func_graph_deleter, forwardprop_input_indices,\n        delayed_rewrite_functions, need_gradients_for_jvps)\n    self._func_graph_deleter = func_graph_deleter\n    self._forwardprop_input_indices = forwardprop_input_indices\n\n  def _forward_and_backward_functions(self, inference_args, input_tangents):\n    \"\"\"Shortcut for when only first-order gradients are required.\n\n    The returned backward function does not accept gradients with respect to\n    side output of forward_function. This is fine as long as the user can't\n    possibly request second order tape gradients, as when they've used a single\n    non-persistent GradientTape. Since we don't need the backward function to\n    take gradients with respect to side outputs, we can skip some potentially\n    slow graph building.\n\n    Args:\n      inference_args: A flat list of Tensors, arguments to the inference\n        function.\n      input_tangents: A flat list of Tensors, jvps associated with\n        `inference_args`.\n\n    Returns:\n      A tuple of (forward_function, backward_function):\n        forward_function: Takes the same inputs as the inference function, but\n          returns side outputs used by backward_function in addition to the\n          inference function's outputs.\n        backward_function: Takes side outputs from forward_function and\n          gradients with respect to the \"real\" outputs of forward_function and\n          returns gradients with respect to the inputs.\n    \"\"\"\n    outputs = self._func_graph.outputs[:self._num_inference_outputs]\n    return self._build_functions_for_outputs(\n        outputs, inference_args, input_tangents)\n\n\nclass _HigherOrderTapeGradientFunctions(_TapeGradientFunctions):\n  \"\"\"Caches tape-friendly functions for higher-order gradients.\"\"\"\n\n  # TODO(b/136189779): Cond/while under a tape may need similar logic. Consider\n  # generalizing if so.\n  def _forward_and_backward_functions(self, inference_args, input_tangents):\n    \"\"\"Forward and backward functions suitable for higher-order gradients.\n\n    Unlike in `_FirstOrderTapeGradientFunctions`, the backward function built by\n    this method accepts gradients for all of the outputs of the returned forward\n    function, including side outputs.\n\n    Args:\n      inference_args: A flat list of Tensors, arguments to the inference\n        function.\n      input_tangents: A flat list of Tensors, jvps associated with\n        `inference_args`.\n\n    Returns:\n      A tuple of (forward_function, backward_function):\n        forward_function: Takes the same inputs as the inference function, but\n          returns side outputs used by backward_function in addition to the\n          inference function's outputs.\n        backward_function: Takes side outputs from forward_function and\n          gradients with respect to all of its outputs, real and side. Returns\n          gradients with respect to the inputs.\n    \"\"\"\n    outputs = []\n    iteration_count = 0\n    # First we need to figure out how many side outputs from the forward pass\n    # will be required. We do this in a temporary graph to avoid actually\n    # running multiple copies of the backward pass (one per _GradientsHelper\n    # call).\n    #\n    # While computing gradients, the backward function captures Tensors from\n    # the forward function. We add these as side outputs of the original\n    # function. However, we then need to accept output gradients with respect\n    # to these side outputs for higher order gradients to work. Thus we loop\n    # until the number of outputs of the function stabilizes. Note that this\n    # is only required for tape gradients, where we need to declare in advance\n    # all of the forward op's outputs: symbolic gradients with tf.gradients\n    # instead rely on regenerating backward functions when higher-order\n    # gradients are requested.\n    while (len(outputs) < len(self._func_graph.outputs)\n           # It's possible for gradient generation to add new ops to the forward\n           # pass. If all of the new outputs are non-trainable, there's no\n           # reason to continue.\n           and any(backprop_util.IsTrainable(output)\n                   for output in self._func_graph.outputs[len(outputs):])):\n      iteration_count += 1\n      if iteration_count >= 20 and iteration_count % 5 == 0:\n        new_op_with_trainable_output = None\n        num_new_trainable_outputs = 0\n        for output in self._func_graph.outputs[len(outputs):]:\n          if backprop_util.IsTrainable(output):\n            num_new_trainable_outputs += 1\n            new_op_with_trainable_output = output.op\n        logging.warning(\n            (\"Determining side outputs for the function '{}' is taking longer \"\n             \"than expected ({} iterations, typically this converges in 5 or \"\n             \"so). This could indicate that a gradient registration is adding \"\n             \"new ops to the forward pass every time gradients are generated. \"\n             \"{} new trainable output(s) were added this iteration, one from \"\n             \"the following op:\\n {}\\nThis may indicate a TensorFlow bug, or \"\n             \"an issue in a tf.custom_gradient.\")\n            .format(\n                self._func_graph.name, iteration_count,\n                num_new_trainable_outputs, new_op_with_trainable_output))\n      outputs = list(self._func_graph.outputs)\n      self._build_functions_for_outputs(\n          outputs, inference_args, input_tangents)\n\n    (forward_function, forward_graph,\n     backward_function, output_indices, num_output_tangents) = (\n         self._build_functions_for_outputs(\n             outputs, inference_args, input_tangents))\n    if (len(self._func_graph.outputs) > len(outputs)\n        and any(backprop_util.IsTrainable(output)\n                for output in self._func_graph.outputs[len(outputs):])):\n      raise errors.InternalError(\n          \"Unexpectedly added new outputs to the forward function when \"\n          \"building the backward function: \"\n          f\"{self._func_graph.outputs[len(outputs):]}.\")\n    return (forward_function, forward_graph, backward_function, output_indices,\n            num_output_tangents)\n\n\nclass _ForwardBackwardCall(object):\n  \"\"\"Holds the state of a function call between execution and recording.\"\"\"\n\n  __slots__ = [\n      \"_functions\", \"_inference_args\", \"_input_tangents\", \"_tape_watching\"\n  ]\n\n  def __init__(self, functions, inference_args, input_tangents, tape_watching):\n    \"\"\"Collects information about the function call.\n\n    Args:\n      functions: An object which produces forward and backward functions, either\n        a _DelayedRewriteGradientFunctions or a _TapeGradientFunctions object.\n      inference_args: A flat list of Tensors, arguments to the inference\n        function.\n      input_tangents: A flat list of Tensors, jvps associated with\n        `inference_args`.\n      tape_watching: Boolean, with True indicating that recording is necessary.\n    \"\"\"\n    self._functions = functions\n    self._inference_args = inference_args\n    self._input_tangents = input_tangents\n    self._tape_watching = tape_watching\n\n  def forward(self):\n    \"\"\"Builds or retrieves a forward function for this call.\"\"\"\n    forward_function = self._functions.forward(\n        self._inference_args, self._input_tangents)\n    return forward_function, self._inference_args + self._input_tangents\n\n  def record(self, flat_outputs):\n    \"\"\"Given outputs from the execution of `forward`, records the operation.\"\"\"\n    if (self._tape_watching\n        and not isinstance(flat_outputs, ops.Operation)\n        and flat_outputs is not None):\n      # We only record function calls which have outputs, and then only when a\n      # tape is watching.\n      self._functions.record(\n          flat_outputs, self._inference_args, self._input_tangents)\n\n\n# Sentinel value used by with ConcreteFunction's structured signature to\n# indicate that a non-tensor parameter should use the value that was\n# specified when the concrete function was created.\n_BOUND_VALUE = object()\n\n\nclass ConcreteFunction(core.ConcreteFunction):\n  \"\"\"A `tf.types.experimental.ConcreteFunction` created from `tf.function`.\"\"\"\n\n  def __init__(self,\n               func_graph,\n               attrs=None,\n               shared_func_graph=True,\n               function_spec=None):\n    \"\"\"Initialize a `ConcreteFunction`.\n\n    Args:\n      func_graph: An instance of FuncGraph: the function body to wrap.\n      attrs: (optional) dict mapping names of attributes to their AttrValue\n        values. Attributes in `attrs` will be included in this function's\n        definition.\n     shared_func_graph: If False, the ConcreteFunction takes ownership of\n       `func_graph` and will break reference cycles when it is deleted. This\n       makes the FuncGraph inoperable.\n     function_spec: FunctionSpec for the original function.  If not specified,\n       then this ConcreteFunction may only be called using the flat signature.\n\n    Raises:\n      ValueError: If number of input_placeholders is not equal to the number\n        of function inputs.\n    \"\"\"\n    # _arg_keywords and _num_positional_args define the flat signature.  They\n    # are assigned after construction.\n    self._arg_keywords = None\n    self._num_positional_args = None\n\n    self._func_graph = func_graph\n    self._captured_inputs = self._func_graph.external_captures + self._func_graph.deferred_external_captures\n\n    # function_spec defines the structured signature.\n    self._set_function_spec(function_spec)\n\n    if attrs and IMPLEMENTS_ATTRIBUTE_NAME in attrs:\n      # The alternative is to silently drop \"implements\" tag\n      # but it seems likely it would lead to hard to catch bugs.\n      # Another alternative is to make func_body to preserve the order\n      # of arguments if variables are present. Yet another option\n      # is to automatically replace variables as arguments to functions\n      # to v.read_value() whenever \"implements\" tag is present\n      # Anytime we annotate existing function we probably want to wrap\n      # it with safe read_value for backward compatibility.\n      has_resource_vars = any(inp.dtype == dtypes.resource\n                              for inp in self.inputs)\n\n      assert not any((has_resource_vars, self._captured_inputs)), (\n          'Function {name} has \"{attr}={value}\" attribute and thus can not '\n          \"depend on any tensors outside of its signature or modify variables. \"\n          \"\\n\\nNote: variables are always captured and cause function \"\n          \"re-tracing for every variable called.\\n\"\n          \"  inputs: {inputs}\\n  captures: {captured}\\n\\n\"\n          \"To pass a variable to such function use  \"\n          \"use variable.read_value().\".format(\n              name=func_graph.name,\n              attr=IMPLEMENTS_ATTRIBUTE_NAME,\n              value=attrs[IMPLEMENTS_ATTRIBUTE_NAME],\n              inputs=self.inputs,\n              captured=self._captured_inputs))\n    self._output_shapes = tuple(\n        output.shape for output in self._func_graph.outputs)\n    self._attrs = _parse_func_attrs(attrs or {})\n\n    if shared_func_graph:\n      self._garbage_collector = None\n    else:\n      self._garbage_collector = ConcreteFunctionGarbageCollector(func_graph)\n\n    # Pairs of forward and backward functions used for computing gradients.\n    #\n    # These each get a reference to the FuncGraph deleter since they use the\n    # FuncGraph directly.\n    self._delayed_rewrite_functions = _DelayedRewriteGradientFunctions(\n        func_graph, self._attrs, self._garbage_collector)\n    self._first_order_tape_functions = {}\n    self._higher_order_tape_functions = {}\n    # Cache the inference function to avoid a (Python) function call when not\n    # building gradients.\n    self._inference_function = self._delayed_rewrite_functions.forward()\n\n  def _set_function_spec(self, function_spec):\n    \"\"\"Enables the structured signature by supplying a function_spec.\"\"\"\n    self._function_spec = None\n    self._pre_initialized_function_spec = function_spec\n\n    # Note: when ConcreteFunctions are built by recreate_function() in\n    # function_deserialization.py, they don't have a structured_input_signature\n    # yet.  In that case, _initialize_function_spec() gets called by\n    # _setup_functions_structures() in load.py.\n    if (function_spec is not None and\n        self.structured_input_signature is not None):\n      self._initialize_function_spec()\n\n  def _initialize_function_spec(self):\n    \"\"\"Updates `self._function_spec` to include varargs and bound variables.\n\n    Adds new positional arguments for any varargs (i.e., for args that are\n    in `structured_input_signature`, but not in the original fullargspec.args).\n\n    Replaces `defaults` and `kwonlydefaults` with the `_BOUND_VALUE`, for\n    all args and kwargs in `structured_input_signature`.\n\n    Sets `varkw` and `varargs` to None.\n    \"\"\"\n    if self._pre_initialized_function_spec is None:\n      return  # e.g., SavedBareConcreteFunction doesn't have function_spec yet.\n    assert not self._function_spec, \"already initialized\"\n    function_spec = self._pre_initialized_function_spec\n    args = function_spec.fullargspec.args\n    arg_specs, kwarg_specs = self.structured_input_signature\n    vararg_indices = range(len(function_spec.arg_names), len(arg_specs))\n    fullargspec = tf_inspect.FullArgSpec(\n        args=list(args) + [\"<arg{}>\".format(i + 1) for i in vararg_indices],\n        varargs=None,\n        varkw=None,\n        defaults=[_BOUND_VALUE] * len(arg_specs),\n        kwonlyargs=list(sorted(kwarg_specs)),\n        kwonlydefaults=dict((k, _BOUND_VALUE) for k in kwarg_specs),\n        annotations=function_spec.fullargspec.annotations)\n    self._function_spec = FunctionSpec(\n        fullargspec,\n        function_spec.is_method,\n        function_spec.input_signature,\n        function_spec.is_pure,\n        name=self._func_graph.name)\n\n  @property\n  def variables(self):\n    \"\"\"Sequence of variables for this function.\"\"\"\n    return tuple(self._func_graph.variables)\n\n  @property\n  def trainable_variables(self):\n    \"\"\"Sequence of trainable variables for this function.\"\"\"\n    return tuple(self._func_graph.trainable_variables)\n\n  def __call__(self, *args, **kwargs):\n    \"\"\"Executes the wrapped function.\n\n    ConcreteFunctions have two signatures:\n\n    * The signature of the original function wrapped by this ConcreteFunction.\n    * A flat signature, where each argument accepts a single Tensor.\n\n    The original function signature is generally preferred, but the flat input\n    signature is supported for backward compatibility.\n\n    ### Original Function Signature\n\n    When calling a ConcreteFunction with the signature of the original function,\n    each argument must match the type or value that was used when the\n    ConcreteFunction's graph was traced.  In particular:\n\n    * Tensor arguments (including CompositeTensors, such as RaggedTensor) must\n      have matching `TypeSpec`s.\n    * Non-Tensor arguments (such as booleans or ints) must have equal values.\n    * Nested arguments (such as lists, tuples, or dictionaries) must have the\n      same nesting structure; and each nested value must have a matching type\n      or value.\n\n    The default value for any arguments that were traced with non-Tensor values\n    is the value that was used in the trace.  Arguments that were traced with\n    tensor arguments do not have a default value (even if the original function\n    had a default value for that argument).\n\n    ### Flat Signature\n\n    When calling a ConcreteFunction with the flat signature, the arguments\n    correspond to the flattened component tensors of the arguments that were\n    used to construct the ConcreteFunction.  Parameter names are assigned based\n    on `TensorSpec.name` (when specified) or the original argument names (with\n    suffixes automatically added for nested arguments or composite tensors with\n    multiple components).\n\n    Args:\n      *args: Positional arguments to the concrete function.\n      **kwargs: Keyword arguments to the concrete function.\n\n    Returns:\n      The result of applying the TF function on the given Tensors.\n\n    Raises:\n      AssertionError: If this `ConcreteFunction` was not created through\n        `get_concrete_function`.\n      TypeError: If the arguments do not match the function's signature.\n    \"\"\"\n    return self._call_impl(args, kwargs)\n\n  def _call_impl(self, args, kwargs, cancellation_manager=None):\n    \"\"\"See `__call__` for details.\"\"\"\n    with trace.Trace(self._func_graph.name, tf_function_call=\"concrete\"):\n      # Construct the list of input tensors: check if the structured signature\n      # applies first; and if not, then use the flat signature.\n      if self._function_spec is not None:\n        try:\n          return self._call_with_structured_signature(args, kwargs,\n                                                      cancellation_manager)\n        except TypeError as structured_err:\n          try:\n            return self._call_with_flat_signature(args, kwargs,\n                                                  cancellation_manager)\n          except TypeError:\n            raise structured_err\n\n      return self._call_with_flat_signature(args, kwargs, cancellation_manager)\n\n  def _call_with_flat_signature(self, args, kwargs, cancellation_manager):\n    \"\"\"Executes the wrapped function with the flat signature.\n\n    Args:\n      args: Positional arguments to the concrete function.\n      kwargs: Keyword arguments to the concrete function.\n      cancellation_manager: A `CancellationManager` that can be used to cancel\n        function invocation.\n\n    Returns:\n      The result of applying the function on the Tensors/Variables contained in\n      `args` and `kwargs`.\n    Raises:\n      TypeError: if `args` and `kwargs` do not match the flat signature of this\n        `ConcreteFunction`.\n    \"\"\"\n    if len(args) > self._num_positional_args:\n      raise TypeError(\n          f\"{self._flat_signature_summary()} takes {self._num_positional_args} \"\n          f\"positional arguments, got {len(args)}.\")\n    args = list(args)\n    kwargs = dict(kwargs)\n    for keyword in self._arg_keywords[len(args):]:\n      try:\n        args.append(kwargs.pop(compat.as_str(keyword)))\n      except KeyError:\n        specified_keywords = (\n            list(self._arg_keywords[:len(args)]) + list(kwargs.keys()))\n        missing_required_args = sorted(\n            set(self._arg_keywords) - set(specified_keywords))\n        raise TypeError(f\"{self._flat_signature_summary()} missing required \"\n                        f\"arguments: {', '.join(missing_required_args)}.\")\n    if kwargs:\n      positional_arg_keywords = set(self._arg_keywords[:len(args)])\n      for unused_key in kwargs:\n        if unused_key in positional_arg_keywords:\n          raise TypeError(f\"{self._flat_signature_summary()} got two values \"\n                          f\"for '{unused_key}'.\")\n      raise TypeError(f\"{self._flat_signature_summary()} got unexpected \"\n                      f\"keyword arguments: {', '.join(sorted(kwargs))}.\")\n\n    for i, arg in enumerate(args):\n      if not isinstance(\n          arg, (ops.Tensor, resource_variable_ops.BaseResourceVariable)):\n        raise TypeError(f\"{self._flat_signature_summary()}: expected argument \"\n                        f\"#{i}(zero-based) to be a Tensor; \"\n                        f\"got {type(arg).__name__} ({arg}).\")\n    return self._call_flat(args, self.captured_inputs, cancellation_manager)\n\n  def _call_with_structured_signature(self, args, kwargs, cancellation_manager):\n    \"\"\"Executes the wrapped function with the structured signature.\n\n    Args:\n      args: Positional arguments to the concrete function.\n      kwargs: Keyword arguments to the concrete function.\n      cancellation_manager: A `CancellationManager` that can be used to cancel\n        function invocation.\n\n    Returns:\n      The result of applying the function on the Tensors/Variables contained in\n      `args` and `kwargs`.\n    Raises:\n      TypeError: if `args` and `kwargs` do not match the structured signature\n        of this `ConcreteFunction`.\n    \"\"\"\n    args, kwargs, _, filtered_flat_args = \\\n        self._function_spec.canonicalize_function_inputs(*args, **kwargs)\n    self._structured_signature_check_missing_args(args, kwargs)\n    self._structured_signature_check_unexpected_args(args, kwargs)\n    self._structured_signature_check_arg_types(args, kwargs)\n    return self._call_flat(\n        filtered_flat_args,\n        captured_inputs=self.captured_inputs,\n        cancellation_manager=cancellation_manager)\n\n  def _structured_signature_check_missing_args(self, args, kwargs):\n    \"\"\"Raises a TypeError if any args are missing.\"\"\"\n    arg_specs, kwarg_specs = self.structured_input_signature\n    missing_arguments = []\n    for i, (arg, spec) in enumerate(zip(args, arg_specs)):\n      if arg is _BOUND_VALUE and _contains_type_spec(spec):\n        missing_arguments.append(self._function_spec.arg_names[i])\n    for (name, arg) in kwargs.items():\n      if arg is _BOUND_VALUE and _contains_type_spec(kwarg_specs[name]):\n        missing_arguments.append(name)\n    if missing_arguments:\n      raise TypeError(f\"{self._structured_signature_summary()} missing \"\n                      \"required arguments: \"\n                      f\"{', '.join(sorted(missing_arguments))}.\")\n\n  def _structured_signature_check_unexpected_args(self, args, kwargs):\n    \"\"\"Raises a TypeError if there are any extra args.\"\"\"\n    arg_specs, kwarg_specs = self.structured_input_signature\n    if len(args) > len(arg_specs):\n      raise TypeError(\n          f\"{self._structured_signature_summary()} takes \"\n          f\"{len(self._function_spec.arg_names)} positional arguments but got \"\n          f\"{len(args)}.\")\n    if len(kwargs) > len(kwarg_specs):\n      extra_args = set(kwargs) - set(kwarg_specs)\n      raise TypeError(f\"{self._structured_signature_summary()} got unexpected \"\n                      f\"keyword arguments: {', '.join(extra_args)}.\")\n\n  def _structured_signature_check_arg_types(self, args, kwargs):\n    \"\"\"Raises a TypeError if any args have the wrong type.\"\"\"\n    # Check argument types\n    arg_specs, kwarg_specs = self.structured_input_signature\n    for i, (arg, spec) in enumerate(zip(args, arg_specs)):\n      name = self._function_spec.arg_names[i]\n      self._structured_signature_check_arg_type(arg, spec, name)\n    for (name, arg) in kwargs.items():\n      self._structured_signature_check_arg_type(arg, kwarg_specs[name], name)\n\n  def _structured_signature_check_arg_type(self, arg, spec, name):\n    \"\"\"Raise TypeError if `arg`'s type doesn't match `spec`.\"\"\"\n    if arg is _BOUND_VALUE:\n      return\n\n    # Check the overall nested structure of the argument.\n    try:\n      nest.assert_same_structure(arg, spec, expand_composites=True)\n    except (ValueError, TypeError):\n      try:\n        nest.assert_same_structure(arg, spec, expand_composites=False)\n        expected, got = spec, arg\n      except (ValueError, TypeError):\n        expected, got = _structure_summary(spec), _structure_summary(arg)\n      raise TypeError(f\"{self._structured_signature_summary()}: argument \"\n                      f\"{name} had incorrect type\\n\"\n                      f\"  expected: {expected}\\n\"\n                      f\"       got: {got}\")\n\n    # Check the type for each leaf in the nested structure.\n    arg_pieces = nest.flatten(arg, expand_composites=True)\n    spec_pieces = nest.flatten(spec, expand_composites=True)\n    for (arg_piece, spec_piece) in zip(arg_pieces, spec_pieces):\n      # TODO(mdan): Use consistent error messages.\n      if isinstance(spec_piece, tensor_spec.DenseSpec):\n        # TODO(edloper): Consider calling convert_to_tensor on non-tensor\n        # values here.  That would match the behavior of\n        # _call_concrete_function() in function_deserialization.py.  If\n        # we do, then we need to change the nest assert_same_structure and\n        # flatten calls above to use shallow variants.\n        tensor_types = (ops.Tensor, resource_variable_ops.BaseResourceVariable)\n        if not isinstance(arg_piece, tensor_types):\n          raise TypeError(f\"{self._structured_signature_summary()} expected a \"\n                          f\"Tensor in {name}, but got \"\n                          f\"{type(arg_piece).__name__} value {arg_piece}.\")\n      elif arg_piece is not _BOUND_VALUE:\n        try:\n          arg_matches_spec = bool(arg_piece == spec_piece)\n        except (ValueError, TypeError):\n          logging.vlog(1, \"Error matching value with spec\", exc_info=True)\n          arg_matches_spec = False\n        if not arg_matches_spec:\n          raise TypeError(\n              f\"ConcreteFunction {self._structured_signature_summary()} was \"\n              f\"constructed with {type(spec_piece).__name__} value \"\n              f\"{spec_piece} in {name}, but was called with \"\n              f\"{type(arg_piece).__name__} value {arg_piece}.\")\n\n  def _call_flat(self, args, captured_inputs, cancellation_manager=None):\n    \"\"\"Executes the wrapped function.\n\n    Args:\n      args: a list of Tensors or Variables. Arguments from the Python function\n        should be filtered before calling this method: objects aside from\n        Tensors, CompositeTensors, and Variables are ignored. Any\n        CompositeTensors should be expanded before calling this method.\n      captured_inputs: the captured inputs that are also part of the input args\n        to the actual execution. By default, it should be self._captured_inputs.\n      cancellation_manager: (Optional.) A `CancellationManager` that can be\n        used to cancel function invocation.\n\n    Returns:\n      The result of applying the TF function to `args`.\n\n    Raises:\n      ValueError: If `args` contains anything other than Tensors or Variables.\n    \"\"\"\n    ctx = context.context()\n    executing_eagerly = ctx.executing_eagerly()\n\n    # Copy saveable status of function's graph to current FuncGraph.\n    default_graph = ops.get_default_graph()\n    if default_graph.building_function and not self._func_graph.saveable:\n      default_graph.mark_as_unsaveable(self._func_graph.saving_errors)\n\n    if (tape.could_possibly_record() or\n        hasattr(default_graph, \"watch_variable\")):\n      for v in self._func_graph.variables:\n        resource_variable_ops.variable_accessed(v)\n\n    tensor_inputs = []\n    variables_used = set([])\n    for i, arg in enumerate(args):\n      if isinstance(arg, resource_variable_ops.BaseResourceVariable):\n        # We can pass a variable more than once, and in this case we need to\n        # pass its handle only once.\n        if id(arg.handle) in variables_used:\n          continue\n        resource_variable_ops.variable_accessed(arg)\n        tensor_inputs.append(arg.handle)\n        variables_used.add(id(arg.handle))\n      elif isinstance(arg, ops.Tensor):\n        tensor_inputs.append(arg)\n        if not executing_eagerly:\n          # If we're graph building, shape inference is on. We check for input\n          # compatibility up front to avoid hard to debug incompatibilities\n          # later.\n          graph_input_shape = tensor_shape.TensorShape(\n              self._func_graph.inputs[i].shape)\n          if not graph_input_shape.is_compatible_with(arg.shape):\n            if self._arg_keywords:\n              arg_name = \"'{}'\".format(self._arg_keywords[i])\n            else:\n              arg_name = \"with index {}\".format(i)\n            raise ValueError(\n                f\"The argument {arg_name} (value {arg}) is not compatible with \"\n                \"the shape this function was traced with. Expected shape \"\n                f\"{self._func_graph.inputs[i].shape}, but got shape \"\n                f\"{arg.shape}.\\n\\nIf you called get_concrete_function, you may \"\n                \"need to pass a tf.TensorSpec(..., shape=...) with a less \"\n                \"specific shape, having None on axes which can vary.\")\n      else:\n        raise ValueError(f\"{i:d}-th input {arg} must be a Tensor, got \"\n                         f\"{type(arg)} when calling {self._func_graph.name}.\")\n    args = tensor_inputs + captured_inputs\n    possible_gradient_type = gradients_util.PossibleTapeGradientTypes(args)\n    if (possible_gradient_type == gradients_util.POSSIBLE_GRADIENT_TYPES_NONE\n        and executing_eagerly):\n      # No tape is watching; skip to running the function.\n      return self._build_call_outputs(self._inference_function.call(\n          ctx, args, cancellation_manager=cancellation_manager))\n    forward_backward = self._select_forward_and_backward_functions(\n        args,\n        possible_gradient_type,\n        executing_eagerly)\n    forward_function, args_with_tangents = forward_backward.forward()\n    if executing_eagerly:\n      flat_outputs = forward_function.call(\n          ctx, args_with_tangents, cancellation_manager=cancellation_manager)\n    else:\n      with default_graph._override_gradient_function(  # pylint: disable=protected-access\n          {\"PartitionedCall\": self._get_gradient_function(),\n           \"StatefulPartitionedCall\": self._get_gradient_function()}):\n        flat_outputs = forward_function.call(ctx, args_with_tangents)\n    forward_backward.record(flat_outputs)\n    return self._build_call_outputs(flat_outputs)\n\n  def _experimental_with_cancellation_manager(self, cancellation_manager):\n    \"\"\"Returns a callable that invokes a cancellable version of this function.\n\n    Args:\n      cancellation_manager: A `CancellationManager` object that can be used to\n        cancel function invocation.\n\n    Returns:\n      A callable with the same signature as this concrete function.\n    \"\"\"\n\n    def cancellable_call(*args, **kwargs):\n      return self._call_impl(\n          args, kwargs, cancellation_manager=cancellation_manager)\n\n    return cancellable_call\n\n  @property\n  def name(self):\n    \"\"\"`ConcreteFunction` name.\"\"\"\n    return self._delayed_rewrite_functions.forward().name\n\n  @property\n  def graph(self):\n    \"\"\"Returns the graph from which this function was constructed.\"\"\"\n    return self._func_graph\n\n  @property\n  def inputs(self):\n    \"\"\"Returns tensors in `self.graph` corresponding to arguments.\"\"\"\n    return self._func_graph.inputs\n\n  @property\n  def structured_input_signature(self):\n    \"\"\"Returns structured signature for this concrete function.\n\n    Returns:\n      A tuple `(args, kwargs)`, where:\n\n        * `args` is a tuple that specifies the expected type or value each for\n          positional argument.\n        * `kwargs` is a dictionary that specifies the expected type or value\n          for each keyword-only argument.\n\n      The type or value for each argument is specified using one of the\n      following:\n\n        * A `tf.TypeSpec`, indicating that a Tensor or other TensorFlow-native\n          value is expected.\n        * A Python value, such as an integer, indicating that an equal value\n          is expected.\n        * A nested structure of `tf.TypeSpec`s and Python values, indicating\n          that a corresponding nested structure is expected.\n    \"\"\"\n    return self._func_graph.structured_input_signature\n\n  @property\n  def outputs(self):\n    \"\"\"Returns tensors in `self.graph` corresponding to returned tensors.\"\"\"\n    return self._func_graph.outputs\n\n  @property\n  def structured_outputs(self):\n    \"\"\"Returns outputs in `self.graph` as returned by the original function.\"\"\"\n    return self._func_graph.structured_outputs\n\n  def set_external_captures(self, captures):\n    \"\"\"Updates the function capture values.\n\n    The new values must have tensor types and shapes consistent with the\n    original captures of the concrete function, but it is allowed to change a\n    value captured with a deferred one and vice-versa.\n\n    Args:\n      captures: A list of tensors or closures. Tensors are value captures, and\n        closures are call-time (deferred captures).\n    \"\"\"\n    # TODO(wxinyi): 1. verify that the new captures' type spec is compatible\n    # with the original's. However, doing so requires MirroredVariable captures\n    # initialized. 2. replace the original/new captures/deferred\n    # captures in the wrapped graph. Doing such for a capture-to-deferred\n    # capture replacement requires more arguments than the deferred capture\n    # itself, e.g. default value, spec.\n    self._captured_inputs = captures\n\n  def replace_capture_with_deferred_capture(self,\n                                            tensor,\n                                            closure,\n                                            spec,\n                                            placeholder=None,\n                                            default_value=None):\n    \"\"\"Replaces existing capture `tensor` with a deferred capture `closure`.\n\n    This API replaces the capture `tensor` from the concrete function's captured\n    inputs list, and places the deferred capture `closure` in\n    its spot so the order of captured inputs is preserved. This is important\n    because the old `tensor` and the new `closure` will have the same internal\n    placeholder, which can be passed through the `placeholder` argument, or\n    skipped, in which case we find the placeholder from internal inputs by\n    indexing `tensor` in the external captured inputs list. Thus, it is\n    important that the new deferred capture has output spec (specified by the\n    `spec` argument) compatible with the internal placeholder (`placeholder`)\n    and the original capture (`tensor`).\n\n    For example,\n\n    ```python\n    bool_captured_tensor = tf.constant(True)\n    float_captured_tensor = tf.constant([3.], dtype=tf.float32)\n    value = tf.constant([2.], dtype=tf.float32)\n\n    @tf.function\n    def fn():\n      deferred_tensor = ops.get_default_graph().capture_call_time_value(\n          lambda: value,\n          tf.TensorSpec(shape=(1,), dtype=tf.float32))\n      if bool_captured_tensor:\n        return deferred_tensor\n      else:\n        return deferred_tensor + float_captured_tensor\n\n    concrete_fn = fn.get_concrete_function()\n    print(concrete_fn())  # tf.Tensor([2.], shape=(1,), dtype=float32)\n\n    new_bool_captured_tensor = constant_op.constant(False)\n    def bool_closure():\n      return new_bool_captured_tensor\n\n    concrete_fn.replace_capture_with_deferred_capture(\n        bool_captured_tensor,\n        bool_closure,\n        spec=tensor_spec.TensorSpec(shape=(), dtype=dtypes.bool))\n\n    print(concrete_fn())  # tf.Tensor([5.], shape=(1,), dtype=float32)\n    ```\n\n    Args:\n      tensor: Tensor already captured. This `tensor` should be listed in\n        concrete_function.captured_inputs except when it's empty such as when\n        the concrete function is restored from SavedModel.\n      closure: function which takes no arguments, to be evaluated at function\n        call time, returning a nest of tensors compatible with `spec`.\n      spec: nest of TypeSpec for the value to capture.\n      placeholder: optional. The internal placeholder corresponding to the\n        captured `tensor` and the new `closure`.\n      default_value: optional value to use in environments that cannot safely\n        evaluate closure.\n    \"\"\"\n    capture_index = None\n    for i, capture in enumerate(self._captured_inputs):\n      if id(tensor) == id(capture):\n        capture_index = i\n        break\n\n    if placeholder is None:\n      if capture_index is None:\n        raise ValueError(\n            f\"Did not find `tensor` argument {tensor} in the ConcreteFunction's\"\n            \" captured inputs list, and did not receive a placeholder argument.\"\n            \" Thus we're unable to infer the internal placeholder. \")\n\n      placeholder = self.inputs[-len(self._captured_inputs) + capture_index]\n\n    if not (spec.is_compatible_with(tensor) or\n            spec.is_compatible_with(placeholder)):\n      raise ValueError(\n          f\"Attempting to substitute closure with spec {spec} that's \"\n          f\"incompatible with the original capture {tensor} or the internal \"\n          f\"placeholder {placeholder}.\")\n\n    self._func_graph.replace_capture_with_deferred_capture(\n        tensor=tensor,\n        closure=closure,\n        spec=spec,\n        placeholder=placeholder,\n        default_value=default_value)\n\n    if capture_index is not None:\n      self._captured_inputs[capture_index] = closure\n\n  @property\n  def captured_inputs(self):\n    \"\"\"Returns external Tensors captured by this function.\n\n    self.__call__(*args) passes `args + self.captured_inputs` to the function.\n    \"\"\"\n    return nest.flatten(\n        [x() if callable(x) else x for x in self._captured_inputs],\n        expand_composites=True)\n\n  @property\n  def function_def(self):\n    \"\"\"Returns a `FunctionDef` object representing this function.\"\"\"\n    return self._delayed_rewrite_functions.forward().definition\n\n  @property\n  def output_shapes(self):\n    \"\"\"The function's output shapes.\"\"\"\n    return nest.map_structure(\n        lambda x: getattr(x, \"shape\", tensor_shape.TensorShape(None)),\n        composite_tensor.replace_composites_with_components(\n            self._func_graph.structured_outputs),\n        expand_composites=False)\n\n  @property\n  def output_dtypes(self):\n    # TODO(akshayka): Consider removing this.\n    return nest.map_structure(\n        lambda x: x.dtype if x is not None else None,\n        composite_tensor.replace_composites_with_components(\n            self._func_graph.structured_outputs),\n        expand_composites=False)\n\n  def add_to_graph(self, g=None):\n    \"\"\"Registers the function, adds it to the graph g or default graph.\n\n    Args:\n      g: If specified, registers the function with this graph. Defaults to the\n        current context (either the default graph or the eager context).\n    \"\"\"\n    # If we are not executing eagerly, adds the function to default graph if no\n    # graph is specified.\n    # In case of eager execution, function definition gets added to context\n    # during construction itself.\n\n    if not context.executing_eagerly() and not g:\n      g = ops.get_default_graph()\n    self._delayed_rewrite_functions.forward().add_to_graph(g)\n\n  def add_gradient_functions_to_graph(self, g=None):\n    \"\"\"Add forward/backward functions to graph `g` or the current context.\"\"\"\n    if not context.executing_eagerly() and not g:\n      g = ops.get_default_graph()\n    self._delayed_rewrite_functions.forward().add_to_graph(g)\n    forward_function, backward_function = (\n        self._delayed_rewrite_functions.forward_backward())\n    forward_function.add_to_graph(g)\n    backward_function.add_to_graph(g)\n\n  def _get_gradient_function(self):\n    \"\"\"Returns gradient function. It will be lazily created at first call.\"\"\"\n    return self._delayed_rewrite_functions._rewrite_forward_and_call_backward  # pylint: disable=protected-access\n\n  def _select_forward_and_backward_functions(\n      self, args, possible_gradient_type, executing_eagerly):\n    \"\"\"Selects forward and backward functions based on the calling context.\n\n    The forward function computes the \"real\" function outputs, `self._outputs`,\n    and any extra values needed by the corresponding backward function.\n\n    Args:\n      args: A flat list of Tensors with all of the inputs to the forward\n        function (including user-specified and captured inputs).\n      possible_gradient_type: One of gradients_util.POSSIBLE_GRADIENT_TYPES_*.\n      executing_eagerly: Boolean, the value of context.executing_eagerly().\n\n    Returns:\n      An object with a `forward` method returning a tuple of (forward_function :\n      _EagerDefinedFunction, augmented_arguments : List), and a corresponding\n      `record` method which takes outputs from the forward function and records\n      the operation. forward_function should be called with augmented_arguments.\n    \"\"\"\n    if executing_eagerly:\n      input_tangents = forwardprop_util.pack_tangents(args)\n    else:\n      input_tangents = forwardprop_util.TangentInfo()\n    need_gradients_for_jvps = tape.should_record_backprop(\n        input_tangents.tangents)\n    # Allows re-use of forward and backward function pairs depending on the\n    # tapes and forward accumulators watching its inputs.\n    cache_key = (need_gradients_for_jvps, input_tangents.indices)\n    if (possible_gradient_type\n        == gradients_util.POSSIBLE_GRADIENT_TYPES_FIRST_ORDER):\n      if input_tangents.indices or executing_eagerly:\n        # There is a single non-persistent tape active, so the user can only\n        # request first-order gradients from a tape. We can spend less time\n        # graph building since we know this.\n        #\n        # We may still end up computing higher-order gradients, but that'd be\n        # through `tf.gradients`, which can re-write the forward pass and so\n        # needs no preparation here.\n        functions = self._first_order_tape_functions.get(cache_key, None)\n        if functions is None:\n          functions = _FirstOrderTapeGradientFunctions(\n              self._func_graph, self._attrs, self._garbage_collector,\n              forwardprop_input_indices=input_tangents.indices,\n              delayed_rewrite_functions=self._delayed_rewrite_functions,\n              need_gradients_for_jvps=need_gradients_for_jvps)\n          self._first_order_tape_functions[cache_key] = functions\n        return _ForwardBackwardCall(\n            functions, args, input_tangents.tangents, tape_watching=True)\n      else:\n        # We can avoid computing second-order gradients in some cases by doing a\n        # delayed rewrite when graph building. Since we know we'll only compute\n        # first-order tape gradients, the delayed rewrite is safe: we won't need\n        # to tell the tape about side outputs.\n        #\n        # TODO(allenl): This case is really dirty. It would be better if we\n        # could temporarily pop all of the current tapes to avoid\n        # accidentally taking second-order gradients.\n        return _ForwardBackwardCall(\n            self._delayed_rewrite_functions, args, input_tangents.tangents,\n            tape_watching=True)\n    elif (possible_gradient_type\n          == gradients_util.POSSIBLE_GRADIENT_TYPES_HIGHER_ORDER):\n      # Either there's a persistent tape watching, or there are multiple nested\n      # tapes. Either way, the user may request higher-order gradients. We'll\n      # spend a bit more time and make sure higher-order gradients are correct.\n      functions = self._higher_order_tape_functions.get(\n          cache_key, None)\n      if functions is None:\n        functions = _HigherOrderTapeGradientFunctions(\n            self._func_graph, self._attrs, self._garbage_collector,\n            forwardprop_input_indices=input_tangents.indices,\n            delayed_rewrite_functions=self._delayed_rewrite_functions,\n            need_gradients_for_jvps=need_gradients_for_jvps)\n        self._higher_order_tape_functions[cache_key] = functions\n      return _ForwardBackwardCall(functions, args, input_tangents.tangents,\n                                  tape_watching=True)\n    # else possible_gradient_type == POSSIBLE_GRADIENT_TYPES_NONE, meaning no\n    # tape is recording.\n    return _ForwardBackwardCall(\n        self._delayed_rewrite_functions, args, input_tangents.tangents,\n        tape_watching=False)\n\n  def _build_call_outputs(self, result):\n    \"\"\"Maps the fdef output list to actual output structure.\n\n    Args:\n      result: Output lists defined by FunctionDef.\n    Returns:\n      The actual call output.\n    \"\"\"\n    # TODO(jlchu): call C++ version in function.cc when speed is improved\n    if self._func_graph.structured_outputs is None:\n      return result\n\n    # Replace outputs with results, skipping over any 'None' values.\n    outputs_list = nest.flatten(\n        self._func_graph.structured_outputs, expand_composites=True)\n    j = 0\n    for i, o in enumerate(outputs_list):\n      if o is not None:\n        handle_data_util.copy_handle_data(self.outputs[j], result[j])\n        outputs_list[i] = result[j]\n        j += 1\n    ret = nest.pack_sequence_as(self._func_graph.structured_outputs,\n                                outputs_list, expand_composites=True)\n    return ret\n\n  @property\n  def _as_name_attr_list(self):\n    \"\"\"Returns a `NameAttrList` representing this function.\"\"\"\n    ret = attr_value_pb2.NameAttrList(name=self.name)\n    for name, value in self._attrs.items():\n      ret.attr[name].CopyFrom(value)\n    return ret\n\n  def _structured_signature_summary(self, default_values=False):\n    \"\"\"Returns a string summarizing this function's structured signature.\n\n    Args:\n      default_values: If true, then include default values in the signature.\n\n    Returns:\n      A `string`.\n    \"\"\"\n    # Note: we can't just use self._funcion_spec.signature_summary(), because\n    # that would show \"_BOUND_VALUE\" as the default value for all arguments.\n    assert self._function_spec is not None\n    arg_specs, kwarg_specs = self.structured_input_signature\n    arg_names = list(self._function_spec.arg_names)\n\n    # If an explicit input_signature is provided to @tf.function, then any\n    # arguments with defaults that are not covered by that explicit signature\n    # are simply dropped from the signature.\n    # TODO(b/159639913) Look into whether dropping arguments with default values\n    # from the signature is the right thing to do.\n    arg_names = arg_names[:len(arg_specs)]\n\n    if default_values:\n      for i in range(len(arg_names)):\n        if not _contains_type_spec(arg_specs[i]):\n          arg_names[i] += \"={}\".format(arg_specs[i])\n    if kwarg_specs:\n      arg_names.append(\"*\")\n      for name, spec in kwarg_specs.items():\n        arg_names.append(name)\n        if default_values and not _contains_type_spec(spec):\n          arg_names[-1] += \"={}\".format(spec)\n    signature = f\"{self._func_graph.name}({', '.join(arg_names)})\"\n\n    return signature\n\n  def _flat_signature_summary(self):\n    \"\"\"Returns a string summarizing this function's flat signature.\"\"\"\n    assert self._arg_keywords is not None\n    assert self._num_positional_args is not None\n    arg_names = self._arg_keywords\n    if self._num_positional_args > len(arg_names):\n      arg_names.extend(\n          \"<arg{}>\".format(i + 1)\n          for i in range(len(arg_names), self._num_positional_args))\n    return f\"{self._func_graph.name}({', '.join(arg_names)})\"\n\n  def pretty_printed_signature(self, verbose=True):\n    \"\"\"Returns a string summarizing the signature of this concrete function.\"\"\"\n    if not verbose:\n      return self._structured_signature_summary(default_values=True)\n\n    def pretty_print_spec(spec):\n      \"\"\"Returns a string describing the spec for a single argument.\"\"\"\n      if isinstance(spec, tensor_spec.TensorSpec):\n        return \"{} Tensor, shape={}\".format(spec.dtype.name, spec.shape)\n      elif nest.is_sequence(spec):\n        pieces = nest.flatten(spec, expand_composites=False)\n        markers = [_Marker(\"<{}>\".format(i + 1)) for i in range(len(pieces))]\n        structure = nest.pack_sequence_as(spec, markers)\n        # Ensure dictionaries are sorted by key (for determinism)\n        result = pprint.pformat(structure, width=10000)\n        for (marker, piece) in zip(markers, pieces):\n          result += \"\\n      {}: {}\".format(marker, pretty_print_spec(piece))\n        return result\n      else:\n        return repr(spec)\n\n    lines = [self._structured_signature_summary(default_values=True)]\n    arg_specs, kwarg_specs = self.structured_input_signature\n    names = list(self._function_spec.arg_names)\n\n    # If an explicit input_signature is provided to @tf.function, then any\n    # arguments with defaults that are not covered by that explicit signature\n    # are simply dropped from the signature.\n    # TODO(b/159639913) Look into whether dropping arguments with default values\n    # from the signature is the right thing to do.\n\n    # Note: we can skip bound args, since we already displayed their bound\n    # value in the signature summary.\n    arg_details = []\n    for (name, spec) in zip(names[:len(arg_specs)], list(arg_specs)):\n      if _contains_type_spec(spec):\n        arg_details.append(\"    {}: {}\".format(name, pretty_print_spec(spec)))\n\n    if kwarg_specs:\n      for kwarg in sorted(kwarg_specs):\n        spec = kwarg_specs[kwarg]\n        if _contains_type_spec(spec):\n          arg_details.append(\"    {}: {}\".format(\n              kwarg, pretty_print_spec(spec)))\n\n    if arg_details:\n      lines.append(\"  Args:\")\n      lines.extend(arg_details)\n    lines.append(\"  Returns:\")\n\n    def spec_from_value(value):\n      # For loaded function, structured_outputs are already specs.\n      if isinstance(value, type_spec.TypeSpec):\n        return value\n      return type_spec.type_spec_from_value(value)\n\n    lines.append(\"    {}\".format(\n        pretty_print_spec(\n            nest.map_structure(spec_from_value, self.structured_outputs))))\n\n    return \"\\n\".join(lines)\n\n  def __repr__(self):\n    if self._function_spec is not None:\n      return \"<ConcreteFunction {} at 0x{:X}>\".format(\n          self.pretty_printed_signature(verbose=False), id(self))\n    elif not (self._num_positional_args is None or self._arg_keywords is None):\n      return \"<ConcreteFunction {} at 0x{:X}>\".format(\n          self._flat_signature_summary(), id(self))\n    else:\n      return object.__repr__(self)\n\n  def __str__(self):\n    if self._function_spec is not None:\n      return \"ConcreteFunction {}\".format(self.pretty_printed_signature())\n    else:\n      return self.__repr__()\n\n\n_pywrap_utils.RegisterType(\"Tensor\", ops.Tensor)\n_pywrap_utils.RegisterType(\"EagerTensor\", ops.EagerTensor)\n_pywrap_utils.RegisterType(\"IndexedSlices\", ops.IndexedSlices)\n\n\ndef _deterministic_dict_values(dictionary):\n  return tuple(dictionary[key] for key in sorted(dictionary))\n\n\nclass FunctionSpec(object):\n  \"\"\"Specification of how to bind arguments to a function.\"\"\"\n\n  @staticmethod\n  def from_function_and_signature(python_function,\n                                  input_signature,\n                                  is_pure=False,\n                                  experimental_follow_type_hints=False,\n                                  jit_compile=None):\n    \"\"\"Create a FunctionSpec instance given a python function and signature.\n\n    Args:\n      python_function: a function to inspect\n      input_signature: a signature of the function (None, if variable)\n      is_pure: if True all input arguments (including variables and constants)\n      will be converted to tensors and no variable changes allowed.\n      experimental_follow_type_hints: see `tf.function`\n      jit_compile: see `tf.function`\n\n    Returns:\n      instance of FunctionSpec\n    \"\"\"\n    fullargspec = tf_inspect.getfullargspec(python_function)\n    if (input_signature is not None and\n        set(fullargspec.kwonlyargs) - set(fullargspec.kwonlydefaults or ())):\n      nodefault_kwonlyargs = set(fullargspec.kwonlyargs)\n      if fullargspec.kwonlydefaults is not None:\n        nodefault_kwonlyargs -= set(fullargspec.kwonlydefaults)\n      raise ValueError(\"Cannot build TF function from \"\n                       f\"{python_function.__name__}: keyword-only arguments \"\n                       \"must have default values when input_signature is \"\n                       \"provided. Got keyword-only arguments without default \"\n                       f\"values: {sorted(nodefault_kwonlyargs)}.\")\n\n    # Checks if the `fullargspec` contains self or cls as its first argument.\n    is_method = tf_inspect.isanytargetmethod(python_function)\n\n    # Treat a wrapped partial function as a special case. For all arguments that\n    # were overridden with keywords in the partial:\n    #   - remove the corresponding arguments,\n    #   - remove the corresponding keywords.\n    _, unwrapped = tf_decorator.unwrap(python_function)\n    if isinstance(unwrapped, functools.partial):\n      # Also consider the Python3 case with kwonlydefaults.\n      if fullargspec.defaults or fullargspec.kwonlydefaults:\n        new_defaults = fullargspec.defaults\n        new_args = fullargspec.args\n        if fullargspec.defaults:\n          # To be able to canonicalize the function properly, we want to ignore\n          # default values that are overridden via a partial kwarg. For example:\n          #\n          #   def func(a, b, c, d=5, e=7):\n          #     return a, b, c, d, e\n          #   p_func = tf.function(functools.partial(func, 10, e=9))\n          #\n          # Here we want to drop from the defaults the parameter `e`. If we\n          # forwarded the call to the partial function with a default for `e`\n          # we would get an error for passing two values for one parameter.\n          #\n          # Note that this has a limitation: we can only override parameters at\n          # the end of the parameter list.\n          #\n          # In this case we want to end up with 3 arguments (b, c, d) and 1\n          # default value (5). We do this by constructing a mask where 0 stands\n          # for a value that was overridden by a partial kwarg. The seemingly\n          # complicated logic below does just that - for arguments (b, c, d, e)\n          # we would get a mask (1, 1, 1, 0).\n          old_args = fullargspec.args\n          old_defaults = fullargspec.defaults\n\n          no_default = object()\n          num_args_without_defaults = len(old_args) - len(old_defaults)\n          left_padding = tuple([no_default] * num_args_without_defaults)\n\n          args_with_defaults = zip(old_args, left_padding + old_defaults)\n\n          # Create a mask where 0 stands for args that had a partial kwarg\n          # defined.\n          non_keyword_defaults_mask = [\n              0 if key in unwrapped.keywords else 1 for key in old_args\n          ]\n          # Keep only arguments and defaults that were not kwargs of partial.\n          new_args_with_defaults = list(\n              itertools.compress(args_with_defaults, non_keyword_defaults_mask))\n          # Keep all args.\n          new_args = [arg for arg, _ in new_args_with_defaults]\n          # Keep only real default values.\n          new_defaults = [\n              default for _, default in new_args_with_defaults\n              if default is not no_default\n          ]\n        fullargspec = tf_inspect.FullArgSpec(\n            args=new_args,\n            varargs=fullargspec.varargs,\n            varkw=fullargspec.varkw,\n            defaults=new_defaults,\n            kwonlyargs=[],\n            kwonlydefaults={},\n            annotations=fullargspec.annotations)\n\n    # Get the function's name.  Remove functools.partial wrappers if necessary.\n    while isinstance(python_function, functools.partial):\n      python_function = python_function.func\n    name = getattr(python_function, \"__name__\", \"f\")\n\n    return FunctionSpec(\n        fullargspec,\n        is_method,\n        input_signature,\n        is_pure=is_pure,\n        jit_compile=jit_compile,\n        experimental_follow_type_hints=experimental_follow_type_hints,\n        name=name)\n\n  def __init__(self,\n               fullargspec,\n               is_method,\n               input_signature,\n               is_pure=False,\n               experimental_follow_type_hints=False,\n               name=None,\n               jit_compile=None):\n    \"\"\"Constructs a FunctionSpec describing a python function.\n\n    Args:\n      fullargspec: `tf_inspect.FullArgSpec` object describing the function.\n      is_method: True if the function is a method.\n      input_signature: a signature of the function (None, if variable)\n      is_pure: if True all input arguments (including variables and constants)\n        will be converted to tensors and no variable changes allowed.\n      experimental_follow_type_hints: see `tf.function`.\n      name: Name of the function\n      jit_compile: see `tf.function`.\n    \"\"\"\n    self._fullargspec = fullargspec\n    self._is_method = is_method\n    self._is_pure = is_pure\n    self._jit_compile = jit_compile\n    self._experimental_follow_type_hints = experimental_follow_type_hints\n\n    # TODO(edloper): Include name when serializing for SavedModel?\n    self._name = name or \"f\"\n\n    if self._is_method:\n      # Remove `self`: default arguments shouldn't be matched to it.\n      # TODO(b/127938157): Should this error out if there is no arg to\n      # be removed?\n      args = fullargspec.args[1:]\n    else:\n      args = fullargspec.args\n\n    # A cache mapping from argument name to index, for canonicalizing\n    # arguments that are called in a keyword-like fashion.\n    self._args_to_indices = {arg: i for i, arg in enumerate(args)}\n    self._arg_names = args\n\n    # A cache mapping from arg index to default value, for canonicalization.\n    default_values = fullargspec.defaults\n    offset = len(args) - len(default_values or [])\n    self._arg_indices_to_default_values = {\n        offset + index: default\n        for index, default in enumerate(default_values or [])\n    }\n    self._arg_indices_no_default_values = set(range(len(args))) - set(\n        self._arg_indices_to_default_values)\n    if input_signature is None:\n      self._input_signature = None\n    else:\n      self._input_signature = tuple(input_signature)\n      self._flat_input_signature = tuple(nest.flatten(input_signature,\n                                                      expand_composites=True))\n\n  @property\n  def fullargspec(self):\n    return self._fullargspec\n\n  @property\n  def is_method(self):\n    return self._is_method\n\n  @property\n  def args_to_indices(self):\n    return self._args_to_indices\n\n  @property\n  def kwargs_to_include(self):\n    return self._kwargs_to_include\n\n  @property\n  def input_signature(self):\n    return self._input_signature\n\n  @property\n  def flat_input_signature(self):\n    return self._flat_input_signature\n\n  @property\n  def is_pure(self):\n    return self._is_pure\n\n  @property\n  def jit_compile(self):\n    return self._jit_compile\n\n  @property\n  def arg_names(self):\n    return self._arg_names\n\n  @property\n  def vararg_name(self):\n    return self._fullargspec.varargs\n\n  @property\n  def varkw_name(self):\n    return self._fullargspec.varkw\n\n  def signature_summary(self, default_values=False):\n    \"\"\"Returns a string summarizing this function's signature.\n\n    Args:\n      default_values: If true, then include default values in the signature.\n\n    Returns:\n      A `string`.\n    \"\"\"\n    args = list(self._arg_names)\n    if default_values:\n      for (i, default) in self._arg_indices_to_default_values.items():\n        args[i] += \"={}\".format(default)\n    if self._fullargspec.kwonlyargs:\n      args.append(\"*\")\n      for arg_name in self._fullargspec.kwonlyargs:\n        args.append(arg_name)\n        if default_values and arg_name in self._fullargspec.kwonlydefaults:\n          args[-1] += \"={}\".format(self._fullargspec.kwonlydefaults[arg_name])\n    return f\"{self._name}({', '.join(args)})\"\n\n  def _to_tensor_or_tensor_spec(self, x):\n    return (x if isinstance(x, (ops.Tensor, tensor_spec.TensorSpec))\n            else ops.convert_to_tensor(x))\n\n  def _convert_variables_to_tensors(self, args, kwargs):\n    args = [self._to_tensor_or_tensor_spec(x) for x in args]\n    kwargs = {kw: self._to_tensor_or_tensor_spec(x)\n              for kw, x in kwargs.items()}\n    return tuple(args), kwargs\n\n  def _convert_annotated_args_to_tensors(self, args, kwargs):\n    \"\"\"Attempts to autobox arguments annotated as tf.Tensor.\"\"\"\n    if self.input_signature is not None:\n      return\n\n    args = list(args)\n    for i, arg in enumerate(args):\n      # See\n      # https://docs.python.org/3/library/inspect.html#inspect.getfullargspec\n      if i < len(self._fullargspec.args):\n        annotation_key = self._fullargspec.args[i]\n      else:\n        annotation_key = self._fullargspec.varargs\n      arg_annotation = self._fullargspec.annotations.get(annotation_key, None)\n\n      # TODO(rahulkamat): Change to TensorLike (here ans below)\n      if arg_annotation == ops.Tensor:\n        args[i] = self._to_tensor_or_tensor_spec(arg)\n\n    for kw, v in kwargs.items():\n      if kw in self._fullargspec.kwonlyargs or kw in self._fullargspec.args:\n        annotation_key = kw\n      else:\n        annotation_key = self._fullargspec.varkw\n      kwarg_annotation = self._fullargspec.annotations.get(annotation_key, None)\n      if kwarg_annotation == ops.Tensor:\n        kwargs[kw] = self._to_tensor_or_tensor_spec(v)\n    return tuple(args), kwargs\n\n  def _validate_inputs(self, flat_inputs):\n    \"\"\"Raises an error if inputs contain illegal values.\"\"\"\n    for inp in flat_inputs:\n      # TODO(b/183107079): Allow these once they're handled properly.\n      if isinstance(inp, weakref.ref):\n        raise ValueError(\n            f\"weakref input {inp} not supported for function {self._name}\")\n\n  def canonicalize_function_inputs(self, *args, **kwargs):\n    \"\"\"Canonicalizes `args` and `kwargs`.\n\n    Canonicalize the inputs to the Python function using a `FunctionSpec`\n    instance. In particular, we parse the varargs and kwargs that the\n    original function was called with into a tuple corresponding to the\n    Python function's positional (named) arguments and a dictionary\n    corresponding to its kwargs.  Missing default arguments are added.\n\n    If this `FunctionSpec` has an input signature, then it is used to convert\n    arguments to tensors; otherwise, any inputs containing numpy arrays are\n    converted to tensors.\n\n    Additionally, any inputs containing numpy arrays are converted to Tensors.\n\n    Args:\n      *args: The varargs this object was called with.\n      **kwargs: The keyword args this function was called with.\n\n    Returns:\n      A canonicalized ordering of the inputs, as well as full and filtered\n      (Tensors and Variables only) versions of their concatenated flattened\n      representations, represented by a tuple in the form (args, kwargs,\n      flat_args, filtered_flat_args). Here: `args` is a full list of bound\n      arguments, and `kwargs` contains only true keyword arguments, as opposed\n      to named arguments called in a keyword-like fashion.\n\n    Raises:\n      ValueError: If a keyword in `kwargs` cannot be matched with a positional\n        argument when an input signature is specified, or when the inputs\n        do not conform to the input signature.\n    \"\"\"\n    if self._is_pure:\n      args, kwargs = self._convert_variables_to_tensors(args, kwargs)\n    if self._experimental_follow_type_hints:\n      args, kwargs = self._convert_annotated_args_to_tensors(args, kwargs)\n    # Pre-calculate to reduce overhead\n    arglen = len(args)\n    if self._input_signature is not None:\n      if arglen > len(self._input_signature):\n        raise TypeError(f\"{self.signature_summary()} specifies \"\n                        f\"{len(self._input_signature)} positional arguments, \"\n                        f\"but got {arglen}.\")\n      for arg in six.iterkeys(kwargs):\n        index = self._args_to_indices.get(arg, None)\n        if index is None:\n          raise TypeError(f\"{self.signature_summary()} got unexpected keyword \"\n                          f\"argument `{arg}`.\")\n        if index >= len(self._input_signature):\n          raise TypeError(\n              f\"{self.signature_summary()} got keyword argument `{arg}` that \"\n              \"was not included in input_signature.\")\n\n    if not kwargs:\n      inputs = args\n      if self._arg_indices_to_default_values:\n        try:\n          inputs += tuple(self._arg_indices_to_default_values[i]\n                          for i in range(arglen, len(self._arg_names)))\n        except KeyError:\n          missing_args = [\n              self._arg_names[i]\n              for i in range(arglen, len(self._arg_names))\n              if i not in self._arg_indices_to_default_values\n          ]\n          raise TypeError(f\"{self.signature_summary()} missing required \"\n                          f\"arguments: {', '.join(missing_args)}.\")\n\n      if self._fullargspec.kwonlydefaults:\n        kwargs.update(self._fullargspec.kwonlydefaults)\n    else:\n      # Maps from index of arg to its corresponding value, according to `args`\n      # and `kwargs`; seeded with the default values for the named args that\n      # aren't in `args`.\n      arg_indices_to_values = {\n          index: default for index, default in six.iteritems(\n              self._arg_indices_to_default_values) if index >= arglen\n      }\n      consumed_args = []\n      missing_arg_indices = self._arg_indices_no_default_values - set(\n          range(arglen))\n      for arg, value in six.iteritems(kwargs):\n        index = self._args_to_indices.get(arg, None)\n        if index is not None:\n          if index < arglen:\n            raise TypeError(f\"{self.signature_summary()} got two values for \"\n                            f\"{arg!r}.\")\n          arg_indices_to_values[index] = value\n          # These arguments in 'kwargs' might also belong to\n          # positional arguments\n          missing_arg_indices.discard(index)\n          consumed_args.append(arg)\n      for arg in consumed_args:\n        # After this loop, `kwargs` will only contain keyword_only arguments,\n        # and all positional_or_keyword arguments have been moved to `inputs`.\n        kwargs.pop(arg)\n      inputs = args + _deterministic_dict_values(arg_indices_to_values)\n      # Exclude positional args with values\n      if missing_arg_indices:\n        missing_args = [self._arg_names[i] for i in sorted(missing_arg_indices)]\n        if len(missing_args) == 1:\n          raise TypeError(f\"{self.signature_summary()} missing 1 required \"\n                          f\"argument: {missing_args[0]}.\")\n        else:\n          raise TypeError(f\"{self.signature_summary()} missing required \"\n                          f\"arguments: {', '.join(missing_args)}.\")\n\n      if kwargs and self._input_signature is not None:\n        raise TypeError(\"Keyword arguments are not supported when \"\n                        \"input_signature is provided. Signature: \"\n                        f\"{self.signature_summary()}. Keyword arguments: \"\n                        f\"{kwargs}.\")\n\n      if self._fullargspec.kwonlydefaults:\n        for (kwarg, default) in self._fullargspec.kwonlydefaults.items():\n          kwargs.setdefault(kwarg, default)\n\n    if self._input_signature is None:\n      inputs, flat_inputs, filtered_flat_inputs = _convert_numpy_inputs(inputs)\n      kwargs, flat_kwargs, filtered_flat_kwargs = _convert_numpy_inputs(kwargs)\n      flat_inputs += flat_kwargs\n      filtered_flat_inputs += filtered_flat_kwargs\n    else:\n      inputs, flat_inputs, filtered_flat_inputs = _convert_inputs_to_signature(\n          inputs, self._input_signature, self._flat_input_signature)\n\n    self._validate_inputs(flat_inputs)\n\n    return inputs, kwargs, flat_inputs, filtered_flat_inputs\n\n\ndef _convert_numpy_inputs(inputs):\n  \"\"\"Convert numpy array inputs to tensors.\"\"\"\n  # We assume that any CompositeTensors have already converted their components\n  # from numpy arrays to Tensors, so we don't need to expand composites here for\n  # the numpy array conversion. Instead, we do so because the flattened inputs\n  # are eventually passed to ConcreteFunction()._call_flat, which requires\n  # expanded composites.\n  flat_inputs = nest.flatten(inputs, expand_composites=True)\n\n  # Check for NumPy arrays in arguments and convert them to Tensors.\n  # TODO(nareshmodi): Skip ndarray conversion to tensor altogether, perhaps\n  # finding a way to store them directly in the cache key (currently not\n  # possible since ndarrays are not hashable).\n  need_packing = False\n  filtered_flat_inputs = []\n  for index, value in enumerate(flat_inputs):\n    if isinstance(value,\n                  (ops.Tensor, resource_variable_ops.BaseResourceVariable)):\n      filtered_flat_inputs.append(value)\n    elif hasattr(value, \"__array__\") and not (\n        hasattr(value, \"_should_act_as_resource_variable\") or\n        isinstance(value, (np.str_, type, composite_tensor.CompositeTensor))):\n      # This case is equivalent to _is_ndarray(value) == True\n      a = value.__array__()\n      if not isinstance(a, np.ndarray):\n        raise TypeError(f\"The output of __array__ must be an np.ndarray, \"\n                        f\"got {type(a)} from {value}.\")\n      flat_inputs[index] = constant_op.constant(a)\n      filtered_flat_inputs.append(flat_inputs[index])\n      need_packing = True\n  if need_packing:\n    return (nest.pack_sequence_as(\n        structure=inputs, flat_sequence=flat_inputs,\n        expand_composites=True), flat_inputs, filtered_flat_inputs)\n  else:\n    return inputs, flat_inputs, filtered_flat_inputs\n\n\ndef _convert_inputs_to_signature(inputs, input_signature, flat_input_signature):\n  \"\"\"Convert inputs to pass into a function with an explicit signature.\"\"\"\n\n  def format_error_message(inputs, input_signature):\n    return (\"  inputs: (\\n\" + \"    \" + \",\\n    \".join(str(i) for i in inputs) +\n            \")\\n\" + \"  input_signature: (\\n\" + \"    \" +\n            \",\\n    \".join(str(i) for i in input_signature) + \")\")\n\n  try:\n    flatten_inputs = nest.flatten_up_to(\n        input_signature,\n        inputs[:len(input_signature)],\n        expand_composites=True,\n        check_types=False)  # lists are convert to tuples for `tf.data`.\n  except ValueError:\n    raise ValueError(\"Structure of Python function inputs does not match \"\n                     \"input_signature:\\n\"\n                     f\"{format_error_message(inputs, input_signature)}.\")\n\n  need_packing = False\n  for index, (value, spec) in enumerate(zip(flatten_inputs,\n                                            flat_input_signature)):\n    if (isinstance(spec, tensor_spec.TensorSpec) and\n        not _pywrap_utils.IsTensor(value)):\n      try:\n        flatten_inputs[index] = ops.convert_to_tensor(\n            value, dtype_hint=spec.dtype)\n        need_packing = True\n      except ValueError:\n        raise ValueError(\"When input_signature is provided, all inputs to \"\n                         \"the Python function must be convertible to \"\n                         \"tensors:\\n\"\n                         f\"{format_error_message(inputs, input_signature)}.\")\n\n  if any(not spec.is_compatible_with(other) for spec, other in zip(\n      flat_input_signature,\n      flatten_inputs)):\n    raise ValueError(\"Python inputs incompatible with input_signature:\\n\"\n                     f\"{format_error_message(inputs, input_signature)}.\")\n\n  if need_packing:\n    inputs = nest.pack_sequence_as(\n        structure=input_signature,\n        flat_sequence=flatten_inputs,\n        expand_composites=True)\n\n  flat_inputs = nest.flatten(inputs, expand_composites=True)\n\n  return (inputs, flat_inputs, [\n      t for t in flat_inputs\n      if isinstance(t, (ops.Tensor, resource_variable_ops.BaseResourceVariable))\n  ])\n\n\nclass FunctionCache(object):\n  \"\"\"A lightweight container for cached functions.\n  \"\"\"\n\n  __slots__ = [\n      \"missed\", \"primary\", \"arg_relaxed_specs\", \"arg_relaxed\",\n      \"_garbage_collectors\"\n  ]\n\n  def __init__(self):\n    # The set of functions that have been missed; entries are CacheKey with\n    # input_signature `None` (e.g. a \"call context key\")\n    self.missed = set()\n    # The primary cache, mapping a fully shaped CacheKey to a function.\n    self.primary = collections.OrderedDict()\n    # A cache key lookup, mapping a CacheKey generated without shape info to a\n    # flat list of `TypeSpec`s with relaxed shapes (one for each flattened\n    # argument). Arguments that are not Tensors or `CompositeTensor`s contain a\n    # `None` for the corresponding relaxed spec.\n    self.arg_relaxed_specs = collections.OrderedDict()\n    # The secondary cache, mapping a CacheKey generated without shape info to a\n    # function.\n    self.arg_relaxed = collections.OrderedDict()\n    # All OrderedDicts require manual garbage collection.\n    self._garbage_collectors = [\n        _FunctionGarbageCollector(self.primary),\n        _FunctionGarbageCollector(self.arg_relaxed),\n        _FunctionGarbageCollector(self.arg_relaxed_specs)]\n\n  def all_values(self):\n    \"\"\"A list of all `ConcreteFunction` instances held by this cache.\"\"\"\n    # We need to simultaneously make sure our returned concrete functions are\n    # unique *and* make sure they are returned in a deterministic order for\n    # serialization.\n    #\n    # TODO(b/174215821): It's likely that we ultimately would just prefer to\n    # choose the most specific concrete function shape given a set of\n    # arguments. If and when that is implemented, this logic can be revisited.\n    primary_functions = set(self.primary.values())\n    return list(self.primary.values()) + [\n        v for v in self.arg_relaxed.values() if v not in primary_functions]\n\n\n# TODO(mdan): Refactor this and clarify relationship with def_function.Function.\n# Right now, def_function.Function is the higher level implementation.\nclass Function(object):\n  \"\"\"Wrapper class for the graph functions defined for a Python function.\n\n  See the documentation for `defun` for more information on the semantics of\n  defined functions.\n\n  `Function` class is thread-compatible meaning that minimal usage of defuns\n  (defining and calling) is thread-safe, but if users call other methods or\n  invoke the base `python_function` themselves, external synchronization is\n  necessary.\n  In addition, Function is not reentrant, so recursive functions need to call\n  the wrapped function, not the wrapper.\n  \"\"\"\n\n  def __init__(self,\n               python_function,\n               name,\n               input_signature=None,\n               attributes=None,\n               autograph=True,\n               autograph_options=None,\n               experimental_relax_shapes=False,\n               capture_by_value=None,\n               jit_compile=None,\n               experimental_follow_type_hints=False):\n    \"\"\"Initializes a `Function`.\n\n    Args:\n      python_function: the function to be wrapped.\n      name: the name given to it.\n      input_signature: a possibly nested sequence of `TensorSpec` objects\n        specifying the input signature of this function. If `None`, a separate\n        function is instantiated for each inferred input signature.\n      attributes: dict, extra keyword arguments that will be added as attribute\n        of the function.\n      autograph: whether to use autograph to compile\n        `python_function`. See https://www.tensorflow.org/guide/autograph for\n        more information.\n      autograph_options: Experimental knobs to control behavior\n        `when autograph=True`. See https://www.tensorflow.org/guide/autograph\n        for more information.\n      experimental_relax_shapes: When true, argument shapes may be relaxed to\n        avoid unnecessary retracing.\n      capture_by_value: Experimental. Whether to capture resource variables by\n        value or reference. If None, will inherit from a parent context or\n        default to False.\n      jit_compile: Force-compile the function with XLA, cf.\n        def_function.Function doc on jit_compile.\n      experimental_follow_type_hints: See the documentation for `tf.function`.\n\n    Raises:\n      ValueError: if `input_signature` is not None and the `python_function`'s\n        argspec has keyword arguments.\n    \"\"\"\n    self._python_function = python_function\n    pure_function = attributes and IMPLEMENTS_ATTRIBUTE_NAME in attributes\n    self._function_spec = FunctionSpec.from_function_and_signature(\n        python_function,\n        input_signature,\n        is_pure=pure_function,\n        experimental_follow_type_hints=experimental_follow_type_hints)\n    self._name = name\n    self._autograph = autograph\n    self._autograph_options = autograph_options\n    self._experimental_relax_shapes = experimental_relax_shapes\n    self._function_cache = FunctionCache()\n    self._function_attributes = attributes or {}\n    self._capture_by_value = capture_by_value\n    self.tracing_count = 0\n    if self.input_signature is not None:\n      self._hashable_input_signature = hash(self.flat_input_signature)\n\n    self._lock = threading.RLock()\n    # _descriptor_cache is a of instance of a class to an instance-specific\n    # `Function`, used to make sure defun-decorated methods create different\n    # functions for each instance.\n    self._descriptor_cache = weakref.WeakKeyDictionary()\n    self._jit_compile = jit_compile\n    self._experimental_follow_type_hints = experimental_follow_type_hints\n\n  def __call__(self, *args, **kwargs):\n    \"\"\"Calls a graph function specialized to the inputs.\"\"\"\n    with self._lock:\n      (graph_function,\n       filtered_flat_args) = self._maybe_define_function(args, kwargs)\n    return graph_function._call_flat(\n        filtered_flat_args, captured_inputs=graph_function.captured_inputs)  # pylint: disable=protected-access\n\n  @property\n  def python_function(self):\n    \"\"\"Returns the wrapped Python function.\"\"\"\n    return self._python_function  # pylint: disable=protected-access\n\n  @property\n  def function_spec(self):\n    return self._function_spec\n\n  @property\n  def input_signature(self):\n    \"\"\"Returns the input signature.\"\"\"\n    return self._function_spec.input_signature\n\n  @property\n  def flat_input_signature(self):\n    \"\"\"Returns the flattened input signature.\"\"\"\n    return self._function_spec.flat_input_signature\n\n  def _get_concrete_function_internal_garbage_collected(self, *args, **kwargs):\n    \"\"\"Returns a concrete function which cleans up its graph function.\"\"\"\n    if self.input_signature:\n      args, kwargs = None, None\n    with self._lock:\n      graph_function, _ = self._maybe_define_function(args, kwargs)\n    return graph_function\n\n  def _get_concrete_function_internal(self, *args, **kwargs):\n    \"\"\"Bypasses error checking when getting a graph function.\"\"\"\n    graph_function = self._get_concrete_function_internal_garbage_collected(\n        *args, **kwargs)\n    # We're returning this concrete function to someone, and they may keep a\n    # reference to the FuncGraph without keeping a reference to the\n    # ConcreteFunction object. So we won't clean up the reference cycles\n    # manually and instead will leave them to Python's garbage collector.\n    graph_function._garbage_collector.release()  # pylint: disable=protected-access\n    return graph_function\n\n  def _get_concrete_function_garbage_collected(self, *args, **kwargs):\n    \"\"\"Returns a `ConcreteFunction` specialized to inputs and execution context.\n\n    Unlike `get_concrete_function(...)`, the graph will be deleted when the\n    returned function is deleted.  It's useful to avoid creating a reference\n    cycle when you know for sure that the graph will be no longer used without\n    the returned function.\n\n    Args:\n      *args: inputs to specialize on.\n      **kwargs: inputs to specialize on.\n    \"\"\"\n    if self.input_signature:\n      if kwargs:\n        raise ValueError(\"Cannot define a TensorFlow function from a Python \"\n                         \"function with keyword arguments when \"\n                         \"input_signature is provided, got keyword arguments \"\n                         f\"({kwargs}) with input_signature \"\n                         f\"({self.input_signature}).\")\n      if args:\n        # If args are provided, they must match the input signature.\n        if not is_same_structure(self.input_signature, args):\n          raise ValueError(\"Structure of Python function inputs does not match \"\n                           f\"input_signature: inputs ({args}), \"\n                           f\"input_signature ({self.input_signature}).\")\n        flat_inputs = nest.flatten(args, expand_composites=True)\n        if any(not isinstance(arg, (ops.Tensor, tensor_spec.DenseSpec,\n                                    resource_variable_ops.BaseResourceVariable))\n               for arg in flat_inputs):\n          raise ValueError(\"When input_signature is provided, all inputs to \"\n                           \"the Python function must be Tensors, Variables, \"\n                           \"tf.TensorSpec or tf.VariableSpec objects.\")\n        if any(not spec.is_compatible_with(other)\n               for spec, other in zip(self.flat_input_signature, flat_inputs)):\n          raise ValueError(\"Python inputs incompatible with input_signature: \"\n                           f\"inputs ({args}), input_signature \"\n                           f\"({self.input_signature}).\")\n      args, kwargs = None, None\n    with self._lock:\n      graph_function, _ = self._maybe_define_function(args, kwargs)\n      seen_names = set()\n      captured = object_identity.ObjectIdentitySet(\n          graph_function.graph.internal_captures)\n      # pylint: disable=protected-access\n      graph_function._arg_keywords = []\n      prefix_counts = {}\n      # pylint: enable=protected-access\n      num_positional = 0\n      for arg in graph_function.graph.inputs:\n        if arg in captured:\n          break\n        num_positional += 1\n        user_arg_name = compat.as_str(arg.op.get_attr(\"_user_specified_name\"))\n        proposal = user_arg_name\n        while proposal in seen_names:\n          index = prefix_counts.get(user_arg_name, 1)\n          proposal = \"{}_{}\".format(user_arg_name, index)\n          prefix_counts[user_arg_name] = index + 1\n        seen_names.add(proposal)\n        graph_function._arg_keywords.append(proposal)  # pylint: disable=protected-access\n      # Anything can be a positional argument, in the same order as .inputs\n      graph_function._num_positional_args = num_positional  # pylint: disable=protected-access\n      return graph_function\n\n  def get_concrete_function(self, *args, **kwargs):\n    \"\"\"Returns a `ConcreteFunction` specialized to inputs and execution context.\n\n    Args:\n      *args: inputs to specialize on. Can be concrete values (e.g. 1)\n         or `tf.Tensor` or `tf.TensorSpec`.\n      **kwargs: keyword inputs to specialize on. Concrete values (e.g. 1)\n         or `tf.Tensor` or `tf.TensorSpec`.\n    \"\"\"\n    graph_function = self._get_concrete_function_garbage_collected(\n        *args, **kwargs)\n    graph_function._garbage_collector.release()  # pylint: disable=protected-access\n    return graph_function\n\n  def __get__(self, instance, owner):\n    \"\"\"Makes it possible to defun instance methods.\"\"\"\n    del owner\n    # `instance` here is the instance that this `Function` was accessed through\n    # e.g., for\n    #\n    #   class Foo(object):\n    #\n    #     @function.defun\n    #     def bar(self):\n    #       ...\n    #\n    #   foo = Foo()\n    #   foo.bar()  # `foo.bar` is a `Function` instance\n    #\n    # then `instance` will be `foo` (and `owner` will be `Foo`).  We create a\n    # new instance of `Function` here to allow different instances each\n    # to create variables once, thereby allowing methods to be decorated with\n    # defun. Keeps a cache to avoid retracing the function every time the\n    # descriptor is accessed.\n    if instance not in self._descriptor_cache:\n      if instance is None:\n        return self\n      # If there is no instance-specific `Function` in the cache, we construct\n      # an instance-specific `Function` that uses a weak reference to the\n      # instance (so that the instance will be correctly gc'd).\n\n      # And finally add the wrapped function to the description cache\n      self._descriptor_cache[instance] = class_method_to_instance_method(\n          self, instance)\n\n    # Return the cached `Function` for the instance\n    return self._descriptor_cache[instance]\n\n  def _cache_key(self,\n                 args,\n                 kwargs,\n                 cache_key_context,\n                 include_tensor_ranks_only=False):\n    \"\"\"Computes the cache key given inputs and execution context.\"\"\"\n    if self.input_signature is None:\n      # We always use both args and kwargs to form input even if one is empty.\n      # This reduces ambiguity, for example, when args contains a dict and\n      # kwargs is empty.\n      inputs = (args, kwargs)\n      hashable_input_signature = function_trace_type.get_arg_spec(\n          inputs, include_tensor_ranks_only, ENCODE_VARIABLES_BY_RESOURCE_ID,\n          USE_FULL_TRACE_TYPE)\n    else:\n      del args, kwargs\n      assert not include_tensor_ranks_only\n      hashable_input_signature = self._hashable_input_signature\n\n    (parent_graph, device_functions, colocation_stack, in_cross_replica_context,\n     variable_policy, xla_context_id) = cache_key_context\n\n    return CacheKey(hashable_input_signature, parent_graph, device_functions,\n                    colocation_stack, in_cross_replica_context, variable_policy,\n                    xla_context_id)\n\n  def _cache_key_context(self):\n    \"\"\"Returns execution context.\"\"\"\n    ctx = context.context()\n\n    # Don't need to open an init_scope if the _cache_key call is in eager mode\n    # already.\n    executing_eagerly = ctx.executing_eagerly()\n    parent_graph = None\n    xla_context_id = 0\n    if not executing_eagerly:\n      # We want to force function retracing for each different\n      # XLAControlFlowContext, so add `xla_context_id` to the cache key.\n      xla_context = _enclosing_xla_context()\n      if xla_context is not None and \\\n            xla_context.RequiresUniqueFunctionRetracing():\n        xla_context_id = id(xla_context)\n\n      with ops.init_scope():\n        # The graph, or whether we're executing eagerly, should be a part of the\n        # cache key so we don't improperly capture tensors such as variables.\n        executing_eagerly = ctx.executing_eagerly()\n        parent_graph = None if executing_eagerly else ops.get_default_graph()\n\n    # pylint: disable=protected-access\n    default_graph = ops.get_default_graph()\n    # TODO(b/117617952): The current distribution strategy will affect graph\n    # building (e.g. accessing different variables from different devices) and\n    # so requires retracing for each device.\n    strategy_stack = default_graph._distribution_strategy_stack\n    uses_distribution_strategy = (\n        strategy_stack and\n        strategy_stack[-1].strategy.extended._retrace_functions_for_each_device\n    )\n    if executing_eagerly:\n      colocation_stack = ()\n      if uses_distribution_strategy:\n        device_functions = (pydev.merge_device(ctx.device_name),)\n      else:\n        device_functions = ()\n    else:\n      colocation_stack = tuple(default_graph._colocation_stack.peek_objs())\n      if (uses_distribution_strategy\n          or func_graph_module.device_stack_has_callable(\n              default_graph._device_function_stack)):\n        # Putting the device in the cache key ensures that call-site device\n        # annotations are respected.\n        device_functions = tuple(default_graph._device_functions_outer_to_inner)\n      else:\n        device_functions = ()\n\n    in_cross_replica_context = False\n    try:\n      in_cross_replica_context = (strategy_stack[-1].replica_context is None)  # pylint: disable=protected-access\n    except (AttributeError, IndexError):\n      pass\n\n    if save_context.in_save_context():\n      variable_policy = (\n          save_context.get_save_options().experimental_variable_policy)\n    else:\n      variable_policy = None\n\n    return (parent_graph, device_functions, colocation_stack,\n            in_cross_replica_context, variable_policy, xla_context_id)\n\n  def _create_graph_function(self, args, kwargs, override_flat_arg_shapes=None):\n    \"\"\"Create a `ConcreteFunction` from `args` and `kwargs`.\"\"\"\n    self.tracing_count += 1\n\n    if self.input_signature is None:\n      arglen = len(args)\n    else:\n      arglen = len(self.input_signature)\n    base_arg_names = self._function_spec.arg_names[:arglen]\n    num_missing_args = arglen - len(self._function_spec.arg_names)\n    missing_arg_names = [self._function_spec.vararg_name] * num_missing_args\n    # Produce a list of missing args of the form [\"arg_0\", \"arg_1\", ...],\n    # where arg is based on the self._function_spec.vararg_name.\n    missing_arg_names = [\n        \"%s_%d\" % (arg, i) for i, arg in enumerate(missing_arg_names)\n    ]\n    arg_names = base_arg_names + missing_arg_names\n    graph_function = ConcreteFunction(\n        func_graph_module.func_graph_from_py_func(\n            self._name,\n            self._python_function,\n            args,\n            kwargs,\n            self.input_signature,\n            autograph=self._autograph,\n            autograph_options=self._autograph_options,\n            arg_names=arg_names,\n            override_flat_arg_shapes=override_flat_arg_shapes,\n            capture_by_value=self._capture_by_value),\n        self._function_attributes,\n        function_spec=self.function_spec,\n        # Tell the ConcreteFunction to clean up its graph once it goes out of\n        # scope. This is not the default behavior since it gets used in some\n        # places (like Keras) where the FuncGraph lives longer than the\n        # ConcreteFunction.\n        shared_func_graph=False)\n    return graph_function\n\n  def _define_function_with_shape_relaxation(self, args, kwargs, flat_args,\n                                             filtered_flat_args,\n                                             cache_key_context):\n    \"\"\"Define a function, relaxing arg shapes to avoid unnecessary retracing.\"\"\"\n    flat_no_comp = nest.flatten((args, kwargs), expand_composites=False)\n\n    any_composite_args = any(\n        isinstance(x, composite_tensor.CompositeTensor) for x in flat_no_comp)\n\n    # Build a cache key where TensorShapes include only rank information (and\n    # not information about the size of each dimension).\n    if not any_composite_args:\n      rank_only_cache_key = self._cache_key(\n          args, kwargs, cache_key_context, include_tensor_ranks_only=True)\n    else:\n      # For the rank-only cache key, replace any composite tensors with\n      # shape-relaxed TypeSpecs.\n      (cache_key_args, cache_key_kwargs) = nest.map_structure(\n          _shape_relaxed_type_for_composite_tensor, (args, kwargs))\n      rank_only_cache_key = self._cache_key(\n          cache_key_args,\n          cache_key_kwargs,\n          cache_key_context,\n          include_tensor_ranks_only=True)\n\n    arg_specs = [_type_spec_for(x) for x in flat_no_comp]\n    relaxed_arg_specs = self._function_cache.arg_relaxed_specs.get(\n        rank_only_cache_key, None)\n    relaxed_arg_function = self._function_cache.arg_relaxed.get(\n        rank_only_cache_key, None)\n\n    if (relaxed_arg_function is not None\n        and all(_is_type_subset(x, y) for (x, y) in\n                zip(relaxed_arg_specs, arg_specs))):\n      return relaxed_arg_function, filtered_flat_args\n\n    if relaxed_arg_specs is None:\n      relaxed_arg_specs = arg_specs\n    else:\n      if len(arg_specs) != len(relaxed_arg_specs):\n        raise RuntimeError(\"Expected arg_specs len to match relaxed_arg_specs \"\n                           f\"len: {len(arg_specs):d} vs. \"\n                           f\"{len(relaxed_arg_specs):d}.\")\n      relaxed_arg_specs = [\n          x if x is None else x.most_specific_compatible_type(y)\n          for (x, y) in zip(arg_specs, relaxed_arg_specs)]\n    self._function_cache.arg_relaxed_specs[rank_only_cache_key] = (\n        relaxed_arg_specs)\n    relaxed_arg_shapes = [\n        x if x is None else x.shape\n        for x in nest.flatten(relaxed_arg_specs, expand_composites=True)]\n\n    if any_composite_args:\n      # Rebuild composite tensors with the relaxed TypeSpecs.  For example,\n      # if a tf.data iterator is passed as an argument, then we need to relax\n      # the TensorShapes in its element_spec.\n      (relaxed_arg_specs, relaxed_kwarg_specs) = nest.pack_sequence_as(\n          (args, kwargs), relaxed_arg_specs, expand_composites=False)\n      (args, kwargs) = nest.pack_sequence_as(\n          (relaxed_arg_specs, relaxed_kwarg_specs),\n          flat_args,\n          expand_composites=True)\n\n    graph_function = self._create_graph_function(\n        args, kwargs, override_flat_arg_shapes=relaxed_arg_shapes)\n    self._function_cache.arg_relaxed[rank_only_cache_key] = graph_function\n\n    return (graph_function, [\n        t for t in nest.flatten((args, kwargs), expand_composites=True)\n        if isinstance(t, (ops.Tensor,\n                          resource_variable_ops.BaseResourceVariable))\n    ])\n\n  def _maybe_define_function(self, args, kwargs):\n    \"\"\"Gets a function for these inputs, defining it if necessary.\n\n    `args` and `kwargs` can be None if this `Function` was created with an\n    `input_signature`.\n\n    Caller must hold self._lock.\n\n    Args:\n      args: The varargs for the Python function.\n      kwargs: The keyword args for the Python function.\n\n    Returns:\n      A graph function corresponding to the input signature implied by args and\n      kwargs, as well as filtered flattened inputs (only Tensors and Variables)\n      that the object should be called with.\n\n    Raises:\n      ValueError: If inputs are incompatible with the input signature.\n      TypeError: If the function inputs include non-hashable objects\n      RuntimeError: If there's an internal bug (inconsistency) in handling\n        shape relaxation retracing.\n    \"\"\"\n    if self.input_signature is None or args is not None or kwargs is not None:\n      args, kwargs, flat_args, filtered_flat_args = \\\n          self._function_spec.canonicalize_function_inputs(*args, **kwargs)\n    else:\n      flat_args, filtered_flat_args = [None], []\n\n    cache_key_context = self._cache_key_context()\n    cache_key = self._cache_key(args, kwargs, cache_key_context)\n\n    try:\n      hash(cache_key)\n    except TypeError as e:\n      raise TypeError(\n          \"Arguments supplied to `defun`-generated functions must be \"\n          f\"hashable.  Original error: {e}.\")\n\n    graph_function = self._function_cache.primary.get(cache_key, None)\n    if graph_function is not None:\n      return graph_function, filtered_flat_args\n\n    with monitoring.MonitoredTimer(_graph_building_time_counter.get_cell()):\n      with trace.Trace(\"tf.function-graph_building\"):\n        logging.vlog(1,\n                     \"Creating new FuncGraph for Python function %r (key: %r)\",\n                     self._python_function, cache_key)\n        logging.vlog(2, \"Python function signature [args: %s] [kwargs: %s]\",\n                     args, kwargs)\n\n        # pylint: disable=protected-access\n        call_context_key = cache_key._replace(input_signature=None)\n        # pylint: disable=protected-access\n\n        ag_status = (\n            ag_ctx.Status.ENABLED\n            if self._autograph else ag_ctx.Status.DISABLED)\n        with ag_ctx.ControlStatusCtx(\n            status=ag_status, options=self._autograph_options):\n\n          # Build a function with shape relaxation retracing if:\n          # 1. shape relaxation is explicitly enabled\n          # and 2. there's no provided input signature\n          # and 3. there's been a cache miss for this calling context\n          if (self._experimental_relax_shapes and\n              self.input_signature is None and\n              call_context_key in self._function_cache.missed):\n            return self._define_function_with_shape_relaxation(\n                args, kwargs, flat_args, filtered_flat_args, cache_key_context)\n\n          self._function_cache.missed.add(call_context_key)\n          graph_function = self._create_graph_function(args, kwargs)\n          self._function_cache.primary[cache_key] = graph_function\n\n          return graph_function, filtered_flat_args\n\n\ndef register(func, *args, **kwargs):\n  \"\"\"Register a specialization of a `Function` into the graph.\n\n  This won't actually call the function with the inputs, and only put the\n  function definition into graph. Register function with different input param\n  will result into multiple version of functions registered in graph.\n\n  Args:\n    func: the `Function` instance that generated by a @defun\n    *args: input arguments for the Python function.\n    **kwargs: input keyword arguments for the Python function.\n\n  Returns:\n    a `ConcreteFunction` object specialized to inputs and execution context.\n\n  Raises:\n    ValueError: When the input function is not a defun wrapped python function.\n  \"\"\"\n  if not isinstance(func, Function):\n    raise ValueError(\"Only defun function is allowed to be registered. \"\n                     f\"Got {func} with type {type(func)}.\")\n  concrete_func = func.get_concrete_function(*args, **kwargs)\n  concrete_func.add_to_graph()\n  concrete_func.add_gradient_functions_to_graph()\n  return concrete_func\n\n\ndef validate_signature(signature):\n  if not isinstance(signature, (tuple, list)):\n    raise TypeError(\"input_signature must be either a tuple or a list, got \"\n                    f\"{type(signature)}.\")\n\n  if any(not isinstance(arg, tensor_spec.DenseSpec)\n         for arg in nest.flatten(signature, expand_composites=True)):\n    bad_args = [arg for arg in nest.flatten(signature, expand_composites=True)\n                if not isinstance(arg, tensor_spec.DenseSpec)]\n    raise TypeError(\"input_signature must be a possibly nested sequence of \"\n                    f\"TensorSpec objects, got invalid args {bad_args} with \"\n                    f\"types {list(map(type, bad_args))}.\")\n\n\ndef validate_python_function(python_function):\n  if not callable(python_function):\n    raise TypeError(f\"{python_function} is not a callable object.\")\n\n\ndef defun(func=None,\n          input_signature=None,\n          autograph=True,\n          experimental_autograph_options=None,\n          experimental_relax_shapes=False):\n  \"\"\"Compiles a Python function into a callable TensorFlow graph.\n\n  `defun` (short for \"define function\") compiles a Python function\n  composed of TensorFlow operations into a callable that executes a `tf.Graph`\n  containing those operations. The callable produced by `defun` contains only\n  the subgraph of TensorFlow operations that were executed when the Python\n  function was called with a particular input signature, defined as a list\n  of the shapes and dtypes of the Python function's Tensor-valued arguments and\n  the values of its non-Tensor Python objects.\n\n  When eager execution is enabled, the ability to create graphs from Python\n  functions makes it possible to incrementally trade off debuggability and\n  interactivity for performance.  Functions compiled with `defun` cannot be\n  inspected with `pdb`; however, executing a graph\n  generated by `defun` sometimes takes less time and memory than eagerly\n  executing the corresponding Python function, since specifying computations as\n  graphs allows for optimizations like automatic buffer reuse and\n  parallelization among ops. Note that executing a `defun`-compiled function\n  incurs a small constant overhead, so eagerly executing sufficiently small\n  Python functions might take less time than executing their corresponding\n  `defun`-generated graphs.\n\n  For a Python function to be compatible with `defun`, all of its arguments must\n  be hashable Python objects or lists thereof. The function itself may not\n  modify the list/map structure of its arguments. Additionally, it must return\n  zero or more `tf.Tensor` objects. If the Python function returns\n  a `tf.Variable`, its compiled version will return the value of that variable\n  as a `tf.Tensor`.\n\n  Executing a graph generated by `defun` respects device annotations (i.e.,\n  all `with tf.device` directives present in a Python function will also be\n  present in its corresponding graph), but it is not yet possible to execute the\n  generated graphs across multiple machines.\n\n  _Example Usage_\n\n  ```python\n  import tensorflow as tf\n\n  tf.compat.v1.enable_eager_execution()\n\n  # A simple example.\n  def f(x, y):\n    return tf.reduce_mean(tf.multiply(x ** 2, 3) + y)\n\n  g = tf.contrib.eager.defun(f)\n\n  x = tf.constant([[2.0, 3.0]])\n  y = tf.constant([[3.0, -2.0]])\n\n  # `f` and `g` will return the same value, but `g` will be executed as a\n  # TensorFlow graph.\n  assert f(x, y).numpy() == g(x, y).numpy()\n\n  # `defun` is capable of compiling Python functions that close over Python\n  # objects, including Tensors and Variables.\n  @tf.contrib.eager.defun\n  def h():\n    return f(x, y)\n\n  assert (h().numpy() == f(x, y).numpy()).all()\n\n  # `defun` automatically lifts variables out of the graphs it creates,\n  # allowing you to compile the `call` methods of `tf.keras.layers.Layer` and\n  # `tf.keras.Model` objects.\n  class MyModel(tf.keras.Model):\n\n    def __init__(self, keep_probability=0.2):\n      super(MyModel, self).__init__()\n      self.dense1 = tf.keras.layers.Dense(4, activation=tf.nn.relu)\n      self.dense2 = tf.keras.layers.Dense(5, activation=tf.nn.softmax)\n      self.keep_probability = keep_probability\n\n    @tf.contrib.eager.defun\n    def call(self, inputs, training=True):\n      x = self.dense2(self.dense1(inputs))\n      if training:\n        return tf.nn.dropout(x, self.keep_probability)\n      else:\n        return x\n\n  model = MyModel()\n  model(x, training=True)  # executes a graph, with dropout\n  model(x, training=False) # executes a graph, without dropout\n\n  # `defun`-compiled functions are differentiable.\n  optimizer = tf.compat.v1.train.GradientDescentOptimizer(learning_rate=0.01)\n  with tf.GradientTape() as tape:\n    outputs = model(x)\n  gradient = tape.gradient(outputs, model.trainable_variables)\n  optimizer.apply_gradients((grad, var) for grad, var in zip(gradient,\n                            model.trainable_variables))\n  ```\n\n  When using `defun`, there are subtleties regarding inputs, Python control\n  flow, and variable creation that one should be aware of. For concreteness, let\n  `f` be a Python function that returns zero or more `tf.Tensor` objects and\n  let `F = defun(f)`. `F` builds a graph for each unique input signature it\n  sees, Python control flow is baked into graphs, and operations related to\n  variable initialization are automatically lifted out of the graphs that `F`\n  generates and placed in the eager context if executing eagerly or into an\n  outer graph otherwise.\n\n  _Input Signatures_\n\n  By default, `F = tf.contrib.eager.defun(f)` instantiates a separate graph\n  for every unique sequence of the shapes and dtypes of Tensor arguments and\n  the values of Python objects it is invoked with. For example, calling\n  `F(tf.random.uniform([2])` will execute a different graph than\n  `F(tf.random.uniform([3])` because the two inputs have different shapes.\n  The first time that `F(*args, **kwargs)` is called with a particular sequence\n  of Tensor shapes and dtypes and Python values, it constructs a graph by\n  tracing the execution of `f(*args, **kwargs)`; this graph is bound to an\n  input signature inferred from `(*args, **kwargs)` and cached for future reuse.\n\n  NumPy arrays passed as inputs to `F` are converted to `tf.Tensor` objects\n  before being passed to `f`, and are treated as Tensors for caching. This\n  allows a function to be called multiple times with NumPy arrays having\n  different values but the same shape and dtype without re-tracing each time.\n\n  `tf.contrib.eager.defun` caches graphs for your convenience, letting you\n  define TensorFlow functions without explicitly specifying their signatures.\n  However, this policy is conservative and potentially expensive; for example,\n  when different invocations of your function have differently-shaped Tensor\n  inputs, this policy might generate more graph functions than necessary. To\n  eliminate such costs, `tf.contrib.eager.defun` allows you to supply an\n  optional `input_signature` argument specifying the shapes and dtypes of the\n  inputs. In particular, the shapes may be partially unspecified, with `None`s\n  in the unknown dimensions.  When an input signature is provided,\n  `tf.contrib.eager.defun` will only instantiate a single graph for the\n  decorated Python function. The following is an example:\n\n  ```python\n  import tensorflow as tf\n\n  # The first `TensorSpec` below describes the shape and dtype of `words`,\n  # and the second describes the shape and dtype of `another_tensor`. Note that\n  # the last dimension of the `words` `TensorSpec` is left unspecified.\n  @tf.contrib.eager.defun(input_signature=[\n    tf.contrib.eager.TensorSpec(shape=[50, 300, None], dtype=tf.float32),\n    tf.contrib.eager.TensorSpec(shape=[300, 100], dtype=tf.float32)\n  ])\n  def my_sequence_model(words, another_tensor):\n    ...\n\n  # Note how the third dimension of the first input can vary freely.\n  words = tf.random.uniform(([50, 300, 10])\n  second_input = tf.random.uniform([300, 100])\n  my_sequence_model(words, second_input)\n\n  words = tf.random.uniform(([50, 300, 20])\n  my_sequence_model(words, second_input)\n\n  # Passing an input with an incompatible shape will raise an error.\n  words = tf.random.uniform(([50, 100, 20])\n  my_sequence_model(words, second_input)  # <---- This will raise an error.\n\n  ```\n\n  Python functions that are compiled with an `input_signature` must only accept\n  Tensors as arguments and must not take unnamed keyword arguments (**kwargs).\n\n  _Tracing_\n\n  Be aware that because `F` only logs TensorFlow operations, all the other\n  Python code that `f` executes will only shape the _construction_ of the graphs\n  that `F` executes: the Python code won't be executed when the graphs\n  themselves are executed, though it will be executed every time the Python\n  function is traced (and a given Python function might be traced multiple\n  times, once for each input signature it is invoked with). For example, whereas\n  the Python function\n\n  ```python\n  import tensorflow as tf\n  import numpy as np\n\n  tf.compat.v1.enable_eager_execution()\n\n  def add_noise():\n    return tf.eye(5) + np.random.randn(5, 5)\n  ```\n\n  will return a different output everytime it is invoked, the compiled function\n  `compiled = tf.contrib.eager.defun(add_noise)` will return the same value\n  every time it is called, since a particular random offset generated by NumPy\n  will be inserted into the graph as a TensorFlow constant. The solution is to\n  replace the call to `np.random.randn` with `tf.random.normal((5, 5))`.\n\n  _Python Side-Effects_\n\n  A corollary of the previous discussion on tracing is the following: If a\n  Python function `f` has Python side-effects, then executing `f` multiple times\n  will not necessarily be semantically equivalent to executing `F =\n  tf.contrib.eager.defun(f)` multiple times; this difference is due to the fact\n  that `defun` only captures the subgraph of TensorFlow operations that is\n  constructed when `f` is called in a graph-building context.\n\n  _Python Control Flow_\n\n  The structure of many machine learning computations depend upon whether one is\n  training or validating, and it is common to nest specialized logic under `if\n  training:` blocks. By mapping each input signature to a unique graph, `defun`\n  lets users transparently compile such code, as the following code snippet\n  demonstrates:\n\n  ```python\n  import tensorflow as tf\n\n  tf.compat.v1.enable_eager_execution()\n\n  @tf.contrib.eager.defun\n  def lossy_matmul(W, x, training=True):\n    outputs = tf.matmul(W, x)\n    if training:\n      outputs = tf.nn.dropout(outputs, keep_probability=0.2)\n    return outputs\n\n  W = tf.random.normal((3, 5))\n  x = tf.random.normal((5, 1))\n\n  # Executes a graph that applies dropout.\n  lossy_outputs = lossy_matmul(W, x, training=True)\n\n  # Executes a graph that does not apply dropout.\n  exact_outputs = lossy_matmul(W, x, training=False)\n  ```\n\n  _TensorFlow Control Flow_\n\n  When `autograph` is `True`, data-dependent control flow is allowed as well.\n  Control flow statements that depend on `Tensor` values are staged into\n  corresponding TensorFlow ops. For example, the following code will work as\n  expected:\n\n  ```python\n  @tf.contrib.eager.defun\n  def dynamic_rnn_loop(cell, seq):\n    state, output = cell.zero_state()\n    for input in seq:\n      state, output = cell(input, state)\n    return output\n  ```\n\n  For more information see `tf.autograph`.\n\n  _Variables_\n\n  TensorFlow operations related to variable creation and initialization are\n  automatically lifted out of the graphs generated by `defun`. In practice, this\n  implies that variable creation and initialization only happen the first time\n  `F` is called, and that variables are reused every time thereafter. Many\n  TensorFlow APIs, like `tf.keras.layers.Layer` objects, create variables the\n  first time they are called and reuse them thereafter. Automatic variable\n  lifting makes it possible to compile these APIs without extra effort, at the\n  cost of introducing a discrepancy between the semantics of executing Python\n  functions and their corresponding compiled functions. For example:\n\n  ```python\n  import tensorflow as tf\n\n  tf.compat.v1.enable_eager_execution()\n\n  def fn():\n    x = tf.Variable(0.0)\n    x.assign_add(1.0)\n    return x.read_value()\n\n  # `fn` is a Python function, so x is created, initialized, and destroyed upon\n  # every invocation\n  assert fn().numpy() == fn().numpy() == 1.0\n\n  compiled = tf.contrib.eager.defun(fn)\n\n  # Compiling `fn` with `defun` hoists all variables outside of the generated\n  # graph, so initialization happens exactly once.\n  assert compiled().numpy() == 1.0\n  assert compiled().numpy() == 2.0\n  ```\n\n  Finally, because each input signature is bound to a unique graph, if your\n  Python function constructs `tf.Variable` objects, then each graph constructed\n  for that Python function will reference a unique set of variables. To\n  circumvent this problem, we recommend against compiling Python functions that\n  create `tf.Variable` objects. Instead, Python functions should either\n  lexically close over `tf.Variable` objects or accept them as arguments,\n  preferably encapsulated in an object-oriented container. If you must create\n  variables inside your Python function and you want each graph generated for it\n  to reference the same set of variables, add logic to your Python function that\n  ensures that variables are only created the first time it is called and are\n  reused for every subsequent invocation; note that this is precisely what\n  `tf.keras.layers.Layer` objects do, so we recommend using them to represent\n  variable-bearing computations whenever possible.\n\n  Args:\n    func: function to be compiled. If `func` is None, returns a\n      decorator that can be invoked with a single argument - `func`. The\n      end result is equivalent to providing all the arguments up front.\n      In other words, defun(input_signature=...)(func) is equivalent to\n      defun(func, input_signature=...). The former allows\n      the following use case:\n        @tf.contrib.eager.defun(input_signature=...)\n        def foo(...):\n          ...\n\n    input_signature: A possibly nested sequence of\n      `tf.contrib.eager.TensorSpec` objects specifying the shapes and dtypes of\n      the Tensors that will be supplied to this function. If `None`, a separate\n      function is instantiated for each inferred input signature.  If a\n      signature is specified, every input to `func` must be a `Tensor`, and\n      `func` cannot accept `**kwargs`.\n    autograph: Whether `func` should be compiled before\n      constructing the graph. See https://www.tensorflow.org/guide/autograph\n      for more information.\n    experimental_autograph_options: Experimental knobs (in the form of a tuple\n      of tensorflow.autograph.Feature values) to control behavior when\n      autograph=True.\n    experimental_relax_shapes: When true, argument shapes may be relaxed to\n      avoid unnecessary retracing.\n\n  Returns:\n     If `func` is not None, returns a callable that will execute the compiled\n     function (and return zero or more `tf.Tensor` objects).\n     If `func` is None, returns a decorator that, when invoked with a single\n     `func` argument, returns a callable equivalent to the case above.\n\n  Raises:\n    TypeError: If `input_signature` is neither `None` nor a sequence of\n      `tf.contrib.eager.TensorSpec` objects.\n  \"\"\"\n  return defun_with_attributes(\n      func=func,\n      input_signature=input_signature,\n      autograph=autograph,\n      experimental_autograph_options=experimental_autograph_options,\n      experimental_relax_shapes=experimental_relax_shapes)\n\n\n@tf_export(\"__internal__.function.defun_with_attributes\", v1=[])\ndef defun_with_attributes(func=None,\n                          input_signature=None,\n                          attributes=None,\n                          autograph=True,\n                          experimental_autograph_options=None,\n                          jit_compile=None,\n                          experimental_relax_shapes=False,\n                          experimental_follow_type_hints=False):\n  \"\"\"Compiles a Python function into a callable TensorFlow graph.\n\n  This function supports adding extra function attributes. See detailed\n  documentation in defun(). Currently this is not exposed in public API since we\n  don't expect user to directly use attributes, and attribute won't work by\n  itself. This assumption might change in future.\n\n  Args:\n    func: function to be compiled.\n    input_signature: same as defun()'s input_signature.\n    attributes: A dictionary of arguments which will be added to function def as\n      attributes. Currently only support primitive types as value, and only\n      allowlisted attribute name is allowed. Unallowlisted attribute name or\n      unsupported value will result into ValueError. `func_name` is also one of\n      the allowlisted argument which is a python string, and sets the name for\n      this `ConcreteFunction` in the graph.\n    autograph: same as defun()'s autograph.\n    experimental_autograph_options: same as defun()'s\n      experimental_autograph_options.\n    jit_compile: same as defun()'s jit_compile.\n    experimental_relax_shapes: same as defun()'s experimental_relax_shapes\n    experimental_follow_type_hints: see `tf.function`.\n\n  Returns:\n    Same as the return value of defun, with attributes added to the function in\n    graph.\n  \"\"\"\n  if input_signature is not None:\n    validate_signature(input_signature)\n\n  # TODO(apassos): deal with captured global state. Deal with control flow.\n  def decorated(function):\n    try:\n      if attributes:\n        name = attributes.pop(\"func_name\", function.__name__)\n      else:\n        name = function.__name__\n    except AttributeError:\n      name = \"function\"\n    return tf_decorator.make_decorator(\n        function,\n        Function(\n            function,\n            name,\n            input_signature=input_signature,\n            attributes=attributes,\n            autograph=autograph,\n            autograph_options=experimental_autograph_options,\n            jit_compile=jit_compile,\n            experimental_relax_shapes=experimental_relax_shapes,\n            experimental_follow_type_hints=experimental_follow_type_hints))\n\n  # This code path is for the `foo = tfe.defun(foo, ...)` use case\n  if func is not None:\n    return decorated(func)\n\n  # This code path is for the\n  #\n  # @tfe.defun(...)\n  # def foo(...):\n  #    ...\n  #\n  # use case, which is equivalent to `foo = tfe.defun(...)(foo)`\n  return decorated\n\n\n# When a method is bound to objects of this type, it allows AutoGraph to\n# recover a weak reference the original method's self pointer, so that it can\n# execute it consistent with class_method_to_instance_method's\n# bound_method_wrapper.\n# TODO(b/119246461): This is not pretty. Use a descriptor instead?\nclass TfMethodTarget(object):\n  \"\"\"Binding target for methods replaced by function and defun.\"\"\"\n\n  __slots__ = (\"weakrefself_target__\", \"weakrefself_func__\")\n\n  def __init__(self, target, original_python_function):\n    self.weakrefself_target__ = target\n    self.weakrefself_func__ = weakref.ref(original_python_function)\n\n  @property\n  def target(self):\n    return self.weakrefself_target__()\n\n  @property\n  def target_class(self):\n    true_self = self.weakrefself_target__()\n    if tf_inspect.isclass(true_self):\n      # Class method\n      return true_self\n    else:\n      return true_self.__class__\n\n  def call(self, args, kwargs):\n    wrapped_fn = self.weakrefself_func__()\n    if tf_inspect.ismethod(wrapped_fn):\n      wrapped_fn = six.get_unbound_function(wrapped_fn)\n    return wrapped_fn(self.weakrefself_target__(), *args, **kwargs)\n\n\ndef class_method_to_instance_method(original_function, instance):\n  \"\"\"Constructs a new `Function` with `self` bound.\"\"\"\n  weak_instance = weakref.ref(instance)\n\n  # Note: while we could bind to a weakref proxy instead, that causes the\n  # bound method to be unhashable.\n  bound_method = types_lib.MethodType(\n      original_function.python_function,\n      TfMethodTarget(weak_instance, original_function.python_function))\n\n  # original_function is expected to be of one of the two `Function` types\n  # (defined either in function.py or def_function.py).\n  assert hasattr(original_function, \"_name\")\n  assert hasattr(original_function, \"_autograph\")\n  assert hasattr(original_function, \"_function_spec\")\n  assert hasattr(original_function, \"python_function\")\n\n  weak_bound_method_wrapper = None\n  def bound_method_wrapper(*args, **kwargs):\n    \"\"\"Wraps either a dummy MethodType or a converted AutoGraph function.\"\"\"\n    # __wrapped__ allows AutoGraph to swap in a converted function.\n    strong_bound_method_wrapper = weak_bound_method_wrapper()\n    wrapped_fn = strong_bound_method_wrapper.__wrapped__\n\n    if wrapped_fn is strong_bound_method_wrapper.__original_wrapped__:\n      # If __wrapped__ was not replaced, then call original_function.\n      # TODO(mdan): For better consistency, use the wrapper's call().\n      wrapped_fn = original_function.python_function\n      if tf_inspect.ismethod(wrapped_fn):\n        wrapped_fn = six.get_unbound_function(wrapped_fn)\n      return wrapped_fn(weak_instance(), *args, **kwargs)\n\n    # If __wrapped__ was replaced, then it is always an unbound function.\n    # However, the replacer is still responsible for attaching self properly.\n    # TODO(mdan): Is it possible to do it here instead?\n    return wrapped_fn(*args, **kwargs)\n  weak_bound_method_wrapper = weakref.ref(bound_method_wrapper)\n\n  # pylint: disable=protected-access\n  # We make a dummy MethodType object to generate the correct bound method\n  # signature. The actual call is to a function with a weak reference to\n  # `instance`.\n  instance_func = type(original_function)(\n      tf_decorator.make_decorator(bound_method, bound_method_wrapper),\n      name=original_function._name,\n      autograph=original_function._autograph,\n      input_signature=original_function.input_signature,\n      experimental_relax_shapes=original_function._experimental_relax_shapes,\n      jit_compile=original_function._jit_compile)\n  # pylint: enable=protected-access\n\n  # We wrap the the bound method with tf_decorator so inspection works correctly\n  wrapped_instance_func = tf_decorator.make_decorator(bound_method,\n                                                      instance_func)\n  return wrapped_instance_func\n\n\nclass _FunctionGarbageCollector(object):\n  \"\"\"Cleans up cycles when a defun goes out of scope.\"\"\"\n\n  __slots__ = [\"_cache\"]\n\n  def __init__(self, cache):\n    self._cache = cache\n\n  def __del__(self):\n    if func_graph_module is None or memory is None:\n      return\n    try:\n      while self._cache:\n        self._cache.popitem()\n      memory.dismantle_ordered_dict(self._cache)\n    except:  # pylint: disable=bare-except\n      pass\n\n\nclass ConcreteFunctionGarbageCollector(object):\n  \"\"\"Cleans up reference cycles when a `ConcreteFunction` goes out of scope.\"\"\"\n\n  __slots__ = [\"_func_graph\"]\n\n  def __init__(self, func_graph):\n    self._func_graph = func_graph\n\n  def release(self):\n    \"\"\"Call off the FuncGraph deletion.\"\"\"\n    self._func_graph = None\n\n  def __del__(self):\n    if func_graph_module is None or memory is None or self._func_graph is None:\n      return\n    try:\n      func_graph_module.dismantle_func_graph(self._func_graph)\n    except:  # pylint: disable=bare-except\n      pass\n\n\nclass _Marker(object):\n  \"\"\"Markers used to pretty-print nested args in function signatures.\"\"\"\n\n  __slots__ = [\"_s\"]\n\n  def __init__(self, s):\n    self._s = s\n\n  def __repr__(self):\n    return str(self._s)\n\n\ndef _structure_summary(structure):\n  \"\"\"Displays a summary of the nesting structure of the given value.\"\"\"\n\n  def type_name(x):\n    if isinstance(x, type_spec.TypeSpec):\n      return x.value_type.__name__\n    else:\n      return type(x).__name__\n\n  markers = [_Marker(type_name(v)) for v in nest.flatten(structure)]\n  return str(nest.pack_sequence_as(structure, markers))\n\n\ndef _contains_type_spec(value):\n  return any(isinstance(x, type_spec.TypeSpec) for x in nest.flatten(value))\n"], "filenames": ["tensorflow/python/eager/def_function.py", "tensorflow/python/eager/def_function_test.py", "tensorflow/python/eager/function.py"], "buggy_code_start_loc": [575, 27, 3040], "buggy_code_end_loc": [617, 1263, 3041], "fixing_code_start_loc": [575, 28, 3040], "fixing_code_end_loc": [617, 1377, 3041], "type": "CWE-662", "message": "TensorFlow is an open source platform for machine learning. In affected versions the code behind `tf.function` API can be made to deadlock when two `tf.function` decorated Python functions are mutually recursive. This occurs due to using a non-reentrant `Lock` Python object. Loading any model which contains mutually recursive functions is vulnerable. An attacker can cause denial of service by causing users to load such models and calling a recursive `tf.function`, although this is not a frequent scenario. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2021-41213", "sourceIdentifier": "security-advisories@github.com", "published": "2021-11-05T23:15:08.217", "lastModified": "2022-10-20T21:25:47.840", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an open source platform for machine learning. In affected versions the code behind `tf.function` API can be made to deadlock when two `tf.function` decorated Python functions are mutually recursive. This occurs due to using a non-reentrant `Lock` Python object. Loading any model which contains mutually recursive functions is vulnerable. An attacker can cause denial of service by causing users to load such models and calling a recursive `tf.function`, although this is not a frequent scenario. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto para el aprendizaje autom\u00e1tico. En las versiones afectadas, el c\u00f3digo detr\u00e1s de la API \"tf.function\" puede llegar a bloquearse cuando dos funciones de Python decoradas con \"tf.function\" son recursivas entre s\u00ed. Esto ocurre debido a que es usado un objeto Python \"Lock\" no recursivo. La carga de cualquier modelo que contenga funciones mutuamente recursivas es vulnerable. Un atacante puede causar una denegaci\u00f3n de servicio al causar que usuarios carguen dichos modelos y llamen a una funci\u00f3n recursiva \"tf.function\", aunque esto no es un escenario frecuente. La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.7.0. Tambi\u00e9n ser\u00e1 incluida este commit en TensorFlow versi\u00f3n 2.6.1, TensorFlow versi\u00f3n 2.5.2, y TensorFlow versi\u00f3n 2.4.4, ya que estos tambi\u00e9n est\u00e1n afectados y todav\u00eda est\u00e1n en el rango admitido"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-662"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-667"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.4", "matchCriteriaId": "0E596567-6F67-4880-8EC4-CB262BF02E0D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.5.0", "versionEndExcluding": "2.5.2", "matchCriteriaId": "035CDF63-1548-4FB4-B8A9-B8D328FAF910"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.6.0", "versionEndExcluding": "2.6.1", "matchCriteriaId": "5D68D8D1-DB27-4395-9D3D-2BED901B852C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.7.0:rc0:*:*:*:*:*:*", "matchCriteriaId": "A58EDA5C-66D6-46F1-962E-60AFB7C784A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.7.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "89522760-C2DF-400D-9624-626D8F160CBA"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/afac8158d43691661ad083f6dd9e56f327c1dcb7", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-h67m-xg8f-fxcf", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/afac8158d43691661ad083f6dd9e56f327c1dcb7"}}