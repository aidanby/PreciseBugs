{"buggy_code": ["/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.io;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.io.FileWriteMode.APPEND;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.TreeTraverser;\nimport com.google.common.graph.SuccessorsFunction;\nimport com.google.common.graph.Traverser;\nimport com.google.common.hash.HashCode;\nimport com.google.common.hash.HashFunction;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.RandomAccessFile;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * Provides utility methods for working with {@linkplain File files}.\n *\n * <p>{@link java.nio.file.Path} users will find similar utilities in {@link MoreFiles} and the\n * JDK's {@link java.nio.file.Files} class.\n *\n * @author Chris Nokleberg\n * @author Colin Decker\n * @since 1.0\n */\n@GwtIncompatible\npublic final class Files {\n\n  /** Maximum loop count when creating temp directories. */\n  private static final int TEMP_DIR_ATTEMPTS = 10000;\n\n  private Files() {}\n\n  /**\n   * Returns a buffered reader that reads from a file using the given character set.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#newBufferedReader(java.nio.file.Path, Charset)}.\n   *\n   * @param file the file to read from\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @return the buffered reader\n   */\n  @Beta\n  public static BufferedReader newReader(File file, Charset charset) throws FileNotFoundException {\n    checkNotNull(file);\n    checkNotNull(charset);\n    return new BufferedReader(new InputStreamReader(new FileInputStream(file), charset));\n  }\n\n  /**\n   * Returns a buffered writer that writes to a file using the given character set.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#newBufferedWriter(java.nio.file.Path, Charset,\n   * java.nio.file.OpenOption...)}.\n   *\n   * @param file the file to write to\n   * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @return the buffered writer\n   */\n  @Beta\n  public static BufferedWriter newWriter(File file, Charset charset) throws FileNotFoundException {\n    checkNotNull(file);\n    checkNotNull(charset);\n    return new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), charset));\n  }\n\n  /**\n   * Returns a new {@link ByteSource} for reading bytes from the given file.\n   *\n   * @since 14.0\n   */\n  public static ByteSource asByteSource(File file) {\n    return new FileByteSource(file);\n  }\n\n  private static final class FileByteSource extends ByteSource {\n\n    private final File file;\n\n    private FileByteSource(File file) {\n      this.file = checkNotNull(file);\n    }\n\n    @Override\n    public FileInputStream openStream() throws IOException {\n      return new FileInputStream(file);\n    }\n\n    @Override\n    public Optional<Long> sizeIfKnown() {\n      if (file.isFile()) {\n        return Optional.of(file.length());\n      } else {\n        return Optional.absent();\n      }\n    }\n\n    @Override\n    public long size() throws IOException {\n      if (!file.isFile()) {\n        throw new FileNotFoundException(file.toString());\n      }\n      return file.length();\n    }\n\n    @Override\n    public byte[] read() throws IOException {\n      Closer closer = Closer.create();\n      try {\n        FileInputStream in = closer.register(openStream());\n        return ByteStreams.toByteArray(in, in.getChannel().size());\n      } catch (Throwable e) {\n        throw closer.rethrow(e);\n      } finally {\n        closer.close();\n      }\n    }\n\n    @Override\n    public String toString() {\n      return \"Files.asByteSource(\" + file + \")\";\n    }\n  }\n\n  /**\n   * Returns a new {@link ByteSink} for writing bytes to the given file. The given {@code modes}\n   * control how the file is opened for writing. When no mode is provided, the file will be\n   * truncated before writing. When the {@link FileWriteMode#APPEND APPEND} mode is provided, writes\n   * will append to the end of the file without truncating it.\n   *\n   * @since 14.0\n   */\n  public static ByteSink asByteSink(File file, FileWriteMode... modes) {\n    return new FileByteSink(file, modes);\n  }\n\n  private static final class FileByteSink extends ByteSink {\n\n    private final File file;\n    private final ImmutableSet<FileWriteMode> modes;\n\n    private FileByteSink(File file, FileWriteMode... modes) {\n      this.file = checkNotNull(file);\n      this.modes = ImmutableSet.copyOf(modes);\n    }\n\n    @Override\n    public FileOutputStream openStream() throws IOException {\n      return new FileOutputStream(file, modes.contains(APPEND));\n    }\n\n    @Override\n    public String toString() {\n      return \"Files.asByteSink(\" + file + \", \" + modes + \")\";\n    }\n  }\n\n  /**\n   * Returns a new {@link CharSource} for reading character data from the given file using the given\n   * character set.\n   *\n   * @since 14.0\n   */\n  public static CharSource asCharSource(File file, Charset charset) {\n    return asByteSource(file).asCharSource(charset);\n  }\n\n  /**\n   * Returns a new {@link CharSink} for writing character data to the given file using the given\n   * character set. The given {@code modes} control how the file is opened for writing. When no mode\n   * is provided, the file will be truncated before writing. When the {@link FileWriteMode#APPEND\n   * APPEND} mode is provided, writes will append to the end of the file without truncating it.\n   *\n   * @since 14.0\n   */\n  public static CharSink asCharSink(File file, Charset charset, FileWriteMode... modes) {\n    return asByteSink(file, modes).asCharSink(charset);\n  }\n\n  /**\n   * Reads all bytes from a file into a byte array.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link java.nio.file.Files#readAllBytes}.\n   *\n   * @param file the file to read from\n   * @return a byte array containing all the bytes from file\n   * @throws IllegalArgumentException if the file is bigger than the largest possible byte array\n   *     (2^31 - 1)\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  public static byte[] toByteArray(File file) throws IOException {\n    return asByteSource(file).read();\n  }\n\n  /**\n   * Reads all characters from a file into a {@link String}, using the given character set.\n   *\n   * @param file the file to read from\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @return a string containing all the characters from the file\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSource(file, charset).read()}. This method is scheduled to be\n   *     removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public static String toString(File file, Charset charset) throws IOException {\n    return asCharSource(file, charset).read();\n  }\n\n  /**\n   * Overwrites a file with the contents of a byte array.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#write(java.nio.file.Path, byte[], java.nio.file.OpenOption...)}.\n   *\n   * @param from the bytes to write\n   * @param to the destination file\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  public static void write(byte[] from, File to) throws IOException {\n    asByteSink(to).write(from);\n  }\n\n  /**\n   * Writes a character sequence (such as a string) to a file using the given character set.\n   *\n   * @param from the character sequence to write\n   * @param to the destination file\n   * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSink(to, charset).write(from)}. This method is scheduled to be\n   *     removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public static void write(CharSequence from, File to, Charset charset) throws IOException {\n    asCharSink(to, charset).write(from);\n  }\n\n  /**\n   * Copies all bytes from a file to an output stream.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#copy(java.nio.file.Path, OutputStream)}.\n   *\n   * @param from the source file\n   * @param to the output stream\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  public static void copy(File from, OutputStream to) throws IOException {\n    asByteSource(from).copyTo(to);\n  }\n\n  /**\n   * Copies all the bytes from one file to another.\n   *\n   * <p>Copying is not an atomic operation - in the case of an I/O error, power loss, process\n   * termination, or other problems, {@code to} may not be a complete copy of {@code from}. If you\n   * need to guard against those conditions, you should employ other file-level synchronization.\n   *\n   * <p><b>Warning:</b> If {@code to} represents an existing file, that file will be overwritten\n   * with the contents of {@code from}. If {@code to} and {@code from} refer to the <i>same</i>\n   * file, the contents of that file will be deleted.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#copy(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption...)}.\n   *\n   * @param from the source file\n   * @param to the destination file\n   * @throws IOException if an I/O error occurs\n   * @throws IllegalArgumentException if {@code from.equals(to)}\n   */\n  @Beta\n  public static void copy(File from, File to) throws IOException {\n    checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n    asByteSource(from).copyTo(asByteSink(to));\n  }\n\n  /**\n   * Copies all characters from a file to an appendable object, using the given character set.\n   *\n   * @param from the source file\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @param to the appendable object\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSource(from, charset).copyTo(to)}. This method is scheduled to\n   *     be removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public\n  static void copy(File from, Charset charset, Appendable to) throws IOException {\n    asCharSource(from, charset).copyTo(to);\n  }\n\n  /**\n   * Appends a character sequence (such as a string) to a file using the given character set.\n   *\n   * @param from the character sequence to append\n   * @param to the destination file\n   * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSink(to, charset, FileWriteMode.APPEND).write(from)}. This\n   *     method is scheduled to be removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public\n  static void append(CharSequence from, File to, Charset charset) throws IOException {\n    asCharSink(to, charset, FileWriteMode.APPEND).write(from);\n  }\n\n  /**\n   * Returns true if the given files exist, are not directories, and contain the same bytes.\n   *\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  public static boolean equal(File file1, File file2) throws IOException {\n    checkNotNull(file1);\n    checkNotNull(file2);\n    if (file1 == file2 || file1.equals(file2)) {\n      return true;\n    }\n\n    /*\n     * Some operating systems may return zero as the length for files denoting system-dependent\n     * entities such as devices or pipes, in which case we must fall back on comparing the bytes\n     * directly.\n     */\n    long len1 = file1.length();\n    long len2 = file2.length();\n    if (len1 != 0 && len2 != 0 && len1 != len2) {\n      return false;\n    }\n    return asByteSource(file1).contentEquals(asByteSource(file2));\n  }\n\n  /**\n   * Atomically creates a new directory somewhere beneath the system's temporary directory (as\n   * defined by the {@code java.io.tmpdir} system property), and returns its name.\n   *\n   * <p>Use this method instead of {@link File#createTempFile(String, String)} when you wish to\n   * create a directory, not a regular file. A common pitfall is to call {@code createTempFile},\n   * delete the file and create a directory in its place, but this leads a race condition which can\n   * be exploited to create security vulnerabilities, especially when executable files are to be\n   * written into the directory.\n   *\n   * <p>This method assumes that the temporary volume is writable, has free inodes and free blocks,\n   * and that it will not be called thousands of times per second.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#createTempDirectory}.\n   *\n   * @return the newly-created directory\n   * @throws IllegalStateException if the directory could not be created\n   */\n  @Beta\n  public static File createTempDir() {\n    File baseDir = new File(System.getProperty(\"java.io.tmpdir\"));\n    @SuppressWarnings(\"GoodTime\") // reading system time without TimeSource\n    String baseName = System.currentTimeMillis() + \"-\";\n\n    for (int counter = 0; counter < TEMP_DIR_ATTEMPTS; counter++) {\n      File tempDir = new File(baseDir, baseName + counter);\n      if (tempDir.mkdir()) {\n        return tempDir;\n      }\n    }\n    throw new IllegalStateException(\n        \"Failed to create directory within \"\n            + TEMP_DIR_ATTEMPTS\n            + \" attempts (tried \"\n            + baseName\n            + \"0 to \"\n            + baseName\n            + (TEMP_DIR_ATTEMPTS - 1)\n            + ')');\n  }\n\n  /**\n   * Creates an empty file or updates the last updated timestamp on the same as the unix command of\n   * the same name.\n   *\n   * @param file the file to create or update\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  @SuppressWarnings(\"GoodTime\") // reading system time without TimeSource\n  public static void touch(File file) throws IOException {\n    checkNotNull(file);\n    if (!file.createNewFile() && !file.setLastModified(System.currentTimeMillis())) {\n      throw new IOException(\"Unable to update modification time of \" + file);\n    }\n  }\n\n  /**\n   * Creates any necessary but nonexistent parent directories of the specified file. Note that if\n   * this operation fails it may have succeeded in creating some (but not all) of the necessary\n   * parent directories.\n   *\n   * @throws IOException if an I/O error occurs, or if any necessary but nonexistent parent\n   *     directories of the specified file could not be created.\n   * @since 4.0\n   */\n  @Beta\n  public static void createParentDirs(File file) throws IOException {\n    checkNotNull(file);\n    File parent = file.getCanonicalFile().getParentFile();\n    if (parent == null) {\n      /*\n       * The given directory is a filesystem root. All zero of its ancestors exist. This doesn't\n       * mean that the root itself exists -- consider x:\\ on a Windows machine without such a drive\n       * -- or even that the caller can create it, but this method makes no such guarantees even for\n       * non-root files.\n       */\n      return;\n    }\n    parent.mkdirs();\n    if (!parent.isDirectory()) {\n      throw new IOException(\"Unable to create parent directories of \" + file);\n    }\n  }\n\n  /**\n   * Moves a file from one path to another. This method can rename a file and/or move it to a\n   * different directory. In either case {@code to} must be the target path for the file itself; not\n   * just the new name for the file or the path to the new parent directory.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link java.nio.file.Files#move}.\n   *\n   * @param from the source file\n   * @param to the destination file\n   * @throws IOException if an I/O error occurs\n   * @throws IllegalArgumentException if {@code from.equals(to)}\n   */\n  @Beta\n  public static void move(File from, File to) throws IOException {\n    checkNotNull(from);\n    checkNotNull(to);\n    checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n\n    if (!from.renameTo(to)) {\n      copy(from, to);\n      if (!from.delete()) {\n        if (!to.delete()) {\n          throw new IOException(\"Unable to delete \" + to);\n        }\n        throw new IOException(\"Unable to delete \" + from);\n      }\n    }\n  }\n\n  /**\n   * Reads the first line from a file. The line does not include line-termination characters, but\n   * does include other leading and trailing whitespace.\n   *\n   * @param file the file to read from\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @return the first line, or null if the file is empty\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSource(file, charset).readFirstLine()}. This method is\n   *     scheduled to be removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public\n  static String readFirstLine(File file, Charset charset) throws IOException {\n    return asCharSource(file, charset).readFirstLine();\n  }\n\n  /**\n   * Reads all of the lines from a file. The lines do not include line-termination characters, but\n   * do include other leading and trailing whitespace.\n   *\n   * <p>This method returns a mutable {@code List}. For an {@code ImmutableList}, use {@code\n   * Files.asCharSource(file, charset).readLines()}.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#readAllLines(java.nio.file.Path, Charset)}.\n   *\n   * @param file the file to read from\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @return a mutable {@link List} containing all the lines\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  public static List<String> readLines(File file, Charset charset) throws IOException {\n    // don't use asCharSource(file, charset).readLines() because that returns\n    // an immutable list, which would change the behavior of this method\n    return asCharSource(file, charset)\n        .readLines(\n            new LineProcessor<List<String>>() {\n              final List<String> result = Lists.newArrayList();\n\n              @Override\n              public boolean processLine(String line) {\n                result.add(line);\n                return true;\n              }\n\n              @Override\n              public List<String> getResult() {\n                return result;\n              }\n            });\n  }\n\n  /**\n   * Streams lines from a {@link File}, stopping when our callback returns false, or we have read\n   * all of the lines.\n   *\n   * @param file the file to read from\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @param callback the {@link LineProcessor} to use to handle the lines\n   * @return the output of processing the lines\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSource(file, charset).readLines(callback)}. This method is\n   *     scheduled to be removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  @CanIgnoreReturnValue // some processors won't return a useful result\n  public\n  static <T> T readLines(File file, Charset charset, LineProcessor<T> callback) throws IOException {\n    return asCharSource(file, charset).readLines(callback);\n  }\n\n  /**\n   * Process the bytes of a file.\n   *\n   * <p>(If this seems too complicated, maybe you're looking for {@link #toByteArray}.)\n   *\n   * @param file the file to read\n   * @param processor the object to which the bytes of the file are passed.\n   * @return the result of the byte processor\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asByteSource(file).read(processor)}. This method is scheduled to be\n   *     removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  @CanIgnoreReturnValue // some processors won't return a useful result\n  public\n  static <T> T readBytes(File file, ByteProcessor<T> processor) throws IOException {\n    return asByteSource(file).read(processor);\n  }\n\n  /**\n   * Computes the hash code of the {@code file} using {@code hashFunction}.\n   *\n   * @param file the file to read\n   * @param hashFunction the hash function to use to hash the data\n   * @return the {@link HashCode} of all of the bytes in the file\n   * @throws IOException if an I/O error occurs\n   * @since 12.0\n   * @deprecated Prefer {@code asByteSource(file).hash(hashFunction)}. This method is scheduled to\n   *     be removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public\n  static HashCode hash(File file, HashFunction hashFunction) throws IOException {\n    return asByteSource(file).hash(hashFunction);\n  }\n\n  /**\n   * Fully maps a file read-only in to memory as per {@link\n   * FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)}.\n   *\n   * <p>Files are mapped from offset 0 to its length.\n   *\n   * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n   *\n   * @param file the file to map\n   * @return a read-only buffer reflecting {@code file}\n   * @throws FileNotFoundException if the {@code file} does not exist\n   * @throws IOException if an I/O error occurs\n   * @see FileChannel#map(MapMode, long, long)\n   * @since 2.0\n   */\n  @Beta\n  public static MappedByteBuffer map(File file) throws IOException {\n    checkNotNull(file);\n    return map(file, MapMode.READ_ONLY);\n  }\n\n  /**\n   * Fully maps a file in to memory as per {@link\n   * FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)} using the requested {@link\n   * MapMode}.\n   *\n   * <p>Files are mapped from offset 0 to its length.\n   *\n   * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n   *\n   * @param file the file to map\n   * @param mode the mode to use when mapping {@code file}\n   * @return a buffer reflecting {@code file}\n   * @throws FileNotFoundException if the {@code file} does not exist\n   * @throws IOException if an I/O error occurs\n   * @see FileChannel#map(MapMode, long, long)\n   * @since 2.0\n   */\n  @Beta\n  public static MappedByteBuffer map(File file, MapMode mode) throws IOException {\n    return mapInternal(file, mode, -1);\n  }\n\n  /**\n   * Maps a file in to memory as per {@link FileChannel#map(java.nio.channels.FileChannel.MapMode,\n   * long, long)} using the requested {@link MapMode}.\n   *\n   * <p>Files are mapped from offset 0 to {@code size}.\n   *\n   * <p>If the mode is {@link MapMode#READ_WRITE} and the file does not exist, it will be created\n   * with the requested {@code size}. Thus this method is useful for creating memory mapped files\n   * which do not yet exist.\n   *\n   * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n   *\n   * @param file the file to map\n   * @param mode the mode to use when mapping {@code file}\n   * @return a buffer reflecting {@code file}\n   * @throws IOException if an I/O error occurs\n   * @see FileChannel#map(MapMode, long, long)\n   * @since 2.0\n   */\n  @Beta\n  public static MappedByteBuffer map(File file, MapMode mode, long size) throws IOException {\n    checkArgument(size >= 0, \"size (%s) may not be negative\", size);\n    return mapInternal(file, mode, size);\n  }\n\n  private static MappedByteBuffer mapInternal(File file, MapMode mode, long size)\n      throws IOException {\n    checkNotNull(file);\n    checkNotNull(mode);\n\n    Closer closer = Closer.create();\n    try {\n      RandomAccessFile raf =\n          closer.register(new RandomAccessFile(file, mode == MapMode.READ_ONLY ? \"r\" : \"rw\"));\n      FileChannel channel = closer.register(raf.getChannel());\n      return channel.map(mode, 0, size == -1 ? channel.size() : size);\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }\n\n  /**\n   * Returns the lexically cleaned form of the path name, <i>usually</i> (but not always) equivalent\n   * to the original. The following heuristics are used:\n   *\n   * <ul>\n   *   <li>empty string becomes .\n   *   <li>. stays as .\n   *   <li>fold out ./\n   *   <li>fold out ../ when possible\n   *   <li>collapse multiple slashes\n   *   <li>delete trailing slashes (unless the path is just \"/\")\n   * </ul>\n   *\n   * <p>These heuristics do not always match the behavior of the filesystem. In particular, consider\n   * the path {@code a/../b}, which {@code simplifyPath} will change to {@code b}. If {@code a} is a\n   * symlink to {@code x}, {@code a/../b} may refer to a sibling of {@code x}, rather than the\n   * sibling of {@code a} referred to by {@code b}.\n   *\n   * @since 11.0\n   */\n  @Beta\n  public static String simplifyPath(String pathname) {\n    checkNotNull(pathname);\n    if (pathname.length() == 0) {\n      return \".\";\n    }\n\n    // split the path apart\n    Iterable<String> components = Splitter.on('/').omitEmptyStrings().split(pathname);\n    List<String> path = new ArrayList<>();\n\n    // resolve ., .., and //\n    for (String component : components) {\n      switch (component) {\n        case \".\":\n          continue;\n        case \"..\":\n          if (path.size() > 0 && !path.get(path.size() - 1).equals(\"..\")) {\n            path.remove(path.size() - 1);\n          } else {\n            path.add(\"..\");\n          }\n          break;\n        default:\n          path.add(component);\n          break;\n      }\n    }\n\n    // put it back together\n    String result = Joiner.on('/').join(path);\n    if (pathname.charAt(0) == '/') {\n      result = \"/\" + result;\n    }\n\n    while (result.startsWith(\"/../\")) {\n      result = result.substring(3);\n    }\n    if (result.equals(\"/..\")) {\n      result = \"/\";\n    } else if (\"\".equals(result)) {\n      result = \".\";\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns the <a href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> for\n   * the given file name, or the empty string if the file has no extension. The result does not\n   * include the '{@code .}'.\n   *\n   * <p><b>Note:</b> This method simply returns everything after the last '{@code .}' in the file's\n   * name as determined by {@link File#getName}. It does not account for any filesystem-specific\n   * behavior that the {@link File} API does not already account for. For example, on NTFS it will\n   * report {@code \"txt\"} as the extension for the filename {@code \"foo.exe:.txt\"} even though NTFS\n   * will drop the {@code \":.txt\"} part of the name when the file is actually created on the\n   * filesystem due to NTFS's <a href=\"https://goo.gl/vTpJi4\">Alternate Data Streams</a>.\n   *\n   * @since 11.0\n   */\n  @Beta\n  public static String getFileExtension(String fullName) {\n    checkNotNull(fullName);\n    String fileName = new File(fullName).getName();\n    int dotIndex = fileName.lastIndexOf('.');\n    return (dotIndex == -1) ? \"\" : fileName.substring(dotIndex + 1);\n  }\n\n  /**\n   * Returns the file name without its <a\n   * href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> or path. This is\n   * similar to the {@code basename} unix command. The result does not include the '{@code .}'.\n   *\n   * @param file The name of the file to trim the extension from. This can be either a fully\n   *     qualified file name (including a path) or just a file name.\n   * @return The file name without its path or extension.\n   * @since 14.0\n   */\n  @Beta\n  public static String getNameWithoutExtension(String file) {\n    checkNotNull(file);\n    String fileName = new File(file).getName();\n    int dotIndex = fileName.lastIndexOf('.');\n    return (dotIndex == -1) ? fileName : fileName.substring(0, dotIndex);\n  }\n\n  /**\n   * Returns a {@link TreeTraverser} instance for {@link File} trees.\n   *\n   * <p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no\n   * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In\n   * this case, iterables created by this traverser could contain files that are outside of the\n   * given directory or even be infinite if there is a symbolic link loop.\n   *\n   * @since 15.0\n   * @deprecated The returned {@link TreeTraverser} type is deprecated. Use the replacement method\n   *     {@link #fileTraverser()} instead with the same semantics as this method.\n   */\n  @Deprecated\n  static TreeTraverser<File> fileTreeTraverser() {\n    return FILE_TREE_TRAVERSER;\n  }\n\n  private static final TreeTraverser<File> FILE_TREE_TRAVERSER =\n      new TreeTraverser<File>() {\n        @Override\n        public Iterable<File> children(File file) {\n          return fileTreeChildren(file);\n        }\n\n        @Override\n        public String toString() {\n          return \"Files.fileTreeTraverser()\";\n        }\n      };\n\n  /**\n   * Returns a {@link Traverser} instance for the file and directory tree. The returned traverser\n   * starts from a {@link File} and will return all files and directories it encounters.\n   *\n   * <p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no\n   * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In\n   * this case, iterables created by this traverser could contain files that are outside of the\n   * given directory or even be infinite if there is a symbolic link loop.\n   *\n   * <p>If available, consider using {@link MoreFiles#fileTraverser()} instead. It behaves the same\n   * except that it doesn't follow symbolic links and returns {@code Path} instances.\n   *\n   * <p>If the {@link File} passed to one of the {@link Traverser} methods does not exist or is not\n   * a directory, no exception will be thrown and the returned {@link Iterable} will contain a\n   * single element: that file.\n   *\n   * <p>Example: {@code Files.fileTraverser().depthFirstPreOrder(new File(\"/\"))} may return files\n   * with the following paths: {@code [\"/\", \"/etc\", \"/etc/config.txt\", \"/etc/fonts\", \"/home\",\n   * \"/home/alice\", ...]}\n   *\n   * @since 23.5\n   */\n  @Beta\n  public static Traverser<File> fileTraverser() {\n    return Traverser.forTree(FILE_TREE);\n  }\n\n  private static final SuccessorsFunction<File> FILE_TREE =\n      new SuccessorsFunction<File>() {\n        @Override\n        public Iterable<File> successors(File file) {\n          return fileTreeChildren(file);\n        }\n      };\n\n  private static Iterable<File> fileTreeChildren(File file) {\n    // check isDirectory() just because it may be faster than listFiles() on a non-directory\n    if (file.isDirectory()) {\n      File[] files = file.listFiles();\n      if (files != null) {\n        return Collections.unmodifiableList(Arrays.asList(files));\n      }\n    }\n\n    return Collections.emptyList();\n  }\n\n  /**\n   * Returns a predicate that returns the result of {@link File#isDirectory} on input files.\n   *\n   * @since 15.0\n   */\n  @Beta\n  public static Predicate<File> isDirectory() {\n    return FilePredicate.IS_DIRECTORY;\n  }\n\n  /**\n   * Returns a predicate that returns the result of {@link File#isFile} on input files.\n   *\n   * @since 15.0\n   */\n  @Beta\n  public static Predicate<File> isFile() {\n    return FilePredicate.IS_FILE;\n  }\n\n  private enum FilePredicate implements Predicate<File> {\n    IS_DIRECTORY {\n      @Override\n      public boolean apply(File file) {\n        return file.isDirectory();\n      }\n\n      @Override\n      public String toString() {\n        return \"Files.isDirectory()\";\n      }\n    },\n\n    IS_FILE {\n      @Override\n      public boolean apply(File file) {\n        return file.isFile();\n      }\n\n      @Override\n      public String toString() {\n        return \"Files.isFile()\";\n      }\n    }\n  }\n}\n", "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.io;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.io.FileWriteMode.APPEND;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.TreeTraverser;\nimport com.google.common.graph.SuccessorsFunction;\nimport com.google.common.graph.Traverser;\nimport com.google.common.hash.HashCode;\nimport com.google.common.hash.HashFunction;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.RandomAccessFile;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * Provides utility methods for working with {@linkplain File files}.\n *\n * <p>{@link java.nio.file.Path} users will find similar utilities in {@link MoreFiles} and the\n * JDK's {@link java.nio.file.Files} class.\n *\n * @author Chris Nokleberg\n * @author Colin Decker\n * @since 1.0\n */\n@GwtIncompatible\npublic final class Files {\n\n  /** Maximum loop count when creating temp directories. */\n  private static final int TEMP_DIR_ATTEMPTS = 10000;\n\n  private Files() {}\n\n  /**\n   * Returns a buffered reader that reads from a file using the given character set.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#newBufferedReader(java.nio.file.Path, Charset)}.\n   *\n   * @param file the file to read from\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @return the buffered reader\n   */\n  @Beta\n  public static BufferedReader newReader(File file, Charset charset) throws FileNotFoundException {\n    checkNotNull(file);\n    checkNotNull(charset);\n    return new BufferedReader(new InputStreamReader(new FileInputStream(file), charset));\n  }\n\n  /**\n   * Returns a buffered writer that writes to a file using the given character set.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#newBufferedWriter(java.nio.file.Path, Charset,\n   * java.nio.file.OpenOption...)}.\n   *\n   * @param file the file to write to\n   * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @return the buffered writer\n   */\n  @Beta\n  public static BufferedWriter newWriter(File file, Charset charset) throws FileNotFoundException {\n    checkNotNull(file);\n    checkNotNull(charset);\n    return new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), charset));\n  }\n\n  /**\n   * Returns a new {@link ByteSource} for reading bytes from the given file.\n   *\n   * @since 14.0\n   */\n  public static ByteSource asByteSource(File file) {\n    return new FileByteSource(file);\n  }\n\n  private static final class FileByteSource extends ByteSource {\n\n    private final File file;\n\n    private FileByteSource(File file) {\n      this.file = checkNotNull(file);\n    }\n\n    @Override\n    public FileInputStream openStream() throws IOException {\n      return new FileInputStream(file);\n    }\n\n    @Override\n    public Optional<Long> sizeIfKnown() {\n      if (file.isFile()) {\n        return Optional.of(file.length());\n      } else {\n        return Optional.absent();\n      }\n    }\n\n    @Override\n    public long size() throws IOException {\n      if (!file.isFile()) {\n        throw new FileNotFoundException(file.toString());\n      }\n      return file.length();\n    }\n\n    @Override\n    public byte[] read() throws IOException {\n      Closer closer = Closer.create();\n      try {\n        FileInputStream in = closer.register(openStream());\n        return ByteStreams.toByteArray(in, in.getChannel().size());\n      } catch (Throwable e) {\n        throw closer.rethrow(e);\n      } finally {\n        closer.close();\n      }\n    }\n\n    @Override\n    public String toString() {\n      return \"Files.asByteSource(\" + file + \")\";\n    }\n  }\n\n  /**\n   * Returns a new {@link ByteSink} for writing bytes to the given file. The given {@code modes}\n   * control how the file is opened for writing. When no mode is provided, the file will be\n   * truncated before writing. When the {@link FileWriteMode#APPEND APPEND} mode is provided, writes\n   * will append to the end of the file without truncating it.\n   *\n   * @since 14.0\n   */\n  public static ByteSink asByteSink(File file, FileWriteMode... modes) {\n    return new FileByteSink(file, modes);\n  }\n\n  private static final class FileByteSink extends ByteSink {\n\n    private final File file;\n    private final ImmutableSet<FileWriteMode> modes;\n\n    private FileByteSink(File file, FileWriteMode... modes) {\n      this.file = checkNotNull(file);\n      this.modes = ImmutableSet.copyOf(modes);\n    }\n\n    @Override\n    public FileOutputStream openStream() throws IOException {\n      return new FileOutputStream(file, modes.contains(APPEND));\n    }\n\n    @Override\n    public String toString() {\n      return \"Files.asByteSink(\" + file + \", \" + modes + \")\";\n    }\n  }\n\n  /**\n   * Returns a new {@link CharSource} for reading character data from the given file using the given\n   * character set.\n   *\n   * @since 14.0\n   */\n  public static CharSource asCharSource(File file, Charset charset) {\n    return asByteSource(file).asCharSource(charset);\n  }\n\n  /**\n   * Returns a new {@link CharSink} for writing character data to the given file using the given\n   * character set. The given {@code modes} control how the file is opened for writing. When no mode\n   * is provided, the file will be truncated before writing. When the {@link FileWriteMode#APPEND\n   * APPEND} mode is provided, writes will append to the end of the file without truncating it.\n   *\n   * @since 14.0\n   */\n  public static CharSink asCharSink(File file, Charset charset, FileWriteMode... modes) {\n    return asByteSink(file, modes).asCharSink(charset);\n  }\n\n  /**\n   * Reads all bytes from a file into a byte array.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link java.nio.file.Files#readAllBytes}.\n   *\n   * @param file the file to read from\n   * @return a byte array containing all the bytes from file\n   * @throws IllegalArgumentException if the file is bigger than the largest possible byte array\n   *     (2^31 - 1)\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  public static byte[] toByteArray(File file) throws IOException {\n    return asByteSource(file).read();\n  }\n\n  /**\n   * Reads all characters from a file into a {@link String}, using the given character set.\n   *\n   * @param file the file to read from\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @return a string containing all the characters from the file\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSource(file, charset).read()}. This method is scheduled to be\n   *     removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public static String toString(File file, Charset charset) throws IOException {\n    return asCharSource(file, charset).read();\n  }\n\n  /**\n   * Overwrites a file with the contents of a byte array.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#write(java.nio.file.Path, byte[], java.nio.file.OpenOption...)}.\n   *\n   * @param from the bytes to write\n   * @param to the destination file\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  public static void write(byte[] from, File to) throws IOException {\n    asByteSink(to).write(from);\n  }\n\n  /**\n   * Writes a character sequence (such as a string) to a file using the given character set.\n   *\n   * @param from the character sequence to write\n   * @param to the destination file\n   * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSink(to, charset).write(from)}. This method is scheduled to be\n   *     removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public static void write(CharSequence from, File to, Charset charset) throws IOException {\n    asCharSink(to, charset).write(from);\n  }\n\n  /**\n   * Copies all bytes from a file to an output stream.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#copy(java.nio.file.Path, OutputStream)}.\n   *\n   * @param from the source file\n   * @param to the output stream\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  public static void copy(File from, OutputStream to) throws IOException {\n    asByteSource(from).copyTo(to);\n  }\n\n  /**\n   * Copies all the bytes from one file to another.\n   *\n   * <p>Copying is not an atomic operation - in the case of an I/O error, power loss, process\n   * termination, or other problems, {@code to} may not be a complete copy of {@code from}. If you\n   * need to guard against those conditions, you should employ other file-level synchronization.\n   *\n   * <p><b>Warning:</b> If {@code to} represents an existing file, that file will be overwritten\n   * with the contents of {@code from}. If {@code to} and {@code from} refer to the <i>same</i>\n   * file, the contents of that file will be deleted.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#copy(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption...)}.\n   *\n   * @param from the source file\n   * @param to the destination file\n   * @throws IOException if an I/O error occurs\n   * @throws IllegalArgumentException if {@code from.equals(to)}\n   */\n  @Beta\n  public static void copy(File from, File to) throws IOException {\n    checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n    asByteSource(from).copyTo(asByteSink(to));\n  }\n\n  /**\n   * Copies all characters from a file to an appendable object, using the given character set.\n   *\n   * @param from the source file\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @param to the appendable object\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSource(from, charset).copyTo(to)}. This method is scheduled to\n   *     be removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public\n  static void copy(File from, Charset charset, Appendable to) throws IOException {\n    asCharSource(from, charset).copyTo(to);\n  }\n\n  /**\n   * Appends a character sequence (such as a string) to a file using the given character set.\n   *\n   * @param from the character sequence to append\n   * @param to the destination file\n   * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSink(to, charset, FileWriteMode.APPEND).write(from)}. This\n   *     method is scheduled to be removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public\n  static void append(CharSequence from, File to, Charset charset) throws IOException {\n    asCharSink(to, charset, FileWriteMode.APPEND).write(from);\n  }\n\n  /**\n   * Returns true if the given files exist, are not directories, and contain the same bytes.\n   *\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  public static boolean equal(File file1, File file2) throws IOException {\n    checkNotNull(file1);\n    checkNotNull(file2);\n    if (file1 == file2 || file1.equals(file2)) {\n      return true;\n    }\n\n    /*\n     * Some operating systems may return zero as the length for files denoting system-dependent\n     * entities such as devices or pipes, in which case we must fall back on comparing the bytes\n     * directly.\n     */\n    long len1 = file1.length();\n    long len2 = file2.length();\n    if (len1 != 0 && len2 != 0 && len1 != len2) {\n      return false;\n    }\n    return asByteSource(file1).contentEquals(asByteSource(file2));\n  }\n\n  /**\n   * Atomically creates a new directory somewhere beneath the system's temporary directory (as\n   * defined by the {@code java.io.tmpdir} system property), and returns its name.\n   *\n   * <p>Use this method instead of {@link File#createTempFile(String, String)} when you wish to\n   * create a directory, not a regular file. A common pitfall is to call {@code createTempFile},\n   * delete the file and create a directory in its place, but this leads a race condition which can\n   * be exploited to create security vulnerabilities, especially when executable files are to be\n   * written into the directory.\n   *\n   * <p>This method assumes that the temporary volume is writable, has free inodes and free blocks,\n   * and that it will not be called thousands of times per second.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#createTempDirectory}.\n   *\n   * @return the newly-created directory\n   * @throws IllegalStateException if the directory could not be created\n   */\n  @Beta\n  public static File createTempDir() {\n    File baseDir = new File(System.getProperty(\"java.io.tmpdir\"));\n    @SuppressWarnings(\"GoodTime\") // reading system time without TimeSource\n    String baseName = System.currentTimeMillis() + \"-\";\n\n    for (int counter = 0; counter < TEMP_DIR_ATTEMPTS; counter++) {\n      File tempDir = new File(baseDir, baseName + counter);\n      if (tempDir.mkdir()) {\n        return tempDir;\n      }\n    }\n    throw new IllegalStateException(\n        \"Failed to create directory within \"\n            + TEMP_DIR_ATTEMPTS\n            + \" attempts (tried \"\n            + baseName\n            + \"0 to \"\n            + baseName\n            + (TEMP_DIR_ATTEMPTS - 1)\n            + ')');\n  }\n\n  /**\n   * Creates an empty file or updates the last updated timestamp on the same as the unix command of\n   * the same name.\n   *\n   * @param file the file to create or update\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  @SuppressWarnings(\"GoodTime\") // reading system time without TimeSource\n  public static void touch(File file) throws IOException {\n    checkNotNull(file);\n    if (!file.createNewFile() && !file.setLastModified(System.currentTimeMillis())) {\n      throw new IOException(\"Unable to update modification time of \" + file);\n    }\n  }\n\n  /**\n   * Creates any necessary but nonexistent parent directories of the specified file. Note that if\n   * this operation fails it may have succeeded in creating some (but not all) of the necessary\n   * parent directories.\n   *\n   * @throws IOException if an I/O error occurs, or if any necessary but nonexistent parent\n   *     directories of the specified file could not be created.\n   * @since 4.0\n   */\n  @Beta\n  public static void createParentDirs(File file) throws IOException {\n    checkNotNull(file);\n    File parent = file.getCanonicalFile().getParentFile();\n    if (parent == null) {\n      /*\n       * The given directory is a filesystem root. All zero of its ancestors exist. This doesn't\n       * mean that the root itself exists -- consider x:\\ on a Windows machine without such a drive\n       * -- or even that the caller can create it, but this method makes no such guarantees even for\n       * non-root files.\n       */\n      return;\n    }\n    parent.mkdirs();\n    if (!parent.isDirectory()) {\n      throw new IOException(\"Unable to create parent directories of \" + file);\n    }\n  }\n\n  /**\n   * Moves a file from one path to another. This method can rename a file and/or move it to a\n   * different directory. In either case {@code to} must be the target path for the file itself; not\n   * just the new name for the file or the path to the new parent directory.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link java.nio.file.Files#move}.\n   *\n   * @param from the source file\n   * @param to the destination file\n   * @throws IOException if an I/O error occurs\n   * @throws IllegalArgumentException if {@code from.equals(to)}\n   */\n  @Beta\n  public static void move(File from, File to) throws IOException {\n    checkNotNull(from);\n    checkNotNull(to);\n    checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n\n    if (!from.renameTo(to)) {\n      copy(from, to);\n      if (!from.delete()) {\n        if (!to.delete()) {\n          throw new IOException(\"Unable to delete \" + to);\n        }\n        throw new IOException(\"Unable to delete \" + from);\n      }\n    }\n  }\n\n  /**\n   * Reads the first line from a file. The line does not include line-termination characters, but\n   * does include other leading and trailing whitespace.\n   *\n   * @param file the file to read from\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @return the first line, or null if the file is empty\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSource(file, charset).readFirstLine()}. This method is\n   *     scheduled to be removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public\n  static String readFirstLine(File file, Charset charset) throws IOException {\n    return asCharSource(file, charset).readFirstLine();\n  }\n\n  /**\n   * Reads all of the lines from a file. The lines do not include line-termination characters, but\n   * do include other leading and trailing whitespace.\n   *\n   * <p>This method returns a mutable {@code List}. For an {@code ImmutableList}, use {@code\n   * Files.asCharSource(file, charset).readLines()}.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#readAllLines(java.nio.file.Path, Charset)}.\n   *\n   * @param file the file to read from\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @return a mutable {@link List} containing all the lines\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  public static List<String> readLines(File file, Charset charset) throws IOException {\n    // don't use asCharSource(file, charset).readLines() because that returns\n    // an immutable list, which would change the behavior of this method\n    return asCharSource(file, charset)\n        .readLines(\n            new LineProcessor<List<String>>() {\n              final List<String> result = Lists.newArrayList();\n\n              @Override\n              public boolean processLine(String line) {\n                result.add(line);\n                return true;\n              }\n\n              @Override\n              public List<String> getResult() {\n                return result;\n              }\n            });\n  }\n\n  /**\n   * Streams lines from a {@link File}, stopping when our callback returns false, or we have read\n   * all of the lines.\n   *\n   * @param file the file to read from\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @param callback the {@link LineProcessor} to use to handle the lines\n   * @return the output of processing the lines\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSource(file, charset).readLines(callback)}. This method is\n   *     scheduled to be removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  @CanIgnoreReturnValue // some processors won't return a useful result\n  public\n  static <T> T readLines(File file, Charset charset, LineProcessor<T> callback) throws IOException {\n    return asCharSource(file, charset).readLines(callback);\n  }\n\n  /**\n   * Process the bytes of a file.\n   *\n   * <p>(If this seems too complicated, maybe you're looking for {@link #toByteArray}.)\n   *\n   * @param file the file to read\n   * @param processor the object to which the bytes of the file are passed.\n   * @return the result of the byte processor\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asByteSource(file).read(processor)}. This method is scheduled to be\n   *     removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  @CanIgnoreReturnValue // some processors won't return a useful result\n  public\n  static <T> T readBytes(File file, ByteProcessor<T> processor) throws IOException {\n    return asByteSource(file).read(processor);\n  }\n\n  /**\n   * Computes the hash code of the {@code file} using {@code hashFunction}.\n   *\n   * @param file the file to read\n   * @param hashFunction the hash function to use to hash the data\n   * @return the {@link HashCode} of all of the bytes in the file\n   * @throws IOException if an I/O error occurs\n   * @since 12.0\n   * @deprecated Prefer {@code asByteSource(file).hash(hashFunction)}. This method is scheduled to\n   *     be removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public\n  static HashCode hash(File file, HashFunction hashFunction) throws IOException {\n    return asByteSource(file).hash(hashFunction);\n  }\n\n  /**\n   * Fully maps a file read-only in to memory as per {@link\n   * FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)}.\n   *\n   * <p>Files are mapped from offset 0 to its length.\n   *\n   * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n   *\n   * @param file the file to map\n   * @return a read-only buffer reflecting {@code file}\n   * @throws FileNotFoundException if the {@code file} does not exist\n   * @throws IOException if an I/O error occurs\n   * @see FileChannel#map(MapMode, long, long)\n   * @since 2.0\n   */\n  @Beta\n  public static MappedByteBuffer map(File file) throws IOException {\n    checkNotNull(file);\n    return map(file, MapMode.READ_ONLY);\n  }\n\n  /**\n   * Fully maps a file in to memory as per {@link\n   * FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)} using the requested {@link\n   * MapMode}.\n   *\n   * <p>Files are mapped from offset 0 to its length.\n   *\n   * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n   *\n   * @param file the file to map\n   * @param mode the mode to use when mapping {@code file}\n   * @return a buffer reflecting {@code file}\n   * @throws FileNotFoundException if the {@code file} does not exist\n   * @throws IOException if an I/O error occurs\n   * @see FileChannel#map(MapMode, long, long)\n   * @since 2.0\n   */\n  @Beta\n  public static MappedByteBuffer map(File file, MapMode mode) throws IOException {\n    return mapInternal(file, mode, -1);\n  }\n\n  /**\n   * Maps a file in to memory as per {@link FileChannel#map(java.nio.channels.FileChannel.MapMode,\n   * long, long)} using the requested {@link MapMode}.\n   *\n   * <p>Files are mapped from offset 0 to {@code size}.\n   *\n   * <p>If the mode is {@link MapMode#READ_WRITE} and the file does not exist, it will be created\n   * with the requested {@code size}. Thus this method is useful for creating memory mapped files\n   * which do not yet exist.\n   *\n   * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n   *\n   * @param file the file to map\n   * @param mode the mode to use when mapping {@code file}\n   * @return a buffer reflecting {@code file}\n   * @throws IOException if an I/O error occurs\n   * @see FileChannel#map(MapMode, long, long)\n   * @since 2.0\n   */\n  @Beta\n  public static MappedByteBuffer map(File file, MapMode mode, long size) throws IOException {\n    checkArgument(size >= 0, \"size (%s) may not be negative\", size);\n    return mapInternal(file, mode, size);\n  }\n\n  private static MappedByteBuffer mapInternal(File file, MapMode mode, long size)\n      throws IOException {\n    checkNotNull(file);\n    checkNotNull(mode);\n\n    Closer closer = Closer.create();\n    try {\n      RandomAccessFile raf =\n          closer.register(new RandomAccessFile(file, mode == MapMode.READ_ONLY ? \"r\" : \"rw\"));\n      FileChannel channel = closer.register(raf.getChannel());\n      return channel.map(mode, 0, size == -1 ? channel.size() : size);\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }\n\n  /**\n   * Returns the lexically cleaned form of the path name, <i>usually</i> (but not always) equivalent\n   * to the original. The following heuristics are used:\n   *\n   * <ul>\n   *   <li>empty string becomes .\n   *   <li>. stays as .\n   *   <li>fold out ./\n   *   <li>fold out ../ when possible\n   *   <li>collapse multiple slashes\n   *   <li>delete trailing slashes (unless the path is just \"/\")\n   * </ul>\n   *\n   * <p>These heuristics do not always match the behavior of the filesystem. In particular, consider\n   * the path {@code a/../b}, which {@code simplifyPath} will change to {@code b}. If {@code a} is a\n   * symlink to {@code x}, {@code a/../b} may refer to a sibling of {@code x}, rather than the\n   * sibling of {@code a} referred to by {@code b}.\n   *\n   * @since 11.0\n   */\n  @Beta\n  public static String simplifyPath(String pathname) {\n    checkNotNull(pathname);\n    if (pathname.length() == 0) {\n      return \".\";\n    }\n\n    // split the path apart\n    Iterable<String> components = Splitter.on('/').omitEmptyStrings().split(pathname);\n    List<String> path = new ArrayList<>();\n\n    // resolve ., .., and //\n    for (String component : components) {\n      switch (component) {\n        case \".\":\n          continue;\n        case \"..\":\n          if (path.size() > 0 && !path.get(path.size() - 1).equals(\"..\")) {\n            path.remove(path.size() - 1);\n          } else {\n            path.add(\"..\");\n          }\n          break;\n        default:\n          path.add(component);\n          break;\n      }\n    }\n\n    // put it back together\n    String result = Joiner.on('/').join(path);\n    if (pathname.charAt(0) == '/') {\n      result = \"/\" + result;\n    }\n\n    while (result.startsWith(\"/../\")) {\n      result = result.substring(3);\n    }\n    if (result.equals(\"/..\")) {\n      result = \"/\";\n    } else if (\"\".equals(result)) {\n      result = \".\";\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns the <a href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> for\n   * the given file name, or the empty string if the file has no extension. The result does not\n   * include the '{@code .}'.\n   *\n   * <p><b>Note:</b> This method simply returns everything after the last '{@code .}' in the file's\n   * name as determined by {@link File#getName}. It does not account for any filesystem-specific\n   * behavior that the {@link File} API does not already account for. For example, on NTFS it will\n   * report {@code \"txt\"} as the extension for the filename {@code \"foo.exe:.txt\"} even though NTFS\n   * will drop the {@code \":.txt\"} part of the name when the file is actually created on the\n   * filesystem due to NTFS's <a href=\"https://goo.gl/vTpJi4\">Alternate Data Streams</a>.\n   *\n   * @since 11.0\n   */\n  @Beta\n  public static String getFileExtension(String fullName) {\n    checkNotNull(fullName);\n    String fileName = new File(fullName).getName();\n    int dotIndex = fileName.lastIndexOf('.');\n    return (dotIndex == -1) ? \"\" : fileName.substring(dotIndex + 1);\n  }\n\n  /**\n   * Returns the file name without its <a\n   * href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> or path. This is\n   * similar to the {@code basename} unix command. The result does not include the '{@code .}'.\n   *\n   * @param file The name of the file to trim the extension from. This can be either a fully\n   *     qualified file name (including a path) or just a file name.\n   * @return The file name without its path or extension.\n   * @since 14.0\n   */\n  @Beta\n  public static String getNameWithoutExtension(String file) {\n    checkNotNull(file);\n    String fileName = new File(file).getName();\n    int dotIndex = fileName.lastIndexOf('.');\n    return (dotIndex == -1) ? fileName : fileName.substring(0, dotIndex);\n  }\n\n  /**\n   * Returns a {@link TreeTraverser} instance for {@link File} trees.\n   *\n   * <p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no\n   * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In\n   * this case, iterables created by this traverser could contain files that are outside of the\n   * given directory or even be infinite if there is a symbolic link loop.\n   *\n   * @since 15.0\n   * @deprecated The returned {@link TreeTraverser} type is deprecated. Use the replacement method\n   *     {@link #fileTraverser()} instead with the same semantics as this method.\n   */\n  @Deprecated\n  static TreeTraverser<File> fileTreeTraverser() {\n    return FILE_TREE_TRAVERSER;\n  }\n\n  private static final TreeTraverser<File> FILE_TREE_TRAVERSER =\n      new TreeTraverser<File>() {\n        @Override\n        public Iterable<File> children(File file) {\n          return fileTreeChildren(file);\n        }\n\n        @Override\n        public String toString() {\n          return \"Files.fileTreeTraverser()\";\n        }\n      };\n\n  /**\n   * Returns a {@link Traverser} instance for the file and directory tree. The returned traverser\n   * starts from a {@link File} and will return all files and directories it encounters.\n   *\n   * <p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no\n   * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In\n   * this case, iterables created by this traverser could contain files that are outside of the\n   * given directory or even be infinite if there is a symbolic link loop.\n   *\n   * <p>If available, consider using {@link MoreFiles#fileTraverser()} instead. It behaves the same\n   * except that it doesn't follow symbolic links and returns {@code Path} instances.\n   *\n   * <p>If the {@link File} passed to one of the {@link Traverser} methods does not exist or is not\n   * a directory, no exception will be thrown and the returned {@link Iterable} will contain a\n   * single element: that file.\n   *\n   * <p>Example: {@code Files.fileTraverser().depthFirstPreOrder(new File(\"/\"))} may return files\n   * with the following paths: {@code [\"/\", \"/etc\", \"/etc/config.txt\", \"/etc/fonts\", \"/home\",\n   * \"/home/alice\", ...]}\n   *\n   * @since 23.5\n   */\n  @Beta\n  public static Traverser<File> fileTraverser() {\n    return Traverser.forTree(FILE_TREE);\n  }\n\n  private static final SuccessorsFunction<File> FILE_TREE =\n      new SuccessorsFunction<File>() {\n        @Override\n        public Iterable<File> successors(File file) {\n          return fileTreeChildren(file);\n        }\n      };\n\n  private static Iterable<File> fileTreeChildren(File file) {\n    // check isDirectory() just because it may be faster than listFiles() on a non-directory\n    if (file.isDirectory()) {\n      File[] files = file.listFiles();\n      if (files != null) {\n        return Collections.unmodifiableList(Arrays.asList(files));\n      }\n    }\n\n    return Collections.emptyList();\n  }\n\n  /**\n   * Returns a predicate that returns the result of {@link File#isDirectory} on input files.\n   *\n   * @since 15.0\n   */\n  @Beta\n  public static Predicate<File> isDirectory() {\n    return FilePredicate.IS_DIRECTORY;\n  }\n\n  /**\n   * Returns a predicate that returns the result of {@link File#isFile} on input files.\n   *\n   * @since 15.0\n   */\n  @Beta\n  public static Predicate<File> isFile() {\n    return FilePredicate.IS_FILE;\n  }\n\n  private enum FilePredicate implements Predicate<File> {\n    IS_DIRECTORY {\n      @Override\n      public boolean apply(File file) {\n        return file.isDirectory();\n      }\n\n      @Override\n      public String toString() {\n        return \"Files.isDirectory()\";\n      }\n    },\n\n    IS_FILE {\n      @Override\n      public boolean apply(File file) {\n        return file.isFile();\n      }\n\n      @Override\n      public String toString() {\n        return \"Files.isFile()\";\n      }\n    }\n  }\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.io;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.io.FileWriteMode.APPEND;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.TreeTraverser;\nimport com.google.common.graph.SuccessorsFunction;\nimport com.google.common.graph.Traverser;\nimport com.google.common.hash.HashCode;\nimport com.google.common.hash.HashFunction;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.RandomAccessFile;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * Provides utility methods for working with {@linkplain File files}.\n *\n * <p>{@link java.nio.file.Path} users will find similar utilities in {@link MoreFiles} and the\n * JDK's {@link java.nio.file.Files} class.\n *\n * @author Chris Nokleberg\n * @author Colin Decker\n * @since 1.0\n */\n@GwtIncompatible\npublic final class Files {\n\n  /** Maximum loop count when creating temp directories. */\n  private static final int TEMP_DIR_ATTEMPTS = 10000;\n\n  private Files() {}\n\n  /**\n   * Returns a buffered reader that reads from a file using the given character set.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#newBufferedReader(java.nio.file.Path, Charset)}.\n   *\n   * @param file the file to read from\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @return the buffered reader\n   */\n  @Beta\n  public static BufferedReader newReader(File file, Charset charset) throws FileNotFoundException {\n    checkNotNull(file);\n    checkNotNull(charset);\n    return new BufferedReader(new InputStreamReader(new FileInputStream(file), charset));\n  }\n\n  /**\n   * Returns a buffered writer that writes to a file using the given character set.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#newBufferedWriter(java.nio.file.Path, Charset,\n   * java.nio.file.OpenOption...)}.\n   *\n   * @param file the file to write to\n   * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @return the buffered writer\n   */\n  @Beta\n  public static BufferedWriter newWriter(File file, Charset charset) throws FileNotFoundException {\n    checkNotNull(file);\n    checkNotNull(charset);\n    return new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), charset));\n  }\n\n  /**\n   * Returns a new {@link ByteSource} for reading bytes from the given file.\n   *\n   * @since 14.0\n   */\n  public static ByteSource asByteSource(File file) {\n    return new FileByteSource(file);\n  }\n\n  private static final class FileByteSource extends ByteSource {\n\n    private final File file;\n\n    private FileByteSource(File file) {\n      this.file = checkNotNull(file);\n    }\n\n    @Override\n    public FileInputStream openStream() throws IOException {\n      return new FileInputStream(file);\n    }\n\n    @Override\n    public Optional<Long> sizeIfKnown() {\n      if (file.isFile()) {\n        return Optional.of(file.length());\n      } else {\n        return Optional.absent();\n      }\n    }\n\n    @Override\n    public long size() throws IOException {\n      if (!file.isFile()) {\n        throw new FileNotFoundException(file.toString());\n      }\n      return file.length();\n    }\n\n    @Override\n    public byte[] read() throws IOException {\n      Closer closer = Closer.create();\n      try {\n        FileInputStream in = closer.register(openStream());\n        return ByteStreams.toByteArray(in, in.getChannel().size());\n      } catch (Throwable e) {\n        throw closer.rethrow(e);\n      } finally {\n        closer.close();\n      }\n    }\n\n    @Override\n    public String toString() {\n      return \"Files.asByteSource(\" + file + \")\";\n    }\n  }\n\n  /**\n   * Returns a new {@link ByteSink} for writing bytes to the given file. The given {@code modes}\n   * control how the file is opened for writing. When no mode is provided, the file will be\n   * truncated before writing. When the {@link FileWriteMode#APPEND APPEND} mode is provided, writes\n   * will append to the end of the file without truncating it.\n   *\n   * @since 14.0\n   */\n  public static ByteSink asByteSink(File file, FileWriteMode... modes) {\n    return new FileByteSink(file, modes);\n  }\n\n  private static final class FileByteSink extends ByteSink {\n\n    private final File file;\n    private final ImmutableSet<FileWriteMode> modes;\n\n    private FileByteSink(File file, FileWriteMode... modes) {\n      this.file = checkNotNull(file);\n      this.modes = ImmutableSet.copyOf(modes);\n    }\n\n    @Override\n    public FileOutputStream openStream() throws IOException {\n      return new FileOutputStream(file, modes.contains(APPEND));\n    }\n\n    @Override\n    public String toString() {\n      return \"Files.asByteSink(\" + file + \", \" + modes + \")\";\n    }\n  }\n\n  /**\n   * Returns a new {@link CharSource} for reading character data from the given file using the given\n   * character set.\n   *\n   * @since 14.0\n   */\n  public static CharSource asCharSource(File file, Charset charset) {\n    return asByteSource(file).asCharSource(charset);\n  }\n\n  /**\n   * Returns a new {@link CharSink} for writing character data to the given file using the given\n   * character set. The given {@code modes} control how the file is opened for writing. When no mode\n   * is provided, the file will be truncated before writing. When the {@link FileWriteMode#APPEND\n   * APPEND} mode is provided, writes will append to the end of the file without truncating it.\n   *\n   * @since 14.0\n   */\n  public static CharSink asCharSink(File file, Charset charset, FileWriteMode... modes) {\n    return asByteSink(file, modes).asCharSink(charset);\n  }\n\n  /**\n   * Reads all bytes from a file into a byte array.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link java.nio.file.Files#readAllBytes}.\n   *\n   * @param file the file to read from\n   * @return a byte array containing all the bytes from file\n   * @throws IllegalArgumentException if the file is bigger than the largest possible byte array\n   *     (2^31 - 1)\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  public static byte[] toByteArray(File file) throws IOException {\n    return asByteSource(file).read();\n  }\n\n  /**\n   * Reads all characters from a file into a {@link String}, using the given character set.\n   *\n   * @param file the file to read from\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @return a string containing all the characters from the file\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSource(file, charset).read()}. This method is scheduled to be\n   *     removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public static String toString(File file, Charset charset) throws IOException {\n    return asCharSource(file, charset).read();\n  }\n\n  /**\n   * Overwrites a file with the contents of a byte array.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#write(java.nio.file.Path, byte[], java.nio.file.OpenOption...)}.\n   *\n   * @param from the bytes to write\n   * @param to the destination file\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  public static void write(byte[] from, File to) throws IOException {\n    asByteSink(to).write(from);\n  }\n\n  /**\n   * Writes a character sequence (such as a string) to a file using the given character set.\n   *\n   * @param from the character sequence to write\n   * @param to the destination file\n   * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSink(to, charset).write(from)}. This method is scheduled to be\n   *     removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public static void write(CharSequence from, File to, Charset charset) throws IOException {\n    asCharSink(to, charset).write(from);\n  }\n\n  /**\n   * Copies all bytes from a file to an output stream.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#copy(java.nio.file.Path, OutputStream)}.\n   *\n   * @param from the source file\n   * @param to the output stream\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  public static void copy(File from, OutputStream to) throws IOException {\n    asByteSource(from).copyTo(to);\n  }\n\n  /**\n   * Copies all the bytes from one file to another.\n   *\n   * <p>Copying is not an atomic operation - in the case of an I/O error, power loss, process\n   * termination, or other problems, {@code to} may not be a complete copy of {@code from}. If you\n   * need to guard against those conditions, you should employ other file-level synchronization.\n   *\n   * <p><b>Warning:</b> If {@code to} represents an existing file, that file will be overwritten\n   * with the contents of {@code from}. If {@code to} and {@code from} refer to the <i>same</i>\n   * file, the contents of that file will be deleted.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#copy(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption...)}.\n   *\n   * @param from the source file\n   * @param to the destination file\n   * @throws IOException if an I/O error occurs\n   * @throws IllegalArgumentException if {@code from.equals(to)}\n   */\n  @Beta\n  public static void copy(File from, File to) throws IOException {\n    checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n    asByteSource(from).copyTo(asByteSink(to));\n  }\n\n  /**\n   * Copies all characters from a file to an appendable object, using the given character set.\n   *\n   * @param from the source file\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @param to the appendable object\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSource(from, charset).copyTo(to)}. This method is scheduled to\n   *     be removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public\n  static void copy(File from, Charset charset, Appendable to) throws IOException {\n    asCharSource(from, charset).copyTo(to);\n  }\n\n  /**\n   * Appends a character sequence (such as a string) to a file using the given character set.\n   *\n   * @param from the character sequence to append\n   * @param to the destination file\n   * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSink(to, charset, FileWriteMode.APPEND).write(from)}. This\n   *     method is scheduled to be removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public\n  static void append(CharSequence from, File to, Charset charset) throws IOException {\n    asCharSink(to, charset, FileWriteMode.APPEND).write(from);\n  }\n\n  /**\n   * Returns true if the given files exist, are not directories, and contain the same bytes.\n   *\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  public static boolean equal(File file1, File file2) throws IOException {\n    checkNotNull(file1);\n    checkNotNull(file2);\n    if (file1 == file2 || file1.equals(file2)) {\n      return true;\n    }\n\n    /*\n     * Some operating systems may return zero as the length for files denoting system-dependent\n     * entities such as devices or pipes, in which case we must fall back on comparing the bytes\n     * directly.\n     */\n    long len1 = file1.length();\n    long len2 = file2.length();\n    if (len1 != 0 && len2 != 0 && len1 != len2) {\n      return false;\n    }\n    return asByteSource(file1).contentEquals(asByteSource(file2));\n  }\n\n  /**\n   * Atomically creates a new directory somewhere beneath the system's temporary directory (as\n   * defined by the {@code java.io.tmpdir} system property), and returns its name.\n   *\n   * <p>Use this method instead of {@link File#createTempFile(String, String)} when you wish to\n   * create a directory, not a regular file. A common pitfall is to call {@code createTempFile},\n   * delete the file and create a directory in its place, but this leads a race condition which can\n   * be exploited to create security vulnerabilities, especially when executable files are to be\n   * written into the directory.\n   *\n   * <p>Depending on the environmment that this code is run in, the system temporary directory (and\n   * thus the directory this method creates) may be more visible that a program would like - files\n   * written to this directory may be read or overwritten by hostile programs running on the same\n   * machine.\n   *\n   * <p>This method assumes that the temporary volume is writable, has free inodes and free blocks,\n   * and that it will not be called thousands of times per second.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#createTempDirectory}.\n   *\n   * @return the newly-created directory\n   * @throws IllegalStateException if the directory could not be created\n   * @deprecated For Android users, see the <a\n   *     href=\"https://developer.android.com/training/data-storage\" target=\"_blank\">Data and File\n   *     Storage overview</a> to select an appropriate temporary directory (perhaps {@code\n   *     context.getCacheDir()}). For developers on Java 7 or later, use {@link\n   *     java.nio.file.Files#createTempDirectory}, transforming it to a {@link File} using {@link\n   *     java.nio.file.Path#toFile() toFile()} if needed.\n   */\n  @Beta\n  @Deprecated\n  public static File createTempDir() {\n    File baseDir = new File(System.getProperty(\"java.io.tmpdir\"));\n    @SuppressWarnings(\"GoodTime\") // reading system time without TimeSource\n    String baseName = System.currentTimeMillis() + \"-\";\n\n    for (int counter = 0; counter < TEMP_DIR_ATTEMPTS; counter++) {\n      File tempDir = new File(baseDir, baseName + counter);\n      if (tempDir.mkdir()) {\n        return tempDir;\n      }\n    }\n    throw new IllegalStateException(\n        \"Failed to create directory within \"\n            + TEMP_DIR_ATTEMPTS\n            + \" attempts (tried \"\n            + baseName\n            + \"0 to \"\n            + baseName\n            + (TEMP_DIR_ATTEMPTS - 1)\n            + ')');\n  }\n\n  /**\n   * Creates an empty file or updates the last updated timestamp on the same as the unix command of\n   * the same name.\n   *\n   * @param file the file to create or update\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  @SuppressWarnings(\"GoodTime\") // reading system time without TimeSource\n  public static void touch(File file) throws IOException {\n    checkNotNull(file);\n    if (!file.createNewFile() && !file.setLastModified(System.currentTimeMillis())) {\n      throw new IOException(\"Unable to update modification time of \" + file);\n    }\n  }\n\n  /**\n   * Creates any necessary but nonexistent parent directories of the specified file. Note that if\n   * this operation fails it may have succeeded in creating some (but not all) of the necessary\n   * parent directories.\n   *\n   * @throws IOException if an I/O error occurs, or if any necessary but nonexistent parent\n   *     directories of the specified file could not be created.\n   * @since 4.0\n   */\n  @Beta\n  public static void createParentDirs(File file) throws IOException {\n    checkNotNull(file);\n    File parent = file.getCanonicalFile().getParentFile();\n    if (parent == null) {\n      /*\n       * The given directory is a filesystem root. All zero of its ancestors exist. This doesn't\n       * mean that the root itself exists -- consider x:\\ on a Windows machine without such a drive\n       * -- or even that the caller can create it, but this method makes no such guarantees even for\n       * non-root files.\n       */\n      return;\n    }\n    parent.mkdirs();\n    if (!parent.isDirectory()) {\n      throw new IOException(\"Unable to create parent directories of \" + file);\n    }\n  }\n\n  /**\n   * Moves a file from one path to another. This method can rename a file and/or move it to a\n   * different directory. In either case {@code to} must be the target path for the file itself; not\n   * just the new name for the file or the path to the new parent directory.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link java.nio.file.Files#move}.\n   *\n   * @param from the source file\n   * @param to the destination file\n   * @throws IOException if an I/O error occurs\n   * @throws IllegalArgumentException if {@code from.equals(to)}\n   */\n  @Beta\n  public static void move(File from, File to) throws IOException {\n    checkNotNull(from);\n    checkNotNull(to);\n    checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n\n    if (!from.renameTo(to)) {\n      copy(from, to);\n      if (!from.delete()) {\n        if (!to.delete()) {\n          throw new IOException(\"Unable to delete \" + to);\n        }\n        throw new IOException(\"Unable to delete \" + from);\n      }\n    }\n  }\n\n  /**\n   * Reads the first line from a file. The line does not include line-termination characters, but\n   * does include other leading and trailing whitespace.\n   *\n   * @param file the file to read from\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @return the first line, or null if the file is empty\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSource(file, charset).readFirstLine()}. This method is\n   *     scheduled to be removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public\n  static String readFirstLine(File file, Charset charset) throws IOException {\n    return asCharSource(file, charset).readFirstLine();\n  }\n\n  /**\n   * Reads all of the lines from a file. The lines do not include line-termination characters, but\n   * do include other leading and trailing whitespace.\n   *\n   * <p>This method returns a mutable {@code List}. For an {@code ImmutableList}, use {@code\n   * Files.asCharSource(file, charset).readLines()}.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#readAllLines(java.nio.file.Path, Charset)}.\n   *\n   * @param file the file to read from\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @return a mutable {@link List} containing all the lines\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  public static List<String> readLines(File file, Charset charset) throws IOException {\n    // don't use asCharSource(file, charset).readLines() because that returns\n    // an immutable list, which would change the behavior of this method\n    return asCharSource(file, charset)\n        .readLines(\n            new LineProcessor<List<String>>() {\n              final List<String> result = Lists.newArrayList();\n\n              @Override\n              public boolean processLine(String line) {\n                result.add(line);\n                return true;\n              }\n\n              @Override\n              public List<String> getResult() {\n                return result;\n              }\n            });\n  }\n\n  /**\n   * Streams lines from a {@link File}, stopping when our callback returns false, or we have read\n   * all of the lines.\n   *\n   * @param file the file to read from\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @param callback the {@link LineProcessor} to use to handle the lines\n   * @return the output of processing the lines\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSource(file, charset).readLines(callback)}. This method is\n   *     scheduled to be removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  @CanIgnoreReturnValue // some processors won't return a useful result\n  public\n  static <T> T readLines(File file, Charset charset, LineProcessor<T> callback) throws IOException {\n    return asCharSource(file, charset).readLines(callback);\n  }\n\n  /**\n   * Process the bytes of a file.\n   *\n   * <p>(If this seems too complicated, maybe you're looking for {@link #toByteArray}.)\n   *\n   * @param file the file to read\n   * @param processor the object to which the bytes of the file are passed.\n   * @return the result of the byte processor\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asByteSource(file).read(processor)}. This method is scheduled to be\n   *     removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  @CanIgnoreReturnValue // some processors won't return a useful result\n  public\n  static <T> T readBytes(File file, ByteProcessor<T> processor) throws IOException {\n    return asByteSource(file).read(processor);\n  }\n\n  /**\n   * Computes the hash code of the {@code file} using {@code hashFunction}.\n   *\n   * @param file the file to read\n   * @param hashFunction the hash function to use to hash the data\n   * @return the {@link HashCode} of all of the bytes in the file\n   * @throws IOException if an I/O error occurs\n   * @since 12.0\n   * @deprecated Prefer {@code asByteSource(file).hash(hashFunction)}. This method is scheduled to\n   *     be removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public\n  static HashCode hash(File file, HashFunction hashFunction) throws IOException {\n    return asByteSource(file).hash(hashFunction);\n  }\n\n  /**\n   * Fully maps a file read-only in to memory as per {@link\n   * FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)}.\n   *\n   * <p>Files are mapped from offset 0 to its length.\n   *\n   * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n   *\n   * @param file the file to map\n   * @return a read-only buffer reflecting {@code file}\n   * @throws FileNotFoundException if the {@code file} does not exist\n   * @throws IOException if an I/O error occurs\n   * @see FileChannel#map(MapMode, long, long)\n   * @since 2.0\n   */\n  @Beta\n  public static MappedByteBuffer map(File file) throws IOException {\n    checkNotNull(file);\n    return map(file, MapMode.READ_ONLY);\n  }\n\n  /**\n   * Fully maps a file in to memory as per {@link\n   * FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)} using the requested {@link\n   * MapMode}.\n   *\n   * <p>Files are mapped from offset 0 to its length.\n   *\n   * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n   *\n   * @param file the file to map\n   * @param mode the mode to use when mapping {@code file}\n   * @return a buffer reflecting {@code file}\n   * @throws FileNotFoundException if the {@code file} does not exist\n   * @throws IOException if an I/O error occurs\n   * @see FileChannel#map(MapMode, long, long)\n   * @since 2.0\n   */\n  @Beta\n  public static MappedByteBuffer map(File file, MapMode mode) throws IOException {\n    return mapInternal(file, mode, -1);\n  }\n\n  /**\n   * Maps a file in to memory as per {@link FileChannel#map(java.nio.channels.FileChannel.MapMode,\n   * long, long)} using the requested {@link MapMode}.\n   *\n   * <p>Files are mapped from offset 0 to {@code size}.\n   *\n   * <p>If the mode is {@link MapMode#READ_WRITE} and the file does not exist, it will be created\n   * with the requested {@code size}. Thus this method is useful for creating memory mapped files\n   * which do not yet exist.\n   *\n   * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n   *\n   * @param file the file to map\n   * @param mode the mode to use when mapping {@code file}\n   * @return a buffer reflecting {@code file}\n   * @throws IOException if an I/O error occurs\n   * @see FileChannel#map(MapMode, long, long)\n   * @since 2.0\n   */\n  @Beta\n  public static MappedByteBuffer map(File file, MapMode mode, long size) throws IOException {\n    checkArgument(size >= 0, \"size (%s) may not be negative\", size);\n    return mapInternal(file, mode, size);\n  }\n\n  private static MappedByteBuffer mapInternal(File file, MapMode mode, long size)\n      throws IOException {\n    checkNotNull(file);\n    checkNotNull(mode);\n\n    Closer closer = Closer.create();\n    try {\n      RandomAccessFile raf =\n          closer.register(new RandomAccessFile(file, mode == MapMode.READ_ONLY ? \"r\" : \"rw\"));\n      FileChannel channel = closer.register(raf.getChannel());\n      return channel.map(mode, 0, size == -1 ? channel.size() : size);\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }\n\n  /**\n   * Returns the lexically cleaned form of the path name, <i>usually</i> (but not always) equivalent\n   * to the original. The following heuristics are used:\n   *\n   * <ul>\n   *   <li>empty string becomes .\n   *   <li>. stays as .\n   *   <li>fold out ./\n   *   <li>fold out ../ when possible\n   *   <li>collapse multiple slashes\n   *   <li>delete trailing slashes (unless the path is just \"/\")\n   * </ul>\n   *\n   * <p>These heuristics do not always match the behavior of the filesystem. In particular, consider\n   * the path {@code a/../b}, which {@code simplifyPath} will change to {@code b}. If {@code a} is a\n   * symlink to {@code x}, {@code a/../b} may refer to a sibling of {@code x}, rather than the\n   * sibling of {@code a} referred to by {@code b}.\n   *\n   * @since 11.0\n   */\n  @Beta\n  public static String simplifyPath(String pathname) {\n    checkNotNull(pathname);\n    if (pathname.length() == 0) {\n      return \".\";\n    }\n\n    // split the path apart\n    Iterable<String> components = Splitter.on('/').omitEmptyStrings().split(pathname);\n    List<String> path = new ArrayList<>();\n\n    // resolve ., .., and //\n    for (String component : components) {\n      switch (component) {\n        case \".\":\n          continue;\n        case \"..\":\n          if (path.size() > 0 && !path.get(path.size() - 1).equals(\"..\")) {\n            path.remove(path.size() - 1);\n          } else {\n            path.add(\"..\");\n          }\n          break;\n        default:\n          path.add(component);\n          break;\n      }\n    }\n\n    // put it back together\n    String result = Joiner.on('/').join(path);\n    if (pathname.charAt(0) == '/') {\n      result = \"/\" + result;\n    }\n\n    while (result.startsWith(\"/../\")) {\n      result = result.substring(3);\n    }\n    if (result.equals(\"/..\")) {\n      result = \"/\";\n    } else if (\"\".equals(result)) {\n      result = \".\";\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns the <a href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> for\n   * the given file name, or the empty string if the file has no extension. The result does not\n   * include the '{@code .}'.\n   *\n   * <p><b>Note:</b> This method simply returns everything after the last '{@code .}' in the file's\n   * name as determined by {@link File#getName}. It does not account for any filesystem-specific\n   * behavior that the {@link File} API does not already account for. For example, on NTFS it will\n   * report {@code \"txt\"} as the extension for the filename {@code \"foo.exe:.txt\"} even though NTFS\n   * will drop the {@code \":.txt\"} part of the name when the file is actually created on the\n   * filesystem due to NTFS's <a href=\"https://goo.gl/vTpJi4\">Alternate Data Streams</a>.\n   *\n   * @since 11.0\n   */\n  @Beta\n  public static String getFileExtension(String fullName) {\n    checkNotNull(fullName);\n    String fileName = new File(fullName).getName();\n    int dotIndex = fileName.lastIndexOf('.');\n    return (dotIndex == -1) ? \"\" : fileName.substring(dotIndex + 1);\n  }\n\n  /**\n   * Returns the file name without its <a\n   * href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> or path. This is\n   * similar to the {@code basename} unix command. The result does not include the '{@code .}'.\n   *\n   * @param file The name of the file to trim the extension from. This can be either a fully\n   *     qualified file name (including a path) or just a file name.\n   * @return The file name without its path or extension.\n   * @since 14.0\n   */\n  @Beta\n  public static String getNameWithoutExtension(String file) {\n    checkNotNull(file);\n    String fileName = new File(file).getName();\n    int dotIndex = fileName.lastIndexOf('.');\n    return (dotIndex == -1) ? fileName : fileName.substring(0, dotIndex);\n  }\n\n  /**\n   * Returns a {@link TreeTraverser} instance for {@link File} trees.\n   *\n   * <p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no\n   * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In\n   * this case, iterables created by this traverser could contain files that are outside of the\n   * given directory or even be infinite if there is a symbolic link loop.\n   *\n   * @since 15.0\n   * @deprecated The returned {@link TreeTraverser} type is deprecated. Use the replacement method\n   *     {@link #fileTraverser()} instead with the same semantics as this method.\n   */\n  @Deprecated\n  static TreeTraverser<File> fileTreeTraverser() {\n    return FILE_TREE_TRAVERSER;\n  }\n\n  private static final TreeTraverser<File> FILE_TREE_TRAVERSER =\n      new TreeTraverser<File>() {\n        @Override\n        public Iterable<File> children(File file) {\n          return fileTreeChildren(file);\n        }\n\n        @Override\n        public String toString() {\n          return \"Files.fileTreeTraverser()\";\n        }\n      };\n\n  /**\n   * Returns a {@link Traverser} instance for the file and directory tree. The returned traverser\n   * starts from a {@link File} and will return all files and directories it encounters.\n   *\n   * <p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no\n   * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In\n   * this case, iterables created by this traverser could contain files that are outside of the\n   * given directory or even be infinite if there is a symbolic link loop.\n   *\n   * <p>If available, consider using {@link MoreFiles#fileTraverser()} instead. It behaves the same\n   * except that it doesn't follow symbolic links and returns {@code Path} instances.\n   *\n   * <p>If the {@link File} passed to one of the {@link Traverser} methods does not exist or is not\n   * a directory, no exception will be thrown and the returned {@link Iterable} will contain a\n   * single element: that file.\n   *\n   * <p>Example: {@code Files.fileTraverser().depthFirstPreOrder(new File(\"/\"))} may return files\n   * with the following paths: {@code [\"/\", \"/etc\", \"/etc/config.txt\", \"/etc/fonts\", \"/home\",\n   * \"/home/alice\", ...]}\n   *\n   * @since 23.5\n   */\n  @Beta\n  public static Traverser<File> fileTraverser() {\n    return Traverser.forTree(FILE_TREE);\n  }\n\n  private static final SuccessorsFunction<File> FILE_TREE =\n      new SuccessorsFunction<File>() {\n        @Override\n        public Iterable<File> successors(File file) {\n          return fileTreeChildren(file);\n        }\n      };\n\n  private static Iterable<File> fileTreeChildren(File file) {\n    // check isDirectory() just because it may be faster than listFiles() on a non-directory\n    if (file.isDirectory()) {\n      File[] files = file.listFiles();\n      if (files != null) {\n        return Collections.unmodifiableList(Arrays.asList(files));\n      }\n    }\n\n    return Collections.emptyList();\n  }\n\n  /**\n   * Returns a predicate that returns the result of {@link File#isDirectory} on input files.\n   *\n   * @since 15.0\n   */\n  @Beta\n  public static Predicate<File> isDirectory() {\n    return FilePredicate.IS_DIRECTORY;\n  }\n\n  /**\n   * Returns a predicate that returns the result of {@link File#isFile} on input files.\n   *\n   * @since 15.0\n   */\n  @Beta\n  public static Predicate<File> isFile() {\n    return FilePredicate.IS_FILE;\n  }\n\n  private enum FilePredicate implements Predicate<File> {\n    IS_DIRECTORY {\n      @Override\n      public boolean apply(File file) {\n        return file.isDirectory();\n      }\n\n      @Override\n      public String toString() {\n        return \"Files.isDirectory()\";\n      }\n    },\n\n    IS_FILE {\n      @Override\n      public boolean apply(File file) {\n        return file.isFile();\n      }\n\n      @Override\n      public String toString() {\n        return \"Files.isFile()\";\n      }\n    }\n  }\n}\n", "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.io;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.io.FileWriteMode.APPEND;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.TreeTraverser;\nimport com.google.common.graph.SuccessorsFunction;\nimport com.google.common.graph.Traverser;\nimport com.google.common.hash.HashCode;\nimport com.google.common.hash.HashFunction;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.RandomAccessFile;\nimport java.nio.MappedByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.FileChannel.MapMode;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * Provides utility methods for working with {@linkplain File files}.\n *\n * <p>{@link java.nio.file.Path} users will find similar utilities in {@link MoreFiles} and the\n * JDK's {@link java.nio.file.Files} class.\n *\n * @author Chris Nokleberg\n * @author Colin Decker\n * @since 1.0\n */\n@GwtIncompatible\npublic final class Files {\n\n  /** Maximum loop count when creating temp directories. */\n  private static final int TEMP_DIR_ATTEMPTS = 10000;\n\n  private Files() {}\n\n  /**\n   * Returns a buffered reader that reads from a file using the given character set.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#newBufferedReader(java.nio.file.Path, Charset)}.\n   *\n   * @param file the file to read from\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @return the buffered reader\n   */\n  @Beta\n  public static BufferedReader newReader(File file, Charset charset) throws FileNotFoundException {\n    checkNotNull(file);\n    checkNotNull(charset);\n    return new BufferedReader(new InputStreamReader(new FileInputStream(file), charset));\n  }\n\n  /**\n   * Returns a buffered writer that writes to a file using the given character set.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#newBufferedWriter(java.nio.file.Path, Charset,\n   * java.nio.file.OpenOption...)}.\n   *\n   * @param file the file to write to\n   * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @return the buffered writer\n   */\n  @Beta\n  public static BufferedWriter newWriter(File file, Charset charset) throws FileNotFoundException {\n    checkNotNull(file);\n    checkNotNull(charset);\n    return new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), charset));\n  }\n\n  /**\n   * Returns a new {@link ByteSource} for reading bytes from the given file.\n   *\n   * @since 14.0\n   */\n  public static ByteSource asByteSource(File file) {\n    return new FileByteSource(file);\n  }\n\n  private static final class FileByteSource extends ByteSource {\n\n    private final File file;\n\n    private FileByteSource(File file) {\n      this.file = checkNotNull(file);\n    }\n\n    @Override\n    public FileInputStream openStream() throws IOException {\n      return new FileInputStream(file);\n    }\n\n    @Override\n    public Optional<Long> sizeIfKnown() {\n      if (file.isFile()) {\n        return Optional.of(file.length());\n      } else {\n        return Optional.absent();\n      }\n    }\n\n    @Override\n    public long size() throws IOException {\n      if (!file.isFile()) {\n        throw new FileNotFoundException(file.toString());\n      }\n      return file.length();\n    }\n\n    @Override\n    public byte[] read() throws IOException {\n      Closer closer = Closer.create();\n      try {\n        FileInputStream in = closer.register(openStream());\n        return ByteStreams.toByteArray(in, in.getChannel().size());\n      } catch (Throwable e) {\n        throw closer.rethrow(e);\n      } finally {\n        closer.close();\n      }\n    }\n\n    @Override\n    public String toString() {\n      return \"Files.asByteSource(\" + file + \")\";\n    }\n  }\n\n  /**\n   * Returns a new {@link ByteSink} for writing bytes to the given file. The given {@code modes}\n   * control how the file is opened for writing. When no mode is provided, the file will be\n   * truncated before writing. When the {@link FileWriteMode#APPEND APPEND} mode is provided, writes\n   * will append to the end of the file without truncating it.\n   *\n   * @since 14.0\n   */\n  public static ByteSink asByteSink(File file, FileWriteMode... modes) {\n    return new FileByteSink(file, modes);\n  }\n\n  private static final class FileByteSink extends ByteSink {\n\n    private final File file;\n    private final ImmutableSet<FileWriteMode> modes;\n\n    private FileByteSink(File file, FileWriteMode... modes) {\n      this.file = checkNotNull(file);\n      this.modes = ImmutableSet.copyOf(modes);\n    }\n\n    @Override\n    public FileOutputStream openStream() throws IOException {\n      return new FileOutputStream(file, modes.contains(APPEND));\n    }\n\n    @Override\n    public String toString() {\n      return \"Files.asByteSink(\" + file + \", \" + modes + \")\";\n    }\n  }\n\n  /**\n   * Returns a new {@link CharSource} for reading character data from the given file using the given\n   * character set.\n   *\n   * @since 14.0\n   */\n  public static CharSource asCharSource(File file, Charset charset) {\n    return asByteSource(file).asCharSource(charset);\n  }\n\n  /**\n   * Returns a new {@link CharSink} for writing character data to the given file using the given\n   * character set. The given {@code modes} control how the file is opened for writing. When no mode\n   * is provided, the file will be truncated before writing. When the {@link FileWriteMode#APPEND\n   * APPEND} mode is provided, writes will append to the end of the file without truncating it.\n   *\n   * @since 14.0\n   */\n  public static CharSink asCharSink(File file, Charset charset, FileWriteMode... modes) {\n    return asByteSink(file, modes).asCharSink(charset);\n  }\n\n  /**\n   * Reads all bytes from a file into a byte array.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link java.nio.file.Files#readAllBytes}.\n   *\n   * @param file the file to read from\n   * @return a byte array containing all the bytes from file\n   * @throws IllegalArgumentException if the file is bigger than the largest possible byte array\n   *     (2^31 - 1)\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  public static byte[] toByteArray(File file) throws IOException {\n    return asByteSource(file).read();\n  }\n\n  /**\n   * Reads all characters from a file into a {@link String}, using the given character set.\n   *\n   * @param file the file to read from\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @return a string containing all the characters from the file\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSource(file, charset).read()}. This method is scheduled to be\n   *     removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public static String toString(File file, Charset charset) throws IOException {\n    return asCharSource(file, charset).read();\n  }\n\n  /**\n   * Overwrites a file with the contents of a byte array.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#write(java.nio.file.Path, byte[], java.nio.file.OpenOption...)}.\n   *\n   * @param from the bytes to write\n   * @param to the destination file\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  public static void write(byte[] from, File to) throws IOException {\n    asByteSink(to).write(from);\n  }\n\n  /**\n   * Writes a character sequence (such as a string) to a file using the given character set.\n   *\n   * @param from the character sequence to write\n   * @param to the destination file\n   * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSink(to, charset).write(from)}. This method is scheduled to be\n   *     removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public static void write(CharSequence from, File to, Charset charset) throws IOException {\n    asCharSink(to, charset).write(from);\n  }\n\n  /**\n   * Copies all bytes from a file to an output stream.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#copy(java.nio.file.Path, OutputStream)}.\n   *\n   * @param from the source file\n   * @param to the output stream\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  public static void copy(File from, OutputStream to) throws IOException {\n    asByteSource(from).copyTo(to);\n  }\n\n  /**\n   * Copies all the bytes from one file to another.\n   *\n   * <p>Copying is not an atomic operation - in the case of an I/O error, power loss, process\n   * termination, or other problems, {@code to} may not be a complete copy of {@code from}. If you\n   * need to guard against those conditions, you should employ other file-level synchronization.\n   *\n   * <p><b>Warning:</b> If {@code to} represents an existing file, that file will be overwritten\n   * with the contents of {@code from}. If {@code to} and {@code from} refer to the <i>same</i>\n   * file, the contents of that file will be deleted.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#copy(java.nio.file.Path, java.nio.file.Path, java.nio.file.CopyOption...)}.\n   *\n   * @param from the source file\n   * @param to the destination file\n   * @throws IOException if an I/O error occurs\n   * @throws IllegalArgumentException if {@code from.equals(to)}\n   */\n  @Beta\n  public static void copy(File from, File to) throws IOException {\n    checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n    asByteSource(from).copyTo(asByteSink(to));\n  }\n\n  /**\n   * Copies all characters from a file to an appendable object, using the given character set.\n   *\n   * @param from the source file\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @param to the appendable object\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSource(from, charset).copyTo(to)}. This method is scheduled to\n   *     be removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public\n  static void copy(File from, Charset charset, Appendable to) throws IOException {\n    asCharSource(from, charset).copyTo(to);\n  }\n\n  /**\n   * Appends a character sequence (such as a string) to a file using the given character set.\n   *\n   * @param from the character sequence to append\n   * @param to the destination file\n   * @param charset the charset used to encode the output stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSink(to, charset, FileWriteMode.APPEND).write(from)}. This\n   *     method is scheduled to be removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public\n  static void append(CharSequence from, File to, Charset charset) throws IOException {\n    asCharSink(to, charset, FileWriteMode.APPEND).write(from);\n  }\n\n  /**\n   * Returns true if the given files exist, are not directories, and contain the same bytes.\n   *\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  public static boolean equal(File file1, File file2) throws IOException {\n    checkNotNull(file1);\n    checkNotNull(file2);\n    if (file1 == file2 || file1.equals(file2)) {\n      return true;\n    }\n\n    /*\n     * Some operating systems may return zero as the length for files denoting system-dependent\n     * entities such as devices or pipes, in which case we must fall back on comparing the bytes\n     * directly.\n     */\n    long len1 = file1.length();\n    long len2 = file2.length();\n    if (len1 != 0 && len2 != 0 && len1 != len2) {\n      return false;\n    }\n    return asByteSource(file1).contentEquals(asByteSource(file2));\n  }\n\n  /**\n   * Atomically creates a new directory somewhere beneath the system's temporary directory (as\n   * defined by the {@code java.io.tmpdir} system property), and returns its name.\n   *\n   * <p>Use this method instead of {@link File#createTempFile(String, String)} when you wish to\n   * create a directory, not a regular file. A common pitfall is to call {@code createTempFile},\n   * delete the file and create a directory in its place, but this leads a race condition which can\n   * be exploited to create security vulnerabilities, especially when executable files are to be\n   * written into the directory.\n   *\n   * <p>Depending on the environmment that this code is run in, the system temporary directory (and\n   * thus the directory this method creates) may be more visible that a program would like - files\n   * written to this directory may be read or overwritten by hostile programs running on the same\n   * machine.\n   *\n   * <p>This method assumes that the temporary volume is writable, has free inodes and free blocks,\n   * and that it will not be called thousands of times per second.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#createTempDirectory}.\n   *\n   * @return the newly-created directory\n   * @throws IllegalStateException if the directory could not be created\n   * @deprecated For Android users, see the <a\n   *     href=\"https://developer.android.com/training/data-storage\" target=\"_blank\">Data and File\n   *     Storage overview</a> to select an appropriate temporary directory (perhaps {@code\n   *     context.getCacheDir()}). For developers on Java 7 or later, use {@link\n   *     java.nio.file.Files#createTempDirectory}, transforming it to a {@link File} using {@link\n   *     java.nio.file.Path#toFile() toFile()} if needed.\n   */\n  @Beta\n  @Deprecated\n  public static File createTempDir() {\n    File baseDir = new File(System.getProperty(\"java.io.tmpdir\"));\n    @SuppressWarnings(\"GoodTime\") // reading system time without TimeSource\n    String baseName = System.currentTimeMillis() + \"-\";\n\n    for (int counter = 0; counter < TEMP_DIR_ATTEMPTS; counter++) {\n      File tempDir = new File(baseDir, baseName + counter);\n      if (tempDir.mkdir()) {\n        return tempDir;\n      }\n    }\n    throw new IllegalStateException(\n        \"Failed to create directory within \"\n            + TEMP_DIR_ATTEMPTS\n            + \" attempts (tried \"\n            + baseName\n            + \"0 to \"\n            + baseName\n            + (TEMP_DIR_ATTEMPTS - 1)\n            + ')');\n  }\n\n  /**\n   * Creates an empty file or updates the last updated timestamp on the same as the unix command of\n   * the same name.\n   *\n   * @param file the file to create or update\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  @SuppressWarnings(\"GoodTime\") // reading system time without TimeSource\n  public static void touch(File file) throws IOException {\n    checkNotNull(file);\n    if (!file.createNewFile() && !file.setLastModified(System.currentTimeMillis())) {\n      throw new IOException(\"Unable to update modification time of \" + file);\n    }\n  }\n\n  /**\n   * Creates any necessary but nonexistent parent directories of the specified file. Note that if\n   * this operation fails it may have succeeded in creating some (but not all) of the necessary\n   * parent directories.\n   *\n   * @throws IOException if an I/O error occurs, or if any necessary but nonexistent parent\n   *     directories of the specified file could not be created.\n   * @since 4.0\n   */\n  @Beta\n  public static void createParentDirs(File file) throws IOException {\n    checkNotNull(file);\n    File parent = file.getCanonicalFile().getParentFile();\n    if (parent == null) {\n      /*\n       * The given directory is a filesystem root. All zero of its ancestors exist. This doesn't\n       * mean that the root itself exists -- consider x:\\ on a Windows machine without such a drive\n       * -- or even that the caller can create it, but this method makes no such guarantees even for\n       * non-root files.\n       */\n      return;\n    }\n    parent.mkdirs();\n    if (!parent.isDirectory()) {\n      throw new IOException(\"Unable to create parent directories of \" + file);\n    }\n  }\n\n  /**\n   * Moves a file from one path to another. This method can rename a file and/or move it to a\n   * different directory. In either case {@code to} must be the target path for the file itself; not\n   * just the new name for the file or the path to the new parent directory.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link java.nio.file.Files#move}.\n   *\n   * @param from the source file\n   * @param to the destination file\n   * @throws IOException if an I/O error occurs\n   * @throws IllegalArgumentException if {@code from.equals(to)}\n   */\n  @Beta\n  public static void move(File from, File to) throws IOException {\n    checkNotNull(from);\n    checkNotNull(to);\n    checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);\n\n    if (!from.renameTo(to)) {\n      copy(from, to);\n      if (!from.delete()) {\n        if (!to.delete()) {\n          throw new IOException(\"Unable to delete \" + to);\n        }\n        throw new IOException(\"Unable to delete \" + from);\n      }\n    }\n  }\n\n  /**\n   * Reads the first line from a file. The line does not include line-termination characters, but\n   * does include other leading and trailing whitespace.\n   *\n   * @param file the file to read from\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @return the first line, or null if the file is empty\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSource(file, charset).readFirstLine()}. This method is\n   *     scheduled to be removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public\n  static String readFirstLine(File file, Charset charset) throws IOException {\n    return asCharSource(file, charset).readFirstLine();\n  }\n\n  /**\n   * Reads all of the lines from a file. The lines do not include line-termination characters, but\n   * do include other leading and trailing whitespace.\n   *\n   * <p>This method returns a mutable {@code List}. For an {@code ImmutableList}, use {@code\n   * Files.asCharSource(file, charset).readLines()}.\n   *\n   * <p><b>{@link java.nio.file.Path} equivalent:</b> {@link\n   * java.nio.file.Files#readAllLines(java.nio.file.Path, Charset)}.\n   *\n   * @param file the file to read from\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @return a mutable {@link List} containing all the lines\n   * @throws IOException if an I/O error occurs\n   */\n  @Beta\n  public static List<String> readLines(File file, Charset charset) throws IOException {\n    // don't use asCharSource(file, charset).readLines() because that returns\n    // an immutable list, which would change the behavior of this method\n    return asCharSource(file, charset)\n        .readLines(\n            new LineProcessor<List<String>>() {\n              final List<String> result = Lists.newArrayList();\n\n              @Override\n              public boolean processLine(String line) {\n                result.add(line);\n                return true;\n              }\n\n              @Override\n              public List<String> getResult() {\n                return result;\n              }\n            });\n  }\n\n  /**\n   * Streams lines from a {@link File}, stopping when our callback returns false, or we have read\n   * all of the lines.\n   *\n   * @param file the file to read from\n   * @param charset the charset used to decode the input stream; see {@link StandardCharsets} for\n   *     helpful predefined constants\n   * @param callback the {@link LineProcessor} to use to handle the lines\n   * @return the output of processing the lines\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asCharSource(file, charset).readLines(callback)}. This method is\n   *     scheduled to be removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  @CanIgnoreReturnValue // some processors won't return a useful result\n  public\n  static <T> T readLines(File file, Charset charset, LineProcessor<T> callback) throws IOException {\n    return asCharSource(file, charset).readLines(callback);\n  }\n\n  /**\n   * Process the bytes of a file.\n   *\n   * <p>(If this seems too complicated, maybe you're looking for {@link #toByteArray}.)\n   *\n   * @param file the file to read\n   * @param processor the object to which the bytes of the file are passed.\n   * @return the result of the byte processor\n   * @throws IOException if an I/O error occurs\n   * @deprecated Prefer {@code asByteSource(file).read(processor)}. This method is scheduled to be\n   *     removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  @CanIgnoreReturnValue // some processors won't return a useful result\n  public\n  static <T> T readBytes(File file, ByteProcessor<T> processor) throws IOException {\n    return asByteSource(file).read(processor);\n  }\n\n  /**\n   * Computes the hash code of the {@code file} using {@code hashFunction}.\n   *\n   * @param file the file to read\n   * @param hashFunction the hash function to use to hash the data\n   * @return the {@link HashCode} of all of the bytes in the file\n   * @throws IOException if an I/O error occurs\n   * @since 12.0\n   * @deprecated Prefer {@code asByteSource(file).hash(hashFunction)}. This method is scheduled to\n   *     be removed in October 2019.\n   */\n  @Beta\n  @Deprecated\n  public\n  static HashCode hash(File file, HashFunction hashFunction) throws IOException {\n    return asByteSource(file).hash(hashFunction);\n  }\n\n  /**\n   * Fully maps a file read-only in to memory as per {@link\n   * FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)}.\n   *\n   * <p>Files are mapped from offset 0 to its length.\n   *\n   * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n   *\n   * @param file the file to map\n   * @return a read-only buffer reflecting {@code file}\n   * @throws FileNotFoundException if the {@code file} does not exist\n   * @throws IOException if an I/O error occurs\n   * @see FileChannel#map(MapMode, long, long)\n   * @since 2.0\n   */\n  @Beta\n  public static MappedByteBuffer map(File file) throws IOException {\n    checkNotNull(file);\n    return map(file, MapMode.READ_ONLY);\n  }\n\n  /**\n   * Fully maps a file in to memory as per {@link\n   * FileChannel#map(java.nio.channels.FileChannel.MapMode, long, long)} using the requested {@link\n   * MapMode}.\n   *\n   * <p>Files are mapped from offset 0 to its length.\n   *\n   * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n   *\n   * @param file the file to map\n   * @param mode the mode to use when mapping {@code file}\n   * @return a buffer reflecting {@code file}\n   * @throws FileNotFoundException if the {@code file} does not exist\n   * @throws IOException if an I/O error occurs\n   * @see FileChannel#map(MapMode, long, long)\n   * @since 2.0\n   */\n  @Beta\n  public static MappedByteBuffer map(File file, MapMode mode) throws IOException {\n    return mapInternal(file, mode, -1);\n  }\n\n  /**\n   * Maps a file in to memory as per {@link FileChannel#map(java.nio.channels.FileChannel.MapMode,\n   * long, long)} using the requested {@link MapMode}.\n   *\n   * <p>Files are mapped from offset 0 to {@code size}.\n   *\n   * <p>If the mode is {@link MapMode#READ_WRITE} and the file does not exist, it will be created\n   * with the requested {@code size}. Thus this method is useful for creating memory mapped files\n   * which do not yet exist.\n   *\n   * <p>This only works for files \u2264 {@link Integer#MAX_VALUE} bytes.\n   *\n   * @param file the file to map\n   * @param mode the mode to use when mapping {@code file}\n   * @return a buffer reflecting {@code file}\n   * @throws IOException if an I/O error occurs\n   * @see FileChannel#map(MapMode, long, long)\n   * @since 2.0\n   */\n  @Beta\n  public static MappedByteBuffer map(File file, MapMode mode, long size) throws IOException {\n    checkArgument(size >= 0, \"size (%s) may not be negative\", size);\n    return mapInternal(file, mode, size);\n  }\n\n  private static MappedByteBuffer mapInternal(File file, MapMode mode, long size)\n      throws IOException {\n    checkNotNull(file);\n    checkNotNull(mode);\n\n    Closer closer = Closer.create();\n    try {\n      RandomAccessFile raf =\n          closer.register(new RandomAccessFile(file, mode == MapMode.READ_ONLY ? \"r\" : \"rw\"));\n      FileChannel channel = closer.register(raf.getChannel());\n      return channel.map(mode, 0, size == -1 ? channel.size() : size);\n    } catch (Throwable e) {\n      throw closer.rethrow(e);\n    } finally {\n      closer.close();\n    }\n  }\n\n  /**\n   * Returns the lexically cleaned form of the path name, <i>usually</i> (but not always) equivalent\n   * to the original. The following heuristics are used:\n   *\n   * <ul>\n   *   <li>empty string becomes .\n   *   <li>. stays as .\n   *   <li>fold out ./\n   *   <li>fold out ../ when possible\n   *   <li>collapse multiple slashes\n   *   <li>delete trailing slashes (unless the path is just \"/\")\n   * </ul>\n   *\n   * <p>These heuristics do not always match the behavior of the filesystem. In particular, consider\n   * the path {@code a/../b}, which {@code simplifyPath} will change to {@code b}. If {@code a} is a\n   * symlink to {@code x}, {@code a/../b} may refer to a sibling of {@code x}, rather than the\n   * sibling of {@code a} referred to by {@code b}.\n   *\n   * @since 11.0\n   */\n  @Beta\n  public static String simplifyPath(String pathname) {\n    checkNotNull(pathname);\n    if (pathname.length() == 0) {\n      return \".\";\n    }\n\n    // split the path apart\n    Iterable<String> components = Splitter.on('/').omitEmptyStrings().split(pathname);\n    List<String> path = new ArrayList<>();\n\n    // resolve ., .., and //\n    for (String component : components) {\n      switch (component) {\n        case \".\":\n          continue;\n        case \"..\":\n          if (path.size() > 0 && !path.get(path.size() - 1).equals(\"..\")) {\n            path.remove(path.size() - 1);\n          } else {\n            path.add(\"..\");\n          }\n          break;\n        default:\n          path.add(component);\n          break;\n      }\n    }\n\n    // put it back together\n    String result = Joiner.on('/').join(path);\n    if (pathname.charAt(0) == '/') {\n      result = \"/\" + result;\n    }\n\n    while (result.startsWith(\"/../\")) {\n      result = result.substring(3);\n    }\n    if (result.equals(\"/..\")) {\n      result = \"/\";\n    } else if (\"\".equals(result)) {\n      result = \".\";\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns the <a href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> for\n   * the given file name, or the empty string if the file has no extension. The result does not\n   * include the '{@code .}'.\n   *\n   * <p><b>Note:</b> This method simply returns everything after the last '{@code .}' in the file's\n   * name as determined by {@link File#getName}. It does not account for any filesystem-specific\n   * behavior that the {@link File} API does not already account for. For example, on NTFS it will\n   * report {@code \"txt\"} as the extension for the filename {@code \"foo.exe:.txt\"} even though NTFS\n   * will drop the {@code \":.txt\"} part of the name when the file is actually created on the\n   * filesystem due to NTFS's <a href=\"https://goo.gl/vTpJi4\">Alternate Data Streams</a>.\n   *\n   * @since 11.0\n   */\n  @Beta\n  public static String getFileExtension(String fullName) {\n    checkNotNull(fullName);\n    String fileName = new File(fullName).getName();\n    int dotIndex = fileName.lastIndexOf('.');\n    return (dotIndex == -1) ? \"\" : fileName.substring(dotIndex + 1);\n  }\n\n  /**\n   * Returns the file name without its <a\n   * href=\"http://en.wikipedia.org/wiki/Filename_extension\">file extension</a> or path. This is\n   * similar to the {@code basename} unix command. The result does not include the '{@code .}'.\n   *\n   * @param file The name of the file to trim the extension from. This can be either a fully\n   *     qualified file name (including a path) or just a file name.\n   * @return The file name without its path or extension.\n   * @since 14.0\n   */\n  @Beta\n  public static String getNameWithoutExtension(String file) {\n    checkNotNull(file);\n    String fileName = new File(file).getName();\n    int dotIndex = fileName.lastIndexOf('.');\n    return (dotIndex == -1) ? fileName : fileName.substring(0, dotIndex);\n  }\n\n  /**\n   * Returns a {@link TreeTraverser} instance for {@link File} trees.\n   *\n   * <p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no\n   * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In\n   * this case, iterables created by this traverser could contain files that are outside of the\n   * given directory or even be infinite if there is a symbolic link loop.\n   *\n   * @since 15.0\n   * @deprecated The returned {@link TreeTraverser} type is deprecated. Use the replacement method\n   *     {@link #fileTraverser()} instead with the same semantics as this method.\n   */\n  @Deprecated\n  static TreeTraverser<File> fileTreeTraverser() {\n    return FILE_TREE_TRAVERSER;\n  }\n\n  private static final TreeTraverser<File> FILE_TREE_TRAVERSER =\n      new TreeTraverser<File>() {\n        @Override\n        public Iterable<File> children(File file) {\n          return fileTreeChildren(file);\n        }\n\n        @Override\n        public String toString() {\n          return \"Files.fileTreeTraverser()\";\n        }\n      };\n\n  /**\n   * Returns a {@link Traverser} instance for the file and directory tree. The returned traverser\n   * starts from a {@link File} and will return all files and directories it encounters.\n   *\n   * <p><b>Warning:</b> {@code File} provides no support for symbolic links, and as such there is no\n   * way to ensure that a symbolic link to a directory is not followed when traversing the tree. In\n   * this case, iterables created by this traverser could contain files that are outside of the\n   * given directory or even be infinite if there is a symbolic link loop.\n   *\n   * <p>If available, consider using {@link MoreFiles#fileTraverser()} instead. It behaves the same\n   * except that it doesn't follow symbolic links and returns {@code Path} instances.\n   *\n   * <p>If the {@link File} passed to one of the {@link Traverser} methods does not exist or is not\n   * a directory, no exception will be thrown and the returned {@link Iterable} will contain a\n   * single element: that file.\n   *\n   * <p>Example: {@code Files.fileTraverser().depthFirstPreOrder(new File(\"/\"))} may return files\n   * with the following paths: {@code [\"/\", \"/etc\", \"/etc/config.txt\", \"/etc/fonts\", \"/home\",\n   * \"/home/alice\", ...]}\n   *\n   * @since 23.5\n   */\n  @Beta\n  public static Traverser<File> fileTraverser() {\n    return Traverser.forTree(FILE_TREE);\n  }\n\n  private static final SuccessorsFunction<File> FILE_TREE =\n      new SuccessorsFunction<File>() {\n        @Override\n        public Iterable<File> successors(File file) {\n          return fileTreeChildren(file);\n        }\n      };\n\n  private static Iterable<File> fileTreeChildren(File file) {\n    // check isDirectory() just because it may be faster than listFiles() on a non-directory\n    if (file.isDirectory()) {\n      File[] files = file.listFiles();\n      if (files != null) {\n        return Collections.unmodifiableList(Arrays.asList(files));\n      }\n    }\n\n    return Collections.emptyList();\n  }\n\n  /**\n   * Returns a predicate that returns the result of {@link File#isDirectory} on input files.\n   *\n   * @since 15.0\n   */\n  @Beta\n  public static Predicate<File> isDirectory() {\n    return FilePredicate.IS_DIRECTORY;\n  }\n\n  /**\n   * Returns a predicate that returns the result of {@link File#isFile} on input files.\n   *\n   * @since 15.0\n   */\n  @Beta\n  public static Predicate<File> isFile() {\n    return FilePredicate.IS_FILE;\n  }\n\n  private enum FilePredicate implements Predicate<File> {\n    IS_DIRECTORY {\n      @Override\n      public boolean apply(File file) {\n        return file.isDirectory();\n      }\n\n      @Override\n      public String toString() {\n        return \"Files.isDirectory()\";\n      }\n    },\n\n    IS_FILE {\n      @Override\n      public boolean apply(File file) {\n        return file.isFile();\n      }\n\n      @Override\n      public String toString() {\n        return \"Files.isFile()\";\n      }\n    }\n  }\n}\n"], "filenames": ["android/guava/src/com/google/common/io/Files.java", "guava/src/com/google/common/io/Files.java"], "buggy_code_start_loc": [400, 400], "buggy_code_end_loc": [411, 411], "fixing_code_start_loc": [401, 401], "fixing_code_end_loc": [423, 423], "type": "CWE-732", "message": "A temp directory creation vulnerability exists in all versions of Guava, allowing an attacker with access to the machine to potentially access data in a temporary directory created by the Guava API com.google.common.io.Files.createTempDir(). By default, on unix-like systems, the created directory is world-readable (readable by an attacker with access to the system). The method in question has been marked @Deprecated in versions 30.0 and later and should not be used. For Android developers, we recommend choosing a temporary directory API provided by Android, such as context.getCacheDir(). For other Java developers, we recommend migrating to the Java 7 API java.nio.file.Files.createTempDirectory() which explicitly configures permissions of 700, or configuring the Java runtime's java.io.tmpdir system property to point to a location whose permissions are appropriately configured.\n\n", "other": {"cve": {"id": "CVE-2020-8908", "sourceIdentifier": "cve-coordination@google.com", "published": "2020-12-10T23:15:13.973", "lastModified": "2023-06-06T10:15:09.257", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A temp directory creation vulnerability exists in all versions of Guava, allowing an attacker with access to the machine to potentially access data in a temporary directory created by the Guava API com.google.common.io.Files.createTempDir(). By default, on unix-like systems, the created directory is world-readable (readable by an attacker with access to the system). The method in question has been marked @Deprecated in versions 30.0 and later and should not be used. For Android developers, we recommend choosing a temporary directory API provided by Android, such as context.getCacheDir(). For other Java developers, we recommend migrating to the Java 7 API java.nio.file.Files.createTempDirectory() which explicitly configures permissions of 700, or configuring the Java runtime's java.io.tmpdir system property to point to a location whose permissions are appropriately configured.\n\n"}, {"lang": "es", "value": "Se presenta una vulnerabilidad en la creaci\u00f3n de directorios temporales en todas las versiones de Guava, que permite a un atacante con acceso a la m\u00e1quina acceder potencialmente a los datos de un directorio temporal creado por la API de Guava com.google.common.io.Files.createTempDir(). Por defecto, en los sistemas de tipo unix, el directorio creado es legible por el mundo (legible por un atacante con acceso al sistema). El m\u00e9todo en cuesti\u00f3n ha sido marcado como @Deprecated en las versiones 30.0 y posteriores y no debe ser utilizado. Para los desarrolladores de Android, recomendamos elegir una API de directorio temporal proporcionada por Android, como context.getCacheDir(). Para otros desarrolladores de Java, recomendamos migrar a la API de Java 7 java.nio.file.Files.createTempDirectory() que configura expl\u00edcitamente los permisos de 700, o configurar la propiedad del sistema java.io.tmpdir del tiempo de ejecuci\u00f3n de Java para que apunte a una ubicaci\u00f3n cuyos permisos est\u00e9n configurados adecuadamente"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}, {"source": "cve-coordination@google.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-732"}]}, {"source": "cve-coordination@google.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-378"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:guava:*:*:*:*:*:*:*:*", "versionEndExcluding": "30.0", "matchCriteriaId": "AB651F00-27B2-4124-9D1D-781BEB6E4DE1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:quarkus:quarkus:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.11.4", "matchCriteriaId": "89306BA8-9E5C-49F6-AB32-B78BE1D831F0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:commerce_guided_search:11.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "2A3622F5-5976-4BBC-A147-FC8A6431EA79"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_network_slice_selection_function:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "ADE6EF8F-1F05-429B-A916-76FDB20CEB81"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_pricing_design_center:12.0.0.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "A28F42F0-FBDA-4574-AD30-7A04F27FEA3E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_pricing_design_center:12.0.0.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "129CA55C-C770-4D42-BD17-9011F3AC93C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:data_integrator:12.2.1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "9901F6BA-78D5-45B8-9409-07FF1C6DDD38"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:data_integrator:12.2.1.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "9FADE563-5AAA-42FF-B43F-35B20A2386C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:nosql_database:*:*:*:*:*:*:*:*", "versionEndExcluding": "20.3", "matchCriteriaId": "D04565AE-D092-4AE0-8FEE-0E8114662A1B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:peoplesoft_enterprise_peopletools:8.57:*:*:*:*:*:*:*", "matchCriteriaId": "7E1E416B-920B-49A0-9523-382898C2979D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:peoplesoft_enterprise_peopletools:8.58:*:*:*:*:*:*:*", "matchCriteriaId": "D9DB4A14-2EF5-4B54-95D2-75E6CF9AA0A9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:peoplesoft_enterprise_peopletools:8.59:*:*:*:*:*:*:*", "matchCriteriaId": "C8AF00C6-B97F-414D-A8DF-057E6BFD8597"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_customer_management_and_segmentation_foundation:*:*:*:*:*:*:*:*", "versionStartIncluding": "16.0", "versionEndIncluding": "19.0", "matchCriteriaId": "B92BB355-DB00-438E-84E5-8EC007009576"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:weblogic_server:14.1.1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "04BCDC24-4A21-473C-8733-0D9CFB38A752"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_network_repository_function:1.14.0:*:*:*:*:*:*:*", "matchCriteriaId": "8E463039-5E48-4AA0-A42B-081053FA0111"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_unifier:*:*:*:*:*:*:*:*", "versionStartIncluding": "17.7", "versionEndIncluding": "17.12", "matchCriteriaId": "08FA59A8-6A62-4B33-8952-D6E658F8DAC9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_unifier:18.8:*:*:*:*:*:*:*", "matchCriteriaId": "202AD518-2E9B-4062-B063-9858AE1F9CE2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_unifier:19.12:*:*:*:*:*:*:*", "matchCriteriaId": "10864586-270E-4ACF-BDCC-ECFCD299305F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_unifier:20.12:*:*:*:*:*:*:*", "matchCriteriaId": "38340E3C-C452-4370-86D4-355B6B4E0A06"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_unifier:21.12:*:*:*:*:*:*:*", "matchCriteriaId": "E9C55C69-E22E-4B80-9371-5CD821D79FE2"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:linux:*:*", "matchCriteriaId": "F3E0B672-3E06-4422-B2A4-0BD073AEC2A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:vmware_vsphere:*:*", "matchCriteriaId": "3A756737-1CC4-42C2-A4DF-E1C893B4E2D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:windows:*:*", "matchCriteriaId": "B55E8D50-99B4-47EC-86F9-699B67D473CE"}]}]}], "references": [{"url": "https://github.com/google/guava/commit/fec0dbc4634006a6162cfd4d0d09c962073ddf40", "source": "cve-coordination@google.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/google/guava/issues/4011", "source": "cve-coordination@google.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r007add131977f4f576c232b25e024249a3d16f66aad14a4b52819d21%40%3Ccommon-issues.hadoop.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/r07ed3e4417ad043a27bee7bb33322e9bfc7d7e6d1719b8e3dfd95c14%40%3Cdev.drill.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/r161b87f8037bbaff400194a63cd2016c9a69f5949f06dcc79beeab54%40%3Cdev.drill.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/r215b3d50f56faeb2f9383505f3e62faa9f549bb23e8a9848b78a968e%40%3Ccommits.ws.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/r294be9d31c0312d2c0837087204b5d4bf49d0552890e6eec716fa6a6%40%3Cyarn-issues.hadoop.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/r2fe45d96eea8434b91592ca08109118f6308d60f6d0e21d52438cfb4%40%3Cdev.drill.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/r3c3b33ee5bef0c67391d27a97cbfd89d44f328cf072b601b58d4e748%40%3Ccommits.pulsar.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/r3dd8881de891598d622227e9840dd7c2ef1d08abbb49e9690c7ae1bc%40%3Cissues.geode.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/r4776f62dfae4a0006658542f43034a7fc199350e35a66d4e18164ee6%40%3Ccommits.cxf.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/r49549a8322f62cd3acfa4490d25bfba0be04f3f9ff4d14fe36199d27%40%3Cyarn-dev.hadoop.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/r58a8775205ab1839dba43054b09a9ab3b25b423a4170b2413c4067ac%40%3Ccommon-issues.hadoop.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/r5b3d93dfdfb7708e796e8762ab40edbde8ff8add48aba53e5ea26f44%40%3Cissues.geode.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/r5d61b98ceb7bba939a651de5900dbd67be3817db6bfcc41c6e04e199%40%3Cyarn-issues.hadoop.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/r6874dfe26eefc41b7c9a5e4a0487846fc4accf8c78ff948b24a1104a%40%3Cdev.drill.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/r68d86f4b06c808204f62bcb254fcb5b0432528ee8d37a07ef4bc8222%40%3Ccommits.ws.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/r79e47ed555bdb1180e528420a7a2bb898541367a29a3bc6bbf0baf2c%40%3Cissues.hive.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/r7b0e81d8367264d6cad98766a469d64d11248eb654417809bfdacf09%40%3Cyarn-issues.hadoop.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/r841c5e14e1b55281523ebcde661ece00b38a0569e00ef5e12bd5f6ba%40%3Cissues.maven.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/ra7ab308481ee729f998691e8e3e02e93b1dedfc98f6b1cd3d86923b3%40%3Cyarn-issues.hadoop.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/rb2364f4cf4d274eab5a7ecfaf64bf575cedf8b0173551997c749d322%40%3Cgitbox.hive.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/rb8c0f1b7589864396690fe42a91a71dea9412e86eec66dc85bbacaaf%40%3Ccommits.cxf.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/rbc7642b9800249553f13457e46b813bea1aec99d2bc9106510e00ff3%40%3Ctorque-dev.db.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/rc2dbc4633a6eea1fcbce6831876cfa17b73759a98c65326d1896cb1a%40%3Ctorque-dev.db.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/rc607bc52f3507b8b9c28c6a747c3122f51ac24afe80af2a670785b97%40%3Cissues.geode.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/rcafc3a637d82bdc9a24036b2ddcad1e519dd0e6f848fcc3d606fd78f%40%3Cdev.hive.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/rd01f5ff0164c468ec7abc96ff7646cea3cce6378da2e4aa29c6bcb95%40%3Cgithub.arrow.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/rd2704306ec729ccac726e50339b8a8f079515cc29ccb77713b16e7c5%40%3Cissues.hive.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/rd5d58088812cf8e677d99b07f73c654014c524c94e7fedbdee047604%40%3Ctorque-dev.db.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/rd7e12d56d49d73e2b8549694974b07561b79b05455f7f781954231bf%40%3Cdev.pig.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/re120f6b3d2f8222121080342c5801fdafca2f5188ceeb3b49c8a1d27%40%3Cyarn-issues.hadoop.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/reebbd63c25bc1a946caa419cec2be78079f8449d1af48e52d47c9e85%40%3Cissues.geode.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/rf00b688ffa620c990597f829ff85fdbba8bf73ee7bfb34783e1f0d4e%40%3Cyarn-dev.hadoop.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/rf9f0fa84b8ae1a285f0210bafec6de2a9eba083007d04640b82aa625%40%3Cissues.geode.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://lists.apache.org/thread.html/rfc27e2727a20a574f39273e0432aa97486a332f9b3068f6ac1346594%40%3Cdev.myfaces.apache.org%3E", "source": "cve-coordination@google.com"}, {"url": "https://security.netapp.com/advisory/ntap-20220210-0003/", "source": "cve-coordination@google.com", "tags": ["Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-COMGOOGLEGUAVA-1015415", "source": "cve-coordination@google.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com//security-alerts/cpujul2021.html", "source": "cve-coordination@google.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuApr2021.html", "source": "cve-coordination@google.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2022.html", "source": "cve-coordination@google.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujan2022.html", "source": "cve-coordination@google.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuoct2021.html", "source": "cve-coordination@google.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/google/guava/commit/fec0dbc4634006a6162cfd4d0d09c962073ddf40"}}