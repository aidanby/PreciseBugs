{"buggy_code": ["/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#ifndef __PJMEDIA_TRANSPORT_H__\n#define __PJMEDIA_TRANSPORT_H__\n\n\n/**\n * @file transport.h Media Transport Interface\n * @brief Transport interface.\n */\n\n#include <pjmedia/types.h>\n#include <pjmedia/errno.h>\n#include <pj/string.h>\n\n/**\n * @defgroup PJMEDIA_TRANSPORT Media Transport\n * @brief Transports.\n * @{\n * The media transport (#pjmedia_transport) is the object to send and\n * receive media packets over the network. The media transport interface\n * allows the library to be extended to support different types of \n * transports to send and receive packets.\n *\n * The media transport is declared as #pjmedia_transport \"class\", which\n * declares \"interfaces\" to use the class in #pjmedia_transport_op\n * structure. For the user of the media transport (normally the user of\n * media transport is media stream, see \\ref PJMED_STRM), these transport\n * \"methods\" are wrapped with API such as #pjmedia_transport_attach(),\n * so it should not need to call the function pointer inside \n * #pjmedia_transport_op directly.\n *\n * The connection between \\ref PJMED_STRM and media transport is shown in\n * the diagram below:\n\n   \\img{pjmedia/docs/media-transport.PNG}\n\n\n * \\section PJMEDIA_TRANSPORT_H_USING Basic Media Transport Usage\n *\n * The media transport's life-cycle normally follows the following stages.\n *\n * \\subsection PJMEDIA_TRANSPORT_H_CREATE Creating the Media Transport\n *\n *  Application creates the media transport when it needs to establish\n *    media session to remote peer. The media transport is created using\n *    specific function to create that particular transport; for example,\n *    for UDP media transport, it is created with #pjmedia_transport_udp_create()\n *    or #pjmedia_transport_udp_create2() functions. Different media\n *    transports will provide different API to create those transports.\n *\n *  Alternatively, application may create pool of media transports when\n *    it is first started up. Using this approach probably is better, since\n *    application has to specify the RTP port when sending the initial\n *    session establishment request (e.g. SIP INVITE request), thus if\n *    application only creates the media transport later when media is to be\n *    established (normally when 200/OK is received, or when 18x is received\n *    for early media), there is a possibility that the particular RTP\n *    port might have been occupied by other programs. Also it is more\n *    efficient since sockets don't need to be closed and re-opened between\n *    calls.\n *\n *\n * \\subsection PJMEDIA_TRANSPORT_H_ATTACH Attaching and Using the Media Transport.\n *\n *  Application specifies the media transport instance when creating\n *    the media session (#pjmedia_session_create()). Alternatively, it\n *    may create the media stream directly with #pjmedia_stream_create()\n *    and specify the transport instance in the argument. (Note: media\n *    session is a high-level abstraction for media communications between\n *    two endpoints, and it may contain more than one media streams, for\n *    example, an audio stream and a video stream).\n *\n *  When stream is created, it will \"attach\" itself to the media \n *    transport by calling #pjmedia_transport_attach(), which is a thin\n *    wrapper which calls \"attach()\" method of the media transport's \n *    \"virtual function pointer\" (#pjmedia_transport_op). Among other things,\n *    the stream specifies two callback functions to the transport: one\n *    callback function will be called by transport when it receives RTP\n *    packet, and another callback for incoming RTCP packet. The \n *    #pjmedia_transport_attach() function also establish the destination\n *    of the outgoing RTP and RTCP packets.\n *\n *  When the stream needs to send outgoing RTP/RTCP packets, it will\n *    call #pjmedia_transport_send_rtp() and #pjmedia_transport_send_rtcp()\n *    of the media transport API, which is a thin wrapper to call send_rtp() \n *    and send_rtcp() methods in the media transport's \"virtual function \n *    pointer\"  (#pjmedia_transport_op).\n *\n *  When the stream is destroyed, it will \"detach\" itself from\n *    the media transport by calling #pjmedia_transport_detach(), which is\n *    a thin wrapper which calls \"detach()\" method of the media transport's \n *    \"virtual function pointer\" (#pjmedia_transport_op). After the transport\n *    is detached from its user (the stream), it will no longer report \n *    incoming RTP/RTCP packets to the stream, and it will refuse to send\n *    outgoing packets since the destination has been cleared.\n *\n *\n * \\subsection PJMEDIA_TRANSPORT_H_REUSE Reusing the Media Transport.\n *\n *  After transport has been detached, application may re-attach the\n *    transport to another stream if it wants to. Detaching and re-attaching\n *    media transport may be preferable than closing and re-opening the\n *    transport, since it is more efficient (sockets don't need to be\n *    closed and re-opened). However it is up to the application to choose\n *    which method is most suitable for its uses.\n *\n * \n * \\subsection PJMEDIA_TRANSPORT_H_DESTROY Destroying the Media Transport.\n *\n *  Finally if application no longer needs the media transport, it will\n *    call #pjmedia_transport_close() function, which is thin wrapper which \n *    calls \"destroy()\" method of the media transport's  \"virtual function \n *    pointer\" (#pjmedia_transport_op). This function releases\n *    all resources used by the transport, such as sockets and memory.\n *\n *\n * \\section offer_answer Interaction with SDP Offer/Answer\n \n   For basic UDP transport, the \\ref PJMEDIA_TRANSPORT_H_USING above is\n   sufficient to use the media transport. However, more complex media\n   transports such as \\ref PJMEDIA_TRANSPORT_SRTP and \\ref\n   PJMEDIA_TRANSPORT_ICE requires closer interactions with SDP offer and\n   answer negotiation.\n\n   The media transports can interact with the SDP offer/answer via\n   these APIs:\n     - #pjmedia_transport_media_create(), to initialize the media transport\n       for new media session,\n     - #pjmedia_transport_encode_sdp(), to encode SDP offer or answer,\n     - #pjmedia_transport_media_start(), to activate the settings that\n       have been negotiated by SDP offer answer, and\n     - #pjmedia_transport_media_stop(), to deinitialize the media transport\n       and reset the transport to its idle state.\n   \n   The usage of these API in the context of SDP offer answer will be \n   described below.\n\n   \\subsection media_create Initializing Transport for New Session\n\n   Application must call #pjmedia_transport_media_create() before using\n   the transport for a new session.\n\n   \\subsection creat_oa Creating SDP Offer and Answer\n\n   The #pjmedia_transport_encode_sdp() is used to put additional information\n   from the transport to the local SDP, before the SDP is sent and negotiated\n   with remote SDP.\n\n   When creating an offer, call #pjmedia_transport_encode_sdp() with\n   local SDP (and NULL as \\a rem_sdp). The media transport will add the\n   relevant attributes in the local SDP. Application then gives the local\n   SDP to the invite session to be sent to remote agent.\n\n   When creating an answer, also call #pjmedia_transport_encode_sdp(),\n   but this time specify both local and remote SDP to the function. The \n   media transport will once again modify the local SDP and add relevant\n   attributes to the local SDP, if the appropriate attributes related to\n   the transport functionality are present in remote offer. The remote\n   SDP does not contain the relevant attributes, then the specific transport\n   functionality will not be activated for the session.\n\n   The #pjmedia_transport_encode_sdp() should also be called when application\n   sends subsequent SDP offer or answer. The media transport will encode\n   the appropriate attributes based on the state of the session.\n\n   \\subsection media_start Offer/Answer Completion\n\n   Once both local and remote SDP have been negotiated by the \n   \\ref PJMEDIA_SDP_NEG (normally this is part of PJSIP invite session),\n   application should give both local and remote SDP to \n   #pjmedia_transport_media_start() so that the settings are activated\n   for the session. This function should be called for both initial and\n   subsequent SDP negotiation.\n\n   \\subsection media_stop Stopping Transport\n\n   Once session is stop application must call #pjmedia_transport_media_stop()\n   to deactivate the transport feature. Application may reuse the transport\n   for subsequent media session by repeating the #pjmedia_transport_media_create(),\n   #pjmedia_transport_encode_sdp(), #pjmedia_transport_media_start(), and\n   #pjmedia_transport_media_stop() above.\n\n * \\section PJMEDIA_TRANSPORT_H_IMPL Implementing Media Transport\n *\n * To implement a new type of media transport, one needs to \"subclass\" the\n * media transport \"class\" (#pjmedia_transport) by providing the \"methods\"\n * in the media transport \"interface\" (#pjmedia_transport_op), and provides\n * a function to create this new type of transport (similar to \n * #pjmedia_transport_udp_create() function).\n *\n * The media transport is expected to run indepently, that is there should\n * be no polling like function to poll the transport for incoming RTP/RTCP\n * packets. This normally can be done by registering the media sockets to\n * the media endpoint's IOQueue, which allows the transport to be notified\n * when incoming packet has arrived.\n *\n * Alternatively, media transport may utilize thread(s) internally to wait\n * for incoming packets. The thread then will call the appropriate RTP or\n * RTCP callback provided by its user (stream) whenever packet is received.\n * If the transport's user is a stream, then the callbacks provided by the\n * stream will be thread-safe, so the transport may call these callbacks\n * without having to serialize the access with some mutex protection. But\n * the media transport may still have to protect its internal data with\n * mutex protection, since it may be called by application's thread (for\n * example, to send RTP/RTCP packets).\n *\n */\n\n\n#include <pjmedia/sdp.h>\n\nPJ_BEGIN_DECL\n\n\n/**\n * Forward declaration for media transport.\n */\ntypedef struct pjmedia_transport pjmedia_transport;\n\n/**\n * Forward declaration for media transport info.\n */\ntypedef struct pjmedia_transport_info pjmedia_transport_info;\n\n/**\n * Forward declaration for media transport attach param.\n */\ntypedef struct pjmedia_transport_attach_param pjmedia_transport_attach_param;\n\n/**\n * This enumeration specifies the general behaviour of media processing\n */\ntypedef enum pjmedia_tranport_media_option\n{\n    /**\n     * When this flag is specified, the transport will not perform media\n     * transport validation, this is useful when transport is stacked with\n     * other transport, for example when transport UDP is stacked under\n     * transport SRTP, media transport validation only need to be done by \n     * transport SRTP.\n     */\n    PJMEDIA_TPMED_NO_TRANSPORT_CHECKING = 1,\n\n    /**\n     * When this flag is specified, the transport will allow multiplexing\n     * RTP and RTCP, i.e. if the remote agrees, RTCP will be sent using\n     * the same socket for RTP.\n     */\n    PJMEDIA_TPMED_RTCP_MUX = 2\n\n} pjmedia_tranport_media_option;\n\n\n/**\n * Media socket info is used to describe the underlying sockets\n * to be used as media transport.\n */\ntypedef struct pjmedia_sock_info\n{\n    /** The RTP socket handle */\n    pj_sock_t       rtp_sock;\n\n    /** Address to be advertised as the local address for the RTP\n     *  socket, which does not need to be equal as the bound\n     *  address (for example, this address can be the address resolved\n     *  with STUN).\n     */\n    pj_sockaddr     rtp_addr_name;\n\n    /** The RTCP socket handle. */\n    pj_sock_t       rtcp_sock;\n\n    /** Address to be advertised as the local address for the RTCP\n     *  socket, which does not need to be equal as the bound\n     *  address (for example, this address can be the address resolved\n     *  with STUN).\n     */\n    pj_sockaddr     rtcp_addr_name;\n\n} pjmedia_sock_info;\n\n\n/**\n * This structure describes the operations for the stream transport.\n */\nstruct pjmedia_transport_op\n{\n    /**\n     * Get media socket info from the specified transport.\n     *\n     * Application should call #pjmedia_transport_get_info() instead\n     */\n    pj_status_t (*get_info)(pjmedia_transport *tp,\n                            pjmedia_transport_info *info);\n\n    /**\n     * This function is called by the stream when the transport is about\n     * to be used by the stream for the first time, and it tells the transport\n     * about remote RTP address to send the packet and some callbacks to be \n     * called for incoming packets. This function exists for backwards\n     * compatibility. Transports should implement attach2 instead.\n     *\n     * Application should call #pjmedia_transport_attach() instead of \n     * calling this function directly.\n     */\n    pj_status_t (*attach)(pjmedia_transport *tp,\n                          void *user_data,\n                          const pj_sockaddr_t *rem_addr,\n                          const pj_sockaddr_t *rem_rtcp,\n                          unsigned addr_len,\n                          void (*rtp_cb)(void *user_data,\n                                         void *pkt,\n                                         pj_ssize_t size),\n                          void (*rtcp_cb)(void *user_data,\n                                          void *pkt,\n                                          pj_ssize_t size));\n\n    /**\n     * This function is called by the stream when the stream no longer\n     * needs the transport (normally when the stream is about to be closed).\n     * After the transport is detached, it will ignore incoming\n     * RTP/RTCP packets, and will refuse to send outgoing RTP/RTCP packets.\n     * Application may re-attach the media transport to another transport \n     * user (e.g. stream) after the transport has been detached.\n     *\n     * Application should call #pjmedia_transport_detach() instead of \n     * calling this function directly.\n     */\n    void (*detach)(pjmedia_transport *tp,\n                   void *user_data);\n\n    /**\n     * This function is called by the stream to send RTP packet using the \n     * transport.\n     *\n     * Application should call #pjmedia_transport_send_rtp() instead of \n     * calling this function directly.\n     */\n    pj_status_t (*send_rtp)(pjmedia_transport *tp,\n                            const void *pkt,\n                            pj_size_t size);\n\n    /**\n     * This function is called by the stream to send RTCP packet using the\n     * transport.\n     *\n     * Application should call #pjmedia_transport_send_rtcp() instead of \n     * calling this function directly.\n     */\n    pj_status_t (*send_rtcp)(pjmedia_transport *tp,\n                             const void *pkt,\n                             pj_size_t size);\n\n    /**\n     * This function is called by the stream to send RTCP packet using the\n     * transport with destination address other than default specified in\n     * #pjmedia_transport_attach().\n     *\n     * Application should call #pjmedia_transport_send_rtcp2() instead of \n     * calling this function directly.\n     */\n    pj_status_t (*send_rtcp2)(pjmedia_transport *tp,\n                              const pj_sockaddr_t *addr,\n                              unsigned addr_len,\n                              const void *pkt,\n                              pj_size_t size);\n\n    /**\n     * Prepare the transport for a new media session.\n     *\n     * Application should call #pjmedia_transport_media_create() instead of \n     * calling this function directly.\n     */\n    pj_status_t (*media_create)(pjmedia_transport *tp,\n                                pj_pool_t *sdp_pool,\n                                unsigned options,\n                                const pjmedia_sdp_session *remote_sdp,\n                                unsigned media_index);\n\n    /**\n     * This function is called by application to generate the SDP parts\n     * related to transport type, e.g: ICE, SRTP.\n     *\n     * Application should call #pjmedia_transport_encode_sdp() instead of\n     * calling this function directly.\n     */\n    pj_status_t (*encode_sdp)(pjmedia_transport *tp,\n                              pj_pool_t *sdp_pool,\n                              pjmedia_sdp_session *sdp_local,\n                              const pjmedia_sdp_session *rem_sdp,\n                              unsigned media_index);\n\n    /**\n     * This function is called by application to start the transport\n     * based on local and remote SDP.\n     *\n     * Application should call #pjmedia_transport_media_start() instead of \n     * calling this function directly.\n     */\n    pj_status_t (*media_start) (pjmedia_transport *tp,\n                                pj_pool_t *tmp_pool,\n                                const pjmedia_sdp_session *sdp_local,\n                                const pjmedia_sdp_session *sdp_remote,\n                                unsigned media_index);\n\n    /**\n     * This function is called by application to stop the transport.\n     *\n     * Application should call #pjmedia_transport_media_stop() instead of \n     * calling this function directly.\n     */\n    pj_status_t (*media_stop)  (pjmedia_transport *tp);\n\n    /**\n     * This function can be called to simulate packet lost.\n     *\n     * Application should call #pjmedia_transport_simulate_lost() instead of \n     * calling this function directly.\n     */\n    pj_status_t (*simulate_lost)(pjmedia_transport *tp,\n                                 pjmedia_dir dir,\n                                 unsigned pct_lost);\n\n    /**\n     * This function can be called to destroy this transport.\n     *\n     * Application should call #pjmedia_transport_close() instead of \n     * calling this function directly.\n     */\n    pj_status_t (*destroy)(pjmedia_transport *tp);\n\n    /**\n     * This function is called by the stream when the transport is about\n     * to be used by the stream for the first time, and it tells the transport\n     * about remote RTP address to send the packet and some callbacks to be\n     * called for incoming packets.\n     *\n     * Application should call #pjmedia_transport_attach2() instead of\n     * calling this function directly.\n     */\n    pj_status_t (*attach2)(pjmedia_transport *tp,\n                           pjmedia_transport_attach_param *att_param);\n};\n\n\n/**\n * @see pjmedia_transport_op.\n */\ntypedef struct pjmedia_transport_op pjmedia_transport_op;\n\n\n/** \n * Media transport type.\n */\ntypedef enum pjmedia_transport_type\n{\n    /** Media transport using standard UDP */\n    PJMEDIA_TRANSPORT_TYPE_UDP,\n\n    /** Media transport using ICE */\n    PJMEDIA_TRANSPORT_TYPE_ICE,\n\n    /** \n     * Media transport SRTP, this transport is actually security adapter to be\n     * stacked with other transport to enable encryption on the underlying\n     * transport.\n     */\n    PJMEDIA_TRANSPORT_TYPE_SRTP,\n\n    /** Loopback media transport */\n    PJMEDIA_TRANSPORT_TYPE_LOOP,\n\n    /**\n     * Start of user defined transport.\n     */\n    PJMEDIA_TRANSPORT_TYPE_USER\n\n} pjmedia_transport_type;\n\n\n/**\n * This structure declares media transport. A media transport is called\n * by the stream to transmit a packet, and will notify stream when\n * incoming packet is arrived.\n */\nstruct pjmedia_transport\n{\n    /** Transport name (for logging purpose). */\n    char                     name[PJ_MAX_OBJ_NAME];\n\n    /** Transport type. */\n    pjmedia_transport_type   type;\n\n    /** Transport's \"virtual\" function table. */\n    pjmedia_transport_op    *op;\n\n    /** Application/user data */\n    void                    *user_data;\n};\n\n/**\n * This structure describes storage buffer of transport specific info.\n * The actual transport specific info contents will be defined by transport\n * implementation. Note that some transport implementations do not need to\n * provide specific info, since the general socket info is enough.\n */\ntypedef struct pjmedia_transport_specific_info\n{\n    /**\n     * Specify media transport type.\n     */\n    pjmedia_transport_type   type;\n\n    /**\n     * Specify storage buffer size of transport specific info.\n     */\n    int                      cbsize;\n\n    /**\n     * Storage buffer of transport specific info.\n     */\n    char                     buffer[PJMEDIA_TRANSPORT_SPECIFIC_INFO_MAXSIZE];\n\n    /**\n     * The media transport instance.\n     */\n    pjmedia_transport       *tp;\n\n} pjmedia_transport_specific_info;\n\n\n/**\n * This structure describes transport informations, including general \n * socket information and specific information of single transport or \n * stacked transports (e.g: SRTP stacked on top of UDP)\n */\nstruct pjmedia_transport_info\n{\n    /**\n     * General socket info.\n     */\n    pjmedia_sock_info sock_info;\n\n    /**\n     * Remote address where RTP/RTCP originated from. In case this transport\n     * hasn't ever received packet, the address can be invalid (zero).\n     */\n    pj_sockaddr     src_rtp_name;\n    pj_sockaddr     src_rtcp_name;\n\n    /**\n     * Specifies number of transport specific info included.\n     */\n    unsigned specific_info_cnt;\n\n    /**\n     * Buffer storage of transport specific info.\n     */\n    pjmedia_transport_specific_info spc_info[PJMEDIA_TRANSPORT_SPECIFIC_INFO_MAXCNT];\n\n};\n\n/**\n * This structure describes the data passed when calling #rtp_cb2().\n */\ntypedef struct pjmedia_tp_cb_param\n{\n    /**\n     * User data.\n     */\n    void               *user_data;\n\n    /**\n     * Packet buffer.\n     */\n    void               *pkt;\n\n    /**\n     * Packet size.\n     */\n    pj_ssize_t          size;\n\n    /**\n     * Packet's source address.\n     */\n    pj_sockaddr        *src_addr;\n\n    /**\n     * Should media transport switch remote address to \\a rtp_src_addr?\n     * Media transport should initialize it to PJ_FALSE, and application\n     * can change the value as necessary.\n     */\n    pj_bool_t           rem_switch;\n\n} pjmedia_tp_cb_param;\n\n/**\n * This structure describes the data passed when calling\n * #pjmedia_transport_attach2().\n */\nstruct pjmedia_transport_attach_param\n{\n    /**\n     * The media stream.\n     */\n    void *stream;\n\n    /**\n     * Indicate the stream type, either it's audio (PJMEDIA_TYPE_AUDIO) \n     * or video (PJMEDIA_TYPE_VIDEO).\n     */\n    pjmedia_type media_type;\n\n    /**\n     * Remote RTP address to send RTP packet to.\n     */\n    pj_sockaddr rem_addr;\n\n    /**\n     * Optional remote RTCP address. If the argument is NULL\n     * or if the address is zero, the RTCP address will be\n     * calculated from the RTP address (which is RTP port plus one).\n     */\n    pj_sockaddr rem_rtcp;\n\n    /**\n     * Length of the remote address.\n     */\n    unsigned addr_len;\n\n    /**\n     * Arbitrary user data to be set when the callbacks are called.\n     */\n    void *user_data;\n\n    /**\n     * Callback to be called when RTP packet is received on the transport.\n     */\n    void (*rtp_cb)(void *user_data, void *pkt, pj_ssize_t);\n\n    /**\n     * Callback to be called when RTCP packet is received on the transport.\n     */\n    void (*rtcp_cb)(void *user_data, void *pkt, pj_ssize_t);\n\n    /**\n     * Callback to be called when RTP packet is received on the transport.\n     */\n    void (*rtp_cb2)(pjmedia_tp_cb_param *param);\n\n};\n\n/**\n * Initialize transport info.\n *\n * @param info      Transport info to be initialized.\n */\nPJ_INLINE(void) pjmedia_transport_info_init(pjmedia_transport_info *info)\n{\n    pj_bzero(info, sizeof(pjmedia_transport_info));\n    info->sock_info.rtp_sock = info->sock_info.rtcp_sock = PJ_INVALID_SOCKET;\n}\n\n\n/**\n * Get media transport info from the specified transport and all underlying \n * transports if any. The transport also contains information about socket info\n * which describes the local address of the transport, and would be needed\n * for example to fill in the \"c=\" and \"m=\" line of local SDP.\n *\n * @param tp        The transport.\n * @param info      Media transport info to be initialized.\n *\n * @return          PJ_SUCCESS on success.\n */\nPJ_INLINE(pj_status_t) pjmedia_transport_get_info(pjmedia_transport *tp,\n                                                  pjmedia_transport_info *info)\n{\n    if (tp && tp->op && tp->op->get_info)\n        return (*tp->op->get_info)(tp, info);\n    \n    return PJ_ENOTSUP;\n}\n\n\n/**\n * Utility API to get transport type specific info from the specified media\n * transport info.\n * \n * @param info      Media transport info.\n * @param type      Media transport type.\n *\n * @return          Pointer to media transport specific info, or NULL if\n *                  specific info for the transport type is not found.\n */\nPJ_INLINE(void*) pjmedia_transport_info_get_spc_info(\n                                                pjmedia_transport_info *info,\n                                                pjmedia_transport_type type)\n{\n    unsigned i;\n    for (i = 0; i < info->specific_info_cnt; ++i) {\n        if (info->spc_info[i].type == type)\n            return (void*)info->spc_info[i].buffer;\n    }\n    return NULL;\n}\n\n\n/**\n * Utility API to get the transport instance from the specified media\n * transport info.\n *\n * @param info      Media transport info.\n * @param type      Media transport type.\n *\n * @return          The media transport instance, or NULL if\n *                  the transport type is not found.\n */\nPJ_INLINE(pjmedia_transport*) pjmedia_transport_info_get_transport(\n                                                pjmedia_transport_info *info,\n                                                pjmedia_transport_type type)\n{\n    unsigned i;\n    for (i = 0; i < info->specific_info_cnt; ++i) {\n        if (info->spc_info[i].type == type)\n            return info->spc_info[i].tp;\n    }\n    return NULL;\n}\n\n\n/**\n * Attach callbacks to be called on receipt of incoming RTP/RTCP packets.\n * This is just a simple wrapper which calls <tt>attach2()</tt> member of\n * the transport if it is implemented, otherwise it calls <tt>attach()</tt>\n * member of the transport.\n *\n * @param tp        The media transport.\n * @param att_param The transport attach param.\n *\n * @return          PJ_SUCCESS on success, or the appropriate error code.\n */\nPJ_INLINE(pj_status_t) pjmedia_transport_attach2(pjmedia_transport *tp,\n                                  pjmedia_transport_attach_param *att_param)\n{\n    if (tp->op->attach2) {\n        return (*tp->op->attach2)(tp, att_param);\n    } else {\n        return (*tp->op->attach)(tp, att_param->user_data, \n                                 (pj_sockaddr_t*)&att_param->rem_addr, \n                                 (pj_sockaddr_t*)&att_param->rem_rtcp, \n                                 att_param->addr_len, att_param->rtp_cb, \n                                 att_param->rtcp_cb);\n    }\n}\n\n\n/**\n * Attach callbacks to be called on receipt of incoming RTP/RTCP packets.\n * This is just a simple wrapper which calls <tt>attach()</tt> member of \n * the transport.\n *\n * @param tp        The media transport.\n * @param user_data Arbitrary user data to be set when the callbacks are \n *                  called.\n * @param rem_addr  Remote RTP address to send RTP packet to.\n * @param rem_rtcp  Optional remote RTCP address. If the argument is NULL\n *                  or if the address is zero, the RTCP address will be\n *                  calculated from the RTP address (which is RTP port\n *                  plus one).\n * @param addr_len  Length of the remote address.\n * @param rtp_cb    Callback to be called when RTP packet is received on\n *                  the transport.\n * @param rtcp_cb   Callback to be called when RTCP packet is received on\n *                  the transport.\n *\n * @return          PJ_SUCCESS on success, or the appropriate error code.\n */\nPJ_INLINE(pj_status_t) pjmedia_transport_attach(pjmedia_transport *tp,\n                                                void *user_data,\n                                                const pj_sockaddr_t *rem_addr,\n                                                const pj_sockaddr_t *rem_rtcp,\n                                                unsigned addr_len,\n                                                void (*rtp_cb)(void *user_data,\n                                                               void *pkt,\n                                                               pj_ssize_t),\n                                                void (*rtcp_cb)(void *usr_data,\n                                                                void*pkt,\n                                                                pj_ssize_t))\n{\n    if (tp->op->attach2) {\n        pjmedia_transport_attach_param param;\n\n        pj_bzero(&param, sizeof(param));\n        param.user_data = user_data;\n        pj_sockaddr_cp(&param.rem_addr, rem_addr);\n        if (rem_rtcp && pj_sockaddr_has_addr(rem_rtcp)) {\n            pj_sockaddr_cp(&param.rem_rtcp, rem_rtcp);\n        } else {\n            /* Copy RTCP address from the RTP address, with port + 1 */\n            pj_memcpy(&param.rem_rtcp, rem_addr, addr_len);\n            pj_sockaddr_set_port(&param.rem_rtcp,\n                                 pj_sockaddr_get_port(rem_addr) + 1);\n        }\n        param.addr_len = addr_len;\n        param.rtp_cb = rtp_cb;\n        param.rtcp_cb = rtcp_cb;\n\n        return (*tp->op->attach2)(tp, &param);\n    } else {\n        return (*tp->op->attach)(tp, user_data, rem_addr, rem_rtcp, addr_len,\n                                 rtp_cb, rtcp_cb);\n    }\n}\n\n\n/**\n * Detach callbacks from the transport.\n * This is just a simple wrapper which calls <tt>detach()</tt> member of \n * the transport. After the transport is detached, it will ignore incoming\n * RTP/RTCP packets, and will refuse to send outgoing RTP/RTCP packets.\n * Application may re-attach the media transport to another transport user\n * (e.g. stream) after the transport has been detached.\n *\n * @param tp        The media transport.\n * @param user_data User data which must match the previously set value\n *                  on attachment.\n */\nPJ_INLINE(void) pjmedia_transport_detach(pjmedia_transport *tp,\n                                         void *user_data)\n{\n    (*tp->op->detach)(tp, user_data);\n}\n\n\n/**\n * Send RTP packet with the specified media transport. This is just a simple\n * wrapper which calls <tt>send_rtp()</tt> member of the transport. The \n * RTP packet will be delivered to the destination address specified in\n * #pjmedia_transport_attach() function.\n *\n * @param tp        The media transport.\n * @param pkt       The packet to send.\n * @param size      Size of the packet.\n *\n * @return          PJ_SUCCESS on success, or the appropriate error code.\n */\nPJ_INLINE(pj_status_t) pjmedia_transport_send_rtp(pjmedia_transport *tp,\n                                                  const void *pkt,\n                                                  pj_size_t size)\n{\n    return (*tp->op->send_rtp)(tp, pkt, size);\n}\n\n\n/**\n * Send RTCP packet with the specified media transport. This is just a simple\n * wrapper which calls <tt>send_rtcp()</tt> member of the transport. The \n * RTCP packet will be delivered to the destination address specified in\n * #pjmedia_transport_attach() function.\n *\n * @param tp        The media transport.\n * @param pkt       The packet to send.\n * @param size      Size of the packet.\n *\n * @return          PJ_SUCCESS on success, or the appropriate error code.\n */\nPJ_INLINE(pj_status_t) pjmedia_transport_send_rtcp(pjmedia_transport *tp,\n                                                  const void *pkt,\n                                                  pj_size_t size)\n{\n    return (*tp->op->send_rtcp)(tp, pkt, size);\n}\n\n\n/**\n * Send RTCP packet with the specified media transport. This is just a simple\n * wrapper which calls <tt>send_rtcp2()</tt> member of the transport. The \n * RTCP packet will be delivered to the destination address specified in\n * param addr, if addr is NULL, RTCP packet will be delivered to destination \n * address specified in #pjmedia_transport_attach() function.\n *\n * @param tp        The media transport.\n * @param addr      The destination address.\n * @param addr_len  Length of destination address.\n * @param pkt       The packet to send.\n * @param size      Size of the packet.\n *\n * @return          PJ_SUCCESS on success, or the appropriate error code.\n */\nPJ_INLINE(pj_status_t) pjmedia_transport_send_rtcp2(pjmedia_transport *tp,\n                                                    const pj_sockaddr_t *addr,\n                                                    unsigned addr_len,\n                                                    const void *pkt,\n                                                    pj_size_t size)\n{\n    return (*tp->op->send_rtcp2)(tp, addr, addr_len, pkt, size);\n}\n\n\n/**\n * Prepare the media transport for a new media session, Application must\n * call this function before starting a new media session using this\n * transport.\n *\n * This is just a simple wrapper which calls <tt>media_create()</tt> member \n * of the transport.\n *\n * @param tp            The media transport.\n * @param sdp_pool      Pool object to allocate memory related to SDP\n *                      messaging components.\n * @param options       Option flags, from #pjmedia_tranport_media_option\n * @param rem_sdp       Remote SDP if local SDP is an answer, otherwise\n *                      specify NULL if SDP is an offer.\n * @param media_index   Media index in SDP.\n *\n * @return              PJ_SUCCESS on success, or the appropriate error code.\n */\nPJ_INLINE(pj_status_t) pjmedia_transport_media_create(pjmedia_transport *tp,\n                                    pj_pool_t *sdp_pool,\n                                    unsigned options,\n                                    const pjmedia_sdp_session *rem_sdp,\n                                    unsigned media_index)\n{\n    return (*tp->op->media_create)(tp, sdp_pool, options, rem_sdp, \n                                   media_index);\n}\n\n\n/**\n * Put transport specific information into the SDP. This function can be\n * called to put transport specific information in the initial or\n * subsequent SDP offer or answer.\n *\n * This is just a simple wrapper which calls <tt>encode_sdp()</tt> member \n * of the transport.\n *\n * @param tp            The media transport.\n * @param sdp_pool      Pool object to allocate memory related to SDP\n *                      messaging components.\n * @param sdp           The local SDP to be filled in information from the\n *                      media transport.\n * @param rem_sdp       Remote SDP if local SDP is an answer, otherwise\n *                      specify NULL if SDP is an offer.\n * @param media_index   Media index in SDP.\n *\n * @return              PJ_SUCCESS on success, or the appropriate error code.\n */\nPJ_INLINE(pj_status_t) pjmedia_transport_encode_sdp(pjmedia_transport *tp,\n                                            pj_pool_t *sdp_pool,\n                                            pjmedia_sdp_session *sdp,\n                                            const pjmedia_sdp_session *rem_sdp,\n                                            unsigned media_index)\n{\n    return (*tp->op->encode_sdp)(tp, sdp_pool, sdp, rem_sdp, media_index);\n}\n\n\n/**\n * Start the transport session with the settings in both local and remote \n * SDP. The actual work that is done by this function depends on the \n * underlying transport type. For SRTP, this will activate the encryption\n * and decryption based on the keys found the SDPs. For ICE, this will\n * start ICE negotiation according to the information found in the SDPs.\n *\n * This is just a simple wrapper which calls <tt>media_start()</tt> member \n * of the transport.\n *\n * @param tp            The media transport.\n * @param tmp_pool      The memory pool for allocating temporary objects.\n * @param sdp_local     Local SDP.\n * @param sdp_remote    Remote SDP.\n * @param media_index   Media index in the SDP.\n *\n * @return              PJ_SUCCESS on success, or the appropriate error code.\n */\nPJ_INLINE(pj_status_t) pjmedia_transport_media_start(pjmedia_transport *tp,\n                                    pj_pool_t *tmp_pool,\n                                    const pjmedia_sdp_session *sdp_local,\n                                    const pjmedia_sdp_session *sdp_remote,\n                                    unsigned media_index)\n{\n    return (*tp->op->media_start)(tp, tmp_pool, sdp_local, sdp_remote, \n                                  media_index);\n}\n\n\n/**\n * This API should be called when the session is stopped, to allow the media\n * transport to release its resources used for the session.\n *\n * This is just a simple wrapper which calls <tt>media_stop()</tt> member \n * of the transport.\n *\n * @param tp            The media transport.\n *\n * @return              PJ_SUCCESS on success, or the appropriate error code.\n */\nPJ_INLINE(pj_status_t) pjmedia_transport_media_stop(pjmedia_transport *tp)\n{\n    return (*tp->op->media_stop)(tp);\n}\n\n/**\n * Close media transport. This is just a simple wrapper which calls \n * <tt>destroy()</tt> member of the transport. This function will free\n * all resources created by this transport (such as sockets, memory, etc.).\n *\n * @param tp        The media transport.\n *\n * @return          PJ_SUCCESS on success, or the appropriate error code.\n */\nPJ_INLINE(pj_status_t) pjmedia_transport_close(pjmedia_transport *tp)\n{\n    if (tp->op->destroy)\n        return (*tp->op->destroy)(tp);\n    else\n        return PJ_SUCCESS;\n}\n\n/**\n * Simulate packet lost in the specified direction (for testing purposes).\n * When enabled, the transport will randomly drop packets to the specified\n * direction.\n *\n * @param tp        The media transport.\n * @param dir       Media direction to which packets will be randomly dropped.\n * @param pct_lost  Percent lost (0-100). Set to zero to disable packet\n *                  lost simulation.\n *\n * @return          PJ_SUCCESS on success.\n */\nPJ_INLINE(pj_status_t) pjmedia_transport_simulate_lost(pjmedia_transport *tp,\n                                                       pjmedia_dir dir,\n                                                       unsigned pct_lost)\n{\n    return (*tp->op->simulate_lost)(tp, dir, pct_lost);\n}\n\n\nPJ_END_DECL\n\n/**\n * @}\n */\n\n\n#endif  /* __PJMEDIA_TRANSPORT_H__ */\n\n", "/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/transport_adapter_sample.h>\n#include <pjmedia/endpoint.h>\n#include <pj/assert.h>\n#include <pj/pool.h>\n\n\n/* Transport functions prototypes */\nstatic pj_status_t transport_get_info (pjmedia_transport *tp,\n                                       pjmedia_transport_info *info);\nstatic pj_status_t transport_attach2  (pjmedia_transport *tp,\n                                       pjmedia_transport_attach_param *att_prm);\nstatic void        transport_detach   (pjmedia_transport *tp,\n                                       void *strm);\nstatic pj_status_t transport_send_rtp( pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_send_rtcp(pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_send_rtcp2(pjmedia_transport *tp,\n                                       const pj_sockaddr_t *addr,\n                                       unsigned addr_len,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_media_create(pjmedia_transport *tp,\n                                       pj_pool_t *sdp_pool,\n                                       unsigned options,\n                                       const pjmedia_sdp_session *rem_sdp,\n                                       unsigned media_index);\nstatic pj_status_t transport_encode_sdp(pjmedia_transport *tp,\n                                       pj_pool_t *sdp_pool,\n                                       pjmedia_sdp_session *local_sdp,\n                                       const pjmedia_sdp_session *rem_sdp,\n                                       unsigned media_index);\nstatic pj_status_t transport_media_start (pjmedia_transport *tp,\n                                       pj_pool_t *pool,\n                                       const pjmedia_sdp_session *local_sdp,\n                                       const pjmedia_sdp_session *rem_sdp,\n                                       unsigned media_index);\nstatic pj_status_t transport_media_stop(pjmedia_transport *tp);\nstatic pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n                                       pjmedia_dir dir,\n                                       unsigned pct_lost);\nstatic pj_status_t transport_destroy  (pjmedia_transport *tp);\n\n\n/* The transport operations */\nstatic struct pjmedia_transport_op tp_adapter_op = \n{\n    &transport_get_info,\n    NULL,\n    &transport_detach,\n    &transport_send_rtp,\n    &transport_send_rtcp,\n    &transport_send_rtcp2,\n    &transport_media_create,\n    &transport_encode_sdp,\n    &transport_media_start,\n    &transport_media_stop,\n    &transport_simulate_lost,\n    &transport_destroy,\n    &transport_attach2,\n};\n\n\n/* The transport adapter instance */\nstruct tp_adapter\n{\n    pjmedia_transport    base;\n    pj_bool_t            del_base;\n\n    pj_pool_t           *pool;\n\n    /* Stream information. */\n    void                *stream_user_data;\n    void                *stream_ref;\n    void               (*stream_rtp_cb)(void *user_data,\n                                        void *pkt,\n                                        pj_ssize_t);\n    void               (*stream_rtp_cb2)(pjmedia_tp_cb_param *param);\n    void               (*stream_rtcp_cb)(void *user_data,\n                                         void *pkt,\n                                         pj_ssize_t);\n\n\n    /* Add your own member here.. */\n    pjmedia_transport   *slave_tp;\n};\n\n\n/*\n * Create the adapter.\n */\nPJ_DEF(pj_status_t) pjmedia_tp_adapter_create( pjmedia_endpt *endpt,\n                                               const char *name,\n                                               pjmedia_transport *transport,\n                                               pj_bool_t del_base,\n                                               pjmedia_transport **p_tp)\n{\n    pj_pool_t *pool;\n    struct tp_adapter *adapter;\n\n    if (name == NULL)\n        name = \"tpad%p\";\n\n    /* Create the pool and initialize the adapter structure */\n    pool = pjmedia_endpt_create_pool(endpt, name, 512, 512);\n    adapter = PJ_POOL_ZALLOC_T(pool, struct tp_adapter);\n    adapter->pool = pool;\n    pj_ansi_strxcpy(adapter->base.name, pool->obj_name, \n                    sizeof(adapter->base.name));\n    adapter->base.type = (pjmedia_transport_type)\n                         (PJMEDIA_TRANSPORT_TYPE_USER + 1);\n    adapter->base.op = &tp_adapter_op;\n\n    /* Save the transport as the slave transport */\n    adapter->slave_tp = transport;\n    adapter->del_base = del_base;\n\n    /* Done */\n    *p_tp = &adapter->base;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * get_info() is called to get the transport addresses to be put\n * in SDP c= line and a=rtcp line.\n */\nstatic pj_status_t transport_get_info(pjmedia_transport *tp,\n                                      pjmedia_transport_info *info)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n\n    /* Since we don't have our own connection here, we just pass\n     * this function to the slave transport.\n     */\n    return pjmedia_transport_get_info(adapter->slave_tp, info);\n}\n\n\n/* This is our RTP callback, that is called by the slave transport when it\n * receives RTP packet.\n */\nstatic void transport_rtp_cb2(pjmedia_tp_cb_param *param)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)param->user_data;\n\n    pj_assert(adapter->stream_rtp_cb != NULL ||\n              adapter->stream_rtp_cb2 != NULL);\n\n    /* Call stream's callback */\n    if (adapter->stream_rtp_cb2) {\n        pjmedia_tp_cb_param cbparam;\n        \n        pj_memcpy(&cbparam, param, sizeof(cbparam));\n        cbparam.user_data = adapter->stream_user_data;\n        adapter->stream_rtp_cb2(&cbparam);\n    } else {\n        adapter->stream_rtp_cb(adapter->stream_user_data, param->pkt,\n                               param->size);\n    }\n}\n\n/* This is our RTCP callback, that is called by the slave transport when it\n * receives RTCP packet.\n */\nstatic void transport_rtcp_cb(void *user_data, void *pkt, pj_ssize_t size)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)user_data;\n\n    pj_assert(adapter->stream_rtcp_cb != NULL);\n\n    /* Call stream's callback */\n    adapter->stream_rtcp_cb(adapter->stream_user_data, pkt, size);\n}\n\n/*\n * attach2() is called by stream to register callbacks that we should\n * call on receipt of RTP and RTCP packets.\n */\nstatic pj_status_t transport_attach2(pjmedia_transport *tp,\n                                     pjmedia_transport_attach_param *att_param)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n    pj_status_t status;\n\n    /* In this example, we will save the stream information and callbacks\n     * to our structure, and we will register different RTP/RTCP callbacks\n     * instead.\n     */\n    pj_assert(adapter->stream_user_data == NULL);\n    adapter->stream_user_data = att_param->user_data;\n    if (att_param->rtp_cb2) {\n        adapter->stream_rtp_cb2 = att_param->rtp_cb2;\n    } else {\n        adapter->stream_rtp_cb = att_param->rtp_cb;\n    }\n    adapter->stream_rtcp_cb = att_param->rtcp_cb;\n    adapter->stream_ref = att_param->stream;\n\n    att_param->rtp_cb2 = &transport_rtp_cb2;\n    att_param->rtp_cb = NULL;    \n    att_param->rtcp_cb = &transport_rtcp_cb;\n    att_param->user_data = adapter;\n        \n    status = pjmedia_transport_attach2(adapter->slave_tp, att_param);\n    if (status != PJ_SUCCESS) {\n        adapter->stream_user_data = NULL;\n        adapter->stream_rtp_cb = NULL;\n        adapter->stream_rtp_cb2 = NULL;\n        adapter->stream_rtcp_cb = NULL;\n        adapter->stream_ref = NULL;\n        return status;\n    }\n\n    return PJ_SUCCESS;\n}\n\n/* \n * detach() is called when the media is terminated, and the stream is \n * to be disconnected from us.\n */\nstatic void transport_detach(pjmedia_transport *tp, void *strm)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n    \n    PJ_UNUSED_ARG(strm);\n\n    if (adapter->stream_user_data != NULL) {\n        pjmedia_transport_detach(adapter->slave_tp, adapter);\n        adapter->stream_user_data = NULL;\n        adapter->stream_rtp_cb = NULL;\n        adapter->stream_rtp_cb2 = NULL;\n        adapter->stream_rtcp_cb = NULL;\n        adapter->stream_ref = NULL;\n    }\n}\n\n\n/*\n * send_rtp() is called to send RTP packet. The \"pkt\" and \"size\" argument \n * contain both the RTP header and the payload.\n */\nstatic pj_status_t transport_send_rtp( pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n\n    /* You may do some processing to the RTP packet here if you want. */\n\n    /* Send the packet using the slave transport */\n    return pjmedia_transport_send_rtp(adapter->slave_tp, pkt, size);\n}\n\n\n/*\n * send_rtcp() is called to send RTCP packet. The \"pkt\" and \"size\" argument\n * contain the RTCP packet.\n */\nstatic pj_status_t transport_send_rtcp(pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n\n    /* You may do some processing to the RTCP packet here if you want. */\n\n    /* Send the packet using the slave transport */\n    return pjmedia_transport_send_rtcp(adapter->slave_tp, pkt, size);\n}\n\n\n/*\n * This is another variant of send_rtcp(), with the alternate destination\n * address in the argument.\n */\nstatic pj_status_t transport_send_rtcp2(pjmedia_transport *tp,\n                                        const pj_sockaddr_t *addr,\n                                        unsigned addr_len,\n                                        const void *pkt,\n                                        pj_size_t size)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n    return pjmedia_transport_send_rtcp2(adapter->slave_tp, addr, addr_len, \n                                        pkt, size);\n}\n\n/*\n * The media_create() is called when the transport is about to be used for\n * a new call.\n */\nstatic pj_status_t transport_media_create(pjmedia_transport *tp,\n                                          pj_pool_t *sdp_pool,\n                                          unsigned options,\n                                          const pjmedia_sdp_session *rem_sdp,\n                                          unsigned media_index)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n\n    /* if \"rem_sdp\" is not NULL, it means we are UAS. You may do some\n     * inspections on the incoming SDP to verify that the SDP is acceptable\n     * for us. If the SDP is not acceptable, we can reject the SDP by \n     * returning non-PJ_SUCCESS.\n     */\n    if (rem_sdp) {\n        /* Do your stuff.. */\n    }\n\n    /* Once we're done with our initialization, pass the call to the\n     * slave transports to let it do it's own initialization too.\n     */\n    return pjmedia_transport_media_create(adapter->slave_tp, sdp_pool, options,\n                                           rem_sdp, media_index);\n}\n\n/*\n * The encode_sdp() is called when we're about to send SDP to remote party,\n * either as SDP offer or as SDP answer.\n */\nstatic pj_status_t transport_encode_sdp(pjmedia_transport *tp,\n                                        pj_pool_t *sdp_pool,\n                                        pjmedia_sdp_session *local_sdp,\n                                        const pjmedia_sdp_session *rem_sdp,\n                                        unsigned media_index)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n\n    /* If \"rem_sdp\" is not NULL, it means we're encoding SDP answer. You may\n     * do some more checking on the SDP's once again to make sure that\n     * everything is okay before we send SDP.\n     */\n    if (rem_sdp) {\n        /* Do checking stuffs here.. */\n    }\n\n    /* You may do anything to the local_sdp, e.g. adding new attributes, or\n     * even modifying the SDP if you want.\n     */\n    if (1) {\n        /* Say we add a proprietary attribute here.. */\n        pjmedia_sdp_attr *my_attr;\n\n        my_attr = PJ_POOL_ALLOC_T(sdp_pool, pjmedia_sdp_attr);\n        pj_strdup2(sdp_pool, &my_attr->name, \"X-adapter\");\n        pj_strdup2(sdp_pool, &my_attr->value, \"some value\");\n\n        pjmedia_sdp_attr_add(&local_sdp->media[media_index]->attr_count,\n                             local_sdp->media[media_index]->attr,\n                             my_attr);\n    }\n\n    /* And then pass the call to slave transport to let it encode its \n     * information in the SDP. You may choose to call encode_sdp() to slave\n     * first before adding your custom attributes if you want.\n     */\n    return pjmedia_transport_encode_sdp(adapter->slave_tp, sdp_pool, local_sdp,\n                                        rem_sdp, media_index);\n}\n\n/*\n * The media_start() is called once both local and remote SDP have been\n * negotiated successfully, and the media is ready to start. Here we can start\n * committing our processing.\n */\nstatic pj_status_t transport_media_start(pjmedia_transport *tp,\n                                         pj_pool_t *pool,\n                                         const pjmedia_sdp_session *local_sdp,\n                                         const pjmedia_sdp_session *rem_sdp,\n                                         unsigned media_index)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n\n    /* Do something.. */\n\n    /* And pass the call to the slave transport */\n    return pjmedia_transport_media_start(adapter->slave_tp, pool, local_sdp,\n                                         rem_sdp, media_index);\n}\n\n/*\n * The media_stop() is called when media has been stopped.\n */\nstatic pj_status_t transport_media_stop(pjmedia_transport *tp)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n\n    /* Do something.. */\n\n    /* And pass the call to the slave transport */\n    return pjmedia_transport_media_stop(adapter->slave_tp);\n}\n\n/*\n * simulate_lost() is called to simulate packet lost\n */\nstatic pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n                                           pjmedia_dir dir,\n                                           unsigned pct_lost)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n    return pjmedia_transport_simulate_lost(adapter->slave_tp, dir, pct_lost);\n}\n\n/*\n * destroy() is called when the transport is no longer needed.\n */\nstatic pj_status_t transport_destroy  (pjmedia_transport *tp)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n\n    /* Close the slave transport */\n    if (adapter->del_base) {\n        pjmedia_transport_close(adapter->slave_tp);\n    }\n\n    /* Self destruct.. */\n    pj_pool_release(adapter->pool);\n\n    return PJ_SUCCESS;\n}\n\n\n\n\n\n", "/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/transport_ice.h>\n#include <pjnath/errno.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/pool.h>\n#include <pj/rand.h>\n\n#define THIS_FILE   \"transport_ice.c\"\n#if 0\n#   define TRACE__(expr)    PJ_LOG(5,expr)\n#else\n#   define TRACE__(expr)\n#endif\n\nenum oa_role\n{\n    ROLE_NONE,\n    ROLE_OFFERER,\n    ROLE_ANSWERER\n};\n\nstruct sdp_state\n{\n    unsigned            match_comp_cnt; /* Matching number of components    */\n    pj_bool_t           ice_mismatch;   /* Address doesn't match candidates */\n    pj_bool_t           ice_restart;    /* Offer to restart ICE             */\n    pj_ice_sess_role    local_role;     /* Our role                         */\n    pj_bool_t           has_trickle;    /* Has trickle ICE attribute        */\n};\n\n/* ICE listener */\ntypedef struct ice_listener\n{\n    PJ_DECL_LIST_MEMBER(struct ice_listener);\n    pjmedia_ice_cb       cb;\n    void                *user_data;\n} ice_listener;\n\nstruct transport_ice\n{\n    pjmedia_transport    base;\n    pj_pool_t           *pool;\n    unsigned             options;       /**< Transport options.             */\n\n    unsigned             comp_cnt;\n    pj_ice_strans       *ice_st;\n\n    pjmedia_ice_cb       cb;\n    ice_listener         listener;\n    ice_listener         listener_empty;\n    unsigned             media_option;\n\n    pj_bool_t            initial_sdp;\n    enum oa_role         oa_role;       /**< Last role in SDP offer/answer  */\n    struct sdp_state     rem_offer_state;/**< Describes the remote offer    */\n\n    void                *stream;\n    pj_sockaddr          remote_rtp;\n    pj_sockaddr          remote_rtcp;\n    unsigned             addr_len;      /**< Length of addresses.           */\n\n    pj_bool_t            use_ice;\n    pj_sockaddr          rtp_src_addr;  /**< Actual source RTP address.     */\n    unsigned             rtp_src_cnt;   /**< How many pkt from this addr.   */\n    pj_sockaddr          rtcp_src_addr; /**< Actual source RTCP address.    */\n    unsigned             rtcp_src_cnt;  /**< How many pkt from this addr.   */\n    pj_bool_t            enable_rtcp_mux;/**< Enable RTP& RTCP multiplexing?*/\n    pj_bool_t            use_rtcp_mux;  /**< Use RTP & RTCP multiplexing?   */\n\n    unsigned             tx_drop_pct;   /**< Percent of tx pkts to drop.    */\n    unsigned             rx_drop_pct;   /**< Percent of rx pkts to drop.    */\n\n    pj_ice_sess_trickle  trickle_ice;   /**< Trickle ICE mode.              */\n    unsigned             last_send_cand_cnt[PJ_ICE_MAX_COMP];\n                                        /**< Last local candidate count.    */\n    pj_bool_t            end_of_cand;   /**< Local cand gathering done?     */\n    pj_str_t             sdp_mid;       /**< SDP \"a=mid\" attribute.         */\n\n    void               (*rtp_cb)(void*,\n                                 void*,\n                                 pj_ssize_t);\n    void               (*rtp_cb2)(pjmedia_tp_cb_param*);\n    void               (*rtcp_cb)(void*,\n                                  void*,\n                                  pj_ssize_t);\n};\n\n\n/*\n * These are media transport operations.\n */\nstatic pj_status_t transport_get_info (pjmedia_transport *tp,\n                                       pjmedia_transport_info *info);\nstatic pj_status_t transport_attach   (pjmedia_transport *tp,\n                                       void *user_data,\n                                       const pj_sockaddr_t *rem_addr,\n                                       const pj_sockaddr_t *rem_rtcp,\n                                       unsigned addr_len,\n                                       void (*rtp_cb)(void*,\n                                                      void*,\n                                                      pj_ssize_t),\n                                       void (*rtcp_cb)(void*,\n                                                       void*,\n                                                       pj_ssize_t));\nstatic pj_status_t transport_attach2  (pjmedia_transport *tp,\n                                       pjmedia_transport_attach_param\n                                           *att_param);\nstatic void        transport_detach   (pjmedia_transport *tp,\n                                       void *strm);\nstatic pj_status_t transport_send_rtp( pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_send_rtcp(pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_send_rtcp2(pjmedia_transport *tp,\n                                       const pj_sockaddr_t *addr,\n                                       unsigned addr_len,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_media_create(pjmedia_transport *tp,\n                                       pj_pool_t *pool,\n                                       unsigned options,\n                                       const pjmedia_sdp_session *rem_sdp,\n                                       unsigned media_index);\nstatic pj_status_t transport_encode_sdp(pjmedia_transport *tp,\n                                        pj_pool_t *tmp_pool,\n                                        pjmedia_sdp_session *sdp_local,\n                                        const pjmedia_sdp_session *rem_sdp,\n                                        unsigned media_index);\nstatic pj_status_t transport_media_start(pjmedia_transport *tp,\n                                       pj_pool_t *pool,\n                                       const pjmedia_sdp_session *sdp_local,\n                                       const pjmedia_sdp_session *rem_sdp,\n                                       unsigned media_index);\nstatic pj_status_t transport_media_stop(pjmedia_transport *tp);\nstatic pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n                                       pjmedia_dir dir,\n                                       unsigned pct_lost);\nstatic pj_status_t transport_destroy  (pjmedia_transport *tp);\n\n/*\n * And these are ICE callbacks.\n */\nstatic void ice_on_rx_data(pj_ice_strans *ice_st, \n                           unsigned comp_id, \n                           void *pkt, pj_size_t size,\n                           const pj_sockaddr_t *src_addr,\n                           unsigned src_addr_len);\nstatic void ice_on_ice_complete(pj_ice_strans *ice_st, \n                                pj_ice_strans_op op,\n                                pj_status_t status);\nstatic void ice_on_new_candidate(pj_ice_strans *ice_st,\n                                 const pj_ice_sess_cand *cand,\n                                 pj_bool_t last);\n\n/*\n * Clean up ICE resources.\n */\nstatic void tp_ice_on_destroy(void *arg);\n\n\nstatic pjmedia_transport_op transport_ice_op = \n{\n    &transport_get_info,\n    &transport_attach,\n    &transport_detach,\n    &transport_send_rtp,\n    &transport_send_rtcp,\n    &transport_send_rtcp2,\n    &transport_media_create,\n    &transport_encode_sdp,\n    &transport_media_start,\n    &transport_media_stop,\n    &transport_simulate_lost,\n    &transport_destroy,\n    &transport_attach2\n};\n\nstatic const pj_str_t STR_CANDIDATE     = { \"candidate\", 9};\nstatic const pj_str_t STR_REM_CAND      = { \"remote-candidates\", 17 };\nstatic const pj_str_t STR_ICE_LITE      = { \"ice-lite\", 8};\nstatic const pj_str_t STR_ICE_MISMATCH  = { \"ice-mismatch\", 12};\nstatic const pj_str_t STR_ICE_UFRAG     = { \"ice-ufrag\", 9 };\nstatic const pj_str_t STR_ICE_PWD       = { \"ice-pwd\", 7 };\nstatic const pj_str_t STR_IP4           = { \"IP4\", 3 };\nstatic const pj_str_t STR_IP6           = { \"IP6\", 3 };\nstatic const pj_str_t STR_RTCP          = { \"rtcp\", 4 };\nstatic const pj_str_t STR_RTCP_MUX      = { \"rtcp-mux\", 8 };\nstatic const pj_str_t STR_BANDW_RR      = { \"RR\", 2 };\nstatic const pj_str_t STR_BANDW_RS      = { \"RS\", 2 };\nstatic const pj_str_t STR_ICE_OPTIONS   = { \"ice-options\", 11 };\nstatic const pj_str_t STR_TRICKLE       = { \"trickle\", 7 };\nstatic const pj_str_t STR_END_OF_CAND   = { \"end-of-candidates\", 17 };\n\nenum {\n    COMP_RTP = 1,\n    COMP_RTCP = 2\n};\n\n\n/* Forward declaration of internal functions */\n\nstatic int print_sdp_cand_attr(char *buffer, int max_len,\n                               const pj_ice_sess_cand *cand);\nstatic void get_ice_attr(const pjmedia_sdp_session *rem_sdp,\n                         const pjmedia_sdp_media *rem_m,\n                         const pjmedia_sdp_attr **p_ice_ufrag,\n                         const pjmedia_sdp_attr **p_ice_pwd);\nstatic pj_status_t parse_cand(const char *obj_name,\n                              pj_pool_t *pool,\n                              const pj_str_t *orig_input,\n                              pj_ice_sess_cand *cand);\n\n\n/*\n * Create ICE media transport.\n */\nPJ_DEF(pj_status_t) pjmedia_ice_create(pjmedia_endpt *endpt,\n                                       const char *name,\n                                       unsigned comp_cnt,\n                                       const pj_ice_strans_cfg *cfg,\n                                       const pjmedia_ice_cb *cb,\n                                       pjmedia_transport **p_tp)\n{\n    return pjmedia_ice_create2(endpt, name, comp_cnt, cfg, cb, 0, p_tp);\n}\n\n/*\n * Create ICE media transport.\n */\nPJ_DEF(pj_status_t) pjmedia_ice_create2(pjmedia_endpt *endpt,\n                                        const char *name,\n                                        unsigned comp_cnt,\n                                        const pj_ice_strans_cfg *cfg,\n                                        const pjmedia_ice_cb *cb,\n                                        unsigned options,\n                                        pjmedia_transport **p_tp)\n{\n    return pjmedia_ice_create3(endpt, name, comp_cnt, cfg, cb,\n                               options, NULL, p_tp);\n}\n\n/*\n * Create ICE media transport.\n */\nPJ_DEF(pj_status_t) pjmedia_ice_create3(pjmedia_endpt *endpt,\n                                        const char *name,\n                                        unsigned comp_cnt,\n                                        const pj_ice_strans_cfg *cfg,\n                                        const pjmedia_ice_cb *cb,\n                                        unsigned options,\n                                        void *user_data,\n                                        pjmedia_transport **p_tp)\n{\n    pj_pool_t *pool;\n    pj_ice_strans_cb ice_st_cb;\n    pj_ice_strans_cfg ice_st_cfg;\n    struct transport_ice *tp_ice;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(endpt && comp_cnt && cfg && p_tp, PJ_EINVAL);\n\n    /* Create transport instance */\n    pool = pjmedia_endpt_create_pool(endpt, name, 512, 512);\n    tp_ice = PJ_POOL_ZALLOC_T(pool, struct transport_ice);\n    tp_ice->pool = pool;\n    tp_ice->options = options;\n    tp_ice->comp_cnt = comp_cnt;\n    pj_ansi_strxcpy(tp_ice->base.name, pool->obj_name, \n                    sizeof(tp_ice->base.name));\n    tp_ice->base.op = &transport_ice_op;\n    tp_ice->base.type = PJMEDIA_TRANSPORT_TYPE_ICE;\n    tp_ice->base.user_data = user_data;\n    tp_ice->initial_sdp = PJ_TRUE;\n    tp_ice->oa_role = ROLE_NONE;\n    tp_ice->use_ice = PJ_FALSE;\n    tp_ice->trickle_ice = cfg->opt.trickle;\n    pj_list_init(&tp_ice->listener);\n    pj_list_init(&tp_ice->listener_empty);\n\n    pj_memcpy(&ice_st_cfg, cfg, sizeof(pj_ice_strans_cfg));\n    if (cb)\n        pj_memcpy(&tp_ice->cb, cb, sizeof(pjmedia_ice_cb));\n\n    /* Assign return value first because ICE might call callback\n     * in create()\n     */\n    *p_tp = &tp_ice->base;\n\n    /* Configure ICE callbacks */\n    pj_bzero(&ice_st_cb, sizeof(ice_st_cb));\n    ice_st_cb.on_ice_complete = &ice_on_ice_complete;\n    ice_st_cb.on_rx_data = &ice_on_rx_data;\n    ice_st_cb.on_new_candidate = &ice_on_new_candidate;\n\n    /* Configure RTP socket buffer settings, if not set */\n    if (ice_st_cfg.comp[COMP_RTP-1].so_rcvbuf_size == 0) {\n        ice_st_cfg.comp[COMP_RTP-1].so_rcvbuf_size = \n                            PJMEDIA_TRANSPORT_SO_RCVBUF_SIZE;\n    }\n    if (ice_st_cfg.comp[COMP_RTP-1].so_sndbuf_size == 0) {\n        ice_st_cfg.comp[COMP_RTP-1].so_sndbuf_size = \n                            PJMEDIA_TRANSPORT_SO_SNDBUF_SIZE;\n    }\n    if (ice_st_cfg.send_buf_size == 0)\n        ice_st_cfg.send_buf_size = PJMEDIA_MAX_MTU;\n\n    /* Create ICE */\n    status = pj_ice_strans_create(name, &ice_st_cfg, comp_cnt, tp_ice, \n                                  &ice_st_cb, &tp_ice->ice_st);\n    if (status != PJ_SUCCESS) {\n        pj_pool_release(pool);\n        *p_tp = NULL;\n        return status;\n    }\n\n    /* Sync to ICE */\n    {\n        pj_grp_lock_t *grp_lock = pj_ice_strans_get_grp_lock(tp_ice->ice_st);\n        pj_grp_lock_add_ref(grp_lock);\n        pj_grp_lock_add_handler(grp_lock, pool, tp_ice, &tp_ice_on_destroy);\n    }\n\n    /* Done */\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_grp_lock_t *) pjmedia_ice_get_grp_lock(pjmedia_transport *tp)\n{\n    PJ_ASSERT_RETURN(tp, NULL);\n    return pj_ice_strans_get_grp_lock(((struct transport_ice *)tp)->ice_st);\n}\n\n\n/*\n * Add application to receive ICE notifications from the specified ICE media\n * transport.\n */\nPJ_DEF(pj_status_t) pjmedia_ice_add_ice_cb( pjmedia_transport *tp,\n                                            const pjmedia_ice_cb *cb,\n                                            void *user_data)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n    ice_listener *il;\n    pj_grp_lock_t *grp_lock;\n\n    PJ_ASSERT_RETURN(tp && cb, PJ_EINVAL);\n    grp_lock = pjmedia_ice_get_grp_lock(tp);\n    PJ_ASSERT_RETURN(grp_lock, PJ_EINVAL);\n\n    pj_grp_lock_acquire(grp_lock);\n\n    if (!pj_list_empty(&tp_ice->listener_empty)) {\n        il = tp_ice->listener_empty.next;\n        pj_list_erase(il);\n        il->cb = *cb;\n        il->user_data = user_data;\n        pj_list_push_back(&tp_ice->listener, il);\n    } else {\n        il = PJ_POOL_ZALLOC_T(tp_ice->pool, ice_listener);\n        pj_list_init(il);\n        il->cb = *cb;\n        il->user_data = user_data;\n        pj_list_push_back(&tp_ice->listener, il);\n    }\n\n    pj_grp_lock_release(grp_lock);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Remove application to stop receiving ICE notifications the specified\n * ICE media transport.\n */\nPJ_DEF(pj_status_t) pjmedia_ice_remove_ice_cb( pjmedia_transport *tp,\n                                               const pjmedia_ice_cb *cb,\n                                               void *user_data)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n    ice_listener *il;\n    pj_grp_lock_t *grp_lock;\n\n    PJ_ASSERT_RETURN(tp && cb, PJ_EINVAL);\n    grp_lock = pjmedia_ice_get_grp_lock(tp);\n    PJ_ASSERT_RETURN(grp_lock, PJ_EINVAL);\n\n    pj_grp_lock_acquire(grp_lock);\n\n    for (il=tp_ice->listener.next; il!=&tp_ice->listener; il=il->next) {\n        if (pj_memcmp(&il->cb, cb, sizeof(*cb))==0 && il->user_data==user_data)\n            break;\n    }\n    if (il != &tp_ice->listener) {\n        pj_list_erase(il);\n        pj_list_push_back(&tp_ice->listener_empty, il);\n    }\n\n    pj_grp_lock_release(grp_lock);\n\n    return (il != &tp_ice->listener? PJ_SUCCESS : PJ_ENOTFOUND);\n}\n\n\n/* Check if trickle support is signalled in the specified SDP. */\nPJ_DEF(pj_bool_t) pjmedia_ice_sdp_has_trickle( const pjmedia_sdp_session *sdp,\n                                               unsigned med_idx)\n{\n    const pjmedia_sdp_media *m;\n    const pjmedia_sdp_attr *a;\n\n    PJ_ASSERT_RETURN(sdp && med_idx < sdp->media_count, PJ_EINVAL);\n\n    /* Find in media level */\n    m = sdp->media[med_idx];\n    a = pjmedia_sdp_attr_find(m->attr_count, m->attr, &STR_ICE_OPTIONS, NULL);\n    if (a && pj_strstr(&a->value, &STR_TRICKLE))\n        return PJ_TRUE;\n\n    /* Find in session level */\n    a = pjmedia_sdp_attr_find(sdp->attr_count, sdp->attr, &STR_ICE_OPTIONS,\n                              NULL);\n    if (a && pj_strstr(&a->value, &STR_TRICKLE))\n        return PJ_TRUE;\n\n    return PJ_FALSE;\n}\n\n\n/* Update check list after discovering and conveying new local ICE candidate,\n * or receiving update of remote ICE candidates in trickle ICE.\n */\nPJ_DEF(pj_status_t) pjmedia_ice_trickle_update(\n                                             pjmedia_transport *tp,\n                                             const pj_str_t *rem_ufrag,\n                                             const pj_str_t *rem_passwd,\n                                             unsigned rcand_cnt,\n                                             const pj_ice_sess_cand rcand[],\n                                             pj_bool_t rcand_end)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(tp_ice && tp_ice->ice_st, PJ_EINVAL);\n    PJ_ASSERT_RETURN(tp_ice->trickle_ice != PJ_ICE_SESS_TRICKLE_DISABLED,\n                     PJ_EINVALIDOP);\n\n\n    /* Update the checklist */\n    status = pj_ice_strans_update_check_list(tp_ice->ice_st,\n                                             rem_ufrag, rem_passwd,\n                                             rcand_cnt, rcand, rcand_end);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Start ICE if both sides have sent their (initial) SDPs */\n    if (!pj_ice_strans_sess_is_running(tp_ice->ice_st)) {\n        unsigned i, comp_cnt;\n\n        comp_cnt = pj_ice_strans_get_running_comp_cnt(tp_ice->ice_st);\n        for (i = 0; i < comp_cnt; ++i) {\n            if (tp_ice->last_send_cand_cnt[i] > 0)\n                break;\n        }\n        if (i != comp_cnt) {\n            pj_str_t rufrag;\n            pj_ice_strans_get_ufrag_pwd(tp_ice->ice_st, NULL, NULL,\n                                        &rufrag, NULL);\n            if (rufrag.slen > 0) {\n                PJ_LOG(3,(THIS_FILE,\"Trickle ICE starts connectivity check\"));\n                status = pj_ice_strans_start_ice(tp_ice->ice_st, NULL, NULL,\n                                                 0, NULL);\n            }\n        }\n    }\n\n    return status;\n}\n\n\n/* Fetch trickle ICE info from the specified SDP. */\nPJ_DEF(pj_status_t) pjmedia_ice_trickle_decode_sdp(\n                                            const pjmedia_sdp_session *sdp,\n                                            unsigned media_index,\n                                            pj_str_t *mid,\n                                            pj_str_t *ufrag,\n                                            pj_str_t *passwd,\n                                            unsigned *cand_cnt,\n                                            pj_ice_sess_cand cand[],\n                                            pj_bool_t *end_of_cand)\n{\n    const pjmedia_sdp_media *m;\n    const pjmedia_sdp_attr *a;\n\n    PJ_ASSERT_RETURN(sdp && media_index < sdp->media_count, PJ_EINVAL);\n\n    m = sdp->media[media_index];\n\n    if (mid) {\n        a = pjmedia_sdp_attr_find2(m->attr_count, m->attr, \"mid\", NULL);\n        if (a) {\n            *mid = a->value;\n        } else {\n            pj_bzero(mid, sizeof(*mid));\n        }\n    }\n\n    if (ufrag && passwd) {\n        const pjmedia_sdp_attr *a_ufrag, *a_pwd;\n        get_ice_attr(sdp, m, &a_ufrag, &a_pwd);\n        if (a_ufrag && a_pwd) {\n            *ufrag = a_ufrag->value;\n            *passwd = a_pwd->value;\n        } else {\n            pj_bzero(ufrag, sizeof(*ufrag));\n            pj_bzero(passwd, sizeof(*passwd));\n        }\n    }\n\n    if (cand_cnt && cand && *cand_cnt > 0) {\n        pj_status_t status;\n        unsigned i, cnt = 0;\n\n        for (i=0; i<m->attr_count && cnt<*cand_cnt; ++i) {\n            a = m->attr[i];\n            if (pj_strcmp(&a->name, &STR_CANDIDATE)!=0)\n                continue;\n\n            /* Parse candidate */\n            status = parse_cand(\"trickle-ice\", NULL, &a->value, &cand[cnt]);\n            if (status != PJ_SUCCESS) {\n                PJ_PERROR(4,(\"trickle-ice\", status,\n                             \"Error in parsing SDP candidate attribute '%.*s', \"\n                             \"candidate is ignored\",\n                             (int)a->value.slen, a->value.ptr));\n                continue;\n            }\n            ++cnt;\n        }\n        *cand_cnt = cnt;\n    }\n\n    if (end_of_cand) {\n        a = pjmedia_sdp_attr_find(m->attr_count, m->attr, &STR_END_OF_CAND,\n                                  NULL);\n        if (!a) {\n            a = pjmedia_sdp_attr_find(sdp->attr_count, sdp->attr,\n                                      &STR_END_OF_CAND, NULL);\n        }\n        *end_of_cand = (a != NULL);\n    }\n    return PJ_SUCCESS;\n}\n\n\n/* Generate SDP attributes for trickle ICE in the specified SDP. */\nPJ_DEF(pj_status_t) pjmedia_ice_trickle_encode_sdp(\n                                            pj_pool_t *sdp_pool,\n                                            pjmedia_sdp_session *sdp,\n                                            const pj_str_t *mid,\n                                            const pj_str_t *ufrag,\n                                            const pj_str_t *passwd,\n                                            unsigned cand_cnt,\n                                            const pj_ice_sess_cand cand[],\n                                            pj_bool_t end_of_cand)\n{\n    pjmedia_sdp_media *m = NULL;\n    pjmedia_sdp_attr *a;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(sdp_pool && sdp, PJ_EINVAL);\n\n    /* Find media by checking \"a=mid\"*/\n    for (i = 0; i < sdp->media_count; ++i) {\n        m = sdp->media[i];\n        a = pjmedia_sdp_media_find_attr2(m, \"mid\", NULL);\n        if (a && pj_strcmp(&a->value, mid)==0)\n            break;\n    }\n\n    /* Media not exist, try to add it */\n    if (i == sdp->media_count) {\n        if (sdp->media_count >= PJMEDIA_MAX_SDP_MEDIA) {\n            PJ_LOG(3,(THIS_FILE,\"Trickle ICE failed to encode candidates, \"\n                                \"the specified SDP has too many media\"));\n            return PJ_ETOOMANY;\n        }\n\n        /* Add a new media to the SDP */\n        m = PJ_POOL_ZALLOC_T(sdp_pool, pjmedia_sdp_media);\n        m->desc.media = pj_str(\"audio\");\n        m->desc.fmt_count = 1;\n        m->desc.fmt[0] = pj_str(\"0\");\n        m->desc.transport = pj_str(\"RTP/AVP\");\n        sdp->media[sdp->media_count++] = m;\n\n        /* Add media ID attribute \"a=mid\" */\n        a = pjmedia_sdp_attr_create(sdp_pool, \"mid\", mid);\n        pjmedia_sdp_attr_add(&m->attr_count, m->attr, a);\n    }\n\n    /* Add \"a=ice-options:trickle\" in session level */\n    a = pjmedia_sdp_attr_find(sdp->attr_count, sdp->attr, &STR_ICE_OPTIONS,\n                              NULL);\n    if (!a || !pj_strstr(&a->value, &STR_TRICKLE)) {\n        a = pjmedia_sdp_attr_create(sdp_pool, STR_ICE_OPTIONS.ptr,\n                                    &STR_TRICKLE);\n        pjmedia_sdp_attr_add(&sdp->attr_count, sdp->attr, a);\n    }\n\n    /* Add \"a=ice-options:trickle\" in media level */\n    /*\n    a = pjmedia_sdp_attr_find(m->attr_count, m->attr, &STR_ICE_OPTIONS,\n                              NULL);\n    if (!a || !pj_strstr(&a->value, &STR_TRICKLE)) {\n        a = pjmedia_sdp_attr_create(sdp_pool, STR_ICE_OPTIONS.ptr,\n                                    &STR_TRICKLE);\n        pjmedia_sdp_attr_add(&m->attr_count, m->attr, a);\n    }\n    */\n\n    /* Add ice-ufrag & ice-pwd attributes */\n    if (ufrag && passwd &&\n        !pjmedia_sdp_attr_find(m->attr_count, m->attr, &STR_ICE_UFRAG, NULL))\n    {\n        a = pjmedia_sdp_attr_create(sdp_pool, STR_ICE_UFRAG.ptr, ufrag);\n        pjmedia_sdp_attr_add(&m->attr_count, m->attr, a);\n\n        a = pjmedia_sdp_attr_create(sdp_pool, STR_ICE_PWD.ptr, passwd);\n        pjmedia_sdp_attr_add(&m->attr_count, m->attr, a);\n    }\n\n    /* Add candidates */\n    for (i=0; i<cand_cnt; ++i) {\n        enum {\n            ATTR_BUF_LEN = 160, /* Max len of a=candidate attr */\n            RATTR_BUF_LEN= 160  /* Max len of a=remote-candidates attr */\n        };\n        char attr_buf[ATTR_BUF_LEN];\n        pj_str_t value;\n\n        value.slen = print_sdp_cand_attr(attr_buf, ATTR_BUF_LEN, &cand[i]);\n        if (value.slen < 0) {\n            pj_assert(!\"Not enough attr_buf to print candidate\");\n            return PJ_EBUG;\n        }\n\n        value.ptr = attr_buf;\n        a = pjmedia_sdp_attr_create(sdp_pool, STR_CANDIDATE.ptr, &value);\n        pjmedia_sdp_attr_add(&m->attr_count, m->attr, a);\n    }\n\n    /* Add \"a=end-of-candidates\" */\n    if (end_of_cand) {\n        a = pjmedia_sdp_attr_find(m->attr_count, m->attr, &STR_END_OF_CAND,\n                                  NULL);\n        if (!a) {\n            a = pjmedia_sdp_attr_create(sdp_pool, STR_END_OF_CAND.ptr, NULL);\n            pjmedia_sdp_attr_add(&m->attr_count, m->attr, a);\n        }\n    }\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_bool_t) pjmedia_ice_trickle_has_new_cand(pjmedia_transport *tp)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n    unsigned i, comp_cnt;\n\n    /* Make sure ICE transport has session already */\n    if (!tp_ice->ice_st || !pj_ice_strans_has_sess(tp_ice->ice_st))\n        return PJ_FALSE;\n\n    /* Count all local candidates */\n    comp_cnt = pj_ice_strans_get_running_comp_cnt(tp_ice->ice_st);\n    for (i = 0; i < comp_cnt; ++i) {\n        if (tp_ice->last_send_cand_cnt[i] <\n            pj_ice_strans_get_cands_count(tp_ice->ice_st, i+1))\n        {\n            return PJ_TRUE;\n        }\n    }\n    return PJ_FALSE;\n}\n\n\n/* Add any new local candidates to the specified SDP to be conveyed to\n * remote (e.g: via SIP INFO).\n */\nPJ_DEF(pj_status_t) pjmedia_ice_trickle_send_local_cand(\n                                            pjmedia_transport *tp,\n                                            pj_pool_t *sdp_pool,\n                                            pjmedia_sdp_session *sdp,\n                                            pj_bool_t *p_end_of_cand)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n    pj_str_t ufrag, pwd;\n    pj_ice_sess_cand cand[PJ_ICE_MAX_CAND];\n    unsigned cand_cnt, i, comp_cnt;\n    pj_bool_t end_of_cand;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(tp && sdp_pool && sdp, PJ_EINVAL);\n\n    /* Make sure ICE transport has session already */\n    if (!tp_ice->ice_st || !pj_ice_strans_has_sess(tp_ice->ice_st))\n        return PJ_EINVALIDOP;\n\n    end_of_cand = tp_ice->end_of_cand;\n\n    /* Get ufrag and pwd from current session */\n    pj_ice_strans_get_ufrag_pwd(tp_ice->ice_st, &ufrag, &pwd, NULL, NULL);\n\n    cand_cnt = 0;\n    comp_cnt = pj_ice_strans_get_running_comp_cnt(tp_ice->ice_st);\n    for (i = 0; i < comp_cnt; ++i) {\n        unsigned cnt = PJ_ICE_MAX_CAND - cand_cnt;\n\n        /* Get all local candidates for this comp */\n        status = pj_ice_strans_enum_cands(tp_ice->ice_st, i+1,\n                                          &cnt, &cand[cand_cnt]);\n        if (status != PJ_SUCCESS) {\n            PJ_PERROR(3,(tp_ice->base.name, status,\n                         \"Failed enumerating local candidates for comp-id=%d\",\n                         i+1));\n            continue;\n        }\n        cand_cnt += cnt;\n\n        tp_ice->last_send_cand_cnt[i] = cnt;\n    }\n\n    /* Update the SDP with all local candidates (not just the new ones).\n     * https://tools.ietf.org/html/draft-ietf-mmusic-trickle-ice-sip-18:\n     * 4.4. Delivering Candidates in INFO Requests: the agent MUST\n     * repeat in the INFO request body all candidates that were previously\n     * sent under the same combination of \"a=ice-pwd:\" and \"a=ice-ufrag:\"\n     * in the same order as they were sent before.\n     */\n    status = pjmedia_ice_trickle_encode_sdp(sdp_pool, sdp, &tp_ice->sdp_mid,\n                                            &ufrag, &pwd, cand_cnt, cand,\n                                            end_of_cand);\n    if (status != PJ_SUCCESS) {\n        PJ_PERROR(3,(tp_ice->base.name, status,\n                     \"Failed encoding local candidates to SDP\"));\n    }\n\n    if (p_end_of_cand)\n        *p_end_of_cand = end_of_cand;\n\n    return PJ_SUCCESS;\n}\n\n\n/* Disable ICE when SDP from remote doesn't contain a=candidate line */\nstatic void set_no_ice(struct transport_ice *tp_ice, const char *reason,\n                       pj_status_t err)\n{\n    if (err != PJ_SUCCESS) {\n        PJ_PERROR(4,(tp_ice->base.name, err,\n                     \"Stopping ICE, reason=%s\", reason));\n    } else {\n        PJ_LOG(4,(tp_ice->base.name, \n                  \"Stopping ICE, reason=%s\", reason));\n    }\n\n    if (tp_ice->ice_st) {\n        pj_ice_strans_stop_ice(tp_ice->ice_st);\n    }\n\n    tp_ice->use_ice = PJ_FALSE;\n}\n\n\n/* Create SDP candidate attribute */\nstatic int print_sdp_cand_attr(char *buffer, int max_len,\n                               const pj_ice_sess_cand *cand)\n{\n    char ipaddr[PJ_INET6_ADDRSTRLEN+2];\n    int len, len2;\n\n    len = pj_ansi_snprintf( buffer, max_len,\n                            \"%.*s %u UDP %u %s %u typ \",\n                            (int)cand->foundation.slen,\n                            cand->foundation.ptr,\n                            (unsigned)cand->comp_id,\n                            cand->prio,\n                            pj_sockaddr_print(&cand->addr, ipaddr, \n                                              sizeof(ipaddr), 0),\n                            (unsigned)pj_sockaddr_get_port(&cand->addr));\n    if (len < 1 || len >= max_len)\n        return -1;\n\n    switch (cand->type) {\n    case PJ_ICE_CAND_TYPE_HOST:\n        len2 = pj_ansi_snprintf(buffer+len, max_len-len, \"host\");\n        break;\n    case PJ_ICE_CAND_TYPE_SRFLX:\n    case PJ_ICE_CAND_TYPE_RELAYED:\n    case PJ_ICE_CAND_TYPE_PRFLX:\n        len2 = pj_ansi_snprintf(buffer+len, max_len-len,\n                                \"%s raddr %s rport %d\",\n                                pj_ice_get_cand_type_name(cand->type),\n                                pj_sockaddr_print(&cand->rel_addr, ipaddr,\n                                                  sizeof(ipaddr), 0),\n                                (int)pj_sockaddr_get_port(&cand->rel_addr));\n        break;\n    default:\n        pj_assert(!\"Invalid candidate type\");\n        len2 = -1;\n        break;\n    }\n    if (len2 < 1 || len2 >= max_len-len)\n        return -1;\n\n    return len+len2;\n}\n\n\n/* Get ice-ufrag and ice-pwd attribute */\nstatic void get_ice_attr(const pjmedia_sdp_session *rem_sdp,\n                         const pjmedia_sdp_media *rem_m,\n                         const pjmedia_sdp_attr **p_ice_ufrag,\n                         const pjmedia_sdp_attr **p_ice_pwd)\n{\n    pjmedia_sdp_attr *attr;\n\n    /* Find ice-ufrag attribute in media descriptor */\n    attr = pjmedia_sdp_attr_find(rem_m->attr_count, rem_m->attr,\n                                 &STR_ICE_UFRAG, NULL);\n    if (attr == NULL) {\n        /* Find ice-ufrag attribute in session descriptor */\n        attr = pjmedia_sdp_attr_find(rem_sdp->attr_count, rem_sdp->attr,\n                                     &STR_ICE_UFRAG, NULL);\n    }\n    *p_ice_ufrag = attr;\n\n    /* Find ice-pwd attribute in media descriptor */\n    attr = pjmedia_sdp_attr_find(rem_m->attr_count, rem_m->attr,\n                                 &STR_ICE_PWD, NULL);\n    if (attr == NULL) {\n        /* Find ice-pwd attribute in session descriptor */\n        attr = pjmedia_sdp_attr_find(rem_sdp->attr_count, rem_sdp->attr,\n                                     &STR_ICE_PWD, NULL);\n    }\n    *p_ice_pwd = attr;\n}\n\n\n/* Encode and add \"a=ice-mismatch\" attribute in the SDP */\nstatic void encode_ice_mismatch(pj_pool_t *sdp_pool,\n                                pjmedia_sdp_session *sdp_local,\n                                unsigned media_index)\n{\n    pjmedia_sdp_attr *attr;\n    pjmedia_sdp_media *m = sdp_local->media[media_index];\n\n    attr = PJ_POOL_ALLOC_T(sdp_pool, pjmedia_sdp_attr);\n    attr->name = STR_ICE_MISMATCH;\n    attr->value.slen = 0;\n    pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n}\n\n\n/* Encode ICE information in SDP */\nstatic pj_status_t encode_session_in_sdp(struct transport_ice *tp_ice,\n                                         pj_pool_t *sdp_pool,\n                                         pjmedia_sdp_session *sdp_local,\n                                         unsigned media_index,\n                                         unsigned comp_cnt,\n                                         pj_bool_t restart_session,\n                                         pj_bool_t rtcp_mux,\n                                         pj_bool_t trickle)\n{\n    enum { \n        ATTR_BUF_LEN = 160,     /* Max len of a=candidate attr */\n        RATTR_BUF_LEN= 160      /* Max len of a=remote-candidates attr */\n    };\n    pjmedia_sdp_media *m = sdp_local->media[media_index];\n    pj_str_t local_ufrag, local_pwd;\n    pjmedia_sdp_attr *attr;\n    pj_status_t status;\n\n    /* Must have a session */\n    PJ_ASSERT_RETURN(pj_ice_strans_has_sess(tp_ice->ice_st), PJ_EBUG);\n\n    /* Get ufrag and pwd from current session */\n    pj_ice_strans_get_ufrag_pwd(tp_ice->ice_st, &local_ufrag, &local_pwd,\n                                NULL, NULL);\n\n    /* The listing of candidates depends on whether ICE has completed\n     * or not. When ICE has completed:\n     *\n     * 9.1.2.2: Existing Media Streams with ICE Completed\n     *   The agent MUST include a candidate attributes for candidates\n     *   matching the default destination for each component of the \n     *   media stream, and MUST NOT include any other candidates.\n     *\n     * When ICE has not completed, we shall include all candidates.\n     *\n     * Except when we have detected that remote is offering to restart\n     * the session, in this case we will answer with full ICE SDP and\n     * new ufrag/pwd pair.\n     */\n    if (!restart_session && pj_ice_strans_sess_is_complete(tp_ice->ice_st) &&\n        pj_ice_strans_get_state(tp_ice->ice_st) != PJ_ICE_STRANS_STATE_FAILED)\n    {\n        const pj_ice_sess_check *check;\n        char *attr_buf;\n        pjmedia_sdp_conn *conn;\n        pjmedia_sdp_attr *a_rtcp;\n        pj_str_t rem_cand;\n        unsigned comp;\n\n        /* Encode ice-ufrag attribute */\n        attr = pjmedia_sdp_attr_create(sdp_pool, STR_ICE_UFRAG.ptr,\n                                       &local_ufrag);\n        pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n\n        /* Encode ice-pwd attribute */\n        attr = pjmedia_sdp_attr_create(sdp_pool, STR_ICE_PWD.ptr, \n                                       &local_pwd);\n        pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n\n        /* Prepare buffer */\n        attr_buf = (char*) pj_pool_alloc(sdp_pool, ATTR_BUF_LEN);\n        rem_cand.ptr = (char*) pj_pool_alloc(sdp_pool, RATTR_BUF_LEN);\n        rem_cand.slen = 0;\n\n        /* 9.1.2.2: Existing Media Streams with ICE Completed\n         *   The default destination for media (i.e., the values of \n         *   the IP addresses and ports in the m and c line used for\n         *   that media stream) MUST be the local candidate from the\n         *   highest priority nominated pair in the valid list for each\n         *   component.\n         */\n        check = pj_ice_strans_get_valid_pair(tp_ice->ice_st, 1);\n        if (check == NULL) {\n            pj_assert(!\"Shouldn't happen\");\n            return PJ_EBUG;\n        }\n\n        /* Override connection line address and media port number */\n        conn = m->conn;\n        if (conn == NULL)\n            conn = sdp_local->conn;\n\n        conn->addr.ptr = (char*) pj_pool_alloc(sdp_pool, \n                                               PJ_INET6_ADDRSTRLEN);\n        pj_sockaddr_print(&check->lcand->addr, conn->addr.ptr, \n                          PJ_INET6_ADDRSTRLEN, 0);\n        conn->addr.slen = pj_ansi_strlen(conn->addr.ptr);\n        m->desc.port = pj_sockaddr_get_port(&check->lcand->addr);\n\n        /* Override address RTCP attribute if it's present */\n        if (comp_cnt == 2 &&\n            (check = pj_ice_strans_get_valid_pair(tp_ice->ice_st, \n                                                  COMP_RTCP)) != NULL &&\n            (a_rtcp = pjmedia_sdp_attr_find(m->attr_count, m->attr, \n                                            &STR_RTCP, 0)) != NULL) \n        {\n            pjmedia_sdp_attr_remove(&m->attr_count, m->attr, a_rtcp);\n\n            a_rtcp = pjmedia_sdp_attr_create_rtcp(sdp_pool, \n                                                  &check->lcand->addr);\n            if (a_rtcp)\n                pjmedia_sdp_attr_add(&m->attr_count, m->attr, a_rtcp);\n        }\n\n        /* Encode only candidates matching the default destination \n         * for each component \n         */\n        for (comp=0; comp < comp_cnt; ++comp) {\n            int len;\n            pj_str_t value;\n\n            /* Get valid pair for this component */\n            check = pj_ice_strans_get_valid_pair(tp_ice->ice_st, comp+1);\n            if (check == NULL)\n                continue;\n\n            /* Print and add local candidate in the pair */\n            value.ptr = attr_buf;\n            value.slen = print_sdp_cand_attr(attr_buf, ATTR_BUF_LEN, \n                                             check->lcand);\n            if (value.slen < 0) {\n                pj_assert(!\"Not enough attr_buf to print candidate\");\n                return PJ_EBUG;\n            }\n\n            attr = pjmedia_sdp_attr_create(sdp_pool, STR_CANDIDATE.ptr,\n                                           &value);\n            pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n\n            /* Append to a=remote-candidates attribute */\n            if (pj_ice_strans_get_role(tp_ice->ice_st) == \n                                    PJ_ICE_SESS_ROLE_CONTROLLING) \n            {\n                char rem_addr[PJ_INET6_ADDRSTRLEN];\n\n                pj_sockaddr_print(&check->rcand->addr, rem_addr, \n                                  sizeof(rem_addr), 0);\n                len = pj_ansi_snprintf(\n                           rem_cand.ptr + rem_cand.slen,\n                           RATTR_BUF_LEN - rem_cand.slen,\n                           \"%s%u %s %u\", \n                           (rem_cand.slen==0? \"\" : \" \"),\n                           comp+1, rem_addr,\n                           pj_sockaddr_get_port(&check->rcand->addr)\n                           );\n                if (len < 1 || len >= RATTR_BUF_LEN - rem_cand.slen) {\n                    pj_assert(!\"Not enough buffer to print \"\n                               \"remote-candidates\");\n                    return PJ_EBUG;\n                }\n\n                rem_cand.slen += len;\n            }\n        }\n\n        /* 9.1.2.2: Existing Media Streams with ICE Completed\n         *   In addition, if the agent is controlling, it MUST include\n         *   the a=remote-candidates attribute for each media stream \n         *   whose check list is in the Completed state.  The attribute\n         *   contains the remote candidates from the highest priority \n         *   nominated pair in the valid list for each component of that\n         *   media stream.\n         */\n        if (pj_ice_strans_get_role(tp_ice->ice_st) == \n                                    PJ_ICE_SESS_ROLE_CONTROLLING) \n        {\n            attr = pjmedia_sdp_attr_create(sdp_pool, STR_REM_CAND.ptr, \n                                           &rem_cand);\n            pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n        }\n\n    } else if (pj_ice_strans_has_sess(tp_ice->ice_st) &&\n               (restart_session || pj_ice_strans_get_state(tp_ice->ice_st) !=\n                PJ_ICE_STRANS_STATE_FAILED))\n    {\n        /* Encode all candidates to SDP media */\n        char *attr_buf;\n        unsigned comp;\n\n        /* If ICE is not restarted, encode current ICE ufrag/pwd.\n         * Otherwise generate new one.\n         */\n        if (!restart_session) {\n            attr = pjmedia_sdp_attr_create(sdp_pool, STR_ICE_UFRAG.ptr,\n                                           &local_ufrag);\n            pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n\n            attr = pjmedia_sdp_attr_create(sdp_pool, STR_ICE_PWD.ptr, \n                                           &local_pwd);\n            pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n\n        } else {\n            pj_str_t str;\n\n            str.slen = PJ_ICE_UFRAG_LEN;\n            str.ptr = (char*) pj_pool_alloc(sdp_pool, str.slen);\n            pj_create_random_string(str.ptr, str.slen);\n            attr = pjmedia_sdp_attr_create(sdp_pool, STR_ICE_UFRAG.ptr, &str);\n            pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n\n            str.slen = PJ_ICE_PWD_LEN;\n            str.ptr = (char*) pj_pool_alloc(sdp_pool, str.slen);\n            pj_create_random_string(str.ptr, str.slen);\n            attr = pjmedia_sdp_attr_create(sdp_pool, STR_ICE_PWD.ptr, &str);\n            pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n        }\n\n        /* Create buffer to encode candidates as SDP attribute */\n        attr_buf = (char*) pj_pool_alloc(sdp_pool, ATTR_BUF_LEN);\n\n        for (comp=0; comp < comp_cnt; ++comp) {\n            unsigned cand_cnt;\n            pj_ice_sess_cand cand[PJ_ICE_ST_MAX_CAND];\n            unsigned i;\n\n            cand_cnt = PJ_ARRAY_SIZE(cand);\n            status = pj_ice_strans_enum_cands(tp_ice->ice_st, comp+1,\n                                              &cand_cnt, cand);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            for (i=0; i<cand_cnt; ++i) {\n                pj_str_t value;\n\n                value.slen = print_sdp_cand_attr(attr_buf, ATTR_BUF_LEN, \n                                                 &cand[i]);\n                if (value.slen < 0) {\n                    pj_assert(!\"Not enough attr_buf to print candidate\");\n                    return PJ_EBUG;\n                }\n\n                value.ptr = attr_buf;\n                attr = pjmedia_sdp_attr_create(sdp_pool, \n                                               STR_CANDIDATE.ptr,\n                                               &value);\n                pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n            }\n        }\n    } else {\n        /* ICE has failed, application should have terminated this call */\n    }\n\n    /* Removing a=rtcp line when there is only one component. */\n    if (comp_cnt == 1) {\n        attr = pjmedia_sdp_attr_find(m->attr_count, m->attr, &STR_RTCP, NULL);\n        if (attr)\n            pjmedia_sdp_attr_remove(&m->attr_count, m->attr, attr);\n        /* If RTCP is not in use, we MUST send b=RS:0 and b=RR:0. */\n        pj_assert(m->bandw_count + 2 <= PJ_ARRAY_SIZE(m->bandw));\n        if (m->bandw_count + 2 <= PJ_ARRAY_SIZE(m->bandw)) {\n            m->bandw[m->bandw_count] = PJ_POOL_ZALLOC_T(sdp_pool,\n                                                        pjmedia_sdp_bandw);\n            pj_memcpy(&m->bandw[m->bandw_count]->modifier, &STR_BANDW_RS,\n                      sizeof(pj_str_t));\n            m->bandw_count++;\n            m->bandw[m->bandw_count] = PJ_POOL_ZALLOC_T(sdp_pool,\n                                                        pjmedia_sdp_bandw);\n            pj_memcpy(&m->bandw[m->bandw_count]->modifier, &STR_BANDW_RR,\n                      sizeof(pj_str_t));\n            m->bandw_count++;\n        }\n    }\n\n    /* Add a=rtcp-mux attribute */\n    if (rtcp_mux) {\n        pjmedia_sdp_attr *add_attr;\n\n        add_attr = PJ_POOL_ZALLOC_T(sdp_pool, pjmedia_sdp_attr);\n        add_attr->name = STR_RTCP_MUX;\n        m->attr[m->attr_count++] = add_attr;\n    }\n\n    /* Add trickle ICE attributes */\n    if (trickle) {\n        pj_bool_t end_of_cand;\n\n        /* Add media ID attribute \"a=mid\" */\n        attr = pjmedia_sdp_attr_find2(m->attr_count, m->attr, \"mid\", NULL);\n        if (!attr) {\n            attr = pjmedia_sdp_attr_create(sdp_pool, \"mid\", &tp_ice->sdp_mid);\n            pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n        }\n\n        end_of_cand = tp_ice->end_of_cand;\n        status = pjmedia_ice_trickle_encode_sdp(sdp_pool, sdp_local,\n                                                &tp_ice->sdp_mid, NULL, NULL,\n                                                0, NULL, end_of_cand);\n        if (status != PJ_SUCCESS) {\n            PJ_PERROR(3,(tp_ice->base.name, status,\n                         \"Failed in adding trickle ICE attributes\"));\n            return status;\n        }\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/* Parse a=candidate line */\nstatic pj_status_t parse_cand(const char *obj_name,\n                              pj_pool_t *pool,\n                              const pj_str_t *orig_input,\n                              pj_ice_sess_cand *cand)\n{\n    pj_str_t token, delim, host;\n    int af;\n    pj_ssize_t found_idx;\n    pj_status_t status = PJNATH_EICEINCANDSDP;\n\n    pj_bzero(cand, sizeof(*cand));\n\n    PJ_UNUSED_ARG(obj_name);\n\n    /* Foundation */\n    delim = pj_str(\" \");\n    found_idx = pj_strtok(orig_input, &delim, &token, 0);\n    if (found_idx == orig_input->slen) {\n        TRACE__((obj_name, \"Expecting ICE foundation in candidate\"));\n        goto on_return;\n    }\n    if (pool) {\n        pj_strdup(pool, &cand->foundation, &token);\n    } else {\n        cand->foundation = token;\n    }\n\n    /* Component ID */\n    found_idx = pj_strtok(orig_input, &delim, &token, found_idx + token.slen);\n    if (found_idx == orig_input->slen) {\n        TRACE__((obj_name, \"Expecting ICE component ID in candidate\"));\n        goto on_return;\n    }\n    cand->comp_id = (pj_uint8_t)pj_strtoul(&token);\n\n    /* Transport */\n    found_idx = pj_strtok(orig_input, &delim, &token, found_idx + token.slen);\n    if (found_idx == orig_input->slen) {\n        TRACE__((obj_name, \"Expecting ICE transport in candidate\"));\n        goto on_return;\n    }\n    if (pj_stricmp2(&token, \"UDP\") != 0) {\n        TRACE__((obj_name, \n                 \"Expecting ICE UDP transport only in candidate\"));\n        goto on_return;\n    }\n\n    /* Priority */\n    found_idx = pj_strtok(orig_input, &delim, &token, found_idx + token.slen);\n    if (found_idx == orig_input->slen) {\n        TRACE__((obj_name, \"Expecting ICE priority in candidate\"));\n        goto on_return;\n    }\n    cand->prio = pj_strtoul(&token);\n\n    /* Host */\n    found_idx = pj_strtok(orig_input, &delim, &host, found_idx + token.slen);\n    if (found_idx == orig_input->slen) {\n        TRACE__((obj_name, \"Expecting ICE host in candidate\"));\n        goto on_return;\n    }\n    /* Detect address family */\n    if (pj_strchr(&host, ':'))\n        af = pj_AF_INET6();\n    else\n        af = pj_AF_INET();\n    /* Assign address */\n    if (pj_sockaddr_init(af, &cand->addr, &host, 0)) {\n        TRACE__((obj_name, \"Invalid ICE candidate address\"));\n        goto on_return;\n    }\n\n    /* Port */\n    found_idx = pj_strtok(orig_input, &delim, &token, found_idx + host.slen);\n    if (found_idx == orig_input->slen) {\n        TRACE__((obj_name, \"Expecting ICE port number in candidate\"));\n        goto on_return;\n    }\n    pj_sockaddr_set_port(&cand->addr, (pj_uint16_t)pj_strtoul(&token));\n\n    /* typ */\n    found_idx = pj_strtok(orig_input, &delim, &token, found_idx + token.slen);\n    if (found_idx == orig_input->slen) {\n        TRACE__((obj_name, \"Expecting ICE \\\"typ\\\" in candidate\"));\n        goto on_return;\n    }\n    if (pj_stricmp2(&token, \"typ\") != 0) {\n        TRACE__((obj_name, \"Expecting ICE \\\"typ\\\" in candidate\"));\n        goto on_return;\n    }\n\n    /* candidate type */\n    found_idx = pj_strtok(orig_input, &delim, &token, found_idx + token.slen);\n    if (found_idx == orig_input->slen) {\n        TRACE__((obj_name, \"Expecting ICE candidate type in candidate\"));\n        goto on_return;\n    }\n\n    if (pj_stricmp2(&token, \"host\") == 0) {\n        cand->type = PJ_ICE_CAND_TYPE_HOST;\n\n    } else if (pj_stricmp2(&token, \"srflx\") == 0) {\n        cand->type = PJ_ICE_CAND_TYPE_SRFLX;\n\n    } else if (pj_stricmp2(&token, \"relay\") == 0) {\n        cand->type = PJ_ICE_CAND_TYPE_RELAYED;\n\n    } else if (pj_stricmp2(&token, \"prflx\") == 0) {\n        cand->type = PJ_ICE_CAND_TYPE_PRFLX;\n\n    } else {\n        PJ_LOG(5,(obj_name, \"Invalid ICE candidate type %.*s in candidate\", \n                  (int)token.slen, token.ptr));\n        goto on_return;\n    }\n\n    status = PJ_SUCCESS;\n\non_return:\n    return status;\n}\n\n\n/* Create initial SDP offer */\nstatic pj_status_t create_initial_offer(struct transport_ice *tp_ice,\n                                        pj_pool_t *sdp_pool,\n                                        pjmedia_sdp_session *loc_sdp,\n                                        unsigned media_index)\n{\n    pj_status_t status;\n\n    /* Encode ICE in SDP */\n    status = encode_session_in_sdp(tp_ice, sdp_pool, loc_sdp, media_index, \n                                   tp_ice->comp_cnt, PJ_FALSE,\n                                   tp_ice->enable_rtcp_mux,\n                                   tp_ice->trickle_ice !=\n                                        PJ_ICE_SESS_TRICKLE_DISABLED);\n    if (status != PJ_SUCCESS) {\n        set_no_ice(tp_ice, \"Error encoding SDP answer\", status);\n        return status;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/* Verify incoming offer */\nstatic pj_status_t verify_ice_sdp(struct transport_ice *tp_ice,\n                                  pj_pool_t *tmp_pool,\n                                  const pjmedia_sdp_session *rem_sdp,\n                                  unsigned media_index,\n                                  pj_ice_sess_role current_ice_role,\n                                  struct sdp_state *sdp_state)\n{\n    const pjmedia_sdp_media *rem_m;\n    const pjmedia_sdp_attr *ufrag_attr, *pwd_attr;\n    const pjmedia_sdp_conn *rem_conn;\n    pj_bool_t comp1_found=PJ_FALSE, comp2_found=PJ_FALSE, has_rtcp=PJ_FALSE;\n    pj_sockaddr rem_conn_addr, rtcp_addr;\n    unsigned i;\n    int rem_af = 0;\n    pj_status_t status;\n\n    rem_m = rem_sdp->media[media_index];\n\n    /* Check if remote wants RTCP mux */\n    if (tp_ice->enable_rtcp_mux) {\n        pjmedia_sdp_attr *attr;\n\n        attr = pjmedia_sdp_attr_find(rem_m->attr_count, rem_m->attr, \n                                     &STR_RTCP_MUX, NULL);\n        tp_ice->use_rtcp_mux = (attr? PJ_TRUE: PJ_FALSE);\n    }\n\n    /* Get the \"ice-ufrag\" and \"ice-pwd\" attributes */\n    get_ice_attr(rem_sdp, rem_m, &ufrag_attr, &pwd_attr);\n\n    /* If \"ice-ufrag\" or \"ice-pwd\" are not found, disable ICE */\n    if (ufrag_attr==NULL || pwd_attr==NULL) {\n        sdp_state->match_comp_cnt = 0;\n        return PJ_SUCCESS;\n    }\n\n    /* Verify that default target for each component matches one of the \n     * candidate for the component. Otherwise stop ICE with ICE ice_mismatch \n     * error.\n     */\n\n    /* Component 1 is the c= line */\n    rem_conn = rem_m->conn;\n    if (rem_conn == NULL)\n        rem_conn = rem_sdp->conn;\n    if (!rem_conn)\n        return PJMEDIA_SDP_EMISSINGCONN;\n\n    /* Verify address family matches */\n    /*\n    if ((tp_ice->af==pj_AF_INET() && \n         pj_strcmp(&rem_conn->addr_type, &STR_IP4)!=0) ||\n        (tp_ice->af==pj_AF_INET6() && \n         pj_strcmp(&rem_conn->addr_type, &STR_IP6)!=0))\n    {\n        return PJMEDIA_SDP_ETPORTNOTEQUAL;\n    }\n    */\n\n    /* Get remote address family */\n    if (pj_strcmp(&rem_conn->addr_type, &STR_IP4)==0)\n        rem_af = pj_AF_INET();\n    else if (pj_strcmp(&rem_conn->addr_type, &STR_IP6)==0)\n        rem_af = pj_AF_INET6();\n    else\n        pj_assert(!\"Unsupported address family\");\n\n    /* Assign remote connection address */\n    status = pj_sockaddr_init(rem_af, &rem_conn_addr, &rem_conn->addr,\n                              (pj_uint16_t)rem_m->desc.port);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    if (tp_ice->comp_cnt > 1) {\n        const pjmedia_sdp_attr *attr;\n\n        /* Get default RTCP candidate from a=rtcp line, if present, otherwise\n         * calculate default RTCP candidate from default RTP target.\n         */\n        attr = pjmedia_sdp_attr_find(rem_m->attr_count, rem_m->attr, \n                                     &STR_RTCP, NULL);\n        has_rtcp = (attr != NULL);\n\n        if (attr) {\n            pjmedia_sdp_rtcp_attr rtcp_attr;\n\n            status = pjmedia_sdp_attr_get_rtcp(attr, &rtcp_attr);\n            if (status != PJ_SUCCESS) {\n                /* Error parsing a=rtcp attribute */\n                return status;\n            }\n        \n            if (rtcp_attr.addr.slen) {\n                /* Verify address family matches */\n                /*\n                if ((tp_ice->af==pj_AF_INET() && \n                     pj_strcmp(&rtcp_attr.addr_type, &STR_IP4)!=0) ||\n                    (tp_ice->af==pj_AF_INET6() && \n                     pj_strcmp(&rtcp_attr.addr_type, &STR_IP6)!=0))\n                {\n                    return PJMEDIA_SDP_ETPORTNOTEQUAL;\n                }\n                */\n\n                /* Assign RTCP address */\n                status = pj_sockaddr_init(rem_af, &rtcp_addr,\n                                          &rtcp_attr.addr,\n                                          (pj_uint16_t)rtcp_attr.port);\n                if (status != PJ_SUCCESS) {\n                    return PJMEDIA_SDP_EINRTCP;\n                }\n            } else {\n                /* Assign RTCP address */\n                status = pj_sockaddr_init(rem_af, &rtcp_addr, \n                                          NULL, \n                                          (pj_uint16_t)rtcp_attr.port);\n                if (status != PJ_SUCCESS) {\n                    return PJMEDIA_SDP_EINRTCP;\n                }\n                pj_sockaddr_copy_addr(&rtcp_addr, &rem_conn_addr);\n            }\n        } else {\n            unsigned rtcp_port;\n        \n            rtcp_port = pj_sockaddr_get_port(&rem_conn_addr) + 1;\n            pj_sockaddr_cp(&rtcp_addr, &rem_conn_addr);\n            pj_sockaddr_set_port(&rtcp_addr, (pj_uint16_t)rtcp_port);\n        }\n    }\n\n    /* Find the default addresses in a=candidate attributes. \n     */\n    for (i=0; i<rem_m->attr_count; ++i) {\n        pj_ice_sess_cand cand;\n        unsigned disable_ice_mismatch = tp_ice->options &\n                                        PJMEDIA_ICE_DISABLE_ICE_MISMATCH;\n\n        if (pj_strcmp(&rem_m->attr[i]->name, &STR_CANDIDATE)!=0)\n            continue;\n\n        status = parse_cand(tp_ice->base.name, tmp_pool, \n                            &rem_m->attr[i]->value, &cand);\n        if (status != PJ_SUCCESS) {\n            PJ_PERROR(4,(tp_ice->base.name, status,\n                         \"Error in parsing SDP candidate attribute '%.*s', \"\n                         \"candidate is ignored\",\n                         (int)rem_m->attr[i]->value.slen, \n                         rem_m->attr[i]->value.ptr));\n            continue;\n        }\n\n        if (!comp1_found && cand.comp_id==COMP_RTP)\n        {\n            if ((disable_ice_mismatch) ||\n                (pj_sockaddr_cmp(&rem_conn_addr, &cand.addr) == 0))\n            {\n                comp1_found = PJ_TRUE;\n            }\n        } else if (!comp2_found && cand.comp_id==COMP_RTCP)\n        {\n            if ((disable_ice_mismatch) ||\n                (pj_sockaddr_cmp(&rtcp_addr, &cand.addr) == 0))\n            {\n                comp2_found = PJ_TRUE;\n            }\n        }\n\n        if (cand.comp_id == COMP_RTCP)\n            has_rtcp = PJ_TRUE;\n\n        if (comp1_found && (comp2_found || tp_ice->comp_cnt==1))\n            break;\n    }\n\n    /* Check matched component count and ice_mismatch */\n    if (comp1_found &&\n        (tp_ice->comp_cnt==1 || !has_rtcp || tp_ice->use_rtcp_mux))\n    {\n        sdp_state->match_comp_cnt = 1;\n        sdp_state->ice_mismatch = PJ_FALSE;\n    } else if (comp1_found && comp2_found) {\n        sdp_state->match_comp_cnt = 2;\n        sdp_state->ice_mismatch = PJ_FALSE;\n    } else {\n        sdp_state->match_comp_cnt = (tp_ice->comp_cnt > 1 && has_rtcp)? 2 : 1;\n        sdp_state->ice_mismatch = PJ_TRUE;\n    }\n\n\n    /* Detect remote restarting session */\n    if (pj_ice_strans_has_sess(tp_ice->ice_st) &&\n        (pj_ice_strans_sess_is_running(tp_ice->ice_st) ||\n         pj_ice_strans_sess_is_complete(tp_ice->ice_st))) \n    {\n        pj_str_t rem_run_ufrag, rem_run_pwd;\n        pj_ice_strans_get_ufrag_pwd(tp_ice->ice_st, NULL, NULL,\n                                    &rem_run_ufrag, &rem_run_pwd);\n        if (pj_strcmp(&ufrag_attr->value, &rem_run_ufrag) ||\n            pj_strcmp(&pwd_attr->value, &rem_run_pwd))\n        {\n            /* Remote offers to restart ICE */\n            sdp_state->ice_restart = PJ_TRUE;\n        } else {\n            sdp_state->ice_restart = PJ_FALSE;\n        }\n    } else {\n        sdp_state->ice_restart = PJ_FALSE;\n    }\n\n    /* Detect our role */\n    if (pjmedia_sdp_attr_find(rem_sdp->attr_count, rem_sdp->attr,\n                              &STR_ICE_LITE, NULL) != NULL)\n    {\n        /* Remote is ICE lite, set our role as controlling */\n        sdp_state->local_role = PJ_ICE_SESS_ROLE_CONTROLLING;\n    } else {\n        if (current_ice_role==PJ_ICE_SESS_ROLE_CONTROLLING) {\n            sdp_state->local_role = PJ_ICE_SESS_ROLE_CONTROLLING;\n        } else {\n            sdp_state->local_role = PJ_ICE_SESS_ROLE_CONTROLLED;\n        }\n    }\n\n    /* Check trickle ICE indication */\n    if (tp_ice->trickle_ice != PJ_ICE_SESS_TRICKLE_DISABLED) {\n        sdp_state->has_trickle = pjmedia_ice_sdp_has_trickle(rem_sdp,\n                                                             media_index);\n\n        /* Reset ICE mismatch flag if conn addr is default address */\n        if (sdp_state->ice_mismatch && sdp_state->has_trickle) {\n            pj_sockaddr def_addr;\n            pj_sockaddr_init(rem_af, &def_addr, NULL, 9);\n            if (pj_sockaddr_cmp(&rem_conn_addr, &def_addr)==0)\n                sdp_state->ice_mismatch = PJ_FALSE;\n        }\n    } else {\n        sdp_state->has_trickle = PJ_FALSE;\n    }\n\n    PJ_LOG(4,(tp_ice->base.name, \n              \"Processing SDP: support ICE=%u, common comp_cnt=%u, \"\n              \"ice_mismatch=%u, ice_restart=%u, local_role=%s, trickle=%u\",\n              (sdp_state->match_comp_cnt != 0), \n              sdp_state->match_comp_cnt, \n              sdp_state->ice_mismatch, \n              sdp_state->ice_restart,\n              pj_ice_sess_role_name(sdp_state->local_role),\n              sdp_state->has_trickle));\n\n    return PJ_SUCCESS;\n\n}\n\n/* Encode information in SDP if ICE is not used */\nstatic pj_status_t encode_no_ice_in_sdp( struct transport_ice *tp_ice,\n                                         pj_pool_t *pool,\n                                         pjmedia_sdp_session *sdp_local,\n                                         const pjmedia_sdp_session *rem_sdp,\n                                         unsigned media_index)\n{\n    if (tp_ice->enable_rtcp_mux) {\n        pjmedia_sdp_media *m = sdp_local->media[media_index];\n        pjmedia_sdp_attr *attr;\n        pj_bool_t add_rtcp_mux = PJ_TRUE;\n\n        if (rem_sdp)\n            add_rtcp_mux = tp_ice->use_rtcp_mux;\n        else {\n            /* For subsequent offer, set it to false first since\n             * we are still waiting for remote answer.\n             */\n            tp_ice->use_rtcp_mux = PJ_FALSE;\n        }\n\n        /* Remove RTCP attribute because for subsequent offers/answers,\n         * the address (obtained from transport_get_info() ) may be\n         * incorrect if we are not yet confirmed to use RTCP mux\n         * (because we are still waiting for remote answer) or\n         * if remote rejects it.\n         */\n        pjmedia_sdp_attr_remove_all(&m->attr_count, m->attr, \"rtcp\");\n        \n        if (!tp_ice->use_rtcp_mux && tp_ice->comp_cnt > 1) {\n            pj_ice_sess_cand cand;\n            pj_status_t status;\n            \n            status = pj_ice_strans_get_def_cand(tp_ice->ice_st, 2, &cand);\n            if (status == PJ_SUCCESS) {\n                /* Add RTCP attribute if the remote doesn't offer or\n                 * rejects it.\n                 */\n                attr = pjmedia_sdp_attr_create_rtcp(pool, &cand.addr);  \n                if (attr)\n                    pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n            }\n        }\n\n        /* Add a=rtcp-mux attribute. */\n        if (add_rtcp_mux) {\n            attr = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_attr);\n            attr->name = STR_RTCP_MUX;\n            m->attr[m->attr_count++] = attr;\n        }\n    }\n    return PJ_SUCCESS;\n}\n\n\n/* Verify incoming offer and create initial answer */\nstatic pj_status_t create_initial_answer(struct transport_ice *tp_ice,\n                                         pj_pool_t *sdp_pool,\n                                         pjmedia_sdp_session *loc_sdp,\n                                         const pjmedia_sdp_session *rem_sdp,\n                                         unsigned media_index)\n{\n    const pjmedia_sdp_media *rem_m = rem_sdp->media[media_index];\n    pj_bool_t with_trickle;\n    pj_status_t status;\n\n    /* Check if media is removed (just in case) */\n    if (rem_m->desc.port == 0) {\n        return PJ_SUCCESS;\n    }\n\n    /* Verify the offer */\n    status = verify_ice_sdp(tp_ice, sdp_pool, rem_sdp, media_index, \n                            PJ_ICE_SESS_ROLE_CONTROLLED, \n                            &tp_ice->rem_offer_state);\n    if (status != PJ_SUCCESS) {\n        set_no_ice(tp_ice, \"Invalid SDP offer\", status);\n        return status;\n    }\n\n    /* Does remote support ICE? */\n    if (tp_ice->rem_offer_state.match_comp_cnt==0) {\n        set_no_ice(tp_ice, \"No ICE found in SDP offer\", PJ_SUCCESS);\n        encode_no_ice_in_sdp(tp_ice, sdp_pool, loc_sdp, rem_sdp,\n                             media_index);\n        return PJ_SUCCESS;\n    }\n\n    /* ICE ice_mismatch? */\n    if (tp_ice->rem_offer_state.ice_mismatch) {\n        set_no_ice(tp_ice, \"ICE ice_mismatch in remote offer\", PJ_SUCCESS);\n        encode_ice_mismatch(sdp_pool, loc_sdp, media_index);\n        return PJ_SUCCESS;\n    }\n\n    /* Encode ICE in SDP */\n    with_trickle = tp_ice->rem_offer_state.has_trickle &&\n                   tp_ice->trickle_ice != PJ_ICE_SESS_TRICKLE_DISABLED;\n    status = encode_session_in_sdp(tp_ice, sdp_pool, loc_sdp, media_index, \n                                   tp_ice->rem_offer_state.match_comp_cnt,\n                                   PJ_FALSE, tp_ice->use_rtcp_mux,\n                                   with_trickle);\n    if (status != PJ_SUCCESS) {\n        set_no_ice(tp_ice, \"Error encoding SDP answer\", status);\n        return status;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/* Create subsequent SDP offer */\nstatic pj_status_t create_subsequent_offer(struct transport_ice *tp_ice,\n                                           pj_pool_t *sdp_pool,\n                                           pjmedia_sdp_session *loc_sdp,\n                                           unsigned media_index)\n{\n    unsigned comp_cnt;\n\n    if (pj_ice_strans_has_sess(tp_ice->ice_st) == PJ_FALSE) {\n        /* We don't have ICE */\n        encode_no_ice_in_sdp(tp_ice, sdp_pool, loc_sdp, NULL, media_index);\n        return PJ_SUCCESS;\n    }\n\n    comp_cnt = pj_ice_strans_get_running_comp_cnt(tp_ice->ice_st);\n    return encode_session_in_sdp(tp_ice, sdp_pool, loc_sdp, media_index,\n                                 comp_cnt, PJ_FALSE, tp_ice->enable_rtcp_mux,\n                                 PJ_FALSE);\n}\n\n\n/* Create subsequent SDP answer */\nstatic pj_status_t create_subsequent_answer(struct transport_ice *tp_ice,\n                                            pj_pool_t *sdp_pool,\n                                            pjmedia_sdp_session *loc_sdp,\n                                            const pjmedia_sdp_session *rem_sdp,\n                                            unsigned media_index)\n{\n    pj_status_t status;\n\n    /* We have a session */\n    status = verify_ice_sdp(tp_ice, sdp_pool, rem_sdp, media_index, \n                            PJ_ICE_SESS_ROLE_CONTROLLED, \n                            &tp_ice->rem_offer_state);\n    if (status != PJ_SUCCESS) {\n        /* Something wrong with the offer */\n        return status;\n    }\n\n    if (pj_ice_strans_has_sess(tp_ice->ice_st)) {\n        /*\n         * Received subsequent offer while we have ICE active.\n         */\n\n        if (tp_ice->rem_offer_state.match_comp_cnt == 0) {\n            /* Remote no longer offers ICE */\n            encode_no_ice_in_sdp(tp_ice, sdp_pool, loc_sdp, rem_sdp,\n                                 media_index);\n            return PJ_SUCCESS;\n        }\n\n        if (tp_ice->rem_offer_state.ice_mismatch) {\n            encode_ice_mismatch(sdp_pool, loc_sdp, media_index);\n            return PJ_SUCCESS;\n        }\n\n        status = encode_session_in_sdp(tp_ice, sdp_pool, loc_sdp, media_index,\n                                       tp_ice->rem_offer_state.match_comp_cnt,\n                                       tp_ice->rem_offer_state.ice_restart,\n                                       tp_ice->use_rtcp_mux, PJ_FALSE);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        /* Done */\n\n    } else {\n        pj_bool_t with_trickle;\n\n        /*\n         * Received subsequent offer while we DON'T have ICE active.\n         */\n\n        if (tp_ice->rem_offer_state.match_comp_cnt == 0) {\n            /* Remote does not support ICE */\n            encode_no_ice_in_sdp(tp_ice, sdp_pool, loc_sdp, rem_sdp,\n                                 media_index);\n            return PJ_SUCCESS;\n        }\n\n        if (tp_ice->rem_offer_state.ice_mismatch) {\n            encode_ice_mismatch(sdp_pool, loc_sdp, media_index);\n            return PJ_SUCCESS;\n        }\n\n        /* Looks like now remote is offering ICE, so we need to create\n         * ICE session now.\n         */\n        status = pj_ice_strans_init_ice(tp_ice->ice_st, \n                                        PJ_ICE_SESS_ROLE_CONTROLLED,\n                                        NULL, NULL);\n        if (status != PJ_SUCCESS) {\n            /* Fail to create new ICE session */\n            return status;\n        }\n\n        with_trickle = tp_ice->rem_offer_state.has_trickle &&\n                       tp_ice->trickle_ice != PJ_ICE_SESS_TRICKLE_DISABLED;\n        status = encode_session_in_sdp(tp_ice, sdp_pool, loc_sdp, media_index,\n                                       tp_ice->rem_offer_state.match_comp_cnt,\n                                       tp_ice->rem_offer_state.ice_restart,\n                                       tp_ice->use_rtcp_mux,\n                                       with_trickle);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        /* Done */\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * For both UAC and UAS, pass in the SDP before sending it to remote.\n * This will add ICE attributes to the SDP.\n */\nstatic pj_status_t transport_media_create(pjmedia_transport *tp,\n                                          pj_pool_t *sdp_pool,\n                                          unsigned options,\n                                          const pjmedia_sdp_session *rem_sdp,\n                                          unsigned media_index)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n    pj_ice_sess_role ice_role;\n    pj_status_t status;\n\n    PJ_UNUSED_ARG(media_index);\n    PJ_UNUSED_ARG(sdp_pool);\n\n    tp_ice->media_option = options;\n    tp_ice->enable_rtcp_mux = ((options & PJMEDIA_TPMED_RTCP_MUX) != 0);\n    tp_ice->oa_role = ROLE_NONE;\n    tp_ice->initial_sdp = PJ_TRUE;\n\n    /* Init SDP \"a=mid\" attribute. Get from remote SDP for answerer or\n     * generate one for offerer (or if remote doesn't specify).\n     */\n    tp_ice->sdp_mid.slen = 0;\n    if (rem_sdp) {\n        pjmedia_sdp_media *m = rem_sdp->media[media_index];\n        pjmedia_sdp_attr *a;\n        a = pjmedia_sdp_attr_find2(m->attr_count, m->attr, \"mid\", NULL);\n        if (a) {\n            pj_strdup(tp_ice->pool, &tp_ice->sdp_mid, &a->value);\n        }\n    }\n    if (tp_ice->sdp_mid.slen == 0) {\n        char tmp_buf[8];\n        pj_ansi_snprintf(tmp_buf, sizeof(tmp_buf), \"%d\", media_index+1);\n        tp_ice->sdp_mid = pj_strdup3(tp_ice->pool, tmp_buf);\n    }\n\n    /* If RTCP mux is being used, set component count to 1 */\n    if (rem_sdp && tp_ice->enable_rtcp_mux) {\n        pjmedia_sdp_media *rem_m = rem_sdp->media[media_index];\n        pjmedia_sdp_attr *attr;\n        attr = pjmedia_sdp_attr_find(rem_m->attr_count, rem_m->attr,\n                                     &STR_RTCP_MUX, NULL);\n        tp_ice->use_rtcp_mux = (attr? PJ_TRUE: PJ_FALSE);\n    }\n    if (tp_ice->use_rtcp_mux &&\n        pj_ice_strans_get_running_comp_cnt(tp_ice->ice_st)>1)\n    {\n        pj_ice_strans_update_comp_cnt(tp_ice->ice_st, 1);\n    }\n\n    /* Init ICE, the initial role is set now based on availability of\n     * rem_sdp, but it will be checked again later.\n     */\n    ice_role = (rem_sdp==NULL ? PJ_ICE_SESS_ROLE_CONTROLLING : \n                                PJ_ICE_SESS_ROLE_CONTROLLED);\n    status = pj_ice_strans_init_ice(tp_ice->ice_st, ice_role, NULL, NULL);\n\n    /* For trickle ICE, if remote SDP has been received, process any remote\n     * ICE info now (ICE user fragment and/or initial ICE candidate list).\n     */\n    if (rem_sdp && status == PJ_SUCCESS) {\n        if (tp_ice->trickle_ice != PJ_ICE_SESS_TRICKLE_DISABLED &&\n            pjmedia_ice_sdp_has_trickle(rem_sdp, media_index))\n        {\n            pj_str_t ufrag, pwd;\n            unsigned cand_cnt = PJ_ICE_ST_MAX_CAND;\n            pj_ice_sess_cand cand[PJ_ICE_ST_MAX_CAND];\n            pj_bool_t end_of_cand;\n\n            status = pjmedia_ice_trickle_decode_sdp(rem_sdp, media_index,\n                                                    NULL, &ufrag, &pwd,\n                                                    &cand_cnt, cand,\n                                                    &end_of_cand);\n            if (status == PJ_SUCCESS)\n                status = pj_ice_strans_update_check_list(\n                                            tp_ice->ice_st, &ufrag, &pwd,\n                                            cand_cnt, cand, end_of_cand);\n            if (status != PJ_SUCCESS) {\n                PJ_PERROR(1,(tp_ice->base.name, status,\n                             \"Failed create checklist for trickling ICE\"));\n                return status;\n            }\n        }\n    }\n\n    /* Done */\n    return status;\n}\n\n\nstatic pj_status_t transport_encode_sdp(pjmedia_transport *tp,\n                                        pj_pool_t *sdp_pool,\n                                        pjmedia_sdp_session *sdp_local,\n                                        const pjmedia_sdp_session *rem_sdp,\n                                        unsigned media_index)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n    pj_status_t status;\n\n    /* Validate media transport */\n    /* This transport only support RTP/AVP transport, unless if\n     * transport checking is disabled\n     */\n    if ((tp_ice->media_option & PJMEDIA_TPMED_NO_TRANSPORT_CHECKING) == 0) {\n        pjmedia_sdp_media *m_rem, *m_loc;\n        pj_uint32_t tp_proto_loc, tp_proto_rem;\n\n        m_rem = rem_sdp? rem_sdp->media[media_index] : NULL;\n        m_loc = sdp_local->media[media_index];\n\n        tp_proto_loc = pjmedia_sdp_transport_get_proto(&m_loc->desc.transport);\n        tp_proto_rem = m_rem? \n                pjmedia_sdp_transport_get_proto(&m_rem->desc.transport) : 0;\n        PJMEDIA_TP_PROTO_TRIM_FLAG(tp_proto_loc, PJMEDIA_TP_PROFILE_RTCP_FB);\n        PJMEDIA_TP_PROTO_TRIM_FLAG(tp_proto_rem, PJMEDIA_TP_PROFILE_RTCP_FB);\n\n        if ((tp_proto_loc != PJMEDIA_TP_PROTO_RTP_AVP) ||\n            (m_rem && tp_proto_rem != PJMEDIA_TP_PROTO_RTP_AVP))\n        {\n            pjmedia_sdp_media_deactivate(sdp_pool, m_loc);\n            return PJMEDIA_SDP_EINPROTO;\n        }\n    }\n\n    if (tp_ice->initial_sdp) {\n        if (rem_sdp) {\n            status = create_initial_answer(tp_ice, sdp_pool, sdp_local, \n                                           rem_sdp, media_index);\n        } else {\n            status = create_initial_offer(tp_ice, sdp_pool, sdp_local,\n                                          media_index);\n        }\n    } else {\n        if (rem_sdp) {\n            status = create_subsequent_answer(tp_ice, sdp_pool, sdp_local,\n                                              rem_sdp, media_index);\n        } else {\n            status = create_subsequent_offer(tp_ice, sdp_pool, sdp_local,\n                                             media_index);\n        }\n    }\n\n    if (status==PJ_SUCCESS) {\n        if (rem_sdp)\n            tp_ice->oa_role = ROLE_ANSWERER;\n        else\n            tp_ice->oa_role = ROLE_OFFERER;\n\n        if (tp_ice->use_ice) {\n            /* Update last local candidate count, so trickle ICE can identify\n             * if there is any new local candidate.\n             */\n            unsigned i, comp_cnt;\n            comp_cnt = pj_ice_strans_get_running_comp_cnt(tp_ice->ice_st);\n            for (i = 0; i < comp_cnt; ++i) {\n                tp_ice->last_send_cand_cnt[i] =\n                        pj_ice_strans_get_cands_count(tp_ice->ice_st, i+1);\n            }\n        }\n    }\n\n    return status;\n}\n\n\n/* Start ICE session with the specified remote SDP */\nstatic pj_status_t start_ice(struct transport_ice *tp_ice,\n                             pj_pool_t *tmp_pool,\n                             const pjmedia_sdp_session *rem_sdp,\n                             unsigned media_index)\n{\n    pjmedia_sdp_media *rem_m = rem_sdp->media[media_index];\n    const pjmedia_sdp_attr *ufrag_attr, *pwd_attr;\n    pj_ice_sess_cand *cand;\n    unsigned i, cand_cnt;\n    pj_status_t status;\n\n    get_ice_attr(rem_sdp, rem_m, &ufrag_attr, &pwd_attr);\n\n    /* Allocate candidate array */\n    cand = (pj_ice_sess_cand*)\n           pj_pool_calloc(tmp_pool, PJ_ICE_MAX_CAND, \n                          sizeof(pj_ice_sess_cand));\n\n    /* Get all candidates in the media */\n    cand_cnt = 0;\n    for (i=0; i<rem_m->attr_count && cand_cnt < PJ_ICE_MAX_CAND; ++i) {\n        pjmedia_sdp_attr *attr;\n\n        attr = rem_m->attr[i];\n\n        if (pj_strcmp(&attr->name, &STR_CANDIDATE)!=0)\n            continue;\n\n        /* Parse candidate */\n        status = parse_cand(tp_ice->base.name, tmp_pool, &attr->value, \n                            &cand[cand_cnt]);\n        if (status != PJ_SUCCESS) {\n            PJ_PERROR(4,(tp_ice->base.name, status,\n                         \"Error in parsing SDP candidate attribute '%.*s', \"\n                         \"candidate is ignored\",\n                         (int)attr->value.slen, attr->value.ptr));\n            continue;\n        }\n\n        if (!tp_ice->use_rtcp_mux || cand[cand_cnt].comp_id < 2)\n            cand_cnt++;\n    }\n\n    /* Start ICE */\n    return pj_ice_strans_start_ice(tp_ice->ice_st, &ufrag_attr->value, \n                                   &pwd_attr->value, cand_cnt, cand);\n}\n\n\n/*\n * Start ICE checks when both offer and answer have been negotiated\n * by SDP negotiator.\n */\nstatic pj_status_t transport_media_start(pjmedia_transport *tp,\n                                         pj_pool_t *tmp_pool,\n                                         const pjmedia_sdp_session *sdp_local,\n                                         const pjmedia_sdp_session *rem_sdp,\n                                         unsigned media_index)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n    pjmedia_sdp_media *rem_m;\n    enum oa_role current_oa_role;\n    pj_bool_t initial_oa;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(tp && tmp_pool && rem_sdp, PJ_EINVAL);\n    PJ_ASSERT_RETURN(media_index < rem_sdp->media_count, PJ_EINVAL);\n\n    rem_m = rem_sdp->media[media_index];\n\n    initial_oa = tp_ice->initial_sdp;\n    current_oa_role = tp_ice->oa_role;\n\n    /* SDP has been negotiated */\n    tp_ice->initial_sdp = PJ_FALSE;\n    tp_ice->oa_role = ROLE_NONE;\n\n    /* Nothing to do if we don't have ICE session */\n    if (pj_ice_strans_has_sess(tp_ice->ice_st) == PJ_FALSE) {\n        return PJ_SUCCESS;\n    }\n\n    /* Special case for Session Timer. The re-INVITE for session refresh\n     * doesn't call transport_encode_sdp(), causing current_oa_role to\n     * be set to ROLE_NONE. This is a workaround.\n     */\n    if (current_oa_role == ROLE_NONE) {\n        current_oa_role = ROLE_OFFERER;\n    }\n\n    /* Processing depends on the offer/answer role */\n    if (current_oa_role == ROLE_OFFERER) {\n        /*\n         * We are offerer. So this will be the first time we see the\n         * remote's SDP.\n         */\n        struct sdp_state answer_state;\n\n        /* Verify the answer */\n        status = verify_ice_sdp(tp_ice, tmp_pool, rem_sdp, media_index, \n                                PJ_ICE_SESS_ROLE_CONTROLLING, &answer_state);\n        if (status != PJ_SUCCESS) {\n            /* Something wrong in the SDP answer */\n            set_no_ice(tp_ice, \"Invalid remote SDP answer\", status);\n            return status;\n        }\n\n        /* Does it have ICE? */\n        if (answer_state.match_comp_cnt == 0) {\n            /* Remote doesn't support ICE */\n            set_no_ice(tp_ice, \"Remote answer doesn't support ICE\", \n                       PJ_SUCCESS);\n            return PJ_SUCCESS;\n        }\n\n        /* Check if remote has reported ice-mismatch */\n        if (pjmedia_sdp_attr_find(rem_m->attr_count, rem_m->attr, \n                                  &STR_ICE_MISMATCH, NULL) != NULL)\n        {\n            /* Remote has reported ice-mismatch */\n            set_no_ice(tp_ice, \n                       \"Remote answer contains 'ice-mismatch' attribute\", \n                       PJ_SUCCESS);\n            return PJ_SUCCESS;\n        }\n\n        /* Check if remote has indicated a restart */\n        if (answer_state.ice_restart) {\n            PJ_LOG(2,(tp_ice->base.name, \n                      \"Warning: remote has signalled ICE restart in SDP \"\n                      \"answer which is disallowed. Remote ICE negotiation\"\n                      \" may fail.\"));\n        }\n\n        /* Check if the answer itself is mismatched */\n        if (answer_state.ice_mismatch) {\n            /* This happens either when a B2BUA modified remote answer but\n             * strangely didn't modify our offer, or remote is not capable\n             * of detecting mismatch in our offer (it didn't put \n             * 'ice-mismatch' attribute in the answer).\n             */\n            PJ_LOG(2,(tp_ice->base.name, \n                      \"Warning: remote answer mismatch, but it does not \"\n                      \"reject our offer with 'ice-mismatch'. ICE negotiation \"\n                      \"may fail\"));\n        }\n\n        /* Do nothing if ICE is complete or running */\n        if (pj_ice_strans_sess_is_running(tp_ice->ice_st)) {\n            PJ_LOG(4,(tp_ice->base.name,\n                      \"Ignored offer/answer because ICE is running\"));\n            return PJ_SUCCESS;\n        }\n\n        if (pj_ice_strans_sess_is_complete(tp_ice->ice_st)) {\n            PJ_LOG(4,(tp_ice->base.name, \"ICE session unchanged\"));\n            return PJ_SUCCESS;\n        }\n\n        /* Start ICE */\n\n    } else {\n        /*\n         * We are answerer. We've seen and negotiated remote's SDP\n         * before, and the result is in \"rem_offer_state\".\n         */\n        const pjmedia_sdp_attr *ufrag_attr, *pwd_attr;\n\n        /* Check for ICE in remote offer */\n        if (tp_ice->rem_offer_state.match_comp_cnt == 0) {\n            /* No ICE attribute present */\n            set_no_ice(tp_ice, \"Remote no longer offers ICE\",\n                       PJ_SUCCESS);\n            return PJ_SUCCESS;\n        }\n\n        /* Check for ICE ice_mismatch condition in the offer */\n        if (tp_ice->rem_offer_state.ice_mismatch) {\n            set_no_ice(tp_ice, \"Remote offer mismatch: \", \n                       PJNATH_EICEMISMATCH);\n            return PJ_SUCCESS;\n        }\n\n        /* If ICE is complete and remote doesn't request restart,\n         * then leave the session as is.\n         */\n        if (!initial_oa && tp_ice->rem_offer_state.ice_restart == PJ_FALSE) {\n            /* Remote has not requested ICE restart, so session is\n             * unchanged.\n             */\n            PJ_LOG(4,(tp_ice->base.name, \"ICE session unchanged\"));\n            return PJ_SUCCESS;\n        }\n\n        /* Either remote has requested ICE restart or this is our\n         * first answer. \n         */\n\n        /* Stop ICE */\n        if (!initial_oa) {\n            set_no_ice(tp_ice, \"restarting by remote request..\", PJ_SUCCESS);\n\n            /* We have put new ICE ufrag and pwd in the answer. Now\n             * create a new ICE session with that ufrag/pwd pair.\n             */\n            get_ice_attr(sdp_local, sdp_local->media[media_index], \n                         &ufrag_attr, &pwd_attr);\n            status = pj_ice_strans_init_ice(tp_ice->ice_st, \n                                            tp_ice->rem_offer_state.local_role,\n                                            &ufrag_attr->value, \n                                            &pwd_attr->value);\n            if (status != PJ_SUCCESS) {\n                PJ_PERROR(1,(tp_ice->base.name, status,\n                             \"ICE re-initialization failed!\"));\n                return status;\n            }\n        }\n\n        /* Ticket #977: Update role if turns out we're supposed to be the \n         * Controlling agent (e.g. when talking to ice-lite peer). \n         */\n        if (tp_ice->rem_offer_state.local_role==PJ_ICE_SESS_ROLE_CONTROLLING &&\n            pj_ice_strans_has_sess(tp_ice->ice_st)) \n        {\n            pj_ice_strans_change_role(tp_ice->ice_st, \n                                      PJ_ICE_SESS_ROLE_CONTROLLING);\n        }\n\n        /* start ICE */\n    }\n\n    /* RFC 5245 section 8.1.1:\n     * If its peer has a lite implementation, an agent MUST use\n     * a regular nomination algorithm.\n     */\n    if (pjmedia_sdp_attr_find(rem_sdp->attr_count, rem_sdp->attr,\n                              &STR_ICE_LITE, NULL) != NULL)\n    {\n        pj_ice_sess_options opt;\n        pj_ice_strans_get_options(tp_ice->ice_st, &opt);\n        if (opt.aggressive) {\n            opt.aggressive = PJ_FALSE;\n            pj_ice_strans_set_options(tp_ice->ice_st, &opt);\n            PJ_LOG(4,(tp_ice->base.name, \"Forcefully set ICE to use regular \"\n                      \"nomination as remote is lite implementation\"));\n        }\n    }\n\n    /* Now start ICE, if not yet (trickle ICE may have started it earlier) */\n    if (!pj_ice_strans_sess_is_running(tp_ice->ice_st) &&\n        !pj_ice_strans_sess_is_complete(tp_ice->ice_st))\n    {\n        status = start_ice(tp_ice, tmp_pool, rem_sdp, media_index);\n        if (status != PJ_SUCCESS) {\n            PJ_PERROR(1,(tp_ice->base.name, status, \"ICE restart failed!\"));\n            return status;\n        }\n    }\n\n    /* Done */\n    tp_ice->use_ice = PJ_TRUE;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t transport_media_stop(pjmedia_transport *tp)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n    \n    set_no_ice(tp_ice, \"media stop requested\", PJ_SUCCESS);\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t transport_get_info(pjmedia_transport *tp,\n                                      pjmedia_transport_info *info)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n    pj_ice_sess_cand cands[PJ_ICE_ST_MAX_CAND];\n    pj_ice_sess_cand cand;\n    pj_sockaddr_t *addr;\n    pj_status_t status;\n\n    pj_bzero(&info->sock_info, sizeof(info->sock_info));\n    info->sock_info.rtp_sock = info->sock_info.rtcp_sock = PJ_INVALID_SOCKET;\n\n    /* Get RTP default address */\n    status = pj_ice_strans_get_def_cand(tp_ice->ice_st, 1, &cand);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Address of the default candidate may not be available (e.g:\n     * STUN/TURN address is still being resolved), so let's find address\n     * of any other candidate, if still not available, the draft RFC\n     * seems to allow us using \"0.0.0.0:9\" in SDP.\n     */\n    addr = NULL;\n    if (pj_sockaddr_has_addr(&cand.addr)) {\n        addr = &cand.addr;\n    } else if (pj_ice_strans_has_sess(tp_ice->ice_st)) {\n        unsigned i, cnt = PJ_ICE_ST_MAX_CAND;\n        pj_ice_strans_enum_cands(tp_ice->ice_st, 1, &cnt, cands);\n        for (i = 0; i < cnt && !addr; ++i) {\n            if (pj_sockaddr_has_addr(&cands[i].addr))\n                addr = &cands[i].addr;\n        }\n    }\n    if (addr) {\n        pj_sockaddr_cp(&info->sock_info.rtp_addr_name, addr);\n    } else {\n        pj_sockaddr_init(PJ_AF_INET, &info->sock_info.rtp_addr_name, NULL, 9);\n    }\n\n    /* Get RTCP default address */\n    if (tp_ice->use_rtcp_mux) {\n        pj_sockaddr_cp(&info->sock_info.rtcp_addr_name,\n                       &info->sock_info.rtp_addr_name);\n    } else if (tp_ice->comp_cnt > 1) {\n        status = pj_ice_strans_get_def_cand(tp_ice->ice_st, 2, &cand);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        /* Address of the default candidate may not be available (e.g:\n         * STUN/TURN address is still being resolved), so let's find address\n         * of any other candidate. If none is available, SDP must not include\n         * \"a=rtcp\" attribute.\n         */\n        addr = NULL;\n        if (pj_sockaddr_has_addr(&cand.addr)) {\n            addr = &cand.addr;\n        } else if (pj_ice_strans_has_sess(tp_ice->ice_st)) {\n            unsigned i, cnt = PJ_ICE_ST_MAX_CAND;\n            pj_ice_strans_enum_cands(tp_ice->ice_st, 2, &cnt, cands);\n            for (i = 0; i < cnt && !addr; ++i) {\n                if (pj_sockaddr_has_addr(&cands[i].addr))\n                    addr = &cands[i].addr;\n            }\n        }\n        if (addr) {\n            pj_sockaddr_cp(&info->sock_info.rtcp_addr_name, addr);\n        }\n    }\n\n    /* Set remote address originating RTP & RTCP if this transport has \n     * ICE activated or received any packets.\n     */\n    if (tp_ice->use_ice || tp_ice->rtp_src_cnt) {\n        info->src_rtp_name = tp_ice->rtp_src_addr;\n        if (tp_ice->use_rtcp_mux)\n            info->src_rtcp_name = tp_ice->rtp_src_addr;\n    }\n    if ((!tp_ice->use_rtcp_mux) &&\n        (tp_ice->use_ice || tp_ice->rtcp_src_cnt))\n    {\n        info->src_rtcp_name = tp_ice->rtcp_src_addr;\n    }\n\n    /* Fill up transport specific info */\n    if (info->specific_info_cnt < PJ_ARRAY_SIZE(info->spc_info)) {\n        pjmedia_transport_specific_info *tsi;\n        pjmedia_ice_transport_info *ii;\n        unsigned i;\n\n        pj_assert(sizeof(*ii) <= sizeof(tsi->buffer));\n        tsi = &info->spc_info[info->specific_info_cnt++];\n        tsi->type = PJMEDIA_TRANSPORT_TYPE_ICE;\n        tsi->tp = tp;\n        tsi->cbsize = sizeof(*ii);\n\n        ii = (pjmedia_ice_transport_info*) tsi->buffer;\n        pj_bzero(ii, sizeof(*ii));\n\n        ii->active = tp_ice->use_ice;\n\n        if (pj_ice_strans_has_sess(tp_ice->ice_st)) {\n            ii->role = pj_ice_strans_get_role(tp_ice->ice_st);\n            pj_ice_strans_get_ufrag_pwd(tp_ice->ice_st, &ii->loc_ufrag, NULL,\n                                        &ii->rem_ufrag, NULL);\n        } else {\n            ii->role = PJ_ICE_SESS_ROLE_UNKNOWN;\n        }\n        ii->sess_state = pj_ice_strans_get_state(tp_ice->ice_st);\n        ii->comp_cnt = pj_ice_strans_get_running_comp_cnt(tp_ice->ice_st);\n        \n        for (i=1; i<=ii->comp_cnt && i<=PJ_ARRAY_SIZE(ii->comp); ++i) {\n            const pj_ice_sess_check *chk;\n\n            chk = pj_ice_strans_get_valid_pair(tp_ice->ice_st, i);\n            if (chk) {\n                ii->comp[i-1].lcand_type = chk->lcand->type;\n                pj_sockaddr_cp(&ii->comp[i-1].lcand_addr,\n                               &chk->lcand->addr);\n                ii->comp[i-1].rcand_type = chk->rcand->type;\n                pj_sockaddr_cp(&ii->comp[i-1].rcand_addr,\n                               &chk->rcand->addr);\n            }\n        }\n    }\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t transport_attach  (pjmedia_transport *tp,\n                                      void *stream,\n                                      const pj_sockaddr_t *rem_addr,\n                                      const pj_sockaddr_t *rem_rtcp,\n                                      unsigned addr_len,\n                                      void (*rtp_cb)(void*,\n                                                     void*,\n                                                     pj_ssize_t),\n                                      void (*rtcp_cb)(void*,\n                                                      void*,\n                                                      pj_ssize_t))\n{\n    pjmedia_transport_attach_param param;\n    \n    pj_bzero(&param, sizeof(param));\n    param.user_data = stream;\n    pj_sockaddr_cp(&param.rem_addr, rem_addr);\n    pj_sockaddr_cp(&param.rem_rtcp, rem_rtcp);\n    param.addr_len = addr_len;\n    param.rtp_cb = rtp_cb;\n    param.rtcp_cb = rtcp_cb;\n    return transport_attach2(tp, &param);\n}\n\n\nstatic pj_status_t transport_attach2  (pjmedia_transport *tp,\n                                       pjmedia_transport_attach_param\n                                           *att_param)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n\n    tp_ice->stream = att_param->user_data;\n    tp_ice->rtp_cb = att_param->rtp_cb;\n    tp_ice->rtp_cb2 = att_param->rtp_cb2;\n    tp_ice->rtcp_cb = att_param->rtcp_cb;\n\n    /* Check again if we are multiplexing RTP & RTCP. */\n    tp_ice->use_rtcp_mux = (pj_sockaddr_has_addr(&att_param->rem_addr) &&\n                            pj_sockaddr_cmp(&att_param->rem_addr,\n                                            &att_param->rem_rtcp) == 0);\n\n    pj_memcpy(&tp_ice->remote_rtp, &att_param->rem_addr, att_param->addr_len);\n    pj_memcpy(&tp_ice->remote_rtcp, &att_param->rem_rtcp, att_param->addr_len);\n    tp_ice->addr_len = att_param->addr_len;\n\n    /* Init source RTP & RTCP addresses and counter */\n    tp_ice->rtp_src_addr = tp_ice->remote_rtp;\n    pj_bzero(&tp_ice->rtcp_src_addr, sizeof(tp_ice->rtcp_src_addr));\n    tp_ice->rtp_src_cnt = tp_ice->rtcp_src_cnt = 0;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void transport_detach(pjmedia_transport *tp,\n                             void *strm)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n\n    /* TODO: need to solve ticket #460 here */\n\n    tp_ice->rtp_cb = NULL;\n    tp_ice->rtp_cb2 = NULL;\n    tp_ice->rtcp_cb = NULL;\n    tp_ice->stream = NULL;\n\n    PJ_UNUSED_ARG(strm);\n}\n\n\nstatic pj_status_t transport_send_rtp(pjmedia_transport *tp,\n                                      const void *pkt,\n                                      pj_size_t size)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n    pj_status_t status;\n\n    /* Simulate packet lost on TX direction */\n    if (tp_ice->tx_drop_pct) {\n        if ((pj_rand() % 100) <= (int)tp_ice->tx_drop_pct) {\n            PJ_LOG(5,(tp_ice->base.name, \n                      \"TX RTP packet dropped because of pkt lost \"\n                      \"simulation\"));\n            return PJ_SUCCESS;\n        }\n    }\n\n    status = pj_ice_strans_sendto2(tp_ice->ice_st, 1, \n                                   pkt, size, &tp_ice->remote_rtp,\n                                   tp_ice->addr_len);\n    if (status == PJ_EPENDING)\n        status = PJ_SUCCESS;\n\n    return status;\n}\n\n\nstatic pj_status_t transport_send_rtcp(pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size)\n{\n    return transport_send_rtcp2(tp, NULL, 0, pkt, size);\n}\n\nstatic pj_status_t transport_send_rtcp2(pjmedia_transport *tp,\n                                        const pj_sockaddr_t *addr,\n                                        unsigned addr_len,\n                                        const void *pkt,\n                                        pj_size_t size)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n\n    if (tp_ice->comp_cnt > 1 || tp_ice->use_rtcp_mux) {\n        pj_status_t status;\n        unsigned comp_id = (tp_ice->use_rtcp_mux? 1: 2);\n\n        if (addr == NULL) {\n            addr = &tp_ice->remote_rtcp;\n            addr_len = pj_sockaddr_get_len(addr);\n        }         \n\n        status = pj_ice_strans_sendto2(tp_ice->ice_st, comp_id, pkt, size,\n                                       addr, addr_len);\n        if (status == PJ_EPENDING)\n            status = PJ_SUCCESS;\n\n        return status;\n    } else {\n        return PJ_SUCCESS;\n    }\n}\n\n\nstatic void ice_on_rx_data(pj_ice_strans *ice_st, unsigned comp_id, \n                           void *pkt, pj_size_t size,\n                           const pj_sockaddr_t *src_addr,\n                           unsigned src_addr_len)\n{\n    struct transport_ice *tp_ice;\n    pj_bool_t discard = PJ_FALSE;\n\n    tp_ice = (struct transport_ice*) pj_ice_strans_get_user_data(ice_st);\n    if (!tp_ice) {\n        /* Destroy on progress */\n        return;\n    }\n\n    if (comp_id == 1) {\n        ++tp_ice->rtp_src_cnt;\n        pj_sockaddr_cp(&tp_ice->rtp_src_addr, src_addr);\n    } else if (comp_id == 2) {\n        pj_sockaddr_cp(&tp_ice->rtcp_src_addr, src_addr);\n    }\n\n    if (comp_id==1 && (tp_ice->rtp_cb || tp_ice->rtp_cb2)) {\n        pj_bool_t rem_switch = PJ_FALSE;\n\n        /* Simulate packet lost on RX direction */\n        if (tp_ice->rx_drop_pct) {\n            if ((pj_rand() % 100) <= (int)tp_ice->rx_drop_pct) {\n                PJ_LOG(5,(tp_ice->base.name, \n                          \"RX RTP packet dropped because of pkt lost \"\n                          \"simulation\"));\n                return;\n            }\n        }\n\n        if (!discard) {\n            if (tp_ice->rtp_cb2) {\n                pjmedia_tp_cb_param param;\n\n                param.user_data = tp_ice->stream;\n                param.pkt = pkt;\n                param.size = size;\n                param.src_addr = (tp_ice->use_ice? NULL:\n                                  (pj_sockaddr_t *)src_addr);\n                param.rem_switch = PJ_FALSE;\n                (*tp_ice->rtp_cb2)(&param);\n                rem_switch = param.rem_switch;\n            } else {\n                (*tp_ice->rtp_cb)(tp_ice->stream, pkt, size);\n            }\n        }\n        \n#if defined(PJMEDIA_TRANSPORT_SWITCH_REMOTE_ADDR) && \\\n    (PJMEDIA_TRANSPORT_SWITCH_REMOTE_ADDR == 1)\n        if (rem_switch &&\n            (tp_ice->options & PJMEDIA_ICE_NO_SRC_ADDR_CHECKING)==0)\n        {\n            char addr_text[PJ_INET6_ADDRSTRLEN+10];\n\n            /* Set remote RTP address to source address */\n            pj_sockaddr_cp(&tp_ice->rtp_src_addr, src_addr);\n            pj_sockaddr_cp(&tp_ice->remote_rtp, src_addr);\n            tp_ice->addr_len = pj_sockaddr_get_len(&tp_ice->remote_rtp);\n\n            PJ_LOG(4,(tp_ice->base.name,\n                      \"Remote RTP address switched to %s\",\n                      pj_sockaddr_print(&tp_ice->remote_rtp, addr_text,\n                                        sizeof(addr_text), 3)));\n\n            if (tp_ice->use_rtcp_mux) {\n                pj_sockaddr_cp(&tp_ice->remote_rtcp, &tp_ice->remote_rtp);\n            } else if (!pj_sockaddr_has_addr(&tp_ice->rtcp_src_addr)) {\n                /* Also update remote RTCP address if actual RTCP source\n                 * address is not heard yet.\n                 */\n                pj_uint16_t port;\n\n                pj_sockaddr_cp(&tp_ice->remote_rtcp, &tp_ice->remote_rtp);\n\n                port = (pj_uint16_t)\n                       (pj_sockaddr_get_port(&tp_ice->remote_rtp)+1);\n                pj_sockaddr_set_port(&tp_ice->remote_rtcp, port);\n\n                PJ_LOG(4,(tp_ice->base.name,\n                          \"Remote RTCP address switched to predicted \"\n                          \"address %s\",\n                          pj_sockaddr_print(&tp_ice->remote_rtcp, \n                                            addr_text,\n                                            sizeof(addr_text), 3)));\n            }\n        }\n#else\n        PJ_UNUSED_ARG(rem_switch);\n#endif\n\n    } else if (comp_id==2 && tp_ice->rtcp_cb) {\n\n#if defined(PJMEDIA_TRANSPORT_SWITCH_REMOTE_ADDR) && \\\n    (PJMEDIA_TRANSPORT_SWITCH_REMOTE_ADDR == 1)\n        /* Check if RTCP source address is the same as the configured\n         * remote address, and switch the address when they are\n         * different.\n         */\n        if (!tp_ice->use_ice &&\n            (tp_ice->options & PJMEDIA_ICE_NO_SRC_ADDR_CHECKING)==0)\n        {\n            if (pj_sockaddr_cmp(&tp_ice->remote_rtcp, src_addr) == 0) {\n                tp_ice->rtcp_src_cnt = 0;\n            } else {\n                char addr_text[PJ_INET6_ADDRSTRLEN+10];\n\n                ++tp_ice->rtcp_src_cnt;\n                if (tp_ice->rtcp_src_cnt < PJMEDIA_RTCP_NAT_PROBATION_CNT) {\n                    discard = PJ_TRUE;\n                } else {\n                    tp_ice->rtcp_src_cnt = 0;\n                    pj_sockaddr_cp(&tp_ice->rtcp_src_addr, src_addr);\n                    pj_sockaddr_cp(&tp_ice->remote_rtcp, src_addr);\n\n                    pj_assert(tp_ice->addr_len==pj_sockaddr_get_len(src_addr));\n\n                    PJ_LOG(4,(tp_ice->base.name,\n                              \"Remote RTCP address switched to %s\",\n                              pj_sockaddr_print(&tp_ice->remote_rtcp,\n                                                addr_text, sizeof(addr_text),\n                                                3)));\n                }\n            }\n        }\n#endif\n\n        if (!discard)\n            (*tp_ice->rtcp_cb)(tp_ice->stream, pkt, size);\n    }\n\n    PJ_UNUSED_ARG(src_addr_len);\n}\n\n\nstatic void ice_on_ice_complete(pj_ice_strans *ice_st, \n                                pj_ice_strans_op op,\n                                pj_status_t result)\n{\n    struct transport_ice *tp_ice;\n    ice_listener *il;\n\n    tp_ice = (struct transport_ice*) pj_ice_strans_get_user_data(ice_st);\n    if (!tp_ice) {\n        /* Destroy on progress */\n        return;\n    }\n\n    /* Set the flag indicating that local candidate gathering is completed */\n    if (op == PJ_ICE_STRANS_OP_INIT && result == PJ_SUCCESS)\n        tp_ice->end_of_cand = PJ_TRUE;\n\n    pj_perror(5, tp_ice->base.name, result, \"ICE operation complete\"\n              \" (op=%d%s)\", op,\n              (op==PJ_ICE_STRANS_OP_INIT? \"/initialization\" :\n              (op==PJ_ICE_STRANS_OP_NEGOTIATION? \"/negotiation\":\"\")));\n\n    /* Notify application */\n    if (tp_ice->cb.on_ice_complete)\n        (*tp_ice->cb.on_ice_complete)(&tp_ice->base, op, result);\n\n    for (il=tp_ice->listener.next; il!=&tp_ice->listener; il=il->next) {\n        if (il->cb.on_ice_complete2) {\n            (*il->cb.on_ice_complete2)(&tp_ice->base, op, result,\n                                       il->user_data);\n        } else if (il->cb.on_ice_complete) {\n            (*il->cb.on_ice_complete)(&tp_ice->base, op, result);\n        }\n    }\n}\n\n\nstatic void ice_on_new_candidate(pj_ice_strans *ice_st,\n                                 const pj_ice_sess_cand *cand,\n                                 pj_bool_t last)\n{\n    struct transport_ice *tp_ice;\n    ice_listener *il;\n\n    tp_ice = (struct transport_ice*) pj_ice_strans_get_user_data(ice_st);\n    if (!tp_ice) {\n        /* Destroy on progress */\n        return;\n    }\n\n    /* Notify application */\n    if (tp_ice->cb.on_new_candidate)\n        (*tp_ice->cb.on_new_candidate)(&tp_ice->base, cand, last);\n\n    for (il=tp_ice->listener.next; il!=&tp_ice->listener; il=il->next) {\n        if (il->cb.on_new_candidate) {\n            (*il->cb.on_new_candidate)(&tp_ice->base, cand, last);\n        }\n    }\n}\n\n\n/* Simulate lost */\nstatic pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n                                           pjmedia_dir dir,\n                                           unsigned pct_lost)\n{\n    struct transport_ice *ice = (struct transport_ice*) tp;\n\n    PJ_ASSERT_RETURN(tp && pct_lost <= 100, PJ_EINVAL);\n\n    if (dir & PJMEDIA_DIR_ENCODING)\n        ice->tx_drop_pct = pct_lost;\n\n    if (dir & PJMEDIA_DIR_DECODING)\n        ice->rx_drop_pct = pct_lost;\n\n    return PJ_SUCCESS;\n}\n\nstatic void tp_ice_on_destroy(void *arg)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)arg;\n    pj_pool_safe_release(&tp_ice->pool);\n}\n\n/*\n * Destroy ICE media transport.\n */\nstatic pj_status_t transport_destroy(pjmedia_transport *tp)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n\n    /* Reset callback and user data */\n    pj_bzero(&tp_ice->cb, sizeof(tp_ice->cb));\n    tp_ice->base.user_data = NULL;\n    tp_ice->rtp_cb = NULL;\n    tp_ice->rtp_cb2 = NULL;\n    tp_ice->rtcp_cb = NULL;\n\n    if (tp_ice->ice_st) {\n        pj_grp_lock_t *grp_lock = pj_ice_strans_get_grp_lock(tp_ice->ice_st);\n        pj_ice_strans_destroy(tp_ice->ice_st);\n        tp_ice->ice_st = NULL;\n        pj_grp_lock_dec_ref(grp_lock);\n    } else {\n        tp_ice_on_destroy(tp);\n    }\n\n    return PJ_SUCCESS;\n}\n\n", "/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/transport_loop.h>\n#include <pj/array.h>\n#include <pj/assert.h>\n#include <pj/errno.h>\n#include <pj/ioqueue.h>\n#include <pj/log.h>\n#include <pj/pool.h>\n#include <pj/rand.h>\n#include <pj/string.h>\n\n\nstruct tp_user\n{\n    pj_bool_t           rx_disabled;    /**< Doesn't want to receive pkt?   */\n    void               *user_data;      /**< Only valid when attached       */\n    void  (*rtp_cb)(    void*,          /**< To report incoming RTP.        */\n                        void*,\n                        pj_ssize_t);\n    void  (*rtp_cb2)(   pjmedia_tp_cb_param*);\n    void  (*rtcp_cb)(   void*,          /**< To report incoming RTCP.       */\n                        void*,\n                        pj_ssize_t);\n};\n\nstruct transport_loop\n{\n    pjmedia_transport   base;           /**< Base transport.                */\n\n    pj_pool_t          *pool;           /**< Memory pool                    */\n    unsigned            max_attach_cnt; /**< Max number of attachments      */\n    unsigned            user_cnt;       /**< Number of attachments          */\n    struct tp_user     *users;          /**< Array of users.                */\n    pj_bool_t           disable_rx;     /**< Disable RX.                    */\n\n    pjmedia_loop_tp_setting setting;    /**< Setting.                       */\n\n    unsigned            tx_drop_pct;    /**< Percent of tx pkts to drop.    */\n    unsigned            rx_drop_pct;    /**< Percent of rx pkts to drop.    */\n\n};\n\n\n\n/*\n * These are media transport operations.\n */\nstatic pj_status_t transport_get_info (pjmedia_transport *tp,\n                                       pjmedia_transport_info *info);\nstatic pj_status_t transport_attach   (pjmedia_transport *tp,\n                                       void *user_data,\n                                       const pj_sockaddr_t *rem_addr,\n                                       const pj_sockaddr_t *rem_rtcp,\n                                       unsigned addr_len,\n                                       void (*rtp_cb)(void*,\n                                                      void*,\n                                                      pj_ssize_t),\n                                       void (*rtcp_cb)(void*,\n                                                       void*,\n                                                       pj_ssize_t));\nstatic pj_status_t transport_attach2  (pjmedia_transport *tp,\n                                       pjmedia_transport_attach_param\n                                           *att_param);\nstatic void        transport_detach   (pjmedia_transport *tp,\n                                       void *strm);\nstatic pj_status_t transport_send_rtp( pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_send_rtcp(pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_send_rtcp2(pjmedia_transport *tp,\n                                       const pj_sockaddr_t *addr,\n                                       unsigned addr_len,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_media_create(pjmedia_transport *tp,\n                                       pj_pool_t *pool,\n                                       unsigned options,\n                                       const pjmedia_sdp_session *sdp_remote,\n                                       unsigned media_index);\nstatic pj_status_t transport_encode_sdp(pjmedia_transport *tp,\n                                        pj_pool_t *pool,\n                                        pjmedia_sdp_session *sdp_local,\n                                        const pjmedia_sdp_session *rem_sdp,\n                                        unsigned media_index);\nstatic pj_status_t transport_media_start (pjmedia_transport *tp,\n                                       pj_pool_t *pool,\n                                       const pjmedia_sdp_session *sdp_local,\n                                       const pjmedia_sdp_session *sdp_remote,\n                                       unsigned media_index);\nstatic pj_status_t transport_media_stop(pjmedia_transport *tp);\nstatic pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n                                       pjmedia_dir dir,\n                                       unsigned pct_lost);\nstatic pj_status_t transport_destroy  (pjmedia_transport *tp);\n\n\nstatic pjmedia_transport_op transport_udp_op = \n{\n    &transport_get_info,\n    &transport_attach,\n    &transport_detach,\n    &transport_send_rtp,\n    &transport_send_rtcp,\n    &transport_send_rtcp2,\n    &transport_media_create,\n    &transport_encode_sdp,\n    &transport_media_start,\n    &transport_media_stop,\n    &transport_simulate_lost,\n    &transport_destroy,\n    &transport_attach2\n};\n\n\n/**\n * Initialize loopback media transport setting with its default values.\n */\nPJ_DEF(void) pjmedia_loop_tp_setting_default(pjmedia_loop_tp_setting *opt)\n{\n    pj_bzero(opt, sizeof(pjmedia_loop_tp_setting));\n    \n    opt->af = pj_AF_INET();\n    opt->max_attach_cnt = 4;\n}\n\n\n/**\n * Create loopback transport.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_loop_create(pjmedia_endpt *endpt,\n                                                  pjmedia_transport **p_tp)\n{\n    pjmedia_loop_tp_setting opt;\n\n    pjmedia_loop_tp_setting_default(&opt);\n\n    return pjmedia_transport_loop_create2(endpt, &opt, p_tp);\n}\n\n\nPJ_DEF(pj_status_t)\npjmedia_transport_loop_create2(pjmedia_endpt *endpt,\n                               const pjmedia_loop_tp_setting *opt,\n                               pjmedia_transport **p_tp)\n{\n    struct transport_loop *tp;\n    pj_pool_t *pool;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(endpt && p_tp, PJ_EINVAL);\n\n    /* Create transport structure */\n    pool = pjmedia_endpt_create_pool(endpt, \"tploop\", 512, 512);\n    if (!pool)\n        return PJ_ENOMEM;\n\n    tp = PJ_POOL_ZALLOC_T(pool, struct transport_loop);\n    tp->pool = pool;\n    pj_memcpy(tp->base.name, tp->pool->obj_name, PJ_MAX_OBJ_NAME);\n    tp->base.op = &transport_udp_op;\n    tp->base.type = PJMEDIA_TRANSPORT_TYPE_UDP;\n\n    if (opt) {\n        tp->setting = *opt;\n    } else {\n        pjmedia_loop_tp_setting_default(&tp->setting);\n    }\n    if (tp->setting.addr.slen) {\n        pj_strdup(pool, &tp->setting.addr, &opt->addr);\n    } else {\n        pj_strset2(&tp->setting.addr, (tp->setting.af == pj_AF_INET())?\n                                       \"127.0.0.1\": \"::1\");\n    }\n    if (tp->setting.port == 0)\n        tp->setting.port = 4000;\n\n    /* alloc users array */\n    tp->max_attach_cnt = tp->setting.max_attach_cnt;\n    if (tp->max_attach_cnt == 0)\n        tp->max_attach_cnt = 1;\n    tp->users = (struct tp_user *)pj_pool_calloc(pool, tp->max_attach_cnt, sizeof(struct tp_user));\n\n    /* Done */\n    *p_tp = &tp->base;\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_transport_loop_disable_rx( pjmedia_transport *tp,\n                                                       void *user,\n                                                       pj_bool_t disabled)\n{\n    struct transport_loop *loop = (struct transport_loop*) tp;\n    unsigned i;\n\n    for (i=0; i<loop->user_cnt; ++i) {\n        if (loop->users[i].user_data == user) {\n            loop->users[i].rx_disabled = disabled;\n            return PJ_SUCCESS;\n        }\n    }\n    pj_assert(!\"Invalid stream user\");\n    return PJ_ENOTFOUND;\n}\n\n/**\n * Close loopback transport.\n */\nstatic pj_status_t transport_destroy(pjmedia_transport *tp)\n{\n    struct transport_loop *loop = (struct transport_loop*) tp;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    pj_pool_release(loop->pool);\n\n    return PJ_SUCCESS;\n}\n\n\n/* Called to get the transport info */\nstatic pj_status_t transport_get_info(pjmedia_transport *tp,\n                                      pjmedia_transport_info *info)\n{\n    struct transport_loop *loop = (struct transport_loop*) tp;\n\n    info->sock_info.rtp_sock = 1;\n    pj_sockaddr_init(loop->setting.af, &info->sock_info.rtp_addr_name, \n                     &loop->setting.addr, (pj_uint16_t)loop->setting.port);\n    info->sock_info.rtcp_sock = 2;\n    pj_sockaddr_init(loop->setting.af, &info->sock_info.rtcp_addr_name,\n                     &loop->setting.addr, (pj_uint16_t)loop->setting.port + 1);\n\n    return PJ_SUCCESS;\n}\n\n\n/* Called by application to initialize the transport */\nstatic pj_status_t tp_attach(   pjmedia_transport *tp,\n                                       void *user_data,\n                                       const pj_sockaddr_t *rem_addr,\n                                       const pj_sockaddr_t *rem_rtcp,\n                                       unsigned addr_len,\n                                       void (*rtp_cb)(void*,\n                                                      void*,\n                                                      pj_ssize_t),\n                                       void (*rtp_cb2)(pjmedia_tp_cb_param*),\n                                       void (*rtcp_cb)(void*,\n                                                       void*,\n                                                       pj_ssize_t))\n{\n    struct transport_loop *loop = (struct transport_loop*) tp;\n    unsigned i;\n    const pj_sockaddr *rtcp_addr;\n\n    /* Validate arguments */\n    PJ_ASSERT_RETURN(tp && rem_addr && addr_len, PJ_EINVAL);\n\n    /* Must not be \"attached\" to same user */\n    for (i=0; i<loop->user_cnt; ++i) {\n        PJ_ASSERT_RETURN(loop->users[i].user_data != user_data,\n                         PJ_EINVALIDOP);\n    }\n    PJ_ASSERT_RETURN(loop->user_cnt != loop->max_attach_cnt, PJ_ETOOMANY);\n\n    PJ_UNUSED_ARG(rem_rtcp);\n    PJ_UNUSED_ARG(rtcp_addr);\n\n    /* \"Attach\" the application: */\n\n    /* Save the new user */\n    loop->users[loop->user_cnt].rtp_cb = rtp_cb;\n    loop->users[loop->user_cnt].rtp_cb2 = rtp_cb2;\n    loop->users[loop->user_cnt].rtcp_cb = rtcp_cb;\n    loop->users[loop->user_cnt].user_data = user_data;\n    loop->users[loop->user_cnt].rx_disabled = loop->disable_rx;\n    ++loop->user_cnt;\n\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t transport_attach(   pjmedia_transport *tp,\n                                       void *user_data,\n                                       const pj_sockaddr_t *rem_addr,\n                                       const pj_sockaddr_t *rem_rtcp,\n                                       unsigned addr_len,\n                                       void (*rtp_cb)(void*,\n                                                      void*,\n                                                      pj_ssize_t),\n                                       void (*rtcp_cb)(void*,\n                                                       void*,\n                                                       pj_ssize_t))\n{\n    return tp_attach(tp, user_data, rem_addr, rem_rtcp, addr_len,\n                     rtp_cb, NULL, rtcp_cb);\n}\n\nstatic pj_status_t transport_attach2(pjmedia_transport *tp,\n                                     pjmedia_transport_attach_param *att_param)\n{\n    return tp_attach(tp, att_param->user_data, \n                            (pj_sockaddr_t*)&att_param->rem_addr, \n                            (pj_sockaddr_t*)&att_param->rem_rtcp, \n                            att_param->addr_len, att_param->rtp_cb,\n                            att_param->rtp_cb2, \n                            att_param->rtcp_cb);\n}\n\n\n/* Called by application when it no longer needs the transport */\nstatic void transport_detach( pjmedia_transport *tp,\n                              void *user_data)\n{\n    struct transport_loop *loop = (struct transport_loop*) tp;\n    unsigned i;\n\n    pj_assert(tp);\n\n    for (i=0; i<loop->user_cnt; ++i) {\n        if (loop->users[i].user_data == user_data)\n            break;\n    }\n\n    /* Remove this user */\n    if (i != loop->user_cnt) {\n        pj_array_erase(loop->users, sizeof(loop->users[0]),\n                       loop->user_cnt, i);\n        --loop->user_cnt;\n    }\n}\n\n\n/* Called by application to send RTP packet */\nstatic pj_status_t transport_send_rtp( pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size)\n{\n    struct transport_loop *loop = (struct transport_loop*)tp;\n    unsigned i;\n\n    /* Simulate packet lost on TX direction */\n    if (loop->tx_drop_pct) {\n        if ((pj_rand() % 100) <= (int)loop->tx_drop_pct) {\n            PJ_LOG(5,(loop->base.name, \n                      \"TX RTP packet dropped because of pkt lost \"\n                      \"simulation\"));\n            return PJ_SUCCESS;\n        }\n    }\n\n    /* Simulate packet lost on RX direction */\n    if (loop->rx_drop_pct) {\n        if ((pj_rand() % 100) <= (int)loop->rx_drop_pct) {\n            PJ_LOG(5,(loop->base.name, \n                      \"RX RTP packet dropped because of pkt lost \"\n                      \"simulation\"));\n            return PJ_SUCCESS;\n        }\n    }\n\n    /* Distribute to users */\n    for (i=0; i<loop->user_cnt; ++i) {\n        if (loop->users[i].rx_disabled) continue;\n        if (loop->users[i].rtp_cb2) {\n            pjmedia_tp_cb_param param;\n\n            pj_bzero(&param, sizeof(param));\n            param.user_data = loop->users[i].user_data;\n            param.pkt = (void *)pkt;\n            param.size = size;\n            (*loop->users[i].rtp_cb2)(&param);\n        } else if (loop->users[i].rtp_cb) {\n            (*loop->users[i].rtp_cb)(loop->users[i].user_data, (void*)pkt, \n                                     size);\n        }\n    }\n\n    return PJ_SUCCESS;\n}\n\n/* Called by application to send RTCP packet */\nstatic pj_status_t transport_send_rtcp(pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size)\n{\n    return transport_send_rtcp2(tp, NULL, 0, pkt, size);\n}\n\n\n/* Called by application to send RTCP packet */\nstatic pj_status_t transport_send_rtcp2(pjmedia_transport *tp,\n                                        const pj_sockaddr_t *addr,\n                                        unsigned addr_len,\n                                        const void *pkt,\n                                        pj_size_t size)\n{\n    struct transport_loop *loop = (struct transport_loop*)tp;\n    unsigned i;\n\n    PJ_UNUSED_ARG(addr_len);\n    PJ_UNUSED_ARG(addr);\n\n    /* Distribute to users */\n    for (i=0; i<loop->user_cnt; ++i) {\n        if (!loop->users[i].rx_disabled && loop->users[i].rtcp_cb)\n            (*loop->users[i].rtcp_cb)(loop->users[i].user_data, (void*)pkt,\n                                      size);\n    }\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t transport_media_create(pjmedia_transport *tp,\n                                  pj_pool_t *pool,\n                                  unsigned options,\n                                  const pjmedia_sdp_session *sdp_remote,\n                                  unsigned media_index)\n{\n    PJ_UNUSED_ARG(tp);\n    PJ_UNUSED_ARG(pool);\n    PJ_UNUSED_ARG(options);\n    PJ_UNUSED_ARG(sdp_remote);\n    PJ_UNUSED_ARG(media_index);\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t transport_encode_sdp(pjmedia_transport *tp,\n                                        pj_pool_t *pool,\n                                        pjmedia_sdp_session *sdp_local,\n                                        const pjmedia_sdp_session *rem_sdp,\n                                        unsigned media_index)\n{\n    PJ_UNUSED_ARG(tp);\n    PJ_UNUSED_ARG(pool);\n    PJ_UNUSED_ARG(sdp_local);\n    PJ_UNUSED_ARG(rem_sdp);\n    PJ_UNUSED_ARG(media_index);\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t transport_media_start(pjmedia_transport *tp,\n                                  pj_pool_t *pool,\n                                  const pjmedia_sdp_session *sdp_local,\n                                  const pjmedia_sdp_session *sdp_remote,\n                                  unsigned media_index)\n{\n    PJ_UNUSED_ARG(tp);\n    PJ_UNUSED_ARG(pool);\n    PJ_UNUSED_ARG(sdp_local);\n    PJ_UNUSED_ARG(sdp_remote);\n    PJ_UNUSED_ARG(media_index);\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t transport_media_stop(pjmedia_transport *tp)\n{\n    PJ_UNUSED_ARG(tp);\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n                                           pjmedia_dir dir,\n                                           unsigned pct_lost)\n{\n    struct transport_loop *loop = (struct transport_loop*)tp;\n\n    PJ_ASSERT_RETURN(tp && pct_lost <= 100, PJ_EINVAL);\n\n    if (dir & PJMEDIA_DIR_ENCODING)\n        loop->tx_drop_pct = pct_lost;\n    \n    if (dir & PJMEDIA_DIR_DECODING)\n        loop->rx_drop_pct = pct_lost;\n\n    return PJ_SUCCESS;\n}\n\n", "/*\n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n */\n\n#include <pjmedia/transport_srtp.h>\n#include <pjmedia/endpoint.h>\n#include <pjmedia/rtp.h>\n#include <pjlib-util/base64.h>\n#include <pj/array.h>\n#include <pj/assert.h>\n#include <pj/ctype.h>\n#include <pj/lock.h>\n#include <pj/log.h>\n#include <pj/os.h>\n#include <pj/pool.h>\n\n#if defined(PJMEDIA_HAS_SRTP) && (PJMEDIA_HAS_SRTP != 0)\n\n/* Enable this to test ROC initialization setting. For offerer,\n * it will send packets with ROC 1 and expect to receive ROC 2.\n * For answerer it will be the other way around.\n */\n#define TEST_ROC 0\n\n#if defined(PJ_HAS_SSL_SOCK) && PJ_HAS_SSL_SOCK != 0 && \\\n    (PJ_SSL_SOCK_IMP == PJ_SSL_SOCK_IMP_OPENSSL)\n#  include <openssl/rand.h>\n#  include <openssl/opensslv.h>\n\n/* Suppress compile warning of OpenSSL deprecation (OpenSSL is deprecated\n * since MacOSX 10.7).\n */\n#if defined(PJ_DARWINOS) && PJ_DARWINOS==1\n#  pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n#endif\n\n#endif\n\n#if defined(PJMEDIA_EXTERNAL_SRTP)\n\n#if (PJMEDIA_EXTERNAL_SRTP == 1)        /* External SRTP 1.x */\n#  include <srtp/srtp.h>\n#  include <srtp/crypto_kernel.h>\n#define srtp_crypto_policy_t            crypto_policy_t\n#define srtp_cipher_type_id_t           cipher_type_id_t\n#define srtp_cipher_type_t              cipher_type_t\n#define srtp_auth_type_id_t             auth_type_id_t\n#define srtp_sec_serv_t                 sec_serv_t\n#define srtp_err_status_t               err_status_t\n#define srtp_err_status_ok              err_status_ok\n#define srtp_err_status_replay_old      err_status_replay_old\n#define srtp_err_status_replay_fail     err_status_replay_fail\n#define srtp_crypto_policy_set_aes_cm_256_hmac_sha1_32 \\\n             crypto_policy_set_aes_cm_256_hmac_sha1_32\n#define srtp_crypto_policy_set_aes_cm_256_hmac_sha1_80 \\\n             crypto_policy_set_aes_cm_256_hmac_sha1_80\n#define SRTP_NULL_CIPHER                NULL_CIPHER\n#define SRTP_NULL_AUTH                  NULL_AUTH\n#define SRTP_AES_ICM_128                AES_ICM\n#define SRTP_AES_ICM_192                AES_ICM\n#define SRTP_AES_ICM_256                AES_ICM\n#define SRTP_AES_GCM_128                AES_128_GCM\n#define SRTP_AES_GCM_256                AES_256_GCM\n#define SRTP_HMAC_SHA1                  HMAC_SHA1\n#define srtp_aes_gcm_256_openssl        aes_gcm_256_openssl\n#define srtp_aes_gcm_128_openssl        aes_gcm_128_openssl\n\n#else                                   /* External SRTP 2.x */\n#  include <srtp2/srtp.h>\n#  include <srtp2/cipher.h>\n\n/* In libsrtp 2.0.0, the macro SRTP_AES_ICM_128 is not available. \n * Instead it was named with ICM at the end: SRTP_AES_128_ICM. \n */\n#  ifdef SRTP_AES_128_ICM\n#    define SRTP_AES_ICM_128            SRTP_AES_128_ICM\n#    define SRTP_AES_ICM_192            SRTP_AES_192_ICM\n#    define SRTP_AES_ICM_256            SRTP_AES_256_ICM\n#    define SRTP_AES_GCM_128            SRTP_AES_128_GCM\n#    define SRTP_AES_GCM_256            SRTP_AES_256_GCM\n#  endif\n\n#endif\n\n#else                                   /* Bundled SRTP */\n\n#  include <srtp_config.h>\n#  include <srtp.h>\n#  include <crypto_kernel.h>\n\n#define srtp_aes_gcm_256_openssl        srtp_aes_gcm_256\n#define srtp_aes_gcm_128_openssl        srtp_aes_gcm_128\n\n#endif\n\n#define THIS_FILE   \"transport_srtp.c\"\n\n/* Maximum size of outgoing packet */\n#define MAX_RTP_BUFFER_LEN          PJMEDIA_MAX_MTU\n#define MAX_RTCP_BUFFER_LEN         PJMEDIA_MAX_MTU\n\n/* Maximum SRTP crypto key length */\n#define MAX_KEY_LEN                 128\n\n/* Initial value of probation counter. When probation counter > 0,\n * it means SRTP is in probation state, and it may restart when\n * srtp_unprotect() returns err_status_replay_*\n */\n#define PROBATION_CNT_INIT          100\n\n#define DEACTIVATE_MEDIA(pool, m)   pjmedia_sdp_media_deactivate(pool, m)\n\n#ifdef SRTP_MAX_TRAILER_LEN\n#   define MAX_TRAILER_LEN SRTP_MAX_TRAILER_LEN\n#else\n#   define MAX_TRAILER_LEN 10\n#endif\n\n/* Maximum number of SRTP keying method */\n#define MAX_KEYING                  2\n\nstatic const pj_str_t ID_RTP_AVP  = { \"RTP/AVP\", 7 };\nstatic const pj_str_t ID_RTP_SAVP = { \"RTP/SAVP\", 8 };\n// static const pj_str_t ID_INACTIVE = { \"inactive\", 8 };\nstatic const pj_str_t ID_CRYPTO   = { \"crypto\", 6 };\n\ntypedef void (*crypto_method_t)(srtp_crypto_policy_t *policy);\n\ntypedef struct crypto_suite\n{\n    char                *name;\n    srtp_cipher_type_id_t cipher_type;\n    unsigned             cipher_key_len;    /* key + salt length    */\n    unsigned             cipher_salt_len;   /* salt only length     */\n    srtp_auth_type_id_t  auth_type;\n    unsigned             auth_key_len;\n    unsigned             srtp_auth_tag_len;\n    unsigned             srtcp_auth_tag_len;\n    srtp_sec_serv_t      service;\n    /* This is an attempt to validate crypto support by libsrtp, i.e: it should\n     * raise linking error if the libsrtp does not support the crypto. \n     */\n    srtp_cipher_type_t  *ext_cipher_type;\n    crypto_method_t      ext_crypto_method;\n} crypto_suite;\n\nextern srtp_cipher_type_t srtp_aes_gcm_256_openssl;\nextern srtp_cipher_type_t srtp_aes_gcm_128_openssl;\nextern srtp_cipher_type_t srtp_aes_icm_192;\n\n/* https://www.iana.org/assignments/sdp-security-descriptions/sdp-security-descriptions.xhtml */\nstatic crypto_suite crypto_suites[] = {\n    /* plain RTP/RTCP (no cipher & no auth) */\n    {\"NULL\", SRTP_NULL_CIPHER, 0, SRTP_NULL_AUTH, 0, 0, 0, sec_serv_none},\n\n#if defined(PJMEDIA_SRTP_HAS_AES_GCM_256)&&(PJMEDIA_SRTP_HAS_AES_GCM_256!=0)\n\n    /* cipher AES_GCM, NULL auth, auth tag len = 16 octets */\n    {\"AEAD_AES_256_GCM\", SRTP_AES_GCM_256, 44, 12,\n        SRTP_NULL_AUTH, 0, 16, 16, sec_serv_conf_and_auth,\n        &srtp_aes_gcm_256_openssl},\n\n    /* cipher AES_GCM, NULL auth, auth tag len = 8 octets */\n    {\"AEAD_AES_256_GCM_8\", SRTP_AES_GCM_256, 44, 12,\n        SRTP_NULL_AUTH, 0, 8, 8, sec_serv_conf_and_auth,\n        &srtp_aes_gcm_256_openssl},\n#endif\n#if defined(PJMEDIA_SRTP_HAS_AES_CM_256)&&(PJMEDIA_SRTP_HAS_AES_CM_256!=0)\n\n    /* cipher AES_CM_256, auth SRTP_HMAC_SHA1, auth tag len = 10 octets */\n    {\"AES_256_CM_HMAC_SHA1_80\", SRTP_AES_ICM_256, 46, 14,\n        SRTP_HMAC_SHA1, 20, 10, 10, sec_serv_conf_and_auth,\n        NULL, &srtp_crypto_policy_set_aes_cm_256_hmac_sha1_80},\n\n    /* cipher AES_CM_256, auth SRTP_HMAC_SHA1, auth tag len = 10 octets */\n    {\"AES_256_CM_HMAC_SHA1_32\", SRTP_AES_ICM_256, 46, 14,\n        SRTP_HMAC_SHA1, 20, 4, 10, sec_serv_conf_and_auth,\n        NULL, &srtp_crypto_policy_set_aes_cm_256_hmac_sha1_32},\n#endif\n#if defined(PJMEDIA_SRTP_HAS_AES_CM_192)&&(PJMEDIA_SRTP_HAS_AES_CM_192!=0)\n\n    /* cipher AES_CM_192, auth SRTP_HMAC_SHA1, auth tag len = 10 octets */\n    {\"AES_192_CM_HMAC_SHA1_80\", SRTP_AES_ICM_192, 38, 14,\n        SRTP_HMAC_SHA1, 20, 10, 10, sec_serv_conf_and_auth,\n        &srtp_aes_icm_192},\n\n    /* cipher AES_CM_192, auth SRTP_HMAC_SHA1, auth tag len = 4 octets */\n    {\"AES_192_CM_HMAC_SHA1_32\", SRTP_AES_ICM_192, 38, 14,\n        SRTP_HMAC_SHA1, 20, 4, 10, sec_serv_conf_and_auth,\n        &srtp_aes_icm_192},\n#endif\n#if defined(PJMEDIA_SRTP_HAS_AES_GCM_128)&&(PJMEDIA_SRTP_HAS_AES_GCM_128!=0)\n\n    /* cipher AES_GCM, NULL auth, auth tag len = 16 octets */\n    {\"AEAD_AES_128_GCM\", SRTP_AES_GCM_128, 28, 12,\n        SRTP_NULL_AUTH, 0, 16, 16, sec_serv_conf_and_auth,\n        &srtp_aes_gcm_128_openssl},\n\n    /* cipher AES_GCM, NULL auth, auth tag len = 8 octets */\n    {\"AEAD_AES_128_GCM_8\", SRTP_AES_GCM_128, 28, 12,\n        SRTP_NULL_AUTH, 0, 8, 8, sec_serv_conf_and_auth,\n        &srtp_aes_gcm_128_openssl},\n#endif\n#if defined(PJMEDIA_SRTP_HAS_AES_CM_128)&&(PJMEDIA_SRTP_HAS_AES_CM_128!=0)\n\n    /* cipher AES_CM_128, auth SRTP_HMAC_SHA1, auth tag len = 10 octets */\n    {\"AES_CM_128_HMAC_SHA1_80\", SRTP_AES_ICM_128, 30, 14,\n        SRTP_HMAC_SHA1, 20, 10, 10, sec_serv_conf_and_auth},\n\n    /* cipher AES_CM_128, auth SRTP_HMAC_SHA1, auth tag len = 4 octets */\n    {\"AES_CM_128_HMAC_SHA1_32\", SRTP_AES_ICM_128, 30, 14,\n        SRTP_HMAC_SHA1, 20, 4, 10, sec_serv_conf_and_auth},\n#endif\n\n    /*\n     * F8_128_HMAC_SHA1_8 not supported by libsrtp?\n     * {\"F8_128_HMAC_SHA1_8\", NULL_CIPHER, 0, 0, NULL_AUTH, 0, 0, 0,\n     *  sec_serv_none}\n     */\n};\n\ntypedef struct srtp_context\n{\n    /* SRTP policy */\n    char                 tx_key[MAX_KEY_LEN];\n    char                 rx_key[MAX_KEY_LEN];\n    pjmedia_srtp_crypto  tx_policy;\n    pjmedia_srtp_crypto  rx_policy;\n\n    /* Temporary policy for negotiation */\n    pjmedia_srtp_crypto  tx_policy_neg;\n    pjmedia_srtp_crypto  rx_policy_neg;\n\n    /* libSRTP contexts */\n    srtp_t               srtp_tx_ctx;\n    srtp_t               srtp_rx_ctx;\n} srtp_context;\n\n/* SRTP transport */\ntypedef struct transport_srtp\n{\n    pjmedia_transport    base;              /**< Base transport interface.  */\n    pj_pool_t           *pool;              /**< Pool for transport SRTP.   */\n    pj_lock_t           *mutex;             /**< Mutex for libsrtp contexts.*/\n    char                 rtp_tx_buffer[MAX_RTP_BUFFER_LEN];\n    char                 rtcp_tx_buffer[MAX_RTCP_BUFFER_LEN];\n    pjmedia_srtp_setting setting;\n    unsigned             media_option;\n    pj_bool_t            use_rtcp_mux;      /**< Use RTP& RTCP multiplexing?*/\n\n    pj_bool_t            session_inited;\n    pj_bool_t            offerer_side;\n    pj_bool_t            bypass_srtp;\n\n    /* SRTP contexts */\n    srtp_context         srtp_ctx;\n    srtp_context         srtp_rtcp;         /**< Separate context for RTCP,\n                                                 if needed, such as for DTLS*/\n\n    /* Stream information */\n    void                *user_data;\n    void                (*rtp_cb)( void *user_data,\n                                   void *pkt,\n                                   pj_ssize_t size);\n    void                (*rtp_cb2)(pjmedia_tp_cb_param*);\n    void                (*rtcp_cb)(void *user_data,\n                                   void *pkt,\n                                   pj_ssize_t size);\n\n    /* Transport information */\n    pjmedia_transport   *member_tp; /**< Underlying transport.       */\n    pj_bool_t            member_tp_attached;\n    pj_bool_t            started;\n\n    /* SRTP usage policy of peer. This field is updated when media is starting.\n     * This is useful when SRTP is in optional mode and peer is using mandatory\n     * mode, so when local is about to reinvite/update, it should offer\n     * RTP/SAVP instead of offering RTP/AVP.\n     */\n    pjmedia_srtp_use     peer_use;\n\n    /* When probation counter > 0, it means SRTP is in probation state,\n     * and it may restart when srtp_unprotect() returns err_status_replay_*\n     */\n    unsigned             probation_cnt;\n\n    /* SRTP keying methods. The keying is implemented using media transport\n     * abstraction, so it will also be invoked when the SRTP media transport\n     * operation is invoked.\n     *\n     * As there can be multiple keying methods enabled (currently only SDES &\n     * DTLS-SRTP), each keying method will be given the chance to respond to\n     * remote SDP. If any keying operation returns non-success, it will be\n     * removed from the session. And once SRTP key is obtained via a keying\n     * method, any other keying methods will be stopped and destroyed.\n     */\n    unsigned             all_keying_cnt;\n    pjmedia_transport   *all_keying[MAX_KEYING];\n\n    /* Current active SRTP keying methods. */\n    unsigned             keying_cnt;\n    pjmedia_transport   *keying[MAX_KEYING];\n\n    /* If not zero, keying nego is ongoing (async-ly, e.g: by DTLS-SRTP).\n     * This field may be updated by keying method.\n     */\n    unsigned             keying_pending_cnt;\n\n    /* RTP SSRC in receiving direction, used in getting and setting SRTP\n     * roll over counter (ROC) on SRTP restart.\n     */\n    pj_uint32_t          rx_ssrc;\n\n    pj_uint32_t          tx_ssrc;\n\n} transport_srtp;\n\n\n/*\n * This callback is called by transport when incoming rtp is received\n */\nstatic void srtp_rtp_cb(pjmedia_tp_cb_param *param);\n\n/*\n * This callback is called by transport when incoming rtcp is received\n */\nstatic void srtp_rtcp_cb( void *user_data, void *pkt, pj_ssize_t size);\n\n\n/*\n * These are media transport operations.\n */\nstatic pj_status_t transport_get_info (pjmedia_transport *tp,\n                                       pjmedia_transport_info *info);\n//static pj_status_t transport_attach   (pjmedia_transport *tp,\n//                                     void *user_data,\n//                                     const pj_sockaddr_t *rem_addr,\n//                                     const pj_sockaddr_t *rem_rtcp,\n//                                     unsigned addr_len,\n//                                     void (*rtp_cb)(void*,\n//                                                    void*,\n//                                                    pj_ssize_t),\n//                                     void (*rtcp_cb)(void*,\n//                                                     void*,\n//                                                     pj_ssize_t));\nstatic void        transport_detach   (pjmedia_transport *tp,\n                                       void *strm);\nstatic pj_status_t transport_send_rtp( pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_send_rtcp(pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_send_rtcp2(pjmedia_transport *tp,\n                                       const pj_sockaddr_t *addr,\n                                       unsigned addr_len,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_media_create(pjmedia_transport *tp,\n                                       pj_pool_t *sdp_pool,\n                                       unsigned options,\n                                       const pjmedia_sdp_session *sdp_remote,\n                                       unsigned media_index);\nstatic pj_status_t transport_encode_sdp(pjmedia_transport *tp,\n                                       pj_pool_t *sdp_pool,\n                                       pjmedia_sdp_session *sdp_local,\n                                       const pjmedia_sdp_session *sdp_remote,\n                                       unsigned media_index);\nstatic pj_status_t transport_media_start (pjmedia_transport *tp,\n                                       pj_pool_t *pool,\n                                       const pjmedia_sdp_session *sdp_local,\n                                       const pjmedia_sdp_session *sdp_remote,\n                                       unsigned media_index);\nstatic pj_status_t transport_media_stop(pjmedia_transport *tp);\nstatic pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n                                       pjmedia_dir dir,\n                                       unsigned pct_lost);\nstatic pj_status_t transport_destroy  (pjmedia_transport *tp);\nstatic pj_status_t transport_attach2  (pjmedia_transport *tp,\n                                       pjmedia_transport_attach_param *param);\n\n\n\nstatic pjmedia_transport_op transport_srtp_op =\n{\n    &transport_get_info,\n    NULL, //&transport_attach,\n    &transport_detach,\n    &transport_send_rtp,\n    &transport_send_rtcp,\n    &transport_send_rtcp2,\n    &transport_media_create,\n    &transport_encode_sdp,\n    &transport_media_start,\n    &transport_media_stop,\n    &transport_simulate_lost,\n    &transport_destroy,\n    &transport_attach2\n};\n\n/* Get crypto index from crypto name */\nstatic int get_crypto_idx(const pj_str_t* crypto_name);\n\n/* Is crypto empty (i.e: no name or key)? */\nstatic pj_bool_t srtp_crypto_empty(const pjmedia_srtp_crypto* c);\n\n/* Compare crypto, return zero if same */\nstatic int srtp_crypto_cmp(const pjmedia_srtp_crypto* c1,\n                           const pjmedia_srtp_crypto* c2);\n\n/* Start SRTP */\nstatic pj_status_t start_srtp(transport_srtp *srtp);\n/* Create SRTP context */\nstatic pj_status_t create_srtp_ctx(transport_srtp *srtp,\n                                   srtp_context *ctx,\n                                   const pjmedia_srtp_setting *setting,\n                                   const pjmedia_srtp_crypto *tx,\n                                   const pjmedia_srtp_crypto *rx);\n/* Destroy SRTP context */\nstatic void destroy_srtp_ctx(transport_srtp *p_srtp, srtp_context *ctx);\n\n\n/* This function may also be used by other module, e.g: pjmedia/errno.c,\n * it should have C compatible declaration.\n */\nPJ_BEGIN_DECL\n    const char* get_libsrtp_errstr(int err);\nPJ_END_DECL\n\nconst char* get_libsrtp_errstr(int err)\n{\n#if defined(PJ_HAS_ERROR_STRING) && (PJ_HAS_ERROR_STRING != 0)\n    static char *liberr[] = {\n        \"ok\",                               /* srtp_err_status_ok       = 0  */\n        \"unspecified failure\",              /* err_status_fail          = 1  */\n        \"unsupported parameter\",            /* err_status_bad_param     = 2  */\n        \"couldn't allocate memory\",         /* err_status_alloc_fail    = 3  */\n        \"couldn't deallocate properly\",     /* err_status_dealloc_fail  = 4  */\n        \"couldn't initialize\",              /* err_status_init_fail     = 5  */\n        \"can't process as much data as requested\",\n                                            /* err_status_terminus      = 6  */\n        \"authentication failure\",           /* err_status_auth_fail     = 7  */\n        \"cipher failure\",                   /* err_status_cipher_fail   = 8  */\n        \"replay check failed (bad index)\",  /* err_status_replay_fail   = 9  */\n        \"replay check failed (index too old)\",\n                                            /* err_status_replay_old    = 10 */\n        \"algorithm failed test routine\",    /* err_status_algo_fail     = 11 */\n        \"unsupported operation\",            /* err_status_no_such_op    = 12 */\n        \"no appropriate context found\",     /* err_status_no_ctx        = 13 */\n        \"unable to perform desired validation\",\n                                            /* err_status_cant_check    = 14 */\n        \"can't use key any more\",           /* err_status_key_expired   = 15 */\n        \"error in use of socket\",           /* err_status_socket_err    = 16 */\n        \"error in use POSIX signals\",       /* err_status_signal_err    = 17 */\n        \"nonce check failed\",               /* err_status_nonce_bad     = 18 */\n        \"couldn't read data\",               /* err_status_read_fail     = 19 */\n        \"couldn't write data\",              /* err_status_write_fail    = 20 */\n        \"error pasring data\",               /* err_status_parse_err     = 21 */\n        \"error encoding data\",              /* err_status_encode_err    = 22 */\n        \"error while using semaphores\",     /* err_status_semaphore_err = 23 */\n        \"error while using pfkey\"           /* err_status_pfkey_err     = 24 */\n    };\n    if (err >= 0 && err < (int)PJ_ARRAY_SIZE(liberr)) {\n        return liberr[err];\n    } else {\n        static char msg[32];\n        pj_ansi_snprintf(msg, sizeof(msg), \"Unknown libsrtp error %d\", err);\n        return msg;\n    }\n#else\n    static char msg[32];\n    pj_ansi_snprintf(msg, sizeof(msg), \"libsrtp error %d\", err);\n    return msg;\n#endif\n}\n\n/* SRTP keying method: Session Description */\n#if defined(PJMEDIA_SRTP_HAS_SDES) && (PJMEDIA_SRTP_HAS_SDES != 0)\n#  include \"transport_srtp_sdes.c\"\n#endif\n\n/* SRTP keying method: DTLS */\n#if defined(PJMEDIA_SRTP_HAS_DTLS) && (PJMEDIA_SRTP_HAS_DTLS != 0)\n#  include \"transport_srtp_dtls.c\"\n#else\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_dtls_start_nego(\n                                pjmedia_transport *srtp,\n                                const pjmedia_srtp_dtls_nego_param *param)\n{\n    PJ_UNUSED_ARG(srtp);\n    PJ_UNUSED_ARG(param);\n    return PJ_ENOTSUP;\n}\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_dtls_get_fingerprint(\n                                pjmedia_transport *srtp,\n                                const char *hash,\n                                char *buf, pj_size_t *len)\n{\n    PJ_UNUSED_ARG(srtp);\n    PJ_UNUSED_ARG(hash);\n    PJ_UNUSED_ARG(buf);\n    PJ_UNUSED_ARG(len);\n    return PJ_ENOTSUP;\n}\n#endif\n\n\nstatic pj_bool_t libsrtp_initialized;\nstatic void pjmedia_srtp_deinit_lib(pjmedia_endpt *endpt);\n\nPJ_DEF(pj_status_t) pjmedia_srtp_init_lib(pjmedia_endpt *endpt)\n{\n    pj_status_t status = PJ_SUCCESS;\n\n    if (libsrtp_initialized)\n        return PJ_SUCCESS;\n\n#if PJMEDIA_LIBSRTP_AUTO_INIT_DEINIT\n    /* Init libsrtp */\n    {\n        srtp_err_status_t err;\n\n        err = srtp_init();\n        if (err != srtp_err_status_ok) {\n            PJ_LOG(4, (THIS_FILE, \"Failed to initialize libsrtp: %s\",\n                       get_libsrtp_errstr(err)));\n            pjmedia_srtp_deinit_lib(endpt);\n            return PJMEDIA_ERRNO_FROM_LIBSRTP(err);\n        }\n    }\n#endif\n\n#if defined(PJMEDIA_SRTP_HAS_DTLS) && (PJMEDIA_SRTP_HAS_DTLS != 0)\n    dtls_init();\n#endif\n\n    status = pjmedia_endpt_atexit(endpt, pjmedia_srtp_deinit_lib);\n    if (status != PJ_SUCCESS) {\n        /* There will be memory leak when it fails to schedule libsrtp\n         * deinitialization, however the memory leak could be harmless,\n         * since in modern OS's memory used by an application is released\n         * when the application terminates.\n         */\n        PJ_PERROR(4, (THIS_FILE, status,\n                      \"Failed to register libsrtp deinit.\"));\n\n        /* Ignore this error */\n        status = PJ_SUCCESS;\n    }\n\n    libsrtp_initialized = PJ_TRUE;\n\n    return status;\n}\n\nstatic void pjmedia_srtp_deinit_lib(pjmedia_endpt *endpt)\n{\n    srtp_err_status_t err;\n\n    /* Note that currently this SRTP init/deinit is not equipped with\n     * reference counter, it should be safe as normally there is only\n     * one single instance of media endpoint and even if it isn't, the\n     * pjmedia_transport_srtp_create() will invoke SRTP init (the only\n     * drawback should be the delay described by #788).\n     */\n\n    PJ_UNUSED_ARG(endpt);\n\n#if !defined(PJMEDIA_SRTP_HAS_DEINIT) && !defined(PJMEDIA_SRTP_HAS_SHUTDOWN)\n# define PJMEDIA_SRTP_HAS_SHUTDOWN 1\n#endif\n\n#if PJMEDIA_LIBSRTP_AUTO_INIT_DEINIT\n\n# if defined(PJMEDIA_SRTP_HAS_DEINIT) && PJMEDIA_SRTP_HAS_DEINIT!=0\n    err = srtp_deinit();\n# elif defined(PJMEDIA_SRTP_HAS_SHUTDOWN) && PJMEDIA_SRTP_HAS_SHUTDOWN!=0\n    err = srtp_shutdown();\n# else\n    err = srtp_err_status_ok;\n# endif\n    if (err != srtp_err_status_ok) {\n        PJ_LOG(4, (THIS_FILE, \"Failed to deinitialize libsrtp: %s\",\n                   get_libsrtp_errstr(err)));\n    }\n#endif // PJMEDIA_LIBSRTP_AUTO_INIT_DEINIT\n\n#if defined(PJMEDIA_SRTP_HAS_DTLS) && (PJMEDIA_SRTP_HAS_DTLS != 0)\n    dtls_deinit();\n#endif\n\n    libsrtp_initialized = PJ_FALSE;\n}\n\n\nstatic int get_crypto_idx(const pj_str_t* crypto_name)\n{\n    int i;\n    int cs_cnt = PJ_ARRAY_SIZE(crypto_suites);\n\n    /* treat unspecified crypto_name as crypto 'NULL' */\n    if (crypto_name->slen == 0)\n        return 0;\n\n    for (i=0; i<cs_cnt; ++i) {\n        if (!pj_stricmp2(crypto_name, crypto_suites[i].name))\n            return i;\n    }\n\n    return -1;\n}\n\n\nstatic int srtp_crypto_cmp(const pjmedia_srtp_crypto* c1,\n                           const pjmedia_srtp_crypto* c2)\n{\n    int r;\n\n    r = pj_strcmp(&c1->key, &c2->key);\n    if (r != 0)\n        return r;\n\n    r = pj_stricmp(&c1->name, &c2->name);\n    if (r != 0)\n        return r;\n\n    return (c1->flags != c2->flags);\n}\n\n\nstatic pj_bool_t srtp_crypto_empty(const pjmedia_srtp_crypto* c)\n{\n    return (c->name.slen==0 || c->key.slen==0);\n}\n\n\nPJ_DEF(void) pjmedia_srtp_setting_default(pjmedia_srtp_setting *opt)\n{\n    pj_assert(opt);\n\n    pj_bzero(opt, sizeof(pjmedia_srtp_setting));\n    opt->close_member_tp = PJ_TRUE;\n    opt->use = PJMEDIA_SRTP_OPTIONAL;\n}\n\n/*\n * Enumerate all SRTP cryptos, except \"NULL\".\n */\nPJ_DEF(pj_status_t) pjmedia_srtp_enum_crypto(unsigned *count,\n                                             pjmedia_srtp_crypto crypto[])\n{\n    unsigned i, max;\n\n    PJ_ASSERT_RETURN(count && crypto, PJ_EINVAL);\n\n    max = PJ_ARRAY_SIZE(crypto_suites) - 1;\n    if (*count > max)\n        *count = max;\n\n    for (i=0; i<*count; ++i) {\n        pj_bzero(&crypto[i], sizeof(crypto[0]));\n        crypto[i].name = pj_str(crypto_suites[i+1].name);\n    }\n    \n    return PJ_SUCCESS;\n}\n\n\n/*\n * Enumerate available SRTP keying methods.\n */\nPJ_DEF(pj_status_t) pjmedia_srtp_enum_keying(unsigned *count,\n                                      pjmedia_srtp_keying_method keying[])\n{\n    unsigned max;\n\n    PJ_ASSERT_RETURN(count && keying, PJ_EINVAL);\n\n    max = *count;\n    *count = 0;\n\n#if defined(PJMEDIA_SRTP_HAS_SDES) && (PJMEDIA_SRTP_HAS_SDES != 0)\n    if (*count < max)\n        keying[(*count)++] = PJMEDIA_SRTP_KEYING_SDES;\n#endif\n#if defined(PJMEDIA_SRTP_HAS_DTLS) && (PJMEDIA_SRTP_HAS_DTLS != 0)\n    if (*count < max)\n        keying[(*count)++] = PJMEDIA_SRTP_KEYING_DTLS_SRTP;\n#endif\n    \n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create an SRTP media transport.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_create(\n                                       pjmedia_endpt *endpt,\n                                       pjmedia_transport *tp,\n                                       const pjmedia_srtp_setting *opt,\n                                       pjmedia_transport **p_tp)\n{\n    pj_pool_t *pool;\n    transport_srtp *srtp;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(endpt && tp && p_tp, PJ_EINVAL);\n\n    /* Check crypto */\n    if (opt && opt->use != PJMEDIA_SRTP_DISABLED) {\n        for (i=0; i < opt->crypto_count; ++i) {\n            int cs_idx = get_crypto_idx(&opt->crypto[i].name);\n\n            /* check crypto name */\n            if (cs_idx == -1)\n                return PJMEDIA_SRTP_ENOTSUPCRYPTO;\n\n            /* check key length */\n            if (opt->crypto[i].key.slen &&\n                opt->crypto[i].key.slen <\n                (pj_ssize_t)crypto_suites[cs_idx].cipher_key_len)\n                return PJMEDIA_SRTP_EINKEYLEN;\n        }\n    }\n\n    /* Init libsrtp. */\n    status = pjmedia_srtp_init_lib(endpt);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    pool = pjmedia_endpt_create_pool(endpt, \"srtp%p\", 1000, 1000);\n    srtp = PJ_POOL_ZALLOC_T(pool, transport_srtp);\n\n    srtp->pool = pool;\n    srtp->session_inited = PJ_FALSE;\n    srtp->bypass_srtp = PJ_FALSE;\n    srtp->probation_cnt = PROBATION_CNT_INIT;\n\n    if (opt) {\n        srtp->setting = *opt;\n        if (opt->use == PJMEDIA_SRTP_DISABLED)\n            srtp->setting.crypto_count = 0;\n\n        for (i=0; i < srtp->setting.crypto_count; ++i) {\n            int cs_idx = get_crypto_idx(&opt->crypto[i].name);\n            pj_str_t tmp_key = opt->crypto[i].key;\n\n            if (cs_idx == -1) continue;\n\n            /* re-set crypto */\n            srtp->setting.crypto[i].name = pj_str(crypto_suites[cs_idx].name);\n            /* cut key length */\n            if (tmp_key.slen)\n                tmp_key.slen = crypto_suites[cs_idx].cipher_key_len;\n            pj_strdup(pool, &srtp->setting.crypto[i].key, &tmp_key);\n        }\n    } else {\n        pjmedia_srtp_setting_default(&srtp->setting);\n    }\n\n    /* If crypto count is set to zero, setup default crypto-suites,\n     * i.e: all available crypto but 'NULL'.\n     */\n    if (srtp->setting.crypto_count == 0 && \n        srtp->setting.use != PJMEDIA_SRTP_DISABLED)\n    {\n        srtp->setting.crypto_count = PJMEDIA_SRTP_MAX_CRYPTOS;\n        pjmedia_srtp_enum_crypto(&srtp->setting.crypto_count,\n                                 srtp->setting.crypto);\n    }\n\n    status = pj_lock_create_recursive_mutex(pool, pool->obj_name,\n                                            &srtp->mutex);\n    if (status != PJ_SUCCESS) {\n        pj_pool_release(pool);\n        return status;\n    }\n\n    /* Initialize base pjmedia_transport */\n    pj_memcpy(srtp->base.name, pool->obj_name, PJ_MAX_OBJ_NAME);\n    if (tp)\n        srtp->base.type = tp->type;\n    else\n        srtp->base.type = PJMEDIA_TRANSPORT_TYPE_UDP;\n    srtp->base.op = &transport_srtp_op;\n    srtp->base.user_data = srtp->setting.user_data;\n\n    /* Set underlying transport */\n    srtp->member_tp = tp;\n\n    /* Initialize peer's SRTP usage mode. */\n    srtp->peer_use = srtp->setting.use;\n\n    /* If keying count set to zero, setup default keying count & priorities */\n    if (srtp->setting.keying_count == 0) {\n        srtp->setting.keying_count = PJMEDIA_SRTP_KEYINGS_COUNT;\n        pjmedia_srtp_enum_keying(&srtp->setting.keying_count,\n                                 srtp->setting.keying);\n    }\n\n    /* Initialize SRTP keying method. */\n    for (i = 0; i < srtp->setting.keying_count && i < MAX_KEYING; ++i) {\n        switch(srtp->setting.keying[i]) {\n\n        case PJMEDIA_SRTP_KEYING_SDES:\n#if defined(PJMEDIA_SRTP_HAS_SDES) && (PJMEDIA_SRTP_HAS_SDES != 0)\n            sdes_create(srtp, &srtp->all_keying[srtp->all_keying_cnt++]);\n#endif\n            break;\n\n        case PJMEDIA_SRTP_KEYING_DTLS_SRTP:\n#if defined(PJMEDIA_SRTP_HAS_DTLS) && (PJMEDIA_SRTP_HAS_DTLS != 0)\n            dtls_create(srtp, &srtp->all_keying[srtp->all_keying_cnt++]);\n#endif\n            break;\n\n        default:\n            break;\n        }\n    }\n\n    /* Done */\n    *p_tp = &srtp->base;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get SRTP media transport setting.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_get_setting(\n                                       pjmedia_transport *tp,\n                                       pjmedia_srtp_setting *opt)\n{\n    transport_srtp  *srtp = (transport_srtp*) tp;\n    *opt = srtp->setting;\n    return PJ_SUCCESS;\n}\n\n/*\n * Modify SRTP media transport setting.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_modify_setting(\n                                       pjmedia_transport *tp,\n                                       const pjmedia_srtp_setting *opt)\n{\n    transport_srtp  *srtp = (transport_srtp*) tp;\n    srtp->setting = *opt;\n    return PJ_SUCCESS;\n}\n\n\n/* Create SRTP context */\nstatic pj_status_t create_srtp_ctx(transport_srtp *srtp,\n                                   srtp_context *ctx,\n                                   const pjmedia_srtp_setting *setting,\n                                   const pjmedia_srtp_crypto *tx,\n                                   const pjmedia_srtp_crypto *rx)\n{\n    srtp_policy_t    tx_;\n    srtp_policy_t    rx_;\n    srtp_err_status_t err;\n    int              cr_tx_idx = 0;\n    int              au_tx_idx = 0;\n    int              cr_rx_idx = 0;\n    int              au_rx_idx = 0;\n    pj_status_t      status = PJ_SUCCESS;\n\n    pj_lock_acquire(srtp->mutex);\n\n    if (ctx->srtp_tx_ctx || ctx->srtp_rx_ctx)\n        destroy_srtp_ctx(srtp, ctx);\n\n    /* Get encryption and authentication method */\n    cr_tx_idx = au_tx_idx = get_crypto_idx(&tx->name);\n    if (tx->flags & PJMEDIA_SRTP_NO_ENCRYPTION)\n        cr_tx_idx = 0;\n    if (tx->flags & PJMEDIA_SRTP_NO_AUTHENTICATION)\n        au_tx_idx = 0;\n\n    cr_rx_idx = au_rx_idx = get_crypto_idx(&rx->name);\n    if (rx->flags & PJMEDIA_SRTP_NO_ENCRYPTION)\n        cr_rx_idx = 0;\n    if (rx->flags & PJMEDIA_SRTP_NO_AUTHENTICATION)\n        au_rx_idx = 0;\n\n    /* Check whether the crypto-suite requested is supported */\n    if (cr_tx_idx == -1 || cr_rx_idx == -1 || au_tx_idx == -1 ||\n        au_rx_idx == -1)\n    {\n        status = PJMEDIA_SRTP_ENOTSUPCRYPTO;\n        goto on_return;\n    }\n\n    /* If all options points to 'NULL' method, just bypass SRTP */\n    if (cr_tx_idx == 0 && cr_rx_idx == 0 && au_tx_idx == 0 && au_rx_idx == 0) {\n        /* To bypass SRTP: we return PJ_SUCCESS without allocating SRTP\n         * contexts.\n         */\n        goto on_return;\n    }\n\n    /* Check key length */\n    if (tx->key.slen != (pj_ssize_t)crypto_suites[cr_tx_idx].cipher_key_len ||\n        rx->key.slen != (pj_ssize_t)crypto_suites[cr_rx_idx].cipher_key_len)\n    {\n        status = PJMEDIA_SRTP_EINKEYLEN;\n        goto on_return;\n    }\n\n    /* Init transmit direction */\n    pj_bzero(&tx_, sizeof(srtp_policy_t));\n    pj_memmove(ctx->tx_key, tx->key.ptr, tx->key.slen);\n    if (cr_tx_idx && au_tx_idx)\n        tx_.rtp.sec_serv    = sec_serv_conf_and_auth;\n    else if (cr_tx_idx)\n        tx_.rtp.sec_serv    = sec_serv_conf;\n    else if (au_tx_idx)\n        tx_.rtp.sec_serv    = sec_serv_auth;\n    else\n        tx_.rtp.sec_serv    = sec_serv_none;\n    tx_.key                 = (uint8_t*)ctx->tx_key;\n    if (setting->tx_roc.roc != 0 &&\n        setting->tx_roc.ssrc != 0)\n    {\n        tx_.ssrc.type       = ssrc_specific;\n        tx_.ssrc.value      = setting->tx_roc.ssrc;\n    } else {\n        tx_.ssrc.type       = ssrc_any_outbound;\n        tx_.ssrc.value      = 0;\n    }\n    tx_.rtp.cipher_type     = crypto_suites[cr_tx_idx].cipher_type;\n    tx_.rtp.cipher_key_len  = crypto_suites[cr_tx_idx].cipher_key_len;\n    tx_.rtp.auth_type       = crypto_suites[au_tx_idx].auth_type;\n    tx_.rtp.auth_key_len    = crypto_suites[au_tx_idx].auth_key_len;\n    tx_.rtp.auth_tag_len    = crypto_suites[au_tx_idx].srtp_auth_tag_len;\n    tx_.rtcp                = tx_.rtp;\n    tx_.rtcp.auth_tag_len   = crypto_suites[au_tx_idx].srtcp_auth_tag_len;\n    tx_.next                = NULL;\n    err = srtp_create(&ctx->srtp_tx_ctx, &tx_);\n    if (err != srtp_err_status_ok) {\n        status = PJMEDIA_ERRNO_FROM_LIBSRTP(err);\n        goto on_return;\n    }\n    if (setting->tx_roc.roc != 0 &&\n        setting->tx_roc.ssrc != 0)\n    {\n        err = srtp_set_stream_roc(ctx->srtp_tx_ctx,\n                                  setting->tx_roc.ssrc,\n                                  setting->tx_roc.roc);\n        PJ_LOG(4, (THIS_FILE, \"Initializing SRTP TX ROC to SSRC %d with \"\n                   \"ROC %d %s\\n\", setting->tx_roc.ssrc,\n                   setting->tx_roc.roc,\n                   (err == srtp_err_status_ok)? \"succeeded\": \"failed\"));\n    }\n    ctx->tx_policy = *tx;\n    pj_strset(&ctx->tx_policy.key,  ctx->tx_key, tx->key.slen);\n    ctx->tx_policy.name=pj_str(crypto_suites[get_crypto_idx(&tx->name)].name);\n\n\n    /* Init receive direction */\n    pj_bzero(&rx_, sizeof(srtp_policy_t));\n    pj_memmove(ctx->rx_key, rx->key.ptr, rx->key.slen);\n    if (cr_rx_idx && au_rx_idx)\n        rx_.rtp.sec_serv    = sec_serv_conf_and_auth;\n    else if (cr_rx_idx)\n        rx_.rtp.sec_serv    = sec_serv_conf;\n    else if (au_rx_idx)\n        rx_.rtp.sec_serv    = sec_serv_auth;\n    else\n        rx_.rtp.sec_serv    = sec_serv_none;\n    rx_.key                 = (uint8_t*)ctx->rx_key;\n    if (setting->rx_roc.roc != 0 &&\n        setting->rx_roc.ssrc != 0)\n    {\n        rx_.ssrc.type       = ssrc_specific;\n        rx_.ssrc.value      = setting->rx_roc.ssrc;\n    } else {\n        rx_.ssrc.type       = ssrc_any_inbound;\n        rx_.ssrc.value      = 0;\n    }\n    rx_.rtp.sec_serv        = crypto_suites[cr_rx_idx].service;\n    rx_.rtp.cipher_type     = crypto_suites[cr_rx_idx].cipher_type;\n    rx_.rtp.cipher_key_len  = crypto_suites[cr_rx_idx].cipher_key_len;\n    rx_.rtp.auth_type       = crypto_suites[au_rx_idx].auth_type;\n    rx_.rtp.auth_key_len    = crypto_suites[au_rx_idx].auth_key_len;\n    rx_.rtp.auth_tag_len    = crypto_suites[au_rx_idx].srtp_auth_tag_len;\n    rx_.rtcp                = rx_.rtp;\n    rx_.rtcp.auth_tag_len   = crypto_suites[au_rx_idx].srtcp_auth_tag_len;\n    rx_.next                = NULL;\n    err = srtp_create(&ctx->srtp_rx_ctx, &rx_);\n    if (err != srtp_err_status_ok) {\n        srtp_dealloc(ctx->srtp_tx_ctx);\n        status = PJMEDIA_ERRNO_FROM_LIBSRTP(err);\n        goto on_return;\n    }\n    if (setting->rx_roc.roc != 0 &&\n        setting->rx_roc.ssrc != 0)\n    {\n        err = srtp_set_stream_roc(ctx->srtp_rx_ctx,\n                                  setting->rx_roc.ssrc,\n                                  setting->rx_roc.roc);\n        PJ_LOG(4, (THIS_FILE, \"Initializing SRTP RX ROC from SSRC %d with \"\n                   \"ROC %d %s\\n\",\n                   setting->rx_roc.ssrc, setting->rx_roc.roc,\n                   (err == srtp_err_status_ok)? \"succeeded\": \"failed\"));\n    }\n    ctx->rx_policy = *rx;\n    pj_strset(&ctx->rx_policy.key,  ctx->rx_key, rx->key.slen);\n    ctx->rx_policy.name=pj_str(crypto_suites[get_crypto_idx(&rx->name)].name);\n\n    /* Logging stuffs */\n#if PJ_LOG_MAX_LEVEL >= 5\n    {\n        char b64[PJ_BASE256_TO_BASE64_LEN(MAX_KEY_LEN)];\n        int b64_len;\n\n        /* TX crypto and key */\n        b64_len = sizeof(b64);\n        status = pj_base64_encode((pj_uint8_t*)tx->key.ptr, (int)tx->key.slen,\n                                  b64, &b64_len);\n        if (status != PJ_SUCCESS)\n            b64_len = pj_ansi_snprintf(b64, sizeof(b64), \"--key too long--\");\n        else\n            b64[b64_len] = '\\0';\n\n        PJ_LOG(5, (srtp->pool->obj_name, \"TX: %s key=%s\",\n                   ctx->tx_policy.name.ptr, b64));\n        if (ctx->tx_policy.flags) {\n            PJ_LOG(5,(srtp->pool->obj_name, \"TX: disable%s%s\",\n                      (cr_tx_idx?\"\":\" enc\"),\n                      (au_tx_idx?\"\":\" auth\")));\n        }\n\n        /* RX crypto and key */\n        b64_len = sizeof(b64);\n        status = pj_base64_encode((pj_uint8_t*)rx->key.ptr, (int)rx->key.slen,\n                                  b64, &b64_len);\n        if (status != PJ_SUCCESS)\n            b64_len = pj_ansi_snprintf(b64, sizeof(b64), \"--key too long--\");\n        else\n            b64[b64_len] = '\\0';\n\n        PJ_LOG(5, (srtp->pool->obj_name, \"RX: %s key=%s\",\n                   ctx->rx_policy.name.ptr, b64));\n        if (ctx->rx_policy.flags) {\n            PJ_LOG(5,(srtp->pool->obj_name,\"RX: disable%s%s\",\n                      (cr_rx_idx?\"\":\" enc\"),\n                      (au_rx_idx?\"\":\" auth\")));\n        }\n    }\n#endif\n\non_return:\n    pj_lock_release(srtp->mutex);\n    return status;\n}\n\n/*\n * Initialize and start SRTP session with the given parameters.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_start(\n                           pjmedia_transport *tp,\n                           const pjmedia_srtp_crypto *tx,\n                           const pjmedia_srtp_crypto *rx)\n{\n    transport_srtp  *srtp = (transport_srtp*) tp;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(tp && tx && rx, PJ_EINVAL);\n\n    pj_lock_acquire(srtp->mutex);\n\n    if (srtp->session_inited) {\n        pjmedia_transport_srtp_stop(tp);\n    }\n\n    status = create_srtp_ctx(srtp, &srtp->srtp_ctx, &srtp->setting, tx, rx);\n    if (status == PJ_SUCCESS) {\n        if (srtp->srtp_ctx.srtp_tx_ctx && srtp->srtp_ctx.srtp_rx_ctx) {\n            /* Declare SRTP session initialized */\n            srtp->session_inited = PJ_TRUE;\n        } else {\n            srtp->bypass_srtp = PJ_TRUE;\n        }\n    }\n\n    pj_lock_release(srtp->mutex);\n\n    return status;\n}\n\n/* Destroy SRTP context */\nstatic void destroy_srtp_ctx(transport_srtp *p_srtp, srtp_context *ctx)\n{\n    srtp_err_status_t err;\n\n    if (ctx->srtp_rx_ctx) {\n        err = srtp_dealloc(ctx->srtp_rx_ctx);\n        if (err != srtp_err_status_ok) {\n            PJ_LOG(4, (p_srtp->pool->obj_name,\n                       \"Failed to dealloc RX SRTP context: %s\",\n                       get_libsrtp_errstr(err)));\n        }\n    }\n    if (ctx->srtp_tx_ctx) {\n        err = srtp_dealloc(ctx->srtp_tx_ctx);\n        if (err != srtp_err_status_ok) {\n            PJ_LOG(4, (p_srtp->pool->obj_name,\n                       \"Failed to dealloc TX SRTP context: %s\",\n                       get_libsrtp_errstr(err)));\n        }\n    }\n    ctx->srtp_rx_ctx = NULL;\n    ctx->srtp_tx_ctx = NULL;\n\n    pj_bzero(&ctx->rx_policy, sizeof(ctx->rx_policy));\n    pj_bzero(&ctx->tx_policy, sizeof(ctx->tx_policy));\n}\n\n/*\n * Stop SRTP session.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_stop(pjmedia_transport *srtp)\n{\n    transport_srtp *p_srtp = (transport_srtp*) srtp;\n\n    PJ_ASSERT_RETURN(srtp, PJ_EINVAL);\n\n    pj_lock_acquire(p_srtp->mutex);\n\n    if (!p_srtp->session_inited) {\n        pj_lock_release(p_srtp->mutex);\n        return PJ_SUCCESS;\n    }\n\n    destroy_srtp_ctx(p_srtp, &p_srtp->srtp_ctx);\n    destroy_srtp_ctx(p_srtp, &p_srtp->srtp_rtcp);\n\n    p_srtp->session_inited = PJ_FALSE;\n\n    pj_lock_release(p_srtp->mutex);\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t start_srtp(transport_srtp *srtp)\n{\n    /* Make sure we have the SRTP policies */\n    if (srtp_crypto_empty(&srtp->srtp_ctx.tx_policy_neg) ||\n        srtp_crypto_empty(&srtp->srtp_ctx.rx_policy_neg))\n    {\n        srtp->bypass_srtp = PJ_TRUE;\n        srtp->peer_use = PJMEDIA_SRTP_DISABLED;\n        if (srtp->session_inited) {\n            pjmedia_transport_srtp_stop(&srtp->base);\n        }\n\n        PJ_LOG(4, (srtp->pool->obj_name, \"SRTP not active\"));\n        return PJ_SUCCESS;\n    }\n\n    /* Got policy_local & policy_remote, let's initalize the SRTP */\n\n    /* Ticket #1075: media_start() is called whenever media description\n     * gets updated, e.g: call hold, however we should restart SRTP only\n     * when the SRTP policy settings are updated.\n     */\n    if (srtp_crypto_cmp(&srtp->srtp_ctx.tx_policy_neg,\n                        &srtp->srtp_ctx.tx_policy) ||\n        srtp_crypto_cmp(&srtp->srtp_ctx.rx_policy_neg,\n                        &srtp->srtp_ctx.rx_policy))\n    {\n        pj_status_t status;\n        status = pjmedia_transport_srtp_start(&srtp->base,\n                                              &srtp->srtp_ctx.tx_policy_neg,\n                                              &srtp->srtp_ctx.rx_policy_neg);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        /* Reset probation counts */\n        srtp->probation_cnt = PROBATION_CNT_INIT;\n\n        PJ_LOG(4, (srtp->pool->obj_name,\n                   \"SRTP started, keying=%s, crypto=%s\",\n                   ((int)srtp->keying[0]->type==PJMEDIA_SRTP_KEYING_SDES?\n                    \"SDES\":\"DTLS-SRTP\"),\n                   srtp->srtp_ctx.tx_policy.name.ptr));\n    }\n\n    srtp->bypass_srtp = PJ_FALSE;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pjmedia_transport *) pjmedia_transport_srtp_get_member(\n                                                pjmedia_transport *tp)\n{\n    transport_srtp *srtp = (transport_srtp*) tp;\n\n    PJ_ASSERT_RETURN(tp, NULL);\n\n    return srtp->member_tp;\n}\n\n\nstatic pj_status_t transport_get_info(pjmedia_transport *tp,\n                                      pjmedia_transport_info *info)\n{\n    transport_srtp *srtp = (transport_srtp*) tp;\n    pjmedia_srtp_info srtp_info;\n    int spc_info_idx;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp && info, PJ_EINVAL);\n    PJ_ASSERT_RETURN(info->specific_info_cnt <\n                     PJMEDIA_TRANSPORT_SPECIFIC_INFO_MAXCNT, PJ_ETOOMANY);\n    PJ_ASSERT_RETURN(sizeof(pjmedia_srtp_info) <=\n                     PJMEDIA_TRANSPORT_SPECIFIC_INFO_MAXSIZE, PJ_ENOMEM);\n\n    srtp_info.active = srtp->session_inited;\n    srtp_info.rx_policy = srtp->srtp_ctx.rx_policy;\n    srtp_info.tx_policy = srtp->srtp_ctx.tx_policy;\n    srtp_info.use = srtp->setting.use;\n    srtp_info.peer_use = srtp->peer_use;\n\n    pj_bzero(&srtp_info.tx_roc, sizeof(srtp_info.tx_roc));\n    pj_bzero(&srtp_info.rx_roc, sizeof(srtp_info.rx_roc));\n\n    if (srtp->srtp_ctx.srtp_rx_ctx && srtp->rx_ssrc != 0) {\n        srtp_info.rx_roc.ssrc = srtp->rx_ssrc;\n        srtp_get_stream_roc(srtp->srtp_ctx.srtp_rx_ctx, srtp->rx_ssrc,\n                            &srtp_info.rx_roc.roc);\n    } else if (srtp->setting.rx_roc.ssrc != 0) {\n        srtp_info.rx_roc.ssrc = srtp->setting.rx_roc.ssrc;\n        srtp_info.rx_roc.roc = srtp->setting.rx_roc.roc;\n    }\n    if (srtp->srtp_ctx.srtp_tx_ctx && srtp->tx_ssrc != 0) {\n        srtp_info.tx_roc.ssrc = srtp->tx_ssrc;\n        srtp_get_stream_roc(srtp->srtp_ctx.srtp_tx_ctx, srtp->tx_ssrc,\n                            &srtp_info.tx_roc.roc);\n    } else if (srtp->setting.tx_roc.ssrc != 0) {\n        srtp_info.tx_roc.ssrc = srtp->setting.tx_roc.ssrc;\n        srtp_info.tx_roc.roc = srtp->setting.tx_roc.roc;\n    }\n\n    spc_info_idx = info->specific_info_cnt++;\n    info->spc_info[spc_info_idx].type = PJMEDIA_TRANSPORT_TYPE_SRTP;\n    info->spc_info[spc_info_idx].tp = tp;\n    info->spc_info[spc_info_idx].cbsize = sizeof(srtp_info);\n    pj_memcpy(&info->spc_info[spc_info_idx].buffer, &srtp_info,\n              sizeof(srtp_info));\n\n    /* Invoke get_info() from any active keying method */\n    for (i=0; i < srtp->keying_cnt; i++)\n        pjmedia_transport_get_info(srtp->keying[i], info);\n\n    return pjmedia_transport_get_info(srtp->member_tp, info);\n}\n\nstatic pj_status_t transport_attach2(pjmedia_transport *tp,\n                                     pjmedia_transport_attach_param *param)\n{\n    transport_srtp *srtp = (transport_srtp*) tp;\n    pjmedia_transport_attach_param member_param;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(tp && param, PJ_EINVAL);\n\n    /* Save the callbacks */\n    pj_lock_acquire(srtp->mutex);\n    if (param->rtp_cb || param->rtp_cb2) {\n        /* Do not update rtp_cb if not set, as attach() is called by\n         * keying method.\n         */\n        srtp->rtp_cb = param->rtp_cb;\n        srtp->rtp_cb2 = param->rtp_cb2;\n        srtp->rtcp_cb = param->rtcp_cb;\n        srtp->user_data = param->user_data;\n    }\n    pj_lock_release(srtp->mutex);\n\n    /* Attach self to member transport */\n    member_param = *param;\n    member_param.user_data = srtp;\n    member_param.rtp_cb = NULL;\n    member_param.rtp_cb2 = &srtp_rtp_cb;\n    member_param.rtcp_cb = &srtp_rtcp_cb;\n    status = pjmedia_transport_attach2(srtp->member_tp, &member_param);\n    if (status != PJ_SUCCESS) {\n        pj_lock_acquire(srtp->mutex);\n        srtp->rtp_cb = NULL;\n        srtp->rtcp_cb = NULL;\n        srtp->user_data = NULL;\n        pj_lock_release(srtp->mutex);\n        return status;\n    }\n\n    /* Check if we are multiplexing RTP & RTCP. */\n    srtp->use_rtcp_mux = (pj_sockaddr_has_addr(&param->rem_addr) &&\n                          pj_sockaddr_cmp(&param->rem_addr,\n                                          &param->rem_rtcp) == 0);\n    srtp->member_tp_attached = PJ_TRUE;\n    return PJ_SUCCESS;\n}\n\nstatic void transport_detach(pjmedia_transport *tp, void *strm)\n{\n    transport_srtp *srtp = (transport_srtp*) tp;\n\n    PJ_UNUSED_ARG(strm);\n    PJ_ASSERT_ON_FAIL(tp, return);\n\n    if (srtp->member_tp) {\n        pjmedia_transport_detach(srtp->member_tp, srtp);\n    }\n\n    /* Clear up application infos from transport */\n    pj_lock_acquire(srtp->mutex);\n    srtp->rtp_cb = NULL;\n    srtp->rtp_cb2 = NULL;\n    srtp->rtcp_cb = NULL;\n    srtp->user_data = NULL;\n    pj_lock_release(srtp->mutex);\n    srtp->member_tp_attached = PJ_FALSE;\n}\n\nstatic pj_status_t transport_send_rtp( pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size)\n{\n    pj_status_t status;\n    transport_srtp *srtp = (transport_srtp*) tp;\n    int len = (int)size;\n    srtp_err_status_t err;\n\n    if (srtp->bypass_srtp)\n        return pjmedia_transport_send_rtp(srtp->member_tp, pkt, size);\n\n    if (size > sizeof(srtp->rtp_tx_buffer) - MAX_TRAILER_LEN)\n        return PJ_ETOOBIG;\n\n    pj_memcpy(srtp->rtp_tx_buffer, pkt, size);\n\n    pj_lock_acquire(srtp->mutex);\n    if (!srtp->session_inited) {\n        pj_lock_release(srtp->mutex);\n        return PJMEDIA_SRTP_EKEYNOTREADY;\n    }\n\n    /* Save outgoing SSRC */\n    srtp->tx_ssrc = ntohl(((pjmedia_rtp_hdr*)pkt)->ssrc);\n\n#if TEST_ROC\n    if (srtp->setting.tx_roc.ssrc == 0) {\n        srtp_err_status_t status;\n        status = srtp_set_stream_roc(srtp->srtp_ctx.srtp_tx_ctx, srtp->tx_ssrc,\n                                     (srtp->offerer_side? 1: 2));\n        if (status == srtp_err_status_ok) {\n            srtp->setting.tx_roc.ssrc = srtp->tx_ssrc;\n            srtp->setting.tx_roc.roc = (srtp->offerer_side? 1: 2);\n            PJ_LOG(4, (THIS_FILE, \"Setting TX ROC to SSRC %d to %d\",\n                   srtp->tx_ssrc, srtp->setting.tx_roc.roc));\n        }\n    }\n#endif\n\n    err = srtp_protect(srtp->srtp_ctx.srtp_tx_ctx, srtp->rtp_tx_buffer, &len);\n    pj_lock_release(srtp->mutex);\n\n    if (err == srtp_err_status_ok) {\n        status = pjmedia_transport_send_rtp(srtp->member_tp,\n                                            srtp->rtp_tx_buffer, len);\n    } else {\n        status = PJMEDIA_ERRNO_FROM_LIBSRTP(err);\n    }\n\n    return status;\n}\n\nstatic pj_status_t transport_send_rtcp(pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size)\n{\n    return transport_send_rtcp2(tp, NULL, 0, pkt, size);\n}\n\nstatic pj_status_t transport_send_rtcp2(pjmedia_transport *tp,\n                                        const pj_sockaddr_t *addr,\n                                        unsigned addr_len,\n                                        const void *pkt,\n                                        pj_size_t size)\n{\n    pj_status_t status;\n    transport_srtp *srtp = (transport_srtp*) tp;\n    int len = (int)size;\n    srtp_err_status_t err;\n\n    if (srtp->bypass_srtp) {\n        return pjmedia_transport_send_rtcp2(srtp->member_tp, addr, addr_len,\n                                            pkt, size);\n    }\n\n    if (size > sizeof(srtp->rtcp_tx_buffer) - (MAX_TRAILER_LEN+4))\n        return PJ_ETOOBIG;\n\n    pj_memcpy(srtp->rtcp_tx_buffer, pkt, size);\n\n    pj_lock_acquire(srtp->mutex);\n    if (!srtp->session_inited) {\n        pj_lock_release(srtp->mutex);\n        return PJMEDIA_SRTP_EKEYNOTREADY;\n    }\n    err = srtp_protect_rtcp(srtp->srtp_rtcp.srtp_tx_ctx?\n                            srtp->srtp_rtcp.srtp_tx_ctx:\n                            srtp->srtp_ctx.srtp_tx_ctx,\n                            srtp->rtcp_tx_buffer, &len);\n    pj_lock_release(srtp->mutex);\n\n    if (err == srtp_err_status_ok) {\n        status = pjmedia_transport_send_rtcp2(srtp->member_tp, addr, addr_len,\n                                              srtp->rtcp_tx_buffer, len);\n    } else {\n        status = PJMEDIA_ERRNO_FROM_LIBSRTP(err);\n    }\n\n    return status;\n}\n\n\nstatic pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n                                           pjmedia_dir dir,\n                                           unsigned pct_lost)\n{\n    transport_srtp *srtp = (transport_srtp *) tp;\n\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    return pjmedia_transport_simulate_lost(srtp->member_tp, dir, pct_lost);\n}\n\nstatic pj_status_t transport_destroy  (pjmedia_transport *tp)\n{\n    transport_srtp *srtp = (transport_srtp *) tp;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    /* Close all keying. Note that any keying should not be destroyed before\n     * SRTP transport is destroyed as re-INVITE may initiate new keying method\n     * without destroying SRTP transport.\n     */\n    for (i=0; i < srtp->all_keying_cnt; i++)\n        pjmedia_transport_close(srtp->all_keying[i]);\n\n    /* Close member if configured */\n    if (srtp->setting.close_member_tp && srtp->member_tp) {\n        pjmedia_transport_close(srtp->member_tp);\n    }\n\n    status = pjmedia_transport_srtp_stop(tp);\n\n    /* In case mutex is being acquired by other thread */\n    pj_lock_acquire(srtp->mutex);\n    pj_lock_release(srtp->mutex);\n\n    pj_lock_destroy(srtp->mutex);\n    pj_pool_release(srtp->pool);\n\n    return status;\n}\n\n/*\n * This callback is called by transport when incoming rtp is received\n */\nstatic void srtp_rtp_cb(pjmedia_tp_cb_param *param)\n{\n    transport_srtp *srtp = (transport_srtp *) param->user_data;\n    void *pkt = param->pkt;\n    pj_ssize_t size = param->size;\n    int len = (int)size;\n    srtp_err_status_t err;\n    void (*cb)(void*, void*, pj_ssize_t) = NULL;\n    void (*cb2)(pjmedia_tp_cb_param*) = NULL;\n    void *cb_data = NULL;\n\n    if (srtp->bypass_srtp) {\n        if (srtp->rtp_cb2) {\n            pjmedia_tp_cb_param param2 = *param;\n            param2.user_data = srtp->user_data;\n            srtp->rtp_cb2(&param2);\n            param->rem_switch = param2.rem_switch;\n        } else if (srtp->rtp_cb) {\n            srtp->rtp_cb(srtp->user_data, pkt, size);\n        }\n        return;\n    }\n\n    if (size < 0) {\n        return;\n    }\n\n    /* Give the packet to keying first by invoking its send_rtp() op.\n     * Yes, the usage of send_rtp() is rather hacky, but it is convenient\n     * as the signature suits the purpose and it is ready to use\n     * (no futher registration/setting needed), and it may never be used\n     * by any keying method in the future.\n     */\n    {\n        unsigned i;\n        pj_status_t status;\n        for (i=0; i < srtp->keying_cnt; i++) {\n            if (!srtp->keying[i]->op->send_rtp)\n                continue;\n            status = pjmedia_transport_send_rtp(srtp->keying[i], pkt, size);\n            if (status != PJ_EIGNORED) {\n                /* Packet is already consumed by the keying method */\n                return;\n            }\n        }\n    }\n\n    /* Make sure buffer is 32bit aligned */\n    PJ_ASSERT_ON_FAIL( (((pj_ssize_t)pkt) & 0x03)==0, return );\n\n    if (srtp->probation_cnt > 0)\n        --srtp->probation_cnt;\n\n    pj_lock_acquire(srtp->mutex);\n\n    if (!srtp->session_inited) {\n        pj_lock_release(srtp->mutex);\n        return;\n    }\n\n    /* Check if multiplexing is allowed and the payload indicates RTCP. */\n    if (srtp->use_rtcp_mux) {\n        pjmedia_rtp_hdr *hdr = (pjmedia_rtp_hdr *)pkt;\n  \n        if (hdr->pt >= 64 && hdr->pt <= 95) {   \n            pj_lock_release(srtp->mutex);\n            srtp_rtcp_cb(srtp, pkt, size);\n            return;\n        }\n    }\n\n#if TEST_ROC\n    if (srtp->setting.rx_roc.ssrc == 0) {\n        srtp_err_status_t status;\n        \n        srtp->rx_ssrc = ntohl(((pjmedia_rtp_hdr*)pkt)->ssrc);\n        status = srtp_set_stream_roc(srtp->srtp_ctx.srtp_rx_ctx, srtp->rx_ssrc,\n                                     (srtp->offerer_side? 2: 1));\n        if (status == srtp_err_status_ok) {     \n            srtp->setting.rx_roc.ssrc = srtp->rx_ssrc;\n            srtp->setting.rx_roc.roc = (srtp->offerer_side? 2: 1);\n\n            PJ_LOG(4, (THIS_FILE, \"Setting RX ROC from SSRC %d to %d\",\n                                  srtp->rx_ssrc, srtp->setting.rx_roc.roc));\n        } else {\n            PJ_LOG(4, (THIS_FILE, \"Setting RX ROC %s\",\n                       get_libsrtp_errstr(status)));\n        }\n    }\n#endif\n    \n    err = srtp_unprotect(srtp->srtp_ctx.srtp_rx_ctx, (pj_uint8_t*)pkt, &len);\n\n#if PJMEDIA_SRTP_CHECK_RTP_SEQ_ON_RESTART\n    if (srtp->probation_cnt > 0 &&\n        (err == srtp_err_status_replay_old ||\n         err == srtp_err_status_replay_fail))\n    {\n        /* Handle such condition that stream is updated (RTP seq is reinited\n         * & SRTP is restarted), but some old packets are still coming\n         * so SRTP is learning wrong RTP seq. While the newly inited RTP seq\n         * comes, SRTP thinks the RTP seq is replayed, so srtp_unprotect()\n         * will return err_status_replay_*. Restarting SRTP can resolve this.\n         */\n        pjmedia_srtp_crypto tx, rx;\n        pj_status_t status;\n\n        tx = srtp->srtp_ctx.tx_policy;\n        rx = srtp->srtp_ctx.rx_policy;\n\n        /* Stop SRTP first, otherwise srtp_start() will maintain current\n         * roll-over counter.\n         */\n        pjmedia_transport_srtp_stop((pjmedia_transport*)srtp);\n\n        status = pjmedia_transport_srtp_start((pjmedia_transport*)srtp,\n                                              &tx, &rx);\n        if (status != PJ_SUCCESS) {\n            PJ_LOG(5,(srtp->pool->obj_name, \"Failed to restart SRTP, err=%s\",\n                      get_libsrtp_errstr(err)));\n        } else if (!srtp->bypass_srtp) {\n            err = srtp_unprotect(srtp->srtp_ctx.srtp_rx_ctx,\n                                 (pj_uint8_t*)pkt, &len);\n        }\n    }\n#if PJMEDIA_SRTP_CHECK_ROC_ON_RESTART\n    else\n#endif\n#endif\n\n#if PJMEDIA_SRTP_CHECK_ROC_ON_RESTART\n    if (srtp->probation_cnt > 0 && err == srtp_err_status_auth_fail &&\n        srtp->setting.prev_rx_roc.ssrc != 0 &&\n        srtp->setting.prev_rx_roc.ssrc == srtp->setting.rx_roc.ssrc &&\n        srtp->setting.prev_rx_roc.roc != srtp->setting.rx_roc.roc)\n    {\n        unsigned roc, new_roc;\n        srtp_err_status_t status;\n\n        srtp_get_stream_roc(srtp->srtp_ctx.srtp_rx_ctx,\n                            srtp->setting.rx_roc.ssrc, &roc);\n        new_roc = (roc == srtp->setting.rx_roc.roc?\n                   srtp->setting.prev_rx_roc.roc: srtp->setting.rx_roc.roc);\n        status = srtp_set_stream_roc(srtp->srtp_ctx.srtp_rx_ctx,\n                                     srtp->setting.rx_roc.ssrc, new_roc);\n        if (status == srtp_err_status_ok) {\n            PJ_LOG(4, (srtp->pool->obj_name,\n                       \"Retrying to unprotect SRTP from ROC %d to new ROC %d\",\n                       roc, new_roc));\n            err = srtp_unprotect(srtp->srtp_ctx.srtp_rx_ctx, (pj_uint8_t*)pkt,\n                                 &len);\n        }\n    }\n#endif\n\n    if (err != srtp_err_status_ok) {\n        PJ_LOG(5,(srtp->pool->obj_name,\n                  \"Failed to unprotect SRTP, pkt size=%ld, err=%s\",\n                  size, get_libsrtp_errstr(err)));\n    } else {\n        cb = srtp->rtp_cb;\n        cb2 = srtp->rtp_cb2;\n        cb_data = srtp->user_data;\n\n        /* Save SSRC after successful SRTP unprotect */\n        srtp->rx_ssrc = ntohl(((pjmedia_rtp_hdr*)pkt)->ssrc);\n    }\n\n    pj_lock_release(srtp->mutex);\n\n    if (cb2) {\n        pjmedia_tp_cb_param param2 = *param;\n        param2.user_data = cb_data;\n        param2.pkt = pkt;\n        param2.size = len;\n        (*cb2)(&param2);\n        param->rem_switch = param2.rem_switch;\n    } else if (cb) {\n        (*cb)(cb_data, pkt, len);\n    }\n}\n\n/*\n * This callback is called by transport when incoming rtcp is received\n */\nstatic void srtp_rtcp_cb( void *user_data, void *pkt, pj_ssize_t size)\n{\n    transport_srtp *srtp = (transport_srtp *) user_data;\n    int len = (int)size;\n    srtp_err_status_t err;\n    void (*cb)(void*, void*, pj_ssize_t) = NULL;\n    void *cb_data = NULL;\n\n    if (srtp->bypass_srtp) {\n        srtp->rtcp_cb(srtp->user_data, pkt, size);\n        return;\n    }\n\n    if (size < 0) {\n        return;\n    }\n\n    /* Give the packet to keying first by invoking its send_rtcp() op,\n     * in the same way as for RTP packet above.\n     */\n    {\n        unsigned i;\n        pj_status_t status;\n        for (i=0; i < srtp->keying_cnt; i++) {\n            if (!srtp->keying[i]->op->send_rtcp)\n                continue;\n            status = pjmedia_transport_send_rtcp(srtp->keying[i], pkt, size);\n            if (status != PJ_EIGNORED) {\n                /* Packet is already consumed by the keying method */\n                return;\n            }\n        }\n    }\n\n    /* Make sure buffer is 32bit aligned */\n    PJ_ASSERT_ON_FAIL( (((pj_ssize_t)pkt) & 0x03)==0, return );\n\n    pj_lock_acquire(srtp->mutex);\n\n    if (!srtp->session_inited) {\n        pj_lock_release(srtp->mutex);\n        return;\n    }\n    err = srtp_unprotect_rtcp(srtp->srtp_rtcp.srtp_rx_ctx?\n                              srtp->srtp_rtcp.srtp_rx_ctx:\n                              srtp->srtp_ctx.srtp_rx_ctx,\n                              (pj_uint8_t*)pkt, &len);\n    if (err != srtp_err_status_ok) {\n        PJ_LOG(5,(srtp->pool->obj_name,\n                  \"Failed to unprotect SRTCP, pkt size=%ld, err=%s\",\n                  size, get_libsrtp_errstr(err)));\n    } else {\n        cb = srtp->rtcp_cb;\n        cb_data = srtp->user_data;\n    }\n\n    pj_lock_release(srtp->mutex);\n\n    if (cb) {\n        (*cb)(cb_data, pkt, len);\n    }\n}\n\n\nstatic pj_status_t transport_media_create(pjmedia_transport *tp,\n                                          pj_pool_t *sdp_pool,\n                                          unsigned options,\n                                          const pjmedia_sdp_session *sdp_remote,\n                                          unsigned media_index)\n{\n    struct transport_srtp *srtp = (struct transport_srtp*) tp;\n    unsigned member_tp_option;\n    pj_status_t keying_status = PJ_SUCCESS;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    pj_bzero(&srtp->srtp_ctx.rx_policy_neg,\n             sizeof(srtp->srtp_ctx.rx_policy_neg));\n    pj_bzero(&srtp->srtp_ctx.tx_policy_neg,\n             sizeof(srtp->srtp_ctx.tx_policy_neg));\n\n    srtp->tx_ssrc = srtp->rx_ssrc = 0;\n    srtp->media_option = member_tp_option = options;\n    srtp->offerer_side = (sdp_remote == NULL);\n\n    if (srtp->offerer_side && srtp->setting.use == PJMEDIA_SRTP_DISABLED) {\n        /* If we are offerer and SRTP is disabled, simply bypass SRTP and\n         * skip keying.\n         */\n        srtp->bypass_srtp = PJ_TRUE;\n        srtp->keying_cnt = 0;\n    } else {\n        /* If we are answerer and SRTP is disabled, we need to verify that\n         * SRTP is disabled too in remote SDP, so we can't just skip keying.\n         */\n        srtp->bypass_srtp = PJ_FALSE;\n        srtp->keying_cnt = srtp->all_keying_cnt;\n        for (i = 0; i < srtp->all_keying_cnt; ++i)\n            srtp->keying[i] = srtp->all_keying[i];\n\n        member_tp_option |= PJMEDIA_TPMED_NO_TRANSPORT_CHECKING;\n    }\n\n    status = pjmedia_transport_media_create(srtp->member_tp, sdp_pool,\n                                            member_tp_option, sdp_remote,\n                                            media_index);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Invoke media_create() of all keying methods, keying actions for each\n     * SRTP mode:\n     * - DISABLED:\n     *   - as offerer, nothing (keying is skipped).\n     *   - as answerer, verify remote SDP, make sure it has SRTP disabled too,\n     *     if not, return error.\n     * - OPTIONAL:\n     *   - as offerer, general initialization.\n     *   - as answerer, optionally verify SRTP attr in remote SDP (if any).\n     * - MANDATORY:\n     *   - as offerer, general initialization.\n     *   - as answerer, verify SRTP attr in remote SDP.\n     */\n    for (i=0; i < srtp->keying_cnt; ) {\n        pj_status_t st;\n        st = pjmedia_transport_media_create(srtp->keying[i], sdp_pool,\n                                            options, sdp_remote,\n                                            media_index);\n        if (st != PJ_SUCCESS) {\n            /* This keying method returns error, remove it */\n            pj_array_erase(srtp->keying, sizeof(srtp->keying[0]),\n                           srtp->keying_cnt, i);\n            srtp->keying_cnt--;\n            keying_status = st;\n            continue;\n        } else if (srtp->offerer_side) {\n            /* Currently we can send one keying only in outgoing offer */\n            srtp->keying[0] = srtp->keying[i];\n            srtp->keying_cnt = 1;\n            break;\n        }\n\n        ++i;\n    }\n\n    /* All keying method failed to process remote SDP? */\n    if (srtp->keying_cnt == 0)\n        return keying_status;\n\n    /* Bypass SRTP & skip keying as SRTP is disabled and verification on\n     * remote SDP has been done.\n     */\n    if (srtp->setting.use == PJMEDIA_SRTP_DISABLED) {\n        srtp->bypass_srtp = PJ_TRUE;\n        srtp->keying_cnt = 0;\n    }\n\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t transport_encode_sdp(pjmedia_transport *tp,\n                                        pj_pool_t *sdp_pool,\n                                        pjmedia_sdp_session *sdp_local,\n                                        const pjmedia_sdp_session *sdp_remote,\n                                        unsigned media_index)\n{\n    struct transport_srtp *srtp = (struct transport_srtp*) tp;\n    pj_status_t keying_status = PJ_SUCCESS;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp && sdp_pool && sdp_local, PJ_EINVAL);\n\n    pj_bzero(&srtp->srtp_ctx.rx_policy_neg,\n             sizeof(srtp->srtp_ctx.rx_policy_neg));\n    pj_bzero(&srtp->srtp_ctx.tx_policy_neg,\n             sizeof(srtp->srtp_ctx.tx_policy_neg));\n\n    srtp->offerer_side = (sdp_remote == NULL);\n\n    if (!srtp->offerer_side && srtp->started) {\n        /* This is may be incoming reoffer that may change keying */\n        srtp->keying_cnt = srtp->all_keying_cnt;\n        for (i = 0; i < srtp->all_keying_cnt; ++i)\n            srtp->keying[i] = srtp->all_keying[i];\n    }\n\n    status = pjmedia_transport_encode_sdp(srtp->member_tp, sdp_pool,\n                                          sdp_local, sdp_remote, media_index);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Invoke encode_sdp() of all keying methods, keying actions for each\n     * SRTP mode:\n     * - DISABLED: nothing (keying is skipped)\n     * - OPTIONAL:\n     *   - as offerer, generate offer.\n     *   - as answerer, if remote has the same SRTP keying in SDP, verify it,\n     *     generate answer, start crypto nego.\n     * - MANDATORY:\n     *   - as offerer, generate offer.\n     *   - as answerer, verify remote SDP, generate answer, start crypto nego.\n     *\n     * Note: because the SDP will be processed by other keying/components,\n     *       keying must do verification on remote SDP first (e.g: keying\n     *       is being used) before touching local SDP.\n     */\n    for (i=0; i < srtp->keying_cnt; ) {\n        pj_status_t st;\n        st = pjmedia_transport_encode_sdp(srtp->keying[i], sdp_pool,\n                                          sdp_local, sdp_remote,\n                                          media_index);\n        if (st != PJ_SUCCESS) {\n            /* This keying method returns error, remove it */\n            pj_array_erase(srtp->keying, sizeof(srtp->keying[0]),\n                           srtp->keying_cnt, i);\n            srtp->keying_cnt--;\n            keying_status = st;\n            continue;\n        } else if (!srtp->offerer_side) {\n            /* Answer with one keying only */\n            srtp->keying[0] = srtp->keying[i];\n            srtp->keying_cnt = 1;\n            break;\n        }\n\n        i++;\n    }\n\n    /* All keying method failed to process remote SDP? */\n    if (srtp->keying_cnt == 0) {\n        if (keying_status != PJ_SUCCESS) {\n            DEACTIVATE_MEDIA(sdp_pool, sdp_local->media[media_index]);\n        }\n        return keying_status;\n    }\n\n    /* Bypass SRTP & skip keying as SRTP is disabled and verification on\n     * remote SDP has been done.\n     */\n    if (srtp->setting.use == PJMEDIA_SRTP_DISABLED) {\n        srtp->bypass_srtp = PJ_TRUE;\n        srtp->keying_cnt = 0;\n    }\n\n    if (srtp->keying_cnt != 0) {\n        /* At this point for now, keying count should be 1 */\n        pj_assert(srtp->keying_cnt == 1);\n        PJ_LOG(4, (srtp->pool->obj_name, \"SRTP uses keying method %s\",\n                   ((int)srtp->keying[0]->type==PJMEDIA_SRTP_KEYING_SDES?\n                    \"SDES\":\"DTLS-SRTP\")));\n    }\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t transport_media_start(pjmedia_transport *tp,\n                                         pj_pool_t *pool,\n                                         const pjmedia_sdp_session *sdp_local,\n                                         const pjmedia_sdp_session *sdp_remote,\n                                         unsigned media_index)\n{\n    struct transport_srtp *srtp = (struct transport_srtp*) tp;\n    pj_status_t keying_status = PJ_SUCCESS;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    /* At this point for now, keying count should be 0 or 1 */\n    pj_assert(srtp->keying_cnt <= 1);\n\n    srtp->started = PJ_TRUE;\n\n    status = pjmedia_transport_media_start(srtp->member_tp, pool,\n                                           sdp_local, sdp_remote,\n                                           media_index);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Invoke media_start() of all keying methods, keying actions for each\n     * SRTP mode:\n     * - DISABLED: nothing (keying is skipped)\n     * - OPTIONAL:\n     *   - as offerer, if remote answer has the same SRTP keying in SDP,\n     *     verify it and start crypto nego.\n     *   - as answerer, start crypto nego if not yet (usually initated in\n     *     encode_sdp()).\n     * - MANDATORY:\n     *   - as offerer, verify remote answer and start crypto nego.\n     *   - as answerer, start crypto nego if not yet (usually initated in\n     *     encode_sdp()).\n     */\n    for (i=0; i < srtp->keying_cnt; ) {\n        status = pjmedia_transport_media_start(srtp->keying[i], pool,\n                                               sdp_local, sdp_remote,\n                                               media_index);\n        if (status != PJ_SUCCESS) {\n            /* This keying method returns error, remove it */\n            pj_array_erase(srtp->keying, sizeof(srtp->keying[0]),\n                           srtp->keying_cnt, i);\n            srtp->keying_cnt--;\n            keying_status = status;\n            continue;\n        }\n\n        if (!srtp_crypto_empty(&srtp->srtp_ctx.tx_policy_neg) &&\n            !srtp_crypto_empty(&srtp->srtp_ctx.rx_policy_neg))\n        {\n            /* SRTP nego is done */\n            srtp->keying_cnt = 1;\n            srtp->keying[0] = srtp->keying[i];\n            srtp->keying_pending_cnt = 0;\n            break;\n        }\n\n        i++;\n    }\n\n    /* All keying method failed to process remote SDP? */\n    if (srtp->keying_cnt == 0)\n        return keying_status;\n\n    /* If SRTP key is being negotiated, just return now.\n     * The keying method should start the SRTP once keying nego is done.\n     */\n    if (srtp->keying_pending_cnt)\n        return PJ_SUCCESS;\n\n    /* Start SRTP */\n    status = start_srtp(srtp);\n\n    return status;\n}\n\n\nstatic pj_status_t transport_media_stop(pjmedia_transport *tp)\n{\n    struct transport_srtp *srtp = (struct transport_srtp*) tp;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    srtp->started = PJ_FALSE;\n\n    /* Invoke media_stop() of all keying methods */\n    for (i=0; i < srtp->keying_cnt; ++i) {\n        pjmedia_transport_media_stop(srtp->keying[i]);\n    }\n\n    /* Invoke media_stop() of member tp */\n    status = pjmedia_transport_media_stop(srtp->member_tp);\n    if (status != PJ_SUCCESS)\n        PJ_PERROR(4, (srtp->pool->obj_name, status,\n                      \"SRTP failed stop underlying media transport.\"));\n\n    /* Finally, stop SRTP */\n    return pjmedia_transport_srtp_stop(tp);\n}\n\n\n/* Utility */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_decrypt_pkt(pjmedia_transport *tp,\n                                                       pj_bool_t is_rtp,\n                                                       void *pkt,\n                                                       int *pkt_len)\n{\n    transport_srtp *srtp = (transport_srtp *)tp;\n    srtp_err_status_t err;\n\n    if (srtp->bypass_srtp)\n        return PJ_SUCCESS;\n\n    PJ_ASSERT_RETURN(tp && pkt && (*pkt_len>0), PJ_EINVAL);\n    PJ_ASSERT_RETURN(srtp->session_inited, PJ_EINVALIDOP);\n\n    /* Make sure buffer is 32bit aligned */\n    PJ_ASSERT_ON_FAIL( (((pj_ssize_t)pkt) & 0x03)==0, return PJ_EINVAL);\n\n    pj_lock_acquire(srtp->mutex);\n\n    if (!srtp->session_inited) {\n        pj_lock_release(srtp->mutex);\n        return PJ_EINVALIDOP;\n    }\n\n    if (is_rtp)\n        err = srtp_unprotect(srtp->srtp_ctx.srtp_rx_ctx, pkt, pkt_len);\n    else\n        err = srtp_unprotect_rtcp(srtp->srtp_ctx.srtp_rx_ctx, pkt, pkt_len);\n\n    if (err != srtp_err_status_ok) {\n        PJ_LOG(5,(srtp->pool->obj_name,\n                  \"Failed to unprotect SRTP, pkt size=%d, err=%s\",\n                  *pkt_len, get_libsrtp_errstr(err)));\n    }\n\n    pj_lock_release(srtp->mutex);\n\n    return (err==srtp_err_status_ok) ? PJ_SUCCESS :\n                                       PJMEDIA_ERRNO_FROM_LIBSRTP(err);\n}\n\n#endif\n", "/*\n * Copyright (C) 2017 Teluu Inc. (http://www.teluu.com)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n */\n\n#include <pjmedia/clock.h>\n#include <pjmedia/sdp.h>\n#include <pjmedia/transport_ice.h>\n#include <pj/errno.h>\n#include <pj/rand.h>\n#include <pj/ssl_sock.h>\n\n/* \n * Include OpenSSL headers\n */\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    defined(OPENSSL_API_COMPAT) && OPENSSL_API_COMPAT >= 0x10100000L\n#  define X509_get_notBefore(x)     X509_getm_notBefore(x)\n#  define X509_get_notAfter(x)      X509_getm_notAfter(x)\n#endif\n\n/* Set to 1 to enable DTLS-SRTP debugging */\n#define DTLS_DEBUG  0\n\n#define NUM_CHANNEL 2\n\nenum {\n    RTP_CHANNEL = 0,\n    RTCP_CHANNEL = 1\n};\n\n#define CHANNEL_TO_STRING(idx) (idx == RTP_CHANNEL? \"RTP channel\": \\\n                                \"RTCP channel\")\n\n/* DTLS-SRTP transport op */\nstatic pj_status_t dtls_media_create  (pjmedia_transport *tp,\n                                       pj_pool_t *sdp_pool,\n                                       unsigned options,\n                                       const pjmedia_sdp_session *sdp_remote,\n                                       unsigned media_index);\nstatic pj_status_t dtls_encode_sdp    (pjmedia_transport *tp,\n                                       pj_pool_t *sdp_pool,\n                                       pjmedia_sdp_session *sdp_local,\n                                       const pjmedia_sdp_session *sdp_remote,\n                                       unsigned media_index);\nstatic pj_status_t dtls_media_start   (pjmedia_transport *tp,\n                                       pj_pool_t *tmp_pool,\n                                       const pjmedia_sdp_session *sdp_local,\n                                       const pjmedia_sdp_session *sdp_remote,\n                                       unsigned media_index);\nstatic pj_status_t dtls_media_stop    (pjmedia_transport *tp);\nstatic pj_status_t dtls_destroy       (pjmedia_transport *tp);\nstatic pj_status_t dtls_on_recv_rtp   (pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t dtls_on_recv_rtcp  (pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size);\n\nstatic void on_ice_complete2(pjmedia_transport *tp,\n                             pj_ice_strans_op op,\n                             pj_status_t status,\n                             void *user_data);\n\n\nstatic pjmedia_transport_op dtls_op =\n{\n    NULL,\n    NULL,\n    NULL,\n    &dtls_on_recv_rtp,      // originally send_rtp()\n    &dtls_on_recv_rtcp,     // originally send_rtcp()\n    NULL,\n    &dtls_media_create,\n    &dtls_encode_sdp,\n    &dtls_media_start,\n    &dtls_media_stop,\n    NULL,\n    &dtls_destroy,\n    NULL,\n};\n\n\ntypedef enum dtls_setup\n{ \n    DTLS_SETUP_UNKNOWN,\n    DTLS_SETUP_ACTPASS,\n    DTLS_SETUP_ACTIVE,\n    DTLS_SETUP_PASSIVE\n} dtls_setup;\n\ntypedef struct dtls_srtp dtls_srtp;\n\ntypedef struct dtls_srtp_channel\n{\n    dtls_srtp           *dtls_srtp;\n    unsigned             channel;\n} dtls_srtp_channel;\n\ntypedef struct dtls_srtp\n{\n    pjmedia_transport    base;\n    pj_pool_t           *pool;\n    transport_srtp      *srtp;\n\n    dtls_setup           setup;\n    unsigned long        last_err;\n    pj_bool_t            use_ice;\n    dtls_srtp_channel    channel[NUM_CHANNEL];\n    pj_bool_t            nego_started[NUM_CHANNEL];\n    pj_bool_t            nego_completed[NUM_CHANNEL];\n    pj_str_t             rem_fingerprint;   /* Remote fingerprint in SDP    */\n    pj_status_t          rem_fprint_status; /* Fingerprint verif. status    */\n    pj_sockaddr          rem_addr;          /* Remote address (from SDP/RTP)*/\n    pj_sockaddr          rem_rtcp;          /* Remote RTCP address (SDP)    */\n    pj_bool_t            pending_start;     /* media_start() invoked but DTLS\n                                               nego not done yet, so start\n                                               the SRTP once the nego done  */\n    pj_bool_t            got_keys;          /* DTLS nego done & keys ready  */\n    pjmedia_srtp_crypto  tx_crypto[NUM_CHANNEL];\n    pjmedia_srtp_crypto  rx_crypto[NUM_CHANNEL];\n\n    char                 buf[NUM_CHANNEL][PJMEDIA_MAX_MTU];\n    pjmedia_clock       *clock[NUM_CHANNEL];/* Timer workaround for retrans */\n\n    SSL_CTX             *ossl_ctx[NUM_CHANNEL];\n    SSL                 *ossl_ssl[NUM_CHANNEL];\n    BIO                 *ossl_rbio[NUM_CHANNEL];\n    BIO                 *ossl_wbio[NUM_CHANNEL];\n    pj_lock_t           *ossl_lock;\n} dtls_srtp;\n\n\nstatic const pj_str_t ID_TP_DTLS_SRTP = { \"UDP/TLS/RTP/SAVP\", 16 };\nstatic const pj_str_t ID_SETUP        = { \"setup\", 5 };\nstatic const pj_str_t ID_ACTPASS      = { \"actpass\", 7 };\nstatic const pj_str_t ID_ACTIVE       = { \"active\", 6 };\nstatic const pj_str_t ID_PASSIVE      = { \"passive\", 7 };\nstatic const pj_str_t ID_FINGERPRINT  = { \"fingerprint\", 11 };\n\n/* Map of OpenSSL-pjmedia SRTP cryptos. Currently OpenSSL seems to\n * support few cryptos only (based on ssl/d1_srtp.c of OpenSSL 1.1.0c).\n */\n#define OPENSSL_PROFILE_NUM 4\n\nstatic char* ossl_profiles[OPENSSL_PROFILE_NUM] =\n{\n     \"SRTP_AES128_CM_SHA1_80\",\n     \"SRTP_AES128_CM_SHA1_32\",\n     \"SRTP_AEAD_AES_256_GCM\",\n     \"SRTP_AEAD_AES_128_GCM\"\n};\nstatic char* pj_profiles[OPENSSL_PROFILE_NUM] =\n{\n    \"AES_CM_128_HMAC_SHA1_80\",\n    \"AES_CM_128_HMAC_SHA1_32\",\n    \"AEAD_AES_256_GCM\",\n    \"AEAD_AES_128_GCM\"\n};\n\n/* This will store the valid OpenSSL profiles which is mapped from \n * OpenSSL-pjmedia SRTP cryptos.\n */\nstatic char *valid_pj_profiles_list[OPENSSL_PROFILE_NUM];\nstatic char *valid_ossl_profiles_list[OPENSSL_PROFILE_NUM];\nstatic unsigned valid_profiles_cnt;\n\n\n/* Certificate & private key */\nstatic X509     *dtls_cert;\nstatic EVP_PKEY *dtls_priv_key;\nstatic pj_status_t ssl_generate_cert(X509 **p_cert, EVP_PKEY **p_priv_key);\n\nstatic pj_status_t dtls_init()\n{\n    /* Make sure OpenSSL library has been initialized */\n    {\n        pj_ssl_cipher ciphers[1];\n        unsigned cipher_num = 1;\n        pj_ssl_cipher_get_availables(ciphers, &cipher_num);\n    }\n\n    /* Generate cert if not yet */\n    if (!dtls_cert) {\n        pj_status_t status;\n        status = ssl_generate_cert(&dtls_cert, &dtls_priv_key);\n        if (status != PJ_SUCCESS) {\n            pj_perror(4, \"DTLS-SRTP\", status,\n                      \"Failed generating DTLS certificate\");\n            return status;\n        }\n    }\n\n    if (valid_profiles_cnt == 0) {\n        unsigned n, j;\n        int rc;\n        char *p, *end, buf[OPENSSL_PROFILE_NUM*25];\n\n        /* Create DTLS context */\n        SSL_CTX *ctx = SSL_CTX_new(DTLS_method());\n        if (ctx == NULL) {\n            return PJ_ENOMEM;\n        }\n\n        p = buf;\n        end = buf + sizeof(buf);\n        for (j=0; j<PJ_ARRAY_SIZE(ossl_profiles); ++j) {\n            rc = SSL_CTX_set_tlsext_use_srtp(ctx, ossl_profiles[j]);\n            if (rc == 0) {\n                valid_pj_profiles_list[valid_profiles_cnt] =\n                    pj_profiles[j];\n                valid_ossl_profiles_list[valid_profiles_cnt++] =\n                    ossl_profiles[j];\n\n                n = pj_ansi_snprintf(p, end - p, \":%s\", pj_profiles[j]);\n                p += n;\n            }\n        }\n        SSL_CTX_free(ctx);\n\n        if (valid_profiles_cnt > 0) {\n            PJ_LOG(4,(\"DTLS-SRTP\", \"%s profile is supported\", buf));\n        } else {\n            PJ_PERROR(4, (\"DTLS-SRTP\", PJMEDIA_SRTP_DTLS_ENOPROFILE,\n                          \"Error getting SRTP profile\"));\n\n            return PJMEDIA_SRTP_DTLS_ENOPROFILE;\n        }\n    }\n\n    return PJ_SUCCESS;\n}\n\nstatic void dtls_deinit()\n{\n    if (dtls_cert) {\n        X509_free(dtls_cert);\n        dtls_cert = NULL;\n\n        EVP_PKEY_free(dtls_priv_key);\n        dtls_priv_key = NULL;\n    }\n\n    valid_profiles_cnt = 0;\n}\n\n\n/* Create DTLS-SRTP keying instance */\nstatic pj_status_t dtls_create(transport_srtp *srtp,\n                               pjmedia_transport **p_keying)\n{\n    dtls_srtp *ds;\n    pj_pool_t *pool;\n\tpj_status_t status;\n\n    pool = pj_pool_create(srtp->pool->factory, \"dtls%p\",\n                          2000, 256, NULL);\n    ds = PJ_POOL_ZALLOC_T(pool, dtls_srtp);\n    ds->pool = pool;\n\n    pj_ansi_strxcpy(ds->base.name, pool->obj_name, PJ_MAX_OBJ_NAME);\n    ds->base.type = (pjmedia_transport_type)PJMEDIA_SRTP_KEYING_DTLS_SRTP;\n    ds->base.op = &dtls_op;\n    ds->base.user_data = srtp;\n    ds->srtp = srtp;\n\n    status = pj_lock_create_simple_mutex(ds->pool, \"dtls_ssl_lock%p\",\n                                         &ds->ossl_lock);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    *p_keying = &ds->base;\n    PJ_LOG(5,(srtp->pool->obj_name, \"SRTP keying DTLS-SRTP created\"));\n    return PJ_SUCCESS;\n}\n\n\n/**\n * Mapping from OpenSSL error codes to pjlib error space.\n */\n#define PJ_SSL_ERRNO_START              (PJ_ERRNO_START_USER + \\\n                                         PJ_ERRNO_SPACE_SIZE*6)\n\n#define PJ_SSL_ERRNO_SPACE_SIZE         PJ_ERRNO_SPACE_SIZE\n\n/* Expected maximum value of reason component in OpenSSL error code */\n#define MAX_OSSL_ERR_REASON             1200\n\nstatic pj_status_t STATUS_FROM_SSL_ERR(dtls_srtp *ds,\n                                       unsigned long err)\n{\n    pj_status_t status;\n\n    /* General SSL error, dig more from OpenSSL error queue */\n    if (err == SSL_ERROR_SSL)\n        err = ERR_get_error();\n\n    /* OpenSSL error range is much wider than PJLIB errno space, so\n     * if it exceeds the space, only the error reason will be kept.\n     * Note that the last native error will be kept as is and can be\n     * retrieved via SSL socket info.\n     */\n    status = ERR_GET_LIB(err)*MAX_OSSL_ERR_REASON + ERR_GET_REASON(err);\n    if (status > PJ_SSL_ERRNO_SPACE_SIZE)\n        status = ERR_GET_REASON(err);\n\n    if (status != PJ_SUCCESS)\n        status += PJ_SSL_ERRNO_START;\n\n    ds->last_err = err;\n    return status;\n}\n\n\nstatic pj_status_t GET_SSL_STATUS(dtls_srtp *ds)\n{\n    return STATUS_FROM_SSL_ERR(ds, ERR_get_error());\n}\n\n\n/* SSL cert verification callback. */\nstatic int verify_cb(int preverify_ok, X509_STORE_CTX *x509_ctx)\n{\n    PJ_UNUSED_ARG(preverify_ok);\n    PJ_UNUSED_ARG(x509_ctx);\n    /* Just skip it for now (as usually it's a self-signed cert) */\n    return 1;\n}\n\n/* Get fingerprint from TLS cert, output is formatted for SDP a=fingerprint,\n * e.g: \"SHA-256 XX:XX:XX...\". If is_sha256 is true, SHA-256 hash algo will\n * be used, otherwise it is SHA-1.\n */\nstatic pj_status_t ssl_get_fingerprint(X509 *cert, pj_bool_t is_sha256,\n                                       char *buf, pj_size_t *buf_len)\n{\n    unsigned int len, st_out_len, i;\n    unsigned char tmp[EVP_MAX_MD_SIZE];\n    char *p, *end=buf+*buf_len;\n\n    if (!X509_digest(cert, (is_sha256?EVP_sha256():EVP_sha1()), tmp, &len))\n        return PJ_EUNKNOWN;\n\n    st_out_len =  len*3 + (is_sha256? 7 : 5);\n    if (*buf_len < st_out_len + 1)\n        return PJ_ETOOSMALL;\n\n    /* Format fingerprint to \"SHA-256 XX:XX:XX...\" */\n    p = buf;\n    p += pj_ansi_snprintf(p, end-p, \"SHA-%s %.2X\", \n                          (is_sha256?\"256\":\"1\"), tmp[0]);\n    for (i=1; i<len; ++i)\n        p += pj_ansi_snprintf(p, end-p, \":%.2X\", tmp[i]);\n\n    *buf_len = st_out_len;\n\n    return PJ_SUCCESS;\n}\n\n/* Generate self-signed cert */\nstatic pj_status_t ssl_generate_cert(X509 **p_cert, EVP_PKEY **p_priv_key)\n{\n    BIGNUM *bne = NULL;\n    RSA *rsa_key = NULL;\n    X509_NAME *cert_name = NULL;\n    X509 *cert = NULL;\n    EVP_PKEY *priv_key = NULL;\n\n    /* Create big number */\n    bne = BN_new();\n    if (!bne) goto on_error;\n    if (!BN_set_word(bne, RSA_F4)) goto on_error;\n\n    /* Generate RSA key */\n    rsa_key = RSA_new();\n    if (!rsa_key) goto on_error;\n    if (!RSA_generate_key_ex(rsa_key, 2048, bne, NULL)) goto on_error;\n\n    /* Create private key */\n    priv_key = EVP_PKEY_new();\n    if (!priv_key) goto on_error;\n    if (!EVP_PKEY_assign_RSA(priv_key, rsa_key)) goto on_error;\n    rsa_key = NULL;\n\n    /* Create certificate */\n    cert = X509_new();\n    if (!cert) goto on_error;\n\n    /* Set version to 3 (2 = x509v3) */\n    X509_set_version(cert, 2);\n\n    /* Set serial number */\n    ASN1_INTEGER_set(X509_get_serialNumber(cert), pj_rand());\n\n    /* Set valid period */\n    X509_gmtime_adj(X509_get_notBefore(cert), -60*60*24);\n    X509_gmtime_adj(X509_get_notAfter(cert), 60*60*24*365);\n\n    /* Set subject name */\n    cert_name = X509_get_subject_name(cert);\n    if (!cert_name) goto on_error;\n    if (!X509_NAME_add_entry_by_txt(cert_name, \"CN\", MBSTRING_ASC,\n                                    (const unsigned char*)\"pjmedia.pjsip.org\",\n                                    -1, -1, 0)) goto on_error;\n\n    /* Set the issuer name (to subject name as this is self-signed cert) */\n    if (!X509_set_issuer_name(cert, cert_name)) goto on_error;\n\n    /* Set the public key */\n    if (!X509_set_pubkey(cert, priv_key)) goto on_error;\n\n    /* Sign with the private key */\n    if (!X509_sign(cert, priv_key, EVP_sha1())) goto on_error;\n\n    /* Free big number */\n    BN_free(bne);\n\n    *p_cert = cert;\n    *p_priv_key = priv_key;\n    return PJ_SUCCESS;\n\non_error:\n    if (bne) BN_free(bne);\n    if (rsa_key && !priv_key) RSA_free(rsa_key);\n    if (priv_key) EVP_PKEY_free(priv_key);\n    if (cert) X509_free(cert);\n    return PJ_EUNKNOWN;\n}\n\n/* Create and initialize new SSL context and instance */\nstatic pj_status_t ssl_create(dtls_srtp *ds, unsigned idx)\n{\n    SSL_CTX *ctx;\n    unsigned i;\n    int mode, rc;\n\n    /* Check if it is already instantiated */\n    if (ds->ossl_ssl[idx])\n        return PJ_SUCCESS;\n\n    /* Create DTLS context */\n    ctx = SSL_CTX_new(DTLS_method());\n    if (ctx == NULL) {\n        return GET_SSL_STATUS(ds);\n    }\n\n    if (valid_profiles_cnt == 0) {\n        SSL_CTX_free(ctx);\n        return PJMEDIA_SRTP_DTLS_ENOPROFILE;\n    }\n\n    /* Set crypto */\n    if (1) {\n        char *p, *end, buf[PJ_ARRAY_SIZE(ossl_profiles)*25];\n        unsigned n;\n\n        p = buf;\n        end = buf + sizeof(buf);\n        for (i=0; i<ds->srtp->setting.crypto_count && p < end; ++i) {\n            pjmedia_srtp_crypto *crypto = &ds->srtp->setting.crypto[i];\n            unsigned j;\n            for (j=0; j < valid_profiles_cnt; ++j) {\n                if (!pj_ansi_strcmp(crypto->name.ptr,\n                                    valid_pj_profiles_list[j]))\n                {\n                    n = pj_ansi_snprintf(p, end-p, \":%s\",\n                                         valid_ossl_profiles_list[j]);\n                    p += n;\n                    break;\n                }\n            }\n\n        }\n        rc = SSL_CTX_set_tlsext_use_srtp(ctx, buf+1);\n        PJ_LOG(4,(ds->base.name, \"Setting crypto [%s], errcode=%d\", buf, rc));\n        if (rc != 0) {\n            SSL_CTX_free(ctx);\n            return GET_SSL_STATUS(ds);\n        }\n    }\n\n    /* Set ciphers */\n    SSL_CTX_set_cipher_list(ctx, PJMEDIA_SRTP_DTLS_OSSL_CIPHERS);\n\n    /* Set cert & private key */\n    rc = SSL_CTX_use_certificate(ctx, dtls_cert);\n    pj_assert(rc);\n    rc = SSL_CTX_use_PrivateKey(ctx, dtls_priv_key);\n    pj_assert(rc);\n    rc = SSL_CTX_check_private_key(ctx);\n    pj_assert(rc);\n\n    /* Create SSL instance */\n    ds->ossl_ctx[idx] = ctx;\n    ds->ossl_ssl[idx] = SSL_new(ds->ossl_ctx[idx]);\n    if (ds->ossl_ssl[idx] == NULL) {\n        SSL_CTX_free(ctx);\n        return GET_SSL_STATUS(ds);\n    }\n\n    /* Set MTU */\n#ifdef DTLS_CTRL_SET_LINK_MTU\n    if (!SSL_ctrl(ds->ossl_ssl[idx], DTLS_CTRL_SET_LINK_MTU, PJMEDIA_MAX_MTU,\n                  NULL))\n    {\n        PJ_LOG(4, (ds->base.name,\n                  \"Ignored failure in setting MTU to %d (too small?)\",\n                  PJMEDIA_MAX_MTU));\n    }\n#endif\n\n    /* SSL verification options, must be mutual auth */\n    mode = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT;\n    SSL_set_verify(ds->ossl_ssl[idx], mode, &verify_cb);\n\n    /* Setup SSL BIOs */\n    ds->ossl_rbio[idx] = BIO_new(BIO_s_mem());\n    ds->ossl_wbio[idx] = BIO_new(BIO_s_mem());\n    (void)BIO_set_close(ds->ossl_rbio[idx], BIO_CLOSE);\n    (void)BIO_set_close(ds->ossl_wbio[idx], BIO_CLOSE);\n    SSL_set_bio(ds->ossl_ssl[idx], ds->ossl_rbio[idx], ds->ossl_wbio[idx]);\n\n    return PJ_SUCCESS;\n}\n\n\n/* Destroy SSL context and instance */\nstatic void ssl_destroy(dtls_srtp *ds, unsigned idx)\n{\n    pj_lock_acquire(ds->ossl_lock);\n\n    /* Destroy SSL instance */\n    if (ds->ossl_ssl[idx]) {\n        /**\n         * Avoid calling SSL_shutdown() if handshake wasn't completed.\n         * OpenSSL 1.0.2f complains if SSL_shutdown() is called during an\n         * SSL handshake, while previous versions always return 0.       \n         */\n        if (SSL_in_init(ds->ossl_ssl[idx]) == 0) {\n            SSL_shutdown(ds->ossl_ssl[idx]);\n        }\n        SSL_free(ds->ossl_ssl[idx]); /* this will also close BIOs */\n        ds->ossl_ssl[idx] = NULL;\n        /* thus reset the BIOs as well */\n        ds->ossl_rbio[idx] = NULL;\n        ds->ossl_wbio[idx] = NULL;\n    }\n\n    /* Destroy SSL context */\n    if (ds->ossl_ctx[idx]) {\n        SSL_CTX_free(ds->ossl_ctx[idx]);\n        ds->ossl_ctx[idx] = NULL;\n    }\n\n    pj_lock_release(ds->ossl_lock);\n}\n\nstatic pj_status_t ssl_get_srtp_material(dtls_srtp *ds, unsigned idx)\n{\n    unsigned char material[SRTP_MAX_KEY_LEN * 2];\n    SRTP_PROTECTION_PROFILE *profile;\n    int rc, i, crypto_idx = -1;\n    pjmedia_srtp_crypto *tx, *rx;\n    pj_status_t status = PJ_SUCCESS;\n\n    pj_lock_acquire(ds->ossl_lock);\n\n    if (!ds->ossl_ssl[idx]) {\n        status = PJ_EGONE;\n        goto on_return;\n    }\n\n    /* Get selected crypto-suite */\n    profile = SSL_get_selected_srtp_profile(ds->ossl_ssl[idx]);\n    if (!profile) {\n        status = PJMEDIA_SRTP_DTLS_ENOCRYPTO;\n        goto on_return;\n    }\n\n    tx = &ds->tx_crypto[idx];\n    rx = &ds->rx_crypto[idx];\n    pj_bzero(tx, sizeof(*tx));\n    pj_bzero(rx, sizeof(*rx));\n    for (i=0; i<(int)PJ_ARRAY_SIZE(ossl_profiles); ++i) {\n        if (pj_ansi_stricmp(profile->name, ossl_profiles[i])==0) {\n            pj_strset2(&tx->name, pj_profiles[i]);\n            pj_strset2(&rx->name, pj_profiles[i]);\n            crypto_idx = get_crypto_idx(&tx->name);\n            break;\n        }\n    }\n    if (crypto_idx == -1) {\n        status = PJMEDIA_SRTP_ENOTSUPCRYPTO;\n        goto on_return;\n    }\n\n    /* Get keying material from DTLS nego. There seems to be no info about\n     * material length returned by SSL_export_keying_material()?\n     */\n    rc = SSL_export_keying_material(ds->ossl_ssl[idx], material,\n                                    sizeof(material), \"EXTRACTOR-dtls_srtp\",\n                                    19, NULL, 0, 0);\n    if (rc == 0) {\n        status = PJMEDIA_SRTP_EINKEYLEN;\n        goto on_return;\n    }\n\n    /* Parse SRTP master key & salt from keying material */\n    {\n        char *p = (char*)material;\n        char *k1, *k2;\n        crypto_suite *cs = &crypto_suites[crypto_idx];\n        unsigned key_len, salt_len;\n\n        key_len = cs->cipher_key_len - cs->cipher_salt_len;\n        salt_len = cs->cipher_salt_len;\n\n        tx->key.ptr = (char*)pj_pool_alloc(ds->pool, key_len+salt_len);\n        tx->key.slen = key_len+salt_len;\n        rx->key.ptr = (char*)pj_pool_alloc(ds->pool, key_len+salt_len);\n        rx->key.slen = key_len+salt_len;\n        if (ds->setup == DTLS_SETUP_ACTIVE) {\n            k1 = tx->key.ptr;\n            k2 = rx->key.ptr;\n        } else {\n            k1 = rx->key.ptr;\n            k2 = tx->key.ptr;\n        }\n        pj_memcpy(k1, p, key_len); p += key_len;\n        pj_memcpy(k2, p, key_len); p += key_len;\n        pj_memcpy(k1+key_len, p, salt_len); p += salt_len;\n        pj_memcpy(k2+key_len, p, salt_len);\n        ds->got_keys = PJ_TRUE;\n    }\n\non_return:\n    pj_lock_release(ds->ossl_lock);\n    return status;\n}\n\n/* Match remote fingerprint: SDP vs actual */\nstatic pj_status_t ssl_match_fingerprint(dtls_srtp *ds, unsigned idx)\n{\n    X509 *rem_cert;\n    pj_bool_t is_sha256;\n    char buf[128];\n    pj_size_t buf_len = sizeof(buf);\n    pj_status_t status;\n\n    /* Check hash algo, currently we only support SHA-256 & SHA-1 */\n    if (!pj_strnicmp2(&ds->rem_fingerprint, \"SHA-256 \", 8))\n        is_sha256 = PJ_TRUE;\n    else if (!pj_strnicmp2(&ds->rem_fingerprint, \"SHA-1 \", 6))\n        is_sha256 = PJ_FALSE;\n    else {\n        PJ_LOG(4,(ds->base.name, \"Hash algo specified in remote SDP for \"\n                  \"its DTLS certificate fingerprint is not supported\"));\n        return PJ_ENOTSUP;\n    }\n\n    pj_lock_acquire(ds->ossl_lock);\n    if (!ds->ossl_ssl[idx]) {\n        pj_lock_release(ds->ossl_lock);\n        return PJ_EGONE;\n    }\n\n    /* Get remote cert & calculate the hash */\n    rem_cert = SSL_get_peer_certificate(ds->ossl_ssl[idx]);\n\n    pj_lock_release(ds->ossl_lock);\n\n    if (!rem_cert)\n        return PJMEDIA_SRTP_DTLS_EPEERNOCERT;\n\n    status = ssl_get_fingerprint(rem_cert, is_sha256, buf, &buf_len);\n    X509_free(rem_cert);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Do they match? */\n    if (pj_stricmp2(&ds->rem_fingerprint, buf))\n        return PJMEDIA_SRTP_DTLS_EFPNOTMATCH;\n\n    return PJ_SUCCESS;\n}\n\n\n/* Send data to network */\nstatic pj_status_t send_raw(dtls_srtp *ds, unsigned idx, const void *buf,\n                            pj_size_t len)\n{\n#if DTLS_DEBUG\n    PJ_LOG(2,(ds->base.name, \"DTLS-SRTP %s sending %lu bytes\",\n                             CHANNEL_TO_STRING(idx), len));\n#endif\n\n    return (idx == RTP_CHANNEL?\n            pjmedia_transport_send_rtp(ds->srtp->member_tp, buf, len):\n            pjmedia_transport_send_rtcp(ds->srtp->member_tp, buf, len));\n}\n\n\n/* Start socket if member transport is UDP */\nstatic pj_status_t udp_member_transport_media_start(dtls_srtp *ds)\n{\n    pjmedia_transport_info info;\n    pj_status_t status;\n\n    if (!ds->srtp->member_tp)\n        return PJ_SUCCESS;\n\n    pjmedia_transport_info_init(&info);\n    status = pjmedia_transport_get_info(ds->srtp->member_tp, &info);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    if (info.specific_info_cnt == 1 &&\n        info.spc_info[0].type == PJMEDIA_TRANSPORT_TYPE_UDP)\n    {\n        return pjmedia_transport_media_start(ds->srtp->member_tp, 0, 0, 0, 0);\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/* Flush write BIO */\nstatic pj_status_t ssl_flush_wbio(dtls_srtp *ds, unsigned idx)\n{\n    pj_size_t len;\n    pj_status_t status = PJ_SUCCESS;\n\n    pj_lock_acquire(ds->ossl_lock);\n\n    if (!ds->ossl_wbio[idx]) {\n        pj_lock_release(ds->ossl_lock);\n        return PJ_EGONE;\n    }\n\n    /* Check whether there is data to send */\n    if (BIO_ctrl_pending(ds->ossl_wbio[idx]) > 0) {\n        /* Yes, get and send it */\n        len = BIO_read(ds->ossl_wbio[idx], ds->buf[idx], sizeof(ds->buf));\n        if (len > 0) {\n            pj_lock_release(ds->ossl_lock);\n\n            status = send_raw(ds, idx, ds->buf[idx], len);\n            if (status != PJ_SUCCESS) {\n#if DTLS_DEBUG\n                pj_perror(2, ds->base.name, status, \"Send error\");\n#endif\n                /* This error should be recoverable, remote will retransmit\n                 * its packet when not receiving from us.\n                 */\n            }\n            pj_lock_acquire(ds->ossl_lock);\n        }\n    }\n\n    if (!ds->ossl_ssl[idx]) {\n        pj_lock_release(ds->ossl_lock);\n        return PJ_EGONE;\n    }\n\n    /* Just return if handshake completion procedure (key parsing, fingerprint\n     * verification, etc) has been done or handshake is still in progress.\n     */\n    if (ds->nego_completed[idx] || !SSL_is_init_finished(ds->ossl_ssl[idx])) {\n        pj_lock_release(ds->ossl_lock);\n        return PJ_SUCCESS;\n    }\n\n    /* Yes, SSL handshake is done! */\n    ds->nego_completed[idx] = PJ_TRUE;\n    PJ_LOG(2,(ds->base.name, \"DTLS-SRTP negotiation for %s completed!\",\n                             CHANNEL_TO_STRING(idx)));\n\n    pj_lock_release(ds->ossl_lock);\n\n    /* Stop the retransmission clock. Note that the clock may not be stopped\n     * if this function is called from clock thread context. We'll try again\n     * later in socket context.\n     */\n    if (ds->clock[idx])\n        pjmedia_clock_stop(ds->clock[idx]);\n\n    /* Get SRTP key material */\n    status = ssl_get_srtp_material(ds, idx);\n    if (status != PJ_SUCCESS) {\n        pj_perror(4, ds->base.name, status,\n                  \"Failed to get SRTP material\");\n        goto on_return;\n    }\n\n    /* Verify remote fingerprint if we've already got one from SDP */\n    if (ds->rem_fingerprint.slen && ds->rem_fprint_status == PJ_EPENDING) {\n        ds->rem_fprint_status = status = ssl_match_fingerprint(ds, idx);\n        if (status != PJ_SUCCESS) {\n            pj_perror(4, ds->base.name, status,\n                      \"Fingerprint specified in remote SDP doesn't match \"\n                      \"to actual remote certificate fingerprint!\");\n            goto on_return;\n        }\n    }\n\n    /* If media_start() has been called, start SRTP now */\n    if (ds->pending_start && idx == RTP_CHANNEL) {\n        ds->pending_start = PJ_FALSE;\n        ds->srtp->keying_pending_cnt--;\n\n        /* Copy negotiated policy to SRTP */\n        ds->srtp->srtp_ctx.tx_policy_neg = ds->tx_crypto[idx];\n        ds->srtp->srtp_ctx.rx_policy_neg = ds->rx_crypto[idx];\n\n        status = start_srtp(ds->srtp);\n        if (status != PJ_SUCCESS)\n            pj_perror(4, ds->base.name, status, \"Failed starting SRTP\");\n    } else if (idx == RTCP_CHANNEL) {\n        pjmedia_srtp_setting setting;\n\n        pjmedia_srtp_setting_default (&setting);\n\n        /* Copy negotiated policy to SRTP */\n        ds->srtp->srtp_rtcp.tx_policy_neg = ds->tx_crypto[idx];\n        ds->srtp->srtp_rtcp.rx_policy_neg = ds->rx_crypto[idx];\n\n        status = create_srtp_ctx(ds->srtp, &ds->srtp->srtp_rtcp,\n                                 &setting, &ds->srtp->srtp_rtcp.tx_policy_neg,\n                                 &ds->srtp->srtp_rtcp.rx_policy_neg);\n        if (status != PJ_SUCCESS)\n            pj_perror(4, ds->base.name, status, \"Failed creating SRTP RTCP\");\n    }\n\non_return:\n    if (idx == RTP_CHANNEL && ds->srtp->setting.cb.on_srtp_nego_complete) {\n        (*ds->srtp->setting.cb.on_srtp_nego_complete)\n                                            (&ds->srtp->base, status);\n    }\n\n    return status;\n}\n\n\nstatic void clock_cb(const pj_timestamp *ts, void *user_data)\n{\n    dtls_srtp_channel *ds_ch = (dtls_srtp_channel*)user_data;\n    dtls_srtp *ds = ds_ch->dtls_srtp;\n    unsigned idx = ds_ch->channel;\n\n    PJ_UNUSED_ARG(ts);\n\n    pj_lock_acquire(ds->ossl_lock);\n\n    if (!ds->ossl_ssl[idx]) {\n        pj_lock_release(ds->ossl_lock);\n        return;\n    }\n\n    if (DTLSv1_handle_timeout(ds->ossl_ssl[idx]) > 0) {\n        pj_lock_release(ds->ossl_lock);\n        ssl_flush_wbio(ds, idx);\n    } else {\n        pj_lock_release(ds->ossl_lock);\n    }\n}\n\n\n/* Asynchronous handshake */\nstatic pj_status_t ssl_handshake_channel(dtls_srtp *ds, unsigned idx)\n{\n    pj_status_t status;\n    int err;\n\n    pj_lock_acquire(ds->ossl_lock);\n\n    /* Init DTLS (if not yet) */\n    status = ssl_create(ds, idx);\n    if (status != PJ_SUCCESS) {\n        pj_lock_release(ds->ossl_lock);\n        return status;\n    }\n\n    /* Check if handshake has been initiated or even completed */\n    if (ds->nego_started[idx] || SSL_is_init_finished(ds->ossl_ssl[idx])) {\n        pj_lock_release(ds->ossl_lock);\n        return PJ_SUCCESS;\n    }\n\n    /* Perform SSL handshake */\n    if (ds->setup == DTLS_SETUP_ACTIVE) {\n        SSL_set_connect_state(ds->ossl_ssl[idx]);\n    } else {\n        SSL_set_accept_state(ds->ossl_ssl[idx]);\n    }\n    err = SSL_do_handshake(ds->ossl_ssl[idx]);\n    if (err < 0) {\n        err = SSL_get_error(ds->ossl_ssl[idx], err);\n\n        pj_lock_release(ds->ossl_lock);\n\n        if (err == SSL_ERROR_WANT_READ) {\n            status = ssl_flush_wbio(ds, idx);\n            if (status != PJ_SUCCESS)\n                goto on_return;\n        } else if (err != SSL_ERROR_NONE) {\n            /* Handshake fails */\n            status = STATUS_FROM_SSL_ERR(ds, err);\n            pj_perror(2, ds->base.name, status, \"SSL_do_handshake() error\");\n            goto on_return;\n        }\n    } else {\n        pj_lock_release(ds->ossl_lock);\n    }\n\n    /* Create and start clock @4Hz for retransmission */\n    if (!ds->clock[idx]) {\n        ds->channel[idx].dtls_srtp = ds;\n        ds->channel[idx].channel = idx;\n        status = pjmedia_clock_create(ds->pool, 4, 1, 1,\n                                      PJMEDIA_CLOCK_NO_HIGHEST_PRIO, clock_cb,\n                                      &ds->channel[idx], &ds->clock[idx]);\n        if (status != PJ_SUCCESS)\n            goto on_return;\n    }    \n    status = pjmedia_clock_start(ds->clock[idx]);\n    if (status != PJ_SUCCESS)\n        goto on_return;\n\n    /* Finally, DTLS nego started! */\n    ds->nego_started[idx] = PJ_TRUE;\n    PJ_LOG(4,(ds->base.name, \"DTLS-SRTP %s negotiation initiated as %s\",\n              CHANNEL_TO_STRING(idx),\n              (ds->setup==DTLS_SETUP_ACTIVE? \"client\":\"server\")));\n\non_return:\n    if (status != PJ_SUCCESS) {\n        if (ds->clock[idx])\n            pjmedia_clock_stop(ds->clock[idx]);\n    }\n    return status;\n}\n\nstatic pj_status_t ssl_handshake(dtls_srtp *ds)\n{\n    pj_status_t status;\n\n    status = ssl_handshake_channel(ds, RTP_CHANNEL);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    if (!ds->srtp->use_rtcp_mux)\n        status = ssl_handshake_channel(ds, RTCP_CHANNEL);\n\n    return status;\n}\n\n/* Parse a=setup & a=fingerprint in remote SDP to update DTLS-SRTP states\n * 'setup' and 'rem_fingerprint'.\n * TODO: check those attributes in a=acap too?\n */\nstatic pj_status_t parse_setup_finger_attr(dtls_srtp *ds,\n                                           pj_bool_t rem_as_offerer,\n                                           const pjmedia_sdp_session *sdp,\n                                           unsigned media_index)\n{\n    pjmedia_sdp_media *m;\n    pjmedia_sdp_attr *a;\n\n    m = sdp->media[media_index];\n\n    /* Parse a=setup */\n    a = pjmedia_sdp_media_find_attr(m, &ID_SETUP, NULL);\n    if (!a)\n        a = pjmedia_sdp_attr_find(sdp->attr_count,\n                                  sdp->attr, &ID_SETUP, NULL);\n    if (!a)\n        return PJMEDIA_SRTP_ESDPAMBIGUEANS;\n\n    if (pj_stristr(&a->value, &ID_PASSIVE) ||\n        (rem_as_offerer && pj_stristr(&a->value, &ID_ACTPASS)))\n    {\n        /* Remote offers/answers 'passive' (or offers 'actpass'), so we are\n         * the client.\n         */\n        ds->setup = DTLS_SETUP_ACTIVE;\n    } else if (pj_stristr(&a->value, &ID_ACTIVE)) {\n        /* Remote offers/answers 'active' so we are the server. */\n        ds->setup = DTLS_SETUP_PASSIVE;\n    } else {\n        /* Unknown value set in remote a=setup */\n        return PJMEDIA_SRTP_ESDPAMBIGUEANS;\n    }\n\n    /* Parse a=fingerprint */\n    a = pjmedia_sdp_media_find_attr(m, &ID_FINGERPRINT, NULL);\n    if (!a)\n        a = pjmedia_sdp_attr_find(sdp->attr_count,\n                                  sdp->attr, &ID_FINGERPRINT,\n                                  NULL);\n    if (!a) {\n        /* No fingerprint attribute in remote SDP */\n        return PJMEDIA_SRTP_DTLS_ENOFPRINT;\n    } else {\n        pj_str_t rem_fp = a->value;\n        pj_strtrim(&rem_fp);\n        if (pj_stricmp(&ds->rem_fingerprint, &rem_fp))\n            pj_strdup(ds->pool, &ds->rem_fingerprint, &rem_fp);\n    }\n\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t get_rem_addrs(dtls_srtp *ds,\n                                 const pjmedia_sdp_session *sdp_remote,\n                                 unsigned media_index,\n                                 pj_sockaddr *rem_rtp,\n                                 pj_sockaddr *rem_rtcp,\n                                 pj_bool_t *rtcp_mux)\n{\n    pjmedia_sdp_media *m_rem = sdp_remote->media[media_index];\n    pjmedia_sdp_conn *conn;\n    pjmedia_sdp_attr *a;\n    int af = pj_AF_UNSPEC();\n    pj_bool_t use_ice_info = PJ_FALSE;\n\n    /* Init RTP & RTCP address */\n    pj_bzero(rem_rtp, sizeof(*rem_rtp));\n    pj_bzero(rem_rtcp, sizeof(*rem_rtcp));\n\n    /* If underlying transport is ICE, get remote addresses from ICE */\n    if (ds->use_ice) {\n        pjmedia_transport_info info;\n        pjmedia_ice_transport_info *ice_info;\n\n        pjmedia_transport_info_init(&info);\n        pjmedia_transport_get_info(ds->srtp->member_tp, &info);\n        ice_info = (pjmedia_ice_transport_info*)\n                   pjmedia_transport_info_get_spc_info(\n                                    &info, PJMEDIA_TRANSPORT_TYPE_ICE);\n        if (ice_info) {\n            *rem_rtp = ice_info->comp[0].rcand_addr;\n            if (ice_info->comp_cnt > 1)\n                *rem_rtcp = ice_info->comp[1].rcand_addr;\n\n            use_ice_info = PJ_TRUE;\n        }\n    }\n\n    /* Get remote addresses from SDP */\n    if (!use_ice_info) {\n\n        /* Get RTP address */\n        conn = m_rem->conn ? m_rem->conn : sdp_remote->conn;\n        if (pj_stricmp2(&conn->net_type, \"IN\")==0) {\n            if (pj_stricmp2(&conn->addr_type, \"IP4\")==0) {\n                af = pj_AF_INET();\n            } else if (pj_stricmp2(&conn->addr_type, \"IP6\")==0) {\n                af = pj_AF_INET6();\n            }\n        }\n        if (af != pj_AF_UNSPEC()) {\n            pj_sockaddr_init(af, rem_rtp, &conn->addr,\n                             m_rem->desc.port);\n        } else {\n            return PJ_EAFNOTSUP;\n        }\n\n        /* Get RTCP address. If \"rtcp\" attribute is present in the SDP,\n         * set the RTCP address from that attribute. Otherwise, calculate\n         * from RTP address.\n         */\n        a = pjmedia_sdp_attr_find2(m_rem->attr_count, m_rem->attr,\n                                   \"rtcp\", NULL);\n        if (a) {\n            pjmedia_sdp_rtcp_attr rtcp;\n            pj_status_t status;\n            status = pjmedia_sdp_attr_get_rtcp(a, &rtcp);\n            if (status == PJ_SUCCESS) {\n                if (rtcp.addr.slen) {\n                    pj_sockaddr_init(af, rem_rtcp, &rtcp.addr,\n                                     (pj_uint16_t)rtcp.port);\n                } else {\n                    pj_sockaddr_init(af, rem_rtcp, NULL,\n                                     (pj_uint16_t)rtcp.port);\n                    pj_memcpy(pj_sockaddr_get_addr(rem_rtcp),\n                              pj_sockaddr_get_addr(rem_rtp),\n                              pj_sockaddr_get_addr_len(rem_rtp));\n                }\n            }\n        }\n        if (!pj_sockaddr_has_addr(rem_rtcp)) {\n            int rtcp_port;\n            pj_memcpy(rem_rtcp, rem_rtp, sizeof(pj_sockaddr));\n            rtcp_port = pj_sockaddr_get_port(rem_rtp) + 1;\n            pj_sockaddr_set_port(rem_rtcp, (pj_uint16_t)rtcp_port);\n        }\n    }\n\n    /* Check if remote indicates the desire to use rtcp-mux in its SDP. */\n    if (rtcp_mux) {\n        a = pjmedia_sdp_attr_find2(m_rem->attr_count, m_rem->attr,\n                                   \"rtcp-mux\", NULL);\n        *rtcp_mux = (a? PJ_TRUE: PJ_FALSE);\n    }\n\n    return PJ_SUCCESS;\n}\n\n/* Check if an incoming packet is a DTLS packet (rfc5764 section 5.1.2) */\n#define IS_DTLS_PKT(pkt, pkt_len) (*(char*)pkt > 19 && *(char*)pkt < 64)\n\n\n/* Received packet (SSL handshake) from socket */\nstatic pj_status_t ssl_on_recv_packet(dtls_srtp *ds, unsigned idx,\n                                      const void *data, pj_size_t len)\n{\n    char tmp[128];\n    pj_size_t nwritten;\n\n    pj_lock_acquire(ds->ossl_lock);\n\n    if (!ds->ossl_rbio[idx]) {\n        pj_lock_release(ds->ossl_lock);\n        return PJ_EGONE;\n    }\n\n    nwritten = BIO_write(ds->ossl_rbio[idx], data, (int)len);\n    if (nwritten < len) {\n        /* Error? */\n        pj_status_t status;\n        status = GET_SSL_STATUS(ds);\n#if DTLS_DEBUG\n        pj_perror(2, ds->base.name, status, \"BIO_write() error\");\n#endif\n        pj_lock_release(ds->ossl_lock);\n        return status;\n    }\n\n    if (!ds->ossl_ssl[idx]) {\n        pj_lock_release(ds->ossl_lock);\n        return PJ_EGONE;\n    }\n\n    /* Consume (and ignore) the packet */\n    while (1) {\n        int rc = SSL_read(ds->ossl_ssl[idx], tmp, sizeof(tmp));\n        if (rc <= 0) {\n#if DTLS_DEBUG\n            pj_status_t status = GET_SSL_STATUS(ds);\n            if (status != PJ_SUCCESS)\n                pj_perror(2, ds->base.name, status, \"SSL_read() error\");\n#endif\n            break;\n        }\n    }\n\n    pj_lock_release(ds->ossl_lock);\n\n    /* Flush anything pending in the write BIO */\n    return ssl_flush_wbio(ds, idx);\n}\n\n\nstatic void on_ice_complete2(pjmedia_transport *tp,\n                             pj_ice_strans_op op,\n                             pj_status_t status,\n                             void *user_data)\n{\n    dtls_srtp *ds = (dtls_srtp*)user_data;\n    pj_assert(ds);\n\n    PJ_UNUSED_ARG(tp);\n\n    if (op == PJ_ICE_STRANS_OP_NEGOTIATION && status == PJ_SUCCESS &&\n        ds->setup == DTLS_SETUP_ACTIVE)\n    {\n        pj_status_t tmp_st;\n        tmp_st = ssl_handshake(ds);\n        if (tmp_st != PJ_SUCCESS)\n            pj_perror(4, ds->base.name, tmp_st, \"Failed starting DTLS nego\");\n    }\n}\n\n\n/* *************************************\n *\n * DTLS-SRTP transport keying operations\n *\n * *************************************/\n\nstatic pj_status_t dtls_on_recv(pjmedia_transport *tp, unsigned idx,     \n                                const void *pkt, pj_size_t size)\n{\n    dtls_srtp *ds = (dtls_srtp*)tp;\n\n    /* Destroy the retransmission clock if handshake has been completed. */\n    if (ds->clock[idx] && ds->nego_completed[idx]) {\n        pjmedia_clock_destroy(ds->clock[idx]);\n        ds->clock[idx] = NULL;\n    }\n\n    if (size < 1 || !IS_DTLS_PKT(pkt, size))\n        return PJ_EIGNORED;\n\n#if DTLS_DEBUG\n    PJ_LOG(2,(ds->base.name, \"DTLS-SRTP %s receiving %lu bytes\",\n                             CHANNEL_TO_STRING(idx), size));\n#endif\n\n    /* This is DTLS packet, let's process it. Note that if DTLS nego has\n     * been completed, this may be a retransmission (e.g: remote didn't\n     * receive our last handshake packet) or just a stray.\n     */\n\n    /* Check remote address info, reattach member tp if changed */\n    if (idx == RTP_CHANNEL && !ds->use_ice && !ds->nego_completed[idx]) {\n        pjmedia_transport_info info;\n        pjmedia_transport_get_info(ds->srtp->member_tp, &info);\n        if (pj_sockaddr_cmp(&ds->rem_addr, &info.src_rtp_name)) {\n            pjmedia_transport_attach_param ap;\n            pj_status_t status;\n\n            pj_bzero(&ap, sizeof(ap));\n            ap.user_data = ds->srtp;\n            pj_sockaddr_cp(&ds->rem_addr, &info.src_rtp_name);\n            pj_sockaddr_cp(&ap.rem_addr, &ds->rem_addr);\n            ap.addr_len = pj_sockaddr_get_len(&ap.rem_addr);\n            if (pj_sockaddr_cmp(&info.sock_info.rtp_addr_name,\n                                &info.sock_info.rtcp_addr_name) == 0)\n            {\n                /* Using RTP & RTCP multiplexing */\n                pj_sockaddr_cp(&ds->rem_rtcp, &ds->rem_addr);\n                pj_sockaddr_cp(&ap.rem_rtcp, &ds->rem_rtcp);\n            } else if (pj_sockaddr_has_addr(&ds->rem_rtcp)) {\n                pj_sockaddr_cp(&ap.rem_rtcp, &ds->rem_rtcp);\n            } else {\n                pj_sockaddr_cp(&ap.rem_rtcp, &ds->rem_addr);\n                pj_sockaddr_set_port(&ap.rem_rtcp,\n                                     pj_sockaddr_get_port(&ds->rem_addr)+1);\n            }\n\n            status = pjmedia_transport_attach2(&ds->srtp->base, &ap);\n            if (status != PJ_SUCCESS)\n                return status;\n\n#if DTLS_DEBUG\n            {\n                char addr[PJ_INET6_ADDRSTRLEN];\n                PJ_LOG(2,(ds->base.name, \"Re-attached transport to update \"\n                          \"remote addr=%s:%d\",\n                          pj_sockaddr_print(&ap.rem_addr, addr,\n                                            sizeof(addr), 2),\n                          pj_sockaddr_get_port(&ap.rem_addr)));\n            }\n#endif\n        }\n    }\n\n    /* If our setup is ACTPASS, incoming packet may be a client hello,\n     * so let's update setup to PASSIVE and initiate DTLS handshake.\n     */\n    if (!ds->nego_started[idx] &&\n        (ds->setup == DTLS_SETUP_ACTPASS || ds->setup == DTLS_SETUP_PASSIVE))\n    {\n        pj_status_t status;\n        ds->setup = DTLS_SETUP_PASSIVE;\n        status = ssl_handshake_channel(ds, idx);\n        if (status != PJ_SUCCESS)\n            return status;\n    }\n\n    /* Send it to OpenSSL */\n    ssl_on_recv_packet(ds, idx, pkt, size);\n    return PJ_SUCCESS;\n}\n\n/*\n * This callback is called by SRTP transport when incoming rtp is received.\n * Originally this is send_rtp() op.\n */\nstatic pj_status_t dtls_on_recv_rtp( pjmedia_transport *tp,\n                                     const void *pkt,\n                                     pj_size_t size)\n{\n    return dtls_on_recv(tp, RTP_CHANNEL, pkt, size);\n}\n\n/*\n * This callback is called by SRTP transport when incoming rtcp is received.\n * Originally this is send_rtcp() op.\n */\nstatic pj_status_t dtls_on_recv_rtcp(pjmedia_transport *tp,\n                                     const void *pkt,\n                                     pj_size_t size)\n{\n    return dtls_on_recv(tp, RTCP_CHANNEL, pkt, size);\n}\n\nstatic pj_status_t dtls_media_create( pjmedia_transport *tp,\n                                      pj_pool_t *sdp_pool,\n                                      unsigned options,\n                                      const pjmedia_sdp_session *sdp_remote,\n                                      unsigned media_index)\n{\n    dtls_srtp *ds = (dtls_srtp*) tp;\n    pj_status_t status = PJ_SUCCESS;\n\n#if DTLS_DEBUG\n    PJ_LOG(2,(ds->base.name, \"dtls_media_create()\"));\n#endif\n\n    PJ_UNUSED_ARG(sdp_pool);\n    PJ_UNUSED_ARG(options);\n\n    if (ds->srtp->offerer_side) {\n        /* As offerer: do nothing. */\n    } else {\n        /* As answerer:\n         *    Check for DTLS-SRTP support in remote SDP. Detect remote\n         *    support of DTLS-SRTP by inspecting remote SDP offer for\n         *    SDP a=fingerprint attribute. And currently we only support\n         *    RTP/AVP transports.\n         */\n        pjmedia_sdp_media *m_rem = sdp_remote->media[media_index];\n        pjmedia_sdp_attr *attr_fp;\n        pj_uint32_t rem_proto = 0;\n\n        /* Find SDP a=fingerprint line. */\n        attr_fp = pjmedia_sdp_media_find_attr(m_rem, &ID_FINGERPRINT, NULL);\n        if (!attr_fp)\n            attr_fp = pjmedia_sdp_attr_find(sdp_remote->attr_count,\n                                            sdp_remote->attr, &ID_FINGERPRINT,\n                                            NULL);\n\n        /* Get media transport proto */\n        rem_proto = pjmedia_sdp_transport_get_proto(&m_rem->desc.transport);\n        if (!PJMEDIA_TP_PROTO_HAS_FLAG(rem_proto, PJMEDIA_TP_PROTO_RTP_AVP) ||\n            !attr_fp)\n        {\n            /* Remote doesn't signal DTLS-SRTP */\n            status = PJMEDIA_SRTP_ESDPINTRANSPORT;\n            goto on_return;\n        }\n\n        /* Check for a=fingerprint in remote SDP. */\n        switch (ds->srtp->setting.use) {\n            case PJMEDIA_SRTP_DISABLED:\n                status = PJMEDIA_SRTP_ESDPINTRANSPORT;\n                goto on_return;\n                break;\n            case PJMEDIA_SRTP_OPTIONAL:\n                break;\n            case PJMEDIA_SRTP_MANDATORY:\n                break;\n        }\n    }\n\n    /* Set remote cert fingerprint verification status to PJ_EPENDING */\n    ds->rem_fprint_status = PJ_EPENDING;\n\non_return:\n#if DTLS_DEBUG\n    if (status != PJ_SUCCESS) {\n        pj_perror(4, ds->base.name, status, \"dtls_media_create() failed\");\n    }\n#endif\n    return status;\n}\n\nstatic void dtls_media_stop_channel(dtls_srtp *ds, unsigned idx)\n{\n    if (ds->clock[idx])\n        pjmedia_clock_stop(ds->clock[idx]);\n\n    /* Reset DTLS state */\n    ssl_destroy(ds, idx);\n    ds->nego_started[idx] = PJ_FALSE;\n    ds->nego_completed[idx] = PJ_FALSE;\n}\n\nstatic pj_status_t dtls_encode_sdp( pjmedia_transport *tp,\n                                    pj_pool_t *sdp_pool,\n                                    pjmedia_sdp_session *sdp_local,\n                                    const pjmedia_sdp_session *sdp_remote,\n                                    unsigned media_index)\n{\n    dtls_srtp *ds = (dtls_srtp *)tp;\n    pjmedia_sdp_media *m_loc;\n    pjmedia_sdp_attr *a;\n    pj_bool_t use_ice = PJ_FALSE;\n    pj_status_t status = PJ_SUCCESS;\n\n#if DTLS_DEBUG\n    PJ_LOG(2,(ds->base.name, \"dtls_encode_sdp()\"));\n#endif\n\n    PJ_UNUSED_ARG(sdp_pool);\n\n    m_loc = sdp_local->media[media_index];\n    if (ds->srtp->offerer_side) {\n        /* As offerer */\n\n        /* Add attribute a=setup if none (rfc5763 section 5) */\n        a = pjmedia_sdp_media_find_attr(m_loc, &ID_SETUP, NULL);\n        if (!a)\n            a = pjmedia_sdp_attr_find(sdp_local->attr_count,\n                                      sdp_local->attr, &ID_SETUP, NULL);\n        if (!a) {\n            pj_str_t val;\n\n            if (ds->setup == DTLS_SETUP_UNKNOWN)\n                ds->setup = DTLS_SETUP_ACTPASS;\n            \n            if (ds->setup == DTLS_SETUP_ACTIVE)\n                val = ID_ACTIVE;\n            else if (ds->setup == DTLS_SETUP_PASSIVE)\n                val = ID_PASSIVE;\n            else\n                val = ID_ACTPASS;\n            a = pjmedia_sdp_attr_create(ds->pool, ID_SETUP.ptr, &val);\n            pjmedia_sdp_media_add_attr(m_loc, a);\n        }\n    } else {\n        /* As answerer */\n        dtls_setup last_setup = ds->setup;\n        pj_str_t last_rem_fp = ds->rem_fingerprint;\n        pj_bool_t rem_addr_changed = PJ_FALSE;\n\n        /* Parse a=setup and a=fingerprint */\n        status = parse_setup_finger_attr(ds, PJ_TRUE, sdp_remote,\n                                         media_index);\n        if (status != PJ_SUCCESS)\n            goto on_return;\n\n        /* Add attribute a=setup:active/passive if we are client/server. */\n        a = pjmedia_sdp_attr_create(ds->pool, ID_SETUP.ptr,\n                    (ds->setup==DTLS_SETUP_ACTIVE? &ID_ACTIVE:&ID_PASSIVE));\n        pjmedia_sdp_media_add_attr(m_loc, a);\n\n        if (last_setup != DTLS_SETUP_UNKNOWN) {\n            pj_sockaddr rem_rtp;\n            pj_sockaddr rem_rtcp;\n            pj_bool_t use_rtcp_mux;\n\n            status = get_rem_addrs(ds, sdp_remote, media_index, &rem_rtp,\n                                   &rem_rtcp, &use_rtcp_mux);\n            if (status == PJ_SUCCESS) {\n                if (use_rtcp_mux) {\n                    /* Remote indicates it wants to use rtcp-mux */\n                    pjmedia_transport_info info;\n\n                    pjmedia_transport_info_init(&info);\n                    pjmedia_transport_get_info(ds->srtp->member_tp, &info);\n                    if (pj_sockaddr_cmp(&info.sock_info.rtp_addr_name,\n                        &info.sock_info.rtcp_addr_name))\n                    {\n                        /* But we do not wish to use rtcp mux */\n                        use_rtcp_mux = PJ_FALSE;\n                    }\n                }\n                if (pj_sockaddr_has_addr(&ds->rem_addr) &&\n                    pj_sockaddr_has_addr(&rem_rtp) &&\n                    (pj_sockaddr_cmp(&ds->rem_addr, &rem_rtp) ||\n                     (!use_rtcp_mux &&\n                      pj_sockaddr_has_addr(&ds->rem_rtcp) &&\n                      pj_sockaddr_has_addr(&rem_rtcp) &&\n                      pj_sockaddr_cmp(&ds->rem_rtcp, &rem_rtcp))))\n                {\n                    rem_addr_changed = PJ_TRUE;\n                }\n            }\n        }\n\n        /* Check if remote signals DTLS re-nego by changing its\n         * setup/fingerprint in SDP or media transport address in SDP.\n         */\n        if ((last_setup != DTLS_SETUP_UNKNOWN && last_setup != ds->setup) ||\n            (last_rem_fp.slen &&\n             pj_memcmp(&last_rem_fp, &ds->rem_fingerprint, sizeof(pj_str_t)))||\n            (rem_addr_changed))\n        {\n            dtls_media_stop_channel(ds, RTP_CHANNEL);\n            dtls_media_stop_channel(ds, RTCP_CHANNEL);\n            ds->got_keys = PJ_FALSE;\n            ds->rem_fprint_status = PJ_EPENDING;\n        }\n    }\n\n    /* Set media transport to UDP/TLS/RTP/SAVP if we are the offerer,\n     * otherwise just match it to the offer (currently we only accept\n     * UDP/TLS/RTP/SAVP in remote offer though).\n     */\n    if (ds->srtp->offerer_side) {\n        m_loc->desc.transport = ID_TP_DTLS_SRTP;\n    } else {\n        m_loc->desc.transport = \n                            sdp_remote->media[media_index]->desc.transport;\n    }\n\n    /* Add a=fingerprint attribute, fingerprint of our TLS certificate */\n    {\n        char buf[128];\n        pj_size_t buf_len = sizeof(buf);\n        pj_str_t fp;\n\n        status = ssl_get_fingerprint(dtls_cert, PJ_TRUE, buf, &buf_len);\n        if (status != PJ_SUCCESS)\n            goto on_return;\n\n        pj_strset(&fp, buf, buf_len);\n        a = pjmedia_sdp_attr_create(ds->pool, ID_FINGERPRINT.ptr, &fp);\n        pjmedia_sdp_media_add_attr(m_loc, a);\n    }\n\n    if (ds->nego_completed[RTP_CHANNEL]) {\n        /* This is subsequent SDP offer/answer and no DTLS re-nego has been\n         * signalled.\n         */\n        goto on_return;\n    }\n\n    /* Attach member transport, so we can receive DTLS init (if our setup\n     * is PASSIVE/ACTPASS) or send DTLS init (if our setup is ACTIVE).\n     */\n    {\n        pjmedia_transport_attach_param ap;\n        pjmedia_transport_info info;\n\n        pj_bzero(&ap, sizeof(ap));\n        ap.user_data = ds->srtp;\n        pjmedia_transport_get_info(ds->srtp->member_tp, &info);\n\n        if (sdp_remote) {\n            get_rem_addrs(ds, sdp_remote, media_index, &ds->rem_addr,\n                          &ds->rem_rtcp, NULL);\n        }\n\n        if (pj_sockaddr_has_addr(&ds->rem_addr)) {\n            pj_sockaddr_cp(&ap.rem_addr, &ds->rem_addr);\n        } else if (pj_sockaddr_has_addr(&info.sock_info.rtp_addr_name)) {\n            pj_sockaddr_cp(&ap.rem_addr, &info.sock_info.rtp_addr_name);\n        } else {\n            pj_sockaddr_init(pj_AF_INET(), &ap.rem_addr, 0, 0);\n        }\n\n        if (pj_sockaddr_cmp(&info.sock_info.rtp_addr_name,\n                            &info.sock_info.rtcp_addr_name) == 0)\n        {\n            /* Using RTP & RTCP multiplexing */\n            pj_sockaddr_cp(&ap.rem_rtcp, &ap.rem_addr);\n        } else if (pj_sockaddr_has_addr(&ds->rem_rtcp)) {\n            pj_sockaddr_cp(&ap.rem_rtcp, &ds->rem_rtcp);\n        } else if (pj_sockaddr_has_addr(&info.sock_info.rtcp_addr_name)) {\n            pj_sockaddr_cp(&ap.rem_rtcp, &info.sock_info.rtcp_addr_name);\n        } else {\n            pj_sockaddr_init(pj_AF_INET(), &ap.rem_rtcp, 0, 0);\n        }\n\n        ap.addr_len = pj_sockaddr_get_len(&ap.rem_addr);\n        status = pjmedia_transport_attach2(&ds->srtp->base, &ap);\n        if (status != PJ_SUCCESS)\n            goto on_return;\n\n        /* Start member transport if it is UDP, so we can receive packet\n         * (see also #2097).\n         */\n        udp_member_transport_media_start(ds);\n\n#if DTLS_DEBUG\n        {\n            char addr[PJ_INET6_ADDRSTRLEN];\n            PJ_LOG(2,(ds->base.name, \"Attached transport, remote addr=%s:%d\",\n                      pj_sockaddr_print(&ap.rem_addr, addr, sizeof(addr), 2),\n                      pj_sockaddr_get_port(&ap.rem_addr)));\n        }\n#endif\n    }\n\n    /* If our setup is ACTIVE and member transport is not ICE,\n     * start DTLS nego.\n     */\n    if (ds->setup == DTLS_SETUP_ACTIVE) {\n        pjmedia_transport_info info;\n        pjmedia_ice_transport_info *ice_info;\n\n        pjmedia_transport_info_init(&info);\n        pjmedia_transport_get_info(ds->srtp->member_tp, &info);\n        ice_info = (pjmedia_ice_transport_info*)\n                   pjmedia_transport_info_get_spc_info(\n                                    &info, PJMEDIA_TRANSPORT_TYPE_ICE);\n        use_ice = ice_info && ice_info->comp_cnt;\n        if (!use_ice) {\n            /* Start SSL nego */\n            status = ssl_handshake(ds);\n            if (status != PJ_SUCCESS)\n                goto on_return;\n        }\n    }\n\non_return:\n#if DTLS_DEBUG\n    if (status != PJ_SUCCESS) {\n        pj_perror(4, ds->base.name, status, \"dtls_encode_sdp() failed\");\n    }\n#endif\n    return status;\n}\n\n\nstatic pj_status_t dtls_media_start( pjmedia_transport *tp,\n                                     pj_pool_t *tmp_pool,\n                                     const pjmedia_sdp_session *sdp_local,\n                                     const pjmedia_sdp_session *sdp_remote,\n                                     unsigned media_index)\n{\n    dtls_srtp *ds = (dtls_srtp *)tp;\n    pj_ice_strans_state ice_state;\n    pj_bool_t use_rtcp_mux = PJ_FALSE;\n    pj_status_t status = PJ_SUCCESS;\n    struct transport_srtp *srtp = (struct transport_srtp*)tp->user_data;\n\n#if DTLS_DEBUG\n    PJ_LOG(2,(ds->base.name, \"dtls_media_start()\"));\n#endif\n\n    PJ_UNUSED_ARG(tmp_pool);\n    PJ_UNUSED_ARG(sdp_local);\n\n    if (ds->srtp->offerer_side) {\n        /* As offerer */\n        dtls_setup last_setup = ds->setup;\n        pj_str_t last_rem_fp = ds->rem_fingerprint;\n\n        /* Parse a=setup and a=fingerprint */\n        status = parse_setup_finger_attr(ds, PJ_FALSE, sdp_remote,\n                                         media_index);\n        if (status != PJ_SUCCESS)\n            goto on_return;\n\n        /* Check if remote signals DTLS re-nego by changing its\n         * setup/fingerprint in SDP.\n         */\n        if ((last_setup != DTLS_SETUP_ACTPASS && last_setup != ds->setup) ||\n            (last_rem_fp.slen &&\n             pj_memcmp(&last_rem_fp, &ds->rem_fingerprint, sizeof(pj_str_t))))\n        {\n            dtls_media_stop_channel(ds, RTP_CHANNEL);\n            dtls_media_stop_channel(ds, RTCP_CHANNEL);\n            ds->got_keys = PJ_FALSE;\n            ds->rem_fprint_status = PJ_EPENDING;\n        }\n    } else {\n        /* As answerer */\n        \n        /* Nothing to do? */\n    }\n\n    /* Check and update ICE and rtcp-mux status */\n    {\n        pjmedia_transport_info info;\n        pjmedia_ice_transport_info *ice_info;\n\n        pjmedia_transport_info_init(&info);\n        pjmedia_transport_get_info(ds->srtp->member_tp, &info);\n        if (pj_sockaddr_cmp(&info.sock_info.rtp_addr_name,\n                            &info.sock_info.rtcp_addr_name) == 0)\n        {\n            ds->srtp->use_rtcp_mux = use_rtcp_mux = PJ_TRUE;\n        }\n        ice_info = (pjmedia_ice_transport_info*)\n                   pjmedia_transport_info_get_spc_info(\n                                    &info, PJMEDIA_TRANSPORT_TYPE_ICE);\n        ds->use_ice = ice_info && ice_info->active;\n        ice_state = ds->use_ice? ice_info->sess_state : 0;\n\n        /* Update remote RTP & RTCP addresses */\n        get_rem_addrs(ds, sdp_remote, media_index, &ds->rem_addr,\n                      &ds->rem_rtcp, NULL);\n    }\n\n    /* Check if the background DTLS nego has completed */\n    if (ds->got_keys) { \n        unsigned idx = RTP_CHANNEL;\n\n        ds->srtp->srtp_ctx.tx_policy_neg = ds->tx_crypto[idx];\n        ds->srtp->srtp_ctx.rx_policy_neg = ds->rx_crypto[idx];\n\n        /* Verify remote fingerprint (if available) */\n        if (ds->rem_fingerprint.slen && ds->rem_fprint_status == PJ_EPENDING)\n        {\n            ds->rem_fprint_status = ssl_match_fingerprint(ds, idx);\n            if (ds->rem_fprint_status != PJ_SUCCESS) {\n                pj_perror(4, ds->base.name, ds->rem_fprint_status,\n                          \"Fingerprint specified in remote SDP doesn't match \"\n                          \"to actual remote certificate fingerprint!\");\n                return ds->rem_fprint_status;\n            }\n        }\n\n        return PJ_SUCCESS;\n    } \n\n    /* SRTP key is not ready, SRTP start is pending */\n    ds->srtp->keying_pending_cnt++;\n    ds->pending_start = PJ_TRUE;\n\n    srtp->peer_use = PJMEDIA_SRTP_MANDATORY;\n\n    /* If our DTLS setup is ACTIVE:\n     * - start DTLS nego after ICE nego, or\n     * - start it now if there is no ICE.\n     */\n    if (ds->setup == DTLS_SETUP_ACTIVE) {\n        if (ds->use_ice && ice_state < PJ_ICE_STRANS_STATE_RUNNING)  {\n            /* Register ourselves to listen to ICE notifications */\n            pjmedia_ice_cb ice_cb;\n            pj_bzero(&ice_cb, sizeof(ice_cb));\n            ice_cb.on_ice_complete2 = &on_ice_complete2;\n            pjmedia_ice_add_ice_cb(ds->srtp->member_tp, &ice_cb, ds);\n        } else {\n            /* This can happen when we are SDP offerer and remote wants\n             * PASSIVE DTLS role.\n             */\n            pjmedia_transport_attach_param ap;\n            pj_bzero(&ap, sizeof(ap));\n            ap.user_data = ds->srtp;\n\n            /* Attach ourselves to member transport for DTLS nego. */\n            if (pj_sockaddr_has_addr(&ds->rem_addr))\n                pj_sockaddr_cp(&ap.rem_addr, &ds->rem_addr);\n            else\n                pj_sockaddr_init(pj_AF_INET(), &ap.rem_addr, 0, 0);\n\n            if (use_rtcp_mux) {\n                /* Using RTP & RTCP multiplexing */\n                pj_sockaddr_cp(&ap.rem_rtcp, &ds->rem_addr);\n            } else if (pj_sockaddr_has_addr(&ds->rem_rtcp)) {\n                pj_sockaddr_cp(&ap.rem_rtcp, &ds->rem_rtcp);\n            } else if (pj_sockaddr_has_addr(&ds->rem_addr)) {\n                pj_sockaddr_cp(&ap.rem_rtcp, &ds->rem_addr);\n                pj_sockaddr_set_port(&ap.rem_rtcp,\n                                     pj_sockaddr_get_port(&ap.rem_rtcp) + 1);\n            } else {\n                pj_sockaddr_init(pj_AF_INET(), &ap.rem_rtcp, 0, 0);\n            }\n\n            ap.addr_len = pj_sockaddr_get_len(&ap.rem_addr);\n            status = pjmedia_transport_attach2(&ds->srtp->base, &ap);\n            if (status != PJ_SUCCESS)\n                goto on_return;\n#if DTLS_DEBUG\n            {\n                char addr[PJ_INET6_ADDRSTRLEN];\n                PJ_LOG(2,(ds->base.name, \"Attached transport, \"\n                          \"remote addr=%s:%d\",\n                          pj_sockaddr_print(&ap.rem_addr, addr,\n                          sizeof(addr), 2),\n                          pj_sockaddr_get_port(&ap.rem_addr)));\n            }\n#endif\n            \n            status = ssl_handshake(ds);\n            if (status != PJ_SUCCESS)\n                goto on_return;\n        }\n    }\n\non_return:\n#if DTLS_DEBUG\n    if (status != PJ_SUCCESS) {\n        pj_perror(4, ds->base.name, status, \"dtls_media_start() failed\");\n    }\n#endif\n    return status;\n}\n\nstatic pj_status_t dtls_media_stop(pjmedia_transport *tp)\n{\n    dtls_srtp *ds = (dtls_srtp *)tp;\n\n#if DTLS_DEBUG\n    PJ_LOG(2,(ds->base.name, \"dtls_media_stop()\"));\n#endif\n\n    dtls_media_stop_channel(ds, RTP_CHANNEL);\n    dtls_media_stop_channel(ds, RTCP_CHANNEL);\n\n    ds->setup = DTLS_SETUP_UNKNOWN;\n    ds->use_ice = PJ_FALSE;\n    ds->got_keys = PJ_FALSE;\n    ds->rem_fingerprint.slen = 0;\n    ds->rem_fprint_status = PJ_EPENDING;\n\n    return PJ_SUCCESS;\n}\n\nstatic void dtls_destroy_channel(dtls_srtp *ds, unsigned idx)\n{\n    if (ds->clock[idx]) {\n        pjmedia_clock_destroy(ds->clock[idx]);\n        ds->clock[idx] = NULL;\n    }\n    ssl_destroy(ds, idx);\n}\n\nstatic pj_status_t dtls_destroy(pjmedia_transport *tp)\n{\n    dtls_srtp *ds = (dtls_srtp *)tp;\n\n#if DTLS_DEBUG\n    PJ_LOG(2,(ds->base.name, \"dtls_destroy()\"));\n#endif\n\n    dtls_destroy_channel(ds, RTP_CHANNEL);\n    dtls_destroy_channel(ds, RTCP_CHANNEL);\n\n    if (ds->ossl_lock) {\n        pj_lock_destroy(ds->ossl_lock);\n        ds->ossl_lock = NULL;\n    }\n\n    pj_pool_safe_release(&ds->pool);\n\n    return PJ_SUCCESS;\n}\n\n\n/* Get fingerprint of local DTLS-SRTP certificate. */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_dtls_get_fingerprint(\n                                pjmedia_transport *tp,\n                                const char *hash,\n                                char *buf, pj_size_t *len)\n{\n    PJ_ASSERT_RETURN(dtls_cert, PJ_EINVALIDOP);\n    PJ_ASSERT_RETURN(tp && hash && buf && len, PJ_EINVAL);\n    PJ_ASSERT_RETURN(pj_ansi_strcmp(hash, \"SHA-256\")==0 ||\n                     pj_ansi_strcmp(hash, \"SHA-1\")==0, PJ_EINVAL);\n    PJ_UNUSED_ARG(tp);\n\n    return ssl_get_fingerprint(dtls_cert,\n                               pj_ansi_strcmp(hash, \"SHA-256\")==0,\n                               buf, len);\n}\n\n\n/* Manually start DTLS-SRTP negotiation (without SDP offer/answer) */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_dtls_start_nego(\n                                pjmedia_transport *tp,\n                                const pjmedia_srtp_dtls_nego_param *param)\n{\n    transport_srtp *srtp = (transport_srtp*)tp;\n    dtls_srtp *ds = NULL;\n    unsigned j;\n    pjmedia_transport_attach_param ap;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(tp && param, PJ_EINVAL);\n    PJ_ASSERT_RETURN(pj_sockaddr_has_addr(&param->rem_addr), PJ_EINVAL);\n\n    /* Find DTLS keying and destroy any other keying. */\n    for (j = 0; j < srtp->all_keying_cnt; ++j) {\n        if (srtp->all_keying[j]->op == &dtls_op)\n            ds = (dtls_srtp*)srtp->all_keying[j];\n        else\n            pjmedia_transport_close(srtp->all_keying[j]);\n    }\n\n    /* DTLS-SRTP is not enabled */\n    if (!ds)\n        return PJ_ENOTSUP;\n\n    /* Set SRTP keying to DTLS-SRTP only */\n    srtp->keying_cnt = 1;\n    srtp->keying[0] = &ds->base;\n    srtp->keying_pending_cnt = 0;\n\n    /* Apply param to DTLS-SRTP internal states */\n    pj_strdup(ds->pool, &ds->rem_fingerprint, &param->rem_fingerprint);\n    ds->rem_fprint_status = PJ_EPENDING;\n    ds->rem_addr = param->rem_addr;\n    ds->rem_rtcp = param->rem_rtcp;\n    ds->setup = param->is_role_active? DTLS_SETUP_ACTIVE:DTLS_SETUP_PASSIVE;\n\n    /* Pending start SRTP */\n    ds->pending_start = PJ_TRUE;\n    srtp->keying_pending_cnt++;\n\n    /* Attach member transport, so we can send/receive DTLS init packets */\n    pj_bzero(&ap, sizeof(ap));\n    ap.user_data = ds->srtp;\n    pj_sockaddr_cp(&ap.rem_addr, &ds->rem_addr);\n    pj_sockaddr_cp(&ap.rem_rtcp, &ds->rem_rtcp);\n    if (pj_sockaddr_cmp(&ds->rem_addr, &ds->rem_rtcp) == 0)\n        ds->srtp->use_rtcp_mux = PJ_TRUE;\n    ap.addr_len = pj_sockaddr_get_len(&ap.rem_addr);\n    status = pjmedia_transport_attach2(&ds->srtp->base, &ap);\n    if (status != PJ_SUCCESS)\n        goto on_return;\n\n#if DTLS_DEBUG\n    {\n        char addr[PJ_INET6_ADDRSTRLEN];\n        PJ_LOG(2,(ds->base.name, \"Attached transport, remote addr=%s:%d\",\n                  pj_sockaddr_print(&ap.rem_addr, addr, sizeof(addr), 2),\n                  pj_sockaddr_get_port(&ap.rem_addr)));\n    }\n#endif\n\n    /* Start DTLS handshake */\n    pj_bzero(&srtp->srtp_ctx.rx_policy_neg,\n             sizeof(srtp->srtp_ctx.rx_policy_neg));\n    pj_bzero(&srtp->srtp_ctx.tx_policy_neg,\n             sizeof(srtp->srtp_ctx.tx_policy_neg));\n    status = ssl_handshake(ds);\n    if (status != PJ_SUCCESS)\n        goto on_return;\n\non_return:\n    if (status != PJ_SUCCESS) {\n        ssl_destroy(ds, RTP_CHANNEL);\n        ssl_destroy(ds, RTCP_CHANNEL);\n    }\n    return status;\n}\n", "/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/transport_udp.h>\n#include <pj/compat/socket.h>\n#include <pj/addr_resolv.h>\n#include <pj/assert.h>\n#include <pj/errno.h>\n#include <pj/ioqueue.h>\n#include <pj/log.h>\n#include <pj/pool.h>\n#include <pj/rand.h>\n#include <pj/string.h>\n\n/* Maximum size of incoming RTP packet */\n#define RTP_LEN     PJMEDIA_MAX_MRU\n\n/* Maximum size of incoming RTCP packet */\n#if defined(PJMEDIA_SRTP_HAS_DTLS) && (PJMEDIA_SRTP_HAS_DTLS != 0)\n#   define RTCP_LEN    PJMEDIA_MAX_MRU\n#else\n#   define RTCP_LEN    600\n#endif\n\n/* Maximum pending write operations */\n#define MAX_PENDING 4\n\n#if 1\n#  define TRACE_(expr)\n#else\n#  define TRACE_(expr) PJ_LOG(3,expr)\n#endif\n\n\n/* Pending write buffer */\ntypedef struct pending_write\n{\n    char                buffer[PJMEDIA_MAX_MTU];\n    pj_ioqueue_op_key_t op_key;\n    pj_bool_t           is_pending;\n} pending_write;\n\n\nstruct transport_udp\n{\n    pjmedia_transport   base;           /**< Base transport.                */\n\n    pj_pool_t          *pool;           /**< Memory pool                    */\n    unsigned            options;        /**< Transport options.             */\n    unsigned            media_options;  /**< Transport media options.       */\n    void               *user_data;      /**< Only valid when attached       */\n    //pj_bool_t         attached;       /**< Has attachment?                */\n    pj_bool_t           started;        /**< Has started?                   */\n    pj_sockaddr         rem_rtp_addr;   /**< Remote RTP address             */\n    pj_sockaddr         rem_rtcp_addr;  /**< Remote RTCP address            */\n    int                 addr_len;       /**< Length of addresses.           */\n    void  (*rtp_cb)(    void*,          /**< To report incoming RTP.        */\n                        void*,\n                        pj_ssize_t);\n    void  (*rtp_cb2)(pjmedia_tp_cb_param*); /**< To report incoming RTP.    */\n    void  (*rtcp_cb)(   void*,          /**< To report incoming RTCP.       */\n                        void*,\n                        pj_ssize_t);\n\n    unsigned            tx_drop_pct;    /**< Percent of tx pkts to drop.    */\n    unsigned            rx_drop_pct;    /**< Percent of rx pkts to drop.    */\n    pj_ioqueue_t        *ioqueue;       /**< Ioqueue instance.              */\n\n    pj_sock_t           rtp_sock;       /**< RTP socket                     */\n    pj_sockaddr         rtp_addr_name;  /**< Published RTP address.         */\n    pj_ioqueue_key_t   *rtp_key;        /**< RTP socket key in ioqueue      */\n    pj_ioqueue_op_key_t rtp_read_op;    /**< Pending read operation         */\n    unsigned            rtp_write_op_id;/**< Next write_op to use           */\n    pending_write       rtp_pending_write[MAX_PENDING];  /**< Pending write */\n    pj_sockaddr         rtp_src_addr;   /**< Actual packet src addr.        */\n    int                 rtp_addrlen;    /**< Address length.                */\n    char                rtp_pkt[RTP_LEN];/**< Incoming RTP packet buffer    */\n\n    pj_bool_t           enable_rtcp_mux;/**< Enable RTP & RTCP multiplexing?*/\n    pj_bool_t           use_rtcp_mux;   /**< Use RTP & RTCP multiplexing?   */\n    pj_sock_t           rtcp_sock;      /**< RTCP socket                    */\n    pj_sockaddr         rtcp_addr_name; /**< Published RTCP address.        */\n    pj_sockaddr         rtcp_src_addr;  /**< Actual source RTCP address.    */\n    unsigned            rtcp_src_cnt;   /**< How many pkt from this addr.   */\n    int                 rtcp_addr_len;  /**< Length of RTCP src address.    */\n    pj_ioqueue_key_t   *rtcp_key;       /**< RTCP socket key in ioqueue     */\n    pj_ioqueue_op_key_t rtcp_read_op;   /**< Pending read operation         */\n    pj_ioqueue_op_key_t rtcp_write_op;  /**< Pending write operation        */\n    char                rtcp_pkt[RTCP_LEN];/**< Incoming RTCP packet buffer */\n};\n\n\n\nstatic void on_rx_rtp( pj_ioqueue_key_t *key, \n                       pj_ioqueue_op_key_t *op_key, \n                       pj_ssize_t bytes_read);\nstatic void on_rtp_data_sent(pj_ioqueue_key_t *key, \n                             pj_ioqueue_op_key_t *op_key, \n                             pj_ssize_t bytes_sent);\nstatic void on_rx_rtcp(pj_ioqueue_key_t *key, \n                       pj_ioqueue_op_key_t *op_key, \n                       pj_ssize_t bytes_read);\n\n/*\n * These are media transport operations.\n */\nstatic pj_status_t transport_get_info (pjmedia_transport *tp,\n                                       pjmedia_transport_info *info);\nstatic pj_status_t transport_attach   (pjmedia_transport *tp,\n                                       void *user_data,\n                                       const pj_sockaddr_t *rem_addr,\n                                       const pj_sockaddr_t *rem_rtcp,\n                                       unsigned addr_len,\n                                       void (*rtp_cb)(void*,\n                                                      void*,\n                                                      pj_ssize_t),\n                                       void (*rtcp_cb)(void*,\n                                                       void*,\n                                                       pj_ssize_t));\nstatic pj_status_t transport_attach2  (pjmedia_transport *tp,\n                                       pjmedia_transport_attach_param\n                                           *att_param);\nstatic void        transport_detach   (pjmedia_transport *tp,\n                                       void *strm);\nstatic pj_status_t transport_send_rtp( pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_send_rtcp(pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_send_rtcp2(pjmedia_transport *tp,\n                                       const pj_sockaddr_t *addr,\n                                       unsigned addr_len,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_media_create(pjmedia_transport *tp,\n                                       pj_pool_t *pool,\n                                       unsigned options,\n                                       const pjmedia_sdp_session *sdp_remote,\n                                       unsigned media_index);\nstatic pj_status_t transport_encode_sdp(pjmedia_transport *tp,\n                                        pj_pool_t *pool,\n                                        pjmedia_sdp_session *sdp_local,\n                                        const pjmedia_sdp_session *rem_sdp,\n                                        unsigned media_index);\nstatic pj_status_t transport_media_start (pjmedia_transport *tp,\n                                       pj_pool_t *pool,\n                                       const pjmedia_sdp_session *sdp_local,\n                                       const pjmedia_sdp_session *sdp_remote,\n                                       unsigned media_index);\nstatic pj_status_t transport_media_stop(pjmedia_transport *tp);\nstatic pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n                                       pjmedia_dir dir,\n                                       unsigned pct_lost);\nstatic pj_status_t transport_destroy  (pjmedia_transport *tp);\nstatic pj_status_t transport_restart  (pj_bool_t is_rtp, \n                                       struct transport_udp *udp);\n\nstatic pjmedia_transport_op transport_udp_op = \n{\n    &transport_get_info,\n    &transport_attach,\n    &transport_detach,\n    &transport_send_rtp,\n    &transport_send_rtcp,\n    &transport_send_rtcp2,\n    &transport_media_create,\n    &transport_encode_sdp,\n    &transport_media_start,\n    &transport_media_stop,\n    &transport_simulate_lost,\n    &transport_destroy,\n    &transport_attach2\n};\n\nstatic const pj_str_t STR_RTCP_MUX      = { \"rtcp-mux\", 8 };\n\n/**\n * Create UDP stream transport.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_udp_create( pjmedia_endpt *endpt,\n                                                  const char *name,\n                                                  int port,\n                                                  unsigned options,\n                                                  pjmedia_transport **p_tp)\n{\n    return pjmedia_transport_udp_create2(endpt, name, NULL, port, options, \n                                        p_tp);\n}\n\n/**\n * Create UDP stream transport.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_udp_create2(pjmedia_endpt *endpt,\n                                                  const char *name,\n                                                  const pj_str_t *addr,\n                                                  int port,\n                                                  unsigned options,\n                                                  pjmedia_transport **p_tp)\n{\n    return pjmedia_transport_udp_create3(endpt, pj_AF_INET(), name,\n                                         addr, port, options, p_tp);\n}\n\n/**\n * Create UDP stream transport.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_udp_create3(pjmedia_endpt *endpt,\n                                                  int af,\n                                                  const char *name,\n                                                  const pj_str_t *addr,\n                                                  int port,\n                                                  unsigned options,\n                                                  pjmedia_transport **p_tp)\n{\n    pjmedia_sock_info si;\n    pj_status_t status;\n\n    \n    /* Sanity check */\n    PJ_ASSERT_RETURN(endpt && port && p_tp, PJ_EINVAL);\n\n\n    pj_bzero(&si, sizeof(pjmedia_sock_info));\n    si.rtp_sock = si.rtcp_sock = PJ_INVALID_SOCKET;\n\n    /* Create RTP socket */\n    status = pj_sock_socket(af, pj_SOCK_DGRAM() | pj_SOCK_CLOEXEC(), 0, &si.rtp_sock);\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    /* Bind RTP socket */\n    status = pj_sockaddr_init(af, &si.rtp_addr_name, addr, (pj_uint16_t)port);\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    status = pj_sock_bind(si.rtp_sock, &si.rtp_addr_name, \n                          pj_sockaddr_get_len(&si.rtp_addr_name));\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n\n    /* Create RTCP socket */\n    status = pj_sock_socket(af, pj_SOCK_DGRAM() | pj_SOCK_CLOEXEC(), 0, &si.rtcp_sock);\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    /* Bind RTCP socket */\n    status = pj_sockaddr_init(af, &si.rtcp_addr_name, addr, \n                              (pj_uint16_t)(port+1));\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    status = pj_sock_bind(si.rtcp_sock, &si.rtcp_addr_name,\n                          pj_sockaddr_get_len(&si.rtcp_addr_name));\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    \n    /* Create UDP transport by attaching socket info */\n    return pjmedia_transport_udp_attach( endpt, name, &si, options, p_tp);\n\n\non_error:\n    if (si.rtp_sock != PJ_INVALID_SOCKET)\n        pj_sock_close(si.rtp_sock);\n    if (si.rtcp_sock != PJ_INVALID_SOCKET)\n        pj_sock_close(si.rtcp_sock);\n    return status;\n}\n\n\n/**\n * Create UDP stream transport from existing socket info.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_udp_attach( pjmedia_endpt *endpt,\n                                                  const char *name,\n                                                  const pjmedia_sock_info *si,\n                                                  unsigned options,\n                                                  pjmedia_transport **p_tp)\n{\n    struct transport_udp *tp;\n    pj_pool_t *pool;\n    pj_ioqueue_t *ioqueue;\n    pj_ioqueue_callback rtp_cb, rtcp_cb;\n    pj_status_t status;\n\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(endpt && si && p_tp, PJ_EINVAL);\n\n    /* Get ioqueue instance */\n    ioqueue = pjmedia_endpt_get_ioqueue(endpt);\n\n    if (name==NULL)\n        name = \"udp%p\";\n\n    /* Create transport structure */\n    pool = pjmedia_endpt_create_pool(endpt, name, 512, 512);\n    if (!pool)\n        return PJ_ENOMEM;\n\n    tp = PJ_POOL_ZALLOC_T(pool, struct transport_udp);\n    tp->pool = pool;\n    tp->options = options;\n    pj_memcpy(tp->base.name, pool->obj_name, PJ_MAX_OBJ_NAME);\n    tp->base.op = &transport_udp_op;\n    tp->base.type = PJMEDIA_TRANSPORT_TYPE_UDP;\n\n    /* Copy socket infos */\n    tp->rtp_sock = si->rtp_sock;\n    tp->rtp_addr_name = si->rtp_addr_name;\n    tp->rtcp_sock = si->rtcp_sock;\n    tp->rtcp_addr_name = si->rtcp_addr_name;\n\n    /* If address is 0.0.0.0, use host's IP address */\n    if (!pj_sockaddr_has_addr(&tp->rtp_addr_name)) {\n        pj_sockaddr hostip;\n\n        status = pj_gethostip(tp->rtp_addr_name.addr.sa_family, &hostip);\n        if (status != PJ_SUCCESS)\n            goto on_error;\n\n        pj_memcpy(pj_sockaddr_get_addr(&tp->rtp_addr_name), \n                  pj_sockaddr_get_addr(&hostip),\n                  pj_sockaddr_get_addr_len(&hostip));\n    }\n\n    /* Same with RTCP */\n    if (!pj_sockaddr_has_addr(&tp->rtcp_addr_name)) {\n        pj_memcpy(pj_sockaddr_get_addr(&tp->rtcp_addr_name),\n                  pj_sockaddr_get_addr(&tp->rtp_addr_name),\n                  pj_sockaddr_get_addr_len(&tp->rtp_addr_name));\n    }\n\n    /* Setup RTP socket with the ioqueue */\n    pj_bzero(&rtp_cb, sizeof(rtp_cb));\n    rtp_cb.on_read_complete = &on_rx_rtp;\n    rtp_cb.on_write_complete = &on_rtp_data_sent;\n\n    status = pj_ioqueue_register_sock(pool, ioqueue, tp->rtp_sock, tp,\n                                      &rtp_cb, &tp->rtp_key);\n    if (status != PJ_SUCCESS)\n        goto on_error;\n    \n    /* Disallow concurrency so that detach() and destroy() are\n     * synchronized with the callback.\n     */\n    status = pj_ioqueue_set_concurrency(tp->rtp_key, PJ_FALSE);\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n#if 0 // See #2097: move read op kick-off to media_start()\n    pj_ioqueue_op_key_init(&tp->rtp_read_op, sizeof(tp->rtp_read_op));\n    for (i=0; i<PJ_ARRAY_SIZE(tp->rtp_pending_write); ++i) {\n        tp->rtp_pending_write[i].is_pending = PJ_FALSE;\n        pj_ioqueue_op_key_init(&tp->rtp_pending_write[i].op_key, \n                               sizeof(tp->rtp_pending_write[i].op_key));\n    }\n\n    /* Kick of pending RTP read from the ioqueue */\n    tp->rtp_addrlen = sizeof(tp->rtp_src_addr);\n    size = sizeof(tp->rtp_pkt);\n    status = pj_ioqueue_recvfrom(tp->rtp_key, &tp->rtp_read_op,\n                                 tp->rtp_pkt, &size, PJ_IOQUEUE_ALWAYS_ASYNC,\n                                 &tp->rtp_src_addr, &tp->rtp_addrlen);\n    if (status != PJ_EPENDING)\n        goto on_error;\n#endif\n\n\n    /* Setup RTCP socket with ioqueue */\n    pj_bzero(&rtcp_cb, sizeof(rtcp_cb));\n    rtcp_cb.on_read_complete = &on_rx_rtcp;\n\n    status = pj_ioqueue_register_sock(pool, ioqueue, tp->rtcp_sock, tp,\n                                      &rtcp_cb, &tp->rtcp_key);\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    status = pj_ioqueue_set_concurrency(tp->rtcp_key, PJ_FALSE);\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n#if 0 // See #2097: move read op kick-off to media_start()\n    pj_ioqueue_op_key_init(&tp->rtcp_read_op, sizeof(tp->rtcp_read_op));\n    pj_ioqueue_op_key_init(&tp->rtcp_write_op, sizeof(tp->rtcp_write_op));\n\n    /* Kick of pending RTCP read from the ioqueue */\n    size = sizeof(tp->rtcp_pkt);\n    tp->rtcp_addr_len = sizeof(tp->rtcp_src_addr);\n    status = pj_ioqueue_recvfrom( tp->rtcp_key, &tp->rtcp_read_op,\n                                  tp->rtcp_pkt, &size, PJ_IOQUEUE_ALWAYS_ASYNC,\n                                  &tp->rtcp_src_addr, &tp->rtcp_addr_len);\n    if (status != PJ_EPENDING)\n        goto on_error;\n#endif  \n\n    tp->ioqueue = ioqueue;\n\n    /* Done */\n    *p_tp = &tp->base;\n    return PJ_SUCCESS;\n\n\non_error:\n    transport_destroy(&tp->base);\n    return status;\n}\n\n\n/**\n * Close UDP transport.\n */\nstatic pj_status_t transport_destroy(pjmedia_transport *tp)\n{\n    struct transport_udp *udp = (struct transport_udp*) tp;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    /* Must not close while application is using this */\n    //PJ_ASSERT_RETURN(!udp->attached, PJ_EINVALIDOP);\n    \n\n    if (udp->rtp_key) {\n        /* This will block the execution if callback is still\n         * being called.\n         */\n        pj_ioqueue_unregister(udp->rtp_key);\n        udp->rtp_key = NULL;\n        udp->rtp_sock = PJ_INVALID_SOCKET;\n    } else if (udp->rtp_sock != PJ_INVALID_SOCKET) {\n        pj_sock_close(udp->rtp_sock);\n        udp->rtp_sock = PJ_INVALID_SOCKET;\n    }\n\n    if (udp->rtcp_key) {\n        pj_ioqueue_unregister(udp->rtcp_key);\n        udp->rtcp_key = NULL;\n        udp->rtcp_sock = PJ_INVALID_SOCKET;\n    } else if (udp->rtcp_sock != PJ_INVALID_SOCKET) {\n        pj_sock_close(udp->rtcp_sock);\n        udp->rtcp_sock = PJ_INVALID_SOCKET;\n    }\n\n    PJ_LOG(4,(udp->base.name, \"UDP media transport destroyed\"));\n    pj_pool_release(udp->pool);\n\n    return PJ_SUCCESS;\n}\n\n/* Call RTP cb. */\nstatic void call_rtp_cb(struct transport_udp *udp, pj_ssize_t bytes_read, \n                        pj_bool_t *rem_switch)\n{\n    void (*cb)(void*,void*,pj_ssize_t);\n    void (*cb2)(pjmedia_tp_cb_param*);\n    void *user_data;\n\n    cb = udp->rtp_cb;\n    cb2 = udp->rtp_cb2;\n    user_data = udp->user_data;\n\n    if (cb2) {\n        pjmedia_tp_cb_param param;\n\n        param.user_data = user_data;\n        param.pkt = udp->rtp_pkt;\n        param.size = bytes_read;\n        param.src_addr = &udp->rtp_src_addr;\n        param.rem_switch = PJ_FALSE;\n        (*cb2)(&param);\n        if (rem_switch)\n            *rem_switch = param.rem_switch;\n    } else if (cb) {\n        (*cb)(user_data, udp->rtp_pkt, bytes_read);\n    }\n}\n\n/* Call RTCP cb. */\nstatic void call_rtcp_cb(struct transport_udp *udp, pj_ssize_t bytes_read)\n{\n    void(*cb)(void*, void*, pj_ssize_t);\n    void *user_data;\n\n    cb = udp->rtcp_cb;\n    user_data = udp->user_data;\n\n    if (cb)\n        (*cb)(user_data, udp->rtcp_pkt, bytes_read);\n}\n\n/* Notification from ioqueue about incoming RTP packet */\nstatic void on_rx_rtp(pj_ioqueue_key_t *key,\n                      pj_ioqueue_op_key_t *op_key,\n                      pj_ssize_t bytes_read)\n{\n    struct transport_udp *udp;\n    pj_status_t status;\n    pj_bool_t rem_switch = PJ_FALSE;\n    pj_bool_t transport_restarted = PJ_FALSE;\n    unsigned num_err = 0;\n    pj_status_t last_err = PJ_SUCCESS;\n\n    PJ_UNUSED_ARG(op_key);\n\n    udp = (struct transport_udp*) pj_ioqueue_get_user_data(key);\n\n    if (-bytes_read == PJ_ECANCELLED) {\n        TRACE_((udp->base.name, \"on_rx_rtp(): got PJ_ECANCELLED\"));\n        return;\n    }\n\n    if (-bytes_read == PJ_ESOCKETSTOP) {\n        TRACE_((udp->base.name, \"on_rx_rtp(): got PJ_ESOCKETSTOP\"));\n\n        /* Try to recover by restarting the transport. */\n        status = transport_restart(PJ_TRUE, udp);\n        if (status != PJ_SUCCESS) {\n            bytes_read = -PJ_ESOCKETSTOP;\n            call_rtp_cb(udp, bytes_read, NULL);\n        }\n        return;\n    }\n\n    do {\n        pj_bool_t discard = PJ_FALSE;\n\n        /* Simulate packet lost on RX direction */\n        if (udp->rx_drop_pct) {\n            if ((pj_rand() % 100) <= (int)udp->rx_drop_pct) {\n                PJ_LOG(5,(udp->base.name, \n                          \"RX RTP packet dropped because of pkt lost \"\n                          \"simulation\"));\n                discard = PJ_TRUE;\n            }\n        }\n\n        //if (!discard && udp->attached && cb)\n        if (!discard && \n            (-bytes_read != PJ_STATUS_FROM_OS(PJ_BLOCKING_ERROR_VAL))) \n        {\n            call_rtp_cb(udp, bytes_read, &rem_switch);\n        }\n\n#if defined(PJMEDIA_TRANSPORT_SWITCH_REMOTE_ADDR) && \\\n    (PJMEDIA_TRANSPORT_SWITCH_REMOTE_ADDR == 1)\n        if (rem_switch &&\n            (udp->options & PJMEDIA_UDP_NO_SRC_ADDR_CHECKING)==0)\n        {\n            char addr_text[PJ_INET6_ADDRSTRLEN+10];\n\n            /* Set remote RTP address to source address */\n            pj_sockaddr_cp(&udp->rem_rtp_addr, &udp->rtp_src_addr);\n\n            PJ_LOG(4,(udp->base.name,\n                      \"Remote RTP address switched to %s\",\n                      pj_sockaddr_print(&udp->rtp_src_addr, addr_text,\n                                        sizeof(addr_text), 3)));\n\n            if (udp->use_rtcp_mux) {\n                pj_sockaddr_cp(&udp->rem_rtcp_addr, &udp->rem_rtp_addr);\n                pj_sockaddr_cp(&udp->rtcp_src_addr, &udp->rem_rtcp_addr);\n            } else if (!pj_sockaddr_has_addr(&udp->rtcp_src_addr)) {\n                /* Also update remote RTCP address if actual RTCP source\n                 * address is not heard yet.\n                 */\n                pj_uint16_t port;\n\n                pj_sockaddr_cp(&udp->rem_rtcp_addr, &udp->rem_rtp_addr);\n                port = (pj_uint16_t)\n                       (pj_sockaddr_get_port(&udp->rem_rtp_addr)+1);\n                pj_sockaddr_set_port(&udp->rem_rtcp_addr, port);\n\n                pj_sockaddr_cp(&udp->rtcp_src_addr, &udp->rem_rtcp_addr);\n\n                PJ_LOG(4,(udp->base.name,\n                          \"Remote RTCP address switched to predicted\"\n                          \" address %s\",\n                          pj_sockaddr_print(&udp->rtcp_src_addr, addr_text,\n                                            sizeof(addr_text), 3)));\n            }\n        }\n#endif\n\n        bytes_read = sizeof(udp->rtp_pkt);\n        udp->rtp_addrlen = sizeof(udp->rtp_src_addr);\n        status = pj_ioqueue_recvfrom(udp->rtp_key, &udp->rtp_read_op,\n                                        udp->rtp_pkt, &bytes_read, 0,\n                                        &udp->rtp_src_addr,\n                                        &udp->rtp_addrlen);\n\n        if (status != PJ_EPENDING && status != PJ_SUCCESS) {        \n            if (transport_restarted && last_err == status) {\n                /* Still the same error after restart */\n                bytes_read = -PJ_ESOCKETSTOP;\n                call_rtp_cb(udp, bytes_read, NULL);\n                break;\n            } else if (PJMEDIA_IGNORE_RECV_ERR_CNT) {\n                if (last_err == status) {\n                    ++num_err;\n                } else {\n                    num_err = 1;\n                    last_err = status;\n                }\n\n                if (status == PJ_ESOCKETSTOP ||\n                    num_err > PJMEDIA_IGNORE_RECV_ERR_CNT)\n                {\n                    status = transport_restart(PJ_TRUE, udp);               \n                    if (status != PJ_SUCCESS) {\n                        bytes_read = -PJ_ESOCKETSTOP;\n                        call_rtp_cb(udp, bytes_read, NULL);\n                        break;\n                    }\n                    transport_restarted = PJ_TRUE;\n                    num_err = 0;\n                }\n            }\n            bytes_read = -status;\n            TRACE_((udp->base.name, \"on_rx_rtp(): recvfrom error=%d\", status));\n        }\n    } while (status != PJ_EPENDING && status != PJ_ECANCELLED &&\n             udp->started);\n}\n\nstatic void on_rtp_data_sent(pj_ioqueue_key_t *key, \n                             pj_ioqueue_op_key_t *op_key, \n                             pj_ssize_t bytes_sent)\n{\n    struct transport_udp *udp;\n    unsigned i;\n\n    PJ_UNUSED_ARG(bytes_sent);\n\n    udp = (struct transport_udp*) pj_ioqueue_get_user_data(key);\n\n    for (i = 0; i < PJ_ARRAY_SIZE(udp->rtp_pending_write); ++i) {\n        if (&udp->rtp_pending_write[i].op_key == op_key) {\n            udp->rtp_pending_write[i].is_pending = PJ_FALSE;\n            break;\n        }\n    }\n}\n\n/* Notification from ioqueue about incoming RTCP packet */\nstatic void on_rx_rtcp(pj_ioqueue_key_t *key, \n                       pj_ioqueue_op_key_t *op_key, \n                       pj_ssize_t bytes_read)\n{\n    struct transport_udp *udp;\n    pj_status_t status = PJ_SUCCESS;\n    pj_bool_t transport_restarted = PJ_FALSE;\n    unsigned num_err = 0;\n    pj_status_t last_err = PJ_SUCCESS;\n\n    PJ_UNUSED_ARG(op_key);\n\n    udp = (struct transport_udp*) pj_ioqueue_get_user_data(key);\n\n    if (-bytes_read == PJ_ECANCELLED) {\n        TRACE_((udp->base.name, \"on_rx_rtcp(): got PJ_ECANCELLED\"));\n        return;\n    }\n\n    if (-bytes_read == PJ_ESOCKETSTOP) {\n        TRACE_((udp->base.name, \"on_rx_rtcp(): got PJ_ESOCKETSTOP\"));\n\n        /* Try to recover by restarting the transport. */\n        status = transport_restart(PJ_FALSE, udp);\n        if (status != PJ_SUCCESS) {\n            bytes_read = -PJ_ESOCKETSTOP;\n            call_rtcp_cb(udp, bytes_read);\n        }\n        return;\n    }\n\n    do {\n        call_rtcp_cb(udp, bytes_read);\n\n#if defined(PJMEDIA_TRANSPORT_SWITCH_REMOTE_ADDR) && \\\n    (PJMEDIA_TRANSPORT_SWITCH_REMOTE_ADDR == 1)\n        /* Check if RTCP source address is the same as the configured\n         * remote address, and switch the address when they are\n         * different.\n         */\n        if (bytes_read>0 &&\n            (udp->options & PJMEDIA_UDP_NO_SRC_ADDR_CHECKING)==0)\n        {\n            if (pj_sockaddr_cmp(&udp->rem_rtcp_addr, &udp->rtcp_src_addr) == 0) {\n                /* Still receiving from rem_rtcp_addr, don't switch */\n                udp->rtcp_src_cnt = 0;\n            } else {\n                ++udp->rtcp_src_cnt;\n\n                if (udp->rtcp_src_cnt >= PJMEDIA_RTCP_NAT_PROBATION_CNT ) {\n                    char addr_text[PJ_INET6_ADDRSTRLEN+10];\n\n                    udp->rtcp_src_cnt = 0;\n                    pj_memcpy(&udp->rem_rtcp_addr, &udp->rtcp_src_addr,\n                              sizeof(pj_sockaddr));\n\n                    PJ_LOG(4,(udp->base.name,\n                              \"Remote RTCP address switched to %s\",\n                              pj_sockaddr_print(&udp->rtcp_src_addr, addr_text,\n                                                sizeof(addr_text), 3)));\n                }\n            }\n        }\n#endif\n\n        bytes_read = sizeof(udp->rtcp_pkt);\n        udp->rtcp_addr_len = sizeof(udp->rtcp_src_addr);\n        status = pj_ioqueue_recvfrom(udp->rtcp_key, &udp->rtcp_read_op,\n                                     udp->rtcp_pkt, &bytes_read, 0,\n                                     &udp->rtcp_src_addr, \n                                     &udp->rtcp_addr_len);\n\n        if (status != PJ_EPENDING && status != PJ_SUCCESS) {\n            if (transport_restarted && last_err == status) {\n                /* Still the same error after restart */\n                bytes_read = -PJ_ESOCKETSTOP;\n                call_rtcp_cb(udp, bytes_read);\n                break;\n            } else if (PJMEDIA_IGNORE_RECV_ERR_CNT) {\n                if (last_err == status) {\n                    ++num_err;\n                } else {\n                    num_err = 1;\n                    last_err = status;\n                }\n\n                if (status == PJ_ESOCKETSTOP ||\n                    num_err > PJMEDIA_IGNORE_RECV_ERR_CNT)\n                {\n                    status = transport_restart(PJ_FALSE, udp);              \n                    if (status != PJ_SUCCESS) {\n                        bytes_read = -PJ_ESOCKETSTOP;\n                        call_rtcp_cb(udp, bytes_read);\n                        break;\n                    }\n                    transport_restarted = PJ_TRUE;\n                    num_err = 0;\n                }\n            }\n            bytes_read = -status;\n            TRACE_((udp->base.name, \"on_rx_rtcp(): recvfrom error=%d\", status));\n        }       \n    } while (status != PJ_EPENDING && status != PJ_ECANCELLED &&\n             udp->started);\n}\n\n\n/* Called to get the transport info */\nstatic pj_status_t transport_get_info(pjmedia_transport *tp,\n                                      pjmedia_transport_info *info)\n{\n    struct transport_udp *udp = (struct transport_udp*)tp;\n    PJ_ASSERT_RETURN(tp && info, PJ_EINVAL);\n\n    info->sock_info.rtp_sock = udp->rtp_sock;\n    info->sock_info.rtp_addr_name = udp->rtp_addr_name;\n    info->sock_info.rtcp_sock = udp->rtcp_sock;\n    info->sock_info.rtcp_addr_name = (udp->use_rtcp_mux?\n                                      udp->rtp_addr_name:\n                                      udp->rtcp_addr_name);\n\n    /* Get remote address originating RTP & RTCP. */\n    info->src_rtp_name  = udp->rtp_src_addr;\n    info->src_rtcp_name = udp->rtcp_src_addr;\n\n    /* Add empty specific info */\n    if (info->specific_info_cnt < PJ_ARRAY_SIZE(info->spc_info)) {\n        pjmedia_transport_specific_info *tsi;\n\n        tsi = &info->spc_info[info->specific_info_cnt++];\n        tsi->type = PJMEDIA_TRANSPORT_TYPE_UDP;\n        tsi->cbsize = 0;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t tp_attach          (pjmedia_transport *tp,\n                                       void *user_data,\n                                       const pj_sockaddr_t *rem_addr,\n                                       const pj_sockaddr_t *rem_rtcp,\n                                       unsigned addr_len,\n                                       void (*rtp_cb)(void*,\n                                                      void*,\n                                                      pj_ssize_t),\n                                       void (*rtp_cb2)(pjmedia_tp_cb_param*),\n                                       void (*rtcp_cb)(void*,\n                                                       void*,\n                                                       pj_ssize_t))\n{\n    struct transport_udp *udp = (struct transport_udp*) tp;\n    const pj_sockaddr *rtcp_addr;\n    pj_sockaddr sock_addr, remote_addr, remote_rtcp;\n    int rem_addr_len;\n    pj_status_t status;\n\n    /* Validate arguments */\n    PJ_ASSERT_RETURN(tp && rem_addr && addr_len, PJ_EINVAL);\n\n    /* Must not be \"attached\" to existing application */\n    //PJ_ASSERT_RETURN(!udp->attached, PJ_EINVALIDOP);\n\n    /* Check again if we are multiplexing RTP & RTCP. */\n    udp->use_rtcp_mux = (pj_sockaddr_has_addr(rem_addr) &&\n                         pj_sockaddr_cmp(rem_addr, rem_rtcp) == 0);\n\n    TRACE_((udp->base.name, \"attach(): before locking keys\"));\n\n    /* Lock the ioqueue keys to make sure that callbacks are\n     * not executed. See ticket #844 for details.\n     */\n    pj_ioqueue_lock_key(udp->rtp_key);\n    pj_ioqueue_lock_key(udp->rtcp_key);\n\n    TRACE_((udp->base.name, \"attach(): inside locked keys\"));\n\n    /* \"Attach\" the application: */\n\n    rem_addr_len = sizeof(pj_sockaddr);\n    pj_sock_getsockname(udp->rtp_sock, &sock_addr, &rem_addr_len);\n\n    /* Synthesize address, if necessary. */\n    status = pj_sockaddr_synthesize(sock_addr.addr.sa_family,\n                                    &remote_addr, rem_addr);\n    if (status != PJ_SUCCESS) {\n        pj_perror(3, tp->name, status, \"Failed to synthesize the correct\"\n                                       \"IP address for RTP\");\n    }\n    rem_addr_len = pj_sockaddr_get_len(&remote_addr);\n\n    /* Copy remote RTP address */\n    pj_memcpy(&udp->rem_rtp_addr, &remote_addr, rem_addr_len);\n\n    /* Copy remote RTP address, if one is specified. */\n    rtcp_addr = (const pj_sockaddr*) rem_rtcp;\n    if (rtcp_addr && pj_sockaddr_has_addr(rtcp_addr)) {\n        status = pj_sockaddr_synthesize(sock_addr.addr.sa_family,\n                                        &remote_rtcp, rem_rtcp);\n        if (status != PJ_SUCCESS) {\n            pj_perror(3, tp->name, status, \"Failed to synthesize the correct\"\n                                           \"IP address for RTCP\");\n        }\n        pj_memcpy(&udp->rem_rtcp_addr, &remote_rtcp, rem_addr_len);\n\n    } else {\n        unsigned rtcp_port;\n\n        /* Otherwise guess the RTCP address from the RTP address */\n        pj_memcpy(&udp->rem_rtcp_addr, &udp->rem_rtp_addr, rem_addr_len);\n        rtcp_port = pj_sockaddr_get_port(&udp->rem_rtp_addr) + 1;\n        pj_sockaddr_set_port(&udp->rem_rtcp_addr, (pj_uint16_t)rtcp_port);\n    }\n\n    /* Save the callbacks */\n    udp->rtp_cb = rtp_cb;\n    udp->rtp_cb2 = rtp_cb2;\n    udp->rtcp_cb = rtcp_cb;\n    udp->user_data = user_data;\n\n    /* Save address length */\n    udp->addr_len = rem_addr_len;\n\n    /* Last, mark transport as attached */\n    //udp->attached = PJ_TRUE;\n\n    /* Reset source RTP & RTCP addresses and counter */\n    pj_bzero(&udp->rtp_src_addr, sizeof(udp->rtp_src_addr));\n    pj_bzero(&udp->rtcp_src_addr, sizeof(udp->rtcp_src_addr));\n    udp->rtcp_src_cnt = 0;\n\n    /* Set buffer size for RTP socket */\n#if PJMEDIA_TRANSPORT_SO_RCVBUF_SIZE\n    {\n        unsigned sobuf_size = PJMEDIA_TRANSPORT_SO_RCVBUF_SIZE;\n        \n        status = pj_sock_setsockopt_sobuf(udp->rtp_sock, pj_SO_RCVBUF(),\n                                          PJ_TRUE, &sobuf_size);\n        if (status != PJ_SUCCESS) {\n            pj_perror(3, tp->name, status, \"Failed setting SO_RCVBUF\");\n        } else {\n            if (sobuf_size < PJMEDIA_TRANSPORT_SO_RCVBUF_SIZE) {\n                PJ_LOG(4, (tp->name, \n                           \"Warning! Cannot set SO_RCVBUF as configured, \"\n                           \"now=%d, configured=%d\",\n                           sobuf_size, PJMEDIA_TRANSPORT_SO_RCVBUF_SIZE));\n            } else {\n                PJ_LOG(5, (tp->name, \"SO_RCVBUF set to %d\", sobuf_size));\n            }\n        }\n    }\n#endif\n#if PJMEDIA_TRANSPORT_SO_SNDBUF_SIZE\n    {\n        unsigned sobuf_size = PJMEDIA_TRANSPORT_SO_SNDBUF_SIZE;\n\n        status = pj_sock_setsockopt_sobuf(udp->rtp_sock, pj_SO_SNDBUF(),\n                                          PJ_TRUE, &sobuf_size);\n        if (status != PJ_SUCCESS) {\n            pj_perror(3, tp->name, status, \"Failed setting SO_SNDBUF\");\n        } else {\n            if (sobuf_size < PJMEDIA_TRANSPORT_SO_SNDBUF_SIZE) {\n                PJ_LOG(4, (tp->name, \n                           \"Warning! Cannot set SO_SNDBUF as configured, \"\n                           \"now=%d, configured=%d\",\n                           sobuf_size, PJMEDIA_TRANSPORT_SO_SNDBUF_SIZE));\n            } else {\n                PJ_LOG(5, (tp->name, \"SO_SNDBUF set to %d\", sobuf_size));\n            }\n        }\n    }\n#endif\n\n    /* Unlock keys */\n    pj_ioqueue_unlock_key(udp->rtcp_key);\n    pj_ioqueue_unlock_key(udp->rtp_key);\n\n    PJ_LOG(4,(udp->base.name, \"UDP media transport attached\"));\n\n    return PJ_SUCCESS;\n}\n\n\n/* Called by application to initialize the transport */\nstatic pj_status_t transport_attach(   pjmedia_transport *tp,\n                                       void *user_data,\n                                       const pj_sockaddr_t *rem_addr,\n                                       const pj_sockaddr_t *rem_rtcp,\n                                       unsigned addr_len,\n                                       void (*rtp_cb)(void*,\n                                                      void*,\n                                                      pj_ssize_t),\n                                       void (*rtcp_cb)(void*,\n                                                       void*,\n                                                       pj_ssize_t))\n{\n    return tp_attach(tp, user_data, rem_addr, rem_rtcp, addr_len,\n                     rtp_cb, NULL, rtcp_cb);\n}\n\n\nstatic pj_status_t transport_attach2(pjmedia_transport *tp,\n                                     pjmedia_transport_attach_param *att_param)\n{\n    return tp_attach(tp, att_param->user_data, \n                            (pj_sockaddr_t*)&att_param->rem_addr, \n                            (pj_sockaddr_t*)&att_param->rem_rtcp, \n                            att_param->addr_len, att_param->rtp_cb,\n                            att_param->rtp_cb2, \n                            att_param->rtcp_cb);\n}\n\n\n/* Called by application when it no longer needs the transport */\nstatic void transport_detach( pjmedia_transport *tp,\n                              void *user_data)\n{\n    struct transport_udp *udp = (struct transport_udp*) tp;\n\n    pj_assert(tp);\n\n    //if (udp->attached) {\n    if (1) {\n        /* Lock the ioqueue keys to make sure that callbacks are\n         * not executed. See ticket #460 for details.\n         */\n\n        TRACE_((udp->base.name, \"detach(): before locking keys\"));\n\n        pj_ioqueue_lock_key(udp->rtp_key);\n        pj_ioqueue_lock_key(udp->rtcp_key);\n\n        TRACE_((udp->base.name, \"detach(): inside locked keys\"));\n\n        /* User data is unreferenced on Release build */\n        PJ_UNUSED_ARG(user_data);\n\n        /* As additional checking, check if the same user data is specified */\n        pj_assert(!udp->user_data || user_data == udp->user_data);\n\n        /* First, mark transport as unattached */\n        //udp->attached = PJ_FALSE;\n\n        /* Clear up application infos from transport */\n        udp->rtp_cb = NULL;\n        udp->rtp_cb2 = NULL;\n        udp->rtcp_cb = NULL;\n        udp->user_data = NULL;\n\n        /* Cancel any outstanding operations */\n        pj_ioqueue_clear_key(udp->rtp_key);\n        pj_ioqueue_clear_key(udp->rtcp_key);\n\n        /* Set key status to 'stopped' as keys have been cleared */\n        udp->started = PJ_FALSE;\n\n        /* Unlock keys */\n        pj_ioqueue_unlock_key(udp->rtcp_key);\n        pj_ioqueue_unlock_key(udp->rtp_key);\n\n        PJ_LOG(4,(udp->base.name, \"UDP media transport detached\"));\n    }\n}\n\n\n/* Called by application to send RTP packet */\nstatic pj_status_t transport_send_rtp( pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size)\n{\n    struct transport_udp *udp = (struct transport_udp*)tp;\n    pj_ssize_t sent;\n    unsigned id;\n    struct pending_write *pw;\n    pj_status_t status;\n\n    /* Must be attached */\n    //PJ_ASSERT_RETURN(udp->attached, PJ_EINVALIDOP);\n\n    /* Check that the size is supported */\n    PJ_ASSERT_RETURN(size <= PJMEDIA_MAX_MTU, PJ_ETOOBIG);\n\n    if (!udp->started) {\n        return PJ_SUCCESS;\n    }\n\n    /* Simulate packet lost on TX direction */\n    if (udp->tx_drop_pct) {\n        if ((pj_rand() % 100) <= (int)udp->tx_drop_pct) {\n            PJ_LOG(5,(udp->base.name, \n                      \"TX RTP packet dropped because of pkt lost \"\n                      \"simulation\"));\n            return PJ_SUCCESS;\n        }\n    }\n\n\n    id = udp->rtp_write_op_id;\n    pw = &udp->rtp_pending_write[id];\n    if (pw->is_pending) {\n        /* There is still currently pending operation for this buffer. */\n        PJ_LOG(4,(udp->base.name, \"Too many pending write operations\"));\n        return PJ_EBUSY;\n    }\n    pw->is_pending = PJ_TRUE;\n\n    /* We need to copy packet to our buffer because when the\n     * operation is pending, caller might write something else\n     * to the original buffer.\n     */\n    pj_memcpy(pw->buffer, pkt, size);\n\n    sent = size;\n    status = pj_ioqueue_sendto( udp->rtp_key, \n                                &udp->rtp_pending_write[id].op_key,\n                                pw->buffer, &sent, 0,\n                                &udp->rem_rtp_addr, \n                                udp->addr_len);\n\n    if (status != PJ_EPENDING) {\n        /* Send operation has completed immediately. Clear the flag. */\n        pw->is_pending = PJ_FALSE;\n    }\n\n    udp->rtp_write_op_id = (udp->rtp_write_op_id + 1) %\n                           PJ_ARRAY_SIZE(udp->rtp_pending_write);\n\n    if (status==PJ_SUCCESS || status==PJ_EPENDING)\n        return PJ_SUCCESS;\n\n    return status;\n}\n\n/* Called by application to send RTCP packet */\nstatic pj_status_t transport_send_rtcp(pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size)\n{\n    return transport_send_rtcp2(tp, NULL, 0, pkt, size);\n}\n\n\n/* Called by application to send RTCP packet */\nstatic pj_status_t transport_send_rtcp2(pjmedia_transport *tp,\n                                        const pj_sockaddr_t *addr,\n                                        unsigned addr_len,\n                                        const void *pkt,\n                                        pj_size_t size)\n{\n    struct transport_udp *udp = (struct transport_udp*)tp;\n    pj_ssize_t sent;\n    pj_status_t status;\n\n    //PJ_ASSERT_RETURN(udp->attached, PJ_EINVALIDOP);\n\n    if (!udp->started) {\n        return PJ_SUCCESS;\n    }\n\n    if (addr == NULL) {\n        addr = &udp->rem_rtcp_addr;\n        addr_len = udp->addr_len;\n    }\n\n    sent = size;\n    status = pj_ioqueue_sendto( (udp->use_rtcp_mux? udp->rtp_key:\n                                 udp->rtcp_key), &udp->rtcp_write_op,\n                                pkt, &sent, 0, addr, addr_len);\n\n    if (status==PJ_SUCCESS || status==PJ_EPENDING)\n        return PJ_SUCCESS;\n\n    return status;\n}\n\n\nstatic pj_status_t transport_media_create(pjmedia_transport *tp,\n                                  pj_pool_t *pool,\n                                  unsigned options,\n                                  const pjmedia_sdp_session *sdp_remote,\n                                  unsigned media_index)\n{\n    struct transport_udp *udp = (struct transport_udp*)tp;\n\n    PJ_ASSERT_RETURN(tp && pool, PJ_EINVAL);\n    udp->media_options = options;\n    udp->enable_rtcp_mux = ((options & PJMEDIA_TPMED_RTCP_MUX) != 0);\n\n    PJ_UNUSED_ARG(sdp_remote);\n    PJ_UNUSED_ARG(media_index);\n\n    PJ_LOG(4,(udp->base.name, \"UDP media transport created\"));\n\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t transport_encode_sdp(pjmedia_transport *tp,\n                                        pj_pool_t *pool,\n                                        pjmedia_sdp_session *sdp_local,\n                                        const pjmedia_sdp_session *rem_sdp,\n                                        unsigned media_index)\n{\n    struct transport_udp *udp = (struct transport_udp*)tp;\n\n    /* Validate media transport */\n    /* By now, this transport only support RTP/AVP transport */\n    if ((udp->media_options & PJMEDIA_TPMED_NO_TRANSPORT_CHECKING) == 0) {\n        pjmedia_sdp_media *m_rem, *m_loc;\n        pj_uint32_t tp_proto_loc, tp_proto_rem;\n\n        m_rem = rem_sdp? rem_sdp->media[media_index] : NULL;\n        m_loc = sdp_local->media[media_index];\n\n        tp_proto_loc = pjmedia_sdp_transport_get_proto(&m_loc->desc.transport);\n        tp_proto_rem = m_rem? \n                pjmedia_sdp_transport_get_proto(&m_rem->desc.transport) : 0;\n        PJMEDIA_TP_PROTO_TRIM_FLAG(tp_proto_loc, PJMEDIA_TP_PROFILE_RTCP_FB);\n        PJMEDIA_TP_PROTO_TRIM_FLAG(tp_proto_rem, PJMEDIA_TP_PROFILE_RTCP_FB);\n\n        if ((tp_proto_loc != PJMEDIA_TP_PROTO_RTP_AVP) ||\n            (m_rem && tp_proto_rem != PJMEDIA_TP_PROTO_RTP_AVP))\n        {\n            pjmedia_sdp_media_deactivate(pool, m_loc);\n            return PJMEDIA_SDP_EINPROTO;\n        }\n    }\n    \n    if (udp->enable_rtcp_mux) {\n        pjmedia_sdp_media *m = sdp_local->media[media_index];\n        pjmedia_sdp_attr *attr;\n        pj_bool_t add_rtcp_mux = PJ_TRUE;\n\n        udp->use_rtcp_mux = PJ_FALSE;\n\n        /* Check if remote wants RTCP mux */\n        if (rem_sdp) {\n            pjmedia_sdp_media *rem_m = rem_sdp->media[media_index];\n            \n            attr = pjmedia_sdp_attr_find(rem_m->attr_count, rem_m->attr, \n                                         &STR_RTCP_MUX, NULL);\n            udp->use_rtcp_mux = (attr? PJ_TRUE: PJ_FALSE);\n            add_rtcp_mux = udp->use_rtcp_mux;\n        }\n\n        /* Remove RTCP attribute because for subsequent offers/answers,\n         * the address (obtained from transport_get_info() ) may be\n         * incorrect if we are not yet confirmed to use RTCP mux\n         * (because we are still waiting for remote answer) or\n         * if remote rejects it.\n         */\n        pjmedia_sdp_attr_remove_all(&m->attr_count, m->attr, \"rtcp\");\n        \n        if (!udp->use_rtcp_mux) {\n           /* Add RTCP attribute if the remote doesn't offer or\n            * rejects it.\n            */\n            attr = pjmedia_sdp_attr_create_rtcp(pool,\n                                                &udp->rtcp_addr_name);  \n            if (attr)\n                pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n        }\n\n        /* Add a=rtcp-mux attribute. */\n        if (add_rtcp_mux) {\n            attr = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_attr);\n            attr->name = STR_RTCP_MUX;\n            m->attr[m->attr_count++] = attr;\n        }\n    }\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t transport_media_start(pjmedia_transport *tp,\n                                  pj_pool_t *pool,\n                                  const pjmedia_sdp_session *sdp_local,\n                                  const pjmedia_sdp_session *sdp_remote,\n                                  unsigned media_index)\n{\n    struct transport_udp *udp = (struct transport_udp*)tp;\n    pj_ssize_t size;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    PJ_UNUSED_ARG(pool);\n    PJ_UNUSED_ARG(sdp_local);\n    PJ_UNUSED_ARG(sdp_remote);\n    PJ_UNUSED_ARG(media_index);\n\n    /* Just return success if there is already pending read */\n    if (udp->started) {\n        PJ_LOG(5,(udp->base.name, \"UDP media transport already started\"));\n        return PJ_SUCCESS;\n    }\n\n    pj_ioqueue_op_key_init(&udp->rtp_read_op, sizeof(udp->rtp_read_op));\n    for (i=0; i<PJ_ARRAY_SIZE(udp->rtp_pending_write); ++i) {\n        pj_ioqueue_op_key_init(&udp->rtp_pending_write[i].op_key, \n                               sizeof(udp->rtp_pending_write[i].op_key));\n    }\n\n    pj_ioqueue_op_key_init(&udp->rtcp_read_op, sizeof(udp->rtcp_read_op));\n    pj_ioqueue_op_key_init(&udp->rtcp_write_op, sizeof(udp->rtcp_write_op));\n\n    TRACE_((udp->base.name, \"media_start(): before recvfrom RTP\"));\n\n    /* Kick off pending RTP read from the ioqueue */\n    udp->rtp_addrlen = sizeof(udp->rtp_src_addr);\n    size = sizeof(udp->rtp_pkt);\n    status = pj_ioqueue_recvfrom(udp->rtp_key, &udp->rtp_read_op,\n                                 udp->rtp_pkt, &size, PJ_IOQUEUE_ALWAYS_ASYNC,\n                                 &udp->rtp_src_addr, &udp->rtp_addrlen);\n    if (status != PJ_EPENDING) {\n        PJ_PERROR(3, (udp->base.name, status,\n                      \"media_start(): recvfrom RTP failed\"));\n        return status;\n    }\n\n    TRACE_((udp->base.name, \"media_start(): before recvfrom RTCP\"));\n\n    /* Kick off pending RTCP read from the ioqueue */\n    udp->rtcp_addr_len = sizeof(udp->rtcp_src_addr);\n    size = sizeof(udp->rtcp_pkt);\n    status = pj_ioqueue_recvfrom(udp->rtcp_key, &udp->rtcp_read_op,\n                                 udp->rtcp_pkt, &size,\n                                 PJ_IOQUEUE_ALWAYS_ASYNC,\n                                 &udp->rtcp_src_addr, &udp->rtcp_addr_len);\n    if (status != PJ_EPENDING) {\n        PJ_PERROR(3, (udp->base.name, status,\n                      \"media_start(): recvfrom RTCP failed\"));\n        pj_ioqueue_clear_key(udp->rtp_key);\n        return status;\n    }\n\n    udp->started = PJ_TRUE;\n\n    PJ_LOG(4,(udp->base.name, \"UDP media transport started\"));\n\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t transport_media_stop(pjmedia_transport *tp)\n{\n    struct transport_udp *udp = (struct transport_udp*)tp;\n\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    /* Just return success if there is no pending read */\n    if (!udp->started) {\n        PJ_LOG(5, (udp->base.name, \"UDP media transport already stopped\"));\n        return PJ_SUCCESS;\n    }\n\n    pj_ioqueue_clear_key(udp->rtp_key);\n    pj_ioqueue_clear_key(udp->rtcp_key);\n\n    udp->started = PJ_FALSE;\n\n    PJ_LOG(4, (udp->base.name, \"UDP media transport stopped\"));\n\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n                                           pjmedia_dir dir,\n                                           unsigned pct_lost)\n{\n    struct transport_udp *udp = (struct transport_udp*)tp;\n\n    PJ_ASSERT_RETURN(tp && pct_lost <= 100, PJ_EINVAL);\n\n    if (dir & PJMEDIA_DIR_ENCODING)\n        udp->tx_drop_pct = pct_lost;\n    \n    if (dir & PJMEDIA_DIR_DECODING)\n        udp->rx_drop_pct = pct_lost;\n\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t transport_restart(pj_bool_t is_rtp, \n                                     struct transport_udp *udp)\n{\n    PJ_UNUSED_ARG(udp);\n    PJ_UNUSED_ARG(is_rtp);\n\n    return PJ_ENOTSUP;\n\n/* This code is disabled for the following reason (see also #2881):\n * The following code will set ioqueue key to NULL or replace with a new one,\n * and that may introduces issues, e.g:\n * - this code is invoked from on_rx_rtp/rtcp(), which is invoked by\n *   ioqueue_dispatch_read_event(), which may need to unlock ioqueue key\n *   after returning from the callback (when allow_concurrent is false),\n *   if the ioqueue key has been unregistered by this code, a crash may occur\n *   when unlocking the invalid ioqueue key.\n * - this code may set ioqueue key to NULL, while other code may assume\n *   it may never be changed to NULL, and cause crash, e.g: transport_detach().\n */\n#if 0\n\n    pj_ioqueue_key_t *key = (is_rtp ? udp->rtp_key : udp->rtcp_key);\n    pj_sock_t *sock = (is_rtp ? &udp->rtp_sock : &udp->rtcp_sock);\n    pj_status_t status;\n    int af;\n    pj_sockaddr *addr;\n    pj_ioqueue_callback cb;\n    pj_ssize_t size;\n\n    PJ_LOG(4, (udp->base.name, \"Restarting %s transport\", \n              (is_rtp)?\"RTP\":\"RTCP\"));\n\n    udp->started = PJ_FALSE;\n    /* Destroy existing socket, if any. */    \n    if (key) {\n        /* This will block the execution if callback is still\n         * being called.\n         */\n        pj_ioqueue_unregister(key);\n        if (is_rtp) {\n            udp->rtp_key = NULL;\n        } else {\n            udp->rtcp_key = NULL;\n        }\n    } else if (*sock != PJ_INVALID_SOCKET) {\n        pj_sock_close(*sock);\n    }\n    *sock = PJ_INVALID_SOCKET;   \n\n    /* Create socket */\n    af = udp->rtp_addr_name.addr.sa_family;\n    status = pj_sock_socket(af, pj_SOCK_DGRAM(), 0, sock);\n\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    addr = (is_rtp) ? &udp->rtp_addr_name : &udp->rtcp_addr_name;\n    status = pj_sock_bind(*sock, addr, pj_sockaddr_get_len(addr));\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    /* Set buffer size for RTP socket */\n#if PJMEDIA_TRANSPORT_SO_RCVBUF_SIZE\n    if (is_rtp) {\n        unsigned sobuf_size = PJMEDIA_TRANSPORT_SO_RCVBUF_SIZE;\n\n        pj_sock_setsockopt_sobuf(udp->rtp_sock, pj_SO_RCVBUF(), \n                                 PJ_TRUE, &sobuf_size);\n    }\n#endif\n#if PJMEDIA_TRANSPORT_SO_SNDBUF_SIZE\n    if (is_rtp) {\n        unsigned sobuf_size = PJMEDIA_TRANSPORT_SO_SNDBUF_SIZE;\n\n        pj_sock_setsockopt_sobuf(udp->rtp_sock, pj_SO_SNDBUF(), \n                                 PJ_TRUE, &sobuf_size);\n    }\n#endif\n    pj_bzero(&cb, sizeof(cb));\n    if (is_rtp) {\n        cb.on_read_complete = &on_rx_rtp;\n        cb.on_write_complete = &on_rtp_data_sent;\n    } else {\n        cb.on_read_complete = &on_rx_rtcp;\n    }\n\n    if (is_rtp) {\n        status = pj_ioqueue_register_sock(udp->pool, udp->ioqueue, *sock, udp,\n                                          &cb, &udp->rtp_key);\n    } else {\n        status = pj_ioqueue_register_sock(udp->pool, udp->ioqueue, *sock, udp,\n                                          &cb, &udp->rtcp_key);    \n    }\n\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    if (is_rtp) {\n        size = sizeof(udp->rtp_pkt);\n        status = pj_ioqueue_recvfrom(udp->rtp_key, &udp->rtp_read_op,\n                                     udp->rtp_pkt, &size, \n                                     PJ_IOQUEUE_ALWAYS_ASYNC,\n                                     &udp->rtp_src_addr, &udp->rtp_addrlen);\n    } else {\n        size = sizeof(udp->rtcp_pkt);\n        status = pj_ioqueue_recvfrom(udp->rtcp_key, &udp->rtcp_read_op,\n                                     udp->rtcp_pkt, &size, \n                                     PJ_IOQUEUE_ALWAYS_ASYNC,\n                                     &udp->rtcp_src_addr, &udp->rtcp_addr_len);\n    }\n    if (status != PJ_EPENDING)\n        goto on_error;\n\n    udp->started = PJ_TRUE;\n    PJ_LOG(4, (udp->base.name, \"Success restarting %s transport\", \n              (is_rtp)?\"RTP\":\"RTCP\"));\n    return PJ_SUCCESS;\non_error:\n    if (*sock != PJ_INVALID_SOCKET) {\n        pj_sock_close(*sock);\n        *sock = PJ_INVALID_SOCKET;\n    }\n    PJ_PERROR(1, (udp->base.name, status, \n                 \"Error restarting %s transport\", (is_rtp)?\"RTP\":\"RTCP\"));\n    return status;\n\n#endif\n}\n"], "fixing_code": ["/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#ifndef __PJMEDIA_TRANSPORT_H__\n#define __PJMEDIA_TRANSPORT_H__\n\n\n/**\n * @file transport.h Media Transport Interface\n * @brief Transport interface.\n */\n\n#include <pjmedia/types.h>\n#include <pjmedia/errno.h>\n#include <pj/string.h>\n\n/**\n * @defgroup PJMEDIA_TRANSPORT Media Transport\n * @brief Transports.\n * @{\n * The media transport (#pjmedia_transport) is the object to send and\n * receive media packets over the network. The media transport interface\n * allows the library to be extended to support different types of \n * transports to send and receive packets.\n *\n * The media transport is declared as #pjmedia_transport \"class\", which\n * declares \"interfaces\" to use the class in #pjmedia_transport_op\n * structure. For the user of the media transport (normally the user of\n * media transport is media stream, see \\ref PJMED_STRM), these transport\n * \"methods\" are wrapped with API such as #pjmedia_transport_attach(),\n * so it should not need to call the function pointer inside \n * #pjmedia_transport_op directly.\n *\n * The connection between \\ref PJMED_STRM and media transport is shown in\n * the diagram below:\n\n   \\img{pjmedia/docs/media-transport.PNG}\n\n\n * \\section PJMEDIA_TRANSPORT_H_USING Basic Media Transport Usage\n *\n * The media transport's life-cycle normally follows the following stages.\n *\n * \\subsection PJMEDIA_TRANSPORT_H_CREATE Creating the Media Transport\n *\n *  Application creates the media transport when it needs to establish\n *    media session to remote peer. The media transport is created using\n *    specific function to create that particular transport; for example,\n *    for UDP media transport, it is created with #pjmedia_transport_udp_create()\n *    or #pjmedia_transport_udp_create2() functions. Different media\n *    transports will provide different API to create those transports.\n *\n *  Alternatively, application may create pool of media transports when\n *    it is first started up. Using this approach probably is better, since\n *    application has to specify the RTP port when sending the initial\n *    session establishment request (e.g. SIP INVITE request), thus if\n *    application only creates the media transport later when media is to be\n *    established (normally when 200/OK is received, or when 18x is received\n *    for early media), there is a possibility that the particular RTP\n *    port might have been occupied by other programs. Also it is more\n *    efficient since sockets don't need to be closed and re-opened between\n *    calls.\n *\n *\n * \\subsection PJMEDIA_TRANSPORT_H_ATTACH Attaching and Using the Media Transport.\n *\n *  Application specifies the media transport instance when creating\n *    the media session (#pjmedia_session_create()). Alternatively, it\n *    may create the media stream directly with #pjmedia_stream_create()\n *    and specify the transport instance in the argument. (Note: media\n *    session is a high-level abstraction for media communications between\n *    two endpoints, and it may contain more than one media streams, for\n *    example, an audio stream and a video stream).\n *\n *  When stream is created, it will \"attach\" itself to the media \n *    transport by calling #pjmedia_transport_attach(), which is a thin\n *    wrapper which calls \"attach()\" method of the media transport's \n *    \"virtual function pointer\" (#pjmedia_transport_op). Among other things,\n *    the stream specifies two callback functions to the transport: one\n *    callback function will be called by transport when it receives RTP\n *    packet, and another callback for incoming RTCP packet. The \n *    #pjmedia_transport_attach() function also establish the destination\n *    of the outgoing RTP and RTCP packets.\n *\n *  When the stream needs to send outgoing RTP/RTCP packets, it will\n *    call #pjmedia_transport_send_rtp() and #pjmedia_transport_send_rtcp()\n *    of the media transport API, which is a thin wrapper to call send_rtp() \n *    and send_rtcp() methods in the media transport's \"virtual function \n *    pointer\"  (#pjmedia_transport_op).\n *\n *  When the stream is destroyed, it will \"detach\" itself from\n *    the media transport by calling #pjmedia_transport_detach(), which is\n *    a thin wrapper which calls \"detach()\" method of the media transport's \n *    \"virtual function pointer\" (#pjmedia_transport_op). After the transport\n *    is detached from its user (the stream), it will no longer report \n *    incoming RTP/RTCP packets to the stream, and it will refuse to send\n *    outgoing packets since the destination has been cleared.\n *\n *\n * \\subsection PJMEDIA_TRANSPORT_H_REUSE Reusing the Media Transport.\n *\n *  After transport has been detached, application may re-attach the\n *    transport to another stream if it wants to. Detaching and re-attaching\n *    media transport may be preferable than closing and re-opening the\n *    transport, since it is more efficient (sockets don't need to be\n *    closed and re-opened). However it is up to the application to choose\n *    which method is most suitable for its uses.\n *\n * \n * \\subsection PJMEDIA_TRANSPORT_H_DESTROY Destroying the Media Transport.\n *\n *  Finally if application no longer needs the media transport, it will\n *    call #pjmedia_transport_close() function, which is thin wrapper which \n *    calls \"destroy()\" method of the media transport's  \"virtual function \n *    pointer\" (#pjmedia_transport_op). This function releases\n *    all resources used by the transport, such as sockets and memory.\n *\n *\n * \\section offer_answer Interaction with SDP Offer/Answer\n \n   For basic UDP transport, the \\ref PJMEDIA_TRANSPORT_H_USING above is\n   sufficient to use the media transport. However, more complex media\n   transports such as \\ref PJMEDIA_TRANSPORT_SRTP and \\ref\n   PJMEDIA_TRANSPORT_ICE requires closer interactions with SDP offer and\n   answer negotiation.\n\n   The media transports can interact with the SDP offer/answer via\n   these APIs:\n     - #pjmedia_transport_media_create(), to initialize the media transport\n       for new media session,\n     - #pjmedia_transport_encode_sdp(), to encode SDP offer or answer,\n     - #pjmedia_transport_media_start(), to activate the settings that\n       have been negotiated by SDP offer answer, and\n     - #pjmedia_transport_media_stop(), to deinitialize the media transport\n       and reset the transport to its idle state.\n   \n   The usage of these API in the context of SDP offer answer will be \n   described below.\n\n   \\subsection media_create Initializing Transport for New Session\n\n   Application must call #pjmedia_transport_media_create() before using\n   the transport for a new session.\n\n   \\subsection creat_oa Creating SDP Offer and Answer\n\n   The #pjmedia_transport_encode_sdp() is used to put additional information\n   from the transport to the local SDP, before the SDP is sent and negotiated\n   with remote SDP.\n\n   When creating an offer, call #pjmedia_transport_encode_sdp() with\n   local SDP (and NULL as \\a rem_sdp). The media transport will add the\n   relevant attributes in the local SDP. Application then gives the local\n   SDP to the invite session to be sent to remote agent.\n\n   When creating an answer, also call #pjmedia_transport_encode_sdp(),\n   but this time specify both local and remote SDP to the function. The \n   media transport will once again modify the local SDP and add relevant\n   attributes to the local SDP, if the appropriate attributes related to\n   the transport functionality are present in remote offer. The remote\n   SDP does not contain the relevant attributes, then the specific transport\n   functionality will not be activated for the session.\n\n   The #pjmedia_transport_encode_sdp() should also be called when application\n   sends subsequent SDP offer or answer. The media transport will encode\n   the appropriate attributes based on the state of the session.\n\n   \\subsection media_start Offer/Answer Completion\n\n   Once both local and remote SDP have been negotiated by the \n   \\ref PJMEDIA_SDP_NEG (normally this is part of PJSIP invite session),\n   application should give both local and remote SDP to \n   #pjmedia_transport_media_start() so that the settings are activated\n   for the session. This function should be called for both initial and\n   subsequent SDP negotiation.\n\n   \\subsection media_stop Stopping Transport\n\n   Once session is stop application must call #pjmedia_transport_media_stop()\n   to deactivate the transport feature. Application may reuse the transport\n   for subsequent media session by repeating the #pjmedia_transport_media_create(),\n   #pjmedia_transport_encode_sdp(), #pjmedia_transport_media_start(), and\n   #pjmedia_transport_media_stop() above.\n\n * \\section PJMEDIA_TRANSPORT_H_IMPL Implementing Media Transport\n *\n * To implement a new type of media transport, one needs to \"subclass\" the\n * media transport \"class\" (#pjmedia_transport) by providing the \"methods\"\n * in the media transport \"interface\" (#pjmedia_transport_op), and provides\n * a function to create this new type of transport (similar to \n * #pjmedia_transport_udp_create() function).\n *\n * The media transport is expected to run indepently, that is there should\n * be no polling like function to poll the transport for incoming RTP/RTCP\n * packets. This normally can be done by registering the media sockets to\n * the media endpoint's IOQueue, which allows the transport to be notified\n * when incoming packet has arrived.\n *\n * Alternatively, media transport may utilize thread(s) internally to wait\n * for incoming packets. The thread then will call the appropriate RTP or\n * RTCP callback provided by its user (stream) whenever packet is received.\n * If the transport's user is a stream, then the callbacks provided by the\n * stream will be thread-safe, so the transport may call these callbacks\n * without having to serialize the access with some mutex protection. But\n * the media transport may still have to protect its internal data with\n * mutex protection, since it may be called by application's thread (for\n * example, to send RTP/RTCP packets).\n *\n */\n\n\n#include <pjmedia/sdp.h>\n\nPJ_BEGIN_DECL\n\n\n/**\n * Forward declaration for media transport.\n */\ntypedef struct pjmedia_transport pjmedia_transport;\n\n/**\n * Forward declaration for media transport info.\n */\ntypedef struct pjmedia_transport_info pjmedia_transport_info;\n\n/**\n * Forward declaration for media transport attach param.\n */\ntypedef struct pjmedia_transport_attach_param pjmedia_transport_attach_param;\n\n/**\n * This enumeration specifies the general behaviour of media processing\n */\ntypedef enum pjmedia_tranport_media_option\n{\n    /**\n     * When this flag is specified, the transport will not perform media\n     * transport validation, this is useful when transport is stacked with\n     * other transport, for example when transport UDP is stacked under\n     * transport SRTP, media transport validation only need to be done by \n     * transport SRTP.\n     */\n    PJMEDIA_TPMED_NO_TRANSPORT_CHECKING = 1,\n\n    /**\n     * When this flag is specified, the transport will allow multiplexing\n     * RTP and RTCP, i.e. if the remote agrees, RTCP will be sent using\n     * the same socket for RTP.\n     */\n    PJMEDIA_TPMED_RTCP_MUX = 2\n\n} pjmedia_tranport_media_option;\n\n\n/**\n * Media socket info is used to describe the underlying sockets\n * to be used as media transport.\n */\ntypedef struct pjmedia_sock_info\n{\n    /** The RTP socket handle */\n    pj_sock_t       rtp_sock;\n\n    /** Address to be advertised as the local address for the RTP\n     *  socket, which does not need to be equal as the bound\n     *  address (for example, this address can be the address resolved\n     *  with STUN).\n     */\n    pj_sockaddr     rtp_addr_name;\n\n    /** The RTCP socket handle. */\n    pj_sock_t       rtcp_sock;\n\n    /** Address to be advertised as the local address for the RTCP\n     *  socket, which does not need to be equal as the bound\n     *  address (for example, this address can be the address resolved\n     *  with STUN).\n     */\n    pj_sockaddr     rtcp_addr_name;\n\n} pjmedia_sock_info;\n\n\n/**\n * This structure describes the operations for the stream transport.\n */\nstruct pjmedia_transport_op\n{\n    /**\n     * Get media socket info from the specified transport.\n     *\n     * Application should call #pjmedia_transport_get_info() instead\n     */\n    pj_status_t (*get_info)(pjmedia_transport *tp,\n                            pjmedia_transport_info *info);\n\n    /**\n     * This function is called by the stream when the transport is about\n     * to be used by the stream for the first time, and it tells the transport\n     * about remote RTP address to send the packet and some callbacks to be \n     * called for incoming packets. This function exists for backwards\n     * compatibility. Transports should implement attach2 instead.\n     *\n     * Application should call #pjmedia_transport_attach() instead of \n     * calling this function directly.\n     */\n    pj_status_t (*attach)(pjmedia_transport *tp,\n                          void *user_data,\n                          const pj_sockaddr_t *rem_addr,\n                          const pj_sockaddr_t *rem_rtcp,\n                          unsigned addr_len,\n                          void (*rtp_cb)(void *user_data,\n                                         void *pkt,\n                                         pj_ssize_t size),\n                          void (*rtcp_cb)(void *user_data,\n                                          void *pkt,\n                                          pj_ssize_t size));\n\n    /**\n     * This function is called by the stream when the stream no longer\n     * needs the transport (normally when the stream is about to be closed).\n     * After the transport is detached, it will ignore incoming\n     * RTP/RTCP packets, and will refuse to send outgoing RTP/RTCP packets.\n     * Application may re-attach the media transport to another transport \n     * user (e.g. stream) after the transport has been detached.\n     *\n     * Application should call #pjmedia_transport_detach() instead of \n     * calling this function directly.\n     */\n    void (*detach)(pjmedia_transport *tp,\n                   void *user_data);\n\n    /**\n     * This function is called by the stream to send RTP packet using the \n     * transport.\n     *\n     * Application should call #pjmedia_transport_send_rtp() instead of \n     * calling this function directly.\n     */\n    pj_status_t (*send_rtp)(pjmedia_transport *tp,\n                            const void *pkt,\n                            pj_size_t size);\n\n    /**\n     * This function is called by the stream to send RTCP packet using the\n     * transport.\n     *\n     * Application should call #pjmedia_transport_send_rtcp() instead of \n     * calling this function directly.\n     */\n    pj_status_t (*send_rtcp)(pjmedia_transport *tp,\n                             const void *pkt,\n                             pj_size_t size);\n\n    /**\n     * This function is called by the stream to send RTCP packet using the\n     * transport with destination address other than default specified in\n     * #pjmedia_transport_attach().\n     *\n     * Application should call #pjmedia_transport_send_rtcp2() instead of \n     * calling this function directly.\n     */\n    pj_status_t (*send_rtcp2)(pjmedia_transport *tp,\n                              const pj_sockaddr_t *addr,\n                              unsigned addr_len,\n                              const void *pkt,\n                              pj_size_t size);\n\n    /**\n     * Prepare the transport for a new media session.\n     *\n     * Application should call #pjmedia_transport_media_create() instead of \n     * calling this function directly.\n     */\n    pj_status_t (*media_create)(pjmedia_transport *tp,\n                                pj_pool_t *sdp_pool,\n                                unsigned options,\n                                const pjmedia_sdp_session *remote_sdp,\n                                unsigned media_index);\n\n    /**\n     * This function is called by application to generate the SDP parts\n     * related to transport type, e.g: ICE, SRTP.\n     *\n     * Application should call #pjmedia_transport_encode_sdp() instead of\n     * calling this function directly.\n     */\n    pj_status_t (*encode_sdp)(pjmedia_transport *tp,\n                              pj_pool_t *sdp_pool,\n                              pjmedia_sdp_session *sdp_local,\n                              const pjmedia_sdp_session *rem_sdp,\n                              unsigned media_index);\n\n    /**\n     * This function is called by application to start the transport\n     * based on local and remote SDP.\n     *\n     * Application should call #pjmedia_transport_media_start() instead of \n     * calling this function directly.\n     */\n    pj_status_t (*media_start) (pjmedia_transport *tp,\n                                pj_pool_t *tmp_pool,\n                                const pjmedia_sdp_session *sdp_local,\n                                const pjmedia_sdp_session *sdp_remote,\n                                unsigned media_index);\n\n    /**\n     * This function is called by application to stop the transport.\n     *\n     * Application should call #pjmedia_transport_media_stop() instead of \n     * calling this function directly.\n     */\n    pj_status_t (*media_stop)  (pjmedia_transport *tp);\n\n    /**\n     * This function can be called to simulate packet lost.\n     *\n     * Application should call #pjmedia_transport_simulate_lost() instead of \n     * calling this function directly.\n     */\n    pj_status_t (*simulate_lost)(pjmedia_transport *tp,\n                                 pjmedia_dir dir,\n                                 unsigned pct_lost);\n\n    /**\n     * This function can be called to destroy this transport.\n     *\n     * Application should call #pjmedia_transport_close() instead of \n     * calling this function directly.\n     */\n    pj_status_t (*destroy)(pjmedia_transport *tp);\n\n    /**\n     * This function is called by the stream when the transport is about\n     * to be used by the stream for the first time, and it tells the transport\n     * about remote RTP address to send the packet and some callbacks to be\n     * called for incoming packets.\n     *\n     * Application should call #pjmedia_transport_attach2() instead of\n     * calling this function directly.\n     */\n    pj_status_t (*attach2)(pjmedia_transport *tp,\n                           pjmedia_transport_attach_param *att_param);\n};\n\n\n/**\n * @see pjmedia_transport_op.\n */\ntypedef struct pjmedia_transport_op pjmedia_transport_op;\n\n\n/** \n * Media transport type.\n */\ntypedef enum pjmedia_transport_type\n{\n    /** Media transport using standard UDP */\n    PJMEDIA_TRANSPORT_TYPE_UDP,\n\n    /** Media transport using ICE */\n    PJMEDIA_TRANSPORT_TYPE_ICE,\n\n    /** \n     * Media transport SRTP, this transport is actually security adapter to be\n     * stacked with other transport to enable encryption on the underlying\n     * transport.\n     */\n    PJMEDIA_TRANSPORT_TYPE_SRTP,\n\n    /** Loopback media transport */\n    PJMEDIA_TRANSPORT_TYPE_LOOP,\n\n    /**\n     * Start of user defined transport.\n     */\n    PJMEDIA_TRANSPORT_TYPE_USER\n\n} pjmedia_transport_type;\n\n\n/**\n * This structure declares media transport. A media transport is called\n * by the stream to transmit a packet, and will notify stream when\n * incoming packet is arrived.\n */\nstruct pjmedia_transport\n{\n    /** Transport name (for logging purpose). */\n    char                     name[PJ_MAX_OBJ_NAME];\n\n    /** Transport type. */\n    pjmedia_transport_type   type;\n\n    /** Transport's \"virtual\" function table. */\n    pjmedia_transport_op    *op;\n\n    /** Application/user data */\n    void                    *user_data;\n\n    /** Group lock, for synchronization between destroy() & callbacks. */\n    pj_grp_lock_t           *grp_lock;\n};\n\n/**\n * This structure describes storage buffer of transport specific info.\n * The actual transport specific info contents will be defined by transport\n * implementation. Note that some transport implementations do not need to\n * provide specific info, since the general socket info is enough.\n */\ntypedef struct pjmedia_transport_specific_info\n{\n    /**\n     * Specify media transport type.\n     */\n    pjmedia_transport_type   type;\n\n    /**\n     * Specify storage buffer size of transport specific info.\n     */\n    int                      cbsize;\n\n    /**\n     * Storage buffer of transport specific info.\n     */\n    char                     buffer[PJMEDIA_TRANSPORT_SPECIFIC_INFO_MAXSIZE];\n\n    /**\n     * The media transport instance.\n     */\n    pjmedia_transport       *tp;\n\n} pjmedia_transport_specific_info;\n\n\n/**\n * This structure describes transport informations, including general \n * socket information and specific information of single transport or \n * stacked transports (e.g: SRTP stacked on top of UDP)\n */\nstruct pjmedia_transport_info\n{\n    /**\n     * General socket info.\n     */\n    pjmedia_sock_info sock_info;\n\n    /**\n     * Remote address where RTP/RTCP originated from. In case this transport\n     * hasn't ever received packet, the address can be invalid (zero).\n     */\n    pj_sockaddr     src_rtp_name;\n    pj_sockaddr     src_rtcp_name;\n\n    /**\n     * Specifies number of transport specific info included.\n     */\n    unsigned specific_info_cnt;\n\n    /**\n     * Buffer storage of transport specific info.\n     */\n    pjmedia_transport_specific_info spc_info[PJMEDIA_TRANSPORT_SPECIFIC_INFO_MAXCNT];\n\n};\n\n/**\n * This structure describes the data passed when calling #rtp_cb2().\n */\ntypedef struct pjmedia_tp_cb_param\n{\n    /**\n     * User data.\n     */\n    void               *user_data;\n\n    /**\n     * Packet buffer.\n     */\n    void               *pkt;\n\n    /**\n     * Packet size.\n     */\n    pj_ssize_t          size;\n\n    /**\n     * Packet's source address.\n     */\n    pj_sockaddr        *src_addr;\n\n    /**\n     * Should media transport switch remote address to \\a rtp_src_addr?\n     * Media transport should initialize it to PJ_FALSE, and application\n     * can change the value as necessary.\n     */\n    pj_bool_t           rem_switch;\n\n} pjmedia_tp_cb_param;\n\n/**\n * This structure describes the data passed when calling\n * #pjmedia_transport_attach2().\n */\nstruct pjmedia_transport_attach_param\n{\n    /**\n     * The media stream.\n     */\n    void *stream;\n\n    /**\n     * Indicate the stream type, either it's audio (PJMEDIA_TYPE_AUDIO) \n     * or video (PJMEDIA_TYPE_VIDEO).\n     */\n    pjmedia_type media_type;\n\n    /**\n     * Remote RTP address to send RTP packet to.\n     */\n    pj_sockaddr rem_addr;\n\n    /**\n     * Optional remote RTCP address. If the argument is NULL\n     * or if the address is zero, the RTCP address will be\n     * calculated from the RTP address (which is RTP port plus one).\n     */\n    pj_sockaddr rem_rtcp;\n\n    /**\n     * Length of the remote address.\n     */\n    unsigned addr_len;\n\n    /**\n     * Arbitrary user data to be set when the callbacks are called.\n     */\n    void *user_data;\n\n    /**\n     * Callback to be called when RTP packet is received on the transport.\n     */\n    void (*rtp_cb)(void *user_data, void *pkt, pj_ssize_t);\n\n    /**\n     * Callback to be called when RTCP packet is received on the transport.\n     */\n    void (*rtcp_cb)(void *user_data, void *pkt, pj_ssize_t);\n\n    /**\n     * Callback to be called when RTP packet is received on the transport.\n     */\n    void (*rtp_cb2)(pjmedia_tp_cb_param *param);\n\n};\n\n/**\n * Initialize transport info.\n *\n * @param info      Transport info to be initialized.\n */\nPJ_INLINE(void) pjmedia_transport_info_init(pjmedia_transport_info *info)\n{\n    pj_bzero(info, sizeof(pjmedia_transport_info));\n    info->sock_info.rtp_sock = info->sock_info.rtcp_sock = PJ_INVALID_SOCKET;\n}\n\n\n/**\n * Get media transport info from the specified transport and all underlying \n * transports if any. The transport also contains information about socket info\n * which describes the local address of the transport, and would be needed\n * for example to fill in the \"c=\" and \"m=\" line of local SDP.\n *\n * @param tp        The transport.\n * @param info      Media transport info to be initialized.\n *\n * @return          PJ_SUCCESS on success.\n */\nPJ_INLINE(pj_status_t) pjmedia_transport_get_info(pjmedia_transport *tp,\n                                                  pjmedia_transport_info *info)\n{\n    if (tp && tp->op && tp->op->get_info)\n        return (*tp->op->get_info)(tp, info);\n    \n    return PJ_ENOTSUP;\n}\n\n\n/**\n * Utility API to get transport type specific info from the specified media\n * transport info.\n * \n * @param info      Media transport info.\n * @param type      Media transport type.\n *\n * @return          Pointer to media transport specific info, or NULL if\n *                  specific info for the transport type is not found.\n */\nPJ_INLINE(void*) pjmedia_transport_info_get_spc_info(\n                                                pjmedia_transport_info *info,\n                                                pjmedia_transport_type type)\n{\n    unsigned i;\n    for (i = 0; i < info->specific_info_cnt; ++i) {\n        if (info->spc_info[i].type == type)\n            return (void*)info->spc_info[i].buffer;\n    }\n    return NULL;\n}\n\n\n/**\n * Utility API to get the transport instance from the specified media\n * transport info.\n *\n * @param info      Media transport info.\n * @param type      Media transport type.\n *\n * @return          The media transport instance, or NULL if\n *                  the transport type is not found.\n */\nPJ_INLINE(pjmedia_transport*) pjmedia_transport_info_get_transport(\n                                                pjmedia_transport_info *info,\n                                                pjmedia_transport_type type)\n{\n    unsigned i;\n    for (i = 0; i < info->specific_info_cnt; ++i) {\n        if (info->spc_info[i].type == type)\n            return info->spc_info[i].tp;\n    }\n    return NULL;\n}\n\n\n/**\n * Attach callbacks to be called on receipt of incoming RTP/RTCP packets.\n * This is just a simple wrapper which calls <tt>attach2()</tt> member of\n * the transport if it is implemented, otherwise it calls <tt>attach()</tt>\n * member of the transport.\n *\n * @param tp        The media transport.\n * @param att_param The transport attach param.\n *\n * @return          PJ_SUCCESS on success, or the appropriate error code.\n */\nPJ_INLINE(pj_status_t) pjmedia_transport_attach2(pjmedia_transport *tp,\n                                  pjmedia_transport_attach_param *att_param)\n{\n    if (tp->op->attach2) {\n        return (*tp->op->attach2)(tp, att_param);\n    } else {\n        return (*tp->op->attach)(tp, att_param->user_data, \n                                 (pj_sockaddr_t*)&att_param->rem_addr, \n                                 (pj_sockaddr_t*)&att_param->rem_rtcp, \n                                 att_param->addr_len, att_param->rtp_cb, \n                                 att_param->rtcp_cb);\n    }\n}\n\n\n/**\n * Attach callbacks to be called on receipt of incoming RTP/RTCP packets.\n * This is just a simple wrapper which calls <tt>attach()</tt> member of \n * the transport.\n *\n * @param tp        The media transport.\n * @param user_data Arbitrary user data to be set when the callbacks are \n *                  called.\n * @param rem_addr  Remote RTP address to send RTP packet to.\n * @param rem_rtcp  Optional remote RTCP address. If the argument is NULL\n *                  or if the address is zero, the RTCP address will be\n *                  calculated from the RTP address (which is RTP port\n *                  plus one).\n * @param addr_len  Length of the remote address.\n * @param rtp_cb    Callback to be called when RTP packet is received on\n *                  the transport.\n * @param rtcp_cb   Callback to be called when RTCP packet is received on\n *                  the transport.\n *\n * @return          PJ_SUCCESS on success, or the appropriate error code.\n */\nPJ_INLINE(pj_status_t) pjmedia_transport_attach(pjmedia_transport *tp,\n                                                void *user_data,\n                                                const pj_sockaddr_t *rem_addr,\n                                                const pj_sockaddr_t *rem_rtcp,\n                                                unsigned addr_len,\n                                                void (*rtp_cb)(void *user_data,\n                                                               void *pkt,\n                                                               pj_ssize_t),\n                                                void (*rtcp_cb)(void *usr_data,\n                                                                void*pkt,\n                                                                pj_ssize_t))\n{\n    if (tp->op->attach2) {\n        pjmedia_transport_attach_param param;\n\n        pj_bzero(&param, sizeof(param));\n        param.user_data = user_data;\n        pj_sockaddr_cp(&param.rem_addr, rem_addr);\n        if (rem_rtcp && pj_sockaddr_has_addr(rem_rtcp)) {\n            pj_sockaddr_cp(&param.rem_rtcp, rem_rtcp);\n        } else {\n            /* Copy RTCP address from the RTP address, with port + 1 */\n            pj_memcpy(&param.rem_rtcp, rem_addr, addr_len);\n            pj_sockaddr_set_port(&param.rem_rtcp,\n                                 pj_sockaddr_get_port(rem_addr) + 1);\n        }\n        param.addr_len = addr_len;\n        param.rtp_cb = rtp_cb;\n        param.rtcp_cb = rtcp_cb;\n\n        return (*tp->op->attach2)(tp, &param);\n    } else {\n        return (*tp->op->attach)(tp, user_data, rem_addr, rem_rtcp, addr_len,\n                                 rtp_cb, rtcp_cb);\n    }\n}\n\n\n/**\n * Detach callbacks from the transport.\n * This is just a simple wrapper which calls <tt>detach()</tt> member of \n * the transport. After the transport is detached, it will ignore incoming\n * RTP/RTCP packets, and will refuse to send outgoing RTP/RTCP packets.\n * Application may re-attach the media transport to another transport user\n * (e.g. stream) after the transport has been detached.\n *\n * @param tp        The media transport.\n * @param user_data User data which must match the previously set value\n *                  on attachment.\n */\nPJ_INLINE(void) pjmedia_transport_detach(pjmedia_transport *tp,\n                                         void *user_data)\n{\n    (*tp->op->detach)(tp, user_data);\n}\n\n\n/**\n * Send RTP packet with the specified media transport. This is just a simple\n * wrapper which calls <tt>send_rtp()</tt> member of the transport. The \n * RTP packet will be delivered to the destination address specified in\n * #pjmedia_transport_attach() function.\n *\n * @param tp        The media transport.\n * @param pkt       The packet to send.\n * @param size      Size of the packet.\n *\n * @return          PJ_SUCCESS on success, or the appropriate error code.\n */\nPJ_INLINE(pj_status_t) pjmedia_transport_send_rtp(pjmedia_transport *tp,\n                                                  const void *pkt,\n                                                  pj_size_t size)\n{\n    return (*tp->op->send_rtp)(tp, pkt, size);\n}\n\n\n/**\n * Send RTCP packet with the specified media transport. This is just a simple\n * wrapper which calls <tt>send_rtcp()</tt> member of the transport. The \n * RTCP packet will be delivered to the destination address specified in\n * #pjmedia_transport_attach() function.\n *\n * @param tp        The media transport.\n * @param pkt       The packet to send.\n * @param size      Size of the packet.\n *\n * @return          PJ_SUCCESS on success, or the appropriate error code.\n */\nPJ_INLINE(pj_status_t) pjmedia_transport_send_rtcp(pjmedia_transport *tp,\n                                                  const void *pkt,\n                                                  pj_size_t size)\n{\n    return (*tp->op->send_rtcp)(tp, pkt, size);\n}\n\n\n/**\n * Send RTCP packet with the specified media transport. This is just a simple\n * wrapper which calls <tt>send_rtcp2()</tt> member of the transport. The \n * RTCP packet will be delivered to the destination address specified in\n * param addr, if addr is NULL, RTCP packet will be delivered to destination \n * address specified in #pjmedia_transport_attach() function.\n *\n * @param tp        The media transport.\n * @param addr      The destination address.\n * @param addr_len  Length of destination address.\n * @param pkt       The packet to send.\n * @param size      Size of the packet.\n *\n * @return          PJ_SUCCESS on success, or the appropriate error code.\n */\nPJ_INLINE(pj_status_t) pjmedia_transport_send_rtcp2(pjmedia_transport *tp,\n                                                    const pj_sockaddr_t *addr,\n                                                    unsigned addr_len,\n                                                    const void *pkt,\n                                                    pj_size_t size)\n{\n    return (*tp->op->send_rtcp2)(tp, addr, addr_len, pkt, size);\n}\n\n\n/**\n * Prepare the media transport for a new media session, Application must\n * call this function before starting a new media session using this\n * transport.\n *\n * This is just a simple wrapper which calls <tt>media_create()</tt> member \n * of the transport.\n *\n * @param tp            The media transport.\n * @param sdp_pool      Pool object to allocate memory related to SDP\n *                      messaging components.\n * @param options       Option flags, from #pjmedia_tranport_media_option\n * @param rem_sdp       Remote SDP if local SDP is an answer, otherwise\n *                      specify NULL if SDP is an offer.\n * @param media_index   Media index in SDP.\n *\n * @return              PJ_SUCCESS on success, or the appropriate error code.\n */\nPJ_INLINE(pj_status_t) pjmedia_transport_media_create(pjmedia_transport *tp,\n                                    pj_pool_t *sdp_pool,\n                                    unsigned options,\n                                    const pjmedia_sdp_session *rem_sdp,\n                                    unsigned media_index)\n{\n    return (*tp->op->media_create)(tp, sdp_pool, options, rem_sdp, \n                                   media_index);\n}\n\n\n/**\n * Put transport specific information into the SDP. This function can be\n * called to put transport specific information in the initial or\n * subsequent SDP offer or answer.\n *\n * This is just a simple wrapper which calls <tt>encode_sdp()</tt> member \n * of the transport.\n *\n * @param tp            The media transport.\n * @param sdp_pool      Pool object to allocate memory related to SDP\n *                      messaging components.\n * @param sdp           The local SDP to be filled in information from the\n *                      media transport.\n * @param rem_sdp       Remote SDP if local SDP is an answer, otherwise\n *                      specify NULL if SDP is an offer.\n * @param media_index   Media index in SDP.\n *\n * @return              PJ_SUCCESS on success, or the appropriate error code.\n */\nPJ_INLINE(pj_status_t) pjmedia_transport_encode_sdp(pjmedia_transport *tp,\n                                            pj_pool_t *sdp_pool,\n                                            pjmedia_sdp_session *sdp,\n                                            const pjmedia_sdp_session *rem_sdp,\n                                            unsigned media_index)\n{\n    return (*tp->op->encode_sdp)(tp, sdp_pool, sdp, rem_sdp, media_index);\n}\n\n\n/**\n * Start the transport session with the settings in both local and remote \n * SDP. The actual work that is done by this function depends on the \n * underlying transport type. For SRTP, this will activate the encryption\n * and decryption based on the keys found the SDPs. For ICE, this will\n * start ICE negotiation according to the information found in the SDPs.\n *\n * This is just a simple wrapper which calls <tt>media_start()</tt> member \n * of the transport.\n *\n * @param tp            The media transport.\n * @param tmp_pool      The memory pool for allocating temporary objects.\n * @param sdp_local     Local SDP.\n * @param sdp_remote    Remote SDP.\n * @param media_index   Media index in the SDP.\n *\n * @return              PJ_SUCCESS on success, or the appropriate error code.\n */\nPJ_INLINE(pj_status_t) pjmedia_transport_media_start(pjmedia_transport *tp,\n                                    pj_pool_t *tmp_pool,\n                                    const pjmedia_sdp_session *sdp_local,\n                                    const pjmedia_sdp_session *sdp_remote,\n                                    unsigned media_index)\n{\n    return (*tp->op->media_start)(tp, tmp_pool, sdp_local, sdp_remote, \n                                  media_index);\n}\n\n\n/**\n * This API should be called when the session is stopped, to allow the media\n * transport to release its resources used for the session.\n *\n * This is just a simple wrapper which calls <tt>media_stop()</tt> member \n * of the transport.\n *\n * @param tp            The media transport.\n *\n * @return              PJ_SUCCESS on success, or the appropriate error code.\n */\nPJ_INLINE(pj_status_t) pjmedia_transport_media_stop(pjmedia_transport *tp)\n{\n    return (*tp->op->media_stop)(tp);\n}\n\n/**\n * Close media transport. This is just a simple wrapper which calls \n * <tt>destroy()</tt> member of the transport. This function will free\n * all resources created by this transport (such as sockets, memory, etc.).\n *\n * @param tp        The media transport.\n *\n * @return          PJ_SUCCESS on success, or the appropriate error code.\n */\nPJ_INLINE(pj_status_t) pjmedia_transport_close(pjmedia_transport *tp)\n{\n    if (tp->op->destroy)\n        return (*tp->op->destroy)(tp);\n    else\n        return PJ_SUCCESS;\n}\n\n/**\n * Simulate packet lost in the specified direction (for testing purposes).\n * When enabled, the transport will randomly drop packets to the specified\n * direction.\n *\n * @param tp        The media transport.\n * @param dir       Media direction to which packets will be randomly dropped.\n * @param pct_lost  Percent lost (0-100). Set to zero to disable packet\n *                  lost simulation.\n *\n * @return          PJ_SUCCESS on success.\n */\nPJ_INLINE(pj_status_t) pjmedia_transport_simulate_lost(pjmedia_transport *tp,\n                                                       pjmedia_dir dir,\n                                                       unsigned pct_lost)\n{\n    return (*tp->op->simulate_lost)(tp, dir, pct_lost);\n}\n\n\nPJ_END_DECL\n\n/**\n * @}\n */\n\n\n#endif  /* __PJMEDIA_TRANSPORT_H__ */\n\n", "/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/transport_adapter_sample.h>\n#include <pjmedia/endpoint.h>\n#include <pj/assert.h>\n#include <pj/pool.h>\n\n\n/* Transport functions prototypes */\nstatic pj_status_t transport_get_info (pjmedia_transport *tp,\n                                       pjmedia_transport_info *info);\nstatic pj_status_t transport_attach2  (pjmedia_transport *tp,\n                                       pjmedia_transport_attach_param *att_prm);\nstatic void        transport_detach   (pjmedia_transport *tp,\n                                       void *strm);\nstatic pj_status_t transport_send_rtp( pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_send_rtcp(pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_send_rtcp2(pjmedia_transport *tp,\n                                       const pj_sockaddr_t *addr,\n                                       unsigned addr_len,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_media_create(pjmedia_transport *tp,\n                                       pj_pool_t *sdp_pool,\n                                       unsigned options,\n                                       const pjmedia_sdp_session *rem_sdp,\n                                       unsigned media_index);\nstatic pj_status_t transport_encode_sdp(pjmedia_transport *tp,\n                                       pj_pool_t *sdp_pool,\n                                       pjmedia_sdp_session *local_sdp,\n                                       const pjmedia_sdp_session *rem_sdp,\n                                       unsigned media_index);\nstatic pj_status_t transport_media_start (pjmedia_transport *tp,\n                                       pj_pool_t *pool,\n                                       const pjmedia_sdp_session *local_sdp,\n                                       const pjmedia_sdp_session *rem_sdp,\n                                       unsigned media_index);\nstatic pj_status_t transport_media_stop(pjmedia_transport *tp);\nstatic pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n                                       pjmedia_dir dir,\n                                       unsigned pct_lost);\nstatic pj_status_t transport_destroy  (pjmedia_transport *tp);\n\n\n/* The transport operations */\nstatic struct pjmedia_transport_op tp_adapter_op = \n{\n    &transport_get_info,\n    NULL,\n    &transport_detach,\n    &transport_send_rtp,\n    &transport_send_rtcp,\n    &transport_send_rtcp2,\n    &transport_media_create,\n    &transport_encode_sdp,\n    &transport_media_start,\n    &transport_media_stop,\n    &transport_simulate_lost,\n    &transport_destroy,\n    &transport_attach2,\n};\n\n\n/* The transport adapter instance */\nstruct tp_adapter\n{\n    pjmedia_transport    base;\n    pj_bool_t            del_base;\n\n    pj_pool_t           *pool;\n\n    /* Stream information. */\n    void                *stream_user_data;\n    void                *stream_ref;\n    void               (*stream_rtp_cb)(void *user_data,\n                                        void *pkt,\n                                        pj_ssize_t);\n    void               (*stream_rtp_cb2)(pjmedia_tp_cb_param *param);\n    void               (*stream_rtcp_cb)(void *user_data,\n                                         void *pkt,\n                                         pj_ssize_t);\n\n\n    /* Add your own member here.. */\n    pjmedia_transport   *slave_tp;\n};\n\n\nstatic void adapter_on_destroy(void *arg);\n\n\n/*\n * Create the adapter.\n */\nPJ_DEF(pj_status_t) pjmedia_tp_adapter_create( pjmedia_endpt *endpt,\n                                               const char *name,\n                                               pjmedia_transport *transport,\n                                               pj_bool_t del_base,\n                                               pjmedia_transport **p_tp)\n{\n    pj_pool_t *pool;\n    struct tp_adapter *adapter;\n\n    if (name == NULL)\n        name = \"tpad%p\";\n\n    /* Create the pool and initialize the adapter structure */\n    pool = pjmedia_endpt_create_pool(endpt, name, 512, 512);\n    adapter = PJ_POOL_ZALLOC_T(pool, struct tp_adapter);\n    adapter->pool = pool;\n    pj_ansi_strxcpy(adapter->base.name, pool->obj_name, \n                    sizeof(adapter->base.name));\n    adapter->base.type = (pjmedia_transport_type)\n                         (PJMEDIA_TRANSPORT_TYPE_USER + 1);\n    adapter->base.op = &tp_adapter_op;\n\n    /* Save the transport as the slave transport */\n    adapter->slave_tp = transport;\n    adapter->del_base = del_base;\n\n    /* Setup group lock handler for destroy and callback synchronization */\n    if (transport && transport->grp_lock) {\n        pj_grp_lock_t *grp_lock = transport->grp_lock;\n\n        adapter->base.grp_lock = grp_lock;\n        pj_grp_lock_add_ref(grp_lock);\n        pj_grp_lock_add_handler(grp_lock, pool, adapter, &adapter_on_destroy);\n    }\n\n    /* Done */\n    *p_tp = &adapter->base;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * get_info() is called to get the transport addresses to be put\n * in SDP c= line and a=rtcp line.\n */\nstatic pj_status_t transport_get_info(pjmedia_transport *tp,\n                                      pjmedia_transport_info *info)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n\n    /* Since we don't have our own connection here, we just pass\n     * this function to the slave transport.\n     */\n    return pjmedia_transport_get_info(adapter->slave_tp, info);\n}\n\n\n/* This is our RTP callback, that is called by the slave transport when it\n * receives RTP packet.\n */\nstatic void transport_rtp_cb2(pjmedia_tp_cb_param *param)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)param->user_data;\n\n    pj_assert(adapter->stream_rtp_cb != NULL ||\n              adapter->stream_rtp_cb2 != NULL);\n\n    /* Call stream's callback */\n    if (adapter->stream_rtp_cb2) {\n        pjmedia_tp_cb_param cbparam;\n        \n        pj_memcpy(&cbparam, param, sizeof(cbparam));\n        cbparam.user_data = adapter->stream_user_data;\n        adapter->stream_rtp_cb2(&cbparam);\n    } else {\n        adapter->stream_rtp_cb(adapter->stream_user_data, param->pkt,\n                               param->size);\n    }\n}\n\n/* This is our RTCP callback, that is called by the slave transport when it\n * receives RTCP packet.\n */\nstatic void transport_rtcp_cb(void *user_data, void *pkt, pj_ssize_t size)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)user_data;\n\n    pj_assert(adapter->stream_rtcp_cb != NULL);\n\n    /* Call stream's callback */\n    adapter->stream_rtcp_cb(adapter->stream_user_data, pkt, size);\n}\n\n/*\n * attach2() is called by stream to register callbacks that we should\n * call on receipt of RTP and RTCP packets.\n */\nstatic pj_status_t transport_attach2(pjmedia_transport *tp,\n                                     pjmedia_transport_attach_param *att_param)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n    pj_status_t status;\n\n    /* In this example, we will save the stream information and callbacks\n     * to our structure, and we will register different RTP/RTCP callbacks\n     * instead.\n     */\n    pj_assert(adapter->stream_user_data == NULL);\n    adapter->stream_user_data = att_param->user_data;\n    if (att_param->rtp_cb2) {\n        adapter->stream_rtp_cb2 = att_param->rtp_cb2;\n    } else {\n        adapter->stream_rtp_cb = att_param->rtp_cb;\n    }\n    adapter->stream_rtcp_cb = att_param->rtcp_cb;\n    adapter->stream_ref = att_param->stream;\n\n    att_param->rtp_cb2 = &transport_rtp_cb2;\n    att_param->rtp_cb = NULL;    \n    att_param->rtcp_cb = &transport_rtcp_cb;\n    att_param->user_data = adapter;\n        \n    status = pjmedia_transport_attach2(adapter->slave_tp, att_param);\n    if (status != PJ_SUCCESS) {\n        adapter->stream_user_data = NULL;\n        adapter->stream_rtp_cb = NULL;\n        adapter->stream_rtp_cb2 = NULL;\n        adapter->stream_rtcp_cb = NULL;\n        adapter->stream_ref = NULL;\n        return status;\n    }\n\n    return PJ_SUCCESS;\n}\n\n/* \n * detach() is called when the media is terminated, and the stream is \n * to be disconnected from us.\n */\nstatic void transport_detach(pjmedia_transport *tp, void *strm)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n    \n    PJ_UNUSED_ARG(strm);\n\n    if (adapter->stream_user_data != NULL) {\n        pjmedia_transport_detach(adapter->slave_tp, adapter);\n        adapter->stream_user_data = NULL;\n        adapter->stream_rtp_cb = NULL;\n        adapter->stream_rtp_cb2 = NULL;\n        adapter->stream_rtcp_cb = NULL;\n        adapter->stream_ref = NULL;\n    }\n}\n\n\n/*\n * send_rtp() is called to send RTP packet. The \"pkt\" and \"size\" argument \n * contain both the RTP header and the payload.\n */\nstatic pj_status_t transport_send_rtp( pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n\n    /* You may do some processing to the RTP packet here if you want. */\n\n    /* Send the packet using the slave transport */\n    return pjmedia_transport_send_rtp(adapter->slave_tp, pkt, size);\n}\n\n\n/*\n * send_rtcp() is called to send RTCP packet. The \"pkt\" and \"size\" argument\n * contain the RTCP packet.\n */\nstatic pj_status_t transport_send_rtcp(pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n\n    /* You may do some processing to the RTCP packet here if you want. */\n\n    /* Send the packet using the slave transport */\n    return pjmedia_transport_send_rtcp(adapter->slave_tp, pkt, size);\n}\n\n\n/*\n * This is another variant of send_rtcp(), with the alternate destination\n * address in the argument.\n */\nstatic pj_status_t transport_send_rtcp2(pjmedia_transport *tp,\n                                        const pj_sockaddr_t *addr,\n                                        unsigned addr_len,\n                                        const void *pkt,\n                                        pj_size_t size)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n    return pjmedia_transport_send_rtcp2(adapter->slave_tp, addr, addr_len, \n                                        pkt, size);\n}\n\n/*\n * The media_create() is called when the transport is about to be used for\n * a new call.\n */\nstatic pj_status_t transport_media_create(pjmedia_transport *tp,\n                                          pj_pool_t *sdp_pool,\n                                          unsigned options,\n                                          const pjmedia_sdp_session *rem_sdp,\n                                          unsigned media_index)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n\n    /* if \"rem_sdp\" is not NULL, it means we are UAS. You may do some\n     * inspections on the incoming SDP to verify that the SDP is acceptable\n     * for us. If the SDP is not acceptable, we can reject the SDP by \n     * returning non-PJ_SUCCESS.\n     */\n    if (rem_sdp) {\n        /* Do your stuff.. */\n    }\n\n    /* Once we're done with our initialization, pass the call to the\n     * slave transports to let it do it's own initialization too.\n     */\n    return pjmedia_transport_media_create(adapter->slave_tp, sdp_pool, options,\n                                           rem_sdp, media_index);\n}\n\n/*\n * The encode_sdp() is called when we're about to send SDP to remote party,\n * either as SDP offer or as SDP answer.\n */\nstatic pj_status_t transport_encode_sdp(pjmedia_transport *tp,\n                                        pj_pool_t *sdp_pool,\n                                        pjmedia_sdp_session *local_sdp,\n                                        const pjmedia_sdp_session *rem_sdp,\n                                        unsigned media_index)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n\n    /* If \"rem_sdp\" is not NULL, it means we're encoding SDP answer. You may\n     * do some more checking on the SDP's once again to make sure that\n     * everything is okay before we send SDP.\n     */\n    if (rem_sdp) {\n        /* Do checking stuffs here.. */\n    }\n\n    /* You may do anything to the local_sdp, e.g. adding new attributes, or\n     * even modifying the SDP if you want.\n     */\n    if (1) {\n        /* Say we add a proprietary attribute here.. */\n        pjmedia_sdp_attr *my_attr;\n\n        my_attr = PJ_POOL_ALLOC_T(sdp_pool, pjmedia_sdp_attr);\n        pj_strdup2(sdp_pool, &my_attr->name, \"X-adapter\");\n        pj_strdup2(sdp_pool, &my_attr->value, \"some value\");\n\n        pjmedia_sdp_attr_add(&local_sdp->media[media_index]->attr_count,\n                             local_sdp->media[media_index]->attr,\n                             my_attr);\n    }\n\n    /* And then pass the call to slave transport to let it encode its \n     * information in the SDP. You may choose to call encode_sdp() to slave\n     * first before adding your custom attributes if you want.\n     */\n    return pjmedia_transport_encode_sdp(adapter->slave_tp, sdp_pool, local_sdp,\n                                        rem_sdp, media_index);\n}\n\n/*\n * The media_start() is called once both local and remote SDP have been\n * negotiated successfully, and the media is ready to start. Here we can start\n * committing our processing.\n */\nstatic pj_status_t transport_media_start(pjmedia_transport *tp,\n                                         pj_pool_t *pool,\n                                         const pjmedia_sdp_session *local_sdp,\n                                         const pjmedia_sdp_session *rem_sdp,\n                                         unsigned media_index)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n\n    /* Do something.. */\n\n    /* And pass the call to the slave transport */\n    return pjmedia_transport_media_start(adapter->slave_tp, pool, local_sdp,\n                                         rem_sdp, media_index);\n}\n\n/*\n * The media_stop() is called when media has been stopped.\n */\nstatic pj_status_t transport_media_stop(pjmedia_transport *tp)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n\n    /* Do something.. */\n\n    /* And pass the call to the slave transport */\n    return pjmedia_transport_media_stop(adapter->slave_tp);\n}\n\n/*\n * simulate_lost() is called to simulate packet lost\n */\nstatic pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n                                           pjmedia_dir dir,\n                                           unsigned pct_lost)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n    return pjmedia_transport_simulate_lost(adapter->slave_tp, dir, pct_lost);\n}\n\n\nstatic void adapter_on_destroy(void *arg)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)arg;\n\n    pj_pool_release(adapter->pool);\n}\n\n/*\n * destroy() is called when the transport is no longer needed.\n */\nstatic pj_status_t transport_destroy  (pjmedia_transport *tp)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n\n    /* Close the slave transport */\n    if (adapter->del_base) {\n        pjmedia_transport_close(adapter->slave_tp);\n    }\n\n    if (adapter->base.grp_lock) {\n        pj_grp_lock_dec_ref(adapter->base.grp_lock);\n    } else {\n        adapter_on_destroy(tp);\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n\n\n\n", "/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/transport_ice.h>\n#include <pjnath/errno.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/pool.h>\n#include <pj/rand.h>\n\n#define THIS_FILE   \"transport_ice.c\"\n#if 0\n#   define TRACE__(expr)    PJ_LOG(5,expr)\n#else\n#   define TRACE__(expr)\n#endif\n\nenum oa_role\n{\n    ROLE_NONE,\n    ROLE_OFFERER,\n    ROLE_ANSWERER\n};\n\nstruct sdp_state\n{\n    unsigned            match_comp_cnt; /* Matching number of components    */\n    pj_bool_t           ice_mismatch;   /* Address doesn't match candidates */\n    pj_bool_t           ice_restart;    /* Offer to restart ICE             */\n    pj_ice_sess_role    local_role;     /* Our role                         */\n    pj_bool_t           has_trickle;    /* Has trickle ICE attribute        */\n};\n\n/* ICE listener */\ntypedef struct ice_listener\n{\n    PJ_DECL_LIST_MEMBER(struct ice_listener);\n    pjmedia_ice_cb       cb;\n    void                *user_data;\n} ice_listener;\n\nstruct transport_ice\n{\n    pjmedia_transport    base;\n    pj_pool_t           *pool;\n    unsigned             options;       /**< Transport options.             */\n\n    unsigned             comp_cnt;\n    pj_ice_strans       *ice_st;\n\n    pjmedia_ice_cb       cb;\n    ice_listener         listener;\n    ice_listener         listener_empty;\n    unsigned             media_option;\n\n    pj_bool_t            initial_sdp;\n    enum oa_role         oa_role;       /**< Last role in SDP offer/answer  */\n    struct sdp_state     rem_offer_state;/**< Describes the remote offer    */\n\n    void                *stream;\n    pj_sockaddr          remote_rtp;\n    pj_sockaddr          remote_rtcp;\n    unsigned             addr_len;      /**< Length of addresses.           */\n\n    pj_bool_t            use_ice;\n    pj_sockaddr          rtp_src_addr;  /**< Actual source RTP address.     */\n    unsigned             rtp_src_cnt;   /**< How many pkt from this addr.   */\n    pj_sockaddr          rtcp_src_addr; /**< Actual source RTCP address.    */\n    unsigned             rtcp_src_cnt;  /**< How many pkt from this addr.   */\n    pj_bool_t            enable_rtcp_mux;/**< Enable RTP& RTCP multiplexing?*/\n    pj_bool_t            use_rtcp_mux;  /**< Use RTP & RTCP multiplexing?   */\n\n    unsigned             tx_drop_pct;   /**< Percent of tx pkts to drop.    */\n    unsigned             rx_drop_pct;   /**< Percent of rx pkts to drop.    */\n\n    pj_ice_sess_trickle  trickle_ice;   /**< Trickle ICE mode.              */\n    unsigned             last_send_cand_cnt[PJ_ICE_MAX_COMP];\n                                        /**< Last local candidate count.    */\n    pj_bool_t            end_of_cand;   /**< Local cand gathering done?     */\n    pj_str_t             sdp_mid;       /**< SDP \"a=mid\" attribute.         */\n\n    void               (*rtp_cb)(void*,\n                                 void*,\n                                 pj_ssize_t);\n    void               (*rtp_cb2)(pjmedia_tp_cb_param*);\n    void               (*rtcp_cb)(void*,\n                                  void*,\n                                  pj_ssize_t);\n};\n\n\n/*\n * These are media transport operations.\n */\nstatic pj_status_t transport_get_info (pjmedia_transport *tp,\n                                       pjmedia_transport_info *info);\nstatic pj_status_t transport_attach   (pjmedia_transport *tp,\n                                       void *user_data,\n                                       const pj_sockaddr_t *rem_addr,\n                                       const pj_sockaddr_t *rem_rtcp,\n                                       unsigned addr_len,\n                                       void (*rtp_cb)(void*,\n                                                      void*,\n                                                      pj_ssize_t),\n                                       void (*rtcp_cb)(void*,\n                                                       void*,\n                                                       pj_ssize_t));\nstatic pj_status_t transport_attach2  (pjmedia_transport *tp,\n                                       pjmedia_transport_attach_param\n                                           *att_param);\nstatic void        transport_detach   (pjmedia_transport *tp,\n                                       void *strm);\nstatic pj_status_t transport_send_rtp( pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_send_rtcp(pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_send_rtcp2(pjmedia_transport *tp,\n                                       const pj_sockaddr_t *addr,\n                                       unsigned addr_len,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_media_create(pjmedia_transport *tp,\n                                       pj_pool_t *pool,\n                                       unsigned options,\n                                       const pjmedia_sdp_session *rem_sdp,\n                                       unsigned media_index);\nstatic pj_status_t transport_encode_sdp(pjmedia_transport *tp,\n                                        pj_pool_t *tmp_pool,\n                                        pjmedia_sdp_session *sdp_local,\n                                        const pjmedia_sdp_session *rem_sdp,\n                                        unsigned media_index);\nstatic pj_status_t transport_media_start(pjmedia_transport *tp,\n                                       pj_pool_t *pool,\n                                       const pjmedia_sdp_session *sdp_local,\n                                       const pjmedia_sdp_session *rem_sdp,\n                                       unsigned media_index);\nstatic pj_status_t transport_media_stop(pjmedia_transport *tp);\nstatic pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n                                       pjmedia_dir dir,\n                                       unsigned pct_lost);\nstatic pj_status_t transport_destroy  (pjmedia_transport *tp);\n\n/*\n * And these are ICE callbacks.\n */\nstatic void ice_on_rx_data(pj_ice_strans *ice_st, \n                           unsigned comp_id, \n                           void *pkt, pj_size_t size,\n                           const pj_sockaddr_t *src_addr,\n                           unsigned src_addr_len);\nstatic void ice_on_ice_complete(pj_ice_strans *ice_st, \n                                pj_ice_strans_op op,\n                                pj_status_t status);\nstatic void ice_on_new_candidate(pj_ice_strans *ice_st,\n                                 const pj_ice_sess_cand *cand,\n                                 pj_bool_t last);\n\n/*\n * Clean up ICE resources.\n */\nstatic void tp_ice_on_destroy(void *arg);\n\n\nstatic pjmedia_transport_op transport_ice_op = \n{\n    &transport_get_info,\n    &transport_attach,\n    &transport_detach,\n    &transport_send_rtp,\n    &transport_send_rtcp,\n    &transport_send_rtcp2,\n    &transport_media_create,\n    &transport_encode_sdp,\n    &transport_media_start,\n    &transport_media_stop,\n    &transport_simulate_lost,\n    &transport_destroy,\n    &transport_attach2\n};\n\nstatic const pj_str_t STR_CANDIDATE     = { \"candidate\", 9};\nstatic const pj_str_t STR_REM_CAND      = { \"remote-candidates\", 17 };\nstatic const pj_str_t STR_ICE_LITE      = { \"ice-lite\", 8};\nstatic const pj_str_t STR_ICE_MISMATCH  = { \"ice-mismatch\", 12};\nstatic const pj_str_t STR_ICE_UFRAG     = { \"ice-ufrag\", 9 };\nstatic const pj_str_t STR_ICE_PWD       = { \"ice-pwd\", 7 };\nstatic const pj_str_t STR_IP4           = { \"IP4\", 3 };\nstatic const pj_str_t STR_IP6           = { \"IP6\", 3 };\nstatic const pj_str_t STR_RTCP          = { \"rtcp\", 4 };\nstatic const pj_str_t STR_RTCP_MUX      = { \"rtcp-mux\", 8 };\nstatic const pj_str_t STR_BANDW_RR      = { \"RR\", 2 };\nstatic const pj_str_t STR_BANDW_RS      = { \"RS\", 2 };\nstatic const pj_str_t STR_ICE_OPTIONS   = { \"ice-options\", 11 };\nstatic const pj_str_t STR_TRICKLE       = { \"trickle\", 7 };\nstatic const pj_str_t STR_END_OF_CAND   = { \"end-of-candidates\", 17 };\n\nenum {\n    COMP_RTP = 1,\n    COMP_RTCP = 2\n};\n\n\n/* Forward declaration of internal functions */\n\nstatic int print_sdp_cand_attr(char *buffer, int max_len,\n                               const pj_ice_sess_cand *cand);\nstatic void get_ice_attr(const pjmedia_sdp_session *rem_sdp,\n                         const pjmedia_sdp_media *rem_m,\n                         const pjmedia_sdp_attr **p_ice_ufrag,\n                         const pjmedia_sdp_attr **p_ice_pwd);\nstatic pj_status_t parse_cand(const char *obj_name,\n                              pj_pool_t *pool,\n                              const pj_str_t *orig_input,\n                              pj_ice_sess_cand *cand);\n\n\n/*\n * Create ICE media transport.\n */\nPJ_DEF(pj_status_t) pjmedia_ice_create(pjmedia_endpt *endpt,\n                                       const char *name,\n                                       unsigned comp_cnt,\n                                       const pj_ice_strans_cfg *cfg,\n                                       const pjmedia_ice_cb *cb,\n                                       pjmedia_transport **p_tp)\n{\n    return pjmedia_ice_create2(endpt, name, comp_cnt, cfg, cb, 0, p_tp);\n}\n\n/*\n * Create ICE media transport.\n */\nPJ_DEF(pj_status_t) pjmedia_ice_create2(pjmedia_endpt *endpt,\n                                        const char *name,\n                                        unsigned comp_cnt,\n                                        const pj_ice_strans_cfg *cfg,\n                                        const pjmedia_ice_cb *cb,\n                                        unsigned options,\n                                        pjmedia_transport **p_tp)\n{\n    return pjmedia_ice_create3(endpt, name, comp_cnt, cfg, cb,\n                               options, NULL, p_tp);\n}\n\n/*\n * Create ICE media transport.\n */\nPJ_DEF(pj_status_t) pjmedia_ice_create3(pjmedia_endpt *endpt,\n                                        const char *name,\n                                        unsigned comp_cnt,\n                                        const pj_ice_strans_cfg *cfg,\n                                        const pjmedia_ice_cb *cb,\n                                        unsigned options,\n                                        void *user_data,\n                                        pjmedia_transport **p_tp)\n{\n    pj_pool_t *pool;\n    pj_ice_strans_cb ice_st_cb;\n    pj_ice_strans_cfg ice_st_cfg;\n    struct transport_ice *tp_ice;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(endpt && comp_cnt && cfg && p_tp, PJ_EINVAL);\n\n    /* Create transport instance */\n    pool = pjmedia_endpt_create_pool(endpt, name, 512, 512);\n    tp_ice = PJ_POOL_ZALLOC_T(pool, struct transport_ice);\n    tp_ice->pool = pool;\n    tp_ice->options = options;\n    tp_ice->comp_cnt = comp_cnt;\n    pj_ansi_strxcpy(tp_ice->base.name, pool->obj_name, \n                    sizeof(tp_ice->base.name));\n    tp_ice->base.op = &transport_ice_op;\n    tp_ice->base.type = PJMEDIA_TRANSPORT_TYPE_ICE;\n    tp_ice->base.user_data = user_data;\n    tp_ice->initial_sdp = PJ_TRUE;\n    tp_ice->oa_role = ROLE_NONE;\n    tp_ice->use_ice = PJ_FALSE;\n    tp_ice->trickle_ice = cfg->opt.trickle;\n    pj_list_init(&tp_ice->listener);\n    pj_list_init(&tp_ice->listener_empty);\n\n    pj_memcpy(&ice_st_cfg, cfg, sizeof(pj_ice_strans_cfg));\n    if (cb)\n        pj_memcpy(&tp_ice->cb, cb, sizeof(pjmedia_ice_cb));\n\n    /* Assign return value first because ICE might call callback\n     * in create()\n     */\n    *p_tp = &tp_ice->base;\n\n    /* Configure ICE callbacks */\n    pj_bzero(&ice_st_cb, sizeof(ice_st_cb));\n    ice_st_cb.on_ice_complete = &ice_on_ice_complete;\n    ice_st_cb.on_rx_data = &ice_on_rx_data;\n    ice_st_cb.on_new_candidate = &ice_on_new_candidate;\n\n    /* Configure RTP socket buffer settings, if not set */\n    if (ice_st_cfg.comp[COMP_RTP-1].so_rcvbuf_size == 0) {\n        ice_st_cfg.comp[COMP_RTP-1].so_rcvbuf_size = \n                            PJMEDIA_TRANSPORT_SO_RCVBUF_SIZE;\n    }\n    if (ice_st_cfg.comp[COMP_RTP-1].so_sndbuf_size == 0) {\n        ice_st_cfg.comp[COMP_RTP-1].so_sndbuf_size = \n                            PJMEDIA_TRANSPORT_SO_SNDBUF_SIZE;\n    }\n    if (ice_st_cfg.send_buf_size == 0)\n        ice_st_cfg.send_buf_size = PJMEDIA_MAX_MTU;\n\n    /* Create ICE */\n    status = pj_ice_strans_create(name, &ice_st_cfg, comp_cnt, tp_ice, \n                                  &ice_st_cb, &tp_ice->ice_st);\n    if (status != PJ_SUCCESS) {\n        pj_pool_release(pool);\n        *p_tp = NULL;\n        return status;\n    }\n\n    /* Sync to ICE */\n    {\n        pj_grp_lock_t *grp_lock = pj_ice_strans_get_grp_lock(tp_ice->ice_st);\n        pj_grp_lock_add_ref(grp_lock);\n        pj_grp_lock_add_handler(grp_lock, pool, tp_ice, &tp_ice_on_destroy);\n        tp_ice->base.grp_lock = grp_lock;\n    }\n\n    /* Done */\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_grp_lock_t *) pjmedia_ice_get_grp_lock(pjmedia_transport *tp)\n{\n    PJ_ASSERT_RETURN(tp, NULL);\n    return pj_ice_strans_get_grp_lock(((struct transport_ice *)tp)->ice_st);\n}\n\n\n/*\n * Add application to receive ICE notifications from the specified ICE media\n * transport.\n */\nPJ_DEF(pj_status_t) pjmedia_ice_add_ice_cb( pjmedia_transport *tp,\n                                            const pjmedia_ice_cb *cb,\n                                            void *user_data)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n    ice_listener *il;\n    pj_grp_lock_t *grp_lock;\n\n    PJ_ASSERT_RETURN(tp && cb, PJ_EINVAL);\n    grp_lock = pjmedia_ice_get_grp_lock(tp);\n    PJ_ASSERT_RETURN(grp_lock, PJ_EINVAL);\n\n    pj_grp_lock_acquire(grp_lock);\n\n    if (!pj_list_empty(&tp_ice->listener_empty)) {\n        il = tp_ice->listener_empty.next;\n        pj_list_erase(il);\n        il->cb = *cb;\n        il->user_data = user_data;\n        pj_list_push_back(&tp_ice->listener, il);\n    } else {\n        il = PJ_POOL_ZALLOC_T(tp_ice->pool, ice_listener);\n        pj_list_init(il);\n        il->cb = *cb;\n        il->user_data = user_data;\n        pj_list_push_back(&tp_ice->listener, il);\n    }\n\n    pj_grp_lock_release(grp_lock);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Remove application to stop receiving ICE notifications the specified\n * ICE media transport.\n */\nPJ_DEF(pj_status_t) pjmedia_ice_remove_ice_cb( pjmedia_transport *tp,\n                                               const pjmedia_ice_cb *cb,\n                                               void *user_data)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n    ice_listener *il;\n    pj_grp_lock_t *grp_lock;\n\n    PJ_ASSERT_RETURN(tp && cb, PJ_EINVAL);\n    grp_lock = pjmedia_ice_get_grp_lock(tp);\n    PJ_ASSERT_RETURN(grp_lock, PJ_EINVAL);\n\n    pj_grp_lock_acquire(grp_lock);\n\n    for (il=tp_ice->listener.next; il!=&tp_ice->listener; il=il->next) {\n        if (pj_memcmp(&il->cb, cb, sizeof(*cb))==0 && il->user_data==user_data)\n            break;\n    }\n    if (il != &tp_ice->listener) {\n        pj_list_erase(il);\n        pj_list_push_back(&tp_ice->listener_empty, il);\n    }\n\n    pj_grp_lock_release(grp_lock);\n\n    return (il != &tp_ice->listener? PJ_SUCCESS : PJ_ENOTFOUND);\n}\n\n\n/* Check if trickle support is signalled in the specified SDP. */\nPJ_DEF(pj_bool_t) pjmedia_ice_sdp_has_trickle( const pjmedia_sdp_session *sdp,\n                                               unsigned med_idx)\n{\n    const pjmedia_sdp_media *m;\n    const pjmedia_sdp_attr *a;\n\n    PJ_ASSERT_RETURN(sdp && med_idx < sdp->media_count, PJ_EINVAL);\n\n    /* Find in media level */\n    m = sdp->media[med_idx];\n    a = pjmedia_sdp_attr_find(m->attr_count, m->attr, &STR_ICE_OPTIONS, NULL);\n    if (a && pj_strstr(&a->value, &STR_TRICKLE))\n        return PJ_TRUE;\n\n    /* Find in session level */\n    a = pjmedia_sdp_attr_find(sdp->attr_count, sdp->attr, &STR_ICE_OPTIONS,\n                              NULL);\n    if (a && pj_strstr(&a->value, &STR_TRICKLE))\n        return PJ_TRUE;\n\n    return PJ_FALSE;\n}\n\n\n/* Update check list after discovering and conveying new local ICE candidate,\n * or receiving update of remote ICE candidates in trickle ICE.\n */\nPJ_DEF(pj_status_t) pjmedia_ice_trickle_update(\n                                             pjmedia_transport *tp,\n                                             const pj_str_t *rem_ufrag,\n                                             const pj_str_t *rem_passwd,\n                                             unsigned rcand_cnt,\n                                             const pj_ice_sess_cand rcand[],\n                                             pj_bool_t rcand_end)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(tp_ice && tp_ice->ice_st, PJ_EINVAL);\n    PJ_ASSERT_RETURN(tp_ice->trickle_ice != PJ_ICE_SESS_TRICKLE_DISABLED,\n                     PJ_EINVALIDOP);\n\n\n    /* Update the checklist */\n    status = pj_ice_strans_update_check_list(tp_ice->ice_st,\n                                             rem_ufrag, rem_passwd,\n                                             rcand_cnt, rcand, rcand_end);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Start ICE if both sides have sent their (initial) SDPs */\n    if (!pj_ice_strans_sess_is_running(tp_ice->ice_st)) {\n        unsigned i, comp_cnt;\n\n        comp_cnt = pj_ice_strans_get_running_comp_cnt(tp_ice->ice_st);\n        for (i = 0; i < comp_cnt; ++i) {\n            if (tp_ice->last_send_cand_cnt[i] > 0)\n                break;\n        }\n        if (i != comp_cnt) {\n            pj_str_t rufrag;\n            pj_ice_strans_get_ufrag_pwd(tp_ice->ice_st, NULL, NULL,\n                                        &rufrag, NULL);\n            if (rufrag.slen > 0) {\n                PJ_LOG(3,(THIS_FILE,\"Trickle ICE starts connectivity check\"));\n                status = pj_ice_strans_start_ice(tp_ice->ice_st, NULL, NULL,\n                                                 0, NULL);\n            }\n        }\n    }\n\n    return status;\n}\n\n\n/* Fetch trickle ICE info from the specified SDP. */\nPJ_DEF(pj_status_t) pjmedia_ice_trickle_decode_sdp(\n                                            const pjmedia_sdp_session *sdp,\n                                            unsigned media_index,\n                                            pj_str_t *mid,\n                                            pj_str_t *ufrag,\n                                            pj_str_t *passwd,\n                                            unsigned *cand_cnt,\n                                            pj_ice_sess_cand cand[],\n                                            pj_bool_t *end_of_cand)\n{\n    const pjmedia_sdp_media *m;\n    const pjmedia_sdp_attr *a;\n\n    PJ_ASSERT_RETURN(sdp && media_index < sdp->media_count, PJ_EINVAL);\n\n    m = sdp->media[media_index];\n\n    if (mid) {\n        a = pjmedia_sdp_attr_find2(m->attr_count, m->attr, \"mid\", NULL);\n        if (a) {\n            *mid = a->value;\n        } else {\n            pj_bzero(mid, sizeof(*mid));\n        }\n    }\n\n    if (ufrag && passwd) {\n        const pjmedia_sdp_attr *a_ufrag, *a_pwd;\n        get_ice_attr(sdp, m, &a_ufrag, &a_pwd);\n        if (a_ufrag && a_pwd) {\n            *ufrag = a_ufrag->value;\n            *passwd = a_pwd->value;\n        } else {\n            pj_bzero(ufrag, sizeof(*ufrag));\n            pj_bzero(passwd, sizeof(*passwd));\n        }\n    }\n\n    if (cand_cnt && cand && *cand_cnt > 0) {\n        pj_status_t status;\n        unsigned i, cnt = 0;\n\n        for (i=0; i<m->attr_count && cnt<*cand_cnt; ++i) {\n            a = m->attr[i];\n            if (pj_strcmp(&a->name, &STR_CANDIDATE)!=0)\n                continue;\n\n            /* Parse candidate */\n            status = parse_cand(\"trickle-ice\", NULL, &a->value, &cand[cnt]);\n            if (status != PJ_SUCCESS) {\n                PJ_PERROR(4,(\"trickle-ice\", status,\n                             \"Error in parsing SDP candidate attribute '%.*s', \"\n                             \"candidate is ignored\",\n                             (int)a->value.slen, a->value.ptr));\n                continue;\n            }\n            ++cnt;\n        }\n        *cand_cnt = cnt;\n    }\n\n    if (end_of_cand) {\n        a = pjmedia_sdp_attr_find(m->attr_count, m->attr, &STR_END_OF_CAND,\n                                  NULL);\n        if (!a) {\n            a = pjmedia_sdp_attr_find(sdp->attr_count, sdp->attr,\n                                      &STR_END_OF_CAND, NULL);\n        }\n        *end_of_cand = (a != NULL);\n    }\n    return PJ_SUCCESS;\n}\n\n\n/* Generate SDP attributes for trickle ICE in the specified SDP. */\nPJ_DEF(pj_status_t) pjmedia_ice_trickle_encode_sdp(\n                                            pj_pool_t *sdp_pool,\n                                            pjmedia_sdp_session *sdp,\n                                            const pj_str_t *mid,\n                                            const pj_str_t *ufrag,\n                                            const pj_str_t *passwd,\n                                            unsigned cand_cnt,\n                                            const pj_ice_sess_cand cand[],\n                                            pj_bool_t end_of_cand)\n{\n    pjmedia_sdp_media *m = NULL;\n    pjmedia_sdp_attr *a;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(sdp_pool && sdp, PJ_EINVAL);\n\n    /* Find media by checking \"a=mid\"*/\n    for (i = 0; i < sdp->media_count; ++i) {\n        m = sdp->media[i];\n        a = pjmedia_sdp_media_find_attr2(m, \"mid\", NULL);\n        if (a && pj_strcmp(&a->value, mid)==0)\n            break;\n    }\n\n    /* Media not exist, try to add it */\n    if (i == sdp->media_count) {\n        if (sdp->media_count >= PJMEDIA_MAX_SDP_MEDIA) {\n            PJ_LOG(3,(THIS_FILE,\"Trickle ICE failed to encode candidates, \"\n                                \"the specified SDP has too many media\"));\n            return PJ_ETOOMANY;\n        }\n\n        /* Add a new media to the SDP */\n        m = PJ_POOL_ZALLOC_T(sdp_pool, pjmedia_sdp_media);\n        m->desc.media = pj_str(\"audio\");\n        m->desc.fmt_count = 1;\n        m->desc.fmt[0] = pj_str(\"0\");\n        m->desc.transport = pj_str(\"RTP/AVP\");\n        sdp->media[sdp->media_count++] = m;\n\n        /* Add media ID attribute \"a=mid\" */\n        a = pjmedia_sdp_attr_create(sdp_pool, \"mid\", mid);\n        pjmedia_sdp_attr_add(&m->attr_count, m->attr, a);\n    }\n\n    /* Add \"a=ice-options:trickle\" in session level */\n    a = pjmedia_sdp_attr_find(sdp->attr_count, sdp->attr, &STR_ICE_OPTIONS,\n                              NULL);\n    if (!a || !pj_strstr(&a->value, &STR_TRICKLE)) {\n        a = pjmedia_sdp_attr_create(sdp_pool, STR_ICE_OPTIONS.ptr,\n                                    &STR_TRICKLE);\n        pjmedia_sdp_attr_add(&sdp->attr_count, sdp->attr, a);\n    }\n\n    /* Add \"a=ice-options:trickle\" in media level */\n    /*\n    a = pjmedia_sdp_attr_find(m->attr_count, m->attr, &STR_ICE_OPTIONS,\n                              NULL);\n    if (!a || !pj_strstr(&a->value, &STR_TRICKLE)) {\n        a = pjmedia_sdp_attr_create(sdp_pool, STR_ICE_OPTIONS.ptr,\n                                    &STR_TRICKLE);\n        pjmedia_sdp_attr_add(&m->attr_count, m->attr, a);\n    }\n    */\n\n    /* Add ice-ufrag & ice-pwd attributes */\n    if (ufrag && passwd &&\n        !pjmedia_sdp_attr_find(m->attr_count, m->attr, &STR_ICE_UFRAG, NULL))\n    {\n        a = pjmedia_sdp_attr_create(sdp_pool, STR_ICE_UFRAG.ptr, ufrag);\n        pjmedia_sdp_attr_add(&m->attr_count, m->attr, a);\n\n        a = pjmedia_sdp_attr_create(sdp_pool, STR_ICE_PWD.ptr, passwd);\n        pjmedia_sdp_attr_add(&m->attr_count, m->attr, a);\n    }\n\n    /* Add candidates */\n    for (i=0; i<cand_cnt; ++i) {\n        enum {\n            ATTR_BUF_LEN = 160, /* Max len of a=candidate attr */\n            RATTR_BUF_LEN= 160  /* Max len of a=remote-candidates attr */\n        };\n        char attr_buf[ATTR_BUF_LEN];\n        pj_str_t value;\n\n        value.slen = print_sdp_cand_attr(attr_buf, ATTR_BUF_LEN, &cand[i]);\n        if (value.slen < 0) {\n            pj_assert(!\"Not enough attr_buf to print candidate\");\n            return PJ_EBUG;\n        }\n\n        value.ptr = attr_buf;\n        a = pjmedia_sdp_attr_create(sdp_pool, STR_CANDIDATE.ptr, &value);\n        pjmedia_sdp_attr_add(&m->attr_count, m->attr, a);\n    }\n\n    /* Add \"a=end-of-candidates\" */\n    if (end_of_cand) {\n        a = pjmedia_sdp_attr_find(m->attr_count, m->attr, &STR_END_OF_CAND,\n                                  NULL);\n        if (!a) {\n            a = pjmedia_sdp_attr_create(sdp_pool, STR_END_OF_CAND.ptr, NULL);\n            pjmedia_sdp_attr_add(&m->attr_count, m->attr, a);\n        }\n    }\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_bool_t) pjmedia_ice_trickle_has_new_cand(pjmedia_transport *tp)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n    unsigned i, comp_cnt;\n\n    /* Make sure ICE transport has session already */\n    if (!tp_ice->ice_st || !pj_ice_strans_has_sess(tp_ice->ice_st))\n        return PJ_FALSE;\n\n    /* Count all local candidates */\n    comp_cnt = pj_ice_strans_get_running_comp_cnt(tp_ice->ice_st);\n    for (i = 0; i < comp_cnt; ++i) {\n        if (tp_ice->last_send_cand_cnt[i] <\n            pj_ice_strans_get_cands_count(tp_ice->ice_st, i+1))\n        {\n            return PJ_TRUE;\n        }\n    }\n    return PJ_FALSE;\n}\n\n\n/* Add any new local candidates to the specified SDP to be conveyed to\n * remote (e.g: via SIP INFO).\n */\nPJ_DEF(pj_status_t) pjmedia_ice_trickle_send_local_cand(\n                                            pjmedia_transport *tp,\n                                            pj_pool_t *sdp_pool,\n                                            pjmedia_sdp_session *sdp,\n                                            pj_bool_t *p_end_of_cand)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n    pj_str_t ufrag, pwd;\n    pj_ice_sess_cand cand[PJ_ICE_MAX_CAND];\n    unsigned cand_cnt, i, comp_cnt;\n    pj_bool_t end_of_cand;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(tp && sdp_pool && sdp, PJ_EINVAL);\n\n    /* Make sure ICE transport has session already */\n    if (!tp_ice->ice_st || !pj_ice_strans_has_sess(tp_ice->ice_st))\n        return PJ_EINVALIDOP;\n\n    end_of_cand = tp_ice->end_of_cand;\n\n    /* Get ufrag and pwd from current session */\n    pj_ice_strans_get_ufrag_pwd(tp_ice->ice_st, &ufrag, &pwd, NULL, NULL);\n\n    cand_cnt = 0;\n    comp_cnt = pj_ice_strans_get_running_comp_cnt(tp_ice->ice_st);\n    for (i = 0; i < comp_cnt; ++i) {\n        unsigned cnt = PJ_ICE_MAX_CAND - cand_cnt;\n\n        /* Get all local candidates for this comp */\n        status = pj_ice_strans_enum_cands(tp_ice->ice_st, i+1,\n                                          &cnt, &cand[cand_cnt]);\n        if (status != PJ_SUCCESS) {\n            PJ_PERROR(3,(tp_ice->base.name, status,\n                         \"Failed enumerating local candidates for comp-id=%d\",\n                         i+1));\n            continue;\n        }\n        cand_cnt += cnt;\n\n        tp_ice->last_send_cand_cnt[i] = cnt;\n    }\n\n    /* Update the SDP with all local candidates (not just the new ones).\n     * https://tools.ietf.org/html/draft-ietf-mmusic-trickle-ice-sip-18:\n     * 4.4. Delivering Candidates in INFO Requests: the agent MUST\n     * repeat in the INFO request body all candidates that were previously\n     * sent under the same combination of \"a=ice-pwd:\" and \"a=ice-ufrag:\"\n     * in the same order as they were sent before.\n     */\n    status = pjmedia_ice_trickle_encode_sdp(sdp_pool, sdp, &tp_ice->sdp_mid,\n                                            &ufrag, &pwd, cand_cnt, cand,\n                                            end_of_cand);\n    if (status != PJ_SUCCESS) {\n        PJ_PERROR(3,(tp_ice->base.name, status,\n                     \"Failed encoding local candidates to SDP\"));\n    }\n\n    if (p_end_of_cand)\n        *p_end_of_cand = end_of_cand;\n\n    return PJ_SUCCESS;\n}\n\n\n/* Disable ICE when SDP from remote doesn't contain a=candidate line */\nstatic void set_no_ice(struct transport_ice *tp_ice, const char *reason,\n                       pj_status_t err)\n{\n    if (err != PJ_SUCCESS) {\n        PJ_PERROR(4,(tp_ice->base.name, err,\n                     \"Stopping ICE, reason=%s\", reason));\n    } else {\n        PJ_LOG(4,(tp_ice->base.name, \n                  \"Stopping ICE, reason=%s\", reason));\n    }\n\n    if (tp_ice->ice_st) {\n        pj_ice_strans_stop_ice(tp_ice->ice_st);\n    }\n\n    tp_ice->use_ice = PJ_FALSE;\n}\n\n\n/* Create SDP candidate attribute */\nstatic int print_sdp_cand_attr(char *buffer, int max_len,\n                               const pj_ice_sess_cand *cand)\n{\n    char ipaddr[PJ_INET6_ADDRSTRLEN+2];\n    int len, len2;\n\n    len = pj_ansi_snprintf( buffer, max_len,\n                            \"%.*s %u UDP %u %s %u typ \",\n                            (int)cand->foundation.slen,\n                            cand->foundation.ptr,\n                            (unsigned)cand->comp_id,\n                            cand->prio,\n                            pj_sockaddr_print(&cand->addr, ipaddr, \n                                              sizeof(ipaddr), 0),\n                            (unsigned)pj_sockaddr_get_port(&cand->addr));\n    if (len < 1 || len >= max_len)\n        return -1;\n\n    switch (cand->type) {\n    case PJ_ICE_CAND_TYPE_HOST:\n        len2 = pj_ansi_snprintf(buffer+len, max_len-len, \"host\");\n        break;\n    case PJ_ICE_CAND_TYPE_SRFLX:\n    case PJ_ICE_CAND_TYPE_RELAYED:\n    case PJ_ICE_CAND_TYPE_PRFLX:\n        len2 = pj_ansi_snprintf(buffer+len, max_len-len,\n                                \"%s raddr %s rport %d\",\n                                pj_ice_get_cand_type_name(cand->type),\n                                pj_sockaddr_print(&cand->rel_addr, ipaddr,\n                                                  sizeof(ipaddr), 0),\n                                (int)pj_sockaddr_get_port(&cand->rel_addr));\n        break;\n    default:\n        pj_assert(!\"Invalid candidate type\");\n        len2 = -1;\n        break;\n    }\n    if (len2 < 1 || len2 >= max_len-len)\n        return -1;\n\n    return len+len2;\n}\n\n\n/* Get ice-ufrag and ice-pwd attribute */\nstatic void get_ice_attr(const pjmedia_sdp_session *rem_sdp,\n                         const pjmedia_sdp_media *rem_m,\n                         const pjmedia_sdp_attr **p_ice_ufrag,\n                         const pjmedia_sdp_attr **p_ice_pwd)\n{\n    pjmedia_sdp_attr *attr;\n\n    /* Find ice-ufrag attribute in media descriptor */\n    attr = pjmedia_sdp_attr_find(rem_m->attr_count, rem_m->attr,\n                                 &STR_ICE_UFRAG, NULL);\n    if (attr == NULL) {\n        /* Find ice-ufrag attribute in session descriptor */\n        attr = pjmedia_sdp_attr_find(rem_sdp->attr_count, rem_sdp->attr,\n                                     &STR_ICE_UFRAG, NULL);\n    }\n    *p_ice_ufrag = attr;\n\n    /* Find ice-pwd attribute in media descriptor */\n    attr = pjmedia_sdp_attr_find(rem_m->attr_count, rem_m->attr,\n                                 &STR_ICE_PWD, NULL);\n    if (attr == NULL) {\n        /* Find ice-pwd attribute in session descriptor */\n        attr = pjmedia_sdp_attr_find(rem_sdp->attr_count, rem_sdp->attr,\n                                     &STR_ICE_PWD, NULL);\n    }\n    *p_ice_pwd = attr;\n}\n\n\n/* Encode and add \"a=ice-mismatch\" attribute in the SDP */\nstatic void encode_ice_mismatch(pj_pool_t *sdp_pool,\n                                pjmedia_sdp_session *sdp_local,\n                                unsigned media_index)\n{\n    pjmedia_sdp_attr *attr;\n    pjmedia_sdp_media *m = sdp_local->media[media_index];\n\n    attr = PJ_POOL_ALLOC_T(sdp_pool, pjmedia_sdp_attr);\n    attr->name = STR_ICE_MISMATCH;\n    attr->value.slen = 0;\n    pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n}\n\n\n/* Encode ICE information in SDP */\nstatic pj_status_t encode_session_in_sdp(struct transport_ice *tp_ice,\n                                         pj_pool_t *sdp_pool,\n                                         pjmedia_sdp_session *sdp_local,\n                                         unsigned media_index,\n                                         unsigned comp_cnt,\n                                         pj_bool_t restart_session,\n                                         pj_bool_t rtcp_mux,\n                                         pj_bool_t trickle)\n{\n    enum { \n        ATTR_BUF_LEN = 160,     /* Max len of a=candidate attr */\n        RATTR_BUF_LEN= 160      /* Max len of a=remote-candidates attr */\n    };\n    pjmedia_sdp_media *m = sdp_local->media[media_index];\n    pj_str_t local_ufrag, local_pwd;\n    pjmedia_sdp_attr *attr;\n    pj_status_t status;\n\n    /* Must have a session */\n    PJ_ASSERT_RETURN(pj_ice_strans_has_sess(tp_ice->ice_st), PJ_EBUG);\n\n    /* Get ufrag and pwd from current session */\n    pj_ice_strans_get_ufrag_pwd(tp_ice->ice_st, &local_ufrag, &local_pwd,\n                                NULL, NULL);\n\n    /* The listing of candidates depends on whether ICE has completed\n     * or not. When ICE has completed:\n     *\n     * 9.1.2.2: Existing Media Streams with ICE Completed\n     *   The agent MUST include a candidate attributes for candidates\n     *   matching the default destination for each component of the \n     *   media stream, and MUST NOT include any other candidates.\n     *\n     * When ICE has not completed, we shall include all candidates.\n     *\n     * Except when we have detected that remote is offering to restart\n     * the session, in this case we will answer with full ICE SDP and\n     * new ufrag/pwd pair.\n     */\n    if (!restart_session && pj_ice_strans_sess_is_complete(tp_ice->ice_st) &&\n        pj_ice_strans_get_state(tp_ice->ice_st) != PJ_ICE_STRANS_STATE_FAILED)\n    {\n        const pj_ice_sess_check *check;\n        char *attr_buf;\n        pjmedia_sdp_conn *conn;\n        pjmedia_sdp_attr *a_rtcp;\n        pj_str_t rem_cand;\n        unsigned comp;\n\n        /* Encode ice-ufrag attribute */\n        attr = pjmedia_sdp_attr_create(sdp_pool, STR_ICE_UFRAG.ptr,\n                                       &local_ufrag);\n        pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n\n        /* Encode ice-pwd attribute */\n        attr = pjmedia_sdp_attr_create(sdp_pool, STR_ICE_PWD.ptr, \n                                       &local_pwd);\n        pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n\n        /* Prepare buffer */\n        attr_buf = (char*) pj_pool_alloc(sdp_pool, ATTR_BUF_LEN);\n        rem_cand.ptr = (char*) pj_pool_alloc(sdp_pool, RATTR_BUF_LEN);\n        rem_cand.slen = 0;\n\n        /* 9.1.2.2: Existing Media Streams with ICE Completed\n         *   The default destination for media (i.e., the values of \n         *   the IP addresses and ports in the m and c line used for\n         *   that media stream) MUST be the local candidate from the\n         *   highest priority nominated pair in the valid list for each\n         *   component.\n         */\n        check = pj_ice_strans_get_valid_pair(tp_ice->ice_st, 1);\n        if (check == NULL) {\n            pj_assert(!\"Shouldn't happen\");\n            return PJ_EBUG;\n        }\n\n        /* Override connection line address and media port number */\n        conn = m->conn;\n        if (conn == NULL)\n            conn = sdp_local->conn;\n\n        conn->addr.ptr = (char*) pj_pool_alloc(sdp_pool, \n                                               PJ_INET6_ADDRSTRLEN);\n        pj_sockaddr_print(&check->lcand->addr, conn->addr.ptr, \n                          PJ_INET6_ADDRSTRLEN, 0);\n        conn->addr.slen = pj_ansi_strlen(conn->addr.ptr);\n        m->desc.port = pj_sockaddr_get_port(&check->lcand->addr);\n\n        /* Override address RTCP attribute if it's present */\n        if (comp_cnt == 2 &&\n            (check = pj_ice_strans_get_valid_pair(tp_ice->ice_st, \n                                                  COMP_RTCP)) != NULL &&\n            (a_rtcp = pjmedia_sdp_attr_find(m->attr_count, m->attr, \n                                            &STR_RTCP, 0)) != NULL) \n        {\n            pjmedia_sdp_attr_remove(&m->attr_count, m->attr, a_rtcp);\n\n            a_rtcp = pjmedia_sdp_attr_create_rtcp(sdp_pool, \n                                                  &check->lcand->addr);\n            if (a_rtcp)\n                pjmedia_sdp_attr_add(&m->attr_count, m->attr, a_rtcp);\n        }\n\n        /* Encode only candidates matching the default destination \n         * for each component \n         */\n        for (comp=0; comp < comp_cnt; ++comp) {\n            int len;\n            pj_str_t value;\n\n            /* Get valid pair for this component */\n            check = pj_ice_strans_get_valid_pair(tp_ice->ice_st, comp+1);\n            if (check == NULL)\n                continue;\n\n            /* Print and add local candidate in the pair */\n            value.ptr = attr_buf;\n            value.slen = print_sdp_cand_attr(attr_buf, ATTR_BUF_LEN, \n                                             check->lcand);\n            if (value.slen < 0) {\n                pj_assert(!\"Not enough attr_buf to print candidate\");\n                return PJ_EBUG;\n            }\n\n            attr = pjmedia_sdp_attr_create(sdp_pool, STR_CANDIDATE.ptr,\n                                           &value);\n            pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n\n            /* Append to a=remote-candidates attribute */\n            if (pj_ice_strans_get_role(tp_ice->ice_st) == \n                                    PJ_ICE_SESS_ROLE_CONTROLLING) \n            {\n                char rem_addr[PJ_INET6_ADDRSTRLEN];\n\n                pj_sockaddr_print(&check->rcand->addr, rem_addr, \n                                  sizeof(rem_addr), 0);\n                len = pj_ansi_snprintf(\n                           rem_cand.ptr + rem_cand.slen,\n                           RATTR_BUF_LEN - rem_cand.slen,\n                           \"%s%u %s %u\", \n                           (rem_cand.slen==0? \"\" : \" \"),\n                           comp+1, rem_addr,\n                           pj_sockaddr_get_port(&check->rcand->addr)\n                           );\n                if (len < 1 || len >= RATTR_BUF_LEN - rem_cand.slen) {\n                    pj_assert(!\"Not enough buffer to print \"\n                               \"remote-candidates\");\n                    return PJ_EBUG;\n                }\n\n                rem_cand.slen += len;\n            }\n        }\n\n        /* 9.1.2.2: Existing Media Streams with ICE Completed\n         *   In addition, if the agent is controlling, it MUST include\n         *   the a=remote-candidates attribute for each media stream \n         *   whose check list is in the Completed state.  The attribute\n         *   contains the remote candidates from the highest priority \n         *   nominated pair in the valid list for each component of that\n         *   media stream.\n         */\n        if (pj_ice_strans_get_role(tp_ice->ice_st) == \n                                    PJ_ICE_SESS_ROLE_CONTROLLING) \n        {\n            attr = pjmedia_sdp_attr_create(sdp_pool, STR_REM_CAND.ptr, \n                                           &rem_cand);\n            pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n        }\n\n    } else if (pj_ice_strans_has_sess(tp_ice->ice_st) &&\n               (restart_session || pj_ice_strans_get_state(tp_ice->ice_st) !=\n                PJ_ICE_STRANS_STATE_FAILED))\n    {\n        /* Encode all candidates to SDP media */\n        char *attr_buf;\n        unsigned comp;\n\n        /* If ICE is not restarted, encode current ICE ufrag/pwd.\n         * Otherwise generate new one.\n         */\n        if (!restart_session) {\n            attr = pjmedia_sdp_attr_create(sdp_pool, STR_ICE_UFRAG.ptr,\n                                           &local_ufrag);\n            pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n\n            attr = pjmedia_sdp_attr_create(sdp_pool, STR_ICE_PWD.ptr, \n                                           &local_pwd);\n            pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n\n        } else {\n            pj_str_t str;\n\n            str.slen = PJ_ICE_UFRAG_LEN;\n            str.ptr = (char*) pj_pool_alloc(sdp_pool, str.slen);\n            pj_create_random_string(str.ptr, str.slen);\n            attr = pjmedia_sdp_attr_create(sdp_pool, STR_ICE_UFRAG.ptr, &str);\n            pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n\n            str.slen = PJ_ICE_PWD_LEN;\n            str.ptr = (char*) pj_pool_alloc(sdp_pool, str.slen);\n            pj_create_random_string(str.ptr, str.slen);\n            attr = pjmedia_sdp_attr_create(sdp_pool, STR_ICE_PWD.ptr, &str);\n            pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n        }\n\n        /* Create buffer to encode candidates as SDP attribute */\n        attr_buf = (char*) pj_pool_alloc(sdp_pool, ATTR_BUF_LEN);\n\n        for (comp=0; comp < comp_cnt; ++comp) {\n            unsigned cand_cnt;\n            pj_ice_sess_cand cand[PJ_ICE_ST_MAX_CAND];\n            unsigned i;\n\n            cand_cnt = PJ_ARRAY_SIZE(cand);\n            status = pj_ice_strans_enum_cands(tp_ice->ice_st, comp+1,\n                                              &cand_cnt, cand);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            for (i=0; i<cand_cnt; ++i) {\n                pj_str_t value;\n\n                value.slen = print_sdp_cand_attr(attr_buf, ATTR_BUF_LEN, \n                                                 &cand[i]);\n                if (value.slen < 0) {\n                    pj_assert(!\"Not enough attr_buf to print candidate\");\n                    return PJ_EBUG;\n                }\n\n                value.ptr = attr_buf;\n                attr = pjmedia_sdp_attr_create(sdp_pool, \n                                               STR_CANDIDATE.ptr,\n                                               &value);\n                pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n            }\n        }\n    } else {\n        /* ICE has failed, application should have terminated this call */\n    }\n\n    /* Removing a=rtcp line when there is only one component. */\n    if (comp_cnt == 1) {\n        attr = pjmedia_sdp_attr_find(m->attr_count, m->attr, &STR_RTCP, NULL);\n        if (attr)\n            pjmedia_sdp_attr_remove(&m->attr_count, m->attr, attr);\n        /* If RTCP is not in use, we MUST send b=RS:0 and b=RR:0. */\n        pj_assert(m->bandw_count + 2 <= PJ_ARRAY_SIZE(m->bandw));\n        if (m->bandw_count + 2 <= PJ_ARRAY_SIZE(m->bandw)) {\n            m->bandw[m->bandw_count] = PJ_POOL_ZALLOC_T(sdp_pool,\n                                                        pjmedia_sdp_bandw);\n            pj_memcpy(&m->bandw[m->bandw_count]->modifier, &STR_BANDW_RS,\n                      sizeof(pj_str_t));\n            m->bandw_count++;\n            m->bandw[m->bandw_count] = PJ_POOL_ZALLOC_T(sdp_pool,\n                                                        pjmedia_sdp_bandw);\n            pj_memcpy(&m->bandw[m->bandw_count]->modifier, &STR_BANDW_RR,\n                      sizeof(pj_str_t));\n            m->bandw_count++;\n        }\n    }\n\n    /* Add a=rtcp-mux attribute */\n    if (rtcp_mux) {\n        pjmedia_sdp_attr *add_attr;\n\n        add_attr = PJ_POOL_ZALLOC_T(sdp_pool, pjmedia_sdp_attr);\n        add_attr->name = STR_RTCP_MUX;\n        m->attr[m->attr_count++] = add_attr;\n    }\n\n    /* Add trickle ICE attributes */\n    if (trickle) {\n        pj_bool_t end_of_cand;\n\n        /* Add media ID attribute \"a=mid\" */\n        attr = pjmedia_sdp_attr_find2(m->attr_count, m->attr, \"mid\", NULL);\n        if (!attr) {\n            attr = pjmedia_sdp_attr_create(sdp_pool, \"mid\", &tp_ice->sdp_mid);\n            pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n        }\n\n        end_of_cand = tp_ice->end_of_cand;\n        status = pjmedia_ice_trickle_encode_sdp(sdp_pool, sdp_local,\n                                                &tp_ice->sdp_mid, NULL, NULL,\n                                                0, NULL, end_of_cand);\n        if (status != PJ_SUCCESS) {\n            PJ_PERROR(3,(tp_ice->base.name, status,\n                         \"Failed in adding trickle ICE attributes\"));\n            return status;\n        }\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/* Parse a=candidate line */\nstatic pj_status_t parse_cand(const char *obj_name,\n                              pj_pool_t *pool,\n                              const pj_str_t *orig_input,\n                              pj_ice_sess_cand *cand)\n{\n    pj_str_t token, delim, host;\n    int af;\n    pj_ssize_t found_idx;\n    pj_status_t status = PJNATH_EICEINCANDSDP;\n\n    pj_bzero(cand, sizeof(*cand));\n\n    PJ_UNUSED_ARG(obj_name);\n\n    /* Foundation */\n    delim = pj_str(\" \");\n    found_idx = pj_strtok(orig_input, &delim, &token, 0);\n    if (found_idx == orig_input->slen) {\n        TRACE__((obj_name, \"Expecting ICE foundation in candidate\"));\n        goto on_return;\n    }\n    if (pool) {\n        pj_strdup(pool, &cand->foundation, &token);\n    } else {\n        cand->foundation = token;\n    }\n\n    /* Component ID */\n    found_idx = pj_strtok(orig_input, &delim, &token, found_idx + token.slen);\n    if (found_idx == orig_input->slen) {\n        TRACE__((obj_name, \"Expecting ICE component ID in candidate\"));\n        goto on_return;\n    }\n    cand->comp_id = (pj_uint8_t)pj_strtoul(&token);\n\n    /* Transport */\n    found_idx = pj_strtok(orig_input, &delim, &token, found_idx + token.slen);\n    if (found_idx == orig_input->slen) {\n        TRACE__((obj_name, \"Expecting ICE transport in candidate\"));\n        goto on_return;\n    }\n    if (pj_stricmp2(&token, \"UDP\") != 0) {\n        TRACE__((obj_name, \n                 \"Expecting ICE UDP transport only in candidate\"));\n        goto on_return;\n    }\n\n    /* Priority */\n    found_idx = pj_strtok(orig_input, &delim, &token, found_idx + token.slen);\n    if (found_idx == orig_input->slen) {\n        TRACE__((obj_name, \"Expecting ICE priority in candidate\"));\n        goto on_return;\n    }\n    cand->prio = pj_strtoul(&token);\n\n    /* Host */\n    found_idx = pj_strtok(orig_input, &delim, &host, found_idx + token.slen);\n    if (found_idx == orig_input->slen) {\n        TRACE__((obj_name, \"Expecting ICE host in candidate\"));\n        goto on_return;\n    }\n    /* Detect address family */\n    if (pj_strchr(&host, ':'))\n        af = pj_AF_INET6();\n    else\n        af = pj_AF_INET();\n    /* Assign address */\n    if (pj_sockaddr_init(af, &cand->addr, &host, 0)) {\n        TRACE__((obj_name, \"Invalid ICE candidate address\"));\n        goto on_return;\n    }\n\n    /* Port */\n    found_idx = pj_strtok(orig_input, &delim, &token, found_idx + host.slen);\n    if (found_idx == orig_input->slen) {\n        TRACE__((obj_name, \"Expecting ICE port number in candidate\"));\n        goto on_return;\n    }\n    pj_sockaddr_set_port(&cand->addr, (pj_uint16_t)pj_strtoul(&token));\n\n    /* typ */\n    found_idx = pj_strtok(orig_input, &delim, &token, found_idx + token.slen);\n    if (found_idx == orig_input->slen) {\n        TRACE__((obj_name, \"Expecting ICE \\\"typ\\\" in candidate\"));\n        goto on_return;\n    }\n    if (pj_stricmp2(&token, \"typ\") != 0) {\n        TRACE__((obj_name, \"Expecting ICE \\\"typ\\\" in candidate\"));\n        goto on_return;\n    }\n\n    /* candidate type */\n    found_idx = pj_strtok(orig_input, &delim, &token, found_idx + token.slen);\n    if (found_idx == orig_input->slen) {\n        TRACE__((obj_name, \"Expecting ICE candidate type in candidate\"));\n        goto on_return;\n    }\n\n    if (pj_stricmp2(&token, \"host\") == 0) {\n        cand->type = PJ_ICE_CAND_TYPE_HOST;\n\n    } else if (pj_stricmp2(&token, \"srflx\") == 0) {\n        cand->type = PJ_ICE_CAND_TYPE_SRFLX;\n\n    } else if (pj_stricmp2(&token, \"relay\") == 0) {\n        cand->type = PJ_ICE_CAND_TYPE_RELAYED;\n\n    } else if (pj_stricmp2(&token, \"prflx\") == 0) {\n        cand->type = PJ_ICE_CAND_TYPE_PRFLX;\n\n    } else {\n        PJ_LOG(5,(obj_name, \"Invalid ICE candidate type %.*s in candidate\", \n                  (int)token.slen, token.ptr));\n        goto on_return;\n    }\n\n    status = PJ_SUCCESS;\n\non_return:\n    return status;\n}\n\n\n/* Create initial SDP offer */\nstatic pj_status_t create_initial_offer(struct transport_ice *tp_ice,\n                                        pj_pool_t *sdp_pool,\n                                        pjmedia_sdp_session *loc_sdp,\n                                        unsigned media_index)\n{\n    pj_status_t status;\n\n    /* Encode ICE in SDP */\n    status = encode_session_in_sdp(tp_ice, sdp_pool, loc_sdp, media_index, \n                                   tp_ice->comp_cnt, PJ_FALSE,\n                                   tp_ice->enable_rtcp_mux,\n                                   tp_ice->trickle_ice !=\n                                        PJ_ICE_SESS_TRICKLE_DISABLED);\n    if (status != PJ_SUCCESS) {\n        set_no_ice(tp_ice, \"Error encoding SDP answer\", status);\n        return status;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/* Verify incoming offer */\nstatic pj_status_t verify_ice_sdp(struct transport_ice *tp_ice,\n                                  pj_pool_t *tmp_pool,\n                                  const pjmedia_sdp_session *rem_sdp,\n                                  unsigned media_index,\n                                  pj_ice_sess_role current_ice_role,\n                                  struct sdp_state *sdp_state)\n{\n    const pjmedia_sdp_media *rem_m;\n    const pjmedia_sdp_attr *ufrag_attr, *pwd_attr;\n    const pjmedia_sdp_conn *rem_conn;\n    pj_bool_t comp1_found=PJ_FALSE, comp2_found=PJ_FALSE, has_rtcp=PJ_FALSE;\n    pj_sockaddr rem_conn_addr, rtcp_addr;\n    unsigned i;\n    int rem_af = 0;\n    pj_status_t status;\n\n    rem_m = rem_sdp->media[media_index];\n\n    /* Check if remote wants RTCP mux */\n    if (tp_ice->enable_rtcp_mux) {\n        pjmedia_sdp_attr *attr;\n\n        attr = pjmedia_sdp_attr_find(rem_m->attr_count, rem_m->attr, \n                                     &STR_RTCP_MUX, NULL);\n        tp_ice->use_rtcp_mux = (attr? PJ_TRUE: PJ_FALSE);\n    }\n\n    /* Get the \"ice-ufrag\" and \"ice-pwd\" attributes */\n    get_ice_attr(rem_sdp, rem_m, &ufrag_attr, &pwd_attr);\n\n    /* If \"ice-ufrag\" or \"ice-pwd\" are not found, disable ICE */\n    if (ufrag_attr==NULL || pwd_attr==NULL) {\n        sdp_state->match_comp_cnt = 0;\n        return PJ_SUCCESS;\n    }\n\n    /* Verify that default target for each component matches one of the \n     * candidate for the component. Otherwise stop ICE with ICE ice_mismatch \n     * error.\n     */\n\n    /* Component 1 is the c= line */\n    rem_conn = rem_m->conn;\n    if (rem_conn == NULL)\n        rem_conn = rem_sdp->conn;\n    if (!rem_conn)\n        return PJMEDIA_SDP_EMISSINGCONN;\n\n    /* Verify address family matches */\n    /*\n    if ((tp_ice->af==pj_AF_INET() && \n         pj_strcmp(&rem_conn->addr_type, &STR_IP4)!=0) ||\n        (tp_ice->af==pj_AF_INET6() && \n         pj_strcmp(&rem_conn->addr_type, &STR_IP6)!=0))\n    {\n        return PJMEDIA_SDP_ETPORTNOTEQUAL;\n    }\n    */\n\n    /* Get remote address family */\n    if (pj_strcmp(&rem_conn->addr_type, &STR_IP4)==0)\n        rem_af = pj_AF_INET();\n    else if (pj_strcmp(&rem_conn->addr_type, &STR_IP6)==0)\n        rem_af = pj_AF_INET6();\n    else\n        pj_assert(!\"Unsupported address family\");\n\n    /* Assign remote connection address */\n    status = pj_sockaddr_init(rem_af, &rem_conn_addr, &rem_conn->addr,\n                              (pj_uint16_t)rem_m->desc.port);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    if (tp_ice->comp_cnt > 1) {\n        const pjmedia_sdp_attr *attr;\n\n        /* Get default RTCP candidate from a=rtcp line, if present, otherwise\n         * calculate default RTCP candidate from default RTP target.\n         */\n        attr = pjmedia_sdp_attr_find(rem_m->attr_count, rem_m->attr, \n                                     &STR_RTCP, NULL);\n        has_rtcp = (attr != NULL);\n\n        if (attr) {\n            pjmedia_sdp_rtcp_attr rtcp_attr;\n\n            status = pjmedia_sdp_attr_get_rtcp(attr, &rtcp_attr);\n            if (status != PJ_SUCCESS) {\n                /* Error parsing a=rtcp attribute */\n                return status;\n            }\n        \n            if (rtcp_attr.addr.slen) {\n                /* Verify address family matches */\n                /*\n                if ((tp_ice->af==pj_AF_INET() && \n                     pj_strcmp(&rtcp_attr.addr_type, &STR_IP4)!=0) ||\n                    (tp_ice->af==pj_AF_INET6() && \n                     pj_strcmp(&rtcp_attr.addr_type, &STR_IP6)!=0))\n                {\n                    return PJMEDIA_SDP_ETPORTNOTEQUAL;\n                }\n                */\n\n                /* Assign RTCP address */\n                status = pj_sockaddr_init(rem_af, &rtcp_addr,\n                                          &rtcp_attr.addr,\n                                          (pj_uint16_t)rtcp_attr.port);\n                if (status != PJ_SUCCESS) {\n                    return PJMEDIA_SDP_EINRTCP;\n                }\n            } else {\n                /* Assign RTCP address */\n                status = pj_sockaddr_init(rem_af, &rtcp_addr, \n                                          NULL, \n                                          (pj_uint16_t)rtcp_attr.port);\n                if (status != PJ_SUCCESS) {\n                    return PJMEDIA_SDP_EINRTCP;\n                }\n                pj_sockaddr_copy_addr(&rtcp_addr, &rem_conn_addr);\n            }\n        } else {\n            unsigned rtcp_port;\n        \n            rtcp_port = pj_sockaddr_get_port(&rem_conn_addr) + 1;\n            pj_sockaddr_cp(&rtcp_addr, &rem_conn_addr);\n            pj_sockaddr_set_port(&rtcp_addr, (pj_uint16_t)rtcp_port);\n        }\n    }\n\n    /* Find the default addresses in a=candidate attributes. \n     */\n    for (i=0; i<rem_m->attr_count; ++i) {\n        pj_ice_sess_cand cand;\n        unsigned disable_ice_mismatch = tp_ice->options &\n                                        PJMEDIA_ICE_DISABLE_ICE_MISMATCH;\n\n        if (pj_strcmp(&rem_m->attr[i]->name, &STR_CANDIDATE)!=0)\n            continue;\n\n        status = parse_cand(tp_ice->base.name, tmp_pool, \n                            &rem_m->attr[i]->value, &cand);\n        if (status != PJ_SUCCESS) {\n            PJ_PERROR(4,(tp_ice->base.name, status,\n                         \"Error in parsing SDP candidate attribute '%.*s', \"\n                         \"candidate is ignored\",\n                         (int)rem_m->attr[i]->value.slen, \n                         rem_m->attr[i]->value.ptr));\n            continue;\n        }\n\n        if (!comp1_found && cand.comp_id==COMP_RTP)\n        {\n            if ((disable_ice_mismatch) ||\n                (pj_sockaddr_cmp(&rem_conn_addr, &cand.addr) == 0))\n            {\n                comp1_found = PJ_TRUE;\n            }\n        } else if (!comp2_found && cand.comp_id==COMP_RTCP)\n        {\n            if ((disable_ice_mismatch) ||\n                (pj_sockaddr_cmp(&rtcp_addr, &cand.addr) == 0))\n            {\n                comp2_found = PJ_TRUE;\n            }\n        }\n\n        if (cand.comp_id == COMP_RTCP)\n            has_rtcp = PJ_TRUE;\n\n        if (comp1_found && (comp2_found || tp_ice->comp_cnt==1))\n            break;\n    }\n\n    /* Check matched component count and ice_mismatch */\n    if (comp1_found &&\n        (tp_ice->comp_cnt==1 || !has_rtcp || tp_ice->use_rtcp_mux))\n    {\n        sdp_state->match_comp_cnt = 1;\n        sdp_state->ice_mismatch = PJ_FALSE;\n    } else if (comp1_found && comp2_found) {\n        sdp_state->match_comp_cnt = 2;\n        sdp_state->ice_mismatch = PJ_FALSE;\n    } else {\n        sdp_state->match_comp_cnt = (tp_ice->comp_cnt > 1 && has_rtcp)? 2 : 1;\n        sdp_state->ice_mismatch = PJ_TRUE;\n    }\n\n\n    /* Detect remote restarting session */\n    if (pj_ice_strans_has_sess(tp_ice->ice_st) &&\n        (pj_ice_strans_sess_is_running(tp_ice->ice_st) ||\n         pj_ice_strans_sess_is_complete(tp_ice->ice_st))) \n    {\n        pj_str_t rem_run_ufrag, rem_run_pwd;\n        pj_ice_strans_get_ufrag_pwd(tp_ice->ice_st, NULL, NULL,\n                                    &rem_run_ufrag, &rem_run_pwd);\n        if (pj_strcmp(&ufrag_attr->value, &rem_run_ufrag) ||\n            pj_strcmp(&pwd_attr->value, &rem_run_pwd))\n        {\n            /* Remote offers to restart ICE */\n            sdp_state->ice_restart = PJ_TRUE;\n        } else {\n            sdp_state->ice_restart = PJ_FALSE;\n        }\n    } else {\n        sdp_state->ice_restart = PJ_FALSE;\n    }\n\n    /* Detect our role */\n    if (pjmedia_sdp_attr_find(rem_sdp->attr_count, rem_sdp->attr,\n                              &STR_ICE_LITE, NULL) != NULL)\n    {\n        /* Remote is ICE lite, set our role as controlling */\n        sdp_state->local_role = PJ_ICE_SESS_ROLE_CONTROLLING;\n    } else {\n        if (current_ice_role==PJ_ICE_SESS_ROLE_CONTROLLING) {\n            sdp_state->local_role = PJ_ICE_SESS_ROLE_CONTROLLING;\n        } else {\n            sdp_state->local_role = PJ_ICE_SESS_ROLE_CONTROLLED;\n        }\n    }\n\n    /* Check trickle ICE indication */\n    if (tp_ice->trickle_ice != PJ_ICE_SESS_TRICKLE_DISABLED) {\n        sdp_state->has_trickle = pjmedia_ice_sdp_has_trickle(rem_sdp,\n                                                             media_index);\n\n        /* Reset ICE mismatch flag if conn addr is default address */\n        if (sdp_state->ice_mismatch && sdp_state->has_trickle) {\n            pj_sockaddr def_addr;\n            pj_sockaddr_init(rem_af, &def_addr, NULL, 9);\n            if (pj_sockaddr_cmp(&rem_conn_addr, &def_addr)==0)\n                sdp_state->ice_mismatch = PJ_FALSE;\n        }\n    } else {\n        sdp_state->has_trickle = PJ_FALSE;\n    }\n\n    PJ_LOG(4,(tp_ice->base.name, \n              \"Processing SDP: support ICE=%u, common comp_cnt=%u, \"\n              \"ice_mismatch=%u, ice_restart=%u, local_role=%s, trickle=%u\",\n              (sdp_state->match_comp_cnt != 0), \n              sdp_state->match_comp_cnt, \n              sdp_state->ice_mismatch, \n              sdp_state->ice_restart,\n              pj_ice_sess_role_name(sdp_state->local_role),\n              sdp_state->has_trickle));\n\n    return PJ_SUCCESS;\n\n}\n\n/* Encode information in SDP if ICE is not used */\nstatic pj_status_t encode_no_ice_in_sdp( struct transport_ice *tp_ice,\n                                         pj_pool_t *pool,\n                                         pjmedia_sdp_session *sdp_local,\n                                         const pjmedia_sdp_session *rem_sdp,\n                                         unsigned media_index)\n{\n    if (tp_ice->enable_rtcp_mux) {\n        pjmedia_sdp_media *m = sdp_local->media[media_index];\n        pjmedia_sdp_attr *attr;\n        pj_bool_t add_rtcp_mux = PJ_TRUE;\n\n        if (rem_sdp)\n            add_rtcp_mux = tp_ice->use_rtcp_mux;\n        else {\n            /* For subsequent offer, set it to false first since\n             * we are still waiting for remote answer.\n             */\n            tp_ice->use_rtcp_mux = PJ_FALSE;\n        }\n\n        /* Remove RTCP attribute because for subsequent offers/answers,\n         * the address (obtained from transport_get_info() ) may be\n         * incorrect if we are not yet confirmed to use RTCP mux\n         * (because we are still waiting for remote answer) or\n         * if remote rejects it.\n         */\n        pjmedia_sdp_attr_remove_all(&m->attr_count, m->attr, \"rtcp\");\n        \n        if (!tp_ice->use_rtcp_mux && tp_ice->comp_cnt > 1) {\n            pj_ice_sess_cand cand;\n            pj_status_t status;\n            \n            status = pj_ice_strans_get_def_cand(tp_ice->ice_st, 2, &cand);\n            if (status == PJ_SUCCESS) {\n                /* Add RTCP attribute if the remote doesn't offer or\n                 * rejects it.\n                 */\n                attr = pjmedia_sdp_attr_create_rtcp(pool, &cand.addr);  \n                if (attr)\n                    pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n            }\n        }\n\n        /* Add a=rtcp-mux attribute. */\n        if (add_rtcp_mux) {\n            attr = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_attr);\n            attr->name = STR_RTCP_MUX;\n            m->attr[m->attr_count++] = attr;\n        }\n    }\n    return PJ_SUCCESS;\n}\n\n\n/* Verify incoming offer and create initial answer */\nstatic pj_status_t create_initial_answer(struct transport_ice *tp_ice,\n                                         pj_pool_t *sdp_pool,\n                                         pjmedia_sdp_session *loc_sdp,\n                                         const pjmedia_sdp_session *rem_sdp,\n                                         unsigned media_index)\n{\n    const pjmedia_sdp_media *rem_m = rem_sdp->media[media_index];\n    pj_bool_t with_trickle;\n    pj_status_t status;\n\n    /* Check if media is removed (just in case) */\n    if (rem_m->desc.port == 0) {\n        return PJ_SUCCESS;\n    }\n\n    /* Verify the offer */\n    status = verify_ice_sdp(tp_ice, sdp_pool, rem_sdp, media_index, \n                            PJ_ICE_SESS_ROLE_CONTROLLED, \n                            &tp_ice->rem_offer_state);\n    if (status != PJ_SUCCESS) {\n        set_no_ice(tp_ice, \"Invalid SDP offer\", status);\n        return status;\n    }\n\n    /* Does remote support ICE? */\n    if (tp_ice->rem_offer_state.match_comp_cnt==0) {\n        set_no_ice(tp_ice, \"No ICE found in SDP offer\", PJ_SUCCESS);\n        encode_no_ice_in_sdp(tp_ice, sdp_pool, loc_sdp, rem_sdp,\n                             media_index);\n        return PJ_SUCCESS;\n    }\n\n    /* ICE ice_mismatch? */\n    if (tp_ice->rem_offer_state.ice_mismatch) {\n        set_no_ice(tp_ice, \"ICE ice_mismatch in remote offer\", PJ_SUCCESS);\n        encode_ice_mismatch(sdp_pool, loc_sdp, media_index);\n        return PJ_SUCCESS;\n    }\n\n    /* Encode ICE in SDP */\n    with_trickle = tp_ice->rem_offer_state.has_trickle &&\n                   tp_ice->trickle_ice != PJ_ICE_SESS_TRICKLE_DISABLED;\n    status = encode_session_in_sdp(tp_ice, sdp_pool, loc_sdp, media_index, \n                                   tp_ice->rem_offer_state.match_comp_cnt,\n                                   PJ_FALSE, tp_ice->use_rtcp_mux,\n                                   with_trickle);\n    if (status != PJ_SUCCESS) {\n        set_no_ice(tp_ice, \"Error encoding SDP answer\", status);\n        return status;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/* Create subsequent SDP offer */\nstatic pj_status_t create_subsequent_offer(struct transport_ice *tp_ice,\n                                           pj_pool_t *sdp_pool,\n                                           pjmedia_sdp_session *loc_sdp,\n                                           unsigned media_index)\n{\n    unsigned comp_cnt;\n\n    if (pj_ice_strans_has_sess(tp_ice->ice_st) == PJ_FALSE) {\n        /* We don't have ICE */\n        encode_no_ice_in_sdp(tp_ice, sdp_pool, loc_sdp, NULL, media_index);\n        return PJ_SUCCESS;\n    }\n\n    comp_cnt = pj_ice_strans_get_running_comp_cnt(tp_ice->ice_st);\n    return encode_session_in_sdp(tp_ice, sdp_pool, loc_sdp, media_index,\n                                 comp_cnt, PJ_FALSE, tp_ice->enable_rtcp_mux,\n                                 PJ_FALSE);\n}\n\n\n/* Create subsequent SDP answer */\nstatic pj_status_t create_subsequent_answer(struct transport_ice *tp_ice,\n                                            pj_pool_t *sdp_pool,\n                                            pjmedia_sdp_session *loc_sdp,\n                                            const pjmedia_sdp_session *rem_sdp,\n                                            unsigned media_index)\n{\n    pj_status_t status;\n\n    /* We have a session */\n    status = verify_ice_sdp(tp_ice, sdp_pool, rem_sdp, media_index, \n                            PJ_ICE_SESS_ROLE_CONTROLLED, \n                            &tp_ice->rem_offer_state);\n    if (status != PJ_SUCCESS) {\n        /* Something wrong with the offer */\n        return status;\n    }\n\n    if (pj_ice_strans_has_sess(tp_ice->ice_st)) {\n        /*\n         * Received subsequent offer while we have ICE active.\n         */\n\n        if (tp_ice->rem_offer_state.match_comp_cnt == 0) {\n            /* Remote no longer offers ICE */\n            encode_no_ice_in_sdp(tp_ice, sdp_pool, loc_sdp, rem_sdp,\n                                 media_index);\n            return PJ_SUCCESS;\n        }\n\n        if (tp_ice->rem_offer_state.ice_mismatch) {\n            encode_ice_mismatch(sdp_pool, loc_sdp, media_index);\n            return PJ_SUCCESS;\n        }\n\n        status = encode_session_in_sdp(tp_ice, sdp_pool, loc_sdp, media_index,\n                                       tp_ice->rem_offer_state.match_comp_cnt,\n                                       tp_ice->rem_offer_state.ice_restart,\n                                       tp_ice->use_rtcp_mux, PJ_FALSE);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        /* Done */\n\n    } else {\n        pj_bool_t with_trickle;\n\n        /*\n         * Received subsequent offer while we DON'T have ICE active.\n         */\n\n        if (tp_ice->rem_offer_state.match_comp_cnt == 0) {\n            /* Remote does not support ICE */\n            encode_no_ice_in_sdp(tp_ice, sdp_pool, loc_sdp, rem_sdp,\n                                 media_index);\n            return PJ_SUCCESS;\n        }\n\n        if (tp_ice->rem_offer_state.ice_mismatch) {\n            encode_ice_mismatch(sdp_pool, loc_sdp, media_index);\n            return PJ_SUCCESS;\n        }\n\n        /* Looks like now remote is offering ICE, so we need to create\n         * ICE session now.\n         */\n        status = pj_ice_strans_init_ice(tp_ice->ice_st, \n                                        PJ_ICE_SESS_ROLE_CONTROLLED,\n                                        NULL, NULL);\n        if (status != PJ_SUCCESS) {\n            /* Fail to create new ICE session */\n            return status;\n        }\n\n        with_trickle = tp_ice->rem_offer_state.has_trickle &&\n                       tp_ice->trickle_ice != PJ_ICE_SESS_TRICKLE_DISABLED;\n        status = encode_session_in_sdp(tp_ice, sdp_pool, loc_sdp, media_index,\n                                       tp_ice->rem_offer_state.match_comp_cnt,\n                                       tp_ice->rem_offer_state.ice_restart,\n                                       tp_ice->use_rtcp_mux,\n                                       with_trickle);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        /* Done */\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * For both UAC and UAS, pass in the SDP before sending it to remote.\n * This will add ICE attributes to the SDP.\n */\nstatic pj_status_t transport_media_create(pjmedia_transport *tp,\n                                          pj_pool_t *sdp_pool,\n                                          unsigned options,\n                                          const pjmedia_sdp_session *rem_sdp,\n                                          unsigned media_index)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n    pj_ice_sess_role ice_role;\n    pj_status_t status;\n\n    PJ_UNUSED_ARG(media_index);\n    PJ_UNUSED_ARG(sdp_pool);\n\n    tp_ice->media_option = options;\n    tp_ice->enable_rtcp_mux = ((options & PJMEDIA_TPMED_RTCP_MUX) != 0);\n    tp_ice->oa_role = ROLE_NONE;\n    tp_ice->initial_sdp = PJ_TRUE;\n\n    /* Init SDP \"a=mid\" attribute. Get from remote SDP for answerer or\n     * generate one for offerer (or if remote doesn't specify).\n     */\n    tp_ice->sdp_mid.slen = 0;\n    if (rem_sdp) {\n        pjmedia_sdp_media *m = rem_sdp->media[media_index];\n        pjmedia_sdp_attr *a;\n        a = pjmedia_sdp_attr_find2(m->attr_count, m->attr, \"mid\", NULL);\n        if (a) {\n            pj_strdup(tp_ice->pool, &tp_ice->sdp_mid, &a->value);\n        }\n    }\n    if (tp_ice->sdp_mid.slen == 0) {\n        char tmp_buf[8];\n        pj_ansi_snprintf(tmp_buf, sizeof(tmp_buf), \"%d\", media_index+1);\n        tp_ice->sdp_mid = pj_strdup3(tp_ice->pool, tmp_buf);\n    }\n\n    /* If RTCP mux is being used, set component count to 1 */\n    if (rem_sdp && tp_ice->enable_rtcp_mux) {\n        pjmedia_sdp_media *rem_m = rem_sdp->media[media_index];\n        pjmedia_sdp_attr *attr;\n        attr = pjmedia_sdp_attr_find(rem_m->attr_count, rem_m->attr,\n                                     &STR_RTCP_MUX, NULL);\n        tp_ice->use_rtcp_mux = (attr? PJ_TRUE: PJ_FALSE);\n    }\n    if (tp_ice->use_rtcp_mux &&\n        pj_ice_strans_get_running_comp_cnt(tp_ice->ice_st)>1)\n    {\n        pj_ice_strans_update_comp_cnt(tp_ice->ice_st, 1);\n    }\n\n    /* Init ICE, the initial role is set now based on availability of\n     * rem_sdp, but it will be checked again later.\n     */\n    ice_role = (rem_sdp==NULL ? PJ_ICE_SESS_ROLE_CONTROLLING : \n                                PJ_ICE_SESS_ROLE_CONTROLLED);\n    status = pj_ice_strans_init_ice(tp_ice->ice_st, ice_role, NULL, NULL);\n\n    /* For trickle ICE, if remote SDP has been received, process any remote\n     * ICE info now (ICE user fragment and/or initial ICE candidate list).\n     */\n    if (rem_sdp && status == PJ_SUCCESS) {\n        if (tp_ice->trickle_ice != PJ_ICE_SESS_TRICKLE_DISABLED &&\n            pjmedia_ice_sdp_has_trickle(rem_sdp, media_index))\n        {\n            pj_str_t ufrag, pwd;\n            unsigned cand_cnt = PJ_ICE_ST_MAX_CAND;\n            pj_ice_sess_cand cand[PJ_ICE_ST_MAX_CAND];\n            pj_bool_t end_of_cand;\n\n            status = pjmedia_ice_trickle_decode_sdp(rem_sdp, media_index,\n                                                    NULL, &ufrag, &pwd,\n                                                    &cand_cnt, cand,\n                                                    &end_of_cand);\n            if (status == PJ_SUCCESS)\n                status = pj_ice_strans_update_check_list(\n                                            tp_ice->ice_st, &ufrag, &pwd,\n                                            cand_cnt, cand, end_of_cand);\n            if (status != PJ_SUCCESS) {\n                PJ_PERROR(1,(tp_ice->base.name, status,\n                             \"Failed create checklist for trickling ICE\"));\n                return status;\n            }\n        }\n    }\n\n    /* Done */\n    return status;\n}\n\n\nstatic pj_status_t transport_encode_sdp(pjmedia_transport *tp,\n                                        pj_pool_t *sdp_pool,\n                                        pjmedia_sdp_session *sdp_local,\n                                        const pjmedia_sdp_session *rem_sdp,\n                                        unsigned media_index)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n    pj_status_t status;\n\n    /* Validate media transport */\n    /* This transport only support RTP/AVP transport, unless if\n     * transport checking is disabled\n     */\n    if ((tp_ice->media_option & PJMEDIA_TPMED_NO_TRANSPORT_CHECKING) == 0) {\n        pjmedia_sdp_media *m_rem, *m_loc;\n        pj_uint32_t tp_proto_loc, tp_proto_rem;\n\n        m_rem = rem_sdp? rem_sdp->media[media_index] : NULL;\n        m_loc = sdp_local->media[media_index];\n\n        tp_proto_loc = pjmedia_sdp_transport_get_proto(&m_loc->desc.transport);\n        tp_proto_rem = m_rem? \n                pjmedia_sdp_transport_get_proto(&m_rem->desc.transport) : 0;\n        PJMEDIA_TP_PROTO_TRIM_FLAG(tp_proto_loc, PJMEDIA_TP_PROFILE_RTCP_FB);\n        PJMEDIA_TP_PROTO_TRIM_FLAG(tp_proto_rem, PJMEDIA_TP_PROFILE_RTCP_FB);\n\n        if ((tp_proto_loc != PJMEDIA_TP_PROTO_RTP_AVP) ||\n            (m_rem && tp_proto_rem != PJMEDIA_TP_PROTO_RTP_AVP))\n        {\n            pjmedia_sdp_media_deactivate(sdp_pool, m_loc);\n            return PJMEDIA_SDP_EINPROTO;\n        }\n    }\n\n    if (tp_ice->initial_sdp) {\n        if (rem_sdp) {\n            status = create_initial_answer(tp_ice, sdp_pool, sdp_local, \n                                           rem_sdp, media_index);\n        } else {\n            status = create_initial_offer(tp_ice, sdp_pool, sdp_local,\n                                          media_index);\n        }\n    } else {\n        if (rem_sdp) {\n            status = create_subsequent_answer(tp_ice, sdp_pool, sdp_local,\n                                              rem_sdp, media_index);\n        } else {\n            status = create_subsequent_offer(tp_ice, sdp_pool, sdp_local,\n                                             media_index);\n        }\n    }\n\n    if (status==PJ_SUCCESS) {\n        if (rem_sdp)\n            tp_ice->oa_role = ROLE_ANSWERER;\n        else\n            tp_ice->oa_role = ROLE_OFFERER;\n\n        if (tp_ice->use_ice) {\n            /* Update last local candidate count, so trickle ICE can identify\n             * if there is any new local candidate.\n             */\n            unsigned i, comp_cnt;\n            comp_cnt = pj_ice_strans_get_running_comp_cnt(tp_ice->ice_st);\n            for (i = 0; i < comp_cnt; ++i) {\n                tp_ice->last_send_cand_cnt[i] =\n                        pj_ice_strans_get_cands_count(tp_ice->ice_st, i+1);\n            }\n        }\n    }\n\n    return status;\n}\n\n\n/* Start ICE session with the specified remote SDP */\nstatic pj_status_t start_ice(struct transport_ice *tp_ice,\n                             pj_pool_t *tmp_pool,\n                             const pjmedia_sdp_session *rem_sdp,\n                             unsigned media_index)\n{\n    pjmedia_sdp_media *rem_m = rem_sdp->media[media_index];\n    const pjmedia_sdp_attr *ufrag_attr, *pwd_attr;\n    pj_ice_sess_cand *cand;\n    unsigned i, cand_cnt;\n    pj_status_t status;\n\n    get_ice_attr(rem_sdp, rem_m, &ufrag_attr, &pwd_attr);\n\n    /* Allocate candidate array */\n    cand = (pj_ice_sess_cand*)\n           pj_pool_calloc(tmp_pool, PJ_ICE_MAX_CAND, \n                          sizeof(pj_ice_sess_cand));\n\n    /* Get all candidates in the media */\n    cand_cnt = 0;\n    for (i=0; i<rem_m->attr_count && cand_cnt < PJ_ICE_MAX_CAND; ++i) {\n        pjmedia_sdp_attr *attr;\n\n        attr = rem_m->attr[i];\n\n        if (pj_strcmp(&attr->name, &STR_CANDIDATE)!=0)\n            continue;\n\n        /* Parse candidate */\n        status = parse_cand(tp_ice->base.name, tmp_pool, &attr->value, \n                            &cand[cand_cnt]);\n        if (status != PJ_SUCCESS) {\n            PJ_PERROR(4,(tp_ice->base.name, status,\n                         \"Error in parsing SDP candidate attribute '%.*s', \"\n                         \"candidate is ignored\",\n                         (int)attr->value.slen, attr->value.ptr));\n            continue;\n        }\n\n        if (!tp_ice->use_rtcp_mux || cand[cand_cnt].comp_id < 2)\n            cand_cnt++;\n    }\n\n    /* Start ICE */\n    return pj_ice_strans_start_ice(tp_ice->ice_st, &ufrag_attr->value, \n                                   &pwd_attr->value, cand_cnt, cand);\n}\n\n\n/*\n * Start ICE checks when both offer and answer have been negotiated\n * by SDP negotiator.\n */\nstatic pj_status_t transport_media_start(pjmedia_transport *tp,\n                                         pj_pool_t *tmp_pool,\n                                         const pjmedia_sdp_session *sdp_local,\n                                         const pjmedia_sdp_session *rem_sdp,\n                                         unsigned media_index)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n    pjmedia_sdp_media *rem_m;\n    enum oa_role current_oa_role;\n    pj_bool_t initial_oa;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(tp && tmp_pool && rem_sdp, PJ_EINVAL);\n    PJ_ASSERT_RETURN(media_index < rem_sdp->media_count, PJ_EINVAL);\n\n    rem_m = rem_sdp->media[media_index];\n\n    initial_oa = tp_ice->initial_sdp;\n    current_oa_role = tp_ice->oa_role;\n\n    /* SDP has been negotiated */\n    tp_ice->initial_sdp = PJ_FALSE;\n    tp_ice->oa_role = ROLE_NONE;\n\n    /* Nothing to do if we don't have ICE session */\n    if (pj_ice_strans_has_sess(tp_ice->ice_st) == PJ_FALSE) {\n        return PJ_SUCCESS;\n    }\n\n    /* Special case for Session Timer. The re-INVITE for session refresh\n     * doesn't call transport_encode_sdp(), causing current_oa_role to\n     * be set to ROLE_NONE. This is a workaround.\n     */\n    if (current_oa_role == ROLE_NONE) {\n        current_oa_role = ROLE_OFFERER;\n    }\n\n    /* Processing depends on the offer/answer role */\n    if (current_oa_role == ROLE_OFFERER) {\n        /*\n         * We are offerer. So this will be the first time we see the\n         * remote's SDP.\n         */\n        struct sdp_state answer_state;\n\n        /* Verify the answer */\n        status = verify_ice_sdp(tp_ice, tmp_pool, rem_sdp, media_index, \n                                PJ_ICE_SESS_ROLE_CONTROLLING, &answer_state);\n        if (status != PJ_SUCCESS) {\n            /* Something wrong in the SDP answer */\n            set_no_ice(tp_ice, \"Invalid remote SDP answer\", status);\n            return status;\n        }\n\n        /* Does it have ICE? */\n        if (answer_state.match_comp_cnt == 0) {\n            /* Remote doesn't support ICE */\n            set_no_ice(tp_ice, \"Remote answer doesn't support ICE\", \n                       PJ_SUCCESS);\n            return PJ_SUCCESS;\n        }\n\n        /* Check if remote has reported ice-mismatch */\n        if (pjmedia_sdp_attr_find(rem_m->attr_count, rem_m->attr, \n                                  &STR_ICE_MISMATCH, NULL) != NULL)\n        {\n            /* Remote has reported ice-mismatch */\n            set_no_ice(tp_ice, \n                       \"Remote answer contains 'ice-mismatch' attribute\", \n                       PJ_SUCCESS);\n            return PJ_SUCCESS;\n        }\n\n        /* Check if remote has indicated a restart */\n        if (answer_state.ice_restart) {\n            PJ_LOG(2,(tp_ice->base.name, \n                      \"Warning: remote has signalled ICE restart in SDP \"\n                      \"answer which is disallowed. Remote ICE negotiation\"\n                      \" may fail.\"));\n        }\n\n        /* Check if the answer itself is mismatched */\n        if (answer_state.ice_mismatch) {\n            /* This happens either when a B2BUA modified remote answer but\n             * strangely didn't modify our offer, or remote is not capable\n             * of detecting mismatch in our offer (it didn't put \n             * 'ice-mismatch' attribute in the answer).\n             */\n            PJ_LOG(2,(tp_ice->base.name, \n                      \"Warning: remote answer mismatch, but it does not \"\n                      \"reject our offer with 'ice-mismatch'. ICE negotiation \"\n                      \"may fail\"));\n        }\n\n        /* Do nothing if ICE is complete or running */\n        if (pj_ice_strans_sess_is_running(tp_ice->ice_st)) {\n            PJ_LOG(4,(tp_ice->base.name,\n                      \"Ignored offer/answer because ICE is running\"));\n            return PJ_SUCCESS;\n        }\n\n        if (pj_ice_strans_sess_is_complete(tp_ice->ice_st)) {\n            PJ_LOG(4,(tp_ice->base.name, \"ICE session unchanged\"));\n            return PJ_SUCCESS;\n        }\n\n        /* Start ICE */\n\n    } else {\n        /*\n         * We are answerer. We've seen and negotiated remote's SDP\n         * before, and the result is in \"rem_offer_state\".\n         */\n        const pjmedia_sdp_attr *ufrag_attr, *pwd_attr;\n\n        /* Check for ICE in remote offer */\n        if (tp_ice->rem_offer_state.match_comp_cnt == 0) {\n            /* No ICE attribute present */\n            set_no_ice(tp_ice, \"Remote no longer offers ICE\",\n                       PJ_SUCCESS);\n            return PJ_SUCCESS;\n        }\n\n        /* Check for ICE ice_mismatch condition in the offer */\n        if (tp_ice->rem_offer_state.ice_mismatch) {\n            set_no_ice(tp_ice, \"Remote offer mismatch: \", \n                       PJNATH_EICEMISMATCH);\n            return PJ_SUCCESS;\n        }\n\n        /* If ICE is complete and remote doesn't request restart,\n         * then leave the session as is.\n         */\n        if (!initial_oa && tp_ice->rem_offer_state.ice_restart == PJ_FALSE) {\n            /* Remote has not requested ICE restart, so session is\n             * unchanged.\n             */\n            PJ_LOG(4,(tp_ice->base.name, \"ICE session unchanged\"));\n            return PJ_SUCCESS;\n        }\n\n        /* Either remote has requested ICE restart or this is our\n         * first answer. \n         */\n\n        /* Stop ICE */\n        if (!initial_oa) {\n            set_no_ice(tp_ice, \"restarting by remote request..\", PJ_SUCCESS);\n\n            /* We have put new ICE ufrag and pwd in the answer. Now\n             * create a new ICE session with that ufrag/pwd pair.\n             */\n            get_ice_attr(sdp_local, sdp_local->media[media_index], \n                         &ufrag_attr, &pwd_attr);\n            status = pj_ice_strans_init_ice(tp_ice->ice_st, \n                                            tp_ice->rem_offer_state.local_role,\n                                            &ufrag_attr->value, \n                                            &pwd_attr->value);\n            if (status != PJ_SUCCESS) {\n                PJ_PERROR(1,(tp_ice->base.name, status,\n                             \"ICE re-initialization failed!\"));\n                return status;\n            }\n        }\n\n        /* Ticket #977: Update role if turns out we're supposed to be the \n         * Controlling agent (e.g. when talking to ice-lite peer). \n         */\n        if (tp_ice->rem_offer_state.local_role==PJ_ICE_SESS_ROLE_CONTROLLING &&\n            pj_ice_strans_has_sess(tp_ice->ice_st)) \n        {\n            pj_ice_strans_change_role(tp_ice->ice_st, \n                                      PJ_ICE_SESS_ROLE_CONTROLLING);\n        }\n\n        /* start ICE */\n    }\n\n    /* RFC 5245 section 8.1.1:\n     * If its peer has a lite implementation, an agent MUST use\n     * a regular nomination algorithm.\n     */\n    if (pjmedia_sdp_attr_find(rem_sdp->attr_count, rem_sdp->attr,\n                              &STR_ICE_LITE, NULL) != NULL)\n    {\n        pj_ice_sess_options opt;\n        pj_ice_strans_get_options(tp_ice->ice_st, &opt);\n        if (opt.aggressive) {\n            opt.aggressive = PJ_FALSE;\n            pj_ice_strans_set_options(tp_ice->ice_st, &opt);\n            PJ_LOG(4,(tp_ice->base.name, \"Forcefully set ICE to use regular \"\n                      \"nomination as remote is lite implementation\"));\n        }\n    }\n\n    /* Now start ICE, if not yet (trickle ICE may have started it earlier) */\n    if (!pj_ice_strans_sess_is_running(tp_ice->ice_st) &&\n        !pj_ice_strans_sess_is_complete(tp_ice->ice_st))\n    {\n        status = start_ice(tp_ice, tmp_pool, rem_sdp, media_index);\n        if (status != PJ_SUCCESS) {\n            PJ_PERROR(1,(tp_ice->base.name, status, \"ICE restart failed!\"));\n            return status;\n        }\n    }\n\n    /* Done */\n    tp_ice->use_ice = PJ_TRUE;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t transport_media_stop(pjmedia_transport *tp)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n    \n    set_no_ice(tp_ice, \"media stop requested\", PJ_SUCCESS);\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t transport_get_info(pjmedia_transport *tp,\n                                      pjmedia_transport_info *info)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n    pj_ice_sess_cand cands[PJ_ICE_ST_MAX_CAND];\n    pj_ice_sess_cand cand;\n    pj_sockaddr_t *addr;\n    pj_status_t status;\n\n    pj_bzero(&info->sock_info, sizeof(info->sock_info));\n    info->sock_info.rtp_sock = info->sock_info.rtcp_sock = PJ_INVALID_SOCKET;\n\n    /* Get RTP default address */\n    status = pj_ice_strans_get_def_cand(tp_ice->ice_st, 1, &cand);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Address of the default candidate may not be available (e.g:\n     * STUN/TURN address is still being resolved), so let's find address\n     * of any other candidate, if still not available, the draft RFC\n     * seems to allow us using \"0.0.0.0:9\" in SDP.\n     */\n    addr = NULL;\n    if (pj_sockaddr_has_addr(&cand.addr)) {\n        addr = &cand.addr;\n    } else if (pj_ice_strans_has_sess(tp_ice->ice_st)) {\n        unsigned i, cnt = PJ_ICE_ST_MAX_CAND;\n        pj_ice_strans_enum_cands(tp_ice->ice_st, 1, &cnt, cands);\n        for (i = 0; i < cnt && !addr; ++i) {\n            if (pj_sockaddr_has_addr(&cands[i].addr))\n                addr = &cands[i].addr;\n        }\n    }\n    if (addr) {\n        pj_sockaddr_cp(&info->sock_info.rtp_addr_name, addr);\n    } else {\n        pj_sockaddr_init(PJ_AF_INET, &info->sock_info.rtp_addr_name, NULL, 9);\n    }\n\n    /* Get RTCP default address */\n    if (tp_ice->use_rtcp_mux) {\n        pj_sockaddr_cp(&info->sock_info.rtcp_addr_name,\n                       &info->sock_info.rtp_addr_name);\n    } else if (tp_ice->comp_cnt > 1) {\n        status = pj_ice_strans_get_def_cand(tp_ice->ice_st, 2, &cand);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        /* Address of the default candidate may not be available (e.g:\n         * STUN/TURN address is still being resolved), so let's find address\n         * of any other candidate. If none is available, SDP must not include\n         * \"a=rtcp\" attribute.\n         */\n        addr = NULL;\n        if (pj_sockaddr_has_addr(&cand.addr)) {\n            addr = &cand.addr;\n        } else if (pj_ice_strans_has_sess(tp_ice->ice_st)) {\n            unsigned i, cnt = PJ_ICE_ST_MAX_CAND;\n            pj_ice_strans_enum_cands(tp_ice->ice_st, 2, &cnt, cands);\n            for (i = 0; i < cnt && !addr; ++i) {\n                if (pj_sockaddr_has_addr(&cands[i].addr))\n                    addr = &cands[i].addr;\n            }\n        }\n        if (addr) {\n            pj_sockaddr_cp(&info->sock_info.rtcp_addr_name, addr);\n        }\n    }\n\n    /* Set remote address originating RTP & RTCP if this transport has \n     * ICE activated or received any packets.\n     */\n    if (tp_ice->use_ice || tp_ice->rtp_src_cnt) {\n        info->src_rtp_name = tp_ice->rtp_src_addr;\n        if (tp_ice->use_rtcp_mux)\n            info->src_rtcp_name = tp_ice->rtp_src_addr;\n    }\n    if ((!tp_ice->use_rtcp_mux) &&\n        (tp_ice->use_ice || tp_ice->rtcp_src_cnt))\n    {\n        info->src_rtcp_name = tp_ice->rtcp_src_addr;\n    }\n\n    /* Fill up transport specific info */\n    if (info->specific_info_cnt < PJ_ARRAY_SIZE(info->spc_info)) {\n        pjmedia_transport_specific_info *tsi;\n        pjmedia_ice_transport_info *ii;\n        unsigned i;\n\n        pj_assert(sizeof(*ii) <= sizeof(tsi->buffer));\n        tsi = &info->spc_info[info->specific_info_cnt++];\n        tsi->type = PJMEDIA_TRANSPORT_TYPE_ICE;\n        tsi->tp = tp;\n        tsi->cbsize = sizeof(*ii);\n\n        ii = (pjmedia_ice_transport_info*) tsi->buffer;\n        pj_bzero(ii, sizeof(*ii));\n\n        ii->active = tp_ice->use_ice;\n\n        if (pj_ice_strans_has_sess(tp_ice->ice_st)) {\n            ii->role = pj_ice_strans_get_role(tp_ice->ice_st);\n            pj_ice_strans_get_ufrag_pwd(tp_ice->ice_st, &ii->loc_ufrag, NULL,\n                                        &ii->rem_ufrag, NULL);\n        } else {\n            ii->role = PJ_ICE_SESS_ROLE_UNKNOWN;\n        }\n        ii->sess_state = pj_ice_strans_get_state(tp_ice->ice_st);\n        ii->comp_cnt = pj_ice_strans_get_running_comp_cnt(tp_ice->ice_st);\n        \n        for (i=1; i<=ii->comp_cnt && i<=PJ_ARRAY_SIZE(ii->comp); ++i) {\n            const pj_ice_sess_check *chk;\n\n            chk = pj_ice_strans_get_valid_pair(tp_ice->ice_st, i);\n            if (chk) {\n                ii->comp[i-1].lcand_type = chk->lcand->type;\n                pj_sockaddr_cp(&ii->comp[i-1].lcand_addr,\n                               &chk->lcand->addr);\n                ii->comp[i-1].rcand_type = chk->rcand->type;\n                pj_sockaddr_cp(&ii->comp[i-1].rcand_addr,\n                               &chk->rcand->addr);\n            }\n        }\n    }\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t transport_attach  (pjmedia_transport *tp,\n                                      void *stream,\n                                      const pj_sockaddr_t *rem_addr,\n                                      const pj_sockaddr_t *rem_rtcp,\n                                      unsigned addr_len,\n                                      void (*rtp_cb)(void*,\n                                                     void*,\n                                                     pj_ssize_t),\n                                      void (*rtcp_cb)(void*,\n                                                      void*,\n                                                      pj_ssize_t))\n{\n    pjmedia_transport_attach_param param;\n    \n    pj_bzero(&param, sizeof(param));\n    param.user_data = stream;\n    pj_sockaddr_cp(&param.rem_addr, rem_addr);\n    pj_sockaddr_cp(&param.rem_rtcp, rem_rtcp);\n    param.addr_len = addr_len;\n    param.rtp_cb = rtp_cb;\n    param.rtcp_cb = rtcp_cb;\n    return transport_attach2(tp, &param);\n}\n\n\nstatic pj_status_t transport_attach2  (pjmedia_transport *tp,\n                                       pjmedia_transport_attach_param\n                                           *att_param)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n\n    tp_ice->stream = att_param->user_data;\n    tp_ice->rtp_cb = att_param->rtp_cb;\n    tp_ice->rtp_cb2 = att_param->rtp_cb2;\n    tp_ice->rtcp_cb = att_param->rtcp_cb;\n\n    /* Check again if we are multiplexing RTP & RTCP. */\n    tp_ice->use_rtcp_mux = (pj_sockaddr_has_addr(&att_param->rem_addr) &&\n                            pj_sockaddr_cmp(&att_param->rem_addr,\n                                            &att_param->rem_rtcp) == 0);\n\n    pj_memcpy(&tp_ice->remote_rtp, &att_param->rem_addr, att_param->addr_len);\n    pj_memcpy(&tp_ice->remote_rtcp, &att_param->rem_rtcp, att_param->addr_len);\n    tp_ice->addr_len = att_param->addr_len;\n\n    /* Init source RTP & RTCP addresses and counter */\n    tp_ice->rtp_src_addr = tp_ice->remote_rtp;\n    pj_bzero(&tp_ice->rtcp_src_addr, sizeof(tp_ice->rtcp_src_addr));\n    tp_ice->rtp_src_cnt = tp_ice->rtcp_src_cnt = 0;\n\n    return PJ_SUCCESS;\n}\n\n\nstatic void transport_detach(pjmedia_transport *tp,\n                             void *strm)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n\n    /* TODO: need to solve ticket #460 here */\n\n    tp_ice->rtp_cb = NULL;\n    tp_ice->rtp_cb2 = NULL;\n    tp_ice->rtcp_cb = NULL;\n    tp_ice->stream = NULL;\n\n    PJ_UNUSED_ARG(strm);\n}\n\n\nstatic pj_status_t transport_send_rtp(pjmedia_transport *tp,\n                                      const void *pkt,\n                                      pj_size_t size)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n    pj_status_t status;\n\n    /* Simulate packet lost on TX direction */\n    if (tp_ice->tx_drop_pct) {\n        if ((pj_rand() % 100) <= (int)tp_ice->tx_drop_pct) {\n            PJ_LOG(5,(tp_ice->base.name, \n                      \"TX RTP packet dropped because of pkt lost \"\n                      \"simulation\"));\n            return PJ_SUCCESS;\n        }\n    }\n\n    status = pj_ice_strans_sendto2(tp_ice->ice_st, 1, \n                                   pkt, size, &tp_ice->remote_rtp,\n                                   tp_ice->addr_len);\n    if (status == PJ_EPENDING)\n        status = PJ_SUCCESS;\n\n    return status;\n}\n\n\nstatic pj_status_t transport_send_rtcp(pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size)\n{\n    return transport_send_rtcp2(tp, NULL, 0, pkt, size);\n}\n\nstatic pj_status_t transport_send_rtcp2(pjmedia_transport *tp,\n                                        const pj_sockaddr_t *addr,\n                                        unsigned addr_len,\n                                        const void *pkt,\n                                        pj_size_t size)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n\n    if (tp_ice->comp_cnt > 1 || tp_ice->use_rtcp_mux) {\n        pj_status_t status;\n        unsigned comp_id = (tp_ice->use_rtcp_mux? 1: 2);\n\n        if (addr == NULL) {\n            addr = &tp_ice->remote_rtcp;\n            addr_len = pj_sockaddr_get_len(addr);\n        }         \n\n        status = pj_ice_strans_sendto2(tp_ice->ice_st, comp_id, pkt, size,\n                                       addr, addr_len);\n        if (status == PJ_EPENDING)\n            status = PJ_SUCCESS;\n\n        return status;\n    } else {\n        return PJ_SUCCESS;\n    }\n}\n\n\nstatic void ice_on_rx_data(pj_ice_strans *ice_st, unsigned comp_id, \n                           void *pkt, pj_size_t size,\n                           const pj_sockaddr_t *src_addr,\n                           unsigned src_addr_len)\n{\n    struct transport_ice *tp_ice;\n    pj_bool_t discard = PJ_FALSE;\n\n    tp_ice = (struct transport_ice*) pj_ice_strans_get_user_data(ice_st);\n    if (!tp_ice) {\n        /* Destroy on progress */\n        return;\n    }\n\n    if (comp_id == 1) {\n        ++tp_ice->rtp_src_cnt;\n        pj_sockaddr_cp(&tp_ice->rtp_src_addr, src_addr);\n    } else if (comp_id == 2) {\n        pj_sockaddr_cp(&tp_ice->rtcp_src_addr, src_addr);\n    }\n\n    if (comp_id==1 && (tp_ice->rtp_cb || tp_ice->rtp_cb2)) {\n        pj_bool_t rem_switch = PJ_FALSE;\n\n        /* Simulate packet lost on RX direction */\n        if (tp_ice->rx_drop_pct) {\n            if ((pj_rand() % 100) <= (int)tp_ice->rx_drop_pct) {\n                PJ_LOG(5,(tp_ice->base.name, \n                          \"RX RTP packet dropped because of pkt lost \"\n                          \"simulation\"));\n                return;\n            }\n        }\n\n        if (!discard) {\n            if (tp_ice->rtp_cb2) {\n                pjmedia_tp_cb_param param;\n\n                param.user_data = tp_ice->stream;\n                param.pkt = pkt;\n                param.size = size;\n                param.src_addr = (tp_ice->use_ice? NULL:\n                                  (pj_sockaddr_t *)src_addr);\n                param.rem_switch = PJ_FALSE;\n                (*tp_ice->rtp_cb2)(&param);\n                rem_switch = param.rem_switch;\n            } else {\n                (*tp_ice->rtp_cb)(tp_ice->stream, pkt, size);\n            }\n        }\n        \n#if defined(PJMEDIA_TRANSPORT_SWITCH_REMOTE_ADDR) && \\\n    (PJMEDIA_TRANSPORT_SWITCH_REMOTE_ADDR == 1)\n        if (rem_switch &&\n            (tp_ice->options & PJMEDIA_ICE_NO_SRC_ADDR_CHECKING)==0)\n        {\n            char addr_text[PJ_INET6_ADDRSTRLEN+10];\n\n            /* Set remote RTP address to source address */\n            pj_sockaddr_cp(&tp_ice->rtp_src_addr, src_addr);\n            pj_sockaddr_cp(&tp_ice->remote_rtp, src_addr);\n            tp_ice->addr_len = pj_sockaddr_get_len(&tp_ice->remote_rtp);\n\n            PJ_LOG(4,(tp_ice->base.name,\n                      \"Remote RTP address switched to %s\",\n                      pj_sockaddr_print(&tp_ice->remote_rtp, addr_text,\n                                        sizeof(addr_text), 3)));\n\n            if (tp_ice->use_rtcp_mux) {\n                pj_sockaddr_cp(&tp_ice->remote_rtcp, &tp_ice->remote_rtp);\n            } else if (!pj_sockaddr_has_addr(&tp_ice->rtcp_src_addr)) {\n                /* Also update remote RTCP address if actual RTCP source\n                 * address is not heard yet.\n                 */\n                pj_uint16_t port;\n\n                pj_sockaddr_cp(&tp_ice->remote_rtcp, &tp_ice->remote_rtp);\n\n                port = (pj_uint16_t)\n                       (pj_sockaddr_get_port(&tp_ice->remote_rtp)+1);\n                pj_sockaddr_set_port(&tp_ice->remote_rtcp, port);\n\n                PJ_LOG(4,(tp_ice->base.name,\n                          \"Remote RTCP address switched to predicted \"\n                          \"address %s\",\n                          pj_sockaddr_print(&tp_ice->remote_rtcp, \n                                            addr_text,\n                                            sizeof(addr_text), 3)));\n            }\n        }\n#else\n        PJ_UNUSED_ARG(rem_switch);\n#endif\n\n    } else if (comp_id==2 && tp_ice->rtcp_cb) {\n\n#if defined(PJMEDIA_TRANSPORT_SWITCH_REMOTE_ADDR) && \\\n    (PJMEDIA_TRANSPORT_SWITCH_REMOTE_ADDR == 1)\n        /* Check if RTCP source address is the same as the configured\n         * remote address, and switch the address when they are\n         * different.\n         */\n        if (!tp_ice->use_ice &&\n            (tp_ice->options & PJMEDIA_ICE_NO_SRC_ADDR_CHECKING)==0)\n        {\n            if (pj_sockaddr_cmp(&tp_ice->remote_rtcp, src_addr) == 0) {\n                tp_ice->rtcp_src_cnt = 0;\n            } else {\n                char addr_text[PJ_INET6_ADDRSTRLEN+10];\n\n                ++tp_ice->rtcp_src_cnt;\n                if (tp_ice->rtcp_src_cnt < PJMEDIA_RTCP_NAT_PROBATION_CNT) {\n                    discard = PJ_TRUE;\n                } else {\n                    tp_ice->rtcp_src_cnt = 0;\n                    pj_sockaddr_cp(&tp_ice->rtcp_src_addr, src_addr);\n                    pj_sockaddr_cp(&tp_ice->remote_rtcp, src_addr);\n\n                    pj_assert(tp_ice->addr_len==pj_sockaddr_get_len(src_addr));\n\n                    PJ_LOG(4,(tp_ice->base.name,\n                              \"Remote RTCP address switched to %s\",\n                              pj_sockaddr_print(&tp_ice->remote_rtcp,\n                                                addr_text, sizeof(addr_text),\n                                                3)));\n                }\n            }\n        }\n#endif\n\n        if (!discard)\n            (*tp_ice->rtcp_cb)(tp_ice->stream, pkt, size);\n    }\n\n    PJ_UNUSED_ARG(src_addr_len);\n}\n\n\nstatic void ice_on_ice_complete(pj_ice_strans *ice_st, \n                                pj_ice_strans_op op,\n                                pj_status_t result)\n{\n    struct transport_ice *tp_ice;\n    ice_listener *il;\n\n    tp_ice = (struct transport_ice*) pj_ice_strans_get_user_data(ice_st);\n    if (!tp_ice) {\n        /* Destroy on progress */\n        return;\n    }\n\n    /* Set the flag indicating that local candidate gathering is completed */\n    if (op == PJ_ICE_STRANS_OP_INIT && result == PJ_SUCCESS)\n        tp_ice->end_of_cand = PJ_TRUE;\n\n    pj_perror(5, tp_ice->base.name, result, \"ICE operation complete\"\n              \" (op=%d%s)\", op,\n              (op==PJ_ICE_STRANS_OP_INIT? \"/initialization\" :\n              (op==PJ_ICE_STRANS_OP_NEGOTIATION? \"/negotiation\":\"\")));\n\n    /* Notify application */\n    if (tp_ice->cb.on_ice_complete)\n        (*tp_ice->cb.on_ice_complete)(&tp_ice->base, op, result);\n\n    for (il=tp_ice->listener.next; il!=&tp_ice->listener; il=il->next) {\n        if (il->cb.on_ice_complete2) {\n            (*il->cb.on_ice_complete2)(&tp_ice->base, op, result,\n                                       il->user_data);\n        } else if (il->cb.on_ice_complete) {\n            (*il->cb.on_ice_complete)(&tp_ice->base, op, result);\n        }\n    }\n}\n\n\nstatic void ice_on_new_candidate(pj_ice_strans *ice_st,\n                                 const pj_ice_sess_cand *cand,\n                                 pj_bool_t last)\n{\n    struct transport_ice *tp_ice;\n    ice_listener *il;\n\n    tp_ice = (struct transport_ice*) pj_ice_strans_get_user_data(ice_st);\n    if (!tp_ice) {\n        /* Destroy on progress */\n        return;\n    }\n\n    /* Notify application */\n    if (tp_ice->cb.on_new_candidate)\n        (*tp_ice->cb.on_new_candidate)(&tp_ice->base, cand, last);\n\n    for (il=tp_ice->listener.next; il!=&tp_ice->listener; il=il->next) {\n        if (il->cb.on_new_candidate) {\n            (*il->cb.on_new_candidate)(&tp_ice->base, cand, last);\n        }\n    }\n}\n\n\n/* Simulate lost */\nstatic pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n                                           pjmedia_dir dir,\n                                           unsigned pct_lost)\n{\n    struct transport_ice *ice = (struct transport_ice*) tp;\n\n    PJ_ASSERT_RETURN(tp && pct_lost <= 100, PJ_EINVAL);\n\n    if (dir & PJMEDIA_DIR_ENCODING)\n        ice->tx_drop_pct = pct_lost;\n\n    if (dir & PJMEDIA_DIR_DECODING)\n        ice->rx_drop_pct = pct_lost;\n\n    return PJ_SUCCESS;\n}\n\nstatic void tp_ice_on_destroy(void *arg)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)arg;\n\n    PJ_LOG(4, (tp_ice->base.name, \"ICE transport destroyed\"));\n    pj_pool_safe_release(&tp_ice->pool);\n}\n\n/*\n * Destroy ICE media transport.\n */\nstatic pj_status_t transport_destroy(pjmedia_transport *tp)\n{\n    struct transport_ice *tp_ice = (struct transport_ice*)tp;\n\n    PJ_LOG(4, (tp_ice->base.name, \"Destroying ICE transport\"));\n\n    /* Reset callback and user data */\n    pj_bzero(&tp_ice->cb, sizeof(tp_ice->cb));\n    tp_ice->base.user_data = NULL;\n    tp_ice->rtp_cb = NULL;\n    tp_ice->rtp_cb2 = NULL;\n    tp_ice->rtcp_cb = NULL;\n\n    if (tp_ice->ice_st) {\n        pj_grp_lock_t *grp_lock = pj_ice_strans_get_grp_lock(tp_ice->ice_st);\n        pj_ice_strans_destroy(tp_ice->ice_st);\n        tp_ice->ice_st = NULL;\n        pj_grp_lock_dec_ref(grp_lock);\n    } else {\n        tp_ice_on_destroy(tp);\n    }\n\n    return PJ_SUCCESS;\n}\n\n", "/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/transport_loop.h>\n#include <pj/array.h>\n#include <pj/assert.h>\n#include <pj/errno.h>\n#include <pj/ioqueue.h>\n#include <pj/log.h>\n#include <pj/pool.h>\n#include <pj/rand.h>\n#include <pj/string.h>\n\n\nstruct tp_user\n{\n    pj_bool_t           rx_disabled;    /**< Doesn't want to receive pkt?   */\n    void               *user_data;      /**< Only valid when attached       */\n    void  (*rtp_cb)(    void*,          /**< To report incoming RTP.        */\n                        void*,\n                        pj_ssize_t);\n    void  (*rtp_cb2)(   pjmedia_tp_cb_param*);\n    void  (*rtcp_cb)(   void*,          /**< To report incoming RTCP.       */\n                        void*,\n                        pj_ssize_t);\n};\n\nstruct transport_loop\n{\n    pjmedia_transport   base;           /**< Base transport.                */\n\n    pj_pool_t          *pool;           /**< Memory pool                    */\n    unsigned            max_attach_cnt; /**< Max number of attachments      */\n    unsigned            user_cnt;       /**< Number of attachments          */\n    struct tp_user     *users;          /**< Array of users.                */\n    pj_bool_t           disable_rx;     /**< Disable RX.                    */\n\n    pjmedia_loop_tp_setting setting;    /**< Setting.                       */\n\n    unsigned            tx_drop_pct;    /**< Percent of tx pkts to drop.    */\n    unsigned            rx_drop_pct;    /**< Percent of rx pkts to drop.    */\n\n};\n\n\n\n/*\n * These are media transport operations.\n */\nstatic pj_status_t transport_get_info (pjmedia_transport *tp,\n                                       pjmedia_transport_info *info);\nstatic pj_status_t transport_attach   (pjmedia_transport *tp,\n                                       void *user_data,\n                                       const pj_sockaddr_t *rem_addr,\n                                       const pj_sockaddr_t *rem_rtcp,\n                                       unsigned addr_len,\n                                       void (*rtp_cb)(void*,\n                                                      void*,\n                                                      pj_ssize_t),\n                                       void (*rtcp_cb)(void*,\n                                                       void*,\n                                                       pj_ssize_t));\nstatic pj_status_t transport_attach2  (pjmedia_transport *tp,\n                                       pjmedia_transport_attach_param\n                                           *att_param);\nstatic void        transport_detach   (pjmedia_transport *tp,\n                                       void *strm);\nstatic pj_status_t transport_send_rtp( pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_send_rtcp(pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_send_rtcp2(pjmedia_transport *tp,\n                                       const pj_sockaddr_t *addr,\n                                       unsigned addr_len,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_media_create(pjmedia_transport *tp,\n                                       pj_pool_t *pool,\n                                       unsigned options,\n                                       const pjmedia_sdp_session *sdp_remote,\n                                       unsigned media_index);\nstatic pj_status_t transport_encode_sdp(pjmedia_transport *tp,\n                                        pj_pool_t *pool,\n                                        pjmedia_sdp_session *sdp_local,\n                                        const pjmedia_sdp_session *rem_sdp,\n                                        unsigned media_index);\nstatic pj_status_t transport_media_start (pjmedia_transport *tp,\n                                       pj_pool_t *pool,\n                                       const pjmedia_sdp_session *sdp_local,\n                                       const pjmedia_sdp_session *sdp_remote,\n                                       unsigned media_index);\nstatic pj_status_t transport_media_stop(pjmedia_transport *tp);\nstatic pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n                                       pjmedia_dir dir,\n                                       unsigned pct_lost);\nstatic pj_status_t transport_destroy  (pjmedia_transport *tp);\n\n\nstatic pjmedia_transport_op transport_udp_op = \n{\n    &transport_get_info,\n    &transport_attach,\n    &transport_detach,\n    &transport_send_rtp,\n    &transport_send_rtcp,\n    &transport_send_rtcp2,\n    &transport_media_create,\n    &transport_encode_sdp,\n    &transport_media_start,\n    &transport_media_stop,\n    &transport_simulate_lost,\n    &transport_destroy,\n    &transport_attach2\n};\n\nstatic void tp_loop_on_destroy(void *arg);\n\n/**\n * Initialize loopback media transport setting with its default values.\n */\nPJ_DEF(void) pjmedia_loop_tp_setting_default(pjmedia_loop_tp_setting *opt)\n{\n    pj_bzero(opt, sizeof(pjmedia_loop_tp_setting));\n    \n    opt->af = pj_AF_INET();\n    opt->max_attach_cnt = 4;\n}\n\n\n/**\n * Create loopback transport.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_loop_create(pjmedia_endpt *endpt,\n                                                  pjmedia_transport **p_tp)\n{\n    pjmedia_loop_tp_setting opt;\n\n    pjmedia_loop_tp_setting_default(&opt);\n\n    return pjmedia_transport_loop_create2(endpt, &opt, p_tp);\n}\n\n\nPJ_DEF(pj_status_t)\npjmedia_transport_loop_create2(pjmedia_endpt *endpt,\n                               const pjmedia_loop_tp_setting *opt,\n                               pjmedia_transport **p_tp)\n{\n    struct transport_loop *tp;\n    pj_pool_t *pool;\n    pj_grp_lock_t *grp_lock;\n    pj_status_t status;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(endpt && p_tp, PJ_EINVAL);\n\n    /* Create transport structure */\n    pool = pjmedia_endpt_create_pool(endpt, \"tploop\", 512, 512);\n    if (!pool)\n        return PJ_ENOMEM;\n\n    tp = PJ_POOL_ZALLOC_T(pool, struct transport_loop);\n    tp->pool = pool;\n    pj_memcpy(tp->base.name, tp->pool->obj_name, PJ_MAX_OBJ_NAME);\n    tp->base.op = &transport_udp_op;\n    tp->base.type = PJMEDIA_TRANSPORT_TYPE_UDP;\n\n    /* Create group lock */\n    status = pj_grp_lock_create(pool, NULL, &grp_lock);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    pj_grp_lock_add_ref(grp_lock);\n    pj_grp_lock_add_handler(grp_lock, pool, tp, &tp_loop_on_destroy);\n\n    if (opt) {\n        tp->setting = *opt;\n    } else {\n        pjmedia_loop_tp_setting_default(&tp->setting);\n    }\n    if (tp->setting.addr.slen) {\n        pj_strdup(pool, &tp->setting.addr, &opt->addr);\n    } else {\n        pj_strset2(&tp->setting.addr, (tp->setting.af == pj_AF_INET())?\n                                       \"127.0.0.1\": \"::1\");\n    }\n    if (tp->setting.port == 0)\n        tp->setting.port = 4000;\n\n    /* alloc users array */\n    tp->max_attach_cnt = tp->setting.max_attach_cnt;\n    if (tp->max_attach_cnt == 0)\n        tp->max_attach_cnt = 1;\n    tp->users = (struct tp_user *)pj_pool_calloc(pool, tp->max_attach_cnt, sizeof(struct tp_user));\n\n    /* Done */\n    *p_tp = &tp->base;\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_transport_loop_disable_rx( pjmedia_transport *tp,\n                                                       void *user,\n                                                       pj_bool_t disabled)\n{\n    struct transport_loop *loop = (struct transport_loop*) tp;\n    unsigned i;\n\n    for (i=0; i<loop->user_cnt; ++i) {\n        if (loop->users[i].user_data == user) {\n            loop->users[i].rx_disabled = disabled;\n            return PJ_SUCCESS;\n        }\n    }\n    pj_assert(!\"Invalid stream user\");\n    return PJ_ENOTFOUND;\n}\n\n\nstatic void tp_loop_on_destroy(void *arg)\n{\n    struct transport_loop *loop = (struct transport_loop*) arg;\n\n    PJ_LOG(4, (loop->base.name, \"Loop transport destroyed\"));\n    pj_pool_release(loop->pool);\n}\n\n\n/**\n * Close loopback transport.\n */\nstatic pj_status_t transport_destroy(pjmedia_transport *tp)\n{\n    /* Sanity check */\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    pj_grp_lock_dec_ref(tp->grp_lock);\n\n    return PJ_SUCCESS;\n}\n\n\n/* Called to get the transport info */\nstatic pj_status_t transport_get_info(pjmedia_transport *tp,\n                                      pjmedia_transport_info *info)\n{\n    struct transport_loop *loop = (struct transport_loop*) tp;\n\n    info->sock_info.rtp_sock = 1;\n    pj_sockaddr_init(loop->setting.af, &info->sock_info.rtp_addr_name, \n                     &loop->setting.addr, (pj_uint16_t)loop->setting.port);\n    info->sock_info.rtcp_sock = 2;\n    pj_sockaddr_init(loop->setting.af, &info->sock_info.rtcp_addr_name,\n                     &loop->setting.addr, (pj_uint16_t)loop->setting.port + 1);\n\n    return PJ_SUCCESS;\n}\n\n\n/* Called by application to initialize the transport */\nstatic pj_status_t tp_attach(   pjmedia_transport *tp,\n                                       void *user_data,\n                                       const pj_sockaddr_t *rem_addr,\n                                       const pj_sockaddr_t *rem_rtcp,\n                                       unsigned addr_len,\n                                       void (*rtp_cb)(void*,\n                                                      void*,\n                                                      pj_ssize_t),\n                                       void (*rtp_cb2)(pjmedia_tp_cb_param*),\n                                       void (*rtcp_cb)(void*,\n                                                       void*,\n                                                       pj_ssize_t))\n{\n    struct transport_loop *loop = (struct transport_loop*) tp;\n    unsigned i;\n    const pj_sockaddr *rtcp_addr;\n\n    /* Validate arguments */\n    PJ_ASSERT_RETURN(tp && rem_addr && addr_len, PJ_EINVAL);\n\n    /* Must not be \"attached\" to same user */\n    for (i=0; i<loop->user_cnt; ++i) {\n        PJ_ASSERT_RETURN(loop->users[i].user_data != user_data,\n                         PJ_EINVALIDOP);\n    }\n    PJ_ASSERT_RETURN(loop->user_cnt != loop->max_attach_cnt, PJ_ETOOMANY);\n\n    PJ_UNUSED_ARG(rem_rtcp);\n    PJ_UNUSED_ARG(rtcp_addr);\n\n    /* \"Attach\" the application: */\n\n    /* Save the new user */\n    loop->users[loop->user_cnt].rtp_cb = rtp_cb;\n    loop->users[loop->user_cnt].rtp_cb2 = rtp_cb2;\n    loop->users[loop->user_cnt].rtcp_cb = rtcp_cb;\n    loop->users[loop->user_cnt].user_data = user_data;\n    loop->users[loop->user_cnt].rx_disabled = loop->disable_rx;\n    ++loop->user_cnt;\n\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t transport_attach(   pjmedia_transport *tp,\n                                       void *user_data,\n                                       const pj_sockaddr_t *rem_addr,\n                                       const pj_sockaddr_t *rem_rtcp,\n                                       unsigned addr_len,\n                                       void (*rtp_cb)(void*,\n                                                      void*,\n                                                      pj_ssize_t),\n                                       void (*rtcp_cb)(void*,\n                                                       void*,\n                                                       pj_ssize_t))\n{\n    return tp_attach(tp, user_data, rem_addr, rem_rtcp, addr_len,\n                     rtp_cb, NULL, rtcp_cb);\n}\n\nstatic pj_status_t transport_attach2(pjmedia_transport *tp,\n                                     pjmedia_transport_attach_param *att_param)\n{\n    return tp_attach(tp, att_param->user_data, \n                            (pj_sockaddr_t*)&att_param->rem_addr, \n                            (pj_sockaddr_t*)&att_param->rem_rtcp, \n                            att_param->addr_len, att_param->rtp_cb,\n                            att_param->rtp_cb2, \n                            att_param->rtcp_cb);\n}\n\n\n/* Called by application when it no longer needs the transport */\nstatic void transport_detach( pjmedia_transport *tp,\n                              void *user_data)\n{\n    struct transport_loop *loop = (struct transport_loop*) tp;\n    unsigned i;\n\n    pj_assert(tp);\n\n    for (i=0; i<loop->user_cnt; ++i) {\n        if (loop->users[i].user_data == user_data)\n            break;\n    }\n\n    /* Remove this user */\n    if (i != loop->user_cnt) {\n        pj_array_erase(loop->users, sizeof(loop->users[0]),\n                       loop->user_cnt, i);\n        --loop->user_cnt;\n    }\n}\n\n\n/* Called by application to send RTP packet */\nstatic pj_status_t transport_send_rtp( pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size)\n{\n    struct transport_loop *loop = (struct transport_loop*)tp;\n    unsigned i;\n\n    /* Simulate packet lost on TX direction */\n    if (loop->tx_drop_pct) {\n        if ((pj_rand() % 100) <= (int)loop->tx_drop_pct) {\n            PJ_LOG(5,(loop->base.name, \n                      \"TX RTP packet dropped because of pkt lost \"\n                      \"simulation\"));\n            return PJ_SUCCESS;\n        }\n    }\n\n    /* Simulate packet lost on RX direction */\n    if (loop->rx_drop_pct) {\n        if ((pj_rand() % 100) <= (int)loop->rx_drop_pct) {\n            PJ_LOG(5,(loop->base.name, \n                      \"RX RTP packet dropped because of pkt lost \"\n                      \"simulation\"));\n            return PJ_SUCCESS;\n        }\n    }\n\n    pj_grp_lock_add_ref(tp->grp_lock);\n\n    /* Distribute to users */\n    for (i=0; i<loop->user_cnt; ++i) {\n        if (loop->users[i].rx_disabled) continue;\n        if (loop->users[i].rtp_cb2) {\n            pjmedia_tp_cb_param param;\n\n            pj_bzero(&param, sizeof(param));\n            param.user_data = loop->users[i].user_data;\n            param.pkt = (void *)pkt;\n            param.size = size;\n            (*loop->users[i].rtp_cb2)(&param);\n        } else if (loop->users[i].rtp_cb) {\n            (*loop->users[i].rtp_cb)(loop->users[i].user_data, (void*)pkt, \n                                     size);\n        }\n    }\n\n    pj_grp_lock_dec_ref(tp->grp_lock);\n\n    return PJ_SUCCESS;\n}\n\n/* Called by application to send RTCP packet */\nstatic pj_status_t transport_send_rtcp(pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size)\n{\n    return transport_send_rtcp2(tp, NULL, 0, pkt, size);\n}\n\n\n/* Called by application to send RTCP packet */\nstatic pj_status_t transport_send_rtcp2(pjmedia_transport *tp,\n                                        const pj_sockaddr_t *addr,\n                                        unsigned addr_len,\n                                        const void *pkt,\n                                        pj_size_t size)\n{\n    struct transport_loop *loop = (struct transport_loop*)tp;\n    unsigned i;\n\n    PJ_UNUSED_ARG(addr_len);\n    PJ_UNUSED_ARG(addr);\n\n    pj_grp_lock_add_ref(tp->grp_lock);\n\n    /* Distribute to users */\n    for (i=0; i<loop->user_cnt; ++i) {\n        if (!loop->users[i].rx_disabled && loop->users[i].rtcp_cb)\n            (*loop->users[i].rtcp_cb)(loop->users[i].user_data, (void*)pkt,\n                                      size);\n    }\n\n    pj_grp_lock_dec_ref(tp->grp_lock);\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t transport_media_create(pjmedia_transport *tp,\n                                  pj_pool_t *pool,\n                                  unsigned options,\n                                  const pjmedia_sdp_session *sdp_remote,\n                                  unsigned media_index)\n{\n    PJ_UNUSED_ARG(tp);\n    PJ_UNUSED_ARG(pool);\n    PJ_UNUSED_ARG(options);\n    PJ_UNUSED_ARG(sdp_remote);\n    PJ_UNUSED_ARG(media_index);\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t transport_encode_sdp(pjmedia_transport *tp,\n                                        pj_pool_t *pool,\n                                        pjmedia_sdp_session *sdp_local,\n                                        const pjmedia_sdp_session *rem_sdp,\n                                        unsigned media_index)\n{\n    PJ_UNUSED_ARG(tp);\n    PJ_UNUSED_ARG(pool);\n    PJ_UNUSED_ARG(sdp_local);\n    PJ_UNUSED_ARG(rem_sdp);\n    PJ_UNUSED_ARG(media_index);\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t transport_media_start(pjmedia_transport *tp,\n                                  pj_pool_t *pool,\n                                  const pjmedia_sdp_session *sdp_local,\n                                  const pjmedia_sdp_session *sdp_remote,\n                                  unsigned media_index)\n{\n    PJ_UNUSED_ARG(tp);\n    PJ_UNUSED_ARG(pool);\n    PJ_UNUSED_ARG(sdp_local);\n    PJ_UNUSED_ARG(sdp_remote);\n    PJ_UNUSED_ARG(media_index);\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t transport_media_stop(pjmedia_transport *tp)\n{\n    PJ_UNUSED_ARG(tp);\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n                                           pjmedia_dir dir,\n                                           unsigned pct_lost)\n{\n    struct transport_loop *loop = (struct transport_loop*)tp;\n\n    PJ_ASSERT_RETURN(tp && pct_lost <= 100, PJ_EINVAL);\n\n    if (dir & PJMEDIA_DIR_ENCODING)\n        loop->tx_drop_pct = pct_lost;\n    \n    if (dir & PJMEDIA_DIR_DECODING)\n        loop->rx_drop_pct = pct_lost;\n\n    return PJ_SUCCESS;\n}\n\n", "/*\n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n */\n\n#include <pjmedia/transport_srtp.h>\n#include <pjmedia/endpoint.h>\n#include <pjmedia/rtp.h>\n#include <pjlib-util/base64.h>\n#include <pj/array.h>\n#include <pj/assert.h>\n#include <pj/ctype.h>\n#include <pj/lock.h>\n#include <pj/log.h>\n#include <pj/os.h>\n#include <pj/pool.h>\n\n#if defined(PJMEDIA_HAS_SRTP) && (PJMEDIA_HAS_SRTP != 0)\n\n/* Enable this to test ROC initialization setting. For offerer,\n * it will send packets with ROC 1 and expect to receive ROC 2.\n * For answerer it will be the other way around.\n */\n#define TEST_ROC 0\n\n#if defined(PJ_HAS_SSL_SOCK) && PJ_HAS_SSL_SOCK != 0 && \\\n    (PJ_SSL_SOCK_IMP == PJ_SSL_SOCK_IMP_OPENSSL)\n#  include <openssl/rand.h>\n#  include <openssl/opensslv.h>\n\n/* Suppress compile warning of OpenSSL deprecation (OpenSSL is deprecated\n * since MacOSX 10.7).\n */\n#if defined(PJ_DARWINOS) && PJ_DARWINOS==1\n#  pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n#endif\n\n#endif\n\n#if defined(PJMEDIA_EXTERNAL_SRTP)\n\n#if (PJMEDIA_EXTERNAL_SRTP == 1)        /* External SRTP 1.x */\n#  include <srtp/srtp.h>\n#  include <srtp/crypto_kernel.h>\n#define srtp_crypto_policy_t            crypto_policy_t\n#define srtp_cipher_type_id_t           cipher_type_id_t\n#define srtp_cipher_type_t              cipher_type_t\n#define srtp_auth_type_id_t             auth_type_id_t\n#define srtp_sec_serv_t                 sec_serv_t\n#define srtp_err_status_t               err_status_t\n#define srtp_err_status_ok              err_status_ok\n#define srtp_err_status_replay_old      err_status_replay_old\n#define srtp_err_status_replay_fail     err_status_replay_fail\n#define srtp_crypto_policy_set_aes_cm_256_hmac_sha1_32 \\\n             crypto_policy_set_aes_cm_256_hmac_sha1_32\n#define srtp_crypto_policy_set_aes_cm_256_hmac_sha1_80 \\\n             crypto_policy_set_aes_cm_256_hmac_sha1_80\n#define SRTP_NULL_CIPHER                NULL_CIPHER\n#define SRTP_NULL_AUTH                  NULL_AUTH\n#define SRTP_AES_ICM_128                AES_ICM\n#define SRTP_AES_ICM_192                AES_ICM\n#define SRTP_AES_ICM_256                AES_ICM\n#define SRTP_AES_GCM_128                AES_128_GCM\n#define SRTP_AES_GCM_256                AES_256_GCM\n#define SRTP_HMAC_SHA1                  HMAC_SHA1\n#define srtp_aes_gcm_256_openssl        aes_gcm_256_openssl\n#define srtp_aes_gcm_128_openssl        aes_gcm_128_openssl\n\n#else                                   /* External SRTP 2.x */\n#  include <srtp2/srtp.h>\n#  include <srtp2/cipher.h>\n\n/* In libsrtp 2.0.0, the macro SRTP_AES_ICM_128 is not available. \n * Instead it was named with ICM at the end: SRTP_AES_128_ICM. \n */\n#  ifdef SRTP_AES_128_ICM\n#    define SRTP_AES_ICM_128            SRTP_AES_128_ICM\n#    define SRTP_AES_ICM_192            SRTP_AES_192_ICM\n#    define SRTP_AES_ICM_256            SRTP_AES_256_ICM\n#    define SRTP_AES_GCM_128            SRTP_AES_128_GCM\n#    define SRTP_AES_GCM_256            SRTP_AES_256_GCM\n#  endif\n\n#endif\n\n#else                                   /* Bundled SRTP */\n\n#  include <srtp_config.h>\n#  include <srtp.h>\n#  include <crypto_kernel.h>\n\n#define srtp_aes_gcm_256_openssl        srtp_aes_gcm_256\n#define srtp_aes_gcm_128_openssl        srtp_aes_gcm_128\n\n#endif\n\n#define THIS_FILE   \"transport_srtp.c\"\n\n/* Maximum size of outgoing packet */\n#define MAX_RTP_BUFFER_LEN          PJMEDIA_MAX_MTU\n#define MAX_RTCP_BUFFER_LEN         PJMEDIA_MAX_MTU\n\n/* Maximum SRTP crypto key length */\n#define MAX_KEY_LEN                 128\n\n/* Initial value of probation counter. When probation counter > 0,\n * it means SRTP is in probation state, and it may restart when\n * srtp_unprotect() returns err_status_replay_*\n */\n#define PROBATION_CNT_INIT          100\n\n#define DEACTIVATE_MEDIA(pool, m)   pjmedia_sdp_media_deactivate(pool, m)\n\n#ifdef SRTP_MAX_TRAILER_LEN\n#   define MAX_TRAILER_LEN SRTP_MAX_TRAILER_LEN\n#else\n#   define MAX_TRAILER_LEN 10\n#endif\n\n/* Maximum number of SRTP keying method */\n#define MAX_KEYING                  2\n\nstatic const pj_str_t ID_RTP_AVP  = { \"RTP/AVP\", 7 };\nstatic const pj_str_t ID_RTP_SAVP = { \"RTP/SAVP\", 8 };\n// static const pj_str_t ID_INACTIVE = { \"inactive\", 8 };\nstatic const pj_str_t ID_CRYPTO   = { \"crypto\", 6 };\n\ntypedef void (*crypto_method_t)(srtp_crypto_policy_t *policy);\n\ntypedef struct crypto_suite\n{\n    char                *name;\n    srtp_cipher_type_id_t cipher_type;\n    unsigned             cipher_key_len;    /* key + salt length    */\n    unsigned             cipher_salt_len;   /* salt only length     */\n    srtp_auth_type_id_t  auth_type;\n    unsigned             auth_key_len;\n    unsigned             srtp_auth_tag_len;\n    unsigned             srtcp_auth_tag_len;\n    srtp_sec_serv_t      service;\n    /* This is an attempt to validate crypto support by libsrtp, i.e: it should\n     * raise linking error if the libsrtp does not support the crypto. \n     */\n    srtp_cipher_type_t  *ext_cipher_type;\n    crypto_method_t      ext_crypto_method;\n} crypto_suite;\n\nextern srtp_cipher_type_t srtp_aes_gcm_256_openssl;\nextern srtp_cipher_type_t srtp_aes_gcm_128_openssl;\nextern srtp_cipher_type_t srtp_aes_icm_192;\n\n/* https://www.iana.org/assignments/sdp-security-descriptions/sdp-security-descriptions.xhtml */\nstatic crypto_suite crypto_suites[] = {\n    /* plain RTP/RTCP (no cipher & no auth) */\n    {\"NULL\", SRTP_NULL_CIPHER, 0, SRTP_NULL_AUTH, 0, 0, 0, sec_serv_none},\n\n#if defined(PJMEDIA_SRTP_HAS_AES_GCM_256)&&(PJMEDIA_SRTP_HAS_AES_GCM_256!=0)\n\n    /* cipher AES_GCM, NULL auth, auth tag len = 16 octets */\n    {\"AEAD_AES_256_GCM\", SRTP_AES_GCM_256, 44, 12,\n        SRTP_NULL_AUTH, 0, 16, 16, sec_serv_conf_and_auth,\n        &srtp_aes_gcm_256_openssl},\n\n    /* cipher AES_GCM, NULL auth, auth tag len = 8 octets */\n    {\"AEAD_AES_256_GCM_8\", SRTP_AES_GCM_256, 44, 12,\n        SRTP_NULL_AUTH, 0, 8, 8, sec_serv_conf_and_auth,\n        &srtp_aes_gcm_256_openssl},\n#endif\n#if defined(PJMEDIA_SRTP_HAS_AES_CM_256)&&(PJMEDIA_SRTP_HAS_AES_CM_256!=0)\n\n    /* cipher AES_CM_256, auth SRTP_HMAC_SHA1, auth tag len = 10 octets */\n    {\"AES_256_CM_HMAC_SHA1_80\", SRTP_AES_ICM_256, 46, 14,\n        SRTP_HMAC_SHA1, 20, 10, 10, sec_serv_conf_and_auth,\n        NULL, &srtp_crypto_policy_set_aes_cm_256_hmac_sha1_80},\n\n    /* cipher AES_CM_256, auth SRTP_HMAC_SHA1, auth tag len = 10 octets */\n    {\"AES_256_CM_HMAC_SHA1_32\", SRTP_AES_ICM_256, 46, 14,\n        SRTP_HMAC_SHA1, 20, 4, 10, sec_serv_conf_and_auth,\n        NULL, &srtp_crypto_policy_set_aes_cm_256_hmac_sha1_32},\n#endif\n#if defined(PJMEDIA_SRTP_HAS_AES_CM_192)&&(PJMEDIA_SRTP_HAS_AES_CM_192!=0)\n\n    /* cipher AES_CM_192, auth SRTP_HMAC_SHA1, auth tag len = 10 octets */\n    {\"AES_192_CM_HMAC_SHA1_80\", SRTP_AES_ICM_192, 38, 14,\n        SRTP_HMAC_SHA1, 20, 10, 10, sec_serv_conf_and_auth,\n        &srtp_aes_icm_192},\n\n    /* cipher AES_CM_192, auth SRTP_HMAC_SHA1, auth tag len = 4 octets */\n    {\"AES_192_CM_HMAC_SHA1_32\", SRTP_AES_ICM_192, 38, 14,\n        SRTP_HMAC_SHA1, 20, 4, 10, sec_serv_conf_and_auth,\n        &srtp_aes_icm_192},\n#endif\n#if defined(PJMEDIA_SRTP_HAS_AES_GCM_128)&&(PJMEDIA_SRTP_HAS_AES_GCM_128!=0)\n\n    /* cipher AES_GCM, NULL auth, auth tag len = 16 octets */\n    {\"AEAD_AES_128_GCM\", SRTP_AES_GCM_128, 28, 12,\n        SRTP_NULL_AUTH, 0, 16, 16, sec_serv_conf_and_auth,\n        &srtp_aes_gcm_128_openssl},\n\n    /* cipher AES_GCM, NULL auth, auth tag len = 8 octets */\n    {\"AEAD_AES_128_GCM_8\", SRTP_AES_GCM_128, 28, 12,\n        SRTP_NULL_AUTH, 0, 8, 8, sec_serv_conf_and_auth,\n        &srtp_aes_gcm_128_openssl},\n#endif\n#if defined(PJMEDIA_SRTP_HAS_AES_CM_128)&&(PJMEDIA_SRTP_HAS_AES_CM_128!=0)\n\n    /* cipher AES_CM_128, auth SRTP_HMAC_SHA1, auth tag len = 10 octets */\n    {\"AES_CM_128_HMAC_SHA1_80\", SRTP_AES_ICM_128, 30, 14,\n        SRTP_HMAC_SHA1, 20, 10, 10, sec_serv_conf_and_auth},\n\n    /* cipher AES_CM_128, auth SRTP_HMAC_SHA1, auth tag len = 4 octets */\n    {\"AES_CM_128_HMAC_SHA1_32\", SRTP_AES_ICM_128, 30, 14,\n        SRTP_HMAC_SHA1, 20, 4, 10, sec_serv_conf_and_auth},\n#endif\n\n    /*\n     * F8_128_HMAC_SHA1_8 not supported by libsrtp?\n     * {\"F8_128_HMAC_SHA1_8\", NULL_CIPHER, 0, 0, NULL_AUTH, 0, 0, 0,\n     *  sec_serv_none}\n     */\n};\n\ntypedef struct srtp_context\n{\n    /* SRTP policy */\n    char                 tx_key[MAX_KEY_LEN];\n    char                 rx_key[MAX_KEY_LEN];\n    pjmedia_srtp_crypto  tx_policy;\n    pjmedia_srtp_crypto  rx_policy;\n\n    /* Temporary policy for negotiation */\n    pjmedia_srtp_crypto  tx_policy_neg;\n    pjmedia_srtp_crypto  rx_policy_neg;\n\n    /* libSRTP contexts */\n    srtp_t               srtp_tx_ctx;\n    srtp_t               srtp_rx_ctx;\n} srtp_context;\n\n/* SRTP transport */\ntypedef struct transport_srtp\n{\n    pjmedia_transport    base;              /**< Base transport interface.  */\n    pj_pool_t           *pool;              /**< Pool for transport SRTP.   */\n    pj_lock_t           *mutex;             /**< Mutex for libsrtp contexts.*/\n    char                 rtp_tx_buffer[MAX_RTP_BUFFER_LEN];\n    char                 rtcp_tx_buffer[MAX_RTCP_BUFFER_LEN];\n    pjmedia_srtp_setting setting;\n    unsigned             media_option;\n    pj_bool_t            use_rtcp_mux;      /**< Use RTP& RTCP multiplexing?*/\n\n    pj_bool_t            session_inited;\n    pj_bool_t            offerer_side;\n    pj_bool_t            bypass_srtp;\n\n    /* SRTP contexts */\n    srtp_context         srtp_ctx;\n    srtp_context         srtp_rtcp;         /**< Separate context for RTCP,\n                                                 if needed, such as for DTLS*/\n\n    /* Stream information */\n    void                *user_data;\n    void                (*rtp_cb)( void *user_data,\n                                   void *pkt,\n                                   pj_ssize_t size);\n    void                (*rtp_cb2)(pjmedia_tp_cb_param*);\n    void                (*rtcp_cb)(void *user_data,\n                                   void *pkt,\n                                   pj_ssize_t size);\n\n    /* Transport information */\n    pjmedia_transport   *member_tp; /**< Underlying transport.       */\n    pj_bool_t            member_tp_attached;\n    pj_bool_t            started;\n\n    /* SRTP usage policy of peer. This field is updated when media is starting.\n     * This is useful when SRTP is in optional mode and peer is using mandatory\n     * mode, so when local is about to reinvite/update, it should offer\n     * RTP/SAVP instead of offering RTP/AVP.\n     */\n    pjmedia_srtp_use     peer_use;\n\n    /* When probation counter > 0, it means SRTP is in probation state,\n     * and it may restart when srtp_unprotect() returns err_status_replay_*\n     */\n    unsigned             probation_cnt;\n\n    /* SRTP keying methods. The keying is implemented using media transport\n     * abstraction, so it will also be invoked when the SRTP media transport\n     * operation is invoked.\n     *\n     * As there can be multiple keying methods enabled (currently only SDES &\n     * DTLS-SRTP), each keying method will be given the chance to respond to\n     * remote SDP. If any keying operation returns non-success, it will be\n     * removed from the session. And once SRTP key is obtained via a keying\n     * method, any other keying methods will be stopped and destroyed.\n     */\n    unsigned             all_keying_cnt;\n    pjmedia_transport   *all_keying[MAX_KEYING];\n\n    /* Current active SRTP keying methods. */\n    unsigned             keying_cnt;\n    pjmedia_transport   *keying[MAX_KEYING];\n\n    /* If not zero, keying nego is ongoing (async-ly, e.g: by DTLS-SRTP).\n     * This field may be updated by keying method.\n     */\n    unsigned             keying_pending_cnt;\n\n    /* RTP SSRC in receiving direction, used in getting and setting SRTP\n     * roll over counter (ROC) on SRTP restart.\n     */\n    pj_uint32_t          rx_ssrc;\n\n    pj_uint32_t          tx_ssrc;\n\n} transport_srtp;\n\n\n/*\n * This callback is called by transport when incoming rtp is received\n */\nstatic void srtp_rtp_cb(pjmedia_tp_cb_param *param);\n\n/*\n * This callback is called by transport when incoming rtcp is received\n */\nstatic void srtp_rtcp_cb( void *user_data, void *pkt, pj_ssize_t size);\n\n\n/*\n * These are media transport operations.\n */\nstatic pj_status_t transport_get_info (pjmedia_transport *tp,\n                                       pjmedia_transport_info *info);\n//static pj_status_t transport_attach   (pjmedia_transport *tp,\n//                                     void *user_data,\n//                                     const pj_sockaddr_t *rem_addr,\n//                                     const pj_sockaddr_t *rem_rtcp,\n//                                     unsigned addr_len,\n//                                     void (*rtp_cb)(void*,\n//                                                    void*,\n//                                                    pj_ssize_t),\n//                                     void (*rtcp_cb)(void*,\n//                                                     void*,\n//                                                     pj_ssize_t));\nstatic void        transport_detach   (pjmedia_transport *tp,\n                                       void *strm);\nstatic pj_status_t transport_send_rtp( pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_send_rtcp(pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_send_rtcp2(pjmedia_transport *tp,\n                                       const pj_sockaddr_t *addr,\n                                       unsigned addr_len,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_media_create(pjmedia_transport *tp,\n                                       pj_pool_t *sdp_pool,\n                                       unsigned options,\n                                       const pjmedia_sdp_session *sdp_remote,\n                                       unsigned media_index);\nstatic pj_status_t transport_encode_sdp(pjmedia_transport *tp,\n                                       pj_pool_t *sdp_pool,\n                                       pjmedia_sdp_session *sdp_local,\n                                       const pjmedia_sdp_session *sdp_remote,\n                                       unsigned media_index);\nstatic pj_status_t transport_media_start (pjmedia_transport *tp,\n                                       pj_pool_t *pool,\n                                       const pjmedia_sdp_session *sdp_local,\n                                       const pjmedia_sdp_session *sdp_remote,\n                                       unsigned media_index);\nstatic pj_status_t transport_media_stop(pjmedia_transport *tp);\nstatic pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n                                       pjmedia_dir dir,\n                                       unsigned pct_lost);\nstatic pj_status_t transport_destroy  (pjmedia_transport *tp);\nstatic pj_status_t transport_attach2  (pjmedia_transport *tp,\n                                       pjmedia_transport_attach_param *param);\n\n\n\nstatic pjmedia_transport_op transport_srtp_op =\n{\n    &transport_get_info,\n    NULL, //&transport_attach,\n    &transport_detach,\n    &transport_send_rtp,\n    &transport_send_rtcp,\n    &transport_send_rtcp2,\n    &transport_media_create,\n    &transport_encode_sdp,\n    &transport_media_start,\n    &transport_media_stop,\n    &transport_simulate_lost,\n    &transport_destroy,\n    &transport_attach2\n};\n\n/* Get crypto index from crypto name */\nstatic int get_crypto_idx(const pj_str_t* crypto_name);\n\n/* Is crypto empty (i.e: no name or key)? */\nstatic pj_bool_t srtp_crypto_empty(const pjmedia_srtp_crypto* c);\n\n/* Compare crypto, return zero if same */\nstatic int srtp_crypto_cmp(const pjmedia_srtp_crypto* c1,\n                           const pjmedia_srtp_crypto* c2);\n\n/* Start SRTP */\nstatic pj_status_t start_srtp(transport_srtp *srtp);\n/* Create SRTP context */\nstatic pj_status_t create_srtp_ctx(transport_srtp *srtp,\n                                   srtp_context *ctx,\n                                   const pjmedia_srtp_setting *setting,\n                                   const pjmedia_srtp_crypto *tx,\n                                   const pjmedia_srtp_crypto *rx);\n/* Destroy SRTP context */\nstatic void destroy_srtp_ctx(transport_srtp *p_srtp, srtp_context *ctx);\n\n/* SRTP destroy handler */\nstatic void srtp_on_destroy(void *arg);\n\n/* This function may also be used by other module, e.g: pjmedia/errno.c,\n * it should have C compatible declaration.\n */\nPJ_BEGIN_DECL\n    const char* get_libsrtp_errstr(int err);\nPJ_END_DECL\n\nconst char* get_libsrtp_errstr(int err)\n{\n#if defined(PJ_HAS_ERROR_STRING) && (PJ_HAS_ERROR_STRING != 0)\n    static char *liberr[] = {\n        \"ok\",                               /* srtp_err_status_ok       = 0  */\n        \"unspecified failure\",              /* err_status_fail          = 1  */\n        \"unsupported parameter\",            /* err_status_bad_param     = 2  */\n        \"couldn't allocate memory\",         /* err_status_alloc_fail    = 3  */\n        \"couldn't deallocate properly\",     /* err_status_dealloc_fail  = 4  */\n        \"couldn't initialize\",              /* err_status_init_fail     = 5  */\n        \"can't process as much data as requested\",\n                                            /* err_status_terminus      = 6  */\n        \"authentication failure\",           /* err_status_auth_fail     = 7  */\n        \"cipher failure\",                   /* err_status_cipher_fail   = 8  */\n        \"replay check failed (bad index)\",  /* err_status_replay_fail   = 9  */\n        \"replay check failed (index too old)\",\n                                            /* err_status_replay_old    = 10 */\n        \"algorithm failed test routine\",    /* err_status_algo_fail     = 11 */\n        \"unsupported operation\",            /* err_status_no_such_op    = 12 */\n        \"no appropriate context found\",     /* err_status_no_ctx        = 13 */\n        \"unable to perform desired validation\",\n                                            /* err_status_cant_check    = 14 */\n        \"can't use key any more\",           /* err_status_key_expired   = 15 */\n        \"error in use of socket\",           /* err_status_socket_err    = 16 */\n        \"error in use POSIX signals\",       /* err_status_signal_err    = 17 */\n        \"nonce check failed\",               /* err_status_nonce_bad     = 18 */\n        \"couldn't read data\",               /* err_status_read_fail     = 19 */\n        \"couldn't write data\",              /* err_status_write_fail    = 20 */\n        \"error pasring data\",               /* err_status_parse_err     = 21 */\n        \"error encoding data\",              /* err_status_encode_err    = 22 */\n        \"error while using semaphores\",     /* err_status_semaphore_err = 23 */\n        \"error while using pfkey\"           /* err_status_pfkey_err     = 24 */\n    };\n    if (err >= 0 && err < (int)PJ_ARRAY_SIZE(liberr)) {\n        return liberr[err];\n    } else {\n        static char msg[32];\n        pj_ansi_snprintf(msg, sizeof(msg), \"Unknown libsrtp error %d\", err);\n        return msg;\n    }\n#else\n    static char msg[32];\n    pj_ansi_snprintf(msg, sizeof(msg), \"libsrtp error %d\", err);\n    return msg;\n#endif\n}\n\n/* SRTP keying method: Session Description */\n#if defined(PJMEDIA_SRTP_HAS_SDES) && (PJMEDIA_SRTP_HAS_SDES != 0)\n#  include \"transport_srtp_sdes.c\"\n#endif\n\n/* SRTP keying method: DTLS */\n#if defined(PJMEDIA_SRTP_HAS_DTLS) && (PJMEDIA_SRTP_HAS_DTLS != 0)\n#  include \"transport_srtp_dtls.c\"\n#else\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_dtls_start_nego(\n                                pjmedia_transport *srtp,\n                                const pjmedia_srtp_dtls_nego_param *param)\n{\n    PJ_UNUSED_ARG(srtp);\n    PJ_UNUSED_ARG(param);\n    return PJ_ENOTSUP;\n}\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_dtls_get_fingerprint(\n                                pjmedia_transport *srtp,\n                                const char *hash,\n                                char *buf, pj_size_t *len)\n{\n    PJ_UNUSED_ARG(srtp);\n    PJ_UNUSED_ARG(hash);\n    PJ_UNUSED_ARG(buf);\n    PJ_UNUSED_ARG(len);\n    return PJ_ENOTSUP;\n}\n#endif\n\n\nstatic pj_bool_t libsrtp_initialized;\nstatic void pjmedia_srtp_deinit_lib(pjmedia_endpt *endpt);\n\nPJ_DEF(pj_status_t) pjmedia_srtp_init_lib(pjmedia_endpt *endpt)\n{\n    pj_status_t status = PJ_SUCCESS;\n\n    if (libsrtp_initialized)\n        return PJ_SUCCESS;\n\n#if PJMEDIA_LIBSRTP_AUTO_INIT_DEINIT\n    /* Init libsrtp */\n    {\n        srtp_err_status_t err;\n\n        err = srtp_init();\n        if (err != srtp_err_status_ok) {\n            PJ_LOG(4, (THIS_FILE, \"Failed to initialize libsrtp: %s\",\n                       get_libsrtp_errstr(err)));\n            pjmedia_srtp_deinit_lib(endpt);\n            return PJMEDIA_ERRNO_FROM_LIBSRTP(err);\n        }\n    }\n#endif\n\n#if defined(PJMEDIA_SRTP_HAS_DTLS) && (PJMEDIA_SRTP_HAS_DTLS != 0)\n    dtls_init();\n#endif\n\n    status = pjmedia_endpt_atexit(endpt, pjmedia_srtp_deinit_lib);\n    if (status != PJ_SUCCESS) {\n        /* There will be memory leak when it fails to schedule libsrtp\n         * deinitialization, however the memory leak could be harmless,\n         * since in modern OS's memory used by an application is released\n         * when the application terminates.\n         */\n        PJ_PERROR(4, (THIS_FILE, status,\n                      \"Failed to register libsrtp deinit.\"));\n\n        /* Ignore this error */\n        status = PJ_SUCCESS;\n    }\n\n    libsrtp_initialized = PJ_TRUE;\n\n    return status;\n}\n\nstatic void pjmedia_srtp_deinit_lib(pjmedia_endpt *endpt)\n{\n    srtp_err_status_t err;\n\n    /* Note that currently this SRTP init/deinit is not equipped with\n     * reference counter, it should be safe as normally there is only\n     * one single instance of media endpoint and even if it isn't, the\n     * pjmedia_transport_srtp_create() will invoke SRTP init (the only\n     * drawback should be the delay described by #788).\n     */\n\n    PJ_UNUSED_ARG(endpt);\n\n#if !defined(PJMEDIA_SRTP_HAS_DEINIT) && !defined(PJMEDIA_SRTP_HAS_SHUTDOWN)\n# define PJMEDIA_SRTP_HAS_SHUTDOWN 1\n#endif\n\n#if PJMEDIA_LIBSRTP_AUTO_INIT_DEINIT\n\n# if defined(PJMEDIA_SRTP_HAS_DEINIT) && PJMEDIA_SRTP_HAS_DEINIT!=0\n    err = srtp_deinit();\n# elif defined(PJMEDIA_SRTP_HAS_SHUTDOWN) && PJMEDIA_SRTP_HAS_SHUTDOWN!=0\n    err = srtp_shutdown();\n# else\n    err = srtp_err_status_ok;\n# endif\n    if (err != srtp_err_status_ok) {\n        PJ_LOG(4, (THIS_FILE, \"Failed to deinitialize libsrtp: %s\",\n                   get_libsrtp_errstr(err)));\n    }\n#endif // PJMEDIA_LIBSRTP_AUTO_INIT_DEINIT\n\n#if defined(PJMEDIA_SRTP_HAS_DTLS) && (PJMEDIA_SRTP_HAS_DTLS != 0)\n    dtls_deinit();\n#endif\n\n    libsrtp_initialized = PJ_FALSE;\n}\n\n\nstatic int get_crypto_idx(const pj_str_t* crypto_name)\n{\n    int i;\n    int cs_cnt = PJ_ARRAY_SIZE(crypto_suites);\n\n    /* treat unspecified crypto_name as crypto 'NULL' */\n    if (crypto_name->slen == 0)\n        return 0;\n\n    for (i=0; i<cs_cnt; ++i) {\n        if (!pj_stricmp2(crypto_name, crypto_suites[i].name))\n            return i;\n    }\n\n    return -1;\n}\n\n\nstatic int srtp_crypto_cmp(const pjmedia_srtp_crypto* c1,\n                           const pjmedia_srtp_crypto* c2)\n{\n    int r;\n\n    r = pj_strcmp(&c1->key, &c2->key);\n    if (r != 0)\n        return r;\n\n    r = pj_stricmp(&c1->name, &c2->name);\n    if (r != 0)\n        return r;\n\n    return (c1->flags != c2->flags);\n}\n\n\nstatic pj_bool_t srtp_crypto_empty(const pjmedia_srtp_crypto* c)\n{\n    return (c->name.slen==0 || c->key.slen==0);\n}\n\n\nPJ_DEF(void) pjmedia_srtp_setting_default(pjmedia_srtp_setting *opt)\n{\n    pj_assert(opt);\n\n    pj_bzero(opt, sizeof(pjmedia_srtp_setting));\n    opt->close_member_tp = PJ_TRUE;\n    opt->use = PJMEDIA_SRTP_OPTIONAL;\n}\n\n/*\n * Enumerate all SRTP cryptos, except \"NULL\".\n */\nPJ_DEF(pj_status_t) pjmedia_srtp_enum_crypto(unsigned *count,\n                                             pjmedia_srtp_crypto crypto[])\n{\n    unsigned i, max;\n\n    PJ_ASSERT_RETURN(count && crypto, PJ_EINVAL);\n\n    max = PJ_ARRAY_SIZE(crypto_suites) - 1;\n    if (*count > max)\n        *count = max;\n\n    for (i=0; i<*count; ++i) {\n        pj_bzero(&crypto[i], sizeof(crypto[0]));\n        crypto[i].name = pj_str(crypto_suites[i+1].name);\n    }\n    \n    return PJ_SUCCESS;\n}\n\n\n/*\n * Enumerate available SRTP keying methods.\n */\nPJ_DEF(pj_status_t) pjmedia_srtp_enum_keying(unsigned *count,\n                                      pjmedia_srtp_keying_method keying[])\n{\n    unsigned max;\n\n    PJ_ASSERT_RETURN(count && keying, PJ_EINVAL);\n\n    max = *count;\n    *count = 0;\n\n#if defined(PJMEDIA_SRTP_HAS_SDES) && (PJMEDIA_SRTP_HAS_SDES != 0)\n    if (*count < max)\n        keying[(*count)++] = PJMEDIA_SRTP_KEYING_SDES;\n#endif\n#if defined(PJMEDIA_SRTP_HAS_DTLS) && (PJMEDIA_SRTP_HAS_DTLS != 0)\n    if (*count < max)\n        keying[(*count)++] = PJMEDIA_SRTP_KEYING_DTLS_SRTP;\n#endif\n    \n    return PJ_SUCCESS;\n}\n\n\n/*\n * Create an SRTP media transport.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_create(\n                                       pjmedia_endpt *endpt,\n                                       pjmedia_transport *tp,\n                                       const pjmedia_srtp_setting *opt,\n                                       pjmedia_transport **p_tp)\n{\n    pj_pool_t *pool;\n    transport_srtp *srtp;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(endpt && tp && p_tp, PJ_EINVAL);\n\n    /* Check crypto */\n    if (opt && opt->use != PJMEDIA_SRTP_DISABLED) {\n        for (i=0; i < opt->crypto_count; ++i) {\n            int cs_idx = get_crypto_idx(&opt->crypto[i].name);\n\n            /* check crypto name */\n            if (cs_idx == -1)\n                return PJMEDIA_SRTP_ENOTSUPCRYPTO;\n\n            /* check key length */\n            if (opt->crypto[i].key.slen &&\n                opt->crypto[i].key.slen <\n                (pj_ssize_t)crypto_suites[cs_idx].cipher_key_len)\n                return PJMEDIA_SRTP_EINKEYLEN;\n        }\n    }\n\n    /* Init libsrtp. */\n    status = pjmedia_srtp_init_lib(endpt);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    pool = pjmedia_endpt_create_pool(endpt, \"srtp%p\", 1000, 1000);\n    srtp = PJ_POOL_ZALLOC_T(pool, transport_srtp);\n\n    srtp->pool = pool;\n    srtp->session_inited = PJ_FALSE;\n    srtp->bypass_srtp = PJ_FALSE;\n    srtp->probation_cnt = PROBATION_CNT_INIT;\n\n    if (opt) {\n        srtp->setting = *opt;\n        if (opt->use == PJMEDIA_SRTP_DISABLED)\n            srtp->setting.crypto_count = 0;\n\n        for (i=0; i < srtp->setting.crypto_count; ++i) {\n            int cs_idx = get_crypto_idx(&opt->crypto[i].name);\n            pj_str_t tmp_key = opt->crypto[i].key;\n\n            if (cs_idx == -1) continue;\n\n            /* re-set crypto */\n            srtp->setting.crypto[i].name = pj_str(crypto_suites[cs_idx].name);\n            /* cut key length */\n            if (tmp_key.slen)\n                tmp_key.slen = crypto_suites[cs_idx].cipher_key_len;\n            pj_strdup(pool, &srtp->setting.crypto[i].key, &tmp_key);\n        }\n    } else {\n        pjmedia_srtp_setting_default(&srtp->setting);\n    }\n\n    /* If crypto count is set to zero, setup default crypto-suites,\n     * i.e: all available crypto but 'NULL'.\n     */\n    if (srtp->setting.crypto_count == 0 && \n        srtp->setting.use != PJMEDIA_SRTP_DISABLED)\n    {\n        srtp->setting.crypto_count = PJMEDIA_SRTP_MAX_CRYPTOS;\n        pjmedia_srtp_enum_crypto(&srtp->setting.crypto_count,\n                                 srtp->setting.crypto);\n    }\n\n    status = pj_lock_create_recursive_mutex(pool, pool->obj_name,\n                                            &srtp->mutex);\n    if (status != PJ_SUCCESS) {\n        pj_pool_release(pool);\n        return status;\n    }\n\n    /* Initialize base pjmedia_transport */\n    pj_memcpy(srtp->base.name, pool->obj_name, PJ_MAX_OBJ_NAME);\n    if (tp)\n        srtp->base.type = tp->type;\n    else\n        srtp->base.type = PJMEDIA_TRANSPORT_TYPE_UDP;\n    srtp->base.op = &transport_srtp_op;\n    srtp->base.user_data = srtp->setting.user_data;\n\n    /* Set underlying transport */\n    srtp->member_tp = tp;\n\n    /* Setup group lock handler for destroy and callback synchronization */\n    if (tp && tp->grp_lock) {\n        srtp->base.grp_lock = tp->grp_lock;\n        pj_grp_lock_add_ref(tp->grp_lock);\n        pj_grp_lock_add_handler(tp->grp_lock, pool, srtp, &srtp_on_destroy);\n    }\n\n    /* Initialize peer's SRTP usage mode. */\n    srtp->peer_use = srtp->setting.use;\n\n    /* If keying count set to zero, setup default keying count & priorities */\n    if (srtp->setting.keying_count == 0) {\n        srtp->setting.keying_count = PJMEDIA_SRTP_KEYINGS_COUNT;\n        pjmedia_srtp_enum_keying(&srtp->setting.keying_count,\n                                 srtp->setting.keying);\n    }\n\n    /* Initialize SRTP keying method. */\n    for (i = 0; i < srtp->setting.keying_count && i < MAX_KEYING; ++i) {\n        switch(srtp->setting.keying[i]) {\n\n        case PJMEDIA_SRTP_KEYING_SDES:\n#if defined(PJMEDIA_SRTP_HAS_SDES) && (PJMEDIA_SRTP_HAS_SDES != 0)\n            sdes_create(srtp, &srtp->all_keying[srtp->all_keying_cnt++]);\n#endif\n            break;\n\n        case PJMEDIA_SRTP_KEYING_DTLS_SRTP:\n#if defined(PJMEDIA_SRTP_HAS_DTLS) && (PJMEDIA_SRTP_HAS_DTLS != 0)\n            dtls_create(srtp, &srtp->all_keying[srtp->all_keying_cnt++]);\n#endif\n            break;\n\n        default:\n            break;\n        }\n    }\n\n    /* Done */\n    *p_tp = &srtp->base;\n\n    PJ_LOG(4, (srtp->pool->obj_name, \"SRTP transport created\"));\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get SRTP media transport setting.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_get_setting(\n                                       pjmedia_transport *tp,\n                                       pjmedia_srtp_setting *opt)\n{\n    transport_srtp  *srtp = (transport_srtp*) tp;\n    *opt = srtp->setting;\n    return PJ_SUCCESS;\n}\n\n/*\n * Modify SRTP media transport setting.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_modify_setting(\n                                       pjmedia_transport *tp,\n                                       const pjmedia_srtp_setting *opt)\n{\n    transport_srtp  *srtp = (transport_srtp*) tp;\n    srtp->setting = *opt;\n    return PJ_SUCCESS;\n}\n\n\n/* Create SRTP context */\nstatic pj_status_t create_srtp_ctx(transport_srtp *srtp,\n                                   srtp_context *ctx,\n                                   const pjmedia_srtp_setting *setting,\n                                   const pjmedia_srtp_crypto *tx,\n                                   const pjmedia_srtp_crypto *rx)\n{\n    srtp_policy_t    tx_;\n    srtp_policy_t    rx_;\n    srtp_err_status_t err;\n    int              cr_tx_idx = 0;\n    int              au_tx_idx = 0;\n    int              cr_rx_idx = 0;\n    int              au_rx_idx = 0;\n    pj_status_t      status = PJ_SUCCESS;\n\n    pj_lock_acquire(srtp->mutex);\n\n    if (ctx->srtp_tx_ctx || ctx->srtp_rx_ctx)\n        destroy_srtp_ctx(srtp, ctx);\n\n    /* Get encryption and authentication method */\n    cr_tx_idx = au_tx_idx = get_crypto_idx(&tx->name);\n    if (tx->flags & PJMEDIA_SRTP_NO_ENCRYPTION)\n        cr_tx_idx = 0;\n    if (tx->flags & PJMEDIA_SRTP_NO_AUTHENTICATION)\n        au_tx_idx = 0;\n\n    cr_rx_idx = au_rx_idx = get_crypto_idx(&rx->name);\n    if (rx->flags & PJMEDIA_SRTP_NO_ENCRYPTION)\n        cr_rx_idx = 0;\n    if (rx->flags & PJMEDIA_SRTP_NO_AUTHENTICATION)\n        au_rx_idx = 0;\n\n    /* Check whether the crypto-suite requested is supported */\n    if (cr_tx_idx == -1 || cr_rx_idx == -1 || au_tx_idx == -1 ||\n        au_rx_idx == -1)\n    {\n        status = PJMEDIA_SRTP_ENOTSUPCRYPTO;\n        goto on_return;\n    }\n\n    /* If all options points to 'NULL' method, just bypass SRTP */\n    if (cr_tx_idx == 0 && cr_rx_idx == 0 && au_tx_idx == 0 && au_rx_idx == 0) {\n        /* To bypass SRTP: we return PJ_SUCCESS without allocating SRTP\n         * contexts.\n         */\n        goto on_return;\n    }\n\n    /* Check key length */\n    if (tx->key.slen != (pj_ssize_t)crypto_suites[cr_tx_idx].cipher_key_len ||\n        rx->key.slen != (pj_ssize_t)crypto_suites[cr_rx_idx].cipher_key_len)\n    {\n        status = PJMEDIA_SRTP_EINKEYLEN;\n        goto on_return;\n    }\n\n    /* Init transmit direction */\n    pj_bzero(&tx_, sizeof(srtp_policy_t));\n    pj_memmove(ctx->tx_key, tx->key.ptr, tx->key.slen);\n    if (cr_tx_idx && au_tx_idx)\n        tx_.rtp.sec_serv    = sec_serv_conf_and_auth;\n    else if (cr_tx_idx)\n        tx_.rtp.sec_serv    = sec_serv_conf;\n    else if (au_tx_idx)\n        tx_.rtp.sec_serv    = sec_serv_auth;\n    else\n        tx_.rtp.sec_serv    = sec_serv_none;\n    tx_.key                 = (uint8_t*)ctx->tx_key;\n    if (setting->tx_roc.roc != 0 &&\n        setting->tx_roc.ssrc != 0)\n    {\n        tx_.ssrc.type       = ssrc_specific;\n        tx_.ssrc.value      = setting->tx_roc.ssrc;\n    } else {\n        tx_.ssrc.type       = ssrc_any_outbound;\n        tx_.ssrc.value      = 0;\n    }\n    tx_.rtp.cipher_type     = crypto_suites[cr_tx_idx].cipher_type;\n    tx_.rtp.cipher_key_len  = crypto_suites[cr_tx_idx].cipher_key_len;\n    tx_.rtp.auth_type       = crypto_suites[au_tx_idx].auth_type;\n    tx_.rtp.auth_key_len    = crypto_suites[au_tx_idx].auth_key_len;\n    tx_.rtp.auth_tag_len    = crypto_suites[au_tx_idx].srtp_auth_tag_len;\n    tx_.rtcp                = tx_.rtp;\n    tx_.rtcp.auth_tag_len   = crypto_suites[au_tx_idx].srtcp_auth_tag_len;\n    tx_.next                = NULL;\n    err = srtp_create(&ctx->srtp_tx_ctx, &tx_);\n    if (err != srtp_err_status_ok) {\n        status = PJMEDIA_ERRNO_FROM_LIBSRTP(err);\n        goto on_return;\n    }\n    if (setting->tx_roc.roc != 0 &&\n        setting->tx_roc.ssrc != 0)\n    {\n        err = srtp_set_stream_roc(ctx->srtp_tx_ctx,\n                                  setting->tx_roc.ssrc,\n                                  setting->tx_roc.roc);\n        PJ_LOG(4, (THIS_FILE, \"Initializing SRTP TX ROC to SSRC %d with \"\n                   \"ROC %d %s\\n\", setting->tx_roc.ssrc,\n                   setting->tx_roc.roc,\n                   (err == srtp_err_status_ok)? \"succeeded\": \"failed\"));\n    }\n    ctx->tx_policy = *tx;\n    pj_strset(&ctx->tx_policy.key,  ctx->tx_key, tx->key.slen);\n    ctx->tx_policy.name=pj_str(crypto_suites[get_crypto_idx(&tx->name)].name);\n\n\n    /* Init receive direction */\n    pj_bzero(&rx_, sizeof(srtp_policy_t));\n    pj_memmove(ctx->rx_key, rx->key.ptr, rx->key.slen);\n    if (cr_rx_idx && au_rx_idx)\n        rx_.rtp.sec_serv    = sec_serv_conf_and_auth;\n    else if (cr_rx_idx)\n        rx_.rtp.sec_serv    = sec_serv_conf;\n    else if (au_rx_idx)\n        rx_.rtp.sec_serv    = sec_serv_auth;\n    else\n        rx_.rtp.sec_serv    = sec_serv_none;\n    rx_.key                 = (uint8_t*)ctx->rx_key;\n    if (setting->rx_roc.roc != 0 &&\n        setting->rx_roc.ssrc != 0)\n    {\n        rx_.ssrc.type       = ssrc_specific;\n        rx_.ssrc.value      = setting->rx_roc.ssrc;\n    } else {\n        rx_.ssrc.type       = ssrc_any_inbound;\n        rx_.ssrc.value      = 0;\n    }\n    rx_.rtp.sec_serv        = crypto_suites[cr_rx_idx].service;\n    rx_.rtp.cipher_type     = crypto_suites[cr_rx_idx].cipher_type;\n    rx_.rtp.cipher_key_len  = crypto_suites[cr_rx_idx].cipher_key_len;\n    rx_.rtp.auth_type       = crypto_suites[au_rx_idx].auth_type;\n    rx_.rtp.auth_key_len    = crypto_suites[au_rx_idx].auth_key_len;\n    rx_.rtp.auth_tag_len    = crypto_suites[au_rx_idx].srtp_auth_tag_len;\n    rx_.rtcp                = rx_.rtp;\n    rx_.rtcp.auth_tag_len   = crypto_suites[au_rx_idx].srtcp_auth_tag_len;\n    rx_.next                = NULL;\n    err = srtp_create(&ctx->srtp_rx_ctx, &rx_);\n    if (err != srtp_err_status_ok) {\n        srtp_dealloc(ctx->srtp_tx_ctx);\n        status = PJMEDIA_ERRNO_FROM_LIBSRTP(err);\n        goto on_return;\n    }\n    if (setting->rx_roc.roc != 0 &&\n        setting->rx_roc.ssrc != 0)\n    {\n        err = srtp_set_stream_roc(ctx->srtp_rx_ctx,\n                                  setting->rx_roc.ssrc,\n                                  setting->rx_roc.roc);\n        PJ_LOG(4, (THIS_FILE, \"Initializing SRTP RX ROC from SSRC %d with \"\n                   \"ROC %d %s\\n\",\n                   setting->rx_roc.ssrc, setting->rx_roc.roc,\n                   (err == srtp_err_status_ok)? \"succeeded\": \"failed\"));\n    }\n    ctx->rx_policy = *rx;\n    pj_strset(&ctx->rx_policy.key,  ctx->rx_key, rx->key.slen);\n    ctx->rx_policy.name=pj_str(crypto_suites[get_crypto_idx(&rx->name)].name);\n\n    /* Logging stuffs */\n#if PJ_LOG_MAX_LEVEL >= 5\n    {\n        char b64[PJ_BASE256_TO_BASE64_LEN(MAX_KEY_LEN)];\n        int b64_len;\n\n        /* TX crypto and key */\n        b64_len = sizeof(b64);\n        status = pj_base64_encode((pj_uint8_t*)tx->key.ptr, (int)tx->key.slen,\n                                  b64, &b64_len);\n        if (status != PJ_SUCCESS)\n            b64_len = pj_ansi_snprintf(b64, sizeof(b64), \"--key too long--\");\n        else\n            b64[b64_len] = '\\0';\n\n        PJ_LOG(5, (srtp->pool->obj_name, \"TX: %s key=%s\",\n                   ctx->tx_policy.name.ptr, b64));\n        if (ctx->tx_policy.flags) {\n            PJ_LOG(5,(srtp->pool->obj_name, \"TX: disable%s%s\",\n                      (cr_tx_idx?\"\":\" enc\"),\n                      (au_tx_idx?\"\":\" auth\")));\n        }\n\n        /* RX crypto and key */\n        b64_len = sizeof(b64);\n        status = pj_base64_encode((pj_uint8_t*)rx->key.ptr, (int)rx->key.slen,\n                                  b64, &b64_len);\n        if (status != PJ_SUCCESS)\n            b64_len = pj_ansi_snprintf(b64, sizeof(b64), \"--key too long--\");\n        else\n            b64[b64_len] = '\\0';\n\n        PJ_LOG(5, (srtp->pool->obj_name, \"RX: %s key=%s\",\n                   ctx->rx_policy.name.ptr, b64));\n        if (ctx->rx_policy.flags) {\n            PJ_LOG(5,(srtp->pool->obj_name,\"RX: disable%s%s\",\n                      (cr_rx_idx?\"\":\" enc\"),\n                      (au_rx_idx?\"\":\" auth\")));\n        }\n    }\n#endif\n\non_return:\n    pj_lock_release(srtp->mutex);\n    return status;\n}\n\n/*\n * Initialize and start SRTP session with the given parameters.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_start(\n                           pjmedia_transport *tp,\n                           const pjmedia_srtp_crypto *tx,\n                           const pjmedia_srtp_crypto *rx)\n{\n    transport_srtp  *srtp = (transport_srtp*) tp;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(tp && tx && rx, PJ_EINVAL);\n\n    pj_lock_acquire(srtp->mutex);\n\n    if (srtp->session_inited) {\n        pjmedia_transport_srtp_stop(tp);\n    }\n\n    status = create_srtp_ctx(srtp, &srtp->srtp_ctx, &srtp->setting, tx, rx);\n    if (status == PJ_SUCCESS) {\n        if (srtp->srtp_ctx.srtp_tx_ctx && srtp->srtp_ctx.srtp_rx_ctx) {\n            /* Declare SRTP session initialized */\n            srtp->session_inited = PJ_TRUE;\n        } else {\n            srtp->bypass_srtp = PJ_TRUE;\n        }\n    }\n\n    pj_lock_release(srtp->mutex);\n\n    return status;\n}\n\n/* Destroy SRTP context */\nstatic void destroy_srtp_ctx(transport_srtp *p_srtp, srtp_context *ctx)\n{\n    srtp_err_status_t err;\n\n    if (ctx->srtp_rx_ctx) {\n        err = srtp_dealloc(ctx->srtp_rx_ctx);\n        if (err != srtp_err_status_ok) {\n            PJ_LOG(4, (p_srtp->pool->obj_name,\n                       \"Failed to dealloc RX SRTP context: %s\",\n                       get_libsrtp_errstr(err)));\n        }\n    }\n    if (ctx->srtp_tx_ctx) {\n        err = srtp_dealloc(ctx->srtp_tx_ctx);\n        if (err != srtp_err_status_ok) {\n            PJ_LOG(4, (p_srtp->pool->obj_name,\n                       \"Failed to dealloc TX SRTP context: %s\",\n                       get_libsrtp_errstr(err)));\n        }\n    }\n    ctx->srtp_rx_ctx = NULL;\n    ctx->srtp_tx_ctx = NULL;\n\n    pj_bzero(&ctx->rx_policy, sizeof(ctx->rx_policy));\n    pj_bzero(&ctx->tx_policy, sizeof(ctx->tx_policy));\n}\n\n/*\n * Stop SRTP session.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_stop(pjmedia_transport *srtp)\n{\n    transport_srtp *p_srtp = (transport_srtp*) srtp;\n\n    PJ_ASSERT_RETURN(srtp, PJ_EINVAL);\n\n    pj_lock_acquire(p_srtp->mutex);\n\n    if (!p_srtp->session_inited) {\n        pj_lock_release(p_srtp->mutex);\n        return PJ_SUCCESS;\n    }\n\n    destroy_srtp_ctx(p_srtp, &p_srtp->srtp_ctx);\n    destroy_srtp_ctx(p_srtp, &p_srtp->srtp_rtcp);\n\n    p_srtp->session_inited = PJ_FALSE;\n\n    pj_lock_release(p_srtp->mutex);\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t start_srtp(transport_srtp *srtp)\n{\n    /* Make sure we have the SRTP policies */\n    if (srtp_crypto_empty(&srtp->srtp_ctx.tx_policy_neg) ||\n        srtp_crypto_empty(&srtp->srtp_ctx.rx_policy_neg))\n    {\n        srtp->bypass_srtp = PJ_TRUE;\n        srtp->peer_use = PJMEDIA_SRTP_DISABLED;\n        if (srtp->session_inited) {\n            pjmedia_transport_srtp_stop(&srtp->base);\n        }\n\n        PJ_LOG(4, (srtp->pool->obj_name, \"SRTP not active\"));\n        return PJ_SUCCESS;\n    }\n\n    /* Got policy_local & policy_remote, let's initalize the SRTP */\n\n    /* Ticket #1075: media_start() is called whenever media description\n     * gets updated, e.g: call hold, however we should restart SRTP only\n     * when the SRTP policy settings are updated.\n     */\n    if (srtp_crypto_cmp(&srtp->srtp_ctx.tx_policy_neg,\n                        &srtp->srtp_ctx.tx_policy) ||\n        srtp_crypto_cmp(&srtp->srtp_ctx.rx_policy_neg,\n                        &srtp->srtp_ctx.rx_policy))\n    {\n        pj_status_t status;\n        status = pjmedia_transport_srtp_start(&srtp->base,\n                                              &srtp->srtp_ctx.tx_policy_neg,\n                                              &srtp->srtp_ctx.rx_policy_neg);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        /* Reset probation counts */\n        srtp->probation_cnt = PROBATION_CNT_INIT;\n\n        PJ_LOG(4, (srtp->pool->obj_name,\n                   \"SRTP started, keying=%s, crypto=%s\",\n                   ((int)srtp->keying[0]->type==PJMEDIA_SRTP_KEYING_SDES?\n                    \"SDES\":\"DTLS-SRTP\"),\n                   srtp->srtp_ctx.tx_policy.name.ptr));\n    }\n\n    srtp->bypass_srtp = PJ_FALSE;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pjmedia_transport *) pjmedia_transport_srtp_get_member(\n                                                pjmedia_transport *tp)\n{\n    transport_srtp *srtp = (transport_srtp*) tp;\n\n    PJ_ASSERT_RETURN(tp, NULL);\n\n    return srtp->member_tp;\n}\n\n\nstatic pj_status_t transport_get_info(pjmedia_transport *tp,\n                                      pjmedia_transport_info *info)\n{\n    transport_srtp *srtp = (transport_srtp*) tp;\n    pjmedia_srtp_info srtp_info;\n    int spc_info_idx;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp && info, PJ_EINVAL);\n    PJ_ASSERT_RETURN(info->specific_info_cnt <\n                     PJMEDIA_TRANSPORT_SPECIFIC_INFO_MAXCNT, PJ_ETOOMANY);\n    PJ_ASSERT_RETURN(sizeof(pjmedia_srtp_info) <=\n                     PJMEDIA_TRANSPORT_SPECIFIC_INFO_MAXSIZE, PJ_ENOMEM);\n\n    srtp_info.active = srtp->session_inited;\n    srtp_info.rx_policy = srtp->srtp_ctx.rx_policy;\n    srtp_info.tx_policy = srtp->srtp_ctx.tx_policy;\n    srtp_info.use = srtp->setting.use;\n    srtp_info.peer_use = srtp->peer_use;\n\n    pj_bzero(&srtp_info.tx_roc, sizeof(srtp_info.tx_roc));\n    pj_bzero(&srtp_info.rx_roc, sizeof(srtp_info.rx_roc));\n\n    if (srtp->srtp_ctx.srtp_rx_ctx && srtp->rx_ssrc != 0) {\n        srtp_info.rx_roc.ssrc = srtp->rx_ssrc;\n        srtp_get_stream_roc(srtp->srtp_ctx.srtp_rx_ctx, srtp->rx_ssrc,\n                            &srtp_info.rx_roc.roc);\n    } else if (srtp->setting.rx_roc.ssrc != 0) {\n        srtp_info.rx_roc.ssrc = srtp->setting.rx_roc.ssrc;\n        srtp_info.rx_roc.roc = srtp->setting.rx_roc.roc;\n    }\n    if (srtp->srtp_ctx.srtp_tx_ctx && srtp->tx_ssrc != 0) {\n        srtp_info.tx_roc.ssrc = srtp->tx_ssrc;\n        srtp_get_stream_roc(srtp->srtp_ctx.srtp_tx_ctx, srtp->tx_ssrc,\n                            &srtp_info.tx_roc.roc);\n    } else if (srtp->setting.tx_roc.ssrc != 0) {\n        srtp_info.tx_roc.ssrc = srtp->setting.tx_roc.ssrc;\n        srtp_info.tx_roc.roc = srtp->setting.tx_roc.roc;\n    }\n\n    spc_info_idx = info->specific_info_cnt++;\n    info->spc_info[spc_info_idx].type = PJMEDIA_TRANSPORT_TYPE_SRTP;\n    info->spc_info[spc_info_idx].tp = tp;\n    info->spc_info[spc_info_idx].cbsize = sizeof(srtp_info);\n    pj_memcpy(&info->spc_info[spc_info_idx].buffer, &srtp_info,\n              sizeof(srtp_info));\n\n    /* Invoke get_info() from any active keying method */\n    for (i=0; i < srtp->keying_cnt; i++)\n        pjmedia_transport_get_info(srtp->keying[i], info);\n\n    return pjmedia_transport_get_info(srtp->member_tp, info);\n}\n\nstatic pj_status_t transport_attach2(pjmedia_transport *tp,\n                                     pjmedia_transport_attach_param *param)\n{\n    transport_srtp *srtp = (transport_srtp*) tp;\n    pjmedia_transport_attach_param member_param;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(tp && param, PJ_EINVAL);\n\n    /* Save the callbacks */\n    pj_lock_acquire(srtp->mutex);\n    if (param->rtp_cb || param->rtp_cb2) {\n        /* Do not update rtp_cb if not set, as attach() is called by\n         * keying method.\n         */\n        srtp->rtp_cb = param->rtp_cb;\n        srtp->rtp_cb2 = param->rtp_cb2;\n        srtp->rtcp_cb = param->rtcp_cb;\n        srtp->user_data = param->user_data;\n    }\n    pj_lock_release(srtp->mutex);\n\n    /* Attach self to member transport */\n    member_param = *param;\n    member_param.user_data = srtp;\n    member_param.rtp_cb = NULL;\n    member_param.rtp_cb2 = &srtp_rtp_cb;\n    member_param.rtcp_cb = &srtp_rtcp_cb;\n    status = pjmedia_transport_attach2(srtp->member_tp, &member_param);\n    if (status != PJ_SUCCESS) {\n        pj_lock_acquire(srtp->mutex);\n        srtp->rtp_cb = NULL;\n        srtp->rtcp_cb = NULL;\n        srtp->user_data = NULL;\n        pj_lock_release(srtp->mutex);\n        return status;\n    }\n\n    /* Check if we are multiplexing RTP & RTCP. */\n    srtp->use_rtcp_mux = (pj_sockaddr_has_addr(&param->rem_addr) &&\n                          pj_sockaddr_cmp(&param->rem_addr,\n                                          &param->rem_rtcp) == 0);\n    srtp->member_tp_attached = PJ_TRUE;\n    return PJ_SUCCESS;\n}\n\nstatic void transport_detach(pjmedia_transport *tp, void *strm)\n{\n    transport_srtp *srtp = (transport_srtp*) tp;\n\n    PJ_UNUSED_ARG(strm);\n    PJ_ASSERT_ON_FAIL(tp, return);\n\n    if (srtp->member_tp) {\n        pjmedia_transport_detach(srtp->member_tp, srtp);\n    }\n\n    /* Clear up application infos from transport */\n    pj_lock_acquire(srtp->mutex);\n    srtp->rtp_cb = NULL;\n    srtp->rtp_cb2 = NULL;\n    srtp->rtcp_cb = NULL;\n    srtp->user_data = NULL;\n    pj_lock_release(srtp->mutex);\n    srtp->member_tp_attached = PJ_FALSE;\n}\n\nstatic pj_status_t transport_send_rtp( pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size)\n{\n    pj_status_t status;\n    transport_srtp *srtp = (transport_srtp*) tp;\n    int len = (int)size;\n    srtp_err_status_t err;\n\n    if (srtp->bypass_srtp)\n        return pjmedia_transport_send_rtp(srtp->member_tp, pkt, size);\n\n    if (size > sizeof(srtp->rtp_tx_buffer) - MAX_TRAILER_LEN)\n        return PJ_ETOOBIG;\n\n    pj_memcpy(srtp->rtp_tx_buffer, pkt, size);\n\n    pj_lock_acquire(srtp->mutex);\n    if (!srtp->session_inited) {\n        pj_lock_release(srtp->mutex);\n        return PJMEDIA_SRTP_EKEYNOTREADY;\n    }\n\n    /* Save outgoing SSRC */\n    srtp->tx_ssrc = ntohl(((pjmedia_rtp_hdr*)pkt)->ssrc);\n\n#if TEST_ROC\n    if (srtp->setting.tx_roc.ssrc == 0) {\n        srtp_err_status_t status;\n        status = srtp_set_stream_roc(srtp->srtp_ctx.srtp_tx_ctx, srtp->tx_ssrc,\n                                     (srtp->offerer_side? 1: 2));\n        if (status == srtp_err_status_ok) {\n            srtp->setting.tx_roc.ssrc = srtp->tx_ssrc;\n            srtp->setting.tx_roc.roc = (srtp->offerer_side? 1: 2);\n            PJ_LOG(4, (THIS_FILE, \"Setting TX ROC to SSRC %d to %d\",\n                   srtp->tx_ssrc, srtp->setting.tx_roc.roc));\n        }\n    }\n#endif\n\n    err = srtp_protect(srtp->srtp_ctx.srtp_tx_ctx, srtp->rtp_tx_buffer, &len);\n    pj_lock_release(srtp->mutex);\n\n    if (err == srtp_err_status_ok) {\n        status = pjmedia_transport_send_rtp(srtp->member_tp,\n                                            srtp->rtp_tx_buffer, len);\n    } else {\n        status = PJMEDIA_ERRNO_FROM_LIBSRTP(err);\n    }\n\n    return status;\n}\n\nstatic pj_status_t transport_send_rtcp(pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size)\n{\n    return transport_send_rtcp2(tp, NULL, 0, pkt, size);\n}\n\nstatic pj_status_t transport_send_rtcp2(pjmedia_transport *tp,\n                                        const pj_sockaddr_t *addr,\n                                        unsigned addr_len,\n                                        const void *pkt,\n                                        pj_size_t size)\n{\n    pj_status_t status;\n    transport_srtp *srtp = (transport_srtp*) tp;\n    int len = (int)size;\n    srtp_err_status_t err;\n\n    if (srtp->bypass_srtp) {\n        return pjmedia_transport_send_rtcp2(srtp->member_tp, addr, addr_len,\n                                            pkt, size);\n    }\n\n    if (size > sizeof(srtp->rtcp_tx_buffer) - (MAX_TRAILER_LEN+4))\n        return PJ_ETOOBIG;\n\n    pj_memcpy(srtp->rtcp_tx_buffer, pkt, size);\n\n    pj_lock_acquire(srtp->mutex);\n    if (!srtp->session_inited) {\n        pj_lock_release(srtp->mutex);\n        return PJMEDIA_SRTP_EKEYNOTREADY;\n    }\n    err = srtp_protect_rtcp(srtp->srtp_rtcp.srtp_tx_ctx?\n                            srtp->srtp_rtcp.srtp_tx_ctx:\n                            srtp->srtp_ctx.srtp_tx_ctx,\n                            srtp->rtcp_tx_buffer, &len);\n    pj_lock_release(srtp->mutex);\n\n    if (err == srtp_err_status_ok) {\n        status = pjmedia_transport_send_rtcp2(srtp->member_tp, addr, addr_len,\n                                              srtp->rtcp_tx_buffer, len);\n    } else {\n        status = PJMEDIA_ERRNO_FROM_LIBSRTP(err);\n    }\n\n    return status;\n}\n\n\nstatic pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n                                           pjmedia_dir dir,\n                                           unsigned pct_lost)\n{\n    transport_srtp *srtp = (transport_srtp *) tp;\n\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    return pjmedia_transport_simulate_lost(srtp->member_tp, dir, pct_lost);\n}\n\n\n/* SRTP real destroy */\nstatic void srtp_on_destroy(void *arg)\n{\n    transport_srtp *srtp = (transport_srtp*)arg;\n\n    PJ_LOG(4, (srtp->pool->obj_name, \"SRTP transport destroyed\"));\n\n    pj_lock_destroy(srtp->mutex);\n    pj_pool_safe_release(&srtp->pool);\n}\n\n\nstatic pj_status_t transport_destroy  (pjmedia_transport *tp)\n{\n    transport_srtp *srtp = (transport_srtp *) tp;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    PJ_LOG(4, (srtp->pool->obj_name, \"Destroying SRTP transport\"));\n\n    /* Close all keying. Note that any keying should not be destroyed before\n     * SRTP transport is destroyed as re-INVITE may initiate new keying method\n     * without destroying SRTP transport.\n     */\n    for (i=0; i < srtp->all_keying_cnt; i++)\n        pjmedia_transport_close(srtp->all_keying[i]);\n\n    /* Close member if configured */\n    if (srtp->setting.close_member_tp && srtp->member_tp) {\n        pjmedia_transport_close(srtp->member_tp);\n    }\n\n    status = pjmedia_transport_srtp_stop(tp);\n\n    if (srtp->base.grp_lock) {\n        pj_grp_lock_dec_ref(srtp->base.grp_lock);\n    } else {\n        /* Only get here when the underlying transport does not have\n         * a group lock, race condition with callbacks may occur.\n         * Currently UDP, ICE, and loop have a group lock already.\n         */\n        PJ_LOG(4,(srtp->pool->obj_name,\n                  \"Warning: underlying transport does not have group lock\"));\n\n        /* In case mutex is being acquired by other thread.\n         * An effort to synchronize destroy() & callbacks when the underlying\n         * transport does not provide a group lock.\n         */\n        pj_lock_acquire(srtp->mutex);\n        pj_lock_release(srtp->mutex);\n\n        srtp_on_destroy(srtp);\n    }\n\n    return status;\n}\n\n/*\n * This callback is called by transport when incoming rtp is received\n */\nstatic void srtp_rtp_cb(pjmedia_tp_cb_param *param)\n{\n    transport_srtp *srtp = (transport_srtp *) param->user_data;\n    void *pkt = param->pkt;\n    pj_ssize_t size = param->size;\n    int len = (int)size;\n    srtp_err_status_t err;\n    void (*cb)(void*, void*, pj_ssize_t) = NULL;\n    void (*cb2)(pjmedia_tp_cb_param*) = NULL;\n    void *cb_data = NULL;\n\n    if (srtp->bypass_srtp) {\n        if (srtp->rtp_cb2) {\n            pjmedia_tp_cb_param param2 = *param;\n            param2.user_data = srtp->user_data;\n            srtp->rtp_cb2(&param2);\n            param->rem_switch = param2.rem_switch;\n        } else if (srtp->rtp_cb) {\n            srtp->rtp_cb(srtp->user_data, pkt, size);\n        }\n        return;\n    }\n\n    if (size < 0) {\n        return;\n    }\n\n    /* Give the packet to keying first by invoking its send_rtp() op.\n     * Yes, the usage of send_rtp() is rather hacky, but it is convenient\n     * as the signature suits the purpose and it is ready to use\n     * (no futher registration/setting needed), and it may never be used\n     * by any keying method in the future.\n     */\n    {\n        unsigned i;\n        pj_status_t status;\n        for (i=0; i < srtp->keying_cnt; i++) {\n            if (!srtp->keying[i]->op->send_rtp)\n                continue;\n            status = pjmedia_transport_send_rtp(srtp->keying[i], pkt, size);\n            if (status != PJ_EIGNORED) {\n                /* Packet is already consumed by the keying method */\n                return;\n            }\n        }\n    }\n\n    /* Make sure buffer is 32bit aligned */\n    PJ_ASSERT_ON_FAIL( (((pj_ssize_t)pkt) & 0x03)==0, return );\n\n    if (srtp->probation_cnt > 0)\n        --srtp->probation_cnt;\n\n    pj_lock_acquire(srtp->mutex);\n\n    if (!srtp->session_inited) {\n        pj_lock_release(srtp->mutex);\n        return;\n    }\n\n    /* Check if multiplexing is allowed and the payload indicates RTCP. */\n    if (srtp->use_rtcp_mux) {\n        pjmedia_rtp_hdr *hdr = (pjmedia_rtp_hdr *)pkt;\n  \n        if (hdr->pt >= 64 && hdr->pt <= 95) {   \n            pj_lock_release(srtp->mutex);\n            srtp_rtcp_cb(srtp, pkt, size);\n            return;\n        }\n    }\n\n#if TEST_ROC\n    if (srtp->setting.rx_roc.ssrc == 0) {\n        srtp_err_status_t status;\n        \n        srtp->rx_ssrc = ntohl(((pjmedia_rtp_hdr*)pkt)->ssrc);\n        status = srtp_set_stream_roc(srtp->srtp_ctx.srtp_rx_ctx, srtp->rx_ssrc,\n                                     (srtp->offerer_side? 2: 1));\n        if (status == srtp_err_status_ok) {     \n            srtp->setting.rx_roc.ssrc = srtp->rx_ssrc;\n            srtp->setting.rx_roc.roc = (srtp->offerer_side? 2: 1);\n\n            PJ_LOG(4, (THIS_FILE, \"Setting RX ROC from SSRC %d to %d\",\n                                  srtp->rx_ssrc, srtp->setting.rx_roc.roc));\n        } else {\n            PJ_LOG(4, (THIS_FILE, \"Setting RX ROC %s\",\n                       get_libsrtp_errstr(status)));\n        }\n    }\n#endif\n    \n    err = srtp_unprotect(srtp->srtp_ctx.srtp_rx_ctx, (pj_uint8_t*)pkt, &len);\n\n#if PJMEDIA_SRTP_CHECK_RTP_SEQ_ON_RESTART\n    if (srtp->probation_cnt > 0 &&\n        (err == srtp_err_status_replay_old ||\n         err == srtp_err_status_replay_fail))\n    {\n        /* Handle such condition that stream is updated (RTP seq is reinited\n         * & SRTP is restarted), but some old packets are still coming\n         * so SRTP is learning wrong RTP seq. While the newly inited RTP seq\n         * comes, SRTP thinks the RTP seq is replayed, so srtp_unprotect()\n         * will return err_status_replay_*. Restarting SRTP can resolve this.\n         */\n        pjmedia_srtp_crypto tx, rx;\n        pj_status_t status;\n\n        tx = srtp->srtp_ctx.tx_policy;\n        rx = srtp->srtp_ctx.rx_policy;\n\n        /* Stop SRTP first, otherwise srtp_start() will maintain current\n         * roll-over counter.\n         */\n        pjmedia_transport_srtp_stop((pjmedia_transport*)srtp);\n\n        status = pjmedia_transport_srtp_start((pjmedia_transport*)srtp,\n                                              &tx, &rx);\n        if (status != PJ_SUCCESS) {\n            PJ_LOG(5,(srtp->pool->obj_name, \"Failed to restart SRTP, err=%s\",\n                      get_libsrtp_errstr(err)));\n        } else if (!srtp->bypass_srtp) {\n            err = srtp_unprotect(srtp->srtp_ctx.srtp_rx_ctx,\n                                 (pj_uint8_t*)pkt, &len);\n        }\n    }\n#if PJMEDIA_SRTP_CHECK_ROC_ON_RESTART\n    else\n#endif\n#endif\n\n#if PJMEDIA_SRTP_CHECK_ROC_ON_RESTART\n    if (srtp->probation_cnt > 0 && err == srtp_err_status_auth_fail &&\n        srtp->setting.prev_rx_roc.ssrc != 0 &&\n        srtp->setting.prev_rx_roc.ssrc == srtp->setting.rx_roc.ssrc &&\n        srtp->setting.prev_rx_roc.roc != srtp->setting.rx_roc.roc)\n    {\n        unsigned roc, new_roc;\n        srtp_err_status_t status;\n\n        srtp_get_stream_roc(srtp->srtp_ctx.srtp_rx_ctx,\n                            srtp->setting.rx_roc.ssrc, &roc);\n        new_roc = (roc == srtp->setting.rx_roc.roc?\n                   srtp->setting.prev_rx_roc.roc: srtp->setting.rx_roc.roc);\n        status = srtp_set_stream_roc(srtp->srtp_ctx.srtp_rx_ctx,\n                                     srtp->setting.rx_roc.ssrc, new_roc);\n        if (status == srtp_err_status_ok) {\n            PJ_LOG(4, (srtp->pool->obj_name,\n                       \"Retrying to unprotect SRTP from ROC %d to new ROC %d\",\n                       roc, new_roc));\n            err = srtp_unprotect(srtp->srtp_ctx.srtp_rx_ctx, (pj_uint8_t*)pkt,\n                                 &len);\n        }\n    }\n#endif\n\n    if (err != srtp_err_status_ok) {\n        PJ_LOG(5,(srtp->pool->obj_name,\n                  \"Failed to unprotect SRTP, pkt size=%ld, err=%s\",\n                  size, get_libsrtp_errstr(err)));\n    } else {\n        cb = srtp->rtp_cb;\n        cb2 = srtp->rtp_cb2;\n        cb_data = srtp->user_data;\n\n        /* Save SSRC after successful SRTP unprotect */\n        srtp->rx_ssrc = ntohl(((pjmedia_rtp_hdr*)pkt)->ssrc);\n    }\n\n    pj_lock_release(srtp->mutex);\n\n    if (cb2) {\n        pjmedia_tp_cb_param param2 = *param;\n        param2.user_data = cb_data;\n        param2.pkt = pkt;\n        param2.size = len;\n        (*cb2)(&param2);\n        param->rem_switch = param2.rem_switch;\n    } else if (cb) {\n        (*cb)(cb_data, pkt, len);\n    }\n}\n\n/*\n * This callback is called by transport when incoming rtcp is received\n */\nstatic void srtp_rtcp_cb( void *user_data, void *pkt, pj_ssize_t size)\n{\n    transport_srtp *srtp = (transport_srtp *) user_data;\n    int len = (int)size;\n    srtp_err_status_t err;\n    void (*cb)(void*, void*, pj_ssize_t) = NULL;\n    void *cb_data = NULL;\n\n    if (srtp->bypass_srtp) {\n        srtp->rtcp_cb(srtp->user_data, pkt, size);\n        return;\n    }\n\n    if (size < 0) {\n        return;\n    }\n\n    /* Give the packet to keying first by invoking its send_rtcp() op,\n     * in the same way as for RTP packet above.\n     */\n    {\n        unsigned i;\n        pj_status_t status;\n        for (i=0; i < srtp->keying_cnt; i++) {\n            if (!srtp->keying[i]->op->send_rtcp)\n                continue;\n            status = pjmedia_transport_send_rtcp(srtp->keying[i], pkt, size);\n            if (status != PJ_EIGNORED) {\n                /* Packet is already consumed by the keying method */\n                return;\n            }\n        }\n    }\n\n    /* Make sure buffer is 32bit aligned */\n    PJ_ASSERT_ON_FAIL( (((pj_ssize_t)pkt) & 0x03)==0, return );\n\n    pj_lock_acquire(srtp->mutex);\n\n    if (!srtp->session_inited) {\n        pj_lock_release(srtp->mutex);\n        return;\n    }\n    err = srtp_unprotect_rtcp(srtp->srtp_rtcp.srtp_rx_ctx?\n                              srtp->srtp_rtcp.srtp_rx_ctx:\n                              srtp->srtp_ctx.srtp_rx_ctx,\n                              (pj_uint8_t*)pkt, &len);\n    if (err != srtp_err_status_ok) {\n        PJ_LOG(5,(srtp->pool->obj_name,\n                  \"Failed to unprotect SRTCP, pkt size=%ld, err=%s\",\n                  size, get_libsrtp_errstr(err)));\n    } else {\n        cb = srtp->rtcp_cb;\n        cb_data = srtp->user_data;\n    }\n\n    pj_lock_release(srtp->mutex);\n\n    if (cb) {\n        (*cb)(cb_data, pkt, len);\n    }\n}\n\n\nstatic pj_status_t transport_media_create(pjmedia_transport *tp,\n                                          pj_pool_t *sdp_pool,\n                                          unsigned options,\n                                          const pjmedia_sdp_session *sdp_remote,\n                                          unsigned media_index)\n{\n    struct transport_srtp *srtp = (struct transport_srtp*) tp;\n    unsigned member_tp_option;\n    pj_status_t keying_status = PJ_SUCCESS;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    pj_bzero(&srtp->srtp_ctx.rx_policy_neg,\n             sizeof(srtp->srtp_ctx.rx_policy_neg));\n    pj_bzero(&srtp->srtp_ctx.tx_policy_neg,\n             sizeof(srtp->srtp_ctx.tx_policy_neg));\n\n    srtp->tx_ssrc = srtp->rx_ssrc = 0;\n    srtp->media_option = member_tp_option = options;\n    srtp->offerer_side = (sdp_remote == NULL);\n\n    if (srtp->offerer_side && srtp->setting.use == PJMEDIA_SRTP_DISABLED) {\n        /* If we are offerer and SRTP is disabled, simply bypass SRTP and\n         * skip keying.\n         */\n        srtp->bypass_srtp = PJ_TRUE;\n        srtp->keying_cnt = 0;\n    } else {\n        /* If we are answerer and SRTP is disabled, we need to verify that\n         * SRTP is disabled too in remote SDP, so we can't just skip keying.\n         */\n        srtp->bypass_srtp = PJ_FALSE;\n        srtp->keying_cnt = srtp->all_keying_cnt;\n        for (i = 0; i < srtp->all_keying_cnt; ++i)\n            srtp->keying[i] = srtp->all_keying[i];\n\n        member_tp_option |= PJMEDIA_TPMED_NO_TRANSPORT_CHECKING;\n    }\n\n    status = pjmedia_transport_media_create(srtp->member_tp, sdp_pool,\n                                            member_tp_option, sdp_remote,\n                                            media_index);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Invoke media_create() of all keying methods, keying actions for each\n     * SRTP mode:\n     * - DISABLED:\n     *   - as offerer, nothing (keying is skipped).\n     *   - as answerer, verify remote SDP, make sure it has SRTP disabled too,\n     *     if not, return error.\n     * - OPTIONAL:\n     *   - as offerer, general initialization.\n     *   - as answerer, optionally verify SRTP attr in remote SDP (if any).\n     * - MANDATORY:\n     *   - as offerer, general initialization.\n     *   - as answerer, verify SRTP attr in remote SDP.\n     */\n    for (i=0; i < srtp->keying_cnt; ) {\n        pj_status_t st;\n        st = pjmedia_transport_media_create(srtp->keying[i], sdp_pool,\n                                            options, sdp_remote,\n                                            media_index);\n        if (st != PJ_SUCCESS) {\n            /* This keying method returns error, remove it */\n            pj_array_erase(srtp->keying, sizeof(srtp->keying[0]),\n                           srtp->keying_cnt, i);\n            srtp->keying_cnt--;\n            keying_status = st;\n            continue;\n        } else if (srtp->offerer_side) {\n            /* Currently we can send one keying only in outgoing offer */\n            srtp->keying[0] = srtp->keying[i];\n            srtp->keying_cnt = 1;\n            break;\n        }\n\n        ++i;\n    }\n\n    /* All keying method failed to process remote SDP? */\n    if (srtp->keying_cnt == 0)\n        return keying_status;\n\n    /* Bypass SRTP & skip keying as SRTP is disabled and verification on\n     * remote SDP has been done.\n     */\n    if (srtp->setting.use == PJMEDIA_SRTP_DISABLED) {\n        srtp->bypass_srtp = PJ_TRUE;\n        srtp->keying_cnt = 0;\n    }\n\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t transport_encode_sdp(pjmedia_transport *tp,\n                                        pj_pool_t *sdp_pool,\n                                        pjmedia_sdp_session *sdp_local,\n                                        const pjmedia_sdp_session *sdp_remote,\n                                        unsigned media_index)\n{\n    struct transport_srtp *srtp = (struct transport_srtp*) tp;\n    pj_status_t keying_status = PJ_SUCCESS;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp && sdp_pool && sdp_local, PJ_EINVAL);\n\n    pj_bzero(&srtp->srtp_ctx.rx_policy_neg,\n             sizeof(srtp->srtp_ctx.rx_policy_neg));\n    pj_bzero(&srtp->srtp_ctx.tx_policy_neg,\n             sizeof(srtp->srtp_ctx.tx_policy_neg));\n\n    srtp->offerer_side = (sdp_remote == NULL);\n\n    if (!srtp->offerer_side && srtp->started) {\n        /* This is may be incoming reoffer that may change keying */\n        srtp->keying_cnt = srtp->all_keying_cnt;\n        for (i = 0; i < srtp->all_keying_cnt; ++i)\n            srtp->keying[i] = srtp->all_keying[i];\n    }\n\n    status = pjmedia_transport_encode_sdp(srtp->member_tp, sdp_pool,\n                                          sdp_local, sdp_remote, media_index);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Invoke encode_sdp() of all keying methods, keying actions for each\n     * SRTP mode:\n     * - DISABLED: nothing (keying is skipped)\n     * - OPTIONAL:\n     *   - as offerer, generate offer.\n     *   - as answerer, if remote has the same SRTP keying in SDP, verify it,\n     *     generate answer, start crypto nego.\n     * - MANDATORY:\n     *   - as offerer, generate offer.\n     *   - as answerer, verify remote SDP, generate answer, start crypto nego.\n     *\n     * Note: because the SDP will be processed by other keying/components,\n     *       keying must do verification on remote SDP first (e.g: keying\n     *       is being used) before touching local SDP.\n     */\n    for (i=0; i < srtp->keying_cnt; ) {\n        pj_status_t st;\n        st = pjmedia_transport_encode_sdp(srtp->keying[i], sdp_pool,\n                                          sdp_local, sdp_remote,\n                                          media_index);\n        if (st != PJ_SUCCESS) {\n            /* This keying method returns error, remove it */\n            pj_array_erase(srtp->keying, sizeof(srtp->keying[0]),\n                           srtp->keying_cnt, i);\n            srtp->keying_cnt--;\n            keying_status = st;\n            continue;\n        } else if (!srtp->offerer_side) {\n            /* Answer with one keying only */\n            srtp->keying[0] = srtp->keying[i];\n            srtp->keying_cnt = 1;\n            break;\n        }\n\n        i++;\n    }\n\n    /* All keying method failed to process remote SDP? */\n    if (srtp->keying_cnt == 0) {\n        if (keying_status != PJ_SUCCESS) {\n            DEACTIVATE_MEDIA(sdp_pool, sdp_local->media[media_index]);\n        }\n        return keying_status;\n    }\n\n    /* Bypass SRTP & skip keying as SRTP is disabled and verification on\n     * remote SDP has been done.\n     */\n    if (srtp->setting.use == PJMEDIA_SRTP_DISABLED) {\n        srtp->bypass_srtp = PJ_TRUE;\n        srtp->keying_cnt = 0;\n    }\n\n    if (srtp->keying_cnt != 0) {\n        /* At this point for now, keying count should be 1 */\n        pj_assert(srtp->keying_cnt == 1);\n        PJ_LOG(4, (srtp->pool->obj_name, \"SRTP uses keying method %s\",\n                   ((int)srtp->keying[0]->type==PJMEDIA_SRTP_KEYING_SDES?\n                    \"SDES\":\"DTLS-SRTP\")));\n    }\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t transport_media_start(pjmedia_transport *tp,\n                                         pj_pool_t *pool,\n                                         const pjmedia_sdp_session *sdp_local,\n                                         const pjmedia_sdp_session *sdp_remote,\n                                         unsigned media_index)\n{\n    struct transport_srtp *srtp = (struct transport_srtp*) tp;\n    pj_status_t keying_status = PJ_SUCCESS;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    /* At this point for now, keying count should be 0 or 1 */\n    pj_assert(srtp->keying_cnt <= 1);\n\n    srtp->started = PJ_TRUE;\n\n    status = pjmedia_transport_media_start(srtp->member_tp, pool,\n                                           sdp_local, sdp_remote,\n                                           media_index);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Invoke media_start() of all keying methods, keying actions for each\n     * SRTP mode:\n     * - DISABLED: nothing (keying is skipped)\n     * - OPTIONAL:\n     *   - as offerer, if remote answer has the same SRTP keying in SDP,\n     *     verify it and start crypto nego.\n     *   - as answerer, start crypto nego if not yet (usually initated in\n     *     encode_sdp()).\n     * - MANDATORY:\n     *   - as offerer, verify remote answer and start crypto nego.\n     *   - as answerer, start crypto nego if not yet (usually initated in\n     *     encode_sdp()).\n     */\n    for (i=0; i < srtp->keying_cnt; ) {\n        status = pjmedia_transport_media_start(srtp->keying[i], pool,\n                                               sdp_local, sdp_remote,\n                                               media_index);\n        if (status != PJ_SUCCESS) {\n            /* This keying method returns error, remove it */\n            pj_array_erase(srtp->keying, sizeof(srtp->keying[0]),\n                           srtp->keying_cnt, i);\n            srtp->keying_cnt--;\n            keying_status = status;\n            continue;\n        }\n\n        if (!srtp_crypto_empty(&srtp->srtp_ctx.tx_policy_neg) &&\n            !srtp_crypto_empty(&srtp->srtp_ctx.rx_policy_neg))\n        {\n            /* SRTP nego is done */\n            srtp->keying_cnt = 1;\n            srtp->keying[0] = srtp->keying[i];\n            srtp->keying_pending_cnt = 0;\n            break;\n        }\n\n        i++;\n    }\n\n    /* All keying method failed to process remote SDP? */\n    if (srtp->keying_cnt == 0)\n        return keying_status;\n\n    /* If SRTP key is being negotiated, just return now.\n     * The keying method should start the SRTP once keying nego is done.\n     */\n    if (srtp->keying_pending_cnt)\n        return PJ_SUCCESS;\n\n    /* Start SRTP */\n    status = start_srtp(srtp);\n\n    return status;\n}\n\n\nstatic pj_status_t transport_media_stop(pjmedia_transport *tp)\n{\n    struct transport_srtp *srtp = (struct transport_srtp*) tp;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    srtp->started = PJ_FALSE;\n\n    /* Invoke media_stop() of all keying methods */\n    for (i=0; i < srtp->keying_cnt; ++i) {\n        pjmedia_transport_media_stop(srtp->keying[i]);\n    }\n\n    /* Invoke media_stop() of member tp */\n    status = pjmedia_transport_media_stop(srtp->member_tp);\n    if (status != PJ_SUCCESS)\n        PJ_PERROR(4, (srtp->pool->obj_name, status,\n                      \"SRTP failed stop underlying media transport.\"));\n\n    /* Finally, stop SRTP */\n    return pjmedia_transport_srtp_stop(tp);\n}\n\n\n/* Utility */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_decrypt_pkt(pjmedia_transport *tp,\n                                                       pj_bool_t is_rtp,\n                                                       void *pkt,\n                                                       int *pkt_len)\n{\n    transport_srtp *srtp = (transport_srtp *)tp;\n    srtp_err_status_t err;\n\n    if (srtp->bypass_srtp)\n        return PJ_SUCCESS;\n\n    PJ_ASSERT_RETURN(tp && pkt && (*pkt_len>0), PJ_EINVAL);\n    PJ_ASSERT_RETURN(srtp->session_inited, PJ_EINVALIDOP);\n\n    /* Make sure buffer is 32bit aligned */\n    PJ_ASSERT_ON_FAIL( (((pj_ssize_t)pkt) & 0x03)==0, return PJ_EINVAL);\n\n    pj_lock_acquire(srtp->mutex);\n\n    if (!srtp->session_inited) {\n        pj_lock_release(srtp->mutex);\n        return PJ_EINVALIDOP;\n    }\n\n    if (is_rtp)\n        err = srtp_unprotect(srtp->srtp_ctx.srtp_rx_ctx, pkt, pkt_len);\n    else\n        err = srtp_unprotect_rtcp(srtp->srtp_ctx.srtp_rx_ctx, pkt, pkt_len);\n\n    if (err != srtp_err_status_ok) {\n        PJ_LOG(5,(srtp->pool->obj_name,\n                  \"Failed to unprotect SRTP, pkt size=%d, err=%s\",\n                  *pkt_len, get_libsrtp_errstr(err)));\n    }\n\n    pj_lock_release(srtp->mutex);\n\n    return (err==srtp_err_status_ok) ? PJ_SUCCESS :\n                                       PJMEDIA_ERRNO_FROM_LIBSRTP(err);\n}\n\n#endif\n", "/*\n * Copyright (C) 2017 Teluu Inc. (http://www.teluu.com)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n */\n\n#include <pjmedia/clock.h>\n#include <pjmedia/sdp.h>\n#include <pjmedia/transport_ice.h>\n#include <pj/errno.h>\n#include <pj/rand.h>\n#include <pj/ssl_sock.h>\n\n/* \n * Include OpenSSL headers\n */\n#include <openssl/bn.h>\n#include <openssl/err.h>\n#include <openssl/rsa.h>\n#include <openssl/ssl.h>\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    defined(OPENSSL_API_COMPAT) && OPENSSL_API_COMPAT >= 0x10100000L\n#  define X509_get_notBefore(x)     X509_getm_notBefore(x)\n#  define X509_get_notAfter(x)      X509_getm_notAfter(x)\n#endif\n\n/* Set to 1 to enable DTLS-SRTP debugging */\n#define DTLS_DEBUG  0\n\n#define NUM_CHANNEL 2\n\nenum {\n    RTP_CHANNEL = 0,\n    RTCP_CHANNEL = 1\n};\n\n#define CHANNEL_TO_STRING(idx) (idx == RTP_CHANNEL? \"RTP channel\": \\\n                                \"RTCP channel\")\n\n/* DTLS-SRTP transport op */\nstatic pj_status_t dtls_media_create  (pjmedia_transport *tp,\n                                       pj_pool_t *sdp_pool,\n                                       unsigned options,\n                                       const pjmedia_sdp_session *sdp_remote,\n                                       unsigned media_index);\nstatic pj_status_t dtls_encode_sdp    (pjmedia_transport *tp,\n                                       pj_pool_t *sdp_pool,\n                                       pjmedia_sdp_session *sdp_local,\n                                       const pjmedia_sdp_session *sdp_remote,\n                                       unsigned media_index);\nstatic pj_status_t dtls_media_start   (pjmedia_transport *tp,\n                                       pj_pool_t *tmp_pool,\n                                       const pjmedia_sdp_session *sdp_local,\n                                       const pjmedia_sdp_session *sdp_remote,\n                                       unsigned media_index);\nstatic pj_status_t dtls_media_stop    (pjmedia_transport *tp);\nstatic pj_status_t dtls_destroy       (pjmedia_transport *tp);\nstatic pj_status_t dtls_on_recv_rtp   (pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t dtls_on_recv_rtcp  (pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size);\n\nstatic void on_ice_complete2(pjmedia_transport *tp,\n                             pj_ice_strans_op op,\n                             pj_status_t status,\n                             void *user_data);\n\nstatic void dtls_on_destroy(void *arg);\n\n\nstatic pjmedia_transport_op dtls_op =\n{\n    NULL,\n    NULL,\n    NULL,\n    &dtls_on_recv_rtp,      // originally send_rtp()\n    &dtls_on_recv_rtcp,     // originally send_rtcp()\n    NULL,\n    &dtls_media_create,\n    &dtls_encode_sdp,\n    &dtls_media_start,\n    &dtls_media_stop,\n    NULL,\n    &dtls_destroy,\n    NULL,\n};\n\n\ntypedef enum dtls_setup\n{ \n    DTLS_SETUP_UNKNOWN,\n    DTLS_SETUP_ACTPASS,\n    DTLS_SETUP_ACTIVE,\n    DTLS_SETUP_PASSIVE\n} dtls_setup;\n\ntypedef struct dtls_srtp dtls_srtp;\n\ntypedef struct dtls_srtp_channel\n{\n    dtls_srtp           *dtls_srtp;\n    unsigned             channel;\n} dtls_srtp_channel;\n\ntypedef struct dtls_srtp\n{\n    pjmedia_transport    base;\n    pj_pool_t           *pool;\n    transport_srtp      *srtp;\n\n    dtls_setup           setup;\n    unsigned long        last_err;\n    pj_bool_t            use_ice;\n    dtls_srtp_channel    channel[NUM_CHANNEL];\n    pj_bool_t            nego_started[NUM_CHANNEL];\n    pj_bool_t            nego_completed[NUM_CHANNEL];\n    pj_str_t             rem_fingerprint;   /* Remote fingerprint in SDP    */\n    pj_status_t          rem_fprint_status; /* Fingerprint verif. status    */\n    pj_sockaddr          rem_addr;          /* Remote address (from SDP/RTP)*/\n    pj_sockaddr          rem_rtcp;          /* Remote RTCP address (SDP)    */\n    pj_bool_t            pending_start;     /* media_start() invoked but DTLS\n                                               nego not done yet, so start\n                                               the SRTP once the nego done  */\n    pj_bool_t            is_destroying;     /* DTLS being destroyed?        */\n    pj_bool_t            got_keys;          /* DTLS nego done & keys ready  */\n    pjmedia_srtp_crypto  tx_crypto[NUM_CHANNEL];\n    pjmedia_srtp_crypto  rx_crypto[NUM_CHANNEL];\n\n    char                 buf[NUM_CHANNEL][PJMEDIA_MAX_MTU];\n    pjmedia_clock       *clock[NUM_CHANNEL];/* Timer workaround for retrans */\n\n    SSL_CTX             *ossl_ctx[NUM_CHANNEL];\n    SSL                 *ossl_ssl[NUM_CHANNEL];\n    BIO                 *ossl_rbio[NUM_CHANNEL];\n    BIO                 *ossl_wbio[NUM_CHANNEL];\n    pj_lock_t           *ossl_lock;\n} dtls_srtp;\n\n\nstatic const pj_str_t ID_TP_DTLS_SRTP = { \"UDP/TLS/RTP/SAVP\", 16 };\nstatic const pj_str_t ID_SETUP        = { \"setup\", 5 };\nstatic const pj_str_t ID_ACTPASS      = { \"actpass\", 7 };\nstatic const pj_str_t ID_ACTIVE       = { \"active\", 6 };\nstatic const pj_str_t ID_PASSIVE      = { \"passive\", 7 };\nstatic const pj_str_t ID_FINGERPRINT  = { \"fingerprint\", 11 };\n\n/* Map of OpenSSL-pjmedia SRTP cryptos. Currently OpenSSL seems to\n * support few cryptos only (based on ssl/d1_srtp.c of OpenSSL 1.1.0c).\n */\n#define OPENSSL_PROFILE_NUM 4\n\nstatic char* ossl_profiles[OPENSSL_PROFILE_NUM] =\n{\n     \"SRTP_AES128_CM_SHA1_80\",\n     \"SRTP_AES128_CM_SHA1_32\",\n     \"SRTP_AEAD_AES_256_GCM\",\n     \"SRTP_AEAD_AES_128_GCM\"\n};\nstatic char* pj_profiles[OPENSSL_PROFILE_NUM] =\n{\n    \"AES_CM_128_HMAC_SHA1_80\",\n    \"AES_CM_128_HMAC_SHA1_32\",\n    \"AEAD_AES_256_GCM\",\n    \"AEAD_AES_128_GCM\"\n};\n\n/* This will store the valid OpenSSL profiles which is mapped from \n * OpenSSL-pjmedia SRTP cryptos.\n */\nstatic char *valid_pj_profiles_list[OPENSSL_PROFILE_NUM];\nstatic char *valid_ossl_profiles_list[OPENSSL_PROFILE_NUM];\nstatic unsigned valid_profiles_cnt;\n\n\n/* Certificate & private key */\nstatic X509     *dtls_cert;\nstatic EVP_PKEY *dtls_priv_key;\nstatic pj_status_t ssl_generate_cert(X509 **p_cert, EVP_PKEY **p_priv_key);\n\nstatic pj_status_t dtls_init()\n{\n    /* Make sure OpenSSL library has been initialized */\n    {\n        pj_ssl_cipher ciphers[1];\n        unsigned cipher_num = 1;\n        pj_ssl_cipher_get_availables(ciphers, &cipher_num);\n    }\n\n    /* Generate cert if not yet */\n    if (!dtls_cert) {\n        pj_status_t status;\n        status = ssl_generate_cert(&dtls_cert, &dtls_priv_key);\n        if (status != PJ_SUCCESS) {\n            pj_perror(4, \"DTLS-SRTP\", status,\n                      \"Failed generating DTLS certificate\");\n            return status;\n        }\n    }\n\n    if (valid_profiles_cnt == 0) {\n        unsigned n, j;\n        int rc;\n        char *p, *end, buf[OPENSSL_PROFILE_NUM*25];\n\n        /* Create DTLS context */\n        SSL_CTX *ctx = SSL_CTX_new(DTLS_method());\n        if (ctx == NULL) {\n            return PJ_ENOMEM;\n        }\n\n        p = buf;\n        end = buf + sizeof(buf);\n        for (j=0; j<PJ_ARRAY_SIZE(ossl_profiles); ++j) {\n            rc = SSL_CTX_set_tlsext_use_srtp(ctx, ossl_profiles[j]);\n            if (rc == 0) {\n                valid_pj_profiles_list[valid_profiles_cnt] =\n                    pj_profiles[j];\n                valid_ossl_profiles_list[valid_profiles_cnt++] =\n                    ossl_profiles[j];\n\n                n = pj_ansi_snprintf(p, end - p, \":%s\", pj_profiles[j]);\n                p += n;\n            }\n        }\n        SSL_CTX_free(ctx);\n\n        if (valid_profiles_cnt > 0) {\n            PJ_LOG(4,(\"DTLS-SRTP\", \"%s profile is supported\", buf));\n        } else {\n            PJ_PERROR(4, (\"DTLS-SRTP\", PJMEDIA_SRTP_DTLS_ENOPROFILE,\n                          \"Error getting SRTP profile\"));\n\n            return PJMEDIA_SRTP_DTLS_ENOPROFILE;\n        }\n    }\n\n    return PJ_SUCCESS;\n}\n\nstatic void dtls_deinit()\n{\n    if (dtls_cert) {\n        X509_free(dtls_cert);\n        dtls_cert = NULL;\n\n        EVP_PKEY_free(dtls_priv_key);\n        dtls_priv_key = NULL;\n    }\n\n    valid_profiles_cnt = 0;\n}\n\n\n/* Create DTLS-SRTP keying instance */\nstatic pj_status_t dtls_create(transport_srtp *srtp,\n                               pjmedia_transport **p_keying)\n{\n    dtls_srtp *ds;\n    pj_pool_t *pool;\n    pj_status_t status;\n\n    pool = pj_pool_create(srtp->pool->factory, \"dtls%p\",\n                          2000, 256, NULL);\n    ds = PJ_POOL_ZALLOC_T(pool, dtls_srtp);\n    ds->pool = pool;\n\n    pj_ansi_strxcpy(ds->base.name, pool->obj_name, PJ_MAX_OBJ_NAME);\n    ds->base.type = (pjmedia_transport_type)PJMEDIA_SRTP_KEYING_DTLS_SRTP;\n    ds->base.op = &dtls_op;\n    ds->base.user_data = srtp;\n    ds->srtp = srtp;\n\n    /* Setup group lock handler for destroy and callback synchronization */\n    if (srtp->base.grp_lock) {\n        pj_grp_lock_t *grp_lock = srtp->base.grp_lock;\n\n        ds->base.grp_lock = grp_lock;\n        pj_grp_lock_add_ref(grp_lock);\n        pj_grp_lock_add_handler(grp_lock, pool, ds, &dtls_on_destroy);\n    } else {\n        status = pj_lock_create_simple_mutex(ds->pool, \"dtls_ssl_lock%p\",\n                                             &ds->ossl_lock);\n        if (status != PJ_SUCCESS)\n            return status;\n    }\n\n    *p_keying = &ds->base;\n    PJ_LOG(5,(srtp->pool->obj_name, \"SRTP keying DTLS-SRTP created\"));\n    return PJ_SUCCESS;\n}\n\n\n/* Lock/unlock for DTLS states access protection */\n\nstatic void DTLS_LOCK(dtls_srtp *ds) {\n    if (ds->base.grp_lock)\n        pj_grp_lock_acquire(ds->base.grp_lock);\n    else\n        pj_lock_acquire(ds->ossl_lock);\n}\n\n\nstatic void DTLS_UNLOCK(dtls_srtp *ds) {\n    if (ds->base.grp_lock)\n        pj_grp_lock_release(ds->base.grp_lock);\n    else\n        pj_lock_release(ds->ossl_lock);\n}\n\n\n/**\n * Mapping from OpenSSL error codes to pjlib error space.\n */\n#define PJ_SSL_ERRNO_START              (PJ_ERRNO_START_USER + \\\n                                         PJ_ERRNO_SPACE_SIZE*6)\n\n#define PJ_SSL_ERRNO_SPACE_SIZE         PJ_ERRNO_SPACE_SIZE\n\n/* Expected maximum value of reason component in OpenSSL error code */\n#define MAX_OSSL_ERR_REASON             1200\n\nstatic pj_status_t STATUS_FROM_SSL_ERR(dtls_srtp *ds,\n                                       unsigned long err)\n{\n    pj_status_t status;\n\n    /* General SSL error, dig more from OpenSSL error queue */\n    if (err == SSL_ERROR_SSL)\n        err = ERR_get_error();\n\n    /* OpenSSL error range is much wider than PJLIB errno space, so\n     * if it exceeds the space, only the error reason will be kept.\n     * Note that the last native error will be kept as is and can be\n     * retrieved via SSL socket info.\n     */\n    status = ERR_GET_LIB(err)*MAX_OSSL_ERR_REASON + ERR_GET_REASON(err);\n    if (status > PJ_SSL_ERRNO_SPACE_SIZE)\n        status = ERR_GET_REASON(err);\n\n    if (status != PJ_SUCCESS)\n        status += PJ_SSL_ERRNO_START;\n\n    ds->last_err = err;\n    return status;\n}\n\n\nstatic pj_status_t GET_SSL_STATUS(dtls_srtp *ds)\n{\n    return STATUS_FROM_SSL_ERR(ds, ERR_get_error());\n}\n\n\n/* SSL cert verification callback. */\nstatic int verify_cb(int preverify_ok, X509_STORE_CTX *x509_ctx)\n{\n    PJ_UNUSED_ARG(preverify_ok);\n    PJ_UNUSED_ARG(x509_ctx);\n    /* Just skip it for now (as usually it's a self-signed cert) */\n    return 1;\n}\n\n/* Get fingerprint from TLS cert, output is formatted for SDP a=fingerprint,\n * e.g: \"SHA-256 XX:XX:XX...\". If is_sha256 is true, SHA-256 hash algo will\n * be used, otherwise it is SHA-1.\n */\nstatic pj_status_t ssl_get_fingerprint(X509 *cert, pj_bool_t is_sha256,\n                                       char *buf, pj_size_t *buf_len)\n{\n    unsigned int len, st_out_len, i;\n    unsigned char tmp[EVP_MAX_MD_SIZE];\n    char *p, *end=buf+*buf_len;\n\n    if (!X509_digest(cert, (is_sha256?EVP_sha256():EVP_sha1()), tmp, &len))\n        return PJ_EUNKNOWN;\n\n    st_out_len =  len*3 + (is_sha256? 7 : 5);\n    if (*buf_len < st_out_len + 1)\n        return PJ_ETOOSMALL;\n\n    /* Format fingerprint to \"SHA-256 XX:XX:XX...\" */\n    p = buf;\n    p += pj_ansi_snprintf(p, end-p, \"SHA-%s %.2X\", \n                          (is_sha256?\"256\":\"1\"), tmp[0]);\n    for (i=1; i<len; ++i)\n        p += pj_ansi_snprintf(p, end-p, \":%.2X\", tmp[i]);\n\n    *buf_len = st_out_len;\n\n    return PJ_SUCCESS;\n}\n\n/* Generate self-signed cert */\nstatic pj_status_t ssl_generate_cert(X509 **p_cert, EVP_PKEY **p_priv_key)\n{\n    BIGNUM *bne = NULL;\n    RSA *rsa_key = NULL;\n    X509_NAME *cert_name = NULL;\n    X509 *cert = NULL;\n    EVP_PKEY *priv_key = NULL;\n\n    /* Create big number */\n    bne = BN_new();\n    if (!bne) goto on_error;\n    if (!BN_set_word(bne, RSA_F4)) goto on_error;\n\n    /* Generate RSA key */\n    rsa_key = RSA_new();\n    if (!rsa_key) goto on_error;\n    if (!RSA_generate_key_ex(rsa_key, 2048, bne, NULL)) goto on_error;\n\n    /* Create private key */\n    priv_key = EVP_PKEY_new();\n    if (!priv_key) goto on_error;\n    if (!EVP_PKEY_assign_RSA(priv_key, rsa_key)) goto on_error;\n    rsa_key = NULL;\n\n    /* Create certificate */\n    cert = X509_new();\n    if (!cert) goto on_error;\n\n    /* Set version to 3 (2 = x509v3) */\n    X509_set_version(cert, 2);\n\n    /* Set serial number */\n    ASN1_INTEGER_set(X509_get_serialNumber(cert), pj_rand());\n\n    /* Set valid period */\n    X509_gmtime_adj(X509_get_notBefore(cert), -60*60*24);\n    X509_gmtime_adj(X509_get_notAfter(cert), 60*60*24*365);\n\n    /* Set subject name */\n    cert_name = X509_get_subject_name(cert);\n    if (!cert_name) goto on_error;\n    if (!X509_NAME_add_entry_by_txt(cert_name, \"CN\", MBSTRING_ASC,\n                                    (const unsigned char*)\"pjmedia.pjsip.org\",\n                                    -1, -1, 0)) goto on_error;\n\n    /* Set the issuer name (to subject name as this is self-signed cert) */\n    if (!X509_set_issuer_name(cert, cert_name)) goto on_error;\n\n    /* Set the public key */\n    if (!X509_set_pubkey(cert, priv_key)) goto on_error;\n\n    /* Sign with the private key */\n    if (!X509_sign(cert, priv_key, EVP_sha1())) goto on_error;\n\n    /* Free big number */\n    BN_free(bne);\n\n    *p_cert = cert;\n    *p_priv_key = priv_key;\n    return PJ_SUCCESS;\n\non_error:\n    if (bne) BN_free(bne);\n    if (rsa_key && !priv_key) RSA_free(rsa_key);\n    if (priv_key) EVP_PKEY_free(priv_key);\n    if (cert) X509_free(cert);\n    return PJ_EUNKNOWN;\n}\n\n/* Create and initialize new SSL context and instance */\nstatic pj_status_t ssl_create(dtls_srtp *ds, unsigned idx)\n{\n    SSL_CTX *ctx;\n    unsigned i;\n    int mode, rc;\n\n    /* Check if it is already instantiated */\n    if (ds->ossl_ssl[idx])\n        return PJ_SUCCESS;\n\n    /* Create DTLS context */\n    ctx = SSL_CTX_new(DTLS_method());\n    if (ctx == NULL) {\n        return GET_SSL_STATUS(ds);\n    }\n\n    if (valid_profiles_cnt == 0) {\n        SSL_CTX_free(ctx);\n        return PJMEDIA_SRTP_DTLS_ENOPROFILE;\n    }\n\n    /* Set crypto */\n    if (1) {\n        char *p, *end, buf[PJ_ARRAY_SIZE(ossl_profiles)*25];\n        unsigned n;\n\n        p = buf;\n        end = buf + sizeof(buf);\n        for (i=0; i<ds->srtp->setting.crypto_count && p < end; ++i) {\n            pjmedia_srtp_crypto *crypto = &ds->srtp->setting.crypto[i];\n            unsigned j;\n            for (j=0; j < valid_profiles_cnt; ++j) {\n                if (!pj_ansi_strcmp(crypto->name.ptr,\n                                    valid_pj_profiles_list[j]))\n                {\n                    n = pj_ansi_snprintf(p, end-p, \":%s\",\n                                         valid_ossl_profiles_list[j]);\n                    p += n;\n                    break;\n                }\n            }\n\n        }\n        rc = SSL_CTX_set_tlsext_use_srtp(ctx, buf+1);\n        PJ_LOG(4,(ds->base.name, \"Setting crypto [%s], errcode=%d\", buf, rc));\n        if (rc != 0) {\n            SSL_CTX_free(ctx);\n            return GET_SSL_STATUS(ds);\n        }\n    }\n\n    /* Set ciphers */\n    SSL_CTX_set_cipher_list(ctx, PJMEDIA_SRTP_DTLS_OSSL_CIPHERS);\n\n    /* Set cert & private key */\n    rc = SSL_CTX_use_certificate(ctx, dtls_cert);\n    pj_assert(rc);\n    rc = SSL_CTX_use_PrivateKey(ctx, dtls_priv_key);\n    pj_assert(rc);\n    rc = SSL_CTX_check_private_key(ctx);\n    pj_assert(rc);\n\n    /* Create SSL instance */\n    ds->ossl_ctx[idx] = ctx;\n    ds->ossl_ssl[idx] = SSL_new(ds->ossl_ctx[idx]);\n    if (ds->ossl_ssl[idx] == NULL) {\n        SSL_CTX_free(ctx);\n        return GET_SSL_STATUS(ds);\n    }\n\n    /* Set MTU */\n#ifdef DTLS_CTRL_SET_LINK_MTU\n    if (!SSL_ctrl(ds->ossl_ssl[idx], DTLS_CTRL_SET_LINK_MTU, PJMEDIA_MAX_MTU,\n                  NULL))\n    {\n        PJ_LOG(4, (ds->base.name,\n                  \"Ignored failure in setting MTU to %d (too small?)\",\n                  PJMEDIA_MAX_MTU));\n    }\n#endif\n\n    /* SSL verification options, must be mutual auth */\n    mode = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT;\n    SSL_set_verify(ds->ossl_ssl[idx], mode, &verify_cb);\n\n    /* Setup SSL BIOs */\n    ds->ossl_rbio[idx] = BIO_new(BIO_s_mem());\n    ds->ossl_wbio[idx] = BIO_new(BIO_s_mem());\n    (void)BIO_set_close(ds->ossl_rbio[idx], BIO_CLOSE);\n    (void)BIO_set_close(ds->ossl_wbio[idx], BIO_CLOSE);\n    SSL_set_bio(ds->ossl_ssl[idx], ds->ossl_rbio[idx], ds->ossl_wbio[idx]);\n\n    return PJ_SUCCESS;\n}\n\n\n/* Destroy SSL context and instance */\nstatic void ssl_destroy(dtls_srtp *ds, unsigned idx)\n{\n    DTLS_LOCK(ds);\n\n    /* Destroy SSL instance */\n    if (ds->ossl_ssl[idx]) {\n        /**\n         * Avoid calling SSL_shutdown() if handshake wasn't completed.\n         * OpenSSL 1.0.2f complains if SSL_shutdown() is called during an\n         * SSL handshake, while previous versions always return 0.       \n         */\n        if (SSL_in_init(ds->ossl_ssl[idx]) == 0) {\n            SSL_shutdown(ds->ossl_ssl[idx]);\n        }\n        SSL_free(ds->ossl_ssl[idx]); /* this will also close BIOs */\n        ds->ossl_ssl[idx] = NULL;\n        /* thus reset the BIOs as well */\n        ds->ossl_rbio[idx] = NULL;\n        ds->ossl_wbio[idx] = NULL;\n    }\n\n    /* Destroy SSL context */\n    if (ds->ossl_ctx[idx]) {\n        SSL_CTX_free(ds->ossl_ctx[idx]);\n        ds->ossl_ctx[idx] = NULL;\n    }\n\n    DTLS_UNLOCK(ds);\n}\n\nstatic pj_status_t ssl_get_srtp_material(dtls_srtp *ds, unsigned idx)\n{\n    unsigned char material[SRTP_MAX_KEY_LEN * 2];\n    SRTP_PROTECTION_PROFILE *profile;\n    int rc, i, crypto_idx = -1;\n    pjmedia_srtp_crypto *tx, *rx;\n    pj_status_t status = PJ_SUCCESS;\n\n    DTLS_LOCK(ds);\n\n    if (!ds->ossl_ssl[idx]) {\n        status = PJ_EGONE;\n        goto on_return;\n    }\n\n    /* Get selected crypto-suite */\n    profile = SSL_get_selected_srtp_profile(ds->ossl_ssl[idx]);\n    if (!profile) {\n        status = PJMEDIA_SRTP_DTLS_ENOCRYPTO;\n        goto on_return;\n    }\n\n    tx = &ds->tx_crypto[idx];\n    rx = &ds->rx_crypto[idx];\n    pj_bzero(tx, sizeof(*tx));\n    pj_bzero(rx, sizeof(*rx));\n    for (i=0; i<(int)PJ_ARRAY_SIZE(ossl_profiles); ++i) {\n        if (pj_ansi_stricmp(profile->name, ossl_profiles[i])==0) {\n            pj_strset2(&tx->name, pj_profiles[i]);\n            pj_strset2(&rx->name, pj_profiles[i]);\n            crypto_idx = get_crypto_idx(&tx->name);\n            break;\n        }\n    }\n    if (crypto_idx == -1) {\n        status = PJMEDIA_SRTP_ENOTSUPCRYPTO;\n        goto on_return;\n    }\n\n    /* Get keying material from DTLS nego. There seems to be no info about\n     * material length returned by SSL_export_keying_material()?\n     */\n    rc = SSL_export_keying_material(ds->ossl_ssl[idx], material,\n                                    sizeof(material), \"EXTRACTOR-dtls_srtp\",\n                                    19, NULL, 0, 0);\n    if (rc == 0) {\n        status = PJMEDIA_SRTP_EINKEYLEN;\n        goto on_return;\n    }\n\n    /* Parse SRTP master key & salt from keying material */\n    {\n        char *p = (char*)material;\n        char *k1, *k2;\n        crypto_suite *cs = &crypto_suites[crypto_idx];\n        unsigned key_len, salt_len;\n\n        key_len = cs->cipher_key_len - cs->cipher_salt_len;\n        salt_len = cs->cipher_salt_len;\n\n        tx->key.ptr = (char*)pj_pool_alloc(ds->pool, key_len+salt_len);\n        tx->key.slen = key_len+salt_len;\n        rx->key.ptr = (char*)pj_pool_alloc(ds->pool, key_len+salt_len);\n        rx->key.slen = key_len+salt_len;\n        if (ds->setup == DTLS_SETUP_ACTIVE) {\n            k1 = tx->key.ptr;\n            k2 = rx->key.ptr;\n        } else {\n            k1 = rx->key.ptr;\n            k2 = tx->key.ptr;\n        }\n        pj_memcpy(k1, p, key_len); p += key_len;\n        pj_memcpy(k2, p, key_len); p += key_len;\n        pj_memcpy(k1+key_len, p, salt_len); p += salt_len;\n        pj_memcpy(k2+key_len, p, salt_len);\n        ds->got_keys = PJ_TRUE;\n    }\n\non_return:\n    DTLS_UNLOCK(ds);\n    return status;\n}\n\n/* Match remote fingerprint: SDP vs actual */\nstatic pj_status_t ssl_match_fingerprint(dtls_srtp *ds, unsigned idx)\n{\n    X509 *rem_cert;\n    pj_bool_t is_sha256;\n    char buf[128];\n    pj_size_t buf_len = sizeof(buf);\n    pj_status_t status;\n\n    /* Check hash algo, currently we only support SHA-256 & SHA-1 */\n    if (!pj_strnicmp2(&ds->rem_fingerprint, \"SHA-256 \", 8))\n        is_sha256 = PJ_TRUE;\n    else if (!pj_strnicmp2(&ds->rem_fingerprint, \"SHA-1 \", 6))\n        is_sha256 = PJ_FALSE;\n    else {\n        PJ_LOG(4,(ds->base.name, \"Hash algo specified in remote SDP for \"\n                  \"its DTLS certificate fingerprint is not supported\"));\n        return PJ_ENOTSUP;\n    }\n\n    DTLS_LOCK(ds);\n    if (!ds->ossl_ssl[idx]) {\n        DTLS_UNLOCK(ds);\n        return PJ_EGONE;\n    }\n\n    /* Get remote cert & calculate the hash */\n    rem_cert = SSL_get_peer_certificate(ds->ossl_ssl[idx]);\n\n    DTLS_UNLOCK(ds);\n\n    if (!rem_cert)\n        return PJMEDIA_SRTP_DTLS_EPEERNOCERT;\n\n    status = ssl_get_fingerprint(rem_cert, is_sha256, buf, &buf_len);\n    X509_free(rem_cert);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Do they match? */\n    if (pj_stricmp2(&ds->rem_fingerprint, buf))\n        return PJMEDIA_SRTP_DTLS_EFPNOTMATCH;\n\n    return PJ_SUCCESS;\n}\n\n\n/* Send data to network */\nstatic pj_status_t send_raw(dtls_srtp *ds, unsigned idx, const void *buf,\n                            pj_size_t len)\n{\n#if DTLS_DEBUG\n    PJ_LOG(2,(ds->base.name, \"DTLS-SRTP %s sending %lu bytes\",\n                             CHANNEL_TO_STRING(idx), len));\n#endif\n\n    return (idx == RTP_CHANNEL?\n            pjmedia_transport_send_rtp(ds->srtp->member_tp, buf, len):\n            pjmedia_transport_send_rtcp(ds->srtp->member_tp, buf, len));\n}\n\n\n/* Start socket if member transport is UDP */\nstatic pj_status_t udp_member_transport_media_start(dtls_srtp *ds)\n{\n    pjmedia_transport_info info;\n    pj_status_t status;\n\n    if (!ds->srtp->member_tp)\n        return PJ_SUCCESS;\n\n    pjmedia_transport_info_init(&info);\n    status = pjmedia_transport_get_info(ds->srtp->member_tp, &info);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    if (info.specific_info_cnt == 1 &&\n        info.spc_info[0].type == PJMEDIA_TRANSPORT_TYPE_UDP)\n    {\n        return pjmedia_transport_media_start(ds->srtp->member_tp, 0, 0, 0, 0);\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/* Flush write BIO */\nstatic pj_status_t ssl_flush_wbio(dtls_srtp *ds, unsigned idx)\n{\n    pj_size_t len;\n    pj_status_t status = PJ_SUCCESS;\n\n    DTLS_LOCK(ds);\n\n    if (!ds->ossl_wbio[idx]) {\n        DTLS_UNLOCK(ds);\n        return PJ_EGONE;\n    }\n\n    /* Check whether there is data to send */\n    if (BIO_ctrl_pending(ds->ossl_wbio[idx]) > 0) {\n        /* Yes, get and send it */\n        len = BIO_read(ds->ossl_wbio[idx], ds->buf[idx], sizeof(ds->buf));\n        if (len > 0) {\n            DTLS_UNLOCK(ds);\n\n            status = send_raw(ds, idx, ds->buf[idx], len);\n            if (status != PJ_SUCCESS) {\n#if DTLS_DEBUG\n                pj_perror(2, ds->base.name, status, \"Send error\");\n#endif\n                /* This error should be recoverable, remote will retransmit\n                 * its packet when not receiving from us.\n                 */\n            }\n            DTLS_LOCK(ds);\n        }\n    }\n\n    if (!ds->ossl_ssl[idx]) {\n        DTLS_UNLOCK(ds);\n        return PJ_EGONE;\n    }\n\n    /* Just return if handshake completion procedure (key parsing, fingerprint\n     * verification, etc) has been done or handshake is still in progress.\n     */\n    if (ds->nego_completed[idx] || !SSL_is_init_finished(ds->ossl_ssl[idx])) {\n        DTLS_UNLOCK(ds);\n        return PJ_SUCCESS;\n    }\n\n    /* Yes, SSL handshake is done! */\n    ds->nego_completed[idx] = PJ_TRUE;\n    PJ_LOG(2,(ds->base.name, \"DTLS-SRTP negotiation for %s completed!\",\n                             CHANNEL_TO_STRING(idx)));\n\n    DTLS_UNLOCK(ds);\n\n    /* Stop the retransmission clock. Note that the clock may not be stopped\n     * if this function is called from clock thread context. We'll try again\n     * later in socket context.\n     */\n    if (ds->clock[idx])\n        pjmedia_clock_stop(ds->clock[idx]);\n\n    /* Get SRTP key material */\n    status = ssl_get_srtp_material(ds, idx);\n    if (status != PJ_SUCCESS) {\n        pj_perror(4, ds->base.name, status,\n                  \"Failed to get SRTP material\");\n        goto on_return;\n    }\n\n    /* Verify remote fingerprint if we've already got one from SDP */\n    if (ds->rem_fingerprint.slen && ds->rem_fprint_status == PJ_EPENDING) {\n        ds->rem_fprint_status = status = ssl_match_fingerprint(ds, idx);\n        if (status != PJ_SUCCESS) {\n            pj_perror(4, ds->base.name, status,\n                      \"Fingerprint specified in remote SDP doesn't match \"\n                      \"to actual remote certificate fingerprint!\");\n            goto on_return;\n        }\n    }\n\n    /* If media_start() has been called, start SRTP now */\n    if (ds->pending_start && idx == RTP_CHANNEL) {\n        ds->pending_start = PJ_FALSE;\n        ds->srtp->keying_pending_cnt--;\n\n        /* Copy negotiated policy to SRTP */\n        ds->srtp->srtp_ctx.tx_policy_neg = ds->tx_crypto[idx];\n        ds->srtp->srtp_ctx.rx_policy_neg = ds->rx_crypto[idx];\n\n        status = start_srtp(ds->srtp);\n        if (status != PJ_SUCCESS)\n            pj_perror(4, ds->base.name, status, \"Failed starting SRTP\");\n    } else if (idx == RTCP_CHANNEL) {\n        pjmedia_srtp_setting setting;\n\n        pjmedia_srtp_setting_default (&setting);\n\n        /* Copy negotiated policy to SRTP */\n        ds->srtp->srtp_rtcp.tx_policy_neg = ds->tx_crypto[idx];\n        ds->srtp->srtp_rtcp.rx_policy_neg = ds->rx_crypto[idx];\n\n        status = create_srtp_ctx(ds->srtp, &ds->srtp->srtp_rtcp,\n                                 &setting, &ds->srtp->srtp_rtcp.tx_policy_neg,\n                                 &ds->srtp->srtp_rtcp.rx_policy_neg);\n        if (status != PJ_SUCCESS)\n            pj_perror(4, ds->base.name, status, \"Failed creating SRTP RTCP\");\n    }\n\non_return:\n    if (idx == RTP_CHANNEL && ds->srtp->setting.cb.on_srtp_nego_complete) {\n        (*ds->srtp->setting.cb.on_srtp_nego_complete)\n                                            (&ds->srtp->base, status);\n    }\n\n    return status;\n}\n\n\nstatic void clock_cb(const pj_timestamp *ts, void *user_data)\n{\n    dtls_srtp_channel *ds_ch = (dtls_srtp_channel*)user_data;\n    dtls_srtp *ds = ds_ch->dtls_srtp;\n    unsigned idx = ds_ch->channel;\n\n    PJ_UNUSED_ARG(ts);\n\n    DTLS_LOCK(ds);\n\n    if (!ds->ossl_ssl[idx]) {\n        DTLS_UNLOCK(ds);\n        return;\n    }\n\n    if (DTLSv1_handle_timeout(ds->ossl_ssl[idx]) > 0) {\n        DTLS_UNLOCK(ds);\n        ssl_flush_wbio(ds, idx);\n    } else {\n        DTLS_UNLOCK(ds);\n    }\n}\n\n\n/* Asynchronous handshake */\nstatic pj_status_t ssl_handshake_channel(dtls_srtp *ds, unsigned idx)\n{\n    pj_status_t status;\n    int err;\n\n    DTLS_LOCK(ds);\n\n    /* Init DTLS (if not yet) */\n    status = ssl_create(ds, idx);\n    if (status != PJ_SUCCESS) {\n        DTLS_UNLOCK(ds);\n        return status;\n    }\n\n    /* Check if handshake has been initiated or even completed */\n    if (ds->nego_started[idx] || SSL_is_init_finished(ds->ossl_ssl[idx])) {\n        DTLS_UNLOCK(ds);\n        return PJ_SUCCESS;\n    }\n\n    /* Perform SSL handshake */\n    if (ds->setup == DTLS_SETUP_ACTIVE) {\n        SSL_set_connect_state(ds->ossl_ssl[idx]);\n    } else {\n        SSL_set_accept_state(ds->ossl_ssl[idx]);\n    }\n    err = SSL_do_handshake(ds->ossl_ssl[idx]);\n    if (err < 0) {\n        err = SSL_get_error(ds->ossl_ssl[idx], err);\n\n        DTLS_UNLOCK(ds);\n\n        if (err == SSL_ERROR_WANT_READ) {\n            status = ssl_flush_wbio(ds, idx);\n            if (status != PJ_SUCCESS)\n                goto on_return;\n        } else if (err != SSL_ERROR_NONE) {\n            /* Handshake fails */\n            status = STATUS_FROM_SSL_ERR(ds, err);\n            pj_perror(2, ds->base.name, status, \"SSL_do_handshake() error\");\n            goto on_return;\n        }\n    } else {\n        DTLS_UNLOCK(ds);\n    }\n\n    /* Create and start clock @4Hz for retransmission */\n    if (!ds->clock[idx]) {\n        ds->channel[idx].dtls_srtp = ds;\n        ds->channel[idx].channel = idx;\n        status = pjmedia_clock_create(ds->pool, 4, 1, 1,\n                                      PJMEDIA_CLOCK_NO_HIGHEST_PRIO, clock_cb,\n                                      &ds->channel[idx], &ds->clock[idx]);\n        if (status != PJ_SUCCESS)\n            goto on_return;\n    }    \n    status = pjmedia_clock_start(ds->clock[idx]);\n    if (status != PJ_SUCCESS)\n        goto on_return;\n\n    /* Finally, DTLS nego started! */\n    ds->nego_started[idx] = PJ_TRUE;\n    PJ_LOG(4,(ds->base.name, \"DTLS-SRTP %s negotiation initiated as %s\",\n              CHANNEL_TO_STRING(idx),\n              (ds->setup==DTLS_SETUP_ACTIVE? \"client\":\"server\")));\n\non_return:\n    if (status != PJ_SUCCESS) {\n        if (ds->clock[idx])\n            pjmedia_clock_stop(ds->clock[idx]);\n    }\n    return status;\n}\n\nstatic pj_status_t ssl_handshake(dtls_srtp *ds)\n{\n    pj_status_t status;\n\n    status = ssl_handshake_channel(ds, RTP_CHANNEL);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    if (!ds->srtp->use_rtcp_mux)\n        status = ssl_handshake_channel(ds, RTCP_CHANNEL);\n\n    return status;\n}\n\n/* Parse a=setup & a=fingerprint in remote SDP to update DTLS-SRTP states\n * 'setup' and 'rem_fingerprint'.\n * TODO: check those attributes in a=acap too?\n */\nstatic pj_status_t parse_setup_finger_attr(dtls_srtp *ds,\n                                           pj_bool_t rem_as_offerer,\n                                           const pjmedia_sdp_session *sdp,\n                                           unsigned media_index)\n{\n    pjmedia_sdp_media *m;\n    pjmedia_sdp_attr *a;\n\n    m = sdp->media[media_index];\n\n    /* Parse a=setup */\n    a = pjmedia_sdp_media_find_attr(m, &ID_SETUP, NULL);\n    if (!a)\n        a = pjmedia_sdp_attr_find(sdp->attr_count,\n                                  sdp->attr, &ID_SETUP, NULL);\n    if (!a)\n        return PJMEDIA_SRTP_ESDPAMBIGUEANS;\n\n    if (pj_stristr(&a->value, &ID_PASSIVE) ||\n        (rem_as_offerer && pj_stristr(&a->value, &ID_ACTPASS)))\n    {\n        /* Remote offers/answers 'passive' (or offers 'actpass'), so we are\n         * the client.\n         */\n        ds->setup = DTLS_SETUP_ACTIVE;\n    } else if (pj_stristr(&a->value, &ID_ACTIVE)) {\n        /* Remote offers/answers 'active' so we are the server. */\n        ds->setup = DTLS_SETUP_PASSIVE;\n    } else {\n        /* Unknown value set in remote a=setup */\n        return PJMEDIA_SRTP_ESDPAMBIGUEANS;\n    }\n\n    /* Parse a=fingerprint */\n    a = pjmedia_sdp_media_find_attr(m, &ID_FINGERPRINT, NULL);\n    if (!a)\n        a = pjmedia_sdp_attr_find(sdp->attr_count,\n                                  sdp->attr, &ID_FINGERPRINT,\n                                  NULL);\n    if (!a) {\n        /* No fingerprint attribute in remote SDP */\n        return PJMEDIA_SRTP_DTLS_ENOFPRINT;\n    } else {\n        pj_str_t rem_fp = a->value;\n        pj_strtrim(&rem_fp);\n        if (pj_stricmp(&ds->rem_fingerprint, &rem_fp))\n            pj_strdup(ds->pool, &ds->rem_fingerprint, &rem_fp);\n    }\n\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t get_rem_addrs(dtls_srtp *ds,\n                                 const pjmedia_sdp_session *sdp_remote,\n                                 unsigned media_index,\n                                 pj_sockaddr *rem_rtp,\n                                 pj_sockaddr *rem_rtcp,\n                                 pj_bool_t *rtcp_mux)\n{\n    pjmedia_sdp_media *m_rem = sdp_remote->media[media_index];\n    pjmedia_sdp_conn *conn;\n    pjmedia_sdp_attr *a;\n    int af = pj_AF_UNSPEC();\n    pj_bool_t use_ice_info = PJ_FALSE;\n\n    /* Init RTP & RTCP address */\n    pj_bzero(rem_rtp, sizeof(*rem_rtp));\n    pj_bzero(rem_rtcp, sizeof(*rem_rtcp));\n\n    /* If underlying transport is ICE, get remote addresses from ICE */\n    if (ds->use_ice) {\n        pjmedia_transport_info info;\n        pjmedia_ice_transport_info *ice_info;\n\n        pjmedia_transport_info_init(&info);\n        pjmedia_transport_get_info(ds->srtp->member_tp, &info);\n        ice_info = (pjmedia_ice_transport_info*)\n                   pjmedia_transport_info_get_spc_info(\n                                    &info, PJMEDIA_TRANSPORT_TYPE_ICE);\n        if (ice_info) {\n            *rem_rtp = ice_info->comp[0].rcand_addr;\n            if (ice_info->comp_cnt > 1)\n                *rem_rtcp = ice_info->comp[1].rcand_addr;\n\n            use_ice_info = PJ_TRUE;\n        }\n    }\n\n    /* Get remote addresses from SDP */\n    if (!use_ice_info) {\n\n        /* Get RTP address */\n        conn = m_rem->conn ? m_rem->conn : sdp_remote->conn;\n        if (pj_stricmp2(&conn->net_type, \"IN\")==0) {\n            if (pj_stricmp2(&conn->addr_type, \"IP4\")==0) {\n                af = pj_AF_INET();\n            } else if (pj_stricmp2(&conn->addr_type, \"IP6\")==0) {\n                af = pj_AF_INET6();\n            }\n        }\n        if (af != pj_AF_UNSPEC()) {\n            pj_sockaddr_init(af, rem_rtp, &conn->addr,\n                             m_rem->desc.port);\n        } else {\n            return PJ_EAFNOTSUP;\n        }\n\n        /* Get RTCP address. If \"rtcp\" attribute is present in the SDP,\n         * set the RTCP address from that attribute. Otherwise, calculate\n         * from RTP address.\n         */\n        a = pjmedia_sdp_attr_find2(m_rem->attr_count, m_rem->attr,\n                                   \"rtcp\", NULL);\n        if (a) {\n            pjmedia_sdp_rtcp_attr rtcp;\n            pj_status_t status;\n            status = pjmedia_sdp_attr_get_rtcp(a, &rtcp);\n            if (status == PJ_SUCCESS) {\n                if (rtcp.addr.slen) {\n                    pj_sockaddr_init(af, rem_rtcp, &rtcp.addr,\n                                     (pj_uint16_t)rtcp.port);\n                } else {\n                    pj_sockaddr_init(af, rem_rtcp, NULL,\n                                     (pj_uint16_t)rtcp.port);\n                    pj_memcpy(pj_sockaddr_get_addr(rem_rtcp),\n                              pj_sockaddr_get_addr(rem_rtp),\n                              pj_sockaddr_get_addr_len(rem_rtp));\n                }\n            }\n        }\n        if (!pj_sockaddr_has_addr(rem_rtcp)) {\n            int rtcp_port;\n            pj_memcpy(rem_rtcp, rem_rtp, sizeof(pj_sockaddr));\n            rtcp_port = pj_sockaddr_get_port(rem_rtp) + 1;\n            pj_sockaddr_set_port(rem_rtcp, (pj_uint16_t)rtcp_port);\n        }\n    }\n\n    /* Check if remote indicates the desire to use rtcp-mux in its SDP. */\n    if (rtcp_mux) {\n        a = pjmedia_sdp_attr_find2(m_rem->attr_count, m_rem->attr,\n                                   \"rtcp-mux\", NULL);\n        *rtcp_mux = (a? PJ_TRUE: PJ_FALSE);\n    }\n\n    return PJ_SUCCESS;\n}\n\n/* Check if an incoming packet is a DTLS packet (rfc5764 section 5.1.2) */\n#define IS_DTLS_PKT(pkt, pkt_len) (*(char*)pkt > 19 && *(char*)pkt < 64)\n\n\n/* Received packet (SSL handshake) from socket */\nstatic pj_status_t ssl_on_recv_packet(dtls_srtp *ds, unsigned idx,\n                                      const void *data, pj_size_t len)\n{\n    char tmp[128];\n    pj_size_t nwritten;\n\n    DTLS_LOCK(ds);\n\n    if (!ds->ossl_rbio[idx]) {\n        DTLS_UNLOCK(ds);\n        return PJ_EGONE;\n    }\n\n    nwritten = BIO_write(ds->ossl_rbio[idx], data, (int)len);\n    if (nwritten < len) {\n        /* Error? */\n        pj_status_t status;\n        status = GET_SSL_STATUS(ds);\n#if DTLS_DEBUG\n        pj_perror(2, ds->base.name, status, \"BIO_write() error\");\n#endif\n        DTLS_UNLOCK(ds);\n        return status;\n    }\n\n    if (!ds->ossl_ssl[idx]) {\n        DTLS_UNLOCK(ds);\n        return PJ_EGONE;\n    }\n\n    /* Consume (and ignore) the packet */\n    while (1) {\n        int rc = SSL_read(ds->ossl_ssl[idx], tmp, sizeof(tmp));\n        if (rc <= 0) {\n#if DTLS_DEBUG\n            pj_status_t status = GET_SSL_STATUS(ds);\n            if (status != PJ_SUCCESS)\n                pj_perror(2, ds->base.name, status, \"SSL_read() error\");\n#endif\n            break;\n        }\n    }\n\n    DTLS_UNLOCK(ds);\n\n    /* Flush anything pending in the write BIO */\n    return ssl_flush_wbio(ds, idx);\n}\n\n\nstatic void on_ice_complete2(pjmedia_transport *tp,\n                             pj_ice_strans_op op,\n                             pj_status_t status,\n                             void *user_data)\n{\n    dtls_srtp *ds = (dtls_srtp*)user_data;\n    pj_assert(ds);\n\n    PJ_UNUSED_ARG(tp);\n\n    if (op == PJ_ICE_STRANS_OP_NEGOTIATION && status == PJ_SUCCESS &&\n        ds->setup == DTLS_SETUP_ACTIVE)\n    {\n        pj_status_t tmp_st;\n        tmp_st = ssl_handshake(ds);\n        if (tmp_st != PJ_SUCCESS)\n            pj_perror(4, ds->base.name, tmp_st, \"Failed starting DTLS nego\");\n    }\n}\n\n\n/* *************************************\n *\n * DTLS-SRTP transport keying operations\n *\n * *************************************/\n\nstatic pj_status_t dtls_on_recv(pjmedia_transport *tp, unsigned idx,     \n                                const void *pkt, pj_size_t size)\n{\n    dtls_srtp *ds = (dtls_srtp*)tp;\n\n    DTLS_LOCK(ds);\n\n    /* Destroy the retransmission clock if handshake has been completed. */\n    if (ds->clock[idx] && ds->nego_completed[idx]) {\n        pjmedia_clock_destroy(ds->clock[idx]);\n        ds->clock[idx] = NULL;\n    }\n\n    if (size < 1 || !IS_DTLS_PKT(pkt, size) || ds->is_destroying) {\n        DTLS_UNLOCK(ds);\n        return PJ_EIGNORED;\n    }\n\n#if DTLS_DEBUG\n    PJ_LOG(2,(ds->base.name, \"DTLS-SRTP %s receiving %lu bytes\",\n                             CHANNEL_TO_STRING(idx), size));\n#endif\n\n    /* This is DTLS packet, let's process it. Note that if DTLS nego has\n     * been completed, this may be a retransmission (e.g: remote didn't\n     * receive our last handshake packet) or just a stray.\n     */\n\n    /* Check remote address info, reattach member tp if changed */\n    if (idx == RTP_CHANNEL && !ds->use_ice && !ds->nego_completed[idx]) {\n        pjmedia_transport_info info;\n        pjmedia_transport_get_info(ds->srtp->member_tp, &info);\n        if (pj_sockaddr_cmp(&ds->rem_addr, &info.src_rtp_name)) {\n            pjmedia_transport_attach_param ap;\n            pj_status_t status;\n\n            pj_bzero(&ap, sizeof(ap));\n            ap.user_data = ds->srtp;\n            pj_sockaddr_cp(&ds->rem_addr, &info.src_rtp_name);\n            pj_sockaddr_cp(&ap.rem_addr, &ds->rem_addr);\n            ap.addr_len = pj_sockaddr_get_len(&ap.rem_addr);\n            if (pj_sockaddr_cmp(&info.sock_info.rtp_addr_name,\n                                &info.sock_info.rtcp_addr_name) == 0)\n            {\n                /* Using RTP & RTCP multiplexing */\n                pj_sockaddr_cp(&ds->rem_rtcp, &ds->rem_addr);\n                pj_sockaddr_cp(&ap.rem_rtcp, &ds->rem_rtcp);\n            } else if (pj_sockaddr_has_addr(&ds->rem_rtcp)) {\n                pj_sockaddr_cp(&ap.rem_rtcp, &ds->rem_rtcp);\n            } else {\n                pj_sockaddr_cp(&ap.rem_rtcp, &ds->rem_addr);\n                pj_sockaddr_set_port(&ap.rem_rtcp,\n                                     pj_sockaddr_get_port(&ds->rem_addr)+1);\n            }\n\n            status = pjmedia_transport_attach2(&ds->srtp->base, &ap);\n            if (status != PJ_SUCCESS) {\n                DTLS_UNLOCK(ds);\n                return status;\n            }\n\n#if DTLS_DEBUG\n            {\n                char addr[PJ_INET6_ADDRSTRLEN];\n                PJ_LOG(2,(ds->base.name, \"Re-attached transport to update \"\n                          \"remote addr=%s:%d\",\n                          pj_sockaddr_print(&ap.rem_addr, addr,\n                                            sizeof(addr), 2),\n                          pj_sockaddr_get_port(&ap.rem_addr)));\n            }\n#endif\n        }\n    }\n\n    /* If our setup is ACTPASS, incoming packet may be a client hello,\n     * so let's update setup to PASSIVE and initiate DTLS handshake.\n     */\n    if (!ds->nego_started[idx] &&\n        (ds->setup == DTLS_SETUP_ACTPASS || ds->setup == DTLS_SETUP_PASSIVE))\n    {\n        pj_status_t status;\n        ds->setup = DTLS_SETUP_PASSIVE;\n        status = ssl_handshake_channel(ds, idx);\n        if (status != PJ_SUCCESS) {\n            DTLS_UNLOCK(ds);\n            return status;\n        }\n    }\n\n    /* Send it to OpenSSL */\n    ssl_on_recv_packet(ds, idx, pkt, size);\n\n    DTLS_UNLOCK(ds);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * This callback is called by SRTP transport when incoming rtp is received.\n * Originally this is send_rtp() op.\n */\nstatic pj_status_t dtls_on_recv_rtp( pjmedia_transport *tp,\n                                     const void *pkt,\n                                     pj_size_t size)\n{\n    return dtls_on_recv(tp, RTP_CHANNEL, pkt, size);\n}\n\n/*\n * This callback is called by SRTP transport when incoming rtcp is received.\n * Originally this is send_rtcp() op.\n */\nstatic pj_status_t dtls_on_recv_rtcp(pjmedia_transport *tp,\n                                     const void *pkt,\n                                     pj_size_t size)\n{\n    return dtls_on_recv(tp, RTCP_CHANNEL, pkt, size);\n}\n\nstatic pj_status_t dtls_media_create( pjmedia_transport *tp,\n                                      pj_pool_t *sdp_pool,\n                                      unsigned options,\n                                      const pjmedia_sdp_session *sdp_remote,\n                                      unsigned media_index)\n{\n    dtls_srtp *ds = (dtls_srtp*) tp;\n    pj_status_t status = PJ_SUCCESS;\n\n#if DTLS_DEBUG\n    PJ_LOG(2,(ds->base.name, \"dtls_media_create()\"));\n#endif\n\n    PJ_UNUSED_ARG(sdp_pool);\n    PJ_UNUSED_ARG(options);\n\n    if (ds->srtp->offerer_side) {\n        /* As offerer: do nothing. */\n    } else {\n        /* As answerer:\n         *    Check for DTLS-SRTP support in remote SDP. Detect remote\n         *    support of DTLS-SRTP by inspecting remote SDP offer for\n         *    SDP a=fingerprint attribute. And currently we only support\n         *    RTP/AVP transports.\n         */\n        pjmedia_sdp_media *m_rem = sdp_remote->media[media_index];\n        pjmedia_sdp_attr *attr_fp;\n        pj_uint32_t rem_proto = 0;\n\n        /* Find SDP a=fingerprint line. */\n        attr_fp = pjmedia_sdp_media_find_attr(m_rem, &ID_FINGERPRINT, NULL);\n        if (!attr_fp)\n            attr_fp = pjmedia_sdp_attr_find(sdp_remote->attr_count,\n                                            sdp_remote->attr, &ID_FINGERPRINT,\n                                            NULL);\n\n        /* Get media transport proto */\n        rem_proto = pjmedia_sdp_transport_get_proto(&m_rem->desc.transport);\n        if (!PJMEDIA_TP_PROTO_HAS_FLAG(rem_proto, PJMEDIA_TP_PROTO_RTP_AVP) ||\n            !attr_fp)\n        {\n            /* Remote doesn't signal DTLS-SRTP */\n            status = PJMEDIA_SRTP_ESDPINTRANSPORT;\n            goto on_return;\n        }\n\n        /* Check for a=fingerprint in remote SDP. */\n        switch (ds->srtp->setting.use) {\n            case PJMEDIA_SRTP_DISABLED:\n                status = PJMEDIA_SRTP_ESDPINTRANSPORT;\n                goto on_return;\n                break;\n            case PJMEDIA_SRTP_OPTIONAL:\n                break;\n            case PJMEDIA_SRTP_MANDATORY:\n                break;\n        }\n    }\n\n    /* Set remote cert fingerprint verification status to PJ_EPENDING */\n    ds->rem_fprint_status = PJ_EPENDING;\n\non_return:\n#if DTLS_DEBUG\n    if (status != PJ_SUCCESS) {\n        pj_perror(4, ds->base.name, status, \"dtls_media_create() failed\");\n    }\n#endif\n    return status;\n}\n\nstatic void dtls_media_stop_channel(dtls_srtp *ds, unsigned idx)\n{\n    if (ds->clock[idx])\n        pjmedia_clock_stop(ds->clock[idx]);\n\n    /* Reset DTLS state */\n    ssl_destroy(ds, idx);\n    ds->nego_started[idx] = PJ_FALSE;\n    ds->nego_completed[idx] = PJ_FALSE;\n}\n\nstatic pj_status_t dtls_encode_sdp( pjmedia_transport *tp,\n                                    pj_pool_t *sdp_pool,\n                                    pjmedia_sdp_session *sdp_local,\n                                    const pjmedia_sdp_session *sdp_remote,\n                                    unsigned media_index)\n{\n    dtls_srtp *ds = (dtls_srtp *)tp;\n    pjmedia_sdp_media *m_loc;\n    pjmedia_sdp_attr *a;\n    pj_bool_t use_ice = PJ_FALSE;\n    pj_status_t status = PJ_SUCCESS;\n\n#if DTLS_DEBUG\n    PJ_LOG(2,(ds->base.name, \"dtls_encode_sdp()\"));\n#endif\n\n    PJ_UNUSED_ARG(sdp_pool);\n\n    m_loc = sdp_local->media[media_index];\n    if (ds->srtp->offerer_side) {\n        /* As offerer */\n\n        /* Add attribute a=setup if none (rfc5763 section 5) */\n        a = pjmedia_sdp_media_find_attr(m_loc, &ID_SETUP, NULL);\n        if (!a)\n            a = pjmedia_sdp_attr_find(sdp_local->attr_count,\n                                      sdp_local->attr, &ID_SETUP, NULL);\n        if (!a) {\n            pj_str_t val;\n\n            if (ds->setup == DTLS_SETUP_UNKNOWN)\n                ds->setup = DTLS_SETUP_ACTPASS;\n            \n            if (ds->setup == DTLS_SETUP_ACTIVE)\n                val = ID_ACTIVE;\n            else if (ds->setup == DTLS_SETUP_PASSIVE)\n                val = ID_PASSIVE;\n            else\n                val = ID_ACTPASS;\n            a = pjmedia_sdp_attr_create(ds->pool, ID_SETUP.ptr, &val);\n            pjmedia_sdp_media_add_attr(m_loc, a);\n        }\n    } else {\n        /* As answerer */\n        dtls_setup last_setup = ds->setup;\n        pj_str_t last_rem_fp = ds->rem_fingerprint;\n        pj_bool_t rem_addr_changed = PJ_FALSE;\n\n        /* Parse a=setup and a=fingerprint */\n        status = parse_setup_finger_attr(ds, PJ_TRUE, sdp_remote,\n                                         media_index);\n        if (status != PJ_SUCCESS)\n            goto on_return;\n\n        /* Add attribute a=setup:active/passive if we are client/server. */\n        a = pjmedia_sdp_attr_create(ds->pool, ID_SETUP.ptr,\n                    (ds->setup==DTLS_SETUP_ACTIVE? &ID_ACTIVE:&ID_PASSIVE));\n        pjmedia_sdp_media_add_attr(m_loc, a);\n\n        if (last_setup != DTLS_SETUP_UNKNOWN) {\n            pj_sockaddr rem_rtp;\n            pj_sockaddr rem_rtcp;\n            pj_bool_t use_rtcp_mux;\n\n            status = get_rem_addrs(ds, sdp_remote, media_index, &rem_rtp,\n                                   &rem_rtcp, &use_rtcp_mux);\n            if (status == PJ_SUCCESS) {\n                if (use_rtcp_mux) {\n                    /* Remote indicates it wants to use rtcp-mux */\n                    pjmedia_transport_info info;\n\n                    pjmedia_transport_info_init(&info);\n                    pjmedia_transport_get_info(ds->srtp->member_tp, &info);\n                    if (pj_sockaddr_cmp(&info.sock_info.rtp_addr_name,\n                        &info.sock_info.rtcp_addr_name))\n                    {\n                        /* But we do not wish to use rtcp mux */\n                        use_rtcp_mux = PJ_FALSE;\n                    }\n                }\n                if (pj_sockaddr_has_addr(&ds->rem_addr) &&\n                    pj_sockaddr_has_addr(&rem_rtp) &&\n                    (pj_sockaddr_cmp(&ds->rem_addr, &rem_rtp) ||\n                     (!use_rtcp_mux &&\n                      pj_sockaddr_has_addr(&ds->rem_rtcp) &&\n                      pj_sockaddr_has_addr(&rem_rtcp) &&\n                      pj_sockaddr_cmp(&ds->rem_rtcp, &rem_rtcp))))\n                {\n                    rem_addr_changed = PJ_TRUE;\n                }\n            }\n        }\n\n        /* Check if remote signals DTLS re-nego by changing its\n         * setup/fingerprint in SDP or media transport address in SDP.\n         */\n        if ((last_setup != DTLS_SETUP_UNKNOWN && last_setup != ds->setup) ||\n            (last_rem_fp.slen &&\n             pj_memcmp(&last_rem_fp, &ds->rem_fingerprint, sizeof(pj_str_t)))||\n            (rem_addr_changed))\n        {\n            dtls_media_stop_channel(ds, RTP_CHANNEL);\n            dtls_media_stop_channel(ds, RTCP_CHANNEL);\n            ds->got_keys = PJ_FALSE;\n            ds->rem_fprint_status = PJ_EPENDING;\n        }\n    }\n\n    /* Set media transport to UDP/TLS/RTP/SAVP if we are the offerer,\n     * otherwise just match it to the offer (currently we only accept\n     * UDP/TLS/RTP/SAVP in remote offer though).\n     */\n    if (ds->srtp->offerer_side) {\n        m_loc->desc.transport = ID_TP_DTLS_SRTP;\n    } else {\n        m_loc->desc.transport = \n                            sdp_remote->media[media_index]->desc.transport;\n    }\n\n    /* Add a=fingerprint attribute, fingerprint of our TLS certificate */\n    {\n        char buf[128];\n        pj_size_t buf_len = sizeof(buf);\n        pj_str_t fp;\n\n        status = ssl_get_fingerprint(dtls_cert, PJ_TRUE, buf, &buf_len);\n        if (status != PJ_SUCCESS)\n            goto on_return;\n\n        pj_strset(&fp, buf, buf_len);\n        a = pjmedia_sdp_attr_create(ds->pool, ID_FINGERPRINT.ptr, &fp);\n        pjmedia_sdp_media_add_attr(m_loc, a);\n    }\n\n    if (ds->nego_completed[RTP_CHANNEL]) {\n        /* This is subsequent SDP offer/answer and no DTLS re-nego has been\n         * signalled.\n         */\n        goto on_return;\n    }\n\n    /* Attach member transport, so we can receive DTLS init (if our setup\n     * is PASSIVE/ACTPASS) or send DTLS init (if our setup is ACTIVE).\n     */\n    {\n        pjmedia_transport_attach_param ap;\n        pjmedia_transport_info info;\n\n        pj_bzero(&ap, sizeof(ap));\n        ap.user_data = ds->srtp;\n        pjmedia_transport_get_info(ds->srtp->member_tp, &info);\n\n        if (sdp_remote) {\n            get_rem_addrs(ds, sdp_remote, media_index, &ds->rem_addr,\n                          &ds->rem_rtcp, NULL);\n        }\n\n        if (pj_sockaddr_has_addr(&ds->rem_addr)) {\n            pj_sockaddr_cp(&ap.rem_addr, &ds->rem_addr);\n        } else if (pj_sockaddr_has_addr(&info.sock_info.rtp_addr_name)) {\n            pj_sockaddr_cp(&ap.rem_addr, &info.sock_info.rtp_addr_name);\n        } else {\n            pj_sockaddr_init(pj_AF_INET(), &ap.rem_addr, 0, 0);\n        }\n\n        if (pj_sockaddr_cmp(&info.sock_info.rtp_addr_name,\n                            &info.sock_info.rtcp_addr_name) == 0)\n        {\n            /* Using RTP & RTCP multiplexing */\n            pj_sockaddr_cp(&ap.rem_rtcp, &ap.rem_addr);\n        } else if (pj_sockaddr_has_addr(&ds->rem_rtcp)) {\n            pj_sockaddr_cp(&ap.rem_rtcp, &ds->rem_rtcp);\n        } else if (pj_sockaddr_has_addr(&info.sock_info.rtcp_addr_name)) {\n            pj_sockaddr_cp(&ap.rem_rtcp, &info.sock_info.rtcp_addr_name);\n        } else {\n            pj_sockaddr_init(pj_AF_INET(), &ap.rem_rtcp, 0, 0);\n        }\n\n        ap.addr_len = pj_sockaddr_get_len(&ap.rem_addr);\n        status = pjmedia_transport_attach2(&ds->srtp->base, &ap);\n        if (status != PJ_SUCCESS)\n            goto on_return;\n\n        /* Start member transport if it is UDP, so we can receive packet\n         * (see also #2097).\n         */\n        udp_member_transport_media_start(ds);\n\n#if DTLS_DEBUG\n        {\n            char addr[PJ_INET6_ADDRSTRLEN];\n            PJ_LOG(2,(ds->base.name, \"Attached transport, remote addr=%s:%d\",\n                      pj_sockaddr_print(&ap.rem_addr, addr, sizeof(addr), 2),\n                      pj_sockaddr_get_port(&ap.rem_addr)));\n        }\n#endif\n    }\n\n    /* If our setup is ACTIVE and member transport is not ICE,\n     * start DTLS nego.\n     */\n    if (ds->setup == DTLS_SETUP_ACTIVE) {\n        pjmedia_transport_info info;\n        pjmedia_ice_transport_info *ice_info;\n\n        pjmedia_transport_info_init(&info);\n        pjmedia_transport_get_info(ds->srtp->member_tp, &info);\n        ice_info = (pjmedia_ice_transport_info*)\n                   pjmedia_transport_info_get_spc_info(\n                                    &info, PJMEDIA_TRANSPORT_TYPE_ICE);\n        use_ice = ice_info && ice_info->comp_cnt;\n        if (!use_ice) {\n            /* Start SSL nego */\n            status = ssl_handshake(ds);\n            if (status != PJ_SUCCESS)\n                goto on_return;\n        }\n    }\n\non_return:\n#if DTLS_DEBUG\n    if (status != PJ_SUCCESS) {\n        pj_perror(4, ds->base.name, status, \"dtls_encode_sdp() failed\");\n    }\n#endif\n    return status;\n}\n\n\nstatic pj_status_t dtls_media_start( pjmedia_transport *tp,\n                                     pj_pool_t *tmp_pool,\n                                     const pjmedia_sdp_session *sdp_local,\n                                     const pjmedia_sdp_session *sdp_remote,\n                                     unsigned media_index)\n{\n    dtls_srtp *ds = (dtls_srtp *)tp;\n    pj_ice_strans_state ice_state;\n    pj_bool_t use_rtcp_mux = PJ_FALSE;\n    pj_status_t status = PJ_SUCCESS;\n    struct transport_srtp *srtp = (struct transport_srtp*)tp->user_data;\n\n#if DTLS_DEBUG\n    PJ_LOG(2,(ds->base.name, \"dtls_media_start()\"));\n#endif\n\n    PJ_UNUSED_ARG(tmp_pool);\n    PJ_UNUSED_ARG(sdp_local);\n\n    if (ds->srtp->offerer_side) {\n        /* As offerer */\n        dtls_setup last_setup = ds->setup;\n        pj_str_t last_rem_fp = ds->rem_fingerprint;\n\n        /* Parse a=setup and a=fingerprint */\n        status = parse_setup_finger_attr(ds, PJ_FALSE, sdp_remote,\n                                         media_index);\n        if (status != PJ_SUCCESS)\n            goto on_return;\n\n        /* Check if remote signals DTLS re-nego by changing its\n         * setup/fingerprint in SDP.\n         */\n        if ((last_setup != DTLS_SETUP_ACTPASS && last_setup != ds->setup) ||\n            (last_rem_fp.slen &&\n             pj_memcmp(&last_rem_fp, &ds->rem_fingerprint, sizeof(pj_str_t))))\n        {\n            dtls_media_stop_channel(ds, RTP_CHANNEL);\n            dtls_media_stop_channel(ds, RTCP_CHANNEL);\n            ds->got_keys = PJ_FALSE;\n            ds->rem_fprint_status = PJ_EPENDING;\n        }\n    } else {\n        /* As answerer */\n        \n        /* Nothing to do? */\n    }\n\n    /* Check and update ICE and rtcp-mux status */\n    {\n        pjmedia_transport_info info;\n        pjmedia_ice_transport_info *ice_info;\n\n        pjmedia_transport_info_init(&info);\n        pjmedia_transport_get_info(ds->srtp->member_tp, &info);\n        if (pj_sockaddr_cmp(&info.sock_info.rtp_addr_name,\n                            &info.sock_info.rtcp_addr_name) == 0)\n        {\n            ds->srtp->use_rtcp_mux = use_rtcp_mux = PJ_TRUE;\n        }\n        ice_info = (pjmedia_ice_transport_info*)\n                   pjmedia_transport_info_get_spc_info(\n                                    &info, PJMEDIA_TRANSPORT_TYPE_ICE);\n        ds->use_ice = ice_info && ice_info->active;\n        ice_state = ds->use_ice? ice_info->sess_state : 0;\n\n        /* Update remote RTP & RTCP addresses */\n        get_rem_addrs(ds, sdp_remote, media_index, &ds->rem_addr,\n                      &ds->rem_rtcp, NULL);\n    }\n\n    /* Check if the background DTLS nego has completed */\n    if (ds->got_keys) { \n        unsigned idx = RTP_CHANNEL;\n\n        ds->srtp->srtp_ctx.tx_policy_neg = ds->tx_crypto[idx];\n        ds->srtp->srtp_ctx.rx_policy_neg = ds->rx_crypto[idx];\n\n        /* Verify remote fingerprint (if available) */\n        if (ds->rem_fingerprint.slen && ds->rem_fprint_status == PJ_EPENDING)\n        {\n            ds->rem_fprint_status = ssl_match_fingerprint(ds, idx);\n            if (ds->rem_fprint_status != PJ_SUCCESS) {\n                pj_perror(4, ds->base.name, ds->rem_fprint_status,\n                          \"Fingerprint specified in remote SDP doesn't match \"\n                          \"to actual remote certificate fingerprint!\");\n                return ds->rem_fprint_status;\n            }\n        }\n\n        return PJ_SUCCESS;\n    } \n\n    /* SRTP key is not ready, SRTP start is pending */\n    ds->srtp->keying_pending_cnt++;\n    ds->pending_start = PJ_TRUE;\n\n    srtp->peer_use = PJMEDIA_SRTP_MANDATORY;\n\n    /* If our DTLS setup is ACTIVE:\n     * - start DTLS nego after ICE nego, or\n     * - start it now if there is no ICE.\n     */\n    if (ds->setup == DTLS_SETUP_ACTIVE) {\n        if (ds->use_ice && ice_state < PJ_ICE_STRANS_STATE_RUNNING)  {\n            /* Register ourselves to listen to ICE notifications */\n            pjmedia_ice_cb ice_cb;\n            pj_bzero(&ice_cb, sizeof(ice_cb));\n            ice_cb.on_ice_complete2 = &on_ice_complete2;\n            pjmedia_ice_add_ice_cb(ds->srtp->member_tp, &ice_cb, ds);\n        } else {\n            /* This can happen when we are SDP offerer and remote wants\n             * PASSIVE DTLS role.\n             */\n            pjmedia_transport_attach_param ap;\n            pj_bzero(&ap, sizeof(ap));\n            ap.user_data = ds->srtp;\n\n            /* Attach ourselves to member transport for DTLS nego. */\n            if (pj_sockaddr_has_addr(&ds->rem_addr))\n                pj_sockaddr_cp(&ap.rem_addr, &ds->rem_addr);\n            else\n                pj_sockaddr_init(pj_AF_INET(), &ap.rem_addr, 0, 0);\n\n            if (use_rtcp_mux) {\n                /* Using RTP & RTCP multiplexing */\n                pj_sockaddr_cp(&ap.rem_rtcp, &ds->rem_addr);\n            } else if (pj_sockaddr_has_addr(&ds->rem_rtcp)) {\n                pj_sockaddr_cp(&ap.rem_rtcp, &ds->rem_rtcp);\n            } else if (pj_sockaddr_has_addr(&ds->rem_addr)) {\n                pj_sockaddr_cp(&ap.rem_rtcp, &ds->rem_addr);\n                pj_sockaddr_set_port(&ap.rem_rtcp,\n                                     pj_sockaddr_get_port(&ap.rem_rtcp) + 1);\n            } else {\n                pj_sockaddr_init(pj_AF_INET(), &ap.rem_rtcp, 0, 0);\n            }\n\n            ap.addr_len = pj_sockaddr_get_len(&ap.rem_addr);\n            status = pjmedia_transport_attach2(&ds->srtp->base, &ap);\n            if (status != PJ_SUCCESS)\n                goto on_return;\n#if DTLS_DEBUG\n            {\n                char addr[PJ_INET6_ADDRSTRLEN];\n                PJ_LOG(2,(ds->base.name, \"Attached transport, \"\n                          \"remote addr=%s:%d\",\n                          pj_sockaddr_print(&ap.rem_addr, addr,\n                          sizeof(addr), 2),\n                          pj_sockaddr_get_port(&ap.rem_addr)));\n            }\n#endif\n            \n            status = ssl_handshake(ds);\n            if (status != PJ_SUCCESS)\n                goto on_return;\n        }\n    }\n\non_return:\n#if DTLS_DEBUG\n    if (status != PJ_SUCCESS) {\n        pj_perror(4, ds->base.name, status, \"dtls_media_start() failed\");\n    }\n#endif\n    return status;\n}\n\nstatic pj_status_t dtls_media_stop(pjmedia_transport *tp)\n{\n    dtls_srtp *ds = (dtls_srtp *)tp;\n\n#if DTLS_DEBUG\n    PJ_LOG(2,(ds->base.name, \"dtls_media_stop()\"));\n#endif\n\n    dtls_media_stop_channel(ds, RTP_CHANNEL);\n    dtls_media_stop_channel(ds, RTCP_CHANNEL);\n\n    ds->setup = DTLS_SETUP_UNKNOWN;\n    ds->use_ice = PJ_FALSE;\n    ds->got_keys = PJ_FALSE;\n    ds->rem_fingerprint.slen = 0;\n    ds->rem_fprint_status = PJ_EPENDING;\n\n    return PJ_SUCCESS;\n}\n\nstatic void dtls_destroy_channel(dtls_srtp *ds, unsigned idx)\n{\n    if (ds->clock[idx]) {\n        pjmedia_clock_destroy(ds->clock[idx]);\n        ds->clock[idx] = NULL;\n    }\n    ssl_destroy(ds, idx);\n}\n\nstatic void dtls_on_destroy(void *arg) {\n    dtls_srtp *ds = (dtls_srtp *)arg;\n\n    if (ds->ossl_lock)\n        pj_lock_destroy(ds->ossl_lock);\n\n    pj_pool_safe_release(&ds->pool);\n}\n\nstatic pj_status_t dtls_destroy(pjmedia_transport *tp)\n{\n    dtls_srtp *ds = (dtls_srtp *)tp;\n\n#if DTLS_DEBUG\n    PJ_LOG(2,(ds->base.name, \"dtls_destroy()\"));\n#endif\n\n    ds->is_destroying = PJ_TRUE;\n\n    DTLS_LOCK(ds);\n\n    dtls_destroy_channel(ds, RTP_CHANNEL);\n    dtls_destroy_channel(ds, RTCP_CHANNEL);\n\n    DTLS_UNLOCK(ds);\n\n    if (ds->base.grp_lock) {\n        pj_grp_lock_dec_ref(ds->base.grp_lock);\n    } else {\n        dtls_on_destroy(tp);\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/* Get fingerprint of local DTLS-SRTP certificate. */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_dtls_get_fingerprint(\n                                pjmedia_transport *tp,\n                                const char *hash,\n                                char *buf, pj_size_t *len)\n{\n    PJ_ASSERT_RETURN(dtls_cert, PJ_EINVALIDOP);\n    PJ_ASSERT_RETURN(tp && hash && buf && len, PJ_EINVAL);\n    PJ_ASSERT_RETURN(pj_ansi_strcmp(hash, \"SHA-256\")==0 ||\n                     pj_ansi_strcmp(hash, \"SHA-1\")==0, PJ_EINVAL);\n    PJ_UNUSED_ARG(tp);\n\n    return ssl_get_fingerprint(dtls_cert,\n                               pj_ansi_strcmp(hash, \"SHA-256\")==0,\n                               buf, len);\n}\n\n\n/* Manually start DTLS-SRTP negotiation (without SDP offer/answer) */\nPJ_DEF(pj_status_t) pjmedia_transport_srtp_dtls_start_nego(\n                                pjmedia_transport *tp,\n                                const pjmedia_srtp_dtls_nego_param *param)\n{\n    transport_srtp *srtp = (transport_srtp*)tp;\n    dtls_srtp *ds = NULL;\n    unsigned j;\n    pjmedia_transport_attach_param ap;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(tp && param, PJ_EINVAL);\n    PJ_ASSERT_RETURN(pj_sockaddr_has_addr(&param->rem_addr), PJ_EINVAL);\n\n    /* Find DTLS keying and destroy any other keying. */\n    for (j = 0; j < srtp->all_keying_cnt; ++j) {\n        if (srtp->all_keying[j]->op == &dtls_op)\n            ds = (dtls_srtp*)srtp->all_keying[j];\n        else\n            pjmedia_transport_close(srtp->all_keying[j]);\n    }\n\n    /* DTLS-SRTP is not enabled */\n    if (!ds)\n        return PJ_ENOTSUP;\n\n    /* Set SRTP keying to DTLS-SRTP only */\n    srtp->keying_cnt = 1;\n    srtp->keying[0] = &ds->base;\n    srtp->keying_pending_cnt = 0;\n\n    /* Apply param to DTLS-SRTP internal states */\n    pj_strdup(ds->pool, &ds->rem_fingerprint, &param->rem_fingerprint);\n    ds->rem_fprint_status = PJ_EPENDING;\n    ds->rem_addr = param->rem_addr;\n    ds->rem_rtcp = param->rem_rtcp;\n    ds->setup = param->is_role_active? DTLS_SETUP_ACTIVE:DTLS_SETUP_PASSIVE;\n\n    /* Pending start SRTP */\n    ds->pending_start = PJ_TRUE;\n    srtp->keying_pending_cnt++;\n\n    /* Attach member transport, so we can send/receive DTLS init packets */\n    pj_bzero(&ap, sizeof(ap));\n    ap.user_data = ds->srtp;\n    pj_sockaddr_cp(&ap.rem_addr, &ds->rem_addr);\n    pj_sockaddr_cp(&ap.rem_rtcp, &ds->rem_rtcp);\n    if (pj_sockaddr_cmp(&ds->rem_addr, &ds->rem_rtcp) == 0)\n        ds->srtp->use_rtcp_mux = PJ_TRUE;\n    ap.addr_len = pj_sockaddr_get_len(&ap.rem_addr);\n    status = pjmedia_transport_attach2(&ds->srtp->base, &ap);\n    if (status != PJ_SUCCESS)\n        goto on_return;\n\n#if DTLS_DEBUG\n    {\n        char addr[PJ_INET6_ADDRSTRLEN];\n        PJ_LOG(2,(ds->base.name, \"Attached transport, remote addr=%s:%d\",\n                  pj_sockaddr_print(&ap.rem_addr, addr, sizeof(addr), 2),\n                  pj_sockaddr_get_port(&ap.rem_addr)));\n    }\n#endif\n\n    /* Start DTLS handshake */\n    pj_bzero(&srtp->srtp_ctx.rx_policy_neg,\n             sizeof(srtp->srtp_ctx.rx_policy_neg));\n    pj_bzero(&srtp->srtp_ctx.tx_policy_neg,\n             sizeof(srtp->srtp_ctx.tx_policy_neg));\n    status = ssl_handshake(ds);\n    if (status != PJ_SUCCESS)\n        goto on_return;\n\non_return:\n    if (status != PJ_SUCCESS) {\n        ssl_destroy(ds, RTP_CHANNEL);\n        ssl_destroy(ds, RTCP_CHANNEL);\n    }\n    return status;\n}\n", "/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/transport_udp.h>\n#include <pj/compat/socket.h>\n#include <pj/addr_resolv.h>\n#include <pj/assert.h>\n#include <pj/errno.h>\n#include <pj/ioqueue.h>\n#include <pj/log.h>\n#include <pj/pool.h>\n#include <pj/rand.h>\n#include <pj/string.h>\n\n/* Maximum size of incoming RTP packet */\n#define RTP_LEN     PJMEDIA_MAX_MRU\n\n/* Maximum size of incoming RTCP packet */\n#if defined(PJMEDIA_SRTP_HAS_DTLS) && (PJMEDIA_SRTP_HAS_DTLS != 0)\n#   define RTCP_LEN    PJMEDIA_MAX_MRU\n#else\n#   define RTCP_LEN    600\n#endif\n\n/* Maximum pending write operations */\n#define MAX_PENDING 4\n\n#if 1\n#  define TRACE_(expr)\n#else\n#  define TRACE_(expr) PJ_LOG(3,expr)\n#endif\n\n\n/* Pending write buffer */\ntypedef struct pending_write\n{\n    char                buffer[PJMEDIA_MAX_MTU];\n    pj_ioqueue_op_key_t op_key;\n    pj_bool_t           is_pending;\n} pending_write;\n\n\nstruct transport_udp\n{\n    pjmedia_transport   base;           /**< Base transport.                */\n\n    pj_pool_t          *pool;           /**< Memory pool                    */\n    unsigned            options;        /**< Transport options.             */\n    unsigned            media_options;  /**< Transport media options.       */\n    void               *user_data;      /**< Only valid when attached       */\n    //pj_bool_t         attached;       /**< Has attachment?                */\n    pj_bool_t           started;        /**< Has started?                   */\n    pj_sockaddr         rem_rtp_addr;   /**< Remote RTP address             */\n    pj_sockaddr         rem_rtcp_addr;  /**< Remote RTCP address            */\n    int                 addr_len;       /**< Length of addresses.           */\n    void  (*rtp_cb)(    void*,          /**< To report incoming RTP.        */\n                        void*,\n                        pj_ssize_t);\n    void  (*rtp_cb2)(pjmedia_tp_cb_param*); /**< To report incoming RTP.    */\n    void  (*rtcp_cb)(   void*,          /**< To report incoming RTCP.       */\n                        void*,\n                        pj_ssize_t);\n\n    unsigned            tx_drop_pct;    /**< Percent of tx pkts to drop.    */\n    unsigned            rx_drop_pct;    /**< Percent of rx pkts to drop.    */\n    pj_ioqueue_t        *ioqueue;       /**< Ioqueue instance.              */\n\n    pj_sock_t           rtp_sock;       /**< RTP socket                     */\n    pj_sockaddr         rtp_addr_name;  /**< Published RTP address.         */\n    pj_ioqueue_key_t   *rtp_key;        /**< RTP socket key in ioqueue      */\n    pj_ioqueue_op_key_t rtp_read_op;    /**< Pending read operation         */\n    unsigned            rtp_write_op_id;/**< Next write_op to use           */\n    pending_write       rtp_pending_write[MAX_PENDING];  /**< Pending write */\n    pj_sockaddr         rtp_src_addr;   /**< Actual packet src addr.        */\n    int                 rtp_addrlen;    /**< Address length.                */\n    char                rtp_pkt[RTP_LEN];/**< Incoming RTP packet buffer    */\n\n    pj_bool_t           enable_rtcp_mux;/**< Enable RTP & RTCP multiplexing?*/\n    pj_bool_t           use_rtcp_mux;   /**< Use RTP & RTCP multiplexing?   */\n    pj_sock_t           rtcp_sock;      /**< RTCP socket                    */\n    pj_sockaddr         rtcp_addr_name; /**< Published RTCP address.        */\n    pj_sockaddr         rtcp_src_addr;  /**< Actual source RTCP address.    */\n    unsigned            rtcp_src_cnt;   /**< How many pkt from this addr.   */\n    int                 rtcp_addr_len;  /**< Length of RTCP src address.    */\n    pj_ioqueue_key_t   *rtcp_key;       /**< RTCP socket key in ioqueue     */\n    pj_ioqueue_op_key_t rtcp_read_op;   /**< Pending read operation         */\n    pj_ioqueue_op_key_t rtcp_write_op;  /**< Pending write operation        */\n    char                rtcp_pkt[RTCP_LEN];/**< Incoming RTCP packet buffer */\n};\n\n\n\nstatic void on_rx_rtp( pj_ioqueue_key_t *key, \n                       pj_ioqueue_op_key_t *op_key, \n                       pj_ssize_t bytes_read);\nstatic void on_rtp_data_sent(pj_ioqueue_key_t *key, \n                             pj_ioqueue_op_key_t *op_key, \n                             pj_ssize_t bytes_sent);\nstatic void on_rx_rtcp(pj_ioqueue_key_t *key, \n                       pj_ioqueue_op_key_t *op_key, \n                       pj_ssize_t bytes_read);\n\n/*\n * These are media transport operations.\n */\nstatic pj_status_t transport_get_info (pjmedia_transport *tp,\n                                       pjmedia_transport_info *info);\nstatic pj_status_t transport_attach   (pjmedia_transport *tp,\n                                       void *user_data,\n                                       const pj_sockaddr_t *rem_addr,\n                                       const pj_sockaddr_t *rem_rtcp,\n                                       unsigned addr_len,\n                                       void (*rtp_cb)(void*,\n                                                      void*,\n                                                      pj_ssize_t),\n                                       void (*rtcp_cb)(void*,\n                                                       void*,\n                                                       pj_ssize_t));\nstatic pj_status_t transport_attach2  (pjmedia_transport *tp,\n                                       pjmedia_transport_attach_param\n                                           *att_param);\nstatic void        transport_detach   (pjmedia_transport *tp,\n                                       void *strm);\nstatic pj_status_t transport_send_rtp( pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_send_rtcp(pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_send_rtcp2(pjmedia_transport *tp,\n                                       const pj_sockaddr_t *addr,\n                                       unsigned addr_len,\n                                       const void *pkt,\n                                       pj_size_t size);\nstatic pj_status_t transport_media_create(pjmedia_transport *tp,\n                                       pj_pool_t *pool,\n                                       unsigned options,\n                                       const pjmedia_sdp_session *sdp_remote,\n                                       unsigned media_index);\nstatic pj_status_t transport_encode_sdp(pjmedia_transport *tp,\n                                        pj_pool_t *pool,\n                                        pjmedia_sdp_session *sdp_local,\n                                        const pjmedia_sdp_session *rem_sdp,\n                                        unsigned media_index);\nstatic pj_status_t transport_media_start (pjmedia_transport *tp,\n                                       pj_pool_t *pool,\n                                       const pjmedia_sdp_session *sdp_local,\n                                       const pjmedia_sdp_session *sdp_remote,\n                                       unsigned media_index);\nstatic pj_status_t transport_media_stop(pjmedia_transport *tp);\nstatic pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n                                       pjmedia_dir dir,\n                                       unsigned pct_lost);\nstatic pj_status_t transport_destroy  (pjmedia_transport *tp);\nstatic pj_status_t transport_restart  (pj_bool_t is_rtp, \n                                       struct transport_udp *udp);\n\nstatic pjmedia_transport_op transport_udp_op = \n{\n    &transport_get_info,\n    &transport_attach,\n    &transport_detach,\n    &transport_send_rtp,\n    &transport_send_rtcp,\n    &transport_send_rtcp2,\n    &transport_media_create,\n    &transport_encode_sdp,\n    &transport_media_start,\n    &transport_media_stop,\n    &transport_simulate_lost,\n    &transport_destroy,\n    &transport_attach2\n};\n\nstatic const pj_str_t STR_RTCP_MUX      = { \"rtcp-mux\", 8 };\n\n/**\n * Create UDP stream transport.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_udp_create( pjmedia_endpt *endpt,\n                                                  const char *name,\n                                                  int port,\n                                                  unsigned options,\n                                                  pjmedia_transport **p_tp)\n{\n    return pjmedia_transport_udp_create2(endpt, name, NULL, port, options, \n                                        p_tp);\n}\n\n/**\n * Create UDP stream transport.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_udp_create2(pjmedia_endpt *endpt,\n                                                  const char *name,\n                                                  const pj_str_t *addr,\n                                                  int port,\n                                                  unsigned options,\n                                                  pjmedia_transport **p_tp)\n{\n    return pjmedia_transport_udp_create3(endpt, pj_AF_INET(), name,\n                                         addr, port, options, p_tp);\n}\n\n/**\n * Create UDP stream transport.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_udp_create3(pjmedia_endpt *endpt,\n                                                  int af,\n                                                  const char *name,\n                                                  const pj_str_t *addr,\n                                                  int port,\n                                                  unsigned options,\n                                                  pjmedia_transport **p_tp)\n{\n    pjmedia_sock_info si;\n    pj_status_t status;\n\n    \n    /* Sanity check */\n    PJ_ASSERT_RETURN(endpt && port && p_tp, PJ_EINVAL);\n\n\n    pj_bzero(&si, sizeof(pjmedia_sock_info));\n    si.rtp_sock = si.rtcp_sock = PJ_INVALID_SOCKET;\n\n    /* Create RTP socket */\n    status = pj_sock_socket(af, pj_SOCK_DGRAM() | pj_SOCK_CLOEXEC(), 0, &si.rtp_sock);\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    /* Bind RTP socket */\n    status = pj_sockaddr_init(af, &si.rtp_addr_name, addr, (pj_uint16_t)port);\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    status = pj_sock_bind(si.rtp_sock, &si.rtp_addr_name, \n                          pj_sockaddr_get_len(&si.rtp_addr_name));\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n\n    /* Create RTCP socket */\n    status = pj_sock_socket(af, pj_SOCK_DGRAM() | pj_SOCK_CLOEXEC(), 0, &si.rtcp_sock);\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    /* Bind RTCP socket */\n    status = pj_sockaddr_init(af, &si.rtcp_addr_name, addr, \n                              (pj_uint16_t)(port+1));\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    status = pj_sock_bind(si.rtcp_sock, &si.rtcp_addr_name,\n                          pj_sockaddr_get_len(&si.rtcp_addr_name));\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    \n    /* Create UDP transport by attaching socket info */\n    return pjmedia_transport_udp_attach( endpt, name, &si, options, p_tp);\n\n\non_error:\n    if (si.rtp_sock != PJ_INVALID_SOCKET)\n        pj_sock_close(si.rtp_sock);\n    if (si.rtcp_sock != PJ_INVALID_SOCKET)\n        pj_sock_close(si.rtcp_sock);\n    return status;\n}\n\n\n/**\n * Create UDP stream transport from existing socket info.\n */\nPJ_DEF(pj_status_t) pjmedia_transport_udp_attach( pjmedia_endpt *endpt,\n                                                  const char *name,\n                                                  const pjmedia_sock_info *si,\n                                                  unsigned options,\n                                                  pjmedia_transport **p_tp)\n{\n    struct transport_udp *tp;\n    pj_pool_t *pool;\n    pj_ioqueue_t *ioqueue;\n    pj_ioqueue_callback rtp_cb, rtcp_cb;\n    pj_grp_lock_t *grp_lock;\n    pj_status_t status;\n\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(endpt && si && p_tp, PJ_EINVAL);\n\n    /* Get ioqueue instance */\n    ioqueue = pjmedia_endpt_get_ioqueue(endpt);\n\n    if (name==NULL)\n        name = \"udp%p\";\n\n    /* Create transport structure */\n    pool = pjmedia_endpt_create_pool(endpt, name, 512, 512);\n    if (!pool)\n        return PJ_ENOMEM;\n\n    tp = PJ_POOL_ZALLOC_T(pool, struct transport_udp);\n    tp->pool = pool;\n    tp->options = options;\n    pj_memcpy(tp->base.name, pool->obj_name, PJ_MAX_OBJ_NAME);\n    tp->base.op = &transport_udp_op;\n    tp->base.type = PJMEDIA_TRANSPORT_TYPE_UDP;\n\n    /* Copy socket infos */\n    tp->rtp_sock = si->rtp_sock;\n    tp->rtp_addr_name = si->rtp_addr_name;\n    tp->rtcp_sock = si->rtcp_sock;\n    tp->rtcp_addr_name = si->rtcp_addr_name;\n\n    /* If address is 0.0.0.0, use host's IP address */\n    if (!pj_sockaddr_has_addr(&tp->rtp_addr_name)) {\n        pj_sockaddr hostip;\n\n        status = pj_gethostip(tp->rtp_addr_name.addr.sa_family, &hostip);\n        if (status != PJ_SUCCESS)\n            goto on_error;\n\n        pj_memcpy(pj_sockaddr_get_addr(&tp->rtp_addr_name), \n                  pj_sockaddr_get_addr(&hostip),\n                  pj_sockaddr_get_addr_len(&hostip));\n    }\n\n    /* Same with RTCP */\n    if (!pj_sockaddr_has_addr(&tp->rtcp_addr_name)) {\n        pj_memcpy(pj_sockaddr_get_addr(&tp->rtcp_addr_name),\n                  pj_sockaddr_get_addr(&tp->rtp_addr_name),\n                  pj_sockaddr_get_addr_len(&tp->rtp_addr_name));\n    }\n\n    /* Create group lock */\n    status = pj_grp_lock_create(pool, NULL, &grp_lock);\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    pj_grp_lock_add_ref(grp_lock);\n    tp->base.grp_lock = grp_lock;\n\n    /* Setup RTP socket with the ioqueue */\n    pj_bzero(&rtp_cb, sizeof(rtp_cb));\n    rtp_cb.on_read_complete = &on_rx_rtp;\n    rtp_cb.on_write_complete = &on_rtp_data_sent;\n\n    status = pj_ioqueue_register_sock2(pool, ioqueue, tp->rtp_sock, grp_lock,\n                                       tp, &rtp_cb, &tp->rtp_key);\n    if (status != PJ_SUCCESS)\n        goto on_error;\n    \n    /* Disallow concurrency so that detach() and destroy() are\n     * synchronized with the callback.\n     *\n     * Note that we still need this even after group lock is added to\n     * maintain the above behavior.\n     */\n    status = pj_ioqueue_set_concurrency(tp->rtp_key, PJ_FALSE);\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n#if 0 // See #2097: move read op kick-off to media_start()\n    pj_ioqueue_op_key_init(&tp->rtp_read_op, sizeof(tp->rtp_read_op));\n    for (i=0; i<PJ_ARRAY_SIZE(tp->rtp_pending_write); ++i) {\n        tp->rtp_pending_write[i].is_pending = PJ_FALSE;\n        pj_ioqueue_op_key_init(&tp->rtp_pending_write[i].op_key, \n                               sizeof(tp->rtp_pending_write[i].op_key));\n    }\n\n    /* Kick of pending RTP read from the ioqueue */\n    tp->rtp_addrlen = sizeof(tp->rtp_src_addr);\n    size = sizeof(tp->rtp_pkt);\n    status = pj_ioqueue_recvfrom(tp->rtp_key, &tp->rtp_read_op,\n                                 tp->rtp_pkt, &size, PJ_IOQUEUE_ALWAYS_ASYNC,\n                                 &tp->rtp_src_addr, &tp->rtp_addrlen);\n    if (status != PJ_EPENDING)\n        goto on_error;\n#endif\n\n\n    /* Setup RTCP socket with ioqueue */\n    pj_bzero(&rtcp_cb, sizeof(rtcp_cb));\n    rtcp_cb.on_read_complete = &on_rx_rtcp;\n\n    status = pj_ioqueue_register_sock2(pool, ioqueue, tp->rtcp_sock, grp_lock,\n                                       tp, &rtcp_cb, &tp->rtcp_key);\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    status = pj_ioqueue_set_concurrency(tp->rtcp_key, PJ_FALSE);\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n#if 0 // See #2097: move read op kick-off to media_start()\n    pj_ioqueue_op_key_init(&tp->rtcp_read_op, sizeof(tp->rtcp_read_op));\n    pj_ioqueue_op_key_init(&tp->rtcp_write_op, sizeof(tp->rtcp_write_op));\n\n    /* Kick of pending RTCP read from the ioqueue */\n    size = sizeof(tp->rtcp_pkt);\n    tp->rtcp_addr_len = sizeof(tp->rtcp_src_addr);\n    status = pj_ioqueue_recvfrom( tp->rtcp_key, &tp->rtcp_read_op,\n                                  tp->rtcp_pkt, &size, PJ_IOQUEUE_ALWAYS_ASYNC,\n                                  &tp->rtcp_src_addr, &tp->rtcp_addr_len);\n    if (status != PJ_EPENDING)\n        goto on_error;\n#endif  \n\n    tp->ioqueue = ioqueue;\n\n    /* Done */\n    *p_tp = &tp->base;\n    return PJ_SUCCESS;\n\n\non_error:\n    transport_destroy(&tp->base);\n    return status;\n}\n\n\n/**\n * Close UDP transport.\n */\nstatic pj_status_t transport_destroy(pjmedia_transport *tp)\n{\n    struct transport_udp *udp = (struct transport_udp*) tp;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    /* Must not close while application is using this */\n    //PJ_ASSERT_RETURN(!udp->attached, PJ_EINVALIDOP);\n\n    /* The following calls to pj_ioqueue_unregister() will block the execution\n     * if callback is still being called because allow_concurrent is false.\n     * So it is safe to release the pool immediately after.\n     */\n\n    if (udp->rtp_key) {\n        pj_ioqueue_unregister(udp->rtp_key);\n        udp->rtp_key = NULL;\n        udp->rtp_sock = PJ_INVALID_SOCKET;\n    } else if (udp->rtp_sock != PJ_INVALID_SOCKET) {\n        pj_sock_close(udp->rtp_sock);\n        udp->rtp_sock = PJ_INVALID_SOCKET;\n    }\n\n    if (udp->rtcp_key) {\n        pj_ioqueue_unregister(udp->rtcp_key);\n        udp->rtcp_key = NULL;\n        udp->rtcp_sock = PJ_INVALID_SOCKET;\n    } else if (udp->rtcp_sock != PJ_INVALID_SOCKET) {\n        pj_sock_close(udp->rtcp_sock);\n        udp->rtcp_sock = PJ_INVALID_SOCKET;\n    }\n\n    pj_grp_lock_dec_ref(tp->grp_lock);\n\n    PJ_LOG(4,(udp->base.name, \"UDP media transport destroyed\"));\n    pj_pool_release(udp->pool);\n\n    return PJ_SUCCESS;\n}\n\n/* Call RTP cb. */\nstatic void call_rtp_cb(struct transport_udp *udp, pj_ssize_t bytes_read, \n                        pj_bool_t *rem_switch)\n{\n    void (*cb)(void*,void*,pj_ssize_t);\n    void (*cb2)(pjmedia_tp_cb_param*);\n    void *user_data;\n\n    cb = udp->rtp_cb;\n    cb2 = udp->rtp_cb2;\n    user_data = udp->user_data;\n\n    if (cb2) {\n        pjmedia_tp_cb_param param;\n\n        param.user_data = user_data;\n        param.pkt = udp->rtp_pkt;\n        param.size = bytes_read;\n        param.src_addr = &udp->rtp_src_addr;\n        param.rem_switch = PJ_FALSE;\n        (*cb2)(&param);\n        if (rem_switch)\n            *rem_switch = param.rem_switch;\n    } else if (cb) {\n        (*cb)(user_data, udp->rtp_pkt, bytes_read);\n    }\n}\n\n/* Call RTCP cb. */\nstatic void call_rtcp_cb(struct transport_udp *udp, pj_ssize_t bytes_read)\n{\n    void(*cb)(void*, void*, pj_ssize_t);\n    void *user_data;\n\n    cb = udp->rtcp_cb;\n    user_data = udp->user_data;\n\n    if (cb)\n        (*cb)(user_data, udp->rtcp_pkt, bytes_read);\n}\n\n/* Notification from ioqueue about incoming RTP packet */\nstatic void on_rx_rtp(pj_ioqueue_key_t *key,\n                      pj_ioqueue_op_key_t *op_key,\n                      pj_ssize_t bytes_read)\n{\n    struct transport_udp *udp;\n    pj_status_t status;\n    pj_bool_t rem_switch = PJ_FALSE;\n    pj_bool_t transport_restarted = PJ_FALSE;\n    unsigned num_err = 0;\n    pj_status_t last_err = PJ_SUCCESS;\n\n    PJ_UNUSED_ARG(op_key);\n\n    udp = (struct transport_udp*) pj_ioqueue_get_user_data(key);\n\n    if (-bytes_read == PJ_ECANCELLED) {\n        TRACE_((udp->base.name, \"on_rx_rtp(): got PJ_ECANCELLED\"));\n        return;\n    }\n\n    if (-bytes_read == PJ_ESOCKETSTOP) {\n        TRACE_((udp->base.name, \"on_rx_rtp(): got PJ_ESOCKETSTOP\"));\n\n        /* Try to recover by restarting the transport. */\n        status = transport_restart(PJ_TRUE, udp);\n        if (status != PJ_SUCCESS) {\n            bytes_read = -PJ_ESOCKETSTOP;\n            call_rtp_cb(udp, bytes_read, NULL);\n        }\n        return;\n    }\n\n    do {\n        pj_bool_t discard = PJ_FALSE;\n\n        /* Simulate packet lost on RX direction */\n        if (udp->rx_drop_pct) {\n            if ((pj_rand() % 100) <= (int)udp->rx_drop_pct) {\n                PJ_LOG(5,(udp->base.name, \n                          \"RX RTP packet dropped because of pkt lost \"\n                          \"simulation\"));\n                discard = PJ_TRUE;\n            }\n        }\n\n        //if (!discard && udp->attached && cb)\n        if (!discard && \n            (-bytes_read != PJ_STATUS_FROM_OS(PJ_BLOCKING_ERROR_VAL))) \n        {\n            call_rtp_cb(udp, bytes_read, &rem_switch);\n        }\n\n#if defined(PJMEDIA_TRANSPORT_SWITCH_REMOTE_ADDR) && \\\n    (PJMEDIA_TRANSPORT_SWITCH_REMOTE_ADDR == 1)\n        if (rem_switch &&\n            (udp->options & PJMEDIA_UDP_NO_SRC_ADDR_CHECKING)==0)\n        {\n            char addr_text[PJ_INET6_ADDRSTRLEN+10];\n\n            /* Set remote RTP address to source address */\n            pj_sockaddr_cp(&udp->rem_rtp_addr, &udp->rtp_src_addr);\n\n            PJ_LOG(4,(udp->base.name,\n                      \"Remote RTP address switched to %s\",\n                      pj_sockaddr_print(&udp->rtp_src_addr, addr_text,\n                                        sizeof(addr_text), 3)));\n\n            if (udp->use_rtcp_mux) {\n                pj_sockaddr_cp(&udp->rem_rtcp_addr, &udp->rem_rtp_addr);\n                pj_sockaddr_cp(&udp->rtcp_src_addr, &udp->rem_rtcp_addr);\n            } else if (!pj_sockaddr_has_addr(&udp->rtcp_src_addr)) {\n                /* Also update remote RTCP address if actual RTCP source\n                 * address is not heard yet.\n                 */\n                pj_uint16_t port;\n\n                pj_sockaddr_cp(&udp->rem_rtcp_addr, &udp->rem_rtp_addr);\n                port = (pj_uint16_t)\n                       (pj_sockaddr_get_port(&udp->rem_rtp_addr)+1);\n                pj_sockaddr_set_port(&udp->rem_rtcp_addr, port);\n\n                pj_sockaddr_cp(&udp->rtcp_src_addr, &udp->rem_rtcp_addr);\n\n                PJ_LOG(4,(udp->base.name,\n                          \"Remote RTCP address switched to predicted\"\n                          \" address %s\",\n                          pj_sockaddr_print(&udp->rtcp_src_addr, addr_text,\n                                            sizeof(addr_text), 3)));\n            }\n        }\n#endif\n\n        bytes_read = sizeof(udp->rtp_pkt);\n        udp->rtp_addrlen = sizeof(udp->rtp_src_addr);\n        status = pj_ioqueue_recvfrom(udp->rtp_key, &udp->rtp_read_op,\n                                        udp->rtp_pkt, &bytes_read, 0,\n                                        &udp->rtp_src_addr,\n                                        &udp->rtp_addrlen);\n\n        if (status != PJ_EPENDING && status != PJ_SUCCESS) {        \n            if (transport_restarted && last_err == status) {\n                /* Still the same error after restart */\n                bytes_read = -PJ_ESOCKETSTOP;\n                call_rtp_cb(udp, bytes_read, NULL);\n                break;\n            } else if (PJMEDIA_IGNORE_RECV_ERR_CNT) {\n                if (last_err == status) {\n                    ++num_err;\n                } else {\n                    num_err = 1;\n                    last_err = status;\n                }\n\n                if (status == PJ_ESOCKETSTOP ||\n                    num_err > PJMEDIA_IGNORE_RECV_ERR_CNT)\n                {\n                    status = transport_restart(PJ_TRUE, udp);               \n                    if (status != PJ_SUCCESS) {\n                        bytes_read = -PJ_ESOCKETSTOP;\n                        call_rtp_cb(udp, bytes_read, NULL);\n                        break;\n                    }\n                    transport_restarted = PJ_TRUE;\n                    num_err = 0;\n                }\n            }\n            bytes_read = -status;\n            TRACE_((udp->base.name, \"on_rx_rtp(): recvfrom error=%d\", status));\n        }\n    } while (status != PJ_EPENDING && status != PJ_ECANCELLED &&\n             udp->started);\n}\n\nstatic void on_rtp_data_sent(pj_ioqueue_key_t *key, \n                             pj_ioqueue_op_key_t *op_key, \n                             pj_ssize_t bytes_sent)\n{\n    struct transport_udp *udp;\n    unsigned i;\n\n    PJ_UNUSED_ARG(bytes_sent);\n\n    udp = (struct transport_udp*) pj_ioqueue_get_user_data(key);\n\n    for (i = 0; i < PJ_ARRAY_SIZE(udp->rtp_pending_write); ++i) {\n        if (&udp->rtp_pending_write[i].op_key == op_key) {\n            udp->rtp_pending_write[i].is_pending = PJ_FALSE;\n            break;\n        }\n    }\n}\n\n/* Notification from ioqueue about incoming RTCP packet */\nstatic void on_rx_rtcp(pj_ioqueue_key_t *key, \n                       pj_ioqueue_op_key_t *op_key, \n                       pj_ssize_t bytes_read)\n{\n    struct transport_udp *udp;\n    pj_status_t status = PJ_SUCCESS;\n    pj_bool_t transport_restarted = PJ_FALSE;\n    unsigned num_err = 0;\n    pj_status_t last_err = PJ_SUCCESS;\n\n    PJ_UNUSED_ARG(op_key);\n\n    udp = (struct transport_udp*) pj_ioqueue_get_user_data(key);\n\n    if (-bytes_read == PJ_ECANCELLED) {\n        TRACE_((udp->base.name, \"on_rx_rtcp(): got PJ_ECANCELLED\"));\n        return;\n    }\n\n    if (-bytes_read == PJ_ESOCKETSTOP) {\n        TRACE_((udp->base.name, \"on_rx_rtcp(): got PJ_ESOCKETSTOP\"));\n\n        /* Try to recover by restarting the transport. */\n        status = transport_restart(PJ_FALSE, udp);\n        if (status != PJ_SUCCESS) {\n            bytes_read = -PJ_ESOCKETSTOP;\n            call_rtcp_cb(udp, bytes_read);\n        }\n        return;\n    }\n\n    do {\n        call_rtcp_cb(udp, bytes_read);\n\n#if defined(PJMEDIA_TRANSPORT_SWITCH_REMOTE_ADDR) && \\\n    (PJMEDIA_TRANSPORT_SWITCH_REMOTE_ADDR == 1)\n        /* Check if RTCP source address is the same as the configured\n         * remote address, and switch the address when they are\n         * different.\n         */\n        if (bytes_read>0 &&\n            (udp->options & PJMEDIA_UDP_NO_SRC_ADDR_CHECKING)==0)\n        {\n            if (pj_sockaddr_cmp(&udp->rem_rtcp_addr, &udp->rtcp_src_addr) == 0) {\n                /* Still receiving from rem_rtcp_addr, don't switch */\n                udp->rtcp_src_cnt = 0;\n            } else {\n                ++udp->rtcp_src_cnt;\n\n                if (udp->rtcp_src_cnt >= PJMEDIA_RTCP_NAT_PROBATION_CNT ) {\n                    char addr_text[PJ_INET6_ADDRSTRLEN+10];\n\n                    udp->rtcp_src_cnt = 0;\n                    pj_memcpy(&udp->rem_rtcp_addr, &udp->rtcp_src_addr,\n                              sizeof(pj_sockaddr));\n\n                    PJ_LOG(4,(udp->base.name,\n                              \"Remote RTCP address switched to %s\",\n                              pj_sockaddr_print(&udp->rtcp_src_addr, addr_text,\n                                                sizeof(addr_text), 3)));\n                }\n            }\n        }\n#endif\n\n        bytes_read = sizeof(udp->rtcp_pkt);\n        udp->rtcp_addr_len = sizeof(udp->rtcp_src_addr);\n        status = pj_ioqueue_recvfrom(udp->rtcp_key, &udp->rtcp_read_op,\n                                     udp->rtcp_pkt, &bytes_read, 0,\n                                     &udp->rtcp_src_addr, \n                                     &udp->rtcp_addr_len);\n\n        if (status != PJ_EPENDING && status != PJ_SUCCESS) {\n            if (transport_restarted && last_err == status) {\n                /* Still the same error after restart */\n                bytes_read = -PJ_ESOCKETSTOP;\n                call_rtcp_cb(udp, bytes_read);\n                break;\n            } else if (PJMEDIA_IGNORE_RECV_ERR_CNT) {\n                if (last_err == status) {\n                    ++num_err;\n                } else {\n                    num_err = 1;\n                    last_err = status;\n                }\n\n                if (status == PJ_ESOCKETSTOP ||\n                    num_err > PJMEDIA_IGNORE_RECV_ERR_CNT)\n                {\n                    status = transport_restart(PJ_FALSE, udp);              \n                    if (status != PJ_SUCCESS) {\n                        bytes_read = -PJ_ESOCKETSTOP;\n                        call_rtcp_cb(udp, bytes_read);\n                        break;\n                    }\n                    transport_restarted = PJ_TRUE;\n                    num_err = 0;\n                }\n            }\n            bytes_read = -status;\n            TRACE_((udp->base.name, \"on_rx_rtcp(): recvfrom error=%d\", status));\n        }       \n    } while (status != PJ_EPENDING && status != PJ_ECANCELLED &&\n             udp->started);\n}\n\n\n/* Called to get the transport info */\nstatic pj_status_t transport_get_info(pjmedia_transport *tp,\n                                      pjmedia_transport_info *info)\n{\n    struct transport_udp *udp = (struct transport_udp*)tp;\n    PJ_ASSERT_RETURN(tp && info, PJ_EINVAL);\n\n    info->sock_info.rtp_sock = udp->rtp_sock;\n    info->sock_info.rtp_addr_name = udp->rtp_addr_name;\n    info->sock_info.rtcp_sock = udp->rtcp_sock;\n    info->sock_info.rtcp_addr_name = (udp->use_rtcp_mux?\n                                      udp->rtp_addr_name:\n                                      udp->rtcp_addr_name);\n\n    /* Get remote address originating RTP & RTCP. */\n    info->src_rtp_name  = udp->rtp_src_addr;\n    info->src_rtcp_name = udp->rtcp_src_addr;\n\n    /* Add empty specific info */\n    if (info->specific_info_cnt < PJ_ARRAY_SIZE(info->spc_info)) {\n        pjmedia_transport_specific_info *tsi;\n\n        tsi = &info->spc_info[info->specific_info_cnt++];\n        tsi->type = PJMEDIA_TRANSPORT_TYPE_UDP;\n        tsi->cbsize = 0;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t tp_attach          (pjmedia_transport *tp,\n                                       void *user_data,\n                                       const pj_sockaddr_t *rem_addr,\n                                       const pj_sockaddr_t *rem_rtcp,\n                                       unsigned addr_len,\n                                       void (*rtp_cb)(void*,\n                                                      void*,\n                                                      pj_ssize_t),\n                                       void (*rtp_cb2)(pjmedia_tp_cb_param*),\n                                       void (*rtcp_cb)(void*,\n                                                       void*,\n                                                       pj_ssize_t))\n{\n    struct transport_udp *udp = (struct transport_udp*) tp;\n    const pj_sockaddr *rtcp_addr;\n    pj_sockaddr sock_addr, remote_addr, remote_rtcp;\n    int rem_addr_len;\n    pj_status_t status;\n\n    /* Validate arguments */\n    PJ_ASSERT_RETURN(tp && rem_addr && addr_len, PJ_EINVAL);\n\n    /* Must not be \"attached\" to existing application */\n    //PJ_ASSERT_RETURN(!udp->attached, PJ_EINVALIDOP);\n\n    /* Check again if we are multiplexing RTP & RTCP. */\n    udp->use_rtcp_mux = (pj_sockaddr_has_addr(rem_addr) &&\n                         pj_sockaddr_cmp(rem_addr, rem_rtcp) == 0);\n\n    TRACE_((udp->base.name, \"attach(): before locking keys\"));\n\n    /* Lock the ioqueue keys to make sure that callbacks are\n     * not executed. See ticket #844 for details.\n     */\n    pj_ioqueue_lock_key(udp->rtp_key);\n    pj_ioqueue_lock_key(udp->rtcp_key);\n\n    TRACE_((udp->base.name, \"attach(): inside locked keys\"));\n\n    /* \"Attach\" the application: */\n\n    rem_addr_len = sizeof(pj_sockaddr);\n    pj_sock_getsockname(udp->rtp_sock, &sock_addr, &rem_addr_len);\n\n    /* Synthesize address, if necessary. */\n    status = pj_sockaddr_synthesize(sock_addr.addr.sa_family,\n                                    &remote_addr, rem_addr);\n    if (status != PJ_SUCCESS) {\n        pj_perror(3, tp->name, status, \"Failed to synthesize the correct\"\n                                       \"IP address for RTP\");\n    }\n    rem_addr_len = pj_sockaddr_get_len(&remote_addr);\n\n    /* Copy remote RTP address */\n    pj_memcpy(&udp->rem_rtp_addr, &remote_addr, rem_addr_len);\n\n    /* Copy remote RTP address, if one is specified. */\n    rtcp_addr = (const pj_sockaddr*) rem_rtcp;\n    if (rtcp_addr && pj_sockaddr_has_addr(rtcp_addr)) {\n        status = pj_sockaddr_synthesize(sock_addr.addr.sa_family,\n                                        &remote_rtcp, rem_rtcp);\n        if (status != PJ_SUCCESS) {\n            pj_perror(3, tp->name, status, \"Failed to synthesize the correct\"\n                                           \"IP address for RTCP\");\n        }\n        pj_memcpy(&udp->rem_rtcp_addr, &remote_rtcp, rem_addr_len);\n\n    } else {\n        unsigned rtcp_port;\n\n        /* Otherwise guess the RTCP address from the RTP address */\n        pj_memcpy(&udp->rem_rtcp_addr, &udp->rem_rtp_addr, rem_addr_len);\n        rtcp_port = pj_sockaddr_get_port(&udp->rem_rtp_addr) + 1;\n        pj_sockaddr_set_port(&udp->rem_rtcp_addr, (pj_uint16_t)rtcp_port);\n    }\n\n    /* Save the callbacks */\n    udp->rtp_cb = rtp_cb;\n    udp->rtp_cb2 = rtp_cb2;\n    udp->rtcp_cb = rtcp_cb;\n    udp->user_data = user_data;\n\n    /* Save address length */\n    udp->addr_len = rem_addr_len;\n\n    /* Last, mark transport as attached */\n    //udp->attached = PJ_TRUE;\n\n    /* Reset source RTP & RTCP addresses and counter */\n    pj_bzero(&udp->rtp_src_addr, sizeof(udp->rtp_src_addr));\n    pj_bzero(&udp->rtcp_src_addr, sizeof(udp->rtcp_src_addr));\n    udp->rtcp_src_cnt = 0;\n\n    /* Set buffer size for RTP socket */\n#if PJMEDIA_TRANSPORT_SO_RCVBUF_SIZE\n    {\n        unsigned sobuf_size = PJMEDIA_TRANSPORT_SO_RCVBUF_SIZE;\n        \n        status = pj_sock_setsockopt_sobuf(udp->rtp_sock, pj_SO_RCVBUF(),\n                                          PJ_TRUE, &sobuf_size);\n        if (status != PJ_SUCCESS) {\n            pj_perror(3, tp->name, status, \"Failed setting SO_RCVBUF\");\n        } else {\n            if (sobuf_size < PJMEDIA_TRANSPORT_SO_RCVBUF_SIZE) {\n                PJ_LOG(4, (tp->name, \n                           \"Warning! Cannot set SO_RCVBUF as configured, \"\n                           \"now=%d, configured=%d\",\n                           sobuf_size, PJMEDIA_TRANSPORT_SO_RCVBUF_SIZE));\n            } else {\n                PJ_LOG(5, (tp->name, \"SO_RCVBUF set to %d\", sobuf_size));\n            }\n        }\n    }\n#endif\n#if PJMEDIA_TRANSPORT_SO_SNDBUF_SIZE\n    {\n        unsigned sobuf_size = PJMEDIA_TRANSPORT_SO_SNDBUF_SIZE;\n\n        status = pj_sock_setsockopt_sobuf(udp->rtp_sock, pj_SO_SNDBUF(),\n                                          PJ_TRUE, &sobuf_size);\n        if (status != PJ_SUCCESS) {\n            pj_perror(3, tp->name, status, \"Failed setting SO_SNDBUF\");\n        } else {\n            if (sobuf_size < PJMEDIA_TRANSPORT_SO_SNDBUF_SIZE) {\n                PJ_LOG(4, (tp->name, \n                           \"Warning! Cannot set SO_SNDBUF as configured, \"\n                           \"now=%d, configured=%d\",\n                           sobuf_size, PJMEDIA_TRANSPORT_SO_SNDBUF_SIZE));\n            } else {\n                PJ_LOG(5, (tp->name, \"SO_SNDBUF set to %d\", sobuf_size));\n            }\n        }\n    }\n#endif\n\n    /* Unlock keys */\n    pj_ioqueue_unlock_key(udp->rtcp_key);\n    pj_ioqueue_unlock_key(udp->rtp_key);\n\n    PJ_LOG(4,(udp->base.name, \"UDP media transport attached\"));\n\n    return PJ_SUCCESS;\n}\n\n\n/* Called by application to initialize the transport */\nstatic pj_status_t transport_attach(   pjmedia_transport *tp,\n                                       void *user_data,\n                                       const pj_sockaddr_t *rem_addr,\n                                       const pj_sockaddr_t *rem_rtcp,\n                                       unsigned addr_len,\n                                       void (*rtp_cb)(void*,\n                                                      void*,\n                                                      pj_ssize_t),\n                                       void (*rtcp_cb)(void*,\n                                                       void*,\n                                                       pj_ssize_t))\n{\n    return tp_attach(tp, user_data, rem_addr, rem_rtcp, addr_len,\n                     rtp_cb, NULL, rtcp_cb);\n}\n\n\nstatic pj_status_t transport_attach2(pjmedia_transport *tp,\n                                     pjmedia_transport_attach_param *att_param)\n{\n    return tp_attach(tp, att_param->user_data, \n                            (pj_sockaddr_t*)&att_param->rem_addr, \n                            (pj_sockaddr_t*)&att_param->rem_rtcp, \n                            att_param->addr_len, att_param->rtp_cb,\n                            att_param->rtp_cb2, \n                            att_param->rtcp_cb);\n}\n\n\n/* Called by application when it no longer needs the transport */\nstatic void transport_detach( pjmedia_transport *tp,\n                              void *user_data)\n{\n    struct transport_udp *udp = (struct transport_udp*) tp;\n\n    pj_assert(tp);\n\n    //if (udp->attached) {\n    if (1) {\n        /* Lock the ioqueue keys to make sure that callbacks are\n         * not executed. See ticket #460 for details.\n         */\n\n        TRACE_((udp->base.name, \"detach(): before locking keys\"));\n\n        pj_ioqueue_lock_key(udp->rtp_key);\n        pj_ioqueue_lock_key(udp->rtcp_key);\n\n        TRACE_((udp->base.name, \"detach(): inside locked keys\"));\n\n        /* User data is unreferenced on Release build */\n        PJ_UNUSED_ARG(user_data);\n\n        /* As additional checking, check if the same user data is specified */\n        pj_assert(!udp->user_data || user_data == udp->user_data);\n\n        /* First, mark transport as unattached */\n        //udp->attached = PJ_FALSE;\n\n        /* Clear up application infos from transport */\n        udp->rtp_cb = NULL;\n        udp->rtp_cb2 = NULL;\n        udp->rtcp_cb = NULL;\n        udp->user_data = NULL;\n\n        /* Cancel any outstanding operations */\n        pj_ioqueue_clear_key(udp->rtp_key);\n        pj_ioqueue_clear_key(udp->rtcp_key);\n\n        /* Set key status to 'stopped' as keys have been cleared */\n        udp->started = PJ_FALSE;\n\n        /* Unlock keys */\n        pj_ioqueue_unlock_key(udp->rtcp_key);\n        pj_ioqueue_unlock_key(udp->rtp_key);\n\n        PJ_LOG(4,(udp->base.name, \"UDP media transport detached\"));\n    }\n}\n\n\n/* Called by application to send RTP packet */\nstatic pj_status_t transport_send_rtp( pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size)\n{\n    struct transport_udp *udp = (struct transport_udp*)tp;\n    pj_ssize_t sent;\n    unsigned id;\n    struct pending_write *pw;\n    pj_status_t status;\n\n    /* Must be attached */\n    //PJ_ASSERT_RETURN(udp->attached, PJ_EINVALIDOP);\n\n    /* Check that the size is supported */\n    PJ_ASSERT_RETURN(size <= PJMEDIA_MAX_MTU, PJ_ETOOBIG);\n\n    if (!udp->started) {\n        return PJ_SUCCESS;\n    }\n\n    /* Simulate packet lost on TX direction */\n    if (udp->tx_drop_pct) {\n        if ((pj_rand() % 100) <= (int)udp->tx_drop_pct) {\n            PJ_LOG(5,(udp->base.name, \n                      \"TX RTP packet dropped because of pkt lost \"\n                      \"simulation\"));\n            return PJ_SUCCESS;\n        }\n    }\n\n\n    id = udp->rtp_write_op_id;\n    pw = &udp->rtp_pending_write[id];\n    if (pw->is_pending) {\n        /* There is still currently pending operation for this buffer. */\n        PJ_LOG(4,(udp->base.name, \"Too many pending write operations\"));\n        return PJ_EBUSY;\n    }\n    pw->is_pending = PJ_TRUE;\n\n    /* We need to copy packet to our buffer because when the\n     * operation is pending, caller might write something else\n     * to the original buffer.\n     */\n    pj_memcpy(pw->buffer, pkt, size);\n\n    sent = size;\n    status = pj_ioqueue_sendto( udp->rtp_key, \n                                &udp->rtp_pending_write[id].op_key,\n                                pw->buffer, &sent, 0,\n                                &udp->rem_rtp_addr, \n                                udp->addr_len);\n\n    if (status != PJ_EPENDING) {\n        /* Send operation has completed immediately. Clear the flag. */\n        pw->is_pending = PJ_FALSE;\n    }\n\n    udp->rtp_write_op_id = (udp->rtp_write_op_id + 1) %\n                           PJ_ARRAY_SIZE(udp->rtp_pending_write);\n\n    if (status==PJ_SUCCESS || status==PJ_EPENDING)\n        return PJ_SUCCESS;\n\n    return status;\n}\n\n/* Called by application to send RTCP packet */\nstatic pj_status_t transport_send_rtcp(pjmedia_transport *tp,\n                                       const void *pkt,\n                                       pj_size_t size)\n{\n    return transport_send_rtcp2(tp, NULL, 0, pkt, size);\n}\n\n\n/* Called by application to send RTCP packet */\nstatic pj_status_t transport_send_rtcp2(pjmedia_transport *tp,\n                                        const pj_sockaddr_t *addr,\n                                        unsigned addr_len,\n                                        const void *pkt,\n                                        pj_size_t size)\n{\n    struct transport_udp *udp = (struct transport_udp*)tp;\n    pj_ssize_t sent;\n    pj_status_t status;\n\n    //PJ_ASSERT_RETURN(udp->attached, PJ_EINVALIDOP);\n\n    if (!udp->started) {\n        return PJ_SUCCESS;\n    }\n\n    if (addr == NULL) {\n        addr = &udp->rem_rtcp_addr;\n        addr_len = udp->addr_len;\n    }\n\n    sent = size;\n    status = pj_ioqueue_sendto( (udp->use_rtcp_mux? udp->rtp_key:\n                                 udp->rtcp_key), &udp->rtcp_write_op,\n                                pkt, &sent, 0, addr, addr_len);\n\n    if (status==PJ_SUCCESS || status==PJ_EPENDING)\n        return PJ_SUCCESS;\n\n    return status;\n}\n\n\nstatic pj_status_t transport_media_create(pjmedia_transport *tp,\n                                  pj_pool_t *pool,\n                                  unsigned options,\n                                  const pjmedia_sdp_session *sdp_remote,\n                                  unsigned media_index)\n{\n    struct transport_udp *udp = (struct transport_udp*)tp;\n\n    PJ_ASSERT_RETURN(tp && pool, PJ_EINVAL);\n    udp->media_options = options;\n    udp->enable_rtcp_mux = ((options & PJMEDIA_TPMED_RTCP_MUX) != 0);\n\n    PJ_UNUSED_ARG(sdp_remote);\n    PJ_UNUSED_ARG(media_index);\n\n    PJ_LOG(4,(udp->base.name, \"UDP media transport created\"));\n\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t transport_encode_sdp(pjmedia_transport *tp,\n                                        pj_pool_t *pool,\n                                        pjmedia_sdp_session *sdp_local,\n                                        const pjmedia_sdp_session *rem_sdp,\n                                        unsigned media_index)\n{\n    struct transport_udp *udp = (struct transport_udp*)tp;\n\n    /* Validate media transport */\n    /* By now, this transport only support RTP/AVP transport */\n    if ((udp->media_options & PJMEDIA_TPMED_NO_TRANSPORT_CHECKING) == 0) {\n        pjmedia_sdp_media *m_rem, *m_loc;\n        pj_uint32_t tp_proto_loc, tp_proto_rem;\n\n        m_rem = rem_sdp? rem_sdp->media[media_index] : NULL;\n        m_loc = sdp_local->media[media_index];\n\n        tp_proto_loc = pjmedia_sdp_transport_get_proto(&m_loc->desc.transport);\n        tp_proto_rem = m_rem? \n                pjmedia_sdp_transport_get_proto(&m_rem->desc.transport) : 0;\n        PJMEDIA_TP_PROTO_TRIM_FLAG(tp_proto_loc, PJMEDIA_TP_PROFILE_RTCP_FB);\n        PJMEDIA_TP_PROTO_TRIM_FLAG(tp_proto_rem, PJMEDIA_TP_PROFILE_RTCP_FB);\n\n        if ((tp_proto_loc != PJMEDIA_TP_PROTO_RTP_AVP) ||\n            (m_rem && tp_proto_rem != PJMEDIA_TP_PROTO_RTP_AVP))\n        {\n            pjmedia_sdp_media_deactivate(pool, m_loc);\n            return PJMEDIA_SDP_EINPROTO;\n        }\n    }\n    \n    if (udp->enable_rtcp_mux) {\n        pjmedia_sdp_media *m = sdp_local->media[media_index];\n        pjmedia_sdp_attr *attr;\n        pj_bool_t add_rtcp_mux = PJ_TRUE;\n\n        udp->use_rtcp_mux = PJ_FALSE;\n\n        /* Check if remote wants RTCP mux */\n        if (rem_sdp) {\n            pjmedia_sdp_media *rem_m = rem_sdp->media[media_index];\n            \n            attr = pjmedia_sdp_attr_find(rem_m->attr_count, rem_m->attr, \n                                         &STR_RTCP_MUX, NULL);\n            udp->use_rtcp_mux = (attr? PJ_TRUE: PJ_FALSE);\n            add_rtcp_mux = udp->use_rtcp_mux;\n        }\n\n        /* Remove RTCP attribute because for subsequent offers/answers,\n         * the address (obtained from transport_get_info() ) may be\n         * incorrect if we are not yet confirmed to use RTCP mux\n         * (because we are still waiting for remote answer) or\n         * if remote rejects it.\n         */\n        pjmedia_sdp_attr_remove_all(&m->attr_count, m->attr, \"rtcp\");\n        \n        if (!udp->use_rtcp_mux) {\n           /* Add RTCP attribute if the remote doesn't offer or\n            * rejects it.\n            */\n            attr = pjmedia_sdp_attr_create_rtcp(pool,\n                                                &udp->rtcp_addr_name);  \n            if (attr)\n                pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n        }\n\n        /* Add a=rtcp-mux attribute. */\n        if (add_rtcp_mux) {\n            attr = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_attr);\n            attr->name = STR_RTCP_MUX;\n            m->attr[m->attr_count++] = attr;\n        }\n    }\n\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_status_t transport_media_start(pjmedia_transport *tp,\n                                  pj_pool_t *pool,\n                                  const pjmedia_sdp_session *sdp_local,\n                                  const pjmedia_sdp_session *sdp_remote,\n                                  unsigned media_index)\n{\n    struct transport_udp *udp = (struct transport_udp*)tp;\n    pj_ssize_t size;\n    pj_status_t status;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    PJ_UNUSED_ARG(pool);\n    PJ_UNUSED_ARG(sdp_local);\n    PJ_UNUSED_ARG(sdp_remote);\n    PJ_UNUSED_ARG(media_index);\n\n    /* Just return success if there is already pending read */\n    if (udp->started) {\n        PJ_LOG(5,(udp->base.name, \"UDP media transport already started\"));\n        return PJ_SUCCESS;\n    }\n\n    pj_ioqueue_op_key_init(&udp->rtp_read_op, sizeof(udp->rtp_read_op));\n    for (i=0; i<PJ_ARRAY_SIZE(udp->rtp_pending_write); ++i) {\n        pj_ioqueue_op_key_init(&udp->rtp_pending_write[i].op_key, \n                               sizeof(udp->rtp_pending_write[i].op_key));\n    }\n\n    pj_ioqueue_op_key_init(&udp->rtcp_read_op, sizeof(udp->rtcp_read_op));\n    pj_ioqueue_op_key_init(&udp->rtcp_write_op, sizeof(udp->rtcp_write_op));\n\n    TRACE_((udp->base.name, \"media_start(): before recvfrom RTP\"));\n\n    /* Kick off pending RTP read from the ioqueue */\n    udp->rtp_addrlen = sizeof(udp->rtp_src_addr);\n    size = sizeof(udp->rtp_pkt);\n    status = pj_ioqueue_recvfrom(udp->rtp_key, &udp->rtp_read_op,\n                                 udp->rtp_pkt, &size, PJ_IOQUEUE_ALWAYS_ASYNC,\n                                 &udp->rtp_src_addr, &udp->rtp_addrlen);\n    if (status != PJ_EPENDING) {\n        PJ_PERROR(3, (udp->base.name, status,\n                      \"media_start(): recvfrom RTP failed\"));\n        return status;\n    }\n\n    TRACE_((udp->base.name, \"media_start(): before recvfrom RTCP\"));\n\n    /* Kick off pending RTCP read from the ioqueue */\n    udp->rtcp_addr_len = sizeof(udp->rtcp_src_addr);\n    size = sizeof(udp->rtcp_pkt);\n    status = pj_ioqueue_recvfrom(udp->rtcp_key, &udp->rtcp_read_op,\n                                 udp->rtcp_pkt, &size,\n                                 PJ_IOQUEUE_ALWAYS_ASYNC,\n                                 &udp->rtcp_src_addr, &udp->rtcp_addr_len);\n    if (status != PJ_EPENDING) {\n        PJ_PERROR(3, (udp->base.name, status,\n                      \"media_start(): recvfrom RTCP failed\"));\n        pj_ioqueue_clear_key(udp->rtp_key);\n        return status;\n    }\n\n    udp->started = PJ_TRUE;\n\n    PJ_LOG(4,(udp->base.name, \"UDP media transport started\"));\n\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t transport_media_stop(pjmedia_transport *tp)\n{\n    struct transport_udp *udp = (struct transport_udp*)tp;\n\n    PJ_ASSERT_RETURN(tp, PJ_EINVAL);\n\n    /* Just return success if there is no pending read */\n    if (!udp->started) {\n        PJ_LOG(5, (udp->base.name, \"UDP media transport already stopped\"));\n        return PJ_SUCCESS;\n    }\n\n    pj_ioqueue_clear_key(udp->rtp_key);\n    pj_ioqueue_clear_key(udp->rtcp_key);\n\n    udp->started = PJ_FALSE;\n\n    PJ_LOG(4, (udp->base.name, \"UDP media transport stopped\"));\n\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t transport_simulate_lost(pjmedia_transport *tp,\n                                           pjmedia_dir dir,\n                                           unsigned pct_lost)\n{\n    struct transport_udp *udp = (struct transport_udp*)tp;\n\n    PJ_ASSERT_RETURN(tp && pct_lost <= 100, PJ_EINVAL);\n\n    if (dir & PJMEDIA_DIR_ENCODING)\n        udp->tx_drop_pct = pct_lost;\n    \n    if (dir & PJMEDIA_DIR_DECODING)\n        udp->rx_drop_pct = pct_lost;\n\n    return PJ_SUCCESS;\n}\n\nstatic pj_status_t transport_restart(pj_bool_t is_rtp, \n                                     struct transport_udp *udp)\n{\n    PJ_UNUSED_ARG(udp);\n    PJ_UNUSED_ARG(is_rtp);\n\n    return PJ_ENOTSUP;\n\n/* This code is disabled for the following reason (see also #2881):\n * The following code will set ioqueue key to NULL or replace with a new one,\n * and that may introduces issues, e.g:\n * - this code is invoked from on_rx_rtp/rtcp(), which is invoked by\n *   ioqueue_dispatch_read_event(), which may need to unlock ioqueue key\n *   after returning from the callback (when allow_concurrent is false),\n *   if the ioqueue key has been unregistered by this code, a crash may occur\n *   when unlocking the invalid ioqueue key.\n * - this code may set ioqueue key to NULL, while other code may assume\n *   it may never be changed to NULL, and cause crash, e.g: transport_detach().\n */\n#if 0\n\n    pj_ioqueue_key_t *key = (is_rtp ? udp->rtp_key : udp->rtcp_key);\n    pj_sock_t *sock = (is_rtp ? &udp->rtp_sock : &udp->rtcp_sock);\n    pj_status_t status;\n    int af;\n    pj_sockaddr *addr;\n    pj_ioqueue_callback cb;\n    pj_ssize_t size;\n\n    PJ_LOG(4, (udp->base.name, \"Restarting %s transport\", \n              (is_rtp)?\"RTP\":\"RTCP\"));\n\n    udp->started = PJ_FALSE;\n    /* Destroy existing socket, if any. */    \n    if (key) {\n        /* This will block the execution if callback is still\n         * being called.\n         */\n        pj_ioqueue_unregister(key);\n        if (is_rtp) {\n            udp->rtp_key = NULL;\n        } else {\n            udp->rtcp_key = NULL;\n        }\n    } else if (*sock != PJ_INVALID_SOCKET) {\n        pj_sock_close(*sock);\n    }\n    *sock = PJ_INVALID_SOCKET;   \n\n    /* Create socket */\n    af = udp->rtp_addr_name.addr.sa_family;\n    status = pj_sock_socket(af, pj_SOCK_DGRAM(), 0, sock);\n\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    addr = (is_rtp) ? &udp->rtp_addr_name : &udp->rtcp_addr_name;\n    status = pj_sock_bind(*sock, addr, pj_sockaddr_get_len(addr));\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    /* Set buffer size for RTP socket */\n#if PJMEDIA_TRANSPORT_SO_RCVBUF_SIZE\n    if (is_rtp) {\n        unsigned sobuf_size = PJMEDIA_TRANSPORT_SO_RCVBUF_SIZE;\n\n        pj_sock_setsockopt_sobuf(udp->rtp_sock, pj_SO_RCVBUF(), \n                                 PJ_TRUE, &sobuf_size);\n    }\n#endif\n#if PJMEDIA_TRANSPORT_SO_SNDBUF_SIZE\n    if (is_rtp) {\n        unsigned sobuf_size = PJMEDIA_TRANSPORT_SO_SNDBUF_SIZE;\n\n        pj_sock_setsockopt_sobuf(udp->rtp_sock, pj_SO_SNDBUF(), \n                                 PJ_TRUE, &sobuf_size);\n    }\n#endif\n    pj_bzero(&cb, sizeof(cb));\n    if (is_rtp) {\n        cb.on_read_complete = &on_rx_rtp;\n        cb.on_write_complete = &on_rtp_data_sent;\n    } else {\n        cb.on_read_complete = &on_rx_rtcp;\n    }\n\n    if (is_rtp) {\n        status = pj_ioqueue_register_sock(udp->pool, udp->ioqueue, *sock, udp,\n                                          &cb, &udp->rtp_key);\n    } else {\n        status = pj_ioqueue_register_sock(udp->pool, udp->ioqueue, *sock, udp,\n                                          &cb, &udp->rtcp_key);    \n    }\n\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    if (is_rtp) {\n        size = sizeof(udp->rtp_pkt);\n        status = pj_ioqueue_recvfrom(udp->rtp_key, &udp->rtp_read_op,\n                                     udp->rtp_pkt, &size, \n                                     PJ_IOQUEUE_ALWAYS_ASYNC,\n                                     &udp->rtp_src_addr, &udp->rtp_addrlen);\n    } else {\n        size = sizeof(udp->rtcp_pkt);\n        status = pj_ioqueue_recvfrom(udp->rtcp_key, &udp->rtcp_read_op,\n                                     udp->rtcp_pkt, &size, \n                                     PJ_IOQUEUE_ALWAYS_ASYNC,\n                                     &udp->rtcp_src_addr, &udp->rtcp_addr_len);\n    }\n    if (status != PJ_EPENDING)\n        goto on_error;\n\n    udp->started = PJ_TRUE;\n    PJ_LOG(4, (udp->base.name, \"Success restarting %s transport\", \n              (is_rtp)?\"RTP\":\"RTCP\"));\n    return PJ_SUCCESS;\non_error:\n    if (*sock != PJ_INVALID_SOCKET) {\n        pj_sock_close(*sock);\n        *sock = PJ_INVALID_SOCKET;\n    }\n    PJ_PERROR(1, (udp->base.name, status, \n                 \"Error restarting %s transport\", (is_rtp)?\"RTP\":\"RTCP\"));\n    return status;\n\n#endif\n}\n"], "filenames": ["pjmedia/include/pjmedia/transport.h", "pjmedia/src/pjmedia/transport_adapter_sample.c", "pjmedia/src/pjmedia/transport_ice.c", "pjmedia/src/pjmedia/transport_loop.c", "pjmedia/src/pjmedia/transport_srtp.c", "pjmedia/src/pjmedia/transport_srtp_dtls.c", "pjmedia/src/pjmedia/transport_udp.c"], "buggy_code_start_loc": [515, 108, 340, 132, 436, 82, 300], "buggy_code_end_loc": [515, 438, 2747, 429, 1490, 1841, 460], "fixing_code_start_loc": [516, 109, 341, 133, 437, 83, 301], "fixing_code_end_loc": [519, 461, 2753, 457, 1529, 1896, 476], "type": "CWE-416", "message": "PJSIP is a free and open source multimedia communication library written in C with high level API in C, C++, Java, C#, and Python languages. SRTP is a higher level media transport which is stacked upon a lower level media transport such as UDP and ICE. Currently a higher level transport is not synchronized with its lower level transport that may introduce use-after-free issue. This vulnerability affects applications that have SRTP capability (`PJMEDIA_HAS_SRTP` is set) and use underlying media transport other than UDP. This vulnerability\u2019s impact may range from unexpected application termination to control flow hijack/memory corruption. The patch is available as a commit in the master branch.\n", "other": {"cve": {"id": "CVE-2023-38703", "sourceIdentifier": "security-advisories@github.com", "published": "2023-10-06T14:15:12.020", "lastModified": "2023-12-29T00:15:49.813", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "PJSIP is a free and open source multimedia communication library written in C with high level API in C, C++, Java, C#, and Python languages. SRTP is a higher level media transport which is stacked upon a lower level media transport such as UDP and ICE. Currently a higher level transport is not synchronized with its lower level transport that may introduce use-after-free issue. This vulnerability affects applications that have SRTP capability (`PJMEDIA_HAS_SRTP` is set) and use underlying media transport other than UDP. This vulnerability\u2019s impact may range from unexpected application termination to control flow hijack/memory corruption. The patch is available as a commit in the master branch.\n"}, {"lang": "es", "value": "PJSIP es una librer\u00eda de comunicaci\u00f3n multimedia gratuita y de c\u00f3digo abierto escrita en C con API de alto nivel en los lenguajes C, C++, Java, C# y Python. SRTP es un transporte de medios de nivel superior que se apila sobre un transporte de medios de nivel inferior, como UDP e ICE. Actualmente, un transporte de nivel superior no est\u00e1 sincronizado con su transporte de nivel inferior, lo que puede introducir un problema de use-after-free. Esta vulnerabilidad afecta a las aplicaciones que tienen capacidad SRTP (`PJMEDIA_HAS_SRTP` est\u00e1 configurado) y utilizan transporte de medios subyacente distinto de UDP. El impacto de esta vulnerabilidad puede variar desde la terminaci\u00f3n inesperada de la aplicaci\u00f3n hasta el secuestro de flujo de control/corrupci\u00f3n de memoria. El parche est\u00e1 disponible como commit en la rama master."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:teluu:pjsip:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.13.1", "matchCriteriaId": "18445C5E-4DC0-4E50-8E25-1CE15925AAC1"}]}]}], "references": [{"url": "https://github.com/pjsip/pjproject/commit/6dc9b8c181aff39845f02b4626e0812820d4ef0d", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-f76w-fh7c-pc66", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/12/msg00019.html", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/pjsip/pjproject/commit/6dc9b8c181aff39845f02b4626e0812820d4ef0d"}}