{"buggy_code": ["// Copyright (C) 2004-2021 Artifex Software, Inc.\n//\n// This file is part of MuPDF.\n//\n// MuPDF is free software: you can redistribute it and/or modify it under the\n// terms of the GNU Affero General Public License as published by the Free\n// Software Foundation, either version 3 of the License, or (at your option)\n// any later version.\n//\n// MuPDF is distributed in the hope that it will be useful, but WITHOUT ANY\n// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n// FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more\n// details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with MuPDF. If not, see <https://www.gnu.org/licenses/agpl-3.0.en.html>\n//\n// Alternative licensing terms are available from the licensor.\n// For commercial licensing, see <https://www.artifex.com/> or contact\n// Artifex Software, Inc., 1305 Grant Avenue - Suite 200, Novato,\n// CA 94945, U.S.A., +1(415)492-9861, for further information.\n\n/*\n * muraster -- Convert a document to a raster file.\n *\n * Deliberately simple. Designed to be a basis for what\n * printer customers would need.\n *\n * Therefore; only supports pgm, ppm, pam, pbm, pkm,\n * and then only dependent on the FZ_PLOTTERS_{G,RGB,CMYK}\n * flags.\n * Only supports banding.\n * Supports auto fallback to grey if possible.\n * Supports threading.\n * Supports fallback in low memory cases.\n */\n\n/*\n\tCONFIGURATION SECTION\n\n\tThe first bit of configuration for this is actually in\n\thow the muthreads helper library is built. If muthreads\n\tdoes not know how to support threading on your system\n\tthen it will ensure that DISABLE_MUTHREADS is set. All\n\tthe muthreads entrypoints/types will still be defined\n\t(as dummy types/functions), but attempting to use them\n\twill return errors.\n\n\tConfiguration options affecting threading should be\n\tturned off if DISABLE_MUTHREADS is set.\n\n\tIntegrators can/should define the following\n\tMURASTER_CONFIG_ values. If not set, we'll\n\tattempt to set sensible defaults.\n*/\n\n/*\n\tMURASTER_CONFIG_RENDER_THREADS: The number of render\n\tthreads to use. Typically you would set this to the\n\tnumber of CPU cores - 1 (or -2 if background printing\n\tis used).\n\n\tIf no threading library exists for your OS set this\n\tto 0.\n\n\tIf undefined, we will use a default of\n\t3 - MURASTER_CONFIG_BGPRINT.\n*/\n/* #define MURASTER_CONFIG_RENDER_THREADS 3 */\n\n/*\n\tMURASTER_CONFIG_BGPRINT: 0 or 1. Set to 1 to\n\tenable background printing. This relies on\n\ta threading library existing for the OS.\n\n\tIf undefined, we will use a default of 1.\n*/\n/* #define MURASTER_CONFIG_BGPRINT 1 */\n\n/*\n\tMURASTER_CONFIG_X_RESOLUTION: The default X resolution\n\tin dots per inch. If undefined, taken to be 300dpi.\n*/\n/* #define MURASTER_CONFIG_X_RESOLUTION 300 */\n\n/*\n\tMURASTER_CONFIG_Y_RESOLUTION: The default Y resolution\n\tin dots per inch. If undefined, taken to be 300dpi.\n*/\n/* #define MURASTER_CONFIG_Y_RESOLUTION 300 */\n\n/*\n\tMURASTER_CONFIG_WIDTH: The printable page width\n\t(in inches)\n*/\n/* #define MURASTER_CONFIG_WIDTH 8.27f */\n\n/*\n\tMURASTER_CONFIG_HEIGHT: The printable page height\n\t(in inches)\n*/\n/* #define MURASTER_CONFIG_HEIGHT 11.69f */\n\n/*\n\tMURASTER_CONFIG_STORE_SIZE: The maximum size to use\n\tfor the fz_store.\n\n\tIf undefined, then on Linux we will attempt to guess\n\tthe memory size, and we'll use that for the store\n\tsize. This will be too large, but it should work OK.\n\n\tIf undefined and NOT linux, then we'll use the default\n\tstore size.\n*/\n/* #define MURASTER_CONFIG_STORE_SIZE FZ_STORE_DEFAULT */\n\n/*\n\tMURASTER_CONFIG_MIN_BAND_HEIGHT: The minimum band\n\theight we will ever use. This might correspond to the\n\tnumber of nozzles on an inkjet head.\n\n\tBy default, we'll use 32.\n*/\n/* #define MURASTER_CONFIG_MIN_BAND_HEIGHT 32 */\n\n/*\n\tMURASTER_CONFIG_BAND_MEMORY: The maximum amount of\n\tmemory (in bytes) to use for any given band.\n\n\tWe will need MURASTER_CONFIG_RENDER_THREADS of these,\n\tone for each render thread.\n\n\tHaving this be a multiple of\n\tMURASTER_CONFIG_MIN_BAND_HEIGHT * MURASTER_CONFIG_MAX_WIDTH * MURASTER_CONFIG_X_RESOLUTION * N\n\twould be sensible.\n\n\t(Where N = 1 for greyscale, 3 for RGB, 4 for CMYK)\n*/\n/* #define MURASTER_CONFIG_BAND_MEMORY (32*10*300*4*16) */\n\n/*\n\tMURASTER_CONFIG_GREY_FALLBACK: 0, 1 or 2.\n\n\tSet to 1 to fallback to grey rendering if the page\n\tis definitely grey. Any images in colored color\n\tspaces will be assumed to be color. This may refuse\n\tto fallback in some cases when it could have done.\n\n\tSet to 2 to fallback to grey rendering if the page\n\tis definitely grey. Any images in colored color\n\tspaces will be exhaustively checked. This will\n\tfallback whenever possible, at the expense of some\n\truntime as more processing is required to check.\n*/\n/* #define MURASTER_CONFIG_GREY_FALLBACK 1 */\n\n/*\n\tEND OF CONFIGURATION SECTION\n*/\n\n#include \"mupdf/fitz.h\"\n#include \"mupdf/helpers/mu-threads.h\"\n\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#ifdef _MSC_VER\nstruct timeval;\nstruct timezone;\nint gettimeofday(struct timeval *tv, struct timezone *tz);\n#else\n#include <sys/time.h>\n#endif\n\n/*\n\tAfter this point, we convert the #defines set (or not set)\n\tabove into sensible values we can work with. Don't edit\n\tthese for configuration.\n*/\n\n/* Unless we have specifically disabled threading, enable it. */\n#ifndef DISABLE_MUTHREADS\n#ifndef MURASTER_THREADS\n#define MURASTER_THREADS 1\n#endif\n#endif\n\n/* If we have threading, and we haven't already configured BGPRINT,\n * enable it. */\n#if MURASTER_THREADS != 0\n#ifndef MURASTER_CONFIG_BGPRINT\n#define MURASTER_CONFIG_BGPRINT 1\n#endif\n#endif\n\n#ifdef MURASTER_CONFIG_X_RESOLUTION\n#define X_RESOLUTION MURASTER_CONFIG_X_RESOLUTION\n#else\n#define X_RESOLUTION 300\n#endif\n\n#ifdef MURASTER_CONFIG_Y_RESOLUTION\n#define Y_RESOLUTION MURASTER_CONFIG_Y_RESOLUTION\n#else\n#define Y_RESOLUTION 300\n#endif\n\n#ifdef MURASTER_CONFIG_WIDTH\n#define PAPER_WIDTH MURASTER_CONFIG_WIDTH\n#else\n#define PAPER_WIDTH 8.27f\n#endif\n\n#ifdef MURASTER_CONFIG_HEIGHT\n#define PAPER_HEIGHT MURASTER_CONFIG_HEIGHT\n#else\n#define PAPER_HEIGHT 11.69f\n#endif\n\n#ifdef MURASTER_CONFIG_STORE_SIZE\n#define STORE_SIZE MURASTER_CONFIG_STORE_SIZE\n#else\n#define STORE_SIZE FZ_STORE_SIZE\n#endif\n\n#ifdef MURASTER_CONFIG_MIN_BAND_HEIGHT\n#define MIN_BAND_HEIGHT MURASTER_CONFIG_MIN_BAND_HEIGHT\n#else\n#define MIN_BAND_HEIGHT 32\n#endif\n\n#ifdef MURASTER_CONFIG_BAND_MEMORY\n#define BAND_MEMORY MURASTER_CONFIG_BAND_MEMORY\n#else\n#if defined(FZ_PLOTTERS_CMYK) || defined(FZ_PLOTTERS_N)\n#define BAND_MEMORY (MIN_BAND_HEIGHT * PAPER_WIDTH * X_RESOLUTION * 4 * 16)\n#elif defined(FZ_PLOTTERS_RGB)\n#define BAND_MEMORY (MIN_BAND_HEIGHT * PAPER_WIDTH * X_RESOLUTION * 3 * 16)\n#else\n#define BAND_MEMORY (MIN_BAND_HEIGHT * PAPER_WIDTH * X_RESOLUTION * 1 * 16)\n#endif\n#endif\n\n#ifdef MURASTER_CONFIG_GREY_FALLBACK\n#define GREY_FALLBACK MURASTER_CONFIG_GREY_FALLBACK\n#else\n#ifdef FZ_PLOTTERS_N\n#define GREY_FALLBACK 1\n#elif defined(FZ_PLOTTERS_G) && (defined(FZ_PLOTTERS_RGB) || defined(FZ_PLOTTERS_CMYK))\n#define GREY_FALLBACK 1\n#else\n#define GREY_FALLBACK 0\n#endif\n#endif\n\n#if GREY_FALLBACK != 0 && !defined(FZ_PLOTTERS_N) && !defined(FZ_PLOTTERS_G)\n#error MURASTER_CONFIG_GREY_FALLBACK requires either FZ_PLOTTERS_N or FZ_PLOTTERS_G\n#endif\n\n/* Enable for helpful threading debug */\n/* #define DEBUG_THREADS(A) do { printf A; fflush(stdout); } while (0) */\n#define DEBUG_THREADS(A) do { } while (0)\n\nenum {\n\tOUT_PGM,\n\tOUT_PPM,\n\tOUT_PAM,\n\tOUT_PBM,\n\tOUT_PKM\n};\n\nenum {\n\tCS_GRAY,\n\tCS_RGB,\n\tCS_CMYK\n};\n\ntypedef struct\n{\n\tchar *suffix;\n\tint format;\n\tint cs;\n} suffix_t;\n\nstatic const suffix_t suffix_table[] =\n{\n#if FZ_PLOTTERS_G || FZ_PLOTTERS_N\n\t{ \".pgm\", OUT_PGM, CS_GRAY },\n#endif\n#if FZ_PLOTTERS_RGB || FZ_PLOTTERS_N\n\t{ \".ppm\", OUT_PPM, CS_RGB },\n#endif\n#if FZ_PLOTTERS_CMYK || FZ_PLOTTERS_N\n\t{ \".pam\", OUT_PAM, CS_CMYK },\n#endif\n#if FZ_PLOTTERS_G || FZ_PLOTTERS_N\n\t{ \".pbm\", OUT_PBM, CS_GRAY },\n#endif\n#if FZ_PLOTTERS_CMYK || FZ_PLOTTERS_N\n\t{ \".pkm\", OUT_PKM, CS_CMYK }\n#endif\n};\n\n#ifndef DISABLE_MUTHREADS\n\nstatic mu_mutex mutexes[FZ_LOCK_MAX];\n\nstatic void muraster_lock(void *user, int lock)\n{\n\tmu_lock_mutex(&mutexes[lock]);\n}\n\nstatic void muraster_unlock(void *user, int lock)\n{\n\tmu_unlock_mutex(&mutexes[lock]);\n}\n\nstatic fz_locks_context muraster_locks =\n{\n\tNULL, muraster_lock, muraster_unlock\n};\n\nstatic void fin_muraster_locks(void)\n{\n\tint i;\n\n\tfor (i = 0; i < FZ_LOCK_MAX; i++)\n\t\tmu_destroy_mutex(&mutexes[i]);\n}\n\nstatic fz_locks_context *init_muraster_locks(void)\n{\n\tint i;\n\tint failed = 0;\n\n\tfor (i = 0; i < FZ_LOCK_MAX; i++)\n\t\tfailed |= mu_create_mutex(&mutexes[i]);\n\n\tif (failed)\n\t{\n\t\tfin_muraster_locks();\n\t\treturn NULL;\n\t}\n\n\treturn &muraster_locks;\n}\n\n#endif\n\n#ifdef MURASTER_CONFIG_RENDER_THREADS\n#define NUM_RENDER_THREADS MURASTER_CONFIG_RENDER_THREADS\n#elif defined(DISABLE_MUTHREADS)\n#define NUM_RENDER_THREADS 0\n#else\n#define NUM_RENDER_THREADS 3\n#endif\n\n#if defined(DISABLE_MUTHREADS) && NUM_RENDER_THREADS != 0\n#error \"Can't have MURASTER_CONFIG_RENDER_THREADS > 0 without having a threading library!\"\n#endif\n\n#ifdef MURASTER_CONFIG_BGPRINT\n#define BGPRINT MURASTER_CONFIG_BGPRINT\n#elif MURASTER_THREADS == 0\n#define BGPRINT 0\n#else\n#define BGPRINT 1\n#endif\n\n#if defined(DISABLE_MUTHREADS) && BGPRINT != 0\n#error \"Can't have MURASTER_CONFIG_BGPRINT > 0 without having a threading library!\"\n#endif\n\ntypedef struct worker_t {\n\tfz_context *ctx;\n\tint started;\n\tint status;\n\tint num;\n\tint band_start; /* -1 to shutdown, or offset of band to render */\n\tfz_display_list *list;\n\tfz_matrix ctm;\n\tfz_rect tbounds;\n\tfz_pixmap *pix;\n\tfz_bitmap *bit;\n\tfz_cookie cookie;\n\tmu_semaphore start;\n\tmu_semaphore stop;\n\tmu_thread thread;\n} worker_t;\n\nstatic char *output = NULL;\nstatic fz_output *out = NULL;\n\nstatic char *format;\nstatic int output_format;\nstatic int output_cs;\n\nstatic int rotation = -1;\nstatic float x_resolution;\nstatic float y_resolution;\nstatic int width = 0;\nstatic int height = 0;\nstatic int fit = 0;\n\nstatic float layout_w = FZ_DEFAULT_LAYOUT_W;\nstatic float layout_h = FZ_DEFAULT_LAYOUT_H;\nstatic float layout_em = FZ_DEFAULT_LAYOUT_EM;\nstatic char *layout_css = NULL;\nstatic int layout_use_doc_css = 1;\n\nstatic int showtime = 0;\nstatic int showmemory = 0;\n\nstatic int ignore_errors = 0;\nstatic int alphabits_text = 8;\nstatic int alphabits_graphics = 8;\n\nstatic int min_band_height;\nstatic size_t max_band_memory;\n\nstatic int errored = 0;\nstatic fz_colorspace *colorspace;\nstatic char *filename;\nstatic int num_workers = 0;\nstatic worker_t *workers;\n\ntypedef struct render_details\n{\n\t/* Page */\n\tfz_page *page;\n\n\t/* Display list */\n\tfz_display_list *list;\n\n\t/* Raw bounds */\n\tfz_rect bounds;\n\n\t/* Transformed bounds */\n\tfz_rect tbounds;\n\n\t/* Rounded transformed bounds */\n\tfz_irect ibounds;\n\n\t/* Transform matrix */\n\tfz_matrix ctm;\n\n\t/* How many min band heights are we working in? */\n\tint band_height_multiple;\n\n\t/* What colorspace are we working in? (Adjusted for fallback) */\n\tint colorspace;\n\n\t/* What output format? (Adjusted for fallback) */\n\tint format;\n\n\t/* During the course of the rendering, this keeps track of\n\t * how many 'min_band_heights' have been safely rendered. */\n\tint bands_rendered;\n\n\t/* The maximum number of workers we'll try to use. This\n\t * will start at the maximum value, and may drop to 0\n\t * if we have problems with memory. */\n\tint num_workers;\n\n\t/* The band writer to output the page */\n\tfz_band_writer *bander;\n\n\t/* Number of components in image */\n\tint n;\n} render_details;\n\nenum\n{\n\tRENDER_OK = 0,\n\tRENDER_RETRY = 1,\n\tRENDER_FATAL = 2\n};\n\nstatic struct {\n\tint active;\n\tint started;\n\tint solo;\n\tint status;\n\tfz_context *ctx;\n\tmu_thread thread;\n\tmu_semaphore start;\n\tmu_semaphore stop;\n\tint pagenum;\n\tchar *filename;\n\trender_details render;\n\tint interptime;\n} bgprint;\n\nstatic struct {\n\tint count, total;\n\tint min, max;\n\tint mininterp, maxinterp;\n\tint minpage, maxpage;\n\tchar *minfilename;\n\tchar *maxfilename;\n} timing;\n\n#define stringify(A) #A\n\nstatic int usage(void)\n{\n\tfprintf(stderr,\n\t\t\"muraster version \" FZ_VERSION \"\\n\"\n\t\t\"Usage: muraster [options] file [pages]\\n\"\n\t\t\"\\t-p -\\tpassword\\n\"\n\t\t\"\\n\"\n\t\t\"\\t-o -\\toutput file name\\n\"\n\t\t\"\\t-F -\\toutput format (default inferred from output file name)\\n\"\n\t\t\"\\t\\tpam, pbm, pgm, pkm, ppm\\n\"\n\t\t\"\\n\"\n\t\t\"\\t-s -\\tshow extra information:\\n\"\n\t\t\"\\t\\tm - show memory use\\n\"\n\t\t\"\\t\\tt - show timings\\n\"\n\t\t\"\\n\"\n\t\t\"\\t-R {auto,0,90,180,270}\\n\"\n\t\t\"\\t\\trotate clockwise (default: auto)\\n\"\n\t\t\"\\t-r -{,_}\\tx and y resolution in dpi (default: \" stringify(X_RESOLUTION) \"x\" stringify(Y_RESOLUTION) \")\\n\"\n\t\t\"\\t-w -\\tprintable width (in inches) (default: \" stringify(PAPER_WIDTH) \")\\n\"\n\t\t\"\\t-h -\\tprintable height (in inches) (default: \" stringify(PAPER_HEIGHT) \"\\n\"\n\t\t\"\\t-f\\tfit file to page if too large\\n\"\n\t\t\"\\t-B -\\tminimum band height (e.g. 32)\\n\"\n\t\t\"\\t-M -\\tmax bandmemory (e.g. 655360)\\n\"\n#ifndef DISABLE_MUTHREADS\n\t\t\"\\t-T -\\tnumber of threads to use for rendering\\n\"\n\t\t\"\\t-P\\tparallel interpretation/rendering\\n\"\n#endif\n\t\t\"\\n\"\n\t\t\"\\t-W -\\tpage width for EPUB layout\\n\"\n\t\t\"\\t-H -\\tpage height for EPUB layout\\n\"\n\t\t\"\\t-S -\\tfont size for EPUB layout\\n\"\n\t\t\"\\t-U -\\tfile name of user stylesheet for EPUB layout\\n\"\n\t\t\"\\t-X\\tdisable document styles for EPUB layout\\n\"\n\t\t\"\\n\"\n\t\t\"\\t-A -\\tnumber of bits of antialiasing (0 to 8)\\n\"\n\t\t\"\\t-A -/-\\tnumber of bits of antialiasing (0 to 8) (graphics, text)\\n\"\n\t\t\"\\n\"\n\t\t\"\\tpages\\tcomma separated list of page numbers and ranges\\n\"\n\t\t);\n\treturn 1;\n}\n\nstatic int gettime(void)\n{\n\tstatic struct timeval first;\n\tstatic int once = 1;\n\tstruct timeval now;\n\tif (once)\n\t{\n\t\tgettimeofday(&first, NULL);\n\t\tonce = 0;\n\t}\n\tgettimeofday(&now, NULL);\n\treturn (now.tv_sec - first.tv_sec) * 1000 + (now.tv_usec - first.tv_usec) / 1000;\n}\n\nstatic int drawband(fz_context *ctx, fz_page *page, fz_display_list *list, fz_matrix ctm, fz_rect tbounds, fz_cookie *cookie, int band_start, fz_pixmap *pix, fz_bitmap **bit)\n{\n\tfz_device *dev = NULL;\n\n\t*bit = NULL;\n\n\tfz_try(ctx)\n\t{\n\t\tfz_clear_pixmap_with_value(ctx, pix, 255);\n\n\t\tdev = fz_new_draw_device(ctx, fz_identity, pix);\n\t\tif (alphabits_graphics == 0)\n\t\t\tfz_enable_device_hints(ctx, dev, FZ_DONT_INTERPOLATE_IMAGES);\n\t\tif (list)\n\t\t\tfz_run_display_list(ctx, list, dev, ctm, tbounds, cookie);\n\t\telse\n\t\t\tfz_run_page(ctx, page, dev, ctm, cookie);\n\t\tfz_close_device(ctx, dev);\n\t\tfz_drop_device(ctx, dev);\n\t\tdev = NULL;\n\n\t\tif ((output_format == OUT_PBM) || (output_format == OUT_PKM))\n\t\t\t*bit = fz_new_bitmap_from_pixmap_band(ctx, pix, NULL, band_start);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_drop_device(ctx, dev);\n\t\treturn RENDER_RETRY;\n\t}\n\treturn RENDER_OK;\n}\n\nstatic int dodrawpage(fz_context *ctx, int pagenum, fz_cookie *cookie, render_details *render)\n{\n\tfz_pixmap *pix = NULL;\n\tfz_bitmap *bit = NULL;\n\tint errors_are_fatal = 0;\n\tfz_irect ibounds = render->ibounds;\n\tfz_rect tbounds = render->tbounds;\n\tint total_height = ibounds.y1 - ibounds.y0;\n\tint start_offset = min_band_height * render->bands_rendered;\n\tint remaining_start = ibounds.y0 + start_offset;\n\tint remaining_height = ibounds.y1 - remaining_start;\n\tint band_height = min_band_height * render->band_height_multiple;\n\tint bands = (remaining_height + band_height-1) / band_height;\n\tfz_matrix ctm = render->ctm;\n\tint band;\n\n\tfz_var(pix);\n\tfz_var(bit);\n\tfz_var(errors_are_fatal);\n\n\tfz_try(ctx)\n\t{\n\t\t/* Set up ibounds and tbounds for a single band_height band.\n\t\t * We will adjust ctm as we go. */\n\t\tibounds.y1 = ibounds.y0 + band_height;\n\t\ttbounds.y1 = tbounds.y0 + band_height + 2;\n\t\tDEBUG_THREADS((\"Using %d Bands\\n\", bands));\n\t\tctm.f += start_offset;\n\n\t\tif (render->num_workers > 0)\n\t\t{\n\t\t\tfor (band = 0; band < fz_mini(render->num_workers, bands); band++)\n\t\t\t{\n\t\t\t\tint band_start = start_offset + band * band_height;\n\t\t\t\tworker_t *w = &workers[band];\n\t\t\t\tw->band_start = band_start;\n\t\t\t\tw->ctm = ctm;\n\t\t\t\tw->tbounds = tbounds;\n\t\t\t\tmemset(&w->cookie, 0, sizeof(fz_cookie));\n\t\t\t\tw->list = render->list;\n\t\t\t\tif (remaining_height < band_height)\n\t\t\t\t\tibounds.y1 = ibounds.y0 + remaining_height;\n\t\t\t\tremaining_height -= band_height;\n\t\t\t\tw->pix = fz_new_pixmap_with_bbox(ctx, colorspace, ibounds, NULL, 0);\n\t\t\t\tw->pix->y += band * band_height;\n\t\t\t\tfz_set_pixmap_resolution(ctx, w->pix, x_resolution, y_resolution);\n\t\t\t\tDEBUG_THREADS((\"Worker %d, Pre-triggering band %d\\n\", band, band));\n\t\t\t\tw->started = 1;\n\t\t\t\tmu_trigger_semaphore(&w->start);\n\t\t\t}\n\t\t\tpix = workers[0].pix;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpix = fz_new_pixmap_with_bbox(ctx, colorspace, ibounds, NULL, 0);\n\t\t\tfz_set_pixmap_resolution(ctx, pix, x_resolution, y_resolution);\n\t\t}\n\n\t\tfor (band = 0; band < bands; band++)\n\t\t{\n\t\t\tint status;\n\t\t\tint band_start = start_offset + band * band_height;\n\t\t\tint draw_height = total_height - band_start;\n\n\t\t\tif (draw_height > band_height)\n\t\t\t\tdraw_height = band_height;\n\n\t\t\tif (render->num_workers > 0)\n\t\t\t{\n\t\t\t\tworker_t *w = &workers[band % render->num_workers];\n\t\t\t\tDEBUG_THREADS((\"Waiting for worker %d to complete band %d\\n\", w->num, band));\n\t\t\t\tmu_wait_semaphore(&w->stop);\n\t\t\t\tw->started = 0;\n\t\t\t\tstatus = w->status;\n\t\t\t\tpix = w->pix;\n\t\t\t\tbit = w->bit;\n\t\t\t\tw->bit = NULL;\n\t\t\t\tcookie->errors += w->cookie.errors;\n\t\t\t}\n\t\t\telse\n\t\t\t\tstatus = drawband(ctx, render->page, render->list, ctm, tbounds, cookie, band_start, pix, &bit);\n\n\t\t\tif (status != RENDER_OK)\n\t\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Render failed\");\n\n\t\t\trender->bands_rendered += render->band_height_multiple;\n\n\t\t\tif (out)\n\t\t\t{\n\t\t\t\t/* If we get any errors while outputting the bands, retrying won't help. */\n\t\t\t\terrors_are_fatal = 1;\n\t\t\t\tfz_write_band(ctx, render->bander, bit ? bit->stride : pix->stride, draw_height, bit ? bit->samples : pix->samples);\n\t\t\t\terrors_are_fatal = 0;\n\t\t\t}\n\t\t\tfz_drop_bitmap(ctx, bit);\n\t\t\tbit = NULL;\n\n\t\t\tif (render->num_workers > 0 && band + render->num_workers < bands)\n\t\t\t{\n\t\t\t\tworker_t *w = &workers[band % render->num_workers];\n\t\t\t\tw->band_start = band_start;\n\t\t\t\tw->ctm = ctm;\n\t\t\t\tw->tbounds = tbounds;\n\t\t\t\tmemset(&w->cookie, 0, sizeof(fz_cookie));\n\t\t\t\tDEBUG_THREADS((\"Triggering worker %d for band_start= %d\\n\", w->num, w->band_start));\n\t\t\t\tw->started = 1;\n\t\t\t\tmu_trigger_semaphore(&w->start);\n\t\t\t}\n\t\t\tif (render->num_workers <= 0)\n\t\t\t\tpix += draw_height;\n\t\t}\n\t}\n\tfz_always(ctx)\n\t{\n\t\tfz_drop_bitmap(ctx, bit);\n\t\tbit = NULL;\n\t\tif (render->num_workers > 0)\n\t\t{\n\t\t\tint band;\n\t\t\tfor (band = 0; band < fz_mini(render->num_workers, bands); band++)\n\t\t\t{\n\t\t\t\tworker_t *w = &workers[band];\n\t\t\t\tw->cookie.abort = 1;\n\t\t\t\tif (w->started)\n\t\t\t\t{\n\t\t\t\t\tmu_wait_semaphore(&w->stop);\n\t\t\t\t\tw->started = 0;\n\t\t\t\t}\n\t\t\t\tfz_drop_pixmap(ctx, w->pix);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tfz_drop_pixmap(ctx, pix);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\t/* Swallow error */\n\t\tif (errors_are_fatal)\n\t\t\treturn RENDER_FATAL;\n\t\treturn RENDER_RETRY;\n\t}\n\tif (cookie->errors)\n\t\terrored = 1;\n\n\treturn RENDER_OK;\n}\n\n/* This functions tries to render a page, falling back repeatedly to try and make it work. */\nstatic int try_render_page(fz_context *ctx, int pagenum, fz_cookie *cookie, int start, int interptime, char *fname, int bg, int solo, render_details *render)\n{\n\tint status;\n\n\tif (out && !(bg && solo))\n\t{\n\t\t/* Output any page level headers (for banded formats). Don't do this if\n\t\t * we're running in solo bgprint mode, cos we've already done it once! */\n\t\tfz_try(ctx)\n\t\t{\n\t\t\tint w = render->ibounds.x1 - render->ibounds.x0;\n\t\t\tint h = render->ibounds.y1 - render->ibounds.y0;\n\t\t\tfz_write_header(ctx, render->bander, w, h, render->n, 0, 0, 0, 0, 0, NULL);\n\t\t}\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\t/* Failure! */\n\t\t\treturn RENDER_FATAL;\n\t\t}\n\t}\n\n\twhile (1)\n\t{\n\t\tstatus = dodrawpage(ctx, pagenum, cookie, render);\n\t\tif (status == RENDER_OK || status == RENDER_FATAL)\n\t\t\tbreak;\n\n\t\t/* If we are bgprinting, then ask the caller to try us again in solo mode. */\n\t\tif (bg && !solo)\n\t\t{\n\t\t\tDEBUG_THREADS((\"Render failure; trying again in solo mode\\n\"));\n\t\t\treturn RENDER_RETRY; /* Avoids all the cleanup below! */\n\t\t}\n\n\t\t/* Try again with fewer threads */\n\t\tif (render->num_workers > 1)\n\t\t{\n\t\t\trender->num_workers >>= 1;\n\t\t\tDEBUG_THREADS((\"Render failure; trying again with %d render threads\\n\", render->num_workers));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Halve the band height, if we still can. */\n\t\tif (render->band_height_multiple > 2)\n\t\t{\n\t\t\trender->band_height_multiple >>= 1;\n\t\t\tDEBUG_THREADS((\"Render failure; trying again with %d band height multiple\\n\", render->band_height_multiple));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* If all else fails, ditch the list and try again. */\n\t\tif (render->list)\n\t\t{\n\t\t\tfz_drop_display_list(ctx, render->list);\n\t\t\trender->list = NULL;\n\t\t\tDEBUG_THREADS((\"Render failure; trying again with no list\\n\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Give up. */\n\t\tDEBUG_THREADS((\"Render failure; nothing else to try\\n\"));\n\t\tbreak;\n\t}\n\n\tfz_close_band_writer(ctx, render->bander);\n\n\tfz_drop_page(ctx, render->page);\n\tfz_drop_display_list(ctx, render->list);\n\tfz_drop_band_writer(ctx, render->bander);\n\n\tif (showtime)\n\t{\n\t\tint end = gettime();\n\t\tint diff = end - start;\n\n\t\tif (bg)\n\t\t{\n\t\t\tif (diff + interptime < timing.min)\n\t\t\t{\n\t\t\t\ttiming.min = diff + interptime;\n\t\t\t\ttiming.mininterp = interptime;\n\t\t\t\ttiming.minpage = pagenum;\n\t\t\t\ttiming.minfilename = fname;\n\t\t\t}\n\t\t\tif (diff + interptime > timing.max)\n\t\t\t{\n\t\t\t\ttiming.max = diff + interptime;\n\t\t\t\ttiming.maxinterp = interptime;\n\t\t\t\ttiming.maxpage = pagenum;\n\t\t\t\ttiming.maxfilename = fname;\n\t\t\t}\n\t\t\ttiming.total += diff + interptime;\n\t\t\ttiming.count ++;\n\n\t\t\tfprintf(stderr, \" %dms (interpretation) %dms (rendering) %dms (total)\\n\", interptime, diff, diff + interptime);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (diff < timing.min)\n\t\t\t{\n\t\t\t\ttiming.min = diff;\n\t\t\t\ttiming.minpage = pagenum;\n\t\t\t\ttiming.minfilename = fname;\n\t\t\t}\n\t\t\tif (diff > timing.max)\n\t\t\t{\n\t\t\t\ttiming.max = diff;\n\t\t\t\ttiming.maxpage = pagenum;\n\t\t\t\ttiming.maxfilename = fname;\n\t\t\t}\n\t\t\ttiming.total += diff;\n\t\t\ttiming.count ++;\n\n\t\t\tfprintf(stderr, \" %dms\\n\", diff);\n\t\t}\n\t}\n\n\tif (showmemory)\n\t{\n\t\tfz_dump_glyph_cache_stats(ctx, fz_stderr(ctx));\n\t}\n\n\tfz_flush_warnings(ctx);\n\n\treturn status;\n}\n\nstatic int wait_for_bgprint_to_finish(void)\n{\n\tif (!bgprint.active || !bgprint.started)\n\t\treturn 0;\n\n\tmu_wait_semaphore(&bgprint.stop);\n\tbgprint.started = 0;\n\treturn bgprint.status;\n}\n\nstatic void\nget_page_render_details(fz_context *ctx, fz_page *page, render_details *render)\n{\n\tfloat page_width, page_height;\n\tint rot;\n\tfloat s_x, s_y;\n\n\trender->page = page;\n\trender->list = NULL;\n\trender->num_workers = num_workers;\n\n\trender->bounds = fz_bound_page(ctx, page);\n\tpage_width = (render->bounds.x1 - render->bounds.x0)/72;\n\tpage_height = (render->bounds.y1 - render->bounds.y0)/72;\n\n\ts_x = x_resolution / 72;\n\ts_y = y_resolution / 72;\n\tif (rotation == -1)\n\t{\n\t\t/* Automatic rotation. If we fit, use 0. If we don't, and 90 would be 'better' use that. */\n\t\tif (page_width <= width && page_height <= height)\n\t\t{\n\t\t\t/* Page fits, so use no rotation. */\n\t\t\trot = 0;\n\t\t}\n\t\telse if (fit)\n\t\t{\n\t\t\t/* Use whichever gives the biggest scale */\n\t\t\tfloat sx_0 = width / page_width;\n\t\t\tfloat sy_0 = height / page_height;\n\t\t\tfloat sx_90 = height / page_width;\n\t\t\tfloat sy_90 = width / page_height;\n\t\t\tfloat s_0, s_90;\n\t\t\ts_0 = fz_min(sx_0, sy_0);\n\t\t\ts_90 = fz_min(sx_90, sy_90);\n\t\t\tif (s_0 >= s_90)\n\t\t\t{\n\t\t\t\trot = 0;\n\t\t\t\tif (s_0 < 1)\n\t\t\t\t{\n\t\t\t\t\ts_x *= s_0;\n\t\t\t\t\ts_y *= s_0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trot = 90;\n\t\t\t\tif (s_90 < 1)\n\t\t\t\t{\n\t\t\t\t\ts_x *= s_90;\n\t\t\t\t\ts_y *= s_90;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Use whichever crops the least area */\n\t\t\tfloat lost0 = 0;\n\t\t\tfloat lost90 = 0;\n\n\t\t\tif (page_width > width)\n\t\t\t\tlost0 += (page_width - width) * (page_height > height ? height : page_height);\n\t\t\tif (page_height > height)\n\t\t\t\tlost0 += (page_height - height) * page_width;\n\n\t\t\tif (page_width > height)\n\t\t\t\tlost90 += (page_width - height) * (page_height > width ? width : page_height);\n\t\t\tif (page_height > width)\n\t\t\t\tlost90 += (page_height - width) * page_width;\n\n\t\t\trot = (lost0 <= lost90 ? 0 : 90);\n\t\t}\n\t}\n\telse\n\t{\n\t\trot = rotation;\n\t}\n\n\trender->ctm = fz_pre_scale(fz_rotate(rot), s_x, s_y);\n\trender->tbounds = fz_transform_rect(render->bounds, render->ctm);;\n\trender->ibounds = fz_round_rect(render->tbounds);\n}\n\nstatic void\ninitialise_banding(fz_context *ctx, render_details *render, int color)\n{\n\tsize_t min_band_mem;\n\tint bpp, h, w, reps;\n\n\trender->colorspace = output_cs;\n\trender->format = output_format;\n#if GREY_FALLBACK != 0\n\tif (color == 0)\n\t{\n\t\tif (render->colorspace == CS_RGB)\n\t\t{\n\t\t\t/* Fallback from PPM to PGM */\n\t\t\trender->colorspace = CS_GRAY;\n\t\t\trender->format = OUT_PGM;\n\t\t}\n\t\telse if (render->colorspace == CS_CMYK)\n\t\t{\n\t\t\trender->colorspace = CS_GRAY;\n\t\t\tif (render->format == OUT_PKM)\n\t\t\t\trender->format = OUT_PBM;\n\t\t\telse\n\t\t\t\trender->format = OUT_PGM;\n\t\t}\n\t}\n#endif\n\n\tswitch (render->colorspace)\n\t{\n\tcase CS_GRAY:\n\t\tbpp = 1;\n\t\tbreak;\n\tcase CS_RGB:\n\t\tbpp = 2;\n\t\tbreak;\n\tdefault:\n\tcase CS_CMYK:\n\t\tbpp = 3;\n\t\tbreak;\n\t}\n\n\tw = render->ibounds.x1 - render->ibounds.x0;\n\tmin_band_mem = (size_t)bpp * w * min_band_height;\n\treps = (int)(max_band_memory / min_band_mem);\n\tif (reps < 1)\n\t\treps = 1;\n\n\t/* Adjust reps to even out the work between threads */\n\tif (render->num_workers > 0)\n\t{\n\t\tint runs, num_bands;\n\t\th = render->ibounds.y1 - render->ibounds.y0;\n\t\tnum_bands = (h + min_band_height - 1) / min_band_height;\n\t\t/* num_bands = number of min_band_height bands */\n\t\truns = (num_bands + reps-1) / reps;\n\t\t/* runs = number of worker runs of reps min_band_height bands */\n\t\truns = ((runs + render->num_workers - 1) / render->num_workers) * render->num_workers;\n\t\t/* runs = number of worker runs rounded up to make use of all our threads */\n\t\treps = (num_bands + runs - 1) / runs;\n\t}\n\n\trender->band_height_multiple = reps;\n\trender->bands_rendered = 0;\n\n\tif (output_format == OUT_PGM || output_format == OUT_PPM)\n\t{\n\t\trender->bander = fz_new_pnm_band_writer(ctx, out);\n\t\trender->n = output_format == OUT_PGM ? 1 : 3;\n\t}\n\telse if (output_format == OUT_PAM)\n\t{\n\t\trender->bander = fz_new_pam_band_writer(ctx, out);\n\t\trender->n = 4;\n\t}\n\telse if (output_format == OUT_PBM)\n\t{\n\t\trender->bander = fz_new_pbm_band_writer(ctx, out);\n\t\trender->n = 1;\n\t}\n\telse if (output_format == OUT_PKM)\n\t{\n\t\trender->bander = fz_new_pkm_band_writer(ctx, out);\n\t\trender->n = 4;\n\t}\n}\n\nstatic void drawpage(fz_context *ctx, fz_document *doc, int pagenum)\n{\n\tfz_page *page;\n\tfz_display_list *list = NULL;\n\tfz_device *list_dev = NULL;\n\tint start;\n\tfz_cookie cookie = { 0 };\n#if GREY_FALLBACK != 0\n\tfz_device *test_dev = NULL;\n\tint is_color = 0;\n#else\n\tint is_color = 2;\n#endif\n\trender_details render;\n\tint status;\n\n\tfz_var(list);\n\tfz_var(list_dev);\n\tfz_var(test_dev);\n\n\tdo\n\t{\n\t\tstart = (showtime ? gettime() : 0);\n\n\t\tpage = fz_load_page(ctx, doc, pagenum - 1);\n\n\t\t/* Calculate Page bounds, transform etc */\n\t\tget_page_render_details(ctx, page, &render);\n\n\t\t/* Make the display list, and see if we need color */\n\t\tfz_try(ctx)\n\t\t{\n\t\t\tlist = fz_new_display_list(ctx, render.bounds);\n\t\t\tlist_dev = fz_new_list_device(ctx, list);\n#if GREY_FALLBACK != 0\n\t\t\ttest_dev = fz_new_test_device(ctx, &is_color, 0.01f, 0, list_dev);\n\t\t\tfz_run_page(ctx, page, test_dev, fz_identity, &cookie);\n\t\t\tfz_close_device(ctx, test_dev);\n#else\n\t\t\tfz_run_page(ctx, page, list_dev, fz_identity, &cookie);\n#endif\n\t\t\tfz_close_device(ctx, list_dev);\n\t\t}\n\t\tfz_always(ctx)\n\t\t{\n#if GREY_FALLBACK != 0\n\t\t\tfz_drop_device(ctx, test_dev);\n#endif\n\t\t\tfz_drop_device(ctx, list_dev);\n\t\t}\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tfz_drop_display_list(ctx, list);\n\t\t\tlist = NULL;\n\t\t\t/* Just continue with no list. Also, we can't do multiple\n\t\t\t * threads if we have no list. */\n\t\t\trender.num_workers = 1;\n\t\t}\n\t\trender.list = list;\n\n#if GREY_FALLBACK != 0\n\t\tif (list == NULL)\n\t\t{\n\t\t\t/* We need to know about color, but the previous test failed\n\t\t\t * (presumably) due to the size of the list. Rerun direct\n\t\t\t * from file. */\n\t\t\tfz_try(ctx)\n\t\t\t{\n\t\t\t\ttest_dev = fz_new_test_device(ctx, &is_color, 0.01f, 0, NULL);\n\t\t\t\tfz_run_page(ctx, page, test_dev, fz_identity, &cookie);\n\t\t\t\tfz_close_device(ctx, test_dev);\n\t\t\t}\n\t\t\tfz_always(ctx)\n\t\t\t{\n\t\t\t\tfz_drop_device(ctx, test_dev);\n\t\t\t}\n\t\t\tfz_catch(ctx)\n\t\t\t{\n\t\t\t\t/* We failed. Just give up. */\n\t\t\t\tfz_drop_page(ctx, page);\n\t\t\t\tfz_rethrow(ctx);\n\t\t\t}\n\t\t}\n#endif\n\n#if GREY_FALLBACK == 2\n\t\t/* If we 'possibly' need color, find out if we 'really' need color. */\n\t\tif (is_color == 1)\n\t\t{\n\t\t\t/* We know that the device has images or shadings in\n\t\t\t * colored spaces. We have been told to test exhaustively\n\t\t\t * so we know whether to use color or grey rendering. */\n\t\t\tis_color = 0;\n\t\t\tfz_try(ctx)\n\t\t\t{\n\t\t\t\ttest_dev = fz_new_test_device(ctx, &is_color, 0.01f, FZ_TEST_OPT_IMAGES | FZ_TEST_OPT_SHADINGS, NULL);\n\t\t\t\tif (list)\n\t\t\t\t\tfz_run_display_list(ctx, list, test_dev, &fz_identity, &fz_infinite_rect, &cookie);\n\t\t\t\telse\n\t\t\t\t\tfz_run_page(ctx, page, test_dev, &fz_identity, &cookie);\n\t\t\t\tfz_close_device(ctx, test_dev);\n\t\t\t}\n\t\t\tfz_always(ctx)\n\t\t\t{\n\t\t\t\tfz_drop_device(ctx, test_dev);\n\t\t\t}\n\t\t\tfz_catch(ctx)\n\t\t\t{\n\t\t\t\tfz_drop_display_list(ctx, list);\n\t\t\t\tfz_drop_page(ctx, page);\n\t\t\t\tfz_rethrow(ctx);\n\t\t\t}\n\t\t}\n#endif\n\n\t\t/* Figure out banding */\n\t\tinitialise_banding(ctx, &render, is_color);\n\n\t\tif (bgprint.active && showtime)\n\t\t{\n\t\t\tint end = gettime();\n\t\t\tstart = end - start;\n\t\t}\n\n\t\t/* If we're not using bgprint, then no need to wait */\n\t\tif (!bgprint.active)\n\t\t\tbreak;\n\n\t\t/* If we are using it, then wait for it to finish. */\n\t\tstatus = wait_for_bgprint_to_finish();\n\t\tif (status == RENDER_OK)\n\t\t{\n\t\t\t/* The background bgprint completed successfully. Drop out of the loop,\n\t\t\t * and carry on with our next page. */\n\t\t\tbreak;\n\t\t}\n\n\t\t/* The bgprint in the background failed! This might have been because\n\t\t * we were using memory etc in the foreground. We'd better ditch\n\t\t * everything we can and try again. */\n\t\tfz_drop_display_list(ctx, list);\n\t\tfz_drop_page(ctx, page);\n\n\t\tif (status == RENDER_FATAL)\n\t\t{\n\t\t\t/* We failed because of not being able to output. No point in retrying. */\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Failed to render page\");\n\t\t}\n\t\tbgprint.started = 1;\n\t\tbgprint.solo = 1;\n\t\tmu_trigger_semaphore(&bgprint.start);\n\t\tstatus = wait_for_bgprint_to_finish();\n\t\tif (status != 0)\n\t\t{\n\t\t\t/* Hard failure */\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Failed to render page\");\n\t\t}\n\t\t/* Loop back to reload this page */\n\t}\n\twhile (1);\n\n\tif (showtime)\n\t{\n\t\tfprintf(stderr, \"page %s %d\", filename, pagenum);\n\t}\n\tif (bgprint.active)\n\t{\n\t\tbgprint.started = 1;\n\t\tbgprint.solo = 0;\n\t\tbgprint.render = render;\n\t\tbgprint.filename = filename;\n\t\tbgprint.pagenum = pagenum;\n\t\tbgprint.interptime = start;\n\t\tmu_trigger_semaphore(&bgprint.start);\n\t}\n\telse\n\t{\n\t\tif (try_render_page(ctx, pagenum, &cookie, start, 0, filename, 0, 0, &render))\n\t\t{\n\t\t\t/* Hard failure */\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Failed to render page\");\n\t\t}\n\t}\n}\n\n/* Wait for the final page being printed by bgprint to complete,\n * retrying if necessary. */\nstatic void\nfinish_bgprint(fz_context *ctx)\n{\n\tint status;\n\n\tif (!bgprint.active)\n\t\treturn;\n\n\t/* If we are using it, then wait for it to finish. */\n\tstatus = wait_for_bgprint_to_finish();\n\tif (status == RENDER_OK)\n\t{\n\t\t/* The background bgprint completed successfully. */\n\t\treturn;\n\t}\n\n\tif (status == RENDER_FATAL)\n\t{\n\t\t/* We failed because of not being able to output. No point in retrying. */\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Failed to render page\");\n\t}\n\tbgprint.started = 1;\n\tbgprint.solo = 1;\n\tmu_trigger_semaphore(&bgprint.start);\n\tstatus = wait_for_bgprint_to_finish();\n\tif (status != 0)\n\t{\n\t\t/* Hard failure */\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Failed to render page\");\n\t}\n}\n\nstatic void drawrange(fz_context *ctx, fz_document *doc, const char *range)\n{\n\tint page, spage, epage, pagecount;\n\n\tpagecount = fz_count_pages(ctx, doc);\n\n\twhile ((range = fz_parse_page_range(ctx, range, &spage, &epage, pagecount)))\n\t{\n\t\tif (spage < epage)\n\t\t\tfor (page = spage; page <= epage; page++)\n\t\t\t\tdrawpage(ctx, doc, page);\n\t\telse\n\t\t\tfor (page = spage; page >= epage; page--)\n\t\t\t\tdrawpage(ctx, doc, page);\n\t}\n}\n\ntypedef struct\n{\n\tsize_t size;\n#if defined(_M_IA64) || defined(_M_AMD64)\n\tsize_t align;\n#endif\n} trace_header;\n\ntypedef struct\n{\n\tsize_t current;\n\tsize_t peak;\n\tsize_t total;\n} trace_info;\n\nstatic void *\ntrace_malloc(void *arg, size_t size)\n{\n\ttrace_info *info = (trace_info *) arg;\n\ttrace_header *p;\n\tif (size == 0)\n\t\treturn NULL;\n\tp = malloc(size + sizeof(trace_header));\n\tif (p == NULL)\n\t\treturn NULL;\n\tp[0].size = size;\n\tinfo->current += size;\n\tinfo->total += size;\n\tif (info->current > info->peak)\n\t\tinfo->peak = info->current;\n\treturn (void *)&p[1];\n}\n\nstatic void\ntrace_free(void *arg, void *p_)\n{\n\ttrace_info *info = (trace_info *) arg;\n\ttrace_header *p = (trace_header *)p_;\n\n\tif (p == NULL)\n\t\treturn;\n\tinfo->current -= p[-1].size;\n\tfree(&p[-1]);\n}\n\nstatic void *\ntrace_realloc(void *arg, void *p_, size_t size)\n{\n\ttrace_info *info = (trace_info *) arg;\n\ttrace_header *p = (trace_header *)p_;\n\tsize_t oldsize;\n\n\tif (size == 0)\n\t{\n\t\ttrace_free(arg, p_);\n\t\treturn NULL;\n\t}\n\tif (p == NULL)\n\t\treturn trace_malloc(arg, size);\n\toldsize = p[-1].size;\n\tp = realloc(&p[-1], size + sizeof(trace_header));\n\tif (p == NULL)\n\t\treturn NULL;\n\tinfo->current += size - oldsize;\n\tif (size > oldsize)\n\t\tinfo->total += size - oldsize;\n\tif (info->current > info->peak)\n\t\tinfo->peak = info->current;\n\tp[0].size = size;\n\treturn &p[1];\n}\n\n#ifndef DISABLE_MUTHREADS\nstatic void worker_thread(void *arg)\n{\n\tworker_t *me = (worker_t *)arg;\n\tint band_start;\n\n\tdo\n\t{\n\t\tDEBUG_THREADS((\"Worker %d waiting\\n\", me->num));\n\t\tmu_wait_semaphore(&me->start);\n\t\tband_start = me->band_start;\n\t\tDEBUG_THREADS((\"Worker %d woken for band_start %d\\n\", me->num, me->band_start));\n\t\tme->status = RENDER_OK;\n\t\tif (band_start >= 0)\n\t\t\tme->status = drawband(me->ctx, NULL, me->list, me->ctm, me->tbounds, &me->cookie, band_start, me->pix, &me->bit);\n\t\tDEBUG_THREADS((\"Worker %d completed band_start %d (status=%d)\\n\", me->num, band_start, me->status));\n\t\tmu_trigger_semaphore(&me->stop);\n\t}\n\twhile (band_start >= 0);\n}\n\nstatic void bgprint_worker(void *arg)\n{\n\tfz_cookie cookie = { 0 };\n\tint pagenum;\n\n\t(void)arg;\n\n\tdo\n\t{\n\t\tDEBUG_THREADS((\"BGPrint waiting\\n\"));\n\t\tmu_wait_semaphore(&bgprint.start);\n\t\tpagenum = bgprint.pagenum;\n\t\tDEBUG_THREADS((\"BGPrint woken for pagenum %d\\n\", pagenum));\n\t\tif (pagenum >= 0)\n\t\t{\n\t\t\tint start = gettime();\n\t\t\tmemset(&cookie, 0, sizeof(cookie));\n\t\t\tbgprint.status = try_render_page(bgprint.ctx, pagenum, &cookie, start, bgprint.interptime, bgprint.filename, 1, bgprint.solo, &bgprint.render);\n\t\t}\n\t\tDEBUG_THREADS((\"BGPrint completed page %d\\n\", pagenum));\n\t\tmu_trigger_semaphore(&bgprint.stop);\n\t}\n\twhile (pagenum >= 0);\n}\n#endif\n\nstatic void\nread_resolution(const char *arg)\n{\n\tchar *sep = strchr(arg, ',');\n\n\tif (sep == NULL)\n\t\tsep = strchr(arg, 'x');\n\tif (sep == NULL)\n\t\tsep = strchr(arg, ':');\n\tif (sep == NULL)\n\t\tsep = strchr(arg, ';');\n\n\tx_resolution = fz_atoi(arg);\n\tif (sep && sep[1])\n\t\ty_resolution = fz_atoi(arg);\n\telse\n\t\ty_resolution = x_resolution;\n}\n\nstatic int\nread_rotation(const char *arg)\n{\n\tint i;\n\n\tif (strcmp(arg, \"auto\"))\n\t{\n\t\treturn -1;\n\t}\n\n\ti = fz_atoi(arg);\n\n\ti = i % 360;\n\tif (i % 90 != 0)\n\t{\n\t\tfprintf(stderr, \"Ignoring invalid rotation\\n\");\n\t\ti = 0;\n\t}\n\n\treturn i;\n}\n\nint main(int argc, char **argv)\n{\n\tchar *password = \"\";\n\tfz_document *doc = NULL;\n\tint c;\n\tfz_context *ctx;\n\ttrace_info info = { 0, 0, 0 };\n\tfz_alloc_context alloc_ctx = { &info, trace_malloc, trace_realloc, trace_free };\n\tfz_locks_context *locks = NULL;\n\n\tfz_var(doc);\n\n\tbgprint.active = 0;\t\t\t/* set by -P */\n\tmin_band_height = MIN_BAND_HEIGHT;\n\tmax_band_memory = BAND_MEMORY;\n\twidth = 0;\n\theight = 0;\n\tnum_workers = NUM_RENDER_THREADS;\n\tx_resolution = X_RESOLUTION;\n\ty_resolution = Y_RESOLUTION;\n\n\twhile ((c = fz_getopt(argc, argv, \"p:o:F:R:r:w:h:fB:M:s:A:iW:H:S:T:U:XvP\")) != -1)\n\t{\n\t\tswitch (c)\n\t\t{\n\t\tdefault: return usage();\n\n\t\tcase 'p': password = fz_optarg; break;\n\n\t\tcase 'o': output = fz_optarg; break;\n\t\tcase 'F': format = fz_optarg; break;\n\n\t\tcase 'R': rotation = read_rotation(fz_optarg); break;\n\t\tcase 'r': read_resolution(fz_optarg); break;\n\t\tcase 'w': width = fz_atof(fz_optarg); break;\n\t\tcase 'h': height = fz_atof(fz_optarg); break;\n\t\tcase 'f': fit = 1; break;\n\t\tcase 'B': min_band_height = atoi(fz_optarg); break;\n\t\tcase 'M': max_band_memory = atoi(fz_optarg); break;\n\n\t\tcase 'W': layout_w = fz_atof(fz_optarg); break;\n\t\tcase 'H': layout_h = fz_atof(fz_optarg); break;\n\t\tcase 'S': layout_em = fz_atof(fz_optarg); break;\n\t\tcase 'U': layout_css = fz_optarg; break;\n\t\tcase 'X': layout_use_doc_css = 0; break;\n\n\t\tcase 's':\n\t\t\tif (strchr(fz_optarg, 't')) ++showtime;\n\t\t\tif (strchr(fz_optarg, 'm')) ++showmemory;\n\t\t\tbreak;\n\n\t\tcase 'A':\n\t\t{\n\t\t\tchar *sep;\n\t\t\talphabits_graphics = atoi(fz_optarg);\n\t\t\tsep = strchr(fz_optarg, '/');\n\t\t\tif (sep)\n\t\t\t\talphabits_text = atoi(sep+1);\n\t\t\telse\n\t\t\t\talphabits_text = alphabits_graphics;\n\t\t\tbreak;\n\t\t}\n\t\tcase 'i': ignore_errors = 1; break;\n\n\t\tcase 'T':\n#if MURASTER_THREADS != 0\n\t\t\tnum_workers = atoi(fz_optarg); break;\n#else\n\t\t\tfprintf(stderr, \"Threads not enabled in this build\\n\");\n\t\t\tbreak;\n#endif\n\t\tcase 'P':\n#if MURASTER_THREADS != 0\n\t\t\tbgprint.active = 1; break;\n#else\n\t\t\tfprintf(stderr, \"Threads not enabled in this build\\n\");\n\t\t\tbreak;\n#endif\n\t\tcase 'v': fprintf(stderr, \"muraster version %s\\n\", FZ_VERSION); return 1;\n\t\t}\n\t}\n\n\tif (width == 0)\n\t\twidth = x_resolution * PAPER_WIDTH;\n\n\tif (height == 0)\n\t\theight = y_resolution * PAPER_HEIGHT;\n\n\tif (fz_optind == argc)\n\t\treturn usage();\n\n\tif (min_band_height <= 0)\n\t{\n\t\tfprintf(stderr, \"Require a positive minimum band height\\n\");\n\t\texit(1);\n\t}\n\n#ifndef DISABLE_MUTHREADS\n\tlocks = init_muraster_locks();\n\tif (locks == NULL)\n\t{\n\t\tfprintf(stderr, \"cannot initialise mutexes\\n\");\n\t\texit(1);\n\t}\n#endif\n\n\tctx = fz_new_context((showmemory == 0 ? NULL : &alloc_ctx), locks, FZ_STORE_DEFAULT);\n\tif (!ctx)\n\t{\n\t\tfprintf(stderr, \"cannot initialise context\\n\");\n\t\texit(1);\n\t}\n\n\tfz_set_text_aa_level(ctx, alphabits_text);\n\tfz_set_graphics_aa_level(ctx, alphabits_graphics);\n\n#ifndef DISABLE_MUTHREADS\n\tif (bgprint.active)\n\t{\n\t\tint fail = 0;\n\t\tbgprint.ctx = fz_clone_context(ctx);\n\t\tfail |= mu_create_semaphore(&bgprint.start);\n\t\tfail |= mu_create_semaphore(&bgprint.stop);\n\t\tfail |= mu_create_thread(&bgprint.thread, bgprint_worker, NULL);\n\t\tif (fail)\n\t\t{\n\t\t\tfprintf(stderr, \"bgprint startup failed\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (num_workers > 0)\n\t{\n\t\tint i;\n\t\tint fail = 0;\n\t\tworkers = fz_calloc(ctx, num_workers, sizeof(*workers));\n\t\tfor (i = 0; i < num_workers; i++)\n\t\t{\n\t\t\tworkers[i].ctx = fz_clone_context(ctx);\n\t\t\tworkers[i].num = i;\n\t\t\tfail |= mu_create_semaphore(&workers[i].start);\n\t\t\tfail |= mu_create_semaphore(&workers[i].stop);\n\t\t\tfail |= mu_create_thread(&workers[i].thread, worker_thread, &workers[i]);\n\t\t}\n\t\tif (fail)\n\t\t{\n\t\t\tfprintf(stderr, \"worker startup failed\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n#endif /* DISABLE_MUTHREADS */\n\n\tif (layout_css)\n\t{\n\t\tfz_buffer *buf = fz_read_file(ctx, layout_css);\n\t\tfz_set_user_css(ctx, fz_string_from_buffer(ctx, buf));\n\t\tfz_drop_buffer(ctx, buf);\n\t}\n\n\tfz_set_use_document_css(ctx, layout_use_doc_css);\n\n\toutput_format = suffix_table[0].format;\n\toutput_cs = suffix_table[0].cs;\n\tif (format)\n\t{\n\t\tint i;\n\n\t\tfor (i = 0; i < (int)nelem(suffix_table); i++)\n\t\t{\n\t\t\tif (!strcmp(format, suffix_table[i].suffix+1))\n\t\t\t{\n\t\t\t\toutput_format = suffix_table[i].format;\n\t\t\t\toutput_cs = suffix_table[i].cs;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == (int)nelem(suffix_table))\n\t\t{\n\t\t\tfprintf(stderr, \"Unknown output format '%s'\\n\", format);\n\t\t\texit(1);\n\t\t}\n\t}\n\telse if (output)\n\t{\n\t\tchar *suffix = output;\n\t\tint i;\n\n\t\tfor (i = 0; i < (int)nelem(suffix_table); i++)\n\t\t{\n\t\t\tchar *s = strstr(suffix, suffix_table[i].suffix);\n\n\t\t\tif (s != NULL)\n\t\t\t{\n\t\t\t\tsuffix = s+1;\n\t\t\t\toutput_format = suffix_table[i].format;\n\t\t\t\toutput_cs = suffix_table[i].cs;\n\t\t\t\ti = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (output_cs)\n\t{\n\tcase CS_GRAY:\n\t\tcolorspace = fz_device_gray(ctx);\n\t\tbreak;\n\tcase CS_RGB:\n\t\tcolorspace = fz_device_rgb(ctx);\n\t\tbreak;\n\tcase CS_CMYK:\n\t\tcolorspace = fz_device_cmyk(ctx);\n\t\tbreak;\n\t}\n\n\tif (output && (output[0] != '-' || output[1] != 0) && *output != 0)\n\t{\n\t\tout = fz_new_output_with_path(ctx, output, 0);\n\t}\n\telse\n\t\tout = fz_stdout(ctx);\n\n\ttiming.count = 0;\n\ttiming.total = 0;\n\ttiming.min = 1 << 30;\n\ttiming.max = 0;\n\ttiming.mininterp = 1 << 30;\n\ttiming.maxinterp = 0;\n\ttiming.minpage = 0;\n\ttiming.maxpage = 0;\n\ttiming.minfilename = \"\";\n\ttiming.maxfilename = \"\";\n\n\tfz_try(ctx)\n\t{\n\t\tfz_register_document_handlers(ctx);\n\n\t\twhile (fz_optind < argc)\n\t\t{\n\t\t\tfz_try(ctx)\n\t\t\t{\n\t\t\t\tfilename = argv[fz_optind++];\n\n\t\t\t\tdoc = fz_open_document(ctx, filename);\n\n\t\t\t\tif (fz_needs_password(ctx, doc))\n\t\t\t\t{\n\t\t\t\t\tif (!fz_authenticate_password(ctx, doc, password))\n\t\t\t\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"cannot authenticate password: %s\", filename);\n\t\t\t\t}\n\n\t\t\t\tfz_layout_document(ctx, doc, layout_w, layout_h, layout_em);\n\n\t\t\t\tif (fz_optind == argc || !fz_is_page_range(ctx, argv[fz_optind]))\n\t\t\t\t\tdrawrange(ctx, doc, \"1-N\");\n\t\t\t\tif (fz_optind < argc && fz_is_page_range(ctx, argv[fz_optind]))\n\t\t\t\t\tdrawrange(ctx, doc, argv[fz_optind++]);\n\n\t\t\t\tfz_drop_document(ctx, doc);\n\t\t\t\tdoc = NULL;\n\t\t\t}\n\t\t\tfz_catch(ctx)\n\t\t\t{\n\t\t\t\tif (!ignore_errors)\n\t\t\t\t\tfz_rethrow(ctx);\n\n\t\t\t\tfz_drop_document(ctx, doc);\n\t\t\t\tdoc = NULL;\n\t\t\t\tfz_warn(ctx, \"ignoring error in '%s'\", filename);\n\t\t\t}\n\t\t}\n\t\tfinish_bgprint(ctx);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_drop_document(ctx, doc);\n\t\tfprintf(stderr, \"error: cannot draw '%s'\\n\", filename);\n\t\terrored = 1;\n\t}\n\n\tif (showtime && timing.count > 0)\n\t{\n\t\tfprintf(stderr, \"total %dms / %d pages for an average of %dms\\n\",\n\t\t\ttiming.total, timing.count, timing.total / timing.count);\n\t\tfprintf(stderr, \"fastest page %d: %dms\\n\", timing.minpage, timing.min);\n\t\tfprintf(stderr, \"slowest page %d: %dms\\n\", timing.maxpage, timing.max);\n\t}\n\n#ifndef DISABLE_MUTHREADS\n\tif (num_workers > 0)\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < num_workers; i++)\n\t\t{\n\t\t\tworkers[i].band_start = -1;\n\t\t\tmu_trigger_semaphore(&workers[i].start);\n\t\t\tmu_wait_semaphore(&workers[i].stop);\n\t\t\tmu_destroy_semaphore(&workers[i].start);\n\t\t\tmu_destroy_semaphore(&workers[i].stop);\n\t\t\tmu_destroy_thread(&workers[i].thread);\n\t\t\tfz_drop_context(workers[i].ctx);\n\t\t}\n\t\tfz_free(ctx, workers);\n\t}\n\n\tif (bgprint.active)\n\t{\n\t\tbgprint.pagenum = -1;\n\t\tmu_trigger_semaphore(&bgprint.start);\n\t\tmu_wait_semaphore(&bgprint.stop);\n\t\tmu_destroy_semaphore(&bgprint.start);\n\t\tmu_destroy_semaphore(&bgprint.stop);\n\t\tmu_destroy_thread(&bgprint.thread);\n\t\tfz_drop_context(bgprint.ctx);\n\t}\n#endif /* DISABLE_MUTHREADS */\n\n\tfz_close_output(ctx, out);\n\tfz_drop_output(ctx, out);\n\tout = NULL;\n\n\tfz_drop_context(ctx);\n#ifndef DISABLE_MUTHREADS\n\tfin_muraster_locks();\n#endif /* DISABLE_MUTHREADS */\n\n\tif (showmemory)\n\t{\n\t\tchar buf[100];\n\t\tfz_snprintf(buf, sizeof buf, \"Memory use total=%zu peak=%zu current=%zu\", info.total, info.peak, info.current);\n\t\tfprintf(stderr, \"%s\\n\", buf);\n\t}\n\n\treturn (errored != 0);\n}\n"], "fixing_code": ["// Copyright (C) 2004-2021 Artifex Software, Inc.\n//\n// This file is part of MuPDF.\n//\n// MuPDF is free software: you can redistribute it and/or modify it under the\n// terms of the GNU Affero General Public License as published by the Free\n// Software Foundation, either version 3 of the License, or (at your option)\n// any later version.\n//\n// MuPDF is distributed in the hope that it will be useful, but WITHOUT ANY\n// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n// FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more\n// details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with MuPDF. If not, see <https://www.gnu.org/licenses/agpl-3.0.en.html>\n//\n// Alternative licensing terms are available from the licensor.\n// For commercial licensing, see <https://www.artifex.com/> or contact\n// Artifex Software, Inc., 1305 Grant Avenue - Suite 200, Novato,\n// CA 94945, U.S.A., +1(415)492-9861, for further information.\n\n/*\n * muraster -- Convert a document to a raster file.\n *\n * Deliberately simple. Designed to be a basis for what\n * printer customers would need.\n *\n * Therefore; only supports pgm, ppm, pam, pbm, pkm,\n * and then only dependent on the FZ_PLOTTERS_{G,RGB,CMYK}\n * flags.\n * Only supports banding.\n * Supports auto fallback to grey if possible.\n * Supports threading.\n * Supports fallback in low memory cases.\n */\n\n/*\n\tCONFIGURATION SECTION\n\n\tThe first bit of configuration for this is actually in\n\thow the muthreads helper library is built. If muthreads\n\tdoes not know how to support threading on your system\n\tthen it will ensure that DISABLE_MUTHREADS is set. All\n\tthe muthreads entrypoints/types will still be defined\n\t(as dummy types/functions), but attempting to use them\n\twill return errors.\n\n\tConfiguration options affecting threading should be\n\tturned off if DISABLE_MUTHREADS is set.\n\n\tIntegrators can/should define the following\n\tMURASTER_CONFIG_ values. If not set, we'll\n\tattempt to set sensible defaults.\n*/\n\n/*\n\tMURASTER_CONFIG_RENDER_THREADS: The number of render\n\tthreads to use. Typically you would set this to the\n\tnumber of CPU cores - 1 (or -2 if background printing\n\tis used).\n\n\tIf no threading library exists for your OS set this\n\tto 0.\n\n\tIf undefined, we will use a default of\n\t3 - MURASTER_CONFIG_BGPRINT.\n*/\n/* #define MURASTER_CONFIG_RENDER_THREADS 3 */\n\n/*\n\tMURASTER_CONFIG_BGPRINT: 0 or 1. Set to 1 to\n\tenable background printing. This relies on\n\ta threading library existing for the OS.\n\n\tIf undefined, we will use a default of 1.\n*/\n/* #define MURASTER_CONFIG_BGPRINT 1 */\n\n/*\n\tMURASTER_CONFIG_X_RESOLUTION: The default X resolution\n\tin dots per inch. If undefined, taken to be 300dpi.\n*/\n/* #define MURASTER_CONFIG_X_RESOLUTION 300 */\n\n/*\n\tMURASTER_CONFIG_Y_RESOLUTION: The default Y resolution\n\tin dots per inch. If undefined, taken to be 300dpi.\n*/\n/* #define MURASTER_CONFIG_Y_RESOLUTION 300 */\n\n/*\n\tMURASTER_CONFIG_WIDTH: The printable page width\n\t(in inches)\n*/\n/* #define MURASTER_CONFIG_WIDTH 8.27f */\n\n/*\n\tMURASTER_CONFIG_HEIGHT: The printable page height\n\t(in inches)\n*/\n/* #define MURASTER_CONFIG_HEIGHT 11.69f */\n\n/*\n\tMURASTER_CONFIG_STORE_SIZE: The maximum size to use\n\tfor the fz_store.\n\n\tIf undefined, then on Linux we will attempt to guess\n\tthe memory size, and we'll use that for the store\n\tsize. This will be too large, but it should work OK.\n\n\tIf undefined and NOT linux, then we'll use the default\n\tstore size.\n*/\n/* #define MURASTER_CONFIG_STORE_SIZE FZ_STORE_DEFAULT */\n\n/*\n\tMURASTER_CONFIG_MIN_BAND_HEIGHT: The minimum band\n\theight we will ever use. This might correspond to the\n\tnumber of nozzles on an inkjet head.\n\n\tBy default, we'll use 32.\n*/\n/* #define MURASTER_CONFIG_MIN_BAND_HEIGHT 32 */\n\n/*\n\tMURASTER_CONFIG_BAND_MEMORY: The maximum amount of\n\tmemory (in bytes) to use for any given band.\n\n\tWe will need MURASTER_CONFIG_RENDER_THREADS of these,\n\tone for each render thread.\n\n\tHaving this be a multiple of\n\tMURASTER_CONFIG_MIN_BAND_HEIGHT * MURASTER_CONFIG_MAX_WIDTH * MURASTER_CONFIG_X_RESOLUTION * N\n\twould be sensible.\n\n\t(Where N = 1 for greyscale, 3 for RGB, 4 for CMYK)\n*/\n/* #define MURASTER_CONFIG_BAND_MEMORY (32*10*300*4*16) */\n\n/*\n\tMURASTER_CONFIG_GREY_FALLBACK: 0, 1 or 2.\n\n\tSet to 1 to fallback to grey rendering if the page\n\tis definitely grey. Any images in colored color\n\tspaces will be assumed to be color. This may refuse\n\tto fallback in some cases when it could have done.\n\n\tSet to 2 to fallback to grey rendering if the page\n\tis definitely grey. Any images in colored color\n\tspaces will be exhaustively checked. This will\n\tfallback whenever possible, at the expense of some\n\truntime as more processing is required to check.\n*/\n/* #define MURASTER_CONFIG_GREY_FALLBACK 1 */\n\n/*\n\tEND OF CONFIGURATION SECTION\n*/\n\n#include \"mupdf/fitz.h\"\n#include \"mupdf/helpers/mu-threads.h\"\n\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#ifdef _MSC_VER\nstruct timeval;\nstruct timezone;\nint gettimeofday(struct timeval *tv, struct timezone *tz);\n#else\n#include <sys/time.h>\n#endif\n\n/*\n\tAfter this point, we convert the #defines set (or not set)\n\tabove into sensible values we can work with. Don't edit\n\tthese for configuration.\n*/\n\n/* Unless we have specifically disabled threading, enable it. */\n#ifndef DISABLE_MUTHREADS\n#ifndef MURASTER_THREADS\n#define MURASTER_THREADS 1\n#endif\n#endif\n\n/* If we have threading, and we haven't already configured BGPRINT,\n * enable it. */\n#if MURASTER_THREADS != 0\n#ifndef MURASTER_CONFIG_BGPRINT\n#define MURASTER_CONFIG_BGPRINT 1\n#endif\n#endif\n\n#ifdef MURASTER_CONFIG_X_RESOLUTION\n#define X_RESOLUTION MURASTER_CONFIG_X_RESOLUTION\n#else\n#define X_RESOLUTION 300\n#endif\n\n#ifdef MURASTER_CONFIG_Y_RESOLUTION\n#define Y_RESOLUTION MURASTER_CONFIG_Y_RESOLUTION\n#else\n#define Y_RESOLUTION 300\n#endif\n\n#ifdef MURASTER_CONFIG_WIDTH\n#define PAPER_WIDTH MURASTER_CONFIG_WIDTH\n#else\n#define PAPER_WIDTH 8.27f\n#endif\n\n#ifdef MURASTER_CONFIG_HEIGHT\n#define PAPER_HEIGHT MURASTER_CONFIG_HEIGHT\n#else\n#define PAPER_HEIGHT 11.69f\n#endif\n\n#ifdef MURASTER_CONFIG_STORE_SIZE\n#define STORE_SIZE MURASTER_CONFIG_STORE_SIZE\n#else\n#define STORE_SIZE FZ_STORE_SIZE\n#endif\n\n#ifdef MURASTER_CONFIG_MIN_BAND_HEIGHT\n#define MIN_BAND_HEIGHT MURASTER_CONFIG_MIN_BAND_HEIGHT\n#else\n#define MIN_BAND_HEIGHT 32\n#endif\n\n#ifdef MURASTER_CONFIG_BAND_MEMORY\n#define BAND_MEMORY MURASTER_CONFIG_BAND_MEMORY\n#else\n#if defined(FZ_PLOTTERS_CMYK) || defined(FZ_PLOTTERS_N)\n#define BAND_MEMORY (MIN_BAND_HEIGHT * PAPER_WIDTH * X_RESOLUTION * 4 * 16)\n#elif defined(FZ_PLOTTERS_RGB)\n#define BAND_MEMORY (MIN_BAND_HEIGHT * PAPER_WIDTH * X_RESOLUTION * 3 * 16)\n#else\n#define BAND_MEMORY (MIN_BAND_HEIGHT * PAPER_WIDTH * X_RESOLUTION * 1 * 16)\n#endif\n#endif\n\n#ifdef MURASTER_CONFIG_GREY_FALLBACK\n#define GREY_FALLBACK MURASTER_CONFIG_GREY_FALLBACK\n#else\n#ifdef FZ_PLOTTERS_N\n#define GREY_FALLBACK 1\n#elif defined(FZ_PLOTTERS_G) && (defined(FZ_PLOTTERS_RGB) || defined(FZ_PLOTTERS_CMYK))\n#define GREY_FALLBACK 1\n#else\n#define GREY_FALLBACK 0\n#endif\n#endif\n\n#if GREY_FALLBACK != 0 && !defined(FZ_PLOTTERS_N) && !defined(FZ_PLOTTERS_G)\n#error MURASTER_CONFIG_GREY_FALLBACK requires either FZ_PLOTTERS_N or FZ_PLOTTERS_G\n#endif\n\n/* Enable for helpful threading debug */\n/* #define DEBUG_THREADS(A) do { printf A; fflush(stdout); } while (0) */\n#define DEBUG_THREADS(A) do { } while (0)\n\nenum {\n\tOUT_PGM,\n\tOUT_PPM,\n\tOUT_PAM,\n\tOUT_PBM,\n\tOUT_PKM\n};\n\nenum {\n\tCS_GRAY,\n\tCS_RGB,\n\tCS_CMYK\n};\n\ntypedef struct\n{\n\tchar *suffix;\n\tint format;\n\tint cs;\n} suffix_t;\n\nstatic const suffix_t suffix_table[] =\n{\n#if FZ_PLOTTERS_G || FZ_PLOTTERS_N\n\t{ \".pgm\", OUT_PGM, CS_GRAY },\n#endif\n#if FZ_PLOTTERS_RGB || FZ_PLOTTERS_N\n\t{ \".ppm\", OUT_PPM, CS_RGB },\n#endif\n#if FZ_PLOTTERS_CMYK || FZ_PLOTTERS_N\n\t{ \".pam\", OUT_PAM, CS_CMYK },\n#endif\n#if FZ_PLOTTERS_G || FZ_PLOTTERS_N\n\t{ \".pbm\", OUT_PBM, CS_GRAY },\n#endif\n#if FZ_PLOTTERS_CMYK || FZ_PLOTTERS_N\n\t{ \".pkm\", OUT_PKM, CS_CMYK }\n#endif\n};\n\n#ifndef DISABLE_MUTHREADS\n\nstatic mu_mutex mutexes[FZ_LOCK_MAX];\n\nstatic void muraster_lock(void *user, int lock)\n{\n\tmu_lock_mutex(&mutexes[lock]);\n}\n\nstatic void muraster_unlock(void *user, int lock)\n{\n\tmu_unlock_mutex(&mutexes[lock]);\n}\n\nstatic fz_locks_context muraster_locks =\n{\n\tNULL, muraster_lock, muraster_unlock\n};\n\nstatic void fin_muraster_locks(void)\n{\n\tint i;\n\n\tfor (i = 0; i < FZ_LOCK_MAX; i++)\n\t\tmu_destroy_mutex(&mutexes[i]);\n}\n\nstatic fz_locks_context *init_muraster_locks(void)\n{\n\tint i;\n\tint failed = 0;\n\n\tfor (i = 0; i < FZ_LOCK_MAX; i++)\n\t\tfailed |= mu_create_mutex(&mutexes[i]);\n\n\tif (failed)\n\t{\n\t\tfin_muraster_locks();\n\t\treturn NULL;\n\t}\n\n\treturn &muraster_locks;\n}\n\n#endif\n\n#ifdef MURASTER_CONFIG_RENDER_THREADS\n#define NUM_RENDER_THREADS MURASTER_CONFIG_RENDER_THREADS\n#elif defined(DISABLE_MUTHREADS)\n#define NUM_RENDER_THREADS 0\n#else\n#define NUM_RENDER_THREADS 3\n#endif\n\n#if defined(DISABLE_MUTHREADS) && NUM_RENDER_THREADS != 0\n#error \"Can't have MURASTER_CONFIG_RENDER_THREADS > 0 without having a threading library!\"\n#endif\n\n#ifdef MURASTER_CONFIG_BGPRINT\n#define BGPRINT MURASTER_CONFIG_BGPRINT\n#elif MURASTER_THREADS == 0\n#define BGPRINT 0\n#else\n#define BGPRINT 1\n#endif\n\n#if defined(DISABLE_MUTHREADS) && BGPRINT != 0\n#error \"Can't have MURASTER_CONFIG_BGPRINT > 0 without having a threading library!\"\n#endif\n\ntypedef struct worker_t {\n\tfz_context *ctx;\n\tint started;\n\tint status;\n\tint num;\n\tint band_start; /* -1 to shutdown, or offset of band to render */\n\tfz_display_list *list;\n\tfz_matrix ctm;\n\tfz_rect tbounds;\n\tfz_pixmap *pix;\n\tfz_bitmap *bit;\n\tfz_cookie cookie;\n\tmu_semaphore start;\n\tmu_semaphore stop;\n\tmu_thread thread;\n} worker_t;\n\nstatic char *output = NULL;\nstatic fz_output *out = NULL;\n\nstatic char *format;\nstatic int output_format;\nstatic int output_cs;\n\nstatic int rotation = -1;\nstatic float x_resolution;\nstatic float y_resolution;\nstatic int width = 0;\nstatic int height = 0;\nstatic int fit = 0;\n\nstatic float layout_w = FZ_DEFAULT_LAYOUT_W;\nstatic float layout_h = FZ_DEFAULT_LAYOUT_H;\nstatic float layout_em = FZ_DEFAULT_LAYOUT_EM;\nstatic char *layout_css = NULL;\nstatic int layout_use_doc_css = 1;\n\nstatic int showtime = 0;\nstatic int showmemory = 0;\n\nstatic int ignore_errors = 0;\nstatic int alphabits_text = 8;\nstatic int alphabits_graphics = 8;\n\nstatic int min_band_height;\nstatic size_t max_band_memory;\n\nstatic int errored = 0;\nstatic fz_colorspace *colorspace;\nstatic char *filename;\nstatic int num_workers = 0;\nstatic worker_t *workers;\n\ntypedef struct render_details\n{\n\t/* Page */\n\tfz_page *page;\n\n\t/* Display list */\n\tfz_display_list *list;\n\n\t/* Raw bounds */\n\tfz_rect bounds;\n\n\t/* Transformed bounds */\n\tfz_rect tbounds;\n\n\t/* Rounded transformed bounds */\n\tfz_irect ibounds;\n\n\t/* Transform matrix */\n\tfz_matrix ctm;\n\n\t/* How many min band heights are we working in? */\n\tint band_height_multiple;\n\n\t/* What colorspace are we working in? (Adjusted for fallback) */\n\tint colorspace;\n\n\t/* What output format? (Adjusted for fallback) */\n\tint format;\n\n\t/* During the course of the rendering, this keeps track of\n\t * how many 'min_band_heights' have been safely rendered. */\n\tint bands_rendered;\n\n\t/* The maximum number of workers we'll try to use. This\n\t * will start at the maximum value, and may drop to 0\n\t * if we have problems with memory. */\n\tint num_workers;\n\n\t/* The band writer to output the page */\n\tfz_band_writer *bander;\n\n\t/* Number of components in image */\n\tint n;\n} render_details;\n\nenum\n{\n\tRENDER_OK = 0,\n\tRENDER_RETRY = 1,\n\tRENDER_FATAL = 2\n};\n\nstatic struct {\n\tint active;\n\tint started;\n\tint solo;\n\tint status;\n\tfz_context *ctx;\n\tmu_thread thread;\n\tmu_semaphore start;\n\tmu_semaphore stop;\n\tint pagenum;\n\tchar *filename;\n\trender_details render;\n\tint interptime;\n} bgprint;\n\nstatic struct {\n\tint count, total;\n\tint min, max;\n\tint mininterp, maxinterp;\n\tint minpage, maxpage;\n\tchar *minfilename;\n\tchar *maxfilename;\n} timing;\n\n#define stringify(A) #A\n\nstatic int usage(void)\n{\n\tfprintf(stderr,\n\t\t\"muraster version \" FZ_VERSION \"\\n\"\n\t\t\"Usage: muraster [options] file [pages]\\n\"\n\t\t\"\\t-p -\\tpassword\\n\"\n\t\t\"\\n\"\n\t\t\"\\t-o -\\toutput file name\\n\"\n\t\t\"\\t-F -\\toutput format (default inferred from output file name)\\n\"\n\t\t\"\\t\\tpam, pbm, pgm, pkm, ppm\\n\"\n\t\t\"\\n\"\n\t\t\"\\t-s -\\tshow extra information:\\n\"\n\t\t\"\\t\\tm - show memory use\\n\"\n\t\t\"\\t\\tt - show timings\\n\"\n\t\t\"\\n\"\n\t\t\"\\t-R {auto,0,90,180,270}\\n\"\n\t\t\"\\t\\trotate clockwise (default: auto)\\n\"\n\t\t\"\\t-r -{,_}\\tx and y resolution in dpi (default: \" stringify(X_RESOLUTION) \"x\" stringify(Y_RESOLUTION) \")\\n\"\n\t\t\"\\t-w -\\tprintable width (in inches) (default: \" stringify(PAPER_WIDTH) \")\\n\"\n\t\t\"\\t-h -\\tprintable height (in inches) (default: \" stringify(PAPER_HEIGHT) \"\\n\"\n\t\t\"\\t-f\\tfit file to page if too large\\n\"\n\t\t\"\\t-B -\\tminimum band height (e.g. 32)\\n\"\n\t\t\"\\t-M -\\tmax bandmemory (e.g. 655360)\\n\"\n#ifndef DISABLE_MUTHREADS\n\t\t\"\\t-T -\\tnumber of threads to use for rendering\\n\"\n\t\t\"\\t-P\\tparallel interpretation/rendering\\n\"\n#endif\n\t\t\"\\n\"\n\t\t\"\\t-W -\\tpage width for EPUB layout\\n\"\n\t\t\"\\t-H -\\tpage height for EPUB layout\\n\"\n\t\t\"\\t-S -\\tfont size for EPUB layout\\n\"\n\t\t\"\\t-U -\\tfile name of user stylesheet for EPUB layout\\n\"\n\t\t\"\\t-X\\tdisable document styles for EPUB layout\\n\"\n\t\t\"\\n\"\n\t\t\"\\t-A -\\tnumber of bits of antialiasing (0 to 8)\\n\"\n\t\t\"\\t-A -/-\\tnumber of bits of antialiasing (0 to 8) (graphics, text)\\n\"\n\t\t\"\\n\"\n\t\t\"\\tpages\\tcomma separated list of page numbers and ranges\\n\"\n\t\t);\n\treturn 1;\n}\n\nstatic int gettime(void)\n{\n\tstatic struct timeval first;\n\tstatic int once = 1;\n\tstruct timeval now;\n\tif (once)\n\t{\n\t\tgettimeofday(&first, NULL);\n\t\tonce = 0;\n\t}\n\tgettimeofday(&now, NULL);\n\treturn (now.tv_sec - first.tv_sec) * 1000 + (now.tv_usec - first.tv_usec) / 1000;\n}\n\nstatic int drawband(fz_context *ctx, fz_page *page, fz_display_list *list, fz_matrix ctm, fz_rect tbounds, fz_cookie *cookie, int band_start, fz_pixmap *pix, fz_bitmap **bit)\n{\n\tfz_device *dev = NULL;\n\n\t*bit = NULL;\n\n\tfz_try(ctx)\n\t{\n\t\tfz_clear_pixmap_with_value(ctx, pix, 255);\n\n\t\tdev = fz_new_draw_device(ctx, fz_identity, pix);\n\t\tif (alphabits_graphics == 0)\n\t\t\tfz_enable_device_hints(ctx, dev, FZ_DONT_INTERPOLATE_IMAGES);\n\t\tif (list)\n\t\t\tfz_run_display_list(ctx, list, dev, ctm, tbounds, cookie);\n\t\telse\n\t\t\tfz_run_page(ctx, page, dev, ctm, cookie);\n\t\tfz_close_device(ctx, dev);\n\t\tfz_drop_device(ctx, dev);\n\t\tdev = NULL;\n\n\t\tif ((output_format == OUT_PBM) || (output_format == OUT_PKM))\n\t\t\t*bit = fz_new_bitmap_from_pixmap_band(ctx, pix, NULL, band_start);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_drop_device(ctx, dev);\n\t\treturn RENDER_RETRY;\n\t}\n\treturn RENDER_OK;\n}\n\nstatic int dodrawpage(fz_context *ctx, int pagenum, fz_cookie *cookie, render_details *render)\n{\n\tfz_pixmap *pix = NULL;\n\tfz_bitmap *bit = NULL;\n\tint errors_are_fatal = 0;\n\tfz_irect ibounds = render->ibounds;\n\tfz_rect tbounds = render->tbounds;\n\tint total_height = ibounds.y1 - ibounds.y0;\n\tint start_offset = min_band_height * render->bands_rendered;\n\tint remaining_start = ibounds.y0 + start_offset;\n\tint remaining_height = ibounds.y1 - remaining_start;\n\tint band_height = min_band_height * render->band_height_multiple;\n\tint bands = (remaining_height + band_height-1) / band_height;\n\tfz_matrix ctm = render->ctm;\n\tint band;\n\n\tfz_var(pix);\n\tfz_var(bit);\n\tfz_var(errors_are_fatal);\n\n\tfz_try(ctx)\n\t{\n\t\t/* Set up ibounds and tbounds for a single band_height band.\n\t\t * We will adjust ctm as we go. */\n\t\tibounds.y1 = ibounds.y0 + band_height;\n\t\ttbounds.y1 = tbounds.y0 + band_height + 2;\n\t\tDEBUG_THREADS((\"Using %d Bands\\n\", bands));\n\t\tctm.f += start_offset;\n\n\t\tif (render->num_workers > 0)\n\t\t{\n\t\t\tfor (band = 0; band < fz_mini(render->num_workers, bands); band++)\n\t\t\t{\n\t\t\t\tint band_start = start_offset + band * band_height;\n\t\t\t\tworker_t *w = &workers[band];\n\t\t\t\tw->band_start = band_start;\n\t\t\t\tw->ctm = ctm;\n\t\t\t\tw->tbounds = tbounds;\n\t\t\t\tmemset(&w->cookie, 0, sizeof(fz_cookie));\n\t\t\t\tw->list = render->list;\n\t\t\t\tif (remaining_height < band_height)\n\t\t\t\t\tibounds.y1 = ibounds.y0 + remaining_height;\n\t\t\t\tremaining_height -= band_height;\n\t\t\t\tw->pix = fz_new_pixmap_with_bbox(ctx, colorspace, ibounds, NULL, 0);\n\t\t\t\tw->pix->y += band * band_height;\n\t\t\t\tfz_set_pixmap_resolution(ctx, w->pix, x_resolution, y_resolution);\n\t\t\t\tDEBUG_THREADS((\"Worker %d, Pre-triggering band %d\\n\", band, band));\n\t\t\t\tw->started = 1;\n\t\t\t\tmu_trigger_semaphore(&w->start);\n\t\t\t}\n\t\t\tpix = workers[0].pix;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpix = fz_new_pixmap_with_bbox(ctx, colorspace, ibounds, NULL, 0);\n\t\t\tfz_set_pixmap_resolution(ctx, pix, x_resolution, y_resolution);\n\t\t}\n\n\t\tfor (band = 0; band < bands; band++)\n\t\t{\n\t\t\tint status;\n\t\t\tint band_start = start_offset + band * band_height;\n\t\t\tint draw_height = total_height - band_start;\n\n\t\t\tif (draw_height > band_height)\n\t\t\t\tdraw_height = band_height;\n\n\t\t\tif (render->num_workers > 0)\n\t\t\t{\n\t\t\t\tworker_t *w = &workers[band % render->num_workers];\n\t\t\t\tDEBUG_THREADS((\"Waiting for worker %d to complete band %d\\n\", w->num, band));\n\t\t\t\tmu_wait_semaphore(&w->stop);\n\t\t\t\tw->started = 0;\n\t\t\t\tstatus = w->status;\n\t\t\t\tpix = w->pix;\n\t\t\t\tbit = w->bit;\n\t\t\t\tw->bit = NULL;\n\t\t\t\tcookie->errors += w->cookie.errors;\n\t\t\t}\n\t\t\telse\n\t\t\t\tstatus = drawband(ctx, render->page, render->list, ctm, tbounds, cookie, band_start, pix, &bit);\n\n\t\t\tif (status != RENDER_OK)\n\t\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Render failed\");\n\n\t\t\trender->bands_rendered += render->band_height_multiple;\n\n\t\t\tif (out)\n\t\t\t{\n\t\t\t\t/* If we get any errors while outputting the bands, retrying won't help. */\n\t\t\t\terrors_are_fatal = 1;\n\t\t\t\tfz_write_band(ctx, render->bander, bit ? bit->stride : pix->stride, draw_height, bit ? bit->samples : pix->samples);\n\t\t\t\terrors_are_fatal = 0;\n\t\t\t}\n\t\t\tfz_drop_bitmap(ctx, bit);\n\t\t\tbit = NULL;\n\n\t\t\tif (render->num_workers > 0 && band + render->num_workers < bands)\n\t\t\t{\n\t\t\t\tworker_t *w = &workers[band % render->num_workers];\n\t\t\t\tw->band_start = band_start;\n\t\t\t\tw->ctm = ctm;\n\t\t\t\tw->tbounds = tbounds;\n\t\t\t\tmemset(&w->cookie, 0, sizeof(fz_cookie));\n\t\t\t\tDEBUG_THREADS((\"Triggering worker %d for band_start= %d\\n\", w->num, w->band_start));\n\t\t\t\tw->started = 1;\n\t\t\t\tmu_trigger_semaphore(&w->start);\n\t\t\t}\n\t\t\tif (render->num_workers <= 0)\n\t\t\t\tpix += draw_height;\n\t\t}\n\t}\n\tfz_always(ctx)\n\t{\n\t\tfz_drop_bitmap(ctx, bit);\n\t\tbit = NULL;\n\t\tif (render->num_workers > 0)\n\t\t{\n\t\t\tint band;\n\t\t\tfor (band = 0; band < fz_mini(render->num_workers, bands); band++)\n\t\t\t{\n\t\t\t\tworker_t *w = &workers[band];\n\t\t\t\tw->cookie.abort = 1;\n\t\t\t\tif (w->started)\n\t\t\t\t{\n\t\t\t\t\tmu_wait_semaphore(&w->stop);\n\t\t\t\t\tw->started = 0;\n\t\t\t\t}\n\t\t\t\tfz_drop_pixmap(ctx, w->pix);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tfz_drop_pixmap(ctx, pix);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\t/* Swallow error */\n\t\tif (errors_are_fatal)\n\t\t\treturn RENDER_FATAL;\n\t\treturn RENDER_RETRY;\n\t}\n\tif (cookie->errors)\n\t\terrored = 1;\n\n\treturn RENDER_OK;\n}\n\n/* This functions tries to render a page, falling back repeatedly to try and make it work. */\nstatic int try_render_page(fz_context *ctx, int pagenum, fz_cookie *cookie, int start, int interptime, char *fname, int bg, int solo, render_details *render)\n{\n\tint status;\n\n\tif (out && !(bg && solo))\n\t{\n\t\t/* Output any page level headers (for banded formats). Don't do this if\n\t\t * we're running in solo bgprint mode, cos we've already done it once! */\n\t\tfz_try(ctx)\n\t\t{\n\t\t\tint w = render->ibounds.x1 - render->ibounds.x0;\n\t\t\tint h = render->ibounds.y1 - render->ibounds.y0;\n\t\t\tfz_write_header(ctx, render->bander, w, h, render->n, 0, 0, 0, 0, 0, NULL);\n\t\t}\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\t/* Failure! */\n\t\t\treturn RENDER_FATAL;\n\t\t}\n\t}\n\n\twhile (1)\n\t{\n\t\tstatus = dodrawpage(ctx, pagenum, cookie, render);\n\t\tif (status == RENDER_OK || status == RENDER_FATAL)\n\t\t\tbreak;\n\n\t\t/* If we are bgprinting, then ask the caller to try us again in solo mode. */\n\t\tif (bg && !solo)\n\t\t{\n\t\t\tDEBUG_THREADS((\"Render failure; trying again in solo mode\\n\"));\n\t\t\treturn RENDER_RETRY; /* Avoids all the cleanup below! */\n\t\t}\n\n\t\t/* Try again with fewer threads */\n\t\tif (render->num_workers > 1)\n\t\t{\n\t\t\trender->num_workers >>= 1;\n\t\t\tDEBUG_THREADS((\"Render failure; trying again with %d render threads\\n\", render->num_workers));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Halve the band height, if we still can. */\n\t\tif (render->band_height_multiple > 2)\n\t\t{\n\t\t\trender->band_height_multiple >>= 1;\n\t\t\tDEBUG_THREADS((\"Render failure; trying again with %d band height multiple\\n\", render->band_height_multiple));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* If all else fails, ditch the list and try again. */\n\t\tif (render->list)\n\t\t{\n\t\t\tfz_drop_display_list(ctx, render->list);\n\t\t\trender->list = NULL;\n\t\t\tDEBUG_THREADS((\"Render failure; trying again with no list\\n\"));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Give up. */\n\t\tDEBUG_THREADS((\"Render failure; nothing else to try\\n\"));\n\t\tbreak;\n\t}\n\n\tfz_close_band_writer(ctx, render->bander);\n\n\tfz_drop_page(ctx, render->page);\n\tfz_drop_display_list(ctx, render->list);\n\tfz_drop_band_writer(ctx, render->bander);\n\n\tif (showtime)\n\t{\n\t\tint end = gettime();\n\t\tint diff = end - start;\n\n\t\tif (bg)\n\t\t{\n\t\t\tif (diff + interptime < timing.min)\n\t\t\t{\n\t\t\t\ttiming.min = diff + interptime;\n\t\t\t\ttiming.mininterp = interptime;\n\t\t\t\ttiming.minpage = pagenum;\n\t\t\t\ttiming.minfilename = fname;\n\t\t\t}\n\t\t\tif (diff + interptime > timing.max)\n\t\t\t{\n\t\t\t\ttiming.max = diff + interptime;\n\t\t\t\ttiming.maxinterp = interptime;\n\t\t\t\ttiming.maxpage = pagenum;\n\t\t\t\ttiming.maxfilename = fname;\n\t\t\t}\n\t\t\ttiming.total += diff + interptime;\n\t\t\ttiming.count ++;\n\n\t\t\tfprintf(stderr, \" %dms (interpretation) %dms (rendering) %dms (total)\\n\", interptime, diff, diff + interptime);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (diff < timing.min)\n\t\t\t{\n\t\t\t\ttiming.min = diff;\n\t\t\t\ttiming.minpage = pagenum;\n\t\t\t\ttiming.minfilename = fname;\n\t\t\t}\n\t\t\tif (diff > timing.max)\n\t\t\t{\n\t\t\t\ttiming.max = diff;\n\t\t\t\ttiming.maxpage = pagenum;\n\t\t\t\ttiming.maxfilename = fname;\n\t\t\t}\n\t\t\ttiming.total += diff;\n\t\t\ttiming.count ++;\n\n\t\t\tfprintf(stderr, \" %dms\\n\", diff);\n\t\t}\n\t}\n\n\tif (showmemory)\n\t{\n\t\tfz_dump_glyph_cache_stats(ctx, fz_stderr(ctx));\n\t}\n\n\tfz_flush_warnings(ctx);\n\n\treturn status;\n}\n\nstatic int wait_for_bgprint_to_finish(void)\n{\n\tif (!bgprint.active || !bgprint.started)\n\t\treturn 0;\n\n\tmu_wait_semaphore(&bgprint.stop);\n\tbgprint.started = 0;\n\treturn bgprint.status;\n}\n\nstatic void\nget_page_render_details(fz_context *ctx, fz_page *page, render_details *render)\n{\n\tfloat page_width, page_height;\n\tint rot;\n\tfloat s_x, s_y;\n\n\trender->page = page;\n\trender->list = NULL;\n\trender->num_workers = num_workers;\n\n\trender->bounds = fz_bound_page(ctx, page);\n\tpage_width = (render->bounds.x1 - render->bounds.x0)/72;\n\tpage_height = (render->bounds.y1 - render->bounds.y0)/72;\n\n\ts_x = x_resolution / 72;\n\ts_y = y_resolution / 72;\n\tif (rotation == -1)\n\t{\n\t\t/* Automatic rotation. If we fit, use 0. If we don't, and 90 would be 'better' use that. */\n\t\tif (page_width <= width && page_height <= height)\n\t\t{\n\t\t\t/* Page fits, so use no rotation. */\n\t\t\trot = 0;\n\t\t}\n\t\telse if (fit)\n\t\t{\n\t\t\t/* Use whichever gives the biggest scale */\n\t\t\tfloat sx_0 = width / page_width;\n\t\t\tfloat sy_0 = height / page_height;\n\t\t\tfloat sx_90 = height / page_width;\n\t\t\tfloat sy_90 = width / page_height;\n\t\t\tfloat s_0, s_90;\n\t\t\ts_0 = fz_min(sx_0, sy_0);\n\t\t\ts_90 = fz_min(sx_90, sy_90);\n\t\t\tif (s_0 >= s_90)\n\t\t\t{\n\t\t\t\trot = 0;\n\t\t\t\tif (s_0 < 1)\n\t\t\t\t{\n\t\t\t\t\ts_x *= s_0;\n\t\t\t\t\ts_y *= s_0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trot = 90;\n\t\t\t\tif (s_90 < 1)\n\t\t\t\t{\n\t\t\t\t\ts_x *= s_90;\n\t\t\t\t\ts_y *= s_90;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Use whichever crops the least area */\n\t\t\tfloat lost0 = 0;\n\t\t\tfloat lost90 = 0;\n\n\t\t\tif (page_width > width)\n\t\t\t\tlost0 += (page_width - width) * (page_height > height ? height : page_height);\n\t\t\tif (page_height > height)\n\t\t\t\tlost0 += (page_height - height) * page_width;\n\n\t\t\tif (page_width > height)\n\t\t\t\tlost90 += (page_width - height) * (page_height > width ? width : page_height);\n\t\t\tif (page_height > width)\n\t\t\t\tlost90 += (page_height - width) * page_width;\n\n\t\t\trot = (lost0 <= lost90 ? 0 : 90);\n\t\t}\n\t}\n\telse\n\t{\n\t\trot = rotation;\n\t}\n\n\trender->ctm = fz_pre_scale(fz_rotate(rot), s_x, s_y);\n\trender->tbounds = fz_transform_rect(render->bounds, render->ctm);;\n\trender->ibounds = fz_round_rect(render->tbounds);\n}\n\nstatic void\ninitialise_banding(fz_context *ctx, render_details *render, int color)\n{\n\tsize_t min_band_mem;\n\tint bpp, h, w, reps;\n\n\trender->colorspace = output_cs;\n\trender->format = output_format;\n#if GREY_FALLBACK != 0\n\tif (color == 0)\n\t{\n\t\tif (render->colorspace == CS_RGB)\n\t\t{\n\t\t\t/* Fallback from PPM to PGM */\n\t\t\trender->colorspace = CS_GRAY;\n\t\t\trender->format = OUT_PGM;\n\t\t}\n\t\telse if (render->colorspace == CS_CMYK)\n\t\t{\n\t\t\trender->colorspace = CS_GRAY;\n\t\t\tif (render->format == OUT_PKM)\n\t\t\t\trender->format = OUT_PBM;\n\t\t\telse\n\t\t\t\trender->format = OUT_PGM;\n\t\t}\n\t}\n#endif\n\n\tswitch (render->colorspace)\n\t{\n\tcase CS_GRAY:\n\t\tbpp = 1;\n\t\tbreak;\n\tcase CS_RGB:\n\t\tbpp = 2;\n\t\tbreak;\n\tdefault:\n\tcase CS_CMYK:\n\t\tbpp = 3;\n\t\tbreak;\n\t}\n\n\tw = render->ibounds.x1 - render->ibounds.x0;\n\tmin_band_mem = (size_t)bpp * w * min_band_height;\n\tif (min_band_mem > 0)\n\t\treps = (int)(max_band_memory / min_band_mem);\n\tif (min_band_mem == 0 || reps < 1)\n\t\treps = 1;\n\n\t/* Adjust reps to even out the work between threads */\n\tif (render->num_workers > 0)\n\t{\n\t\tint runs, num_bands;\n\t\th = render->ibounds.y1 - render->ibounds.y0;\n\t\tnum_bands = (h + min_band_height - 1) / min_band_height;\n\t\t/* num_bands = number of min_band_height bands */\n\t\truns = (num_bands + reps-1) / reps;\n\t\t/* runs = number of worker runs of reps min_band_height bands */\n\t\truns = ((runs + render->num_workers - 1) / render->num_workers) * render->num_workers;\n\t\t/* runs = number of worker runs rounded up to make use of all our threads */\n\t\treps = (num_bands + runs - 1) / runs;\n\t}\n\n\trender->band_height_multiple = reps;\n\trender->bands_rendered = 0;\n\n\tif (output_format == OUT_PGM || output_format == OUT_PPM)\n\t{\n\t\trender->bander = fz_new_pnm_band_writer(ctx, out);\n\t\trender->n = output_format == OUT_PGM ? 1 : 3;\n\t}\n\telse if (output_format == OUT_PAM)\n\t{\n\t\trender->bander = fz_new_pam_band_writer(ctx, out);\n\t\trender->n = 4;\n\t}\n\telse if (output_format == OUT_PBM)\n\t{\n\t\trender->bander = fz_new_pbm_band_writer(ctx, out);\n\t\trender->n = 1;\n\t}\n\telse if (output_format == OUT_PKM)\n\t{\n\t\trender->bander = fz_new_pkm_band_writer(ctx, out);\n\t\trender->n = 4;\n\t}\n}\n\nstatic void drawpage(fz_context *ctx, fz_document *doc, int pagenum)\n{\n\tfz_page *page;\n\tfz_display_list *list = NULL;\n\tfz_device *list_dev = NULL;\n\tint start;\n\tfz_cookie cookie = { 0 };\n#if GREY_FALLBACK != 0\n\tfz_device *test_dev = NULL;\n\tint is_color = 0;\n#else\n\tint is_color = 2;\n#endif\n\trender_details render;\n\tint status;\n\n\tfz_var(list);\n\tfz_var(list_dev);\n\tfz_var(test_dev);\n\n\tdo\n\t{\n\t\tstart = (showtime ? gettime() : 0);\n\n\t\tpage = fz_load_page(ctx, doc, pagenum - 1);\n\n\t\t/* Calculate Page bounds, transform etc */\n\t\tget_page_render_details(ctx, page, &render);\n\n\t\t/* Make the display list, and see if we need color */\n\t\tfz_try(ctx)\n\t\t{\n\t\t\tlist = fz_new_display_list(ctx, render.bounds);\n\t\t\tlist_dev = fz_new_list_device(ctx, list);\n#if GREY_FALLBACK != 0\n\t\t\ttest_dev = fz_new_test_device(ctx, &is_color, 0.01f, 0, list_dev);\n\t\t\tfz_run_page(ctx, page, test_dev, fz_identity, &cookie);\n\t\t\tfz_close_device(ctx, test_dev);\n#else\n\t\t\tfz_run_page(ctx, page, list_dev, fz_identity, &cookie);\n#endif\n\t\t\tfz_close_device(ctx, list_dev);\n\t\t}\n\t\tfz_always(ctx)\n\t\t{\n#if GREY_FALLBACK != 0\n\t\t\tfz_drop_device(ctx, test_dev);\n#endif\n\t\t\tfz_drop_device(ctx, list_dev);\n\t\t}\n\t\tfz_catch(ctx)\n\t\t{\n\t\t\tfz_drop_display_list(ctx, list);\n\t\t\tlist = NULL;\n\t\t\t/* Just continue with no list. Also, we can't do multiple\n\t\t\t * threads if we have no list. */\n\t\t\trender.num_workers = 1;\n\t\t}\n\t\trender.list = list;\n\n#if GREY_FALLBACK != 0\n\t\tif (list == NULL)\n\t\t{\n\t\t\t/* We need to know about color, but the previous test failed\n\t\t\t * (presumably) due to the size of the list. Rerun direct\n\t\t\t * from file. */\n\t\t\tfz_try(ctx)\n\t\t\t{\n\t\t\t\ttest_dev = fz_new_test_device(ctx, &is_color, 0.01f, 0, NULL);\n\t\t\t\tfz_run_page(ctx, page, test_dev, fz_identity, &cookie);\n\t\t\t\tfz_close_device(ctx, test_dev);\n\t\t\t}\n\t\t\tfz_always(ctx)\n\t\t\t{\n\t\t\t\tfz_drop_device(ctx, test_dev);\n\t\t\t}\n\t\t\tfz_catch(ctx)\n\t\t\t{\n\t\t\t\t/* We failed. Just give up. */\n\t\t\t\tfz_drop_page(ctx, page);\n\t\t\t\tfz_rethrow(ctx);\n\t\t\t}\n\t\t}\n#endif\n\n#if GREY_FALLBACK == 2\n\t\t/* If we 'possibly' need color, find out if we 'really' need color. */\n\t\tif (is_color == 1)\n\t\t{\n\t\t\t/* We know that the device has images or shadings in\n\t\t\t * colored spaces. We have been told to test exhaustively\n\t\t\t * so we know whether to use color or grey rendering. */\n\t\t\tis_color = 0;\n\t\t\tfz_try(ctx)\n\t\t\t{\n\t\t\t\ttest_dev = fz_new_test_device(ctx, &is_color, 0.01f, FZ_TEST_OPT_IMAGES | FZ_TEST_OPT_SHADINGS, NULL);\n\t\t\t\tif (list)\n\t\t\t\t\tfz_run_display_list(ctx, list, test_dev, &fz_identity, &fz_infinite_rect, &cookie);\n\t\t\t\telse\n\t\t\t\t\tfz_run_page(ctx, page, test_dev, &fz_identity, &cookie);\n\t\t\t\tfz_close_device(ctx, test_dev);\n\t\t\t}\n\t\t\tfz_always(ctx)\n\t\t\t{\n\t\t\t\tfz_drop_device(ctx, test_dev);\n\t\t\t}\n\t\t\tfz_catch(ctx)\n\t\t\t{\n\t\t\t\tfz_drop_display_list(ctx, list);\n\t\t\t\tfz_drop_page(ctx, page);\n\t\t\t\tfz_rethrow(ctx);\n\t\t\t}\n\t\t}\n#endif\n\n\t\t/* Figure out banding */\n\t\tinitialise_banding(ctx, &render, is_color);\n\n\t\tif (bgprint.active && showtime)\n\t\t{\n\t\t\tint end = gettime();\n\t\t\tstart = end - start;\n\t\t}\n\n\t\t/* If we're not using bgprint, then no need to wait */\n\t\tif (!bgprint.active)\n\t\t\tbreak;\n\n\t\t/* If we are using it, then wait for it to finish. */\n\t\tstatus = wait_for_bgprint_to_finish();\n\t\tif (status == RENDER_OK)\n\t\t{\n\t\t\t/* The background bgprint completed successfully. Drop out of the loop,\n\t\t\t * and carry on with our next page. */\n\t\t\tbreak;\n\t\t}\n\n\t\t/* The bgprint in the background failed! This might have been because\n\t\t * we were using memory etc in the foreground. We'd better ditch\n\t\t * everything we can and try again. */\n\t\tfz_drop_display_list(ctx, list);\n\t\tfz_drop_page(ctx, page);\n\n\t\tif (status == RENDER_FATAL)\n\t\t{\n\t\t\t/* We failed because of not being able to output. No point in retrying. */\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Failed to render page\");\n\t\t}\n\t\tbgprint.started = 1;\n\t\tbgprint.solo = 1;\n\t\tmu_trigger_semaphore(&bgprint.start);\n\t\tstatus = wait_for_bgprint_to_finish();\n\t\tif (status != 0)\n\t\t{\n\t\t\t/* Hard failure */\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Failed to render page\");\n\t\t}\n\t\t/* Loop back to reload this page */\n\t}\n\twhile (1);\n\n\tif (showtime)\n\t{\n\t\tfprintf(stderr, \"page %s %d\", filename, pagenum);\n\t}\n\tif (bgprint.active)\n\t{\n\t\tbgprint.started = 1;\n\t\tbgprint.solo = 0;\n\t\tbgprint.render = render;\n\t\tbgprint.filename = filename;\n\t\tbgprint.pagenum = pagenum;\n\t\tbgprint.interptime = start;\n\t\tmu_trigger_semaphore(&bgprint.start);\n\t}\n\telse\n\t{\n\t\tif (try_render_page(ctx, pagenum, &cookie, start, 0, filename, 0, 0, &render))\n\t\t{\n\t\t\t/* Hard failure */\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Failed to render page\");\n\t\t}\n\t}\n}\n\n/* Wait for the final page being printed by bgprint to complete,\n * retrying if necessary. */\nstatic void\nfinish_bgprint(fz_context *ctx)\n{\n\tint status;\n\n\tif (!bgprint.active)\n\t\treturn;\n\n\t/* If we are using it, then wait for it to finish. */\n\tstatus = wait_for_bgprint_to_finish();\n\tif (status == RENDER_OK)\n\t{\n\t\t/* The background bgprint completed successfully. */\n\t\treturn;\n\t}\n\n\tif (status == RENDER_FATAL)\n\t{\n\t\t/* We failed because of not being able to output. No point in retrying. */\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Failed to render page\");\n\t}\n\tbgprint.started = 1;\n\tbgprint.solo = 1;\n\tmu_trigger_semaphore(&bgprint.start);\n\tstatus = wait_for_bgprint_to_finish();\n\tif (status != 0)\n\t{\n\t\t/* Hard failure */\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Failed to render page\");\n\t}\n}\n\nstatic void drawrange(fz_context *ctx, fz_document *doc, const char *range)\n{\n\tint page, spage, epage, pagecount;\n\n\tpagecount = fz_count_pages(ctx, doc);\n\n\twhile ((range = fz_parse_page_range(ctx, range, &spage, &epage, pagecount)))\n\t{\n\t\tif (spage < epage)\n\t\t\tfor (page = spage; page <= epage; page++)\n\t\t\t\tdrawpage(ctx, doc, page);\n\t\telse\n\t\t\tfor (page = spage; page >= epage; page--)\n\t\t\t\tdrawpage(ctx, doc, page);\n\t}\n}\n\ntypedef struct\n{\n\tsize_t size;\n#if defined(_M_IA64) || defined(_M_AMD64)\n\tsize_t align;\n#endif\n} trace_header;\n\ntypedef struct\n{\n\tsize_t current;\n\tsize_t peak;\n\tsize_t total;\n} trace_info;\n\nstatic void *\ntrace_malloc(void *arg, size_t size)\n{\n\ttrace_info *info = (trace_info *) arg;\n\ttrace_header *p;\n\tif (size == 0)\n\t\treturn NULL;\n\tp = malloc(size + sizeof(trace_header));\n\tif (p == NULL)\n\t\treturn NULL;\n\tp[0].size = size;\n\tinfo->current += size;\n\tinfo->total += size;\n\tif (info->current > info->peak)\n\t\tinfo->peak = info->current;\n\treturn (void *)&p[1];\n}\n\nstatic void\ntrace_free(void *arg, void *p_)\n{\n\ttrace_info *info = (trace_info *) arg;\n\ttrace_header *p = (trace_header *)p_;\n\n\tif (p == NULL)\n\t\treturn;\n\tinfo->current -= p[-1].size;\n\tfree(&p[-1]);\n}\n\nstatic void *\ntrace_realloc(void *arg, void *p_, size_t size)\n{\n\ttrace_info *info = (trace_info *) arg;\n\ttrace_header *p = (trace_header *)p_;\n\tsize_t oldsize;\n\n\tif (size == 0)\n\t{\n\t\ttrace_free(arg, p_);\n\t\treturn NULL;\n\t}\n\tif (p == NULL)\n\t\treturn trace_malloc(arg, size);\n\toldsize = p[-1].size;\n\tp = realloc(&p[-1], size + sizeof(trace_header));\n\tif (p == NULL)\n\t\treturn NULL;\n\tinfo->current += size - oldsize;\n\tif (size > oldsize)\n\t\tinfo->total += size - oldsize;\n\tif (info->current > info->peak)\n\t\tinfo->peak = info->current;\n\tp[0].size = size;\n\treturn &p[1];\n}\n\n#ifndef DISABLE_MUTHREADS\nstatic void worker_thread(void *arg)\n{\n\tworker_t *me = (worker_t *)arg;\n\tint band_start;\n\n\tdo\n\t{\n\t\tDEBUG_THREADS((\"Worker %d waiting\\n\", me->num));\n\t\tmu_wait_semaphore(&me->start);\n\t\tband_start = me->band_start;\n\t\tDEBUG_THREADS((\"Worker %d woken for band_start %d\\n\", me->num, me->band_start));\n\t\tme->status = RENDER_OK;\n\t\tif (band_start >= 0)\n\t\t\tme->status = drawband(me->ctx, NULL, me->list, me->ctm, me->tbounds, &me->cookie, band_start, me->pix, &me->bit);\n\t\tDEBUG_THREADS((\"Worker %d completed band_start %d (status=%d)\\n\", me->num, band_start, me->status));\n\t\tmu_trigger_semaphore(&me->stop);\n\t}\n\twhile (band_start >= 0);\n}\n\nstatic void bgprint_worker(void *arg)\n{\n\tfz_cookie cookie = { 0 };\n\tint pagenum;\n\n\t(void)arg;\n\n\tdo\n\t{\n\t\tDEBUG_THREADS((\"BGPrint waiting\\n\"));\n\t\tmu_wait_semaphore(&bgprint.start);\n\t\tpagenum = bgprint.pagenum;\n\t\tDEBUG_THREADS((\"BGPrint woken for pagenum %d\\n\", pagenum));\n\t\tif (pagenum >= 0)\n\t\t{\n\t\t\tint start = gettime();\n\t\t\tmemset(&cookie, 0, sizeof(cookie));\n\t\t\tbgprint.status = try_render_page(bgprint.ctx, pagenum, &cookie, start, bgprint.interptime, bgprint.filename, 1, bgprint.solo, &bgprint.render);\n\t\t}\n\t\tDEBUG_THREADS((\"BGPrint completed page %d\\n\", pagenum));\n\t\tmu_trigger_semaphore(&bgprint.stop);\n\t}\n\twhile (pagenum >= 0);\n}\n#endif\n\nstatic void\nread_resolution(const char *arg)\n{\n\tchar *sep = strchr(arg, ',');\n\n\tif (sep == NULL)\n\t\tsep = strchr(arg, 'x');\n\tif (sep == NULL)\n\t\tsep = strchr(arg, ':');\n\tif (sep == NULL)\n\t\tsep = strchr(arg, ';');\n\n\tx_resolution = fz_atoi(arg);\n\tif (sep && sep[1])\n\t\ty_resolution = fz_atoi(arg);\n\telse\n\t\ty_resolution = x_resolution;\n}\n\nstatic int\nread_rotation(const char *arg)\n{\n\tint i;\n\n\tif (strcmp(arg, \"auto\"))\n\t{\n\t\treturn -1;\n\t}\n\n\ti = fz_atoi(arg);\n\n\ti = i % 360;\n\tif (i % 90 != 0)\n\t{\n\t\tfprintf(stderr, \"Ignoring invalid rotation\\n\");\n\t\ti = 0;\n\t}\n\n\treturn i;\n}\n\nint main(int argc, char **argv)\n{\n\tchar *password = \"\";\n\tfz_document *doc = NULL;\n\tint c;\n\tfz_context *ctx;\n\ttrace_info info = { 0, 0, 0 };\n\tfz_alloc_context alloc_ctx = { &info, trace_malloc, trace_realloc, trace_free };\n\tfz_locks_context *locks = NULL;\n\n\tfz_var(doc);\n\n\tbgprint.active = 0;\t\t\t/* set by -P */\n\tmin_band_height = MIN_BAND_HEIGHT;\n\tmax_band_memory = BAND_MEMORY;\n\twidth = 0;\n\theight = 0;\n\tnum_workers = NUM_RENDER_THREADS;\n\tx_resolution = X_RESOLUTION;\n\ty_resolution = Y_RESOLUTION;\n\n\twhile ((c = fz_getopt(argc, argv, \"p:o:F:R:r:w:h:fB:M:s:A:iW:H:S:T:U:XvP\")) != -1)\n\t{\n\t\tswitch (c)\n\t\t{\n\t\tdefault: return usage();\n\n\t\tcase 'p': password = fz_optarg; break;\n\n\t\tcase 'o': output = fz_optarg; break;\n\t\tcase 'F': format = fz_optarg; break;\n\n\t\tcase 'R': rotation = read_rotation(fz_optarg); break;\n\t\tcase 'r': read_resolution(fz_optarg); break;\n\t\tcase 'w': width = fz_atof(fz_optarg); break;\n\t\tcase 'h': height = fz_atof(fz_optarg); break;\n\t\tcase 'f': fit = 1; break;\n\t\tcase 'B': min_band_height = atoi(fz_optarg); break;\n\t\tcase 'M': max_band_memory = atoi(fz_optarg); break;\n\n\t\tcase 'W': layout_w = fz_atof(fz_optarg); break;\n\t\tcase 'H': layout_h = fz_atof(fz_optarg); break;\n\t\tcase 'S': layout_em = fz_atof(fz_optarg); break;\n\t\tcase 'U': layout_css = fz_optarg; break;\n\t\tcase 'X': layout_use_doc_css = 0; break;\n\n\t\tcase 's':\n\t\t\tif (strchr(fz_optarg, 't')) ++showtime;\n\t\t\tif (strchr(fz_optarg, 'm')) ++showmemory;\n\t\t\tbreak;\n\n\t\tcase 'A':\n\t\t{\n\t\t\tchar *sep;\n\t\t\talphabits_graphics = atoi(fz_optarg);\n\t\t\tsep = strchr(fz_optarg, '/');\n\t\t\tif (sep)\n\t\t\t\talphabits_text = atoi(sep+1);\n\t\t\telse\n\t\t\t\talphabits_text = alphabits_graphics;\n\t\t\tbreak;\n\t\t}\n\t\tcase 'i': ignore_errors = 1; break;\n\n\t\tcase 'T':\n#if MURASTER_THREADS != 0\n\t\t\tnum_workers = atoi(fz_optarg); break;\n#else\n\t\t\tfprintf(stderr, \"Threads not enabled in this build\\n\");\n\t\t\tbreak;\n#endif\n\t\tcase 'P':\n#if MURASTER_THREADS != 0\n\t\t\tbgprint.active = 1; break;\n#else\n\t\t\tfprintf(stderr, \"Threads not enabled in this build\\n\");\n\t\t\tbreak;\n#endif\n\t\tcase 'v': fprintf(stderr, \"muraster version %s\\n\", FZ_VERSION); return 1;\n\t\t}\n\t}\n\n\tif (width == 0)\n\t\twidth = x_resolution * PAPER_WIDTH;\n\n\tif (height == 0)\n\t\theight = y_resolution * PAPER_HEIGHT;\n\n\tif (fz_optind == argc)\n\t\treturn usage();\n\n\tif (min_band_height <= 0)\n\t{\n\t\tfprintf(stderr, \"Require a positive minimum band height\\n\");\n\t\texit(1);\n\t}\n\n#ifndef DISABLE_MUTHREADS\n\tlocks = init_muraster_locks();\n\tif (locks == NULL)\n\t{\n\t\tfprintf(stderr, \"cannot initialise mutexes\\n\");\n\t\texit(1);\n\t}\n#endif\n\n\tctx = fz_new_context((showmemory == 0 ? NULL : &alloc_ctx), locks, FZ_STORE_DEFAULT);\n\tif (!ctx)\n\t{\n\t\tfprintf(stderr, \"cannot initialise context\\n\");\n\t\texit(1);\n\t}\n\n\tfz_set_text_aa_level(ctx, alphabits_text);\n\tfz_set_graphics_aa_level(ctx, alphabits_graphics);\n\n#ifndef DISABLE_MUTHREADS\n\tif (bgprint.active)\n\t{\n\t\tint fail = 0;\n\t\tbgprint.ctx = fz_clone_context(ctx);\n\t\tfail |= mu_create_semaphore(&bgprint.start);\n\t\tfail |= mu_create_semaphore(&bgprint.stop);\n\t\tfail |= mu_create_thread(&bgprint.thread, bgprint_worker, NULL);\n\t\tif (fail)\n\t\t{\n\t\t\tfprintf(stderr, \"bgprint startup failed\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (num_workers > 0)\n\t{\n\t\tint i;\n\t\tint fail = 0;\n\t\tworkers = fz_calloc(ctx, num_workers, sizeof(*workers));\n\t\tfor (i = 0; i < num_workers; i++)\n\t\t{\n\t\t\tworkers[i].ctx = fz_clone_context(ctx);\n\t\t\tworkers[i].num = i;\n\t\t\tfail |= mu_create_semaphore(&workers[i].start);\n\t\t\tfail |= mu_create_semaphore(&workers[i].stop);\n\t\t\tfail |= mu_create_thread(&workers[i].thread, worker_thread, &workers[i]);\n\t\t}\n\t\tif (fail)\n\t\t{\n\t\t\tfprintf(stderr, \"worker startup failed\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n#endif /* DISABLE_MUTHREADS */\n\n\tif (layout_css)\n\t{\n\t\tfz_buffer *buf = fz_read_file(ctx, layout_css);\n\t\tfz_set_user_css(ctx, fz_string_from_buffer(ctx, buf));\n\t\tfz_drop_buffer(ctx, buf);\n\t}\n\n\tfz_set_use_document_css(ctx, layout_use_doc_css);\n\n\toutput_format = suffix_table[0].format;\n\toutput_cs = suffix_table[0].cs;\n\tif (format)\n\t{\n\t\tint i;\n\n\t\tfor (i = 0; i < (int)nelem(suffix_table); i++)\n\t\t{\n\t\t\tif (!strcmp(format, suffix_table[i].suffix+1))\n\t\t\t{\n\t\t\t\toutput_format = suffix_table[i].format;\n\t\t\t\toutput_cs = suffix_table[i].cs;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == (int)nelem(suffix_table))\n\t\t{\n\t\t\tfprintf(stderr, \"Unknown output format '%s'\\n\", format);\n\t\t\texit(1);\n\t\t}\n\t}\n\telse if (output)\n\t{\n\t\tchar *suffix = output;\n\t\tint i;\n\n\t\tfor (i = 0; i < (int)nelem(suffix_table); i++)\n\t\t{\n\t\t\tchar *s = strstr(suffix, suffix_table[i].suffix);\n\n\t\t\tif (s != NULL)\n\t\t\t{\n\t\t\t\tsuffix = s+1;\n\t\t\t\toutput_format = suffix_table[i].format;\n\t\t\t\toutput_cs = suffix_table[i].cs;\n\t\t\t\ti = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (output_cs)\n\t{\n\tcase CS_GRAY:\n\t\tcolorspace = fz_device_gray(ctx);\n\t\tbreak;\n\tcase CS_RGB:\n\t\tcolorspace = fz_device_rgb(ctx);\n\t\tbreak;\n\tcase CS_CMYK:\n\t\tcolorspace = fz_device_cmyk(ctx);\n\t\tbreak;\n\t}\n\n\tif (output && (output[0] != '-' || output[1] != 0) && *output != 0)\n\t{\n\t\tout = fz_new_output_with_path(ctx, output, 0);\n\t}\n\telse\n\t\tout = fz_stdout(ctx);\n\n\ttiming.count = 0;\n\ttiming.total = 0;\n\ttiming.min = 1 << 30;\n\ttiming.max = 0;\n\ttiming.mininterp = 1 << 30;\n\ttiming.maxinterp = 0;\n\ttiming.minpage = 0;\n\ttiming.maxpage = 0;\n\ttiming.minfilename = \"\";\n\ttiming.maxfilename = \"\";\n\n\tfz_try(ctx)\n\t{\n\t\tfz_register_document_handlers(ctx);\n\n\t\twhile (fz_optind < argc)\n\t\t{\n\t\t\tfz_try(ctx)\n\t\t\t{\n\t\t\t\tfilename = argv[fz_optind++];\n\n\t\t\t\tdoc = fz_open_document(ctx, filename);\n\n\t\t\t\tif (fz_needs_password(ctx, doc))\n\t\t\t\t{\n\t\t\t\t\tif (!fz_authenticate_password(ctx, doc, password))\n\t\t\t\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"cannot authenticate password: %s\", filename);\n\t\t\t\t}\n\n\t\t\t\tfz_layout_document(ctx, doc, layout_w, layout_h, layout_em);\n\n\t\t\t\tif (fz_optind == argc || !fz_is_page_range(ctx, argv[fz_optind]))\n\t\t\t\t\tdrawrange(ctx, doc, \"1-N\");\n\t\t\t\tif (fz_optind < argc && fz_is_page_range(ctx, argv[fz_optind]))\n\t\t\t\t\tdrawrange(ctx, doc, argv[fz_optind++]);\n\n\t\t\t\tfz_drop_document(ctx, doc);\n\t\t\t\tdoc = NULL;\n\t\t\t}\n\t\t\tfz_catch(ctx)\n\t\t\t{\n\t\t\t\tif (!ignore_errors)\n\t\t\t\t\tfz_rethrow(ctx);\n\n\t\t\t\tfz_drop_document(ctx, doc);\n\t\t\t\tdoc = NULL;\n\t\t\t\tfz_warn(ctx, \"ignoring error in '%s'\", filename);\n\t\t\t}\n\t\t}\n\t\tfinish_bgprint(ctx);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_drop_document(ctx, doc);\n\t\tfprintf(stderr, \"error: cannot draw '%s'\\n\", filename);\n\t\terrored = 1;\n\t}\n\n\tif (showtime && timing.count > 0)\n\t{\n\t\tfprintf(stderr, \"total %dms / %d pages for an average of %dms\\n\",\n\t\t\ttiming.total, timing.count, timing.total / timing.count);\n\t\tfprintf(stderr, \"fastest page %d: %dms\\n\", timing.minpage, timing.min);\n\t\tfprintf(stderr, \"slowest page %d: %dms\\n\", timing.maxpage, timing.max);\n\t}\n\n#ifndef DISABLE_MUTHREADS\n\tif (num_workers > 0)\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < num_workers; i++)\n\t\t{\n\t\t\tworkers[i].band_start = -1;\n\t\t\tmu_trigger_semaphore(&workers[i].start);\n\t\t\tmu_wait_semaphore(&workers[i].stop);\n\t\t\tmu_destroy_semaphore(&workers[i].start);\n\t\t\tmu_destroy_semaphore(&workers[i].stop);\n\t\t\tmu_destroy_thread(&workers[i].thread);\n\t\t\tfz_drop_context(workers[i].ctx);\n\t\t}\n\t\tfz_free(ctx, workers);\n\t}\n\n\tif (bgprint.active)\n\t{\n\t\tbgprint.pagenum = -1;\n\t\tmu_trigger_semaphore(&bgprint.start);\n\t\tmu_wait_semaphore(&bgprint.stop);\n\t\tmu_destroy_semaphore(&bgprint.start);\n\t\tmu_destroy_semaphore(&bgprint.stop);\n\t\tmu_destroy_thread(&bgprint.thread);\n\t\tfz_drop_context(bgprint.ctx);\n\t}\n#endif /* DISABLE_MUTHREADS */\n\n\tfz_close_output(ctx, out);\n\tfz_drop_output(ctx, out);\n\tout = NULL;\n\n\tfz_drop_context(ctx);\n#ifndef DISABLE_MUTHREADS\n\tfin_muraster_locks();\n#endif /* DISABLE_MUTHREADS */\n\n\tif (showmemory)\n\t{\n\t\tchar buf[100];\n\t\tfz_snprintf(buf, sizeof buf, \"Memory use total=%zu peak=%zu current=%zu\", info.total, info.peak, info.current);\n\t\tfprintf(stderr, \"%s\\n\", buf);\n\t}\n\n\treturn (errored != 0);\n}\n"], "filenames": ["source/tools/muraster.c"], "buggy_code_start_loc": [1006], "buggy_code_end_loc": [1008], "fixing_code_start_loc": [1006], "fixing_code_end_loc": [1009], "type": "CWE-369", "message": "A Floating point exception (division-by-zero) flaw was found in Mupdf for zero width pages in muraster.c. It is fixed in Mupdf-1.20.0-rc1 upstream.", "other": {"cve": {"id": "CVE-2021-4216", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-26T16:15:09.820", "lastModified": "2022-08-31T19:39:13.537", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A Floating point exception (division-by-zero) flaw was found in Mupdf for zero width pages in muraster.c. It is fixed in Mupdf-1.20.0-rc1 upstream."}, {"lang": "es", "value": "Se encontr\u00f3 un fallo de excepci\u00f3n de punto Flotante (divisi\u00f3n por cero) en Mupdf para p\u00e1ginas de ancho cero en el archivo muraster.c. Ha sido corregido en Mupdf versi\u00f3n 1.20.0-rc1 upstream."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:artifex:mupdf:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.20.0", "matchCriteriaId": "11EB83ED-4B1E-4503-AABB-1182ED39051B"}]}]}], "references": [{"url": "https://bugs.ghostscript.com/show_bug.cgi?id=704834", "source": "secalert@redhat.com", "tags": ["Permissions Required"]}, {"url": "https://github.com/ArtifexSoftware/mupdf/commit/22c47acbd52949421f8c7cb46ea1556827d0fcbf", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ArtifexSoftware/mupdf/commit/22c47acbd52949421f8c7cb46ea1556827d0fcbf"}}