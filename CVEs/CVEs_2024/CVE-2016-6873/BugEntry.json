{"buggy_code": ["/*\n   +----------------------------------------------------------------------+\n   | HipHop for PHP                                                       |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 2010-2016 Facebook, Inc. (http://www.facebook.com)     |\n   | Copyright (c) 1997-2010 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n*/\n\n#include \"hphp/runtime/ext/array/ext_array.h\"\n\n#include \"hphp/runtime/base/thread-info.h\"\n#include \"hphp/runtime/base/actrec-args.h\"\n#include \"hphp/runtime/base/array-data-defs.h\"\n#include \"hphp/runtime/base/array-init.h\"\n#include \"hphp/runtime/base/builtin-functions.h\"\n#include \"hphp/runtime/base/collections.h\"\n#include \"hphp/runtime/base/comparisons.h\"\n#include \"hphp/runtime/base/container-functions.h\"\n#include \"hphp/runtime/base/mixed-array.h\"\n#include \"hphp/runtime/base/request-event-handler.h\"\n#include \"hphp/runtime/base/request-local.h\"\n#include \"hphp/runtime/base/req-containers.h\"\n#include \"hphp/runtime/base/sort-flags.h\"\n#include \"hphp/runtime/base/zend-collator.h\"\n#include \"hphp/runtime/base/zend-sort.h\"\n#include \"hphp/runtime/ext/generator/ext_generator.h\"\n#include \"hphp/runtime/ext/collections/ext_collections-map.h\"\n#include \"hphp/runtime/ext/collections/ext_collections-pair.h\"\n#include \"hphp/runtime/ext/collections/ext_collections-set.h\"\n#include \"hphp/runtime/ext/collections/ext_collections-vector.h\"\n#include \"hphp/runtime/ext/std/ext_std_function.h\"\n#include \"hphp/runtime/vm/jit/translator.h\"\n#include \"hphp/runtime/vm/jit/translator-inline.h\"\n#include \"hphp/util/logger.h\"\n\n#include <vector>\n\nnamespace HPHP {\n///////////////////////////////////////////////////////////////////////////////\n\n#define SORT_DESC               3\n#define SORT_ASC                4\n\nconst StaticString s_count(\"count\");\n\nenum class CaseMode {\n  LOWER = 0,\n  UPPER = 1,\n};\n\nTypedValue HHVM_FUNCTION(array_change_key_case,\n                         ArrayArg input,\n                         int64_t case_ /* = 0 */) {\n  return tvReturn(ArrayUtil::ChangeKeyCase(ArrNR(input.get()),\n                                           (CaseMode)case_ == CaseMode::LOWER));\n}\n\nTypedValue HHVM_FUNCTION(array_chunk,\n                         const Variant& input,\n                         int chunkSize,\n                         bool preserve_keys /* = false */) {\n  const auto& cellInput = *input.asCell();\n  if (UNLIKELY(!isContainer(cellInput))) {\n    raise_warning(\"Invalid operand type was used: %s expects \"\n                  \"an array or collection as argument 1\", __FUNCTION__+2);\n    return make_tv<KindOfNull>();\n  }\n\n  if (chunkSize < 1) {\n    throw_invalid_argument(\"size: %d\", chunkSize);\n    return make_tv<KindOfNull>();\n  }\n\n  auto const retSize = (getContainerSize(cellInput) / chunkSize) + 1;\n  PackedArrayInit ret(retSize);\n  Array chunk;\n  int current = 0;\n  for (ArrayIter iter(cellInput); iter; ++iter) {\n    if (preserve_keys) {\n      chunk.setWithRef(iter.first(), iter.secondRefPlus(), true);\n    } else {\n      chunk.appendWithRef(iter.secondRefPlus());\n    }\n    if ((++current % chunkSize) == 0) {\n      ret.append(chunk);\n      chunk.clear();\n    }\n  }\n  if (!chunk.empty()) {\n    ret.append(chunk);\n  }\n\n  return tvReturn(ret.toVariant());\n}\n\nstatic inline bool array_column_coerce_key(Variant &key, const char *name) {\n  /* NULL has a special meaning for each field */\n  if (key.isNull()) {\n    return true;\n  }\n\n  /* Custom coercion rules for key types */\n  if (key.isInteger() || key.isDouble()) {\n    key = key.toInt64();\n    return true;\n  } else if (key.isString() || key.isObject()) {\n    key = key.toString();\n    return true;\n  } else {\n    raise_warning(\"array_column(): The %s key should be either a string \"\n                  \"or an integer\", name);\n    return false;\n  }\n}\n\nTypedValue HHVM_FUNCTION(array_column,\n                         ArrayArg input,\n                         const Variant& val_key,\n                         const Variant& idx_key /* = null_variant */) {\n\n  ArrNR arr_input(input.get());\n  Variant val = val_key, idx = idx_key;\n  if (!array_column_coerce_key(val, \"column\") ||\n      !array_column_coerce_key(idx, \"index\")) {\n    return make_tv<KindOfBoolean>(false);\n  }\n  ArrayInit ret(input->size(), ArrayInit::Map{});\n  for(auto it = arr_input.asArray().begin(); !it.end(); it.next()) {\n    if (!it.second().isArray()) {\n      continue;\n    }\n    Array sub = it.second().toArray();\n\n    Variant elem;\n    if (val.isNull()) {\n      elem = sub;\n    } else if (sub.exists(val)) {\n      elem = sub[val];\n    } else {\n      // skip subarray without named element\n      continue;\n    }\n\n    if (idx.isNull() || !sub.exists(idx)) {\n      ret.append(elem);\n    } else if (sub[idx].isObject()) {\n      ret.setUnknownKey(sub[idx].toString(), elem);\n    } else {\n      ret.setUnknownKey(sub[idx], elem);\n    }\n  }\n  return tvReturn(ret.toVariant());\n}\n\nTypedValue HHVM_FUNCTION(array_combine,\n                         const Variant& keys,\n                         const Variant& values) {\n  const auto& cell_keys = *keys.asCell();\n  const auto& cell_values = *values.asCell();\n  if (UNLIKELY(!isContainer(cell_keys) || !isContainer(cell_values))) {\n    raise_warning(\"Invalid operand type was used: array_combine expects \"\n                  \"arrays or collections\");\n    return make_tv<KindOfNull>();\n  }\n  auto keys_size = getContainerSize(cell_keys);\n  if (UNLIKELY(keys_size != getContainerSize(cell_values))) {\n    raise_warning(\"array_combine(): Both parameters should have an equal \"\n                  \"number of elements\");\n    return make_tv<KindOfBoolean>(false);\n  }\n  Array ret = Array::attach(MixedArray::MakeReserveMixed(keys_size));\n  for (ArrayIter iter1(cell_keys), iter2(cell_values);\n       iter1; ++iter1, ++iter2) {\n    const Variant& key = iter1.secondRefPlus();\n    if (key.isInteger() || key.isString()) {\n      ret.setWithRef(key, iter2.secondRefPlus());\n    } else {\n      ret.setWithRef(key.toString(), iter2.secondRefPlus());\n    }\n  }\n  return tvReturn(std::move(ret));\n}\n\nTypedValue HHVM_FUNCTION(array_count_values,\n                         ArrayArg input) {\n  return tvReturn(ArrayUtil::CountValues(ArrNR(input.get())));\n}\n\nTypedValue HHVM_FUNCTION(array_fill_keys,\n                         const Variant& keys,\n                         const Variant& value) {\n  folly::Optional<ArrayInit> ai;\n  auto ok = IterateV(*keys.asCell(),\n                     [&](ArrayData* adata) {\n                       ai.emplace(adata->size(), ArrayInit::Mixed{});\n                     },\n                     [&](const TypedValue* tv) {\n                       auto& key = tvAsCVarRef(tv);\n                       if (key.isInteger() || key.isString()) {\n                         ai->setUnknownKey(key, value);\n                       } else {\n                         raise_hack_strict(RuntimeOption::StrictArrayFillKeys,\n                                           \"strict_array_fill_keys\",\n                                           \"keys must be ints or strings\");\n                         ai->setUnknownKey(key.toString(), value);\n                       }\n                     },\n                     [&](ObjectData* coll) {\n                       if (coll->collectionType() == CollectionType::Pair) {\n                         ai.emplace(2, ArrayInit::Mixed{});\n                       }\n                     });\n\n  if (!ok) {\n    raise_warning(\"Invalid operand type was used: array_fill_keys expects \"\n                  \"an array or collection\");\n    return make_tv<KindOfNull>();\n  }\n  assert(ai.hasValue());\n  return tvReturn(ai->toVariant());\n}\n\nTypedValue HHVM_FUNCTION(array_fill,\n                         int start_index,\n                         int num,\n                         const Variant& value) {\n  if (num < 0) {\n    throw_invalid_argument(\"Number of elements can't be negative\");\n    return make_tv<KindOfBoolean>(false);\n  }\n\n  if (start_index == 0) {\n    PackedArrayInit pai(num, CheckAllocation{});\n    for (size_t k = 0; k < num; k++) {\n      pai.append(value);\n    }\n    return tvReturn(pai.toVariant());\n  } else {\n    ArrayInit ret(num, ArrayInit::Mixed{}, CheckAllocation{});\n    ret.set(start_index, value);\n    for (int i = num - 1; i > 0; i--) {\n      ret.append(value);\n    }\n    return tvReturn(ret.toVariant());\n  }\n}\n\nTypedValue HHVM_FUNCTION(array_flip,\n                         const Variant& trans) {\n  auto const& transCell = *trans.asCell();\n  if (UNLIKELY(!isContainer(transCell))) {\n    raise_warning(\"Invalid operand type was used: %s expects \"\n                  \"an array or collection\", __FUNCTION__+2);\n    return make_tv<KindOfNull>();\n  }\n\n  ArrayInit ret(getContainerSize(transCell), ArrayInit::Mixed{});\n  for (ArrayIter iter(transCell); iter; ++iter) {\n    const Variant& value(iter.secondRefPlus());\n    if (value.isString() || value.isInteger()) {\n      ret.setUnknownKey(value, iter.first());\n    } else {\n      raise_warning(\"Can only flip STRING and INTEGER values!\");\n    }\n  }\n  return tvReturn(ret.toVariant());\n}\n\nbool HHVM_FUNCTION(array_key_exists,\n                   const Variant& key,\n                   const Variant& search) {\n  const ArrayData *ad;\n\n  auto const searchCell = search.asCell();\n  if (LIKELY(isArrayType(searchCell->m_type))) {\n    ad = searchCell->m_data.parr;\n  } else if (searchCell->m_type == KindOfObject) {\n    ObjectData* obj = searchCell->m_data.pobj;\n    if (obj->isCollection()) {\n      return collections::contains(obj, key);\n    }\n    return HHVM_FN(array_key_exists)(key, toArray(search));\n  } else {\n    throw_bad_type_exception(\"array_key_exists expects an array or an object; \"\n                             \"false returned.\");\n    return false;\n  }\n\n  auto const cell = key.asCell();\n\n  switch (cell->m_type) {\n    case KindOfUninit:\n    case KindOfNull:\n      return ad->useWeakKeys() && ad->exists(staticEmptyString());\n\n    case KindOfBoolean:\n    case KindOfDouble:\n    case KindOfPersistentArray:\n    case KindOfArray:\n    case KindOfObject:\n    case KindOfResource:\n      if (!ad->useWeakKeys()) throwInvalidArrayKeyException(cell, ad);\n      raise_warning(\"Array key should be either a string or an integer\");\n      return false;\n\n    case KindOfPersistentString:\n    case KindOfString: {\n      int64_t n = 0;\n      if (ad->convertKey(cell->m_data.pstr, n)) {\n        return ad->exists(n);\n      }\n      return ad->exists(StrNR(cell->m_data.pstr));\n    }\n    case KindOfInt64:\n      return ad->exists(cell->m_data.num);\n    case KindOfRef:\n    case KindOfClass:\n      break;\n  }\n  not_reached();\n}\n\nbool HHVM_FUNCTION(key_exists,\n                   const Variant& key,\n                   const Variant& search) {\n  return HHVM_FN(array_key_exists)(key, search);\n}\n\nVariant array_keys_helper(const Variant& input,\n                          const Variant& search_value /* = uninit_null */,\n                          bool strict /* = false */) {\n  const auto& cell_input = *input.asCell();\n  if (UNLIKELY(!isContainer(cell_input))) {\n    raise_warning(\"array_keys() expects parameter 1 to be an array \"\n                  \"or collection\");\n    return init_null();\n  }\n\n  if (LIKELY(!search_value.isInitialized())) {\n    PackedArrayInit ai(getContainerSize(cell_input));\n    for (ArrayIter iter(cell_input); iter; ++iter) {\n      ai.append(iter.first());\n    }\n    return ai.toVariant();\n  } else {\n    Array ai = Array::attach(PackedArray::MakeReserve(0));\n    for (ArrayIter iter(cell_input); iter; ++iter) {\n      if ((strict && HPHP::same(iter.secondRefPlus(), search_value)) ||\n          (!strict && HPHP::equal(iter.secondRefPlus(), search_value))) {\n        ai.append(iter.first());\n      }\n    }\n    return ai;\n  }\n}\n\nstatic\nVariant HHVM_FUNCTION(array_keys, int64_t argc,\n                                  const Variant& input,\n                                  const Variant& search_value /*=null*/,\n                                  bool strict /*=false*/) {\n  return array_keys_helper(\n    input,\n    argc < 2 ? null_variant : search_value,\n    strict\n  );\n}\n\nstatic void php_array_merge(Array &arr1, const Array& arr2) {\n  arr1.merge(arr2);\n}\n\nstatic bool couldRecur(const Variant& v, const Array& arr) {\n  return v.isReferenced() ||\n    arr.get()->kind() == ArrayData::kGlobalsKind ||\n    arr.get()->kind() == ArrayData::kProxyKind;\n}\n\nstatic void php_array_merge_recursive(PointerSet &seen, bool check,\n                                      Array &arr1, const Array& arr2) {\n  if (check && !seen.insert((void*)arr1.get()).second) {\n    raise_warning(\"array_merge_recursive(): recursion detected\");\n    return;\n  }\n\n  for (ArrayIter iter(arr2); iter; ++iter) {\n    Variant key(iter.first());\n    const Variant& value(iter.secondRef());\n    if (key.isNumeric()) {\n      arr1.appendWithRef(value);\n    } else if (arr1.exists(key, true)) {\n      // There is no need to do toKey() conversion, for a key that is already\n      // in the array.\n      Variant &v = arr1.lvalAt(key, AccessFlags::Key);\n      auto subarr1 = v.toArray().copy();\n      php_array_merge_recursive(seen,\n                                couldRecur(v, subarr1),\n                                subarr1,\n                                value.toArray());\n      v.unset(); // avoid contamination of the value that was strongly bound\n      v = subarr1;\n    } else {\n      arr1.setWithRef(key, value, true);\n    }\n  }\n\n  if (check) {\n    seen.erase((void*)arr1.get());\n  }\n}\n\nTypedValue HHVM_FUNCTION(array_map,\n                         const Variant& callback,\n                         const Variant& arr1,\n                         const Array& _argv) {\n  VMRegGuard _;\n  CallCtx ctx;\n  ctx.func = nullptr;\n  if (!callback.isNull()) {\n    CallerFrame cf;\n    vm_decode_function(callback, cf(), false, ctx);\n  }\n  const auto& cell_arr1 = *arr1.asCell();\n  if (UNLIKELY(!isContainer(cell_arr1))) {\n    raise_warning(\"array_map(): Argument #2 should be an array or collection\");\n    return make_tv<KindOfNull>();\n  }\n  if (LIKELY(_argv.empty())) {\n    // Handle the common case where the caller passed two\n    // params (a callback and a container)\n    if (!ctx.func) {\n      if (isArrayType(cell_arr1.m_type)) {\n        return tvReturn(arr1);\n      } else {\n        return tvReturn(arr1.toArray());\n      }\n    }\n    ArrayInit ret(getContainerSize(cell_arr1), ArrayInit::Map{});\n    bool keyConverted = isArrayType(cell_arr1.m_type);\n    if (!keyConverted) {\n      auto col_type = cell_arr1.m_data.pobj->collectionType();\n      keyConverted = !collectionAllowsIntStringKeys(col_type);\n    }\n    for (ArrayIter iter(arr1); iter; ++iter) {\n      Variant result;\n      g_context->invokeFuncFew((TypedValue*)&result, ctx, 1,\n                               iter.secondRefPlus().asCell());\n      // if keyConverted is false, it's possible that ret will have fewer\n      // elements than cell_arr1; keys int(1) and string('1') may both be\n      // present\n      ret.add(iter.first(), result, keyConverted);\n    }\n    return tvReturn(ret.toVariant());\n  }\n\n  // Handle the uncommon case where the caller passed a callback\n  // and two or more containers\n  req::vector<ArrayIter> iters;\n  iters.reserve(_argv.size() + 1);\n  size_t maxLen = getContainerSize(cell_arr1);\n  iters.emplace_back(cell_arr1);\n  for (ArrayIter it(_argv); it; ++it) {\n    const auto& c = *it.secondRefPlus().asCell();\n    if (UNLIKELY(!isContainer(c))) {\n      raise_warning(\"array_map(): Argument #%d should be an array or \"\n                    \"collection\", (int)(iters.size() + 2));\n      iters.emplace_back(it.secondRefPlus().toArray());\n    } else {\n      iters.emplace_back(c);\n      size_t len = getContainerSize(c);\n      if (len > maxLen) maxLen = len;\n    }\n  }\n  PackedArrayInit ret_ai(maxLen);\n  for (size_t k = 0; k < maxLen; k++) {\n    PackedArrayInit params_ai(iters.size());\n    for (auto& iter : iters) {\n      if (iter) {\n        params_ai.append(iter.secondRefPlus());\n        ++iter;\n      } else {\n        params_ai.append(init_null_variant);\n      }\n    }\n    Array params = params_ai.toArray();\n    if (ctx.func) {\n      Variant result;\n      g_context->invokeFunc((TypedValue*)&result,\n                              ctx.func, params, ctx.this_,\n                              ctx.cls, nullptr, ctx.invName);\n      ret_ai.append(result);\n    } else {\n      ret_ai.append(params);\n    }\n  }\n  return tvReturn(ret_ai.toVariant());\n}\n\nTypedValue HHVM_FUNCTION(array_merge,\n                         int64_t numArgs,\n                         ArrayArg array1,\n                         const Variant& array2 /* = null_variant */,\n                         const Array& args /* = null array */) {\n  Array ret = Array::attach(MixedArray::MakeReserveLike(array1.get(), 0));\n  php_array_merge(ret, ArrNR(array1.get()));\n\n  if (UNLIKELY(numArgs < 2)) return tvReturn(std::move(ret));\n\n  getCheckedArrayRet(array2, make_tv<KindOfNull>());\n  php_array_merge(ret, arr_array2);\n\n  for (ArrayIter iter(args); iter; ++iter) {\n    Variant v = iter.second();\n    if (!v.isArray()) {\n      throw_expected_array_exception(\"array_merge\");\n      return make_tv<KindOfNull>();\n    }\n    const Array& arr_v = v.asCArrRef();\n    php_array_merge(ret, arr_v);\n  }\n  return tvReturn(std::move(ret));\n}\n\nTypedValue HHVM_FUNCTION(array_merge_recursive,\n                         int64_t numArgs,\n                         const Variant& array1,\n                         const Variant& array2 /* = null_variant */,\n                         const Array& args /* = null array */) {\n  getCheckedArray(array1);\n  auto in1 = array1.asCArrRef();\n  auto ret = Array::attach(MixedArray::MakeReserveLike(in1.get(), 0));\n  PointerSet seen;\n  php_array_merge_recursive(seen, false, ret, arr_array1);\n  assert(seen.empty());\n\n  if (UNLIKELY(numArgs < 2)) return tvReturn(std::move(ret));\n\n  getCheckedArray(array2);\n  php_array_merge_recursive(seen, false, ret, arr_array2);\n  assert(seen.empty());\n\n  for (ArrayIter iter(args); iter; ++iter) {\n    Variant v = iter.second();\n    if (!v.isArray()) {\n      throw_expected_array_exception(\"array_merge_recursive\");\n      return make_tv<KindOfNull>();\n    }\n    const Array& arr_v = v.asCArrRef();\n    php_array_merge_recursive(seen, false, ret, arr_v);\n    assert(seen.empty());\n  }\n  return tvReturn(std::move(ret));\n}\n\nstatic void php_array_replace(Array &arr1, const Array& arr2) {\n  for (ArrayIter iter(arr2); iter; ++iter) {\n    Variant key = iter.first();\n    const Variant& value = iter.secondRef();\n    arr1.setWithRef(key, value, true);\n  }\n}\n\nstatic void php_array_replace_recursive(PointerSet &seen, bool check,\n                                        Array &arr1, const Array& arr2) {\n  if (arr1.get() == arr2.get()) {\n    // This is an optimization, but it also avoids an assert in\n    // setWithRef (Variant::setWithRef asserts that its source\n    // and destination are not the same).\n    // If the arrays are self recursive, this does change the behavior\n    // slightly - it skips the \"recursion detected\" warning.\n    return;\n  }\n\n  if (check && !seen.insert((void*)arr1.get()).second) {\n    raise_warning(\"array_replace_recursive(): recursion detected\");\n    return;\n  }\n\n  for (ArrayIter iter(arr2); iter; ++iter) {\n    Variant key = iter.first();\n    const Variant& value = iter.secondRef();\n    if (arr1.exists(key, true) && value.isArray()) {\n      Variant &v = arr1.lvalAt(key, AccessFlags::Key);\n      if (v.isArray()) {\n        Array subarr1 = v.toArray();\n        const ArrNR& arr_value = value.toArrNR();\n        php_array_replace_recursive(seen, couldRecur(v, subarr1),\n                                    subarr1, arr_value);\n        v = subarr1;\n      } else {\n        arr1.set(key, value, true);\n      }\n    } else {\n      arr1.setWithRef(key, value, true);\n    }\n  }\n\n  if (check) {\n    seen.erase((void*)arr1.get());\n  }\n}\n\nTypedValue HHVM_FUNCTION(array_replace,\n                         const Variant& array1,\n                         const Variant& array2 /* = null_variant */,\n                         const Array& args /* = null array */) {\n  getCheckedArray(array1);\n  Array ret = Array::Create();\n  php_array_replace(ret, arr_array1);\n\n  if (UNLIKELY(array2.isNull() && args.empty())) {\n    return tvReturn(std::move(ret));\n  }\n\n  getCheckedArray(array2);\n  php_array_replace(ret, arr_array2);\n\n  for (ArrayIter iter(args); iter; ++iter) {\n    const Variant& v = iter.secondRef();\n    getCheckedArray(v);\n    php_array_replace(ret, arr_v);\n  }\n  return tvReturn(std::move(ret));\n}\n\nTypedValue HHVM_FUNCTION(array_replace_recursive,\n                         const Variant& array1,\n                         const Variant& array2 /* = null_variant */,\n                         const Array& args /* = null array */) {\n  getCheckedArray(array1);\n  Array ret = Array::Create();\n  PointerSet seen;\n  php_array_replace_recursive(seen, false, ret, arr_array1);\n  assert(seen.empty());\n\n  if (UNLIKELY(array2.isNull() && args.empty())) {\n    return tvReturn(std::move(ret));\n  }\n\n  getCheckedArray(array2);\n  php_array_replace_recursive(seen, false, ret, arr_array2);\n  assert(seen.empty());\n\n  for (ArrayIter iter(args); iter; ++iter) {\n    const Variant& v = iter.secondRef();\n    getCheckedArray(v);\n    php_array_replace_recursive(seen, false, ret, arr_v);\n    assert(seen.empty());\n  }\n  return tvReturn(std::move(ret));\n}\n\nTypedValue HHVM_FUNCTION(array_pad,\n                         const Variant& input,\n                         int pad_size,\n                         const Variant& pad_value) {\n  getCheckedArray(input);\n  if (pad_size > 0) {\n    return tvReturn(ArrayUtil::Pad(arr_input, pad_value, pad_size, true));\n  }\n  return tvReturn(ArrayUtil::Pad(arr_input, pad_value, -pad_size, false));\n}\n\nTypedValue HHVM_FUNCTION(array_pop,\n                         VRefParam containerRef) {\n  const auto* container = containerRef->asCell();\n  if (UNLIKELY(!isMutableContainer(*container))) {\n    raise_warning(\"array_pop() expects parameter 1 to be an \"\n                  \"array or mutable collection\");\n    return make_tv<KindOfNull>();\n  }\n  if (!getContainerSize(containerRef)) {\n    return make_tv<KindOfNull>();\n  }\n  if (isArrayType(container->m_type)) {\n    if (auto ref = containerRef.getVariantOrNull()) {\n      return tvReturn(ref->asArrRef().pop());\n    }\n    auto ad = container->m_data.parr;\n    if (ad->size()) {\n      auto last = ad->iter_last();\n      return tvReturn(ad->getValue(last));\n    }\n    return make_tv<KindOfNull>();\n  }\n  assert(container->m_type == KindOfObject);\n  return tvReturn(collections::pop(container->m_data.pobj));\n}\n\nTypedValue HHVM_FUNCTION(array_product,\n                         const Variant& input) {\n  if (UNLIKELY(!isContainer(input))) {\n    raise_warning(\"Invalid operand type was used: %s expects \"\n                  \"an array or collection as argument 1\",\n                  __FUNCTION__+2);\n    return make_tv<KindOfNull>();\n  }\n\n  int64_t i = 1;\n  ArrayIter iter(input);\n  for (; iter; ++iter) {\n    const Variant& entry(iter.secondRefPlus());\n\n    switch (entry.getType()) {\n      case KindOfUninit:\n      case KindOfNull:\n      case KindOfBoolean:\n      case KindOfInt64:\n      case KindOfRef:\n        i *= entry.toInt64();\n        continue;\n\n      case KindOfDouble:\n        goto DOUBLE;\n\n      case KindOfPersistentString:\n      case KindOfString: {\n        int64_t ti;\n        double td;\n        if (entry.getStringData()->isNumericWithVal(ti, td, 1) ==\n            KindOfInt64) {\n          i *= ti;\n          continue;\n        } else {\n          goto DOUBLE;\n        }\n      }\n\n      case KindOfPersistentArray:\n      case KindOfArray:\n      case KindOfObject:\n      case KindOfResource:\n        continue;\n\n      case KindOfClass:\n        break;\n    }\n    not_reached();\n  }\n  return make_tv<KindOfInt64>(i);\n\nDOUBLE:\n  double d = i;\n  for (; iter; ++iter) {\n    const Variant& entry(iter.secondRefPlus());\n    switch (entry.getType()) {\n      DT_UNCOUNTED_CASE:\n      case KindOfString:\n      case KindOfRef:\n        d *= entry.toDouble();\n\n      case KindOfArray:\n      case KindOfObject:\n      case KindOfResource:\n        continue;\n\n      case KindOfClass:\n        break;\n    }\n    not_reached();\n  }\n  return make_tv<KindOfDouble>(d);\n}\n\nTypedValue HHVM_FUNCTION(array_push,\n                         VRefParam container,\n                         const Variant& var,\n                         const Array& args /* = null array */) {\n  if (LIKELY(container->isArray())) {\n    auto ref = container.getVariantOrNull();\n    if (!ref) {\n      return make_tv<KindOfInt64>(\n        1 + args.size() + container->asCArrRef().size()\n      );\n    }\n\n    /*\n     * Important note: this *must* cast the parr in the inner cell to\n     * the Array&---we can't copy it to the stack or anything because we\n     * might escalate.\n     */\n    Array& arr_array = ref->asArrRef();\n    arr_array.append(var);\n    for (ArrayIter iter(args); iter; ++iter) {\n      arr_array.append(iter.second());\n    }\n    return make_tv<KindOfInt64>(arr_array.size());\n  }\n\n  if (container.isObject()) {\n    ObjectData* obj = container.getObjectData();\n    if (obj->isCollection()) {\n      switch (obj->collectionType()) {\n        case CollectionType::Vector: {\n          c_Vector* vec = static_cast<c_Vector*>(obj);\n          vec->reserve(vec->size() + args.size() + 1);\n          vec->add(var);\n          for (ArrayIter iter(args); iter; ++iter) {\n            vec->add(iter.second());\n          }\n          return make_tv<KindOfInt64>(vec->size());\n        }\n        case CollectionType::Set: {\n          c_Set* set = static_cast<c_Set*>(obj);\n          set->reserve(set->size() + args.size() + 1);\n          set->add(var);\n          for (ArrayIter iter(args); iter; ++iter) {\n            set->add(iter.second());\n          }\n          return make_tv<KindOfInt64>(set->size());\n        }\n        case CollectionType::Map:\n        case CollectionType::Pair:\n        case CollectionType::ImmVector:\n        case CollectionType::ImmMap:\n        case CollectionType::ImmSet:\n          // other collection types are unsupported:\n          //  - mapping collections require a key\n          //  - immutable collections don't allow insertion\n          break;\n      }\n    }\n  }\n  throw_expected_array_or_collection_exception(\"array_push\");\n  return make_tv<KindOfNull>();\n}\n\nTypedValue HHVM_FUNCTION(array_rand,\n                         const Variant& input,\n                         int num_req /* = 1 */) {\n  getCheckedArray(input);\n  return tvReturn(ArrayUtil::RandomKeys(arr_input, num_req));\n}\n\nTypedValue HHVM_FUNCTION(array_reverse,\n                         ArrayArg input,\n                         bool preserve_keys /* = false */) {\n\n  ArrNR arrNR(input.get());\n  const Array& arr = arrNR.asArray();\n  return tvReturn(ArrayUtil::Reverse(arr, preserve_keys));\n}\n\nTypedValue HHVM_FUNCTION(array_shift,\n                         VRefParam array) {\n  const auto* cell_array = array->asCell();\n  if (UNLIKELY(!isMutableContainer(*cell_array))) {\n    raise_warning(\"array_shift() expects parameter 1 to be an \"\n                  \"array or mutable collection\");\n    return make_tv<KindOfNull>();\n  }\n  if (!getContainerSize(array)) {\n    return make_tv<KindOfNull>();\n  }\n  if (isArrayType(cell_array->m_type)) {\n    if (auto ref = array.getVariantOrNull()) {\n      return tvReturn(ref->asArrRef().dequeue());\n    }\n    auto ad = cell_array->m_data.parr;\n    if (ad->size()) {\n      auto first = ad->iter_begin();\n      return tvReturn(ad->getValue(first));\n    }\n    return make_tv<KindOfNull>();\n  }\n  assertx(cell_array->m_type == KindOfObject);\n  return tvReturn(collections::shift(cell_array->m_data.pobj));\n}\n\nTypedValue HHVM_FUNCTION(array_slice,\n                         TypedValue cell_input,\n                         int64_t offset,\n                         const Variant& length /* = null_variant */,\n                         bool preserve_keys /* = false */) {\n  if (UNLIKELY(!isContainer(cell_input))) {\n    raise_warning(\"Invalid operand type was used: %s expects \"\n                  \"an array or collection as argument 1\",\n                  __FUNCTION__+2);\n    return make_tv<KindOfNull>();\n  }\n  int64_t len = length.isNull() ? 0x7FFFFFFF : length.toInt64();\n\n  const int64_t num_in = getContainerSize(cell_input);\n  if (offset > num_in) {\n    offset = num_in;\n  } else if (offset < 0 && (offset = (num_in + offset)) < 0) {\n    offset = 0;\n  }\n\n  auto const maxLen = num_in - offset;\n  if (len < 0) {\n    len = maxLen + len;\n  } else if (len > maxLen) {\n    len = maxLen;\n  }\n\n  if (len <= 0) {\n    return make_tv<KindOfPersistentArray>(staticEmptyArray());\n  }\n\n  bool input_is_packed = isPackedContainer(cell_input);\n\n  // If the slice covers the entire input container, we can just nop when\n  // preserve_keys is true, or when preserve_keys is false but the container\n  // is packed so we know the keys already map to [0,N].\n  if (offset == 0 && len == num_in && (preserve_keys || input_is_packed)) {\n    if (isArrayType(cell_input.m_type)) {\n      return tvReturn(Variant(cell_input.m_data.parr));\n    }\n    return tvReturn(cell_input.m_data.pobj->toArray());\n  }\n\n  int pos = 0;\n  ArrayIter iter(cell_input);\n  for (; pos < offset && iter; ++pos, ++iter) {}\n\n  if (input_is_packed && (offset == 0 || !preserve_keys)) {\n    PackedArrayInit ret(len);\n    for (; pos < (offset + len) && iter; ++pos, ++iter) {\n      ret.appendWithRef(iter.secondRefPlus());\n    }\n    return tvReturn(ret.toVariant());\n  }\n\n  // Otherwise PackedArrayInit can't be used because non-numeric keys are\n  // preserved even when preserve_keys is false\n  Array ret = Array::attach(PackedArray::MakeReserve(len));\n  for (; pos < (offset + len) && iter; ++pos, ++iter) {\n    Variant key(iter.first());\n    bool doAppend = !preserve_keys && key.isNumeric();\n    const Variant& v = iter.secondRefPlus();\n    if (doAppend) {\n      ret.appendWithRef(v);\n    } else {\n      ret.setWithRef(key, v, true);\n    }\n  }\n  return tvReturn(std::move(ret));\n}\n\nVariant array_splice(VRefParam input, int offset,\n                     const Variant& length, const Variant& replacement) {\n  getCheckedArrayVariant(input);\n  Array ret(Array::Create());\n  int64_t len = length.isNull() ? 0x7FFFFFFF : length.toInt64();\n  input.assignIfRef(ArrayUtil::Splice(arr_input, offset, len, replacement, &ret));\n  return ret;\n}\n\nTypedValue HHVM_FUNCTION(array_splice,\n                         VRefParam input,\n                         int offset,\n                         const Variant& length,\n                         const Variant& replacement) {\n  return tvReturn(array_splice(input, offset, length, replacement));\n}\n\nTypedValue HHVM_FUNCTION(array_sum,\n                         const Variant& input) {\n  if (UNLIKELY(!isContainer(input))) {\n    raise_warning(\"Invalid operand type was used: %s expects \"\n                  \"an array or collection as argument 1\",\n                  __FUNCTION__+2);\n    return make_tv<KindOfNull>();\n  }\n\n  int64_t i = 0;\n  ArrayIter iter(input);\n  for (; iter; ++iter) {\n    const Variant& entry(iter.secondRefPlus());\n\n    switch (entry.getType()) {\n      case KindOfUninit:\n      case KindOfNull:\n      case KindOfBoolean:\n      case KindOfInt64:\n      case KindOfRef:\n        i += entry.toInt64();\n        continue;\n\n      case KindOfDouble:\n        goto DOUBLE;\n\n      case KindOfPersistentString:\n      case KindOfString: {\n        int64_t ti;\n        double td;\n        if (entry.getStringData()->isNumericWithVal(ti, td, 1) ==\n            KindOfInt64) {\n          i += ti;\n          continue;\n        } else {\n          goto DOUBLE;\n        }\n      }\n\n      case KindOfPersistentArray:\n      case KindOfArray:\n      case KindOfObject:\n      case KindOfResource:\n        continue;\n\n      case KindOfClass:\n        break;\n    }\n    not_reached();\n  }\n  return make_tv<KindOfInt64>(i);\n\nDOUBLE:\n  double d = i;\n  for (; iter; ++iter) {\n    const Variant& entry(iter.secondRefPlus());\n    switch (entry.getType()) {\n      DT_UNCOUNTED_CASE:\n      case KindOfString:\n      case KindOfRef:\n        d += entry.toDouble();\n\n      case KindOfArray:\n      case KindOfObject:\n      case KindOfResource:\n        continue;\n\n      case KindOfClass:\n        break;\n    }\n    not_reached();\n  }\n  return make_tv<KindOfDouble>(d);\n}\n\nTypedValue HHVM_FUNCTION(array_unshift,\n                         VRefParam array,\n                         const Variant& var,\n                         const Array& args /* = null array */) {\n  const auto* cell_array = array->asCell();\n  if (UNLIKELY(!isContainer(*cell_array))) {\n    raise_warning(\"%s() expects parameter 1 to be an array, Vector, or Set\",\n                  __FUNCTION__+2 /* remove the \"f_\" prefix */);\n    return make_tv<KindOfNull>();\n  }\n  if (isArrayType(cell_array->m_type)) {\n    auto ref_array = array.getVariantOrNull();\n    if (!ref_array) {\n      return make_tv<KindOfInt64>(\n        cell_array->m_data.parr->size() + args.size() + 1\n      );\n    }\n    if (cell_array->m_data.parr->isVectorData()) {\n      if (!args.empty()) {\n        auto pos_limit = args->iter_end();\n        for (ssize_t pos = args->iter_last(); pos != pos_limit;\n             pos = args->iter_rewind(pos)) {\n          ref_array->asArrRef().prepend(args->getValueRef(pos));\n        }\n      }\n      ref_array->asArrRef().prepend(var);\n    } else {\n      {\n        Array newArray;\n        newArray.append(var);\n        if (!args.empty()) {\n          auto pos_limit = args->iter_end();\n          for (ssize_t pos = args->iter_begin(); pos != pos_limit;\n               pos = args->iter_advance(pos)) {\n            newArray.append(args->getValueRef(pos));\n          }\n        }\n        for (ArrayIter iter(array.toArray()); iter; ++iter) {\n          Variant key(iter.first());\n          const Variant& value(iter.secondRef());\n          if (key.isInteger()) {\n            newArray.appendWithRef(value);\n          } else {\n            newArray.setWithRef(key, value, true);\n          }\n        }\n        *ref_array = std::move(newArray);\n      }\n      // Reset the array's internal pointer\n      ref_array->asArrRef()->reset();\n    }\n    return make_tv<KindOfInt64>(ref_array->asArrRef().size());\n  }\n  // Handle collections\n  assert(cell_array->m_type == KindOfObject);\n  auto* obj = cell_array->m_data.pobj;\n  assert(obj->isCollection());\n  switch (obj->collectionType()) {\n    case CollectionType::Vector: {\n      auto* vec = static_cast<c_Vector*>(obj);\n      if (!args.empty()) {\n        auto pos_limit = args->iter_end();\n        for (ssize_t pos = args->iter_last(); pos != pos_limit;\n             pos = args->iter_rewind(pos)) {\n          vec->addFront(args->getValueRef(pos).asCell());\n        }\n      }\n      vec->addFront(var.asCell());\n      return make_tv<KindOfInt64>(vec->size());\n    }\n    case CollectionType::Set: {\n      auto* st = static_cast<c_Set*>(obj);\n      if (!args.empty()) {\n        auto pos_limit = args->iter_end();\n        for (ssize_t pos = args->iter_last(); pos != pos_limit;\n             pos = args->iter_rewind(pos)) {\n          st->addFront(args->getValueRef(pos).asCell());\n        }\n      }\n      st->addFront(var.asCell());\n      return make_tv<KindOfInt64>(st->size());\n    }\n    case CollectionType::Map:\n    case CollectionType::Pair:\n    case CollectionType::ImmVector:\n    case CollectionType::ImmMap:\n    case CollectionType::ImmSet:\n      break;\n  }\n  raise_warning(\"%s() expects parameter 1 to be an array, Vector, or Set\",\n                __FUNCTION__+2 /* remove the \"f_\" prefix */);\n  return make_tv<KindOfNull>();\n}\n\nVariant array_values(const Variant& input) {\n  if (input.isArray() && input.asCArrRef()->isVecArray()) {\n    return input;\n  }\n\n  folly::Optional<PackedArrayInit> ai;\n  auto ok = IterateV(*input.asCell(),\n                     [&](ArrayData* adata) {\n                       ai.emplace(adata->size());\n                     },\n                     [&](const TypedValue* tv) {\n                       ai->appendWithRef(tvAsCVarRef(tv));\n                     },\n                     [&](ObjectData* coll) {\n                       if (coll->collectionType() == CollectionType::Pair) {\n                         ai.emplace(2);\n                       }\n                     });\n\n  if (!ok) {\n    raise_warning(\"array_values() expects parameter 1 to be an array \"\n                  \"or collection\");\n    return init_null();\n  }\n\n  assert(ai.hasValue());\n  return ai->toVariant();\n}\n\nTypedValue HHVM_FUNCTION(array_values,\n                         const Variant& input) {\n  return tvReturn(array_values(input));\n}\n\nstatic void walk_func(Variant& value,\n                      const Variant& key,\n                      const Variant& userdata,\n                      const void *data) {\n  CallCtx* ctx = (CallCtx*)data;\n  Variant sink;\n  int nargs = userdata.isInitialized() ? 3 : 2;\n  TypedValue args[3] = { *value.asRef(), *key.asCell(), *userdata.asCell() };\n  g_context->invokeFuncFew(sink.asTypedValue(), *ctx, nargs, args);\n}\n\nbool HHVM_FUNCTION(array_walk_recursive,\n                   VRefParam input,\n                   const Variant& funcname,\n                   const Variant& userdata /* = null_variant */) {\n  if (!input.isArray()) {\n    throw_expected_array_exception(\"array_walk_recursive\");\n    return false;\n  }\n  CallCtx ctx;\n  CallerFrame cf;\n  vm_decode_function(funcname, cf(), false, ctx);\n  if (ctx.func == NULL) {\n    return false;\n  }\n  PointerSet seen;\n  Variant var(input, Variant::WithRefBind{});\n  ArrayUtil::Walk(var, walk_func, &ctx, true, &seen, userdata);\n  return true;\n}\n\nbool HHVM_FUNCTION(array_walk,\n                   VRefParam input,\n                   const Variant& funcname,\n                   const Variant& userdata /* = null_variant */) {\n  if (!input.isArray()) {\n    throw_expected_array_exception(\"array_walk\");\n    return false;\n  }\n  CallCtx ctx;\n  CallerFrame cf;\n  vm_decode_function(funcname, cf(), false, ctx);\n  if (ctx.func == NULL) {\n    return false;\n  }\n  Variant var(input, Variant::WithRefBind{});\n  ArrayUtil::Walk(var, walk_func, &ctx, false, NULL, userdata);\n  return true;\n}\n\nstatic void compact(VarEnv* v, Array &ret, const Variant& var) {\n  if (var.isArray()) {\n    for (ArrayIter iter(var.getArrayData()); iter; ++iter) {\n      compact(v, ret, iter.second());\n    }\n  } else {\n    String varname = var.toString();\n    if (!varname.empty() && v->lookup(varname.get()) != NULL) {\n      ret.set(varname, *reinterpret_cast<Variant*>(v->lookup(varname.get())));\n    }\n  }\n}\n\nArray HHVM_FUNCTION(compact,\n                    const Variant& varname,\n                    const Array& args /* = null array */) {\n  raise_disallowed_dynamic_call(\"compact should not be called dynamically\");\n  Array ret = Array::attach(PackedArray::MakeReserve(args.size() + 1));\n  VarEnv* v = g_context->getOrCreateVarEnv();\n  if (v) {\n    compact(v, ret, varname);\n    compact(v, ret, args);\n  }\n  return ret;\n}\n\n// __SystemLib\\\\compact_sl\nArray HHVM_FUNCTION(__SystemLib_compact_sl,\n                    const Variant& varname,\n                    const Array& args /* = null array */) {\n  Array ret = Array::attach(PackedArray::MakeReserve(args.size() + 1));\n  VarEnv* v = g_context->getOrCreateVarEnv();\n  if (v) {\n    compact(v, ret, varname);\n    compact(v, ret, args);\n  }\n  return ret;\n}\n\nstatic int php_count_recursive(const Array& array) {\n  long cnt = array.size();\n  for (ArrayIter iter(array); iter; ++iter) {\n    Variant value = iter.second();\n    if (value.isArray()) {\n      const Array& arr_value = value.asCArrRef();\n      check_recursion_throw();\n      cnt += php_count_recursive(arr_value);\n    }\n  }\n  return cnt;\n}\n\nbool HHVM_FUNCTION(shuffle,\n                   VRefParam array) {\n  if (!array.isArray()) {\n    throw_expected_array_exception(\"shuffle\");\n    return false;\n  }\n  array.assignIfRef(ArrayUtil::Shuffle(array));\n  return true;\n}\n\nenum class CountMode {\n  NORMAL = 0,\n  RECURSIVE = 1,\n};\n\nint64_t HHVM_FUNCTION(count,\n                      const Variant& var,\n                      int64_t mode /* = 0 */) {\n  switch (var.getType()) {\n    case KindOfUninit:\n    case KindOfNull:\n      return 0;\n\n    case KindOfBoolean:\n    case KindOfInt64:\n    case KindOfDouble:\n    case KindOfPersistentString:\n    case KindOfString:\n    case KindOfResource:\n      return 1;\n\n    case KindOfPersistentArray:\n    case KindOfArray:\n      if ((CountMode)mode == CountMode::RECURSIVE) {\n        const Array& arr_var = var.toCArrRef();\n        return php_count_recursive(arr_var);\n      }\n      return var.getArrayData()->size();\n\n    case KindOfObject:\n      {\n        Object obj = var.toObject();\n        if (obj->isCollection()) {\n          return collections::getSize(obj.get());\n        }\n        if (obj.instanceof(SystemLib::s_CountableClass)) {\n          return obj->o_invoke_few_args(s_count, 0).toInt64();\n        }\n      }\n      return 1;\n\n    case KindOfRef:\n    case KindOfClass:\n      break;\n  }\n  not_reached();\n}\n\nint64_t HHVM_FUNCTION(sizeof,\n                      const Variant& var,\n                      int64_t mode /* = 0 */) {\n  return HHVM_FN(count)(var, mode);\n}\n\nnamespace {\n\nenum class NoCow {};\ntemplate<class DoCow = void, class NonArrayRet, class OpPtr>\nstatic Variant iter_op_impl(VRefParam refParam, OpPtr op, const String& objOp,\n                            NonArrayRet nonArray,\n                            bool(ArrayData::*pred)() const =\n                              &ArrayData::isInvalid) {\n  auto& cell = *refParam.wrapped().asCell();\n  if (!isArrayType(cell.m_type)) {\n    if (cell.m_type == KindOfObject) {\n      auto obj = refParam.wrapped().toObject();\n      if (obj->instanceof(SystemLib::s_ArrayObjectClass)) {\n        return obj->o_invoke_few_args(objOp, 0);\n      }\n    }\n    throw_bad_type_exception(\"expecting an array\");\n    return Variant(nonArray);\n  }\n\n  auto ad = cell.m_data.parr;\n  auto constexpr doCow = !std::is_same<DoCow, NoCow>::value;\n  if (doCow && ad->cowCheck() && !(ad->*pred)() &&\n      !ad->noCopyOnWrite()) {\n    ad = ad->copy();\n    if (LIKELY(refParam.isRefData()))\n      cellMove(make_tv<KindOfArray>(ad), *refParam.getRefData()->tv());\n    else {\n      req::ptr<ArrayData> tmp(ad, req::ptr<ArrayData>::NoIncRef{});\n      return (ad->*op)();\n    }\n  }\n  return (ad->*op)();\n}\n\n}\n\nconst StaticString\n  s___each(\"__each\"),\n  s___current(\"__current\"),\n  s___key(\"__key\"),\n  s___next(\"__next\"),\n  s___prev(\"__prev\"),\n  s___reset(\"__reset\"),\n  s___end(\"__end\");\n\n\nVariant HHVM_FUNCTION(each,\n                      VRefParam refParam) {\n  return iter_op_impl(\n    refParam,\n    &ArrayData::each,\n    s___each,\n    Variant::NullInit()\n  );\n}\n\nVariant HHVM_FUNCTION(current,\n                      VRefParam refParam) {\n  return iter_op_impl<NoCow>(\n    refParam,\n    &ArrayData::current,\n    s___current,\n    false\n  );\n}\n\nVariant HHVM_FUNCTION(pos,\n                      VRefParam refParam) {\n  return HHVM_FN(current)(refParam);\n}\n\nVariant HHVM_FUNCTION(key,\n                      VRefParam refParam) {\n  return iter_op_impl<NoCow>(\n    refParam,\n    &ArrayData::key,\n    s___key,\n    false\n  );\n}\n\nVariant HHVM_FUNCTION(next,\n                      VRefParam refParam) {\n  return iter_op_impl(\n    refParam,\n    &ArrayData::next,\n    s___next,\n    false\n  );\n}\n\nVariant HHVM_FUNCTION(prev,\n                      VRefParam refParam) {\n  return iter_op_impl(\n    refParam,\n    &ArrayData::prev,\n    s___prev,\n    false\n  );\n}\n\nVariant HHVM_FUNCTION(reset,\n                      VRefParam refParam) {\n  return iter_op_impl(\n    refParam,\n    &ArrayData::reset,\n    s___reset,\n    false,\n    &ArrayData::isHead\n  );\n}\n\nVariant HHVM_FUNCTION(end,\n                      VRefParam refParam) {\n  return iter_op_impl(\n    refParam,\n    &ArrayData::end,\n    s___end,\n    false,\n    &ArrayData::isTail\n  );\n}\n\nbool HHVM_FUNCTION(in_array,\n                   const Variant& needle,\n                   const Variant& haystack,\n                   bool strict /* = false */) {\n  bool ret = false;\n  auto ok = strict ?\n    IterateV(*haystack.asCell(),\n             [](ArrayData*) { return false; },\n             [&](const TypedValue* tv) -> bool {\n               if (HPHP::same(tvAsCVarRef(tv), needle)) {\n                 ret = true;\n                 return true;\n               }\n               return false;\n             },\n             [](ObjectData*) { return false; }) :\n    IterateV(*haystack.asCell(),\n             [](ArrayData*) { return false; },\n             [&](const TypedValue* tv) -> bool {\n               if (HPHP::equal(tvAsCVarRef(tv), needle)) {\n                 ret = true;\n                 return true;\n               }\n               return false;\n             },\n             [](ObjectData*) { return false; });\n\n  if (UNLIKELY(!ok)) {\n    raise_warning(\"in_array() expects parameter 2 to be an array \"\n                  \"or collection\");\n  }\n  return ret;\n}\n\nVariant array_search(const Variant& needle,\n                     const Variant& haystack,\n                     bool strict /* = false */) {\n  Variant ret = false;\n  auto ok = strict ?\n    IterateKV(*haystack.asCell(),\n              [](ArrayData*) { return false; },\n              [&](const TypedValue* key, const TypedValue* tv) -> bool {\n                if (HPHP::same(tvAsCVarRef(tv), needle)) {\n                  ret = tvAsCVarRef(key);\n                  return true;\n                }\n                return false;\n              },\n              [](ObjectData*) { return false; }) :\n    IterateKV(*haystack.asCell(),\n              [](ArrayData*) { return false; },\n              [&](const TypedValue* key, const TypedValue* tv) -> bool {\n                if (HPHP::equal(tvAsCVarRef(tv), needle)) {\n                  ret = tvAsCVarRef(key);\n                  return true;\n                }\n                return false;\n              },\n              [](ObjectData*) { return false; });\n\n  if (UNLIKELY(!ok)) {\n    raise_warning(\"array_search() expects parameter 2 to be an array \"\n                  \"or collection\");\n    return init_null();\n  }\n\n  return ret;\n}\n\nTypedValue HHVM_FUNCTION(array_search,\n                         const Variant& needle,\n                         const Variant& haystack,\n                         bool strict /* = false */) {\n  return tvReturn(array_search(needle, haystack, strict));\n}\n\nTypedValue HHVM_FUNCTION(range,\n                         const Variant& low,\n                         const Variant& high,\n                         const Variant& step /* = 1 */) {\n  bool is_step_double = false;\n  double dstep = 1.0;\n  if (step.isDouble()) {\n    dstep = step.toDouble();\n    is_step_double = true;\n  } else if (step.isString()) {\n    int64_t sn;\n    double sd;\n    DataType stype = step.toString().get()->isNumericWithVal(sn, sd, 0);\n    if (stype == KindOfDouble) {\n      is_step_double = true;\n      dstep = sd;\n    } else if (stype == KindOfInt64) {\n      dstep = (double)sn;\n    } else {\n      dstep = step.toDouble();\n    }\n  } else {\n    dstep = step.toDouble();\n  }\n  /* We only want positive step values. */\n  if (dstep < 0.0) dstep *= -1;\n  if (low.isString() && high.isString()) {\n    String slow = low.toString();\n    String shigh = high.toString();\n    if (slow.size() >= 1 && shigh.size() >=1) {\n      int64_t n1, n2;\n      double d1, d2;\n      DataType type1 = slow.get()->isNumericWithVal(n1, d1, 0);\n      DataType type2 = shigh.get()->isNumericWithVal(n2, d2, 0);\n      if (type1 == KindOfDouble || type2 == KindOfDouble || is_step_double) {\n        if (type1 != KindOfDouble) d1 = slow.toDouble();\n        if (type2 != KindOfDouble) d2 = shigh.toDouble();\n        return tvReturn(ArrayUtil::Range(d1, d2, dstep));\n      }\n\n      int64_t lstep = (int64_t) dstep;\n      if (type1 == KindOfInt64 || type2 == KindOfInt64) {\n        if (type1 != KindOfInt64) n1 = slow.toInt64();\n        if (type2 != KindOfInt64) n2 = shigh.toInt64();\n        return tvReturn(ArrayUtil::Range((double)n1, (double)n2, lstep));\n      }\n\n      return tvReturn(ArrayUtil::Range((unsigned char)slow.charAt(0),\n                                       (unsigned char)shigh.charAt(0), lstep));\n    }\n  }\n\n  if (low.is(KindOfDouble) || high.is(KindOfDouble) || is_step_double) {\n    return tvReturn(ArrayUtil::Range(low.toDouble(), high.toDouble(), dstep));\n  }\n\n  int64_t lstep = (int64_t) dstep;\n  return tvReturn(ArrayUtil::Range(low.toDouble(), high.toDouble(), lstep));\n}\n///////////////////////////////////////////////////////////////////////////////\n// diff/intersect helpers\n\nstatic int cmp_func(const Variant& v1, const Variant& v2, const void *data) {\n  Variant *callback = (Variant *)data;\n  return vm_call_user_func(*callback, make_packed_array(v1, v2)).toInt32();\n}\n\n// PHP 5.x does different things when diffing against the same array,\n// particularly when the comparison function is outside the norm of\n// return -1, 0, 1 specification. To do what PHP 5.x in these cases,\n// use the RuntimeOption\n#define COMMA ,\n#define diff_intersect_body(type, vararg, intersect_params)     \\\n  getCheckedArray(array1);                                      \\\n  if (!arr_array1.size()) return tvReturn(arr_array1);          \\\n  Array ret = Array::Create();                                  \\\n  if (RuntimeOption::EnableZendSorting) {                       \\\n    getCheckedArray(array2);                                    \\\n    if (arr_array1.same(arr_array2)) {                          \\\n      return tvReturn(std::move(ret));                          \\\n    }                                                           \\\n  }                                                             \\\n  ret = arr_array1.type(array2, intersect_params);              \\\n  if (ret.size()) {                                             \\\n    for (ArrayIter iter(vararg); iter; ++iter) {                \\\n      ret = ret.type(iter.second(), intersect_params);          \\\n      if (!ret.size()) break;                                   \\\n    }                                                           \\\n  }                                                             \\\n  return tvReturn(std::move(ret));\n\n///////////////////////////////////////////////////////////////////////////////\n// diff functions\n\nstatic inline void addToSetHelper(const req::ptr<c_Set>& st,\n                                  const Cell c,\n                                  TypedValue* strTv,\n                                  bool convertIntLikeStrs) {\n  if (c.m_type == KindOfInt64) {\n    st->add(c.m_data.num);\n  } else {\n    StringData* s;\n    if (LIKELY(isStringType(c.m_type))) {\n      s = c.m_data.pstr;\n    } else {\n      s = tvCastToString(&c);\n      decRefStr(strTv->m_data.pstr);\n      strTv->m_data.pstr = s;\n    }\n    int64_t n;\n    if (convertIntLikeStrs && s->isStrictlyInteger(n)) {\n      st->add(n);\n    } else {\n      st->add(s);\n    }\n  }\n}\n\nstatic inline bool checkSetHelper(const req::ptr<c_Set>& st,\n                                  const Cell c,\n                                  TypedValue* strTv,\n                                  bool convertIntLikeStrs) {\n  if (c.m_type == KindOfInt64) {\n    return st->contains(c.m_data.num);\n  }\n  StringData* s;\n  if (LIKELY(isStringType(c.m_type))) {\n    s = c.m_data.pstr;\n  } else {\n    s = tvCastToString(&c);\n    decRefStr(strTv->m_data.pstr);\n    strTv->m_data.pstr = s;\n  }\n  int64_t n;\n  if (convertIntLikeStrs && s->isStrictlyInteger(n)) {\n    return st->contains(n);\n  }\n  return st->contains(s);\n}\n\nstatic void containerValuesToSetHelper(const req::ptr<c_Set>& st,\n                                       const Variant& container) {\n  Variant strHolder(empty_string_variant());\n  TypedValue* strTv = strHolder.asTypedValue();\n  for (ArrayIter iter(container); iter; ++iter) {\n    auto const& c = *iter.secondRefPlus().asCell();\n    addToSetHelper(st, c, strTv, true);\n  }\n}\n\nstatic void containerKeysToSetHelper(const req::ptr<c_Set>& st,\n                                     const Variant& container) {\n  Variant strHolder(empty_string_variant());\n  TypedValue* strTv = strHolder.asTypedValue();\n  bool isKey = isArrayType(container.asCell()->m_type);\n  for (ArrayIter iter(container); iter; ++iter) {\n    addToSetHelper(st, *iter.first().asCell(), strTv, !isKey);\n  }\n}\n\n#define ARRAY_DIFF_PRELUDE() \\\n  /* Check to make sure all inputs are containers */ \\\n  const auto& c1 = *container1.asCell(); \\\n  const auto& c2 = *container2.asCell(); \\\n  if (UNLIKELY(!isContainer(c1) || !isContainer(c2))) { \\\n    raise_warning(\"%s() expects parameter %d to be an array or collection\", \\\n                  __FUNCTION__+2, /* remove the \"f_\" prefix */ \\\n                  isContainer(c1) ? 2 : 1); \\\n    return make_tv<KindOfNull>(); \\\n  } \\\n  bool moreThanTwo = !args.empty(); \\\n  size_t largestSize = getContainerSize(c2); \\\n  if (UNLIKELY(moreThanTwo)) { \\\n    int pos = 3; \\\n    for (ArrayIter argvIter(args); argvIter; ++argvIter, ++pos) { \\\n      const auto& c = *argvIter.secondRef().asCell(); \\\n      if (!isContainer(c)) { \\\n        raise_warning(\"%s() expects parameter %d to be an array or collection\",\\\n                      __FUNCTION__+2, /* remove the \"f_\" prefix */ \\\n                      pos); \\\n        return make_tv<KindOfNull>(); \\\n      } \\\n      size_t sz = getContainerSize(c); \\\n      if (sz > largestSize) { \\\n        largestSize = sz; \\\n      } \\\n    } \\\n  } \\\n  /* If container1 is empty, we can stop here and return the empty array */ \\\n  if (!getContainerSize(c1)) { \\\n    return make_tv<KindOfPersistentArray>(staticEmptyArray()); \\\n  } \\\n  /* If all of the containers (except container1) are empty, we can just \\\n     return container1 (converting it to an array if needed) */ \\\n  if (!largestSize) { \\\n    if (isArrayType(c1.m_type)) { \\\n      return tvReturn(container1); \\\n    } else { \\\n      return tvReturn(container1.toArray()); \\\n    } \\\n  } \\\n  Array ret = Array::Create();\n\nTypedValue HHVM_FUNCTION(array_diff,\n                         const Variant& container1,\n                         const Variant& container2,\n                         const Array& args /* = null array */) {\n  ARRAY_DIFF_PRELUDE()\n  // Put all of the values from all the containers (except container1 into a\n  // Set. All types aside from integer and string will be cast to string, and\n  // we also convert int-like strings to integers.\n  auto st = req::make<c_Set>();\n  st->reserve(largestSize);\n  containerValuesToSetHelper(st, container2);\n  if (UNLIKELY(moreThanTwo)) {\n    for (ArrayIter argvIter(args); argvIter; ++argvIter) {\n      const auto& container = argvIter.secondRef();\n      containerValuesToSetHelper(st, container);\n    }\n  }\n  // Loop over container1, only copying over key/value pairs where the value\n  // is not present in the Set. When checking if a value is present in the\n  // Set, any value that is not an integer or string is cast to a string, and\n  // we convert int-like strings to integers.\n  Variant strHolder(empty_string_variant());\n  TypedValue* strTv = strHolder.asTypedValue();\n  bool isKey = isArrayType(c1.m_type);\n  for (ArrayIter iter(container1); iter; ++iter) {\n    const auto& val = iter.secondRefPlus();\n    const auto& c = *val.asCell();\n    if (checkSetHelper(st, c, strTv, true)) continue;\n    ret.setWithRef(iter.first(), val, isKey);\n  }\n  return tvReturn(std::move(ret));\n}\n\nTypedValue HHVM_FUNCTION(array_diff_key,\n                         const Variant& container1,\n                         const Variant& container2,\n                         const Array& args /* = null array */) {\n  ARRAY_DIFF_PRELUDE()\n  // If we're only dealing with two containers and if they are both arrays,\n  // we can avoid creating an intermediate Set\n  if (!moreThanTwo && isArrayType(c1.m_type) && isArrayType(c2.m_type)) {\n    auto ad2 = c2.m_data.parr;\n    for (ArrayIter iter(container1); iter; ++iter) {\n      auto key = iter.first();\n      const auto& c = *key.asCell();\n      if (c.m_type == KindOfInt64) {\n        if (ad2->exists(c.m_data.num)) continue;\n      } else {\n        assert(isStringType(c.m_type));\n        if (ad2->exists(c.m_data.pstr)) continue;\n      }\n      ret.setWithRef(key, iter.secondRefPlus(), true);\n    }\n    return tvReturn(std::move(ret));\n  }\n  // Put all of the keys from all the containers (except container1) into a\n  // Set. All types aside from integer and string will be cast to string, and\n  // we also convert int-like strings to integers.\n  auto st = req::make<c_Set>();\n  st->reserve(largestSize);\n  containerKeysToSetHelper(st, container2);\n  if (UNLIKELY(moreThanTwo)) {\n    for (ArrayIter argvIter(args); argvIter; ++argvIter) {\n      const auto& container = argvIter.secondRef();\n      containerKeysToSetHelper(st, container);\n    }\n  }\n  // Loop over container1, only copying over key/value pairs where the key is\n  // not present in the Set. When checking if a key is present in the Set, any\n  // key that is not an integer or string is cast to a string, and we convert\n  // int-like strings to integers.\n  Variant strHolder(empty_string_variant());\n  TypedValue* strTv = strHolder.asTypedValue();\n  bool isKey = isArrayType(c1.m_type);\n  for (ArrayIter iter(container1); iter; ++iter) {\n    auto key = iter.first();\n    const auto& c = *key.asCell();\n    if (checkSetHelper(st, c, strTv, !isKey)) continue;\n    ret.setWithRef(key, iter.secondRefPlus(), isKey);\n  }\n  return tvReturn(std::move(ret));\n}\n\n#undef ARRAY_DIFF_PRELUDE\n\nTypedValue HHVM_FUNCTION(array_udiff,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& data_compare_func,\n                         const Array& args /* = null array */) {\n  Variant func = data_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(func);\n    func = extra.pop();\n  }\n  diff_intersect_body(diff, extra, false COMMA true COMMA NULL COMMA NULL\n                      COMMA cmp_func COMMA &func);\n}\n\nTypedValue HHVM_FUNCTION(array_diff_assoc,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Array& args /* = null array */) {\n  diff_intersect_body(diff, args, true COMMA true);\n}\n\nTypedValue HHVM_FUNCTION(array_diff_uassoc,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& key_compare_func,\n                         const Array& args /* = null array */) {\n  Variant func = key_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(func);\n    func = extra.pop();\n  }\n  diff_intersect_body(diff, extra, true COMMA true COMMA cmp_func COMMA &func);\n}\n\nTypedValue HHVM_FUNCTION(array_udiff_assoc,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& data_compare_func,\n                         const Array& args /* = null array */) {\n  Variant func = data_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(func);\n    func = extra.pop();\n  }\n  diff_intersect_body(diff, extra, true COMMA true COMMA NULL COMMA NULL\n                      COMMA cmp_func COMMA &func);\n}\n\nTypedValue HHVM_FUNCTION(array_udiff_uassoc,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& data_compare_func,\n                         const Variant& key_compare_func,\n                         const Array& args /* = null array */) {\n  Variant data_func = data_compare_func;\n  Variant key_func = key_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(key_func);\n    extra.prepend(data_func);\n    key_func = extra.pop();\n    data_func = extra.pop();\n  }\n  diff_intersect_body(diff, extra, true\n                      COMMA true COMMA cmp_func COMMA &key_func\n                      COMMA cmp_func COMMA &data_func);\n}\n\nTypedValue HHVM_FUNCTION(array_diff_ukey,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& key_compare_func,\n                         const Array& args /* = null array */) {\n  Variant func = key_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(func);\n    func = extra.pop();\n  }\n  diff_intersect_body(diff, extra, true COMMA false COMMA cmp_func COMMA &func);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// intersect functions\n\nstatic inline TypedValue* makeContainerListHelper(const Variant& a,\n                                                  const Array& argv,\n                                                  int count,\n                                                  int smallestPos) {\n  assert(count == argv.size() + 1);\n  assert(0 <= smallestPos);\n  assert(smallestPos < count);\n  // Allocate a TypedValue array and copy 'a' and the contents of 'argv'\n  TypedValue* containers = req::make_raw_array<TypedValue>(count);\n  tvCopy(*a.asCell(), containers[0]);\n  int pos = 1;\n  for (ArrayIter argvIter(argv); argvIter; ++argvIter, ++pos) {\n    const auto& c = *argvIter.secondRef().asCell();\n    tvCopy(c, containers[pos]);\n  }\n  // Perform a swap so that the smallest container occurs at the first\n  // position in the TypedValue array; this helps improve the performance\n  // of containerValuesIntersectHelper()\n  if (smallestPos != 0) {\n    TypedValue tmp;\n    tvCopy(containers[0], tmp);\n    tvCopy(containers[smallestPos], containers[0]);\n    tvCopy(tmp, containers[smallestPos]);\n  }\n  return containers;\n}\n\nstatic inline void addToIntersectMapHelper(const req::ptr<c_Map>& mp,\n                                           const Cell c,\n                                           TypedValue* intOneTv,\n                                           TypedValue* strTv,\n                                           bool convertIntLikeStrs) {\n  if (c.m_type == KindOfInt64) {\n    mp->set(c.m_data.num, intOneTv);\n  } else {\n    StringData* s;\n    if (LIKELY(isStringType(c.m_type))) {\n      s = c.m_data.pstr;\n    } else {\n      s = tvCastToString(&c);\n      decRefStr(strTv->m_data.pstr);\n      strTv->m_data.pstr = s;\n    }\n    int64_t n;\n    if (convertIntLikeStrs && s->isStrictlyInteger(n)) {\n      mp->set(n, intOneTv);\n    } else {\n      mp->set(s, intOneTv);\n    }\n  }\n}\n\nstatic inline void updateIntersectMapHelper(const req::ptr<c_Map>& mp,\n                                            const Cell c,\n                                            int pos,\n                                            TypedValue* strTv,\n                                            bool convertIntLikeStrs) {\n  if (c.m_type == KindOfInt64) {\n    auto val = mp->get(c.m_data.num);\n    if (val && val->m_data.num == pos) {\n      assert(val->m_type == KindOfInt64);\n      ++val->m_data.num;\n    }\n  } else {\n    StringData* s;\n    if (LIKELY(isStringType(c.m_type))) {\n      s = c.m_data.pstr;\n    } else {\n      s = tvCastToString(&c);\n      decRefStr(strTv->m_data.pstr);\n      strTv->m_data.pstr = s;\n    }\n    int64_t n;\n    if (convertIntLikeStrs && s->isStrictlyInteger(n)) {\n      auto val = mp->get(n);\n      if (val && val->m_data.num == pos) {\n        assert(val->m_type == KindOfInt64);\n        ++val->m_data.num;\n      }\n    } else {\n      auto val = mp->get(s);\n      if (val && val->m_data.num == pos) {\n        assert(val->m_type == KindOfInt64);\n        ++val->m_data.num;\n      }\n    }\n  }\n}\n\nstatic void containerValuesIntersectHelper(const req::ptr<c_Set>& st,\n                                           TypedValue* containers,\n                                           int count) {\n  assert(count >= 2);\n  auto mp = req::make<c_Map>();\n  Variant strHolder(empty_string_variant());\n  TypedValue* strTv = strHolder.asTypedValue();\n  TypedValue intOneTv = make_tv<KindOfInt64>(1);\n  for (ArrayIter iter(tvAsCVarRef(&containers[0])); iter; ++iter) {\n    const auto& c = *iter.secondRefPlus().asCell();\n    // For each value v in containers[0], we add the key/value pair (v, 1)\n    // to the map. If a value (after various conversions) occurs more than\n    // once in the container, we'll simply overwrite the old entry and that's\n    // fine.\n    addToIntersectMapHelper(mp, c, &intOneTv, strTv, true);\n  }\n  for (int pos = 1; pos < count; ++pos) {\n    for (ArrayIter iter(tvAsCVarRef(&containers[pos])); iter; ++iter) {\n      const auto& c = *iter.secondRefPlus().asCell();\n      // We check if the value is present as a key in the map. If an entry\n      // exists and its value equals pos, we increment it, otherwise we do\n      // nothing. This is essential so that we don't accidentally double-count\n      // a key (after various conversions) that occurs in the container more\n      // than once.\n      updateIntersectMapHelper(mp, c, pos, strTv, true);\n    }\n  }\n  for (ArrayIter iter(mp.get()); iter; ++iter) {\n    // For each key in the map, we copy the key to the set if the\n    // corresponding value is equal to pos exactly (which means it\n    // was present in all of the containers).\n    const auto& val = *iter.secondRefPlus().asCell();\n    assert(val.m_type == KindOfInt64);\n    if (val.m_data.num == count) {\n      st->add(iter.first().asCell());\n    }\n  }\n}\n\nstatic void containerKeysIntersectHelper(const req::ptr<c_Set>& st,\n                                         TypedValue* containers,\n                                         int count) {\n  assert(count >= 2);\n  auto mp = req::make<c_Map>();\n  Variant strHolder(empty_string_variant());\n  TypedValue* strTv = strHolder.asTypedValue();\n  TypedValue intOneTv = make_tv<KindOfInt64>(1);\n  bool isKey = isArrayType(containers[0].m_type);\n  for (ArrayIter iter(tvAsCVarRef(&containers[0])); iter; ++iter) {\n    auto key = iter.first();\n    const auto& c = *key.asCell();\n    // For each key k in containers[0], we add the key/value pair (k, 1)\n    // to the map. If a key (after various conversions) occurs more than\n    // once in the container, we'll simply overwrite the old entry and\n    // that's fine.\n    addToIntersectMapHelper(mp, c, &intOneTv, strTv, !isKey);\n  }\n  for (int pos = 1; pos < count; ++pos) {\n    isKey = isArrayType(containers[pos].m_type);\n    for (ArrayIter iter(tvAsCVarRef(&containers[pos])); iter; ++iter) {\n      auto key = iter.first();\n      const auto& c = *key.asCell();\n      updateIntersectMapHelper(mp, c, pos, strTv, !isKey);\n    }\n  }\n  for (ArrayIter iter(mp.get()); iter; ++iter) {\n    // For each key in the map, we copy the key to the set if the\n    // corresponding value is equal to pos exactly (which means it\n    // was present in all of the containers).\n    const auto& val = *iter.secondRefPlus().asCell();\n    assert(val.m_type == KindOfInt64);\n    if (val.m_data.num == count) {\n      st->add(iter.first().asCell());\n    }\n  }\n}\n\n#define ARRAY_INTERSECT_PRELUDE() \\\n  /* Check to make sure all inputs are containers */ \\\n  const auto& c1 = *container1.asCell(); \\\n  const auto& c2 = *container2.asCell(); \\\n  if (!isContainer(c1) || !isContainer(c2)) { \\\n    raise_warning(\"%s() expects parameter %d to be an array or collection\", \\\n                  __FUNCTION__+2, /* remove the \"f_\" prefix */ \\\n                  isContainer(c1) ? 2 : 1); \\\n    return make_tv<KindOfNull>(); \\\n  } \\\n  bool moreThanTwo = !args.empty(); \\\n  /* Keep track of which input container was the smallest (excluding \\\n     container1) */ \\\n  int smallestPos = 0; \\\n  size_t smallestSize = getContainerSize(c2); \\\n  if (UNLIKELY(moreThanTwo)) { \\\n    int pos = 1; \\\n    for (ArrayIter argvIter(args); argvIter; ++argvIter, ++pos) { \\\n      const auto& c = *argvIter.secondRef().asCell(); \\\n      if (!isContainer(c)) { \\\n        raise_warning(\"%s() expects parameter %d to be an array or collection\",\\\n                      __FUNCTION__+2, /* remove the \"f_\" prefix */ \\\n                      pos+2); \\\n        return make_tv<KindOfNull>(); \\\n      } \\\n      size_t sz = getContainerSize(c); \\\n      if (sz < smallestSize) { \\\n        smallestSize = sz; \\\n        smallestPos = pos; \\\n      } \\\n    } \\\n  } \\\n  /* If any of the containers were empty, we can stop here and return the \\\n     empty array */ \\\n  if (!getContainerSize(c1) || !smallestSize) { \\\n    return make_tv<KindOfPersistentArray>(staticEmptyArray()); \\\n  } \\\n  Array ret = Array::Create();\n\nTypedValue HHVM_FUNCTION(array_intersect,\n                         const Variant& container1,\n                         const Variant& container2,\n                         const Array& args /* = null array */) {\n  ARRAY_INTERSECT_PRELUDE()\n  // Build up a Set containing the values that are present in all the\n  // containers (except container1)\n  auto st = req::make<c_Set>();\n  if (LIKELY(!moreThanTwo)) {\n    // There is only one container (not counting container1) so we can\n    // just call containerValuesToSetHelper() to build the Set.\n    containerValuesToSetHelper(st, container2);\n  } else {\n    // We're dealing with three or more containers. Copy all of the containers\n    // (except the first) into a TypedValue array.\n    int count = args.size() + 1;\n    TypedValue* containers =\n      makeContainerListHelper(container2, args, count, smallestPos);\n    SCOPE_EXIT { req::free(containers); };\n    // Build a Set of the values that were present in all of the containers\n    containerValuesIntersectHelper(st, containers, count);\n  }\n  // Loop over container1, only copying over key/value pairs where the value\n  // is present in the Set. When checking if a value is present in the Set,\n  // any value that is not an integer or string is cast to a string, and we\n  // convert int-like strings to integers.\n  Variant strHolder(empty_string_variant());\n  TypedValue* strTv = strHolder.asTypedValue();\n  bool isKey = isArrayType(c1.m_type);\n  for (ArrayIter iter(container1); iter; ++iter) {\n    const auto& val = iter.secondRefPlus();\n    const auto& c = *val.asCell();\n    if (!checkSetHelper(st, c, strTv, true)) continue;\n    ret.setWithRef(iter.first(), val, isKey);\n  }\n  return tvReturn(std::move(ret));\n}\n\nTypedValue HHVM_FUNCTION(array_intersect_key,\n                         const Variant& container1,\n                         const Variant& container2,\n                         const Array& args /* = null array */) {\n  ARRAY_INTERSECT_PRELUDE()\n  // If we're only dealing with two containers and if they are both arrays,\n  // we can avoid creating an intermediate Set\n  if (!moreThanTwo && isArrayType(c1.m_type) && isArrayType(c2.m_type)) {\n    auto ad2 = c2.m_data.parr;\n    for (ArrayIter iter(container1); iter; ++iter) {\n      auto key = iter.first();\n      const auto& c = *key.asCell();\n      if (c.m_type == KindOfInt64) {\n        if (!ad2->exists(c.m_data.num)) continue;\n      } else {\n        assert(isStringType(c.m_type));\n        if (!ad2->exists(c.m_data.pstr)) continue;\n      }\n      ret.setWithRef(key, iter.secondRefPlus(), true);\n    }\n    return tvReturn(std::move(ret));\n  }\n  // Build up a Set containing the keys that are present in all the containers\n  // (except container1)\n  auto st = req::make<c_Set>();\n  if (LIKELY(!moreThanTwo)) {\n    // There is only one container (not counting container1) so we can just\n    // call containerKeysToSetHelper() to build the Set.\n    containerKeysToSetHelper(st, container2);\n  } else {\n    // We're dealing with three or more containers. Copy all of the containers\n    // (except the first) into a TypedValue array.\n    int count = args.size() + 1;\n    TypedValue* containers =\n      makeContainerListHelper(container2, args, count, smallestPos);\n    SCOPE_EXIT { req::free(containers); };\n    // Build a Set of the keys that were present in all of the containers\n    containerKeysIntersectHelper(st, containers, count);\n  }\n  // Loop over container1, only copying over key/value pairs where the key\n  // is present in the Set. When checking if a key is present in the Set,\n  // any value that is not an integer or string is cast to a string, and we\n  // convert int-like strings to integers.\n  Variant strHolder(empty_string_variant());\n  TypedValue* strTv = strHolder.asTypedValue();\n  bool isKey = isArrayType(c1.m_type);\n  for (ArrayIter iter(container1); iter; ++iter) {\n    auto key = iter.first();\n    const auto& c = *key.asCell();\n    if (!checkSetHelper(st, c, strTv, !isKey)) continue;\n    ret.setWithRef(key, iter.secondRefPlus(), isKey);\n  }\n  return tvReturn(std::move(ret));\n}\n\n#undef ARRAY_INTERSECT_PRELUDE\n\nTypedValue HHVM_FUNCTION(array_uintersect,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& data_compare_func,\n                         const Array& args /* = null array */) {\n  Variant func = data_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(func);\n    func = extra.pop();\n  }\n  diff_intersect_body(intersect, extra, false COMMA true COMMA NULL COMMA NULL\n                      COMMA cmp_func COMMA &func);\n}\n\nTypedValue HHVM_FUNCTION(array_intersect_assoc,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Array& args /* = null array */) {\n  diff_intersect_body(intersect, args, true COMMA true);\n}\n\nTypedValue HHVM_FUNCTION(array_intersect_uassoc,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& key_compare_func,\n                         const Array& args /* = null array */) {\n  Variant func = key_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(func);\n    func = extra.pop();\n  }\n  diff_intersect_body(intersect, extra, true COMMA true\n                      COMMA cmp_func COMMA &func);\n}\n\nTypedValue HHVM_FUNCTION(array_uintersect_assoc,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& data_compare_func,\n                         const Array& args /* = null array */) {\n  Variant func = data_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(func);\n    func = extra.pop();\n  }\n  diff_intersect_body(intersect, extra, true COMMA true COMMA NULL COMMA NULL\n                      COMMA cmp_func COMMA &func);\n}\n\nTypedValue HHVM_FUNCTION(array_uintersect_uassoc,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& data_compare_func,\n                         const Variant& key_compare_func,\n                         const Array& args /* = null array */) {\n  Variant data_func = data_compare_func;\n  Variant key_func = key_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(key_func);\n    extra.prepend(data_func);\n    key_func = extra.pop();\n    data_func = extra.pop();\n  }\n  diff_intersect_body(intersect, extra, true COMMA true COMMA cmp_func\n                      COMMA &key_func COMMA cmp_func COMMA &data_func);\n}\n\nTypedValue HHVM_FUNCTION(array_intersect_ukey,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& key_compare_func,\n                         const Array& args /* = null array */) {\n  Variant func = key_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(func);\n    func = extra.pop();\n  }\n  diff_intersect_body(intersect, extra, true COMMA false\n                      COMMA cmp_func COMMA &func);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// sorting functions\n\nstruct Collator final : RequestEventHandler {\n  String getLocale() {\n    return m_locale;\n  }\n  Intl::IntlError &getErrorRef() {\n    return m_errcode;\n  }\n  bool setLocale(const String& locale) {\n    if (m_locale.same(locale)) {\n      return true;\n    }\n    if (m_ucoll) {\n      ucol_close(m_ucoll);\n      m_ucoll = NULL;\n    }\n    m_errcode.clearError();\n    UErrorCode error = U_ZERO_ERROR;\n    m_ucoll = ucol_open(locale.data(), &error);\n    if (m_ucoll == NULL) {\n      raise_warning(\"failed to load %s locale from icu data\", locale.data());\n      return false;\n    }\n    if (U_FAILURE(error)) {\n      m_errcode.setError(error);\n      ucol_close(m_ucoll);\n      m_ucoll = NULL;\n      return false;\n    }\n    m_locale = locale;\n    return true;\n  }\n\n  UCollator *getCollator() {\n    return m_ucoll;\n  }\n\n  bool setAttribute(int64_t attr, int64_t val) {\n    if (!m_ucoll) {\n      Logger::Verbose(\"m_ucoll is NULL\");\n      return false;\n    }\n    m_errcode.clearError();\n    UErrorCode error = U_ZERO_ERROR;\n    ucol_setAttribute(m_ucoll, (UColAttribute)attr,\n                      (UColAttributeValue)val, &error);\n    if (U_FAILURE(error)) {\n      m_errcode.setError(error);\n      Logger::Verbose(\"Error setting attribute value\");\n      return false;\n    }\n    return true;\n  }\n\n  bool setStrength(int64_t strength) {\n    if (!m_ucoll) {\n      Logger::Verbose(\"m_ucoll is NULL\");\n      return false;\n    }\n    ucol_setStrength(m_ucoll, (UCollationStrength)strength);\n    return true;\n  }\n\n  Variant getErrorCode() {\n    if (!m_ucoll) {\n      Logger::Verbose(\"m_ucoll is NULL\");\n      return false;\n    }\n    return m_errcode.getErrorCode();\n  }\n\n  void requestInit() override {\n    m_locale = String(uloc_getDefault(), CopyString);\n    m_errcode.clearError();\n    UErrorCode error = U_ZERO_ERROR;\n    m_ucoll = ucol_open(m_locale.data(), &error);\n    if (U_FAILURE(error)) {\n      m_errcode.setError(error);\n    }\n    assert(m_ucoll);\n  }\n\n  void requestShutdown() override {\n    m_locale.reset();\n    m_errcode.clearError(false);\n    if (m_ucoll) {\n      ucol_close(m_ucoll);\n      m_ucoll = NULL;\n    }\n  }\n\n  void vscan(IMarker& mark) const override {\n    mark(m_locale);\n  }\n\nprivate:\n  String     m_locale;\n  UCollator *m_ucoll;\n  Intl::IntlError m_errcode;\n};\nIMPLEMENT_STATIC_REQUEST_LOCAL(Collator, s_collator);\n\nnamespace {\nstruct ArraySortTmp {\n  explicit ArraySortTmp(Array& arr, SortFunction sf) : m_arr(arr) {\n    m_ad = arr.get()->escalateForSort(sf);\n    assert(m_ad == arr.get() || m_ad->hasExactlyOneRef());\n  }\n  ~ArraySortTmp() {\n    if (m_ad != m_arr.get()) {\n      m_arr = Array::attach(m_ad);\n    }\n  }\n  ArrayData* operator->() { return m_ad; }\n private:\n  Array& m_arr;\n  ArrayData* m_ad;\n};\n}\n\nstatic bool\nphp_sort(VRefParam container, int sort_flags,\n         bool ascending, bool use_zend_sort) {\n  if (container.isArray()) {\n    auto ref = container.getVariantOrNull();\n    if (!ref) return true;\n    Array& arr_array = ref->asArrRef();\n    if (use_zend_sort) {\n      return zend_sort(*ref, sort_flags, ascending);\n    }\n    SortFunction sf = getSortFunction(SORTFUNC_SORT, ascending);\n    ArraySortTmp ast(arr_array, sf);\n    ast->sort(sort_flags, ascending);\n    return true;\n  }\n  if (container.isObject()) {\n    ObjectData* obj = container.getObjectData();\n    if (obj->isCollection() &&\n        obj->collectionType() == CollectionType::Vector) {\n      c_Vector* vec = static_cast<c_Vector*>(obj);\n      vec->sort(sort_flags, ascending);\n      return true;\n    }\n    // other collections are not supported:\n    //  - Maps and Sets require associative sort\n    //  - Immutable collections are not to be modified\n  }\n  throw_expected_array_or_collection_exception(ascending ? \"sort\" : \"rsort\");\n  return false;\n}\n\nstatic bool\nphp_asort(VRefParam container, int sort_flags,\n          bool ascending, bool use_zend_sort) {\n  if (container.isArray()) {\n    auto ref = container.getVariantOrNull();\n    if (!ref) return true;\n    Array& arr_array = ref->asArrRef();\n    if (use_zend_sort) {\n      return zend_asort(*ref, sort_flags, ascending);\n    }\n    SortFunction sf = getSortFunction(SORTFUNC_ASORT, ascending);\n    ArraySortTmp ast(arr_array, sf);\n    ast->asort(sort_flags, ascending);\n    return true;\n  }\n  if (container.isObject()) {\n    ObjectData* obj = container.getObjectData();\n    if (obj->isCollection()) {\n      auto type = obj->collectionType();\n      if (type == CollectionType::Map || type == CollectionType::Set) {\n        HashCollection* hc = static_cast<HashCollection*>(obj);\n        hc->asort(sort_flags, ascending);\n        return true;\n      }\n    }\n  }\n  throw_expected_array_or_collection_exception(ascending ? \"asort\" : \"arsort\");\n  return false;\n}\n\nstatic bool\nphp_ksort(VRefParam container, int sort_flags, bool ascending,\n          bool use_zend_sort) {\n  if (container.isArray()) {\n    auto ref = container.getVariantOrNull();\n    if (!ref) return true;\n    Array& arr_array = ref->asArrRef();\n    if (use_zend_sort) {\n      return zend_ksort(*ref, sort_flags, ascending);\n    }\n    SortFunction sf = getSortFunction(SORTFUNC_KRSORT, ascending);\n    ArraySortTmp ast(arr_array, sf);\n    ast->ksort(sort_flags, ascending);\n    return true;\n  }\n  if (container.isObject()) {\n    ObjectData* obj = container.getObjectData();\n    if (obj->isCollection()) {\n      auto type = obj->collectionType();\n      if (type == CollectionType::Map || type == CollectionType::Set) {\n        HashCollection* hc = static_cast<HashCollection*>(obj);\n        hc->ksort(sort_flags, ascending);\n        return true;\n      }\n    }\n  }\n  throw_expected_array_or_collection_exception(ascending ? \"ksort\" : \"krsort\");\n  return false;\n}\n\nbool HHVM_FUNCTION(sort,\n                  VRefParam array,\n                  int sort_flags /* = 0 */) {\n  bool use_zend_sort = RuntimeOption::EnableZendSorting;\n  return php_sort(array, sort_flags, true, use_zend_sort);\n}\n\nbool HHVM_FUNCTION(rsort,\n                   VRefParam array,\n                   int sort_flags /* = 0 */) {\n  bool use_zend_sort = RuntimeOption::EnableZendSorting;\n  return php_sort(array, sort_flags, false, use_zend_sort);\n}\n\nbool HHVM_FUNCTION(asort,\n                   VRefParam array,\n                   int sort_flags /* = 0 */) {\n  bool use_zend_sort = RuntimeOption::EnableZendSorting;\n  return php_asort(array, sort_flags, true, use_zend_sort);\n}\n\nbool HHVM_FUNCTION(arsort,\n                   VRefParam array,\n                   int sort_flags /* = 0 */) {\n  bool use_zend_sort = RuntimeOption::EnableZendSorting;\n  return php_asort(array, sort_flags, false, use_zend_sort);\n}\n\nbool HHVM_FUNCTION(ksort,\n                   VRefParam array,\n                   int sort_flags /* = 0 */) {\n  bool use_zend_sort = RuntimeOption::EnableZendSorting;\n  return php_ksort(array, sort_flags, true, use_zend_sort);\n}\n\nbool HHVM_FUNCTION(krsort,\n                   VRefParam array,\n                   int sort_flags /* = 0 */) {\n  bool use_zend_sort = RuntimeOption::EnableZendSorting;\n  return php_ksort(array, sort_flags, false, use_zend_sort);\n}\n\n// NOTE: PHP's implementation of natsort and natcasesort accepts ArrayAccess\n// objects as well, which does not make much sense, and which is not supported\n// here.\n\nbool HHVM_FUNCTION(natsort, VRefParam array) {\n  return php_asort(array, SORT_NATURAL, true, false);\n}\n\nbool HHVM_FUNCTION(natcasesort, VRefParam array) {\n  return php_asort(array, SORT_NATURAL_CASE, true, false);\n}\n\nbool HHVM_FUNCTION(usort,\n                   VRefParam container,\n                   const Variant& cmp_function) {\n  if (container.isArray()) {\n    auto sort = [](Array& arr_array, const Variant& cmp_function) -> bool {\n      if (RuntimeOption::EnableZendSorting) {\n        arr_array.sort(cmp_func, false, true, &cmp_function);\n        return true;\n      } else {\n        ArraySortTmp ast(arr_array, SORTFUNC_USORT);\n        return ast->usort(cmp_function);\n      }\n    };\n    auto ref = container.getVariantOrNull();\n    if (LIKELY(ref != nullptr)) {\n      return sort(ref->asArrRef(), cmp_function);\n    }\n    auto tmp = container->asCArrRef();\n    return sort(tmp, cmp_function);\n  }\n  if (container.isObject()) {\n    ObjectData* obj = container.getObjectData();\n    if (obj->isCollection()) {\n      if (obj->collectionType() == CollectionType::Vector) {\n        c_Vector* vec = static_cast<c_Vector*>(obj);\n        return vec->usort(cmp_function);\n      }\n    }\n    // other collections are not supported:\n    //  - Maps and Sets require associative sort\n    //  - Immutable collections are not to be modified\n  }\n  throw_expected_array_or_collection_exception(\"usort\");\n  return false;\n}\n\nbool HHVM_FUNCTION(uasort,\n                   VRefParam container,\n                   const Variant& cmp_function) {\n  if (container.isArray()) {\n    auto sort = [](Array& arr_array, const Variant& cmp_function) -> bool {\n      if (RuntimeOption::EnableZendSorting) {\n        arr_array.sort(cmp_func, false, false, &cmp_function);\n        return true;\n      } else {\n        ArraySortTmp ast(arr_array, SORTFUNC_UASORT);\n        return ast->uasort(cmp_function);\n      }\n    };\n    auto ref = container.getVariantOrNull();\n    if (LIKELY(ref != nullptr)) {\n      return sort(ref->asArrRef(), cmp_function);\n    }\n    auto tmp = container->asCArrRef();\n    return sort(tmp, cmp_function);\n  }\n  if (container.isObject()) {\n    ObjectData* obj = container.getObjectData();\n    if (obj->isCollection()) {\n      auto type = obj->collectionType();\n      if (type == CollectionType::Map || type == CollectionType::Set) {\n        HashCollection* hc = static_cast<HashCollection*>(obj);\n        return hc->uasort(cmp_function);\n      }\n    }\n    // other collections are not supported:\n    //  - Vectors require a non-associative sort\n    //  - Immutable collections are not to be modified\n  }\n  throw_expected_array_or_collection_exception(\"uasort\");\n  return false;\n}\n\nbool HHVM_FUNCTION(uksort,\n                   VRefParam container,\n                   const Variant& cmp_function) {\n  if (container.isArray()) {\n    auto sort = [](Array& arr_array, const Variant& cmp_function) -> bool {\n      ArraySortTmp ast(arr_array, SORTFUNC_UKSORT);\n      return ast->uksort(cmp_function);\n    };\n    auto ref = container.getVariantOrNull();\n    if (LIKELY(ref != nullptr)) {\n      return sort(ref->asArrRef(), cmp_function);\n    }\n    auto tmp = container->asCArrRef();\n    return sort(tmp, cmp_function);\n  }\n  if (container.isObject()) {\n    ObjectData* obj = container.getObjectData();\n    if (obj->isCollection()) {\n      auto type = obj->collectionType();\n      if (type == CollectionType::Map || type == CollectionType::Set) {\n        HashCollection* hc = static_cast<HashCollection*>(obj);\n        return hc->uksort(cmp_function);\n      }\n    }\n    // other collections are not supported:\n    //  - Vectors require a non-associative sort\n    //  - Immutable collections are not to be modified\n  }\n  throw_expected_array_or_collection_exception(\"uksort\");\n  return false;\n}\n\nTypedValue HHVM_FUNCTION(array_unique,\n                         const Variant& array,\n                         int sort_flags /* = 2 */) {\n  // NOTE, PHP array_unique accepts ArrayAccess objects as well,\n  // which is not supported here.\n  getCheckedArray(array);\n  switch (sort_flags) {\n  case SORT_STRING:\n  case SORT_LOCALE_STRING:\n    return tvReturn(ArrayUtil::StringUnique(arr_array));\n  case SORT_NUMERIC:\n    return tvReturn(ArrayUtil::NumericUnique(arr_array));\n  case SORT_REGULAR:\n  default:\n    return tvReturn(ArrayUtil::RegularSortUnique(arr_array));\n  }\n}\n\nString HHVM_FUNCTION(i18n_loc_get_default) {\n  return s_collator->getLocale();\n}\n\nbool HHVM_FUNCTION(i18n_loc_set_default,\n                   const String& locale) {\n  return s_collator->setLocale(locale);\n}\n\nbool HHVM_FUNCTION(i18n_loc_set_attribute,\n                   int64_t attr,\n                   int64_t val) {\n  return s_collator->setAttribute(attr, val);\n}\n\nbool HHVM_FUNCTION(i18n_loc_set_strength,\n                   int64_t strength) {\n  return s_collator->setStrength(strength);\n}\n\nVariant HHVM_FUNCTION(i18n_loc_get_error_code) {\n  return s_collator->getErrorCode();\n}\n\nTypedValue HHVM_FUNCTION(hphp_array_idx,\n                         const Variant& search,\n                         const Variant& key,\n                         const Variant& def) {\n  if (!key.isNull()) {\n    if (LIKELY(search.isArray())) {\n      ArrayData *arr = search.getArrayData();\n      VarNR index = key.toKey(arr);\n      if (!index.isNull()) {\n        const Variant& ret = arr->get(index, false);\n        return tvReturn((&ret != &null_variant) ? ret : def);\n      }\n    } else {\n      raise_error(\"hphp_array_idx: search must be an array\");\n    }\n  }\n  return tvReturn(def);\n}\n\nstatic Array::PFUNC_CMP get_cmp_func(int sort_flags, bool ascending) {\n  switch (sort_flags) {\n  case SORT_NATURAL:\n    return ascending ?\n      Array::SortNaturalAscending : Array::SortNaturalDescending;\n  case SORT_NATURAL_CASE:\n    return ascending ?\n      Array::SortNaturalCaseAscending: Array::SortNaturalCaseDescending;\n  case SORT_NUMERIC:\n    return ascending ?\n      Array::SortNumericAscending : Array::SortNumericDescending;\n  case SORT_STRING:\n    return ascending ?\n      Array::SortStringAscending : Array::SortStringDescending;\n  case SORT_STRING_CASE:\n    return ascending ?\n      Array::SortStringAscendingCase : Array::SortStringDescendingCase;\n  case SORT_LOCALE_STRING:\n    return ascending ?\n      Array::SortLocaleStringAscending : Array::SortLocaleStringDescending;\n  case SORT_REGULAR:\n  default:\n    return ascending ?\n      Array::SortRegularAscending : Array::SortRegularDescending;\n  }\n}\n\nTypedValue* HHVM_FN(array_multisort)(ActRec* ar) {\n  TypedValue* tv = getArg(ar, 0);\n  if (tv == nullptr || !tvAsVariant(tv).isArray()) {\n    throw_expected_array_exception(\"array_multisort\");\n    return arReturn(ar, false);\n  }\n\n  std::vector<Array::SortData> data;\n  std::vector<Array> arrays;\n  arrays.reserve(ar->numArgs()); // so no resize would happen\n\n  Array::SortData sd;\n  sd.original = &tvAsVariant(tv);\n  arrays.push_back(Array(sd.original->getArrayData()));\n  sd.array = &arrays.back();\n  sd.by_key = false;\n\n  int sort_flags = SORT_REGULAR;\n  bool ascending = true;\n  for (int i = 1; i < ar->numArgs(); i++) {\n    tv = getArg(ar, i);\n    if (tvAsVariant(tv).isArray()) {\n      sd.cmp_func = get_cmp_func(sort_flags, ascending);\n      data.push_back(sd);\n\n      sort_flags = SORT_REGULAR;\n      ascending = true;\n\n      sd.original = &tvAsVariant(tv);\n      arrays.push_back(Array(sd.original->getArrayData()));\n      sd.array = &arrays.back();\n    } else {\n      int n = toInt32(getArg<KindOfInt64>(ar, i));\n      if (n == SORT_ASC) {\n      } else if (n == SORT_DESC) {\n        ascending = false;\n      } else {\n        sort_flags = n;\n      }\n    }\n  }\n\n  sd.cmp_func = get_cmp_func(sort_flags, ascending);\n  data.push_back(sd);\n\n  return arReturn(ar, Array::MultiSort(data, true));\n}\n\n// HH\\\\dict\nArray HHVM_FUNCTION(HH_dict, const Array& arr) {\n  return arr.toDict();\n}\n\n// HH\\\\vec\nArray HHVM_FUNCTION(HH_vec, const Array& arr) {\n  return arr.toVec();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nstruct ArrayExtension final : Extension {\n  ArrayExtension() : Extension(\"array\") {}\n  void moduleInit() override {\n    HHVM_RC_INT_SAME(UCOL_DEFAULT);\n\n    HHVM_RC_INT_SAME(UCOL_PRIMARY);\n    HHVM_RC_INT_SAME(UCOL_SECONDARY);\n    HHVM_RC_INT_SAME(UCOL_TERTIARY);\n    HHVM_RC_INT_SAME(UCOL_DEFAULT_STRENGTH);\n    HHVM_RC_INT_SAME(UCOL_QUATERNARY);\n    HHVM_RC_INT_SAME(UCOL_IDENTICAL);\n\n    HHVM_RC_INT_SAME(UCOL_OFF);\n    HHVM_RC_INT_SAME(UCOL_ON);\n\n    HHVM_RC_INT_SAME(UCOL_SHIFTED);\n    HHVM_RC_INT_SAME(UCOL_NON_IGNORABLE);\n\n    HHVM_RC_INT_SAME(UCOL_LOWER_FIRST);\n    HHVM_RC_INT_SAME(UCOL_UPPER_FIRST);\n\n    HHVM_RC_INT_SAME(UCOL_FRENCH_COLLATION);\n    HHVM_RC_INT_SAME(UCOL_ALTERNATE_HANDLING);\n    HHVM_RC_INT_SAME(UCOL_CASE_FIRST);\n    HHVM_RC_INT_SAME(UCOL_CASE_LEVEL);\n    HHVM_RC_INT_SAME(UCOL_NORMALIZATION_MODE);\n    HHVM_RC_INT_SAME(UCOL_STRENGTH);\n    HHVM_RC_INT_SAME(UCOL_HIRAGANA_QUATERNARY_MODE);\n    HHVM_RC_INT_SAME(UCOL_NUMERIC_COLLATION);\n\n    HHVM_RC_INT(ARRAY_FILTER_USE_BOTH, 1);\n    HHVM_RC_INT(ARRAY_FILTER_USE_KEY, 2);\n\n    HHVM_RC_INT(CASE_LOWER,      CaseMode::LOWER);\n    HHVM_RC_INT(CASE_UPPER,      CaseMode::UPPER);\n\n    HHVM_RC_INT(COUNT_NORMAL,    CountMode::NORMAL);\n    HHVM_RC_INT(COUNT_RECURSIVE, CountMode::RECURSIVE);\n\n    HHVM_RC_INT_SAME(SORT_ASC);\n    HHVM_RC_INT_SAME(SORT_DESC);\n    HHVM_RC_INT_SAME(SORT_FLAG_CASE);\n    HHVM_RC_INT_SAME(SORT_LOCALE_STRING);\n    HHVM_RC_INT_SAME(SORT_NATURAL);\n    HHVM_RC_INT_SAME(SORT_NUMERIC);\n    HHVM_RC_INT_SAME(SORT_REGULAR);\n    HHVM_RC_INT_SAME(SORT_STRING);\n\n    HHVM_FE(array_change_key_case);\n    HHVM_FE(array_chunk);\n    HHVM_FE(array_column);\n    HHVM_FE(array_combine);\n    HHVM_FE(array_count_values);\n    HHVM_FE(array_fill_keys);\n    HHVM_FE(array_fill);\n    HHVM_FE(array_flip);\n    HHVM_FE(array_key_exists);\n    HHVM_FE(key_exists);\n    HHVM_FE(array_keys);\n    HHVM_FALIAS(__SystemLib\\\\array_map, array_map);\n    HHVM_FE(array_merge_recursive);\n    HHVM_FE(array_merge);\n    HHVM_FE(array_replace_recursive);\n    HHVM_FE(array_replace);\n    HHVM_FE(array_pad);\n    HHVM_FE(array_pop);\n    HHVM_FE(array_product);\n    HHVM_FE(array_push);\n    HHVM_FE(array_rand);\n    HHVM_FE(array_reverse);\n    HHVM_FE(array_search);\n    HHVM_FE(array_shift);\n    HHVM_FE(array_slice);\n    HHVM_FE(array_splice);\n    HHVM_FE(array_sum);\n    HHVM_FE(array_unique);\n    HHVM_FE(array_unshift);\n    HHVM_FE(array_values);\n    HHVM_FE(array_walk_recursive);\n    HHVM_FE(array_walk);\n    HHVM_FE(compact);\n    HHVM_FALIAS(__SystemLib\\\\compact_sl, __SystemLib_compact_sl);\n    HHVM_FE(shuffle);\n    HHVM_FE(count);\n    HHVM_FE(sizeof);\n    HHVM_FE(each);\n    HHVM_FE(current);\n    HHVM_FE(next);\n    HHVM_FE(pos);\n    HHVM_FE(prev);\n    HHVM_FE(reset);\n    HHVM_FE(end);\n    HHVM_FE(key);\n    HHVM_FE(in_array);\n    HHVM_FE(range);\n    HHVM_FE(array_diff);\n    HHVM_FE(array_udiff);\n    HHVM_FE(array_diff_assoc);\n    HHVM_FE(array_diff_uassoc);\n    HHVM_FE(array_udiff_assoc);\n    HHVM_FE(array_udiff_uassoc);\n    HHVM_FE(array_diff_key);\n    HHVM_FE(array_diff_ukey);\n    HHVM_FE(array_intersect);\n    HHVM_FE(array_uintersect);\n    HHVM_FE(array_intersect_assoc);\n    HHVM_FE(array_intersect_uassoc);\n    HHVM_FE(array_uintersect_assoc);\n    HHVM_FE(array_uintersect_uassoc);\n    HHVM_FE(array_intersect_key);\n    HHVM_FE(array_intersect_ukey);\n    HHVM_FE(sort);\n    HHVM_FE(rsort);\n    HHVM_FE(asort);\n    HHVM_FE(arsort);\n    HHVM_FE(ksort);\n    HHVM_FE(krsort);\n    HHVM_FE(usort);\n    HHVM_FE(uasort);\n    HHVM_FE(uksort);\n    HHVM_FE(natsort);\n    HHVM_FE(natcasesort);\n    HHVM_FE(i18n_loc_get_default);\n    HHVM_FE(i18n_loc_set_default);\n    HHVM_FE(i18n_loc_set_attribute);\n    HHVM_FE(i18n_loc_set_strength);\n    HHVM_FE(i18n_loc_get_error_code);\n    HHVM_FE(hphp_array_idx);\n    HHVM_FE(array_multisort);\n    HHVM_FALIAS(HH\\\\dict, HH_dict);\n    HHVM_FALIAS(HH\\\\vec, HH_vec);\n\n    loadSystemlib();\n  }\n} s_array_extension;\n\n}\n", "<?php\n\nfunction test($g) {\n  $GLOBALS['g'] = $GLOBALS;\n\n  array_replace_recursive($GLOBALS, $g);\n\n  $GLOBALS['g'] = $GLOBALS;\n  array_merge_recursive($GLOBALS, $g);\n}\n\nfunction main() {\n  $a = array();\n  $a['g'] = &$a;\n\n  test($a);\n  test($GLOBALS);\n}\n\nmain();\n", "\nWarning: array_replace_recursive(): recursion detected in %s/test/slow/array_functions/self_recursive.php on line 6\n\nWarning: array_merge_recursive(): recursion detected in %s/test/slow/array_functions/self_recursive.php on line 9\n\nWarning: array_merge_recursive(): recursion detected in %s/test/slow/array_functions/self_recursive.php on line 9\n\nWarning: array_merge_recursive(): recursion detected in %s/test/slow/array_functions/self_recursive.php on line 9\n\nWarning: array_merge_recursive(): recursion detected in %s/test/slow/array_functions/self_recursive.php on line 9\n\nWarning: array_merge_recursive(): recursion detected in %s/test/slow/array_functions/self_recursive.php on line 9\n"], "fixing_code": ["/*\n   +----------------------------------------------------------------------+\n   | HipHop for PHP                                                       |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 2010-2016 Facebook, Inc. (http://www.facebook.com)     |\n   | Copyright (c) 1997-2010 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n*/\n\n#include \"hphp/runtime/ext/array/ext_array.h\"\n\n#include \"hphp/runtime/base/thread-info.h\"\n#include \"hphp/runtime/base/actrec-args.h\"\n#include \"hphp/runtime/base/array-data-defs.h\"\n#include \"hphp/runtime/base/array-init.h\"\n#include \"hphp/runtime/base/builtin-functions.h\"\n#include \"hphp/runtime/base/collections.h\"\n#include \"hphp/runtime/base/comparisons.h\"\n#include \"hphp/runtime/base/container-functions.h\"\n#include \"hphp/runtime/base/mixed-array.h\"\n#include \"hphp/runtime/base/request-event-handler.h\"\n#include \"hphp/runtime/base/request-local.h\"\n#include \"hphp/runtime/base/req-containers.h\"\n#include \"hphp/runtime/base/sort-flags.h\"\n#include \"hphp/runtime/base/zend-collator.h\"\n#include \"hphp/runtime/base/zend-sort.h\"\n#include \"hphp/runtime/ext/generator/ext_generator.h\"\n#include \"hphp/runtime/ext/collections/ext_collections-map.h\"\n#include \"hphp/runtime/ext/collections/ext_collections-pair.h\"\n#include \"hphp/runtime/ext/collections/ext_collections-set.h\"\n#include \"hphp/runtime/ext/collections/ext_collections-vector.h\"\n#include \"hphp/runtime/ext/std/ext_std_function.h\"\n#include \"hphp/runtime/vm/jit/translator.h\"\n#include \"hphp/runtime/vm/jit/translator-inline.h\"\n#include \"hphp/util/logger.h\"\n\n#include <vector>\n\nnamespace HPHP {\n///////////////////////////////////////////////////////////////////////////////\n\n#define SORT_DESC               3\n#define SORT_ASC                4\n\nconst StaticString s_count(\"count\");\n\nenum class CaseMode {\n  LOWER = 0,\n  UPPER = 1,\n};\n\nTypedValue HHVM_FUNCTION(array_change_key_case,\n                         ArrayArg input,\n                         int64_t case_ /* = 0 */) {\n  return tvReturn(ArrayUtil::ChangeKeyCase(ArrNR(input.get()),\n                                           (CaseMode)case_ == CaseMode::LOWER));\n}\n\nTypedValue HHVM_FUNCTION(array_chunk,\n                         const Variant& input,\n                         int chunkSize,\n                         bool preserve_keys /* = false */) {\n  const auto& cellInput = *input.asCell();\n  if (UNLIKELY(!isContainer(cellInput))) {\n    raise_warning(\"Invalid operand type was used: %s expects \"\n                  \"an array or collection as argument 1\", __FUNCTION__+2);\n    return make_tv<KindOfNull>();\n  }\n\n  if (chunkSize < 1) {\n    throw_invalid_argument(\"size: %d\", chunkSize);\n    return make_tv<KindOfNull>();\n  }\n\n  auto const retSize = (getContainerSize(cellInput) / chunkSize) + 1;\n  PackedArrayInit ret(retSize);\n  Array chunk;\n  int current = 0;\n  for (ArrayIter iter(cellInput); iter; ++iter) {\n    if (preserve_keys) {\n      chunk.setWithRef(iter.first(), iter.secondRefPlus(), true);\n    } else {\n      chunk.appendWithRef(iter.secondRefPlus());\n    }\n    if ((++current % chunkSize) == 0) {\n      ret.append(chunk);\n      chunk.clear();\n    }\n  }\n  if (!chunk.empty()) {\n    ret.append(chunk);\n  }\n\n  return tvReturn(ret.toVariant());\n}\n\nstatic inline bool array_column_coerce_key(Variant &key, const char *name) {\n  /* NULL has a special meaning for each field */\n  if (key.isNull()) {\n    return true;\n  }\n\n  /* Custom coercion rules for key types */\n  if (key.isInteger() || key.isDouble()) {\n    key = key.toInt64();\n    return true;\n  } else if (key.isString() || key.isObject()) {\n    key = key.toString();\n    return true;\n  } else {\n    raise_warning(\"array_column(): The %s key should be either a string \"\n                  \"or an integer\", name);\n    return false;\n  }\n}\n\nTypedValue HHVM_FUNCTION(array_column,\n                         ArrayArg input,\n                         const Variant& val_key,\n                         const Variant& idx_key /* = null_variant */) {\n\n  ArrNR arr_input(input.get());\n  Variant val = val_key, idx = idx_key;\n  if (!array_column_coerce_key(val, \"column\") ||\n      !array_column_coerce_key(idx, \"index\")) {\n    return make_tv<KindOfBoolean>(false);\n  }\n  ArrayInit ret(input->size(), ArrayInit::Map{});\n  for(auto it = arr_input.asArray().begin(); !it.end(); it.next()) {\n    if (!it.second().isArray()) {\n      continue;\n    }\n    Array sub = it.second().toArray();\n\n    Variant elem;\n    if (val.isNull()) {\n      elem = sub;\n    } else if (sub.exists(val)) {\n      elem = sub[val];\n    } else {\n      // skip subarray without named element\n      continue;\n    }\n\n    if (idx.isNull() || !sub.exists(idx)) {\n      ret.append(elem);\n    } else if (sub[idx].isObject()) {\n      ret.setUnknownKey(sub[idx].toString(), elem);\n    } else {\n      ret.setUnknownKey(sub[idx], elem);\n    }\n  }\n  return tvReturn(ret.toVariant());\n}\n\nTypedValue HHVM_FUNCTION(array_combine,\n                         const Variant& keys,\n                         const Variant& values) {\n  const auto& cell_keys = *keys.asCell();\n  const auto& cell_values = *values.asCell();\n  if (UNLIKELY(!isContainer(cell_keys) || !isContainer(cell_values))) {\n    raise_warning(\"Invalid operand type was used: array_combine expects \"\n                  \"arrays or collections\");\n    return make_tv<KindOfNull>();\n  }\n  auto keys_size = getContainerSize(cell_keys);\n  if (UNLIKELY(keys_size != getContainerSize(cell_values))) {\n    raise_warning(\"array_combine(): Both parameters should have an equal \"\n                  \"number of elements\");\n    return make_tv<KindOfBoolean>(false);\n  }\n  Array ret = Array::attach(MixedArray::MakeReserveMixed(keys_size));\n  for (ArrayIter iter1(cell_keys), iter2(cell_values);\n       iter1; ++iter1, ++iter2) {\n    const Variant& key = iter1.secondRefPlus();\n    if (key.isInteger() || key.isString()) {\n      ret.setWithRef(key, iter2.secondRefPlus());\n    } else {\n      ret.setWithRef(key.toString(), iter2.secondRefPlus());\n    }\n  }\n  return tvReturn(std::move(ret));\n}\n\nTypedValue HHVM_FUNCTION(array_count_values,\n                         ArrayArg input) {\n  return tvReturn(ArrayUtil::CountValues(ArrNR(input.get())));\n}\n\nTypedValue HHVM_FUNCTION(array_fill_keys,\n                         const Variant& keys,\n                         const Variant& value) {\n  folly::Optional<ArrayInit> ai;\n  auto ok = IterateV(*keys.asCell(),\n                     [&](ArrayData* adata) {\n                       ai.emplace(adata->size(), ArrayInit::Mixed{});\n                     },\n                     [&](const TypedValue* tv) {\n                       auto& key = tvAsCVarRef(tv);\n                       if (key.isInteger() || key.isString()) {\n                         ai->setUnknownKey(key, value);\n                       } else {\n                         raise_hack_strict(RuntimeOption::StrictArrayFillKeys,\n                                           \"strict_array_fill_keys\",\n                                           \"keys must be ints or strings\");\n                         ai->setUnknownKey(key.toString(), value);\n                       }\n                     },\n                     [&](ObjectData* coll) {\n                       if (coll->collectionType() == CollectionType::Pair) {\n                         ai.emplace(2, ArrayInit::Mixed{});\n                       }\n                     });\n\n  if (!ok) {\n    raise_warning(\"Invalid operand type was used: array_fill_keys expects \"\n                  \"an array or collection\");\n    return make_tv<KindOfNull>();\n  }\n  assert(ai.hasValue());\n  return tvReturn(ai->toVariant());\n}\n\nTypedValue HHVM_FUNCTION(array_fill,\n                         int start_index,\n                         int num,\n                         const Variant& value) {\n  if (num < 0) {\n    throw_invalid_argument(\"Number of elements can't be negative\");\n    return make_tv<KindOfBoolean>(false);\n  }\n\n  if (start_index == 0) {\n    PackedArrayInit pai(num, CheckAllocation{});\n    for (size_t k = 0; k < num; k++) {\n      pai.append(value);\n    }\n    return tvReturn(pai.toVariant());\n  } else {\n    ArrayInit ret(num, ArrayInit::Mixed{}, CheckAllocation{});\n    ret.set(start_index, value);\n    for (int i = num - 1; i > 0; i--) {\n      ret.append(value);\n    }\n    return tvReturn(ret.toVariant());\n  }\n}\n\nTypedValue HHVM_FUNCTION(array_flip,\n                         const Variant& trans) {\n  auto const& transCell = *trans.asCell();\n  if (UNLIKELY(!isContainer(transCell))) {\n    raise_warning(\"Invalid operand type was used: %s expects \"\n                  \"an array or collection\", __FUNCTION__+2);\n    return make_tv<KindOfNull>();\n  }\n\n  ArrayInit ret(getContainerSize(transCell), ArrayInit::Mixed{});\n  for (ArrayIter iter(transCell); iter; ++iter) {\n    const Variant& value(iter.secondRefPlus());\n    if (value.isString() || value.isInteger()) {\n      ret.setUnknownKey(value, iter.first());\n    } else {\n      raise_warning(\"Can only flip STRING and INTEGER values!\");\n    }\n  }\n  return tvReturn(ret.toVariant());\n}\n\nbool HHVM_FUNCTION(array_key_exists,\n                   const Variant& key,\n                   const Variant& search) {\n  const ArrayData *ad;\n\n  auto const searchCell = search.asCell();\n  if (LIKELY(isArrayType(searchCell->m_type))) {\n    ad = searchCell->m_data.parr;\n  } else if (searchCell->m_type == KindOfObject) {\n    ObjectData* obj = searchCell->m_data.pobj;\n    if (obj->isCollection()) {\n      return collections::contains(obj, key);\n    }\n    return HHVM_FN(array_key_exists)(key, toArray(search));\n  } else {\n    throw_bad_type_exception(\"array_key_exists expects an array or an object; \"\n                             \"false returned.\");\n    return false;\n  }\n\n  auto const cell = key.asCell();\n\n  switch (cell->m_type) {\n    case KindOfUninit:\n    case KindOfNull:\n      return ad->useWeakKeys() && ad->exists(staticEmptyString());\n\n    case KindOfBoolean:\n    case KindOfDouble:\n    case KindOfPersistentArray:\n    case KindOfArray:\n    case KindOfObject:\n    case KindOfResource:\n      if (!ad->useWeakKeys()) throwInvalidArrayKeyException(cell, ad);\n      raise_warning(\"Array key should be either a string or an integer\");\n      return false;\n\n    case KindOfPersistentString:\n    case KindOfString: {\n      int64_t n = 0;\n      if (ad->convertKey(cell->m_data.pstr, n)) {\n        return ad->exists(n);\n      }\n      return ad->exists(StrNR(cell->m_data.pstr));\n    }\n    case KindOfInt64:\n      return ad->exists(cell->m_data.num);\n    case KindOfRef:\n    case KindOfClass:\n      break;\n  }\n  not_reached();\n}\n\nbool HHVM_FUNCTION(key_exists,\n                   const Variant& key,\n                   const Variant& search) {\n  return HHVM_FN(array_key_exists)(key, search);\n}\n\nVariant array_keys_helper(const Variant& input,\n                          const Variant& search_value /* = uninit_null */,\n                          bool strict /* = false */) {\n  const auto& cell_input = *input.asCell();\n  if (UNLIKELY(!isContainer(cell_input))) {\n    raise_warning(\"array_keys() expects parameter 1 to be an array \"\n                  \"or collection\");\n    return init_null();\n  }\n\n  if (LIKELY(!search_value.isInitialized())) {\n    PackedArrayInit ai(getContainerSize(cell_input));\n    for (ArrayIter iter(cell_input); iter; ++iter) {\n      ai.append(iter.first());\n    }\n    return ai.toVariant();\n  } else {\n    Array ai = Array::attach(PackedArray::MakeReserve(0));\n    for (ArrayIter iter(cell_input); iter; ++iter) {\n      if ((strict && HPHP::same(iter.secondRefPlus(), search_value)) ||\n          (!strict && HPHP::equal(iter.secondRefPlus(), search_value))) {\n        ai.append(iter.first());\n      }\n    }\n    return ai;\n  }\n}\n\nstatic\nVariant HHVM_FUNCTION(array_keys, int64_t argc,\n                                  const Variant& input,\n                                  const Variant& search_value /*=null*/,\n                                  bool strict /*=false*/) {\n  return array_keys_helper(\n    input,\n    argc < 2 ? null_variant : search_value,\n    strict\n  );\n}\n\nstatic void php_array_merge(Array &arr1, const Array& arr2) {\n  arr1.merge(arr2);\n}\n\nstatic bool couldRecur(const Variant& v, const ArrayData* arr) {\n  return v.isReferenced() ||\n    arr->kind() == ArrayData::kGlobalsKind ||\n    arr->kind() == ArrayData::kProxyKind;\n}\n\nstatic void php_array_merge_recursive(PointerSet &seen, bool check,\n                                      Array &arr1, const Array& arr2) {\n  if (check && !seen.insert((void*)arr1.get()).second) {\n    raise_warning(\"array_merge_recursive(): recursion detected\");\n    return;\n  }\n\n  for (ArrayIter iter(arr2); iter; ++iter) {\n    Variant key(iter.first());\n    const Variant& value(iter.secondRef());\n    if (key.isNumeric()) {\n      arr1.appendWithRef(value);\n    } else if (arr1.exists(key, true)) {\n      // There is no need to do toKey() conversion, for a key that is already\n      // in the array.\n      Variant &v = arr1.lvalAt(key, AccessFlags::Key);\n      auto subarr1 = v.toArray().copy();\n      php_array_merge_recursive(seen,\n                                couldRecur(v, subarr1.get()),\n                                subarr1,\n                                value.toArray());\n      v.unset(); // avoid contamination of the value that was strongly bound\n      v = subarr1;\n    } else {\n      arr1.setWithRef(key, value, true);\n    }\n  }\n\n  if (check) {\n    seen.erase((void*)arr1.get());\n  }\n}\n\nTypedValue HHVM_FUNCTION(array_map,\n                         const Variant& callback,\n                         const Variant& arr1,\n                         const Array& _argv) {\n  VMRegGuard _;\n  CallCtx ctx;\n  ctx.func = nullptr;\n  if (!callback.isNull()) {\n    CallerFrame cf;\n    vm_decode_function(callback, cf(), false, ctx);\n  }\n  const auto& cell_arr1 = *arr1.asCell();\n  if (UNLIKELY(!isContainer(cell_arr1))) {\n    raise_warning(\"array_map(): Argument #2 should be an array or collection\");\n    return make_tv<KindOfNull>();\n  }\n  if (LIKELY(_argv.empty())) {\n    // Handle the common case where the caller passed two\n    // params (a callback and a container)\n    if (!ctx.func) {\n      if (isArrayType(cell_arr1.m_type)) {\n        return tvReturn(arr1);\n      } else {\n        return tvReturn(arr1.toArray());\n      }\n    }\n    ArrayInit ret(getContainerSize(cell_arr1), ArrayInit::Map{});\n    bool keyConverted = isArrayType(cell_arr1.m_type);\n    if (!keyConverted) {\n      auto col_type = cell_arr1.m_data.pobj->collectionType();\n      keyConverted = !collectionAllowsIntStringKeys(col_type);\n    }\n    for (ArrayIter iter(arr1); iter; ++iter) {\n      Variant result;\n      g_context->invokeFuncFew((TypedValue*)&result, ctx, 1,\n                               iter.secondRefPlus().asCell());\n      // if keyConverted is false, it's possible that ret will have fewer\n      // elements than cell_arr1; keys int(1) and string('1') may both be\n      // present\n      ret.add(iter.first(), result, keyConverted);\n    }\n    return tvReturn(ret.toVariant());\n  }\n\n  // Handle the uncommon case where the caller passed a callback\n  // and two or more containers\n  req::vector<ArrayIter> iters;\n  iters.reserve(_argv.size() + 1);\n  size_t maxLen = getContainerSize(cell_arr1);\n  iters.emplace_back(cell_arr1);\n  for (ArrayIter it(_argv); it; ++it) {\n    const auto& c = *it.secondRefPlus().asCell();\n    if (UNLIKELY(!isContainer(c))) {\n      raise_warning(\"array_map(): Argument #%d should be an array or \"\n                    \"collection\", (int)(iters.size() + 2));\n      iters.emplace_back(it.secondRefPlus().toArray());\n    } else {\n      iters.emplace_back(c);\n      size_t len = getContainerSize(c);\n      if (len > maxLen) maxLen = len;\n    }\n  }\n  PackedArrayInit ret_ai(maxLen);\n  for (size_t k = 0; k < maxLen; k++) {\n    PackedArrayInit params_ai(iters.size());\n    for (auto& iter : iters) {\n      if (iter) {\n        params_ai.append(iter.secondRefPlus());\n        ++iter;\n      } else {\n        params_ai.append(init_null_variant);\n      }\n    }\n    Array params = params_ai.toArray();\n    if (ctx.func) {\n      Variant result;\n      g_context->invokeFunc((TypedValue*)&result,\n                              ctx.func, params, ctx.this_,\n                              ctx.cls, nullptr, ctx.invName);\n      ret_ai.append(result);\n    } else {\n      ret_ai.append(params);\n    }\n  }\n  return tvReturn(ret_ai.toVariant());\n}\n\nTypedValue HHVM_FUNCTION(array_merge,\n                         int64_t numArgs,\n                         ArrayArg array1,\n                         const Variant& array2 /* = null_variant */,\n                         const Array& args /* = null array */) {\n  Array ret = Array::attach(MixedArray::MakeReserveLike(array1.get(), 0));\n  php_array_merge(ret, ArrNR(array1.get()));\n\n  if (UNLIKELY(numArgs < 2)) return tvReturn(std::move(ret));\n\n  getCheckedArrayRet(array2, make_tv<KindOfNull>());\n  php_array_merge(ret, arr_array2);\n\n  for (ArrayIter iter(args); iter; ++iter) {\n    Variant v = iter.second();\n    if (!v.isArray()) {\n      throw_expected_array_exception(\"array_merge\");\n      return make_tv<KindOfNull>();\n    }\n    const Array& arr_v = v.asCArrRef();\n    php_array_merge(ret, arr_v);\n  }\n  return tvReturn(std::move(ret));\n}\n\nTypedValue HHVM_FUNCTION(array_merge_recursive,\n                         int64_t numArgs,\n                         const Variant& array1,\n                         const Variant& array2 /* = null_variant */,\n                         const Array& args /* = null array */) {\n  getCheckedArray(array1);\n  auto in1 = array1.asCArrRef();\n  auto ret = Array::attach(MixedArray::MakeReserveLike(in1.get(), 0));\n  PointerSet seen;\n  php_array_merge_recursive(seen, false, ret, arr_array1);\n  assert(seen.empty());\n\n  if (UNLIKELY(numArgs < 2)) return tvReturn(std::move(ret));\n\n  getCheckedArray(array2);\n  php_array_merge_recursive(seen, false, ret, arr_array2);\n  assert(seen.empty());\n\n  for (ArrayIter iter(args); iter; ++iter) {\n    Variant v = iter.second();\n    if (!v.isArray()) {\n      throw_expected_array_exception(\"array_merge_recursive\");\n      return make_tv<KindOfNull>();\n    }\n    const Array& arr_v = v.asCArrRef();\n    php_array_merge_recursive(seen, false, ret, arr_v);\n    assert(seen.empty());\n  }\n  return tvReturn(std::move(ret));\n}\n\nstatic void php_array_replace(Array &arr1, const Array& arr2) {\n  for (ArrayIter iter(arr2); iter; ++iter) {\n    Variant key = iter.first();\n    const Variant& value = iter.secondRef();\n    arr1.setWithRef(key, value, true);\n  }\n}\n\nstatic void php_array_replace_recursive(PointerSet &seen, bool check,\n                                        Array &arr1, const Array& arr2) {\n  if (arr1.get() == arr2.get()) {\n    // This is an optimization, but it also avoids an assert in\n    // setWithRef (Variant::setWithRef asserts that its source\n    // and destination are not the same).\n    // If the arrays are self recursive, this does change the behavior\n    // slightly - it skips the \"recursion detected\" warning.\n    return;\n  }\n\n  if (check && !seen.insert((void*)arr1.get()).second) {\n    raise_warning(\"array_replace_recursive(): recursion detected\");\n    return;\n  }\n\n  for (ArrayIter iter(arr2); iter; ++iter) {\n    Variant key = iter.first();\n    const Variant& value = iter.secondRef();\n    if (arr1.exists(key, true) && value.isArray()) {\n      Variant &v = arr1.lvalAt(key, AccessFlags::Key);\n      if (v.isArray()) {\n        Array subarr1 = v.toArray();\n        const ArrNR& arr_value = value.toArrNR();\n        php_array_replace_recursive(seen, couldRecur(v, subarr1.get()),\n                                    subarr1, arr_value);\n        v = subarr1;\n      } else {\n        arr1.set(key, value, true);\n      }\n    } else {\n      arr1.setWithRef(key, value, true);\n    }\n  }\n\n  if (check) {\n    seen.erase((void*)arr1.get());\n  }\n}\n\nTypedValue HHVM_FUNCTION(array_replace,\n                         const Variant& array1,\n                         const Variant& array2 /* = null_variant */,\n                         const Array& args /* = null array */) {\n  getCheckedArray(array1);\n  Array ret = Array::Create();\n  php_array_replace(ret, arr_array1);\n\n  if (UNLIKELY(array2.isNull() && args.empty())) {\n    return tvReturn(std::move(ret));\n  }\n\n  getCheckedArray(array2);\n  php_array_replace(ret, arr_array2);\n\n  for (ArrayIter iter(args); iter; ++iter) {\n    const Variant& v = iter.secondRef();\n    getCheckedArray(v);\n    php_array_replace(ret, arr_v);\n  }\n  return tvReturn(std::move(ret));\n}\n\nTypedValue HHVM_FUNCTION(array_replace_recursive,\n                         const Variant& array1,\n                         const Variant& array2 /* = null_variant */,\n                         const Array& args /* = null array */) {\n  getCheckedArray(array1);\n  Array ret = Array::Create();\n  PointerSet seen;\n  php_array_replace_recursive(seen, false, ret, arr_array1);\n  assert(seen.empty());\n\n  if (UNLIKELY(array2.isNull() && args.empty())) {\n    return tvReturn(std::move(ret));\n  }\n\n  getCheckedArray(array2);\n  php_array_replace_recursive(seen, false, ret, arr_array2);\n  assert(seen.empty());\n\n  for (ArrayIter iter(args); iter; ++iter) {\n    const Variant& v = iter.secondRef();\n    getCheckedArray(v);\n    php_array_replace_recursive(seen, false, ret, arr_v);\n    assert(seen.empty());\n  }\n  return tvReturn(std::move(ret));\n}\n\nTypedValue HHVM_FUNCTION(array_pad,\n                         const Variant& input,\n                         int pad_size,\n                         const Variant& pad_value) {\n  getCheckedArray(input);\n  if (pad_size > 0) {\n    return tvReturn(ArrayUtil::Pad(arr_input, pad_value, pad_size, true));\n  }\n  return tvReturn(ArrayUtil::Pad(arr_input, pad_value, -pad_size, false));\n}\n\nTypedValue HHVM_FUNCTION(array_pop,\n                         VRefParam containerRef) {\n  const auto* container = containerRef->asCell();\n  if (UNLIKELY(!isMutableContainer(*container))) {\n    raise_warning(\"array_pop() expects parameter 1 to be an \"\n                  \"array or mutable collection\");\n    return make_tv<KindOfNull>();\n  }\n  if (!getContainerSize(containerRef)) {\n    return make_tv<KindOfNull>();\n  }\n  if (isArrayType(container->m_type)) {\n    if (auto ref = containerRef.getVariantOrNull()) {\n      return tvReturn(ref->asArrRef().pop());\n    }\n    auto ad = container->m_data.parr;\n    if (ad->size()) {\n      auto last = ad->iter_last();\n      return tvReturn(ad->getValue(last));\n    }\n    return make_tv<KindOfNull>();\n  }\n  assert(container->m_type == KindOfObject);\n  return tvReturn(collections::pop(container->m_data.pobj));\n}\n\nTypedValue HHVM_FUNCTION(array_product,\n                         const Variant& input) {\n  if (UNLIKELY(!isContainer(input))) {\n    raise_warning(\"Invalid operand type was used: %s expects \"\n                  \"an array or collection as argument 1\",\n                  __FUNCTION__+2);\n    return make_tv<KindOfNull>();\n  }\n\n  int64_t i = 1;\n  ArrayIter iter(input);\n  for (; iter; ++iter) {\n    const Variant& entry(iter.secondRefPlus());\n\n    switch (entry.getType()) {\n      case KindOfUninit:\n      case KindOfNull:\n      case KindOfBoolean:\n      case KindOfInt64:\n      case KindOfRef:\n        i *= entry.toInt64();\n        continue;\n\n      case KindOfDouble:\n        goto DOUBLE;\n\n      case KindOfPersistentString:\n      case KindOfString: {\n        int64_t ti;\n        double td;\n        if (entry.getStringData()->isNumericWithVal(ti, td, 1) ==\n            KindOfInt64) {\n          i *= ti;\n          continue;\n        } else {\n          goto DOUBLE;\n        }\n      }\n\n      case KindOfPersistentArray:\n      case KindOfArray:\n      case KindOfObject:\n      case KindOfResource:\n        continue;\n\n      case KindOfClass:\n        break;\n    }\n    not_reached();\n  }\n  return make_tv<KindOfInt64>(i);\n\nDOUBLE:\n  double d = i;\n  for (; iter; ++iter) {\n    const Variant& entry(iter.secondRefPlus());\n    switch (entry.getType()) {\n      DT_UNCOUNTED_CASE:\n      case KindOfString:\n      case KindOfRef:\n        d *= entry.toDouble();\n\n      case KindOfArray:\n      case KindOfObject:\n      case KindOfResource:\n        continue;\n\n      case KindOfClass:\n        break;\n    }\n    not_reached();\n  }\n  return make_tv<KindOfDouble>(d);\n}\n\nTypedValue HHVM_FUNCTION(array_push,\n                         VRefParam container,\n                         const Variant& var,\n                         const Array& args /* = null array */) {\n  if (LIKELY(container->isArray())) {\n    auto ref = container.getVariantOrNull();\n    if (!ref) {\n      return make_tv<KindOfInt64>(\n        1 + args.size() + container->asCArrRef().size()\n      );\n    }\n\n    /*\n     * Important note: this *must* cast the parr in the inner cell to\n     * the Array&---we can't copy it to the stack or anything because we\n     * might escalate.\n     */\n    Array& arr_array = ref->asArrRef();\n    arr_array.append(var);\n    for (ArrayIter iter(args); iter; ++iter) {\n      arr_array.append(iter.second());\n    }\n    return make_tv<KindOfInt64>(arr_array.size());\n  }\n\n  if (container.isObject()) {\n    ObjectData* obj = container.getObjectData();\n    if (obj->isCollection()) {\n      switch (obj->collectionType()) {\n        case CollectionType::Vector: {\n          c_Vector* vec = static_cast<c_Vector*>(obj);\n          vec->reserve(vec->size() + args.size() + 1);\n          vec->add(var);\n          for (ArrayIter iter(args); iter; ++iter) {\n            vec->add(iter.second());\n          }\n          return make_tv<KindOfInt64>(vec->size());\n        }\n        case CollectionType::Set: {\n          c_Set* set = static_cast<c_Set*>(obj);\n          set->reserve(set->size() + args.size() + 1);\n          set->add(var);\n          for (ArrayIter iter(args); iter; ++iter) {\n            set->add(iter.second());\n          }\n          return make_tv<KindOfInt64>(set->size());\n        }\n        case CollectionType::Map:\n        case CollectionType::Pair:\n        case CollectionType::ImmVector:\n        case CollectionType::ImmMap:\n        case CollectionType::ImmSet:\n          // other collection types are unsupported:\n          //  - mapping collections require a key\n          //  - immutable collections don't allow insertion\n          break;\n      }\n    }\n  }\n  throw_expected_array_or_collection_exception(\"array_push\");\n  return make_tv<KindOfNull>();\n}\n\nTypedValue HHVM_FUNCTION(array_rand,\n                         const Variant& input,\n                         int num_req /* = 1 */) {\n  getCheckedArray(input);\n  return tvReturn(ArrayUtil::RandomKeys(arr_input, num_req));\n}\n\nTypedValue HHVM_FUNCTION(array_reverse,\n                         ArrayArg input,\n                         bool preserve_keys /* = false */) {\n\n  ArrNR arrNR(input.get());\n  const Array& arr = arrNR.asArray();\n  return tvReturn(ArrayUtil::Reverse(arr, preserve_keys));\n}\n\nTypedValue HHVM_FUNCTION(array_shift,\n                         VRefParam array) {\n  const auto* cell_array = array->asCell();\n  if (UNLIKELY(!isMutableContainer(*cell_array))) {\n    raise_warning(\"array_shift() expects parameter 1 to be an \"\n                  \"array or mutable collection\");\n    return make_tv<KindOfNull>();\n  }\n  if (!getContainerSize(array)) {\n    return make_tv<KindOfNull>();\n  }\n  if (isArrayType(cell_array->m_type)) {\n    if (auto ref = array.getVariantOrNull()) {\n      return tvReturn(ref->asArrRef().dequeue());\n    }\n    auto ad = cell_array->m_data.parr;\n    if (ad->size()) {\n      auto first = ad->iter_begin();\n      return tvReturn(ad->getValue(first));\n    }\n    return make_tv<KindOfNull>();\n  }\n  assertx(cell_array->m_type == KindOfObject);\n  return tvReturn(collections::shift(cell_array->m_data.pobj));\n}\n\nTypedValue HHVM_FUNCTION(array_slice,\n                         TypedValue cell_input,\n                         int64_t offset,\n                         const Variant& length /* = null_variant */,\n                         bool preserve_keys /* = false */) {\n  if (UNLIKELY(!isContainer(cell_input))) {\n    raise_warning(\"Invalid operand type was used: %s expects \"\n                  \"an array or collection as argument 1\",\n                  __FUNCTION__+2);\n    return make_tv<KindOfNull>();\n  }\n  int64_t len = length.isNull() ? 0x7FFFFFFF : length.toInt64();\n\n  const int64_t num_in = getContainerSize(cell_input);\n  if (offset > num_in) {\n    offset = num_in;\n  } else if (offset < 0 && (offset = (num_in + offset)) < 0) {\n    offset = 0;\n  }\n\n  auto const maxLen = num_in - offset;\n  if (len < 0) {\n    len = maxLen + len;\n  } else if (len > maxLen) {\n    len = maxLen;\n  }\n\n  if (len <= 0) {\n    return make_tv<KindOfPersistentArray>(staticEmptyArray());\n  }\n\n  bool input_is_packed = isPackedContainer(cell_input);\n\n  // If the slice covers the entire input container, we can just nop when\n  // preserve_keys is true, or when preserve_keys is false but the container\n  // is packed so we know the keys already map to [0,N].\n  if (offset == 0 && len == num_in && (preserve_keys || input_is_packed)) {\n    if (isArrayType(cell_input.m_type)) {\n      return tvReturn(Variant(cell_input.m_data.parr));\n    }\n    return tvReturn(cell_input.m_data.pobj->toArray());\n  }\n\n  int pos = 0;\n  ArrayIter iter(cell_input);\n  for (; pos < offset && iter; ++pos, ++iter) {}\n\n  if (input_is_packed && (offset == 0 || !preserve_keys)) {\n    PackedArrayInit ret(len);\n    for (; pos < (offset + len) && iter; ++pos, ++iter) {\n      ret.appendWithRef(iter.secondRefPlus());\n    }\n    return tvReturn(ret.toVariant());\n  }\n\n  // Otherwise PackedArrayInit can't be used because non-numeric keys are\n  // preserved even when preserve_keys is false\n  Array ret = Array::attach(PackedArray::MakeReserve(len));\n  for (; pos < (offset + len) && iter; ++pos, ++iter) {\n    Variant key(iter.first());\n    bool doAppend = !preserve_keys && key.isNumeric();\n    const Variant& v = iter.secondRefPlus();\n    if (doAppend) {\n      ret.appendWithRef(v);\n    } else {\n      ret.setWithRef(key, v, true);\n    }\n  }\n  return tvReturn(std::move(ret));\n}\n\nVariant array_splice(VRefParam input, int offset,\n                     const Variant& length, const Variant& replacement) {\n  getCheckedArrayVariant(input);\n  Array ret(Array::Create());\n  int64_t len = length.isNull() ? 0x7FFFFFFF : length.toInt64();\n  input.assignIfRef(ArrayUtil::Splice(arr_input, offset, len, replacement, &ret));\n  return ret;\n}\n\nTypedValue HHVM_FUNCTION(array_splice,\n                         VRefParam input,\n                         int offset,\n                         const Variant& length,\n                         const Variant& replacement) {\n  return tvReturn(array_splice(input, offset, length, replacement));\n}\n\nTypedValue HHVM_FUNCTION(array_sum,\n                         const Variant& input) {\n  if (UNLIKELY(!isContainer(input))) {\n    raise_warning(\"Invalid operand type was used: %s expects \"\n                  \"an array or collection as argument 1\",\n                  __FUNCTION__+2);\n    return make_tv<KindOfNull>();\n  }\n\n  int64_t i = 0;\n  ArrayIter iter(input);\n  for (; iter; ++iter) {\n    const Variant& entry(iter.secondRefPlus());\n\n    switch (entry.getType()) {\n      case KindOfUninit:\n      case KindOfNull:\n      case KindOfBoolean:\n      case KindOfInt64:\n      case KindOfRef:\n        i += entry.toInt64();\n        continue;\n\n      case KindOfDouble:\n        goto DOUBLE;\n\n      case KindOfPersistentString:\n      case KindOfString: {\n        int64_t ti;\n        double td;\n        if (entry.getStringData()->isNumericWithVal(ti, td, 1) ==\n            KindOfInt64) {\n          i += ti;\n          continue;\n        } else {\n          goto DOUBLE;\n        }\n      }\n\n      case KindOfPersistentArray:\n      case KindOfArray:\n      case KindOfObject:\n      case KindOfResource:\n        continue;\n\n      case KindOfClass:\n        break;\n    }\n    not_reached();\n  }\n  return make_tv<KindOfInt64>(i);\n\nDOUBLE:\n  double d = i;\n  for (; iter; ++iter) {\n    const Variant& entry(iter.secondRefPlus());\n    switch (entry.getType()) {\n      DT_UNCOUNTED_CASE:\n      case KindOfString:\n      case KindOfRef:\n        d += entry.toDouble();\n\n      case KindOfArray:\n      case KindOfObject:\n      case KindOfResource:\n        continue;\n\n      case KindOfClass:\n        break;\n    }\n    not_reached();\n  }\n  return make_tv<KindOfDouble>(d);\n}\n\nTypedValue HHVM_FUNCTION(array_unshift,\n                         VRefParam array,\n                         const Variant& var,\n                         const Array& args /* = null array */) {\n  const auto* cell_array = array->asCell();\n  if (UNLIKELY(!isContainer(*cell_array))) {\n    raise_warning(\"%s() expects parameter 1 to be an array, Vector, or Set\",\n                  __FUNCTION__+2 /* remove the \"f_\" prefix */);\n    return make_tv<KindOfNull>();\n  }\n  if (isArrayType(cell_array->m_type)) {\n    auto ref_array = array.getVariantOrNull();\n    if (!ref_array) {\n      return make_tv<KindOfInt64>(\n        cell_array->m_data.parr->size() + args.size() + 1\n      );\n    }\n    if (cell_array->m_data.parr->isVectorData()) {\n      if (!args.empty()) {\n        auto pos_limit = args->iter_end();\n        for (ssize_t pos = args->iter_last(); pos != pos_limit;\n             pos = args->iter_rewind(pos)) {\n          ref_array->asArrRef().prepend(args->getValueRef(pos));\n        }\n      }\n      ref_array->asArrRef().prepend(var);\n    } else {\n      {\n        Array newArray;\n        newArray.append(var);\n        if (!args.empty()) {\n          auto pos_limit = args->iter_end();\n          for (ssize_t pos = args->iter_begin(); pos != pos_limit;\n               pos = args->iter_advance(pos)) {\n            newArray.append(args->getValueRef(pos));\n          }\n        }\n        for (ArrayIter iter(array.toArray()); iter; ++iter) {\n          Variant key(iter.first());\n          const Variant& value(iter.secondRef());\n          if (key.isInteger()) {\n            newArray.appendWithRef(value);\n          } else {\n            newArray.setWithRef(key, value, true);\n          }\n        }\n        *ref_array = std::move(newArray);\n      }\n      // Reset the array's internal pointer\n      ref_array->asArrRef()->reset();\n    }\n    return make_tv<KindOfInt64>(ref_array->asArrRef().size());\n  }\n  // Handle collections\n  assert(cell_array->m_type == KindOfObject);\n  auto* obj = cell_array->m_data.pobj;\n  assert(obj->isCollection());\n  switch (obj->collectionType()) {\n    case CollectionType::Vector: {\n      auto* vec = static_cast<c_Vector*>(obj);\n      if (!args.empty()) {\n        auto pos_limit = args->iter_end();\n        for (ssize_t pos = args->iter_last(); pos != pos_limit;\n             pos = args->iter_rewind(pos)) {\n          vec->addFront(args->getValueRef(pos).asCell());\n        }\n      }\n      vec->addFront(var.asCell());\n      return make_tv<KindOfInt64>(vec->size());\n    }\n    case CollectionType::Set: {\n      auto* st = static_cast<c_Set*>(obj);\n      if (!args.empty()) {\n        auto pos_limit = args->iter_end();\n        for (ssize_t pos = args->iter_last(); pos != pos_limit;\n             pos = args->iter_rewind(pos)) {\n          st->addFront(args->getValueRef(pos).asCell());\n        }\n      }\n      st->addFront(var.asCell());\n      return make_tv<KindOfInt64>(st->size());\n    }\n    case CollectionType::Map:\n    case CollectionType::Pair:\n    case CollectionType::ImmVector:\n    case CollectionType::ImmMap:\n    case CollectionType::ImmSet:\n      break;\n  }\n  raise_warning(\"%s() expects parameter 1 to be an array, Vector, or Set\",\n                __FUNCTION__+2 /* remove the \"f_\" prefix */);\n  return make_tv<KindOfNull>();\n}\n\nVariant array_values(const Variant& input) {\n  if (input.isArray() && input.asCArrRef()->isVecArray()) {\n    return input;\n  }\n\n  folly::Optional<PackedArrayInit> ai;\n  auto ok = IterateV(*input.asCell(),\n                     [&](ArrayData* adata) {\n                       ai.emplace(adata->size());\n                     },\n                     [&](const TypedValue* tv) {\n                       ai->appendWithRef(tvAsCVarRef(tv));\n                     },\n                     [&](ObjectData* coll) {\n                       if (coll->collectionType() == CollectionType::Pair) {\n                         ai.emplace(2);\n                       }\n                     });\n\n  if (!ok) {\n    raise_warning(\"array_values() expects parameter 1 to be an array \"\n                  \"or collection\");\n    return init_null();\n  }\n\n  assert(ai.hasValue());\n  return ai->toVariant();\n}\n\nTypedValue HHVM_FUNCTION(array_values,\n                         const Variant& input) {\n  return tvReturn(array_values(input));\n}\n\nstatic void walk_func(Variant& value,\n                      const Variant& key,\n                      const Variant& userdata,\n                      const void *data) {\n  CallCtx* ctx = (CallCtx*)data;\n  Variant sink;\n  int nargs = userdata.isInitialized() ? 3 : 2;\n  TypedValue args[3] = { *value.asRef(), *key.asCell(), *userdata.asCell() };\n  g_context->invokeFuncFew(sink.asTypedValue(), *ctx, nargs, args);\n}\n\nbool HHVM_FUNCTION(array_walk_recursive,\n                   VRefParam input,\n                   const Variant& funcname,\n                   const Variant& userdata /* = null_variant */) {\n  if (!input.isArray()) {\n    throw_expected_array_exception(\"array_walk_recursive\");\n    return false;\n  }\n  CallCtx ctx;\n  CallerFrame cf;\n  vm_decode_function(funcname, cf(), false, ctx);\n  if (ctx.func == NULL) {\n    return false;\n  }\n  PointerSet seen;\n  Variant var(input, Variant::WithRefBind{});\n  ArrayUtil::Walk(var, walk_func, &ctx, true, &seen, userdata);\n  return true;\n}\n\nbool HHVM_FUNCTION(array_walk,\n                   VRefParam input,\n                   const Variant& funcname,\n                   const Variant& userdata /* = null_variant */) {\n  if (!input.isArray()) {\n    throw_expected_array_exception(\"array_walk\");\n    return false;\n  }\n  CallCtx ctx;\n  CallerFrame cf;\n  vm_decode_function(funcname, cf(), false, ctx);\n  if (ctx.func == NULL) {\n    return false;\n  }\n  Variant var(input, Variant::WithRefBind{});\n  ArrayUtil::Walk(var, walk_func, &ctx, false, NULL, userdata);\n  return true;\n}\n\nstatic void compact(PointerSet& seen,\n                    VarEnv* v, Array &ret, const Variant& var) {\n  if (var.isArray()) {\n    auto adata = var.getArrayData();\n    auto check = couldRecur(var, adata);\n    if (check && !seen.insert(adata).second) {\n      raise_warning(\"compact(): recursion detected\");\n      return;\n    }\n    for (ArrayIter iter(adata); iter; ++iter) {\n      compact(seen, v, ret, iter.secondRef());\n    }\n    if (check) seen.erase(adata);\n  } else {\n    String varname = var.toString();\n    if (!varname.empty() && v->lookup(varname.get()) != NULL) {\n      ret.set(varname, *reinterpret_cast<Variant*>(v->lookup(varname.get())));\n    }\n  }\n}\n\nArray HHVM_FUNCTION(compact,\n                    const Variant& varname,\n                    const Array& args /* = null array */) {\n  raise_disallowed_dynamic_call(\"compact should not be called dynamically\");\n  Array ret = Array::attach(PackedArray::MakeReserve(args.size() + 1));\n  VarEnv* v = g_context->getOrCreateVarEnv();\n  if (v) {\n    PointerSet seen;\n    compact(seen, v, ret, varname);\n    if (!args.empty()) compact(seen, v, ret, args);\n  }\n  return ret;\n}\n\n// __SystemLib\\\\compact_sl\nArray HHVM_FUNCTION(__SystemLib_compact_sl,\n                    const Variant& varname,\n                    const Array& args /* = null array */) {\n  Array ret = Array::attach(PackedArray::MakeReserve(args.size() + 1));\n  VarEnv* v = g_context->getOrCreateVarEnv();\n  if (v) {\n    PointerSet seen;\n    compact(seen, v, ret, varname);\n    if (!args.empty()) compact(seen, v, ret, args);\n  }\n  return ret;\n}\n\nstatic int php_count_recursive(const Array& array) {\n  long cnt = array.size();\n  for (ArrayIter iter(array); iter; ++iter) {\n    Variant value = iter.second();\n    if (value.isArray()) {\n      const Array& arr_value = value.asCArrRef();\n      check_recursion_throw();\n      cnt += php_count_recursive(arr_value);\n    }\n  }\n  return cnt;\n}\n\nbool HHVM_FUNCTION(shuffle,\n                   VRefParam array) {\n  if (!array.isArray()) {\n    throw_expected_array_exception(\"shuffle\");\n    return false;\n  }\n  array.assignIfRef(ArrayUtil::Shuffle(array));\n  return true;\n}\n\nenum class CountMode {\n  NORMAL = 0,\n  RECURSIVE = 1,\n};\n\nint64_t HHVM_FUNCTION(count,\n                      const Variant& var,\n                      int64_t mode /* = 0 */) {\n  switch (var.getType()) {\n    case KindOfUninit:\n    case KindOfNull:\n      return 0;\n\n    case KindOfBoolean:\n    case KindOfInt64:\n    case KindOfDouble:\n    case KindOfPersistentString:\n    case KindOfString:\n    case KindOfResource:\n      return 1;\n\n    case KindOfPersistentArray:\n    case KindOfArray:\n      if ((CountMode)mode == CountMode::RECURSIVE) {\n        const Array& arr_var = var.toCArrRef();\n        return php_count_recursive(arr_var);\n      }\n      return var.getArrayData()->size();\n\n    case KindOfObject:\n      {\n        Object obj = var.toObject();\n        if (obj->isCollection()) {\n          return collections::getSize(obj.get());\n        }\n        if (obj.instanceof(SystemLib::s_CountableClass)) {\n          return obj->o_invoke_few_args(s_count, 0).toInt64();\n        }\n      }\n      return 1;\n\n    case KindOfRef:\n    case KindOfClass:\n      break;\n  }\n  not_reached();\n}\n\nint64_t HHVM_FUNCTION(sizeof,\n                      const Variant& var,\n                      int64_t mode /* = 0 */) {\n  return HHVM_FN(count)(var, mode);\n}\n\nnamespace {\n\nenum class NoCow {};\ntemplate<class DoCow = void, class NonArrayRet, class OpPtr>\nstatic Variant iter_op_impl(VRefParam refParam, OpPtr op, const String& objOp,\n                            NonArrayRet nonArray,\n                            bool(ArrayData::*pred)() const =\n                              &ArrayData::isInvalid) {\n  auto& cell = *refParam.wrapped().asCell();\n  if (!isArrayType(cell.m_type)) {\n    if (cell.m_type == KindOfObject) {\n      auto obj = refParam.wrapped().toObject();\n      if (obj->instanceof(SystemLib::s_ArrayObjectClass)) {\n        return obj->o_invoke_few_args(objOp, 0);\n      }\n    }\n    throw_bad_type_exception(\"expecting an array\");\n    return Variant(nonArray);\n  }\n\n  auto ad = cell.m_data.parr;\n  auto constexpr doCow = !std::is_same<DoCow, NoCow>::value;\n  if (doCow && ad->cowCheck() && !(ad->*pred)() &&\n      !ad->noCopyOnWrite()) {\n    ad = ad->copy();\n    if (LIKELY(refParam.isRefData()))\n      cellMove(make_tv<KindOfArray>(ad), *refParam.getRefData()->tv());\n    else {\n      req::ptr<ArrayData> tmp(ad, req::ptr<ArrayData>::NoIncRef{});\n      return (ad->*op)();\n    }\n  }\n  return (ad->*op)();\n}\n\n}\n\nconst StaticString\n  s___each(\"__each\"),\n  s___current(\"__current\"),\n  s___key(\"__key\"),\n  s___next(\"__next\"),\n  s___prev(\"__prev\"),\n  s___reset(\"__reset\"),\n  s___end(\"__end\");\n\n\nVariant HHVM_FUNCTION(each,\n                      VRefParam refParam) {\n  return iter_op_impl(\n    refParam,\n    &ArrayData::each,\n    s___each,\n    Variant::NullInit()\n  );\n}\n\nVariant HHVM_FUNCTION(current,\n                      VRefParam refParam) {\n  return iter_op_impl<NoCow>(\n    refParam,\n    &ArrayData::current,\n    s___current,\n    false\n  );\n}\n\nVariant HHVM_FUNCTION(pos,\n                      VRefParam refParam) {\n  return HHVM_FN(current)(refParam);\n}\n\nVariant HHVM_FUNCTION(key,\n                      VRefParam refParam) {\n  return iter_op_impl<NoCow>(\n    refParam,\n    &ArrayData::key,\n    s___key,\n    false\n  );\n}\n\nVariant HHVM_FUNCTION(next,\n                      VRefParam refParam) {\n  return iter_op_impl(\n    refParam,\n    &ArrayData::next,\n    s___next,\n    false\n  );\n}\n\nVariant HHVM_FUNCTION(prev,\n                      VRefParam refParam) {\n  return iter_op_impl(\n    refParam,\n    &ArrayData::prev,\n    s___prev,\n    false\n  );\n}\n\nVariant HHVM_FUNCTION(reset,\n                      VRefParam refParam) {\n  return iter_op_impl(\n    refParam,\n    &ArrayData::reset,\n    s___reset,\n    false,\n    &ArrayData::isHead\n  );\n}\n\nVariant HHVM_FUNCTION(end,\n                      VRefParam refParam) {\n  return iter_op_impl(\n    refParam,\n    &ArrayData::end,\n    s___end,\n    false,\n    &ArrayData::isTail\n  );\n}\n\nbool HHVM_FUNCTION(in_array,\n                   const Variant& needle,\n                   const Variant& haystack,\n                   bool strict /* = false */) {\n  bool ret = false;\n  auto ok = strict ?\n    IterateV(*haystack.asCell(),\n             [](ArrayData*) { return false; },\n             [&](const TypedValue* tv) -> bool {\n               if (HPHP::same(tvAsCVarRef(tv), needle)) {\n                 ret = true;\n                 return true;\n               }\n               return false;\n             },\n             [](ObjectData*) { return false; }) :\n    IterateV(*haystack.asCell(),\n             [](ArrayData*) { return false; },\n             [&](const TypedValue* tv) -> bool {\n               if (HPHP::equal(tvAsCVarRef(tv), needle)) {\n                 ret = true;\n                 return true;\n               }\n               return false;\n             },\n             [](ObjectData*) { return false; });\n\n  if (UNLIKELY(!ok)) {\n    raise_warning(\"in_array() expects parameter 2 to be an array \"\n                  \"or collection\");\n  }\n  return ret;\n}\n\nVariant array_search(const Variant& needle,\n                     const Variant& haystack,\n                     bool strict /* = false */) {\n  Variant ret = false;\n  auto ok = strict ?\n    IterateKV(*haystack.asCell(),\n              [](ArrayData*) { return false; },\n              [&](const TypedValue* key, const TypedValue* tv) -> bool {\n                if (HPHP::same(tvAsCVarRef(tv), needle)) {\n                  ret = tvAsCVarRef(key);\n                  return true;\n                }\n                return false;\n              },\n              [](ObjectData*) { return false; }) :\n    IterateKV(*haystack.asCell(),\n              [](ArrayData*) { return false; },\n              [&](const TypedValue* key, const TypedValue* tv) -> bool {\n                if (HPHP::equal(tvAsCVarRef(tv), needle)) {\n                  ret = tvAsCVarRef(key);\n                  return true;\n                }\n                return false;\n              },\n              [](ObjectData*) { return false; });\n\n  if (UNLIKELY(!ok)) {\n    raise_warning(\"array_search() expects parameter 2 to be an array \"\n                  \"or collection\");\n    return init_null();\n  }\n\n  return ret;\n}\n\nTypedValue HHVM_FUNCTION(array_search,\n                         const Variant& needle,\n                         const Variant& haystack,\n                         bool strict /* = false */) {\n  return tvReturn(array_search(needle, haystack, strict));\n}\n\nTypedValue HHVM_FUNCTION(range,\n                         const Variant& low,\n                         const Variant& high,\n                         const Variant& step /* = 1 */) {\n  bool is_step_double = false;\n  double dstep = 1.0;\n  if (step.isDouble()) {\n    dstep = step.toDouble();\n    is_step_double = true;\n  } else if (step.isString()) {\n    int64_t sn;\n    double sd;\n    DataType stype = step.toString().get()->isNumericWithVal(sn, sd, 0);\n    if (stype == KindOfDouble) {\n      is_step_double = true;\n      dstep = sd;\n    } else if (stype == KindOfInt64) {\n      dstep = (double)sn;\n    } else {\n      dstep = step.toDouble();\n    }\n  } else {\n    dstep = step.toDouble();\n  }\n  /* We only want positive step values. */\n  if (dstep < 0.0) dstep *= -1;\n  if (low.isString() && high.isString()) {\n    String slow = low.toString();\n    String shigh = high.toString();\n    if (slow.size() >= 1 && shigh.size() >=1) {\n      int64_t n1, n2;\n      double d1, d2;\n      DataType type1 = slow.get()->isNumericWithVal(n1, d1, 0);\n      DataType type2 = shigh.get()->isNumericWithVal(n2, d2, 0);\n      if (type1 == KindOfDouble || type2 == KindOfDouble || is_step_double) {\n        if (type1 != KindOfDouble) d1 = slow.toDouble();\n        if (type2 != KindOfDouble) d2 = shigh.toDouble();\n        return tvReturn(ArrayUtil::Range(d1, d2, dstep));\n      }\n\n      int64_t lstep = (int64_t) dstep;\n      if (type1 == KindOfInt64 || type2 == KindOfInt64) {\n        if (type1 != KindOfInt64) n1 = slow.toInt64();\n        if (type2 != KindOfInt64) n2 = shigh.toInt64();\n        return tvReturn(ArrayUtil::Range((double)n1, (double)n2, lstep));\n      }\n\n      return tvReturn(ArrayUtil::Range((unsigned char)slow.charAt(0),\n                                       (unsigned char)shigh.charAt(0), lstep));\n    }\n  }\n\n  if (low.is(KindOfDouble) || high.is(KindOfDouble) || is_step_double) {\n    return tvReturn(ArrayUtil::Range(low.toDouble(), high.toDouble(), dstep));\n  }\n\n  int64_t lstep = (int64_t) dstep;\n  return tvReturn(ArrayUtil::Range(low.toDouble(), high.toDouble(), lstep));\n}\n///////////////////////////////////////////////////////////////////////////////\n// diff/intersect helpers\n\nstatic int cmp_func(const Variant& v1, const Variant& v2, const void *data) {\n  Variant *callback = (Variant *)data;\n  return vm_call_user_func(*callback, make_packed_array(v1, v2)).toInt32();\n}\n\n// PHP 5.x does different things when diffing against the same array,\n// particularly when the comparison function is outside the norm of\n// return -1, 0, 1 specification. To do what PHP 5.x in these cases,\n// use the RuntimeOption\n#define COMMA ,\n#define diff_intersect_body(type, vararg, intersect_params)     \\\n  getCheckedArray(array1);                                      \\\n  if (!arr_array1.size()) return tvReturn(arr_array1);          \\\n  Array ret = Array::Create();                                  \\\n  if (RuntimeOption::EnableZendSorting) {                       \\\n    getCheckedArray(array2);                                    \\\n    if (arr_array1.same(arr_array2)) {                          \\\n      return tvReturn(std::move(ret));                          \\\n    }                                                           \\\n  }                                                             \\\n  ret = arr_array1.type(array2, intersect_params);              \\\n  if (ret.size()) {                                             \\\n    for (ArrayIter iter(vararg); iter; ++iter) {                \\\n      ret = ret.type(iter.second(), intersect_params);          \\\n      if (!ret.size()) break;                                   \\\n    }                                                           \\\n  }                                                             \\\n  return tvReturn(std::move(ret));\n\n///////////////////////////////////////////////////////////////////////////////\n// diff functions\n\nstatic inline void addToSetHelper(const req::ptr<c_Set>& st,\n                                  const Cell c,\n                                  TypedValue* strTv,\n                                  bool convertIntLikeStrs) {\n  if (c.m_type == KindOfInt64) {\n    st->add(c.m_data.num);\n  } else {\n    StringData* s;\n    if (LIKELY(isStringType(c.m_type))) {\n      s = c.m_data.pstr;\n    } else {\n      s = tvCastToString(&c);\n      decRefStr(strTv->m_data.pstr);\n      strTv->m_data.pstr = s;\n    }\n    int64_t n;\n    if (convertIntLikeStrs && s->isStrictlyInteger(n)) {\n      st->add(n);\n    } else {\n      st->add(s);\n    }\n  }\n}\n\nstatic inline bool checkSetHelper(const req::ptr<c_Set>& st,\n                                  const Cell c,\n                                  TypedValue* strTv,\n                                  bool convertIntLikeStrs) {\n  if (c.m_type == KindOfInt64) {\n    return st->contains(c.m_data.num);\n  }\n  StringData* s;\n  if (LIKELY(isStringType(c.m_type))) {\n    s = c.m_data.pstr;\n  } else {\n    s = tvCastToString(&c);\n    decRefStr(strTv->m_data.pstr);\n    strTv->m_data.pstr = s;\n  }\n  int64_t n;\n  if (convertIntLikeStrs && s->isStrictlyInteger(n)) {\n    return st->contains(n);\n  }\n  return st->contains(s);\n}\n\nstatic void containerValuesToSetHelper(const req::ptr<c_Set>& st,\n                                       const Variant& container) {\n  Variant strHolder(empty_string_variant());\n  TypedValue* strTv = strHolder.asTypedValue();\n  for (ArrayIter iter(container); iter; ++iter) {\n    auto const& c = *iter.secondRefPlus().asCell();\n    addToSetHelper(st, c, strTv, true);\n  }\n}\n\nstatic void containerKeysToSetHelper(const req::ptr<c_Set>& st,\n                                     const Variant& container) {\n  Variant strHolder(empty_string_variant());\n  TypedValue* strTv = strHolder.asTypedValue();\n  bool isKey = isArrayType(container.asCell()->m_type);\n  for (ArrayIter iter(container); iter; ++iter) {\n    addToSetHelper(st, *iter.first().asCell(), strTv, !isKey);\n  }\n}\n\n#define ARRAY_DIFF_PRELUDE() \\\n  /* Check to make sure all inputs are containers */ \\\n  const auto& c1 = *container1.asCell(); \\\n  const auto& c2 = *container2.asCell(); \\\n  if (UNLIKELY(!isContainer(c1) || !isContainer(c2))) { \\\n    raise_warning(\"%s() expects parameter %d to be an array or collection\", \\\n                  __FUNCTION__+2, /* remove the \"f_\" prefix */ \\\n                  isContainer(c1) ? 2 : 1); \\\n    return make_tv<KindOfNull>(); \\\n  } \\\n  bool moreThanTwo = !args.empty(); \\\n  size_t largestSize = getContainerSize(c2); \\\n  if (UNLIKELY(moreThanTwo)) { \\\n    int pos = 3; \\\n    for (ArrayIter argvIter(args); argvIter; ++argvIter, ++pos) { \\\n      const auto& c = *argvIter.secondRef().asCell(); \\\n      if (!isContainer(c)) { \\\n        raise_warning(\"%s() expects parameter %d to be an array or collection\",\\\n                      __FUNCTION__+2, /* remove the \"f_\" prefix */ \\\n                      pos); \\\n        return make_tv<KindOfNull>(); \\\n      } \\\n      size_t sz = getContainerSize(c); \\\n      if (sz > largestSize) { \\\n        largestSize = sz; \\\n      } \\\n    } \\\n  } \\\n  /* If container1 is empty, we can stop here and return the empty array */ \\\n  if (!getContainerSize(c1)) { \\\n    return make_tv<KindOfPersistentArray>(staticEmptyArray()); \\\n  } \\\n  /* If all of the containers (except container1) are empty, we can just \\\n     return container1 (converting it to an array if needed) */ \\\n  if (!largestSize) { \\\n    if (isArrayType(c1.m_type)) { \\\n      return tvReturn(container1); \\\n    } else { \\\n      return tvReturn(container1.toArray()); \\\n    } \\\n  } \\\n  Array ret = Array::Create();\n\nTypedValue HHVM_FUNCTION(array_diff,\n                         const Variant& container1,\n                         const Variant& container2,\n                         const Array& args /* = null array */) {\n  ARRAY_DIFF_PRELUDE()\n  // Put all of the values from all the containers (except container1 into a\n  // Set. All types aside from integer and string will be cast to string, and\n  // we also convert int-like strings to integers.\n  auto st = req::make<c_Set>();\n  st->reserve(largestSize);\n  containerValuesToSetHelper(st, container2);\n  if (UNLIKELY(moreThanTwo)) {\n    for (ArrayIter argvIter(args); argvIter; ++argvIter) {\n      const auto& container = argvIter.secondRef();\n      containerValuesToSetHelper(st, container);\n    }\n  }\n  // Loop over container1, only copying over key/value pairs where the value\n  // is not present in the Set. When checking if a value is present in the\n  // Set, any value that is not an integer or string is cast to a string, and\n  // we convert int-like strings to integers.\n  Variant strHolder(empty_string_variant());\n  TypedValue* strTv = strHolder.asTypedValue();\n  bool isKey = isArrayType(c1.m_type);\n  for (ArrayIter iter(container1); iter; ++iter) {\n    const auto& val = iter.secondRefPlus();\n    const auto& c = *val.asCell();\n    if (checkSetHelper(st, c, strTv, true)) continue;\n    ret.setWithRef(iter.first(), val, isKey);\n  }\n  return tvReturn(std::move(ret));\n}\n\nTypedValue HHVM_FUNCTION(array_diff_key,\n                         const Variant& container1,\n                         const Variant& container2,\n                         const Array& args /* = null array */) {\n  ARRAY_DIFF_PRELUDE()\n  // If we're only dealing with two containers and if they are both arrays,\n  // we can avoid creating an intermediate Set\n  if (!moreThanTwo && isArrayType(c1.m_type) && isArrayType(c2.m_type)) {\n    auto ad2 = c2.m_data.parr;\n    for (ArrayIter iter(container1); iter; ++iter) {\n      auto key = iter.first();\n      const auto& c = *key.asCell();\n      if (c.m_type == KindOfInt64) {\n        if (ad2->exists(c.m_data.num)) continue;\n      } else {\n        assert(isStringType(c.m_type));\n        if (ad2->exists(c.m_data.pstr)) continue;\n      }\n      ret.setWithRef(key, iter.secondRefPlus(), true);\n    }\n    return tvReturn(std::move(ret));\n  }\n  // Put all of the keys from all the containers (except container1) into a\n  // Set. All types aside from integer and string will be cast to string, and\n  // we also convert int-like strings to integers.\n  auto st = req::make<c_Set>();\n  st->reserve(largestSize);\n  containerKeysToSetHelper(st, container2);\n  if (UNLIKELY(moreThanTwo)) {\n    for (ArrayIter argvIter(args); argvIter; ++argvIter) {\n      const auto& container = argvIter.secondRef();\n      containerKeysToSetHelper(st, container);\n    }\n  }\n  // Loop over container1, only copying over key/value pairs where the key is\n  // not present in the Set. When checking if a key is present in the Set, any\n  // key that is not an integer or string is cast to a string, and we convert\n  // int-like strings to integers.\n  Variant strHolder(empty_string_variant());\n  TypedValue* strTv = strHolder.asTypedValue();\n  bool isKey = isArrayType(c1.m_type);\n  for (ArrayIter iter(container1); iter; ++iter) {\n    auto key = iter.first();\n    const auto& c = *key.asCell();\n    if (checkSetHelper(st, c, strTv, !isKey)) continue;\n    ret.setWithRef(key, iter.secondRefPlus(), isKey);\n  }\n  return tvReturn(std::move(ret));\n}\n\n#undef ARRAY_DIFF_PRELUDE\n\nTypedValue HHVM_FUNCTION(array_udiff,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& data_compare_func,\n                         const Array& args /* = null array */) {\n  Variant func = data_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(func);\n    func = extra.pop();\n  }\n  diff_intersect_body(diff, extra, false COMMA true COMMA NULL COMMA NULL\n                      COMMA cmp_func COMMA &func);\n}\n\nTypedValue HHVM_FUNCTION(array_diff_assoc,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Array& args /* = null array */) {\n  diff_intersect_body(diff, args, true COMMA true);\n}\n\nTypedValue HHVM_FUNCTION(array_diff_uassoc,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& key_compare_func,\n                         const Array& args /* = null array */) {\n  Variant func = key_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(func);\n    func = extra.pop();\n  }\n  diff_intersect_body(diff, extra, true COMMA true COMMA cmp_func COMMA &func);\n}\n\nTypedValue HHVM_FUNCTION(array_udiff_assoc,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& data_compare_func,\n                         const Array& args /* = null array */) {\n  Variant func = data_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(func);\n    func = extra.pop();\n  }\n  diff_intersect_body(diff, extra, true COMMA true COMMA NULL COMMA NULL\n                      COMMA cmp_func COMMA &func);\n}\n\nTypedValue HHVM_FUNCTION(array_udiff_uassoc,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& data_compare_func,\n                         const Variant& key_compare_func,\n                         const Array& args /* = null array */) {\n  Variant data_func = data_compare_func;\n  Variant key_func = key_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(key_func);\n    extra.prepend(data_func);\n    key_func = extra.pop();\n    data_func = extra.pop();\n  }\n  diff_intersect_body(diff, extra, true\n                      COMMA true COMMA cmp_func COMMA &key_func\n                      COMMA cmp_func COMMA &data_func);\n}\n\nTypedValue HHVM_FUNCTION(array_diff_ukey,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& key_compare_func,\n                         const Array& args /* = null array */) {\n  Variant func = key_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(func);\n    func = extra.pop();\n  }\n  diff_intersect_body(diff, extra, true COMMA false COMMA cmp_func COMMA &func);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// intersect functions\n\nstatic inline TypedValue* makeContainerListHelper(const Variant& a,\n                                                  const Array& argv,\n                                                  int count,\n                                                  int smallestPos) {\n  assert(count == argv.size() + 1);\n  assert(0 <= smallestPos);\n  assert(smallestPos < count);\n  // Allocate a TypedValue array and copy 'a' and the contents of 'argv'\n  TypedValue* containers = req::make_raw_array<TypedValue>(count);\n  tvCopy(*a.asCell(), containers[0]);\n  int pos = 1;\n  for (ArrayIter argvIter(argv); argvIter; ++argvIter, ++pos) {\n    const auto& c = *argvIter.secondRef().asCell();\n    tvCopy(c, containers[pos]);\n  }\n  // Perform a swap so that the smallest container occurs at the first\n  // position in the TypedValue array; this helps improve the performance\n  // of containerValuesIntersectHelper()\n  if (smallestPos != 0) {\n    TypedValue tmp;\n    tvCopy(containers[0], tmp);\n    tvCopy(containers[smallestPos], containers[0]);\n    tvCopy(tmp, containers[smallestPos]);\n  }\n  return containers;\n}\n\nstatic inline void addToIntersectMapHelper(const req::ptr<c_Map>& mp,\n                                           const Cell c,\n                                           TypedValue* intOneTv,\n                                           TypedValue* strTv,\n                                           bool convertIntLikeStrs) {\n  if (c.m_type == KindOfInt64) {\n    mp->set(c.m_data.num, intOneTv);\n  } else {\n    StringData* s;\n    if (LIKELY(isStringType(c.m_type))) {\n      s = c.m_data.pstr;\n    } else {\n      s = tvCastToString(&c);\n      decRefStr(strTv->m_data.pstr);\n      strTv->m_data.pstr = s;\n    }\n    int64_t n;\n    if (convertIntLikeStrs && s->isStrictlyInteger(n)) {\n      mp->set(n, intOneTv);\n    } else {\n      mp->set(s, intOneTv);\n    }\n  }\n}\n\nstatic inline void updateIntersectMapHelper(const req::ptr<c_Map>& mp,\n                                            const Cell c,\n                                            int pos,\n                                            TypedValue* strTv,\n                                            bool convertIntLikeStrs) {\n  if (c.m_type == KindOfInt64) {\n    auto val = mp->get(c.m_data.num);\n    if (val && val->m_data.num == pos) {\n      assert(val->m_type == KindOfInt64);\n      ++val->m_data.num;\n    }\n  } else {\n    StringData* s;\n    if (LIKELY(isStringType(c.m_type))) {\n      s = c.m_data.pstr;\n    } else {\n      s = tvCastToString(&c);\n      decRefStr(strTv->m_data.pstr);\n      strTv->m_data.pstr = s;\n    }\n    int64_t n;\n    if (convertIntLikeStrs && s->isStrictlyInteger(n)) {\n      auto val = mp->get(n);\n      if (val && val->m_data.num == pos) {\n        assert(val->m_type == KindOfInt64);\n        ++val->m_data.num;\n      }\n    } else {\n      auto val = mp->get(s);\n      if (val && val->m_data.num == pos) {\n        assert(val->m_type == KindOfInt64);\n        ++val->m_data.num;\n      }\n    }\n  }\n}\n\nstatic void containerValuesIntersectHelper(const req::ptr<c_Set>& st,\n                                           TypedValue* containers,\n                                           int count) {\n  assert(count >= 2);\n  auto mp = req::make<c_Map>();\n  Variant strHolder(empty_string_variant());\n  TypedValue* strTv = strHolder.asTypedValue();\n  TypedValue intOneTv = make_tv<KindOfInt64>(1);\n  for (ArrayIter iter(tvAsCVarRef(&containers[0])); iter; ++iter) {\n    const auto& c = *iter.secondRefPlus().asCell();\n    // For each value v in containers[0], we add the key/value pair (v, 1)\n    // to the map. If a value (after various conversions) occurs more than\n    // once in the container, we'll simply overwrite the old entry and that's\n    // fine.\n    addToIntersectMapHelper(mp, c, &intOneTv, strTv, true);\n  }\n  for (int pos = 1; pos < count; ++pos) {\n    for (ArrayIter iter(tvAsCVarRef(&containers[pos])); iter; ++iter) {\n      const auto& c = *iter.secondRefPlus().asCell();\n      // We check if the value is present as a key in the map. If an entry\n      // exists and its value equals pos, we increment it, otherwise we do\n      // nothing. This is essential so that we don't accidentally double-count\n      // a key (after various conversions) that occurs in the container more\n      // than once.\n      updateIntersectMapHelper(mp, c, pos, strTv, true);\n    }\n  }\n  for (ArrayIter iter(mp.get()); iter; ++iter) {\n    // For each key in the map, we copy the key to the set if the\n    // corresponding value is equal to pos exactly (which means it\n    // was present in all of the containers).\n    const auto& val = *iter.secondRefPlus().asCell();\n    assert(val.m_type == KindOfInt64);\n    if (val.m_data.num == count) {\n      st->add(iter.first().asCell());\n    }\n  }\n}\n\nstatic void containerKeysIntersectHelper(const req::ptr<c_Set>& st,\n                                         TypedValue* containers,\n                                         int count) {\n  assert(count >= 2);\n  auto mp = req::make<c_Map>();\n  Variant strHolder(empty_string_variant());\n  TypedValue* strTv = strHolder.asTypedValue();\n  TypedValue intOneTv = make_tv<KindOfInt64>(1);\n  bool isKey = isArrayType(containers[0].m_type);\n  for (ArrayIter iter(tvAsCVarRef(&containers[0])); iter; ++iter) {\n    auto key = iter.first();\n    const auto& c = *key.asCell();\n    // For each key k in containers[0], we add the key/value pair (k, 1)\n    // to the map. If a key (after various conversions) occurs more than\n    // once in the container, we'll simply overwrite the old entry and\n    // that's fine.\n    addToIntersectMapHelper(mp, c, &intOneTv, strTv, !isKey);\n  }\n  for (int pos = 1; pos < count; ++pos) {\n    isKey = isArrayType(containers[pos].m_type);\n    for (ArrayIter iter(tvAsCVarRef(&containers[pos])); iter; ++iter) {\n      auto key = iter.first();\n      const auto& c = *key.asCell();\n      updateIntersectMapHelper(mp, c, pos, strTv, !isKey);\n    }\n  }\n  for (ArrayIter iter(mp.get()); iter; ++iter) {\n    // For each key in the map, we copy the key to the set if the\n    // corresponding value is equal to pos exactly (which means it\n    // was present in all of the containers).\n    const auto& val = *iter.secondRefPlus().asCell();\n    assert(val.m_type == KindOfInt64);\n    if (val.m_data.num == count) {\n      st->add(iter.first().asCell());\n    }\n  }\n}\n\n#define ARRAY_INTERSECT_PRELUDE() \\\n  /* Check to make sure all inputs are containers */ \\\n  const auto& c1 = *container1.asCell(); \\\n  const auto& c2 = *container2.asCell(); \\\n  if (!isContainer(c1) || !isContainer(c2)) { \\\n    raise_warning(\"%s() expects parameter %d to be an array or collection\", \\\n                  __FUNCTION__+2, /* remove the \"f_\" prefix */ \\\n                  isContainer(c1) ? 2 : 1); \\\n    return make_tv<KindOfNull>(); \\\n  } \\\n  bool moreThanTwo = !args.empty(); \\\n  /* Keep track of which input container was the smallest (excluding \\\n     container1) */ \\\n  int smallestPos = 0; \\\n  size_t smallestSize = getContainerSize(c2); \\\n  if (UNLIKELY(moreThanTwo)) { \\\n    int pos = 1; \\\n    for (ArrayIter argvIter(args); argvIter; ++argvIter, ++pos) { \\\n      const auto& c = *argvIter.secondRef().asCell(); \\\n      if (!isContainer(c)) { \\\n        raise_warning(\"%s() expects parameter %d to be an array or collection\",\\\n                      __FUNCTION__+2, /* remove the \"f_\" prefix */ \\\n                      pos+2); \\\n        return make_tv<KindOfNull>(); \\\n      } \\\n      size_t sz = getContainerSize(c); \\\n      if (sz < smallestSize) { \\\n        smallestSize = sz; \\\n        smallestPos = pos; \\\n      } \\\n    } \\\n  } \\\n  /* If any of the containers were empty, we can stop here and return the \\\n     empty array */ \\\n  if (!getContainerSize(c1) || !smallestSize) { \\\n    return make_tv<KindOfPersistentArray>(staticEmptyArray()); \\\n  } \\\n  Array ret = Array::Create();\n\nTypedValue HHVM_FUNCTION(array_intersect,\n                         const Variant& container1,\n                         const Variant& container2,\n                         const Array& args /* = null array */) {\n  ARRAY_INTERSECT_PRELUDE()\n  // Build up a Set containing the values that are present in all the\n  // containers (except container1)\n  auto st = req::make<c_Set>();\n  if (LIKELY(!moreThanTwo)) {\n    // There is only one container (not counting container1) so we can\n    // just call containerValuesToSetHelper() to build the Set.\n    containerValuesToSetHelper(st, container2);\n  } else {\n    // We're dealing with three or more containers. Copy all of the containers\n    // (except the first) into a TypedValue array.\n    int count = args.size() + 1;\n    TypedValue* containers =\n      makeContainerListHelper(container2, args, count, smallestPos);\n    SCOPE_EXIT { req::free(containers); };\n    // Build a Set of the values that were present in all of the containers\n    containerValuesIntersectHelper(st, containers, count);\n  }\n  // Loop over container1, only copying over key/value pairs where the value\n  // is present in the Set. When checking if a value is present in the Set,\n  // any value that is not an integer or string is cast to a string, and we\n  // convert int-like strings to integers.\n  Variant strHolder(empty_string_variant());\n  TypedValue* strTv = strHolder.asTypedValue();\n  bool isKey = isArrayType(c1.m_type);\n  for (ArrayIter iter(container1); iter; ++iter) {\n    const auto& val = iter.secondRefPlus();\n    const auto& c = *val.asCell();\n    if (!checkSetHelper(st, c, strTv, true)) continue;\n    ret.setWithRef(iter.first(), val, isKey);\n  }\n  return tvReturn(std::move(ret));\n}\n\nTypedValue HHVM_FUNCTION(array_intersect_key,\n                         const Variant& container1,\n                         const Variant& container2,\n                         const Array& args /* = null array */) {\n  ARRAY_INTERSECT_PRELUDE()\n  // If we're only dealing with two containers and if they are both arrays,\n  // we can avoid creating an intermediate Set\n  if (!moreThanTwo && isArrayType(c1.m_type) && isArrayType(c2.m_type)) {\n    auto ad2 = c2.m_data.parr;\n    for (ArrayIter iter(container1); iter; ++iter) {\n      auto key = iter.first();\n      const auto& c = *key.asCell();\n      if (c.m_type == KindOfInt64) {\n        if (!ad2->exists(c.m_data.num)) continue;\n      } else {\n        assert(isStringType(c.m_type));\n        if (!ad2->exists(c.m_data.pstr)) continue;\n      }\n      ret.setWithRef(key, iter.secondRefPlus(), true);\n    }\n    return tvReturn(std::move(ret));\n  }\n  // Build up a Set containing the keys that are present in all the containers\n  // (except container1)\n  auto st = req::make<c_Set>();\n  if (LIKELY(!moreThanTwo)) {\n    // There is only one container (not counting container1) so we can just\n    // call containerKeysToSetHelper() to build the Set.\n    containerKeysToSetHelper(st, container2);\n  } else {\n    // We're dealing with three or more containers. Copy all of the containers\n    // (except the first) into a TypedValue array.\n    int count = args.size() + 1;\n    TypedValue* containers =\n      makeContainerListHelper(container2, args, count, smallestPos);\n    SCOPE_EXIT { req::free(containers); };\n    // Build a Set of the keys that were present in all of the containers\n    containerKeysIntersectHelper(st, containers, count);\n  }\n  // Loop over container1, only copying over key/value pairs where the key\n  // is present in the Set. When checking if a key is present in the Set,\n  // any value that is not an integer or string is cast to a string, and we\n  // convert int-like strings to integers.\n  Variant strHolder(empty_string_variant());\n  TypedValue* strTv = strHolder.asTypedValue();\n  bool isKey = isArrayType(c1.m_type);\n  for (ArrayIter iter(container1); iter; ++iter) {\n    auto key = iter.first();\n    const auto& c = *key.asCell();\n    if (!checkSetHelper(st, c, strTv, !isKey)) continue;\n    ret.setWithRef(key, iter.secondRefPlus(), isKey);\n  }\n  return tvReturn(std::move(ret));\n}\n\n#undef ARRAY_INTERSECT_PRELUDE\n\nTypedValue HHVM_FUNCTION(array_uintersect,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& data_compare_func,\n                         const Array& args /* = null array */) {\n  Variant func = data_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(func);\n    func = extra.pop();\n  }\n  diff_intersect_body(intersect, extra, false COMMA true COMMA NULL COMMA NULL\n                      COMMA cmp_func COMMA &func);\n}\n\nTypedValue HHVM_FUNCTION(array_intersect_assoc,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Array& args /* = null array */) {\n  diff_intersect_body(intersect, args, true COMMA true);\n}\n\nTypedValue HHVM_FUNCTION(array_intersect_uassoc,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& key_compare_func,\n                         const Array& args /* = null array */) {\n  Variant func = key_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(func);\n    func = extra.pop();\n  }\n  diff_intersect_body(intersect, extra, true COMMA true\n                      COMMA cmp_func COMMA &func);\n}\n\nTypedValue HHVM_FUNCTION(array_uintersect_assoc,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& data_compare_func,\n                         const Array& args /* = null array */) {\n  Variant func = data_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(func);\n    func = extra.pop();\n  }\n  diff_intersect_body(intersect, extra, true COMMA true COMMA NULL COMMA NULL\n                      COMMA cmp_func COMMA &func);\n}\n\nTypedValue HHVM_FUNCTION(array_uintersect_uassoc,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& data_compare_func,\n                         const Variant& key_compare_func,\n                         const Array& args /* = null array */) {\n  Variant data_func = data_compare_func;\n  Variant key_func = key_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(key_func);\n    extra.prepend(data_func);\n    key_func = extra.pop();\n    data_func = extra.pop();\n  }\n  diff_intersect_body(intersect, extra, true COMMA true COMMA cmp_func\n                      COMMA &key_func COMMA cmp_func COMMA &data_func);\n}\n\nTypedValue HHVM_FUNCTION(array_intersect_ukey,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& key_compare_func,\n                         const Array& args /* = null array */) {\n  Variant func = key_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(func);\n    func = extra.pop();\n  }\n  diff_intersect_body(intersect, extra, true COMMA false\n                      COMMA cmp_func COMMA &func);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// sorting functions\n\nstruct Collator final : RequestEventHandler {\n  String getLocale() {\n    return m_locale;\n  }\n  Intl::IntlError &getErrorRef() {\n    return m_errcode;\n  }\n  bool setLocale(const String& locale) {\n    if (m_locale.same(locale)) {\n      return true;\n    }\n    if (m_ucoll) {\n      ucol_close(m_ucoll);\n      m_ucoll = NULL;\n    }\n    m_errcode.clearError();\n    UErrorCode error = U_ZERO_ERROR;\n    m_ucoll = ucol_open(locale.data(), &error);\n    if (m_ucoll == NULL) {\n      raise_warning(\"failed to load %s locale from icu data\", locale.data());\n      return false;\n    }\n    if (U_FAILURE(error)) {\n      m_errcode.setError(error);\n      ucol_close(m_ucoll);\n      m_ucoll = NULL;\n      return false;\n    }\n    m_locale = locale;\n    return true;\n  }\n\n  UCollator *getCollator() {\n    return m_ucoll;\n  }\n\n  bool setAttribute(int64_t attr, int64_t val) {\n    if (!m_ucoll) {\n      Logger::Verbose(\"m_ucoll is NULL\");\n      return false;\n    }\n    m_errcode.clearError();\n    UErrorCode error = U_ZERO_ERROR;\n    ucol_setAttribute(m_ucoll, (UColAttribute)attr,\n                      (UColAttributeValue)val, &error);\n    if (U_FAILURE(error)) {\n      m_errcode.setError(error);\n      Logger::Verbose(\"Error setting attribute value\");\n      return false;\n    }\n    return true;\n  }\n\n  bool setStrength(int64_t strength) {\n    if (!m_ucoll) {\n      Logger::Verbose(\"m_ucoll is NULL\");\n      return false;\n    }\n    ucol_setStrength(m_ucoll, (UCollationStrength)strength);\n    return true;\n  }\n\n  Variant getErrorCode() {\n    if (!m_ucoll) {\n      Logger::Verbose(\"m_ucoll is NULL\");\n      return false;\n    }\n    return m_errcode.getErrorCode();\n  }\n\n  void requestInit() override {\n    m_locale = String(uloc_getDefault(), CopyString);\n    m_errcode.clearError();\n    UErrorCode error = U_ZERO_ERROR;\n    m_ucoll = ucol_open(m_locale.data(), &error);\n    if (U_FAILURE(error)) {\n      m_errcode.setError(error);\n    }\n    assert(m_ucoll);\n  }\n\n  void requestShutdown() override {\n    m_locale.reset();\n    m_errcode.clearError(false);\n    if (m_ucoll) {\n      ucol_close(m_ucoll);\n      m_ucoll = NULL;\n    }\n  }\n\n  void vscan(IMarker& mark) const override {\n    mark(m_locale);\n  }\n\nprivate:\n  String     m_locale;\n  UCollator *m_ucoll;\n  Intl::IntlError m_errcode;\n};\nIMPLEMENT_STATIC_REQUEST_LOCAL(Collator, s_collator);\n\nnamespace {\nstruct ArraySortTmp {\n  explicit ArraySortTmp(Array& arr, SortFunction sf) : m_arr(arr) {\n    m_ad = arr.get()->escalateForSort(sf);\n    assert(m_ad == arr.get() || m_ad->hasExactlyOneRef());\n  }\n  ~ArraySortTmp() {\n    if (m_ad != m_arr.get()) {\n      m_arr = Array::attach(m_ad);\n    }\n  }\n  ArrayData* operator->() { return m_ad; }\n private:\n  Array& m_arr;\n  ArrayData* m_ad;\n};\n}\n\nstatic bool\nphp_sort(VRefParam container, int sort_flags,\n         bool ascending, bool use_zend_sort) {\n  if (container.isArray()) {\n    auto ref = container.getVariantOrNull();\n    if (!ref) return true;\n    Array& arr_array = ref->asArrRef();\n    if (use_zend_sort) {\n      return zend_sort(*ref, sort_flags, ascending);\n    }\n    SortFunction sf = getSortFunction(SORTFUNC_SORT, ascending);\n    ArraySortTmp ast(arr_array, sf);\n    ast->sort(sort_flags, ascending);\n    return true;\n  }\n  if (container.isObject()) {\n    ObjectData* obj = container.getObjectData();\n    if (obj->isCollection() &&\n        obj->collectionType() == CollectionType::Vector) {\n      c_Vector* vec = static_cast<c_Vector*>(obj);\n      vec->sort(sort_flags, ascending);\n      return true;\n    }\n    // other collections are not supported:\n    //  - Maps and Sets require associative sort\n    //  - Immutable collections are not to be modified\n  }\n  throw_expected_array_or_collection_exception(ascending ? \"sort\" : \"rsort\");\n  return false;\n}\n\nstatic bool\nphp_asort(VRefParam container, int sort_flags,\n          bool ascending, bool use_zend_sort) {\n  if (container.isArray()) {\n    auto ref = container.getVariantOrNull();\n    if (!ref) return true;\n    Array& arr_array = ref->asArrRef();\n    if (use_zend_sort) {\n      return zend_asort(*ref, sort_flags, ascending);\n    }\n    SortFunction sf = getSortFunction(SORTFUNC_ASORT, ascending);\n    ArraySortTmp ast(arr_array, sf);\n    ast->asort(sort_flags, ascending);\n    return true;\n  }\n  if (container.isObject()) {\n    ObjectData* obj = container.getObjectData();\n    if (obj->isCollection()) {\n      auto type = obj->collectionType();\n      if (type == CollectionType::Map || type == CollectionType::Set) {\n        HashCollection* hc = static_cast<HashCollection*>(obj);\n        hc->asort(sort_flags, ascending);\n        return true;\n      }\n    }\n  }\n  throw_expected_array_or_collection_exception(ascending ? \"asort\" : \"arsort\");\n  return false;\n}\n\nstatic bool\nphp_ksort(VRefParam container, int sort_flags, bool ascending,\n          bool use_zend_sort) {\n  if (container.isArray()) {\n    auto ref = container.getVariantOrNull();\n    if (!ref) return true;\n    Array& arr_array = ref->asArrRef();\n    if (use_zend_sort) {\n      return zend_ksort(*ref, sort_flags, ascending);\n    }\n    SortFunction sf = getSortFunction(SORTFUNC_KRSORT, ascending);\n    ArraySortTmp ast(arr_array, sf);\n    ast->ksort(sort_flags, ascending);\n    return true;\n  }\n  if (container.isObject()) {\n    ObjectData* obj = container.getObjectData();\n    if (obj->isCollection()) {\n      auto type = obj->collectionType();\n      if (type == CollectionType::Map || type == CollectionType::Set) {\n        HashCollection* hc = static_cast<HashCollection*>(obj);\n        hc->ksort(sort_flags, ascending);\n        return true;\n      }\n    }\n  }\n  throw_expected_array_or_collection_exception(ascending ? \"ksort\" : \"krsort\");\n  return false;\n}\n\nbool HHVM_FUNCTION(sort,\n                  VRefParam array,\n                  int sort_flags /* = 0 */) {\n  bool use_zend_sort = RuntimeOption::EnableZendSorting;\n  return php_sort(array, sort_flags, true, use_zend_sort);\n}\n\nbool HHVM_FUNCTION(rsort,\n                   VRefParam array,\n                   int sort_flags /* = 0 */) {\n  bool use_zend_sort = RuntimeOption::EnableZendSorting;\n  return php_sort(array, sort_flags, false, use_zend_sort);\n}\n\nbool HHVM_FUNCTION(asort,\n                   VRefParam array,\n                   int sort_flags /* = 0 */) {\n  bool use_zend_sort = RuntimeOption::EnableZendSorting;\n  return php_asort(array, sort_flags, true, use_zend_sort);\n}\n\nbool HHVM_FUNCTION(arsort,\n                   VRefParam array,\n                   int sort_flags /* = 0 */) {\n  bool use_zend_sort = RuntimeOption::EnableZendSorting;\n  return php_asort(array, sort_flags, false, use_zend_sort);\n}\n\nbool HHVM_FUNCTION(ksort,\n                   VRefParam array,\n                   int sort_flags /* = 0 */) {\n  bool use_zend_sort = RuntimeOption::EnableZendSorting;\n  return php_ksort(array, sort_flags, true, use_zend_sort);\n}\n\nbool HHVM_FUNCTION(krsort,\n                   VRefParam array,\n                   int sort_flags /* = 0 */) {\n  bool use_zend_sort = RuntimeOption::EnableZendSorting;\n  return php_ksort(array, sort_flags, false, use_zend_sort);\n}\n\n// NOTE: PHP's implementation of natsort and natcasesort accepts ArrayAccess\n// objects as well, which does not make much sense, and which is not supported\n// here.\n\nbool HHVM_FUNCTION(natsort, VRefParam array) {\n  return php_asort(array, SORT_NATURAL, true, false);\n}\n\nbool HHVM_FUNCTION(natcasesort, VRefParam array) {\n  return php_asort(array, SORT_NATURAL_CASE, true, false);\n}\n\nbool HHVM_FUNCTION(usort,\n                   VRefParam container,\n                   const Variant& cmp_function) {\n  if (container.isArray()) {\n    auto sort = [](Array& arr_array, const Variant& cmp_function) -> bool {\n      if (RuntimeOption::EnableZendSorting) {\n        arr_array.sort(cmp_func, false, true, &cmp_function);\n        return true;\n      } else {\n        ArraySortTmp ast(arr_array, SORTFUNC_USORT);\n        return ast->usort(cmp_function);\n      }\n    };\n    auto ref = container.getVariantOrNull();\n    if (LIKELY(ref != nullptr)) {\n      return sort(ref->asArrRef(), cmp_function);\n    }\n    auto tmp = container->asCArrRef();\n    return sort(tmp, cmp_function);\n  }\n  if (container.isObject()) {\n    ObjectData* obj = container.getObjectData();\n    if (obj->isCollection()) {\n      if (obj->collectionType() == CollectionType::Vector) {\n        c_Vector* vec = static_cast<c_Vector*>(obj);\n        return vec->usort(cmp_function);\n      }\n    }\n    // other collections are not supported:\n    //  - Maps and Sets require associative sort\n    //  - Immutable collections are not to be modified\n  }\n  throw_expected_array_or_collection_exception(\"usort\");\n  return false;\n}\n\nbool HHVM_FUNCTION(uasort,\n                   VRefParam container,\n                   const Variant& cmp_function) {\n  if (container.isArray()) {\n    auto sort = [](Array& arr_array, const Variant& cmp_function) -> bool {\n      if (RuntimeOption::EnableZendSorting) {\n        arr_array.sort(cmp_func, false, false, &cmp_function);\n        return true;\n      } else {\n        ArraySortTmp ast(arr_array, SORTFUNC_UASORT);\n        return ast->uasort(cmp_function);\n      }\n    };\n    auto ref = container.getVariantOrNull();\n    if (LIKELY(ref != nullptr)) {\n      return sort(ref->asArrRef(), cmp_function);\n    }\n    auto tmp = container->asCArrRef();\n    return sort(tmp, cmp_function);\n  }\n  if (container.isObject()) {\n    ObjectData* obj = container.getObjectData();\n    if (obj->isCollection()) {\n      auto type = obj->collectionType();\n      if (type == CollectionType::Map || type == CollectionType::Set) {\n        HashCollection* hc = static_cast<HashCollection*>(obj);\n        return hc->uasort(cmp_function);\n      }\n    }\n    // other collections are not supported:\n    //  - Vectors require a non-associative sort\n    //  - Immutable collections are not to be modified\n  }\n  throw_expected_array_or_collection_exception(\"uasort\");\n  return false;\n}\n\nbool HHVM_FUNCTION(uksort,\n                   VRefParam container,\n                   const Variant& cmp_function) {\n  if (container.isArray()) {\n    auto sort = [](Array& arr_array, const Variant& cmp_function) -> bool {\n      ArraySortTmp ast(arr_array, SORTFUNC_UKSORT);\n      return ast->uksort(cmp_function);\n    };\n    auto ref = container.getVariantOrNull();\n    if (LIKELY(ref != nullptr)) {\n      return sort(ref->asArrRef(), cmp_function);\n    }\n    auto tmp = container->asCArrRef();\n    return sort(tmp, cmp_function);\n  }\n  if (container.isObject()) {\n    ObjectData* obj = container.getObjectData();\n    if (obj->isCollection()) {\n      auto type = obj->collectionType();\n      if (type == CollectionType::Map || type == CollectionType::Set) {\n        HashCollection* hc = static_cast<HashCollection*>(obj);\n        return hc->uksort(cmp_function);\n      }\n    }\n    // other collections are not supported:\n    //  - Vectors require a non-associative sort\n    //  - Immutable collections are not to be modified\n  }\n  throw_expected_array_or_collection_exception(\"uksort\");\n  return false;\n}\n\nTypedValue HHVM_FUNCTION(array_unique,\n                         const Variant& array,\n                         int sort_flags /* = 2 */) {\n  // NOTE, PHP array_unique accepts ArrayAccess objects as well,\n  // which is not supported here.\n  getCheckedArray(array);\n  switch (sort_flags) {\n  case SORT_STRING:\n  case SORT_LOCALE_STRING:\n    return tvReturn(ArrayUtil::StringUnique(arr_array));\n  case SORT_NUMERIC:\n    return tvReturn(ArrayUtil::NumericUnique(arr_array));\n  case SORT_REGULAR:\n  default:\n    return tvReturn(ArrayUtil::RegularSortUnique(arr_array));\n  }\n}\n\nString HHVM_FUNCTION(i18n_loc_get_default) {\n  return s_collator->getLocale();\n}\n\nbool HHVM_FUNCTION(i18n_loc_set_default,\n                   const String& locale) {\n  return s_collator->setLocale(locale);\n}\n\nbool HHVM_FUNCTION(i18n_loc_set_attribute,\n                   int64_t attr,\n                   int64_t val) {\n  return s_collator->setAttribute(attr, val);\n}\n\nbool HHVM_FUNCTION(i18n_loc_set_strength,\n                   int64_t strength) {\n  return s_collator->setStrength(strength);\n}\n\nVariant HHVM_FUNCTION(i18n_loc_get_error_code) {\n  return s_collator->getErrorCode();\n}\n\nTypedValue HHVM_FUNCTION(hphp_array_idx,\n                         const Variant& search,\n                         const Variant& key,\n                         const Variant& def) {\n  if (!key.isNull()) {\n    if (LIKELY(search.isArray())) {\n      ArrayData *arr = search.getArrayData();\n      VarNR index = key.toKey(arr);\n      if (!index.isNull()) {\n        const Variant& ret = arr->get(index, false);\n        return tvReturn((&ret != &null_variant) ? ret : def);\n      }\n    } else {\n      raise_error(\"hphp_array_idx: search must be an array\");\n    }\n  }\n  return tvReturn(def);\n}\n\nstatic Array::PFUNC_CMP get_cmp_func(int sort_flags, bool ascending) {\n  switch (sort_flags) {\n  case SORT_NATURAL:\n    return ascending ?\n      Array::SortNaturalAscending : Array::SortNaturalDescending;\n  case SORT_NATURAL_CASE:\n    return ascending ?\n      Array::SortNaturalCaseAscending: Array::SortNaturalCaseDescending;\n  case SORT_NUMERIC:\n    return ascending ?\n      Array::SortNumericAscending : Array::SortNumericDescending;\n  case SORT_STRING:\n    return ascending ?\n      Array::SortStringAscending : Array::SortStringDescending;\n  case SORT_STRING_CASE:\n    return ascending ?\n      Array::SortStringAscendingCase : Array::SortStringDescendingCase;\n  case SORT_LOCALE_STRING:\n    return ascending ?\n      Array::SortLocaleStringAscending : Array::SortLocaleStringDescending;\n  case SORT_REGULAR:\n  default:\n    return ascending ?\n      Array::SortRegularAscending : Array::SortRegularDescending;\n  }\n}\n\nTypedValue* HHVM_FN(array_multisort)(ActRec* ar) {\n  TypedValue* tv = getArg(ar, 0);\n  if (tv == nullptr || !tvAsVariant(tv).isArray()) {\n    throw_expected_array_exception(\"array_multisort\");\n    return arReturn(ar, false);\n  }\n\n  std::vector<Array::SortData> data;\n  std::vector<Array> arrays;\n  arrays.reserve(ar->numArgs()); // so no resize would happen\n\n  Array::SortData sd;\n  sd.original = &tvAsVariant(tv);\n  arrays.push_back(Array(sd.original->getArrayData()));\n  sd.array = &arrays.back();\n  sd.by_key = false;\n\n  int sort_flags = SORT_REGULAR;\n  bool ascending = true;\n  for (int i = 1; i < ar->numArgs(); i++) {\n    tv = getArg(ar, i);\n    if (tvAsVariant(tv).isArray()) {\n      sd.cmp_func = get_cmp_func(sort_flags, ascending);\n      data.push_back(sd);\n\n      sort_flags = SORT_REGULAR;\n      ascending = true;\n\n      sd.original = &tvAsVariant(tv);\n      arrays.push_back(Array(sd.original->getArrayData()));\n      sd.array = &arrays.back();\n    } else {\n      int n = toInt32(getArg<KindOfInt64>(ar, i));\n      if (n == SORT_ASC) {\n      } else if (n == SORT_DESC) {\n        ascending = false;\n      } else {\n        sort_flags = n;\n      }\n    }\n  }\n\n  sd.cmp_func = get_cmp_func(sort_flags, ascending);\n  data.push_back(sd);\n\n  return arReturn(ar, Array::MultiSort(data, true));\n}\n\n// HH\\\\dict\nArray HHVM_FUNCTION(HH_dict, const Array& arr) {\n  return arr.toDict();\n}\n\n// HH\\\\vec\nArray HHVM_FUNCTION(HH_vec, const Array& arr) {\n  return arr.toVec();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nstruct ArrayExtension final : Extension {\n  ArrayExtension() : Extension(\"array\") {}\n  void moduleInit() override {\n    HHVM_RC_INT_SAME(UCOL_DEFAULT);\n\n    HHVM_RC_INT_SAME(UCOL_PRIMARY);\n    HHVM_RC_INT_SAME(UCOL_SECONDARY);\n    HHVM_RC_INT_SAME(UCOL_TERTIARY);\n    HHVM_RC_INT_SAME(UCOL_DEFAULT_STRENGTH);\n    HHVM_RC_INT_SAME(UCOL_QUATERNARY);\n    HHVM_RC_INT_SAME(UCOL_IDENTICAL);\n\n    HHVM_RC_INT_SAME(UCOL_OFF);\n    HHVM_RC_INT_SAME(UCOL_ON);\n\n    HHVM_RC_INT_SAME(UCOL_SHIFTED);\n    HHVM_RC_INT_SAME(UCOL_NON_IGNORABLE);\n\n    HHVM_RC_INT_SAME(UCOL_LOWER_FIRST);\n    HHVM_RC_INT_SAME(UCOL_UPPER_FIRST);\n\n    HHVM_RC_INT_SAME(UCOL_FRENCH_COLLATION);\n    HHVM_RC_INT_SAME(UCOL_ALTERNATE_HANDLING);\n    HHVM_RC_INT_SAME(UCOL_CASE_FIRST);\n    HHVM_RC_INT_SAME(UCOL_CASE_LEVEL);\n    HHVM_RC_INT_SAME(UCOL_NORMALIZATION_MODE);\n    HHVM_RC_INT_SAME(UCOL_STRENGTH);\n    HHVM_RC_INT_SAME(UCOL_HIRAGANA_QUATERNARY_MODE);\n    HHVM_RC_INT_SAME(UCOL_NUMERIC_COLLATION);\n\n    HHVM_RC_INT(ARRAY_FILTER_USE_BOTH, 1);\n    HHVM_RC_INT(ARRAY_FILTER_USE_KEY, 2);\n\n    HHVM_RC_INT(CASE_LOWER,      CaseMode::LOWER);\n    HHVM_RC_INT(CASE_UPPER,      CaseMode::UPPER);\n\n    HHVM_RC_INT(COUNT_NORMAL,    CountMode::NORMAL);\n    HHVM_RC_INT(COUNT_RECURSIVE, CountMode::RECURSIVE);\n\n    HHVM_RC_INT_SAME(SORT_ASC);\n    HHVM_RC_INT_SAME(SORT_DESC);\n    HHVM_RC_INT_SAME(SORT_FLAG_CASE);\n    HHVM_RC_INT_SAME(SORT_LOCALE_STRING);\n    HHVM_RC_INT_SAME(SORT_NATURAL);\n    HHVM_RC_INT_SAME(SORT_NUMERIC);\n    HHVM_RC_INT_SAME(SORT_REGULAR);\n    HHVM_RC_INT_SAME(SORT_STRING);\n\n    HHVM_FE(array_change_key_case);\n    HHVM_FE(array_chunk);\n    HHVM_FE(array_column);\n    HHVM_FE(array_combine);\n    HHVM_FE(array_count_values);\n    HHVM_FE(array_fill_keys);\n    HHVM_FE(array_fill);\n    HHVM_FE(array_flip);\n    HHVM_FE(array_key_exists);\n    HHVM_FE(key_exists);\n    HHVM_FE(array_keys);\n    HHVM_FALIAS(__SystemLib\\\\array_map, array_map);\n    HHVM_FE(array_merge_recursive);\n    HHVM_FE(array_merge);\n    HHVM_FE(array_replace_recursive);\n    HHVM_FE(array_replace);\n    HHVM_FE(array_pad);\n    HHVM_FE(array_pop);\n    HHVM_FE(array_product);\n    HHVM_FE(array_push);\n    HHVM_FE(array_rand);\n    HHVM_FE(array_reverse);\n    HHVM_FE(array_search);\n    HHVM_FE(array_shift);\n    HHVM_FE(array_slice);\n    HHVM_FE(array_splice);\n    HHVM_FE(array_sum);\n    HHVM_FE(array_unique);\n    HHVM_FE(array_unshift);\n    HHVM_FE(array_values);\n    HHVM_FE(array_walk_recursive);\n    HHVM_FE(array_walk);\n    HHVM_FE(compact);\n    HHVM_FALIAS(__SystemLib\\\\compact_sl, __SystemLib_compact_sl);\n    HHVM_FE(shuffle);\n    HHVM_FE(count);\n    HHVM_FE(sizeof);\n    HHVM_FE(each);\n    HHVM_FE(current);\n    HHVM_FE(next);\n    HHVM_FE(pos);\n    HHVM_FE(prev);\n    HHVM_FE(reset);\n    HHVM_FE(end);\n    HHVM_FE(key);\n    HHVM_FE(in_array);\n    HHVM_FE(range);\n    HHVM_FE(array_diff);\n    HHVM_FE(array_udiff);\n    HHVM_FE(array_diff_assoc);\n    HHVM_FE(array_diff_uassoc);\n    HHVM_FE(array_udiff_assoc);\n    HHVM_FE(array_udiff_uassoc);\n    HHVM_FE(array_diff_key);\n    HHVM_FE(array_diff_ukey);\n    HHVM_FE(array_intersect);\n    HHVM_FE(array_uintersect);\n    HHVM_FE(array_intersect_assoc);\n    HHVM_FE(array_intersect_uassoc);\n    HHVM_FE(array_uintersect_assoc);\n    HHVM_FE(array_uintersect_uassoc);\n    HHVM_FE(array_intersect_key);\n    HHVM_FE(array_intersect_ukey);\n    HHVM_FE(sort);\n    HHVM_FE(rsort);\n    HHVM_FE(asort);\n    HHVM_FE(arsort);\n    HHVM_FE(ksort);\n    HHVM_FE(krsort);\n    HHVM_FE(usort);\n    HHVM_FE(uasort);\n    HHVM_FE(uksort);\n    HHVM_FE(natsort);\n    HHVM_FE(natcasesort);\n    HHVM_FE(i18n_loc_get_default);\n    HHVM_FE(i18n_loc_set_default);\n    HHVM_FE(i18n_loc_set_attribute);\n    HHVM_FE(i18n_loc_set_strength);\n    HHVM_FE(i18n_loc_get_error_code);\n    HHVM_FE(hphp_array_idx);\n    HHVM_FE(array_multisort);\n    HHVM_FALIAS(HH\\\\dict, HH_dict);\n    HHVM_FALIAS(HH\\\\vec, HH_vec);\n\n    loadSystemlib();\n  }\n} s_array_extension;\n\n}\n", "<?php\n\nfunction test($g) {\n  $GLOBALS['g'] = $GLOBALS;\n\n  array_replace_recursive($GLOBALS, $g);\n\n  $GLOBALS['g'] = $GLOBALS;\n  array_merge_recursive($GLOBALS, $g);\n}\n\nfunction main() {\n  $a = array();\n  $a['g'] = &$a;\n\n  test($a);\n  test($GLOBALS);\n  var_dump(compact($a));\n}\n\nmain();\n", "Warning: array_replace_recursive(): recursion detected in %s/test/slow/array_functions/self_recursive.php on line 6\n\nWarning: array_merge_recursive(): recursion detected in %s/test/slow/array_functions/self_recursive.php on line 9\n\nWarning: array_merge_recursive(): recursion detected in %s/test/slow/array_functions/self_recursive.php on line 9\n\nWarning: array_merge_recursive(): recursion detected in %s/test/slow/array_functions/self_recursive.php on line 9\n\nWarning: array_merge_recursive(): recursion detected in %s/test/slow/array_functions/self_recursive.php on line 9\n\nWarning: array_merge_recursive(): recursion detected in %s/test/slow/array_functions/self_recursive.php on line 9\n\nWarning: compact(): recursion detected in %s/test/slow/array_functions/self_recursive.php on line 18\narray(0) {\n}"], "filenames": ["hphp/runtime/ext/array/ext_array.cpp", "hphp/test/slow/array_functions/self_recursive.php", "hphp/test/slow/array_functions/self_recursive.php.expectf"], "buggy_code_start_loc": [382, 17, 1], "buggy_code_end_loc": [1255, 17, 12], "fixing_code_start_loc": [382, 18, 0], "fixing_code_end_loc": [1265, 19, 16], "type": "NVD-CWE-Other", "message": "Self recursion in compact in Facebook HHVM before 3.15.0 allows attackers to have unspecified impact via unknown vectors.", "other": {"cve": {"id": "CVE-2016-6873", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-17T17:59:01.077", "lastModified": "2017-02-22T17:41:13.930", "vulnStatus": "Analyzed", "evaluatorComment": "<a href=\"http://cwe.mitre.org/data/definitions/674.html\">CWE-674: Uncontrolled Recursion</a>", "descriptions": [{"lang": "en", "value": "Self recursion in compact in Facebook HHVM before 3.15.0 allows attackers to have unspecified impact via unknown vectors."}, {"lang": "es", "value": "Auto recursividad en compact en Facebook HHVM en versiones anteriores a 3.15.0 permite a atacantes tener un impacto no especificado a trav\u00e9s de vectores desconocidos."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.14.5", "matchCriteriaId": "157280C9-2498-4181-BF93-3F1017445394"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/08/11/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/08/19/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/facebook/hhvm/commit/e264f04ae825a5d97758130cf8eec99862517e7e", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/facebook/hhvm/commit/e264f04ae825a5d97758130cf8eec99862517e7e"}}