{"buggy_code": ["/*\n * rfbserver.c - deal with server-side of the RFB protocol.\n */\n\n/*\n *  Copyright (C) 2011-2012 D. R. Commander\n *  Copyright (C) 2005 Rohit Kumar, Johannes E. Schindelin\n *  Copyright (C) 2002 RealVNC Ltd.\n *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.\n *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  \n *  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n#ifdef __STRICT_ANSI__\n#define _BSD_SOURCE\n#define _POSIX_SOURCE\n#define _XOPEN_SOURCE 600\n#endif\n\n#include <stdio.h>\n#include <string.h>\n#include <rfb/rfb.h>\n#include <rfb/rfbregion.h>\n#include \"private.h\"\n#include \"rfb/rfbconfig.h\"\n\n#ifdef LIBVNCSERVER_HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n\n#ifdef WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <io.h>\n#define write(sock,buf,len) send(sock,buf,len,0)\n#else\n#ifdef LIBVNCSERVER_HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#include <pwd.h>\n#ifdef LIBVNCSERVER_HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n#ifdef LIBVNCSERVER_HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#endif\n#endif\n\n#ifdef DEBUGPROTO\n#undef DEBUGPROTO\n#define DEBUGPROTO(x) x\n#else\n#define DEBUGPROTO(x)\n#endif\n#include <stdarg.h>\n#include <scale.h>\n/* stst() */\n#include <sys/types.h>\n#include <sys/stat.h>\n#if LIBVNCSERVER_HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#ifndef WIN32\n/* readdir() */\n#include <dirent.h>\n#endif\n\n/* errno */\n#include <errno.h>\n/* strftime() */\n#include <time.h>\n/* INT_MAX */\n#include <limits.h>\n\n#ifdef LIBVNCSERVER_WITH_WEBSOCKETS\n#include \"rfbssl.h\"\n#endif\n\n#ifdef _MSC_VER\n#define snprintf _snprintf /* Missing in MSVC */\n/* Prevent POSIX deprecation warnings */\n#define close _close\n#define strdup _strdup \n#endif\n\n#ifdef WIN32\n#include <direct.h>\n#ifdef __MINGW32__\n#define mkdir(path, perms) mkdir(path) /* Omit the perms argument to match POSIX signature */\n#else /* MSVC and other windows compilers */\n#define mkdir(path, perms) _mkdir(path) /* Omit the perms argument to match POSIX signature */\n#endif /* __MINGW32__ else... */\n#ifndef S_ISDIR\n#define S_ISDIR(m)\t(((m) & S_IFDIR) == S_IFDIR)\n#endif\n#endif\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n/*\n * Map of quality levels to provide compatibility with TightVNC/TigerVNC\n * clients.  This emulates the behavior of the TigerVNC Server.\n */\n\nstatic const int tight2turbo_qual[10] = {\n   15, 29, 41, 42, 62, 77, 79, 86, 92, 100\n};\n\nstatic const int tight2turbo_subsamp[10] = {\n   1, 1, 1, 2, 2, 2, 0, 0, 0, 0\n};\n#endif\n\nstatic void rfbProcessClientProtocolVersion(rfbClientPtr cl);\nstatic void rfbProcessClientNormalMessage(rfbClientPtr cl);\nstatic void rfbProcessClientInitMessage(rfbClientPtr cl);\n\n#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD\nvoid rfbIncrClientRef(rfbClientPtr cl)\n{\n  LOCK(cl->refCountMutex);\n  cl->refCount++;\n  UNLOCK(cl->refCountMutex);\n}\n\nvoid rfbDecrClientRef(rfbClientPtr cl)\n{\n  LOCK(cl->refCountMutex);\n  cl->refCount--;\n  if(cl->refCount<=0) /* just to be sure also < 0 */\n    TSIGNAL(cl->deleteCond);\n  UNLOCK(cl->refCountMutex);\n}\n#else\nvoid rfbIncrClientRef(rfbClientPtr cl) {}\nvoid rfbDecrClientRef(rfbClientPtr cl) {}\n#endif\n\n#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD\nstatic MUTEX(rfbClientListMutex);\n#endif\n\nstruct rfbClientIterator {\n  rfbClientPtr next;\n  rfbScreenInfoPtr screen;\n  rfbBool closedToo;\n};\n\nvoid\nrfbClientListInit(rfbScreenInfoPtr rfbScreen)\n{\n    if(sizeof(rfbBool)!=1) {\n        /* a sanity check */\n        fprintf(stderr,\"rfbBool's size is not 1 (%d)!\\n\",(int)sizeof(rfbBool));\n\t/* we cannot continue, because rfbBool is supposed to be char everywhere */\n\texit(1);\n    }\n    rfbScreen->clientHead = NULL;\n    INIT_MUTEX(rfbClientListMutex);\n}\n\nrfbClientIteratorPtr\nrfbGetClientIterator(rfbScreenInfoPtr rfbScreen)\n{\n  rfbClientIteratorPtr i =\n    (rfbClientIteratorPtr)malloc(sizeof(struct rfbClientIterator));\n  i->next = NULL;\n  i->screen = rfbScreen;\n  i->closedToo = FALSE;\n  return i;\n}\n\nrfbClientIteratorPtr\nrfbGetClientIteratorWithClosed(rfbScreenInfoPtr rfbScreen)\n{\n  rfbClientIteratorPtr i =\n    (rfbClientIteratorPtr)malloc(sizeof(struct rfbClientIterator));\n  i->next = NULL;\n  i->screen = rfbScreen;\n  i->closedToo = TRUE;\n  return i;\n}\n\nrfbClientPtr\nrfbClientIteratorHead(rfbClientIteratorPtr i)\n{\n#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD\n  if(i->next != 0) {\n    rfbDecrClientRef(i->next);\n    rfbIncrClientRef(i->screen->clientHead);\n  }\n#endif\n  LOCK(rfbClientListMutex);\n  i->next = i->screen->clientHead;\n  UNLOCK(rfbClientListMutex);\n  return i->next;\n}\n\nrfbClientPtr\nrfbClientIteratorNext(rfbClientIteratorPtr i)\n{\n  if(i->next == 0) {\n    LOCK(rfbClientListMutex);\n    i->next = i->screen->clientHead;\n    UNLOCK(rfbClientListMutex);\n  } else {\n    IF_PTHREADS(rfbClientPtr cl = i->next);\n    i->next = i->next->next;\n    IF_PTHREADS(rfbDecrClientRef(cl));\n  }\n\n#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD\n    if(!i->closedToo)\n      while(i->next && i->next->sock<0)\n        i->next = i->next->next;\n    if(i->next)\n      rfbIncrClientRef(i->next);\n#endif\n\n    return i->next;\n}\n\nvoid\nrfbReleaseClientIterator(rfbClientIteratorPtr iterator)\n{\n  IF_PTHREADS(if(iterator->next) rfbDecrClientRef(iterator->next));\n  free(iterator);\n}\n\n\n/*\n * rfbNewClientConnection is called from sockets.c when a new connection\n * comes in.\n */\n\nvoid\nrfbNewClientConnection(rfbScreenInfoPtr rfbScreen,\n                       int sock)\n{\n    rfbNewClient(rfbScreen,sock);\n}\n\n\n/*\n * rfbReverseConnection is called to make an outward\n * connection to a \"listening\" RFB client.\n */\n\nrfbClientPtr\nrfbReverseConnection(rfbScreenInfoPtr rfbScreen,\n                     char *host,\n                     int port)\n{\n    int sock;\n    rfbClientPtr cl;\n\n    if ((sock = rfbConnect(rfbScreen, host, port)) < 0)\n        return (rfbClientPtr)NULL;\n\n    cl = rfbNewClient(rfbScreen, sock);\n\n    if (cl) {\n        cl->reverseConnection = TRUE;\n    }\n\n    return cl;\n}\n\n\nvoid\nrfbSetProtocolVersion(rfbScreenInfoPtr rfbScreen, int major_, int minor_)\n{\n    /* Permit the server to set the version to report */\n    /* TODO: sanity checking */\n    if ((major_==3) && (minor_ > 2 && minor_ < 9))\n    {\n      rfbScreen->protocolMajorVersion = major_;\n      rfbScreen->protocolMinorVersion = minor_;\n    }\n    else\n        rfbLog(\"rfbSetProtocolVersion(%d,%d) set to invalid values\\n\", major_, minor_);\n}\n\n/*\n * rfbNewClient is called when a new connection has been made by whatever\n * means.\n */\n\nstatic rfbClientPtr\nrfbNewTCPOrUDPClient(rfbScreenInfoPtr rfbScreen,\n                     int sock,\n                     rfbBool isUDP)\n{\n    rfbProtocolVersionMsg pv;\n    rfbClientIteratorPtr iterator;\n    rfbClientPtr cl,cl_;\n#ifdef LIBVNCSERVER_IPv6\n    struct sockaddr_storage addr;\n#else\n    struct sockaddr_in addr;\n#endif\n    socklen_t addrlen = sizeof(addr);\n    rfbProtocolExtension* extension;\n\n    cl = (rfbClientPtr)calloc(sizeof(rfbClientRec),1);\n\n    cl->screen = rfbScreen;\n    cl->sock = sock;\n    cl->viewOnly = FALSE;\n    /* setup pseudo scaling */\n    cl->scaledScreen = rfbScreen;\n    cl->scaledScreen->scaledScreenRefCount++;\n\n    rfbResetStats(cl);\n\n    cl->clientData = NULL;\n    cl->clientGoneHook = rfbDoNothingWithClient;\n\n    if(isUDP) {\n      rfbLog(\" accepted UDP client\\n\");\n\t} else {\n#ifdef LIBVNCSERVER_IPv6\n\t\tchar host[1024];\n#endif\n      int one=1;\n      size_t otherClientsCount = 0;\n\n      getpeername(sock, (struct sockaddr *)&addr, &addrlen);\n#ifdef LIBVNCSERVER_IPv6\n      if(getnameinfo((struct sockaddr*)&addr, addrlen, host, sizeof(host), NULL, 0, NI_NUMERICHOST) != 0) {\n\trfbLogPerror(\"rfbNewClient: error in getnameinfo\");\n\tcl->host = strdup(\"\");\n      }\n      else\n\tcl->host = strdup(host);\n#else\n      cl->host = strdup(inet_ntoa(addr.sin_addr));\n#endif\n\n      iterator = rfbGetClientIterator(rfbScreen);\n      while ((cl_ = rfbClientIteratorNext(iterator)) != NULL)\n\t  ++otherClientsCount;\n      rfbReleaseClientIterator(iterator);\n      rfbLog(\"  %lu other clients\\n\", (unsigned long) otherClientsCount);\n\n      if(!rfbSetNonBlocking(sock)) {\n\tclose(sock);\n\treturn NULL;\n      }\n\n      if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,\n\t\t     (char *)&one, sizeof(one)) < 0) {\n\trfbLogPerror(\"setsockopt failed: can't set TCP_NODELAY flag, non TCP socket?\");\n      }\n\n      FD_SET(sock,&(rfbScreen->allFds));\n\t\trfbScreen->maxFd = rfbMax(sock,rfbScreen->maxFd);\n\n      INIT_MUTEX(cl->outputMutex);\n      INIT_MUTEX(cl->refCountMutex);\n      INIT_MUTEX(cl->sendMutex);\n      INIT_COND(cl->deleteCond);\n\n      cl->state = RFB_PROTOCOL_VERSION;\n\n      cl->reverseConnection = FALSE;\n      cl->readyForSetColourMapEntries = FALSE;\n      cl->useCopyRect = FALSE;\n      cl->preferredEncoding = -1;\n      cl->correMaxWidth = 48;\n      cl->correMaxHeight = 48;\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n      cl->zrleData = NULL;\n#endif\n\n      cl->copyRegion = sraRgnCreate();\n      cl->copyDX = 0;\n      cl->copyDY = 0;\n   \n      cl->modifiedRegion =\n\tsraRgnCreateRect(0,0,rfbScreen->width,rfbScreen->height);\n\n      INIT_MUTEX(cl->updateMutex);\n      INIT_COND(cl->updateCond);\n\n      cl->requestedRegion = sraRgnCreate();\n\n      cl->format = cl->screen->serverFormat;\n      cl->translateFn = rfbTranslateNone;\n      cl->translateLookupTable = NULL;\n\n      LOCK(rfbClientListMutex);\n\n      IF_PTHREADS(cl->refCount = 0);\n      cl->next = rfbScreen->clientHead;\n      cl->prev = NULL;\n      if (rfbScreen->clientHead)\n        rfbScreen->clientHead->prev = cl;\n\n      rfbScreen->clientHead = cl;\n      UNLOCK(rfbClientListMutex);\n\n#if defined(LIBVNCSERVER_HAVE_LIBZ) || defined(LIBVNCSERVER_HAVE_LIBPNG)\n      cl->tightQualityLevel = -1;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n      cl->tightCompressLevel = TIGHT_DEFAULT_COMPRESSION;\n      cl->turboSubsampLevel = TURBO_DEFAULT_SUBSAMP;\n      {\n\tint i;\n\tfor (i = 0; i < 4; i++)\n          cl->zsActive[i] = FALSE;\n      }\n#endif\n#endif\n\n      cl->fileTransfer.fd = -1;\n\n      cl->enableCursorShapeUpdates = FALSE;\n      cl->enableCursorPosUpdates = FALSE;\n      cl->useRichCursorEncoding = FALSE;\n      cl->enableLastRectEncoding = FALSE;\n      cl->enableKeyboardLedState = FALSE;\n      cl->enableSupportedMessages = FALSE;\n      cl->enableSupportedEncodings = FALSE;\n      cl->enableServerIdentity = FALSE;\n      cl->lastKeyboardLedState = -1;\n      cl->cursorX = rfbScreen->cursorX;\n      cl->cursorY = rfbScreen->cursorY;\n      cl->useNewFBSize = FALSE;\n      cl->useExtDesktopSize = FALSE;\n      cl->requestedDesktopSizeChange = 0;\n      cl->lastDesktopSizeChangeError = 0;\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n      cl->compStreamInited = FALSE;\n      cl->compStream.total_in = 0;\n      cl->compStream.total_out = 0;\n      cl->compStream.zalloc = Z_NULL;\n      cl->compStream.zfree = Z_NULL;\n      cl->compStream.opaque = Z_NULL;\n\n      cl->zlibCompressLevel = 5;\n#endif\n\n      cl->progressiveSliceY = 0;\n\n      cl->extensions = NULL;\n\n      cl->lastPtrX = -1;\n\n#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD\n      cl->pipe_notify_client_thread[0] = -1;\n      cl->pipe_notify_client_thread[1] = -1;\n#endif\n\n#ifdef LIBVNCSERVER_WITH_WEBSOCKETS\n      /*\n       * Wait a few ms for the client to send WebSockets connection (TLS/SSL or plain)\n       */\n      if (!webSocketsCheck(cl)) {\n        /* Error reporting handled in webSocketsHandshake */\n        rfbCloseClient(cl);\n        rfbClientConnectionGone(cl);\n        return NULL;\n      }\n#endif\n\n      sprintf(pv,rfbProtocolVersionFormat,rfbScreen->protocolMajorVersion, \n              rfbScreen->protocolMinorVersion);\n\n      if (rfbWriteExact(cl, pv, sz_rfbProtocolVersionMsg) < 0) {\n        rfbLogPerror(\"rfbNewClient: write\");\n        rfbCloseClient(cl);\n\trfbClientConnectionGone(cl);\n        return NULL;\n      }\n    }\n\n    for(extension = rfbGetExtensionIterator(); extension;\n\t    extension=extension->next) {\n\tvoid* data = NULL;\n\t/* if the extension does not have a newClient method, it wants\n\t * to be initialized later. */\n\tif(extension->newClient && extension->newClient(cl, &data))\n\t\trfbEnableExtension(cl, extension, data);\n    }\n    rfbReleaseExtensionIterator();\n\n    switch (cl->screen->newClientHook(cl)) {\n    case RFB_CLIENT_ON_HOLD:\n\t    cl->onHold = TRUE;\n\t    break;\n    case RFB_CLIENT_ACCEPT:\n\t    cl->onHold = FALSE;\n\t    break;\n    case RFB_CLIENT_REFUSE:\n\t    rfbCloseClient(cl);\n\t    rfbClientConnectionGone(cl);\n\t    cl = NULL;\n\t    break;\n    }\n    return cl;\n}\n\nrfbClientPtr\nrfbNewClient(rfbScreenInfoPtr rfbScreen,\n             int sock)\n{\n  return(rfbNewTCPOrUDPClient(rfbScreen,sock,FALSE));\n}\n\nrfbClientPtr\nrfbNewUDPClient(rfbScreenInfoPtr rfbScreen)\n{\n  return((rfbScreen->udpClient=\n\t  rfbNewTCPOrUDPClient(rfbScreen,rfbScreen->udpSock,TRUE)));\n}\n\n/*\n * rfbClientConnectionGone is called from sockets.c just after a connection\n * has gone away.\n */\n\nvoid\nrfbClientConnectionGone(rfbClientPtr cl)\n{\n#if defined(LIBVNCSERVER_HAVE_LIBZ) && defined(LIBVNCSERVER_HAVE_LIBJPEG)\n    int i;\n#endif\n\n    LOCK(rfbClientListMutex);\n\n    if (cl->prev)\n        cl->prev->next = cl->next;\n    else\n        cl->screen->clientHead = cl->next;\n    if (cl->next)\n        cl->next->prev = cl->prev;\n\n    UNLOCK(rfbClientListMutex);\n\n#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD\n    if(cl->screen->backgroundLoop != FALSE) {\n      int i;\n      do {\n\tLOCK(cl->refCountMutex);\n\ti=cl->refCount;\n\tif(i>0)\n\t  WAIT(cl->deleteCond,cl->refCountMutex);\n\tUNLOCK(cl->refCountMutex);\n      } while(i>0);\n    }\n#endif\n\n    if(cl->sock>=0)\n\tclose(cl->sock);\n\n    if (cl->scaledScreen!=NULL)\n        cl->scaledScreen->scaledScreenRefCount--;\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n    rfbFreeZrleData(cl);\n#endif\n\n    rfbFreeUltraData(cl);\n\n    /* free buffers holding pixel data before and after encoding */\n    free(cl->beforeEncBuf);\n    free(cl->afterEncBuf);\n\n    if(cl->sock>=0)\n       FD_CLR(cl->sock,&(cl->screen->allFds));\n\n    cl->clientGoneHook(cl);\n\n    rfbLog(\"Client %s gone\\n\",cl->host);\n    free(cl->host);\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n    /* Release the compression state structures if any. */\n    if ( cl->compStreamInited ) {\n\tdeflateEnd( &(cl->compStream) );\n    }\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n    for (i = 0; i < 4; i++) {\n\tif (cl->zsActive[i])\n\t    deflateEnd(&cl->zsStruct[i]);\n    }\n#endif\n#endif\n\n    if (cl->screen->pointerClient == cl)\n        cl->screen->pointerClient = NULL;\n\n    sraRgnDestroy(cl->modifiedRegion);\n    sraRgnDestroy(cl->requestedRegion);\n    sraRgnDestroy(cl->copyRegion);\n\n    if (cl->translateLookupTable) free(cl->translateLookupTable);\n\n    TINI_COND(cl->updateCond);\n    TINI_MUTEX(cl->updateMutex);\n\n    /* make sure outputMutex is unlocked before destroying */\n    LOCK(cl->outputMutex);\n    UNLOCK(cl->outputMutex);\n    TINI_MUTEX(cl->outputMutex);\n\n    LOCK(cl->sendMutex);\n    UNLOCK(cl->sendMutex);\n    TINI_MUTEX(cl->sendMutex);\n\n#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD\n    close(cl->pipe_notify_client_thread[0]);\n    close(cl->pipe_notify_client_thread[1]);\n#endif\n\n    rfbPrintStats(cl);\n    rfbResetStats(cl);\n\n    free(cl);\n}\n\n\n/*\n * rfbProcessClientMessage is called when there is data to read from a client.\n */\n\nvoid\nrfbProcessClientMessage(rfbClientPtr cl)\n{\n    switch (cl->state) {\n    case RFB_PROTOCOL_VERSION:\n        rfbProcessClientProtocolVersion(cl);\n        return;\n    case RFB_SECURITY_TYPE:\n        rfbProcessClientSecurityType(cl);\n        return;\n    case RFB_AUTHENTICATION:\n        rfbAuthProcessClientMessage(cl);\n        return;\n    case RFB_INITIALISATION:\n    case RFB_INITIALISATION_SHARED:\n        rfbProcessClientInitMessage(cl);\n        return;\n    default:\n        rfbProcessClientNormalMessage(cl);\n        return;\n    }\n}\n\n\n/*\n * rfbProcessClientProtocolVersion is called when the client sends its\n * protocol version.\n */\n\nstatic void\nrfbProcessClientProtocolVersion(rfbClientPtr cl)\n{\n    rfbProtocolVersionMsg pv;\n    int n, major_, minor_;\n\n    if ((n = rfbReadExact(cl, pv, sz_rfbProtocolVersionMsg)) <= 0) {\n        if (n == 0)\n            rfbLog(\"rfbProcessClientProtocolVersion: client gone\\n\");\n        else\n            rfbLogPerror(\"rfbProcessClientProtocolVersion: read\");\n        rfbCloseClient(cl);\n        return;\n    }\n\n    pv[sz_rfbProtocolVersionMsg] = 0;\n    if (sscanf(pv,rfbProtocolVersionFormat,&major_,&minor_) != 2) {\n\trfbErr(\"rfbProcessClientProtocolVersion: not a valid RFB client: %s\\n\", pv);\n\trfbCloseClient(cl);\n\treturn;\n    }\n    rfbLog(\"Client Protocol Version %d.%d\\n\", major_, minor_);\n\n    if (major_ != rfbProtocolMajorVersion) {\n        rfbErr(\"RFB protocol version mismatch - server %d.%d, client %d.%d\",\n                cl->screen->protocolMajorVersion, cl->screen->protocolMinorVersion,\n                major_,minor_);\n        rfbCloseClient(cl);\n        return;\n    }\n\n    /* Check for the minor version use either of the two standard version of RFB */\n    /*\n     * UltraVNC Viewer detects FileTransfer compatible servers via rfb versions\n     * 3.4, 3.6, 3.14, 3.16\n     * It's a bad method, but it is what they use to enable features...\n     * maintaining RFB version compatibility across multiple servers is a pain\n     * Should use something like ServerIdentity encoding\n     */\n    cl->protocolMajorVersion = major_;\n    cl->protocolMinorVersion = minor_;\n    \n    rfbLog(\"Protocol version sent %d.%d, using %d.%d\\n\",\n              major_, minor_, rfbProtocolMajorVersion, cl->protocolMinorVersion);\n\n    rfbAuthNewClient(cl);\n}\n\n\nvoid\nrfbClientSendString(rfbClientPtr cl, const char *reason)\n{\n    char *buf;\n    int len = strlen(reason);\n\n    rfbLog(\"rfbClientSendString(\\\"%s\\\")\\n\", reason);\n\n    buf = (char *)malloc(4 + len);\n    ((uint32_t *)buf)[0] = Swap32IfLE(len);\n    memcpy(buf + 4, reason, len);\n\n    if (rfbWriteExact(cl, buf, 4 + len) < 0)\n        rfbLogPerror(\"rfbClientSendString: write\");\n    free(buf);\n\n    rfbCloseClient(cl);\n}\n\n/*\n * rfbClientConnFailed is called when a client connection has failed either\n * because it talks the wrong protocol or it has failed authentication.\n */\n\nvoid\nrfbClientConnFailed(rfbClientPtr cl,\n                    const char *reason)\n{\n    char *buf;\n    int len = strlen(reason);\n\n    rfbLog(\"rfbClientConnFailed(\\\"%s\\\")\\n\", reason);\n\n    buf = (char *)malloc(8 + len);\n    ((uint32_t *)buf)[0] = Swap32IfLE(rfbConnFailed);\n    ((uint32_t *)buf)[1] = Swap32IfLE(len);\n    memcpy(buf + 8, reason, len);\n\n    if (rfbWriteExact(cl, buf, 8 + len) < 0)\n        rfbLogPerror(\"rfbClientConnFailed: write\");\n    free(buf);\n\n    rfbCloseClient(cl);\n}\n\n\n/*\n * rfbProcessClientInitMessage is called when the client sends its\n * initialisation message.\n */\n\nstatic void\nrfbProcessClientInitMessage(rfbClientPtr cl)\n{\n    rfbClientInitMsg ci;\n    union {\n        char buf[256];\n        rfbServerInitMsg si;\n    } u;\n    int len, n;\n    rfbClientIteratorPtr iterator;\n    rfbClientPtr otherCl;\n    rfbExtensionData* extension;\n\n    if (cl->state == RFB_INITIALISATION_SHARED) {\n        /* In this case behave as though an implicit ClientInit message has\n         * already been received with a shared-flag of true. */\n        ci.shared = 1;\n        /* Avoid the possibility of exposing the RFB_INITIALISATION_SHARED\n         * state to calling software. */\n        cl->state = RFB_INITIALISATION;\n    } else {\n        if ((n = rfbReadExact(cl, (char *)&ci,sz_rfbClientInitMsg)) <= 0) {\n            if (n == 0)\n                rfbLog(\"rfbProcessClientInitMessage: client gone\\n\");\n            else\n                rfbLogPerror(\"rfbProcessClientInitMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n    }\n\n    memset(u.buf,0,sizeof(u.buf));\n\n    u.si.framebufferWidth = Swap16IfLE(cl->screen->width);\n    u.si.framebufferHeight = Swap16IfLE(cl->screen->height);\n    u.si.format = cl->screen->serverFormat;\n    u.si.format.redMax = Swap16IfLE(u.si.format.redMax);\n    u.si.format.greenMax = Swap16IfLE(u.si.format.greenMax);\n    u.si.format.blueMax = Swap16IfLE(u.si.format.blueMax);\n\n    strncpy(u.buf + sz_rfbServerInitMsg, cl->screen->desktopName, 127);\n    len = strlen(u.buf + sz_rfbServerInitMsg);\n    u.si.nameLength = Swap32IfLE(len);\n\n    if (rfbWriteExact(cl, u.buf, sz_rfbServerInitMsg + len) < 0) {\n        rfbLogPerror(\"rfbProcessClientInitMessage: write\");\n        rfbCloseClient(cl);\n        return;\n    }\n\n    for(extension = cl->extensions; extension;) {\n\trfbExtensionData* next = extension->next;\n\tif(extension->extension->init &&\n\t\t!extension->extension->init(cl, extension->data))\n\t    /* extension requested that it be removed */\n\t    rfbDisableExtension(cl, extension->extension);\n\textension = next;\n    }\n\n    cl->state = RFB_NORMAL;\n\n    if (!cl->reverseConnection &&\n                        (cl->screen->neverShared || (!cl->screen->alwaysShared && !ci.shared))) {\n\n        if (cl->screen->dontDisconnect) {\n            iterator = rfbGetClientIterator(cl->screen);\n            while ((otherCl = rfbClientIteratorNext(iterator)) != NULL) {\n                if ((otherCl != cl) && (otherCl->state == RFB_NORMAL)) {\n                    rfbLog(\"-dontdisconnect: Not shared & existing client\\n\");\n                    rfbLog(\"  refusing new client %s\\n\", cl->host);\n                    rfbCloseClient(cl);\n                    rfbReleaseClientIterator(iterator);\n                    return;\n                }\n            }\n            rfbReleaseClientIterator(iterator);\n        } else {\n            iterator = rfbGetClientIterator(cl->screen);\n            while ((otherCl = rfbClientIteratorNext(iterator)) != NULL) {\n                if ((otherCl != cl) && (otherCl->state == RFB_NORMAL)) {\n                    rfbLog(\"Not shared - closing connection to client %s\\n\",\n                           otherCl->host);\n                    rfbCloseClient(otherCl);\n                }\n            }\n            rfbReleaseClientIterator(iterator);\n        }\n    }\n}\n\n/* The values come in based on the scaled screen, we need to convert them to\n * values based on the man screen's coordinate system\n */\nstatic rfbBool rectSwapIfLEAndClip(uint16_t* x,uint16_t* y,uint16_t* w,uint16_t* h,\n\t\trfbClientPtr cl)\n{\n\tint x1=Swap16IfLE(*x);\n\tint y1=Swap16IfLE(*y);\n\tint w1=Swap16IfLE(*w);\n\tint h1=Swap16IfLE(*h);\n\n\trfbScaledCorrection(cl->scaledScreen, cl->screen, &x1, &y1, &w1, &h1, \"rectSwapIfLEAndClip\");\n\t*x = x1;\n\t*y = y1;\n\t*w = w1;\n\t*h = h1;\n\n\tif(*w>cl->screen->width-*x)\n\t\t*w=cl->screen->width-*x;\n\t/* possible underflow */\n\tif(*w>cl->screen->width-*x)\n\t\treturn FALSE;\n\tif(*h>cl->screen->height-*y)\n\t\t*h=cl->screen->height-*y;\n\tif(*h>cl->screen->height-*y)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\n/*\n * Send keyboard state (PointerPos pseudo-encoding).\n */\n\nrfbBool\nrfbSendKeyboardLedState(rfbClientPtr cl)\n{\n    rfbFramebufferUpdateRectHeader rect;\n\n    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader > UPDATE_BUF_SIZE) {\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n    }\n\n    rect.encoding = Swap32IfLE(rfbEncodingKeyboardLedState);\n    rect.r.x = Swap16IfLE(cl->lastKeyboardLedState);\n    rect.r.y = 0;\n    rect.r.w = 0;\n    rect.r.h = 0;\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,\n        sz_rfbFramebufferUpdateRectHeader);\n    cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n    rfbStatRecordEncodingSent(cl, rfbEncodingKeyboardLedState, sz_rfbFramebufferUpdateRectHeader, sz_rfbFramebufferUpdateRectHeader);\n\n    if (!rfbSendUpdateBuf(cl))\n        return FALSE;\n\n    return TRUE;\n}\n\n\n#define rfbSetBit(buffer, position)  (buffer[(position & 255) / 8] |= (1 << (position % 8)))\n\n/*\n * Send rfbEncodingSupportedMessages.\n */\n\nrfbBool\nrfbSendSupportedMessages(rfbClientPtr cl)\n{\n    rfbFramebufferUpdateRectHeader rect;\n    rfbSupportedMessages msgs;\n\n    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader\n                  + sz_rfbSupportedMessages > UPDATE_BUF_SIZE) {\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n    }\n\n    rect.encoding = Swap32IfLE(rfbEncodingSupportedMessages);\n    rect.r.x = 0;\n    rect.r.y = 0;\n    rect.r.w = Swap16IfLE(sz_rfbSupportedMessages);\n    rect.r.h = 0;\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,\n        sz_rfbFramebufferUpdateRectHeader);\n    cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n    memset((char *)&msgs, 0, sz_rfbSupportedMessages);\n    rfbSetBit(msgs.client2server, rfbSetPixelFormat);\n    rfbSetBit(msgs.client2server, rfbFixColourMapEntries);\n    rfbSetBit(msgs.client2server, rfbSetEncodings);\n    rfbSetBit(msgs.client2server, rfbFramebufferUpdateRequest);\n    rfbSetBit(msgs.client2server, rfbKeyEvent);\n    rfbSetBit(msgs.client2server, rfbPointerEvent);\n    rfbSetBit(msgs.client2server, rfbClientCutText);\n    rfbSetBit(msgs.client2server, rfbFileTransfer);\n    rfbSetBit(msgs.client2server, rfbSetScale);\n    /*rfbSetBit(msgs.client2server, rfbSetServerInput);  */\n    /*rfbSetBit(msgs.client2server, rfbSetSW);           */\n    /*rfbSetBit(msgs.client2server, rfbTextChat);        */\n    rfbSetBit(msgs.client2server, rfbPalmVNCSetScaleFactor);\n\n    rfbSetBit(msgs.server2client, rfbFramebufferUpdate);\n    rfbSetBit(msgs.server2client, rfbSetColourMapEntries);\n    rfbSetBit(msgs.server2client, rfbBell);\n    rfbSetBit(msgs.server2client, rfbServerCutText);\n    rfbSetBit(msgs.server2client, rfbResizeFrameBuffer);\n    rfbSetBit(msgs.server2client, rfbPalmVNCReSizeFrameBuffer);\n    rfbSetBit(msgs.client2server, rfbSetDesktopSize);\n\n    if (cl->screen->xvpHook) {\n        rfbSetBit(msgs.client2server, rfbXvp);\n        rfbSetBit(msgs.server2client, rfbXvp);\n    }\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&msgs, sz_rfbSupportedMessages);\n    cl->ublen += sz_rfbSupportedMessages;\n\n    rfbStatRecordEncodingSent(cl, rfbEncodingSupportedMessages,\n        sz_rfbFramebufferUpdateRectHeader+sz_rfbSupportedMessages,\n        sz_rfbFramebufferUpdateRectHeader+sz_rfbSupportedMessages);\n    if (!rfbSendUpdateBuf(cl))\n        return FALSE;\n\n    return TRUE;\n}\n\n\n\n/*\n * Send rfbEncodingSupportedEncodings.\n */\n\nrfbBool\nrfbSendSupportedEncodings(rfbClientPtr cl)\n{\n    rfbFramebufferUpdateRectHeader rect;\n    static uint32_t supported[] = {\n        rfbEncodingRaw,\n\trfbEncodingCopyRect,\n\trfbEncodingRRE,\n\trfbEncodingCoRRE,\n\trfbEncodingHextile,\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\trfbEncodingZlib,\n\trfbEncodingZRLE,\n\trfbEncodingZYWRLE,\n#endif\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\trfbEncodingTight,\n#endif\n#ifdef LIBVNCSERVER_HAVE_LIBPNG\n\trfbEncodingTightPng,\n#endif\n\trfbEncodingUltra,\n\trfbEncodingUltraZip,\n\trfbEncodingXCursor,\n\trfbEncodingRichCursor,\n\trfbEncodingPointerPos,\n\trfbEncodingLastRect,\n\trfbEncodingNewFBSize,\n\trfbEncodingExtDesktopSize,\n\trfbEncodingKeyboardLedState,\n\trfbEncodingSupportedMessages,\n\trfbEncodingSupportedEncodings,\n\trfbEncodingServerIdentity,\n    };\n    uint32_t nEncodings = sizeof(supported) / sizeof(supported[0]), i;\n\n    /* think rfbSetEncodingsMsg */\n\n    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader\n                  + (nEncodings * sizeof(uint32_t)) > UPDATE_BUF_SIZE) {\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n    }\n\n    rect.encoding = Swap32IfLE(rfbEncodingSupportedEncodings);\n    rect.r.x = 0;\n    rect.r.y = 0;\n    rect.r.w = Swap16IfLE(nEncodings * sizeof(uint32_t));\n    rect.r.h = Swap16IfLE(nEncodings);\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,\n        sz_rfbFramebufferUpdateRectHeader);\n    cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n    for (i = 0; i < nEncodings; i++) {\n        uint32_t encoding = Swap32IfLE(supported[i]);\n\tmemcpy(&cl->updateBuf[cl->ublen], (char *)&encoding, sizeof(encoding));\n\tcl->ublen += sizeof(encoding);\n    }\n\n    rfbStatRecordEncodingSent(cl, rfbEncodingSupportedEncodings,\n        sz_rfbFramebufferUpdateRectHeader+(nEncodings * sizeof(uint32_t)),\n        sz_rfbFramebufferUpdateRectHeader+(nEncodings * sizeof(uint32_t)));\n\n    if (!rfbSendUpdateBuf(cl))\n        return FALSE;\n\n    return TRUE;\n}\n\n\nvoid\nrfbSetServerVersionIdentity(rfbScreenInfoPtr screen, char *fmt, ...)\n{\n    char buffer[256];\n    va_list ap;\n    \n    va_start(ap, fmt);\n    vsnprintf(buffer, sizeof(buffer)-1, fmt, ap);\n    va_end(ap);\n    \n    if (screen->versionString!=NULL) free(screen->versionString);\n    screen->versionString = strdup(buffer);\n}\n\n/*\n * Send rfbEncodingServerIdentity.\n */\n\nrfbBool\nrfbSendServerIdentity(rfbClientPtr cl)\n{\n    rfbFramebufferUpdateRectHeader rect;\n    char buffer[512];\n\n    /* tack on our library version */\n    snprintf(buffer,sizeof(buffer)-1, \"%s (%s)\", \n        (cl->screen->versionString==NULL ? \"unknown\" : cl->screen->versionString),\n        LIBVNCSERVER_PACKAGE_STRING);\n\n    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader\n                  + (strlen(buffer)+1) > UPDATE_BUF_SIZE) {\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n    }\n\n    rect.encoding = Swap32IfLE(rfbEncodingServerIdentity);\n    rect.r.x = 0;\n    rect.r.y = 0;\n    rect.r.w = Swap16IfLE(strlen(buffer)+1);\n    rect.r.h = 0;\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,\n        sz_rfbFramebufferUpdateRectHeader);\n    cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n    memcpy(&cl->updateBuf[cl->ublen], buffer, strlen(buffer)+1);\n    cl->ublen += strlen(buffer)+1;\n\n    rfbStatRecordEncodingSent(cl, rfbEncodingServerIdentity,\n        sz_rfbFramebufferUpdateRectHeader+strlen(buffer)+1,\n        sz_rfbFramebufferUpdateRectHeader+strlen(buffer)+1);\n    \n\n    if (!rfbSendUpdateBuf(cl))\n        return FALSE;\n\n    return TRUE;\n}\n\n/*\n * Send an xvp server message\n */\n\nrfbBool\nrfbSendXvp(rfbClientPtr cl, uint8_t version, uint8_t code)\n{\n    rfbXvpMsg xvp;\n\n    xvp.type = rfbXvp;\n    xvp.pad = 0;\n    xvp.version = version;\n    xvp.code = code;\n\n    LOCK(cl->sendMutex);\n    if (rfbWriteExact(cl, (char *)&xvp, sz_rfbXvpMsg) < 0) {\n      rfbLogPerror(\"rfbSendXvp: write\");\n      rfbCloseClient(cl);\n    }\n    UNLOCK(cl->sendMutex);\n\n    rfbStatRecordMessageSent(cl, rfbXvp, sz_rfbXvpMsg, sz_rfbXvpMsg);\n\n    return TRUE;\n}\n\n\nrfbBool rfbSendTextChatMessage(rfbClientPtr cl, uint32_t length, char *buffer)\n{\n    rfbTextChatMsg tc;\n    int bytesToSend=0;\n\n    memset((char *)&tc, 0, sizeof(tc)); \n    tc.type = rfbTextChat;\n    tc.length = Swap32IfLE(length);\n    \n    switch(length) {\n    case rfbTextChatOpen:\n    case rfbTextChatClose:\n    case rfbTextChatFinished:\n        bytesToSend=0;\n        break;\n    default:\n        bytesToSend=length;\n        if (bytesToSend>rfbTextMaxSize)\n            bytesToSend=rfbTextMaxSize;\n    }\n\n    if (cl->ublen + sz_rfbTextChatMsg + bytesToSend > UPDATE_BUF_SIZE) {\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n    }\n    \n    memcpy(&cl->updateBuf[cl->ublen], (char *)&tc, sz_rfbTextChatMsg);\n    cl->ublen += sz_rfbTextChatMsg;\n    if (bytesToSend>0) {\n        memcpy(&cl->updateBuf[cl->ublen], buffer, bytesToSend);\n        cl->ublen += bytesToSend;    \n    }\n    rfbStatRecordMessageSent(cl, rfbTextChat, sz_rfbTextChatMsg+bytesToSend, sz_rfbTextChatMsg+bytesToSend);\n\n    if (!rfbSendUpdateBuf(cl))\n        return FALSE;\n        \n    return TRUE;\n}\n\n#define FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(msg, cl, ret) \\\n\tif ((cl->screen->getFileTransferPermission != NULL \\\n\t    && cl->screen->getFileTransferPermission(cl) != TRUE) \\\n\t    || cl->screen->permitFileTransfer != TRUE) { \\\n\t\trfbLog(\"%sUltra File Transfer is disabled, dropping client: %s\\n\", msg, cl->host); \\\n\t\trfbCloseClient(cl); \\\n\t\treturn ret; \\\n\t}\n\nint DB = 1;\n\nrfbBool rfbSendFileTransferMessage(rfbClientPtr cl, uint8_t contentType, uint8_t contentParam, uint32_t size, uint32_t length, const char *buffer)\n{\n    rfbFileTransferMsg ft;\n    ft.type = rfbFileTransfer;\n    ft.contentType = contentType;\n    ft.contentParam = contentParam;\n    ft.pad          = 0; /* UltraVNC did not Swap16LE(ft.contentParam) (Looks like it might be BigEndian) */\n    ft.size         = Swap32IfLE(size);\n    ft.length       = Swap32IfLE(length);\n    \n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, FALSE);\n    /*\n    rfbLog(\"rfbSendFileTransferMessage( %dtype, %dparam, %dsize, %dlen, %p)\\n\", contentType, contentParam, size, length, buffer);\n    */\n    LOCK(cl->sendMutex);\n    if (rfbWriteExact(cl, (char *)&ft, sz_rfbFileTransferMsg) < 0) {\n        rfbLogPerror(\"rfbSendFileTransferMessage: write\");\n        rfbCloseClient(cl);\n        UNLOCK(cl->sendMutex);\n        return FALSE;\n    }\n\n    if (length>0)\n    {\n        if (rfbWriteExact(cl, buffer, length) < 0) {\n            rfbLogPerror(\"rfbSendFileTransferMessage: write\");\n            rfbCloseClient(cl);\n            UNLOCK(cl->sendMutex);\n            return FALSE;\n        }\n    }\n    UNLOCK(cl->sendMutex);\n\n    rfbStatRecordMessageSent(cl, rfbFileTransfer, sz_rfbFileTransferMsg+length, sz_rfbFileTransferMsg+length);\n\n    return TRUE;\n}\n\n\n/*\n * UltraVNC uses Windows Structures\n */\n#define MAX_PATH 260\n\ntypedef struct {\n    uint32_t dwLowDateTime;\n    uint32_t dwHighDateTime;\n} RFB_FILETIME; \n\ntypedef struct {\n    uint32_t dwFileAttributes;\n    RFB_FILETIME ftCreationTime;\n    RFB_FILETIME ftLastAccessTime;\n    RFB_FILETIME ftLastWriteTime;\n    uint32_t nFileSizeHigh;\n    uint32_t nFileSizeLow;\n    uint32_t dwReserved0;\n    uint32_t dwReserved1;\n    uint8_t  cFileName[ MAX_PATH ];\n    uint8_t  cAlternateFileName[ 14 ];\n} RFB_FIND_DATA;\n\n#define RFB_FILE_ATTRIBUTE_READONLY   0x1\n#define RFB_FILE_ATTRIBUTE_HIDDEN     0x2\n#define RFB_FILE_ATTRIBUTE_SYSTEM     0x4\n#define RFB_FILE_ATTRIBUTE_DIRECTORY  0x10\n#define RFB_FILE_ATTRIBUTE_ARCHIVE    0x20\n#define RFB_FILE_ATTRIBUTE_NORMAL     0x80\n#define RFB_FILE_ATTRIBUTE_TEMPORARY  0x100\n#define RFB_FILE_ATTRIBUTE_COMPRESSED 0x800\n\nrfbBool rfbFilenameTranslate2UNIX(rfbClientPtr cl, /* in */ char *path, /* out */ char *unixPath, size_t unixPathMaxLen)\n{\n    int x;\n    char *home=NULL;\n\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, FALSE);\n\n    /*\n     * Do not use strncpy() - truncating the file name would probably have undesirable side effects\n     * Instead check if destination buffer is big enough\n     */\n    if (strlen(path) >= unixPathMaxLen)\n      return FALSE;\n\n    /* C: */\n    if (path[0]=='C' && path[1]==':')\n      strcpy(unixPath, &path[2]);\n    else\n    {\n      home = getenv(\"HOME\");\n      if (home!=NULL)\n      {\n        /* Re-check buffer size */\n        if ((strlen(path) + strlen(home) + 1) >= unixPathMaxLen)\n          return FALSE;\n\n        strcpy(unixPath, home);\n        strcat(unixPath,\"/\");\n        strcat(unixPath, path);\n      }\n      else\n        strcpy(unixPath, path);\n    }\n    for (x=0;x<strlen(unixPath);x++)\n      if (unixPath[x]=='\\\\') unixPath[x]='/';\n    return TRUE;\n}\n\nrfbBool rfbFilenameTranslate2DOS(rfbClientPtr cl, char *unixPath, char *path)\n{\n    int x;\n\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, FALSE);\n\n    sprintf(path,\"C:%s\", unixPath);\n    for (x=2;x<strlen(path);x++)\n        if (path[x]=='/') path[x]='\\\\';\n    return TRUE;\n}\n\nrfbBool rfbSendDirContent(rfbClientPtr cl, int length, char *buffer)\n{\n    char retfilename[MAX_PATH];\n    char path[MAX_PATH];\n    struct stat statbuf;\n    RFB_FIND_DATA win32filename;\n    int nOptLen = 0, retval=0;\n#ifdef WIN32\n    WIN32_FIND_DATAA winFindData;\n    HANDLE findHandle;\n    int pathLen, basePathLength;\n    char *basePath;\n#else\n    DIR *dirp=NULL;\n    struct dirent *direntp=NULL;\n#endif\n\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, FALSE);\n\n    /* Client thinks we are Winblows */\n    if (!rfbFilenameTranslate2UNIX(cl, buffer, path, sizeof(path)))\n        return FALSE;\n\n    if (DB) rfbLog(\"rfbProcessFileTransfer() rfbDirContentRequest: rfbRDirContent: \\\"%s\\\"->\\\"%s\\\"\\n\",buffer, path);\n\n#ifdef WIN32\n    // Create a search string, like C:\\folder\\*\n\n    pathLen = strlen(path);\n    basePath = malloc(pathLen + 3);\n    memcpy(basePath, path, pathLen);\n    basePathLength = pathLen;\n    basePath[basePathLength] = '\\\\';\n    basePath[basePathLength + 1] = '*';\n    basePath[basePathLength + 2] = '\\0';\n\n    // Start a search\n    memset(&winFindData, 0, sizeof(winFindData));\n    findHandle = FindFirstFileA(path, &winFindData);\n    free(basePath);\n\n    if (findHandle == INVALID_HANDLE_VALUE)\n#else\n    dirp=opendir(path);\n    if (dirp==NULL)\n#endif\n        return rfbSendFileTransferMessage(cl, rfbDirPacket, rfbADirectory, 0, 0, NULL);\n\n    /* send back the path name (necessary for links) */\n    if (rfbSendFileTransferMessage(cl, rfbDirPacket, rfbADirectory, 0, length, buffer)==FALSE) return FALSE;\n\n#ifdef WIN32\n    while (findHandle != INVALID_HANDLE_VALUE)\n#else\n    for (direntp=readdir(dirp); direntp!=NULL; direntp=readdir(dirp))\n#endif\n    {\n        /* get stats */\n#ifdef WIN32\n    snprintf(retfilename,sizeof(retfilename),\"%s/%s\", path, winFindData.cFileName);\n#else\n    snprintf(retfilename,sizeof(retfilename),\"%s/%s\", path, direntp->d_name);\n#endif\n        retval = stat(retfilename, &statbuf);\n\n        if (retval==0)\n        {\n            memset((char *)&win32filename, 0, sizeof(win32filename));\n#ifdef WIN32\n            win32filename.dwFileAttributes = winFindData.dwFileAttributes;\n            win32filename.ftCreationTime.dwLowDateTime = winFindData.ftCreationTime.dwLowDateTime;\n            win32filename.ftCreationTime.dwHighDateTime = winFindData.ftCreationTime.dwHighDateTime;\n            win32filename.ftLastAccessTime.dwLowDateTime = winFindData.ftLastAccessTime.dwLowDateTime;\n            win32filename.ftLastAccessTime.dwHighDateTime = winFindData.ftLastAccessTime.dwHighDateTime;\n            win32filename.ftLastWriteTime.dwLowDateTime = winFindData.ftLastWriteTime.dwLowDateTime;\n            win32filename.ftLastWriteTime.dwHighDateTime = winFindData.ftLastWriteTime.dwHighDateTime;\n            win32filename.nFileSizeLow = winFindData.nFileSizeLow;\n            win32filename.nFileSizeHigh = winFindData.nFileSizeHigh;\n            win32filename.dwReserved0 = winFindData.dwReserved0;\n            win32filename.dwReserved1 = winFindData.dwReserved1;\n            strcpy((char *)win32filename.cFileName, winFindData.cFileName);\n            strcpy((char *)win32filename.cAlternateFileName, winFindData.cAlternateFileName);\n#else\n            win32filename.dwFileAttributes = Swap32IfBE(RFB_FILE_ATTRIBUTE_NORMAL);\n            if (S_ISDIR(statbuf.st_mode))\n                win32filename.dwFileAttributes = Swap32IfBE(RFB_FILE_ATTRIBUTE_DIRECTORY);\n            win32filename.ftCreationTime.dwLowDateTime = Swap32IfBE(statbuf.st_ctime);   /* Intel Order */\n            win32filename.ftCreationTime.dwHighDateTime = 0;\n            win32filename.ftLastAccessTime.dwLowDateTime = Swap32IfBE(statbuf.st_atime); /* Intel Order */\n            win32filename.ftLastAccessTime.dwHighDateTime = 0;\n            win32filename.ftLastWriteTime.dwLowDateTime = Swap32IfBE(statbuf.st_mtime);  /* Intel Order */\n            win32filename.ftLastWriteTime.dwHighDateTime = 0;\n            win32filename.nFileSizeLow = Swap32IfBE(statbuf.st_size); /* Intel Order */\n            win32filename.nFileSizeHigh = 0;\n            win32filename.dwReserved0 = 0;\n            win32filename.dwReserved1 = 0;\n\n            /* If this had the full path, we would need to translate to DOS format (\"C:\\\") */\n            /* rfbFilenameTranslate2DOS(cl, retfilename, win32filename.cFileName); */\n            strcpy((char *)win32filename.cFileName, direntp->d_name);\n#endif\n            \n            /* Do not show hidden files (but show how to move up the tree) */\n            if ((strcmp((char *)win32filename.cFileName, \"..\")==0) || (win32filename.cFileName[0]!='.'))\n            {\n                nOptLen = sizeof(RFB_FIND_DATA) - MAX_PATH - 14 + strlen((char *)win32filename.cFileName);\n                /*\n                rfbLog(\"rfbProcessFileTransfer() rfbDirContentRequest: rfbRDirContent: Sending \\\"%s\\\"\\n\", (char *)win32filename.cFileName);\n                */\n                if (rfbSendFileTransferMessage(cl, rfbDirPacket, rfbADirectory, 0, nOptLen, (char *)&win32filename)==FALSE)\n                {\n#ifdef WIN32\n                    FindClose(findHandle);\n#else\n                    closedir(dirp);\n#endif\n                    return FALSE;\n                }\n            }\n        }\n\n#ifdef WIN32\n        if (FindNextFileA(findHandle, &winFindData) == 0)\n        {\n            FindClose(findHandle);\n            findHandle = INVALID_HANDLE_VALUE;\n        }\n#endif\n    }\n#ifdef WIN32\n    if (findHandle != INVALID_HANDLE_VALUE)\n    {\n        FindClose(findHandle);\n    }\n#else\n    closedir(dirp);\n#endif\n    /* End of the transfer */\n    return rfbSendFileTransferMessage(cl, rfbDirPacket, 0, 0, 0, NULL);\n}\n\n\nchar *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n{\n    char *buffer=NULL;\n    int   n=0;\n\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, NULL);\n\n    /*\n       We later alloc length+1, which might wrap around on 32-bit systems if length equals\n       0XFFFFFFFF, i.e. SIZE_MAX for 32-bit systems. On 64-bit systems, a length of 0XFFFFFFFF\n       will safely be allocated since this check will never trigger and malloc() can digest length+1\n       without problems as length is a uint32_t.\n       We also later pass length to rfbReadExact() that expects a signed int type and\n       that might wrap on platforms with a 32-bit int type if length is bigger\n       than 0X7FFFFFFF.\n    */\n    if(length == SIZE_MAX || length > INT_MAX) {\n\trfbErr(\"rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u\", (unsigned int)length);\n\trfbCloseClient(cl);\n\treturn NULL;\n    }\n\n    if (length>0) {\n        buffer=malloc((size_t)length+1);\n        if (buffer!=NULL) {\n            if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessFileTransferReadBuffer: read\");\n                rfbCloseClient(cl);\n                /* NOTE: don't forget to free(buffer) if you return early! */\n                if (buffer!=NULL) free(buffer);\n                return NULL;\n            }\n            /* Null Terminate */\n            buffer[length]=0;\n        }\n    }\n    return buffer;\n}\n\n\nrfbBool rfbSendFileTransferChunk(rfbClientPtr cl)\n{\n    /* Allocate buffer for compression */\n    unsigned char readBuf[sz_rfbBlockSize];\n    int bytesRead=0;\n    int retval=0;\n    fd_set wfds;\n    struct timeval tv;\n    int n;\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n    unsigned char compBuf[sz_rfbBlockSize + 1024];\n    unsigned long nMaxCompSize = sizeof(compBuf);\n    int nRetC = 0;\n#endif\n\n    /*\n     * Don't close the client if we get into this one because \n     * it is called from many places to service file transfers.\n     * Note that permitFileTransfer is checked first.\n     */\n    if (cl->screen->permitFileTransfer != TRUE ||\n       (cl->screen->getFileTransferPermission != NULL\n        && cl->screen->getFileTransferPermission(cl) != TRUE)) { \n\t\treturn TRUE;\n    }\n\n    /* If not sending, or no file open...   Return as if we sent something! */\n    if ((cl->fileTransfer.fd!=-1) && (cl->fileTransfer.sending==1))\n    {\n\tFD_ZERO(&wfds);\n        FD_SET(cl->sock, &wfds);\n\n        /* return immediately */\n\ttv.tv_sec = 0; \n\ttv.tv_usec = 0;\n\tn = select(cl->sock + 1, NULL, &wfds, NULL, &tv);\n\n\tif (n<0) {\n#ifdef WIN32\n\t    errno=WSAGetLastError();\n#endif\n            rfbLog(\"rfbSendFileTransferChunk() select failed: %s\\n\", strerror(errno));\n\t}\n        /* We have space on the transmit queue */\n\tif (n > 0)\n\t{\n            bytesRead = read(cl->fileTransfer.fd, readBuf, sz_rfbBlockSize);\n            switch (bytesRead) {\n            case 0:\n                /*\n                rfbLog(\"rfbSendFileTransferChunk(): End-Of-File Encountered\\n\");\n                */\n                retval = rfbSendFileTransferMessage(cl, rfbEndOfFile, 0, 0, 0, NULL);\n                close(cl->fileTransfer.fd);\n                cl->fileTransfer.fd = -1;\n                cl->fileTransfer.sending   = 0;\n                cl->fileTransfer.receiving = 0;\n                return retval;\n            case -1:\n                /* TODO : send an error msg to the client... */\n#ifdef WIN32\n\t        errno=WSAGetLastError();\n#endif\n                rfbLog(\"rfbSendFileTransferChunk(): %s\\n\",strerror(errno));\n                retval = rfbSendFileTransferMessage(cl, rfbAbortFileTransfer, 0, 0, 0, NULL);\n                close(cl->fileTransfer.fd);\n                cl->fileTransfer.fd = -1;\n                cl->fileTransfer.sending   = 0;\n                cl->fileTransfer.receiving = 0;\n                return retval;\n            default:\n                /*\n                rfbLog(\"rfbSendFileTransferChunk(): Read %d bytes\\n\", bytesRead);\n                */\n                if (!cl->fileTransfer.compressionEnabled)\n                    return  rfbSendFileTransferMessage(cl, rfbFilePacket, 0, 0, bytesRead, (char *)readBuf);\n                else\n                {\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n                    nRetC = compress(compBuf, &nMaxCompSize, readBuf, bytesRead);\n                    /*\n                    rfbLog(\"Compressed the packet from %d -> %d bytes\\n\", nMaxCompSize, bytesRead);\n                    */\n                    \n                    if ((nRetC==0) && (nMaxCompSize<bytesRead))\n                        return  rfbSendFileTransferMessage(cl, rfbFilePacket, 0, 1, nMaxCompSize, (char *)compBuf);\n                    else\n                        return  rfbSendFileTransferMessage(cl, rfbFilePacket, 0, 0, bytesRead, (char *)readBuf);\n#else\n                    /* We do not support compression of the data stream */\n                    return  rfbSendFileTransferMessage(cl, rfbFilePacket, 0, 0, bytesRead, (char *)readBuf);\n#endif\n                }\n            }\n        }\n    }\n    return TRUE;\n}\n\nrfbBool rfbProcessFileTransfer(rfbClientPtr cl, uint8_t contentType, uint8_t contentParam, uint32_t size, uint32_t length)\n{\n    char *buffer=NULL, *p=NULL;\n    int retval=0;\n    char filename1[MAX_PATH];\n    char filename2[MAX_PATH];\n    char szFileTime[MAX_PATH];\n    struct stat statbuf;\n    uint32_t sizeHtmp=0;\n    int n=0;\n    char timespec[64];\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n    unsigned char compBuff[sz_rfbBlockSize];\n    unsigned long nRawBytes = sz_rfbBlockSize;\n    int nRet = 0;\n#endif\n\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, FALSE);\n        \n    /*\n    rfbLog(\"rfbProcessFileTransfer(%dtype, %dparam, %dsize, %dlen)\\n\", contentType, contentParam, size, length);\n    */\n\n    switch (contentType) {\n    case rfbDirContentRequest:\n        switch (contentParam) {\n        case rfbRDrivesList: /* Client requests the List of Local Drives */\n            /*\n            rfbLog(\"rfbProcessFileTransfer() rfbDirContentRequest: rfbRDrivesList:\\n\");\n            */\n            /* Format when filled : \"C:\\<NULL>D:\\<NULL>....Z:\\<NULL><NULL>\n             *\n             * We replace the \"\\\" char following the drive letter and \":\"\n             * with a char corresponding to the type of drive\n             * We obtain something like \"C:l<NULL>D:c<NULL>....Z:n\\<NULL><NULL>\"\n             *  Isn't it ugly ?\n             * DRIVE_FIXED = 'l'     (local?)\n             * DRIVE_REMOVABLE = 'f' (floppy?)\n             * DRIVE_CDROM = 'c'\n             * DRIVE_REMOTE = 'n'\n             */\n            \n            /* in unix, there are no 'drives'  (We could list mount points though)\n             * We fake the root as a \"C:\" for the Winblows users\n             */\n            filename2[0]='C';\n            filename2[1]=':';\n            filename2[2]='l';\n            filename2[3]=0;\n            filename2[4]=0;\n            retval = rfbSendFileTransferMessage(cl, rfbDirPacket, rfbADrivesList, 0, 5, filename2);\n            if (buffer!=NULL) free(buffer);\n            return retval;\n            break;\n        case rfbRDirContent: /* Client requests the content of a directory */\n            /*\n            rfbLog(\"rfbProcessFileTransfer() rfbDirContentRequest: rfbRDirContent\\n\");\n            */\n            if ((buffer = rfbProcessFileTransferReadBuffer(cl, length))==NULL) return FALSE;\n            retval = rfbSendDirContent(cl, length, buffer);\n            if (buffer!=NULL) free(buffer);\n            return retval;\n        }\n        break;\n\n    case rfbDirPacket:\n        rfbLog(\"rfbProcessFileTransfer() rfbDirPacket\\n\");\n        break;\n    case rfbFileAcceptHeader:\n        rfbLog(\"rfbProcessFileTransfer() rfbFileAcceptHeader\\n\");\n        break;\n    case rfbCommandReturn:\n        rfbLog(\"rfbProcessFileTransfer() rfbCommandReturn\\n\");\n        break;\n    case rfbFileChecksums:\n        /* Destination file already exists - the viewer sends the checksums */\n        rfbLog(\"rfbProcessFileTransfer() rfbFileChecksums\\n\");\n        break;\n    case rfbFileTransferAccess:\n        rfbLog(\"rfbProcessFileTransfer() rfbFileTransferAccess\\n\");\n        break;\n\n    /*\n     * sending from the server to the viewer\n     */\n\n    case rfbFileTransferRequest:\n        /*\n        rfbLog(\"rfbProcessFileTransfer() rfbFileTransferRequest:\\n\");\n        */\n        /* add some space to the end of the buffer as we will be adding a timespec to it */\n        if ((buffer = rfbProcessFileTransferReadBuffer(cl, length))==NULL) return FALSE;\n        /* The client requests a File */\n        if (!rfbFilenameTranslate2UNIX(cl, buffer, filename1, sizeof(filename1)))\n            goto fail;\n        cl->fileTransfer.fd=open(filename1, O_RDONLY, 0744);\n\n        /*\n        */\n        if (DB) rfbLog(\"rfbProcessFileTransfer() rfbFileTransferRequest(\\\"%s\\\"->\\\"%s\\\") Open: %s fd=%d\\n\", buffer, filename1, (cl->fileTransfer.fd==-1?\"Failed\":\"Success\"), cl->fileTransfer.fd);\n        \n        if (cl->fileTransfer.fd!=-1) {\n            if (fstat(cl->fileTransfer.fd, &statbuf)!=0) {\n                close(cl->fileTransfer.fd);\n                cl->fileTransfer.fd=-1;\n            }\n            else\n            {\n              /* Add the File Time Stamp to the filename */\n              strftime(timespec, sizeof(timespec), \"%m/%d/%Y %H:%M\",gmtime(&statbuf.st_ctime));\n              buffer=realloc(buffer, length + strlen(timespec) + 2); /* comma, and Null term */\n              if (buffer==NULL) {\n                  rfbLog(\"rfbProcessFileTransfer() rfbFileTransferRequest: Failed to malloc %d bytes\\n\", length + strlen(timespec) + 2);\n                  return FALSE;\n              }\n              strcat(buffer,\",\");\n              strcat(buffer, timespec);\n              length = strlen(buffer);\n              if (DB) rfbLog(\"rfbProcessFileTransfer() buffer is now: \\\"%s\\\"\\n\", buffer);\n            }\n        }\n\n        /* The viewer supports compression if size==1 */\n        cl->fileTransfer.compressionEnabled = (size==1);\n\n        /*\n        rfbLog(\"rfbProcessFileTransfer() rfbFileTransferRequest(\\\"%s\\\"->\\\"%s\\\")%s\\n\", buffer, filename1, (size==1?\" <Compression Enabled>\":\"\"));\n        */\n\n        /* File Size in bytes, 0xFFFFFFFF (-1) means error */\n        retval = rfbSendFileTransferMessage(cl, rfbFileHeader, 0, (cl->fileTransfer.fd==-1 ? -1 : statbuf.st_size), length, buffer);\n\n        if (cl->fileTransfer.fd==-1)\n        {\n            if (buffer!=NULL) free(buffer);\n            return retval;\n        }\n        /* setup filetransfer stuff */\n        cl->fileTransfer.fileSize = statbuf.st_size;\n        cl->fileTransfer.numPackets = statbuf.st_size / sz_rfbBlockSize;\n        cl->fileTransfer.receiving = 0;\n        cl->fileTransfer.sending = 0; /* set when we receive a rfbFileHeader: */\n\n        /* TODO: finish 64-bit file size support */\n        sizeHtmp = 0;        \n        LOCK(cl->sendMutex);\n        if (rfbWriteExact(cl, (char *)&sizeHtmp, 4) < 0) {\n          rfbLogPerror(\"rfbProcessFileTransfer: write\");\n          rfbCloseClient(cl);\n          UNLOCK(cl->sendMutex);\n          if (buffer!=NULL) free(buffer);\n          return FALSE;\n        }\n        UNLOCK(cl->sendMutex);\n        break;\n\n    case rfbFileHeader:\n        /* Destination file (viewer side) is ready for reception (size > 0) or not (size = -1) */\n        if (size==-1) {\n            rfbLog(\"rfbProcessFileTransfer() rfbFileHeader (error, aborting)\\n\");\n            close(cl->fileTransfer.fd);\n            cl->fileTransfer.fd=-1;\n            return TRUE;\n        }\n\n        /*\n        rfbLog(\"rfbProcessFileTransfer() rfbFileHeader (%d bytes of a file)\\n\", size);\n        */\n\n        /* Starts the transfer! */\n        cl->fileTransfer.sending=1;\n        return rfbSendFileTransferChunk(cl);\n        break;\n\n\n    /*\n     * sending from the viewer to the server\n     */\n\n    case rfbFileTransferOffer:\n        /* client is sending a file to us */\n        /* buffer contains full path name (plus FileTime) */\n        /* size contains size of the file */\n        /*\n        rfbLog(\"rfbProcessFileTransfer() rfbFileTransferOffer:\\n\");\n        */\n        if ((buffer = rfbProcessFileTransferReadBuffer(cl, length))==NULL) return FALSE;\n\n        /* Parse the FileTime */\n        p = strrchr(buffer, ',');\n        if (p!=NULL) {\n            *p = '\\0';\n            strncpy(szFileTime, p+1, sizeof(szFileTime));\n            szFileTime[sizeof(szFileTime)-1] = '\\x00'; /* ensure NULL terminating byte is present, even if copy overflowed */\n        } else\n            szFileTime[0]=0;\n\n\n\n        /* Need to read in sizeHtmp */\n        if ((n = rfbReadExact(cl, (char *)&sizeHtmp, 4)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessFileTransfer: read sizeHtmp\");\n            rfbCloseClient(cl);\n            /* NOTE: don't forget to free(buffer) if you return early! */\n            if (buffer!=NULL) free(buffer);\n            return FALSE;\n        }\n        sizeHtmp = Swap32IfLE(sizeHtmp);\n        \n        if (!rfbFilenameTranslate2UNIX(cl, buffer, filename1, sizeof(filename1)))\n            goto fail;\n\n        /* If the file exists... We can send a rfbFileChecksums back to the client before we send an rfbFileAcceptHeader */\n        /* TODO: Delta Transfer */\n\n        cl->fileTransfer.fd=open(filename1, O_CREAT|O_WRONLY|O_TRUNC, 0744);\n        if (DB) rfbLog(\"rfbProcessFileTransfer() rfbFileTransferOffer(\\\"%s\\\"->\\\"%s\\\") %s %s fd=%d\\n\", buffer, filename1, (cl->fileTransfer.fd==-1?\"Failed\":\"Success\"), (cl->fileTransfer.fd==-1?strerror(errno):\"\"), cl->fileTransfer.fd);\n        /*\n        */\n        \n        /* File Size in bytes, 0xFFFFFFFF (-1) means error */\n        retval = rfbSendFileTransferMessage(cl, rfbFileAcceptHeader, 0, (cl->fileTransfer.fd==-1 ? -1 : 0), length, buffer);\n        if (cl->fileTransfer.fd==-1) {\n            free(buffer);\n            return retval;\n        }\n        \n        /* setup filetransfer stuff */\n        cl->fileTransfer.fileSize = size;\n        cl->fileTransfer.numPackets = size / sz_rfbBlockSize;\n        cl->fileTransfer.receiving = 1;\n        cl->fileTransfer.sending = 0;\n        break;\n\n    case rfbFilePacket:\n        /*\n        rfbLog(\"rfbProcessFileTransfer() rfbFilePacket:\\n\");\n        */\n        if ((buffer = rfbProcessFileTransferReadBuffer(cl, length))==NULL) return FALSE;\n        if (cl->fileTransfer.fd!=-1) {\n            /* buffer contains the contents of the file */\n            if (size==0)\n                retval=write(cl->fileTransfer.fd, buffer, length);\n            else\n            {\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n                /* compressed packet */\n                nRet = uncompress(compBuff,&nRawBytes,(const unsigned char*)buffer, length);\n\t\tif(nRet == Z_OK)\n\t\t  retval=write(cl->fileTransfer.fd, (char*)compBuff, nRawBytes);\n\t\telse\n\t\t  retval = -1;\n#else\n                /* Write the file out as received... */\n                retval=write(cl->fileTransfer.fd, buffer, length);\n#endif\n            }\n            if (retval==-1)\n            {\n                close(cl->fileTransfer.fd);\n                cl->fileTransfer.fd=-1;\n                cl->fileTransfer.sending   = 0;\n                cl->fileTransfer.receiving = 0;\n            }\n        }\n        break;\n\n    case rfbEndOfFile:\n        if (DB) rfbLog(\"rfbProcessFileTransfer() rfbEndOfFile\\n\");\n        /*\n        */\n        if (cl->fileTransfer.fd!=-1)\n            close(cl->fileTransfer.fd);\n        cl->fileTransfer.fd=-1;\n        cl->fileTransfer.sending   = 0;\n        cl->fileTransfer.receiving = 0;\n        break;\n\n    case rfbAbortFileTransfer:\n        if (DB) rfbLog(\"rfbProcessFileTransfer() rfbAbortFileTransfer\\n\");\n        /*\n        */\n        if (cl->fileTransfer.fd!=-1)\n        {\n            close(cl->fileTransfer.fd);\n            cl->fileTransfer.fd=-1;\n            cl->fileTransfer.sending   = 0;\n            cl->fileTransfer.receiving = 0;\n        }\n        else\n        {\n            /* We use this message for FileTransfer rights (<=RC18 versions)\n             * The client asks for FileTransfer permission\n             */\n            if (contentParam == 0)\n            {\n                rfbLog(\"rfbProcessFileTransfer() File Transfer Permission DENIED! (Client Version <=RC18)\\n\");\n                /* Old method for FileTransfer handshake perimssion (<=RC18) (Deny it)*/\n                return rfbSendFileTransferMessage(cl, rfbAbortFileTransfer, 0, -1, 0, \"\");\n            }\n            /* New method is allowed */\n            if (cl->screen->getFileTransferPermission!=NULL)\n            {\n                if (cl->screen->getFileTransferPermission(cl)==TRUE)\n                {\n                    rfbLog(\"rfbProcessFileTransfer() File Transfer Permission Granted!\\n\");\n                    return rfbSendFileTransferMessage(cl, rfbFileTransferAccess, 0, 1 , 0, \"\"); /* Permit */\n                }\n                else\n                {\n                    rfbLog(\"rfbProcessFileTransfer() File Transfer Permission DENIED!\\n\");\n                    return rfbSendFileTransferMessage(cl, rfbFileTransferAccess, 0, -1 , 0, \"\"); /* Deny */\n                }\n            }\n            else\n            {\n                if (cl->screen->permitFileTransfer)\n                {\n                    rfbLog(\"rfbProcessFileTransfer() File Transfer Permission Granted!\\n\");\n                    return rfbSendFileTransferMessage(cl, rfbFileTransferAccess, 0, 1 , 0, \"\"); /* Permit */\n                }\n                else\n                {\n                    rfbLog(\"rfbProcessFileTransfer() File Transfer Permission DENIED by default!\\n\");\n                    return rfbSendFileTransferMessage(cl, rfbFileTransferAccess, 0, -1 , 0, \"\"); /* DEFAULT: DENY (for security) */\n                }\n                \n            }\n        }\n        break;\n\n\n    case rfbCommand:\n        /*\n        rfbLog(\"rfbProcessFileTransfer() rfbCommand:\\n\");\n        */\n        if ((buffer = rfbProcessFileTransferReadBuffer(cl, length))==NULL) return FALSE;\n        switch (contentParam) {\n        case rfbCDirCreate:  /* Client requests the creation of a directory */\n            if (!rfbFilenameTranslate2UNIX(cl, buffer, filename1, sizeof(filename1)))\n                goto fail;\n            retval = mkdir(filename1, 0755);\n            if (DB) rfbLog(\"rfbProcessFileTransfer() rfbCommand: rfbCDirCreate(\\\"%s\\\"->\\\"%s\\\") %s\\n\", buffer, filename1, (retval==-1?\"Failed\":\"Success\"));\n            /*\n            */\n            retval = rfbSendFileTransferMessage(cl, rfbCommandReturn, rfbADirCreate, retval, length, buffer);\n            if (buffer!=NULL) free(buffer);\n            return retval;\n        case rfbCFileDelete: /* Client requests the deletion of a file */\n            if (!rfbFilenameTranslate2UNIX(cl, buffer, filename1, sizeof(filename1)))\n                goto fail;\n            if (stat(filename1,&statbuf)==0)\n            {\n                if (S_ISDIR(statbuf.st_mode))\n                    retval = rmdir(filename1);\n                else\n                    retval = unlink(filename1);\n            }\n            else retval=-1;\n            retval = rfbSendFileTransferMessage(cl, rfbCommandReturn, rfbAFileDelete, retval, length, buffer);\n            if (buffer!=NULL) free(buffer);\n            return retval;\n        case rfbCFileRename: /* Client requests the Renaming of a file/directory */\n            p = strrchr(buffer, '*');\n            if (p != NULL)\n            {\n                /* Split into 2 filenames ('*' is a seperator) */\n                *p = '\\0';\n                if (!rfbFilenameTranslate2UNIX(cl, buffer, filename1, sizeof(filename1)))\n                    goto fail;\n                if (!rfbFilenameTranslate2UNIX(cl, p+1,    filename2, sizeof(filename2)))\n                    goto fail;\n                retval = rename(filename1,filename2);\n                if (DB) rfbLog(\"rfbProcessFileTransfer() rfbCommand: rfbCFileRename(\\\"%s\\\"->\\\"%s\\\" -->> \\\"%s\\\"->\\\"%s\\\") %s\\n\", buffer, filename1, p+1, filename2, (retval==-1?\"Failed\":\"Success\"));\n                /*\n                */\n                /* Restore the buffer so the reply is good */\n                *p = '*';\n                retval = rfbSendFileTransferMessage(cl, rfbCommandReturn, rfbAFileRename, retval, length, buffer);\n                if (buffer!=NULL) free(buffer);\n                return retval;\n            }\n            break;\n        }\n    \n        break;\n    }\n\n    /* NOTE: don't forget to free(buffer) if you return early! */\n    if (buffer!=NULL) free(buffer);\n    return TRUE;\n\nfail:\n    if (buffer!=NULL) free(buffer);\n    return FALSE;\n}\n\n/*\n * rfbProcessClientNormalMessage is called when the client has sent a normal\n * protocol message.\n */\n\nstatic void\nrfbProcessClientNormalMessage(rfbClientPtr cl)\n{\n    int n=0;\n    rfbClientToServerMsg msg;\n    char *str;\n    int i;\n    uint32_t enc=0;\n    uint32_t lastPreferredEncoding = -1;\n    char encBuf[64];\n    char encBuf2[64];\n    rfbExtDesktopScreen *extDesktopScreens;\n    rfbClientIteratorPtr iterator;\n    rfbClientPtr clp;\n\n    if ((n = rfbReadExact(cl, (char *)&msg, 1)) <= 0) {\n        if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n        rfbCloseClient(cl);\n        return;\n    }\n\n    switch (msg.type) {\n\n    case rfbSetPixelFormat:\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbSetPixelFormatMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        cl->format.bitsPerPixel = msg.spf.format.bitsPerPixel;\n        cl->format.depth = msg.spf.format.depth;\n        cl->format.bigEndian = (msg.spf.format.bigEndian ? TRUE : FALSE);\n        cl->format.trueColour = (msg.spf.format.trueColour ? TRUE : FALSE);\n        cl->format.redMax = Swap16IfLE(msg.spf.format.redMax);\n        cl->format.greenMax = Swap16IfLE(msg.spf.format.greenMax);\n        cl->format.blueMax = Swap16IfLE(msg.spf.format.blueMax);\n        cl->format.redShift = msg.spf.format.redShift;\n        cl->format.greenShift = msg.spf.format.greenShift;\n        cl->format.blueShift = msg.spf.format.blueShift;\n\n\tcl->readyForSetColourMapEntries = TRUE;\n        cl->screen->setTranslateFunction(cl);\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetPixelFormatMsg, sz_rfbSetPixelFormatMsg);\n\n        return;\n\n\n    case rfbFixColourMapEntries:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbFixColourMapEntriesMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetPixelFormatMsg, sz_rfbSetPixelFormatMsg);\n        rfbLog(\"rfbProcessClientNormalMessage: %s\",\n                \"FixColourMapEntries unsupported\\n\");\n        rfbCloseClient(cl);\n        return;\n\n\n    /* NOTE: Some clients send us a set of encodings (ie: PointerPos) designed to enable/disable features...\n     * We may want to look into this...\n     * Example:\n     *     case rfbEncodingXCursor:\n     *         cl->enableCursorShapeUpdates = TRUE;\n     *\n     * Currently: cl->enableCursorShapeUpdates can *never* be turned off...\n     */\n    case rfbSetEncodings:\n    {\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbSetEncodingsMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        msg.se.nEncodings = Swap16IfLE(msg.se.nEncodings);\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetEncodingsMsg+(msg.se.nEncodings*4),sz_rfbSetEncodingsMsg+(msg.se.nEncodings*4));\n\n        /*\n         * UltraVNC Client has the ability to adapt to changing network environments\n         * So, let's give it a change to tell us what it wants now!\n         */\n        if (cl->preferredEncoding!=-1)\n            lastPreferredEncoding = cl->preferredEncoding;\n\n        /* Reset all flags to defaults (allows us to switch between PointerPos and Server Drawn Cursors) */\n        cl->preferredEncoding=-1;\n        cl->useCopyRect              = FALSE;\n        cl->useNewFBSize             = FALSE;\n        cl->useExtDesktopSize        = FALSE;\n        cl->cursorWasChanged         = FALSE;\n        cl->useRichCursorEncoding    = FALSE;\n        cl->enableCursorPosUpdates   = FALSE;\n        cl->enableCursorShapeUpdates = FALSE;\n        cl->enableCursorShapeUpdates = FALSE;\n        cl->enableLastRectEncoding   = FALSE;\n        cl->enableKeyboardLedState   = FALSE;\n        cl->enableSupportedMessages  = FALSE;\n        cl->enableSupportedEncodings = FALSE;\n        cl->enableServerIdentity     = FALSE;\n#if defined(LIBVNCSERVER_HAVE_LIBZ) || defined(LIBVNCSERVER_HAVE_LIBPNG)\n        cl->tightQualityLevel        = -1;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n        cl->tightCompressLevel       = TIGHT_DEFAULT_COMPRESSION;\n        cl->turboSubsampLevel        = TURBO_DEFAULT_SUBSAMP;\n        cl->turboQualityLevel        = -1;\n#endif\n#endif\n\n\n        for (i = 0; i < msg.se.nEncodings; i++) {\n            if ((n = rfbReadExact(cl, (char *)&enc, 4)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n                rfbCloseClient(cl);\n                return;\n            }\n            enc = Swap32IfLE(enc);\n\n            switch (enc) {\n\n            case rfbEncodingCopyRect:\n\t\tcl->useCopyRect = TRUE;\n                break;\n            case rfbEncodingRaw:\n            case rfbEncodingRRE:\n            case rfbEncodingCoRRE:\n            case rfbEncodingHextile:\n            case rfbEncodingUltra:\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\t    case rfbEncodingZlib:\n            case rfbEncodingZRLE:\n            case rfbEncodingZYWRLE:\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t    case rfbEncodingTight:\n#endif\n#endif\n#ifdef LIBVNCSERVER_HAVE_LIBPNG\n\t    case rfbEncodingTightPng:\n#endif\n            /* The first supported encoding is the 'preferred' encoding */\n                if (cl->preferredEncoding == -1)\n                    cl->preferredEncoding = enc;\n\n\n                break;\n\t    case rfbEncodingXCursor:\n\t\tif(!cl->screen->dontConvertRichCursorToXCursor) {\n\t\t    rfbLog(\"Enabling X-style cursor updates for client %s\\n\",\n\t\t\t   cl->host);\n\t\t    /* if cursor was drawn, hide the cursor */\n\t\t    if(!cl->enableCursorShapeUpdates)\n\t\t        rfbRedrawAfterHideCursor(cl,NULL);\n\n\t\t    cl->enableCursorShapeUpdates = TRUE;\n\t\t    cl->cursorWasChanged = TRUE;\n\t\t}\n\t\tbreak;\n\t    case rfbEncodingRichCursor:\n\t        rfbLog(\"Enabling full-color cursor updates for client %s\\n\",\n\t\t       cl->host);\n\t\t/* if cursor was drawn, hide the cursor */\n\t\tif(!cl->enableCursorShapeUpdates)\n\t\t    rfbRedrawAfterHideCursor(cl,NULL);\n\n\t        cl->enableCursorShapeUpdates = TRUE;\n\t        cl->useRichCursorEncoding = TRUE;\n\t        cl->cursorWasChanged = TRUE;\n\t        break;\n\t    case rfbEncodingPointerPos:\n\t\tif (!cl->enableCursorPosUpdates) {\n\t\t    rfbLog(\"Enabling cursor position updates for client %s\\n\",\n\t\t\t   cl->host);\n\t\t    cl->enableCursorPosUpdates = TRUE;\n\t\t    cl->cursorWasMoved = TRUE;\n\t\t}\n\t        break;\n\t    case rfbEncodingLastRect:\n\t\tif (!cl->enableLastRectEncoding) {\n\t\t    rfbLog(\"Enabling LastRect protocol extension for client \"\n\t\t\t   \"%s\\n\", cl->host);\n\t\t    cl->enableLastRectEncoding = TRUE;\n\t\t}\n\t\tbreak;\n\t    case rfbEncodingNewFBSize:\n\t\tif (!cl->useNewFBSize) {\n\t\t    rfbLog(\"Enabling NewFBSize protocol extension for client \"\n\t\t\t   \"%s\\n\", cl->host);\n\t\t    cl->useNewFBSize = TRUE;\n\t\t}\n\t\tbreak;\n            case rfbEncodingExtDesktopSize:\n                if (!cl->useExtDesktopSize) {\n                    rfbLog(\"Enabling ExtDesktopSize protocol extension for client \"\n                           \"%s\\n\", cl->host);\n                    cl->useExtDesktopSize = TRUE;\n                    cl->useNewFBSize = TRUE;\n                }\n                break;\n            case rfbEncodingKeyboardLedState:\n                if (!cl->enableKeyboardLedState) {\n                  rfbLog(\"Enabling KeyboardLedState protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableKeyboardLedState = TRUE;\n                }\n                break;           \n            case rfbEncodingSupportedMessages:\n                if (!cl->enableSupportedMessages) {\n                  rfbLog(\"Enabling SupportedMessages protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableSupportedMessages = TRUE;\n                }\n                break;           \n            case rfbEncodingSupportedEncodings:\n                if (!cl->enableSupportedEncodings) {\n                  rfbLog(\"Enabling SupportedEncodings protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableSupportedEncodings = TRUE;\n                }\n                break;           \n            case rfbEncodingServerIdentity:\n                if (!cl->enableServerIdentity) {\n                  rfbLog(\"Enabling ServerIdentity protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableServerIdentity = TRUE;\n                }\n                break;\n            case rfbEncodingXvp:\n                if (cl->screen->xvpHook) {\n                  rfbLog(\"Enabling Xvp protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  if (!rfbSendXvp(cl, 1, rfbXvp_Init)) {\n                    rfbCloseClient(cl);\n                    return;\n                  }\n                }\n                break;\n            default:\n#if defined(LIBVNCSERVER_HAVE_LIBZ) || defined(LIBVNCSERVER_HAVE_LIBPNG)\n\t\tif ( enc >= (uint32_t)rfbEncodingCompressLevel0 &&\n\t\t     enc <= (uint32_t)rfbEncodingCompressLevel9 ) {\n\t\t    cl->zlibCompressLevel = enc & 0x0F;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t\t    cl->tightCompressLevel = enc & 0x0F;\n\t\t    rfbLog(\"Using compression level %d for client %s\\n\",\n\t\t\t   cl->tightCompressLevel, cl->host);\n#endif\n\t\t} else if ( enc >= (uint32_t)rfbEncodingQualityLevel0 &&\n\t\t\t    enc <= (uint32_t)rfbEncodingQualityLevel9 ) {\n\t\t    cl->tightQualityLevel = enc & 0x0F;\n\t\t    rfbLog(\"Using image quality level %d for client %s\\n\",\n\t\t\t   cl->tightQualityLevel, cl->host);\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t\t    cl->turboQualityLevel = tight2turbo_qual[enc & 0x0F];\n\t\t    cl->turboSubsampLevel = tight2turbo_subsamp[enc & 0x0F];\n\t\t    rfbLog(\"Using JPEG subsampling %d, Q%d for client %s\\n\",\n\t\t\t   cl->turboSubsampLevel, cl->turboQualityLevel, cl->host);\n\t\t} else if ( enc >= (uint32_t)rfbEncodingFineQualityLevel0 + 1 &&\n\t\t\t    enc <= (uint32_t)rfbEncodingFineQualityLevel100 ) {\n\t\t    cl->turboQualityLevel = enc & 0xFF;\n\t\t    rfbLog(\"Using fine quality level %d for client %s\\n\",\n\t\t\t   cl->turboQualityLevel, cl->host);\n\t\t} else if ( enc >= (uint32_t)rfbEncodingSubsamp1X &&\n\t\t\t    enc <= (uint32_t)rfbEncodingSubsampGray ) {\n\t\t    cl->turboSubsampLevel = enc & 0xFF;\n\t\t    rfbLog(\"Using subsampling level %d for client %s\\n\",\n\t\t\t   cl->turboSubsampLevel, cl->host);\n#endif\n\t\t} else\n#endif\n\t\t{\n\t\t\trfbExtensionData* e;\n\t\t\tfor(e = cl->extensions; e;) {\n\t\t\t\trfbExtensionData* next = e->next;\n\t\t\t\tif(e->extension->enablePseudoEncoding &&\n\t\t\t\t\te->extension->enablePseudoEncoding(cl,\n\t\t\t\t\t\t&e->data, (int)enc))\n\t\t\t\t\t/* ext handles this encoding */\n\t\t\t\t\tbreak;\n\t\t\t\te = next;\n\t\t\t}\n\t\t\tif(e == NULL) {\n\t\t\t\trfbBool handled = FALSE;\n\t\t\t\t/* if the pseudo encoding is not handled by the\n\t\t\t\t   enabled extensions, search through all\n\t\t\t\t   extensions. */\n\t\t\t\trfbProtocolExtension* e;\n\n\t\t\t\tfor(e = rfbGetExtensionIterator(); e;) {\n\t\t\t\t\tint* encs = e->pseudoEncodings;\n\t\t\t\t\twhile(encs && *encs!=0) {\n\t\t\t\t\t\tif(*encs==(int)enc) {\n\t\t\t\t\t\t\tvoid* data = NULL;\n\t\t\t\t\t\t\tif(!e->enablePseudoEncoding(cl, &data, (int)enc)) {\n\t\t\t\t\t\t\t\trfbLog(\"Installed extension pretends to handle pseudo encoding 0x%x, but does not!\\n\",(int)enc);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\trfbEnableExtension(cl, e, data);\n\t\t\t\t\t\t\t\thandled = TRUE;\n\t\t\t\t\t\t\t\te = NULL;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tencs++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(e)\n\t\t\t\t\t\te = e->next;\n\t\t\t\t}\n\t\t\t\trfbReleaseExtensionIterator();\n\n\t\t\t\tif(!handled)\n\t\t\t\t\trfbLog(\"rfbProcessClientNormalMessage: \"\n\t\t\t\t\t    \"ignoring unsupported encoding type %s\\n\",\n\t\t\t\t\t    encodingName(enc,encBuf,sizeof(encBuf)));\n\t\t\t}\n\t\t}\n            }\n        }\n\n\n\n        if (cl->preferredEncoding == -1) {\n            if (lastPreferredEncoding==-1) {\n                cl->preferredEncoding = rfbEncodingRaw;\n                rfbLog(\"Defaulting to %s encoding for client %s\\n\", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n            }\n            else {\n                cl->preferredEncoding = lastPreferredEncoding;\n                rfbLog(\"Sticking with %s encoding for client %s\\n\", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n            }\n        }\n        else\n        {\n          if (lastPreferredEncoding==-1) {\n              rfbLog(\"Using %s encoding for client %s\\n\", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n          } else {\n              rfbLog(\"Switching from %s to %s Encoding for client %s\\n\", \n                  encodingName(lastPreferredEncoding,encBuf2,sizeof(encBuf2)),\n                  encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)), cl->host);\n          }\n        }\n        \n\tif (cl->enableCursorPosUpdates && !cl->enableCursorShapeUpdates) {\n\t  rfbLog(\"Disabling cursor position updates for client %s\\n\",\n\t\t cl->host);\n\t  cl->enableCursorPosUpdates = FALSE;\n\t}\n\n        return;\n    }\n\n\n    case rfbFramebufferUpdateRequest:\n    {\n        sraRegionPtr tmpRegion;\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbFramebufferUpdateRequestMsg-1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbFramebufferUpdateRequestMsg,sz_rfbFramebufferUpdateRequestMsg);\n\n        /* The values come in based on the scaled screen, we need to convert them to\n         * values based on the main screen's coordinate system\n         */\n\tif(!rectSwapIfLEAndClip(&msg.fur.x,&msg.fur.y,&msg.fur.w,&msg.fur.h,cl))\n\t{\n\t        rfbLog(\"Warning, ignoring rfbFramebufferUpdateRequest: %dXx%dY-%dWx%dH\\n\",msg.fur.x, msg.fur.y, msg.fur.w, msg.fur.h);\n\t\treturn;\n        }\n\n        if (cl->clientFramebufferUpdateRequestHook)\n            cl->clientFramebufferUpdateRequestHook(cl, &msg.fur);\n\n\ttmpRegion =\n\t  sraRgnCreateRect(msg.fur.x,\n\t\t\t   msg.fur.y,\n\t\t\t   msg.fur.x+msg.fur.w,\n\t\t\t   msg.fur.y+msg.fur.h);\n\n        LOCK(cl->updateMutex);\n\tsraRgnOr(cl->requestedRegion,tmpRegion);\n\n\tif (!cl->readyForSetColourMapEntries) {\n\t    /* client hasn't sent a SetPixelFormat so is using server's */\n\t    cl->readyForSetColourMapEntries = TRUE;\n\t    if (!cl->format.trueColour) {\n\t\tif (!rfbSetClientColourMap(cl, 0, 0)) {\n\t\t    sraRgnDestroy(tmpRegion);\n\t\t    TSIGNAL(cl->updateCond);\n\t\t    UNLOCK(cl->updateMutex);\n\t\t    return;\n\t\t}\n\t    }\n\t}\n\n       if (!msg.fur.incremental) {\n\t    sraRgnOr(cl->modifiedRegion,tmpRegion);\n\t    sraRgnSubtract(cl->copyRegion,tmpRegion);\n            if (cl->useExtDesktopSize)\n                cl->newFBSizePending = TRUE;\n       }\n       TSIGNAL(cl->updateCond);\n       UNLOCK(cl->updateMutex);\n\n       sraRgnDestroy(tmpRegion);\n\n       return;\n    }\n\n    case rfbKeyEvent:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbKeyEventMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbKeyEventMsg, sz_rfbKeyEventMsg);\n\n\tif(!cl->viewOnly) {\n\t    cl->screen->kbdAddEvent(msg.ke.down, (rfbKeySym)Swap32IfLE(msg.ke.key), cl);\n\t}\n\n        return;\n\n\n    case rfbPointerEvent:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbPointerEventMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbPointerEventMsg, sz_rfbPointerEventMsg);\n\t\n\tif (cl->screen->pointerClient && cl->screen->pointerClient != cl)\n\t    return;\n\n\tif (msg.pe.buttonMask == 0)\n\t    cl->screen->pointerClient = NULL;\n\telse\n\t    cl->screen->pointerClient = cl;\n\n\tif(!cl->viewOnly) {\n\t    if (msg.pe.buttonMask != cl->lastPtrButtons ||\n\t\t    cl->screen->deferPtrUpdateTime == 0) {\n\t\tcl->screen->ptrAddEvent(msg.pe.buttonMask,\n\t\t\tScaleX(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.x)), \n\t\t\tScaleY(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.y)),\n\t\t\tcl);\n\t\tcl->lastPtrButtons = msg.pe.buttonMask;\n\t    } else {\n\t\tcl->lastPtrX = ScaleX(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.x));\n\t\tcl->lastPtrY = ScaleY(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.y));\n\t\tcl->lastPtrButtons = msg.pe.buttonMask;\n\t    }\n      }      \n      return;\n\n\n    case rfbFileTransfer:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbFileTransferMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        msg.ft.size         = Swap32IfLE(msg.ft.size);\n        msg.ft.length       = Swap32IfLE(msg.ft.length);\n        /* record statistics in rfbProcessFileTransfer as length is filled with garbage when it is not valid */\n        rfbProcessFileTransfer(cl, msg.ft.contentType, msg.ft.contentParam, msg.ft.size, msg.ft.length);\n        return;\n\n    case rfbSetSW:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbSetSWMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        msg.sw.x = Swap16IfLE(msg.sw.x);\n        msg.sw.y = Swap16IfLE(msg.sw.y);\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetSWMsg, sz_rfbSetSWMsg);\n        /* msg.sw.status is not initialized in the ultraVNC viewer and contains random numbers (why???) */\n\n        rfbLog(\"Received a rfbSetSingleWindow(%d x, %d y)\\n\", msg.sw.x, msg.sw.y);\n        if (cl->screen->setSingleWindow!=NULL)\n            cl->screen->setSingleWindow(cl, msg.sw.x, msg.sw.y);\n        return;\n\n    case rfbSetServerInput:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbSetServerInputMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetServerInputMsg, sz_rfbSetServerInputMsg);\n\n        /* msg.sim.pad is not initialized in the ultraVNC viewer and contains random numbers (why???) */\n        /* msg.sim.pad = Swap16IfLE(msg.sim.pad); */\n\n        rfbLog(\"Received a rfbSetServerInput(%d status)\\n\", msg.sim.status);\n        if (cl->screen->setServerInput!=NULL)\n            cl->screen->setServerInput(cl, msg.sim.status);\n        return;\n        \n    case rfbTextChat:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbTextChatMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        \n        msg.tc.pad2   = Swap16IfLE(msg.tc.pad2);\n        msg.tc.length = Swap32IfLE(msg.tc.length);\n\n        switch (msg.tc.length) {\n        case rfbTextChatOpen:\n        case rfbTextChatClose:\n        case rfbTextChatFinished:\n            /* commands do not have text following */\n            /* Why couldn't they have used the pad byte??? */\n            str=NULL;\n            rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbTextChatMsg, sz_rfbTextChatMsg);\n            break;\n        default:\n            if ((msg.tc.length>0) && (msg.tc.length<rfbTextMaxSize))\n            {\n                str = (char *)malloc(msg.tc.length);\n                if (str==NULL)\n                {\n                    rfbLog(\"Unable to malloc %d bytes for a TextChat Message\\n\", msg.tc.length);\n                    rfbCloseClient(cl);\n                    return;\n                }\n                if ((n = rfbReadExact(cl, str, msg.tc.length)) <= 0) {\n                    if (n != 0)\n                        rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n                    free(str);\n                    rfbCloseClient(cl);\n                    return;\n                }\n                rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbTextChatMsg+msg.tc.length, sz_rfbTextChatMsg+msg.tc.length);\n            }\n            else\n            {\n                /* This should never happen */\n                rfbLog(\"client sent us a Text Message that is too big %d>%d\\n\", msg.tc.length, rfbTextMaxSize);\n                rfbCloseClient(cl);\n                return;\n            }\n        }\n\n        /* Note: length can be commands: rfbTextChatOpen, rfbTextChatClose, and rfbTextChatFinished\n         * at which point, the str is NULL (as it is not sent)\n         */\n        if (cl->screen->setTextChat!=NULL)\n            cl->screen->setTextChat(cl, msg.tc.length, str);\n\n        free(str);\n        return;\n\n\n    case rfbClientCutText:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbClientCutTextMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\tmsg.cct.length = Swap32IfLE(msg.cct.length);\n\n\t/* uint32_t input is passed to malloc()'s size_t argument,\n\t * to rfbReadExact()'s int argument, to rfbStatRecordMessageRcvd()'s int\n\t * argument increased of sz_rfbClientCutTextMsg, and to setXCutText()'s int\n\t * argument. Here we impose a limit of 1 MB so that the value fits\n\t * into all of the types to prevent from misinterpretation and thus\n\t * from accessing uninitialized memory (CVE-2018-7225) and also to\n\t * prevent from a denial-of-service by allocating too much memory in\n\t * the server. */\n\tif (msg.cct.length > 1<<20) {\n\t    rfbLog(\"rfbClientCutText: too big cut text length requested: %u B > 1 MB\\n\", (unsigned int)msg.cct.length);\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\t/* Allow zero-length client cut text. */\n\tstr = (char *)calloc(msg.cct.length ? msg.cct.length : 1, 1);\n\tif (str == NULL) {\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: not enough memory\");\n\t\trfbCloseClient(cl);\n\t\treturn;\n\t}\n\n\tif ((n = rfbReadExact(cl, str, msg.cct.length)) <= 0) {\n\t    if (n != 0)\n\t        rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    free(str);\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbClientCutTextMsg+msg.cct.length, sz_rfbClientCutTextMsg+msg.cct.length);\n\tif(!cl->viewOnly) {\n\t    cl->screen->setXCutText(str, msg.cct.length, cl);\n\t}\n\tfree(str);\n\n        return;\n\n    case rfbPalmVNCSetScaleFactor:\n      cl->PalmVNC = TRUE;\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbSetScaleMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      if (msg.ssc.scale == 0) {\n          rfbLogPerror(\"rfbProcessClientNormalMessage: will not accept a scale factor of zero\");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetScaleMsg, sz_rfbSetScaleMsg);\n      rfbLog(\"rfbSetScale(%d)\\n\", msg.ssc.scale);\n      rfbScalingSetup(cl,cl->screen->width/msg.ssc.scale, cl->screen->height/msg.ssc.scale);\n\n      rfbSendNewScaleSize(cl);\n      return;\n      \n    case rfbSetScale:\n\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbSetScaleMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      if (msg.ssc.scale == 0) {\n          rfbLogPerror(\"rfbProcessClientNormalMessage: will not accept a scale factor of zero\");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetScaleMsg, sz_rfbSetScaleMsg);\n      rfbLog(\"rfbSetScale(%d)\\n\", msg.ssc.scale);\n      rfbScalingSetup(cl,cl->screen->width/msg.ssc.scale, cl->screen->height/msg.ssc.scale);\n\n      rfbSendNewScaleSize(cl);\n      return;\n\n    case rfbXvp:\n\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbXvpMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(cl);\n          return;\n      }\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbXvpMsg, sz_rfbXvpMsg);\n\n      /* only version when is defined, so echo back a fail */\n      if(msg.xvp.version != 1) {\n\trfbSendXvp(cl, msg.xvp.version, rfbXvp_Fail);\n      }\n      else {\n\t/* if the hook exists and fails, send a fail msg */\n\tif(cl->screen->xvpHook && !cl->screen->xvpHook(cl, msg.xvp.version, msg.xvp.code))\n\t  rfbSendXvp(cl, 1, rfbXvp_Fail);\n      }\n      return;\n\n    case rfbSetDesktopSize:\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n            sz_rfbSetDesktopSizeMsg - 1)) <= 0) {\n            if (n != 0)\n              rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        if (msg.sdm.numberOfScreens == 0) {\n            rfbLog(\"Ignoring setDesktopSize message from client that defines zero screens\\n\");\n            return;\n        }\n\n        extDesktopScreens = (rfbExtDesktopScreen *) malloc(msg.sdm.numberOfScreens * sz_rfbExtDesktopScreen);\n        if (extDesktopScreens == NULL) {\n                rfbLogPerror(\"rfbProcessClientNormalMessage: not enough memory\");\n                rfbCloseClient(cl);\n                return;\n        }\n\n        if ((n = rfbReadExact(cl, ((char *)extDesktopScreens), msg.sdm.numberOfScreens * sz_rfbExtDesktopScreen)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            free(extDesktopScreens);\n            rfbCloseClient(cl);\n            return;\n        }\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetDesktopSizeMsg + msg.sdm.numberOfScreens * sz_rfbExtDesktopScreen,\n                                 sz_rfbSetDesktopSizeMsg + msg.sdm.numberOfScreens * sz_rfbExtDesktopScreen);\n\n        for (i=0; i < msg.sdm.numberOfScreens; i++) {\n            extDesktopScreens[i].id = Swap32IfLE(extDesktopScreens[i].id);\n            extDesktopScreens[i].x = Swap16IfLE(extDesktopScreens[i].x);\n            extDesktopScreens[i].y = Swap16IfLE(extDesktopScreens[i].y);\n            extDesktopScreens[i].width = Swap16IfLE(extDesktopScreens[i].width);\n            extDesktopScreens[i].height = Swap16IfLE(extDesktopScreens[i].height);\n            extDesktopScreens[i].flags = Swap32IfLE(extDesktopScreens[i].flags);\n        }\n        msg.sdm.width = Swap16IfLE(msg.sdm.width);\n        msg.sdm.height = Swap16IfLE(msg.sdm.height);\n\n        rfbLog(\"Client requested resolution change to (%dx%d)\\n\", msg.sdm.width, msg.sdm.height);\n        cl->requestedDesktopSizeChange = rfbExtDesktopSize_ClientRequestedChange;\n        cl->lastDesktopSizeChangeError = cl->screen->setDesktopSizeHook(msg.sdm.width, msg.sdm.height, msg.sdm.numberOfScreens,\n                                           extDesktopScreens, cl);\n\n        if (cl->lastDesktopSizeChangeError == 0) {\n            /* Let other clients know it was this client that requested the change */\n            iterator = rfbGetClientIterator(cl->screen);\n            while ((clp = rfbClientIteratorNext(iterator)) != NULL) {\n                LOCK(clp->updateMutex);\n                if (clp != cl)\n                    clp->requestedDesktopSizeChange = rfbExtDesktopSize_OtherClientRequestedChange;\n                UNLOCK(clp->updateMutex);\n            }\n        }\n        else\n        {\n            /* Force ExtendedDesktopSize message to be sent with result code in case of error.\n               (In case of success, it is delayed until the new framebuffer is created) */\n            cl->newFBSizePending = TRUE;\n        }\n\n        free(extDesktopScreens);\n        return;\n\n    default:\n\t{\n\t    rfbExtensionData *e,*next;\n\n\t    for(e=cl->extensions; e;) {\n\t\tnext = e->next;\n\t\tif(e->extension->handleMessage &&\n\t\t\te->extension->handleMessage(cl, e->data, &msg))\n                {\n                    rfbStatRecordMessageRcvd(cl, msg.type, 0, 0); /* Extension should handle this */\n\t\t    return;\n                }\n\t\te = next;\n\t    }\n\n\t    rfbLog(\"rfbProcessClientNormalMessage: unknown message type %d\\n\",\n\t\t    msg.type);\n\t    rfbLog(\" ... closing connection\\n\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n    }\n}\n\n\n\n/*\n * rfbSendFramebufferUpdate - send the currently pending framebuffer update to\n * the RFB client.\n * givenUpdateRegion is not changed.\n */\n\nrfbBool\nrfbSendFramebufferUpdate(rfbClientPtr cl,\n                         sraRegionPtr givenUpdateRegion)\n{\n    sraRectangleIterator* i=NULL;\n    sraRect rect;\n    int nUpdateRegionRects;\n    rfbFramebufferUpdateMsg *fu = (rfbFramebufferUpdateMsg *)cl->updateBuf;\n    sraRegionPtr updateRegion,updateCopyRegion,tmpRegion;\n    int dx, dy;\n    rfbBool sendCursorShape = FALSE;\n    rfbBool sendCursorPos = FALSE;\n    rfbBool sendKeyboardLedState = FALSE;\n    rfbBool sendSupportedMessages = FALSE;\n    rfbBool sendSupportedEncodings = FALSE;\n    rfbBool sendServerIdentity = FALSE;\n    rfbBool result = TRUE;\n    \n\n    if(cl->screen->displayHook)\n      cl->screen->displayHook(cl);\n\n    /*\n     * If framebuffer size was changed and the client supports NewFBSize\n     * encoding, just send NewFBSize marker and return.\n     */\n\n    if (cl->useNewFBSize && cl->newFBSizePending) {\n      LOCK(cl->updateMutex);\n      cl->newFBSizePending = FALSE;\n      UNLOCK(cl->updateMutex);\n      fu->type = rfbFramebufferUpdate;\n      fu->nRects = Swap16IfLE(1);\n      cl->ublen = sz_rfbFramebufferUpdateMsg;\n\n      if (cl->useExtDesktopSize) {\n        if (!rfbSendExtDesktopSize(cl, cl->scaledScreen->width, cl->scaledScreen->height)) {\n          if(cl->screen->displayFinishedHook)\n            cl->screen->displayFinishedHook(cl, FALSE);\n          return FALSE;\n        }\n      }\n      else if (!rfbSendNewFBSize(cl, cl->scaledScreen->width, cl->scaledScreen->height)) {\n\tif(cl->screen->displayFinishedHook)\n\t  cl->screen->displayFinishedHook(cl, FALSE);\n        return FALSE;\n      }\n      result = rfbSendUpdateBuf(cl);\n      if(cl->screen->displayFinishedHook)\n\tcl->screen->displayFinishedHook(cl, result);\n      return result;\n    }\n    \n    /*\n     * If this client understands cursor shape updates, cursor should be\n     * removed from the framebuffer. Otherwise, make sure it's put up.\n     */\n\n    if (cl->enableCursorShapeUpdates) {\n      if (cl->cursorWasChanged && cl->readyForSetColourMapEntries)\n\t  sendCursorShape = TRUE;\n    }\n\n    /*\n     * Do we plan to send cursor position update?\n     */\n\n    if (cl->enableCursorPosUpdates && cl->cursorWasMoved)\n      sendCursorPos = TRUE;\n\n    /*\n     * Do we plan to send a keyboard state update?\n     */\n    if ((cl->enableKeyboardLedState) &&\n\t(cl->screen->getKeyboardLedStateHook!=NULL))\n    {\n        int x;\n        x=cl->screen->getKeyboardLedStateHook(cl->screen);\n        if (x!=cl->lastKeyboardLedState)\n        {\n            sendKeyboardLedState = TRUE;\n            cl->lastKeyboardLedState=x;\n        }\n    }\n\n    /*\n     * Do we plan to send a rfbEncodingSupportedMessages?\n     */\n    if (cl->enableSupportedMessages)\n    {\n        sendSupportedMessages = TRUE;\n        /* We only send this message ONCE <per setEncodings message received>\n         * (We disable it here)\n         */\n        cl->enableSupportedMessages = FALSE;\n    }\n    /*\n     * Do we plan to send a rfbEncodingSupportedEncodings?\n     */\n    if (cl->enableSupportedEncodings)\n    {\n        sendSupportedEncodings = TRUE;\n        /* We only send this message ONCE <per setEncodings message received>\n         * (We disable it here)\n         */\n        cl->enableSupportedEncodings = FALSE;\n    }\n    /*\n     * Do we plan to send a rfbEncodingServerIdentity?\n     */\n    if (cl->enableServerIdentity)\n    {\n        sendServerIdentity = TRUE;\n        /* We only send this message ONCE <per setEncodings message received>\n         * (We disable it here)\n         */\n        cl->enableServerIdentity = FALSE;\n    }\n\n    LOCK(cl->updateMutex);\n\n    /*\n     * The modifiedRegion may overlap the destination copyRegion.  We remove\n     * any overlapping bits from the copyRegion (since they'd only be\n     * overwritten anyway).\n     */\n    \n    sraRgnSubtract(cl->copyRegion,cl->modifiedRegion);\n\n    /*\n     * The client is interested in the region requestedRegion.  The region\n     * which should be updated now is the intersection of requestedRegion\n     * and the union of modifiedRegion and copyRegion.  If it's empty then\n     * no update is needed.\n     */\n\n    updateRegion = sraRgnCreateRgn(givenUpdateRegion);\n    if(cl->screen->progressiveSliceHeight>0) {\n\t    int height=cl->screen->progressiveSliceHeight,\n\t    \ty=cl->progressiveSliceY;\n\t    sraRegionPtr bbox=sraRgnBBox(updateRegion);\n\t    sraRect rect;\n\t    if(sraRgnPopRect(bbox,&rect,0)) {\n\t\tsraRegionPtr slice;\n\t\tif(y<rect.y1 || y>=rect.y2)\n\t\t    y=rect.y1;\n\t    \tslice=sraRgnCreateRect(0,y,cl->screen->width,y+height);\n\t\tsraRgnAnd(updateRegion,slice);\n\t\tsraRgnDestroy(slice);\n\t    }\n\t    sraRgnDestroy(bbox);\n\t    y+=height;\n\t    if(y>=cl->screen->height)\n\t\t    y=0;\n\t    cl->progressiveSliceY=y;\n    }\n\n    sraRgnOr(updateRegion,cl->copyRegion);\n    if(!sraRgnAnd(updateRegion,cl->requestedRegion) &&\n       sraRgnEmpty(updateRegion) &&\n       (cl->enableCursorShapeUpdates ||\n\t(cl->cursorX == cl->screen->cursorX && cl->cursorY == cl->screen->cursorY)) &&\n       !sendCursorShape && !sendCursorPos && !sendKeyboardLedState &&\n       !sendSupportedMessages && !sendSupportedEncodings && !sendServerIdentity) {\n      sraRgnDestroy(updateRegion);\n      UNLOCK(cl->updateMutex);\n      if(cl->screen->displayFinishedHook)\n\tcl->screen->displayFinishedHook(cl, TRUE);\n      return TRUE;\n    }\n\n    /*\n     * We assume that the client doesn't have any pixel data outside the\n     * requestedRegion.  In other words, both the source and destination of a\n     * copy must lie within requestedRegion.  So the region we can send as a\n     * copy is the intersection of the copyRegion with both the requestedRegion\n     * and the requestedRegion translated by the amount of the copy.  We set\n     * updateCopyRegion to this.\n     */\n\n    updateCopyRegion = sraRgnCreateRgn(cl->copyRegion);\n    sraRgnAnd(updateCopyRegion,cl->requestedRegion);\n    tmpRegion = sraRgnCreateRgn(cl->requestedRegion);\n    sraRgnOffset(tmpRegion,cl->copyDX,cl->copyDY);\n    sraRgnAnd(updateCopyRegion,tmpRegion);\n    sraRgnDestroy(tmpRegion);\n    dx = cl->copyDX;\n    dy = cl->copyDY;\n\n    /*\n     * Next we remove updateCopyRegion from updateRegion so that updateRegion\n     * is the part of this update which is sent as ordinary pixel data (i.e not\n     * a copy).\n     */\n\n    sraRgnSubtract(updateRegion,updateCopyRegion);\n\n    /*\n     * Finally we leave modifiedRegion to be the remainder (if any) of parts of\n     * the screen which are modified but outside the requestedRegion.  We also\n     * empty both the requestedRegion and the copyRegion - note that we never\n     * carry over a copyRegion for a future update.\n     */\n\n     sraRgnOr(cl->modifiedRegion,cl->copyRegion);\n     sraRgnSubtract(cl->modifiedRegion,updateRegion);\n     sraRgnSubtract(cl->modifiedRegion,updateCopyRegion);\n\n     sraRgnMakeEmpty(cl->requestedRegion);\n     sraRgnMakeEmpty(cl->copyRegion);\n     cl->copyDX = 0;\n     cl->copyDY = 0;\n   \n     UNLOCK(cl->updateMutex);\n   \n    if (!cl->enableCursorShapeUpdates) {\n      if(cl->cursorX != cl->screen->cursorX || cl->cursorY != cl->screen->cursorY) {\n\trfbRedrawAfterHideCursor(cl,updateRegion);\n\tLOCK(cl->screen->cursorMutex);\n\tcl->cursorX = cl->screen->cursorX;\n\tcl->cursorY = cl->screen->cursorY;\n\tUNLOCK(cl->screen->cursorMutex);\n\trfbRedrawAfterHideCursor(cl,updateRegion);\n      }\n      rfbShowCursor(cl);\n    }\n\n    /*\n     * Now send the update.\n     */\n    \n    rfbStatRecordMessageSent(cl, rfbFramebufferUpdate, 0, 0);\n    if (cl->preferredEncoding == rfbEncodingCoRRE) {\n        nUpdateRegionRects = 0;\n\n        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n            int x = rect.x1;\n            int y = rect.y1;\n            int w = rect.x2 - x;\n            int h = rect.y2 - y;\n\t    int rectsPerRow, rows;\n            /* We need to count the number of rects in the scaled screen */\n            if (cl->screen!=cl->scaledScreen)\n                rfbScaledCorrection(cl->screen, cl->scaledScreen, &x, &y, &w, &h, \"rfbSendFramebufferUpdate\");\n\t    rectsPerRow = (w-1)/cl->correMaxWidth+1;\n\t    rows = (h-1)/cl->correMaxHeight+1;\n\t    nUpdateRegionRects += rectsPerRow*rows;\n        }\n\tsraRgnReleaseIterator(i); i=NULL;\n    } else if (cl->preferredEncoding == rfbEncodingUltra) {\n        nUpdateRegionRects = 0;\n        \n        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n            int x = rect.x1;\n            int y = rect.y1;\n            int w = rect.x2 - x;\n            int h = rect.y2 - y;\n            /* We need to count the number of rects in the scaled screen */\n            if (cl->screen!=cl->scaledScreen)\n                rfbScaledCorrection(cl->screen, cl->scaledScreen, &x, &y, &w, &h, \"rfbSendFramebufferUpdate\");\n            nUpdateRegionRects += (((h-1) / (ULTRA_MAX_SIZE( w ) / w)) + 1);\n          }\n        sraRgnReleaseIterator(i); i=NULL;\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n    } else if (cl->preferredEncoding == rfbEncodingZlib) {\n\tnUpdateRegionRects = 0;\n\n        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n            int x = rect.x1;\n            int y = rect.y1;\n            int w = rect.x2 - x;\n            int h = rect.y2 - y;\n            /* We need to count the number of rects in the scaled screen */\n            if (cl->screen!=cl->scaledScreen)\n                rfbScaledCorrection(cl->screen, cl->scaledScreen, &x, &y, &w, &h, \"rfbSendFramebufferUpdate\");\n\t    nUpdateRegionRects += (((h-1) / (ZLIB_MAX_SIZE( w ) / w)) + 1);\n\t}\n\tsraRgnReleaseIterator(i); i=NULL;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n    } else if (cl->preferredEncoding == rfbEncodingTight) {\n\tnUpdateRegionRects = 0;\n\n        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n            int x = rect.x1;\n            int y = rect.y1;\n            int w = rect.x2 - x;\n            int h = rect.y2 - y;\n            int n;\n            /* We need to count the number of rects in the scaled screen */\n            if (cl->screen!=cl->scaledScreen)\n                rfbScaledCorrection(cl->screen, cl->scaledScreen, &x, &y, &w, &h, \"rfbSendFramebufferUpdate\");\n\t    n = rfbNumCodedRectsTight(cl, x, y, w, h);\n\t    if (n == 0) {\n\t\tnUpdateRegionRects = 0xFFFF;\n\t\tbreak;\n\t    }\n\t    nUpdateRegionRects += n;\n\t}\n\tsraRgnReleaseIterator(i); i=NULL;\n#endif\n#endif\n#if defined(LIBVNCSERVER_HAVE_LIBJPEG) && defined(LIBVNCSERVER_HAVE_LIBPNG)\n    } else if (cl->preferredEncoding == rfbEncodingTightPng) {\n\tnUpdateRegionRects = 0;\n\n        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n            int x = rect.x1;\n            int y = rect.y1;\n            int w = rect.x2 - x;\n            int h = rect.y2 - y;\n            int n;\n            /* We need to count the number of rects in the scaled screen */\n            if (cl->screen!=cl->scaledScreen)\n                rfbScaledCorrection(cl->screen, cl->scaledScreen, &x, &y, &w, &h, \"rfbSendFramebufferUpdate\");\n\t    n = rfbNumCodedRectsTight(cl, x, y, w, h);\n\t    if (n == 0) {\n\t\tnUpdateRegionRects = 0xFFFF;\n\t\tbreak;\n\t    }\n\t    nUpdateRegionRects += n;\n\t}\n\tsraRgnReleaseIterator(i); i=NULL;\n#endif\n    } else {\n        nUpdateRegionRects = sraRgnCountRects(updateRegion);\n    }\n\n    fu->type = rfbFramebufferUpdate;\n    if (nUpdateRegionRects != 0xFFFF) {\n\tif(cl->screen->maxRectsPerUpdate>0\n\t   /* CoRRE splits the screen into smaller squares */\n\t   && cl->preferredEncoding != rfbEncodingCoRRE\n\t   /* Ultra encoding splits rectangles up into smaller chunks */\n           && cl->preferredEncoding != rfbEncodingUltra\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\t   /* Zlib encoding splits rectangles up into smaller chunks */\n\t   && cl->preferredEncoding != rfbEncodingZlib\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t   /* Tight encoding counts the rectangles differently */\n\t   && cl->preferredEncoding != rfbEncodingTight\n#endif\n#endif\n#ifdef LIBVNCSERVER_HAVE_LIBPNG\n\t   /* Tight encoding counts the rectangles differently */\n\t   && cl->preferredEncoding != rfbEncodingTightPng\n#endif\n\t   && nUpdateRegionRects>cl->screen->maxRectsPerUpdate) {\n\t    sraRegion* newUpdateRegion = sraRgnBBox(updateRegion);\n\t    sraRgnDestroy(updateRegion);\n\t    updateRegion = newUpdateRegion;\n\t    nUpdateRegionRects = sraRgnCountRects(updateRegion);\n\t}\n\tfu->nRects = Swap16IfLE((uint16_t)(sraRgnCountRects(updateCopyRegion) +\n\t\t\t\t\t   nUpdateRegionRects +\n\t\t\t\t\t   !!sendCursorShape + !!sendCursorPos + !!sendKeyboardLedState +\n\t\t\t\t\t   !!sendSupportedMessages + !!sendSupportedEncodings + !!sendServerIdentity));\n    } else {\n\tfu->nRects = 0xFFFF;\n    }\n    cl->ublen = sz_rfbFramebufferUpdateMsg;\n\n   if (sendCursorShape) {\n\tcl->cursorWasChanged = FALSE;\n\tif (!rfbSendCursorShape(cl))\n\t    goto updateFailed;\n    }\n   \n   if (sendCursorPos) {\n\tcl->cursorWasMoved = FALSE;\n\tif (!rfbSendCursorPos(cl))\n\t        goto updateFailed;\n   }\n   \n   if (sendKeyboardLedState) {\n       if (!rfbSendKeyboardLedState(cl))\n           goto updateFailed;\n   }\n\n   if (sendSupportedMessages) {\n       if (!rfbSendSupportedMessages(cl))\n           goto updateFailed;\n   }\n   if (sendSupportedEncodings) {\n       if (!rfbSendSupportedEncodings(cl))\n           goto updateFailed;\n   }\n   if (sendServerIdentity) {\n       if (!rfbSendServerIdentity(cl))\n           goto updateFailed;\n   }\n\n    if (!sraRgnEmpty(updateCopyRegion)) {\n\tif (!rfbSendCopyRegion(cl,updateCopyRegion,dx,dy))\n\t        goto updateFailed;\n    }\n\n    for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n        int x = rect.x1;\n        int y = rect.y1;\n        int w = rect.x2 - x;\n        int h = rect.y2 - y;\n\n        /* We need to count the number of rects in the scaled screen */\n        if (cl->screen!=cl->scaledScreen)\n            rfbScaledCorrection(cl->screen, cl->scaledScreen, &x, &y, &w, &h, \"rfbSendFramebufferUpdate\");\n\n        switch (cl->preferredEncoding) {\n\tcase -1:\n        case rfbEncodingRaw:\n            if (!rfbSendRectEncodingRaw(cl, x, y, w, h))\n\t        goto updateFailed;\n            break;\n        case rfbEncodingRRE:\n            if (!rfbSendRectEncodingRRE(cl, x, y, w, h))\n\t        goto updateFailed;\n            break;\n        case rfbEncodingCoRRE:\n            if (!rfbSendRectEncodingCoRRE(cl, x, y, w, h))\n\t        goto updateFailed;\n\t    break;\n        case rfbEncodingHextile:\n            if (!rfbSendRectEncodingHextile(cl, x, y, w, h))\n\t        goto updateFailed;\n            break;\n        case rfbEncodingUltra:\n            if (!rfbSendRectEncodingUltra(cl, x, y, w, h))\n                goto updateFailed;\n            break;\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\tcase rfbEncodingZlib:\n\t    if (!rfbSendRectEncodingZlib(cl, x, y, w, h))\n\t        goto updateFailed;\n\t    break;\n       case rfbEncodingZRLE:\n       case rfbEncodingZYWRLE:\n           if (!rfbSendRectEncodingZRLE(cl, x, y, w, h))\n\t       goto updateFailed;\n           break;\n#endif\n#if defined(LIBVNCSERVER_HAVE_LIBJPEG) && (defined(LIBVNCSERVER_HAVE_LIBZ) || defined(LIBVNCSERVER_HAVE_LIBPNG))\n\tcase rfbEncodingTight:\n\t    if (!rfbSendRectEncodingTight(cl, x, y, w, h))\n\t        goto updateFailed;\n\t    break;\n#ifdef LIBVNCSERVER_HAVE_LIBPNG\n\tcase rfbEncodingTightPng:\n\t    if (!rfbSendRectEncodingTightPng(cl, x, y, w, h))\n\t        goto updateFailed;\n\t    break;\n#endif\n#endif\n        }\n    }\n    if (i) {\n        sraRgnReleaseIterator(i);\n        i = NULL;\n    }\n\n    if ( nUpdateRegionRects == 0xFFFF &&\n\t !rfbSendLastRectMarker(cl) )\n\t    goto updateFailed;\n\n    if (!rfbSendUpdateBuf(cl)) {\nupdateFailed:\n\tresult = FALSE;\n    }\n\n    if (!cl->enableCursorShapeUpdates) {\n      rfbHideCursor(cl);\n    }\n\n    if(i)\n        sraRgnReleaseIterator(i);\n    sraRgnDestroy(updateRegion);\n    sraRgnDestroy(updateCopyRegion);\n\n    if(cl->screen->displayFinishedHook)\n      cl->screen->displayFinishedHook(cl, result);\n    return result;\n}\n\n\n/*\n * Send the copy region as a string of CopyRect encoded rectangles.\n * The only slightly tricky thing is that we should send the messages in\n * the correct order so that an earlier CopyRect will not corrupt the source\n * of a later one.\n */\n\nrfbBool\nrfbSendCopyRegion(rfbClientPtr cl,\n                  sraRegionPtr reg,\n                  int dx,\n                  int dy)\n{\n    int x, y, w, h;\n    rfbFramebufferUpdateRectHeader rect;\n    rfbCopyRect cr;\n    sraRectangleIterator* i;\n    sraRect rect1;\n\n    /* printf(\"copyrect: \"); sraRgnPrint(reg); putchar('\\n');fflush(stdout); */\n    i = sraRgnGetReverseIterator(reg,dx>0,dy>0);\n\n    /* correct for the scale of the screen */\n    dx = ScaleX(cl->screen, cl->scaledScreen, dx);\n    dy = ScaleX(cl->screen, cl->scaledScreen, dy);\n\n    while(sraRgnIteratorNext(i,&rect1)) {\n      x = rect1.x1;\n      y = rect1.y1;\n      w = rect1.x2 - x;\n      h = rect1.y2 - y;\n\n      /* correct for scaling (if necessary) */\n      rfbScaledCorrection(cl->screen, cl->scaledScreen, &x, &y, &w, &h, \"copyrect\");\n\n      rect.r.x = Swap16IfLE(x);\n      rect.r.y = Swap16IfLE(y);\n      rect.r.w = Swap16IfLE(w);\n      rect.r.h = Swap16IfLE(h);\n      rect.encoding = Swap32IfLE(rfbEncodingCopyRect);\n\n      memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,\n\t     sz_rfbFramebufferUpdateRectHeader);\n      cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n      cr.srcX = Swap16IfLE(x - dx);\n      cr.srcY = Swap16IfLE(y - dy);\n\n      memcpy(&cl->updateBuf[cl->ublen], (char *)&cr, sz_rfbCopyRect);\n      cl->ublen += sz_rfbCopyRect;\n\n      rfbStatRecordEncodingSent(cl, rfbEncodingCopyRect, sz_rfbFramebufferUpdateRectHeader + sz_rfbCopyRect,\n          w * h  * (cl->scaledScreen->bitsPerPixel / 8));\n    }\n    sraRgnReleaseIterator(i);\n\n    return TRUE;\n}\n\n/*\n * Send a given rectangle in raw encoding (rfbEncodingRaw).\n */\n\nrfbBool\nrfbSendRectEncodingRaw(rfbClientPtr cl,\n                       int x,\n                       int y,\n                       int w,\n                       int h)\n{\n    rfbFramebufferUpdateRectHeader rect;\n    int nlines;\n    int bytesPerLine = w * (cl->format.bitsPerPixel / 8);\n    char *fbptr = (cl->scaledScreen->frameBuffer + (cl->scaledScreen->paddedWidthInBytes * y)\n                   + (x * (cl->scaledScreen->bitsPerPixel / 8)));\n\n    /* Flush the buffer to guarantee correct alignment for translateFn(). */\n    if (cl->ublen > 0) {\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n    }\n\n    rect.r.x = Swap16IfLE(x);\n    rect.r.y = Swap16IfLE(y);\n    rect.r.w = Swap16IfLE(w);\n    rect.r.h = Swap16IfLE(h);\n    rect.encoding = Swap32IfLE(rfbEncodingRaw);\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,sz_rfbFramebufferUpdateRectHeader);\n    cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n\n    rfbStatRecordEncodingSent(cl, rfbEncodingRaw, sz_rfbFramebufferUpdateRectHeader + bytesPerLine * h,\n        sz_rfbFramebufferUpdateRectHeader + bytesPerLine * h);\n\n    nlines = (UPDATE_BUF_SIZE - cl->ublen) / bytesPerLine;\n\n    while (TRUE) {\n        if (nlines > h)\n            nlines = h;\n\n        (*cl->translateFn)(cl->translateLookupTable,\n\t\t\t   &(cl->screen->serverFormat),\n                           &cl->format, fbptr, &cl->updateBuf[cl->ublen],\n                           cl->scaledScreen->paddedWidthInBytes, w, nlines);\n\n        cl->ublen += nlines * bytesPerLine;\n        h -= nlines;\n\n        if (h == 0)     /* rect fitted in buffer, do next one */\n            return TRUE;\n\n        /* buffer full - flush partial rect and do another nlines */\n\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n\n        fbptr += (cl->scaledScreen->paddedWidthInBytes * nlines);\n\n        nlines = (UPDATE_BUF_SIZE - cl->ublen) / bytesPerLine;\n        if (nlines == 0) {\n            rfbErr(\"rfbSendRectEncodingRaw: send buffer too small for %d \"\n                   \"bytes per line\\n\", bytesPerLine);\n            rfbCloseClient(cl);\n            return FALSE;\n        }\n    }\n}\n\n\n\n/*\n * Send an empty rectangle with encoding field set to value of\n * rfbEncodingLastRect to notify client that this is the last\n * rectangle in framebuffer update (\"LastRect\" extension of RFB\n * protocol).\n */\n\nrfbBool\nrfbSendLastRectMarker(rfbClientPtr cl)\n{\n    rfbFramebufferUpdateRectHeader rect;\n\n    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader > UPDATE_BUF_SIZE) {\n\tif (!rfbSendUpdateBuf(cl))\n\t    return FALSE;\n    }\n\n    rect.encoding = Swap32IfLE(rfbEncodingLastRect);\n    rect.r.x = 0;\n    rect.r.y = 0;\n    rect.r.w = 0;\n    rect.r.h = 0;\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,sz_rfbFramebufferUpdateRectHeader);\n    cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n\n    rfbStatRecordEncodingSent(cl, rfbEncodingLastRect, sz_rfbFramebufferUpdateRectHeader, sz_rfbFramebufferUpdateRectHeader);\n\n    return TRUE;\n}\n\n\n/*\n * Send NewFBSize pseudo-rectangle. This tells the client to change\n * its framebuffer size.\n */\n\nrfbBool\nrfbSendNewFBSize(rfbClientPtr cl,\n                 int w,\n                 int h)\n{\n    rfbFramebufferUpdateRectHeader rect;\n\n    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader > UPDATE_BUF_SIZE) {\n\tif (!rfbSendUpdateBuf(cl))\n\t    return FALSE;\n    }\n\n    if (cl->PalmVNC==TRUE)\n        rfbLog(\"Sending rfbEncodingNewFBSize in response to a PalmVNC style framebuffer resize (%dx%d)\\n\", w, h);\n    else\n        rfbLog(\"Sending rfbEncodingNewFBSize for resize to (%dx%d)\\n\", w, h);\n\n    rect.encoding = Swap32IfLE(rfbEncodingNewFBSize);\n    rect.r.x = 0;\n    rect.r.y = 0;\n    rect.r.w = Swap16IfLE(w);\n    rect.r.h = Swap16IfLE(h);\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,\n           sz_rfbFramebufferUpdateRectHeader);\n    cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n    rfbStatRecordEncodingSent(cl, rfbEncodingNewFBSize, sz_rfbFramebufferUpdateRectHeader, sz_rfbFramebufferUpdateRectHeader);\n\n    return TRUE;\n}\n\n/*\n * Send ExtDesktopSize pseudo-rectangle. This message is used:\n * - to tell the client to change its framebuffer size\n * - at the start of the session to inform the client we support size changes through setDesktopSize\n * - in response to setDesktopSize commands to indicate success or failure\n */\n\nrfbBool\nrfbSendExtDesktopSize(rfbClientPtr cl,\n                 int w,\n                 int h)\n{\n    rfbFramebufferUpdateRectHeader rect;\n    rfbExtDesktopSizeMsg edsHdr;\n    rfbExtDesktopScreen eds;\n    int i;\n    char *logmsg;\n    int numScreens = cl->screen->numberOfExtDesktopScreensHook(cl);\n\n    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader\n            + sz_rfbExtDesktopSizeMsg\n            + sz_rfbExtDesktopScreen * numScreens > UPDATE_BUF_SIZE) {\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n    }\n\n    rect.encoding = Swap32IfLE(rfbEncodingExtDesktopSize);\n    rect.r.w = Swap16IfLE(w);\n    rect.r.h = Swap16IfLE(h);\n    rect.r.x = Swap16IfLE(cl->requestedDesktopSizeChange);\n    rect.r.y = Swap16IfLE(cl->lastDesktopSizeChangeError);\n\n    logmsg = \"\";\n\n    if (cl->requestedDesktopSizeChange == rfbExtDesktopSize_ClientRequestedChange)\n    {\n        /* our client requested the resize through setDesktopSize */\n\n        switch (cl->lastDesktopSizeChangeError)\n        {\n        case rfbExtDesktopSize_Success:\n            logmsg = \"resize successful\";\n            break;\n        case rfbExtDesktopSize_ResizeProhibited:\n            logmsg = \"resize prohibited\";\n            break;\n        case rfbExtDesktopSize_OutOfResources:\n            logmsg = \"resize failed: out of resources\";\n            break;\n        case rfbExtDesktopSize_InvalidScreenLayout:\n            logmsg = \"resize failed: invalid screen layout\";\n            break;\n        default:\n            break;\n        }\n    }\n\n    cl->requestedDesktopSizeChange = 0;\n    cl->lastDesktopSizeChangeError = 0;\n\n    rfbLog(\"Sending rfbEncodingExtDesktopSize for size (%dx%d) %s\\n\", w, h, logmsg);\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,\n           sz_rfbFramebufferUpdateRectHeader);\n    cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n    edsHdr.numberOfScreens = numScreens;\n    edsHdr.pad[0] = edsHdr.pad[1] = edsHdr.pad[2] = 0;\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&edsHdr,\n           sz_rfbExtDesktopSizeMsg);\n    cl->ublen += sz_rfbExtDesktopSizeMsg;\n\n    for (i=0; i<numScreens; i++) {\n        if (!cl->screen->getExtDesktopScreenHook(i, &eds, cl))\n        {\n            rfbErr(\"Error getting ExtendedDesktopSize information for screen #%d\\n\", i);\n            return FALSE;\n        }\n        eds.id = Swap32IfLE(eds.id);\n        eds.x = Swap16IfLE(eds.x);\n        eds.y = Swap16IfLE(eds.y);\n        eds.width = Swap16IfLE(eds.width);\n        eds.height = Swap16IfLE(eds.height);\n        eds.flags = Swap32IfLE(eds.flags);\n        memcpy(&cl->updateBuf[cl->ublen], (char *)&eds,\n               sz_rfbExtDesktopScreen);\n        cl->ublen += sz_rfbExtDesktopScreen;\n    }\n\n    rfbStatRecordEncodingSent(cl, rfbEncodingExtDesktopSize,\n                              sz_rfbFramebufferUpdateRectHeader + sz_rfbExtDesktopSizeMsg + sz_rfbExtDesktopScreen * numScreens,\n                              sz_rfbFramebufferUpdateRectHeader + sz_rfbExtDesktopSizeMsg + sz_rfbExtDesktopScreen * numScreens);\n\n    return TRUE;\n}\n\n/*\n * Send the contents of cl->updateBuf.  Returns 1 if successful, -1 if\n * not (errno should be set).\n */\n\nrfbBool\nrfbSendUpdateBuf(rfbClientPtr cl)\n{\n    if(cl->sock<0)\n      return FALSE;\n\n    if (rfbWriteExact(cl, cl->updateBuf, cl->ublen) < 0) {\n        rfbLogPerror(\"rfbSendUpdateBuf: write\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n\n    cl->ublen = 0;\n    return TRUE;\n}\n\n/*\n * rfbSendSetColourMapEntries sends a SetColourMapEntries message to the\n * client, using values from the currently installed colormap.\n */\n\nrfbBool\nrfbSendSetColourMapEntries(rfbClientPtr cl,\n                           int firstColour,\n                           int nColours)\n{\n    char buf[sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2];\n    char *wbuf = buf;\n    rfbSetColourMapEntriesMsg *scme;\n    uint16_t *rgb;\n    rfbColourMap* cm = &cl->screen->colourMap;\n    int i, len;\n\n    if (nColours > 256) {\n\t/* some rare hardware has, e.g., 4096 colors cells: PseudoColor:12 */\n    \twbuf = (char *) malloc(sz_rfbSetColourMapEntriesMsg + nColours * 3 * 2);\n    }\n\n    scme = (rfbSetColourMapEntriesMsg *)wbuf;\n    rgb = (uint16_t *)(&wbuf[sz_rfbSetColourMapEntriesMsg]);\n\n    scme->type = rfbSetColourMapEntries;\n\n    scme->firstColour = Swap16IfLE(firstColour);\n    scme->nColours = Swap16IfLE(nColours);\n\n    len = sz_rfbSetColourMapEntriesMsg;\n\n    for (i = 0; i < nColours; i++) {\n      if(i<(int)cm->count) {\n\tif(cm->is16) {\n\t  rgb[i*3] = Swap16IfLE(cm->data.shorts[i*3]);\n\t  rgb[i*3+1] = Swap16IfLE(cm->data.shorts[i*3+1]);\n\t  rgb[i*3+2] = Swap16IfLE(cm->data.shorts[i*3+2]);\n\t} else {\n\t  rgb[i*3] = Swap16IfLE((unsigned short)cm->data.bytes[i*3]);\n\t  rgb[i*3+1] = Swap16IfLE((unsigned short)cm->data.bytes[i*3+1]);\n\t  rgb[i*3+2] = Swap16IfLE((unsigned short)cm->data.bytes[i*3+2]);\n\t}\n      }\n    }\n\n    len += nColours * 3 * 2;\n\n    LOCK(cl->sendMutex);\n    if (rfbWriteExact(cl, wbuf, len) < 0) {\n\trfbLogPerror(\"rfbSendSetColourMapEntries: write\");\n\trfbCloseClient(cl);\n        if (wbuf != buf) free(wbuf);\n        UNLOCK(cl->sendMutex);\n\treturn FALSE;\n    }\n    UNLOCK(cl->sendMutex);\n\n    rfbStatRecordMessageSent(cl, rfbSetColourMapEntries, len, len);\n    if (wbuf != buf) free(wbuf);\n    return TRUE;\n}\n\n/*\n * rfbSendBell sends a Bell message to all the clients.\n */\n\nvoid\nrfbSendBell(rfbScreenInfoPtr rfbScreen)\n{\n    rfbClientIteratorPtr i;\n    rfbClientPtr cl;\n    rfbBellMsg b;\n\n    i = rfbGetClientIterator(rfbScreen);\n    while((cl=rfbClientIteratorNext(i))) {\n\tb.type = rfbBell;\n        LOCK(cl->sendMutex);\n\tif (rfbWriteExact(cl, (char *)&b, sz_rfbBellMsg) < 0) {\n\t    rfbLogPerror(\"rfbSendBell: write\");\n\t    rfbCloseClient(cl);\n\t}\n        UNLOCK(cl->sendMutex);\n    }\n    rfbStatRecordMessageSent(cl, rfbBell, sz_rfbBellMsg, sz_rfbBellMsg);\n    rfbReleaseClientIterator(i);\n}\n\n\n/*\n * rfbSendServerCutText sends a ServerCutText message to all the clients.\n */\n\nvoid\nrfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        LOCK(cl->sendMutex);\n        if (rfbWriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            UNLOCK(cl->sendMutex);\n            continue;\n        }\n        if (rfbWriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n        UNLOCK(cl->sendMutex);\n        rfbStatRecordMessageSent(cl, rfbServerCutText, sz_rfbServerCutTextMsg+len, sz_rfbServerCutTextMsg+len);\n    }\n    rfbReleaseClientIterator(iterator);\n}\n\n/*****************************************************************************\n *\n * UDP can be used for keyboard and pointer events when the underlying\n * network is highly reliable.  This is really here to support ORL's\n * videotile, whose TCP implementation doesn't like sending lots of small\n * packets (such as 100s of pen readings per second!).\n */\n\nstatic unsigned char ptrAcceleration = 50;\n\nvoid\nrfbNewUDPConnection(rfbScreenInfoPtr rfbScreen,\n                    int sock)\n{\n  if (write(sock, (char*) &ptrAcceleration, 1) < 0) {\n\trfbLogPerror(\"rfbNewUDPConnection: write\");\n    }\n}\n\n/*\n * Because UDP is a message based service, we can't read the first byte and\n * then the rest of the packet separately like we do with TCP.  We will always\n * get a whole packet delivered in one go, so we ask read() for the maximum\n * number of bytes we can possibly get.\n */\n\nvoid\nrfbProcessUDPInput(rfbScreenInfoPtr rfbScreen)\n{\n    int n;\n    rfbClientPtr cl=rfbScreen->udpClient;\n    rfbClientToServerMsg msg;\n\n    if((!cl) || cl->onHold)\n      return;\n\n    if ((n = read(rfbScreen->udpSock, (char *)&msg, sizeof(msg))) <= 0) {\n\tif (n < 0) {\n\t    rfbLogPerror(\"rfbProcessUDPInput: read\");\n\t}\n\trfbDisconnectUDPSock(rfbScreen);\n\treturn;\n    }\n\n    switch (msg.type) {\n\n    case rfbKeyEvent:\n\tif (n != sz_rfbKeyEventMsg) {\n\t    rfbErr(\"rfbProcessUDPInput: key event incorrect length\\n\");\n\t    rfbDisconnectUDPSock(rfbScreen);\n\t    return;\n\t}\n\tcl->screen->kbdAddEvent(msg.ke.down, (rfbKeySym)Swap32IfLE(msg.ke.key), cl);\n\tbreak;\n\n    case rfbPointerEvent:\n\tif (n != sz_rfbPointerEventMsg) {\n\t    rfbErr(\"rfbProcessUDPInput: ptr event incorrect length\\n\");\n\t    rfbDisconnectUDPSock(rfbScreen);\n\t    return;\n\t}\n\tcl->screen->ptrAddEvent(msg.pe.buttonMask,\n\t\t    Swap16IfLE(msg.pe.x), Swap16IfLE(msg.pe.y), cl);\n\tbreak;\n\n    default:\n\trfbErr(\"rfbProcessUDPInput: unknown message type %d\\n\",\n\t       msg.type);\n\trfbDisconnectUDPSock(rfbScreen);\n    }\n}\n\n\n"], "fixing_code": ["/*\n * rfbserver.c - deal with server-side of the RFB protocol.\n */\n\n/*\n *  Copyright (C) 2011-2012 D. R. Commander\n *  Copyright (C) 2005 Rohit Kumar, Johannes E. Schindelin\n *  Copyright (C) 2002 RealVNC Ltd.\n *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.\n *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  \n *  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n#ifdef __STRICT_ANSI__\n#define _BSD_SOURCE\n#define _POSIX_SOURCE\n#define _XOPEN_SOURCE 600\n#endif\n\n#include <stdio.h>\n#include <string.h>\n#include <rfb/rfb.h>\n#include <rfb/rfbregion.h>\n#include \"private.h\"\n#include \"rfb/rfbconfig.h\"\n\n#ifdef LIBVNCSERVER_HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n\n#ifdef WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <io.h>\n#define write(sock,buf,len) send(sock,buf,len,0)\n#else\n#ifdef LIBVNCSERVER_HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#include <pwd.h>\n#ifdef LIBVNCSERVER_HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n#ifdef LIBVNCSERVER_HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#endif\n#endif\n\n#ifdef DEBUGPROTO\n#undef DEBUGPROTO\n#define DEBUGPROTO(x) x\n#else\n#define DEBUGPROTO(x)\n#endif\n#include <stdarg.h>\n#include <scale.h>\n/* stst() */\n#include <sys/types.h>\n#include <sys/stat.h>\n#if LIBVNCSERVER_HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#ifndef WIN32\n/* readdir() */\n#include <dirent.h>\n#endif\n\n/* errno */\n#include <errno.h>\n/* strftime() */\n#include <time.h>\n/* INT_MAX */\n#include <limits.h>\n\n#ifdef LIBVNCSERVER_WITH_WEBSOCKETS\n#include \"rfbssl.h\"\n#endif\n\n#ifdef _MSC_VER\n#define snprintf _snprintf /* Missing in MSVC */\n/* Prevent POSIX deprecation warnings */\n#define close _close\n#define strdup _strdup \n#endif\n\n#ifdef WIN32\n#include <direct.h>\n#ifdef __MINGW32__\n#define mkdir(path, perms) mkdir(path) /* Omit the perms argument to match POSIX signature */\n#else /* MSVC and other windows compilers */\n#define mkdir(path, perms) _mkdir(path) /* Omit the perms argument to match POSIX signature */\n#endif /* __MINGW32__ else... */\n#ifndef S_ISDIR\n#define S_ISDIR(m)\t(((m) & S_IFDIR) == S_IFDIR)\n#endif\n#endif\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n/*\n * Map of quality levels to provide compatibility with TightVNC/TigerVNC\n * clients.  This emulates the behavior of the TigerVNC Server.\n */\n\nstatic const int tight2turbo_qual[10] = {\n   15, 29, 41, 42, 62, 77, 79, 86, 92, 100\n};\n\nstatic const int tight2turbo_subsamp[10] = {\n   1, 1, 1, 2, 2, 2, 0, 0, 0, 0\n};\n#endif\n\nstatic void rfbProcessClientProtocolVersion(rfbClientPtr cl);\nstatic void rfbProcessClientNormalMessage(rfbClientPtr cl);\nstatic void rfbProcessClientInitMessage(rfbClientPtr cl);\n\n#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD\nvoid rfbIncrClientRef(rfbClientPtr cl)\n{\n  LOCK(cl->refCountMutex);\n  cl->refCount++;\n  UNLOCK(cl->refCountMutex);\n}\n\nvoid rfbDecrClientRef(rfbClientPtr cl)\n{\n  LOCK(cl->refCountMutex);\n  cl->refCount--;\n  if(cl->refCount<=0) /* just to be sure also < 0 */\n    TSIGNAL(cl->deleteCond);\n  UNLOCK(cl->refCountMutex);\n}\n#else\nvoid rfbIncrClientRef(rfbClientPtr cl) {}\nvoid rfbDecrClientRef(rfbClientPtr cl) {}\n#endif\n\n#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD\nstatic MUTEX(rfbClientListMutex);\n#endif\n\nstruct rfbClientIterator {\n  rfbClientPtr next;\n  rfbScreenInfoPtr screen;\n  rfbBool closedToo;\n};\n\nvoid\nrfbClientListInit(rfbScreenInfoPtr rfbScreen)\n{\n    if(sizeof(rfbBool)!=1) {\n        /* a sanity check */\n        fprintf(stderr,\"rfbBool's size is not 1 (%d)!\\n\",(int)sizeof(rfbBool));\n\t/* we cannot continue, because rfbBool is supposed to be char everywhere */\n\texit(1);\n    }\n    rfbScreen->clientHead = NULL;\n    INIT_MUTEX(rfbClientListMutex);\n}\n\nrfbClientIteratorPtr\nrfbGetClientIterator(rfbScreenInfoPtr rfbScreen)\n{\n  rfbClientIteratorPtr i =\n    (rfbClientIteratorPtr)malloc(sizeof(struct rfbClientIterator));\n  i->next = NULL;\n  i->screen = rfbScreen;\n  i->closedToo = FALSE;\n  return i;\n}\n\nrfbClientIteratorPtr\nrfbGetClientIteratorWithClosed(rfbScreenInfoPtr rfbScreen)\n{\n  rfbClientIteratorPtr i =\n    (rfbClientIteratorPtr)malloc(sizeof(struct rfbClientIterator));\n  i->next = NULL;\n  i->screen = rfbScreen;\n  i->closedToo = TRUE;\n  return i;\n}\n\nrfbClientPtr\nrfbClientIteratorHead(rfbClientIteratorPtr i)\n{\n#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD\n  if(i->next != 0) {\n    rfbDecrClientRef(i->next);\n    rfbIncrClientRef(i->screen->clientHead);\n  }\n#endif\n  LOCK(rfbClientListMutex);\n  i->next = i->screen->clientHead;\n  UNLOCK(rfbClientListMutex);\n  return i->next;\n}\n\nrfbClientPtr\nrfbClientIteratorNext(rfbClientIteratorPtr i)\n{\n  if(i->next == 0) {\n    LOCK(rfbClientListMutex);\n    i->next = i->screen->clientHead;\n    UNLOCK(rfbClientListMutex);\n  } else {\n    IF_PTHREADS(rfbClientPtr cl = i->next);\n    i->next = i->next->next;\n    IF_PTHREADS(rfbDecrClientRef(cl));\n  }\n\n#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD\n    if(!i->closedToo)\n      while(i->next && i->next->sock<0)\n        i->next = i->next->next;\n    if(i->next)\n      rfbIncrClientRef(i->next);\n#endif\n\n    return i->next;\n}\n\nvoid\nrfbReleaseClientIterator(rfbClientIteratorPtr iterator)\n{\n  IF_PTHREADS(if(iterator->next) rfbDecrClientRef(iterator->next));\n  free(iterator);\n}\n\n\n/*\n * rfbNewClientConnection is called from sockets.c when a new connection\n * comes in.\n */\n\nvoid\nrfbNewClientConnection(rfbScreenInfoPtr rfbScreen,\n                       int sock)\n{\n    rfbNewClient(rfbScreen,sock);\n}\n\n\n/*\n * rfbReverseConnection is called to make an outward\n * connection to a \"listening\" RFB client.\n */\n\nrfbClientPtr\nrfbReverseConnection(rfbScreenInfoPtr rfbScreen,\n                     char *host,\n                     int port)\n{\n    int sock;\n    rfbClientPtr cl;\n\n    if ((sock = rfbConnect(rfbScreen, host, port)) < 0)\n        return (rfbClientPtr)NULL;\n\n    cl = rfbNewClient(rfbScreen, sock);\n\n    if (cl) {\n        cl->reverseConnection = TRUE;\n    }\n\n    return cl;\n}\n\n\nvoid\nrfbSetProtocolVersion(rfbScreenInfoPtr rfbScreen, int major_, int minor_)\n{\n    /* Permit the server to set the version to report */\n    /* TODO: sanity checking */\n    if ((major_==3) && (minor_ > 2 && minor_ < 9))\n    {\n      rfbScreen->protocolMajorVersion = major_;\n      rfbScreen->protocolMinorVersion = minor_;\n    }\n    else\n        rfbLog(\"rfbSetProtocolVersion(%d,%d) set to invalid values\\n\", major_, minor_);\n}\n\n/*\n * rfbNewClient is called when a new connection has been made by whatever\n * means.\n */\n\nstatic rfbClientPtr\nrfbNewTCPOrUDPClient(rfbScreenInfoPtr rfbScreen,\n                     int sock,\n                     rfbBool isUDP)\n{\n    rfbProtocolVersionMsg pv;\n    rfbClientIteratorPtr iterator;\n    rfbClientPtr cl,cl_;\n#ifdef LIBVNCSERVER_IPv6\n    struct sockaddr_storage addr;\n#else\n    struct sockaddr_in addr;\n#endif\n    socklen_t addrlen = sizeof(addr);\n    rfbProtocolExtension* extension;\n\n    cl = (rfbClientPtr)calloc(sizeof(rfbClientRec),1);\n\n    cl->screen = rfbScreen;\n    cl->sock = sock;\n    cl->viewOnly = FALSE;\n    /* setup pseudo scaling */\n    cl->scaledScreen = rfbScreen;\n    cl->scaledScreen->scaledScreenRefCount++;\n\n    rfbResetStats(cl);\n\n    cl->clientData = NULL;\n    cl->clientGoneHook = rfbDoNothingWithClient;\n\n    if(isUDP) {\n      rfbLog(\" accepted UDP client\\n\");\n\t} else {\n#ifdef LIBVNCSERVER_IPv6\n\t\tchar host[1024];\n#endif\n      int one=1;\n      size_t otherClientsCount = 0;\n\n      getpeername(sock, (struct sockaddr *)&addr, &addrlen);\n#ifdef LIBVNCSERVER_IPv6\n      if(getnameinfo((struct sockaddr*)&addr, addrlen, host, sizeof(host), NULL, 0, NI_NUMERICHOST) != 0) {\n\trfbLogPerror(\"rfbNewClient: error in getnameinfo\");\n\tcl->host = strdup(\"\");\n      }\n      else\n\tcl->host = strdup(host);\n#else\n      cl->host = strdup(inet_ntoa(addr.sin_addr));\n#endif\n\n      iterator = rfbGetClientIterator(rfbScreen);\n      while ((cl_ = rfbClientIteratorNext(iterator)) != NULL)\n\t  ++otherClientsCount;\n      rfbReleaseClientIterator(iterator);\n      rfbLog(\"  %lu other clients\\n\", (unsigned long) otherClientsCount);\n\n      if(!rfbSetNonBlocking(sock)) {\n\tclose(sock);\n\treturn NULL;\n      }\n\n      if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,\n\t\t     (char *)&one, sizeof(one)) < 0) {\n\trfbLogPerror(\"setsockopt failed: can't set TCP_NODELAY flag, non TCP socket?\");\n      }\n\n      FD_SET(sock,&(rfbScreen->allFds));\n\t\trfbScreen->maxFd = rfbMax(sock,rfbScreen->maxFd);\n\n      INIT_MUTEX(cl->outputMutex);\n      INIT_MUTEX(cl->refCountMutex);\n      INIT_MUTEX(cl->sendMutex);\n      INIT_COND(cl->deleteCond);\n\n      cl->state = RFB_PROTOCOL_VERSION;\n\n      cl->reverseConnection = FALSE;\n      cl->readyForSetColourMapEntries = FALSE;\n      cl->useCopyRect = FALSE;\n      cl->preferredEncoding = -1;\n      cl->correMaxWidth = 48;\n      cl->correMaxHeight = 48;\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n      cl->zrleData = NULL;\n#endif\n\n      cl->copyRegion = sraRgnCreate();\n      cl->copyDX = 0;\n      cl->copyDY = 0;\n   \n      cl->modifiedRegion =\n\tsraRgnCreateRect(0,0,rfbScreen->width,rfbScreen->height);\n\n      INIT_MUTEX(cl->updateMutex);\n      INIT_COND(cl->updateCond);\n\n      cl->requestedRegion = sraRgnCreate();\n\n      cl->format = cl->screen->serverFormat;\n      cl->translateFn = rfbTranslateNone;\n      cl->translateLookupTable = NULL;\n\n      LOCK(rfbClientListMutex);\n\n      IF_PTHREADS(cl->refCount = 0);\n      cl->next = rfbScreen->clientHead;\n      cl->prev = NULL;\n      if (rfbScreen->clientHead)\n        rfbScreen->clientHead->prev = cl;\n\n      rfbScreen->clientHead = cl;\n      UNLOCK(rfbClientListMutex);\n\n#if defined(LIBVNCSERVER_HAVE_LIBZ) || defined(LIBVNCSERVER_HAVE_LIBPNG)\n      cl->tightQualityLevel = -1;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n      cl->tightCompressLevel = TIGHT_DEFAULT_COMPRESSION;\n      cl->turboSubsampLevel = TURBO_DEFAULT_SUBSAMP;\n      {\n\tint i;\n\tfor (i = 0; i < 4; i++)\n          cl->zsActive[i] = FALSE;\n      }\n#endif\n#endif\n\n      cl->fileTransfer.fd = -1;\n\n      cl->enableCursorShapeUpdates = FALSE;\n      cl->enableCursorPosUpdates = FALSE;\n      cl->useRichCursorEncoding = FALSE;\n      cl->enableLastRectEncoding = FALSE;\n      cl->enableKeyboardLedState = FALSE;\n      cl->enableSupportedMessages = FALSE;\n      cl->enableSupportedEncodings = FALSE;\n      cl->enableServerIdentity = FALSE;\n      cl->lastKeyboardLedState = -1;\n      cl->cursorX = rfbScreen->cursorX;\n      cl->cursorY = rfbScreen->cursorY;\n      cl->useNewFBSize = FALSE;\n      cl->useExtDesktopSize = FALSE;\n      cl->requestedDesktopSizeChange = 0;\n      cl->lastDesktopSizeChangeError = 0;\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n      cl->compStreamInited = FALSE;\n      cl->compStream.total_in = 0;\n      cl->compStream.total_out = 0;\n      cl->compStream.zalloc = Z_NULL;\n      cl->compStream.zfree = Z_NULL;\n      cl->compStream.opaque = Z_NULL;\n\n      cl->zlibCompressLevel = 5;\n#endif\n\n      cl->progressiveSliceY = 0;\n\n      cl->extensions = NULL;\n\n      cl->lastPtrX = -1;\n\n#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD\n      cl->pipe_notify_client_thread[0] = -1;\n      cl->pipe_notify_client_thread[1] = -1;\n#endif\n\n#ifdef LIBVNCSERVER_WITH_WEBSOCKETS\n      /*\n       * Wait a few ms for the client to send WebSockets connection (TLS/SSL or plain)\n       */\n      if (!webSocketsCheck(cl)) {\n        /* Error reporting handled in webSocketsHandshake */\n        rfbCloseClient(cl);\n        rfbClientConnectionGone(cl);\n        return NULL;\n      }\n#endif\n\n      sprintf(pv,rfbProtocolVersionFormat,rfbScreen->protocolMajorVersion, \n              rfbScreen->protocolMinorVersion);\n\n      if (rfbWriteExact(cl, pv, sz_rfbProtocolVersionMsg) < 0) {\n        rfbLogPerror(\"rfbNewClient: write\");\n        rfbCloseClient(cl);\n\trfbClientConnectionGone(cl);\n        return NULL;\n      }\n    }\n\n    for(extension = rfbGetExtensionIterator(); extension;\n\t    extension=extension->next) {\n\tvoid* data = NULL;\n\t/* if the extension does not have a newClient method, it wants\n\t * to be initialized later. */\n\tif(extension->newClient && extension->newClient(cl, &data))\n\t\trfbEnableExtension(cl, extension, data);\n    }\n    rfbReleaseExtensionIterator();\n\n    switch (cl->screen->newClientHook(cl)) {\n    case RFB_CLIENT_ON_HOLD:\n\t    cl->onHold = TRUE;\n\t    break;\n    case RFB_CLIENT_ACCEPT:\n\t    cl->onHold = FALSE;\n\t    break;\n    case RFB_CLIENT_REFUSE:\n\t    rfbCloseClient(cl);\n\t    rfbClientConnectionGone(cl);\n\t    cl = NULL;\n\t    break;\n    }\n    return cl;\n}\n\nrfbClientPtr\nrfbNewClient(rfbScreenInfoPtr rfbScreen,\n             int sock)\n{\n  return(rfbNewTCPOrUDPClient(rfbScreen,sock,FALSE));\n}\n\nrfbClientPtr\nrfbNewUDPClient(rfbScreenInfoPtr rfbScreen)\n{\n  return((rfbScreen->udpClient=\n\t  rfbNewTCPOrUDPClient(rfbScreen,rfbScreen->udpSock,TRUE)));\n}\n\n/*\n * rfbClientConnectionGone is called from sockets.c just after a connection\n * has gone away.\n */\n\nvoid\nrfbClientConnectionGone(rfbClientPtr cl)\n{\n#if defined(LIBVNCSERVER_HAVE_LIBZ) && defined(LIBVNCSERVER_HAVE_LIBJPEG)\n    int i;\n#endif\n\n    LOCK(rfbClientListMutex);\n\n    if (cl->prev)\n        cl->prev->next = cl->next;\n    else\n        cl->screen->clientHead = cl->next;\n    if (cl->next)\n        cl->next->prev = cl->prev;\n\n    UNLOCK(rfbClientListMutex);\n\n#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD\n    if(cl->screen->backgroundLoop != FALSE) {\n      int i;\n      do {\n\tLOCK(cl->refCountMutex);\n\ti=cl->refCount;\n\tif(i>0)\n\t  WAIT(cl->deleteCond,cl->refCountMutex);\n\tUNLOCK(cl->refCountMutex);\n      } while(i>0);\n    }\n#endif\n\n    if(cl->sock>=0)\n\tclose(cl->sock);\n\n    if (cl->scaledScreen!=NULL)\n        cl->scaledScreen->scaledScreenRefCount--;\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n    rfbFreeZrleData(cl);\n#endif\n\n    rfbFreeUltraData(cl);\n\n    /* free buffers holding pixel data before and after encoding */\n    free(cl->beforeEncBuf);\n    free(cl->afterEncBuf);\n\n    if(cl->sock>=0)\n       FD_CLR(cl->sock,&(cl->screen->allFds));\n\n    cl->clientGoneHook(cl);\n\n    rfbLog(\"Client %s gone\\n\",cl->host);\n    free(cl->host);\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n    /* Release the compression state structures if any. */\n    if ( cl->compStreamInited ) {\n\tdeflateEnd( &(cl->compStream) );\n    }\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n    for (i = 0; i < 4; i++) {\n\tif (cl->zsActive[i])\n\t    deflateEnd(&cl->zsStruct[i]);\n    }\n#endif\n#endif\n\n    if (cl->screen->pointerClient == cl)\n        cl->screen->pointerClient = NULL;\n\n    sraRgnDestroy(cl->modifiedRegion);\n    sraRgnDestroy(cl->requestedRegion);\n    sraRgnDestroy(cl->copyRegion);\n\n    if (cl->translateLookupTable) free(cl->translateLookupTable);\n\n    TINI_COND(cl->updateCond);\n    TINI_MUTEX(cl->updateMutex);\n\n    /* make sure outputMutex is unlocked before destroying */\n    LOCK(cl->outputMutex);\n    UNLOCK(cl->outputMutex);\n    TINI_MUTEX(cl->outputMutex);\n\n    LOCK(cl->sendMutex);\n    UNLOCK(cl->sendMutex);\n    TINI_MUTEX(cl->sendMutex);\n\n#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD\n    close(cl->pipe_notify_client_thread[0]);\n    close(cl->pipe_notify_client_thread[1]);\n#endif\n\n    rfbPrintStats(cl);\n    rfbResetStats(cl);\n\n    free(cl);\n}\n\n\n/*\n * rfbProcessClientMessage is called when there is data to read from a client.\n */\n\nvoid\nrfbProcessClientMessage(rfbClientPtr cl)\n{\n    switch (cl->state) {\n    case RFB_PROTOCOL_VERSION:\n        rfbProcessClientProtocolVersion(cl);\n        return;\n    case RFB_SECURITY_TYPE:\n        rfbProcessClientSecurityType(cl);\n        return;\n    case RFB_AUTHENTICATION:\n        rfbAuthProcessClientMessage(cl);\n        return;\n    case RFB_INITIALISATION:\n    case RFB_INITIALISATION_SHARED:\n        rfbProcessClientInitMessage(cl);\n        return;\n    default:\n        rfbProcessClientNormalMessage(cl);\n        return;\n    }\n}\n\n\n/*\n * rfbProcessClientProtocolVersion is called when the client sends its\n * protocol version.\n */\n\nstatic void\nrfbProcessClientProtocolVersion(rfbClientPtr cl)\n{\n    rfbProtocolVersionMsg pv;\n    int n, major_, minor_;\n\n    if ((n = rfbReadExact(cl, pv, sz_rfbProtocolVersionMsg)) <= 0) {\n        if (n == 0)\n            rfbLog(\"rfbProcessClientProtocolVersion: client gone\\n\");\n        else\n            rfbLogPerror(\"rfbProcessClientProtocolVersion: read\");\n        rfbCloseClient(cl);\n        return;\n    }\n\n    pv[sz_rfbProtocolVersionMsg] = 0;\n    if (sscanf(pv,rfbProtocolVersionFormat,&major_,&minor_) != 2) {\n\trfbErr(\"rfbProcessClientProtocolVersion: not a valid RFB client: %s\\n\", pv);\n\trfbCloseClient(cl);\n\treturn;\n    }\n    rfbLog(\"Client Protocol Version %d.%d\\n\", major_, minor_);\n\n    if (major_ != rfbProtocolMajorVersion) {\n        rfbErr(\"RFB protocol version mismatch - server %d.%d, client %d.%d\",\n                cl->screen->protocolMajorVersion, cl->screen->protocolMinorVersion,\n                major_,minor_);\n        rfbCloseClient(cl);\n        return;\n    }\n\n    /* Check for the minor version use either of the two standard version of RFB */\n    /*\n     * UltraVNC Viewer detects FileTransfer compatible servers via rfb versions\n     * 3.4, 3.6, 3.14, 3.16\n     * It's a bad method, but it is what they use to enable features...\n     * maintaining RFB version compatibility across multiple servers is a pain\n     * Should use something like ServerIdentity encoding\n     */\n    cl->protocolMajorVersion = major_;\n    cl->protocolMinorVersion = minor_;\n    \n    rfbLog(\"Protocol version sent %d.%d, using %d.%d\\n\",\n              major_, minor_, rfbProtocolMajorVersion, cl->protocolMinorVersion);\n\n    rfbAuthNewClient(cl);\n}\n\n\nvoid\nrfbClientSendString(rfbClientPtr cl, const char *reason)\n{\n    char *buf;\n    int len = strlen(reason);\n\n    rfbLog(\"rfbClientSendString(\\\"%s\\\")\\n\", reason);\n\n    buf = (char *)malloc(4 + len);\n    ((uint32_t *)buf)[0] = Swap32IfLE(len);\n    memcpy(buf + 4, reason, len);\n\n    if (rfbWriteExact(cl, buf, 4 + len) < 0)\n        rfbLogPerror(\"rfbClientSendString: write\");\n    free(buf);\n\n    rfbCloseClient(cl);\n}\n\n/*\n * rfbClientConnFailed is called when a client connection has failed either\n * because it talks the wrong protocol or it has failed authentication.\n */\n\nvoid\nrfbClientConnFailed(rfbClientPtr cl,\n                    const char *reason)\n{\n    char *buf;\n    int len = strlen(reason);\n\n    rfbLog(\"rfbClientConnFailed(\\\"%s\\\")\\n\", reason);\n\n    buf = (char *)malloc(8 + len);\n    ((uint32_t *)buf)[0] = Swap32IfLE(rfbConnFailed);\n    ((uint32_t *)buf)[1] = Swap32IfLE(len);\n    memcpy(buf + 8, reason, len);\n\n    if (rfbWriteExact(cl, buf, 8 + len) < 0)\n        rfbLogPerror(\"rfbClientConnFailed: write\");\n    free(buf);\n\n    rfbCloseClient(cl);\n}\n\n\n/*\n * rfbProcessClientInitMessage is called when the client sends its\n * initialisation message.\n */\n\nstatic void\nrfbProcessClientInitMessage(rfbClientPtr cl)\n{\n    rfbClientInitMsg ci;\n    union {\n        char buf[256];\n        rfbServerInitMsg si;\n    } u;\n    int len, n;\n    rfbClientIteratorPtr iterator;\n    rfbClientPtr otherCl;\n    rfbExtensionData* extension;\n\n    if (cl->state == RFB_INITIALISATION_SHARED) {\n        /* In this case behave as though an implicit ClientInit message has\n         * already been received with a shared-flag of true. */\n        ci.shared = 1;\n        /* Avoid the possibility of exposing the RFB_INITIALISATION_SHARED\n         * state to calling software. */\n        cl->state = RFB_INITIALISATION;\n    } else {\n        if ((n = rfbReadExact(cl, (char *)&ci,sz_rfbClientInitMsg)) <= 0) {\n            if (n == 0)\n                rfbLog(\"rfbProcessClientInitMessage: client gone\\n\");\n            else\n                rfbLogPerror(\"rfbProcessClientInitMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n    }\n\n    memset(u.buf,0,sizeof(u.buf));\n\n    u.si.framebufferWidth = Swap16IfLE(cl->screen->width);\n    u.si.framebufferHeight = Swap16IfLE(cl->screen->height);\n    u.si.format = cl->screen->serverFormat;\n    u.si.format.redMax = Swap16IfLE(u.si.format.redMax);\n    u.si.format.greenMax = Swap16IfLE(u.si.format.greenMax);\n    u.si.format.blueMax = Swap16IfLE(u.si.format.blueMax);\n\n    strncpy(u.buf + sz_rfbServerInitMsg, cl->screen->desktopName, 127);\n    len = strlen(u.buf + sz_rfbServerInitMsg);\n    u.si.nameLength = Swap32IfLE(len);\n\n    if (rfbWriteExact(cl, u.buf, sz_rfbServerInitMsg + len) < 0) {\n        rfbLogPerror(\"rfbProcessClientInitMessage: write\");\n        rfbCloseClient(cl);\n        return;\n    }\n\n    for(extension = cl->extensions; extension;) {\n\trfbExtensionData* next = extension->next;\n\tif(extension->extension->init &&\n\t\t!extension->extension->init(cl, extension->data))\n\t    /* extension requested that it be removed */\n\t    rfbDisableExtension(cl, extension->extension);\n\textension = next;\n    }\n\n    cl->state = RFB_NORMAL;\n\n    if (!cl->reverseConnection &&\n                        (cl->screen->neverShared || (!cl->screen->alwaysShared && !ci.shared))) {\n\n        if (cl->screen->dontDisconnect) {\n            iterator = rfbGetClientIterator(cl->screen);\n            while ((otherCl = rfbClientIteratorNext(iterator)) != NULL) {\n                if ((otherCl != cl) && (otherCl->state == RFB_NORMAL)) {\n                    rfbLog(\"-dontdisconnect: Not shared & existing client\\n\");\n                    rfbLog(\"  refusing new client %s\\n\", cl->host);\n                    rfbCloseClient(cl);\n                    rfbReleaseClientIterator(iterator);\n                    return;\n                }\n            }\n            rfbReleaseClientIterator(iterator);\n        } else {\n            iterator = rfbGetClientIterator(cl->screen);\n            while ((otherCl = rfbClientIteratorNext(iterator)) != NULL) {\n                if ((otherCl != cl) && (otherCl->state == RFB_NORMAL)) {\n                    rfbLog(\"Not shared - closing connection to client %s\\n\",\n                           otherCl->host);\n                    rfbCloseClient(otherCl);\n                }\n            }\n            rfbReleaseClientIterator(iterator);\n        }\n    }\n}\n\n/* The values come in based on the scaled screen, we need to convert them to\n * values based on the man screen's coordinate system\n */\nstatic rfbBool rectSwapIfLEAndClip(uint16_t* x,uint16_t* y,uint16_t* w,uint16_t* h,\n\t\trfbClientPtr cl)\n{\n\tint x1=Swap16IfLE(*x);\n\tint y1=Swap16IfLE(*y);\n\tint w1=Swap16IfLE(*w);\n\tint h1=Swap16IfLE(*h);\n\n\trfbScaledCorrection(cl->scaledScreen, cl->screen, &x1, &y1, &w1, &h1, \"rectSwapIfLEAndClip\");\n\t*x = x1;\n\t*y = y1;\n\t*w = w1;\n\t*h = h1;\n\n\tif(*w>cl->screen->width-*x)\n\t\t*w=cl->screen->width-*x;\n\t/* possible underflow */\n\tif(*w>cl->screen->width-*x)\n\t\treturn FALSE;\n\tif(*h>cl->screen->height-*y)\n\t\t*h=cl->screen->height-*y;\n\tif(*h>cl->screen->height-*y)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\n/*\n * Send keyboard state (PointerPos pseudo-encoding).\n */\n\nrfbBool\nrfbSendKeyboardLedState(rfbClientPtr cl)\n{\n    rfbFramebufferUpdateRectHeader rect;\n\n    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader > UPDATE_BUF_SIZE) {\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n    }\n\n    rect.encoding = Swap32IfLE(rfbEncodingKeyboardLedState);\n    rect.r.x = Swap16IfLE(cl->lastKeyboardLedState);\n    rect.r.y = 0;\n    rect.r.w = 0;\n    rect.r.h = 0;\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,\n        sz_rfbFramebufferUpdateRectHeader);\n    cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n    rfbStatRecordEncodingSent(cl, rfbEncodingKeyboardLedState, sz_rfbFramebufferUpdateRectHeader, sz_rfbFramebufferUpdateRectHeader);\n\n    if (!rfbSendUpdateBuf(cl))\n        return FALSE;\n\n    return TRUE;\n}\n\n\n#define rfbSetBit(buffer, position)  (buffer[(position & 255) / 8] |= (1 << (position % 8)))\n\n/*\n * Send rfbEncodingSupportedMessages.\n */\n\nrfbBool\nrfbSendSupportedMessages(rfbClientPtr cl)\n{\n    rfbFramebufferUpdateRectHeader rect;\n    rfbSupportedMessages msgs;\n\n    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader\n                  + sz_rfbSupportedMessages > UPDATE_BUF_SIZE) {\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n    }\n\n    rect.encoding = Swap32IfLE(rfbEncodingSupportedMessages);\n    rect.r.x = 0;\n    rect.r.y = 0;\n    rect.r.w = Swap16IfLE(sz_rfbSupportedMessages);\n    rect.r.h = 0;\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,\n        sz_rfbFramebufferUpdateRectHeader);\n    cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n    memset((char *)&msgs, 0, sz_rfbSupportedMessages);\n    rfbSetBit(msgs.client2server, rfbSetPixelFormat);\n    rfbSetBit(msgs.client2server, rfbFixColourMapEntries);\n    rfbSetBit(msgs.client2server, rfbSetEncodings);\n    rfbSetBit(msgs.client2server, rfbFramebufferUpdateRequest);\n    rfbSetBit(msgs.client2server, rfbKeyEvent);\n    rfbSetBit(msgs.client2server, rfbPointerEvent);\n    rfbSetBit(msgs.client2server, rfbClientCutText);\n    rfbSetBit(msgs.client2server, rfbFileTransfer);\n    rfbSetBit(msgs.client2server, rfbSetScale);\n    /*rfbSetBit(msgs.client2server, rfbSetServerInput);  */\n    /*rfbSetBit(msgs.client2server, rfbSetSW);           */\n    /*rfbSetBit(msgs.client2server, rfbTextChat);        */\n    rfbSetBit(msgs.client2server, rfbPalmVNCSetScaleFactor);\n\n    rfbSetBit(msgs.server2client, rfbFramebufferUpdate);\n    rfbSetBit(msgs.server2client, rfbSetColourMapEntries);\n    rfbSetBit(msgs.server2client, rfbBell);\n    rfbSetBit(msgs.server2client, rfbServerCutText);\n    rfbSetBit(msgs.server2client, rfbResizeFrameBuffer);\n    rfbSetBit(msgs.server2client, rfbPalmVNCReSizeFrameBuffer);\n    rfbSetBit(msgs.client2server, rfbSetDesktopSize);\n\n    if (cl->screen->xvpHook) {\n        rfbSetBit(msgs.client2server, rfbXvp);\n        rfbSetBit(msgs.server2client, rfbXvp);\n    }\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&msgs, sz_rfbSupportedMessages);\n    cl->ublen += sz_rfbSupportedMessages;\n\n    rfbStatRecordEncodingSent(cl, rfbEncodingSupportedMessages,\n        sz_rfbFramebufferUpdateRectHeader+sz_rfbSupportedMessages,\n        sz_rfbFramebufferUpdateRectHeader+sz_rfbSupportedMessages);\n    if (!rfbSendUpdateBuf(cl))\n        return FALSE;\n\n    return TRUE;\n}\n\n\n\n/*\n * Send rfbEncodingSupportedEncodings.\n */\n\nrfbBool\nrfbSendSupportedEncodings(rfbClientPtr cl)\n{\n    rfbFramebufferUpdateRectHeader rect;\n    static uint32_t supported[] = {\n        rfbEncodingRaw,\n\trfbEncodingCopyRect,\n\trfbEncodingRRE,\n\trfbEncodingCoRRE,\n\trfbEncodingHextile,\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\trfbEncodingZlib,\n\trfbEncodingZRLE,\n\trfbEncodingZYWRLE,\n#endif\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\trfbEncodingTight,\n#endif\n#ifdef LIBVNCSERVER_HAVE_LIBPNG\n\trfbEncodingTightPng,\n#endif\n\trfbEncodingUltra,\n\trfbEncodingUltraZip,\n\trfbEncodingXCursor,\n\trfbEncodingRichCursor,\n\trfbEncodingPointerPos,\n\trfbEncodingLastRect,\n\trfbEncodingNewFBSize,\n\trfbEncodingExtDesktopSize,\n\trfbEncodingKeyboardLedState,\n\trfbEncodingSupportedMessages,\n\trfbEncodingSupportedEncodings,\n\trfbEncodingServerIdentity,\n    };\n    uint32_t nEncodings = sizeof(supported) / sizeof(supported[0]), i;\n\n    /* think rfbSetEncodingsMsg */\n\n    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader\n                  + (nEncodings * sizeof(uint32_t)) > UPDATE_BUF_SIZE) {\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n    }\n\n    rect.encoding = Swap32IfLE(rfbEncodingSupportedEncodings);\n    rect.r.x = 0;\n    rect.r.y = 0;\n    rect.r.w = Swap16IfLE(nEncodings * sizeof(uint32_t));\n    rect.r.h = Swap16IfLE(nEncodings);\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,\n        sz_rfbFramebufferUpdateRectHeader);\n    cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n    for (i = 0; i < nEncodings; i++) {\n        uint32_t encoding = Swap32IfLE(supported[i]);\n\tmemcpy(&cl->updateBuf[cl->ublen], (char *)&encoding, sizeof(encoding));\n\tcl->ublen += sizeof(encoding);\n    }\n\n    rfbStatRecordEncodingSent(cl, rfbEncodingSupportedEncodings,\n        sz_rfbFramebufferUpdateRectHeader+(nEncodings * sizeof(uint32_t)),\n        sz_rfbFramebufferUpdateRectHeader+(nEncodings * sizeof(uint32_t)));\n\n    if (!rfbSendUpdateBuf(cl))\n        return FALSE;\n\n    return TRUE;\n}\n\n\nvoid\nrfbSetServerVersionIdentity(rfbScreenInfoPtr screen, char *fmt, ...)\n{\n    char buffer[256];\n    va_list ap;\n    \n    va_start(ap, fmt);\n    vsnprintf(buffer, sizeof(buffer)-1, fmt, ap);\n    va_end(ap);\n    \n    if (screen->versionString!=NULL) free(screen->versionString);\n    screen->versionString = strdup(buffer);\n}\n\n/*\n * Send rfbEncodingServerIdentity.\n */\n\nrfbBool\nrfbSendServerIdentity(rfbClientPtr cl)\n{\n    rfbFramebufferUpdateRectHeader rect;\n    char buffer[512];\n\n    /* tack on our library version */\n    snprintf(buffer,sizeof(buffer)-1, \"%s (%s)\", \n        (cl->screen->versionString==NULL ? \"unknown\" : cl->screen->versionString),\n        LIBVNCSERVER_PACKAGE_STRING);\n\n    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader\n                  + (strlen(buffer)+1) > UPDATE_BUF_SIZE) {\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n    }\n\n    rect.encoding = Swap32IfLE(rfbEncodingServerIdentity);\n    rect.r.x = 0;\n    rect.r.y = 0;\n    rect.r.w = Swap16IfLE(strlen(buffer)+1);\n    rect.r.h = 0;\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,\n        sz_rfbFramebufferUpdateRectHeader);\n    cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n    memcpy(&cl->updateBuf[cl->ublen], buffer, strlen(buffer)+1);\n    cl->ublen += strlen(buffer)+1;\n\n    rfbStatRecordEncodingSent(cl, rfbEncodingServerIdentity,\n        sz_rfbFramebufferUpdateRectHeader+strlen(buffer)+1,\n        sz_rfbFramebufferUpdateRectHeader+strlen(buffer)+1);\n    \n\n    if (!rfbSendUpdateBuf(cl))\n        return FALSE;\n\n    return TRUE;\n}\n\n/*\n * Send an xvp server message\n */\n\nrfbBool\nrfbSendXvp(rfbClientPtr cl, uint8_t version, uint8_t code)\n{\n    rfbXvpMsg xvp;\n\n    xvp.type = rfbXvp;\n    xvp.pad = 0;\n    xvp.version = version;\n    xvp.code = code;\n\n    LOCK(cl->sendMutex);\n    if (rfbWriteExact(cl, (char *)&xvp, sz_rfbXvpMsg) < 0) {\n      rfbLogPerror(\"rfbSendXvp: write\");\n      rfbCloseClient(cl);\n    }\n    UNLOCK(cl->sendMutex);\n\n    rfbStatRecordMessageSent(cl, rfbXvp, sz_rfbXvpMsg, sz_rfbXvpMsg);\n\n    return TRUE;\n}\n\n\nrfbBool rfbSendTextChatMessage(rfbClientPtr cl, uint32_t length, char *buffer)\n{\n    rfbTextChatMsg tc;\n    int bytesToSend=0;\n\n    memset((char *)&tc, 0, sizeof(tc)); \n    tc.type = rfbTextChat;\n    tc.length = Swap32IfLE(length);\n    \n    switch(length) {\n    case rfbTextChatOpen:\n    case rfbTextChatClose:\n    case rfbTextChatFinished:\n        bytesToSend=0;\n        break;\n    default:\n        bytesToSend=length;\n        if (bytesToSend>rfbTextMaxSize)\n            bytesToSend=rfbTextMaxSize;\n    }\n\n    if (cl->ublen + sz_rfbTextChatMsg + bytesToSend > UPDATE_BUF_SIZE) {\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n    }\n    \n    memcpy(&cl->updateBuf[cl->ublen], (char *)&tc, sz_rfbTextChatMsg);\n    cl->ublen += sz_rfbTextChatMsg;\n    if (bytesToSend>0) {\n        memcpy(&cl->updateBuf[cl->ublen], buffer, bytesToSend);\n        cl->ublen += bytesToSend;    \n    }\n    rfbStatRecordMessageSent(cl, rfbTextChat, sz_rfbTextChatMsg+bytesToSend, sz_rfbTextChatMsg+bytesToSend);\n\n    if (!rfbSendUpdateBuf(cl))\n        return FALSE;\n        \n    return TRUE;\n}\n\n#define FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(msg, cl, ret) \\\n\tif ((cl->screen->getFileTransferPermission != NULL \\\n\t    && cl->screen->getFileTransferPermission(cl) != TRUE) \\\n\t    || cl->screen->permitFileTransfer != TRUE) { \\\n\t\trfbLog(\"%sUltra File Transfer is disabled, dropping client: %s\\n\", msg, cl->host); \\\n\t\trfbCloseClient(cl); \\\n\t\treturn ret; \\\n\t}\n\nint DB = 1;\n\nrfbBool rfbSendFileTransferMessage(rfbClientPtr cl, uint8_t contentType, uint8_t contentParam, uint32_t size, uint32_t length, const char *buffer)\n{\n    rfbFileTransferMsg ft;\n    ft.type = rfbFileTransfer;\n    ft.contentType = contentType;\n    ft.contentParam = contentParam;\n    ft.pad          = 0; /* UltraVNC did not Swap16LE(ft.contentParam) (Looks like it might be BigEndian) */\n    ft.size         = Swap32IfLE(size);\n    ft.length       = Swap32IfLE(length);\n    \n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, FALSE);\n    /*\n    rfbLog(\"rfbSendFileTransferMessage( %dtype, %dparam, %dsize, %dlen, %p)\\n\", contentType, contentParam, size, length, buffer);\n    */\n    LOCK(cl->sendMutex);\n    if (rfbWriteExact(cl, (char *)&ft, sz_rfbFileTransferMsg) < 0) {\n        rfbLogPerror(\"rfbSendFileTransferMessage: write\");\n        rfbCloseClient(cl);\n        UNLOCK(cl->sendMutex);\n        return FALSE;\n    }\n\n    if (length>0)\n    {\n        if (rfbWriteExact(cl, buffer, length) < 0) {\n            rfbLogPerror(\"rfbSendFileTransferMessage: write\");\n            rfbCloseClient(cl);\n            UNLOCK(cl->sendMutex);\n            return FALSE;\n        }\n    }\n    UNLOCK(cl->sendMutex);\n\n    rfbStatRecordMessageSent(cl, rfbFileTransfer, sz_rfbFileTransferMsg+length, sz_rfbFileTransferMsg+length);\n\n    return TRUE;\n}\n\n\n/*\n * UltraVNC uses Windows Structures\n */\n#define MAX_PATH 260\n\ntypedef struct {\n    uint32_t dwLowDateTime;\n    uint32_t dwHighDateTime;\n} RFB_FILETIME; \n\ntypedef struct {\n    uint32_t dwFileAttributes;\n    RFB_FILETIME ftCreationTime;\n    RFB_FILETIME ftLastAccessTime;\n    RFB_FILETIME ftLastWriteTime;\n    uint32_t nFileSizeHigh;\n    uint32_t nFileSizeLow;\n    uint32_t dwReserved0;\n    uint32_t dwReserved1;\n    uint8_t  cFileName[ MAX_PATH ];\n    uint8_t  cAlternateFileName[ 14 ];\n} RFB_FIND_DATA;\n\n#define RFB_FILE_ATTRIBUTE_READONLY   0x1\n#define RFB_FILE_ATTRIBUTE_HIDDEN     0x2\n#define RFB_FILE_ATTRIBUTE_SYSTEM     0x4\n#define RFB_FILE_ATTRIBUTE_DIRECTORY  0x10\n#define RFB_FILE_ATTRIBUTE_ARCHIVE    0x20\n#define RFB_FILE_ATTRIBUTE_NORMAL     0x80\n#define RFB_FILE_ATTRIBUTE_TEMPORARY  0x100\n#define RFB_FILE_ATTRIBUTE_COMPRESSED 0x800\n\nrfbBool rfbFilenameTranslate2UNIX(rfbClientPtr cl, /* in */ char *path, /* out */ char *unixPath, size_t unixPathMaxLen)\n{\n    int x;\n    char *home=NULL;\n\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, FALSE);\n\n    /*\n     * Do not use strncpy() - truncating the file name would probably have undesirable side effects\n     * Instead check if destination buffer is big enough\n     */\n    if (strlen(path) >= unixPathMaxLen)\n      return FALSE;\n\n    /* C: */\n    if (path[0]=='C' && path[1]==':')\n      strcpy(unixPath, &path[2]);\n    else\n    {\n      home = getenv(\"HOME\");\n      if (home!=NULL)\n      {\n        /* Re-check buffer size */\n        if ((strlen(path) + strlen(home) + 1) >= unixPathMaxLen)\n          return FALSE;\n\n        strcpy(unixPath, home);\n        strcat(unixPath,\"/\");\n        strcat(unixPath, path);\n      }\n      else\n        strcpy(unixPath, path);\n    }\n    for (x=0;x<strlen(unixPath);x++)\n      if (unixPath[x]=='\\\\') unixPath[x]='/';\n    return TRUE;\n}\n\nrfbBool rfbFilenameTranslate2DOS(rfbClientPtr cl, char *unixPath, char *path)\n{\n    int x;\n\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, FALSE);\n\n    sprintf(path,\"C:%s\", unixPath);\n    for (x=2;x<strlen(path);x++)\n        if (path[x]=='/') path[x]='\\\\';\n    return TRUE;\n}\n\nrfbBool rfbSendDirContent(rfbClientPtr cl, int length, char *buffer)\n{\n    char retfilename[MAX_PATH];\n    char path[MAX_PATH];\n    struct stat statbuf;\n    RFB_FIND_DATA win32filename;\n    int nOptLen = 0, retval=0;\n#ifdef WIN32\n    WIN32_FIND_DATAA winFindData;\n    HANDLE findHandle;\n    int pathLen, basePathLength;\n    char *basePath;\n#else\n    DIR *dirp=NULL;\n    struct dirent *direntp=NULL;\n#endif\n\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, FALSE);\n\n    /* Client thinks we are Winblows */\n    if (!rfbFilenameTranslate2UNIX(cl, buffer, path, sizeof(path)))\n        return FALSE;\n\n    if (DB) rfbLog(\"rfbProcessFileTransfer() rfbDirContentRequest: rfbRDirContent: \\\"%s\\\"->\\\"%s\\\"\\n\",buffer, path);\n\n#ifdef WIN32\n    // Create a search string, like C:\\folder\\*\n\n    pathLen = strlen(path);\n    basePath = malloc(pathLen + 3);\n    memcpy(basePath, path, pathLen);\n    basePathLength = pathLen;\n    basePath[basePathLength] = '\\\\';\n    basePath[basePathLength + 1] = '*';\n    basePath[basePathLength + 2] = '\\0';\n\n    // Start a search\n    memset(&winFindData, 0, sizeof(winFindData));\n    findHandle = FindFirstFileA(path, &winFindData);\n    free(basePath);\n\n    if (findHandle == INVALID_HANDLE_VALUE)\n#else\n    dirp=opendir(path);\n    if (dirp==NULL)\n#endif\n        return rfbSendFileTransferMessage(cl, rfbDirPacket, rfbADirectory, 0, 0, NULL);\n\n    /* send back the path name (necessary for links) */\n    if (rfbSendFileTransferMessage(cl, rfbDirPacket, rfbADirectory, 0, length, buffer)==FALSE) return FALSE;\n\n#ifdef WIN32\n    while (findHandle != INVALID_HANDLE_VALUE)\n#else\n    for (direntp=readdir(dirp); direntp!=NULL; direntp=readdir(dirp))\n#endif\n    {\n        /* get stats */\n#ifdef WIN32\n    snprintf(retfilename,sizeof(retfilename),\"%s/%s\", path, winFindData.cFileName);\n#else\n    snprintf(retfilename,sizeof(retfilename),\"%s/%s\", path, direntp->d_name);\n#endif\n        retval = stat(retfilename, &statbuf);\n\n        if (retval==0)\n        {\n            memset((char *)&win32filename, 0, sizeof(win32filename));\n#ifdef WIN32\n            win32filename.dwFileAttributes = winFindData.dwFileAttributes;\n            win32filename.ftCreationTime.dwLowDateTime = winFindData.ftCreationTime.dwLowDateTime;\n            win32filename.ftCreationTime.dwHighDateTime = winFindData.ftCreationTime.dwHighDateTime;\n            win32filename.ftLastAccessTime.dwLowDateTime = winFindData.ftLastAccessTime.dwLowDateTime;\n            win32filename.ftLastAccessTime.dwHighDateTime = winFindData.ftLastAccessTime.dwHighDateTime;\n            win32filename.ftLastWriteTime.dwLowDateTime = winFindData.ftLastWriteTime.dwLowDateTime;\n            win32filename.ftLastWriteTime.dwHighDateTime = winFindData.ftLastWriteTime.dwHighDateTime;\n            win32filename.nFileSizeLow = winFindData.nFileSizeLow;\n            win32filename.nFileSizeHigh = winFindData.nFileSizeHigh;\n            win32filename.dwReserved0 = winFindData.dwReserved0;\n            win32filename.dwReserved1 = winFindData.dwReserved1;\n            strcpy((char *)win32filename.cFileName, winFindData.cFileName);\n            strcpy((char *)win32filename.cAlternateFileName, winFindData.cAlternateFileName);\n#else\n            win32filename.dwFileAttributes = Swap32IfBE(RFB_FILE_ATTRIBUTE_NORMAL);\n            if (S_ISDIR(statbuf.st_mode))\n                win32filename.dwFileAttributes = Swap32IfBE(RFB_FILE_ATTRIBUTE_DIRECTORY);\n            win32filename.ftCreationTime.dwLowDateTime = Swap32IfBE(statbuf.st_ctime);   /* Intel Order */\n            win32filename.ftCreationTime.dwHighDateTime = 0;\n            win32filename.ftLastAccessTime.dwLowDateTime = Swap32IfBE(statbuf.st_atime); /* Intel Order */\n            win32filename.ftLastAccessTime.dwHighDateTime = 0;\n            win32filename.ftLastWriteTime.dwLowDateTime = Swap32IfBE(statbuf.st_mtime);  /* Intel Order */\n            win32filename.ftLastWriteTime.dwHighDateTime = 0;\n            win32filename.nFileSizeLow = Swap32IfBE(statbuf.st_size); /* Intel Order */\n            win32filename.nFileSizeHigh = 0;\n            win32filename.dwReserved0 = 0;\n            win32filename.dwReserved1 = 0;\n\n            /* If this had the full path, we would need to translate to DOS format (\"C:\\\") */\n            /* rfbFilenameTranslate2DOS(cl, retfilename, win32filename.cFileName); */\n            strcpy((char *)win32filename.cFileName, direntp->d_name);\n#endif\n            \n            /* Do not show hidden files (but show how to move up the tree) */\n            if ((strcmp((char *)win32filename.cFileName, \"..\")==0) || (win32filename.cFileName[0]!='.'))\n            {\n                nOptLen = sizeof(RFB_FIND_DATA) - MAX_PATH - 14 + strlen((char *)win32filename.cFileName);\n                /*\n                rfbLog(\"rfbProcessFileTransfer() rfbDirContentRequest: rfbRDirContent: Sending \\\"%s\\\"\\n\", (char *)win32filename.cFileName);\n                */\n                if (rfbSendFileTransferMessage(cl, rfbDirPacket, rfbADirectory, 0, nOptLen, (char *)&win32filename)==FALSE)\n                {\n#ifdef WIN32\n                    FindClose(findHandle);\n#else\n                    closedir(dirp);\n#endif\n                    return FALSE;\n                }\n            }\n        }\n\n#ifdef WIN32\n        if (FindNextFileA(findHandle, &winFindData) == 0)\n        {\n            FindClose(findHandle);\n            findHandle = INVALID_HANDLE_VALUE;\n        }\n#endif\n    }\n#ifdef WIN32\n    if (findHandle != INVALID_HANDLE_VALUE)\n    {\n        FindClose(findHandle);\n    }\n#else\n    closedir(dirp);\n#endif\n    /* End of the transfer */\n    return rfbSendFileTransferMessage(cl, rfbDirPacket, 0, 0, 0, NULL);\n}\n\n\nchar *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n{\n    char *buffer=NULL;\n    int   n=0;\n\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, NULL);\n\n    /*\n       We later alloc length+1, which might wrap around on 32-bit systems if length equals\n       0XFFFFFFFF, i.e. SIZE_MAX for 32-bit systems. On 64-bit systems, a length of 0XFFFFFFFF\n       will safely be allocated since this check will never trigger and malloc() can digest length+1\n       without problems as length is a uint32_t.\n       We also later pass length to rfbReadExact() that expects a signed int type and\n       that might wrap on platforms with a 32-bit int type if length is bigger\n       than 0X7FFFFFFF.\n    */\n    if(length == SIZE_MAX || length > INT_MAX) {\n\trfbErr(\"rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u\", (unsigned int)length);\n\trfbCloseClient(cl);\n\treturn NULL;\n    }\n\n    if (length>0) {\n        buffer=malloc((size_t)length+1);\n        if (buffer!=NULL) {\n            if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessFileTransferReadBuffer: read\");\n                rfbCloseClient(cl);\n                /* NOTE: don't forget to free(buffer) if you return early! */\n                if (buffer!=NULL) free(buffer);\n                return NULL;\n            }\n            /* Null Terminate */\n            buffer[length]=0;\n        }\n    }\n    return buffer;\n}\n\n\nrfbBool rfbSendFileTransferChunk(rfbClientPtr cl)\n{\n    /* Allocate buffer for compression */\n    unsigned char readBuf[sz_rfbBlockSize];\n    int bytesRead=0;\n    int retval=0;\n    fd_set wfds;\n    struct timeval tv;\n    int n;\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n    unsigned char compBuf[sz_rfbBlockSize + 1024];\n    unsigned long nMaxCompSize = sizeof(compBuf);\n    int nRetC = 0;\n#endif\n\n    /*\n     * Don't close the client if we get into this one because \n     * it is called from many places to service file transfers.\n     * Note that permitFileTransfer is checked first.\n     */\n    if (cl->screen->permitFileTransfer != TRUE ||\n       (cl->screen->getFileTransferPermission != NULL\n        && cl->screen->getFileTransferPermission(cl) != TRUE)) { \n\t\treturn TRUE;\n    }\n\n    /* If not sending, or no file open...   Return as if we sent something! */\n    if ((cl->fileTransfer.fd!=-1) && (cl->fileTransfer.sending==1))\n    {\n\tFD_ZERO(&wfds);\n        FD_SET(cl->sock, &wfds);\n\n        /* return immediately */\n\ttv.tv_sec = 0; \n\ttv.tv_usec = 0;\n\tn = select(cl->sock + 1, NULL, &wfds, NULL, &tv);\n\n\tif (n<0) {\n#ifdef WIN32\n\t    errno=WSAGetLastError();\n#endif\n            rfbLog(\"rfbSendFileTransferChunk() select failed: %s\\n\", strerror(errno));\n\t}\n        /* We have space on the transmit queue */\n\tif (n > 0)\n\t{\n            bytesRead = read(cl->fileTransfer.fd, readBuf, sz_rfbBlockSize);\n            switch (bytesRead) {\n            case 0:\n                /*\n                rfbLog(\"rfbSendFileTransferChunk(): End-Of-File Encountered\\n\");\n                */\n                retval = rfbSendFileTransferMessage(cl, rfbEndOfFile, 0, 0, 0, NULL);\n                close(cl->fileTransfer.fd);\n                cl->fileTransfer.fd = -1;\n                cl->fileTransfer.sending   = 0;\n                cl->fileTransfer.receiving = 0;\n                return retval;\n            case -1:\n                /* TODO : send an error msg to the client... */\n#ifdef WIN32\n\t        errno=WSAGetLastError();\n#endif\n                rfbLog(\"rfbSendFileTransferChunk(): %s\\n\",strerror(errno));\n                retval = rfbSendFileTransferMessage(cl, rfbAbortFileTransfer, 0, 0, 0, NULL);\n                close(cl->fileTransfer.fd);\n                cl->fileTransfer.fd = -1;\n                cl->fileTransfer.sending   = 0;\n                cl->fileTransfer.receiving = 0;\n                return retval;\n            default:\n                /*\n                rfbLog(\"rfbSendFileTransferChunk(): Read %d bytes\\n\", bytesRead);\n                */\n                if (!cl->fileTransfer.compressionEnabled)\n                    return  rfbSendFileTransferMessage(cl, rfbFilePacket, 0, 0, bytesRead, (char *)readBuf);\n                else\n                {\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n                    nRetC = compress(compBuf, &nMaxCompSize, readBuf, bytesRead);\n                    /*\n                    rfbLog(\"Compressed the packet from %d -> %d bytes\\n\", nMaxCompSize, bytesRead);\n                    */\n                    \n                    if ((nRetC==0) && (nMaxCompSize<bytesRead))\n                        return  rfbSendFileTransferMessage(cl, rfbFilePacket, 0, 1, nMaxCompSize, (char *)compBuf);\n                    else\n                        return  rfbSendFileTransferMessage(cl, rfbFilePacket, 0, 0, bytesRead, (char *)readBuf);\n#else\n                    /* We do not support compression of the data stream */\n                    return  rfbSendFileTransferMessage(cl, rfbFilePacket, 0, 0, bytesRead, (char *)readBuf);\n#endif\n                }\n            }\n        }\n    }\n    return TRUE;\n}\n\nrfbBool rfbProcessFileTransfer(rfbClientPtr cl, uint8_t contentType, uint8_t contentParam, uint32_t size, uint32_t length)\n{\n    char *buffer=NULL, *p=NULL;\n    int retval=0;\n    char filename1[MAX_PATH];\n    char filename2[MAX_PATH];\n    char szFileTime[MAX_PATH];\n    struct stat statbuf;\n    uint32_t sizeHtmp=0;\n    int n=0;\n    char timespec[64];\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n    unsigned char compBuff[sz_rfbBlockSize];\n    unsigned long nRawBytes = sz_rfbBlockSize;\n    int nRet = 0;\n#endif\n\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, FALSE);\n        \n    /*\n    rfbLog(\"rfbProcessFileTransfer(%dtype, %dparam, %dsize, %dlen)\\n\", contentType, contentParam, size, length);\n    */\n\n    switch (contentType) {\n    case rfbDirContentRequest:\n        switch (contentParam) {\n        case rfbRDrivesList: /* Client requests the List of Local Drives */\n            /*\n            rfbLog(\"rfbProcessFileTransfer() rfbDirContentRequest: rfbRDrivesList:\\n\");\n            */\n            /* Format when filled : \"C:\\<NULL>D:\\<NULL>....Z:\\<NULL><NULL>\n             *\n             * We replace the \"\\\" char following the drive letter and \":\"\n             * with a char corresponding to the type of drive\n             * We obtain something like \"C:l<NULL>D:c<NULL>....Z:n\\<NULL><NULL>\"\n             *  Isn't it ugly ?\n             * DRIVE_FIXED = 'l'     (local?)\n             * DRIVE_REMOVABLE = 'f' (floppy?)\n             * DRIVE_CDROM = 'c'\n             * DRIVE_REMOTE = 'n'\n             */\n            \n            /* in unix, there are no 'drives'  (We could list mount points though)\n             * We fake the root as a \"C:\" for the Winblows users\n             */\n            filename2[0]='C';\n            filename2[1]=':';\n            filename2[2]='l';\n            filename2[3]=0;\n            filename2[4]=0;\n            retval = rfbSendFileTransferMessage(cl, rfbDirPacket, rfbADrivesList, 0, 5, filename2);\n            if (buffer!=NULL) free(buffer);\n            return retval;\n            break;\n        case rfbRDirContent: /* Client requests the content of a directory */\n            /*\n            rfbLog(\"rfbProcessFileTransfer() rfbDirContentRequest: rfbRDirContent\\n\");\n            */\n            if ((buffer = rfbProcessFileTransferReadBuffer(cl, length))==NULL) return FALSE;\n            retval = rfbSendDirContent(cl, length, buffer);\n            if (buffer!=NULL) free(buffer);\n            return retval;\n        }\n        break;\n\n    case rfbDirPacket:\n        rfbLog(\"rfbProcessFileTransfer() rfbDirPacket\\n\");\n        break;\n    case rfbFileAcceptHeader:\n        rfbLog(\"rfbProcessFileTransfer() rfbFileAcceptHeader\\n\");\n        break;\n    case rfbCommandReturn:\n        rfbLog(\"rfbProcessFileTransfer() rfbCommandReturn\\n\");\n        break;\n    case rfbFileChecksums:\n        /* Destination file already exists - the viewer sends the checksums */\n        rfbLog(\"rfbProcessFileTransfer() rfbFileChecksums\\n\");\n        break;\n    case rfbFileTransferAccess:\n        rfbLog(\"rfbProcessFileTransfer() rfbFileTransferAccess\\n\");\n        break;\n\n    /*\n     * sending from the server to the viewer\n     */\n\n    case rfbFileTransferRequest:\n        /*\n        rfbLog(\"rfbProcessFileTransfer() rfbFileTransferRequest:\\n\");\n        */\n        /* add some space to the end of the buffer as we will be adding a timespec to it */\n        if ((buffer = rfbProcessFileTransferReadBuffer(cl, length))==NULL) return FALSE;\n        /* The client requests a File */\n        if (!rfbFilenameTranslate2UNIX(cl, buffer, filename1, sizeof(filename1)))\n            goto fail;\n        cl->fileTransfer.fd=open(filename1, O_RDONLY, 0744);\n\n        /*\n        */\n        if (DB) rfbLog(\"rfbProcessFileTransfer() rfbFileTransferRequest(\\\"%s\\\"->\\\"%s\\\") Open: %s fd=%d\\n\", buffer, filename1, (cl->fileTransfer.fd==-1?\"Failed\":\"Success\"), cl->fileTransfer.fd);\n        \n        if (cl->fileTransfer.fd!=-1) {\n            if (fstat(cl->fileTransfer.fd, &statbuf)!=0) {\n                close(cl->fileTransfer.fd);\n                cl->fileTransfer.fd=-1;\n            }\n            else\n            {\n              /* Add the File Time Stamp to the filename */\n              strftime(timespec, sizeof(timespec), \"%m/%d/%Y %H:%M\",gmtime(&statbuf.st_ctime));\n              buffer=realloc(buffer, length + strlen(timespec) + 2); /* comma, and Null term */\n              if (buffer==NULL) {\n                  rfbLog(\"rfbProcessFileTransfer() rfbFileTransferRequest: Failed to malloc %d bytes\\n\", length + strlen(timespec) + 2);\n                  return FALSE;\n              }\n              strcat(buffer,\",\");\n              strcat(buffer, timespec);\n              length = strlen(buffer);\n              if (DB) rfbLog(\"rfbProcessFileTransfer() buffer is now: \\\"%s\\\"\\n\", buffer);\n            }\n        }\n\n        /* The viewer supports compression if size==1 */\n        cl->fileTransfer.compressionEnabled = (size==1);\n\n        /*\n        rfbLog(\"rfbProcessFileTransfer() rfbFileTransferRequest(\\\"%s\\\"->\\\"%s\\\")%s\\n\", buffer, filename1, (size==1?\" <Compression Enabled>\":\"\"));\n        */\n\n        /* File Size in bytes, 0xFFFFFFFF (-1) means error */\n        retval = rfbSendFileTransferMessage(cl, rfbFileHeader, 0, (cl->fileTransfer.fd==-1 ? -1 : statbuf.st_size), length, buffer);\n\n        if (cl->fileTransfer.fd==-1)\n        {\n            if (buffer!=NULL) free(buffer);\n            return retval;\n        }\n        /* setup filetransfer stuff */\n        cl->fileTransfer.fileSize = statbuf.st_size;\n        cl->fileTransfer.numPackets = statbuf.st_size / sz_rfbBlockSize;\n        cl->fileTransfer.receiving = 0;\n        cl->fileTransfer.sending = 0; /* set when we receive a rfbFileHeader: */\n\n        /* TODO: finish 64-bit file size support */\n        sizeHtmp = 0;        \n        LOCK(cl->sendMutex);\n        if (rfbWriteExact(cl, (char *)&sizeHtmp, 4) < 0) {\n          rfbLogPerror(\"rfbProcessFileTransfer: write\");\n          rfbCloseClient(cl);\n          UNLOCK(cl->sendMutex);\n          if (buffer!=NULL) free(buffer);\n          return FALSE;\n        }\n        UNLOCK(cl->sendMutex);\n        break;\n\n    case rfbFileHeader:\n        /* Destination file (viewer side) is ready for reception (size > 0) or not (size = -1) */\n        if (size==-1) {\n            rfbLog(\"rfbProcessFileTransfer() rfbFileHeader (error, aborting)\\n\");\n            close(cl->fileTransfer.fd);\n            cl->fileTransfer.fd=-1;\n            return TRUE;\n        }\n\n        /*\n        rfbLog(\"rfbProcessFileTransfer() rfbFileHeader (%d bytes of a file)\\n\", size);\n        */\n\n        /* Starts the transfer! */\n        cl->fileTransfer.sending=1;\n        return rfbSendFileTransferChunk(cl);\n        break;\n\n\n    /*\n     * sending from the viewer to the server\n     */\n\n    case rfbFileTransferOffer:\n        /* client is sending a file to us */\n        /* buffer contains full path name (plus FileTime) */\n        /* size contains size of the file */\n        /*\n        rfbLog(\"rfbProcessFileTransfer() rfbFileTransferOffer:\\n\");\n        */\n        if ((buffer = rfbProcessFileTransferReadBuffer(cl, length))==NULL) return FALSE;\n\n        /* Parse the FileTime */\n        p = strrchr(buffer, ',');\n        if (p!=NULL) {\n            *p = '\\0';\n            strncpy(szFileTime, p+1, sizeof(szFileTime));\n            szFileTime[sizeof(szFileTime)-1] = '\\x00'; /* ensure NULL terminating byte is present, even if copy overflowed */\n        } else\n            szFileTime[0]=0;\n\n\n\n        /* Need to read in sizeHtmp */\n        if ((n = rfbReadExact(cl, (char *)&sizeHtmp, 4)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessFileTransfer: read sizeHtmp\");\n            rfbCloseClient(cl);\n            /* NOTE: don't forget to free(buffer) if you return early! */\n            if (buffer!=NULL) free(buffer);\n            return FALSE;\n        }\n        sizeHtmp = Swap32IfLE(sizeHtmp);\n        \n        if (!rfbFilenameTranslate2UNIX(cl, buffer, filename1, sizeof(filename1)))\n            goto fail;\n\n        /* If the file exists... We can send a rfbFileChecksums back to the client before we send an rfbFileAcceptHeader */\n        /* TODO: Delta Transfer */\n\n        cl->fileTransfer.fd=open(filename1, O_CREAT|O_WRONLY|O_TRUNC, 0744);\n        if (DB) rfbLog(\"rfbProcessFileTransfer() rfbFileTransferOffer(\\\"%s\\\"->\\\"%s\\\") %s %s fd=%d\\n\", buffer, filename1, (cl->fileTransfer.fd==-1?\"Failed\":\"Success\"), (cl->fileTransfer.fd==-1?strerror(errno):\"\"), cl->fileTransfer.fd);\n        /*\n        */\n        \n        /* File Size in bytes, 0xFFFFFFFF (-1) means error */\n        retval = rfbSendFileTransferMessage(cl, rfbFileAcceptHeader, 0, (cl->fileTransfer.fd==-1 ? -1 : 0), length, buffer);\n        if (cl->fileTransfer.fd==-1) {\n            free(buffer);\n            return retval;\n        }\n        \n        /* setup filetransfer stuff */\n        cl->fileTransfer.fileSize = size;\n        cl->fileTransfer.numPackets = size / sz_rfbBlockSize;\n        cl->fileTransfer.receiving = 1;\n        cl->fileTransfer.sending = 0;\n        break;\n\n    case rfbFilePacket:\n        /*\n        rfbLog(\"rfbProcessFileTransfer() rfbFilePacket:\\n\");\n        */\n        if ((buffer = rfbProcessFileTransferReadBuffer(cl, length))==NULL) return FALSE;\n        if (cl->fileTransfer.fd!=-1) {\n            /* buffer contains the contents of the file */\n            if (size==0)\n                retval=write(cl->fileTransfer.fd, buffer, length);\n            else\n            {\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n                /* compressed packet */\n                nRet = uncompress(compBuff,&nRawBytes,(const unsigned char*)buffer, length);\n\t\tif(nRet == Z_OK)\n\t\t  retval=write(cl->fileTransfer.fd, (char*)compBuff, nRawBytes);\n\t\telse\n\t\t  retval = -1;\n#else\n                /* Write the file out as received... */\n                retval=write(cl->fileTransfer.fd, buffer, length);\n#endif\n            }\n            if (retval==-1)\n            {\n                close(cl->fileTransfer.fd);\n                cl->fileTransfer.fd=-1;\n                cl->fileTransfer.sending   = 0;\n                cl->fileTransfer.receiving = 0;\n            }\n        }\n        break;\n\n    case rfbEndOfFile:\n        if (DB) rfbLog(\"rfbProcessFileTransfer() rfbEndOfFile\\n\");\n        /*\n        */\n        if (cl->fileTransfer.fd!=-1)\n            close(cl->fileTransfer.fd);\n        cl->fileTransfer.fd=-1;\n        cl->fileTransfer.sending   = 0;\n        cl->fileTransfer.receiving = 0;\n        break;\n\n    case rfbAbortFileTransfer:\n        if (DB) rfbLog(\"rfbProcessFileTransfer() rfbAbortFileTransfer\\n\");\n        /*\n        */\n        if (cl->fileTransfer.fd!=-1)\n        {\n            close(cl->fileTransfer.fd);\n            cl->fileTransfer.fd=-1;\n            cl->fileTransfer.sending   = 0;\n            cl->fileTransfer.receiving = 0;\n        }\n        else\n        {\n            /* We use this message for FileTransfer rights (<=RC18 versions)\n             * The client asks for FileTransfer permission\n             */\n            if (contentParam == 0)\n            {\n                rfbLog(\"rfbProcessFileTransfer() File Transfer Permission DENIED! (Client Version <=RC18)\\n\");\n                /* Old method for FileTransfer handshake perimssion (<=RC18) (Deny it)*/\n                return rfbSendFileTransferMessage(cl, rfbAbortFileTransfer, 0, -1, 0, \"\");\n            }\n            /* New method is allowed */\n            if (cl->screen->getFileTransferPermission!=NULL)\n            {\n                if (cl->screen->getFileTransferPermission(cl)==TRUE)\n                {\n                    rfbLog(\"rfbProcessFileTransfer() File Transfer Permission Granted!\\n\");\n                    return rfbSendFileTransferMessage(cl, rfbFileTransferAccess, 0, 1 , 0, \"\"); /* Permit */\n                }\n                else\n                {\n                    rfbLog(\"rfbProcessFileTransfer() File Transfer Permission DENIED!\\n\");\n                    return rfbSendFileTransferMessage(cl, rfbFileTransferAccess, 0, -1 , 0, \"\"); /* Deny */\n                }\n            }\n            else\n            {\n                if (cl->screen->permitFileTransfer)\n                {\n                    rfbLog(\"rfbProcessFileTransfer() File Transfer Permission Granted!\\n\");\n                    return rfbSendFileTransferMessage(cl, rfbFileTransferAccess, 0, 1 , 0, \"\"); /* Permit */\n                }\n                else\n                {\n                    rfbLog(\"rfbProcessFileTransfer() File Transfer Permission DENIED by default!\\n\");\n                    return rfbSendFileTransferMessage(cl, rfbFileTransferAccess, 0, -1 , 0, \"\"); /* DEFAULT: DENY (for security) */\n                }\n                \n            }\n        }\n        break;\n\n\n    case rfbCommand:\n        /*\n        rfbLog(\"rfbProcessFileTransfer() rfbCommand:\\n\");\n        */\n        if ((buffer = rfbProcessFileTransferReadBuffer(cl, length))==NULL) return FALSE;\n        switch (contentParam) {\n        case rfbCDirCreate:  /* Client requests the creation of a directory */\n            if (!rfbFilenameTranslate2UNIX(cl, buffer, filename1, sizeof(filename1)))\n                goto fail;\n            retval = mkdir(filename1, 0755);\n            if (DB) rfbLog(\"rfbProcessFileTransfer() rfbCommand: rfbCDirCreate(\\\"%s\\\"->\\\"%s\\\") %s\\n\", buffer, filename1, (retval==-1?\"Failed\":\"Success\"));\n            /*\n            */\n            retval = rfbSendFileTransferMessage(cl, rfbCommandReturn, rfbADirCreate, retval, length, buffer);\n            if (buffer!=NULL) free(buffer);\n            return retval;\n        case rfbCFileDelete: /* Client requests the deletion of a file */\n            if (!rfbFilenameTranslate2UNIX(cl, buffer, filename1, sizeof(filename1)))\n                goto fail;\n            if (stat(filename1,&statbuf)==0)\n            {\n                if (S_ISDIR(statbuf.st_mode))\n                    retval = rmdir(filename1);\n                else\n                    retval = unlink(filename1);\n            }\n            else retval=-1;\n            retval = rfbSendFileTransferMessage(cl, rfbCommandReturn, rfbAFileDelete, retval, length, buffer);\n            if (buffer!=NULL) free(buffer);\n            return retval;\n        case rfbCFileRename: /* Client requests the Renaming of a file/directory */\n            p = strrchr(buffer, '*');\n            if (p != NULL)\n            {\n                /* Split into 2 filenames ('*' is a seperator) */\n                *p = '\\0';\n                if (!rfbFilenameTranslate2UNIX(cl, buffer, filename1, sizeof(filename1)))\n                    goto fail;\n                if (!rfbFilenameTranslate2UNIX(cl, p+1,    filename2, sizeof(filename2)))\n                    goto fail;\n                retval = rename(filename1,filename2);\n                if (DB) rfbLog(\"rfbProcessFileTransfer() rfbCommand: rfbCFileRename(\\\"%s\\\"->\\\"%s\\\" -->> \\\"%s\\\"->\\\"%s\\\") %s\\n\", buffer, filename1, p+1, filename2, (retval==-1?\"Failed\":\"Success\"));\n                /*\n                */\n                /* Restore the buffer so the reply is good */\n                *p = '*';\n                retval = rfbSendFileTransferMessage(cl, rfbCommandReturn, rfbAFileRename, retval, length, buffer);\n                if (buffer!=NULL) free(buffer);\n                return retval;\n            }\n            break;\n        }\n    \n        break;\n    }\n\n    /* NOTE: don't forget to free(buffer) if you return early! */\n    if (buffer!=NULL) free(buffer);\n    return TRUE;\n\nfail:\n    if (buffer!=NULL) free(buffer);\n    return FALSE;\n}\n\n/*\n * rfbProcessClientNormalMessage is called when the client has sent a normal\n * protocol message.\n */\n\nstatic void\nrfbProcessClientNormalMessage(rfbClientPtr cl)\n{\n    int n=0;\n    rfbClientToServerMsg msg;\n    char *str;\n    int i;\n    uint32_t enc=0;\n    uint32_t lastPreferredEncoding = -1;\n    char encBuf[64];\n    char encBuf2[64];\n    rfbExtDesktopScreen *extDesktopScreens;\n    rfbClientIteratorPtr iterator;\n    rfbClientPtr clp;\n\n    if ((n = rfbReadExact(cl, (char *)&msg, 1)) <= 0) {\n        if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n        rfbCloseClient(cl);\n        return;\n    }\n\n    switch (msg.type) {\n\n    case rfbSetPixelFormat:\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbSetPixelFormatMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        cl->format.bitsPerPixel = msg.spf.format.bitsPerPixel;\n        cl->format.depth = msg.spf.format.depth;\n        cl->format.bigEndian = (msg.spf.format.bigEndian ? TRUE : FALSE);\n        cl->format.trueColour = (msg.spf.format.trueColour ? TRUE : FALSE);\n        cl->format.redMax = Swap16IfLE(msg.spf.format.redMax);\n        cl->format.greenMax = Swap16IfLE(msg.spf.format.greenMax);\n        cl->format.blueMax = Swap16IfLE(msg.spf.format.blueMax);\n        cl->format.redShift = msg.spf.format.redShift;\n        cl->format.greenShift = msg.spf.format.greenShift;\n        cl->format.blueShift = msg.spf.format.blueShift;\n\n\tcl->readyForSetColourMapEntries = TRUE;\n        cl->screen->setTranslateFunction(cl);\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetPixelFormatMsg, sz_rfbSetPixelFormatMsg);\n\n        return;\n\n\n    case rfbFixColourMapEntries:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbFixColourMapEntriesMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetPixelFormatMsg, sz_rfbSetPixelFormatMsg);\n        rfbLog(\"rfbProcessClientNormalMessage: %s\",\n                \"FixColourMapEntries unsupported\\n\");\n        rfbCloseClient(cl);\n        return;\n\n\n    /* NOTE: Some clients send us a set of encodings (ie: PointerPos) designed to enable/disable features...\n     * We may want to look into this...\n     * Example:\n     *     case rfbEncodingXCursor:\n     *         cl->enableCursorShapeUpdates = TRUE;\n     *\n     * Currently: cl->enableCursorShapeUpdates can *never* be turned off...\n     */\n    case rfbSetEncodings:\n    {\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbSetEncodingsMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        msg.se.nEncodings = Swap16IfLE(msg.se.nEncodings);\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetEncodingsMsg+(msg.se.nEncodings*4),sz_rfbSetEncodingsMsg+(msg.se.nEncodings*4));\n\n        /*\n         * UltraVNC Client has the ability to adapt to changing network environments\n         * So, let's give it a change to tell us what it wants now!\n         */\n        if (cl->preferredEncoding!=-1)\n            lastPreferredEncoding = cl->preferredEncoding;\n\n        /* Reset all flags to defaults (allows us to switch between PointerPos and Server Drawn Cursors) */\n        cl->preferredEncoding=-1;\n        cl->useCopyRect              = FALSE;\n        cl->useNewFBSize             = FALSE;\n        cl->useExtDesktopSize        = FALSE;\n        cl->cursorWasChanged         = FALSE;\n        cl->useRichCursorEncoding    = FALSE;\n        cl->enableCursorPosUpdates   = FALSE;\n        cl->enableCursorShapeUpdates = FALSE;\n        cl->enableCursorShapeUpdates = FALSE;\n        cl->enableLastRectEncoding   = FALSE;\n        cl->enableKeyboardLedState   = FALSE;\n        cl->enableSupportedMessages  = FALSE;\n        cl->enableSupportedEncodings = FALSE;\n        cl->enableServerIdentity     = FALSE;\n#if defined(LIBVNCSERVER_HAVE_LIBZ) || defined(LIBVNCSERVER_HAVE_LIBPNG)\n        cl->tightQualityLevel        = -1;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n        cl->tightCompressLevel       = TIGHT_DEFAULT_COMPRESSION;\n        cl->turboSubsampLevel        = TURBO_DEFAULT_SUBSAMP;\n        cl->turboQualityLevel        = -1;\n#endif\n#endif\n\n\n        for (i = 0; i < msg.se.nEncodings; i++) {\n            if ((n = rfbReadExact(cl, (char *)&enc, 4)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n                rfbCloseClient(cl);\n                return;\n            }\n            enc = Swap32IfLE(enc);\n\n            switch (enc) {\n\n            case rfbEncodingCopyRect:\n\t\tcl->useCopyRect = TRUE;\n                break;\n            case rfbEncodingRaw:\n            case rfbEncodingRRE:\n            case rfbEncodingCoRRE:\n            case rfbEncodingHextile:\n            case rfbEncodingUltra:\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\t    case rfbEncodingZlib:\n            case rfbEncodingZRLE:\n            case rfbEncodingZYWRLE:\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t    case rfbEncodingTight:\n#endif\n#endif\n#ifdef LIBVNCSERVER_HAVE_LIBPNG\n\t    case rfbEncodingTightPng:\n#endif\n            /* The first supported encoding is the 'preferred' encoding */\n                if (cl->preferredEncoding == -1)\n                    cl->preferredEncoding = enc;\n\n\n                break;\n\t    case rfbEncodingXCursor:\n\t\tif(!cl->screen->dontConvertRichCursorToXCursor) {\n\t\t    rfbLog(\"Enabling X-style cursor updates for client %s\\n\",\n\t\t\t   cl->host);\n\t\t    /* if cursor was drawn, hide the cursor */\n\t\t    if(!cl->enableCursorShapeUpdates)\n\t\t        rfbRedrawAfterHideCursor(cl,NULL);\n\n\t\t    cl->enableCursorShapeUpdates = TRUE;\n\t\t    cl->cursorWasChanged = TRUE;\n\t\t}\n\t\tbreak;\n\t    case rfbEncodingRichCursor:\n\t        rfbLog(\"Enabling full-color cursor updates for client %s\\n\",\n\t\t       cl->host);\n\t\t/* if cursor was drawn, hide the cursor */\n\t\tif(!cl->enableCursorShapeUpdates)\n\t\t    rfbRedrawAfterHideCursor(cl,NULL);\n\n\t        cl->enableCursorShapeUpdates = TRUE;\n\t        cl->useRichCursorEncoding = TRUE;\n\t        cl->cursorWasChanged = TRUE;\n\t        break;\n\t    case rfbEncodingPointerPos:\n\t\tif (!cl->enableCursorPosUpdates) {\n\t\t    rfbLog(\"Enabling cursor position updates for client %s\\n\",\n\t\t\t   cl->host);\n\t\t    cl->enableCursorPosUpdates = TRUE;\n\t\t    cl->cursorWasMoved = TRUE;\n\t\t}\n\t        break;\n\t    case rfbEncodingLastRect:\n\t\tif (!cl->enableLastRectEncoding) {\n\t\t    rfbLog(\"Enabling LastRect protocol extension for client \"\n\t\t\t   \"%s\\n\", cl->host);\n\t\t    cl->enableLastRectEncoding = TRUE;\n\t\t}\n\t\tbreak;\n\t    case rfbEncodingNewFBSize:\n\t\tif (!cl->useNewFBSize) {\n\t\t    rfbLog(\"Enabling NewFBSize protocol extension for client \"\n\t\t\t   \"%s\\n\", cl->host);\n\t\t    cl->useNewFBSize = TRUE;\n\t\t}\n\t\tbreak;\n            case rfbEncodingExtDesktopSize:\n                if (!cl->useExtDesktopSize) {\n                    rfbLog(\"Enabling ExtDesktopSize protocol extension for client \"\n                           \"%s\\n\", cl->host);\n                    cl->useExtDesktopSize = TRUE;\n                    cl->useNewFBSize = TRUE;\n                }\n                break;\n            case rfbEncodingKeyboardLedState:\n                if (!cl->enableKeyboardLedState) {\n                  rfbLog(\"Enabling KeyboardLedState protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableKeyboardLedState = TRUE;\n                }\n                break;           \n            case rfbEncodingSupportedMessages:\n                if (!cl->enableSupportedMessages) {\n                  rfbLog(\"Enabling SupportedMessages protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableSupportedMessages = TRUE;\n                }\n                break;           \n            case rfbEncodingSupportedEncodings:\n                if (!cl->enableSupportedEncodings) {\n                  rfbLog(\"Enabling SupportedEncodings protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableSupportedEncodings = TRUE;\n                }\n                break;           \n            case rfbEncodingServerIdentity:\n                if (!cl->enableServerIdentity) {\n                  rfbLog(\"Enabling ServerIdentity protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  cl->enableServerIdentity = TRUE;\n                }\n                break;\n            case rfbEncodingXvp:\n                if (cl->screen->xvpHook) {\n                  rfbLog(\"Enabling Xvp protocol extension for client \"\n                          \"%s\\n\", cl->host);\n                  if (!rfbSendXvp(cl, 1, rfbXvp_Init)) {\n                    rfbCloseClient(cl);\n                    return;\n                  }\n                }\n                break;\n            default:\n#if defined(LIBVNCSERVER_HAVE_LIBZ) || defined(LIBVNCSERVER_HAVE_LIBPNG)\n\t\tif ( enc >= (uint32_t)rfbEncodingCompressLevel0 &&\n\t\t     enc <= (uint32_t)rfbEncodingCompressLevel9 ) {\n\t\t    cl->zlibCompressLevel = enc & 0x0F;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t\t    cl->tightCompressLevel = enc & 0x0F;\n\t\t    rfbLog(\"Using compression level %d for client %s\\n\",\n\t\t\t   cl->tightCompressLevel, cl->host);\n#endif\n\t\t} else if ( enc >= (uint32_t)rfbEncodingQualityLevel0 &&\n\t\t\t    enc <= (uint32_t)rfbEncodingQualityLevel9 ) {\n\t\t    cl->tightQualityLevel = enc & 0x0F;\n\t\t    rfbLog(\"Using image quality level %d for client %s\\n\",\n\t\t\t   cl->tightQualityLevel, cl->host);\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t\t    cl->turboQualityLevel = tight2turbo_qual[enc & 0x0F];\n\t\t    cl->turboSubsampLevel = tight2turbo_subsamp[enc & 0x0F];\n\t\t    rfbLog(\"Using JPEG subsampling %d, Q%d for client %s\\n\",\n\t\t\t   cl->turboSubsampLevel, cl->turboQualityLevel, cl->host);\n\t\t} else if ( enc >= (uint32_t)rfbEncodingFineQualityLevel0 + 1 &&\n\t\t\t    enc <= (uint32_t)rfbEncodingFineQualityLevel100 ) {\n\t\t    cl->turboQualityLevel = enc & 0xFF;\n\t\t    rfbLog(\"Using fine quality level %d for client %s\\n\",\n\t\t\t   cl->turboQualityLevel, cl->host);\n\t\t} else if ( enc >= (uint32_t)rfbEncodingSubsamp1X &&\n\t\t\t    enc <= (uint32_t)rfbEncodingSubsampGray ) {\n\t\t    cl->turboSubsampLevel = enc & 0xFF;\n\t\t    rfbLog(\"Using subsampling level %d for client %s\\n\",\n\t\t\t   cl->turboSubsampLevel, cl->host);\n#endif\n\t\t} else\n#endif\n\t\t{\n\t\t\trfbExtensionData* e;\n\t\t\tfor(e = cl->extensions; e;) {\n\t\t\t\trfbExtensionData* next = e->next;\n\t\t\t\tif(e->extension->enablePseudoEncoding &&\n\t\t\t\t\te->extension->enablePseudoEncoding(cl,\n\t\t\t\t\t\t&e->data, (int)enc))\n\t\t\t\t\t/* ext handles this encoding */\n\t\t\t\t\tbreak;\n\t\t\t\te = next;\n\t\t\t}\n\t\t\tif(e == NULL) {\n\t\t\t\trfbBool handled = FALSE;\n\t\t\t\t/* if the pseudo encoding is not handled by the\n\t\t\t\t   enabled extensions, search through all\n\t\t\t\t   extensions. */\n\t\t\t\trfbProtocolExtension* e;\n\n\t\t\t\tfor(e = rfbGetExtensionIterator(); e;) {\n\t\t\t\t\tint* encs = e->pseudoEncodings;\n\t\t\t\t\twhile(encs && *encs!=0) {\n\t\t\t\t\t\tif(*encs==(int)enc) {\n\t\t\t\t\t\t\tvoid* data = NULL;\n\t\t\t\t\t\t\tif(!e->enablePseudoEncoding(cl, &data, (int)enc)) {\n\t\t\t\t\t\t\t\trfbLog(\"Installed extension pretends to handle pseudo encoding 0x%x, but does not!\\n\",(int)enc);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\trfbEnableExtension(cl, e, data);\n\t\t\t\t\t\t\t\thandled = TRUE;\n\t\t\t\t\t\t\t\te = NULL;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tencs++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(e)\n\t\t\t\t\t\te = e->next;\n\t\t\t\t}\n\t\t\t\trfbReleaseExtensionIterator();\n\n\t\t\t\tif(!handled)\n\t\t\t\t\trfbLog(\"rfbProcessClientNormalMessage: \"\n\t\t\t\t\t    \"ignoring unsupported encoding type %s\\n\",\n\t\t\t\t\t    encodingName(enc,encBuf,sizeof(encBuf)));\n\t\t\t}\n\t\t}\n            }\n        }\n\n\n\n        if (cl->preferredEncoding == -1) {\n            if (lastPreferredEncoding==-1) {\n                cl->preferredEncoding = rfbEncodingRaw;\n                rfbLog(\"Defaulting to %s encoding for client %s\\n\", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n            }\n            else {\n                cl->preferredEncoding = lastPreferredEncoding;\n                rfbLog(\"Sticking with %s encoding for client %s\\n\", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n            }\n        }\n        else\n        {\n          if (lastPreferredEncoding==-1) {\n              rfbLog(\"Using %s encoding for client %s\\n\", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);\n          } else {\n              rfbLog(\"Switching from %s to %s Encoding for client %s\\n\", \n                  encodingName(lastPreferredEncoding,encBuf2,sizeof(encBuf2)),\n                  encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)), cl->host);\n          }\n        }\n        \n\tif (cl->enableCursorPosUpdates && !cl->enableCursorShapeUpdates) {\n\t  rfbLog(\"Disabling cursor position updates for client %s\\n\",\n\t\t cl->host);\n\t  cl->enableCursorPosUpdates = FALSE;\n\t}\n\n        return;\n    }\n\n\n    case rfbFramebufferUpdateRequest:\n    {\n        sraRegionPtr tmpRegion;\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                           sz_rfbFramebufferUpdateRequestMsg-1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbFramebufferUpdateRequestMsg,sz_rfbFramebufferUpdateRequestMsg);\n\n        /* The values come in based on the scaled screen, we need to convert them to\n         * values based on the main screen's coordinate system\n         */\n\tif(!rectSwapIfLEAndClip(&msg.fur.x,&msg.fur.y,&msg.fur.w,&msg.fur.h,cl))\n\t{\n\t        rfbLog(\"Warning, ignoring rfbFramebufferUpdateRequest: %dXx%dY-%dWx%dH\\n\",msg.fur.x, msg.fur.y, msg.fur.w, msg.fur.h);\n\t\treturn;\n        }\n\n        if (cl->clientFramebufferUpdateRequestHook)\n            cl->clientFramebufferUpdateRequestHook(cl, &msg.fur);\n\n\ttmpRegion =\n\t  sraRgnCreateRect(msg.fur.x,\n\t\t\t   msg.fur.y,\n\t\t\t   msg.fur.x+msg.fur.w,\n\t\t\t   msg.fur.y+msg.fur.h);\n\n        LOCK(cl->updateMutex);\n\tsraRgnOr(cl->requestedRegion,tmpRegion);\n\n\tif (!cl->readyForSetColourMapEntries) {\n\t    /* client hasn't sent a SetPixelFormat so is using server's */\n\t    cl->readyForSetColourMapEntries = TRUE;\n\t    if (!cl->format.trueColour) {\n\t\tif (!rfbSetClientColourMap(cl, 0, 0)) {\n\t\t    sraRgnDestroy(tmpRegion);\n\t\t    TSIGNAL(cl->updateCond);\n\t\t    UNLOCK(cl->updateMutex);\n\t\t    return;\n\t\t}\n\t    }\n\t}\n\n       if (!msg.fur.incremental) {\n\t    sraRgnOr(cl->modifiedRegion,tmpRegion);\n\t    sraRgnSubtract(cl->copyRegion,tmpRegion);\n            if (cl->useExtDesktopSize)\n                cl->newFBSizePending = TRUE;\n       }\n       TSIGNAL(cl->updateCond);\n       UNLOCK(cl->updateMutex);\n\n       sraRgnDestroy(tmpRegion);\n\n       return;\n    }\n\n    case rfbKeyEvent:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbKeyEventMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbKeyEventMsg, sz_rfbKeyEventMsg);\n\n\tif(!cl->viewOnly) {\n\t    cl->screen->kbdAddEvent(msg.ke.down, (rfbKeySym)Swap32IfLE(msg.ke.key), cl);\n\t}\n\n        return;\n\n\n    case rfbPointerEvent:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbPointerEventMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbPointerEventMsg, sz_rfbPointerEventMsg);\n\t\n\tif (cl->screen->pointerClient && cl->screen->pointerClient != cl)\n\t    return;\n\n\tif (msg.pe.buttonMask == 0)\n\t    cl->screen->pointerClient = NULL;\n\telse\n\t    cl->screen->pointerClient = cl;\n\n\tif(!cl->viewOnly) {\n\t    if (msg.pe.buttonMask != cl->lastPtrButtons ||\n\t\t    cl->screen->deferPtrUpdateTime == 0) {\n\t\tcl->screen->ptrAddEvent(msg.pe.buttonMask,\n\t\t\tScaleX(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.x)), \n\t\t\tScaleY(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.y)),\n\t\t\tcl);\n\t\tcl->lastPtrButtons = msg.pe.buttonMask;\n\t    } else {\n\t\tcl->lastPtrX = ScaleX(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.x));\n\t\tcl->lastPtrY = ScaleY(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.y));\n\t\tcl->lastPtrButtons = msg.pe.buttonMask;\n\t    }\n      }      \n      return;\n\n\n    case rfbFileTransfer:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbFileTransferMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        msg.ft.size         = Swap32IfLE(msg.ft.size);\n        msg.ft.length       = Swap32IfLE(msg.ft.length);\n        /* record statistics in rfbProcessFileTransfer as length is filled with garbage when it is not valid */\n        rfbProcessFileTransfer(cl, msg.ft.contentType, msg.ft.contentParam, msg.ft.size, msg.ft.length);\n        return;\n\n    case rfbSetSW:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbSetSWMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        msg.sw.x = Swap16IfLE(msg.sw.x);\n        msg.sw.y = Swap16IfLE(msg.sw.y);\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetSWMsg, sz_rfbSetSWMsg);\n        /* msg.sw.status is not initialized in the ultraVNC viewer and contains random numbers (why???) */\n\n        rfbLog(\"Received a rfbSetSingleWindow(%d x, %d y)\\n\", msg.sw.x, msg.sw.y);\n        if (cl->screen->setSingleWindow!=NULL)\n            cl->screen->setSingleWindow(cl, msg.sw.x, msg.sw.y);\n        return;\n\n    case rfbSetServerInput:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbSetServerInputMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetServerInputMsg, sz_rfbSetServerInputMsg);\n\n        /* msg.sim.pad is not initialized in the ultraVNC viewer and contains random numbers (why???) */\n        /* msg.sim.pad = Swap16IfLE(msg.sim.pad); */\n\n        rfbLog(\"Received a rfbSetServerInput(%d status)\\n\", msg.sim.status);\n        if (cl->screen->setServerInput!=NULL)\n            cl->screen->setServerInput(cl, msg.sim.status);\n        return;\n        \n    case rfbTextChat:\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n                              sz_rfbTextChatMsg - 1)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n        \n        msg.tc.pad2   = Swap16IfLE(msg.tc.pad2);\n        msg.tc.length = Swap32IfLE(msg.tc.length);\n\n        switch (msg.tc.length) {\n        case rfbTextChatOpen:\n        case rfbTextChatClose:\n        case rfbTextChatFinished:\n            /* commands do not have text following */\n            /* Why couldn't they have used the pad byte??? */\n            str=NULL;\n            rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbTextChatMsg, sz_rfbTextChatMsg);\n            break;\n        default:\n            if ((msg.tc.length>0) && (msg.tc.length<rfbTextMaxSize))\n            {\n                str = (char *)malloc(msg.tc.length);\n                if (str==NULL)\n                {\n                    rfbLog(\"Unable to malloc %d bytes for a TextChat Message\\n\", msg.tc.length);\n                    rfbCloseClient(cl);\n                    return;\n                }\n                if ((n = rfbReadExact(cl, str, msg.tc.length)) <= 0) {\n                    if (n != 0)\n                        rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n                    free(str);\n                    rfbCloseClient(cl);\n                    return;\n                }\n                rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbTextChatMsg+msg.tc.length, sz_rfbTextChatMsg+msg.tc.length);\n            }\n            else\n            {\n                /* This should never happen */\n                rfbLog(\"client sent us a Text Message that is too big %d>%d\\n\", msg.tc.length, rfbTextMaxSize);\n                rfbCloseClient(cl);\n                return;\n            }\n        }\n\n        /* Note: length can be commands: rfbTextChatOpen, rfbTextChatClose, and rfbTextChatFinished\n         * at which point, the str is NULL (as it is not sent)\n         */\n        if (cl->screen->setTextChat!=NULL)\n            cl->screen->setTextChat(cl, msg.tc.length, str);\n\n        free(str);\n        return;\n\n\n    case rfbClientCutText:\n\n\tif ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n\t\t\t   sz_rfbClientCutTextMsg - 1)) <= 0) {\n\t    if (n != 0)\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\tmsg.cct.length = Swap32IfLE(msg.cct.length);\n\n\t/* uint32_t input is passed to malloc()'s size_t argument,\n\t * to rfbReadExact()'s int argument, to rfbStatRecordMessageRcvd()'s int\n\t * argument increased of sz_rfbClientCutTextMsg, and to setXCutText()'s int\n\t * argument. Here we impose a limit of 1 MB so that the value fits\n\t * into all of the types to prevent from misinterpretation and thus\n\t * from accessing uninitialized memory (CVE-2018-7225) and also to\n\t * prevent from a denial-of-service by allocating too much memory in\n\t * the server. */\n\tif (msg.cct.length > 1<<20) {\n\t    rfbLog(\"rfbClientCutText: too big cut text length requested: %u B > 1 MB\\n\", (unsigned int)msg.cct.length);\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\n\t/* Allow zero-length client cut text. */\n\tstr = (char *)calloc(msg.cct.length ? msg.cct.length : 1, 1);\n\tif (str == NULL) {\n\t\trfbLogPerror(\"rfbProcessClientNormalMessage: not enough memory\");\n\t\trfbCloseClient(cl);\n\t\treturn;\n\t}\n\n\tif ((n = rfbReadExact(cl, str, msg.cct.length)) <= 0) {\n\t    if (n != 0)\n\t        rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n\t    free(str);\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n\trfbStatRecordMessageRcvd(cl, msg.type, sz_rfbClientCutTextMsg+msg.cct.length, sz_rfbClientCutTextMsg+msg.cct.length);\n\tif(!cl->viewOnly) {\n\t    cl->screen->setXCutText(str, msg.cct.length, cl);\n\t}\n\tfree(str);\n\n        return;\n\n    case rfbPalmVNCSetScaleFactor:\n      cl->PalmVNC = TRUE;\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbSetScaleMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      if (msg.ssc.scale == 0) {\n          rfbLogPerror(\"rfbProcessClientNormalMessage: will not accept a scale factor of zero\");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetScaleMsg, sz_rfbSetScaleMsg);\n      rfbLog(\"rfbSetScale(%d)\\n\", msg.ssc.scale);\n      rfbScalingSetup(cl,cl->screen->width/msg.ssc.scale, cl->screen->height/msg.ssc.scale);\n\n      rfbSendNewScaleSize(cl);\n      return;\n      \n    case rfbSetScale:\n\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbSetScaleMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      if (msg.ssc.scale == 0) {\n          rfbLogPerror(\"rfbProcessClientNormalMessage: will not accept a scale factor of zero\");\n          rfbCloseClient(cl);\n          return;\n      }\n\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetScaleMsg, sz_rfbSetScaleMsg);\n      rfbLog(\"rfbSetScale(%d)\\n\", msg.ssc.scale);\n      rfbScalingSetup(cl,cl->screen->width/msg.ssc.scale, cl->screen->height/msg.ssc.scale);\n\n      rfbSendNewScaleSize(cl);\n      return;\n\n    case rfbXvp:\n\n      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n          sz_rfbXvpMsg - 1)) <= 0) {\n          if (n != 0)\n            rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n          rfbCloseClient(cl);\n          return;\n      }\n      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbXvpMsg, sz_rfbXvpMsg);\n\n      /* only version when is defined, so echo back a fail */\n      if(msg.xvp.version != 1) {\n\trfbSendXvp(cl, msg.xvp.version, rfbXvp_Fail);\n      }\n      else {\n\t/* if the hook exists and fails, send a fail msg */\n\tif(cl->screen->xvpHook && !cl->screen->xvpHook(cl, msg.xvp.version, msg.xvp.code))\n\t  rfbSendXvp(cl, 1, rfbXvp_Fail);\n      }\n      return;\n\n    case rfbSetDesktopSize:\n\n        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,\n            sz_rfbSetDesktopSizeMsg - 1)) <= 0) {\n            if (n != 0)\n              rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            rfbCloseClient(cl);\n            return;\n        }\n\n        if (msg.sdm.numberOfScreens == 0) {\n            rfbLog(\"Ignoring setDesktopSize message from client that defines zero screens\\n\");\n            return;\n        }\n\n        extDesktopScreens = (rfbExtDesktopScreen *) malloc(msg.sdm.numberOfScreens * sz_rfbExtDesktopScreen);\n        if (extDesktopScreens == NULL) {\n                rfbLogPerror(\"rfbProcessClientNormalMessage: not enough memory\");\n                rfbCloseClient(cl);\n                return;\n        }\n\n        if ((n = rfbReadExact(cl, ((char *)extDesktopScreens), msg.sdm.numberOfScreens * sz_rfbExtDesktopScreen)) <= 0) {\n            if (n != 0)\n                rfbLogPerror(\"rfbProcessClientNormalMessage: read\");\n            free(extDesktopScreens);\n            rfbCloseClient(cl);\n            return;\n        }\n        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetDesktopSizeMsg + msg.sdm.numberOfScreens * sz_rfbExtDesktopScreen,\n                                 sz_rfbSetDesktopSizeMsg + msg.sdm.numberOfScreens * sz_rfbExtDesktopScreen);\n\n        for (i=0; i < msg.sdm.numberOfScreens; i++) {\n            extDesktopScreens[i].id = Swap32IfLE(extDesktopScreens[i].id);\n            extDesktopScreens[i].x = Swap16IfLE(extDesktopScreens[i].x);\n            extDesktopScreens[i].y = Swap16IfLE(extDesktopScreens[i].y);\n            extDesktopScreens[i].width = Swap16IfLE(extDesktopScreens[i].width);\n            extDesktopScreens[i].height = Swap16IfLE(extDesktopScreens[i].height);\n            extDesktopScreens[i].flags = Swap32IfLE(extDesktopScreens[i].flags);\n        }\n        msg.sdm.width = Swap16IfLE(msg.sdm.width);\n        msg.sdm.height = Swap16IfLE(msg.sdm.height);\n\n        rfbLog(\"Client requested resolution change to (%dx%d)\\n\", msg.sdm.width, msg.sdm.height);\n        cl->requestedDesktopSizeChange = rfbExtDesktopSize_ClientRequestedChange;\n        cl->lastDesktopSizeChangeError = cl->screen->setDesktopSizeHook(msg.sdm.width, msg.sdm.height, msg.sdm.numberOfScreens,\n                                           extDesktopScreens, cl);\n\n        if (cl->lastDesktopSizeChangeError == 0) {\n            /* Let other clients know it was this client that requested the change */\n            iterator = rfbGetClientIterator(cl->screen);\n            while ((clp = rfbClientIteratorNext(iterator)) != NULL) {\n                LOCK(clp->updateMutex);\n                if (clp != cl)\n                    clp->requestedDesktopSizeChange = rfbExtDesktopSize_OtherClientRequestedChange;\n                UNLOCK(clp->updateMutex);\n            }\n        }\n        else\n        {\n            /* Force ExtendedDesktopSize message to be sent with result code in case of error.\n               (In case of success, it is delayed until the new framebuffer is created) */\n            cl->newFBSizePending = TRUE;\n        }\n\n        free(extDesktopScreens);\n        return;\n\n    default:\n\t{\n\t    rfbExtensionData *e,*next;\n\n\t    for(e=cl->extensions; e;) {\n\t\tnext = e->next;\n\t\tif(e->extension->handleMessage &&\n\t\t\te->extension->handleMessage(cl, e->data, &msg))\n                {\n                    rfbStatRecordMessageRcvd(cl, msg.type, 0, 0); /* Extension should handle this */\n\t\t    return;\n                }\n\t\te = next;\n\t    }\n\n\t    rfbLog(\"rfbProcessClientNormalMessage: unknown message type %d\\n\",\n\t\t    msg.type);\n\t    rfbLog(\" ... closing connection\\n\");\n\t    rfbCloseClient(cl);\n\t    return;\n\t}\n    }\n}\n\n\n\n/*\n * rfbSendFramebufferUpdate - send the currently pending framebuffer update to\n * the RFB client.\n * givenUpdateRegion is not changed.\n */\n\nrfbBool\nrfbSendFramebufferUpdate(rfbClientPtr cl,\n                         sraRegionPtr givenUpdateRegion)\n{\n    sraRectangleIterator* i=NULL;\n    sraRect rect;\n    int nUpdateRegionRects;\n    rfbFramebufferUpdateMsg *fu = (rfbFramebufferUpdateMsg *)cl->updateBuf;\n    sraRegionPtr updateRegion,updateCopyRegion,tmpRegion;\n    int dx, dy;\n    rfbBool sendCursorShape = FALSE;\n    rfbBool sendCursorPos = FALSE;\n    rfbBool sendKeyboardLedState = FALSE;\n    rfbBool sendSupportedMessages = FALSE;\n    rfbBool sendSupportedEncodings = FALSE;\n    rfbBool sendServerIdentity = FALSE;\n    rfbBool result = TRUE;\n    \n\n    if(cl->screen->displayHook)\n      cl->screen->displayHook(cl);\n\n    /*\n     * If framebuffer size was changed and the client supports NewFBSize\n     * encoding, just send NewFBSize marker and return.\n     */\n\n    if (cl->useNewFBSize && cl->newFBSizePending) {\n      LOCK(cl->updateMutex);\n      cl->newFBSizePending = FALSE;\n      UNLOCK(cl->updateMutex);\n      fu->type = rfbFramebufferUpdate;\n      fu->nRects = Swap16IfLE(1);\n      cl->ublen = sz_rfbFramebufferUpdateMsg;\n\n      if (cl->useExtDesktopSize) {\n        if (!rfbSendExtDesktopSize(cl, cl->scaledScreen->width, cl->scaledScreen->height)) {\n          if(cl->screen->displayFinishedHook)\n            cl->screen->displayFinishedHook(cl, FALSE);\n          return FALSE;\n        }\n      }\n      else if (!rfbSendNewFBSize(cl, cl->scaledScreen->width, cl->scaledScreen->height)) {\n\tif(cl->screen->displayFinishedHook)\n\t  cl->screen->displayFinishedHook(cl, FALSE);\n        return FALSE;\n      }\n      result = rfbSendUpdateBuf(cl);\n      if(cl->screen->displayFinishedHook)\n\tcl->screen->displayFinishedHook(cl, result);\n      return result;\n    }\n    \n    /*\n     * If this client understands cursor shape updates, cursor should be\n     * removed from the framebuffer. Otherwise, make sure it's put up.\n     */\n\n    if (cl->enableCursorShapeUpdates) {\n      if (cl->cursorWasChanged && cl->readyForSetColourMapEntries)\n\t  sendCursorShape = TRUE;\n    }\n\n    /*\n     * Do we plan to send cursor position update?\n     */\n\n    if (cl->enableCursorPosUpdates && cl->cursorWasMoved)\n      sendCursorPos = TRUE;\n\n    /*\n     * Do we plan to send a keyboard state update?\n     */\n    if ((cl->enableKeyboardLedState) &&\n\t(cl->screen->getKeyboardLedStateHook!=NULL))\n    {\n        int x;\n        x=cl->screen->getKeyboardLedStateHook(cl->screen);\n        if (x!=cl->lastKeyboardLedState)\n        {\n            sendKeyboardLedState = TRUE;\n            cl->lastKeyboardLedState=x;\n        }\n    }\n\n    /*\n     * Do we plan to send a rfbEncodingSupportedMessages?\n     */\n    if (cl->enableSupportedMessages)\n    {\n        sendSupportedMessages = TRUE;\n        /* We only send this message ONCE <per setEncodings message received>\n         * (We disable it here)\n         */\n        cl->enableSupportedMessages = FALSE;\n    }\n    /*\n     * Do we plan to send a rfbEncodingSupportedEncodings?\n     */\n    if (cl->enableSupportedEncodings)\n    {\n        sendSupportedEncodings = TRUE;\n        /* We only send this message ONCE <per setEncodings message received>\n         * (We disable it here)\n         */\n        cl->enableSupportedEncodings = FALSE;\n    }\n    /*\n     * Do we plan to send a rfbEncodingServerIdentity?\n     */\n    if (cl->enableServerIdentity)\n    {\n        sendServerIdentity = TRUE;\n        /* We only send this message ONCE <per setEncodings message received>\n         * (We disable it here)\n         */\n        cl->enableServerIdentity = FALSE;\n    }\n\n    LOCK(cl->updateMutex);\n\n    /*\n     * The modifiedRegion may overlap the destination copyRegion.  We remove\n     * any overlapping bits from the copyRegion (since they'd only be\n     * overwritten anyway).\n     */\n    \n    sraRgnSubtract(cl->copyRegion,cl->modifiedRegion);\n\n    /*\n     * The client is interested in the region requestedRegion.  The region\n     * which should be updated now is the intersection of requestedRegion\n     * and the union of modifiedRegion and copyRegion.  If it's empty then\n     * no update is needed.\n     */\n\n    updateRegion = sraRgnCreateRgn(givenUpdateRegion);\n    if(cl->screen->progressiveSliceHeight>0) {\n\t    int height=cl->screen->progressiveSliceHeight,\n\t    \ty=cl->progressiveSliceY;\n\t    sraRegionPtr bbox=sraRgnBBox(updateRegion);\n\t    sraRect rect;\n\t    if(sraRgnPopRect(bbox,&rect,0)) {\n\t\tsraRegionPtr slice;\n\t\tif(y<rect.y1 || y>=rect.y2)\n\t\t    y=rect.y1;\n\t    \tslice=sraRgnCreateRect(0,y,cl->screen->width,y+height);\n\t\tsraRgnAnd(updateRegion,slice);\n\t\tsraRgnDestroy(slice);\n\t    }\n\t    sraRgnDestroy(bbox);\n\t    y+=height;\n\t    if(y>=cl->screen->height)\n\t\t    y=0;\n\t    cl->progressiveSliceY=y;\n    }\n\n    sraRgnOr(updateRegion,cl->copyRegion);\n    if(!sraRgnAnd(updateRegion,cl->requestedRegion) &&\n       sraRgnEmpty(updateRegion) &&\n       (cl->enableCursorShapeUpdates ||\n\t(cl->cursorX == cl->screen->cursorX && cl->cursorY == cl->screen->cursorY)) &&\n       !sendCursorShape && !sendCursorPos && !sendKeyboardLedState &&\n       !sendSupportedMessages && !sendSupportedEncodings && !sendServerIdentity) {\n      sraRgnDestroy(updateRegion);\n      UNLOCK(cl->updateMutex);\n      if(cl->screen->displayFinishedHook)\n\tcl->screen->displayFinishedHook(cl, TRUE);\n      return TRUE;\n    }\n\n    /*\n     * We assume that the client doesn't have any pixel data outside the\n     * requestedRegion.  In other words, both the source and destination of a\n     * copy must lie within requestedRegion.  So the region we can send as a\n     * copy is the intersection of the copyRegion with both the requestedRegion\n     * and the requestedRegion translated by the amount of the copy.  We set\n     * updateCopyRegion to this.\n     */\n\n    updateCopyRegion = sraRgnCreateRgn(cl->copyRegion);\n    sraRgnAnd(updateCopyRegion,cl->requestedRegion);\n    tmpRegion = sraRgnCreateRgn(cl->requestedRegion);\n    sraRgnOffset(tmpRegion,cl->copyDX,cl->copyDY);\n    sraRgnAnd(updateCopyRegion,tmpRegion);\n    sraRgnDestroy(tmpRegion);\n    dx = cl->copyDX;\n    dy = cl->copyDY;\n\n    /*\n     * Next we remove updateCopyRegion from updateRegion so that updateRegion\n     * is the part of this update which is sent as ordinary pixel data (i.e not\n     * a copy).\n     */\n\n    sraRgnSubtract(updateRegion,updateCopyRegion);\n\n    /*\n     * Finally we leave modifiedRegion to be the remainder (if any) of parts of\n     * the screen which are modified but outside the requestedRegion.  We also\n     * empty both the requestedRegion and the copyRegion - note that we never\n     * carry over a copyRegion for a future update.\n     */\n\n     sraRgnOr(cl->modifiedRegion,cl->copyRegion);\n     sraRgnSubtract(cl->modifiedRegion,updateRegion);\n     sraRgnSubtract(cl->modifiedRegion,updateCopyRegion);\n\n     sraRgnMakeEmpty(cl->requestedRegion);\n     sraRgnMakeEmpty(cl->copyRegion);\n     cl->copyDX = 0;\n     cl->copyDY = 0;\n   \n     UNLOCK(cl->updateMutex);\n   \n    if (!cl->enableCursorShapeUpdates) {\n      if(cl->cursorX != cl->screen->cursorX || cl->cursorY != cl->screen->cursorY) {\n\trfbRedrawAfterHideCursor(cl,updateRegion);\n\tLOCK(cl->screen->cursorMutex);\n\tcl->cursorX = cl->screen->cursorX;\n\tcl->cursorY = cl->screen->cursorY;\n\tUNLOCK(cl->screen->cursorMutex);\n\trfbRedrawAfterHideCursor(cl,updateRegion);\n      }\n      rfbShowCursor(cl);\n    }\n\n    /*\n     * Now send the update.\n     */\n    \n    rfbStatRecordMessageSent(cl, rfbFramebufferUpdate, 0, 0);\n    if (cl->preferredEncoding == rfbEncodingCoRRE) {\n        nUpdateRegionRects = 0;\n\n        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n            int x = rect.x1;\n            int y = rect.y1;\n            int w = rect.x2 - x;\n            int h = rect.y2 - y;\n\t    int rectsPerRow, rows;\n            /* We need to count the number of rects in the scaled screen */\n            if (cl->screen!=cl->scaledScreen)\n                rfbScaledCorrection(cl->screen, cl->scaledScreen, &x, &y, &w, &h, \"rfbSendFramebufferUpdate\");\n\t    rectsPerRow = (w-1)/cl->correMaxWidth+1;\n\t    rows = (h-1)/cl->correMaxHeight+1;\n\t    nUpdateRegionRects += rectsPerRow*rows;\n        }\n\tsraRgnReleaseIterator(i); i=NULL;\n    } else if (cl->preferredEncoding == rfbEncodingUltra) {\n        nUpdateRegionRects = 0;\n        \n        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n            int x = rect.x1;\n            int y = rect.y1;\n            int w = rect.x2 - x;\n            int h = rect.y2 - y;\n            /* We need to count the number of rects in the scaled screen */\n            if (cl->screen!=cl->scaledScreen)\n                rfbScaledCorrection(cl->screen, cl->scaledScreen, &x, &y, &w, &h, \"rfbSendFramebufferUpdate\");\n            nUpdateRegionRects += (((h-1) / (ULTRA_MAX_SIZE( w ) / w)) + 1);\n          }\n        sraRgnReleaseIterator(i); i=NULL;\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n    } else if (cl->preferredEncoding == rfbEncodingZlib) {\n\tnUpdateRegionRects = 0;\n\n        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n            int x = rect.x1;\n            int y = rect.y1;\n            int w = rect.x2 - x;\n            int h = rect.y2 - y;\n            /* We need to count the number of rects in the scaled screen */\n            if (cl->screen!=cl->scaledScreen)\n                rfbScaledCorrection(cl->screen, cl->scaledScreen, &x, &y, &w, &h, \"rfbSendFramebufferUpdate\");\n\t    nUpdateRegionRects += (((h-1) / (ZLIB_MAX_SIZE( w ) / w)) + 1);\n\t}\n\tsraRgnReleaseIterator(i); i=NULL;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n    } else if (cl->preferredEncoding == rfbEncodingTight) {\n\tnUpdateRegionRects = 0;\n\n        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n            int x = rect.x1;\n            int y = rect.y1;\n            int w = rect.x2 - x;\n            int h = rect.y2 - y;\n            int n;\n            /* We need to count the number of rects in the scaled screen */\n            if (cl->screen!=cl->scaledScreen)\n                rfbScaledCorrection(cl->screen, cl->scaledScreen, &x, &y, &w, &h, \"rfbSendFramebufferUpdate\");\n\t    n = rfbNumCodedRectsTight(cl, x, y, w, h);\n\t    if (n == 0) {\n\t\tnUpdateRegionRects = 0xFFFF;\n\t\tbreak;\n\t    }\n\t    nUpdateRegionRects += n;\n\t}\n\tsraRgnReleaseIterator(i); i=NULL;\n#endif\n#endif\n#if defined(LIBVNCSERVER_HAVE_LIBJPEG) && defined(LIBVNCSERVER_HAVE_LIBPNG)\n    } else if (cl->preferredEncoding == rfbEncodingTightPng) {\n\tnUpdateRegionRects = 0;\n\n        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n            int x = rect.x1;\n            int y = rect.y1;\n            int w = rect.x2 - x;\n            int h = rect.y2 - y;\n            int n;\n            /* We need to count the number of rects in the scaled screen */\n            if (cl->screen!=cl->scaledScreen)\n                rfbScaledCorrection(cl->screen, cl->scaledScreen, &x, &y, &w, &h, \"rfbSendFramebufferUpdate\");\n\t    n = rfbNumCodedRectsTight(cl, x, y, w, h);\n\t    if (n == 0) {\n\t\tnUpdateRegionRects = 0xFFFF;\n\t\tbreak;\n\t    }\n\t    nUpdateRegionRects += n;\n\t}\n\tsraRgnReleaseIterator(i); i=NULL;\n#endif\n    } else {\n        nUpdateRegionRects = sraRgnCountRects(updateRegion);\n    }\n\n    fu->type = rfbFramebufferUpdate;\n    if (nUpdateRegionRects != 0xFFFF) {\n\tif(cl->screen->maxRectsPerUpdate>0\n\t   /* CoRRE splits the screen into smaller squares */\n\t   && cl->preferredEncoding != rfbEncodingCoRRE\n\t   /* Ultra encoding splits rectangles up into smaller chunks */\n           && cl->preferredEncoding != rfbEncodingUltra\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\t   /* Zlib encoding splits rectangles up into smaller chunks */\n\t   && cl->preferredEncoding != rfbEncodingZlib\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t   /* Tight encoding counts the rectangles differently */\n\t   && cl->preferredEncoding != rfbEncodingTight\n#endif\n#endif\n#ifdef LIBVNCSERVER_HAVE_LIBPNG\n\t   /* Tight encoding counts the rectangles differently */\n\t   && cl->preferredEncoding != rfbEncodingTightPng\n#endif\n\t   && nUpdateRegionRects>cl->screen->maxRectsPerUpdate) {\n\t    sraRegion* newUpdateRegion = sraRgnBBox(updateRegion);\n\t    sraRgnDestroy(updateRegion);\n\t    updateRegion = newUpdateRegion;\n\t    nUpdateRegionRects = sraRgnCountRects(updateRegion);\n\t}\n\tfu->nRects = Swap16IfLE((uint16_t)(sraRgnCountRects(updateCopyRegion) +\n\t\t\t\t\t   nUpdateRegionRects +\n\t\t\t\t\t   !!sendCursorShape + !!sendCursorPos + !!sendKeyboardLedState +\n\t\t\t\t\t   !!sendSupportedMessages + !!sendSupportedEncodings + !!sendServerIdentity));\n    } else {\n\tfu->nRects = 0xFFFF;\n    }\n    cl->ublen = sz_rfbFramebufferUpdateMsg;\n\n   if (sendCursorShape) {\n\tcl->cursorWasChanged = FALSE;\n\tif (!rfbSendCursorShape(cl))\n\t    goto updateFailed;\n    }\n   \n   if (sendCursorPos) {\n\tcl->cursorWasMoved = FALSE;\n\tif (!rfbSendCursorPos(cl))\n\t        goto updateFailed;\n   }\n   \n   if (sendKeyboardLedState) {\n       if (!rfbSendKeyboardLedState(cl))\n           goto updateFailed;\n   }\n\n   if (sendSupportedMessages) {\n       if (!rfbSendSupportedMessages(cl))\n           goto updateFailed;\n   }\n   if (sendSupportedEncodings) {\n       if (!rfbSendSupportedEncodings(cl))\n           goto updateFailed;\n   }\n   if (sendServerIdentity) {\n       if (!rfbSendServerIdentity(cl))\n           goto updateFailed;\n   }\n\n    if (!sraRgnEmpty(updateCopyRegion)) {\n\tif (!rfbSendCopyRegion(cl,updateCopyRegion,dx,dy))\n\t        goto updateFailed;\n    }\n\n    for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){\n        int x = rect.x1;\n        int y = rect.y1;\n        int w = rect.x2 - x;\n        int h = rect.y2 - y;\n\n        /* We need to count the number of rects in the scaled screen */\n        if (cl->screen!=cl->scaledScreen)\n            rfbScaledCorrection(cl->screen, cl->scaledScreen, &x, &y, &w, &h, \"rfbSendFramebufferUpdate\");\n\n        switch (cl->preferredEncoding) {\n\tcase -1:\n        case rfbEncodingRaw:\n            if (!rfbSendRectEncodingRaw(cl, x, y, w, h))\n\t        goto updateFailed;\n            break;\n        case rfbEncodingRRE:\n            if (!rfbSendRectEncodingRRE(cl, x, y, w, h))\n\t        goto updateFailed;\n            break;\n        case rfbEncodingCoRRE:\n            if (!rfbSendRectEncodingCoRRE(cl, x, y, w, h))\n\t        goto updateFailed;\n\t    break;\n        case rfbEncodingHextile:\n            if (!rfbSendRectEncodingHextile(cl, x, y, w, h))\n\t        goto updateFailed;\n            break;\n        case rfbEncodingUltra:\n            if (!rfbSendRectEncodingUltra(cl, x, y, w, h))\n                goto updateFailed;\n            break;\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\tcase rfbEncodingZlib:\n\t    if (!rfbSendRectEncodingZlib(cl, x, y, w, h))\n\t        goto updateFailed;\n\t    break;\n       case rfbEncodingZRLE:\n       case rfbEncodingZYWRLE:\n           if (!rfbSendRectEncodingZRLE(cl, x, y, w, h))\n\t       goto updateFailed;\n           break;\n#endif\n#if defined(LIBVNCSERVER_HAVE_LIBJPEG) && (defined(LIBVNCSERVER_HAVE_LIBZ) || defined(LIBVNCSERVER_HAVE_LIBPNG))\n\tcase rfbEncodingTight:\n\t    if (!rfbSendRectEncodingTight(cl, x, y, w, h))\n\t        goto updateFailed;\n\t    break;\n#ifdef LIBVNCSERVER_HAVE_LIBPNG\n\tcase rfbEncodingTightPng:\n\t    if (!rfbSendRectEncodingTightPng(cl, x, y, w, h))\n\t        goto updateFailed;\n\t    break;\n#endif\n#endif\n        }\n    }\n    if (i) {\n        sraRgnReleaseIterator(i);\n        i = NULL;\n    }\n\n    if ( nUpdateRegionRects == 0xFFFF &&\n\t !rfbSendLastRectMarker(cl) )\n\t    goto updateFailed;\n\n    if (!rfbSendUpdateBuf(cl)) {\nupdateFailed:\n\tresult = FALSE;\n    }\n\n    if (!cl->enableCursorShapeUpdates) {\n      rfbHideCursor(cl);\n    }\n\n    if(i)\n        sraRgnReleaseIterator(i);\n    sraRgnDestroy(updateRegion);\n    sraRgnDestroy(updateCopyRegion);\n\n    if(cl->screen->displayFinishedHook)\n      cl->screen->displayFinishedHook(cl, result);\n    return result;\n}\n\n\n/*\n * Send the copy region as a string of CopyRect encoded rectangles.\n * The only slightly tricky thing is that we should send the messages in\n * the correct order so that an earlier CopyRect will not corrupt the source\n * of a later one.\n */\n\nrfbBool\nrfbSendCopyRegion(rfbClientPtr cl,\n                  sraRegionPtr reg,\n                  int dx,\n                  int dy)\n{\n    int x, y, w, h;\n    rfbFramebufferUpdateRectHeader rect;\n    rfbCopyRect cr;\n    sraRectangleIterator* i;\n    sraRect rect1;\n\n    /* printf(\"copyrect: \"); sraRgnPrint(reg); putchar('\\n');fflush(stdout); */\n    i = sraRgnGetReverseIterator(reg,dx>0,dy>0);\n\n    /* correct for the scale of the screen */\n    dx = ScaleX(cl->screen, cl->scaledScreen, dx);\n    dy = ScaleX(cl->screen, cl->scaledScreen, dy);\n\n    while(sraRgnIteratorNext(i,&rect1)) {\n      x = rect1.x1;\n      y = rect1.y1;\n      w = rect1.x2 - x;\n      h = rect1.y2 - y;\n\n      /* correct for scaling (if necessary) */\n      rfbScaledCorrection(cl->screen, cl->scaledScreen, &x, &y, &w, &h, \"copyrect\");\n\n      rect.r.x = Swap16IfLE(x);\n      rect.r.y = Swap16IfLE(y);\n      rect.r.w = Swap16IfLE(w);\n      rect.r.h = Swap16IfLE(h);\n      rect.encoding = Swap32IfLE(rfbEncodingCopyRect);\n\n      memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,\n\t     sz_rfbFramebufferUpdateRectHeader);\n      cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n      cr.srcX = Swap16IfLE(x - dx);\n      cr.srcY = Swap16IfLE(y - dy);\n\n      memcpy(&cl->updateBuf[cl->ublen], (char *)&cr, sz_rfbCopyRect);\n      cl->ublen += sz_rfbCopyRect;\n\n      rfbStatRecordEncodingSent(cl, rfbEncodingCopyRect, sz_rfbFramebufferUpdateRectHeader + sz_rfbCopyRect,\n          w * h  * (cl->scaledScreen->bitsPerPixel / 8));\n    }\n    sraRgnReleaseIterator(i);\n\n    return TRUE;\n}\n\n/*\n * Send a given rectangle in raw encoding (rfbEncodingRaw).\n */\n\nrfbBool\nrfbSendRectEncodingRaw(rfbClientPtr cl,\n                       int x,\n                       int y,\n                       int w,\n                       int h)\n{\n    rfbFramebufferUpdateRectHeader rect;\n    int nlines;\n    int bytesPerLine = w * (cl->format.bitsPerPixel / 8);\n    char *fbptr = (cl->scaledScreen->frameBuffer + (cl->scaledScreen->paddedWidthInBytes * y)\n                   + (x * (cl->scaledScreen->bitsPerPixel / 8)));\n\n    /* Flush the buffer to guarantee correct alignment for translateFn(). */\n    if (cl->ublen > 0) {\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n    }\n\n    rect.r.x = Swap16IfLE(x);\n    rect.r.y = Swap16IfLE(y);\n    rect.r.w = Swap16IfLE(w);\n    rect.r.h = Swap16IfLE(h);\n    rect.encoding = Swap32IfLE(rfbEncodingRaw);\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,sz_rfbFramebufferUpdateRectHeader);\n    cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n\n    rfbStatRecordEncodingSent(cl, rfbEncodingRaw, sz_rfbFramebufferUpdateRectHeader + bytesPerLine * h,\n        sz_rfbFramebufferUpdateRectHeader + bytesPerLine * h);\n\n    nlines = (UPDATE_BUF_SIZE - cl->ublen) / bytesPerLine;\n\n    while (TRUE) {\n        if (nlines > h)\n            nlines = h;\n\n        (*cl->translateFn)(cl->translateLookupTable,\n\t\t\t   &(cl->screen->serverFormat),\n                           &cl->format, fbptr, &cl->updateBuf[cl->ublen],\n                           cl->scaledScreen->paddedWidthInBytes, w, nlines);\n\n        cl->ublen += nlines * bytesPerLine;\n        h -= nlines;\n\n        if (h == 0)     /* rect fitted in buffer, do next one */\n            return TRUE;\n\n        /* buffer full - flush partial rect and do another nlines */\n\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n\n        fbptr += (cl->scaledScreen->paddedWidthInBytes * nlines);\n\n        nlines = (UPDATE_BUF_SIZE - cl->ublen) / bytesPerLine;\n        if (nlines == 0) {\n            rfbErr(\"rfbSendRectEncodingRaw: send buffer too small for %d \"\n                   \"bytes per line\\n\", bytesPerLine);\n            rfbCloseClient(cl);\n            return FALSE;\n        }\n    }\n}\n\n\n\n/*\n * Send an empty rectangle with encoding field set to value of\n * rfbEncodingLastRect to notify client that this is the last\n * rectangle in framebuffer update (\"LastRect\" extension of RFB\n * protocol).\n */\n\nrfbBool\nrfbSendLastRectMarker(rfbClientPtr cl)\n{\n    rfbFramebufferUpdateRectHeader rect;\n\n    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader > UPDATE_BUF_SIZE) {\n\tif (!rfbSendUpdateBuf(cl))\n\t    return FALSE;\n    }\n\n    rect.encoding = Swap32IfLE(rfbEncodingLastRect);\n    rect.r.x = 0;\n    rect.r.y = 0;\n    rect.r.w = 0;\n    rect.r.h = 0;\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,sz_rfbFramebufferUpdateRectHeader);\n    cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n\n    rfbStatRecordEncodingSent(cl, rfbEncodingLastRect, sz_rfbFramebufferUpdateRectHeader, sz_rfbFramebufferUpdateRectHeader);\n\n    return TRUE;\n}\n\n\n/*\n * Send NewFBSize pseudo-rectangle. This tells the client to change\n * its framebuffer size.\n */\n\nrfbBool\nrfbSendNewFBSize(rfbClientPtr cl,\n                 int w,\n                 int h)\n{\n    rfbFramebufferUpdateRectHeader rect;\n\n    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader > UPDATE_BUF_SIZE) {\n\tif (!rfbSendUpdateBuf(cl))\n\t    return FALSE;\n    }\n\n    if (cl->PalmVNC==TRUE)\n        rfbLog(\"Sending rfbEncodingNewFBSize in response to a PalmVNC style framebuffer resize (%dx%d)\\n\", w, h);\n    else\n        rfbLog(\"Sending rfbEncodingNewFBSize for resize to (%dx%d)\\n\", w, h);\n\n    rect.encoding = Swap32IfLE(rfbEncodingNewFBSize);\n    rect.r.x = 0;\n    rect.r.y = 0;\n    rect.r.w = Swap16IfLE(w);\n    rect.r.h = Swap16IfLE(h);\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,\n           sz_rfbFramebufferUpdateRectHeader);\n    cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n    rfbStatRecordEncodingSent(cl, rfbEncodingNewFBSize, sz_rfbFramebufferUpdateRectHeader, sz_rfbFramebufferUpdateRectHeader);\n\n    return TRUE;\n}\n\n/*\n * Send ExtDesktopSize pseudo-rectangle. This message is used:\n * - to tell the client to change its framebuffer size\n * - at the start of the session to inform the client we support size changes through setDesktopSize\n * - in response to setDesktopSize commands to indicate success or failure\n */\n\nrfbBool\nrfbSendExtDesktopSize(rfbClientPtr cl,\n                 int w,\n                 int h)\n{\n    rfbFramebufferUpdateRectHeader rect;\n    rfbExtDesktopSizeMsg edsHdr;\n    rfbExtDesktopScreen eds;\n    int i;\n    char *logmsg;\n    int numScreens = cl->screen->numberOfExtDesktopScreensHook(cl);\n\n    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader\n            + sz_rfbExtDesktopSizeMsg\n            + sz_rfbExtDesktopScreen * numScreens > UPDATE_BUF_SIZE) {\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n    }\n\n    rect.encoding = Swap32IfLE(rfbEncodingExtDesktopSize);\n    rect.r.w = Swap16IfLE(w);\n    rect.r.h = Swap16IfLE(h);\n    rect.r.x = Swap16IfLE(cl->requestedDesktopSizeChange);\n    rect.r.y = Swap16IfLE(cl->lastDesktopSizeChangeError);\n\n    logmsg = \"\";\n\n    if (cl->requestedDesktopSizeChange == rfbExtDesktopSize_ClientRequestedChange)\n    {\n        /* our client requested the resize through setDesktopSize */\n\n        switch (cl->lastDesktopSizeChangeError)\n        {\n        case rfbExtDesktopSize_Success:\n            logmsg = \"resize successful\";\n            break;\n        case rfbExtDesktopSize_ResizeProhibited:\n            logmsg = \"resize prohibited\";\n            break;\n        case rfbExtDesktopSize_OutOfResources:\n            logmsg = \"resize failed: out of resources\";\n            break;\n        case rfbExtDesktopSize_InvalidScreenLayout:\n            logmsg = \"resize failed: invalid screen layout\";\n            break;\n        default:\n            break;\n        }\n    }\n\n    cl->requestedDesktopSizeChange = 0;\n    cl->lastDesktopSizeChangeError = 0;\n\n    rfbLog(\"Sending rfbEncodingExtDesktopSize for size (%dx%d) %s\\n\", w, h, logmsg);\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,\n           sz_rfbFramebufferUpdateRectHeader);\n    cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n    edsHdr.numberOfScreens = numScreens;\n    edsHdr.pad[0] = edsHdr.pad[1] = edsHdr.pad[2] = 0;\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&edsHdr,\n           sz_rfbExtDesktopSizeMsg);\n    cl->ublen += sz_rfbExtDesktopSizeMsg;\n\n    for (i=0; i<numScreens; i++) {\n        if (!cl->screen->getExtDesktopScreenHook(i, &eds, cl))\n        {\n            rfbErr(\"Error getting ExtendedDesktopSize information for screen #%d\\n\", i);\n            return FALSE;\n        }\n        eds.id = Swap32IfLE(eds.id);\n        eds.x = Swap16IfLE(eds.x);\n        eds.y = Swap16IfLE(eds.y);\n        eds.width = Swap16IfLE(eds.width);\n        eds.height = Swap16IfLE(eds.height);\n        eds.flags = Swap32IfLE(eds.flags);\n        memcpy(&cl->updateBuf[cl->ublen], (char *)&eds,\n               sz_rfbExtDesktopScreen);\n        cl->ublen += sz_rfbExtDesktopScreen;\n    }\n\n    rfbStatRecordEncodingSent(cl, rfbEncodingExtDesktopSize,\n                              sz_rfbFramebufferUpdateRectHeader + sz_rfbExtDesktopSizeMsg + sz_rfbExtDesktopScreen * numScreens,\n                              sz_rfbFramebufferUpdateRectHeader + sz_rfbExtDesktopSizeMsg + sz_rfbExtDesktopScreen * numScreens);\n\n    return TRUE;\n}\n\n/*\n * Send the contents of cl->updateBuf.  Returns 1 if successful, -1 if\n * not (errno should be set).\n */\n\nrfbBool\nrfbSendUpdateBuf(rfbClientPtr cl)\n{\n    if(cl->sock<0)\n      return FALSE;\n\n    if (rfbWriteExact(cl, cl->updateBuf, cl->ublen) < 0) {\n        rfbLogPerror(\"rfbSendUpdateBuf: write\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n\n    cl->ublen = 0;\n    return TRUE;\n}\n\n/*\n * rfbSendSetColourMapEntries sends a SetColourMapEntries message to the\n * client, using values from the currently installed colormap.\n */\n\nrfbBool\nrfbSendSetColourMapEntries(rfbClientPtr cl,\n                           int firstColour,\n                           int nColours)\n{\n    char buf[sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2];\n    char *wbuf = buf;\n    rfbSetColourMapEntriesMsg *scme;\n    uint16_t *rgb;\n    rfbColourMap* cm = &cl->screen->colourMap;\n    int i, len;\n\n    if (nColours > 256) {\n\t/* some rare hardware has, e.g., 4096 colors cells: PseudoColor:12 */\n    \twbuf = (char *) malloc(sz_rfbSetColourMapEntriesMsg + nColours * 3 * 2);\n    }\n\n    scme = (rfbSetColourMapEntriesMsg *)wbuf;\n    rgb = (uint16_t *)(&wbuf[sz_rfbSetColourMapEntriesMsg]);\n\n    scme->type = rfbSetColourMapEntries;\n\n    scme->firstColour = Swap16IfLE(firstColour);\n    scme->nColours = Swap16IfLE(nColours);\n\n    len = sz_rfbSetColourMapEntriesMsg;\n\n    for (i = 0; i < nColours; i++) {\n      if(i<(int)cm->count) {\n\tif(cm->is16) {\n\t  rgb[i*3] = Swap16IfLE(cm->data.shorts[i*3]);\n\t  rgb[i*3+1] = Swap16IfLE(cm->data.shorts[i*3+1]);\n\t  rgb[i*3+2] = Swap16IfLE(cm->data.shorts[i*3+2]);\n\t} else {\n\t  rgb[i*3] = Swap16IfLE((unsigned short)cm->data.bytes[i*3]);\n\t  rgb[i*3+1] = Swap16IfLE((unsigned short)cm->data.bytes[i*3+1]);\n\t  rgb[i*3+2] = Swap16IfLE((unsigned short)cm->data.bytes[i*3+2]);\n\t}\n      }\n    }\n\n    len += nColours * 3 * 2;\n\n    LOCK(cl->sendMutex);\n    if (rfbWriteExact(cl, wbuf, len) < 0) {\n\trfbLogPerror(\"rfbSendSetColourMapEntries: write\");\n\trfbCloseClient(cl);\n        if (wbuf != buf) free(wbuf);\n        UNLOCK(cl->sendMutex);\n\treturn FALSE;\n    }\n    UNLOCK(cl->sendMutex);\n\n    rfbStatRecordMessageSent(cl, rfbSetColourMapEntries, len, len);\n    if (wbuf != buf) free(wbuf);\n    return TRUE;\n}\n\n/*\n * rfbSendBell sends a Bell message to all the clients.\n */\n\nvoid\nrfbSendBell(rfbScreenInfoPtr rfbScreen)\n{\n    rfbClientIteratorPtr i;\n    rfbClientPtr cl;\n    rfbBellMsg b;\n\n    i = rfbGetClientIterator(rfbScreen);\n    while((cl=rfbClientIteratorNext(i))) {\n\tb.type = rfbBell;\n        LOCK(cl->sendMutex);\n\tif (rfbWriteExact(cl, (char *)&b, sz_rfbBellMsg) < 0) {\n\t    rfbLogPerror(\"rfbSendBell: write\");\n\t    rfbCloseClient(cl);\n\t}\n        UNLOCK(cl->sendMutex);\n    }\n    rfbStatRecordMessageSent(cl, rfbBell, sz_rfbBellMsg, sz_rfbBellMsg);\n    rfbReleaseClientIterator(i);\n}\n\n\n/*\n * rfbSendServerCutText sends a ServerCutText message to all the clients.\n */\n\nvoid\nrfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n\n    memset((char *)&sct, 0, sizeof(sct));\n\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        LOCK(cl->sendMutex);\n        if (rfbWriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            UNLOCK(cl->sendMutex);\n            continue;\n        }\n        if (rfbWriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n        UNLOCK(cl->sendMutex);\n        rfbStatRecordMessageSent(cl, rfbServerCutText, sz_rfbServerCutTextMsg+len, sz_rfbServerCutTextMsg+len);\n    }\n    rfbReleaseClientIterator(iterator);\n}\n\n/*****************************************************************************\n *\n * UDP can be used for keyboard and pointer events when the underlying\n * network is highly reliable.  This is really here to support ORL's\n * videotile, whose TCP implementation doesn't like sending lots of small\n * packets (such as 100s of pen readings per second!).\n */\n\nstatic unsigned char ptrAcceleration = 50;\n\nvoid\nrfbNewUDPConnection(rfbScreenInfoPtr rfbScreen,\n                    int sock)\n{\n  if (write(sock, (char*) &ptrAcceleration, 1) < 0) {\n\trfbLogPerror(\"rfbNewUDPConnection: write\");\n    }\n}\n\n/*\n * Because UDP is a message based service, we can't read the first byte and\n * then the rest of the packet separately like we do with TCP.  We will always\n * get a whole packet delivered in one go, so we ask read() for the maximum\n * number of bytes we can possibly get.\n */\n\nvoid\nrfbProcessUDPInput(rfbScreenInfoPtr rfbScreen)\n{\n    int n;\n    rfbClientPtr cl=rfbScreen->udpClient;\n    rfbClientToServerMsg msg;\n\n    if((!cl) || cl->onHold)\n      return;\n\n    if ((n = read(rfbScreen->udpSock, (char *)&msg, sizeof(msg))) <= 0) {\n\tif (n < 0) {\n\t    rfbLogPerror(\"rfbProcessUDPInput: read\");\n\t}\n\trfbDisconnectUDPSock(rfbScreen);\n\treturn;\n    }\n\n    switch (msg.type) {\n\n    case rfbKeyEvent:\n\tif (n != sz_rfbKeyEventMsg) {\n\t    rfbErr(\"rfbProcessUDPInput: key event incorrect length\\n\");\n\t    rfbDisconnectUDPSock(rfbScreen);\n\t    return;\n\t}\n\tcl->screen->kbdAddEvent(msg.ke.down, (rfbKeySym)Swap32IfLE(msg.ke.key), cl);\n\tbreak;\n\n    case rfbPointerEvent:\n\tif (n != sz_rfbPointerEventMsg) {\n\t    rfbErr(\"rfbProcessUDPInput: ptr event incorrect length\\n\");\n\t    rfbDisconnectUDPSock(rfbScreen);\n\t    return;\n\t}\n\tcl->screen->ptrAddEvent(msg.pe.buttonMask,\n\t\t    Swap16IfLE(msg.pe.x), Swap16IfLE(msg.pe.y), cl);\n\tbreak;\n\n    default:\n\trfbErr(\"rfbProcessUDPInput: unknown message type %d\\n\",\n\t       msg.type);\n\trfbDisconnectUDPSock(rfbScreen);\n    }\n}\n\n\n"], "filenames": ["libvncserver/rfbserver.c"], "buggy_code_start_loc": [3726], "buggy_code_end_loc": [3726], "fixing_code_start_loc": [3727], "fixing_code_end_loc": [3729], "type": "CWE-665", "message": "LibVNC commit before d01e1bb4246323ba6fcee3b82ef1faa9b1dac82a contains a memory leak (CWE-655) in VNC server code, which allow an attacker to read stack memory and can be abused for information disclosure. Combined with another vulnerability, it can be used to leak stack memory and bypass ASLR. This attack appear to be exploitable via network connectivity. These vulnerabilities have been fixed in commit d01e1bb4246323ba6fcee3b82ef1faa9b1dac82a.", "other": {"cve": {"id": "CVE-2019-15681", "sourceIdentifier": "vulnerability@kaspersky.com", "published": "2019-10-29T19:15:18.127", "lastModified": "2022-04-05T21:10:02.193", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "LibVNC commit before d01e1bb4246323ba6fcee3b82ef1faa9b1dac82a contains a memory leak (CWE-655) in VNC server code, which allow an attacker to read stack memory and can be abused for information disclosure. Combined with another vulnerability, it can be used to leak stack memory and bypass ASLR. This attack appear to be exploitable via network connectivity. These vulnerabilities have been fixed in commit d01e1bb4246323ba6fcee3b82ef1faa9b1dac82a."}, {"lang": "es", "value": "LibVNC en el commit anterior a d01e1bb4246323ba6fcee3b82ef1faa9b1dac82a, contiene una p\u00e9rdida de memoria (CWE-655) en el c\u00f3digo del servidor VNC, lo que permite a un atacante leer la memoria de la pila y puede ser abusada para la divulgaci\u00f3n de informaci\u00f3n. Combinada con otra vulnerabilidad, puede ser usada para filtrar la memoria de la pila y omitir el ASLR. Este ataque parece ser explotable por medio de la conectividad de la red. Estas vulnerabilidades han sido corregidas en el commit d01e1bb4246323ba6fcee3b82ef1faa9b1dac82a."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-665"}]}, {"source": "vulnerability@kaspersky.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-665"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libvnc_project:libvncserver:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.12", "matchCriteriaId": "DEF1BF44-78B8-44E3-9A5A-29AB8111322B"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1500_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "3A664216-EEA0-423F-8E11-59C746FDEEFE"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1500:-:*:*:*:*:*:*:*", "matchCriteriaId": "9596C8CD-B03F-4E9D-82AB-0986FDD1B47C"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1500_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "CD78291E-48D8-4718-AE14-BDF93BD557D7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1500_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "5BB898D3-07A3-42A1-8F1B-53C3B005982D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1900_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "AD1209DE-2724-493D-8276-1BE959BFE6BF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1900:-:*:*:*:*:*:*:*", "matchCriteriaId": "6A9143A6-A93A-45CA-8A1F-6EE30647B54A"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1900_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "92F7FC17-F19F-4BD6-9704-49B67D22B532"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1900_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "3D34BD13-4E71-48A2-851D-AE7CE2A03C28"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc2200_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "FE4A6F13-385B-4A13-B8D8-3BBC4E9D5B67"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc2200:-:*:*:*:*:*:*:*", "matchCriteriaId": "3E63E423-7450-4043-B33B-3FFF5BBE1CB2"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc2200_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "71A51CA4-1A62-47BC-99A3-4DC9F3986FF5"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc2200_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "CD278558-AB0E-4FC1-9E5B-6B57D29CB86A"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-05/msg00027.html", "source": "vulnerability@kaspersky.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00073.html", "source": "vulnerability@kaspersky.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-390195.pdf", "source": "vulnerability@kaspersky.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/LibVNC/libvncserver/commit/d01e1bb4246323ba6fcee3b82ef1faa9b1dac82a", "source": "vulnerability@kaspersky.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/10/msg00039.html", "source": "vulnerability@kaspersky.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/10/msg00042.html", "source": "vulnerability@kaspersky.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/11/msg00032.html", "source": "vulnerability@kaspersky.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/12/msg00028.html", "source": "vulnerability@kaspersky.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4407-1/", "source": "vulnerability@kaspersky.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4547-1/", "source": "vulnerability@kaspersky.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4573-1/", "source": "vulnerability@kaspersky.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4587-1/", "source": "vulnerability@kaspersky.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibVNC/libvncserver/commit/d01e1bb4246323ba6fcee3b82ef1faa9b1dac82a"}}