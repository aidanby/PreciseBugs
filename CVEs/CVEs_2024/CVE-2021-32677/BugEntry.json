{"buggy_code": ["import asyncio\nimport enum\nimport inspect\nimport json\nfrom typing import (\n    Any,\n    Callable,\n    Coroutine,\n    Dict,\n    List,\n    Optional,\n    Sequence,\n    Set,\n    Type,\n    Union,\n)\n\nfrom fastapi import params\nfrom fastapi.datastructures import Default, DefaultPlaceholder\nfrom fastapi.dependencies.models import Dependant\nfrom fastapi.dependencies.utils import (\n    get_body_field,\n    get_dependant,\n    get_parameterless_sub_dependant,\n    solve_dependencies,\n)\nfrom fastapi.encoders import DictIntStrAny, SetIntStr, jsonable_encoder\nfrom fastapi.exceptions import RequestValidationError, WebSocketRequestValidationError\nfrom fastapi.openapi.constants import STATUS_CODES_WITH_NO_BODY\nfrom fastapi.types import DecoratedCallable\nfrom fastapi.utils import (\n    create_cloned_field,\n    create_response_field,\n    generate_operation_id_for_path,\n    get_value_or_default,\n)\nfrom pydantic import BaseModel\nfrom pydantic.error_wrappers import ErrorWrapper, ValidationError\nfrom pydantic.fields import ModelField\nfrom starlette import routing\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse, Response\nfrom starlette.routing import BaseRoute\nfrom starlette.routing import Mount as Mount  # noqa\nfrom starlette.routing import (\n    compile_path,\n    get_name,\n    request_response,\n    websocket_session,\n)\nfrom starlette.status import WS_1008_POLICY_VIOLATION\nfrom starlette.types import ASGIApp\nfrom starlette.websockets import WebSocket\n\n\ndef _prepare_response_content(\n    res: Any,\n    *,\n    exclude_unset: bool,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -> Any:\n    if isinstance(res, BaseModel):\n        return res.dict(\n            by_alias=True,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n        )\n    elif isinstance(res, list):\n        return [\n            _prepare_response_content(\n                item,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=exclude_none,\n            )\n            for item in res\n        ]\n    elif isinstance(res, dict):\n        return {\n            k: _prepare_response_content(\n                v,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=exclude_none,\n            )\n            for k, v in res.items()\n        }\n    return res\n\n\nasync def serialize_response(\n    *,\n    field: Optional[ModelField] = None,\n    response_content: Any,\n    include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n    exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n    by_alias: bool = True,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    is_coroutine: bool = True,\n) -> Any:\n    if field:\n        errors = []\n        response_content = _prepare_response_content(\n            response_content,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n        )\n        if is_coroutine:\n            value, errors_ = field.validate(response_content, {}, loc=(\"response\",))\n        else:\n            value, errors_ = await run_in_threadpool(\n                field.validate, response_content, {}, loc=(\"response\",)\n            )\n        if isinstance(errors_, ErrorWrapper):\n            errors.append(errors_)\n        elif isinstance(errors_, list):\n            errors.extend(errors_)\n        if errors:\n            raise ValidationError(errors, field.type_)\n        return jsonable_encoder(\n            value,\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n        )\n    else:\n        return jsonable_encoder(response_content)\n\n\nasync def run_endpoint_function(\n    *, dependant: Dependant, values: Dict[str, Any], is_coroutine: bool\n) -> Any:\n    # Only called by get_request_handler. Has been split into its own function to\n    # facilitate profiling endpoints, since inner functions are harder to profile.\n    assert dependant.call is not None, \"dependant.call must be a function\"\n\n    if is_coroutine:\n        return await dependant.call(**values)\n    else:\n        return await run_in_threadpool(dependant.call, **values)\n\n\ndef get_request_handler(\n    dependant: Dependant,\n    body_field: Optional[ModelField] = None,\n    status_code: int = 200,\n    response_class: Union[Type[Response], DefaultPlaceholder] = Default(JSONResponse),\n    response_field: Optional[ModelField] = None,\n    response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n    response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n    response_model_by_alias: bool = True,\n    response_model_exclude_unset: bool = False,\n    response_model_exclude_defaults: bool = False,\n    response_model_exclude_none: bool = False,\n    dependency_overrides_provider: Optional[Any] = None,\n) -> Callable[[Request], Coroutine[Any, Any, Response]]:\n    assert dependant.call is not None, \"dependant.call must be a function\"\n    is_coroutine = asyncio.iscoroutinefunction(dependant.call)\n    is_body_form = body_field and isinstance(body_field.field_info, params.Form)\n    if isinstance(response_class, DefaultPlaceholder):\n        actual_response_class: Type[Response] = response_class.value\n    else:\n        actual_response_class = response_class\n\n    async def app(request: Request) -> Response:\n        try:\n            body = None\n            if body_field:\n                if is_body_form:\n                    body = await request.form()\n                else:\n                    body_bytes = await request.body()\n                    if body_bytes:\n                        body = await request.json()\n        except json.JSONDecodeError as e:\n            raise RequestValidationError([ErrorWrapper(e, (\"body\", e.pos))], body=e.doc)\n        except Exception as e:\n            raise HTTPException(\n                status_code=400, detail=\"There was an error parsing the body\"\n            ) from e\n        solved_result = await solve_dependencies(\n            request=request,\n            dependant=dependant,\n            body=body,\n            dependency_overrides_provider=dependency_overrides_provider,\n        )\n        values, errors, background_tasks, sub_response, _ = solved_result\n        if errors:\n            raise RequestValidationError(errors, body=body)\n        else:\n            raw_response = await run_endpoint_function(\n                dependant=dependant, values=values, is_coroutine=is_coroutine\n            )\n\n            if isinstance(raw_response, Response):\n                if raw_response.background is None:\n                    raw_response.background = background_tasks\n                return raw_response\n            response_data = await serialize_response(\n                field=response_field,\n                response_content=raw_response,\n                include=response_model_include,\n                exclude=response_model_exclude,\n                by_alias=response_model_by_alias,\n                exclude_unset=response_model_exclude_unset,\n                exclude_defaults=response_model_exclude_defaults,\n                exclude_none=response_model_exclude_none,\n                is_coroutine=is_coroutine,\n            )\n            response = actual_response_class(\n                content=response_data,\n                status_code=status_code,\n                background=background_tasks,  # type: ignore # in Starlette\n            )\n            response.headers.raw.extend(sub_response.headers.raw)\n            if sub_response.status_code:\n                response.status_code = sub_response.status_code\n            return response\n\n    return app\n\n\ndef get_websocket_app(\n    dependant: Dependant, dependency_overrides_provider: Optional[Any] = None\n) -> Callable[[WebSocket], Coroutine[Any, Any, Any]]:\n    async def app(websocket: WebSocket) -> None:\n        solved_result = await solve_dependencies(\n            request=websocket,\n            dependant=dependant,\n            dependency_overrides_provider=dependency_overrides_provider,\n        )\n        values, errors, _, _2, _3 = solved_result\n        if errors:\n            await websocket.close(code=WS_1008_POLICY_VIOLATION)\n            raise WebSocketRequestValidationError(errors)\n        assert dependant.call is not None, \"dependant.call must be a function\"\n        await dependant.call(**values)\n\n    return app\n\n\nclass APIWebSocketRoute(routing.WebSocketRoute):\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable[..., Any],\n        *,\n        name: Optional[str] = None,\n        dependency_overrides_provider: Optional[Any] = None,\n    ) -> None:\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n        self.dependant = get_dependant(path=path, call=self.endpoint)\n        self.app = websocket_session(\n            get_websocket_app(\n                dependant=self.dependant,\n                dependency_overrides_provider=dependency_overrides_provider,\n            )\n        )\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n\n\nclass APIRoute(routing.Route):\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable[..., Any],\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: int = 200,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        name: Optional[str] = None,\n        methods: Optional[Union[Set[str], List[str]]] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Union[Type[Response], DefaultPlaceholder] = Default(\n            JSONResponse\n        ),\n        dependency_overrides_provider: Optional[Any] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n    ) -> None:\n        # normalise enums e.g. http.HTTPStatus\n        if isinstance(status_code, enum.IntEnum):\n            status_code = int(status_code)\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n        if methods is None:\n            methods = [\"GET\"]\n        self.methods: Set[str] = set([method.upper() for method in methods])\n        self.unique_id = generate_operation_id_for_path(\n            name=self.name, path=self.path_format, method=list(methods)[0]\n        )\n        self.response_model = response_model\n        if self.response_model:\n            assert (\n                status_code not in STATUS_CODES_WITH_NO_BODY\n            ), f\"Status code {status_code} must not have a response body\"\n            response_name = \"Response_\" + self.unique_id\n            self.response_field = create_response_field(\n                name=response_name, type_=self.response_model\n            )\n            # Create a clone of the field, so that a Pydantic submodel is not returned\n            # as is just because it's an instance of a subclass of a more limited class\n            # e.g. UserInDB (containing hashed_password) could be a subclass of User\n            # that doesn't have the hashed_password. But because it's a subclass, it\n            # would pass the validation and be returned as is.\n            # By being a new field, no inheritance will be passed as is. A new model\n            # will be always created.\n            self.secure_cloned_response_field: Optional[\n                ModelField\n            ] = create_cloned_field(self.response_field)\n        else:\n            self.response_field = None  # type: ignore\n            self.secure_cloned_response_field = None\n        self.status_code = status_code\n        self.tags = tags or []\n        if dependencies:\n            self.dependencies = list(dependencies)\n        else:\n            self.dependencies = []\n        self.summary = summary\n        self.description = description or inspect.cleandoc(self.endpoint.__doc__ or \"\")\n        # if a \"form feed\" character (page break) is found in the description text,\n        # truncate description text to the content preceding the first \"form feed\"\n        self.description = self.description.split(\"\\f\")[0]\n        self.response_description = response_description\n        self.responses = responses or {}\n        response_fields = {}\n        for additional_status_code, response in self.responses.items():\n            assert isinstance(response, dict), \"An additional response must be a dict\"\n            model = response.get(\"model\")\n            if model:\n                assert (\n                    additional_status_code not in STATUS_CODES_WITH_NO_BODY\n                ), f\"Status code {additional_status_code} must not have a response body\"\n                response_name = f\"Response_{additional_status_code}_{self.unique_id}\"\n                response_field = create_response_field(name=response_name, type_=model)\n                response_fields[additional_status_code] = response_field\n        if response_fields:\n            self.response_fields: Dict[Union[int, str], ModelField] = response_fields\n        else:\n            self.response_fields = {}\n        self.deprecated = deprecated\n        self.operation_id = operation_id\n        self.response_model_include = response_model_include\n        self.response_model_exclude = response_model_exclude\n        self.response_model_by_alias = response_model_by_alias\n        self.response_model_exclude_unset = response_model_exclude_unset\n        self.response_model_exclude_defaults = response_model_exclude_defaults\n        self.response_model_exclude_none = response_model_exclude_none\n        self.include_in_schema = include_in_schema\n        self.response_class = response_class\n\n        assert callable(endpoint), \"An endpoint must be a callable\"\n        self.dependant = get_dependant(path=self.path_format, call=self.endpoint)\n        for depends in self.dependencies[::-1]:\n            self.dependant.dependencies.insert(\n                0,\n                get_parameterless_sub_dependant(depends=depends, path=self.path_format),\n            )\n        self.body_field = get_body_field(dependant=self.dependant, name=self.unique_id)\n        self.dependency_overrides_provider = dependency_overrides_provider\n        self.callbacks = callbacks\n        self.app = request_response(self.get_route_handler())\n\n    def get_route_handler(self) -> Callable[[Request], Coroutine[Any, Any, Response]]:\n        return get_request_handler(\n            dependant=self.dependant,\n            body_field=self.body_field,\n            status_code=self.status_code,\n            response_class=self.response_class,\n            response_field=self.secure_cloned_response_field,\n            response_model_include=self.response_model_include,\n            response_model_exclude=self.response_model_exclude,\n            response_model_by_alias=self.response_model_by_alias,\n            response_model_exclude_unset=self.response_model_exclude_unset,\n            response_model_exclude_defaults=self.response_model_exclude_defaults,\n            response_model_exclude_none=self.response_model_exclude_none,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n        )\n\n\nclass APIRouter(routing.Router):\n    def __init__(\n        self,\n        *,\n        prefix: str = \"\",\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        default_response_class: Type[Response] = Default(JSONResponse),\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        routes: Optional[List[routing.BaseRoute]] = None,\n        redirect_slashes: bool = True,\n        default: Optional[ASGIApp] = None,\n        dependency_overrides_provider: Optional[Any] = None,\n        route_class: Type[APIRoute] = APIRoute,\n        on_startup: Optional[Sequence[Callable[[], Any]]] = None,\n        on_shutdown: Optional[Sequence[Callable[[], Any]]] = None,\n        deprecated: Optional[bool] = None,\n        include_in_schema: bool = True,\n    ) -> None:\n        super().__init__(\n            routes=routes,  # type: ignore # in Starlette\n            redirect_slashes=redirect_slashes,\n            default=default,  # type: ignore # in Starlette\n            on_startup=on_startup,  # type: ignore # in Starlette\n            on_shutdown=on_shutdown,  # type: ignore # in Starlette\n        )\n        if prefix:\n            assert prefix.startswith(\"/\"), \"A path prefix must start with '/'\"\n            assert not prefix.endswith(\n                \"/\"\n            ), \"A path prefix must not end with '/', as the routes will start with '/'\"\n        self.prefix = prefix\n        self.tags: List[str] = tags or []\n        self.dependencies = list(dependencies or []) or []\n        self.deprecated = deprecated\n        self.include_in_schema = include_in_schema\n        self.responses = responses or {}\n        self.callbacks = callbacks or []\n        self.dependency_overrides_provider = dependency_overrides_provider\n        self.route_class = route_class\n        self.default_response_class = default_response_class\n\n    def add_api_route(\n        self,\n        path: str,\n        endpoint: Callable[..., Any],\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: int = 200,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        methods: Optional[Union[Set[str], List[str]]] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Union[Type[Response], DefaultPlaceholder] = Default(\n            JSONResponse\n        ),\n        name: Optional[str] = None,\n        route_class_override: Optional[Type[APIRoute]] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n    ) -> None:\n        route_class = route_class_override or self.route_class\n        responses = responses or {}\n        combined_responses = {**self.responses, **responses}\n        current_response_class = get_value_or_default(\n            response_class, self.default_response_class\n        )\n        current_tags = self.tags.copy()\n        if tags:\n            current_tags.extend(tags)\n        current_dependencies = self.dependencies.copy()\n        if dependencies:\n            current_dependencies.extend(dependencies)\n        current_callbacks = self.callbacks.copy()\n        if callbacks:\n            current_callbacks.extend(callbacks)\n        route = route_class(\n            self.prefix + path,\n            endpoint=endpoint,\n            response_model=response_model,\n            status_code=status_code,\n            tags=current_tags,\n            dependencies=current_dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=combined_responses,\n            deprecated=deprecated or self.deprecated,\n            methods=methods,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema and self.include_in_schema,\n            response_class=current_response_class,\n            name=name,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n            callbacks=current_callbacks,\n        )\n        self.routes.append(route)\n\n    def api_route(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: int = 200,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        methods: Optional[List[str]] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags,\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses,\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_exclude_unset=response_model_exclude_unset,\n                response_model_exclude_defaults=response_model_exclude_defaults,\n                response_model_exclude_none=response_model_exclude_none,\n                include_in_schema=include_in_schema,\n                response_class=response_class,\n                name=name,\n                callbacks=callbacks,\n            )\n            return func\n\n        return decorator\n\n    def add_api_websocket_route(\n        self, path: str, endpoint: Callable[..., Any], name: Optional[str] = None\n    ) -> None:\n        route = APIWebSocketRoute(\n            path,\n            endpoint=endpoint,\n            name=name,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n        )\n        self.routes.append(route)\n\n    def websocket(\n        self, path: str, name: Optional[str] = None\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_api_websocket_route(path, func, name=name)\n            return func\n\n        return decorator\n\n    def include_router(\n        self,\n        router: \"APIRouter\",\n        *,\n        prefix: str = \"\",\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        default_response_class: Type[Response] = Default(JSONResponse),\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        deprecated: Optional[bool] = None,\n        include_in_schema: bool = True,\n    ) -> None:\n        if prefix:\n            assert prefix.startswith(\"/\"), \"A path prefix must start with '/'\"\n            assert not prefix.endswith(\n                \"/\"\n            ), \"A path prefix must not end with '/', as the routes will start with '/'\"\n        else:\n            for r in router.routes:\n                path = getattr(r, \"path\")\n                name = getattr(r, \"name\", \"unknown\")\n                if path is not None and not path:\n                    raise Exception(\n                        f\"Prefix and path cannot be both empty (path operation: {name})\"\n                    )\n        if responses is None:\n            responses = {}\n        for route in router.routes:\n            if isinstance(route, APIRoute):\n                combined_responses = {**responses, **route.responses}\n                use_response_class = get_value_or_default(\n                    route.response_class,\n                    router.default_response_class,\n                    default_response_class,\n                    self.default_response_class,\n                )\n                current_tags = []\n                if tags:\n                    current_tags.extend(tags)\n                if route.tags:\n                    current_tags.extend(route.tags)\n                current_dependencies: List[params.Depends] = []\n                if dependencies:\n                    current_dependencies.extend(dependencies)\n                if route.dependencies:\n                    current_dependencies.extend(route.dependencies)\n                current_callbacks = []\n                if callbacks:\n                    current_callbacks.extend(callbacks)\n                if route.callbacks:\n                    current_callbacks.extend(route.callbacks)\n                self.add_api_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    response_model=route.response_model,\n                    status_code=route.status_code,\n                    tags=current_tags,\n                    dependencies=current_dependencies,\n                    summary=route.summary,\n                    description=route.description,\n                    response_description=route.response_description,\n                    responses=combined_responses,\n                    deprecated=route.deprecated or deprecated or self.deprecated,\n                    methods=route.methods,\n                    operation_id=route.operation_id,\n                    response_model_include=route.response_model_include,\n                    response_model_exclude=route.response_model_exclude,\n                    response_model_by_alias=route.response_model_by_alias,\n                    response_model_exclude_unset=route.response_model_exclude_unset,\n                    response_model_exclude_defaults=route.response_model_exclude_defaults,\n                    response_model_exclude_none=route.response_model_exclude_none,\n                    include_in_schema=route.include_in_schema\n                    and self.include_in_schema\n                    and include_in_schema,\n                    response_class=use_response_class,\n                    name=route.name,\n                    route_class_override=type(route),\n                    callbacks=current_callbacks,\n                )\n            elif isinstance(route, routing.Route):\n                methods = list(route.methods or [])  # type: ignore # in Starlette\n                self.add_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    methods=methods,\n                    include_in_schema=route.include_in_schema,\n                    name=route.name,\n                )\n            elif isinstance(route, APIWebSocketRoute):\n                self.add_api_websocket_route(\n                    prefix + route.path, route.endpoint, name=route.name\n                )\n            elif isinstance(route, routing.WebSocketRoute):\n                self.add_websocket_route(\n                    prefix + route.path, route.endpoint, name=route.name\n                )\n        for handler in router.on_startup:\n            self.add_event_handler(\"startup\", handler)\n        for handler in router.on_shutdown:\n            self.add_event_handler(\"shutdown\", handler)\n\n    def get(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: int = 200,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"GET\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def put(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: int = 200,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"PUT\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def post(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: int = 200,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"POST\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def delete(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: int = 200,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"DELETE\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def options(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: int = 200,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"OPTIONS\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def head(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: int = 200,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"HEAD\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def patch(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: int = 200,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"PATCH\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def trace(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: int = 200,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"TRACE\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n", "from unittest.mock import patch\n\nimport pytest\nfrom fastapi.testclient import TestClient\n\nfrom docs_src.body.tutorial001 import app\n\nclient = TestClient(app)\n\nopenapi_schema = {\n    \"openapi\": \"3.0.2\",\n    \"info\": {\"title\": \"FastAPI\", \"version\": \"0.1.0\"},\n    \"paths\": {\n        \"/items/\": {\n            \"post\": {\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n                \"summary\": \"Create Item\",\n                \"operationId\": \"create_item_items__post\",\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\"$ref\": \"#/components/schemas/Item\"}\n                        }\n                    },\n                    \"required\": True,\n                },\n            }\n        }\n    },\n    \"components\": {\n        \"schemas\": {\n            \"Item\": {\n                \"title\": \"Item\",\n                \"required\": [\"name\", \"price\"],\n                \"type\": \"object\",\n                \"properties\": {\n                    \"name\": {\"title\": \"Name\", \"type\": \"string\"},\n                    \"price\": {\"title\": \"Price\", \"type\": \"number\"},\n                    \"description\": {\"title\": \"Description\", \"type\": \"string\"},\n                    \"tax\": {\"title\": \"Tax\", \"type\": \"number\"},\n                },\n            },\n            \"ValidationError\": {\n                \"title\": \"ValidationError\",\n                \"required\": [\"loc\", \"msg\", \"type\"],\n                \"type\": \"object\",\n                \"properties\": {\n                    \"loc\": {\n                        \"title\": \"Location\",\n                        \"type\": \"array\",\n                        \"items\": {\"type\": \"string\"},\n                    },\n                    \"msg\": {\"title\": \"Message\", \"type\": \"string\"},\n                    \"type\": {\"title\": \"Error Type\", \"type\": \"string\"},\n                },\n            },\n            \"HTTPValidationError\": {\n                \"title\": \"HTTPValidationError\",\n                \"type\": \"object\",\n                \"properties\": {\n                    \"detail\": {\n                        \"title\": \"Detail\",\n                        \"type\": \"array\",\n                        \"items\": {\"$ref\": \"#/components/schemas/ValidationError\"},\n                    }\n                },\n            },\n        }\n    },\n}\n\n\ndef test_openapi_schema():\n    response = client.get(\"/openapi.json\")\n    assert response.status_code == 200, response.text\n    assert response.json() == openapi_schema\n\n\nprice_missing = {\n    \"detail\": [\n        {\n            \"loc\": [\"body\", \"price\"],\n            \"msg\": \"field required\",\n            \"type\": \"value_error.missing\",\n        }\n    ]\n}\n\nprice_not_float = {\n    \"detail\": [\n        {\n            \"loc\": [\"body\", \"price\"],\n            \"msg\": \"value is not a valid float\",\n            \"type\": \"type_error.float\",\n        }\n    ]\n}\n\nname_price_missing = {\n    \"detail\": [\n        {\n            \"loc\": [\"body\", \"name\"],\n            \"msg\": \"field required\",\n            \"type\": \"value_error.missing\",\n        },\n        {\n            \"loc\": [\"body\", \"price\"],\n            \"msg\": \"field required\",\n            \"type\": \"value_error.missing\",\n        },\n    ]\n}\n\nbody_missing = {\n    \"detail\": [\n        {\"loc\": [\"body\"], \"msg\": \"field required\", \"type\": \"value_error.missing\"}\n    ]\n}\n\n\n@pytest.mark.parametrize(\n    \"path,body,expected_status,expected_response\",\n    [\n        (\n            \"/items/\",\n            {\"name\": \"Foo\", \"price\": 50.5},\n            200,\n            {\"name\": \"Foo\", \"price\": 50.5, \"description\": None, \"tax\": None},\n        ),\n        (\n            \"/items/\",\n            {\"name\": \"Foo\", \"price\": \"50.5\"},\n            200,\n            {\"name\": \"Foo\", \"price\": 50.5, \"description\": None, \"tax\": None},\n        ),\n        (\n            \"/items/\",\n            {\"name\": \"Foo\", \"price\": \"50.5\", \"description\": \"Some Foo\"},\n            200,\n            {\"name\": \"Foo\", \"price\": 50.5, \"description\": \"Some Foo\", \"tax\": None},\n        ),\n        (\n            \"/items/\",\n            {\"name\": \"Foo\", \"price\": \"50.5\", \"description\": \"Some Foo\", \"tax\": 0.3},\n            200,\n            {\"name\": \"Foo\", \"price\": 50.5, \"description\": \"Some Foo\", \"tax\": 0.3},\n        ),\n        (\"/items/\", {\"name\": \"Foo\"}, 422, price_missing),\n        (\"/items/\", {\"name\": \"Foo\", \"price\": \"twenty\"}, 422, price_not_float),\n        (\"/items/\", {}, 422, name_price_missing),\n        (\"/items/\", None, 422, body_missing),\n    ],\n)\ndef test_post_body(path, body, expected_status, expected_response):\n    response = client.post(path, json=body)\n    assert response.status_code == expected_status\n    assert response.json() == expected_response\n\n\ndef test_post_broken_body():\n    response = client.post(\"/items/\", data={\"name\": \"Foo\", \"price\": 50.5})\n    assert response.status_code == 422, response.text\n    assert response.json() == {\n        \"detail\": [\n            {\n                \"ctx\": {\n                    \"colno\": 1,\n                    \"doc\": \"name=Foo&price=50.5\",\n                    \"lineno\": 1,\n                    \"msg\": \"Expecting value\",\n                    \"pos\": 0,\n                },\n                \"loc\": [\"body\", 0],\n                \"msg\": \"Expecting value: line 1 column 1 (char 0)\",\n                \"type\": \"value_error.jsondecode\",\n            }\n        ]\n    }\n    with patch(\"json.loads\", side_effect=Exception):\n        response = client.post(\"/items/\", json={\"test\": \"test2\"})\n        assert response.status_code == 400, response.text\n    assert response.json() == {\"detail\": \"There was an error parsing the body\"}\n", "import gzip\nimport json\n\nimport pytest\nfrom fastapi import Request\nfrom fastapi.testclient import TestClient\n\nfrom docs_src.custom_request_and_route.tutorial001 import app\n\n\n@app.get(\"/check-class\")\nasync def check_gzip_request(request: Request):\n    return {\"request_class\": type(request).__name__}\n\n\nclient = TestClient(app)\n\n\n@pytest.mark.parametrize(\"compress\", [True, False])\ndef test_gzip_request(compress):\n    n = 1000\n    headers = {}\n    body = [1] * n\n    data = json.dumps(body).encode()\n    if compress:\n        data = gzip.compress(data)\n        headers[\"Content-Encoding\"] = \"gzip\"\n    response = client.post(\"/sum\", data=data, headers=headers)\n    assert response.json() == {\"sum\": n}\n\n\ndef test_request_class():\n    response = client.get(\"/check-class\")\n    assert response.json() == {\"request_class\": \"GzipRequest\"}\n"], "fixing_code": ["import asyncio\nimport email.message\nimport enum\nimport inspect\nimport json\nfrom typing import (\n    Any,\n    Callable,\n    Coroutine,\n    Dict,\n    List,\n    Optional,\n    Sequence,\n    Set,\n    Type,\n    Union,\n)\n\nfrom fastapi import params\nfrom fastapi.datastructures import Default, DefaultPlaceholder\nfrom fastapi.dependencies.models import Dependant\nfrom fastapi.dependencies.utils import (\n    get_body_field,\n    get_dependant,\n    get_parameterless_sub_dependant,\n    solve_dependencies,\n)\nfrom fastapi.encoders import DictIntStrAny, SetIntStr, jsonable_encoder\nfrom fastapi.exceptions import RequestValidationError, WebSocketRequestValidationError\nfrom fastapi.openapi.constants import STATUS_CODES_WITH_NO_BODY\nfrom fastapi.types import DecoratedCallable\nfrom fastapi.utils import (\n    create_cloned_field,\n    create_response_field,\n    generate_operation_id_for_path,\n    get_value_or_default,\n)\nfrom pydantic import BaseModel\nfrom pydantic.error_wrappers import ErrorWrapper, ValidationError\nfrom pydantic.fields import ModelField, Undefined\nfrom starlette import routing\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse, Response\nfrom starlette.routing import BaseRoute\nfrom starlette.routing import Mount as Mount  # noqa\nfrom starlette.routing import (\n    compile_path,\n    get_name,\n    request_response,\n    websocket_session,\n)\nfrom starlette.status import WS_1008_POLICY_VIOLATION\nfrom starlette.types import ASGIApp\nfrom starlette.websockets import WebSocket\n\n\ndef _prepare_response_content(\n    res: Any,\n    *,\n    exclude_unset: bool,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -> Any:\n    if isinstance(res, BaseModel):\n        return res.dict(\n            by_alias=True,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n        )\n    elif isinstance(res, list):\n        return [\n            _prepare_response_content(\n                item,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=exclude_none,\n            )\n            for item in res\n        ]\n    elif isinstance(res, dict):\n        return {\n            k: _prepare_response_content(\n                v,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=exclude_none,\n            )\n            for k, v in res.items()\n        }\n    return res\n\n\nasync def serialize_response(\n    *,\n    field: Optional[ModelField] = None,\n    response_content: Any,\n    include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n    exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n    by_alias: bool = True,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    is_coroutine: bool = True,\n) -> Any:\n    if field:\n        errors = []\n        response_content = _prepare_response_content(\n            response_content,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n        )\n        if is_coroutine:\n            value, errors_ = field.validate(response_content, {}, loc=(\"response\",))\n        else:\n            value, errors_ = await run_in_threadpool(\n                field.validate, response_content, {}, loc=(\"response\",)\n            )\n        if isinstance(errors_, ErrorWrapper):\n            errors.append(errors_)\n        elif isinstance(errors_, list):\n            errors.extend(errors_)\n        if errors:\n            raise ValidationError(errors, field.type_)\n        return jsonable_encoder(\n            value,\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n        )\n    else:\n        return jsonable_encoder(response_content)\n\n\nasync def run_endpoint_function(\n    *, dependant: Dependant, values: Dict[str, Any], is_coroutine: bool\n) -> Any:\n    # Only called by get_request_handler. Has been split into its own function to\n    # facilitate profiling endpoints, since inner functions are harder to profile.\n    assert dependant.call is not None, \"dependant.call must be a function\"\n\n    if is_coroutine:\n        return await dependant.call(**values)\n    else:\n        return await run_in_threadpool(dependant.call, **values)\n\n\ndef get_request_handler(\n    dependant: Dependant,\n    body_field: Optional[ModelField] = None,\n    status_code: int = 200,\n    response_class: Union[Type[Response], DefaultPlaceholder] = Default(JSONResponse),\n    response_field: Optional[ModelField] = None,\n    response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n    response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n    response_model_by_alias: bool = True,\n    response_model_exclude_unset: bool = False,\n    response_model_exclude_defaults: bool = False,\n    response_model_exclude_none: bool = False,\n    dependency_overrides_provider: Optional[Any] = None,\n) -> Callable[[Request], Coroutine[Any, Any, Response]]:\n    assert dependant.call is not None, \"dependant.call must be a function\"\n    is_coroutine = asyncio.iscoroutinefunction(dependant.call)\n    is_body_form = body_field and isinstance(body_field.field_info, params.Form)\n    if isinstance(response_class, DefaultPlaceholder):\n        actual_response_class: Type[Response] = response_class.value\n    else:\n        actual_response_class = response_class\n\n    async def app(request: Request) -> Response:\n        try:\n            body: Any = None\n            if body_field:\n                if is_body_form:\n                    body = await request.form()\n                else:\n                    body_bytes = await request.body()\n                    if body_bytes:\n                        json_body: Any = Undefined\n                        content_type_value = request.headers.get(\"content-type\")\n                        if content_type_value:\n                            message = email.message.Message()\n                            message[\"content-type\"] = content_type_value\n                            if message.get_content_maintype() == \"application\":\n                                subtype = message.get_content_subtype()\n                                if subtype == \"json\" or subtype.endswith(\"+json\"):\n                                    json_body = await request.json()\n                        if json_body != Undefined:\n                            body = json_body\n                        else:\n                            body = body_bytes\n        except json.JSONDecodeError as e:\n            raise RequestValidationError([ErrorWrapper(e, (\"body\", e.pos))], body=e.doc)\n        except Exception as e:\n            raise HTTPException(\n                status_code=400, detail=\"There was an error parsing the body\"\n            ) from e\n        solved_result = await solve_dependencies(\n            request=request,\n            dependant=dependant,\n            body=body,\n            dependency_overrides_provider=dependency_overrides_provider,\n        )\n        values, errors, background_tasks, sub_response, _ = solved_result\n        if errors:\n            raise RequestValidationError(errors, body=body)\n        else:\n            raw_response = await run_endpoint_function(\n                dependant=dependant, values=values, is_coroutine=is_coroutine\n            )\n\n            if isinstance(raw_response, Response):\n                if raw_response.background is None:\n                    raw_response.background = background_tasks\n                return raw_response\n            response_data = await serialize_response(\n                field=response_field,\n                response_content=raw_response,\n                include=response_model_include,\n                exclude=response_model_exclude,\n                by_alias=response_model_by_alias,\n                exclude_unset=response_model_exclude_unset,\n                exclude_defaults=response_model_exclude_defaults,\n                exclude_none=response_model_exclude_none,\n                is_coroutine=is_coroutine,\n            )\n            response = actual_response_class(\n                content=response_data,\n                status_code=status_code,\n                background=background_tasks,  # type: ignore # in Starlette\n            )\n            response.headers.raw.extend(sub_response.headers.raw)\n            if sub_response.status_code:\n                response.status_code = sub_response.status_code\n            return response\n\n    return app\n\n\ndef get_websocket_app(\n    dependant: Dependant, dependency_overrides_provider: Optional[Any] = None\n) -> Callable[[WebSocket], Coroutine[Any, Any, Any]]:\n    async def app(websocket: WebSocket) -> None:\n        solved_result = await solve_dependencies(\n            request=websocket,\n            dependant=dependant,\n            dependency_overrides_provider=dependency_overrides_provider,\n        )\n        values, errors, _, _2, _3 = solved_result\n        if errors:\n            await websocket.close(code=WS_1008_POLICY_VIOLATION)\n            raise WebSocketRequestValidationError(errors)\n        assert dependant.call is not None, \"dependant.call must be a function\"\n        await dependant.call(**values)\n\n    return app\n\n\nclass APIWebSocketRoute(routing.WebSocketRoute):\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable[..., Any],\n        *,\n        name: Optional[str] = None,\n        dependency_overrides_provider: Optional[Any] = None,\n    ) -> None:\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n        self.dependant = get_dependant(path=path, call=self.endpoint)\n        self.app = websocket_session(\n            get_websocket_app(\n                dependant=self.dependant,\n                dependency_overrides_provider=dependency_overrides_provider,\n            )\n        )\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n\n\nclass APIRoute(routing.Route):\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable[..., Any],\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: int = 200,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        name: Optional[str] = None,\n        methods: Optional[Union[Set[str], List[str]]] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Union[Type[Response], DefaultPlaceholder] = Default(\n            JSONResponse\n        ),\n        dependency_overrides_provider: Optional[Any] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n    ) -> None:\n        # normalise enums e.g. http.HTTPStatus\n        if isinstance(status_code, enum.IntEnum):\n            status_code = int(status_code)\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n        if methods is None:\n            methods = [\"GET\"]\n        self.methods: Set[str] = set([method.upper() for method in methods])\n        self.unique_id = generate_operation_id_for_path(\n            name=self.name, path=self.path_format, method=list(methods)[0]\n        )\n        self.response_model = response_model\n        if self.response_model:\n            assert (\n                status_code not in STATUS_CODES_WITH_NO_BODY\n            ), f\"Status code {status_code} must not have a response body\"\n            response_name = \"Response_\" + self.unique_id\n            self.response_field = create_response_field(\n                name=response_name, type_=self.response_model\n            )\n            # Create a clone of the field, so that a Pydantic submodel is not returned\n            # as is just because it's an instance of a subclass of a more limited class\n            # e.g. UserInDB (containing hashed_password) could be a subclass of User\n            # that doesn't have the hashed_password. But because it's a subclass, it\n            # would pass the validation and be returned as is.\n            # By being a new field, no inheritance will be passed as is. A new model\n            # will be always created.\n            self.secure_cloned_response_field: Optional[\n                ModelField\n            ] = create_cloned_field(self.response_field)\n        else:\n            self.response_field = None  # type: ignore\n            self.secure_cloned_response_field = None\n        self.status_code = status_code\n        self.tags = tags or []\n        if dependencies:\n            self.dependencies = list(dependencies)\n        else:\n            self.dependencies = []\n        self.summary = summary\n        self.description = description or inspect.cleandoc(self.endpoint.__doc__ or \"\")\n        # if a \"form feed\" character (page break) is found in the description text,\n        # truncate description text to the content preceding the first \"form feed\"\n        self.description = self.description.split(\"\\f\")[0]\n        self.response_description = response_description\n        self.responses = responses or {}\n        response_fields = {}\n        for additional_status_code, response in self.responses.items():\n            assert isinstance(response, dict), \"An additional response must be a dict\"\n            model = response.get(\"model\")\n            if model:\n                assert (\n                    additional_status_code not in STATUS_CODES_WITH_NO_BODY\n                ), f\"Status code {additional_status_code} must not have a response body\"\n                response_name = f\"Response_{additional_status_code}_{self.unique_id}\"\n                response_field = create_response_field(name=response_name, type_=model)\n                response_fields[additional_status_code] = response_field\n        if response_fields:\n            self.response_fields: Dict[Union[int, str], ModelField] = response_fields\n        else:\n            self.response_fields = {}\n        self.deprecated = deprecated\n        self.operation_id = operation_id\n        self.response_model_include = response_model_include\n        self.response_model_exclude = response_model_exclude\n        self.response_model_by_alias = response_model_by_alias\n        self.response_model_exclude_unset = response_model_exclude_unset\n        self.response_model_exclude_defaults = response_model_exclude_defaults\n        self.response_model_exclude_none = response_model_exclude_none\n        self.include_in_schema = include_in_schema\n        self.response_class = response_class\n\n        assert callable(endpoint), \"An endpoint must be a callable\"\n        self.dependant = get_dependant(path=self.path_format, call=self.endpoint)\n        for depends in self.dependencies[::-1]:\n            self.dependant.dependencies.insert(\n                0,\n                get_parameterless_sub_dependant(depends=depends, path=self.path_format),\n            )\n        self.body_field = get_body_field(dependant=self.dependant, name=self.unique_id)\n        self.dependency_overrides_provider = dependency_overrides_provider\n        self.callbacks = callbacks\n        self.app = request_response(self.get_route_handler())\n\n    def get_route_handler(self) -> Callable[[Request], Coroutine[Any, Any, Response]]:\n        return get_request_handler(\n            dependant=self.dependant,\n            body_field=self.body_field,\n            status_code=self.status_code,\n            response_class=self.response_class,\n            response_field=self.secure_cloned_response_field,\n            response_model_include=self.response_model_include,\n            response_model_exclude=self.response_model_exclude,\n            response_model_by_alias=self.response_model_by_alias,\n            response_model_exclude_unset=self.response_model_exclude_unset,\n            response_model_exclude_defaults=self.response_model_exclude_defaults,\n            response_model_exclude_none=self.response_model_exclude_none,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n        )\n\n\nclass APIRouter(routing.Router):\n    def __init__(\n        self,\n        *,\n        prefix: str = \"\",\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        default_response_class: Type[Response] = Default(JSONResponse),\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        routes: Optional[List[routing.BaseRoute]] = None,\n        redirect_slashes: bool = True,\n        default: Optional[ASGIApp] = None,\n        dependency_overrides_provider: Optional[Any] = None,\n        route_class: Type[APIRoute] = APIRoute,\n        on_startup: Optional[Sequence[Callable[[], Any]]] = None,\n        on_shutdown: Optional[Sequence[Callable[[], Any]]] = None,\n        deprecated: Optional[bool] = None,\n        include_in_schema: bool = True,\n    ) -> None:\n        super().__init__(\n            routes=routes,  # type: ignore # in Starlette\n            redirect_slashes=redirect_slashes,\n            default=default,  # type: ignore # in Starlette\n            on_startup=on_startup,  # type: ignore # in Starlette\n            on_shutdown=on_shutdown,  # type: ignore # in Starlette\n        )\n        if prefix:\n            assert prefix.startswith(\"/\"), \"A path prefix must start with '/'\"\n            assert not prefix.endswith(\n                \"/\"\n            ), \"A path prefix must not end with '/', as the routes will start with '/'\"\n        self.prefix = prefix\n        self.tags: List[str] = tags or []\n        self.dependencies = list(dependencies or []) or []\n        self.deprecated = deprecated\n        self.include_in_schema = include_in_schema\n        self.responses = responses or {}\n        self.callbacks = callbacks or []\n        self.dependency_overrides_provider = dependency_overrides_provider\n        self.route_class = route_class\n        self.default_response_class = default_response_class\n\n    def add_api_route(\n        self,\n        path: str,\n        endpoint: Callable[..., Any],\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: int = 200,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        methods: Optional[Union[Set[str], List[str]]] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Union[Type[Response], DefaultPlaceholder] = Default(\n            JSONResponse\n        ),\n        name: Optional[str] = None,\n        route_class_override: Optional[Type[APIRoute]] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n    ) -> None:\n        route_class = route_class_override or self.route_class\n        responses = responses or {}\n        combined_responses = {**self.responses, **responses}\n        current_response_class = get_value_or_default(\n            response_class, self.default_response_class\n        )\n        current_tags = self.tags.copy()\n        if tags:\n            current_tags.extend(tags)\n        current_dependencies = self.dependencies.copy()\n        if dependencies:\n            current_dependencies.extend(dependencies)\n        current_callbacks = self.callbacks.copy()\n        if callbacks:\n            current_callbacks.extend(callbacks)\n        route = route_class(\n            self.prefix + path,\n            endpoint=endpoint,\n            response_model=response_model,\n            status_code=status_code,\n            tags=current_tags,\n            dependencies=current_dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=combined_responses,\n            deprecated=deprecated or self.deprecated,\n            methods=methods,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema and self.include_in_schema,\n            response_class=current_response_class,\n            name=name,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n            callbacks=current_callbacks,\n        )\n        self.routes.append(route)\n\n    def api_route(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: int = 200,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        methods: Optional[List[str]] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags,\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses,\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_exclude_unset=response_model_exclude_unset,\n                response_model_exclude_defaults=response_model_exclude_defaults,\n                response_model_exclude_none=response_model_exclude_none,\n                include_in_schema=include_in_schema,\n                response_class=response_class,\n                name=name,\n                callbacks=callbacks,\n            )\n            return func\n\n        return decorator\n\n    def add_api_websocket_route(\n        self, path: str, endpoint: Callable[..., Any], name: Optional[str] = None\n    ) -> None:\n        route = APIWebSocketRoute(\n            path,\n            endpoint=endpoint,\n            name=name,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n        )\n        self.routes.append(route)\n\n    def websocket(\n        self, path: str, name: Optional[str] = None\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\n            self.add_api_websocket_route(path, func, name=name)\n            return func\n\n        return decorator\n\n    def include_router(\n        self,\n        router: \"APIRouter\",\n        *,\n        prefix: str = \"\",\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        default_response_class: Type[Response] = Default(JSONResponse),\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        deprecated: Optional[bool] = None,\n        include_in_schema: bool = True,\n    ) -> None:\n        if prefix:\n            assert prefix.startswith(\"/\"), \"A path prefix must start with '/'\"\n            assert not prefix.endswith(\n                \"/\"\n            ), \"A path prefix must not end with '/', as the routes will start with '/'\"\n        else:\n            for r in router.routes:\n                path = getattr(r, \"path\")\n                name = getattr(r, \"name\", \"unknown\")\n                if path is not None and not path:\n                    raise Exception(\n                        f\"Prefix and path cannot be both empty (path operation: {name})\"\n                    )\n        if responses is None:\n            responses = {}\n        for route in router.routes:\n            if isinstance(route, APIRoute):\n                combined_responses = {**responses, **route.responses}\n                use_response_class = get_value_or_default(\n                    route.response_class,\n                    router.default_response_class,\n                    default_response_class,\n                    self.default_response_class,\n                )\n                current_tags = []\n                if tags:\n                    current_tags.extend(tags)\n                if route.tags:\n                    current_tags.extend(route.tags)\n                current_dependencies: List[params.Depends] = []\n                if dependencies:\n                    current_dependencies.extend(dependencies)\n                if route.dependencies:\n                    current_dependencies.extend(route.dependencies)\n                current_callbacks = []\n                if callbacks:\n                    current_callbacks.extend(callbacks)\n                if route.callbacks:\n                    current_callbacks.extend(route.callbacks)\n                self.add_api_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    response_model=route.response_model,\n                    status_code=route.status_code,\n                    tags=current_tags,\n                    dependencies=current_dependencies,\n                    summary=route.summary,\n                    description=route.description,\n                    response_description=route.response_description,\n                    responses=combined_responses,\n                    deprecated=route.deprecated or deprecated or self.deprecated,\n                    methods=route.methods,\n                    operation_id=route.operation_id,\n                    response_model_include=route.response_model_include,\n                    response_model_exclude=route.response_model_exclude,\n                    response_model_by_alias=route.response_model_by_alias,\n                    response_model_exclude_unset=route.response_model_exclude_unset,\n                    response_model_exclude_defaults=route.response_model_exclude_defaults,\n                    response_model_exclude_none=route.response_model_exclude_none,\n                    include_in_schema=route.include_in_schema\n                    and self.include_in_schema\n                    and include_in_schema,\n                    response_class=use_response_class,\n                    name=route.name,\n                    route_class_override=type(route),\n                    callbacks=current_callbacks,\n                )\n            elif isinstance(route, routing.Route):\n                methods = list(route.methods or [])  # type: ignore # in Starlette\n                self.add_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    methods=methods,\n                    include_in_schema=route.include_in_schema,\n                    name=route.name,\n                )\n            elif isinstance(route, APIWebSocketRoute):\n                self.add_api_websocket_route(\n                    prefix + route.path, route.endpoint, name=route.name\n                )\n            elif isinstance(route, routing.WebSocketRoute):\n                self.add_websocket_route(\n                    prefix + route.path, route.endpoint, name=route.name\n                )\n        for handler in router.on_startup:\n            self.add_event_handler(\"startup\", handler)\n        for handler in router.on_shutdown:\n            self.add_event_handler(\"shutdown\", handler)\n\n    def get(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: int = 200,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"GET\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def put(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: int = 200,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"PUT\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def post(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: int = 200,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"POST\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def delete(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: int = 200,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"DELETE\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def options(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: int = 200,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"OPTIONS\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def head(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: int = 200,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"HEAD\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def patch(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: int = 200,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"PATCH\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def trace(\n        self,\n        path: str,\n        *,\n        response_model: Optional[Type[Any]] = None,\n        status_code: int = 200,\n        tags: Optional[List[str]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        deprecated: Optional[bool] = None,\n        operation_id: Optional[str] = None,\n        response_model_include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = Default(JSONResponse),\n        name: Optional[str] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\n\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags,\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses,\n            deprecated=deprecated,\n            methods=[\"TRACE\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=response_model_exclude_unset,\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n", "from unittest.mock import patch\n\nimport pytest\nfrom fastapi.testclient import TestClient\n\nfrom docs_src.body.tutorial001 import app\n\nclient = TestClient(app)\n\nopenapi_schema = {\n    \"openapi\": \"3.0.2\",\n    \"info\": {\"title\": \"FastAPI\", \"version\": \"0.1.0\"},\n    \"paths\": {\n        \"/items/\": {\n            \"post\": {\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n                \"summary\": \"Create Item\",\n                \"operationId\": \"create_item_items__post\",\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\"$ref\": \"#/components/schemas/Item\"}\n                        }\n                    },\n                    \"required\": True,\n                },\n            }\n        }\n    },\n    \"components\": {\n        \"schemas\": {\n            \"Item\": {\n                \"title\": \"Item\",\n                \"required\": [\"name\", \"price\"],\n                \"type\": \"object\",\n                \"properties\": {\n                    \"name\": {\"title\": \"Name\", \"type\": \"string\"},\n                    \"price\": {\"title\": \"Price\", \"type\": \"number\"},\n                    \"description\": {\"title\": \"Description\", \"type\": \"string\"},\n                    \"tax\": {\"title\": \"Tax\", \"type\": \"number\"},\n                },\n            },\n            \"ValidationError\": {\n                \"title\": \"ValidationError\",\n                \"required\": [\"loc\", \"msg\", \"type\"],\n                \"type\": \"object\",\n                \"properties\": {\n                    \"loc\": {\n                        \"title\": \"Location\",\n                        \"type\": \"array\",\n                        \"items\": {\"type\": \"string\"},\n                    },\n                    \"msg\": {\"title\": \"Message\", \"type\": \"string\"},\n                    \"type\": {\"title\": \"Error Type\", \"type\": \"string\"},\n                },\n            },\n            \"HTTPValidationError\": {\n                \"title\": \"HTTPValidationError\",\n                \"type\": \"object\",\n                \"properties\": {\n                    \"detail\": {\n                        \"title\": \"Detail\",\n                        \"type\": \"array\",\n                        \"items\": {\"$ref\": \"#/components/schemas/ValidationError\"},\n                    }\n                },\n            },\n        }\n    },\n}\n\n\ndef test_openapi_schema():\n    response = client.get(\"/openapi.json\")\n    assert response.status_code == 200, response.text\n    assert response.json() == openapi_schema\n\n\nprice_missing = {\n    \"detail\": [\n        {\n            \"loc\": [\"body\", \"price\"],\n            \"msg\": \"field required\",\n            \"type\": \"value_error.missing\",\n        }\n    ]\n}\n\nprice_not_float = {\n    \"detail\": [\n        {\n            \"loc\": [\"body\", \"price\"],\n            \"msg\": \"value is not a valid float\",\n            \"type\": \"type_error.float\",\n        }\n    ]\n}\n\nname_price_missing = {\n    \"detail\": [\n        {\n            \"loc\": [\"body\", \"name\"],\n            \"msg\": \"field required\",\n            \"type\": \"value_error.missing\",\n        },\n        {\n            \"loc\": [\"body\", \"price\"],\n            \"msg\": \"field required\",\n            \"type\": \"value_error.missing\",\n        },\n    ]\n}\n\nbody_missing = {\n    \"detail\": [\n        {\"loc\": [\"body\"], \"msg\": \"field required\", \"type\": \"value_error.missing\"}\n    ]\n}\n\n\n@pytest.mark.parametrize(\n    \"path,body,expected_status,expected_response\",\n    [\n        (\n            \"/items/\",\n            {\"name\": \"Foo\", \"price\": 50.5},\n            200,\n            {\"name\": \"Foo\", \"price\": 50.5, \"description\": None, \"tax\": None},\n        ),\n        (\n            \"/items/\",\n            {\"name\": \"Foo\", \"price\": \"50.5\"},\n            200,\n            {\"name\": \"Foo\", \"price\": 50.5, \"description\": None, \"tax\": None},\n        ),\n        (\n            \"/items/\",\n            {\"name\": \"Foo\", \"price\": \"50.5\", \"description\": \"Some Foo\"},\n            200,\n            {\"name\": \"Foo\", \"price\": 50.5, \"description\": \"Some Foo\", \"tax\": None},\n        ),\n        (\n            \"/items/\",\n            {\"name\": \"Foo\", \"price\": \"50.5\", \"description\": \"Some Foo\", \"tax\": 0.3},\n            200,\n            {\"name\": \"Foo\", \"price\": 50.5, \"description\": \"Some Foo\", \"tax\": 0.3},\n        ),\n        (\"/items/\", {\"name\": \"Foo\"}, 422, price_missing),\n        (\"/items/\", {\"name\": \"Foo\", \"price\": \"twenty\"}, 422, price_not_float),\n        (\"/items/\", {}, 422, name_price_missing),\n        (\"/items/\", None, 422, body_missing),\n    ],\n)\ndef test_post_body(path, body, expected_status, expected_response):\n    response = client.post(path, json=body)\n    assert response.status_code == expected_status\n    assert response.json() == expected_response\n\n\ndef test_post_broken_body():\n    response = client.post(\n        \"/items/\",\n        headers={\"content-type\": \"application/json\"},\n        data=\"{some broken json}\",\n    )\n    assert response.status_code == 422, response.text\n    assert response.json() == {\n        \"detail\": [\n            {\n                \"loc\": [\"body\", 1],\n                \"msg\": \"Expecting property name enclosed in double quotes: line 1 column 2 (char 1)\",\n                \"type\": \"value_error.jsondecode\",\n                \"ctx\": {\n                    \"msg\": \"Expecting property name enclosed in double quotes\",\n                    \"doc\": \"{some broken json}\",\n                    \"pos\": 1,\n                    \"lineno\": 1,\n                    \"colno\": 2,\n                },\n            }\n        ]\n    }\n\n\ndef test_post_form_for_json():\n    response = client.post(\"/items/\", data={\"name\": \"Foo\", \"price\": 50.5})\n    assert response.status_code == 422, response.text\n    assert response.json() == {\n        \"detail\": [\n            {\n                \"loc\": [\"body\"],\n                \"msg\": \"value is not a valid dict\",\n                \"type\": \"type_error.dict\",\n            }\n        ]\n    }\n\n\ndef test_explicit_content_type():\n    response = client.post(\n        \"/items/\",\n        data='{\"name\": \"Foo\", \"price\": 50.5}',\n        headers={\"Content-Type\": \"application/json\"},\n    )\n    assert response.status_code == 200, response.text\n\n\ndef test_geo_json():\n    response = client.post(\n        \"/items/\",\n        data='{\"name\": \"Foo\", \"price\": 50.5}',\n        headers={\"Content-Type\": \"application/geo+json\"},\n    )\n    assert response.status_code == 200, response.text\n\n\ndef test_wrong_headers():\n    data = '{\"name\": \"Foo\", \"price\": 50.5}'\n    invalid_dict = {\n        \"detail\": [\n            {\n                \"loc\": [\"body\"],\n                \"msg\": \"value is not a valid dict\",\n                \"type\": \"type_error.dict\",\n            }\n        ]\n    }\n\n    response = client.post(\"/items/\", data=data, headers={\"Content-Type\": \"text/plain\"})\n    assert response.status_code == 422, response.text\n    assert response.json() == invalid_dict\n\n    response = client.post(\n        \"/items/\", data=data, headers={\"Content-Type\": \"application/geo+json-seq\"}\n    )\n    assert response.status_code == 422, response.text\n    assert response.json() == invalid_dict\n    response = client.post(\n        \"/items/\", data=data, headers={\"Content-Type\": \"application/not-really-json\"}\n    )\n    assert response.status_code == 422, response.text\n    assert response.json() == invalid_dict\n\n\ndef test_other_exceptions():\n    with patch(\"json.loads\", side_effect=Exception):\n        response = client.post(\"/items/\", json={\"test\": \"test2\"})\n        assert response.status_code == 400, response.text\n", "import gzip\nimport json\n\nimport pytest\nfrom fastapi import Request\nfrom fastapi.testclient import TestClient\n\nfrom docs_src.custom_request_and_route.tutorial001 import app\n\n\n@app.get(\"/check-class\")\nasync def check_gzip_request(request: Request):\n    return {\"request_class\": type(request).__name__}\n\n\nclient = TestClient(app)\n\n\n@pytest.mark.parametrize(\"compress\", [True, False])\ndef test_gzip_request(compress):\n    n = 1000\n    headers = {}\n    body = [1] * n\n    data = json.dumps(body).encode()\n    if compress:\n        data = gzip.compress(data)\n        headers[\"Content-Encoding\"] = \"gzip\"\n    headers[\"Content-Type\"] = \"application/json\"\n    response = client.post(\"/sum\", data=data, headers=headers)\n    assert response.json() == {\"sum\": n}\n\n\ndef test_request_class():\n    response = client.get(\"/check-class\")\n    assert response.json() == {\"request_class\": \"GzipRequest\"}\n"], "filenames": ["fastapi/routing.py", "tests/test_tutorial/test_body/test_tutorial001.py", "tests/test_tutorial/test_custom_request_and_route/test_tutorial001.py"], "buggy_code_start_loc": [1, 176, 27], "buggy_code_end_loc": [185, 198, 27], "fixing_code_start_loc": [2, 176, 28], "fixing_code_end_loc": [198, 263, 29], "type": "CWE-352", "message": "FastAPI is a web framework for building APIs with Python 3.6+ based on standard Python type hints. FastAPI versions lower than 0.65.2 that used cookies for authentication in path operations that received JSON payloads sent by browsers were vulnerable to a Cross-Site Request Forgery (CSRF) attack. In versions lower than 0.65.2, FastAPI would try to read the request payload as JSON even if the content-type header sent was not set to application/json or a compatible JSON media type (e.g. application/geo+json). A request with a content type of text/plain containing JSON data would be accepted and the JSON data would be extracted. Requests with content type text/plain are exempt from CORS preflights, for being considered Simple requests. The browser will execute them right away including cookies, and the text content could be a JSON string that would be parsed and accepted by the FastAPI application. This is fixed in FastAPI 0.65.2. The request data is now parsed as JSON only if the content-type header is application/json or another JSON compatible media type like application/geo+json. It's best to upgrade to the latest FastAPI, but if updating is not possible then a middleware or a dependency that checks the content-type header and aborts the request if it is not application/json or another JSON compatible content type can act as a mitigating workaround.", "other": {"cve": {"id": "CVE-2021-32677", "sourceIdentifier": "security-advisories@github.com", "published": "2021-06-09T18:15:08.553", "lastModified": "2021-06-24T14:31:37.397", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "FastAPI is a web framework for building APIs with Python 3.6+ based on standard Python type hints. FastAPI versions lower than 0.65.2 that used cookies for authentication in path operations that received JSON payloads sent by browsers were vulnerable to a Cross-Site Request Forgery (CSRF) attack. In versions lower than 0.65.2, FastAPI would try to read the request payload as JSON even if the content-type header sent was not set to application/json or a compatible JSON media type (e.g. application/geo+json). A request with a content type of text/plain containing JSON data would be accepted and the JSON data would be extracted. Requests with content type text/plain are exempt from CORS preflights, for being considered Simple requests. The browser will execute them right away including cookies, and the text content could be a JSON string that would be parsed and accepted by the FastAPI application. This is fixed in FastAPI 0.65.2. The request data is now parsed as JSON only if the content-type header is application/json or another JSON compatible media type like application/geo+json. It's best to upgrade to the latest FastAPI, but if updating is not possible then a middleware or a dependency that checks the content-type header and aborts the request if it is not application/json or another JSON compatible content type can act as a mitigating workaround."}, {"lang": "es", "value": "FastAPI es un framework web para construir APIs con Python versi\u00f3n 3.6+ basado en sugerencias de tipo est\u00e1ndar de Python. Las versiones de FastAPI inferiores a la 0.65.2 que usaban cookies para la autenticaci\u00f3n en las operaciones de ruta que recib\u00edan cargas \u00fatiles JSON enviadas por los navegadores eran vulnerables a un ataque de tipo Cross-Site Request Forgery (CSRF). En versiones inferiores a la 0.65.2, FastAPI intentaba leer la carga \u00fatil de la petici\u00f3n como JSON incluso si la encabezado content-type enviada no estaba configurada como application/json o un tipo de medio JSON compatible (por ejemplo, application/geo+json). Una petici\u00f3n con un tipo de contenido text/plain que contenga datos JSON ser\u00e1 aceptada y los datos JSON ser\u00e1n extra\u00eddos. Las peticiones con tipo de contenido text/plain est\u00e1n exentas de preflights CORS, por ser consideradas peticiones simples. El navegador las ejecutar\u00e1 de inmediato, incluyendo las cookies, y el contenido de texto podr\u00eda ser una cadena JSON que ser\u00eda analizada y aceptada por la aplicaci\u00f3n FastAPI. Esto se ha corregido en FastAPI 0.65.2. Ahora los datos de la petici\u00f3n se analizan como JSON s\u00f3lo si la encabezado content-type es application/json u otro tipo de medio compatible con JSON como application/geo+json. Es mejor actualizar a la \u00faltima FastAPI, pero si la actualizaci\u00f3n no es posible, entonces un middleware o una dependencia que compruebe la encabezado de tipo de contenido y aborte la petici\u00f3n si no es application/json u otro tipo de contenido compatible con JSON puede actuar como una soluci\u00f3n de mitigaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fastapi_project:fastapi:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.65.2", "matchCriteriaId": "11BD9B21-4146-463D-B886-44EA2687B0EB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}], "references": [{"url": "https://github.com/tiangolo/fastapi/commit/fa7e3c996edf2d5482fff8f9d890ac2390dede4d", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tiangolo/fastapi/security/advisories/GHSA-8h2j-cgx8-6xv7", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MATAWX25TYKNEKLDMKWNLYDB34UWTROA/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tiangolo/fastapi/commit/fa7e3c996edf2d5482fff8f9d890ac2390dede4d"}}