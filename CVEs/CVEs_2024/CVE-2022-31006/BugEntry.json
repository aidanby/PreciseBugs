{"buggy_code": ["# Setup iptables rules (recommended)\n\nIt is strongly recommended to add iptables (or some other firewall) rule that limits the number of simultaneous clients\nconnections for client port.\nThere are at least two important reasons for this:\n - preventing the indy-node process from reaching of open file descriptors limit caused by clients connections\n - preventing the indy-node process from large memory usage as ZeroMQ creates the separate queue for each TCP connection.\n\nNOTE: limitation of the number of *simultaneous clients connections* does not mean that we limit the\nnumber of *simultaneous clients* the indy-node works with in any time. The IndySDK client does not keep\nconnection infinitely, it uses the same connection for request-response session with some optimisations,\nso it's just about **connections**, **not** about **clients**.\n\nAlso iptables can be used to deal with various DoS attacks (e.g. syn flood) but rules' parameters are not estimated yet.\n\nNOTE: you should be a root to operate with iptables.\n\n\n## Setting up clients connections limit\n\n#### Using raw iptables command or iptables front-end\n\nIn case of deb installation the indy-node environment file /etc/indy/indy.env is created by `init_indy_node` script.\nThis environment file contains client port (NODE_CLIENT_PORT) and recommended clients connections limit (CLIENT_CONNECTIONS_LIMIT).\nThis parameters can be used to add the iptables rule for chain INPUT:\n\n```\n# iptables -I INPUT -p tcp --syn --dport 9702 -m connlimit --connlimit-above 500 --connlimit-mask 0 -j REJECT --reject-with tcp-reset\n```\nSome key options:\n - --dport - a port for which limit is set\n - --connlimit-above - connections limit, exceeding new connections will be rejected using TCP reset\n - --connlimit-mask - group hosts using the prefix length, 0 means \"all subnets\"\n\nCorresponding fields should be set in case of some iptables front-end usage.\n\n\n#### Using indy scripts\n\nFor ease of use and for people that are not familiar with iptables we've \nadded two scripts:\n - setup_iptables: adds a rule to iptables to limit the number of simultaneous\n clients connections for specified port;\n - setup_indy_node_iptables: a wrapper for setup_iptables script which gets client\n port and recommended connections limit from indy-node environment file that is created by init_indy_node script.\n\nLinks to these scripts:\n\n - https://github.com/hyperledger/indy-node/blob/master/scripts/setup_iptables\n - https://github.com/hyperledger/indy-node/blob/master/scripts/setup_indy_node_iptables\n \nNOTE: for now the iptables chain for which the rule is added is not parameterized,\nthe rule is always added for INPUT chain, we can parameterize it in future if needed. \n\n###### For deb installation\nTo setup the limit of the number of simultaneous clients connections it is enough to run the following script without parameters\n```\n# setup_indy_node_iptables\n```\nThis script gets client port and recommended connections limit from the indy-node environment file.\n\nNOTE: this script should be called *after* `init_indy_node` script.\n\n###### For pip installation\nThe `setup_indy_node_iptables` script can not be used in case of pip installation as indy-node environment file does not exist,\nuse the `setup_iptables` script instead (9702 is a client port, 500 is recommended limit for now)\n```\n# setup_iptables 9702 500\n```\nIn fact, the `setup_indy_node_iptables` script is just a wrapper for the `setup_iptables` script.\n", "#!/bin/bash\n\nif [ $# -lt 2 ]; then\n    echo \"\"\n    echo \"Usage: $0 client_port connlimit\";\n    echo \"  client_port - node client port\";\n    echo \"  connlimit   - clients connections limit\";\n    echo \"\"\n    exit 1;\nfi\n\n\nDPORT=$1\nCONN_LIMIT=$2\nLOG_CHAIN=LOG_CONN_REJECT\n\nadd_rule_if_not_exist()\n{\n    RULE=\"$1\"\n\n    cmd=\"iptables -C $RULE 2>/dev/null 1>&2\"\n    eval $cmd\n\n    if [ $? -eq 1 ]; then\n        cmd=\"iptables -A $RULE\"\n        eval $cmd\n    fi\n}\n\n# Check whether iptables installed and works\ndpkg -s iptables 2>/dev/null 1>&2 && iptables -nL 2>/dev/null 1>&2\nif [ $? -eq 0 ]; then\n    # Create logging chain for rejected connections\n    iptables -N $LOG_CHAIN 2>/dev/null 1>&2\n\n    # Append a rule that sets log level and log prefix\n    RULE=\"$LOG_CHAIN -j LOG --log-level warning --log-prefix \\\"connlimit: \\\"\"\n    add_rule_if_not_exist \"$RULE\"\n\n    # Append a rule that finally rejects connection\n    RULE=\"$LOG_CHAIN -p tcp -j REJECT --reject-with tcp-reset\"\n    add_rule_if_not_exist \"$RULE\"\n\n    # Append a rule to limit the number of simultaneous clients connections\n    RULE=\"INPUT -p tcp --syn --dport $DPORT -m connlimit --connlimit-above $CONN_LIMIT --connlimit-mask 0 -j $LOG_CHAIN\"\n    add_rule_if_not_exist \"$RULE\"\nelse\n    echo \"Warning: iptables is not installed or permission denied, clients connections limit is not set.\"\nfi\n"], "fixing_code": ["# Setup iptables rules (recommended)\n\nIt is strongly recommended to add iptables (or some other firewall) rules to limit the number of simultaneous clients\nconnections to your node's client port.\n\nThere are at least two important reasons for this:\n - preventing the indy-node process from exceeding the limit of open file descriptors due to an excessive number of clients connections.\n - controlling the indy-node process's memory use, as ZeroMQ creates a separate queue for each TCP connection.\n\nNOTE: The limitation of the number of *simultaneous clients connections* does not mean that we limit the\nnumber of *simultaneous clients* indy-node works with in any time. Connections are not left open infinitely.  The same connection is used for a request-response session with some optimisations and then closed, therefore it's just about **connections**, **not** about **clients**.\n\nNOTE: You will need to have sudo privileges to work with iptables.\n\n## Using indy scripts\n\nFor ease of use and for people that are not familiar with iptables we've added two scripts:\n - [`setup_iptables`](https://github.com/hyperledger/indy-node/blob/main/scripts/setup_iptables):\n    - By default this scripts adds rules to iptables to limit the number of simultaneous clients connections for a specified port.\n    - To get a full list of options run `./setup_iptables -h` from the scripts directory.\n\n - [`setup_indy_node_iptables`](https://github.com/hyperledger/indy-node/blob/main/scripts/setup_indy_node_iptables):\n    - A wrapper around `setup_iptables` which gets client port and connection limit settings from the `/etc/indy/indy.env` that is created by the `init_indy_node` script.\n\nWhich one you use depends on how you installed indy-node on your server.  Refer to the [For deb package based installations](#for-deb-package-based-installations), and [For pip based installations](#for-pip-based-installations) sections below.\n\n### Updating the scripts and configuration\n\nBefore you run the scripts you should ensure you are using the latest scripts and recommended settings by following these steps while logged into your node:\n\n1. Make a backup copy of the existing `setup_iptables` script by executing the command:\n    ```\n    sudo cp /usr/local/bin/setup_iptables /usr/local/bin/setup_iptables_$(date \"+%Y%m%d-%H%M%S\")\n    ```\n\n1. Update the default client connection limit to 15000 in `/etc/indy/indy.env`.\n    - NOTE:\n      - `/etc/indy/indy.env` only exists for deb package based installations.\n      - `\\1` is an excape sequence `\\115000` is not a typo.\n    ```\n    sudo sed -i -re \"s/(^CLIENT_CONNECTIONS_LIMIT=).*$/\\115000/\" /etc/indy/indy.env\n    ```\n\n1. Download the latest version of the script.\n    ```\n    sudo curl -o /usr/local/bin/setup_iptables https://raw.githubusercontent.com/hyperledger/indy-node/main/scripts/setup_iptables\n    ```\n    The sha256 checksum for the current version of the script is `a0e4451cc49897dc38946091b245368c1f1360201f374a3ad121925f9aa80664`\n\n\n### For deb package based installations\n\nRun:\n```\nsetup_indy_node_iptables\n```\nNOTE:\n  - This script should only be called *after* your node has been initialized using `init_indy_node`, to ensure `/etc/indy/indy.env` has been created.\n\n### For pip based installations\n\nFor pip based installations `/etc/indy/indy.env` does not exist, therefore `setup_indy_node_iptables` cannot be used.  Instead you run `setup_iptables` directly.\n\nFor example, if your client port is 9702, you would run:\n```\nsetup_iptables 9702 15000\n```\n\n## Using raw iptables command or iptables front-end\n\nIf you are confident with using iptables, you may add additional rules as you see fit using iptables directly.", "#!/bin/bash\n\nusage () {\n  cat <<-EOF\n\n  Usage:\n\n    $0 [-d] <client_port> <overall_connlimit> [per_ip_connlimit] [conn_rate_limit] [conn_rate_period] [logging_level]\n\n      Options:\n        -d                  - Delete the corresponding rules.\n                              Removes the rules corresponding to the supplied input parameters.\n        -t                  - Test mode.  Prints out the list of input settings and exits.\n\n      Input Parameters:\n        client_port         - Required.  The node's client port.\n        overall_connlimit   - Required.  The overall connection limit for all clients.\n        per_ip_connlimit    - Optional.  The connection limit per IP address; defaults to 10.\n        conn_rate_limit     - Optional.  The connection limit for connection rate limiting; default to -1, off.\n        conn_rate_period    - Optional.  The period for connection rate limiting; defaults to 60 seconds.\n        logging_level       - Optional.  If used, this should be set to a level such as 'debug' so they can \n                                         easily be filtered from the logs and included only as needed.\n                                         Default is no logging.\n\n        Example:\n        $0 9702 15000\n\nEOF\n    exit 1\n}\n\ncheck_setup () {\n  cat <<-EOF\n\n    Warning: iptables and/or iptables-persistent is not installed, or permission denied.  Client connections limit is not set.\n\n    Please ensure iptables and iptables-persistent are both installed and iptables-persistent is enabled, and try running with sudo.\n\n    # To install iptables-persistent:\n    sudo apt-get install -y iptables-persistent\n\n    # Make sure services are enabled on Debian or Ubuntu using the systemctl command:\n    sudo systemctl is-enabled netfilter-persistent.service\n\n    # If not enable it:\n    sudo systemctl enable netfilter-persistent.service\n\n    # Get status:\n    sudo systemctl status netfilter-persistent.service\n\nEOF\n    exit 1\n}\n\nprint_settings() {\n  if (( ${CONN_RATE_LIMIT_LIMIT} <= 0 || ${CONN_RATE_LIMIT_PERIOD} <= 0 )); then\n    RATE_LIMIT_MESSAGE=\" - Connection rate limiting is turned off.\"\n  fi\n\n  cat <<-EOF\n\n  client_port:          ${DPORT}\n  overall_connlimit:    ${OVER_ALL_CONN_LIMIT}\n  per_ip_connlimit:     ${CONN_LIMIT_PER_IP}\n  conn_rate_limit:      ${CONN_RATE_LIMIT_LIMIT} ${RATE_LIMIT_MESSAGE} \n  conn_rate_period:     ${CONN_RATE_LIMIT_PERIOD} ${RATE_LIMIT_MESSAGE}\n  logging_level:        ${CONN_LOGGING_LEVEL:-Not set, (off) default}\n\n  OPERATION:            ${OPERATION}\n  DELETE:               ${DELETE}\n  TEST_MODE:            ${TEST_MODE}\nEOF\n}\n\nLOG_CHAIN=LOG_CONN_REJECT\nOPERATION=\"add_rule\"\n\nwhile getopts dth FLAG; do\n  case $FLAG in\n    d)\n      OPERATION=\"delete_rule\"\n      DELETE=1\n      ;;\n    t)\n      TEST_MODE=1\n      ;;\n    h)\n      usage\n      ;;\n    \\?)\n      usage\n      ;;\n  esac\ndone\nshift $((OPTIND-1))\n\nDPORT=${1}\nOVER_ALL_CONN_LIMIT=${2}\n\n# Default to 10 connections per IP.\nCONN_LIMIT_PER_IP=${3:-10}\n\n# Default: Rate limiting disabled; -1.\nCONN_RATE_LIMIT_LIMIT=${4:--1}\n\n# Default to a per minute rate limit.\nCONN_RATE_LIMIT_PERIOD=${5:-60}\n\nCONN_LOGGING_LEVEL=${6}\n\nadd() {\n    if [ -z ${DELETE} ]; then\n        return 0\n    else\n        return 1\n    fi\n}\n\ndelete() {\n    if [ ! -z ${DELETE} ]; then\n        return 0\n    else\n        return 1\n    fi\n}\n\nrule_exists() {\n    RULE=\"${1}\"\n    cmd=\"iptables -C ${RULE} 2>/dev/null 1>&2\"\n    # echo $cmd\n    eval $cmd\n    rtnCd=$?\n    if (( ${rtnCd} == 0 )); then\n        return 0\n    else\n        return 1\n    fi\n}\n\nadd_rule() {\n    RULE=\"${1}\"\n    if ! rule_exists \"${RULE}\"; then\n        cmd=\"iptables -A ${RULE}\"\n        # echo $cmd\n        eval $cmd\n    fi\n}\n\ndelete_rule() {\n    RULE=\"${1}\"\n    if rule_exists \"${RULE}\"; then\n        cmd=\"iptables -D ${RULE}\"\n        # echo $cmd\n        eval $cmd\n    fi\n}\n\nsave_rules() {\n    su -c \"iptables-save > /etc/iptables/rules.v4 && ip6tables-save > /etc/iptables/rules.v6\"\n}\n\ndisable_ipv6() {\n    echo \"Disabling IPv6 ...\"\n    ip6_conf_file=\"/etc/sysctl.d/60-custom-disable-ipv6.conf\"\n    mkdir -p ${ip6_conf_file%/*}\n\n    cat <<-EOF > ${ip6_conf_file}\nnet.ipv6.conf.all.disable_ipv6 = 1\nnet.ipv6.conf.default.disable_ipv6 = 1\nnet.ipv6.conf.lo.disable_ipv6 = 1\nEOF\n\n    sysctl -p\n    systemctl restart procps\n}\n\nenable_ipv6() {\n    echo \"Enabling IPv6 ...\"\n    ip6_conf_file=\"/etc/sysctl.d/60-custom-disable-ipv6.conf\"\n\n    if [ -f ${ip6_conf_file} ]; then\n        rm ${ip6_conf_file}\n    fi\n    sysctl -p\n    systemctl restart procps\n}\n\nif [ $# -lt 2 ]; then\n    usage\nfi\n\nif [ ! -z ${TEST_MODE} ]; then\n    print_settings\n    exit 0\nfi\n\n# Check whether iptables installed and works\ndpkg -s iptables 2>/dev/null 1>&2 && iptables -nL 2>/dev/null 1>&2 && dpkg -s iptables-persistent 2>/dev/null 1>&2\nif [ $? -eq 0 ]; then\n\n    if add; then\n        echo \"Adding iptable rules ...\"\n        # Create logging chain for rejected connections\n        iptables -N ${LOG_CHAIN} 2>/dev/null 1>&2\n    else\n        echo \"Removing iptable rules ...\"\n    fi\n\n    # Make sure the previous default logging rule is removed.  It causes too much CPU overhead under load.\n    RULE=\"${LOG_CHAIN} -j LOG --log-level warning --log-prefix \\\"connlimit: \\\"\"\n    delete_rule \"${RULE}\"\n\n    # Append a rule that sets log level and log prefix\n    # Default to no logging unless a logging level is explicitly supplied.\n    if [ ! -z ${CONN_LOGGING_LEVEL} ]; then\n        RULE=\"${LOG_CHAIN} -j LOG --log-level ${CONN_LOGGING_LEVEL} --log-prefix \\\"connlimit: \\\"\"\n        ${OPERATION} \"${RULE}\"\n    fi\n\n    # Append a rule that finally rejects connection\n    RULE=\"${LOG_CHAIN} -p tcp -j REJECT --reject-with tcp-reset\"\n    ${OPERATION} \"${RULE}\"\n\n    # Append a rule to limit the total number of simultaneous client connections\n    RULE=\"INPUT -p tcp --syn --dport ${DPORT} -m connlimit --connlimit-above ${OVER_ALL_CONN_LIMIT} --connlimit-mask 0 -j ${LOG_CHAIN}\"\n    ${OPERATION} \"${RULE}\"\n\n    # Append a rule to limit the number connections per IP address\n    RULE=\"INPUT -p tcp -m tcp --dport ${DPORT} --tcp-flags FIN,SYN,RST,ACK SYN -m connlimit --connlimit-above ${CONN_LIMIT_PER_IP} --connlimit-mask 32 --connlimit-saddr -j ${LOG_CHAIN}\"\n    ${OPERATION} \"${RULE}\"\n\n    # Append rules to rate limit connections\n    if (( ${CONN_RATE_LIMIT_LIMIT} > 0 && ${CONN_RATE_LIMIT_PERIOD} > 0 )); then\n        echo \"Including settings for rate limiting ...\"\n        RULE=\"INPUT -p tcp -m tcp --dport ${DPORT} -m conntrack --ctstate NEW -m recent --set --name DEFAULT --mask 255.255.255.255 --rsource\"\n        ${OPERATION} \"${RULE}\"\n        RULE=\"INPUT -p tcp -m tcp --dport ${DPORT} -m conntrack --ctstate NEW -m recent --update --seconds ${CONN_RATE_LIMIT_PERIOD} --hitcount ${CONN_RATE_LIMIT_LIMIT} --name DEFAULT --mask 255.255.255.255 --rsource -j ${LOG_CHAIN}\"\n        ${OPERATION} \"${RULE}\"\n    else\n        echo \"Rate limiting is disabled, skipping settings for rate limiting ...\"\n    fi\n\n    if delete; then\n        # Remove logging chain for rejected connections\n        iptables -X ${LOG_CHAIN} 2>/dev/null 1>&2\n    fi\n\n    # Save the rules\n    save_rules\n\n    if add; then\n        disable_ipv6\n    else\n        enable_ipv6\n    fi\nelse\n    check_setup\nfi"], "filenames": ["docs/source/setup-iptables.md", "scripts/setup_iptables"], "buggy_code_start_loc": [3, 2], "buggy_code_end_loc": [71, 50], "fixing_code_start_loc": [3, 3], "fixing_code_end_loc": [72, 259], "type": "CWE-400", "message": "indy-node is the server portion of Hyperledger Indy, a distributed ledger purpose-built for decentralized identity. In vulnerable versions of indy-node, an attacker can max out the number of client connections allowed by the ledger, leaving the ledger unable to be used for its intended purpose. However, the ledger content will not be impacted and the ledger will resume functioning after the attack. This attack exploits the trade-off between resilience and availability. Any protection against abusive client connections will also prevent the network being accessed by certain legitimate users. As a result, validator nodes must tune their firewall rules to ensure the right trade-off for their network's expected users. The guidance to network operators for the use of firewall rules in the deployment of Indy networks has been modified to better protect against denial of service attacks by increasing the cost and complexity in mounting such attacks. The mitigation for this vulnerability is not in the Hyperledger Indy code per se, but rather in the individual deployments of Indy. The mitigations should be applied to all deployments of Indy, and are not related to a particular release.", "other": {"cve": {"id": "CVE-2022-31006", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-09T19:15:08.247", "lastModified": "2022-09-15T15:00:44.820", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "indy-node is the server portion of Hyperledger Indy, a distributed ledger purpose-built for decentralized identity. In vulnerable versions of indy-node, an attacker can max out the number of client connections allowed by the ledger, leaving the ledger unable to be used for its intended purpose. However, the ledger content will not be impacted and the ledger will resume functioning after the attack. This attack exploits the trade-off between resilience and availability. Any protection against abusive client connections will also prevent the network being accessed by certain legitimate users. As a result, validator nodes must tune their firewall rules to ensure the right trade-off for their network's expected users. The guidance to network operators for the use of firewall rules in the deployment of Indy networks has been modified to better protect against denial of service attacks by increasing the cost and complexity in mounting such attacks. The mitigation for this vulnerability is not in the Hyperledger Indy code per se, but rather in the individual deployments of Indy. The mitigations should be applied to all deployments of Indy, and are not related to a particular release."}, {"lang": "es", "value": "indy-node es la parte del servidor de Hyperledger Indy, un libro de contabilidad distribuido dise\u00f1ado para la identidad descentralizada. En las versiones vulnerables de indy-node, un atacante puede superar el n\u00famero de conexiones de clientes permitidas por el libro mayor, dejando el libro mayor incapaz de ser usado para su prop\u00f3sito. Sin embargo, el contenido del libro mayor no estar\u00e1 afectado y el libro mayor volver\u00e1 a funcionar despu\u00e9s del ataque. Este ataque aprovecha el equilibrio entre la resistencia y la disponibilidad. Cualquier protecci\u00f3n contra las conexiones abusivas de los clientes tambi\u00e9n impedir\u00e1 el acceso a la red de ciertos usuarios leg\u00edtimos. Por ello, los nodos validadores deben ajustar sus reglas de firewall para garantizar el equilibrio apropiado para los usuarios previstos de su red. Las orientaciones a operadores de redes para el uso de reglas de firewall en el despliegue de las redes Indy han sido modificadas para proteger mejor contra los ataques de denegaci\u00f3n de servicio, aumentando el coste y la complejidad en el montaje de dichos ataques. La mitigaci\u00f3n de esta vulnerabilidad no est\u00e1 en el c\u00f3digo de Hyperledger Indy per se, sino en los despliegues individuales de Indy. Las mitigaciones deben aplicarse a todas las implementaciones de Indy, y no est\u00e1n relacionadas con una versi\u00f3n en particular"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:indy-node:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.12.6", "matchCriteriaId": "8B8C19BC-54F7-4972-95E3-EFB7F64AB24C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:indy-node:1.13.2:rc1:*:*:*:*:*:*", "matchCriteriaId": "B9DDDE33-EC69-4C6E-895A-72C7C600BAB0"}]}]}], "references": [{"url": "https://github.com/hyperledger/indy-node/commit/53a2a1bf1a26cb8ba710fd6adc8bcf275186a4b3", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/hyperledger/indy-node/security/advisories/GHSA-x996-7qh9-7ff7", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/hyperledger/indy-node/commit/53a2a1bf1a26cb8ba710fd6adc8bcf275186a4b3"}}