{"buggy_code": ["<?php\n\nnamespace enshrined\\svgSanitize;\n\nuse enshrined\\svgSanitize\\data\\AllowedAttributes;\nuse enshrined\\svgSanitize\\data\\AllowedTags;\nuse enshrined\\svgSanitize\\data\\AttributeInterface;\nuse enshrined\\svgSanitize\\data\\TagInterface;\nuse enshrined\\svgSanitize\\data\\XPath;\nuse enshrined\\svgSanitize\\ElementReference\\Resolver;\nuse enshrined\\svgSanitize\\ElementReference\\Subject;\n\n/**\n * Class Sanitizer\n *\n * @package enshrined\\svgSanitize\n */\nclass Sanitizer\n{\n\n    /**\n     * Regex to catch script and data values in attributes\n     */\n    const SCRIPT_REGEX = '/(?:\\w+script|data):/xi';\n\n    /**\n     * @var \\DOMDocument\n     */\n    protected $xmlDocument;\n\n    /**\n     * @var array\n     */\n    protected $allowedTags;\n\n    /**\n     * @var array\n     */\n    protected $allowedAttrs;\n\n    /**\n     * @var\n     */\n    protected $xmlLoaderValue;\n\n    /**\n     * @var bool\n     */\n    protected $minifyXML = false;\n\n    /**\n     * @var bool\n     */\n    protected $removeRemoteReferences = false;\n\n    /**\n     * @var int\n     */\n    protected $useThreshold = 1000;\n\n    /**\n     * @var bool\n     */\n    protected $removeXMLTag = false;\n\n    /**\n     * @var int\n     */\n    protected $xmlOptions = LIBXML_NOEMPTYTAG;\n\n    /**\n     * @var array\n     */\n    protected $xmlIssues = array();\n\n    /**\n     * @var Resolver\n     */\n    protected $elementReferenceResolver;\n\n    /**\n     *\n     */\n    function __construct()\n    {\n        // Load default tags/attributes\n        $this->allowedAttrs = array_map('strtolower', AllowedAttributes::getAttributes());\n        $this->allowedTags = array_map('strtolower', AllowedTags::getTags());\n    }\n\n    /**\n     * Set up the DOMDocument\n     */\n    protected function resetInternal()\n    {\n        $this->xmlDocument = new \\DOMDocument();\n        $this->xmlDocument->preserveWhiteSpace = false;\n        $this->xmlDocument->strictErrorChecking = false;\n        $this->xmlDocument->formatOutput = !$this->minifyXML;\n    }\n\n    /**\n     * Set XML options to use when saving XML\n     * See: DOMDocument::saveXML\n     *\n     * @param int  $xmlOptions\n     */\n    public function setXMLOptions($xmlOptions)\n    {\n        $this->xmlOptions = $xmlOptions;\n    }\n\n    /**\n     * Get XML options to use when saving XML\n     * See: DOMDocument::saveXML\n     *\n     * @return int\n     */\n    public function getXMLOptions()\n    {\n        return $this->xmlOptions;\n    }\n\n    /**\n     * Get the array of allowed tags\n     *\n     * @return array\n     */\n    public function getAllowedTags()\n    {\n        return $this->allowedTags;\n    }\n\n    /**\n     * Set custom allowed tags\n     *\n     * @param TagInterface $allowedTags\n     */\n    public function setAllowedTags(TagInterface $allowedTags)\n    {\n        $this->allowedTags = array_map('strtolower', $allowedTags::getTags());\n    }\n\n    /**\n     * Get the array of allowed attributes\n     *\n     * @return array\n     */\n    public function getAllowedAttrs()\n    {\n        return $this->allowedAttrs;\n    }\n\n    /**\n     * Set custom allowed attributes\n     *\n     * @param AttributeInterface $allowedAttrs\n     */\n    public function setAllowedAttrs(AttributeInterface $allowedAttrs)\n    {\n        $this->allowedAttrs = array_map('strtolower', $allowedAttrs::getAttributes());\n    }\n\n    /**\n     * Should we remove references to remote files?\n     *\n     * @param bool $removeRemoteRefs\n     */\n    public function removeRemoteReferences($removeRemoteRefs = false)\n    {\n        $this->removeRemoteReferences = $removeRemoteRefs;\n    }\n\n    /**\n     * Get XML issues.\n     *\n     * @return array\n     */\n    public function getXmlIssues() {\n        return $this->xmlIssues;\n    }\n\n\n    /**\n     * Sanitize the passed string\n     *\n     * @param string $dirty\n     * @return string\n     */\n    public function sanitize($dirty)\n    {\n        // Don't run on an empty string\n        if (empty($dirty)) {\n            return '';\n        }\n\n        // Strip php tags\n        $dirty = preg_replace('/<\\?(=|php)(.+?)\\?>/i', '', $dirty);\n\n        $this->resetInternal();\n        $this->setUpBefore();\n\n        $loaded = $this->xmlDocument->loadXML($dirty);\n\n        // If we couldn't parse the XML then we go no further. Reset and return false\n        if (!$loaded) {\n            $this->resetAfter();\n            return false;\n        }\n\n        $this->removeDoctype();\n\n        // Pre-process all identified elements\n        $xPath = new XPath($this->xmlDocument);\n        $this->elementReferenceResolver = new Resolver($xPath);\n        $this->elementReferenceResolver->collect();\n        // Grab all the elements\n        $allElements = $this->xmlDocument->getElementsByTagName(\"*\");\n\n        // Start the cleaning proccess\n        $this->startClean($allElements);\n\n        // Save cleaned XML to a variable\n        if ($this->removeXMLTag) {\n            $clean = $this->xmlDocument->saveXML($this->xmlDocument->documentElement, $this->xmlOptions);\n        } else {\n            $clean = $this->xmlDocument->saveXML($this->xmlDocument, $this->xmlOptions);\n        }\n\n        $this->resetAfter();\n\n        // Remove any extra whitespaces when minifying\n        if ($this->minifyXML) {\n            $clean = preg_replace('/\\s+/', ' ', $clean);\n        }\n\n        // Return result\n        return $clean;\n    }\n\n    /**\n     * Set up libXML before we start\n     */\n    protected function setUpBefore()\n    {\n        // Turn off the entity loader\n        $this->xmlLoaderValue = libxml_disable_entity_loader(true);\n\n        // Suppress the errors because we don't really have to worry about formation before cleansing\n        libxml_use_internal_errors(true);\n\n        // Reset array of altered XML\n        $this->xmlIssues = array();\n    }\n\n    /**\n     * Reset the class after use\n     */\n    protected function resetAfter()\n    {\n        // Reset the entity loader\n        libxml_disable_entity_loader($this->xmlLoaderValue);\n    }\n\n    /**\n     * Remove the XML Doctype\n     * It may be caught later on output but that seems to be buggy, so we need to make sure it's gone\n     */\n    protected function removeDoctype()\n    {\n        foreach ($this->xmlDocument->childNodes as $child) {\n            if ($child->nodeType === XML_DOCUMENT_TYPE_NODE) {\n                $child->parentNode->removeChild($child);\n            }\n        }\n    }\n\n    /**\n     * Start the cleaning with tags, then we move onto attributes and hrefs later\n     *\n     * @param \\DOMNodeList $elements\n     */\n    protected function startClean(\\DOMNodeList $elements)\n    {\n        // loop through all elements\n        // we do this backwards so we don't skip anything if we delete a node\n        // see comments at: http://php.net/manual/en/class.domnamednodemap.php\n        for ($i = $elements->length - 1; $i >= 0; $i--) {\n            /** @var \\DOMElement $currentElement */\n            $currentElement = $elements->item($i);\n\n            // If the tag isn't in the whitelist, remove it and continue with next iteration\n            if (!in_array(strtolower($currentElement->tagName), $this->allowedTags)) {\n                $currentElement->parentNode->removeChild($currentElement);\n                $this->xmlIssues[] = array(\n                    'message' => 'Suspicious tag \\'' . $currentElement->tagName . '\\'',\n                    'line' => $currentElement->getLineNo(),\n                );\n                continue;\n            }\n\n            $this->cleanAttributesOnWhitelist($currentElement);\n\n            $this->cleanXlinkHrefs($currentElement);\n\n            $this->cleanHrefs($currentElement);\n\n            if ($this->isTaggedInvalid($currentElement)) {\n                $currentElement->parentNode->removeChild($currentElement);\n                $this->xmlIssues[] = array(\n                    'message' => 'Invalid \\'' . $currentElement->tagName . '\\'',\n                    'line' => $currentElement->getLineNo(),\n                );\n                continue;\n            }\n\n            if (strtolower($currentElement->tagName) === 'use') {\n                if ($this->isUseTagDirty($currentElement)\n                    || $this->isUseTagExceedingThreshold($currentElement)\n                ) {\n                    $currentElement->parentNode->removeChild($currentElement);\n                    $this->xmlIssues[] = array(\n                        'message' => 'Suspicious \\'' . $currentElement->tagName . '\\'',\n                        'line' => $currentElement->getLineNo(),\n                    );\n                    continue;\n                }\n            }\n        }\n    }\n\n    /**\n     * Only allow attributes that are on the whitelist\n     *\n     * @param \\DOMElement $element\n     */\n    protected function cleanAttributesOnWhitelist(\\DOMElement $element)\n    {\n        for ($x = $element->attributes->length - 1; $x >= 0; $x--) {\n            // get attribute name\n            $attrName = $element->attributes->item($x)->name;\n\n            // Remove attribute if not in whitelist\n            if (!in_array(strtolower($attrName), $this->allowedAttrs) && !$this->isAriaAttribute(strtolower($attrName)) && !$this->isDataAttribute(strtolower($attrName))) {\n\n                $element->removeAttribute($attrName);\n                $this->xmlIssues[] = array(\n                    'message' => 'Suspicious attribute \\'' . $attrName . '\\'',\n                    'line' => $element->getLineNo(),\n                );\n            }\n\n            // Do we want to strip remote references?\n            if($this->removeRemoteReferences) {\n                // Remove attribute if it has a remote reference\n                if (isset($element->attributes->item($x)->value) && $this->hasRemoteReference($element->attributes->item($x)->value)) {\n                    $element->removeAttribute($attrName);\n                    $this->xmlIssues[] = array(\n                        'message' => 'Suspicious attribute \\'' . $attrName . '\\'',\n                        'line' => $element->getLineNo(),\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Clean the xlink:hrefs of script and data embeds\n     *\n     * @param \\DOMElement $element\n     */\n    protected function cleanXlinkHrefs(\\DOMElement $element)\n    {\n        $xlinks = $element->getAttributeNS('http://www.w3.org/1999/xlink', 'href');\n        if (preg_match(self::SCRIPT_REGEX, $xlinks) === 1) {\n            if (!in_array(substr($xlinks, 0, 14), array(\n                'data:image/png', // PNG\n                'data:image/gif', // GIF\n                'data:image/jpg', // JPG\n                'data:image/jpe', // JPEG\n                'data:image/pjp', // PJPEG\n            ))) {\n                $element->removeAttributeNS( 'http://www.w3.org/1999/xlink', 'href' );\n                $this->xmlIssues[] = array(\n                    'message' => 'Suspicious attribute \\'href\\'',\n                    'line' => $element->getLineNo(),\n                );\n\n\n            }\n        }\n    }\n\n    /**\n     * Clean the hrefs of script and data embeds\n     *\n     * @param \\DOMElement $element\n     */\n    protected function cleanHrefs(\\DOMElement $element)\n    {\n        $href = $element->getAttribute('href');\n        if (preg_match(self::SCRIPT_REGEX, $href) === 1) {\n            $element->removeAttribute('href');\n            $this->xmlIssues[] = array(\n                'message' => 'Suspicious attribute \\'href\\'',\n                'line' => $element->getLineNo(),\n            );\n        }\n    }\n\n    /**\n     * Removes non-printable ASCII characters from string & trims it\n     *\n     * @param string $value\n     * @return bool\n     */\n    protected function removeNonPrintableCharacters($value)\n    {\n        return trim(preg_replace('/[^ -~]/xu','',$value));\n    }\n\n    /**\n     * Does this attribute value have a remote reference?\n     *\n     * @param $value\n     * @return bool\n     */\n    protected function hasRemoteReference($value)\n    {\n        $value = $this->removeNonPrintableCharacters($value);\n\n        $wrapped_in_url = preg_match('~^url\\(\\s*[\\'\"]\\s*(.*)\\s*[\\'\"]\\s*\\)$~xi', $value, $match);\n        if (!$wrapped_in_url){\n            return false;\n        }\n\n        $value = trim($match[1], '\\'\"');\n\n        return preg_match('~^((https?|ftp|file):)?//~xi', $value);\n    }\n\n    /**\n     * Should we minify the output?\n     *\n     * @param bool $shouldMinify\n     */\n    public function minify($shouldMinify = false)\n    {\n        $this->minifyXML = (bool) $shouldMinify;\n    }\n\n    /**\n     * Should we remove the XML tag in the header?\n     *\n     * @param bool $removeXMLTag\n     */\n    public function removeXMLTag($removeXMLTag = false)\n    {\n        $this->removeXMLTag = (bool) $removeXMLTag;\n    }\n\n    /**\n     * Whether `<use ... xlink:href=\"#identifier\">` elements shall be\n     * removed in case expansion would exceed this threshold.\n     *\n     * @param int $useThreshold\n     */\n    public function useThreshold($useThreshold = 1000)\n    {\n        $this->useThreshold = (int)$useThreshold;\n    }\n\n    /**\n     * Check to see if an attribute is an aria attribute or not\n     *\n     * @param $attributeName\n     *\n     * @return bool\n     */\n    protected function isAriaAttribute($attributeName)\n    {\n        return strpos($attributeName, 'aria-') === 0;\n    }\n\n    /**\n     * Check to see if an attribute is an data attribute or not\n     *\n     * @param $attributeName\n     *\n     * @return bool\n     */\n    protected function isDataAttribute($attributeName)\n    {\n        return strpos($attributeName, 'data-') === 0;\n    }\n\n    /**\n     * Determines whether element is used in a Subject that has the \"invalid\" tag.\n     *\n     * @param \\DOMElement $element\n     * @return bool\n     */\n    protected function isTaggedInvalid(\\DOMElement $element)\n    {\n        $subject = $this->elementReferenceResolver->findByElement($element, true);\n        return $subject !== null && $subject->matchesTags([Subject::TAG_INVALID]);\n    }\n\n    /**\n     * Make sure our use tag is only referencing internal resources\n     *\n     * @param \\DOMElement $element\n     * @return bool\n     */\n    protected function isUseTagDirty(\\DOMElement $element)\n    {\n        $href = Helper::getElementHref($element);\n        return $href && strpos($href, '#') !== 0;\n    }\n\n    /**\n     * Determines whether `<use ... xlink:href=\"#identifier\">` is expanded\n     * recursively in order to create DoS scenarios. The amount of a actually\n     * used element needs to be below `$this->useThreshold`.\n     *\n     * @param \\DOMElement $element\n     * @return bool\n     */\n    protected function isUseTagExceedingThreshold(\\DOMElement $element)\n    {\n        if ($this->useThreshold <= 0) {\n            return false;\n        }\n        $useId = Helper::extractIdReferenceFromHref(\n            Helper::getElementHref($element)\n        );\n        if ($useId === null) {\n            return false;\n        }\n        foreach ($this->elementReferenceResolver->findByElementId($useId) as $subject) {\n            if ($subject->countUse() >= $this->useThreshold) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" height=\"600px\" id=\"Layer_1\" width=\"600px\" x=\"0px\" y=\"0px\" xml:space=\"preserve\">\n    <a>test 1</a>\n    <a>test 2</a>\n    <a href=\"#test3\">test 3</a>\n    <a xlink:href=\"#test\">test 4</a>\n\n    <a>test 5</a>\n    <a>test 6</a>\n</svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" height=\"600px\" id=\"Layer_1\" width=\"600px\" x=\"0px\" y=\"0px\" xml:space=\"preserve\">\n    <a href=\"javascript:alert(2)\">test 1</a>\n    <a xlink:href=\"javascript:alert(2)\">test 2</a>\n    <a href=\"#test3\">test 3</a>\n    <a xlink:href=\"#test\">test 4</a>\n\n    <a href=\"data:data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' onload='alert(88)'%3E%3C/svg%3E\">test 5</a>\n    <a xlink:href=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' onload='alert(88)'%3E%3C/svg%3E\">test 6</a>\n</svg>"], "fixing_code": ["<?php\n\nnamespace enshrined\\svgSanitize;\n\nuse enshrined\\svgSanitize\\data\\AllowedAttributes;\nuse enshrined\\svgSanitize\\data\\AllowedTags;\nuse enshrined\\svgSanitize\\data\\AttributeInterface;\nuse enshrined\\svgSanitize\\data\\TagInterface;\nuse enshrined\\svgSanitize\\data\\XPath;\nuse enshrined\\svgSanitize\\ElementReference\\Resolver;\nuse enshrined\\svgSanitize\\ElementReference\\Subject;\n\n/**\n * Class Sanitizer\n *\n * @package enshrined\\svgSanitize\n */\nclass Sanitizer\n{\n\n    /**\n     * Regex to catch script and data values in attributes\n     */\n    const SCRIPT_REGEX = '/(?:\\w+script|data)(?:\\s)?:/xi';\n\n    /**\n     * @var \\DOMDocument\n     */\n    protected $xmlDocument;\n\n    /**\n     * @var array\n     */\n    protected $allowedTags;\n\n    /**\n     * @var array\n     */\n    protected $allowedAttrs;\n\n    /**\n     * @var\n     */\n    protected $xmlLoaderValue;\n\n    /**\n     * @var bool\n     */\n    protected $minifyXML = false;\n\n    /**\n     * @var bool\n     */\n    protected $removeRemoteReferences = false;\n\n    /**\n     * @var int\n     */\n    protected $useThreshold = 1000;\n\n    /**\n     * @var bool\n     */\n    protected $removeXMLTag = false;\n\n    /**\n     * @var int\n     */\n    protected $xmlOptions = LIBXML_NOEMPTYTAG;\n\n    /**\n     * @var array\n     */\n    protected $xmlIssues = array();\n\n    /**\n     * @var Resolver\n     */\n    protected $elementReferenceResolver;\n\n    /**\n     *\n     */\n    function __construct()\n    {\n        // Load default tags/attributes\n        $this->allowedAttrs = array_map('strtolower', AllowedAttributes::getAttributes());\n        $this->allowedTags = array_map('strtolower', AllowedTags::getTags());\n    }\n\n    /**\n     * Set up the DOMDocument\n     */\n    protected function resetInternal()\n    {\n        $this->xmlDocument = new \\DOMDocument();\n        $this->xmlDocument->preserveWhiteSpace = false;\n        $this->xmlDocument->strictErrorChecking = false;\n        $this->xmlDocument->formatOutput = !$this->minifyXML;\n    }\n\n    /**\n     * Set XML options to use when saving XML\n     * See: DOMDocument::saveXML\n     *\n     * @param int  $xmlOptions\n     */\n    public function setXMLOptions($xmlOptions)\n    {\n        $this->xmlOptions = $xmlOptions;\n    }\n\n    /**\n     * Get XML options to use when saving XML\n     * See: DOMDocument::saveXML\n     *\n     * @return int\n     */\n    public function getXMLOptions()\n    {\n        return $this->xmlOptions;\n    }\n\n    /**\n     * Get the array of allowed tags\n     *\n     * @return array\n     */\n    public function getAllowedTags()\n    {\n        return $this->allowedTags;\n    }\n\n    /**\n     * Set custom allowed tags\n     *\n     * @param TagInterface $allowedTags\n     */\n    public function setAllowedTags(TagInterface $allowedTags)\n    {\n        $this->allowedTags = array_map('strtolower', $allowedTags::getTags());\n    }\n\n    /**\n     * Get the array of allowed attributes\n     *\n     * @return array\n     */\n    public function getAllowedAttrs()\n    {\n        return $this->allowedAttrs;\n    }\n\n    /**\n     * Set custom allowed attributes\n     *\n     * @param AttributeInterface $allowedAttrs\n     */\n    public function setAllowedAttrs(AttributeInterface $allowedAttrs)\n    {\n        $this->allowedAttrs = array_map('strtolower', $allowedAttrs::getAttributes());\n    }\n\n    /**\n     * Should we remove references to remote files?\n     *\n     * @param bool $removeRemoteRefs\n     */\n    public function removeRemoteReferences($removeRemoteRefs = false)\n    {\n        $this->removeRemoteReferences = $removeRemoteRefs;\n    }\n\n    /**\n     * Get XML issues.\n     *\n     * @return array\n     */\n    public function getXmlIssues() {\n        return $this->xmlIssues;\n    }\n\n\n    /**\n     * Sanitize the passed string\n     *\n     * @param string $dirty\n     * @return string\n     */\n    public function sanitize($dirty)\n    {\n        // Don't run on an empty string\n        if (empty($dirty)) {\n            return '';\n        }\n\n        // Strip php tags\n        $dirty = preg_replace('/<\\?(=|php)(.+?)\\?>/i', '', $dirty);\n\n        $this->resetInternal();\n        $this->setUpBefore();\n\n        $loaded = $this->xmlDocument->loadXML($dirty);\n\n        // If we couldn't parse the XML then we go no further. Reset and return false\n        if (!$loaded) {\n            $this->resetAfter();\n            return false;\n        }\n\n        $this->removeDoctype();\n\n        // Pre-process all identified elements\n        $xPath = new XPath($this->xmlDocument);\n        $this->elementReferenceResolver = new Resolver($xPath);\n        $this->elementReferenceResolver->collect();\n        // Grab all the elements\n        $allElements = $this->xmlDocument->getElementsByTagName(\"*\");\n\n        // Start the cleaning proccess\n        $this->startClean($allElements);\n\n        // Save cleaned XML to a variable\n        if ($this->removeXMLTag) {\n            $clean = $this->xmlDocument->saveXML($this->xmlDocument->documentElement, $this->xmlOptions);\n        } else {\n            $clean = $this->xmlDocument->saveXML($this->xmlDocument, $this->xmlOptions);\n        }\n\n        $this->resetAfter();\n\n        // Remove any extra whitespaces when minifying\n        if ($this->minifyXML) {\n            $clean = preg_replace('/\\s+/', ' ', $clean);\n        }\n\n        // Return result\n        return $clean;\n    }\n\n    /**\n     * Set up libXML before we start\n     */\n    protected function setUpBefore()\n    {\n        // Turn off the entity loader\n        $this->xmlLoaderValue = libxml_disable_entity_loader(true);\n\n        // Suppress the errors because we don't really have to worry about formation before cleansing\n        libxml_use_internal_errors(true);\n\n        // Reset array of altered XML\n        $this->xmlIssues = array();\n    }\n\n    /**\n     * Reset the class after use\n     */\n    protected function resetAfter()\n    {\n        // Reset the entity loader\n        libxml_disable_entity_loader($this->xmlLoaderValue);\n    }\n\n    /**\n     * Remove the XML Doctype\n     * It may be caught later on output but that seems to be buggy, so we need to make sure it's gone\n     */\n    protected function removeDoctype()\n    {\n        foreach ($this->xmlDocument->childNodes as $child) {\n            if ($child->nodeType === XML_DOCUMENT_TYPE_NODE) {\n                $child->parentNode->removeChild($child);\n            }\n        }\n    }\n\n    /**\n     * Start the cleaning with tags, then we move onto attributes and hrefs later\n     *\n     * @param \\DOMNodeList $elements\n     */\n    protected function startClean(\\DOMNodeList $elements)\n    {\n        // loop through all elements\n        // we do this backwards so we don't skip anything if we delete a node\n        // see comments at: http://php.net/manual/en/class.domnamednodemap.php\n        for ($i = $elements->length - 1; $i >= 0; $i--) {\n            /** @var \\DOMElement $currentElement */\n            $currentElement = $elements->item($i);\n\n            // If the tag isn't in the whitelist, remove it and continue with next iteration\n            if (!in_array(strtolower($currentElement->tagName), $this->allowedTags)) {\n                $currentElement->parentNode->removeChild($currentElement);\n                $this->xmlIssues[] = array(\n                    'message' => 'Suspicious tag \\'' . $currentElement->tagName . '\\'',\n                    'line' => $currentElement->getLineNo(),\n                );\n                continue;\n            }\n\n            $this->cleanAttributesOnWhitelist($currentElement);\n\n            $this->cleanXlinkHrefs($currentElement);\n\n            $this->cleanHrefs($currentElement);\n\n            if ($this->isTaggedInvalid($currentElement)) {\n                $currentElement->parentNode->removeChild($currentElement);\n                $this->xmlIssues[] = array(\n                    'message' => 'Invalid \\'' . $currentElement->tagName . '\\'',\n                    'line' => $currentElement->getLineNo(),\n                );\n                continue;\n            }\n\n            if (strtolower($currentElement->tagName) === 'use') {\n                if ($this->isUseTagDirty($currentElement)\n                    || $this->isUseTagExceedingThreshold($currentElement)\n                ) {\n                    $currentElement->parentNode->removeChild($currentElement);\n                    $this->xmlIssues[] = array(\n                        'message' => 'Suspicious \\'' . $currentElement->tagName . '\\'',\n                        'line' => $currentElement->getLineNo(),\n                    );\n                    continue;\n                }\n            }\n        }\n    }\n\n    /**\n     * Only allow attributes that are on the whitelist\n     *\n     * @param \\DOMElement $element\n     */\n    protected function cleanAttributesOnWhitelist(\\DOMElement $element)\n    {\n        for ($x = $element->attributes->length - 1; $x >= 0; $x--) {\n            // get attribute name\n            $attrName = $element->attributes->item($x)->name;\n\n            // Remove attribute if not in whitelist\n            if (!in_array(strtolower($attrName), $this->allowedAttrs) && !$this->isAriaAttribute(strtolower($attrName)) && !$this->isDataAttribute(strtolower($attrName))) {\n\n                $element->removeAttribute($attrName);\n                $this->xmlIssues[] = array(\n                    'message' => 'Suspicious attribute \\'' . $attrName . '\\'',\n                    'line' => $element->getLineNo(),\n                );\n            }\n\n            // Do we want to strip remote references?\n            if($this->removeRemoteReferences) {\n                // Remove attribute if it has a remote reference\n                if (isset($element->attributes->item($x)->value) && $this->hasRemoteReference($element->attributes->item($x)->value)) {\n                    $element->removeAttribute($attrName);\n                    $this->xmlIssues[] = array(\n                        'message' => 'Suspicious attribute \\'' . $attrName . '\\'',\n                        'line' => $element->getLineNo(),\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Clean the xlink:hrefs of script and data embeds\n     *\n     * @param \\DOMElement $element\n     */\n    protected function cleanXlinkHrefs(\\DOMElement $element)\n    {\n        $xlinks = $element->getAttributeNS('http://www.w3.org/1999/xlink', 'href');\n        if (preg_match(self::SCRIPT_REGEX, $xlinks) === 1) {\n            if (!in_array(substr($xlinks, 0, 14), array(\n                'data:image/png', // PNG\n                'data:image/gif', // GIF\n                'data:image/jpg', // JPG\n                'data:image/jpe', // JPEG\n                'data:image/pjp', // PJPEG\n            ))) {\n                $element->removeAttributeNS( 'http://www.w3.org/1999/xlink', 'href' );\n                $this->xmlIssues[] = array(\n                    'message' => 'Suspicious attribute \\'href\\'',\n                    'line' => $element->getLineNo(),\n                );\n\n\n            }\n        }\n    }\n\n    /**\n     * Clean the hrefs of script and data embeds\n     *\n     * @param \\DOMElement $element\n     */\n    protected function cleanHrefs(\\DOMElement $element)\n    {\n        $href = $element->getAttribute('href');\n        if (preg_match(self::SCRIPT_REGEX, $href) === 1) {\n            $element->removeAttribute('href');\n            $this->xmlIssues[] = array(\n                'message' => 'Suspicious attribute \\'href\\'',\n                'line' => $element->getLineNo(),\n            );\n        }\n    }\n\n    /**\n     * Removes non-printable ASCII characters from string & trims it\n     *\n     * @param string $value\n     * @return bool\n     */\n    protected function removeNonPrintableCharacters($value)\n    {\n        return trim(preg_replace('/[^ -~]/xu','',$value));\n    }\n\n    /**\n     * Does this attribute value have a remote reference?\n     *\n     * @param $value\n     * @return bool\n     */\n    protected function hasRemoteReference($value)\n    {\n        $value = $this->removeNonPrintableCharacters($value);\n\n        $wrapped_in_url = preg_match('~^url\\(\\s*[\\'\"]\\s*(.*)\\s*[\\'\"]\\s*\\)$~xi', $value, $match);\n        if (!$wrapped_in_url){\n            return false;\n        }\n\n        $value = trim($match[1], '\\'\"');\n\n        return preg_match('~^((https?|ftp|file):)?//~xi', $value);\n    }\n\n    /**\n     * Should we minify the output?\n     *\n     * @param bool $shouldMinify\n     */\n    public function minify($shouldMinify = false)\n    {\n        $this->minifyXML = (bool) $shouldMinify;\n    }\n\n    /**\n     * Should we remove the XML tag in the header?\n     *\n     * @param bool $removeXMLTag\n     */\n    public function removeXMLTag($removeXMLTag = false)\n    {\n        $this->removeXMLTag = (bool) $removeXMLTag;\n    }\n\n    /**\n     * Whether `<use ... xlink:href=\"#identifier\">` elements shall be\n     * removed in case expansion would exceed this threshold.\n     *\n     * @param int $useThreshold\n     */\n    public function useThreshold($useThreshold = 1000)\n    {\n        $this->useThreshold = (int)$useThreshold;\n    }\n\n    /**\n     * Check to see if an attribute is an aria attribute or not\n     *\n     * @param $attributeName\n     *\n     * @return bool\n     */\n    protected function isAriaAttribute($attributeName)\n    {\n        return strpos($attributeName, 'aria-') === 0;\n    }\n\n    /**\n     * Check to see if an attribute is an data attribute or not\n     *\n     * @param $attributeName\n     *\n     * @return bool\n     */\n    protected function isDataAttribute($attributeName)\n    {\n        return strpos($attributeName, 'data-') === 0;\n    }\n\n    /**\n     * Determines whether element is used in a Subject that has the \"invalid\" tag.\n     *\n     * @param \\DOMElement $element\n     * @return bool\n     */\n    protected function isTaggedInvalid(\\DOMElement $element)\n    {\n        $subject = $this->elementReferenceResolver->findByElement($element, true);\n        return $subject !== null && $subject->matchesTags([Subject::TAG_INVALID]);\n    }\n\n    /**\n     * Make sure our use tag is only referencing internal resources\n     *\n     * @param \\DOMElement $element\n     * @return bool\n     */\n    protected function isUseTagDirty(\\DOMElement $element)\n    {\n        $href = Helper::getElementHref($element);\n        return $href && strpos($href, '#') !== 0;\n    }\n\n    /**\n     * Determines whether `<use ... xlink:href=\"#identifier\">` is expanded\n     * recursively in order to create DoS scenarios. The amount of a actually\n     * used element needs to be below `$this->useThreshold`.\n     *\n     * @param \\DOMElement $element\n     * @return bool\n     */\n    protected function isUseTagExceedingThreshold(\\DOMElement $element)\n    {\n        if ($this->useThreshold <= 0) {\n            return false;\n        }\n        $useId = Helper::extractIdReferenceFromHref(\n            Helper::getElementHref($element)\n        );\n        if ($useId === null) {\n            return false;\n        }\n        foreach ($this->elementReferenceResolver->findByElementId($useId) as $subject) {\n            if ($subject->countUse() >= $this->useThreshold) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" height=\"600px\" id=\"Layer_1\" width=\"600px\" x=\"0px\" y=\"0px\" xml:space=\"preserve\">\n    <a>test 1</a>\n    <a>test 2</a>\n    <a href=\"#test3\">test 3</a>\n    <a xlink:href=\"#test\">test 4</a>\n\n    <a>test 5</a>\n    <a>test 6</a>\n\n    <a>test 7</a>\n</svg>", "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" height=\"600px\" id=\"Layer_1\" width=\"600px\" x=\"0px\" y=\"0px\" xml:space=\"preserve\">\n    <a href=\"javascript:alert(2)\">test 1</a>\n    <a xlink:href=\"javascript:alert(2)\">test 2</a>\n    <a href=\"#test3\">test 3</a>\n    <a xlink:href=\"#test\">test 4</a>\n\n    <a href=\"data:data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' onload='alert(88)'%3E%3C/svg%3E\">test 5</a>\n    <a xlink:href=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' onload='alert(88)'%3E%3C/svg%3E\">test 6</a>\n\n    <a href=\"javascript&#9;:alert(document.domain)\">test 7</a>\n</svg>"], "filenames": ["src/Sanitizer.php", "tests/data/hrefCleanOne.svg", "tests/data/hrefTestOne.svg"], "buggy_code_start_loc": [24, 8, 8], "buggy_code_end_loc": [25, 8, 8], "fixing_code_start_loc": [24, 9, 9], "fixing_code_end_loc": [25, 11, 11], "type": "CWE-79", "message": "darylldoyle svg-sanitizer before 0.12.0 mishandles script and data values in attributes, as demonstrated by unexpected whitespace such as in the javascript&#9;:alert substring.", "other": {"cve": {"id": "CVE-2019-18857", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-11T15:15:12.530", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "darylldoyle svg-sanitizer before 0.12.0 mishandles script and data values in attributes, as demonstrated by unexpected whitespace such as in the javascript&#9;:alert substring."}, {"lang": "es", "value": "darylldoyle svg-sanitizer versiones anteriores 0.12.0, maneja inapropiadamente un script y valores de datos en los atributos, como es demostrado por un espacio en blanco inesperado tal y como en la subcadena javascript\t:alert."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:svg-sanitizer_project:svg-sanitizer:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.12.0", "matchCriteriaId": "8286A45D-B77F-4E60-A441-F30F46E0CF9C"}]}]}], "references": [{"url": "https://github.com/darylldoyle/svg-sanitizer/commit/51ca4b713f3706d6b27769c6296bbc0c28a5bbd0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/darylldoyle/svg-sanitizer/compare/0.11.0...0.12.0", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/darylldoyle/svg-sanitizer/commit/51ca4b713f3706d6b27769c6296bbc0c28a5bbd0"}}