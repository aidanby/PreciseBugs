{"buggy_code": ["/*\n   Copyright The containerd Authors.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npackage encryption\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math/rand\"\n\n\t\"github.com/containerd/containerd/content\"\n\t\"github.com/containerd/containerd/errdefs\"\n\t\"github.com/containerd/containerd/images\"\n\t\"github.com/containerd/containerd/images/converter\"\n\t\"github.com/containerd/containerd/platforms\"\n\n\t\"github.com/containers/ocicrypt\"\n\tencconfig \"github.com/containers/ocicrypt/config\"\n\tencocispec \"github.com/containers/ocicrypt/spec\"\n\t\"github.com/opencontainers/go-digest\"\n\t\"github.com/opencontainers/image-spec/specs-go\"\n\tocispec \"github.com/opencontainers/image-spec/specs-go/v1\"\n)\n\ntype cryptoOp int\n\nconst (\n\tcryptoOpEncrypt    cryptoOp = iota\n\tcryptoOpDecrypt             = iota\n\tcryptoOpUnwrapOnly          = iota\n)\n\n// LayerFilter allows to select Layers by certain criteria\ntype LayerFilter func(desc ocispec.Descriptor) bool\n\n// IsEncryptedDiff returns true if mediaType is a known encrypted media type.\nfunc IsEncryptedDiff(ctx context.Context, mediaType string) bool {\n\tswitch mediaType {\n\tcase encocispec.MediaTypeLayerGzipEnc, encocispec.MediaTypeLayerEnc:\n\t\treturn true\n\t}\n\treturn false\n}\n\n// HasEncryptedLayer returns true if any LayerInfo indicates that the layer is encrypted\nfunc HasEncryptedLayer(ctx context.Context, layerInfos []ocispec.Descriptor) bool {\n\tfor i := 0; i < len(layerInfos); i++ {\n\t\tif IsEncryptedDiff(ctx, layerInfos[i].MediaType) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// encryptLayer encrypts the layer using the CryptoConfig and creates a new OCI Descriptor.\n// A call to this function may also only manipulate the wrapped keys list.\n// The caller is expected to store the returned encrypted data and OCI Descriptor\nfunc encryptLayer(cc *encconfig.CryptoConfig, dataReader content.ReaderAt, desc ocispec.Descriptor) (ocispec.Descriptor, io.Reader, ocicrypt.EncryptLayerFinalizer, error) {\n\tvar (\n\t\tsize int64\n\t\td    digest.Digest\n\t\terr  error\n\t)\n\n\tencLayerReader, encLayerFinalizer, err := ocicrypt.EncryptLayer(cc.EncryptConfig, ocicrypt.ReaderFromReaderAt(dataReader), desc)\n\tif err != nil {\n\t\treturn ocispec.Descriptor{}, nil, nil, err\n\t}\n\n\t// were data touched ?\n\tif encLayerReader != nil {\n\t\tsize = 0\n\t\td = \"\"\n\t} else {\n\t\tsize = desc.Size\n\t\td = desc.Digest\n\t}\n\n\tnewDesc := ocispec.Descriptor{\n\t\tDigest:   d,\n\t\tSize:     size,\n\t\tPlatform: desc.Platform,\n\t}\n\n\tswitch desc.MediaType {\n\tcase images.MediaTypeDockerSchema2LayerGzip:\n\t\tnewDesc.MediaType = encocispec.MediaTypeLayerGzipEnc\n\tcase images.MediaTypeDockerSchema2Layer:\n\t\tnewDesc.MediaType = encocispec.MediaTypeLayerEnc\n\tcase encocispec.MediaTypeLayerGzipEnc:\n\t\tnewDesc.MediaType = encocispec.MediaTypeLayerGzipEnc\n\tcase encocispec.MediaTypeLayerEnc:\n\t\tnewDesc.MediaType = encocispec.MediaTypeLayerEnc\n\n\t// TODO: Mediatypes to be added in ocispec\n\tcase ocispec.MediaTypeImageLayerGzip:\n\t\tnewDesc.MediaType = encocispec.MediaTypeLayerGzipEnc\n\tcase ocispec.MediaTypeImageLayer:\n\t\tnewDesc.MediaType = encocispec.MediaTypeLayerEnc\n\n\tdefault:\n\t\treturn ocispec.Descriptor{}, nil, nil, fmt.Errorf(\"unsupporter layer MediaType: %s\", desc.MediaType)\n\t}\n\n\treturn newDesc, encLayerReader, encLayerFinalizer, nil\n}\n\n// DecryptLayer decrypts the layer using the DecryptConfig and creates a new OCI Descriptor.\n// The caller is expected to store the returned plain data and OCI Descriptor\nfunc DecryptLayer(dc *encconfig.DecryptConfig, dataReader io.Reader, desc ocispec.Descriptor, unwrapOnly bool) (ocispec.Descriptor, io.Reader, digest.Digest, error) {\n\tresultReader, layerDigest, err := ocicrypt.DecryptLayer(dc, dataReader, desc, unwrapOnly)\n\tif err != nil || unwrapOnly {\n\t\treturn ocispec.Descriptor{}, nil, \"\", err\n\t}\n\n\tnewDesc := ocispec.Descriptor{\n\t\tSize:     0,\n\t\tPlatform: desc.Platform,\n\t}\n\n\tswitch desc.MediaType {\n\tcase encocispec.MediaTypeLayerGzipEnc:\n\t\tnewDesc.MediaType = images.MediaTypeDockerSchema2LayerGzip\n\tcase encocispec.MediaTypeLayerEnc:\n\t\tnewDesc.MediaType = images.MediaTypeDockerSchema2Layer\n\tdefault:\n\t\treturn ocispec.Descriptor{}, nil, \"\", fmt.Errorf(\"unsupporter layer MediaType: %s\", desc.MediaType)\n\t}\n\treturn newDesc, resultReader, layerDigest, nil\n}\n\n// decryptLayer decrypts the layer using the CryptoConfig and creates a new OCI Descriptor.\n// The caller is expected to store the returned plain data and OCI Descriptor\nfunc decryptLayer(cc *encconfig.CryptoConfig, dataReader content.ReaderAt, desc ocispec.Descriptor, unwrapOnly bool) (ocispec.Descriptor, io.Reader, error) {\n\tresultReader, d, err := ocicrypt.DecryptLayer(cc.DecryptConfig, ocicrypt.ReaderFromReaderAt(dataReader), desc, unwrapOnly)\n\tif err != nil || unwrapOnly {\n\t\treturn ocispec.Descriptor{}, nil, err\n\t}\n\n\tnewDesc := ocispec.Descriptor{\n\t\tDigest:   d,\n\t\tSize:     0,\n\t\tPlatform: desc.Platform,\n\t}\n\n\tswitch desc.MediaType {\n\tcase encocispec.MediaTypeLayerGzipEnc:\n\t\tnewDesc.MediaType = images.MediaTypeDockerSchema2LayerGzip\n\tcase encocispec.MediaTypeLayerEnc:\n\t\tnewDesc.MediaType = images.MediaTypeDockerSchema2Layer\n\tdefault:\n\t\treturn ocispec.Descriptor{}, nil, fmt.Errorf(\"unsupporter layer MediaType: %s\", desc.MediaType)\n\t}\n\treturn newDesc, resultReader, nil\n}\n\n// cryptLayer handles the changes due to encryption or decryption of a layer\nfunc cryptLayer(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *encconfig.CryptoConfig, cryptoOp cryptoOp) (ocispec.Descriptor, error) {\n\tvar (\n\t\tresultReader      io.Reader\n\t\tnewDesc           ocispec.Descriptor\n\t\tencLayerFinalizer ocicrypt.EncryptLayerFinalizer\n\t)\n\n\tdataReader, err := cs.ReaderAt(ctx, desc)\n\tif err != nil {\n\t\treturn ocispec.Descriptor{}, err\n\t}\n\tdefer dataReader.Close()\n\n\tif cryptoOp == cryptoOpEncrypt {\n\t\tnewDesc, resultReader, encLayerFinalizer, err = encryptLayer(cc, dataReader, desc)\n\t} else {\n\t\tnewDesc, resultReader, err = decryptLayer(cc, dataReader, desc, cryptoOp == cryptoOpUnwrapOnly)\n\t}\n\tif err != nil || cryptoOp == cryptoOpUnwrapOnly {\n\t\treturn ocispec.Descriptor{}, err\n\t}\n\n\tnewDesc.Annotations = ocicrypt.FilterOutAnnotations(desc.Annotations)\n\n\t// some operations, such as changing recipients, may not touch the layer at all\n\tif resultReader != nil {\n\t\tvar ref string\n\t\t// If we have the digest, write blob with checks\n\t\thaveDigest := newDesc.Digest.String() != \"\"\n\t\tif haveDigest {\n\t\t\tref = fmt.Sprintf(\"layer-%s\", newDesc.Digest.String())\n\t\t} else {\n\t\t\tref = fmt.Sprintf(\"blob-%d-%d\", rand.Int(), rand.Int())\n\t\t}\n\n\t\tif haveDigest {\n\t\t\tif err := content.WriteBlob(ctx, cs, ref, resultReader, newDesc); err != nil {\n\t\t\t\treturn ocispec.Descriptor{}, fmt.Errorf(\"failed to write config: %w\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tnewDesc.Digest, newDesc.Size, err = ingestReader(ctx, cs, ref, resultReader)\n\t\t\tif err != nil {\n\t\t\t\treturn ocispec.Descriptor{}, err\n\t\t\t}\n\t\t}\n\t}\n\n\t// After performing encryption, call finalizer to get annotations\n\tif encLayerFinalizer != nil {\n\t\tannotations, err := encLayerFinalizer()\n\t\tif err != nil {\n\t\t\treturn ocispec.Descriptor{}, fmt.Errorf(\"error getting annotations from encLayer finalizer: %w\", err)\n\t\t}\n\t\tfor k, v := range annotations {\n\t\t\tnewDesc.Annotations[k] = v\n\t\t}\n\t}\n\treturn newDesc, err\n}\n\nfunc ingestReader(ctx context.Context, cs content.Ingester, ref string, r io.Reader) (digest.Digest, int64, error) {\n\tcw, err := content.OpenWriter(ctx, cs, content.WithRef(ref))\n\tif err != nil {\n\t\treturn \"\", 0, fmt.Errorf(\"failed to open writer: %w\", err)\n\t}\n\tdefer cw.Close()\n\n\tif _, err := content.CopyReader(cw, r); err != nil {\n\t\treturn \"\", 0, fmt.Errorf(\"copy failed: %w\", err)\n\t}\n\n\tst, err := cw.Status()\n\tif err != nil {\n\t\treturn \"\", 0, fmt.Errorf(\"failed to get state: %w\", err)\n\t}\n\n\tif err := cw.Commit(ctx, st.Offset, \"\"); err != nil {\n\t\tif !errdefs.IsAlreadyExists(err) {\n\t\t\treturn \"\", 0, fmt.Errorf(\"failed commit on ref %q: %w\", ref, err)\n\t\t}\n\t}\n\n\treturn cw.Digest(), st.Offset, nil\n}\n\n// Encrypt or decrypt all the Children of a given descriptor\nfunc cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *encconfig.CryptoConfig, lf LayerFilter, cryptoOp cryptoOp, thisPlatform *ocispec.Platform) (ocispec.Descriptor, bool, error) {\n\tchildren, err := images.Children(ctx, cs, desc)\n\tif err != nil {\n\t\tif errdefs.IsNotFound(err) {\n\t\t\treturn desc, false, nil\n\t\t}\n\t\treturn ocispec.Descriptor{}, false, err\n\t}\n\n\tvar newLayers []ocispec.Descriptor\n\tvar config ocispec.Descriptor\n\tmodified := false\n\n\tfor _, child := range children {\n\t\t// we only encrypt child layers and have to update their parents if encryption happened\n\t\tswitch child.MediaType {\n\t\tcase images.MediaTypeDockerSchema2Config, ocispec.MediaTypeImageConfig:\n\t\t\tconfig = child\n\t\tcase images.MediaTypeDockerSchema2LayerGzip, images.MediaTypeDockerSchema2Layer,\n\t\t\tocispec.MediaTypeImageLayerGzip, ocispec.MediaTypeImageLayer:\n\t\t\tif cryptoOp == cryptoOpEncrypt && lf(child) {\n\t\t\t\tnl, err := cryptLayer(ctx, cs, child, cc, cryptoOp)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn ocispec.Descriptor{}, false, err\n\t\t\t\t}\n\t\t\t\tmodified = true\n\t\t\t\tnewLayers = append(newLayers, nl)\n\t\t\t} else {\n\t\t\t\tnewLayers = append(newLayers, child)\n\t\t\t}\n\t\tcase encocispec.MediaTypeLayerGzipEnc, encocispec.MediaTypeLayerEnc:\n\t\t\t// this one can be decrypted but also its recipients list changed\n\t\t\tif lf(child) {\n\t\t\t\tnl, err := cryptLayer(ctx, cs, child, cc, cryptoOp)\n\t\t\t\tif err != nil || cryptoOp == cryptoOpUnwrapOnly {\n\t\t\t\t\treturn ocispec.Descriptor{}, false, err\n\t\t\t\t}\n\t\t\t\tmodified = true\n\t\t\t\tnewLayers = append(newLayers, nl)\n\t\t\t} else {\n\t\t\t\tnewLayers = append(newLayers, child)\n\t\t\t}\n\t\tcase images.MediaTypeDockerSchema2LayerForeign, images.MediaTypeDockerSchema2LayerForeignGzip:\n\t\t\t// never encrypt/decrypt\n\t\t\tnewLayers = append(newLayers, child)\n\t\tdefault:\n\t\t\treturn ocispec.Descriptor{}, false, fmt.Errorf(\"bad/unhandled MediaType %s in encryptChildren\", child.MediaType)\n\t\t}\n\t}\n\n\tif modified && len(newLayers) > 0 {\n\t\tnewManifest := ocispec.Manifest{\n\t\t\tVersioned: specs.Versioned{\n\t\t\t\tSchemaVersion: 2,\n\t\t\t},\n\t\t\tConfig: config,\n\t\t\tLayers: newLayers,\n\t\t}\n\n\t\tmb, err := json.MarshalIndent(newManifest, \"\", \"   \")\n\t\tif err != nil {\n\t\t\treturn ocispec.Descriptor{}, false, fmt.Errorf(\"failed to marshal image: %w\", err)\n\t\t}\n\n\t\tnewDesc := ocispec.Descriptor{\n\t\t\tMediaType: ocispec.MediaTypeImageManifest,\n\t\t\tSize:      int64(len(mb)),\n\t\t\tDigest:    digest.Canonical.FromBytes(mb),\n\t\t\tPlatform:  desc.Platform,\n\t\t}\n\n\t\tlabels := map[string]string{}\n\t\tlabels[\"containerd.io/gc.ref.content.0\"] = newManifest.Config.Digest.String()\n\t\tfor i, ch := range newManifest.Layers {\n\t\t\tlabels[fmt.Sprintf(\"containerd.io/gc.ref.content.%d\", i+1)] = ch.Digest.String()\n\t\t}\n\n\t\tref := fmt.Sprintf(\"manifest-%s\", newDesc.Digest.String())\n\n\t\tif err := content.WriteBlob(ctx, cs, ref, bytes.NewReader(mb), newDesc, content.WithLabels(labels)); err != nil {\n\t\t\treturn ocispec.Descriptor{}, false, fmt.Errorf(\"failed to write config: %w\", err)\n\t\t}\n\t\treturn newDesc, true, nil\n\t}\n\n\treturn desc, modified, nil\n}\n\n// cryptManifest encrypts or decrypts the children of a top level manifest\nfunc cryptManifest(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *encconfig.CryptoConfig, lf LayerFilter, cryptoOp cryptoOp) (ocispec.Descriptor, bool, error) {\n\tp, err := content.ReadBlob(ctx, cs, desc)\n\tif err != nil {\n\t\treturn ocispec.Descriptor{}, false, err\n\t}\n\tvar manifest ocispec.Manifest\n\tif err := json.Unmarshal(p, &manifest); err != nil {\n\t\treturn ocispec.Descriptor{}, false, err\n\t}\n\tplatform := platforms.DefaultSpec()\n\tnewDesc, modified, err := cryptChildren(ctx, cs, desc, cc, lf, cryptoOp, &platform)\n\tif err != nil || cryptoOp == cryptoOpUnwrapOnly {\n\t\treturn ocispec.Descriptor{}, false, err\n\t}\n\treturn newDesc, modified, nil\n}\n\n// cryptManifestList encrypts or decrypts the children of a top level manifest list\nfunc cryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *encconfig.CryptoConfig, lf LayerFilter, cryptoOp cryptoOp) (ocispec.Descriptor, bool, error) {\n\t// read the index; if any layer is encrypted and any manifests change we will need to rewrite it\n\tb, err := content.ReadBlob(ctx, cs, desc)\n\tif err != nil {\n\t\treturn ocispec.Descriptor{}, false, err\n\t}\n\n\tvar index ocispec.Index\n\tif err := json.Unmarshal(b, &index); err != nil {\n\t\treturn ocispec.Descriptor{}, false, err\n\t}\n\n\tvar newManifests []ocispec.Descriptor\n\tmodified := false\n\tfor _, manifest := range index.Manifests {\n\t\tnewManifest, m, err := cryptChildren(ctx, cs, manifest, cc, lf, cryptoOp, manifest.Platform)\n\t\tif err != nil || cryptoOp == cryptoOpUnwrapOnly {\n\t\t\treturn ocispec.Descriptor{}, false, err\n\t\t}\n\t\tif m {\n\t\t\tmodified = true\n\t\t}\n\t\tnewManifests = append(newManifests, newManifest)\n\t}\n\n\tif modified {\n\t\t// we need to update the index\n\t\tnewIndex := ocispec.Index{\n\t\t\tVersioned: index.Versioned,\n\t\t\tManifests: newManifests,\n\t\t}\n\n\t\tmb, err := json.MarshalIndent(newIndex, \"\", \"   \")\n\t\tif err != nil {\n\t\t\treturn ocispec.Descriptor{}, false, fmt.Errorf(\"failed to marshal index: %w\", err)\n\t\t}\n\n\t\tnewDesc := ocispec.Descriptor{\n\t\t\tMediaType: ocispec.MediaTypeImageIndex,\n\t\t\tSize:      int64(len(mb)),\n\t\t\tDigest:    digest.Canonical.FromBytes(mb),\n\t\t}\n\n\t\tlabels := map[string]string{}\n\t\tfor i, m := range newIndex.Manifests {\n\t\t\tlabels[fmt.Sprintf(\"containerd.io/gc.ref.content.%d\", i)] = m.Digest.String()\n\t\t}\n\n\t\tref := fmt.Sprintf(\"index-%s\", newDesc.Digest.String())\n\n\t\tif err = content.WriteBlob(ctx, cs, ref, bytes.NewReader(mb), newDesc, content.WithLabels(labels)); err != nil {\n\t\t\treturn ocispec.Descriptor{}, false, fmt.Errorf(\"failed to write index: %w\", err)\n\t\t}\n\t\treturn newDesc, true, nil\n\t}\n\n\treturn desc, false, nil\n}\n\n// cryptImage is the dispatcher to encrypt/decrypt an image; it accepts either an OCI descriptor\n// representing a manifest list or a single manifest\nfunc cryptImage(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *encconfig.CryptoConfig, lf LayerFilter, cryptoOp cryptoOp) (ocispec.Descriptor, bool, error) {\n\tif cc == nil {\n\t\treturn ocispec.Descriptor{}, false, errors.New(\"invalid argument: CryptoConfig must not be nil\")\n\t}\n\tswitch desc.MediaType {\n\tcase ocispec.MediaTypeImageIndex, images.MediaTypeDockerSchema2ManifestList:\n\t\treturn cryptManifestList(ctx, cs, desc, cc, lf, cryptoOp)\n\tcase ocispec.MediaTypeImageManifest, images.MediaTypeDockerSchema2Manifest:\n\t\treturn cryptManifest(ctx, cs, desc, cc, lf, cryptoOp)\n\tdefault:\n\t\treturn ocispec.Descriptor{}, false, fmt.Errorf(\"unhandled media type: %s\", desc.MediaType)\n\t}\n}\n\n// EncryptImage encrypts an image; it accepts either an OCI descriptor representing a manifest list or a single manifest\nfunc EncryptImage(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *encconfig.CryptoConfig, lf LayerFilter) (ocispec.Descriptor, bool, error) {\n\treturn cryptImage(ctx, cs, desc, cc, lf, cryptoOpEncrypt)\n}\n\n// DecryptImage decrypts an image; it accepts either an OCI descriptor representing a manifest list or a single manifest\nfunc DecryptImage(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *encconfig.CryptoConfig, lf LayerFilter) (ocispec.Descriptor, bool, error) {\n\treturn cryptImage(ctx, cs, desc, cc, lf, cryptoOpDecrypt)\n}\n\n// GetImageEncryptConverter returns a converter function for image encryption\nfunc GetImageEncryptConverter(cc *encconfig.CryptoConfig, lf LayerFilter) converter.ConvertFunc {\n\treturn func(ctx context.Context, cs content.Store, desc ocispec.Descriptor) (*ocispec.Descriptor, error) {\n\t\tnewDesc, _, err := EncryptImage(ctx, cs, desc, cc, lf)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn &newDesc, nil\n\t}\n}\n\n// GetImageDecryptConverter returns a converter function for image decryption\nfunc GetImageDecryptConverter(cc *encconfig.CryptoConfig, lf LayerFilter) converter.ConvertFunc {\n\treturn func(ctx context.Context, cs content.Store, desc ocispec.Descriptor) (*ocispec.Descriptor, error) {\n\t\tnewDesc, _, err := DecryptImage(ctx, cs, desc, cc, lf)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn &newDesc, nil\n\t}\n}\n\n// CheckAuthorization checks whether a user has the right keys to be allowed to access an image (every layer)\n// It takes decrypting of the layers only as far as decrypting the asymmetrically encrypted data\n// The decryption is only done for the current platform\nfunc CheckAuthorization(ctx context.Context, cs content.Store, desc ocispec.Descriptor, dc *encconfig.DecryptConfig) error {\n\tcc := encconfig.InitDecryption(dc.Parameters)\n\n\tlf := func(desc ocispec.Descriptor) bool {\n\t\treturn true\n\t}\n\n\t_, _, err := cryptImage(ctx, cs, desc, &cc, lf, cryptoOpUnwrapOnly)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"you are not authorized to use this image: %w\", err)\n\t}\n\treturn nil\n}\n"], "fixing_code": ["/*\n   Copyright The containerd Authors.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npackage encryption\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math/rand\"\n\n\t\"github.com/containerd/containerd/content\"\n\t\"github.com/containerd/containerd/errdefs\"\n\t\"github.com/containerd/containerd/images\"\n\t\"github.com/containerd/containerd/images/converter\"\n\t\"github.com/containerd/containerd/platforms\"\n\n\t\"github.com/containers/ocicrypt\"\n\tencconfig \"github.com/containers/ocicrypt/config\"\n\tencocispec \"github.com/containers/ocicrypt/spec\"\n\t\"github.com/opencontainers/go-digest\"\n\t\"github.com/opencontainers/image-spec/specs-go\"\n\tocispec \"github.com/opencontainers/image-spec/specs-go/v1\"\n)\n\ntype cryptoOp int\n\nconst (\n\tcryptoOpEncrypt    cryptoOp = iota\n\tcryptoOpDecrypt             = iota\n\tcryptoOpUnwrapOnly          = iota\n)\n\n// LayerFilter allows to select Layers by certain criteria\ntype LayerFilter func(desc ocispec.Descriptor) bool\n\n// isLocalPlatform determines whether the given platform matches the local one\nfunc isLocalPlatform(platform *ocispec.Platform) bool {\n\tmatcher := platforms.NewMatcher(*platform)\n\n\treturn matcher.Match(platforms.DefaultSpec())\n}\n\n// IsEncryptedDiff returns true if mediaType is a known encrypted media type.\nfunc IsEncryptedDiff(ctx context.Context, mediaType string) bool {\n\tswitch mediaType {\n\tcase encocispec.MediaTypeLayerGzipEnc, encocispec.MediaTypeLayerEnc:\n\t\treturn true\n\t}\n\treturn false\n}\n\n// HasEncryptedLayer returns true if any LayerInfo indicates that the layer is encrypted\nfunc HasEncryptedLayer(ctx context.Context, layerInfos []ocispec.Descriptor) bool {\n\tfor i := 0; i < len(layerInfos); i++ {\n\t\tif IsEncryptedDiff(ctx, layerInfos[i].MediaType) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// encryptLayer encrypts the layer using the CryptoConfig and creates a new OCI Descriptor.\n// A call to this function may also only manipulate the wrapped keys list.\n// The caller is expected to store the returned encrypted data and OCI Descriptor\nfunc encryptLayer(cc *encconfig.CryptoConfig, dataReader content.ReaderAt, desc ocispec.Descriptor) (ocispec.Descriptor, io.Reader, ocicrypt.EncryptLayerFinalizer, error) {\n\tvar (\n\t\tsize int64\n\t\td    digest.Digest\n\t\terr  error\n\t)\n\n\tencLayerReader, encLayerFinalizer, err := ocicrypt.EncryptLayer(cc.EncryptConfig, ocicrypt.ReaderFromReaderAt(dataReader), desc)\n\tif err != nil {\n\t\treturn ocispec.Descriptor{}, nil, nil, err\n\t}\n\n\t// were data touched ?\n\tif encLayerReader != nil {\n\t\tsize = 0\n\t\td = \"\"\n\t} else {\n\t\tsize = desc.Size\n\t\td = desc.Digest\n\t}\n\n\tnewDesc := ocispec.Descriptor{\n\t\tDigest:   d,\n\t\tSize:     size,\n\t\tPlatform: desc.Platform,\n\t}\n\n\tswitch desc.MediaType {\n\tcase images.MediaTypeDockerSchema2LayerGzip:\n\t\tnewDesc.MediaType = encocispec.MediaTypeLayerGzipEnc\n\tcase images.MediaTypeDockerSchema2Layer:\n\t\tnewDesc.MediaType = encocispec.MediaTypeLayerEnc\n\tcase encocispec.MediaTypeLayerGzipEnc:\n\t\tnewDesc.MediaType = encocispec.MediaTypeLayerGzipEnc\n\tcase encocispec.MediaTypeLayerEnc:\n\t\tnewDesc.MediaType = encocispec.MediaTypeLayerEnc\n\n\t// TODO: Mediatypes to be added in ocispec\n\tcase ocispec.MediaTypeImageLayerGzip:\n\t\tnewDesc.MediaType = encocispec.MediaTypeLayerGzipEnc\n\tcase ocispec.MediaTypeImageLayer:\n\t\tnewDesc.MediaType = encocispec.MediaTypeLayerEnc\n\n\tdefault:\n\t\treturn ocispec.Descriptor{}, nil, nil, fmt.Errorf(\"unsupporter layer MediaType: %s\", desc.MediaType)\n\t}\n\n\treturn newDesc, encLayerReader, encLayerFinalizer, nil\n}\n\n// DecryptLayer decrypts the layer using the DecryptConfig and creates a new OCI Descriptor.\n// The caller is expected to store the returned plain data and OCI Descriptor\nfunc DecryptLayer(dc *encconfig.DecryptConfig, dataReader io.Reader, desc ocispec.Descriptor, unwrapOnly bool) (ocispec.Descriptor, io.Reader, digest.Digest, error) {\n\tresultReader, layerDigest, err := ocicrypt.DecryptLayer(dc, dataReader, desc, unwrapOnly)\n\tif err != nil || unwrapOnly {\n\t\treturn ocispec.Descriptor{}, nil, \"\", err\n\t}\n\n\tnewDesc := ocispec.Descriptor{\n\t\tSize:     0,\n\t\tPlatform: desc.Platform,\n\t}\n\n\tswitch desc.MediaType {\n\tcase encocispec.MediaTypeLayerGzipEnc:\n\t\tnewDesc.MediaType = images.MediaTypeDockerSchema2LayerGzip\n\tcase encocispec.MediaTypeLayerEnc:\n\t\tnewDesc.MediaType = images.MediaTypeDockerSchema2Layer\n\tdefault:\n\t\treturn ocispec.Descriptor{}, nil, \"\", fmt.Errorf(\"unsupporter layer MediaType: %s\", desc.MediaType)\n\t}\n\treturn newDesc, resultReader, layerDigest, nil\n}\n\n// decryptLayer decrypts the layer using the CryptoConfig and creates a new OCI Descriptor.\n// The caller is expected to store the returned plain data and OCI Descriptor\nfunc decryptLayer(cc *encconfig.CryptoConfig, dataReader content.ReaderAt, desc ocispec.Descriptor, unwrapOnly bool) (ocispec.Descriptor, io.Reader, error) {\n\tresultReader, d, err := ocicrypt.DecryptLayer(cc.DecryptConfig, ocicrypt.ReaderFromReaderAt(dataReader), desc, unwrapOnly)\n\tif err != nil || unwrapOnly {\n\t\treturn ocispec.Descriptor{}, nil, err\n\t}\n\n\tnewDesc := ocispec.Descriptor{\n\t\tDigest:   d,\n\t\tSize:     0,\n\t\tPlatform: desc.Platform,\n\t}\n\n\tswitch desc.MediaType {\n\tcase encocispec.MediaTypeLayerGzipEnc:\n\t\tnewDesc.MediaType = images.MediaTypeDockerSchema2LayerGzip\n\tcase encocispec.MediaTypeLayerEnc:\n\t\tnewDesc.MediaType = images.MediaTypeDockerSchema2Layer\n\tdefault:\n\t\treturn ocispec.Descriptor{}, nil, fmt.Errorf(\"unsupporter layer MediaType: %s\", desc.MediaType)\n\t}\n\treturn newDesc, resultReader, nil\n}\n\n// cryptLayer handles the changes due to encryption or decryption of a layer\nfunc cryptLayer(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *encconfig.CryptoConfig, cryptoOp cryptoOp) (ocispec.Descriptor, error) {\n\tvar (\n\t\tresultReader      io.Reader\n\t\tnewDesc           ocispec.Descriptor\n\t\tencLayerFinalizer ocicrypt.EncryptLayerFinalizer\n\t)\n\n\tdataReader, err := cs.ReaderAt(ctx, desc)\n\tif err != nil {\n\t\treturn ocispec.Descriptor{}, err\n\t}\n\tdefer dataReader.Close()\n\n\tif cryptoOp == cryptoOpEncrypt {\n\t\tnewDesc, resultReader, encLayerFinalizer, err = encryptLayer(cc, dataReader, desc)\n\t} else {\n\t\tnewDesc, resultReader, err = decryptLayer(cc, dataReader, desc, cryptoOp == cryptoOpUnwrapOnly)\n\t}\n\tif err != nil || cryptoOp == cryptoOpUnwrapOnly {\n\t\treturn ocispec.Descriptor{}, err\n\t}\n\n\tnewDesc.Annotations = ocicrypt.FilterOutAnnotations(desc.Annotations)\n\n\t// some operations, such as changing recipients, may not touch the layer at all\n\tif resultReader != nil {\n\t\tvar ref string\n\t\t// If we have the digest, write blob with checks\n\t\thaveDigest := newDesc.Digest.String() != \"\"\n\t\tif haveDigest {\n\t\t\tref = fmt.Sprintf(\"layer-%s\", newDesc.Digest.String())\n\t\t} else {\n\t\t\tref = fmt.Sprintf(\"blob-%d-%d\", rand.Int(), rand.Int())\n\t\t}\n\n\t\tif haveDigest {\n\t\t\tif err := content.WriteBlob(ctx, cs, ref, resultReader, newDesc); err != nil {\n\t\t\t\treturn ocispec.Descriptor{}, fmt.Errorf(\"failed to write config: %w\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tnewDesc.Digest, newDesc.Size, err = ingestReader(ctx, cs, ref, resultReader)\n\t\t\tif err != nil {\n\t\t\t\treturn ocispec.Descriptor{}, err\n\t\t\t}\n\t\t}\n\t}\n\n\t// After performing encryption, call finalizer to get annotations\n\tif encLayerFinalizer != nil {\n\t\tannotations, err := encLayerFinalizer()\n\t\tif err != nil {\n\t\t\treturn ocispec.Descriptor{}, fmt.Errorf(\"error getting annotations from encLayer finalizer: %w\", err)\n\t\t}\n\t\tfor k, v := range annotations {\n\t\t\tnewDesc.Annotations[k] = v\n\t\t}\n\t}\n\treturn newDesc, err\n}\n\nfunc ingestReader(ctx context.Context, cs content.Ingester, ref string, r io.Reader) (digest.Digest, int64, error) {\n\tcw, err := content.OpenWriter(ctx, cs, content.WithRef(ref))\n\tif err != nil {\n\t\treturn \"\", 0, fmt.Errorf(\"failed to open writer: %w\", err)\n\t}\n\tdefer cw.Close()\n\n\tif _, err := content.CopyReader(cw, r); err != nil {\n\t\treturn \"\", 0, fmt.Errorf(\"copy failed: %w\", err)\n\t}\n\n\tst, err := cw.Status()\n\tif err != nil {\n\t\treturn \"\", 0, fmt.Errorf(\"failed to get state: %w\", err)\n\t}\n\n\tif err := cw.Commit(ctx, st.Offset, \"\"); err != nil {\n\t\tif !errdefs.IsAlreadyExists(err) {\n\t\t\treturn \"\", 0, fmt.Errorf(\"failed commit on ref %q: %w\", ref, err)\n\t\t}\n\t}\n\n\treturn cw.Digest(), st.Offset, nil\n}\n\n// Encrypt or decrypt all the Children of a given descriptor\nfunc cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *encconfig.CryptoConfig, lf LayerFilter, cryptoOp cryptoOp, thisPlatform *ocispec.Platform) (ocispec.Descriptor, bool, error) {\n\tchildren, err := images.Children(ctx, cs, desc)\n\tif err != nil {\n\t\tif errdefs.IsNotFound(err) {\n\t\t\treturn desc, false, nil\n\t\t}\n\t\treturn ocispec.Descriptor{}, false, err\n\t}\n\n\tvar newLayers []ocispec.Descriptor\n\tvar config ocispec.Descriptor\n\tmodified := false\n\n\tfor _, child := range children {\n\t\t// we only encrypt child layers and have to update their parents if encryption happened\n\t\tswitch child.MediaType {\n\t\tcase images.MediaTypeDockerSchema2Config, ocispec.MediaTypeImageConfig:\n\t\t\tconfig = child\n\t\tcase images.MediaTypeDockerSchema2LayerGzip, images.MediaTypeDockerSchema2Layer,\n\t\t\tocispec.MediaTypeImageLayerGzip, ocispec.MediaTypeImageLayer:\n\t\t\tif cryptoOp == cryptoOpEncrypt && lf(child) {\n\t\t\t\tnl, err := cryptLayer(ctx, cs, child, cc, cryptoOp)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn ocispec.Descriptor{}, false, err\n\t\t\t\t}\n\t\t\t\tmodified = true\n\t\t\t\tnewLayers = append(newLayers, nl)\n\t\t\t} else {\n\t\t\t\tnewLayers = append(newLayers, child)\n\t\t\t}\n\t\tcase encocispec.MediaTypeLayerGzipEnc, encocispec.MediaTypeLayerEnc:\n\t\t\t// this one can be decrypted but also its recipients list changed\n\t\t\tif lf(child) {\n\t\t\t\tnl, err := cryptLayer(ctx, cs, child, cc, cryptoOp)\n\t\t\t\tif err != nil || cryptoOp == cryptoOpUnwrapOnly {\n\t\t\t\t\treturn ocispec.Descriptor{}, false, err\n\t\t\t\t}\n\t\t\t\tmodified = true\n\t\t\t\tnewLayers = append(newLayers, nl)\n\t\t\t} else {\n\t\t\t\tnewLayers = append(newLayers, child)\n\t\t\t}\n\t\tcase images.MediaTypeDockerSchema2LayerForeign, images.MediaTypeDockerSchema2LayerForeignGzip:\n\t\t\t// never encrypt/decrypt\n\t\t\tnewLayers = append(newLayers, child)\n\t\tdefault:\n\t\t\treturn ocispec.Descriptor{}, false, fmt.Errorf(\"bad/unhandled MediaType %s in encryptChildren\", child.MediaType)\n\t\t}\n\t}\n\n\tif modified && len(newLayers) > 0 {\n\t\tnewManifest := ocispec.Manifest{\n\t\t\tVersioned: specs.Versioned{\n\t\t\t\tSchemaVersion: 2,\n\t\t\t},\n\t\t\tConfig: config,\n\t\t\tLayers: newLayers,\n\t\t}\n\n\t\tmb, err := json.MarshalIndent(newManifest, \"\", \"   \")\n\t\tif err != nil {\n\t\t\treturn ocispec.Descriptor{}, false, fmt.Errorf(\"failed to marshal image: %w\", err)\n\t\t}\n\n\t\tnewDesc := ocispec.Descriptor{\n\t\t\tMediaType: ocispec.MediaTypeImageManifest,\n\t\t\tSize:      int64(len(mb)),\n\t\t\tDigest:    digest.Canonical.FromBytes(mb),\n\t\t\tPlatform:  desc.Platform,\n\t\t}\n\n\t\tlabels := map[string]string{}\n\t\tlabels[\"containerd.io/gc.ref.content.0\"] = newManifest.Config.Digest.String()\n\t\tfor i, ch := range newManifest.Layers {\n\t\t\tlabels[fmt.Sprintf(\"containerd.io/gc.ref.content.%d\", i+1)] = ch.Digest.String()\n\t\t}\n\n\t\tref := fmt.Sprintf(\"manifest-%s\", newDesc.Digest.String())\n\n\t\tif err := content.WriteBlob(ctx, cs, ref, bytes.NewReader(mb), newDesc, content.WithLabels(labels)); err != nil {\n\t\t\treturn ocispec.Descriptor{}, false, fmt.Errorf(\"failed to write config: %w\", err)\n\t\t}\n\t\treturn newDesc, true, nil\n\t}\n\n\treturn desc, modified, nil\n}\n\n// cryptManifest encrypts or decrypts the children of a top level manifest\nfunc cryptManifest(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *encconfig.CryptoConfig, lf LayerFilter, cryptoOp cryptoOp) (ocispec.Descriptor, bool, error) {\n\tp, err := content.ReadBlob(ctx, cs, desc)\n\tif err != nil {\n\t\treturn ocispec.Descriptor{}, false, err\n\t}\n\tvar manifest ocispec.Manifest\n\tif err := json.Unmarshal(p, &manifest); err != nil {\n\t\treturn ocispec.Descriptor{}, false, err\n\t}\n\tplatform := platforms.DefaultSpec()\n\tnewDesc, modified, err := cryptChildren(ctx, cs, desc, cc, lf, cryptoOp, &platform)\n\tif err != nil || cryptoOp == cryptoOpUnwrapOnly {\n\t\treturn ocispec.Descriptor{}, false, err\n\t}\n\treturn newDesc, modified, nil\n}\n\n// cryptManifestList encrypts or decrypts the children of a top level manifest list\nfunc cryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *encconfig.CryptoConfig, lf LayerFilter, cryptoOp cryptoOp) (ocispec.Descriptor, bool, error) {\n\t// read the index; if any layer is encrypted and any manifests change we will need to rewrite it\n\tb, err := content.ReadBlob(ctx, cs, desc)\n\tif err != nil {\n\t\treturn ocispec.Descriptor{}, false, err\n\t}\n\n\tvar index ocispec.Index\n\tif err := json.Unmarshal(b, &index); err != nil {\n\t\treturn ocispec.Descriptor{}, false, err\n\t}\n\n\tvar newManifests []ocispec.Descriptor\n\tmodified := false\n\tfor _, manifest := range index.Manifests {\n\t\tif cryptoOp == cryptoOpUnwrapOnly && !isLocalPlatform(manifest.Platform) {\n\t\t\tcontinue\n\t\t}\n\t\tnewManifest, m, err := cryptChildren(ctx, cs, manifest, cc, lf, cryptoOp, manifest.Platform)\n\t\tif err != nil || cryptoOp == cryptoOpUnwrapOnly {\n\t\t\treturn ocispec.Descriptor{}, false, err\n\t\t}\n\t\tif m {\n\t\t\tmodified = true\n\t\t}\n\t\tnewManifests = append(newManifests, newManifest)\n\t}\n\tif cryptoOp == cryptoOpUnwrapOnly {\n\t\treturn ocispec.Descriptor{}, false, fmt.Errorf(\"No manifest found for local platform\")\n\t}\n\n\tif modified {\n\t\t// we need to update the index\n\t\tnewIndex := ocispec.Index{\n\t\t\tVersioned: index.Versioned,\n\t\t\tManifests: newManifests,\n\t\t}\n\n\t\tmb, err := json.MarshalIndent(newIndex, \"\", \"   \")\n\t\tif err != nil {\n\t\t\treturn ocispec.Descriptor{}, false, fmt.Errorf(\"failed to marshal index: %w\", err)\n\t\t}\n\n\t\tnewDesc := ocispec.Descriptor{\n\t\t\tMediaType: ocispec.MediaTypeImageIndex,\n\t\t\tSize:      int64(len(mb)),\n\t\t\tDigest:    digest.Canonical.FromBytes(mb),\n\t\t}\n\n\t\tlabels := map[string]string{}\n\t\tfor i, m := range newIndex.Manifests {\n\t\t\tlabels[fmt.Sprintf(\"containerd.io/gc.ref.content.%d\", i)] = m.Digest.String()\n\t\t}\n\n\t\tref := fmt.Sprintf(\"index-%s\", newDesc.Digest.String())\n\n\t\tif err = content.WriteBlob(ctx, cs, ref, bytes.NewReader(mb), newDesc, content.WithLabels(labels)); err != nil {\n\t\t\treturn ocispec.Descriptor{}, false, fmt.Errorf(\"failed to write index: %w\", err)\n\t\t}\n\t\treturn newDesc, true, nil\n\t}\n\n\treturn desc, false, nil\n}\n\n// cryptImage is the dispatcher to encrypt/decrypt an image; it accepts either an OCI descriptor\n// representing a manifest list or a single manifest\nfunc cryptImage(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *encconfig.CryptoConfig, lf LayerFilter, cryptoOp cryptoOp) (ocispec.Descriptor, bool, error) {\n\tif cc == nil {\n\t\treturn ocispec.Descriptor{}, false, errors.New(\"invalid argument: CryptoConfig must not be nil\")\n\t}\n\tswitch desc.MediaType {\n\tcase ocispec.MediaTypeImageIndex, images.MediaTypeDockerSchema2ManifestList:\n\t\treturn cryptManifestList(ctx, cs, desc, cc, lf, cryptoOp)\n\tcase ocispec.MediaTypeImageManifest, images.MediaTypeDockerSchema2Manifest:\n\t\treturn cryptManifest(ctx, cs, desc, cc, lf, cryptoOp)\n\tdefault:\n\t\treturn ocispec.Descriptor{}, false, fmt.Errorf(\"unhandled media type: %s\", desc.MediaType)\n\t}\n}\n\n// EncryptImage encrypts an image; it accepts either an OCI descriptor representing a manifest list or a single manifest\nfunc EncryptImage(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *encconfig.CryptoConfig, lf LayerFilter) (ocispec.Descriptor, bool, error) {\n\treturn cryptImage(ctx, cs, desc, cc, lf, cryptoOpEncrypt)\n}\n\n// DecryptImage decrypts an image; it accepts either an OCI descriptor representing a manifest list or a single manifest\nfunc DecryptImage(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *encconfig.CryptoConfig, lf LayerFilter) (ocispec.Descriptor, bool, error) {\n\treturn cryptImage(ctx, cs, desc, cc, lf, cryptoOpDecrypt)\n}\n\n// GetImageEncryptConverter returns a converter function for image encryption\nfunc GetImageEncryptConverter(cc *encconfig.CryptoConfig, lf LayerFilter) converter.ConvertFunc {\n\treturn func(ctx context.Context, cs content.Store, desc ocispec.Descriptor) (*ocispec.Descriptor, error) {\n\t\tnewDesc, _, err := EncryptImage(ctx, cs, desc, cc, lf)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn &newDesc, nil\n\t}\n}\n\n// GetImageDecryptConverter returns a converter function for image decryption\nfunc GetImageDecryptConverter(cc *encconfig.CryptoConfig, lf LayerFilter) converter.ConvertFunc {\n\treturn func(ctx context.Context, cs content.Store, desc ocispec.Descriptor) (*ocispec.Descriptor, error) {\n\t\tnewDesc, _, err := DecryptImage(ctx, cs, desc, cc, lf)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn &newDesc, nil\n\t}\n}\n\n// CheckAuthorization checks whether a user has the right keys to be allowed to access an image (every layer)\n// It takes decrypting of the layers only as far as decrypting the asymmetrically encrypted data\n// The decryption is only done for the current platform\nfunc CheckAuthorization(ctx context.Context, cs content.Store, desc ocispec.Descriptor, dc *encconfig.DecryptConfig) error {\n\tcc := encconfig.InitDecryption(dc.Parameters)\n\n\tlf := func(desc ocispec.Descriptor) bool {\n\t\treturn true\n\t}\n\n\t_, _, err := cryptImage(ctx, cs, desc, &cc, lf, cryptoOpUnwrapOnly)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"you are not authorized to use this image: %w\", err)\n\t}\n\treturn nil\n}\n"], "filenames": ["images/encryption/encryption.go"], "buggy_code_start_loc": [51], "buggy_code_end_loc": [390], "fixing_code_start_loc": [52], "fixing_code_end_loc": [404], "type": "CWE-863", "message": "The imgcrypt library provides API exensions for containerd to support encrypted container images and implements the ctd-decoder command line tool for use by containerd to decrypt encrypted container images. The imgcrypt function `CheckAuthorization` is supposed to check whether the current used is authorized to access an encrypted image and prevent the user from running an image that another user previously decrypted on the same system. In versions prior to 1.1.4, a failure occurs when an image with a ManifestList is used and the architecture of the local host is not the first one in the ManifestList. Only the first architecture in the list was tested, which may not have its layers available locally since it could not be run on the host architecture. Therefore, the verdict on unavailable layers was that the image could be run anticipating that image run failure would occur later due to the layers not being available. However, this verdict to allow the image to run enabled other architectures in the ManifestList to run an image without providing keys if that image had previously been decrypted. A patch has been applied to imgcrypt 1.1.4. Workarounds may include usage of different namespaces for each remote user.", "other": {"cve": {"id": "CVE-2022-24778", "sourceIdentifier": "security-advisories@github.com", "published": "2022-03-25T18:15:22.830", "lastModified": "2023-01-25T02:09:48.510", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The imgcrypt library provides API exensions for containerd to support encrypted container images and implements the ctd-decoder command line tool for use by containerd to decrypt encrypted container images. The imgcrypt function `CheckAuthorization` is supposed to check whether the current used is authorized to access an encrypted image and prevent the user from running an image that another user previously decrypted on the same system. In versions prior to 1.1.4, a failure occurs when an image with a ManifestList is used and the architecture of the local host is not the first one in the ManifestList. Only the first architecture in the list was tested, which may not have its layers available locally since it could not be run on the host architecture. Therefore, the verdict on unavailable layers was that the image could be run anticipating that image run failure would occur later due to the layers not being available. However, this verdict to allow the image to run enabled other architectures in the ManifestList to run an image without providing keys if that image had previously been decrypted. A patch has been applied to imgcrypt 1.1.4. Workarounds may include usage of different namespaces for each remote user."}, {"lang": "es", "value": "La biblioteca imgcrypt proporciona extensiones de la API para que containerd admita im\u00e1genes de contenedor cifradas e implementa la herramienta de l\u00ednea de comandos ctd-decoder para que containerd la use para descifrar im\u00e1genes de contenedor cifradas. La funci\u00f3n imgcrypt \"CheckAuthorization\" es supuesto que comprueba si el usuario actual est\u00e1 autorizado a acceder a una imagen encriptada y evita que el usuario ejecute una imagen que otro usuario haya desencriptado previamente en el mismo sistema. En versiones anteriores a 1.1.4, es producido un fallo cuando es usada una imagen con una ManifestList y la arquitectura del host local no es la primera de la ManifestList. S\u00f3lo es comprobada la primera arquitectura de la lista, que pod\u00eda no presentar sus capas disponibles localmente al no poder ejecutarse en la arquitectura del host. Por lo tanto, el veredicto sobre las capas no disponibles fue que la imagen pod\u00eda ser ejecutada anticipando que el fallo de ejecuci\u00f3n de la imagen ocurrir\u00eda m\u00e1s tarde debido a que las capas no estaban disponibles. Sin embargo, este veredicto de permitir la ejecuci\u00f3n de la imagen permit\u00eda a otras arquitecturas de la ManifestList ejecutar una imagen sin proporcionar claves si esa imagen hab\u00eda sido descifrada previamente. Ha sido aplicado un parche a imgcrypt versi\u00f3n 1.1.4. Las mitigaciones pueden incluir el uso de diferentes espacios de nombres para cada usuario remoto"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:imgcrypt:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.4", "matchCriteriaId": "E47F333A-A481-488E-817D-59C3C7691D66"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/containerd/imgcrypt/commit/6fdd9818a4d8142107b7ecd767d839c9707700d9", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/containerd/imgcrypt/issues/69", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/containerd/imgcrypt/releases/tag/v1.1.4", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/containerd/imgcrypt/security/advisories/GHSA-8v99-48m9-c8pm", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4SJUNSC7YZLA745EMKWK2GKEV57GE52K/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TAHAAOOA3KZJC2I5WHCR3XVBJBNWTWUE/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZFTJR5CR5EOYDVOSBZEMLBHLJRTPJPUA/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/containerd/imgcrypt/commit/6fdd9818a4d8142107b7ecd767d839c9707700d9"}}