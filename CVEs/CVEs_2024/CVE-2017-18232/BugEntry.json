{"buggy_code": ["/*\n * Support for SATA devices on Serial Attached SCSI (SAS) controllers\n *\n * Copyright (C) 2006 IBM Corporation\n *\n * Written by: Darrick J. Wong <djwong@us.ibm.com>, IBM Corporation\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307\n * USA\n */\n\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <linux/async.h>\n#include <linux/export.h>\n\n#include <scsi/sas_ata.h>\n#include \"sas_internal.h\"\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_sas.h>\n#include \"../scsi_sas_internal.h\"\n#include \"../scsi_transport_api.h\"\n#include <scsi/scsi_eh.h>\n\nstatic enum ata_completion_errors sas_to_ata_err(struct task_status_struct *ts)\n{\n\t/* Cheesy attempt to translate SAS errors into ATA.  Hah! */\n\n\t/* transport error */\n\tif (ts->resp == SAS_TASK_UNDELIVERED)\n\t\treturn AC_ERR_ATA_BUS;\n\n\t/* ts->resp == SAS_TASK_COMPLETE */\n\t/* task delivered, what happened afterwards? */\n\tswitch (ts->stat) {\n\t\tcase SAS_DEV_NO_RESPONSE:\n\t\t\treturn AC_ERR_TIMEOUT;\n\n\t\tcase SAS_INTERRUPTED:\n\t\tcase SAS_PHY_DOWN:\n\t\tcase SAS_NAK_R_ERR:\n\t\t\treturn AC_ERR_ATA_BUS;\n\n\n\t\tcase SAS_DATA_UNDERRUN:\n\t\t\t/*\n\t\t\t * Some programs that use the taskfile interface\n\t\t\t * (smartctl in particular) can cause underrun\n\t\t\t * problems.  Ignore these errors, perhaps at our\n\t\t\t * peril.\n\t\t\t */\n\t\t\treturn 0;\n\n\t\tcase SAS_DATA_OVERRUN:\n\t\tcase SAS_QUEUE_FULL:\n\t\tcase SAS_DEVICE_UNKNOWN:\n\t\tcase SAS_SG_ERR:\n\t\t\treturn AC_ERR_INVALID;\n\n\t\tcase SAS_OPEN_TO:\n\t\tcase SAS_OPEN_REJECT:\n\t\t\tSAS_DPRINTK(\"%s: Saw error %d.  What to do?\\n\",\n\t\t\t\t    __func__, ts->stat);\n\t\t\treturn AC_ERR_OTHER;\n\n\t\tcase SAM_STAT_CHECK_CONDITION:\n\t\tcase SAS_ABORTED_TASK:\n\t\t\treturn AC_ERR_DEV;\n\n\t\tcase SAS_PROTO_RESPONSE:\n\t\t\t/* This means the ending_fis has the error\n\t\t\t * value; return 0 here to collect it */\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n}\n\nstatic void sas_ata_task_done(struct sas_task *task)\n{\n\tstruct ata_queued_cmd *qc = task->uldd_task;\n\tstruct domain_device *dev = task->dev;\n\tstruct task_status_struct *stat = &task->task_status;\n\tstruct ata_task_resp *resp = (struct ata_task_resp *)stat->buf;\n\tstruct sas_ha_struct *sas_ha = dev->port->ha;\n\tenum ata_completion_errors ac;\n\tunsigned long flags;\n\tstruct ata_link *link;\n\tstruct ata_port *ap;\n\n\tspin_lock_irqsave(&dev->done_lock, flags);\n\tif (test_bit(SAS_HA_FROZEN, &sas_ha->state))\n\t\ttask = NULL;\n\telse if (qc && qc->scsicmd)\n\t\tASSIGN_SAS_TASK(qc->scsicmd, NULL);\n\tspin_unlock_irqrestore(&dev->done_lock, flags);\n\n\t/* check if libsas-eh got to the task before us */\n\tif (unlikely(!task))\n\t\treturn;\n\n\tif (!qc)\n\t\tgoto qc_already_gone;\n\n\tap = qc->ap;\n\tlink = &ap->link;\n\n\tspin_lock_irqsave(ap->lock, flags);\n\t/* check if we lost the race with libata/sas_ata_post_internal() */\n\tif (unlikely(ap->pflags & ATA_PFLAG_FROZEN)) {\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t\tif (qc->scsicmd)\n\t\t\tgoto qc_already_gone;\n\t\telse {\n\t\t\t/* if eh is not involved and the port is frozen then the\n\t\t\t * ata internal abort process has taken responsibility\n\t\t\t * for this sas_task\n\t\t\t */\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (stat->stat == SAS_PROTO_RESPONSE || stat->stat == SAM_STAT_GOOD ||\n\t    ((stat->stat == SAM_STAT_CHECK_CONDITION &&\n\t      dev->sata_dev.class == ATA_DEV_ATAPI))) {\n\t\tmemcpy(dev->sata_dev.fis, resp->ending_fis, ATA_RESP_FIS_SIZE);\n\n\t\tif (!link->sactive) {\n\t\t\tqc->err_mask |= ac_err_mask(dev->sata_dev.fis[2]);\n\t\t} else {\n\t\t\tlink->eh_info.err_mask |= ac_err_mask(dev->sata_dev.fis[2]);\n\t\t\tif (unlikely(link->eh_info.err_mask))\n\t\t\t\tqc->flags |= ATA_QCFLAG_FAILED;\n\t\t}\n\t} else {\n\t\tac = sas_to_ata_err(stat);\n\t\tif (ac) {\n\t\t\tSAS_DPRINTK(\"%s: SAS error %x\\n\", __func__,\n\t\t\t\t    stat->stat);\n\t\t\t/* We saw a SAS error. Send a vague error. */\n\t\t\tif (!link->sactive) {\n\t\t\t\tqc->err_mask = ac;\n\t\t\t} else {\n\t\t\t\tlink->eh_info.err_mask |= AC_ERR_DEV;\n\t\t\t\tqc->flags |= ATA_QCFLAG_FAILED;\n\t\t\t}\n\n\t\t\tdev->sata_dev.fis[3] = 0x04; /* status err */\n\t\t\tdev->sata_dev.fis[2] = ATA_ERR;\n\t\t}\n\t}\n\n\tqc->lldd_task = NULL;\n\tata_qc_complete(qc);\n\tspin_unlock_irqrestore(ap->lock, flags);\n\nqc_already_gone:\n\tsas_free_task(task);\n}\n\nstatic unsigned int sas_ata_qc_issue(struct ata_queued_cmd *qc)\n{\n\tunsigned long flags;\n\tstruct sas_task *task;\n\tstruct scatterlist *sg;\n\tint ret = AC_ERR_SYSTEM;\n\tunsigned int si, xfer = 0;\n\tstruct ata_port *ap = qc->ap;\n\tstruct domain_device *dev = ap->private_data;\n\tstruct sas_ha_struct *sas_ha = dev->port->ha;\n\tstruct Scsi_Host *host = sas_ha->core.shost;\n\tstruct sas_internal *i = to_sas_internal(host->transportt);\n\n\t/* TODO: audit callers to ensure they are ready for qc_issue to\n\t * unconditionally re-enable interrupts\n\t */\n\tlocal_irq_save(flags);\n\tspin_unlock(ap->lock);\n\n\t/* If the device fell off, no sense in issuing commands */\n\tif (test_bit(SAS_DEV_GONE, &dev->state))\n\t\tgoto out;\n\n\ttask = sas_alloc_task(GFP_ATOMIC);\n\tif (!task)\n\t\tgoto out;\n\ttask->dev = dev;\n\ttask->task_proto = SAS_PROTOCOL_STP;\n\ttask->task_done = sas_ata_task_done;\n\n\tif (qc->tf.command == ATA_CMD_FPDMA_WRITE ||\n\t    qc->tf.command == ATA_CMD_FPDMA_READ ||\n\t    qc->tf.command == ATA_CMD_FPDMA_RECV ||\n\t    qc->tf.command == ATA_CMD_FPDMA_SEND ||\n\t    qc->tf.command == ATA_CMD_NCQ_NON_DATA) {\n\t\t/* Need to zero out the tag libata assigned us */\n\t\tqc->tf.nsect = 0;\n\t}\n\n\tata_tf_to_fis(&qc->tf, qc->dev->link->pmp, 1, (u8 *)&task->ata_task.fis);\n\ttask->uldd_task = qc;\n\tif (ata_is_atapi(qc->tf.protocol)) {\n\t\tmemcpy(task->ata_task.atapi_packet, qc->cdb, qc->dev->cdb_len);\n\t\ttask->total_xfer_len = qc->nbytes;\n\t\ttask->num_scatter = qc->n_elem;\n\t} else {\n\t\tfor_each_sg(qc->sg, sg, qc->n_elem, si)\n\t\t\txfer += sg_dma_len(sg);\n\n\t\ttask->total_xfer_len = xfer;\n\t\ttask->num_scatter = si;\n\t}\n\n\ttask->data_dir = qc->dma_dir;\n\ttask->scatter = qc->sg;\n\ttask->ata_task.retry_count = 1;\n\ttask->task_state_flags = SAS_TASK_STATE_PENDING;\n\tqc->lldd_task = task;\n\n\ttask->ata_task.use_ncq = ata_is_ncq(qc->tf.protocol);\n\ttask->ata_task.dma_xfer = ata_is_dma(qc->tf.protocol);\n\n\tif (qc->scsicmd)\n\t\tASSIGN_SAS_TASK(qc->scsicmd, task);\n\n\tret = i->dft->lldd_execute_task(task, GFP_ATOMIC);\n\tif (ret) {\n\t\tSAS_DPRINTK(\"lldd_execute_task returned: %d\\n\", ret);\n\n\t\tif (qc->scsicmd)\n\t\t\tASSIGN_SAS_TASK(qc->scsicmd, NULL);\n\t\tsas_free_task(task);\n\t\tqc->lldd_task = NULL;\n\t\tret = AC_ERR_SYSTEM;\n\t}\n\n out:\n\tspin_lock(ap->lock);\n\tlocal_irq_restore(flags);\n\treturn ret;\n}\n\nstatic bool sas_ata_qc_fill_rtf(struct ata_queued_cmd *qc)\n{\n\tstruct domain_device *dev = qc->ap->private_data;\n\n\tata_tf_from_fis(dev->sata_dev.fis, &qc->result_tf);\n\treturn true;\n}\n\nstatic struct sas_internal *dev_to_sas_internal(struct domain_device *dev)\n{\n\treturn to_sas_internal(dev->port->ha->core.shost->transportt);\n}\n\nstatic int sas_get_ata_command_set(struct domain_device *dev);\n\nint sas_get_ata_info(struct domain_device *dev, struct ex_phy *phy)\n{\n\tif (phy->attached_tproto & SAS_PROTOCOL_STP)\n\t\tdev->tproto = phy->attached_tproto;\n\tif (phy->attached_sata_dev)\n\t\tdev->tproto |= SAS_SATA_DEV;\n\n\tif (phy->attached_dev_type == SAS_SATA_PENDING)\n\t\tdev->dev_type = SAS_SATA_PENDING;\n\telse {\n\t\tint res;\n\n\t\tdev->dev_type = SAS_SATA_DEV;\n\t\tres = sas_get_report_phy_sata(dev->parent, phy->phy_id,\n\t\t\t\t\t      &dev->sata_dev.rps_resp);\n\t\tif (res) {\n\t\t\tSAS_DPRINTK(\"report phy sata to %016llx:0x%x returned \"\n\t\t\t\t    \"0x%x\\n\", SAS_ADDR(dev->parent->sas_addr),\n\t\t\t\t    phy->phy_id, res);\n\t\t\treturn res;\n\t\t}\n\t\tmemcpy(dev->frame_rcvd, &dev->sata_dev.rps_resp.rps.fis,\n\t\t       sizeof(struct dev_to_host_fis));\n\t\tdev->sata_dev.class = sas_get_ata_command_set(dev);\n\t}\n\treturn 0;\n}\n\nstatic int sas_ata_clear_pending(struct domain_device *dev, struct ex_phy *phy)\n{\n\tint res;\n\n\t/* we weren't pending, so successfully end the reset sequence now */\n\tif (dev->dev_type != SAS_SATA_PENDING)\n\t\treturn 1;\n\n\t/* hmmm, if this succeeds do we need to repost the domain_device to the\n\t * lldd so it can pick up new parameters?\n\t */\n\tres = sas_get_ata_info(dev, phy);\n\tif (res)\n\t\treturn 0; /* retry */\n\telse\n\t\treturn 1;\n}\n\nstatic int smp_ata_check_ready(struct ata_link *link)\n{\n\tint res;\n\tstruct ata_port *ap = link->ap;\n\tstruct domain_device *dev = ap->private_data;\n\tstruct domain_device *ex_dev = dev->parent;\n\tstruct sas_phy *phy = sas_get_local_phy(dev);\n\tstruct ex_phy *ex_phy = &ex_dev->ex_dev.ex_phy[phy->number];\n\n\tres = sas_ex_phy_discover(ex_dev, phy->number);\n\tsas_put_local_phy(phy);\n\n\t/* break the wait early if the expander is unreachable,\n\t * otherwise keep polling\n\t */\n\tif (res == -ECOMM)\n\t\treturn res;\n\tif (res != SMP_RESP_FUNC_ACC)\n\t\treturn 0;\n\n\tswitch (ex_phy->attached_dev_type) {\n\tcase SAS_SATA_PENDING:\n\t\treturn 0;\n\tcase SAS_END_DEVICE:\n\t\tif (ex_phy->attached_sata_dev)\n\t\t\treturn sas_ata_clear_pending(dev, ex_phy);\n\t\t/* fall through */\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n}\n\nstatic int local_ata_check_ready(struct ata_link *link)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct domain_device *dev = ap->private_data;\n\tstruct sas_internal *i = dev_to_sas_internal(dev);\n\n\tif (i->dft->lldd_ata_check_ready)\n\t\treturn i->dft->lldd_ata_check_ready(dev);\n\telse {\n\t\t/* lldd's that don't implement 'ready' checking get the\n\t\t * old default behavior of not coordinating reset\n\t\t * recovery with libata\n\t\t */\n\t\treturn 1;\n\t}\n}\n\nstatic int sas_ata_printk(const char *level, const struct domain_device *ddev,\n\t\t\t  const char *fmt, ...)\n{\n\tstruct ata_port *ap = ddev->sata_dev.ap;\n\tstruct device *dev = &ddev->rphy->dev;\n\tstruct va_format vaf;\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tr = printk(\"%ssas: ata%u: %s: %pV\",\n\t\t   level, ap->print_id, dev_name(dev), &vaf);\n\n\tva_end(args);\n\n\treturn r;\n}\n\nstatic int sas_ata_hard_reset(struct ata_link *link, unsigned int *class,\n\t\t\t      unsigned long deadline)\n{\n\tint ret = 0, res;\n\tstruct sas_phy *phy;\n\tstruct ata_port *ap = link->ap;\n\tint (*check_ready)(struct ata_link *link);\n\tstruct domain_device *dev = ap->private_data;\n\tstruct sas_internal *i = dev_to_sas_internal(dev);\n\n\tres = i->dft->lldd_I_T_nexus_reset(dev);\n\tif (res == -ENODEV)\n\t\treturn res;\n\n\tif (res != TMF_RESP_FUNC_COMPLETE)\n\t\tsas_ata_printk(KERN_DEBUG, dev, \"Unable to reset ata device?\\n\");\n\n\tphy = sas_get_local_phy(dev);\n\tif (scsi_is_sas_phy_local(phy))\n\t\tcheck_ready = local_ata_check_ready;\n\telse\n\t\tcheck_ready = smp_ata_check_ready;\n\tsas_put_local_phy(phy);\n\n\tret = ata_wait_after_reset(link, deadline, check_ready);\n\tif (ret && ret != -EAGAIN)\n\t\tsas_ata_printk(KERN_ERR, dev, \"reset failed (errno=%d)\\n\", ret);\n\n\t*class = dev->sata_dev.class;\n\n\tap->cbl = ATA_CBL_SATA;\n\treturn ret;\n}\n\n/*\n * notify the lldd to forget the sas_task for this internal ata command\n * that bypasses scsi-eh\n */\nstatic void sas_ata_internal_abort(struct sas_task *task)\n{\n\tstruct sas_internal *si = dev_to_sas_internal(task->dev);\n\tunsigned long flags;\n\tint res;\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (task->task_state_flags & SAS_TASK_STATE_ABORTED ||\n\t    task->task_state_flags & SAS_TASK_STATE_DONE) {\n\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\t\tSAS_DPRINTK(\"%s: Task %p already finished.\\n\", __func__,\n\t\t\t    task);\n\t\tgoto out;\n\t}\n\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\tres = si->dft->lldd_abort_task(task);\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (task->task_state_flags & SAS_TASK_STATE_DONE ||\n\t    res == TMF_RESP_FUNC_COMPLETE) {\n\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\t\tgoto out;\n\t}\n\n\t/* XXX we are not prepared to deal with ->lldd_abort_task()\n\t * failures.  TODO: lldds need to unconditionally forget about\n\t * aborted ata tasks, otherwise we (likely) leak the sas task\n\t * here\n\t */\n\tSAS_DPRINTK(\"%s: Task %p leaked.\\n\", __func__, task);\n\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n\t\ttask->task_state_flags &= ~SAS_TASK_STATE_ABORTED;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\treturn;\n out:\n\tsas_free_task(task);\n}\n\nstatic void sas_ata_post_internal(struct ata_queued_cmd *qc)\n{\n\tif (qc->flags & ATA_QCFLAG_FAILED)\n\t\tqc->err_mask |= AC_ERR_OTHER;\n\n\tif (qc->err_mask) {\n\t\t/*\n\t\t * Find the sas_task and kill it.  By this point, libata\n\t\t * has decided to kill the qc and has frozen the port.\n\t\t * In this state sas_ata_task_done() will no longer free\n\t\t * the sas_task, so we need to notify the lldd (via\n\t\t * ->lldd_abort_task) that the task is dead and free it\n\t\t *  ourselves.\n\t\t */\n\t\tstruct sas_task *task = qc->lldd_task;\n\n\t\tqc->lldd_task = NULL;\n\t\tif (!task)\n\t\t\treturn;\n\t\ttask->uldd_task = NULL;\n\t\tsas_ata_internal_abort(task);\n\t}\n}\n\n\nstatic void sas_ata_set_dmamode(struct ata_port *ap, struct ata_device *ata_dev)\n{\n\tstruct domain_device *dev = ap->private_data;\n\tstruct sas_internal *i = dev_to_sas_internal(dev);\n\n\tif (i->dft->lldd_ata_set_dmamode)\n\t\ti->dft->lldd_ata_set_dmamode(dev);\n}\n\nstatic void sas_ata_sched_eh(struct ata_port *ap)\n{\n\tstruct domain_device *dev = ap->private_data;\n\tstruct sas_ha_struct *ha = dev->port->ha;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ha->lock, flags);\n\tif (!test_and_set_bit(SAS_DEV_EH_PENDING, &dev->state))\n\t\tha->eh_active++;\n\tata_std_sched_eh(ap);\n\tspin_unlock_irqrestore(&ha->lock, flags);\n}\n\nvoid sas_ata_end_eh(struct ata_port *ap)\n{\n\tstruct domain_device *dev = ap->private_data;\n\tstruct sas_ha_struct *ha = dev->port->ha;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ha->lock, flags);\n\tif (test_and_clear_bit(SAS_DEV_EH_PENDING, &dev->state))\n\t\tha->eh_active--;\n\tspin_unlock_irqrestore(&ha->lock, flags);\n}\n\nstatic struct ata_port_operations sas_sata_ops = {\n\t.prereset\t\t= ata_std_prereset,\n\t.hardreset\t\t= sas_ata_hard_reset,\n\t.postreset\t\t= ata_std_postreset,\n\t.error_handler\t\t= ata_std_error_handler,\n\t.post_internal_cmd\t= sas_ata_post_internal,\n\t.qc_defer               = ata_std_qc_defer,\n\t.qc_prep\t\t= ata_noop_qc_prep,\n\t.qc_issue\t\t= sas_ata_qc_issue,\n\t.qc_fill_rtf\t\t= sas_ata_qc_fill_rtf,\n\t.port_start\t\t= ata_sas_port_start,\n\t.port_stop\t\t= ata_sas_port_stop,\n\t.set_dmamode\t\t= sas_ata_set_dmamode,\n\t.sched_eh\t\t= sas_ata_sched_eh,\n\t.end_eh\t\t\t= sas_ata_end_eh,\n};\n\nstatic struct ata_port_info sata_port_info = {\n\t.flags = ATA_FLAG_SATA | ATA_FLAG_PIO_DMA | ATA_FLAG_NCQ |\n\t\t ATA_FLAG_SAS_HOST | ATA_FLAG_FPDMA_AUX,\n\t.pio_mask = ATA_PIO4,\n\t.mwdma_mask = ATA_MWDMA2,\n\t.udma_mask = ATA_UDMA6,\n\t.port_ops = &sas_sata_ops\n};\n\nint sas_ata_init(struct domain_device *found_dev)\n{\n\tstruct sas_ha_struct *ha = found_dev->port->ha;\n\tstruct Scsi_Host *shost = ha->core.shost;\n\tstruct ata_port *ap;\n\tint rc;\n\n\tata_host_init(&found_dev->sata_dev.ata_host, ha->dev, &sas_sata_ops);\n\tap = ata_sas_port_alloc(&found_dev->sata_dev.ata_host,\n\t\t\t\t&sata_port_info,\n\t\t\t\tshost);\n\tif (!ap) {\n\t\tSAS_DPRINTK(\"ata_sas_port_alloc failed.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tap->private_data = found_dev;\n\tap->cbl = ATA_CBL_SATA;\n\tap->scsi_host = shost;\n\trc = ata_sas_port_init(ap);\n\tif (rc) {\n\t\tata_sas_port_destroy(ap);\n\t\treturn rc;\n\t}\n\tfound_dev->sata_dev.ap = ap;\n\n\treturn 0;\n}\n\nvoid sas_ata_task_abort(struct sas_task *task)\n{\n\tstruct ata_queued_cmd *qc = task->uldd_task;\n\tstruct completion *waiting;\n\n\t/* Bounce SCSI-initiated commands to the SCSI EH */\n\tif (qc->scsicmd) {\n\t\tstruct request_queue *q = qc->scsicmd->device->request_queue;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(q->queue_lock, flags);\n\t\tblk_abort_request(qc->scsicmd->request);\n\t\tspin_unlock_irqrestore(q->queue_lock, flags);\n\t\treturn;\n\t}\n\n\t/* Internal command, fake a timeout and complete. */\n\tqc->flags &= ~ATA_QCFLAG_ACTIVE;\n\tqc->flags |= ATA_QCFLAG_FAILED;\n\tqc->err_mask |= AC_ERR_TIMEOUT;\n\twaiting = qc->private_data;\n\tcomplete(waiting);\n}\n\nstatic int sas_get_ata_command_set(struct domain_device *dev)\n{\n\tstruct dev_to_host_fis *fis =\n\t\t(struct dev_to_host_fis *) dev->frame_rcvd;\n\tstruct ata_taskfile tf;\n\n\tif (dev->dev_type == SAS_SATA_PENDING)\n\t\treturn ATA_DEV_UNKNOWN;\n\n\tata_tf_from_fis((const u8 *)fis, &tf);\n\n\treturn ata_dev_classify(&tf);\n}\n\nvoid sas_probe_sata(struct asd_sas_port *port)\n{\n\tstruct domain_device *dev, *n;\n\n\tmutex_lock(&port->ha->disco_mutex);\n\tlist_for_each_entry(dev, &port->disco_list, disco_list_node) {\n\t\tif (!dev_is_sata(dev))\n\t\t\tcontinue;\n\n\t\tata_sas_async_probe(dev->sata_dev.ap);\n\t}\n\tmutex_unlock(&port->ha->disco_mutex);\n\n\tlist_for_each_entry_safe(dev, n, &port->disco_list, disco_list_node) {\n\t\tif (!dev_is_sata(dev))\n\t\t\tcontinue;\n\n\t\tsas_ata_wait_eh(dev);\n\n\t\t/* if libata could not bring the link up, don't surface\n\t\t * the device\n\t\t */\n\t\tif (ata_dev_disabled(sas_to_ata_dev(dev)))\n\t\t\tsas_fail_probe(dev, __func__, -ENODEV);\n\t}\n\n}\n\nstatic void sas_ata_flush_pm_eh(struct asd_sas_port *port, const char *func)\n{\n\tstruct domain_device *dev, *n;\n\n\tlist_for_each_entry_safe(dev, n, &port->dev_list, dev_list_node) {\n\t\tif (!dev_is_sata(dev))\n\t\t\tcontinue;\n\n\t\tsas_ata_wait_eh(dev);\n\n\t\t/* if libata failed to power manage the device, tear it down */\n\t\tif (ata_dev_disabled(sas_to_ata_dev(dev)))\n\t\t\tsas_fail_probe(dev, func, -ENODEV);\n\t}\n}\n\nvoid sas_suspend_sata(struct asd_sas_port *port)\n{\n\tstruct domain_device *dev;\n\n\tmutex_lock(&port->ha->disco_mutex);\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\tstruct sata_device *sata;\n\n\t\tif (!dev_is_sata(dev))\n\t\t\tcontinue;\n\n\t\tsata = &dev->sata_dev;\n\t\tif (sata->ap->pm_mesg.event == PM_EVENT_SUSPEND)\n\t\t\tcontinue;\n\n\t\tata_sas_port_suspend(sata->ap);\n\t}\n\tmutex_unlock(&port->ha->disco_mutex);\n\n\tsas_ata_flush_pm_eh(port, __func__);\n}\n\nvoid sas_resume_sata(struct asd_sas_port *port)\n{\n\tstruct domain_device *dev;\n\n\tmutex_lock(&port->ha->disco_mutex);\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\tstruct sata_device *sata;\n\n\t\tif (!dev_is_sata(dev))\n\t\t\tcontinue;\n\n\t\tsata = &dev->sata_dev;\n\t\tif (sata->ap->pm_mesg.event == PM_EVENT_ON)\n\t\t\tcontinue;\n\n\t\tata_sas_port_resume(sata->ap);\n\t}\n\tmutex_unlock(&port->ha->disco_mutex);\n\n\tsas_ata_flush_pm_eh(port, __func__);\n}\n\n/**\n * sas_discover_sata -- discover an STP/SATA domain device\n * @dev: pointer to struct domain_device of interest\n *\n * Devices directly attached to a HA port, have no parents.  All other\n * devices do, and should have their \"parent\" pointer set appropriately\n * before calling this function.\n */\nint sas_discover_sata(struct domain_device *dev)\n{\n\tint res;\n\n\tif (dev->dev_type == SAS_SATA_PM)\n\t\treturn -ENODEV;\n\n\tdev->sata_dev.class = sas_get_ata_command_set(dev);\n\tsas_fill_in_rphy(dev, dev->rphy);\n\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\n\tsas_discover_event(dev->port, DISCE_PROBE);\n\treturn 0;\n}\n\nstatic void async_sas_ata_eh(void *data, async_cookie_t cookie)\n{\n\tstruct domain_device *dev = data;\n\tstruct ata_port *ap = dev->sata_dev.ap;\n\tstruct sas_ha_struct *ha = dev->port->ha;\n\n\tsas_ata_printk(KERN_DEBUG, dev, \"dev error handler\\n\");\n\tata_scsi_port_error_handler(ha->core.shost, ap);\n\tsas_put_device(dev);\n}\n\nvoid sas_ata_strategy_handler(struct Scsi_Host *shost)\n{\n\tstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(shost);\n\tASYNC_DOMAIN_EXCLUSIVE(async);\n\tint i;\n\n\t/* it's ok to defer revalidation events during ata eh, these\n\t * disks are in one of three states:\n\t * 1/ present for initial domain discovery, and these\n\t *    resets will cause bcn flutters\n\t * 2/ hot removed, we'll discover that after eh fails\n\t * 3/ hot added after initial discovery, lost the race, and need\n\t *    to catch the next train.\n\t */\n\tsas_disable_revalidation(sas_ha);\n\n\tspin_lock_irq(&sas_ha->phy_port_lock);\n\tfor (i = 0; i < sas_ha->num_phys; i++) {\n\t\tstruct asd_sas_port *port = sas_ha->sas_port[i];\n\t\tstruct domain_device *dev;\n\n\t\tspin_lock(&port->dev_list_lock);\n\t\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\t\tif (!dev_is_sata(dev))\n\t\t\t\tcontinue;\n\n\t\t\t/* hold a reference over eh since we may be\n\t\t\t * racing with final remove once all commands\n\t\t\t * are completed\n\t\t\t */\n\t\t\tkref_get(&dev->kref);\n\n\t\t\tasync_schedule_domain(async_sas_ata_eh, dev, &async);\n\t\t}\n\t\tspin_unlock(&port->dev_list_lock);\n\t}\n\tspin_unlock_irq(&sas_ha->phy_port_lock);\n\n\tasync_synchronize_full_domain(&async);\n\n\tsas_enable_revalidation(sas_ha);\n}\n\nvoid sas_ata_eh(struct Scsi_Host *shost, struct list_head *work_q,\n\t\tstruct list_head *done_q)\n{\n\tstruct scsi_cmnd *cmd, *n;\n\tstruct domain_device *eh_dev;\n\n\tdo {\n\t\tLIST_HEAD(sata_q);\n\t\teh_dev = NULL;\n\n\t\tlist_for_each_entry_safe(cmd, n, work_q, eh_entry) {\n\t\t\tstruct domain_device *ddev = cmd_to_domain_dev(cmd);\n\n\t\t\tif (!dev_is_sata(ddev) || TO_SAS_TASK(cmd))\n\t\t\t\tcontinue;\n\t\t\tif (eh_dev && eh_dev != ddev)\n\t\t\t\tcontinue;\n\t\t\teh_dev = ddev;\n\t\t\tlist_move(&cmd->eh_entry, &sata_q);\n\t\t}\n\n\t\tif (!list_empty(&sata_q)) {\n\t\t\tstruct ata_port *ap = eh_dev->sata_dev.ap;\n\n\t\t\tsas_ata_printk(KERN_DEBUG, eh_dev, \"cmd error handler\\n\");\n\t\t\tata_scsi_cmd_error_handler(shost, ap, &sata_q);\n\t\t\t/*\n\t\t\t * ata's error handler may leave the cmd on the list\n\t\t\t * so make sure they don't remain on a stack list\n\t\t\t * about to go out of scope.\n\t\t\t *\n\t\t\t * This looks strange, since the commands are\n\t\t\t * now part of no list, but the next error\n\t\t\t * action will be ata_port_error_handler()\n\t\t\t * which takes no list and sweeps them up\n\t\t\t * anyway from the ata tag array.\n\t\t\t */\n\t\t\twhile (!list_empty(&sata_q))\n\t\t\t\tlist_del_init(sata_q.next);\n\t\t}\n\t} while (eh_dev);\n}\n\nvoid sas_ata_schedule_reset(struct domain_device *dev)\n{\n\tstruct ata_eh_info *ehi;\n\tstruct ata_port *ap;\n\tunsigned long flags;\n\n\tif (!dev_is_sata(dev))\n\t\treturn;\n\n\tap = dev->sata_dev.ap;\n\tehi = &ap->link.eh_info;\n\n\tspin_lock_irqsave(ap->lock, flags);\n\tehi->err_mask |= AC_ERR_TIMEOUT;\n\tehi->action |= ATA_EH_RESET;\n\tata_port_schedule_eh(ap);\n\tspin_unlock_irqrestore(ap->lock, flags);\n}\nEXPORT_SYMBOL_GPL(sas_ata_schedule_reset);\n\nvoid sas_ata_wait_eh(struct domain_device *dev)\n{\n\tstruct ata_port *ap;\n\n\tif (!dev_is_sata(dev))\n\t\treturn;\n\n\tap = dev->sata_dev.ap;\n\tata_port_wait_eh(ap);\n}\n", "/*\n * Serial Attached SCSI (SAS) Discover process\n *\n * Copyright (C) 2005 Adaptec, Inc.  All rights reserved.\n * Copyright (C) 2005 Luben Tuikov <luben_tuikov@adaptec.com>\n *\n * This file is licensed under GPLv2.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <linux/async.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_eh.h>\n#include \"sas_internal.h\"\n\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_sas.h>\n#include <scsi/sas_ata.h>\n#include \"../scsi_sas_internal.h\"\n\n/* ---------- Basic task processing for discovery purposes ---------- */\n\nvoid sas_init_dev(struct domain_device *dev)\n{\n\tswitch (dev->dev_type) {\n\tcase SAS_END_DEVICE:\n\t\tINIT_LIST_HEAD(&dev->ssp_dev.eh_list_node);\n\t\tbreak;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\tINIT_LIST_HEAD(&dev->ex_dev.children);\n\t\tmutex_init(&dev->ex_dev.cmd_mutex);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/* ---------- Domain device discovery ---------- */\n\n/**\n * sas_get_port_device -- Discover devices which caused port creation\n * @port: pointer to struct sas_port of interest\n *\n * Devices directly attached to a HA port, have no parent.  This is\n * how we know they are (domain) \"root\" devices.  All other devices\n * do, and should have their \"parent\" pointer set appropriately as\n * soon as a child device is discovered.\n */\nstatic int sas_get_port_device(struct asd_sas_port *port)\n{\n\tstruct asd_sas_phy *phy;\n\tstruct sas_rphy *rphy;\n\tstruct domain_device *dev;\n\tint rc = -ENODEV;\n\n\tdev = sas_alloc_device();\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&port->phy_list_lock);\n\tif (list_empty(&port->phy_list)) {\n\t\tspin_unlock_irq(&port->phy_list_lock);\n\t\tsas_put_device(dev);\n\t\treturn -ENODEV;\n\t}\n\tphy = container_of(port->phy_list.next, struct asd_sas_phy, port_phy_el);\n\tspin_lock(&phy->frame_rcvd_lock);\n\tmemcpy(dev->frame_rcvd, phy->frame_rcvd, min(sizeof(dev->frame_rcvd),\n\t\t\t\t\t     (size_t)phy->frame_rcvd_size));\n\tspin_unlock(&phy->frame_rcvd_lock);\n\tspin_unlock_irq(&port->phy_list_lock);\n\n\tif (dev->frame_rcvd[0] == 0x34 && port->oob_mode == SATA_OOB_MODE) {\n\t\tstruct dev_to_host_fis *fis =\n\t\t\t(struct dev_to_host_fis *) dev->frame_rcvd;\n\t\tif (fis->interrupt_reason == 1 && fis->lbal == 1 &&\n\t\t    fis->byte_count_low==0x69 && fis->byte_count_high == 0x96\n\t\t    && (fis->device & ~0x10) == 0)\n\t\t\tdev->dev_type = SAS_SATA_PM;\n\t\telse\n\t\t\tdev->dev_type = SAS_SATA_DEV;\n\t\tdev->tproto = SAS_PROTOCOL_SATA;\n\t} else {\n\t\tstruct sas_identify_frame *id =\n\t\t\t(struct sas_identify_frame *) dev->frame_rcvd;\n\t\tdev->dev_type = id->dev_type;\n\t\tdev->iproto = id->initiator_bits;\n\t\tdev->tproto = id->target_bits;\n\t}\n\n\tsas_init_dev(dev);\n\n\tdev->port = port;\n\tswitch (dev->dev_type) {\n\tcase SAS_SATA_DEV:\n\t\trc = sas_ata_init(dev);\n\t\tif (rc) {\n\t\t\trphy = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t/* fall through */\n\tcase SAS_END_DEVICE:\n\t\trphy = sas_end_device_alloc(port->port);\n\t\tbreak;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\trphy = sas_expander_alloc(port->port,\n\t\t\t\t\t  SAS_EDGE_EXPANDER_DEVICE);\n\t\tbreak;\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\trphy = sas_expander_alloc(port->port,\n\t\t\t\t\t  SAS_FANOUT_EXPANDER_DEVICE);\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"ERROR: Unidentified device type %d\\n\", dev->dev_type);\n\t\trphy = NULL;\n\t\tbreak;\n\t}\n\n\tif (!rphy) {\n\t\tsas_put_device(dev);\n\t\treturn rc;\n\t}\n\n\trphy->identify.phy_identifier = phy->phy->identify.phy_identifier;\n\tmemcpy(dev->sas_addr, port->attached_sas_addr, SAS_ADDR_SIZE);\n\tsas_fill_in_rphy(dev, rphy);\n\tsas_hash_addr(dev->hashed_sas_addr, dev->sas_addr);\n\tport->port_dev = dev;\n\tdev->linkrate = port->linkrate;\n\tdev->min_linkrate = port->linkrate;\n\tdev->max_linkrate = port->linkrate;\n\tdev->pathways = port->num_phys;\n\tmemset(port->disc.fanout_sas_addr, 0, SAS_ADDR_SIZE);\n\tmemset(port->disc.eeds_a, 0, SAS_ADDR_SIZE);\n\tmemset(port->disc.eeds_b, 0, SAS_ADDR_SIZE);\n\tport->disc.max_level = 0;\n\tsas_device_set_phy(dev, port->port);\n\n\tdev->rphy = rphy;\n\tget_device(&dev->rphy->dev);\n\n\tif (dev_is_sata(dev) || dev->dev_type == SAS_END_DEVICE)\n\t\tlist_add_tail(&dev->disco_list_node, &port->disco_list);\n\telse {\n\t\tspin_lock_irq(&port->dev_list_lock);\n\t\tlist_add_tail(&dev->dev_list_node, &port->dev_list);\n\t\tspin_unlock_irq(&port->dev_list_lock);\n\t}\n\n\tspin_lock_irq(&port->phy_list_lock);\n\tlist_for_each_entry(phy, &port->phy_list, port_phy_el)\n\t\tsas_phy_set_target(phy, dev);\n\tspin_unlock_irq(&port->phy_list_lock);\n\n\treturn 0;\n}\n\n/* ---------- Discover and Revalidate ---------- */\n\nint sas_notify_lldd_dev_found(struct domain_device *dev)\n{\n\tint res = 0;\n\tstruct sas_ha_struct *sas_ha = dev->port->ha;\n\tstruct Scsi_Host *shost = sas_ha->core.shost;\n\tstruct sas_internal *i = to_sas_internal(shost->transportt);\n\n\tif (!i->dft->lldd_dev_found)\n\t\treturn 0;\n\n\tres = i->dft->lldd_dev_found(dev);\n\tif (res) {\n\t\tprintk(\"sas: driver on pcidev %s cannot handle \"\n\t\t       \"device %llx, error:%d\\n\",\n\t\t       dev_name(sas_ha->dev),\n\t\t       SAS_ADDR(dev->sas_addr), res);\n\t}\n\tset_bit(SAS_DEV_FOUND, &dev->state);\n\tkref_get(&dev->kref);\n\treturn res;\n}\n\n\nvoid sas_notify_lldd_dev_gone(struct domain_device *dev)\n{\n\tstruct sas_ha_struct *sas_ha = dev->port->ha;\n\tstruct Scsi_Host *shost = sas_ha->core.shost;\n\tstruct sas_internal *i = to_sas_internal(shost->transportt);\n\n\tif (!i->dft->lldd_dev_gone)\n\t\treturn;\n\n\tif (test_and_clear_bit(SAS_DEV_FOUND, &dev->state)) {\n\t\ti->dft->lldd_dev_gone(dev);\n\t\tsas_put_device(dev);\n\t}\n}\n\nstatic void sas_probe_devices(struct work_struct *work)\n{\n\tstruct domain_device *dev, *n;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\n\tclear_bit(DISCE_PROBE, &port->disc.pending);\n\n\t/* devices must be domain members before link recovery and probe */\n\tlist_for_each_entry(dev, &port->disco_list, disco_list_node) {\n\t\tspin_lock_irq(&port->dev_list_lock);\n\t\tlist_add_tail(&dev->dev_list_node, &port->dev_list);\n\t\tspin_unlock_irq(&port->dev_list_lock);\n\t}\n\n\tsas_probe_sata(port);\n\n\tlist_for_each_entry_safe(dev, n, &port->disco_list, disco_list_node) {\n\t\tint err;\n\n\t\terr = sas_rphy_add(dev->rphy);\n\t\tif (err)\n\t\t\tsas_fail_probe(dev, __func__, err);\n\t\telse\n\t\t\tlist_del_init(&dev->disco_list_node);\n\t}\n}\n\nstatic void sas_suspend_devices(struct work_struct *work)\n{\n\tstruct asd_sas_phy *phy;\n\tstruct domain_device *dev;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\tstruct Scsi_Host *shost = port->ha->core.shost;\n\tstruct sas_internal *si = to_sas_internal(shost->transportt);\n\n\tclear_bit(DISCE_SUSPEND, &port->disc.pending);\n\n\tsas_suspend_sata(port);\n\n\t/* lldd is free to forget the domain_device across the\n\t * suspension, we force the issue here to keep the reference\n\t * counts aligned\n\t */\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node)\n\t\tsas_notify_lldd_dev_gone(dev);\n\n\t/* we are suspending, so we know events are disabled and\n\t * phy_list is not being mutated\n\t */\n\tlist_for_each_entry(phy, &port->phy_list, port_phy_el) {\n\t\tif (si->dft->lldd_port_formed)\n\t\t\tsi->dft->lldd_port_deformed(phy);\n\t\tphy->suspended = 1;\n\t\tport->suspended = 1;\n\t}\n}\n\nstatic void sas_resume_devices(struct work_struct *work)\n{\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\n\tclear_bit(DISCE_RESUME, &port->disc.pending);\n\n\tsas_resume_sata(port);\n}\n\n/**\n * sas_discover_end_dev -- discover an end device (SSP, etc)\n * @end: pointer to domain device of interest\n *\n * See comment in sas_discover_sata().\n */\nint sas_discover_end_dev(struct domain_device *dev)\n{\n\tint res;\n\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\tsas_discover_event(dev->port, DISCE_PROBE);\n\n\treturn 0;\n}\n\n/* ---------- Device registration and unregistration ---------- */\n\nvoid sas_free_device(struct kref *kref)\n{\n\tstruct domain_device *dev = container_of(kref, typeof(*dev), kref);\n\n\tput_device(&dev->rphy->dev);\n\tdev->rphy = NULL;\n\n\tif (dev->parent)\n\t\tsas_put_device(dev->parent);\n\n\tsas_port_put_phy(dev->phy);\n\tdev->phy = NULL;\n\n\t/* remove the phys and ports, everything else should be gone */\n\tif (dev->dev_type == SAS_EDGE_EXPANDER_DEVICE || dev->dev_type == SAS_FANOUT_EXPANDER_DEVICE)\n\t\tkfree(dev->ex_dev.ex_phy);\n\n\tif (dev_is_sata(dev) && dev->sata_dev.ap) {\n\t\tata_sas_port_destroy(dev->sata_dev.ap);\n\t\tdev->sata_dev.ap = NULL;\n\t}\n\n\tkfree(dev);\n}\n\nstatic void sas_unregister_common_dev(struct asd_sas_port *port, struct domain_device *dev)\n{\n\tstruct sas_ha_struct *ha = port->ha;\n\n\tsas_notify_lldd_dev_gone(dev);\n\tif (!dev->parent)\n\t\tdev->port->port_dev = NULL;\n\telse\n\t\tlist_del_init(&dev->siblings);\n\n\tspin_lock_irq(&port->dev_list_lock);\n\tlist_del_init(&dev->dev_list_node);\n\tif (dev_is_sata(dev))\n\t\tsas_ata_end_eh(dev->sata_dev.ap);\n\tspin_unlock_irq(&port->dev_list_lock);\n\n\tspin_lock_irq(&ha->lock);\n\tif (dev->dev_type == SAS_END_DEVICE &&\n\t    !list_empty(&dev->ssp_dev.eh_list_node)) {\n\t\tlist_del_init(&dev->ssp_dev.eh_list_node);\n\t\tha->eh_active--;\n\t}\n\tspin_unlock_irq(&ha->lock);\n\n\tsas_put_device(dev);\n}\n\nstatic void sas_destruct_devices(struct work_struct *work)\n{\n\tstruct domain_device *dev, *n;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\n\tclear_bit(DISCE_DESTRUCT, &port->disc.pending);\n\n\tlist_for_each_entry_safe(dev, n, &port->destroy_list, disco_list_node) {\n\t\tlist_del_init(&dev->disco_list_node);\n\n\t\tsas_remove_children(&dev->rphy->dev);\n\t\tsas_rphy_delete(dev->rphy);\n\t\tsas_unregister_common_dev(port, dev);\n\t}\n}\n\nvoid sas_unregister_dev(struct asd_sas_port *port, struct domain_device *dev)\n{\n\tif (!test_bit(SAS_DEV_DESTROY, &dev->state) &&\n\t    !list_empty(&dev->disco_list_node)) {\n\t\t/* this rphy never saw sas_rphy_add */\n\t\tlist_del_init(&dev->disco_list_node);\n\t\tsas_rphy_free(dev->rphy);\n\t\tsas_unregister_common_dev(port, dev);\n\t\treturn;\n\t}\n\n\tif (!test_and_set_bit(SAS_DEV_DESTROY, &dev->state)) {\n\t\tsas_rphy_unlink(dev->rphy);\n\t\tlist_move_tail(&dev->disco_list_node, &port->destroy_list);\n\t\tsas_discover_event(dev->port, DISCE_DESTRUCT);\n\t}\n}\n\nvoid sas_unregister_domain_devices(struct asd_sas_port *port, int gone)\n{\n\tstruct domain_device *dev, *n;\n\n\tlist_for_each_entry_safe_reverse(dev, n, &port->dev_list, dev_list_node) {\n\t\tif (gone)\n\t\t\tset_bit(SAS_DEV_GONE, &dev->state);\n\t\tsas_unregister_dev(port, dev);\n\t}\n\n\tlist_for_each_entry_safe(dev, n, &port->disco_list, disco_list_node)\n\t\tsas_unregister_dev(port, dev);\n\n\tport->port->rphy = NULL;\n\n}\n\nvoid sas_device_set_phy(struct domain_device *dev, struct sas_port *port)\n{\n\tstruct sas_ha_struct *ha;\n\tstruct sas_phy *new_phy;\n\n\tif (!dev)\n\t\treturn;\n\n\tha = dev->port->ha;\n\tnew_phy = sas_port_get_phy(port);\n\n\t/* pin and record last seen phy */\n\tspin_lock_irq(&ha->phy_port_lock);\n\tif (new_phy) {\n\t\tsas_port_put_phy(dev->phy);\n\t\tdev->phy = new_phy;\n\t}\n\tspin_unlock_irq(&ha->phy_port_lock);\n}\n\n/* ---------- Discovery and Revalidation ---------- */\n\n/**\n * sas_discover_domain -- discover the domain\n * @port: port to the domain of interest\n *\n * NOTE: this process _must_ quit (return) as soon as any connection\n * errors are encountered.  Connection recovery is done elsewhere.\n * Discover process only interrogates devices in order to discover the\n * domain.\n */\nstatic void sas_discover_domain(struct work_struct *work)\n{\n\tstruct domain_device *dev;\n\tint error = 0;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\n\tclear_bit(DISCE_DISCOVER_DOMAIN, &port->disc.pending);\n\n\tif (port->port_dev)\n\t\treturn;\n\n\terror = sas_get_port_device(port);\n\tif (error)\n\t\treturn;\n\tdev = port->port_dev;\n\n\tSAS_DPRINTK(\"DOING DISCOVERY on port %d, pid:%d\\n\", port->id,\n\t\t    task_pid_nr(current));\n\n\tswitch (dev->dev_type) {\n\tcase SAS_END_DEVICE:\n\t\terror = sas_discover_end_dev(dev);\n\t\tbreak;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\terror = sas_discover_root_expander(dev);\n\t\tbreak;\n\tcase SAS_SATA_DEV:\n\tcase SAS_SATA_PM:\n#ifdef CONFIG_SCSI_SAS_ATA\n\t\terror = sas_discover_sata(dev);\n\t\tbreak;\n#else\n\t\tSAS_DPRINTK(\"ATA device seen but CONFIG_SCSI_SAS_ATA=N so cannot attach\\n\");\n\t\t/* Fall through */\n#endif\n\tdefault:\n\t\terror = -ENXIO;\n\t\tSAS_DPRINTK(\"unhandled device %d\\n\", dev->dev_type);\n\t\tbreak;\n\t}\n\n\tif (error) {\n\t\tsas_rphy_free(dev->rphy);\n\t\tlist_del_init(&dev->disco_list_node);\n\t\tspin_lock_irq(&port->dev_list_lock);\n\t\tlist_del_init(&dev->dev_list_node);\n\t\tspin_unlock_irq(&port->dev_list_lock);\n\n\t\tsas_put_device(dev);\n\t\tport->port_dev = NULL;\n\t}\n\n\tSAS_DPRINTK(\"DONE DISCOVERY on port %d, pid:%d, result:%d\\n\", port->id,\n\t\t    task_pid_nr(current), error);\n}\n\nstatic void sas_revalidate_domain(struct work_struct *work)\n{\n\tint res = 0;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\tstruct sas_ha_struct *ha = port->ha;\n\tstruct domain_device *ddev = port->port_dev;\n\n\t/* prevent revalidation from finding sata links in recovery */\n\tmutex_lock(&ha->disco_mutex);\n\tif (test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state)) {\n\t\tSAS_DPRINTK(\"REVALIDATION DEFERRED on port %d, pid:%d\\n\",\n\t\t\t    port->id, task_pid_nr(current));\n\t\tgoto out;\n\t}\n\n\tclear_bit(DISCE_REVALIDATE_DOMAIN, &port->disc.pending);\n\n\tSAS_DPRINTK(\"REVALIDATING DOMAIN on port %d, pid:%d\\n\", port->id,\n\t\t    task_pid_nr(current));\n\n\tif (ddev && (ddev->dev_type == SAS_FANOUT_EXPANDER_DEVICE ||\n\t\t     ddev->dev_type == SAS_EDGE_EXPANDER_DEVICE))\n\t\tres = sas_ex_revalidate_domain(ddev);\n\n\tSAS_DPRINTK(\"done REVALIDATING DOMAIN on port %d, pid:%d, res 0x%x\\n\",\n\t\t    port->id, task_pid_nr(current), res);\n out:\n\tmutex_unlock(&ha->disco_mutex);\n}\n\n/* ---------- Events ---------- */\n\nstatic void sas_chain_work(struct sas_ha_struct *ha, struct sas_work *sw)\n{\n\t/* chained work is not subject to SA_HA_DRAINING or\n\t * SAS_HA_REGISTERED, because it is either submitted in the\n\t * workqueue, or known to be submitted from a context that is\n\t * not racing against draining\n\t */\n\tqueue_work(ha->disco_q, &sw->work);\n}\n\nstatic void sas_chain_event(int event, unsigned long *pending,\n\t\t\t    struct sas_work *sw,\n\t\t\t    struct sas_ha_struct *ha)\n{\n\tif (!test_and_set_bit(event, pending)) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&ha->lock, flags);\n\t\tsas_chain_work(ha, sw);\n\t\tspin_unlock_irqrestore(&ha->lock, flags);\n\t}\n}\n\nint sas_discover_event(struct asd_sas_port *port, enum discover_event ev)\n{\n\tstruct sas_discovery *disc;\n\n\tif (!port)\n\t\treturn 0;\n\tdisc = &port->disc;\n\n\tBUG_ON(ev >= DISC_NUM_EVENTS);\n\n\tsas_chain_event(ev, &disc->pending, &disc->disc_work[ev].work, port->ha);\n\n\treturn 0;\n}\n\n/**\n * sas_init_disc -- initialize the discovery struct in the port\n * @port: pointer to struct port\n *\n * Called when the ports are being initialized.\n */\nvoid sas_init_disc(struct sas_discovery *disc, struct asd_sas_port *port)\n{\n\tint i;\n\n\tstatic const work_func_t sas_event_fns[DISC_NUM_EVENTS] = {\n\t\t[DISCE_DISCOVER_DOMAIN] = sas_discover_domain,\n\t\t[DISCE_REVALIDATE_DOMAIN] = sas_revalidate_domain,\n\t\t[DISCE_PROBE] = sas_probe_devices,\n\t\t[DISCE_SUSPEND] = sas_suspend_devices,\n\t\t[DISCE_RESUME] = sas_resume_devices,\n\t\t[DISCE_DESTRUCT] = sas_destruct_devices,\n\t};\n\n\tdisc->pending = 0;\n\tfor (i = 0; i < DISC_NUM_EVENTS; i++) {\n\t\tINIT_SAS_WORK(&disc->disc_work[i].work, sas_event_fns[i]);\n\t\tdisc->disc_work[i].port = port;\n\t}\n}\n", "/*\n * Serial Attached SCSI (SAS) Expander discovery and configuration\n *\n * Copyright (C) 2005 Adaptec, Inc.  All rights reserved.\n * Copyright (C) 2005 Luben Tuikov <luben_tuikov@adaptec.com>\n *\n * This file is licensed under GPLv2.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\n#include \"sas_internal.h\"\n\n#include <scsi/sas_ata.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_sas.h>\n#include \"../scsi_sas_internal.h\"\n\nstatic int sas_discover_expander(struct domain_device *dev);\nstatic int sas_configure_routing(struct domain_device *dev, u8 *sas_addr);\nstatic int sas_configure_phy(struct domain_device *dev, int phy_id,\n\t\t\t     u8 *sas_addr, int include);\nstatic int sas_disable_routing(struct domain_device *dev,  u8 *sas_addr);\n\n/* ---------- SMP task management ---------- */\n\nstatic void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n\t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\tcomplete(&task->slow_task->completion);\n}\n\nstatic void smp_task_done(struct sas_task *task)\n{\n\tif (!del_timer(&task->slow_task->timer))\n\t\treturn;\n\tcomplete(&task->slow_task->completion);\n}\n\n/* Give it some long enough timeout. In seconds. */\n#define SMP_TIMEOUT 10\n\nstatic int smp_execute_task_sg(struct domain_device *dev,\n\t\tstruct scatterlist *req, struct scatterlist *resp)\n{\n\tint res, retry;\n\tstruct sas_task *task = NULL;\n\tstruct sas_internal *i =\n\t\tto_sas_internal(dev->port->ha->core.shost->transportt);\n\n\tmutex_lock(&dev->ex_dev.cmd_mutex);\n\tfor (retry = 0; retry < 3; retry++) {\n\t\tif (test_bit(SAS_DEV_GONE, &dev->state)) {\n\t\t\tres = -ECOMM;\n\t\t\tbreak;\n\t\t}\n\n\t\ttask = sas_alloc_slow_task(GFP_KERNEL);\n\t\tif (!task) {\n\t\t\tres = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\ttask->dev = dev;\n\t\ttask->task_proto = dev->tproto;\n\t\ttask->smp_task.smp_req = *req;\n\t\ttask->smp_task.smp_resp = *resp;\n\n\t\ttask->task_done = smp_task_done;\n\n\t\ttask->slow_task->timer.function = smp_task_timedout;\n\t\ttask->slow_task->timer.expires = jiffies + SMP_TIMEOUT*HZ;\n\t\tadd_timer(&task->slow_task->timer);\n\n\t\tres = i->dft->lldd_execute_task(task, GFP_KERNEL);\n\n\t\tif (res) {\n\t\t\tdel_timer(&task->slow_task->timer);\n\t\t\tSAS_DPRINTK(\"executing SMP task failed:%d\\n\", res);\n\t\t\tbreak;\n\t\t}\n\n\t\twait_for_completion(&task->slow_task->completion);\n\t\tres = -ECOMM;\n\t\tif ((task->task_state_flags & SAS_TASK_STATE_ABORTED)) {\n\t\t\tSAS_DPRINTK(\"smp task timed out or aborted\\n\");\n\t\t\ti->dft->lldd_abort_task(task);\n\t\t\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {\n\t\t\t\tSAS_DPRINTK(\"SMP task aborted and not done\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (task->task_status.resp == SAS_TASK_COMPLETE &&\n\t\t    task->task_status.stat == SAM_STAT_GOOD) {\n\t\t\tres = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (task->task_status.resp == SAS_TASK_COMPLETE &&\n\t\t    task->task_status.stat == SAS_DATA_UNDERRUN) {\n\t\t\t/* no error, but return the number of bytes of\n\t\t\t * underrun */\n\t\t\tres = task->task_status.residual;\n\t\t\tbreak;\n\t\t}\n\t\tif (task->task_status.resp == SAS_TASK_COMPLETE &&\n\t\t    task->task_status.stat == SAS_DATA_OVERRUN) {\n\t\t\tres = -EMSGSIZE;\n\t\t\tbreak;\n\t\t}\n\t\tif (task->task_status.resp == SAS_TASK_UNDELIVERED &&\n\t\t    task->task_status.stat == SAS_DEVICE_UNKNOWN)\n\t\t\tbreak;\n\t\telse {\n\t\t\tSAS_DPRINTK(\"%s: task to dev %016llx response: 0x%x \"\n\t\t\t\t    \"status 0x%x\\n\", __func__,\n\t\t\t\t    SAS_ADDR(dev->sas_addr),\n\t\t\t\t    task->task_status.resp,\n\t\t\t\t    task->task_status.stat);\n\t\t\tsas_free_task(task);\n\t\t\ttask = NULL;\n\t\t}\n\t}\n\tmutex_unlock(&dev->ex_dev.cmd_mutex);\n\n\tBUG_ON(retry == 3 && task != NULL);\n\tsas_free_task(task);\n\treturn res;\n}\n\nstatic int smp_execute_task(struct domain_device *dev, void *req, int req_size,\n\t\t\t    void *resp, int resp_size)\n{\n\tstruct scatterlist req_sg;\n\tstruct scatterlist resp_sg;\n\n\tsg_init_one(&req_sg, req, req_size);\n\tsg_init_one(&resp_sg, resp, resp_size);\n\treturn smp_execute_task_sg(dev, &req_sg, &resp_sg);\n}\n\n/* ---------- Allocations ---------- */\n\nstatic inline void *alloc_smp_req(int size)\n{\n\tu8 *p = kzalloc(size, GFP_KERNEL);\n\tif (p)\n\t\tp[0] = SMP_REQUEST;\n\treturn p;\n}\n\nstatic inline void *alloc_smp_resp(int size)\n{\n\treturn kzalloc(size, GFP_KERNEL);\n}\n\nstatic char sas_route_char(struct domain_device *dev, struct ex_phy *phy)\n{\n\tswitch (phy->routing_attr) {\n\tcase TABLE_ROUTING:\n\t\tif (dev->ex_dev.t2t_supp)\n\t\t\treturn 'U';\n\t\telse\n\t\t\treturn 'T';\n\tcase DIRECT_ROUTING:\n\t\treturn 'D';\n\tcase SUBTRACTIVE_ROUTING:\n\t\treturn 'S';\n\tdefault:\n\t\treturn '?';\n\t}\n}\n\nstatic enum sas_device_type to_dev_type(struct discover_resp *dr)\n{\n\t/* This is detecting a failure to transmit initial dev to host\n\t * FIS as described in section J.5 of sas-2 r16\n\t */\n\tif (dr->attached_dev_type == SAS_PHY_UNUSED && dr->attached_sata_dev &&\n\t    dr->linkrate >= SAS_LINK_RATE_1_5_GBPS)\n\t\treturn SAS_SATA_PENDING;\n\telse\n\t\treturn dr->attached_dev_type;\n}\n\nstatic void sas_set_ex_phy(struct domain_device *dev, int phy_id, void *rsp)\n{\n\tenum sas_device_type dev_type;\n\tenum sas_linkrate linkrate;\n\tu8 sas_addr[SAS_ADDR_SIZE];\n\tstruct smp_resp *resp = rsp;\n\tstruct discover_resp *dr = &resp->disc;\n\tstruct sas_ha_struct *ha = dev->port->ha;\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *phy = &ex->ex_phy[phy_id];\n\tstruct sas_rphy *rphy = dev->rphy;\n\tbool new_phy = !phy->phy;\n\tchar *type;\n\n\tif (new_phy) {\n\t\tif (WARN_ON_ONCE(test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state)))\n\t\t\treturn;\n\t\tphy->phy = sas_phy_alloc(&rphy->dev, phy_id);\n\n\t\t/* FIXME: error_handling */\n\t\tBUG_ON(!phy->phy);\n\t}\n\n\tswitch (resp->result) {\n\tcase SMP_RESP_PHY_VACANT:\n\t\tphy->phy_state = PHY_VACANT;\n\t\tbreak;\n\tdefault:\n\t\tphy->phy_state = PHY_NOT_PRESENT;\n\t\tbreak;\n\tcase SMP_RESP_FUNC_ACC:\n\t\tphy->phy_state = PHY_EMPTY; /* do not know yet */\n\t\tbreak;\n\t}\n\n\t/* check if anything important changed to squelch debug */\n\tdev_type = phy->attached_dev_type;\n\tlinkrate  = phy->linkrate;\n\tmemcpy(sas_addr, phy->attached_sas_addr, SAS_ADDR_SIZE);\n\n\t/* Handle vacant phy - rest of dr data is not valid so skip it */\n\tif (phy->phy_state == PHY_VACANT) {\n\t\tmemset(phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\t\tphy->attached_dev_type = SAS_PHY_UNUSED;\n\t\tif (!test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state)) {\n\t\t\tphy->phy_id = phy_id;\n\t\t\tgoto skip;\n\t\t} else\n\t\t\tgoto out;\n\t}\n\n\tphy->attached_dev_type = to_dev_type(dr);\n\tif (test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state))\n\t\tgoto out;\n\tphy->phy_id = phy_id;\n\tphy->linkrate = dr->linkrate;\n\tphy->attached_sata_host = dr->attached_sata_host;\n\tphy->attached_sata_dev  = dr->attached_sata_dev;\n\tphy->attached_sata_ps   = dr->attached_sata_ps;\n\tphy->attached_iproto = dr->iproto << 1;\n\tphy->attached_tproto = dr->tproto << 1;\n\t/* help some expanders that fail to zero sas_address in the 'no\n\t * device' case\n\t */\n\tif (phy->attached_dev_type == SAS_PHY_UNUSED ||\n\t    phy->linkrate < SAS_LINK_RATE_1_5_GBPS)\n\t\tmemset(phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\telse\n\t\tmemcpy(phy->attached_sas_addr, dr->attached_sas_addr, SAS_ADDR_SIZE);\n\tphy->attached_phy_id = dr->attached_phy_id;\n\tphy->phy_change_count = dr->change_count;\n\tphy->routing_attr = dr->routing_attr;\n\tphy->virtual = dr->virtual;\n\tphy->last_da_index = -1;\n\n\tphy->phy->identify.sas_address = SAS_ADDR(phy->attached_sas_addr);\n\tphy->phy->identify.device_type = dr->attached_dev_type;\n\tphy->phy->identify.initiator_port_protocols = phy->attached_iproto;\n\tphy->phy->identify.target_port_protocols = phy->attached_tproto;\n\tif (!phy->attached_tproto && dr->attached_sata_dev)\n\t\tphy->phy->identify.target_port_protocols = SAS_PROTOCOL_SATA;\n\tphy->phy->identify.phy_identifier = phy_id;\n\tphy->phy->minimum_linkrate_hw = dr->hmin_linkrate;\n\tphy->phy->maximum_linkrate_hw = dr->hmax_linkrate;\n\tphy->phy->minimum_linkrate = dr->pmin_linkrate;\n\tphy->phy->maximum_linkrate = dr->pmax_linkrate;\n\tphy->phy->negotiated_linkrate = phy->linkrate;\n\tphy->phy->enabled = (phy->linkrate != SAS_PHY_DISABLED);\n\n skip:\n\tif (new_phy)\n\t\tif (sas_phy_add(phy->phy)) {\n\t\t\tsas_phy_free(phy->phy);\n\t\t\treturn;\n\t\t}\n\n out:\n\tswitch (phy->attached_dev_type) {\n\tcase SAS_SATA_PENDING:\n\t\ttype = \"stp pending\";\n\t\tbreak;\n\tcase SAS_PHY_UNUSED:\n\t\ttype = \"no device\";\n\t\tbreak;\n\tcase SAS_END_DEVICE:\n\t\tif (phy->attached_iproto) {\n\t\t\tif (phy->attached_tproto)\n\t\t\t\ttype = \"host+target\";\n\t\t\telse\n\t\t\t\ttype = \"host\";\n\t\t} else {\n\t\t\tif (dr->attached_sata_dev)\n\t\t\t\ttype = \"stp\";\n\t\t\telse\n\t\t\t\ttype = \"ssp\";\n\t\t}\n\t\tbreak;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\ttype = \"smp\";\n\t\tbreak;\n\tdefault:\n\t\ttype = \"unknown\";\n\t}\n\n\t/* this routine is polled by libata error recovery so filter\n\t * unimportant messages\n\t */\n\tif (new_phy || phy->attached_dev_type != dev_type ||\n\t    phy->linkrate != linkrate ||\n\t    SAS_ADDR(phy->attached_sas_addr) != SAS_ADDR(sas_addr))\n\t\t/* pass */;\n\telse\n\t\treturn;\n\n\t/* if the attached device type changed and ata_eh is active,\n\t * make sure we run revalidation when eh completes (see:\n\t * sas_enable_revalidation)\n\t */\n\tif (test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state))\n\t\tset_bit(DISCE_REVALIDATE_DOMAIN, &dev->port->disc.pending);\n\n\tSAS_DPRINTK(\"%sex %016llx phy%02d:%c:%X attached: %016llx (%s)\\n\",\n\t\t    test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state) ? \"ata: \" : \"\",\n\t\t    SAS_ADDR(dev->sas_addr), phy->phy_id,\n\t\t    sas_route_char(dev, phy), phy->linkrate,\n\t\t    SAS_ADDR(phy->attached_sas_addr), type);\n}\n\n/* check if we have an existing attached ata device on this expander phy */\nstruct domain_device *sas_ex_to_ata(struct domain_device *ex_dev, int phy_id)\n{\n\tstruct ex_phy *ex_phy = &ex_dev->ex_dev.ex_phy[phy_id];\n\tstruct domain_device *dev;\n\tstruct sas_rphy *rphy;\n\n\tif (!ex_phy->port)\n\t\treturn NULL;\n\n\trphy = ex_phy->port->rphy;\n\tif (!rphy)\n\t\treturn NULL;\n\n\tdev = sas_find_dev_by_rphy(rphy);\n\n\tif (dev && dev_is_sata(dev))\n\t\treturn dev;\n\n\treturn NULL;\n}\n\n#define DISCOVER_REQ_SIZE  16\n#define DISCOVER_RESP_SIZE 56\n\nstatic int sas_ex_phy_discover_helper(struct domain_device *dev, u8 *disc_req,\n\t\t\t\t      u8 *disc_resp, int single)\n{\n\tstruct discover_resp *dr;\n\tint res;\n\n\tdisc_req[9] = single;\n\n\tres = smp_execute_task(dev, disc_req, DISCOVER_REQ_SIZE,\n\t\t\t       disc_resp, DISCOVER_RESP_SIZE);\n\tif (res)\n\t\treturn res;\n\tdr = &((struct smp_resp *)disc_resp)->disc;\n\tif (memcmp(dev->sas_addr, dr->attached_sas_addr, SAS_ADDR_SIZE) == 0) {\n\t\tsas_printk(\"Found loopback topology, just ignore it!\\n\");\n\t\treturn 0;\n\t}\n\tsas_set_ex_phy(dev, single, disc_resp);\n\treturn 0;\n}\n\nint sas_ex_phy_discover(struct domain_device *dev, int single)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint  res = 0;\n\tu8   *disc_req;\n\tu8   *disc_resp;\n\n\tdisc_req = alloc_smp_req(DISCOVER_REQ_SIZE);\n\tif (!disc_req)\n\t\treturn -ENOMEM;\n\n\tdisc_resp = alloc_smp_resp(DISCOVER_RESP_SIZE);\n\tif (!disc_resp) {\n\t\tkfree(disc_req);\n\t\treturn -ENOMEM;\n\t}\n\n\tdisc_req[1] = SMP_DISCOVER;\n\n\tif (0 <= single && single < ex->num_phys) {\n\t\tres = sas_ex_phy_discover_helper(dev, disc_req, disc_resp, single);\n\t} else {\n\t\tint i;\n\n\t\tfor (i = 0; i < ex->num_phys; i++) {\n\t\t\tres = sas_ex_phy_discover_helper(dev, disc_req,\n\t\t\t\t\t\t\t disc_resp, i);\n\t\t\tif (res)\n\t\t\t\tgoto out_err;\n\t\t}\n\t}\nout_err:\n\tkfree(disc_resp);\n\tkfree(disc_req);\n\treturn res;\n}\n\nstatic int sas_expander_discover(struct domain_device *dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint res = -ENOMEM;\n\n\tex->ex_phy = kzalloc(sizeof(*ex->ex_phy)*ex->num_phys, GFP_KERNEL);\n\tif (!ex->ex_phy)\n\t\treturn -ENOMEM;\n\n\tres = sas_ex_phy_discover(dev, -1);\n\tif (res)\n\t\tgoto out_err;\n\n\treturn 0;\n out_err:\n\tkfree(ex->ex_phy);\n\tex->ex_phy = NULL;\n\treturn res;\n}\n\n#define MAX_EXPANDER_PHYS 128\n\nstatic void ex_assign_report_general(struct domain_device *dev,\n\t\t\t\t\t    struct smp_resp *resp)\n{\n\tstruct report_general_resp *rg = &resp->rg;\n\n\tdev->ex_dev.ex_change_count = be16_to_cpu(rg->change_count);\n\tdev->ex_dev.max_route_indexes = be16_to_cpu(rg->route_indexes);\n\tdev->ex_dev.num_phys = min(rg->num_phys, (u8)MAX_EXPANDER_PHYS);\n\tdev->ex_dev.t2t_supp = rg->t2t_supp;\n\tdev->ex_dev.conf_route_table = rg->conf_route_table;\n\tdev->ex_dev.configuring = rg->configuring;\n\tmemcpy(dev->ex_dev.enclosure_logical_id, rg->enclosure_logical_id, 8);\n}\n\n#define RG_REQ_SIZE   8\n#define RG_RESP_SIZE 32\n\nstatic int sas_ex_general(struct domain_device *dev)\n{\n\tu8 *rg_req;\n\tstruct smp_resp *rg_resp;\n\tint res;\n\tint i;\n\n\trg_req = alloc_smp_req(RG_REQ_SIZE);\n\tif (!rg_req)\n\t\treturn -ENOMEM;\n\n\trg_resp = alloc_smp_resp(RG_RESP_SIZE);\n\tif (!rg_resp) {\n\t\tkfree(rg_req);\n\t\treturn -ENOMEM;\n\t}\n\n\trg_req[1] = SMP_REPORT_GENERAL;\n\n\tfor (i = 0; i < 5; i++) {\n\t\tres = smp_execute_task(dev, rg_req, RG_REQ_SIZE, rg_resp,\n\t\t\t\t       RG_RESP_SIZE);\n\n\t\tif (res) {\n\t\t\tSAS_DPRINTK(\"RG to ex %016llx failed:0x%x\\n\",\n\t\t\t\t    SAS_ADDR(dev->sas_addr), res);\n\t\t\tgoto out;\n\t\t} else if (rg_resp->result != SMP_RESP_FUNC_ACC) {\n\t\t\tSAS_DPRINTK(\"RG:ex %016llx returned SMP result:0x%x\\n\",\n\t\t\t\t    SAS_ADDR(dev->sas_addr), rg_resp->result);\n\t\t\tres = rg_resp->result;\n\t\t\tgoto out;\n\t\t}\n\n\t\tex_assign_report_general(dev, rg_resp);\n\n\t\tif (dev->ex_dev.configuring) {\n\t\t\tSAS_DPRINTK(\"RG: ex %llx self-configuring...\\n\",\n\t\t\t\t    SAS_ADDR(dev->sas_addr));\n\t\t\tschedule_timeout_interruptible(5*HZ);\n\t\t} else\n\t\t\tbreak;\n\t}\nout:\n\tkfree(rg_req);\n\tkfree(rg_resp);\n\treturn res;\n}\n\nstatic void ex_assign_manuf_info(struct domain_device *dev, void\n\t\t\t\t\t*_mi_resp)\n{\n\tu8 *mi_resp = _mi_resp;\n\tstruct sas_rphy *rphy = dev->rphy;\n\tstruct sas_expander_device *edev = rphy_to_expander_device(rphy);\n\n\tmemcpy(edev->vendor_id, mi_resp + 12, SAS_EXPANDER_VENDOR_ID_LEN);\n\tmemcpy(edev->product_id, mi_resp + 20, SAS_EXPANDER_PRODUCT_ID_LEN);\n\tmemcpy(edev->product_rev, mi_resp + 36,\n\t       SAS_EXPANDER_PRODUCT_REV_LEN);\n\n\tif (mi_resp[8] & 1) {\n\t\tmemcpy(edev->component_vendor_id, mi_resp + 40,\n\t\t       SAS_EXPANDER_COMPONENT_VENDOR_ID_LEN);\n\t\tedev->component_id = mi_resp[48] << 8 | mi_resp[49];\n\t\tedev->component_revision_id = mi_resp[50];\n\t}\n}\n\n#define MI_REQ_SIZE   8\n#define MI_RESP_SIZE 64\n\nstatic int sas_ex_manuf_info(struct domain_device *dev)\n{\n\tu8 *mi_req;\n\tu8 *mi_resp;\n\tint res;\n\n\tmi_req = alloc_smp_req(MI_REQ_SIZE);\n\tif (!mi_req)\n\t\treturn -ENOMEM;\n\n\tmi_resp = alloc_smp_resp(MI_RESP_SIZE);\n\tif (!mi_resp) {\n\t\tkfree(mi_req);\n\t\treturn -ENOMEM;\n\t}\n\n\tmi_req[1] = SMP_REPORT_MANUF_INFO;\n\n\tres = smp_execute_task(dev, mi_req, MI_REQ_SIZE, mi_resp,MI_RESP_SIZE);\n\tif (res) {\n\t\tSAS_DPRINTK(\"MI: ex %016llx failed:0x%x\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), res);\n\t\tgoto out;\n\t} else if (mi_resp[2] != SMP_RESP_FUNC_ACC) {\n\t\tSAS_DPRINTK(\"MI ex %016llx returned SMP result:0x%x\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), mi_resp[2]);\n\t\tgoto out;\n\t}\n\n\tex_assign_manuf_info(dev, mi_resp);\nout:\n\tkfree(mi_req);\n\tkfree(mi_resp);\n\treturn res;\n}\n\n#define PC_REQ_SIZE  44\n#define PC_RESP_SIZE 8\n\nint sas_smp_phy_control(struct domain_device *dev, int phy_id,\n\t\t\tenum phy_func phy_func,\n\t\t\tstruct sas_phy_linkrates *rates)\n{\n\tu8 *pc_req;\n\tu8 *pc_resp;\n\tint res;\n\n\tpc_req = alloc_smp_req(PC_REQ_SIZE);\n\tif (!pc_req)\n\t\treturn -ENOMEM;\n\n\tpc_resp = alloc_smp_resp(PC_RESP_SIZE);\n\tif (!pc_resp) {\n\t\tkfree(pc_req);\n\t\treturn -ENOMEM;\n\t}\n\n\tpc_req[1] = SMP_PHY_CONTROL;\n\tpc_req[9] = phy_id;\n\tpc_req[10]= phy_func;\n\tif (rates) {\n\t\tpc_req[32] = rates->minimum_linkrate << 4;\n\t\tpc_req[33] = rates->maximum_linkrate << 4;\n\t}\n\n\tres = smp_execute_task(dev, pc_req, PC_REQ_SIZE, pc_resp,PC_RESP_SIZE);\n\n\tkfree(pc_resp);\n\tkfree(pc_req);\n\treturn res;\n}\n\nstatic void sas_ex_disable_phy(struct domain_device *dev, int phy_id)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *phy = &ex->ex_phy[phy_id];\n\n\tsas_smp_phy_control(dev, phy_id, PHY_FUNC_DISABLE, NULL);\n\tphy->linkrate = SAS_PHY_DISABLED;\n}\n\nstatic void sas_ex_disable_port(struct domain_device *dev, u8 *sas_addr)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint i;\n\n\tfor (i = 0; i < ex->num_phys; i++) {\n\t\tstruct ex_phy *phy = &ex->ex_phy[i];\n\n\t\tif (phy->phy_state == PHY_VACANT ||\n\t\t    phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif (SAS_ADDR(phy->attached_sas_addr) == SAS_ADDR(sas_addr))\n\t\t\tsas_ex_disable_phy(dev, i);\n\t}\n}\n\nstatic int sas_dev_present_in_domain(struct asd_sas_port *port,\n\t\t\t\t\t    u8 *sas_addr)\n{\n\tstruct domain_device *dev;\n\n\tif (SAS_ADDR(port->sas_addr) == SAS_ADDR(sas_addr))\n\t\treturn 1;\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\tif (SAS_ADDR(dev->sas_addr) == SAS_ADDR(sas_addr))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n#define RPEL_REQ_SIZE\t16\n#define RPEL_RESP_SIZE\t32\nint sas_smp_get_phy_events(struct sas_phy *phy)\n{\n\tint res;\n\tu8 *req;\n\tu8 *resp;\n\tstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\n\tstruct domain_device *dev = sas_find_dev_by_rphy(rphy);\n\n\treq = alloc_smp_req(RPEL_REQ_SIZE);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tresp = alloc_smp_resp(RPEL_RESP_SIZE);\n\tif (!resp) {\n\t\tkfree(req);\n\t\treturn -ENOMEM;\n\t}\n\n\treq[1] = SMP_REPORT_PHY_ERR_LOG;\n\treq[9] = phy->number;\n\n\tres = smp_execute_task(dev, req, RPEL_REQ_SIZE,\n\t\t\t            resp, RPEL_RESP_SIZE);\n\n\tif (res)\n\t\tgoto out;\n\n\tphy->invalid_dword_count = scsi_to_u32(&resp[12]);\n\tphy->running_disparity_error_count = scsi_to_u32(&resp[16]);\n\tphy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);\n\tphy->phy_reset_problem_count = scsi_to_u32(&resp[24]);\n\n out:\n\tkfree(req);\n\tkfree(resp);\n\treturn res;\n\n}\n\n#ifdef CONFIG_SCSI_SAS_ATA\n\n#define RPS_REQ_SIZE  16\n#define RPS_RESP_SIZE 60\n\nint sas_get_report_phy_sata(struct domain_device *dev, int phy_id,\n\t\t\t    struct smp_resp *rps_resp)\n{\n\tint res;\n\tu8 *rps_req = alloc_smp_req(RPS_REQ_SIZE);\n\tu8 *resp = (u8 *)rps_resp;\n\n\tif (!rps_req)\n\t\treturn -ENOMEM;\n\n\trps_req[1] = SMP_REPORT_PHY_SATA;\n\trps_req[9] = phy_id;\n\n\tres = smp_execute_task(dev, rps_req, RPS_REQ_SIZE,\n\t\t\t            rps_resp, RPS_RESP_SIZE);\n\n\t/* 0x34 is the FIS type for the D2H fis.  There's a potential\n\t * standards cockup here.  sas-2 explicitly specifies the FIS\n\t * should be encoded so that FIS type is in resp[24].\n\t * However, some expanders endian reverse this.  Undo the\n\t * reversal here */\n\tif (!res && resp[27] == 0x34 && resp[24] != 0x34) {\n\t\tint i;\n\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tint j = 24 + (i*4);\n\t\t\tu8 a, b;\n\t\t\ta = resp[j + 0];\n\t\t\tb = resp[j + 1];\n\t\t\tresp[j + 0] = resp[j + 3];\n\t\t\tresp[j + 1] = resp[j + 2];\n\t\t\tresp[j + 2] = b;\n\t\t\tresp[j + 3] = a;\n\t\t}\n\t}\n\n\tkfree(rps_req);\n\treturn res;\n}\n#endif\n\nstatic void sas_ex_get_linkrate(struct domain_device *parent,\n\t\t\t\t       struct domain_device *child,\n\t\t\t\t       struct ex_phy *parent_phy)\n{\n\tstruct expander_device *parent_ex = &parent->ex_dev;\n\tstruct sas_port *port;\n\tint i;\n\n\tchild->pathways = 0;\n\n\tport = parent_phy->port;\n\n\tfor (i = 0; i < parent_ex->num_phys; i++) {\n\t\tstruct ex_phy *phy = &parent_ex->ex_phy[i];\n\n\t\tif (phy->phy_state == PHY_VACANT ||\n\t\t    phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif (SAS_ADDR(phy->attached_sas_addr) ==\n\t\t    SAS_ADDR(child->sas_addr)) {\n\n\t\t\tchild->min_linkrate = min(parent->min_linkrate,\n\t\t\t\t\t\t  phy->linkrate);\n\t\t\tchild->max_linkrate = max(parent->max_linkrate,\n\t\t\t\t\t\t  phy->linkrate);\n\t\t\tchild->pathways++;\n\t\t\tsas_port_add_phy(port, phy->phy);\n\t\t}\n\t}\n\tchild->linkrate = min(parent_phy->linkrate, child->max_linkrate);\n\tchild->pathways = min(child->pathways, parent->pathways);\n}\n\nstatic struct domain_device *sas_ex_discover_end_dev(\n\tstruct domain_device *parent, int phy_id)\n{\n\tstruct expander_device *parent_ex = &parent->ex_dev;\n\tstruct ex_phy *phy = &parent_ex->ex_phy[phy_id];\n\tstruct domain_device *child = NULL;\n\tstruct sas_rphy *rphy;\n\tint res;\n\n\tif (phy->attached_sata_host || phy->attached_sata_ps)\n\t\treturn NULL;\n\n\tchild = sas_alloc_device();\n\tif (!child)\n\t\treturn NULL;\n\n\tkref_get(&parent->kref);\n\tchild->parent = parent;\n\tchild->port   = parent->port;\n\tchild->iproto = phy->attached_iproto;\n\tmemcpy(child->sas_addr, phy->attached_sas_addr, SAS_ADDR_SIZE);\n\tsas_hash_addr(child->hashed_sas_addr, child->sas_addr);\n\tif (!phy->port) {\n\t\tphy->port = sas_port_alloc(&parent->rphy->dev, phy_id);\n\t\tif (unlikely(!phy->port))\n\t\t\tgoto out_err;\n\t\tif (unlikely(sas_port_add(phy->port) != 0)) {\n\t\t\tsas_port_free(phy->port);\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\tsas_ex_get_linkrate(parent, child, phy);\n\tsas_device_set_phy(child, phy->port);\n\n#ifdef CONFIG_SCSI_SAS_ATA\n\tif ((phy->attached_tproto & SAS_PROTOCOL_STP) || phy->attached_sata_dev) {\n\t\tres = sas_get_ata_info(child, phy);\n\t\tif (res)\n\t\t\tgoto out_free;\n\n\t\tsas_init_dev(child);\n\t\tres = sas_ata_init(child);\n\t\tif (res)\n\t\t\tgoto out_free;\n\t\trphy = sas_end_device_alloc(phy->port);\n\t\tif (!rphy)\n\t\t\tgoto out_free;\n\n\t\tchild->rphy = rphy;\n\t\tget_device(&rphy->dev);\n\n\t\tlist_add_tail(&child->disco_list_node, &parent->port->disco_list);\n\n\t\tres = sas_discover_sata(child);\n\t\tif (res) {\n\t\t\tSAS_DPRINTK(\"sas_discover_sata() for device %16llx at \"\n\t\t\t\t    \"%016llx:0x%x returned 0x%x\\n\",\n\t\t\t\t    SAS_ADDR(child->sas_addr),\n\t\t\t\t    SAS_ADDR(parent->sas_addr), phy_id, res);\n\t\t\tgoto out_list_del;\n\t\t}\n\t} else\n#endif\n\t  if (phy->attached_tproto & SAS_PROTOCOL_SSP) {\n\t\tchild->dev_type = SAS_END_DEVICE;\n\t\trphy = sas_end_device_alloc(phy->port);\n\t\t/* FIXME: error handling */\n\t\tif (unlikely(!rphy))\n\t\t\tgoto out_free;\n\t\tchild->tproto = phy->attached_tproto;\n\t\tsas_init_dev(child);\n\n\t\tchild->rphy = rphy;\n\t\tget_device(&rphy->dev);\n\t\tsas_fill_in_rphy(child, rphy);\n\n\t\tlist_add_tail(&child->disco_list_node, &parent->port->disco_list);\n\n\t\tres = sas_discover_end_dev(child);\n\t\tif (res) {\n\t\t\tSAS_DPRINTK(\"sas_discover_end_dev() for device %16llx \"\n\t\t\t\t    \"at %016llx:0x%x returned 0x%x\\n\",\n\t\t\t\t    SAS_ADDR(child->sas_addr),\n\t\t\t\t    SAS_ADDR(parent->sas_addr), phy_id, res);\n\t\t\tgoto out_list_del;\n\t\t}\n\t} else {\n\t\tSAS_DPRINTK(\"target proto 0x%x at %016llx:0x%x not handled\\n\",\n\t\t\t    phy->attached_tproto, SAS_ADDR(parent->sas_addr),\n\t\t\t    phy_id);\n\t\tgoto out_free;\n\t}\n\n\tlist_add_tail(&child->siblings, &parent_ex->children);\n\treturn child;\n\n out_list_del:\n\tsas_rphy_free(child->rphy);\n\tlist_del(&child->disco_list_node);\n\tspin_lock_irq(&parent->port->dev_list_lock);\n\tlist_del(&child->dev_list_node);\n\tspin_unlock_irq(&parent->port->dev_list_lock);\n out_free:\n\tsas_port_delete(phy->port);\n out_err:\n\tphy->port = NULL;\n\tsas_put_device(child);\n\treturn NULL;\n}\n\n/* See if this phy is part of a wide port */\nstatic bool sas_ex_join_wide_port(struct domain_device *parent, int phy_id)\n{\n\tstruct ex_phy *phy = &parent->ex_dev.ex_phy[phy_id];\n\tint i;\n\n\tfor (i = 0; i < parent->ex_dev.num_phys; i++) {\n\t\tstruct ex_phy *ephy = &parent->ex_dev.ex_phy[i];\n\n\t\tif (ephy == phy)\n\t\t\tcontinue;\n\n\t\tif (!memcmp(phy->attached_sas_addr, ephy->attached_sas_addr,\n\t\t\t    SAS_ADDR_SIZE) && ephy->port) {\n\t\t\tsas_port_add_phy(ephy->port, phy->phy);\n\t\t\tphy->port = ephy->port;\n\t\t\tphy->phy_state = PHY_DEVICE_DISCOVERED;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic struct domain_device *sas_ex_discover_expander(\n\tstruct domain_device *parent, int phy_id)\n{\n\tstruct sas_expander_device *parent_ex = rphy_to_expander_device(parent->rphy);\n\tstruct ex_phy *phy = &parent->ex_dev.ex_phy[phy_id];\n\tstruct domain_device *child = NULL;\n\tstruct sas_rphy *rphy;\n\tstruct sas_expander_device *edev;\n\tstruct asd_sas_port *port;\n\tint res;\n\n\tif (phy->routing_attr == DIRECT_ROUTING) {\n\t\tSAS_DPRINTK(\"ex %016llx:0x%x:D <--> ex %016llx:0x%x is not \"\n\t\t\t    \"allowed\\n\",\n\t\t\t    SAS_ADDR(parent->sas_addr), phy_id,\n\t\t\t    SAS_ADDR(phy->attached_sas_addr),\n\t\t\t    phy->attached_phy_id);\n\t\treturn NULL;\n\t}\n\tchild = sas_alloc_device();\n\tif (!child)\n\t\treturn NULL;\n\n\tphy->port = sas_port_alloc(&parent->rphy->dev, phy_id);\n\t/* FIXME: better error handling */\n\tBUG_ON(sas_port_add(phy->port) != 0);\n\n\n\tswitch (phy->attached_dev_type) {\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\trphy = sas_expander_alloc(phy->port,\n\t\t\t\t\t  SAS_EDGE_EXPANDER_DEVICE);\n\t\tbreak;\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\trphy = sas_expander_alloc(phy->port,\n\t\t\t\t\t  SAS_FANOUT_EXPANDER_DEVICE);\n\t\tbreak;\n\tdefault:\n\t\trphy = NULL;\t/* shut gcc up */\n\t\tBUG();\n\t}\n\tport = parent->port;\n\tchild->rphy = rphy;\n\tget_device(&rphy->dev);\n\tedev = rphy_to_expander_device(rphy);\n\tchild->dev_type = phy->attached_dev_type;\n\tkref_get(&parent->kref);\n\tchild->parent = parent;\n\tchild->port = port;\n\tchild->iproto = phy->attached_iproto;\n\tchild->tproto = phy->attached_tproto;\n\tmemcpy(child->sas_addr, phy->attached_sas_addr, SAS_ADDR_SIZE);\n\tsas_hash_addr(child->hashed_sas_addr, child->sas_addr);\n\tsas_ex_get_linkrate(parent, child, phy);\n\tedev->level = parent_ex->level + 1;\n\tparent->port->disc.max_level = max(parent->port->disc.max_level,\n\t\t\t\t\t   edev->level);\n\tsas_init_dev(child);\n\tsas_fill_in_rphy(child, rphy);\n\tsas_rphy_add(rphy);\n\n\tspin_lock_irq(&parent->port->dev_list_lock);\n\tlist_add_tail(&child->dev_list_node, &parent->port->dev_list);\n\tspin_unlock_irq(&parent->port->dev_list_lock);\n\n\tres = sas_discover_expander(child);\n\tif (res) {\n\t\tsas_rphy_delete(rphy);\n\t\tspin_lock_irq(&parent->port->dev_list_lock);\n\t\tlist_del(&child->dev_list_node);\n\t\tspin_unlock_irq(&parent->port->dev_list_lock);\n\t\tsas_put_device(child);\n\t\treturn NULL;\n\t}\n\tlist_add_tail(&child->siblings, &parent->ex_dev.children);\n\treturn child;\n}\n\nstatic int sas_ex_discover_dev(struct domain_device *dev, int phy_id)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *ex_phy = &ex->ex_phy[phy_id];\n\tstruct domain_device *child = NULL;\n\tint res = 0;\n\n\t/* Phy state */\n\tif (ex_phy->linkrate == SAS_SATA_SPINUP_HOLD) {\n\t\tif (!sas_smp_phy_control(dev, phy_id, PHY_FUNC_LINK_RESET, NULL))\n\t\t\tres = sas_ex_phy_discover(dev, phy_id);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\t/* Parent and domain coherency */\n\tif (!dev->parent && (SAS_ADDR(ex_phy->attached_sas_addr) ==\n\t\t\t     SAS_ADDR(dev->port->sas_addr))) {\n\t\tsas_add_parent_port(dev, phy_id);\n\t\treturn 0;\n\t}\n\tif (dev->parent && (SAS_ADDR(ex_phy->attached_sas_addr) ==\n\t\t\t    SAS_ADDR(dev->parent->sas_addr))) {\n\t\tsas_add_parent_port(dev, phy_id);\n\t\tif (ex_phy->routing_attr == TABLE_ROUTING)\n\t\t\tsas_configure_phy(dev, phy_id, dev->port->sas_addr, 1);\n\t\treturn 0;\n\t}\n\n\tif (sas_dev_present_in_domain(dev->port, ex_phy->attached_sas_addr))\n\t\tsas_ex_disable_port(dev, ex_phy->attached_sas_addr);\n\n\tif (ex_phy->attached_dev_type == SAS_PHY_UNUSED) {\n\t\tif (ex_phy->routing_attr == DIRECT_ROUTING) {\n\t\t\tmemset(ex_phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\t\t\tsas_configure_routing(dev, ex_phy->attached_sas_addr);\n\t\t}\n\t\treturn 0;\n\t} else if (ex_phy->linkrate == SAS_LINK_RATE_UNKNOWN)\n\t\treturn 0;\n\n\tif (ex_phy->attached_dev_type != SAS_END_DEVICE &&\n\t    ex_phy->attached_dev_type != SAS_FANOUT_EXPANDER_DEVICE &&\n\t    ex_phy->attached_dev_type != SAS_EDGE_EXPANDER_DEVICE &&\n\t    ex_phy->attached_dev_type != SAS_SATA_PENDING) {\n\t\tSAS_DPRINTK(\"unknown device type(0x%x) attached to ex %016llx \"\n\t\t\t    \"phy 0x%x\\n\", ex_phy->attached_dev_type,\n\t\t\t    SAS_ADDR(dev->sas_addr),\n\t\t\t    phy_id);\n\t\treturn 0;\n\t}\n\n\tres = sas_configure_routing(dev, ex_phy->attached_sas_addr);\n\tif (res) {\n\t\tSAS_DPRINTK(\"configure routing for dev %016llx \"\n\t\t\t    \"reported 0x%x. Forgotten\\n\",\n\t\t\t    SAS_ADDR(ex_phy->attached_sas_addr), res);\n\t\tsas_disable_routing(dev, ex_phy->attached_sas_addr);\n\t\treturn res;\n\t}\n\n\tif (sas_ex_join_wide_port(dev, phy_id)) {\n\t\tSAS_DPRINTK(\"Attaching ex phy%d to wide port %016llx\\n\",\n\t\t\t    phy_id, SAS_ADDR(ex_phy->attached_sas_addr));\n\t\treturn res;\n\t}\n\n\tswitch (ex_phy->attached_dev_type) {\n\tcase SAS_END_DEVICE:\n\tcase SAS_SATA_PENDING:\n\t\tchild = sas_ex_discover_end_dev(dev, phy_id);\n\t\tbreak;\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\tif (SAS_ADDR(dev->port->disc.fanout_sas_addr)) {\n\t\t\tSAS_DPRINTK(\"second fanout expander %016llx phy 0x%x \"\n\t\t\t\t    \"attached to ex %016llx phy 0x%x\\n\",\n\t\t\t\t    SAS_ADDR(ex_phy->attached_sas_addr),\n\t\t\t\t    ex_phy->attached_phy_id,\n\t\t\t\t    SAS_ADDR(dev->sas_addr),\n\t\t\t\t    phy_id);\n\t\t\tsas_ex_disable_phy(dev, phy_id);\n\t\t\tbreak;\n\t\t} else\n\t\t\tmemcpy(dev->port->disc.fanout_sas_addr,\n\t\t\t       ex_phy->attached_sas_addr, SAS_ADDR_SIZE);\n\t\t/* fallthrough */\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\tchild = sas_ex_discover_expander(dev, phy_id);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (child) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ex->num_phys; i++) {\n\t\t\tif (ex->ex_phy[i].phy_state == PHY_VACANT ||\n\t\t\t    ex->ex_phy[i].phy_state == PHY_NOT_PRESENT)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Due to races, the phy might not get added to the\n\t\t\t * wide port, so we add the phy to the wide port here.\n\t\t\t */\n\t\t\tif (SAS_ADDR(ex->ex_phy[i].attached_sas_addr) ==\n\t\t\t    SAS_ADDR(child->sas_addr)) {\n\t\t\t\tex->ex_phy[i].phy_state= PHY_DEVICE_DISCOVERED;\n\t\t\t\tif (sas_ex_join_wide_port(dev, i))\n\t\t\t\t\tSAS_DPRINTK(\"Attaching ex phy%d to wide port %016llx\\n\",\n\t\t\t\t\t\t    i, SAS_ADDR(ex->ex_phy[i].attached_sas_addr));\n\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic int sas_find_sub_addr(struct domain_device *dev, u8 *sub_addr)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint i;\n\n\tfor (i = 0; i < ex->num_phys; i++) {\n\t\tstruct ex_phy *phy = &ex->ex_phy[i];\n\n\t\tif (phy->phy_state == PHY_VACANT ||\n\t\t    phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif ((phy->attached_dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t     phy->attached_dev_type == SAS_FANOUT_EXPANDER_DEVICE) &&\n\t\t    phy->routing_attr == SUBTRACTIVE_ROUTING) {\n\n\t\t\tmemcpy(sub_addr, phy->attached_sas_addr,SAS_ADDR_SIZE);\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int sas_check_level_subtractive_boundary(struct domain_device *dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct domain_device *child;\n\tu8 sub_addr[8] = {0, };\n\n\tlist_for_each_entry(child, &ex->children, siblings) {\n\t\tif (child->dev_type != SAS_EDGE_EXPANDER_DEVICE &&\n\t\t    child->dev_type != SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\tcontinue;\n\t\tif (sub_addr[0] == 0) {\n\t\t\tsas_find_sub_addr(child, sub_addr);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tu8 s2[8];\n\n\t\t\tif (sas_find_sub_addr(child, s2) &&\n\t\t\t    (SAS_ADDR(sub_addr) != SAS_ADDR(s2))) {\n\n\t\t\t\tSAS_DPRINTK(\"ex %016llx->%016llx-?->%016llx \"\n\t\t\t\t\t    \"diverges from subtractive \"\n\t\t\t\t\t    \"boundary %016llx\\n\",\n\t\t\t\t\t    SAS_ADDR(dev->sas_addr),\n\t\t\t\t\t    SAS_ADDR(child->sas_addr),\n\t\t\t\t\t    SAS_ADDR(s2),\n\t\t\t\t\t    SAS_ADDR(sub_addr));\n\n\t\t\t\tsas_ex_disable_port(child, s2);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n/**\n * sas_ex_discover_devices -- discover devices attached to this expander\n * dev: pointer to the expander domain device\n * single: if you want to do a single phy, else set to -1;\n *\n * Configure this expander for use with its devices and register the\n * devices of this expander.\n */\nstatic int sas_ex_discover_devices(struct domain_device *dev, int single)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint i = 0, end = ex->num_phys;\n\tint res = 0;\n\n\tif (0 <= single && single < end) {\n\t\ti = single;\n\t\tend = i+1;\n\t}\n\n\tfor ( ; i < end; i++) {\n\t\tstruct ex_phy *ex_phy = &ex->ex_phy[i];\n\n\t\tif (ex_phy->phy_state == PHY_VACANT ||\n\t\t    ex_phy->phy_state == PHY_NOT_PRESENT ||\n\t\t    ex_phy->phy_state == PHY_DEVICE_DISCOVERED)\n\t\t\tcontinue;\n\n\t\tswitch (ex_phy->linkrate) {\n\t\tcase SAS_PHY_DISABLED:\n\t\tcase SAS_PHY_RESET_PROBLEM:\n\t\tcase SAS_SATA_PORT_SELECTOR:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tres = sas_ex_discover_dev(dev, i);\n\t\t\tif (res)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tif (!res)\n\t\tsas_check_level_subtractive_boundary(dev);\n\n\treturn res;\n}\n\nstatic int sas_check_ex_subtractive_boundary(struct domain_device *dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint i;\n\tu8  *sub_sas_addr = NULL;\n\n\tif (dev->dev_type != SAS_EDGE_EXPANDER_DEVICE)\n\t\treturn 0;\n\n\tfor (i = 0; i < ex->num_phys; i++) {\n\t\tstruct ex_phy *phy = &ex->ex_phy[i];\n\n\t\tif (phy->phy_state == PHY_VACANT ||\n\t\t    phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif ((phy->attached_dev_type == SAS_FANOUT_EXPANDER_DEVICE ||\n\t\t     phy->attached_dev_type == SAS_EDGE_EXPANDER_DEVICE) &&\n\t\t    phy->routing_attr == SUBTRACTIVE_ROUTING) {\n\n\t\t\tif (!sub_sas_addr)\n\t\t\t\tsub_sas_addr = &phy->attached_sas_addr[0];\n\t\t\telse if (SAS_ADDR(sub_sas_addr) !=\n\t\t\t\t SAS_ADDR(phy->attached_sas_addr)) {\n\n\t\t\t\tSAS_DPRINTK(\"ex %016llx phy 0x%x \"\n\t\t\t\t\t    \"diverges(%016llx) on subtractive \"\n\t\t\t\t\t    \"boundary(%016llx). Disabled\\n\",\n\t\t\t\t\t    SAS_ADDR(dev->sas_addr), i,\n\t\t\t\t\t    SAS_ADDR(phy->attached_sas_addr),\n\t\t\t\t\t    SAS_ADDR(sub_sas_addr));\n\t\t\t\tsas_ex_disable_phy(dev, i);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void sas_print_parent_topology_bug(struct domain_device *child,\n\t\t\t\t\t\t struct ex_phy *parent_phy,\n\t\t\t\t\t\t struct ex_phy *child_phy)\n{\n\tstatic const char *ex_type[] = {\n\t\t[SAS_EDGE_EXPANDER_DEVICE] = \"edge\",\n\t\t[SAS_FANOUT_EXPANDER_DEVICE] = \"fanout\",\n\t};\n\tstruct domain_device *parent = child->parent;\n\n\tsas_printk(\"%s ex %016llx phy 0x%x <--> %s ex %016llx \"\n\t\t   \"phy 0x%x has %c:%c routing link!\\n\",\n\n\t\t   ex_type[parent->dev_type],\n\t\t   SAS_ADDR(parent->sas_addr),\n\t\t   parent_phy->phy_id,\n\n\t\t   ex_type[child->dev_type],\n\t\t   SAS_ADDR(child->sas_addr),\n\t\t   child_phy->phy_id,\n\n\t\t   sas_route_char(parent, parent_phy),\n\t\t   sas_route_char(child, child_phy));\n}\n\nstatic int sas_check_eeds(struct domain_device *child,\n\t\t\t\t struct ex_phy *parent_phy,\n\t\t\t\t struct ex_phy *child_phy)\n{\n\tint res = 0;\n\tstruct domain_device *parent = child->parent;\n\n\tif (SAS_ADDR(parent->port->disc.fanout_sas_addr) != 0) {\n\t\tres = -ENODEV;\n\t\tSAS_DPRINTK(\"edge ex %016llx phy S:0x%x <--> edge ex %016llx \"\n\t\t\t    \"phy S:0x%x, while there is a fanout ex %016llx\\n\",\n\t\t\t    SAS_ADDR(parent->sas_addr),\n\t\t\t    parent_phy->phy_id,\n\t\t\t    SAS_ADDR(child->sas_addr),\n\t\t\t    child_phy->phy_id,\n\t\t\t    SAS_ADDR(parent->port->disc.fanout_sas_addr));\n\t} else if (SAS_ADDR(parent->port->disc.eeds_a) == 0) {\n\t\tmemcpy(parent->port->disc.eeds_a, parent->sas_addr,\n\t\t       SAS_ADDR_SIZE);\n\t\tmemcpy(parent->port->disc.eeds_b, child->sas_addr,\n\t\t       SAS_ADDR_SIZE);\n\t} else if (((SAS_ADDR(parent->port->disc.eeds_a) ==\n\t\t    SAS_ADDR(parent->sas_addr)) ||\n\t\t   (SAS_ADDR(parent->port->disc.eeds_a) ==\n\t\t    SAS_ADDR(child->sas_addr)))\n\t\t   &&\n\t\t   ((SAS_ADDR(parent->port->disc.eeds_b) ==\n\t\t     SAS_ADDR(parent->sas_addr)) ||\n\t\t    (SAS_ADDR(parent->port->disc.eeds_b) ==\n\t\t     SAS_ADDR(child->sas_addr))))\n\t\t;\n\telse {\n\t\tres = -ENODEV;\n\t\tSAS_DPRINTK(\"edge ex %016llx phy 0x%x <--> edge ex %016llx \"\n\t\t\t    \"phy 0x%x link forms a third EEDS!\\n\",\n\t\t\t    SAS_ADDR(parent->sas_addr),\n\t\t\t    parent_phy->phy_id,\n\t\t\t    SAS_ADDR(child->sas_addr),\n\t\t\t    child_phy->phy_id);\n\t}\n\n\treturn res;\n}\n\n/* Here we spill over 80 columns.  It is intentional.\n */\nstatic int sas_check_parent_topology(struct domain_device *child)\n{\n\tstruct expander_device *child_ex = &child->ex_dev;\n\tstruct expander_device *parent_ex;\n\tint i;\n\tint res = 0;\n\n\tif (!child->parent)\n\t\treturn 0;\n\n\tif (child->parent->dev_type != SAS_EDGE_EXPANDER_DEVICE &&\n\t    child->parent->dev_type != SAS_FANOUT_EXPANDER_DEVICE)\n\t\treturn 0;\n\n\tparent_ex = &child->parent->ex_dev;\n\n\tfor (i = 0; i < parent_ex->num_phys; i++) {\n\t\tstruct ex_phy *parent_phy = &parent_ex->ex_phy[i];\n\t\tstruct ex_phy *child_phy;\n\n\t\tif (parent_phy->phy_state == PHY_VACANT ||\n\t\t    parent_phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif (SAS_ADDR(parent_phy->attached_sas_addr) != SAS_ADDR(child->sas_addr))\n\t\t\tcontinue;\n\n\t\tchild_phy = &child_ex->ex_phy[parent_phy->attached_phy_id];\n\n\t\tswitch (child->parent->dev_type) {\n\t\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\t\tif (child->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\t\t\tif (parent_phy->routing_attr != SUBTRACTIVE_ROUTING ||\n\t\t\t\t    child_phy->routing_attr != TABLE_ROUTING) {\n\t\t\t\t\tsas_print_parent_topology_bug(child, parent_phy, child_phy);\n\t\t\t\t\tres = -ENODEV;\n\t\t\t\t}\n\t\t\t} else if (parent_phy->routing_attr == SUBTRACTIVE_ROUTING) {\n\t\t\t\tif (child_phy->routing_attr == SUBTRACTIVE_ROUTING) {\n\t\t\t\t\tres = sas_check_eeds(child, parent_phy, child_phy);\n\t\t\t\t} else if (child_phy->routing_attr != TABLE_ROUTING) {\n\t\t\t\t\tsas_print_parent_topology_bug(child, parent_phy, child_phy);\n\t\t\t\t\tres = -ENODEV;\n\t\t\t\t}\n\t\t\t} else if (parent_phy->routing_attr == TABLE_ROUTING) {\n\t\t\t\tif (child_phy->routing_attr == SUBTRACTIVE_ROUTING ||\n\t\t\t\t    (child_phy->routing_attr == TABLE_ROUTING &&\n\t\t\t\t     child_ex->t2t_supp && parent_ex->t2t_supp)) {\n\t\t\t\t\t/* All good */;\n\t\t\t\t} else {\n\t\t\t\t\tsas_print_parent_topology_bug(child, parent_phy, child_phy);\n\t\t\t\t\tres = -ENODEV;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\t\tif (parent_phy->routing_attr != TABLE_ROUTING ||\n\t\t\t    child_phy->routing_attr != SUBTRACTIVE_ROUTING) {\n\t\t\t\tsas_print_parent_topology_bug(child, parent_phy, child_phy);\n\t\t\t\tres = -ENODEV;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n#define RRI_REQ_SIZE  16\n#define RRI_RESP_SIZE 44\n\nstatic int sas_configure_present(struct domain_device *dev, int phy_id,\n\t\t\t\t u8 *sas_addr, int *index, int *present)\n{\n\tint i, res = 0;\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *phy = &ex->ex_phy[phy_id];\n\tu8 *rri_req;\n\tu8 *rri_resp;\n\n\t*present = 0;\n\t*index = 0;\n\n\trri_req = alloc_smp_req(RRI_REQ_SIZE);\n\tif (!rri_req)\n\t\treturn -ENOMEM;\n\n\trri_resp = alloc_smp_resp(RRI_RESP_SIZE);\n\tif (!rri_resp) {\n\t\tkfree(rri_req);\n\t\treturn -ENOMEM;\n\t}\n\n\trri_req[1] = SMP_REPORT_ROUTE_INFO;\n\trri_req[9] = phy_id;\n\n\tfor (i = 0; i < ex->max_route_indexes ; i++) {\n\t\t*(__be16 *)(rri_req+6) = cpu_to_be16(i);\n\t\tres = smp_execute_task(dev, rri_req, RRI_REQ_SIZE, rri_resp,\n\t\t\t\t       RRI_RESP_SIZE);\n\t\tif (res)\n\t\t\tgoto out;\n\t\tres = rri_resp[2];\n\t\tif (res == SMP_RESP_NO_INDEX) {\n\t\t\tSAS_DPRINTK(\"overflow of indexes: dev %016llx \"\n\t\t\t\t    \"phy 0x%x index 0x%x\\n\",\n\t\t\t\t    SAS_ADDR(dev->sas_addr), phy_id, i);\n\t\t\tgoto out;\n\t\t} else if (res != SMP_RESP_FUNC_ACC) {\n\t\t\tSAS_DPRINTK(\"%s: dev %016llx phy 0x%x index 0x%x \"\n\t\t\t\t    \"result 0x%x\\n\", __func__,\n\t\t\t\t    SAS_ADDR(dev->sas_addr), phy_id, i, res);\n\t\t\tgoto out;\n\t\t}\n\t\tif (SAS_ADDR(sas_addr) != 0) {\n\t\t\tif (SAS_ADDR(rri_resp+16) == SAS_ADDR(sas_addr)) {\n\t\t\t\t*index = i;\n\t\t\t\tif ((rri_resp[12] & 0x80) == 0x80)\n\t\t\t\t\t*present = 0;\n\t\t\t\telse\n\t\t\t\t\t*present = 1;\n\t\t\t\tgoto out;\n\t\t\t} else if (SAS_ADDR(rri_resp+16) == 0) {\n\t\t\t\t*index = i;\n\t\t\t\t*present = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if (SAS_ADDR(rri_resp+16) == 0 &&\n\t\t\t   phy->last_da_index < i) {\n\t\t\tphy->last_da_index = i;\n\t\t\t*index = i;\n\t\t\t*present = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tres = -1;\nout:\n\tkfree(rri_req);\n\tkfree(rri_resp);\n\treturn res;\n}\n\n#define CRI_REQ_SIZE  44\n#define CRI_RESP_SIZE  8\n\nstatic int sas_configure_set(struct domain_device *dev, int phy_id,\n\t\t\t     u8 *sas_addr, int index, int include)\n{\n\tint res;\n\tu8 *cri_req;\n\tu8 *cri_resp;\n\n\tcri_req = alloc_smp_req(CRI_REQ_SIZE);\n\tif (!cri_req)\n\t\treturn -ENOMEM;\n\n\tcri_resp = alloc_smp_resp(CRI_RESP_SIZE);\n\tif (!cri_resp) {\n\t\tkfree(cri_req);\n\t\treturn -ENOMEM;\n\t}\n\n\tcri_req[1] = SMP_CONF_ROUTE_INFO;\n\t*(__be16 *)(cri_req+6) = cpu_to_be16(index);\n\tcri_req[9] = phy_id;\n\tif (SAS_ADDR(sas_addr) == 0 || !include)\n\t\tcri_req[12] |= 0x80;\n\tmemcpy(cri_req+16, sas_addr, SAS_ADDR_SIZE);\n\n\tres = smp_execute_task(dev, cri_req, CRI_REQ_SIZE, cri_resp,\n\t\t\t       CRI_RESP_SIZE);\n\tif (res)\n\t\tgoto out;\n\tres = cri_resp[2];\n\tif (res == SMP_RESP_NO_INDEX) {\n\t\tSAS_DPRINTK(\"overflow of indexes: dev %016llx phy 0x%x \"\n\t\t\t    \"index 0x%x\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), phy_id, index);\n\t}\nout:\n\tkfree(cri_req);\n\tkfree(cri_resp);\n\treturn res;\n}\n\nstatic int sas_configure_phy(struct domain_device *dev, int phy_id,\n\t\t\t\t    u8 *sas_addr, int include)\n{\n\tint index;\n\tint present;\n\tint res;\n\n\tres = sas_configure_present(dev, phy_id, sas_addr, &index, &present);\n\tif (res)\n\t\treturn res;\n\tif (include ^ present)\n\t\treturn sas_configure_set(dev, phy_id, sas_addr, index,include);\n\n\treturn res;\n}\n\n/**\n * sas_configure_parent -- configure routing table of parent\n * parent: parent expander\n * child: child expander\n * sas_addr: SAS port identifier of device directly attached to child\n */\nstatic int sas_configure_parent(struct domain_device *parent,\n\t\t\t\tstruct domain_device *child,\n\t\t\t\tu8 *sas_addr, int include)\n{\n\tstruct expander_device *ex_parent = &parent->ex_dev;\n\tint res = 0;\n\tint i;\n\n\tif (parent->parent) {\n\t\tres = sas_configure_parent(parent->parent, parent, sas_addr,\n\t\t\t\t\t   include);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tif (ex_parent->conf_route_table == 0) {\n\t\tSAS_DPRINTK(\"ex %016llx has self-configuring routing table\\n\",\n\t\t\t    SAS_ADDR(parent->sas_addr));\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < ex_parent->num_phys; i++) {\n\t\tstruct ex_phy *phy = &ex_parent->ex_phy[i];\n\n\t\tif ((phy->routing_attr == TABLE_ROUTING) &&\n\t\t    (SAS_ADDR(phy->attached_sas_addr) ==\n\t\t     SAS_ADDR(child->sas_addr))) {\n\t\t\tres = sas_configure_phy(parent, i, sas_addr, include);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n/**\n * sas_configure_routing -- configure routing\n * dev: expander device\n * sas_addr: port identifier of device directly attached to the expander device\n */\nstatic int sas_configure_routing(struct domain_device *dev, u8 *sas_addr)\n{\n\tif (dev->parent)\n\t\treturn sas_configure_parent(dev->parent, dev, sas_addr, 1);\n\treturn 0;\n}\n\nstatic int sas_disable_routing(struct domain_device *dev,  u8 *sas_addr)\n{\n\tif (dev->parent)\n\t\treturn sas_configure_parent(dev->parent, dev, sas_addr, 0);\n\treturn 0;\n}\n\n/**\n * sas_discover_expander -- expander discovery\n * @ex: pointer to expander domain device\n *\n * See comment in sas_discover_sata().\n */\nstatic int sas_discover_expander(struct domain_device *dev)\n{\n\tint res;\n\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\n\tres = sas_ex_general(dev);\n\tif (res)\n\t\tgoto out_err;\n\tres = sas_ex_manuf_info(dev);\n\tif (res)\n\t\tgoto out_err;\n\n\tres = sas_expander_discover(dev);\n\tif (res) {\n\t\tSAS_DPRINTK(\"expander %016llx discovery failed(0x%x)\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), res);\n\t\tgoto out_err;\n\t}\n\n\tsas_check_ex_subtractive_boundary(dev);\n\tres = sas_check_parent_topology(dev);\n\tif (res)\n\t\tgoto out_err;\n\treturn 0;\nout_err:\n\tsas_notify_lldd_dev_gone(dev);\n\treturn res;\n}\n\nstatic int sas_ex_level_discovery(struct asd_sas_port *port, const int level)\n{\n\tint res = 0;\n\tstruct domain_device *dev;\n\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\tif (dev->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t    dev->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\t\tstruct sas_expander_device *ex =\n\t\t\t\trphy_to_expander_device(dev->rphy);\n\n\t\t\tif (level == ex->level)\n\t\t\t\tres = sas_ex_discover_devices(dev, -1);\n\t\t\telse if (level > 0)\n\t\t\t\tres = sas_ex_discover_devices(port->port_dev, -1);\n\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic int sas_ex_bfs_disc(struct asd_sas_port *port)\n{\n\tint res;\n\tint level;\n\n\tdo {\n\t\tlevel = port->disc.max_level;\n\t\tres = sas_ex_level_discovery(port, level);\n\t\tmb();\n\t} while (level < port->disc.max_level);\n\n\treturn res;\n}\n\nint sas_discover_root_expander(struct domain_device *dev)\n{\n\tint res;\n\tstruct sas_expander_device *ex = rphy_to_expander_device(dev->rphy);\n\n\tres = sas_rphy_add(dev->rphy);\n\tif (res)\n\t\tgoto out_err;\n\n\tex->level = dev->port->disc.max_level; /* 0 */\n\tres = sas_discover_expander(dev);\n\tif (res)\n\t\tgoto out_err2;\n\n\tsas_ex_bfs_disc(dev->port);\n\n\treturn res;\n\nout_err2:\n\tsas_rphy_remove(dev->rphy);\nout_err:\n\treturn res;\n}\n\n/* ---------- Domain revalidation ---------- */\n\nstatic int sas_get_phy_discover(struct domain_device *dev,\n\t\t\t\tint phy_id, struct smp_resp *disc_resp)\n{\n\tint res;\n\tu8 *disc_req;\n\n\tdisc_req = alloc_smp_req(DISCOVER_REQ_SIZE);\n\tif (!disc_req)\n\t\treturn -ENOMEM;\n\n\tdisc_req[1] = SMP_DISCOVER;\n\tdisc_req[9] = phy_id;\n\n\tres = smp_execute_task(dev, disc_req, DISCOVER_REQ_SIZE,\n\t\t\t       disc_resp, DISCOVER_RESP_SIZE);\n\tif (res)\n\t\tgoto out;\n\telse if (disc_resp->result != SMP_RESP_FUNC_ACC) {\n\t\tres = disc_resp->result;\n\t\tgoto out;\n\t}\nout:\n\tkfree(disc_req);\n\treturn res;\n}\n\nstatic int sas_get_phy_change_count(struct domain_device *dev,\n\t\t\t\t    int phy_id, int *pcc)\n{\n\tint res;\n\tstruct smp_resp *disc_resp;\n\n\tdisc_resp = alloc_smp_resp(DISCOVER_RESP_SIZE);\n\tif (!disc_resp)\n\t\treturn -ENOMEM;\n\n\tres = sas_get_phy_discover(dev, phy_id, disc_resp);\n\tif (!res)\n\t\t*pcc = disc_resp->disc.change_count;\n\n\tkfree(disc_resp);\n\treturn res;\n}\n\nstatic int sas_get_phy_attached_dev(struct domain_device *dev, int phy_id,\n\t\t\t\t    u8 *sas_addr, enum sas_device_type *type)\n{\n\tint res;\n\tstruct smp_resp *disc_resp;\n\tstruct discover_resp *dr;\n\n\tdisc_resp = alloc_smp_resp(DISCOVER_RESP_SIZE);\n\tif (!disc_resp)\n\t\treturn -ENOMEM;\n\tdr = &disc_resp->disc;\n\n\tres = sas_get_phy_discover(dev, phy_id, disc_resp);\n\tif (res == 0) {\n\t\tmemcpy(sas_addr, disc_resp->disc.attached_sas_addr, 8);\n\t\t*type = to_dev_type(dr);\n\t\tif (*type == 0)\n\t\t\tmemset(sas_addr, 0, 8);\n\t}\n\tkfree(disc_resp);\n\treturn res;\n}\n\nstatic int sas_find_bcast_phy(struct domain_device *dev, int *phy_id,\n\t\t\t      int from_phy, bool update)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint res = 0;\n\tint i;\n\n\tfor (i = from_phy; i < ex->num_phys; i++) {\n\t\tint phy_change_count = 0;\n\n\t\tres = sas_get_phy_change_count(dev, i, &phy_change_count);\n\t\tswitch (res) {\n\t\tcase SMP_RESP_PHY_VACANT:\n\t\tcase SMP_RESP_NO_PHY:\n\t\t\tcontinue;\n\t\tcase SMP_RESP_FUNC_ACC:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn res;\n\t\t}\n\n\t\tif (phy_change_count != ex->ex_phy[i].phy_change_count) {\n\t\t\tif (update)\n\t\t\t\tex->ex_phy[i].phy_change_count =\n\t\t\t\t\tphy_change_count;\n\t\t\t*phy_id = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int sas_get_ex_change_count(struct domain_device *dev, int *ecc)\n{\n\tint res;\n\tu8  *rg_req;\n\tstruct smp_resp  *rg_resp;\n\n\trg_req = alloc_smp_req(RG_REQ_SIZE);\n\tif (!rg_req)\n\t\treturn -ENOMEM;\n\n\trg_resp = alloc_smp_resp(RG_RESP_SIZE);\n\tif (!rg_resp) {\n\t\tkfree(rg_req);\n\t\treturn -ENOMEM;\n\t}\n\n\trg_req[1] = SMP_REPORT_GENERAL;\n\n\tres = smp_execute_task(dev, rg_req, RG_REQ_SIZE, rg_resp,\n\t\t\t       RG_RESP_SIZE);\n\tif (res)\n\t\tgoto out;\n\tif (rg_resp->result != SMP_RESP_FUNC_ACC) {\n\t\tres = rg_resp->result;\n\t\tgoto out;\n\t}\n\n\t*ecc = be16_to_cpu(rg_resp->rg.change_count);\nout:\n\tkfree(rg_resp);\n\tkfree(rg_req);\n\treturn res;\n}\n/**\n * sas_find_bcast_dev -  find the device issue BROADCAST(CHANGE).\n * @dev:domain device to be detect.\n * @src_dev: the device which originated BROADCAST(CHANGE).\n *\n * Add self-configuration expander support. Suppose two expander cascading,\n * when the first level expander is self-configuring, hotplug the disks in\n * second level expander, BROADCAST(CHANGE) will not only be originated\n * in the second level expander, but also be originated in the first level\n * expander (see SAS protocol SAS 2r-14, 7.11 for detail), it is to say,\n * expander changed count in two level expanders will all increment at least\n * once, but the phy which chang count has changed is the source device which\n * we concerned.\n */\n\nstatic int sas_find_bcast_dev(struct domain_device *dev,\n\t\t\t      struct domain_device **src_dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint ex_change_count = -1;\n\tint phy_id = -1;\n\tint res;\n\tstruct domain_device *ch;\n\n\tres = sas_get_ex_change_count(dev, &ex_change_count);\n\tif (res)\n\t\tgoto out;\n\tif (ex_change_count != -1 && ex_change_count != ex->ex_change_count) {\n\t\t/* Just detect if this expander phys phy change count changed,\n\t\t* in order to determine if this expander originate BROADCAST,\n\t\t* and do not update phy change count field in our structure.\n\t\t*/\n\t\tres = sas_find_bcast_phy(dev, &phy_id, 0, false);\n\t\tif (phy_id != -1) {\n\t\t\t*src_dev = dev;\n\t\t\tex->ex_change_count = ex_change_count;\n\t\t\tSAS_DPRINTK(\"Expander phy change count has changed\\n\");\n\t\t\treturn res;\n\t\t} else\n\t\t\tSAS_DPRINTK(\"Expander phys DID NOT change\\n\");\n\t}\n\tlist_for_each_entry(ch, &ex->children, siblings) {\n\t\tif (ch->dev_type == SAS_EDGE_EXPANDER_DEVICE || ch->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\t\tres = sas_find_bcast_dev(ch, src_dev);\n\t\t\tif (*src_dev)\n\t\t\t\treturn res;\n\t\t}\n\t}\nout:\n\treturn res;\n}\n\nstatic void sas_unregister_ex_tree(struct asd_sas_port *port, struct domain_device *dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct domain_device *child, *n;\n\n\tlist_for_each_entry_safe(child, n, &ex->children, siblings) {\n\t\tset_bit(SAS_DEV_GONE, &child->state);\n\t\tif (child->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t    child->dev_type == SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\tsas_unregister_ex_tree(port, child);\n\t\telse\n\t\t\tsas_unregister_dev(port, child);\n\t}\n\tsas_unregister_dev(port, dev);\n}\n\nstatic void sas_unregister_devs_sas_addr(struct domain_device *parent,\n\t\t\t\t\t int phy_id, bool last)\n{\n\tstruct expander_device *ex_dev = &parent->ex_dev;\n\tstruct ex_phy *phy = &ex_dev->ex_phy[phy_id];\n\tstruct domain_device *child, *n, *found = NULL;\n\tif (last) {\n\t\tlist_for_each_entry_safe(child, n,\n\t\t\t&ex_dev->children, siblings) {\n\t\t\tif (SAS_ADDR(child->sas_addr) ==\n\t\t\t    SAS_ADDR(phy->attached_sas_addr)) {\n\t\t\t\tset_bit(SAS_DEV_GONE, &child->state);\n\t\t\t\tif (child->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t\t\t    child->dev_type == SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\t\t\tsas_unregister_ex_tree(parent->port, child);\n\t\t\t\telse\n\t\t\t\t\tsas_unregister_dev(parent->port, child);\n\t\t\t\tfound = child;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsas_disable_routing(parent, phy->attached_sas_addr);\n\t}\n\tmemset(phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\tif (phy->port) {\n\t\tsas_port_delete_phy(phy->port, phy->phy);\n\t\tsas_device_set_phy(found, phy->port);\n\t\tif (phy->port->num_phys == 0)\n\t\t\tsas_port_delete(phy->port);\n\t\tphy->port = NULL;\n\t}\n}\n\nstatic int sas_discover_bfs_by_root_level(struct domain_device *root,\n\t\t\t\t\t  const int level)\n{\n\tstruct expander_device *ex_root = &root->ex_dev;\n\tstruct domain_device *child;\n\tint res = 0;\n\n\tlist_for_each_entry(child, &ex_root->children, siblings) {\n\t\tif (child->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t    child->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\t\tstruct sas_expander_device *ex =\n\t\t\t\trphy_to_expander_device(child->rphy);\n\n\t\t\tif (level > ex->level)\n\t\t\t\tres = sas_discover_bfs_by_root_level(child,\n\t\t\t\t\t\t\t\t     level);\n\t\t\telse if (level == ex->level)\n\t\t\t\tres = sas_ex_discover_devices(child, -1);\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic int sas_discover_bfs_by_root(struct domain_device *dev)\n{\n\tint res;\n\tstruct sas_expander_device *ex = rphy_to_expander_device(dev->rphy);\n\tint level = ex->level+1;\n\n\tres = sas_ex_discover_devices(dev, -1);\n\tif (res)\n\t\tgoto out;\n\tdo {\n\t\tres = sas_discover_bfs_by_root_level(dev, level);\n\t\tmb();\n\t\tlevel += 1;\n\t} while (level <= dev->port->disc.max_level);\nout:\n\treturn res;\n}\n\nstatic int sas_discover_new(struct domain_device *dev, int phy_id)\n{\n\tstruct ex_phy *ex_phy = &dev->ex_dev.ex_phy[phy_id];\n\tstruct domain_device *child;\n\tint res;\n\n\tSAS_DPRINTK(\"ex %016llx phy%d new device attached\\n\",\n\t\t    SAS_ADDR(dev->sas_addr), phy_id);\n\tres = sas_ex_phy_discover(dev, phy_id);\n\tif (res)\n\t\treturn res;\n\n\tif (sas_ex_join_wide_port(dev, phy_id))\n\t\treturn 0;\n\n\tres = sas_ex_discover_devices(dev, phy_id);\n\tif (res)\n\t\treturn res;\n\tlist_for_each_entry(child, &dev->ex_dev.children, siblings) {\n\t\tif (SAS_ADDR(child->sas_addr) ==\n\t\t    SAS_ADDR(ex_phy->attached_sas_addr)) {\n\t\t\tif (child->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t\t    child->dev_type == SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\t\tres = sas_discover_bfs_by_root(child);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic bool dev_type_flutter(enum sas_device_type new, enum sas_device_type old)\n{\n\tif (old == new)\n\t\treturn true;\n\n\t/* treat device directed resets as flutter, if we went\n\t * SAS_END_DEVICE to SAS_SATA_PENDING the link needs recovery\n\t */\n\tif ((old == SAS_SATA_PENDING && new == SAS_END_DEVICE) ||\n\t    (old == SAS_END_DEVICE && new == SAS_SATA_PENDING))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int sas_rediscover_dev(struct domain_device *dev, int phy_id, bool last)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *phy = &ex->ex_phy[phy_id];\n\tenum sas_device_type type = SAS_PHY_UNUSED;\n\tu8 sas_addr[8];\n\tint res;\n\n\tmemset(sas_addr, 0, 8);\n\tres = sas_get_phy_attached_dev(dev, phy_id, sas_addr, &type);\n\tswitch (res) {\n\tcase SMP_RESP_NO_PHY:\n\t\tphy->phy_state = PHY_NOT_PRESENT;\n\t\tsas_unregister_devs_sas_addr(dev, phy_id, last);\n\t\treturn res;\n\tcase SMP_RESP_PHY_VACANT:\n\t\tphy->phy_state = PHY_VACANT;\n\t\tsas_unregister_devs_sas_addr(dev, phy_id, last);\n\t\treturn res;\n\tcase SMP_RESP_FUNC_ACC:\n\t\tbreak;\n\tcase -ECOMM:\n\t\tbreak;\n\tdefault:\n\t\treturn res;\n\t}\n\n\tif ((SAS_ADDR(sas_addr) == 0) || (res == -ECOMM)) {\n\t\tphy->phy_state = PHY_EMPTY;\n\t\tsas_unregister_devs_sas_addr(dev, phy_id, last);\n\t\treturn res;\n\t} else if (SAS_ADDR(sas_addr) == SAS_ADDR(phy->attached_sas_addr) &&\n\t\t   dev_type_flutter(type, phy->attached_dev_type)) {\n\t\tstruct domain_device *ata_dev = sas_ex_to_ata(dev, phy_id);\n\t\tchar *action = \"\";\n\n\t\tsas_ex_phy_discover(dev, phy_id);\n\n\t\tif (ata_dev && phy->attached_dev_type == SAS_SATA_PENDING)\n\t\t\taction = \", needs recovery\";\n\t\tSAS_DPRINTK(\"ex %016llx phy 0x%x broadcast flutter%s\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), phy_id, action);\n\t\treturn res;\n\t}\n\n\t/* delete the old link */\n\tif (SAS_ADDR(phy->attached_sas_addr) &&\n\t    SAS_ADDR(sas_addr) != SAS_ADDR(phy->attached_sas_addr)) {\n\t\tSAS_DPRINTK(\"ex %016llx phy 0x%x replace %016llx\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), phy_id,\n\t\t\t    SAS_ADDR(phy->attached_sas_addr));\n\t\tsas_unregister_devs_sas_addr(dev, phy_id, last);\n\t}\n\n\treturn sas_discover_new(dev, phy_id);\n}\n\n/**\n * sas_rediscover - revalidate the domain.\n * @dev:domain device to be detect.\n * @phy_id: the phy id will be detected.\n *\n * NOTE: this process _must_ quit (return) as soon as any connection\n * errors are encountered.  Connection recovery is done elsewhere.\n * Discover process only interrogates devices in order to discover the\n * domain.For plugging out, we un-register the device only when it is\n * the last phy in the port, for other phys in this port, we just delete it\n * from the port.For inserting, we do discovery when it is the\n * first phy,for other phys in this port, we add it to the port to\n * forming the wide-port.\n */\nstatic int sas_rediscover(struct domain_device *dev, const int phy_id)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *changed_phy = &ex->ex_phy[phy_id];\n\tint res = 0;\n\tint i;\n\tbool last = true;\t/* is this the last phy of the port */\n\n\tSAS_DPRINTK(\"ex %016llx phy%d originated BROADCAST(CHANGE)\\n\",\n\t\t    SAS_ADDR(dev->sas_addr), phy_id);\n\n\tif (SAS_ADDR(changed_phy->attached_sas_addr) != 0) {\n\t\tfor (i = 0; i < ex->num_phys; i++) {\n\t\t\tstruct ex_phy *phy = &ex->ex_phy[i];\n\n\t\t\tif (i == phy_id)\n\t\t\t\tcontinue;\n\t\t\tif (SAS_ADDR(phy->attached_sas_addr) ==\n\t\t\t    SAS_ADDR(changed_phy->attached_sas_addr)) {\n\t\t\t\tSAS_DPRINTK(\"phy%d part of wide port with \"\n\t\t\t\t\t    \"phy%d\\n\", phy_id, i);\n\t\t\t\tlast = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tres = sas_rediscover_dev(dev, phy_id, last);\n\t} else\n\t\tres = sas_discover_new(dev, phy_id);\n\treturn res;\n}\n\n/**\n * sas_revalidate_domain -- revalidate the domain\n * @port: port to the domain of interest\n *\n * NOTE: this process _must_ quit (return) as soon as any connection\n * errors are encountered.  Connection recovery is done elsewhere.\n * Discover process only interrogates devices in order to discover the\n * domain.\n */\nint sas_ex_revalidate_domain(struct domain_device *port_dev)\n{\n\tint res;\n\tstruct domain_device *dev = NULL;\n\n\tres = sas_find_bcast_dev(port_dev, &dev);\n\twhile (res == 0 && dev) {\n\t\tstruct expander_device *ex = &dev->ex_dev;\n\t\tint i = 0, phy_id;\n\n\t\tdo {\n\t\t\tphy_id = -1;\n\t\t\tres = sas_find_bcast_phy(dev, &phy_id, i, true);\n\t\t\tif (phy_id == -1)\n\t\t\t\tbreak;\n\t\t\tres = sas_rediscover(dev, phy_id);\n\t\t\ti = phy_id + 1;\n\t\t} while (i < ex->num_phys);\n\n\t\tdev = NULL;\n\t\tres = sas_find_bcast_dev(port_dev, &dev);\n\t}\n\treturn res;\n}\n\nvoid sas_smp_handler(struct bsg_job *job, struct Scsi_Host *shost,\n\t\tstruct sas_rphy *rphy)\n{\n\tstruct domain_device *dev;\n\tunsigned int reslen = 0;\n\tint ret = -EINVAL;\n\n\t/* no rphy means no smp target support (ie aic94xx host) */\n\tif (!rphy)\n\t\treturn sas_smp_host_handler(job, shost);\n\n\tswitch (rphy->identify.device_type) {\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"%s: can we send a smp request to a device?\\n\",\n\t\t       __func__);\n\t\tgoto out;\n\t}\n\n\tdev = sas_find_dev_by_rphy(rphy);\n\tif (!dev) {\n\t\tprintk(\"%s: fail to find a domain_device?\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\t/* do we need to support multiple segments? */\n\tif (job->request_payload.sg_cnt > 1 ||\n\t    job->reply_payload.sg_cnt > 1) {\n\t\tprintk(\"%s: multiple segments req %u, rsp %u\\n\",\n\t\t       __func__, job->request_payload.payload_len,\n\t\t       job->reply_payload.payload_len);\n\t\tgoto out;\n\t}\n\n\tret = smp_execute_task_sg(dev, job->request_payload.sg_list,\n\t\t\tjob->reply_payload.sg_list);\n\tif (ret > 0) {\n\t\t/* positive number is the untransferred residual */\n\t\treslen = ret;\n\t\tret = 0;\n\t}\n\nout:\n\tbsg_job_done(job, ret, reslen);\n}\n", "/*\n * Serial Attached SCSI (SAS) class internal header file\n *\n * Copyright (C) 2005 Adaptec, Inc.  All rights reserved.\n * Copyright (C) 2005 Luben Tuikov <luben_tuikov@adaptec.com>\n *\n * This file is licensed under GPLv2.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307\n * USA\n *\n */\n\n#ifndef _SAS_INTERNAL_H_\n#define _SAS_INTERNAL_H_\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_transport_sas.h>\n#include <scsi/libsas.h>\n#include <scsi/sas_ata.h>\n\n#define sas_printk(fmt, ...) printk(KERN_NOTICE \"sas: \" fmt, ## __VA_ARGS__)\n\n#define SAS_DPRINTK(fmt, ...) printk(KERN_DEBUG \"sas: \" fmt, ## __VA_ARGS__)\n\n#define TO_SAS_TASK(_scsi_cmd)  ((void *)(_scsi_cmd)->host_scribble)\n#define ASSIGN_SAS_TASK(_sc, _t) do { (_sc)->host_scribble = (void *) _t; } while (0)\n\nstruct sas_phy_data {\n\t/* let reset be performed in sas_queue_work() context */\n\tstruct sas_phy *phy;\n\tstruct mutex event_lock;\n\tint hard_reset;\n\tint reset_result;\n\tstruct sas_work reset_work;\n\tint enable;\n\tint enable_result;\n\tstruct sas_work enable_work;\n};\n\nvoid sas_scsi_recover_host(struct Scsi_Host *shost);\n\nint sas_show_class(enum sas_class class, char *buf);\nint sas_show_proto(enum sas_protocol proto, char *buf);\nint sas_show_linkrate(enum sas_linkrate linkrate, char *buf);\nint sas_show_oob_mode(enum sas_oob_mode oob_mode, char *buf);\n\nint  sas_register_phys(struct sas_ha_struct *sas_ha);\nvoid sas_unregister_phys(struct sas_ha_struct *sas_ha);\n\nstruct asd_sas_event *sas_alloc_event(struct asd_sas_phy *phy);\nvoid sas_free_event(struct asd_sas_event *event);\n\nint  sas_register_ports(struct sas_ha_struct *sas_ha);\nvoid sas_unregister_ports(struct sas_ha_struct *sas_ha);\n\nint  sas_init_events(struct sas_ha_struct *sas_ha);\nvoid sas_disable_revalidation(struct sas_ha_struct *ha);\nvoid sas_enable_revalidation(struct sas_ha_struct *ha);\nvoid __sas_drain_work(struct sas_ha_struct *ha);\n\nvoid sas_deform_port(struct asd_sas_phy *phy, int gone);\n\nvoid sas_porte_bytes_dmaed(struct work_struct *work);\nvoid sas_porte_broadcast_rcvd(struct work_struct *work);\nvoid sas_porte_link_reset_err(struct work_struct *work);\nvoid sas_porte_timer_event(struct work_struct *work);\nvoid sas_porte_hard_reset(struct work_struct *work);\nint sas_queue_work(struct sas_ha_struct *ha, struct sas_work *sw);\n\nint sas_notify_lldd_dev_found(struct domain_device *);\nvoid sas_notify_lldd_dev_gone(struct domain_device *);\n\nvoid sas_smp_handler(struct bsg_job *job, struct Scsi_Host *shost,\n\t\tstruct sas_rphy *rphy);\nint sas_smp_phy_control(struct domain_device *dev, int phy_id,\n\t\t\tenum phy_func phy_func, struct sas_phy_linkrates *);\nint sas_smp_get_phy_events(struct sas_phy *phy);\n\nint sas_notify_phy_event(struct asd_sas_phy *phy, enum phy_event event);\nvoid sas_device_set_phy(struct domain_device *dev, struct sas_port *port);\nstruct domain_device *sas_find_dev_by_rphy(struct sas_rphy *rphy);\nstruct domain_device *sas_ex_to_ata(struct domain_device *ex_dev, int phy_id);\nint sas_ex_phy_discover(struct domain_device *dev, int single);\nint sas_get_report_phy_sata(struct domain_device *dev, int phy_id,\n\t\t\t    struct smp_resp *rps_resp);\nint sas_try_ata_reset(struct asd_sas_phy *phy);\nvoid sas_hae_reset(struct work_struct *work);\n\nvoid sas_free_device(struct kref *kref);\n\nextern const work_func_t sas_phy_event_fns[PHY_NUM_EVENTS];\nextern const work_func_t sas_port_event_fns[PORT_NUM_EVENTS];\n\n#ifdef CONFIG_SCSI_SAS_HOST_SMP\nextern void sas_smp_host_handler(struct bsg_job *job, struct Scsi_Host *shost);\n#else\nstatic inline void sas_smp_host_handler(struct bsg_job *job,\n\t\tstruct Scsi_Host *shost)\n{\n\tshost_printk(KERN_ERR, shost,\n\t\t\"Cannot send SMP to a sas host (not enabled in CONFIG)\\n\");\n\tbsg_job_done(job, -EINVAL, 0);\n}\n#endif\n\nstatic inline void sas_fail_probe(struct domain_device *dev, const char *func, int err)\n{\n\tSAS_DPRINTK(\"%s: for %s device %16llx returned %d\\n\",\n\t\t    func, dev->parent ? \"exp-attached\" :\n\t\t\t\t\t    \"direct-attached\",\n\t\t    SAS_ADDR(dev->sas_addr), err);\n\tsas_unregister_dev(dev->port, dev);\n}\n\nstatic inline void sas_fill_in_rphy(struct domain_device *dev,\n\t\t\t\t    struct sas_rphy *rphy)\n{\n\trphy->identify.sas_address = SAS_ADDR(dev->sas_addr);\n\trphy->identify.initiator_port_protocols = dev->iproto;\n\trphy->identify.target_port_protocols = dev->tproto;\n\tswitch (dev->dev_type) {\n\tcase SAS_SATA_DEV:\n\t\t/* FIXME: need sata device type */\n\tcase SAS_END_DEVICE:\n\tcase SAS_SATA_PENDING:\n\t\trphy->identify.device_type = SAS_END_DEVICE;\n\t\tbreak;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\trphy->identify.device_type = SAS_EDGE_EXPANDER_DEVICE;\n\t\tbreak;\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\trphy->identify.device_type = SAS_FANOUT_EXPANDER_DEVICE;\n\t\tbreak;\n\tdefault:\n\t\trphy->identify.device_type = SAS_PHY_UNUSED;\n\t\tbreak;\n\t}\n}\n\nstatic inline void sas_phy_set_target(struct asd_sas_phy *p, struct domain_device *dev)\n{\n\tstruct sas_phy *phy = p->phy;\n\n\tif (dev) {\n\t\tif (dev_is_sata(dev))\n\t\t\tphy->identify.device_type = SAS_END_DEVICE;\n\t\telse\n\t\t\tphy->identify.device_type = dev->dev_type;\n\t\tphy->identify.target_port_protocols = dev->tproto;\n\t} else {\n\t\tphy->identify.device_type = SAS_PHY_UNUSED;\n\t\tphy->identify.target_port_protocols = 0;\n\t}\n}\n\nstatic inline void sas_add_parent_port(struct domain_device *dev, int phy_id)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *ex_phy = &ex->ex_phy[phy_id];\n\n\tif (!ex->parent_port) {\n\t\tex->parent_port = sas_port_alloc(&dev->rphy->dev, phy_id);\n\t\t/* FIXME: error handling */\n\t\tBUG_ON(!ex->parent_port);\n\t\tBUG_ON(sas_port_add(ex->parent_port));\n\t\tsas_port_mark_backlink(ex->parent_port);\n\t}\n\tsas_port_add_phy(ex->parent_port, ex_phy->phy);\n}\n\nstatic inline struct domain_device *sas_alloc_device(void)\n{\n\tstruct domain_device *dev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\n\tif (dev) {\n\t\tINIT_LIST_HEAD(&dev->siblings);\n\t\tINIT_LIST_HEAD(&dev->dev_list_node);\n\t\tINIT_LIST_HEAD(&dev->disco_list_node);\n\t\tkref_init(&dev->kref);\n\t\tspin_lock_init(&dev->done_lock);\n\t}\n\treturn dev;\n}\n\nstatic inline void sas_put_device(struct domain_device *dev)\n{\n\tkref_put(&dev->kref, sas_free_device);\n}\n\n#endif /* _SAS_INTERNAL_H_ */\n", "/*\n * Serial Attached SCSI (SAS) Port class\n *\n * Copyright (C) 2005 Adaptec, Inc.  All rights reserved.\n * Copyright (C) 2005 Luben Tuikov <luben_tuikov@adaptec.com>\n *\n * This file is licensed under GPLv2.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n\n#include \"sas_internal.h\"\n\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_sas.h>\n#include \"../scsi_sas_internal.h\"\n\nstatic bool phy_is_wideport_member(struct asd_sas_port *port, struct asd_sas_phy *phy)\n{\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\n\tif (memcmp(port->attached_sas_addr, phy->attached_sas_addr,\n\t\t   SAS_ADDR_SIZE) != 0 || (sas_ha->strict_wide_ports &&\n\t     memcmp(port->sas_addr, phy->sas_addr, SAS_ADDR_SIZE) != 0))\n\t\treturn false;\n\treturn true;\n}\n\nstatic void sas_resume_port(struct asd_sas_phy *phy)\n{\n\tstruct domain_device *dev;\n\tstruct asd_sas_port *port = phy->port;\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\tstruct sas_internal *si = to_sas_internal(sas_ha->core.shost->transportt);\n\n\tif (si->dft->lldd_port_formed)\n\t\tsi->dft->lldd_port_formed(phy);\n\n\tif (port->suspended)\n\t\tport->suspended = 0;\n\telse {\n\t\t/* we only need to handle \"link returned\" actions once */\n\t\treturn;\n\t}\n\n\t/* if the port came back:\n\t * 1/ presume every device came back\n\t * 2/ force the next revalidation to check all expander phys\n\t */\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\tint i, rc;\n\n\t\trc = sas_notify_lldd_dev_found(dev);\n\t\tif (rc) {\n\t\t\tsas_unregister_dev(port, dev);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (dev->dev_type == SAS_EDGE_EXPANDER_DEVICE || dev->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\t\tdev->ex_dev.ex_change_count = -1;\n\t\t\tfor (i = 0; i < dev->ex_dev.num_phys; i++) {\n\t\t\t\tstruct ex_phy *phy = &dev->ex_dev.ex_phy[i];\n\n\t\t\t\tphy->phy_change_count = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tsas_discover_event(port, DISCE_RESUME);\n}\n\n/**\n * sas_form_port -- add this phy to a port\n * @phy: the phy of interest\n *\n * This function adds this phy to an existing port, thus creating a wide\n * port, or it creates a port and adds the phy to the port.\n */\nstatic void sas_form_port(struct asd_sas_phy *phy)\n{\n\tint i;\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\tstruct asd_sas_port *port = phy->port;\n\tstruct sas_internal *si =\n\t\tto_sas_internal(sas_ha->core.shost->transportt);\n\tunsigned long flags;\n\n\tif (port) {\n\t\tif (!phy_is_wideport_member(port, phy))\n\t\t\tsas_deform_port(phy, 0);\n\t\telse if (phy->suspended) {\n\t\t\tphy->suspended = 0;\n\t\t\tsas_resume_port(phy);\n\n\t\t\t/* phy came back, try to cancel the timeout */\n\t\t\twake_up(&sas_ha->eh_wait_q);\n\t\t\treturn;\n\t\t} else {\n\t\t\tSAS_DPRINTK(\"%s: phy%d belongs to port%d already(%d)!\\n\",\n\t\t\t\t    __func__, phy->id, phy->port->id,\n\t\t\t\t    phy->port->num_phys);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* see if the phy should be part of a wide port */\n\tspin_lock_irqsave(&sas_ha->phy_port_lock, flags);\n\tfor (i = 0; i < sas_ha->num_phys; i++) {\n\t\tport = sas_ha->sas_port[i];\n\t\tspin_lock(&port->phy_list_lock);\n\t\tif (*(u64 *) port->sas_addr &&\n\t\t    phy_is_wideport_member(port, phy) && port->num_phys > 0) {\n\t\t\t/* wide port */\n\t\t\tSAS_DPRINTK(\"phy%d matched wide port%d\\n\", phy->id,\n\t\t\t\t    port->id);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&port->phy_list_lock);\n\t}\n\t/* The phy does not match any existing port, create a new one */\n\tif (i == sas_ha->num_phys) {\n\t\tfor (i = 0; i < sas_ha->num_phys; i++) {\n\t\t\tport = sas_ha->sas_port[i];\n\t\t\tspin_lock(&port->phy_list_lock);\n\t\t\tif (*(u64 *)port->sas_addr == 0\n\t\t\t\t&& port->num_phys == 0) {\n\t\t\t\tmemcpy(port->sas_addr, phy->sas_addr,\n\t\t\t\t\tSAS_ADDR_SIZE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock(&port->phy_list_lock);\n\t\t}\n\t}\n\n\tif (i >= sas_ha->num_phys) {\n\t\tprintk(KERN_NOTICE \"%s: couldn't find a free port, bug?\\n\",\n\t\t       __func__);\n\t\tspin_unlock_irqrestore(&sas_ha->phy_port_lock, flags);\n\t\treturn;\n\t}\n\n\t/* add the phy to the port */\n\tlist_add_tail(&phy->port_phy_el, &port->phy_list);\n\tsas_phy_set_target(phy, port->port_dev);\n\tphy->port = port;\n\tport->num_phys++;\n\tport->phy_mask |= (1U << phy->id);\n\n\tif (*(u64 *)port->attached_sas_addr == 0) {\n\t\tport->class = phy->class;\n\t\tmemcpy(port->attached_sas_addr, phy->attached_sas_addr,\n\t\t       SAS_ADDR_SIZE);\n\t\tport->iproto = phy->iproto;\n\t\tport->tproto = phy->tproto;\n\t\tport->oob_mode = phy->oob_mode;\n\t\tport->linkrate = phy->linkrate;\n\t} else\n\t\tport->linkrate = max(port->linkrate, phy->linkrate);\n\tspin_unlock(&port->phy_list_lock);\n\tspin_unlock_irqrestore(&sas_ha->phy_port_lock, flags);\n\n\tif (!port->port) {\n\t\tport->port = sas_port_alloc(phy->phy->dev.parent, port->id);\n\t\tBUG_ON(!port->port);\n\t\tsas_port_add(port->port);\n\t}\n\tsas_port_add_phy(port->port, phy->phy);\n\n\tSAS_DPRINTK(\"%s added to %s, phy_mask:0x%x (%16llx)\\n\",\n\t\t    dev_name(&phy->phy->dev), dev_name(&port->port->dev),\n\t\t    port->phy_mask,\n\t\t    SAS_ADDR(port->attached_sas_addr));\n\n\tif (port->port_dev)\n\t\tport->port_dev->pathways = port->num_phys;\n\n\t/* Tell the LLDD about this port formation. */\n\tif (si->dft->lldd_port_formed)\n\t\tsi->dft->lldd_port_formed(phy);\n\n\tsas_discover_event(phy->port, DISCE_DISCOVER_DOMAIN);\n\tflush_workqueue(sas_ha->disco_q);\n}\n\n/**\n * sas_deform_port -- remove this phy from the port it belongs to\n * @phy: the phy of interest\n *\n * This is called when the physical link to the other phy has been\n * lost (on this phy), in Event thread context. We cannot delay here.\n */\nvoid sas_deform_port(struct asd_sas_phy *phy, int gone)\n{\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\tstruct asd_sas_port *port = phy->port;\n\tstruct sas_internal *si =\n\t\tto_sas_internal(sas_ha->core.shost->transportt);\n\tstruct domain_device *dev;\n\tunsigned long flags;\n\n\tif (!port)\n\t\treturn;\t\t  /* done by a phy event */\n\n\tdev = port->port_dev;\n\tif (dev)\n\t\tdev->pathways--;\n\n\tif (port->num_phys == 1) {\n\t\tsas_unregister_domain_devices(port, gone);\n\t\tsas_port_delete(port->port);\n\t\tport->port = NULL;\n\t} else {\n\t\tsas_port_delete_phy(port->port, phy->phy);\n\t\tsas_device_set_phy(dev, port->port);\n\t}\n\n\tif (si->dft->lldd_port_deformed)\n\t\tsi->dft->lldd_port_deformed(phy);\n\n\tspin_lock_irqsave(&sas_ha->phy_port_lock, flags);\n\tspin_lock(&port->phy_list_lock);\n\n\tlist_del_init(&phy->port_phy_el);\n\tsas_phy_set_target(phy, NULL);\n\tphy->port = NULL;\n\tport->num_phys--;\n\tport->phy_mask &= ~(1U << phy->id);\n\n\tif (port->num_phys == 0) {\n\t\tINIT_LIST_HEAD(&port->phy_list);\n\t\tmemset(port->sas_addr, 0, SAS_ADDR_SIZE);\n\t\tmemset(port->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\t\tport->class = 0;\n\t\tport->iproto = 0;\n\t\tport->tproto = 0;\n\t\tport->oob_mode = 0;\n\t\tport->phy_mask = 0;\n\t}\n\tspin_unlock(&port->phy_list_lock);\n\tspin_unlock_irqrestore(&sas_ha->phy_port_lock, flags);\n\n\treturn;\n}\n\n/* ---------- SAS port events ---------- */\n\nvoid sas_porte_bytes_dmaed(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = to_asd_sas_event(work);\n\tstruct asd_sas_phy *phy = ev->phy;\n\n\tsas_form_port(phy);\n}\n\nvoid sas_porte_broadcast_rcvd(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = to_asd_sas_event(work);\n\tstruct asd_sas_phy *phy = ev->phy;\n\tunsigned long flags;\n\tu32 prim;\n\n\tspin_lock_irqsave(&phy->sas_prim_lock, flags);\n\tprim = phy->sas_prim;\n\tspin_unlock_irqrestore(&phy->sas_prim_lock, flags);\n\n\tSAS_DPRINTK(\"broadcast received: %d\\n\", prim);\n\tsas_discover_event(phy->port, DISCE_REVALIDATE_DOMAIN);\n\n\tif (phy->port)\n\t\tflush_workqueue(phy->port->ha->disco_q);\n}\n\nvoid sas_porte_link_reset_err(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = to_asd_sas_event(work);\n\tstruct asd_sas_phy *phy = ev->phy;\n\n\tsas_deform_port(phy, 1);\n}\n\nvoid sas_porte_timer_event(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = to_asd_sas_event(work);\n\tstruct asd_sas_phy *phy = ev->phy;\n\n\tsas_deform_port(phy, 1);\n}\n\nvoid sas_porte_hard_reset(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = to_asd_sas_event(work);\n\tstruct asd_sas_phy *phy = ev->phy;\n\n\tsas_deform_port(phy, 1);\n}\n\n/* ---------- SAS port registration ---------- */\n\nstatic void sas_init_port(struct asd_sas_port *port,\n\t\t\t  struct sas_ha_struct *sas_ha, int i)\n{\n\tmemset(port, 0, sizeof(*port));\n\tport->id = i;\n\tINIT_LIST_HEAD(&port->dev_list);\n\tINIT_LIST_HEAD(&port->disco_list);\n\tINIT_LIST_HEAD(&port->destroy_list);\n\tspin_lock_init(&port->phy_list_lock);\n\tINIT_LIST_HEAD(&port->phy_list);\n\tport->ha = sas_ha;\n\n\tspin_lock_init(&port->dev_list_lock);\n}\n\nint sas_register_ports(struct sas_ha_struct *sas_ha)\n{\n\tint i;\n\n\t/* initialize the ports and discovery */\n\tfor (i = 0; i < sas_ha->num_phys; i++) {\n\t\tstruct asd_sas_port *port = sas_ha->sas_port[i];\n\n\t\tsas_init_port(port, sas_ha, i);\n\t\tsas_init_disc(&port->disc, port);\n\t}\n\treturn 0;\n}\n\nvoid sas_unregister_ports(struct sas_ha_struct *sas_ha)\n{\n\tint i;\n\n\tfor (i = 0; i < sas_ha->num_phys; i++)\n\t\tif (sas_ha->sas_phy[i]->port)\n\t\t\tsas_deform_port(sas_ha->sas_phy[i], 0);\n\n}\n\nconst work_func_t sas_port_event_fns[PORT_NUM_EVENTS] = {\n\t[PORTE_BYTES_DMAED] = sas_porte_bytes_dmaed,\n\t[PORTE_BROADCAST_RCVD] = sas_porte_broadcast_rcvd,\n\t[PORTE_LINK_RESET_ERR] = sas_porte_link_reset_err,\n\t[PORTE_TIMER_EVENT] = sas_porte_timer_event,\n\t[PORTE_HARD_RESET] = sas_porte_hard_reset,\n};\n", "/*\n * SAS host prototypes and structures header file\n *\n * Copyright (C) 2005 Adaptec, Inc.  All rights reserved.\n * Copyright (C) 2005 Luben Tuikov <luben_tuikov@adaptec.com>\n *\n * This file is licensed under GPLv2.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307\n * USA\n *\n */\n\n#ifndef _LIBSAS_H_\n#define _LIBSAS_H_\n\n\n#include <linux/timer.h>\n#include <linux/pci.h>\n#include <scsi/sas.h>\n#include <linux/libata.h>\n#include <linux/list.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_transport_sas.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n\nstruct block_device;\n\nenum sas_class {\n\tSAS,\n\tEXPANDER\n};\n\nenum sas_phy_role {\n\tPHY_ROLE_NONE = 0,\n\tPHY_ROLE_TARGET = 0x40,\n\tPHY_ROLE_INITIATOR = 0x80,\n};\n\nenum sas_phy_type {\n        PHY_TYPE_PHYSICAL,\n        PHY_TYPE_VIRTUAL\n};\n\n/* The events are mnemonically described in sas_dump.c\n * so when updating/adding events here, please also\n * update the other file too.\n */\nenum port_event {\n\tPORTE_BYTES_DMAED     = 0U,\n\tPORTE_BROADCAST_RCVD,\n\tPORTE_LINK_RESET_ERR,\n\tPORTE_TIMER_EVENT,\n\tPORTE_HARD_RESET,\n\tPORT_NUM_EVENTS,\n};\n\nenum phy_event {\n\tPHYE_LOSS_OF_SIGNAL   = 0U,\n\tPHYE_OOB_DONE,\n\tPHYE_OOB_ERROR,\n\tPHYE_SPINUP_HOLD,             /* hot plug SATA, no COMWAKE sent */\n\tPHYE_RESUME_TIMEOUT,\n\tPHYE_SHUTDOWN,\n\tPHY_NUM_EVENTS,\n};\n\nenum discover_event {\n\tDISCE_DISCOVER_DOMAIN   = 0U,\n\tDISCE_REVALIDATE_DOMAIN,\n\tDISCE_PROBE,\n\tDISCE_SUSPEND,\n\tDISCE_RESUME,\n\tDISCE_DESTRUCT,\n\tDISC_NUM_EVENTS,\n};\n\n/* ---------- Expander Devices ---------- */\n\n#define to_dom_device(_obj) container_of(_obj, struct domain_device, dev_obj)\n#define to_dev_attr(_attr)  container_of(_attr, struct domain_dev_attribute,\\\n                                         attr)\n\nenum routing_attribute {\n\tDIRECT_ROUTING,\n\tSUBTRACTIVE_ROUTING,\n\tTABLE_ROUTING,\n};\n\nenum ex_phy_state {\n\tPHY_EMPTY,\n\tPHY_VACANT,\n\tPHY_NOT_PRESENT,\n\tPHY_DEVICE_DISCOVERED\n};\n\nstruct ex_phy {\n\tint    phy_id;\n\n\tenum ex_phy_state phy_state;\n\n\tenum sas_device_type attached_dev_type;\n\tenum sas_linkrate linkrate;\n\n\tu8   attached_sata_host:1;\n\tu8   attached_sata_dev:1;\n\tu8   attached_sata_ps:1;\n\n\tenum sas_protocol attached_tproto;\n\tenum sas_protocol attached_iproto;\n\n\tu8   attached_sas_addr[SAS_ADDR_SIZE];\n\tu8   attached_phy_id;\n\n\tint phy_change_count;\n\tenum routing_attribute routing_attr;\n\tu8   virtual:1;\n\n\tint  last_da_index;\n\n\tstruct sas_phy *phy;\n\tstruct sas_port *port;\n};\n\nstruct expander_device {\n\tstruct list_head children;\n\n\tint    ex_change_count;\n\tu16    max_route_indexes;\n\tu8     num_phys;\n\n\tu8     t2t_supp:1;\n\tu8     configuring:1;\n\tu8     conf_route_table:1;\n\n\tu8     enclosure_logical_id[8];\n\n\tstruct ex_phy *ex_phy;\n\tstruct sas_port *parent_port;\n\n\tstruct mutex cmd_mutex;\n};\n\n/* ---------- SATA device ---------- */\n#define ATA_RESP_FIS_SIZE 24\n\nstruct sata_device {\n\tunsigned int class;\n\tstruct smp_resp        rps_resp; /* report_phy_sata_resp */\n\tu8     port_no;        /* port number, if this is a PM (Port) */\n\n\tstruct ata_port *ap;\n\tstruct ata_host ata_host;\n\tu8     fis[ATA_RESP_FIS_SIZE];\n};\n\nstruct ssp_device {\n\tstruct list_head eh_list_node; /* pending a user requested eh action */\n\tstruct scsi_lun reset_lun;\n};\n\nenum {\n\tSAS_DEV_GONE,\n\tSAS_DEV_FOUND, /* device notified to lldd */\n\tSAS_DEV_DESTROY,\n\tSAS_DEV_EH_PENDING,\n\tSAS_DEV_LU_RESET,\n\tSAS_DEV_RESET,\n};\n\nstruct domain_device {\n\tspinlock_t done_lock;\n\tenum sas_device_type dev_type;\n\n        enum sas_linkrate linkrate;\n        enum sas_linkrate min_linkrate;\n        enum sas_linkrate max_linkrate;\n\n        int  pathways;\n\n        struct domain_device *parent;\n        struct list_head siblings; /* devices on the same level */\n        struct asd_sas_port *port;        /* shortcut to root of the tree */\n\tstruct sas_phy *phy;\n\n        struct list_head dev_list_node;\n\tstruct list_head disco_list_node; /* awaiting probe or destruct */\n\n        enum sas_protocol    iproto;\n        enum sas_protocol    tproto;\n\n        struct sas_rphy *rphy;\n\n        u8  sas_addr[SAS_ADDR_SIZE];\n        u8  hashed_sas_addr[HASHED_SAS_ADDR_SIZE];\n\n        u8  frame_rcvd[32];\n\n        union {\n                struct expander_device ex_dev;\n                struct sata_device     sata_dev; /* STP & directly attached */\n\t\tstruct ssp_device      ssp_dev;\n        };\n\n        void *lldd_dev;\n\tunsigned long state;\n\tstruct kref kref;\n};\n\nstruct sas_work {\n\tstruct list_head drain_node;\n\tstruct work_struct work;\n};\n\nstatic inline void INIT_SAS_WORK(struct sas_work *sw, void (*fn)(struct work_struct *))\n{\n\tINIT_WORK(&sw->work, fn);\n\tINIT_LIST_HEAD(&sw->drain_node);\n}\n\nstruct sas_discovery_event {\n\tstruct sas_work work;\n\tstruct asd_sas_port *port;\n};\n\nstatic inline struct sas_discovery_event *to_sas_discovery_event(struct work_struct *work)\n{\n\tstruct sas_discovery_event *ev = container_of(work, typeof(*ev), work.work);\n\n\treturn ev;\n}\n\nstruct sas_discovery {\n\tstruct sas_discovery_event disc_work[DISC_NUM_EVENTS];\n\tunsigned long    pending;\n\tu8     fanout_sas_addr[8];\n\tu8     eeds_a[8];\n\tu8     eeds_b[8];\n\tint    max_level;\n};\n\n/* The port struct is Class:RW, driver:RO */\nstruct asd_sas_port {\n/* private: */\n\tstruct sas_discovery disc;\n\tstruct domain_device *port_dev;\n\tspinlock_t dev_list_lock;\n\tstruct list_head dev_list;\n\tstruct list_head disco_list;\n\tstruct list_head destroy_list;\n\tenum   sas_linkrate linkrate;\n\n\tstruct sas_work work;\n\tint suspended;\n\n/* public: */\n\tint id;\n\n\tenum sas_class   class;\n\tu8               sas_addr[SAS_ADDR_SIZE];\n\tu8               attached_sas_addr[SAS_ADDR_SIZE];\n\tenum sas_protocol   iproto;\n\tenum sas_protocol   tproto;\n\n\tenum sas_oob_mode oob_mode;\n\n\tspinlock_t       phy_list_lock;\n\tstruct list_head phy_list;\n\tint              num_phys;\n\tu32              phy_mask;\n\n\tstruct sas_ha_struct *ha;\n\n\tstruct sas_port\t*port;\n\n\tvoid *lldd_port;\t  /* not touched by the sas class code */\n};\n\nstruct asd_sas_event {\n\tstruct sas_work work;\n\tstruct asd_sas_phy *phy;\n\tint event;\n};\n\nstatic inline struct asd_sas_event *to_asd_sas_event(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = container_of(work, typeof(*ev), work.work);\n\n\treturn ev;\n}\n\nstatic inline void INIT_SAS_EVENT(struct asd_sas_event *ev,\n\t\tvoid (*fn)(struct work_struct *),\n\t\tstruct asd_sas_phy *phy, int event)\n{\n\tINIT_SAS_WORK(&ev->work, fn);\n\tev->phy = phy;\n\tev->event = event;\n}\n\n#define SAS_PHY_SHUTDOWN_THRES   1024\n\n/* The phy pretty much is controlled by the LLDD.\n * The class only reads those fields.\n */\nstruct asd_sas_phy {\n/* private: */\n\tatomic_t event_nr;\n\tint in_shutdown;\n\tint error;\n\tint suspended;\n\n\tstruct sas_phy *phy;\n\n/* public: */\n\t/* The following are class:RO, driver:R/W */\n\tint            enabled;\t  /* must be set */\n\n\tint            id;\t  /* must be set */\n\tenum sas_class class;\n\tenum sas_protocol iproto;\n\tenum sas_protocol tproto;\n\n\tenum sas_phy_type  type;\n\tenum sas_phy_role  role;\n\tenum sas_oob_mode  oob_mode;\n\tenum sas_linkrate linkrate;\n\n\tu8   *sas_addr;\t\t  /* must be set */\n\tu8   attached_sas_addr[SAS_ADDR_SIZE]; /* class:RO, driver: R/W */\n\n\tspinlock_t     frame_rcvd_lock;\n\tu8             *frame_rcvd; /* must be set */\n\tint            frame_rcvd_size;\n\n\tspinlock_t     sas_prim_lock;\n\tu32            sas_prim;\n\n\tstruct list_head port_phy_el; /* driver:RO */\n\tstruct asd_sas_port      *port; /* Class:RW, driver: RO */\n\n\tstruct sas_ha_struct *ha; /* may be set; the class sets it anyway */\n\n\tvoid *lldd_phy;\t\t  /* not touched by the sas_class_code */\n};\n\nstruct scsi_core {\n\tstruct Scsi_Host *shost;\n\n};\n\nenum sas_ha_state {\n\tSAS_HA_REGISTERED,\n\tSAS_HA_DRAINING,\n\tSAS_HA_ATA_EH_ACTIVE,\n\tSAS_HA_FROZEN,\n};\n\nstruct sas_ha_struct {\n/* private: */\n\tstruct list_head  defer_q; /* work queued while draining */\n\tstruct mutex\t  drain_mutex;\n\tunsigned long\t  state;\n\tspinlock_t\t  lock;\n\tint\t\t  eh_active;\n\twait_queue_head_t eh_wait_q;\n\tstruct list_head  eh_dev_q;\n\n\tstruct mutex disco_mutex;\n\n\tstruct scsi_core core;\n\n/* public: */\n\tchar *sas_ha_name;\n\tstruct device *dev;\t  /* should be set */\n\tstruct module *lldd_module; /* should be set */\n\n\tstruct workqueue_struct *event_q;\n\tstruct workqueue_struct *disco_q;\n\n\tu8 *sas_addr;\t\t  /* must be set */\n\tu8 hashed_sas_addr[HASHED_SAS_ADDR_SIZE];\n\n\tspinlock_t      phy_port_lock;\n\tstruct asd_sas_phy  **sas_phy; /* array of valid pointers, must be set */\n\tstruct asd_sas_port **sas_port; /* array of valid pointers, must be set */\n\tint             num_phys; /* must be set, gt 0, static */\n\n\tint strict_wide_ports; /* both sas_addr and attached_sas_addr must match\n\t\t\t\t* their siblings when forming wide ports */\n\n\t/* LLDD calls these to notify the class of an event. */\n\tint (*notify_port_event)(struct asd_sas_phy *, enum port_event);\n\tint (*notify_phy_event)(struct asd_sas_phy *, enum phy_event);\n\n\tvoid *lldd_ha;\t\t  /* not touched by sas class code */\n\n\tstruct list_head eh_done_q;  /* complete via scsi_eh_flush_done_q */\n\tstruct list_head eh_ata_q; /* scmds to promote from sas to ata eh */\n\n\tint event_thres;\n};\n\n#define SHOST_TO_SAS_HA(_shost) (*(struct sas_ha_struct **)(_shost)->hostdata)\n\nstatic inline struct domain_device *\nstarget_to_domain_dev(struct scsi_target *starget) {\n\treturn starget->hostdata;\n}\n\nstatic inline struct domain_device *\nsdev_to_domain_dev(struct scsi_device *sdev) {\n\treturn starget_to_domain_dev(sdev->sdev_target);\n}\n\nstatic inline struct ata_device *sas_to_ata_dev(struct domain_device *dev)\n{\n\treturn &dev->sata_dev.ap->link.device[0];\n}\n\nstatic inline struct domain_device *\ncmd_to_domain_dev(struct scsi_cmnd *cmd)\n{\n\treturn sdev_to_domain_dev(cmd->device);\n}\n\nvoid sas_hash_addr(u8 *hashed, const u8 *sas_addr);\n\n/* Before calling a notify event, LLDD should use this function\n * when the link is severed (possibly from its tasklet).\n * The idea is that the Class only reads those, while the LLDD,\n * can R/W these (thus avoiding a race).\n */\nstatic inline void sas_phy_disconnected(struct asd_sas_phy *phy)\n{\n\tphy->oob_mode = OOB_NOT_CONNECTED;\n\tphy->linkrate = SAS_LINK_RATE_UNKNOWN;\n}\n\nstatic inline unsigned int to_sas_gpio_od(int device, int bit)\n{\n\treturn 3 * device + bit;\n}\n\nstatic inline void sas_put_local_phy(struct sas_phy *phy)\n{\n\tput_device(&phy->dev);\n}\n\n#ifdef CONFIG_SCSI_SAS_HOST_SMP\nint try_test_sas_gpio_gp_bit(unsigned int od, u8 *data, u8 index, u8 count);\n#else\nstatic inline int try_test_sas_gpio_gp_bit(unsigned int od, u8 *data, u8 index, u8 count)\n{\n\treturn -1;\n}\n#endif\n\n/* ---------- Tasks ---------- */\n/*\n      service_response |  SAS_TASK_COMPLETE  |  SAS_TASK_UNDELIVERED |\n  exec_status          |                     |                       |\n  ---------------------+---------------------+-----------------------+\n       SAM_...         |         X           |                       |\n       DEV_NO_RESPONSE |         X           |           X           |\n       INTERRUPTED     |         X           |                       |\n       QUEUE_FULL      |                     |           X           |\n       DEVICE_UNKNOWN  |                     |           X           |\n       SG_ERR          |                     |           X           |\n  ---------------------+---------------------+-----------------------+\n */\n\nenum service_response {\n\tSAS_TASK_COMPLETE,\n\tSAS_TASK_UNDELIVERED = -1,\n};\n\nenum exec_status {\n\t/* The SAM_STAT_.. codes fit in the lower 6 bits, alias some of\n\t * them here to silence 'case value not in enumerated type' warnings\n\t */\n\t__SAM_STAT_CHECK_CONDITION = SAM_STAT_CHECK_CONDITION,\n\n\tSAS_DEV_NO_RESPONSE = 0x80,\n\tSAS_DATA_UNDERRUN,\n\tSAS_DATA_OVERRUN,\n\tSAS_INTERRUPTED,\n\tSAS_QUEUE_FULL,\n\tSAS_DEVICE_UNKNOWN,\n\tSAS_SG_ERR,\n\tSAS_OPEN_REJECT,\n\tSAS_OPEN_TO,\n\tSAS_PROTO_RESPONSE,\n\tSAS_PHY_DOWN,\n\tSAS_NAK_R_ERR,\n\tSAS_PENDING,\n\tSAS_ABORTED_TASK,\n};\n\n/* When a task finishes with a response, the LLDD examines the\n * response:\n * \t- For an ATA task task_status_struct::stat is set to\n * SAS_PROTO_RESPONSE, and the task_status_struct::buf is set to the\n * contents of struct ata_task_resp.\n * \t- For SSP tasks, if no data is present or status/TMF response\n * is valid, task_status_struct::stat is set.  If data is present\n * (SENSE data), the LLDD copies up to SAS_STATUS_BUF_SIZE, sets\n * task_status_struct::buf_valid_size, and task_status_struct::stat is\n * set to SAM_CHECK_COND.\n *\n * \"buf\" has format SCSI Sense for SSP task, or struct ata_task_resp\n * for ATA task.\n *\n * \"frame_len\" is the total frame length, which could be more or less\n * than actually copied.\n *\n * Tasks ending with response, always set the residual field.\n */\nstruct ata_task_resp {\n\tu16  frame_len;\n\tu8   ending_fis[ATA_RESP_FIS_SIZE];\t  /* dev to host or data-in */\n};\n\n#define SAS_STATUS_BUF_SIZE 96\n\nstruct task_status_struct {\n\tenum service_response resp;\n\tenum exec_status      stat;\n\tint  buf_valid_size;\n\n\tu8   buf[SAS_STATUS_BUF_SIZE];\n\n\tu32  residual;\n\tenum sas_open_rej_reason open_rej_reason;\n};\n\n/* ATA and ATAPI task queuable to a SAS LLDD.\n */\nstruct sas_ata_task {\n\tstruct host_to_dev_fis fis;\n\tu8     atapi_packet[16];  /* 0 if not ATAPI task */\n\n\tu8     retry_count;\t  /* hardware retry, should be > 0 */\n\n\tu8     dma_xfer:1;\t  /* PIO:0 or DMA:1 */\n\tu8     use_ncq:1;\n\tu8     set_affil_pol:1;\n\tu8     stp_affil_pol:1;\n\n\tu8     device_control_reg_update:1;\n};\n\nstruct sas_smp_task {\n\tstruct scatterlist smp_req;\n\tstruct scatterlist smp_resp;\n};\n\nenum task_attribute {\n\tTASK_ATTR_SIMPLE = 0,\n\tTASK_ATTR_HOQ    = 1,\n\tTASK_ATTR_ORDERED= 2,\n\tTASK_ATTR_ACA    = 4,\n};\n\nstruct sas_ssp_task {\n\tu8     retry_count;\t  /* hardware retry, should be > 0 */\n\n\tu8     LUN[8];\n\tu8     enable_first_burst:1;\n\tenum   task_attribute task_attr;\n\tu8     task_prio;\n\tstruct scsi_cmnd *cmd;\n};\n\nstruct sas_task {\n\tstruct domain_device *dev;\n\n\tspinlock_t   task_state_lock;\n\tunsigned     task_state_flags;\n\n\tenum   sas_protocol      task_proto;\n\n\tunion {\n\t\tstruct sas_ata_task ata_task;\n\t\tstruct sas_smp_task smp_task;\n\t\tstruct sas_ssp_task ssp_task;\n\t};\n\n\tstruct scatterlist *scatter;\n\tint    num_scatter;\n\tu32    total_xfer_len;\n\tu8     data_dir:2;\t  /* Use PCI_DMA_... */\n\n\tstruct task_status_struct task_status;\n\tvoid   (*task_done)(struct sas_task *);\n\n\tvoid   *lldd_task;\t  /* for use by LLDDs */\n\tvoid   *uldd_task;\n\tstruct sas_task_slow *slow_task;\n};\n\nstruct sas_task_slow {\n\t/* standard/extra infrastructure for slow path commands (SMP and\n\t * internal lldd commands\n\t */\n\tstruct timer_list     timer;\n\tstruct completion     completion;\n\tstruct sas_task       *task;\n};\n\n#define SAS_TASK_STATE_PENDING      1\n#define SAS_TASK_STATE_DONE         2\n#define SAS_TASK_STATE_ABORTED      4\n#define SAS_TASK_NEED_DEV_RESET     8\n#define SAS_TASK_AT_INITIATOR       16\n\nextern struct sas_task *sas_alloc_task(gfp_t flags);\nextern struct sas_task *sas_alloc_slow_task(gfp_t flags);\nextern void sas_free_task(struct sas_task *task);\n\nstruct sas_domain_function_template {\n\t/* The class calls these to notify the LLDD of an event. */\n\tvoid (*lldd_port_formed)(struct asd_sas_phy *);\n\tvoid (*lldd_port_deformed)(struct asd_sas_phy *);\n\n\t/* The class calls these when a device is found or gone. */\n\tint  (*lldd_dev_found)(struct domain_device *);\n\tvoid (*lldd_dev_gone)(struct domain_device *);\n\n\tint (*lldd_execute_task)(struct sas_task *, gfp_t gfp_flags);\n\n\t/* Task Management Functions. Must be called from process context. */\n\tint (*lldd_abort_task)(struct sas_task *);\n\tint (*lldd_abort_task_set)(struct domain_device *, u8 *lun);\n\tint (*lldd_clear_aca)(struct domain_device *, u8 *lun);\n\tint (*lldd_clear_task_set)(struct domain_device *, u8 *lun);\n\tint (*lldd_I_T_nexus_reset)(struct domain_device *);\n\tint (*lldd_ata_check_ready)(struct domain_device *);\n\tvoid (*lldd_ata_set_dmamode)(struct domain_device *);\n\tint (*lldd_lu_reset)(struct domain_device *, u8 *lun);\n\tint (*lldd_query_task)(struct sas_task *);\n\n\t/* Port and Adapter management */\n\tint (*lldd_clear_nexus_port)(struct asd_sas_port *);\n\tint (*lldd_clear_nexus_ha)(struct sas_ha_struct *);\n\n\t/* Phy management */\n\tint (*lldd_control_phy)(struct asd_sas_phy *, enum phy_func, void *);\n\n\t/* GPIO support */\n\tint (*lldd_write_gpio)(struct sas_ha_struct *, u8 reg_type,\n\t\t\t       u8 reg_index, u8 reg_count, u8 *write_data);\n};\n\nextern int sas_register_ha(struct sas_ha_struct *);\nextern int sas_unregister_ha(struct sas_ha_struct *);\nextern void sas_prep_resume_ha(struct sas_ha_struct *sas_ha);\nextern void sas_resume_ha(struct sas_ha_struct *sas_ha);\nextern void sas_suspend_ha(struct sas_ha_struct *sas_ha);\n\nint sas_set_phy_speed(struct sas_phy *phy,\n\t\t      struct sas_phy_linkrates *rates);\nint sas_phy_reset(struct sas_phy *phy, int hard_reset);\nextern int sas_queuecommand(struct Scsi_Host * ,struct scsi_cmnd *);\nextern int sas_target_alloc(struct scsi_target *);\nextern int sas_slave_configure(struct scsi_device *);\nextern int sas_change_queue_depth(struct scsi_device *, int new_depth);\nextern int sas_bios_param(struct scsi_device *,\n\t\t\t  struct block_device *,\n\t\t\t  sector_t capacity, int *hsc);\nextern struct scsi_transport_template *\nsas_domain_attach_transport(struct sas_domain_function_template *);\nextern struct device_attribute dev_attr_phy_event_threshold;\n\nint  sas_discover_root_expander(struct domain_device *);\n\nvoid sas_init_ex_attr(void);\n\nint  sas_ex_revalidate_domain(struct domain_device *);\n\nvoid sas_unregister_domain_devices(struct asd_sas_port *port, int gone);\nvoid sas_init_disc(struct sas_discovery *disc, struct asd_sas_port *);\nint  sas_discover_event(struct asd_sas_port *, enum discover_event ev);\n\nint  sas_discover_sata(struct domain_device *);\nint  sas_discover_end_dev(struct domain_device *);\n\nvoid sas_unregister_dev(struct asd_sas_port *port, struct domain_device *);\n\nvoid sas_init_dev(struct domain_device *);\n\nvoid sas_task_abort(struct sas_task *);\nint sas_eh_abort_handler(struct scsi_cmnd *cmd);\nint sas_eh_device_reset_handler(struct scsi_cmnd *cmd);\nint sas_eh_target_reset_handler(struct scsi_cmnd *cmd);\n\nextern void sas_target_destroy(struct scsi_target *);\nextern int sas_slave_alloc(struct scsi_device *);\nextern int sas_ioctl(struct scsi_device *sdev, int cmd, void __user *arg);\nextern int sas_drain_work(struct sas_ha_struct *ha);\n\nextern void sas_ssp_task_response(struct device *dev, struct sas_task *task,\n\t\t\t\t  struct ssp_response_iu *iu);\nstruct sas_phy *sas_get_local_phy(struct domain_device *dev);\n\nint sas_request_addr(struct Scsi_Host *shost, u8 *addr);\n\n#endif /* _SASLIB_H_ */\n", "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef SCSI_TRANSPORT_SAS_H\n#define SCSI_TRANSPORT_SAS_H\n\n#include <linux/transport_class.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <scsi/sas.h>\n#include <linux/bsg-lib.h>\n\nstruct scsi_transport_template;\nstruct sas_rphy;\nstruct request;\n\n#if !IS_ENABLED(CONFIG_SCSI_SAS_ATTRS)\nstatic inline int scsi_is_sas_rphy(const struct device *sdev)\n{\n\treturn 0;\n}\n#else\nextern int scsi_is_sas_rphy(const struct device *);\n#endif\n\nstatic inline int sas_protocol_ata(enum sas_protocol proto)\n{\n\treturn ((proto & SAS_PROTOCOL_SATA) ||\n\t\t(proto & SAS_PROTOCOL_STP))? 1 : 0;\n}\n\nenum sas_linkrate {\n\t/* These Values are defined in the SAS standard */\n\tSAS_LINK_RATE_UNKNOWN = 0,\n\tSAS_PHY_DISABLED = 1,\n\tSAS_PHY_RESET_PROBLEM = 2,\n\tSAS_SATA_SPINUP_HOLD = 3,\n\tSAS_SATA_PORT_SELECTOR = 4,\n\tSAS_PHY_RESET_IN_PROGRESS = 5,\n\tSAS_LINK_RATE_1_5_GBPS = 8,\n\tSAS_LINK_RATE_G1 = SAS_LINK_RATE_1_5_GBPS,\n\tSAS_LINK_RATE_3_0_GBPS = 9,\n\tSAS_LINK_RATE_G2 = SAS_LINK_RATE_3_0_GBPS,\n\tSAS_LINK_RATE_6_0_GBPS = 10,\n\tSAS_LINK_RATE_12_0_GBPS = 11,\n\t/* These are virtual to the transport class and may never\n\t * be signalled normally since the standard defined field\n\t * is only 4 bits */\n\tSAS_LINK_RATE_FAILED = 0x10,\n\tSAS_PHY_VIRTUAL = 0x11,\n};\n\nstruct sas_identify {\n\tenum sas_device_type\tdevice_type;\n\tenum sas_protocol\tinitiator_port_protocols;\n\tenum sas_protocol\ttarget_port_protocols;\n\tu64\t\t\tsas_address;\n\tu8\t\t\tphy_identifier;\n};\n\nstruct sas_phy {\n\tstruct device\t\tdev;\n\tint\t\t\tnumber;\n\tint\t\t\tenabled;\n\n\t/* phy identification */\n\tstruct sas_identify\tidentify;\n\n\t/* phy attributes */\n\tenum sas_linkrate\tnegotiated_linkrate;\n\tenum sas_linkrate\tminimum_linkrate_hw;\n\tenum sas_linkrate\tminimum_linkrate;\n\tenum sas_linkrate\tmaximum_linkrate_hw;\n\tenum sas_linkrate\tmaximum_linkrate;\n\n\t/* link error statistics */\n\tu32\t\t\tinvalid_dword_count;\n\tu32\t\t\trunning_disparity_error_count;\n\tu32\t\t\tloss_of_dword_sync_count;\n\tu32\t\t\tphy_reset_problem_count;\n\n\t/* for the list of phys belonging to a port */\n\tstruct list_head\tport_siblings;\n\n\t/* available to the lldd */\n\tvoid\t\t\t*hostdata;\n};\n\n#define dev_to_phy(d) \\\n\tcontainer_of((d), struct sas_phy, dev)\n#define transport_class_to_phy(dev) \\\n\tdev_to_phy((dev)->parent)\n#define phy_to_shost(phy) \\\n\tdev_to_shost((phy)->dev.parent)\n\nstruct request_queue;\nstruct sas_rphy {\n\tstruct device\t\tdev;\n\tstruct sas_identify\tidentify;\n\tstruct list_head\tlist;\n\tstruct request_queue\t*q;\n\tu32\t\t\tscsi_target_id;\n};\n\n#define dev_to_rphy(d) \\\n\tcontainer_of((d), struct sas_rphy, dev)\n#define transport_class_to_rphy(dev) \\\n\tdev_to_rphy((dev)->parent)\n#define rphy_to_shost(rphy) \\\n\tdev_to_shost((rphy)->dev.parent)\n#define target_to_rphy(targ) \\\n\tdev_to_rphy((targ)->dev.parent)\n\nstruct sas_end_device {\n\tstruct sas_rphy\t\trphy;\n\t/* flags */\n\tunsigned\t\tready_led_meaning:1;\n\tunsigned\t\ttlr_supported:1;\n\tunsigned\t\ttlr_enabled:1;\n\t/* parameters */\n\tu16\t\t\tI_T_nexus_loss_timeout;\n\tu16\t\t\tinitiator_response_timeout;\n};\n#define rphy_to_end_device(r) \\\n\tcontainer_of((r), struct sas_end_device, rphy)\n\nstruct sas_expander_device {\n\tint    level;\n\tint    next_port_id;\n\n\t#define SAS_EXPANDER_VENDOR_ID_LEN\t8\n\tchar   vendor_id[SAS_EXPANDER_VENDOR_ID_LEN+1];\n\t#define SAS_EXPANDER_PRODUCT_ID_LEN\t16\n\tchar   product_id[SAS_EXPANDER_PRODUCT_ID_LEN+1];\n\t#define SAS_EXPANDER_PRODUCT_REV_LEN\t4\n\tchar   product_rev[SAS_EXPANDER_PRODUCT_REV_LEN+1];\n\t#define SAS_EXPANDER_COMPONENT_VENDOR_ID_LEN\t8\n\tchar   component_vendor_id[SAS_EXPANDER_COMPONENT_VENDOR_ID_LEN+1];\n\tu16    component_id;\n\tu8     component_revision_id;\n\n\tstruct sas_rphy\t\trphy;\n\n};\n#define rphy_to_expander_device(r) \\\n\tcontainer_of((r), struct sas_expander_device, rphy)\n\nstruct sas_port {\n\tstruct device\t\tdev;\n\n\tint\t\t\tport_identifier;\n\tint\t\t\tnum_phys;\n\t/* port flags */\n\tunsigned int\t\tis_backlink:1;\n\n\t/* the other end of the link */\n\tstruct sas_rphy\t\t*rphy;\n\n\tstruct mutex\t\tphy_list_mutex;\n\tstruct list_head\tphy_list;\n};\n\n#define dev_to_sas_port(d) \\\n\tcontainer_of((d), struct sas_port, dev)\n#define transport_class_to_sas_port(dev) \\\n\tdev_to_sas_port((dev)->parent)\n\nstruct sas_phy_linkrates {\n\tenum sas_linkrate maximum_linkrate;\n\tenum sas_linkrate minimum_linkrate;\n};\n\n/* The functions by which the transport class and the driver communicate */\nstruct sas_function_template {\n\tint (*get_linkerrors)(struct sas_phy *);\n\tint (*get_enclosure_identifier)(struct sas_rphy *, u64 *);\n\tint (*get_bay_identifier)(struct sas_rphy *);\n\tint (*phy_reset)(struct sas_phy *, int);\n\tint (*phy_enable)(struct sas_phy *, int);\n\tint (*phy_setup)(struct sas_phy *);\n\tvoid (*phy_release)(struct sas_phy *);\n\tint (*set_phy_speed)(struct sas_phy *, struct sas_phy_linkrates *);\n\tvoid (*smp_handler)(struct bsg_job *, struct Scsi_Host *,\n\t\t\tstruct sas_rphy *);\n};\n\n\nvoid sas_remove_children(struct device *);\nextern void sas_remove_host(struct Scsi_Host *);\n\nextern struct sas_phy *sas_phy_alloc(struct device *, int);\nextern void sas_phy_free(struct sas_phy *);\nextern int sas_phy_add(struct sas_phy *);\nextern void sas_phy_delete(struct sas_phy *);\nextern int scsi_is_sas_phy(const struct device *);\n\nu64 sas_get_address(struct scsi_device *);\nunsigned int sas_tlr_supported(struct scsi_device *);\nunsigned int sas_is_tlr_enabled(struct scsi_device *);\nvoid sas_disable_tlr(struct scsi_device *);\nvoid sas_enable_tlr(struct scsi_device *);\n\nextern struct sas_rphy *sas_end_device_alloc(struct sas_port *);\nextern struct sas_rphy *sas_expander_alloc(struct sas_port *, enum sas_device_type);\nvoid sas_rphy_free(struct sas_rphy *);\nextern int sas_rphy_add(struct sas_rphy *);\nextern void sas_rphy_remove(struct sas_rphy *);\nextern void sas_rphy_delete(struct sas_rphy *);\nextern void sas_rphy_unlink(struct sas_rphy *);\n\nstruct sas_port *sas_port_alloc(struct device *, int);\nstruct sas_port *sas_port_alloc_num(struct device *);\nint sas_port_add(struct sas_port *);\nvoid sas_port_free(struct sas_port *);\nvoid sas_port_delete(struct sas_port *);\nvoid sas_port_add_phy(struct sas_port *, struct sas_phy *);\nvoid sas_port_delete_phy(struct sas_port *, struct sas_phy *);\nvoid sas_port_mark_backlink(struct sas_port *);\nint scsi_is_sas_port(const struct device *);\nstruct sas_phy *sas_port_get_phy(struct sas_port *port);\nstatic inline void sas_port_put_phy(struct sas_phy *phy)\n{\n\tif (phy)\n\t\tput_device(&phy->dev);\n}\n\nextern struct scsi_transport_template *\nsas_attach_transport(struct sas_function_template *);\nextern void sas_release_transport(struct scsi_transport_template *);\nint sas_read_port_mode_page(struct scsi_device *);\n\nstatic inline int\nscsi_is_sas_expander_device(struct device *dev)\n{\n\tstruct sas_rphy *rphy;\n\tif (!scsi_is_sas_rphy(dev))\n\t\treturn 0;\n\trphy = dev_to_rphy(dev);\n\treturn rphy->identify.device_type == SAS_FANOUT_EXPANDER_DEVICE ||\n\t\trphy->identify.device_type == SAS_EDGE_EXPANDER_DEVICE;\n}\n\n#define scsi_is_sas_phy_local(phy)\tscsi_is_host_device((phy)->dev.parent)\n\n#endif /* SCSI_TRANSPORT_SAS_H */\n"], "fixing_code": ["/*\n * Support for SATA devices on Serial Attached SCSI (SAS) controllers\n *\n * Copyright (C) 2006 IBM Corporation\n *\n * Written by: Darrick J. Wong <djwong@us.ibm.com>, IBM Corporation\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307\n * USA\n */\n\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <linux/async.h>\n#include <linux/export.h>\n\n#include <scsi/sas_ata.h>\n#include \"sas_internal.h\"\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_sas.h>\n#include \"../scsi_sas_internal.h\"\n#include \"../scsi_transport_api.h\"\n#include <scsi/scsi_eh.h>\n\nstatic enum ata_completion_errors sas_to_ata_err(struct task_status_struct *ts)\n{\n\t/* Cheesy attempt to translate SAS errors into ATA.  Hah! */\n\n\t/* transport error */\n\tif (ts->resp == SAS_TASK_UNDELIVERED)\n\t\treturn AC_ERR_ATA_BUS;\n\n\t/* ts->resp == SAS_TASK_COMPLETE */\n\t/* task delivered, what happened afterwards? */\n\tswitch (ts->stat) {\n\t\tcase SAS_DEV_NO_RESPONSE:\n\t\t\treturn AC_ERR_TIMEOUT;\n\n\t\tcase SAS_INTERRUPTED:\n\t\tcase SAS_PHY_DOWN:\n\t\tcase SAS_NAK_R_ERR:\n\t\t\treturn AC_ERR_ATA_BUS;\n\n\n\t\tcase SAS_DATA_UNDERRUN:\n\t\t\t/*\n\t\t\t * Some programs that use the taskfile interface\n\t\t\t * (smartctl in particular) can cause underrun\n\t\t\t * problems.  Ignore these errors, perhaps at our\n\t\t\t * peril.\n\t\t\t */\n\t\t\treturn 0;\n\n\t\tcase SAS_DATA_OVERRUN:\n\t\tcase SAS_QUEUE_FULL:\n\t\tcase SAS_DEVICE_UNKNOWN:\n\t\tcase SAS_SG_ERR:\n\t\t\treturn AC_ERR_INVALID;\n\n\t\tcase SAS_OPEN_TO:\n\t\tcase SAS_OPEN_REJECT:\n\t\t\tSAS_DPRINTK(\"%s: Saw error %d.  What to do?\\n\",\n\t\t\t\t    __func__, ts->stat);\n\t\t\treturn AC_ERR_OTHER;\n\n\t\tcase SAM_STAT_CHECK_CONDITION:\n\t\tcase SAS_ABORTED_TASK:\n\t\t\treturn AC_ERR_DEV;\n\n\t\tcase SAS_PROTO_RESPONSE:\n\t\t\t/* This means the ending_fis has the error\n\t\t\t * value; return 0 here to collect it */\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n}\n\nstatic void sas_ata_task_done(struct sas_task *task)\n{\n\tstruct ata_queued_cmd *qc = task->uldd_task;\n\tstruct domain_device *dev = task->dev;\n\tstruct task_status_struct *stat = &task->task_status;\n\tstruct ata_task_resp *resp = (struct ata_task_resp *)stat->buf;\n\tstruct sas_ha_struct *sas_ha = dev->port->ha;\n\tenum ata_completion_errors ac;\n\tunsigned long flags;\n\tstruct ata_link *link;\n\tstruct ata_port *ap;\n\n\tspin_lock_irqsave(&dev->done_lock, flags);\n\tif (test_bit(SAS_HA_FROZEN, &sas_ha->state))\n\t\ttask = NULL;\n\telse if (qc && qc->scsicmd)\n\t\tASSIGN_SAS_TASK(qc->scsicmd, NULL);\n\tspin_unlock_irqrestore(&dev->done_lock, flags);\n\n\t/* check if libsas-eh got to the task before us */\n\tif (unlikely(!task))\n\t\treturn;\n\n\tif (!qc)\n\t\tgoto qc_already_gone;\n\n\tap = qc->ap;\n\tlink = &ap->link;\n\n\tspin_lock_irqsave(ap->lock, flags);\n\t/* check if we lost the race with libata/sas_ata_post_internal() */\n\tif (unlikely(ap->pflags & ATA_PFLAG_FROZEN)) {\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t\tif (qc->scsicmd)\n\t\t\tgoto qc_already_gone;\n\t\telse {\n\t\t\t/* if eh is not involved and the port is frozen then the\n\t\t\t * ata internal abort process has taken responsibility\n\t\t\t * for this sas_task\n\t\t\t */\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (stat->stat == SAS_PROTO_RESPONSE || stat->stat == SAM_STAT_GOOD ||\n\t    ((stat->stat == SAM_STAT_CHECK_CONDITION &&\n\t      dev->sata_dev.class == ATA_DEV_ATAPI))) {\n\t\tmemcpy(dev->sata_dev.fis, resp->ending_fis, ATA_RESP_FIS_SIZE);\n\n\t\tif (!link->sactive) {\n\t\t\tqc->err_mask |= ac_err_mask(dev->sata_dev.fis[2]);\n\t\t} else {\n\t\t\tlink->eh_info.err_mask |= ac_err_mask(dev->sata_dev.fis[2]);\n\t\t\tif (unlikely(link->eh_info.err_mask))\n\t\t\t\tqc->flags |= ATA_QCFLAG_FAILED;\n\t\t}\n\t} else {\n\t\tac = sas_to_ata_err(stat);\n\t\tif (ac) {\n\t\t\tSAS_DPRINTK(\"%s: SAS error %x\\n\", __func__,\n\t\t\t\t    stat->stat);\n\t\t\t/* We saw a SAS error. Send a vague error. */\n\t\t\tif (!link->sactive) {\n\t\t\t\tqc->err_mask = ac;\n\t\t\t} else {\n\t\t\t\tlink->eh_info.err_mask |= AC_ERR_DEV;\n\t\t\t\tqc->flags |= ATA_QCFLAG_FAILED;\n\t\t\t}\n\n\t\t\tdev->sata_dev.fis[3] = 0x04; /* status err */\n\t\t\tdev->sata_dev.fis[2] = ATA_ERR;\n\t\t}\n\t}\n\n\tqc->lldd_task = NULL;\n\tata_qc_complete(qc);\n\tspin_unlock_irqrestore(ap->lock, flags);\n\nqc_already_gone:\n\tsas_free_task(task);\n}\n\nstatic unsigned int sas_ata_qc_issue(struct ata_queued_cmd *qc)\n{\n\tunsigned long flags;\n\tstruct sas_task *task;\n\tstruct scatterlist *sg;\n\tint ret = AC_ERR_SYSTEM;\n\tunsigned int si, xfer = 0;\n\tstruct ata_port *ap = qc->ap;\n\tstruct domain_device *dev = ap->private_data;\n\tstruct sas_ha_struct *sas_ha = dev->port->ha;\n\tstruct Scsi_Host *host = sas_ha->core.shost;\n\tstruct sas_internal *i = to_sas_internal(host->transportt);\n\n\t/* TODO: audit callers to ensure they are ready for qc_issue to\n\t * unconditionally re-enable interrupts\n\t */\n\tlocal_irq_save(flags);\n\tspin_unlock(ap->lock);\n\n\t/* If the device fell off, no sense in issuing commands */\n\tif (test_bit(SAS_DEV_GONE, &dev->state))\n\t\tgoto out;\n\n\ttask = sas_alloc_task(GFP_ATOMIC);\n\tif (!task)\n\t\tgoto out;\n\ttask->dev = dev;\n\ttask->task_proto = SAS_PROTOCOL_STP;\n\ttask->task_done = sas_ata_task_done;\n\n\tif (qc->tf.command == ATA_CMD_FPDMA_WRITE ||\n\t    qc->tf.command == ATA_CMD_FPDMA_READ ||\n\t    qc->tf.command == ATA_CMD_FPDMA_RECV ||\n\t    qc->tf.command == ATA_CMD_FPDMA_SEND ||\n\t    qc->tf.command == ATA_CMD_NCQ_NON_DATA) {\n\t\t/* Need to zero out the tag libata assigned us */\n\t\tqc->tf.nsect = 0;\n\t}\n\n\tata_tf_to_fis(&qc->tf, qc->dev->link->pmp, 1, (u8 *)&task->ata_task.fis);\n\ttask->uldd_task = qc;\n\tif (ata_is_atapi(qc->tf.protocol)) {\n\t\tmemcpy(task->ata_task.atapi_packet, qc->cdb, qc->dev->cdb_len);\n\t\ttask->total_xfer_len = qc->nbytes;\n\t\ttask->num_scatter = qc->n_elem;\n\t} else {\n\t\tfor_each_sg(qc->sg, sg, qc->n_elem, si)\n\t\t\txfer += sg_dma_len(sg);\n\n\t\ttask->total_xfer_len = xfer;\n\t\ttask->num_scatter = si;\n\t}\n\n\ttask->data_dir = qc->dma_dir;\n\ttask->scatter = qc->sg;\n\ttask->ata_task.retry_count = 1;\n\ttask->task_state_flags = SAS_TASK_STATE_PENDING;\n\tqc->lldd_task = task;\n\n\ttask->ata_task.use_ncq = ata_is_ncq(qc->tf.protocol);\n\ttask->ata_task.dma_xfer = ata_is_dma(qc->tf.protocol);\n\n\tif (qc->scsicmd)\n\t\tASSIGN_SAS_TASK(qc->scsicmd, task);\n\n\tret = i->dft->lldd_execute_task(task, GFP_ATOMIC);\n\tif (ret) {\n\t\tSAS_DPRINTK(\"lldd_execute_task returned: %d\\n\", ret);\n\n\t\tif (qc->scsicmd)\n\t\t\tASSIGN_SAS_TASK(qc->scsicmd, NULL);\n\t\tsas_free_task(task);\n\t\tqc->lldd_task = NULL;\n\t\tret = AC_ERR_SYSTEM;\n\t}\n\n out:\n\tspin_lock(ap->lock);\n\tlocal_irq_restore(flags);\n\treturn ret;\n}\n\nstatic bool sas_ata_qc_fill_rtf(struct ata_queued_cmd *qc)\n{\n\tstruct domain_device *dev = qc->ap->private_data;\n\n\tata_tf_from_fis(dev->sata_dev.fis, &qc->result_tf);\n\treturn true;\n}\n\nstatic struct sas_internal *dev_to_sas_internal(struct domain_device *dev)\n{\n\treturn to_sas_internal(dev->port->ha->core.shost->transportt);\n}\n\nstatic int sas_get_ata_command_set(struct domain_device *dev);\n\nint sas_get_ata_info(struct domain_device *dev, struct ex_phy *phy)\n{\n\tif (phy->attached_tproto & SAS_PROTOCOL_STP)\n\t\tdev->tproto = phy->attached_tproto;\n\tif (phy->attached_sata_dev)\n\t\tdev->tproto |= SAS_SATA_DEV;\n\n\tif (phy->attached_dev_type == SAS_SATA_PENDING)\n\t\tdev->dev_type = SAS_SATA_PENDING;\n\telse {\n\t\tint res;\n\n\t\tdev->dev_type = SAS_SATA_DEV;\n\t\tres = sas_get_report_phy_sata(dev->parent, phy->phy_id,\n\t\t\t\t\t      &dev->sata_dev.rps_resp);\n\t\tif (res) {\n\t\t\tSAS_DPRINTK(\"report phy sata to %016llx:0x%x returned \"\n\t\t\t\t    \"0x%x\\n\", SAS_ADDR(dev->parent->sas_addr),\n\t\t\t\t    phy->phy_id, res);\n\t\t\treturn res;\n\t\t}\n\t\tmemcpy(dev->frame_rcvd, &dev->sata_dev.rps_resp.rps.fis,\n\t\t       sizeof(struct dev_to_host_fis));\n\t\tdev->sata_dev.class = sas_get_ata_command_set(dev);\n\t}\n\treturn 0;\n}\n\nstatic int sas_ata_clear_pending(struct domain_device *dev, struct ex_phy *phy)\n{\n\tint res;\n\n\t/* we weren't pending, so successfully end the reset sequence now */\n\tif (dev->dev_type != SAS_SATA_PENDING)\n\t\treturn 1;\n\n\t/* hmmm, if this succeeds do we need to repost the domain_device to the\n\t * lldd so it can pick up new parameters?\n\t */\n\tres = sas_get_ata_info(dev, phy);\n\tif (res)\n\t\treturn 0; /* retry */\n\telse\n\t\treturn 1;\n}\n\nstatic int smp_ata_check_ready(struct ata_link *link)\n{\n\tint res;\n\tstruct ata_port *ap = link->ap;\n\tstruct domain_device *dev = ap->private_data;\n\tstruct domain_device *ex_dev = dev->parent;\n\tstruct sas_phy *phy = sas_get_local_phy(dev);\n\tstruct ex_phy *ex_phy = &ex_dev->ex_dev.ex_phy[phy->number];\n\n\tres = sas_ex_phy_discover(ex_dev, phy->number);\n\tsas_put_local_phy(phy);\n\n\t/* break the wait early if the expander is unreachable,\n\t * otherwise keep polling\n\t */\n\tif (res == -ECOMM)\n\t\treturn res;\n\tif (res != SMP_RESP_FUNC_ACC)\n\t\treturn 0;\n\n\tswitch (ex_phy->attached_dev_type) {\n\tcase SAS_SATA_PENDING:\n\t\treturn 0;\n\tcase SAS_END_DEVICE:\n\t\tif (ex_phy->attached_sata_dev)\n\t\t\treturn sas_ata_clear_pending(dev, ex_phy);\n\t\t/* fall through */\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n}\n\nstatic int local_ata_check_ready(struct ata_link *link)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct domain_device *dev = ap->private_data;\n\tstruct sas_internal *i = dev_to_sas_internal(dev);\n\n\tif (i->dft->lldd_ata_check_ready)\n\t\treturn i->dft->lldd_ata_check_ready(dev);\n\telse {\n\t\t/* lldd's that don't implement 'ready' checking get the\n\t\t * old default behavior of not coordinating reset\n\t\t * recovery with libata\n\t\t */\n\t\treturn 1;\n\t}\n}\n\nstatic int sas_ata_printk(const char *level, const struct domain_device *ddev,\n\t\t\t  const char *fmt, ...)\n{\n\tstruct ata_port *ap = ddev->sata_dev.ap;\n\tstruct device *dev = &ddev->rphy->dev;\n\tstruct va_format vaf;\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tr = printk(\"%ssas: ata%u: %s: %pV\",\n\t\t   level, ap->print_id, dev_name(dev), &vaf);\n\n\tva_end(args);\n\n\treturn r;\n}\n\nstatic int sas_ata_hard_reset(struct ata_link *link, unsigned int *class,\n\t\t\t      unsigned long deadline)\n{\n\tint ret = 0, res;\n\tstruct sas_phy *phy;\n\tstruct ata_port *ap = link->ap;\n\tint (*check_ready)(struct ata_link *link);\n\tstruct domain_device *dev = ap->private_data;\n\tstruct sas_internal *i = dev_to_sas_internal(dev);\n\n\tres = i->dft->lldd_I_T_nexus_reset(dev);\n\tif (res == -ENODEV)\n\t\treturn res;\n\n\tif (res != TMF_RESP_FUNC_COMPLETE)\n\t\tsas_ata_printk(KERN_DEBUG, dev, \"Unable to reset ata device?\\n\");\n\n\tphy = sas_get_local_phy(dev);\n\tif (scsi_is_sas_phy_local(phy))\n\t\tcheck_ready = local_ata_check_ready;\n\telse\n\t\tcheck_ready = smp_ata_check_ready;\n\tsas_put_local_phy(phy);\n\n\tret = ata_wait_after_reset(link, deadline, check_ready);\n\tif (ret && ret != -EAGAIN)\n\t\tsas_ata_printk(KERN_ERR, dev, \"reset failed (errno=%d)\\n\", ret);\n\n\t*class = dev->sata_dev.class;\n\n\tap->cbl = ATA_CBL_SATA;\n\treturn ret;\n}\n\n/*\n * notify the lldd to forget the sas_task for this internal ata command\n * that bypasses scsi-eh\n */\nstatic void sas_ata_internal_abort(struct sas_task *task)\n{\n\tstruct sas_internal *si = dev_to_sas_internal(task->dev);\n\tunsigned long flags;\n\tint res;\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (task->task_state_flags & SAS_TASK_STATE_ABORTED ||\n\t    task->task_state_flags & SAS_TASK_STATE_DONE) {\n\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\t\tSAS_DPRINTK(\"%s: Task %p already finished.\\n\", __func__,\n\t\t\t    task);\n\t\tgoto out;\n\t}\n\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\tres = si->dft->lldd_abort_task(task);\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (task->task_state_flags & SAS_TASK_STATE_DONE ||\n\t    res == TMF_RESP_FUNC_COMPLETE) {\n\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\t\tgoto out;\n\t}\n\n\t/* XXX we are not prepared to deal with ->lldd_abort_task()\n\t * failures.  TODO: lldds need to unconditionally forget about\n\t * aborted ata tasks, otherwise we (likely) leak the sas task\n\t * here\n\t */\n\tSAS_DPRINTK(\"%s: Task %p leaked.\\n\", __func__, task);\n\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n\t\ttask->task_state_flags &= ~SAS_TASK_STATE_ABORTED;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\treturn;\n out:\n\tsas_free_task(task);\n}\n\nstatic void sas_ata_post_internal(struct ata_queued_cmd *qc)\n{\n\tif (qc->flags & ATA_QCFLAG_FAILED)\n\t\tqc->err_mask |= AC_ERR_OTHER;\n\n\tif (qc->err_mask) {\n\t\t/*\n\t\t * Find the sas_task and kill it.  By this point, libata\n\t\t * has decided to kill the qc and has frozen the port.\n\t\t * In this state sas_ata_task_done() will no longer free\n\t\t * the sas_task, so we need to notify the lldd (via\n\t\t * ->lldd_abort_task) that the task is dead and free it\n\t\t *  ourselves.\n\t\t */\n\t\tstruct sas_task *task = qc->lldd_task;\n\n\t\tqc->lldd_task = NULL;\n\t\tif (!task)\n\t\t\treturn;\n\t\ttask->uldd_task = NULL;\n\t\tsas_ata_internal_abort(task);\n\t}\n}\n\n\nstatic void sas_ata_set_dmamode(struct ata_port *ap, struct ata_device *ata_dev)\n{\n\tstruct domain_device *dev = ap->private_data;\n\tstruct sas_internal *i = dev_to_sas_internal(dev);\n\n\tif (i->dft->lldd_ata_set_dmamode)\n\t\ti->dft->lldd_ata_set_dmamode(dev);\n}\n\nstatic void sas_ata_sched_eh(struct ata_port *ap)\n{\n\tstruct domain_device *dev = ap->private_data;\n\tstruct sas_ha_struct *ha = dev->port->ha;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ha->lock, flags);\n\tif (!test_and_set_bit(SAS_DEV_EH_PENDING, &dev->state))\n\t\tha->eh_active++;\n\tata_std_sched_eh(ap);\n\tspin_unlock_irqrestore(&ha->lock, flags);\n}\n\nvoid sas_ata_end_eh(struct ata_port *ap)\n{\n\tstruct domain_device *dev = ap->private_data;\n\tstruct sas_ha_struct *ha = dev->port->ha;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ha->lock, flags);\n\tif (test_and_clear_bit(SAS_DEV_EH_PENDING, &dev->state))\n\t\tha->eh_active--;\n\tspin_unlock_irqrestore(&ha->lock, flags);\n}\n\nstatic struct ata_port_operations sas_sata_ops = {\n\t.prereset\t\t= ata_std_prereset,\n\t.hardreset\t\t= sas_ata_hard_reset,\n\t.postreset\t\t= ata_std_postreset,\n\t.error_handler\t\t= ata_std_error_handler,\n\t.post_internal_cmd\t= sas_ata_post_internal,\n\t.qc_defer               = ata_std_qc_defer,\n\t.qc_prep\t\t= ata_noop_qc_prep,\n\t.qc_issue\t\t= sas_ata_qc_issue,\n\t.qc_fill_rtf\t\t= sas_ata_qc_fill_rtf,\n\t.port_start\t\t= ata_sas_port_start,\n\t.port_stop\t\t= ata_sas_port_stop,\n\t.set_dmamode\t\t= sas_ata_set_dmamode,\n\t.sched_eh\t\t= sas_ata_sched_eh,\n\t.end_eh\t\t\t= sas_ata_end_eh,\n};\n\nstatic struct ata_port_info sata_port_info = {\n\t.flags = ATA_FLAG_SATA | ATA_FLAG_PIO_DMA | ATA_FLAG_NCQ |\n\t\t ATA_FLAG_SAS_HOST | ATA_FLAG_FPDMA_AUX,\n\t.pio_mask = ATA_PIO4,\n\t.mwdma_mask = ATA_MWDMA2,\n\t.udma_mask = ATA_UDMA6,\n\t.port_ops = &sas_sata_ops\n};\n\nint sas_ata_init(struct domain_device *found_dev)\n{\n\tstruct sas_ha_struct *ha = found_dev->port->ha;\n\tstruct Scsi_Host *shost = ha->core.shost;\n\tstruct ata_port *ap;\n\tint rc;\n\n\tata_host_init(&found_dev->sata_dev.ata_host, ha->dev, &sas_sata_ops);\n\tap = ata_sas_port_alloc(&found_dev->sata_dev.ata_host,\n\t\t\t\t&sata_port_info,\n\t\t\t\tshost);\n\tif (!ap) {\n\t\tSAS_DPRINTK(\"ata_sas_port_alloc failed.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tap->private_data = found_dev;\n\tap->cbl = ATA_CBL_SATA;\n\tap->scsi_host = shost;\n\trc = ata_sas_port_init(ap);\n\tif (rc) {\n\t\tata_sas_port_destroy(ap);\n\t\treturn rc;\n\t}\n\tfound_dev->sata_dev.ap = ap;\n\n\treturn 0;\n}\n\nvoid sas_ata_task_abort(struct sas_task *task)\n{\n\tstruct ata_queued_cmd *qc = task->uldd_task;\n\tstruct completion *waiting;\n\n\t/* Bounce SCSI-initiated commands to the SCSI EH */\n\tif (qc->scsicmd) {\n\t\tstruct request_queue *q = qc->scsicmd->device->request_queue;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(q->queue_lock, flags);\n\t\tblk_abort_request(qc->scsicmd->request);\n\t\tspin_unlock_irqrestore(q->queue_lock, flags);\n\t\treturn;\n\t}\n\n\t/* Internal command, fake a timeout and complete. */\n\tqc->flags &= ~ATA_QCFLAG_ACTIVE;\n\tqc->flags |= ATA_QCFLAG_FAILED;\n\tqc->err_mask |= AC_ERR_TIMEOUT;\n\twaiting = qc->private_data;\n\tcomplete(waiting);\n}\n\nstatic int sas_get_ata_command_set(struct domain_device *dev)\n{\n\tstruct dev_to_host_fis *fis =\n\t\t(struct dev_to_host_fis *) dev->frame_rcvd;\n\tstruct ata_taskfile tf;\n\n\tif (dev->dev_type == SAS_SATA_PENDING)\n\t\treturn ATA_DEV_UNKNOWN;\n\n\tata_tf_from_fis((const u8 *)fis, &tf);\n\n\treturn ata_dev_classify(&tf);\n}\n\nvoid sas_probe_sata(struct asd_sas_port *port)\n{\n\tstruct domain_device *dev, *n;\n\n\tmutex_lock(&port->ha->disco_mutex);\n\tlist_for_each_entry(dev, &port->disco_list, disco_list_node) {\n\t\tif (!dev_is_sata(dev))\n\t\t\tcontinue;\n\n\t\tata_sas_async_probe(dev->sata_dev.ap);\n\t}\n\tmutex_unlock(&port->ha->disco_mutex);\n\n\tlist_for_each_entry_safe(dev, n, &port->disco_list, disco_list_node) {\n\t\tif (!dev_is_sata(dev))\n\t\t\tcontinue;\n\n\t\tsas_ata_wait_eh(dev);\n\n\t\t/* if libata could not bring the link up, don't surface\n\t\t * the device\n\t\t */\n\t\tif (ata_dev_disabled(sas_to_ata_dev(dev)))\n\t\t\tsas_fail_probe(dev, __func__, -ENODEV);\n\t}\n\n}\n\nstatic void sas_ata_flush_pm_eh(struct asd_sas_port *port, const char *func)\n{\n\tstruct domain_device *dev, *n;\n\n\tlist_for_each_entry_safe(dev, n, &port->dev_list, dev_list_node) {\n\t\tif (!dev_is_sata(dev))\n\t\t\tcontinue;\n\n\t\tsas_ata_wait_eh(dev);\n\n\t\t/* if libata failed to power manage the device, tear it down */\n\t\tif (ata_dev_disabled(sas_to_ata_dev(dev)))\n\t\t\tsas_fail_probe(dev, func, -ENODEV);\n\t}\n}\n\nvoid sas_suspend_sata(struct asd_sas_port *port)\n{\n\tstruct domain_device *dev;\n\n\tmutex_lock(&port->ha->disco_mutex);\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\tstruct sata_device *sata;\n\n\t\tif (!dev_is_sata(dev))\n\t\t\tcontinue;\n\n\t\tsata = &dev->sata_dev;\n\t\tif (sata->ap->pm_mesg.event == PM_EVENT_SUSPEND)\n\t\t\tcontinue;\n\n\t\tata_sas_port_suspend(sata->ap);\n\t}\n\tmutex_unlock(&port->ha->disco_mutex);\n\n\tsas_ata_flush_pm_eh(port, __func__);\n}\n\nvoid sas_resume_sata(struct asd_sas_port *port)\n{\n\tstruct domain_device *dev;\n\n\tmutex_lock(&port->ha->disco_mutex);\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\tstruct sata_device *sata;\n\n\t\tif (!dev_is_sata(dev))\n\t\t\tcontinue;\n\n\t\tsata = &dev->sata_dev;\n\t\tif (sata->ap->pm_mesg.event == PM_EVENT_ON)\n\t\t\tcontinue;\n\n\t\tata_sas_port_resume(sata->ap);\n\t}\n\tmutex_unlock(&port->ha->disco_mutex);\n\n\tsas_ata_flush_pm_eh(port, __func__);\n}\n\n/**\n * sas_discover_sata -- discover an STP/SATA domain device\n * @dev: pointer to struct domain_device of interest\n *\n * Devices directly attached to a HA port, have no parents.  All other\n * devices do, and should have their \"parent\" pointer set appropriately\n * before calling this function.\n */\nint sas_discover_sata(struct domain_device *dev)\n{\n\tint res;\n\n\tif (dev->dev_type == SAS_SATA_PM)\n\t\treturn -ENODEV;\n\n\tdev->sata_dev.class = sas_get_ata_command_set(dev);\n\tsas_fill_in_rphy(dev, dev->rphy);\n\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\n\treturn 0;\n}\n\nstatic void async_sas_ata_eh(void *data, async_cookie_t cookie)\n{\n\tstruct domain_device *dev = data;\n\tstruct ata_port *ap = dev->sata_dev.ap;\n\tstruct sas_ha_struct *ha = dev->port->ha;\n\n\tsas_ata_printk(KERN_DEBUG, dev, \"dev error handler\\n\");\n\tata_scsi_port_error_handler(ha->core.shost, ap);\n\tsas_put_device(dev);\n}\n\nvoid sas_ata_strategy_handler(struct Scsi_Host *shost)\n{\n\tstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(shost);\n\tASYNC_DOMAIN_EXCLUSIVE(async);\n\tint i;\n\n\t/* it's ok to defer revalidation events during ata eh, these\n\t * disks are in one of three states:\n\t * 1/ present for initial domain discovery, and these\n\t *    resets will cause bcn flutters\n\t * 2/ hot removed, we'll discover that after eh fails\n\t * 3/ hot added after initial discovery, lost the race, and need\n\t *    to catch the next train.\n\t */\n\tsas_disable_revalidation(sas_ha);\n\n\tspin_lock_irq(&sas_ha->phy_port_lock);\n\tfor (i = 0; i < sas_ha->num_phys; i++) {\n\t\tstruct asd_sas_port *port = sas_ha->sas_port[i];\n\t\tstruct domain_device *dev;\n\n\t\tspin_lock(&port->dev_list_lock);\n\t\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\t\tif (!dev_is_sata(dev))\n\t\t\t\tcontinue;\n\n\t\t\t/* hold a reference over eh since we may be\n\t\t\t * racing with final remove once all commands\n\t\t\t * are completed\n\t\t\t */\n\t\t\tkref_get(&dev->kref);\n\n\t\t\tasync_schedule_domain(async_sas_ata_eh, dev, &async);\n\t\t}\n\t\tspin_unlock(&port->dev_list_lock);\n\t}\n\tspin_unlock_irq(&sas_ha->phy_port_lock);\n\n\tasync_synchronize_full_domain(&async);\n\n\tsas_enable_revalidation(sas_ha);\n}\n\nvoid sas_ata_eh(struct Scsi_Host *shost, struct list_head *work_q,\n\t\tstruct list_head *done_q)\n{\n\tstruct scsi_cmnd *cmd, *n;\n\tstruct domain_device *eh_dev;\n\n\tdo {\n\t\tLIST_HEAD(sata_q);\n\t\teh_dev = NULL;\n\n\t\tlist_for_each_entry_safe(cmd, n, work_q, eh_entry) {\n\t\t\tstruct domain_device *ddev = cmd_to_domain_dev(cmd);\n\n\t\t\tif (!dev_is_sata(ddev) || TO_SAS_TASK(cmd))\n\t\t\t\tcontinue;\n\t\t\tif (eh_dev && eh_dev != ddev)\n\t\t\t\tcontinue;\n\t\t\teh_dev = ddev;\n\t\t\tlist_move(&cmd->eh_entry, &sata_q);\n\t\t}\n\n\t\tif (!list_empty(&sata_q)) {\n\t\t\tstruct ata_port *ap = eh_dev->sata_dev.ap;\n\n\t\t\tsas_ata_printk(KERN_DEBUG, eh_dev, \"cmd error handler\\n\");\n\t\t\tata_scsi_cmd_error_handler(shost, ap, &sata_q);\n\t\t\t/*\n\t\t\t * ata's error handler may leave the cmd on the list\n\t\t\t * so make sure they don't remain on a stack list\n\t\t\t * about to go out of scope.\n\t\t\t *\n\t\t\t * This looks strange, since the commands are\n\t\t\t * now part of no list, but the next error\n\t\t\t * action will be ata_port_error_handler()\n\t\t\t * which takes no list and sweeps them up\n\t\t\t * anyway from the ata tag array.\n\t\t\t */\n\t\t\twhile (!list_empty(&sata_q))\n\t\t\t\tlist_del_init(sata_q.next);\n\t\t}\n\t} while (eh_dev);\n}\n\nvoid sas_ata_schedule_reset(struct domain_device *dev)\n{\n\tstruct ata_eh_info *ehi;\n\tstruct ata_port *ap;\n\tunsigned long flags;\n\n\tif (!dev_is_sata(dev))\n\t\treturn;\n\n\tap = dev->sata_dev.ap;\n\tehi = &ap->link.eh_info;\n\n\tspin_lock_irqsave(ap->lock, flags);\n\tehi->err_mask |= AC_ERR_TIMEOUT;\n\tehi->action |= ATA_EH_RESET;\n\tata_port_schedule_eh(ap);\n\tspin_unlock_irqrestore(ap->lock, flags);\n}\nEXPORT_SYMBOL_GPL(sas_ata_schedule_reset);\n\nvoid sas_ata_wait_eh(struct domain_device *dev)\n{\n\tstruct ata_port *ap;\n\n\tif (!dev_is_sata(dev))\n\t\treturn;\n\n\tap = dev->sata_dev.ap;\n\tata_port_wait_eh(ap);\n}\n", "/*\n * Serial Attached SCSI (SAS) Discover process\n *\n * Copyright (C) 2005 Adaptec, Inc.  All rights reserved.\n * Copyright (C) 2005 Luben Tuikov <luben_tuikov@adaptec.com>\n *\n * This file is licensed under GPLv2.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <linux/async.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_eh.h>\n#include \"sas_internal.h\"\n\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_sas.h>\n#include <scsi/sas_ata.h>\n#include \"../scsi_sas_internal.h\"\n\n/* ---------- Basic task processing for discovery purposes ---------- */\n\nvoid sas_init_dev(struct domain_device *dev)\n{\n\tswitch (dev->dev_type) {\n\tcase SAS_END_DEVICE:\n\t\tINIT_LIST_HEAD(&dev->ssp_dev.eh_list_node);\n\t\tbreak;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\tINIT_LIST_HEAD(&dev->ex_dev.children);\n\t\tmutex_init(&dev->ex_dev.cmd_mutex);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/* ---------- Domain device discovery ---------- */\n\n/**\n * sas_get_port_device -- Discover devices which caused port creation\n * @port: pointer to struct sas_port of interest\n *\n * Devices directly attached to a HA port, have no parent.  This is\n * how we know they are (domain) \"root\" devices.  All other devices\n * do, and should have their \"parent\" pointer set appropriately as\n * soon as a child device is discovered.\n */\nstatic int sas_get_port_device(struct asd_sas_port *port)\n{\n\tstruct asd_sas_phy *phy;\n\tstruct sas_rphy *rphy;\n\tstruct domain_device *dev;\n\tint rc = -ENODEV;\n\n\tdev = sas_alloc_device();\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&port->phy_list_lock);\n\tif (list_empty(&port->phy_list)) {\n\t\tspin_unlock_irq(&port->phy_list_lock);\n\t\tsas_put_device(dev);\n\t\treturn -ENODEV;\n\t}\n\tphy = container_of(port->phy_list.next, struct asd_sas_phy, port_phy_el);\n\tspin_lock(&phy->frame_rcvd_lock);\n\tmemcpy(dev->frame_rcvd, phy->frame_rcvd, min(sizeof(dev->frame_rcvd),\n\t\t\t\t\t     (size_t)phy->frame_rcvd_size));\n\tspin_unlock(&phy->frame_rcvd_lock);\n\tspin_unlock_irq(&port->phy_list_lock);\n\n\tif (dev->frame_rcvd[0] == 0x34 && port->oob_mode == SATA_OOB_MODE) {\n\t\tstruct dev_to_host_fis *fis =\n\t\t\t(struct dev_to_host_fis *) dev->frame_rcvd;\n\t\tif (fis->interrupt_reason == 1 && fis->lbal == 1 &&\n\t\t    fis->byte_count_low==0x69 && fis->byte_count_high == 0x96\n\t\t    && (fis->device & ~0x10) == 0)\n\t\t\tdev->dev_type = SAS_SATA_PM;\n\t\telse\n\t\t\tdev->dev_type = SAS_SATA_DEV;\n\t\tdev->tproto = SAS_PROTOCOL_SATA;\n\t} else {\n\t\tstruct sas_identify_frame *id =\n\t\t\t(struct sas_identify_frame *) dev->frame_rcvd;\n\t\tdev->dev_type = id->dev_type;\n\t\tdev->iproto = id->initiator_bits;\n\t\tdev->tproto = id->target_bits;\n\t}\n\n\tsas_init_dev(dev);\n\n\tdev->port = port;\n\tswitch (dev->dev_type) {\n\tcase SAS_SATA_DEV:\n\t\trc = sas_ata_init(dev);\n\t\tif (rc) {\n\t\t\trphy = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t/* fall through */\n\tcase SAS_END_DEVICE:\n\t\trphy = sas_end_device_alloc(port->port);\n\t\tbreak;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\trphy = sas_expander_alloc(port->port,\n\t\t\t\t\t  SAS_EDGE_EXPANDER_DEVICE);\n\t\tbreak;\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\trphy = sas_expander_alloc(port->port,\n\t\t\t\t\t  SAS_FANOUT_EXPANDER_DEVICE);\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"ERROR: Unidentified device type %d\\n\", dev->dev_type);\n\t\trphy = NULL;\n\t\tbreak;\n\t}\n\n\tif (!rphy) {\n\t\tsas_put_device(dev);\n\t\treturn rc;\n\t}\n\n\trphy->identify.phy_identifier = phy->phy->identify.phy_identifier;\n\tmemcpy(dev->sas_addr, port->attached_sas_addr, SAS_ADDR_SIZE);\n\tsas_fill_in_rphy(dev, rphy);\n\tsas_hash_addr(dev->hashed_sas_addr, dev->sas_addr);\n\tport->port_dev = dev;\n\tdev->linkrate = port->linkrate;\n\tdev->min_linkrate = port->linkrate;\n\tdev->max_linkrate = port->linkrate;\n\tdev->pathways = port->num_phys;\n\tmemset(port->disc.fanout_sas_addr, 0, SAS_ADDR_SIZE);\n\tmemset(port->disc.eeds_a, 0, SAS_ADDR_SIZE);\n\tmemset(port->disc.eeds_b, 0, SAS_ADDR_SIZE);\n\tport->disc.max_level = 0;\n\tsas_device_set_phy(dev, port->port);\n\n\tdev->rphy = rphy;\n\tget_device(&dev->rphy->dev);\n\n\tif (dev_is_sata(dev) || dev->dev_type == SAS_END_DEVICE)\n\t\tlist_add_tail(&dev->disco_list_node, &port->disco_list);\n\telse {\n\t\tspin_lock_irq(&port->dev_list_lock);\n\t\tlist_add_tail(&dev->dev_list_node, &port->dev_list);\n\t\tspin_unlock_irq(&port->dev_list_lock);\n\t}\n\n\tspin_lock_irq(&port->phy_list_lock);\n\tlist_for_each_entry(phy, &port->phy_list, port_phy_el)\n\t\tsas_phy_set_target(phy, dev);\n\tspin_unlock_irq(&port->phy_list_lock);\n\n\treturn 0;\n}\n\n/* ---------- Discover and Revalidate ---------- */\n\nint sas_notify_lldd_dev_found(struct domain_device *dev)\n{\n\tint res = 0;\n\tstruct sas_ha_struct *sas_ha = dev->port->ha;\n\tstruct Scsi_Host *shost = sas_ha->core.shost;\n\tstruct sas_internal *i = to_sas_internal(shost->transportt);\n\n\tif (!i->dft->lldd_dev_found)\n\t\treturn 0;\n\n\tres = i->dft->lldd_dev_found(dev);\n\tif (res) {\n\t\tprintk(\"sas: driver on pcidev %s cannot handle \"\n\t\t       \"device %llx, error:%d\\n\",\n\t\t       dev_name(sas_ha->dev),\n\t\t       SAS_ADDR(dev->sas_addr), res);\n\t}\n\tset_bit(SAS_DEV_FOUND, &dev->state);\n\tkref_get(&dev->kref);\n\treturn res;\n}\n\n\nvoid sas_notify_lldd_dev_gone(struct domain_device *dev)\n{\n\tstruct sas_ha_struct *sas_ha = dev->port->ha;\n\tstruct Scsi_Host *shost = sas_ha->core.shost;\n\tstruct sas_internal *i = to_sas_internal(shost->transportt);\n\n\tif (!i->dft->lldd_dev_gone)\n\t\treturn;\n\n\tif (test_and_clear_bit(SAS_DEV_FOUND, &dev->state)) {\n\t\ti->dft->lldd_dev_gone(dev);\n\t\tsas_put_device(dev);\n\t}\n}\n\nstatic void sas_probe_devices(struct asd_sas_port *port)\n{\n\tstruct domain_device *dev, *n;\n\n\t/* devices must be domain members before link recovery and probe */\n\tlist_for_each_entry(dev, &port->disco_list, disco_list_node) {\n\t\tspin_lock_irq(&port->dev_list_lock);\n\t\tlist_add_tail(&dev->dev_list_node, &port->dev_list);\n\t\tspin_unlock_irq(&port->dev_list_lock);\n\t}\n\n\tsas_probe_sata(port);\n\n\tlist_for_each_entry_safe(dev, n, &port->disco_list, disco_list_node) {\n\t\tint err;\n\n\t\terr = sas_rphy_add(dev->rphy);\n\t\tif (err)\n\t\t\tsas_fail_probe(dev, __func__, err);\n\t\telse\n\t\t\tlist_del_init(&dev->disco_list_node);\n\t}\n}\n\nstatic void sas_suspend_devices(struct work_struct *work)\n{\n\tstruct asd_sas_phy *phy;\n\tstruct domain_device *dev;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\tstruct Scsi_Host *shost = port->ha->core.shost;\n\tstruct sas_internal *si = to_sas_internal(shost->transportt);\n\n\tclear_bit(DISCE_SUSPEND, &port->disc.pending);\n\n\tsas_suspend_sata(port);\n\n\t/* lldd is free to forget the domain_device across the\n\t * suspension, we force the issue here to keep the reference\n\t * counts aligned\n\t */\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node)\n\t\tsas_notify_lldd_dev_gone(dev);\n\n\t/* we are suspending, so we know events are disabled and\n\t * phy_list is not being mutated\n\t */\n\tlist_for_each_entry(phy, &port->phy_list, port_phy_el) {\n\t\tif (si->dft->lldd_port_formed)\n\t\t\tsi->dft->lldd_port_deformed(phy);\n\t\tphy->suspended = 1;\n\t\tport->suspended = 1;\n\t}\n}\n\nstatic void sas_resume_devices(struct work_struct *work)\n{\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\n\tclear_bit(DISCE_RESUME, &port->disc.pending);\n\n\tsas_resume_sata(port);\n}\n\n/**\n * sas_discover_end_dev -- discover an end device (SSP, etc)\n * @end: pointer to domain device of interest\n *\n * See comment in sas_discover_sata().\n */\nint sas_discover_end_dev(struct domain_device *dev)\n{\n\tint res;\n\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\n\treturn 0;\n}\n\n/* ---------- Device registration and unregistration ---------- */\n\nvoid sas_free_device(struct kref *kref)\n{\n\tstruct domain_device *dev = container_of(kref, typeof(*dev), kref);\n\n\tput_device(&dev->rphy->dev);\n\tdev->rphy = NULL;\n\n\tif (dev->parent)\n\t\tsas_put_device(dev->parent);\n\n\tsas_port_put_phy(dev->phy);\n\tdev->phy = NULL;\n\n\t/* remove the phys and ports, everything else should be gone */\n\tif (dev->dev_type == SAS_EDGE_EXPANDER_DEVICE || dev->dev_type == SAS_FANOUT_EXPANDER_DEVICE)\n\t\tkfree(dev->ex_dev.ex_phy);\n\n\tif (dev_is_sata(dev) && dev->sata_dev.ap) {\n\t\tata_sas_port_destroy(dev->sata_dev.ap);\n\t\tdev->sata_dev.ap = NULL;\n\t}\n\n\tkfree(dev);\n}\n\nstatic void sas_unregister_common_dev(struct asd_sas_port *port, struct domain_device *dev)\n{\n\tstruct sas_ha_struct *ha = port->ha;\n\n\tsas_notify_lldd_dev_gone(dev);\n\tif (!dev->parent)\n\t\tdev->port->port_dev = NULL;\n\telse\n\t\tlist_del_init(&dev->siblings);\n\n\tspin_lock_irq(&port->dev_list_lock);\n\tlist_del_init(&dev->dev_list_node);\n\tif (dev_is_sata(dev))\n\t\tsas_ata_end_eh(dev->sata_dev.ap);\n\tspin_unlock_irq(&port->dev_list_lock);\n\n\tspin_lock_irq(&ha->lock);\n\tif (dev->dev_type == SAS_END_DEVICE &&\n\t    !list_empty(&dev->ssp_dev.eh_list_node)) {\n\t\tlist_del_init(&dev->ssp_dev.eh_list_node);\n\t\tha->eh_active--;\n\t}\n\tspin_unlock_irq(&ha->lock);\n\n\tsas_put_device(dev);\n}\n\nvoid sas_destruct_devices(struct asd_sas_port *port)\n{\n\tstruct domain_device *dev, *n;\n\n\tlist_for_each_entry_safe(dev, n, &port->destroy_list, disco_list_node) {\n\t\tlist_del_init(&dev->disco_list_node);\n\n\t\tsas_remove_children(&dev->rphy->dev);\n\t\tsas_rphy_delete(dev->rphy);\n\t\tsas_unregister_common_dev(port, dev);\n\t}\n}\n\nstatic void sas_destruct_ports(struct asd_sas_port *port)\n{\n\tstruct sas_port *sas_port, *p;\n\n\tlist_for_each_entry_safe(sas_port, p, &port->sas_port_del_list, del_list) {\n\t\tlist_del_init(&sas_port->del_list);\n\t\tsas_port_delete(sas_port);\n\t}\n}\n\nvoid sas_unregister_dev(struct asd_sas_port *port, struct domain_device *dev)\n{\n\tif (!test_bit(SAS_DEV_DESTROY, &dev->state) &&\n\t    !list_empty(&dev->disco_list_node)) {\n\t\t/* this rphy never saw sas_rphy_add */\n\t\tlist_del_init(&dev->disco_list_node);\n\t\tsas_rphy_free(dev->rphy);\n\t\tsas_unregister_common_dev(port, dev);\n\t\treturn;\n\t}\n\n\tif (!test_and_set_bit(SAS_DEV_DESTROY, &dev->state)) {\n\t\tsas_rphy_unlink(dev->rphy);\n\t\tlist_move_tail(&dev->disco_list_node, &port->destroy_list);\n\t}\n}\n\nvoid sas_unregister_domain_devices(struct asd_sas_port *port, int gone)\n{\n\tstruct domain_device *dev, *n;\n\n\tlist_for_each_entry_safe_reverse(dev, n, &port->dev_list, dev_list_node) {\n\t\tif (gone)\n\t\t\tset_bit(SAS_DEV_GONE, &dev->state);\n\t\tsas_unregister_dev(port, dev);\n\t}\n\n\tlist_for_each_entry_safe(dev, n, &port->disco_list, disco_list_node)\n\t\tsas_unregister_dev(port, dev);\n\n\tport->port->rphy = NULL;\n\n}\n\nvoid sas_device_set_phy(struct domain_device *dev, struct sas_port *port)\n{\n\tstruct sas_ha_struct *ha;\n\tstruct sas_phy *new_phy;\n\n\tif (!dev)\n\t\treturn;\n\n\tha = dev->port->ha;\n\tnew_phy = sas_port_get_phy(port);\n\n\t/* pin and record last seen phy */\n\tspin_lock_irq(&ha->phy_port_lock);\n\tif (new_phy) {\n\t\tsas_port_put_phy(dev->phy);\n\t\tdev->phy = new_phy;\n\t}\n\tspin_unlock_irq(&ha->phy_port_lock);\n}\n\n/* ---------- Discovery and Revalidation ---------- */\n\n/**\n * sas_discover_domain -- discover the domain\n * @port: port to the domain of interest\n *\n * NOTE: this process _must_ quit (return) as soon as any connection\n * errors are encountered.  Connection recovery is done elsewhere.\n * Discover process only interrogates devices in order to discover the\n * domain.\n */\nstatic void sas_discover_domain(struct work_struct *work)\n{\n\tstruct domain_device *dev;\n\tint error = 0;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\n\tclear_bit(DISCE_DISCOVER_DOMAIN, &port->disc.pending);\n\n\tif (port->port_dev)\n\t\treturn;\n\n\terror = sas_get_port_device(port);\n\tif (error)\n\t\treturn;\n\tdev = port->port_dev;\n\n\tSAS_DPRINTK(\"DOING DISCOVERY on port %d, pid:%d\\n\", port->id,\n\t\t    task_pid_nr(current));\n\n\tswitch (dev->dev_type) {\n\tcase SAS_END_DEVICE:\n\t\terror = sas_discover_end_dev(dev);\n\t\tbreak;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\terror = sas_discover_root_expander(dev);\n\t\tbreak;\n\tcase SAS_SATA_DEV:\n\tcase SAS_SATA_PM:\n#ifdef CONFIG_SCSI_SAS_ATA\n\t\terror = sas_discover_sata(dev);\n\t\tbreak;\n#else\n\t\tSAS_DPRINTK(\"ATA device seen but CONFIG_SCSI_SAS_ATA=N so cannot attach\\n\");\n\t\t/* Fall through */\n#endif\n\tdefault:\n\t\terror = -ENXIO;\n\t\tSAS_DPRINTK(\"unhandled device %d\\n\", dev->dev_type);\n\t\tbreak;\n\t}\n\n\tif (error) {\n\t\tsas_rphy_free(dev->rphy);\n\t\tlist_del_init(&dev->disco_list_node);\n\t\tspin_lock_irq(&port->dev_list_lock);\n\t\tlist_del_init(&dev->dev_list_node);\n\t\tspin_unlock_irq(&port->dev_list_lock);\n\n\t\tsas_put_device(dev);\n\t\tport->port_dev = NULL;\n\t}\n\n\tsas_probe_devices(port);\n\n\tSAS_DPRINTK(\"DONE DISCOVERY on port %d, pid:%d, result:%d\\n\", port->id,\n\t\t    task_pid_nr(current), error);\n}\n\nstatic void sas_revalidate_domain(struct work_struct *work)\n{\n\tint res = 0;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\tstruct sas_ha_struct *ha = port->ha;\n\tstruct domain_device *ddev = port->port_dev;\n\n\t/* prevent revalidation from finding sata links in recovery */\n\tmutex_lock(&ha->disco_mutex);\n\tif (test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state)) {\n\t\tSAS_DPRINTK(\"REVALIDATION DEFERRED on port %d, pid:%d\\n\",\n\t\t\t    port->id, task_pid_nr(current));\n\t\tgoto out;\n\t}\n\n\tclear_bit(DISCE_REVALIDATE_DOMAIN, &port->disc.pending);\n\n\tSAS_DPRINTK(\"REVALIDATING DOMAIN on port %d, pid:%d\\n\", port->id,\n\t\t    task_pid_nr(current));\n\n\tif (ddev && (ddev->dev_type == SAS_FANOUT_EXPANDER_DEVICE ||\n\t\t     ddev->dev_type == SAS_EDGE_EXPANDER_DEVICE))\n\t\tres = sas_ex_revalidate_domain(ddev);\n\n\tSAS_DPRINTK(\"done REVALIDATING DOMAIN on port %d, pid:%d, res 0x%x\\n\",\n\t\t    port->id, task_pid_nr(current), res);\n out:\n\tmutex_unlock(&ha->disco_mutex);\n\n\tsas_destruct_devices(port);\n\tsas_destruct_ports(port);\n\tsas_probe_devices(port);\n}\n\n/* ---------- Events ---------- */\n\nstatic void sas_chain_work(struct sas_ha_struct *ha, struct sas_work *sw)\n{\n\t/* chained work is not subject to SA_HA_DRAINING or\n\t * SAS_HA_REGISTERED, because it is either submitted in the\n\t * workqueue, or known to be submitted from a context that is\n\t * not racing against draining\n\t */\n\tqueue_work(ha->disco_q, &sw->work);\n}\n\nstatic void sas_chain_event(int event, unsigned long *pending,\n\t\t\t    struct sas_work *sw,\n\t\t\t    struct sas_ha_struct *ha)\n{\n\tif (!test_and_set_bit(event, pending)) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&ha->lock, flags);\n\t\tsas_chain_work(ha, sw);\n\t\tspin_unlock_irqrestore(&ha->lock, flags);\n\t}\n}\n\nint sas_discover_event(struct asd_sas_port *port, enum discover_event ev)\n{\n\tstruct sas_discovery *disc;\n\n\tif (!port)\n\t\treturn 0;\n\tdisc = &port->disc;\n\n\tBUG_ON(ev >= DISC_NUM_EVENTS);\n\n\tsas_chain_event(ev, &disc->pending, &disc->disc_work[ev].work, port->ha);\n\n\treturn 0;\n}\n\n/**\n * sas_init_disc -- initialize the discovery struct in the port\n * @port: pointer to struct port\n *\n * Called when the ports are being initialized.\n */\nvoid sas_init_disc(struct sas_discovery *disc, struct asd_sas_port *port)\n{\n\tint i;\n\n\tstatic const work_func_t sas_event_fns[DISC_NUM_EVENTS] = {\n\t\t[DISCE_DISCOVER_DOMAIN] = sas_discover_domain,\n\t\t[DISCE_REVALIDATE_DOMAIN] = sas_revalidate_domain,\n\t\t[DISCE_SUSPEND] = sas_suspend_devices,\n\t\t[DISCE_RESUME] = sas_resume_devices,\n\t};\n\n\tdisc->pending = 0;\n\tfor (i = 0; i < DISC_NUM_EVENTS; i++) {\n\t\tINIT_SAS_WORK(&disc->disc_work[i].work, sas_event_fns[i]);\n\t\tdisc->disc_work[i].port = port;\n\t}\n}\n", "/*\n * Serial Attached SCSI (SAS) Expander discovery and configuration\n *\n * Copyright (C) 2005 Adaptec, Inc.  All rights reserved.\n * Copyright (C) 2005 Luben Tuikov <luben_tuikov@adaptec.com>\n *\n * This file is licensed under GPLv2.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\n#include \"sas_internal.h\"\n\n#include <scsi/sas_ata.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_sas.h>\n#include \"../scsi_sas_internal.h\"\n\nstatic int sas_discover_expander(struct domain_device *dev);\nstatic int sas_configure_routing(struct domain_device *dev, u8 *sas_addr);\nstatic int sas_configure_phy(struct domain_device *dev, int phy_id,\n\t\t\t     u8 *sas_addr, int include);\nstatic int sas_disable_routing(struct domain_device *dev,  u8 *sas_addr);\n\n/* ---------- SMP task management ---------- */\n\nstatic void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n\t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\tcomplete(&task->slow_task->completion);\n}\n\nstatic void smp_task_done(struct sas_task *task)\n{\n\tif (!del_timer(&task->slow_task->timer))\n\t\treturn;\n\tcomplete(&task->slow_task->completion);\n}\n\n/* Give it some long enough timeout. In seconds. */\n#define SMP_TIMEOUT 10\n\nstatic int smp_execute_task_sg(struct domain_device *dev,\n\t\tstruct scatterlist *req, struct scatterlist *resp)\n{\n\tint res, retry;\n\tstruct sas_task *task = NULL;\n\tstruct sas_internal *i =\n\t\tto_sas_internal(dev->port->ha->core.shost->transportt);\n\n\tmutex_lock(&dev->ex_dev.cmd_mutex);\n\tfor (retry = 0; retry < 3; retry++) {\n\t\tif (test_bit(SAS_DEV_GONE, &dev->state)) {\n\t\t\tres = -ECOMM;\n\t\t\tbreak;\n\t\t}\n\n\t\ttask = sas_alloc_slow_task(GFP_KERNEL);\n\t\tif (!task) {\n\t\t\tres = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\ttask->dev = dev;\n\t\ttask->task_proto = dev->tproto;\n\t\ttask->smp_task.smp_req = *req;\n\t\ttask->smp_task.smp_resp = *resp;\n\n\t\ttask->task_done = smp_task_done;\n\n\t\ttask->slow_task->timer.function = smp_task_timedout;\n\t\ttask->slow_task->timer.expires = jiffies + SMP_TIMEOUT*HZ;\n\t\tadd_timer(&task->slow_task->timer);\n\n\t\tres = i->dft->lldd_execute_task(task, GFP_KERNEL);\n\n\t\tif (res) {\n\t\t\tdel_timer(&task->slow_task->timer);\n\t\t\tSAS_DPRINTK(\"executing SMP task failed:%d\\n\", res);\n\t\t\tbreak;\n\t\t}\n\n\t\twait_for_completion(&task->slow_task->completion);\n\t\tres = -ECOMM;\n\t\tif ((task->task_state_flags & SAS_TASK_STATE_ABORTED)) {\n\t\t\tSAS_DPRINTK(\"smp task timed out or aborted\\n\");\n\t\t\ti->dft->lldd_abort_task(task);\n\t\t\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {\n\t\t\t\tSAS_DPRINTK(\"SMP task aborted and not done\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (task->task_status.resp == SAS_TASK_COMPLETE &&\n\t\t    task->task_status.stat == SAM_STAT_GOOD) {\n\t\t\tres = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (task->task_status.resp == SAS_TASK_COMPLETE &&\n\t\t    task->task_status.stat == SAS_DATA_UNDERRUN) {\n\t\t\t/* no error, but return the number of bytes of\n\t\t\t * underrun */\n\t\t\tres = task->task_status.residual;\n\t\t\tbreak;\n\t\t}\n\t\tif (task->task_status.resp == SAS_TASK_COMPLETE &&\n\t\t    task->task_status.stat == SAS_DATA_OVERRUN) {\n\t\t\tres = -EMSGSIZE;\n\t\t\tbreak;\n\t\t}\n\t\tif (task->task_status.resp == SAS_TASK_UNDELIVERED &&\n\t\t    task->task_status.stat == SAS_DEVICE_UNKNOWN)\n\t\t\tbreak;\n\t\telse {\n\t\t\tSAS_DPRINTK(\"%s: task to dev %016llx response: 0x%x \"\n\t\t\t\t    \"status 0x%x\\n\", __func__,\n\t\t\t\t    SAS_ADDR(dev->sas_addr),\n\t\t\t\t    task->task_status.resp,\n\t\t\t\t    task->task_status.stat);\n\t\t\tsas_free_task(task);\n\t\t\ttask = NULL;\n\t\t}\n\t}\n\tmutex_unlock(&dev->ex_dev.cmd_mutex);\n\n\tBUG_ON(retry == 3 && task != NULL);\n\tsas_free_task(task);\n\treturn res;\n}\n\nstatic int smp_execute_task(struct domain_device *dev, void *req, int req_size,\n\t\t\t    void *resp, int resp_size)\n{\n\tstruct scatterlist req_sg;\n\tstruct scatterlist resp_sg;\n\n\tsg_init_one(&req_sg, req, req_size);\n\tsg_init_one(&resp_sg, resp, resp_size);\n\treturn smp_execute_task_sg(dev, &req_sg, &resp_sg);\n}\n\n/* ---------- Allocations ---------- */\n\nstatic inline void *alloc_smp_req(int size)\n{\n\tu8 *p = kzalloc(size, GFP_KERNEL);\n\tif (p)\n\t\tp[0] = SMP_REQUEST;\n\treturn p;\n}\n\nstatic inline void *alloc_smp_resp(int size)\n{\n\treturn kzalloc(size, GFP_KERNEL);\n}\n\nstatic char sas_route_char(struct domain_device *dev, struct ex_phy *phy)\n{\n\tswitch (phy->routing_attr) {\n\tcase TABLE_ROUTING:\n\t\tif (dev->ex_dev.t2t_supp)\n\t\t\treturn 'U';\n\t\telse\n\t\t\treturn 'T';\n\tcase DIRECT_ROUTING:\n\t\treturn 'D';\n\tcase SUBTRACTIVE_ROUTING:\n\t\treturn 'S';\n\tdefault:\n\t\treturn '?';\n\t}\n}\n\nstatic enum sas_device_type to_dev_type(struct discover_resp *dr)\n{\n\t/* This is detecting a failure to transmit initial dev to host\n\t * FIS as described in section J.5 of sas-2 r16\n\t */\n\tif (dr->attached_dev_type == SAS_PHY_UNUSED && dr->attached_sata_dev &&\n\t    dr->linkrate >= SAS_LINK_RATE_1_5_GBPS)\n\t\treturn SAS_SATA_PENDING;\n\telse\n\t\treturn dr->attached_dev_type;\n}\n\nstatic void sas_set_ex_phy(struct domain_device *dev, int phy_id, void *rsp)\n{\n\tenum sas_device_type dev_type;\n\tenum sas_linkrate linkrate;\n\tu8 sas_addr[SAS_ADDR_SIZE];\n\tstruct smp_resp *resp = rsp;\n\tstruct discover_resp *dr = &resp->disc;\n\tstruct sas_ha_struct *ha = dev->port->ha;\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *phy = &ex->ex_phy[phy_id];\n\tstruct sas_rphy *rphy = dev->rphy;\n\tbool new_phy = !phy->phy;\n\tchar *type;\n\n\tif (new_phy) {\n\t\tif (WARN_ON_ONCE(test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state)))\n\t\t\treturn;\n\t\tphy->phy = sas_phy_alloc(&rphy->dev, phy_id);\n\n\t\t/* FIXME: error_handling */\n\t\tBUG_ON(!phy->phy);\n\t}\n\n\tswitch (resp->result) {\n\tcase SMP_RESP_PHY_VACANT:\n\t\tphy->phy_state = PHY_VACANT;\n\t\tbreak;\n\tdefault:\n\t\tphy->phy_state = PHY_NOT_PRESENT;\n\t\tbreak;\n\tcase SMP_RESP_FUNC_ACC:\n\t\tphy->phy_state = PHY_EMPTY; /* do not know yet */\n\t\tbreak;\n\t}\n\n\t/* check if anything important changed to squelch debug */\n\tdev_type = phy->attached_dev_type;\n\tlinkrate  = phy->linkrate;\n\tmemcpy(sas_addr, phy->attached_sas_addr, SAS_ADDR_SIZE);\n\n\t/* Handle vacant phy - rest of dr data is not valid so skip it */\n\tif (phy->phy_state == PHY_VACANT) {\n\t\tmemset(phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\t\tphy->attached_dev_type = SAS_PHY_UNUSED;\n\t\tif (!test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state)) {\n\t\t\tphy->phy_id = phy_id;\n\t\t\tgoto skip;\n\t\t} else\n\t\t\tgoto out;\n\t}\n\n\tphy->attached_dev_type = to_dev_type(dr);\n\tif (test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state))\n\t\tgoto out;\n\tphy->phy_id = phy_id;\n\tphy->linkrate = dr->linkrate;\n\tphy->attached_sata_host = dr->attached_sata_host;\n\tphy->attached_sata_dev  = dr->attached_sata_dev;\n\tphy->attached_sata_ps   = dr->attached_sata_ps;\n\tphy->attached_iproto = dr->iproto << 1;\n\tphy->attached_tproto = dr->tproto << 1;\n\t/* help some expanders that fail to zero sas_address in the 'no\n\t * device' case\n\t */\n\tif (phy->attached_dev_type == SAS_PHY_UNUSED ||\n\t    phy->linkrate < SAS_LINK_RATE_1_5_GBPS)\n\t\tmemset(phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\telse\n\t\tmemcpy(phy->attached_sas_addr, dr->attached_sas_addr, SAS_ADDR_SIZE);\n\tphy->attached_phy_id = dr->attached_phy_id;\n\tphy->phy_change_count = dr->change_count;\n\tphy->routing_attr = dr->routing_attr;\n\tphy->virtual = dr->virtual;\n\tphy->last_da_index = -1;\n\n\tphy->phy->identify.sas_address = SAS_ADDR(phy->attached_sas_addr);\n\tphy->phy->identify.device_type = dr->attached_dev_type;\n\tphy->phy->identify.initiator_port_protocols = phy->attached_iproto;\n\tphy->phy->identify.target_port_protocols = phy->attached_tproto;\n\tif (!phy->attached_tproto && dr->attached_sata_dev)\n\t\tphy->phy->identify.target_port_protocols = SAS_PROTOCOL_SATA;\n\tphy->phy->identify.phy_identifier = phy_id;\n\tphy->phy->minimum_linkrate_hw = dr->hmin_linkrate;\n\tphy->phy->maximum_linkrate_hw = dr->hmax_linkrate;\n\tphy->phy->minimum_linkrate = dr->pmin_linkrate;\n\tphy->phy->maximum_linkrate = dr->pmax_linkrate;\n\tphy->phy->negotiated_linkrate = phy->linkrate;\n\tphy->phy->enabled = (phy->linkrate != SAS_PHY_DISABLED);\n\n skip:\n\tif (new_phy)\n\t\tif (sas_phy_add(phy->phy)) {\n\t\t\tsas_phy_free(phy->phy);\n\t\t\treturn;\n\t\t}\n\n out:\n\tswitch (phy->attached_dev_type) {\n\tcase SAS_SATA_PENDING:\n\t\ttype = \"stp pending\";\n\t\tbreak;\n\tcase SAS_PHY_UNUSED:\n\t\ttype = \"no device\";\n\t\tbreak;\n\tcase SAS_END_DEVICE:\n\t\tif (phy->attached_iproto) {\n\t\t\tif (phy->attached_tproto)\n\t\t\t\ttype = \"host+target\";\n\t\t\telse\n\t\t\t\ttype = \"host\";\n\t\t} else {\n\t\t\tif (dr->attached_sata_dev)\n\t\t\t\ttype = \"stp\";\n\t\t\telse\n\t\t\t\ttype = \"ssp\";\n\t\t}\n\t\tbreak;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\ttype = \"smp\";\n\t\tbreak;\n\tdefault:\n\t\ttype = \"unknown\";\n\t}\n\n\t/* this routine is polled by libata error recovery so filter\n\t * unimportant messages\n\t */\n\tif (new_phy || phy->attached_dev_type != dev_type ||\n\t    phy->linkrate != linkrate ||\n\t    SAS_ADDR(phy->attached_sas_addr) != SAS_ADDR(sas_addr))\n\t\t/* pass */;\n\telse\n\t\treturn;\n\n\t/* if the attached device type changed and ata_eh is active,\n\t * make sure we run revalidation when eh completes (see:\n\t * sas_enable_revalidation)\n\t */\n\tif (test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state))\n\t\tset_bit(DISCE_REVALIDATE_DOMAIN, &dev->port->disc.pending);\n\n\tSAS_DPRINTK(\"%sex %016llx phy%02d:%c:%X attached: %016llx (%s)\\n\",\n\t\t    test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state) ? \"ata: \" : \"\",\n\t\t    SAS_ADDR(dev->sas_addr), phy->phy_id,\n\t\t    sas_route_char(dev, phy), phy->linkrate,\n\t\t    SAS_ADDR(phy->attached_sas_addr), type);\n}\n\n/* check if we have an existing attached ata device on this expander phy */\nstruct domain_device *sas_ex_to_ata(struct domain_device *ex_dev, int phy_id)\n{\n\tstruct ex_phy *ex_phy = &ex_dev->ex_dev.ex_phy[phy_id];\n\tstruct domain_device *dev;\n\tstruct sas_rphy *rphy;\n\n\tif (!ex_phy->port)\n\t\treturn NULL;\n\n\trphy = ex_phy->port->rphy;\n\tif (!rphy)\n\t\treturn NULL;\n\n\tdev = sas_find_dev_by_rphy(rphy);\n\n\tif (dev && dev_is_sata(dev))\n\t\treturn dev;\n\n\treturn NULL;\n}\n\n#define DISCOVER_REQ_SIZE  16\n#define DISCOVER_RESP_SIZE 56\n\nstatic int sas_ex_phy_discover_helper(struct domain_device *dev, u8 *disc_req,\n\t\t\t\t      u8 *disc_resp, int single)\n{\n\tstruct discover_resp *dr;\n\tint res;\n\n\tdisc_req[9] = single;\n\n\tres = smp_execute_task(dev, disc_req, DISCOVER_REQ_SIZE,\n\t\t\t       disc_resp, DISCOVER_RESP_SIZE);\n\tif (res)\n\t\treturn res;\n\tdr = &((struct smp_resp *)disc_resp)->disc;\n\tif (memcmp(dev->sas_addr, dr->attached_sas_addr, SAS_ADDR_SIZE) == 0) {\n\t\tsas_printk(\"Found loopback topology, just ignore it!\\n\");\n\t\treturn 0;\n\t}\n\tsas_set_ex_phy(dev, single, disc_resp);\n\treturn 0;\n}\n\nint sas_ex_phy_discover(struct domain_device *dev, int single)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint  res = 0;\n\tu8   *disc_req;\n\tu8   *disc_resp;\n\n\tdisc_req = alloc_smp_req(DISCOVER_REQ_SIZE);\n\tif (!disc_req)\n\t\treturn -ENOMEM;\n\n\tdisc_resp = alloc_smp_resp(DISCOVER_RESP_SIZE);\n\tif (!disc_resp) {\n\t\tkfree(disc_req);\n\t\treturn -ENOMEM;\n\t}\n\n\tdisc_req[1] = SMP_DISCOVER;\n\n\tif (0 <= single && single < ex->num_phys) {\n\t\tres = sas_ex_phy_discover_helper(dev, disc_req, disc_resp, single);\n\t} else {\n\t\tint i;\n\n\t\tfor (i = 0; i < ex->num_phys; i++) {\n\t\t\tres = sas_ex_phy_discover_helper(dev, disc_req,\n\t\t\t\t\t\t\t disc_resp, i);\n\t\t\tif (res)\n\t\t\t\tgoto out_err;\n\t\t}\n\t}\nout_err:\n\tkfree(disc_resp);\n\tkfree(disc_req);\n\treturn res;\n}\n\nstatic int sas_expander_discover(struct domain_device *dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint res = -ENOMEM;\n\n\tex->ex_phy = kzalloc(sizeof(*ex->ex_phy)*ex->num_phys, GFP_KERNEL);\n\tif (!ex->ex_phy)\n\t\treturn -ENOMEM;\n\n\tres = sas_ex_phy_discover(dev, -1);\n\tif (res)\n\t\tgoto out_err;\n\n\treturn 0;\n out_err:\n\tkfree(ex->ex_phy);\n\tex->ex_phy = NULL;\n\treturn res;\n}\n\n#define MAX_EXPANDER_PHYS 128\n\nstatic void ex_assign_report_general(struct domain_device *dev,\n\t\t\t\t\t    struct smp_resp *resp)\n{\n\tstruct report_general_resp *rg = &resp->rg;\n\n\tdev->ex_dev.ex_change_count = be16_to_cpu(rg->change_count);\n\tdev->ex_dev.max_route_indexes = be16_to_cpu(rg->route_indexes);\n\tdev->ex_dev.num_phys = min(rg->num_phys, (u8)MAX_EXPANDER_PHYS);\n\tdev->ex_dev.t2t_supp = rg->t2t_supp;\n\tdev->ex_dev.conf_route_table = rg->conf_route_table;\n\tdev->ex_dev.configuring = rg->configuring;\n\tmemcpy(dev->ex_dev.enclosure_logical_id, rg->enclosure_logical_id, 8);\n}\n\n#define RG_REQ_SIZE   8\n#define RG_RESP_SIZE 32\n\nstatic int sas_ex_general(struct domain_device *dev)\n{\n\tu8 *rg_req;\n\tstruct smp_resp *rg_resp;\n\tint res;\n\tint i;\n\n\trg_req = alloc_smp_req(RG_REQ_SIZE);\n\tif (!rg_req)\n\t\treturn -ENOMEM;\n\n\trg_resp = alloc_smp_resp(RG_RESP_SIZE);\n\tif (!rg_resp) {\n\t\tkfree(rg_req);\n\t\treturn -ENOMEM;\n\t}\n\n\trg_req[1] = SMP_REPORT_GENERAL;\n\n\tfor (i = 0; i < 5; i++) {\n\t\tres = smp_execute_task(dev, rg_req, RG_REQ_SIZE, rg_resp,\n\t\t\t\t       RG_RESP_SIZE);\n\n\t\tif (res) {\n\t\t\tSAS_DPRINTK(\"RG to ex %016llx failed:0x%x\\n\",\n\t\t\t\t    SAS_ADDR(dev->sas_addr), res);\n\t\t\tgoto out;\n\t\t} else if (rg_resp->result != SMP_RESP_FUNC_ACC) {\n\t\t\tSAS_DPRINTK(\"RG:ex %016llx returned SMP result:0x%x\\n\",\n\t\t\t\t    SAS_ADDR(dev->sas_addr), rg_resp->result);\n\t\t\tres = rg_resp->result;\n\t\t\tgoto out;\n\t\t}\n\n\t\tex_assign_report_general(dev, rg_resp);\n\n\t\tif (dev->ex_dev.configuring) {\n\t\t\tSAS_DPRINTK(\"RG: ex %llx self-configuring...\\n\",\n\t\t\t\t    SAS_ADDR(dev->sas_addr));\n\t\t\tschedule_timeout_interruptible(5*HZ);\n\t\t} else\n\t\t\tbreak;\n\t}\nout:\n\tkfree(rg_req);\n\tkfree(rg_resp);\n\treturn res;\n}\n\nstatic void ex_assign_manuf_info(struct domain_device *dev, void\n\t\t\t\t\t*_mi_resp)\n{\n\tu8 *mi_resp = _mi_resp;\n\tstruct sas_rphy *rphy = dev->rphy;\n\tstruct sas_expander_device *edev = rphy_to_expander_device(rphy);\n\n\tmemcpy(edev->vendor_id, mi_resp + 12, SAS_EXPANDER_VENDOR_ID_LEN);\n\tmemcpy(edev->product_id, mi_resp + 20, SAS_EXPANDER_PRODUCT_ID_LEN);\n\tmemcpy(edev->product_rev, mi_resp + 36,\n\t       SAS_EXPANDER_PRODUCT_REV_LEN);\n\n\tif (mi_resp[8] & 1) {\n\t\tmemcpy(edev->component_vendor_id, mi_resp + 40,\n\t\t       SAS_EXPANDER_COMPONENT_VENDOR_ID_LEN);\n\t\tedev->component_id = mi_resp[48] << 8 | mi_resp[49];\n\t\tedev->component_revision_id = mi_resp[50];\n\t}\n}\n\n#define MI_REQ_SIZE   8\n#define MI_RESP_SIZE 64\n\nstatic int sas_ex_manuf_info(struct domain_device *dev)\n{\n\tu8 *mi_req;\n\tu8 *mi_resp;\n\tint res;\n\n\tmi_req = alloc_smp_req(MI_REQ_SIZE);\n\tif (!mi_req)\n\t\treturn -ENOMEM;\n\n\tmi_resp = alloc_smp_resp(MI_RESP_SIZE);\n\tif (!mi_resp) {\n\t\tkfree(mi_req);\n\t\treturn -ENOMEM;\n\t}\n\n\tmi_req[1] = SMP_REPORT_MANUF_INFO;\n\n\tres = smp_execute_task(dev, mi_req, MI_REQ_SIZE, mi_resp,MI_RESP_SIZE);\n\tif (res) {\n\t\tSAS_DPRINTK(\"MI: ex %016llx failed:0x%x\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), res);\n\t\tgoto out;\n\t} else if (mi_resp[2] != SMP_RESP_FUNC_ACC) {\n\t\tSAS_DPRINTK(\"MI ex %016llx returned SMP result:0x%x\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), mi_resp[2]);\n\t\tgoto out;\n\t}\n\n\tex_assign_manuf_info(dev, mi_resp);\nout:\n\tkfree(mi_req);\n\tkfree(mi_resp);\n\treturn res;\n}\n\n#define PC_REQ_SIZE  44\n#define PC_RESP_SIZE 8\n\nint sas_smp_phy_control(struct domain_device *dev, int phy_id,\n\t\t\tenum phy_func phy_func,\n\t\t\tstruct sas_phy_linkrates *rates)\n{\n\tu8 *pc_req;\n\tu8 *pc_resp;\n\tint res;\n\n\tpc_req = alloc_smp_req(PC_REQ_SIZE);\n\tif (!pc_req)\n\t\treturn -ENOMEM;\n\n\tpc_resp = alloc_smp_resp(PC_RESP_SIZE);\n\tif (!pc_resp) {\n\t\tkfree(pc_req);\n\t\treturn -ENOMEM;\n\t}\n\n\tpc_req[1] = SMP_PHY_CONTROL;\n\tpc_req[9] = phy_id;\n\tpc_req[10]= phy_func;\n\tif (rates) {\n\t\tpc_req[32] = rates->minimum_linkrate << 4;\n\t\tpc_req[33] = rates->maximum_linkrate << 4;\n\t}\n\n\tres = smp_execute_task(dev, pc_req, PC_REQ_SIZE, pc_resp,PC_RESP_SIZE);\n\n\tkfree(pc_resp);\n\tkfree(pc_req);\n\treturn res;\n}\n\nstatic void sas_ex_disable_phy(struct domain_device *dev, int phy_id)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *phy = &ex->ex_phy[phy_id];\n\n\tsas_smp_phy_control(dev, phy_id, PHY_FUNC_DISABLE, NULL);\n\tphy->linkrate = SAS_PHY_DISABLED;\n}\n\nstatic void sas_ex_disable_port(struct domain_device *dev, u8 *sas_addr)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint i;\n\n\tfor (i = 0; i < ex->num_phys; i++) {\n\t\tstruct ex_phy *phy = &ex->ex_phy[i];\n\n\t\tif (phy->phy_state == PHY_VACANT ||\n\t\t    phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif (SAS_ADDR(phy->attached_sas_addr) == SAS_ADDR(sas_addr))\n\t\t\tsas_ex_disable_phy(dev, i);\n\t}\n}\n\nstatic int sas_dev_present_in_domain(struct asd_sas_port *port,\n\t\t\t\t\t    u8 *sas_addr)\n{\n\tstruct domain_device *dev;\n\n\tif (SAS_ADDR(port->sas_addr) == SAS_ADDR(sas_addr))\n\t\treturn 1;\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\tif (SAS_ADDR(dev->sas_addr) == SAS_ADDR(sas_addr))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n#define RPEL_REQ_SIZE\t16\n#define RPEL_RESP_SIZE\t32\nint sas_smp_get_phy_events(struct sas_phy *phy)\n{\n\tint res;\n\tu8 *req;\n\tu8 *resp;\n\tstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\n\tstruct domain_device *dev = sas_find_dev_by_rphy(rphy);\n\n\treq = alloc_smp_req(RPEL_REQ_SIZE);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tresp = alloc_smp_resp(RPEL_RESP_SIZE);\n\tif (!resp) {\n\t\tkfree(req);\n\t\treturn -ENOMEM;\n\t}\n\n\treq[1] = SMP_REPORT_PHY_ERR_LOG;\n\treq[9] = phy->number;\n\n\tres = smp_execute_task(dev, req, RPEL_REQ_SIZE,\n\t\t\t            resp, RPEL_RESP_SIZE);\n\n\tif (res)\n\t\tgoto out;\n\n\tphy->invalid_dword_count = scsi_to_u32(&resp[12]);\n\tphy->running_disparity_error_count = scsi_to_u32(&resp[16]);\n\tphy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);\n\tphy->phy_reset_problem_count = scsi_to_u32(&resp[24]);\n\n out:\n\tkfree(req);\n\tkfree(resp);\n\treturn res;\n\n}\n\n#ifdef CONFIG_SCSI_SAS_ATA\n\n#define RPS_REQ_SIZE  16\n#define RPS_RESP_SIZE 60\n\nint sas_get_report_phy_sata(struct domain_device *dev, int phy_id,\n\t\t\t    struct smp_resp *rps_resp)\n{\n\tint res;\n\tu8 *rps_req = alloc_smp_req(RPS_REQ_SIZE);\n\tu8 *resp = (u8 *)rps_resp;\n\n\tif (!rps_req)\n\t\treturn -ENOMEM;\n\n\trps_req[1] = SMP_REPORT_PHY_SATA;\n\trps_req[9] = phy_id;\n\n\tres = smp_execute_task(dev, rps_req, RPS_REQ_SIZE,\n\t\t\t            rps_resp, RPS_RESP_SIZE);\n\n\t/* 0x34 is the FIS type for the D2H fis.  There's a potential\n\t * standards cockup here.  sas-2 explicitly specifies the FIS\n\t * should be encoded so that FIS type is in resp[24].\n\t * However, some expanders endian reverse this.  Undo the\n\t * reversal here */\n\tif (!res && resp[27] == 0x34 && resp[24] != 0x34) {\n\t\tint i;\n\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tint j = 24 + (i*4);\n\t\t\tu8 a, b;\n\t\t\ta = resp[j + 0];\n\t\t\tb = resp[j + 1];\n\t\t\tresp[j + 0] = resp[j + 3];\n\t\t\tresp[j + 1] = resp[j + 2];\n\t\t\tresp[j + 2] = b;\n\t\t\tresp[j + 3] = a;\n\t\t}\n\t}\n\n\tkfree(rps_req);\n\treturn res;\n}\n#endif\n\nstatic void sas_ex_get_linkrate(struct domain_device *parent,\n\t\t\t\t       struct domain_device *child,\n\t\t\t\t       struct ex_phy *parent_phy)\n{\n\tstruct expander_device *parent_ex = &parent->ex_dev;\n\tstruct sas_port *port;\n\tint i;\n\n\tchild->pathways = 0;\n\n\tport = parent_phy->port;\n\n\tfor (i = 0; i < parent_ex->num_phys; i++) {\n\t\tstruct ex_phy *phy = &parent_ex->ex_phy[i];\n\n\t\tif (phy->phy_state == PHY_VACANT ||\n\t\t    phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif (SAS_ADDR(phy->attached_sas_addr) ==\n\t\t    SAS_ADDR(child->sas_addr)) {\n\n\t\t\tchild->min_linkrate = min(parent->min_linkrate,\n\t\t\t\t\t\t  phy->linkrate);\n\t\t\tchild->max_linkrate = max(parent->max_linkrate,\n\t\t\t\t\t\t  phy->linkrate);\n\t\t\tchild->pathways++;\n\t\t\tsas_port_add_phy(port, phy->phy);\n\t\t}\n\t}\n\tchild->linkrate = min(parent_phy->linkrate, child->max_linkrate);\n\tchild->pathways = min(child->pathways, parent->pathways);\n}\n\nstatic struct domain_device *sas_ex_discover_end_dev(\n\tstruct domain_device *parent, int phy_id)\n{\n\tstruct expander_device *parent_ex = &parent->ex_dev;\n\tstruct ex_phy *phy = &parent_ex->ex_phy[phy_id];\n\tstruct domain_device *child = NULL;\n\tstruct sas_rphy *rphy;\n\tint res;\n\n\tif (phy->attached_sata_host || phy->attached_sata_ps)\n\t\treturn NULL;\n\n\tchild = sas_alloc_device();\n\tif (!child)\n\t\treturn NULL;\n\n\tkref_get(&parent->kref);\n\tchild->parent = parent;\n\tchild->port   = parent->port;\n\tchild->iproto = phy->attached_iproto;\n\tmemcpy(child->sas_addr, phy->attached_sas_addr, SAS_ADDR_SIZE);\n\tsas_hash_addr(child->hashed_sas_addr, child->sas_addr);\n\tif (!phy->port) {\n\t\tphy->port = sas_port_alloc(&parent->rphy->dev, phy_id);\n\t\tif (unlikely(!phy->port))\n\t\t\tgoto out_err;\n\t\tif (unlikely(sas_port_add(phy->port) != 0)) {\n\t\t\tsas_port_free(phy->port);\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\tsas_ex_get_linkrate(parent, child, phy);\n\tsas_device_set_phy(child, phy->port);\n\n#ifdef CONFIG_SCSI_SAS_ATA\n\tif ((phy->attached_tproto & SAS_PROTOCOL_STP) || phy->attached_sata_dev) {\n\t\tres = sas_get_ata_info(child, phy);\n\t\tif (res)\n\t\t\tgoto out_free;\n\n\t\tsas_init_dev(child);\n\t\tres = sas_ata_init(child);\n\t\tif (res)\n\t\t\tgoto out_free;\n\t\trphy = sas_end_device_alloc(phy->port);\n\t\tif (!rphy)\n\t\t\tgoto out_free;\n\n\t\tchild->rphy = rphy;\n\t\tget_device(&rphy->dev);\n\n\t\tlist_add_tail(&child->disco_list_node, &parent->port->disco_list);\n\n\t\tres = sas_discover_sata(child);\n\t\tif (res) {\n\t\t\tSAS_DPRINTK(\"sas_discover_sata() for device %16llx at \"\n\t\t\t\t    \"%016llx:0x%x returned 0x%x\\n\",\n\t\t\t\t    SAS_ADDR(child->sas_addr),\n\t\t\t\t    SAS_ADDR(parent->sas_addr), phy_id, res);\n\t\t\tgoto out_list_del;\n\t\t}\n\t} else\n#endif\n\t  if (phy->attached_tproto & SAS_PROTOCOL_SSP) {\n\t\tchild->dev_type = SAS_END_DEVICE;\n\t\trphy = sas_end_device_alloc(phy->port);\n\t\t/* FIXME: error handling */\n\t\tif (unlikely(!rphy))\n\t\t\tgoto out_free;\n\t\tchild->tproto = phy->attached_tproto;\n\t\tsas_init_dev(child);\n\n\t\tchild->rphy = rphy;\n\t\tget_device(&rphy->dev);\n\t\tsas_fill_in_rphy(child, rphy);\n\n\t\tlist_add_tail(&child->disco_list_node, &parent->port->disco_list);\n\n\t\tres = sas_discover_end_dev(child);\n\t\tif (res) {\n\t\t\tSAS_DPRINTK(\"sas_discover_end_dev() for device %16llx \"\n\t\t\t\t    \"at %016llx:0x%x returned 0x%x\\n\",\n\t\t\t\t    SAS_ADDR(child->sas_addr),\n\t\t\t\t    SAS_ADDR(parent->sas_addr), phy_id, res);\n\t\t\tgoto out_list_del;\n\t\t}\n\t} else {\n\t\tSAS_DPRINTK(\"target proto 0x%x at %016llx:0x%x not handled\\n\",\n\t\t\t    phy->attached_tproto, SAS_ADDR(parent->sas_addr),\n\t\t\t    phy_id);\n\t\tgoto out_free;\n\t}\n\n\tlist_add_tail(&child->siblings, &parent_ex->children);\n\treturn child;\n\n out_list_del:\n\tsas_rphy_free(child->rphy);\n\tlist_del(&child->disco_list_node);\n\tspin_lock_irq(&parent->port->dev_list_lock);\n\tlist_del(&child->dev_list_node);\n\tspin_unlock_irq(&parent->port->dev_list_lock);\n out_free:\n\tsas_port_delete(phy->port);\n out_err:\n\tphy->port = NULL;\n\tsas_put_device(child);\n\treturn NULL;\n}\n\n/* See if this phy is part of a wide port */\nstatic bool sas_ex_join_wide_port(struct domain_device *parent, int phy_id)\n{\n\tstruct ex_phy *phy = &parent->ex_dev.ex_phy[phy_id];\n\tint i;\n\n\tfor (i = 0; i < parent->ex_dev.num_phys; i++) {\n\t\tstruct ex_phy *ephy = &parent->ex_dev.ex_phy[i];\n\n\t\tif (ephy == phy)\n\t\t\tcontinue;\n\n\t\tif (!memcmp(phy->attached_sas_addr, ephy->attached_sas_addr,\n\t\t\t    SAS_ADDR_SIZE) && ephy->port) {\n\t\t\tsas_port_add_phy(ephy->port, phy->phy);\n\t\t\tphy->port = ephy->port;\n\t\t\tphy->phy_state = PHY_DEVICE_DISCOVERED;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic struct domain_device *sas_ex_discover_expander(\n\tstruct domain_device *parent, int phy_id)\n{\n\tstruct sas_expander_device *parent_ex = rphy_to_expander_device(parent->rphy);\n\tstruct ex_phy *phy = &parent->ex_dev.ex_phy[phy_id];\n\tstruct domain_device *child = NULL;\n\tstruct sas_rphy *rphy;\n\tstruct sas_expander_device *edev;\n\tstruct asd_sas_port *port;\n\tint res;\n\n\tif (phy->routing_attr == DIRECT_ROUTING) {\n\t\tSAS_DPRINTK(\"ex %016llx:0x%x:D <--> ex %016llx:0x%x is not \"\n\t\t\t    \"allowed\\n\",\n\t\t\t    SAS_ADDR(parent->sas_addr), phy_id,\n\t\t\t    SAS_ADDR(phy->attached_sas_addr),\n\t\t\t    phy->attached_phy_id);\n\t\treturn NULL;\n\t}\n\tchild = sas_alloc_device();\n\tif (!child)\n\t\treturn NULL;\n\n\tphy->port = sas_port_alloc(&parent->rphy->dev, phy_id);\n\t/* FIXME: better error handling */\n\tBUG_ON(sas_port_add(phy->port) != 0);\n\n\n\tswitch (phy->attached_dev_type) {\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\trphy = sas_expander_alloc(phy->port,\n\t\t\t\t\t  SAS_EDGE_EXPANDER_DEVICE);\n\t\tbreak;\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\trphy = sas_expander_alloc(phy->port,\n\t\t\t\t\t  SAS_FANOUT_EXPANDER_DEVICE);\n\t\tbreak;\n\tdefault:\n\t\trphy = NULL;\t/* shut gcc up */\n\t\tBUG();\n\t}\n\tport = parent->port;\n\tchild->rphy = rphy;\n\tget_device(&rphy->dev);\n\tedev = rphy_to_expander_device(rphy);\n\tchild->dev_type = phy->attached_dev_type;\n\tkref_get(&parent->kref);\n\tchild->parent = parent;\n\tchild->port = port;\n\tchild->iproto = phy->attached_iproto;\n\tchild->tproto = phy->attached_tproto;\n\tmemcpy(child->sas_addr, phy->attached_sas_addr, SAS_ADDR_SIZE);\n\tsas_hash_addr(child->hashed_sas_addr, child->sas_addr);\n\tsas_ex_get_linkrate(parent, child, phy);\n\tedev->level = parent_ex->level + 1;\n\tparent->port->disc.max_level = max(parent->port->disc.max_level,\n\t\t\t\t\t   edev->level);\n\tsas_init_dev(child);\n\tsas_fill_in_rphy(child, rphy);\n\tsas_rphy_add(rphy);\n\n\tspin_lock_irq(&parent->port->dev_list_lock);\n\tlist_add_tail(&child->dev_list_node, &parent->port->dev_list);\n\tspin_unlock_irq(&parent->port->dev_list_lock);\n\n\tres = sas_discover_expander(child);\n\tif (res) {\n\t\tsas_rphy_delete(rphy);\n\t\tspin_lock_irq(&parent->port->dev_list_lock);\n\t\tlist_del(&child->dev_list_node);\n\t\tspin_unlock_irq(&parent->port->dev_list_lock);\n\t\tsas_put_device(child);\n\t\treturn NULL;\n\t}\n\tlist_add_tail(&child->siblings, &parent->ex_dev.children);\n\treturn child;\n}\n\nstatic int sas_ex_discover_dev(struct domain_device *dev, int phy_id)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *ex_phy = &ex->ex_phy[phy_id];\n\tstruct domain_device *child = NULL;\n\tint res = 0;\n\n\t/* Phy state */\n\tif (ex_phy->linkrate == SAS_SATA_SPINUP_HOLD) {\n\t\tif (!sas_smp_phy_control(dev, phy_id, PHY_FUNC_LINK_RESET, NULL))\n\t\t\tres = sas_ex_phy_discover(dev, phy_id);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\t/* Parent and domain coherency */\n\tif (!dev->parent && (SAS_ADDR(ex_phy->attached_sas_addr) ==\n\t\t\t     SAS_ADDR(dev->port->sas_addr))) {\n\t\tsas_add_parent_port(dev, phy_id);\n\t\treturn 0;\n\t}\n\tif (dev->parent && (SAS_ADDR(ex_phy->attached_sas_addr) ==\n\t\t\t    SAS_ADDR(dev->parent->sas_addr))) {\n\t\tsas_add_parent_port(dev, phy_id);\n\t\tif (ex_phy->routing_attr == TABLE_ROUTING)\n\t\t\tsas_configure_phy(dev, phy_id, dev->port->sas_addr, 1);\n\t\treturn 0;\n\t}\n\n\tif (sas_dev_present_in_domain(dev->port, ex_phy->attached_sas_addr))\n\t\tsas_ex_disable_port(dev, ex_phy->attached_sas_addr);\n\n\tif (ex_phy->attached_dev_type == SAS_PHY_UNUSED) {\n\t\tif (ex_phy->routing_attr == DIRECT_ROUTING) {\n\t\t\tmemset(ex_phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\t\t\tsas_configure_routing(dev, ex_phy->attached_sas_addr);\n\t\t}\n\t\treturn 0;\n\t} else if (ex_phy->linkrate == SAS_LINK_RATE_UNKNOWN)\n\t\treturn 0;\n\n\tif (ex_phy->attached_dev_type != SAS_END_DEVICE &&\n\t    ex_phy->attached_dev_type != SAS_FANOUT_EXPANDER_DEVICE &&\n\t    ex_phy->attached_dev_type != SAS_EDGE_EXPANDER_DEVICE &&\n\t    ex_phy->attached_dev_type != SAS_SATA_PENDING) {\n\t\tSAS_DPRINTK(\"unknown device type(0x%x) attached to ex %016llx \"\n\t\t\t    \"phy 0x%x\\n\", ex_phy->attached_dev_type,\n\t\t\t    SAS_ADDR(dev->sas_addr),\n\t\t\t    phy_id);\n\t\treturn 0;\n\t}\n\n\tres = sas_configure_routing(dev, ex_phy->attached_sas_addr);\n\tif (res) {\n\t\tSAS_DPRINTK(\"configure routing for dev %016llx \"\n\t\t\t    \"reported 0x%x. Forgotten\\n\",\n\t\t\t    SAS_ADDR(ex_phy->attached_sas_addr), res);\n\t\tsas_disable_routing(dev, ex_phy->attached_sas_addr);\n\t\treturn res;\n\t}\n\n\tif (sas_ex_join_wide_port(dev, phy_id)) {\n\t\tSAS_DPRINTK(\"Attaching ex phy%d to wide port %016llx\\n\",\n\t\t\t    phy_id, SAS_ADDR(ex_phy->attached_sas_addr));\n\t\treturn res;\n\t}\n\n\tswitch (ex_phy->attached_dev_type) {\n\tcase SAS_END_DEVICE:\n\tcase SAS_SATA_PENDING:\n\t\tchild = sas_ex_discover_end_dev(dev, phy_id);\n\t\tbreak;\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\tif (SAS_ADDR(dev->port->disc.fanout_sas_addr)) {\n\t\t\tSAS_DPRINTK(\"second fanout expander %016llx phy 0x%x \"\n\t\t\t\t    \"attached to ex %016llx phy 0x%x\\n\",\n\t\t\t\t    SAS_ADDR(ex_phy->attached_sas_addr),\n\t\t\t\t    ex_phy->attached_phy_id,\n\t\t\t\t    SAS_ADDR(dev->sas_addr),\n\t\t\t\t    phy_id);\n\t\t\tsas_ex_disable_phy(dev, phy_id);\n\t\t\tbreak;\n\t\t} else\n\t\t\tmemcpy(dev->port->disc.fanout_sas_addr,\n\t\t\t       ex_phy->attached_sas_addr, SAS_ADDR_SIZE);\n\t\t/* fallthrough */\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\tchild = sas_ex_discover_expander(dev, phy_id);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (child) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ex->num_phys; i++) {\n\t\t\tif (ex->ex_phy[i].phy_state == PHY_VACANT ||\n\t\t\t    ex->ex_phy[i].phy_state == PHY_NOT_PRESENT)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Due to races, the phy might not get added to the\n\t\t\t * wide port, so we add the phy to the wide port here.\n\t\t\t */\n\t\t\tif (SAS_ADDR(ex->ex_phy[i].attached_sas_addr) ==\n\t\t\t    SAS_ADDR(child->sas_addr)) {\n\t\t\t\tex->ex_phy[i].phy_state= PHY_DEVICE_DISCOVERED;\n\t\t\t\tif (sas_ex_join_wide_port(dev, i))\n\t\t\t\t\tSAS_DPRINTK(\"Attaching ex phy%d to wide port %016llx\\n\",\n\t\t\t\t\t\t    i, SAS_ADDR(ex->ex_phy[i].attached_sas_addr));\n\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic int sas_find_sub_addr(struct domain_device *dev, u8 *sub_addr)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint i;\n\n\tfor (i = 0; i < ex->num_phys; i++) {\n\t\tstruct ex_phy *phy = &ex->ex_phy[i];\n\n\t\tif (phy->phy_state == PHY_VACANT ||\n\t\t    phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif ((phy->attached_dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t     phy->attached_dev_type == SAS_FANOUT_EXPANDER_DEVICE) &&\n\t\t    phy->routing_attr == SUBTRACTIVE_ROUTING) {\n\n\t\t\tmemcpy(sub_addr, phy->attached_sas_addr,SAS_ADDR_SIZE);\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int sas_check_level_subtractive_boundary(struct domain_device *dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct domain_device *child;\n\tu8 sub_addr[8] = {0, };\n\n\tlist_for_each_entry(child, &ex->children, siblings) {\n\t\tif (child->dev_type != SAS_EDGE_EXPANDER_DEVICE &&\n\t\t    child->dev_type != SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\tcontinue;\n\t\tif (sub_addr[0] == 0) {\n\t\t\tsas_find_sub_addr(child, sub_addr);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tu8 s2[8];\n\n\t\t\tif (sas_find_sub_addr(child, s2) &&\n\t\t\t    (SAS_ADDR(sub_addr) != SAS_ADDR(s2))) {\n\n\t\t\t\tSAS_DPRINTK(\"ex %016llx->%016llx-?->%016llx \"\n\t\t\t\t\t    \"diverges from subtractive \"\n\t\t\t\t\t    \"boundary %016llx\\n\",\n\t\t\t\t\t    SAS_ADDR(dev->sas_addr),\n\t\t\t\t\t    SAS_ADDR(child->sas_addr),\n\t\t\t\t\t    SAS_ADDR(s2),\n\t\t\t\t\t    SAS_ADDR(sub_addr));\n\n\t\t\t\tsas_ex_disable_port(child, s2);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n/**\n * sas_ex_discover_devices -- discover devices attached to this expander\n * dev: pointer to the expander domain device\n * single: if you want to do a single phy, else set to -1;\n *\n * Configure this expander for use with its devices and register the\n * devices of this expander.\n */\nstatic int sas_ex_discover_devices(struct domain_device *dev, int single)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint i = 0, end = ex->num_phys;\n\tint res = 0;\n\n\tif (0 <= single && single < end) {\n\t\ti = single;\n\t\tend = i+1;\n\t}\n\n\tfor ( ; i < end; i++) {\n\t\tstruct ex_phy *ex_phy = &ex->ex_phy[i];\n\n\t\tif (ex_phy->phy_state == PHY_VACANT ||\n\t\t    ex_phy->phy_state == PHY_NOT_PRESENT ||\n\t\t    ex_phy->phy_state == PHY_DEVICE_DISCOVERED)\n\t\t\tcontinue;\n\n\t\tswitch (ex_phy->linkrate) {\n\t\tcase SAS_PHY_DISABLED:\n\t\tcase SAS_PHY_RESET_PROBLEM:\n\t\tcase SAS_SATA_PORT_SELECTOR:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tres = sas_ex_discover_dev(dev, i);\n\t\t\tif (res)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tif (!res)\n\t\tsas_check_level_subtractive_boundary(dev);\n\n\treturn res;\n}\n\nstatic int sas_check_ex_subtractive_boundary(struct domain_device *dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint i;\n\tu8  *sub_sas_addr = NULL;\n\n\tif (dev->dev_type != SAS_EDGE_EXPANDER_DEVICE)\n\t\treturn 0;\n\n\tfor (i = 0; i < ex->num_phys; i++) {\n\t\tstruct ex_phy *phy = &ex->ex_phy[i];\n\n\t\tif (phy->phy_state == PHY_VACANT ||\n\t\t    phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif ((phy->attached_dev_type == SAS_FANOUT_EXPANDER_DEVICE ||\n\t\t     phy->attached_dev_type == SAS_EDGE_EXPANDER_DEVICE) &&\n\t\t    phy->routing_attr == SUBTRACTIVE_ROUTING) {\n\n\t\t\tif (!sub_sas_addr)\n\t\t\t\tsub_sas_addr = &phy->attached_sas_addr[0];\n\t\t\telse if (SAS_ADDR(sub_sas_addr) !=\n\t\t\t\t SAS_ADDR(phy->attached_sas_addr)) {\n\n\t\t\t\tSAS_DPRINTK(\"ex %016llx phy 0x%x \"\n\t\t\t\t\t    \"diverges(%016llx) on subtractive \"\n\t\t\t\t\t    \"boundary(%016llx). Disabled\\n\",\n\t\t\t\t\t    SAS_ADDR(dev->sas_addr), i,\n\t\t\t\t\t    SAS_ADDR(phy->attached_sas_addr),\n\t\t\t\t\t    SAS_ADDR(sub_sas_addr));\n\t\t\t\tsas_ex_disable_phy(dev, i);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void sas_print_parent_topology_bug(struct domain_device *child,\n\t\t\t\t\t\t struct ex_phy *parent_phy,\n\t\t\t\t\t\t struct ex_phy *child_phy)\n{\n\tstatic const char *ex_type[] = {\n\t\t[SAS_EDGE_EXPANDER_DEVICE] = \"edge\",\n\t\t[SAS_FANOUT_EXPANDER_DEVICE] = \"fanout\",\n\t};\n\tstruct domain_device *parent = child->parent;\n\n\tsas_printk(\"%s ex %016llx phy 0x%x <--> %s ex %016llx \"\n\t\t   \"phy 0x%x has %c:%c routing link!\\n\",\n\n\t\t   ex_type[parent->dev_type],\n\t\t   SAS_ADDR(parent->sas_addr),\n\t\t   parent_phy->phy_id,\n\n\t\t   ex_type[child->dev_type],\n\t\t   SAS_ADDR(child->sas_addr),\n\t\t   child_phy->phy_id,\n\n\t\t   sas_route_char(parent, parent_phy),\n\t\t   sas_route_char(child, child_phy));\n}\n\nstatic int sas_check_eeds(struct domain_device *child,\n\t\t\t\t struct ex_phy *parent_phy,\n\t\t\t\t struct ex_phy *child_phy)\n{\n\tint res = 0;\n\tstruct domain_device *parent = child->parent;\n\n\tif (SAS_ADDR(parent->port->disc.fanout_sas_addr) != 0) {\n\t\tres = -ENODEV;\n\t\tSAS_DPRINTK(\"edge ex %016llx phy S:0x%x <--> edge ex %016llx \"\n\t\t\t    \"phy S:0x%x, while there is a fanout ex %016llx\\n\",\n\t\t\t    SAS_ADDR(parent->sas_addr),\n\t\t\t    parent_phy->phy_id,\n\t\t\t    SAS_ADDR(child->sas_addr),\n\t\t\t    child_phy->phy_id,\n\t\t\t    SAS_ADDR(parent->port->disc.fanout_sas_addr));\n\t} else if (SAS_ADDR(parent->port->disc.eeds_a) == 0) {\n\t\tmemcpy(parent->port->disc.eeds_a, parent->sas_addr,\n\t\t       SAS_ADDR_SIZE);\n\t\tmemcpy(parent->port->disc.eeds_b, child->sas_addr,\n\t\t       SAS_ADDR_SIZE);\n\t} else if (((SAS_ADDR(parent->port->disc.eeds_a) ==\n\t\t    SAS_ADDR(parent->sas_addr)) ||\n\t\t   (SAS_ADDR(parent->port->disc.eeds_a) ==\n\t\t    SAS_ADDR(child->sas_addr)))\n\t\t   &&\n\t\t   ((SAS_ADDR(parent->port->disc.eeds_b) ==\n\t\t     SAS_ADDR(parent->sas_addr)) ||\n\t\t    (SAS_ADDR(parent->port->disc.eeds_b) ==\n\t\t     SAS_ADDR(child->sas_addr))))\n\t\t;\n\telse {\n\t\tres = -ENODEV;\n\t\tSAS_DPRINTK(\"edge ex %016llx phy 0x%x <--> edge ex %016llx \"\n\t\t\t    \"phy 0x%x link forms a third EEDS!\\n\",\n\t\t\t    SAS_ADDR(parent->sas_addr),\n\t\t\t    parent_phy->phy_id,\n\t\t\t    SAS_ADDR(child->sas_addr),\n\t\t\t    child_phy->phy_id);\n\t}\n\n\treturn res;\n}\n\n/* Here we spill over 80 columns.  It is intentional.\n */\nstatic int sas_check_parent_topology(struct domain_device *child)\n{\n\tstruct expander_device *child_ex = &child->ex_dev;\n\tstruct expander_device *parent_ex;\n\tint i;\n\tint res = 0;\n\n\tif (!child->parent)\n\t\treturn 0;\n\n\tif (child->parent->dev_type != SAS_EDGE_EXPANDER_DEVICE &&\n\t    child->parent->dev_type != SAS_FANOUT_EXPANDER_DEVICE)\n\t\treturn 0;\n\n\tparent_ex = &child->parent->ex_dev;\n\n\tfor (i = 0; i < parent_ex->num_phys; i++) {\n\t\tstruct ex_phy *parent_phy = &parent_ex->ex_phy[i];\n\t\tstruct ex_phy *child_phy;\n\n\t\tif (parent_phy->phy_state == PHY_VACANT ||\n\t\t    parent_phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif (SAS_ADDR(parent_phy->attached_sas_addr) != SAS_ADDR(child->sas_addr))\n\t\t\tcontinue;\n\n\t\tchild_phy = &child_ex->ex_phy[parent_phy->attached_phy_id];\n\n\t\tswitch (child->parent->dev_type) {\n\t\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\t\tif (child->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\t\t\tif (parent_phy->routing_attr != SUBTRACTIVE_ROUTING ||\n\t\t\t\t    child_phy->routing_attr != TABLE_ROUTING) {\n\t\t\t\t\tsas_print_parent_topology_bug(child, parent_phy, child_phy);\n\t\t\t\t\tres = -ENODEV;\n\t\t\t\t}\n\t\t\t} else if (parent_phy->routing_attr == SUBTRACTIVE_ROUTING) {\n\t\t\t\tif (child_phy->routing_attr == SUBTRACTIVE_ROUTING) {\n\t\t\t\t\tres = sas_check_eeds(child, parent_phy, child_phy);\n\t\t\t\t} else if (child_phy->routing_attr != TABLE_ROUTING) {\n\t\t\t\t\tsas_print_parent_topology_bug(child, parent_phy, child_phy);\n\t\t\t\t\tres = -ENODEV;\n\t\t\t\t}\n\t\t\t} else if (parent_phy->routing_attr == TABLE_ROUTING) {\n\t\t\t\tif (child_phy->routing_attr == SUBTRACTIVE_ROUTING ||\n\t\t\t\t    (child_phy->routing_attr == TABLE_ROUTING &&\n\t\t\t\t     child_ex->t2t_supp && parent_ex->t2t_supp)) {\n\t\t\t\t\t/* All good */;\n\t\t\t\t} else {\n\t\t\t\t\tsas_print_parent_topology_bug(child, parent_phy, child_phy);\n\t\t\t\t\tres = -ENODEV;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\t\tif (parent_phy->routing_attr != TABLE_ROUTING ||\n\t\t\t    child_phy->routing_attr != SUBTRACTIVE_ROUTING) {\n\t\t\t\tsas_print_parent_topology_bug(child, parent_phy, child_phy);\n\t\t\t\tres = -ENODEV;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n#define RRI_REQ_SIZE  16\n#define RRI_RESP_SIZE 44\n\nstatic int sas_configure_present(struct domain_device *dev, int phy_id,\n\t\t\t\t u8 *sas_addr, int *index, int *present)\n{\n\tint i, res = 0;\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *phy = &ex->ex_phy[phy_id];\n\tu8 *rri_req;\n\tu8 *rri_resp;\n\n\t*present = 0;\n\t*index = 0;\n\n\trri_req = alloc_smp_req(RRI_REQ_SIZE);\n\tif (!rri_req)\n\t\treturn -ENOMEM;\n\n\trri_resp = alloc_smp_resp(RRI_RESP_SIZE);\n\tif (!rri_resp) {\n\t\tkfree(rri_req);\n\t\treturn -ENOMEM;\n\t}\n\n\trri_req[1] = SMP_REPORT_ROUTE_INFO;\n\trri_req[9] = phy_id;\n\n\tfor (i = 0; i < ex->max_route_indexes ; i++) {\n\t\t*(__be16 *)(rri_req+6) = cpu_to_be16(i);\n\t\tres = smp_execute_task(dev, rri_req, RRI_REQ_SIZE, rri_resp,\n\t\t\t\t       RRI_RESP_SIZE);\n\t\tif (res)\n\t\t\tgoto out;\n\t\tres = rri_resp[2];\n\t\tif (res == SMP_RESP_NO_INDEX) {\n\t\t\tSAS_DPRINTK(\"overflow of indexes: dev %016llx \"\n\t\t\t\t    \"phy 0x%x index 0x%x\\n\",\n\t\t\t\t    SAS_ADDR(dev->sas_addr), phy_id, i);\n\t\t\tgoto out;\n\t\t} else if (res != SMP_RESP_FUNC_ACC) {\n\t\t\tSAS_DPRINTK(\"%s: dev %016llx phy 0x%x index 0x%x \"\n\t\t\t\t    \"result 0x%x\\n\", __func__,\n\t\t\t\t    SAS_ADDR(dev->sas_addr), phy_id, i, res);\n\t\t\tgoto out;\n\t\t}\n\t\tif (SAS_ADDR(sas_addr) != 0) {\n\t\t\tif (SAS_ADDR(rri_resp+16) == SAS_ADDR(sas_addr)) {\n\t\t\t\t*index = i;\n\t\t\t\tif ((rri_resp[12] & 0x80) == 0x80)\n\t\t\t\t\t*present = 0;\n\t\t\t\telse\n\t\t\t\t\t*present = 1;\n\t\t\t\tgoto out;\n\t\t\t} else if (SAS_ADDR(rri_resp+16) == 0) {\n\t\t\t\t*index = i;\n\t\t\t\t*present = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if (SAS_ADDR(rri_resp+16) == 0 &&\n\t\t\t   phy->last_da_index < i) {\n\t\t\tphy->last_da_index = i;\n\t\t\t*index = i;\n\t\t\t*present = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tres = -1;\nout:\n\tkfree(rri_req);\n\tkfree(rri_resp);\n\treturn res;\n}\n\n#define CRI_REQ_SIZE  44\n#define CRI_RESP_SIZE  8\n\nstatic int sas_configure_set(struct domain_device *dev, int phy_id,\n\t\t\t     u8 *sas_addr, int index, int include)\n{\n\tint res;\n\tu8 *cri_req;\n\tu8 *cri_resp;\n\n\tcri_req = alloc_smp_req(CRI_REQ_SIZE);\n\tif (!cri_req)\n\t\treturn -ENOMEM;\n\n\tcri_resp = alloc_smp_resp(CRI_RESP_SIZE);\n\tif (!cri_resp) {\n\t\tkfree(cri_req);\n\t\treturn -ENOMEM;\n\t}\n\n\tcri_req[1] = SMP_CONF_ROUTE_INFO;\n\t*(__be16 *)(cri_req+6) = cpu_to_be16(index);\n\tcri_req[9] = phy_id;\n\tif (SAS_ADDR(sas_addr) == 0 || !include)\n\t\tcri_req[12] |= 0x80;\n\tmemcpy(cri_req+16, sas_addr, SAS_ADDR_SIZE);\n\n\tres = smp_execute_task(dev, cri_req, CRI_REQ_SIZE, cri_resp,\n\t\t\t       CRI_RESP_SIZE);\n\tif (res)\n\t\tgoto out;\n\tres = cri_resp[2];\n\tif (res == SMP_RESP_NO_INDEX) {\n\t\tSAS_DPRINTK(\"overflow of indexes: dev %016llx phy 0x%x \"\n\t\t\t    \"index 0x%x\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), phy_id, index);\n\t}\nout:\n\tkfree(cri_req);\n\tkfree(cri_resp);\n\treturn res;\n}\n\nstatic int sas_configure_phy(struct domain_device *dev, int phy_id,\n\t\t\t\t    u8 *sas_addr, int include)\n{\n\tint index;\n\tint present;\n\tint res;\n\n\tres = sas_configure_present(dev, phy_id, sas_addr, &index, &present);\n\tif (res)\n\t\treturn res;\n\tif (include ^ present)\n\t\treturn sas_configure_set(dev, phy_id, sas_addr, index,include);\n\n\treturn res;\n}\n\n/**\n * sas_configure_parent -- configure routing table of parent\n * parent: parent expander\n * child: child expander\n * sas_addr: SAS port identifier of device directly attached to child\n */\nstatic int sas_configure_parent(struct domain_device *parent,\n\t\t\t\tstruct domain_device *child,\n\t\t\t\tu8 *sas_addr, int include)\n{\n\tstruct expander_device *ex_parent = &parent->ex_dev;\n\tint res = 0;\n\tint i;\n\n\tif (parent->parent) {\n\t\tres = sas_configure_parent(parent->parent, parent, sas_addr,\n\t\t\t\t\t   include);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tif (ex_parent->conf_route_table == 0) {\n\t\tSAS_DPRINTK(\"ex %016llx has self-configuring routing table\\n\",\n\t\t\t    SAS_ADDR(parent->sas_addr));\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < ex_parent->num_phys; i++) {\n\t\tstruct ex_phy *phy = &ex_parent->ex_phy[i];\n\n\t\tif ((phy->routing_attr == TABLE_ROUTING) &&\n\t\t    (SAS_ADDR(phy->attached_sas_addr) ==\n\t\t     SAS_ADDR(child->sas_addr))) {\n\t\t\tres = sas_configure_phy(parent, i, sas_addr, include);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n/**\n * sas_configure_routing -- configure routing\n * dev: expander device\n * sas_addr: port identifier of device directly attached to the expander device\n */\nstatic int sas_configure_routing(struct domain_device *dev, u8 *sas_addr)\n{\n\tif (dev->parent)\n\t\treturn sas_configure_parent(dev->parent, dev, sas_addr, 1);\n\treturn 0;\n}\n\nstatic int sas_disable_routing(struct domain_device *dev,  u8 *sas_addr)\n{\n\tif (dev->parent)\n\t\treturn sas_configure_parent(dev->parent, dev, sas_addr, 0);\n\treturn 0;\n}\n\n/**\n * sas_discover_expander -- expander discovery\n * @ex: pointer to expander domain device\n *\n * See comment in sas_discover_sata().\n */\nstatic int sas_discover_expander(struct domain_device *dev)\n{\n\tint res;\n\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\n\tres = sas_ex_general(dev);\n\tif (res)\n\t\tgoto out_err;\n\tres = sas_ex_manuf_info(dev);\n\tif (res)\n\t\tgoto out_err;\n\n\tres = sas_expander_discover(dev);\n\tif (res) {\n\t\tSAS_DPRINTK(\"expander %016llx discovery failed(0x%x)\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), res);\n\t\tgoto out_err;\n\t}\n\n\tsas_check_ex_subtractive_boundary(dev);\n\tres = sas_check_parent_topology(dev);\n\tif (res)\n\t\tgoto out_err;\n\treturn 0;\nout_err:\n\tsas_notify_lldd_dev_gone(dev);\n\treturn res;\n}\n\nstatic int sas_ex_level_discovery(struct asd_sas_port *port, const int level)\n{\n\tint res = 0;\n\tstruct domain_device *dev;\n\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\tif (dev->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t    dev->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\t\tstruct sas_expander_device *ex =\n\t\t\t\trphy_to_expander_device(dev->rphy);\n\n\t\t\tif (level == ex->level)\n\t\t\t\tres = sas_ex_discover_devices(dev, -1);\n\t\t\telse if (level > 0)\n\t\t\t\tres = sas_ex_discover_devices(port->port_dev, -1);\n\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic int sas_ex_bfs_disc(struct asd_sas_port *port)\n{\n\tint res;\n\tint level;\n\n\tdo {\n\t\tlevel = port->disc.max_level;\n\t\tres = sas_ex_level_discovery(port, level);\n\t\tmb();\n\t} while (level < port->disc.max_level);\n\n\treturn res;\n}\n\nint sas_discover_root_expander(struct domain_device *dev)\n{\n\tint res;\n\tstruct sas_expander_device *ex = rphy_to_expander_device(dev->rphy);\n\n\tres = sas_rphy_add(dev->rphy);\n\tif (res)\n\t\tgoto out_err;\n\n\tex->level = dev->port->disc.max_level; /* 0 */\n\tres = sas_discover_expander(dev);\n\tif (res)\n\t\tgoto out_err2;\n\n\tsas_ex_bfs_disc(dev->port);\n\n\treturn res;\n\nout_err2:\n\tsas_rphy_remove(dev->rphy);\nout_err:\n\treturn res;\n}\n\n/* ---------- Domain revalidation ---------- */\n\nstatic int sas_get_phy_discover(struct domain_device *dev,\n\t\t\t\tint phy_id, struct smp_resp *disc_resp)\n{\n\tint res;\n\tu8 *disc_req;\n\n\tdisc_req = alloc_smp_req(DISCOVER_REQ_SIZE);\n\tif (!disc_req)\n\t\treturn -ENOMEM;\n\n\tdisc_req[1] = SMP_DISCOVER;\n\tdisc_req[9] = phy_id;\n\n\tres = smp_execute_task(dev, disc_req, DISCOVER_REQ_SIZE,\n\t\t\t       disc_resp, DISCOVER_RESP_SIZE);\n\tif (res)\n\t\tgoto out;\n\telse if (disc_resp->result != SMP_RESP_FUNC_ACC) {\n\t\tres = disc_resp->result;\n\t\tgoto out;\n\t}\nout:\n\tkfree(disc_req);\n\treturn res;\n}\n\nstatic int sas_get_phy_change_count(struct domain_device *dev,\n\t\t\t\t    int phy_id, int *pcc)\n{\n\tint res;\n\tstruct smp_resp *disc_resp;\n\n\tdisc_resp = alloc_smp_resp(DISCOVER_RESP_SIZE);\n\tif (!disc_resp)\n\t\treturn -ENOMEM;\n\n\tres = sas_get_phy_discover(dev, phy_id, disc_resp);\n\tif (!res)\n\t\t*pcc = disc_resp->disc.change_count;\n\n\tkfree(disc_resp);\n\treturn res;\n}\n\nstatic int sas_get_phy_attached_dev(struct domain_device *dev, int phy_id,\n\t\t\t\t    u8 *sas_addr, enum sas_device_type *type)\n{\n\tint res;\n\tstruct smp_resp *disc_resp;\n\tstruct discover_resp *dr;\n\n\tdisc_resp = alloc_smp_resp(DISCOVER_RESP_SIZE);\n\tif (!disc_resp)\n\t\treturn -ENOMEM;\n\tdr = &disc_resp->disc;\n\n\tres = sas_get_phy_discover(dev, phy_id, disc_resp);\n\tif (res == 0) {\n\t\tmemcpy(sas_addr, disc_resp->disc.attached_sas_addr, 8);\n\t\t*type = to_dev_type(dr);\n\t\tif (*type == 0)\n\t\t\tmemset(sas_addr, 0, 8);\n\t}\n\tkfree(disc_resp);\n\treturn res;\n}\n\nstatic int sas_find_bcast_phy(struct domain_device *dev, int *phy_id,\n\t\t\t      int from_phy, bool update)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint res = 0;\n\tint i;\n\n\tfor (i = from_phy; i < ex->num_phys; i++) {\n\t\tint phy_change_count = 0;\n\n\t\tres = sas_get_phy_change_count(dev, i, &phy_change_count);\n\t\tswitch (res) {\n\t\tcase SMP_RESP_PHY_VACANT:\n\t\tcase SMP_RESP_NO_PHY:\n\t\t\tcontinue;\n\t\tcase SMP_RESP_FUNC_ACC:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn res;\n\t\t}\n\n\t\tif (phy_change_count != ex->ex_phy[i].phy_change_count) {\n\t\t\tif (update)\n\t\t\t\tex->ex_phy[i].phy_change_count =\n\t\t\t\t\tphy_change_count;\n\t\t\t*phy_id = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int sas_get_ex_change_count(struct domain_device *dev, int *ecc)\n{\n\tint res;\n\tu8  *rg_req;\n\tstruct smp_resp  *rg_resp;\n\n\trg_req = alloc_smp_req(RG_REQ_SIZE);\n\tif (!rg_req)\n\t\treturn -ENOMEM;\n\n\trg_resp = alloc_smp_resp(RG_RESP_SIZE);\n\tif (!rg_resp) {\n\t\tkfree(rg_req);\n\t\treturn -ENOMEM;\n\t}\n\n\trg_req[1] = SMP_REPORT_GENERAL;\n\n\tres = smp_execute_task(dev, rg_req, RG_REQ_SIZE, rg_resp,\n\t\t\t       RG_RESP_SIZE);\n\tif (res)\n\t\tgoto out;\n\tif (rg_resp->result != SMP_RESP_FUNC_ACC) {\n\t\tres = rg_resp->result;\n\t\tgoto out;\n\t}\n\n\t*ecc = be16_to_cpu(rg_resp->rg.change_count);\nout:\n\tkfree(rg_resp);\n\tkfree(rg_req);\n\treturn res;\n}\n/**\n * sas_find_bcast_dev -  find the device issue BROADCAST(CHANGE).\n * @dev:domain device to be detect.\n * @src_dev: the device which originated BROADCAST(CHANGE).\n *\n * Add self-configuration expander support. Suppose two expander cascading,\n * when the first level expander is self-configuring, hotplug the disks in\n * second level expander, BROADCAST(CHANGE) will not only be originated\n * in the second level expander, but also be originated in the first level\n * expander (see SAS protocol SAS 2r-14, 7.11 for detail), it is to say,\n * expander changed count in two level expanders will all increment at least\n * once, but the phy which chang count has changed is the source device which\n * we concerned.\n */\n\nstatic int sas_find_bcast_dev(struct domain_device *dev,\n\t\t\t      struct domain_device **src_dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint ex_change_count = -1;\n\tint phy_id = -1;\n\tint res;\n\tstruct domain_device *ch;\n\n\tres = sas_get_ex_change_count(dev, &ex_change_count);\n\tif (res)\n\t\tgoto out;\n\tif (ex_change_count != -1 && ex_change_count != ex->ex_change_count) {\n\t\t/* Just detect if this expander phys phy change count changed,\n\t\t* in order to determine if this expander originate BROADCAST,\n\t\t* and do not update phy change count field in our structure.\n\t\t*/\n\t\tres = sas_find_bcast_phy(dev, &phy_id, 0, false);\n\t\tif (phy_id != -1) {\n\t\t\t*src_dev = dev;\n\t\t\tex->ex_change_count = ex_change_count;\n\t\t\tSAS_DPRINTK(\"Expander phy change count has changed\\n\");\n\t\t\treturn res;\n\t\t} else\n\t\t\tSAS_DPRINTK(\"Expander phys DID NOT change\\n\");\n\t}\n\tlist_for_each_entry(ch, &ex->children, siblings) {\n\t\tif (ch->dev_type == SAS_EDGE_EXPANDER_DEVICE || ch->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\t\tres = sas_find_bcast_dev(ch, src_dev);\n\t\t\tif (*src_dev)\n\t\t\t\treturn res;\n\t\t}\n\t}\nout:\n\treturn res;\n}\n\nstatic void sas_unregister_ex_tree(struct asd_sas_port *port, struct domain_device *dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct domain_device *child, *n;\n\n\tlist_for_each_entry_safe(child, n, &ex->children, siblings) {\n\t\tset_bit(SAS_DEV_GONE, &child->state);\n\t\tif (child->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t    child->dev_type == SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\tsas_unregister_ex_tree(port, child);\n\t\telse\n\t\t\tsas_unregister_dev(port, child);\n\t}\n\tsas_unregister_dev(port, dev);\n}\n\nstatic void sas_unregister_devs_sas_addr(struct domain_device *parent,\n\t\t\t\t\t int phy_id, bool last)\n{\n\tstruct expander_device *ex_dev = &parent->ex_dev;\n\tstruct ex_phy *phy = &ex_dev->ex_phy[phy_id];\n\tstruct domain_device *child, *n, *found = NULL;\n\tif (last) {\n\t\tlist_for_each_entry_safe(child, n,\n\t\t\t&ex_dev->children, siblings) {\n\t\t\tif (SAS_ADDR(child->sas_addr) ==\n\t\t\t    SAS_ADDR(phy->attached_sas_addr)) {\n\t\t\t\tset_bit(SAS_DEV_GONE, &child->state);\n\t\t\t\tif (child->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t\t\t    child->dev_type == SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\t\t\tsas_unregister_ex_tree(parent->port, child);\n\t\t\t\telse\n\t\t\t\t\tsas_unregister_dev(parent->port, child);\n\t\t\t\tfound = child;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsas_disable_routing(parent, phy->attached_sas_addr);\n\t}\n\tmemset(phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\tif (phy->port) {\n\t\tsas_port_delete_phy(phy->port, phy->phy);\n\t\tsas_device_set_phy(found, phy->port);\n\t\tif (phy->port->num_phys == 0)\n\t\t\tlist_add_tail(&phy->port->del_list,\n\t\t\t\t&parent->port->sas_port_del_list);\n\t\tphy->port = NULL;\n\t}\n}\n\nstatic int sas_discover_bfs_by_root_level(struct domain_device *root,\n\t\t\t\t\t  const int level)\n{\n\tstruct expander_device *ex_root = &root->ex_dev;\n\tstruct domain_device *child;\n\tint res = 0;\n\n\tlist_for_each_entry(child, &ex_root->children, siblings) {\n\t\tif (child->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t    child->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\t\tstruct sas_expander_device *ex =\n\t\t\t\trphy_to_expander_device(child->rphy);\n\n\t\t\tif (level > ex->level)\n\t\t\t\tres = sas_discover_bfs_by_root_level(child,\n\t\t\t\t\t\t\t\t     level);\n\t\t\telse if (level == ex->level)\n\t\t\t\tres = sas_ex_discover_devices(child, -1);\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic int sas_discover_bfs_by_root(struct domain_device *dev)\n{\n\tint res;\n\tstruct sas_expander_device *ex = rphy_to_expander_device(dev->rphy);\n\tint level = ex->level+1;\n\n\tres = sas_ex_discover_devices(dev, -1);\n\tif (res)\n\t\tgoto out;\n\tdo {\n\t\tres = sas_discover_bfs_by_root_level(dev, level);\n\t\tmb();\n\t\tlevel += 1;\n\t} while (level <= dev->port->disc.max_level);\nout:\n\treturn res;\n}\n\nstatic int sas_discover_new(struct domain_device *dev, int phy_id)\n{\n\tstruct ex_phy *ex_phy = &dev->ex_dev.ex_phy[phy_id];\n\tstruct domain_device *child;\n\tint res;\n\n\tSAS_DPRINTK(\"ex %016llx phy%d new device attached\\n\",\n\t\t    SAS_ADDR(dev->sas_addr), phy_id);\n\tres = sas_ex_phy_discover(dev, phy_id);\n\tif (res)\n\t\treturn res;\n\n\tif (sas_ex_join_wide_port(dev, phy_id))\n\t\treturn 0;\n\n\tres = sas_ex_discover_devices(dev, phy_id);\n\tif (res)\n\t\treturn res;\n\tlist_for_each_entry(child, &dev->ex_dev.children, siblings) {\n\t\tif (SAS_ADDR(child->sas_addr) ==\n\t\t    SAS_ADDR(ex_phy->attached_sas_addr)) {\n\t\t\tif (child->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t\t    child->dev_type == SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\t\tres = sas_discover_bfs_by_root(child);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic bool dev_type_flutter(enum sas_device_type new, enum sas_device_type old)\n{\n\tif (old == new)\n\t\treturn true;\n\n\t/* treat device directed resets as flutter, if we went\n\t * SAS_END_DEVICE to SAS_SATA_PENDING the link needs recovery\n\t */\n\tif ((old == SAS_SATA_PENDING && new == SAS_END_DEVICE) ||\n\t    (old == SAS_END_DEVICE && new == SAS_SATA_PENDING))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int sas_rediscover_dev(struct domain_device *dev, int phy_id, bool last)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *phy = &ex->ex_phy[phy_id];\n\tenum sas_device_type type = SAS_PHY_UNUSED;\n\tu8 sas_addr[8];\n\tint res;\n\n\tmemset(sas_addr, 0, 8);\n\tres = sas_get_phy_attached_dev(dev, phy_id, sas_addr, &type);\n\tswitch (res) {\n\tcase SMP_RESP_NO_PHY:\n\t\tphy->phy_state = PHY_NOT_PRESENT;\n\t\tsas_unregister_devs_sas_addr(dev, phy_id, last);\n\t\treturn res;\n\tcase SMP_RESP_PHY_VACANT:\n\t\tphy->phy_state = PHY_VACANT;\n\t\tsas_unregister_devs_sas_addr(dev, phy_id, last);\n\t\treturn res;\n\tcase SMP_RESP_FUNC_ACC:\n\t\tbreak;\n\tcase -ECOMM:\n\t\tbreak;\n\tdefault:\n\t\treturn res;\n\t}\n\n\tif ((SAS_ADDR(sas_addr) == 0) || (res == -ECOMM)) {\n\t\tphy->phy_state = PHY_EMPTY;\n\t\tsas_unregister_devs_sas_addr(dev, phy_id, last);\n\t\treturn res;\n\t} else if (SAS_ADDR(sas_addr) == SAS_ADDR(phy->attached_sas_addr) &&\n\t\t   dev_type_flutter(type, phy->attached_dev_type)) {\n\t\tstruct domain_device *ata_dev = sas_ex_to_ata(dev, phy_id);\n\t\tchar *action = \"\";\n\n\t\tsas_ex_phy_discover(dev, phy_id);\n\n\t\tif (ata_dev && phy->attached_dev_type == SAS_SATA_PENDING)\n\t\t\taction = \", needs recovery\";\n\t\tSAS_DPRINTK(\"ex %016llx phy 0x%x broadcast flutter%s\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), phy_id, action);\n\t\treturn res;\n\t}\n\n\t/* delete the old link */\n\tif (SAS_ADDR(phy->attached_sas_addr) &&\n\t    SAS_ADDR(sas_addr) != SAS_ADDR(phy->attached_sas_addr)) {\n\t\tSAS_DPRINTK(\"ex %016llx phy 0x%x replace %016llx\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), phy_id,\n\t\t\t    SAS_ADDR(phy->attached_sas_addr));\n\t\tsas_unregister_devs_sas_addr(dev, phy_id, last);\n\t}\n\n\treturn sas_discover_new(dev, phy_id);\n}\n\n/**\n * sas_rediscover - revalidate the domain.\n * @dev:domain device to be detect.\n * @phy_id: the phy id will be detected.\n *\n * NOTE: this process _must_ quit (return) as soon as any connection\n * errors are encountered.  Connection recovery is done elsewhere.\n * Discover process only interrogates devices in order to discover the\n * domain.For plugging out, we un-register the device only when it is\n * the last phy in the port, for other phys in this port, we just delete it\n * from the port.For inserting, we do discovery when it is the\n * first phy,for other phys in this port, we add it to the port to\n * forming the wide-port.\n */\nstatic int sas_rediscover(struct domain_device *dev, const int phy_id)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *changed_phy = &ex->ex_phy[phy_id];\n\tint res = 0;\n\tint i;\n\tbool last = true;\t/* is this the last phy of the port */\n\n\tSAS_DPRINTK(\"ex %016llx phy%d originated BROADCAST(CHANGE)\\n\",\n\t\t    SAS_ADDR(dev->sas_addr), phy_id);\n\n\tif (SAS_ADDR(changed_phy->attached_sas_addr) != 0) {\n\t\tfor (i = 0; i < ex->num_phys; i++) {\n\t\t\tstruct ex_phy *phy = &ex->ex_phy[i];\n\n\t\t\tif (i == phy_id)\n\t\t\t\tcontinue;\n\t\t\tif (SAS_ADDR(phy->attached_sas_addr) ==\n\t\t\t    SAS_ADDR(changed_phy->attached_sas_addr)) {\n\t\t\t\tSAS_DPRINTK(\"phy%d part of wide port with \"\n\t\t\t\t\t    \"phy%d\\n\", phy_id, i);\n\t\t\t\tlast = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tres = sas_rediscover_dev(dev, phy_id, last);\n\t} else\n\t\tres = sas_discover_new(dev, phy_id);\n\treturn res;\n}\n\n/**\n * sas_revalidate_domain -- revalidate the domain\n * @port: port to the domain of interest\n *\n * NOTE: this process _must_ quit (return) as soon as any connection\n * errors are encountered.  Connection recovery is done elsewhere.\n * Discover process only interrogates devices in order to discover the\n * domain.\n */\nint sas_ex_revalidate_domain(struct domain_device *port_dev)\n{\n\tint res;\n\tstruct domain_device *dev = NULL;\n\n\tres = sas_find_bcast_dev(port_dev, &dev);\n\tif (res == 0 && dev) {\n\t\tstruct expander_device *ex = &dev->ex_dev;\n\t\tint i = 0, phy_id;\n\n\t\tdo {\n\t\t\tphy_id = -1;\n\t\t\tres = sas_find_bcast_phy(dev, &phy_id, i, true);\n\t\t\tif (phy_id == -1)\n\t\t\t\tbreak;\n\t\t\tres = sas_rediscover(dev, phy_id);\n\t\t\ti = phy_id + 1;\n\t\t} while (i < ex->num_phys);\n\t}\n\treturn res;\n}\n\nvoid sas_smp_handler(struct bsg_job *job, struct Scsi_Host *shost,\n\t\tstruct sas_rphy *rphy)\n{\n\tstruct domain_device *dev;\n\tunsigned int reslen = 0;\n\tint ret = -EINVAL;\n\n\t/* no rphy means no smp target support (ie aic94xx host) */\n\tif (!rphy)\n\t\treturn sas_smp_host_handler(job, shost);\n\n\tswitch (rphy->identify.device_type) {\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"%s: can we send a smp request to a device?\\n\",\n\t\t       __func__);\n\t\tgoto out;\n\t}\n\n\tdev = sas_find_dev_by_rphy(rphy);\n\tif (!dev) {\n\t\tprintk(\"%s: fail to find a domain_device?\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\t/* do we need to support multiple segments? */\n\tif (job->request_payload.sg_cnt > 1 ||\n\t    job->reply_payload.sg_cnt > 1) {\n\t\tprintk(\"%s: multiple segments req %u, rsp %u\\n\",\n\t\t       __func__, job->request_payload.payload_len,\n\t\t       job->reply_payload.payload_len);\n\t\tgoto out;\n\t}\n\n\tret = smp_execute_task_sg(dev, job->request_payload.sg_list,\n\t\t\tjob->reply_payload.sg_list);\n\tif (ret > 0) {\n\t\t/* positive number is the untransferred residual */\n\t\treslen = ret;\n\t\tret = 0;\n\t}\n\nout:\n\tbsg_job_done(job, ret, reslen);\n}\n", "/*\n * Serial Attached SCSI (SAS) class internal header file\n *\n * Copyright (C) 2005 Adaptec, Inc.  All rights reserved.\n * Copyright (C) 2005 Luben Tuikov <luben_tuikov@adaptec.com>\n *\n * This file is licensed under GPLv2.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307\n * USA\n *\n */\n\n#ifndef _SAS_INTERNAL_H_\n#define _SAS_INTERNAL_H_\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_transport_sas.h>\n#include <scsi/libsas.h>\n#include <scsi/sas_ata.h>\n\n#define sas_printk(fmt, ...) printk(KERN_NOTICE \"sas: \" fmt, ## __VA_ARGS__)\n\n#define SAS_DPRINTK(fmt, ...) printk(KERN_DEBUG \"sas: \" fmt, ## __VA_ARGS__)\n\n#define TO_SAS_TASK(_scsi_cmd)  ((void *)(_scsi_cmd)->host_scribble)\n#define ASSIGN_SAS_TASK(_sc, _t) do { (_sc)->host_scribble = (void *) _t; } while (0)\n\nstruct sas_phy_data {\n\t/* let reset be performed in sas_queue_work() context */\n\tstruct sas_phy *phy;\n\tstruct mutex event_lock;\n\tint hard_reset;\n\tint reset_result;\n\tstruct sas_work reset_work;\n\tint enable;\n\tint enable_result;\n\tstruct sas_work enable_work;\n};\n\nvoid sas_scsi_recover_host(struct Scsi_Host *shost);\n\nint sas_show_class(enum sas_class class, char *buf);\nint sas_show_proto(enum sas_protocol proto, char *buf);\nint sas_show_linkrate(enum sas_linkrate linkrate, char *buf);\nint sas_show_oob_mode(enum sas_oob_mode oob_mode, char *buf);\n\nint  sas_register_phys(struct sas_ha_struct *sas_ha);\nvoid sas_unregister_phys(struct sas_ha_struct *sas_ha);\n\nstruct asd_sas_event *sas_alloc_event(struct asd_sas_phy *phy);\nvoid sas_free_event(struct asd_sas_event *event);\n\nint  sas_register_ports(struct sas_ha_struct *sas_ha);\nvoid sas_unregister_ports(struct sas_ha_struct *sas_ha);\n\nint  sas_init_events(struct sas_ha_struct *sas_ha);\nvoid sas_disable_revalidation(struct sas_ha_struct *ha);\nvoid sas_enable_revalidation(struct sas_ha_struct *ha);\nvoid __sas_drain_work(struct sas_ha_struct *ha);\n\nvoid sas_deform_port(struct asd_sas_phy *phy, int gone);\n\nvoid sas_porte_bytes_dmaed(struct work_struct *work);\nvoid sas_porte_broadcast_rcvd(struct work_struct *work);\nvoid sas_porte_link_reset_err(struct work_struct *work);\nvoid sas_porte_timer_event(struct work_struct *work);\nvoid sas_porte_hard_reset(struct work_struct *work);\nint sas_queue_work(struct sas_ha_struct *ha, struct sas_work *sw);\n\nint sas_notify_lldd_dev_found(struct domain_device *);\nvoid sas_notify_lldd_dev_gone(struct domain_device *);\n\nvoid sas_smp_handler(struct bsg_job *job, struct Scsi_Host *shost,\n\t\tstruct sas_rphy *rphy);\nint sas_smp_phy_control(struct domain_device *dev, int phy_id,\n\t\t\tenum phy_func phy_func, struct sas_phy_linkrates *);\nint sas_smp_get_phy_events(struct sas_phy *phy);\n\nint sas_notify_phy_event(struct asd_sas_phy *phy, enum phy_event event);\nvoid sas_device_set_phy(struct domain_device *dev, struct sas_port *port);\nstruct domain_device *sas_find_dev_by_rphy(struct sas_rphy *rphy);\nstruct domain_device *sas_ex_to_ata(struct domain_device *ex_dev, int phy_id);\nint sas_ex_phy_discover(struct domain_device *dev, int single);\nint sas_get_report_phy_sata(struct domain_device *dev, int phy_id,\n\t\t\t    struct smp_resp *rps_resp);\nint sas_try_ata_reset(struct asd_sas_phy *phy);\nvoid sas_hae_reset(struct work_struct *work);\n\nvoid sas_free_device(struct kref *kref);\nvoid sas_destruct_devices(struct asd_sas_port *port);\n\nextern const work_func_t sas_phy_event_fns[PHY_NUM_EVENTS];\nextern const work_func_t sas_port_event_fns[PORT_NUM_EVENTS];\n\n#ifdef CONFIG_SCSI_SAS_HOST_SMP\nextern void sas_smp_host_handler(struct bsg_job *job, struct Scsi_Host *shost);\n#else\nstatic inline void sas_smp_host_handler(struct bsg_job *job,\n\t\tstruct Scsi_Host *shost)\n{\n\tshost_printk(KERN_ERR, shost,\n\t\t\"Cannot send SMP to a sas host (not enabled in CONFIG)\\n\");\n\tbsg_job_done(job, -EINVAL, 0);\n}\n#endif\n\nstatic inline void sas_fail_probe(struct domain_device *dev, const char *func, int err)\n{\n\tSAS_DPRINTK(\"%s: for %s device %16llx returned %d\\n\",\n\t\t    func, dev->parent ? \"exp-attached\" :\n\t\t\t\t\t    \"direct-attached\",\n\t\t    SAS_ADDR(dev->sas_addr), err);\n\tsas_unregister_dev(dev->port, dev);\n}\n\nstatic inline void sas_fill_in_rphy(struct domain_device *dev,\n\t\t\t\t    struct sas_rphy *rphy)\n{\n\trphy->identify.sas_address = SAS_ADDR(dev->sas_addr);\n\trphy->identify.initiator_port_protocols = dev->iproto;\n\trphy->identify.target_port_protocols = dev->tproto;\n\tswitch (dev->dev_type) {\n\tcase SAS_SATA_DEV:\n\t\t/* FIXME: need sata device type */\n\tcase SAS_END_DEVICE:\n\tcase SAS_SATA_PENDING:\n\t\trphy->identify.device_type = SAS_END_DEVICE;\n\t\tbreak;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\trphy->identify.device_type = SAS_EDGE_EXPANDER_DEVICE;\n\t\tbreak;\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\trphy->identify.device_type = SAS_FANOUT_EXPANDER_DEVICE;\n\t\tbreak;\n\tdefault:\n\t\trphy->identify.device_type = SAS_PHY_UNUSED;\n\t\tbreak;\n\t}\n}\n\nstatic inline void sas_phy_set_target(struct asd_sas_phy *p, struct domain_device *dev)\n{\n\tstruct sas_phy *phy = p->phy;\n\n\tif (dev) {\n\t\tif (dev_is_sata(dev))\n\t\t\tphy->identify.device_type = SAS_END_DEVICE;\n\t\telse\n\t\t\tphy->identify.device_type = dev->dev_type;\n\t\tphy->identify.target_port_protocols = dev->tproto;\n\t} else {\n\t\tphy->identify.device_type = SAS_PHY_UNUSED;\n\t\tphy->identify.target_port_protocols = 0;\n\t}\n}\n\nstatic inline void sas_add_parent_port(struct domain_device *dev, int phy_id)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *ex_phy = &ex->ex_phy[phy_id];\n\n\tif (!ex->parent_port) {\n\t\tex->parent_port = sas_port_alloc(&dev->rphy->dev, phy_id);\n\t\t/* FIXME: error handling */\n\t\tBUG_ON(!ex->parent_port);\n\t\tBUG_ON(sas_port_add(ex->parent_port));\n\t\tsas_port_mark_backlink(ex->parent_port);\n\t}\n\tsas_port_add_phy(ex->parent_port, ex_phy->phy);\n}\n\nstatic inline struct domain_device *sas_alloc_device(void)\n{\n\tstruct domain_device *dev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\n\tif (dev) {\n\t\tINIT_LIST_HEAD(&dev->siblings);\n\t\tINIT_LIST_HEAD(&dev->dev_list_node);\n\t\tINIT_LIST_HEAD(&dev->disco_list_node);\n\t\tkref_init(&dev->kref);\n\t\tspin_lock_init(&dev->done_lock);\n\t}\n\treturn dev;\n}\n\nstatic inline void sas_put_device(struct domain_device *dev)\n{\n\tkref_put(&dev->kref, sas_free_device);\n}\n\n#endif /* _SAS_INTERNAL_H_ */\n", "/*\n * Serial Attached SCSI (SAS) Port class\n *\n * Copyright (C) 2005 Adaptec, Inc.  All rights reserved.\n * Copyright (C) 2005 Luben Tuikov <luben_tuikov@adaptec.com>\n *\n * This file is licensed under GPLv2.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n\n#include \"sas_internal.h\"\n\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_sas.h>\n#include \"../scsi_sas_internal.h\"\n\nstatic bool phy_is_wideport_member(struct asd_sas_port *port, struct asd_sas_phy *phy)\n{\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\n\tif (memcmp(port->attached_sas_addr, phy->attached_sas_addr,\n\t\t   SAS_ADDR_SIZE) != 0 || (sas_ha->strict_wide_ports &&\n\t     memcmp(port->sas_addr, phy->sas_addr, SAS_ADDR_SIZE) != 0))\n\t\treturn false;\n\treturn true;\n}\n\nstatic void sas_resume_port(struct asd_sas_phy *phy)\n{\n\tstruct domain_device *dev;\n\tstruct asd_sas_port *port = phy->port;\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\tstruct sas_internal *si = to_sas_internal(sas_ha->core.shost->transportt);\n\n\tif (si->dft->lldd_port_formed)\n\t\tsi->dft->lldd_port_formed(phy);\n\n\tif (port->suspended)\n\t\tport->suspended = 0;\n\telse {\n\t\t/* we only need to handle \"link returned\" actions once */\n\t\treturn;\n\t}\n\n\t/* if the port came back:\n\t * 1/ presume every device came back\n\t * 2/ force the next revalidation to check all expander phys\n\t */\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\tint i, rc;\n\n\t\trc = sas_notify_lldd_dev_found(dev);\n\t\tif (rc) {\n\t\t\tsas_unregister_dev(port, dev);\n\t\t\tsas_destruct_devices(port);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (dev->dev_type == SAS_EDGE_EXPANDER_DEVICE || dev->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\t\tdev->ex_dev.ex_change_count = -1;\n\t\t\tfor (i = 0; i < dev->ex_dev.num_phys; i++) {\n\t\t\t\tstruct ex_phy *phy = &dev->ex_dev.ex_phy[i];\n\n\t\t\t\tphy->phy_change_count = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tsas_discover_event(port, DISCE_RESUME);\n}\n\n/**\n * sas_form_port -- add this phy to a port\n * @phy: the phy of interest\n *\n * This function adds this phy to an existing port, thus creating a wide\n * port, or it creates a port and adds the phy to the port.\n */\nstatic void sas_form_port(struct asd_sas_phy *phy)\n{\n\tint i;\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\tstruct asd_sas_port *port = phy->port;\n\tstruct sas_internal *si =\n\t\tto_sas_internal(sas_ha->core.shost->transportt);\n\tunsigned long flags;\n\n\tif (port) {\n\t\tif (!phy_is_wideport_member(port, phy))\n\t\t\tsas_deform_port(phy, 0);\n\t\telse if (phy->suspended) {\n\t\t\tphy->suspended = 0;\n\t\t\tsas_resume_port(phy);\n\n\t\t\t/* phy came back, try to cancel the timeout */\n\t\t\twake_up(&sas_ha->eh_wait_q);\n\t\t\treturn;\n\t\t} else {\n\t\t\tSAS_DPRINTK(\"%s: phy%d belongs to port%d already(%d)!\\n\",\n\t\t\t\t    __func__, phy->id, phy->port->id,\n\t\t\t\t    phy->port->num_phys);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* see if the phy should be part of a wide port */\n\tspin_lock_irqsave(&sas_ha->phy_port_lock, flags);\n\tfor (i = 0; i < sas_ha->num_phys; i++) {\n\t\tport = sas_ha->sas_port[i];\n\t\tspin_lock(&port->phy_list_lock);\n\t\tif (*(u64 *) port->sas_addr &&\n\t\t    phy_is_wideport_member(port, phy) && port->num_phys > 0) {\n\t\t\t/* wide port */\n\t\t\tSAS_DPRINTK(\"phy%d matched wide port%d\\n\", phy->id,\n\t\t\t\t    port->id);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&port->phy_list_lock);\n\t}\n\t/* The phy does not match any existing port, create a new one */\n\tif (i == sas_ha->num_phys) {\n\t\tfor (i = 0; i < sas_ha->num_phys; i++) {\n\t\t\tport = sas_ha->sas_port[i];\n\t\t\tspin_lock(&port->phy_list_lock);\n\t\t\tif (*(u64 *)port->sas_addr == 0\n\t\t\t\t&& port->num_phys == 0) {\n\t\t\t\tmemcpy(port->sas_addr, phy->sas_addr,\n\t\t\t\t\tSAS_ADDR_SIZE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock(&port->phy_list_lock);\n\t\t}\n\t}\n\n\tif (i >= sas_ha->num_phys) {\n\t\tprintk(KERN_NOTICE \"%s: couldn't find a free port, bug?\\n\",\n\t\t       __func__);\n\t\tspin_unlock_irqrestore(&sas_ha->phy_port_lock, flags);\n\t\treturn;\n\t}\n\n\t/* add the phy to the port */\n\tlist_add_tail(&phy->port_phy_el, &port->phy_list);\n\tsas_phy_set_target(phy, port->port_dev);\n\tphy->port = port;\n\tport->num_phys++;\n\tport->phy_mask |= (1U << phy->id);\n\n\tif (*(u64 *)port->attached_sas_addr == 0) {\n\t\tport->class = phy->class;\n\t\tmemcpy(port->attached_sas_addr, phy->attached_sas_addr,\n\t\t       SAS_ADDR_SIZE);\n\t\tport->iproto = phy->iproto;\n\t\tport->tproto = phy->tproto;\n\t\tport->oob_mode = phy->oob_mode;\n\t\tport->linkrate = phy->linkrate;\n\t} else\n\t\tport->linkrate = max(port->linkrate, phy->linkrate);\n\tspin_unlock(&port->phy_list_lock);\n\tspin_unlock_irqrestore(&sas_ha->phy_port_lock, flags);\n\n\tif (!port->port) {\n\t\tport->port = sas_port_alloc(phy->phy->dev.parent, port->id);\n\t\tBUG_ON(!port->port);\n\t\tsas_port_add(port->port);\n\t}\n\tsas_port_add_phy(port->port, phy->phy);\n\n\tSAS_DPRINTK(\"%s added to %s, phy_mask:0x%x (%16llx)\\n\",\n\t\t    dev_name(&phy->phy->dev), dev_name(&port->port->dev),\n\t\t    port->phy_mask,\n\t\t    SAS_ADDR(port->attached_sas_addr));\n\n\tif (port->port_dev)\n\t\tport->port_dev->pathways = port->num_phys;\n\n\t/* Tell the LLDD about this port formation. */\n\tif (si->dft->lldd_port_formed)\n\t\tsi->dft->lldd_port_formed(phy);\n\n\tsas_discover_event(phy->port, DISCE_DISCOVER_DOMAIN);\n\tflush_workqueue(sas_ha->disco_q);\n}\n\n/**\n * sas_deform_port -- remove this phy from the port it belongs to\n * @phy: the phy of interest\n *\n * This is called when the physical link to the other phy has been\n * lost (on this phy), in Event thread context. We cannot delay here.\n */\nvoid sas_deform_port(struct asd_sas_phy *phy, int gone)\n{\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\tstruct asd_sas_port *port = phy->port;\n\tstruct sas_internal *si =\n\t\tto_sas_internal(sas_ha->core.shost->transportt);\n\tstruct domain_device *dev;\n\tunsigned long flags;\n\n\tif (!port)\n\t\treturn;\t\t  /* done by a phy event */\n\n\tdev = port->port_dev;\n\tif (dev)\n\t\tdev->pathways--;\n\n\tif (port->num_phys == 1) {\n\t\tsas_unregister_domain_devices(port, gone);\n\t\tsas_destruct_devices(port);\n\t\tsas_port_delete(port->port);\n\t\tport->port = NULL;\n\t} else {\n\t\tsas_port_delete_phy(port->port, phy->phy);\n\t\tsas_device_set_phy(dev, port->port);\n\t}\n\n\tif (si->dft->lldd_port_deformed)\n\t\tsi->dft->lldd_port_deformed(phy);\n\n\tspin_lock_irqsave(&sas_ha->phy_port_lock, flags);\n\tspin_lock(&port->phy_list_lock);\n\n\tlist_del_init(&phy->port_phy_el);\n\tsas_phy_set_target(phy, NULL);\n\tphy->port = NULL;\n\tport->num_phys--;\n\tport->phy_mask &= ~(1U << phy->id);\n\n\tif (port->num_phys == 0) {\n\t\tINIT_LIST_HEAD(&port->phy_list);\n\t\tmemset(port->sas_addr, 0, SAS_ADDR_SIZE);\n\t\tmemset(port->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\t\tport->class = 0;\n\t\tport->iproto = 0;\n\t\tport->tproto = 0;\n\t\tport->oob_mode = 0;\n\t\tport->phy_mask = 0;\n\t}\n\tspin_unlock(&port->phy_list_lock);\n\tspin_unlock_irqrestore(&sas_ha->phy_port_lock, flags);\n\n\treturn;\n}\n\n/* ---------- SAS port events ---------- */\n\nvoid sas_porte_bytes_dmaed(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = to_asd_sas_event(work);\n\tstruct asd_sas_phy *phy = ev->phy;\n\n\tsas_form_port(phy);\n}\n\nvoid sas_porte_broadcast_rcvd(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = to_asd_sas_event(work);\n\tstruct asd_sas_phy *phy = ev->phy;\n\tunsigned long flags;\n\tu32 prim;\n\n\tspin_lock_irqsave(&phy->sas_prim_lock, flags);\n\tprim = phy->sas_prim;\n\tspin_unlock_irqrestore(&phy->sas_prim_lock, flags);\n\n\tSAS_DPRINTK(\"broadcast received: %d\\n\", prim);\n\tsas_discover_event(phy->port, DISCE_REVALIDATE_DOMAIN);\n\n\tif (phy->port)\n\t\tflush_workqueue(phy->port->ha->disco_q);\n}\n\nvoid sas_porte_link_reset_err(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = to_asd_sas_event(work);\n\tstruct asd_sas_phy *phy = ev->phy;\n\n\tsas_deform_port(phy, 1);\n}\n\nvoid sas_porte_timer_event(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = to_asd_sas_event(work);\n\tstruct asd_sas_phy *phy = ev->phy;\n\n\tsas_deform_port(phy, 1);\n}\n\nvoid sas_porte_hard_reset(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = to_asd_sas_event(work);\n\tstruct asd_sas_phy *phy = ev->phy;\n\n\tsas_deform_port(phy, 1);\n}\n\n/* ---------- SAS port registration ---------- */\n\nstatic void sas_init_port(struct asd_sas_port *port,\n\t\t\t  struct sas_ha_struct *sas_ha, int i)\n{\n\tmemset(port, 0, sizeof(*port));\n\tport->id = i;\n\tINIT_LIST_HEAD(&port->dev_list);\n\tINIT_LIST_HEAD(&port->disco_list);\n\tINIT_LIST_HEAD(&port->destroy_list);\n\tINIT_LIST_HEAD(&port->sas_port_del_list);\n\tspin_lock_init(&port->phy_list_lock);\n\tINIT_LIST_HEAD(&port->phy_list);\n\tport->ha = sas_ha;\n\n\tspin_lock_init(&port->dev_list_lock);\n}\n\nint sas_register_ports(struct sas_ha_struct *sas_ha)\n{\n\tint i;\n\n\t/* initialize the ports and discovery */\n\tfor (i = 0; i < sas_ha->num_phys; i++) {\n\t\tstruct asd_sas_port *port = sas_ha->sas_port[i];\n\n\t\tsas_init_port(port, sas_ha, i);\n\t\tsas_init_disc(&port->disc, port);\n\t}\n\treturn 0;\n}\n\nvoid sas_unregister_ports(struct sas_ha_struct *sas_ha)\n{\n\tint i;\n\n\tfor (i = 0; i < sas_ha->num_phys; i++)\n\t\tif (sas_ha->sas_phy[i]->port)\n\t\t\tsas_deform_port(sas_ha->sas_phy[i], 0);\n\n}\n\nconst work_func_t sas_port_event_fns[PORT_NUM_EVENTS] = {\n\t[PORTE_BYTES_DMAED] = sas_porte_bytes_dmaed,\n\t[PORTE_BROADCAST_RCVD] = sas_porte_broadcast_rcvd,\n\t[PORTE_LINK_RESET_ERR] = sas_porte_link_reset_err,\n\t[PORTE_TIMER_EVENT] = sas_porte_timer_event,\n\t[PORTE_HARD_RESET] = sas_porte_hard_reset,\n};\n", "/*\n * SAS host prototypes and structures header file\n *\n * Copyright (C) 2005 Adaptec, Inc.  All rights reserved.\n * Copyright (C) 2005 Luben Tuikov <luben_tuikov@adaptec.com>\n *\n * This file is licensed under GPLv2.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307\n * USA\n *\n */\n\n#ifndef _LIBSAS_H_\n#define _LIBSAS_H_\n\n\n#include <linux/timer.h>\n#include <linux/pci.h>\n#include <scsi/sas.h>\n#include <linux/libata.h>\n#include <linux/list.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_transport_sas.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n\nstruct block_device;\n\nenum sas_class {\n\tSAS,\n\tEXPANDER\n};\n\nenum sas_phy_role {\n\tPHY_ROLE_NONE = 0,\n\tPHY_ROLE_TARGET = 0x40,\n\tPHY_ROLE_INITIATOR = 0x80,\n};\n\nenum sas_phy_type {\n        PHY_TYPE_PHYSICAL,\n        PHY_TYPE_VIRTUAL\n};\n\n/* The events are mnemonically described in sas_dump.c\n * so when updating/adding events here, please also\n * update the other file too.\n */\nenum port_event {\n\tPORTE_BYTES_DMAED     = 0U,\n\tPORTE_BROADCAST_RCVD,\n\tPORTE_LINK_RESET_ERR,\n\tPORTE_TIMER_EVENT,\n\tPORTE_HARD_RESET,\n\tPORT_NUM_EVENTS,\n};\n\nenum phy_event {\n\tPHYE_LOSS_OF_SIGNAL   = 0U,\n\tPHYE_OOB_DONE,\n\tPHYE_OOB_ERROR,\n\tPHYE_SPINUP_HOLD,             /* hot plug SATA, no COMWAKE sent */\n\tPHYE_RESUME_TIMEOUT,\n\tPHYE_SHUTDOWN,\n\tPHY_NUM_EVENTS,\n};\n\nenum discover_event {\n\tDISCE_DISCOVER_DOMAIN   = 0U,\n\tDISCE_REVALIDATE_DOMAIN,\n\tDISCE_SUSPEND,\n\tDISCE_RESUME,\n\tDISC_NUM_EVENTS,\n};\n\n/* ---------- Expander Devices ---------- */\n\n#define to_dom_device(_obj) container_of(_obj, struct domain_device, dev_obj)\n#define to_dev_attr(_attr)  container_of(_attr, struct domain_dev_attribute,\\\n                                         attr)\n\nenum routing_attribute {\n\tDIRECT_ROUTING,\n\tSUBTRACTIVE_ROUTING,\n\tTABLE_ROUTING,\n};\n\nenum ex_phy_state {\n\tPHY_EMPTY,\n\tPHY_VACANT,\n\tPHY_NOT_PRESENT,\n\tPHY_DEVICE_DISCOVERED\n};\n\nstruct ex_phy {\n\tint    phy_id;\n\n\tenum ex_phy_state phy_state;\n\n\tenum sas_device_type attached_dev_type;\n\tenum sas_linkrate linkrate;\n\n\tu8   attached_sata_host:1;\n\tu8   attached_sata_dev:1;\n\tu8   attached_sata_ps:1;\n\n\tenum sas_protocol attached_tproto;\n\tenum sas_protocol attached_iproto;\n\n\tu8   attached_sas_addr[SAS_ADDR_SIZE];\n\tu8   attached_phy_id;\n\n\tint phy_change_count;\n\tenum routing_attribute routing_attr;\n\tu8   virtual:1;\n\n\tint  last_da_index;\n\n\tstruct sas_phy *phy;\n\tstruct sas_port *port;\n};\n\nstruct expander_device {\n\tstruct list_head children;\n\n\tint    ex_change_count;\n\tu16    max_route_indexes;\n\tu8     num_phys;\n\n\tu8     t2t_supp:1;\n\tu8     configuring:1;\n\tu8     conf_route_table:1;\n\n\tu8     enclosure_logical_id[8];\n\n\tstruct ex_phy *ex_phy;\n\tstruct sas_port *parent_port;\n\n\tstruct mutex cmd_mutex;\n};\n\n/* ---------- SATA device ---------- */\n#define ATA_RESP_FIS_SIZE 24\n\nstruct sata_device {\n\tunsigned int class;\n\tstruct smp_resp        rps_resp; /* report_phy_sata_resp */\n\tu8     port_no;        /* port number, if this is a PM (Port) */\n\n\tstruct ata_port *ap;\n\tstruct ata_host ata_host;\n\tu8     fis[ATA_RESP_FIS_SIZE];\n};\n\nstruct ssp_device {\n\tstruct list_head eh_list_node; /* pending a user requested eh action */\n\tstruct scsi_lun reset_lun;\n};\n\nenum {\n\tSAS_DEV_GONE,\n\tSAS_DEV_FOUND, /* device notified to lldd */\n\tSAS_DEV_DESTROY,\n\tSAS_DEV_EH_PENDING,\n\tSAS_DEV_LU_RESET,\n\tSAS_DEV_RESET,\n};\n\nstruct domain_device {\n\tspinlock_t done_lock;\n\tenum sas_device_type dev_type;\n\n        enum sas_linkrate linkrate;\n        enum sas_linkrate min_linkrate;\n        enum sas_linkrate max_linkrate;\n\n        int  pathways;\n\n        struct domain_device *parent;\n        struct list_head siblings; /* devices on the same level */\n        struct asd_sas_port *port;        /* shortcut to root of the tree */\n\tstruct sas_phy *phy;\n\n        struct list_head dev_list_node;\n\tstruct list_head disco_list_node; /* awaiting probe or destruct */\n\n        enum sas_protocol    iproto;\n        enum sas_protocol    tproto;\n\n        struct sas_rphy *rphy;\n\n        u8  sas_addr[SAS_ADDR_SIZE];\n        u8  hashed_sas_addr[HASHED_SAS_ADDR_SIZE];\n\n        u8  frame_rcvd[32];\n\n        union {\n                struct expander_device ex_dev;\n                struct sata_device     sata_dev; /* STP & directly attached */\n\t\tstruct ssp_device      ssp_dev;\n        };\n\n        void *lldd_dev;\n\tunsigned long state;\n\tstruct kref kref;\n};\n\nstruct sas_work {\n\tstruct list_head drain_node;\n\tstruct work_struct work;\n};\n\nstatic inline void INIT_SAS_WORK(struct sas_work *sw, void (*fn)(struct work_struct *))\n{\n\tINIT_WORK(&sw->work, fn);\n\tINIT_LIST_HEAD(&sw->drain_node);\n}\n\nstruct sas_discovery_event {\n\tstruct sas_work work;\n\tstruct asd_sas_port *port;\n};\n\nstatic inline struct sas_discovery_event *to_sas_discovery_event(struct work_struct *work)\n{\n\tstruct sas_discovery_event *ev = container_of(work, typeof(*ev), work.work);\n\n\treturn ev;\n}\n\nstruct sas_discovery {\n\tstruct sas_discovery_event disc_work[DISC_NUM_EVENTS];\n\tunsigned long    pending;\n\tu8     fanout_sas_addr[8];\n\tu8     eeds_a[8];\n\tu8     eeds_b[8];\n\tint    max_level;\n};\n\n/* The port struct is Class:RW, driver:RO */\nstruct asd_sas_port {\n/* private: */\n\tstruct sas_discovery disc;\n\tstruct domain_device *port_dev;\n\tspinlock_t dev_list_lock;\n\tstruct list_head dev_list;\n\tstruct list_head disco_list;\n\tstruct list_head destroy_list;\n\tstruct list_head sas_port_del_list;\n\tenum   sas_linkrate linkrate;\n\n\tstruct sas_work work;\n\tint suspended;\n\n/* public: */\n\tint id;\n\n\tenum sas_class   class;\n\tu8               sas_addr[SAS_ADDR_SIZE];\n\tu8               attached_sas_addr[SAS_ADDR_SIZE];\n\tenum sas_protocol   iproto;\n\tenum sas_protocol   tproto;\n\n\tenum sas_oob_mode oob_mode;\n\n\tspinlock_t       phy_list_lock;\n\tstruct list_head phy_list;\n\tint              num_phys;\n\tu32              phy_mask;\n\n\tstruct sas_ha_struct *ha;\n\n\tstruct sas_port\t*port;\n\n\tvoid *lldd_port;\t  /* not touched by the sas class code */\n};\n\nstruct asd_sas_event {\n\tstruct sas_work work;\n\tstruct asd_sas_phy *phy;\n\tint event;\n};\n\nstatic inline struct asd_sas_event *to_asd_sas_event(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = container_of(work, typeof(*ev), work.work);\n\n\treturn ev;\n}\n\nstatic inline void INIT_SAS_EVENT(struct asd_sas_event *ev,\n\t\tvoid (*fn)(struct work_struct *),\n\t\tstruct asd_sas_phy *phy, int event)\n{\n\tINIT_SAS_WORK(&ev->work, fn);\n\tev->phy = phy;\n\tev->event = event;\n}\n\n#define SAS_PHY_SHUTDOWN_THRES   1024\n\n/* The phy pretty much is controlled by the LLDD.\n * The class only reads those fields.\n */\nstruct asd_sas_phy {\n/* private: */\n\tatomic_t event_nr;\n\tint in_shutdown;\n\tint error;\n\tint suspended;\n\n\tstruct sas_phy *phy;\n\n/* public: */\n\t/* The following are class:RO, driver:R/W */\n\tint            enabled;\t  /* must be set */\n\n\tint            id;\t  /* must be set */\n\tenum sas_class class;\n\tenum sas_protocol iproto;\n\tenum sas_protocol tproto;\n\n\tenum sas_phy_type  type;\n\tenum sas_phy_role  role;\n\tenum sas_oob_mode  oob_mode;\n\tenum sas_linkrate linkrate;\n\n\tu8   *sas_addr;\t\t  /* must be set */\n\tu8   attached_sas_addr[SAS_ADDR_SIZE]; /* class:RO, driver: R/W */\n\n\tspinlock_t     frame_rcvd_lock;\n\tu8             *frame_rcvd; /* must be set */\n\tint            frame_rcvd_size;\n\n\tspinlock_t     sas_prim_lock;\n\tu32            sas_prim;\n\n\tstruct list_head port_phy_el; /* driver:RO */\n\tstruct asd_sas_port      *port; /* Class:RW, driver: RO */\n\n\tstruct sas_ha_struct *ha; /* may be set; the class sets it anyway */\n\n\tvoid *lldd_phy;\t\t  /* not touched by the sas_class_code */\n};\n\nstruct scsi_core {\n\tstruct Scsi_Host *shost;\n\n};\n\nenum sas_ha_state {\n\tSAS_HA_REGISTERED,\n\tSAS_HA_DRAINING,\n\tSAS_HA_ATA_EH_ACTIVE,\n\tSAS_HA_FROZEN,\n};\n\nstruct sas_ha_struct {\n/* private: */\n\tstruct list_head  defer_q; /* work queued while draining */\n\tstruct mutex\t  drain_mutex;\n\tunsigned long\t  state;\n\tspinlock_t\t  lock;\n\tint\t\t  eh_active;\n\twait_queue_head_t eh_wait_q;\n\tstruct list_head  eh_dev_q;\n\n\tstruct mutex disco_mutex;\n\n\tstruct scsi_core core;\n\n/* public: */\n\tchar *sas_ha_name;\n\tstruct device *dev;\t  /* should be set */\n\tstruct module *lldd_module; /* should be set */\n\n\tstruct workqueue_struct *event_q;\n\tstruct workqueue_struct *disco_q;\n\n\tu8 *sas_addr;\t\t  /* must be set */\n\tu8 hashed_sas_addr[HASHED_SAS_ADDR_SIZE];\n\n\tspinlock_t      phy_port_lock;\n\tstruct asd_sas_phy  **sas_phy; /* array of valid pointers, must be set */\n\tstruct asd_sas_port **sas_port; /* array of valid pointers, must be set */\n\tint             num_phys; /* must be set, gt 0, static */\n\n\tint strict_wide_ports; /* both sas_addr and attached_sas_addr must match\n\t\t\t\t* their siblings when forming wide ports */\n\n\t/* LLDD calls these to notify the class of an event. */\n\tint (*notify_port_event)(struct asd_sas_phy *, enum port_event);\n\tint (*notify_phy_event)(struct asd_sas_phy *, enum phy_event);\n\n\tvoid *lldd_ha;\t\t  /* not touched by sas class code */\n\n\tstruct list_head eh_done_q;  /* complete via scsi_eh_flush_done_q */\n\tstruct list_head eh_ata_q; /* scmds to promote from sas to ata eh */\n\n\tint event_thres;\n};\n\n#define SHOST_TO_SAS_HA(_shost) (*(struct sas_ha_struct **)(_shost)->hostdata)\n\nstatic inline struct domain_device *\nstarget_to_domain_dev(struct scsi_target *starget) {\n\treturn starget->hostdata;\n}\n\nstatic inline struct domain_device *\nsdev_to_domain_dev(struct scsi_device *sdev) {\n\treturn starget_to_domain_dev(sdev->sdev_target);\n}\n\nstatic inline struct ata_device *sas_to_ata_dev(struct domain_device *dev)\n{\n\treturn &dev->sata_dev.ap->link.device[0];\n}\n\nstatic inline struct domain_device *\ncmd_to_domain_dev(struct scsi_cmnd *cmd)\n{\n\treturn sdev_to_domain_dev(cmd->device);\n}\n\nvoid sas_hash_addr(u8 *hashed, const u8 *sas_addr);\n\n/* Before calling a notify event, LLDD should use this function\n * when the link is severed (possibly from its tasklet).\n * The idea is that the Class only reads those, while the LLDD,\n * can R/W these (thus avoiding a race).\n */\nstatic inline void sas_phy_disconnected(struct asd_sas_phy *phy)\n{\n\tphy->oob_mode = OOB_NOT_CONNECTED;\n\tphy->linkrate = SAS_LINK_RATE_UNKNOWN;\n}\n\nstatic inline unsigned int to_sas_gpio_od(int device, int bit)\n{\n\treturn 3 * device + bit;\n}\n\nstatic inline void sas_put_local_phy(struct sas_phy *phy)\n{\n\tput_device(&phy->dev);\n}\n\n#ifdef CONFIG_SCSI_SAS_HOST_SMP\nint try_test_sas_gpio_gp_bit(unsigned int od, u8 *data, u8 index, u8 count);\n#else\nstatic inline int try_test_sas_gpio_gp_bit(unsigned int od, u8 *data, u8 index, u8 count)\n{\n\treturn -1;\n}\n#endif\n\n/* ---------- Tasks ---------- */\n/*\n      service_response |  SAS_TASK_COMPLETE  |  SAS_TASK_UNDELIVERED |\n  exec_status          |                     |                       |\n  ---------------------+---------------------+-----------------------+\n       SAM_...         |         X           |                       |\n       DEV_NO_RESPONSE |         X           |           X           |\n       INTERRUPTED     |         X           |                       |\n       QUEUE_FULL      |                     |           X           |\n       DEVICE_UNKNOWN  |                     |           X           |\n       SG_ERR          |                     |           X           |\n  ---------------------+---------------------+-----------------------+\n */\n\nenum service_response {\n\tSAS_TASK_COMPLETE,\n\tSAS_TASK_UNDELIVERED = -1,\n};\n\nenum exec_status {\n\t/* The SAM_STAT_.. codes fit in the lower 6 bits, alias some of\n\t * them here to silence 'case value not in enumerated type' warnings\n\t */\n\t__SAM_STAT_CHECK_CONDITION = SAM_STAT_CHECK_CONDITION,\n\n\tSAS_DEV_NO_RESPONSE = 0x80,\n\tSAS_DATA_UNDERRUN,\n\tSAS_DATA_OVERRUN,\n\tSAS_INTERRUPTED,\n\tSAS_QUEUE_FULL,\n\tSAS_DEVICE_UNKNOWN,\n\tSAS_SG_ERR,\n\tSAS_OPEN_REJECT,\n\tSAS_OPEN_TO,\n\tSAS_PROTO_RESPONSE,\n\tSAS_PHY_DOWN,\n\tSAS_NAK_R_ERR,\n\tSAS_PENDING,\n\tSAS_ABORTED_TASK,\n};\n\n/* When a task finishes with a response, the LLDD examines the\n * response:\n * \t- For an ATA task task_status_struct::stat is set to\n * SAS_PROTO_RESPONSE, and the task_status_struct::buf is set to the\n * contents of struct ata_task_resp.\n * \t- For SSP tasks, if no data is present or status/TMF response\n * is valid, task_status_struct::stat is set.  If data is present\n * (SENSE data), the LLDD copies up to SAS_STATUS_BUF_SIZE, sets\n * task_status_struct::buf_valid_size, and task_status_struct::stat is\n * set to SAM_CHECK_COND.\n *\n * \"buf\" has format SCSI Sense for SSP task, or struct ata_task_resp\n * for ATA task.\n *\n * \"frame_len\" is the total frame length, which could be more or less\n * than actually copied.\n *\n * Tasks ending with response, always set the residual field.\n */\nstruct ata_task_resp {\n\tu16  frame_len;\n\tu8   ending_fis[ATA_RESP_FIS_SIZE];\t  /* dev to host or data-in */\n};\n\n#define SAS_STATUS_BUF_SIZE 96\n\nstruct task_status_struct {\n\tenum service_response resp;\n\tenum exec_status      stat;\n\tint  buf_valid_size;\n\n\tu8   buf[SAS_STATUS_BUF_SIZE];\n\n\tu32  residual;\n\tenum sas_open_rej_reason open_rej_reason;\n};\n\n/* ATA and ATAPI task queuable to a SAS LLDD.\n */\nstruct sas_ata_task {\n\tstruct host_to_dev_fis fis;\n\tu8     atapi_packet[16];  /* 0 if not ATAPI task */\n\n\tu8     retry_count;\t  /* hardware retry, should be > 0 */\n\n\tu8     dma_xfer:1;\t  /* PIO:0 or DMA:1 */\n\tu8     use_ncq:1;\n\tu8     set_affil_pol:1;\n\tu8     stp_affil_pol:1;\n\n\tu8     device_control_reg_update:1;\n};\n\nstruct sas_smp_task {\n\tstruct scatterlist smp_req;\n\tstruct scatterlist smp_resp;\n};\n\nenum task_attribute {\n\tTASK_ATTR_SIMPLE = 0,\n\tTASK_ATTR_HOQ    = 1,\n\tTASK_ATTR_ORDERED= 2,\n\tTASK_ATTR_ACA    = 4,\n};\n\nstruct sas_ssp_task {\n\tu8     retry_count;\t  /* hardware retry, should be > 0 */\n\n\tu8     LUN[8];\n\tu8     enable_first_burst:1;\n\tenum   task_attribute task_attr;\n\tu8     task_prio;\n\tstruct scsi_cmnd *cmd;\n};\n\nstruct sas_task {\n\tstruct domain_device *dev;\n\n\tspinlock_t   task_state_lock;\n\tunsigned     task_state_flags;\n\n\tenum   sas_protocol      task_proto;\n\n\tunion {\n\t\tstruct sas_ata_task ata_task;\n\t\tstruct sas_smp_task smp_task;\n\t\tstruct sas_ssp_task ssp_task;\n\t};\n\n\tstruct scatterlist *scatter;\n\tint    num_scatter;\n\tu32    total_xfer_len;\n\tu8     data_dir:2;\t  /* Use PCI_DMA_... */\n\n\tstruct task_status_struct task_status;\n\tvoid   (*task_done)(struct sas_task *);\n\n\tvoid   *lldd_task;\t  /* for use by LLDDs */\n\tvoid   *uldd_task;\n\tstruct sas_task_slow *slow_task;\n};\n\nstruct sas_task_slow {\n\t/* standard/extra infrastructure for slow path commands (SMP and\n\t * internal lldd commands\n\t */\n\tstruct timer_list     timer;\n\tstruct completion     completion;\n\tstruct sas_task       *task;\n};\n\n#define SAS_TASK_STATE_PENDING      1\n#define SAS_TASK_STATE_DONE         2\n#define SAS_TASK_STATE_ABORTED      4\n#define SAS_TASK_NEED_DEV_RESET     8\n#define SAS_TASK_AT_INITIATOR       16\n\nextern struct sas_task *sas_alloc_task(gfp_t flags);\nextern struct sas_task *sas_alloc_slow_task(gfp_t flags);\nextern void sas_free_task(struct sas_task *task);\n\nstruct sas_domain_function_template {\n\t/* The class calls these to notify the LLDD of an event. */\n\tvoid (*lldd_port_formed)(struct asd_sas_phy *);\n\tvoid (*lldd_port_deformed)(struct asd_sas_phy *);\n\n\t/* The class calls these when a device is found or gone. */\n\tint  (*lldd_dev_found)(struct domain_device *);\n\tvoid (*lldd_dev_gone)(struct domain_device *);\n\n\tint (*lldd_execute_task)(struct sas_task *, gfp_t gfp_flags);\n\n\t/* Task Management Functions. Must be called from process context. */\n\tint (*lldd_abort_task)(struct sas_task *);\n\tint (*lldd_abort_task_set)(struct domain_device *, u8 *lun);\n\tint (*lldd_clear_aca)(struct domain_device *, u8 *lun);\n\tint (*lldd_clear_task_set)(struct domain_device *, u8 *lun);\n\tint (*lldd_I_T_nexus_reset)(struct domain_device *);\n\tint (*lldd_ata_check_ready)(struct domain_device *);\n\tvoid (*lldd_ata_set_dmamode)(struct domain_device *);\n\tint (*lldd_lu_reset)(struct domain_device *, u8 *lun);\n\tint (*lldd_query_task)(struct sas_task *);\n\n\t/* Port and Adapter management */\n\tint (*lldd_clear_nexus_port)(struct asd_sas_port *);\n\tint (*lldd_clear_nexus_ha)(struct sas_ha_struct *);\n\n\t/* Phy management */\n\tint (*lldd_control_phy)(struct asd_sas_phy *, enum phy_func, void *);\n\n\t/* GPIO support */\n\tint (*lldd_write_gpio)(struct sas_ha_struct *, u8 reg_type,\n\t\t\t       u8 reg_index, u8 reg_count, u8 *write_data);\n};\n\nextern int sas_register_ha(struct sas_ha_struct *);\nextern int sas_unregister_ha(struct sas_ha_struct *);\nextern void sas_prep_resume_ha(struct sas_ha_struct *sas_ha);\nextern void sas_resume_ha(struct sas_ha_struct *sas_ha);\nextern void sas_suspend_ha(struct sas_ha_struct *sas_ha);\n\nint sas_set_phy_speed(struct sas_phy *phy,\n\t\t      struct sas_phy_linkrates *rates);\nint sas_phy_reset(struct sas_phy *phy, int hard_reset);\nextern int sas_queuecommand(struct Scsi_Host * ,struct scsi_cmnd *);\nextern int sas_target_alloc(struct scsi_target *);\nextern int sas_slave_configure(struct scsi_device *);\nextern int sas_change_queue_depth(struct scsi_device *, int new_depth);\nextern int sas_bios_param(struct scsi_device *,\n\t\t\t  struct block_device *,\n\t\t\t  sector_t capacity, int *hsc);\nextern struct scsi_transport_template *\nsas_domain_attach_transport(struct sas_domain_function_template *);\nextern struct device_attribute dev_attr_phy_event_threshold;\n\nint  sas_discover_root_expander(struct domain_device *);\n\nvoid sas_init_ex_attr(void);\n\nint  sas_ex_revalidate_domain(struct domain_device *);\n\nvoid sas_unregister_domain_devices(struct asd_sas_port *port, int gone);\nvoid sas_init_disc(struct sas_discovery *disc, struct asd_sas_port *);\nint  sas_discover_event(struct asd_sas_port *, enum discover_event ev);\n\nint  sas_discover_sata(struct domain_device *);\nint  sas_discover_end_dev(struct domain_device *);\n\nvoid sas_unregister_dev(struct asd_sas_port *port, struct domain_device *);\n\nvoid sas_init_dev(struct domain_device *);\n\nvoid sas_task_abort(struct sas_task *);\nint sas_eh_abort_handler(struct scsi_cmnd *cmd);\nint sas_eh_device_reset_handler(struct scsi_cmnd *cmd);\nint sas_eh_target_reset_handler(struct scsi_cmnd *cmd);\n\nextern void sas_target_destroy(struct scsi_target *);\nextern int sas_slave_alloc(struct scsi_device *);\nextern int sas_ioctl(struct scsi_device *sdev, int cmd, void __user *arg);\nextern int sas_drain_work(struct sas_ha_struct *ha);\n\nextern void sas_ssp_task_response(struct device *dev, struct sas_task *task,\n\t\t\t\t  struct ssp_response_iu *iu);\nstruct sas_phy *sas_get_local_phy(struct domain_device *dev);\n\nint sas_request_addr(struct Scsi_Host *shost, u8 *addr);\n\n#endif /* _SASLIB_H_ */\n", "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef SCSI_TRANSPORT_SAS_H\n#define SCSI_TRANSPORT_SAS_H\n\n#include <linux/transport_class.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <scsi/sas.h>\n#include <linux/bsg-lib.h>\n\nstruct scsi_transport_template;\nstruct sas_rphy;\nstruct request;\n\n#if !IS_ENABLED(CONFIG_SCSI_SAS_ATTRS)\nstatic inline int scsi_is_sas_rphy(const struct device *sdev)\n{\n\treturn 0;\n}\n#else\nextern int scsi_is_sas_rphy(const struct device *);\n#endif\n\nstatic inline int sas_protocol_ata(enum sas_protocol proto)\n{\n\treturn ((proto & SAS_PROTOCOL_SATA) ||\n\t\t(proto & SAS_PROTOCOL_STP))? 1 : 0;\n}\n\nenum sas_linkrate {\n\t/* These Values are defined in the SAS standard */\n\tSAS_LINK_RATE_UNKNOWN = 0,\n\tSAS_PHY_DISABLED = 1,\n\tSAS_PHY_RESET_PROBLEM = 2,\n\tSAS_SATA_SPINUP_HOLD = 3,\n\tSAS_SATA_PORT_SELECTOR = 4,\n\tSAS_PHY_RESET_IN_PROGRESS = 5,\n\tSAS_LINK_RATE_1_5_GBPS = 8,\n\tSAS_LINK_RATE_G1 = SAS_LINK_RATE_1_5_GBPS,\n\tSAS_LINK_RATE_3_0_GBPS = 9,\n\tSAS_LINK_RATE_G2 = SAS_LINK_RATE_3_0_GBPS,\n\tSAS_LINK_RATE_6_0_GBPS = 10,\n\tSAS_LINK_RATE_12_0_GBPS = 11,\n\t/* These are virtual to the transport class and may never\n\t * be signalled normally since the standard defined field\n\t * is only 4 bits */\n\tSAS_LINK_RATE_FAILED = 0x10,\n\tSAS_PHY_VIRTUAL = 0x11,\n};\n\nstruct sas_identify {\n\tenum sas_device_type\tdevice_type;\n\tenum sas_protocol\tinitiator_port_protocols;\n\tenum sas_protocol\ttarget_port_protocols;\n\tu64\t\t\tsas_address;\n\tu8\t\t\tphy_identifier;\n};\n\nstruct sas_phy {\n\tstruct device\t\tdev;\n\tint\t\t\tnumber;\n\tint\t\t\tenabled;\n\n\t/* phy identification */\n\tstruct sas_identify\tidentify;\n\n\t/* phy attributes */\n\tenum sas_linkrate\tnegotiated_linkrate;\n\tenum sas_linkrate\tminimum_linkrate_hw;\n\tenum sas_linkrate\tminimum_linkrate;\n\tenum sas_linkrate\tmaximum_linkrate_hw;\n\tenum sas_linkrate\tmaximum_linkrate;\n\n\t/* link error statistics */\n\tu32\t\t\tinvalid_dword_count;\n\tu32\t\t\trunning_disparity_error_count;\n\tu32\t\t\tloss_of_dword_sync_count;\n\tu32\t\t\tphy_reset_problem_count;\n\n\t/* for the list of phys belonging to a port */\n\tstruct list_head\tport_siblings;\n\n\t/* available to the lldd */\n\tvoid\t\t\t*hostdata;\n};\n\n#define dev_to_phy(d) \\\n\tcontainer_of((d), struct sas_phy, dev)\n#define transport_class_to_phy(dev) \\\n\tdev_to_phy((dev)->parent)\n#define phy_to_shost(phy) \\\n\tdev_to_shost((phy)->dev.parent)\n\nstruct request_queue;\nstruct sas_rphy {\n\tstruct device\t\tdev;\n\tstruct sas_identify\tidentify;\n\tstruct list_head\tlist;\n\tstruct request_queue\t*q;\n\tu32\t\t\tscsi_target_id;\n};\n\n#define dev_to_rphy(d) \\\n\tcontainer_of((d), struct sas_rphy, dev)\n#define transport_class_to_rphy(dev) \\\n\tdev_to_rphy((dev)->parent)\n#define rphy_to_shost(rphy) \\\n\tdev_to_shost((rphy)->dev.parent)\n#define target_to_rphy(targ) \\\n\tdev_to_rphy((targ)->dev.parent)\n\nstruct sas_end_device {\n\tstruct sas_rphy\t\trphy;\n\t/* flags */\n\tunsigned\t\tready_led_meaning:1;\n\tunsigned\t\ttlr_supported:1;\n\tunsigned\t\ttlr_enabled:1;\n\t/* parameters */\n\tu16\t\t\tI_T_nexus_loss_timeout;\n\tu16\t\t\tinitiator_response_timeout;\n};\n#define rphy_to_end_device(r) \\\n\tcontainer_of((r), struct sas_end_device, rphy)\n\nstruct sas_expander_device {\n\tint    level;\n\tint    next_port_id;\n\n\t#define SAS_EXPANDER_VENDOR_ID_LEN\t8\n\tchar   vendor_id[SAS_EXPANDER_VENDOR_ID_LEN+1];\n\t#define SAS_EXPANDER_PRODUCT_ID_LEN\t16\n\tchar   product_id[SAS_EXPANDER_PRODUCT_ID_LEN+1];\n\t#define SAS_EXPANDER_PRODUCT_REV_LEN\t4\n\tchar   product_rev[SAS_EXPANDER_PRODUCT_REV_LEN+1];\n\t#define SAS_EXPANDER_COMPONENT_VENDOR_ID_LEN\t8\n\tchar   component_vendor_id[SAS_EXPANDER_COMPONENT_VENDOR_ID_LEN+1];\n\tu16    component_id;\n\tu8     component_revision_id;\n\n\tstruct sas_rphy\t\trphy;\n\n};\n#define rphy_to_expander_device(r) \\\n\tcontainer_of((r), struct sas_expander_device, rphy)\n\nstruct sas_port {\n\tstruct device\t\tdev;\n\n\tint\t\t\tport_identifier;\n\tint\t\t\tnum_phys;\n\t/* port flags */\n\tunsigned int\t\tis_backlink:1;\n\n\t/* the other end of the link */\n\tstruct sas_rphy\t\t*rphy;\n\n\tstruct mutex\t\tphy_list_mutex;\n\tstruct list_head\tphy_list;\n\tstruct list_head\tdel_list; /* libsas only */\n};\n\n#define dev_to_sas_port(d) \\\n\tcontainer_of((d), struct sas_port, dev)\n#define transport_class_to_sas_port(dev) \\\n\tdev_to_sas_port((dev)->parent)\n\nstruct sas_phy_linkrates {\n\tenum sas_linkrate maximum_linkrate;\n\tenum sas_linkrate minimum_linkrate;\n};\n\n/* The functions by which the transport class and the driver communicate */\nstruct sas_function_template {\n\tint (*get_linkerrors)(struct sas_phy *);\n\tint (*get_enclosure_identifier)(struct sas_rphy *, u64 *);\n\tint (*get_bay_identifier)(struct sas_rphy *);\n\tint (*phy_reset)(struct sas_phy *, int);\n\tint (*phy_enable)(struct sas_phy *, int);\n\tint (*phy_setup)(struct sas_phy *);\n\tvoid (*phy_release)(struct sas_phy *);\n\tint (*set_phy_speed)(struct sas_phy *, struct sas_phy_linkrates *);\n\tvoid (*smp_handler)(struct bsg_job *, struct Scsi_Host *,\n\t\t\tstruct sas_rphy *);\n};\n\n\nvoid sas_remove_children(struct device *);\nextern void sas_remove_host(struct Scsi_Host *);\n\nextern struct sas_phy *sas_phy_alloc(struct device *, int);\nextern void sas_phy_free(struct sas_phy *);\nextern int sas_phy_add(struct sas_phy *);\nextern void sas_phy_delete(struct sas_phy *);\nextern int scsi_is_sas_phy(const struct device *);\n\nu64 sas_get_address(struct scsi_device *);\nunsigned int sas_tlr_supported(struct scsi_device *);\nunsigned int sas_is_tlr_enabled(struct scsi_device *);\nvoid sas_disable_tlr(struct scsi_device *);\nvoid sas_enable_tlr(struct scsi_device *);\n\nextern struct sas_rphy *sas_end_device_alloc(struct sas_port *);\nextern struct sas_rphy *sas_expander_alloc(struct sas_port *, enum sas_device_type);\nvoid sas_rphy_free(struct sas_rphy *);\nextern int sas_rphy_add(struct sas_rphy *);\nextern void sas_rphy_remove(struct sas_rphy *);\nextern void sas_rphy_delete(struct sas_rphy *);\nextern void sas_rphy_unlink(struct sas_rphy *);\n\nstruct sas_port *sas_port_alloc(struct device *, int);\nstruct sas_port *sas_port_alloc_num(struct device *);\nint sas_port_add(struct sas_port *);\nvoid sas_port_free(struct sas_port *);\nvoid sas_port_delete(struct sas_port *);\nvoid sas_port_add_phy(struct sas_port *, struct sas_phy *);\nvoid sas_port_delete_phy(struct sas_port *, struct sas_phy *);\nvoid sas_port_mark_backlink(struct sas_port *);\nint scsi_is_sas_port(const struct device *);\nstruct sas_phy *sas_port_get_phy(struct sas_port *port);\nstatic inline void sas_port_put_phy(struct sas_phy *phy)\n{\n\tif (phy)\n\t\tput_device(&phy->dev);\n}\n\nextern struct scsi_transport_template *\nsas_attach_transport(struct sas_function_template *);\nextern void sas_release_transport(struct scsi_transport_template *);\nint sas_read_port_mode_page(struct scsi_device *);\n\nstatic inline int\nscsi_is_sas_expander_device(struct device *dev)\n{\n\tstruct sas_rphy *rphy;\n\tif (!scsi_is_sas_rphy(dev))\n\t\treturn 0;\n\trphy = dev_to_rphy(dev);\n\treturn rphy->identify.device_type == SAS_FANOUT_EXPANDER_DEVICE ||\n\t\trphy->identify.device_type == SAS_EDGE_EXPANDER_DEVICE;\n}\n\n#define scsi_is_sas_phy_local(phy)\tscsi_is_host_device((phy)->dev.parent)\n\n#endif /* SCSI_TRANSPORT_SAS_H */\n"], "filenames": ["drivers/scsi/libsas/sas_ata.c", "drivers/scsi/libsas/sas_discover.c", "drivers/scsi/libsas/sas_expander.c", "drivers/scsi/libsas/sas_internal.h", "drivers/scsi/libsas/sas_port.c", "include/scsi/libsas.h", "include/scsi/scsi_transport_sas.h"], "buggy_code_start_loc": [733, 215, 1919, 103, 68, 85, 158], "buggy_code_end_loc": [734, 585, 2142, 103, 319, 264, 158], "fixing_code_start_loc": [732, 215, 1919, 104, 69, 84, 159], "fixing_code_end_loc": [732, 588, 2139, 105, 323, 264, 160], "type": "NVD-CWE-noinfo", "message": "The Serial Attached SCSI (SAS) implementation in the Linux kernel through 4.15.9 mishandles a mutex within libsas, which allows local users to cause a denial of service (deadlock) by triggering certain error-handling code.", "other": {"cve": {"id": "CVE-2017-18232", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-15T04:29:00.227", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The Serial Attached SCSI (SAS) implementation in the Linux kernel through 4.15.9 mishandles a mutex within libsas, which allows local users to cause a denial of service (deadlock) by triggering certain error-handling code."}, {"lang": "es", "value": "La implementaci\u00f3n SAS (Serial Attached SCSI) en el kernel de Linux, hasta la versi\u00f3n 4.15.9, gestiona de manera incorrecta un mutex en libsas. Esto permite que usuarios locales provoquen una denegaci\u00f3n de servicio (deadlock) desencadenando cierto c\u00f3digo de gesti\u00f3n de errores."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.15.9", "matchCriteriaId": "9511E3E2-F4FD-42A1-941F-D47186F35DCB"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=0558f33c06bb910e2879e355192227a8e8f0219d", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/103423", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:3083", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:3096", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4163-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4163-2/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2018/dsa-4187", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d"}}