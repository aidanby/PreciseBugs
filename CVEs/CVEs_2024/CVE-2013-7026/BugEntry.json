{"buggy_code": ["/*\n * linux/ipc/shm.c\n * Copyright (C) 1992, 1993 Krishna Balasubramanian\n *\t Many improvements/fixes by Bruno Haible.\n * Replaced `struct shm_desc' by `struct vm_area_struct', July 1994.\n * Fixed the shm swap deallocation (shm_unuse()), August 1998 Andrea Arcangeli.\n *\n * /proc/sysvipc/shm support (c) 1999 Dragos Acostachioaie <dragos@iname.com>\n * BIGMEM support, Andrea Arcangeli <andrea@suse.de>\n * SMP thread shm, Jean-Luc Boyard <jean-luc.boyard@siemens.fr>\n * HIGHMEM support, Ingo Molnar <mingo@redhat.com>\n * Make shmmax, shmall, shmmni sysctl'able, Christoph Rohland <cr@sap.com>\n * Shared /dev/zero support, Kanoj Sarcar <kanoj@sgi.com>\n * Move the mm functionality over to mm/shmem.c, Christoph Rohland <cr@sap.com>\n *\n * support for audit of ipc object properties and permission changes\n * Dustin Kirkland <dustin.kirkland@us.ibm.com>\n *\n * namespaces support\n * OpenVZ, SWsoft Inc.\n * Pavel Emelianov <xemul@openvz.org>\n *\n * Better ipc lock (kern_ipc_perm.lock) handling\n * Davidlohr Bueso <davidlohr.bueso@hp.com>, June 2013.\n */\n\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/hugetlb.h>\n#include <linux/shm.h>\n#include <linux/init.h>\n#include <linux/file.h>\n#include <linux/mman.h>\n#include <linux/shmem_fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/seq_file.h>\n#include <linux/rwsem.h>\n#include <linux/nsproxy.h>\n#include <linux/mount.h>\n#include <linux/ipc_namespace.h>\n\n#include <asm/uaccess.h>\n\n#include \"util.h\"\n\nstruct shm_file_data {\n\tint id;\n\tstruct ipc_namespace *ns;\n\tstruct file *file;\n\tconst struct vm_operations_struct *vm_ops;\n};\n\n#define shm_file_data(file) (*((struct shm_file_data **)&(file)->private_data))\n\nstatic const struct file_operations shm_file_operations;\nstatic const struct vm_operations_struct shm_vm_ops;\n\n#define shm_ids(ns)\t((ns)->ids[IPC_SHM_IDS])\n\n#define shm_unlock(shp)\t\t\t\\\n\tipc_unlock(&(shp)->shm_perm)\n\nstatic int newseg(struct ipc_namespace *, struct ipc_params *);\nstatic void shm_open(struct vm_area_struct *vma);\nstatic void shm_close(struct vm_area_struct *vma);\nstatic void shm_destroy (struct ipc_namespace *ns, struct shmid_kernel *shp);\n#ifdef CONFIG_PROC_FS\nstatic int sysvipc_shm_proc_show(struct seq_file *s, void *it);\n#endif\n\nvoid shm_init_ns(struct ipc_namespace *ns)\n{\n\tns->shm_ctlmax = SHMMAX;\n\tns->shm_ctlall = SHMALL;\n\tns->shm_ctlmni = SHMMNI;\n\tns->shm_rmid_forced = 0;\n\tns->shm_tot = 0;\n\tipc_init_ids(&shm_ids(ns));\n}\n\n/*\n * Called with shm_ids.rwsem (writer) and the shp structure locked.\n * Only shm_ids.rwsem remains locked on exit.\n */\nstatic void do_shm_rmid(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp)\n{\n\tstruct shmid_kernel *shp;\n\tshp = container_of(ipcp, struct shmid_kernel, shm_perm);\n\n\tif (shp->shm_nattch){\n\t\tshp->shm_perm.mode |= SHM_DEST;\n\t\t/* Do not find it any more */\n\t\tshp->shm_perm.key = IPC_PRIVATE;\n\t\tshm_unlock(shp);\n\t} else\n\t\tshm_destroy(ns, shp);\n}\n\n#ifdef CONFIG_IPC_NS\nvoid shm_exit_ns(struct ipc_namespace *ns)\n{\n\tfree_ipcs(ns, &shm_ids(ns), do_shm_rmid);\n\tidr_destroy(&ns->ids[IPC_SHM_IDS].ipcs_idr);\n}\n#endif\n\nstatic int __init ipc_ns_init(void)\n{\n\tshm_init_ns(&init_ipc_ns);\n\treturn 0;\n}\n\npure_initcall(ipc_ns_init);\n\nvoid __init shm_init (void)\n{\n\tipc_init_proc_interface(\"sysvipc/shm\",\n#if BITS_PER_LONG <= 32\n\t\t\t\t\"       key      shmid perms       size  cpid  lpid nattch   uid   gid  cuid  cgid      atime      dtime      ctime        rss       swap\\n\",\n#else\n\t\t\t\t\"       key      shmid perms                  size  cpid  lpid nattch   uid   gid  cuid  cgid      atime      dtime      ctime                   rss                  swap\\n\",\n#endif\n\t\t\t\tIPC_SHM_IDS, sysvipc_shm_proc_show);\n}\n\nstatic inline struct shmid_kernel *shm_obtain_object(struct ipc_namespace *ns, int id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_obtain_object(&shm_ids(ns), id);\n\n\tif (IS_ERR(ipcp))\n\t\treturn ERR_CAST(ipcp);\n\n\treturn container_of(ipcp, struct shmid_kernel, shm_perm);\n}\n\nstatic inline struct shmid_kernel *shm_obtain_object_check(struct ipc_namespace *ns, int id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_obtain_object_check(&shm_ids(ns), id);\n\n\tif (IS_ERR(ipcp))\n\t\treturn ERR_CAST(ipcp);\n\n\treturn container_of(ipcp, struct shmid_kernel, shm_perm);\n}\n\n/*\n * shm_lock_(check_) routines are called in the paths where the rwsem\n * is not necessarily held.\n */\nstatic inline struct shmid_kernel *shm_lock(struct ipc_namespace *ns, int id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_lock(&shm_ids(ns), id);\n\n\tif (IS_ERR(ipcp))\n\t\treturn (struct shmid_kernel *)ipcp;\n\n\treturn container_of(ipcp, struct shmid_kernel, shm_perm);\n}\n\nstatic inline void shm_lock_by_ptr(struct shmid_kernel *ipcp)\n{\n\trcu_read_lock();\n\tipc_lock_object(&ipcp->shm_perm);\n}\n\nstatic void shm_rcu_free(struct rcu_head *head)\n{\n\tstruct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);\n\tstruct shmid_kernel *shp = ipc_rcu_to_struct(p);\n\n\tsecurity_shm_free(shp);\n\tipc_rcu_free(head);\n}\n\nstatic inline void shm_rmid(struct ipc_namespace *ns, struct shmid_kernel *s)\n{\n\tipc_rmid(&shm_ids(ns), &s->shm_perm);\n}\n\n\n/* This is called by fork, once for every shm attach. */\nstatic void shm_open(struct vm_area_struct *vma)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\tstruct shmid_kernel *shp;\n\n\tshp = shm_lock(sfd->ns, sfd->id);\n\tBUG_ON(IS_ERR(shp));\n\tshp->shm_atim = get_seconds();\n\tshp->shm_lprid = task_tgid_vnr(current);\n\tshp->shm_nattch++;\n\tshm_unlock(shp);\n}\n\n/*\n * shm_destroy - free the struct shmid_kernel\n *\n * @ns: namespace\n * @shp: struct to free\n *\n * It has to be called with shp and shm_ids.rwsem (writer) locked,\n * but returns with shp unlocked and freed.\n */\nstatic void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)\n{\n\tns->shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tshm_rmid(ns, shp);\n\tshm_unlock(shp);\n\tif (!is_file_hugepages(shp->shm_file))\n\t\tshmem_lock(shp->shm_file, 0, shp->mlock_user);\n\telse if (shp->mlock_user)\n\t\tuser_shm_unlock(file_inode(shp->shm_file)->i_size,\n\t\t\t\t\t\tshp->mlock_user);\n\tfput (shp->shm_file);\n\tipc_rcu_putref(shp, shm_rcu_free);\n}\n\n/*\n * shm_may_destroy - identifies whether shm segment should be destroyed now\n *\n * Returns true if and only if there are no active users of the segment and\n * one of the following is true:\n *\n * 1) shmctl(id, IPC_RMID, NULL) was called for this shp\n *\n * 2) sysctl kernel.shm_rmid_forced is set to 1.\n */\nstatic bool shm_may_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)\n{\n\treturn (shp->shm_nattch == 0) &&\n\t       (ns->shm_rmid_forced ||\n\t\t(shp->shm_perm.mode & SHM_DEST));\n}\n\n/*\n * remove the attach descriptor vma.\n * free memory for segment if it is marked destroyed.\n * The descriptor has already been removed from the current->mm->mmap list\n * and will later be kfree()d.\n */\nstatic void shm_close(struct vm_area_struct *vma)\n{\n\tstruct file * file = vma->vm_file;\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\tstruct shmid_kernel *shp;\n\tstruct ipc_namespace *ns = sfd->ns;\n\n\tdown_write(&shm_ids(ns).rwsem);\n\t/* remove from the list of attaches of the shm segment */\n\tshp = shm_lock(ns, sfd->id);\n\tBUG_ON(IS_ERR(shp));\n\tshp->shm_lprid = task_tgid_vnr(current);\n\tshp->shm_dtim = get_seconds();\n\tshp->shm_nattch--;\n\tif (shm_may_destroy(ns, shp))\n\t\tshm_destroy(ns, shp);\n\telse\n\t\tshm_unlock(shp);\n\tup_write(&shm_ids(ns).rwsem);\n}\n\n/* Called with ns->shm_ids(ns).rwsem locked */\nstatic int shm_try_destroy_current(int id, void *p, void *data)\n{\n\tstruct ipc_namespace *ns = data;\n\tstruct kern_ipc_perm *ipcp = p;\n\tstruct shmid_kernel *shp = container_of(ipcp, struct shmid_kernel, shm_perm);\n\n\tif (shp->shm_creator != current)\n\t\treturn 0;\n\n\t/*\n\t * Mark it as orphaned to destroy the segment when\n\t * kernel.shm_rmid_forced is changed.\n\t * It is noop if the following shm_may_destroy() returns true.\n\t */\n\tshp->shm_creator = NULL;\n\n\t/*\n\t * Don't even try to destroy it.  If shm_rmid_forced=0 and IPC_RMID\n\t * is not set, it shouldn't be deleted here.\n\t */\n\tif (!ns->shm_rmid_forced)\n\t\treturn 0;\n\n\tif (shm_may_destroy(ns, shp)) {\n\t\tshm_lock_by_ptr(shp);\n\t\tshm_destroy(ns, shp);\n\t}\n\treturn 0;\n}\n\n/* Called with ns->shm_ids(ns).rwsem locked */\nstatic int shm_try_destroy_orphaned(int id, void *p, void *data)\n{\n\tstruct ipc_namespace *ns = data;\n\tstruct kern_ipc_perm *ipcp = p;\n\tstruct shmid_kernel *shp = container_of(ipcp, struct shmid_kernel, shm_perm);\n\n\t/*\n\t * We want to destroy segments without users and with already\n\t * exit'ed originating process.\n\t *\n\t * As shp->* are changed under rwsem, it's safe to skip shp locking.\n\t */\n\tif (shp->shm_creator != NULL)\n\t\treturn 0;\n\n\tif (shm_may_destroy(ns, shp)) {\n\t\tshm_lock_by_ptr(shp);\n\t\tshm_destroy(ns, shp);\n\t}\n\treturn 0;\n}\n\nvoid shm_destroy_orphaned(struct ipc_namespace *ns)\n{\n\tdown_write(&shm_ids(ns).rwsem);\n\tif (shm_ids(ns).in_use)\n\t\tidr_for_each(&shm_ids(ns).ipcs_idr, &shm_try_destroy_orphaned, ns);\n\tup_write(&shm_ids(ns).rwsem);\n}\n\n\nvoid exit_shm(struct task_struct *task)\n{\n\tstruct ipc_namespace *ns = task->nsproxy->ipc_ns;\n\n\tif (shm_ids(ns).in_use == 0)\n\t\treturn;\n\n\t/* Destroy all already created segments, but not mapped yet */\n\tdown_write(&shm_ids(ns).rwsem);\n\tif (shm_ids(ns).in_use)\n\t\tidr_for_each(&shm_ids(ns).ipcs_idr, &shm_try_destroy_current, ns);\n\tup_write(&shm_ids(ns).rwsem);\n}\n\nstatic int shm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\n\treturn sfd->vm_ops->fault(vma, vmf);\n}\n\n#ifdef CONFIG_NUMA\nstatic int shm_set_policy(struct vm_area_struct *vma, struct mempolicy *new)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\tint err = 0;\n\tif (sfd->vm_ops->set_policy)\n\t\terr = sfd->vm_ops->set_policy(vma, new);\n\treturn err;\n}\n\nstatic struct mempolicy *shm_get_policy(struct vm_area_struct *vma,\n\t\t\t\t\tunsigned long addr)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\tstruct mempolicy *pol = NULL;\n\n\tif (sfd->vm_ops->get_policy)\n\t\tpol = sfd->vm_ops->get_policy(vma, addr);\n\telse if (vma->vm_policy)\n\t\tpol = vma->vm_policy;\n\n\treturn pol;\n}\n#endif\n\nstatic int shm_mmap(struct file * file, struct vm_area_struct * vma)\n{\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\tint ret;\n\n\tret = sfd->file->f_op->mmap(sfd->file, vma);\n\tif (ret != 0)\n\t\treturn ret;\n\tsfd->vm_ops = vma->vm_ops;\n#ifdef CONFIG_MMU\n\tBUG_ON(!sfd->vm_ops->fault);\n#endif\n\tvma->vm_ops = &shm_vm_ops;\n\tshm_open(vma);\n\n\treturn ret;\n}\n\nstatic int shm_release(struct inode *ino, struct file *file)\n{\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\n\tput_ipc_ns(sfd->ns);\n\tshm_file_data(file) = NULL;\n\tkfree(sfd);\n\treturn 0;\n}\n\nstatic int shm_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\n\tif (!sfd->file->f_op->fsync)\n\t\treturn -EINVAL;\n\treturn sfd->file->f_op->fsync(sfd->file, start, end, datasync);\n}\n\nstatic long shm_fallocate(struct file *file, int mode, loff_t offset,\n\t\t\t  loff_t len)\n{\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\n\tif (!sfd->file->f_op->fallocate)\n\t\treturn -EOPNOTSUPP;\n\treturn sfd->file->f_op->fallocate(file, mode, offset, len);\n}\n\nstatic unsigned long shm_get_unmapped_area(struct file *file,\n\tunsigned long addr, unsigned long len, unsigned long pgoff,\n\tunsigned long flags)\n{\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\treturn sfd->file->f_op->get_unmapped_area(sfd->file, addr, len,\n\t\t\t\t\t\tpgoff, flags);\n}\n\nstatic const struct file_operations shm_file_operations = {\n\t.mmap\t\t= shm_mmap,\n\t.fsync\t\t= shm_fsync,\n\t.release\t= shm_release,\n#ifndef CONFIG_MMU\n\t.get_unmapped_area\t= shm_get_unmapped_area,\n#endif\n\t.llseek\t\t= noop_llseek,\n\t.fallocate\t= shm_fallocate,\n};\n\nstatic const struct file_operations shm_file_operations_huge = {\n\t.mmap\t\t= shm_mmap,\n\t.fsync\t\t= shm_fsync,\n\t.release\t= shm_release,\n\t.get_unmapped_area\t= shm_get_unmapped_area,\n\t.llseek\t\t= noop_llseek,\n\t.fallocate\t= shm_fallocate,\n};\n\nint is_file_shm_hugepages(struct file *file)\n{\n\treturn file->f_op == &shm_file_operations_huge;\n}\n\nstatic const struct vm_operations_struct shm_vm_ops = {\n\t.open\t= shm_open,\t/* callback for a new vm-area open */\n\t.close\t= shm_close,\t/* callback for when the vm-area is released */\n\t.fault\t= shm_fault,\n#if defined(CONFIG_NUMA)\n\t.set_policy = shm_set_policy,\n\t.get_policy = shm_get_policy,\n#endif\n};\n\n/**\n * newseg - Create a new shared memory segment\n * @ns: namespace\n * @params: ptr to the structure that contains key, size and shmflg\n *\n * Called with shm_ids.rwsem held as a writer.\n */\n\nstatic int newseg(struct ipc_namespace *ns, struct ipc_params *params)\n{\n\tkey_t key = params->key;\n\tint shmflg = params->flg;\n\tsize_t size = params->u.size;\n\tint error;\n\tstruct shmid_kernel *shp;\n\tsize_t numpages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tstruct file * file;\n\tchar name[13];\n\tint id;\n\tvm_flags_t acctflag = 0;\n\n\tif (size < SHMMIN || size > ns->shm_ctlmax)\n\t\treturn -EINVAL;\n\n\tif (ns->shm_tot + numpages > ns->shm_ctlall)\n\t\treturn -ENOSPC;\n\n\tshp = ipc_rcu_alloc(sizeof(*shp));\n\tif (!shp)\n\t\treturn -ENOMEM;\n\n\tshp->shm_perm.key = key;\n\tshp->shm_perm.mode = (shmflg & S_IRWXUGO);\n\tshp->mlock_user = NULL;\n\n\tshp->shm_perm.security = NULL;\n\terror = security_shm_alloc(shp);\n\tif (error) {\n\t\tipc_rcu_putref(shp, ipc_rcu_free);\n\t\treturn error;\n\t}\n\n\tsprintf (name, \"SYSV%08x\", key);\n\tif (shmflg & SHM_HUGETLB) {\n\t\tstruct hstate *hs;\n\t\tsize_t hugesize;\n\n\t\ths = hstate_sizelog((shmflg >> SHM_HUGE_SHIFT) & SHM_HUGE_MASK);\n\t\tif (!hs) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto no_file;\n\t\t}\n\t\thugesize = ALIGN(size, huge_page_size(hs));\n\n\t\t/* hugetlb_file_setup applies strict accounting */\n\t\tif (shmflg & SHM_NORESERVE)\n\t\t\tacctflag = VM_NORESERVE;\n\t\tfile = hugetlb_file_setup(name, hugesize, acctflag,\n\t\t\t\t  &shp->mlock_user, HUGETLB_SHMFS_INODE,\n\t\t\t\t(shmflg >> SHM_HUGE_SHIFT) & SHM_HUGE_MASK);\n\t} else {\n\t\t/*\n\t\t * Do not allow no accounting for OVERCOMMIT_NEVER, even\n\t \t * if it's asked for.\n\t\t */\n\t\tif  ((shmflg & SHM_NORESERVE) &&\n\t\t\t\tsysctl_overcommit_memory != OVERCOMMIT_NEVER)\n\t\t\tacctflag = VM_NORESERVE;\n\t\tfile = shmem_file_setup(name, size, acctflag);\n\t}\n\terror = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto no_file;\n\n\tid = ipc_addid(&shm_ids(ns), &shp->shm_perm, ns->shm_ctlmni);\n\tif (id < 0) {\n\t\terror = id;\n\t\tgoto no_id;\n\t}\n\n\tshp->shm_cprid = task_tgid_vnr(current);\n\tshp->shm_lprid = 0;\n\tshp->shm_atim = shp->shm_dtim = 0;\n\tshp->shm_ctim = get_seconds();\n\tshp->shm_segsz = size;\n\tshp->shm_nattch = 0;\n\tshp->shm_file = file;\n\tshp->shm_creator = current;\n\n\t/*\n\t * shmid gets reported as \"inode#\" in /proc/pid/maps.\n\t * proc-ps tools use this. Changing this will break them.\n\t */\n\tfile_inode(file)->i_ino = shp->shm_perm.id;\n\n\tns->shm_tot += numpages;\n\terror = shp->shm_perm.id;\n\n\tipc_unlock_object(&shp->shm_perm);\n\trcu_read_unlock();\n\treturn error;\n\nno_id:\n\tif (is_file_hugepages(file) && shp->mlock_user)\n\t\tuser_shm_unlock(size, shp->mlock_user);\n\tfput(file);\nno_file:\n\tipc_rcu_putref(shp, shm_rcu_free);\n\treturn error;\n}\n\n/*\n * Called with shm_ids.rwsem and ipcp locked.\n */\nstatic inline int shm_security(struct kern_ipc_perm *ipcp, int shmflg)\n{\n\tstruct shmid_kernel *shp;\n\n\tshp = container_of(ipcp, struct shmid_kernel, shm_perm);\n\treturn security_shm_associate(shp, shmflg);\n}\n\n/*\n * Called with shm_ids.rwsem and ipcp locked.\n */\nstatic inline int shm_more_checks(struct kern_ipc_perm *ipcp,\n\t\t\t\tstruct ipc_params *params)\n{\n\tstruct shmid_kernel *shp;\n\n\tshp = container_of(ipcp, struct shmid_kernel, shm_perm);\n\tif (shp->shm_segsz < params->u.size)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nSYSCALL_DEFINE3(shmget, key_t, key, size_t, size, int, shmflg)\n{\n\tstruct ipc_namespace *ns;\n\tstruct ipc_ops shm_ops;\n\tstruct ipc_params shm_params;\n\n\tns = current->nsproxy->ipc_ns;\n\n\tshm_ops.getnew = newseg;\n\tshm_ops.associate = shm_security;\n\tshm_ops.more_checks = shm_more_checks;\n\n\tshm_params.key = key;\n\tshm_params.flg = shmflg;\n\tshm_params.u.size = size;\n\n\treturn ipcget(ns, &shm_ids(ns), &shm_ops, &shm_params);\n}\n\nstatic inline unsigned long copy_shmid_to_user(void __user *buf, struct shmid64_ds *in, int version)\n{\n\tswitch(version) {\n\tcase IPC_64:\n\t\treturn copy_to_user(buf, in, sizeof(*in));\n\tcase IPC_OLD:\n\t    {\n\t\tstruct shmid_ds out;\n\n\t\tmemset(&out, 0, sizeof(out));\n\t\tipc64_perm_to_ipc_perm(&in->shm_perm, &out.shm_perm);\n\t\tout.shm_segsz\t= in->shm_segsz;\n\t\tout.shm_atime\t= in->shm_atime;\n\t\tout.shm_dtime\t= in->shm_dtime;\n\t\tout.shm_ctime\t= in->shm_ctime;\n\t\tout.shm_cpid\t= in->shm_cpid;\n\t\tout.shm_lpid\t= in->shm_lpid;\n\t\tout.shm_nattch\t= in->shm_nattch;\n\n\t\treturn copy_to_user(buf, &out, sizeof(out));\n\t    }\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic inline unsigned long\ncopy_shmid_from_user(struct shmid64_ds *out, void __user *buf, int version)\n{\n\tswitch(version) {\n\tcase IPC_64:\n\t\tif (copy_from_user(out, buf, sizeof(*out)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase IPC_OLD:\n\t    {\n\t\tstruct shmid_ds tbuf_old;\n\n\t\tif (copy_from_user(&tbuf_old, buf, sizeof(tbuf_old)))\n\t\t\treturn -EFAULT;\n\n\t\tout->shm_perm.uid\t= tbuf_old.shm_perm.uid;\n\t\tout->shm_perm.gid\t= tbuf_old.shm_perm.gid;\n\t\tout->shm_perm.mode\t= tbuf_old.shm_perm.mode;\n\n\t\treturn 0;\n\t    }\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic inline unsigned long copy_shminfo_to_user(void __user *buf, struct shminfo64 *in, int version)\n{\n\tswitch(version) {\n\tcase IPC_64:\n\t\treturn copy_to_user(buf, in, sizeof(*in));\n\tcase IPC_OLD:\n\t    {\n\t\tstruct shminfo out;\n\n\t\tif(in->shmmax > INT_MAX)\n\t\t\tout.shmmax = INT_MAX;\n\t\telse\n\t\t\tout.shmmax = (int)in->shmmax;\n\n\t\tout.shmmin\t= in->shmmin;\n\t\tout.shmmni\t= in->shmmni;\n\t\tout.shmseg\t= in->shmseg;\n\t\tout.shmall\t= in->shmall; \n\n\t\treturn copy_to_user(buf, &out, sizeof(out));\n\t    }\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/*\n * Calculate and add used RSS and swap pages of a shm.\n * Called with shm_ids.rwsem held as a reader\n */\nstatic void shm_add_rss_swap(struct shmid_kernel *shp,\n\tunsigned long *rss_add, unsigned long *swp_add)\n{\n\tstruct inode *inode;\n\n\tinode = file_inode(shp->shm_file);\n\n\tif (is_file_hugepages(shp->shm_file)) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct hstate *h = hstate_file(shp->shm_file);\n\t\t*rss_add += pages_per_huge_page(h) * mapping->nrpages;\n\t} else {\n#ifdef CONFIG_SHMEM\n\t\tstruct shmem_inode_info *info = SHMEM_I(inode);\n\t\tspin_lock(&info->lock);\n\t\t*rss_add += inode->i_mapping->nrpages;\n\t\t*swp_add += info->swapped;\n\t\tspin_unlock(&info->lock);\n#else\n\t\t*rss_add += inode->i_mapping->nrpages;\n#endif\n\t}\n}\n\n/*\n * Called with shm_ids.rwsem held as a reader\n */\nstatic void shm_get_stat(struct ipc_namespace *ns, unsigned long *rss,\n\t\tunsigned long *swp)\n{\n\tint next_id;\n\tint total, in_use;\n\n\t*rss = 0;\n\t*swp = 0;\n\n\tin_use = shm_ids(ns).in_use;\n\n\tfor (total = 0, next_id = 0; total < in_use; next_id++) {\n\t\tstruct kern_ipc_perm *ipc;\n\t\tstruct shmid_kernel *shp;\n\n\t\tipc = idr_find(&shm_ids(ns).ipcs_idr, next_id);\n\t\tif (ipc == NULL)\n\t\t\tcontinue;\n\t\tshp = container_of(ipc, struct shmid_kernel, shm_perm);\n\n\t\tshm_add_rss_swap(shp, rss, swp);\n\n\t\ttotal++;\n\t}\n}\n\n/*\n * This function handles some shmctl commands which require the rwsem\n * to be held in write mode.\n * NOTE: no locks must be held, the rwsem is taken inside this function.\n */\nstatic int shmctl_down(struct ipc_namespace *ns, int shmid, int cmd,\n\t\t       struct shmid_ds __user *buf, int version)\n{\n\tstruct kern_ipc_perm *ipcp;\n\tstruct shmid64_ds shmid64;\n\tstruct shmid_kernel *shp;\n\tint err;\n\n\tif (cmd == IPC_SET) {\n\t\tif (copy_shmid_from_user(&shmid64, buf, version))\n\t\t\treturn -EFAULT;\n\t}\n\n\tdown_write(&shm_ids(ns).rwsem);\n\trcu_read_lock();\n\n\tipcp = ipcctl_pre_down_nolock(ns, &shm_ids(ns), shmid, cmd,\n\t\t\t\t      &shmid64.shm_perm, 0);\n\tif (IS_ERR(ipcp)) {\n\t\terr = PTR_ERR(ipcp);\n\t\tgoto out_unlock1;\n\t}\n\n\tshp = container_of(ipcp, struct shmid_kernel, shm_perm);\n\n\terr = security_shm_shmctl(shp, cmd);\n\tif (err)\n\t\tgoto out_unlock1;\n\n\tswitch (cmd) {\n\tcase IPC_RMID:\n\t\tipc_lock_object(&shp->shm_perm);\n\t\t/* do_shm_rmid unlocks the ipc object and rcu */\n\t\tdo_shm_rmid(ns, ipcp);\n\t\tgoto out_up;\n\tcase IPC_SET:\n\t\tipc_lock_object(&shp->shm_perm);\n\t\terr = ipc_update_perm(&shmid64.shm_perm, ipcp);\n\t\tif (err)\n\t\t\tgoto out_unlock0;\n\t\tshp->shm_ctim = get_seconds();\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out_unlock1;\n\t}\n\nout_unlock0:\n\tipc_unlock_object(&shp->shm_perm);\nout_unlock1:\n\trcu_read_unlock();\nout_up:\n\tup_write(&shm_ids(ns).rwsem);\n\treturn err;\n}\n\nstatic int shmctl_nolock(struct ipc_namespace *ns, int shmid,\n\t\t\t int cmd, int version, void __user *buf)\n{\n\tint err;\n\tstruct shmid_kernel *shp;\n\n\t/* preliminary security checks for *_INFO */\n\tif (cmd == IPC_INFO || cmd == SHM_INFO) {\n\t\terr = security_shm_shmctl(NULL, cmd);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tswitch (cmd) {\n\tcase IPC_INFO:\n\t{\n\t\tstruct shminfo64 shminfo;\n\n\t\tmemset(&shminfo, 0, sizeof(shminfo));\n\t\tshminfo.shmmni = shminfo.shmseg = ns->shm_ctlmni;\n\t\tshminfo.shmmax = ns->shm_ctlmax;\n\t\tshminfo.shmall = ns->shm_ctlall;\n\n\t\tshminfo.shmmin = SHMMIN;\n\t\tif(copy_shminfo_to_user (buf, &shminfo, version))\n\t\t\treturn -EFAULT;\n\n\t\tdown_read(&shm_ids(ns).rwsem);\n\t\terr = ipc_get_maxid(&shm_ids(ns));\n\t\tup_read(&shm_ids(ns).rwsem);\n\n\t\tif(err<0)\n\t\t\terr = 0;\n\t\tgoto out;\n\t}\n\tcase SHM_INFO:\n\t{\n\t\tstruct shm_info shm_info;\n\n\t\tmemset(&shm_info, 0, sizeof(shm_info));\n\t\tdown_read(&shm_ids(ns).rwsem);\n\t\tshm_info.used_ids = shm_ids(ns).in_use;\n\t\tshm_get_stat (ns, &shm_info.shm_rss, &shm_info.shm_swp);\n\t\tshm_info.shm_tot = ns->shm_tot;\n\t\tshm_info.swap_attempts = 0;\n\t\tshm_info.swap_successes = 0;\n\t\terr = ipc_get_maxid(&shm_ids(ns));\n\t\tup_read(&shm_ids(ns).rwsem);\n\t\tif (copy_to_user(buf, &shm_info, sizeof(shm_info))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = err < 0 ? 0 : err;\n\t\tgoto out;\n\t}\n\tcase SHM_STAT:\n\tcase IPC_STAT:\n\t{\n\t\tstruct shmid64_ds tbuf;\n\t\tint result;\n\n\t\trcu_read_lock();\n\t\tif (cmd == SHM_STAT) {\n\t\t\tshp = shm_obtain_object(ns, shmid);\n\t\t\tif (IS_ERR(shp)) {\n\t\t\t\terr = PTR_ERR(shp);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tresult = shp->shm_perm.id;\n\t\t} else {\n\t\t\tshp = shm_obtain_object_check(ns, shmid);\n\t\t\tif (IS_ERR(shp)) {\n\t\t\t\terr = PTR_ERR(shp);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tresult = 0;\n\t\t}\n\n\t\terr = -EACCES;\n\t\tif (ipcperms(ns, &shp->shm_perm, S_IRUGO))\n\t\t\tgoto out_unlock;\n\n\t\terr = security_shm_shmctl(shp, cmd);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\n\t\tmemset(&tbuf, 0, sizeof(tbuf));\n\t\tkernel_to_ipc64_perm(&shp->shm_perm, &tbuf.shm_perm);\n\t\ttbuf.shm_segsz\t= shp->shm_segsz;\n\t\ttbuf.shm_atime\t= shp->shm_atim;\n\t\ttbuf.shm_dtime\t= shp->shm_dtim;\n\t\ttbuf.shm_ctime\t= shp->shm_ctim;\n\t\ttbuf.shm_cpid\t= shp->shm_cprid;\n\t\ttbuf.shm_lpid\t= shp->shm_lprid;\n\t\ttbuf.shm_nattch\t= shp->shm_nattch;\n\t\trcu_read_unlock();\n\n\t\tif (copy_shmid_to_user(buf, &tbuf, version))\n\t\t\terr = -EFAULT;\n\t\telse\n\t\t\terr = result;\n\t\tgoto out;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\nout_unlock:\n\trcu_read_unlock();\nout:\n\treturn err;\n}\n\nSYSCALL_DEFINE3(shmctl, int, shmid, int, cmd, struct shmid_ds __user *, buf)\n{\n\tstruct shmid_kernel *shp;\n\tint err, version;\n\tstruct ipc_namespace *ns;\n\n\tif (cmd < 0 || shmid < 0)\n\t\treturn -EINVAL;\n\n\tversion = ipc_parse_version(&cmd);\n\tns = current->nsproxy->ipc_ns;\n\n\tswitch (cmd) {\n\tcase IPC_INFO:\n\tcase SHM_INFO:\n\tcase SHM_STAT:\n\tcase IPC_STAT:\n\t\treturn shmctl_nolock(ns, shmid, cmd, version, buf);\n\tcase IPC_RMID:\n\tcase IPC_SET:\n\t\treturn shmctl_down(ns, shmid, cmd, buf, version);\n\tcase SHM_LOCK:\n\tcase SHM_UNLOCK:\n\t{\n\t\tstruct file *shm_file;\n\n\t\trcu_read_lock();\n\t\tshp = shm_obtain_object_check(ns, shmid);\n\t\tif (IS_ERR(shp)) {\n\t\t\terr = PTR_ERR(shp);\n\t\t\tgoto out_unlock1;\n\t\t}\n\n\t\taudit_ipc_obj(&(shp->shm_perm));\n\t\terr = security_shm_shmctl(shp, cmd);\n\t\tif (err)\n\t\t\tgoto out_unlock1;\n\n\t\tipc_lock_object(&shp->shm_perm);\n\t\tif (!ns_capable(ns->user_ns, CAP_IPC_LOCK)) {\n\t\t\tkuid_t euid = current_euid();\n\t\t\terr = -EPERM;\n\t\t\tif (!uid_eq(euid, shp->shm_perm.uid) &&\n\t\t\t    !uid_eq(euid, shp->shm_perm.cuid))\n\t\t\t\tgoto out_unlock0;\n\t\t\tif (cmd == SHM_LOCK && !rlimit(RLIMIT_MEMLOCK))\n\t\t\t\tgoto out_unlock0;\n\t\t}\n\n\t\tshm_file = shp->shm_file;\n\t\tif (is_file_hugepages(shm_file))\n\t\t\tgoto out_unlock0;\n\n\t\tif (cmd == SHM_LOCK) {\n\t\t\tstruct user_struct *user = current_user();\n\t\t\terr = shmem_lock(shm_file, 1, user);\n\t\t\tif (!err && !(shp->shm_perm.mode & SHM_LOCKED)) {\n\t\t\t\tshp->shm_perm.mode |= SHM_LOCKED;\n\t\t\t\tshp->mlock_user = user;\n\t\t\t}\n\t\t\tgoto out_unlock0;\n\t\t}\n\n\t\t/* SHM_UNLOCK */\n\t\tif (!(shp->shm_perm.mode & SHM_LOCKED))\n\t\t\tgoto out_unlock0;\n\t\tshmem_lock(shm_file, 0, shp->mlock_user);\n\t\tshp->shm_perm.mode &= ~SHM_LOCKED;\n\t\tshp->mlock_user = NULL;\n\t\tget_file(shm_file);\n\t\tipc_unlock_object(&shp->shm_perm);\n\t\trcu_read_unlock();\n\t\tshmem_unlock_mapping(shm_file->f_mapping);\n\n\t\tfput(shm_file);\n\t\treturn err;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\nout_unlock0:\n\tipc_unlock_object(&shp->shm_perm);\nout_unlock1:\n\trcu_read_unlock();\n\treturn err;\n}\n\n/*\n * Fix shmaddr, allocate descriptor, map shm, add attach descriptor to lists.\n *\n * NOTE! Despite the name, this is NOT a direct system call entrypoint. The\n * \"raddr\" thing points to kernel space, and there has to be a wrapper around\n * this.\n */\nlong do_shmat(int shmid, char __user *shmaddr, int shmflg, ulong *raddr,\n\t      unsigned long shmlba)\n{\n\tstruct shmid_kernel *shp;\n\tunsigned long addr;\n\tunsigned long size;\n\tstruct file * file;\n\tint    err;\n\tunsigned long flags;\n\tunsigned long prot;\n\tint acc_mode;\n\tstruct ipc_namespace *ns;\n\tstruct shm_file_data *sfd;\n\tstruct path path;\n\tfmode_t f_mode;\n\tunsigned long populate = 0;\n\n\terr = -EINVAL;\n\tif (shmid < 0)\n\t\tgoto out;\n\telse if ((addr = (ulong)shmaddr)) {\n\t\tif (addr & (shmlba - 1)) {\n\t\t\tif (shmflg & SHM_RND)\n\t\t\t\taddr &= ~(shmlba - 1);\t   /* round down */\n\t\t\telse\n#ifndef __ARCH_FORCE_SHMLBA\n\t\t\t\tif (addr & ~PAGE_MASK)\n#endif\n\t\t\t\t\tgoto out;\n\t\t}\n\t\tflags = MAP_SHARED | MAP_FIXED;\n\t} else {\n\t\tif ((shmflg & SHM_REMAP))\n\t\t\tgoto out;\n\n\t\tflags = MAP_SHARED;\n\t}\n\n\tif (shmflg & SHM_RDONLY) {\n\t\tprot = PROT_READ;\n\t\tacc_mode = S_IRUGO;\n\t\tf_mode = FMODE_READ;\n\t} else {\n\t\tprot = PROT_READ | PROT_WRITE;\n\t\tacc_mode = S_IRUGO | S_IWUGO;\n\t\tf_mode = FMODE_READ | FMODE_WRITE;\n\t}\n\tif (shmflg & SHM_EXEC) {\n\t\tprot |= PROT_EXEC;\n\t\tacc_mode |= S_IXUGO;\n\t}\n\n\t/*\n\t * We cannot rely on the fs check since SYSV IPC does have an\n\t * additional creator id...\n\t */\n\tns = current->nsproxy->ipc_ns;\n\trcu_read_lock();\n\tshp = shm_obtain_object_check(ns, shmid);\n\tif (IS_ERR(shp)) {\n\t\terr = PTR_ERR(shp);\n\t\tgoto out_unlock;\n\t}\n\n\terr = -EACCES;\n\tif (ipcperms(ns, &shp->shm_perm, acc_mode))\n\t\tgoto out_unlock;\n\n\terr = security_shm_shmat(shp, shmaddr, shmflg);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tipc_lock_object(&shp->shm_perm);\n\tpath = shp->shm_file->f_path;\n\tpath_get(&path);\n\tshp->shm_nattch++;\n\tsize = i_size_read(path.dentry->d_inode);\n\tipc_unlock_object(&shp->shm_perm);\n\trcu_read_unlock();\n\n\terr = -ENOMEM;\n\tsfd = kzalloc(sizeof(*sfd), GFP_KERNEL);\n\tif (!sfd) {\n\t\tpath_put(&path);\n\t\tgoto out_nattch;\n\t}\n\n\tfile = alloc_file(&path, f_mode,\n\t\t\t  is_file_hugepages(shp->shm_file) ?\n\t\t\t\t&shm_file_operations_huge :\n\t\t\t\t&shm_file_operations);\n\terr = PTR_ERR(file);\n\tif (IS_ERR(file)) {\n\t\tkfree(sfd);\n\t\tpath_put(&path);\n\t\tgoto out_nattch;\n\t}\n\n\tfile->private_data = sfd;\n\tfile->f_mapping = shp->shm_file->f_mapping;\n\tsfd->id = shp->shm_perm.id;\n\tsfd->ns = get_ipc_ns(ns);\n\tsfd->file = shp->shm_file;\n\tsfd->vm_ops = NULL;\n\n\terr = security_mmap_file(file, prot, flags);\n\tif (err)\n\t\tgoto out_fput;\n\n\tdown_write(&current->mm->mmap_sem);\n\tif (addr && !(shmflg & SHM_REMAP)) {\n\t\terr = -EINVAL;\n\t\tif (find_vma_intersection(current->mm, addr, addr + size))\n\t\t\tgoto invalid;\n\t\t/*\n\t\t * If shm segment goes below stack, make sure there is some\n\t\t * space left for the stack to grow (at least 4 pages).\n\t\t */\n\t\tif (addr < current->mm->start_stack &&\n\t\t    addr > current->mm->start_stack - size - PAGE_SIZE * 5)\n\t\t\tgoto invalid;\n\t}\n\n\taddr = do_mmap_pgoff(file, addr, size, prot, flags, 0, &populate);\n\t*raddr = addr;\n\terr = 0;\n\tif (IS_ERR_VALUE(addr))\n\t\terr = (long)addr;\ninvalid:\n\tup_write(&current->mm->mmap_sem);\n\tif (populate)\n\t\tmm_populate(addr, populate);\n\nout_fput:\n\tfput(file);\n\nout_nattch:\n\tdown_write(&shm_ids(ns).rwsem);\n\tshp = shm_lock(ns, shmid);\n\tBUG_ON(IS_ERR(shp));\n\tshp->shm_nattch--;\n\tif (shm_may_destroy(ns, shp))\n\t\tshm_destroy(ns, shp);\n\telse\n\t\tshm_unlock(shp);\n\tup_write(&shm_ids(ns).rwsem);\n\treturn err;\n\nout_unlock:\n\trcu_read_unlock();\nout:\n\treturn err;\n}\n\nSYSCALL_DEFINE3(shmat, int, shmid, char __user *, shmaddr, int, shmflg)\n{\n\tunsigned long ret;\n\tlong err;\n\n\terr = do_shmat(shmid, shmaddr, shmflg, &ret, SHMLBA);\n\tif (err)\n\t\treturn err;\n\tforce_successful_syscall_return();\n\treturn (long)ret;\n}\n\n/*\n * detach and kill segment if marked destroyed.\n * The work is done in shm_close.\n */\nSYSCALL_DEFINE1(shmdt, char __user *, shmaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tunsigned long addr = (unsigned long)shmaddr;\n\tint retval = -EINVAL;\n#ifdef CONFIG_MMU\n\tloff_t size = 0;\n\tstruct vm_area_struct *next;\n#endif\n\n\tif (addr & ~PAGE_MASK)\n\t\treturn retval;\n\n\tdown_write(&mm->mmap_sem);\n\n\t/*\n\t * This function tries to be smart and unmap shm segments that\n\t * were modified by partial mlock or munmap calls:\n\t * - It first determines the size of the shm segment that should be\n\t *   unmapped: It searches for a vma that is backed by shm and that\n\t *   started at address shmaddr. It records it's size and then unmaps\n\t *   it.\n\t * - Then it unmaps all shm vmas that started at shmaddr and that\n\t *   are within the initially determined size.\n\t * Errors from do_munmap are ignored: the function only fails if\n\t * it's called with invalid parameters or if it's called to unmap\n\t * a part of a vma. Both calls in this function are for full vmas,\n\t * the parameters are directly copied from the vma itself and always\n\t * valid - therefore do_munmap cannot fail. (famous last words?)\n\t */\n\t/*\n\t * If it had been mremap()'d, the starting address would not\n\t * match the usual checks anyway. So assume all vma's are\n\t * above the starting address given.\n\t */\n\tvma = find_vma(mm, addr);\n\n#ifdef CONFIG_MMU\n\twhile (vma) {\n\t\tnext = vma->vm_next;\n\n\t\t/*\n\t\t * Check if the starting address would match, i.e. it's\n\t\t * a fragment created by mprotect() and/or munmap(), or it\n\t\t * otherwise it starts at this address with no hassles.\n\t\t */\n\t\tif ((vma->vm_ops == &shm_vm_ops) &&\n\t\t\t(vma->vm_start - addr)/PAGE_SIZE == vma->vm_pgoff) {\n\n\n\t\t\tsize = file_inode(vma->vm_file)->i_size;\n\t\t\tdo_munmap(mm, vma->vm_start, vma->vm_end - vma->vm_start);\n\t\t\t/*\n\t\t\t * We discovered the size of the shm segment, so\n\t\t\t * break out of here and fall through to the next\n\t\t\t * loop that uses the size information to stop\n\t\t\t * searching for matching vma's.\n\t\t\t */\n\t\t\tretval = 0;\n\t\t\tvma = next;\n\t\t\tbreak;\n\t\t}\n\t\tvma = next;\n\t}\n\n\t/*\n\t * We need look no further than the maximum address a fragment\n\t * could possibly have landed at. Also cast things to loff_t to\n\t * prevent overflows and make comparisons vs. equal-width types.\n\t */\n\tsize = PAGE_ALIGN(size);\n\twhile (vma && (loff_t)(vma->vm_end - addr) <= size) {\n\t\tnext = vma->vm_next;\n\n\t\t/* finding a matching vma now does not alter retval */\n\t\tif ((vma->vm_ops == &shm_vm_ops) &&\n\t\t\t(vma->vm_start - addr)/PAGE_SIZE == vma->vm_pgoff)\n\n\t\t\tdo_munmap(mm, vma->vm_start, vma->vm_end - vma->vm_start);\n\t\tvma = next;\n\t}\n\n#else /* CONFIG_MMU */\n\t/* under NOMMU conditions, the exact address to be destroyed must be\n\t * given */\n\tif (vma && vma->vm_start == addr && vma->vm_ops == &shm_vm_ops) {\n\t\tdo_munmap(mm, vma->vm_start, vma->vm_end - vma->vm_start);\n\t\tretval = 0;\n\t}\n\n#endif\n\n\tup_write(&mm->mmap_sem);\n\treturn retval;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic int sysvipc_shm_proc_show(struct seq_file *s, void *it)\n{\n\tstruct user_namespace *user_ns = seq_user_ns(s);\n\tstruct shmid_kernel *shp = it;\n\tunsigned long rss = 0, swp = 0;\n\n\tshm_add_rss_swap(shp, &rss, &swp);\n\n#if BITS_PER_LONG <= 32\n#define SIZE_SPEC \"%10lu\"\n#else\n#define SIZE_SPEC \"%21lu\"\n#endif\n\n\treturn seq_printf(s,\n\t\t\t  \"%10d %10d  %4o \" SIZE_SPEC \" %5u %5u  \"\n\t\t\t  \"%5lu %5u %5u %5u %5u %10lu %10lu %10lu \"\n\t\t\t  SIZE_SPEC \" \" SIZE_SPEC \"\\n\",\n\t\t\t  shp->shm_perm.key,\n\t\t\t  shp->shm_perm.id,\n\t\t\t  shp->shm_perm.mode,\n\t\t\t  shp->shm_segsz,\n\t\t\t  shp->shm_cprid,\n\t\t\t  shp->shm_lprid,\n\t\t\t  shp->shm_nattch,\n\t\t\t  from_kuid_munged(user_ns, shp->shm_perm.uid),\n\t\t\t  from_kgid_munged(user_ns, shp->shm_perm.gid),\n\t\t\t  from_kuid_munged(user_ns, shp->shm_perm.cuid),\n\t\t\t  from_kgid_munged(user_ns, shp->shm_perm.cgid),\n\t\t\t  shp->shm_atim,\n\t\t\t  shp->shm_dtim,\n\t\t\t  shp->shm_ctim,\n\t\t\t  rss * PAGE_SIZE,\n\t\t\t  swp * PAGE_SIZE);\n}\n#endif\n"], "fixing_code": ["/*\n * linux/ipc/shm.c\n * Copyright (C) 1992, 1993 Krishna Balasubramanian\n *\t Many improvements/fixes by Bruno Haible.\n * Replaced `struct shm_desc' by `struct vm_area_struct', July 1994.\n * Fixed the shm swap deallocation (shm_unuse()), August 1998 Andrea Arcangeli.\n *\n * /proc/sysvipc/shm support (c) 1999 Dragos Acostachioaie <dragos@iname.com>\n * BIGMEM support, Andrea Arcangeli <andrea@suse.de>\n * SMP thread shm, Jean-Luc Boyard <jean-luc.boyard@siemens.fr>\n * HIGHMEM support, Ingo Molnar <mingo@redhat.com>\n * Make shmmax, shmall, shmmni sysctl'able, Christoph Rohland <cr@sap.com>\n * Shared /dev/zero support, Kanoj Sarcar <kanoj@sgi.com>\n * Move the mm functionality over to mm/shmem.c, Christoph Rohland <cr@sap.com>\n *\n * support for audit of ipc object properties and permission changes\n * Dustin Kirkland <dustin.kirkland@us.ibm.com>\n *\n * namespaces support\n * OpenVZ, SWsoft Inc.\n * Pavel Emelianov <xemul@openvz.org>\n *\n * Better ipc lock (kern_ipc_perm.lock) handling\n * Davidlohr Bueso <davidlohr.bueso@hp.com>, June 2013.\n */\n\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/hugetlb.h>\n#include <linux/shm.h>\n#include <linux/init.h>\n#include <linux/file.h>\n#include <linux/mman.h>\n#include <linux/shmem_fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/seq_file.h>\n#include <linux/rwsem.h>\n#include <linux/nsproxy.h>\n#include <linux/mount.h>\n#include <linux/ipc_namespace.h>\n\n#include <asm/uaccess.h>\n\n#include \"util.h\"\n\nstruct shm_file_data {\n\tint id;\n\tstruct ipc_namespace *ns;\n\tstruct file *file;\n\tconst struct vm_operations_struct *vm_ops;\n};\n\n#define shm_file_data(file) (*((struct shm_file_data **)&(file)->private_data))\n\nstatic const struct file_operations shm_file_operations;\nstatic const struct vm_operations_struct shm_vm_ops;\n\n#define shm_ids(ns)\t((ns)->ids[IPC_SHM_IDS])\n\n#define shm_unlock(shp)\t\t\t\\\n\tipc_unlock(&(shp)->shm_perm)\n\nstatic int newseg(struct ipc_namespace *, struct ipc_params *);\nstatic void shm_open(struct vm_area_struct *vma);\nstatic void shm_close(struct vm_area_struct *vma);\nstatic void shm_destroy (struct ipc_namespace *ns, struct shmid_kernel *shp);\n#ifdef CONFIG_PROC_FS\nstatic int sysvipc_shm_proc_show(struct seq_file *s, void *it);\n#endif\n\nvoid shm_init_ns(struct ipc_namespace *ns)\n{\n\tns->shm_ctlmax = SHMMAX;\n\tns->shm_ctlall = SHMALL;\n\tns->shm_ctlmni = SHMMNI;\n\tns->shm_rmid_forced = 0;\n\tns->shm_tot = 0;\n\tipc_init_ids(&shm_ids(ns));\n}\n\n/*\n * Called with shm_ids.rwsem (writer) and the shp structure locked.\n * Only shm_ids.rwsem remains locked on exit.\n */\nstatic void do_shm_rmid(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp)\n{\n\tstruct shmid_kernel *shp;\n\tshp = container_of(ipcp, struct shmid_kernel, shm_perm);\n\n\tif (shp->shm_nattch){\n\t\tshp->shm_perm.mode |= SHM_DEST;\n\t\t/* Do not find it any more */\n\t\tshp->shm_perm.key = IPC_PRIVATE;\n\t\tshm_unlock(shp);\n\t} else\n\t\tshm_destroy(ns, shp);\n}\n\n#ifdef CONFIG_IPC_NS\nvoid shm_exit_ns(struct ipc_namespace *ns)\n{\n\tfree_ipcs(ns, &shm_ids(ns), do_shm_rmid);\n\tidr_destroy(&ns->ids[IPC_SHM_IDS].ipcs_idr);\n}\n#endif\n\nstatic int __init ipc_ns_init(void)\n{\n\tshm_init_ns(&init_ipc_ns);\n\treturn 0;\n}\n\npure_initcall(ipc_ns_init);\n\nvoid __init shm_init (void)\n{\n\tipc_init_proc_interface(\"sysvipc/shm\",\n#if BITS_PER_LONG <= 32\n\t\t\t\t\"       key      shmid perms       size  cpid  lpid nattch   uid   gid  cuid  cgid      atime      dtime      ctime        rss       swap\\n\",\n#else\n\t\t\t\t\"       key      shmid perms                  size  cpid  lpid nattch   uid   gid  cuid  cgid      atime      dtime      ctime                   rss                  swap\\n\",\n#endif\n\t\t\t\tIPC_SHM_IDS, sysvipc_shm_proc_show);\n}\n\nstatic inline struct shmid_kernel *shm_obtain_object(struct ipc_namespace *ns, int id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_obtain_object(&shm_ids(ns), id);\n\n\tif (IS_ERR(ipcp))\n\t\treturn ERR_CAST(ipcp);\n\n\treturn container_of(ipcp, struct shmid_kernel, shm_perm);\n}\n\nstatic inline struct shmid_kernel *shm_obtain_object_check(struct ipc_namespace *ns, int id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_obtain_object_check(&shm_ids(ns), id);\n\n\tif (IS_ERR(ipcp))\n\t\treturn ERR_CAST(ipcp);\n\n\treturn container_of(ipcp, struct shmid_kernel, shm_perm);\n}\n\n/*\n * shm_lock_(check_) routines are called in the paths where the rwsem\n * is not necessarily held.\n */\nstatic inline struct shmid_kernel *shm_lock(struct ipc_namespace *ns, int id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_lock(&shm_ids(ns), id);\n\n\tif (IS_ERR(ipcp))\n\t\treturn (struct shmid_kernel *)ipcp;\n\n\treturn container_of(ipcp, struct shmid_kernel, shm_perm);\n}\n\nstatic inline void shm_lock_by_ptr(struct shmid_kernel *ipcp)\n{\n\trcu_read_lock();\n\tipc_lock_object(&ipcp->shm_perm);\n}\n\nstatic void shm_rcu_free(struct rcu_head *head)\n{\n\tstruct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);\n\tstruct shmid_kernel *shp = ipc_rcu_to_struct(p);\n\n\tsecurity_shm_free(shp);\n\tipc_rcu_free(head);\n}\n\nstatic inline void shm_rmid(struct ipc_namespace *ns, struct shmid_kernel *s)\n{\n\tipc_rmid(&shm_ids(ns), &s->shm_perm);\n}\n\n\n/* This is called by fork, once for every shm attach. */\nstatic void shm_open(struct vm_area_struct *vma)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\tstruct shmid_kernel *shp;\n\n\tshp = shm_lock(sfd->ns, sfd->id);\n\tBUG_ON(IS_ERR(shp));\n\tshp->shm_atim = get_seconds();\n\tshp->shm_lprid = task_tgid_vnr(current);\n\tshp->shm_nattch++;\n\tshm_unlock(shp);\n}\n\n/*\n * shm_destroy - free the struct shmid_kernel\n *\n * @ns: namespace\n * @shp: struct to free\n *\n * It has to be called with shp and shm_ids.rwsem (writer) locked,\n * but returns with shp unlocked and freed.\n */\nstatic void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)\n{\n\tstruct file *shm_file;\n\n\tshm_file = shp->shm_file;\n\tshp->shm_file = NULL;\n\tns->shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tshm_rmid(ns, shp);\n\tshm_unlock(shp);\n\tif (!is_file_hugepages(shm_file))\n\t\tshmem_lock(shm_file, 0, shp->mlock_user);\n\telse if (shp->mlock_user)\n\t\tuser_shm_unlock(file_inode(shm_file)->i_size, shp->mlock_user);\n\tfput(shm_file);\n\tipc_rcu_putref(shp, shm_rcu_free);\n}\n\n/*\n * shm_may_destroy - identifies whether shm segment should be destroyed now\n *\n * Returns true if and only if there are no active users of the segment and\n * one of the following is true:\n *\n * 1) shmctl(id, IPC_RMID, NULL) was called for this shp\n *\n * 2) sysctl kernel.shm_rmid_forced is set to 1.\n */\nstatic bool shm_may_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)\n{\n\treturn (shp->shm_nattch == 0) &&\n\t       (ns->shm_rmid_forced ||\n\t\t(shp->shm_perm.mode & SHM_DEST));\n}\n\n/*\n * remove the attach descriptor vma.\n * free memory for segment if it is marked destroyed.\n * The descriptor has already been removed from the current->mm->mmap list\n * and will later be kfree()d.\n */\nstatic void shm_close(struct vm_area_struct *vma)\n{\n\tstruct file * file = vma->vm_file;\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\tstruct shmid_kernel *shp;\n\tstruct ipc_namespace *ns = sfd->ns;\n\n\tdown_write(&shm_ids(ns).rwsem);\n\t/* remove from the list of attaches of the shm segment */\n\tshp = shm_lock(ns, sfd->id);\n\tBUG_ON(IS_ERR(shp));\n\tshp->shm_lprid = task_tgid_vnr(current);\n\tshp->shm_dtim = get_seconds();\n\tshp->shm_nattch--;\n\tif (shm_may_destroy(ns, shp))\n\t\tshm_destroy(ns, shp);\n\telse\n\t\tshm_unlock(shp);\n\tup_write(&shm_ids(ns).rwsem);\n}\n\n/* Called with ns->shm_ids(ns).rwsem locked */\nstatic int shm_try_destroy_current(int id, void *p, void *data)\n{\n\tstruct ipc_namespace *ns = data;\n\tstruct kern_ipc_perm *ipcp = p;\n\tstruct shmid_kernel *shp = container_of(ipcp, struct shmid_kernel, shm_perm);\n\n\tif (shp->shm_creator != current)\n\t\treturn 0;\n\n\t/*\n\t * Mark it as orphaned to destroy the segment when\n\t * kernel.shm_rmid_forced is changed.\n\t * It is noop if the following shm_may_destroy() returns true.\n\t */\n\tshp->shm_creator = NULL;\n\n\t/*\n\t * Don't even try to destroy it.  If shm_rmid_forced=0 and IPC_RMID\n\t * is not set, it shouldn't be deleted here.\n\t */\n\tif (!ns->shm_rmid_forced)\n\t\treturn 0;\n\n\tif (shm_may_destroy(ns, shp)) {\n\t\tshm_lock_by_ptr(shp);\n\t\tshm_destroy(ns, shp);\n\t}\n\treturn 0;\n}\n\n/* Called with ns->shm_ids(ns).rwsem locked */\nstatic int shm_try_destroy_orphaned(int id, void *p, void *data)\n{\n\tstruct ipc_namespace *ns = data;\n\tstruct kern_ipc_perm *ipcp = p;\n\tstruct shmid_kernel *shp = container_of(ipcp, struct shmid_kernel, shm_perm);\n\n\t/*\n\t * We want to destroy segments without users and with already\n\t * exit'ed originating process.\n\t *\n\t * As shp->* are changed under rwsem, it's safe to skip shp locking.\n\t */\n\tif (shp->shm_creator != NULL)\n\t\treturn 0;\n\n\tif (shm_may_destroy(ns, shp)) {\n\t\tshm_lock_by_ptr(shp);\n\t\tshm_destroy(ns, shp);\n\t}\n\treturn 0;\n}\n\nvoid shm_destroy_orphaned(struct ipc_namespace *ns)\n{\n\tdown_write(&shm_ids(ns).rwsem);\n\tif (shm_ids(ns).in_use)\n\t\tidr_for_each(&shm_ids(ns).ipcs_idr, &shm_try_destroy_orphaned, ns);\n\tup_write(&shm_ids(ns).rwsem);\n}\n\n\nvoid exit_shm(struct task_struct *task)\n{\n\tstruct ipc_namespace *ns = task->nsproxy->ipc_ns;\n\n\tif (shm_ids(ns).in_use == 0)\n\t\treturn;\n\n\t/* Destroy all already created segments, but not mapped yet */\n\tdown_write(&shm_ids(ns).rwsem);\n\tif (shm_ids(ns).in_use)\n\t\tidr_for_each(&shm_ids(ns).ipcs_idr, &shm_try_destroy_current, ns);\n\tup_write(&shm_ids(ns).rwsem);\n}\n\nstatic int shm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\n\treturn sfd->vm_ops->fault(vma, vmf);\n}\n\n#ifdef CONFIG_NUMA\nstatic int shm_set_policy(struct vm_area_struct *vma, struct mempolicy *new)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\tint err = 0;\n\tif (sfd->vm_ops->set_policy)\n\t\terr = sfd->vm_ops->set_policy(vma, new);\n\treturn err;\n}\n\nstatic struct mempolicy *shm_get_policy(struct vm_area_struct *vma,\n\t\t\t\t\tunsigned long addr)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\tstruct mempolicy *pol = NULL;\n\n\tif (sfd->vm_ops->get_policy)\n\t\tpol = sfd->vm_ops->get_policy(vma, addr);\n\telse if (vma->vm_policy)\n\t\tpol = vma->vm_policy;\n\n\treturn pol;\n}\n#endif\n\nstatic int shm_mmap(struct file * file, struct vm_area_struct * vma)\n{\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\tint ret;\n\n\tret = sfd->file->f_op->mmap(sfd->file, vma);\n\tif (ret != 0)\n\t\treturn ret;\n\tsfd->vm_ops = vma->vm_ops;\n#ifdef CONFIG_MMU\n\tBUG_ON(!sfd->vm_ops->fault);\n#endif\n\tvma->vm_ops = &shm_vm_ops;\n\tshm_open(vma);\n\n\treturn ret;\n}\n\nstatic int shm_release(struct inode *ino, struct file *file)\n{\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\n\tput_ipc_ns(sfd->ns);\n\tshm_file_data(file) = NULL;\n\tkfree(sfd);\n\treturn 0;\n}\n\nstatic int shm_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\n\tif (!sfd->file->f_op->fsync)\n\t\treturn -EINVAL;\n\treturn sfd->file->f_op->fsync(sfd->file, start, end, datasync);\n}\n\nstatic long shm_fallocate(struct file *file, int mode, loff_t offset,\n\t\t\t  loff_t len)\n{\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\n\tif (!sfd->file->f_op->fallocate)\n\t\treturn -EOPNOTSUPP;\n\treturn sfd->file->f_op->fallocate(file, mode, offset, len);\n}\n\nstatic unsigned long shm_get_unmapped_area(struct file *file,\n\tunsigned long addr, unsigned long len, unsigned long pgoff,\n\tunsigned long flags)\n{\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\treturn sfd->file->f_op->get_unmapped_area(sfd->file, addr, len,\n\t\t\t\t\t\tpgoff, flags);\n}\n\nstatic const struct file_operations shm_file_operations = {\n\t.mmap\t\t= shm_mmap,\n\t.fsync\t\t= shm_fsync,\n\t.release\t= shm_release,\n#ifndef CONFIG_MMU\n\t.get_unmapped_area\t= shm_get_unmapped_area,\n#endif\n\t.llseek\t\t= noop_llseek,\n\t.fallocate\t= shm_fallocate,\n};\n\nstatic const struct file_operations shm_file_operations_huge = {\n\t.mmap\t\t= shm_mmap,\n\t.fsync\t\t= shm_fsync,\n\t.release\t= shm_release,\n\t.get_unmapped_area\t= shm_get_unmapped_area,\n\t.llseek\t\t= noop_llseek,\n\t.fallocate\t= shm_fallocate,\n};\n\nint is_file_shm_hugepages(struct file *file)\n{\n\treturn file->f_op == &shm_file_operations_huge;\n}\n\nstatic const struct vm_operations_struct shm_vm_ops = {\n\t.open\t= shm_open,\t/* callback for a new vm-area open */\n\t.close\t= shm_close,\t/* callback for when the vm-area is released */\n\t.fault\t= shm_fault,\n#if defined(CONFIG_NUMA)\n\t.set_policy = shm_set_policy,\n\t.get_policy = shm_get_policy,\n#endif\n};\n\n/**\n * newseg - Create a new shared memory segment\n * @ns: namespace\n * @params: ptr to the structure that contains key, size and shmflg\n *\n * Called with shm_ids.rwsem held as a writer.\n */\n\nstatic int newseg(struct ipc_namespace *ns, struct ipc_params *params)\n{\n\tkey_t key = params->key;\n\tint shmflg = params->flg;\n\tsize_t size = params->u.size;\n\tint error;\n\tstruct shmid_kernel *shp;\n\tsize_t numpages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tstruct file * file;\n\tchar name[13];\n\tint id;\n\tvm_flags_t acctflag = 0;\n\n\tif (size < SHMMIN || size > ns->shm_ctlmax)\n\t\treturn -EINVAL;\n\n\tif (ns->shm_tot + numpages > ns->shm_ctlall)\n\t\treturn -ENOSPC;\n\n\tshp = ipc_rcu_alloc(sizeof(*shp));\n\tif (!shp)\n\t\treturn -ENOMEM;\n\n\tshp->shm_perm.key = key;\n\tshp->shm_perm.mode = (shmflg & S_IRWXUGO);\n\tshp->mlock_user = NULL;\n\n\tshp->shm_perm.security = NULL;\n\terror = security_shm_alloc(shp);\n\tif (error) {\n\t\tipc_rcu_putref(shp, ipc_rcu_free);\n\t\treturn error;\n\t}\n\n\tsprintf (name, \"SYSV%08x\", key);\n\tif (shmflg & SHM_HUGETLB) {\n\t\tstruct hstate *hs;\n\t\tsize_t hugesize;\n\n\t\ths = hstate_sizelog((shmflg >> SHM_HUGE_SHIFT) & SHM_HUGE_MASK);\n\t\tif (!hs) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto no_file;\n\t\t}\n\t\thugesize = ALIGN(size, huge_page_size(hs));\n\n\t\t/* hugetlb_file_setup applies strict accounting */\n\t\tif (shmflg & SHM_NORESERVE)\n\t\t\tacctflag = VM_NORESERVE;\n\t\tfile = hugetlb_file_setup(name, hugesize, acctflag,\n\t\t\t\t  &shp->mlock_user, HUGETLB_SHMFS_INODE,\n\t\t\t\t(shmflg >> SHM_HUGE_SHIFT) & SHM_HUGE_MASK);\n\t} else {\n\t\t/*\n\t\t * Do not allow no accounting for OVERCOMMIT_NEVER, even\n\t \t * if it's asked for.\n\t\t */\n\t\tif  ((shmflg & SHM_NORESERVE) &&\n\t\t\t\tsysctl_overcommit_memory != OVERCOMMIT_NEVER)\n\t\t\tacctflag = VM_NORESERVE;\n\t\tfile = shmem_file_setup(name, size, acctflag);\n\t}\n\terror = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto no_file;\n\n\tid = ipc_addid(&shm_ids(ns), &shp->shm_perm, ns->shm_ctlmni);\n\tif (id < 0) {\n\t\terror = id;\n\t\tgoto no_id;\n\t}\n\n\tshp->shm_cprid = task_tgid_vnr(current);\n\tshp->shm_lprid = 0;\n\tshp->shm_atim = shp->shm_dtim = 0;\n\tshp->shm_ctim = get_seconds();\n\tshp->shm_segsz = size;\n\tshp->shm_nattch = 0;\n\tshp->shm_file = file;\n\tshp->shm_creator = current;\n\n\t/*\n\t * shmid gets reported as \"inode#\" in /proc/pid/maps.\n\t * proc-ps tools use this. Changing this will break them.\n\t */\n\tfile_inode(file)->i_ino = shp->shm_perm.id;\n\n\tns->shm_tot += numpages;\n\terror = shp->shm_perm.id;\n\n\tipc_unlock_object(&shp->shm_perm);\n\trcu_read_unlock();\n\treturn error;\n\nno_id:\n\tif (is_file_hugepages(file) && shp->mlock_user)\n\t\tuser_shm_unlock(size, shp->mlock_user);\n\tfput(file);\nno_file:\n\tipc_rcu_putref(shp, shm_rcu_free);\n\treturn error;\n}\n\n/*\n * Called with shm_ids.rwsem and ipcp locked.\n */\nstatic inline int shm_security(struct kern_ipc_perm *ipcp, int shmflg)\n{\n\tstruct shmid_kernel *shp;\n\n\tshp = container_of(ipcp, struct shmid_kernel, shm_perm);\n\treturn security_shm_associate(shp, shmflg);\n}\n\n/*\n * Called with shm_ids.rwsem and ipcp locked.\n */\nstatic inline int shm_more_checks(struct kern_ipc_perm *ipcp,\n\t\t\t\tstruct ipc_params *params)\n{\n\tstruct shmid_kernel *shp;\n\n\tshp = container_of(ipcp, struct shmid_kernel, shm_perm);\n\tif (shp->shm_segsz < params->u.size)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nSYSCALL_DEFINE3(shmget, key_t, key, size_t, size, int, shmflg)\n{\n\tstruct ipc_namespace *ns;\n\tstruct ipc_ops shm_ops;\n\tstruct ipc_params shm_params;\n\n\tns = current->nsproxy->ipc_ns;\n\n\tshm_ops.getnew = newseg;\n\tshm_ops.associate = shm_security;\n\tshm_ops.more_checks = shm_more_checks;\n\n\tshm_params.key = key;\n\tshm_params.flg = shmflg;\n\tshm_params.u.size = size;\n\n\treturn ipcget(ns, &shm_ids(ns), &shm_ops, &shm_params);\n}\n\nstatic inline unsigned long copy_shmid_to_user(void __user *buf, struct shmid64_ds *in, int version)\n{\n\tswitch(version) {\n\tcase IPC_64:\n\t\treturn copy_to_user(buf, in, sizeof(*in));\n\tcase IPC_OLD:\n\t    {\n\t\tstruct shmid_ds out;\n\n\t\tmemset(&out, 0, sizeof(out));\n\t\tipc64_perm_to_ipc_perm(&in->shm_perm, &out.shm_perm);\n\t\tout.shm_segsz\t= in->shm_segsz;\n\t\tout.shm_atime\t= in->shm_atime;\n\t\tout.shm_dtime\t= in->shm_dtime;\n\t\tout.shm_ctime\t= in->shm_ctime;\n\t\tout.shm_cpid\t= in->shm_cpid;\n\t\tout.shm_lpid\t= in->shm_lpid;\n\t\tout.shm_nattch\t= in->shm_nattch;\n\n\t\treturn copy_to_user(buf, &out, sizeof(out));\n\t    }\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic inline unsigned long\ncopy_shmid_from_user(struct shmid64_ds *out, void __user *buf, int version)\n{\n\tswitch(version) {\n\tcase IPC_64:\n\t\tif (copy_from_user(out, buf, sizeof(*out)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase IPC_OLD:\n\t    {\n\t\tstruct shmid_ds tbuf_old;\n\n\t\tif (copy_from_user(&tbuf_old, buf, sizeof(tbuf_old)))\n\t\t\treturn -EFAULT;\n\n\t\tout->shm_perm.uid\t= tbuf_old.shm_perm.uid;\n\t\tout->shm_perm.gid\t= tbuf_old.shm_perm.gid;\n\t\tout->shm_perm.mode\t= tbuf_old.shm_perm.mode;\n\n\t\treturn 0;\n\t    }\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic inline unsigned long copy_shminfo_to_user(void __user *buf, struct shminfo64 *in, int version)\n{\n\tswitch(version) {\n\tcase IPC_64:\n\t\treturn copy_to_user(buf, in, sizeof(*in));\n\tcase IPC_OLD:\n\t    {\n\t\tstruct shminfo out;\n\n\t\tif(in->shmmax > INT_MAX)\n\t\t\tout.shmmax = INT_MAX;\n\t\telse\n\t\t\tout.shmmax = (int)in->shmmax;\n\n\t\tout.shmmin\t= in->shmmin;\n\t\tout.shmmni\t= in->shmmni;\n\t\tout.shmseg\t= in->shmseg;\n\t\tout.shmall\t= in->shmall; \n\n\t\treturn copy_to_user(buf, &out, sizeof(out));\n\t    }\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/*\n * Calculate and add used RSS and swap pages of a shm.\n * Called with shm_ids.rwsem held as a reader\n */\nstatic void shm_add_rss_swap(struct shmid_kernel *shp,\n\tunsigned long *rss_add, unsigned long *swp_add)\n{\n\tstruct inode *inode;\n\n\tinode = file_inode(shp->shm_file);\n\n\tif (is_file_hugepages(shp->shm_file)) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct hstate *h = hstate_file(shp->shm_file);\n\t\t*rss_add += pages_per_huge_page(h) * mapping->nrpages;\n\t} else {\n#ifdef CONFIG_SHMEM\n\t\tstruct shmem_inode_info *info = SHMEM_I(inode);\n\t\tspin_lock(&info->lock);\n\t\t*rss_add += inode->i_mapping->nrpages;\n\t\t*swp_add += info->swapped;\n\t\tspin_unlock(&info->lock);\n#else\n\t\t*rss_add += inode->i_mapping->nrpages;\n#endif\n\t}\n}\n\n/*\n * Called with shm_ids.rwsem held as a reader\n */\nstatic void shm_get_stat(struct ipc_namespace *ns, unsigned long *rss,\n\t\tunsigned long *swp)\n{\n\tint next_id;\n\tint total, in_use;\n\n\t*rss = 0;\n\t*swp = 0;\n\n\tin_use = shm_ids(ns).in_use;\n\n\tfor (total = 0, next_id = 0; total < in_use; next_id++) {\n\t\tstruct kern_ipc_perm *ipc;\n\t\tstruct shmid_kernel *shp;\n\n\t\tipc = idr_find(&shm_ids(ns).ipcs_idr, next_id);\n\t\tif (ipc == NULL)\n\t\t\tcontinue;\n\t\tshp = container_of(ipc, struct shmid_kernel, shm_perm);\n\n\t\tshm_add_rss_swap(shp, rss, swp);\n\n\t\ttotal++;\n\t}\n}\n\n/*\n * This function handles some shmctl commands which require the rwsem\n * to be held in write mode.\n * NOTE: no locks must be held, the rwsem is taken inside this function.\n */\nstatic int shmctl_down(struct ipc_namespace *ns, int shmid, int cmd,\n\t\t       struct shmid_ds __user *buf, int version)\n{\n\tstruct kern_ipc_perm *ipcp;\n\tstruct shmid64_ds shmid64;\n\tstruct shmid_kernel *shp;\n\tint err;\n\n\tif (cmd == IPC_SET) {\n\t\tif (copy_shmid_from_user(&shmid64, buf, version))\n\t\t\treturn -EFAULT;\n\t}\n\n\tdown_write(&shm_ids(ns).rwsem);\n\trcu_read_lock();\n\n\tipcp = ipcctl_pre_down_nolock(ns, &shm_ids(ns), shmid, cmd,\n\t\t\t\t      &shmid64.shm_perm, 0);\n\tif (IS_ERR(ipcp)) {\n\t\terr = PTR_ERR(ipcp);\n\t\tgoto out_unlock1;\n\t}\n\n\tshp = container_of(ipcp, struct shmid_kernel, shm_perm);\n\n\terr = security_shm_shmctl(shp, cmd);\n\tif (err)\n\t\tgoto out_unlock1;\n\n\tswitch (cmd) {\n\tcase IPC_RMID:\n\t\tipc_lock_object(&shp->shm_perm);\n\t\t/* do_shm_rmid unlocks the ipc object and rcu */\n\t\tdo_shm_rmid(ns, ipcp);\n\t\tgoto out_up;\n\tcase IPC_SET:\n\t\tipc_lock_object(&shp->shm_perm);\n\t\terr = ipc_update_perm(&shmid64.shm_perm, ipcp);\n\t\tif (err)\n\t\t\tgoto out_unlock0;\n\t\tshp->shm_ctim = get_seconds();\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out_unlock1;\n\t}\n\nout_unlock0:\n\tipc_unlock_object(&shp->shm_perm);\nout_unlock1:\n\trcu_read_unlock();\nout_up:\n\tup_write(&shm_ids(ns).rwsem);\n\treturn err;\n}\n\nstatic int shmctl_nolock(struct ipc_namespace *ns, int shmid,\n\t\t\t int cmd, int version, void __user *buf)\n{\n\tint err;\n\tstruct shmid_kernel *shp;\n\n\t/* preliminary security checks for *_INFO */\n\tif (cmd == IPC_INFO || cmd == SHM_INFO) {\n\t\terr = security_shm_shmctl(NULL, cmd);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tswitch (cmd) {\n\tcase IPC_INFO:\n\t{\n\t\tstruct shminfo64 shminfo;\n\n\t\tmemset(&shminfo, 0, sizeof(shminfo));\n\t\tshminfo.shmmni = shminfo.shmseg = ns->shm_ctlmni;\n\t\tshminfo.shmmax = ns->shm_ctlmax;\n\t\tshminfo.shmall = ns->shm_ctlall;\n\n\t\tshminfo.shmmin = SHMMIN;\n\t\tif(copy_shminfo_to_user (buf, &shminfo, version))\n\t\t\treturn -EFAULT;\n\n\t\tdown_read(&shm_ids(ns).rwsem);\n\t\terr = ipc_get_maxid(&shm_ids(ns));\n\t\tup_read(&shm_ids(ns).rwsem);\n\n\t\tif(err<0)\n\t\t\terr = 0;\n\t\tgoto out;\n\t}\n\tcase SHM_INFO:\n\t{\n\t\tstruct shm_info shm_info;\n\n\t\tmemset(&shm_info, 0, sizeof(shm_info));\n\t\tdown_read(&shm_ids(ns).rwsem);\n\t\tshm_info.used_ids = shm_ids(ns).in_use;\n\t\tshm_get_stat (ns, &shm_info.shm_rss, &shm_info.shm_swp);\n\t\tshm_info.shm_tot = ns->shm_tot;\n\t\tshm_info.swap_attempts = 0;\n\t\tshm_info.swap_successes = 0;\n\t\terr = ipc_get_maxid(&shm_ids(ns));\n\t\tup_read(&shm_ids(ns).rwsem);\n\t\tif (copy_to_user(buf, &shm_info, sizeof(shm_info))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = err < 0 ? 0 : err;\n\t\tgoto out;\n\t}\n\tcase SHM_STAT:\n\tcase IPC_STAT:\n\t{\n\t\tstruct shmid64_ds tbuf;\n\t\tint result;\n\n\t\trcu_read_lock();\n\t\tif (cmd == SHM_STAT) {\n\t\t\tshp = shm_obtain_object(ns, shmid);\n\t\t\tif (IS_ERR(shp)) {\n\t\t\t\terr = PTR_ERR(shp);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tresult = shp->shm_perm.id;\n\t\t} else {\n\t\t\tshp = shm_obtain_object_check(ns, shmid);\n\t\t\tif (IS_ERR(shp)) {\n\t\t\t\terr = PTR_ERR(shp);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tresult = 0;\n\t\t}\n\n\t\terr = -EACCES;\n\t\tif (ipcperms(ns, &shp->shm_perm, S_IRUGO))\n\t\t\tgoto out_unlock;\n\n\t\terr = security_shm_shmctl(shp, cmd);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\n\t\tmemset(&tbuf, 0, sizeof(tbuf));\n\t\tkernel_to_ipc64_perm(&shp->shm_perm, &tbuf.shm_perm);\n\t\ttbuf.shm_segsz\t= shp->shm_segsz;\n\t\ttbuf.shm_atime\t= shp->shm_atim;\n\t\ttbuf.shm_dtime\t= shp->shm_dtim;\n\t\ttbuf.shm_ctime\t= shp->shm_ctim;\n\t\ttbuf.shm_cpid\t= shp->shm_cprid;\n\t\ttbuf.shm_lpid\t= shp->shm_lprid;\n\t\ttbuf.shm_nattch\t= shp->shm_nattch;\n\t\trcu_read_unlock();\n\n\t\tif (copy_shmid_to_user(buf, &tbuf, version))\n\t\t\terr = -EFAULT;\n\t\telse\n\t\t\terr = result;\n\t\tgoto out;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\nout_unlock:\n\trcu_read_unlock();\nout:\n\treturn err;\n}\n\nSYSCALL_DEFINE3(shmctl, int, shmid, int, cmd, struct shmid_ds __user *, buf)\n{\n\tstruct shmid_kernel *shp;\n\tint err, version;\n\tstruct ipc_namespace *ns;\n\n\tif (cmd < 0 || shmid < 0)\n\t\treturn -EINVAL;\n\n\tversion = ipc_parse_version(&cmd);\n\tns = current->nsproxy->ipc_ns;\n\n\tswitch (cmd) {\n\tcase IPC_INFO:\n\tcase SHM_INFO:\n\tcase SHM_STAT:\n\tcase IPC_STAT:\n\t\treturn shmctl_nolock(ns, shmid, cmd, version, buf);\n\tcase IPC_RMID:\n\tcase IPC_SET:\n\t\treturn shmctl_down(ns, shmid, cmd, buf, version);\n\tcase SHM_LOCK:\n\tcase SHM_UNLOCK:\n\t{\n\t\tstruct file *shm_file;\n\n\t\trcu_read_lock();\n\t\tshp = shm_obtain_object_check(ns, shmid);\n\t\tif (IS_ERR(shp)) {\n\t\t\terr = PTR_ERR(shp);\n\t\t\tgoto out_unlock1;\n\t\t}\n\n\t\taudit_ipc_obj(&(shp->shm_perm));\n\t\terr = security_shm_shmctl(shp, cmd);\n\t\tif (err)\n\t\t\tgoto out_unlock1;\n\n\t\tipc_lock_object(&shp->shm_perm);\n\t\tif (!ns_capable(ns->user_ns, CAP_IPC_LOCK)) {\n\t\t\tkuid_t euid = current_euid();\n\t\t\terr = -EPERM;\n\t\t\tif (!uid_eq(euid, shp->shm_perm.uid) &&\n\t\t\t    !uid_eq(euid, shp->shm_perm.cuid))\n\t\t\t\tgoto out_unlock0;\n\t\t\tif (cmd == SHM_LOCK && !rlimit(RLIMIT_MEMLOCK))\n\t\t\t\tgoto out_unlock0;\n\t\t}\n\n\t\tshm_file = shp->shm_file;\n\n\t\t/* check if shm_destroy() is tearing down shp */\n\t\tif (shm_file == NULL) {\n\t\t\terr = -EIDRM;\n\t\t\tgoto out_unlock0;\n\t\t}\n\n\t\tif (is_file_hugepages(shm_file))\n\t\t\tgoto out_unlock0;\n\n\t\tif (cmd == SHM_LOCK) {\n\t\t\tstruct user_struct *user = current_user();\n\t\t\terr = shmem_lock(shm_file, 1, user);\n\t\t\tif (!err && !(shp->shm_perm.mode & SHM_LOCKED)) {\n\t\t\t\tshp->shm_perm.mode |= SHM_LOCKED;\n\t\t\t\tshp->mlock_user = user;\n\t\t\t}\n\t\t\tgoto out_unlock0;\n\t\t}\n\n\t\t/* SHM_UNLOCK */\n\t\tif (!(shp->shm_perm.mode & SHM_LOCKED))\n\t\t\tgoto out_unlock0;\n\t\tshmem_lock(shm_file, 0, shp->mlock_user);\n\t\tshp->shm_perm.mode &= ~SHM_LOCKED;\n\t\tshp->mlock_user = NULL;\n\t\tget_file(shm_file);\n\t\tipc_unlock_object(&shp->shm_perm);\n\t\trcu_read_unlock();\n\t\tshmem_unlock_mapping(shm_file->f_mapping);\n\n\t\tfput(shm_file);\n\t\treturn err;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\nout_unlock0:\n\tipc_unlock_object(&shp->shm_perm);\nout_unlock1:\n\trcu_read_unlock();\n\treturn err;\n}\n\n/*\n * Fix shmaddr, allocate descriptor, map shm, add attach descriptor to lists.\n *\n * NOTE! Despite the name, this is NOT a direct system call entrypoint. The\n * \"raddr\" thing points to kernel space, and there has to be a wrapper around\n * this.\n */\nlong do_shmat(int shmid, char __user *shmaddr, int shmflg, ulong *raddr,\n\t      unsigned long shmlba)\n{\n\tstruct shmid_kernel *shp;\n\tunsigned long addr;\n\tunsigned long size;\n\tstruct file * file;\n\tint    err;\n\tunsigned long flags;\n\tunsigned long prot;\n\tint acc_mode;\n\tstruct ipc_namespace *ns;\n\tstruct shm_file_data *sfd;\n\tstruct path path;\n\tfmode_t f_mode;\n\tunsigned long populate = 0;\n\n\terr = -EINVAL;\n\tif (shmid < 0)\n\t\tgoto out;\n\telse if ((addr = (ulong)shmaddr)) {\n\t\tif (addr & (shmlba - 1)) {\n\t\t\tif (shmflg & SHM_RND)\n\t\t\t\taddr &= ~(shmlba - 1);\t   /* round down */\n\t\t\telse\n#ifndef __ARCH_FORCE_SHMLBA\n\t\t\t\tif (addr & ~PAGE_MASK)\n#endif\n\t\t\t\t\tgoto out;\n\t\t}\n\t\tflags = MAP_SHARED | MAP_FIXED;\n\t} else {\n\t\tif ((shmflg & SHM_REMAP))\n\t\t\tgoto out;\n\n\t\tflags = MAP_SHARED;\n\t}\n\n\tif (shmflg & SHM_RDONLY) {\n\t\tprot = PROT_READ;\n\t\tacc_mode = S_IRUGO;\n\t\tf_mode = FMODE_READ;\n\t} else {\n\t\tprot = PROT_READ | PROT_WRITE;\n\t\tacc_mode = S_IRUGO | S_IWUGO;\n\t\tf_mode = FMODE_READ | FMODE_WRITE;\n\t}\n\tif (shmflg & SHM_EXEC) {\n\t\tprot |= PROT_EXEC;\n\t\tacc_mode |= S_IXUGO;\n\t}\n\n\t/*\n\t * We cannot rely on the fs check since SYSV IPC does have an\n\t * additional creator id...\n\t */\n\tns = current->nsproxy->ipc_ns;\n\trcu_read_lock();\n\tshp = shm_obtain_object_check(ns, shmid);\n\tif (IS_ERR(shp)) {\n\t\terr = PTR_ERR(shp);\n\t\tgoto out_unlock;\n\t}\n\n\terr = -EACCES;\n\tif (ipcperms(ns, &shp->shm_perm, acc_mode))\n\t\tgoto out_unlock;\n\n\terr = security_shm_shmat(shp, shmaddr, shmflg);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tipc_lock_object(&shp->shm_perm);\n\n\t/* check if shm_destroy() is tearing down shp */\n\tif (shp->shm_file == NULL) {\n\t\tipc_unlock_object(&shp->shm_perm);\n\t\terr = -EIDRM;\n\t\tgoto out_unlock;\n\t}\n\n\tpath = shp->shm_file->f_path;\n\tpath_get(&path);\n\tshp->shm_nattch++;\n\tsize = i_size_read(path.dentry->d_inode);\n\tipc_unlock_object(&shp->shm_perm);\n\trcu_read_unlock();\n\n\terr = -ENOMEM;\n\tsfd = kzalloc(sizeof(*sfd), GFP_KERNEL);\n\tif (!sfd) {\n\t\tpath_put(&path);\n\t\tgoto out_nattch;\n\t}\n\n\tfile = alloc_file(&path, f_mode,\n\t\t\t  is_file_hugepages(shp->shm_file) ?\n\t\t\t\t&shm_file_operations_huge :\n\t\t\t\t&shm_file_operations);\n\terr = PTR_ERR(file);\n\tif (IS_ERR(file)) {\n\t\tkfree(sfd);\n\t\tpath_put(&path);\n\t\tgoto out_nattch;\n\t}\n\n\tfile->private_data = sfd;\n\tfile->f_mapping = shp->shm_file->f_mapping;\n\tsfd->id = shp->shm_perm.id;\n\tsfd->ns = get_ipc_ns(ns);\n\tsfd->file = shp->shm_file;\n\tsfd->vm_ops = NULL;\n\n\terr = security_mmap_file(file, prot, flags);\n\tif (err)\n\t\tgoto out_fput;\n\n\tdown_write(&current->mm->mmap_sem);\n\tif (addr && !(shmflg & SHM_REMAP)) {\n\t\terr = -EINVAL;\n\t\tif (find_vma_intersection(current->mm, addr, addr + size))\n\t\t\tgoto invalid;\n\t\t/*\n\t\t * If shm segment goes below stack, make sure there is some\n\t\t * space left for the stack to grow (at least 4 pages).\n\t\t */\n\t\tif (addr < current->mm->start_stack &&\n\t\t    addr > current->mm->start_stack - size - PAGE_SIZE * 5)\n\t\t\tgoto invalid;\n\t}\n\n\taddr = do_mmap_pgoff(file, addr, size, prot, flags, 0, &populate);\n\t*raddr = addr;\n\terr = 0;\n\tif (IS_ERR_VALUE(addr))\n\t\terr = (long)addr;\ninvalid:\n\tup_write(&current->mm->mmap_sem);\n\tif (populate)\n\t\tmm_populate(addr, populate);\n\nout_fput:\n\tfput(file);\n\nout_nattch:\n\tdown_write(&shm_ids(ns).rwsem);\n\tshp = shm_lock(ns, shmid);\n\tBUG_ON(IS_ERR(shp));\n\tshp->shm_nattch--;\n\tif (shm_may_destroy(ns, shp))\n\t\tshm_destroy(ns, shp);\n\telse\n\t\tshm_unlock(shp);\n\tup_write(&shm_ids(ns).rwsem);\n\treturn err;\n\nout_unlock:\n\trcu_read_unlock();\nout:\n\treturn err;\n}\n\nSYSCALL_DEFINE3(shmat, int, shmid, char __user *, shmaddr, int, shmflg)\n{\n\tunsigned long ret;\n\tlong err;\n\n\terr = do_shmat(shmid, shmaddr, shmflg, &ret, SHMLBA);\n\tif (err)\n\t\treturn err;\n\tforce_successful_syscall_return();\n\treturn (long)ret;\n}\n\n/*\n * detach and kill segment if marked destroyed.\n * The work is done in shm_close.\n */\nSYSCALL_DEFINE1(shmdt, char __user *, shmaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tunsigned long addr = (unsigned long)shmaddr;\n\tint retval = -EINVAL;\n#ifdef CONFIG_MMU\n\tloff_t size = 0;\n\tstruct vm_area_struct *next;\n#endif\n\n\tif (addr & ~PAGE_MASK)\n\t\treturn retval;\n\n\tdown_write(&mm->mmap_sem);\n\n\t/*\n\t * This function tries to be smart and unmap shm segments that\n\t * were modified by partial mlock or munmap calls:\n\t * - It first determines the size of the shm segment that should be\n\t *   unmapped: It searches for a vma that is backed by shm and that\n\t *   started at address shmaddr. It records it's size and then unmaps\n\t *   it.\n\t * - Then it unmaps all shm vmas that started at shmaddr and that\n\t *   are within the initially determined size.\n\t * Errors from do_munmap are ignored: the function only fails if\n\t * it's called with invalid parameters or if it's called to unmap\n\t * a part of a vma. Both calls in this function are for full vmas,\n\t * the parameters are directly copied from the vma itself and always\n\t * valid - therefore do_munmap cannot fail. (famous last words?)\n\t */\n\t/*\n\t * If it had been mremap()'d, the starting address would not\n\t * match the usual checks anyway. So assume all vma's are\n\t * above the starting address given.\n\t */\n\tvma = find_vma(mm, addr);\n\n#ifdef CONFIG_MMU\n\twhile (vma) {\n\t\tnext = vma->vm_next;\n\n\t\t/*\n\t\t * Check if the starting address would match, i.e. it's\n\t\t * a fragment created by mprotect() and/or munmap(), or it\n\t\t * otherwise it starts at this address with no hassles.\n\t\t */\n\t\tif ((vma->vm_ops == &shm_vm_ops) &&\n\t\t\t(vma->vm_start - addr)/PAGE_SIZE == vma->vm_pgoff) {\n\n\n\t\t\tsize = file_inode(vma->vm_file)->i_size;\n\t\t\tdo_munmap(mm, vma->vm_start, vma->vm_end - vma->vm_start);\n\t\t\t/*\n\t\t\t * We discovered the size of the shm segment, so\n\t\t\t * break out of here and fall through to the next\n\t\t\t * loop that uses the size information to stop\n\t\t\t * searching for matching vma's.\n\t\t\t */\n\t\t\tretval = 0;\n\t\t\tvma = next;\n\t\t\tbreak;\n\t\t}\n\t\tvma = next;\n\t}\n\n\t/*\n\t * We need look no further than the maximum address a fragment\n\t * could possibly have landed at. Also cast things to loff_t to\n\t * prevent overflows and make comparisons vs. equal-width types.\n\t */\n\tsize = PAGE_ALIGN(size);\n\twhile (vma && (loff_t)(vma->vm_end - addr) <= size) {\n\t\tnext = vma->vm_next;\n\n\t\t/* finding a matching vma now does not alter retval */\n\t\tif ((vma->vm_ops == &shm_vm_ops) &&\n\t\t\t(vma->vm_start - addr)/PAGE_SIZE == vma->vm_pgoff)\n\n\t\t\tdo_munmap(mm, vma->vm_start, vma->vm_end - vma->vm_start);\n\t\tvma = next;\n\t}\n\n#else /* CONFIG_MMU */\n\t/* under NOMMU conditions, the exact address to be destroyed must be\n\t * given */\n\tif (vma && vma->vm_start == addr && vma->vm_ops == &shm_vm_ops) {\n\t\tdo_munmap(mm, vma->vm_start, vma->vm_end - vma->vm_start);\n\t\tretval = 0;\n\t}\n\n#endif\n\n\tup_write(&mm->mmap_sem);\n\treturn retval;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic int sysvipc_shm_proc_show(struct seq_file *s, void *it)\n{\n\tstruct user_namespace *user_ns = seq_user_ns(s);\n\tstruct shmid_kernel *shp = it;\n\tunsigned long rss = 0, swp = 0;\n\n\tshm_add_rss_swap(shp, &rss, &swp);\n\n#if BITS_PER_LONG <= 32\n#define SIZE_SPEC \"%10lu\"\n#else\n#define SIZE_SPEC \"%21lu\"\n#endif\n\n\treturn seq_printf(s,\n\t\t\t  \"%10d %10d  %4o \" SIZE_SPEC \" %5u %5u  \"\n\t\t\t  \"%5lu %5u %5u %5u %5u %10lu %10lu %10lu \"\n\t\t\t  SIZE_SPEC \" \" SIZE_SPEC \"\\n\",\n\t\t\t  shp->shm_perm.key,\n\t\t\t  shp->shm_perm.id,\n\t\t\t  shp->shm_perm.mode,\n\t\t\t  shp->shm_segsz,\n\t\t\t  shp->shm_cprid,\n\t\t\t  shp->shm_lprid,\n\t\t\t  shp->shm_nattch,\n\t\t\t  from_kuid_munged(user_ns, shp->shm_perm.uid),\n\t\t\t  from_kgid_munged(user_ns, shp->shm_perm.gid),\n\t\t\t  from_kuid_munged(user_ns, shp->shm_perm.cuid),\n\t\t\t  from_kgid_munged(user_ns, shp->shm_perm.cgid),\n\t\t\t  shp->shm_atim,\n\t\t\t  shp->shm_dtim,\n\t\t\t  shp->shm_ctim,\n\t\t\t  rss * PAGE_SIZE,\n\t\t\t  swp * PAGE_SIZE);\n}\n#endif\n"], "filenames": ["ipc/shm.c"], "buggy_code_start_loc": [210], "buggy_code_end_loc": [1103], "fixing_code_start_loc": [211], "fixing_code_end_loc": [1122], "type": "CWE-362", "message": "Multiple race conditions in ipc/shm.c in the Linux kernel before 3.12.2 allow local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via a crafted application that uses shmctl IPC_RMID operations in conjunction with other shm system calls.", "other": {"cve": {"id": "CVE-2013-7026", "sourceIdentifier": "cve@mitre.org", "published": "2013-12-09T18:55:10.640", "lastModified": "2014-01-08T04:42:59.620", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Multiple race conditions in ipc/shm.c in the Linux kernel before 3.12.2 allow local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via a crafted application that uses shmctl IPC_RMID operations in conjunction with other shm system calls."}, {"lang": "es", "value": "M\u00faltiples condiciones de carrera en ipc/shm.c en el kernel de Linux anterior a la versi\u00f3n 3.12.2 permite a usuarios locales provocar una denegaci\u00f3n de servicio (uso despu\u00e9s de liberaci\u00f3n y ca\u00edda del sistema) o posiblemente tener otro impacto sin especificar a trav\u00e9s de una aplicaci\u00f3n que usa operaciones shmctl IPC_RMID en conjunci\u00f3n con otras llamadas del sistema shm."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.7}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.12.1", "matchCriteriaId": "3E5AFED7-B198-4A43-B496-CD6B399748A6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "D30AEC07-3CBD-4F4F-9646-BEAA1D98750B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C2AA8E68-691B-499C-AEDD-3C0BFFE70044"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "9440475B-5960-4066-A204-F30AAFC87846"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "53BCFBFB-6AF0-4525-8623-7633CC5E17DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "6ED4E86A-74F0-436A-BEB4-3F4EE93A5421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc6:*:*:*:*:*:*", "matchCriteriaId": "BF0365B0-8E16-4F30-BD92-5DD538CC8135"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc7:*:*:*:*:*:*", "matchCriteriaId": "079505E8-2942-4C33-93D1-35ADA4C39E72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "38989541-2360-4E0A-AE5A-3D6144AA6114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "4E51646B-7A0E-40F3-B8C9-239C1DA81DD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "42A8A507-F8E2-491C-A144-B2448A1DB26E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "901FC6F3-2C2A-4112-AE27-AB102BBE8DEE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "203AD334-DB9F-41B0-A4D1-A6C158EF8C40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "B3611753-E440-410F-8250-600C996A4B8E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "9739BB47-EEAF-42F1-A557-2AE2EA9526A3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "5A95E3BB-0AFC-4C2E-B9BE-C975E902A266"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "482A6C9A-9B8E-4D1C-917A-F16370745E7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "C6D87357-63E0-41D0-9F02-1BCBF9A77E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "3765A2D6-2D78-4FB1-989E-D5106BFA3F5E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "F54257DB-7023-43C4-AC4D-9590B815CD92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "61FF5FCD-A4A1-4803-AC53-320A4C838AF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "9F096553-064F-46A2-877B-F32F163A0F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "C0D762D1-E3AD-40EA-8D39-83EEB51B5E85"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.16:*:*:*:*:*:*:*", "matchCriteriaId": "A6187D19-7148-4B87-AD7E-244FF9EE0FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.17:*:*:*:*:*:*:*", "matchCriteriaId": "99AC64C2-E391-485C-9CD7-BA09C8FA5E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.18:*:*:*:*:*:*:*", "matchCriteriaId": "8CDA5E95-7805-441B-BEF7-4448EA45E964"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.19:*:*:*:*:*:*:*", "matchCriteriaId": "51561053-6C28-4F38-BC9B-3F7A7508EB72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.20:*:*:*:*:*:*:*", "matchCriteriaId": "118F4A5B-C498-4FC3-BE28-50D18EBE4F22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.21:*:*:*:*:*:*:*", "matchCriteriaId": "BD38EBE6-FE1A-4B55-9FB5-07952253B7A5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.22:*:*:*:*:*:*:*", "matchCriteriaId": "3A491E47-82AD-4055-9444-2EC0D6715326"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.23:*:*:*:*:*:*:*", "matchCriteriaId": "13C5FD16-23B6-467F-9438-5B554922F974"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.24:*:*:*:*:*:*:*", "matchCriteriaId": "9C67235F-5B51-4BF7-89EC-4810F720246F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.25:*:*:*:*:*:*:*", "matchCriteriaId": "08405DEF-05F4-45F0-AC95-DBF914A36D93"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.26:*:*:*:*:*:*:*", "matchCriteriaId": "1A7B9C4B-4A41-4175-9F07-191C1EE98C1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.27:*:*:*:*:*:*:*", "matchCriteriaId": "B306E0A8-4D4A-4895-8128-A500D30A7E0C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.28:*:*:*:*:*:*:*", "matchCriteriaId": "295C839A-F34E-4853-A926-55EABC639412"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.29:*:*:*:*:*:*:*", "matchCriteriaId": "2AFD5F49-7EF9-4CFE-95BD-8FD19B500B0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.30:*:*:*:*:*:*:*", "matchCriteriaId": "00B3DDDD-B2F6-4753-BA38-65A24017857D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.31:*:*:*:*:*:*:*", "matchCriteriaId": "33FCD39E-F4BF-432D-9CF9-F195CF5844F3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.32:*:*:*:*:*:*:*", "matchCriteriaId": "C7308690-CB0D-4758-B80F-D2ADCD2A9D66"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.33:*:*:*:*:*:*:*", "matchCriteriaId": "313A470B-8A2B-478A-82B5-B27D2718331C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.34:*:*:*:*:*:*:*", "matchCriteriaId": "83FF021E-07E3-41CC-AAE8-D99D7FF24B9D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.35:*:*:*:*:*:*:*", "matchCriteriaId": "F72412E3-8DA9-4CC9-A426-B534202ADBA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.36:*:*:*:*:*:*:*", "matchCriteriaId": "FCAA9D7A-3C3E-4C0B-9D38-EA80E68C2E46"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.37:*:*:*:*:*:*:*", "matchCriteriaId": "4A9E3AE5-3FCF-4CBB-A30B-082BCFBFB0CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.38:*:*:*:*:*:*:*", "matchCriteriaId": "CF715657-4C3A-4392-B85D-1BBF4DE45D89"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.39:*:*:*:*:*:*:*", "matchCriteriaId": "4B63C618-AC3D-4EF7-AFDF-27B9BF482B78"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.40:*:*:*:*:*:*:*", "matchCriteriaId": "C33DA5A9-5E40-4365-9602-82FB4DCD15B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.41:*:*:*:*:*:*:*", "matchCriteriaId": "EFAFDB74-40BD-46FA-89AC-617EB2C7160B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.42:*:*:*:*:*:*:*", "matchCriteriaId": "CF5F17DA-30A7-40CF-BD7C-CEDF06D64617"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.43:*:*:*:*:*:*:*", "matchCriteriaId": "71A276F5-BD9D-4C1B-90DF-9B0C15B6F7DF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.44:*:*:*:*:*:*:*", "matchCriteriaId": "F8F6EBEC-3C29-444B-BB85-6EF239B59EC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.45:*:*:*:*:*:*:*", "matchCriteriaId": "FDB91302-FD18-44CF-A8A8-B31483328539"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.46:*:*:*:*:*:*:*", "matchCriteriaId": "9B81DC2B-46FA-4640-AD6C-2A404D94BA0B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.47:*:*:*:*:*:*:*", "matchCriteriaId": "BA6A1663-BC4C-4FC9-B5EB-A52EDED17B26"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.48:*:*:*:*:*:*:*", "matchCriteriaId": "69C33D6C-6B9F-49F4-B505-E7B589CDEC50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.49:*:*:*:*:*:*:*", "matchCriteriaId": "C464796B-2F31-4159-A132-82A0C74137B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.50:*:*:*:*:*:*:*", "matchCriteriaId": "1D6C6E46-FE29-4D2D-A0EC-43DA5112BCC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.51:*:*:*:*:*:*:*", "matchCriteriaId": "1A370E91-73A1-4D62-8E7B-696B920203F8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.52:*:*:*:*:*:*:*", "matchCriteriaId": "340197CD-9645-4B7E-B976-F3F5A7D4C5BE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.53:*:*:*:*:*:*:*", "matchCriteriaId": "96030636-0C4A-4A10-B768-525D6A0E18CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.54:*:*:*:*:*:*:*", "matchCriteriaId": "A42D8419-914F-4AD6-B0E9-C1290D514FF1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.55:*:*:*:*:*:*:*", "matchCriteriaId": "F4E2C88B-42EA-4F4F-B1F6-A9332EC6888B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.56:*:*:*:*:*:*:*", "matchCriteriaId": "2449D13B-3314-4182-832F-03F6B11AA31F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.57:*:*:*:*:*:*:*", "matchCriteriaId": "9A35B66C-F050-4462-A58E-FEE061B5582E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.58:*:*:*:*:*:*:*", "matchCriteriaId": "1B551164-0167-49BB-A3AE-4034BDA3DCB4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.59:*:*:*:*:*:*:*", "matchCriteriaId": "7244278E-49B6-4405-A14C-F3540C8F5AF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.60:*:*:*:*:*:*:*", "matchCriteriaId": "B4C3E4B8-7274-4ABB-B7CE-6A39C183CE18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.61:*:*:*:*:*:*:*", "matchCriteriaId": "6501EDB9-4847-47F8-90EE-B295626E4CDC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.62:*:*:*:*:*:*:*", "matchCriteriaId": "2D676D48-7521-45E2-8563-6B966FF86A35"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.63:*:*:*:*:*:*:*", "matchCriteriaId": "3B69FA17-0AB9-4986-A5A7-2A4C1DD24222"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.64:*:*:*:*:*:*:*", "matchCriteriaId": "7BC35593-96C7-41F0-B738-1568F8129121"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.65:*:*:*:*:*:*:*", "matchCriteriaId": "38D23794-0E7C-4FA5-A7A8-CF940E3FA962"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.66:*:*:*:*:*:*:*", "matchCriteriaId": "008E1E7D-4C20-4560-9288-EF532ADB0029"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.67:*:*:*:*:*:*:*", "matchCriteriaId": "3B3A7044-A92E-47A9-A7BD-35E5B575F5FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.68:*:*:*:*:*:*:*", "matchCriteriaId": "783E2980-B6AB-489E-B157-B6A2E10A32CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:*:*:*:*:*:*:*", "matchCriteriaId": "3DFFE5A6-6A67-4992-84A3-C0F05FACDEAD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc1:*:*:*:*:*:*", "matchCriteriaId": "13BBD2A3-AE10-48B9-8776-4FB1CAC37D44"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc2:*:*:*:*:*:*", "matchCriteriaId": "B25680CC-8918-4F27-8D7E-A6579215450B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc3:*:*:*:*:*:*", "matchCriteriaId": "92C48B4C-410C-4BA8-A28A-B2E928320FCC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc4:*:*:*:*:*:*", "matchCriteriaId": "CB447523-855B-461E-8197-95169BE86EB0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "B155BBDF-6DF6-4FF5-9C41-D8A5266DCC67"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "28476DEC-9630-4B40-9D4D-9BC151DC4CA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "5646880A-2355-4BDD-89E7-825863A0311F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "7FF99148-267A-46F8-9927-A9082269BAF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "A783C083-5D9C-48F9-B5A6-A97A9604FB19"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "2B817A24-03AC-46CD-BEFA-505457FD2A5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "51CF1BCE-090E-4B70-BA16-ACB74411293B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "187AAD67-10D7-4B57-B4C6-00443E246AF3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "F341CE88-C5BC-4CDD-9CB5-B6BAD7152E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.10:*:*:*:*:*:*:*", "matchCriteriaId": "37ACE2A6-C229-4236-8E9F-235F008F3AA0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "D3220B70-917F-4F9F-8A3B-2BF581281E8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc2:*:*:*:*:*:*", "matchCriteriaId": "99372D07-C06A-41FA-9843-6D57F99AB5AF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc3:*:*:*:*:*:*", "matchCriteriaId": "2B9DC110-D260-4DB4-B8B0-EF1D160ADA07"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc4:*:*:*:*:*:*", "matchCriteriaId": "6192FE84-4D53-40D4-AF61-78CE7136141A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc5:*:*:*:*:*:*", "matchCriteriaId": "42FEF3CF-1302-45EB-89CC-3786FE4BAC1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc6:*:*:*:*:*:*", "matchCriteriaId": "AE6A6B58-2C89-4DE4-BA57-78100818095C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc7:*:*:*:*:*:*", "matchCriteriaId": "1D467F87-2F13-4D26-9A93-E0BA526FEA24"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "FE348F7B-02DE-47D5-8011-F83DA9426021"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "E91594EA-F0A3-41B3-A9C6-F7864FC2F229"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "9E1ECCDB-0208-48F6-B44F-16CC0ECE3503"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "FBA8B5DE-372E-47E0-A0F6-BE286D509CC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "9A1CA083-2CF8-45AE-9E15-1AA3A8352E3B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "19D69A49-5290-4C5F-8157-719AD58D253D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "290BD969-42E7-47B0-B21B-06DE4865432C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "23A9E29E-DE78-4C73-9FBD-C2410F5FC8B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.9:*:*:*:*:*:*:*", "matchCriteriaId": "018434C9-E75F-45CB-A169-DAB4B1D864D7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.10:*:*:*:*:*:*:*", "matchCriteriaId": "DC0AC68F-EC58-4C4F-8CBC-A59ECC00CCDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.11:*:*:*:*:*:*:*", "matchCriteriaId": "C123C844-F6D7-471E-A62E-F756042FB1CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.12:*:*:*:*:*:*:*", "matchCriteriaId": "A11C38BB-7FA2-49B0-AAC9-83DB387A06DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.13:*:*:*:*:*:*:*", "matchCriteriaId": "61F3733C-E5F6-4855-B471-DF3FB823613B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.14:*:*:*:*:*:*:*", "matchCriteriaId": "1DDCA75F-9A06-4457-9A45-38A38E7F7086"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.15:*:*:*:*:*:*:*", "matchCriteriaId": "7AEA837E-7864-4003-8DB7-111ED710A7E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.16:*:*:*:*:*:*:*", "matchCriteriaId": "B6FE471F-2D1F-4A1D-A197-7E46B75787E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.17:*:*:*:*:*:*:*", "matchCriteriaId": "FDA9E6AB-58DC-4EC5-A25C-11F9D0B38BF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.18:*:*:*:*:*:*:*", "matchCriteriaId": "DC6B8DB3-B05B-41A2-B091-342D66AAE8F5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.19:*:*:*:*:*:*:*", "matchCriteriaId": "958F0FF8-33EF-4A71-A0BD-572C85211DBA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.20:*:*:*:*:*:*:*", "matchCriteriaId": "FBA39F48-B02F-4C48-B304-DA9CCA055244"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.21:*:*:*:*:*:*:*", "matchCriteriaId": "1FF841F3-48A7-41D7-9C45-A8170435A5EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.22:*:*:*:*:*:*:*", "matchCriteriaId": "EF506916-A6DC-4B1E-90E5-959492AF55F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.23:*:*:*:*:*:*:*", "matchCriteriaId": "B3CDAD1F-2C6A-48C0-8FAB-C2659373FA25"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.24:*:*:*:*:*:*:*", "matchCriteriaId": "4FFE4B22-C96A-43D0-B993-F51EDD9C5E0E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.25:*:*:*:*:*:*:*", "matchCriteriaId": "F571CC8B-B212-4553-B463-1DB01D616E8A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.26:*:*:*:*:*:*:*", "matchCriteriaId": "84E3E151-D437-48ED-A529-731EEFF88567"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.27:*:*:*:*:*:*:*", "matchCriteriaId": "E9E3EA3C-CCA5-4433-86E0-3D02C4757A0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.28:*:*:*:*:*:*:*", "matchCriteriaId": "F7AC4F7D-9FA6-4CF1-B2E9-70BF7D4D177C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.29:*:*:*:*:*:*:*", "matchCriteriaId": "3CE3A80D-9648-43CC-8F99-D741ED6552BF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.30:*:*:*:*:*:*:*", "matchCriteriaId": "C8A98C03-A465-41B4-A551-A26FEC7FFD94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:*:*:*:*:*:*:*", "matchCriteriaId": "AFB76697-1C2F-48C0-9B14-517EC053D4B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc1:*:*:*:*:*:*", "matchCriteriaId": "BED88DFD-1DC5-4505-A441-44ECDEF0252D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc2:*:*:*:*:*:*", "matchCriteriaId": "DBFD2ACD-728A-4082-BB6A-A1EF6E58E47D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc3:*:*:*:*:*:*", "matchCriteriaId": "C31B0E51-F62D-4053-B04F-FC4D5BC373D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc4:*:*:*:*:*:*", "matchCriteriaId": "A914303E-1CB6-4AAD-9F5F-DE5433C4E814"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc5:*:*:*:*:*:*", "matchCriteriaId": "203BBA69-90B2-4C5E-8023-C14180742421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc6:*:*:*:*:*:*", "matchCriteriaId": "0DBFAB53-B889-4028-AC0E-7E165B152A18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc7:*:*:*:*:*:*", "matchCriteriaId": "FE409AEC-F677-4DEF-8EB7-2C35809043CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "578EC12B-402F-4AD4-B8F8-C9B2CAB06891"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "877002ED-8097-4BB4-BB88-6FC6306C38B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "76294CE3-D72C-41D5-9E0F-B693D0042699"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "916E97D4-1FAB-42F5-826B-653B1C0909A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "33FD2217-C5D0-48C1-AD74-3527127FEF9C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "2E92971F-B629-4E0A-9A50-8B235F9704B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.7:*:*:*:*:*:*:*", "matchCriteriaId": "EDD3A069-3829-4EE2-9D5A-29459F29D4C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.8:*:*:*:*:*:*:*", "matchCriteriaId": "A4A0964C-CEB2-41D7-A69C-1599B05B6171"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "0F960FA6-F904-4A4E-B483-44C70090E9A1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:*:*", "matchCriteriaId": "261C1B41-C9E0-414F-8368-51C0C0B8AD38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:*:*", "matchCriteriaId": "5CCA261D-2B97-492F-89A0-5F209A804350"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:*:*", "matchCriteriaId": "1B1C0C68-9194-473F-BE5E-EC7F184899FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:*:*", "matchCriteriaId": "D7A6AC9E-BEA6-44B0-B3B3-F0F94E32424A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:*:*", "matchCriteriaId": "16038328-9399-4B85-B777-BA4757D02C9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:*:*", "matchCriteriaId": "16CA2757-FA8D-43D9-96E8-D3C0EB6E1DEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:*:*", "matchCriteriaId": "E8CB5481-5EAE-401E-BD7E-D3095CCA9E94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "A0F36FAC-141D-476D-84C5-A558C199F904"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "51D64824-25F6-4761-BD6A-29038A143744"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "E284C8A1-740F-454D-A774-99CD3A21B594"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "C70D72AE-0CBF-4324-9935-57E28EC6279C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "F674B06B-7E86-4E41-9126-8152D0DDABAE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "7039B3EC-8B22-413E-B582-B4BEC6181241"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "35CF1DD2-80B9-4476-8963-5C3EF52B33F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "BFB0B05B-A5CE-4B9C-AE7F-83062868D35B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.9:*:*:*:*:*:*:*", "matchCriteriaId": "D166A66E-7454-47EC-BB56-861A9AFEAFE1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "7DA94F50-2A62-4300-BF4D-A342AAE35629"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.11:*:*:*:*:*:*:*", "matchCriteriaId": "252D937B-50DC-444F-AE73-5FCF6203DF27"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.12:*:*:*:*:*:*:*", "matchCriteriaId": "F6D8EE51-02C1-47BC-A92C-0A8ABEFD28FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.13:*:*:*:*:*:*:*", "matchCriteriaId": "7F20A5D7-3B38-4911-861A-04C8310D5916"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.14:*:*:*:*:*:*:*", "matchCriteriaId": "D472DE3A-71D8-4F40-9DDE-85929A2B047D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.15:*:*:*:*:*:*:*", "matchCriteriaId": "B2AED943-65A8-4FDB-BBD0-CCEF8682A48C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.16:*:*:*:*:*:*:*", "matchCriteriaId": "D4640185-F3D8-4575-A71D-4C889A93DE2C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.17:*:*:*:*:*:*:*", "matchCriteriaId": "144CCF7C-025E-4879-B2E7-ABB8E4390BE5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.18:*:*:*:*:*:*:*", "matchCriteriaId": "B6FAA052-0B2B-40CE-8C98-919B8D08A5ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.19:*:*:*:*:*:*:*", "matchCriteriaId": "4B5A53DE-9C83-4A6B-96F3-23C03BF445D9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.20:*:*:*:*:*:*:*", "matchCriteriaId": "063EB879-CB05-4E33-AA90-9E43516839B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.21:*:*:*:*:*:*:*", "matchCriteriaId": "2D25764F-4B02-4C65-954E-8C7D6632DE00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.22:*:*:*:*:*:*:*", "matchCriteriaId": "F31F5BF3-CD0A-465C-857F-273841BCD28A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.23:*:*:*:*:*:*:*", "matchCriteriaId": "FF302C8A-079B-42B9-B455-CD9083BFA067"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.24:*:*:*:*:*:*:*", "matchCriteriaId": "744999C0-33D3-4363-B3DB-E0D02CDD3918"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.25:*:*:*:*:*:*:*", "matchCriteriaId": "C2E77A76-2A60-45D8-9337-867BC22C5110"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.26:*:*:*:*:*:*:*", "matchCriteriaId": "C9F4AAE7-C870-46B7-B559-2949737BE777"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.27:*:*:*:*:*:*:*", "matchCriteriaId": "20FA2824-20B0-48B8-BB0A-4904C1D3E8AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.28:*:*:*:*:*:*:*", "matchCriteriaId": "9F9B347E-61AC-419F-9701-B862BBFA46F2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.29:*:*:*:*:*:*:*", "matchCriteriaId": "989F351C-8B7C-4C1B-AFA2-AE9431576368"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.30:*:*:*:*:*:*:*", "matchCriteriaId": "8D22172A-9FA7-42E0-8451-165D8E47A573"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.31:*:*:*:*:*:*:*", "matchCriteriaId": "CE31624C-94F9-45D8-9B4A-D0028F10602F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.32:*:*:*:*:*:*:*", "matchCriteriaId": "70967A83-28F6-4568-9ADA-6EF232E5BBC2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "962B0C45-AB29-4383-AC16-C6E8245D0FF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "A0EE126B-74B2-4F79-BFE1-3DC169F3F9B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "392075E0-A9C7-4B4A-90F9-7F1ADFF5EFA7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "ECC66968-06F0-4874-A95A-A292C36E45C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "5FE986E6-1068-4E1B-8EAB-DF1EAF32B4E3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "543E8536-1A8E-4E76-B89F-1B1F9F26FAB8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.7:*:*:*:*:*:*:*", "matchCriteriaId": "EC2B45E3-31E1-4B46-85FA-3A84E75B8F84"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6:*:*:*:*:*:*:*", "matchCriteriaId": "DDB8CC75-D3EE-417C-A83D-CB6D666FE595"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "09A072F1-7BEE-4236-ACBB-55DB8FEF4A03"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "E19D5A58-17D6-4502-A57A-70B2F84817A4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "D58BA035-1204-4DFA-98A1-12111FB6222E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "A17F2E87-8EB8-476A-B5B5-9AE5CF53D9FE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.5:*:*:*:*:*:*:*", "matchCriteriaId": "A8CCC101-5852-4299-9B67-EA1B149D58C0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.6:*:*:*:*:*:*:*", "matchCriteriaId": "B8074D32-C252-4AD3-A579-1C5EDDD7014B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.7:*:*:*:*:*:*:*", "matchCriteriaId": "962AA802-8179-4606-AAC0-9363BAEABC9F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.8:*:*:*:*:*:*:*", "matchCriteriaId": "1286C858-D5A2-45F3-86D1-E50FE53FB23C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.9:*:*:*:*:*:*:*", "matchCriteriaId": "5AC4A13E-F560-4D01-98A3-E2A2B82EB25B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.10:*:*:*:*:*:*:*", "matchCriteriaId": "942C462A-5398-4BB9-A792-598682E1FEF2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.11:*:*:*:*:*:*:*", "matchCriteriaId": "B852F7E0-0282-483D-BB4D-18CB7A4F1392"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7:*:*:*:*:*:*:*", "matchCriteriaId": "53ED9A31-99CC-41C8-8B72-5B2A9B49AA6C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "EFD646BC-62F7-47CF-B0BE-768F701F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F43D418E-87C1-4C83-9FF1-4F45B4F452DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "680D0E00-F29A-487C-8770-8E7EAC672B7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "2DCA96A4-A836-4E94-A39C-3AD3EA1D9611"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "753C05E3-B603-4E36-B9BA-FAEDCBF62A7D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "E385C2E0-B9F1-4564-8E6D-56FD9E762405"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "041335D4-05E1-4004-9381-28AAD5994B47"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "370F2AE5-3DBC-46B9-AC70-F052C9229C00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "7A971BE3-259D-4494-BBC5-12793D92DB57"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.10:*:*:*:*:*:*:*", "matchCriteriaId": "8E4719A6-FDEA-4714-A830-E23A52AE90BC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A6E41FB-38CE-49F2-B796-9A5AA648E73F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "93523FE1-5993-46CB-9299-7C8C1A04E873"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "27ADC356-6BE9-43A3-9E0B-393DC4B1559A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "4F543D23-1774-4D14-A7D1-AD49EDEA94DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "FC323F58-CA00-4C3C-BA4D-CC2C0A6E5F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "FEA0B2E3-668D-40ED-9D3D-709EB6449F8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "3431B258-4EC8-4E7F-87BB-4D934880601E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "1B09FA1E-8B28-4F2A-BA7E-8E1C40365970"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "91917120-9D68-41C0-8B5D-85C256BC6200"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.9:*:*:*:*:*:*:*", "matchCriteriaId": "AAD268A0-096C-4C31-BEC5-D47F5149D462"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.10:*:*:*:*:*:*:*", "matchCriteriaId": "32BD2427-C47F-4660-A1D9-448E500EF5B9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.11:*:*:*:*:*:*:*", "matchCriteriaId": "02048CE5-81C7-4DFB-BC40-CE4C86B7E022"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.12:*:*:*:*:*:*:*", "matchCriteriaId": "934D2B37-0575-4A75-B00B-0028316D6DF0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.13:*:*:*:*:*:*:*", "matchCriteriaId": "06754C21-995C-4850-A4DC-F21826C0F8C5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc1:*:*:*:*:*:*", "matchCriteriaId": "42633FF9-FB0C-4095-B4A1-8D623A98683B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc2:*:*:*:*:*:*", "matchCriteriaId": "08C04619-89A2-4B15-82A2-48BCC662C1F1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc3:*:*:*:*:*:*", "matchCriteriaId": "5B039196-7159-476C-876A-C61242CC41DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc4:*:*:*:*:*:*", "matchCriteriaId": "3A9E0457-53C9-44DD-ACFB-31EE1D1E060E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc5:*:*:*:*:*:*", "matchCriteriaId": "BEE406E7-87BA-44BA-BF61-673E6CC44A2F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc6:*:*:*:*:*:*", "matchCriteriaId": "29FBA173-658F-45DC-8205-934CACD67166"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc7:*:*:*:*:*:*", "matchCriteriaId": "139700F0-BA32-40CF-B9DF-C9C450384FDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "E578085C-3968-4543-BEBA-EE3C3CB4FA02"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "4DCFA441-68FB-4559-A245-FF0B79DE43CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "8C2508D8-6571-4B81-A0D7-E494CCD039CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "8B516926-5E86-4C0A-85F3-F64E1FCDA249"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "069D774D-79BE-479F-BF4E-F021AD808114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "D15B27A9-46E0-4DDF-A00C-29F8F1F18D73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "A381BB4A-28B4-4672-87EE-91B3DDD6C71A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.7:*:*:*:*:*:*:*", "matchCriteriaId": "922F80CF-937D-4FA2-AFF2-6E47FFE9E1E9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "A548ADF4-9E3B-407C-A5ED-05150EB3A185"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.9:*:*:*:*:*:*:*", "matchCriteriaId": "9C623230-4497-41B9-9BD2-7A6CFDD77983"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.10:*:*:*:*:*:*:*", "matchCriteriaId": "C72FA8A6-60A6-4486-A245-7BEF8B2A2711"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.11:*:*:*:*:*:*:*", "matchCriteriaId": "0A498D90-BB99-405E-9FA6-1FBFE179787E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "D0D32776-8ADB-4E79-846A-C0C99FED19E0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.2:*:*:*:*:*:*:*", "matchCriteriaId": "B7D01673-D13F-487F-81B6-1279C187277E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "ADB27A3E-78E4-40F7-9716-A1099B0D85FB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "16E7136A-A8A6-4BF5-AF5D-AFB5C7A10712"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.5:*:*:*:*:*:*:*", "matchCriteriaId": "6FE127AC-E61D-427A-B998-D60DF5AABA21"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.6:*:*:*:*:*:*:*", "matchCriteriaId": "3819FF99-AEC5-4466-8542-D395419E4308"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.7:*:*:*:*:*:*:*", "matchCriteriaId": "E621FA1A-464B-4D2A-A0D6-EDA475A3709B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.8:*:*:*:*:*:*:*", "matchCriteriaId": "B760B422-EA11-43AB-B6D2-CA54E7229663"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.9:*:*:*:*:*:*:*", "matchCriteriaId": "D2CA7BBC-917C-4F31-A442-465C30444836"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.10:*:*:*:*:*:*:*", "matchCriteriaId": "AE778000-4FD5-4032-86CE-5930EF4CB7C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.11:*:*:*:*:*:*:*", "matchCriteriaId": "B3344EEB-F037-48FE-81DC-67F6384F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.12:*:*:*:*:*:*:*", "matchCriteriaId": "0244B0CA-9C67-4F06-BFBA-1F257112AC08"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.13:*:*:*:*:*:*:*", "matchCriteriaId": "2148C13F-4BB0-4D46-A688-F7C726D12497"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.14:*:*:*:*:*:*:*", "matchCriteriaId": "9871AF57-9158-4A41-8340-596B4463289A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.15:*:*:*:*:*:*:*", "matchCriteriaId": "2A875207-DF01-4240-8895-49B62693D27B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.16:*:*:*:*:*:*:*", "matchCriteriaId": "FE04A172-6F3B-4E3B-8D4D-564740FABAAF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.17:*:*:*:*:*:*:*", "matchCriteriaId": "CFEEF8C4-7DC2-4230-B58C-337F39A4DFAF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.18:*:*:*:*:*:*:*", "matchCriteriaId": "9F74DB5C-5096-438C-8C8A-6D337A2FD06A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11:*:*:*:*:*:*:*", "matchCriteriaId": "639E3A57-A9E7-40E6-8929-81CCC0060EFB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "07012ADD-F521-40A8-B067-E87C2238A3D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.2:*:*:*:*:*:*:*", "matchCriteriaId": "3F5FF393-3F89-4274-B82B-F671358072ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.3:*:*:*:*:*:*:*", "matchCriteriaId": "E348698F-54D1-4F5E-B701-CFAF50881E0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.4:*:*:*:*:*:*:*", "matchCriteriaId": "932205D9-3514-4289-9B55-C7A169276930"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.5:*:*:*:*:*:*:*", "matchCriteriaId": "2ECB2D33-F517-480F-8A6F-99D9D6C49596"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.6:*:*:*:*:*:*:*", "matchCriteriaId": "D16F68DD-E2D4-4AA4-AB81-3796C2947E37"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.7:*:*:*:*:*:*:*", "matchCriteriaId": "2422AC23-8410-4524-A733-25E4ABC7515D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.12:*:*:*:*:*:*:*", "matchCriteriaId": "B291154A-4B91-4A0E-AAAE-716A8BB7BF99"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=a399b29dfbaaaf91162b2dc5a5875dd51bbfa2a1", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.12.2", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2070-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2075-1", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/a399b29dfbaaaf91162b2dc5a5875dd51bbfa2a1", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/a399b29dfbaaaf91162b2dc5a5875dd51bbfa2a1"}}