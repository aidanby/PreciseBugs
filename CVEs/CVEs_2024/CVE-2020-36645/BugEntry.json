{"buggy_code": ["// Copyright 2012, Google Inc. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n//\n// SQUARE NOTE: The encoding routines were derived from vitess's\n// sqlparser package. The original source can be found at\n// https://code.google.com/p/vitess/\n\npackage squalor\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n)\n\n// Instructions for creating new types: If a type needs to satisfy an\n// interface, declare that function along with that interface. This\n// will help users identify the list of types to which they can assert\n// those interfaces. If the member of a type has a string with a\n// predefined list of values, declare those values as const following\n// the type. For interfaces that define dummy functions to\n// consolidate a set of types, define the function as typeName().\n// This will help avoid name collisions.\n\n// The Serializer interface is implemented by all\n// expressions/statements.\ntype Serializer interface {\n\t// Serialize writes the statement/expression to the Writer. If an\n\t// error is returned the Writer may contain partial output.\n\tSerialize(w Writer) error\n}\n\n// Serialize serializes a serializer to a string.\nfunc Serialize(s Serializer) (string, error) {\n\tw := &standardWriter{}\n\tif err := s.Serialize(w); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn w.String(), nil\n}\n\n// SerializeWithPlaceholders serializes a serializer to a string but without substituting\n// values. It may be useful for logging.\nfunc SerializeWithPlaceholders(s Serializer) (string, error) {\n\tw := &placeholderWriter{}\n\tif err := s.Serialize(w); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn w.String(), nil\n}\n\n// Writer defines an interface for writing a AST as SQL.\ntype Writer interface {\n\tio.Writer\n\n\t// WriteBytes writes a string of unprintable value.\n\tWriteBytes(node BytesVal) error\n\t// WriteEncoded writes an already encoded value.\n\tWriteEncoded(node EncodedVal) error\n\t// WriteNum writes a number value.\n\tWriteNum(node NumVal) error\n\t// WriteRaw writes a raw Go value.\n\tWriteRaw(node RawVal) error\n\t// WriteStr writes a SQL string value.\n\tWriteStr(node StrVal) error\n}\n\ntype standardWriter struct {\n\tbytes.Buffer\n}\n\nfunc (w *standardWriter) WriteRaw(node RawVal) error {\n\treturn encodeSQLValue(w, node.Val)\n}\n\nfunc (w *standardWriter) WriteEncoded(node EncodedVal) error {\n\t_, err := w.Write(node.Val)\n\treturn err\n}\n\nfunc (w *standardWriter) WriteStr(node StrVal) error {\n\treturn encodeSQLString(w, string(node))\n}\n\nfunc (w *standardWriter) WriteBytes(node BytesVal) error {\n\treturn encodeSQLBytes(w, []byte(node))\n}\n\nfunc (w *standardWriter) WriteNum(node NumVal) error {\n\t_, err := io.WriteString(w, string(node))\n\treturn err\n}\n\n// placeholderWriter will write all SQL value types as ? placeholders.\ntype placeholderWriter struct {\n\tbytes.Buffer\n}\n\nfunc (w *placeholderWriter) WriteRaw(node RawVal) error {\n\t_, err := w.Write(astPlaceholder)\n\treturn err\n}\n\nfunc (w *placeholderWriter) WriteEncoded(node EncodedVal) error {\n\t_, err := w.Write(astPlaceholder)\n\treturn err\n}\n\nfunc (w *placeholderWriter) WriteStr(node StrVal) error {\n\t_, err := w.Write(astPlaceholder)\n\treturn err\n}\n\nfunc (w *placeholderWriter) WriteBytes(node BytesVal) error {\n\t_, err := w.Write(astPlaceholder)\n\treturn err\n}\n\nfunc (w *placeholderWriter) WriteNum(node NumVal) error {\n\t_, err := w.Write(astPlaceholder)\n\treturn err\n}\n\nvar (\n\t// Placeholder is a placeholder for a value in a SQL statement. It is replaced with\n\t// an actual value when the query is executed.\n\tPlaceholder = PlaceholderVal{}\n)\n\n// Statement represents a statement.\ntype Statement interface {\n\tSerializer\n\tstatement()\n}\n\nfunc (*Union) statement()  {}\nfunc (*Select) statement() {}\nfunc (*Insert) statement() {}\nfunc (*Update) statement() {}\nfunc (*Delete) statement() {}\n\n// SelectStatement any SELECT statement.\ntype SelectStatement interface {\n\tStatement\n\tselectStatement()\n\tinsertRows()\n}\n\nfunc (*Select) selectStatement() {}\nfunc (*Union) selectStatement()  {}\n\n// Select represents a SELECT statement.\ntype Select struct {\n\tComments Comments\n\tDistinct string\n\tExprs    SelectExprs\n\tFrom     TableExprs\n\tWhere    *Where\n\tGroupBy  GroupBy\n\tHaving   *Where\n\tOrderBy  OrderBy\n\tLimit    *Limit\n\tLock     string\n}\n\n// Select.Distinct\nconst (\n\tastDistinct = \"DISTINCT \"\n)\n\n// Select.Lock\nconst (\n\tastForUpdate = \" FOR UPDATE\"\n\tastShareMode = \" LOCK IN SHARE MODE\"\n)\n\nvar (\n\tastSelect     = []byte(\"SELECT \")\n\tastSelectFrom = []byte(\" FROM \")\n)\n\nfunc (node *Select) Serialize(w Writer) error {\n\tif _, err := w.Write(astSelect); err != nil {\n\t\treturn err\n\t}\n\tif _, err := io.WriteString(w, node.Distinct); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Exprs.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif _, err := w.Write(astSelectFrom); err != nil {\n\t\treturn err\n\t}\n\tif err := node.From.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Where.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif err := node.GroupBy.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Having.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif err := node.OrderBy.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Limit.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\t_, err := io.WriteString(w, node.Lock)\n\treturn err\n}\n\n// Union represents a UNION statement.\ntype Union struct {\n\tType        string\n\tLeft, Right SelectStatement\n}\n\n// Union.Type\nconst (\n\tastUnion     = \"UNION\"\n\tastUnionAll  = \"UNION ALL\"\n\tastSetMinus  = \"MINUS\"\n\tastExcept    = \"EXCEPT\"\n\tastIntersect = \"INTERSECT\"\n)\n\nfunc (node *Union) Serialize(w Writer) error {\n\tif err := node.Left.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif _, err := w.Write(astSpace); err != nil {\n\t\treturn err\n\t}\n\tif _, err := io.WriteString(w, node.Type); err != nil {\n\t\treturn err\n\t}\n\tif _, err := w.Write(astSpace); err != nil {\n\t\treturn err\n\t}\n\treturn node.Right.Serialize(w)\n}\n\n// Insert represents an INSERT or REPLACE statement.\ntype Insert struct {\n\tKind     string\n\tComments Comments\n\tTable    *TableName\n\tColumns  Columns\n\tRows     InsertRows\n\tOnDup    OnDup\n}\n\nvar (\n\tastInsertInto = []byte(\"INTO \")\n\tastSpace      = []byte(\" \")\n)\n\nfunc (node *Insert) Serialize(w Writer) error {\n\tif _, err := io.WriteString(w, node.Kind); err != nil {\n\t\treturn err\n\t}\n\tif _, err := w.Write(astSpace); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Comments.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif _, err := w.Write(astInsertInto); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Table.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif _, err := w.Write(astSpace); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Columns.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif _, err := w.Write(astSpace); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Rows.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\treturn node.OnDup.Serialize(w)\n}\n\n// InsertRows represents the rows for an INSERT statement.\ntype InsertRows interface {\n\tSerializer\n\tinsertRows()\n}\n\nfunc (*Select) insertRows() {}\nfunc (*Union) insertRows()  {}\nfunc (Values) insertRows()  {}\n\n// Update represents an UPDATE statement.\ntype Update struct {\n\tComments Comments\n\tTable    *TableName\n\tTables   []*Table\n\tExprs    UpdateExprs\n\tWhere    *Where\n\tOrderBy  OrderBy\n\tLimit    *Limit\n}\n\nvar (\n\tastUpdate = []byte(\"UPDATE \")\n\tastSet    = []byte(\" SET \")\n)\n\nfunc (node *Update) Serialize(w Writer) error {\n\tif _, err := w.Write(astUpdate); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Comments.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Table.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif _, err := w.Write(astSet); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Exprs.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Where.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif err := node.OrderBy.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\treturn node.Limit.Serialize(w)\n}\n\n// Delete represents a DELETE statement.\ntype Delete struct {\n\tComments Comments\n\t// Table is either a TableName or a JoinBuilder\n\tTable abstractTable\n\t// TableNames is a list of tables to perform the delete on. This is only necessary when doing\n\t// joins, because you may not want to delete from all the tables involved in the join.\n\t// In deletes without joins, this may be empty or the table being deleted from.\n\tTableNames TableNames\n\tWhere      *Where\n\tOrderBy    OrderBy\n\tLimit      *Limit\n}\n\nvar (\n\tastDelete     = []byte(\"DELETE \")\n\tastDeleteFrom = []byte(\"FROM \")\n)\n\nfunc (node *Delete) Serialize(w Writer) error {\n\tif _, err := w.Write(astDelete); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Comments.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif len(node.TableNames) != 0 {\n\t\tif err := node.TableNames.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := fmt.Fprintf(w, \" \"); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif _, err := w.Write(astDeleteFrom); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Table.tableExpr().Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Where.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif err := node.OrderBy.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\treturn node.Limit.Serialize(w)\n}\n\n// Comments represents a list of comments.\ntype Comments []string\n\nfunc (node Comments) Serialize(w Writer) error {\n\tfor _, c := range node {\n\t\tif _, err := io.WriteString(w, c); err != nil {\n\t\t\treturn nil\n\t\t}\n\t\tif _, err := w.Write(astSpace); err != nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn nil\n}\n\n// TableNames represents several table names. It is used in deletes that have joins.\ntype TableNames []*TableName\n\nfunc (node TableNames) Serialize(w Writer) error {\n\tvar prefix []byte\n\tfor _, n := range node {\n\t\tif _, err := w.Write(prefix); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := n.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprefix = astCommaSpace\n\t}\n\treturn nil\n}\n\n// SelectExprs represents SELECT expressions.\ntype SelectExprs []SelectExpr\n\nvar (\n\tastCommaSpace = []byte(\", \")\n)\n\nfunc (node SelectExprs) Serialize(w Writer) error {\n\tvar prefix []byte\n\tfor _, n := range node {\n\t\tif _, err := w.Write(prefix); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := n.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprefix = astCommaSpace\n\t}\n\treturn nil\n}\n\n// SelectExpr represents a SELECT expression.\ntype SelectExpr interface {\n\tSerializer\n\tselectExpr()\n}\n\nfunc (*StarExpr) selectExpr()    {}\nfunc (*NonStarExpr) selectExpr() {}\n\n// StarExpr defines a '*' or 'table.*' expression.\ntype StarExpr struct {\n\tTableName string\n}\n\nvar (\n\tastStar = []byte(\"*\")\n)\n\nfunc (node *StarExpr) Serialize(w Writer) error {\n\tif node.TableName != \"\" {\n\t\tif err := quoteName(w, node.TableName); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := w.Write(astPeriod); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t_, err := w.Write(astStar)\n\treturn err\n}\n\n// NonStarExpr defines a non-'*' select expr.\ntype NonStarExpr struct {\n\tExpr Expr\n\tAs   string\n}\n\nvar (\n\tastAsPrefix = []byte(\" AS `\")\n)\n\nfunc (node *NonStarExpr) Serialize(w Writer) error {\n\tif err := node.Expr.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif node.As != \"\" {\n\t\tif _, err := w.Write(astAsPrefix); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := io.WriteString(w, node.As); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := w.Write(astBackquote); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// Columns represents an insert column list.\n// The syntax for Columns is a subset of SelectExprs.\n// So, it's castable to a SelectExprs and can be analyzed\n// as such.\ntype Columns []SelectExpr\n\nvar (\n\tastOpenParen  = []byte(\"(\")\n\tastCloseParen = []byte(\")\")\n)\n\nfunc (node Columns) Serialize(w Writer) error {\n\tif _, err := w.Write(astOpenParen); err != nil {\n\t\treturn err\n\t}\n\tif err := SelectExprs(node).Serialize(w); err != nil {\n\t\treturn err\n\t}\n\t_, err := w.Write(astCloseParen)\n\treturn err\n}\n\n// TableExprs represents a list of table expressions.\ntype TableExprs []TableExpr\n\nfunc (node TableExprs) Serialize(w Writer) error {\n\tvar prefix []byte\n\tfor _, n := range node {\n\t\tif _, err := w.Write(prefix); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := n.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprefix = astCommaSpace\n\t}\n\treturn nil\n}\n\n// TableExpr represents a table expression.\ntype TableExpr interface {\n\tSerializer\n\ttableExpr()\n}\n\nfunc (*AliasedTableExpr) tableExpr() {}\nfunc (*ParenTableExpr) tableExpr()   {}\nfunc (*JoinTableExpr) tableExpr()    {}\n\n// AliasedTableExpr represents a table expression\n// coupled with an optional alias or index hint.\ntype AliasedTableExpr struct {\n\tExpr  SimpleTableExpr\n\tAs    string\n\tHints *IndexHints\n}\n\nfunc (node *AliasedTableExpr) Serialize(w Writer) error {\n\tif err := node.Expr.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif node.As != \"\" {\n\t\tif _, err := w.Write(astAsPrefix); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := io.WriteString(w, node.As); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := w.Write(astBackquote); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif node.Hints != nil {\n\t\t// Hint node provides the space padding.\n\t\tif err := node.Hints.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// SimpleTableExpr represents a simple table expression.\ntype SimpleTableExpr interface {\n\tSerializer\n\tsimpleTableExpr()\n}\n\nfunc (*TableName) simpleTableExpr() {}\nfunc (*Subquery) simpleTableExpr()  {}\n\n// TableName represents a table  name.\ntype TableName struct {\n\tName, Qualifier string\n}\n\nfunc (node *TableName) Serialize(w Writer) error {\n\tif node.Qualifier != \"\" {\n\t\tif err := quoteName(w, node.Qualifier); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := w.Write(astPeriod); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn quoteName(w, node.Name)\n}\n\n// ParenTableExpr represents a parenthesized TableExpr.\ntype ParenTableExpr struct {\n\tExpr TableExpr\n}\n\n// JoinTableExpr represents a TableExpr that's a JOIN operation.\ntype JoinTableExpr struct {\n\tLeftExpr  TableExpr\n\tJoin      string\n\tRightExpr TableExpr\n\tCond      JoinCond\n}\n\n// JoinTableExpr.Join\nconst (\n\tastJoin         = \"JOIN\"\n\tastStraightJoin = \"STRAIGHT_JOIN\"\n\tastLeftJoin     = \"LEFT JOIN\"\n\tastRightJoin    = \"RIGHT JOIN\"\n\tastCrossJoin    = \"CROSS JOIN\"\n\tastNaturalJoin  = \"NATURAL JOIN\"\n)\n\nfunc (node *JoinTableExpr) Serialize(w Writer) error {\n\tif err := node.LeftExpr.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif _, err := fmt.Fprintf(w, \" %s \", node.Join); err != nil {\n\t\treturn err\n\t}\n\tif err := node.RightExpr.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif node.Cond != nil {\n\t\tif err := node.Cond.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// JoinCond represents a join condition.\ntype JoinCond interface {\n\tSerializer\n\tjoinCond()\n}\n\nfunc (*OnJoinCond) joinCond()    {}\nfunc (*UsingJoinCond) joinCond() {}\n\n// OnJoinCond represents an ON join condition.\ntype OnJoinCond struct {\n\tExpr BoolExpr\n}\n\nvar (\n\tastOn = []byte(\" ON \")\n)\n\nfunc (node *OnJoinCond) Serialize(w Writer) error {\n\tif _, err := w.Write(astOn); err != nil {\n\t\treturn err\n\t}\n\treturn node.Expr.Serialize(w)\n}\n\n// UsingJoinCond represents a USING join condition.\ntype UsingJoinCond struct {\n\tCols Columns\n}\n\nvar (\n\tastUsing = []byte(\" USING \")\n)\n\nfunc (node *UsingJoinCond) Serialize(w Writer) error {\n\tif _, err := w.Write(astUsing); err != nil {\n\t\treturn err\n\t}\n\treturn node.Cols.Serialize(w)\n}\n\n// IndexHints represents a list of index hints.\ntype IndexHints struct {\n\tType    string\n\tIndexes []string\n}\n\nconst (\n\tastUse    = \"USE\"\n\tastIgnore = \"IGNORE\"\n\tastForce  = \"FORCE\"\n)\n\nfunc (node *IndexHints) Serialize(w Writer) error {\n\tif _, err := fmt.Fprintf(w, \" %s INDEX \", node.Type); err != nil {\n\t\treturn err\n\t}\n\tprefix := \"(\"\n\tfor _, n := range node.Indexes {\n\t\tif _, err := fmt.Fprintf(w, \"%s%s\", prefix, n); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprefix = \", \"\n\t}\n\t_, err := fmt.Fprintf(w, \")\")\n\treturn err\n}\n\n// Where represents a WHERE or HAVING clause.\ntype Where struct {\n\tType string\n\tExpr BoolExpr\n}\n\n// Where.Type\nconst (\n\tastWhere  = \" WHERE \"\n\tastHaving = \" HAVING \"\n)\n\n// NewWhere creates a WHERE or HAVING clause out\n// of a BoolExpr. If the expression is nil, it returns nil.\nfunc NewWhere(typ string, expr BoolExpr) *Where {\n\tif expr == nil {\n\t\treturn nil\n\t}\n\treturn &Where{Type: typ, Expr: expr}\n}\n\nfunc (node *Where) Serialize(w Writer) error {\n\tif node == nil {\n\t\treturn nil\n\t}\n\tif _, err := io.WriteString(w, node.Type); err != nil {\n\t\treturn err\n\t}\n\treturn node.Expr.Serialize(w)\n}\n\n// Expr represents an expression.\ntype Expr interface {\n\tSerializer\n\texpr()\n}\n\nfunc (*AndExpr) expr()        {}\nfunc (*OrExpr) expr()         {}\nfunc (*NotExpr) expr()        {}\nfunc (*ParenBoolExpr) expr()  {}\nfunc (*ComparisonExpr) expr() {}\nfunc (*RangeCond) expr()      {}\nfunc (*NullCheck) expr()      {}\nfunc (*ExistsExpr) expr()     {}\nfunc (PlaceholderVal) expr()  {}\nfunc (RawVal) expr()          {}\nfunc (EncodedVal) expr()      {}\nfunc (StrVal) expr()          {}\nfunc (NumVal) expr()          {}\nfunc (ValArg) expr()          {}\nfunc (*NullVal) expr()        {}\nfunc (*ColName) expr()        {}\nfunc (ValTuple) expr()        {}\nfunc (*Subquery) expr()       {}\nfunc (*BinaryExpr) expr()     {}\nfunc (*UnaryExpr) expr()      {}\nfunc (*FuncExpr) expr()       {}\nfunc (*CaseExpr) expr()       {}\n\n// BoolExpr represents a boolean expression.\ntype BoolExpr interface {\n\tboolExpr()\n\tExpr\n}\n\nfunc (*AndExpr) boolExpr()        {}\nfunc (*OrExpr) boolExpr()         {}\nfunc (*NotExpr) boolExpr()        {}\nfunc (*ParenBoolExpr) boolExpr()  {}\nfunc (*ComparisonExpr) boolExpr() {}\nfunc (*RangeCond) boolExpr()      {}\nfunc (*NullCheck) boolExpr()      {}\nfunc (*ExistsExpr) boolExpr()     {}\n\nconst (\n\tastAndExpr = \" AND \"\n)\n\n// AndExpr represents an AND expression.\ntype AndExpr struct {\n\tOp    string\n\tExprs []BoolExpr\n}\n\nfunc (node *AndExpr) Serialize(w Writer) error {\n\tif len(node.Exprs) == 0 {\n\t\t_, err := w.Write(astBoolTrue)\n\t\treturn err\n\t} else if len(node.Exprs) == 1 {\n\t\treturn node.Exprs[0].Serialize(w)\n\t}\n\n\tif _, err := w.Write(astOpenParen); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Exprs[0].Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tfor _, expr := range node.Exprs[1:] {\n\t\tif _, err := io.WriteString(w, node.Op); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := expr.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t_, err := w.Write(astCloseParen)\n\treturn err\n}\n\nconst (\n\tastOrExpr = \" OR \"\n)\n\n// OrExpr represents an OR expression.\ntype OrExpr struct {\n\tOp    string\n\tExprs []BoolExpr\n}\n\nfunc (node *OrExpr) Serialize(w Writer) error {\n\tif len(node.Exprs) == 0 {\n\t\t_, err := w.Write(astBoolFalse)\n\t\treturn err\n\t} else if len(node.Exprs) == 1 {\n\t\treturn node.Exprs[0].Serialize(w)\n\t}\n\n\tif _, err := w.Write(astOpenParen); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Exprs[0].Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tfor _, expr := range node.Exprs[1:] {\n\t\tif _, err := io.WriteString(w, node.Op); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := expr.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t_, err := w.Write(astCloseParen)\n\treturn err\n}\n\nconst (\n\tastNotExpr = \"NOT \"\n)\n\n// NotExpr represents a NOT expression.\ntype NotExpr struct {\n\tOp   string\n\tExpr BoolExpr\n}\n\nfunc (node *NotExpr) Serialize(w Writer) error {\n\tif _, err := io.WriteString(w, node.Op); err != nil {\n\t\treturn err\n\t}\n\treturn node.Expr.Serialize(w)\n}\n\n// ParenBoolExpr represents a parenthesized boolean expression.\ntype ParenBoolExpr struct {\n\tExpr BoolExpr\n}\n\nfunc (node *ParenBoolExpr) Serialize(w Writer) error {\n\tif _, err := w.Write(astOpenParen); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Expr.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\t_, err := w.Write(astCloseParen)\n\treturn err\n}\n\n// ComparisonExpr represents a two-value comparison expression.\ntype ComparisonExpr struct {\n\tOperator    string\n\tLeft, Right ValExpr\n}\n\n// ComparisonExpr.Operator\nconst (\n\tastEQ        = \" = \"\n\tastLT        = \" < \"\n\tastGT        = \" > \"\n\tastLE        = \" <= \"\n\tastGE        = \" >= \"\n\tastNE        = \" != \"\n\tastNSE       = \" <=> \"\n\tastIn        = \" IN \"\n\tastNot       = \" NOT \"\n\tastNotIn     = \" NOT IN \"\n\tastLike      = \" LIKE \"\n\tastNotLike   = \" NOT LIKE \"\n\tastRegExp    = \" REGEXP \"\n\tastNotRegExp = \" NOT REGEXP \"\n)\n\nfunc (node *ComparisonExpr) Serialize(w Writer) error {\n\tif err := node.Left.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif _, err := io.WriteString(w, node.Operator); err != nil {\n\t\treturn err\n\t}\n\treturn node.Right.Serialize(w)\n}\n\n// RangeCond represents a BETWEEN or a NOT BETWEEN expression.\ntype RangeCond struct {\n\tOperator string\n\tLeft     ValExpr\n\tFrom, To ValExpr\n}\n\n// RangeCond.Operator\nconst (\n\tastBetween    = \" BETWEEN \"\n\tastNotBetween = \" NOT BETWEEN \"\n)\n\nvar (\n\tastAnd = []byte(\" AND \")\n)\n\nfunc (node *RangeCond) Serialize(w Writer) error {\n\tif err := node.Left.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif _, err := io.WriteString(w, node.Operator); err != nil {\n\t\treturn err\n\t}\n\tif err := node.From.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif _, err := w.Write(astAnd); err != nil {\n\t\treturn err\n\t}\n\treturn node.To.Serialize(w)\n}\n\n// NullCheck represents an IS NULL or an IS NOT NULL expression.\ntype NullCheck struct {\n\tOperator string\n\tExpr     ValExpr\n}\n\n// NullCheck.Operator\nconst (\n\tastIsNull    = \" IS NULL\"\n\tastIsNotNull = \" IS NOT NULL\"\n)\n\nfunc (node *NullCheck) Serialize(w Writer) error {\n\tif err := node.Expr.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\t_, err := io.WriteString(w, node.Operator)\n\treturn err\n}\n\n// ExistsExpr represents an EXISTS expression.\ntype ExistsExpr struct {\n\tSubquery *Subquery\n}\n\n// ValExpr represents a value expression.\ntype ValExpr interface {\n\tvalExpr()\n\tExpr\n}\n\nfunc (PlaceholderVal) valExpr() {}\nfunc (RawVal) valExpr()         {}\nfunc (EncodedVal) valExpr()     {}\nfunc (StrVal) valExpr()         {}\nfunc (NumVal) valExpr()         {}\nfunc (ValArg) valExpr()         {}\nfunc (*NullVal) valExpr()       {}\nfunc (*ColName) valExpr()       {}\nfunc (ValTuple) valExpr()       {}\nfunc (*Subquery) valExpr()      {}\nfunc (*BinaryExpr) valExpr()    {}\nfunc (*UnaryExpr) valExpr()     {}\nfunc (*FuncExpr) valExpr()      {}\nfunc (*CaseExpr) valExpr()      {}\n\nvar (\n\tastPlaceholder = []byte(\"?\")\n)\n\n// PlaceholderVal represents a placeholder parameter that will be supplied\n// when executing the query. It will be serialized as a ?.\ntype PlaceholderVal struct{}\n\nfunc (node PlaceholderVal) Serialize(w Writer) error {\n\t_, err := w.Write(astPlaceholder)\n\treturn err\n}\n\n// RawVal represents a raw go value\ntype RawVal struct {\n\tVal interface{}\n}\n\nvar (\n\tastBoolTrue  = []byte(\"1\")\n\tastBoolFalse = []byte(\"0\")\n)\n\nfunc (node RawVal) Serialize(w Writer) error {\n\treturn w.WriteRaw(node)\n}\n\n// EncodedVal represents an already encoded value. This struct must be used\n// with caution because misuse can provide an avenue for SQL injection attacks.\ntype EncodedVal struct {\n\tVal []byte\n}\n\nfunc (node EncodedVal) Serialize(w Writer) error {\n\treturn w.WriteEncoded(node)\n}\n\n// StrVal represents a string value.\ntype StrVal string\n\nfunc (node StrVal) Serialize(w Writer) error {\n\treturn w.WriteStr(node)\n}\n\n// BytesVal represents a string of unprintable value.\ntype BytesVal []byte\n\nfunc (BytesVal) expr()    {}\nfunc (BytesVal) valExpr() {}\n\nfunc (node BytesVal) Serialize(w Writer) error {\n\treturn w.WriteBytes(node)\n}\n\n// ErrVal represents an error condition that occurred while\n// constructing a tree.\ntype ErrVal struct {\n\tErr error\n}\n\nfunc (ErrVal) expr()    {}\nfunc (ErrVal) valExpr() {}\n\nfunc (node ErrVal) Serialize(w Writer) error {\n\treturn node.Err\n}\n\n// NumVal represents a number.\ntype NumVal string\n\nfunc (node NumVal) Serialize(w Writer) error {\n\treturn w.WriteNum(node)\n}\n\n// ValArg represents a named bind var argument.\ntype ValArg string\n\nfunc (node ValArg) Serialize(w Writer) error {\n\t_, err := fmt.Fprintf(w, \":%s\", string(node)[1:])\n\treturn err\n}\n\n// NullVal represents a NULL value.\ntype NullVal struct{}\n\nvar (\n\tastNull = []byte(\"NULL\")\n)\n\nfunc (node *NullVal) Serialize(w Writer) error {\n\t_, err := w.Write(astNull)\n\treturn err\n}\n\n// ColName represents a column name.\ntype ColName struct {\n\tName, Qualifier string\n}\n\nvar (\n\tastBackquote = []byte(\"`\")\n\tastPeriod    = []byte(\".\")\n)\n\nfunc (node *ColName) Serialize(w Writer) error {\n\tif node.Qualifier != \"\" {\n\t\tif err := quoteName(w, node.Qualifier); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := w.Write(astPeriod); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn quoteName(w, node.Name)\n}\n\n// note: quoteName does not escape s. quoteName is indirectly\n// called by builder.go, which checks that column/table names exist.\nfunc quoteName(w io.Writer, s string) error {\n\tif _, err := w.Write(astBackquote); err != nil {\n\t\treturn err\n\t}\n\tif _, err := io.WriteString(w, s); err != nil {\n\t\treturn err\n\t}\n\t_, err := w.Write(astBackquote)\n\treturn err\n}\n\n// Tuple represents a tuple. It can be ValTuple, Subquery.\ntype Tuple interface {\n\ttuple()\n\tValExpr\n}\n\nfunc (ValTuple) tuple()  {}\nfunc (*Subquery) tuple() {}\n\n// ValTuple represents a tuple of actual values.\ntype ValTuple struct {\n\tExprs ValExprs\n}\n\nfunc (node ValTuple) Serialize(w Writer) error {\n\tif _, err := w.Write(astOpenParen); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Exprs.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\t_, err := w.Write(astCloseParen)\n\treturn err\n}\n\n// ValExprs represents a list of value expressions.\n// It's not a valid expression because it's not parenthesized.\ntype ValExprs []ValExpr\n\nfunc (node ValExprs) Serialize(w Writer) error {\n\tvar prefix []byte\n\tfor _, n := range node {\n\t\tif _, err := w.Write(prefix); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := n.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprefix = astCommaSpace\n\t}\n\treturn nil\n}\n\n// Subquery represents a subquery.\ntype Subquery struct {\n\tSelect SelectStatement\n}\n\nfunc (s *Subquery) Serialize(w Writer) error {\n\t_, err := w.Write([]byte{'('})\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = s.Select.Serialize(w)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = w.Write([]byte{')'})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// BinaryExpr represents a binary value expression.\ntype BinaryExpr struct {\n\tOperator    byte\n\tLeft, Right Expr\n}\n\n// BinaryExpr.Operator\nconst (\n\tastBitand = '&'\n\tastBitor  = '|'\n\tastBitxor = '^'\n\tastPlus   = '+'\n\tastMinus  = '-'\n\tastMult   = '*'\n\tastDiv    = '/'\n\tastMod    = '%'\n)\n\nfunc (node *BinaryExpr) Serialize(w Writer) error {\n\tif err := node.Left.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif _, err := fmt.Fprintf(w, \"%c\", node.Operator); err != nil {\n\t\treturn err\n\t}\n\treturn node.Right.Serialize(w)\n}\n\n// UnaryExpr represents a unary value expression.\ntype UnaryExpr struct {\n\tOperator byte\n\tExpr     Expr\n}\n\n// UnaryExpr.Operator\nconst (\n\tastUnaryPlus  = '+'\n\tastUnaryMinus = '-'\n\tastTilda      = '~'\n)\n\nfunc (node *UnaryExpr) Serialize(w Writer) error {\n\tif _, err := fmt.Fprintf(w, \"%c\", node.Operator); err != nil {\n\t\treturn err\n\t}\n\treturn node.Expr.Serialize(w)\n}\n\n// FuncExpr represents a function call.\ntype FuncExpr struct {\n\tName     string\n\tDistinct bool\n\tExprs    SelectExprs\n}\n\nvar (\n\tastFuncDistinct = []byte(\"DISTINCT \")\n)\n\nfunc (node *FuncExpr) Serialize(w Writer) error {\n\tif _, err := io.WriteString(w, node.Name); err != nil {\n\t\treturn err\n\t}\n\tif _, err := w.Write(astOpenParen); err != nil {\n\t\treturn err\n\t}\n\tif node.Distinct {\n\t\tif _, err := w.Write(astFuncDistinct); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := node.Exprs.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\t_, err := w.Write(astCloseParen)\n\treturn err\n}\n\n// CaseExpr represents a CASE expression.\ntype CaseExpr struct {\n\tExpr  ValExpr\n\tWhens []*When\n\tElse  ValExpr\n}\n\nfunc (node *CaseExpr) Serialize(w Writer) error {\n\tif _, err := fmt.Fprint(w, \"CASE \"); err != nil {\n\t\treturn err\n\t}\n\tif node.Expr != nil {\n\t\tif err := node.Expr.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := fmt.Fprint(w, \" \"); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tfor _, when := range node.Whens {\n\t\tif err := when.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := fmt.Fprint(w, \" \"); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif node.Else != nil {\n\t\tif _, err := fmt.Fprint(w, \"ELSE \"); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := node.Else.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := fmt.Fprint(w, \" \"); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t_, err := fmt.Fprint(w, \"END\")\n\treturn err\n}\n\n// When represents a WHEN sub-expression.\ntype When struct {\n\tCond BoolExpr\n\tVal  ValExpr\n}\n\nfunc (node *When) Serialize(w Writer) error {\n\tif err := node.Cond.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\treturn node.Val.Serialize(w)\n}\n\n// Values represents a VALUES clause.\ntype Values []Tuple\n\nvar (\n\tastValues = []byte(\"VALUES \")\n)\n\nfunc (node Values) Serialize(w Writer) error {\n\tprefix := astValues\n\tfor _, n := range node {\n\t\tif _, err := w.Write(prefix); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := n.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprefix = astCommaSpace\n\t}\n\treturn nil\n}\n\n// GroupBy represents a GROUP BY clause.\ntype GroupBy []ValExpr\n\nvar (\n\tastGroupBy = []byte(\" GROUP BY \")\n)\n\nfunc (node GroupBy) Serialize(w Writer) error {\n\tprefix := astGroupBy\n\tfor _, n := range node {\n\t\tif _, err := w.Write(prefix); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := n.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprefix = astCommaSpace\n\t}\n\treturn nil\n}\n\n// OrderBy represents an ORDER By clause.\ntype OrderBy []*Order\n\nvar (\n\tastOrderBy = []byte(\" ORDER BY \")\n)\n\nfunc (node OrderBy) Serialize(w Writer) error {\n\tprefix := astOrderBy\n\tfor _, n := range node {\n\t\tif _, err := w.Write(prefix); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := n.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprefix = astCommaSpace\n\t}\n\treturn nil\n}\n\n// Order represents an ordering expression.\ntype Order struct {\n\tExpr      ValExpr\n\tDirection string\n}\n\n// Order.Direction\nconst (\n\tastAsc  = \" ASC\"\n\tastDesc = \" DESC\"\n)\n\nfunc (node *Order) Serialize(w Writer) error {\n\tif err := node.Expr.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\t_, err := io.WriteString(w, node.Direction)\n\treturn err\n}\n\n// Limit represents a LIMIT clause.\ntype Limit struct {\n\tOffset, Rowcount ValExpr\n}\n\nvar (\n\tastLimit = []byte(\" LIMIT \")\n)\n\nfunc (node *Limit) Serialize(w Writer) error {\n\tif node == nil {\n\t\treturn nil\n\t}\n\tif _, err := w.Write(astLimit); err != nil {\n\t\treturn err\n\t}\n\tif node.Offset != nil {\n\t\tif err := node.Offset.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := w.Write(astCommaSpace); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn node.Rowcount.Serialize(w)\n}\n\n// UpdateExprs represents a list of update expressions.\ntype UpdateExprs []*UpdateExpr\n\nfunc (node UpdateExprs) Serialize(w Writer) error {\n\tvar prefix []byte\n\tfor _, n := range node {\n\t\tif _, err := w.Write(prefix); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := n.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprefix = astCommaSpace\n\t}\n\treturn nil\n}\n\n// UpdateExpr represents an update expression.\ntype UpdateExpr struct {\n\tName *ColName\n\tExpr ValExpr\n}\n\nvar (\n\tastUpdateEq = []byte(\" = \")\n)\n\nfunc (node *UpdateExpr) Serialize(w Writer) error {\n\tif err := node.Name.Serialize(w); err != nil {\n\t\treturn nil\n\t}\n\tif _, err := w.Write(astUpdateEq); err != nil {\n\t\treturn nil\n\t}\n\treturn node.Expr.Serialize(w)\n}\n\n// OnDup represents an ON DUPLICATE KEY clause.\ntype OnDup UpdateExprs\n\nvar (\n\tastOnDupKeyUpdate = []byte(\" ON DUPLICATE KEY UPDATE \")\n)\n\nfunc (node OnDup) Serialize(w Writer) error {\n\tif node == nil {\n\t\treturn nil\n\t}\n\tif _, err := w.Write(astOnDupKeyUpdate); err != nil {\n\t\treturn err\n\t}\n\treturn UpdateExprs(node).Serialize(w)\n}\n", "// Copyright 2014 Square Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage squalor\n\nimport (\n\t\"bytes\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strings\"\n\t\"text/tabwriter\"\n)\n\n// Column models a database column.\ntype Column struct {\n\tName     string\n\tAutoIncr bool\n\tNullable bool\n\tsqlType  string\n}\n\nfunc (c *Column) String() string {\n\tvar buf bytes.Buffer\n\tfmt.Fprintf(&buf, \"%s\\t%s\", c.Name, c.sqlType)\n\tif c.Nullable {\n\t\tfmt.Fprint(&buf, \"\\tNULL\")\n\t} else {\n\t\tfmt.Fprint(&buf, \"\\tNOT NULL\")\n\t}\n\tif c.AutoIncr {\n\t\tfmt.Fprint(&buf, \" AUTO INCREMENT\")\n\t}\n\treturn buf.String()\n}\n\ntype byName []*Column\n\nfunc (n byName) Len() int {\n\treturn len(n)\n}\n\nfunc (n byName) Less(i, j int) bool {\n\treturn n[i].Name < n[j].Name\n}\n\nfunc (n byName) Swap(i, j int) {\n\tn[i], n[j] = n[j], n[i]\n}\n\ntype keyColumn struct {\n\tseq  int\n\tname string\n}\n\ntype bySeq []keyColumn\n\nfunc (s bySeq) Len() int {\n\treturn len(s)\n}\n\nfunc (s bySeq) Less(i, j int) bool {\n\treturn s[i].seq < s[j].seq\n}\n\nfunc (s bySeq) Swap(i, j int) {\n\ts[i], s[j] = s[j], s[i]\n}\n\n// Key models a key (index) for a database table. A key is composed of\n// one or more columns.\ntype Key struct {\n\tName    string\n\tPrimary bool\n\tUnique  bool\n\tColumns []*Column\n}\n\nfunc (k *Key) String() string {\n\tvar buf bytes.Buffer\n\tif k.Primary {\n\t\tfmt.Fprint(&buf, \"PRIMARY \")\n\t} else if k.Unique {\n\t\tfmt.Fprint(&buf, \"UNIQUE \")\n\t}\n\tfmt.Fprint(&buf, \"KEY\")\n\tif !k.Primary {\n\t\tfmt.Fprintf(&buf, \" %s\", k.Name)\n\t}\n\tfmt.Fprint(&buf, \"\\t(\")\n\tvar sep string\n\tfor _, col := range k.Columns {\n\t\tfmt.Fprintf(&buf, \"%s%s\", sep, col.Name)\n\t\tsep = \",\"\n\t}\n\tfmt.Fprint(&buf, \")\")\n\treturn buf.String()\n}\n\nfunc (k *Key) matches(cols ...string) bool {\n\tif len(k.Columns) != len(cols) {\n\t\treturn false\n\t}\n\tfor i := range cols {\n\t\tif k.Columns[i].Name != cols[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// Table models a database table containing column and key definitions.\ntype Table struct {\n\tName       string\n\tAlias      string\n\tIndexHints *IndexHints\n\tColumns    []*Column\n\tColumnMap  map[string]*Column\n\tPrimaryKey *Key\n\tKeys       []*Key\n\tKeyMap     map[string]*Key\n}\n\nfunc makeTable(name string) *Table {\n\treturn &Table{\n\t\tName:      name,\n\t\tColumnMap: make(map[string]*Column),\n\t\tKeyMap:    make(map[string]*Key),\n\t}\n}\n\n// NewTable constructs a table from a model struct. The resulting\n// table is less detailed than one created from LoadTable due to the\n// lack of keys of type info.\nfunc NewTable(name string, model interface{}) *Table {\n\tt := makeTable(name)\n\tm := getDBFields(reflect.TypeOf(model))\n\tfor k := range m {\n\t\tcol := &Column{Name: k}\n\t\tt.Columns = append(t.Columns, col)\n\t\tt.ColumnMap[k] = col\n\t}\n\tsort.Sort(byName(t.Columns))\n\treturn t\n}\n\n// NewAliasedTable constructs a table with an alias from a model struct. The\n// alias will be used in column names and in joins. The resulting\n// table is less detailed than one created from LoadTable due to the\n// lack of keys of type info.\nfunc NewAliasedTable(name, alias string, model interface{}) *Table {\n\tt := NewTable(name, model)\n\tt.Alias = alias\n\treturn t\n}\n\n// LoadTable loads a table's definition from a database.\nfunc LoadTable(db *sql.DB, name string) (*Table, error) {\n\tt := makeTable(name)\n\terr := t.loadColumns(db)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = t.loadKeys(db)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn t, nil\n}\n\nfunc (t *Table) String() string {\n\tvar buf bytes.Buffer\n\ttab := tabwriter.NewWriter(&buf, 0, 4, 2, ' ', 0)\n\tfmt.Fprintf(tab, \"%s:\\n\", t.Name)\n\tfmt.Fprint(tab, \"  columns:\\n\")\n\tfor _, col := range t.Columns {\n\t\tfmt.Fprintf(tab, \"    %s\\n\", col)\n\t}\n\tfmt.Fprint(tab, \"  keys:\\n\")\n\tfor _, key := range t.Keys {\n\t\tfmt.Fprintf(tab, \"    %s\\n\", key)\n\t}\n\ttab.Flush()\n\treturn buf.String()\n}\n\n// GetKey retrieves a key from the table definition.\nfunc (t *Table) GetKey(cols ...string) *Key {\n\tfor _, key := range t.Keys {\n\t\tif key.matches(cols...) {\n\t\t\treturn key\n\t\t}\n\t}\n\treturn nil\n}\n\n// Apply a \"USE INDEX\" hint to a table. This will replace any existing index hints.\nfunc (t *Table) UseIndex(indexes ...string) *Table {\n\treturn t.setIndexHint(astUse, indexes)\n}\n\n// Apply a \"FORCE INDEX\" hint to a table. This will replace any existing index hints.\nfunc (t *Table) ForceIndex(indexes ...string) *Table {\n\treturn t.setIndexHint(astForce, indexes)\n}\n\n// Apply an \"IGNORE INDEX\" hint to a table. This will replace any existing index hints.\nfunc (t *Table) IgnoreIndex(indexes ...string) *Table {\n\treturn t.setIndexHint(astIgnore, indexes)\n}\n\nfunc (t *Table) setIndexHint(hintType string, indexes []string) *Table {\n\ttableCopy := *t\n\tindexesCopy := make([]string, len(indexes))\n\tcopy(indexesCopy, indexes)\n\ttableCopy.IndexHints = &IndexHints{\n\t\tType:    hintType,\n\t\tIndexes: indexesCopy,\n\t}\n\treturn &tableCopy\n}\n\n// C returns an expression for the specified list of columns. An error\n// expression is created if any of the columns do not exist in the table. An\n// error expression is created if no columns are specified.\nfunc (t *Table) C(cols ...string) ValExprBuilder {\n\tif len(cols) == 0 {\n\t\treturn ValExprBuilder{makeErrVal(\"no columns specified\")}\n\t}\n\n\tif len(cols) == 1 {\n\t\tname := cols[0]\n\t\tif _, ok := t.ColumnMap[name]; !ok {\n\t\t\treturn ValExprBuilder{makeErrVal(\"unknown column: %s\", name)}\n\t\t}\n\t\treturn ValExprBuilder{&ColName{Name: name, Qualifier: t.aliasOrName()}}\n\t}\n\tlist := make([]interface{}, len(cols))\n\tfor i, name := range cols {\n\t\tif _, ok := t.ColumnMap[name]; !ok {\n\t\t\tlist[i] = makeErrVal(\"unknown column: %s\", name)\n\t\t} else {\n\t\t\tlist[i] = &ColName{Name: name, Qualifier: t.aliasOrName()}\n\t\t}\n\t}\n\treturn ValExprBuilder{makeValTuple(list)}\n}\n\n// All returns an expression for all of the columns in the table in\n// the order in which they are defined in the table (the order of\n// Table.Columns). Note that returned expression is a tuple of\n// columns, not a star expression.\nfunc (t *Table) All() ValExprBuilder {\n\tlist := make([]interface{}, len(t.Columns))\n\tfor i, col := range t.Columns {\n\t\tlist[i] = &ColName{Name: col.Name, Qualifier: t.aliasOrName()}\n\t}\n\treturn ValExprBuilder{makeValTuple(list)}\n}\n\n// InnerJoin creates an INNER JOIN statement builder. Note that inner\n// join and join are synonymous in MySQL. Inner join is used here for\n// clarity.\nfunc (t *Table) InnerJoin(other *Table) *JoinBuilder {\n\treturn makeJoinBuilder(\"INNER JOIN\", t, other)\n}\n\n// LeftJoin creates a LEFT JOIN statement builder.\nfunc (t *Table) LeftJoin(other *Table) *JoinBuilder {\n\treturn makeJoinBuilder(\"LEFT JOIN\", t, other)\n}\n\n// RightJoin creates a RIGHT JOIN statement builder.\nfunc (t *Table) RightJoin(other *Table) *JoinBuilder {\n\treturn makeJoinBuilder(\"RIGHT JOIN\", t, other)\n}\n\n// Delete creates a DELETE statement builder.\nfunc (t *Table) Delete(tables ...*Table) *DeleteBuilder {\n\treturn makeDeleteBuilder(t, tables...)\n}\n\n// Insert creates an INSERT statement builder.\nfunc (t *Table) Insert(cols ...interface{}) *InsertBuilder {\n\treturn makeInsertBuilder(t, \"INSERT\", cols...)\n}\n\n// Insert creates an INSERT statement builder.\nfunc (t *Table) InsertIgnore(cols ...interface{}) *InsertBuilder {\n\treturn makeInsertBuilder(t, \"INSERT IGNORE\", cols...)\n}\n\n// Replace creates a REPLACE statement builder.\nfunc (t *Table) Replace(cols ...interface{}) *ReplaceBuilder {\n\treturn makeReplaceBuilder(t, cols...)\n}\n\n// Select creates a SELECT statement builder.\nfunc (t *Table) Select(exprs ...interface{}) *SelectBuilder {\n\treturn makeSelectBuilder(t, exprs...)\n}\n\n// Update creates an UPDATE statement builder.\nfunc (t *Table) Update() *UpdateBuilder {\n\treturn makeUpdateBuilder(t)\n}\n\nfunc (t *Table) validateFields(m fieldMap) error {\n\t// Verify all of the model columns exist in the table.\n\tfor name, field := range m {\n\t\tc1 := t.ColumnMap[name]\n\t\tif c1 == nil {\n\t\t\treturn fmt.Errorf(\"%s: model column '%s' not found in table\", t.Name, name)\n\t\t}\n\t\tif err := validateModelType(c1.sqlType, field.Type); err != nil {\n\t\t\treturn fmt.Errorf(\"%s: '%s': %s\", t.Name, name, err)\n\t\t}\n\t}\n\t// Verify all of the table columns exist in the model.\n\tfor name := range t.ColumnMap {\n\t\tif _, ok := m[name]; !ok {\n\t\t\treturn fmt.Errorf(\"%s: table column '%s' not found in model\", t.Name, name)\n\t\t}\n\t}\n\treturn nil\n}\n\n// ValidateModel validates that the model is compatible for the\n// table's schema. It checks that every column in the database is\n// mapped to a field in the model and every field in the model has a\n// corresponding column in the table schema.\nfunc (t *Table) ValidateModel(model interface{}) error {\n\tm := getDBFields(reflect.TypeOf(model))\n\treturn t.validateFields(m)\n}\n\n// aliasOrName will return table's alias if it is not blank,\n// otherwise it will return the table's name.\nfunc (t *Table) aliasOrName() string {\n\tif t.Alias != \"\" {\n\t\treturn t.Alias\n\t}\n\treturn t.Name\n}\n\n// loadColumns loads a table's columns from a database. MySQL\n// specific.\nfunc (t *Table) loadColumns(db *sql.DB) error {\n\trows, err := db.Query(\"SHOW FULL COLUMNS FROM \" + t.Name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer rows.Close()\n\n\tcols, err := rows.Columns()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar (\n\t\tcol      string\n\t\tsqlType  string\n\t\tnullable string\n\t\textra    string\n\t)\n\tm := map[string]interface{}{\n\t\t\"Field\": &col,\n\t\t\"Type\":  &sqlType,\n\t\t\"Null\":  &nullable,\n\t\t\"Extra\": &extra,\n\t}\n\n\tvals := make([]interface{}, len(cols))\n\tfor i, n := range cols {\n\t\tif v, ok := m[n]; ok {\n\t\t\tvals[i] = v\n\t\t} else {\n\t\t\tvals[i] = &sql.RawBytes{}\n\t\t}\n\t}\n\n\tfor rows.Next() {\n\t\terr := rows.Scan(vals...)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc := &Column{\n\t\t\tName:     col,\n\t\t\tNullable: strings.EqualFold(nullable, \"YES\"),\n\t\t\tAutoIncr: strings.Contains(extra, \"auto_increment\"),\n\t\t\tsqlType:  sqlType,\n\t\t}\n\t\tt.Columns = append(t.Columns, c)\n\t\tt.ColumnMap[c.Name] = c\n\t}\n\treturn nil\n}\n\nfunc (t *Table) tableExpr() TableExpr {\n\tate := &AliasedTableExpr{\n\t\tExpr: &TableName{Name: t.Name},\n\t}\n\tif t.Alias != \"\" {\n\t\tate.As = t.Alias\n\t}\n\tif t.IndexHints != nil {\n\t\tate.Hints = t.IndexHints\n\t}\n\n\treturn ate\n}\n\nfunc (t *Table) tableExists(name string) bool {\n\treturn t.Name == name\n}\n\nfunc (t *Table) column(name string) *ColName {\n\tparts := strings.Split(name, \".\")\n\tif len(parts) == 2 {\n\t\tif parts[0] != t.Name {\n\t\t\treturn nil\n\t\t}\n\t\tname = parts[1]\n\t}\n\tif _, ok := t.ColumnMap[name]; !ok {\n\t\treturn nil\n\t}\n\treturn &ColName{Name: name, Qualifier: t.Name}\n}\n\nfunc (t *Table) columnCount(name string) int {\n\tif _, ok := t.ColumnMap[name]; !ok {\n\t\treturn 0\n\t}\n\treturn 1\n}\n\n// loadKeys loads a table's keys (indexes) from a database. MySQL\n// specific.\nfunc (t *Table) loadKeys(db *sql.DB) error {\n\trows, err := db.Query(\"SHOW INDEX FROM \" + t.Name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer rows.Close()\n\n\tcols, err := rows.Columns()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar (\n\t\tnonUnique bool\n\t\tkeyName   string\n\t\tseq       int\n\t\tcolName   string\n\t)\n\tm := map[string]interface{}{\n\t\t\"Non_unique\":   &nonUnique,\n\t\t\"Key_name\":     &keyName,\n\t\t\"Seq_in_index\": &seq,\n\t\t\"Column_name\":  &colName,\n\t}\n\n\tvals := make([]interface{}, len(cols))\n\tfor i, n := range cols {\n\t\tif v, ok := m[n]; ok {\n\t\t\tvals[i] = v\n\t\t} else {\n\t\t\tvals[i] = &sql.RawBytes{}\n\t\t}\n\t}\n\n\tkeys := map[string][]keyColumn{}\n\tfor rows.Next() {\n\t\terr := rows.Scan(vals...)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tkeys[keyName] = append(keys[keyName], keyColumn{\n\t\t\tseq:  seq,\n\t\t\tname: colName,\n\t\t})\n\n\t\tif _, ok := t.KeyMap[keyName]; !ok {\n\t\t\tk := &Key{\n\t\t\t\tName:   keyName,\n\t\t\t\tUnique: !nonUnique,\n\t\t\t}\n\t\t\tt.Keys = append(t.Keys, k)\n\t\t\tt.KeyMap[keyName] = k\n\t\t}\n\t}\n\n\tfor n, k := range keys {\n\t\tsort.Sort(bySeq(k))\n\t\tvar cols []*Column\n\t\tfor _, c := range k {\n\t\t\tcols = append(cols, t.ColumnMap[c.name])\n\t\t}\n\t\tt.KeyMap[n].Columns = cols\n\t}\n\n\tt.PrimaryKey = t.KeyMap[\"PRIMARY\"]\n\tif t.PrimaryKey != nil {\n\t\tt.PrimaryKey.Primary = true\n\t}\n\n\treturn nil\n}\n", "// Copyright 2014 Square Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage squalor\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc mustLoadTable(t *testing.T, name string) *Table {\n\tdb := makeTestDB(t, objectsDDL)\n\tdefer db.Close()\n\n\ttable, err := LoadTable(db.DB, name)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn table\n}\n\nfunc TestLoadTable(t *testing.T) {\n\ttable := mustLoadTable(t, \"objects\")\n\tfmt.Printf(\"%s\\n\", table)\n}\n\nfunc TestGetKey(t *testing.T) {\n\ttable := mustLoadTable(t, \"objects\")\n\n\ttestCases := []struct {\n\t\tcols   []string\n\t\tresult bool\n\t}{\n\t\t{[]string{\"user_id\", \"object_id\"}, true},\n\t\t{[]string{\"USER_ID\", \"object_id\"}, false},\n\t\t{[]string{\"user_id\", \"timestamp\"}, true},\n\t\t{[]string{\"timestamp\", \"user_id\"}, false},\n\t}\n\tfor _, c := range testCases {\n\t\tkey := table.GetKey(c.cols...)\n\t\tif c.result && key == nil {\n\t\t\tt.Errorf(\"Unable to find key (%s)\", strings.Join(c.cols, \",\"))\n\t\t} else if !c.result && key != nil {\n\t\t\tt.Errorf(\"Expected to not find key, but got %s\", key)\n\t\t}\n\t}\n}\n\nfunc TestValidateModel(t *testing.T) {\n\ttable := mustLoadTable(t, \"objects\")\n\n\ttype BaseModel struct {\n\t\tUserID    int64  `db:\"user_id\"`\n\t\tID        string `db:\"object_id\"`\n\t\tTimestamp int64  `db:\"timestamp\"`\n\t}\n\n\ttype ObjectModel struct {\n\t\tBaseModel\n\t\tValue   string `db:\"value\"`\n\t\tIgnored int    `db:\"-\"`\n\t\tignored int\n\t}\n\n\tif err := table.ValidateModel(ObjectModel{}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// BaseModel doesn't map all of the table's columns.\n\tif err := table.ValidateModel(BaseModel{}); err == nil {\n\t\tt.Fatal(\"Expected failure, but found success\")\n\t}\n\n\ttype BadModel struct {\n\t\tObjectModel\n\t\tExtra string `db:\"extra\"`\n\t}\n\n\t// BadModel maps columns that are not in the table.\n\tif err := table.ValidateModel(BadModel{}); err == nil {\n\t\tt.Fatal(\"Expected failure, but found success\")\n\t}\n}\n"], "fixing_code": ["// Copyright 2012, Google Inc. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n//\n// SQUARE NOTE: The encoding routines were derived from vitess's\n// sqlparser package. The original source can be found at\n// https://code.google.com/p/vitess/\n\npackage squalor\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n)\n\n// Instructions for creating new types: If a type needs to satisfy an\n// interface, declare that function along with that interface. This\n// will help users identify the list of types to which they can assert\n// those interfaces. If the member of a type has a string with a\n// predefined list of values, declare those values as const following\n// the type. For interfaces that define dummy functions to\n// consolidate a set of types, define the function as typeName().\n// This will help avoid name collisions.\n\n// The Serializer interface is implemented by all\n// expressions/statements.\ntype Serializer interface {\n\t// Serialize writes the statement/expression to the Writer. If an\n\t// error is returned the Writer may contain partial output.\n\tSerialize(w Writer) error\n}\n\n// Serialize serializes a serializer to a string.\nfunc Serialize(s Serializer) (string, error) {\n\tw := &standardWriter{}\n\tif err := s.Serialize(w); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn w.String(), nil\n}\n\n// SerializeWithPlaceholders serializes a serializer to a string but without substituting\n// values. It may be useful for logging.\nfunc SerializeWithPlaceholders(s Serializer) (string, error) {\n\tw := &placeholderWriter{}\n\tif err := s.Serialize(w); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn w.String(), nil\n}\n\n// Writer defines an interface for writing a AST as SQL.\ntype Writer interface {\n\tio.Writer\n\n\t// WriteBytes writes a string of unprintable value.\n\tWriteBytes(node BytesVal) error\n\t// WriteEncoded writes an already encoded value.\n\tWriteEncoded(node EncodedVal) error\n\t// WriteNum writes a number value.\n\tWriteNum(node NumVal) error\n\t// WriteRaw writes a raw Go value.\n\tWriteRaw(node RawVal) error\n\t// WriteStr writes a SQL string value.\n\tWriteStr(node StrVal) error\n}\n\ntype standardWriter struct {\n\tbytes.Buffer\n}\n\nfunc (w *standardWriter) WriteRaw(node RawVal) error {\n\treturn encodeSQLValue(w, node.Val)\n}\n\nfunc (w *standardWriter) WriteEncoded(node EncodedVal) error {\n\t_, err := w.Write(node.Val)\n\treturn err\n}\n\nfunc (w *standardWriter) WriteStr(node StrVal) error {\n\treturn encodeSQLString(w, string(node))\n}\n\nfunc (w *standardWriter) WriteBytes(node BytesVal) error {\n\treturn encodeSQLBytes(w, []byte(node))\n}\n\nfunc (w *standardWriter) WriteNum(node NumVal) error {\n\t_, err := io.WriteString(w, string(node))\n\treturn err\n}\n\n// placeholderWriter will write all SQL value types as ? placeholders.\ntype placeholderWriter struct {\n\tbytes.Buffer\n}\n\nfunc (w *placeholderWriter) WriteRaw(node RawVal) error {\n\t_, err := w.Write(astPlaceholder)\n\treturn err\n}\n\nfunc (w *placeholderWriter) WriteEncoded(node EncodedVal) error {\n\t_, err := w.Write(astPlaceholder)\n\treturn err\n}\n\nfunc (w *placeholderWriter) WriteStr(node StrVal) error {\n\t_, err := w.Write(astPlaceholder)\n\treturn err\n}\n\nfunc (w *placeholderWriter) WriteBytes(node BytesVal) error {\n\t_, err := w.Write(astPlaceholder)\n\treturn err\n}\n\nfunc (w *placeholderWriter) WriteNum(node NumVal) error {\n\t_, err := w.Write(astPlaceholder)\n\treturn err\n}\n\nvar (\n\t// Placeholder is a placeholder for a value in a SQL statement. It is replaced with\n\t// an actual value when the query is executed.\n\tPlaceholder = PlaceholderVal{}\n)\n\n// Statement represents a statement.\ntype Statement interface {\n\tSerializer\n\tstatement()\n}\n\nfunc (*Union) statement()  {}\nfunc (*Select) statement() {}\nfunc (*Insert) statement() {}\nfunc (*Update) statement() {}\nfunc (*Delete) statement() {}\n\n// SelectStatement any SELECT statement.\ntype SelectStatement interface {\n\tStatement\n\tselectStatement()\n\tinsertRows()\n}\n\nfunc (*Select) selectStatement() {}\nfunc (*Union) selectStatement()  {}\n\n// Select represents a SELECT statement.\ntype Select struct {\n\tComments Comments\n\tDistinct string\n\tExprs    SelectExprs\n\tFrom     TableExprs\n\tWhere    *Where\n\tGroupBy  GroupBy\n\tHaving   *Where\n\tOrderBy  OrderBy\n\tLimit    *Limit\n\tLock     string\n}\n\n// Select.Distinct\nconst (\n\tastDistinct = \"DISTINCT \"\n)\n\n// Select.Lock\nconst (\n\tastForUpdate = \" FOR UPDATE\"\n\tastShareMode = \" LOCK IN SHARE MODE\"\n)\n\nvar (\n\tastSelect     = []byte(\"SELECT \")\n\tastSelectFrom = []byte(\" FROM \")\n)\n\nfunc (node *Select) Serialize(w Writer) error {\n\tif _, err := w.Write(astSelect); err != nil {\n\t\treturn err\n\t}\n\tif _, err := io.WriteString(w, node.Distinct); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Exprs.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif _, err := w.Write(astSelectFrom); err != nil {\n\t\treturn err\n\t}\n\tif err := node.From.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Where.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif err := node.GroupBy.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Having.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif err := node.OrderBy.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Limit.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\t_, err := io.WriteString(w, node.Lock)\n\treturn err\n}\n\n// Union represents a UNION statement.\ntype Union struct {\n\tType        string\n\tLeft, Right SelectStatement\n}\n\n// Union.Type\nconst (\n\tastUnion     = \"UNION\"\n\tastUnionAll  = \"UNION ALL\"\n\tastSetMinus  = \"MINUS\"\n\tastExcept    = \"EXCEPT\"\n\tastIntersect = \"INTERSECT\"\n)\n\nfunc (node *Union) Serialize(w Writer) error {\n\tif err := node.Left.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif _, err := w.Write(astSpace); err != nil {\n\t\treturn err\n\t}\n\tif _, err := io.WriteString(w, node.Type); err != nil {\n\t\treturn err\n\t}\n\tif _, err := w.Write(astSpace); err != nil {\n\t\treturn err\n\t}\n\treturn node.Right.Serialize(w)\n}\n\n// Insert represents an INSERT or REPLACE statement.\ntype Insert struct {\n\tKind     string\n\tComments Comments\n\tTable    *TableName\n\tColumns  Columns\n\tRows     InsertRows\n\tOnDup    OnDup\n}\n\nvar (\n\tastInsertInto = []byte(\"INTO \")\n\tastSpace      = []byte(\" \")\n)\n\nfunc (node *Insert) Serialize(w Writer) error {\n\tif _, err := io.WriteString(w, node.Kind); err != nil {\n\t\treturn err\n\t}\n\tif _, err := w.Write(astSpace); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Comments.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif _, err := w.Write(astInsertInto); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Table.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif _, err := w.Write(astSpace); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Columns.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif _, err := w.Write(astSpace); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Rows.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\treturn node.OnDup.Serialize(w)\n}\n\n// InsertRows represents the rows for an INSERT statement.\ntype InsertRows interface {\n\tSerializer\n\tinsertRows()\n}\n\nfunc (*Select) insertRows() {}\nfunc (*Union) insertRows()  {}\nfunc (Values) insertRows()  {}\n\n// Update represents an UPDATE statement.\ntype Update struct {\n\tComments Comments\n\tTable    *TableName\n\tTables   []*Table\n\tExprs    UpdateExprs\n\tWhere    *Where\n\tOrderBy  OrderBy\n\tLimit    *Limit\n}\n\nvar (\n\tastUpdate = []byte(\"UPDATE \")\n\tastSet    = []byte(\" SET \")\n)\n\nfunc (node *Update) Serialize(w Writer) error {\n\tif _, err := w.Write(astUpdate); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Comments.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Table.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif _, err := w.Write(astSet); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Exprs.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Where.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif err := node.OrderBy.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\treturn node.Limit.Serialize(w)\n}\n\n// Delete represents a DELETE statement.\ntype Delete struct {\n\tComments Comments\n\t// Table is either a TableName or a JoinBuilder\n\tTable abstractTable\n\t// TableNames is a list of tables to perform the delete on. This is only necessary when doing\n\t// joins, because you may not want to delete from all the tables involved in the join.\n\t// In deletes without joins, this may be empty or the table being deleted from.\n\tTableNames TableNames\n\tWhere      *Where\n\tOrderBy    OrderBy\n\tLimit      *Limit\n}\n\nvar (\n\tastDelete     = []byte(\"DELETE \")\n\tastDeleteFrom = []byte(\"FROM \")\n)\n\nfunc (node *Delete) Serialize(w Writer) error {\n\tif _, err := w.Write(astDelete); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Comments.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif len(node.TableNames) != 0 {\n\t\tif err := node.TableNames.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := fmt.Fprintf(w, \" \"); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif _, err := w.Write(astDeleteFrom); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Table.tableExpr().Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Where.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif err := node.OrderBy.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\treturn node.Limit.Serialize(w)\n}\n\n// Comments represents a list of comments.\ntype Comments []string\n\nfunc (node Comments) Serialize(w Writer) error {\n\tfor _, c := range node {\n\t\tif _, err := io.WriteString(w, c); err != nil {\n\t\t\treturn nil\n\t\t}\n\t\tif _, err := w.Write(astSpace); err != nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn nil\n}\n\n// TableNames represents several table names. It is used in deletes that have joins.\ntype TableNames []*TableName\n\nfunc (node TableNames) Serialize(w Writer) error {\n\tvar prefix []byte\n\tfor _, n := range node {\n\t\tif _, err := w.Write(prefix); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := n.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprefix = astCommaSpace\n\t}\n\treturn nil\n}\n\n// SelectExprs represents SELECT expressions.\ntype SelectExprs []SelectExpr\n\nvar (\n\tastCommaSpace = []byte(\", \")\n)\n\nfunc (node SelectExprs) Serialize(w Writer) error {\n\tvar prefix []byte\n\tfor _, n := range node {\n\t\tif _, err := w.Write(prefix); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := n.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprefix = astCommaSpace\n\t}\n\treturn nil\n}\n\n// SelectExpr represents a SELECT expression.\ntype SelectExpr interface {\n\tSerializer\n\tselectExpr()\n}\n\nfunc (*StarExpr) selectExpr()    {}\nfunc (*NonStarExpr) selectExpr() {}\n\n// StarExpr defines a '*' or 'table.*' expression.\ntype StarExpr struct {\n\tTableName string\n}\n\nvar (\n\tastStar = []byte(\"*\")\n)\n\nfunc (node *StarExpr) Serialize(w Writer) error {\n\tif node.TableName != \"\" {\n\t\tif err := quoteName(w, node.TableName); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := w.Write(astPeriod); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t_, err := w.Write(astStar)\n\treturn err\n}\n\n// NonStarExpr defines a non-'*' select expr.\ntype NonStarExpr struct {\n\tExpr Expr\n\tAs   string\n}\n\nvar (\n\tastAsPrefix = []byte(\" AS `\")\n)\n\nfunc (node *NonStarExpr) Serialize(w Writer) error {\n\tif err := node.Expr.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif node.As != \"\" {\n\t\tif _, err := w.Write(astAsPrefix); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := io.WriteString(w, node.As); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := w.Write(astBackquote); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// Columns represents an insert column list.\n// The syntax for Columns is a subset of SelectExprs.\n// So, it's castable to a SelectExprs and can be analyzed\n// as such.\ntype Columns []SelectExpr\n\nvar (\n\tastOpenParen  = []byte(\"(\")\n\tastCloseParen = []byte(\")\")\n)\n\nfunc (node Columns) Serialize(w Writer) error {\n\tif _, err := w.Write(astOpenParen); err != nil {\n\t\treturn err\n\t}\n\tif err := SelectExprs(node).Serialize(w); err != nil {\n\t\treturn err\n\t}\n\t_, err := w.Write(astCloseParen)\n\treturn err\n}\n\n// TableExprs represents a list of table expressions.\ntype TableExprs []TableExpr\n\nfunc (node TableExprs) Serialize(w Writer) error {\n\tvar prefix []byte\n\tfor _, n := range node {\n\t\tif _, err := w.Write(prefix); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := n.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprefix = astCommaSpace\n\t}\n\treturn nil\n}\n\n// TableExpr represents a table expression.\ntype TableExpr interface {\n\tSerializer\n\ttableExpr()\n}\n\nfunc (*AliasedTableExpr) tableExpr() {}\nfunc (*ParenTableExpr) tableExpr()   {}\nfunc (*JoinTableExpr) tableExpr()    {}\n\n// AliasedTableExpr represents a table expression\n// coupled with an optional alias or index hint.\ntype AliasedTableExpr struct {\n\tExpr  SimpleTableExpr\n\tAs    string\n\tHints *IndexHints\n}\n\nfunc (node *AliasedTableExpr) Serialize(w Writer) error {\n\tif err := node.Expr.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif node.As != \"\" {\n\t\tif _, err := w.Write(astAsPrefix); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := io.WriteString(w, node.As); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := w.Write(astBackquote); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif node.Hints != nil {\n\t\t// Hint node provides the space padding.\n\t\tif err := node.Hints.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// SimpleTableExpr represents a simple table expression.\ntype SimpleTableExpr interface {\n\tSerializer\n\tsimpleTableExpr()\n}\n\nfunc (*TableName) simpleTableExpr() {}\nfunc (*Subquery) simpleTableExpr()  {}\n\n// TableName represents a table name.\ntype TableName struct {\n\tName, Qualifier string\n}\n\nfunc (node *TableName) Serialize(w Writer) error {\n\tif node.Qualifier != \"\" {\n\t\tif err := quoteName(w, node.Qualifier); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := w.Write(astPeriod); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn quoteName(w, node.Name)\n}\n\n// ParenTableExpr represents a parenthesized TableExpr.\ntype ParenTableExpr struct {\n\tExpr TableExpr\n}\n\n// JoinTableExpr represents a TableExpr that's a JOIN operation.\ntype JoinTableExpr struct {\n\tLeftExpr  TableExpr\n\tJoin      string\n\tRightExpr TableExpr\n\tCond      JoinCond\n}\n\n// JoinTableExpr.Join\nconst (\n\tastJoin         = \"JOIN\"\n\tastStraightJoin = \"STRAIGHT_JOIN\"\n\tastLeftJoin     = \"LEFT JOIN\"\n\tastRightJoin    = \"RIGHT JOIN\"\n\tastCrossJoin    = \"CROSS JOIN\"\n\tastNaturalJoin  = \"NATURAL JOIN\"\n)\n\nfunc (node *JoinTableExpr) Serialize(w Writer) error {\n\tif err := node.LeftExpr.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif _, err := fmt.Fprintf(w, \" %s \", node.Join); err != nil {\n\t\treturn err\n\t}\n\tif err := node.RightExpr.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif node.Cond != nil {\n\t\tif err := node.Cond.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// JoinCond represents a join condition.\ntype JoinCond interface {\n\tSerializer\n\tjoinCond()\n}\n\nfunc (*OnJoinCond) joinCond()    {}\nfunc (*UsingJoinCond) joinCond() {}\n\n// OnJoinCond represents an ON join condition.\ntype OnJoinCond struct {\n\tExpr BoolExpr\n}\n\nvar (\n\tastOn = []byte(\" ON \")\n)\n\nfunc (node *OnJoinCond) Serialize(w Writer) error {\n\tif _, err := w.Write(astOn); err != nil {\n\t\treturn err\n\t}\n\treturn node.Expr.Serialize(w)\n}\n\n// UsingJoinCond represents a USING join condition.\ntype UsingJoinCond struct {\n\tCols Columns\n}\n\nvar (\n\tastUsing = []byte(\" USING \")\n)\n\nfunc (node *UsingJoinCond) Serialize(w Writer) error {\n\tif _, err := w.Write(astUsing); err != nil {\n\t\treturn err\n\t}\n\treturn node.Cols.Serialize(w)\n}\n\n// IndexHints represents a list of index hints.\ntype IndexHints struct {\n\tType    string\n\tIndexes []string\n}\n\nconst (\n\tastUse    = \"USE\"\n\tastIgnore = \"IGNORE\"\n\tastForce  = \"FORCE\"\n)\n\nfunc (node *IndexHints) Serialize(w Writer) error {\n\tif _, err := fmt.Fprintf(w, \" %s INDEX \", node.Type); err != nil {\n\t\treturn err\n\t}\n\tprefix := \"(\"\n\tfor _, n := range node.Indexes {\n\t\tif _, err := fmt.Fprintf(w, \"%s%s\", prefix, n); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprefix = \", \"\n\t}\n\t_, err := fmt.Fprintf(w, \")\")\n\treturn err\n}\n\n// Where represents a WHERE or HAVING clause.\ntype Where struct {\n\tType string\n\tExpr BoolExpr\n}\n\n// Where.Type\nconst (\n\tastWhere  = \" WHERE \"\n\tastHaving = \" HAVING \"\n)\n\n// NewWhere creates a WHERE or HAVING clause out\n// of a BoolExpr. If the expression is nil, it returns nil.\nfunc NewWhere(typ string, expr BoolExpr) *Where {\n\tif expr == nil {\n\t\treturn nil\n\t}\n\treturn &Where{Type: typ, Expr: expr}\n}\n\nfunc (node *Where) Serialize(w Writer) error {\n\tif node == nil {\n\t\treturn nil\n\t}\n\tif _, err := io.WriteString(w, node.Type); err != nil {\n\t\treturn err\n\t}\n\treturn node.Expr.Serialize(w)\n}\n\n// Expr represents an expression.\ntype Expr interface {\n\tSerializer\n\texpr()\n}\n\nfunc (*AndExpr) expr()        {}\nfunc (*OrExpr) expr()         {}\nfunc (*NotExpr) expr()        {}\nfunc (*ParenBoolExpr) expr()  {}\nfunc (*ComparisonExpr) expr() {}\nfunc (*RangeCond) expr()      {}\nfunc (*NullCheck) expr()      {}\nfunc (*ExistsExpr) expr()     {}\nfunc (PlaceholderVal) expr()  {}\nfunc (RawVal) expr()          {}\nfunc (EncodedVal) expr()      {}\nfunc (StrVal) expr()          {}\nfunc (NumVal) expr()          {}\nfunc (ValArg) expr()          {}\nfunc (*NullVal) expr()        {}\nfunc (*ColName) expr()        {}\nfunc (ValTuple) expr()        {}\nfunc (*Subquery) expr()       {}\nfunc (*BinaryExpr) expr()     {}\nfunc (*UnaryExpr) expr()      {}\nfunc (*FuncExpr) expr()       {}\nfunc (*CaseExpr) expr()       {}\n\n// BoolExpr represents a boolean expression.\ntype BoolExpr interface {\n\tboolExpr()\n\tExpr\n}\n\nfunc (*AndExpr) boolExpr()        {}\nfunc (*OrExpr) boolExpr()         {}\nfunc (*NotExpr) boolExpr()        {}\nfunc (*ParenBoolExpr) boolExpr()  {}\nfunc (*ComparisonExpr) boolExpr() {}\nfunc (*RangeCond) boolExpr()      {}\nfunc (*NullCheck) boolExpr()      {}\nfunc (*ExistsExpr) boolExpr()     {}\n\nconst (\n\tastAndExpr = \" AND \"\n)\n\n// AndExpr represents an AND expression.\ntype AndExpr struct {\n\tOp    string\n\tExprs []BoolExpr\n}\n\nfunc (node *AndExpr) Serialize(w Writer) error {\n\tif len(node.Exprs) == 0 {\n\t\t_, err := w.Write(astBoolTrue)\n\t\treturn err\n\t} else if len(node.Exprs) == 1 {\n\t\treturn node.Exprs[0].Serialize(w)\n\t}\n\n\tif _, err := w.Write(astOpenParen); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Exprs[0].Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tfor _, expr := range node.Exprs[1:] {\n\t\tif _, err := io.WriteString(w, node.Op); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := expr.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t_, err := w.Write(astCloseParen)\n\treturn err\n}\n\nconst (\n\tastOrExpr = \" OR \"\n)\n\n// OrExpr represents an OR expression.\ntype OrExpr struct {\n\tOp    string\n\tExprs []BoolExpr\n}\n\nfunc (node *OrExpr) Serialize(w Writer) error {\n\tif len(node.Exprs) == 0 {\n\t\t_, err := w.Write(astBoolFalse)\n\t\treturn err\n\t} else if len(node.Exprs) == 1 {\n\t\treturn node.Exprs[0].Serialize(w)\n\t}\n\n\tif _, err := w.Write(astOpenParen); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Exprs[0].Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tfor _, expr := range node.Exprs[1:] {\n\t\tif _, err := io.WriteString(w, node.Op); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := expr.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t_, err := w.Write(astCloseParen)\n\treturn err\n}\n\nconst (\n\tastNotExpr = \"NOT \"\n)\n\n// NotExpr represents a NOT expression.\ntype NotExpr struct {\n\tOp   string\n\tExpr BoolExpr\n}\n\nfunc (node *NotExpr) Serialize(w Writer) error {\n\tif _, err := io.WriteString(w, node.Op); err != nil {\n\t\treturn err\n\t}\n\treturn node.Expr.Serialize(w)\n}\n\n// ParenBoolExpr represents a parenthesized boolean expression.\ntype ParenBoolExpr struct {\n\tExpr BoolExpr\n}\n\nfunc (node *ParenBoolExpr) Serialize(w Writer) error {\n\tif _, err := w.Write(astOpenParen); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Expr.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\t_, err := w.Write(astCloseParen)\n\treturn err\n}\n\n// ComparisonExpr represents a two-value comparison expression.\ntype ComparisonExpr struct {\n\tOperator    string\n\tLeft, Right ValExpr\n}\n\n// ComparisonExpr.Operator\nconst (\n\tastEQ        = \" = \"\n\tastLT        = \" < \"\n\tastGT        = \" > \"\n\tastLE        = \" <= \"\n\tastGE        = \" >= \"\n\tastNE        = \" != \"\n\tastNSE       = \" <=> \"\n\tastIn        = \" IN \"\n\tastNot       = \" NOT \"\n\tastNotIn     = \" NOT IN \"\n\tastLike      = \" LIKE \"\n\tastNotLike   = \" NOT LIKE \"\n\tastRegExp    = \" REGEXP \"\n\tastNotRegExp = \" NOT REGEXP \"\n)\n\nfunc (node *ComparisonExpr) Serialize(w Writer) error {\n\tif err := node.Left.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif _, err := io.WriteString(w, node.Operator); err != nil {\n\t\treturn err\n\t}\n\treturn node.Right.Serialize(w)\n}\n\n// RangeCond represents a BETWEEN or a NOT BETWEEN expression.\ntype RangeCond struct {\n\tOperator string\n\tLeft     ValExpr\n\tFrom, To ValExpr\n}\n\n// RangeCond.Operator\nconst (\n\tastBetween    = \" BETWEEN \"\n\tastNotBetween = \" NOT BETWEEN \"\n)\n\nvar (\n\tastAnd = []byte(\" AND \")\n)\n\nfunc (node *RangeCond) Serialize(w Writer) error {\n\tif err := node.Left.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif _, err := io.WriteString(w, node.Operator); err != nil {\n\t\treturn err\n\t}\n\tif err := node.From.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif _, err := w.Write(astAnd); err != nil {\n\t\treturn err\n\t}\n\treturn node.To.Serialize(w)\n}\n\n// NullCheck represents an IS NULL or an IS NOT NULL expression.\ntype NullCheck struct {\n\tOperator string\n\tExpr     ValExpr\n}\n\n// NullCheck.Operator\nconst (\n\tastIsNull    = \" IS NULL\"\n\tastIsNotNull = \" IS NOT NULL\"\n)\n\nfunc (node *NullCheck) Serialize(w Writer) error {\n\tif err := node.Expr.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\t_, err := io.WriteString(w, node.Operator)\n\treturn err\n}\n\n// ExistsExpr represents an EXISTS expression.\ntype ExistsExpr struct {\n\tSubquery *Subquery\n}\n\n// ValExpr represents a value expression.\ntype ValExpr interface {\n\tvalExpr()\n\tExpr\n}\n\nfunc (PlaceholderVal) valExpr() {}\nfunc (RawVal) valExpr()         {}\nfunc (EncodedVal) valExpr()     {}\nfunc (StrVal) valExpr()         {}\nfunc (NumVal) valExpr()         {}\nfunc (ValArg) valExpr()         {}\nfunc (*NullVal) valExpr()       {}\nfunc (*ColName) valExpr()       {}\nfunc (ValTuple) valExpr()       {}\nfunc (*Subquery) valExpr()      {}\nfunc (*BinaryExpr) valExpr()    {}\nfunc (*UnaryExpr) valExpr()     {}\nfunc (*FuncExpr) valExpr()      {}\nfunc (*CaseExpr) valExpr()      {}\n\nvar (\n\tastPlaceholder = []byte(\"?\")\n)\n\n// PlaceholderVal represents a placeholder parameter that will be supplied\n// when executing the query. It will be serialized as a ?.\ntype PlaceholderVal struct{}\n\nfunc (node PlaceholderVal) Serialize(w Writer) error {\n\t_, err := w.Write(astPlaceholder)\n\treturn err\n}\n\n// RawVal represents a raw go value\ntype RawVal struct {\n\tVal interface{}\n}\n\nvar (\n\tastBoolTrue  = []byte(\"1\")\n\tastBoolFalse = []byte(\"0\")\n)\n\nfunc (node RawVal) Serialize(w Writer) error {\n\treturn w.WriteRaw(node)\n}\n\n// EncodedVal represents an already encoded value. This struct must be used\n// with caution because misuse can provide an avenue for SQL injection attacks.\ntype EncodedVal struct {\n\tVal []byte\n}\n\nfunc (node EncodedVal) Serialize(w Writer) error {\n\treturn w.WriteEncoded(node)\n}\n\n// StrVal represents a string value.\ntype StrVal string\n\nfunc (node StrVal) Serialize(w Writer) error {\n\treturn w.WriteStr(node)\n}\n\n// BytesVal represents a string of unprintable value.\ntype BytesVal []byte\n\nfunc (BytesVal) expr()    {}\nfunc (BytesVal) valExpr() {}\n\nfunc (node BytesVal) Serialize(w Writer) error {\n\treturn w.WriteBytes(node)\n}\n\n// ErrVal represents an error condition that occurred while\n// constructing a tree.\ntype ErrVal struct {\n\tErr error\n}\n\nfunc (ErrVal) expr()    {}\nfunc (ErrVal) valExpr() {}\n\nfunc (node ErrVal) Serialize(w Writer) error {\n\treturn node.Err\n}\n\n// NumVal represents a number.\ntype NumVal string\n\nfunc (node NumVal) Serialize(w Writer) error {\n\treturn w.WriteNum(node)\n}\n\n// ValArg represents a named bind var argument.\ntype ValArg string\n\nfunc (node ValArg) Serialize(w Writer) error {\n\t_, err := fmt.Fprintf(w, \":%s\", string(node)[1:])\n\treturn err\n}\n\n// NullVal represents a NULL value.\ntype NullVal struct{}\n\nvar (\n\tastNull = []byte(\"NULL\")\n)\n\nfunc (node *NullVal) Serialize(w Writer) error {\n\t_, err := w.Write(astNull)\n\treturn err\n}\n\n// ColName represents a column name.\ntype ColName struct {\n\tName, Qualifier string\n}\n\nvar (\n\tastBackquoteStr       = \"`\"\n\tastDoubleBackquoteStr = \"``\"\n\tastBackquote          = []byte(astBackquoteStr)\n\tastPeriod             = []byte(\".\")\n)\n\nfunc (node *ColName) Serialize(w Writer) error {\n\tif node.Qualifier != \"\" {\n\t\tif err := quoteName(w, node.Qualifier); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := w.Write(astPeriod); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn quoteName(w, node.Name)\n}\n\n// note: quoteName escapes any backquote (`) characters in s. quoteName is indirectly\n// called by builder.go, which checks that column/table names exist.\nfunc quoteName(w io.Writer, s string) error {\n\tif _, err := w.Write(astBackquote); err != nil {\n\t\treturn err\n\t}\n\ts = strings.ReplaceAll(s, astBackquoteStr, astDoubleBackquoteStr)\n\tif _, err := io.WriteString(w, s); err != nil {\n\t\treturn err\n\t}\n\t_, err := w.Write(astBackquote)\n\treturn err\n}\n\n// Tuple represents a tuple. It can be ValTuple, Subquery.\ntype Tuple interface {\n\ttuple()\n\tValExpr\n}\n\nfunc (ValTuple) tuple()  {}\nfunc (*Subquery) tuple() {}\n\n// ValTuple represents a tuple of actual values.\ntype ValTuple struct {\n\tExprs ValExprs\n}\n\nfunc (node ValTuple) Serialize(w Writer) error {\n\tif _, err := w.Write(astOpenParen); err != nil {\n\t\treturn err\n\t}\n\tif err := node.Exprs.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\t_, err := w.Write(astCloseParen)\n\treturn err\n}\n\n// ValExprs represents a list of value expressions.\n// It's not a valid expression because it's not parenthesized.\ntype ValExprs []ValExpr\n\nfunc (node ValExprs) Serialize(w Writer) error {\n\tvar prefix []byte\n\tfor _, n := range node {\n\t\tif _, err := w.Write(prefix); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := n.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprefix = astCommaSpace\n\t}\n\treturn nil\n}\n\n// Subquery represents a subquery.\ntype Subquery struct {\n\tSelect SelectStatement\n}\n\nfunc (s *Subquery) Serialize(w Writer) error {\n\t_, err := w.Write([]byte{'('})\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = s.Select.Serialize(w)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = w.Write([]byte{')'})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// BinaryExpr represents a binary value expression.\ntype BinaryExpr struct {\n\tOperator    byte\n\tLeft, Right Expr\n}\n\n// BinaryExpr.Operator\nconst (\n\tastBitand = '&'\n\tastBitor  = '|'\n\tastBitxor = '^'\n\tastPlus   = '+'\n\tastMinus  = '-'\n\tastMult   = '*'\n\tastDiv    = '/'\n\tastMod    = '%'\n)\n\nfunc (node *BinaryExpr) Serialize(w Writer) error {\n\tif err := node.Left.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\tif _, err := fmt.Fprintf(w, \"%c\", node.Operator); err != nil {\n\t\treturn err\n\t}\n\treturn node.Right.Serialize(w)\n}\n\n// UnaryExpr represents a unary value expression.\ntype UnaryExpr struct {\n\tOperator byte\n\tExpr     Expr\n}\n\n// UnaryExpr.Operator\nconst (\n\tastUnaryPlus  = '+'\n\tastUnaryMinus = '-'\n\tastTilda      = '~'\n)\n\nfunc (node *UnaryExpr) Serialize(w Writer) error {\n\tif _, err := fmt.Fprintf(w, \"%c\", node.Operator); err != nil {\n\t\treturn err\n\t}\n\treturn node.Expr.Serialize(w)\n}\n\n// FuncExpr represents a function call.\ntype FuncExpr struct {\n\tName     string\n\tDistinct bool\n\tExprs    SelectExprs\n}\n\nvar (\n\tastFuncDistinct = []byte(\"DISTINCT \")\n)\n\nfunc (node *FuncExpr) Serialize(w Writer) error {\n\tif _, err := io.WriteString(w, node.Name); err != nil {\n\t\treturn err\n\t}\n\tif _, err := w.Write(astOpenParen); err != nil {\n\t\treturn err\n\t}\n\tif node.Distinct {\n\t\tif _, err := w.Write(astFuncDistinct); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := node.Exprs.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\t_, err := w.Write(astCloseParen)\n\treturn err\n}\n\n// CaseExpr represents a CASE expression.\ntype CaseExpr struct {\n\tExpr  ValExpr\n\tWhens []*When\n\tElse  ValExpr\n}\n\nfunc (node *CaseExpr) Serialize(w Writer) error {\n\tif _, err := fmt.Fprint(w, \"CASE \"); err != nil {\n\t\treturn err\n\t}\n\tif node.Expr != nil {\n\t\tif err := node.Expr.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := fmt.Fprint(w, \" \"); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tfor _, when := range node.Whens {\n\t\tif err := when.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := fmt.Fprint(w, \" \"); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif node.Else != nil {\n\t\tif _, err := fmt.Fprint(w, \"ELSE \"); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := node.Else.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := fmt.Fprint(w, \" \"); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t_, err := fmt.Fprint(w, \"END\")\n\treturn err\n}\n\n// When represents a WHEN sub-expression.\ntype When struct {\n\tCond BoolExpr\n\tVal  ValExpr\n}\n\nfunc (node *When) Serialize(w Writer) error {\n\tif err := node.Cond.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\treturn node.Val.Serialize(w)\n}\n\n// Values represents a VALUES clause.\ntype Values []Tuple\n\nvar (\n\tastValues = []byte(\"VALUES \")\n)\n\nfunc (node Values) Serialize(w Writer) error {\n\tprefix := astValues\n\tfor _, n := range node {\n\t\tif _, err := w.Write(prefix); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := n.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprefix = astCommaSpace\n\t}\n\treturn nil\n}\n\n// GroupBy represents a GROUP BY clause.\ntype GroupBy []ValExpr\n\nvar (\n\tastGroupBy = []byte(\" GROUP BY \")\n)\n\nfunc (node GroupBy) Serialize(w Writer) error {\n\tprefix := astGroupBy\n\tfor _, n := range node {\n\t\tif _, err := w.Write(prefix); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := n.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprefix = astCommaSpace\n\t}\n\treturn nil\n}\n\n// OrderBy represents an ORDER By clause.\ntype OrderBy []*Order\n\nvar (\n\tastOrderBy = []byte(\" ORDER BY \")\n)\n\nfunc (node OrderBy) Serialize(w Writer) error {\n\tprefix := astOrderBy\n\tfor _, n := range node {\n\t\tif _, err := w.Write(prefix); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := n.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprefix = astCommaSpace\n\t}\n\treturn nil\n}\n\n// Order represents an ordering expression.\ntype Order struct {\n\tExpr      ValExpr\n\tDirection string\n}\n\n// Order.Direction\nconst (\n\tastAsc  = \" ASC\"\n\tastDesc = \" DESC\"\n)\n\nfunc (node *Order) Serialize(w Writer) error {\n\tif err := node.Expr.Serialize(w); err != nil {\n\t\treturn err\n\t}\n\t_, err := io.WriteString(w, node.Direction)\n\treturn err\n}\n\n// Limit represents a LIMIT clause.\ntype Limit struct {\n\tOffset, Rowcount ValExpr\n}\n\nvar (\n\tastLimit = []byte(\" LIMIT \")\n)\n\nfunc (node *Limit) Serialize(w Writer) error {\n\tif node == nil {\n\t\treturn nil\n\t}\n\tif _, err := w.Write(astLimit); err != nil {\n\t\treturn err\n\t}\n\tif node.Offset != nil {\n\t\tif err := node.Offset.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := w.Write(astCommaSpace); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn node.Rowcount.Serialize(w)\n}\n\n// UpdateExprs represents a list of update expressions.\ntype UpdateExprs []*UpdateExpr\n\nfunc (node UpdateExprs) Serialize(w Writer) error {\n\tvar prefix []byte\n\tfor _, n := range node {\n\t\tif _, err := w.Write(prefix); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := n.Serialize(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprefix = astCommaSpace\n\t}\n\treturn nil\n}\n\n// UpdateExpr represents an update expression.\ntype UpdateExpr struct {\n\tName *ColName\n\tExpr ValExpr\n}\n\nvar (\n\tastUpdateEq = []byte(\" = \")\n)\n\nfunc (node *UpdateExpr) Serialize(w Writer) error {\n\tif err := node.Name.Serialize(w); err != nil {\n\t\treturn nil\n\t}\n\tif _, err := w.Write(astUpdateEq); err != nil {\n\t\treturn nil\n\t}\n\treturn node.Expr.Serialize(w)\n}\n\n// OnDup represents an ON DUPLICATE KEY clause.\ntype OnDup UpdateExprs\n\nvar (\n\tastOnDupKeyUpdate = []byte(\" ON DUPLICATE KEY UPDATE \")\n)\n\nfunc (node OnDup) Serialize(w Writer) error {\n\tif node == nil {\n\t\treturn nil\n\t}\n\tif _, err := w.Write(astOnDupKeyUpdate); err != nil {\n\t\treturn err\n\t}\n\treturn UpdateExprs(node).Serialize(w)\n}\n", "// Copyright 2014 Square Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage squalor\n\nimport (\n\t\"bytes\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strings\"\n\t\"text/tabwriter\"\n)\n\n// Column models a database column.\ntype Column struct {\n\tName     string\n\tAutoIncr bool\n\tNullable bool\n\tsqlType  string\n}\n\nfunc (c *Column) String() string {\n\tvar buf bytes.Buffer\n\tfmt.Fprintf(&buf, \"%s\\t%s\", c.Name, c.sqlType)\n\tif c.Nullable {\n\t\tfmt.Fprint(&buf, \"\\tNULL\")\n\t} else {\n\t\tfmt.Fprint(&buf, \"\\tNOT NULL\")\n\t}\n\tif c.AutoIncr {\n\t\tfmt.Fprint(&buf, \" AUTO INCREMENT\")\n\t}\n\treturn buf.String()\n}\n\ntype byName []*Column\n\nfunc (n byName) Len() int {\n\treturn len(n)\n}\n\nfunc (n byName) Less(i, j int) bool {\n\treturn n[i].Name < n[j].Name\n}\n\nfunc (n byName) Swap(i, j int) {\n\tn[i], n[j] = n[j], n[i]\n}\n\ntype keyColumn struct {\n\tseq  int\n\tname string\n}\n\ntype bySeq []keyColumn\n\nfunc (s bySeq) Len() int {\n\treturn len(s)\n}\n\nfunc (s bySeq) Less(i, j int) bool {\n\treturn s[i].seq < s[j].seq\n}\n\nfunc (s bySeq) Swap(i, j int) {\n\ts[i], s[j] = s[j], s[i]\n}\n\n// Key models a key (index) for a database table. A key is composed of\n// one or more columns.\ntype Key struct {\n\tName    string\n\tPrimary bool\n\tUnique  bool\n\tColumns []*Column\n}\n\nfunc (k *Key) String() string {\n\tvar buf bytes.Buffer\n\tif k.Primary {\n\t\tfmt.Fprint(&buf, \"PRIMARY \")\n\t} else if k.Unique {\n\t\tfmt.Fprint(&buf, \"UNIQUE \")\n\t}\n\tfmt.Fprint(&buf, \"KEY\")\n\tif !k.Primary {\n\t\tfmt.Fprintf(&buf, \" %s\", k.Name)\n\t}\n\tfmt.Fprint(&buf, \"\\t(\")\n\tvar sep string\n\tfor _, col := range k.Columns {\n\t\tfmt.Fprintf(&buf, \"%s%s\", sep, col.Name)\n\t\tsep = \",\"\n\t}\n\tfmt.Fprint(&buf, \")\")\n\treturn buf.String()\n}\n\nfunc (k *Key) matches(cols ...string) bool {\n\tif len(k.Columns) != len(cols) {\n\t\treturn false\n\t}\n\tfor i := range cols {\n\t\tif k.Columns[i].Name != cols[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// Table models a database table containing column and key definitions.\ntype Table struct {\n\tName       string\n\tAlias      string\n\tIndexHints *IndexHints\n\tColumns    []*Column\n\tColumnMap  map[string]*Column\n\tPrimaryKey *Key\n\tKeys       []*Key\n\tKeyMap     map[string]*Key\n}\n\nfunc makeTable(name string) *Table {\n\treturn &Table{\n\t\tName:      name,\n\t\tColumnMap: make(map[string]*Column),\n\t\tKeyMap:    make(map[string]*Key),\n\t}\n}\n\n// NewTable constructs a table from a model struct. The resulting\n// table is less detailed than one created from LoadTable due to the\n// lack of keys of type info.\nfunc NewTable(name string, model interface{}) *Table {\n\tt := makeTable(name)\n\tm := getDBFields(reflect.TypeOf(model))\n\tfor k := range m {\n\t\tcol := &Column{Name: k}\n\t\tt.Columns = append(t.Columns, col)\n\t\tt.ColumnMap[k] = col\n\t}\n\tsort.Sort(byName(t.Columns))\n\treturn t\n}\n\n// NewAliasedTable constructs a table with an alias from a model struct. The\n// alias will be used in column names and in joins. The resulting\n// table is less detailed than one created from LoadTable due to the\n// lack of keys of type info.\nfunc NewAliasedTable(name, alias string, model interface{}) *Table {\n\tt := NewTable(name, model)\n\tt.Alias = alias\n\treturn t\n}\n\n// LoadTable loads a table's definition from a database.\nfunc LoadTable(db *sql.DB, name string) (*Table, error) {\n\tt := makeTable(name)\n\terr := t.loadColumns(db)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = t.loadKeys(db)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn t, nil\n}\n\nfunc (t *Table) String() string {\n\tvar buf bytes.Buffer\n\ttab := tabwriter.NewWriter(&buf, 0, 4, 2, ' ', 0)\n\tfmt.Fprintf(tab, \"%s:\\n\", t.Name)\n\tfmt.Fprint(tab, \"  columns:\\n\")\n\tfor _, col := range t.Columns {\n\t\tfmt.Fprintf(tab, \"    %s\\n\", col)\n\t}\n\tfmt.Fprint(tab, \"  keys:\\n\")\n\tfor _, key := range t.Keys {\n\t\tfmt.Fprintf(tab, \"    %s\\n\", key)\n\t}\n\ttab.Flush()\n\treturn buf.String()\n}\n\n// GetKey retrieves a key from the table definition.\nfunc (t *Table) GetKey(cols ...string) *Key {\n\tfor _, key := range t.Keys {\n\t\tif key.matches(cols...) {\n\t\t\treturn key\n\t\t}\n\t}\n\treturn nil\n}\n\n// Apply a \"USE INDEX\" hint to a table. This will replace any existing index hints.\nfunc (t *Table) UseIndex(indexes ...string) *Table {\n\treturn t.setIndexHint(astUse, indexes)\n}\n\n// Apply a \"FORCE INDEX\" hint to a table. This will replace any existing index hints.\nfunc (t *Table) ForceIndex(indexes ...string) *Table {\n\treturn t.setIndexHint(astForce, indexes)\n}\n\n// Apply an \"IGNORE INDEX\" hint to a table. This will replace any existing index hints.\nfunc (t *Table) IgnoreIndex(indexes ...string) *Table {\n\treturn t.setIndexHint(astIgnore, indexes)\n}\n\nfunc (t *Table) setIndexHint(hintType string, indexes []string) *Table {\n\ttableCopy := *t\n\tindexesCopy := make([]string, len(indexes))\n\tcopy(indexesCopy, indexes)\n\ttableCopy.IndexHints = &IndexHints{\n\t\tType:    hintType,\n\t\tIndexes: indexesCopy,\n\t}\n\treturn &tableCopy\n}\n\n// C returns an expression for the specified list of columns. An error\n// expression is created if any of the columns do not exist in the table. An\n// error expression is created if no columns are specified.\nfunc (t *Table) C(cols ...string) ValExprBuilder {\n\tif len(cols) == 0 {\n\t\treturn ValExprBuilder{makeErrVal(\"no columns specified\")}\n\t}\n\n\tif len(cols) == 1 {\n\t\tname := cols[0]\n\t\tif _, ok := t.ColumnMap[name]; !ok {\n\t\t\treturn ValExprBuilder{makeErrVal(\"unknown column: %s\", name)}\n\t\t}\n\t\treturn ValExprBuilder{&ColName{Name: name, Qualifier: t.aliasOrName()}}\n\t}\n\tlist := make([]interface{}, len(cols))\n\tfor i, name := range cols {\n\t\tif _, ok := t.ColumnMap[name]; !ok {\n\t\t\tlist[i] = makeErrVal(\"unknown column: %s\", name)\n\t\t} else {\n\t\t\tlist[i] = &ColName{Name: name, Qualifier: t.aliasOrName()}\n\t\t}\n\t}\n\treturn ValExprBuilder{makeValTuple(list)}\n}\n\n// All returns an expression for all of the columns in the table in\n// the order in which they are defined in the table (the order of\n// Table.Columns). Note that returned expression is a tuple of\n// columns, not a star expression.\nfunc (t *Table) All() ValExprBuilder {\n\tlist := make([]interface{}, len(t.Columns))\n\tfor i, col := range t.Columns {\n\t\tlist[i] = &ColName{Name: col.Name, Qualifier: t.aliasOrName()}\n\t}\n\treturn ValExprBuilder{makeValTuple(list)}\n}\n\n// InnerJoin creates an INNER JOIN statement builder. Note that inner\n// join and join are synonymous in MySQL. Inner join is used here for\n// clarity.\nfunc (t *Table) InnerJoin(other *Table) *JoinBuilder {\n\treturn makeJoinBuilder(\"INNER JOIN\", t, other)\n}\n\n// LeftJoin creates a LEFT JOIN statement builder.\nfunc (t *Table) LeftJoin(other *Table) *JoinBuilder {\n\treturn makeJoinBuilder(\"LEFT JOIN\", t, other)\n}\n\n// RightJoin creates a RIGHT JOIN statement builder.\nfunc (t *Table) RightJoin(other *Table) *JoinBuilder {\n\treturn makeJoinBuilder(\"RIGHT JOIN\", t, other)\n}\n\n// Delete creates a DELETE statement builder.\nfunc (t *Table) Delete(tables ...*Table) *DeleteBuilder {\n\treturn makeDeleteBuilder(t, tables...)\n}\n\n// Insert creates an INSERT statement builder.\nfunc (t *Table) Insert(cols ...interface{}) *InsertBuilder {\n\treturn makeInsertBuilder(t, \"INSERT\", cols...)\n}\n\n// Insert creates an INSERT statement builder.\nfunc (t *Table) InsertIgnore(cols ...interface{}) *InsertBuilder {\n\treturn makeInsertBuilder(t, \"INSERT IGNORE\", cols...)\n}\n\n// Replace creates a REPLACE statement builder.\nfunc (t *Table) Replace(cols ...interface{}) *ReplaceBuilder {\n\treturn makeReplaceBuilder(t, cols...)\n}\n\n// Select creates a SELECT statement builder.\nfunc (t *Table) Select(exprs ...interface{}) *SelectBuilder {\n\treturn makeSelectBuilder(t, exprs...)\n}\n\n// Update creates an UPDATE statement builder.\nfunc (t *Table) Update() *UpdateBuilder {\n\treturn makeUpdateBuilder(t)\n}\n\nfunc (t *Table) validateFields(m fieldMap) error {\n\t// Verify all of the model columns exist in the table.\n\tfor name, field := range m {\n\t\tc1 := t.ColumnMap[name]\n\t\tif c1 == nil {\n\t\t\treturn fmt.Errorf(\"%s: model column '%s' not found in table\", t.Name, name)\n\t\t}\n\t\tif err := validateModelType(c1.sqlType, field.Type); err != nil {\n\t\t\treturn fmt.Errorf(\"%s: '%s': %s\", t.Name, name, err)\n\t\t}\n\t}\n\t// Verify all of the table columns exist in the model.\n\tfor name := range t.ColumnMap {\n\t\tif _, ok := m[name]; !ok {\n\t\t\treturn fmt.Errorf(\"%s: table column '%s' not found in model\", t.Name, name)\n\t\t}\n\t}\n\treturn nil\n}\n\n// ValidateModel validates that the model is compatible for the\n// table's schema. It checks that every column in the database is\n// mapped to a field in the model and every field in the model has a\n// corresponding column in the table schema.\nfunc (t *Table) ValidateModel(model interface{}) error {\n\tm := getDBFields(reflect.TypeOf(model))\n\treturn t.validateFields(m)\n}\n\n// aliasOrName will return table's alias if it is not blank,\n// otherwise it will return the table's name.\nfunc (t *Table) aliasOrName() string {\n\tif t.Alias != \"\" {\n\t\treturn t.Alias\n\t}\n\treturn t.Name\n}\n\n// Enclose a name in backquotes and escape any internal backquotes.\nfunc quoteNameStr(s string) string {\n\treturn astBackquoteStr + strings.ReplaceAll(s, astBackquoteStr, astDoubleBackquoteStr) + astBackquoteStr\n}\n\n// loadColumns loads a table's columns from a database. MySQL\n// specific.\nfunc (t *Table) loadColumns(db *sql.DB) error {\n\trows, err := db.Query(\"SHOW FULL COLUMNS FROM \" + quoteNameStr(t.Name))\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer rows.Close()\n\n\tcols, err := rows.Columns()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar (\n\t\tcol      string\n\t\tsqlType  string\n\t\tnullable string\n\t\textra    string\n\t)\n\tm := map[string]interface{}{\n\t\t\"Field\": &col,\n\t\t\"Type\":  &sqlType,\n\t\t\"Null\":  &nullable,\n\t\t\"Extra\": &extra,\n\t}\n\n\tvals := make([]interface{}, len(cols))\n\tfor i, n := range cols {\n\t\tif v, ok := m[n]; ok {\n\t\t\tvals[i] = v\n\t\t} else {\n\t\t\tvals[i] = &sql.RawBytes{}\n\t\t}\n\t}\n\n\tfor rows.Next() {\n\t\terr := rows.Scan(vals...)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc := &Column{\n\t\t\tName:     col,\n\t\t\tNullable: strings.EqualFold(nullable, \"YES\"),\n\t\t\tAutoIncr: strings.Contains(extra, \"auto_increment\"),\n\t\t\tsqlType:  sqlType,\n\t\t}\n\t\tt.Columns = append(t.Columns, c)\n\t\tt.ColumnMap[c.Name] = c\n\t}\n\treturn nil\n}\n\nfunc (t *Table) tableExpr() TableExpr {\n\tate := &AliasedTableExpr{\n\t\tExpr: &TableName{Name: t.Name},\n\t}\n\tif t.Alias != \"\" {\n\t\tate.As = t.Alias\n\t}\n\tif t.IndexHints != nil {\n\t\tate.Hints = t.IndexHints\n\t}\n\n\treturn ate\n}\n\nfunc (t *Table) tableExists(name string) bool {\n\treturn t.Name == name\n}\n\nfunc (t *Table) column(name string) *ColName {\n\tparts := strings.Split(name, \".\")\n\tif len(parts) == 2 {\n\t\tif parts[0] != t.Name {\n\t\t\treturn nil\n\t\t}\n\t\tname = parts[1]\n\t}\n\tif _, ok := t.ColumnMap[name]; !ok {\n\t\treturn nil\n\t}\n\treturn &ColName{Name: name, Qualifier: t.Name}\n}\n\nfunc (t *Table) columnCount(name string) int {\n\tif _, ok := t.ColumnMap[name]; !ok {\n\t\treturn 0\n\t}\n\treturn 1\n}\n\n// loadKeys loads a table's keys (indexes) from a database. MySQL\n// specific.\nfunc (t *Table) loadKeys(db *sql.DB) error {\n\trows, err := db.Query(\"SHOW INDEX FROM \" + quoteNameStr(t.Name))\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer rows.Close()\n\n\tcols, err := rows.Columns()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar (\n\t\tnonUnique bool\n\t\tkeyName   string\n\t\tseq       int\n\t\tcolName   string\n\t)\n\tm := map[string]interface{}{\n\t\t\"Non_unique\":   &nonUnique,\n\t\t\"Key_name\":     &keyName,\n\t\t\"Seq_in_index\": &seq,\n\t\t\"Column_name\":  &colName,\n\t}\n\n\tvals := make([]interface{}, len(cols))\n\tfor i, n := range cols {\n\t\tif v, ok := m[n]; ok {\n\t\t\tvals[i] = v\n\t\t} else {\n\t\t\tvals[i] = &sql.RawBytes{}\n\t\t}\n\t}\n\n\tkeys := map[string][]keyColumn{}\n\tfor rows.Next() {\n\t\terr := rows.Scan(vals...)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tkeys[keyName] = append(keys[keyName], keyColumn{\n\t\t\tseq:  seq,\n\t\t\tname: colName,\n\t\t})\n\n\t\tif _, ok := t.KeyMap[keyName]; !ok {\n\t\t\tk := &Key{\n\t\t\t\tName:   keyName,\n\t\t\t\tUnique: !nonUnique,\n\t\t\t}\n\t\t\tt.Keys = append(t.Keys, k)\n\t\t\tt.KeyMap[keyName] = k\n\t\t}\n\t}\n\n\tfor n, k := range keys {\n\t\tsort.Sort(bySeq(k))\n\t\tvar cols []*Column\n\t\tfor _, c := range k {\n\t\t\tcols = append(cols, t.ColumnMap[c.name])\n\t\t}\n\t\tt.KeyMap[n].Columns = cols\n\t}\n\n\tt.PrimaryKey = t.KeyMap[\"PRIMARY\"]\n\tif t.PrimaryKey != nil {\n\t\tt.PrimaryKey.Primary = true\n\t}\n\n\treturn nil\n}\n", "// Copyright 2014 Square Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage squalor\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc mustLoadTable(t *testing.T, name string) *Table {\n\tdb := makeTestDB(t, objectsDDL)\n\tdefer db.Close()\n\n\ttable, err := LoadTable(db.DB, name)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn table\n}\n\nfunc TestLoadTable(t *testing.T) {\n\ttable := mustLoadTable(t, \"objects\")\n\tfmt.Printf(\"%s\\n\", table)\n}\n\nfunc TestLoadTableNameInjection(t *testing.T) {\n\tdb := makeTestDB(t, objectsDDL)\n\tdefer db.Close()\n\n\t// Ensure the table name is quoted to avoid possible SQL injection.\n\ttable, err := LoadTable(db.DB, \"objects WHERE false\")\n\tif table != nil {\n\t\tt.Fatalf(\"Expected nil table returned from injection attempt, got %v\", table)\n\t}\n\texpectedError := \"Error 1146: Table 'squalor_test.objects where false' doesn't exist\"\n\tif err == nil {\n\t\tt.Fatalf(\"Expected error %q from injection attempt, got nil\", expectedError)\n\t}\n\tif err.Error() != expectedError {\n\t\tt.Fatalf(\"Expected error %q from injection attempt, got %q\", expectedError, err.Error())\n\t}\n\n\t// Ensure the table name is quoted to avoid possible SQL injection.\n\ttable, err = LoadTable(db.DB, \"foo`;bar\")\n\tif table != nil {\n\t\tt.Fatalf(\"Expected nil table returned from injection attempt, got %v\", table)\n\t}\n\texpectedError = \"Error 1146: Table 'squalor_test.foo`;bar' doesn't exist\"\n\tif err == nil {\n\t\tt.Fatalf(\"Expected error %q from injection attempt, got nil\", expectedError)\n\t}\n\tif err.Error() != expectedError {\n\t\tt.Fatalf(\"Expected error %q from injection attempt, got %q\", expectedError, err.Error())\n\t}\n}\n\nfunc TestGetKey(t *testing.T) {\n\ttable := mustLoadTable(t, \"objects\")\n\n\ttestCases := []struct {\n\t\tcols   []string\n\t\tresult bool\n\t}{\n\t\t{[]string{\"user_id\", \"object_id\"}, true},\n\t\t{[]string{\"USER_ID\", \"object_id\"}, false},\n\t\t{[]string{\"user_id\", \"timestamp\"}, true},\n\t\t{[]string{\"timestamp\", \"user_id\"}, false},\n\t}\n\tfor _, c := range testCases {\n\t\tkey := table.GetKey(c.cols...)\n\t\tif c.result && key == nil {\n\t\t\tt.Errorf(\"Unable to find key (%s)\", strings.Join(c.cols, \",\"))\n\t\t} else if !c.result && key != nil {\n\t\t\tt.Errorf(\"Expected to not find key, but got %s\", key)\n\t\t}\n\t}\n}\n\nfunc TestValidateModel(t *testing.T) {\n\ttable := mustLoadTable(t, \"objects\")\n\n\ttype BaseModel struct {\n\t\tUserID    int64  `db:\"user_id\"`\n\t\tID        string `db:\"object_id\"`\n\t\tTimestamp int64  `db:\"timestamp\"`\n\t}\n\n\ttype ObjectModel struct {\n\t\tBaseModel\n\t\tValue   string `db:\"value\"`\n\t\tIgnored int    `db:\"-\"`\n\t\tignored int\n\t}\n\n\tif err := table.ValidateModel(ObjectModel{}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// BaseModel doesn't map all of the table's columns.\n\tif err := table.ValidateModel(BaseModel{}); err == nil {\n\t\tt.Fatal(\"Expected failure, but found success\")\n\t}\n\n\ttype BadModel struct {\n\t\tObjectModel\n\t\tExtra string `db:\"extra\"`\n\t}\n\n\t// BadModel maps columns that are not in the table.\n\tif err := table.ValidateModel(BadModel{}); err == nil {\n\t\tt.Fatal(\"Expected failure, but found success\")\n\t}\n}\n"], "filenames": ["ast.go", "table.go", "table_test.go"], "buggy_code_start_loc": [14, 357, 36], "buggy_code_end_loc": [1137, 454, 36], "fixing_code_start_loc": [15, 358, 37], "fixing_code_end_loc": [1142, 459, 68], "type": "CWE-89", "message": "A vulnerability, which was classified as critical, was found in square squalor. This affects an unknown part. The manipulation leads to sql injection. Upgrading to version v0.0.0 is able to address this issue. The name of the patch is f6f0a47cc344711042eb0970cb423e6950ba3f93. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-217623.", "other": {"cve": {"id": "CVE-2020-36645", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-07T19:15:09.383", "lastModified": "2023-01-12T18:40:31.593", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as critical, was found in square squalor. This affects an unknown part. The manipulation leads to sql injection. Upgrading to version v0.0.0 is able to address this issue. The name of the patch is f6f0a47cc344711042eb0970cb423e6950ba3f93. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-217623."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.1, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:square:squalor:-:*:*:*:*:go:*:*", "matchCriteriaId": "CB0806B0-7DBC-4EB8-BDE2-089712486879"}]}]}], "references": [{"url": "https://github.com/square/squalor/commit/f6f0a47cc344711042eb0970cb423e6950ba3f93", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/square/squalor/pull/76", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/square/squalor/releases/tag/v0.0.0", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217623", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217623", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/square/squalor/commit/f6f0a47cc344711042eb0970cb423e6950ba3f93"}}