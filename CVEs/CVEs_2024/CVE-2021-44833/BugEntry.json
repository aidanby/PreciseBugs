{"buggy_code": ["/*\n * SPDX-License-Identifier: Apache-2.0\n *\n * The OpenSearch Contributors require contributions made to\n * this file be licensed under the Apache-2.0 license or a\n * compatible open source license.\n *\n * Modifications Copyright OpenSearch Contributors. See\n * GitHub history for details.\n */\n/*\n * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\").\n * You may not use this file except in compliance with the License.\n * A copy of the License is located at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed\n * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n * express or implied. See the License for the specific language governing\n * permissions and limitations under the License.\n */\n\npackage commands\n\nimport (\n\t\"fmt\"\n\t\"opensearch-cli/entity\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\n\t\"github.com/spf13/cobra\"\n)\n\nconst (\n\tconfigFileType        = \"yaml\"\n\tdefaultConfigFileName = \"config\"\n\tflagConfig            = \"config\"\n\tflagProfileName       = \"profile\"\n\tfolderPermission      = 0755 // only owner can write, while everyone can read and execute\n\tConfigEnvVarName      = \"OPENSEARCH_CLI_CONFIG\"\n\tRootCommandName       = \"opensearch-cli\"\n\tversion               = \"1.0.0\"\n)\n\nfunc buildVersionString() string {\n\n\treturn fmt.Sprintf(\"%s %s/%s\", version, runtime.GOOS, runtime.GOARCH)\n}\n\nvar rootCommand = &cobra.Command{\n\tUse:     RootCommandName,\n\tShort:   \"opensearch-cli is a unified command line interface for managing OpenSearch clusters\",\n\tVersion: buildVersionString(),\n}\n\nfunc GetRoot() *cobra.Command {\n\treturn rootCommand\n}\n\n// Execute executes the root command.\nfunc Execute() error {\n\terr := rootCommand.Execute()\n\treturn err\n}\n\nfunc GetDefaultConfigFilePath() string {\n\treturn filepath.Join(\n\t\tgetDefaultConfigFolderRootPath(),\n\t\tfmt.Sprintf(\".%s\", RootCommandName),\n\t\tfmt.Sprintf(\"%s.%s\", defaultConfigFileName, configFileType),\n\t)\n}\n\nfunc getDefaultConfigFolderRootPath() string {\n\tif homeDir, err := os.UserHomeDir(); err == nil {\n\t\treturn homeDir\n\t}\n\tif cwd, err := os.Getwd(); err == nil {\n\t\treturn cwd\n\t}\n\treturn \"\"\n}\n\nfunc init() {\n\tcobra.OnInitialize()\n\tconfigFilePath := GetDefaultConfigFilePath()\n\trootCommand.PersistentFlags().StringP(flagConfig, \"c\", \"\", fmt.Sprintf(\"Configuration file for opensearch-cli, default is %s\", configFilePath))\n\trootCommand.PersistentFlags().StringP(flagProfileName, \"p\", \"\", \"Use a specific profile from your configuration file\")\n\trootCommand.Flags().BoolP(\"version\", \"v\", false, \"Version for opensearch-cli\")\n\trootCommand.Flags().BoolP(\"help\", \"h\", false, \"Help for opensearch-cli\")\n}\n\n// GetConfigFilePath gets config file path for execution\nfunc GetConfigFilePath(configFlagValue string) (string, error) {\n\n\tif configFlagValue != \"\" {\n\t\treturn configFlagValue, nil\n\t}\n\tif value, ok := os.LookupEnv(ConfigEnvVarName); ok {\n\t\treturn value, nil\n\t}\n\tif err := createDefaultConfigFileIfNotExists(); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn GetDefaultConfigFilePath(), nil\n}\n\n// createDefaultConfigFolderIfNotExists creates default config file along with folder if\n// it doesn't exists\nfunc createDefaultConfigFileIfNotExists() error {\n\tdefaultFilePath := GetDefaultConfigFilePath()\n\tif isExists(defaultFilePath) {\n\t\treturn nil\n\t}\n\tfolderPath := filepath.Dir(defaultFilePath)\n\tif !isExists(folderPath) {\n\t\terr := os.Mkdir(folderPath, folderPermission)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tf, err := os.Create(defaultFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn f.Close()\n}\n\n//isExists check if given path exists or not\n//if path is just a name, it will check in current directory\nfunc isExists(path string) bool {\n\tif _, err := os.Stat(path); os.IsNotExist(err) {\n\t\treturn false\n\t}\n\treturn true\n}\n\n// DisplayError prints command name and error on console and exists as well.\nfunc DisplayError(err error, cmdName string) {\n\tif err != nil {\n\t\tfmt.Println(cmdName, \"Command failed.\")\n\t\tfmt.Println(\"Reason:\", err)\n\t}\n}\n\n// GetProfile gets profile details for current execution\nfunc GetProfile() (*entity.Profile, error) {\n\tp, err := GetProfileController()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tprofileFlagValue, err := rootCommand.PersistentFlags().GetString(flagProfileName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tprofile, ok, err := p.GetProfileForExecution(profileFlagValue)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"no profile found for execution. Try %s %s --help for more information\", RootCommandName, ProfileCommandName)\n\t}\n\treturn &profile, nil\n}\n"], "fixing_code": ["/*\n * SPDX-License-Identifier: Apache-2.0\n *\n * The OpenSearch Contributors require contributions made to\n * this file be licensed under the Apache-2.0 license or a\n * compatible open source license.\n *\n * Modifications Copyright OpenSearch Contributors. See\n * GitHub history for details.\n */\n/*\n * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\").\n * You may not use this file except in compliance with the License.\n * A copy of the License is located at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed\n * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n * express or implied. See the License for the specific language governing\n * permissions and limitations under the License.\n */\n\npackage commands\n\nimport (\n\t\"fmt\"\n\t\"opensearch-cli/entity\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\n\t\"github.com/spf13/cobra\"\n)\n\nconst (\n\tconfigFileType        = \"yaml\"\n\tdefaultConfigFileName = \"config\"\n\tflagConfig            = \"config\"\n\tflagProfileName       = \"profile\"\n\tFolderPermission      = 0700 // only owner can read, write and execute\n\tFilePermission        = 0600 // only owner can read and write\n\tConfigEnvVarName      = \"OPENSEARCH_CLI_CONFIG\"\n\tRootCommandName       = \"opensearch-cli\"\n\tversion               = \"1.0.0\"\n)\n\nfunc buildVersionString() string {\n\n\treturn fmt.Sprintf(\"%s %s/%s\", version, runtime.GOOS, runtime.GOARCH)\n}\n\nvar rootCommand = &cobra.Command{\n\tUse:     RootCommandName,\n\tShort:   \"opensearch-cli is a unified command line interface for managing OpenSearch clusters\",\n\tVersion: buildVersionString(),\n}\n\nfunc GetRoot() *cobra.Command {\n\treturn rootCommand\n}\n\n// Execute executes the root command.\nfunc Execute() error {\n\terr := rootCommand.Execute()\n\treturn err\n}\n\nfunc GetDefaultConfigFilePath() string {\n\treturn filepath.Join(\n\t\tgetDefaultConfigFolderRootPath(),\n\t\tfmt.Sprintf(\".%s\", RootCommandName),\n\t\tfmt.Sprintf(\"%s.%s\", defaultConfigFileName, configFileType),\n\t)\n}\n\nfunc getDefaultConfigFolderRootPath() string {\n\tif homeDir, err := os.UserHomeDir(); err == nil {\n\t\treturn homeDir\n\t}\n\tif cwd, err := os.Getwd(); err == nil {\n\t\treturn cwd\n\t}\n\treturn \"\"\n}\n\nfunc init() {\n\tcobra.OnInitialize()\n\tconfigFilePath := GetDefaultConfigFilePath()\n\trootCommand.PersistentFlags().StringP(flagConfig, \"c\", \"\", fmt.Sprintf(\"Configuration file for opensearch-cli, default is %s\", configFilePath))\n\trootCommand.PersistentFlags().StringP(flagProfileName, \"p\", \"\", \"Use a specific profile from your configuration file\")\n\trootCommand.Flags().BoolP(\"version\", \"v\", false, \"Version for opensearch-cli\")\n\trootCommand.Flags().BoolP(\"help\", \"h\", false, \"Help for opensearch-cli\")\n}\n\n// GetConfigFilePath gets config file path for execution\nfunc GetConfigFilePath(configFlagValue string) (string, error) {\n\n\tif configFlagValue != \"\" {\n\t\treturn configFlagValue, nil\n\t}\n\tif value, ok := os.LookupEnv(ConfigEnvVarName); ok {\n\t\treturn value, nil\n\t}\n\tif err := createDefaultConfigFileIfNotExists(); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn GetDefaultConfigFilePath(), nil\n}\n\n// createDefaultConfigFolderIfNotExists creates default config file along with folder if\n// it doesn't exists\nfunc createDefaultConfigFileIfNotExists() error {\n\tdefaultFilePath := GetDefaultConfigFilePath()\n\tif isExists(defaultFilePath) {\n\t\treturn nil\n\t}\n\tfolderPath := filepath.Dir(defaultFilePath)\n\tif !isExists(folderPath) {\n\t\terr := os.Mkdir(folderPath, FolderPermission)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tf, err := os.Create(defaultFilePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err = f.Chmod(FilePermission); err != nil {\n\t\treturn err\n\t}\n\treturn f.Close()\n}\n\n//isExists check if given path exists or not\n//if path is just a name, it will check in current directory\nfunc isExists(path string) bool {\n\tif _, err := os.Stat(path); os.IsNotExist(err) {\n\t\treturn false\n\t}\n\treturn true\n}\n\n// DisplayError prints command name and error on console and exists as well.\nfunc DisplayError(err error, cmdName string) {\n\tif err != nil {\n\t\tfmt.Println(cmdName, \"Command failed.\")\n\t\tfmt.Println(\"Reason:\", err)\n\t}\n}\n\n// GetProfile gets profile details for current execution\nfunc GetProfile() (*entity.Profile, error) {\n\tp, err := GetProfileController()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tprofileFlagValue, err := rootCommand.PersistentFlags().GetString(flagProfileName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tprofile, ok, err := p.GetProfileForExecution(profileFlagValue)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"no profile found for execution. Try %s %s --help for more information\", RootCommandName, ProfileCommandName)\n\t}\n\treturn &profile, nil\n}\n"], "filenames": ["commands/root.go"], "buggy_code_start_loc": [43], "buggy_code_end_loc": [127], "fixing_code_start_loc": [43], "fixing_code_end_loc": [132], "type": "CWE-276", "message": "The CLI 1.0.0 for Amazon AWS OpenSearch has weak permissions for the configuration file.", "other": {"cve": {"id": "CVE-2021-44833", "sourceIdentifier": "cve@mitre.org", "published": "2021-12-12T06:15:06.993", "lastModified": "2021-12-15T15:57:26.783", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The CLI 1.0.0 for Amazon AWS OpenSearch has weak permissions for the configuration file."}, {"lang": "es", "value": "El CLI 1.0.0 para Amazon AWS OpenSearch presenta permisos d\u00e9biles para el archivo de configuraci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-276"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:amazon:aws_opensearch:1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "0676E964-45EC-4603-BB2A-3D4401B24FE4"}]}]}], "references": [{"url": "https://github.com/opensearch-project/opensearch-cli/blob/275085730f791daccaac81c566a25f541656d9f9/commands/root.go#L43", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/opensearch-project/opensearch-cli/commit/69dc712d0d0d05dc2bc2bd0d733c73e3641b633a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/opensearch-project/opensearch-cli/commit/69dc712d0d0d05dc2bc2bd0d733c73e3641b633a"}}