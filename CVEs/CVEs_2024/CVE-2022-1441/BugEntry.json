{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/tools.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n\n\nGF_Box *gppc_box_new()\n{\n\t//default type is amr but overwritten by box constructor\n\tISOM_DECL_BOX_ALLOC(GF_3GPPConfigBox, GF_ISOM_BOX_TYPE_DAMR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid gppc_box_del(GF_Box *s)\n{\n\tGF_3GPPConfigBox *ptr = (GF_3GPPConfigBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err gppc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_3GPPConfigBox *ptr = (GF_3GPPConfigBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tmemset(&ptr->cfg, 0, sizeof(GF_3GPConfig));\n\n\tISOM_DECREASE_SIZE(s, 5)\n\tptr->cfg.vendor = gf_bs_read_u32(bs);\n\tptr->cfg.decoder_version = gf_bs_read_u8(bs);\n\n\tswitch (ptr->type) {\n\tcase GF_ISOM_BOX_TYPE_D263:\n\t\tISOM_DECREASE_SIZE(s, 2)\n\t\tptr->cfg.H263_level = gf_bs_read_u8(bs);\n\t\tptr->cfg.H263_profile = gf_bs_read_u8(bs);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DAMR:\n\t\tISOM_DECREASE_SIZE(s, 4)\n\t\tptr->cfg.AMR_mode_set = gf_bs_read_u16(bs);\n\t\tptr->cfg.AMR_mode_change_period = gf_bs_read_u8(bs);\n\t\tptr->cfg.frames_per_sample = gf_bs_read_u8(bs);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DEVC:\n\tcase GF_ISOM_BOX_TYPE_DQCP:\n\tcase GF_ISOM_BOX_TYPE_DSMV:\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->cfg.frames_per_sample = gf_bs_read_u8(bs);\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gppc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_3GPPConfigBox *ptr = (GF_3GPPConfigBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->cfg.vendor);\n\tgf_bs_write_u8(bs, ptr->cfg.decoder_version);\n\tswitch (ptr->cfg.type) {\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\tgf_bs_write_u8(bs, ptr->cfg.H263_level);\n\t\tgf_bs_write_u8(bs, ptr->cfg.H263_profile);\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\tgf_bs_write_u16(bs, ptr->cfg.AMR_mode_set);\n\t\tgf_bs_write_u8(bs, ptr->cfg.AMR_mode_change_period);\n\t\tgf_bs_write_u8(bs, ptr->cfg.frames_per_sample);\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\tgf_bs_write_u8(bs, ptr->cfg.frames_per_sample);\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gppc_box_size(GF_Box *s)\n{\n\tGF_3GPPConfigBox *ptr = (GF_3GPPConfigBox *)s;\n\n\ts->size += 5;\n\tif (!ptr->cfg.type) {\n\t\tswitch (ptr->type) {\n\t\tcase GF_ISOM_BOX_TYPE_D263:\n\t\t\tptr->cfg.type = GF_ISOM_SUBTYPE_3GP_H263;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DAMR:\n\t\t\tptr->cfg.type = GF_ISOM_SUBTYPE_3GP_AMR;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DEVC:\n\t\t\tptr->cfg.type = GF_ISOM_SUBTYPE_3GP_EVRC;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DQCP:\n\t\t\tptr->cfg.type = GF_ISOM_SUBTYPE_3GP_QCELP;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DSMV:\n\t\t\tptr->cfg.type = GF_ISOM_SUBTYPE_3GP_SMV;\n\t\t\tbreak;\n\t\t}\n\t}\n\tswitch (ptr->cfg.type) {\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\ts->size += 2;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\ts->size += 4;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\ts->size += 1;\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *ftab_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FontTableBox, GF_ISOM_BOX_TYPE_FTAB);\n\treturn (GF_Box *) tmp;\n}\nvoid ftab_box_del(GF_Box *s)\n{\n\tGF_FontTableBox *ptr = (GF_FontTableBox *)s;\n\tif (ptr->fonts) {\n\t\tu32 i;\n\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\tif (ptr->fonts[i].fontName) gf_free(ptr->fonts[i].fontName);\n\t\tgf_free(ptr->fonts);\n\t}\n\tgf_free(ptr);\n}\nGF_Err ftab_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_FontTableBox *ptr = (GF_FontTableBox *)s;\n\tptr->entry_count = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(ptr, 2);\n\n\tif (ptr->size<ptr->entry_count*3) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Corrupted ftap box, skipping\\n\"));\n\t\tptr->entry_count = 0;\n\t\treturn GF_OK;\n\t}\n\tptr->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord)*ptr->entry_count);\n\tif (!ptr->fonts) return GF_OUT_OF_MEM;\n\n\tmemset(ptr->fonts, 0, sizeof(GF_FontRecord)*ptr->entry_count);\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tu32 len;\n\t\tISOM_DECREASE_SIZE(ptr, 3);\n\t\tptr->fonts[i].fontID = gf_bs_read_u16(bs);\n\t\tlen = gf_bs_read_u8(bs);\n\t\tif (len) {\n\t\t\tISOM_DECREASE_SIZE(ptr, len);\n\t\t\tptr->fonts[i].fontName = (char *)gf_malloc(sizeof(char)*(len+1));\n\t\t\tif (!ptr->fonts[i].fontName) return GF_OUT_OF_MEM;\n\t\t\tgf_bs_read_data(bs, ptr->fonts[i].fontName, len);\n\t\t\tptr->fonts[i].fontName[len] = 0;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err ftab_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_FontTableBox *ptr = (GF_FontTableBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->entry_count);\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tgf_bs_write_u16(bs, ptr->fonts[i].fontID);\n\t\tif (ptr->fonts[i].fontName) {\n\t\t\tu32 len = (u32) strlen(ptr->fonts[i].fontName);\n\t\t\tgf_bs_write_u8(bs, len);\n\t\t\tgf_bs_write_data(bs, ptr->fonts[i].fontName, len);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t}\n\treturn GF_OK;\n}\nGF_Err ftab_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_FontTableBox *ptr = (GF_FontTableBox *)s;\n\n\ts->size += 2;\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\ts->size += 3;\n\t\tif (ptr->fonts[i].fontName) s->size += strlen(ptr->fonts[i].fontName);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *text_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextSampleEntryBox, GF_ISOM_BOX_TYPE_TEXT);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox *)tmp);\n\treturn (GF_Box *) tmp;\n}\n\nvoid text_box_del(GF_Box *s)\n{\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->textName)\n\t\tgf_free(ptr->textName);\n\tgf_free(ptr);\n}\n\nGF_Box *tx3g_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Tx3gSampleEntryBox, GF_ISOM_BOX_TYPE_TX3G);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox *)tmp);\n\treturn (GF_Box *) tmp;\n}\n\nvoid tx3g_box_del(GF_Box *s)\n{\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tgf_free(s);\n}\n\nu32 gpp_read_rgba(GF_BitStream *bs)\n{\n\tu8 r, g, b, a;\n\tu32 col;\n\tr = gf_bs_read_u8(bs);\n\tg = gf_bs_read_u8(bs);\n\tb = gf_bs_read_u8(bs);\n\ta = gf_bs_read_u8(bs);\n\tcol = a;\n\tcol<<=8;\n\tcol |= r;\n\tcol<<=8;\n\tcol |= g;\n\tcol<<=8;\n\tcol |= b;\n\treturn col;\n}\n\n#define GPP_BOX_SIZE\t8\nvoid gpp_read_box(GF_BitStream *bs, GF_BoxRecord *rec)\n{\n\trec->top = gf_bs_read_u16(bs);\n\trec->left = gf_bs_read_u16(bs);\n\trec->bottom = gf_bs_read_u16(bs);\n\trec->right = gf_bs_read_u16(bs);\n}\n\n#define GPP_STYLE_SIZE\t12\nvoid gpp_read_style(GF_BitStream *bs, GF_StyleRecord *rec)\n{\n\trec->startCharOffset = gf_bs_read_u16(bs);\n\trec->endCharOffset = gf_bs_read_u16(bs);\n\trec->fontID = gf_bs_read_u16(bs);\n\trec->style_flags = gf_bs_read_u8(bs);\n\trec->font_size = gf_bs_read_u8(bs);\n\trec->text_color = gpp_read_rgba(bs);\n}\n\nGF_Err tx3g_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_Tx3gSampleEntryBox *ptr = (GF_Tx3gSampleEntryBox*)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_FTAB:\n\t\tBOX_FIELD_ASSIGN(font_table, GF_FontTableBox)\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tx3g_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_Tx3gSampleEntryBox *ptr = (GF_Tx3gSampleEntryBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, (18 + GPP_BOX_SIZE + GPP_STYLE_SIZE) );\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\n\tptr->displayFlags = gf_bs_read_u32(bs);\n\tptr->horizontal_justification = gf_bs_read_u8(bs);\n\tptr->vertical_justification = gf_bs_read_u8(bs);\n\tptr->back_color = gpp_read_rgba(bs);\n\tgpp_read_box(bs, &ptr->default_box);\n\tgpp_read_style(bs, &ptr->default_style);\n\n\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n/*this is a quicktime specific box - see apple documentation*/\nGF_Err text_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu16 pSize;\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\n\tptr->textJustification = 1;\n\n\t//some weird text entries are not QT text nor 3gpp, cf issue #1030\n\tif (!ptr->size) {\n\t\treturn GF_OK;\n\t}\n\tif (ptr->size < 43) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Broken text box (%d bytes but min 43 required), skiping parsing.\\n\", ptr->size));\n\t\treturn GF_OK;\n\t}\n\tISOM_DECREASE_SIZE(ptr, 43);\n\n\tptr->displayFlags = gf_bs_read_u32(bs);\t\t\t/*Display flags*/\n\tptr->textJustification = gf_bs_read_u32(bs);\t/*Text justification*/\n\tgf_bs_read_data(bs, ptr->background_color, 6);\t/*Background color*/\n\tgpp_read_box(bs, &ptr->default_box);\t\t\t/*Default text box*/\n\tgf_bs_read_data(bs, ptr->reserved1, 8);\t\t\t/*Reserved*/\n\tptr->fontNumber = gf_bs_read_u16(bs);\t\t\t/*Font number*/\n\tptr->fontFace   = gf_bs_read_u16(bs);\t\t\t/*Font face*/\n\tptr->reserved2  = gf_bs_read_u8(bs);\t\t\t/*Reserved*/\n\tptr->reserved3  = gf_bs_read_u16(bs);\t\t\t/*Reserved*/\n\tgf_bs_read_data(bs, ptr->foreground_color, 6);\t/*Foreground color*/\n\n\t/*ffmpeg compatibility with iPod streams: no pascal string*/\n\tif (!ptr->size)\n\t\treturn GF_OK;\n\n\tISOM_DECREASE_SIZE(ptr, 1);\n\tpSize = gf_bs_read_u8(bs); /*a Pascal string begins with its size: get textName size*/\n\n\tif (ptr->size < pSize) {\n\t\tu32 b_size = pSize;\n\t\tsize_t i = 0;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] text box doesn't use a Pascal string: trying to decode anyway.\\n\"));\n\t\tptr->textName = (char*)gf_malloc((size_t)ptr->size + 1 + 1);\n\t\tif (!ptr->textName) return GF_OUT_OF_MEM;\n\n\t\tdo {\n\t\t\tchar c = (char)b_size;\n\t\t\tif (c == '\\0') {\n\t\t\t\tbreak;\n\t\t\t} else if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n\t\t\t\tptr->textName[i] = c;\n\t\t\t} else {\n\t\t\t\tgf_free(ptr->textName);\n\t\t\t\tptr->textName = NULL;\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] text box doesn't use a Pascal string and contains non-chars. Abort.\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif (!ptr->size)\n\t\t\t\tbreak;\n\t\t\tptr->size--;\n\t\t\tb_size = gf_bs_read_u8(bs);\n\t\t} while (b_size);\n\n\t\tptr->textName[i] = '\\0';\t\t\t\t/*Font name*/\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] text box doesn't use a Pascal string: \\\"%s\\\" detected.\\n\", ptr->textName));\n\t\treturn GF_OK;\n\t}\n\tif (pSize) {\n\t\tptr->textName = (char*) gf_malloc(pSize+1 * sizeof(char));\n\t\tif (!ptr->textName) return GF_OUT_OF_MEM;\n\n\t\tif (gf_bs_read_data(bs, ptr->textName, pSize) != pSize) {\n\t\t\tgf_free(ptr->textName);\n\t\t\tptr->textName = NULL;\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->textName[pSize] = '\\0';\t\t\t\t/*Font name*/\n\t}\n\tISOM_DECREASE_SIZE(ptr, pSize);\n\n\tu32 next_size = gf_bs_peek_bits(bs, 32, 0);\n\tif (next_size > ptr->size) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Broken text box detected, skiping parsing.\\n\"));\n\t\tptr->textJustification = 1;\n\t\treturn GF_OK;\n\t}\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nvoid gpp_write_rgba(GF_BitStream *bs, u32 col)\n{\n\tgf_bs_write_u8(bs, (col>>16) & 0xFF);\n\tgf_bs_write_u8(bs, (col>>8) & 0xFF);\n\tgf_bs_write_u8(bs, (col) & 0xFF);\n\tgf_bs_write_u8(bs, (col>>24) & 0xFF);\n}\n\nvoid gpp_write_box(GF_BitStream *bs, GF_BoxRecord *rec)\n{\n\tgf_bs_write_u16(bs, rec->top);\n\tgf_bs_write_u16(bs, rec->left);\n\tgf_bs_write_u16(bs, rec->bottom);\n\tgf_bs_write_u16(bs, rec->right);\n}\n\n#define GPP_STYLE_SIZE\t12\nvoid gpp_write_style(GF_BitStream *bs, GF_StyleRecord *rec)\n{\n\tgf_bs_write_u16(bs, rec->startCharOffset);\n\tgf_bs_write_u16(bs, rec->endCharOffset);\n\tgf_bs_write_u16(bs, rec->fontID);\n\tgf_bs_write_u8(bs, rec->style_flags);\n\tgf_bs_write_u8(bs, rec->font_size);\n\tgpp_write_rgba(bs, rec->text_color);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tx3g_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_Tx3gSampleEntryBox *ptr = (GF_Tx3gSampleEntryBox*)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\tgf_bs_write_u32(bs, ptr->displayFlags);\n\tgf_bs_write_u8(bs, ptr->horizontal_justification);\n\tgf_bs_write_u8(bs, ptr->vertical_justification);\n\tgpp_write_rgba(bs, ptr->back_color);\n\tgpp_write_box(bs, &ptr->default_box);\n\tgpp_write_style(bs, &ptr->default_style);\n\treturn GF_OK;\n}\n\nGF_Err text_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu16 pSize;\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\n\tgf_bs_write_u32(bs, ptr->displayFlags);\t\t\t/*Display flags*/\n\tgf_bs_write_u32(bs, ptr->textJustification);\t/*Text justification*/\n\tgf_bs_write_data(bs, ptr->background_color, 6);\t/*Background color*/\n\tgpp_write_box(bs, &ptr->default_box);\t\t\t/*Default text box*/\n\tgf_bs_write_data(bs, ptr->reserved1, 8);\t\t/*Reserved*/\n\tgf_bs_write_u16(bs, ptr->fontNumber);\t\t\t/*Font number*/\n\tgf_bs_write_u16(bs, ptr->fontFace);\t\t\t\t/*Font face*/\n\tgf_bs_write_u8(bs, ptr->reserved2);\t\t\t\t/*Reserved*/\n\tgf_bs_write_u16(bs, ptr->reserved3);\t\t\t/*Reserved*/\n\tgf_bs_write_data(bs, ptr->foreground_color, 6);\t/*Foreground color*/\n\t//pSize assignment below is not a mistake\n\tif (ptr->textName && (pSize = (u16) strlen(ptr->textName))) {\n\t\tgf_bs_write_u8(bs, pSize);\t\t\t\t\t/*a Pascal string begins with its size*/\n\t\tgf_bs_write_data(bs, ptr->textName, pSize);\t/*Font name*/\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tx3g_box_size(GF_Box *s)\n{\n\t/*base + this  + box + style*/\n\ts->size += 18 + GPP_BOX_SIZE + GPP_STYLE_SIZE;\n\treturn GF_OK;\n}\n\nGF_Err text_box_size(GF_Box *s)\n{\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\n\ts->size += 8;\n\t/*base + this + string length*/\n\ts->size += 43 + 1;\n\tif (ptr->textName)\n\t\ts->size += strlen(ptr->textName);\n\treturn GF_OK;\n}\n\n#endif\n\nGF_Box *styl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextStyleBox, GF_ISOM_BOX_TYPE_STYL);\n\treturn (GF_Box *) tmp;\n}\n\nvoid styl_box_del(GF_Box *s)\n{\n\tGF_TextStyleBox*ptr = (GF_TextStyleBox*)s;\n\tif (ptr->styles) gf_free(ptr->styles);\n\tgf_free(ptr);\n}\n\nGF_Err styl_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TextStyleBox*ptr = (GF_TextStyleBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->entry_count = gf_bs_read_u16(bs);\n\n\tif (ptr->size / GPP_STYLE_SIZE < ptr->entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tif (ptr->entry_count) {\n\t\tptr->styles = (GF_StyleRecord*)gf_malloc(sizeof(GF_StyleRecord)*ptr->entry_count);\n\t\tif (!ptr->styles) return GF_OUT_OF_MEM;\n\t\tfor (i=0; i<ptr->entry_count; i++) {\n\t\t\tISOM_DECREASE_SIZE(ptr, GPP_STYLE_SIZE);\n\t\t\tgpp_read_style(bs, &ptr->styles[i]);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err styl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TextStyleBox*ptr = (GF_TextStyleBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->entry_count);\n\tfor (i=0; i<ptr->entry_count; i++) gpp_write_style(bs, &ptr->styles[i]);\n\treturn GF_OK;\n}\n\nGF_Err styl_box_size(GF_Box *s)\n{\n\tGF_TextStyleBox*ptr = (GF_TextStyleBox*)s;\n\n\ts->size += 2 + ptr->entry_count * GPP_STYLE_SIZE;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *hlit_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextHighlightBox, GF_ISOM_BOX_TYPE_HLIT);\n\treturn (GF_Box *) tmp;\n}\n\nvoid hlit_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err hlit_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextHighlightBox *ptr = (GF_TextHighlightBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->startcharoffset = gf_bs_read_u16(bs);\n\tptr->endcharoffset = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err hlit_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TextHighlightBox *ptr = (GF_TextHighlightBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->startcharoffset);\n\tgf_bs_write_u16(bs, ptr->endcharoffset);\n\treturn GF_OK;\n}\n\nGF_Err hlit_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *hclr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextHighlightColorBox, GF_ISOM_BOX_TYPE_HCLR);\n\treturn (GF_Box *) tmp;\n}\n\nvoid hclr_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err hclr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextHighlightColorBox*ptr = (GF_TextHighlightColorBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->hil_color = gpp_read_rgba(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err hclr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TextHighlightColorBox*ptr = (GF_TextHighlightColorBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgpp_write_rgba(bs, ptr->hil_color);\n\treturn GF_OK;\n}\n\nGF_Err hclr_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *krok_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextKaraokeBox, GF_ISOM_BOX_TYPE_KROK);\n\treturn (GF_Box *) tmp;\n}\n\nvoid krok_box_del(GF_Box *s)\n{\n\tGF_TextKaraokeBox*ptr = (GF_TextKaraokeBox*)s;\n\tif (ptr->records) gf_free(ptr->records);\n\tgf_free(ptr);\n}\n\nGF_Err krok_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextKaraokeBox*ptr = (GF_TextKaraokeBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 6)\n\tptr->highlight_starttime = gf_bs_read_u32(bs);\n\tptr->nb_entries = gf_bs_read_u16(bs);\n\tif (ptr->size / 8 < ptr->nb_entries)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tif (ptr->nb_entries) {\n\t\tu32 i;\n\t\tptr->records = (KaraokeRecord*)gf_malloc(sizeof(KaraokeRecord)*ptr->nb_entries);\n\t\tif (!ptr->records) return GF_OUT_OF_MEM;\n\t\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tptr->records[i].highlight_endtime = gf_bs_read_u32(bs);\n\t\t\tptr->records[i].start_charoffset = gf_bs_read_u16(bs);\n\t\t\tptr->records[i].end_charoffset = gf_bs_read_u16(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err krok_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TextKaraokeBox*ptr = (GF_TextKaraokeBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->highlight_starttime);\n\tgf_bs_write_u16(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->records[i].highlight_endtime);\n\t\tgf_bs_write_u16(bs, ptr->records[i].start_charoffset);\n\t\tgf_bs_write_u16(bs, ptr->records[i].end_charoffset);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err krok_box_size(GF_Box *s)\n{\n\tGF_TextKaraokeBox*ptr = (GF_TextKaraokeBox*)s;\n\ts->size += 6 + 8*ptr->nb_entries;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *dlay_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextScrollDelayBox, GF_ISOM_BOX_TYPE_DLAY);\n\treturn (GF_Box *) tmp;\n}\n\nvoid dlay_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err dlay_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextScrollDelayBox*ptr = (GF_TextScrollDelayBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->scroll_delay = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dlay_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TextScrollDelayBox*ptr = (GF_TextScrollDelayBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->scroll_delay);\n\treturn GF_OK;\n}\n\nGF_Err dlay_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *href_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextHyperTextBox, GF_ISOM_BOX_TYPE_HREF);\n\treturn (GF_Box *) tmp;\n}\n\nvoid href_box_del(GF_Box *s)\n{\n\tGF_TextHyperTextBox*ptr = (GF_TextHyperTextBox*)s;\n\tif (ptr->URL) gf_free(ptr->URL);\n\tif (ptr->URL_hint) gf_free(ptr->URL_hint);\n\tgf_free(ptr);\n}\n\nGF_Err href_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 len;\n\tGF_TextHyperTextBox*ptr = (GF_TextHyperTextBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 6) //including 2 length fields\n\tptr->startcharoffset = gf_bs_read_u16(bs);\n\tptr->endcharoffset = gf_bs_read_u16(bs);\n\tlen = gf_bs_read_u8(bs);\n\tif (len) {\n\t\tISOM_DECREASE_SIZE(ptr, len)\n\t\tptr->URL = (char *) gf_malloc(sizeof(char) * (len+1));\n\t\tif (!ptr->URL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->URL, len);\n\t\tptr->URL[len] = 0;\n\t}\n\tlen = gf_bs_read_u8(bs);\n\tif (len) {\n\t\tISOM_DECREASE_SIZE(ptr, len)\n\t\tptr->URL_hint = (char *) gf_malloc(sizeof(char) * (len+1));\n\t\tif (!ptr->URL_hint) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->URL_hint, len);\n\t\tptr->URL_hint[len]= 0;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err href_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 len;\n\tGF_Err e;\n\tGF_TextHyperTextBox*ptr = (GF_TextHyperTextBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->startcharoffset);\n\tgf_bs_write_u16(bs, ptr->endcharoffset);\n\tif (ptr->URL) {\n\t\tlen = (u32) strlen(ptr->URL);\n\t\tgf_bs_write_u8(bs, len);\n\t\tgf_bs_write_data(bs, ptr->URL, len);\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\tif (ptr->URL_hint) {\n\t\tlen = (u32) strlen(ptr->URL_hint);\n\t\tgf_bs_write_u8(bs, len);\n\t\tgf_bs_write_data(bs, ptr->URL_hint, len);\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err href_box_size(GF_Box *s)\n{\n\tGF_TextHyperTextBox*ptr = (GF_TextHyperTextBox*)s;\n\ts->size += 6;\n\tif (ptr->URL) s->size += strlen(ptr->URL);\n\tif (ptr->URL_hint) s->size += strlen(ptr->URL_hint);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *tbox_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextBoxBox, GF_ISOM_BOX_TYPE_TBOX);\n\treturn (GF_Box *) tmp;\n}\n\nvoid tbox_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err tbox_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextBoxBox*ptr = (GF_TextBoxBox*)s;\n\tISOM_DECREASE_SIZE(ptr, GPP_BOX_SIZE)\n\tgpp_read_box(bs, &ptr->box);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tbox_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TextBoxBox*ptr = (GF_TextBoxBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgpp_write_box(bs, &ptr->box);\n\treturn GF_OK;\n}\n\nGF_Err tbox_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *blnk_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextBlinkBox, GF_ISOM_BOX_TYPE_BLNK);\n\treturn (GF_Box *) tmp;\n}\n\nvoid blnk_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err blnk_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextBlinkBox*ptr = (GF_TextBlinkBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->startcharoffset = gf_bs_read_u16(bs);\n\tptr->endcharoffset = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err blnk_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TextBlinkBox*ptr = (GF_TextBlinkBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->startcharoffset);\n\tgf_bs_write_u16(bs, ptr->endcharoffset);\n\treturn GF_OK;\n}\n\nGF_Err blnk_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *twrp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextWrapBox, GF_ISOM_BOX_TYPE_TWRP);\n\treturn (GF_Box *) tmp;\n}\n\nvoid twrp_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err twrp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextWrapBox*ptr = (GF_TextWrapBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->wrap_flag = gf_bs_read_u8(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err twrp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TextWrapBox*ptr = (GF_TextWrapBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->wrap_flag);\n\treturn GF_OK;\n}\nGF_Err twrp_box_size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid tsel_box_del(GF_Box *s)\n{\n\tGF_TrackSelectionBox *ptr;\n\tptr = (GF_TrackSelectionBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->attributeList) gf_free(ptr->attributeList);\n\tgf_free(ptr);\n}\n\nGF_Err tsel_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TrackSelectionBox *ptr = (GF_TrackSelectionBox *) s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->switchGroup = gf_bs_read_u32(bs);\n\n\tif (ptr->size % 4) return GF_ISOM_INVALID_FILE;\n\tptr->attributeListCount = (u32)ptr->size/4;\n\tptr->attributeList = gf_malloc(ptr->attributeListCount*sizeof(u32));\n\tif (ptr->attributeList == NULL) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i< ptr->attributeListCount; i++) {\n\t\tptr->attributeList[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *tsel_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackSelectionBox, GF_ISOM_BOX_TYPE_TSEL);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tsel_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackSelectionBox *ptr = (GF_TrackSelectionBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs,ptr->switchGroup);\n\n\tfor (i = 0; i < ptr->attributeListCount; i++ ) {\n\t\tgf_bs_write_u32(bs, ptr->attributeList[i]);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err tsel_box_size(GF_Box *s)\n{\n\tGF_TrackSelectionBox *ptr = (GF_TrackSelectionBox *) s;\n\tptr->size += 4 + (4*ptr->attributeListCount);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *dimC_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DIMSSceneConfigBox, GF_ISOM_BOX_TYPE_DIMC);\n\treturn (GF_Box *)tmp;\n}\nvoid dimC_box_del(GF_Box *s)\n{\n\tGF_DIMSSceneConfigBox *p = (GF_DIMSSceneConfigBox *)s;\n\tif (p->contentEncoding) gf_free(p->contentEncoding);\n\tif (p->textEncoding) gf_free(p->textEncoding);\n\tgf_free(p);\n}\n\nGF_Err dimC_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tchar str[1024];\n\tu32 i;\n\tGF_DIMSSceneConfigBox *p = (GF_DIMSSceneConfigBox *)s;\n\n\tISOM_DECREASE_SIZE(p, 3);\n\tp->profile = gf_bs_read_u8(bs);\n\tp->level = gf_bs_read_u8(bs);\n\tp->pathComponents = gf_bs_read_int(bs, 4);\n\tp->fullRequestHost = gf_bs_read_int(bs, 1);\n\tp->streamType = gf_bs_read_int(bs, 1);\n\tp->containsRedundant = gf_bs_read_int(bs, 2);\n\n\ti=0;\n\tstr[0]=0;\n\twhile (i < GF_ARRAY_LENGTH(str)) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\n\tp->textEncoding = gf_strdup(str);\n\n\ti=0;\n\tstr[0]=0;\n\twhile (i < GF_ARRAY_LENGTH(str)) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\n\tp->contentEncoding = gf_strdup(str);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dimC_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DIMSSceneConfigBox *p = (GF_DIMSSceneConfigBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, p->profile);\n\tgf_bs_write_u8(bs, p->level);\n\tgf_bs_write_int(bs, p->pathComponents, 4);\n\tgf_bs_write_int(bs, p->fullRequestHost, 1);\n\tgf_bs_write_int(bs, p->streamType, 1);\n\tgf_bs_write_int(bs, p->containsRedundant, 2);\n    if (p->textEncoding)\n        gf_bs_write_data(bs, p->textEncoding, (u32) strlen(p->textEncoding));\n    gf_bs_write_u8(bs, 0);\n    if (p->contentEncoding)\n        gf_bs_write_data(bs, p->contentEncoding, (u32) strlen(p->contentEncoding));\n    gf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\nGF_Err dimC_box_size(GF_Box *s)\n{\n\tGF_DIMSSceneConfigBox *p = (GF_DIMSSceneConfigBox *)s;\n    s->size += 3 + 2;\n    if (p->textEncoding) s->size += strlen(p->textEncoding);\n    if (p->contentEncoding) s->size += strlen(p->contentEncoding);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *diST_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DIMSScriptTypesBox, GF_ISOM_BOX_TYPE_DIST);\n\treturn (GF_Box *)tmp;\n}\nvoid diST_box_del(GF_Box *s)\n{\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\tif (p->content_script_types) gf_free(p->content_script_types);\n\tgf_free(p);\n}\n\nGF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tchar str[1024];\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\n\ti=0;\n\tstr[0]=0;\n\twhile (1) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\n\tp->content_script_types = gf_strdup(str);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err diST_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (p->content_script_types)\n\t\tgf_bs_write_data(bs, p->content_script_types, (u32) strlen(p->content_script_types)+1);\n\telse\n\t\tgf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\nGF_Err diST_box_size(GF_Box *s)\n{\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\ts->size += p->content_script_types ? (strlen(p->content_script_types)+1) : 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *dims_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DIMSSampleEntryBox, GF_ISOM_BOX_TYPE_DIMS);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox *)tmp);\n\treturn (GF_Box*)tmp;\n}\nvoid dims_box_del(GF_Box *s)\n{\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tgf_free(s);\n}\n\nGF_Err dims_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_DIMSSampleEntryBox *ptr = (GF_DIMSSampleEntryBox  *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_DIMC:\n\t\tBOX_FIELD_ASSIGN(config, GF_DIMSSceneConfigBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DIST:\n\t\tBOX_FIELD_ASSIGN(scripts, GF_DIMSScriptTypesBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\nGF_Err dims_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DIMSSampleEntryBox *p = (GF_DIMSSampleEntryBox *)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)p, bs);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(p, 8);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dims_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DIMSSampleEntryBox *p = (GF_DIMSSampleEntryBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, p->reserved, 6);\n\tgf_bs_write_u16(bs, p->dataReferenceIndex);\n\treturn GF_OK;\n}\n\nGF_Err dims_box_size(GF_Box *s)\n{\n\tu32 pos = 0;\n\tGF_DIMSSampleEntryBox *p = (GF_DIMSSampleEntryBox *)s;\n\ts->size += 8;\n\tgf_isom_check_position(s, (GF_Box *) p->config, &pos);\n\tgf_isom_check_position(s, (GF_Box *) p->scripts, &pos);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/tools.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n\n\nGF_Box *gppc_box_new()\n{\n\t//default type is amr but overwritten by box constructor\n\tISOM_DECL_BOX_ALLOC(GF_3GPPConfigBox, GF_ISOM_BOX_TYPE_DAMR);\n\treturn (GF_Box *)tmp;\n}\n\nvoid gppc_box_del(GF_Box *s)\n{\n\tGF_3GPPConfigBox *ptr = (GF_3GPPConfigBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err gppc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_3GPPConfigBox *ptr = (GF_3GPPConfigBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tmemset(&ptr->cfg, 0, sizeof(GF_3GPConfig));\n\n\tISOM_DECREASE_SIZE(s, 5)\n\tptr->cfg.vendor = gf_bs_read_u32(bs);\n\tptr->cfg.decoder_version = gf_bs_read_u8(bs);\n\n\tswitch (ptr->type) {\n\tcase GF_ISOM_BOX_TYPE_D263:\n\t\tISOM_DECREASE_SIZE(s, 2)\n\t\tptr->cfg.H263_level = gf_bs_read_u8(bs);\n\t\tptr->cfg.H263_profile = gf_bs_read_u8(bs);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DAMR:\n\t\tISOM_DECREASE_SIZE(s, 4)\n\t\tptr->cfg.AMR_mode_set = gf_bs_read_u16(bs);\n\t\tptr->cfg.AMR_mode_change_period = gf_bs_read_u8(bs);\n\t\tptr->cfg.frames_per_sample = gf_bs_read_u8(bs);\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DEVC:\n\tcase GF_ISOM_BOX_TYPE_DQCP:\n\tcase GF_ISOM_BOX_TYPE_DSMV:\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->cfg.frames_per_sample = gf_bs_read_u8(bs);\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err gppc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_3GPPConfigBox *ptr = (GF_3GPPConfigBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->cfg.vendor);\n\tgf_bs_write_u8(bs, ptr->cfg.decoder_version);\n\tswitch (ptr->cfg.type) {\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\tgf_bs_write_u8(bs, ptr->cfg.H263_level);\n\t\tgf_bs_write_u8(bs, ptr->cfg.H263_profile);\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\tgf_bs_write_u16(bs, ptr->cfg.AMR_mode_set);\n\t\tgf_bs_write_u8(bs, ptr->cfg.AMR_mode_change_period);\n\t\tgf_bs_write_u8(bs, ptr->cfg.frames_per_sample);\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\tgf_bs_write_u8(bs, ptr->cfg.frames_per_sample);\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gppc_box_size(GF_Box *s)\n{\n\tGF_3GPPConfigBox *ptr = (GF_3GPPConfigBox *)s;\n\n\ts->size += 5;\n\tif (!ptr->cfg.type) {\n\t\tswitch (ptr->type) {\n\t\tcase GF_ISOM_BOX_TYPE_D263:\n\t\t\tptr->cfg.type = GF_ISOM_SUBTYPE_3GP_H263;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DAMR:\n\t\t\tptr->cfg.type = GF_ISOM_SUBTYPE_3GP_AMR;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DEVC:\n\t\t\tptr->cfg.type = GF_ISOM_SUBTYPE_3GP_EVRC;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DQCP:\n\t\t\tptr->cfg.type = GF_ISOM_SUBTYPE_3GP_QCELP;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DSMV:\n\t\t\tptr->cfg.type = GF_ISOM_SUBTYPE_3GP_SMV;\n\t\t\tbreak;\n\t\t}\n\t}\n\tswitch (ptr->cfg.type) {\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\ts->size += 2;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\ts->size += 4;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\ts->size += 1;\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *ftab_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_FontTableBox, GF_ISOM_BOX_TYPE_FTAB);\n\treturn (GF_Box *) tmp;\n}\nvoid ftab_box_del(GF_Box *s)\n{\n\tGF_FontTableBox *ptr = (GF_FontTableBox *)s;\n\tif (ptr->fonts) {\n\t\tu32 i;\n\t\tfor (i=0; i<ptr->entry_count; i++)\n\t\t\tif (ptr->fonts[i].fontName) gf_free(ptr->fonts[i].fontName);\n\t\tgf_free(ptr->fonts);\n\t}\n\tgf_free(ptr);\n}\nGF_Err ftab_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_FontTableBox *ptr = (GF_FontTableBox *)s;\n\tptr->entry_count = gf_bs_read_u16(bs);\n\tISOM_DECREASE_SIZE(ptr, 2);\n\n\tif (ptr->size<ptr->entry_count*3) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Corrupted ftap box, skipping\\n\"));\n\t\tptr->entry_count = 0;\n\t\treturn GF_OK;\n\t}\n\tptr->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord)*ptr->entry_count);\n\tif (!ptr->fonts) return GF_OUT_OF_MEM;\n\n\tmemset(ptr->fonts, 0, sizeof(GF_FontRecord)*ptr->entry_count);\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tu32 len;\n\t\tISOM_DECREASE_SIZE(ptr, 3);\n\t\tptr->fonts[i].fontID = gf_bs_read_u16(bs);\n\t\tlen = gf_bs_read_u8(bs);\n\t\tif (len) {\n\t\t\tISOM_DECREASE_SIZE(ptr, len);\n\t\t\tptr->fonts[i].fontName = (char *)gf_malloc(sizeof(char)*(len+1));\n\t\t\tif (!ptr->fonts[i].fontName) return GF_OUT_OF_MEM;\n\t\t\tgf_bs_read_data(bs, ptr->fonts[i].fontName, len);\n\t\t\tptr->fonts[i].fontName[len] = 0;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err ftab_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_FontTableBox *ptr = (GF_FontTableBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->entry_count);\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tgf_bs_write_u16(bs, ptr->fonts[i].fontID);\n\t\tif (ptr->fonts[i].fontName) {\n\t\t\tu32 len = (u32) strlen(ptr->fonts[i].fontName);\n\t\t\tgf_bs_write_u8(bs, len);\n\t\t\tgf_bs_write_data(bs, ptr->fonts[i].fontName, len);\n\t\t} else {\n\t\t\tgf_bs_write_u8(bs, 0);\n\t\t}\n\t}\n\treturn GF_OK;\n}\nGF_Err ftab_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_FontTableBox *ptr = (GF_FontTableBox *)s;\n\n\ts->size += 2;\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\ts->size += 3;\n\t\tif (ptr->fonts[i].fontName) s->size += strlen(ptr->fonts[i].fontName);\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *text_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextSampleEntryBox, GF_ISOM_BOX_TYPE_TEXT);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox *)tmp);\n\treturn (GF_Box *) tmp;\n}\n\nvoid text_box_del(GF_Box *s)\n{\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\n\tif (ptr->textName)\n\t\tgf_free(ptr->textName);\n\tgf_free(ptr);\n}\n\nGF_Box *tx3g_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_Tx3gSampleEntryBox, GF_ISOM_BOX_TYPE_TX3G);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox *)tmp);\n\treturn (GF_Box *) tmp;\n}\n\nvoid tx3g_box_del(GF_Box *s)\n{\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tgf_free(s);\n}\n\nu32 gpp_read_rgba(GF_BitStream *bs)\n{\n\tu8 r, g, b, a;\n\tu32 col;\n\tr = gf_bs_read_u8(bs);\n\tg = gf_bs_read_u8(bs);\n\tb = gf_bs_read_u8(bs);\n\ta = gf_bs_read_u8(bs);\n\tcol = a;\n\tcol<<=8;\n\tcol |= r;\n\tcol<<=8;\n\tcol |= g;\n\tcol<<=8;\n\tcol |= b;\n\treturn col;\n}\n\n#define GPP_BOX_SIZE\t8\nvoid gpp_read_box(GF_BitStream *bs, GF_BoxRecord *rec)\n{\n\trec->top = gf_bs_read_u16(bs);\n\trec->left = gf_bs_read_u16(bs);\n\trec->bottom = gf_bs_read_u16(bs);\n\trec->right = gf_bs_read_u16(bs);\n}\n\n#define GPP_STYLE_SIZE\t12\nvoid gpp_read_style(GF_BitStream *bs, GF_StyleRecord *rec)\n{\n\trec->startCharOffset = gf_bs_read_u16(bs);\n\trec->endCharOffset = gf_bs_read_u16(bs);\n\trec->fontID = gf_bs_read_u16(bs);\n\trec->style_flags = gf_bs_read_u8(bs);\n\trec->font_size = gf_bs_read_u8(bs);\n\trec->text_color = gpp_read_rgba(bs);\n}\n\nGF_Err tx3g_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_Tx3gSampleEntryBox *ptr = (GF_Tx3gSampleEntryBox*)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_FTAB:\n\t\tBOX_FIELD_ASSIGN(font_table, GF_FontTableBox)\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tx3g_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_Tx3gSampleEntryBox *ptr = (GF_Tx3gSampleEntryBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, (18 + GPP_BOX_SIZE + GPP_STYLE_SIZE) );\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\n\tptr->displayFlags = gf_bs_read_u32(bs);\n\tptr->horizontal_justification = gf_bs_read_u8(bs);\n\tptr->vertical_justification = gf_bs_read_u8(bs);\n\tptr->back_color = gpp_read_rgba(bs);\n\tgpp_read_box(bs, &ptr->default_box);\n\tgpp_read_style(bs, &ptr->default_style);\n\n\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n/*this is a quicktime specific box - see apple documentation*/\nGF_Err text_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu16 pSize;\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);\n\tif (e) return e;\n\n\tptr->textJustification = 1;\n\n\t//some weird text entries are not QT text nor 3gpp, cf issue #1030\n\tif (!ptr->size) {\n\t\treturn GF_OK;\n\t}\n\tif (ptr->size < 43) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Broken text box (%d bytes but min 43 required), skiping parsing.\\n\", ptr->size));\n\t\treturn GF_OK;\n\t}\n\tISOM_DECREASE_SIZE(ptr, 43);\n\n\tptr->displayFlags = gf_bs_read_u32(bs);\t\t\t/*Display flags*/\n\tptr->textJustification = gf_bs_read_u32(bs);\t/*Text justification*/\n\tgf_bs_read_data(bs, ptr->background_color, 6);\t/*Background color*/\n\tgpp_read_box(bs, &ptr->default_box);\t\t\t/*Default text box*/\n\tgf_bs_read_data(bs, ptr->reserved1, 8);\t\t\t/*Reserved*/\n\tptr->fontNumber = gf_bs_read_u16(bs);\t\t\t/*Font number*/\n\tptr->fontFace   = gf_bs_read_u16(bs);\t\t\t/*Font face*/\n\tptr->reserved2  = gf_bs_read_u8(bs);\t\t\t/*Reserved*/\n\tptr->reserved3  = gf_bs_read_u16(bs);\t\t\t/*Reserved*/\n\tgf_bs_read_data(bs, ptr->foreground_color, 6);\t/*Foreground color*/\n\n\t/*ffmpeg compatibility with iPod streams: no pascal string*/\n\tif (!ptr->size)\n\t\treturn GF_OK;\n\n\tISOM_DECREASE_SIZE(ptr, 1);\n\tpSize = gf_bs_read_u8(bs); /*a Pascal string begins with its size: get textName size*/\n\n\tif (ptr->size < pSize) {\n\t\tu32 b_size = pSize;\n\t\tsize_t i = 0;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] text box doesn't use a Pascal string: trying to decode anyway.\\n\"));\n\t\tptr->textName = (char*)gf_malloc((size_t)ptr->size + 1 + 1);\n\t\tif (!ptr->textName) return GF_OUT_OF_MEM;\n\n\t\tdo {\n\t\t\tchar c = (char)b_size;\n\t\t\tif (c == '\\0') {\n\t\t\t\tbreak;\n\t\t\t} else if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n\t\t\t\tptr->textName[i] = c;\n\t\t\t} else {\n\t\t\t\tgf_free(ptr->textName);\n\t\t\t\tptr->textName = NULL;\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] text box doesn't use a Pascal string and contains non-chars. Abort.\\n\"));\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t}\n\t\t\ti++;\n\t\t\tif (!ptr->size)\n\t\t\t\tbreak;\n\t\t\tptr->size--;\n\t\t\tb_size = gf_bs_read_u8(bs);\n\t\t} while (b_size);\n\n\t\tptr->textName[i] = '\\0';\t\t\t\t/*Font name*/\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] text box doesn't use a Pascal string: \\\"%s\\\" detected.\\n\", ptr->textName));\n\t\treturn GF_OK;\n\t}\n\tif (pSize) {\n\t\tptr->textName = (char*) gf_malloc(pSize+1 * sizeof(char));\n\t\tif (!ptr->textName) return GF_OUT_OF_MEM;\n\n\t\tif (gf_bs_read_data(bs, ptr->textName, pSize) != pSize) {\n\t\t\tgf_free(ptr->textName);\n\t\t\tptr->textName = NULL;\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tptr->textName[pSize] = '\\0';\t\t\t\t/*Font name*/\n\t}\n\tISOM_DECREASE_SIZE(ptr, pSize);\n\n\tu32 next_size = gf_bs_peek_bits(bs, 32, 0);\n\tif (next_size > ptr->size) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Broken text box detected, skiping parsing.\\n\"));\n\t\tptr->textJustification = 1;\n\t\treturn GF_OK;\n\t}\n\treturn gf_isom_box_array_read(s, bs);\n}\n\nvoid gpp_write_rgba(GF_BitStream *bs, u32 col)\n{\n\tgf_bs_write_u8(bs, (col>>16) & 0xFF);\n\tgf_bs_write_u8(bs, (col>>8) & 0xFF);\n\tgf_bs_write_u8(bs, (col) & 0xFF);\n\tgf_bs_write_u8(bs, (col>>24) & 0xFF);\n}\n\nvoid gpp_write_box(GF_BitStream *bs, GF_BoxRecord *rec)\n{\n\tgf_bs_write_u16(bs, rec->top);\n\tgf_bs_write_u16(bs, rec->left);\n\tgf_bs_write_u16(bs, rec->bottom);\n\tgf_bs_write_u16(bs, rec->right);\n}\n\n#define GPP_STYLE_SIZE\t12\nvoid gpp_write_style(GF_BitStream *bs, GF_StyleRecord *rec)\n{\n\tgf_bs_write_u16(bs, rec->startCharOffset);\n\tgf_bs_write_u16(bs, rec->endCharOffset);\n\tgf_bs_write_u16(bs, rec->fontID);\n\tgf_bs_write_u8(bs, rec->style_flags);\n\tgf_bs_write_u8(bs, rec->font_size);\n\tgpp_write_rgba(bs, rec->text_color);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tx3g_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_Tx3gSampleEntryBox *ptr = (GF_Tx3gSampleEntryBox*)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\tgf_bs_write_u32(bs, ptr->displayFlags);\n\tgf_bs_write_u8(bs, ptr->horizontal_justification);\n\tgf_bs_write_u8(bs, ptr->vertical_justification);\n\tgpp_write_rgba(bs, ptr->back_color);\n\tgpp_write_box(bs, &ptr->default_box);\n\tgpp_write_style(bs, &ptr->default_style);\n\treturn GF_OK;\n}\n\nGF_Err text_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu16 pSize;\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\n\tgf_bs_write_u32(bs, ptr->displayFlags);\t\t\t/*Display flags*/\n\tgf_bs_write_u32(bs, ptr->textJustification);\t/*Text justification*/\n\tgf_bs_write_data(bs, ptr->background_color, 6);\t/*Background color*/\n\tgpp_write_box(bs, &ptr->default_box);\t\t\t/*Default text box*/\n\tgf_bs_write_data(bs, ptr->reserved1, 8);\t\t/*Reserved*/\n\tgf_bs_write_u16(bs, ptr->fontNumber);\t\t\t/*Font number*/\n\tgf_bs_write_u16(bs, ptr->fontFace);\t\t\t\t/*Font face*/\n\tgf_bs_write_u8(bs, ptr->reserved2);\t\t\t\t/*Reserved*/\n\tgf_bs_write_u16(bs, ptr->reserved3);\t\t\t/*Reserved*/\n\tgf_bs_write_data(bs, ptr->foreground_color, 6);\t/*Foreground color*/\n\t//pSize assignment below is not a mistake\n\tif (ptr->textName && (pSize = (u16) strlen(ptr->textName))) {\n\t\tgf_bs_write_u8(bs, pSize);\t\t\t\t\t/*a Pascal string begins with its size*/\n\t\tgf_bs_write_data(bs, ptr->textName, pSize);\t/*Font name*/\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tx3g_box_size(GF_Box *s)\n{\n\t/*base + this  + box + style*/\n\ts->size += 18 + GPP_BOX_SIZE + GPP_STYLE_SIZE;\n\treturn GF_OK;\n}\n\nGF_Err text_box_size(GF_Box *s)\n{\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\n\ts->size += 8;\n\t/*base + this + string length*/\n\ts->size += 43 + 1;\n\tif (ptr->textName)\n\t\ts->size += strlen(ptr->textName);\n\treturn GF_OK;\n}\n\n#endif\n\nGF_Box *styl_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextStyleBox, GF_ISOM_BOX_TYPE_STYL);\n\treturn (GF_Box *) tmp;\n}\n\nvoid styl_box_del(GF_Box *s)\n{\n\tGF_TextStyleBox*ptr = (GF_TextStyleBox*)s;\n\tif (ptr->styles) gf_free(ptr->styles);\n\tgf_free(ptr);\n}\n\nGF_Err styl_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TextStyleBox*ptr = (GF_TextStyleBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 2);\n\tptr->entry_count = gf_bs_read_u16(bs);\n\n\tif (ptr->size / GPP_STYLE_SIZE < ptr->entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tif (ptr->entry_count) {\n\t\tptr->styles = (GF_StyleRecord*)gf_malloc(sizeof(GF_StyleRecord)*ptr->entry_count);\n\t\tif (!ptr->styles) return GF_OUT_OF_MEM;\n\t\tfor (i=0; i<ptr->entry_count; i++) {\n\t\t\tISOM_DECREASE_SIZE(ptr, GPP_STYLE_SIZE);\n\t\t\tgpp_read_style(bs, &ptr->styles[i]);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err styl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TextStyleBox*ptr = (GF_TextStyleBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->entry_count);\n\tfor (i=0; i<ptr->entry_count; i++) gpp_write_style(bs, &ptr->styles[i]);\n\treturn GF_OK;\n}\n\nGF_Err styl_box_size(GF_Box *s)\n{\n\tGF_TextStyleBox*ptr = (GF_TextStyleBox*)s;\n\n\ts->size += 2 + ptr->entry_count * GPP_STYLE_SIZE;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *hlit_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextHighlightBox, GF_ISOM_BOX_TYPE_HLIT);\n\treturn (GF_Box *) tmp;\n}\n\nvoid hlit_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err hlit_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextHighlightBox *ptr = (GF_TextHighlightBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->startcharoffset = gf_bs_read_u16(bs);\n\tptr->endcharoffset = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err hlit_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TextHighlightBox *ptr = (GF_TextHighlightBox *)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->startcharoffset);\n\tgf_bs_write_u16(bs, ptr->endcharoffset);\n\treturn GF_OK;\n}\n\nGF_Err hlit_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *hclr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextHighlightColorBox, GF_ISOM_BOX_TYPE_HCLR);\n\treturn (GF_Box *) tmp;\n}\n\nvoid hclr_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err hclr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextHighlightColorBox*ptr = (GF_TextHighlightColorBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->hil_color = gpp_read_rgba(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err hclr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TextHighlightColorBox*ptr = (GF_TextHighlightColorBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgpp_write_rgba(bs, ptr->hil_color);\n\treturn GF_OK;\n}\n\nGF_Err hclr_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *krok_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextKaraokeBox, GF_ISOM_BOX_TYPE_KROK);\n\treturn (GF_Box *) tmp;\n}\n\nvoid krok_box_del(GF_Box *s)\n{\n\tGF_TextKaraokeBox*ptr = (GF_TextKaraokeBox*)s;\n\tif (ptr->records) gf_free(ptr->records);\n\tgf_free(ptr);\n}\n\nGF_Err krok_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextKaraokeBox*ptr = (GF_TextKaraokeBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 6)\n\tptr->highlight_starttime = gf_bs_read_u32(bs);\n\tptr->nb_entries = gf_bs_read_u16(bs);\n\tif (ptr->size / 8 < ptr->nb_entries)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tif (ptr->nb_entries) {\n\t\tu32 i;\n\t\tptr->records = (KaraokeRecord*)gf_malloc(sizeof(KaraokeRecord)*ptr->nb_entries);\n\t\tif (!ptr->records) return GF_OUT_OF_MEM;\n\t\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tptr->records[i].highlight_endtime = gf_bs_read_u32(bs);\n\t\t\tptr->records[i].start_charoffset = gf_bs_read_u16(bs);\n\t\t\tptr->records[i].end_charoffset = gf_bs_read_u16(bs);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err krok_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TextKaraokeBox*ptr = (GF_TextKaraokeBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->highlight_starttime);\n\tgf_bs_write_u16(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->records[i].highlight_endtime);\n\t\tgf_bs_write_u16(bs, ptr->records[i].start_charoffset);\n\t\tgf_bs_write_u16(bs, ptr->records[i].end_charoffset);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err krok_box_size(GF_Box *s)\n{\n\tGF_TextKaraokeBox*ptr = (GF_TextKaraokeBox*)s;\n\ts->size += 6 + 8*ptr->nb_entries;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *dlay_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextScrollDelayBox, GF_ISOM_BOX_TYPE_DLAY);\n\treturn (GF_Box *) tmp;\n}\n\nvoid dlay_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err dlay_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextScrollDelayBox*ptr = (GF_TextScrollDelayBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->scroll_delay = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dlay_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TextScrollDelayBox*ptr = (GF_TextScrollDelayBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->scroll_delay);\n\treturn GF_OK;\n}\n\nGF_Err dlay_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *href_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextHyperTextBox, GF_ISOM_BOX_TYPE_HREF);\n\treturn (GF_Box *) tmp;\n}\n\nvoid href_box_del(GF_Box *s)\n{\n\tGF_TextHyperTextBox*ptr = (GF_TextHyperTextBox*)s;\n\tif (ptr->URL) gf_free(ptr->URL);\n\tif (ptr->URL_hint) gf_free(ptr->URL_hint);\n\tgf_free(ptr);\n}\n\nGF_Err href_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 len;\n\tGF_TextHyperTextBox*ptr = (GF_TextHyperTextBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 6) //including 2 length fields\n\tptr->startcharoffset = gf_bs_read_u16(bs);\n\tptr->endcharoffset = gf_bs_read_u16(bs);\n\tlen = gf_bs_read_u8(bs);\n\tif (len) {\n\t\tISOM_DECREASE_SIZE(ptr, len)\n\t\tptr->URL = (char *) gf_malloc(sizeof(char) * (len+1));\n\t\tif (!ptr->URL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->URL, len);\n\t\tptr->URL[len] = 0;\n\t}\n\tlen = gf_bs_read_u8(bs);\n\tif (len) {\n\t\tISOM_DECREASE_SIZE(ptr, len)\n\t\tptr->URL_hint = (char *) gf_malloc(sizeof(char) * (len+1));\n\t\tif (!ptr->URL_hint) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->URL_hint, len);\n\t\tptr->URL_hint[len]= 0;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err href_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 len;\n\tGF_Err e;\n\tGF_TextHyperTextBox*ptr = (GF_TextHyperTextBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u16(bs, ptr->startcharoffset);\n\tgf_bs_write_u16(bs, ptr->endcharoffset);\n\tif (ptr->URL) {\n\t\tlen = (u32) strlen(ptr->URL);\n\t\tgf_bs_write_u8(bs, len);\n\t\tgf_bs_write_data(bs, ptr->URL, len);\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\tif (ptr->URL_hint) {\n\t\tlen = (u32) strlen(ptr->URL_hint);\n\t\tgf_bs_write_u8(bs, len);\n\t\tgf_bs_write_data(bs, ptr->URL_hint, len);\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err href_box_size(GF_Box *s)\n{\n\tGF_TextHyperTextBox*ptr = (GF_TextHyperTextBox*)s;\n\ts->size += 6;\n\tif (ptr->URL) s->size += strlen(ptr->URL);\n\tif (ptr->URL_hint) s->size += strlen(ptr->URL_hint);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *tbox_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextBoxBox, GF_ISOM_BOX_TYPE_TBOX);\n\treturn (GF_Box *) tmp;\n}\n\nvoid tbox_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err tbox_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextBoxBox*ptr = (GF_TextBoxBox*)s;\n\tISOM_DECREASE_SIZE(ptr, GPP_BOX_SIZE)\n\tgpp_read_box(bs, &ptr->box);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err tbox_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TextBoxBox*ptr = (GF_TextBoxBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgpp_write_box(bs, &ptr->box);\n\treturn GF_OK;\n}\n\nGF_Err tbox_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *blnk_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextBlinkBox, GF_ISOM_BOX_TYPE_BLNK);\n\treturn (GF_Box *) tmp;\n}\n\nvoid blnk_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err blnk_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextBlinkBox*ptr = (GF_TextBlinkBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->startcharoffset = gf_bs_read_u16(bs);\n\tptr->endcharoffset = gf_bs_read_u16(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err blnk_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TextBlinkBox*ptr = (GF_TextBlinkBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->startcharoffset);\n\tgf_bs_write_u16(bs, ptr->endcharoffset);\n\treturn GF_OK;\n}\n\nGF_Err blnk_box_size(GF_Box *s)\n{\n\ts->size += 4;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_Box *twrp_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TextWrapBox, GF_ISOM_BOX_TYPE_TWRP);\n\treturn (GF_Box *) tmp;\n}\n\nvoid twrp_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err twrp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TextWrapBox*ptr = (GF_TextWrapBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->wrap_flag = gf_bs_read_u8(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err twrp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TextWrapBox*ptr = (GF_TextWrapBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->wrap_flag);\n\treturn GF_OK;\n}\nGF_Err twrp_box_size(GF_Box *s)\n{\n\ts->size += 1;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid tsel_box_del(GF_Box *s)\n{\n\tGF_TrackSelectionBox *ptr;\n\tptr = (GF_TrackSelectionBox *) s;\n\tif (ptr == NULL) return;\n\tif (ptr->attributeList) gf_free(ptr->attributeList);\n\tgf_free(ptr);\n}\n\nGF_Err tsel_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TrackSelectionBox *ptr = (GF_TrackSelectionBox *) s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->switchGroup = gf_bs_read_u32(bs);\n\n\tif (ptr->size % 4) return GF_ISOM_INVALID_FILE;\n\tptr->attributeListCount = (u32)ptr->size/4;\n\tptr->attributeList = gf_malloc(ptr->attributeListCount*sizeof(u32));\n\tif (ptr->attributeList == NULL) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i< ptr->attributeListCount; i++) {\n\t\tptr->attributeList[i] = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}\n\nGF_Box *tsel_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackSelectionBox, GF_ISOM_BOX_TYPE_TSEL);\n\treturn (GF_Box *)tmp;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tsel_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_TrackSelectionBox *ptr = (GF_TrackSelectionBox *) s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs,ptr->switchGroup);\n\n\tfor (i = 0; i < ptr->attributeListCount; i++ ) {\n\t\tgf_bs_write_u32(bs, ptr->attributeList[i]);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err tsel_box_size(GF_Box *s)\n{\n\tGF_TrackSelectionBox *ptr = (GF_TrackSelectionBox *) s;\n\tptr->size += 4 + (4*ptr->attributeListCount);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *dimC_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DIMSSceneConfigBox, GF_ISOM_BOX_TYPE_DIMC);\n\treturn (GF_Box *)tmp;\n}\nvoid dimC_box_del(GF_Box *s)\n{\n\tGF_DIMSSceneConfigBox *p = (GF_DIMSSceneConfigBox *)s;\n\tif (p->contentEncoding) gf_free(p->contentEncoding);\n\tif (p->textEncoding) gf_free(p->textEncoding);\n\tgf_free(p);\n}\n\nGF_Err dimC_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tchar str[1024];\n\tu32 i;\n\tGF_DIMSSceneConfigBox *p = (GF_DIMSSceneConfigBox *)s;\n\n\tISOM_DECREASE_SIZE(p, 3);\n\tp->profile = gf_bs_read_u8(bs);\n\tp->level = gf_bs_read_u8(bs);\n\tp->pathComponents = gf_bs_read_int(bs, 4);\n\tp->fullRequestHost = gf_bs_read_int(bs, 1);\n\tp->streamType = gf_bs_read_int(bs, 1);\n\tp->containsRedundant = gf_bs_read_int(bs, 2);\n\n\ti=0;\n\tstr[0]=0;\n\twhile (i < GF_ARRAY_LENGTH(str)) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\n\tp->textEncoding = gf_strdup(str);\n\n\ti=0;\n\tstr[0]=0;\n\twhile (i < GF_ARRAY_LENGTH(str)) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\n\tp->contentEncoding = gf_strdup(str);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dimC_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DIMSSceneConfigBox *p = (GF_DIMSSceneConfigBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, p->profile);\n\tgf_bs_write_u8(bs, p->level);\n\tgf_bs_write_int(bs, p->pathComponents, 4);\n\tgf_bs_write_int(bs, p->fullRequestHost, 1);\n\tgf_bs_write_int(bs, p->streamType, 1);\n\tgf_bs_write_int(bs, p->containsRedundant, 2);\n    if (p->textEncoding)\n        gf_bs_write_data(bs, p->textEncoding, (u32) strlen(p->textEncoding));\n    gf_bs_write_u8(bs, 0);\n    if (p->contentEncoding)\n        gf_bs_write_data(bs, p->contentEncoding, (u32) strlen(p->contentEncoding));\n    gf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\nGF_Err dimC_box_size(GF_Box *s)\n{\n\tGF_DIMSSceneConfigBox *p = (GF_DIMSSceneConfigBox *)s;\n    s->size += 3 + 2;\n    if (p->textEncoding) s->size += strlen(p->textEncoding);\n    if (p->contentEncoding) s->size += strlen(p->contentEncoding);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\nGF_Box *diST_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DIMSScriptTypesBox, GF_ISOM_BOX_TYPE_DIST);\n\treturn (GF_Box *)tmp;\n}\nvoid diST_box_del(GF_Box *s)\n{\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\tif (p->content_script_types) gf_free(p->content_script_types);\n\tgf_free(p);\n}\n\nGF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\n\tp->content_script_types = gf_malloc(sizeof(char) * (s->size+1));\n\tif (!p->content_script_types) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, p->content_script_types, s->size);\n\tp->content_script_types[s->size] = 0;\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err diST_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (p->content_script_types)\n\t\tgf_bs_write_data(bs, p->content_script_types, (u32) strlen(p->content_script_types)+1);\n\telse\n\t\tgf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\nGF_Err diST_box_size(GF_Box *s)\n{\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\ts->size += p->content_script_types ? (strlen(p->content_script_types)+1) : 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\nGF_Box *dims_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_DIMSSampleEntryBox, GF_ISOM_BOX_TYPE_DIMS);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox *)tmp);\n\treturn (GF_Box*)tmp;\n}\nvoid dims_box_del(GF_Box *s)\n{\n\tgf_isom_sample_entry_predestroy((GF_SampleEntryBox *)s);\n\tgf_free(s);\n}\n\nGF_Err dims_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_DIMSSampleEntryBox *ptr = (GF_DIMSSampleEntryBox  *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_DIMC:\n\t\tBOX_FIELD_ASSIGN(config, GF_DIMSSceneConfigBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DIST:\n\t\tBOX_FIELD_ASSIGN(scripts, GF_DIMSScriptTypesBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\nGF_Err dims_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_DIMSSampleEntryBox *p = (GF_DIMSSampleEntryBox *)s;\n\n\te = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)p, bs);\n\tif (e) return e;\n\n\tISOM_DECREASE_SIZE(p, 8);\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err dims_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DIMSSampleEntryBox *p = (GF_DIMSSampleEntryBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, p->reserved, 6);\n\tgf_bs_write_u16(bs, p->dataReferenceIndex);\n\treturn GF_OK;\n}\n\nGF_Err dims_box_size(GF_Box *s)\n{\n\tu32 pos = 0;\n\tGF_DIMSSampleEntryBox *p = (GF_DIMSSampleEntryBox *)s;\n\ts->size += 8;\n\tgf_isom_check_position(s, (GF_Box *) p->config, &pos);\n\tgf_isom_check_position(s, (GF_Box *) p->scripts, &pos);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "filenames": ["src/isomedia/box_code_3gpp.c"], "buggy_code_start_loc": [1131], "buggy_code_end_loc": [1145], "fixing_code_start_loc": [1130], "fixing_code_end_loc": [1137], "type": "CWE-119", "message": "MP4Box is a component of GPAC-2.0.0, which is a widely-used third-party package on RPM Fusion. When MP4Box tries to parse a MP4 file, it calls the function `diST_box_read()` to read from video. In this function, it allocates a buffer `str` with fixed length. However, content read from `bs` is controllable by user, so is the length, which causes a buffer overflow.", "other": {"cve": {"id": "CVE-2022-1441", "sourceIdentifier": "secalert@redhat.com", "published": "2022-04-25T17:15:36.547", "lastModified": "2023-05-27T04:15:20.370", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "MP4Box is a component of GPAC-2.0.0, which is a widely-used third-party package on RPM Fusion. When MP4Box tries to parse a MP4 file, it calls the function `diST_box_read()` to read from video. In this function, it allocates a buffer `str` with fixed length. However, content read from `bs` is controllable by user, so is the length, which causes a buffer overflow."}, {"lang": "es", "value": "MP4Box es un componente de GPAC-2.0.0, que es un paquete de terceros ampliamente usado en RPM Fusion. Cuando MP4Box intenta analizar un archivo MP4, llama a la funci\u00f3n \"diST_box_read()\" para leer del v\u00eddeo. En esta funci\u00f3n, es asignado un buffer \"str\" con longitud fija. Sin embargo, el contenido le\u00eddo desde \"bs\" es controlable por el usuario, as\u00ed como la longitud, lo que causa un desbordamiento del buffer"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:2.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "D7AEE044-50E9-4230-B492-A5FF18653115"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/3dbe11b37d65c8472faf0654410068e5500b3adb", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/2175", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5411", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/3dbe11b37d65c8472faf0654410068e5500b3adb"}}