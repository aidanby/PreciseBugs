{"buggy_code": ["/* p_mach.cpp -- pack Mach Object executable\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 2004-2021 John Reiser\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   John Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#include \"conf.h\"\n\n#include \"file.h\"\n#include \"filter.h\"\n#include \"linker.h\"\n#include \"packer.h\"\n#include \"p_mach.h\"\n#include \"ui.h\"\n\nstatic const\n#include \"stub/i386-darwin.macho-entry.h\"\nstatic const\n#include \"stub/i386-darwin.macho-fold.h\"\nstatic const\n#include \"stub/i386-darwin.macho-upxmain.h\"\nstatic const\n#include \"stub/i386-darwin.dylib-entry.h\"\n\nstatic const\n#include \"stub/amd64-darwin.macho-entry.h\"\nstatic const\n#include \"stub/amd64-darwin.macho-fold.h\"\nstatic const\n#include \"stub/amd64-darwin.macho-upxmain.h\"\nstatic const\n#include \"stub/amd64-darwin.dylib-entry.h\"\n\nstatic const\n#include \"stub/arm.v5a-darwin.macho-entry.h\"\nstatic const\n#include \"stub/arm.v5a-darwin.macho-fold.h\"\n\nstatic const\n#include \"stub/arm64-darwin.macho-entry.h\"\nstatic const\n#include \"stub/arm64-darwin.macho-fold.h\"\n\nstatic const\n#include \"stub/powerpc-darwin.macho-entry.h\"\nstatic const\n#include \"stub/powerpc-darwin.macho-fold.h\"\nstatic const\n#include \"stub/powerpc-darwin.macho-upxmain.h\"\nstatic const\n#include \"stub/powerpc-darwin.dylib-entry.h\"\n\nstatic const\n#include \"stub/powerpc64le-darwin.macho-entry.h\"\nstatic const\n#include \"stub/powerpc64le-darwin.macho-fold.h\"\nstatic const\n#include \"stub/powerpc64le-darwin.dylib-entry.h\"\n\n// Packing a Darwin (Mach-o) Mac OS X dylib (dynamic shared library)\n// is restricted.  UPX gets control as the -init function, at the very\n// end of processing by dyld.  Relocation, loading of dependent libraries,\n// etc., already have taken place before decompression.  So the Mach-o\n// headers, the __IMPORT segment, the __LINKEDIT segment, anything\n// that is modifed by relocation, etc., cannot be compressed.\n// We simplify arbitrarily by compressing only the __TEXT segment,\n// which must be the first segment.\n\nstatic const unsigned lc_segment[2] = {\n    0x1, 0x19\n    //Mach_command::LC_SEGMENT,\n    //Mach_command::LC_SEGMENT_64\n};\n\n#if 0 // NOT USED\nstatic const unsigned lc_routines[2] = {\n    0x11, 0x1a\n    //Mach_command::LC_ROUTINES,\n    //Mach_command::LC_ROUTINES_64\n};\n#endif\n\ntemplate <class T>\nPackMachBase<T>::PackMachBase(InputFile *f, unsigned cputype, unsigned filetype,\n        unsigned flavor, unsigned count, unsigned size) :\n    super(f), my_cputype(cputype), my_filetype(filetype), my_thread_flavor(flavor),\n    my_thread_state_word_count(count), my_thread_command_size(size),\n    n_segment(0), rawmseg(nullptr), msegcmd(nullptr), o__mod_init_func(0),\n    prev_mod_init_func(0), pagezero_vmsize(0)\n{\n    MachClass::compileTimeAssertions();\n    bele = N_BELE_CTP::getRTP((const BeLePolicy*) nullptr);\n    memset(&cmdUUID, 0, sizeof(cmdUUID));\n    memset(&cmdSRCVER, 0, sizeof(cmdSRCVER));\n    memset(&cmdVERMIN, 0, sizeof(cmdVERMIN));\n    memset(&linkitem, 0, sizeof(linkitem));\n}\n\ntemplate <class T>\nPackMachBase<T>::~PackMachBase()\n{\n}\n\nPackDylibI386::PackDylibI386(InputFile *f) : super(f)\n{\n    my_filetype = Mach_header::MH_DYLIB;\n}\n\nPackDylibAMD64::PackDylibAMD64(InputFile *f) : super(f)\n{\n    my_filetype = Mach_header::MH_DYLIB;\n}\n\nPackDylibPPC32::PackDylibPPC32(InputFile *f) : super(f)\n{\n    my_filetype = Mach_header::MH_DYLIB;\n}\nPackDylibPPC64LE::PackDylibPPC64LE(InputFile *f) : super(f)\n{\n    my_filetype = Mach_header::MH_DYLIB;\n}\n\ntemplate <class T>\nconst int *PackMachBase<T>::getCompressionMethods(int method, int level) const\n{\n    // There really is no LE bias.\n    return Packer::getDefaultCompressionMethods_le32(method, level);\n}\n\nconst int *PackMachARMEL::getCompressionMethods(int method, int level) const\n{\n    // Un-aligned fetch does not work on 32-bit ARM, so use 8-bit methods\n    return Packer::getDefaultCompressionMethods_8(method, level);\n}\n\nPackMachPPC32::PackMachPPC32(InputFile *f) : super(f, Mach_header::CPU_TYPE_POWERPC,\n        Mach_header::MH_EXECUTE, Mach_thread_command::PPC_THREAD_STATE,\n        sizeof(Mach_ppc_thread_state)>>2, sizeof(threado))\n{ }\n\nPackMachPPC64LE::PackMachPPC64LE(InputFile *f) : super(f, Mach_header::CPU_TYPE_POWERPC64LE,\n        Mach_header::MH_EXECUTE, Mach_thread_command::PPC_THREAD_STATE64,\n        sizeof(Mach_ppcle_thread_state64)>>2, sizeof(threado))\n{ }\n\nconst int *PackMachPPC32::getFilters() const\n{\n    static const int filters[] = { 0xd0, FT_END };\n    return filters;\n}\n\nconst int *PackMachPPC64LE::getFilters() const\n{\n    static const int filters[] = { 0xd0, FT_END };\n    return filters;\n}\n\nPackMachI386::PackMachI386(InputFile *f) : super(f, Mach_header::CPU_TYPE_I386,\n        Mach_header::MH_EXECUTE, (unsigned)Mach_thread_command::x86_THREAD_STATE32,\n        sizeof(Mach_i386_thread_state)>>2, sizeof(threado))\n{ }\n\nint const *PackMachI386::getFilters() const\n{\n    static const int filters[] = { 0x49, FT_END };\n    return filters;\n}\n\nPackMachAMD64::PackMachAMD64(InputFile *f) : super(f, Mach_header::CPU_TYPE_X86_64,\n        Mach_header::MH_EXECUTE, (unsigned)Mach_thread_command::x86_THREAD_STATE64,\n        sizeof(Mach_AMD64_thread_state)>>2, sizeof(threado))\n{ }\n\nint const *PackMachAMD64::getFilters() const\n{\n    static const int filters[] = { 0x49, FT_END };\n    return filters;\n}\n\nPackMachARMEL::PackMachARMEL(InputFile *f) : super(f, Mach_header::CPU_TYPE_ARM,\n        Mach_header::MH_EXECUTE, (unsigned)Mach_thread_command::ARM_THREAD_STATE,\n        sizeof(Mach_ARM_thread_state)>>2, sizeof(threado))\n{ }\n\nPackMachARM64EL::PackMachARM64EL(InputFile *f) : super(f, Mach_header::CPU_TYPE_ARM64,\n        Mach_header::MH_EXECUTE, (unsigned)Mach_thread_command::ARM_THREAD_STATE64,\n        sizeof(Mach_ARM64_thread_state)>>2, sizeof(threado))\n{ }\n\nint const *PackMachARMEL::getFilters() const\n{\n    static const int filters[] = { 0x50, FT_END };\n    return filters;\n}\n\nint const *PackMachARM64EL::getFilters() const\n{\n    static const int filters[] = { 0x52, FT_END };\n    return filters;\n}\n\nLinker *PackMachPPC32::newLinker() const\n{\n    return new ElfLinkerPpc32;\n}\n\nLinker *PackMachPPC64LE::newLinker() const\n{\n    return new ElfLinkerPpc64le;\n}\n\nLinker *PackMachI386::newLinker() const\n{\n    return new ElfLinkerX86;\n}\n\nLinker *PackMachAMD64::newLinker() const\n{\n    return new ElfLinkerAMD64;\n}\n\nLinker *PackMachARMEL::newLinker() const\n{\n    return new ElfLinkerArmLE;\n}\n\nLinker *PackMachARM64EL::newLinker() const\n{\n    return new ElfLinkerArm64LE;\n}\n\ntemplate <class T>\nvoid\nPackMachBase<T>::addStubEntrySections(Filter const *)\n{\n    addLoader(\"MACOS000\", nullptr);\n   //addLoader(getDecompressorSections(), nullptr);\n    addLoader(\n        ( M_IS_NRV2E(ph.method) ? \"NRV_HEAD,NRV2E,NRV_TAIL\"\n        : M_IS_NRV2D(ph.method) ? \"NRV_HEAD,NRV2D,NRV_TAIL\"\n        : M_IS_NRV2B(ph.method) ? \"NRV_HEAD,NRV2B,NRV_TAIL\"\n        : M_IS_LZMA(ph.method)  ? \"LZMA_ELF00,LZMA_DEC20,LZMA_DEC30\"\n        : nullptr), nullptr);\n    if (hasLoaderSection(\"CFLUSH\"))\n        addLoader(\"CFLUSH\");\n    addLoader(\"ELFMAINY,IDENTSTR,+40,ELFMAINZ,FOLDEXEC\", nullptr);\n}\n\nvoid PackMachI386::addStubEntrySections(Filter const * /*ft*/)\n{\n    addLoader(\"MACHMAINX\", nullptr);  // different for MY_DYLIB vs MH_EXECUTE\n    if (my_filetype==Mach_header::MH_EXECUTE) {\n        addLoader(\"MACH_UNC\", nullptr);\n    }\n   //addLoader(getDecompressorSections(), nullptr);\n    addLoader(\n        ( M_IS_NRV2E(ph.method) ? \"NRV_HEAD,NRV2E,NRV_TAIL\"\n        : M_IS_NRV2D(ph.method) ? \"NRV_HEAD,NRV2D,NRV_TAIL\"\n        : M_IS_NRV2B(ph.method) ? \"NRV_HEAD,NRV2B,NRV_TAIL\"\n        : M_IS_LZMA(ph.method)  ? \"LZMA_ELF00,LZMA_DEC20,LZMA_DEC30\"\n        : nullptr), nullptr);\n    if (hasLoaderSection(\"CFLUSH\"))\n        addLoader(\"CFLUSH\");\n    addLoader(\"MACHMAINY,IDENTSTR,+40,MACHMAINZ,FOLDEXEC\", nullptr);\n}\n\nvoid PackMachAMD64::addStubEntrySections(Filter const * /*ft*/)\n{\n    addLoader(\"MACHMAINX\", nullptr);  // different for MY_DYLIB vs MH_EXECUTE\n    if (my_filetype==Mach_header::MH_EXECUTE) {\n        addLoader(\"MACH_UNC\", nullptr);\n    }\n   //addLoader(getDecompressorSections(), nullptr);\n    addLoader(\n        ( M_IS_NRV2E(ph.method) ? \"NRV_HEAD,NRV2E,NRV_TAIL\"\n        : M_IS_NRV2D(ph.method) ? \"NRV_HEAD,NRV2D,NRV_TAIL\"\n        : M_IS_NRV2B(ph.method) ? \"NRV_HEAD,NRV2B,NRV_TAIL\"\n        : M_IS_LZMA(ph.method)  ? \"LZMA_ELF00,LZMA_DEC20,LZMA_DEC30\"\n        : nullptr), nullptr);\n    if (hasLoaderSection(\"CFLUSH\"))\n        addLoader(\"CFLUSH\");\n    addLoader(\"MACHMAINY,IDENTSTR,+40,MACHMAINZ,FOLDEXEC\", nullptr);\n}\n\nvoid PackMachPPC32::addStubEntrySections(Filter const * /*ft*/)\n{\n    if (my_filetype!=Mach_header::MH_EXECUTE) {\n        addLoader(\"MACHMAINX\", nullptr);\n    }\n    else {\n        addLoader(\"PPC32BXX\", nullptr);\n    }\n    addLoader(\"MACH_UNC\", nullptr);\n   //addLoader(getDecompressorSections(), nullptr);\n    addLoader(\n        ( M_IS_NRV2E(ph.method) ? \"NRV_HEAD,NRV2E,NRV_TAIL\"\n        : M_IS_NRV2D(ph.method) ? \"NRV_HEAD,NRV2D,NRV_TAIL\"\n        : M_IS_NRV2B(ph.method) ? \"NRV_HEAD,NRV2B,NRV_TAIL\"\n        : M_IS_LZMA(ph.method)  ? \"LZMA_ELF00,LZMA_DEC20,LZMA_DEC30\"\n        : nullptr), nullptr);\n    if (hasLoaderSection(\"CFLUSH\"))\n        addLoader(\"CFLUSH\");\n    addLoader(\"MACHMAINY,IDENTSTR,+40,MACHMAINZ\", nullptr);\n    if (my_filetype!=Mach_header::MH_EXECUTE) {\n        addLoader(\"FOLDEXEC\", nullptr);\n    }\n}\n\nvoid PackMachARMEL::addStubEntrySections(Filter const * /*ft*/)\n{\n    addLoader(\"MACHMAINX\", nullptr);\n   //addLoader(getDecompressorSections(), nullptr);\n    addLoader(\n        ( M_IS_NRV2E(ph.method) ? \"NRV_HEAD,NRV2E,NRV_TAIL\"\n        : M_IS_NRV2D(ph.method) ? \"NRV_HEAD,NRV2D,NRV_TAIL\"\n        : M_IS_NRV2B(ph.method) ? \"NRV_HEAD,NRV2B,NRV_TAIL\"\n        : M_IS_LZMA(ph.method)  ? \"LZMA_ELF00,LZMA_DEC20,LZMA_DEC30\"\n        : nullptr), nullptr);\n    if (hasLoaderSection(\"CFLUSH\"))\n        addLoader(\"CFLUSH\");\n    addLoader(\"MACHMAINY,IDENTSTR,+40,MACHMAINZ,FOLDEXEC\", nullptr);\n}\n\nvoid PackMachARM64EL::addStubEntrySections(Filter const * /*ft*/)\n{\n    addLoader(\"MACHMAINX\", nullptr);\n   //addLoader(getDecompressorSections(), nullptr);\n    addLoader(\n        ( M_IS_NRV2E(ph.method) ? \"NRV_HEAD,NRV2E,NRV_TAIL\"\n        : M_IS_NRV2D(ph.method) ? \"NRV_HEAD,NRV2D,NRV_TAIL\"\n        : M_IS_NRV2B(ph.method) ? \"NRV_HEAD,NRV2B,NRV_TAIL\"\n        : M_IS_LZMA(ph.method)  ? \"LZMA_ELF00,LZMA_DEC20,LZMA_DEC30\"\n        : nullptr), nullptr);\n    if (hasLoaderSection(\"CFLUSH\"))\n        addLoader(\"CFLUSH\");\n    addLoader(\"MACHMAINY,IDENTSTR,+40,MACHMAINZ,FOLDEXEC\", nullptr);\n}\n\ntemplate <class T>\nvoid PackMachBase<T>::defineSymbols(Filter const *)\n{\n    // empty\n}\n\n\ntemplate <class T>\nvoid\nPackMachBase<T>::buildMachLoader(\n    upx_byte const *const proto,\n    unsigned        const szproto,\n    upx_byte const *const fold,\n    unsigned        const szfold,\n    Filter const *ft\n)\n{\n    initLoader(proto, szproto);\n\n    struct b_info h; memset(&h, 0, sizeof(h));\n    unsigned fold_hdrlen = 0;\n  if (0 < szfold) {\n    h.sz_unc = (szfold < fold_hdrlen) ? 0 : (szfold - fold_hdrlen);\n    h.b_method = (unsigned char) ph.method;\n    h.b_ftid = (unsigned char) ph.filter;\n    h.b_cto8 = (unsigned char) ph.filter_cto;\n  }\n    unsigned char const *const uncLoader = fold_hdrlen + fold;\n\n    MemBuffer cprLoader_buf(sizeof(h) + h.sz_unc);\n    unsigned char *const cprLoader = (unsigned char *)cprLoader_buf.getVoidPtr();\n  if (0 < szfold) {\n    unsigned sz_cpr = 0;\n    int r = upx_compress(uncLoader, h.sz_unc, sizeof(h) + cprLoader, &sz_cpr,\n        nullptr, ph.method, 10, nullptr, nullptr );\n    h.sz_cpr = sz_cpr;\n    if (r != UPX_E_OK || h.sz_cpr >= h.sz_unc)\n        throwInternalError(\"loader compression failed\");\n  }\n    memcpy(cprLoader, &h, sizeof(h));\n\n    // This adds the definition to the \"library\", to be used later.\n    linker->addSection(\"FOLDEXEC\", cprLoader, sizeof(h) + h.sz_cpr, 0);\n\n    int const GAP = 128;  // must match stub/l_mac_ppc.S\n    int const NO_LAP = 64;  // must match stub/src/*darwin*.S\n    segTEXT.vmsize = h.sz_unc - h.sz_cpr + GAP + NO_LAP;\n\n    addStubEntrySections(ft);\n\n    defineSymbols(ft);\n    relocateLoader();\n}\n\ntemplate <class T>\nvoid\nPackMachBase<T>::buildLoader(const Filter *ft)\n{\n    buildMachLoader(\n        stub_entry, sz_stub_entry,\n        stub_fold,  sz_stub_fold,  ft );\n}\n\ntemplate <class T>\nvoid PackMachBase<T>::patchLoader() { }\n\ntemplate <class T>\nvoid PackMachBase<T>::updateLoader(OutputFile *) {}\n\ntemplate <class T>\nvoid PackMachBase<T>::patchLoaderChecksum()\n{\n    unsigned char *const ptr = getLoader();\n    l_info *const lp = &linfo;\n    // checksum for loader; also some PackHeader info\n    lp->l_checksum = 0;\n    lp->l_magic = UPX_MAGIC_LE32;  // LE32 always\n    set_te16(&lp->l_lsize, (upx_uint16_t) lsize);\n    lp->l_version = (unsigned char) ph.version;\n    lp->l_format  = (unsigned char) ph.format;\n    // INFO: lp->l_checksum is currently unused\n    set_te32(&lp->l_checksum, upx_adler32(ptr, lsize));\n}\n\ntemplate <class T>\nint __acc_cdecl_qsort\nPackMachBase<T>::compare_segment_command(void const *const aa, void const *const bb)\n{\n    Mach_segment_command const *const a = (Mach_segment_command const *)aa;\n    Mach_segment_command const *const b = (Mach_segment_command const *)bb;\n    unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];\n    unsigned const xa = a->cmd - lc_seg;\n    unsigned const xb = b->cmd - lc_seg;\n           if (xa < xb)        return -1;  // LC_SEGMENT first\n           if (xa > xb)        return  1;\n           if (0 != xa)        return  0;  // not LC_SEGMENT\n    // Ascending by .fileoff so that find_SEGMENT_gap works\n    if (a->fileoff < b->fileoff)\n                               return -1;\n    if (a->fileoff > b->fileoff)\n                               return  1;\n    // Ascending by .vmaddr\n    if (a->vmaddr < b->vmaddr) return -1;\n    if (a->vmaddr > b->vmaddr) return  1;\n    // Descending by .vmsize\n    if (a->vmsize)             return -1;  // 'a' is first\n    if (b->vmsize)             return  1;  // 'a' is last\n    // What could remain?\n    return 0;\n}\n\n#undef PAGE_MASK\n#undef PAGE_SIZE\n#define PAGE_MASK (~0u<<12)\n#define PAGE_SIZE (0u-PAGE_MASK)\n\n#undef PAGE_MASK64\n#undef PAGE_SIZE64\n#define PAGE_MASK64 (~(upx_uint64_t)0<<16)\n#define PAGE_SIZE64 ((upx_uint64_t)0-PAGE_MASK64)\n\n// At 2013-02-03 part of the source for codesign was\n//    http://opensource.apple.com/source/cctools/cctools-836/libstuff/ofile.c\n\n#undef PAGE_MASK64\n#undef PAGE_SIZE64\n#define PAGE_MASK64 (~(upx_uint64_t)0<<12)\n#define PAGE_SIZE64 ((upx_uint64_t)0-PAGE_MASK64)\n\nunsigned const blankLINK = 16;  // size of our empty __LINK segment\n// Note: \"readelf --segments\"  ==>  \"otool -hl\" or \"otool -hlv\" etc. (Xcode on MacOS)\n\ntemplate <class T>\nvoid PackMachBase<T>::pack4(OutputFile *fo, Filter &ft)  // append PackHeader\n{\n    // offset of p_info in compressed file\n    overlay_offset = secTEXT.offset + sizeof(linfo);\n    super::pack4(fo, ft);\n\n    if (Mach_header::MH_EXECUTE == my_filetype) {\n        unsigned len = fo->getBytesWritten();\n        char page[~PAGE_MASK]; memset(page, 0, sizeof(page));\n        fo->write(page, ~PAGE_MASK & (0u - len));\n        len +=          ~PAGE_MASK & (0u - len) ;\n\n        segTEXT.filesize = len;\n        segTEXT.vmsize   = len;  // FIXME?  utilize GAP + NO_LAP + sz_unc - sz_cpr\n        secTEXT.offset = overlay_offset - sizeof(linfo);\n        secTEXT.addr = segTEXT.vmaddr   + secTEXT.offset;\n        secTEXT.size = segTEXT.filesize - secTEXT.offset;\n        secXHDR.offset = overlay_offset - sizeof(linfo);\n        if (my_filetype==Mach_header::MH_EXECUTE) {\n            secXHDR.offset -= sizeof(linkitem);\n        }\n        secXHDR.addr += secXHDR.offset;\n        unsigned offLINK = segLINK.fileoff;\n\n\n        segLINK.fileoff = len;  // must be in the file\n        segLINK.vmaddr =  len + segTEXT.vmaddr;\n        fo->write(page, blankLINK); len += blankLINK;\n        segLINK.vmsize = PAGE_SIZE;\n        segLINK.filesize = blankLINK;\n\n        // Get a writeable copy of the stub to make editing easier.\n        ByteArray(upxstub, sz_stub_main);\n        memcpy(upxstub, stub_main, sz_stub_main);\n\n        Mach_header *const mhp = (Mach_header *)upxstub;\n        mhp->cpusubtype = my_cpusubtype;\n        mhp->flags = mhdro.flags;\n        char *tail = (char *)(1+ mhp);\n        char *const lcp_end = mhdro.sizeofcmds + tail;\n        Mach_command *lcp = (Mach_command *)(1+ mhp);\n        Mach_command *lcp_next;\n        unsigned const ncmds = mhdro.ncmds;\n        //unsigned cmdsize = mhdro.sizeofcmds;\n        unsigned delta = 0;\n\n    for (unsigned j = 0; j < ncmds; ++j) {\n        unsigned skip = 0;\n        unsigned sz_cmd = lcp->cmdsize;\n        lcp_next = (Mach_command *)(sz_cmd + (char *)lcp);\n\n        switch (lcp->cmd) {\n        case Mach_command::LC_SEGMENT: // fall through\n        case Mach_command::LC_SEGMENT_64: {\n            Mach_segment_command *const segptr = (Mach_segment_command *)lcp;\n            if (!strcmp(\"__PAGEZERO\", segptr->segname)) {\n                segptr->vmsize = pagezero_vmsize;\n            }\n            if (!strcmp(\"__TEXT\", segptr->segname)) {\n                sz_cmd = (segTEXT.nsects * sizeof(secTEXT)) + sizeof(segTEXT);\n                mhp->sizeofcmds += sizeof(secTEXT) * (1 - segptr->nsects);\n                memcpy(tail, &segTEXT, sz_cmd); tail += sz_cmd;\n                goto next;\n            }\n            if (!strcmp(\"__LINKEDIT\", segptr->segname)) {\n                segLINK.initprot = Mach_command::VM_PROT_READ;\n                delta = offLINK - segptr->fileoff;  // relocation constant\n\n                sz_cmd = sizeof(segLINK);\n                if (Mach_header::CPU_TYPE_I386==mhdri.cputype\n                &&  Mach_header::MH_EXECUTE==mhdri.filetype) {\n                    segLINK.maxprot = 0\n                        | Mach_command::VM_PROT_EXECUTE\n                        | Mach_command::VM_PROT_WRITE\n                        | Mach_command::VM_PROT_READ;\n                    segLINK.initprot = 0\n                        | Mach_command::VM_PROT_WRITE\n                        | Mach_command::VM_PROT_READ;\n                }\n                memcpy(tail, &segLINK, sz_cmd); tail += sz_cmd;\n                goto next;\n            }\n        } break;\n        case Mach_command::LC_DYLD_INFO_ONLY: {\n            Mach_dyld_info_only_command *p = (Mach_dyld_info_only_command *)lcp;\n            if (p->rebase_off)    p->rebase_off    += delta;\n            if (p->bind_off)      p->bind_off      += delta;\n            if (p->lazy_bind_off) p->lazy_bind_off += delta;\n            if (p->export_off)    p->export_off    += delta;\n                // But we don't want any exported symbols.\n                p->export_off = 0;\n                p->export_size = 0;\n            skip = 1;\n        } break;\n        case Mach_command::LC_SYMTAB: {\n            // Apple codesign requires that string table is last in the file.\n            Mach_symtab_command *p = (Mach_symtab_command *)lcp;\n            p->symoff = segLINK.filesize + segLINK.fileoff;\n            p->nsyms = 0;\n            p->stroff = segLINK.fileoff;\n            p->strsize = segLINK.filesize;\n            skip = 1;\n        } break;\n        case Mach_command::LC_DYSYMTAB: {\n            Mach_dysymtab_command *p = (Mach_dysymtab_command *)lcp;\n            if (p->tocoff)         p->tocoff         += delta;\n            if (p->modtaboff)      p->modtaboff      += delta;\n            if (p->extrefsymoff)   p->extrefsymoff   += delta;\n            if (p->indirectsymoff) p->indirectsymoff += delta;\n            if (p->extreloff)      p->extreloff      += delta;\n            if (p->locreloff)      p->locreloff      += delta;\n                // But we don't want any symbols.\n                p->ilocalsym = 0;\n                p->nlocalsym = 0;\n                p->iextdefsym = 0;\n                p->nextdefsym = 0;\n                p->iundefsym = 0;\n                p->nundefsym = 0;\n            skip = 1;\n        } break;\n        case Mach_command::LC_MAIN: {\n                // Replace later with LC_UNIXTHREAD.\n// LC_MAIN requires libSystem.B.dylib to provide the environment for main(), and CALLs the entryoff.\n// LC_UNIXTHREAD does not need libSystem.B.dylib, and JMPs to the .rip with %rsp/argc and argv= 8+%rsp\n            threado_setPC(segTEXT.vmaddr +\n                (((Mach_main_command const *)lcp)->entryoff - segTEXT.fileoff));\n            skip = 1;\n        } break;\n        case Mach_command::LC_UNIXTHREAD: { // pre-LC_MAIN\n            skip = 1;\n        } break;\n        case Mach_command::LC_LOAD_DYLIB: {\n            skip = 1;\n        } break;\n\n        case Mach_command::LC_FUNCTION_STARTS:\n        case Mach_command::LC_DATA_IN_CODE: {\n            Mach_linkedit_data_command *p = (Mach_linkedit_data_command *)lcp;\n            if (p->dataoff) p->dataoff += delta;\n            skip = 1;\n        } break;\n        case Mach_command::LC_LOAD_DYLINKER: {\n            skip = 1;\n        } break;\n        case Mach_command::LC_SOURCE_VERSION: { // copy from saved original\n            memcpy(lcp, &cmdSRCVER, sizeof(cmdSRCVER));\n            if (Mach_command::LC_SOURCE_VERSION != cmdSRCVER.cmd) {\n                skip = 1;  // was not seen\n            }\n        } break;\n        case Mach_command::LC_VERSION_MIN_MACOSX: { // copy from saved original\n            memcpy(lcp, &cmdVERMIN, sizeof(cmdVERMIN));\n            if (Mach_command::LC_VERSION_MIN_MACOSX != cmdVERMIN.cmd) {\n                skip = 1;  // was not seen\n            }\n        } break;\n        } // end switch\n\n        if (skip) {\n            mhp->ncmds -= 1;\n            mhp->sizeofcmds -= sz_cmd;\n        }\n        else {\n            if (tail != (char *)lcp) {\n                memmove(tail, lcp, sz_cmd);\n            }\n            tail += sz_cmd;\n        }\nnext:\n        lcp = lcp_next;\n    }  // end for each Mach_command\n\n        // Append LC_UNIXTHREAD\n        unsigned const sz_threado = threado_size();\n        mhp->ncmds += 1;\n        mhp->sizeofcmds += sz_threado;\n        fo->seek(0, SEEK_SET);\n        fo->rewrite(mhp, tail - (char *)mhp);\n        threado_rewrite(fo);\n        tail += sz_threado;\n        //\n        // Zero any remaining tail.\n        if (tail < lcp_end) {\n            unsigned sz_cmd = lcp_end - tail;\n            memset(tail, 0, sz_cmd);\n            fo->rewrite(tail, sz_cmd);\n        }\n        // Rewrite linfo in file.\n        fo->seek(sz_mach_headers, SEEK_SET);\n        fo->rewrite(&linfo, sizeof(linfo));\n        fo->seek(0, SEEK_END);\n    }\n}\n\n// At 2013-02-03 part of the source for codesign was:\n//    http://opensource.apple.com/source/cctools/cctools-836/libstuff/ofile.c\n\ntemplate <class T>\nvoid PackMachBase<T>::pack4dylib(  // append PackHeader\n    OutputFile *const fo,\n    Filter &ft,\n    Addr init_address\n)\n{\n    fo->seek(0, SEEK_SET);\n    fo->rewrite(&mhdro, sizeof(mhdro));  // segTEXT.nsect=1 (only secTEXT)\n    fo->rewrite(&segTEXT, sizeof(segTEXT));  // .vmsize\n    unsigned opos = sizeof(mhdro);\n\n    // Append each non-__TEXT segment, page aligned.\n    int slide = 0;\n    unsigned o_end_txt = 0;\n    unsigned hdrpos = sizeof(mhdro);\n    Mach_segment_command const *seg = rawmseg;\n    Mach_segment_command const *const endseg =\n        (Mach_segment_command const *)(mhdri.sizeofcmds + (char const *)seg);\n    for ( ; seg < endseg; seg = (Mach_segment_command const *)(\n            seg->cmdsize + (char const *)seg )\n    ) switch (seg->cmd & ~Mach_command::LC_REQ_DYLD) {\n    default:  // unknown if any file offset field must slide\n        fprintf(stderr, \"Unrecognized Macho cmd  offset=0x%lx  cmd=0x%lx  size=0x%lx\\n\",\n            (unsigned long)((const char *)seg - (const char *)rawmseg),\n            (unsigned long)seg->cmd, (unsigned long)seg->cmdsize);\n        // fall through\n    case Mach_command::LC_VERSION_MIN_MACOSX:\n    case Mach_command::LC_SOURCE_VERSION:\n    case Mach_command::LC_THREAD:\n    case Mach_command::LC_UNIXTHREAD:\n    case Mach_command::LC_LOAD_DYLIB:\n    case Mach_command::LC_ID_DYLIB:\n    case Mach_command::LC_LOAD_DYLINKER:\n    case Mach_command::LC_UUID:\n    case Mach_command::LC_RPATH:\n    case Mach_command::LC_REEXPORT_DYLIB: { // contain no file offset fields\n        fo->seek(hdrpos, SEEK_SET);\n        fo->rewrite(seg, seg->cmdsize);\n        hdrpos += seg->cmdsize;\n    } break;\n\n    case Mach_command::LC_CODE_SIGNATURE:\n    case Mach_command::LC_SEGMENT_SPLIT_INFO:\n    case Mach_command::LC_DYLIB_CODE_SIGN_DRS:\n    case Mach_command::LC_DATA_IN_CODE:\n    case Mach_command::LC_FUNCTION_STARTS: {\n        Mach_linkedit_data_command cmd; memcpy(&cmd, seg, sizeof(cmd));\n        if (o_end_txt <= cmd.dataoff) { cmd.dataoff += slide; }\n        fo->seek(hdrpos, SEEK_SET);\n        fo->rewrite(&cmd, sizeof(cmd));\n        hdrpos += sizeof(cmd);\n    } break;\n    case Mach_command::LC_DYLD_INFO_ONLY & ~Mach_command::LC_REQ_DYLD: {\n        Mach_dyld_info_only_command cmd; memcpy(&cmd, seg, sizeof(cmd));\n        if (o_end_txt <= cmd.rebase_off)    { cmd.rebase_off    += slide; }\n        if (o_end_txt <= cmd.bind_off)      { cmd.bind_off      += slide; }\n        if (o_end_txt <= cmd.weak_bind_off) { cmd.weak_bind_off += slide; }\n        if (o_end_txt <= cmd.lazy_bind_off) { cmd.lazy_bind_off += slide; }\n        if (o_end_txt <= cmd.export_off)    { cmd.export_off    += slide; }\n        fo->seek(hdrpos, SEEK_SET);\n        fo->rewrite(&cmd, sizeof(cmd));\n        hdrpos += sizeof(cmd);\n    } break;\n    case Mach_command::LC_TWOLEVEL_HINTS: {\n        Mach_twolevel_hints_command cmd; memcpy(&cmd, seg, sizeof(cmd));\n        if (o_end_txt <= cmd.offset) { cmd.offset += slide; }\n        fo->seek(hdrpos, SEEK_SET);\n        fo->rewrite(&cmd, sizeof(cmd));\n        hdrpos += sizeof(cmd);\n    } break;\n    case Mach_command::LC_ROUTINES_64:\n    case Mach_command::LC_ROUTINES: {\n        Mach_routines_command cmd; memcpy(&cmd, seg, sizeof(cmd));\n        cmd.reserved1 = cmd.init_address;\n        cmd.init_address = init_address;\n        fo->seek(hdrpos, SEEK_SET);\n        fo->rewrite(&cmd, sizeof(cmd));\n        hdrpos += sizeof(cmd);\n    } break;\n    case Mach_command::LC_SEGMENT_64:\n    case Mach_command::LC_SEGMENT: {\n        // non-__TEXT might be observed and relocated by dyld before us.\n        Mach_segment_command segcmdtmp = *seg;\n        bool const is_text = 0==strncmp(&seg->segname[0], \"__TEXT\", 1+ 6);\n        {\n            if (is_text) {\n                slide = 0;\n                segTEXT.vmsize = segTEXT.filesize = fo->getBytesWritten();\n                segTEXT.maxprot  |= Mach_command::VM_PROT_WRITE;\n                segcmdtmp = segTEXT;\n                opos = o_end_txt = segcmdtmp.filesize + segcmdtmp.fileoff;\n            }\n            else {\n                opos += ~PAGE_MASK & (0u - opos);  // advance to PAGE_SIZE boundary\n                slide = opos - segcmdtmp.fileoff;\n                segcmdtmp.fileoff = opos;\n            }\n\n            fo->seek(hdrpos, SEEK_SET);\n            fo->rewrite(&segcmdtmp, sizeof(segcmdtmp));\n            hdrpos += sizeof(segcmdtmp);\n\n            // Update the sections.\n            Mach_section_command const *secp =\n                (Mach_section_command const *)(const void*)(const char*)(1+ seg);\n            if (is_text) {\n                secTEXT.offset = secp->offset;\n                secTEXT.addr = segTEXT.vmaddr   + secTEXT.offset;\n                secTEXT.size = segTEXT.filesize - secTEXT.offset;\n                secp = &secTEXT;\n            }\n            unsigned const nsects = (is_text ? 1 : segcmdtmp.nsects);\n            Mach_section_command seccmdtmp;\n            for (unsigned j = 0; j < nsects; ++secp, ++j) {\n                seccmdtmp = *secp;\n                if (o_end_txt <= seccmdtmp.offset) { seccmdtmp.offset += slide; }\n                if (o_end_txt <= seccmdtmp.reloff) { seccmdtmp.reloff += slide; }\n                fo->rewrite(&seccmdtmp, sizeof(seccmdtmp));\n                hdrpos += sizeof(seccmdtmp);\n            }\n\n            if (!is_text) {\n                unsigned const len = seg->filesize;\n                MemBuffer data(len);\n                fi->seek(seg->fileoff, SEEK_SET);\n                fi->readx(data, len);\n                unsigned const pos = o__mod_init_func - seg->fileoff;\n                if (pos < seg->filesize) {\n                    if (*(unsigned *)(pos + data) != (unsigned)prev_mod_init_func) {\n                        throwCantPack(\"__mod_init_func inconsistent\");\n                    }\n                    *(unsigned *)(pos + data) = (unsigned)entryVMA;\n                }\n                fo->seek(opos, SEEK_SET);\n                fo->write(data, len);\n                opos += len;\n            }\n        }\n    } break;\n    case Mach_command::LC_SYMTAB: {\n        Mach_symtab_command cmd; memcpy(&cmd, seg, sizeof(cmd));\n        if (o_end_txt <= cmd.symoff) { cmd.symoff += slide; }\n        if (o_end_txt <= cmd.stroff) { cmd.stroff += slide; }\n        fo->seek(hdrpos, SEEK_SET);\n        fo->rewrite(&cmd, sizeof(cmd));\n        hdrpos += sizeof(cmd);\n    } break;\n    case Mach_command::LC_DYSYMTAB: {\n        Mach_dysymtab_command cmd; memcpy(&cmd, seg, sizeof(cmd));\n        if (o_end_txt <= cmd.tocoff)         { cmd.tocoff         += slide; }\n        if (o_end_txt <= cmd.modtaboff)      { cmd.modtaboff      += slide; }\n        if (o_end_txt <= cmd.extrefsymoff)   { cmd.extrefsymoff   += slide; }\n        if (o_end_txt <= cmd.indirectsymoff) { cmd.indirectsymoff += slide; }\n        if (o_end_txt <= cmd.extreloff)      { cmd.extreloff      += slide; }\n        if (o_end_txt <= cmd.locreloff)      { cmd.locreloff      += slide; }\n        fo->seek(hdrpos, SEEK_SET);\n        fo->rewrite(&cmd, sizeof(cmd));\n        hdrpos += sizeof(cmd);\n    } break;\n    }  // end 'switch'\n    fo->seek(opos, SEEK_SET);  // BUG: \"fo->seek(0, SEEK_END);\" is broken\n\n    PackMachBase<T>::pack4(fo, ft);\n}\n\nvoid PackDylibI386::pack4(OutputFile *fo, Filter &ft)  // append PackHeader\n{\n    pack4dylib(fo, ft, threado.state.eip);\n}\n\nvoid PackDylibAMD64::pack4(OutputFile *fo, Filter &ft)  // append PackHeader\n{\n    pack4dylib(fo, ft, threado.state.rip);\n}\n\nvoid PackDylibPPC32::pack4(OutputFile *fo, Filter &ft)  // append PackHeader\n{\n    pack4dylib(fo, ft, threado.state.srr0);\n}\n\nvoid PackDylibPPC64LE::pack4(OutputFile *fo, Filter &ft)  // append PackHeader\n{\n    pack4dylib(fo, ft, threado.state64.srr0);\n}\n\ntemplate <class T>\noff_t PackMachBase<T>::pack3(OutputFile *fo, Filter &ft)  // append loader\n{\n    TE32 disp;\n    upx_uint64_t const zero = 0;\n    unsigned len = fo->getBytesWritten();\n    fo->write(&zero, 3& (0u-len));\n    len += (3& (0u-len));\n\n    disp = len;  // backward offset to Mach_header\n    fo->write(&disp, sizeof(disp));\n    len += sizeof(disp);\n\n    if (my_filetype!=Mach_header::MH_DYLIB) {\n        disp = len - sz_mach_headers;  // backward offset to start of compressed data\n        fo->write(&disp, sizeof(disp));\n        len += sizeof(disp);\n    }\n    segTEXT.vmsize = segTEXT.filesize;\n    threado_setPC(entryVMA= len + segTEXT.vmaddr);\n\n    return super::pack3(fo, ft);\n}\n\noff_t PackDylibI386::pack3(OutputFile *fo, Filter &ft)  // append loader\n{\n    TE32 disp;\n    upx_uint32_t const zero = 0;\n    off_t len = fo->getBytesWritten();\n    fo->write(&zero, 3& (0u-len));\n    len += (3& (0u-len)) + 4*sizeof(disp);\n\n    disp = prev_mod_init_func;\n    fo->write(&disp, sizeof(disp));  // user .init_address\n\n    disp = secTEXT.offset + sizeof(l_info) + sizeof(p_info);\n    fo->write(&disp, sizeof(disp));  // src offset(compressed __TEXT)\n\n    disp = len - disp - 3*sizeof(disp);\n    fo->write(&disp, sizeof(disp));  // length(compressed __TEXT)\n\n    unsigned const save_sz_mach_headers(sz_mach_headers);\n    sz_mach_headers = 0;\n    len = super::pack3(fo, ft);\n    sz_mach_headers = save_sz_mach_headers;\n    return len;\n}\n\noff_t PackDylibAMD64::pack3(OutputFile *fo, Filter &ft)  // append loader\n{\n    TE32 disp;\n    upx_uint64_t const zero = 0;\n    off_t len = fo->getBytesWritten();\n    fo->write(&zero, 3& (0u-len));\n    len += (3& (0u-len)) + 3*sizeof(disp);\n\n    disp = prev_mod_init_func;\n    fo->write(&disp, sizeof(disp));  // user .init_address\n\n    disp = secTEXT.offset + sizeof(l_info) + sizeof(p_info);\n    fo->write(&disp, sizeof(disp));  // src offset(b_info)\n\n    disp = rawmseg[0].vmsize;\n    fo->write(&disp, sizeof(disp));  // __TEXT.vmsize when expanded\n\n    unsigned const save_sz_mach_headers(sz_mach_headers);\n    sz_mach_headers = 0;\n    len = super::pack3(fo, ft);\n    sz_mach_headers = save_sz_mach_headers;\n    return len;\n}\n\noff_t PackDylibPPC32::pack3(OutputFile *fo, Filter &ft)  // append loader\n{\n    TE32 disp;\n    upx_uint32_t const zero = 0;\n    off_t len = fo->getBytesWritten();\n    fo->write(&zero, 3& (0u-len));\n    len += (3& (0u-len)) + 4*sizeof(disp);\n\n    disp = prev_mod_init_func;\n    fo->write(&disp, sizeof(disp));  // user .init_address\n\n    disp = secTEXT.offset + sizeof(l_info) + sizeof(p_info);\n    fo->write(&disp, sizeof(disp));  // src offset(compressed __TEXT)\n\n    disp = len - disp - 3*sizeof(disp);\n    fo->write(&disp, sizeof(disp));  // length(compressed __TEXT)\n\n    unsigned const save_sz_mach_headers(sz_mach_headers);\n    sz_mach_headers = 0;\n    len = super::pack3(fo, ft);\n    sz_mach_headers = save_sz_mach_headers;\n    return len;\n}\n\noff_t PackDylibPPC64LE::pack3(OutputFile *fo, Filter &ft)  // append loader\n{\n    TE64 disp;\n    upx_uint64_t const zero = 0;\n    off_t len = fo->getBytesWritten();\n    fo->write(&zero, 3& (0u-len));\n    len += (3& (0u-len)) + 4*sizeof(disp);\n\n    disp = prev_mod_init_func;\n    fo->write(&disp, sizeof(disp));  // user .init_address\n\n    disp = secTEXT.offset + sizeof(l_info) + sizeof(p_info);\n    fo->write(&disp, sizeof(disp));  // src offset(compressed __TEXT)\n\n    disp = len - disp - 3*sizeof(disp);\n    fo->write(&disp, sizeof(disp));  // length(compressed __TEXT)\n\n    unsigned const save_sz_mach_headers(sz_mach_headers);\n    sz_mach_headers = 0;\n    len = super::pack3(fo, ft);\n    sz_mach_headers = save_sz_mach_headers;\n    return len;\n}\n\n// Determine length of gap between PT_LOAD phdri[k] and closest PT_LOAD\n// which follows in the file (or end-of-file).  Optimize for common case\n// where the PT_LOAD are adjacent ascending by .p_offset.  Assume no overlap.\n\ntemplate <class T>\nunsigned PackMachBase<T>::find_SEGMENT_gap(\n    unsigned const k, unsigned pos_eof\n)\n{\n    unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];\n    if (lc_seg!=msegcmd[k].cmd\n    ||  0==msegcmd[k].filesize ) {\n        return 0;\n    }\n    unsigned const hi = msegcmd[k].fileoff + msegcmd[k].filesize;\n    unsigned lo = pos_eof;\n    unsigned j = k;\n    for (;;) { // circular search, optimize for adjacent ascending\n        ++j;\n        if (n_segment==j) {\n            j = 0;\n        }\n        if (k==j) {\n            break;\n        }\n        if (lc_seg==msegcmd[j].cmd\n        &&  0!=msegcmd[j].filesize ) {\n            unsigned const t = (unsigned) msegcmd[j].fileoff;\n            if ((t - hi) < (lo - hi)) {\n                lo = t;\n                if (hi==lo) {\n                    break;\n                }\n            }\n        }\n    }\n    return lo - hi;\n}\n\ntemplate <class T>\nint  PackMachBase<T>::pack2(OutputFile *fo, Filter &ft)  // append compressed body\n{\n    unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];\n    Extent x;\n    unsigned k;\n\n    // count passes, set ptload vars\n    uip->ui_total_passes = 0;\n    for (k = 0; k < n_segment; ++k) {\n        if (lc_seg==msegcmd[k].cmd\n        &&  0!=msegcmd[k].filesize ) {\n            uip->ui_total_passes++;\n            if (my_filetype==Mach_header::MH_DYLIB) {\n                break;\n            }\n            if (find_SEGMENT_gap(k, fi->st_size())) {\n                uip->ui_total_passes++;\n            }\n        }\n    }\n\n    // compress extents\n    total_in = 0;\n    total_out = 0;\n\n    unsigned hdr_u_len = mhdri.sizeofcmds + sizeof(mhdri);\n\n    uip->ui_pass = 0;\n    ft.addvalue = 0;\n\n    // Packer::compressWithFilters chooses a filter for us, and the stubs\n    // can handle only one filter, and most filters are for executable\n    // instructions.  So filter only the largest executable segment.\n    unsigned exe_filesize_max = 0;\n    for (k = 0; k < n_segment; ++k)\n    if (lc_seg==msegcmd[k].cmd\n    &&  0!=(Mach_command::VM_PROT_EXECUTE & msegcmd[k].initprot)\n    &&  exe_filesize_max < msegcmd[k].filesize) {\n        exe_filesize_max = (unsigned) msegcmd[k].filesize;\n    }\n\n    int nx = 0;\n    for (k = 0; k < n_segment; ++k)\n    if (lc_seg==msegcmd[k].cmd\n    &&  0!=msegcmd[k].filesize ) {\n        x.offset = msegcmd[k].fileoff;\n        x.size   = msegcmd[k].filesize;\n        if (0 == nx) { // 1st LC_SEGMENT must cover Mach_header at 0==fileoffset\n            unsigned const delta = mhdri.sizeofcmds + sizeof(mhdri);\n            x.offset    += delta;\n            x.size      -= delta;\n        }\n        bool const do_filter = (msegcmd[k].filesize==exe_filesize_max)\n            && 0!=(Mach_command::VM_PROT_EXECUTE & msegcmd[k].initprot);\n        Mach_segment_command const *ptr = rawmseg;\n        unsigned b_extra = 0;\n        for (unsigned j= 0; j < mhdri.ncmds; ++j) {\n            if (msegcmd[k].cmd    == ptr->cmd\n            &&  msegcmd[k].vmaddr == ptr->vmaddr\n            &&  msegcmd[k].vmsize == ptr->vmsize) {\n                b_extra = j;\n                break;\n            }\n            ptr = (Mach_segment_command const *)(ptr->cmdsize + (char const *)ptr);\n        }\n        packExtent(x,\n            (do_filter ? &ft : nullptr), fo, hdr_u_len, b_extra );\n        if (do_filter) {\n            exe_filesize_max = 0;\n        }\n        hdr_u_len = 0;\n        ++nx;\n        if (my_filetype==Mach_header::MH_DYLIB) {\n            break;\n        }\n    }\n    if (my_filetype!=Mach_header::MH_DYLIB)\n    for (k = 0; k < n_segment; ++k) {\n        x.size = find_SEGMENT_gap(k, fi->st_size());\n        if (x.size) {\n            x.offset = msegcmd[k].fileoff +msegcmd[k].filesize;\n            packExtent(x, nullptr, fo);\n        }\n    }\n\n    if (my_filetype!=Mach_header::MH_DYLIB)\n    if ((off_t)total_in != file_size)\n        throwEOFException();\n    segTEXT.filesize = fo->getBytesWritten();\n    secTEXT.size = segTEXT.filesize - overlay_offset + sizeof(linfo);\n\n    return 1;\n}\n\nvoid PackMachPPC32::pack1_setup_threado(OutputFile *const fo)\n{\n    threado.cmd = Mach_command::LC_UNIXTHREAD;\n    threado.cmdsize = sizeof(threado);\n    threado.flavor = my_thread_flavor;\n    threado.count =  my_thread_state_word_count;\n    memset(&threado.state, 0, sizeof(threado.state));\n    fo->write(&threado, sizeof(threado));\n}\n\nvoid PackMachPPC64LE::pack1_setup_threado(OutputFile *const fo)\n{\n    threado.cmd = Mach_command::LC_UNIXTHREAD;\n    threado.cmdsize = sizeof(threado);\n    threado.flavor = my_thread_flavor;\n    threado.count =  my_thread_state_word_count;\n    memset(&threado.state64, 0, sizeof(threado.state64));\n    fo->write(&threado, sizeof(threado));\n}\n\nvoid PackMachI386::pack1_setup_threado(OutputFile *const fo)\n{\n    threado.cmd = Mach_command::LC_UNIXTHREAD;\n    threado.cmdsize = sizeof(threado);\n    threado.flavor = my_thread_flavor;\n    threado.count =  my_thread_state_word_count;\n    memset(&threado.state, 0, sizeof(threado.state));\n    fo->write(&threado, sizeof(threado));\n}\n\nvoid PackMachAMD64::pack1_setup_threado(OutputFile *const fo)\n{\n    threado.cmd = Mach_command::LC_UNIXTHREAD;\n    threado.cmdsize = sizeof(threado);\n    threado.flavor = my_thread_flavor;\n    threado.count =  my_thread_state_word_count;\n    memset(&threado.state, 0, sizeof(threado.state));\n    fo->write(&threado, sizeof(threado));\n}\n\nvoid PackMachARMEL::pack1_setup_threado(OutputFile *const fo)\n{\n    threado.cmd = Mach_command::LC_UNIXTHREAD;\n    threado.cmdsize = sizeof(threado);\n    threado.flavor = my_thread_flavor;\n    threado.count =  my_thread_state_word_count;\n    memset(&threado.state, 0, sizeof(threado.state));\n    fo->write(&threado, sizeof(threado));\n}\n\nvoid PackMachARM64EL::pack1_setup_threado(OutputFile *const fo)\n{\n    threado.cmd = Mach_command::LC_UNIXTHREAD;\n    threado.cmdsize = sizeof(threado);\n    threado.flavor = my_thread_flavor;\n    threado.count =  my_thread_state_word_count;\n    memset(&threado.state, 0, sizeof(threado.state));\n    fo->write(&threado, sizeof(threado));\n}\n\ntemplate <class T>\nvoid PackMachBase<T>::pack1(OutputFile *const fo, Filter &/*ft*/)  // generate executable header\n{\n    unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];\n    mhdro = mhdri;\n    if (my_filetype==Mach_header::MH_EXECUTE) {\n        memcpy(&mhdro, stub_main, sizeof(mhdro));\n        mhdro.flags = mhdri.flags & ~(\n              Mach_header::MH_DYLDLINK  // no dyld at this time\n            | Mach_header::MH_TWOLEVEL  // dyld-specific\n            | Mach_header::MH_BINDATLOAD  // dyld-specific\n            );\n        COMPILE_TIME_ASSERT(sizeof(mhdro.flags) == sizeof(unsigned))\n    }\n    unsigned pos = sizeof(mhdro);\n    fo->write(&mhdro, sizeof(mhdro));\n\n    memset(&segZERO, 0, sizeof(segZERO));\n    segZERO.cmd = lc_seg;\n    segZERO.cmdsize = sizeof(segZERO);\n    strncpy((char *)segZERO.segname, \"__PAGEZERO\", sizeof(segZERO.segname));\n    segZERO.vmsize = PAGE_SIZE;\n    if __acc_cte(sizeof(segZERO.vmsize) == 8\n    && mhdro.filetype == Mach_header::MH_EXECUTE\n    && mhdro.cputype == Mach_header::CPU_TYPE_X86_64) {\n        if (pagezero_vmsize < 0xF0000000ull) {\n            segZERO.vmsize = pagezero_vmsize;\n        }\n        else {\n            segZERO.vmsize <<= 20;  // (1ul<<32)\n        }\n    }\n\n    segTEXT.cmd = lc_seg;\n    segTEXT.cmdsize = sizeof(segTEXT) + sizeof(secTEXT);\n    strncpy((char *)segTEXT.segname, \"__TEXT\", sizeof(segTEXT.segname));\n    if (my_filetype==Mach_header::MH_EXECUTE) {\n        if (Mach_header::MH_PIE & mhdri.flags) {\n            segTEXT.vmaddr = segZERO.vmsize;  // contiguous\n        }\n        else { // not MH_PIE\n            // Start above all eventual mappings.\n            // Cannot enlarge segZERO.vmsize because MacOS 10.13 (HighSierra)\n            // won't permit re-map of PAGEZERO.\n            // Stub will fill with PROT_NONE first.\n            segTEXT.vmaddr = vma_max;\n        }\n    }\n    if (my_filetype==Mach_header::MH_DYLIB) {\n        segTEXT.vmaddr = 0;\n    }\n    segTEXT.vmsize = 0;    // adjust later\n    segTEXT.fileoff = 0;\n    segTEXT.filesize = 0;  // adjust later\n    segTEXT.maxprot =\n        Mach_command::VM_PROT_READ |\n        Mach_command::VM_PROT_WRITE |\n        Mach_command::VM_PROT_EXECUTE;\n    segTEXT.initprot =\n        Mach_command::VM_PROT_READ |\n        Mach_command::VM_PROT_EXECUTE;\n    segTEXT.nsects = 1;  // secTEXT\n    segTEXT.flags = 0;\n\n    memset(&secTEXT, 0, sizeof(secTEXT));\n    strncpy((char *)secTEXT.sectname, \"__text\", sizeof(secTEXT.sectname));\n    memcpy(secTEXT.segname, segTEXT.segname, sizeof(secTEXT.segname));\n    secTEXT.align = 2;  // (1<<2) ==> 4\n    secTEXT.flags = Mach_section_command::S_REGULAR\n        | Mach_section_command::S_ATTR_SOME_INSTRUCTIONS\n        | Mach_section_command::S_ATTR_PURE_INSTRUCTIONS;\n\n    segXHDR = segTEXT;\n    segXHDR.cmdsize = sizeof(segXHDR) + sizeof(secXHDR);\n    segXHDR.vmaddr = segZERO.vmsize;\n    segXHDR.vmsize = PAGE_SIZE;\n    segXHDR.filesize = PAGE_SIZE;\n    segXHDR.nsects = 1;\n    strncpy((char *)segXHDR.segname,  \"UPX_DATA\", sizeof(segXHDR.segname));\n\n    memset(&secXHDR, 0, sizeof(secXHDR));\n    strncpy((char *)secXHDR.sectname, \"upx_data\", sizeof(secXHDR.sectname));\n    memcpy(secXHDR.segname,  segXHDR.segname, sizeof(secXHDR.segname));\n    secXHDR.addr = segXHDR.vmaddr;\n    secXHDR.size = 0;  // empty so far\n    secXHDR.align = 2;  // (1<<2) ==> 4\n\n    segLINK = segTEXT;\n    segLINK.cmdsize = sizeof(segLINK);\n    strncpy((char *)segLINK.segname, \"__LINKEDIT\", sizeof(segLINK.segname));\n    segLINK.initprot = Mach_command::VM_PROT_READ;\n    segLINK.nsects = 0;\n    segLINK.vmsize = 0;\n    // Adjust later: .vmaddr .vmsize .fileoff .filesize\n\n    unsigned gap = 0;\n    if (my_filetype == Mach_header::MH_EXECUTE) {\n        unsigned cmdsize = mhdro.sizeofcmds;\n        Mach_header const *const ptr0 = (Mach_header const *)stub_main;\n        Mach_command const *ptr1 = (Mach_command const *)(1+ ptr0);\n        for (unsigned j = 0; j < mhdro.ncmds -1; ++j, (cmdsize -= ptr1->cmdsize),\n                ptr1 = (Mach_command const *)(ptr1->cmdsize + (char const *)ptr1)) {\n            if (lc_seg == ptr1->cmd) {\n                Mach_segment_command const *const segptr = (Mach_segment_command const *)ptr1;\n                Mach_section_command const *const secptr = (Mach_section_command const *)(1+ segptr);\n                if (!strcmp(\"__TEXT\", segptr->segname)) {\n                    strncpy((char *)secTEXT.segname,   \"__TEXT\", sizeof(secTEXT.segname));\n                    strncpy((char *)secTEXT.sectname, \"upxTEXT\", sizeof(secTEXT.sectname));\n                    secTEXT.addr   = secptr->addr;\n                    secTEXT.size   = secptr->size;  // update later\n                    secTEXT.offset = secptr->offset;\n                    secTEXT.align  = secptr->align;\n                }\n                if (!strcmp(\"__LINKEDIT\", segptr->segname)) {\n                    // Mach_command before __LINKEDIT\n                    pos += (char const *)ptr1 - (char const *)(1+ ptr0);\n                    fo->write((1+ ptr0), (char const *)ptr1 - (char const *)(1+ ptr0));\n\n                    // Mach_command __LINKEDIT and after\n                    pos += cmdsize;\n                    fo->write((char const *)ptr1, cmdsize);\n\n                    // 400: space for LC_UUID, LC_RPATH, LC_CODE_SIGNATURE, etc.\n                    gap = 400 + threado_size();\n                    secTEXT.offset = gap + pos;\n                    secTEXT.addr = secTEXT.offset + segTEXT.vmaddr;\n                    break;\n                }\n            }\n        }\n        unsigned const sz_threado = threado_size();\n        MemBuffer space(sz_threado); memset(space, 0, sz_threado);\n        fo->write(space, sz_threado);\n    }\n    else if (my_filetype == Mach_header::MH_DYLIB) {\n        Mach_command const *ptr = (Mach_command const *)rawmseg;\n        unsigned cmdsize = mhdri.sizeofcmds;\n        for (unsigned j = 0; j < mhdri.ncmds; ++j, (cmdsize -= ptr->cmdsize),\n                ptr = (Mach_command const *)(ptr->cmdsize + (char const *)ptr)) {\n            if (lc_seg == ptr->cmd) {\n                Mach_segment_command const *const segptr = (Mach_segment_command const *)ptr;\n                Mach_section_command const *const secptr = (Mach_section_command const *)(1+ segptr);\n                if (!strcmp(\"__TEXT\", segptr->segname)) {\n                    if (!(1 <= segptr->nsects)) {\n                        throwCantPack(\"TEXT.nsects == 0\");\n                    }\n                    strncpy((char *)secTEXT.sectname, \"upxTEXT\", sizeof(secTEXT.sectname));\n                    secTEXT.addr   = secptr->addr;\n                    secTEXT.size   = secptr->size;  // update later\n                    secTEXT.offset = secptr->offset;\n                    secTEXT.align  = secptr->align;\n                    fo->write(&segTEXT, sizeof(segTEXT));\n                    fo->write(&secTEXT, sizeof(secTEXT));\n                }\n                else { // not __TEXT\n                    fo->write(ptr, ptr->cmdsize);\n                }\n            }\n            else { // not LC_SEGMENT*\n                fo->write(ptr, ptr->cmdsize);\n            }\n        }\n        memset(&linkitem, 0, sizeof(linkitem));\n        fo->write(&linkitem, sizeof(linkitem));\n    }\n    sz_mach_headers = fo->getBytesWritten();\n    gap = secTEXT.offset - sz_mach_headers;\n    MemBuffer filler(gap); filler.clear();\n    fo->write(filler, gap);\n    sz_mach_headers += gap;\n\n    memset((char *)&linfo, 0, sizeof(linfo));\n    fo->write(&linfo, sizeof(linfo));\n\n    return;\n}\n\n#define WANT_MACH_HEADER_ENUM 1\n#include \"p_mach_enum.h\"\n\nstatic unsigned\numin(unsigned a, unsigned b)\n{\n    return (a <= b) ? a : b;\n}\n\ntemplate <class T>\nvoid PackMachBase<T>::unpack(OutputFile *fo)\n{\n    unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];\n    fi->seek(0, SEEK_SET);\n    fi->readx(&mhdri, sizeof(mhdri));\n    if ((MH_MAGIC + (sizeof(Addr)>>3)) != mhdri.magic\n    &&  Mach_fat_header::FAT_MAGIC != mhdri.magic) {\n        throwCantUnpack(\"file header corrupted\");\n    }\n    unsigned const sz_cmds = mhdri.sizeofcmds;\n    if ((sizeof(mhdri) + sz_cmds) > (size_t)fi->st_size()) {\n        throwCantUnpack(\"file header corrupted\");\n    }\n    rawmseg_buf.dealloc();  // discard \"same\" contents from ::canUnpack()\n    rawmseg_buf.alloc(sz_cmds);\n    rawmseg = (Mach_segment_command *)rawmseg_buf.getVoidPtr();\n    fi->readx(rawmseg, mhdri.sizeofcmds);\n\n    // FIXME forgot space left for LC_CODE_SIGNATURE;\n    // but canUnpack() sets overlay_offset anyway.\n    //overlay_offset = sizeof(mhdri) + mhdri.sizeofcmds + sizeof(linfo);\n\n    fi->seek(overlay_offset, SEEK_SET);\n    p_info hbuf;\n    fi->readx(&hbuf, sizeof(hbuf));\n    unsigned const orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);  // emacs-21.2.1 was 0x01d47e6c (== 30703212)\n    if (blocksize > orig_file_size || blocksize > UPX_RSIZE_MAX_MEM)\n        throwCantUnpack(\"file header corrupted\");\n    if (file_size > (off_t)orig_file_size) {\n        opt->info_mode += !opt->info_mode ? 1 : 0;  // make visible\n        opt->backup = 1;\n        infoWarning(\"packed size too big; discarding appended data, keeping backup\");\n    }\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, sizeof(bhdr));\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if ((unsigned)file_size < ph.c_len || ph.c_len == 0 || ph.u_len == 0)\n        throwCantUnpack(\"file header corrupted\");\n    ph.method = bhdr.b_method;\n    ph.filter = bhdr.b_ftid;\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Uncompress Macho headers\n    fi->readx(ibuf, ph.c_len);\n    MemBuffer mhdr_buf(ph.u_len);\n    Mach_header *const mhdr = (Mach_header *)mhdr_buf.getVoidPtr();\n    decompress(ibuf, (upx_byte *)mhdr, false);\n    if (mhdri.magic      != mhdr->magic\n    ||  mhdri.cputype    != mhdr->cputype\n    ||  mhdri.cpusubtype != mhdr->cpusubtype\n    ||  mhdri.filetype   != mhdr->filetype)\n        throwCantUnpack(\"file header corrupted\");\n    unsigned const ncmds = mhdr->ncmds;\n\n    msegcmd_buf.alloc(sizeof(Mach_segment_command) * ncmds);\n    msegcmd = (Mach_segment_command *)msegcmd_buf.getVoidPtr();\n    unsigned char const *ptr = (unsigned char const *)(1+mhdr);\n    for (unsigned j= 0; j < ncmds; ++j) {\n        unsigned char const *const next = ((Mach_command const *)ptr)->cmdsize + ptr;\n        if (ptr_udiff(next, (1+ mhdr)) > ph.u_len) {\n            char msg[50]; snprintf(msg, sizeof(msg), \"cmdsize[%d] %#x\",\n                j, (unsigned)(next - ptr));\n            throwCantUnpack(msg);\n        }\n        memcpy(&msegcmd[j], ptr, umin(sizeof(Mach_segment_command),\n            ((Mach_command const *)ptr)->cmdsize));\n        ptr = next;\n    }\n\n    // Put LC_SEGMENT together at the beginning\n    qsort(msegcmd, ncmds, sizeof(*msegcmd), compare_segment_command);\n    n_segment = 0;\n    for (unsigned j= 0; j < ncmds; ++j) {\n        n_segment += (lc_seg==msegcmd[j].cmd);\n    }\n\n    total_in = 0;\n    total_out = 0;\n    unsigned c_adler = upx_adler32(nullptr, 0);\n    unsigned u_adler = upx_adler32(nullptr, 0);\n\n    fi->seek(- (off_t)(sizeof(bhdr) + ph.c_len), SEEK_CUR);\n    for (unsigned k = 0; k < ncmds; ++k) {\n        if (msegcmd[k].cmd==lc_seg && msegcmd[k].filesize!=0) {\n            if (!strcmp(\"__TEXT\", msegcmd[k].segname)) {\n                segTEXT = msegcmd[k];\n            }\n            if (fo)\n                fo->seek(msegcmd[k].fileoff, SEEK_SET);\n            unpackExtent(msegcmd[k].filesize, fo,\n                c_adler, u_adler, false, sizeof(bhdr));\n            if (my_filetype==Mach_header::MH_DYLIB) {\n                break;  // only the first lc_seg when MH_DYLIB\n            }\n        }\n    }\n    Mach_segment_command const *sc = (Mach_segment_command const *)(void *)(1+ mhdr);\n    if (my_filetype==Mach_header::MH_DYLIB) { // rest of lc_seg are not compressed\n        upx_uint64_t cpr_mod_init_func(0);\n                TE32 unc_mod_init_func; *(int *)&unc_mod_init_func = 0;\n        Mach_segment_command const *rc = rawmseg;\n        rc = (Mach_segment_command const *)(rc->cmdsize + (char const *)rc);\n        sc = (Mach_segment_command const *)(sc->cmdsize + (char const *)sc);\n        for (\n            unsigned k=1;  // skip first lc_seg, which was uncompressed above\n            k < ncmds;\n            (++k), (sc = (Mach_segment_command const *)(sc->cmdsize + (char const *)sc)),\n                   (rc = (Mach_segment_command const *)(rc->cmdsize + (char const *)rc))\n        ) {\n            if (lc_seg==rc->cmd\n            &&  0!=rc->filesize ) {\n                if (!strcmp(\"__DATA\", rc->segname)) {\n                    cpr_mod_init_func = get_mod_init_func(rc);\n                    fi->seek(cpr_mod_init_func - 4*sizeof(TE32), SEEK_SET);\n                    fi->readx(&unc_mod_init_func, sizeof(unc_mod_init_func));\n                }\n                fi->seek(rc->fileoff, SEEK_SET);\n                if (fo)\n                    fo->seek(sc->fileoff, SEEK_SET);\n                unsigned const len = rc->filesize;\n                MemBuffer data(len);\n                fi->readx(data, len);\n                if (!strcmp(\"__DATA\", rc->segname)) {\n                    set_te32(&data[o__mod_init_func - rc->fileoff], unc_mod_init_func);\n                }\n                if (fo)\n                    fo->write(data, len);\n            }\n        }\n    }\n    else\n    for (unsigned j = 0; j < ncmds; ++j) {\n        unsigned const size = find_SEGMENT_gap(j, orig_file_size);\n        if (size) {\n            unsigned const where = msegcmd[j].fileoff +msegcmd[j].filesize;\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo,\n                c_adler, u_adler, false, sizeof(bhdr));\n        }\n    }\n}\n\n// The prize is the value of overlay_offset: the offset of compressed data\ntemplate <class T>\nint PackMachBase<T>::canUnpack()\n{\n    unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];\n    fi->seek(0, SEEK_SET);\n    fi->readx(&mhdri, sizeof(mhdri));\n\n    if (((unsigned) Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) !=mhdri.magic\n    ||  my_cputype   !=mhdri.cputype\n    ||  my_filetype  !=mhdri.filetype\n    )\n        return false;\n    my_cpusubtype = mhdri.cpusubtype;\n\n    unsigned const ncmds = mhdri.ncmds;\n    int headway = (int)mhdri.sizeofcmds;\n    // old style:   LC_SEGMENT + LC_UNIXTHREAD  [smaller, varies by $ARCH]\n    // new style: 3*LC_SEGMENT + LC_MAIN        [larger]\n    if ((2 == ncmds\n        && headway < (int)(sizeof(Mach_segment_command) + 4*4))\n    ||  (3 <= ncmds\n        && headway < (int)(3 * sizeof(Mach_segment_command)\n                    + sizeof(Mach_main_command)))) {\n        infoWarning(\"Mach_header.sizeofcmds = %d too small\", headway);\n        throwCantUnpack(\"file corrupted\");\n    }\n    sz_mach_headers = headway + sizeof(mhdri);\n    if (2048 < headway) {\n        infoWarning(\"Mach_header.sizeofcmds(%d) > 2048\", headway);\n    }\n    rawmseg_buf.alloc(mhdri.sizeofcmds);\n    rawmseg = (Mach_segment_command *)rawmseg_buf.getVoidPtr();\n    fi->readx(rawmseg, mhdri.sizeofcmds);\n\n    Mach_segment_command const *ptrTEXT = nullptr;\n    upx_uint64_t rip = 0;\n    unsigned style = 0;\n    off_t offLINK = 0;\n    unsigned pos_next = 0;\n    unsigned nseg = 0;\n    Mach_command const *ptr = (Mach_command const *)rawmseg;\n    for (unsigned j= 0; j < ncmds;\n            ptr = (Mach_command const *)(ptr->cmdsize + (char const *)ptr), ++j) {\n        if ((unsigned)headway < ptr->cmdsize) {\n                infoWarning(\"bad Mach_command[%u]{@0x%lx,+0x%x}: file_size=0x%lx  cmdsize=0x%lx\",\n                    j, (unsigned long) (sizeof(mhdri) + ((char const *)ptr - (char const *)rawmseg)), headway,\n                    (unsigned long) file_size, (unsigned long)ptr->cmdsize);\n                throwCantUnpack(\"file corrupted\");\n        }\n        if (lc_seg == ptr->cmd) {\n            Mach_segment_command const *const segptr = (Mach_segment_command const *)ptr;\n            if ((unsigned long)file_size < segptr->filesize\n            ||  (unsigned long)file_size < segptr->fileoff\n            ||  (unsigned long)file_size < (segptr->filesize + segptr->fileoff)) {\n                infoWarning(\"bad Mach_segment_command[%u]{@0x%lx,+0x%x}: file_size=0x%lx  cmdsize=0x%lx\"\n                      \"  filesize=0x%lx  fileoff=0x%lx\",\n                    j, (unsigned long) (sizeof(mhdri) + ((char const *)ptr - (char const *)rawmseg)), headway,\n                    (unsigned long) file_size, (unsigned long)ptr->cmdsize,\n                    (unsigned long)segptr->filesize, (unsigned long)segptr->fileoff);\n                throwCantUnpack(\"file corrupted\");\n            }\n            ++nseg;\n            if (!strcmp(\"__XHDR\", segptr->segname)) {\n                // PackHeader precedes __LINKEDIT (pre-Sierra MacOS 10.12)\n                style = 391;  // UPX 3.91\n            }\n            if (!strcmp(\"__TEXT\", segptr->segname)) {\n                ptrTEXT = segptr;\n                style = 391;  // UPX 3.91\n            }\n            if (!strcmp(\"UPX_DATA\", segptr->segname)) {\n                // PackHeader follows loader at __LINKEDIT (Sierra MacOS 10.12)\n                style = 392;  // UPX 3.92\n            }\n            if (!strcmp(\"__LINKEDIT\", segptr->segname)) {\n                offLINK = segptr->fileoff;\n                if (segptr->filesize == blankLINK) {\n                    style = 395;\n                }\n                if (offLINK < (off_t) pos_next) {\n                    offLINK = pos_next;\n                }\n            }\n            pos_next = segptr->filesize + segptr->fileoff;\n            if ((headway -= ptr->cmdsize) < 0) {\n                infoWarning(\"Mach_command[%u]{@%lu}.cmdsize = %u\", j,\n                    (unsigned long) (sizeof(mhdri) + mhdri.sizeofcmds - (headway + ptr->cmdsize)),\n                    (unsigned)ptr->cmdsize);\n                throwCantUnpack(\"sum(.cmdsize) exceeds .sizeofcmds\");\n            }\n        }\n        else if (Mach_command::LC_UNIXTHREAD==ptr->cmd) {\n            rip = entryVMA = threadc_getPC(ptr);\n        }\n    }\n    if (3==nseg && 395 != style) { // __PAGEZERO, __TEXT, __LINKEDIT;  no __XHDR, no UPX_DATA\n        style = 392;\n    }\n    if (391==style && 0==offLINK && 2==ncmds && ptrTEXT) { // pre-3.91 ?\n        offLINK = ptrTEXT->fileoff + ptrTEXT->filesize;  // fake __LINKEDIT at EOF\n    }\n    if (0 == style || 0 == offLINK) {\n        return false;\n    }\n\n    int const small = 32 + sizeof(overlay_offset);\n    unsigned bufsize = 4096;\n    if (391 == style) { // PackHeader precedes __LINKEDIT\n        fi->seek(offLINK - bufsize, SEEK_SET);\n    } else\n    if (392 == style) {\n        if (MH_DYLIB == my_filetype) {\n            fi->seek(fi->st_size() - bufsize, SEEK_SET);\n        }\n        else { // PackHeader follows loader at __LINKEDIT\n            if ((off_t)bufsize > (fi->st_size() - offLINK)) {\n                bufsize = fi->st_size() - offLINK;\n            }\n            fi->seek(offLINK, SEEK_SET);\n        }\n    } else\n    if (395 == style) {\n        fi->seek(offLINK - bufsize - sizeof(PackHeader), SEEK_SET);\n    }\n    MemBuffer buf(bufsize);\n\n    fi->readx(buf, bufsize);\n    int i = bufsize;\n    while (i > small && 0 == buf[--i]) { }\n    i -= small;\n    // allow incompressible extents\n    if (i < 1 || !getPackHeader(buf + i, bufsize - i, true)) {\n        // Breadcrumbs failed.\n        // Pirates might overwrite the UPX! marker.  Try harder.\n        upx_uint64_t const rip_off = ptrTEXT ? (rip - ptrTEXT->vmaddr) : 0;\n        if (ptrTEXT && rip && rip_off < ptrTEXT->vmsize) {\n            fi->seek(ptrTEXT->fileoff + rip_off, SEEK_SET);\n            fi->readx(buf, bufsize);\n            unsigned char const *b = &buf[0];\n            unsigned disp = *(TE32 const *)&b[1];\n            // Emulate the code\n            if (0xe8==b[0] && disp < bufsize\n            &&  0x5d==b[5+disp] && 0xe8==b[6+disp]) {\n                unsigned disp2 = 0u - *(TE32 const *)&b[7+disp];\n                if (disp2 < (12+disp) && 0x5b==b[11+disp-disp2]) {\n                    struct b_info const *bptr = (struct b_info const *)&b[11+disp];\n                    // This is the folded stub.\n                    // FIXME: check b_method?\n                    if (bptr->sz_cpr < bptr->sz_unc && bptr->sz_unc < 0x1000) {\n                        b = bptr->sz_cpr + (unsigned char const *)(1+ bptr);\n                        // FIXME: check PackHeader::putPackHeader(), packhead.cpp\n                        overlay_offset = *(TE32 const *)(32 + b);\n                        if (overlay_offset < 0x1000) {\n                            return true;  // success\n                        }\n                        overlay_offset = 0;\n                    }\n                }\n            }\n        }\n        if (391==style) {\n            TE32 const *uptr = (TE32 const *)&buf[bufsize];\n            while (0==*--uptr) /*empty*/ ;\n            overlay_offset = *uptr;\n            if (mhdri.sizeofcmds <= overlay_offset && overlay_offset < 0x1000) {\n                return true;  // success\n            }\n            overlay_offset = 0;\n            return false;\n        }\n        if (392==style) {\n            overlay_offset = 0x100c;  // (l_info precedes;) p_info; b_info; cpr_data\n            // p_info isn't used for execution, so it has less value for checking:\n            //      0== .p_progid\n            //      .p_filesize == .p_blocksize\n            fi->seek(overlay_offset, SEEK_SET);\n            fi->readx(buf, bufsize);\n            struct p_info const *const p_ptr = (struct p_info const *)&buf[0];\n            struct b_info const *const b_ptr = (struct b_info const *)(1+ p_ptr);\n            TE32 const *uptr = (TE32 const *)(1+ b_ptr);\n            if (b_ptr->sz_unc < 0x4000\n            &&  b_ptr->sz_cpr < b_ptr->sz_unc ) {\n                unsigned const method = b_ptr->b_method;\n                if ((M_NRV2B_LE32 == method || M_NRV2E_LE32 == method)\n                &&  (0xff>>2)==(uptr[0] >> (2+ 24))  // 1st 6 bytes are unique literals\n                &&  (Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) == uptr[1]) {\n                    return true;\n                }\n                unsigned const magic = get_te32(1+ (char const *)uptr);\n                if ((M_NRV2B_8 == method || M_NRV2E_8 == method)\n                && 0xfc==(0xfc & uptr[0])\n                &&  (Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) == magic) {\n                    return true;\n                }\n                // FIXME: M_LZMA\n            }\n\n            overlay_offset = 0;\n            // The first non-zero word scanning backwards from __LINKEDIT.fileoff\n            // is the total length of compressed data which precedes it\n            //(distance to l_info), so that's another method.\n            fi->seek(offLINK - 0x1000, SEEK_SET);\n            fi->readx(buf, 0x1000);\n            unsigned const *const lo = (unsigned const *)&buf[0];\n            unsigned const *p;\n            for (p = (unsigned const *)&buf[0x1000]; p > lo; ) if (*--p) {\n                overlay_offset  = *(TE32 const *)p;\n                if ((off_t)overlay_offset < offLINK) {\n                    overlay_offset = ((char const *)p - (char const *)lo) +\n                        (offLINK - 0x1000) - overlay_offset + sizeof(l_info);\n                    fi->seek(overlay_offset, SEEK_SET);\n                    fi->readx(buf, bufsize);\n                    if (b_ptr->sz_unc < 0x4000\n                    &&  b_ptr->sz_cpr < b_ptr->sz_unc ) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n\n    overlay_offset = 0;  // impossible value\n    int l = ph.buf_offset + ph.getPackHeaderSize();\n    if (0 <= l && (unsigned)(l + sizeof(TE32)) <=bufsize) {\n        overlay_offset = get_te32(buf + i + l);\n    }\n    if (       overlay_offset < sz_mach_headers\n    ||  (off_t)overlay_offset >= file_size) {\n        infoWarning(\"file corrupted\");\n        MemBuffer buf2(umin(1<<14, file_size));\n        fi->seek(sz_mach_headers, SEEK_SET);\n        fi->readx(buf2, buf2.getSize());\n        unsigned const *p = (unsigned const *)&buf2[0];\n        unsigned const *const e_buf2 = (unsigned const *)&buf2[buf2.getSize() - 4*sizeof(*p)];\n        for (; p <= e_buf2; ++p)\n        if (   0==p[0]  // p_info.p_progid\n        &&     0!=p[1]  // p_info.p_filesize\n        &&  p[2]==p[1]  // p_info.p_blocksize == p_info.p_filesize\n        &&  (unsigned)file_size < get_te32(&p[1])  // compression was worthwhile\n        &&  sz_mach_headers==get_te32(&p[3])  // b_info.sz_unc\n        ) {\n            overlay_offset = ((char const *)p - (char const *)&buf2[0]) + sz_mach_headers;\n            if (!(3&overlay_offset  // not word aligned\n                    ||        overlay_offset < sz_mach_headers\n                    || (off_t)overlay_offset >= file_size)) {\n                infoWarning(\"attempting recovery, overlay_offset = %#x\", overlay_offset);\n                return true;\n            }\n        }\n        throwCantUnpack(\"file corrupted\");\n    }\n    return true;\n}\n#define WANT_MACH_SEGMENT_ENUM\n#define WANT_MACH_SECTION_ENUM\n#include \"p_mach_enum.h\"\n\ntemplate <class T>\nupx_uint64_t PackMachBase<T>::get_mod_init_func(Mach_segment_command const *segptr)\n{\n    for (Mach_section_command const *secptr = (Mach_section_command const *)(1+ segptr);\n        ptr_udiff(secptr, segptr) < segptr->cmdsize;\n        ++secptr\n    ) {\n        if (sizeof(Addr) == secptr->size\n        && !strcmp(\"__mod_init_func\", secptr->sectname)) {\n            o__mod_init_func = secptr->offset;\n            fi->seek(o__mod_init_func, SEEK_SET);\n            Addr tmp;\n            fi->readx(&tmp, sizeof(Addr));\n            return tmp;\n        }\n    }\n    return 0;\n}\n\ntemplate <class T>\nbool PackMachBase<T>::canPack()\n{\n    unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];\n    fi->seek(0, SEEK_SET);\n    fi->readx(&mhdri, sizeof(mhdri));\n\n    if (((unsigned) Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) !=mhdri.magic\n    ||  my_cputype   !=mhdri.cputype\n    ||  my_filetype  !=mhdri.filetype\n    )\n        return false;\n    my_cpusubtype = mhdri.cpusubtype;\n\n    unsigned const ncmds = mhdri.ncmds;\n    if (!ncmds || 256 < ncmds) { // arbitrary, but guard against garbage\n        throwCantPack(\"256 < Mach_header.ncmds\");\n    }\n    unsigned const sz_mhcmds = (unsigned)mhdri.sizeofcmds;\n    unsigned headway = file_size - sizeof(mhdri);\n    if (headway < sz_mhcmds) {\n        char buf[32]; snprintf(buf, sizeof(buf), \"bad sizeofcmds %d\", sz_mhcmds);\n        throwCantPack(buf);\n    }\n    if (!sz_mhcmds\n    ||  16384 < sz_mhcmds) { // somewhat arbitrary, but amd64-darwin.macho-upxmain.c\n        throwCantPack(\"16384 < Mach_header.sizeofcmds (or ==0)\");\n    }\n    rawmseg_buf.alloc(sz_mhcmds);\n    rawmseg = (Mach_segment_command *)(void *)rawmseg_buf;\n    fi->readx(rawmseg, mhdri.sizeofcmds);\n\n    msegcmd_buf.alloc(sizeof(Mach_segment_command) * ncmds);\n    msegcmd = (Mach_segment_command *)msegcmd_buf.getVoidPtr();\n    unsigned char const *ptr = (unsigned char const *)rawmseg;\n    for (unsigned j= 0; j < ncmds; ++j) {\n        Mach_segment_command const *segptr = (Mach_segment_command const *)ptr;\n        if (headway < ((Mach_command const *)ptr)->cmdsize) {\n            char buf[64]; snprintf(buf, sizeof(buf),\n                \"bad Mach_command[%d]{%#x, %#x}\", j,\n                (unsigned)segptr->cmd, (unsigned)((Mach_command const *)ptr)->cmdsize);\n            throwCantPack(buf);\n        }\n        headway -= ((Mach_command const *)ptr)->cmdsize;\n        if (lc_seg == segptr->cmd) {\n            msegcmd[j] = *segptr;\n            if (!strcmp(\"__TEXT\", segptr->segname)) {\n                Mach_section_command const *secp =\n                    (Mach_section_command const *)(const void*)(const char*)(1+ segptr);\n                unsigned const offset = secp->offset;\n                if (offset < file_size) {\n                    struct l_info h;\n                    fi->seek(offset, SEEK_SET);\n                    fi->readx(&h, sizeof(h));\n                    checkAlreadyPacked(&h, sizeof(h));\n                }\n            }\n            if (!strcmp(\"__DATA\", segptr->segname)) {\n                prev_mod_init_func = get_mod_init_func(segptr);\n            }\n        }\n        else {\n            memcpy(&msegcmd[j], ptr, 2*sizeof(unsigned)); // cmd and cmdsize\n        }\n        switch (((Mach_uuid_command const *)ptr)->cmd) {\n        default: break;\n        case Mach_command::LC_UUID: {\n            memcpy(&cmdUUID, ptr, sizeof(cmdUUID));  // remember the UUID\n            // Set output UUID to be 1 more than the input UUID.\n            for (unsigned k = 0; k < sizeof(cmdUUID.uuid); ++k) {\n                if (0 != ++cmdUUID.uuid[k]) { // no Carry\n                    break;\n                }\n            }\n        } break;\n        case Mach_command::LC_VERSION_MIN_MACOSX: {\n            memcpy(&cmdVERMIN, ptr, sizeof(cmdVERMIN));\n        } break;\n        case Mach_command::LC_SOURCE_VERSION: {\n            memcpy(&cmdSRCVER, ptr, sizeof(cmdSRCVER));\n        } break;\n        }\n        ptr += (unsigned) ((Mach_command const *)ptr)->cmdsize;\n    }\n    if (Mach_header::MH_DYLIB==my_filetype && 0==o__mod_init_func) {\n        infoWarning(\"missing -init function\");\n        return false;\n    }\n\n    // Put LC_SEGMENT together at the beginning\n    qsort(msegcmd, ncmds, sizeof(*msegcmd), compare_segment_command);\n\n    if (lc_seg==msegcmd[0].cmd && 0==msegcmd[0].vmaddr\n    &&  !strcmp(\"__PAGEZERO\", msegcmd[0].segname)) {\n        pagezero_vmsize = msegcmd[0].vmsize;\n    }\n\n    // Check alignment of non-null LC_SEGMENT.\n    vma_max = 0;\n    for (unsigned j= 0; j < ncmds; ++j) {\n        if (lc_seg==msegcmd[j].cmd) {\n            ++n_segment;\n            if (~PAGE_MASK & (msegcmd[j].fileoff | msegcmd[j].vmaddr)) {\n                return false;\n            }\n            upx_uint64_t t = msegcmd[j].vmsize + msegcmd[j].vmaddr;\n            if (vma_max < t) {\n                vma_max = t;\n            }\n            // Segments need not be contigous (esp. \"rust\"/\"go\")\n            sz_segment = msegcmd[j].filesize + msegcmd[j].fileoff - msegcmd[0].fileoff;\n        }\n    }\n    vma_max = PAGE_MASK & (~PAGE_MASK + vma_max);\n\n    // info: currently the header is 36 (32+4) bytes before EOF\n    unsigned char buf[256];\n    fi->seek(-(off_t)sizeof(buf), SEEK_END);\n    fi->readx(buf, sizeof(buf));\n    checkAlreadyPacked(buf, sizeof(buf));\n\n    // set options\n    opt->o_unix.blocksize = file_size;\n    if (!n_segment) {\n        return false;\n    }\n    static struct {\n        unsigned cputype;\n        unsigned short filetype;\n        unsigned short sz_stub_entry;\n        unsigned short sz_stub_fold;\n        unsigned short sz_stub_main;\n        upx_byte const *stub_entry;\n        upx_byte const *stub_fold;\n        upx_byte const *stub_main;\n    } const stub_list[] = {\n        {CPU_TYPE_I386, MH_EXECUTE,\n            sizeof(stub_i386_darwin_macho_entry),\n            sizeof(stub_i386_darwin_macho_fold),\n            sizeof(stub_i386_darwin_macho_upxmain_exe),\n                   stub_i386_darwin_macho_entry,\n                   stub_i386_darwin_macho_fold,\n                   stub_i386_darwin_macho_upxmain_exe\n        },\n        {CPU_TYPE_I386, MH_DYLIB,\n            sizeof(stub_i386_darwin_dylib_entry), 0, 0,\n                   stub_i386_darwin_dylib_entry,  nullptr, nullptr\n        },\n        {CPU_TYPE_X86_64, MH_EXECUTE,\n            sizeof(stub_amd64_darwin_macho_entry),\n            sizeof(stub_amd64_darwin_macho_fold),\n            0, //sizeof(stub_amd64_darwin_macho_upxmain_exe),\n                   stub_amd64_darwin_macho_entry,\n                   stub_amd64_darwin_macho_fold,\n                   nullptr // stub_amd64_darwin_macho_upxmain_exe\n        },\n        {CPU_TYPE_X86_64, MH_DYLIB,\n            sizeof(stub_amd64_darwin_dylib_entry), 0, 0,\n                   stub_amd64_darwin_dylib_entry,  nullptr, nullptr\n        },\n        {CPU_TYPE_ARM, MH_EXECUTE,\n            sizeof(stub_arm_v5a_darwin_macho_entry),\n            sizeof(stub_arm_v5a_darwin_macho_fold),\n            0,\n                   stub_arm_v5a_darwin_macho_entry,\n                   stub_arm_v5a_darwin_macho_fold,\n                   nullptr\n        },\n        {CPU_TYPE_ARM64, MH_EXECUTE,\n            sizeof(stub_arm64_darwin_macho_entry),\n            sizeof(stub_arm64_darwin_macho_fold),\n            0,\n                   stub_arm64_darwin_macho_entry,\n                   stub_arm64_darwin_macho_fold,\n                   nullptr\n        },\n        {CPU_TYPE_POWERPC, MH_EXECUTE,\n            sizeof(stub_powerpc_darwin_macho_entry),\n            sizeof(stub_powerpc_darwin_macho_fold),\n            sizeof(stub_powerpc_darwin_macho_upxmain_exe),\n                   stub_powerpc_darwin_macho_entry,\n                   stub_powerpc_darwin_macho_fold,\n                   stub_powerpc_darwin_macho_upxmain_exe\n        },\n        {CPU_TYPE_POWERPC, MH_DYLIB,\n            sizeof(stub_powerpc_darwin_dylib_entry), 0, 0,\n                   stub_powerpc_darwin_dylib_entry,  nullptr, nullptr\n        },\n        {CPU_TYPE_POWERPC64LE, MH_EXECUTE,\n            sizeof(stub_powerpc64le_darwin_macho_entry),\n            sizeof(stub_powerpc64le_darwin_macho_fold),\n            0,\n                   stub_powerpc64le_darwin_macho_entry,\n                   stub_powerpc64le_darwin_macho_fold,\n                   nullptr\n        },\n        {CPU_TYPE_POWERPC64LE, MH_DYLIB,\n            sizeof(stub_powerpc64le_darwin_dylib_entry), 0, 0,\n                   stub_powerpc64le_darwin_dylib_entry,  nullptr, nullptr\n        },\n        {0,0, 0,0,0, nullptr,nullptr,nullptr}\n    };\n    for (unsigned j = 0; stub_list[j].cputype; ++j) {\n        if (stub_list[j].cputype  == my_cputype\n        &&  stub_list[j].filetype == my_filetype) {\n            sz_stub_entry = stub_list[j].sz_stub_entry;\n               stub_entry = stub_list[j].stub_entry;\n            sz_stub_fold  = stub_list[j].sz_stub_fold;\n               stub_fold  = stub_list[j].stub_fold;\n            sz_stub_main  = stub_list[j].sz_stub_main;\n               stub_main  = stub_list[j].stub_main;\n            if (!stub_main) { // development stub\n                static struct {\n                    Mach_header mhdri;\n                    Mach_segment_command segZERO;\n                    Mach_segment_command segTEXT;\n                    Mach_section_command secTEXT;\n                    Mach_segment_command segLINK;\n                    Mach_version_min_command cmdVERMIN;\n                    Mach_source_version_command cmdSRCVER;\n                } fsm;  // fake_stub_main\n                fsm.mhdri = mhdri;\n                fsm.mhdri.ncmds = 5;\n                fsm.mhdri.sizeofcmds = sizeof(fsm) - sizeof(fsm.mhdri);\n                fsm.mhdri.flags = MH_NOUNDEFS | MH_PIE;\n\n                fsm.segZERO.cmd = LC_SEGMENT + (fsm.mhdri.cputype >> 24)\n                    * (LC_SEGMENT_64 - LC_SEGMENT);\n                fsm.segZERO.cmdsize = sizeof(Mach_segment_command);\n                strncpy(fsm.segZERO.segname, \"__PAGEZERO\", sizeof(fsm.segZERO.segname));\n                fsm.segZERO.vmaddr = 0;\n                fsm.segZERO.vmsize = (4<<16);\n                if __acc_cte(8==sizeof(void *)) fsm.segZERO.vmsize <<= (32 - 18);\n                fsm.segZERO.fileoff = 0;\n                fsm.segZERO.filesize = 0;\n                fsm.segZERO.maxprot = 0;\n                fsm.segZERO.initprot = 0;\n                fsm.segZERO.nsects = 0;\n                fsm.segZERO.flags = 0;\n\n                unsigned const slop = 400;\n                fsm.segTEXT.cmd = fsm.segZERO.cmd;\n                fsm.segTEXT.cmdsize = sizeof(Mach_segment_command)\n                    + sizeof(Mach_section_command);\n                strncpy(fsm.segTEXT.segname, \"__TEXT\", sizeof(fsm.segTEXT.segname));\n                fsm.segTEXT.vmaddr = fsm.segZERO.vmsize;\n                fsm.segTEXT.vmsize = slop + threado_size() + sizeof(fsm);  // dummy\n                fsm.segTEXT.fileoff = 0;\n                fsm.segTEXT.filesize = fsm.segTEXT.vmsize;  // dummy\n                fsm.segTEXT.maxprot = VM_PROT_EXECUTE | VM_PROT_READ;\n                fsm.segTEXT.initprot = VM_PROT_EXECUTE | VM_PROT_READ;\n                fsm.segTEXT.nsects = 1;\n                fsm.segTEXT.flags = 0;\n\n                strncpy(fsm.secTEXT.sectname, \"__text\", sizeof(fsm.secTEXT.sectname));\n                memcpy(fsm.secTEXT.segname, fsm.segTEXT.segname, sizeof(fsm.secTEXT.segname));\n                unsigned const d = slop + fsm.mhdri.sizeofcmds;\n                fsm.secTEXT.addr = fsm.segTEXT.vmaddr + d;  // dummy\n                fsm.secTEXT.size = fsm.segTEXT.vmsize - d;  // dummy\n                fsm.secTEXT.offset = d;  // dummy\n                fsm.secTEXT.align = 3;  // (1<<2)\n                fsm.secTEXT.reloff = 0;\n                fsm.secTEXT.nreloc = 0;\n                fsm.secTEXT.flags = S_REGULAR | S_ATTR_PURE_INSTRUCTIONS | S_ATTR_SOME_INSTRUCTIONS;\n                fsm.secTEXT.reserved1 = 0;\n                fsm.secTEXT.reserved2 = 0;\n\n                fsm.segLINK = fsm.segTEXT;\n                fsm.segLINK.cmdsize = sizeof(Mach_segment_command);\n                strncpy(fsm.segLINK.segname, \"__LINKEDIT\", sizeof(fsm.segLINK.segname));\n                fsm.segLINK.vmaddr = fsm.segTEXT.vmaddr + fsm.segTEXT.vmsize;  // dummy\n                fsm.segLINK.vmsize = 0x1000;  // dummy\n                fsm.segLINK.fileoff = fsm.segTEXT.fileoff + fsm.segTEXT.filesize;\n                fsm.segLINK.filesize = fsm.segLINK.vmsize;\n                fsm.segLINK.maxprot = VM_PROT_READ;\n                fsm.segLINK.initprot = VM_PROT_READ;\n                fsm.segLINK.nsects = 0;\n\n                fsm.cmdVERMIN.cmd = LC_VERSION_MIN_MACOSX;  // LC_VERSION_MIN_IPHONEOS\n                fsm.cmdVERMIN.cmdsize = 4*4;\n                fsm.cmdVERMIN.version = (10<<16)|(12<<8);\n                fsm.cmdVERMIN.sdk = fsm.cmdVERMIN.version;\n\n                fsm.cmdSRCVER.cmd = LC_SOURCE_VERSION;\n                fsm.cmdSRCVER.cmdsize = 4*4;\n                fsm.cmdSRCVER.version = 0;\n                fsm.cmdSRCVER.__pad = 0;\n\n                sz_stub_main  = sizeof(fsm);\n                   stub_main  = (unsigned char const *)&fsm;\n            }\n            break;\n        }\n    }\n    return true;\n}\n\ntemplate class PackMachBase<MachClass_BE32>;\ntemplate class PackMachBase<MachClass_LE32>;\ntemplate class PackMachBase<MachClass_LE64>;\n\n\nPackMachFat::PackMachFat(InputFile *f) : super(f)\n{\n    bele = &N_BELE_RTP::le_policy;  // sham\n}\n\nPackMachFat::~PackMachFat()\n{\n}\n\nunsigned PackMachFat::check_fat_head()\n{\n    struct Mach_fat_arch const *const arch = &fat_head.arch[0];\n    unsigned nfat = fat_head.fat.nfat_arch;\n    if (Mach_fat_header::FAT_MAGIC!=fat_head.fat.magic\n    ||  N_FAT_ARCH < nfat) {\n        return 0;\n    }\n    for (unsigned j=0; j < nfat; ++j) {\n        unsigned const align = arch[j].align;\n        unsigned const mask = ~(~0u<<align);\n        unsigned const size = arch[j].size;\n        unsigned const offset = arch[j].offset;\n        if (align < 12 || align > 24) { // heuristic\n            throwUnknownExecutableFormat(\"align\", 0);\n        }\n        if (mask > size) {\n            throwUnknownExecutableFormat(\"size\", 0);\n        }\n        if (mask & offset\n        ||  (unsigned)fi->st_size_orig() < size + offset\n        ||  (unsigned)fi->st_size_orig() <= offset) {  // redundant unless overflow\n            throwUnknownExecutableFormat(\"offset\", 0);\n        }\n    }\n    return nfat;\n}\n\nconst int *PackMachFat::getCompressionMethods(int /*method*/, int /*level*/) const\n{\n    static const int m_nrv2e[] = { M_NRV2E_LE32, M_END };\n    return m_nrv2e;  // sham\n}\n\nconst int *PackMachFat::getFilters() const\n{\n    static const int filters[] = { 0x49, FT_END };\n    return filters;  // sham\n}\n\nvoid PackMachFat::pack(OutputFile *fo)\n{\n    unsigned const in_size = this->file_size;\n    fo->write(&fat_head, sizeof(fat_head.fat) +\n        fat_head.fat.nfat_arch * sizeof(fat_head.arch[0]));\n    unsigned length = 0;\n    for (unsigned j=0; j < fat_head.fat.nfat_arch; ++j) {\n        unsigned base = fo->unset_extent();  // actual length\n        base += ~(~0u<<fat_head.arch[j].align) & (0-base);  // align up\n        fo->seek(base, SEEK_SET);\n        fo->set_extent(base, ~0u);\n\n        ph.u_file_size = fat_head.arch[j].size;\n        fi->set_extent(fat_head.arch[j].offset, fat_head.arch[j].size);\n        fi->seek(0, SEEK_SET);\n        switch (fat_head.arch[j].cputype) {\n        case PackMachFat::CPU_TYPE_I386: {\n            typedef N_Mach::Mach_header<MachClass_LE32::MachITypes> Mach_header;\n            Mach_header hdr;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachI386 packer(fi);\n                packer.initPackHeader();\n                packer.canPack();\n                packer.updatePackHeader();\n                packer.pack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibI386 packer(fi);\n                packer.initPackHeader();\n                packer.canPack();\n                packer.updatePackHeader();\n                packer.pack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_X86_64: {\n            typedef N_Mach::Mach_header<MachClass_LE64::MachITypes> Mach_header;\n            Mach_header hdr;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachAMD64 packer(fi);\n                packer.initPackHeader();\n                packer.canPack();\n                packer.updatePackHeader();\n                packer.pack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibAMD64 packer(fi);\n                packer.initPackHeader();\n                packer.canPack();\n                packer.updatePackHeader();\n                packer.pack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC: {\n            typedef N_Mach::Mach_header<MachClass_BE32::MachITypes> Mach_header;\n            Mach_header hdr;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachPPC32 packer(fi);\n                packer.initPackHeader();\n                packer.canPack();\n                packer.updatePackHeader();\n                packer.pack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibPPC32 packer(fi);\n                packer.initPackHeader();\n                packer.canPack();\n                packer.updatePackHeader();\n                packer.pack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC64LE: {\n            typedef N_Mach::Mach_header<MachClass_LE64::MachITypes> Mach_header;\n            Mach_header hdr;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachPPC64LE packer(fi);\n                packer.initPackHeader();\n                packer.canPack();\n                packer.updatePackHeader();\n                packer.pack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibPPC64LE packer(fi);\n                packer.initPackHeader();\n                packer.canPack();\n                packer.updatePackHeader();\n                packer.pack(fo);\n            }\n        } break;\n        }  // switch cputype\n        fat_head.arch[j].offset = base;\n        length = fo->unset_extent();\n        fat_head.arch[j].size = length - base;\n    }\n    ph.u_file_size = in_size;\n    fi->set_extent(0, in_size);\n\n    fo->seek(0, SEEK_SET);\n    fo->rewrite(&fat_head, sizeof(fat_head.fat) +\n        fat_head.fat.nfat_arch * sizeof(fat_head.arch[0]));\n    fo->set_extent(0, length);\n}\n\nvoid PackMachFat::unpack(OutputFile *fo)\n{\n    if (fo) {  // test mode (\"-t\") sets fo = nullptr\n        fo->seek(0, SEEK_SET);\n        fo->write(&fat_head, sizeof(fat_head.fat) +\n            fat_head.fat.nfat_arch * sizeof(fat_head.arch[0]));\n    }\n    unsigned const nfat = check_fat_head();\n    unsigned length;\n    for (unsigned j=0; j < nfat; ++j) {\n        unsigned base = (fo ? fo->unset_extent() : 0);  // actual length\n        base += ~(~0u<<fat_head.arch[j].align) & (0-base);  // align up\n        if (fo) {\n            fo->seek(base, SEEK_SET);\n            fo->set_extent(base, ~0u);\n        }\n\n        ph.u_file_size = fat_head.arch[j].size;\n        fi->set_extent(fat_head.arch[j].offset, fat_head.arch[j].size);\n        fi->seek(0, SEEK_SET);\n        switch (fat_head.arch[j].cputype) {\n        case PackMachFat::CPU_TYPE_I386: {\n            N_Mach::Mach_header<MachClass_LE32::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE32::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachI386 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibI386 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_X86_64: {\n            N_Mach::Mach_header<MachClass_LE64::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE64::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachAMD64 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibAMD64 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC: {\n            N_Mach::Mach_header<MachClass_BE32::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_BE32::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachPPC32 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibPPC32 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC64LE: {\n            N_Mach::Mach_header<MachClass_LE64::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE64::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachPPC64LE packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibPPC64LE packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        }  // switch cputype\n        fat_head.arch[j].offset = base;\n        length = (fo ? fo->unset_extent() : 0);\n        fat_head.arch[j].size = length - base;\n    }\n    if (fo) {\n        fo->unset_extent();\n        fo->seek(0, SEEK_SET);\n        fo->rewrite(&fat_head, sizeof(fat_head.fat) +\n            fat_head.fat.nfat_arch * sizeof(fat_head.arch[0]));\n    }\n}\n\nbool PackMachFat::canPack()\n{\n    struct Mach_fat_arch const *const arch = &fat_head.arch[0];\n\n    fi->readx(&fat_head, sizeof(fat_head));\n    unsigned const nfat = check_fat_head();\n    if (0==nfat)\n        return false;\n    for (unsigned j=0; j < nfat; ++j) {\n        fi->set_extent(arch[j].offset, arch[j].size);\n        fi->seek(0, SEEK_SET);\n        switch (arch[j].cputype) {\n        default:\n            infoWarning(\"unknown cputype 0x%x: %s\",\n                (unsigned)arch[j].cputype, fi->getName());\n            return false;\n        case PackMachFat::CPU_TYPE_I386: {\n            PackMachI386 packer(fi);\n            if (!packer.canPack()) {\n                PackDylibI386 pack2r(fi);\n                if (!pack2r.canPack())\n                    return false;\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_X86_64: {\n            PackMachAMD64 packer(fi);\n            if (!packer.canPack()) {\n                PackDylibI386 pack2r(fi);\n                if (!pack2r.canPack())\n                    return false;\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_ARM64: {\n            PackMachARM64EL packer(fi);\n            if (!packer.canPack()) {\n                //PackDylibARM64EL pack2r(fi);  FIXME: not yet\n                //if (!pack2r.canPack())\n                    return false;\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC: {\n            PackMachPPC32 packer(fi);\n            if (!packer.canPack()) {\n                PackDylibPPC32 pack2r(fi);\n                if (!pack2r.canPack())\n                    return false;\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC64LE: {\n            PackMachPPC64LE packer(fi);\n            if (!packer.canPack()) {\n                PackDylibPPC64LE pack2r(fi);\n                if (!pack2r.canPack())\n                    return false;\n            }\n        } break;\n        }  // switch cputype\n    }\n\n    // info: currently the header is 36 (32+4) bytes before EOF\n    unsigned char buf[256];\n    fi->seek(-(off_t)sizeof(buf), SEEK_END);\n    fi->readx(buf, sizeof(buf));\n    checkAlreadyPacked(buf, sizeof(buf));\n\n    return true;\n}\n\nint PackMachFat::canUnpack()\n{\n    struct Mach_fat_arch const *const arch = &fat_head.arch[0];\n\n    fi->readx(&fat_head, sizeof(fat_head));\n    unsigned const nfat = check_fat_head();\n    if (0 == nfat) {\n        return false;\n    }\n    for (unsigned j=0; j < nfat; ++j) {\n        fi->set_extent(arch[j].offset, arch[j].size);\n        fi->seek(0, SEEK_SET);\n        switch (arch[j].cputype) {\n        default: return false;\n        case PackMachFat::CPU_TYPE_I386: {\n            PackMachI386 packer(fi);\n            if (!packer.canUnpack()) {\n                PackDylibI386 pack2r(fi);\n                if (!pack2r.canUnpack())\n                    return 0;\n                else\n                    ph.format = pack2r.getFormat(); // FIXME: copy entire PackHeader\n            }\n            else\n                ph.format = packer.getFormat(); // FIXME: copy entire PackHeader\n        } break;\n        case PackMachFat::CPU_TYPE_X86_64: {\n            PackMachAMD64 packer(fi);\n            if (!packer.canUnpack()) {\n                PackDylibAMD64 pack2r(fi);\n                if (!pack2r.canUnpack())\n                    return 0;\n                else\n                    ph.format = pack2r.getFormat(); // FIXME: copy entire PackHeader\n            }\n            else\n                ph.format = packer.getFormat(); // FIXME: copy entire PackHeader\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC: {\n            PackMachPPC32 packer(fi);\n            if (!packer.canUnpack()) {\n                PackDylibPPC32 pack2r(fi);\n                if (!pack2r.canUnpack())\n                    return 0;\n                else\n                    ph.format = pack2r.getFormat(); // FIXME: copy entire PackHeader\n            }\n            else\n                ph.format = packer.getFormat(); // FIXME: copy entire PackHeader\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC64LE: {\n            PackMachPPC64LE packer(fi);\n            if (!packer.canUnpack()) {\n                PackDylibPPC64LE pack2r(fi);\n                if (!pack2r.canUnpack())\n                    return 0;\n                else\n                    ph.format = pack2r.getFormat(); // FIXME: copy entire PackHeader\n            }\n            else\n                ph.format = packer.getFormat(); // FIXME: copy entire PackHeader\n        } break;\n        }  // switch cputype\n    }\n    return 1;\n}\n\nvoid PackMachFat::buildLoader(const Filter * /*ft*/)\n{\n    assert(false);\n}\n\nLinker* PackMachFat::newLinker() const\n{\n    return new ElfLinkerX86;  // sham\n}\n\nvoid PackMachFat::list()\n{\n    assert(false);\n}\n\n/* vim:set ts=4 sw=4 et: */\n"], "fixing_code": ["/* p_mach.cpp -- pack Mach Object executable\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 2004-2021 John Reiser\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   John Reiser\n   <jreiser@users.sourceforge.net>\n */\n\n\n#include \"conf.h\"\n\n#include \"file.h\"\n#include \"filter.h\"\n#include \"linker.h\"\n#include \"packer.h\"\n#include \"p_mach.h\"\n#include \"ui.h\"\n\nstatic const\n#include \"stub/i386-darwin.macho-entry.h\"\nstatic const\n#include \"stub/i386-darwin.macho-fold.h\"\nstatic const\n#include \"stub/i386-darwin.macho-upxmain.h\"\nstatic const\n#include \"stub/i386-darwin.dylib-entry.h\"\n\nstatic const\n#include \"stub/amd64-darwin.macho-entry.h\"\nstatic const\n#include \"stub/amd64-darwin.macho-fold.h\"\nstatic const\n#include \"stub/amd64-darwin.macho-upxmain.h\"\nstatic const\n#include \"stub/amd64-darwin.dylib-entry.h\"\n\nstatic const\n#include \"stub/arm.v5a-darwin.macho-entry.h\"\nstatic const\n#include \"stub/arm.v5a-darwin.macho-fold.h\"\n\nstatic const\n#include \"stub/arm64-darwin.macho-entry.h\"\nstatic const\n#include \"stub/arm64-darwin.macho-fold.h\"\n\nstatic const\n#include \"stub/powerpc-darwin.macho-entry.h\"\nstatic const\n#include \"stub/powerpc-darwin.macho-fold.h\"\nstatic const\n#include \"stub/powerpc-darwin.macho-upxmain.h\"\nstatic const\n#include \"stub/powerpc-darwin.dylib-entry.h\"\n\nstatic const\n#include \"stub/powerpc64le-darwin.macho-entry.h\"\nstatic const\n#include \"stub/powerpc64le-darwin.macho-fold.h\"\nstatic const\n#include \"stub/powerpc64le-darwin.dylib-entry.h\"\n\n// Packing a Darwin (Mach-o) Mac OS X dylib (dynamic shared library)\n// is restricted.  UPX gets control as the -init function, at the very\n// end of processing by dyld.  Relocation, loading of dependent libraries,\n// etc., already have taken place before decompression.  So the Mach-o\n// headers, the __IMPORT segment, the __LINKEDIT segment, anything\n// that is modifed by relocation, etc., cannot be compressed.\n// We simplify arbitrarily by compressing only the __TEXT segment,\n// which must be the first segment.\n\nstatic const unsigned lc_segment[2] = {\n    0x1, 0x19\n    //Mach_command::LC_SEGMENT,\n    //Mach_command::LC_SEGMENT_64\n};\n\n#if 0 // NOT USED\nstatic const unsigned lc_routines[2] = {\n    0x11, 0x1a\n    //Mach_command::LC_ROUTINES,\n    //Mach_command::LC_ROUTINES_64\n};\n#endif\n\ntemplate <class T>\nPackMachBase<T>::PackMachBase(InputFile *f, unsigned cputype, unsigned filetype,\n        unsigned flavor, unsigned count, unsigned size) :\n    super(f), my_cputype(cputype), my_filetype(filetype), my_thread_flavor(flavor),\n    my_thread_state_word_count(count), my_thread_command_size(size),\n    n_segment(0), rawmseg(nullptr), msegcmd(nullptr), o__mod_init_func(0),\n    prev_mod_init_func(0), pagezero_vmsize(0)\n{\n    MachClass::compileTimeAssertions();\n    bele = N_BELE_CTP::getRTP((const BeLePolicy*) nullptr);\n    memset(&cmdUUID, 0, sizeof(cmdUUID));\n    memset(&cmdSRCVER, 0, sizeof(cmdSRCVER));\n    memset(&cmdVERMIN, 0, sizeof(cmdVERMIN));\n    memset(&linkitem, 0, sizeof(linkitem));\n}\n\ntemplate <class T>\nPackMachBase<T>::~PackMachBase()\n{\n}\n\nPackDylibI386::PackDylibI386(InputFile *f) : super(f)\n{\n    my_filetype = Mach_header::MH_DYLIB;\n}\n\nPackDylibAMD64::PackDylibAMD64(InputFile *f) : super(f)\n{\n    my_filetype = Mach_header::MH_DYLIB;\n}\n\nPackDylibPPC32::PackDylibPPC32(InputFile *f) : super(f)\n{\n    my_filetype = Mach_header::MH_DYLIB;\n}\nPackDylibPPC64LE::PackDylibPPC64LE(InputFile *f) : super(f)\n{\n    my_filetype = Mach_header::MH_DYLIB;\n}\n\ntemplate <class T>\nconst int *PackMachBase<T>::getCompressionMethods(int method, int level) const\n{\n    // There really is no LE bias.\n    return Packer::getDefaultCompressionMethods_le32(method, level);\n}\n\nconst int *PackMachARMEL::getCompressionMethods(int method, int level) const\n{\n    // Un-aligned fetch does not work on 32-bit ARM, so use 8-bit methods\n    return Packer::getDefaultCompressionMethods_8(method, level);\n}\n\nPackMachPPC32::PackMachPPC32(InputFile *f) : super(f, Mach_header::CPU_TYPE_POWERPC,\n        Mach_header::MH_EXECUTE, Mach_thread_command::PPC_THREAD_STATE,\n        sizeof(Mach_ppc_thread_state)>>2, sizeof(threado))\n{ }\n\nPackMachPPC64LE::PackMachPPC64LE(InputFile *f) : super(f, Mach_header::CPU_TYPE_POWERPC64LE,\n        Mach_header::MH_EXECUTE, Mach_thread_command::PPC_THREAD_STATE64,\n        sizeof(Mach_ppcle_thread_state64)>>2, sizeof(threado))\n{ }\n\nconst int *PackMachPPC32::getFilters() const\n{\n    static const int filters[] = { 0xd0, FT_END };\n    return filters;\n}\n\nconst int *PackMachPPC64LE::getFilters() const\n{\n    static const int filters[] = { 0xd0, FT_END };\n    return filters;\n}\n\nPackMachI386::PackMachI386(InputFile *f) : super(f, Mach_header::CPU_TYPE_I386,\n        Mach_header::MH_EXECUTE, (unsigned)Mach_thread_command::x86_THREAD_STATE32,\n        sizeof(Mach_i386_thread_state)>>2, sizeof(threado))\n{ }\n\nint const *PackMachI386::getFilters() const\n{\n    static const int filters[] = { 0x49, FT_END };\n    return filters;\n}\n\nPackMachAMD64::PackMachAMD64(InputFile *f) : super(f, Mach_header::CPU_TYPE_X86_64,\n        Mach_header::MH_EXECUTE, (unsigned)Mach_thread_command::x86_THREAD_STATE64,\n        sizeof(Mach_AMD64_thread_state)>>2, sizeof(threado))\n{ }\n\nint const *PackMachAMD64::getFilters() const\n{\n    static const int filters[] = { 0x49, FT_END };\n    return filters;\n}\n\nPackMachARMEL::PackMachARMEL(InputFile *f) : super(f, Mach_header::CPU_TYPE_ARM,\n        Mach_header::MH_EXECUTE, (unsigned)Mach_thread_command::ARM_THREAD_STATE,\n        sizeof(Mach_ARM_thread_state)>>2, sizeof(threado))\n{ }\n\nPackMachARM64EL::PackMachARM64EL(InputFile *f) : super(f, Mach_header::CPU_TYPE_ARM64,\n        Mach_header::MH_EXECUTE, (unsigned)Mach_thread_command::ARM_THREAD_STATE64,\n        sizeof(Mach_ARM64_thread_state)>>2, sizeof(threado))\n{ }\n\nint const *PackMachARMEL::getFilters() const\n{\n    static const int filters[] = { 0x50, FT_END };\n    return filters;\n}\n\nint const *PackMachARM64EL::getFilters() const\n{\n    static const int filters[] = { 0x52, FT_END };\n    return filters;\n}\n\nLinker *PackMachPPC32::newLinker() const\n{\n    return new ElfLinkerPpc32;\n}\n\nLinker *PackMachPPC64LE::newLinker() const\n{\n    return new ElfLinkerPpc64le;\n}\n\nLinker *PackMachI386::newLinker() const\n{\n    return new ElfLinkerX86;\n}\n\nLinker *PackMachAMD64::newLinker() const\n{\n    return new ElfLinkerAMD64;\n}\n\nLinker *PackMachARMEL::newLinker() const\n{\n    return new ElfLinkerArmLE;\n}\n\nLinker *PackMachARM64EL::newLinker() const\n{\n    return new ElfLinkerArm64LE;\n}\n\ntemplate <class T>\nvoid\nPackMachBase<T>::addStubEntrySections(Filter const *)\n{\n    addLoader(\"MACOS000\", nullptr);\n   //addLoader(getDecompressorSections(), nullptr);\n    addLoader(\n        ( M_IS_NRV2E(ph.method) ? \"NRV_HEAD,NRV2E,NRV_TAIL\"\n        : M_IS_NRV2D(ph.method) ? \"NRV_HEAD,NRV2D,NRV_TAIL\"\n        : M_IS_NRV2B(ph.method) ? \"NRV_HEAD,NRV2B,NRV_TAIL\"\n        : M_IS_LZMA(ph.method)  ? \"LZMA_ELF00,LZMA_DEC20,LZMA_DEC30\"\n        : nullptr), nullptr);\n    if (hasLoaderSection(\"CFLUSH\"))\n        addLoader(\"CFLUSH\");\n    addLoader(\"ELFMAINY,IDENTSTR,+40,ELFMAINZ,FOLDEXEC\", nullptr);\n}\n\nvoid PackMachI386::addStubEntrySections(Filter const * /*ft*/)\n{\n    addLoader(\"MACHMAINX\", nullptr);  // different for MY_DYLIB vs MH_EXECUTE\n    if (my_filetype==Mach_header::MH_EXECUTE) {\n        addLoader(\"MACH_UNC\", nullptr);\n    }\n   //addLoader(getDecompressorSections(), nullptr);\n    addLoader(\n        ( M_IS_NRV2E(ph.method) ? \"NRV_HEAD,NRV2E,NRV_TAIL\"\n        : M_IS_NRV2D(ph.method) ? \"NRV_HEAD,NRV2D,NRV_TAIL\"\n        : M_IS_NRV2B(ph.method) ? \"NRV_HEAD,NRV2B,NRV_TAIL\"\n        : M_IS_LZMA(ph.method)  ? \"LZMA_ELF00,LZMA_DEC20,LZMA_DEC30\"\n        : nullptr), nullptr);\n    if (hasLoaderSection(\"CFLUSH\"))\n        addLoader(\"CFLUSH\");\n    addLoader(\"MACHMAINY,IDENTSTR,+40,MACHMAINZ,FOLDEXEC\", nullptr);\n}\n\nvoid PackMachAMD64::addStubEntrySections(Filter const * /*ft*/)\n{\n    addLoader(\"MACHMAINX\", nullptr);  // different for MY_DYLIB vs MH_EXECUTE\n    if (my_filetype==Mach_header::MH_EXECUTE) {\n        addLoader(\"MACH_UNC\", nullptr);\n    }\n   //addLoader(getDecompressorSections(), nullptr);\n    addLoader(\n        ( M_IS_NRV2E(ph.method) ? \"NRV_HEAD,NRV2E,NRV_TAIL\"\n        : M_IS_NRV2D(ph.method) ? \"NRV_HEAD,NRV2D,NRV_TAIL\"\n        : M_IS_NRV2B(ph.method) ? \"NRV_HEAD,NRV2B,NRV_TAIL\"\n        : M_IS_LZMA(ph.method)  ? \"LZMA_ELF00,LZMA_DEC20,LZMA_DEC30\"\n        : nullptr), nullptr);\n    if (hasLoaderSection(\"CFLUSH\"))\n        addLoader(\"CFLUSH\");\n    addLoader(\"MACHMAINY,IDENTSTR,+40,MACHMAINZ,FOLDEXEC\", nullptr);\n}\n\nvoid PackMachPPC32::addStubEntrySections(Filter const * /*ft*/)\n{\n    if (my_filetype!=Mach_header::MH_EXECUTE) {\n        addLoader(\"MACHMAINX\", nullptr);\n    }\n    else {\n        addLoader(\"PPC32BXX\", nullptr);\n    }\n    addLoader(\"MACH_UNC\", nullptr);\n   //addLoader(getDecompressorSections(), nullptr);\n    addLoader(\n        ( M_IS_NRV2E(ph.method) ? \"NRV_HEAD,NRV2E,NRV_TAIL\"\n        : M_IS_NRV2D(ph.method) ? \"NRV_HEAD,NRV2D,NRV_TAIL\"\n        : M_IS_NRV2B(ph.method) ? \"NRV_HEAD,NRV2B,NRV_TAIL\"\n        : M_IS_LZMA(ph.method)  ? \"LZMA_ELF00,LZMA_DEC20,LZMA_DEC30\"\n        : nullptr), nullptr);\n    if (hasLoaderSection(\"CFLUSH\"))\n        addLoader(\"CFLUSH\");\n    addLoader(\"MACHMAINY,IDENTSTR,+40,MACHMAINZ\", nullptr);\n    if (my_filetype!=Mach_header::MH_EXECUTE) {\n        addLoader(\"FOLDEXEC\", nullptr);\n    }\n}\n\nvoid PackMachARMEL::addStubEntrySections(Filter const * /*ft*/)\n{\n    addLoader(\"MACHMAINX\", nullptr);\n   //addLoader(getDecompressorSections(), nullptr);\n    addLoader(\n        ( M_IS_NRV2E(ph.method) ? \"NRV_HEAD,NRV2E,NRV_TAIL\"\n        : M_IS_NRV2D(ph.method) ? \"NRV_HEAD,NRV2D,NRV_TAIL\"\n        : M_IS_NRV2B(ph.method) ? \"NRV_HEAD,NRV2B,NRV_TAIL\"\n        : M_IS_LZMA(ph.method)  ? \"LZMA_ELF00,LZMA_DEC20,LZMA_DEC30\"\n        : nullptr), nullptr);\n    if (hasLoaderSection(\"CFLUSH\"))\n        addLoader(\"CFLUSH\");\n    addLoader(\"MACHMAINY,IDENTSTR,+40,MACHMAINZ,FOLDEXEC\", nullptr);\n}\n\nvoid PackMachARM64EL::addStubEntrySections(Filter const * /*ft*/)\n{\n    addLoader(\"MACHMAINX\", nullptr);\n   //addLoader(getDecompressorSections(), nullptr);\n    addLoader(\n        ( M_IS_NRV2E(ph.method) ? \"NRV_HEAD,NRV2E,NRV_TAIL\"\n        : M_IS_NRV2D(ph.method) ? \"NRV_HEAD,NRV2D,NRV_TAIL\"\n        : M_IS_NRV2B(ph.method) ? \"NRV_HEAD,NRV2B,NRV_TAIL\"\n        : M_IS_LZMA(ph.method)  ? \"LZMA_ELF00,LZMA_DEC20,LZMA_DEC30\"\n        : nullptr), nullptr);\n    if (hasLoaderSection(\"CFLUSH\"))\n        addLoader(\"CFLUSH\");\n    addLoader(\"MACHMAINY,IDENTSTR,+40,MACHMAINZ,FOLDEXEC\", nullptr);\n}\n\ntemplate <class T>\nvoid PackMachBase<T>::defineSymbols(Filter const *)\n{\n    // empty\n}\n\n\ntemplate <class T>\nvoid\nPackMachBase<T>::buildMachLoader(\n    upx_byte const *const proto,\n    unsigned        const szproto,\n    upx_byte const *const fold,\n    unsigned        const szfold,\n    Filter const *ft\n)\n{\n    initLoader(proto, szproto);\n\n    struct b_info h; memset(&h, 0, sizeof(h));\n    unsigned fold_hdrlen = 0;\n  if (0 < szfold) {\n    h.sz_unc = (szfold < fold_hdrlen) ? 0 : (szfold - fold_hdrlen);\n    h.b_method = (unsigned char) ph.method;\n    h.b_ftid = (unsigned char) ph.filter;\n    h.b_cto8 = (unsigned char) ph.filter_cto;\n  }\n    unsigned char const *const uncLoader = fold_hdrlen + fold;\n\n    MemBuffer cprLoader_buf(sizeof(h) + h.sz_unc);\n    unsigned char *const cprLoader = (unsigned char *)cprLoader_buf.getVoidPtr();\n  if (0 < szfold) {\n    unsigned sz_cpr = 0;\n    int r = upx_compress(uncLoader, h.sz_unc, sizeof(h) + cprLoader, &sz_cpr,\n        nullptr, ph.method, 10, nullptr, nullptr );\n    h.sz_cpr = sz_cpr;\n    if (r != UPX_E_OK || h.sz_cpr >= h.sz_unc)\n        throwInternalError(\"loader compression failed\");\n  }\n    memcpy(cprLoader, &h, sizeof(h));\n\n    // This adds the definition to the \"library\", to be used later.\n    linker->addSection(\"FOLDEXEC\", cprLoader, sizeof(h) + h.sz_cpr, 0);\n\n    int const GAP = 128;  // must match stub/l_mac_ppc.S\n    int const NO_LAP = 64;  // must match stub/src/*darwin*.S\n    segTEXT.vmsize = h.sz_unc - h.sz_cpr + GAP + NO_LAP;\n\n    addStubEntrySections(ft);\n\n    defineSymbols(ft);\n    relocateLoader();\n}\n\ntemplate <class T>\nvoid\nPackMachBase<T>::buildLoader(const Filter *ft)\n{\n    buildMachLoader(\n        stub_entry, sz_stub_entry,\n        stub_fold,  sz_stub_fold,  ft );\n}\n\ntemplate <class T>\nvoid PackMachBase<T>::patchLoader() { }\n\ntemplate <class T>\nvoid PackMachBase<T>::updateLoader(OutputFile *) {}\n\ntemplate <class T>\nvoid PackMachBase<T>::patchLoaderChecksum()\n{\n    unsigned char *const ptr = getLoader();\n    l_info *const lp = &linfo;\n    // checksum for loader; also some PackHeader info\n    lp->l_checksum = 0;\n    lp->l_magic = UPX_MAGIC_LE32;  // LE32 always\n    set_te16(&lp->l_lsize, (upx_uint16_t) lsize);\n    lp->l_version = (unsigned char) ph.version;\n    lp->l_format  = (unsigned char) ph.format;\n    // INFO: lp->l_checksum is currently unused\n    set_te32(&lp->l_checksum, upx_adler32(ptr, lsize));\n}\n\ntemplate <class T>\nint __acc_cdecl_qsort\nPackMachBase<T>::compare_segment_command(void const *const aa, void const *const bb)\n{\n    Mach_segment_command const *const a = (Mach_segment_command const *)aa;\n    Mach_segment_command const *const b = (Mach_segment_command const *)bb;\n    unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];\n    unsigned const xa = a->cmd - lc_seg;\n    unsigned const xb = b->cmd - lc_seg;\n           if (xa < xb)        return -1;  // LC_SEGMENT first\n           if (xa > xb)        return  1;\n           if (0 != xa)        return  0;  // not LC_SEGMENT\n    // Ascending by .fileoff so that find_SEGMENT_gap works\n    if (a->fileoff < b->fileoff)\n                               return -1;\n    if (a->fileoff > b->fileoff)\n                               return  1;\n    // Ascending by .vmaddr\n    if (a->vmaddr < b->vmaddr) return -1;\n    if (a->vmaddr > b->vmaddr) return  1;\n    // Descending by .vmsize\n    if (a->vmsize)             return -1;  // 'a' is first\n    if (b->vmsize)             return  1;  // 'a' is last\n    // What could remain?\n    return 0;\n}\n\n#undef PAGE_MASK\n#undef PAGE_SIZE\n#define PAGE_MASK (~0u<<12)\n#define PAGE_SIZE (0u-PAGE_MASK)\n\n#undef PAGE_MASK64\n#undef PAGE_SIZE64\n#define PAGE_MASK64 (~(upx_uint64_t)0<<16)\n#define PAGE_SIZE64 ((upx_uint64_t)0-PAGE_MASK64)\n\n// At 2013-02-03 part of the source for codesign was\n//    http://opensource.apple.com/source/cctools/cctools-836/libstuff/ofile.c\n\n#undef PAGE_MASK64\n#undef PAGE_SIZE64\n#define PAGE_MASK64 (~(upx_uint64_t)0<<12)\n#define PAGE_SIZE64 ((upx_uint64_t)0-PAGE_MASK64)\n\nunsigned const blankLINK = 16;  // size of our empty __LINK segment\n// Note: \"readelf --segments\"  ==>  \"otool -hl\" or \"otool -hlv\" etc. (Xcode on MacOS)\n\ntemplate <class T>\nvoid PackMachBase<T>::pack4(OutputFile *fo, Filter &ft)  // append PackHeader\n{\n    // offset of p_info in compressed file\n    overlay_offset = secTEXT.offset + sizeof(linfo);\n    super::pack4(fo, ft);\n\n    if (Mach_header::MH_EXECUTE == my_filetype) {\n        unsigned len = fo->getBytesWritten();\n        char page[~PAGE_MASK]; memset(page, 0, sizeof(page));\n        fo->write(page, ~PAGE_MASK & (0u - len));\n        len +=          ~PAGE_MASK & (0u - len) ;\n\n        segTEXT.filesize = len;\n        segTEXT.vmsize   = len;  // FIXME?  utilize GAP + NO_LAP + sz_unc - sz_cpr\n        secTEXT.offset = overlay_offset - sizeof(linfo);\n        secTEXT.addr = segTEXT.vmaddr   + secTEXT.offset;\n        secTEXT.size = segTEXT.filesize - secTEXT.offset;\n        secXHDR.offset = overlay_offset - sizeof(linfo);\n        if (my_filetype==Mach_header::MH_EXECUTE) {\n            secXHDR.offset -= sizeof(linkitem);\n        }\n        secXHDR.addr += secXHDR.offset;\n        unsigned offLINK = segLINK.fileoff;\n\n\n        segLINK.fileoff = len;  // must be in the file\n        segLINK.vmaddr =  len + segTEXT.vmaddr;\n        fo->write(page, blankLINK); len += blankLINK;\n        segLINK.vmsize = PAGE_SIZE;\n        segLINK.filesize = blankLINK;\n\n        // Get a writeable copy of the stub to make editing easier.\n        ByteArray(upxstub, sz_stub_main);\n        memcpy(upxstub, stub_main, sz_stub_main);\n\n        Mach_header *const mhp = (Mach_header *)upxstub;\n        mhp->cpusubtype = my_cpusubtype;\n        mhp->flags = mhdro.flags;\n        char *tail = (char *)(1+ mhp);\n        char *const lcp_end = mhdro.sizeofcmds + tail;\n        Mach_command *lcp = (Mach_command *)(1+ mhp);\n        Mach_command *lcp_next;\n        unsigned const ncmds = mhdro.ncmds;\n        //unsigned cmdsize = mhdro.sizeofcmds;\n        unsigned delta = 0;\n\n    for (unsigned j = 0; j < ncmds; ++j) {\n        unsigned skip = 0;\n        unsigned sz_cmd = lcp->cmdsize;\n        lcp_next = (Mach_command *)(sz_cmd + (char *)lcp);\n\n        switch (lcp->cmd) {\n        case Mach_command::LC_SEGMENT: // fall through\n        case Mach_command::LC_SEGMENT_64: {\n            Mach_segment_command *const segptr = (Mach_segment_command *)lcp;\n            if (!strcmp(\"__PAGEZERO\", segptr->segname)) {\n                segptr->vmsize = pagezero_vmsize;\n            }\n            if (!strcmp(\"__TEXT\", segptr->segname)) {\n                sz_cmd = (segTEXT.nsects * sizeof(secTEXT)) + sizeof(segTEXT);\n                mhp->sizeofcmds += sizeof(secTEXT) * (1 - segptr->nsects);\n                memcpy(tail, &segTEXT, sz_cmd); tail += sz_cmd;\n                goto next;\n            }\n            if (!strcmp(\"__LINKEDIT\", segptr->segname)) {\n                segLINK.initprot = Mach_command::VM_PROT_READ;\n                delta = offLINK - segptr->fileoff;  // relocation constant\n\n                sz_cmd = sizeof(segLINK);\n                if (Mach_header::CPU_TYPE_I386==mhdri.cputype\n                &&  Mach_header::MH_EXECUTE==mhdri.filetype) {\n                    segLINK.maxprot = 0\n                        | Mach_command::VM_PROT_EXECUTE\n                        | Mach_command::VM_PROT_WRITE\n                        | Mach_command::VM_PROT_READ;\n                    segLINK.initprot = 0\n                        | Mach_command::VM_PROT_WRITE\n                        | Mach_command::VM_PROT_READ;\n                }\n                memcpy(tail, &segLINK, sz_cmd); tail += sz_cmd;\n                goto next;\n            }\n        } break;\n        case Mach_command::LC_DYLD_INFO_ONLY: {\n            Mach_dyld_info_only_command *p = (Mach_dyld_info_only_command *)lcp;\n            if (p->rebase_off)    p->rebase_off    += delta;\n            if (p->bind_off)      p->bind_off      += delta;\n            if (p->lazy_bind_off) p->lazy_bind_off += delta;\n            if (p->export_off)    p->export_off    += delta;\n                // But we don't want any exported symbols.\n                p->export_off = 0;\n                p->export_size = 0;\n            skip = 1;\n        } break;\n        case Mach_command::LC_SYMTAB: {\n            // Apple codesign requires that string table is last in the file.\n            Mach_symtab_command *p = (Mach_symtab_command *)lcp;\n            p->symoff = segLINK.filesize + segLINK.fileoff;\n            p->nsyms = 0;\n            p->stroff = segLINK.fileoff;\n            p->strsize = segLINK.filesize;\n            skip = 1;\n        } break;\n        case Mach_command::LC_DYSYMTAB: {\n            Mach_dysymtab_command *p = (Mach_dysymtab_command *)lcp;\n            if (p->tocoff)         p->tocoff         += delta;\n            if (p->modtaboff)      p->modtaboff      += delta;\n            if (p->extrefsymoff)   p->extrefsymoff   += delta;\n            if (p->indirectsymoff) p->indirectsymoff += delta;\n            if (p->extreloff)      p->extreloff      += delta;\n            if (p->locreloff)      p->locreloff      += delta;\n                // But we don't want any symbols.\n                p->ilocalsym = 0;\n                p->nlocalsym = 0;\n                p->iextdefsym = 0;\n                p->nextdefsym = 0;\n                p->iundefsym = 0;\n                p->nundefsym = 0;\n            skip = 1;\n        } break;\n        case Mach_command::LC_MAIN: {\n                // Replace later with LC_UNIXTHREAD.\n// LC_MAIN requires libSystem.B.dylib to provide the environment for main(), and CALLs the entryoff.\n// LC_UNIXTHREAD does not need libSystem.B.dylib, and JMPs to the .rip with %rsp/argc and argv= 8+%rsp\n            threado_setPC(segTEXT.vmaddr +\n                (((Mach_main_command const *)lcp)->entryoff - segTEXT.fileoff));\n            skip = 1;\n        } break;\n        case Mach_command::LC_UNIXTHREAD: { // pre-LC_MAIN\n            skip = 1;\n        } break;\n        case Mach_command::LC_LOAD_DYLIB: {\n            skip = 1;\n        } break;\n\n        case Mach_command::LC_FUNCTION_STARTS:\n        case Mach_command::LC_DATA_IN_CODE: {\n            Mach_linkedit_data_command *p = (Mach_linkedit_data_command *)lcp;\n            if (p->dataoff) p->dataoff += delta;\n            skip = 1;\n        } break;\n        case Mach_command::LC_LOAD_DYLINKER: {\n            skip = 1;\n        } break;\n        case Mach_command::LC_SOURCE_VERSION: { // copy from saved original\n            memcpy(lcp, &cmdSRCVER, sizeof(cmdSRCVER));\n            if (Mach_command::LC_SOURCE_VERSION != cmdSRCVER.cmd) {\n                skip = 1;  // was not seen\n            }\n        } break;\n        case Mach_command::LC_VERSION_MIN_MACOSX: { // copy from saved original\n            memcpy(lcp, &cmdVERMIN, sizeof(cmdVERMIN));\n            if (Mach_command::LC_VERSION_MIN_MACOSX != cmdVERMIN.cmd) {\n                skip = 1;  // was not seen\n            }\n        } break;\n        } // end switch\n\n        if (skip) {\n            mhp->ncmds -= 1;\n            mhp->sizeofcmds -= sz_cmd;\n        }\n        else {\n            if (tail != (char *)lcp) {\n                memmove(tail, lcp, sz_cmd);\n            }\n            tail += sz_cmd;\n        }\nnext:\n        lcp = lcp_next;\n    }  // end for each Mach_command\n\n        // Append LC_UNIXTHREAD\n        unsigned const sz_threado = threado_size();\n        mhp->ncmds += 1;\n        mhp->sizeofcmds += sz_threado;\n        fo->seek(0, SEEK_SET);\n        fo->rewrite(mhp, tail - (char *)mhp);\n        threado_rewrite(fo);\n        tail += sz_threado;\n        //\n        // Zero any remaining tail.\n        if (tail < lcp_end) {\n            unsigned sz_cmd = lcp_end - tail;\n            memset(tail, 0, sz_cmd);\n            fo->rewrite(tail, sz_cmd);\n        }\n        // Rewrite linfo in file.\n        fo->seek(sz_mach_headers, SEEK_SET);\n        fo->rewrite(&linfo, sizeof(linfo));\n        fo->seek(0, SEEK_END);\n    }\n}\n\n// At 2013-02-03 part of the source for codesign was:\n//    http://opensource.apple.com/source/cctools/cctools-836/libstuff/ofile.c\n\ntemplate <class T>\nvoid PackMachBase<T>::pack4dylib(  // append PackHeader\n    OutputFile *const fo,\n    Filter &ft,\n    Addr init_address\n)\n{\n    fo->seek(0, SEEK_SET);\n    fo->rewrite(&mhdro, sizeof(mhdro));  // segTEXT.nsect=1 (only secTEXT)\n    fo->rewrite(&segTEXT, sizeof(segTEXT));  // .vmsize\n    unsigned opos = sizeof(mhdro);\n\n    // Append each non-__TEXT segment, page aligned.\n    int slide = 0;\n    unsigned o_end_txt = 0;\n    unsigned hdrpos = sizeof(mhdro);\n    Mach_segment_command const *seg = rawmseg;\n    Mach_segment_command const *const endseg =\n        (Mach_segment_command const *)(mhdri.sizeofcmds + (char const *)seg);\n    for ( ; seg < endseg; seg = (Mach_segment_command const *)(\n            seg->cmdsize + (char const *)seg )\n    ) switch (seg->cmd & ~Mach_command::LC_REQ_DYLD) {\n    default:  // unknown if any file offset field must slide\n        fprintf(stderr, \"Unrecognized Macho cmd  offset=0x%lx  cmd=0x%lx  size=0x%lx\\n\",\n            (unsigned long)((const char *)seg - (const char *)rawmseg),\n            (unsigned long)seg->cmd, (unsigned long)seg->cmdsize);\n        // fall through\n    case Mach_command::LC_VERSION_MIN_MACOSX:\n    case Mach_command::LC_SOURCE_VERSION:\n    case Mach_command::LC_THREAD:\n    case Mach_command::LC_UNIXTHREAD:\n    case Mach_command::LC_LOAD_DYLIB:\n    case Mach_command::LC_ID_DYLIB:\n    case Mach_command::LC_LOAD_DYLINKER:\n    case Mach_command::LC_UUID:\n    case Mach_command::LC_RPATH:\n    case Mach_command::LC_REEXPORT_DYLIB: { // contain no file offset fields\n        fo->seek(hdrpos, SEEK_SET);\n        fo->rewrite(seg, seg->cmdsize);\n        hdrpos += seg->cmdsize;\n    } break;\n\n    case Mach_command::LC_CODE_SIGNATURE:\n    case Mach_command::LC_SEGMENT_SPLIT_INFO:\n    case Mach_command::LC_DYLIB_CODE_SIGN_DRS:\n    case Mach_command::LC_DATA_IN_CODE:\n    case Mach_command::LC_FUNCTION_STARTS: {\n        Mach_linkedit_data_command cmd; memcpy(&cmd, seg, sizeof(cmd));\n        if (o_end_txt <= cmd.dataoff) { cmd.dataoff += slide; }\n        fo->seek(hdrpos, SEEK_SET);\n        fo->rewrite(&cmd, sizeof(cmd));\n        hdrpos += sizeof(cmd);\n    } break;\n    case Mach_command::LC_DYLD_INFO_ONLY & ~Mach_command::LC_REQ_DYLD: {\n        Mach_dyld_info_only_command cmd; memcpy(&cmd, seg, sizeof(cmd));\n        if (o_end_txt <= cmd.rebase_off)    { cmd.rebase_off    += slide; }\n        if (o_end_txt <= cmd.bind_off)      { cmd.bind_off      += slide; }\n        if (o_end_txt <= cmd.weak_bind_off) { cmd.weak_bind_off += slide; }\n        if (o_end_txt <= cmd.lazy_bind_off) { cmd.lazy_bind_off += slide; }\n        if (o_end_txt <= cmd.export_off)    { cmd.export_off    += slide; }\n        fo->seek(hdrpos, SEEK_SET);\n        fo->rewrite(&cmd, sizeof(cmd));\n        hdrpos += sizeof(cmd);\n    } break;\n    case Mach_command::LC_TWOLEVEL_HINTS: {\n        Mach_twolevel_hints_command cmd; memcpy(&cmd, seg, sizeof(cmd));\n        if (o_end_txt <= cmd.offset) { cmd.offset += slide; }\n        fo->seek(hdrpos, SEEK_SET);\n        fo->rewrite(&cmd, sizeof(cmd));\n        hdrpos += sizeof(cmd);\n    } break;\n    case Mach_command::LC_ROUTINES_64:\n    case Mach_command::LC_ROUTINES: {\n        Mach_routines_command cmd; memcpy(&cmd, seg, sizeof(cmd));\n        cmd.reserved1 = cmd.init_address;\n        cmd.init_address = init_address;\n        fo->seek(hdrpos, SEEK_SET);\n        fo->rewrite(&cmd, sizeof(cmd));\n        hdrpos += sizeof(cmd);\n    } break;\n    case Mach_command::LC_SEGMENT_64:\n    case Mach_command::LC_SEGMENT: {\n        // non-__TEXT might be observed and relocated by dyld before us.\n        Mach_segment_command segcmdtmp = *seg;\n        bool const is_text = 0==strncmp(&seg->segname[0], \"__TEXT\", 1+ 6);\n        {\n            if (is_text) {\n                slide = 0;\n                segTEXT.vmsize = segTEXT.filesize = fo->getBytesWritten();\n                segTEXT.maxprot  |= Mach_command::VM_PROT_WRITE;\n                segcmdtmp = segTEXT;\n                opos = o_end_txt = segcmdtmp.filesize + segcmdtmp.fileoff;\n            }\n            else {\n                opos += ~PAGE_MASK & (0u - opos);  // advance to PAGE_SIZE boundary\n                slide = opos - segcmdtmp.fileoff;\n                segcmdtmp.fileoff = opos;\n            }\n\n            fo->seek(hdrpos, SEEK_SET);\n            fo->rewrite(&segcmdtmp, sizeof(segcmdtmp));\n            hdrpos += sizeof(segcmdtmp);\n\n            // Update the sections.\n            Mach_section_command const *secp =\n                (Mach_section_command const *)(const void*)(const char*)(1+ seg);\n            if (is_text) {\n                secTEXT.offset = secp->offset;\n                secTEXT.addr = segTEXT.vmaddr   + secTEXT.offset;\n                secTEXT.size = segTEXT.filesize - secTEXT.offset;\n                secp = &secTEXT;\n            }\n            unsigned const nsects = (is_text ? 1 : segcmdtmp.nsects);\n            Mach_section_command seccmdtmp;\n            for (unsigned j = 0; j < nsects; ++secp, ++j) {\n                seccmdtmp = *secp;\n                if (o_end_txt <= seccmdtmp.offset) { seccmdtmp.offset += slide; }\n                if (o_end_txt <= seccmdtmp.reloff) { seccmdtmp.reloff += slide; }\n                fo->rewrite(&seccmdtmp, sizeof(seccmdtmp));\n                hdrpos += sizeof(seccmdtmp);\n            }\n\n            if (!is_text) {\n                unsigned const len = seg->filesize;\n                MemBuffer data(len);\n                fi->seek(seg->fileoff, SEEK_SET);\n                fi->readx(data, len);\n                unsigned const pos = o__mod_init_func - seg->fileoff;\n                if (pos < seg->filesize) {\n                    if (*(unsigned *)(pos + data) != (unsigned)prev_mod_init_func) {\n                        throwCantPack(\"__mod_init_func inconsistent\");\n                    }\n                    *(unsigned *)(pos + data) = (unsigned)entryVMA;\n                }\n                fo->seek(opos, SEEK_SET);\n                fo->write(data, len);\n                opos += len;\n            }\n        }\n    } break;\n    case Mach_command::LC_SYMTAB: {\n        Mach_symtab_command cmd; memcpy(&cmd, seg, sizeof(cmd));\n        if (o_end_txt <= cmd.symoff) { cmd.symoff += slide; }\n        if (o_end_txt <= cmd.stroff) { cmd.stroff += slide; }\n        fo->seek(hdrpos, SEEK_SET);\n        fo->rewrite(&cmd, sizeof(cmd));\n        hdrpos += sizeof(cmd);\n    } break;\n    case Mach_command::LC_DYSYMTAB: {\n        Mach_dysymtab_command cmd; memcpy(&cmd, seg, sizeof(cmd));\n        if (o_end_txt <= cmd.tocoff)         { cmd.tocoff         += slide; }\n        if (o_end_txt <= cmd.modtaboff)      { cmd.modtaboff      += slide; }\n        if (o_end_txt <= cmd.extrefsymoff)   { cmd.extrefsymoff   += slide; }\n        if (o_end_txt <= cmd.indirectsymoff) { cmd.indirectsymoff += slide; }\n        if (o_end_txt <= cmd.extreloff)      { cmd.extreloff      += slide; }\n        if (o_end_txt <= cmd.locreloff)      { cmd.locreloff      += slide; }\n        fo->seek(hdrpos, SEEK_SET);\n        fo->rewrite(&cmd, sizeof(cmd));\n        hdrpos += sizeof(cmd);\n    } break;\n    }  // end 'switch'\n    fo->seek(opos, SEEK_SET);  // BUG: \"fo->seek(0, SEEK_END);\" is broken\n\n    PackMachBase<T>::pack4(fo, ft);\n}\n\nvoid PackDylibI386::pack4(OutputFile *fo, Filter &ft)  // append PackHeader\n{\n    pack4dylib(fo, ft, threado.state.eip);\n}\n\nvoid PackDylibAMD64::pack4(OutputFile *fo, Filter &ft)  // append PackHeader\n{\n    pack4dylib(fo, ft, threado.state.rip);\n}\n\nvoid PackDylibPPC32::pack4(OutputFile *fo, Filter &ft)  // append PackHeader\n{\n    pack4dylib(fo, ft, threado.state.srr0);\n}\n\nvoid PackDylibPPC64LE::pack4(OutputFile *fo, Filter &ft)  // append PackHeader\n{\n    pack4dylib(fo, ft, threado.state64.srr0);\n}\n\ntemplate <class T>\noff_t PackMachBase<T>::pack3(OutputFile *fo, Filter &ft)  // append loader\n{\n    TE32 disp;\n    upx_uint64_t const zero = 0;\n    unsigned len = fo->getBytesWritten();\n    fo->write(&zero, 3& (0u-len));\n    len += (3& (0u-len));\n\n    disp = len;  // backward offset to Mach_header\n    fo->write(&disp, sizeof(disp));\n    len += sizeof(disp);\n\n    if (my_filetype!=Mach_header::MH_DYLIB) {\n        disp = len - sz_mach_headers;  // backward offset to start of compressed data\n        fo->write(&disp, sizeof(disp));\n        len += sizeof(disp);\n    }\n    segTEXT.vmsize = segTEXT.filesize;\n    threado_setPC(entryVMA= len + segTEXT.vmaddr);\n\n    return super::pack3(fo, ft);\n}\n\noff_t PackDylibI386::pack3(OutputFile *fo, Filter &ft)  // append loader\n{\n    TE32 disp;\n    upx_uint32_t const zero = 0;\n    off_t len = fo->getBytesWritten();\n    fo->write(&zero, 3& (0u-len));\n    len += (3& (0u-len)) + 4*sizeof(disp);\n\n    disp = prev_mod_init_func;\n    fo->write(&disp, sizeof(disp));  // user .init_address\n\n    disp = secTEXT.offset + sizeof(l_info) + sizeof(p_info);\n    fo->write(&disp, sizeof(disp));  // src offset(compressed __TEXT)\n\n    disp = len - disp - 3*sizeof(disp);\n    fo->write(&disp, sizeof(disp));  // length(compressed __TEXT)\n\n    unsigned const save_sz_mach_headers(sz_mach_headers);\n    sz_mach_headers = 0;\n    len = super::pack3(fo, ft);\n    sz_mach_headers = save_sz_mach_headers;\n    return len;\n}\n\noff_t PackDylibAMD64::pack3(OutputFile *fo, Filter &ft)  // append loader\n{\n    TE32 disp;\n    upx_uint64_t const zero = 0;\n    off_t len = fo->getBytesWritten();\n    fo->write(&zero, 3& (0u-len));\n    len += (3& (0u-len)) + 3*sizeof(disp);\n\n    disp = prev_mod_init_func;\n    fo->write(&disp, sizeof(disp));  // user .init_address\n\n    disp = secTEXT.offset + sizeof(l_info) + sizeof(p_info);\n    fo->write(&disp, sizeof(disp));  // src offset(b_info)\n\n    disp = rawmseg[0].vmsize;\n    fo->write(&disp, sizeof(disp));  // __TEXT.vmsize when expanded\n\n    unsigned const save_sz_mach_headers(sz_mach_headers);\n    sz_mach_headers = 0;\n    len = super::pack3(fo, ft);\n    sz_mach_headers = save_sz_mach_headers;\n    return len;\n}\n\noff_t PackDylibPPC32::pack3(OutputFile *fo, Filter &ft)  // append loader\n{\n    TE32 disp;\n    upx_uint32_t const zero = 0;\n    off_t len = fo->getBytesWritten();\n    fo->write(&zero, 3& (0u-len));\n    len += (3& (0u-len)) + 4*sizeof(disp);\n\n    disp = prev_mod_init_func;\n    fo->write(&disp, sizeof(disp));  // user .init_address\n\n    disp = secTEXT.offset + sizeof(l_info) + sizeof(p_info);\n    fo->write(&disp, sizeof(disp));  // src offset(compressed __TEXT)\n\n    disp = len - disp - 3*sizeof(disp);\n    fo->write(&disp, sizeof(disp));  // length(compressed __TEXT)\n\n    unsigned const save_sz_mach_headers(sz_mach_headers);\n    sz_mach_headers = 0;\n    len = super::pack3(fo, ft);\n    sz_mach_headers = save_sz_mach_headers;\n    return len;\n}\n\noff_t PackDylibPPC64LE::pack3(OutputFile *fo, Filter &ft)  // append loader\n{\n    TE64 disp;\n    upx_uint64_t const zero = 0;\n    off_t len = fo->getBytesWritten();\n    fo->write(&zero, 3& (0u-len));\n    len += (3& (0u-len)) + 4*sizeof(disp);\n\n    disp = prev_mod_init_func;\n    fo->write(&disp, sizeof(disp));  // user .init_address\n\n    disp = secTEXT.offset + sizeof(l_info) + sizeof(p_info);\n    fo->write(&disp, sizeof(disp));  // src offset(compressed __TEXT)\n\n    disp = len - disp - 3*sizeof(disp);\n    fo->write(&disp, sizeof(disp));  // length(compressed __TEXT)\n\n    unsigned const save_sz_mach_headers(sz_mach_headers);\n    sz_mach_headers = 0;\n    len = super::pack3(fo, ft);\n    sz_mach_headers = save_sz_mach_headers;\n    return len;\n}\n\n// Determine length of gap between PT_LOAD phdri[k] and closest PT_LOAD\n// which follows in the file (or end-of-file).  Optimize for common case\n// where the PT_LOAD are adjacent ascending by .p_offset.  Assume no overlap.\n\ntemplate <class T>\nunsigned PackMachBase<T>::find_SEGMENT_gap(\n    unsigned const k, unsigned pos_eof\n)\n{\n    unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];\n    if (lc_seg!=msegcmd[k].cmd\n    ||  0==msegcmd[k].filesize ) {\n        return 0;\n    }\n    unsigned const hi = msegcmd[k].fileoff + msegcmd[k].filesize;\n    unsigned lo = pos_eof;\n    unsigned j = k;\n    for (;;) { // circular search, optimize for adjacent ascending\n        ++j;\n        if (n_segment==j) {\n            j = 0;\n        }\n        if (k==j) {\n            break;\n        }\n        if (lc_seg==msegcmd[j].cmd\n        &&  0!=msegcmd[j].filesize ) {\n            unsigned const t = (unsigned) msegcmd[j].fileoff;\n            if ((t - hi) < (lo - hi)) {\n                lo = t;\n                if (hi==lo) {\n                    break;\n                }\n            }\n        }\n    }\n    return lo - hi;\n}\n\ntemplate <class T>\nint  PackMachBase<T>::pack2(OutputFile *fo, Filter &ft)  // append compressed body\n{\n    unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];\n    Extent x;\n    unsigned k;\n\n    // count passes, set ptload vars\n    uip->ui_total_passes = 0;\n    for (k = 0; k < n_segment; ++k) {\n        if (lc_seg==msegcmd[k].cmd\n        &&  0!=msegcmd[k].filesize ) {\n            uip->ui_total_passes++;\n            if (my_filetype==Mach_header::MH_DYLIB) {\n                break;\n            }\n            if (find_SEGMENT_gap(k, fi->st_size())) {\n                uip->ui_total_passes++;\n            }\n        }\n    }\n\n    // compress extents\n    total_in = 0;\n    total_out = 0;\n\n    unsigned hdr_u_len = mhdri.sizeofcmds + sizeof(mhdri);\n\n    uip->ui_pass = 0;\n    ft.addvalue = 0;\n\n    // Packer::compressWithFilters chooses a filter for us, and the stubs\n    // can handle only one filter, and most filters are for executable\n    // instructions.  So filter only the largest executable segment.\n    unsigned exe_filesize_max = 0;\n    for (k = 0; k < n_segment; ++k)\n    if (lc_seg==msegcmd[k].cmd\n    &&  0!=(Mach_command::VM_PROT_EXECUTE & msegcmd[k].initprot)\n    &&  exe_filesize_max < msegcmd[k].filesize) {\n        exe_filesize_max = (unsigned) msegcmd[k].filesize;\n    }\n\n    int nx = 0;\n    for (k = 0; k < n_segment; ++k)\n    if (lc_seg==msegcmd[k].cmd\n    &&  0!=msegcmd[k].filesize ) {\n        x.offset = msegcmd[k].fileoff;\n        x.size   = msegcmd[k].filesize;\n        if (0 == nx) { // 1st LC_SEGMENT must cover Mach_header at 0==fileoffset\n            unsigned const delta = mhdri.sizeofcmds + sizeof(mhdri);\n            x.offset    += delta;\n            x.size      -= delta;\n        }\n        bool const do_filter = (msegcmd[k].filesize==exe_filesize_max)\n            && 0!=(Mach_command::VM_PROT_EXECUTE & msegcmd[k].initprot);\n        Mach_segment_command const *ptr = rawmseg;\n        unsigned b_extra = 0;\n        for (unsigned j= 0; j < mhdri.ncmds; ++j) {\n            if (msegcmd[k].cmd    == ptr->cmd\n            &&  msegcmd[k].vmaddr == ptr->vmaddr\n            &&  msegcmd[k].vmsize == ptr->vmsize) {\n                b_extra = j;\n                break;\n            }\n            ptr = (Mach_segment_command const *)(ptr->cmdsize + (char const *)ptr);\n        }\n        packExtent(x,\n            (do_filter ? &ft : nullptr), fo, hdr_u_len, b_extra );\n        if (do_filter) {\n            exe_filesize_max = 0;\n        }\n        hdr_u_len = 0;\n        ++nx;\n        if (my_filetype==Mach_header::MH_DYLIB) {\n            break;\n        }\n    }\n    if (my_filetype!=Mach_header::MH_DYLIB)\n    for (k = 0; k < n_segment; ++k) {\n        x.size = find_SEGMENT_gap(k, fi->st_size());\n        if (x.size) {\n            x.offset = msegcmd[k].fileoff +msegcmd[k].filesize;\n            packExtent(x, nullptr, fo);\n        }\n    }\n\n    if (my_filetype!=Mach_header::MH_DYLIB)\n    if ((off_t)total_in != file_size)\n        throwEOFException();\n    segTEXT.filesize = fo->getBytesWritten();\n    secTEXT.size = segTEXT.filesize - overlay_offset + sizeof(linfo);\n\n    return 1;\n}\n\nvoid PackMachPPC32::pack1_setup_threado(OutputFile *const fo)\n{\n    threado.cmd = Mach_command::LC_UNIXTHREAD;\n    threado.cmdsize = sizeof(threado);\n    threado.flavor = my_thread_flavor;\n    threado.count =  my_thread_state_word_count;\n    memset(&threado.state, 0, sizeof(threado.state));\n    fo->write(&threado, sizeof(threado));\n}\n\nvoid PackMachPPC64LE::pack1_setup_threado(OutputFile *const fo)\n{\n    threado.cmd = Mach_command::LC_UNIXTHREAD;\n    threado.cmdsize = sizeof(threado);\n    threado.flavor = my_thread_flavor;\n    threado.count =  my_thread_state_word_count;\n    memset(&threado.state64, 0, sizeof(threado.state64));\n    fo->write(&threado, sizeof(threado));\n}\n\nvoid PackMachI386::pack1_setup_threado(OutputFile *const fo)\n{\n    threado.cmd = Mach_command::LC_UNIXTHREAD;\n    threado.cmdsize = sizeof(threado);\n    threado.flavor = my_thread_flavor;\n    threado.count =  my_thread_state_word_count;\n    memset(&threado.state, 0, sizeof(threado.state));\n    fo->write(&threado, sizeof(threado));\n}\n\nvoid PackMachAMD64::pack1_setup_threado(OutputFile *const fo)\n{\n    threado.cmd = Mach_command::LC_UNIXTHREAD;\n    threado.cmdsize = sizeof(threado);\n    threado.flavor = my_thread_flavor;\n    threado.count =  my_thread_state_word_count;\n    memset(&threado.state, 0, sizeof(threado.state));\n    fo->write(&threado, sizeof(threado));\n}\n\nvoid PackMachARMEL::pack1_setup_threado(OutputFile *const fo)\n{\n    threado.cmd = Mach_command::LC_UNIXTHREAD;\n    threado.cmdsize = sizeof(threado);\n    threado.flavor = my_thread_flavor;\n    threado.count =  my_thread_state_word_count;\n    memset(&threado.state, 0, sizeof(threado.state));\n    fo->write(&threado, sizeof(threado));\n}\n\nvoid PackMachARM64EL::pack1_setup_threado(OutputFile *const fo)\n{\n    threado.cmd = Mach_command::LC_UNIXTHREAD;\n    threado.cmdsize = sizeof(threado);\n    threado.flavor = my_thread_flavor;\n    threado.count =  my_thread_state_word_count;\n    memset(&threado.state, 0, sizeof(threado.state));\n    fo->write(&threado, sizeof(threado));\n}\n\ntemplate <class T>\nvoid PackMachBase<T>::pack1(OutputFile *const fo, Filter &/*ft*/)  // generate executable header\n{\n    unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];\n    mhdro = mhdri;\n    if (my_filetype==Mach_header::MH_EXECUTE) {\n        memcpy(&mhdro, stub_main, sizeof(mhdro));\n        mhdro.flags = mhdri.flags & ~(\n              Mach_header::MH_DYLDLINK  // no dyld at this time\n            | Mach_header::MH_TWOLEVEL  // dyld-specific\n            | Mach_header::MH_BINDATLOAD  // dyld-specific\n            );\n        COMPILE_TIME_ASSERT(sizeof(mhdro.flags) == sizeof(unsigned))\n    }\n    unsigned pos = sizeof(mhdro);\n    fo->write(&mhdro, sizeof(mhdro));\n\n    memset(&segZERO, 0, sizeof(segZERO));\n    segZERO.cmd = lc_seg;\n    segZERO.cmdsize = sizeof(segZERO);\n    strncpy((char *)segZERO.segname, \"__PAGEZERO\", sizeof(segZERO.segname));\n    segZERO.vmsize = PAGE_SIZE;\n    if __acc_cte(sizeof(segZERO.vmsize) == 8\n    && mhdro.filetype == Mach_header::MH_EXECUTE\n    && mhdro.cputype == Mach_header::CPU_TYPE_X86_64) {\n        if (pagezero_vmsize < 0xF0000000ull) {\n            segZERO.vmsize = pagezero_vmsize;\n        }\n        else {\n            segZERO.vmsize <<= 20;  // (1ul<<32)\n        }\n    }\n\n    segTEXT.cmd = lc_seg;\n    segTEXT.cmdsize = sizeof(segTEXT) + sizeof(secTEXT);\n    strncpy((char *)segTEXT.segname, \"__TEXT\", sizeof(segTEXT.segname));\n    if (my_filetype==Mach_header::MH_EXECUTE) {\n        if (Mach_header::MH_PIE & mhdri.flags) {\n            segTEXT.vmaddr = segZERO.vmsize;  // contiguous\n        }\n        else { // not MH_PIE\n            // Start above all eventual mappings.\n            // Cannot enlarge segZERO.vmsize because MacOS 10.13 (HighSierra)\n            // won't permit re-map of PAGEZERO.\n            // Stub will fill with PROT_NONE first.\n            segTEXT.vmaddr = vma_max;\n        }\n    }\n    if (my_filetype==Mach_header::MH_DYLIB) {\n        segTEXT.vmaddr = 0;\n    }\n    segTEXT.vmsize = 0;    // adjust later\n    segTEXT.fileoff = 0;\n    segTEXT.filesize = 0;  // adjust later\n    segTEXT.maxprot =\n        Mach_command::VM_PROT_READ |\n        Mach_command::VM_PROT_WRITE |\n        Mach_command::VM_PROT_EXECUTE;\n    segTEXT.initprot =\n        Mach_command::VM_PROT_READ |\n        Mach_command::VM_PROT_EXECUTE;\n    segTEXT.nsects = 1;  // secTEXT\n    segTEXT.flags = 0;\n\n    memset(&secTEXT, 0, sizeof(secTEXT));\n    strncpy((char *)secTEXT.sectname, \"__text\", sizeof(secTEXT.sectname));\n    memcpy(secTEXT.segname, segTEXT.segname, sizeof(secTEXT.segname));\n    secTEXT.align = 2;  // (1<<2) ==> 4\n    secTEXT.flags = Mach_section_command::S_REGULAR\n        | Mach_section_command::S_ATTR_SOME_INSTRUCTIONS\n        | Mach_section_command::S_ATTR_PURE_INSTRUCTIONS;\n\n    segXHDR = segTEXT;\n    segXHDR.cmdsize = sizeof(segXHDR) + sizeof(secXHDR);\n    segXHDR.vmaddr = segZERO.vmsize;\n    segXHDR.vmsize = PAGE_SIZE;\n    segXHDR.filesize = PAGE_SIZE;\n    segXHDR.nsects = 1;\n    strncpy((char *)segXHDR.segname,  \"UPX_DATA\", sizeof(segXHDR.segname));\n\n    memset(&secXHDR, 0, sizeof(secXHDR));\n    strncpy((char *)secXHDR.sectname, \"upx_data\", sizeof(secXHDR.sectname));\n    memcpy(secXHDR.segname,  segXHDR.segname, sizeof(secXHDR.segname));\n    secXHDR.addr = segXHDR.vmaddr;\n    secXHDR.size = 0;  // empty so far\n    secXHDR.align = 2;  // (1<<2) ==> 4\n\n    segLINK = segTEXT;\n    segLINK.cmdsize = sizeof(segLINK);\n    strncpy((char *)segLINK.segname, \"__LINKEDIT\", sizeof(segLINK.segname));\n    segLINK.initprot = Mach_command::VM_PROT_READ;\n    segLINK.nsects = 0;\n    segLINK.vmsize = 0;\n    // Adjust later: .vmaddr .vmsize .fileoff .filesize\n\n    unsigned gap = 0;\n    if (my_filetype == Mach_header::MH_EXECUTE) {\n        unsigned cmdsize = mhdro.sizeofcmds;\n        Mach_header const *const ptr0 = (Mach_header const *)stub_main;\n        Mach_command const *ptr1 = (Mach_command const *)(1+ ptr0);\n        for (unsigned j = 0; j < mhdro.ncmds -1; ++j, (cmdsize -= ptr1->cmdsize),\n                ptr1 = (Mach_command const *)(ptr1->cmdsize + (char const *)ptr1)) {\n            if (lc_seg == ptr1->cmd) {\n                Mach_segment_command const *const segptr = (Mach_segment_command const *)ptr1;\n                Mach_section_command const *const secptr = (Mach_section_command const *)(1+ segptr);\n                if (!strcmp(\"__TEXT\", segptr->segname)) {\n                    strncpy((char *)secTEXT.segname,   \"__TEXT\", sizeof(secTEXT.segname));\n                    strncpy((char *)secTEXT.sectname, \"upxTEXT\", sizeof(secTEXT.sectname));\n                    secTEXT.addr   = secptr->addr;\n                    secTEXT.size   = secptr->size;  // update later\n                    secTEXT.offset = secptr->offset;\n                    secTEXT.align  = secptr->align;\n                }\n                if (!strcmp(\"__LINKEDIT\", segptr->segname)) {\n                    // Mach_command before __LINKEDIT\n                    pos += (char const *)ptr1 - (char const *)(1+ ptr0);\n                    fo->write((1+ ptr0), (char const *)ptr1 - (char const *)(1+ ptr0));\n\n                    // Mach_command __LINKEDIT and after\n                    pos += cmdsize;\n                    fo->write((char const *)ptr1, cmdsize);\n\n                    // 400: space for LC_UUID, LC_RPATH, LC_CODE_SIGNATURE, etc.\n                    gap = 400 + threado_size();\n                    secTEXT.offset = gap + pos;\n                    secTEXT.addr = secTEXT.offset + segTEXT.vmaddr;\n                    break;\n                }\n            }\n        }\n        unsigned const sz_threado = threado_size();\n        MemBuffer space(sz_threado); memset(space, 0, sz_threado);\n        fo->write(space, sz_threado);\n    }\n    else if (my_filetype == Mach_header::MH_DYLIB) {\n        Mach_command const *ptr = (Mach_command const *)rawmseg;\n        unsigned cmdsize = mhdri.sizeofcmds;\n        for (unsigned j = 0; j < mhdri.ncmds; ++j, (cmdsize -= ptr->cmdsize),\n                ptr = (Mach_command const *)(ptr->cmdsize + (char const *)ptr)) {\n            if (lc_seg == ptr->cmd) {\n                Mach_segment_command const *const segptr = (Mach_segment_command const *)ptr;\n                Mach_section_command const *const secptr = (Mach_section_command const *)(1+ segptr);\n                if (!strcmp(\"__TEXT\", segptr->segname)) {\n                    if (!(1 <= segptr->nsects)) {\n                        throwCantPack(\"TEXT.nsects == 0\");\n                    }\n                    strncpy((char *)secTEXT.sectname, \"upxTEXT\", sizeof(secTEXT.sectname));\n                    secTEXT.addr   = secptr->addr;\n                    secTEXT.size   = secptr->size;  // update later\n                    secTEXT.offset = secptr->offset;\n                    secTEXT.align  = secptr->align;\n                    fo->write(&segTEXT, sizeof(segTEXT));\n                    fo->write(&secTEXT, sizeof(secTEXT));\n                }\n                else { // not __TEXT\n                    fo->write(ptr, ptr->cmdsize);\n                }\n            }\n            else { // not LC_SEGMENT*\n                fo->write(ptr, ptr->cmdsize);\n            }\n        }\n        memset(&linkitem, 0, sizeof(linkitem));\n        fo->write(&linkitem, sizeof(linkitem));\n    }\n    sz_mach_headers = fo->getBytesWritten();\n    gap = secTEXT.offset - sz_mach_headers;\n    MemBuffer filler(gap); filler.clear();\n    fo->write(filler, gap);\n    sz_mach_headers += gap;\n\n    memset((char *)&linfo, 0, sizeof(linfo));\n    fo->write(&linfo, sizeof(linfo));\n\n    return;\n}\n\n#define WANT_MACH_HEADER_ENUM 1\n#include \"p_mach_enum.h\"\n\nstatic unsigned\numin(unsigned a, unsigned b)\n{\n    return (a <= b) ? a : b;\n}\n\ntemplate <class T>\nvoid PackMachBase<T>::unpack(OutputFile *fo)\n{\n    unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];\n    fi->seek(0, SEEK_SET);\n    fi->readx(&mhdri, sizeof(mhdri));\n    if ((MH_MAGIC + (sizeof(Addr)>>3)) != mhdri.magic\n    &&  Mach_fat_header::FAT_MAGIC != mhdri.magic) {\n        throwCantUnpack(\"file header corrupted\");\n    }\n    unsigned const sz_cmds = mhdri.sizeofcmds;\n    if ((sizeof(mhdri) + sz_cmds) > (size_t)fi->st_size()) {\n        throwCantUnpack(\"file header corrupted\");\n    }\n    rawmseg_buf.dealloc();  // discard \"same\" contents from ::canUnpack()\n    rawmseg_buf.alloc(sz_cmds);\n    rawmseg = (Mach_segment_command *)rawmseg_buf.getVoidPtr();\n    fi->readx(rawmseg, mhdri.sizeofcmds);\n\n    // FIXME forgot space left for LC_CODE_SIGNATURE;\n    // but canUnpack() sets overlay_offset anyway.\n    //overlay_offset = sizeof(mhdri) + mhdri.sizeofcmds + sizeof(linfo);\n\n    fi->seek(overlay_offset, SEEK_SET);\n    p_info hbuf;\n    fi->readx(&hbuf, sizeof(hbuf));\n    unsigned const orig_file_size = get_te32(&hbuf.p_filesize);\n    blocksize = get_te32(&hbuf.p_blocksize);  // emacs-21.2.1 was 0x01d47e6c (== 30703212)\n    if (blocksize > orig_file_size || blocksize > UPX_RSIZE_MAX_MEM)\n        throwCantUnpack(\"file header corrupted\");\n    if (file_size > (off_t)orig_file_size) {\n        opt->info_mode += !opt->info_mode ? 1 : 0;  // make visible\n        opt->backup = 1;\n        infoWarning(\"packed size too big; discarding appended data, keeping backup\");\n    }\n\n    ibuf.alloc(blocksize + OVERHEAD);\n    b_info bhdr; memset(&bhdr, 0, sizeof(bhdr));\n    fi->readx(&bhdr, sizeof(bhdr));\n    ph.u_len = get_te32(&bhdr.sz_unc);\n    ph.c_len = get_te32(&bhdr.sz_cpr);\n    if ((unsigned)file_size < ph.c_len || ph.c_len == 0 || ph.u_len == 0)\n        throwCantUnpack(\"file header corrupted\");\n    ph.method = bhdr.b_method;\n    ph.filter = bhdr.b_ftid;\n    ph.filter_cto = bhdr.b_cto8;\n\n    // Uncompress Macho headers\n    fi->readx(ibuf, ph.c_len);\n    MemBuffer mhdr_buf(ph.u_len);\n    Mach_header *const mhdr = (Mach_header *)mhdr_buf.getVoidPtr();\n    decompress(ibuf, (upx_byte *)mhdr, false);\n    if (mhdri.magic      != mhdr->magic\n    ||  mhdri.cputype    != mhdr->cputype\n    ||  mhdri.cpusubtype != mhdr->cpusubtype\n    ||  mhdri.filetype   != mhdr->filetype)\n        throwCantUnpack(\"file header corrupted\");\n    unsigned const ncmds = mhdr->ncmds;\n\n    msegcmd_buf.alloc(sizeof(Mach_segment_command) * ncmds);\n    msegcmd = (Mach_segment_command *)msegcmd_buf.getVoidPtr();\n    unsigned char const *ptr = (unsigned char const *)(1+mhdr);\n    for (unsigned j= 0; j < ncmds; ++j) {\n        unsigned char const *const next = ((Mach_command const *)ptr)->cmdsize + ptr;\n        if (ptr_udiff(next, (1+ mhdr)) > ph.u_len) {\n            char msg[50]; snprintf(msg, sizeof(msg), \"cmdsize[%d] %#x\",\n                j, (unsigned)(next - ptr));\n            throwCantUnpack(msg);\n        }\n        memcpy(&msegcmd[j], ptr, umin(sizeof(Mach_segment_command),\n            ((Mach_command const *)ptr)->cmdsize));\n        ptr = next;\n    }\n\n    // Put LC_SEGMENT together at the beginning\n    qsort(msegcmd, ncmds, sizeof(*msegcmd), compare_segment_command);\n    n_segment = 0;\n    for (unsigned j= 0; j < ncmds; ++j) {\n        n_segment += (lc_seg==msegcmd[j].cmd);\n    }\n\n    total_in = 0;\n    total_out = 0;\n    unsigned c_adler = upx_adler32(nullptr, 0);\n    unsigned u_adler = upx_adler32(nullptr, 0);\n\n    fi->seek(- (off_t)(sizeof(bhdr) + ph.c_len), SEEK_CUR);\n    for (unsigned k = 0; k < ncmds; ++k) {\n        if (msegcmd[k].cmd==lc_seg && msegcmd[k].filesize!=0) {\n            if (!strcmp(\"__TEXT\", msegcmd[k].segname)) {\n                segTEXT = msegcmd[k];\n            }\n            if (fo)\n                fo->seek(msegcmd[k].fileoff, SEEK_SET);\n            unpackExtent(msegcmd[k].filesize, fo,\n                c_adler, u_adler, false, sizeof(bhdr));\n            if (my_filetype==Mach_header::MH_DYLIB) {\n                break;  // only the first lc_seg when MH_DYLIB\n            }\n        }\n    }\n    Mach_segment_command const *sc = (Mach_segment_command const *)(void *)(1+ mhdr);\n    if (my_filetype==Mach_header::MH_DYLIB) { // rest of lc_seg are not compressed\n        upx_uint64_t cpr_mod_init_func(0);\n                TE32 unc_mod_init_func; *(int *)&unc_mod_init_func = 0;\n        Mach_segment_command const *rc = rawmseg;\n        rc = (Mach_segment_command const *)(rc->cmdsize + (char const *)rc);\n        sc = (Mach_segment_command const *)(sc->cmdsize + (char const *)sc);\n        for (\n            unsigned k=1;  // skip first lc_seg, which was uncompressed above\n            k < ncmds;\n            (++k), (sc = (Mach_segment_command const *)(sc->cmdsize + (char const *)sc)),\n                   (rc = (Mach_segment_command const *)(rc->cmdsize + (char const *)rc))\n        ) {\n            if (lc_seg==rc->cmd\n            &&  0!=rc->filesize ) {\n                if (!strcmp(\"__DATA\", rc->segname)) {\n                    cpr_mod_init_func = get_mod_init_func(rc);\n                    fi->seek(cpr_mod_init_func - 4*sizeof(TE32), SEEK_SET);\n                    fi->readx(&unc_mod_init_func, sizeof(unc_mod_init_func));\n                }\n                fi->seek(rc->fileoff, SEEK_SET);\n                if (fo)\n                    fo->seek(sc->fileoff, SEEK_SET);\n                unsigned const len = rc->filesize;\n                MemBuffer data(len);\n                fi->readx(data, len);\n                if (!strcmp(\"__DATA\", rc->segname)) {\n                    set_te32(&data[o__mod_init_func - rc->fileoff], unc_mod_init_func);\n                }\n                if (fo)\n                    fo->write(data, len);\n            }\n        }\n    }\n    else\n    for (unsigned j = 0; j < ncmds; ++j) {\n        unsigned const size = find_SEGMENT_gap(j, orig_file_size);\n        if (size) {\n            unsigned const where = msegcmd[j].fileoff +msegcmd[j].filesize;\n            if (fo)\n                fo->seek(where, SEEK_SET);\n            unpackExtent(size, fo,\n                c_adler, u_adler, false, sizeof(bhdr));\n        }\n    }\n}\n\n// The prize is the value of overlay_offset: the offset of compressed data\ntemplate <class T>\nint PackMachBase<T>::canUnpack()\n{\n    unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];\n    fi->seek(0, SEEK_SET);\n    fi->readx(&mhdri, sizeof(mhdri));\n\n    if (((unsigned) Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) !=mhdri.magic\n    ||  my_cputype   !=mhdri.cputype\n    ||  my_filetype  !=mhdri.filetype\n    )\n        return false;\n    my_cpusubtype = mhdri.cpusubtype;\n\n    unsigned const ncmds = mhdri.ncmds;\n    int headway = (int)mhdri.sizeofcmds;\n    // old style:   LC_SEGMENT + LC_UNIXTHREAD  [smaller, varies by $ARCH]\n    // new style: 3*LC_SEGMENT + LC_MAIN        [larger]\n    if ((2 == ncmds\n        && headway < (int)(sizeof(Mach_segment_command) + 4*4))\n    ||  (3 <= ncmds\n        && headway < (int)(3 * sizeof(Mach_segment_command)\n                    + sizeof(Mach_main_command)))) {\n        infoWarning(\"Mach_header.sizeofcmds = %d too small\", headway);\n        throwCantUnpack(\"file corrupted\");\n    }\n    sz_mach_headers = headway + sizeof(mhdri);\n    if (2048 < headway) {\n        infoWarning(\"Mach_header.sizeofcmds(%d) > 2048\", headway);\n    }\n    if(!headway){\n        throwCantPack(\"Mach_header.sizeofcmds == 0\");\n    }\n    rawmseg_buf.alloc(mhdri.sizeofcmds);\n    rawmseg = (Mach_segment_command *)rawmseg_buf.getVoidPtr();\n    fi->readx(rawmseg, mhdri.sizeofcmds);\n\n    Mach_segment_command const *ptrTEXT = nullptr;\n    upx_uint64_t rip = 0;\n    unsigned style = 0;\n    off_t offLINK = 0;\n    unsigned pos_next = 0;\n    unsigned nseg = 0;\n    Mach_command const *ptr = (Mach_command const *)rawmseg;\n    for (unsigned j= 0; j < ncmds;\n            ptr = (Mach_command const *)(ptr->cmdsize + (char const *)ptr), ++j) {\n        if ((unsigned)headway < ptr->cmdsize) {\n                infoWarning(\"bad Mach_command[%u]{@0x%lx,+0x%x}: file_size=0x%lx  cmdsize=0x%lx\",\n                    j, (unsigned long) (sizeof(mhdri) + ((char const *)ptr - (char const *)rawmseg)), headway,\n                    (unsigned long) file_size, (unsigned long)ptr->cmdsize);\n                throwCantUnpack(\"file corrupted\");\n        }\n        if (lc_seg == ptr->cmd) {\n            Mach_segment_command const *const segptr = (Mach_segment_command const *)ptr;\n            if ((unsigned long)file_size < segptr->filesize\n            ||  (unsigned long)file_size < segptr->fileoff\n            ||  (unsigned long)file_size < (segptr->filesize + segptr->fileoff)) {\n                infoWarning(\"bad Mach_segment_command[%u]{@0x%lx,+0x%x}: file_size=0x%lx  cmdsize=0x%lx\"\n                      \"  filesize=0x%lx  fileoff=0x%lx\",\n                    j, (unsigned long) (sizeof(mhdri) + ((char const *)ptr - (char const *)rawmseg)), headway,\n                    (unsigned long) file_size, (unsigned long)ptr->cmdsize,\n                    (unsigned long)segptr->filesize, (unsigned long)segptr->fileoff);\n                throwCantUnpack(\"file corrupted\");\n            }\n            ++nseg;\n            if (!strcmp(\"__XHDR\", segptr->segname)) {\n                // PackHeader precedes __LINKEDIT (pre-Sierra MacOS 10.12)\n                style = 391;  // UPX 3.91\n            }\n            if (!strcmp(\"__TEXT\", segptr->segname)) {\n                ptrTEXT = segptr;\n                style = 391;  // UPX 3.91\n            }\n            if (!strcmp(\"UPX_DATA\", segptr->segname)) {\n                // PackHeader follows loader at __LINKEDIT (Sierra MacOS 10.12)\n                style = 392;  // UPX 3.92\n            }\n            if (!strcmp(\"__LINKEDIT\", segptr->segname)) {\n                offLINK = segptr->fileoff;\n                if (segptr->filesize == blankLINK) {\n                    style = 395;\n                }\n                if (offLINK < (off_t) pos_next) {\n                    offLINK = pos_next;\n                }\n            }\n            pos_next = segptr->filesize + segptr->fileoff;\n            if ((headway -= ptr->cmdsize) < 0) {\n                infoWarning(\"Mach_command[%u]{@%lu}.cmdsize = %u\", j,\n                    (unsigned long) (sizeof(mhdri) + mhdri.sizeofcmds - (headway + ptr->cmdsize)),\n                    (unsigned)ptr->cmdsize);\n                throwCantUnpack(\"sum(.cmdsize) exceeds .sizeofcmds\");\n            }\n        }\n        else if (Mach_command::LC_UNIXTHREAD==ptr->cmd) {\n            rip = entryVMA = threadc_getPC(ptr);\n        }\n    }\n    if (3==nseg && 395 != style) { // __PAGEZERO, __TEXT, __LINKEDIT;  no __XHDR, no UPX_DATA\n        style = 392;\n    }\n    if (391==style && 0==offLINK && 2==ncmds && ptrTEXT) { // pre-3.91 ?\n        offLINK = ptrTEXT->fileoff + ptrTEXT->filesize;  // fake __LINKEDIT at EOF\n    }\n    if (0 == style || 0 == offLINK) {\n        return false;\n    }\n\n    int const small = 32 + sizeof(overlay_offset);\n    unsigned bufsize = 4096;\n    if (391 == style) { // PackHeader precedes __LINKEDIT\n        fi->seek(offLINK - bufsize, SEEK_SET);\n    } else\n    if (392 == style) {\n        if (MH_DYLIB == my_filetype) {\n            fi->seek(fi->st_size() - bufsize, SEEK_SET);\n        }\n        else { // PackHeader follows loader at __LINKEDIT\n            if ((off_t)bufsize > (fi->st_size() - offLINK)) {\n                bufsize = fi->st_size() - offLINK;\n            }\n            fi->seek(offLINK, SEEK_SET);\n        }\n    } else\n    if (395 == style) {\n        fi->seek(offLINK - bufsize - sizeof(PackHeader), SEEK_SET);\n    }\n    MemBuffer buf(bufsize);\n\n    fi->readx(buf, bufsize);\n    int i = bufsize;\n    while (i > small && 0 == buf[--i]) { }\n    i -= small;\n    // allow incompressible extents\n    if (i < 1 || !getPackHeader(buf + i, bufsize - i, true)) {\n        // Breadcrumbs failed.\n        // Pirates might overwrite the UPX! marker.  Try harder.\n        upx_uint64_t const rip_off = ptrTEXT ? (rip - ptrTEXT->vmaddr) : 0;\n        if (ptrTEXT && rip && rip_off < ptrTEXT->vmsize) {\n            fi->seek(ptrTEXT->fileoff + rip_off, SEEK_SET);\n            fi->readx(buf, bufsize);\n            unsigned char const *b = &buf[0];\n            unsigned disp = *(TE32 const *)&b[1];\n            // Emulate the code\n            if (0xe8==b[0] && disp < bufsize\n            &&  0x5d==b[5+disp] && 0xe8==b[6+disp]) {\n                unsigned disp2 = 0u - *(TE32 const *)&b[7+disp];\n                if (disp2 < (12+disp) && 0x5b==b[11+disp-disp2]) {\n                    struct b_info const *bptr = (struct b_info const *)&b[11+disp];\n                    // This is the folded stub.\n                    // FIXME: check b_method?\n                    if (bptr->sz_cpr < bptr->sz_unc && bptr->sz_unc < 0x1000) {\n                        b = bptr->sz_cpr + (unsigned char const *)(1+ bptr);\n                        // FIXME: check PackHeader::putPackHeader(), packhead.cpp\n                        overlay_offset = *(TE32 const *)(32 + b);\n                        if (overlay_offset < 0x1000) {\n                            return true;  // success\n                        }\n                        overlay_offset = 0;\n                    }\n                }\n            }\n        }\n        if (391==style) {\n            TE32 const *uptr = (TE32 const *)&buf[bufsize];\n            while (0==*--uptr) /*empty*/ ;\n            overlay_offset = *uptr;\n            if (mhdri.sizeofcmds <= overlay_offset && overlay_offset < 0x1000) {\n                return true;  // success\n            }\n            overlay_offset = 0;\n            return false;\n        }\n        if (392==style) {\n            overlay_offset = 0x100c;  // (l_info precedes;) p_info; b_info; cpr_data\n            // p_info isn't used for execution, so it has less value for checking:\n            //      0== .p_progid\n            //      .p_filesize == .p_blocksize\n            fi->seek(overlay_offset, SEEK_SET);\n            fi->readx(buf, bufsize);\n            struct p_info const *const p_ptr = (struct p_info const *)&buf[0];\n            struct b_info const *const b_ptr = (struct b_info const *)(1+ p_ptr);\n            TE32 const *uptr = (TE32 const *)(1+ b_ptr);\n            if (b_ptr->sz_unc < 0x4000\n            &&  b_ptr->sz_cpr < b_ptr->sz_unc ) {\n                unsigned const method = b_ptr->b_method;\n                if ((M_NRV2B_LE32 == method || M_NRV2E_LE32 == method)\n                &&  (0xff>>2)==(uptr[0] >> (2+ 24))  // 1st 6 bytes are unique literals\n                &&  (Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) == uptr[1]) {\n                    return true;\n                }\n                unsigned const magic = get_te32(1+ (char const *)uptr);\n                if ((M_NRV2B_8 == method || M_NRV2E_8 == method)\n                && 0xfc==(0xfc & uptr[0])\n                &&  (Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) == magic) {\n                    return true;\n                }\n                // FIXME: M_LZMA\n            }\n\n            overlay_offset = 0;\n            // The first non-zero word scanning backwards from __LINKEDIT.fileoff\n            // is the total length of compressed data which precedes it\n            //(distance to l_info), so that's another method.\n            fi->seek(offLINK - 0x1000, SEEK_SET);\n            fi->readx(buf, 0x1000);\n            unsigned const *const lo = (unsigned const *)&buf[0];\n            unsigned const *p;\n            for (p = (unsigned const *)&buf[0x1000]; p > lo; ) if (*--p) {\n                overlay_offset  = *(TE32 const *)p;\n                if ((off_t)overlay_offset < offLINK) {\n                    overlay_offset = ((char const *)p - (char const *)lo) +\n                        (offLINK - 0x1000) - overlay_offset + sizeof(l_info);\n                    fi->seek(overlay_offset, SEEK_SET);\n                    fi->readx(buf, bufsize);\n                    if (b_ptr->sz_unc < 0x4000\n                    &&  b_ptr->sz_cpr < b_ptr->sz_unc ) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n\n    overlay_offset = 0;  // impossible value\n    int l = ph.buf_offset + ph.getPackHeaderSize();\n    if (0 <= l && (unsigned)(l + sizeof(TE32)) <=bufsize) {\n        overlay_offset = get_te32(buf + i + l);\n    }\n    if (       overlay_offset < sz_mach_headers\n    ||  (off_t)overlay_offset >= file_size) {\n        infoWarning(\"file corrupted\");\n        MemBuffer buf2(umin(1<<14, file_size));\n        fi->seek(sz_mach_headers, SEEK_SET);\n        fi->readx(buf2, buf2.getSize());\n        unsigned const *p = (unsigned const *)&buf2[0];\n        unsigned const *const e_buf2 = (unsigned const *)&buf2[buf2.getSize() - 4*sizeof(*p)];\n        for (; p <= e_buf2; ++p)\n        if (   0==p[0]  // p_info.p_progid\n        &&     0!=p[1]  // p_info.p_filesize\n        &&  p[2]==p[1]  // p_info.p_blocksize == p_info.p_filesize\n        &&  (unsigned)file_size < get_te32(&p[1])  // compression was worthwhile\n        &&  sz_mach_headers==get_te32(&p[3])  // b_info.sz_unc\n        ) {\n            overlay_offset = ((char const *)p - (char const *)&buf2[0]) + sz_mach_headers;\n            if (!(3&overlay_offset  // not word aligned\n                    ||        overlay_offset < sz_mach_headers\n                    || (off_t)overlay_offset >= file_size)) {\n                infoWarning(\"attempting recovery, overlay_offset = %#x\", overlay_offset);\n                return true;\n            }\n        }\n        throwCantUnpack(\"file corrupted\");\n    }\n    return true;\n}\n#define WANT_MACH_SEGMENT_ENUM\n#define WANT_MACH_SECTION_ENUM\n#include \"p_mach_enum.h\"\n\ntemplate <class T>\nupx_uint64_t PackMachBase<T>::get_mod_init_func(Mach_segment_command const *segptr)\n{\n    for (Mach_section_command const *secptr = (Mach_section_command const *)(1+ segptr);\n        ptr_udiff(secptr, segptr) < segptr->cmdsize;\n        ++secptr\n    ) {\n        if (sizeof(Addr) == secptr->size\n        && !strcmp(\"__mod_init_func\", secptr->sectname)) {\n            o__mod_init_func = secptr->offset;\n            fi->seek(o__mod_init_func, SEEK_SET);\n            Addr tmp;\n            fi->readx(&tmp, sizeof(Addr));\n            return tmp;\n        }\n    }\n    return 0;\n}\n\ntemplate <class T>\nbool PackMachBase<T>::canPack()\n{\n    unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];\n    fi->seek(0, SEEK_SET);\n    fi->readx(&mhdri, sizeof(mhdri));\n\n    if (((unsigned) Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) !=mhdri.magic\n    ||  my_cputype   !=mhdri.cputype\n    ||  my_filetype  !=mhdri.filetype\n    )\n        return false;\n    my_cpusubtype = mhdri.cpusubtype;\n\n    unsigned const ncmds = mhdri.ncmds;\n    if (!ncmds || 256 < ncmds) { // arbitrary, but guard against garbage\n        throwCantPack(\"256 < Mach_header.ncmds\");\n    }\n    unsigned const sz_mhcmds = (unsigned)mhdri.sizeofcmds;\n    unsigned headway = file_size - sizeof(mhdri);\n    if (headway < sz_mhcmds) {\n        char buf[32]; snprintf(buf, sizeof(buf), \"bad sizeofcmds %d\", sz_mhcmds);\n        throwCantPack(buf);\n    }\n    if (!sz_mhcmds\n    ||  16384 < sz_mhcmds) { // somewhat arbitrary, but amd64-darwin.macho-upxmain.c\n        throwCantPack(\"16384 < Mach_header.sizeofcmds (or ==0)\");\n    }\n    rawmseg_buf.alloc(sz_mhcmds);\n    rawmseg = (Mach_segment_command *)(void *)rawmseg_buf;\n    fi->readx(rawmseg, mhdri.sizeofcmds);\n\n    msegcmd_buf.alloc(sizeof(Mach_segment_command) * ncmds);\n    msegcmd = (Mach_segment_command *)msegcmd_buf.getVoidPtr();\n    unsigned char const *ptr = (unsigned char const *)rawmseg;\n    for (unsigned j= 0; j < ncmds; ++j) {\n        Mach_segment_command const *segptr = (Mach_segment_command const *)ptr;\n        if (headway < ((Mach_command const *)ptr)->cmdsize) {\n            char buf[64]; snprintf(buf, sizeof(buf),\n                \"bad Mach_command[%d]{%#x, %#x}\", j,\n                (unsigned)segptr->cmd, (unsigned)((Mach_command const *)ptr)->cmdsize);\n            throwCantPack(buf);\n        }\n        headway -= ((Mach_command const *)ptr)->cmdsize;\n        if (lc_seg == segptr->cmd) {\n            msegcmd[j] = *segptr;\n            if (!strcmp(\"__TEXT\", segptr->segname)) {\n                Mach_section_command const *secp =\n                    (Mach_section_command const *)(const void*)(const char*)(1+ segptr);\n                unsigned const offset = secp->offset;\n                if (offset < file_size) {\n                    struct l_info h;\n                    fi->seek(offset, SEEK_SET);\n                    fi->readx(&h, sizeof(h));\n                    checkAlreadyPacked(&h, sizeof(h));\n                }\n            }\n            if (!strcmp(\"__DATA\", segptr->segname)) {\n                prev_mod_init_func = get_mod_init_func(segptr);\n            }\n        }\n        else {\n            memcpy(&msegcmd[j], ptr, 2*sizeof(unsigned)); // cmd and cmdsize\n        }\n        switch (((Mach_uuid_command const *)ptr)->cmd) {\n        default: break;\n        case Mach_command::LC_UUID: {\n            memcpy(&cmdUUID, ptr, sizeof(cmdUUID));  // remember the UUID\n            // Set output UUID to be 1 more than the input UUID.\n            for (unsigned k = 0; k < sizeof(cmdUUID.uuid); ++k) {\n                if (0 != ++cmdUUID.uuid[k]) { // no Carry\n                    break;\n                }\n            }\n        } break;\n        case Mach_command::LC_VERSION_MIN_MACOSX: {\n            memcpy(&cmdVERMIN, ptr, sizeof(cmdVERMIN));\n        } break;\n        case Mach_command::LC_SOURCE_VERSION: {\n            memcpy(&cmdSRCVER, ptr, sizeof(cmdSRCVER));\n        } break;\n        }\n        ptr += (unsigned) ((Mach_command const *)ptr)->cmdsize;\n    }\n    if (Mach_header::MH_DYLIB==my_filetype && 0==o__mod_init_func) {\n        infoWarning(\"missing -init function\");\n        return false;\n    }\n\n    // Put LC_SEGMENT together at the beginning\n    qsort(msegcmd, ncmds, sizeof(*msegcmd), compare_segment_command);\n\n    if (lc_seg==msegcmd[0].cmd && 0==msegcmd[0].vmaddr\n    &&  !strcmp(\"__PAGEZERO\", msegcmd[0].segname)) {\n        pagezero_vmsize = msegcmd[0].vmsize;\n    }\n\n    // Check alignment of non-null LC_SEGMENT.\n    vma_max = 0;\n    for (unsigned j= 0; j < ncmds; ++j) {\n        if (lc_seg==msegcmd[j].cmd) {\n            ++n_segment;\n            if (~PAGE_MASK & (msegcmd[j].fileoff | msegcmd[j].vmaddr)) {\n                return false;\n            }\n            upx_uint64_t t = msegcmd[j].vmsize + msegcmd[j].vmaddr;\n            if (vma_max < t) {\n                vma_max = t;\n            }\n            // Segments need not be contigous (esp. \"rust\"/\"go\")\n            sz_segment = msegcmd[j].filesize + msegcmd[j].fileoff - msegcmd[0].fileoff;\n        }\n    }\n    vma_max = PAGE_MASK & (~PAGE_MASK + vma_max);\n\n    // info: currently the header is 36 (32+4) bytes before EOF\n    unsigned char buf[256];\n    fi->seek(-(off_t)sizeof(buf), SEEK_END);\n    fi->readx(buf, sizeof(buf));\n    checkAlreadyPacked(buf, sizeof(buf));\n\n    // set options\n    opt->o_unix.blocksize = file_size;\n    if (!n_segment) {\n        return false;\n    }\n    static struct {\n        unsigned cputype;\n        unsigned short filetype;\n        unsigned short sz_stub_entry;\n        unsigned short sz_stub_fold;\n        unsigned short sz_stub_main;\n        upx_byte const *stub_entry;\n        upx_byte const *stub_fold;\n        upx_byte const *stub_main;\n    } const stub_list[] = {\n        {CPU_TYPE_I386, MH_EXECUTE,\n            sizeof(stub_i386_darwin_macho_entry),\n            sizeof(stub_i386_darwin_macho_fold),\n            sizeof(stub_i386_darwin_macho_upxmain_exe),\n                   stub_i386_darwin_macho_entry,\n                   stub_i386_darwin_macho_fold,\n                   stub_i386_darwin_macho_upxmain_exe\n        },\n        {CPU_TYPE_I386, MH_DYLIB,\n            sizeof(stub_i386_darwin_dylib_entry), 0, 0,\n                   stub_i386_darwin_dylib_entry,  nullptr, nullptr\n        },\n        {CPU_TYPE_X86_64, MH_EXECUTE,\n            sizeof(stub_amd64_darwin_macho_entry),\n            sizeof(stub_amd64_darwin_macho_fold),\n            0, //sizeof(stub_amd64_darwin_macho_upxmain_exe),\n                   stub_amd64_darwin_macho_entry,\n                   stub_amd64_darwin_macho_fold,\n                   nullptr // stub_amd64_darwin_macho_upxmain_exe\n        },\n        {CPU_TYPE_X86_64, MH_DYLIB,\n            sizeof(stub_amd64_darwin_dylib_entry), 0, 0,\n                   stub_amd64_darwin_dylib_entry,  nullptr, nullptr\n        },\n        {CPU_TYPE_ARM, MH_EXECUTE,\n            sizeof(stub_arm_v5a_darwin_macho_entry),\n            sizeof(stub_arm_v5a_darwin_macho_fold),\n            0,\n                   stub_arm_v5a_darwin_macho_entry,\n                   stub_arm_v5a_darwin_macho_fold,\n                   nullptr\n        },\n        {CPU_TYPE_ARM64, MH_EXECUTE,\n            sizeof(stub_arm64_darwin_macho_entry),\n            sizeof(stub_arm64_darwin_macho_fold),\n            0,\n                   stub_arm64_darwin_macho_entry,\n                   stub_arm64_darwin_macho_fold,\n                   nullptr\n        },\n        {CPU_TYPE_POWERPC, MH_EXECUTE,\n            sizeof(stub_powerpc_darwin_macho_entry),\n            sizeof(stub_powerpc_darwin_macho_fold),\n            sizeof(stub_powerpc_darwin_macho_upxmain_exe),\n                   stub_powerpc_darwin_macho_entry,\n                   stub_powerpc_darwin_macho_fold,\n                   stub_powerpc_darwin_macho_upxmain_exe\n        },\n        {CPU_TYPE_POWERPC, MH_DYLIB,\n            sizeof(stub_powerpc_darwin_dylib_entry), 0, 0,\n                   stub_powerpc_darwin_dylib_entry,  nullptr, nullptr\n        },\n        {CPU_TYPE_POWERPC64LE, MH_EXECUTE,\n            sizeof(stub_powerpc64le_darwin_macho_entry),\n            sizeof(stub_powerpc64le_darwin_macho_fold),\n            0,\n                   stub_powerpc64le_darwin_macho_entry,\n                   stub_powerpc64le_darwin_macho_fold,\n                   nullptr\n        },\n        {CPU_TYPE_POWERPC64LE, MH_DYLIB,\n            sizeof(stub_powerpc64le_darwin_dylib_entry), 0, 0,\n                   stub_powerpc64le_darwin_dylib_entry,  nullptr, nullptr\n        },\n        {0,0, 0,0,0, nullptr,nullptr,nullptr}\n    };\n    for (unsigned j = 0; stub_list[j].cputype; ++j) {\n        if (stub_list[j].cputype  == my_cputype\n        &&  stub_list[j].filetype == my_filetype) {\n            sz_stub_entry = stub_list[j].sz_stub_entry;\n               stub_entry = stub_list[j].stub_entry;\n            sz_stub_fold  = stub_list[j].sz_stub_fold;\n               stub_fold  = stub_list[j].stub_fold;\n            sz_stub_main  = stub_list[j].sz_stub_main;\n               stub_main  = stub_list[j].stub_main;\n            if (!stub_main) { // development stub\n                static struct {\n                    Mach_header mhdri;\n                    Mach_segment_command segZERO;\n                    Mach_segment_command segTEXT;\n                    Mach_section_command secTEXT;\n                    Mach_segment_command segLINK;\n                    Mach_version_min_command cmdVERMIN;\n                    Mach_source_version_command cmdSRCVER;\n                } fsm;  // fake_stub_main\n                fsm.mhdri = mhdri;\n                fsm.mhdri.ncmds = 5;\n                fsm.mhdri.sizeofcmds = sizeof(fsm) - sizeof(fsm.mhdri);\n                fsm.mhdri.flags = MH_NOUNDEFS | MH_PIE;\n\n                fsm.segZERO.cmd = LC_SEGMENT + (fsm.mhdri.cputype >> 24)\n                    * (LC_SEGMENT_64 - LC_SEGMENT);\n                fsm.segZERO.cmdsize = sizeof(Mach_segment_command);\n                strncpy(fsm.segZERO.segname, \"__PAGEZERO\", sizeof(fsm.segZERO.segname));\n                fsm.segZERO.vmaddr = 0;\n                fsm.segZERO.vmsize = (4<<16);\n                if __acc_cte(8==sizeof(void *)) fsm.segZERO.vmsize <<= (32 - 18);\n                fsm.segZERO.fileoff = 0;\n                fsm.segZERO.filesize = 0;\n                fsm.segZERO.maxprot = 0;\n                fsm.segZERO.initprot = 0;\n                fsm.segZERO.nsects = 0;\n                fsm.segZERO.flags = 0;\n\n                unsigned const slop = 400;\n                fsm.segTEXT.cmd = fsm.segZERO.cmd;\n                fsm.segTEXT.cmdsize = sizeof(Mach_segment_command)\n                    + sizeof(Mach_section_command);\n                strncpy(fsm.segTEXT.segname, \"__TEXT\", sizeof(fsm.segTEXT.segname));\n                fsm.segTEXT.vmaddr = fsm.segZERO.vmsize;\n                fsm.segTEXT.vmsize = slop + threado_size() + sizeof(fsm);  // dummy\n                fsm.segTEXT.fileoff = 0;\n                fsm.segTEXT.filesize = fsm.segTEXT.vmsize;  // dummy\n                fsm.segTEXT.maxprot = VM_PROT_EXECUTE | VM_PROT_READ;\n                fsm.segTEXT.initprot = VM_PROT_EXECUTE | VM_PROT_READ;\n                fsm.segTEXT.nsects = 1;\n                fsm.segTEXT.flags = 0;\n\n                strncpy(fsm.secTEXT.sectname, \"__text\", sizeof(fsm.secTEXT.sectname));\n                memcpy(fsm.secTEXT.segname, fsm.segTEXT.segname, sizeof(fsm.secTEXT.segname));\n                unsigned const d = slop + fsm.mhdri.sizeofcmds;\n                fsm.secTEXT.addr = fsm.segTEXT.vmaddr + d;  // dummy\n                fsm.secTEXT.size = fsm.segTEXT.vmsize - d;  // dummy\n                fsm.secTEXT.offset = d;  // dummy\n                fsm.secTEXT.align = 3;  // (1<<2)\n                fsm.secTEXT.reloff = 0;\n                fsm.secTEXT.nreloc = 0;\n                fsm.secTEXT.flags = S_REGULAR | S_ATTR_PURE_INSTRUCTIONS | S_ATTR_SOME_INSTRUCTIONS;\n                fsm.secTEXT.reserved1 = 0;\n                fsm.secTEXT.reserved2 = 0;\n\n                fsm.segLINK = fsm.segTEXT;\n                fsm.segLINK.cmdsize = sizeof(Mach_segment_command);\n                strncpy(fsm.segLINK.segname, \"__LINKEDIT\", sizeof(fsm.segLINK.segname));\n                fsm.segLINK.vmaddr = fsm.segTEXT.vmaddr + fsm.segTEXT.vmsize;  // dummy\n                fsm.segLINK.vmsize = 0x1000;  // dummy\n                fsm.segLINK.fileoff = fsm.segTEXT.fileoff + fsm.segTEXT.filesize;\n                fsm.segLINK.filesize = fsm.segLINK.vmsize;\n                fsm.segLINK.maxprot = VM_PROT_READ;\n                fsm.segLINK.initprot = VM_PROT_READ;\n                fsm.segLINK.nsects = 0;\n\n                fsm.cmdVERMIN.cmd = LC_VERSION_MIN_MACOSX;  // LC_VERSION_MIN_IPHONEOS\n                fsm.cmdVERMIN.cmdsize = 4*4;\n                fsm.cmdVERMIN.version = (10<<16)|(12<<8);\n                fsm.cmdVERMIN.sdk = fsm.cmdVERMIN.version;\n\n                fsm.cmdSRCVER.cmd = LC_SOURCE_VERSION;\n                fsm.cmdSRCVER.cmdsize = 4*4;\n                fsm.cmdSRCVER.version = 0;\n                fsm.cmdSRCVER.__pad = 0;\n\n                sz_stub_main  = sizeof(fsm);\n                   stub_main  = (unsigned char const *)&fsm;\n            }\n            break;\n        }\n    }\n    return true;\n}\n\ntemplate class PackMachBase<MachClass_BE32>;\ntemplate class PackMachBase<MachClass_LE32>;\ntemplate class PackMachBase<MachClass_LE64>;\n\n\nPackMachFat::PackMachFat(InputFile *f) : super(f)\n{\n    bele = &N_BELE_RTP::le_policy;  // sham\n}\n\nPackMachFat::~PackMachFat()\n{\n}\n\nunsigned PackMachFat::check_fat_head()\n{\n    struct Mach_fat_arch const *const arch = &fat_head.arch[0];\n    unsigned nfat = fat_head.fat.nfat_arch;\n    if (Mach_fat_header::FAT_MAGIC!=fat_head.fat.magic\n    ||  N_FAT_ARCH < nfat) {\n        return 0;\n    }\n    for (unsigned j=0; j < nfat; ++j) {\n        unsigned const align = arch[j].align;\n        unsigned const mask = ~(~0u<<align);\n        unsigned const size = arch[j].size;\n        unsigned const offset = arch[j].offset;\n        if (align < 12 || align > 24) { // heuristic\n            throwUnknownExecutableFormat(\"align\", 0);\n        }\n        if (mask > size) {\n            throwUnknownExecutableFormat(\"size\", 0);\n        }\n        if (mask & offset\n        ||  (unsigned)fi->st_size_orig() < size + offset\n        ||  (unsigned)fi->st_size_orig() <= offset) {  // redundant unless overflow\n            throwUnknownExecutableFormat(\"offset\", 0);\n        }\n    }\n    return nfat;\n}\n\nconst int *PackMachFat::getCompressionMethods(int /*method*/, int /*level*/) const\n{\n    static const int m_nrv2e[] = { M_NRV2E_LE32, M_END };\n    return m_nrv2e;  // sham\n}\n\nconst int *PackMachFat::getFilters() const\n{\n    static const int filters[] = { 0x49, FT_END };\n    return filters;  // sham\n}\n\nvoid PackMachFat::pack(OutputFile *fo)\n{\n    unsigned const in_size = this->file_size;\n    fo->write(&fat_head, sizeof(fat_head.fat) +\n        fat_head.fat.nfat_arch * sizeof(fat_head.arch[0]));\n    unsigned length = 0;\n    for (unsigned j=0; j < fat_head.fat.nfat_arch; ++j) {\n        unsigned base = fo->unset_extent();  // actual length\n        base += ~(~0u<<fat_head.arch[j].align) & (0-base);  // align up\n        fo->seek(base, SEEK_SET);\n        fo->set_extent(base, ~0u);\n\n        ph.u_file_size = fat_head.arch[j].size;\n        fi->set_extent(fat_head.arch[j].offset, fat_head.arch[j].size);\n        fi->seek(0, SEEK_SET);\n        switch (fat_head.arch[j].cputype) {\n        case PackMachFat::CPU_TYPE_I386: {\n            typedef N_Mach::Mach_header<MachClass_LE32::MachITypes> Mach_header;\n            Mach_header hdr;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachI386 packer(fi);\n                packer.initPackHeader();\n                packer.canPack();\n                packer.updatePackHeader();\n                packer.pack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibI386 packer(fi);\n                packer.initPackHeader();\n                packer.canPack();\n                packer.updatePackHeader();\n                packer.pack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_X86_64: {\n            typedef N_Mach::Mach_header<MachClass_LE64::MachITypes> Mach_header;\n            Mach_header hdr;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachAMD64 packer(fi);\n                packer.initPackHeader();\n                packer.canPack();\n                packer.updatePackHeader();\n                packer.pack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibAMD64 packer(fi);\n                packer.initPackHeader();\n                packer.canPack();\n                packer.updatePackHeader();\n                packer.pack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC: {\n            typedef N_Mach::Mach_header<MachClass_BE32::MachITypes> Mach_header;\n            Mach_header hdr;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachPPC32 packer(fi);\n                packer.initPackHeader();\n                packer.canPack();\n                packer.updatePackHeader();\n                packer.pack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibPPC32 packer(fi);\n                packer.initPackHeader();\n                packer.canPack();\n                packer.updatePackHeader();\n                packer.pack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC64LE: {\n            typedef N_Mach::Mach_header<MachClass_LE64::MachITypes> Mach_header;\n            Mach_header hdr;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachPPC64LE packer(fi);\n                packer.initPackHeader();\n                packer.canPack();\n                packer.updatePackHeader();\n                packer.pack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibPPC64LE packer(fi);\n                packer.initPackHeader();\n                packer.canPack();\n                packer.updatePackHeader();\n                packer.pack(fo);\n            }\n        } break;\n        }  // switch cputype\n        fat_head.arch[j].offset = base;\n        length = fo->unset_extent();\n        fat_head.arch[j].size = length - base;\n    }\n    ph.u_file_size = in_size;\n    fi->set_extent(0, in_size);\n\n    fo->seek(0, SEEK_SET);\n    fo->rewrite(&fat_head, sizeof(fat_head.fat) +\n        fat_head.fat.nfat_arch * sizeof(fat_head.arch[0]));\n    fo->set_extent(0, length);\n}\n\nvoid PackMachFat::unpack(OutputFile *fo)\n{\n    if (fo) {  // test mode (\"-t\") sets fo = nullptr\n        fo->seek(0, SEEK_SET);\n        fo->write(&fat_head, sizeof(fat_head.fat) +\n            fat_head.fat.nfat_arch * sizeof(fat_head.arch[0]));\n    }\n    unsigned const nfat = check_fat_head();\n    unsigned length;\n    for (unsigned j=0; j < nfat; ++j) {\n        unsigned base = (fo ? fo->unset_extent() : 0);  // actual length\n        base += ~(~0u<<fat_head.arch[j].align) & (0-base);  // align up\n        if (fo) {\n            fo->seek(base, SEEK_SET);\n            fo->set_extent(base, ~0u);\n        }\n\n        ph.u_file_size = fat_head.arch[j].size;\n        fi->set_extent(fat_head.arch[j].offset, fat_head.arch[j].size);\n        fi->seek(0, SEEK_SET);\n        switch (fat_head.arch[j].cputype) {\n        case PackMachFat::CPU_TYPE_I386: {\n            N_Mach::Mach_header<MachClass_LE32::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE32::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachI386 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibI386 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_X86_64: {\n            N_Mach::Mach_header<MachClass_LE64::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE64::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachAMD64 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibAMD64 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC: {\n            N_Mach::Mach_header<MachClass_BE32::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_BE32::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachPPC32 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibPPC32 packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC64LE: {\n            N_Mach::Mach_header<MachClass_LE64::MachITypes> hdr;\n            typedef N_Mach::Mach_header<MachClass_LE64::MachITypes> Mach_header;\n            fi->readx(&hdr, sizeof(hdr));\n            if (hdr.filetype==Mach_header::MH_EXECUTE) {\n                PackMachPPC64LE packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n            else if (hdr.filetype==Mach_header::MH_DYLIB) {\n                PackDylibPPC64LE packer(fi);\n                packer.initPackHeader();\n                packer.canUnpack();\n                packer.unpack(fo);\n            }\n        } break;\n        }  // switch cputype\n        fat_head.arch[j].offset = base;\n        length = (fo ? fo->unset_extent() : 0);\n        fat_head.arch[j].size = length - base;\n    }\n    if (fo) {\n        fo->unset_extent();\n        fo->seek(0, SEEK_SET);\n        fo->rewrite(&fat_head, sizeof(fat_head.fat) +\n            fat_head.fat.nfat_arch * sizeof(fat_head.arch[0]));\n    }\n}\n\nbool PackMachFat::canPack()\n{\n    struct Mach_fat_arch const *const arch = &fat_head.arch[0];\n\n    fi->readx(&fat_head, sizeof(fat_head));\n    unsigned const nfat = check_fat_head();\n    if (0==nfat)\n        return false;\n    for (unsigned j=0; j < nfat; ++j) {\n        fi->set_extent(arch[j].offset, arch[j].size);\n        fi->seek(0, SEEK_SET);\n        switch (arch[j].cputype) {\n        default:\n            infoWarning(\"unknown cputype 0x%x: %s\",\n                (unsigned)arch[j].cputype, fi->getName());\n            return false;\n        case PackMachFat::CPU_TYPE_I386: {\n            PackMachI386 packer(fi);\n            if (!packer.canPack()) {\n                PackDylibI386 pack2r(fi);\n                if (!pack2r.canPack())\n                    return false;\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_X86_64: {\n            PackMachAMD64 packer(fi);\n            if (!packer.canPack()) {\n                PackDylibI386 pack2r(fi);\n                if (!pack2r.canPack())\n                    return false;\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_ARM64: {\n            PackMachARM64EL packer(fi);\n            if (!packer.canPack()) {\n                //PackDylibARM64EL pack2r(fi);  FIXME: not yet\n                //if (!pack2r.canPack())\n                    return false;\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC: {\n            PackMachPPC32 packer(fi);\n            if (!packer.canPack()) {\n                PackDylibPPC32 pack2r(fi);\n                if (!pack2r.canPack())\n                    return false;\n            }\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC64LE: {\n            PackMachPPC64LE packer(fi);\n            if (!packer.canPack()) {\n                PackDylibPPC64LE pack2r(fi);\n                if (!pack2r.canPack())\n                    return false;\n            }\n        } break;\n        }  // switch cputype\n    }\n\n    // info: currently the header is 36 (32+4) bytes before EOF\n    unsigned char buf[256];\n    fi->seek(-(off_t)sizeof(buf), SEEK_END);\n    fi->readx(buf, sizeof(buf));\n    checkAlreadyPacked(buf, sizeof(buf));\n\n    return true;\n}\n\nint PackMachFat::canUnpack()\n{\n    struct Mach_fat_arch const *const arch = &fat_head.arch[0];\n\n    fi->readx(&fat_head, sizeof(fat_head));\n    unsigned const nfat = check_fat_head();\n    if (0 == nfat) {\n        return false;\n    }\n    for (unsigned j=0; j < nfat; ++j) {\n        fi->set_extent(arch[j].offset, arch[j].size);\n        fi->seek(0, SEEK_SET);\n        switch (arch[j].cputype) {\n        default: return false;\n        case PackMachFat::CPU_TYPE_I386: {\n            PackMachI386 packer(fi);\n            if (!packer.canUnpack()) {\n                PackDylibI386 pack2r(fi);\n                if (!pack2r.canUnpack())\n                    return 0;\n                else\n                    ph.format = pack2r.getFormat(); // FIXME: copy entire PackHeader\n            }\n            else\n                ph.format = packer.getFormat(); // FIXME: copy entire PackHeader\n        } break;\n        case PackMachFat::CPU_TYPE_X86_64: {\n            PackMachAMD64 packer(fi);\n            if (!packer.canUnpack()) {\n                PackDylibAMD64 pack2r(fi);\n                if (!pack2r.canUnpack())\n                    return 0;\n                else\n                    ph.format = pack2r.getFormat(); // FIXME: copy entire PackHeader\n            }\n            else\n                ph.format = packer.getFormat(); // FIXME: copy entire PackHeader\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC: {\n            PackMachPPC32 packer(fi);\n            if (!packer.canUnpack()) {\n                PackDylibPPC32 pack2r(fi);\n                if (!pack2r.canUnpack())\n                    return 0;\n                else\n                    ph.format = pack2r.getFormat(); // FIXME: copy entire PackHeader\n            }\n            else\n                ph.format = packer.getFormat(); // FIXME: copy entire PackHeader\n        } break;\n        case PackMachFat::CPU_TYPE_POWERPC64LE: {\n            PackMachPPC64LE packer(fi);\n            if (!packer.canUnpack()) {\n                PackDylibPPC64LE pack2r(fi);\n                if (!pack2r.canUnpack())\n                    return 0;\n                else\n                    ph.format = pack2r.getFormat(); // FIXME: copy entire PackHeader\n            }\n            else\n                ph.format = packer.getFormat(); // FIXME: copy entire PackHeader\n        } break;\n        }  // switch cputype\n    }\n    return 1;\n}\n\nvoid PackMachFat::buildLoader(const Filter * /*ft*/)\n{\n    assert(false);\n}\n\nLinker* PackMachFat::newLinker() const\n{\n    return new ElfLinkerX86;  // sham\n}\n\nvoid PackMachFat::list()\n{\n    assert(false);\n}\n\n/* vim:set ts=4 sw=4 et: */\n"], "filenames": ["src/p_mach.cpp"], "buggy_code_start_loc": [1553], "buggy_code_end_loc": [1553], "fixing_code_start_loc": [1554], "fixing_code_end_loc": [1557], "type": "CWE-617", "message": "An assertion abort was found in upx MemBuffer::alloc() in mem.cpp, in version UPX 4.0.0. The flow allows attackers to cause a denial of service (abort) via a crafted file.", "other": {"cve": {"id": "CVE-2021-30501", "sourceIdentifier": "secalert@redhat.com", "published": "2021-05-27T00:15:08.527", "lastModified": "2022-10-25T19:23:28.550", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An assertion abort was found in upx MemBuffer::alloc() in mem.cpp, in version UPX 4.0.0. The flow allows attackers to cause a denial of service (abort) via a crafted file."}, {"lang": "es", "value": "Se encontr\u00f3 un aborto de aserci\u00f3n en upx, en la funci\u00f3n  MemBuffer::alloc() en el archivo mem.cpp, en UPX versi\u00f3n 4.0.0.&#xa0;El flujo permite a atacantes causar una denegaci\u00f3n de servicio (abortar) por medio de un archivo dise\u00f1ado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:upx_project:upx:4.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "D3527302-7874-4400-B123-99C1CA6FE8EB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1948696", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/upx/upx/commit/28e761cd42211dfe0124b7a29b2f74730f453e46", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/upx/upx/issues/486", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/upx/upx/pull/487", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/upx/upx/commit/28e761cd42211dfe0124b7a29b2f74730f453e46"}}