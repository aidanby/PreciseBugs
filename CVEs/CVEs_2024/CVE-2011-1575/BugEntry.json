{"buggy_code": ["#include <config.h>\n\n#include \"ftpd.h\"\n#include \"dynamic.h\"\n#include \"ftpwho-update.h\"\n#include \"globals.h\"\n#include \"messages.h\"\n#ifdef WITH_DIRALIASES\n# include \"diraliases.h\"\n#endif\n#ifdef WITH_TLS\n# include \"tls.h\"\n#endif\n\n#ifdef WITH_DMALLOC\n# include <dmalloc.h>\n#endif\n\nstatic void antiidle(void)\n{\n    if (noopidle == (time_t) -1) {\n        noopidle = time(NULL);\n    } else {\n        if ((time(NULL) - noopidle) > (time_t) idletime_noop) {\n            die(421, LOG_INFO, MSG_TIMEOUT_NOOP, (unsigned long) idletime_noop);\n        }\n    }    \n}\n\n/* \n * Introduce a random delay, to avoid guessing existing user names by\n * mesuring delay. It's especially true when LDAP is used.\n * No need to call usleep2() because we are root at this point.\n */\n\nstatic void randomdelay(void)\n{\n    usleep(rand() % 15000UL);          /* dummy... no need for arc4 */\n}\n\n/* \n * Simple but fast command-line reader. We break the FTP protocol here,\n * because we deny access to files with strange characters in their name.\n * Now, I seriously doubt that clients should be allowed to upload files\n * with carriage returns, bells, cursor moves and other fancy stuff in the\n * names. It can indirectly lead to security flaws with scripts, it's\n * annoying for the sysadmin, it can be a client error, it can bring unexpected\n * results on some filesystems, etc. So control chars are replaced by \"_\".\n * Better be safe than 100% RFC crap compliant but unsafe. If you really want\n * RFC compliance, define RFC_CONFORMANT_PARSER. But I will hate you.\n * \n * RFC_CONFORMANT_LINES is another thing that clients should implement\n * properly (and it's trivial to do) : lines must be ended with \\r\\n .\n * Guess what ? \n * Some broken clients are just sending \\n ... Grrrrrrrrrrrr !!!!!!!!!!!!!!!\n * \n * -Frank.\n */\n\nint sfgets(void)\n{\n    struct pollfd pfd;\n    int pollret;\n    ssize_t readnb;\n    signed char seen_r = 0;\n    static size_t scanned;\n    static size_t readnbd;\n    \n    if (scanned > (size_t) 0U) {       /* support pipelining */\n        readnbd -= scanned;        \n        memmove(cmd, cmd + scanned, readnbd);   /* safe */\n        scanned = (size_t) 0U;\n    }\n    pfd.fd = clientfd;\n#ifdef __APPLE_CC__\n    pfd.events = POLLIN | POLLERR | POLLHUP;\n#else\n    pfd.events = POLLIN | POLLPRI | POLLERR | POLLHUP;\n#endif\n    while (scanned < cmdsize) {\n        if (scanned >= readnbd) {      /* nothing left in the buffer */\n            pfd.revents = 0;\n            while ((pollret = poll(&pfd, 1U, idletime * 1000UL)) < 0 &&\n                   errno == EINTR);\n            if (pollret == 0) {\n                return -1;\n            }\n            if (pollret <= 0 ||\n                (pfd.revents & (POLLERR | POLLHUP | POLLNVAL)) != 0) {\n                return -2;\n            }\n            if ((pfd.revents & (POLLIN | POLLPRI)) == 0) {\n                continue;\n            }\n            if (readnbd >= cmdsize) {\n                break;\n            }\n#ifdef WITH_TLS\n            if (tls_cnx != NULL) {\n                while ((readnb = SSL_read\n                        (tls_cnx, cmd + readnbd, cmdsize - readnbd))\n                       < (ssize_t) 0 && errno == EINTR);\n            } else\n#endif\n            {\n                while ((readnb = read(clientfd, cmd + readnbd,\n                                      cmdsize - readnbd)) < (ssize_t) 0 &&\n                       errno == EINTR);\n            }\n            if (readnb <= (ssize_t) 0) {\n                return -2;\n            }\n            readnbd += readnb;\n            if (readnbd > cmdsize) {\n                return -2;\n            }\n        }\n#ifdef RFC_CONFORMANT_LINES\n        if (seen_r != 0) {\n#endif\n            if (cmd[scanned] == '\\n') {\n#ifndef RFC_CONFORMANT_LINES\n                if (seen_r != 0) {\n#endif\n                    cmd[scanned - 1U] = 0;\n#ifndef RFC_CONFORMANT_LINES\n                } else {\n                    cmd[scanned] = 0;\n                }\n#endif\n                if (++scanned >= readnbd) {   /* non-pipelined command */\n                    scanned = readnbd = (size_t) 0U;\n                }\n                return 0;\n            }\n            seen_r = 0;\n#ifdef RFC_CONFORMANT_LINES\n        }\n#endif\n        if (ISCTRLCODE(cmd[scanned])) {\n            if (cmd[scanned] == '\\r') {\n                seen_r = 1;\n            }\n#ifdef RFC_CONFORMANT_PARSER                   /* disabled by default, intentionnaly */\n            else if (cmd[scanned] == 0) {\n                cmd[scanned] = '\\n';\n            }\n#else\n            /* replace control chars with _ */\n            cmd[scanned] = '_';                \n#endif\n        }\n        scanned++;\n    }\n    die(421, LOG_WARNING, MSG_LINE_TOO_LONG);   /* don't remove this */\n    \n    return 0;                         /* to please GCC */\n}\n\n/* Replace extra spaces before and after a string with '_' */\n\n#ifdef MINIMAL\n# define revealextraspc(X) (X)\n#else\nstatic char *revealextraspc(char * const s_)\n{\n    unsigned char *s = (unsigned char *) s_;\n    unsigned char *sn;\n    \n    if (s == NULL) {\n        return s_;\n    }\n    simplify(s_);\n    while (*s != 0U && isspace(*s)) {\n        *s++ = '_';\n    }\n    if (*s == 0U) {\n        return s_;\n    }\n    sn = s;\n    do {\n        sn++;\n    } while (*sn != 0U);\n    do {\n        sn--;        \n        if (!isspace(*sn)) {\n            break;\n        }\n        *sn = '_';\n    } while (sn != s);\n    \n    return s_;\n}\n#endif\n\n#ifdef WITH_RFC2640\nchar *charset_client2fs(const char * const string)\n{\n    char *output = NULL, *output_;\n    size_t inlen, outlen, outlen_;\n    \n    inlen = strlen(string);\n    outlen_ = outlen = inlen * (size_t) 4U + (size_t) 1U;\n    if (outlen <= inlen ||\n        (output_ = output = calloc(outlen, (size_t) 1U)) == NULL) {\n        die_mem();\n    }\n    if (utf8 > 0 && strcasecmp(charset_fs, \"utf-8\") != 0) {\n        if (iconv(iconv_fd_utf82fs, (char **) &string,\n                  &inlen, &output_, &outlen_) == (size_t) -1) {\n            strncpy(output, string, outlen);\n        }\n    } else if (utf8 <= 0 && strcasecmp(charset_fs, charset_client) != 0) {\n        if (iconv(iconv_fd_client2fs, (char **) &string,\n                  &inlen, &output_, &outlen_) == (size_t) -1) {\n            strncpy(output, string, outlen);\n        }\n    } else {\n        strncpy(output, string, outlen);\n    }\n    output[outlen - 1] = 0;    \n    \n    return output;\n}\n#endif\n\nvoid parser(void)\n{\n    char *arg;\n#ifndef MINIMAL\n    char *sitearg;\n#endif\n#ifdef WITH_RFC2640\n    char *narg = NULL;\n#endif\n    size_t n;\n\n#ifdef IMPLICIT_TLS\n    (void) tls_init_new_session();\n    data_protection_level = CPL_PRIVATE;\n#endif\n    for (;;) {\n        xferfd = -1;\n        if (state_needs_update != 0) {\n            state_needs_update = 0;\n            setprocessname(\"pure-ftpd (IDLE)\");\n#ifdef FTPWHO\n            if (shm_data_cur != NULL) {\n                ftpwho_lock();\n                shm_data_cur->state = FTPWHO_STATE_IDLE;\n                *shm_data_cur->filename = 0;\n                ftpwho_unlock();\n            }\n#endif\n        }\n        doreply();\n        alarm(idletime * 2);\n        switch (sfgets()) {\n        case -1:\n#ifdef BORING_MODE\n            die(421, LOG_INFO, MSG_TIMEOUT);\n#else\n            die(421, LOG_INFO, MSG_TIMEOUT_PARSER);\n#endif\n        case -2:\n            return;\n        }\n#ifdef DEBUG\n        if (debug != 0) {\n            addreply(0, \"%s\", cmd);\n        }\n#endif\n        n = (size_t) 0U;\n        while ((isalpha((unsigned char) cmd[n]) || cmd[n] == '@') &&\n               n < cmdsize) {\n            cmd[n] = (char) tolower((unsigned char) cmd[n]);\n            n++;\n        }\n        if (n >= cmdsize) {            /* overparanoid, it should never happen */\n            die(421, LOG_WARNING, MSG_LINE_TOO_LONG);\n        }\n        if (n == (size_t) 0U) {\n            nop:\n            addreply_noformat(500, \"?\");\n            continue;\n        }\n#ifdef SKIP_COMMAND_TRAILING_SPACES        \n        while (isspace((unsigned char) cmd[n]) && n < cmdsize) {\n            cmd[n++] = 0;\n        }\n        arg = cmd + n;        \n        while (cmd[n] != 0 && n < cmdsize) {\n            n++;\n        }\n        n--;\n        while (isspace((unsigned char) cmd[n])) {\n            cmd[n--] = 0;\n        }\n#else\n        if (cmd[n] == 0) {\n            arg = cmd + n;\n        } else if (isspace((unsigned char) cmd[n])) {\n            cmd[n] = 0;\n            arg = cmd + n + 1;\n        } else {\n            goto nop;\n        }\n#endif\n        if (logging != 0) {\n#ifdef DEBUG\n            logfile(LOG_DEBUG, MSG_DEBUG_COMMAND \" [%s] [%s]\",\n                   cmd, arg);\n#else\n            logfile(LOG_DEBUG, MSG_DEBUG_COMMAND \" [%s] [%s]\",\n                   cmd, strcmp(cmd, \"pass\") ? arg : \"<*>\");\n#endif\n        }\n#ifdef WITH_RFC2640\n        narg = charset_client2fs(arg);\n\targ = narg;\n#endif\n        /*\n         * antiidle() is called with dummy commands, usually used by clients\n         * who are wanting extra idle time. We give them some, but not too much.\n         * When we jump to wayout, the idle timer is not zeroed. It means that\n         * we didn't issue an 'active' command like RETR.\n         */\n        \n#ifndef MINIMAL\n        if (!strcmp(cmd, \"noop\")) {\n            antiidle();\n            donoop();\n            goto wayout;\n        }\n#endif\n        if (!strcmp(cmd, \"user\")) {\n#ifdef WITH_TLS\n            if (enforce_tls_auth > 1 && tls_cnx == NULL) {\n                die(421, LOG_WARNING, MSG_TLS_NEEDED);\n            }\n#endif\n            douser(arg);\n        } else if (!strcmp(cmd, \"acct\")) {\n            addreply(202, MSG_WHOAREYOU);\n        } else if (!strcmp(cmd, \"pass\")) {\n            if (guest == 0) {\n                randomdelay();\n            }\n            dopass(arg);\n        } else if (!strcmp(cmd, \"quit\")) {\n            addreply(221, MSG_GOODBYE,\n                     (unsigned long long) ((uploaded + 1023ULL) / 1024ULL),\n                     (unsigned long long) ((downloaded + 1023ULL) / 1024ULL));\n            return;\n        } else if (!strcmp(cmd, \"syst\")) {\n            antiidle();\n            addreply_noformat(215, \"UNIX Type: L8\");\n            goto wayout;\n#ifdef WITH_TLS\n        } else if (enforce_tls_auth > 0 &&\n                   !strcmp(cmd, \"auth\") && !strcasecmp(arg, \"tls\")) {\n            addreply_noformat(234, \"AUTH TLS OK.\");\n            doreply();\n            if (tls_cnx == NULL) {\n                (void) tls_init_new_session();\n            }\n            goto wayout;\n        } else if (!strcmp(cmd, \"pbsz\")) {\n            addreply_noformat(tls_cnx == NULL ? 503 : 200, \"PBSZ=0\");\n        } else if (!strcmp(cmd, \"prot\")) {\n            if (tls_cnx == NULL) {\n                addreply_noformat(503, MSG_PROT_BEFORE_PBSZ);\n                goto wayout;\n            }\n            switch (*arg) {\n            case 0:\n                addreply_noformat(503, MSG_MISSING_ARG);\n                data_protection_level = CPL_NONE;\n                break;\n            case 'C':\n                if (arg[1] == 0) {\n                    addreply(200, MSG_PROT_OK, \"clear\");\n                    data_protection_level = CPL_CLEAR;\n                    break;\n                }\n            case 'S':\n            case 'E':\n                if (arg[1] == 0) {\n                    addreply(200, MSG_PROT_UNKNOWN_LEVEL, arg, \"private\");\n                    data_protection_level = CPL_PRIVATE;\n                    break;\n                }\n            case 'P':\n                if (arg[1] == 0) {\n                    addreply(200, MSG_PROT_OK, \"private\");\n                    data_protection_level = CPL_PRIVATE;\n                    break;\n                }\n            default:\n                addreply_noformat(534, \"Fallback to [C]\");\n                data_protection_level = CPL_CLEAR;\n                break;\n            }\n#endif\n        } else if (!strcmp(cmd, \"auth\") || !strcmp(cmd, \"adat\")) {\n            addreply_noformat(500, MSG_AUTH_UNIMPLEMENTED);\n        } else if (!strcmp(cmd, \"type\")) {\n            antiidle();\n            dotype(arg);\n            goto wayout;\n        } else if (!strcmp(cmd, \"mode\")) {\n            antiidle();                \n            domode(arg);\n            goto wayout;\n#ifndef MINIMAL\n        } else if (!strcmp(cmd, \"feat\")) {\n            dofeat();\n            goto wayout;\n\t} else if (!strcmp(cmd, \"opts\")) {\n\t    doopts(arg);\n\t    goto wayout;\n#endif\n        } else if (!strcmp(cmd, \"stru\")) {\n            dostru(arg);\n            goto wayout;\n#ifndef MINIMAL\n        } else if (!strcmp(cmd, \"help\")) {\n            goto help_site;\n#endif\n#ifdef DEBUG\n        } else if (!strcmp(cmd, \"xdbg\")) {\n            debug++;\n            addreply(200, MSG_XDBG_OK, debug);\n            goto wayout;\n#endif            \n        } else if (loggedin == 0) {            \n            /* from this point, all commands need authentication */\n            addreply_noformat(530, MSG_NOT_LOGGED_IN);\n            goto wayout;\n        } else {\n            if (!strcmp(cmd, \"cwd\") || !strcmp(cmd, \"xcwd\")) {\n                antiidle();\n                docwd(arg);\n                goto wayout;\n            } else if (!strcmp(cmd, \"port\")) {\n                doport(arg);\n#ifndef MINIMAL\n            } else if (!strcmp(cmd, \"eprt\")) {\n                doeprt(arg);\n            } else if (!strcmp(cmd, \"esta\") &&\n                       disallow_passive == 0 &&\n                       STORAGE_FAMILY(force_passive_ip) == 0) {\n                doesta();\n            } else if (!strcmp(cmd, \"estp\")) {\n                doestp();\n#endif\n            } else if (disallow_passive == 0 && \n                       (!strcmp(cmd, \"pasv\") || !strcmp(cmd, \"p@sw\"))) {\n                dopasv(0);\n            } else if (disallow_passive == 0 && \n                       (!strcmp(cmd, \"epsv\") && \n                       (broken_client_compat == 0 ||\n                        STORAGE_FAMILY(ctrlconn) == AF_INET6))) {\n                if (!strcasecmp(arg, \"all\")) {\n                    epsv_all = 1;\n                    addreply_noformat(220, MSG_ACTIVE_DISABLED);\n                } else if (!strcmp(arg, \"2\") && !v6ready) {\n                    addreply_noformat(522, MSG_ONLY_IPV4);\n                } else {\n                    dopasv(1);\n                }\n#ifndef MINIMAL            \n            } else if (disallow_passive == 0 && !strcmp(cmd, \"spsv\")) {\n                dopasv(2);\n            } else if (!strcmp(cmd, \"allo\")) {\n                if (*arg == 0) {\n                    addreply_noformat(501, MSG_STAT_FAILURE);\n                } else {\n                    const off_t size = (off_t) strtoull(arg, NULL, 10);\n                    \n                    if (size < (off_t) 0) {\n                        addreply_noformat(501, MSG_STAT_FAILURE);                        \n                    } else {\n                        doallo(size);\n                    }\n                }\n#endif\n            } else if (!strcmp(cmd, \"pwd\") || !strcmp(cmd, \"xpwd\")) {\n#ifdef WITH_RFC2640\n\t\tchar *nwd;\n#endif\n                antiidle();\n#ifdef WITH_RFC2640\n\t\tnwd = charset_fs2client(wd);\n\t\taddreply(257, \"\\\"%s\\\" \" MSG_IS_YOUR_CURRENT_LOCATION, nwd);\n\t\tfree(nwd);\n#else\n                addreply(257, \"\\\"%s\\\" \" MSG_IS_YOUR_CURRENT_LOCATION, wd);\n#endif\n                goto wayout;                \n            } else if (!strcmp(cmd, \"cdup\") || !strcmp(cmd, \"xcup\")) {\n                docwd(\"..\");\n            } else if (!strcmp(cmd, \"retr\")) {\n                if (*arg != 0) {\n#ifdef WITH_TLS\n                    if (enforce_tls_auth == 3 &&\n                        data_protection_level != CPL_PRIVATE) {\n                        addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);\n                    }\n                    else\n#endif\n                    {\n                        doretr(arg);\n                    }\n                } else {\n                    addreply_noformat(501, MSG_NO_FILE_NAME);\n                }\n            } else if (!strcmp(cmd, \"rest\")) {\n                antiidle();\n                if (*arg != 0) {\n                    dorest(arg);\n                } else {\n                    addreply_noformat(501, MSG_NO_RESTART_POINT);\n                    restartat = (off_t) 0;\n                }\n                goto wayout;\n            } else if (!strcmp(cmd, \"dele\")) {\n                if (*arg != 0) {\n                    dodele(arg);\n                } else {\n                    addreply_noformat(501, MSG_NO_FILE_NAME);\n                }\n            } else if (!strcmp(cmd, \"stor\")) {\n                arg = revealextraspc(arg);\n                if (*arg != 0) {\n#ifdef WITH_TLS\n                    if (enforce_tls_auth == 3 &&\n                        data_protection_level != CPL_PRIVATE) {\n                        addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);\n                    } else \n#endif\n                    {\n                        dostor(arg, 0, autorename);\n                    }\n                } else {\n                    addreply_noformat(501, MSG_NO_FILE_NAME);\n                }\n            } else if (!strcmp(cmd, \"appe\")) {\n                arg = revealextraspc(arg);\n                if (*arg != 0) {\n#ifdef WITH_TLS\n                    if (enforce_tls_auth == 3 &&\n                        data_protection_level != CPL_PRIVATE) {\n                        addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);\n                    } else \n#endif\n                    {\n                        dostor(arg, 1, 0);\n                    }\n                } else {\n                    addreply_noformat(501, MSG_NO_FILE_NAME);\n                }\n#ifndef MINIMAL\n            } else if (!strcmp(cmd, \"stou\")) {\n#ifdef WITH_TLS\n                if (enforce_tls_auth == 3 &&\n                    data_protection_level != CPL_PRIVATE) {\n                    addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);\n                } else \n#endif\n                {\n            \t     dostou();\n                }\n#endif\n#ifndef DISABLE_MKD_RMD\n            } else if (!strcmp(cmd, \"mkd\") || !strcmp(cmd, \"xmkd\")) {\n                arg = revealextraspc(arg);\n                if (*arg != 0) {\n                    domkd(arg);\n                } else {\n                    addreply_noformat(501, MSG_NO_DIRECTORY_NAME);\n                }\n            } else if (!strcmp(cmd, \"rmd\") || !strcmp(cmd, \"xrmd\")) {\n                if (*arg != 0) {\n                    dormd(arg);\n                } else {\n                    addreply_noformat(550, MSG_NO_DIRECTORY_NAME);\n                }\n#endif\n#ifndef MINIMAL\n            } else if (!strcmp(cmd, \"stat\")) {\n                if (*arg != 0) {\n                    modern_listings = 0;\n                    donlist(arg, 1, 1, 1, 1);\n                } else {\n                    addreply_noformat(211, \"http://www.pureftpd.org/\");\n                }\n#endif\n            } else if (!strcmp(cmd, \"list\")) {\n#ifndef MINIMAL\n                modern_listings = 0;\n#endif\n#ifdef WITH_TLS\n                if (enforce_tls_auth == 3 &&\n                    data_protection_level != CPL_PRIVATE) {\n                    addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);\n                } else\n#endif\n                {\n                    donlist(arg, 0, 1, 0, 1);\n                }\n            } else if (!strcmp(cmd, \"nlst\")) {\n#ifndef MINIMAL                \n                modern_listings = 0;\n#endif\n#ifdef WITH_TLS\n                if (enforce_tls_auth == 3 &&\n                    data_protection_level != CPL_PRIVATE) {\n                    addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);\n                } else\n#endif\n                {\n                    donlist(arg, 0, 0, 0, broken_client_compat);\n                }\n#ifndef MINIMAL\n            } else if (!strcmp(cmd, \"mlst\")) {\n#ifdef WITH_TLS\n                if (enforce_tls_auth == 3 &&\n                    data_protection_level != CPL_PRIVATE) {\n                    addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);\n                } else\n#endif\n                {\n                    domlst(*arg != 0 ? arg : \".\");\n                }\n            } else if (!strcmp(cmd, \"mlsd\")) {\n                modern_listings = 1;\n#ifdef WITH_TLS\n                if (enforce_tls_auth == 3 &&\n                    data_protection_level != CPL_PRIVATE) {\n                    addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);\n                } else\n#endif\n                {\n                    donlist(arg, 0, 1, 1, 0);\n                }\n#endif\n            } else if (!strcmp(cmd, \"abor\")) {\n                addreply_noformat(226, MSG_ABOR_SUCCESS);\n#ifndef MINIMAL\n            } else if (!strcmp(cmd, \"site\")) {\n                if ((sitearg = arg) != NULL) {\n                    while (*sitearg != 0 && !isspace((unsigned char) *sitearg)) {\n                        sitearg++;\n                    }\n                    if (*sitearg != 0) {\n                        *sitearg++ = 0;\n                    }\n                }\n                if (!strcasecmp(arg, \"idle\")) {\n                    if (sitearg == NULL || *sitearg == 0) {\n                        addreply_noformat(501, \"SITE IDLE: \" MSG_MISSING_ARG);\n                    } else {\n                        unsigned long int i = 0;\n\n                        i = strtoul(sitearg, &sitearg, 10);\n                        if (sitearg && *sitearg)\n                            addreply(501, MSG_GARBAGE_FOUND \" : %s\", sitearg);\n                        else if (i > MAX_SITE_IDLE)\n                            addreply_noformat(501, MSG_VALUE_TOO_LARGE);\n                        else {\n                            idletime = i;\n                            addreply(200, MSG_IDLE_TIME, idletime);\n                            idletime_noop = (double) idletime * 2.0;\n                        }\n                    }\n                } else if (!strcasecmp(arg, \"time\")) {\n                    dositetime();\n                } else if (!strcasecmp(arg, \"help\")) {\n                    help_site:\n                    \n                    addreply_noformat(214, MSG_SITE_HELP CRLF\n# ifdef WITH_DIRALIASES\n                                      \" ALIAS\" CRLF\n# endif\n                                      \" CHMOD\" CRLF \" IDLE\" CRLF \" UTIME\");\n                    addreply_noformat(214, \"Pure-FTPd - http://pureftpd.org/\");\n                } else if (!strcasecmp(arg, \"chmod\")) {\n                    char *sitearg2;\n                    mode_t mode;\n                    \n                    parsechmod:\n                    if (sitearg == NULL || *sitearg == 0) {\n                        addreply_noformat(501, MSG_MISSING_ARG);\n                        goto chmod_wayout;\n                    }\n                    sitearg2 = sitearg;\n                    while (*sitearg2 != 0 && !isspace((unsigned char) *sitearg2)) {\n                        sitearg2++;\n                    }                    \n                    while (*sitearg2 != 0 && isspace((unsigned char) *sitearg2)) {\n                        sitearg2++;\n                    }                    \n                    if (*sitearg2 == 0) {\n                        addreply_noformat(550, MSG_NO_FILE_NAME);\n                        goto chmod_wayout;\n                    }\n                    mode = (mode_t) strtoul(sitearg, NULL, 8);\n                    if (mode > (mode_t) 07777) {\n                        addreply_noformat(501, MSG_BAD_CHMOD);\n                        goto chmod_wayout;\n                    }\n                    dochmod(sitearg2, mode);\n                    chmod_wayout:\n                    (void) 0;\n                } else if (!strcasecmp(arg, \"utime\")) {\n                    char *sitearg2;\n                    \n                    if (sitearg == NULL || *sitearg == 0) {\n                        addreply_noformat(501, MSG_NO_FILE_NAME);\n                        goto utime_wayout;\n                    }\t\t    \n                    if ((sitearg2 = strrchr(sitearg, ' ')) == NULL ||\n                        sitearg2 == sitearg) {\n                        addreply_noformat(501, MSG_MISSING_ARG);\n                        goto utime_wayout;\n                    }\n                    if (strcasecmp(sitearg2, \" UTC\") != 0) {\n                        addreply_noformat(500, \"UTC Only\");\n                        goto utime_wayout;\t\t\t\n                    }\n                    *sitearg2-- = 0;\n                    if ((sitearg2 = strrchr(sitearg, ' ')) == NULL ||\n                        sitearg2 == sitearg) {\n                        utime_no_arg:\n                        addreply_noformat(501, MSG_MISSING_ARG);\n                        goto utime_wayout;\n                    }\n                    *sitearg2-- = 0;\n                    if ((sitearg2 = strrchr(sitearg, ' ')) == NULL ||\n                        sitearg2 == sitearg) {\n                        goto utime_no_arg;\n                    }\n                    *sitearg2-- = 0;\n                    if ((sitearg2 = strrchr(sitearg, ' ')) == NULL ||\n                        sitearg2 == sitearg) {\n                        goto utime_no_arg;\n                    }\n                    *sitearg2++ = 0;\n                    if (*sitearg2 == 0) {\n                        goto utime_no_arg;\t\t\t\n                    }\n                    doutime(sitearg, sitearg2);\n                    utime_wayout:\n                    (void) 0;\n# ifdef WITH_DIRALIASES\t\t    \n                } else if (!strcasecmp(arg, \"alias\")) {\n                    if (sitearg == NULL || *sitearg == 0) {\n                        print_aliases();\n                    } else {\n                        const char *alias;\n                        \n                        if ((alias = lookup_alias(sitearg)) != NULL) {\n                            addreply(214, MSG_ALIASES_ALIAS, sitearg, alias);\n                        } else {\n                            addreply(502, MSG_ALIASES_UNKNOWN, sitearg);\n                        }\n                    }\n# endif\n                } else if (*arg != 0) {\n                    addreply(500, \"SITE %s \" MSG_UNKNOWN_EXTENSION, arg);\n                } else {\n                    addreply_noformat(500, \"SITE: \" MSG_MISSING_ARG);\n                }\n#endif\n            } else if (!strcmp(cmd, \"mdtm\")) {\n                domdtm(arg);\n            } else if (!strcmp(cmd, \"size\")) {\n                dosize(arg);\n#ifndef MINIMAL\n            } else if (!strcmp(cmd, \"chmod\")) {\n                sitearg = arg;\n                goto parsechmod;\n#endif\n            } else if (!strcmp(cmd, \"rnfr\")) {\n                if (*arg != 0) {\n                    dornfr(arg);\n                } else {\n                    addreply_noformat(550, MSG_NO_FILE_NAME);\n                }\n            } else if (!strcmp(cmd, \"rnto\")) {\n                arg = revealextraspc(arg);\n                if (*arg != 0) {\n                    dornto(arg);\n                } else {\n                    addreply_noformat(550, MSG_NO_FILE_NAME);\n                }\n            } else {\n                addreply_noformat(500, MSG_UNKNOWN_COMMAND);\n            }\n        }\n        noopidle = (time_t) -1;\n        wayout:\n#ifdef WITH_RFC2640\n        free(narg);\n        narg = NULL;\n#endif\n#ifdef THROTTLING\n        if (throttling_delay != 0UL) {\n            usleep2(throttling_delay);\n        }\n#else\n        (void) 0;\n#endif\n    }\n}\n"], "fixing_code": ["#include <config.h>\n\n#include \"ftpd.h\"\n#include \"dynamic.h\"\n#include \"ftpwho-update.h\"\n#include \"globals.h\"\n#include \"messages.h\"\n#ifdef WITH_DIRALIASES\n# include \"diraliases.h\"\n#endif\n#ifdef WITH_TLS\n# include \"tls.h\"\n#endif\n\n#ifdef WITH_DMALLOC\n# include <dmalloc.h>\n#endif\n\nstatic void antiidle(void)\n{\n    if (noopidle == (time_t) -1) {\n        noopidle = time(NULL);\n    } else {\n        if ((time(NULL) - noopidle) > (time_t) idletime_noop) {\n            die(421, LOG_INFO, MSG_TIMEOUT_NOOP, (unsigned long) idletime_noop);\n        }\n    }    \n}\n\n/* \n * Introduce a random delay, to avoid guessing existing user names by\n * mesuring delay. It's especially true when LDAP is used.\n * No need to call usleep2() because we are root at this point.\n */\n\nstatic void randomdelay(void)\n{\n    usleep(rand() % 15000UL);          /* dummy... no need for arc4 */\n}\n\n/* \n * Simple but fast command-line reader. We break the FTP protocol here,\n * because we deny access to files with strange characters in their name.\n * Now, I seriously doubt that clients should be allowed to upload files\n * with carriage returns, bells, cursor moves and other fancy stuff in the\n * names. It can indirectly lead to security flaws with scripts, it's\n * annoying for the sysadmin, it can be a client error, it can bring unexpected\n * results on some filesystems, etc. So control chars are replaced by \"_\".\n * Better be safe than 100% RFC crap compliant but unsafe. If you really want\n * RFC compliance, define RFC_CONFORMANT_PARSER. But I will hate you.\n * \n * RFC_CONFORMANT_LINES is another thing that clients should implement\n * properly (and it's trivial to do) : lines must be ended with \\r\\n .\n * Guess what ? \n * Some broken clients are just sending \\n ... Grrrrrrrrrrrr !!!!!!!!!!!!!!!\n * \n * -Frank.\n */\n\nstatic size_t scanned;\nstatic size_t readnbd;\n\nstatic void flush_cmd(void)\n{\n    scanned = readnbd = (size_t) 0U;\n}\n\nint sfgets(void)\n{\n    struct pollfd pfd;\n    int pollret;\n    ssize_t readnb;\n    signed char seen_r = 0;\n    \n    if (scanned > (size_t) 0U) {       /* support pipelining */\n        readnbd -= scanned;        \n        memmove(cmd, cmd + scanned, readnbd);   /* safe */\n        scanned = (size_t) 0U;\n    }\n    pfd.fd = clientfd;\n#ifdef __APPLE_CC__\n    pfd.events = POLLIN | POLLERR | POLLHUP;\n#else\n    pfd.events = POLLIN | POLLPRI | POLLERR | POLLHUP;\n#endif\n    while (scanned < cmdsize) {\n        if (scanned >= readnbd) {      /* nothing left in the buffer */\n            pfd.revents = 0;\n            while ((pollret = poll(&pfd, 1U, idletime * 1000UL)) < 0 &&\n                   errno == EINTR);\n            if (pollret == 0) {\n                return -1;\n            }\n            if (pollret <= 0 ||\n                (pfd.revents & (POLLERR | POLLHUP | POLLNVAL)) != 0) {\n                return -2;\n            }\n            if ((pfd.revents & (POLLIN | POLLPRI)) == 0) {\n                continue;\n            }\n            if (readnbd >= cmdsize) {\n                break;\n            }\n#ifdef WITH_TLS\n            if (tls_cnx != NULL) {\n                while ((readnb = SSL_read\n                        (tls_cnx, cmd + readnbd, cmdsize - readnbd))\n                       < (ssize_t) 0 && errno == EINTR);\n            } else\n#endif\n            {\n                while ((readnb = read(clientfd, cmd + readnbd,\n                                      cmdsize - readnbd)) < (ssize_t) 0 &&\n                       errno == EINTR);\n            }\n            if (readnb <= (ssize_t) 0) {\n                return -2;\n            }\n            readnbd += readnb;\n            if (readnbd > cmdsize) {\n                return -2;\n            }\n        }\n#ifdef RFC_CONFORMANT_LINES\n        if (seen_r != 0) {\n#endif\n            if (cmd[scanned] == '\\n') {\n#ifndef RFC_CONFORMANT_LINES\n                if (seen_r != 0) {\n#endif\n                    cmd[scanned - 1U] = 0;\n#ifndef RFC_CONFORMANT_LINES\n                } else {\n                    cmd[scanned] = 0;\n                }\n#endif\n                if (++scanned >= readnbd) {   /* non-pipelined command */\n                    scanned = readnbd = (size_t) 0U;\n                }\n                return 0;\n            }\n            seen_r = 0;\n#ifdef RFC_CONFORMANT_LINES\n        }\n#endif\n        if (ISCTRLCODE(cmd[scanned])) {\n            if (cmd[scanned] == '\\r') {\n                seen_r = 1;\n            }\n#ifdef RFC_CONFORMANT_PARSER                   /* disabled by default, intentionnaly */\n            else if (cmd[scanned] == 0) {\n                cmd[scanned] = '\\n';\n            }\n#else\n            /* replace control chars with _ */\n            cmd[scanned] = '_';                \n#endif\n        }\n        scanned++;\n    }\n    die(421, LOG_WARNING, MSG_LINE_TOO_LONG);   /* don't remove this */\n    \n    return 0;                         /* to please GCC */\n}\n\n/* Replace extra spaces before and after a string with '_' */\n\n#ifdef MINIMAL\n# define revealextraspc(X) (X)\n#else\nstatic char *revealextraspc(char * const s_)\n{\n    unsigned char *s = (unsigned char *) s_;\n    unsigned char *sn;\n    \n    if (s == NULL) {\n        return s_;\n    }\n    simplify(s_);\n    while (*s != 0U && isspace(*s)) {\n        *s++ = '_';\n    }\n    if (*s == 0U) {\n        return s_;\n    }\n    sn = s;\n    do {\n        sn++;\n    } while (*sn != 0U);\n    do {\n        sn--;        \n        if (!isspace(*sn)) {\n            break;\n        }\n        *sn = '_';\n    } while (sn != s);\n    \n    return s_;\n}\n#endif\n\n#ifdef WITH_RFC2640\nchar *charset_client2fs(const char * const string)\n{\n    char *output = NULL, *output_;\n    size_t inlen, outlen, outlen_;\n    \n    inlen = strlen(string);\n    outlen_ = outlen = inlen * (size_t) 4U + (size_t) 1U;\n    if (outlen <= inlen ||\n        (output_ = output = calloc(outlen, (size_t) 1U)) == NULL) {\n        die_mem();\n    }\n    if (utf8 > 0 && strcasecmp(charset_fs, \"utf-8\") != 0) {\n        if (iconv(iconv_fd_utf82fs, (char **) &string,\n                  &inlen, &output_, &outlen_) == (size_t) -1) {\n            strncpy(output, string, outlen);\n        }\n    } else if (utf8 <= 0 && strcasecmp(charset_fs, charset_client) != 0) {\n        if (iconv(iconv_fd_client2fs, (char **) &string,\n                  &inlen, &output_, &outlen_) == (size_t) -1) {\n            strncpy(output, string, outlen);\n        }\n    } else {\n        strncpy(output, string, outlen);\n    }\n    output[outlen - 1] = 0;    \n    \n    return output;\n}\n#endif\n\nvoid parser(void)\n{\n    char *arg;\n#ifndef MINIMAL\n    char *sitearg;\n#endif\n#ifdef WITH_RFC2640\n    char *narg = NULL;\n#endif\n    size_t n;\n\n#ifdef IMPLICIT_TLS\n    (void) tls_init_new_session();\n    data_protection_level = CPL_PRIVATE;\n#endif\n    for (;;) {\n        xferfd = -1;\n        if (state_needs_update != 0) {\n            state_needs_update = 0;\n            setprocessname(\"pure-ftpd (IDLE)\");\n#ifdef FTPWHO\n            if (shm_data_cur != NULL) {\n                ftpwho_lock();\n                shm_data_cur->state = FTPWHO_STATE_IDLE;\n                *shm_data_cur->filename = 0;\n                ftpwho_unlock();\n            }\n#endif\n        }\n        doreply();\n        alarm(idletime * 2);\n        switch (sfgets()) {\n        case -1:\n#ifdef BORING_MODE\n            die(421, LOG_INFO, MSG_TIMEOUT);\n#else\n            die(421, LOG_INFO, MSG_TIMEOUT_PARSER);\n#endif\n        case -2:\n            return;\n        }\n#ifdef DEBUG\n        if (debug != 0) {\n            addreply(0, \"%s\", cmd);\n        }\n#endif\n        n = (size_t) 0U;\n        while ((isalpha((unsigned char) cmd[n]) || cmd[n] == '@') &&\n               n < cmdsize) {\n            cmd[n] = (char) tolower((unsigned char) cmd[n]);\n            n++;\n        }\n        if (n >= cmdsize) {            /* overparanoid, it should never happen */\n            die(421, LOG_WARNING, MSG_LINE_TOO_LONG);\n        }\n        if (n == (size_t) 0U) {\n            nop:\n            addreply_noformat(500, \"?\");\n            continue;\n        }\n#ifdef SKIP_COMMAND_TRAILING_SPACES        \n        while (isspace((unsigned char) cmd[n]) && n < cmdsize) {\n            cmd[n++] = 0;\n        }\n        arg = cmd + n;        \n        while (cmd[n] != 0 && n < cmdsize) {\n            n++;\n        }\n        n--;\n        while (isspace((unsigned char) cmd[n])) {\n            cmd[n--] = 0;\n        }\n#else\n        if (cmd[n] == 0) {\n            arg = cmd + n;\n        } else if (isspace((unsigned char) cmd[n])) {\n            cmd[n] = 0;\n            arg = cmd + n + 1;\n        } else {\n            goto nop;\n        }\n#endif\n        if (logging != 0) {\n#ifdef DEBUG\n            logfile(LOG_DEBUG, MSG_DEBUG_COMMAND \" [%s] [%s]\",\n                   cmd, arg);\n#else\n            logfile(LOG_DEBUG, MSG_DEBUG_COMMAND \" [%s] [%s]\",\n                   cmd, strcmp(cmd, \"pass\") ? arg : \"<*>\");\n#endif\n        }\n#ifdef WITH_RFC2640\n        narg = charset_client2fs(arg);\n\targ = narg;\n#endif\n        /*\n         * antiidle() is called with dummy commands, usually used by clients\n         * who are wanting extra idle time. We give them some, but not too much.\n         * When we jump to wayout, the idle timer is not zeroed. It means that\n         * we didn't issue an 'active' command like RETR.\n         */\n        \n#ifndef MINIMAL\n        if (!strcmp(cmd, \"noop\")) {\n            antiidle();\n            donoop();\n            goto wayout;\n        }\n#endif\n        if (!strcmp(cmd, \"user\")) {\n#ifdef WITH_TLS\n            if (enforce_tls_auth > 1 && tls_cnx == NULL) {\n                die(421, LOG_WARNING, MSG_TLS_NEEDED);\n            }\n#endif\n            douser(arg);\n        } else if (!strcmp(cmd, \"acct\")) {\n            addreply(202, MSG_WHOAREYOU);\n        } else if (!strcmp(cmd, \"pass\")) {\n            if (guest == 0) {\n                randomdelay();\n            }\n            dopass(arg);\n        } else if (!strcmp(cmd, \"quit\")) {\n            addreply(221, MSG_GOODBYE,\n                     (unsigned long long) ((uploaded + 1023ULL) / 1024ULL),\n                     (unsigned long long) ((downloaded + 1023ULL) / 1024ULL));\n            return;\n        } else if (!strcmp(cmd, \"syst\")) {\n            antiidle();\n            addreply_noformat(215, \"UNIX Type: L8\");\n            goto wayout;\n#ifdef WITH_TLS\n        } else if (enforce_tls_auth > 0 &&\n                   !strcmp(cmd, \"auth\") && !strcasecmp(arg, \"tls\")) {\n            addreply_noformat(234, \"AUTH TLS OK.\");\n            doreply();\n            if (tls_cnx == NULL) {\n                flush_cmd();\n                (void) tls_init_new_session();\n            }\n            goto wayout;\n        } else if (!strcmp(cmd, \"pbsz\")) {\n            addreply_noformat(tls_cnx == NULL ? 503 : 200, \"PBSZ=0\");\n        } else if (!strcmp(cmd, \"prot\")) {\n            if (tls_cnx == NULL) {\n                addreply_noformat(503, MSG_PROT_BEFORE_PBSZ);\n                goto wayout;\n            }\n            switch (*arg) {\n            case 0:\n                addreply_noformat(503, MSG_MISSING_ARG);\n                data_protection_level = CPL_NONE;\n                break;\n            case 'C':\n                if (arg[1] == 0) {\n                    addreply(200, MSG_PROT_OK, \"clear\");\n                    data_protection_level = CPL_CLEAR;\n                    break;\n                }\n            case 'S':\n            case 'E':\n                if (arg[1] == 0) {\n                    addreply(200, MSG_PROT_UNKNOWN_LEVEL, arg, \"private\");\n                    data_protection_level = CPL_PRIVATE;\n                    break;\n                }\n            case 'P':\n                if (arg[1] == 0) {\n                    addreply(200, MSG_PROT_OK, \"private\");\n                    data_protection_level = CPL_PRIVATE;\n                    break;\n                }\n            default:\n                addreply_noformat(534, \"Fallback to [C]\");\n                data_protection_level = CPL_CLEAR;\n                break;\n            }\n#endif\n        } else if (!strcmp(cmd, \"auth\") || !strcmp(cmd, \"adat\")) {\n            addreply_noformat(500, MSG_AUTH_UNIMPLEMENTED);\n        } else if (!strcmp(cmd, \"type\")) {\n            antiidle();\n            dotype(arg);\n            goto wayout;\n        } else if (!strcmp(cmd, \"mode\")) {\n            antiidle();                \n            domode(arg);\n            goto wayout;\n#ifndef MINIMAL\n        } else if (!strcmp(cmd, \"feat\")) {\n            dofeat();\n            goto wayout;\n\t} else if (!strcmp(cmd, \"opts\")) {\n\t    doopts(arg);\n\t    goto wayout;\n#endif\n        } else if (!strcmp(cmd, \"stru\")) {\n            dostru(arg);\n            goto wayout;\n#ifndef MINIMAL\n        } else if (!strcmp(cmd, \"help\")) {\n            goto help_site;\n#endif\n#ifdef DEBUG\n        } else if (!strcmp(cmd, \"xdbg\")) {\n            debug++;\n            addreply(200, MSG_XDBG_OK, debug);\n            goto wayout;\n#endif            \n        } else if (loggedin == 0) {            \n            /* from this point, all commands need authentication */\n            addreply_noformat(530, MSG_NOT_LOGGED_IN);\n            goto wayout;\n        } else {\n            if (!strcmp(cmd, \"cwd\") || !strcmp(cmd, \"xcwd\")) {\n                antiidle();\n                docwd(arg);\n                goto wayout;\n            } else if (!strcmp(cmd, \"port\")) {\n                doport(arg);\n#ifndef MINIMAL\n            } else if (!strcmp(cmd, \"eprt\")) {\n                doeprt(arg);\n            } else if (!strcmp(cmd, \"esta\") &&\n                       disallow_passive == 0 &&\n                       STORAGE_FAMILY(force_passive_ip) == 0) {\n                doesta();\n            } else if (!strcmp(cmd, \"estp\")) {\n                doestp();\n#endif\n            } else if (disallow_passive == 0 && \n                       (!strcmp(cmd, \"pasv\") || !strcmp(cmd, \"p@sw\"))) {\n                dopasv(0);\n            } else if (disallow_passive == 0 && \n                       (!strcmp(cmd, \"epsv\") && \n                       (broken_client_compat == 0 ||\n                        STORAGE_FAMILY(ctrlconn) == AF_INET6))) {\n                if (!strcasecmp(arg, \"all\")) {\n                    epsv_all = 1;\n                    addreply_noformat(220, MSG_ACTIVE_DISABLED);\n                } else if (!strcmp(arg, \"2\") && !v6ready) {\n                    addreply_noformat(522, MSG_ONLY_IPV4);\n                } else {\n                    dopasv(1);\n                }\n#ifndef MINIMAL            \n            } else if (disallow_passive == 0 && !strcmp(cmd, \"spsv\")) {\n                dopasv(2);\n            } else if (!strcmp(cmd, \"allo\")) {\n                if (*arg == 0) {\n                    addreply_noformat(501, MSG_STAT_FAILURE);\n                } else {\n                    const off_t size = (off_t) strtoull(arg, NULL, 10);\n                    \n                    if (size < (off_t) 0) {\n                        addreply_noformat(501, MSG_STAT_FAILURE);                        \n                    } else {\n                        doallo(size);\n                    }\n                }\n#endif\n            } else if (!strcmp(cmd, \"pwd\") || !strcmp(cmd, \"xpwd\")) {\n#ifdef WITH_RFC2640\n\t\tchar *nwd;\n#endif\n                antiidle();\n#ifdef WITH_RFC2640\n\t\tnwd = charset_fs2client(wd);\n\t\taddreply(257, \"\\\"%s\\\" \" MSG_IS_YOUR_CURRENT_LOCATION, nwd);\n\t\tfree(nwd);\n#else\n                addreply(257, \"\\\"%s\\\" \" MSG_IS_YOUR_CURRENT_LOCATION, wd);\n#endif\n                goto wayout;                \n            } else if (!strcmp(cmd, \"cdup\") || !strcmp(cmd, \"xcup\")) {\n                docwd(\"..\");\n            } else if (!strcmp(cmd, \"retr\")) {\n                if (*arg != 0) {\n#ifdef WITH_TLS\n                    if (enforce_tls_auth == 3 &&\n                        data_protection_level != CPL_PRIVATE) {\n                        addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);\n                    }\n                    else\n#endif\n                    {\n                        doretr(arg);\n                    }\n                } else {\n                    addreply_noformat(501, MSG_NO_FILE_NAME);\n                }\n            } else if (!strcmp(cmd, \"rest\")) {\n                antiidle();\n                if (*arg != 0) {\n                    dorest(arg);\n                } else {\n                    addreply_noformat(501, MSG_NO_RESTART_POINT);\n                    restartat = (off_t) 0;\n                }\n                goto wayout;\n            } else if (!strcmp(cmd, \"dele\")) {\n                if (*arg != 0) {\n                    dodele(arg);\n                } else {\n                    addreply_noformat(501, MSG_NO_FILE_NAME);\n                }\n            } else if (!strcmp(cmd, \"stor\")) {\n                arg = revealextraspc(arg);\n                if (*arg != 0) {\n#ifdef WITH_TLS\n                    if (enforce_tls_auth == 3 &&\n                        data_protection_level != CPL_PRIVATE) {\n                        addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);\n                    } else \n#endif\n                    {\n                        dostor(arg, 0, autorename);\n                    }\n                } else {\n                    addreply_noformat(501, MSG_NO_FILE_NAME);\n                }\n            } else if (!strcmp(cmd, \"appe\")) {\n                arg = revealextraspc(arg);\n                if (*arg != 0) {\n#ifdef WITH_TLS\n                    if (enforce_tls_auth == 3 &&\n                        data_protection_level != CPL_PRIVATE) {\n                        addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);\n                    } else \n#endif\n                    {\n                        dostor(arg, 1, 0);\n                    }\n                } else {\n                    addreply_noformat(501, MSG_NO_FILE_NAME);\n                }\n#ifndef MINIMAL\n            } else if (!strcmp(cmd, \"stou\")) {\n#ifdef WITH_TLS\n                if (enforce_tls_auth == 3 &&\n                    data_protection_level != CPL_PRIVATE) {\n                    addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);\n                } else \n#endif\n                {\n            \t     dostou();\n                }\n#endif\n#ifndef DISABLE_MKD_RMD\n            } else if (!strcmp(cmd, \"mkd\") || !strcmp(cmd, \"xmkd\")) {\n                arg = revealextraspc(arg);\n                if (*arg != 0) {\n                    domkd(arg);\n                } else {\n                    addreply_noformat(501, MSG_NO_DIRECTORY_NAME);\n                }\n            } else if (!strcmp(cmd, \"rmd\") || !strcmp(cmd, \"xrmd\")) {\n                if (*arg != 0) {\n                    dormd(arg);\n                } else {\n                    addreply_noformat(550, MSG_NO_DIRECTORY_NAME);\n                }\n#endif\n#ifndef MINIMAL\n            } else if (!strcmp(cmd, \"stat\")) {\n                if (*arg != 0) {\n                    modern_listings = 0;\n                    donlist(arg, 1, 1, 1, 1);\n                } else {\n                    addreply_noformat(211, \"http://www.pureftpd.org/\");\n                }\n#endif\n            } else if (!strcmp(cmd, \"list\")) {\n#ifndef MINIMAL\n                modern_listings = 0;\n#endif\n#ifdef WITH_TLS\n                if (enforce_tls_auth == 3 &&\n                    data_protection_level != CPL_PRIVATE) {\n                    addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);\n                } else\n#endif\n                {\n                    donlist(arg, 0, 1, 0, 1);\n                }\n            } else if (!strcmp(cmd, \"nlst\")) {\n#ifndef MINIMAL                \n                modern_listings = 0;\n#endif\n#ifdef WITH_TLS\n                if (enforce_tls_auth == 3 &&\n                    data_protection_level != CPL_PRIVATE) {\n                    addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);\n                } else\n#endif\n                {\n                    donlist(arg, 0, 0, 0, broken_client_compat);\n                }\n#ifndef MINIMAL\n            } else if (!strcmp(cmd, \"mlst\")) {\n#ifdef WITH_TLS\n                if (enforce_tls_auth == 3 &&\n                    data_protection_level != CPL_PRIVATE) {\n                    addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);\n                } else\n#endif\n                {\n                    domlst(*arg != 0 ? arg : \".\");\n                }\n            } else if (!strcmp(cmd, \"mlsd\")) {\n                modern_listings = 1;\n#ifdef WITH_TLS\n                if (enforce_tls_auth == 3 &&\n                    data_protection_level != CPL_PRIVATE) {\n                    addreply_noformat(521, MSG_PROT_PRIVATE_NEEDED);\n                } else\n#endif\n                {\n                    donlist(arg, 0, 1, 1, 0);\n                }\n#endif\n            } else if (!strcmp(cmd, \"abor\")) {\n                addreply_noformat(226, MSG_ABOR_SUCCESS);\n#ifndef MINIMAL\n            } else if (!strcmp(cmd, \"site\")) {\n                if ((sitearg = arg) != NULL) {\n                    while (*sitearg != 0 && !isspace((unsigned char) *sitearg)) {\n                        sitearg++;\n                    }\n                    if (*sitearg != 0) {\n                        *sitearg++ = 0;\n                    }\n                }\n                if (!strcasecmp(arg, \"idle\")) {\n                    if (sitearg == NULL || *sitearg == 0) {\n                        addreply_noformat(501, \"SITE IDLE: \" MSG_MISSING_ARG);\n                    } else {\n                        unsigned long int i = 0;\n\n                        i = strtoul(sitearg, &sitearg, 10);\n                        if (sitearg && *sitearg)\n                            addreply(501, MSG_GARBAGE_FOUND \" : %s\", sitearg);\n                        else if (i > MAX_SITE_IDLE)\n                            addreply_noformat(501, MSG_VALUE_TOO_LARGE);\n                        else {\n                            idletime = i;\n                            addreply(200, MSG_IDLE_TIME, idletime);\n                            idletime_noop = (double) idletime * 2.0;\n                        }\n                    }\n                } else if (!strcasecmp(arg, \"time\")) {\n                    dositetime();\n                } else if (!strcasecmp(arg, \"help\")) {\n                    help_site:\n                    \n                    addreply_noformat(214, MSG_SITE_HELP CRLF\n# ifdef WITH_DIRALIASES\n                                      \" ALIAS\" CRLF\n# endif\n                                      \" CHMOD\" CRLF \" IDLE\" CRLF \" UTIME\");\n                    addreply_noformat(214, \"Pure-FTPd - http://pureftpd.org/\");\n                } else if (!strcasecmp(arg, \"chmod\")) {\n                    char *sitearg2;\n                    mode_t mode;\n                    \n                    parsechmod:\n                    if (sitearg == NULL || *sitearg == 0) {\n                        addreply_noformat(501, MSG_MISSING_ARG);\n                        goto chmod_wayout;\n                    }\n                    sitearg2 = sitearg;\n                    while (*sitearg2 != 0 && !isspace((unsigned char) *sitearg2)) {\n                        sitearg2++;\n                    }                    \n                    while (*sitearg2 != 0 && isspace((unsigned char) *sitearg2)) {\n                        sitearg2++;\n                    }                    \n                    if (*sitearg2 == 0) {\n                        addreply_noformat(550, MSG_NO_FILE_NAME);\n                        goto chmod_wayout;\n                    }\n                    mode = (mode_t) strtoul(sitearg, NULL, 8);\n                    if (mode > (mode_t) 07777) {\n                        addreply_noformat(501, MSG_BAD_CHMOD);\n                        goto chmod_wayout;\n                    }\n                    dochmod(sitearg2, mode);\n                    chmod_wayout:\n                    (void) 0;\n                } else if (!strcasecmp(arg, \"utime\")) {\n                    char *sitearg2;\n                    \n                    if (sitearg == NULL || *sitearg == 0) {\n                        addreply_noformat(501, MSG_NO_FILE_NAME);\n                        goto utime_wayout;\n                    }\t\t    \n                    if ((sitearg2 = strrchr(sitearg, ' ')) == NULL ||\n                        sitearg2 == sitearg) {\n                        addreply_noformat(501, MSG_MISSING_ARG);\n                        goto utime_wayout;\n                    }\n                    if (strcasecmp(sitearg2, \" UTC\") != 0) {\n                        addreply_noformat(500, \"UTC Only\");\n                        goto utime_wayout;\t\t\t\n                    }\n                    *sitearg2-- = 0;\n                    if ((sitearg2 = strrchr(sitearg, ' ')) == NULL ||\n                        sitearg2 == sitearg) {\n                        utime_no_arg:\n                        addreply_noformat(501, MSG_MISSING_ARG);\n                        goto utime_wayout;\n                    }\n                    *sitearg2-- = 0;\n                    if ((sitearg2 = strrchr(sitearg, ' ')) == NULL ||\n                        sitearg2 == sitearg) {\n                        goto utime_no_arg;\n                    }\n                    *sitearg2-- = 0;\n                    if ((sitearg2 = strrchr(sitearg, ' ')) == NULL ||\n                        sitearg2 == sitearg) {\n                        goto utime_no_arg;\n                    }\n                    *sitearg2++ = 0;\n                    if (*sitearg2 == 0) {\n                        goto utime_no_arg;\t\t\t\n                    }\n                    doutime(sitearg, sitearg2);\n                    utime_wayout:\n                    (void) 0;\n# ifdef WITH_DIRALIASES\t\t    \n                } else if (!strcasecmp(arg, \"alias\")) {\n                    if (sitearg == NULL || *sitearg == 0) {\n                        print_aliases();\n                    } else {\n                        const char *alias;\n                        \n                        if ((alias = lookup_alias(sitearg)) != NULL) {\n                            addreply(214, MSG_ALIASES_ALIAS, sitearg, alias);\n                        } else {\n                            addreply(502, MSG_ALIASES_UNKNOWN, sitearg);\n                        }\n                    }\n# endif\n                } else if (*arg != 0) {\n                    addreply(500, \"SITE %s \" MSG_UNKNOWN_EXTENSION, arg);\n                } else {\n                    addreply_noformat(500, \"SITE: \" MSG_MISSING_ARG);\n                }\n#endif\n            } else if (!strcmp(cmd, \"mdtm\")) {\n                domdtm(arg);\n            } else if (!strcmp(cmd, \"size\")) {\n                dosize(arg);\n#ifndef MINIMAL\n            } else if (!strcmp(cmd, \"chmod\")) {\n                sitearg = arg;\n                goto parsechmod;\n#endif\n            } else if (!strcmp(cmd, \"rnfr\")) {\n                if (*arg != 0) {\n                    dornfr(arg);\n                } else {\n                    addreply_noformat(550, MSG_NO_FILE_NAME);\n                }\n            } else if (!strcmp(cmd, \"rnto\")) {\n                arg = revealextraspc(arg);\n                if (*arg != 0) {\n                    dornto(arg);\n                } else {\n                    addreply_noformat(550, MSG_NO_FILE_NAME);\n                }\n            } else {\n                addreply_noformat(500, MSG_UNKNOWN_COMMAND);\n            }\n        }\n        noopidle = (time_t) -1;\n        wayout:\n#ifdef WITH_RFC2640\n        free(narg);\n        narg = NULL;\n#endif\n#ifdef THROTTLING\n        if (throttling_delay != 0UL) {\n            usleep2(throttling_delay);\n        }\n#else\n        (void) 0;\n#endif\n    }\n}\n"], "filenames": ["src/ftp_parser.c"], "buggy_code_start_loc": [59], "buggy_code_end_loc": [364], "fixing_code_start_loc": [60], "fixing_code_end_loc": [372], "type": "CWE-399", "message": "The STARTTLS implementation in ftp_parser.c in Pure-FTPd before 1.0.30 does not properly restrict I/O buffering, which allows man-in-the-middle attackers to insert commands into encrypted FTP sessions by sending a cleartext command that is processed after TLS is in place, related to a \"plaintext command injection\" attack, a similar issue to CVE-2011-0411.", "other": {"cve": {"id": "CVE-2011-1575", "sourceIdentifier": "secalert@redhat.com", "published": "2011-05-23T22:55:01.207", "lastModified": "2014-02-21T04:41:44.733", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The STARTTLS implementation in ftp_parser.c in Pure-FTPd before 1.0.30 does not properly restrict I/O buffering, which allows man-in-the-middle attackers to insert commands into encrypted FTP sessions by sending a cleartext command that is processed after TLS is in place, related to a \"plaintext command injection\" attack, a similar issue to CVE-2011-0411."}, {"lang": "es", "value": "La implementaci\u00f3n de STARTTLS en ftp_parser.c de Pure-FTPd en versiones anteriores a 1.0.30\r\nno restringe correctamente el buffer de entrada/salida, que permite a los atacantes a realizar \"man-in-the-middle\" para insertar comandos en las sesiones FTP cifradas mediante el env\u00edo de un comando en claro que se procesa despu\u00e9s de TLS est\u00e9 funcionando, se relaciona con una \"inyecci\u00f3n de comandos de texto claro\" es un problema similar a CVE-2011-0411."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.0.29", "matchCriteriaId": "A3D14516-085B-45FB-A7F5-C695F72586FA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.90:*:*:*:*:*:*:*", "matchCriteriaId": "1BAA8918-A2CB-47A3-BEA5-012202416E2D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.91:*:*:*:*:*:*:*", "matchCriteriaId": "E7AC08B4-58AC-415A-9B66-40A1E3CCD0F8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.92:*:*:*:*:*:*:*", "matchCriteriaId": "109D76F0-FB16-4DB5-8CD9-5FC4B7A888F8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.93:*:*:*:*:*:*:*", "matchCriteriaId": "D21A2797-A1E1-41D1-A4F9-88A6BDB39386"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.94:*:*:*:*:*:*:*", "matchCriteriaId": "A6F60D6F-5EED-4F98-B837-8DA704AE655E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.95:*:*:*:*:*:*:*", "matchCriteriaId": "B6FB0AE1-D1C1-49BA-92EB-22610F805C24"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.95-pre1:*:*:*:*:*:*:*", "matchCriteriaId": "AEF345E7-32E3-4AC2-AF59-2909BCD0F0E4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.95-pre2:*:*:*:*:*:*:*", "matchCriteriaId": "BB8E9891-37F0-4A89-8313-3DF7B30D20C2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.95-pre3:*:*:*:*:*:*:*", "matchCriteriaId": "3503BC8E-04EB-4B8B-BCC5-257FBE275435"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.95-pre4:*:*:*:*:*:*:*", "matchCriteriaId": "64733EB4-34AE-4BF6-BC42-5BEB171D02F3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.95.1:*:*:*:*:*:*:*", "matchCriteriaId": "75803E7D-E4C4-429A-831D-E9BD35D3822F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.95.2:*:*:*:*:*:*:*", "matchCriteriaId": "0AF6AB58-64E1-4B6E-BE3A-F1EF3A4D6D25"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.96:*:*:*:*:*:*:*", "matchCriteriaId": "AEE4E7D4-64C3-401D-88BD-25480BB0353E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.96.1:*:*:*:*:*:*:*", "matchCriteriaId": "0DE75C61-AEB4-49FF-92F0-59BE2DC235A3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.96pre1:*:*:*:*:*:*:*", "matchCriteriaId": "6341410D-6327-40CB-8E77-03715170957A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.97-final:*:*:*:*:*:*:*", "matchCriteriaId": "1664490B-CA34-44A3-8EEC-71A07799E870"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.97.1:*:*:*:*:*:*:*", "matchCriteriaId": "C151E6E5-AC14-4C12-B1E4-4FDED6F5CF33"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.97.2:*:*:*:*:*:*:*", "matchCriteriaId": "FC7E10AE-9B98-4801-91CD-F6EEC75B9C0D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.97.3:*:*:*:*:*:*:*", "matchCriteriaId": "BFF21C85-76FC-463C-8661-60BE2D3CAC10"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.97.4:*:*:*:*:*:*:*", "matchCriteriaId": "21110017-470F-4C38-B09F-8DF94E48EFE3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.97.5:*:*:*:*:*:*:*", "matchCriteriaId": "2BA24CD0-22DA-4689-981D-88FAA7FCC1C8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.97.6:*:*:*:*:*:*:*", "matchCriteriaId": "1931478E-A672-4CF6-9BDC-B3C73B7DA5A4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.97.7:*:*:*:*:*:*:*", "matchCriteriaId": "71C4863E-76DA-4E38-B2C7-B30037633030"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.97.7pre1:*:*:*:*:*:*:*", "matchCriteriaId": "82F13F0C-B2B7-4DBA-BEB0-4599CE2EE422"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.97.7pre2:*:*:*:*:*:*:*", "matchCriteriaId": "11938621-40EA-4B68-B802-B793F3AAD990"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.97.7pre3:*:*:*:*:*:*:*", "matchCriteriaId": "3DAAE0EB-626A-42BD-A522-CAA026AF5BD3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.97pre1:*:*:*:*:*:*:*", "matchCriteriaId": "C2139A56-05FC-468A-8BA4-D319FD878976"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.97pre2:*:*:*:*:*:*:*", "matchCriteriaId": "1DCE9F15-F266-4194-A328-BE7EB2D4CA6D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.97pre3:*:*:*:*:*:*:*", "matchCriteriaId": "BF3055A8-D3BB-4A42-8A5A-848502C08CA3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.97pre4:*:*:*:*:*:*:*", "matchCriteriaId": "535B52FC-4573-42C7-A0F4-29B8B7BEFD65"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.97pre5:*:*:*:*:*:*:*", "matchCriteriaId": "0772C8AB-3290-4A18-8417-4EB248398478"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.98-final:*:*:*:*:*:*:*", "matchCriteriaId": "BC466025-06CF-48F9-B57A-02FD4D62B472"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.98.1:*:*:*:*:*:*:*", "matchCriteriaId": "57A8D91C-EEEB-4F76-8010-2CB174A9B091"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.98.2:*:*:*:*:*:*:*", "matchCriteriaId": "B1831F7D-7366-4775-9B70-832F3BAB23E1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.98.2a:*:*:*:*:*:*:*", "matchCriteriaId": "4ADCEF99-E5A8-4890-B75D-5055F09EDA23"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.98.3:*:*:*:*:*:*:*", "matchCriteriaId": "962C592B-1B02-49EE-9C82-2EA1B0F0F4DB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.98.4:*:*:*:*:*:*:*", "matchCriteriaId": "DA327868-1A00-4BFE-AB29-3DBE57545EBA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.98.5:*:*:*:*:*:*:*", "matchCriteriaId": "09575AA6-7F8C-4A9C-B781-C892B00C3035"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.98.6:*:*:*:*:*:*:*", "matchCriteriaId": "E3810E39-63C2-486A-9FFC-C7BBC6DCD455"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.98.7:*:*:*:*:*:*:*", "matchCriteriaId": "07E6BD24-3843-479E-9DD0-56C69F8A0B71"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.98pre1:*:*:*:*:*:*:*", "matchCriteriaId": "AAF09FF7-82C8-4C1F-A9CB-245A7D11D2D8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.98pre2:*:*:*:*:*:*:*", "matchCriteriaId": "E0B687A9-8B0B-4059-B6F6-29D76440F054"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.99:*:*:*:*:*:*:*", "matchCriteriaId": "41E823CA-D59A-404F-A064-25F557BEBD5A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.99.1:*:*:*:*:*:*:*", "matchCriteriaId": "AD057E44-D7B8-414C-A21D-DEC8753F0C50"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.99.1a:*:*:*:*:*:*:*", "matchCriteriaId": "ED1A7388-0878-492C-B89A-C732CCE3E6EF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.99.1b:*:*:*:*:*:*:*", "matchCriteriaId": "DF1025C8-B056-4AA7-9976-5FD6AC51A012"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.99.2:*:*:*:*:*:*:*", "matchCriteriaId": "D968FE34-54C4-4C06-8EB7-0537EDAAD6FC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.99.2a:*:*:*:*:*:*:*", "matchCriteriaId": "70D16075-5855-4448-B79D-8B7385EE0E16"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.99.3:*:*:*:*:*:*:*", "matchCriteriaId": "4CAD1DE8-7D55-4C0B-B691-E8D8AA6E2689"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.99.4:*:*:*:*:*:*:*", "matchCriteriaId": "70576B73-12AF-463B-96AB-18725ACDECFE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.99.9:*:*:*:*:*:*:*", "matchCriteriaId": "39F6EBD8-4BFD-49FC-A087-8698DB462880"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.99a:*:*:*:*:*:*:*", "matchCriteriaId": "7ED3D13F-D769-4668-AD31-9E9C6B4F1738"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.99b:*:*:*:*:*:*:*", "matchCriteriaId": "7B02414C-C7CF-4719-ABCC-FB019C205163"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.99pre1:*:*:*:*:*:*:*", "matchCriteriaId": "B0518387-8900-43BF-B592-EB9F725E9FBA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:0.99pre2:*:*:*:*:*:*:*", "matchCriteriaId": "C2044321-568E-4381-83EC-EBF9F0D46CA7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "3737B53D-E0BC-430F-9B00-5F13C15E3EF5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "DF48827A-8F95-4D07-BB35-AD43A048072B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "10DB2640-6C1B-4B95-998C-3737809C9E40"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "3A4B5B69-85CF-40C8-BC79-C340A6445F8C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "8992045B-1EC7-4254-966E-AECDAEFD950E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "14C4E0E1-FC73-4641-A7AC-47E25EAE251B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "AF00DCF7-A5B8-4B62-9F4F-EB2273589215"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "947E46FD-1B9D-4F64-8C10-FF332796CFE5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "B72E9F25-975E-4609-A741-F472CEB53265"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "2D76E5AE-B1D2-4362-915A-A6C15225F772"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "AD6BC5DF-3A1E-4B1F-87E9-857AE413841C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "3928B3DD-CA7E-4204-A49A-7B6E1F973B47"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "091BB6EB-7263-4DD2-8B57-B1FF73D61B7A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.13a:*:*:*:*:*:*:*", "matchCriteriaId": "8622805C-1E49-45F5-8CB0-2C0ECD9E5F0F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "C705AE7A-8F8B-49C1-BEA4-B1486AAE9E2C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "E0AB8F16-5A30-4D85-A3E0-E8EECD5EEA69"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.16a:*:*:*:*:*:*:*", "matchCriteriaId": "DEB3C26B-945B-4C81-BF15-4E767B544A68"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.16b:*:*:*:*:*:*:*", "matchCriteriaId": "C3AD4259-CA7D-45D1-8459-F8D44165AC15"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.16c:*:*:*:*:*:*:*", "matchCriteriaId": "866DF3B5-A364-4563-A883-D052DCD86C51"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.17:*:*:*:*:*:*:*", "matchCriteriaId": "B76D15CD-FECF-435F-A7E4-54FE53638C1E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.17a:*:*:*:*:*:*:*", "matchCriteriaId": "59FBF7FD-A6C9-46F0-8C9E-CF2098DCB8CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.18:*:*:*:*:*:*:*", "matchCriteriaId": "8669B8EC-482D-44CD-B30E-7D83423E1BC9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.19:*:*:*:*:*:*:*", "matchCriteriaId": "B67A0244-D65F-4CCE-A084-31AD9A3D9B8E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.20:*:*:*:*:*:*:*", "matchCriteriaId": "DFD2D751-2B85-428E-8766-36F92B338C5C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.21:*:*:*:*:*:*:*", "matchCriteriaId": "579ECF9F-EBED-49BC-A804-86C71554D06C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.22:*:*:*:*:*:*:*", "matchCriteriaId": "66DC1055-CD1D-48B3-9CC4-40F42C3490A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.24:*:*:*:*:*:*:*", "matchCriteriaId": "F753B7E9-BC46-40AD-A6E6-638C91468756"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.25:*:*:*:*:*:*:*", "matchCriteriaId": "2D2F7326-B11E-42AE-A0E4-E02CA9E0F9E2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.26:*:*:*:*:*:*:*", "matchCriteriaId": "307B2193-1737-4FD5-B1E9-19DCB88443B9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.27:*:*:*:*:*:*:*", "matchCriteriaId": "42799518-1D12-4500-8E06-ED10D2239FCA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.28:*:*:*:*:*:*:*", "matchCriteriaId": "31411BEC-1326-4CC4-84FB-6DFCB0D3AFEF"}]}]}], "references": [{"url": "http://archives.pureftpd.org/archives.cgi?100:mss:3906:201103:cpeojfkblajnpinkeadd", "source": "secalert@redhat.com"}, {"url": "http://archives.pureftpd.org/archives.cgi?100:mss:3910:201103:cpeojfkblajnpinkeadd", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2011-05/msg00005.html", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-updates/2011-05/msg00029.html", "source": "secalert@redhat.com"}, {"url": "http://openwall.com/lists/oss-security/2011/04/11/14", "source": "secalert@redhat.com"}, {"url": "http://openwall.com/lists/oss-security/2011/04/11/3", "source": "secalert@redhat.com"}, {"url": "http://openwall.com/lists/oss-security/2011/04/11/7", "source": "secalert@redhat.com"}, {"url": "http://openwall.com/lists/oss-security/2011/04/11/8", "source": "secalert@redhat.com"}, {"url": "http://www.pureftpd.org/project/pure-ftpd/news", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.novell.com/show_bug.cgi?id=686590", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=683221", "source": "secalert@redhat.com"}, {"url": "https://github.com/jedisct1/pure-ftpd/commit/65c4d4ad331e94661de763e9b5304d28698999c4", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/jedisct1/pure-ftpd/commit/65c4d4ad331e94661de763e9b5304d28698999c4"}}