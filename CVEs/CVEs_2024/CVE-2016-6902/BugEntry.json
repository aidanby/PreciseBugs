{"buggy_code": ["#\n#  Limited command Shell (lshell)\n#\n#  Copyright (C) 2008-2013 Ignace Mouzannar (ghantoos) <ghantoos@ghantoos.org>\n#\n#  This file is part of lshell\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport sys\nimport re\nimport os\n\n# import lshell specifics\nfrom lshell import utils\n\n\ndef warn_count(messagetype, command, conf, strict=None, ssh=None):\n    \"\"\" Update the warning_counter, log and display a warning to the user\n    \"\"\"\n\n    log = conf['logpath']\n    if not ssh:\n        if strict:\n            conf['warning_counter'] -= 1\n            if conf['warning_counter'] < 0:\n                log.critical('*** forbidden %s -> \"%s\"'\n                             % (messagetype, command))\n                log.critical('*** Kicked out')\n                sys.exit(1)\n            else:\n                log.critical('*** forbidden %s -> \"%s\"'\n                             % (messagetype, command))\n                sys.stderr.write('*** You have %s warning(s) left,'\n                                 ' before getting kicked out.\\n'\n                                 % conf['warning_counter'])\n                log.error('*** User warned, counter: %s'\n                          % conf['warning_counter'])\n                sys.stderr.write('This incident has been reported.\\n')\n        else:\n            if not conf['quiet']:\n                log.critical('*** forbidden %s: %s'\n                             % (messagetype, command))\n\n    # if you are here, means that you did something wrong. Return 1.\n    return 1, conf\n\n\ndef check_path(line, conf, completion=None, ssh=None, strict=None):\n    \"\"\" Check if a path is entered in the line. If so, it checks if user\n    are allowed to see this path. If user is not allowed, it calls\n    warn_count. In case of completion, it only returns 0 or 1.\n    \"\"\"\n    allowed_path_re = str(conf['path'][0])\n    denied_path_re = str(conf['path'][1][:-1])\n\n    # split line depending on the operators\n    sep = re.compile(r'\\ |;|\\||&')\n    line = line.strip()\n    line = sep.split(line)\n\n    for item in line:\n        # remove potential quotes or back-ticks\n        item = re.sub(r'^[\"\\'`]|[\"\\'`]$', '', item)\n\n        # remove potential $(), ${}, ``\n        item = re.sub(r'^\\$[\\(\\{]|[\\)\\}]$', '', item)\n\n        # if item has been converted to something other than a string\n        # or an int, reconvert it to a string\n        if type(item) not in ['str', 'int']:\n            item = str(item)\n        # replace \"~\" with home path\n        item = os.path.expanduser(item)\n\n        # expand shell wildcards using \"echo\"\n        # i know, this a bit nasty...\n        if re.findall('\\$|\\*|\\?', item):\n            # remove quotes if available\n            item = re.sub(\"\\\"|\\'\", \"\", item)\n            import subprocess\n            p = subprocess.Popen(\"`which echo` %s\" % item,\n                                 shell=True,\n                                 stdin=subprocess.PIPE,\n                                 stdout=subprocess.PIPE,\n                                 stderr=subprocess.PIPE)\n            cout = p.stdout\n\n            try:\n                item = cout.readlines()[0].decode('utf8').split(' ')[0]\n                item = item.strip()\n                item = os.path.expandvars(item)\n            except IndexError:\n                conf['logpath'].critical('*** Internal error: command not '\n                                         'executed')\n                return 1, conf\n\n        tomatch = os.path.realpath(item)\n        if os.path.isdir(tomatch) and tomatch[-1] != '/':\n            tomatch += '/'\n        match_allowed = re.findall(allowed_path_re, tomatch)\n        if denied_path_re:\n            match_denied = re.findall(denied_path_re, tomatch)\n        else:\n            match_denied = None\n\n        # if path not allowed\n        # case path executed: warn, and return 1\n        # case completion: return 1\n        if not match_allowed or match_denied:\n            if not completion:\n                ret, conf = warn_count('path',\n                                       tomatch,\n                                       conf,\n                                       strict=strict,\n                                       ssh=ssh)\n            return 1, conf\n\n    if not completion:\n        if not re.findall(allowed_path_re, os.getcwd() + '/'):\n            ret, conf = warn_count('path',\n                                   tomatch,\n                                   conf,\n                                   strict=strict,\n                                   ssh=ssh)\n            os.chdir(conf['home_path'])\n            conf['promptprint'] = utils.updateprompt(os.getcwd(),\n                                                     conf)\n            return 1, conf\n    return 0, conf\n\n\ndef check_secure(line, conf, strict=None, ssh=None):\n    \"\"\"This method is used to check the content on the typed command.\n    Its purpose is to forbid the user to user to override the lshell\n    command restrictions.\n    The forbidden characters are placed in the 'forbidden' variable.\n    Feel free to update the list. Emptying it would be quite useless..: )\n\n    A warning counter has been added, to kick out of lshell a user if he\n    is warned more than X time (X being the 'warning_counter' variable).\n    \"\"\"\n\n    # store original string\n    oline = line\n\n    # strip all spaces/tabs\n    line = line.strip()\n\n    # init return code\n    returncode = 0\n\n    # This logic is kept crudely simple on purpose.\n    # At most we might match the same stanza twice\n    # (for e.g. \"'a'\", 'a') but the converse would\n    # require detecting single quotation stanzas\n    # nested within double quotes and vice versa\n    relist = re.findall(r'[^=]\\\"(.+)\\\"', line)\n    relist2 = re.findall(r'[^=]\\'(.+)\\'', line)\n    relist = relist + relist2\n    for item in relist:\n        if os.path.exists(item):\n            ret_check_path, conf = check_path(item, conf, strict=strict)\n            returncode += ret_check_path\n\n    # ignore quoted text\n    line = re.sub(r'\\\"(.+?)\\\"', '', line)\n    line = re.sub(r'\\'(.+?)\\'', '', line)\n\n    if re.findall('[:cntrl:].*\\n', line):\n        ret, conf = warn_count('syntax',\n                               oline,\n                               conf,\n                               strict=strict,\n                               ssh=ssh)\n        return ret, conf\n\n    for item in conf['forbidden']:\n        # allow '&&' and '||' even if singles are forbidden\n        if item in ['&', '|']:\n            if re.findall(\"[^\\%s]\\%s[^\\%s]\" % (item, item, item), line):\n                ret, conf = warn_count('syntax',\n                                       oline,\n                                       conf,\n                                       strict=strict,\n                                       ssh=ssh)\n                return ret, conf\n        else:\n            if item in line:\n                ret, conf = warn_count('syntax',\n                                       oline,\n                                       conf,\n                                       strict=strict,\n                                       ssh=ssh)\n                return ret, conf\n\n    # check if the line contains $(foo) executions, and check them\n    executions = re.findall('\\$\\([^)]+[)]', line)\n    for item in executions:\n        # recurse on check_path\n        ret_check_path, conf = check_path(item[2:-1].strip(),\n                                          conf,\n                                          strict=strict)\n        returncode += ret_check_path\n\n        # recurse on check_secure\n        ret_check_secure, conf = check_secure(item[2:-1].strip(),\n                                              conf,\n                                              strict=strict)\n        returncode += ret_check_secure\n\n    # check for executions using back quotes '`'\n    executions = re.findall('\\`[^`]+[`]', line)\n    for item in executions:\n        ret_check_secure, conf = check_secure(item[1:-1].strip(),\n                                              conf,\n                                              strict=strict)\n        returncode += ret_check_secure\n\n    # check if the line contains ${foo=bar}, and check them\n    curly = re.findall('\\$\\{[^}]+[}]', line)\n    for item in curly:\n        # split to get variable only, and remove last character \"}\"\n        if re.findall(r'=|\\+|\\?|\\-', item):\n            variable = re.split('=|\\+|\\?|\\-', item, 1)\n        else:\n            variable = item\n        ret_check_path, conf = check_path(variable[1][:-1],\n                                          conf,\n                                          strict=strict)\n        returncode += ret_check_path\n\n    # if unknown commands where found, return 1 and don't execute the line\n    if returncode > 0:\n        return 1, conf\n    # in case the $(foo) or `foo` command passed the above tests\n    elif line.startswith('$(') or line.startswith('`'):\n        return 0, conf\n\n    # in case ';', '|' or '&' are not forbidden, check if in line\n    lines = []\n\n    # corrected by Alojzij Blatnik #48\n    # test first character\n    if line[0] in [\"&\", \"|\", \";\"]:\n        start = 1\n    else:\n        start = 0\n\n    # split remaining command line\n    for i in range(1, len(line)):\n        # in case \\& or \\| or \\; don't split it\n        if line[i] in [\"&\", \"|\", \";\"] and line[i - 1] != \"\\\\\":\n            # if there is more && or || skip it\n            if start != i:\n                lines.append(line[start:i])\n            start = i + 1\n\n    # append remaining command line\n    if start != len(line):\n        lines.append(line[start:len(line)])\n\n    # remove trailing parenthesis\n    line = re.sub('\\)$', '', line)\n    for separate_line in lines:\n        separate_line = \" \".join(separate_line.split())\n        splitcmd = separate_line.strip().split(' ')\n        command = splitcmd[0]\n        if len(splitcmd) > 1:\n            cmdargs = splitcmd\n        else:\n            cmdargs = None\n\n        # in case of a sudo command, check in sudo_commands list if allowed\n        if command == 'sudo':\n            if type(cmdargs) == list:\n                # allow the -u (user) flag\n                if cmdargs[1] == '-u' and cmdargs:\n                    sudocmd = cmdargs[3]\n                else:\n                    sudocmd = cmdargs[1]\n                if sudocmd not in conf['sudo_commands'] and cmdargs:\n                    ret, conf = warn_count('sudo command',\n                                           oline,\n                                           conf,\n                                           strict=strict,\n                                           ssh=ssh)\n                    return ret, conf\n\n        # if over SSH, replaced allowed list with the one of overssh\n        if ssh:\n            conf['allowed'] = conf['overssh']\n\n        # for all other commands check in allowed list\n        if command not in conf['allowed'] and command:\n            ret, conf = warn_count('command',\n                                   command,\n                                   conf,\n                                   strict=strict,\n                                   ssh=ssh)\n            return ret, conf\n    return 0, conf\n", "import unittest\nimport pexpect\nimport os\nimport subprocess\nfrom getpass import getuser\n\n# import lshell specifics\nfrom lshell import utils\n\nTOPDIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))\n\n\nclass TestFunctions(unittest.TestCase):\n\n    user = getuser()\n\n    def setUp(self):\n        \"\"\" spawn lshell with pexpext and return the child \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf --strict 1'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n    def tearDown(self):\n        self.child.close()\n\n    def test_01_welcome_message(self):\n        \"\"\" F01 | lshell welcome message \"\"\"\n        expected = \"You are in a limited shell.\\r\\nType '?' or 'help' to get\" \\\n            \" the list of allowed commands\\r\\n\"\n        result = self.child.before.decode('utf8')\n        self.assertEqual(expected, result)\n\n    def test_02_builtin_ls_command(self):\n        \"\"\" F02 | built-in ls command \"\"\"\n        p = subprocess.Popen(\"ls ~\",\n                             shell=True,\n                             stdin=subprocess.PIPE,\n                             stdout=subprocess.PIPE)\n        cout = p.stdout\n        expected = cout.read(-1)\n        self.child.sendline('ls')\n        self.child.expect('%s:~\\$' % self.user)\n        output = self.child.before.decode('utf8').split('ls\\r', 1)[1]\n        self.assertEqual(len(expected.strip().split()),\n                         len(output.strip().split()))\n\n    def test_03_external_echo_command_num(self):\n        \"\"\" F03 | external echo number \"\"\"\n        expected = \"32\"\n        self.child.sendline('echo 32')\n        self.child.expect(\"%s:~\\$\" % self.user)\n        result = self.child.before.decode('utf8').split()[2]\n        self.assertEqual(expected, result)\n\n    def test_04_external_echo_command_string(self):\n        \"\"\" F04 | external echo random string \"\"\"\n        expected = \"bla blabla  32 blibli! plop.\"\n        self.child.sendline('echo \"%s\"' % expected)\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_05_external_echo_forbidden_syntax(self):\n        \"\"\" F05 | echo forbidden syntax $(bleh) \"\"\"\n        expected = \"*** forbidden syntax -> \\\"echo $(uptime)\\\"\\r\\n*** You \" \\\n            \"have 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('echo $(uptime)')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_06_builtin_cd_change_dir(self):\n        \"\"\" F06 | built-in cd - change directory \"\"\"\n        expected = \"\"\n        home = os.path.expanduser('~')\n        dirpath = None\n        for path in os.listdir(home):\n            dirpath = os.path.join(home, path)\n            if os.path.isdir(dirpath):\n                break\n        if dirpath:\n            self.child.sendline('cd %s' % path)\n            self.child.expect('%s:~/%s\\$' % (self.user, path))\n            self.child.sendline('cd ..')\n            self.child.expect('%s:~\\$' % self.user)\n            result = self.child.before.decode('utf8').split('\\n', 1)[1]\n            self.assertEqual(expected, result)\n\n    def test_07_builtin_cd_tilda(self):\n        \"\"\" F07 | built-in cd - tilda bug \"\"\"\n        expected = \"*** forbidden path -> \\\"/etc/passwd\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('ls ~/../../etc/passwd')\n        self.child.expect(\"%s:~\\$\" % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_08_builtin_cd_quotes(self):\n        \"\"\" F08 | built-in - quotes in cd \"/\" \"\"\"\n        expected = \"*** forbidden path -> \\\"/\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('ls -ld \"/\"')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_09_external_forbidden_path(self):\n        \"\"\" F09 | external command forbidden path - ls /root \"\"\"\n        expected = \"*** forbidden path -> \\\"/root/\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('ls ~root')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_10_builtin_cd_forbidden_path(self):\n        \"\"\" F10 | built-in command forbidden path - cd ~root \"\"\"\n        expected = \"*** forbidden path -> \\\"/root/\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('cd ~root')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_11_etc_passwd_1(self):\n        \"\"\" F11 | /etc/passwd: empty variable 'ls \"$a\"/etc/passwd' \"\"\"\n        expected = \"*** forbidden path -> \\\"/etc/passwd\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('ls \"$a\"/etc/passwd')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_12_etc_passwd_2(self):\n        \"\"\" F12 | /etc/passwd: empty variable 'ls -l .*./.*./etc/passwd' \"\"\"\n        expected = \"*** forbidden path -> \\\"/etc/passwd\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('ls -l .*./.*./etc/passwd')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_13_etc_passwd_3(self):\n        \"\"\" F13 | /etc/passwd: empty variable 'ls -l .?/.?/etc/passwd' \"\"\"\n        expected = \"*** forbidden path -> \\\"/etc/passwd\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('ls -l .?/.?/etc/passwd')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_14_path_completion_tilda(self):\n        \"\"\" F14 | path completion with ~/ \"\"\"\n        p = subprocess.Popen(\"ls -F ~/\",\n                             shell=True,\n                             stdin=subprocess.PIPE,\n                             stdout=subprocess.PIPE)\n        cout = p.stdout\n        expected = cout.read(-1)\n        self.child.sendline('cd ~/\\t\\t')\n        self.child.expect('%s:~\\$' % self.user)\n        output = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(len(expected.strip().split()),\n                         len(output.strip().split()))\n\n    def test_15_cmd_completion_tab_tab(self):\n        \"\"\" F15 | command completion: tab to list commands \"\"\"\n        expected = '\\x07\\r\\ncd       echo     help     ll       ls       '\\\n                   '\\r\\nclear    exit     history  lpath    lsudo'\n        self.child.sendline('\\t\\t')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').strip()\n\n        self.assertEqual(expected, result)\n\n    def test_16_exitcode_with_separator_external_cmd(self):\n        \"\"\" F16 | external command exit codes with separator \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--forbidden \"[]\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"2\"\n        self.child.sendline('ls nRVmmn8RGypVneYIp8HxyVAvaEaD55; echo $?')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[2].strip()\n        self.assertEqual(expected, result)\n\n    def test_17_exitcode_without_separator_external_cmd(self):\n        \"\"\" F17 | external command exit codes without separator \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--forbidden \"[]\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"2\"\n        self.child.sendline('ls nRVmmn8RGypVneYIp8HxyVAvaEaD55')\n        self.child.expect('%s:~\\$' % self.user)\n        self.child.sendline('echo $?')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_18_cd_exitcode_with_separator_internal_cmd(self):\n        \"\"\" F18 | built-in command exit codes with separator \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--forbidden \"[]\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"2\"\n        self.child.sendline('cd nRVmmn8RGypVneYIp8HxyVAvaEaD55; echo $?')\n        self.child.expect('%s:~\\$' % self.user)\n        self.child.sendline('echo $?')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_19_cd_exitcode_without_separator_external_cmd(self):\n        \"\"\" F19 | built-in exit codes without separator \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--forbidden \"[]\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"2\"\n        self.child.sendline('cd nRVmmn8RGypVneYIp8HxyVAvaEaD55')\n        self.child.expect('%s:~\\$' % self.user)\n        self.child.sendline('echo $?')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_20_cd_with_cmd_unknwon_dir(self):\n        \"\"\" F20 | test built-in cd with command when dir does not exist\n            Should be returning error, not executing cmd\n        \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--forbidden \"[]\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = 'lshell: nRVmmn8RGypVneYIp8HxyVAvaEaD55: No such file or '\\\n                   'directory'\n\n        self.child.sendline('cd nRVmmn8RGypVneYIp8HxyVAvaEaD55; echo $?')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_21_allow_slash(self):\n        \"\"\" F21 | user should able to allow / access minus some directory\n            (e.g. /var)\n        \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--path \"[\\'/\\'] - [\\'/var\\']\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"*** forbidden path: /var/\"\n        self.child.sendline('cd /')\n        self.child.expect('%s:/\\$' % self.user)\n        self.child.sendline('cd var')\n        self.child.expect('%s:/\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_22_expand_env_variables(self):\n        \"\"\" F22 | expanding of environment variables \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--allowed \"+ [\\'export\\']\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"%s/test\" % os.path.expanduser('~')\n        self.child.sendline('export A=test')\n        self.child.expect('%s:~\\$' % self.user)\n        self.child.sendline('echo $HOME/$A')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_23_expand_env_variables_cd(self):\n        \"\"\" F23 | expanding of environment variables when using cd \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--allowed \"+ [\\'export\\']\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        random = utils.random_string(32)\n\n        expected = 'lshell: %s/random_%s: No such file or directory' % (\n            os.path.expanduser('~'), random)\n        self.child.sendline('export A=random_%s' % random)\n        self.child.expect('%s:~\\$' % self.user)\n        self.child.sendline('cd $HOME/$A')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_24_cd_and_command(self):\n        \"\"\" F24 | cd && command should not be interpreted by internal function\n        \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"OK\"\n        self.child.sendline('cd ~ && echo \"OK\"')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_25_KeyboardInterrupt(self):\n        \"\"\" F25 | test cat(1) with KeyboardInterrupt, should not exit \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--allowed \"+ [\\'cat\\']\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        self.child.sendline('cat')\n        self.child.sendline(' foo ')\n        self.child.sendcontrol('c')\n        self.child.expect('%s:~\\$' % self.user)\n        try:\n            result = self.child.before.decode('utf8').split('\\n')[1].strip()\n            # both behaviors are correct\n            if result.startswith('foo'):\n                expected = 'foo'\n            elif result.startswith('^C'):\n                expected = '^C'\n        except IndexError:\n            # outputs u' ^C' on Debian\n            expected = u'^C'\n            result = self.child.before.decode('utf8').strip()\n        self.assertIn(expected, result)\n\n    def test_26_cmd_completion_dot_slash(self):\n        \"\"\" F26 | command completion: tab to list ./foo1 ./foo2 \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--allowed \"+ [\\'./foo1\\', \\'./foo2\\']\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = u'./\\x07foo\\x07\\r\\nfoo1  foo2'\n        self.child.sendline('./\\t\\t\\t')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').strip()\n\n        self.assertEqual(expected, result)\n\n    def test_27_checksecure_awk(self):\n        \"\"\" F27 | checksecure awk script with /bin/bash \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--allowed \"+ [\\'awk\\']\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = u'*** forbidden path: /bin/bash'\n        self.child.sendline('awk \\'BEGIN {system(\"/bin/bash\")}\\'')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n\n        self.assertEqual(expected, result)\n\n    def test_28_catch_lnext_terminal_ctrl(self):\n        \"\"\" F25 | test ctrl-v ctrl-j then command, forbidden/security \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = u'*** forbidden syntax: echo\\r'\n        self.child.send('echo')\n        self.child.sendcontrol('v')\n        self.child.sendcontrol('j')\n        self.child.sendline('bash')\n        self.child.expect('%s:~\\$' % self.user)\n\n        result = self.child.before.decode('utf8').split('\\n')\n\n        self.assertIn(expected, result)\n\nif __name__ == '__main__':\n    unittest.main()\n", "import unittest\nimport os\nfrom getpass import getuser\n\n# import lshell specifics\nfrom lshell.shellcmd import ShellCmd\nfrom lshell.checkconfig import CheckConfig\nfrom lshell.utils import get_aliases, updateprompt\nfrom lshell.variables import builtins_list\nfrom lshell import builtins\nfrom lshell import sec\n\nTOPDIR = '%s/../' % os.path.dirname(os.path.realpath(__file__))\n\n\nclass TestFunctions(unittest.TestCase):\n    args = ['--config=%s/etc/lshell.conf' % TOPDIR, \"--quiet=1\"]\n    userconf = CheckConfig(args).returnconf()\n    shell = ShellCmd(userconf, args)\n\n    def test_01_checksecure_doublequote(self):\n        \"\"\" U01 | quoted text should not be forbidden \"\"\"\n        INPUT = 'ls -E \"1|2\" tmp/test'\n        return self.assertEqual(sec.check_secure(INPUT, self.userconf)[0], 0)\n\n    def test_02_checksecure_simplequote(self):\n        \"\"\" U02 | quoted text should not be forbidden \"\"\"\n        INPUT = \"ls -E '1|2' tmp/test\"\n        return self.assertEqual(sec.check_secure(INPUT, self.userconf)[0], 0)\n\n    def test_03_checksecure_doublepipe(self):\n        \"\"\" U03 | double pipes should be allowed, even if pipe is forbidden \"\"\"\n        args = self.args + [\"--forbidden=['|']\"]\n        userconf = CheckConfig(args).returnconf()\n        INPUT = \"ls || ls\"\n        return self.assertEqual(sec.check_secure(INPUT, userconf)[0], 0)\n\n    def test_04_checksecure_forbiddenpipe(self):\n        \"\"\" U04 | forbid pipe, should return 1 \"\"\"\n        args = self.args + [\"--forbidden=['|']\"]\n        userconf = CheckConfig(args).returnconf()\n        INPUT = \"ls | ls\"\n        return self.assertEqual(sec.check_secure(INPUT, userconf)[0], 1)\n\n    def test_05_checksecure_forbiddenchar(self):\n        \"\"\" U05 | forbid character, should return 1 \"\"\"\n        args = self.args + [\"--forbidden=['l']\"]\n        userconf = CheckConfig(args).returnconf()\n        INPUT = \"ls\"\n        return self.assertEqual(sec.check_secure(INPUT, userconf)[0], 1)\n\n    def test_06_checksecure_sudo_command(self):\n        \"\"\" U06 | quoted text should not be forbidden \"\"\"\n        INPUT = \"sudo ls\"\n        return self.assertEqual(sec.check_secure(INPUT, self.userconf)[0], 1)\n\n    def test_07_checksecure_notallowed_command(self):\n        \"\"\" U07 | forbidden command, should return 1 \"\"\"\n        args = self.args + [\"--allowed=['ls']\"]\n        userconf = CheckConfig(args).returnconf()\n        INPUT = \"ll\"\n        return self.assertEqual(sec.check_secure(INPUT, userconf)[0], 1)\n\n    def test_08_checkpath_notallowed_path(self):\n        \"\"\" U08 | forbidden command, should return 1 \"\"\"\n        args = self.args + [\"--path=['/home', '/var']\"]\n        userconf = CheckConfig(args).returnconf()\n        INPUT = \"cd /tmp\"\n        return self.assertEqual(sec.check_path(INPUT, userconf)[0], 1)\n\n    def test_09_checkpath_notallowed_path_completion(self):\n        \"\"\" U09 | forbidden command, should return 1 \"\"\"\n        args = self.args + [\"--path=['/home', '/var']\"]\n        userconf = CheckConfig(args).returnconf()\n        INPUT = \"cd /tmp/\"\n        return self.assertEqual(sec.check_path(INPUT,\n                                               userconf,\n                                               completion=1)[0], 1)\n\n    def test_10_checkpath_dollarparenthesis(self):\n        \"\"\" U10 | when $() is allowed, return 0 if path allowed \"\"\"\n        args = self.args + [\"--forbidden=[';', '&', '|','`','>','<', '${']\"]\n        userconf = CheckConfig(args).returnconf()\n        INPUT = \"echo $(echo aze)\"\n        return self.assertEqual(sec.check_path(INPUT, userconf)[0], 0)\n\n    def test_11_checkconfig_configoverwrite(self):\n        \"\"\" U12 | forbid ';', then check_secure should return 1 \"\"\"\n        args = ['--config=%s/etc/lshell.conf' % TOPDIR, '--strict=123']\n        userconf = CheckConfig(args).returnconf()\n        return self.assertEqual(userconf['strict'], 123)\n\n    def test_12_overssh(self):\n        \"\"\" U12 | command over ssh \"\"\"\n        args = self.args + [\"--overssh=['exit']\", '-c exit']\n        os.environ['SSH_CLIENT'] = '8.8.8.8 36000 22'\n        if 'SSH_TTY' in os.environ:\n            os.environ.pop('SSH_TTY')\n        with self.assertRaises(SystemExit) as cm:\n            CheckConfig(args).returnconf()\n        return self.assertEqual(cm.exception.code, 0)\n\n    def test_13_multiple_aliases_with_separator(self):\n        \"\"\" U13 | multiple aliases using &&, || and ; separators \"\"\"\n        # enable &, | and ; characters\n        aliases = {'foo': 'foo -l', 'bar': 'open'}\n        INPUT = \"foo; fooo  ;bar&&foo  &&   foo | bar||bar   ||     foo\"\n        return self.assertEqual(get_aliases(INPUT, aliases),\n                                ' foo -l; fooo  ; open&& foo -l  '\n                                '&& foo -l | open|| open   || foo -l')\n\n    def test_14_sudo_all_commands_expansion(self):\n        \"\"\" U14 | sudo_commands set to 'all' is equal to allowed variable \"\"\"\n        args = self.args + [\"--sudo_commands=all\"]\n        userconf = CheckConfig(args).returnconf()\n        # exclude internal and sudo(8) commands\n        exclude = builtins_list + ['sudo']\n        allowed = [x for x in userconf['allowed'] if x not in exclude]\n        # sort lists to compare\n        userconf['sudo_commands'].sort()\n        allowed.sort()\n        return self.assertEqual(allowed, userconf['sudo_commands'])\n\n    def test_15_allowed_ld_preload_cmd(self):\n        \"\"\" U15 | all allowed commands should be prepended with LD_PRELOAD \"\"\"\n        args = self.args + [\"--allowed=['echo','export']\"]\n        userconf = CheckConfig(args).returnconf()\n        # sort lists to compare\n        return self.assertEqual(userconf['aliases']['echo'],\n                                'LD_PRELOAD=%s echo' % userconf['path_noexec'])\n\n    def test_16_allowed_ld_preload_builtin(self):\n        \"\"\" U16 | builtin commands should NOT be prepended with LD_PRELOAD \"\"\"\n        args = self.args + [\"--allowed=['echo','export']\"]\n        userconf = CheckConfig(args).returnconf()\n        # verify that export is not automatically added to the aliases (i.e.\n        # prepended with LD_PRELOAD)\n        return self.assertNotIn('export', userconf['aliases'])\n\n    def test_17_allowed_exec_cmd(self):\n        \"\"\" U17 | allowed_shell_escape should NOT be prepended with LD_PRELOAD\n            The command should not be added to the aliases variable\n        \"\"\"\n        args = self.args + [\"--allowed_shell_escape=['echo']\"]\n        userconf = CheckConfig(args).returnconf()\n        # sort lists to compare\n        return self.assertNotIn('echo', userconf['aliases'])\n\n    def test_18_forbidden_environment(self):\n        \"\"\" U18 | unsafe environment are forbidden\n        \"\"\"\n        INPUT = 'export LD_PRELOAD=/lib64/ld-2.21.so'\n        args = INPUT\n        retcode = builtins.export(args)[0]\n        return self.assertEqual(retcode, 1)\n\n    def test_19_allowed_environment(self):\n        \"\"\" U19 | other environment are accepted\n        \"\"\"\n        INPUT = 'export MY_PROJECT_VERSION=43'\n        args = INPUT\n        retcode = builtins.export(args)[0]\n        return self.assertEqual(retcode, 0)\n\n    def test_20_winscp_allowed_commands(self):\n        \"\"\" U20 | when winscp is enabled, new allowed commands are automatically\n            added (see man).\n        \"\"\"\n        args = self.args + [\"--allowed=[]\", \"--winscp=1\"]\n        userconf = CheckConfig(args).returnconf()\n        # sort lists to compare, except 'export'\n        exclude = list(set(builtins_list) - set(['export']))\n        expected = exclude + ['scp', 'env', 'pwd', 'groups',\n                              'unset', 'unalias']\n        expected.sort()\n        allowed = userconf['allowed']\n        allowed.sort()\n        return self.assertEqual(allowed, expected)\n\n    def test_21_winscp_allowed_semicolon(self):\n        \"\"\" U21 | when winscp is enabled, use of semicolon is allowed \"\"\"\n        args = self.args + [\"--forbidden=[';']\", \"--winscp=1\"]\n        userconf = CheckConfig(args).returnconf()\n        # sort lists to compare\n        return self.assertNotIn(';', userconf['forbidden'])\n\n    def test_22_prompt_short_0(self):\n        \"\"\" U22 | short_prompt = 0 should show dir compared to home dir \"\"\"\n        expected = '%s:~/foo$ ' % getuser()\n        args = self.args + ['--prompt_short=0']\n        userconf = CheckConfig(args).returnconf()\n        currentpath = \"%s/foo\" % userconf['home_path']\n        prompt = updateprompt(currentpath, userconf)\n        # sort lists to compare\n        return self.assertEqual(prompt, expected)\n\n    def test_23_prompt_short_1(self):\n        \"\"\" U23 | short_prompt = 1 should show only current dir \"\"\"\n        expected = '%s: foo$ ' % getuser()\n        args = self.args + ['--prompt_short=1']\n        userconf = CheckConfig(args).returnconf()\n        currentpath = \"%s/foo\" % userconf['home_path']\n        prompt = updateprompt(currentpath, userconf)\n        # sort lists to compare\n        return self.assertEqual(prompt, expected)\n\n    def test_24_prompt_short_2(self):\n        \"\"\" U24 | short_prompt = 2 should show full dir path \"\"\"\n        expected = '%s: %s$ ' % (getuser(), os.getcwd())\n        args = self.args + ['--prompt_short=2']\n        userconf = CheckConfig(args).returnconf()\n        currentpath = \"%s/foo\" % userconf['home_path']\n        prompt = updateprompt(currentpath, userconf)\n        # sort lists to compare\n        return self.assertEqual(prompt, expected)\n\n    def test_25_disable_ld_preload(self):\n        \"\"\" U25 | empty path_noexec should disable LD_PRELOAD \"\"\"\n        args = self.args + [\"--allowed=['echo','export']\", \"--path_noexec=''\"]\n        userconf = CheckConfig(args).returnconf()\n        # verify that no alias was created containing LD_PRELOAD\n        return self.assertNotIn('echo', userconf['aliases'])\n\nif __name__ == \"__main__\":\n    unittest.main()\n"], "fixing_code": ["#\n#  Limited command Shell (lshell)\n#\n#  Copyright (C) 2008-2013 Ignace Mouzannar (ghantoos) <ghantoos@ghantoos.org>\n#\n#  This file is part of lshell\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport sys\nimport re\nimport os\n\n# import lshell specifics\nfrom lshell import utils\n\n\ndef warn_count(messagetype, command, conf, strict=None, ssh=None):\n    \"\"\" Update the warning_counter, log and display a warning to the user\n    \"\"\"\n\n    log = conf['logpath']\n    if not ssh:\n        if strict:\n            conf['warning_counter'] -= 1\n            if conf['warning_counter'] < 0:\n                log.critical('*** forbidden %s -> \"%s\"'\n                             % (messagetype, command))\n                log.critical('*** Kicked out')\n                sys.exit(1)\n            else:\n                log.critical('*** forbidden %s -> \"%s\"'\n                             % (messagetype, command))\n                sys.stderr.write('*** You have %s warning(s) left,'\n                                 ' before getting kicked out.\\n'\n                                 % conf['warning_counter'])\n                log.error('*** User warned, counter: %s'\n                          % conf['warning_counter'])\n                sys.stderr.write('This incident has been reported.\\n')\n        else:\n            if not conf['quiet']:\n                log.critical('*** forbidden %s: %s'\n                             % (messagetype, command))\n\n    # if you are here, means that you did something wrong. Return 1.\n    return 1, conf\n\n\ndef check_path(line, conf, completion=None, ssh=None, strict=None):\n    \"\"\" Check if a path is entered in the line. If so, it checks if user\n    are allowed to see this path. If user is not allowed, it calls\n    warn_count. In case of completion, it only returns 0 or 1.\n    \"\"\"\n    allowed_path_re = str(conf['path'][0])\n    denied_path_re = str(conf['path'][1][:-1])\n\n    # split line depending on the operators\n    sep = re.compile(r'\\ |;|\\||&')\n    line = line.strip()\n    line = sep.split(line)\n\n    for item in line:\n        # remove potential quotes or back-ticks\n        item = re.sub(r'^[\"\\'`]|[\"\\'`]$', '', item)\n\n        # remove potential $(), ${}, ``\n        item = re.sub(r'^\\$[\\(\\{]|[\\)\\}]$', '', item)\n\n        # if item has been converted to something other than a string\n        # or an int, reconvert it to a string\n        if type(item) not in ['str', 'int']:\n            item = str(item)\n        # replace \"~\" with home path\n        item = os.path.expanduser(item)\n\n        # expand shell wildcards using \"echo\"\n        # i know, this a bit nasty...\n        if re.findall('\\$|\\*|\\?', item):\n            # remove quotes if available\n            item = re.sub(\"\\\"|\\'\", \"\", item)\n            import subprocess\n            p = subprocess.Popen(\"`which echo` %s\" % item,\n                                 shell=True,\n                                 stdin=subprocess.PIPE,\n                                 stdout=subprocess.PIPE,\n                                 stderr=subprocess.PIPE)\n            cout = p.stdout\n\n            try:\n                item = cout.readlines()[0].decode('utf8').split(' ')[0]\n                item = item.strip()\n                item = os.path.expandvars(item)\n            except IndexError:\n                conf['logpath'].critical('*** Internal error: command not '\n                                         'executed')\n                return 1, conf\n\n        tomatch = os.path.realpath(item)\n        if os.path.isdir(tomatch) and tomatch[-1] != '/':\n            tomatch += '/'\n        match_allowed = re.findall(allowed_path_re, tomatch)\n        if denied_path_re:\n            match_denied = re.findall(denied_path_re, tomatch)\n        else:\n            match_denied = None\n\n        # if path not allowed\n        # case path executed: warn, and return 1\n        # case completion: return 1\n        if not match_allowed or match_denied:\n            if not completion:\n                ret, conf = warn_count('path',\n                                       tomatch,\n                                       conf,\n                                       strict=strict,\n                                       ssh=ssh)\n            return 1, conf\n\n    if not completion:\n        if not re.findall(allowed_path_re, os.getcwd() + '/'):\n            ret, conf = warn_count('path',\n                                   tomatch,\n                                   conf,\n                                   strict=strict,\n                                   ssh=ssh)\n            os.chdir(conf['home_path'])\n            conf['promptprint'] = utils.updateprompt(os.getcwd(),\n                                                     conf)\n            return 1, conf\n    return 0, conf\n\n\ndef check_secure(line, conf, strict=None, ssh=None):\n    \"\"\"This method is used to check the content on the typed command.\n    Its purpose is to forbid the user to user to override the lshell\n    command restrictions.\n    The forbidden characters are placed in the 'forbidden' variable.\n    Feel free to update the list. Emptying it would be quite useless..: )\n\n    A warning counter has been added, to kick out of lshell a user if he\n    is warned more than X time (X being the 'warning_counter' variable).\n    \"\"\"\n\n    # store original string\n    oline = line\n\n    # strip all spaces/tabs\n    line = line.strip()\n\n    # init return code\n    returncode = 0\n\n    # This logic is kept crudely simple on purpose.\n    # At most we might match the same stanza twice\n    # (for e.g. \"'a'\", 'a') but the converse would\n    # require detecting single quotation stanzas\n    # nested within double quotes and vice versa\n    relist = re.findall(r'[^=]\\\"(.+)\\\"', line)\n    relist2 = re.findall(r'[^=]\\'(.+)\\'', line)\n    relist = relist + relist2\n    for item in relist:\n        if os.path.exists(item):\n            ret_check_path, conf = check_path(item, conf, strict=strict)\n            returncode += ret_check_path\n\n    # parse command line for control characters, and warn user\n    if re.findall(r'[\\x01-\\x1F\\x7F]', oline):\n        ret, conf = warn_count('control char',\n                               oline,\n                               conf,\n                               strict=strict,\n                               ssh=ssh)\n        return ret, conf\n\n    for item in conf['forbidden']:\n        # allow '&&' and '||' even if singles are forbidden\n        if item in ['&', '|']:\n            if re.findall(\"[^\\%s]\\%s[^\\%s]\" % (item, item, item), line):\n                ret, conf = warn_count('syntax',\n                                       oline,\n                                       conf,\n                                       strict=strict,\n                                       ssh=ssh)\n                return ret, conf\n        else:\n            if item in line:\n                ret, conf = warn_count('syntax',\n                                       oline,\n                                       conf,\n                                       strict=strict,\n                                       ssh=ssh)\n                return ret, conf\n\n    # check if the line contains $(foo) executions, and check them\n    executions = re.findall('\\$\\([^)]+[)]', line)\n    for item in executions:\n        # recurse on check_path\n        ret_check_path, conf = check_path(item[2:-1].strip(),\n                                          conf,\n                                          strict=strict)\n        returncode += ret_check_path\n\n        # recurse on check_secure\n        ret_check_secure, conf = check_secure(item[2:-1].strip(),\n                                              conf,\n                                              strict=strict)\n        returncode += ret_check_secure\n\n    # check for executions using back quotes '`'\n    executions = re.findall('\\`[^`]+[`]', line)\n    for item in executions:\n        ret_check_secure, conf = check_secure(item[1:-1].strip(),\n                                              conf,\n                                              strict=strict)\n        returncode += ret_check_secure\n\n    # check if the line contains ${foo=bar}, and check them\n    curly = re.findall('\\$\\{[^}]+[}]', line)\n    for item in curly:\n        # split to get variable only, and remove last character \"}\"\n        if re.findall(r'=|\\+|\\?|\\-', item):\n            variable = re.split('=|\\+|\\?|\\-', item, 1)\n        else:\n            variable = item\n        ret_check_path, conf = check_path(variable[1][:-1],\n                                          conf,\n                                          strict=strict)\n        returncode += ret_check_path\n\n    # if unknown commands where found, return 1 and don't execute the line\n    if returncode > 0:\n        return 1, conf\n    # in case the $(foo) or `foo` command passed the above tests\n    elif line.startswith('$(') or line.startswith('`'):\n        return 0, conf\n\n    # in case ';', '|' or '&' are not forbidden, check if in line\n    lines = []\n\n    # corrected by Alojzij Blatnik #48\n    # test first character\n    if line[0] in [\"&\", \"|\", \";\"]:\n        start = 1\n    else:\n        start = 0\n\n    # split remaining command line\n    for i in range(1, len(line)):\n        # in case \\& or \\| or \\; don't split it\n        if line[i] in [\"&\", \"|\", \";\"] and line[i - 1] != \"\\\\\":\n            # if there is more && or || skip it\n            if start != i:\n                lines.append(line[start:i])\n            start = i + 1\n\n    # append remaining command line\n    if start != len(line):\n        lines.append(line[start:len(line)])\n\n    # remove trailing parenthesis\n    line = re.sub('\\)$', '', line)\n    for separate_line in lines:\n        separate_line = \" \".join(separate_line.split())\n        splitcmd = separate_line.strip().split(' ')\n        command = splitcmd[0]\n        if len(splitcmd) > 1:\n            cmdargs = splitcmd\n        else:\n            cmdargs = None\n\n        # in case of a sudo command, check in sudo_commands list if allowed\n        if command == 'sudo':\n            if type(cmdargs) == list:\n                # allow the -u (user) flag\n                if cmdargs[1] == '-u' and cmdargs:\n                    sudocmd = cmdargs[3]\n                else:\n                    sudocmd = cmdargs[1]\n                if sudocmd not in conf['sudo_commands'] and cmdargs:\n                    ret, conf = warn_count('sudo command',\n                                           oline,\n                                           conf,\n                                           strict=strict,\n                                           ssh=ssh)\n                    return ret, conf\n\n        # if over SSH, replaced allowed list with the one of overssh\n        if ssh:\n            conf['allowed'] = conf['overssh']\n\n        # for all other commands check in allowed list\n        if command not in conf['allowed'] and command:\n            ret, conf = warn_count('command',\n                                   command,\n                                   conf,\n                                   strict=strict,\n                                   ssh=ssh)\n            return ret, conf\n    return 0, conf\n", "import unittest\nimport pexpect\nimport os\nimport subprocess\nfrom getpass import getuser\n\n# import lshell specifics\nfrom lshell import utils\n\nTOPDIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))\n\n\nclass TestFunctions(unittest.TestCase):\n\n    user = getuser()\n\n    def setUp(self):\n        \"\"\" spawn lshell with pexpext and return the child \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf --strict 1'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n    def tearDown(self):\n        self.child.close()\n\n    def test_01_welcome_message(self):\n        \"\"\" F01 | lshell welcome message \"\"\"\n        expected = \"You are in a limited shell.\\r\\nType '?' or 'help' to get\" \\\n            \" the list of allowed commands\\r\\n\"\n        result = self.child.before.decode('utf8')\n        self.assertEqual(expected, result)\n\n    def test_02_builtin_ls_command(self):\n        \"\"\" F02 | built-in ls command \"\"\"\n        p = subprocess.Popen(\"ls ~\",\n                             shell=True,\n                             stdin=subprocess.PIPE,\n                             stdout=subprocess.PIPE)\n        cout = p.stdout\n        expected = cout.read(-1)\n        self.child.sendline('ls')\n        self.child.expect('%s:~\\$' % self.user)\n        output = self.child.before.decode('utf8').split('ls\\r', 1)[1]\n        self.assertEqual(len(expected.strip().split()),\n                         len(output.strip().split()))\n\n    def test_03_external_echo_command_num(self):\n        \"\"\" F03 | external echo number \"\"\"\n        expected = \"32\"\n        self.child.sendline('echo 32')\n        self.child.expect(\"%s:~\\$\" % self.user)\n        result = self.child.before.decode('utf8').split()[2]\n        self.assertEqual(expected, result)\n\n    def test_04_external_echo_command_string(self):\n        \"\"\" F04 | external echo random string \"\"\"\n        expected = \"bla blabla  32 blibli! plop.\"\n        self.child.sendline('echo \"%s\"' % expected)\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_05_external_echo_forbidden_syntax(self):\n        \"\"\" F05 | echo forbidden syntax $(bleh) \"\"\"\n        expected = \"*** forbidden syntax -> \\\"echo $(uptime)\\\"\\r\\n*** You \" \\\n            \"have 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('echo $(uptime)')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_06_builtin_cd_change_dir(self):\n        \"\"\" F06 | built-in cd - change directory \"\"\"\n        expected = \"\"\n        home = os.path.expanduser('~')\n        dirpath = None\n        for path in os.listdir(home):\n            dirpath = os.path.join(home, path)\n            if os.path.isdir(dirpath):\n                break\n        if dirpath:\n            self.child.sendline('cd %s' % path)\n            self.child.expect('%s:~/%s\\$' % (self.user, path))\n            self.child.sendline('cd ..')\n            self.child.expect('%s:~\\$' % self.user)\n            result = self.child.before.decode('utf8').split('\\n', 1)[1]\n            self.assertEqual(expected, result)\n\n    def test_07_builtin_cd_tilda(self):\n        \"\"\" F07 | built-in cd - tilda bug \"\"\"\n        expected = \"*** forbidden path -> \\\"/etc/passwd\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('ls ~/../../etc/passwd')\n        self.child.expect(\"%s:~\\$\" % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_08_builtin_cd_quotes(self):\n        \"\"\" F08 | built-in - quotes in cd \"/\" \"\"\"\n        expected = \"*** forbidden path -> \\\"/\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('ls -ld \"/\"')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_09_external_forbidden_path(self):\n        \"\"\" F09 | external command forbidden path - ls /root \"\"\"\n        expected = \"*** forbidden path -> \\\"/root/\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('ls ~root')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_10_builtin_cd_forbidden_path(self):\n        \"\"\" F10 | built-in command forbidden path - cd ~root \"\"\"\n        expected = \"*** forbidden path -> \\\"/root/\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('cd ~root')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_11_etc_passwd_1(self):\n        \"\"\" F11 | /etc/passwd: empty variable 'ls \"$a\"/etc/passwd' \"\"\"\n        expected = \"*** forbidden path -> \\\"/etc/passwd\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('ls \"$a\"/etc/passwd')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_12_etc_passwd_2(self):\n        \"\"\" F12 | /etc/passwd: empty variable 'ls -l .*./.*./etc/passwd' \"\"\"\n        expected = \"*** forbidden path -> \\\"/etc/passwd\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('ls -l .*./.*./etc/passwd')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_13_etc_passwd_3(self):\n        \"\"\" F13 | /etc/passwd: empty variable 'ls -l .?/.?/etc/passwd' \"\"\"\n        expected = \"*** forbidden path -> \\\"/etc/passwd\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('ls -l .?/.?/etc/passwd')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_14_path_completion_tilda(self):\n        \"\"\" F14 | path completion with ~/ \"\"\"\n        p = subprocess.Popen(\"ls -F ~/\",\n                             shell=True,\n                             stdin=subprocess.PIPE,\n                             stdout=subprocess.PIPE)\n        cout = p.stdout\n        expected = cout.read(-1)\n        self.child.sendline('cd ~/\\t\\t')\n        self.child.expect('%s:~\\$' % self.user)\n        output = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(len(expected.strip().split()),\n                         len(output.strip().split()))\n\n    def test_15_cmd_completion_tab_tab(self):\n        \"\"\" F15 | command completion: tab to list commands \"\"\"\n        expected = '\\x07\\r\\ncd       echo     help     ll       ls       '\\\n                   '\\r\\nclear    exit     history  lpath    lsudo'\n        self.child.sendline('\\t\\t')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').strip()\n\n        self.assertEqual(expected, result)\n\n    def test_16_exitcode_with_separator_external_cmd(self):\n        \"\"\" F16 | external command exit codes with separator \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--forbidden \"[]\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"2\"\n        self.child.sendline('ls nRVmmn8RGypVneYIp8HxyVAvaEaD55; echo $?')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[2].strip()\n        self.assertEqual(expected, result)\n\n    def test_17_exitcode_without_separator_external_cmd(self):\n        \"\"\" F17 | external command exit codes without separator \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--forbidden \"[]\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"2\"\n        self.child.sendline('ls nRVmmn8RGypVneYIp8HxyVAvaEaD55')\n        self.child.expect('%s:~\\$' % self.user)\n        self.child.sendline('echo $?')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_18_cd_exitcode_with_separator_internal_cmd(self):\n        \"\"\" F18 | built-in command exit codes with separator \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--forbidden \"[]\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"2\"\n        self.child.sendline('cd nRVmmn8RGypVneYIp8HxyVAvaEaD55; echo $?')\n        self.child.expect('%s:~\\$' % self.user)\n        self.child.sendline('echo $?')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_19_cd_exitcode_without_separator_external_cmd(self):\n        \"\"\" F19 | built-in exit codes without separator \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--forbidden \"[]\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"2\"\n        self.child.sendline('cd nRVmmn8RGypVneYIp8HxyVAvaEaD55')\n        self.child.expect('%s:~\\$' % self.user)\n        self.child.sendline('echo $?')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_20_cd_with_cmd_unknwon_dir(self):\n        \"\"\" F20 | test built-in cd with command when dir does not exist\n            Should be returning error, not executing cmd\n        \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--forbidden \"[]\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = 'lshell: nRVmmn8RGypVneYIp8HxyVAvaEaD55: No such file or '\\\n                   'directory'\n\n        self.child.sendline('cd nRVmmn8RGypVneYIp8HxyVAvaEaD55; echo $?')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_21_allow_slash(self):\n        \"\"\" F21 | user should able to allow / access minus some directory\n            (e.g. /var)\n        \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--path \"[\\'/\\'] - [\\'/var\\']\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"*** forbidden path: /var/\"\n        self.child.sendline('cd /')\n        self.child.expect('%s:/\\$' % self.user)\n        self.child.sendline('cd var')\n        self.child.expect('%s:/\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_22_expand_env_variables(self):\n        \"\"\" F22 | expanding of environment variables \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--allowed \"+ [\\'export\\']\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"%s/test\" % os.path.expanduser('~')\n        self.child.sendline('export A=test')\n        self.child.expect('%s:~\\$' % self.user)\n        self.child.sendline('echo $HOME/$A')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_23_expand_env_variables_cd(self):\n        \"\"\" F23 | expanding of environment variables when using cd \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--allowed \"+ [\\'export\\']\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        random = utils.random_string(32)\n\n        expected = 'lshell: %s/random_%s: No such file or directory' % (\n            os.path.expanduser('~'), random)\n        self.child.sendline('export A=random_%s' % random)\n        self.child.expect('%s:~\\$' % self.user)\n        self.child.sendline('cd $HOME/$A')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_24_cd_and_command(self):\n        \"\"\" F24 | cd && command should not be interpreted by internal function\n        \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"OK\"\n        self.child.sendline('cd ~ && echo \"OK\"')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_25_KeyboardInterrupt(self):\n        \"\"\" F25 | test cat(1) with KeyboardInterrupt, should not exit \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--allowed \"+ [\\'cat\\']\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        self.child.sendline('cat')\n        self.child.sendline(' foo ')\n        self.child.sendcontrol('c')\n        self.child.expect('%s:~\\$' % self.user)\n        try:\n            result = self.child.before.decode('utf8').split('\\n')[1].strip()\n            # both behaviors are correct\n            if result.startswith('foo'):\n                expected = 'foo'\n            elif result.startswith('^C'):\n                expected = '^C'\n        except IndexError:\n            # outputs u' ^C' on Debian\n            expected = u'^C'\n            result = self.child.before.decode('utf8').strip()\n        self.assertIn(expected, result)\n\n    def test_26_cmd_completion_dot_slash(self):\n        \"\"\" F26 | command completion: tab to list ./foo1 ./foo2 \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--allowed \"+ [\\'./foo1\\', \\'./foo2\\']\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = u'./\\x07foo\\x07\\r\\nfoo1  foo2'\n        self.child.sendline('./\\t\\t\\t')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').strip()\n\n        self.assertEqual(expected, result)\n\n    def test_27_checksecure_awk(self):\n        \"\"\" F27 | checksecure awk script with /bin/bash \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--allowed \"+ [\\'awk\\']\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = u'*** forbidden path: /bin/bash'\n        self.child.sendline('awk \\'BEGIN {system(\"/bin/bash\")}\\'')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n\n        self.assertEqual(expected, result)\n\n    def test_28_catch_terminal_ctrl_j(self):\n        \"\"\" F28 | test ctrl-v ctrl-j then command, forbidden/security \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = u'*** forbidden control char: echo\\r'\n        self.child.send('echo')\n        self.child.sendcontrol('v')\n        self.child.sendcontrol('j')\n        self.child.sendline('bash')\n        self.child.expect('%s:~\\$' % self.user)\n\n        result = self.child.before.decode('utf8').split('\\n')\n\n        self.assertIn(expected, result)\n\n    def test_29_catch_terminal_ctrl_k(self):\n        \"\"\" F29 | test ctrl-v ctrl-k then command, forbidden/security \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = u'*** forbidden control char: echo\\x0b() bash && echo\\r'\n        self.child.send('echo')\n        self.child.sendcontrol('v')\n        self.child.sendcontrol('k')\n        self.child.sendline('() bash && echo')\n        self.child.expect('%s:~\\$' % self.user)\n\n        result = self.child.before.decode('utf8').split('\\n')[1]\n\n        self.assertIn(expected, result)\n\nif __name__ == '__main__':\n    unittest.main()\n", "import unittest\nimport os\nfrom getpass import getuser\n\n# import lshell specifics\nfrom lshell.shellcmd import ShellCmd\nfrom lshell.checkconfig import CheckConfig\nfrom lshell.utils import get_aliases, updateprompt\nfrom lshell.variables import builtins_list\nfrom lshell import builtins\nfrom lshell import sec\n\nTOPDIR = '%s/../' % os.path.dirname(os.path.realpath(__file__))\n\n\nclass TestFunctions(unittest.TestCase):\n    args = ['--config=%s/etc/lshell.conf' % TOPDIR, \"--quiet=1\"]\n    userconf = CheckConfig(args).returnconf()\n    shell = ShellCmd(userconf, args)\n\n    def test_03_checksecure_doublepipe(self):\n        \"\"\" U03 | double pipes should be allowed, even if pipe is forbidden \"\"\"\n        args = self.args + [\"--forbidden=['|']\"]\n        userconf = CheckConfig(args).returnconf()\n        INPUT = \"ls || ls\"\n        return self.assertEqual(sec.check_secure(INPUT, userconf)[0], 0)\n\n    def test_04_checksecure_forbiddenpipe(self):\n        \"\"\" U04 | forbid pipe, should return 1 \"\"\"\n        args = self.args + [\"--forbidden=['|']\"]\n        userconf = CheckConfig(args).returnconf()\n        INPUT = \"ls | ls\"\n        return self.assertEqual(sec.check_secure(INPUT, userconf)[0], 1)\n\n    def test_05_checksecure_forbiddenchar(self):\n        \"\"\" U05 | forbid character, should return 1 \"\"\"\n        args = self.args + [\"--forbidden=['l']\"]\n        userconf = CheckConfig(args).returnconf()\n        INPUT = \"ls\"\n        return self.assertEqual(sec.check_secure(INPUT, userconf)[0], 1)\n\n    def test_06_checksecure_sudo_command(self):\n        \"\"\" U06 | quoted text should not be forbidden \"\"\"\n        INPUT = \"sudo ls\"\n        return self.assertEqual(sec.check_secure(INPUT, self.userconf)[0], 1)\n\n    def test_07_checksecure_notallowed_command(self):\n        \"\"\" U07 | forbidden command, should return 1 \"\"\"\n        args = self.args + [\"--allowed=['ls']\"]\n        userconf = CheckConfig(args).returnconf()\n        INPUT = \"ll\"\n        return self.assertEqual(sec.check_secure(INPUT, userconf)[0], 1)\n\n    def test_08_checkpath_notallowed_path(self):\n        \"\"\" U08 | forbidden command, should return 1 \"\"\"\n        args = self.args + [\"--path=['/home', '/var']\"]\n        userconf = CheckConfig(args).returnconf()\n        INPUT = \"cd /tmp\"\n        return self.assertEqual(sec.check_path(INPUT, userconf)[0], 1)\n\n    def test_09_checkpath_notallowed_path_completion(self):\n        \"\"\" U09 | forbidden command, should return 1 \"\"\"\n        args = self.args + [\"--path=['/home', '/var']\"]\n        userconf = CheckConfig(args).returnconf()\n        INPUT = \"cd /tmp/\"\n        return self.assertEqual(sec.check_path(INPUT,\n                                               userconf,\n                                               completion=1)[0], 1)\n\n    def test_10_checkpath_dollarparenthesis(self):\n        \"\"\" U10 | when $() is allowed, return 0 if path allowed \"\"\"\n        args = self.args + [\"--forbidden=[';', '&', '|','`','>','<', '${']\"]\n        userconf = CheckConfig(args).returnconf()\n        INPUT = \"echo $(echo aze)\"\n        return self.assertEqual(sec.check_path(INPUT, userconf)[0], 0)\n\n    def test_11_checkconfig_configoverwrite(self):\n        \"\"\" U12 | forbid ';', then check_secure should return 1 \"\"\"\n        args = ['--config=%s/etc/lshell.conf' % TOPDIR, '--strict=123']\n        userconf = CheckConfig(args).returnconf()\n        return self.assertEqual(userconf['strict'], 123)\n\n    def test_12_overssh(self):\n        \"\"\" U12 | command over ssh \"\"\"\n        args = self.args + [\"--overssh=['exit']\", '-c exit']\n        os.environ['SSH_CLIENT'] = '8.8.8.8 36000 22'\n        if 'SSH_TTY' in os.environ:\n            os.environ.pop('SSH_TTY')\n        with self.assertRaises(SystemExit) as cm:\n            CheckConfig(args).returnconf()\n        return self.assertEqual(cm.exception.code, 0)\n\n    def test_13_multiple_aliases_with_separator(self):\n        \"\"\" U13 | multiple aliases using &&, || and ; separators \"\"\"\n        # enable &, | and ; characters\n        aliases = {'foo': 'foo -l', 'bar': 'open'}\n        INPUT = \"foo; fooo  ;bar&&foo  &&   foo | bar||bar   ||     foo\"\n        return self.assertEqual(get_aliases(INPUT, aliases),\n                                ' foo -l; fooo  ; open&& foo -l  '\n                                '&& foo -l | open|| open   || foo -l')\n\n    def test_14_sudo_all_commands_expansion(self):\n        \"\"\" U14 | sudo_commands set to 'all' is equal to allowed variable \"\"\"\n        args = self.args + [\"--sudo_commands=all\"]\n        userconf = CheckConfig(args).returnconf()\n        # exclude internal and sudo(8) commands\n        exclude = builtins_list + ['sudo']\n        allowed = [x for x in userconf['allowed'] if x not in exclude]\n        # sort lists to compare\n        userconf['sudo_commands'].sort()\n        allowed.sort()\n        return self.assertEqual(allowed, userconf['sudo_commands'])\n\n    def test_15_allowed_ld_preload_cmd(self):\n        \"\"\" U15 | all allowed commands should be prepended with LD_PRELOAD \"\"\"\n        args = self.args + [\"--allowed=['echo','export']\"]\n        userconf = CheckConfig(args).returnconf()\n        # sort lists to compare\n        return self.assertEqual(userconf['aliases']['echo'],\n                                'LD_PRELOAD=%s echo' % userconf['path_noexec'])\n\n    def test_16_allowed_ld_preload_builtin(self):\n        \"\"\" U16 | builtin commands should NOT be prepended with LD_PRELOAD \"\"\"\n        args = self.args + [\"--allowed=['echo','export']\"]\n        userconf = CheckConfig(args).returnconf()\n        # verify that export is not automatically added to the aliases (i.e.\n        # prepended with LD_PRELOAD)\n        return self.assertNotIn('export', userconf['aliases'])\n\n    def test_17_allowed_exec_cmd(self):\n        \"\"\" U17 | allowed_shell_escape should NOT be prepended with LD_PRELOAD\n            The command should not be added to the aliases variable\n        \"\"\"\n        args = self.args + [\"--allowed_shell_escape=['echo']\"]\n        userconf = CheckConfig(args).returnconf()\n        # sort lists to compare\n        return self.assertNotIn('echo', userconf['aliases'])\n\n    def test_18_forbidden_environment(self):\n        \"\"\" U18 | unsafe environment are forbidden\n        \"\"\"\n        INPUT = 'export LD_PRELOAD=/lib64/ld-2.21.so'\n        args = INPUT\n        retcode = builtins.export(args)[0]\n        return self.assertEqual(retcode, 1)\n\n    def test_19_allowed_environment(self):\n        \"\"\" U19 | other environment are accepted\n        \"\"\"\n        INPUT = 'export MY_PROJECT_VERSION=43'\n        args = INPUT\n        retcode = builtins.export(args)[0]\n        return self.assertEqual(retcode, 0)\n\n    def test_20_winscp_allowed_commands(self):\n        \"\"\" U20 | when winscp is enabled, new allowed commands are automatically\n            added (see man).\n        \"\"\"\n        args = self.args + [\"--allowed=[]\", \"--winscp=1\"]\n        userconf = CheckConfig(args).returnconf()\n        # sort lists to compare, except 'export'\n        exclude = list(set(builtins_list) - set(['export']))\n        expected = exclude + ['scp', 'env', 'pwd', 'groups',\n                              'unset', 'unalias']\n        expected.sort()\n        allowed = userconf['allowed']\n        allowed.sort()\n        return self.assertEqual(allowed, expected)\n\n    def test_21_winscp_allowed_semicolon(self):\n        \"\"\" U21 | when winscp is enabled, use of semicolon is allowed \"\"\"\n        args = self.args + [\"--forbidden=[';']\", \"--winscp=1\"]\n        userconf = CheckConfig(args).returnconf()\n        # sort lists to compare\n        return self.assertNotIn(';', userconf['forbidden'])\n\n    def test_22_prompt_short_0(self):\n        \"\"\" U22 | short_prompt = 0 should show dir compared to home dir \"\"\"\n        expected = '%s:~/foo$ ' % getuser()\n        args = self.args + ['--prompt_short=0']\n        userconf = CheckConfig(args).returnconf()\n        currentpath = \"%s/foo\" % userconf['home_path']\n        prompt = updateprompt(currentpath, userconf)\n        # sort lists to compare\n        return self.assertEqual(prompt, expected)\n\n    def test_23_prompt_short_1(self):\n        \"\"\" U23 | short_prompt = 1 should show only current dir \"\"\"\n        expected = '%s: foo$ ' % getuser()\n        args = self.args + ['--prompt_short=1']\n        userconf = CheckConfig(args).returnconf()\n        currentpath = \"%s/foo\" % userconf['home_path']\n        prompt = updateprompt(currentpath, userconf)\n        # sort lists to compare\n        return self.assertEqual(prompt, expected)\n\n    def test_24_prompt_short_2(self):\n        \"\"\" U24 | short_prompt = 2 should show full dir path \"\"\"\n        expected = '%s: %s$ ' % (getuser(), os.getcwd())\n        args = self.args + ['--prompt_short=2']\n        userconf = CheckConfig(args).returnconf()\n        currentpath = \"%s/foo\" % userconf['home_path']\n        prompt = updateprompt(currentpath, userconf)\n        # sort lists to compare\n        return self.assertEqual(prompt, expected)\n\n    def test_25_disable_ld_preload(self):\n        \"\"\" U25 | empty path_noexec should disable LD_PRELOAD \"\"\"\n        args = self.args + [\"--allowed=['echo','export']\", \"--path_noexec=''\"]\n        userconf = CheckConfig(args).returnconf()\n        # verify that no alias was created containing LD_PRELOAD\n        return self.assertNotIn('echo', userconf['aliases'])\n\n    def test_26_checksecure_quoted_command(self):\n        \"\"\" U26 | quoted command should be parsed \"\"\"\n        INPUT = 'echo 1 && \"bash\"'\n        return self.assertEqual(sec.check_secure(INPUT, self.userconf)[0], 1)\n\n    def test_27_checksecure_quoted_command(self):\n        \"\"\" U27 | quoted command should be parsed \"\"\"\n        INPUT = '\"bash\" && echo 1'\n        return self.assertEqual(sec.check_secure(INPUT, self.userconf)[0], 1)\n\n    def test_28_checksecure_quoted_command(self):\n        \"\"\" U28 | quoted command should be parsed \"\"\"\n        INPUT = \"echo'/1.sh'\"\n        return self.assertEqual(sec.check_secure(INPUT, self.userconf)[0], 1)\n\nif __name__ == \"__main__\":\n    unittest.main()\n"], "filenames": ["lshell/sec.py", "test/test_functional.py", "test/test_unit.py"], "buggy_code_start_loc": [177, 387, 20], "buggy_code_end_loc": [183, 404, 223], "fixing_code_start_loc": [177, 387, 19], "fixing_code_end_loc": [180, 423, 229], "type": "CWE-264", "message": "lshell 0.9.16 allows remote authenticated users to break out of a limited shell and execute arbitrary commands.", "other": {"cve": {"id": "CVE-2016-6902", "sourceIdentifier": "security@debian.org", "published": "2017-04-24T19:59:00.330", "lastModified": "2017-04-27T19:14:02.577", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "lshell 0.9.16 allows remote authenticated users to break out of a limited shell and execute arbitrary commands."}, {"lang": "es", "value": "Ishell 0.9.16 permite a usuarios remotos autenticados salir de un shell limitado y ejecutar comandos arbitrarios."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.9, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.0}, "baseSeverity": "HIGH", "exploitabilityScore": 8.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lshell_project:lshell:0.9.16:*:*:*:*:*:*:*", "matchCriteriaId": "6EF0F461-1D41-493E-8F35-66E153E5CCCD"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/08/22/17", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/92591", "source": "security@debian.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=834949", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1369345", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/ghantoos/lshell/commit/a686f71732a3d0f16df52ef46ab8a49ee0083c68", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ghantoos/lshell/issues/147", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ghantoos/lshell/commit/a686f71732a3d0f16df52ef46ab8a49ee0083c68"}}