{"buggy_code": ["/*\n   Copyright (c) 2005, 2010, Oracle and/or its affiliates.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n#define MYSQL_LEX 1\n#include <my_global.h>                          /* NO_EMBEDDED_ACCESS_CHECKS */\n#include \"sql_priv.h\"\n#include \"unireg.h\"\n#include \"sql_parse.h\"                          // parse_sql\n#include \"strfunc.h\"                           // find_string_in_array\n#include \"sql_db.h\"                        // get_default_db_collation\n#include \"sql_time.h\"                      // interval_type_to_name,\n                                           // date_add_interval,\n                                           // calc_time_diff\n#include \"tztime.h\"     // my_tz_find, my_tz_OFFSET0, struct Time_zone\n#include \"sql_acl.h\"    // EVENT_ACL, SUPER_ACL\n#include \"sp.h\"         // load_charset, load_collation\n#include \"events.h\"\n#include \"event_data_objects.h\"\n#include \"event_db_repository.h\"\n#include \"sp_head.h\"\n#include \"sql_show.h\"                // append_definer, append_identifier\n\n/**\n  @addtogroup Event_Scheduler\n  @{\n*/\n\n/*************************************************************************/\n\n/**\n  Event_creation_ctx -- creation context of events.\n*/\n\nclass Event_creation_ctx :public Stored_program_creation_ctx,\n                          public Sql_alloc\n{\npublic:\n  static bool load_from_db(THD *thd,\n                           MEM_ROOT *event_mem_root,\n                           const char *db_name,\n                           const char *event_name,\n                           TABLE *event_tbl,\n                           Stored_program_creation_ctx **ctx);\n\npublic:\n  virtual Stored_program_creation_ctx *clone(MEM_ROOT *mem_root)\n  {\n    return new (mem_root)\n               Event_creation_ctx(m_client_cs, m_connection_cl, m_db_cl);\n  }\n\nprotected:\n  virtual Object_creation_ctx *create_backup_ctx(THD *thd) const\n  {\n    /*\n      We can avoid usual backup/restore employed in stored programs since we\n      know that this is a top level statement and the worker thread is\n      allocated exclusively to execute this event.\n    */\n\n    return NULL;\n  }\n\nprivate:\n  Event_creation_ctx(CHARSET_INFO *client_cs,\n                     CHARSET_INFO *connection_cl,\n                     CHARSET_INFO *db_cl)\n    : Stored_program_creation_ctx(client_cs, connection_cl, db_cl)\n  { }\n};\n\n/**************************************************************************\n  Event_creation_ctx implementation.\n**************************************************************************/\n\nbool\nEvent_creation_ctx::load_from_db(THD *thd,\n                                 MEM_ROOT *event_mem_root,\n                                 const char *db_name,\n                                 const char *event_name,\n                                 TABLE *event_tbl,\n                                 Stored_program_creation_ctx **ctx)\n{\n  /* Load character set/collation attributes. */\n\n  CHARSET_INFO *client_cs;\n  CHARSET_INFO *connection_cl;\n  CHARSET_INFO *db_cl;\n\n  bool invalid_creation_ctx= FALSE;\n\n  if (load_charset(event_mem_root,\n                   event_tbl->field[ET_FIELD_CHARACTER_SET_CLIENT],\n                   thd->variables.character_set_client,\n                   &client_cs))\n  {\n    sql_print_warning(\"Event '%s'.'%s': invalid value \"\n                      \"in column mysql.event.character_set_client.\",\n                      (const char *) db_name,\n                      (const char *) event_name);\n\n    invalid_creation_ctx= TRUE;\n  }\n\n  if (load_collation(event_mem_root,\n                     event_tbl->field[ET_FIELD_COLLATION_CONNECTION],\n                     thd->variables.collation_connection,\n                     &connection_cl))\n  {\n    sql_print_warning(\"Event '%s'.'%s': invalid value \"\n                      \"in column mysql.event.collation_connection.\",\n                      (const char *) db_name,\n                      (const char *) event_name);\n\n    invalid_creation_ctx= TRUE;\n  }\n\n  if (load_collation(event_mem_root,\n                     event_tbl->field[ET_FIELD_DB_COLLATION],\n                     NULL,\n                     &db_cl))\n  {\n    sql_print_warning(\"Event '%s'.'%s': invalid value \"\n                      \"in column mysql.event.db_collation.\",\n                      (const char *) db_name,\n                      (const char *) event_name);\n\n    invalid_creation_ctx= TRUE;\n  }\n\n  /*\n    If we failed to resolve the database collation, load the default one\n    from the disk.\n  */\n\n  if (!db_cl)\n    db_cl= get_default_db_collation(thd, db_name);\n\n  /* Create the context. */\n\n  *ctx= new Event_creation_ctx(client_cs, connection_cl, db_cl);\n\n  return invalid_creation_ctx;\n}\n\n/*************************************************************************/\n\n/*\n  Initiliazes dbname and name of an Event_queue_element_for_exec\n  object\n\n  SYNOPSIS\n    Event_queue_element_for_exec::init()\n\n  RETURN VALUE\n    FALSE  OK\n    TRUE   Error (OOM)\n*/\n\nbool\nEvent_queue_element_for_exec::init(LEX_STRING db, LEX_STRING n)\n{\n  if (!(dbname.str= my_strndup(db.str, dbname.length= db.length, MYF(MY_WME))))\n    return TRUE;\n  if (!(name.str= my_strndup(n.str, name.length= n.length, MYF(MY_WME))))\n  {\n    my_free(dbname.str);\n    return TRUE;\n  }\n  return FALSE;\n}\n\n\n/*\n  Destructor\n\n  SYNOPSIS\n    Event_queue_element_for_exec::~Event_queue_element_for_exec()\n*/\n\nEvent_queue_element_for_exec::~Event_queue_element_for_exec()\n{\n  my_free(dbname.str);\n  my_free(name.str);\n}\n\n\n/*\n  Constructor\n\n  SYNOPSIS\n    Event_basic::Event_basic()\n*/\n\nEvent_basic::Event_basic()\n{\n  DBUG_ENTER(\"Event_basic::Event_basic\");\n  /* init memory root */\n  init_sql_alloc(&mem_root, 256, 512, MYF(0));\n  dbname.str= name.str= NULL;\n  dbname.length= name.length= 0;\n  time_zone= NULL;\n  DBUG_VOID_RETURN;\n}\n\n\n/*\n  Destructor\n\n  SYNOPSIS\n    Event_basic::Event_basic()\n*/\n\nEvent_basic::~Event_basic()\n{\n  DBUG_ENTER(\"Event_basic::~Event_basic\");\n  free_root(&mem_root, MYF(0));\n  DBUG_VOID_RETURN;\n}\n\n\n/*\n  Short function to load a char column into a LEX_STRING\n\n  SYNOPSIS\n    Event_basic::load_string_field()\n      field_name  The field( enum_events_table_field is not actually used\n                  because it's unknown in event_data_objects.h)\n      fields      The Field array\n      field_value The value\n*/\n\nbool\nEvent_basic::load_string_fields(Field **fields, ...)\n{\n  bool ret= FALSE;\n  va_list args;\n  enum enum_events_table_field field_name;\n  LEX_STRING *field_value;\n\n  DBUG_ENTER(\"Event_basic::load_string_fields\");\n\n  va_start(args, fields);\n  field_name= (enum enum_events_table_field) va_arg(args, int);\n  while (field_name < ET_FIELD_COUNT)\n  {\n    field_value= va_arg(args, LEX_STRING *);\n    if ((field_value->str= get_field(&mem_root, fields[field_name])) == NullS)\n    {\n      ret= TRUE;\n      break;\n    }\n    field_value->length= strlen(field_value->str);\n\n    field_name= (enum enum_events_table_field) va_arg(args, int);\n  }\n  va_end(args);\n\n  DBUG_RETURN(ret);\n}\n\n\nbool\nEvent_basic::load_time_zone(THD *thd, const LEX_STRING tz_name)\n{\n  String str(tz_name.str, &my_charset_latin1);\n  time_zone= my_tz_find(thd, &str);\n\n  return (time_zone == NULL);\n}\n\n\n/*\n  Constructor\n\n  SYNOPSIS\n    Event_queue_element::Event_queue_element()\n*/\n\nEvent_queue_element::Event_queue_element():\n  on_completion(Event_parse_data::ON_COMPLETION_DROP),\n  status(Event_parse_data::ENABLED), expression(0), dropped(FALSE),\n  execution_count(0)\n{\n  DBUG_ENTER(\"Event_queue_element::Event_queue_element\");\n\n  starts= ends= execute_at= last_executed= 0;\n  starts_null= ends_null= execute_at_null= TRUE;\n\n  DBUG_VOID_RETURN;\n}\n\n\n/*\n  Destructor\n\n  SYNOPSIS\n    Event_queue_element::Event_queue_element()\n*/\nEvent_queue_element::~Event_queue_element()\n{\n}\n\n\n/*\n  Constructor\n\n  SYNOPSIS\n    Event_timed::Event_timed()\n*/\n\nEvent_timed::Event_timed():\n  created(0), modified(0), sql_mode(0)\n{\n  DBUG_ENTER(\"Event_timed::Event_timed\");\n  init();\n  DBUG_VOID_RETURN;\n}\n\n\n/*\n  Destructor\n\n  SYNOPSIS\n    Event_timed::~Event_timed()\n*/\n\nEvent_timed::~Event_timed()\n{\n}\n\n\n/*\n  Constructor\n\n  SYNOPSIS\n    Event_job_data::Event_job_data()\n*/\n\nEvent_job_data::Event_job_data()\n  :sql_mode(0)\n{\n}\n\n/*\n  Init all member variables\n\n  SYNOPSIS\n    Event_timed::init()\n*/\n\nvoid\nEvent_timed::init()\n{\n  DBUG_ENTER(\"Event_timed::init\");\n\n  definer_user.str= definer_host.str= body.str= comment.str= NULL;\n  definer_user.length= definer_host.length= body.length= comment.length= 0;\n\n  sql_mode= 0;\n\n  DBUG_VOID_RETURN;\n}\n\n\n/**\n  Load an event's body from a row from mysql.event.\n\n  @details This method is silent on errors and should behave like that.\n  Callers should handle throwing of error messages. The reason is that the\n  class should not know about how to deal with communication.\n\n  @return Operation status\n    @retval FALSE OK\n    @retval TRUE  Error\n*/\n\nbool\nEvent_job_data::load_from_row(THD *thd, TABLE *table)\n{\n  char *ptr;\n  size_t len;\n  LEX_STRING tz_name;\n\n  DBUG_ENTER(\"Event_job_data::load_from_row\");\n\n  if (!table)\n    DBUG_RETURN(TRUE);\n\n  if (table->s->fields < ET_FIELD_COUNT)\n    DBUG_RETURN(TRUE);\n\n  if (load_string_fields(table->field,\n                         ET_FIELD_DB, &dbname,\n                         ET_FIELD_NAME, &name,\n                         ET_FIELD_BODY, &body,\n                         ET_FIELD_DEFINER, &definer,\n                         ET_FIELD_TIME_ZONE, &tz_name,\n                         ET_FIELD_COUNT))\n    DBUG_RETURN(TRUE);\n\n  if (load_time_zone(thd, tz_name))\n    DBUG_RETURN(TRUE);\n\n  Event_creation_ctx::load_from_db(thd, &mem_root, dbname.str, name.str, table,\n                                   &creation_ctx);\n\n  ptr= strchr(definer.str, '@');\n\n  if (! ptr)\n    ptr= definer.str;\n\n  len= ptr - definer.str;\n  definer_user.str= strmake_root(&mem_root, definer.str, len);\n  definer_user.length= len;\n  len= definer.length - len - 1;\n  /* 1:because of @ */\n  definer_host.str= strmake_root(&mem_root, ptr + 1, len);\n  definer_host.length= len;\n\n  sql_mode= (ulong) table->field[ET_FIELD_SQL_MODE]->val_int();\n\n  DBUG_RETURN(FALSE);\n}\n\n\n/**\n  Load an event's body from a row from mysql.event.\n\n  @details This method is silent on errors and should behave like that.\n  Callers should handle throwing of error messages. The reason is that the\n  class should not know about how to deal with communication.\n\n  @return Operation status\n    @retval FALSE OK\n    @retval TRUE  Error\n*/\n\nbool\nEvent_queue_element::load_from_row(THD *thd, TABLE *table)\n{\n  char *ptr;\n  MYSQL_TIME time;\n  LEX_STRING tz_name;\n\n  DBUG_ENTER(\"Event_queue_element::load_from_row\");\n\n  if (!table)\n    DBUG_RETURN(TRUE);\n\n  if (table->s->fields < ET_FIELD_COUNT)\n    DBUG_RETURN(TRUE);\n\n  if (load_string_fields(table->field,\n                         ET_FIELD_DB, &dbname,\n                         ET_FIELD_NAME, &name,\n                         ET_FIELD_DEFINER, &definer,\n                         ET_FIELD_TIME_ZONE, &tz_name,\n                         ET_FIELD_COUNT))\n    DBUG_RETURN(TRUE);\n\n  if (load_time_zone(thd, tz_name))\n    DBUG_RETURN(TRUE);\n\n  starts_null= table->field[ET_FIELD_STARTS]->is_null();\n  uint not_used;\n  if (!starts_null)\n  {\n    table->field[ET_FIELD_STARTS]->get_date(&time, TIME_NO_ZERO_DATE);\n    starts= my_tz_OFFSET0->TIME_to_gmt_sec(&time,&not_used);\n  }\n\n  ends_null= table->field[ET_FIELD_ENDS]->is_null();\n  if (!ends_null)\n  {\n    table->field[ET_FIELD_ENDS]->get_date(&time, TIME_NO_ZERO_DATE);\n    ends= my_tz_OFFSET0->TIME_to_gmt_sec(&time,&not_used);\n  }\n\n  if (!table->field[ET_FIELD_INTERVAL_EXPR]->is_null())\n    expression= table->field[ET_FIELD_INTERVAL_EXPR]->val_int();\n  else\n    expression= 0;\n  /*\n    If neigher STARTS and ENDS is set, then both fields are empty.\n    Hence, if ET_FIELD_EXECUTE_AT is empty there is an error.\n  */\n  execute_at_null= table->field[ET_FIELD_EXECUTE_AT]->is_null();\n  DBUG_ASSERT(!(starts_null && ends_null && !expression && execute_at_null));\n  if (!expression && !execute_at_null)\n  {\n    if (table->field[ET_FIELD_EXECUTE_AT]->get_date(&time,\n                                                    TIME_NO_ZERO_DATE))\n      DBUG_RETURN(TRUE);\n    execute_at= my_tz_OFFSET0->TIME_to_gmt_sec(&time,&not_used);\n  }\n\n  /*\n    We load the interval type from disk as string and then map it to\n    an integer. This decouples the values of enum interval_type\n    and values actually stored on disk. Therefore the type can be\n    reordered without risking incompatibilities of data between versions.\n  */\n  if (!table->field[ET_FIELD_TRANSIENT_INTERVAL]->is_null())\n  {\n    int i;\n    char buff[MAX_FIELD_WIDTH];\n    String str(buff, sizeof(buff), &my_charset_bin);\n    LEX_STRING tmp;\n\n    table->field[ET_FIELD_TRANSIENT_INTERVAL]->val_str(&str);\n    if (!(tmp.length= str.length()))\n      DBUG_RETURN(TRUE);\n\n    tmp.str= str.c_ptr_safe();\n\n    i= find_string_in_array(interval_type_to_name, &tmp, system_charset_info);\n    if (i < 0)\n      DBUG_RETURN(TRUE);\n    interval= (interval_type) i;\n  }\n\n  if (!table->field[ET_FIELD_LAST_EXECUTED]->is_null())\n  {\n    table->field[ET_FIELD_LAST_EXECUTED]->get_date(&time,\n                                                   TIME_NO_ZERO_DATE);\n    last_executed= my_tz_OFFSET0->TIME_to_gmt_sec(&time,&not_used);\n  }\n\n  if ((ptr= get_field(&mem_root, table->field[ET_FIELD_STATUS])) == NullS)\n    DBUG_RETURN(TRUE);\n\n  DBUG_PRINT(\"load_from_row\", (\"Event [%s] is [%s]\", name.str, ptr));\n\n  /* Set event status (ENABLED | SLAVESIDE_DISABLED | DISABLED) */\n  switch (ptr[0])\n  {\n  case 'E' :\n    status = Event_parse_data::ENABLED;\n    break;\n  case 'S' :\n    status = Event_parse_data::SLAVESIDE_DISABLED;\n    break;\n  case 'D' :\n  default:\n    status = Event_parse_data::DISABLED;\n    break;\n  }\n  if ((ptr= get_field(&mem_root, table->field[ET_FIELD_ORIGINATOR])) == NullS)\n    DBUG_RETURN(TRUE);\n  originator = (uint32) table->field[ET_FIELD_ORIGINATOR]->val_int(); \n\n  /* ToDo : Andrey . Find a way not to allocate ptr on event_mem_root */\n  if ((ptr= get_field(&mem_root,\n                      table->field[ET_FIELD_ON_COMPLETION])) == NullS)\n    DBUG_RETURN(TRUE);\n\n  on_completion= (ptr[0]=='D'? Event_parse_data::ON_COMPLETION_DROP:\n                               Event_parse_data::ON_COMPLETION_PRESERVE);\n\n  DBUG_RETURN(FALSE);\n}\n\n\n/**\n  Load an event's body from a row from mysql.event.\n\n  @details This method is silent on errors and should behave like that.\n  Callers should handle throwing of error messages. The reason is that the\n  class should not know about how to deal with communication.\n\n  @return Operation status\n    @retval FALSE OK\n    @retval TRUE  Error\n*/\n\nbool\nEvent_timed::load_from_row(THD *thd, TABLE *table)\n{\n  char *ptr;\n  size_t len;\n\n  DBUG_ENTER(\"Event_timed::load_from_row\");\n\n  if (Event_queue_element::load_from_row(thd, table))\n    DBUG_RETURN(TRUE);\n\n  if (load_string_fields(table->field,\n                         ET_FIELD_BODY, &body,\n                         ET_FIELD_BODY_UTF8, &body_utf8,\n                         ET_FIELD_COUNT))\n    DBUG_RETURN(TRUE);\n\n  if (Event_creation_ctx::load_from_db(thd, &mem_root, dbname.str, name.str,\n                                       table, &creation_ctx))\n  {\n    push_warning_printf(thd,\n                        Sql_condition::WARN_LEVEL_WARN,\n                        ER_EVENT_INVALID_CREATION_CTX,\n                        ER_THD(thd, ER_EVENT_INVALID_CREATION_CTX),\n                        (const char *) dbname.str,\n                        (const char *) name.str);\n  }\n\n  ptr= strchr(definer.str, '@');\n\n  if (! ptr)\n    ptr= definer.str;\n\n  len= ptr - definer.str;\n  definer_user.str= strmake_root(&mem_root, definer.str, len);\n  definer_user.length= len;\n  len= definer.length - len - 1;\n  /* 1:because of @ */\n  definer_host.str= strmake_root(&mem_root, ptr + 1,  len);\n  definer_host.length= len;\n\n  created= table->field[ET_FIELD_CREATED]->val_int();\n  modified= table->field[ET_FIELD_MODIFIED]->val_int();\n\n  comment.str= get_field(&mem_root, table->field[ET_FIELD_COMMENT]);\n  if (comment.str != NullS)\n    comment.length= strlen(comment.str);\n  else\n    comment.length= 0;\n\n  sql_mode= (ulong) table->field[ET_FIELD_SQL_MODE]->val_int();\n\n  DBUG_RETURN(FALSE);\n}\n\n\n/*\n  add_interval() adds a specified interval to time 'ltime' in time\n  zone 'time_zone', and returns the result converted to the number of\n  seconds since epoch (aka Unix time; in UTC time zone).  Zero result\n  means an error.\n*/\nstatic\nmy_time_t\nadd_interval(MYSQL_TIME *ltime, const Time_zone *time_zone,\n             interval_type scale, INTERVAL interval)\n{\n  if (date_add_interval(ltime, scale, interval))\n    return 0;\n\n  uint not_used;\n  return time_zone->TIME_to_gmt_sec(ltime, &not_used);\n}\n\n\n/*\n  Computes the sum of a timestamp plus interval.\n\n  SYNOPSIS\n    get_next_time()\n      time_zone     event time zone\n      next          the sum\n      start         add interval_value to this time\n      time_now      current time\n      i_value       quantity of time type interval to add\n      i_type        type of interval to add (SECOND, MINUTE, HOUR, WEEK ...)\n\n  RETURN VALUE\n    0  OK\n    1  Error\n\n  NOTES\n    1) If the interval is conversible to SECOND, like MINUTE, HOUR, DAY, WEEK.\n       Then we use TIMEDIFF()'s implementation as underlying and number of\n       seconds as resolution for computation.\n    2) In all other cases - MONTH, QUARTER, YEAR we use MONTH as resolution\n       and PERIOD_DIFF()'s implementation\n*/\n\nstatic\nbool get_next_time(const Time_zone *time_zone, my_time_t *next,\n                   my_time_t start, my_time_t time_now,\n                   int i_value, interval_type i_type)\n{\n  DBUG_ENTER(\"get_next_time\");\n  DBUG_PRINT(\"enter\", (\"start: %lu  now: %lu\", (long) start, (long) time_now));\n\n  DBUG_ASSERT(start <= time_now);\n\n  longlong months=0, seconds=0;\n\n  switch (i_type) {\n  case INTERVAL_YEAR:\n    months= i_value*12;\n    break;\n  case INTERVAL_QUARTER:\n    /* Has already been converted to months */\n  case INTERVAL_YEAR_MONTH:\n  case INTERVAL_MONTH:\n    months= i_value;\n    break;\n  case INTERVAL_WEEK:\n    /* WEEK has already been converted to days */\n  case INTERVAL_DAY:\n    seconds= i_value*24*3600;\n    break;\n  case INTERVAL_DAY_HOUR:\n  case INTERVAL_HOUR:\n    seconds= i_value*3600;\n    break;\n  case INTERVAL_DAY_MINUTE:\n  case INTERVAL_HOUR_MINUTE:\n  case INTERVAL_MINUTE:\n    seconds= i_value*60;\n    break;\n  case INTERVAL_DAY_SECOND:\n  case INTERVAL_HOUR_SECOND:\n  case INTERVAL_MINUTE_SECOND:\n  case INTERVAL_SECOND:\n    seconds= i_value;\n    break;\n  case INTERVAL_DAY_MICROSECOND:\n  case INTERVAL_HOUR_MICROSECOND:\n  case INTERVAL_MINUTE_MICROSECOND:\n  case INTERVAL_SECOND_MICROSECOND:\n  case INTERVAL_MICROSECOND:\n    /*\n     We should return an error here so SHOW EVENTS/ SELECT FROM I_S.EVENTS\n     would give an error then.\n    */\n    DBUG_RETURN(1);\n  case INTERVAL_LAST:\n    DBUG_ASSERT(0);\n  }\n  DBUG_PRINT(\"info\", (\"seconds: %ld  months: %ld\", (long) seconds, (long) months));\n\n  MYSQL_TIME local_start;\n  MYSQL_TIME local_now;\n\n  /* Convert times from UTC to local. */\n  {\n    time_zone->gmt_sec_to_TIME(&local_start, start);\n    time_zone->gmt_sec_to_TIME(&local_now, time_now);\n  }\n\n  INTERVAL interval;\n  bzero(&interval, sizeof(interval));\n  my_time_t next_time= 0;\n\n  if (seconds)\n  {\n    longlong seconds_diff;\n    long microsec_diff;\n    bool negative= calc_time_diff(&local_now, &local_start, 1,\n                                  &seconds_diff, &microsec_diff);\n    if (!negative)\n    {\n      /*\n        The formula below returns the interval that, when added to\n        local_start, will always give the time in the future.\n      */\n      interval.second= seconds_diff - seconds_diff % seconds + seconds;\n      next_time= add_interval(&local_start, time_zone,\n                              INTERVAL_SECOND, interval);\n      if (next_time == 0)\n        goto done;\n    }\n\n    if (next_time <= time_now)\n    {\n      /*\n        If 'negative' is true above, then 'next_time == 0', and\n        'next_time <= time_now' is also true.  If negative is false,\n        then next_time was set, but perhaps to the value that is less\n        then time_now.  See below for elaboration.\n      */\n      DBUG_ASSERT(negative || next_time > 0);\n\n      /*\n        If local_now < local_start, i.e. STARTS time is in the future\n        according to the local time (it always in the past according\n        to UTC---this is a prerequisite of this function), then\n        STARTS is almost always in the past according to the local\n        time too.  However, in the time zone that has backward\n        Daylight Saving Time shift, the following may happen: suppose\n        we have a backward DST shift at certain date after 2:59:59,\n        i.e. local time goes 1:59:59, 2:00:00, ... , 2:59:59, (shift\n        here) 2:00:00 (again), ... , 2:59:59 (again), 3:00:00, ... .\n        Now suppose the time has passed the first 2:59:59, has been\n        shifted backward, and now is (the second) 2:20:00.  The user\n        does CREATE EVENT with STARTS 'current-date 2:40:00'.  Local\n        time 2:40:00 from create statement is treated by time\n        functions as the first such time, so according to UTC it comes\n        before the second 2:20:00.  But according to local time it is\n        obviously in the future, so we end up in this branch.\n\n        Since we are in the second pass through 2:00:00--2:59:59, and\n        any local time form this interval is treated by system\n        functions as the time from the first pass, we have to find the\n        time for the next execution that is past the DST-affected\n        interval (past the second 2:59:59 for our example,\n        i.e. starting from 3:00:00).  We do this in the loop until the\n        local time is mapped onto future UTC time.  'start' time is in\n        the past, so we may use 'do { } while' here, and add the first\n        interval right away.\n\n        Alternatively, it could be that local_now >= local_start.  Now\n        for the example above imagine we do CREATE EVENT with STARTS\n        'current-date 2:10:00'.  Local start 2:10 is in the past (now\n        is local 2:20), so we add an interval, and get next execution\n        time, say, 2:40.  It is in the future according to local time,\n        but, again, since we are in the second pass through\n        2:00:00--2:59:59, 2:40 will be converted into UTC time in the\n        past.  So we will end up in this branch again, and may add\n        intervals in a 'do { } while' loop.\n\n        Note that for any given event we may end up here only if event\n        next execution time will map to the time interval that is\n        passed twice, and only if the server was started during the\n        second pass, or the event is being created during the second\n        pass.  After that, we never will get here (unless we again\n        start the server during the second pass).  In other words,\n        such a condition is extremely rare.\n      */\n      interval.second= seconds;\n      do\n      {\n        next_time= add_interval(&local_start, time_zone,\n                                INTERVAL_SECOND, interval);\n        if (next_time == 0)\n          goto done;\n      }\n      while (next_time <= time_now);\n    }\n  }\n  else\n  {\n    long diff_months= ((long) local_now.year - (long) local_start.year)*12 +\n                      ((long) local_now.month - (long) local_start.month);\n\n    /*\n      Unlike for seconds above, the formula below returns the interval\n      that, when added to the local_start, will give the time in the\n      past, or somewhere in the current month.  We are interested in\n      the latter case, to see if this time has already passed, or is\n      yet to come this month.\n\n      Note that the time is guaranteed to be in the past unless\n      (diff_months % months == 0), but no good optimization is\n      possible here, because (diff_months % months == 0) is what will\n      happen most of the time, as get_next_time() will be called right\n      after the execution of the event.  We could pass last_executed\n      time to this function, and see if the execution has already\n      happened this month, but for that we will have to convert\n      last_executed from seconds since epoch to local broken-down\n      time, and this will greatly reduce the effect of the\n      optimization.  So instead we keep the code simple and clean.\n    */\n    interval.month= (ulong) (diff_months - diff_months % months);\n    next_time= add_interval(&local_start, time_zone,\n                            INTERVAL_MONTH, interval);\n    if (next_time == 0)\n      goto done;\n\n    if (next_time <= time_now)\n    {\n      interval.month= (ulong) months;\n      next_time= add_interval(&local_start, time_zone,\n                              INTERVAL_MONTH, interval);\n      if (next_time == 0)\n        goto done;\n    }\n  }\n\n  DBUG_ASSERT(time_now < next_time);\n\n  *next= next_time;\n\ndone:\n  DBUG_PRINT(\"info\", (\"next_time: %ld\", (long) next_time));\n  DBUG_RETURN(next_time == 0);\n}\n\n\n/*\n  Computes next execution time.\n\n  SYNOPSIS\n    Event_queue_element::compute_next_execution_time()\n\n  RETURN VALUE\n    FALSE  OK\n    TRUE   Error\n\n  NOTES\n    The time is set in execute_at, if no more executions the latter is\n    set to 0.\n*/\n\nbool\nEvent_queue_element::compute_next_execution_time()\n{\n  my_time_t time_now;\n  DBUG_ENTER(\"Event_queue_element::compute_next_execution_time\");\n  DBUG_PRINT(\"enter\", (\"starts: %lu  ends: %lu  last_executed: %lu  this: %p\",\n                       (long) starts, (long) ends, (long) last_executed,\n                       this));\n\n  if (status != Event_parse_data::ENABLED)\n  {\n    DBUG_PRINT(\"compute_next_execution_time\",\n               (\"Event %s is DISABLED\", name.str));\n    goto ret;\n  }\n  /* If one-time, no need to do computation */\n  if (!expression)\n  {\n    /* Let's check whether it was executed */\n    if (last_executed)\n    {\n      DBUG_PRINT(\"info\",(\"One-time event %s.%s of was already executed\",\n                         dbname.str, name.str));\n      dropped= (on_completion == Event_parse_data::ON_COMPLETION_DROP);\n      DBUG_PRINT(\"info\",(\"One-time event will be dropped: %d.\", dropped));\n\n      status= Event_parse_data::DISABLED;\n    }\n    goto ret;\n  }\n\n  time_now= current_thd->query_start();\n\n  DBUG_PRINT(\"info\",(\"NOW: [%lu]\", (ulong) time_now));\n\n  /* if time_now is after ends don't execute anymore */\n  if (!ends_null && ends < time_now)\n  {\n    DBUG_PRINT(\"info\", (\"NOW after ENDS, don't execute anymore\"));\n    /* time_now is after ends. don't execute anymore */\n    execute_at= 0;\n    execute_at_null= TRUE;\n    if (on_completion == Event_parse_data::ON_COMPLETION_DROP)\n      dropped= TRUE;\n    DBUG_PRINT(\"info\", (\"Dropped: %d\", dropped));\n    status= Event_parse_data::DISABLED;\n\n    goto ret;\n  }\n\n  /*\n    Here time_now is before or equals ends if the latter is set.\n    Let's check whether time_now is before starts.\n    If so schedule for starts.\n  */\n  if (!starts_null && time_now <= starts)\n  {\n    if (time_now == starts && starts == last_executed)\n    {\n      /*\n        do nothing or we will schedule for second time execution at starts.\n      */\n    }\n    else\n    {\n      DBUG_PRINT(\"info\", (\"STARTS is future, NOW <= STARTS,sched for STARTS\"));\n      /*\n        starts is in the future\n        time_now before starts. Scheduling for starts\n      */\n      execute_at= starts;\n      execute_at_null= FALSE;\n      goto ret;\n    }\n  }\n\n  if (!starts_null && !ends_null)\n  {\n    /*\n      Both starts and m_ends are set and time_now is between them (incl.)\n      If last_executed is set then increase with m_expression. The new MYSQL_TIME is\n      after m_ends set execute_at to 0. And check for on_completion\n      If not set then schedule for now.\n    */\n    DBUG_PRINT(\"info\", (\"Both STARTS & ENDS are set\"));\n    if (!last_executed)\n    {\n      DBUG_PRINT(\"info\", (\"Not executed so far.\"));\n    }\n\n    {\n      my_time_t next_exec;\n\n      if (get_next_time(time_zone, &next_exec, starts, time_now,\n                        (int) expression, interval))\n        goto err;\n\n      /* There was previous execution */\n      if (ends < next_exec)\n      {\n        DBUG_PRINT(\"info\", (\"Next execution of %s after ENDS. Stop executing.\",\n                   name.str));\n        /* Next execution after ends. No more executions */\n        execute_at= 0;\n        execute_at_null= TRUE;\n        if (on_completion == Event_parse_data::ON_COMPLETION_DROP)\n          dropped= TRUE;\n        status= Event_parse_data::DISABLED;\n      }\n      else\n      {\n        DBUG_PRINT(\"info\",(\"Next[%lu]\", (ulong) next_exec));\n        execute_at= next_exec;\n        execute_at_null= FALSE;\n      }\n    }\n    goto ret;\n  }\n  else if (starts_null && ends_null)\n  {\n    /* starts is always set, so this is a dead branch !! */\n    DBUG_PRINT(\"info\", (\"Neither STARTS nor ENDS are set\"));\n    /*\n      Both starts and m_ends are not set, so we schedule for the next\n      based on last_executed.\n    */\n    if (last_executed)\n    {\n      my_time_t next_exec;\n      if (get_next_time(time_zone, &next_exec, starts, time_now,\n                        (int) expression, interval))\n        goto err;\n      execute_at= next_exec;\n      DBUG_PRINT(\"info\",(\"Next[%lu]\", (ulong) next_exec));\n    }\n    else\n    {\n      /* last_executed not set. Schedule the event for now */\n      DBUG_PRINT(\"info\", (\"Execute NOW\"));\n      execute_at= time_now;\n    }\n    execute_at_null= FALSE;\n  }\n  else\n  {\n    /* either starts or m_ends is set */\n    if (!starts_null)\n    {\n      DBUG_PRINT(\"info\", (\"STARTS is set\"));\n      /*\n        - starts is set.\n        - starts is not in the future according to check made before\n        Hence schedule for starts + m_expression in case last_executed\n        is not set, otherwise to last_executed + m_expression\n      */\n      if (!last_executed)\n      {\n        DBUG_PRINT(\"info\", (\"Not executed so far.\"));\n      }\n\n      {\n        my_time_t next_exec;\n        if (get_next_time(time_zone, &next_exec, starts, time_now,\n                          (int) expression, interval))\n          goto err;\n        execute_at= next_exec;\n        DBUG_PRINT(\"info\",(\"Next[%lu]\", (ulong) next_exec));\n      }\n      execute_at_null= FALSE;\n    }\n    else\n    {\n      /* this is a dead branch, because starts is always set !!! */\n      DBUG_PRINT(\"info\", (\"STARTS is not set. ENDS is set\"));\n      /*\n        - m_ends is set\n        - m_ends is after time_now or is equal\n        Hence check for m_last_execute and increment with m_expression.\n        If last_executed is not set then schedule for now\n      */\n\n      if (!last_executed)\n        execute_at= time_now;\n      else\n      {\n        my_time_t next_exec;\n\n        if (get_next_time(time_zone, &next_exec, starts, time_now,\n                          (int) expression, interval))\n          goto err;\n\n        if (ends < next_exec)\n        {\n          DBUG_PRINT(\"info\", (\"Next execution after ENDS. Stop executing.\"));\n          execute_at= 0;\n          execute_at_null= TRUE;\n          status= Event_parse_data::DISABLED;\n          if (on_completion == Event_parse_data::ON_COMPLETION_DROP)\n            dropped= TRUE;\n        }\n        else\n        {\n          DBUG_PRINT(\"info\", (\"Next[%lu]\", (ulong) next_exec));\n          execute_at= next_exec;\n          execute_at_null= FALSE;\n        }\n      }\n    }\n    goto ret;\n  }\nret:\n  DBUG_PRINT(\"info\", (\"ret: 0 execute_at: %lu\", (long) execute_at));\n  DBUG_RETURN(FALSE);\nerr:\n  DBUG_PRINT(\"info\", (\"ret=1\"));\n  DBUG_RETURN(TRUE);\n}\n\n\n/*\n  Set the internal last_executed MYSQL_TIME struct to now. NOW is the\n  time according to thd->query_start(), so the THD's clock.\n\n  SYNOPSIS\n    Event_queue_element::mark_last_executed()\n      thd   thread context\n*/\n\nvoid\nEvent_queue_element::mark_last_executed(THD *thd)\n{\n  last_executed= thd->query_start();\n\n  execution_count++;\n}\n\n\nstatic\nvoid\nappend_datetime(String *buf, Time_zone *time_zone, my_time_t secs,\n                const char *name, uint len)\n{\n  char dtime_buff[20*2+32];/* +32 to make my_snprintf_{8bit|ucs2} happy */\n  buf->append(STRING_WITH_LEN(\" \"));\n  buf->append(name, len);\n  buf->append(STRING_WITH_LEN(\" '\"));\n  /*\n    Pass the buffer and the second param tells fills the buffer and\n    returns the number of chars to copy.\n  */\n  MYSQL_TIME time;\n  time_zone->gmt_sec_to_TIME(&time, secs);\n  buf->append(dtime_buff, my_datetime_to_str(&time, dtime_buff, 0));\n  buf->append(STRING_WITH_LEN(\"'\"));\n}\n\n\n/*\n  Get SHOW CREATE EVENT as string\n\n  SYNOPSIS\n    Event_timed::get_create_event(THD *thd, String *buf)\n      thd    Thread\n      buf    String*, should be already allocated. CREATE EVENT goes inside.\n\n  RETURN VALUE\n    0                       OK\n    EVEX_MICROSECOND_UNSUP  Error (for now if mysql.event has been\n                            tampered and MICROSECONDS interval or\n                            derivative has been put there.\n*/\n\nint\nEvent_timed::get_create_event(THD *thd, String *buf)\n{\n  char tmp_buf[2 * STRING_BUFFER_USUAL_SIZE];\n  String expr_buf(tmp_buf, sizeof(tmp_buf), system_charset_info);\n  expr_buf.length(0);\n\n  DBUG_ENTER(\"get_create_event\");\n  DBUG_PRINT(\"ret_info\",(\"body_len=[%d]body=[%s]\",\n                         (int) body.length, body.str));\n\n  if (expression && Events::reconstruct_interval_expression(&expr_buf, interval,\n                                                            expression))\n    DBUG_RETURN(EVEX_MICROSECOND_UNSUP);\n\n  buf->append(STRING_WITH_LEN(\"CREATE \"));\n  append_definer(thd, buf, &definer_user, &definer_host);\n  buf->append(STRING_WITH_LEN(\"EVENT \"));\n  append_identifier(thd, buf, name.str, name.length);\n\n  if (expression)\n  {\n    buf->append(STRING_WITH_LEN(\" ON SCHEDULE EVERY \"));\n    buf->append(expr_buf);\n    buf->append(' ');\n    LEX_STRING *ival= &interval_type_to_name[interval];\n    buf->append(ival->str, ival->length);\n\n    if (!starts_null)\n      append_datetime(buf, time_zone, starts, STRING_WITH_LEN(\"STARTS\"));\n\n    if (!ends_null)\n      append_datetime(buf, time_zone, ends, STRING_WITH_LEN(\"ENDS\"));\n  }\n  else\n  {\n    append_datetime(buf, time_zone, execute_at,\n                    STRING_WITH_LEN(\"ON SCHEDULE AT\"));\n  }\n\n  if (on_completion == Event_parse_data::ON_COMPLETION_DROP)\n    buf->append(STRING_WITH_LEN(\" ON COMPLETION NOT PRESERVE \"));\n  else\n    buf->append(STRING_WITH_LEN(\" ON COMPLETION PRESERVE \"));\n\n  if (status == Event_parse_data::ENABLED)\n    buf->append(STRING_WITH_LEN(\"ENABLE\"));\n  else if (status == Event_parse_data::SLAVESIDE_DISABLED)\n    buf->append(STRING_WITH_LEN(\"DISABLE ON SLAVE\"));\n  else\n    buf->append(STRING_WITH_LEN(\"DISABLE\"));\n\n  if (comment.length)\n  {\n    buf->append(STRING_WITH_LEN(\" COMMENT \"));\n    append_unescaped(buf, comment.str, comment.length);\n  }\n  buf->append(STRING_WITH_LEN(\" DO \"));\n  buf->append(body.str, body.length);\n\n  DBUG_RETURN(0);\n}\n\n\n/**\n  Get an artificial stored procedure to parse as an event definition.\n*/\n\nbool\nEvent_job_data::construct_sp_sql(THD *thd, String *sp_sql)\n{\n  LEX_STRING buffer;\n  const uint STATIC_SQL_LENGTH= 44;\n\n  DBUG_ENTER(\"Event_job_data::construct_sp_sql\");\n\n  /*\n    Allocate a large enough buffer on the thread execution memory\n    root to avoid multiple [re]allocations on system heap\n  */\n  buffer.length= STATIC_SQL_LENGTH + name.length + body.length;\n  if (! (buffer.str= (char*) thd->alloc(buffer.length)))\n    DBUG_RETURN(TRUE);\n\n  sp_sql->set(buffer.str, buffer.length, system_charset_info);\n  sp_sql->length(0);\n\n\n  sp_sql->append(C_STRING_WITH_LEN(\"CREATE \"));\n  sp_sql->append(C_STRING_WITH_LEN(\"PROCEDURE \"));\n  /*\n    Let's use the same name as the event name to perhaps produce a\n    better error message in case it is a part of some parse error.\n    We're using append_identifier here to successfully parse\n    events with reserved names.\n  */\n  append_identifier(thd, sp_sql, name.str, name.length);\n\n  /*\n    The default SQL security of a stored procedure is DEFINER. We\n    have already activated the security context of the event, so\n    let's execute the procedure with the invoker rights to save on\n    resets of security contexts.\n  */\n  sp_sql->append(C_STRING_WITH_LEN(\"() SQL SECURITY INVOKER \"));\n\n  sp_sql->append(body.str, body.length);\n\n  DBUG_RETURN(thd->is_fatal_error);\n}\n\n\n/**\n  Get DROP EVENT statement to binlog the drop of ON COMPLETION NOT\n  PRESERVE event.\n*/\n\nbool\nEvent_job_data::construct_drop_event_sql(THD *thd, String *sp_sql)\n{\n  LEX_STRING buffer;\n  const uint STATIC_SQL_LENGTH= 14;\n\n  DBUG_ENTER(\"Event_job_data::construct_drop_event_sql\");\n\n  buffer.length= STATIC_SQL_LENGTH + name.length*2 + dbname.length*2;\n  if (! (buffer.str= (char*) thd->alloc(buffer.length)))\n    DBUG_RETURN(TRUE);\n\n  sp_sql->set(buffer.str, buffer.length, system_charset_info);\n  sp_sql->length(0);\n\n  sp_sql->append(C_STRING_WITH_LEN(\"DROP EVENT \"));\n  append_identifier(thd, sp_sql, dbname.str, dbname.length);\n  sp_sql->append('.');\n  append_identifier(thd, sp_sql, name.str, name.length);\n\n  DBUG_RETURN(thd->is_fatal_error);\n}\n\n/**\n  Compiles and executes the event (the underlying sp_head object)\n\n  @retval TRUE  error (reported to the error log)\n  @retval FALSE success\n*/\n\nbool\nEvent_job_data::execute(THD *thd, bool drop)\n{\n  String sp_sql;\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n  Security_context event_sctx, *save_sctx= NULL;\n#endif\n  List<Item> empty_item_list;\n  bool ret= TRUE;\n\n  DBUG_ENTER(\"Event_job_data::execute\");\n\n  thd->reset_for_next_command();\n\n  /*\n    MySQL parser currently assumes that current database is either\n    present in THD or all names in all statements are fully specified.\n    And yet not fully specified names inside stored programs must be \n    be supported, even if the current database is not set:\n    CREATE PROCEDURE db1.p1() BEGIN CREATE TABLE t1; END//\n    -- in this example t1 should be always created in db1 and the statement\n    must parse even if there is no current database.\n\n    To support this feature and still address the parser limitation,\n    we need to set the current database here.\n    We don't have to call mysql_change_db, since the checks performed\n    in it are unnecessary for the purpose of parsing, and\n    mysql_change_db will be invoked anyway later, to activate the\n    procedure database before it's executed.\n  */\n  thd->set_db(dbname.str, dbname.length);\n\n  lex_start(thd);\n\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n  if (event_sctx.change_security_context(thd,\n                                         &definer_user, &definer_host,\n                                         &dbname, &save_sctx))\n  {\n    sql_print_error(\"Event Scheduler: \"\n                    \"[%s].[%s.%s] execution failed, \"\n                    \"failed to authenticate the user.\",\n                    definer.str, dbname.str, name.str);\n    goto end;\n  }\n#endif\n\n  if (check_access(thd, EVENT_ACL, dbname.str, NULL, NULL, 0, 0))\n  {\n    /*\n      This aspect of behavior is defined in the worklog,\n      and this is how triggers work too: if TRIGGER\n      privilege is revoked from trigger definer,\n      triggers are not executed.\n    */\n    sql_print_error(\"Event Scheduler: \"\n                    \"[%s].[%s.%s] execution failed, \"\n                    \"user no longer has EVENT privilege.\",\n                    definer.str, dbname.str, name.str);\n    goto end;\n  }\n\n  if (construct_sp_sql(thd, &sp_sql))\n    goto end;\n\n  /*\n    Set up global thread attributes to reflect the properties of\n    this Event. We can simply reset these instead of usual\n    backup/restore employed in stored programs since we know that\n    this is a top level statement and the worker thread is\n    allocated exclusively to execute this event.\n  */\n\n  thd->variables.sql_mode= sql_mode;\n  thd->variables.time_zone= time_zone;\n\n  thd->set_query(sp_sql.c_ptr_safe(), sp_sql.length());\n\n  {\n    Parser_state parser_state;\n    if (parser_state.init(thd, thd->query(), thd->query_length()))\n      goto end;\n\n    if (parse_sql(thd, & parser_state, creation_ctx))\n    {\n      sql_print_error(\"Event Scheduler: \"\n                      \"%serror during compilation of %s.%s\",\n                      thd->is_fatal_error ? \"fatal \" : \"\",\n                      (const char *) dbname.str, (const char *) name.str);\n      goto end;\n    }\n  }\n\n  {\n    sp_head *sphead= thd->lex->sphead;\n\n    DBUG_ASSERT(sphead);\n\n    sphead->m_flags|= sp_head::LOG_SLOW_STATEMENTS;\n    sphead->m_flags|= sp_head::LOG_GENERAL_LOG;\n\n    sphead->set_info(0, 0, &thd->lex->sp_chistics, sql_mode);\n    sphead->set_creation_ctx(creation_ctx);\n    sphead->optimize();\n\n    ret= sphead->execute_procedure(thd, &empty_item_list);\n    /*\n      There is no pre-locking and therefore there should be no\n      tables open and locked left after execute_procedure.\n    */\n  }\n\nend:\n  if (drop && !thd->is_fatal_error)\n  {\n    /*\n      We must do it here since here we're under the right authentication\n      ID of the event definer.\n    */\n    sql_print_information(\"Event Scheduler: Dropping %s.%s\",\n                          (const char *) dbname.str, (const char *) name.str);\n    /*\n      Construct a query for the binary log, to ensure the event is dropped\n      on the slave\n    */\n    if (construct_drop_event_sql(thd, &sp_sql))\n      ret= 1;\n    else\n    {\n      ulong saved_master_access;\n\n      thd->set_query(sp_sql.c_ptr_safe(), sp_sql.length());\n\n      /*\n        NOTE: even if we run in read-only mode, we should be able to lock\n        the mysql.event table for writing. In order to achieve this, we\n        should call mysql_lock_tables() under the super-user.\n\n        Same goes for transaction access mode.\n        Temporarily reset it to read-write.\n      */\n\n      saved_master_access= thd->security_ctx->master_access;\n      thd->security_ctx->master_access |= SUPER_ACL;\n      bool save_tx_read_only= thd->tx_read_only;\n      thd->tx_read_only= false;\n\n      if (WSREP(thd))\n      {\n        thd->lex->sql_command = SQLCOM_DROP_EVENT;\n        WSREP_TO_ISOLATION_BEGIN(WSREP_MYSQL_DB, NULL, NULL);\n      }\n\n      ret= Events::drop_event(thd, dbname, name, FALSE);\n\n      WSREP_TO_ISOLATION_END;\n\n#ifdef WITH_WSREP\n  error:\n#endif\n      thd->tx_read_only= save_tx_read_only;\n      thd->security_ctx->master_access= saved_master_access;\n    }\n  }\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n  if (save_sctx)\n    event_sctx.restore_security_context(thd, save_sctx);\n#endif\n  thd->lex->unit.cleanup();\n  thd->end_statement();\n  thd->cleanup_after_query();\n  /* Avoid races with SHOW PROCESSLIST */\n  thd->reset_query();\n\n  DBUG_PRINT(\"info\", (\"EXECUTED %s.%s  ret: %d\", dbname.str, name.str, ret));\n\n  DBUG_RETURN(ret);\n}\n\n\n/*\n  Checks whether two events are in the same schema\n\n  SYNOPSIS\n    event_basic_db_equal()\n      db  Schema\n      et  Compare et->dbname to `db`\n\n  RETURN VALUE\n    TRUE   Equal\n    FALSE  Not equal\n*/\n\nbool\nevent_basic_db_equal(LEX_STRING db, Event_basic *et)\n{\n  return !sortcmp_lex_string(et->dbname, db, system_charset_info);\n}\n\n\n/*\n  Checks whether an event has equal `db` and `name`\n\n  SYNOPSIS\n    event_basic_identifier_equal()\n      db   Schema\n      name Name\n      et   The event object\n\n  RETURN VALUE\n    TRUE   Equal\n    FALSE  Not equal\n*/\n\nbool\nevent_basic_identifier_equal(LEX_STRING db, LEX_STRING name, Event_basic *b)\n{\n  return !sortcmp_lex_string(name, b->name, system_charset_info) &&\n         !sortcmp_lex_string(db, b->dbname, system_charset_info);\n}\n\n/**\n  @} (End of group Event_Scheduler)\n*/\n"], "fixing_code": ["/*\n   Copyright (c) 2005, 2010, Oracle and/or its affiliates.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n#define MYSQL_LEX 1\n#include <my_global.h>                          /* NO_EMBEDDED_ACCESS_CHECKS */\n#include \"sql_priv.h\"\n#include \"unireg.h\"\n#include \"sql_parse.h\"                          // parse_sql\n#include \"strfunc.h\"                           // find_string_in_array\n#include \"sql_db.h\"                        // get_default_db_collation\n#include \"sql_time.h\"                      // interval_type_to_name,\n                                           // date_add_interval,\n                                           // calc_time_diff\n#include \"tztime.h\"     // my_tz_find, my_tz_OFFSET0, struct Time_zone\n#include \"sql_acl.h\"    // EVENT_ACL, SUPER_ACL\n#include \"sp.h\"         // load_charset, load_collation\n#include \"events.h\"\n#include \"event_data_objects.h\"\n#include \"event_db_repository.h\"\n#include \"sp_head.h\"\n#include \"sql_show.h\"                // append_definer, append_identifier\n\n/**\n  @addtogroup Event_Scheduler\n  @{\n*/\n\n/*************************************************************************/\n\n/**\n  Event_creation_ctx -- creation context of events.\n*/\n\nclass Event_creation_ctx :public Stored_program_creation_ctx,\n                          public Sql_alloc\n{\npublic:\n  static bool load_from_db(THD *thd,\n                           MEM_ROOT *event_mem_root,\n                           const char *db_name,\n                           const char *event_name,\n                           TABLE *event_tbl,\n                           Stored_program_creation_ctx **ctx);\n\npublic:\n  virtual Stored_program_creation_ctx *clone(MEM_ROOT *mem_root)\n  {\n    return new (mem_root)\n               Event_creation_ctx(m_client_cs, m_connection_cl, m_db_cl);\n  }\n\nprotected:\n  virtual Object_creation_ctx *create_backup_ctx(THD *thd) const\n  {\n    /*\n      We can avoid usual backup/restore employed in stored programs since we\n      know that this is a top level statement and the worker thread is\n      allocated exclusively to execute this event.\n    */\n\n    return NULL;\n  }\n\nprivate:\n  Event_creation_ctx(CHARSET_INFO *client_cs,\n                     CHARSET_INFO *connection_cl,\n                     CHARSET_INFO *db_cl)\n    : Stored_program_creation_ctx(client_cs, connection_cl, db_cl)\n  { }\n};\n\n/**************************************************************************\n  Event_creation_ctx implementation.\n**************************************************************************/\n\nbool\nEvent_creation_ctx::load_from_db(THD *thd,\n                                 MEM_ROOT *event_mem_root,\n                                 const char *db_name,\n                                 const char *event_name,\n                                 TABLE *event_tbl,\n                                 Stored_program_creation_ctx **ctx)\n{\n  /* Load character set/collation attributes. */\n\n  CHARSET_INFO *client_cs;\n  CHARSET_INFO *connection_cl;\n  CHARSET_INFO *db_cl;\n\n  bool invalid_creation_ctx= FALSE;\n\n  if (load_charset(event_mem_root,\n                   event_tbl->field[ET_FIELD_CHARACTER_SET_CLIENT],\n                   thd->variables.character_set_client,\n                   &client_cs))\n  {\n    sql_print_warning(\"Event '%s'.'%s': invalid value \"\n                      \"in column mysql.event.character_set_client.\",\n                      (const char *) db_name,\n                      (const char *) event_name);\n\n    invalid_creation_ctx= TRUE;\n  }\n\n  if (load_collation(event_mem_root,\n                     event_tbl->field[ET_FIELD_COLLATION_CONNECTION],\n                     thd->variables.collation_connection,\n                     &connection_cl))\n  {\n    sql_print_warning(\"Event '%s'.'%s': invalid value \"\n                      \"in column mysql.event.collation_connection.\",\n                      (const char *) db_name,\n                      (const char *) event_name);\n\n    invalid_creation_ctx= TRUE;\n  }\n\n  if (load_collation(event_mem_root,\n                     event_tbl->field[ET_FIELD_DB_COLLATION],\n                     NULL,\n                     &db_cl))\n  {\n    sql_print_warning(\"Event '%s'.'%s': invalid value \"\n                      \"in column mysql.event.db_collation.\",\n                      (const char *) db_name,\n                      (const char *) event_name);\n\n    invalid_creation_ctx= TRUE;\n  }\n\n  /*\n    If we failed to resolve the database collation, load the default one\n    from the disk.\n  */\n\n  if (!db_cl)\n    db_cl= get_default_db_collation(thd, db_name);\n\n  /* Create the context. */\n\n  *ctx= new Event_creation_ctx(client_cs, connection_cl, db_cl);\n\n  return invalid_creation_ctx;\n}\n\n/*************************************************************************/\n\n/*\n  Initiliazes dbname and name of an Event_queue_element_for_exec\n  object\n\n  SYNOPSIS\n    Event_queue_element_for_exec::init()\n\n  RETURN VALUE\n    FALSE  OK\n    TRUE   Error (OOM)\n*/\n\nbool\nEvent_queue_element_for_exec::init(LEX_STRING db, LEX_STRING n)\n{\n  if (!(dbname.str= my_strndup(db.str, dbname.length= db.length, MYF(MY_WME))))\n    return TRUE;\n  if (!(name.str= my_strndup(n.str, name.length= n.length, MYF(MY_WME))))\n  {\n    my_free(dbname.str);\n    return TRUE;\n  }\n  return FALSE;\n}\n\n\n/*\n  Destructor\n\n  SYNOPSIS\n    Event_queue_element_for_exec::~Event_queue_element_for_exec()\n*/\n\nEvent_queue_element_for_exec::~Event_queue_element_for_exec()\n{\n  my_free(dbname.str);\n  my_free(name.str);\n}\n\n\n/*\n  Constructor\n\n  SYNOPSIS\n    Event_basic::Event_basic()\n*/\n\nEvent_basic::Event_basic()\n{\n  DBUG_ENTER(\"Event_basic::Event_basic\");\n  /* init memory root */\n  init_sql_alloc(&mem_root, 256, 512, MYF(0));\n  dbname.str= name.str= NULL;\n  dbname.length= name.length= 0;\n  time_zone= NULL;\n  DBUG_VOID_RETURN;\n}\n\n\n/*\n  Destructor\n\n  SYNOPSIS\n    Event_basic::Event_basic()\n*/\n\nEvent_basic::~Event_basic()\n{\n  DBUG_ENTER(\"Event_basic::~Event_basic\");\n  free_root(&mem_root, MYF(0));\n  DBUG_VOID_RETURN;\n}\n\n\n/*\n  Short function to load a char column into a LEX_STRING\n\n  SYNOPSIS\n    Event_basic::load_string_field()\n      field_name  The field( enum_events_table_field is not actually used\n                  because it's unknown in event_data_objects.h)\n      fields      The Field array\n      field_value The value\n*/\n\nbool\nEvent_basic::load_string_fields(Field **fields, ...)\n{\n  bool ret= FALSE;\n  va_list args;\n  enum enum_events_table_field field_name;\n  LEX_STRING *field_value;\n\n  DBUG_ENTER(\"Event_basic::load_string_fields\");\n\n  va_start(args, fields);\n  field_name= (enum enum_events_table_field) va_arg(args, int);\n  while (field_name < ET_FIELD_COUNT)\n  {\n    field_value= va_arg(args, LEX_STRING *);\n    if ((field_value->str= get_field(&mem_root, fields[field_name])) == NullS)\n    {\n      ret= TRUE;\n      break;\n    }\n    field_value->length= strlen(field_value->str);\n\n    field_name= (enum enum_events_table_field) va_arg(args, int);\n  }\n  va_end(args);\n\n  DBUG_RETURN(ret);\n}\n\n\nbool\nEvent_basic::load_time_zone(THD *thd, const LEX_STRING tz_name)\n{\n  String str(tz_name.str, &my_charset_latin1);\n  time_zone= my_tz_find(thd, &str);\n\n  return (time_zone == NULL);\n}\n\n\n/*\n  Constructor\n\n  SYNOPSIS\n    Event_queue_element::Event_queue_element()\n*/\n\nEvent_queue_element::Event_queue_element():\n  on_completion(Event_parse_data::ON_COMPLETION_DROP),\n  status(Event_parse_data::ENABLED), expression(0), dropped(FALSE),\n  execution_count(0)\n{\n  DBUG_ENTER(\"Event_queue_element::Event_queue_element\");\n\n  starts= ends= execute_at= last_executed= 0;\n  starts_null= ends_null= execute_at_null= TRUE;\n\n  DBUG_VOID_RETURN;\n}\n\n\n/*\n  Destructor\n\n  SYNOPSIS\n    Event_queue_element::Event_queue_element()\n*/\nEvent_queue_element::~Event_queue_element()\n{\n}\n\n\n/*\n  Constructor\n\n  SYNOPSIS\n    Event_timed::Event_timed()\n*/\n\nEvent_timed::Event_timed():\n  created(0), modified(0), sql_mode(0)\n{\n  DBUG_ENTER(\"Event_timed::Event_timed\");\n  init();\n  DBUG_VOID_RETURN;\n}\n\n\n/*\n  Destructor\n\n  SYNOPSIS\n    Event_timed::~Event_timed()\n*/\n\nEvent_timed::~Event_timed()\n{\n}\n\n\n/*\n  Constructor\n\n  SYNOPSIS\n    Event_job_data::Event_job_data()\n*/\n\nEvent_job_data::Event_job_data()\n  :sql_mode(0)\n{\n}\n\n/*\n  Init all member variables\n\n  SYNOPSIS\n    Event_timed::init()\n*/\n\nvoid\nEvent_timed::init()\n{\n  DBUG_ENTER(\"Event_timed::init\");\n\n  definer_user.str= definer_host.str= body.str= comment.str= NULL;\n  definer_user.length= definer_host.length= body.length= comment.length= 0;\n\n  sql_mode= 0;\n\n  DBUG_VOID_RETURN;\n}\n\n\n/**\n  Load an event's body from a row from mysql.event.\n\n  @details This method is silent on errors and should behave like that.\n  Callers should handle throwing of error messages. The reason is that the\n  class should not know about how to deal with communication.\n\n  @return Operation status\n    @retval FALSE OK\n    @retval TRUE  Error\n*/\n\nbool\nEvent_job_data::load_from_row(THD *thd, TABLE *table)\n{\n  char *ptr;\n  size_t len;\n  LEX_STRING tz_name;\n\n  DBUG_ENTER(\"Event_job_data::load_from_row\");\n\n  if (!table)\n    DBUG_RETURN(TRUE);\n\n  if (table->s->fields < ET_FIELD_COUNT)\n    DBUG_RETURN(TRUE);\n\n  if (load_string_fields(table->field,\n                         ET_FIELD_DB, &dbname,\n                         ET_FIELD_NAME, &name,\n                         ET_FIELD_BODY, &body,\n                         ET_FIELD_DEFINER, &definer,\n                         ET_FIELD_TIME_ZONE, &tz_name,\n                         ET_FIELD_COUNT))\n    DBUG_RETURN(TRUE);\n\n  if (load_time_zone(thd, tz_name))\n    DBUG_RETURN(TRUE);\n\n  Event_creation_ctx::load_from_db(thd, &mem_root, dbname.str, name.str, table,\n                                   &creation_ctx);\n\n  ptr= strchr(definer.str, '@');\n\n  if (! ptr)\n    ptr= definer.str;\n\n  len= ptr - definer.str;\n  definer_user.str= strmake_root(&mem_root, definer.str, len);\n  definer_user.length= len;\n  len= definer.length - len - 1;\n  /* 1:because of @ */\n  definer_host.str= strmake_root(&mem_root, ptr + 1, len);\n  definer_host.length= len;\n\n  sql_mode= (ulong) table->field[ET_FIELD_SQL_MODE]->val_int();\n\n  DBUG_RETURN(FALSE);\n}\n\n\n/**\n  Load an event's body from a row from mysql.event.\n\n  @details This method is silent on errors and should behave like that.\n  Callers should handle throwing of error messages. The reason is that the\n  class should not know about how to deal with communication.\n\n  @return Operation status\n    @retval FALSE OK\n    @retval TRUE  Error\n*/\n\nbool\nEvent_queue_element::load_from_row(THD *thd, TABLE *table)\n{\n  char *ptr;\n  MYSQL_TIME time;\n  LEX_STRING tz_name;\n\n  DBUG_ENTER(\"Event_queue_element::load_from_row\");\n\n  if (!table)\n    DBUG_RETURN(TRUE);\n\n  if (table->s->fields < ET_FIELD_COUNT)\n    DBUG_RETURN(TRUE);\n\n  if (load_string_fields(table->field,\n                         ET_FIELD_DB, &dbname,\n                         ET_FIELD_NAME, &name,\n                         ET_FIELD_DEFINER, &definer,\n                         ET_FIELD_TIME_ZONE, &tz_name,\n                         ET_FIELD_COUNT))\n    DBUG_RETURN(TRUE);\n\n  if (load_time_zone(thd, tz_name))\n    DBUG_RETURN(TRUE);\n\n  starts_null= table->field[ET_FIELD_STARTS]->is_null();\n  uint not_used;\n  if (!starts_null)\n  {\n    table->field[ET_FIELD_STARTS]->get_date(&time, TIME_NO_ZERO_DATE);\n    starts= my_tz_OFFSET0->TIME_to_gmt_sec(&time,&not_used);\n  }\n\n  ends_null= table->field[ET_FIELD_ENDS]->is_null();\n  if (!ends_null)\n  {\n    table->field[ET_FIELD_ENDS]->get_date(&time, TIME_NO_ZERO_DATE);\n    ends= my_tz_OFFSET0->TIME_to_gmt_sec(&time,&not_used);\n  }\n\n  if (!table->field[ET_FIELD_INTERVAL_EXPR]->is_null())\n    expression= table->field[ET_FIELD_INTERVAL_EXPR]->val_int();\n  else\n    expression= 0;\n  /*\n    If neigher STARTS and ENDS is set, then both fields are empty.\n    Hence, if ET_FIELD_EXECUTE_AT is empty there is an error.\n  */\n  execute_at_null= table->field[ET_FIELD_EXECUTE_AT]->is_null();\n  DBUG_ASSERT(!(starts_null && ends_null && !expression && execute_at_null));\n  if (!expression && !execute_at_null)\n  {\n    if (table->field[ET_FIELD_EXECUTE_AT]->get_date(&time,\n                                                    TIME_NO_ZERO_DATE))\n      DBUG_RETURN(TRUE);\n    execute_at= my_tz_OFFSET0->TIME_to_gmt_sec(&time,&not_used);\n  }\n\n  /*\n    We load the interval type from disk as string and then map it to\n    an integer. This decouples the values of enum interval_type\n    and values actually stored on disk. Therefore the type can be\n    reordered without risking incompatibilities of data between versions.\n  */\n  if (!table->field[ET_FIELD_TRANSIENT_INTERVAL]->is_null())\n  {\n    int i;\n    char buff[MAX_FIELD_WIDTH];\n    String str(buff, sizeof(buff), &my_charset_bin);\n    LEX_STRING tmp;\n\n    table->field[ET_FIELD_TRANSIENT_INTERVAL]->val_str(&str);\n    if (!(tmp.length= str.length()))\n      DBUG_RETURN(TRUE);\n\n    tmp.str= str.c_ptr_safe();\n\n    i= find_string_in_array(interval_type_to_name, &tmp, system_charset_info);\n    if (i < 0)\n      DBUG_RETURN(TRUE);\n    interval= (interval_type) i;\n  }\n\n  if (!table->field[ET_FIELD_LAST_EXECUTED]->is_null())\n  {\n    table->field[ET_FIELD_LAST_EXECUTED]->get_date(&time,\n                                                   TIME_NO_ZERO_DATE);\n    last_executed= my_tz_OFFSET0->TIME_to_gmt_sec(&time,&not_used);\n  }\n\n  if ((ptr= get_field(&mem_root, table->field[ET_FIELD_STATUS])) == NullS)\n    DBUG_RETURN(TRUE);\n\n  DBUG_PRINT(\"load_from_row\", (\"Event [%s] is [%s]\", name.str, ptr));\n\n  /* Set event status (ENABLED | SLAVESIDE_DISABLED | DISABLED) */\n  switch (ptr[0])\n  {\n  case 'E' :\n    status = Event_parse_data::ENABLED;\n    break;\n  case 'S' :\n    status = Event_parse_data::SLAVESIDE_DISABLED;\n    break;\n  case 'D' :\n  default:\n    status = Event_parse_data::DISABLED;\n    break;\n  }\n  if ((ptr= get_field(&mem_root, table->field[ET_FIELD_ORIGINATOR])) == NullS)\n    DBUG_RETURN(TRUE);\n  originator = (uint32) table->field[ET_FIELD_ORIGINATOR]->val_int(); \n\n  /* ToDo : Andrey . Find a way not to allocate ptr on event_mem_root */\n  if ((ptr= get_field(&mem_root,\n                      table->field[ET_FIELD_ON_COMPLETION])) == NullS)\n    DBUG_RETURN(TRUE);\n\n  on_completion= (ptr[0]=='D'? Event_parse_data::ON_COMPLETION_DROP:\n                               Event_parse_data::ON_COMPLETION_PRESERVE);\n\n  DBUG_RETURN(FALSE);\n}\n\n\n/**\n  Load an event's body from a row from mysql.event.\n\n  @details This method is silent on errors and should behave like that.\n  Callers should handle throwing of error messages. The reason is that the\n  class should not know about how to deal with communication.\n\n  @return Operation status\n    @retval FALSE OK\n    @retval TRUE  Error\n*/\n\nbool\nEvent_timed::load_from_row(THD *thd, TABLE *table)\n{\n  char *ptr;\n  size_t len;\n\n  DBUG_ENTER(\"Event_timed::load_from_row\");\n\n  if (Event_queue_element::load_from_row(thd, table))\n    DBUG_RETURN(TRUE);\n\n  if (load_string_fields(table->field,\n                         ET_FIELD_BODY, &body,\n                         ET_FIELD_BODY_UTF8, &body_utf8,\n                         ET_FIELD_COUNT))\n    DBUG_RETURN(TRUE);\n\n  if (Event_creation_ctx::load_from_db(thd, &mem_root, dbname.str, name.str,\n                                       table, &creation_ctx))\n  {\n    push_warning_printf(thd,\n                        Sql_condition::WARN_LEVEL_WARN,\n                        ER_EVENT_INVALID_CREATION_CTX,\n                        ER_THD(thd, ER_EVENT_INVALID_CREATION_CTX),\n                        (const char *) dbname.str,\n                        (const char *) name.str);\n  }\n\n  ptr= strchr(definer.str, '@');\n\n  if (! ptr)\n    ptr= definer.str;\n\n  len= ptr - definer.str;\n  definer_user.str= strmake_root(&mem_root, definer.str, len);\n  definer_user.length= len;\n  len= definer.length - len - 1;\n  /* 1:because of @ */\n  definer_host.str= strmake_root(&mem_root, ptr + 1,  len);\n  definer_host.length= len;\n\n  created= table->field[ET_FIELD_CREATED]->val_int();\n  modified= table->field[ET_FIELD_MODIFIED]->val_int();\n\n  comment.str= get_field(&mem_root, table->field[ET_FIELD_COMMENT]);\n  if (comment.str != NullS)\n    comment.length= strlen(comment.str);\n  else\n    comment.length= 0;\n\n  sql_mode= (ulong) table->field[ET_FIELD_SQL_MODE]->val_int();\n\n  DBUG_RETURN(FALSE);\n}\n\n\n/*\n  add_interval() adds a specified interval to time 'ltime' in time\n  zone 'time_zone', and returns the result converted to the number of\n  seconds since epoch (aka Unix time; in UTC time zone).  Zero result\n  means an error.\n*/\nstatic\nmy_time_t\nadd_interval(MYSQL_TIME *ltime, const Time_zone *time_zone,\n             interval_type scale, INTERVAL interval)\n{\n  if (date_add_interval(ltime, scale, interval))\n    return 0;\n\n  uint not_used;\n  return time_zone->TIME_to_gmt_sec(ltime, &not_used);\n}\n\n\n/*\n  Computes the sum of a timestamp plus interval.\n\n  SYNOPSIS\n    get_next_time()\n      time_zone     event time zone\n      next          the sum\n      start         add interval_value to this time\n      time_now      current time\n      i_value       quantity of time type interval to add\n      i_type        type of interval to add (SECOND, MINUTE, HOUR, WEEK ...)\n\n  RETURN VALUE\n    0  OK\n    1  Error\n\n  NOTES\n    1) If the interval is conversible to SECOND, like MINUTE, HOUR, DAY, WEEK.\n       Then we use TIMEDIFF()'s implementation as underlying and number of\n       seconds as resolution for computation.\n    2) In all other cases - MONTH, QUARTER, YEAR we use MONTH as resolution\n       and PERIOD_DIFF()'s implementation\n*/\n\nstatic\nbool get_next_time(const Time_zone *time_zone, my_time_t *next,\n                   my_time_t start, my_time_t time_now,\n                   int i_value, interval_type i_type)\n{\n  DBUG_ENTER(\"get_next_time\");\n  DBUG_PRINT(\"enter\", (\"start: %lu  now: %lu\", (long) start, (long) time_now));\n\n  DBUG_ASSERT(start <= time_now);\n\n  longlong months=0, seconds=0;\n\n  switch (i_type) {\n  case INTERVAL_YEAR:\n    months= i_value*12;\n    break;\n  case INTERVAL_QUARTER:\n    /* Has already been converted to months */\n  case INTERVAL_YEAR_MONTH:\n  case INTERVAL_MONTH:\n    months= i_value;\n    break;\n  case INTERVAL_WEEK:\n    /* WEEK has already been converted to days */\n  case INTERVAL_DAY:\n    seconds= i_value*24*3600;\n    break;\n  case INTERVAL_DAY_HOUR:\n  case INTERVAL_HOUR:\n    seconds= i_value*3600;\n    break;\n  case INTERVAL_DAY_MINUTE:\n  case INTERVAL_HOUR_MINUTE:\n  case INTERVAL_MINUTE:\n    seconds= i_value*60;\n    break;\n  case INTERVAL_DAY_SECOND:\n  case INTERVAL_HOUR_SECOND:\n  case INTERVAL_MINUTE_SECOND:\n  case INTERVAL_SECOND:\n    seconds= i_value;\n    break;\n  case INTERVAL_DAY_MICROSECOND:\n  case INTERVAL_HOUR_MICROSECOND:\n  case INTERVAL_MINUTE_MICROSECOND:\n  case INTERVAL_SECOND_MICROSECOND:\n  case INTERVAL_MICROSECOND:\n    /*\n     We should return an error here so SHOW EVENTS/ SELECT FROM I_S.EVENTS\n     would give an error then.\n    */\n    DBUG_RETURN(1);\n  case INTERVAL_LAST:\n    DBUG_ASSERT(0);\n  }\n  DBUG_PRINT(\"info\", (\"seconds: %ld  months: %ld\", (long) seconds, (long) months));\n\n  MYSQL_TIME local_start;\n  MYSQL_TIME local_now;\n\n  /* Convert times from UTC to local. */\n  {\n    time_zone->gmt_sec_to_TIME(&local_start, start);\n    time_zone->gmt_sec_to_TIME(&local_now, time_now);\n  }\n\n  INTERVAL interval;\n  bzero(&interval, sizeof(interval));\n  my_time_t next_time= 0;\n\n  if (seconds)\n  {\n    longlong seconds_diff;\n    long microsec_diff;\n    bool negative= calc_time_diff(&local_now, &local_start, 1,\n                                  &seconds_diff, &microsec_diff);\n    if (!negative)\n    {\n      /*\n        The formula below returns the interval that, when added to\n        local_start, will always give the time in the future.\n      */\n      interval.second= seconds_diff - seconds_diff % seconds + seconds;\n      next_time= add_interval(&local_start, time_zone,\n                              INTERVAL_SECOND, interval);\n      if (next_time == 0)\n        goto done;\n    }\n\n    if (next_time <= time_now)\n    {\n      /*\n        If 'negative' is true above, then 'next_time == 0', and\n        'next_time <= time_now' is also true.  If negative is false,\n        then next_time was set, but perhaps to the value that is less\n        then time_now.  See below for elaboration.\n      */\n      DBUG_ASSERT(negative || next_time > 0);\n\n      /*\n        If local_now < local_start, i.e. STARTS time is in the future\n        according to the local time (it always in the past according\n        to UTC---this is a prerequisite of this function), then\n        STARTS is almost always in the past according to the local\n        time too.  However, in the time zone that has backward\n        Daylight Saving Time shift, the following may happen: suppose\n        we have a backward DST shift at certain date after 2:59:59,\n        i.e. local time goes 1:59:59, 2:00:00, ... , 2:59:59, (shift\n        here) 2:00:00 (again), ... , 2:59:59 (again), 3:00:00, ... .\n        Now suppose the time has passed the first 2:59:59, has been\n        shifted backward, and now is (the second) 2:20:00.  The user\n        does CREATE EVENT with STARTS 'current-date 2:40:00'.  Local\n        time 2:40:00 from create statement is treated by time\n        functions as the first such time, so according to UTC it comes\n        before the second 2:20:00.  But according to local time it is\n        obviously in the future, so we end up in this branch.\n\n        Since we are in the second pass through 2:00:00--2:59:59, and\n        any local time form this interval is treated by system\n        functions as the time from the first pass, we have to find the\n        time for the next execution that is past the DST-affected\n        interval (past the second 2:59:59 for our example,\n        i.e. starting from 3:00:00).  We do this in the loop until the\n        local time is mapped onto future UTC time.  'start' time is in\n        the past, so we may use 'do { } while' here, and add the first\n        interval right away.\n\n        Alternatively, it could be that local_now >= local_start.  Now\n        for the example above imagine we do CREATE EVENT with STARTS\n        'current-date 2:10:00'.  Local start 2:10 is in the past (now\n        is local 2:20), so we add an interval, and get next execution\n        time, say, 2:40.  It is in the future according to local time,\n        but, again, since we are in the second pass through\n        2:00:00--2:59:59, 2:40 will be converted into UTC time in the\n        past.  So we will end up in this branch again, and may add\n        intervals in a 'do { } while' loop.\n\n        Note that for any given event we may end up here only if event\n        next execution time will map to the time interval that is\n        passed twice, and only if the server was started during the\n        second pass, or the event is being created during the second\n        pass.  After that, we never will get here (unless we again\n        start the server during the second pass).  In other words,\n        such a condition is extremely rare.\n      */\n      interval.second= seconds;\n      do\n      {\n        next_time= add_interval(&local_start, time_zone,\n                                INTERVAL_SECOND, interval);\n        if (next_time == 0)\n          goto done;\n      }\n      while (next_time <= time_now);\n    }\n  }\n  else\n  {\n    long diff_months= ((long) local_now.year - (long) local_start.year)*12 +\n                      ((long) local_now.month - (long) local_start.month);\n\n    /*\n      Unlike for seconds above, the formula below returns the interval\n      that, when added to the local_start, will give the time in the\n      past, or somewhere in the current month.  We are interested in\n      the latter case, to see if this time has already passed, or is\n      yet to come this month.\n\n      Note that the time is guaranteed to be in the past unless\n      (diff_months % months == 0), but no good optimization is\n      possible here, because (diff_months % months == 0) is what will\n      happen most of the time, as get_next_time() will be called right\n      after the execution of the event.  We could pass last_executed\n      time to this function, and see if the execution has already\n      happened this month, but for that we will have to convert\n      last_executed from seconds since epoch to local broken-down\n      time, and this will greatly reduce the effect of the\n      optimization.  So instead we keep the code simple and clean.\n    */\n    interval.month= (ulong) (diff_months - diff_months % months);\n    next_time= add_interval(&local_start, time_zone,\n                            INTERVAL_MONTH, interval);\n    if (next_time == 0)\n      goto done;\n\n    if (next_time <= time_now)\n    {\n      interval.month= (ulong) months;\n      next_time= add_interval(&local_start, time_zone,\n                              INTERVAL_MONTH, interval);\n      if (next_time == 0)\n        goto done;\n    }\n  }\n\n  DBUG_ASSERT(time_now < next_time);\n\n  *next= next_time;\n\ndone:\n  DBUG_PRINT(\"info\", (\"next_time: %ld\", (long) next_time));\n  DBUG_RETURN(next_time == 0);\n}\n\n\n/*\n  Computes next execution time.\n\n  SYNOPSIS\n    Event_queue_element::compute_next_execution_time()\n\n  RETURN VALUE\n    FALSE  OK\n    TRUE   Error\n\n  NOTES\n    The time is set in execute_at, if no more executions the latter is\n    set to 0.\n*/\n\nbool\nEvent_queue_element::compute_next_execution_time()\n{\n  my_time_t time_now;\n  DBUG_ENTER(\"Event_queue_element::compute_next_execution_time\");\n  DBUG_PRINT(\"enter\", (\"starts: %lu  ends: %lu  last_executed: %lu  this: %p\",\n                       (long) starts, (long) ends, (long) last_executed,\n                       this));\n\n  if (status != Event_parse_data::ENABLED)\n  {\n    DBUG_PRINT(\"compute_next_execution_time\",\n               (\"Event %s is DISABLED\", name.str));\n    goto ret;\n  }\n  /* If one-time, no need to do computation */\n  if (!expression)\n  {\n    /* Let's check whether it was executed */\n    if (last_executed)\n    {\n      DBUG_PRINT(\"info\",(\"One-time event %s.%s of was already executed\",\n                         dbname.str, name.str));\n      dropped= (on_completion == Event_parse_data::ON_COMPLETION_DROP);\n      DBUG_PRINT(\"info\",(\"One-time event will be dropped: %d.\", dropped));\n\n      status= Event_parse_data::DISABLED;\n    }\n    goto ret;\n  }\n\n  time_now= current_thd->query_start();\n\n  DBUG_PRINT(\"info\",(\"NOW: [%lu]\", (ulong) time_now));\n\n  /* if time_now is after ends don't execute anymore */\n  if (!ends_null && ends < time_now)\n  {\n    DBUG_PRINT(\"info\", (\"NOW after ENDS, don't execute anymore\"));\n    /* time_now is after ends. don't execute anymore */\n    execute_at= 0;\n    execute_at_null= TRUE;\n    if (on_completion == Event_parse_data::ON_COMPLETION_DROP)\n      dropped= TRUE;\n    DBUG_PRINT(\"info\", (\"Dropped: %d\", dropped));\n    status= Event_parse_data::DISABLED;\n\n    goto ret;\n  }\n\n  /*\n    Here time_now is before or equals ends if the latter is set.\n    Let's check whether time_now is before starts.\n    If so schedule for starts.\n  */\n  if (!starts_null && time_now <= starts)\n  {\n    if (time_now == starts && starts == last_executed)\n    {\n      /*\n        do nothing or we will schedule for second time execution at starts.\n      */\n    }\n    else\n    {\n      DBUG_PRINT(\"info\", (\"STARTS is future, NOW <= STARTS,sched for STARTS\"));\n      /*\n        starts is in the future\n        time_now before starts. Scheduling for starts\n      */\n      execute_at= starts;\n      execute_at_null= FALSE;\n      goto ret;\n    }\n  }\n\n  if (!starts_null && !ends_null)\n  {\n    /*\n      Both starts and m_ends are set and time_now is between them (incl.)\n      If last_executed is set then increase with m_expression. The new MYSQL_TIME is\n      after m_ends set execute_at to 0. And check for on_completion\n      If not set then schedule for now.\n    */\n    DBUG_PRINT(\"info\", (\"Both STARTS & ENDS are set\"));\n    if (!last_executed)\n    {\n      DBUG_PRINT(\"info\", (\"Not executed so far.\"));\n    }\n\n    {\n      my_time_t next_exec;\n\n      if (get_next_time(time_zone, &next_exec, starts, time_now,\n                        (int) expression, interval))\n        goto err;\n\n      /* There was previous execution */\n      if (ends < next_exec)\n      {\n        DBUG_PRINT(\"info\", (\"Next execution of %s after ENDS. Stop executing.\",\n                   name.str));\n        /* Next execution after ends. No more executions */\n        execute_at= 0;\n        execute_at_null= TRUE;\n        if (on_completion == Event_parse_data::ON_COMPLETION_DROP)\n          dropped= TRUE;\n        status= Event_parse_data::DISABLED;\n      }\n      else\n      {\n        DBUG_PRINT(\"info\",(\"Next[%lu]\", (ulong) next_exec));\n        execute_at= next_exec;\n        execute_at_null= FALSE;\n      }\n    }\n    goto ret;\n  }\n  else if (starts_null && ends_null)\n  {\n    /* starts is always set, so this is a dead branch !! */\n    DBUG_PRINT(\"info\", (\"Neither STARTS nor ENDS are set\"));\n    /*\n      Both starts and m_ends are not set, so we schedule for the next\n      based on last_executed.\n    */\n    if (last_executed)\n    {\n      my_time_t next_exec;\n      if (get_next_time(time_zone, &next_exec, starts, time_now,\n                        (int) expression, interval))\n        goto err;\n      execute_at= next_exec;\n      DBUG_PRINT(\"info\",(\"Next[%lu]\", (ulong) next_exec));\n    }\n    else\n    {\n      /* last_executed not set. Schedule the event for now */\n      DBUG_PRINT(\"info\", (\"Execute NOW\"));\n      execute_at= time_now;\n    }\n    execute_at_null= FALSE;\n  }\n  else\n  {\n    /* either starts or m_ends is set */\n    if (!starts_null)\n    {\n      DBUG_PRINT(\"info\", (\"STARTS is set\"));\n      /*\n        - starts is set.\n        - starts is not in the future according to check made before\n        Hence schedule for starts + m_expression in case last_executed\n        is not set, otherwise to last_executed + m_expression\n      */\n      if (!last_executed)\n      {\n        DBUG_PRINT(\"info\", (\"Not executed so far.\"));\n      }\n\n      {\n        my_time_t next_exec;\n        if (get_next_time(time_zone, &next_exec, starts, time_now,\n                          (int) expression, interval))\n          goto err;\n        execute_at= next_exec;\n        DBUG_PRINT(\"info\",(\"Next[%lu]\", (ulong) next_exec));\n      }\n      execute_at_null= FALSE;\n    }\n    else\n    {\n      /* this is a dead branch, because starts is always set !!! */\n      DBUG_PRINT(\"info\", (\"STARTS is not set. ENDS is set\"));\n      /*\n        - m_ends is set\n        - m_ends is after time_now or is equal\n        Hence check for m_last_execute and increment with m_expression.\n        If last_executed is not set then schedule for now\n      */\n\n      if (!last_executed)\n        execute_at= time_now;\n      else\n      {\n        my_time_t next_exec;\n\n        if (get_next_time(time_zone, &next_exec, starts, time_now,\n                          (int) expression, interval))\n          goto err;\n\n        if (ends < next_exec)\n        {\n          DBUG_PRINT(\"info\", (\"Next execution after ENDS. Stop executing.\"));\n          execute_at= 0;\n          execute_at_null= TRUE;\n          status= Event_parse_data::DISABLED;\n          if (on_completion == Event_parse_data::ON_COMPLETION_DROP)\n            dropped= TRUE;\n        }\n        else\n        {\n          DBUG_PRINT(\"info\", (\"Next[%lu]\", (ulong) next_exec));\n          execute_at= next_exec;\n          execute_at_null= FALSE;\n        }\n      }\n    }\n    goto ret;\n  }\nret:\n  DBUG_PRINT(\"info\", (\"ret: 0 execute_at: %lu\", (long) execute_at));\n  DBUG_RETURN(FALSE);\nerr:\n  DBUG_PRINT(\"info\", (\"ret=1\"));\n  DBUG_RETURN(TRUE);\n}\n\n\n/*\n  Set the internal last_executed MYSQL_TIME struct to now. NOW is the\n  time according to thd->query_start(), so the THD's clock.\n\n  SYNOPSIS\n    Event_queue_element::mark_last_executed()\n      thd   thread context\n*/\n\nvoid\nEvent_queue_element::mark_last_executed(THD *thd)\n{\n  last_executed= thd->query_start();\n\n  execution_count++;\n}\n\n\nstatic\nvoid\nappend_datetime(String *buf, Time_zone *time_zone, my_time_t secs,\n                const char *name, uint len)\n{\n  char dtime_buff[20*2+32];/* +32 to make my_snprintf_{8bit|ucs2} happy */\n  buf->append(STRING_WITH_LEN(\" \"));\n  buf->append(name, len);\n  buf->append(STRING_WITH_LEN(\" '\"));\n  /*\n    Pass the buffer and the second param tells fills the buffer and\n    returns the number of chars to copy.\n  */\n  MYSQL_TIME time;\n  time_zone->gmt_sec_to_TIME(&time, secs);\n  buf->append(dtime_buff, my_datetime_to_str(&time, dtime_buff, 0));\n  buf->append(STRING_WITH_LEN(\"'\"));\n}\n\n\n/*\n  Get SHOW CREATE EVENT as string\n\n  SYNOPSIS\n    Event_timed::get_create_event(THD *thd, String *buf)\n      thd    Thread\n      buf    String*, should be already allocated. CREATE EVENT goes inside.\n\n  RETURN VALUE\n    0                       OK\n    EVEX_MICROSECOND_UNSUP  Error (for now if mysql.event has been\n                            tampered and MICROSECONDS interval or\n                            derivative has been put there.\n*/\n\nint\nEvent_timed::get_create_event(THD *thd, String *buf)\n{\n  char tmp_buf[2 * STRING_BUFFER_USUAL_SIZE];\n  String expr_buf(tmp_buf, sizeof(tmp_buf), system_charset_info);\n  expr_buf.length(0);\n\n  DBUG_ENTER(\"get_create_event\");\n  DBUG_PRINT(\"ret_info\",(\"body_len=[%d]body=[%s]\",\n                         (int) body.length, body.str));\n\n  if (expression && Events::reconstruct_interval_expression(&expr_buf, interval,\n                                                            expression))\n    DBUG_RETURN(EVEX_MICROSECOND_UNSUP);\n\n  buf->append(STRING_WITH_LEN(\"CREATE \"));\n  append_definer(thd, buf, &definer_user, &definer_host);\n  buf->append(STRING_WITH_LEN(\"EVENT \"));\n  append_identifier(thd, buf, name.str, name.length);\n\n  if (expression)\n  {\n    buf->append(STRING_WITH_LEN(\" ON SCHEDULE EVERY \"));\n    buf->append(expr_buf);\n    buf->append(' ');\n    LEX_STRING *ival= &interval_type_to_name[interval];\n    buf->append(ival->str, ival->length);\n\n    if (!starts_null)\n      append_datetime(buf, time_zone, starts, STRING_WITH_LEN(\"STARTS\"));\n\n    if (!ends_null)\n      append_datetime(buf, time_zone, ends, STRING_WITH_LEN(\"ENDS\"));\n  }\n  else\n  {\n    append_datetime(buf, time_zone, execute_at,\n                    STRING_WITH_LEN(\"ON SCHEDULE AT\"));\n  }\n\n  if (on_completion == Event_parse_data::ON_COMPLETION_DROP)\n    buf->append(STRING_WITH_LEN(\" ON COMPLETION NOT PRESERVE \"));\n  else\n    buf->append(STRING_WITH_LEN(\" ON COMPLETION PRESERVE \"));\n\n  if (status == Event_parse_data::ENABLED)\n    buf->append(STRING_WITH_LEN(\"ENABLE\"));\n  else if (status == Event_parse_data::SLAVESIDE_DISABLED)\n    buf->append(STRING_WITH_LEN(\"DISABLE ON SLAVE\"));\n  else\n    buf->append(STRING_WITH_LEN(\"DISABLE\"));\n\n  if (comment.length)\n  {\n    buf->append(STRING_WITH_LEN(\" COMMENT \"));\n    append_unescaped(buf, comment.str, comment.length);\n  }\n  buf->append(STRING_WITH_LEN(\" DO \"));\n  buf->append(body.str, body.length);\n\n  DBUG_RETURN(0);\n}\n\n\n/**\n  Get an artificial stored procedure to parse as an event definition.\n*/\n\nbool\nEvent_job_data::construct_sp_sql(THD *thd, String *sp_sql)\n{\n  LEX_STRING buffer;\n  const uint STATIC_SQL_LENGTH= 44;\n\n  DBUG_ENTER(\"Event_job_data::construct_sp_sql\");\n\n  /*\n    Allocate a large enough buffer on the thread execution memory\n    root to avoid multiple [re]allocations on system heap\n  */\n  buffer.length= STATIC_SQL_LENGTH + name.length + body.length;\n  if (! (buffer.str= (char*) thd->alloc(buffer.length)))\n    DBUG_RETURN(TRUE);\n\n  sp_sql->set(buffer.str, buffer.length, system_charset_info);\n  sp_sql->length(0);\n\n\n  sp_sql->append(C_STRING_WITH_LEN(\"CREATE \"));\n  sp_sql->append(C_STRING_WITH_LEN(\"PROCEDURE \"));\n  /*\n    Let's use the same name as the event name to perhaps produce a\n    better error message in case it is a part of some parse error.\n    We're using append_identifier here to successfully parse\n    events with reserved names.\n  */\n  append_identifier(thd, sp_sql, name.str, name.length);\n\n  /*\n    The default SQL security of a stored procedure is DEFINER. We\n    have already activated the security context of the event, so\n    let's execute the procedure with the invoker rights to save on\n    resets of security contexts.\n  */\n  sp_sql->append(C_STRING_WITH_LEN(\"() SQL SECURITY INVOKER \"));\n\n  sp_sql->append(body.str, body.length);\n\n  DBUG_RETURN(thd->is_fatal_error);\n}\n\n\n/**\n  Get DROP EVENT statement to binlog the drop of ON COMPLETION NOT\n  PRESERVE event.\n*/\n\nbool\nEvent_job_data::construct_drop_event_sql(THD *thd, String *sp_sql)\n{\n  LEX_STRING buffer;\n  const uint STATIC_SQL_LENGTH= 14;\n\n  DBUG_ENTER(\"Event_job_data::construct_drop_event_sql\");\n\n  buffer.length= STATIC_SQL_LENGTH + name.length*2 + dbname.length*2;\n  if (! (buffer.str= (char*) thd->alloc(buffer.length)))\n    DBUG_RETURN(TRUE);\n\n  sp_sql->set(buffer.str, buffer.length, system_charset_info);\n  sp_sql->length(0);\n\n  sp_sql->append(C_STRING_WITH_LEN(\"DROP EVENT \"));\n  append_identifier(thd, sp_sql, dbname.str, dbname.length);\n  sp_sql->append('.');\n  append_identifier(thd, sp_sql, name.str, name.length);\n\n  DBUG_RETURN(thd->is_fatal_error);\n}\n\n/**\n  Compiles and executes the event (the underlying sp_head object)\n\n  @retval TRUE  error (reported to the error log)\n  @retval FALSE success\n*/\n\nbool\nEvent_job_data::execute(THD *thd, bool drop)\n{\n  String sp_sql;\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n  Security_context event_sctx, *save_sctx= NULL;\n#endif\n  List<Item> empty_item_list;\n  bool ret= TRUE;\n\n  DBUG_ENTER(\"Event_job_data::execute\");\n\n  thd->reset_for_next_command();\n\n  /*\n    MySQL parser currently assumes that current database is either\n    present in THD or all names in all statements are fully specified.\n    And yet not fully specified names inside stored programs must be \n    be supported, even if the current database is not set:\n    CREATE PROCEDURE db1.p1() BEGIN CREATE TABLE t1; END//\n    -- in this example t1 should be always created in db1 and the statement\n    must parse even if there is no current database.\n\n    To support this feature and still address the parser limitation,\n    we need to set the current database here.\n    We don't have to call mysql_change_db, since the checks performed\n    in it are unnecessary for the purpose of parsing, and\n    mysql_change_db will be invoked anyway later, to activate the\n    procedure database before it's executed.\n  */\n  thd->set_db(dbname.str, dbname.length);\n\n  lex_start(thd);\n\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n  if (event_sctx.change_security_context(thd,\n                                         &definer_user, &definer_host,\n                                         &dbname, &save_sctx))\n  {\n    sql_print_error(\"Event Scheduler: \"\n                    \"[%s].[%s.%s] execution failed, \"\n                    \"failed to authenticate the user.\",\n                    definer.str, dbname.str, name.str);\n    goto end;\n  }\n#endif\n\n  if (check_access(thd, EVENT_ACL, dbname.str, NULL, NULL, 0, 0))\n  {\n    /*\n      This aspect of behavior is defined in the worklog,\n      and this is how triggers work too: if TRIGGER\n      privilege is revoked from trigger definer,\n      triggers are not executed.\n    */\n    sql_print_error(\"Event Scheduler: \"\n                    \"[%s].[%s.%s] execution failed, \"\n                    \"user no longer has EVENT privilege.\",\n                    definer.str, dbname.str, name.str);\n    goto end;\n  }\n\n  if (construct_sp_sql(thd, &sp_sql))\n    goto end;\n\n  /*\n    Set up global thread attributes to reflect the properties of\n    this Event. We can simply reset these instead of usual\n    backup/restore employed in stored programs since we know that\n    this is a top level statement and the worker thread is\n    allocated exclusively to execute this event.\n  */\n\n  thd->variables.sql_mode= sql_mode;\n  thd->variables.time_zone= time_zone;\n\n  thd->set_query(sp_sql.c_ptr_safe(), sp_sql.length());\n\n  {\n    Parser_state parser_state;\n    if (parser_state.init(thd, thd->query(), thd->query_length()))\n      goto end;\n\n    if (parse_sql(thd, & parser_state, creation_ctx))\n    {\n      sql_print_error(\"Event Scheduler: \"\n                      \"%serror during compilation of %s.%s\",\n                      thd->is_fatal_error ? \"fatal \" : \"\",\n                      (const char *) dbname.str, (const char *) name.str);\n      goto end;\n    }\n  }\n\n  {\n    sp_head *sphead= thd->lex->sphead;\n\n    DBUG_ASSERT(sphead);\n\n    sphead->m_flags|= sp_head::LOG_SLOW_STATEMENTS;\n    sphead->m_flags|= sp_head::LOG_GENERAL_LOG;\n\n    sphead->set_info(0, 0, &thd->lex->sp_chistics, sql_mode);\n    sphead->set_creation_ctx(creation_ctx);\n    sphead->optimize();\n\n    ret= sphead->execute_procedure(thd, &empty_item_list);\n    /*\n      There is no pre-locking and therefore there should be no\n      tables open and locked left after execute_procedure.\n    */\n  }\n\nend:\n  if (drop && !thd->is_fatal_error)\n  {\n    /*\n      We must do it here since here we're under the right authentication\n      ID of the event definer.\n    */\n    sql_print_information(\"Event Scheduler: Dropping %s.%s\",\n                          (const char *) dbname.str, (const char *) name.str);\n    /*\n      Construct a query for the binary log, to ensure the event is dropped\n      on the slave\n    */\n    if (construct_drop_event_sql(thd, &sp_sql))\n      ret= 1;\n    else\n    {\n      ulong saved_master_access;\n\n      thd->set_query(sp_sql.c_ptr_safe(), sp_sql.length());\n\n      /*\n        NOTE: even if we run in read-only mode, we should be able to lock\n        the mysql.event table for writing. In order to achieve this, we\n        should call mysql_lock_tables() under the super-user.\n\n        Same goes for transaction access mode.\n        Temporarily reset it to read-write.\n      */\n\n      saved_master_access= thd->security_ctx->master_access;\n      thd->security_ctx->master_access |= SUPER_ACL;\n      bool save_tx_read_only= thd->tx_read_only;\n      thd->tx_read_only= false;\n\n      /*\n         This code is processing event execution and does not have client\n         connection. Here, event execution will now execute a prepared\n         DROP EVENT statement, but thd->lex->sql_command is set to\n         SQLCOM_CREATE_PROCEDURE\n         DROP EVENT will be logged in binlog, and we have to\n         replicate it to make all nodes have consistent event definitions\n         Wsrep DDL replication is triggered inside Events::drop_event(),\n         and here we need to prepare the THD so that DDL replication is\n         possible, essentially it requires setting sql_command to\n         SQLCOMM_DROP_EVENT, we will switch sql_command for the duration\n         of DDL replication only.\n      */\n      const enum_sql_command sql_command_save= thd->lex->sql_command;\n      const bool sql_command_set= WSREP(thd);\n\n      if (sql_command_set)\n        thd->lex->sql_command = SQLCOM_DROP_EVENT;\n\n      ret= Events::drop_event(thd, dbname, name, FALSE);\n\n      if (sql_command_set)\n      {\n        WSREP_TO_ISOLATION_END;\n        thd->lex->sql_command = sql_command_save;\n      }\n\n      thd->tx_read_only= save_tx_read_only;\n      thd->security_ctx->master_access= saved_master_access;\n    }\n  }\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n  if (save_sctx)\n    event_sctx.restore_security_context(thd, save_sctx);\n#endif\n  thd->lex->unit.cleanup();\n  thd->end_statement();\n  thd->cleanup_after_query();\n  /* Avoid races with SHOW PROCESSLIST */\n  thd->reset_query();\n\n  DBUG_PRINT(\"info\", (\"EXECUTED %s.%s  ret: %d\", dbname.str, name.str, ret));\n\n  DBUG_RETURN(ret);\n}\n\n\n/*\n  Checks whether two events are in the same schema\n\n  SYNOPSIS\n    event_basic_db_equal()\n      db  Schema\n      et  Compare et->dbname to `db`\n\n  RETURN VALUE\n    TRUE   Equal\n    FALSE  Not equal\n*/\n\nbool\nevent_basic_db_equal(LEX_STRING db, Event_basic *et)\n{\n  return !sortcmp_lex_string(et->dbname, db, system_charset_info);\n}\n\n\n/*\n  Checks whether an event has equal `db` and `name`\n\n  SYNOPSIS\n    event_basic_identifier_equal()\n      db   Schema\n      name Name\n      et   The event object\n\n  RETURN VALUE\n    TRUE   Equal\n    FALSE  Not equal\n*/\n\nbool\nevent_basic_identifier_equal(LEX_STRING db, LEX_STRING name, Event_basic *b)\n{\n  return !sortcmp_lex_string(name, b->name, system_charset_info) &&\n         !sortcmp_lex_string(db, b->dbname, system_charset_info);\n}\n\n/**\n  @} (End of group Event_Scheduler)\n*/\n"], "filenames": ["sql/event_data_objects.cc"], "buggy_code_start_loc": [1475], "buggy_code_end_loc": [1488], "fixing_code_start_loc": [1475], "fixing_code_end_loc": [1501], "type": "NVD-CWE-noinfo", "message": "sql/event_data_objects.cc in MariaDB before 10.1.30 and 10.2.x before 10.2.10 and Percona XtraDB Cluster before 5.6.37-26.21-3 and 5.7.x before 5.7.19-29.22-3 allows remote authenticated users with SQL access to bypass intended access restrictions and replicate data definition language (DDL) statements to cluster nodes by leveraging incorrect ordering of DDL replication and ACL checking.", "other": {"cve": {"id": "CVE-2017-15365", "sourceIdentifier": "cve@mitre.org", "published": "2018-01-25T16:29:00.290", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "sql/event_data_objects.cc in MariaDB before 10.1.30 and 10.2.x before 10.2.10 and Percona XtraDB Cluster before 5.6.37-26.21-3 and 5.7.x before 5.7.19-29.22-3 allows remote authenticated users with SQL access to bypass intended access restrictions and replicate data definition language (DDL) statements to cluster nodes by leveraging incorrect ordering of DDL replication and ACL checking."}, {"lang": "es", "value": "sql/event_data_objects.cc en MariaDB en versiones anteriores a la 10.1.30 y 10.2.x anteriores a la 10.2.10 y Percona XtraDB Cluster anterior a 5.6.37-26.21-3 y 5.7.x anteriores a 5.7.19-29.22-3 permite que los usuarios autenticados remotos con acceso SQL omitan las restricciones de acceso y repliquen las sentencias DDL (Data Definition Language) para agrupar nodos utilizando una orden de replicaci\u00f3n de DDL y una comprobaci\u00f3n de listas de control de acceso incorrectas."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:26:*:*:*:*:*:*:*", "matchCriteriaId": "6E4D8269-B407-4C24-AAB0-02F885C7D752"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mariadb:mariadb:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.1.30", "matchCriteriaId": "44E9AB36-D550-4453-AF71-557A54F8DF2B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mariadb:mariadb:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.2.0", "versionEndExcluding": "10.2.10", "matchCriteriaId": "9CAD3CAD-7960-408C-B159-D514A6584D41"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:percona:xtradb_cluster:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.6.37-26.21-3", "matchCriteriaId": "25227672-0E31-48F9-847F-EA2B48650B74"}, {"vulnerable": true, "criteria": "cpe:2.3:a:percona:xtradb_cluster:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.7.0", "versionEndExcluding": "5.7.19-29.22-3", "matchCriteriaId": "D6CFE182-20B2-4A96-A705-2F4700282CE1"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2019:1258", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1524234", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/MariaDB/server/commit/0b5a5258abbeaf8a0c3a18c7e753699787fdf46e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ELCZV46WIYSJ6VMC65GMNN3A3QDRUJGK/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://mariadb.com/kb/en/library/mariadb-10130-release-notes/", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://mariadb.com/kb/en/library/mariadb-10210-release-notes/", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4341", "source": "cve@mitre.org"}, {"url": "https://www.percona.com/blog/2017/10/30/percona-xtradb-cluster-5-6-37-26-21-3-is-now-available/", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://www.percona.com/doc/percona-xtradb-cluster/LATEST/release-notes/Percona-XtraDB-Cluster-5.7.19-29.22-3.html", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/MariaDB/server/commit/0b5a5258abbeaf8a0c3a18c7e753699787fdf46e"}}