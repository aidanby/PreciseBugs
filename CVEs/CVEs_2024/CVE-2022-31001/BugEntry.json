{"buggy_code": ["/*\n * This file is part of the Sofia-SIP package\n *\n * Copyright (C) 2005 Nokia Corporation.\n *\n * Contact: Pekka Pessi <pekka.pessi@nokia.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA\n *\n */\n\n/**@ingroup sip_parser\n * @CFILE sip_parser.c\n *\n * SIP parser.\n *\n * @author Pekka Pessi <Pekka.Pessi@nokia.com>.\n *\n * @date Created: Thu Oct  5 14:01:24 2000 ppessi\n */\n\n#include \"config.h\"\n\n/* Avoid casting sip_t to msg_pub_t and sip_header_t to msg_header_t */\n#define MSG_PUB_T       struct sip_s\n#define MSG_HDR_T       union sip_header_u\n\n#include <sofia-sip/su_tagarg.h>\n#include <sofia-sip/su_string.h>\n#include \"sofia-sip/sip_parser.h\"\n#include <sofia-sip/msg_mclass.h>\n\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <assert.h>\n#include <limits.h>\n\n#ifndef UINT32_MAX\n#define UINT32_MAX (0xffffffffU)\n#endif\n\n/** Version of the SIP module */\nchar const sip_parser_version[] = VERSION;\n\n/** SIP version 2.0. */\nchar const sip_version_2_0[] = \"SIP/2.0\";\n\n/** Default message class */\nextern msg_mclass_t sip_mclass[];\n\nstatic msg_mclass_t const *_default = sip_mclass;\nstatic msg_mclass_t *_default_parser_cloned = NULL;\n\n/** Return a built-in SIP parser object. */\nmsg_mclass_t const *sip_default_mclass(void)\n{\n  return _default;\n}\n\n/** Restore default SIP parser to non-extended */\nvoid sip_default_mclass_restore() {\n\t_default = sip_mclass;\n}\n\n/** Destroy SIP parser object */\nvoid sip_destroy_mclass(msg_mclass_t *mclass) {\n\tif (mclass && mclass != sip_mclass) {\n\t\tif (mclass == _default_parser_cloned) {\n\t\t\tsip_cloned_parser_destroy();\n\t\t} else {\n\t\t\tif (mclass == _default) {\n\t\t\t\tsip_default_mclass_restore();\n\t\t\t}\n\t\t\tfree(mclass);\n\t\t}\n\t}\n}\n\n/** Release SIP parser object if it was cloned. */\nvoid sip_cloned_parser_destroy(void)\n{\n\tif (_default_parser_cloned) {\n\t\tif (_default_parser_cloned == _default) {\n\t\t\tsip_default_mclass_restore();\n\t\t}\n\n\t\tfree(_default_parser_cloned);\n\t\t_default_parser_cloned = NULL;\n\t}\n}\n\n/** Update the default SIP parser.\n *\n * Use the extended SIP parser as default one.\n *\n * If the applications want to use headers added after @VERSION_1_12_5,\n * they should call this function before doing any other initialization, e.g.,\n * @code\n *   su_init();\n *   if (sip_update_default_mclass(sip_extend_mclass(NULL)) < 0) {\n *     su_deinit();\n *     exit(2);\n *   }\n * @endcode\n * When finish don't forget to call \n * @code\n *   sip_destroy_mclass(sip_default_mclass());\n * @endcode\n * as return of sip_extend_mclass(NULL) requires to be freed.\n *\n * The default parser is not extended because it may break the old\n * applications looking for extension headers from sip_unknown list.\n *\n * @retval 0 when successful\n * @retval -1 upon an error\n *\n * @sa sip_extend_mclass()\n *\n * @NEW_1_12_7.\n */\nint sip_update_default_mclass(msg_mclass_t const *mclass)\n{\n  if (mclass == NULL)\n    return -1;\n  _default = mclass;\n  return 0;\n}\n\n/**Extend SIP parser class with extension headers.\n *\n * Extend given SIP parser class with extension headers. If the given parser\n * (message class) is the default one or NULL, make a clone of default\n * parser before extending it.\n *\n * @param input pointer to a SIP message class (may be NULL)\n *\n * @return Pointer to extended mclass, or NULL upon an error.\n *\n * @sa\n * @AlertInfo,\n * @ReplyTo,\n * @RemotePartyId,\n * @PAssertedIdentity,\n * @PPreferredIdentity,\n * @SuppressBodyIfMatch,\n * @SuppressNotifyIfMatch\n *\n * @NEW_1_12_7.\n */\nmsg_mclass_t *sip_extend_mclass(msg_mclass_t *input)\n{\n  msg_mclass_t *mclass;\n\n  if (input == NULL || input == _default) {\n    _default_parser_cloned = msg_mclass_clone(_default, 0, 0);\n    mclass = _default_parser_cloned;\n  } else {\n    mclass = input;\n  }\n\n  if (mclass) {\n    extern msg_hclass_t * const sip_extensions[];\n    int i;\n\n    for (i = 0; sip_extensions[i]; i++) {\n      msg_hclass_t *hclass = sip_extensions[i];\n      if (mclass->mc_unknown != msg_find_hclass(mclass, hclass->hc_name, NULL))\n\tcontinue;\n\n      if (msg_mclass_insert_header(mclass, hclass, 0) < 0) {\n        if (input != mclass) {\n          sip_destroy_mclass(mclass);\n        }\n        return mclass = NULL;\n      }\n    }\n  }\n\n  return mclass;\n}\n\n/** Extract the SIP message body, including separator line.\n *\n * @param msg  message object [IN]\n * @param sip  public SIP message structure [IN/OUT]\n * @param b    buffer containing unparsed data [IN]\n * @param bsiz buffer size [IN]\n * @param eos  true if buffer contains whole message [IN]\n *\n * @retval -1 error\n * @retval 0  cannot proceed\n * @retval m\n */\nissize_t sip_extract_body(msg_t *msg, sip_t *sip, char b[], isize_t bsiz, int eos)\n{\n  ssize_t m = 0;\n  size_t body_len;\n\n  if (!(sip->sip_flags & MSG_FLG_BODY)) {\n    /* We are looking at a potential empty line */\n    m = msg_extract_separator(msg, (msg_pub_t *)sip, b, bsiz, eos);\n    if (m <= 0)\n      return m;\n    sip->sip_flags |= MSG_FLG_BODY;\n    b += m;\n    bsiz -= m;\n  }\n\n  if (sip->sip_content_length)\n    body_len = sip->sip_content_length->l_length;\n  else if (MSG_IS_MAILBOX(sip->sip_flags)) /* message fragments */\n    body_len = 0;\n  else if (eos)\n    body_len = bsiz;\n  else if (bsiz == 0)\n    return m;\n  else\n    return -1;\n\n  if (body_len == 0) {\n    sip->sip_flags |= MSG_FLG_COMPLETE;\n    return m;\n  }\n\n  if (m)\n    return m;\n\n  if (eos && body_len > bsiz) {\n    sip->sip_flags |= MSG_FLG_TRUNC | MSG_FLG_ERROR;\n    return bsiz;\n  }\n\n  if ((m = msg_extract_payload(msg, (msg_pub_t *)sip,\n\t\t\t       NULL, body_len, b, bsiz, eos)) == -1)\n    return -1;\n\n  sip->sip_flags |= MSG_FLG_FRAGS;\n  if (bsiz >= body_len)\n    sip->sip_flags |= MSG_FLG_COMPLETE;\n\n  return m;\n}\n\n/** Parse SIP version.\n *\n * Parse a SIP version string. Update the\n * pointer at @a ss to first non-LWS character after the version string.\n *\n * @param ss   string to be parsed [IN/OUT]\n * @param ver  value result for version [OUT]\n *\n * @retval 0 when successful,\n * @retval -1 upon an error.\n */\nint sip_version_d(char **ss, char const **ver)\n{\n  char *s = *ss;\n  char const *result;\n  size_t const version_size = sizeof(sip_version_2_0) - 1;\n\n  if (su_casenmatch(s, sip_version_2_0, version_size) &&\n      !IS_TOKEN(s[version_size])) {\n    result = sip_version_2_0;\n    s += version_size;\n  }\n  else {\n    /* Version consists of two tokens, separated by / */\n    size_t l1 = 0, l2 = 0, n;\n\n    result = s;\n\n    l1 = span_token(s);\n    for (n = l1; IS_LWS(s[n]); n++)\n      {}\n    if (s[n] == '/') {\n      for (n++; IS_LWS(s[n]); n++)\n        {}\n      l2 = span_token(s + n);\n      n += l2;\n    }\n\n    if (l1 == 0 || l2 == 0)\n      return -1;\n\n    /* If there is extra ws between tokens, compact version */\n    if (n > l1 + 1 + l2) {\n      s[l1] = '/';\n      memmove(s + l1 + 1, s + n - l2, l2);\n      s[l1 + 1 + l2] = 0;\n\n      /* Compare again with compacted version */\n      if (su_casematch(s, sip_version_2_0))\n\tresult = sip_version_2_0;\n    }\n\n    s += n;\n  }\n\n  while (IS_WS(*s)) *s++ = '\\0';\n\n  *ss = s;\n\n  if (ver)\n    *ver = result;\n\n  return 0;\n}\n\n/** Calculate extra space required by version string */\nisize_t sip_version_xtra(char const *version)\n{\n  if (version == SIP_VERSION_CURRENT)\n    return 0;\n  return MSG_STRING_SIZE(version);\n}\n\n/** Duplicate a transport string */\nvoid sip_version_dup(char **pp, char const **dd, char const *s)\n{\n  if (s == SIP_VERSION_CURRENT)\n    *dd = s;\n  else\n    MSG_STRING_DUP(*pp, *dd, s);\n}\n\nchar const sip_method_name_invite[] =  \t \"INVITE\";\nchar const sip_method_name_ack[] =     \t \"ACK\";\nchar const sip_method_name_cancel[] =  \t \"CANCEL\";\nchar const sip_method_name_bye[] =     \t \"BYE\";\nchar const sip_method_name_options[] = \t \"OPTIONS\";\nchar const sip_method_name_register[] =  \"REGISTER\";\nchar const sip_method_name_info[] =      \"INFO\";\nchar const sip_method_name_prack[] =     \"PRACK\";\nchar const sip_method_name_update[] =    \"UPDATE\";\nchar const sip_method_name_message[] =   \"MESSAGE\";\nchar const sip_method_name_subscribe[] = \"SUBSCRIBE\";\nchar const sip_method_name_notify[] =    \"NOTIFY\";\nchar const sip_method_name_refer[] =     \"REFER\";\nchar const sip_method_name_publish[] =   \"PUBLISH\";\n\n/** Well-known SIP method names. */\nchar const * const sip_method_names[] = {\n  \"<UNKNOWN>\",\n  sip_method_name_invite,\n  sip_method_name_ack,\n  sip_method_name_cancel,\n  sip_method_name_bye,\n  sip_method_name_options,\n  sip_method_name_register,\n  sip_method_name_info,\n  sip_method_name_prack,\n  sip_method_name_update,\n  sip_method_name_message,\n  sip_method_name_subscribe,\n  sip_method_name_notify,\n  sip_method_name_refer,\n  sip_method_name_publish,\n  /* If you add something here, add also them to sip_method_d! */\n  NULL\n};\n\n/** Get canonic method name. */\nchar const *sip_method_name(sip_method_t method, char const *name)\n{\n  const size_t N = sizeof(sip_method_names)/sizeof(sip_method_names[0]);\n  if (method > 0 && (size_t)method < N)\n    return sip_method_names[method];\n  else if (method == 0)\n    return name;\n  else\n    return NULL;\n}\n\n/**Parse a SIP method name.\n *\n * Parse a SIP method name and return a code corresponding to the method.\n * The address of the first non-LWS character after method name is stored in\n * @a *ss.\n *\n * @param ss    pointer to pointer to string to be parsed\n * @param return_name  value-result parameter for method name\n *\n * @note\n * If there is no whitespace after method name, the value in @a *return_name\n * may not be NUL-terminated.  The calling function @b must NUL terminate\n * the value by setting the @a **ss to NUL after first examining its value.\n *\n * @return The method code if method\n * was identified, 0 (sip_method_unknown()) if method is not known, or @c -1\n * (sip_method_invalid()) if an error occurred.\n *\n * If the value-result argument @a return_name is not @c NULL,\n * a pointer to the method name is stored to it.\n */\nsip_method_t sip_method_d(char **ss, char const **return_name)\n{\n  char *s = *ss, c = *s;\n  char const *name;\n  int code = sip_method_unknown;\n  size_t n = 0;\n\n#define MATCH(s, m) (strncmp(s, m, n = sizeof(m) - 1) == 0)\n\n  switch (c) {\n  case 'A': if (MATCH(s, \"ACK\")) code = sip_method_ack; break;\n  case 'B': if (MATCH(s, \"BYE\")) code = sip_method_bye; break;\n  case 'C':\n    if (MATCH(s, \"CANCEL\"))\n      code = sip_method_cancel;\n    break;\n  case 'I':\n    if (MATCH(s, \"INVITE\"))\n      code = sip_method_invite;\n    else if (MATCH(s, \"INFO\"))\n      code = sip_method_info;\n    break;\n  case 'M': if (MATCH(s, \"MESSAGE\")) code = sip_method_message; break;\n  case 'N': if (MATCH(s, \"NOTIFY\")) code = sip_method_notify; break;\n  case 'O': if (MATCH(s, \"OPTIONS\")) code = sip_method_options; break;\n  case 'P':\n    if (MATCH(s, \"PRACK\")) code = sip_method_prack;\n    else if (MATCH(s, \"PUBLISH\")) code = sip_method_publish;\n    break;\n  case 'R':\n    if (MATCH(s, \"REGISTER\"))\n      code = sip_method_register;\n    else if (MATCH(s, \"REFER\"))\n      code = sip_method_refer;\n    break;\n  case 'S':\n    if (MATCH(s, \"SUBSCRIBE\"))\n      code = sip_method_subscribe;\n    break;\n  case 'U':\n    if (MATCH(s, \"UPDATE\"))\n      code = sip_method_update;\n    break;\n  }\n\n#undef MATCH\n\n  if (IS_NON_WS(s[n]))\n    /* Unknown method */\n    code = sip_method_unknown;\n\n  if (code == sip_method_unknown) {\n    name = s;\n    for (n = 0; IS_UNRESERVED(s[n]); n++)\n      ;\n    if (s[n]) {\n      if (!IS_LWS(s[n]))\n\treturn sip_method_invalid;\n      if (return_name)\n\ts[n++] = '\\0';\n    }\n  }\n  else {\n    name = sip_method_names[code];\n  }\n\n  while (IS_LWS(s[n]))\n    n++;\n\n  *ss = (s + n);\n  if (return_name) *return_name = name;\n\n  return (sip_method_t)code;\n}\n\n/** Get method enum corresponding to method name */\nsip_method_t sip_method_code(char const *name)\n{\n  /* Note that sip_method_d() does not change string if return_name is NULL */\n  return sip_method_d((char **)&name, NULL);\n}\n\nchar const sip_transport_udp[] = \"SIP/2.0/UDP\";\nchar const sip_transport_tcp[] = \"SIP/2.0/TCP\";\nchar const sip_transport_sctp[] = \"SIP/2.0/SCTP\";\nchar const sip_transport_ws[] = \"SIP/2.0/WS\";\nchar const sip_transport_wss[] = \"SIP/2.0/WSS\";\nchar const sip_transport_tls[] = \"SIP/2.0/TLS\";\n\n/** Decode transport */\nissize_t sip_transport_d(char **ss, char const **ttransport)\n{\n  char const *transport;\n  char *pn, *pv, *pt;\n  size_t pn_len, pv_len, pt_len;\n  char *s = *ss;\n\n#define TRANSPORT_MATCH(t) \\\n  (su_casenmatch(s + 7, t + 7, (sizeof t) - 8) && \\\n   (!s[sizeof(t) - 1] || IS_LWS(s[sizeof(t) - 1]))\t\\\n   && (transport = t, s += sizeof(t) - 1))\n\n  if (!su_casenmatch(s, \"SIP/2.0\", 7) ||\n      (!TRANSPORT_MATCH(sip_transport_udp) &&\n       !TRANSPORT_MATCH(sip_transport_tcp) &&\n       !TRANSPORT_MATCH(sip_transport_sctp) &&\n       !TRANSPORT_MATCH(sip_transport_ws) &&\n       !TRANSPORT_MATCH(sip_transport_wss) &&\n       !TRANSPORT_MATCH(sip_transport_tls))) {\n    /* Protocol name */\n    transport = pn = s;\n    skip_token(&s);\n    pn_len = s - pn;\n    skip_lws(&s);\n    if (pn_len == 0 || *s++ != '/') return -1;\n    skip_lws(&s);\n\n    /* Protocol version */\n    pv = s;\n    skip_token(&s);\n    pv_len = s - pv;\n    skip_lws(&s);\n    if (pv_len == 0 || *s++ != '/') return -1;\n    skip_lws(&s);\n\n    /* Transport protocol */\n    pt = s;\n    skip_token(&s);\n    pt_len = s - pt;\n    if (pt_len == 0) return -1;\n\n    /* Remove whitespace between protocol name and version */\n    if (pn + pn_len + 1 != pv) {\n      pn[pn_len] = '/';\n      pv = memmove(pn + pn_len + 1, pv, pv_len);\n    }\n\n    /* Remove whitespace between protocol version and transport */\n    if (pv + pv_len + 1 != pt) {\n      pv[pv_len] = '/';\n      pt = memmove(pv + pv_len + 1, pt, pt_len);\n      pt[pt_len] = '\\0';\n\n      /* extra whitespace? */\n      if (su_casematch(transport, sip_transport_udp))\n\ttransport = sip_transport_udp;\n      else if (su_casematch(transport, sip_transport_tcp))\n\ttransport = sip_transport_tcp;\n      else if (su_casematch(transport, sip_transport_sctp))\n\ttransport = sip_transport_sctp;\n      else if (su_casematch(transport, sip_transport_ws))\n\ttransport = sip_transport_ws;\n      else if (su_casematch(transport, sip_transport_wss))\n\ttransport = sip_transport_wss;\n      else if (su_casematch(transport, sip_transport_tls))\n\ttransport = sip_transport_tls;\n    }\n  }\n\n  if (IS_LWS(*s)) { *s++ = '\\0'; skip_lws(&s); }\n  *ss = s;\n  *ttransport = transport;\n  return 0;\n}\n\n/** Calculate extra space required by sip_transport_dup() */\nisize_t sip_transport_xtra(char const *transport)\n{\n  if (transport == sip_transport_udp ||\n      transport == sip_transport_tcp ||\n      transport == sip_transport_sctp ||\n      transport == sip_transport_ws ||\n      transport == sip_transport_wss ||\n      transport == sip_transport_tls ||\n      su_casematch(transport, sip_transport_udp) ||\n      su_casematch(transport, sip_transport_tcp) ||\n      su_casematch(transport, sip_transport_sctp) ||\n      su_casematch(transport, sip_transport_ws) ||\n      su_casematch(transport, sip_transport_wss) ||\n      su_casematch(transport, sip_transport_tls))\n    return 0;\n\n  return MSG_STRING_SIZE(transport);\n}\n\n/** Duplicate a transport string */\nvoid sip_transport_dup(char **pp, char const **dd, char const *s)\n{\n  if (s == sip_transport_udp)\n    *dd = s;\n  else if (s == sip_transport_tcp)\n    *dd = s;\n  else if (s == sip_transport_sctp)\n    *dd = s;\n  else if (s == sip_transport_tls)\n    *dd = s;\n  else if (s == sip_transport_ws)\n    *dd = s;\n  else if (s == sip_transport_wss)\n    *dd = s;\n  else if (su_casematch(s, sip_transport_udp))\n    *dd = sip_transport_udp;\n  else if (su_casematch(s, sip_transport_tcp))\n    *dd = sip_transport_tcp;\n  else if (su_casematch(s, sip_transport_sctp))\n    *dd = sip_transport_sctp;\n  else if (su_casematch(s, sip_transport_tls))\n    *dd = sip_transport_tls;\n  else if (su_casematch(s, sip_transport_ws))\n    *dd = sip_transport_ws;\n  else if (su_casematch(s, sip_transport_wss))\n    *dd = sip_transport_wss;\n  else\n    MSG_STRING_DUP(*pp, *dd, s);\n}\n\n/** Parse SIP <word \"@\" word> construct used in @CallID. */\nchar *sip_word_at_word_d(char **ss)\n{\n  char *rv = *ss, *s0 = *ss;\n\n  skip_word(ss);\n  if (s0 == *ss)\n    return NULL;\n  if (**ss == '@') {\n    (*ss)++;\n    s0 = *ss;\n    skip_word(ss);\n    if (s0 == *ss)\n      return NULL;\n  }\n  if (IS_LWS(**ss))\n    (*ss)++;\n  skip_lws(ss);\n\n  return rv;\n}\n\n/**Add message separator, then test if message is complete.\n *\n * Add sip_content_length and sip_separator if they are missing.\n * The test that all necessary message components ( @From, @To,\n * @CSeq, @CallID, @ContentLength and message separator are present.\n *\n * @retval 0 when successful\n * @retval -1 upon an error: headers are missing and they could not be added\n */\nint sip_complete_message(msg_t *msg)\n{\n  sip_t *sip = sip_object(msg);\n  su_home_t *home = msg_home(msg);\n  size_t len = 0;\n  ssize_t mplen;\n\n  if (sip == NULL)\n    return -1;\n\n  if (!sip->sip_separator)\n    sip->sip_separator = sip_separator_create(msg_home(msg));\n\n  if (sip->sip_multipart) {\n    sip_content_type_t *c = sip->sip_content_type;\n    msg_multipart_t *mp = sip->sip_multipart;\n    sip_common_t *head;\n\n    if (!c || msg_multipart_complete(msg_home(msg), c, mp) < 0)\n      return -1;\n\n    if (sip->sip_payload)\n      head = sip->sip_payload->pl_common;\n    else\n      head = sip->sip_separator->sep_common;\n\n    if (!head || !msg_multipart_serialize(&head->h_succ, mp))\n      return -1;\n\n    mplen = msg_multipart_prepare(msg, mp, sip->sip_flags);\n    if (mplen == -1)\n      return -1;\n    len = (size_t)mplen;\n  }\n\n  if (sip->sip_payload)\n    len += sip->sip_payload->pl_len;\n\n  if (len > UINT32_MAX)\n    return -1;\n\n  if (!sip->sip_content_length) {\n    msg_header_insert(msg, (msg_pub_t *)sip, (msg_header_t*)\n\t\t      sip_content_length_create(home, (uint32_t)len));\n  }\n  else {\n    if (sip->sip_content_length->l_length != len) {\n      sip->sip_content_length->l_length = (uint32_t)len;\n      sip_fragment_clear(sip->sip_content_length->l_common);\n    }\n  }\n\n  if (!sip->sip_cseq ||\n      !sip->sip_call_id ||\n      !sip->sip_to ||\n      !sip->sip_from ||\n      !sip->sip_separator ||\n      !sip->sip_content_length)\n    return -1;\n\n  return 0;\n}\n"], "fixing_code": ["/*\n * This file is part of the Sofia-SIP package\n *\n * Copyright (C) 2005 Nokia Corporation.\n *\n * Contact: Pekka Pessi <pekka.pessi@nokia.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA\n *\n */\n\n/**@ingroup sip_parser\n * @CFILE sip_parser.c\n *\n * SIP parser.\n *\n * @author Pekka Pessi <Pekka.Pessi@nokia.com>.\n *\n * @date Created: Thu Oct  5 14:01:24 2000 ppessi\n */\n\n#include \"config.h\"\n\n/* Avoid casting sip_t to msg_pub_t and sip_header_t to msg_header_t */\n#define MSG_PUB_T       struct sip_s\n#define MSG_HDR_T       union sip_header_u\n\n#include <sofia-sip/su_tagarg.h>\n#include <sofia-sip/su_string.h>\n#include \"sofia-sip/sip_parser.h\"\n#include <sofia-sip/msg_mclass.h>\n\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <assert.h>\n#include <limits.h>\n\n#ifndef UINT32_MAX\n#define UINT32_MAX (0xffffffffU)\n#endif\n\n/** Version of the SIP module */\nchar const sip_parser_version[] = VERSION;\n\n/** SIP version 2.0. */\nchar const sip_version_2_0[] = \"SIP/2.0\";\n\n/** Default message class */\nextern msg_mclass_t sip_mclass[];\n\nstatic msg_mclass_t const *_default = sip_mclass;\nstatic msg_mclass_t *_default_parser_cloned = NULL;\n\n/** Return a built-in SIP parser object. */\nmsg_mclass_t const *sip_default_mclass(void)\n{\n  return _default;\n}\n\n/** Restore default SIP parser to non-extended */\nvoid sip_default_mclass_restore() {\n\t_default = sip_mclass;\n}\n\n/** Destroy SIP parser object */\nvoid sip_destroy_mclass(msg_mclass_t *mclass) {\n\tif (mclass && mclass != sip_mclass) {\n\t\tif (mclass == _default_parser_cloned) {\n\t\t\tsip_cloned_parser_destroy();\n\t\t} else {\n\t\t\tif (mclass == _default) {\n\t\t\t\tsip_default_mclass_restore();\n\t\t\t}\n\t\t\tfree(mclass);\n\t\t}\n\t}\n}\n\n/** Release SIP parser object if it was cloned. */\nvoid sip_cloned_parser_destroy(void)\n{\n\tif (_default_parser_cloned) {\n\t\tif (_default_parser_cloned == _default) {\n\t\t\tsip_default_mclass_restore();\n\t\t}\n\n\t\tfree(_default_parser_cloned);\n\t\t_default_parser_cloned = NULL;\n\t}\n}\n\n/** Update the default SIP parser.\n *\n * Use the extended SIP parser as default one.\n *\n * If the applications want to use headers added after @VERSION_1_12_5,\n * they should call this function before doing any other initialization, e.g.,\n * @code\n *   su_init();\n *   if (sip_update_default_mclass(sip_extend_mclass(NULL)) < 0) {\n *     su_deinit();\n *     exit(2);\n *   }\n * @endcode\n * When finish don't forget to call \n * @code\n *   sip_destroy_mclass(sip_default_mclass());\n * @endcode\n * as return of sip_extend_mclass(NULL) requires to be freed.\n *\n * The default parser is not extended because it may break the old\n * applications looking for extension headers from sip_unknown list.\n *\n * @retval 0 when successful\n * @retval -1 upon an error\n *\n * @sa sip_extend_mclass()\n *\n * @NEW_1_12_7.\n */\nint sip_update_default_mclass(msg_mclass_t const *mclass)\n{\n  if (mclass == NULL)\n    return -1;\n  _default = mclass;\n  return 0;\n}\n\n/**Extend SIP parser class with extension headers.\n *\n * Extend given SIP parser class with extension headers. If the given parser\n * (message class) is the default one or NULL, make a clone of default\n * parser before extending it.\n *\n * @param input pointer to a SIP message class (may be NULL)\n *\n * @return Pointer to extended mclass, or NULL upon an error.\n *\n * @sa\n * @AlertInfo,\n * @ReplyTo,\n * @RemotePartyId,\n * @PAssertedIdentity,\n * @PPreferredIdentity,\n * @SuppressBodyIfMatch,\n * @SuppressNotifyIfMatch\n *\n * @NEW_1_12_7.\n */\nmsg_mclass_t *sip_extend_mclass(msg_mclass_t *input)\n{\n  msg_mclass_t *mclass;\n\n  if (input == NULL || input == _default) {\n    _default_parser_cloned = msg_mclass_clone(_default, 0, 0);\n    mclass = _default_parser_cloned;\n  } else {\n    mclass = input;\n  }\n\n  if (mclass) {\n    extern msg_hclass_t * const sip_extensions[];\n    int i;\n\n    for (i = 0; sip_extensions[i]; i++) {\n      msg_hclass_t *hclass = sip_extensions[i];\n      if (mclass->mc_unknown != msg_find_hclass(mclass, hclass->hc_name, NULL))\n\tcontinue;\n\n      if (msg_mclass_insert_header(mclass, hclass, 0) < 0) {\n        if (input != mclass) {\n          sip_destroy_mclass(mclass);\n        }\n        return mclass = NULL;\n      }\n    }\n  }\n\n  return mclass;\n}\n\n/** Extract the SIP message body, including separator line.\n *\n * @param msg  message object [IN]\n * @param sip  public SIP message structure [IN/OUT]\n * @param b    buffer containing unparsed data [IN]\n * @param bsiz buffer size [IN]\n * @param eos  true if buffer contains whole message [IN]\n *\n * @retval -1 error\n * @retval 0  cannot proceed\n * @retval m\n */\nissize_t sip_extract_body(msg_t *msg, sip_t *sip, char b[], isize_t bsiz, int eos)\n{\n  ssize_t m = 0;\n  size_t body_len;\n\n  if (!(sip->sip_flags & MSG_FLG_BODY)) {\n    /* We are looking at a potential empty line */\n    m = msg_extract_separator(msg, (msg_pub_t *)sip, b, bsiz, eos);\n    if (m <= 0)\n      return m;\n    sip->sip_flags |= MSG_FLG_BODY;\n    b += m;\n    bsiz -= m;\n  }\n\n  if (sip->sip_content_length)\n    body_len = sip->sip_content_length->l_length;\n  else if (MSG_IS_MAILBOX(sip->sip_flags)) /* message fragments */\n    body_len = 0;\n  else if (eos)\n    body_len = bsiz;\n  else if (bsiz == 0)\n    return m;\n  else\n    return -1;\n\n  if (body_len == 0) {\n    sip->sip_flags |= MSG_FLG_COMPLETE;\n    return m;\n  }\n\n  if (m)\n    return m;\n\n  if (eos && body_len > bsiz) {\n    sip->sip_flags |= MSG_FLG_TRUNC | MSG_FLG_ERROR;\n    return bsiz;\n  }\n\n  if ((m = msg_extract_payload(msg, (msg_pub_t *)sip,\n\t\t\t       NULL, body_len, b, bsiz, eos)) == -1)\n    return -1;\n\n  sip->sip_flags |= MSG_FLG_FRAGS;\n  if (bsiz >= body_len)\n    sip->sip_flags |= MSG_FLG_COMPLETE;\n\n  return m;\n}\n\n/** Parse SIP version.\n *\n * Parse a SIP version string. Update the\n * pointer at @a ss to first non-LWS character after the version string.\n *\n * @param ss   string to be parsed [IN/OUT]\n * @param ver  value result for version [OUT]\n *\n * @retval 0 when successful,\n * @retval -1 upon an error.\n */\nint sip_version_d(char **ss, char const **ver)\n{\n  char *s = *ss;\n  char const *result;\n  size_t const version_size = sizeof(sip_version_2_0) - 1;\n\n  if (su_casenmatch(s, sip_version_2_0, version_size) &&\n      !IS_TOKEN(s[version_size])) {\n    result = sip_version_2_0;\n    s += version_size;\n  }\n  else {\n    /* Version consists of two tokens, separated by / */\n    size_t l1 = 0, l2 = 0, n;\n\n    result = s;\n\n    l1 = span_token(s);\n    for (n = l1; IS_LWS(s[n]); n++)\n      {}\n    if (s[n] == '/') {\n      for (n++; IS_LWS(s[n]); n++)\n        {}\n      l2 = span_token(s + n);\n      n += l2;\n    }\n\n    if (l1 == 0 || l2 == 0)\n      return -1;\n\n    /* If there is extra ws between tokens, compact version */\n    if (n > l1 + 1 + l2) {\n      s[l1] = '/';\n      memmove(s + l1 + 1, s + n - l2, l2);\n      s[l1 + 1 + l2] = 0;\n\n      /* Compare again with compacted version */\n      if (su_casematch(s, sip_version_2_0))\n\tresult = sip_version_2_0;\n    }\n\n    s += n;\n  }\n\n  while (IS_WS(*s)) *s++ = '\\0';\n\n  *ss = s;\n\n  if (ver)\n    *ver = result;\n\n  return 0;\n}\n\n/** Calculate extra space required by version string */\nisize_t sip_version_xtra(char const *version)\n{\n  if (version == SIP_VERSION_CURRENT)\n    return 0;\n  return MSG_STRING_SIZE(version);\n}\n\n/** Duplicate a transport string */\nvoid sip_version_dup(char **pp, char const **dd, char const *s)\n{\n  if (s == SIP_VERSION_CURRENT)\n    *dd = s;\n  else\n    MSG_STRING_DUP(*pp, *dd, s);\n}\n\nchar const sip_method_name_invite[] =  \t \"INVITE\";\nchar const sip_method_name_ack[] =     \t \"ACK\";\nchar const sip_method_name_cancel[] =  \t \"CANCEL\";\nchar const sip_method_name_bye[] =     \t \"BYE\";\nchar const sip_method_name_options[] = \t \"OPTIONS\";\nchar const sip_method_name_register[] =  \"REGISTER\";\nchar const sip_method_name_info[] =      \"INFO\";\nchar const sip_method_name_prack[] =     \"PRACK\";\nchar const sip_method_name_update[] =    \"UPDATE\";\nchar const sip_method_name_message[] =   \"MESSAGE\";\nchar const sip_method_name_subscribe[] = \"SUBSCRIBE\";\nchar const sip_method_name_notify[] =    \"NOTIFY\";\nchar const sip_method_name_refer[] =     \"REFER\";\nchar const sip_method_name_publish[] =   \"PUBLISH\";\n\n/** Well-known SIP method names. */\nchar const * const sip_method_names[] = {\n  \"<UNKNOWN>\",\n  sip_method_name_invite,\n  sip_method_name_ack,\n  sip_method_name_cancel,\n  sip_method_name_bye,\n  sip_method_name_options,\n  sip_method_name_register,\n  sip_method_name_info,\n  sip_method_name_prack,\n  sip_method_name_update,\n  sip_method_name_message,\n  sip_method_name_subscribe,\n  sip_method_name_notify,\n  sip_method_name_refer,\n  sip_method_name_publish,\n  /* If you add something here, add also them to sip_method_d! */\n  NULL\n};\n\n/** Get canonic method name. */\nchar const *sip_method_name(sip_method_t method, char const *name)\n{\n  const size_t N = sizeof(sip_method_names)/sizeof(sip_method_names[0]);\n  if (method > 0 && (size_t)method < N)\n    return sip_method_names[method];\n  else if (method == 0)\n    return name;\n  else\n    return NULL;\n}\n\n/**Parse a SIP method name.\n *\n * Parse a SIP method name and return a code corresponding to the method.\n * The address of the first non-LWS character after method name is stored in\n * @a *ss.\n *\n * @param ss    pointer to pointer to string to be parsed\n * @param return_name  value-result parameter for method name\n *\n * @note\n * If there is no whitespace after method name, the value in @a *return_name\n * may not be NUL-terminated.  The calling function @b must NUL terminate\n * the value by setting the @a **ss to NUL after first examining its value.\n *\n * @return The method code if method\n * was identified, 0 (sip_method_unknown()) if method is not known, or @c -1\n * (sip_method_invalid()) if an error occurred.\n *\n * If the value-result argument @a return_name is not @c NULL,\n * a pointer to the method name is stored to it.\n */\nsip_method_t sip_method_d(char **ss, char const **return_name)\n{\n  char *s = *ss, c = *s;\n  char const *name;\n  int code = sip_method_unknown;\n  size_t n = 0;\n\n#define MATCH(s, m) (strncmp(s, m, n = sizeof(m) - 1) == 0)\n\n  switch (c) {\n  case 'A': if (MATCH(s, \"ACK\")) code = sip_method_ack; break;\n  case 'B': if (MATCH(s, \"BYE\")) code = sip_method_bye; break;\n  case 'C':\n    if (MATCH(s, \"CANCEL\"))\n      code = sip_method_cancel;\n    break;\n  case 'I':\n    if (MATCH(s, \"INVITE\"))\n      code = sip_method_invite;\n    else if (MATCH(s, \"INFO\"))\n      code = sip_method_info;\n    break;\n  case 'M': if (MATCH(s, \"MESSAGE\")) code = sip_method_message; break;\n  case 'N': if (MATCH(s, \"NOTIFY\")) code = sip_method_notify; break;\n  case 'O': if (MATCH(s, \"OPTIONS\")) code = sip_method_options; break;\n  case 'P':\n    if (MATCH(s, \"PRACK\")) code = sip_method_prack;\n    else if (MATCH(s, \"PUBLISH\")) code = sip_method_publish;\n    break;\n  case 'R':\n    if (MATCH(s, \"REGISTER\"))\n      code = sip_method_register;\n    else if (MATCH(s, \"REFER\"))\n      code = sip_method_refer;\n    break;\n  case 'S':\n    if (MATCH(s, \"SUBSCRIBE\"))\n      code = sip_method_subscribe;\n    break;\n  case 'U':\n    if (MATCH(s, \"UPDATE\"))\n      code = sip_method_update;\n    break;\n  }\n\n#undef MATCH\n\n  if (strlen(s) < n) {\n    return sip_method_invalid;\n  }\n\n  if (IS_NON_WS(s[n]))\n    /* Unknown method */\n    code = sip_method_unknown;\n\n  if (code == sip_method_unknown) {\n    name = s;\n    for (n = 0; IS_UNRESERVED(s[n]); n++)\n      ;\n    if (s[n]) {\n      if (!IS_LWS(s[n]))\n\treturn sip_method_invalid;\n      if (return_name)\n\ts[n++] = '\\0';\n    }\n  }\n  else {\n    name = sip_method_names[code];\n  }\n\n  while (IS_LWS(s[n]))\n    n++;\n\n  *ss = (s + n);\n  if (return_name) *return_name = name;\n\n  return (sip_method_t)code;\n}\n\n/** Get method enum corresponding to method name */\nsip_method_t sip_method_code(char const *name)\n{\n  /* Note that sip_method_d() does not change string if return_name is NULL */\n  return sip_method_d((char **)&name, NULL);\n}\n\nchar const sip_transport_udp[] = \"SIP/2.0/UDP\";\nchar const sip_transport_tcp[] = \"SIP/2.0/TCP\";\nchar const sip_transport_sctp[] = \"SIP/2.0/SCTP\";\nchar const sip_transport_ws[] = \"SIP/2.0/WS\";\nchar const sip_transport_wss[] = \"SIP/2.0/WSS\";\nchar const sip_transport_tls[] = \"SIP/2.0/TLS\";\n\n/** Decode transport */\nissize_t sip_transport_d(char **ss, char const **ttransport)\n{\n  char const *transport;\n  char *pn, *pv, *pt;\n  size_t pn_len, pv_len, pt_len;\n  char *s = *ss;\n\n#define TRANSPORT_MATCH(t) \\\n  (su_casenmatch(s + 7, t + 7, (sizeof t) - 8) && \\\n   (!s[sizeof(t) - 1] || IS_LWS(s[sizeof(t) - 1]))\t\\\n   && (transport = t, s += sizeof(t) - 1))\n\n  if (!su_casenmatch(s, \"SIP/2.0\", 7) ||\n      (!TRANSPORT_MATCH(sip_transport_udp) &&\n       !TRANSPORT_MATCH(sip_transport_tcp) &&\n       !TRANSPORT_MATCH(sip_transport_sctp) &&\n       !TRANSPORT_MATCH(sip_transport_ws) &&\n       !TRANSPORT_MATCH(sip_transport_wss) &&\n       !TRANSPORT_MATCH(sip_transport_tls))) {\n    /* Protocol name */\n    transport = pn = s;\n    skip_token(&s);\n    pn_len = s - pn;\n    skip_lws(&s);\n    if (pn_len == 0 || *s++ != '/') return -1;\n    skip_lws(&s);\n\n    /* Protocol version */\n    pv = s;\n    skip_token(&s);\n    pv_len = s - pv;\n    skip_lws(&s);\n    if (pv_len == 0 || *s++ != '/') return -1;\n    skip_lws(&s);\n\n    /* Transport protocol */\n    pt = s;\n    skip_token(&s);\n    pt_len = s - pt;\n    if (pt_len == 0) return -1;\n\n    /* Remove whitespace between protocol name and version */\n    if (pn + pn_len + 1 != pv) {\n      pn[pn_len] = '/';\n      pv = memmove(pn + pn_len + 1, pv, pv_len);\n    }\n\n    /* Remove whitespace between protocol version and transport */\n    if (pv + pv_len + 1 != pt) {\n      pv[pv_len] = '/';\n      pt = memmove(pv + pv_len + 1, pt, pt_len);\n      pt[pt_len] = '\\0';\n\n      /* extra whitespace? */\n      if (su_casematch(transport, sip_transport_udp))\n\ttransport = sip_transport_udp;\n      else if (su_casematch(transport, sip_transport_tcp))\n\ttransport = sip_transport_tcp;\n      else if (su_casematch(transport, sip_transport_sctp))\n\ttransport = sip_transport_sctp;\n      else if (su_casematch(transport, sip_transport_ws))\n\ttransport = sip_transport_ws;\n      else if (su_casematch(transport, sip_transport_wss))\n\ttransport = sip_transport_wss;\n      else if (su_casematch(transport, sip_transport_tls))\n\ttransport = sip_transport_tls;\n    }\n  }\n\n  if (IS_LWS(*s)) { *s++ = '\\0'; skip_lws(&s); }\n  *ss = s;\n  *ttransport = transport;\n  return 0;\n}\n\n/** Calculate extra space required by sip_transport_dup() */\nisize_t sip_transport_xtra(char const *transport)\n{\n  if (transport == sip_transport_udp ||\n      transport == sip_transport_tcp ||\n      transport == sip_transport_sctp ||\n      transport == sip_transport_ws ||\n      transport == sip_transport_wss ||\n      transport == sip_transport_tls ||\n      su_casematch(transport, sip_transport_udp) ||\n      su_casematch(transport, sip_transport_tcp) ||\n      su_casematch(transport, sip_transport_sctp) ||\n      su_casematch(transport, sip_transport_ws) ||\n      su_casematch(transport, sip_transport_wss) ||\n      su_casematch(transport, sip_transport_tls))\n    return 0;\n\n  return MSG_STRING_SIZE(transport);\n}\n\n/** Duplicate a transport string */\nvoid sip_transport_dup(char **pp, char const **dd, char const *s)\n{\n  if (s == sip_transport_udp)\n    *dd = s;\n  else if (s == sip_transport_tcp)\n    *dd = s;\n  else if (s == sip_transport_sctp)\n    *dd = s;\n  else if (s == sip_transport_tls)\n    *dd = s;\n  else if (s == sip_transport_ws)\n    *dd = s;\n  else if (s == sip_transport_wss)\n    *dd = s;\n  else if (su_casematch(s, sip_transport_udp))\n    *dd = sip_transport_udp;\n  else if (su_casematch(s, sip_transport_tcp))\n    *dd = sip_transport_tcp;\n  else if (su_casematch(s, sip_transport_sctp))\n    *dd = sip_transport_sctp;\n  else if (su_casematch(s, sip_transport_tls))\n    *dd = sip_transport_tls;\n  else if (su_casematch(s, sip_transport_ws))\n    *dd = sip_transport_ws;\n  else if (su_casematch(s, sip_transport_wss))\n    *dd = sip_transport_wss;\n  else\n    MSG_STRING_DUP(*pp, *dd, s);\n}\n\n/** Parse SIP <word \"@\" word> construct used in @CallID. */\nchar *sip_word_at_word_d(char **ss)\n{\n  char *rv = *ss, *s0 = *ss;\n\n  skip_word(ss);\n  if (s0 == *ss)\n    return NULL;\n  if (**ss == '@') {\n    (*ss)++;\n    s0 = *ss;\n    skip_word(ss);\n    if (s0 == *ss)\n      return NULL;\n  }\n  if (IS_LWS(**ss))\n    (*ss)++;\n  skip_lws(ss);\n\n  return rv;\n}\n\n/**Add message separator, then test if message is complete.\n *\n * Add sip_content_length and sip_separator if they are missing.\n * The test that all necessary message components ( @From, @To,\n * @CSeq, @CallID, @ContentLength and message separator are present.\n *\n * @retval 0 when successful\n * @retval -1 upon an error: headers are missing and they could not be added\n */\nint sip_complete_message(msg_t *msg)\n{\n  sip_t *sip = sip_object(msg);\n  su_home_t *home = msg_home(msg);\n  size_t len = 0;\n  ssize_t mplen;\n\n  if (sip == NULL)\n    return -1;\n\n  if (!sip->sip_separator)\n    sip->sip_separator = sip_separator_create(msg_home(msg));\n\n  if (sip->sip_multipart) {\n    sip_content_type_t *c = sip->sip_content_type;\n    msg_multipart_t *mp = sip->sip_multipart;\n    sip_common_t *head;\n\n    if (!c || msg_multipart_complete(msg_home(msg), c, mp) < 0)\n      return -1;\n\n    if (sip->sip_payload)\n      head = sip->sip_payload->pl_common;\n    else\n      head = sip->sip_separator->sep_common;\n\n    if (!head || !msg_multipart_serialize(&head->h_succ, mp))\n      return -1;\n\n    mplen = msg_multipart_prepare(msg, mp, sip->sip_flags);\n    if (mplen == -1)\n      return -1;\n    len = (size_t)mplen;\n  }\n\n  if (sip->sip_payload)\n    len += sip->sip_payload->pl_len;\n\n  if (len > UINT32_MAX)\n    return -1;\n\n  if (!sip->sip_content_length) {\n    msg_header_insert(msg, (msg_pub_t *)sip, (msg_header_t*)\n\t\t      sip_content_length_create(home, (uint32_t)len));\n  }\n  else {\n    if (sip->sip_content_length->l_length != len) {\n      sip->sip_content_length->l_length = (uint32_t)len;\n      sip_fragment_clear(sip->sip_content_length->l_common);\n    }\n  }\n\n  if (!sip->sip_cseq ||\n      !sip->sip_call_id ||\n      !sip->sip_to ||\n      !sip->sip_from ||\n      !sip->sip_separator ||\n      !sip->sip_content_length)\n    return -1;\n\n  return 0;\n}\n"], "filenames": ["libsofia-sip-ua/sip/sip_parser.c"], "buggy_code_start_loc": [456], "buggy_code_end_loc": [456], "fixing_code_start_loc": [457], "fixing_code_end_loc": [461], "type": "CWE-125", "message": "Sofia-SIP is an open-source Session Initiation Protocol (SIP) User-Agent library. Prior to version 1.13.8, an attacker can send a message with evil sdp to FreeSWITCH, which may cause crash. This type of crash may be caused by `#define MATCH(s, m) (strncmp(s, m, n = sizeof(m) - 1) == 0)`, which will make `n` bigger and trigger out-of-bound access when `IS_NON_WS(s[n])`. Version 1.13.8 contains a patch for this issue.", "other": {"cve": {"id": "CVE-2022-31001", "sourceIdentifier": "security-advisories@github.com", "published": "2022-05-31T20:15:07.850", "lastModified": "2023-05-24T21:15:10.540", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Sofia-SIP is an open-source Session Initiation Protocol (SIP) User-Agent library. Prior to version 1.13.8, an attacker can send a message with evil sdp to FreeSWITCH, which may cause crash. This type of crash may be caused by `#define MATCH(s, m) (strncmp(s, m, n = sizeof(m) - 1) == 0)`, which will make `n` bigger and trigger out-of-bound access when `IS_NON_WS(s[n])`. Version 1.13.8 contains a patch for this issue."}, {"lang": "es", "value": "Sofia-SIP es una biblioteca de agente de usuario del Protocolo de Iniciaci\u00f3n de Sesi\u00f3n (SIP) de c\u00f3digo abierto. En versiones anteriores a 1.13.8, un atacante puede enviar un mensaje con sdp maligno a FreeSWITCH, lo que puede causar un bloqueo. Este tipo de bloqueo puede ser causado por \"#define MATCH(s, m) (strncmp(s, m, n = sizeof(m) - 1) == 0)\", que har\u00e1 que \"n\" sea m\u00e1s grande y desencadenar\u00e1 un acceso fuera de l\u00edmites cuando \"IS_NON_WS(s[n])\". La versi\u00f3n 1.13.8 contiene un parche para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:signalwire:sofia-sip:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.13.8", "matchCriteriaId": "C8062138-09E2-4610-9FFB-037EDC6FA766"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/freeswitch/sofia-sip/commit/a99804b336d0e16d26ab7119d56184d2d7110a36", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/freeswitch/sofia-sip/security/advisories/GHSA-79jq-hh82-cv9g", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/09/msg00001.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202210-18", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5410", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/freeswitch/sofia-sip/commit/a99804b336d0e16d26ab7119d56184d2d7110a36"}}