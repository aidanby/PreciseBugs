{"buggy_code": ["/*\n * algif_skcipher: User-space interface for skcipher algorithms\n *\n * This file provides the user-space API for symmetric key ciphers.\n *\n * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#include <crypto/scatterwalk.h>\n#include <crypto/skcipher.h>\n#include <crypto/if_alg.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/net.h>\n#include <net/sock.h>\n\nstruct skcipher_sg_list {\n\tstruct list_head list;\n\n\tint cur;\n\n\tstruct scatterlist sg[0];\n};\n\nstruct skcipher_ctx {\n\tstruct list_head tsgl;\n\tstruct af_alg_sgl rsgl;\n\n\tvoid *iv;\n\n\tstruct af_alg_completion completion;\n\n\tatomic_t inflight;\n\tsize_t used;\n\n\tunsigned int len;\n\tbool more;\n\tbool merge;\n\tbool enc;\n\n\tstruct skcipher_request req;\n};\n\nstruct skcipher_async_rsgl {\n\tstruct af_alg_sgl sgl;\n\tstruct list_head list;\n};\n\nstruct skcipher_async_req {\n\tstruct kiocb *iocb;\n\tstruct skcipher_async_rsgl first_sgl;\n\tstruct list_head list;\n\tstruct scatterlist *tsg;\n\tchar iv[];\n};\n\n#define GET_SREQ(areq, ctx) (struct skcipher_async_req *)((char *)areq + \\\n\tcrypto_skcipher_reqsize(crypto_skcipher_reqtfm(&ctx->req)))\n\n#define GET_REQ_SIZE(ctx) \\\n\tcrypto_skcipher_reqsize(crypto_skcipher_reqtfm(&ctx->req))\n\n#define GET_IV_SIZE(ctx) \\\n\tcrypto_skcipher_ivsize(crypto_skcipher_reqtfm(&ctx->req))\n\n#define MAX_SGL_ENTS ((4096 - sizeof(struct skcipher_sg_list)) / \\\n\t\t      sizeof(struct scatterlist) - 1)\n\nstatic void skcipher_free_async_sgls(struct skcipher_async_req *sreq)\n{\n\tstruct skcipher_async_rsgl *rsgl, *tmp;\n\tstruct scatterlist *sgl;\n\tstruct scatterlist *sg;\n\tint i, n;\n\n\tlist_for_each_entry_safe(rsgl, tmp, &sreq->list, list) {\n\t\taf_alg_free_sg(&rsgl->sgl);\n\t\tif (rsgl != &sreq->first_sgl)\n\t\t\tkfree(rsgl);\n\t}\n\tsgl = sreq->tsg;\n\tn = sg_nents(sgl);\n\tfor_each_sg(sgl, sg, n, i)\n\t\tput_page(sg_page(sg));\n\n\tkfree(sreq->tsg);\n}\n\nstatic void skcipher_async_cb(struct crypto_async_request *req, int err)\n{\n\tstruct sock *sk = req->data;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct skcipher_async_req *sreq = GET_SREQ(req, ctx);\n\tstruct kiocb *iocb = sreq->iocb;\n\n\tatomic_dec(&ctx->inflight);\n\tskcipher_free_async_sgls(sreq);\n\tkfree(req);\n\tiocb->ki_complete(iocb, err, err);\n}\n\nstatic inline int skcipher_sndbuf(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\n\treturn max_t(int, max_t(int, sk->sk_sndbuf & PAGE_MASK, PAGE_SIZE) -\n\t\t\t  ctx->used, 0);\n}\n\nstatic inline bool skcipher_writable(struct sock *sk)\n{\n\treturn PAGE_SIZE <= skcipher_sndbuf(sk);\n}\n\nstatic int skcipher_alloc_sgl(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg = NULL;\n\n\tsgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);\n\tif (!list_empty(&ctx->tsgl))\n\t\tsg = sgl->sg;\n\n\tif (!sg || sgl->cur >= MAX_SGL_ENTS) {\n\t\tsgl = sock_kmalloc(sk, sizeof(*sgl) +\n\t\t\t\t       sizeof(sgl->sg[0]) * (MAX_SGL_ENTS + 1),\n\t\t\t\t   GFP_KERNEL);\n\t\tif (!sgl)\n\t\t\treturn -ENOMEM;\n\n\t\tsg_init_table(sgl->sg, MAX_SGL_ENTS + 1);\n\t\tsgl->cur = 0;\n\n\t\tif (sg)\n\t\t\tsg_chain(sg, MAX_SGL_ENTS + 1, sgl->sg);\n\n\t\tlist_add_tail(&sgl->list, &ctx->tsgl);\n\t}\n\n\treturn 0;\n}\n\nstatic void skcipher_pull_sgl(struct sock *sk, size_t used, int put)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg;\n\tint i;\n\n\twhile (!list_empty(&ctx->tsgl)) {\n\t\tsgl = list_first_entry(&ctx->tsgl, struct skcipher_sg_list,\n\t\t\t\t       list);\n\t\tsg = sgl->sg;\n\n\t\tfor (i = 0; i < sgl->cur; i++) {\n\t\t\tsize_t plen = min_t(size_t, used, sg[i].length);\n\n\t\t\tif (!sg_page(sg + i))\n\t\t\t\tcontinue;\n\n\t\t\tsg[i].length -= plen;\n\t\t\tsg[i].offset += plen;\n\n\t\t\tused -= plen;\n\t\t\tctx->used -= plen;\n\n\t\t\tif (sg[i].length)\n\t\t\t\treturn;\n\t\t\tif (put)\n\t\t\t\tput_page(sg_page(sg + i));\n\t\t\tsg_assign_page(sg + i, NULL);\n\t\t}\n\n\t\tlist_del(&sgl->list);\n\t\tsock_kfree_s(sk, sgl,\n\t\t\t     sizeof(*sgl) + sizeof(sgl->sg[0]) *\n\t\t\t\t\t    (MAX_SGL_ENTS + 1));\n\t}\n\n\tif (!ctx->used)\n\t\tctx->merge = 0;\n}\n\nstatic void skcipher_free_sgl(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\n\tskcipher_pull_sgl(sk, ctx->used, 1);\n}\n\nstatic int skcipher_wait_for_wmem(struct sock *sk, unsigned flags)\n{\n\tlong timeout;\n\tDEFINE_WAIT(wait);\n\tint err = -ERESTARTSYS;\n\n\tif (flags & MSG_DONTWAIT)\n\t\treturn -EAGAIN;\n\n\tsk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\n\tfor (;;) {\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\t\tif (sk_wait_event(sk, &timeout, skcipher_writable(sk))) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\n\treturn err;\n}\n\nstatic void skcipher_wmem_wakeup(struct sock *sk)\n{\n\tstruct socket_wq *wq;\n\n\tif (!skcipher_writable(sk))\n\t\treturn;\n\n\trcu_read_lock();\n\twq = rcu_dereference(sk->sk_wq);\n\tif (wq_has_sleeper(wq))\n\t\twake_up_interruptible_sync_poll(&wq->wait, POLLIN |\n\t\t\t\t\t\t\t   POLLRDNORM |\n\t\t\t\t\t\t\t   POLLRDBAND);\n\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);\n\trcu_read_unlock();\n}\n\nstatic int skcipher_wait_for_data(struct sock *sk, unsigned flags)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tlong timeout;\n\tDEFINE_WAIT(wait);\n\tint err = -ERESTARTSYS;\n\n\tif (flags & MSG_DONTWAIT) {\n\t\treturn -EAGAIN;\n\t}\n\n\tsk_set_bit(SOCKWQ_ASYNC_WAITDATA, sk);\n\n\tfor (;;) {\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\t\tif (sk_wait_event(sk, &timeout, ctx->used)) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\n\tsk_clear_bit(SOCKWQ_ASYNC_WAITDATA, sk);\n\n\treturn err;\n}\n\nstatic void skcipher_data_wakeup(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct socket_wq *wq;\n\n\tif (!ctx->used)\n\t\treturn;\n\n\trcu_read_lock();\n\twq = rcu_dereference(sk->sk_wq);\n\tif (wq_has_sleeper(wq))\n\t\twake_up_interruptible_sync_poll(&wq->wait, POLLOUT |\n\t\t\t\t\t\t\t   POLLRDNORM |\n\t\t\t\t\t\t\t   POLLRDBAND);\n\tsk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);\n\trcu_read_unlock();\n}\n\nstatic int skcipher_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t size)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(&ctx->req);\n\tunsigned ivsize = crypto_skcipher_ivsize(tfm);\n\tstruct skcipher_sg_list *sgl;\n\tstruct af_alg_control con = {};\n\tlong copied = 0;\n\tbool enc = 0;\n\tbool init = 0;\n\tint err;\n\tint i;\n\n\tif (msg->msg_controllen) {\n\t\terr = af_alg_cmsg_send(msg, &con);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tinit = 1;\n\t\tswitch (con.op) {\n\t\tcase ALG_OP_ENCRYPT:\n\t\t\tenc = 1;\n\t\t\tbreak;\n\t\tcase ALG_OP_DECRYPT:\n\t\t\tenc = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (con.iv && con.iv->ivlen != ivsize)\n\t\t\treturn -EINVAL;\n\t}\n\n\terr = -EINVAL;\n\n\tlock_sock(sk);\n\tif (!ctx->more && ctx->used)\n\t\tgoto unlock;\n\n\tif (init) {\n\t\tctx->enc = enc;\n\t\tif (con.iv)\n\t\t\tmemcpy(ctx->iv, con.iv->iv, ivsize);\n\t}\n\n\twhile (size) {\n\t\tstruct scatterlist *sg;\n\t\tunsigned long len = size;\n\t\tsize_t plen;\n\n\t\tif (ctx->merge) {\n\t\t\tsgl = list_entry(ctx->tsgl.prev,\n\t\t\t\t\t struct skcipher_sg_list, list);\n\t\t\tsg = sgl->sg + sgl->cur - 1;\n\t\t\tlen = min_t(unsigned long, len,\n\t\t\t\t    PAGE_SIZE - sg->offset - sg->length);\n\n\t\t\terr = memcpy_from_msg(page_address(sg_page(sg)) +\n\t\t\t\t\t      sg->offset + sg->length,\n\t\t\t\t\t      msg, len);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\n\t\t\tsg->length += len;\n\t\t\tctx->merge = (sg->offset + sg->length) &\n\t\t\t\t     (PAGE_SIZE - 1);\n\n\t\t\tctx->used += len;\n\t\t\tcopied += len;\n\t\t\tsize -= len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!skcipher_writable(sk)) {\n\t\t\terr = skcipher_wait_for_wmem(sk, msg->msg_flags);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t}\n\n\t\tlen = min_t(unsigned long, len, skcipher_sndbuf(sk));\n\n\t\terr = skcipher_alloc_sgl(sk);\n\t\tif (err)\n\t\t\tgoto unlock;\n\n\t\tsgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);\n\t\tsg = sgl->sg;\n\t\tsg_unmark_end(sg + sgl->cur);\n\t\tdo {\n\t\t\ti = sgl->cur;\n\t\t\tplen = min_t(size_t, len, PAGE_SIZE);\n\n\t\t\tsg_assign_page(sg + i, alloc_page(GFP_KERNEL));\n\t\t\terr = -ENOMEM;\n\t\t\tif (!sg_page(sg + i))\n\t\t\t\tgoto unlock;\n\n\t\t\terr = memcpy_from_msg(page_address(sg_page(sg + i)),\n\t\t\t\t\t      msg, plen);\n\t\t\tif (err) {\n\t\t\t\t__free_page(sg_page(sg + i));\n\t\t\t\tsg_assign_page(sg + i, NULL);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tsg[i].length = plen;\n\t\t\tlen -= plen;\n\t\t\tctx->used += plen;\n\t\t\tcopied += plen;\n\t\t\tsize -= plen;\n\t\t\tsgl->cur++;\n\t\t} while (len && sgl->cur < MAX_SGL_ENTS);\n\n\t\tif (!size)\n\t\t\tsg_mark_end(sg + sgl->cur - 1);\n\n\t\tctx->merge = plen & (PAGE_SIZE - 1);\n\t}\n\n\terr = 0;\n\n\tctx->more = msg->msg_flags & MSG_MORE;\n\nunlock:\n\tskcipher_data_wakeup(sk);\n\trelease_sock(sk);\n\n\treturn copied ?: err;\n}\n\nstatic ssize_t skcipher_sendpage(struct socket *sock, struct page *page,\n\t\t\t\t int offset, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct skcipher_sg_list *sgl;\n\tint err = -EINVAL;\n\n\tif (flags & MSG_SENDPAGE_NOTLAST)\n\t\tflags |= MSG_MORE;\n\n\tlock_sock(sk);\n\tif (!ctx->more && ctx->used)\n\t\tgoto unlock;\n\n\tif (!size)\n\t\tgoto done;\n\n\tif (!skcipher_writable(sk)) {\n\t\terr = skcipher_wait_for_wmem(sk, flags);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\terr = skcipher_alloc_sgl(sk);\n\tif (err)\n\t\tgoto unlock;\n\n\tctx->merge = 0;\n\tsgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);\n\n\tif (sgl->cur)\n\t\tsg_unmark_end(sgl->sg + sgl->cur - 1);\n\n\tsg_mark_end(sgl->sg + sgl->cur);\n\tget_page(page);\n\tsg_set_page(sgl->sg + sgl->cur, page, size, offset);\n\tsgl->cur++;\n\tctx->used += size;\n\ndone:\n\tctx->more = flags & MSG_MORE;\n\nunlock:\n\tskcipher_data_wakeup(sk);\n\trelease_sock(sk);\n\n\treturn err ?: size;\n}\n\nstatic int skcipher_all_sg_nents(struct skcipher_ctx *ctx)\n{\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg;\n\tint nents = 0;\n\n\tlist_for_each_entry(sgl, &ctx->tsgl, list) {\n\t\tsg = sgl->sg;\n\n\t\twhile (!sg->length)\n\t\t\tsg++;\n\n\t\tnents += sg_nents(sg);\n\t}\n\treturn nents;\n}\n\nstatic int skcipher_recvmsg_async(struct socket *sock, struct msghdr *msg,\n\t\t\t\t  int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg;\n\tstruct skcipher_async_req *sreq;\n\tstruct skcipher_request *req;\n\tstruct skcipher_async_rsgl *last_rsgl = NULL;\n\tunsigned int txbufs = 0, len = 0, tx_nents = skcipher_all_sg_nents(ctx);\n\tunsigned int reqlen = sizeof(struct skcipher_async_req) +\n\t\t\t\tGET_REQ_SIZE(ctx) + GET_IV_SIZE(ctx);\n\tint err = -ENOMEM;\n\tbool mark = false;\n\n\tlock_sock(sk);\n\treq = kmalloc(reqlen, GFP_KERNEL);\n\tif (unlikely(!req))\n\t\tgoto unlock;\n\n\tsreq = GET_SREQ(req, ctx);\n\tsreq->iocb = msg->msg_iocb;\n\tmemset(&sreq->first_sgl, '\\0', sizeof(struct skcipher_async_rsgl));\n\tINIT_LIST_HEAD(&sreq->list);\n\tsreq->tsg = kcalloc(tx_nents, sizeof(*sg), GFP_KERNEL);\n\tif (unlikely(!sreq->tsg)) {\n\t\tkfree(req);\n\t\tgoto unlock;\n\t}\n\tsg_init_table(sreq->tsg, tx_nents);\n\tmemcpy(sreq->iv, ctx->iv, GET_IV_SIZE(ctx));\n\tskcipher_request_set_tfm(req, crypto_skcipher_reqtfm(&ctx->req));\n\tskcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      skcipher_async_cb, sk);\n\n\twhile (iov_iter_count(&msg->msg_iter)) {\n\t\tstruct skcipher_async_rsgl *rsgl;\n\t\tint used;\n\n\t\tif (!ctx->used) {\n\t\t\terr = skcipher_wait_for_data(sk, flags);\n\t\t\tif (err)\n\t\t\t\tgoto free;\n\t\t}\n\t\tsgl = list_first_entry(&ctx->tsgl,\n\t\t\t\t       struct skcipher_sg_list, list);\n\t\tsg = sgl->sg;\n\n\t\twhile (!sg->length)\n\t\t\tsg++;\n\n\t\tused = min_t(unsigned long, ctx->used,\n\t\t\t     iov_iter_count(&msg->msg_iter));\n\t\tused = min_t(unsigned long, used, sg->length);\n\n\t\tif (txbufs == tx_nents) {\n\t\t\tstruct scatterlist *tmp;\n\t\t\tint x;\n\t\t\t/* Ran out of tx slots in async request\n\t\t\t * need to expand */\n\t\t\ttmp = kcalloc(tx_nents * 2, sizeof(*tmp),\n\t\t\t\t      GFP_KERNEL);\n\t\t\tif (!tmp)\n\t\t\t\tgoto free;\n\n\t\t\tsg_init_table(tmp, tx_nents * 2);\n\t\t\tfor (x = 0; x < tx_nents; x++)\n\t\t\t\tsg_set_page(&tmp[x], sg_page(&sreq->tsg[x]),\n\t\t\t\t\t    sreq->tsg[x].length,\n\t\t\t\t\t    sreq->tsg[x].offset);\n\t\t\tkfree(sreq->tsg);\n\t\t\tsreq->tsg = tmp;\n\t\t\ttx_nents *= 2;\n\t\t\tmark = true;\n\t\t}\n\t\t/* Need to take over the tx sgl from ctx\n\t\t * to the asynch req - these sgls will be freed later */\n\t\tsg_set_page(sreq->tsg + txbufs++, sg_page(sg), sg->length,\n\t\t\t    sg->offset);\n\n\t\tif (list_empty(&sreq->list)) {\n\t\t\trsgl = &sreq->first_sgl;\n\t\t\tlist_add_tail(&rsgl->list, &sreq->list);\n\t\t} else {\n\t\t\trsgl = kmalloc(sizeof(*rsgl), GFP_KERNEL);\n\t\t\tif (!rsgl) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\tlist_add_tail(&rsgl->list, &sreq->list);\n\t\t}\n\n\t\tused = af_alg_make_sg(&rsgl->sgl, &msg->msg_iter, used);\n\t\terr = used;\n\t\tif (used < 0)\n\t\t\tgoto free;\n\t\tif (last_rsgl)\n\t\t\taf_alg_link_sg(&last_rsgl->sgl, &rsgl->sgl);\n\n\t\tlast_rsgl = rsgl;\n\t\tlen += used;\n\t\tskcipher_pull_sgl(sk, used, 0);\n\t\tiov_iter_advance(&msg->msg_iter, used);\n\t}\n\n\tif (mark)\n\t\tsg_mark_end(sreq->tsg + txbufs - 1);\n\n\tskcipher_request_set_crypt(req, sreq->tsg, sreq->first_sgl.sgl.sg,\n\t\t\t\t   len, sreq->iv);\n\terr = ctx->enc ? crypto_skcipher_encrypt(req) :\n\t\t\t crypto_skcipher_decrypt(req);\n\tif (err == -EINPROGRESS) {\n\t\tatomic_inc(&ctx->inflight);\n\t\terr = -EIOCBQUEUED;\n\t\tgoto unlock;\n\t}\nfree:\n\tskcipher_free_async_sgls(sreq);\n\tkfree(req);\nunlock:\n\tskcipher_wmem_wakeup(sk);\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int skcipher_recvmsg_sync(struct socket *sock, struct msghdr *msg,\n\t\t\t\t int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tunsigned bs = crypto_skcipher_blocksize(crypto_skcipher_reqtfm(\n\t\t&ctx->req));\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg;\n\tint err = -EAGAIN;\n\tint used;\n\tlong copied = 0;\n\n\tlock_sock(sk);\n\twhile (msg_data_left(msg)) {\n\t\tsgl = list_first_entry(&ctx->tsgl,\n\t\t\t\t       struct skcipher_sg_list, list);\n\t\tsg = sgl->sg;\n\n\t\twhile (!sg->length)\n\t\t\tsg++;\n\n\t\tif (!ctx->used) {\n\t\t\terr = skcipher_wait_for_data(sk, flags);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t}\n\n\t\tused = min_t(unsigned long, ctx->used, msg_data_left(msg));\n\n\t\tused = af_alg_make_sg(&ctx->rsgl, &msg->msg_iter, used);\n\t\terr = used;\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\n\t\tif (ctx->more || used < ctx->used)\n\t\t\tused -= used % bs;\n\n\t\terr = -EINVAL;\n\t\tif (!used)\n\t\t\tgoto free;\n\n\t\tskcipher_request_set_crypt(&ctx->req, sg, ctx->rsgl.sg, used,\n\t\t\t\t\t   ctx->iv);\n\n\t\terr = af_alg_wait_for_completion(\n\t\t\t\tctx->enc ?\n\t\t\t\t\tcrypto_skcipher_encrypt(&ctx->req) :\n\t\t\t\t\tcrypto_skcipher_decrypt(&ctx->req),\n\t\t\t\t&ctx->completion);\n\nfree:\n\t\taf_alg_free_sg(&ctx->rsgl);\n\n\t\tif (err)\n\t\t\tgoto unlock;\n\n\t\tcopied += used;\n\t\tskcipher_pull_sgl(sk, used, 1);\n\t\tiov_iter_advance(&msg->msg_iter, used);\n\t}\n\n\terr = 0;\n\nunlock:\n\tskcipher_wmem_wakeup(sk);\n\trelease_sock(sk);\n\n\treturn copied ?: err;\n}\n\nstatic int skcipher_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t ignored, int flags)\n{\n\treturn (msg->msg_iocb && !is_sync_kiocb(msg->msg_iocb)) ?\n\t\tskcipher_recvmsg_async(sock, msg, flags) :\n\t\tskcipher_recvmsg_sync(sock, msg, flags);\n}\n\nstatic unsigned int skcipher_poll(struct file *file, struct socket *sock,\n\t\t\t\t  poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tunsigned int mask;\n\n\tsock_poll_wait(file, sk_sleep(sk), wait);\n\tmask = 0;\n\n\tif (ctx->used)\n\t\tmask |= POLLIN | POLLRDNORM;\n\n\tif (skcipher_writable(sk))\n\t\tmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\n\n\treturn mask;\n}\n\nstatic struct proto_ops algif_skcipher_ops = {\n\t.family\t\t=\tPF_ALG,\n\n\t.connect\t=\tsock_no_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.getname\t=\tsock_no_getname,\n\t.ioctl\t\t=\tsock_no_ioctl,\n\t.listen\t\t=\tsock_no_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.getsockopt\t=\tsock_no_getsockopt,\n\t.mmap\t\t=\tsock_no_mmap,\n\t.bind\t\t=\tsock_no_bind,\n\t.accept\t\t=\tsock_no_accept,\n\t.setsockopt\t=\tsock_no_setsockopt,\n\n\t.release\t=\taf_alg_release,\n\t.sendmsg\t=\tskcipher_sendmsg,\n\t.sendpage\t=\tskcipher_sendpage,\n\t.recvmsg\t=\tskcipher_recvmsg,\n\t.poll\t\t=\tskcipher_poll,\n};\n\nstatic void *skcipher_bind(const char *name, u32 type, u32 mask)\n{\n\treturn crypto_alloc_skcipher(name, type, mask);\n}\n\nstatic void skcipher_release(void *private)\n{\n\tcrypto_free_skcipher(private);\n}\n\nstatic int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)\n{\n\treturn crypto_skcipher_setkey(private, key, keylen);\n}\n\nstatic void skcipher_wait(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tint ctr = 0;\n\n\twhile (atomic_read(&ctx->inflight) && ctr++ < 100)\n\t\tmsleep(100);\n}\n\nstatic void skcipher_sock_destruct(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(&ctx->req);\n\n\tif (atomic_read(&ctx->inflight))\n\t\tskcipher_wait(sk);\n\n\tskcipher_free_sgl(sk);\n\tsock_kzfree_s(sk, ctx->iv, crypto_skcipher_ivsize(tfm));\n\tsock_kfree_s(sk, ctx, ctx->len);\n\taf_alg_release_parent(sk);\n}\n\nstatic int skcipher_accept_parent(void *private, struct sock *sk)\n{\n\tstruct skcipher_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);\n\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),\n\t\t\t       GFP_KERNEL);\n\tif (!ctx->iv) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(private));\n\n\tINIT_LIST_HEAD(&ctx->tsgl);\n\tctx->len = len;\n\tctx->used = 0;\n\tctx->more = 0;\n\tctx->merge = 0;\n\tctx->enc = 0;\n\tatomic_set(&ctx->inflight, 0);\n\taf_alg_init_completion(&ctx->completion);\n\n\task->private = ctx;\n\n\tskcipher_request_set_tfm(&ctx->req, private);\n\tskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      af_alg_complete, &ctx->completion);\n\n\tsk->sk_destruct = skcipher_sock_destruct;\n\n\treturn 0;\n}\n\nstatic const struct af_alg_type algif_type_skcipher = {\n\t.bind\t\t=\tskcipher_bind,\n\t.release\t=\tskcipher_release,\n\t.setkey\t\t=\tskcipher_setkey,\n\t.accept\t\t=\tskcipher_accept_parent,\n\t.ops\t\t=\t&algif_skcipher_ops,\n\t.name\t\t=\t\"skcipher\",\n\t.owner\t\t=\tTHIS_MODULE\n};\n\nstatic int __init algif_skcipher_init(void)\n{\n\treturn af_alg_register_type(&algif_type_skcipher);\n}\n\nstatic void __exit algif_skcipher_exit(void)\n{\n\tint err = af_alg_unregister_type(&algif_type_skcipher);\n\tBUG_ON(err);\n}\n\nmodule_init(algif_skcipher_init);\nmodule_exit(algif_skcipher_exit);\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["/*\n * algif_skcipher: User-space interface for skcipher algorithms\n *\n * This file provides the user-space API for symmetric key ciphers.\n *\n * Copyright (c) 2010 Herbert Xu <herbert@gondor.apana.org.au>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n */\n\n#include <crypto/scatterwalk.h>\n#include <crypto/skcipher.h>\n#include <crypto/if_alg.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/net.h>\n#include <net/sock.h>\n\nstruct skcipher_sg_list {\n\tstruct list_head list;\n\n\tint cur;\n\n\tstruct scatterlist sg[0];\n};\n\nstruct skcipher_tfm {\n\tstruct crypto_skcipher *skcipher;\n\tbool has_key;\n};\n\nstruct skcipher_ctx {\n\tstruct list_head tsgl;\n\tstruct af_alg_sgl rsgl;\n\n\tvoid *iv;\n\n\tstruct af_alg_completion completion;\n\n\tatomic_t inflight;\n\tsize_t used;\n\n\tunsigned int len;\n\tbool more;\n\tbool merge;\n\tbool enc;\n\n\tstruct skcipher_request req;\n};\n\nstruct skcipher_async_rsgl {\n\tstruct af_alg_sgl sgl;\n\tstruct list_head list;\n};\n\nstruct skcipher_async_req {\n\tstruct kiocb *iocb;\n\tstruct skcipher_async_rsgl first_sgl;\n\tstruct list_head list;\n\tstruct scatterlist *tsg;\n\tchar iv[];\n};\n\n#define GET_SREQ(areq, ctx) (struct skcipher_async_req *)((char *)areq + \\\n\tcrypto_skcipher_reqsize(crypto_skcipher_reqtfm(&ctx->req)))\n\n#define GET_REQ_SIZE(ctx) \\\n\tcrypto_skcipher_reqsize(crypto_skcipher_reqtfm(&ctx->req))\n\n#define GET_IV_SIZE(ctx) \\\n\tcrypto_skcipher_ivsize(crypto_skcipher_reqtfm(&ctx->req))\n\n#define MAX_SGL_ENTS ((4096 - sizeof(struct skcipher_sg_list)) / \\\n\t\t      sizeof(struct scatterlist) - 1)\n\nstatic void skcipher_free_async_sgls(struct skcipher_async_req *sreq)\n{\n\tstruct skcipher_async_rsgl *rsgl, *tmp;\n\tstruct scatterlist *sgl;\n\tstruct scatterlist *sg;\n\tint i, n;\n\n\tlist_for_each_entry_safe(rsgl, tmp, &sreq->list, list) {\n\t\taf_alg_free_sg(&rsgl->sgl);\n\t\tif (rsgl != &sreq->first_sgl)\n\t\t\tkfree(rsgl);\n\t}\n\tsgl = sreq->tsg;\n\tn = sg_nents(sgl);\n\tfor_each_sg(sgl, sg, n, i)\n\t\tput_page(sg_page(sg));\n\n\tkfree(sreq->tsg);\n}\n\nstatic void skcipher_async_cb(struct crypto_async_request *req, int err)\n{\n\tstruct sock *sk = req->data;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct skcipher_async_req *sreq = GET_SREQ(req, ctx);\n\tstruct kiocb *iocb = sreq->iocb;\n\n\tatomic_dec(&ctx->inflight);\n\tskcipher_free_async_sgls(sreq);\n\tkfree(req);\n\tiocb->ki_complete(iocb, err, err);\n}\n\nstatic inline int skcipher_sndbuf(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\n\treturn max_t(int, max_t(int, sk->sk_sndbuf & PAGE_MASK, PAGE_SIZE) -\n\t\t\t  ctx->used, 0);\n}\n\nstatic inline bool skcipher_writable(struct sock *sk)\n{\n\treturn PAGE_SIZE <= skcipher_sndbuf(sk);\n}\n\nstatic int skcipher_alloc_sgl(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg = NULL;\n\n\tsgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);\n\tif (!list_empty(&ctx->tsgl))\n\t\tsg = sgl->sg;\n\n\tif (!sg || sgl->cur >= MAX_SGL_ENTS) {\n\t\tsgl = sock_kmalloc(sk, sizeof(*sgl) +\n\t\t\t\t       sizeof(sgl->sg[0]) * (MAX_SGL_ENTS + 1),\n\t\t\t\t   GFP_KERNEL);\n\t\tif (!sgl)\n\t\t\treturn -ENOMEM;\n\n\t\tsg_init_table(sgl->sg, MAX_SGL_ENTS + 1);\n\t\tsgl->cur = 0;\n\n\t\tif (sg)\n\t\t\tsg_chain(sg, MAX_SGL_ENTS + 1, sgl->sg);\n\n\t\tlist_add_tail(&sgl->list, &ctx->tsgl);\n\t}\n\n\treturn 0;\n}\n\nstatic void skcipher_pull_sgl(struct sock *sk, size_t used, int put)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg;\n\tint i;\n\n\twhile (!list_empty(&ctx->tsgl)) {\n\t\tsgl = list_first_entry(&ctx->tsgl, struct skcipher_sg_list,\n\t\t\t\t       list);\n\t\tsg = sgl->sg;\n\n\t\tfor (i = 0; i < sgl->cur; i++) {\n\t\t\tsize_t plen = min_t(size_t, used, sg[i].length);\n\n\t\t\tif (!sg_page(sg + i))\n\t\t\t\tcontinue;\n\n\t\t\tsg[i].length -= plen;\n\t\t\tsg[i].offset += plen;\n\n\t\t\tused -= plen;\n\t\t\tctx->used -= plen;\n\n\t\t\tif (sg[i].length)\n\t\t\t\treturn;\n\t\t\tif (put)\n\t\t\t\tput_page(sg_page(sg + i));\n\t\t\tsg_assign_page(sg + i, NULL);\n\t\t}\n\n\t\tlist_del(&sgl->list);\n\t\tsock_kfree_s(sk, sgl,\n\t\t\t     sizeof(*sgl) + sizeof(sgl->sg[0]) *\n\t\t\t\t\t    (MAX_SGL_ENTS + 1));\n\t}\n\n\tif (!ctx->used)\n\t\tctx->merge = 0;\n}\n\nstatic void skcipher_free_sgl(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\n\tskcipher_pull_sgl(sk, ctx->used, 1);\n}\n\nstatic int skcipher_wait_for_wmem(struct sock *sk, unsigned flags)\n{\n\tlong timeout;\n\tDEFINE_WAIT(wait);\n\tint err = -ERESTARTSYS;\n\n\tif (flags & MSG_DONTWAIT)\n\t\treturn -EAGAIN;\n\n\tsk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\n\tfor (;;) {\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\t\tif (sk_wait_event(sk, &timeout, skcipher_writable(sk))) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\n\treturn err;\n}\n\nstatic void skcipher_wmem_wakeup(struct sock *sk)\n{\n\tstruct socket_wq *wq;\n\n\tif (!skcipher_writable(sk))\n\t\treturn;\n\n\trcu_read_lock();\n\twq = rcu_dereference(sk->sk_wq);\n\tif (wq_has_sleeper(wq))\n\t\twake_up_interruptible_sync_poll(&wq->wait, POLLIN |\n\t\t\t\t\t\t\t   POLLRDNORM |\n\t\t\t\t\t\t\t   POLLRDBAND);\n\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);\n\trcu_read_unlock();\n}\n\nstatic int skcipher_wait_for_data(struct sock *sk, unsigned flags)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tlong timeout;\n\tDEFINE_WAIT(wait);\n\tint err = -ERESTARTSYS;\n\n\tif (flags & MSG_DONTWAIT) {\n\t\treturn -EAGAIN;\n\t}\n\n\tsk_set_bit(SOCKWQ_ASYNC_WAITDATA, sk);\n\n\tfor (;;) {\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\t\tif (sk_wait_event(sk, &timeout, ctx->used)) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\n\tsk_clear_bit(SOCKWQ_ASYNC_WAITDATA, sk);\n\n\treturn err;\n}\n\nstatic void skcipher_data_wakeup(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct socket_wq *wq;\n\n\tif (!ctx->used)\n\t\treturn;\n\n\trcu_read_lock();\n\twq = rcu_dereference(sk->sk_wq);\n\tif (wq_has_sleeper(wq))\n\t\twake_up_interruptible_sync_poll(&wq->wait, POLLOUT |\n\t\t\t\t\t\t\t   POLLRDNORM |\n\t\t\t\t\t\t\t   POLLRDBAND);\n\tsk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);\n\trcu_read_unlock();\n}\n\nstatic int skcipher_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t size)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(&ctx->req);\n\tunsigned ivsize = crypto_skcipher_ivsize(tfm);\n\tstruct skcipher_sg_list *sgl;\n\tstruct af_alg_control con = {};\n\tlong copied = 0;\n\tbool enc = 0;\n\tbool init = 0;\n\tint err;\n\tint i;\n\n\tif (msg->msg_controllen) {\n\t\terr = af_alg_cmsg_send(msg, &con);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tinit = 1;\n\t\tswitch (con.op) {\n\t\tcase ALG_OP_ENCRYPT:\n\t\t\tenc = 1;\n\t\t\tbreak;\n\t\tcase ALG_OP_DECRYPT:\n\t\t\tenc = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (con.iv && con.iv->ivlen != ivsize)\n\t\t\treturn -EINVAL;\n\t}\n\n\terr = -EINVAL;\n\n\tlock_sock(sk);\n\tif (!ctx->more && ctx->used)\n\t\tgoto unlock;\n\n\tif (init) {\n\t\tctx->enc = enc;\n\t\tif (con.iv)\n\t\t\tmemcpy(ctx->iv, con.iv->iv, ivsize);\n\t}\n\n\twhile (size) {\n\t\tstruct scatterlist *sg;\n\t\tunsigned long len = size;\n\t\tsize_t plen;\n\n\t\tif (ctx->merge) {\n\t\t\tsgl = list_entry(ctx->tsgl.prev,\n\t\t\t\t\t struct skcipher_sg_list, list);\n\t\t\tsg = sgl->sg + sgl->cur - 1;\n\t\t\tlen = min_t(unsigned long, len,\n\t\t\t\t    PAGE_SIZE - sg->offset - sg->length);\n\n\t\t\terr = memcpy_from_msg(page_address(sg_page(sg)) +\n\t\t\t\t\t      sg->offset + sg->length,\n\t\t\t\t\t      msg, len);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\n\t\t\tsg->length += len;\n\t\t\tctx->merge = (sg->offset + sg->length) &\n\t\t\t\t     (PAGE_SIZE - 1);\n\n\t\t\tctx->used += len;\n\t\t\tcopied += len;\n\t\t\tsize -= len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!skcipher_writable(sk)) {\n\t\t\terr = skcipher_wait_for_wmem(sk, msg->msg_flags);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t}\n\n\t\tlen = min_t(unsigned long, len, skcipher_sndbuf(sk));\n\n\t\terr = skcipher_alloc_sgl(sk);\n\t\tif (err)\n\t\t\tgoto unlock;\n\n\t\tsgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);\n\t\tsg = sgl->sg;\n\t\tsg_unmark_end(sg + sgl->cur);\n\t\tdo {\n\t\t\ti = sgl->cur;\n\t\t\tplen = min_t(size_t, len, PAGE_SIZE);\n\n\t\t\tsg_assign_page(sg + i, alloc_page(GFP_KERNEL));\n\t\t\terr = -ENOMEM;\n\t\t\tif (!sg_page(sg + i))\n\t\t\t\tgoto unlock;\n\n\t\t\terr = memcpy_from_msg(page_address(sg_page(sg + i)),\n\t\t\t\t\t      msg, plen);\n\t\t\tif (err) {\n\t\t\t\t__free_page(sg_page(sg + i));\n\t\t\t\tsg_assign_page(sg + i, NULL);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tsg[i].length = plen;\n\t\t\tlen -= plen;\n\t\t\tctx->used += plen;\n\t\t\tcopied += plen;\n\t\t\tsize -= plen;\n\t\t\tsgl->cur++;\n\t\t} while (len && sgl->cur < MAX_SGL_ENTS);\n\n\t\tif (!size)\n\t\t\tsg_mark_end(sg + sgl->cur - 1);\n\n\t\tctx->merge = plen & (PAGE_SIZE - 1);\n\t}\n\n\terr = 0;\n\n\tctx->more = msg->msg_flags & MSG_MORE;\n\nunlock:\n\tskcipher_data_wakeup(sk);\n\trelease_sock(sk);\n\n\treturn copied ?: err;\n}\n\nstatic ssize_t skcipher_sendpage(struct socket *sock, struct page *page,\n\t\t\t\t int offset, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct skcipher_sg_list *sgl;\n\tint err = -EINVAL;\n\n\tif (flags & MSG_SENDPAGE_NOTLAST)\n\t\tflags |= MSG_MORE;\n\n\tlock_sock(sk);\n\tif (!ctx->more && ctx->used)\n\t\tgoto unlock;\n\n\tif (!size)\n\t\tgoto done;\n\n\tif (!skcipher_writable(sk)) {\n\t\terr = skcipher_wait_for_wmem(sk, flags);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\terr = skcipher_alloc_sgl(sk);\n\tif (err)\n\t\tgoto unlock;\n\n\tctx->merge = 0;\n\tsgl = list_entry(ctx->tsgl.prev, struct skcipher_sg_list, list);\n\n\tif (sgl->cur)\n\t\tsg_unmark_end(sgl->sg + sgl->cur - 1);\n\n\tsg_mark_end(sgl->sg + sgl->cur);\n\tget_page(page);\n\tsg_set_page(sgl->sg + sgl->cur, page, size, offset);\n\tsgl->cur++;\n\tctx->used += size;\n\ndone:\n\tctx->more = flags & MSG_MORE;\n\nunlock:\n\tskcipher_data_wakeup(sk);\n\trelease_sock(sk);\n\n\treturn err ?: size;\n}\n\nstatic int skcipher_all_sg_nents(struct skcipher_ctx *ctx)\n{\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg;\n\tint nents = 0;\n\n\tlist_for_each_entry(sgl, &ctx->tsgl, list) {\n\t\tsg = sgl->sg;\n\n\t\twhile (!sg->length)\n\t\t\tsg++;\n\n\t\tnents += sg_nents(sg);\n\t}\n\treturn nents;\n}\n\nstatic int skcipher_recvmsg_async(struct socket *sock, struct msghdr *msg,\n\t\t\t\t  int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg;\n\tstruct skcipher_async_req *sreq;\n\tstruct skcipher_request *req;\n\tstruct skcipher_async_rsgl *last_rsgl = NULL;\n\tunsigned int txbufs = 0, len = 0, tx_nents = skcipher_all_sg_nents(ctx);\n\tunsigned int reqlen = sizeof(struct skcipher_async_req) +\n\t\t\t\tGET_REQ_SIZE(ctx) + GET_IV_SIZE(ctx);\n\tint err = -ENOMEM;\n\tbool mark = false;\n\n\tlock_sock(sk);\n\treq = kmalloc(reqlen, GFP_KERNEL);\n\tif (unlikely(!req))\n\t\tgoto unlock;\n\n\tsreq = GET_SREQ(req, ctx);\n\tsreq->iocb = msg->msg_iocb;\n\tmemset(&sreq->first_sgl, '\\0', sizeof(struct skcipher_async_rsgl));\n\tINIT_LIST_HEAD(&sreq->list);\n\tsreq->tsg = kcalloc(tx_nents, sizeof(*sg), GFP_KERNEL);\n\tif (unlikely(!sreq->tsg)) {\n\t\tkfree(req);\n\t\tgoto unlock;\n\t}\n\tsg_init_table(sreq->tsg, tx_nents);\n\tmemcpy(sreq->iv, ctx->iv, GET_IV_SIZE(ctx));\n\tskcipher_request_set_tfm(req, crypto_skcipher_reqtfm(&ctx->req));\n\tskcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      skcipher_async_cb, sk);\n\n\twhile (iov_iter_count(&msg->msg_iter)) {\n\t\tstruct skcipher_async_rsgl *rsgl;\n\t\tint used;\n\n\t\tif (!ctx->used) {\n\t\t\terr = skcipher_wait_for_data(sk, flags);\n\t\t\tif (err)\n\t\t\t\tgoto free;\n\t\t}\n\t\tsgl = list_first_entry(&ctx->tsgl,\n\t\t\t\t       struct skcipher_sg_list, list);\n\t\tsg = sgl->sg;\n\n\t\twhile (!sg->length)\n\t\t\tsg++;\n\n\t\tused = min_t(unsigned long, ctx->used,\n\t\t\t     iov_iter_count(&msg->msg_iter));\n\t\tused = min_t(unsigned long, used, sg->length);\n\n\t\tif (txbufs == tx_nents) {\n\t\t\tstruct scatterlist *tmp;\n\t\t\tint x;\n\t\t\t/* Ran out of tx slots in async request\n\t\t\t * need to expand */\n\t\t\ttmp = kcalloc(tx_nents * 2, sizeof(*tmp),\n\t\t\t\t      GFP_KERNEL);\n\t\t\tif (!tmp)\n\t\t\t\tgoto free;\n\n\t\t\tsg_init_table(tmp, tx_nents * 2);\n\t\t\tfor (x = 0; x < tx_nents; x++)\n\t\t\t\tsg_set_page(&tmp[x], sg_page(&sreq->tsg[x]),\n\t\t\t\t\t    sreq->tsg[x].length,\n\t\t\t\t\t    sreq->tsg[x].offset);\n\t\t\tkfree(sreq->tsg);\n\t\t\tsreq->tsg = tmp;\n\t\t\ttx_nents *= 2;\n\t\t\tmark = true;\n\t\t}\n\t\t/* Need to take over the tx sgl from ctx\n\t\t * to the asynch req - these sgls will be freed later */\n\t\tsg_set_page(sreq->tsg + txbufs++, sg_page(sg), sg->length,\n\t\t\t    sg->offset);\n\n\t\tif (list_empty(&sreq->list)) {\n\t\t\trsgl = &sreq->first_sgl;\n\t\t\tlist_add_tail(&rsgl->list, &sreq->list);\n\t\t} else {\n\t\t\trsgl = kmalloc(sizeof(*rsgl), GFP_KERNEL);\n\t\t\tif (!rsgl) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\tlist_add_tail(&rsgl->list, &sreq->list);\n\t\t}\n\n\t\tused = af_alg_make_sg(&rsgl->sgl, &msg->msg_iter, used);\n\t\terr = used;\n\t\tif (used < 0)\n\t\t\tgoto free;\n\t\tif (last_rsgl)\n\t\t\taf_alg_link_sg(&last_rsgl->sgl, &rsgl->sgl);\n\n\t\tlast_rsgl = rsgl;\n\t\tlen += used;\n\t\tskcipher_pull_sgl(sk, used, 0);\n\t\tiov_iter_advance(&msg->msg_iter, used);\n\t}\n\n\tif (mark)\n\t\tsg_mark_end(sreq->tsg + txbufs - 1);\n\n\tskcipher_request_set_crypt(req, sreq->tsg, sreq->first_sgl.sgl.sg,\n\t\t\t\t   len, sreq->iv);\n\terr = ctx->enc ? crypto_skcipher_encrypt(req) :\n\t\t\t crypto_skcipher_decrypt(req);\n\tif (err == -EINPROGRESS) {\n\t\tatomic_inc(&ctx->inflight);\n\t\terr = -EIOCBQUEUED;\n\t\tgoto unlock;\n\t}\nfree:\n\tskcipher_free_async_sgls(sreq);\n\tkfree(req);\nunlock:\n\tskcipher_wmem_wakeup(sk);\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int skcipher_recvmsg_sync(struct socket *sock, struct msghdr *msg,\n\t\t\t\t int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tunsigned bs = crypto_skcipher_blocksize(crypto_skcipher_reqtfm(\n\t\t&ctx->req));\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg;\n\tint err = -EAGAIN;\n\tint used;\n\tlong copied = 0;\n\n\tlock_sock(sk);\n\twhile (msg_data_left(msg)) {\n\t\tsgl = list_first_entry(&ctx->tsgl,\n\t\t\t\t       struct skcipher_sg_list, list);\n\t\tsg = sgl->sg;\n\n\t\twhile (!sg->length)\n\t\t\tsg++;\n\n\t\tif (!ctx->used) {\n\t\t\terr = skcipher_wait_for_data(sk, flags);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t}\n\n\t\tused = min_t(unsigned long, ctx->used, msg_data_left(msg));\n\n\t\tused = af_alg_make_sg(&ctx->rsgl, &msg->msg_iter, used);\n\t\terr = used;\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\n\t\tif (ctx->more || used < ctx->used)\n\t\t\tused -= used % bs;\n\n\t\terr = -EINVAL;\n\t\tif (!used)\n\t\t\tgoto free;\n\n\t\tskcipher_request_set_crypt(&ctx->req, sg, ctx->rsgl.sg, used,\n\t\t\t\t\t   ctx->iv);\n\n\t\terr = af_alg_wait_for_completion(\n\t\t\t\tctx->enc ?\n\t\t\t\t\tcrypto_skcipher_encrypt(&ctx->req) :\n\t\t\t\t\tcrypto_skcipher_decrypt(&ctx->req),\n\t\t\t\t&ctx->completion);\n\nfree:\n\t\taf_alg_free_sg(&ctx->rsgl);\n\n\t\tif (err)\n\t\t\tgoto unlock;\n\n\t\tcopied += used;\n\t\tskcipher_pull_sgl(sk, used, 1);\n\t\tiov_iter_advance(&msg->msg_iter, used);\n\t}\n\n\terr = 0;\n\nunlock:\n\tskcipher_wmem_wakeup(sk);\n\trelease_sock(sk);\n\n\treturn copied ?: err;\n}\n\nstatic int skcipher_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t ignored, int flags)\n{\n\treturn (msg->msg_iocb && !is_sync_kiocb(msg->msg_iocb)) ?\n\t\tskcipher_recvmsg_async(sock, msg, flags) :\n\t\tskcipher_recvmsg_sync(sock, msg, flags);\n}\n\nstatic unsigned int skcipher_poll(struct file *file, struct socket *sock,\n\t\t\t\t  poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tunsigned int mask;\n\n\tsock_poll_wait(file, sk_sleep(sk), wait);\n\tmask = 0;\n\n\tif (ctx->used)\n\t\tmask |= POLLIN | POLLRDNORM;\n\n\tif (skcipher_writable(sk))\n\t\tmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\n\n\treturn mask;\n}\n\nstatic struct proto_ops algif_skcipher_ops = {\n\t.family\t\t=\tPF_ALG,\n\n\t.connect\t=\tsock_no_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.getname\t=\tsock_no_getname,\n\t.ioctl\t\t=\tsock_no_ioctl,\n\t.listen\t\t=\tsock_no_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.getsockopt\t=\tsock_no_getsockopt,\n\t.mmap\t\t=\tsock_no_mmap,\n\t.bind\t\t=\tsock_no_bind,\n\t.accept\t\t=\tsock_no_accept,\n\t.setsockopt\t=\tsock_no_setsockopt,\n\n\t.release\t=\taf_alg_release,\n\t.sendmsg\t=\tskcipher_sendmsg,\n\t.sendpage\t=\tskcipher_sendpage,\n\t.recvmsg\t=\tskcipher_recvmsg,\n\t.poll\t\t=\tskcipher_poll,\n};\n\nstatic void *skcipher_bind(const char *name, u32 type, u32 mask)\n{\n\tstruct skcipher_tfm *tfm;\n\tstruct crypto_skcipher *skcipher;\n\n\ttfm = kzalloc(sizeof(*tfm), GFP_KERNEL);\n\tif (!tfm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tskcipher = crypto_alloc_skcipher(name, type, mask);\n\tif (IS_ERR(skcipher)) {\n\t\tkfree(tfm);\n\t\treturn ERR_CAST(skcipher);\n\t}\n\n\ttfm->skcipher = skcipher;\n\n\treturn tfm;\n}\n\nstatic void skcipher_release(void *private)\n{\n\tstruct skcipher_tfm *tfm = private;\n\n\tcrypto_free_skcipher(tfm->skcipher);\n\tkfree(tfm);\n}\n\nstatic int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)\n{\n\tstruct skcipher_tfm *tfm = private;\n\tint err;\n\n\terr = crypto_skcipher_setkey(tfm->skcipher, key, keylen);\n\ttfm->has_key = !err;\n\n\treturn err;\n}\n\nstatic void skcipher_wait(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tint ctr = 0;\n\n\twhile (atomic_read(&ctx->inflight) && ctr++ < 100)\n\t\tmsleep(100);\n}\n\nstatic void skcipher_sock_destruct(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(&ctx->req);\n\n\tif (atomic_read(&ctx->inflight))\n\t\tskcipher_wait(sk);\n\n\tskcipher_free_sgl(sk);\n\tsock_kzfree_s(sk, ctx->iv, crypto_skcipher_ivsize(tfm));\n\tsock_kfree_s(sk, ctx, ctx->len);\n\taf_alg_release_parent(sk);\n}\n\nstatic int skcipher_accept_parent(void *private, struct sock *sk)\n{\n\tstruct skcipher_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_tfm *tfm = private;\n\tstruct crypto_skcipher *skcipher = tfm->skcipher;\n\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);\n\n\tif (!tfm->has_key)\n\t\treturn -ENOKEY;\n\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),\n\t\t\t       GFP_KERNEL);\n\tif (!ctx->iv) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(skcipher));\n\n\tINIT_LIST_HEAD(&ctx->tsgl);\n\tctx->len = len;\n\tctx->used = 0;\n\tctx->more = 0;\n\tctx->merge = 0;\n\tctx->enc = 0;\n\tatomic_set(&ctx->inflight, 0);\n\taf_alg_init_completion(&ctx->completion);\n\n\task->private = ctx;\n\n\tskcipher_request_set_tfm(&ctx->req, skcipher);\n\tskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      af_alg_complete, &ctx->completion);\n\n\tsk->sk_destruct = skcipher_sock_destruct;\n\n\treturn 0;\n}\n\nstatic const struct af_alg_type algif_type_skcipher = {\n\t.bind\t\t=\tskcipher_bind,\n\t.release\t=\tskcipher_release,\n\t.setkey\t\t=\tskcipher_setkey,\n\t.accept\t\t=\tskcipher_accept_parent,\n\t.ops\t\t=\t&algif_skcipher_ops,\n\t.name\t\t=\t\"skcipher\",\n\t.owner\t\t=\tTHIS_MODULE\n};\n\nstatic int __init algif_skcipher_init(void)\n{\n\treturn af_alg_register_type(&algif_type_skcipher);\n}\n\nstatic void __exit algif_skcipher_exit(void)\n{\n\tint err = af_alg_unregister_type(&algif_type_skcipher);\n\tBUG_ON(err);\n}\n\nmodule_init(algif_skcipher_init);\nmodule_exit(algif_skcipher_exit);\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["crypto/algif_skcipher.c"], "buggy_code_start_loc": [33], "buggy_code_end_loc": [822], "fixing_code_start_loc": [34], "fixing_code_end_loc": [856], "type": "CWE-476", "message": "crypto/algif_skcipher.c in the Linux kernel before 4.4.2 does not verify that a setkey operation has been performed on an AF_ALG socket before an accept system call is processed, which allows local users to cause a denial of service (NULL pointer dereference and system crash) via a crafted application that does not supply a key, related to the lrw_crypt function in crypto/lrw.c.", "other": {"cve": {"id": "CVE-2015-8970", "sourceIdentifier": "secalert@redhat.com", "published": "2016-11-28T03:59:02.310", "lastModified": "2023-02-13T00:55:21.783", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "crypto/algif_skcipher.c in the Linux kernel before 4.4.2 does not verify that a setkey operation has been performed on an AF_ALG socket before an accept system call is processed, which allows local users to cause a denial of service (NULL pointer dereference and system crash) via a crafted application that does not supply a key, related to the lrw_crypt function in crypto/lrw.c."}, {"lang": "es", "value": "crypto/algif_skcipher.c en el kernel Linux en versiones anteriores a 4.4.2 no verifica que una operaci\u00f3n setkey haya sido llevada a cabo en un enchufe AF_ALG antes de que una llamada de sistema aceptada sea procesada, lo que permite a usuarios locales provocar una denegaci\u00f3n de servicio (referencia a puntero NULO y ca\u00edda de sistema) a trav\u00e9s de una aplicaci\u00f3n manipulada que no aporta una llave, relacionado con la funci\u00f3n lrw_crypt en crypto/lrw.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.4.1", "matchCriteriaId": "EDD97C46-E284-47DB-B96A-3B8D5013F2F7"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=dd504589577d8e8e70f51f997ad487a4cb6c026f", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.4.2", "source": "secalert@redhat.com", "tags": ["Release Notes"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/11/04/3", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/94217", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1842", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2017:2077", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2017:2437", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2017:2444", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1386286", "source": "secalert@redhat.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/dd504589577d8e8e70f51f997ad487a4cb6c026f", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://groups.google.com/forum/#%21msg/syzkaller/frb2XrB5aWk/xCXzkIBcDAAJ", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/dd504589577d8e8e70f51f997ad487a4cb6c026f"}}