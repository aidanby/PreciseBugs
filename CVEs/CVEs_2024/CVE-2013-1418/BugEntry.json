{"buggy_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* kdc/main.c - Main procedure body for the KDC server process */\n/*\n * Copyright 1990,2001,2008,2009 by the Massachusetts Institute of Technology.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n/*\n * Copyright (c) 2006-2008, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdio.h>\n#include <syslog.h>\n#include <signal.h>\n#include <errno.h>\n#include <netdb.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <sys/wait.h>\n\n#include \"k5-int.h\"\n#include \"com_err.h\"\n#include \"adm.h\"\n#include \"adm_proto.h\"\n#include \"kdc_util.h\"\n#include \"extern.h\"\n#include \"kdc5_err.h\"\n#include \"kdb_kt.h\"\n#include \"net-server.h\"\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n\n#if defined(NEED_DAEMON_PROTO)\nextern int daemon(int, int);\n#endif\n\nstatic void usage (char *);\n\nstatic krb5_error_code setup_sam (void);\n\nstatic void initialize_realms (krb5_context, int, char **);\n\nstatic void finish_realms (void);\n\nstatic int nofork = 0;\nstatic int workers = 0;\nstatic const char *pid_file = NULL;\nstatic int rkey_init_done = 0;\nstatic volatile int signal_received = 0;\nstatic volatile int sighup_received = 0;\n\n#define KRB5_KDC_MAX_REALMS     32\n\nstatic krb5_context kdc_err_context;\nstatic const char *kdc_progname;\n\n/*\n * We use krb5_klog_init to set up a com_err callback to log error\n * messages.  The callback also pulls the error message out of the\n * context we pass to krb5_klog_init; however, we use realm-specific\n * contexts for most of our krb5 library calls, so the error message\n * isn't present in the global context.  This wrapper ensures that the\n * error message state from the call context is copied into the\n * context known by krb5_klog.  call_context can be NULL if the error\n * code did not come from a krb5 library function.\n */\nvoid\nkdc_err(krb5_context call_context, errcode_t code, const char *fmt, ...)\n{\n    va_list ap;\n\n    if (call_context)\n        krb5_copy_error_message(kdc_err_context, call_context);\n    va_start(ap, fmt);\n    com_err_va(kdc_progname, code, fmt, ap);\n    va_end(ap);\n}\n\n/*\n * Find the realm entry for a given realm.\n */\nkdc_realm_t *\nfind_realm_data(char *rname, krb5_ui_4 rsize)\n{\n    int i;\n    for (i=0; i<kdc_numrealms; i++) {\n        if ((rsize == strlen(kdc_realmlist[i]->realm_name)) &&\n            !strncmp(rname, kdc_realmlist[i]->realm_name, rsize))\n            return(kdc_realmlist[i]);\n    }\n    return((kdc_realm_t *) NULL);\n}\n\nkrb5_error_code\nsetup_server_realm(krb5_principal sprinc)\n{\n    krb5_error_code     kret;\n    kdc_realm_t         *newrealm;\n\n    kret = 0;\n    if (kdc_numrealms > 1) {\n        if (!(newrealm = find_realm_data(sprinc->realm.data,\n                                         (krb5_ui_4) sprinc->realm.length)))\n            kret = ENOENT;\n        else\n            kdc_active_realm = newrealm;\n    }\n    else\n        kdc_active_realm = kdc_realmlist[0];\n    return(kret);\n}\n\nstatic void\nfinish_realm(kdc_realm_t *rdp)\n{\n    if (rdp->realm_name)\n        free(rdp->realm_name);\n    if (rdp->realm_mpname)\n        free(rdp->realm_mpname);\n    if (rdp->realm_stash)\n        free(rdp->realm_stash);\n    if (rdp->realm_ports)\n        free(rdp->realm_ports);\n    if (rdp->realm_tcp_ports)\n        free(rdp->realm_tcp_ports);\n    if (rdp->realm_keytab)\n        krb5_kt_close(rdp->realm_context, rdp->realm_keytab);\n    if (rdp->realm_host_based_services)\n        free(rdp->realm_host_based_services);\n    if (rdp->realm_no_host_referral)\n        free(rdp->realm_no_host_referral);\n    if (rdp->realm_context) {\n        if (rdp->realm_mprinc)\n            krb5_free_principal(rdp->realm_context, rdp->realm_mprinc);\n        if (rdp->realm_mkey.length && rdp->realm_mkey.contents) {\n            /* XXX shouldn't memset be zap for safety? */\n            memset(rdp->realm_mkey.contents, 0, rdp->realm_mkey.length);\n            free(rdp->realm_mkey.contents);\n        }\n        if (rdp->mkey_list)\n            krb5_dbe_free_key_list(rdp->realm_context, rdp->mkey_list);\n        krb5_db_fini(rdp->realm_context);\n        if (rdp->realm_tgsprinc)\n            krb5_free_principal(rdp->realm_context, rdp->realm_tgsprinc);\n        krb5_free_context(rdp->realm_context);\n    }\n    memset(rdp, 0, sizeof(*rdp));\n    free(rdp);\n}\n\nstatic krb5_error_code\nhandle_referral_params(krb5_realm_params *rparams,\n                       char *no_refrls, char *host_based_srvcs,\n                       kdc_realm_t *rdp )\n{\n    krb5_error_code retval = 0;\n    if (no_refrls && krb5_match_config_pattern(no_refrls, KRB5_CONF_ASTERISK) == TRUE) {\n        rdp->realm_no_host_referral = strdup(KRB5_CONF_ASTERISK);\n        if (!rdp->realm_no_host_referral)\n            retval = ENOMEM;\n    } else {\n        if (rparams && rparams->realm_no_host_referral) {\n            if (krb5_match_config_pattern(rparams->realm_no_host_referral,\n                                          KRB5_CONF_ASTERISK) == TRUE) {\n                rdp->realm_no_host_referral = strdup(KRB5_CONF_ASTERISK);\n                if (!rdp->realm_no_host_referral)\n                    retval = ENOMEM;\n            } else if (no_refrls) {\n                if (asprintf(&(rdp->realm_no_host_referral),\n                             \"%s%s%s%s%s\", \" \", no_refrls,\" \",\n                             rparams->realm_no_host_referral, \" \") < 0)\n                    retval = ENOMEM;\n            } else if (asprintf(&(rdp->realm_no_host_referral),\"%s%s%s\", \" \",\n                                rparams->realm_no_host_referral, \" \") < 0)\n                retval = ENOMEM;\n        } else if( no_refrls != NULL) {\n            if ( asprintf(&(rdp->realm_no_host_referral),\n                          \"%s%s%s\", \" \", no_refrls, \" \") < 0)\n                retval = ENOMEM;\n        } else\n            rdp->realm_no_host_referral = NULL;\n    }\n\n    if (rdp->realm_no_host_referral &&\n        krb5_match_config_pattern(rdp->realm_no_host_referral,\n                                  KRB5_CONF_ASTERISK) == TRUE) {\n        rdp->realm_host_based_services = NULL;\n        return 0;\n    }\n\n    if (host_based_srvcs &&\n        (krb5_match_config_pattern(host_based_srvcs, KRB5_CONF_ASTERISK) == TRUE)) {\n        rdp->realm_host_based_services = strdup(KRB5_CONF_ASTERISK);\n        if (!rdp->realm_host_based_services)\n            retval = ENOMEM;\n    } else {\n        if (rparams && rparams->realm_host_based_services) {\n            if (krb5_match_config_pattern(rparams->realm_host_based_services,\n                                          KRB5_CONF_ASTERISK) == TRUE) {\n                rdp->realm_host_based_services = strdup(KRB5_CONF_ASTERISK);\n                if (!rdp->realm_host_based_services)\n                    retval = ENOMEM;\n            } else if (host_based_srvcs) {\n                if (asprintf(&(rdp->realm_host_based_services), \"%s%s%s%s%s\",\n                             \" \", host_based_srvcs,\" \",\n                             rparams->realm_host_based_services, \" \") < 0)\n                    retval = ENOMEM;\n            } else if (asprintf(&(rdp->realm_host_based_services),\"%s%s%s\", \" \",\n                                rparams->realm_host_based_services, \" \") < 0)\n                retval = ENOMEM;\n        } else if (host_based_srvcs) {\n            if (asprintf(&(rdp->realm_host_based_services),\"%s%s%s\", \" \",\n                         host_based_srvcs, \" \") < 0)\n                retval = ENOMEM;\n        } else\n            rdp->realm_host_based_services = NULL;\n    }\n\n    return retval;\n}\n\n/*\n * Initialize a realm control structure from the alternate profile or from\n * the specified defaults.\n *\n * After we're complete here, the essence of the realm is embodied in the\n * realm data and we should be all set to begin operation for that realm.\n */\nstatic krb5_error_code\ninit_realm(kdc_realm_t *rdp, char *realm, char *def_mpname,\n           krb5_enctype def_enctype, char *def_udp_ports, char *def_tcp_ports,\n           krb5_boolean def_manual, krb5_boolean def_restrict_anon,\n           char **db_args, char *no_refrls, char *host_based_srvcs)\n{\n    krb5_error_code     kret;\n    krb5_boolean        manual;\n    krb5_realm_params   *rparams;\n    int                 kdb_open_flags;\n    krb5_kvno       mkvno = IGNORE_VNO;\n\n    memset(rdp, 0, sizeof(kdc_realm_t));\n    if (!realm) {\n        kret = EINVAL;\n        goto whoops;\n    }\n\n    rdp->realm_name = strdup(realm);\n    if (rdp->realm_name == NULL) {\n        kret = ENOMEM;\n        goto whoops;\n    }\n    kret = krb5int_init_context_kdc(&rdp->realm_context);\n    if (kret) {\n        kdc_err(NULL, kret, _(\"while getting context for realm %s\"), realm);\n        goto whoops;\n    }\n\n    kret = krb5_read_realm_params(rdp->realm_context, rdp->realm_name,\n                                  &rparams);\n    if (kret) {\n        kdc_err(rdp->realm_context, kret, _(\"while reading realm parameters\"));\n        goto whoops;\n    }\n\n    /* Handle profile file name */\n    if (rparams && rparams->realm_profile) {\n        rdp->realm_profile = strdup(rparams->realm_profile);\n        if (!rdp->realm_profile) {\n            kret = ENOMEM;\n            goto whoops;\n        }\n    }\n\n    /* Handle master key name */\n    if (rparams && rparams->realm_mkey_name)\n        rdp->realm_mpname = strdup(rparams->realm_mkey_name);\n    else\n        rdp->realm_mpname = (def_mpname) ? strdup(def_mpname) :\n            strdup(KRB5_KDB_M_NAME);\n    if (!rdp->realm_mpname) {\n        kret = ENOMEM;\n        goto whoops;\n    }\n\n    /* Handle KDC ports */\n    if (rparams && rparams->realm_kdc_ports)\n        rdp->realm_ports = strdup(rparams->realm_kdc_ports);\n    else\n        rdp->realm_ports = strdup(def_udp_ports);\n    if (!rdp->realm_ports) {\n        kret = ENOMEM;\n        goto whoops;\n    }\n    if (rparams && rparams->realm_kdc_tcp_ports)\n        rdp->realm_tcp_ports = strdup(rparams->realm_kdc_tcp_ports);\n    else\n        rdp->realm_tcp_ports = strdup(def_tcp_ports);\n    if (!rdp->realm_tcp_ports) {\n        kret = ENOMEM;\n        goto whoops;\n    }\n    /* Handle stash file */\n    if (rparams && rparams->realm_stash_file) {\n        rdp->realm_stash = strdup(rparams->realm_stash_file);\n        if (!rdp->realm_stash) {\n            kret = ENOMEM;\n            goto whoops;\n        }\n        manual = FALSE;\n    } else\n        manual = def_manual;\n\n    if (rparams && rparams->realm_restrict_anon_valid)\n        rdp->realm_restrict_anon = rparams->realm_restrict_anon;\n    else\n        rdp->realm_restrict_anon = def_restrict_anon;\n\n    /* Handle master key type */\n    if (rparams && rparams->realm_enctype_valid)\n        rdp->realm_mkey.enctype = (krb5_enctype) rparams->realm_enctype;\n    else\n        rdp->realm_mkey.enctype = manual ? def_enctype : ENCTYPE_UNKNOWN;\n\n    /* Handle reject-bad-transit flag */\n    if (rparams && rparams->realm_reject_bad_transit_valid)\n        rdp->realm_reject_bad_transit = rparams->realm_reject_bad_transit;\n    else\n        rdp->realm_reject_bad_transit = 1;\n\n    /* Handle ticket maximum life */\n    rdp->realm_maxlife = (rparams && rparams->realm_max_life_valid) ?\n        rparams->realm_max_life : KRB5_KDB_MAX_LIFE;\n\n    /* Handle ticket renewable maximum life */\n    rdp->realm_maxrlife = (rparams && rparams->realm_max_rlife_valid) ?\n        rparams->realm_max_rlife : KRB5_KDB_MAX_RLIFE;\n\n    /* Handle KDC referrals */\n    kret = handle_referral_params(rparams, no_refrls, host_based_srvcs, rdp);\n    if (kret == ENOMEM)\n        goto whoops;\n\n    if (rparams)\n        krb5_free_realm_params(rdp->realm_context, rparams);\n\n    /*\n     * We've got our parameters, now go and setup our realm context.\n     */\n\n    /* Set the default realm of this context */\n    if ((kret = krb5_set_default_realm(rdp->realm_context, realm))) {\n        kdc_err(rdp->realm_context, kret,\n                _(\"while setting default realm to %s\"), realm);\n        goto whoops;\n    }\n\n    /* first open the database  before doing anything */\n    kdb_open_flags = KRB5_KDB_OPEN_RW | KRB5_KDB_SRV_TYPE_KDC;\n    if ((kret = krb5_db_open(rdp->realm_context, db_args, kdb_open_flags))) {\n        kdc_err(rdp->realm_context, kret,\n                _(\"while initializing database for realm %s\"), realm);\n        goto whoops;\n    }\n\n    /* Assemble and parse the master key name */\n    if ((kret = krb5_db_setup_mkey_name(rdp->realm_context, rdp->realm_mpname,\n                                        rdp->realm_name, (char **) NULL,\n                                        &rdp->realm_mprinc))) {\n        kdc_err(rdp->realm_context, kret,\n                _(\"while setting up master key name %s for realm %s\"),\n                rdp->realm_mpname, realm);\n        goto whoops;\n    }\n\n    /*\n     * Get the master key (note, may not be the most current mkey).\n     */\n    if ((kret = krb5_db_fetch_mkey(rdp->realm_context, rdp->realm_mprinc,\n                                   rdp->realm_mkey.enctype, manual,\n                                   FALSE, rdp->realm_stash,\n                                   &mkvno, NULL, &rdp->realm_mkey))) {\n        kdc_err(rdp->realm_context, kret,\n                _(\"while fetching master key %s for realm %s\"),\n                rdp->realm_mpname, realm);\n        goto whoops;\n    }\n\n    if ((kret = krb5_db_fetch_mkey_list(rdp->realm_context, rdp->realm_mprinc,\n                                        &rdp->realm_mkey, mkvno, &rdp->mkey_list))) {\n        kdc_err(rdp->realm_context, kret,\n                _(\"while fetching master keys list for realm %s\"), realm);\n        goto whoops;\n    }\n\n\n    /* Set up the keytab */\n    if ((kret = krb5_ktkdb_resolve(rdp->realm_context, NULL,\n                                   &rdp->realm_keytab))) {\n        kdc_err(rdp->realm_context, kret,\n                _(\"while resolving kdb keytab for realm %s\"), realm);\n        goto whoops;\n    }\n\n    /* Preformat the TGS name */\n    if ((kret = krb5_build_principal(rdp->realm_context, &rdp->realm_tgsprinc,\n                                     strlen(realm), realm, KRB5_TGS_NAME,\n                                     realm, (char *) NULL))) {\n        kdc_err(rdp->realm_context, kret,\n                _(\"while building TGS name for realm %s\"), realm);\n        goto whoops;\n    }\n\n    if (!rkey_init_done) {\n        krb5_data seed;\n        /*\n         * If all that worked, then initialize the random key\n         * generators.\n         */\n\n        seed.length = rdp->realm_mkey.length;\n        seed.data = (char *)rdp->realm_mkey.contents;\n\n        if ((kret = krb5_c_random_add_entropy(rdp->realm_context,\n                                              KRB5_C_RANDSOURCE_TRUSTEDPARTY, &seed)))\n            goto whoops;\n\n        rkey_init_done = 1;\n    }\nwhoops:\n    /*\n     * If we choked, then clean up any dirt we may have dropped on the floor.\n     */\n    if (kret) {\n\n        finish_realm(rdp);\n    }\n    return(kret);\n}\n\nstatic krb5_sigtype\non_monitor_signal(int signo)\n{\n    signal_received = signo;\n\n#ifdef POSIX_SIGTYPE\n    return;\n#else\n    return(0);\n#endif\n}\n\nstatic krb5_sigtype\non_monitor_sighup(int signo)\n{\n    sighup_received = 1;\n\n#ifdef POSIX_SIGTYPE\n    return;\n#else\n    return(0);\n#endif\n}\n\n/*\n * Kill the worker subprocesses given by pids[0..bound-1], skipping any which\n * are set to -1, and wait for them to exit (so that we know the ports are no\n * longer in use).\n */\nstatic void\nterminate_workers(pid_t *pids, int bound)\n{\n    int i, status, num_active = 0;\n    pid_t pid;\n\n    /* Kill the active worker pids. */\n    for (i = 0; i < bound; i++) {\n        if (pids[i] == -1)\n            continue;\n        kill(pids[i], SIGTERM);\n        num_active++;\n    }\n\n    /* Wait for them to exit. */\n    while (num_active > 0) {\n        pid = wait(&status);\n        if (pid >= 0)\n            num_active--;\n    }\n}\n\n/*\n * Create num worker processes and return successfully in each child.  The\n * parent process will act as a supervisor and will only return from this\n * function in error cases.\n */\nstatic krb5_error_code\ncreate_workers(verto_ctx *ctx, int num)\n{\n    krb5_error_code retval;\n    int i, status;\n    pid_t pid, *pids;\n#ifdef POSIX_SIGNALS\n    struct sigaction s_action;\n#endif /* POSIX_SIGNALS */\n\n    /*\n     * Setup our signal handlers which will forward to the children.\n     * These handlers will be overriden in the child processes.\n     */\n#ifdef POSIX_SIGNALS\n    (void) sigemptyset(&s_action.sa_mask);\n    s_action.sa_flags = 0;\n    s_action.sa_handler = on_monitor_signal;\n    (void) sigaction(SIGINT, &s_action, (struct sigaction *) NULL);\n    (void) sigaction(SIGTERM, &s_action, (struct sigaction *) NULL);\n    (void) sigaction(SIGQUIT, &s_action, (struct sigaction *) NULL);\n    s_action.sa_handler = on_monitor_sighup;\n    (void) sigaction(SIGHUP, &s_action, (struct sigaction *) NULL);\n#else  /* POSIX_SIGNALS */\n    signal(SIGINT, on_monitor_signal);\n    signal(SIGTERM, on_monitor_signal);\n    signal(SIGQUIT, on_monitor_signal);\n    signal(SIGHUP, on_monitor_sighup);\n#endif /* POSIX_SIGNALS */\n\n    /* Create child worker processes; return in each child. */\n    krb5_klog_syslog(LOG_INFO, _(\"creating %d worker processes\"), num);\n    pids = calloc(num, sizeof(pid_t));\n    if (pids == NULL)\n        return ENOMEM;\n    for (i = 0; i < num; i++) {\n        pid = fork();\n        if (pid == 0) {\n            if (!verto_reinitialize(ctx)) {\n                krb5_klog_syslog(LOG_ERR,\n                                 _(\"Unable to reinitialize main loop\"));\n                return ENOMEM;\n            }\n            retval = loop_setup_signals(ctx, NULL, reset_for_hangup);\n            if (retval) {\n                krb5_klog_syslog(LOG_ERR, _(\"Unable to initialize signal \"\n                                            \"handlers in pid %d\"), pid);\n                return retval;\n            }\n\n            /* Avoid race condition */\n            if (signal_received)\n                exit(0);\n\n            /* Return control to main() in the new worker process. */\n            free(pids);\n            return 0;\n        }\n        if (pid == -1) {\n            /* Couldn't fork enough times. */\n            status = errno;\n            terminate_workers(pids, i);\n            free(pids);\n            return status;\n        }\n        pids[i] = pid;\n    }\n\n    /* We're going to use our own main loop here. */\n    loop_free(ctx);\n\n    /* Supervise the worker processes. */\n    while (!signal_received) {\n        /* Wait until a worker process exits or we get a signal. */\n        pid = wait(&status);\n        if (pid >= 0) {\n            krb5_klog_syslog(LOG_ERR, _(\"worker %ld exited with status %d\"),\n                             (long) pid, status);\n\n            /* Remove the pid from the table. */\n            for (i = 0; i < num; i++) {\n                if (pids[i] == pid)\n                    pids[i] = -1;\n            }\n\n            /* When one worker process exits, terminate them all, so that KDC\n             * crashes behave similarly with or without worker processes. */\n            break;\n        }\n\n        /* Propagate HUP signal to worker processes if we received one. */\n        if (sighup_received) {\n            sighup_received = 0;\n            for (i = 0; i < num; i++) {\n                if (pids[i] != -1)\n                    kill(pids[i], SIGHUP);\n            }\n        }\n    }\n    if (signal_received)\n        krb5_klog_syslog(LOG_INFO, _(\"signal %d received in supervisor\"),\n                         signal_received);\n\n    terminate_workers(pids, num);\n    free(pids);\n    exit(0);\n}\n\nstatic krb5_error_code\nsetup_sam(void)\n{\n    return krb5_c_make_random_key(kdc_context, ENCTYPE_DES_CBC_MD5, &psr_key);\n}\n\nstatic void\nusage(char *name)\n{\n    fprintf(stderr,\n            _(\"usage: %s [-x db_args]* [-d dbpathname] [-r dbrealmname]\\n\"\n              \"\\t\\t[-R replaycachename] [-m] [-k masterenctype]\\n\"\n              \"\\t\\t[-M masterkeyname] [-p port] [-P pid_file]\\n\"\n              \"\\t\\t[-n] [-w numworkers] [/]\\n\\n\"\n              \"where,\\n\"\n              \"\\t[-x db_args]* - Any number of database specific arguments.\\n\"\n              \"\\t\\t\\tLook at each database module documentation for \"\n              \"\\t\\t\\tsupported arguments\\n\"),\n            name);\n    exit(1);\n}\n\n\nstatic void\ninitialize_realms(krb5_context kcontext, int argc, char **argv)\n{\n    int                 c;\n    char                *db_name = (char *) NULL;\n    char                *lrealm = (char *) NULL;\n    char                *mkey_name = (char *) NULL;\n    krb5_error_code     retval;\n    krb5_enctype        menctype = ENCTYPE_UNKNOWN;\n    kdc_realm_t         *rdatap = NULL;\n    krb5_boolean        manual = FALSE;\n    krb5_boolean        def_restrict_anon;\n    char                *default_udp_ports = 0;\n    char                *default_tcp_ports = 0;\n    krb5_pointer        aprof;\n    const char          *hierarchy[3];\n    char                *no_refrls = NULL;\n    char                *host_based_srvcs = NULL;\n    int                  db_args_size = 0;\n    char                **db_args = NULL;\n\n    extern char *optarg;\n\n    if (!krb5_aprof_init(DEFAULT_KDC_PROFILE, KDC_PROFILE_ENV, &aprof)) {\n        hierarchy[0] = KRB5_CONF_KDCDEFAULTS;\n        hierarchy[1] = KRB5_CONF_KDC_PORTS;\n        hierarchy[2] = (char *) NULL;\n        if (krb5_aprof_get_string(aprof, hierarchy, TRUE, &default_udp_ports))\n            default_udp_ports = 0;\n        hierarchy[1] = KRB5_CONF_KDC_TCP_PORTS;\n        if (krb5_aprof_get_string(aprof, hierarchy, TRUE, &default_tcp_ports))\n            default_tcp_ports = 0;\n        hierarchy[1] = KRB5_CONF_MAX_DGRAM_REPLY_SIZE;\n        if (krb5_aprof_get_int32(aprof, hierarchy, TRUE, &max_dgram_reply_size))\n            max_dgram_reply_size = MAX_DGRAM_SIZE;\n        hierarchy[1] = KRB5_CONF_RESTRICT_ANONYMOUS_TO_TGT;\n        if (krb5_aprof_get_boolean(aprof, hierarchy, TRUE, &def_restrict_anon))\n            def_restrict_anon = FALSE;\n        hierarchy[1] = KRB5_CONF_NO_HOST_REFERRAL;\n        if (krb5_aprof_get_string_all(aprof, hierarchy, &no_refrls))\n            no_refrls = 0;\n        if (!no_refrls ||\n            krb5_match_config_pattern(no_refrls, KRB5_CONF_ASTERISK) == FALSE) {\n            hierarchy[1] = KRB5_CONF_HOST_BASED_SERVICES;\n            if (krb5_aprof_get_string_all(aprof, hierarchy, &host_based_srvcs))\n                host_based_srvcs = 0;\n        }\n\n        krb5_aprof_finish(aprof);\n    }\n\n    if (default_udp_ports == 0) {\n        default_udp_ports = strdup(DEFAULT_KDC_UDP_PORTLIST);\n        if (default_udp_ports == 0) {\n            fprintf(stderr, _(\" KDC cannot initialize. Not enough memory\\n\"));\n            exit(1);\n        }\n    }\n    if (default_tcp_ports == 0) {\n        default_tcp_ports = strdup(DEFAULT_KDC_TCP_PORTLIST);\n        if (default_tcp_ports == 0) {\n            fprintf(stderr, _(\" KDC cannot initialize. Not enough memory\\n\"));\n            exit(1);\n        }\n    }\n\n    /*\n     * Loop through the option list.  Each time we encounter a realm name,\n     * use the previously scanned options to fill in for defaults.\n     */\n    while ((c = getopt(argc, argv, \"x:r:d:mM:k:R:e:P:p:s:nw:4:X3\")) != -1) {\n        switch(c) {\n        case 'x':\n            db_args_size++;\n            {\n                char **temp = realloc( db_args, sizeof(char*) * (db_args_size+1)); /* one for NULL */\n                if( temp == NULL )\n                {\n                    fprintf(stderr, _(\"%s: KDC cannot initialize. Not enough \"\n                                      \"memory\\n\"), argv[0]);\n                    exit(1);\n                }\n\n                db_args = temp;\n            }\n            db_args[db_args_size-1] = optarg;\n            db_args[db_args_size]   = NULL;\n            break;\n\n        case 'r':                       /* realm name for db */\n            if (!find_realm_data(optarg, (krb5_ui_4) strlen(optarg))) {\n                if ((rdatap = (kdc_realm_t *) malloc(sizeof(kdc_realm_t)))) {\n                    if ((retval = init_realm(rdatap, optarg, mkey_name,\n                                             menctype, default_udp_ports,\n                                             default_tcp_ports, manual,\n                                             def_restrict_anon, db_args,\n                                             no_refrls, host_based_srvcs))) {\n                        fprintf(stderr, _(\"%s: cannot initialize realm %s - \"\n                                          \"see log file for details\\n\"),\n                                argv[0], optarg);\n                        exit(1);\n                    }\n                    kdc_realmlist[kdc_numrealms] = rdatap;\n                    kdc_numrealms++;\n                    free(db_args), db_args=NULL, db_args_size = 0;\n                }\n                else\n                {\n                    fprintf(stderr, _(\"%s: cannot initialize realm %s. Not \"\n                                      \"enough memory\\n\"), argv[0], optarg);\n                    exit(1);\n                }\n            }\n            break;\n        case 'd':                       /* pathname for db */\n            /* now db_name is not a seperate argument.\n             * It has to be passed as part of the db_args\n             */\n            if( db_name == NULL ) {\n                if (asprintf(&db_name, \"dbname=%s\", optarg) < 0) {\n                    fprintf(stderr, _(\"%s: KDC cannot initialize. Not enough \"\n                                      \"memory\\n\"), argv[0]);\n                    exit(1);\n                }\n            }\n\n            db_args_size++;\n            {\n                char **temp = realloc( db_args, sizeof(char*) * (db_args_size+1)); /* one for NULL */\n                if( temp == NULL )\n                {\n                    fprintf(stderr, _(\"%s: KDC cannot initialize. Not enough \"\n                                      \"memory\\n\"), argv[0]);\n                    exit(1);\n                }\n\n                db_args = temp;\n            }\n            db_args[db_args_size-1] = db_name;\n            db_args[db_args_size]   = NULL;\n            break;\n        case 'm':                       /* manual type-in of master key */\n            manual = TRUE;\n            if (menctype == ENCTYPE_UNKNOWN)\n                menctype = ENCTYPE_DES_CBC_CRC;\n            break;\n        case 'M':                       /* master key name in DB */\n            mkey_name = optarg;\n            break;\n        case 'n':\n            nofork++;                   /* don't detach from terminal */\n            break;\n        case 'w':                       /* create multiple worker processes */\n            workers = atoi(optarg);\n            if (workers <= 0)\n                usage(argv[0]);\n            break;\n        case 'k':                       /* enctype for master key */\n            if (krb5_string_to_enctype(optarg, &menctype))\n                com_err(argv[0], 0, _(\"invalid enctype %s\"), optarg);\n            break;\n        case 'R':\n            /* Replay cache name; defunct since we don't use a replay cache. */\n            break;\n        case 'P':\n            pid_file = optarg;\n            break;\n        case 'p':\n            if (default_udp_ports)\n                free(default_udp_ports);\n            default_udp_ports = strdup(optarg);\n            if (!default_udp_ports) {\n                fprintf(stderr, _(\" KDC cannot initialize. Not enough \"\n                                  \"memory\\n\"));\n                exit(1);\n            }\n#if 0 /* not yet */\n            if (default_tcp_ports)\n                free(default_tcp_ports);\n            default_tcp_ports = strdup(optarg);\n#endif\n            break;\n        case '4':\n            break;\n        case 'X':\n            break;\n        case '?':\n        default:\n            usage(argv[0]);\n        }\n    }\n\n    /*\n     * Check to see if we processed any realms.\n     */\n    if (kdc_numrealms == 0) {\n        /* no realm specified, use default realm */\n        if ((retval = krb5_get_default_realm(kcontext, &lrealm))) {\n            com_err(argv[0], retval,\n                    _(\"while attempting to retrieve default realm\"));\n            fprintf (stderr,\n                     _(\"%s: %s, attempting to retrieve default realm\\n\"),\n                     argv[0], krb5_get_error_message(kcontext, retval));\n            exit(1);\n        }\n        if ((rdatap = (kdc_realm_t *) malloc(sizeof(kdc_realm_t)))) {\n            if ((retval = init_realm(rdatap, lrealm, mkey_name, menctype,\n                                     default_udp_ports, default_tcp_ports,\n                                     manual, def_restrict_anon, db_args,\n                                     no_refrls, host_based_srvcs))) {\n                fprintf(stderr, _(\"%s: cannot initialize realm %s - see log \"\n                                  \"file for details\\n\"), argv[0], lrealm);\n                exit(1);\n            }\n            kdc_realmlist[0] = rdatap;\n            kdc_numrealms++;\n        }\n        krb5_free_default_realm(kcontext, lrealm);\n    }\n\n    /* Ensure that this is set for our first request. */\n    kdc_active_realm = kdc_realmlist[0];\n    if (default_udp_ports)\n        free(default_udp_ports);\n    if (default_tcp_ports)\n        free(default_tcp_ports);\n    if (db_args)\n        free(db_args);\n    if (db_name)\n        free(db_name);\n    if (host_based_srvcs)\n        free(host_based_srvcs);\n    if (no_refrls)\n        free(no_refrls);\n\n    return;\n}\n\nstatic krb5_error_code\nwrite_pid_file(const char *path)\n{\n    FILE *file;\n    unsigned long pid;\n\n    file = fopen(path, \"w\");\n    if (file == NULL)\n        return errno;\n    pid = (unsigned long) getpid();\n    if (fprintf(file, \"%ld\\n\", pid) < 0 || fclose(file) == EOF)\n        return errno;\n    return 0;\n}\n\nstatic void\nfinish_realms()\n{\n    int i;\n\n    for (i = 0; i < kdc_numrealms; i++) {\n        finish_realm(kdc_realmlist[i]);\n        kdc_realmlist[i] = 0;\n    }\n    kdc_numrealms = 0;\n}\n\n/*\n  outline:\n\n  process args & setup\n\n  initialize database access (fetch master key, open DB)\n\n  initialize network\n\n  loop:\n  listen for packet\n\n  determine packet type, dispatch to handling routine\n  (AS or TGS (or V4?))\n\n  reflect response\n\n  exit on signal\n\n  clean up secrets, close db\n\n  shut down network\n\n  exit\n*/\n\nint main(int argc, char **argv)\n{\n    krb5_error_code     retval;\n    krb5_context        kcontext;\n    verto_ctx *ctx;\n    int errout = 0;\n    int i;\n\n    setlocale(LC_MESSAGES, \"\");\n    if (strrchr(argv[0], '/'))\n        argv[0] = strrchr(argv[0], '/')+1;\n\n    if (!(kdc_realmlist = (kdc_realm_t **) malloc(sizeof(kdc_realm_t *) *\n                                                  KRB5_KDC_MAX_REALMS))) {\n        fprintf(stderr, _(\"%s: cannot get memory for realm list\\n\"), argv[0]);\n        exit(1);\n    }\n    memset(kdc_realmlist, 0,\n           (size_t) (sizeof(kdc_realm_t *) * KRB5_KDC_MAX_REALMS));\n\n    /*\n     * A note about Kerberos contexts: This context, \"kcontext\", is used\n     * for the KDC operations, i.e. setup, network connection and error\n     * reporting.  The per-realm operations use the \"realm_context\"\n     * associated with each realm.\n     */\n    retval = krb5int_init_context_kdc(&kcontext);\n    if (retval) {\n        com_err(argv[0], retval, _(\"while initializing krb5\"));\n        exit(1);\n    }\n    krb5_klog_init(kcontext, \"kdc\", argv[0], 1);\n    kdc_err_context = kcontext;\n    kdc_progname = argv[0];\n    /* N.B.: After this point, com_err sends output to the KDC log\n       file, and not to stderr.  We use the kdc_err wrapper around\n       com_err to ensure that the error state exists in the context\n       known to the krb5_klog callback. */\n\n    initialize_kdc5_error_table();\n\n    /*\n     * Scan through the argument list\n     */\n    initialize_realms(kcontext, argc, argv);\n\n    ctx = loop_init(VERTO_EV_TYPE_NONE);\n    if (!ctx) {\n        kdc_err(kcontext, ENOMEM, _(\"while creating main loop\"));\n        finish_realms();\n        return 1;\n    }\n\n    load_preauth_plugins(kcontext);\n    load_authdata_plugins(kcontext);\n\n    retval = setup_sam();\n    if (retval) {\n        kdc_err(kcontext, retval, _(\"while initializing SAM\"));\n        finish_realms();\n        return 1;\n    }\n\n    /* Handle each realm's ports */\n    for (i=0; i<kdc_numrealms; i++) {\n        char *cp = kdc_realmlist[i]->realm_ports;\n        int port;\n        while (cp && *cp) {\n            if (*cp == ',' || isspace((int) *cp)) {\n                cp++;\n                continue;\n            }\n            port = strtol(cp, &cp, 10);\n            if (cp == 0)\n                break;\n            retval = loop_add_udp_port(port);\n            if (retval)\n                goto net_init_error;\n        }\n\n        cp = kdc_realmlist[i]->realm_tcp_ports;\n        while (cp && *cp) {\n            if (*cp == ',' || isspace((int) *cp)) {\n                cp++;\n                continue;\n            }\n            port = strtol(cp, &cp, 10);\n            if (cp == 0)\n                break;\n            retval = loop_add_tcp_port(port);\n            if (retval)\n                goto net_init_error;\n        }\n    }\n\n    /*\n     * Setup network listeners.  Disallow network reconfig in response to\n     * routing socket messages if we're using worker processes, since the\n     * children won't be able to re-open the listener sockets.  Hopefully our\n     * platform has pktinfo support and doesn't need reconfigs.\n     */\n    if (workers == 0) {\n        retval = loop_setup_routing_socket(ctx, NULL, kdc_progname);\n        if (retval) {\n            kdc_err(kcontext, retval, _(\"while initializing routing socket\"));\n            finish_realms();\n            return 1;\n        }\n        retval = loop_setup_signals(ctx, NULL, reset_for_hangup);\n        if (retval) {\n            kdc_err(kcontext, retval, _(\"while initializing signal handlers\"));\n            finish_realms();\n            return 1;\n        }\n    }\n    if ((retval = loop_setup_network(ctx, NULL, kdc_progname))) {\n    net_init_error:\n        kdc_err(kcontext, retval, _(\"while initializing network\"));\n        finish_realms();\n        return 1;\n    }\n    if (!nofork && daemon(0, 0)) {\n        kdc_err(kcontext, errno, _(\"while detaching from tty\"));\n        finish_realms();\n        return 1;\n    }\n    if (pid_file != NULL) {\n        retval = write_pid_file(pid_file);\n        if (retval) {\n            kdc_err(kcontext, retval, _(\"while creating PID file\"));\n            finish_realms();\n            return 1;\n        }\n    }\n    if (workers > 0) {\n        finish_realms();\n        retval = create_workers(ctx, workers);\n        if (retval) {\n            kdc_err(kcontext, errno, _(\"creating worker processes\"));\n            return 1;\n        }\n        /* We get here only in a worker child process; re-initialize realms. */\n        initialize_realms(kcontext, argc, argv);\n    }\n    krb5_klog_syslog(LOG_INFO, _(\"commencing operation\"));\n    if (nofork)\n        fprintf(stderr, _(\"%s: starting...\\n\"), kdc_progname);\n\n    verto_run(ctx);\n    loop_free(ctx);\n    krb5_klog_syslog(LOG_INFO, _(\"shutting down\"));\n    unload_preauth_plugins(kcontext);\n    unload_authdata_plugins(kcontext);\n    krb5_klog_close(kdc_context);\n    finish_realms();\n    if (kdc_realmlist)\n        free(kdc_realmlist);\n#ifndef NOCACHE\n    kdc_free_lookaside(kcontext);\n#endif\n    krb5_free_context(kcontext);\n    return errout;\n}\n"], "fixing_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* kdc/main.c - Main procedure body for the KDC server process */\n/*\n * Copyright 1990,2001,2008,2009 by the Massachusetts Institute of Technology.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n/*\n * Copyright (c) 2006-2008, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdio.h>\n#include <syslog.h>\n#include <signal.h>\n#include <errno.h>\n#include <netdb.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <sys/wait.h>\n\n#include \"k5-int.h\"\n#include \"com_err.h\"\n#include \"adm.h\"\n#include \"adm_proto.h\"\n#include \"kdc_util.h\"\n#include \"extern.h\"\n#include \"kdc5_err.h\"\n#include \"kdb_kt.h\"\n#include \"net-server.h\"\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n\n#if defined(NEED_DAEMON_PROTO)\nextern int daemon(int, int);\n#endif\n\nstatic void usage (char *);\n\nstatic krb5_error_code setup_sam (void);\n\nstatic void initialize_realms (krb5_context, int, char **);\n\nstatic void finish_realms (void);\n\nstatic int nofork = 0;\nstatic int workers = 0;\nstatic const char *pid_file = NULL;\nstatic int rkey_init_done = 0;\nstatic volatile int signal_received = 0;\nstatic volatile int sighup_received = 0;\n\n#define KRB5_KDC_MAX_REALMS     32\n\nstatic krb5_context kdc_err_context;\nstatic const char *kdc_progname;\n\n/*\n * We use krb5_klog_init to set up a com_err callback to log error\n * messages.  The callback also pulls the error message out of the\n * context we pass to krb5_klog_init; however, we use realm-specific\n * contexts for most of our krb5 library calls, so the error message\n * isn't present in the global context.  This wrapper ensures that the\n * error message state from the call context is copied into the\n * context known by krb5_klog.  call_context can be NULL if the error\n * code did not come from a krb5 library function.\n */\nvoid\nkdc_err(krb5_context call_context, errcode_t code, const char *fmt, ...)\n{\n    va_list ap;\n\n    if (call_context)\n        krb5_copy_error_message(kdc_err_context, call_context);\n    va_start(ap, fmt);\n    com_err_va(kdc_progname, code, fmt, ap);\n    va_end(ap);\n}\n\n/*\n * Find the realm entry for a given realm.\n */\nkdc_realm_t *\nfind_realm_data(char *rname, krb5_ui_4 rsize)\n{\n    int i;\n    for (i=0; i<kdc_numrealms; i++) {\n        if ((rsize == strlen(kdc_realmlist[i]->realm_name)) &&\n            !strncmp(rname, kdc_realmlist[i]->realm_name, rsize))\n            return(kdc_realmlist[i]);\n    }\n    return((kdc_realm_t *) NULL);\n}\n\nkrb5_error_code\nsetup_server_realm(krb5_principal sprinc)\n{\n    krb5_error_code     kret;\n    kdc_realm_t         *newrealm;\n\n    kret = 0;\n    if (sprinc == NULL)\n        return NULL;\n\n    if (kdc_numrealms > 1) {\n        if (!(newrealm = find_realm_data(sprinc->realm.data,\n                                         (krb5_ui_4) sprinc->realm.length)))\n            kret = ENOENT;\n        else\n            kdc_active_realm = newrealm;\n    }\n    else\n        kdc_active_realm = kdc_realmlist[0];\n    return(kret);\n}\n\nstatic void\nfinish_realm(kdc_realm_t *rdp)\n{\n    if (rdp->realm_name)\n        free(rdp->realm_name);\n    if (rdp->realm_mpname)\n        free(rdp->realm_mpname);\n    if (rdp->realm_stash)\n        free(rdp->realm_stash);\n    if (rdp->realm_ports)\n        free(rdp->realm_ports);\n    if (rdp->realm_tcp_ports)\n        free(rdp->realm_tcp_ports);\n    if (rdp->realm_keytab)\n        krb5_kt_close(rdp->realm_context, rdp->realm_keytab);\n    if (rdp->realm_host_based_services)\n        free(rdp->realm_host_based_services);\n    if (rdp->realm_no_host_referral)\n        free(rdp->realm_no_host_referral);\n    if (rdp->realm_context) {\n        if (rdp->realm_mprinc)\n            krb5_free_principal(rdp->realm_context, rdp->realm_mprinc);\n        if (rdp->realm_mkey.length && rdp->realm_mkey.contents) {\n            /* XXX shouldn't memset be zap for safety? */\n            memset(rdp->realm_mkey.contents, 0, rdp->realm_mkey.length);\n            free(rdp->realm_mkey.contents);\n        }\n        if (rdp->mkey_list)\n            krb5_dbe_free_key_list(rdp->realm_context, rdp->mkey_list);\n        krb5_db_fini(rdp->realm_context);\n        if (rdp->realm_tgsprinc)\n            krb5_free_principal(rdp->realm_context, rdp->realm_tgsprinc);\n        krb5_free_context(rdp->realm_context);\n    }\n    memset(rdp, 0, sizeof(*rdp));\n    free(rdp);\n}\n\nstatic krb5_error_code\nhandle_referral_params(krb5_realm_params *rparams,\n                       char *no_refrls, char *host_based_srvcs,\n                       kdc_realm_t *rdp )\n{\n    krb5_error_code retval = 0;\n    if (no_refrls && krb5_match_config_pattern(no_refrls, KRB5_CONF_ASTERISK) == TRUE) {\n        rdp->realm_no_host_referral = strdup(KRB5_CONF_ASTERISK);\n        if (!rdp->realm_no_host_referral)\n            retval = ENOMEM;\n    } else {\n        if (rparams && rparams->realm_no_host_referral) {\n            if (krb5_match_config_pattern(rparams->realm_no_host_referral,\n                                          KRB5_CONF_ASTERISK) == TRUE) {\n                rdp->realm_no_host_referral = strdup(KRB5_CONF_ASTERISK);\n                if (!rdp->realm_no_host_referral)\n                    retval = ENOMEM;\n            } else if (no_refrls) {\n                if (asprintf(&(rdp->realm_no_host_referral),\n                             \"%s%s%s%s%s\", \" \", no_refrls,\" \",\n                             rparams->realm_no_host_referral, \" \") < 0)\n                    retval = ENOMEM;\n            } else if (asprintf(&(rdp->realm_no_host_referral),\"%s%s%s\", \" \",\n                                rparams->realm_no_host_referral, \" \") < 0)\n                retval = ENOMEM;\n        } else if( no_refrls != NULL) {\n            if ( asprintf(&(rdp->realm_no_host_referral),\n                          \"%s%s%s\", \" \", no_refrls, \" \") < 0)\n                retval = ENOMEM;\n        } else\n            rdp->realm_no_host_referral = NULL;\n    }\n\n    if (rdp->realm_no_host_referral &&\n        krb5_match_config_pattern(rdp->realm_no_host_referral,\n                                  KRB5_CONF_ASTERISK) == TRUE) {\n        rdp->realm_host_based_services = NULL;\n        return 0;\n    }\n\n    if (host_based_srvcs &&\n        (krb5_match_config_pattern(host_based_srvcs, KRB5_CONF_ASTERISK) == TRUE)) {\n        rdp->realm_host_based_services = strdup(KRB5_CONF_ASTERISK);\n        if (!rdp->realm_host_based_services)\n            retval = ENOMEM;\n    } else {\n        if (rparams && rparams->realm_host_based_services) {\n            if (krb5_match_config_pattern(rparams->realm_host_based_services,\n                                          KRB5_CONF_ASTERISK) == TRUE) {\n                rdp->realm_host_based_services = strdup(KRB5_CONF_ASTERISK);\n                if (!rdp->realm_host_based_services)\n                    retval = ENOMEM;\n            } else if (host_based_srvcs) {\n                if (asprintf(&(rdp->realm_host_based_services), \"%s%s%s%s%s\",\n                             \" \", host_based_srvcs,\" \",\n                             rparams->realm_host_based_services, \" \") < 0)\n                    retval = ENOMEM;\n            } else if (asprintf(&(rdp->realm_host_based_services),\"%s%s%s\", \" \",\n                                rparams->realm_host_based_services, \" \") < 0)\n                retval = ENOMEM;\n        } else if (host_based_srvcs) {\n            if (asprintf(&(rdp->realm_host_based_services),\"%s%s%s\", \" \",\n                         host_based_srvcs, \" \") < 0)\n                retval = ENOMEM;\n        } else\n            rdp->realm_host_based_services = NULL;\n    }\n\n    return retval;\n}\n\n/*\n * Initialize a realm control structure from the alternate profile or from\n * the specified defaults.\n *\n * After we're complete here, the essence of the realm is embodied in the\n * realm data and we should be all set to begin operation for that realm.\n */\nstatic krb5_error_code\ninit_realm(kdc_realm_t *rdp, char *realm, char *def_mpname,\n           krb5_enctype def_enctype, char *def_udp_ports, char *def_tcp_ports,\n           krb5_boolean def_manual, krb5_boolean def_restrict_anon,\n           char **db_args, char *no_refrls, char *host_based_srvcs)\n{\n    krb5_error_code     kret;\n    krb5_boolean        manual;\n    krb5_realm_params   *rparams;\n    int                 kdb_open_flags;\n    krb5_kvno       mkvno = IGNORE_VNO;\n\n    memset(rdp, 0, sizeof(kdc_realm_t));\n    if (!realm) {\n        kret = EINVAL;\n        goto whoops;\n    }\n\n    rdp->realm_name = strdup(realm);\n    if (rdp->realm_name == NULL) {\n        kret = ENOMEM;\n        goto whoops;\n    }\n    kret = krb5int_init_context_kdc(&rdp->realm_context);\n    if (kret) {\n        kdc_err(NULL, kret, _(\"while getting context for realm %s\"), realm);\n        goto whoops;\n    }\n\n    kret = krb5_read_realm_params(rdp->realm_context, rdp->realm_name,\n                                  &rparams);\n    if (kret) {\n        kdc_err(rdp->realm_context, kret, _(\"while reading realm parameters\"));\n        goto whoops;\n    }\n\n    /* Handle profile file name */\n    if (rparams && rparams->realm_profile) {\n        rdp->realm_profile = strdup(rparams->realm_profile);\n        if (!rdp->realm_profile) {\n            kret = ENOMEM;\n            goto whoops;\n        }\n    }\n\n    /* Handle master key name */\n    if (rparams && rparams->realm_mkey_name)\n        rdp->realm_mpname = strdup(rparams->realm_mkey_name);\n    else\n        rdp->realm_mpname = (def_mpname) ? strdup(def_mpname) :\n            strdup(KRB5_KDB_M_NAME);\n    if (!rdp->realm_mpname) {\n        kret = ENOMEM;\n        goto whoops;\n    }\n\n    /* Handle KDC ports */\n    if (rparams && rparams->realm_kdc_ports)\n        rdp->realm_ports = strdup(rparams->realm_kdc_ports);\n    else\n        rdp->realm_ports = strdup(def_udp_ports);\n    if (!rdp->realm_ports) {\n        kret = ENOMEM;\n        goto whoops;\n    }\n    if (rparams && rparams->realm_kdc_tcp_ports)\n        rdp->realm_tcp_ports = strdup(rparams->realm_kdc_tcp_ports);\n    else\n        rdp->realm_tcp_ports = strdup(def_tcp_ports);\n    if (!rdp->realm_tcp_ports) {\n        kret = ENOMEM;\n        goto whoops;\n    }\n    /* Handle stash file */\n    if (rparams && rparams->realm_stash_file) {\n        rdp->realm_stash = strdup(rparams->realm_stash_file);\n        if (!rdp->realm_stash) {\n            kret = ENOMEM;\n            goto whoops;\n        }\n        manual = FALSE;\n    } else\n        manual = def_manual;\n\n    if (rparams && rparams->realm_restrict_anon_valid)\n        rdp->realm_restrict_anon = rparams->realm_restrict_anon;\n    else\n        rdp->realm_restrict_anon = def_restrict_anon;\n\n    /* Handle master key type */\n    if (rparams && rparams->realm_enctype_valid)\n        rdp->realm_mkey.enctype = (krb5_enctype) rparams->realm_enctype;\n    else\n        rdp->realm_mkey.enctype = manual ? def_enctype : ENCTYPE_UNKNOWN;\n\n    /* Handle reject-bad-transit flag */\n    if (rparams && rparams->realm_reject_bad_transit_valid)\n        rdp->realm_reject_bad_transit = rparams->realm_reject_bad_transit;\n    else\n        rdp->realm_reject_bad_transit = 1;\n\n    /* Handle ticket maximum life */\n    rdp->realm_maxlife = (rparams && rparams->realm_max_life_valid) ?\n        rparams->realm_max_life : KRB5_KDB_MAX_LIFE;\n\n    /* Handle ticket renewable maximum life */\n    rdp->realm_maxrlife = (rparams && rparams->realm_max_rlife_valid) ?\n        rparams->realm_max_rlife : KRB5_KDB_MAX_RLIFE;\n\n    /* Handle KDC referrals */\n    kret = handle_referral_params(rparams, no_refrls, host_based_srvcs, rdp);\n    if (kret == ENOMEM)\n        goto whoops;\n\n    if (rparams)\n        krb5_free_realm_params(rdp->realm_context, rparams);\n\n    /*\n     * We've got our parameters, now go and setup our realm context.\n     */\n\n    /* Set the default realm of this context */\n    if ((kret = krb5_set_default_realm(rdp->realm_context, realm))) {\n        kdc_err(rdp->realm_context, kret,\n                _(\"while setting default realm to %s\"), realm);\n        goto whoops;\n    }\n\n    /* first open the database  before doing anything */\n    kdb_open_flags = KRB5_KDB_OPEN_RW | KRB5_KDB_SRV_TYPE_KDC;\n    if ((kret = krb5_db_open(rdp->realm_context, db_args, kdb_open_flags))) {\n        kdc_err(rdp->realm_context, kret,\n                _(\"while initializing database for realm %s\"), realm);\n        goto whoops;\n    }\n\n    /* Assemble and parse the master key name */\n    if ((kret = krb5_db_setup_mkey_name(rdp->realm_context, rdp->realm_mpname,\n                                        rdp->realm_name, (char **) NULL,\n                                        &rdp->realm_mprinc))) {\n        kdc_err(rdp->realm_context, kret,\n                _(\"while setting up master key name %s for realm %s\"),\n                rdp->realm_mpname, realm);\n        goto whoops;\n    }\n\n    /*\n     * Get the master key (note, may not be the most current mkey).\n     */\n    if ((kret = krb5_db_fetch_mkey(rdp->realm_context, rdp->realm_mprinc,\n                                   rdp->realm_mkey.enctype, manual,\n                                   FALSE, rdp->realm_stash,\n                                   &mkvno, NULL, &rdp->realm_mkey))) {\n        kdc_err(rdp->realm_context, kret,\n                _(\"while fetching master key %s for realm %s\"),\n                rdp->realm_mpname, realm);\n        goto whoops;\n    }\n\n    if ((kret = krb5_db_fetch_mkey_list(rdp->realm_context, rdp->realm_mprinc,\n                                        &rdp->realm_mkey, mkvno, &rdp->mkey_list))) {\n        kdc_err(rdp->realm_context, kret,\n                _(\"while fetching master keys list for realm %s\"), realm);\n        goto whoops;\n    }\n\n\n    /* Set up the keytab */\n    if ((kret = krb5_ktkdb_resolve(rdp->realm_context, NULL,\n                                   &rdp->realm_keytab))) {\n        kdc_err(rdp->realm_context, kret,\n                _(\"while resolving kdb keytab for realm %s\"), realm);\n        goto whoops;\n    }\n\n    /* Preformat the TGS name */\n    if ((kret = krb5_build_principal(rdp->realm_context, &rdp->realm_tgsprinc,\n                                     strlen(realm), realm, KRB5_TGS_NAME,\n                                     realm, (char *) NULL))) {\n        kdc_err(rdp->realm_context, kret,\n                _(\"while building TGS name for realm %s\"), realm);\n        goto whoops;\n    }\n\n    if (!rkey_init_done) {\n        krb5_data seed;\n        /*\n         * If all that worked, then initialize the random key\n         * generators.\n         */\n\n        seed.length = rdp->realm_mkey.length;\n        seed.data = (char *)rdp->realm_mkey.contents;\n\n        if ((kret = krb5_c_random_add_entropy(rdp->realm_context,\n                                              KRB5_C_RANDSOURCE_TRUSTEDPARTY, &seed)))\n            goto whoops;\n\n        rkey_init_done = 1;\n    }\nwhoops:\n    /*\n     * If we choked, then clean up any dirt we may have dropped on the floor.\n     */\n    if (kret) {\n\n        finish_realm(rdp);\n    }\n    return(kret);\n}\n\nstatic krb5_sigtype\non_monitor_signal(int signo)\n{\n    signal_received = signo;\n\n#ifdef POSIX_SIGTYPE\n    return;\n#else\n    return(0);\n#endif\n}\n\nstatic krb5_sigtype\non_monitor_sighup(int signo)\n{\n    sighup_received = 1;\n\n#ifdef POSIX_SIGTYPE\n    return;\n#else\n    return(0);\n#endif\n}\n\n/*\n * Kill the worker subprocesses given by pids[0..bound-1], skipping any which\n * are set to -1, and wait for them to exit (so that we know the ports are no\n * longer in use).\n */\nstatic void\nterminate_workers(pid_t *pids, int bound)\n{\n    int i, status, num_active = 0;\n    pid_t pid;\n\n    /* Kill the active worker pids. */\n    for (i = 0; i < bound; i++) {\n        if (pids[i] == -1)\n            continue;\n        kill(pids[i], SIGTERM);\n        num_active++;\n    }\n\n    /* Wait for them to exit. */\n    while (num_active > 0) {\n        pid = wait(&status);\n        if (pid >= 0)\n            num_active--;\n    }\n}\n\n/*\n * Create num worker processes and return successfully in each child.  The\n * parent process will act as a supervisor and will only return from this\n * function in error cases.\n */\nstatic krb5_error_code\ncreate_workers(verto_ctx *ctx, int num)\n{\n    krb5_error_code retval;\n    int i, status;\n    pid_t pid, *pids;\n#ifdef POSIX_SIGNALS\n    struct sigaction s_action;\n#endif /* POSIX_SIGNALS */\n\n    /*\n     * Setup our signal handlers which will forward to the children.\n     * These handlers will be overriden in the child processes.\n     */\n#ifdef POSIX_SIGNALS\n    (void) sigemptyset(&s_action.sa_mask);\n    s_action.sa_flags = 0;\n    s_action.sa_handler = on_monitor_signal;\n    (void) sigaction(SIGINT, &s_action, (struct sigaction *) NULL);\n    (void) sigaction(SIGTERM, &s_action, (struct sigaction *) NULL);\n    (void) sigaction(SIGQUIT, &s_action, (struct sigaction *) NULL);\n    s_action.sa_handler = on_monitor_sighup;\n    (void) sigaction(SIGHUP, &s_action, (struct sigaction *) NULL);\n#else  /* POSIX_SIGNALS */\n    signal(SIGINT, on_monitor_signal);\n    signal(SIGTERM, on_monitor_signal);\n    signal(SIGQUIT, on_monitor_signal);\n    signal(SIGHUP, on_monitor_sighup);\n#endif /* POSIX_SIGNALS */\n\n    /* Create child worker processes; return in each child. */\n    krb5_klog_syslog(LOG_INFO, _(\"creating %d worker processes\"), num);\n    pids = calloc(num, sizeof(pid_t));\n    if (pids == NULL)\n        return ENOMEM;\n    for (i = 0; i < num; i++) {\n        pid = fork();\n        if (pid == 0) {\n            if (!verto_reinitialize(ctx)) {\n                krb5_klog_syslog(LOG_ERR,\n                                 _(\"Unable to reinitialize main loop\"));\n                return ENOMEM;\n            }\n            retval = loop_setup_signals(ctx, NULL, reset_for_hangup);\n            if (retval) {\n                krb5_klog_syslog(LOG_ERR, _(\"Unable to initialize signal \"\n                                            \"handlers in pid %d\"), pid);\n                return retval;\n            }\n\n            /* Avoid race condition */\n            if (signal_received)\n                exit(0);\n\n            /* Return control to main() in the new worker process. */\n            free(pids);\n            return 0;\n        }\n        if (pid == -1) {\n            /* Couldn't fork enough times. */\n            status = errno;\n            terminate_workers(pids, i);\n            free(pids);\n            return status;\n        }\n        pids[i] = pid;\n    }\n\n    /* We're going to use our own main loop here. */\n    loop_free(ctx);\n\n    /* Supervise the worker processes. */\n    while (!signal_received) {\n        /* Wait until a worker process exits or we get a signal. */\n        pid = wait(&status);\n        if (pid >= 0) {\n            krb5_klog_syslog(LOG_ERR, _(\"worker %ld exited with status %d\"),\n                             (long) pid, status);\n\n            /* Remove the pid from the table. */\n            for (i = 0; i < num; i++) {\n                if (pids[i] == pid)\n                    pids[i] = -1;\n            }\n\n            /* When one worker process exits, terminate them all, so that KDC\n             * crashes behave similarly with or without worker processes. */\n            break;\n        }\n\n        /* Propagate HUP signal to worker processes if we received one. */\n        if (sighup_received) {\n            sighup_received = 0;\n            for (i = 0; i < num; i++) {\n                if (pids[i] != -1)\n                    kill(pids[i], SIGHUP);\n            }\n        }\n    }\n    if (signal_received)\n        krb5_klog_syslog(LOG_INFO, _(\"signal %d received in supervisor\"),\n                         signal_received);\n\n    terminate_workers(pids, num);\n    free(pids);\n    exit(0);\n}\n\nstatic krb5_error_code\nsetup_sam(void)\n{\n    return krb5_c_make_random_key(kdc_context, ENCTYPE_DES_CBC_MD5, &psr_key);\n}\n\nstatic void\nusage(char *name)\n{\n    fprintf(stderr,\n            _(\"usage: %s [-x db_args]* [-d dbpathname] [-r dbrealmname]\\n\"\n              \"\\t\\t[-R replaycachename] [-m] [-k masterenctype]\\n\"\n              \"\\t\\t[-M masterkeyname] [-p port] [-P pid_file]\\n\"\n              \"\\t\\t[-n] [-w numworkers] [/]\\n\\n\"\n              \"where,\\n\"\n              \"\\t[-x db_args]* - Any number of database specific arguments.\\n\"\n              \"\\t\\t\\tLook at each database module documentation for \"\n              \"\\t\\t\\tsupported arguments\\n\"),\n            name);\n    exit(1);\n}\n\n\nstatic void\ninitialize_realms(krb5_context kcontext, int argc, char **argv)\n{\n    int                 c;\n    char                *db_name = (char *) NULL;\n    char                *lrealm = (char *) NULL;\n    char                *mkey_name = (char *) NULL;\n    krb5_error_code     retval;\n    krb5_enctype        menctype = ENCTYPE_UNKNOWN;\n    kdc_realm_t         *rdatap = NULL;\n    krb5_boolean        manual = FALSE;\n    krb5_boolean        def_restrict_anon;\n    char                *default_udp_ports = 0;\n    char                *default_tcp_ports = 0;\n    krb5_pointer        aprof;\n    const char          *hierarchy[3];\n    char                *no_refrls = NULL;\n    char                *host_based_srvcs = NULL;\n    int                  db_args_size = 0;\n    char                **db_args = NULL;\n\n    extern char *optarg;\n\n    if (!krb5_aprof_init(DEFAULT_KDC_PROFILE, KDC_PROFILE_ENV, &aprof)) {\n        hierarchy[0] = KRB5_CONF_KDCDEFAULTS;\n        hierarchy[1] = KRB5_CONF_KDC_PORTS;\n        hierarchy[2] = (char *) NULL;\n        if (krb5_aprof_get_string(aprof, hierarchy, TRUE, &default_udp_ports))\n            default_udp_ports = 0;\n        hierarchy[1] = KRB5_CONF_KDC_TCP_PORTS;\n        if (krb5_aprof_get_string(aprof, hierarchy, TRUE, &default_tcp_ports))\n            default_tcp_ports = 0;\n        hierarchy[1] = KRB5_CONF_MAX_DGRAM_REPLY_SIZE;\n        if (krb5_aprof_get_int32(aprof, hierarchy, TRUE, &max_dgram_reply_size))\n            max_dgram_reply_size = MAX_DGRAM_SIZE;\n        hierarchy[1] = KRB5_CONF_RESTRICT_ANONYMOUS_TO_TGT;\n        if (krb5_aprof_get_boolean(aprof, hierarchy, TRUE, &def_restrict_anon))\n            def_restrict_anon = FALSE;\n        hierarchy[1] = KRB5_CONF_NO_HOST_REFERRAL;\n        if (krb5_aprof_get_string_all(aprof, hierarchy, &no_refrls))\n            no_refrls = 0;\n        if (!no_refrls ||\n            krb5_match_config_pattern(no_refrls, KRB5_CONF_ASTERISK) == FALSE) {\n            hierarchy[1] = KRB5_CONF_HOST_BASED_SERVICES;\n            if (krb5_aprof_get_string_all(aprof, hierarchy, &host_based_srvcs))\n                host_based_srvcs = 0;\n        }\n\n        krb5_aprof_finish(aprof);\n    }\n\n    if (default_udp_ports == 0) {\n        default_udp_ports = strdup(DEFAULT_KDC_UDP_PORTLIST);\n        if (default_udp_ports == 0) {\n            fprintf(stderr, _(\" KDC cannot initialize. Not enough memory\\n\"));\n            exit(1);\n        }\n    }\n    if (default_tcp_ports == 0) {\n        default_tcp_ports = strdup(DEFAULT_KDC_TCP_PORTLIST);\n        if (default_tcp_ports == 0) {\n            fprintf(stderr, _(\" KDC cannot initialize. Not enough memory\\n\"));\n            exit(1);\n        }\n    }\n\n    /*\n     * Loop through the option list.  Each time we encounter a realm name,\n     * use the previously scanned options to fill in for defaults.\n     */\n    while ((c = getopt(argc, argv, \"x:r:d:mM:k:R:e:P:p:s:nw:4:X3\")) != -1) {\n        switch(c) {\n        case 'x':\n            db_args_size++;\n            {\n                char **temp = realloc( db_args, sizeof(char*) * (db_args_size+1)); /* one for NULL */\n                if( temp == NULL )\n                {\n                    fprintf(stderr, _(\"%s: KDC cannot initialize. Not enough \"\n                                      \"memory\\n\"), argv[0]);\n                    exit(1);\n                }\n\n                db_args = temp;\n            }\n            db_args[db_args_size-1] = optarg;\n            db_args[db_args_size]   = NULL;\n            break;\n\n        case 'r':                       /* realm name for db */\n            if (!find_realm_data(optarg, (krb5_ui_4) strlen(optarg))) {\n                if ((rdatap = (kdc_realm_t *) malloc(sizeof(kdc_realm_t)))) {\n                    if ((retval = init_realm(rdatap, optarg, mkey_name,\n                                             menctype, default_udp_ports,\n                                             default_tcp_ports, manual,\n                                             def_restrict_anon, db_args,\n                                             no_refrls, host_based_srvcs))) {\n                        fprintf(stderr, _(\"%s: cannot initialize realm %s - \"\n                                          \"see log file for details\\n\"),\n                                argv[0], optarg);\n                        exit(1);\n                    }\n                    kdc_realmlist[kdc_numrealms] = rdatap;\n                    kdc_numrealms++;\n                    free(db_args), db_args=NULL, db_args_size = 0;\n                }\n                else\n                {\n                    fprintf(stderr, _(\"%s: cannot initialize realm %s. Not \"\n                                      \"enough memory\\n\"), argv[0], optarg);\n                    exit(1);\n                }\n            }\n            break;\n        case 'd':                       /* pathname for db */\n            /* now db_name is not a seperate argument.\n             * It has to be passed as part of the db_args\n             */\n            if( db_name == NULL ) {\n                if (asprintf(&db_name, \"dbname=%s\", optarg) < 0) {\n                    fprintf(stderr, _(\"%s: KDC cannot initialize. Not enough \"\n                                      \"memory\\n\"), argv[0]);\n                    exit(1);\n                }\n            }\n\n            db_args_size++;\n            {\n                char **temp = realloc( db_args, sizeof(char*) * (db_args_size+1)); /* one for NULL */\n                if( temp == NULL )\n                {\n                    fprintf(stderr, _(\"%s: KDC cannot initialize. Not enough \"\n                                      \"memory\\n\"), argv[0]);\n                    exit(1);\n                }\n\n                db_args = temp;\n            }\n            db_args[db_args_size-1] = db_name;\n            db_args[db_args_size]   = NULL;\n            break;\n        case 'm':                       /* manual type-in of master key */\n            manual = TRUE;\n            if (menctype == ENCTYPE_UNKNOWN)\n                menctype = ENCTYPE_DES_CBC_CRC;\n            break;\n        case 'M':                       /* master key name in DB */\n            mkey_name = optarg;\n            break;\n        case 'n':\n            nofork++;                   /* don't detach from terminal */\n            break;\n        case 'w':                       /* create multiple worker processes */\n            workers = atoi(optarg);\n            if (workers <= 0)\n                usage(argv[0]);\n            break;\n        case 'k':                       /* enctype for master key */\n            if (krb5_string_to_enctype(optarg, &menctype))\n                com_err(argv[0], 0, _(\"invalid enctype %s\"), optarg);\n            break;\n        case 'R':\n            /* Replay cache name; defunct since we don't use a replay cache. */\n            break;\n        case 'P':\n            pid_file = optarg;\n            break;\n        case 'p':\n            if (default_udp_ports)\n                free(default_udp_ports);\n            default_udp_ports = strdup(optarg);\n            if (!default_udp_ports) {\n                fprintf(stderr, _(\" KDC cannot initialize. Not enough \"\n                                  \"memory\\n\"));\n                exit(1);\n            }\n#if 0 /* not yet */\n            if (default_tcp_ports)\n                free(default_tcp_ports);\n            default_tcp_ports = strdup(optarg);\n#endif\n            break;\n        case '4':\n            break;\n        case 'X':\n            break;\n        case '?':\n        default:\n            usage(argv[0]);\n        }\n    }\n\n    /*\n     * Check to see if we processed any realms.\n     */\n    if (kdc_numrealms == 0) {\n        /* no realm specified, use default realm */\n        if ((retval = krb5_get_default_realm(kcontext, &lrealm))) {\n            com_err(argv[0], retval,\n                    _(\"while attempting to retrieve default realm\"));\n            fprintf (stderr,\n                     _(\"%s: %s, attempting to retrieve default realm\\n\"),\n                     argv[0], krb5_get_error_message(kcontext, retval));\n            exit(1);\n        }\n        if ((rdatap = (kdc_realm_t *) malloc(sizeof(kdc_realm_t)))) {\n            if ((retval = init_realm(rdatap, lrealm, mkey_name, menctype,\n                                     default_udp_ports, default_tcp_ports,\n                                     manual, def_restrict_anon, db_args,\n                                     no_refrls, host_based_srvcs))) {\n                fprintf(stderr, _(\"%s: cannot initialize realm %s - see log \"\n                                  \"file for details\\n\"), argv[0], lrealm);\n                exit(1);\n            }\n            kdc_realmlist[0] = rdatap;\n            kdc_numrealms++;\n        }\n        krb5_free_default_realm(kcontext, lrealm);\n    }\n\n    /* Ensure that this is set for our first request. */\n    kdc_active_realm = kdc_realmlist[0];\n    if (default_udp_ports)\n        free(default_udp_ports);\n    if (default_tcp_ports)\n        free(default_tcp_ports);\n    if (db_args)\n        free(db_args);\n    if (db_name)\n        free(db_name);\n    if (host_based_srvcs)\n        free(host_based_srvcs);\n    if (no_refrls)\n        free(no_refrls);\n\n    return;\n}\n\nstatic krb5_error_code\nwrite_pid_file(const char *path)\n{\n    FILE *file;\n    unsigned long pid;\n\n    file = fopen(path, \"w\");\n    if (file == NULL)\n        return errno;\n    pid = (unsigned long) getpid();\n    if (fprintf(file, \"%ld\\n\", pid) < 0 || fclose(file) == EOF)\n        return errno;\n    return 0;\n}\n\nstatic void\nfinish_realms()\n{\n    int i;\n\n    for (i = 0; i < kdc_numrealms; i++) {\n        finish_realm(kdc_realmlist[i]);\n        kdc_realmlist[i] = 0;\n    }\n    kdc_numrealms = 0;\n}\n\n/*\n  outline:\n\n  process args & setup\n\n  initialize database access (fetch master key, open DB)\n\n  initialize network\n\n  loop:\n  listen for packet\n\n  determine packet type, dispatch to handling routine\n  (AS or TGS (or V4?))\n\n  reflect response\n\n  exit on signal\n\n  clean up secrets, close db\n\n  shut down network\n\n  exit\n*/\n\nint main(int argc, char **argv)\n{\n    krb5_error_code     retval;\n    krb5_context        kcontext;\n    verto_ctx *ctx;\n    int errout = 0;\n    int i;\n\n    setlocale(LC_MESSAGES, \"\");\n    if (strrchr(argv[0], '/'))\n        argv[0] = strrchr(argv[0], '/')+1;\n\n    if (!(kdc_realmlist = (kdc_realm_t **) malloc(sizeof(kdc_realm_t *) *\n                                                  KRB5_KDC_MAX_REALMS))) {\n        fprintf(stderr, _(\"%s: cannot get memory for realm list\\n\"), argv[0]);\n        exit(1);\n    }\n    memset(kdc_realmlist, 0,\n           (size_t) (sizeof(kdc_realm_t *) * KRB5_KDC_MAX_REALMS));\n\n    /*\n     * A note about Kerberos contexts: This context, \"kcontext\", is used\n     * for the KDC operations, i.e. setup, network connection and error\n     * reporting.  The per-realm operations use the \"realm_context\"\n     * associated with each realm.\n     */\n    retval = krb5int_init_context_kdc(&kcontext);\n    if (retval) {\n        com_err(argv[0], retval, _(\"while initializing krb5\"));\n        exit(1);\n    }\n    krb5_klog_init(kcontext, \"kdc\", argv[0], 1);\n    kdc_err_context = kcontext;\n    kdc_progname = argv[0];\n    /* N.B.: After this point, com_err sends output to the KDC log\n       file, and not to stderr.  We use the kdc_err wrapper around\n       com_err to ensure that the error state exists in the context\n       known to the krb5_klog callback. */\n\n    initialize_kdc5_error_table();\n\n    /*\n     * Scan through the argument list\n     */\n    initialize_realms(kcontext, argc, argv);\n\n    ctx = loop_init(VERTO_EV_TYPE_NONE);\n    if (!ctx) {\n        kdc_err(kcontext, ENOMEM, _(\"while creating main loop\"));\n        finish_realms();\n        return 1;\n    }\n\n    load_preauth_plugins(kcontext);\n    load_authdata_plugins(kcontext);\n\n    retval = setup_sam();\n    if (retval) {\n        kdc_err(kcontext, retval, _(\"while initializing SAM\"));\n        finish_realms();\n        return 1;\n    }\n\n    /* Handle each realm's ports */\n    for (i=0; i<kdc_numrealms; i++) {\n        char *cp = kdc_realmlist[i]->realm_ports;\n        int port;\n        while (cp && *cp) {\n            if (*cp == ',' || isspace((int) *cp)) {\n                cp++;\n                continue;\n            }\n            port = strtol(cp, &cp, 10);\n            if (cp == 0)\n                break;\n            retval = loop_add_udp_port(port);\n            if (retval)\n                goto net_init_error;\n        }\n\n        cp = kdc_realmlist[i]->realm_tcp_ports;\n        while (cp && *cp) {\n            if (*cp == ',' || isspace((int) *cp)) {\n                cp++;\n                continue;\n            }\n            port = strtol(cp, &cp, 10);\n            if (cp == 0)\n                break;\n            retval = loop_add_tcp_port(port);\n            if (retval)\n                goto net_init_error;\n        }\n    }\n\n    /*\n     * Setup network listeners.  Disallow network reconfig in response to\n     * routing socket messages if we're using worker processes, since the\n     * children won't be able to re-open the listener sockets.  Hopefully our\n     * platform has pktinfo support and doesn't need reconfigs.\n     */\n    if (workers == 0) {\n        retval = loop_setup_routing_socket(ctx, NULL, kdc_progname);\n        if (retval) {\n            kdc_err(kcontext, retval, _(\"while initializing routing socket\"));\n            finish_realms();\n            return 1;\n        }\n        retval = loop_setup_signals(ctx, NULL, reset_for_hangup);\n        if (retval) {\n            kdc_err(kcontext, retval, _(\"while initializing signal handlers\"));\n            finish_realms();\n            return 1;\n        }\n    }\n    if ((retval = loop_setup_network(ctx, NULL, kdc_progname))) {\n    net_init_error:\n        kdc_err(kcontext, retval, _(\"while initializing network\"));\n        finish_realms();\n        return 1;\n    }\n    if (!nofork && daemon(0, 0)) {\n        kdc_err(kcontext, errno, _(\"while detaching from tty\"));\n        finish_realms();\n        return 1;\n    }\n    if (pid_file != NULL) {\n        retval = write_pid_file(pid_file);\n        if (retval) {\n            kdc_err(kcontext, retval, _(\"while creating PID file\"));\n            finish_realms();\n            return 1;\n        }\n    }\n    if (workers > 0) {\n        finish_realms();\n        retval = create_workers(ctx, workers);\n        if (retval) {\n            kdc_err(kcontext, errno, _(\"creating worker processes\"));\n            return 1;\n        }\n        /* We get here only in a worker child process; re-initialize realms. */\n        initialize_realms(kcontext, argc, argv);\n    }\n    krb5_klog_syslog(LOG_INFO, _(\"commencing operation\"));\n    if (nofork)\n        fprintf(stderr, _(\"%s: starting...\\n\"), kdc_progname);\n\n    verto_run(ctx);\n    loop_free(ctx);\n    krb5_klog_syslog(LOG_INFO, _(\"shutting down\"));\n    unload_preauth_plugins(kcontext);\n    unload_authdata_plugins(kcontext);\n    krb5_klog_close(kdc_context);\n    finish_realms();\n    if (kdc_realmlist)\n        free(kdc_realmlist);\n#ifndef NOCACHE\n    kdc_free_lookaside(kcontext);\n#endif\n    krb5_free_context(kcontext);\n    return errout;\n}\n"], "filenames": ["src/kdc/main.c"], "buggy_code_start_loc": [142], "buggy_code_end_loc": [142], "fixing_code_start_loc": [143], "fixing_code_end_loc": [146], "type": "CWE-476", "message": "The setup_server_realm function in main.c in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.10.7, when multiple realms are configured, allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via a crafted request.", "other": {"cve": {"id": "CVE-2013-1418", "sourceIdentifier": "cve@mitre.org", "published": "2013-11-18T03:55:05.397", "lastModified": "2021-02-02T19:04:27.273", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The setup_server_realm function in main.c in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.10.7, when multiple realms are configured, allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via a crafted request."}, {"lang": "es", "value": "La funci\u00f3n setup_server_realm en main.c en Key Distribution Center (KDC) de MIT Kerberos 5 (tambi\u00e9n conocido como krb5) anterior a la versi\u00f3n 1.10.7, cuando se configuran varios campos, permite a atacantes remotos provocar una denegaci\u00f3n de servicio (referencia a un puntero NULL y cierre del demonio) a trav\u00e9s de una petici\u00f3n manipulada."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.7", "matchCriteriaId": "704EA682-C360-4B22-84F8-FF1EF0C97C3D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:11.4:*:*:*:*:*:*:*", "matchCriteriaId": "DE554781-1EB9-446E-911F-6C11970C47F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:12.2:*:*:*:*:*:*:*", "matchCriteriaId": "D806A17E-B8F9-466D-807D-3F1E77603DC8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:12.3:*:*:*:*:*:*:*", "matchCriteriaId": "DFBF430B-0832-44B0-AA0E-BA9E467F7668"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.1:*:*:*:*:*:*:*", "matchCriteriaId": "A10BC294-9196-425F-9FB0-B1625465B47F"}]}]}], "references": [{"url": "http://advisories.mageia.org/MGASA-2013-0335.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://krbdev.mit.edu/rt/Ticket/Display.html?id=7757", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2013-11/msg00082.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2013-11/msg00086.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2013-12/msg00026.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://web.mit.edu/kerberos/krb5-1.10/README-1.10.7.txt", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://web.mit.edu/kerberos/krb5-1.11/README-1.11.4.txt", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/63555", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1026942", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/krb5/krb5/commit/c2ccf4197f697c4ff143b8a786acdd875e70a89d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/01/msg00040.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/krb5/krb5/commit/c2ccf4197f697c4ff143b8a786acdd875e70a89d"}}