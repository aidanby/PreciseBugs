{"buggy_code": ["use crate::errors::{OssError, OssResult};\nuse crate::types::{CanonicalizedResource, ContentMd5, ContentType, Date, KeyId, KeySecret};\n#[cfg(test)]\nuse http::header::AsHeaderName;\n#[cfg(test)]\nuse mockall::automock;\nuse reqwest::header::{HeaderMap, HeaderName, HeaderValue, IntoHeaderName};\nuse reqwest::Method;\nuse std::borrow::Cow;\nuse std::convert::TryInto;\n\n#[derive(Clone, PartialEq, Eq)]\n#[cfg_attr(test, derive(Debug))]\n#[non_exhaustive]\npub struct VERB(pub Method);\n\n#[derive(Default, Clone)]\npub struct Auth {\n    access_key_id: KeyId,\n    access_key_secret: KeySecret,\n    verb: VERB,\n    content_md5: Option<ContentMd5>,\n    date: Date,\n    // pub canonicalized_oss_headers: &'a str, // TODO\n    canonicalized_resource: CanonicalizedResource,\n    headers: HeaderMap,\n}\n\nimpl Auth {\n    fn set_key(&mut self, access_key_id: KeyId) {\n        self.access_key_id = access_key_id;\n    }\n\n    #[cfg(test)]\n    pub(crate) fn get_key(self) -> KeyId {\n        self.access_key_id\n    }\n\n    fn set_secret(&mut self, secret: KeySecret) {\n        self.access_key_secret = secret;\n    }\n    fn set_verb(&mut self, verb: VERB) {\n        self.verb = verb;\n    }\n    fn set_content_md5(&mut self, content_md5: ContentMd5) {\n        self.content_md5 = Some(content_md5)\n    }\n    fn set_date(&mut self, date: Date) {\n        self.date = date;\n    }\n    fn set_canonicalized_resource(&mut self, canonicalized_resource: CanonicalizedResource) {\n        self.canonicalized_resource = canonicalized_resource;\n    }\n    fn set_headers(&mut self, headers: HeaderMap) {\n        self.headers = headers;\n    }\n    fn extend_headers(&mut self, headers: HeaderMap) {\n        self.headers.extend(headers);\n    }\n    fn header_insert<K: IntoHeaderName + 'static>(&mut self, key: K, val: HeaderValue) {\n        self.headers.insert(key, val);\n    }\n    fn headers_clear(&mut self) {\n        self.headers.clear();\n    }\n\n    #[cfg(test)]\n    pub(crate) fn get_header<K>(self, key: K) -> Option<HeaderValue>\n    where\n        K: AsHeaderName,\n    {\n        self.headers.get(key).cloned()\n    }\n\n    #[cfg(test)]\n    pub(crate) fn header_len(&self) -> usize {\n        self.headers.len()\n    }\n\n    #[cfg(test)]\n    pub(crate) fn header_contains_key<K>(&self, key: K) -> bool\n    where\n        K: AsHeaderName,\n    {\n        self.headers.contains_key(key)\n    }\n}\n\nimpl VERB {\n    /// GET\n    pub const GET: VERB = VERB(Method::GET);\n\n    /// POST\n    pub const POST: VERB = VERB(Method::POST);\n\n    /// PUT\n    pub const PUT: VERB = VERB(Method::PUT);\n\n    /// DELETE\n    pub const DELETE: VERB = VERB(Method::DELETE);\n\n    /// HEAD\n    pub const HEAD: VERB = VERB(Method::HEAD);\n\n    /// OPTIONS\n    pub const OPTIONS: VERB = VERB(Method::OPTIONS);\n\n    /// CONNECT\n    pub const CONNECT: VERB = VERB(Method::CONNECT);\n\n    /// PATCH\n    pub const PATCH: VERB = VERB(Method::PATCH);\n\n    /// TRACE\n    pub const TRACE: VERB = VERB(Method::TRACE);\n\n    #[inline]\n    pub fn to_string(&self) -> String {\n        self.0.to_string()\n    }\n}\n\nimpl TryInto<HeaderValue> for VERB {\n    type Error = OssError;\n    fn try_into(self) -> OssResult<HeaderValue> {\n        self.0\n            .to_string()\n            .parse::<HeaderValue>()\n            .map_err(OssError::from)\n    }\n}\n\nimpl From<VERB> for String {\n    fn from(verb: VERB) -> Self {\n        match verb.0 {\n            Method::GET => \"GET\".into(),\n            Method::POST => \"POST\".into(),\n            Method::PUT => \"PUT\".into(),\n            Method::DELETE => \"DELETE\".into(),\n            Method::HEAD => \"HEAD\".into(),\n            Method::OPTIONS => \"OPTIONS\".into(),\n            Method::CONNECT => \"CONNECT\".into(),\n            Method::PATCH => \"PATCH\".into(),\n            Method::TRACE => \"TRACE\".into(),\n            _ => \"\".into(),\n        }\n    }\n}\n\nimpl From<&str> for VERB {\n    fn from(str: &str) -> Self {\n        match str {\n            \"POST\" => VERB(Method::POST),\n            \"GET\" => VERB(Method::GET),\n            \"PUT\" => VERB(Method::PUT),\n            \"DELETE\" => VERB(Method::DELETE),\n            \"HEAD\" => VERB(Method::HEAD),\n            \"OPTIONS\" => VERB(Method::OPTIONS),\n            \"CONNECT\" => VERB(Method::CONNECT),\n            \"PATCH\" => VERB(Method::PATCH),\n            \"TRACE\" => VERB(Method::TRACE),\n            _ => VERB(Method::GET),\n        }\n    }\n}\n\nimpl Into<Method> for VERB {\n    fn into(self) -> Method {\n        self.0\n    }\n}\n\nimpl Default for VERB {\n    fn default() -> Self {\n        Self::GET\n    }\n}\n\n#[cfg_attr(test, automock)]\npub trait AuthToHeaderMap {\n    fn get_original_header(&self) -> HeaderMap;\n    fn get_header_key(&self) -> OssResult<HeaderValue>;\n    fn get_header_secret(&self) -> OssResult<HeaderValue>;\n    fn get_header_verb(&self) -> OssResult<HeaderValue>;\n    fn get_header_md5(&self) -> OssResult<Option<HeaderValue>>;\n    fn get_header_date(&self) -> OssResult<HeaderValue>;\n    fn get_header_resource(&self) -> OssResult<HeaderValue>;\n}\n\nimpl AuthToHeaderMap for Auth {\n    fn get_original_header(&self) -> HeaderMap {\n        self.headers.clone()\n    }\n    fn get_header_key(&self) -> OssResult<HeaderValue> {\n        let val: HeaderValue = self.access_key_id.as_ref().try_into()?;\n        Ok(val)\n    }\n    fn get_header_secret(&self) -> OssResult<HeaderValue> {\n        let val: HeaderValue = self.access_key_secret.as_ref().try_into()?;\n        Ok(val)\n    }\n    fn get_header_verb(&self) -> OssResult<HeaderValue> {\n        let val: HeaderValue = self.verb.clone().try_into()?;\n        Ok(val)\n    }\n    fn get_header_md5(&self) -> OssResult<Option<HeaderValue>> {\n        let res = match self.content_md5.clone() {\n            Some(val) => {\n                let val: HeaderValue = val.try_into()?;\n                Some(val)\n            }\n            None => None,\n        };\n        Ok(res)\n    }\n    fn get_header_date(&self) -> OssResult<HeaderValue> {\n        let val: HeaderValue = self.date.as_ref().try_into()?;\n        Ok(val)\n    }\n    fn get_header_resource(&self) -> OssResult<HeaderValue> {\n        let val: HeaderValue = self.canonicalized_resource.as_ref().try_into()?;\n        Ok(val)\n    }\n}\n\npub trait AuthToOssHeader {\n    fn to_oss_header(&self) -> OssResult<OssHeader>;\n}\n\nimpl AuthToOssHeader for Auth {\n    /// \u8f6c\u5316\u6210 OssHeader\n    fn to_oss_header(&self) -> OssResult<OssHeader> {\n        //return Some(\"x-oss-copy-source:/honglei123/file1.txt\");\n        let mut header: Vec<(&HeaderName, &HeaderValue)> = self\n            .headers\n            .iter()\n            .filter(|(k, _v)| k.as_str().starts_with(\"x-oss-\"))\n            .collect();\n        if header.len() == 0 {\n            return Ok(OssHeader(None));\n        }\n\n        header.sort_by(|(k1, _), (k2, _)| k1.to_string().cmp(&k2.to_string()));\n\n        let header_vec: Vec<String> = header\n            .into_iter()\n            .filter_map(|(k, v)| match v.to_str() {\n                Ok(val) => Some(k.as_str().to_owned() + \":\" + val),\n                _ => None,\n            })\n            .collect();\n\n        Ok(OssHeader(Some(header_vec.join(\"\\n\"))))\n    }\n}\n\n/// \u4ece auth \u4e2d\u63d0\u53d6\u5404\u4e2a\u5b57\u6bb5\uff0c\u7528\u4e8e\u8ba1\u7b97\u7b7e\u540d\u7684\u539f\u59cb\u5b57\u7b26\u4e32\npub trait AuthSignString {\n    fn key(&self) -> Cow<'_, KeyId>;\n    fn secret(&self) -> Cow<'_, KeySecret>;\n    fn verb(&self) -> String;\n    fn content_md5(&self) -> Cow<'_, ContentMd5>;\n    fn content_type(&self) -> Cow<'_, ContentType>;\n    fn date(&self) -> Cow<'_, Date>;\n    fn canonicalized_resource(&self) -> Cow<'_, CanonicalizedResource>;\n}\n\nimpl AuthSignString for Auth {\n    fn key(&self) -> Cow<'_, KeyId> {\n        Cow::Borrowed(&self.access_key_id)\n    }\n    fn secret(&self) -> Cow<'_, KeySecret> {\n        Cow::Borrowed(&self.access_key_secret)\n    }\n    fn verb(&self) -> String {\n        self.verb.to_string()\n    }\n    fn content_md5(&self) -> Cow<'_, ContentMd5> {\n        match self.content_md5.clone() {\n            Some(md5) => Cow::Owned(md5),\n            None => Cow::Owned(ContentMd5::new(\"\")),\n        }\n    }\n    fn content_type(&self) -> Cow<'_, ContentType> {\n        match self.headers.get(\"Content-Type\") {\n            Some(ct) => Cow::Owned(ct.to_owned().try_into().unwrap()),\n            None => Cow::Owned(ContentType::new(\"\")),\n        }\n    }\n    fn date(&self) -> Cow<'_, Date> {\n        Cow::Borrowed(&self.date)\n    }\n    fn canonicalized_resource(&self) -> Cow<'_, CanonicalizedResource> {\n        Cow::Borrowed(&self.canonicalized_resource)\n    }\n}\n\npub trait AuthGetHeader {\n    fn get_headers(&self) -> OssResult<HeaderMap>;\n}\n\nimpl AuthGetHeader for Auth {\n    fn get_headers(&self) -> OssResult<HeaderMap> {\n        let mut map = HeaderMap::from_auth(self)?;\n\n        let oss_header = self.to_oss_header()?;\n        let sign_string = SignString::from_auth(self, oss_header)?;\n        let sign = sign_string.to_sign()?;\n        map.append_sign(sign)?;\n\n        Ok(map)\n    }\n}\n\npub trait AuthHeader {\n    fn from_auth(auth: &impl AuthToHeaderMap) -> OssResult<Self>\n    where\n        Self: Sized;\n    fn append_sign<S: TryInto<HeaderValue, Error = OssError>>(\n        &mut self,\n        sign: S,\n    ) -> OssResult<Option<HeaderValue>>;\n}\n\nimpl AuthHeader for HeaderMap {\n    fn from_auth(auth: &impl AuthToHeaderMap) -> OssResult<Self> {\n        let mut map = auth.get_original_header();\n\n        map.insert(\"AccessKeyId\", auth.get_header_key()?);\n        map.insert(\"SecretAccessKey\", auth.get_header_secret()?);\n        map.insert(\"VERB\", auth.get_header_verb()?);\n\n        if let Some(a) = auth.get_header_md5()? {\n            map.insert(\"Content-MD5\", a);\n        }\n        map.insert(\"Date\", auth.get_header_date()?);\n        map.insert(\"CanonicalizedResource\", auth.get_header_resource()?);\n\n        //println!(\"header list: {:?}\",map);\n        Ok(map)\n    }\n    fn append_sign<S: TryInto<HeaderValue, Error = OssError>>(\n        &mut self,\n        sign: S,\n    ) -> OssResult<Option<HeaderValue>> {\n        let res = self.insert(\"Authorization\", sign.try_into()?);\n        Ok(res)\n    }\n}\n\n/// # \u524d\u7f00\u662f x-oss- \u7684 header \u8bb0\u5f55\n///\n/// \u5c06\u4ed6\u4eec\u6309\u987a\u5e8f\u7ec4\u5408\u6210\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u7528\u4e8e\u8ba1\u7b97\u7b7e\u540d\npub struct OssHeader(Option<String>);\n\nimpl OssHeader {\n    pub fn new(string: Option<String>) -> Self {\n        Self(string)\n    }\n\n    pub fn is_none(&self) -> bool {\n        self.0.is_none()\n    }\n}\n\n#[cfg_attr(test, automock)]\npub trait HeaderToSign {\n    fn to_sign_string(self) -> String;\n}\n\nimpl HeaderToSign for OssHeader {\n    fn to_sign_string(self) -> String {\n        let mut content = String::new();\n        match self.0.clone() {\n            Some(str) => {\n                content.push_str(&str);\n                content.push_str(\"\\n\");\n            }\n            None => (),\n        }\n        content\n    }\n}\n\nimpl Into<String> for OssHeader {\n    fn into(self) -> String {\n        self.to_sign_string()\n    }\n}\n\n/// \u5f85\u7b7e\u540d\u7684\u6570\u636e\npub struct SignString {\n    data: String,\n    key: KeyId,\n    secret: KeySecret,\n}\n\nimpl SignString {\n    pub fn new(data: String, key: KeyId, secret: KeySecret) -> SignString {\n        SignString { data, key, secret }\n    }\n    pub fn from_auth(\n        auth: &impl AuthSignString,\n        header: impl HeaderToSign,\n    ) -> OssResult<SignString> {\n        let method = auth.verb();\n\n        let str: String = method\n            + \"\\n\"\n            + auth.content_md5().as_ref().as_ref()\n            + \"\\n\"\n            + auth.content_type().as_ref().as_ref()\n            + \"\\n\"\n            + auth.date().as_ref().as_ref()\n            + \"\\n\"\n            + header.to_sign_string().as_ref()\n            + auth.canonicalized_resource().as_ref().as_ref();\n\n        Ok(SignString {\n            data: str,\n            key: auth.key().into_owned(),\n            secret: auth.secret().into_owned(),\n        })\n    }\n\n    pub fn data(&self) -> String {\n        self.data.clone()\n    }\n\n    pub fn key_string(&self) -> String {\n        self.key.to_string()\n    }\n\n    pub fn secret_string(&self) -> String {\n        self.secret.to_string()\n    }\n\n    // \u8f6c\u5316\u6210\u7b7e\u540d\n    pub fn to_sign(self) -> OssResult<Sign> {\n        use base64::encode;\n        use hmac::{Hmac, Mac};\n        use sha1::Sha1;\n        type HmacSha1 = Hmac<Sha1>;\n\n        let secret = self.secret.as_bytes();\n        let data_u8 = self.data.as_bytes();\n\n        let mut mac = HmacSha1::new_from_slice(secret)?;\n\n        mac.update(data_u8);\n\n        let sha1 = mac.finalize().into_bytes();\n\n        Ok(Sign {\n            data: encode(sha1),\n            key: self.key.clone(),\n        })\n    }\n}\n\n/// header \u4e2d\u7684\u7b7e\u540d\npub struct Sign {\n    data: String,\n    key: KeyId,\n}\n\nimpl Sign {\n    pub fn new(data: String, key: KeyId) -> Sign {\n        Sign { data, key }\n    }\n\n    pub fn data(&self) -> String {\n        self.data.clone()\n    }\n\n    pub fn key_string(&self) -> String {\n        self.key.clone().to_string()\n    }\n}\n\nimpl TryInto<HeaderValue> for Sign {\n    type Error = OssError;\n\n    /// \u8f6c\u5316\u6210 header \u4e2d\u9700\u8981\u7684\u683c\u5f0f\n    fn try_into(self) -> OssResult<HeaderValue> {\n        let sign = format!(\"OSS {}:{}\", self.key, self.data);\n        Ok(sign.parse()?)\n    }\n}\n\n#[derive(Default, Clone)]\npub struct AuthBuilder {\n    auth: Auth,\n}\n\n#[cfg_attr(test, mockall::automock)]\nimpl AuthBuilder {\n    /// \u7ed9 key \u8d4b\u503c\n    ///\n    /// ```\n    /// # use aliyun_oss_client::auth::AuthBuilder;\n    /// let auth = AuthBuilder::default()\n    ///     .key(\"bar\".into())\n    ///     .build();\n    /// ```\n    pub fn key(mut self, key: KeyId) -> Self {\n        self.auth.set_key(key);\n        self\n    }\n\n    /// \u7ed9 secret \u8d4b\u503c\n    pub fn secret(mut self, secret: KeySecret) -> Self {\n        self.auth.set_secret(secret);\n        self\n    }\n\n    /// \u7ed9 verb \u8d4b\u503c\n    pub fn verb(mut self, verb: &VERB) -> Self {\n        self.auth.set_verb(verb.to_owned());\n        self\n    }\n\n    /// \u7ed9 content_md5 \u8d4b\u503c\n    pub fn content_md5(mut self, content_md5: ContentMd5) -> Self {\n        self.auth.set_content_md5(content_md5);\n        self\n    }\n\n    /// # \u7ed9 date \u8d4b\u503c\n    ///\n    /// ## Example\n    /// ```\n    /// use chrono::Utc;\n    /// let builder = aliyun_oss_client::auth::AuthBuilder::default()\n    ///    .date(Utc::now().into());\n    /// ```\n    pub fn date(mut self, date: Date) -> Self {\n        self.auth.set_date(date);\n        self\n    }\n\n    /// \u7ed9 content_md5 \u8d4b\u503c\n    pub fn canonicalized_resource(mut self, data: CanonicalizedResource) -> Self {\n        self.auth.set_canonicalized_resource(data);\n        self\n    }\n\n    pub fn with_headers(mut self, headers: Option<HeaderMap>) -> Self {\n        if let Some(headers) = headers {\n            self = self.extend_headers(headers);\n        }\n        self\n    }\n\n    pub fn headers(mut self, headers: HeaderMap) -> Self {\n        self.auth.set_headers(headers);\n        self\n    }\n\n    pub fn extend_headers(mut self, headers: HeaderMap) -> Self {\n        self.auth.extend_headers(headers);\n        self\n    }\n\n    /// \u7ed9 header \u5e8f\u5217\u6dfb\u52a0\u65b0\u503c\n    pub fn header_insert<K: IntoHeaderName + 'static>(mut self, key: K, val: HeaderValue) -> Self {\n        self.auth.header_insert(key, val);\n        self\n    }\n\n    /// \u6e05\u7406 headers\n    pub fn header_clear(mut self) -> Self {\n        self.auth.headers_clear();\n        self\n    }\n\n    pub fn build(self) -> Auth {\n        self.auth\n    }\n}\n\nimpl AuthGetHeader for AuthBuilder {\n    fn get_headers(&self) -> OssResult<HeaderMap> {\n        self.auth.get_headers()\n    }\n}\n\n#[cfg(test)]\nmod builder_tests {\n    use super::AuthBuilder;\n\n    #[test]\n    fn key() {\n        let builder = AuthBuilder::default();\n        assert_eq!(builder.build().get_key().as_ref(), \"\");\n\n        let mut builder = AuthBuilder::default();\n        builder = builder.key(\"bar\".into());\n        assert_eq!(builder.build().get_key().as_ref(), \"bar\");\n    }\n}\n"], "fixing_code": ["use crate::errors::{OssError, OssResult};\nuse crate::types::{CanonicalizedResource, ContentMd5, ContentType, Date, KeyId, KeySecret};\n#[cfg(test)]\nuse http::header::AsHeaderName;\n#[cfg(test)]\nuse mockall::automock;\nuse reqwest::header::{HeaderMap, HeaderName, HeaderValue, IntoHeaderName};\nuse reqwest::Method;\nuse std::borrow::Cow;\nuse std::convert::TryInto;\n\n#[derive(Clone, PartialEq, Eq)]\n#[cfg_attr(test, derive(Debug))]\n#[non_exhaustive]\npub struct VERB(pub Method);\n\n#[derive(Default, Clone)]\npub struct Auth {\n    access_key_id: KeyId,\n    access_key_secret: KeySecret,\n    verb: VERB,\n    content_md5: Option<ContentMd5>,\n    date: Date,\n    // pub canonicalized_oss_headers: &'a str, // TODO\n    canonicalized_resource: CanonicalizedResource,\n    headers: HeaderMap,\n}\n\nimpl Auth {\n    fn set_key(&mut self, access_key_id: KeyId) {\n        self.access_key_id = access_key_id;\n    }\n\n    #[cfg(test)]\n    pub(crate) fn get_key(self) -> KeyId {\n        self.access_key_id\n    }\n\n    fn set_secret(&mut self, secret: KeySecret) {\n        self.access_key_secret = secret;\n    }\n    fn set_verb(&mut self, verb: VERB) {\n        self.verb = verb;\n    }\n    fn set_content_md5(&mut self, content_md5: ContentMd5) {\n        self.content_md5 = Some(content_md5)\n    }\n    fn set_date(&mut self, date: Date) {\n        self.date = date;\n    }\n    fn set_canonicalized_resource(&mut self, canonicalized_resource: CanonicalizedResource) {\n        self.canonicalized_resource = canonicalized_resource;\n    }\n    fn set_headers(&mut self, headers: HeaderMap) {\n        self.headers = headers;\n    }\n    fn extend_headers(&mut self, headers: HeaderMap) {\n        self.headers.extend(headers);\n    }\n    fn header_insert<K: IntoHeaderName + 'static>(&mut self, key: K, val: HeaderValue) {\n        self.headers.insert(key, val);\n    }\n    fn headers_clear(&mut self) {\n        self.headers.clear();\n    }\n\n    #[cfg(test)]\n    pub(crate) fn get_header<K>(self, key: K) -> Option<HeaderValue>\n    where\n        K: AsHeaderName,\n    {\n        self.headers.get(key).cloned()\n    }\n\n    #[cfg(test)]\n    pub(crate) fn header_len(&self) -> usize {\n        self.headers.len()\n    }\n\n    #[cfg(test)]\n    pub(crate) fn header_contains_key<K>(&self, key: K) -> bool\n    where\n        K: AsHeaderName,\n    {\n        self.headers.contains_key(key)\n    }\n}\n\nimpl VERB {\n    /// GET\n    pub const GET: VERB = VERB(Method::GET);\n\n    /// POST\n    pub const POST: VERB = VERB(Method::POST);\n\n    /// PUT\n    pub const PUT: VERB = VERB(Method::PUT);\n\n    /// DELETE\n    pub const DELETE: VERB = VERB(Method::DELETE);\n\n    /// HEAD\n    pub const HEAD: VERB = VERB(Method::HEAD);\n\n    /// OPTIONS\n    pub const OPTIONS: VERB = VERB(Method::OPTIONS);\n\n    /// CONNECT\n    pub const CONNECT: VERB = VERB(Method::CONNECT);\n\n    /// PATCH\n    pub const PATCH: VERB = VERB(Method::PATCH);\n\n    /// TRACE\n    pub const TRACE: VERB = VERB(Method::TRACE);\n\n    #[inline]\n    pub fn to_string(&self) -> String {\n        self.0.to_string()\n    }\n}\n\nimpl TryInto<HeaderValue> for VERB {\n    type Error = OssError;\n    fn try_into(self) -> OssResult<HeaderValue> {\n        self.0\n            .to_string()\n            .parse::<HeaderValue>()\n            .map_err(OssError::from)\n    }\n}\n\nimpl From<VERB> for String {\n    fn from(verb: VERB) -> Self {\n        match verb.0 {\n            Method::GET => \"GET\".into(),\n            Method::POST => \"POST\".into(),\n            Method::PUT => \"PUT\".into(),\n            Method::DELETE => \"DELETE\".into(),\n            Method::HEAD => \"HEAD\".into(),\n            Method::OPTIONS => \"OPTIONS\".into(),\n            Method::CONNECT => \"CONNECT\".into(),\n            Method::PATCH => \"PATCH\".into(),\n            Method::TRACE => \"TRACE\".into(),\n            _ => \"\".into(),\n        }\n    }\n}\n\nimpl From<&str> for VERB {\n    fn from(str: &str) -> Self {\n        match str {\n            \"POST\" => VERB(Method::POST),\n            \"GET\" => VERB(Method::GET),\n            \"PUT\" => VERB(Method::PUT),\n            \"DELETE\" => VERB(Method::DELETE),\n            \"HEAD\" => VERB(Method::HEAD),\n            \"OPTIONS\" => VERB(Method::OPTIONS),\n            \"CONNECT\" => VERB(Method::CONNECT),\n            \"PATCH\" => VERB(Method::PATCH),\n            \"TRACE\" => VERB(Method::TRACE),\n            _ => VERB(Method::GET),\n        }\n    }\n}\n\nimpl Into<Method> for VERB {\n    fn into(self) -> Method {\n        self.0\n    }\n}\n\nimpl Default for VERB {\n    fn default() -> Self {\n        Self::GET\n    }\n}\n\n#[cfg_attr(test, automock)]\npub(crate) trait AuthToHeaderMap {\n    fn get_original_header(&self) -> HeaderMap;\n    fn get_header_key(&self) -> OssResult<HeaderValue>;\n    fn get_header_secret(&self) -> OssResult<HeaderValue>;\n    fn get_header_verb(&self) -> OssResult<HeaderValue>;\n    fn get_header_md5(&self) -> OssResult<Option<HeaderValue>>;\n    fn get_header_date(&self) -> OssResult<HeaderValue>;\n    fn get_header_resource(&self) -> OssResult<HeaderValue>;\n}\n\nimpl AuthToHeaderMap for Auth {\n    fn get_original_header(&self) -> HeaderMap {\n        self.headers.clone()\n    }\n    fn get_header_key(&self) -> OssResult<HeaderValue> {\n        let val: HeaderValue = self.access_key_id.as_ref().try_into()?;\n        Ok(val)\n    }\n    fn get_header_secret(&self) -> OssResult<HeaderValue> {\n        let val: HeaderValue = self.access_key_secret.as_ref().try_into()?;\n        Ok(val)\n    }\n    fn get_header_verb(&self) -> OssResult<HeaderValue> {\n        let val: HeaderValue = self.verb.clone().try_into()?;\n        Ok(val)\n    }\n    fn get_header_md5(&self) -> OssResult<Option<HeaderValue>> {\n        let res = match self.content_md5.clone() {\n            Some(val) => {\n                let val: HeaderValue = val.try_into()?;\n                Some(val)\n            }\n            None => None,\n        };\n        Ok(res)\n    }\n    fn get_header_date(&self) -> OssResult<HeaderValue> {\n        let val: HeaderValue = self.date.as_ref().try_into()?;\n        Ok(val)\n    }\n    fn get_header_resource(&self) -> OssResult<HeaderValue> {\n        let val: HeaderValue = self.canonicalized_resource.as_ref().try_into()?;\n        Ok(val)\n    }\n}\n\npub trait AuthToOssHeader {\n    fn to_oss_header(&self) -> OssResult<OssHeader>;\n}\n\nimpl AuthToOssHeader for Auth {\n    /// \u8f6c\u5316\u6210 OssHeader\n    fn to_oss_header(&self) -> OssResult<OssHeader> {\n        //return Some(\"x-oss-copy-source:/honglei123/file1.txt\");\n        let mut header: Vec<(&HeaderName, &HeaderValue)> = self\n            .headers\n            .iter()\n            .filter(|(k, _v)| k.as_str().starts_with(\"x-oss-\"))\n            .collect();\n        if header.len() == 0 {\n            return Ok(OssHeader(None));\n        }\n\n        header.sort_by(|(k1, _), (k2, _)| k1.to_string().cmp(&k2.to_string()));\n\n        let header_vec: Vec<String> = header\n            .into_iter()\n            .filter_map(|(k, v)| match v.to_str() {\n                Ok(val) => Some(k.as_str().to_owned() + \":\" + val),\n                _ => None,\n            })\n            .collect();\n\n        Ok(OssHeader(Some(header_vec.join(\"\\n\"))))\n    }\n}\n\n/// \u4ece auth \u4e2d\u63d0\u53d6\u5404\u4e2a\u5b57\u6bb5\uff0c\u7528\u4e8e\u8ba1\u7b97\u7b7e\u540d\u7684\u539f\u59cb\u5b57\u7b26\u4e32\npub(crate) trait AuthSignString {\n    fn key(&self) -> Cow<'_, KeyId>;\n    fn secret(&self) -> Cow<'_, KeySecret>;\n    fn verb(&self) -> String;\n    fn content_md5(&self) -> Cow<'_, ContentMd5>;\n    fn content_type(&self) -> Cow<'_, ContentType>;\n    fn date(&self) -> Cow<'_, Date>;\n    fn canonicalized_resource(&self) -> Cow<'_, CanonicalizedResource>;\n}\n\nimpl AuthSignString for Auth {\n    fn key(&self) -> Cow<'_, KeyId> {\n        Cow::Borrowed(&self.access_key_id)\n    }\n    fn secret(&self) -> Cow<'_, KeySecret> {\n        Cow::Borrowed(&self.access_key_secret)\n    }\n    fn verb(&self) -> String {\n        self.verb.to_string()\n    }\n    fn content_md5(&self) -> Cow<'_, ContentMd5> {\n        match self.content_md5.clone() {\n            Some(md5) => Cow::Owned(md5),\n            None => Cow::Owned(ContentMd5::new(\"\")),\n        }\n    }\n    fn content_type(&self) -> Cow<'_, ContentType> {\n        match self.headers.get(\"Content-Type\") {\n            Some(ct) => Cow::Owned(ct.to_owned().try_into().unwrap()),\n            None => Cow::Owned(ContentType::new(\"\")),\n        }\n    }\n    fn date(&self) -> Cow<'_, Date> {\n        Cow::Borrowed(&self.date)\n    }\n    fn canonicalized_resource(&self) -> Cow<'_, CanonicalizedResource> {\n        Cow::Borrowed(&self.canonicalized_resource)\n    }\n}\n\npub trait AuthGetHeader {\n    fn get_headers(&self) -> OssResult<HeaderMap>;\n}\n\nimpl AuthGetHeader for Auth {\n    fn get_headers(&self) -> OssResult<HeaderMap> {\n        let mut map = HeaderMap::from_auth(self)?;\n\n        let oss_header = self.to_oss_header()?;\n        let sign_string = SignString::from_auth(self, oss_header)?;\n        let sign = sign_string.to_sign()?;\n        map.append_sign(sign)?;\n\n        Ok(map)\n    }\n}\n\npub(crate) trait AuthHeader {\n    fn from_auth(auth: &impl AuthToHeaderMap) -> OssResult<Self>\n    where\n        Self: Sized;\n    fn append_sign<S: TryInto<HeaderValue, Error = OssError>>(\n        &mut self,\n        sign: S,\n    ) -> OssResult<Option<HeaderValue>>;\n}\n\nimpl AuthHeader for HeaderMap {\n    fn from_auth(auth: &impl AuthToHeaderMap) -> OssResult<Self> {\n        let mut map = auth.get_original_header();\n\n        map.insert(\"AccessKeyId\", auth.get_header_key()?);\n        map.insert(\"SecretAccessKey\", auth.get_header_secret()?);\n        map.insert(\"VERB\", auth.get_header_verb()?);\n\n        if let Some(a) = auth.get_header_md5()? {\n            map.insert(\"Content-MD5\", a);\n        }\n        map.insert(\"Date\", auth.get_header_date()?);\n        map.insert(\"CanonicalizedResource\", auth.get_header_resource()?);\n\n        //println!(\"header list: {:?}\",map);\n        Ok(map)\n    }\n    fn append_sign<S: TryInto<HeaderValue, Error = OssError>>(\n        &mut self,\n        sign: S,\n    ) -> OssResult<Option<HeaderValue>> {\n        let res = self.insert(\"Authorization\", sign.try_into()?);\n        Ok(res)\n    }\n}\n\n/// # \u524d\u7f00\u662f x-oss- \u7684 header \u8bb0\u5f55\n///\n/// \u5c06\u4ed6\u4eec\u6309\u987a\u5e8f\u7ec4\u5408\u6210\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u7528\u4e8e\u8ba1\u7b97\u7b7e\u540d\npub struct OssHeader(Option<String>);\n\nimpl OssHeader {\n    pub fn new(string: Option<String>) -> Self {\n        Self(string)\n    }\n\n    pub fn is_none(&self) -> bool {\n        self.0.is_none()\n    }\n}\n\n#[cfg_attr(test, automock)]\npub trait HeaderToSign {\n    fn to_sign_string(self) -> String;\n}\n\nimpl HeaderToSign for OssHeader {\n    fn to_sign_string(self) -> String {\n        let mut content = String::new();\n        match self.0.clone() {\n            Some(str) => {\n                content.push_str(&str);\n                content.push_str(\"\\n\");\n            }\n            None => (),\n        }\n        content\n    }\n}\n\nimpl Into<String> for OssHeader {\n    fn into(self) -> String {\n        self.to_sign_string()\n    }\n}\n\n/// \u5f85\u7b7e\u540d\u7684\u6570\u636e\npub struct SignString {\n    data: String,\n    key: KeyId,\n    secret: KeySecret,\n}\n\nimpl SignString {\n    pub fn new(data: String, key: KeyId, secret: KeySecret) -> SignString {\n        SignString { data, key, secret }\n    }\n\n    pub(crate) fn from_auth(\n        auth: &impl AuthSignString,\n        header: impl HeaderToSign,\n    ) -> OssResult<SignString> {\n        let method = auth.verb();\n\n        let str: String = method\n            + \"\\n\"\n            + auth.content_md5().as_ref().as_ref()\n            + \"\\n\"\n            + auth.content_type().as_ref().as_ref()\n            + \"\\n\"\n            + auth.date().as_ref().as_ref()\n            + \"\\n\"\n            + header.to_sign_string().as_ref()\n            + auth.canonicalized_resource().as_ref().as_ref();\n\n        Ok(SignString {\n            data: str,\n            key: auth.key().into_owned(),\n            secret: auth.secret().into_owned(),\n        })\n    }\n\n    pub fn data(&self) -> String {\n        self.data.clone()\n    }\n\n    #[cfg(test)]\n    pub(crate) fn key_string(&self) -> String {\n        self.key.to_string()\n    }\n\n    #[cfg(test)]\n    pub(crate) fn secret_string(&self) -> String {\n        self.secret.to_string()\n    }\n\n    // \u8f6c\u5316\u6210\u7b7e\u540d\n    pub fn to_sign(self) -> OssResult<Sign> {\n        use base64::encode;\n        use hmac::{Hmac, Mac};\n        use sha1::Sha1;\n        type HmacSha1 = Hmac<Sha1>;\n\n        let secret = self.secret.as_bytes();\n        let data_u8 = self.data.as_bytes();\n\n        let mut mac = HmacSha1::new_from_slice(secret)?;\n\n        mac.update(data_u8);\n\n        let sha1 = mac.finalize().into_bytes();\n\n        Ok(Sign {\n            data: encode(sha1),\n            key: self.key.clone(),\n        })\n    }\n}\n\n/// header \u4e2d\u7684\u7b7e\u540d\npub struct Sign {\n    data: String,\n    key: KeyId,\n}\n\nimpl Sign {\n    pub fn new(data: String, key: KeyId) -> Sign {\n        Sign { data, key }\n    }\n\n    pub fn data(&self) -> String {\n        self.data.clone()\n    }\n\n    pub fn key_string(&self) -> String {\n        self.key.clone().to_string()\n    }\n}\n\nimpl TryInto<HeaderValue> for Sign {\n    type Error = OssError;\n\n    /// \u8f6c\u5316\u6210 header \u4e2d\u9700\u8981\u7684\u683c\u5f0f\n    fn try_into(self) -> OssResult<HeaderValue> {\n        let sign = format!(\"OSS {}:{}\", self.key, self.data);\n        Ok(sign.parse()?)\n    }\n}\n\n#[derive(Default, Clone)]\npub struct AuthBuilder {\n    auth: Auth,\n}\n\n#[cfg_attr(test, mockall::automock)]\nimpl AuthBuilder {\n    /// \u7ed9 key \u8d4b\u503c\n    ///\n    /// ```\n    /// # use aliyun_oss_client::auth::AuthBuilder;\n    /// use aliyun_oss_client::auth::AuthGetHeader;\n    /// let headers = AuthBuilder::default()\n    ///     .key(\"bar\".into())\n    ///     .get_headers();\n    /// ```\n    pub fn key(mut self, key: KeyId) -> Self {\n        self.auth.set_key(key);\n        self\n    }\n\n    /// \u7ed9 secret \u8d4b\u503c\n    pub fn secret(mut self, secret: KeySecret) -> Self {\n        self.auth.set_secret(secret);\n        self\n    }\n\n    /// \u7ed9 verb \u8d4b\u503c\n    pub fn verb(mut self, verb: &VERB) -> Self {\n        self.auth.set_verb(verb.to_owned());\n        self\n    }\n\n    /// \u7ed9 content_md5 \u8d4b\u503c\n    pub fn content_md5(mut self, content_md5: ContentMd5) -> Self {\n        self.auth.set_content_md5(content_md5);\n        self\n    }\n\n    /// # \u7ed9 date \u8d4b\u503c\n    ///\n    /// ## Example\n    /// ```\n    /// use chrono::Utc;\n    /// let builder = aliyun_oss_client::auth::AuthBuilder::default()\n    ///    .date(Utc::now().into());\n    /// ```\n    pub fn date(mut self, date: Date) -> Self {\n        self.auth.set_date(date);\n        self\n    }\n\n    /// \u7ed9 content_md5 \u8d4b\u503c\n    pub fn canonicalized_resource(mut self, data: CanonicalizedResource) -> Self {\n        self.auth.set_canonicalized_resource(data);\n        self\n    }\n\n    pub fn with_headers(mut self, headers: Option<HeaderMap>) -> Self {\n        if let Some(headers) = headers {\n            self = self.extend_headers(headers);\n        }\n        self\n    }\n\n    pub fn headers(mut self, headers: HeaderMap) -> Self {\n        self.auth.set_headers(headers);\n        self\n    }\n\n    pub fn extend_headers(mut self, headers: HeaderMap) -> Self {\n        self.auth.extend_headers(headers);\n        self\n    }\n\n    /// \u7ed9 header \u5e8f\u5217\u6dfb\u52a0\u65b0\u503c\n    pub fn header_insert<K: IntoHeaderName + 'static>(mut self, key: K, val: HeaderValue) -> Self {\n        self.auth.header_insert(key, val);\n        self\n    }\n\n    /// \u6e05\u7406 headers\n    pub fn header_clear(mut self) -> Self {\n        self.auth.headers_clear();\n        self\n    }\n\n    #[allow(dead_code)]\n    pub(crate) fn build(self) -> Auth {\n        self.auth\n    }\n}\n\nimpl AuthGetHeader for AuthBuilder {\n    fn get_headers(&self) -> OssResult<HeaderMap> {\n        self.auth.get_headers()\n    }\n}\n\n#[cfg(test)]\nmod builder_tests {\n    use super::AuthBuilder;\n\n    #[test]\n    fn key() {\n        let builder = AuthBuilder::default();\n        assert_eq!(builder.build().get_key().as_ref(), \"\");\n\n        let mut builder = AuthBuilder::default();\n        builder = builder.key(\"bar\".into());\n        assert_eq!(builder.build().get_key().as_ref(), \"bar\");\n    }\n}\n"], "filenames": ["src/auth.rs"], "buggy_code_start_loc": [180], "buggy_code_end_loc": [578], "fixing_code_start_loc": [180], "fixing_code_end_loc": [583], "type": "CWE-200", "message": "aliyun-oss-client is a rust client for Alibaba Cloud OSS. Users of this library will be affected, the incoming secret will be disclosed unintentionally. This issue has been patched in version 0.8.1.", "other": {"cve": {"id": "CVE-2022-39397", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-22T21:15:10.737", "lastModified": "2022-11-28T14:56:16.053", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "aliyun-oss-client is a rust client for Alibaba Cloud OSS. Users of this library will be affected, the incoming secret will be disclosed unintentionally. This issue has been patched in version 0.8.1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:L/PR:H/UI:R/S:C/C:H/I:L/A:N", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.4, "impactScore": 4.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:aliyun-oss-client_project:aliyun-oss-client:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8.1", "matchCriteriaId": "29E6F07E-E1D6-4EBE-B862-C764AB6E43C5"}]}]}], "references": [{"url": "https://github.com/tu6ge/oss-rs/commit/e4553f7d74fce682d802f8fb073943387796df29", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tu6ge/oss-rs/security/advisories/GHSA-3w3h-7xgx-grwc", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tu6ge/oss-rs/commit/e4553f7d74fce682d802f8fb073943387796df29"}}