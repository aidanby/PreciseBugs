{"buggy_code": ["/*\n * Copyright (C) 2015 Cenk G\u00fcndo\u011fan <cnkgndgn@gmail.com>\n * Copyright (C) 2018 Freie Universit\u00e4t Berlin\n *\n * This file is subject to the terms and conditions of the GNU Lesser\n * General Public License v2.1. See the file LICENSE in the top level\n * directory for more details.\n */\n\n/**\n * @{\n *\n * @file\n * @author Cenk G\u00fcndo\u011fan <cnkgndgn@gmail.com>\n * @author Martine Lenders <m.lenders@fu-berlin.de>\n */\n\n#include <assert.h>\n#include <string.h>\n#include \"net/gnrc/netif/internal.h\"\n#include \"net/gnrc/ipv6/ext/rh.h\"\n#include \"net/gnrc/rpl/srh.h\"\n\n#define ENABLE_DEBUG                0\n#include \"debug.h\"\n\n#define GNRC_RPL_SRH_PADDING(X)     ((X & 0xF0) >> 4)\n#define GNRC_RPL_SRH_COMPRE(X)      (X & 0x0F)\n#define GNRC_RPL_SRH_COMPRI(X)      ((X & 0xF0) >> 4)\n\nstatic char addr_str[IPV6_ADDR_MAX_STR_LEN];\n\n/* checks if multiple addresses within the source routing header exist on my\n * interfaces */\nstatic void *_contains_multiple_of_my_addr(const ipv6_addr_t *dst,\n                                           const gnrc_rpl_srh_t *rh,\n                                           unsigned num_addr,\n                                           unsigned compri_addr_len)\n{\n    ipv6_addr_t addr;\n    uint8_t *addr_vec = (uint8_t *) (rh + 1);\n    bool found = false;\n    uint8_t pref_elided = GNRC_RPL_SRH_COMPRI(rh->compr);\n    uint8_t addr_len = compri_addr_len;\n    uint8_t found_pos = 0;\n\n    memcpy(&addr, dst, pref_elided);\n    for (unsigned i = 0; i < num_addr; i++) {\n        uint8_t *addr_vec_ptr = &addr_vec[i * compri_addr_len];\n\n        if (i == num_addr - 1) {\n            pref_elided = GNRC_RPL_SRH_COMPRE(rh->compr);\n            addr_len = sizeof(ipv6_addr_t) - pref_elided;\n        }\n        memcpy(&addr.u8[pref_elided], addr_vec_ptr, addr_len);\n        if (gnrc_netif_get_by_ipv6_addr(&addr) != NULL) {\n            if (found && ((i - found_pos) > 1)) {\n                DEBUG(\"RPL SRH: found multiple addresses that belong to me - \"\n                      \"discard\\n\");\n                return addr_vec_ptr;\n            }\n            found_pos = i;\n            found = true;\n        }\n    }\n    return NULL;\n}\n\nint gnrc_rpl_srh_process(ipv6_hdr_t *ipv6, gnrc_rpl_srh_t *rh, void **err_ptr)\n{\n    ipv6_addr_t addr;\n    uint8_t *addr_vec = (uint8_t *) (rh + 1), *current_address;\n    uint8_t num_addr;\n    uint8_t current_pos, pref_elided, addr_len, compri_addr_len;\n    const uint8_t new_seg_left = rh->seg_left - 1;\n\n    assert(rh->seg_left > 0);\n    num_addr = (((rh->len * 8) - GNRC_RPL_SRH_PADDING(rh->pad_resv) -\n                 (16 - GNRC_RPL_SRH_COMPRE(rh->compr))) /\n                (16 - GNRC_RPL_SRH_COMPRI(rh->compr))) + 1;\n\n    DEBUG(\"RPL SRH: %u addresses in the routing header\\n\", (unsigned) num_addr);\n\n    if (rh->seg_left > num_addr) {\n        DEBUG(\"RPL SRH: number of segments left > number of addresses - \"\n              \"discard\\n\");\n        *err_ptr = &rh->seg_left;\n        return GNRC_IPV6_EXT_RH_ERROR;\n    }\n\n    current_pos = num_addr - new_seg_left;\n    pref_elided = (new_seg_left)\n                ? GNRC_RPL_SRH_COMPRI(rh->compr)\n                : GNRC_RPL_SRH_COMPRE(rh->compr);\n    compri_addr_len = sizeof(ipv6_addr_t) - GNRC_RPL_SRH_COMPRI(rh->compr);\n    addr_len = sizeof(ipv6_addr_t) - pref_elided;\n    memcpy(&addr, &ipv6->dst, pref_elided);\n    current_address = &addr_vec[(current_pos - 1) * compri_addr_len];\n    memcpy(&addr.u8[pref_elided], current_address, addr_len);\n\n    if (ipv6_addr_is_multicast(&ipv6->dst)) {\n        DEBUG(\"RPL SRH: found a multicast destination address - discard\\n\");\n        return GNRC_IPV6_EXT_RH_ERROR;\n    }\n    if (ipv6_addr_is_multicast(&addr)) {\n        DEBUG(\"RPL SRH: found a multicast address in next address - discard\\n\");\n        return GNRC_IPV6_EXT_RH_ERROR;\n    }\n\n    /* check if multiple addresses of my interface exist */\n    if ((*err_ptr = _contains_multiple_of_my_addr(&ipv6->dst, rh, num_addr,\n                                                  compri_addr_len))) {\n        return GNRC_IPV6_EXT_RH_ERROR;\n    }\n    rh->seg_left = new_seg_left;\n    memcpy(current_address, &ipv6->dst.u8[pref_elided], addr_len);\n\n    DEBUG(\"RPL SRH: Next hop: %s at position %d\\n\",\n          ipv6_addr_to_str(addr_str, &addr, sizeof(addr_str)), current_pos);\n\n    memcpy(&ipv6->dst, &addr, sizeof(ipv6->dst));\n\n    return GNRC_IPV6_EXT_RH_FORWARDED;\n}\n\n/** @} */\n", "/*\n * Copyright (C) 2015 Freie Universit\u00e4t Berlin\n *\n * This file is subject to the terms and conditions of the GNU Lesser\n * General Public License v2.1. See the file LICENSE in the top level\n * directory for more details.\n */\n\n/**\n * @ingroup     tests\n * @{\n *\n * @file\n * @brief       Tests extension header handling of gnrc stack.\n *\n * @author      Hauke Petersen <hauke.petersen@fu-berlin.de>\n * @author      Takuo Yonezawa <Yonezawa-T2@mail.dnp.co.jp>\n *\n * @}\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"embUnit.h\"\n#include \"shell.h\"\n#include \"net/ipv6/addr.h\"\n#include \"net/ipv6/ext.h\"\n#include \"net/ipv6/hdr.h\"\n#include \"net/gnrc/pktbuf.h\"\n#include \"net/gnrc/pktdump.h\"\n#include \"net/gnrc/netreg.h\"\n#include \"net/gnrc/rpl/srh.h\"\n#include \"net/gnrc/ipv6/ext/rh.h\"\n\n#define IPV6_DST            {{ 0x20, 0x01, 0xab, 0xcd, \\\n                               0x00, 0x00, 0x00, 0x00, \\\n                               0x00, 0x00, 0x00, 0x00, \\\n                               0x00, 0x00, 0x00, 0x01 }}\n#define IPV6_ADDR1          {{ 0x20, 0x01, 0xab, 0xcd, \\\n                               0x00, 0x00, 0x00, 0x00, \\\n                               0x00, 0x00, 0x00, 0x00, \\\n                               0x00, 0x00, 0x00, 0x02 }}\n#define IPV6_ADDR2          {{ 0x20, 0x01, 0xab, 0xcd, \\\n                               0x00, 0x00, 0x00, 0x00, \\\n                               0x00, 0x00, 0x00, 0x00, \\\n                               0x00, 0x00, 0x00, 0x03 }}\n#define IPV6_MCAST_ADDR     {{ 0xff, 0x05, 0xab, 0xcd, \\\n                               0x00, 0x00, 0x00, 0x00, \\\n                               0x00, 0x00, 0x00, 0x00, \\\n                               0x00, 0x00, 0x00, 0x03 }}\n\n#define IPV6_ADDR1_ELIDED   { 0x00, 0x00, 0x02 }\n#define IPV6_ADDR2_ELIDED   { 0x00, 0x00, 0x03 }\n#define IPV6_ELIDED_PREFIX  (13)\n\n#define SRH_SEG_LEFT        (2)\n#define MAX_BUF_SIZE        ((sizeof(gnrc_rpl_srh_t) + 2) + sizeof(ipv6_addr_t))\n\nstatic ipv6_hdr_t hdr;\nstatic uint8_t buf[MAX_BUF_SIZE];\nstatic char line_buf[SHELL_DEFAULT_BUFSIZE];\nstatic gnrc_netreg_entry_t ip_entry = GNRC_NETREG_ENTRY_INIT_PID(\n        0, KERNEL_PID_UNDEF\n    );\n\nstatic void set_up_tests(void)\n{\n    memset(&hdr, 0, sizeof(hdr));\n    memset(buf, 0, sizeof(buf));\n}\n\nstatic inline void _init_hdrs(gnrc_rpl_srh_t **srh, uint8_t **vec,\n                              const ipv6_addr_t *dst)\n{\n    *srh = (gnrc_rpl_srh_t *)buf;\n    *vec = (uint8_t *)(*srh + 1);\n    memcpy(&hdr.dst, dst, sizeof(hdr.dst));\n}\n\nstatic void test_rpl_srh_dst_multicast(void)\n{\n    static const ipv6_addr_t a1 = IPV6_ADDR1, a2 = IPV6_ADDR2;\n    static const ipv6_addr_t mcast = IPV6_MCAST_ADDR;\n    gnrc_rpl_srh_t *srh;\n    uint8_t *vec;\n    void *err_ptr = NULL;\n    int res;\n\n    _init_hdrs(&srh, &vec, &mcast);\n    srh->len = (2 * sizeof(ipv6_addr_t)) / 8;\n    srh->seg_left = SRH_SEG_LEFT;\n    memcpy(vec, &a1, sizeof(a1));\n    memcpy(vec + sizeof(a1), &a2, sizeof(a2));\n\n    res = gnrc_rpl_srh_process(&hdr, srh, &err_ptr);\n    TEST_ASSERT_EQUAL_INT(res, GNRC_IPV6_EXT_RH_ERROR);\n    TEST_ASSERT_NULL(err_ptr);\n}\n\nstatic void test_rpl_srh_route_multicast(void)\n{\n    static const ipv6_addr_t a1 = IPV6_ADDR1;\n    static const ipv6_addr_t mcast = IPV6_MCAST_ADDR;\n    static const ipv6_addr_t dst = IPV6_DST;\n    gnrc_rpl_srh_t *srh;\n    uint8_t *vec;\n    void *err_ptr = NULL;\n    int res;\n\n    _init_hdrs(&srh, &vec, &dst);\n    srh->len = (2 * sizeof(ipv6_addr_t)) / 8;\n    srh->seg_left = SRH_SEG_LEFT;\n    memcpy(vec, &mcast, sizeof(mcast));\n    memcpy(vec + sizeof(mcast), &a1, sizeof(a1));\n\n    res = gnrc_rpl_srh_process(&hdr, srh, &err_ptr);\n    TEST_ASSERT_EQUAL_INT(res, GNRC_IPV6_EXT_RH_ERROR);\n    TEST_ASSERT_NULL(err_ptr);\n}\n\nstatic void test_rpl_srh_too_many_seg_left(void)\n{\n    static const ipv6_addr_t a1 = IPV6_ADDR1;\n    static const ipv6_addr_t dst = IPV6_DST;\n    gnrc_rpl_srh_t *srh;\n    uint8_t *vec;\n    void *err_ptr;\n    int res;\n\n    _init_hdrs(&srh, &vec, &dst);\n    srh->len = sizeof(ipv6_addr_t) / 8;\n    srh->seg_left = SRH_SEG_LEFT;\n    memcpy(vec, &a1, sizeof(a1));\n\n    res = gnrc_rpl_srh_process(&hdr, srh, &err_ptr);\n    TEST_ASSERT_EQUAL_INT(res, GNRC_IPV6_EXT_RH_ERROR);\n    TEST_ASSERT((&srh->seg_left) == err_ptr);\n}\n\nstatic void test_rpl_srh_nexthop_no_prefix_elided(void)\n{\n    static const ipv6_addr_t a1 = IPV6_ADDR1, a2 = IPV6_ADDR2, dst = IPV6_DST;\n    static const ipv6_addr_t expected1 = IPV6_ADDR1, expected2 = IPV6_ADDR2;\n    gnrc_rpl_srh_t *srh;\n    uint8_t *vec;\n    void *err_ptr;\n    int res;\n\n    _init_hdrs(&srh, &vec, &dst);\n    srh->len = (2 * sizeof(ipv6_addr_t)) / 8;\n    srh->seg_left = SRH_SEG_LEFT;\n    memcpy(vec, &a1, sizeof(a1));\n    memcpy(vec + sizeof(a1), &a2, sizeof(a2));\n\n    /* first hop */\n    res = gnrc_rpl_srh_process(&hdr, srh, &err_ptr);\n    TEST_ASSERT_EQUAL_INT(res, GNRC_IPV6_EXT_RH_FORWARDED);\n    TEST_ASSERT_EQUAL_INT(SRH_SEG_LEFT - 1, srh->seg_left);\n    TEST_ASSERT(ipv6_addr_equal(&hdr.dst, &expected1));\n\n    /* second hop */\n    res = gnrc_rpl_srh_process(&hdr, srh, &err_ptr);\n    TEST_ASSERT_EQUAL_INT(res, GNRC_IPV6_EXT_RH_FORWARDED);\n    TEST_ASSERT_EQUAL_INT(SRH_SEG_LEFT - 2, srh->seg_left);\n    TEST_ASSERT(ipv6_addr_equal(&hdr.dst, &expected2));\n}\n\nstatic void test_rpl_srh_nexthop_prefix_elided(void)\n{\n    static const ipv6_addr_t dst = IPV6_DST;\n    static const ipv6_addr_t expected1 = IPV6_ADDR1, expected2 = IPV6_ADDR2;\n    gnrc_rpl_srh_t *srh;\n    uint8_t *vec;\n    void *err_ptr;\n    int res;\n    static const uint8_t a1[3] = IPV6_ADDR1_ELIDED;\n    static const uint8_t a2[3] = IPV6_ADDR2_ELIDED;\n\n    _init_hdrs(&srh, &vec, &dst);\n    srh->len = (sizeof(a1) + sizeof(a2) + 2) / 8;\n    srh->seg_left = SRH_SEG_LEFT;\n    srh->compr = (IPV6_ELIDED_PREFIX << 4) | IPV6_ELIDED_PREFIX;\n    srh->pad_resv = 2 << 4;\n    memcpy(vec, &a1, sizeof(a1));\n    memcpy(vec + sizeof(a1), &a2, sizeof(a2));\n\n    /* first hop */\n    res = gnrc_rpl_srh_process(&hdr, srh, &err_ptr);\n    TEST_ASSERT_EQUAL_INT(res, GNRC_IPV6_EXT_RH_FORWARDED);\n    TEST_ASSERT_EQUAL_INT(SRH_SEG_LEFT - 1, srh->seg_left);\n    TEST_ASSERT(ipv6_addr_equal(&hdr.dst, &expected1));\n\n    /* second hop */\n    res = gnrc_rpl_srh_process(&hdr, srh, &err_ptr);\n    TEST_ASSERT_EQUAL_INT(res, GNRC_IPV6_EXT_RH_FORWARDED);\n    TEST_ASSERT_EQUAL_INT(SRH_SEG_LEFT - 2, srh->seg_left);\n    TEST_ASSERT(ipv6_addr_equal(&hdr.dst, &expected2));\n}\n\n/* tools for external interaction */\nstatic inline void _ipreg_usage(char *cmd)\n{\n    printf(\"Usage: %s {reg|unreg}\", cmd);\n}\n\nstatic int _ipreg(int argc, char **argv)\n{\n    if (argc < 2) {\n        _ipreg_usage(argv[0]);\n        return 1;\n    }\n    else if (strcmp(\"reg\", argv[1]) == 0) {\n        if (ip_entry.target.pid != KERNEL_PID_UNDEF) {\n            puts(\"Already registered to protocol number 59\");\n            return 1;\n        }\n        gnrc_netreg_entry_init_pid(&ip_entry, PROTNUM_IPV6_NONXT,\n                                   gnrc_pktdump_pid);\n        gnrc_netreg_register(GNRC_NETTYPE_IPV6, &ip_entry);\n        puts(\"Registered to protocol number 59\");\n    }\n    else if (strcmp(\"unreg\", argv[1]) == 0) {\n        puts(\"Unregistered from protocol number 59\");\n        gnrc_netreg_unregister(GNRC_NETTYPE_IPV6, &ip_entry);\n        gnrc_netreg_entry_init_pid(&ip_entry, 0, KERNEL_PID_UNDEF);\n    }\n    else {\n        _ipreg_usage(argv[0]);\n        return 1;\n    }\n\n    return 0;\n}\n\nstatic void run_unittests(void)\n{\n    EMB_UNIT_TESTFIXTURES(fixtures) {\n        new_TestFixture(test_rpl_srh_dst_multicast),\n        new_TestFixture(test_rpl_srh_route_multicast),\n        new_TestFixture(test_rpl_srh_too_many_seg_left),\n        new_TestFixture(test_rpl_srh_nexthop_no_prefix_elided),\n        new_TestFixture(test_rpl_srh_nexthop_prefix_elided),\n    };\n\n    EMB_UNIT_TESTCALLER(rpl_srh_tests, set_up_tests, NULL, fixtures);\n    TESTS_START();\n    TESTS_RUN((Test *)&rpl_srh_tests);\n    TESTS_END();\n}\n\nstatic int _unittests(int argc, char** argv)\n{\n    (void) argc;\n    (void) argv;\n\n    run_unittests();\n    return 0;\n}\n\nstatic const shell_command_t shell_commands[] = {\n    { \"ip\", \"Registers pktdump to protocol number 59 (no next header)\", _ipreg },\n    { \"unittests\", \"Runs unitest\", _unittests},\n    { NULL, NULL, NULL }\n};\n\nint main(void)\n{\n    shell_run(shell_commands, line_buf, SHELL_DEFAULT_BUFSIZE);\n    return 0;\n}\n", "#!/usr/bin/env python3\n\n# Copyright (C) 2018 Freie Universit\u00e4t Berlin\n#\n# This file is subject to the terms and conditions of the GNU Lesser\n# General Public License v2.1. See the file LICENSE in the top level\n# directory for more details.\n\nimport os\nimport random\nimport re\nimport sys\nimport subprocess\n\nfrom scapy.all import Ether, IPv6, UDP, \\\n                      IPv6ExtHdrHopByHop, IPv6ExtHdrDestOpt, \\\n                      IPv6ExtHdrFragment, IPv6ExtHdrRouting, \\\n                      ICMPv6ParamProblem, ICMPv6TimeExceeded, \\\n                      sendp, srp1, AsyncSniffer\nfrom testrunner import run, check_unittests\n\n\nEXT_HDR_NH = {\n    IPv6ExtHdrHopByHop: 0,\n    IPv6ExtHdrRouting: 43,\n    IPv6ExtHdrFragment: 44,\n    # IPSec headers currently unsupported by scapy\n    IPv6ExtHdrDestOpt: 60,\n    # Mobility header currently unsupported by scapy\n  }\n\n\nclass Sniffer(object):\n    def __init__(self, iface, *args, **kwargs):\n        self.iface = iface\n        self.sniffer = None\n        self.stop_filter = None\n\n    def start_sniff(self, stop_filter):\n        assert self.sniffer is None\n        self.stop_filter = stop_filter\n        self.sniffer = AsyncSniffer(\n            iface=self.iface,\n            stop_filter=stop_filter,\n        )\n        self.sniffer.start()\n\n    def wait_for_sniff_results(self, timeout=5):\n        assert self.sniffer is not None\n        self.sniffer.join(timeout=timeout)\n        sniffer = self.sniffer\n        self.sniffer = None\n        if sniffer.results is None:\n            return []\n        return [p for p in sniffer.results\n                # filter out packets only belonging to stop_filter if\n                # it existed\n                if sniffer.kwargs.get(\"stop_filter\") is None or\n                sniffer.kwargs[\"stop_filter\"](p)]\n\n\nsniffer = None\n\n\ndef check_and_search_output(cmd, pattern, res_group, *args, **kwargs):\n    output = subprocess.check_output(cmd, *args, **kwargs).decode(\"utf-8\")\n    for line in output.splitlines():\n        m = re.search(pattern, line)\n        if m is not None:\n            return m.group(res_group)\n    return None\n\n\ndef get_bridge(tap):\n    res = check_and_search_output(\n            [\"bridge\", \"link\"],\n            r\"{}.+master\\s+(?P<master>[^\\s]+)\".format(tap),\n            \"master\"\n        )\n    return tap if res is None else res\n\n\ndef get_host_lladdr(tap):\n    res = check_and_search_output(\n            [\"ip\", \"addr\", \"show\", \"dev\", tap, \"scope\", \"link\"],\n            r\"inet6\\s+(?P<lladdr>[0-9A-Fa-f:]+)/\\d+\",\n            \"lladdr\"\n        )\n    if res is None:\n        raise AssertionError(\n                \"Can't find host link-local address on interface {}\".format(tap)\n            )\n    else:\n        return res\n\n\ndef get_host_hwaddr(tap):\n    res = check_and_search_output(\n            [\"ip\", \"addr\", \"show\", \"dev\", tap, \"scope\", \"link\"],\n            r\"link[^\\s]+\\s+(?P<hwaddr>[0-9A-Fa-f:]+)\",\n            \"hwaddr\"\n        )\n    if res is None:\n        raise AssertionError(\n                \"Can't find host hardware address on interface {}\".format(tap)\n            )\n    else:\n        return res\n\n\ndef pktbuf_empty(child):\n    child.sendline(\"pktbuf\")\n    child.expect(r\"packet buffer: first byte: (?P<first_byte>0x[0-9a-fA-F]+), \"\n                 r\"last byte: 0x[0-9a-fA-F]+ \\(size: (?P<size>\\d+)\\)\")\n    first_byte = child.match.group(\"first_byte\")\n    size = child.match.group(\"size\")\n    child.expect(\n            r\"~ unused: {} \\(next: (\\(nil\\)|0), size: {}\\) ~\".format(\n                first_byte, size))\n\n\ndef register_protnum(child):\n    child.sendline(\"ip reg\")\n    child.expect(\"Registered to protocol number 59\")\n\n\ndef unregister(child):\n    child.sendline(\"ip unreg\")\n    child.expect(r\"Unregistered from protocol number \\d\")\n\n\ndef get_first_interface(child):\n    child.sendline(\"ifconfig\")\n    child.expect(r\"Iface\\s+(\\d+)\\s\")\n    return int(child.match.group(1))\n\n\ndef add_ipv6_address(child, iface, ipv6_addr):\n    child.sendline(\"ifconfig {} add {}\".format(iface, ipv6_addr))\n    child.expect(r\"success: added [a-f0-9:]+/\\d+ to interface \\d+\")\n\n\ndef del_ipv6_address(child, iface, ipv6_addr):\n    child.sendline(\"ifconfig {} del {}\".format(iface, ipv6_addr))\n    child.expect(r\"success: removed [a-f0-9:]+ to interface \\d+\")\n\n\ndef add_neighbor(child, iface, ipv6_addr, hw_addr):\n    child.sendline(\"nib neigh add {} {} {}\".format(iface, ipv6_addr, hw_addr))\n    child.sendline(\"nib neigh\")\n    child.expect(r\"{} dev #{} lladdr {}\".format(ipv6_addr.lower(), iface,\n                                                hw_addr.upper()))\n\n\ndef del_neighbor(child, iface, ipv6_addr):\n    child.sendline(\"nib neigh del {} {}\".format(iface, ipv6_addr))\n\n\ndef test_wrong_type(child, iface, hw_dst, ll_dst, ll_src):\n    p = srp1(Ether(dst=hw_dst) / IPv6(dst=ll_dst, src=ll_src) /\n             IPv6ExtHdrRouting(type=255, segleft=1, addresses=[\"abcd::1\"]),\n             iface=iface, timeout=1, verbose=0)\n    assert(p is not None)\n    assert(ICMPv6ParamProblem in p)\n    assert(p[ICMPv6ParamProblem].code == 0)     # erroneous header field encountered\n    assert(p[ICMPv6ParamProblem].ptr == 42)     # routing header type field\n    pktbuf_empty(child)\n\n\ndef test_seg_left_gt_len_addresses(child, iface, hw_dst, ll_dst, ll_src):\n    # send routing header with no (0) addresses but segleft set to a value\n    # larger than 0\n    p = srp1(Ether(dst=hw_dst) / IPv6(dst=ll_dst, src=ll_src) /\n             IPv6ExtHdrRouting(type=3, segleft=18, addresses=[]),\n             iface=iface, timeout=1, verbose=0)\n    assert(p is not None)\n    assert(ICMPv6ParamProblem in p)\n    assert(p[ICMPv6ParamProblem].code == 0)     # erroneous header field encountered\n    assert(p[ICMPv6ParamProblem].ptr == 43)     # segleft field\n    pktbuf_empty(child)\n\n\ndef test_multicast_dst(child, iface, hw_dst, ll_dst, ll_src):\n    # sniffing for ICMPv6 parameter problem message\n    sniffer.start_sniff(lambda p: p.haslayer(ICMPv6ParamProblem) or\n                        (p.haslayer(UDP) and (p[IPv6].dst != \"ff02::1\")))\n    # send routing header with multicast destination\n    sendp(Ether(dst=hw_dst) / IPv6(dst=\"ff02::1\", src=ll_src) /\n          IPv6ExtHdrRouting(type=3, segleft=1, addresses=[\"abcd::1\"]) /\n          UDP(dport=2606), iface=iface, verbose=0)\n    ps = sniffer.wait_for_sniff_results()\n    p = [p for p in ps if (ICMPv6ParamProblem in p) or\n                          ((UDP in p) and (p[UDP].dport == 2606) and\n                           (p[IPv6].dst != \"ff02::1\"))]\n    # packet should be discarded silently:\n    # see https://tools.ietf.org/html/rfc6554#section-4.2\n    assert(len(p) == 0)\n    pktbuf_empty(child)\n\n\ndef test_multicast_addr(child, iface, hw_dst, ll_dst, ll_src):\n    # sniffing for ICMPv6 parameter problem message\n    sniffer.start_sniff(lambda p: p.haslayer(ICMPv6ParamProblem) or\n                        (p.haslayer(UDP) and (p[IPv6].dst != ll_dst)))\n    # Send routing header with multicast address in its destinations\n    sendp(Ether(dst=hw_dst) / IPv6(dst=ll_dst, src=ll_src) /\n          IPv6ExtHdrRouting(type=3, segleft=1, addresses=[\"abcd::1\"]) /\n          UDP(dport=2606), iface=iface, verbose=0)\n    ps = sniffer.wait_for_sniff_results()\n    p = [p for p in ps if (ICMPv6ParamProblem in p) or\n                          ((UDP in p) and (p[UDP].dport == 2606) and\n                           (p[IPv6].dst != ll_dst))]\n    # packet should be discarded silently:\n    # see https://tools.ietf.org/html/rfc6554#section-4.2\n    assert(len(p) == 0)\n    pktbuf_empty(child)\n\n\ndef test_multiple_addrs_of_mine_uncomp(child, iface, hw_dst, ll_dst, ll_src):\n    dummy = \"affe::1\"\n    # add dummy IPv6 address\n    dst_iface = get_first_interface(child)\n    add_ipv6_address(child, dst_iface, dummy)\n    p = srp1(Ether(dst=hw_dst) / IPv6(dst=ll_dst, src=ll_src) /\n             IPv6ExtHdrRouting(type=3, segleft=3, addresses=[ll_dst, ll_src,\n                                                             dummy]),\n             iface=iface, timeout=1, verbose=0)\n    assert(p is not None)\n    assert(ICMPv6ParamProblem in p)\n    assert(p[ICMPv6ParamProblem].code == 0)             # erroneous header field encountered\n    assert(p[ICMPv6ParamProblem].ptr == 40+8+(2 * 16))  # dummy in routing header\n    pktbuf_empty(child)\n    del_ipv6_address(child, dst_iface, dummy)\n\n\ndef test_forward_uncomp(child, iface, hw_dst, ll_dst, ll_src):\n    dummy = \"affe::1\"\n    hl = random.randint(2, 255)\n    # sniffing for packets to dummy\n    sniffer.start_sniff(lambda p: p[Ether].src == hw_dst)\n    # add dummy IPv6 address\n    dst_iface = get_first_interface(child)\n    hw_src = get_host_hwaddr(iface)\n    add_neighbor(child, dst_iface, dummy, hw_src)\n    sendp(Ether(dst=hw_dst) / IPv6(dst=ll_dst, src=ll_src, hlim=hl) /\n          IPv6ExtHdrRouting(type=3, segleft=1, addresses=[dummy]),\n          iface=iface, verbose=0)\n    ps = sniffer.wait_for_sniff_results()\n    p = [p for p in ps if p[Ether].src == hw_dst]\n    assert(len(p) > 0)\n    p = p[0]\n    assert(IPv6 in p)\n    assert(IPv6ExtHdrRouting in p)\n    assert(p[IPv6].src == ll_src)\n    assert(p[IPv6].dst == dummy)\n    assert(p[IPv6].hlim == (hl - 1))\n    assert(p[IPv6ExtHdrRouting].type == 3)\n    assert(p[IPv6ExtHdrRouting].segleft == 0)\n    pktbuf_empty(child)\n    del_neighbor(child, dst_iface, dummy)\n\n\ndef test_forward_uncomp_not_first_ext_hdr(child, iface, hw_dst, ll_dst, ll_src):\n    dummy = \"affe::1\"\n    hl = random.randint(2, 255)\n    # sniffing for packets to dummy\n    sniffer.start_sniff(lambda p: p[Ether].src == hw_dst)\n    # add dummy IPv6 address\n    dst_iface = get_first_interface(child)\n    hw_src = get_host_hwaddr(iface)\n    add_neighbor(child, dst_iface, dummy, hw_src)\n    sendp(Ether(dst=hw_dst) / IPv6(dst=ll_dst, src=ll_src, hlim=hl) /\n          IPv6ExtHdrHopByHop() /\n          IPv6ExtHdrRouting(type=3, segleft=1, addresses=[dummy]),\n          iface=iface, verbose=0)\n    ps = sniffer.wait_for_sniff_results()\n    p = [p for p in ps if p[Ether].src == hw_dst]\n    assert(len(p) > 0)\n    p = p[0]\n    assert(IPv6 in p)\n    assert(IPv6ExtHdrRouting in p)\n    assert(p[IPv6].src == ll_src)\n    assert(p[IPv6].dst == dummy)\n    assert(p[IPv6].hlim == (hl - 1))\n    assert(p[IPv6ExtHdrRouting].type == 3)\n    assert(p[IPv6ExtHdrRouting].segleft == 0)\n    pktbuf_empty(child)\n    del_neighbor(child, dst_iface, dummy)\n\n\ndef test_seq_left_0(child, iface, hw_dst, ll_dst, ll_src):\n    register_protnum(child)\n    sendp(Ether(dst=hw_dst) / IPv6(dst=ll_dst, src=ll_src) /\n          IPv6ExtHdrRouting(type=3, segleft=0), iface=iface, verbose=0)\n    # we are the target, so the packet should be dumped\n    # empty snip\n    child.expect(r\"~~ SNIP  0 - size:\\s+0 byte, type: NETTYPE_UNDEF \\(\\d+\\)\")\n    ipv6_payload_len = 0\n    # parsed routing header\n    child.expect(r\"~~ SNIP  1 - size:\\s+(\\d+) byte, type: NETTYPE_\\w+ \\(\\d+\\)\")\n    ipv6_payload_len += int(child.match.group(1))\n    # NH = 59 (IPV6_NONXT), len = 0x00, routing type = 3, segments left = 0\n    child.expect(r\"00000000  3B  00  03  00  00  00  00  00\")\n    # IPv6 header\n    child.expect(r\"~~ SNIP  2 - size:\\s+40 byte, type: NETTYPE_IPV6 \\(\\d+\\)\")\n    child.expect_exact(r\"length: {}  next header: {}\".format(\n            ipv6_payload_len, EXT_HDR_NH[IPv6ExtHdrRouting]\n        ))\n    child.expect_exact(r\"destination address: {}\".format(ll_dst))\n    pktbuf_empty(child)\n    unregister(child)\n\n\ndef test_time_exc(child, iface, hw_dst, ll_dst, ll_src):\n    dummy = \"affe::1\"\n    p = srp1(Ether(dst=hw_dst) / IPv6(dst=ll_dst, hlim=1, src=ll_src) /\n             IPv6ExtHdrRouting(type=3, segleft=1, addresses=[dummy]),\n             iface=iface, timeout=1, verbose=0)\n    assert(p is not None)\n    assert(ICMPv6TimeExceeded in p)\n    assert(p[ICMPv6TimeExceeded].code == 0)\n    pktbuf_empty(child)\n\n\ndef testfunc(child):\n    global sniffer\n    tap = get_bridge(os.environ[\"TAP\"])\n    child.sendline(\"unittests\")\n    # wait for and check result of unittests\n    print(\".\" * check_unittests(child), end=\"\", flush=True)\n    lladdr_src = get_host_lladdr(tap)\n    child.sendline(\"ifconfig\")\n    child.expect(r\"HWaddr: (?P<hwaddr>[A-Fa-f:0-9]+)\\s\")\n    hwaddr_dst = child.match.group(\"hwaddr\").lower()\n    child.expect(r\"(?P<lladdr>fe80::[A-Fa-f:0-9]+)\\s\")\n    lladdr_dst = child.match.group(\"lladdr\").lower()\n    sniffer = Sniffer(tap)\n\n    def run(func):\n        if child.logfile == sys.stdout:\n            func(child, tap, hwaddr_dst, lladdr_dst, lladdr_src)\n        else:\n            try:\n                func(child, tap, hwaddr_dst, lladdr_dst, lladdr_src)\n                print(\".\", end=\"\", flush=True)\n            except Exception as e:\n                print(\"FAILED\")\n                raise e\n\n    run(test_wrong_type)\n    run(test_seg_left_gt_len_addresses)\n    run(test_multicast_dst)\n    run(test_multicast_addr)\n    run(test_multiple_addrs_of_mine_uncomp)\n    run(test_forward_uncomp)\n    run(test_forward_uncomp_not_first_ext_hdr)\n    # compressed tests hard to implement with scapy and also covered in\n    # unittests\n    run(test_seq_left_0)\n    run(test_time_exc)\n    print(\"SUCCESS\")\n\n\nif __name__ == \"__main__\":\n    if os.geteuid() != 0:\n        print(\"\\x1b[1;31mThis test requires root privileges.\\n\"\n              \"It's constructing and sending Ethernet frames.\\x1b[0m\\n\",\n              file=sys.stderr)\n        sys.exit(1)\n    sys.exit(run(testfunc, timeout=1, echo=False))\n"], "fixing_code": ["/*\n * Copyright (C) 2015 Cenk G\u00fcndo\u011fan <cnkgndgn@gmail.com>\n * Copyright (C) 2018 Freie Universit\u00e4t Berlin\n *\n * This file is subject to the terms and conditions of the GNU Lesser\n * General Public License v2.1. See the file LICENSE in the top level\n * directory for more details.\n */\n\n/**\n * @{\n *\n * @file\n * @author Cenk G\u00fcndo\u011fan <cnkgndgn@gmail.com>\n * @author Martine Lenders <m.lenders@fu-berlin.de>\n */\n\n#include <assert.h>\n#include <string.h>\n#include \"net/gnrc/netif/internal.h\"\n#include \"net/gnrc/ipv6/ext/rh.h\"\n#include \"net/gnrc/rpl/srh.h\"\n\n#define ENABLE_DEBUG                0\n#include \"debug.h\"\n\n#define GNRC_RPL_SRH_PADDING(X)     ((X & 0xF0) >> 4)\n#define GNRC_RPL_SRH_COMPRE(X)      (X & 0x0F)\n#define GNRC_RPL_SRH_COMPRI(X)      ((X & 0xF0) >> 4)\n\nstatic char addr_str[IPV6_ADDR_MAX_STR_LEN];\n\n/* checks if multiple addresses within the source routing header exist on my\n * interfaces */\nstatic void *_contains_multiple_of_my_addr(const ipv6_addr_t *dst,\n                                           const gnrc_rpl_srh_t *rh,\n                                           unsigned num_addr,\n                                           unsigned compri_addr_len)\n{\n    ipv6_addr_t addr;\n    uint8_t *addr_vec = (uint8_t *) (rh + 1);\n    bool found = false;\n    uint8_t pref_elided = GNRC_RPL_SRH_COMPRI(rh->compr);\n    uint8_t addr_len = compri_addr_len;\n    uint8_t found_pos = 0;\n\n    memcpy(&addr, dst, pref_elided);\n    for (unsigned i = 0; i < num_addr; i++) {\n        uint8_t *addr_vec_ptr = &addr_vec[i * compri_addr_len];\n\n        if (i == num_addr - 1) {\n            pref_elided = GNRC_RPL_SRH_COMPRE(rh->compr);\n            addr_len = sizeof(ipv6_addr_t) - pref_elided;\n        }\n        memcpy(&addr.u8[pref_elided], addr_vec_ptr, addr_len);\n        if (gnrc_netif_get_by_ipv6_addr(&addr) != NULL) {\n            if (found && ((i - found_pos) > 1)) {\n                DEBUG(\"RPL SRH: found multiple addresses that belong to me - \"\n                      \"discard\\n\");\n                return addr_vec_ptr;\n            }\n            found_pos = i;\n            found = true;\n        }\n    }\n    return NULL;\n}\n\nint gnrc_rpl_srh_process(ipv6_hdr_t *ipv6, gnrc_rpl_srh_t *rh, void **err_ptr)\n{\n    ipv6_addr_t addr;\n    uint8_t *addr_vec = (uint8_t *) (rh + 1), *current_address;\n    uint8_t num_addr;\n    uint8_t current_pos, pref_elided, addr_len, compri_addr_len;\n    const uint8_t new_seg_left = rh->seg_left - 1;\n\n    if ((rh->len * 8) < (GNRC_RPL_SRH_PADDING(rh->pad_resv) +\n                         (16 - GNRC_RPL_SRH_COMPRE(rh->compr)))) {\n        DEBUG(\"RPL SRH: inconsistent header received\\n\");\n        *err_ptr = &rh->len;\n        return GNRC_IPV6_EXT_RH_ERROR;\n    }\n\n    assert(rh->seg_left > 0);\n    num_addr = (((rh->len * 8) - GNRC_RPL_SRH_PADDING(rh->pad_resv) -\n                 (16 - GNRC_RPL_SRH_COMPRE(rh->compr))) /\n                (16 - GNRC_RPL_SRH_COMPRI(rh->compr))) + 1;\n\n    DEBUG(\"RPL SRH: %u addresses in the routing header\\n\", (unsigned) num_addr);\n\n    if (rh->seg_left > num_addr) {\n        DEBUG(\"RPL SRH: number of segments left > number of addresses - \"\n              \"discard\\n\");\n        *err_ptr = &rh->seg_left;\n        return GNRC_IPV6_EXT_RH_ERROR;\n    }\n\n    current_pos = num_addr - new_seg_left;\n    pref_elided = (new_seg_left)\n                ? GNRC_RPL_SRH_COMPRI(rh->compr)\n                : GNRC_RPL_SRH_COMPRE(rh->compr);\n    compri_addr_len = sizeof(ipv6_addr_t) - GNRC_RPL_SRH_COMPRI(rh->compr);\n    addr_len = sizeof(ipv6_addr_t) - pref_elided;\n    memcpy(&addr, &ipv6->dst, pref_elided);\n    current_address = &addr_vec[(current_pos - 1) * compri_addr_len];\n    memcpy(&addr.u8[pref_elided], current_address, addr_len);\n\n    if (ipv6_addr_is_multicast(&ipv6->dst)) {\n        DEBUG(\"RPL SRH: found a multicast destination address - discard\\n\");\n        return GNRC_IPV6_EXT_RH_ERROR;\n    }\n    if (ipv6_addr_is_multicast(&addr)) {\n        DEBUG(\"RPL SRH: found a multicast address in next address - discard\\n\");\n        return GNRC_IPV6_EXT_RH_ERROR;\n    }\n\n    /* check if multiple addresses of my interface exist */\n    if ((*err_ptr = _contains_multiple_of_my_addr(&ipv6->dst, rh, num_addr,\n                                                  compri_addr_len))) {\n        return GNRC_IPV6_EXT_RH_ERROR;\n    }\n    rh->seg_left = new_seg_left;\n    memcpy(current_address, &ipv6->dst.u8[pref_elided], addr_len);\n\n    DEBUG(\"RPL SRH: Next hop: %s at position %d\\n\",\n          ipv6_addr_to_str(addr_str, &addr, sizeof(addr_str)), current_pos);\n\n    memcpy(&ipv6->dst, &addr, sizeof(ipv6->dst));\n\n    return GNRC_IPV6_EXT_RH_FORWARDED;\n}\n\n/** @} */\n", "/*\n * Copyright (C) 2015 Freie Universit\u00e4t Berlin\n *\n * This file is subject to the terms and conditions of the GNU Lesser\n * General Public License v2.1. See the file LICENSE in the top level\n * directory for more details.\n */\n\n/**\n * @ingroup     tests\n * @{\n *\n * @file\n * @brief       Tests extension header handling of gnrc stack.\n *\n * @author      Hauke Petersen <hauke.petersen@fu-berlin.de>\n * @author      Takuo Yonezawa <Yonezawa-T2@mail.dnp.co.jp>\n *\n * @}\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"embUnit.h\"\n#include \"shell.h\"\n#include \"net/ipv6/addr.h\"\n#include \"net/ipv6/ext.h\"\n#include \"net/ipv6/hdr.h\"\n#include \"net/gnrc/pktbuf.h\"\n#include \"net/gnrc/pktdump.h\"\n#include \"net/gnrc/netreg.h\"\n#include \"net/gnrc/rpl/srh.h\"\n#include \"net/gnrc/ipv6/ext/rh.h\"\n\n#define IPV6_DST            {{ 0x20, 0x01, 0xab, 0xcd, \\\n                               0x00, 0x00, 0x00, 0x00, \\\n                               0x00, 0x00, 0x00, 0x00, \\\n                               0x00, 0x00, 0x00, 0x01 }}\n#define IPV6_ADDR1          {{ 0x20, 0x01, 0xab, 0xcd, \\\n                               0x00, 0x00, 0x00, 0x00, \\\n                               0x00, 0x00, 0x00, 0x00, \\\n                               0x00, 0x00, 0x00, 0x02 }}\n#define IPV6_ADDR2          {{ 0x20, 0x01, 0xab, 0xcd, \\\n                               0x00, 0x00, 0x00, 0x00, \\\n                               0x00, 0x00, 0x00, 0x00, \\\n                               0x00, 0x00, 0x00, 0x03 }}\n#define IPV6_MCAST_ADDR     {{ 0xff, 0x05, 0xab, 0xcd, \\\n                               0x00, 0x00, 0x00, 0x00, \\\n                               0x00, 0x00, 0x00, 0x00, \\\n                               0x00, 0x00, 0x00, 0x03 }}\n\n#define IPV6_ADDR1_ELIDED   { 0x00, 0x00, 0x02 }\n#define IPV6_ADDR2_ELIDED   { 0x00, 0x00, 0x03 }\n#define IPV6_ELIDED_PREFIX  (13)\n\n#define SRH_SEG_LEFT        (2)\n#define MAX_BUF_SIZE        ((sizeof(gnrc_rpl_srh_t) + 2) + sizeof(ipv6_addr_t))\n\nstatic ipv6_hdr_t hdr;\nstatic uint8_t buf[MAX_BUF_SIZE];\nstatic char line_buf[SHELL_DEFAULT_BUFSIZE];\nstatic gnrc_netreg_entry_t ip_entry = GNRC_NETREG_ENTRY_INIT_PID(\n        0, KERNEL_PID_UNDEF\n    );\n\nstatic void set_up_tests(void)\n{\n    memset(&hdr, 0, sizeof(hdr));\n    memset(buf, 0, sizeof(buf));\n}\n\nstatic inline void _init_hdrs(gnrc_rpl_srh_t **srh, uint8_t **vec,\n                              const ipv6_addr_t *dst)\n{\n    *srh = (gnrc_rpl_srh_t *)buf;\n    *vec = (uint8_t *)(*srh + 1);\n    memcpy(&hdr.dst, dst, sizeof(hdr.dst));\n}\n\nstatic void test_rpl_srh_dst_multicast(void)\n{\n    static const ipv6_addr_t a1 = IPV6_ADDR1, a2 = IPV6_ADDR2;\n    static const ipv6_addr_t mcast = IPV6_MCAST_ADDR;\n    gnrc_rpl_srh_t *srh;\n    uint8_t *vec;\n    void *err_ptr = NULL;\n    int res;\n\n    _init_hdrs(&srh, &vec, &mcast);\n    srh->len = (2 * sizeof(ipv6_addr_t)) / 8;\n    srh->seg_left = SRH_SEG_LEFT;\n    memcpy(vec, &a1, sizeof(a1));\n    memcpy(vec + sizeof(a1), &a2, sizeof(a2));\n\n    res = gnrc_rpl_srh_process(&hdr, srh, &err_ptr);\n    TEST_ASSERT_EQUAL_INT(res, GNRC_IPV6_EXT_RH_ERROR);\n    TEST_ASSERT_NULL(err_ptr);\n}\n\nstatic void test_rpl_srh_route_multicast(void)\n{\n    static const ipv6_addr_t a1 = IPV6_ADDR1;\n    static const ipv6_addr_t mcast = IPV6_MCAST_ADDR;\n    static const ipv6_addr_t dst = IPV6_DST;\n    gnrc_rpl_srh_t *srh;\n    uint8_t *vec;\n    void *err_ptr = NULL;\n    int res;\n\n    _init_hdrs(&srh, &vec, &dst);\n    srh->len = (2 * sizeof(ipv6_addr_t)) / 8;\n    srh->seg_left = SRH_SEG_LEFT;\n    memcpy(vec, &mcast, sizeof(mcast));\n    memcpy(vec + sizeof(mcast), &a1, sizeof(a1));\n\n    res = gnrc_rpl_srh_process(&hdr, srh, &err_ptr);\n    TEST_ASSERT_EQUAL_INT(res, GNRC_IPV6_EXT_RH_ERROR);\n    TEST_ASSERT_NULL(err_ptr);\n}\n\nstatic void test_rpl_srh_inconsistent_hdr(void)\n{\n    static const ipv6_addr_t dst = IPV6_DST;\n    gnrc_rpl_srh_t srh;\n    void *err_ptr;\n    int res;\n\n    memset(&srh, 0, sizeof(srh));\n    memcpy(&hdr.dst, &dst, sizeof(hdr.dst));\n    srh.nh = 128U;\n    srh.len = 0U;\n    srh.type = 3U;\n    srh.seg_left = 220U;\n    srh.compr = 0xc0;\n    srh.pad_resv = 0xf0;\n\n    res = gnrc_rpl_srh_process(&hdr, &srh, &err_ptr);\n    TEST_ASSERT_EQUAL_INT(res, GNRC_IPV6_EXT_RH_ERROR);\n    TEST_ASSERT((&srh.len) == err_ptr);\n}\n\nstatic void test_rpl_srh_too_many_seg_left(void)\n{\n    static const ipv6_addr_t a1 = IPV6_ADDR1;\n    static const ipv6_addr_t dst = IPV6_DST;\n    gnrc_rpl_srh_t *srh;\n    uint8_t *vec;\n    void *err_ptr;\n    int res;\n\n    _init_hdrs(&srh, &vec, &dst);\n    srh->len = sizeof(ipv6_addr_t) / 8;\n    srh->seg_left = SRH_SEG_LEFT;\n    memcpy(vec, &a1, sizeof(a1));\n\n    res = gnrc_rpl_srh_process(&hdr, srh, &err_ptr);\n    TEST_ASSERT_EQUAL_INT(res, GNRC_IPV6_EXT_RH_ERROR);\n    TEST_ASSERT((&srh->seg_left) == err_ptr);\n}\n\nstatic void test_rpl_srh_nexthop_no_prefix_elided(void)\n{\n    static const ipv6_addr_t a1 = IPV6_ADDR1, a2 = IPV6_ADDR2, dst = IPV6_DST;\n    static const ipv6_addr_t expected1 = IPV6_ADDR1, expected2 = IPV6_ADDR2;\n    gnrc_rpl_srh_t *srh;\n    uint8_t *vec;\n    void *err_ptr;\n    int res;\n\n    _init_hdrs(&srh, &vec, &dst);\n    srh->len = (2 * sizeof(ipv6_addr_t)) / 8;\n    srh->seg_left = SRH_SEG_LEFT;\n    memcpy(vec, &a1, sizeof(a1));\n    memcpy(vec + sizeof(a1), &a2, sizeof(a2));\n\n    /* first hop */\n    res = gnrc_rpl_srh_process(&hdr, srh, &err_ptr);\n    TEST_ASSERT_EQUAL_INT(res, GNRC_IPV6_EXT_RH_FORWARDED);\n    TEST_ASSERT_EQUAL_INT(SRH_SEG_LEFT - 1, srh->seg_left);\n    TEST_ASSERT(ipv6_addr_equal(&hdr.dst, &expected1));\n\n    /* second hop */\n    res = gnrc_rpl_srh_process(&hdr, srh, &err_ptr);\n    TEST_ASSERT_EQUAL_INT(res, GNRC_IPV6_EXT_RH_FORWARDED);\n    TEST_ASSERT_EQUAL_INT(SRH_SEG_LEFT - 2, srh->seg_left);\n    TEST_ASSERT(ipv6_addr_equal(&hdr.dst, &expected2));\n}\n\nstatic void test_rpl_srh_nexthop_prefix_elided(void)\n{\n    static const ipv6_addr_t dst = IPV6_DST;\n    static const ipv6_addr_t expected1 = IPV6_ADDR1, expected2 = IPV6_ADDR2;\n    gnrc_rpl_srh_t *srh;\n    uint8_t *vec;\n    void *err_ptr;\n    int res;\n    static const uint8_t a1[3] = IPV6_ADDR1_ELIDED;\n    static const uint8_t a2[3] = IPV6_ADDR2_ELIDED;\n\n    _init_hdrs(&srh, &vec, &dst);\n    srh->len = (sizeof(a1) + sizeof(a2) + 2) / 8;\n    srh->seg_left = SRH_SEG_LEFT;\n    srh->compr = (IPV6_ELIDED_PREFIX << 4) | IPV6_ELIDED_PREFIX;\n    srh->pad_resv = 2 << 4;\n    memcpy(vec, &a1, sizeof(a1));\n    memcpy(vec + sizeof(a1), &a2, sizeof(a2));\n\n    /* first hop */\n    res = gnrc_rpl_srh_process(&hdr, srh, &err_ptr);\n    TEST_ASSERT_EQUAL_INT(res, GNRC_IPV6_EXT_RH_FORWARDED);\n    TEST_ASSERT_EQUAL_INT(SRH_SEG_LEFT - 1, srh->seg_left);\n    TEST_ASSERT(ipv6_addr_equal(&hdr.dst, &expected1));\n\n    /* second hop */\n    res = gnrc_rpl_srh_process(&hdr, srh, &err_ptr);\n    TEST_ASSERT_EQUAL_INT(res, GNRC_IPV6_EXT_RH_FORWARDED);\n    TEST_ASSERT_EQUAL_INT(SRH_SEG_LEFT - 2, srh->seg_left);\n    TEST_ASSERT(ipv6_addr_equal(&hdr.dst, &expected2));\n}\n\n/* tools for external interaction */\nstatic inline void _ipreg_usage(char *cmd)\n{\n    printf(\"Usage: %s {reg|unreg}\", cmd);\n}\n\nstatic int _ipreg(int argc, char **argv)\n{\n    if (argc < 2) {\n        _ipreg_usage(argv[0]);\n        return 1;\n    }\n    else if (strcmp(\"reg\", argv[1]) == 0) {\n        if (ip_entry.target.pid != KERNEL_PID_UNDEF) {\n            puts(\"Already registered to protocol number 59\");\n            return 1;\n        }\n        gnrc_netreg_entry_init_pid(&ip_entry, PROTNUM_IPV6_NONXT,\n                                   gnrc_pktdump_pid);\n        gnrc_netreg_register(GNRC_NETTYPE_IPV6, &ip_entry);\n        puts(\"Registered to protocol number 59\");\n    }\n    else if (strcmp(\"unreg\", argv[1]) == 0) {\n        puts(\"Unregistered from protocol number 59\");\n        gnrc_netreg_unregister(GNRC_NETTYPE_IPV6, &ip_entry);\n        gnrc_netreg_entry_init_pid(&ip_entry, 0, KERNEL_PID_UNDEF);\n    }\n    else {\n        _ipreg_usage(argv[0]);\n        return 1;\n    }\n\n    return 0;\n}\n\nstatic void run_unittests(void)\n{\n    EMB_UNIT_TESTFIXTURES(fixtures) {\n        new_TestFixture(test_rpl_srh_dst_multicast),\n        new_TestFixture(test_rpl_srh_route_multicast),\n        new_TestFixture(test_rpl_srh_inconsistent_hdr),\n        new_TestFixture(test_rpl_srh_too_many_seg_left),\n        new_TestFixture(test_rpl_srh_nexthop_no_prefix_elided),\n        new_TestFixture(test_rpl_srh_nexthop_prefix_elided),\n    };\n\n    EMB_UNIT_TESTCALLER(rpl_srh_tests, set_up_tests, NULL, fixtures);\n    TESTS_START();\n    TESTS_RUN((Test *)&rpl_srh_tests);\n    TESTS_END();\n}\n\nstatic int _unittests(int argc, char** argv)\n{\n    (void) argc;\n    (void) argv;\n\n    run_unittests();\n    return 0;\n}\n\nstatic const shell_command_t shell_commands[] = {\n    { \"ip\", \"Registers pktdump to protocol number 59 (no next header)\", _ipreg },\n    { \"unittests\", \"Runs unitest\", _unittests},\n    { NULL, NULL, NULL }\n};\n\nint main(void)\n{\n    shell_run(shell_commands, line_buf, SHELL_DEFAULT_BUFSIZE);\n    return 0;\n}\n", "#!/usr/bin/env python3\n\n# Copyright (C) 2018 Freie Universit\u00e4t Berlin\n#\n# This file is subject to the terms and conditions of the GNU Lesser\n# General Public License v2.1. See the file LICENSE in the top level\n# directory for more details.\n\nimport os\nimport random\nimport re\nimport sys\nimport subprocess\n\nfrom scapy.all import Ether, IPv6, UDP, \\\n                      IPv6ExtHdrHopByHop, IPv6ExtHdrDestOpt, \\\n                      IPv6ExtHdrFragment, IPv6ExtHdrRouting, \\\n                      ICMPv6ParamProblem, ICMPv6TimeExceeded, \\\n                      sendp, srp1, AsyncSniffer\nfrom testrunner import run, check_unittests\n\n\nEXT_HDR_NH = {\n    IPv6ExtHdrHopByHop: 0,\n    IPv6ExtHdrRouting: 43,\n    IPv6ExtHdrFragment: 44,\n    # IPSec headers currently unsupported by scapy\n    IPv6ExtHdrDestOpt: 60,\n    # Mobility header currently unsupported by scapy\n  }\n\n\nclass Sniffer(object):\n    def __init__(self, iface, *args, **kwargs):\n        self.iface = iface\n        self.sniffer = None\n        self.stop_filter = None\n\n    def start_sniff(self, stop_filter):\n        assert self.sniffer is None\n        self.stop_filter = stop_filter\n        self.sniffer = AsyncSniffer(\n            iface=self.iface,\n            stop_filter=stop_filter,\n        )\n        self.sniffer.start()\n\n    def wait_for_sniff_results(self, timeout=5):\n        assert self.sniffer is not None\n        self.sniffer.join(timeout=timeout)\n        sniffer = self.sniffer\n        self.sniffer = None\n        if sniffer.results is None:\n            return []\n        return [p for p in sniffer.results\n                # filter out packets only belonging to stop_filter if\n                # it existed\n                if sniffer.kwargs.get(\"stop_filter\") is None or\n                sniffer.kwargs[\"stop_filter\"](p)]\n\n\nsniffer = None\n\n\ndef check_and_search_output(cmd, pattern, res_group, *args, **kwargs):\n    output = subprocess.check_output(cmd, *args, **kwargs).decode(\"utf-8\")\n    for line in output.splitlines():\n        m = re.search(pattern, line)\n        if m is not None:\n            return m.group(res_group)\n    return None\n\n\ndef get_bridge(tap):\n    res = check_and_search_output(\n            [\"bridge\", \"link\"],\n            r\"{}.+master\\s+(?P<master>[^\\s]+)\".format(tap),\n            \"master\"\n        )\n    return tap if res is None else res\n\n\ndef get_host_lladdr(tap):\n    res = check_and_search_output(\n            [\"ip\", \"addr\", \"show\", \"dev\", tap, \"scope\", \"link\"],\n            r\"inet6\\s+(?P<lladdr>[0-9A-Fa-f:]+)/\\d+\",\n            \"lladdr\"\n        )\n    if res is None:\n        raise AssertionError(\n                \"Can't find host link-local address on interface {}\".format(tap)\n            )\n    else:\n        return res\n\n\ndef get_host_hwaddr(tap):\n    res = check_and_search_output(\n            [\"ip\", \"addr\", \"show\", \"dev\", tap, \"scope\", \"link\"],\n            r\"link[^\\s]+\\s+(?P<hwaddr>[0-9A-Fa-f:]+)\",\n            \"hwaddr\"\n        )\n    if res is None:\n        raise AssertionError(\n                \"Can't find host hardware address on interface {}\".format(tap)\n            )\n    else:\n        return res\n\n\ndef pktbuf_empty(child):\n    child.sendline(\"pktbuf\")\n    child.expect(r\"packet buffer: first byte: (?P<first_byte>0x[0-9a-fA-F]+), \"\n                 r\"last byte: 0x[0-9a-fA-F]+ \\(size: (?P<size>\\d+)\\)\")\n    first_byte = child.match.group(\"first_byte\")\n    size = child.match.group(\"size\")\n    child.expect(\n            r\"~ unused: {} \\(next: (\\(nil\\)|0), size: {}\\) ~\".format(\n                first_byte, size))\n\n\ndef register_protnum(child):\n    child.sendline(\"ip reg\")\n    child.expect(\"Registered to protocol number 59\")\n\n\ndef unregister(child):\n    child.sendline(\"ip unreg\")\n    child.expect(r\"Unregistered from protocol number \\d\")\n\n\ndef get_first_interface(child):\n    child.sendline(\"ifconfig\")\n    child.expect(r\"Iface\\s+(\\d+)\\s\")\n    return int(child.match.group(1))\n\n\ndef add_ipv6_address(child, iface, ipv6_addr):\n    child.sendline(\"ifconfig {} add {}\".format(iface, ipv6_addr))\n    child.expect(r\"success: added [a-f0-9:]+/\\d+ to interface \\d+\")\n\n\ndef del_ipv6_address(child, iface, ipv6_addr):\n    child.sendline(\"ifconfig {} del {}\".format(iface, ipv6_addr))\n    child.expect(r\"success: removed [a-f0-9:]+ to interface \\d+\")\n\n\ndef add_neighbor(child, iface, ipv6_addr, hw_addr):\n    child.sendline(\"nib neigh add {} {} {}\".format(iface, ipv6_addr, hw_addr))\n    child.sendline(\"nib neigh\")\n    child.expect(r\"{} dev #{} lladdr {}\".format(ipv6_addr.lower(), iface,\n                                                hw_addr.upper()))\n\n\ndef del_neighbor(child, iface, ipv6_addr):\n    child.sendline(\"nib neigh del {} {}\".format(iface, ipv6_addr))\n\n\ndef test_wrong_type(child, iface, hw_dst, ll_dst, ll_src):\n    p = srp1(Ether(dst=hw_dst) / IPv6(dst=ll_dst, src=ll_src) /\n             IPv6ExtHdrRouting(type=255, segleft=1, addresses=[\"abcd::1\"]),\n             iface=iface, timeout=1, verbose=0)\n    assert(p is not None)\n    assert(ICMPv6ParamProblem in p)\n    assert(p[ICMPv6ParamProblem].code == 0)     # erroneous header field encountered\n    assert(p[ICMPv6ParamProblem].ptr == 42)     # routing header type field\n    pktbuf_empty(child)\n\n\ndef test_inconsistent_header(child, iface, hw_dst, ll_dst, ll_src):\n    # send routing header with no (0) addresses but segleft set to a value\n    # larger than 0\n    p = srp1(Ether(dst=hw_dst) / IPv6(dst=ll_dst, src=ll_src) /\n             IPv6ExtHdrRouting(type=3, segleft=18, addresses=[]),\n             iface=iface, timeout=1, verbose=0)\n    assert(p is not None)\n    assert(ICMPv6ParamProblem in p)\n    assert(p[ICMPv6ParamProblem].code == 0)     # erroneous header field encountered\n    assert(p[ICMPv6ParamProblem].ptr == 41)     # len field\n    pktbuf_empty(child)\n\n\ndef test_multicast_dst(child, iface, hw_dst, ll_dst, ll_src):\n    # sniffing for ICMPv6 parameter problem message\n    sniffer.start_sniff(lambda p: p.haslayer(ICMPv6ParamProblem) or\n                        (p.haslayer(UDP) and (p[IPv6].dst != \"ff02::1\")))\n    # send routing header with multicast destination\n    sendp(Ether(dst=hw_dst) / IPv6(dst=\"ff02::1\", src=ll_src) /\n          IPv6ExtHdrRouting(type=3, segleft=1, addresses=[\"abcd::1\"]) /\n          UDP(dport=2606), iface=iface, verbose=0)\n    ps = sniffer.wait_for_sniff_results()\n    p = [p for p in ps if (ICMPv6ParamProblem in p) or\n                          ((UDP in p) and (p[UDP].dport == 2606) and\n                           (p[IPv6].dst != \"ff02::1\"))]\n    # packet should be discarded silently:\n    # see https://tools.ietf.org/html/rfc6554#section-4.2\n    assert(len(p) == 0)\n    pktbuf_empty(child)\n\n\ndef test_multicast_addr(child, iface, hw_dst, ll_dst, ll_src):\n    # sniffing for ICMPv6 parameter problem message\n    sniffer.start_sniff(lambda p: p.haslayer(ICMPv6ParamProblem) or\n                        (p.haslayer(UDP) and (p[IPv6].dst != ll_dst)))\n    # Send routing header with multicast address in its destinations\n    sendp(Ether(dst=hw_dst) / IPv6(dst=ll_dst, src=ll_src) /\n          IPv6ExtHdrRouting(type=3, segleft=1, addresses=[\"abcd::1\"]) /\n          UDP(dport=2606), iface=iface, verbose=0)\n    ps = sniffer.wait_for_sniff_results()\n    p = [p for p in ps if (ICMPv6ParamProblem in p) or\n                          ((UDP in p) and (p[UDP].dport == 2606) and\n                           (p[IPv6].dst != ll_dst))]\n    # packet should be discarded silently:\n    # see https://tools.ietf.org/html/rfc6554#section-4.2\n    assert(len(p) == 0)\n    pktbuf_empty(child)\n\n\ndef test_multiple_addrs_of_mine_uncomp(child, iface, hw_dst, ll_dst, ll_src):\n    dummy = \"affe::1\"\n    # add dummy IPv6 address\n    dst_iface = get_first_interface(child)\n    add_ipv6_address(child, dst_iface, dummy)\n    p = srp1(Ether(dst=hw_dst) / IPv6(dst=ll_dst, src=ll_src) /\n             IPv6ExtHdrRouting(type=3, segleft=3, addresses=[ll_dst, ll_src,\n                                                             dummy]),\n             iface=iface, timeout=1, verbose=0)\n    assert(p is not None)\n    assert(ICMPv6ParamProblem in p)\n    assert(p[ICMPv6ParamProblem].code == 0)             # erroneous header field encountered\n    assert(p[ICMPv6ParamProblem].ptr == 40+8+(2 * 16))  # dummy in routing header\n    pktbuf_empty(child)\n    del_ipv6_address(child, dst_iface, dummy)\n\n\ndef test_forward_uncomp(child, iface, hw_dst, ll_dst, ll_src):\n    dummy = \"affe::1\"\n    hl = random.randint(2, 255)\n    # sniffing for packets to dummy\n    sniffer.start_sniff(lambda p: p[Ether].src == hw_dst)\n    # add dummy IPv6 address\n    dst_iface = get_first_interface(child)\n    hw_src = get_host_hwaddr(iface)\n    add_neighbor(child, dst_iface, dummy, hw_src)\n    sendp(Ether(dst=hw_dst) / IPv6(dst=ll_dst, src=ll_src, hlim=hl) /\n          IPv6ExtHdrRouting(type=3, segleft=1, addresses=[dummy]),\n          iface=iface, verbose=0)\n    ps = sniffer.wait_for_sniff_results()\n    p = [p for p in ps if p[Ether].src == hw_dst]\n    assert(len(p) > 0)\n    p = p[0]\n    assert(IPv6 in p)\n    assert(IPv6ExtHdrRouting in p)\n    assert(p[IPv6].src == ll_src)\n    assert(p[IPv6].dst == dummy)\n    assert(p[IPv6].hlim == (hl - 1))\n    assert(p[IPv6ExtHdrRouting].type == 3)\n    assert(p[IPv6ExtHdrRouting].segleft == 0)\n    pktbuf_empty(child)\n    del_neighbor(child, dst_iface, dummy)\n\n\ndef test_forward_uncomp_not_first_ext_hdr(child, iface, hw_dst, ll_dst, ll_src):\n    dummy = \"affe::1\"\n    hl = random.randint(2, 255)\n    # sniffing for packets to dummy\n    sniffer.start_sniff(lambda p: p[Ether].src == hw_dst)\n    # add dummy IPv6 address\n    dst_iface = get_first_interface(child)\n    hw_src = get_host_hwaddr(iface)\n    add_neighbor(child, dst_iface, dummy, hw_src)\n    sendp(Ether(dst=hw_dst) / IPv6(dst=ll_dst, src=ll_src, hlim=hl) /\n          IPv6ExtHdrHopByHop() /\n          IPv6ExtHdrRouting(type=3, segleft=1, addresses=[dummy]),\n          iface=iface, verbose=0)\n    ps = sniffer.wait_for_sniff_results()\n    p = [p for p in ps if p[Ether].src == hw_dst]\n    assert(len(p) > 0)\n    p = p[0]\n    assert(IPv6 in p)\n    assert(IPv6ExtHdrRouting in p)\n    assert(p[IPv6].src == ll_src)\n    assert(p[IPv6].dst == dummy)\n    assert(p[IPv6].hlim == (hl - 1))\n    assert(p[IPv6ExtHdrRouting].type == 3)\n    assert(p[IPv6ExtHdrRouting].segleft == 0)\n    pktbuf_empty(child)\n    del_neighbor(child, dst_iface, dummy)\n\n\ndef test_seq_left_0(child, iface, hw_dst, ll_dst, ll_src):\n    register_protnum(child)\n    sendp(Ether(dst=hw_dst) / IPv6(dst=ll_dst, src=ll_src) /\n          IPv6ExtHdrRouting(type=3, segleft=0), iface=iface, verbose=0)\n    # we are the target, so the packet should be dumped\n    # empty snip\n    child.expect(r\"~~ SNIP  0 - size:\\s+0 byte, type: NETTYPE_UNDEF \\(\\d+\\)\")\n    ipv6_payload_len = 0\n    # parsed routing header\n    child.expect(r\"~~ SNIP  1 - size:\\s+(\\d+) byte, type: NETTYPE_\\w+ \\(\\d+\\)\")\n    ipv6_payload_len += int(child.match.group(1))\n    # NH = 59 (IPV6_NONXT), len = 0x00, routing type = 3, segments left = 0\n    child.expect(r\"00000000  3B  00  03  00  00  00  00  00\")\n    # IPv6 header\n    child.expect(r\"~~ SNIP  2 - size:\\s+40 byte, type: NETTYPE_IPV6 \\(\\d+\\)\")\n    child.expect_exact(r\"length: {}  next header: {}\".format(\n            ipv6_payload_len, EXT_HDR_NH[IPv6ExtHdrRouting]\n        ))\n    child.expect_exact(r\"destination address: {}\".format(ll_dst))\n    pktbuf_empty(child)\n    unregister(child)\n\n\ndef test_time_exc(child, iface, hw_dst, ll_dst, ll_src):\n    dummy = \"affe::1\"\n    p = srp1(Ether(dst=hw_dst) / IPv6(dst=ll_dst, hlim=1, src=ll_src) /\n             IPv6ExtHdrRouting(type=3, segleft=1, addresses=[dummy]),\n             iface=iface, timeout=1, verbose=0)\n    assert(p is not None)\n    assert(ICMPv6TimeExceeded in p)\n    assert(p[ICMPv6TimeExceeded].code == 0)\n    pktbuf_empty(child)\n\n\ndef testfunc(child):\n    global sniffer\n    tap = get_bridge(os.environ[\"TAP\"])\n    child.sendline(\"unittests\")\n    # wait for and check result of unittests\n    print(\".\" * check_unittests(child), end=\"\", flush=True)\n    lladdr_src = get_host_lladdr(tap)\n    child.sendline(\"ifconfig\")\n    child.expect(r\"HWaddr: (?P<hwaddr>[A-Fa-f:0-9]+)\\s\")\n    hwaddr_dst = child.match.group(\"hwaddr\").lower()\n    child.expect(r\"(?P<lladdr>fe80::[A-Fa-f:0-9]+)\\s\")\n    lladdr_dst = child.match.group(\"lladdr\").lower()\n    sniffer = Sniffer(tap)\n\n    def run(func):\n        if child.logfile == sys.stdout:\n            func(child, tap, hwaddr_dst, lladdr_dst, lladdr_src)\n        else:\n            try:\n                func(child, tap, hwaddr_dst, lladdr_dst, lladdr_src)\n                print(\".\", end=\"\", flush=True)\n            except Exception as e:\n                print(\"FAILED\")\n                raise e\n\n    run(test_wrong_type)\n    run(test_inconsistent_header)\n    run(test_multicast_dst)\n    run(test_multicast_addr)\n    run(test_multiple_addrs_of_mine_uncomp)\n    run(test_forward_uncomp)\n    run(test_forward_uncomp_not_first_ext_hdr)\n    # compressed tests hard to implement with scapy and also covered in\n    # unittests\n    run(test_seq_left_0)\n    run(test_time_exc)\n    print(\"SUCCESS\")\n\n\nif __name__ == \"__main__\":\n    if os.geteuid() != 0:\n        print(\"\\x1b[1;31mThis test requires root privileges.\\n\"\n              \"It's constructing and sending Ethernet frames.\\x1b[0m\\n\",\n              file=sys.stderr)\n        sys.exit(1)\n    sys.exit(run(testfunc, timeout=1, echo=False))\n"], "filenames": ["sys/net/gnrc/routing/rpl/srh/gnrc_rpl_srh.c", "tests/gnrc_rpl_srh/main.c", "tests/gnrc_rpl_srh/tests-as-root/01-run.py"], "buggy_code_start_loc": [76, 122, 170], "buggy_code_end_loc": [76, 241, 352], "fixing_code_start_loc": [77, 123, 170], "fixing_code_end_loc": [84, 264, 352], "type": "CWE-191", "message": "RIOT-OS, an operating system for Internet of Things (IoT) devices, contains a network stack with the ability to process 6LoWPAN frames. Prior to version 2023.04, an attacker can send a crafted frame to the device resulting in an integer underflow and out of bounds access in the packet buffer. Triggering the access at the right time will corrupt other packets or the allocator metadata. Corrupting a pointer will lead to denial of service. This issue is fixed in version 2023.04. As a workaround, disable SRH in the network stack.", "other": {"cve": {"id": "CVE-2023-24817", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-30T16:15:09.607", "lastModified": "2023-06-07T19:10:07.593", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "RIOT-OS, an operating system for Internet of Things (IoT) devices, contains a network stack with the ability to process 6LoWPAN frames. Prior to version 2023.04, an attacker can send a crafted frame to the device resulting in an integer underflow and out of bounds access in the packet buffer. Triggering the access at the right time will corrupt other packets or the allocator metadata. Corrupting a pointer will lead to denial of service. This issue is fixed in version 2023.04. As a workaround, disable SRH in the network stack."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-191"}, {"lang": "en", "value": "CWE-787"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-119"}, {"lang": "en", "value": "CWE-191"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:riot-os:riot:*:*:*:*:*:*:*:*", "versionEndExcluding": "2023.04", "matchCriteriaId": "3563E17A-D38F-412B-8C65-733C4439DE19"}]}]}], "references": [{"url": "https://github.com/RIOT-OS/RIOT/commit/34dc1757f5621be48e226cfebb2f4c63505b5360", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/RIOT-OS/RIOT/security/advisories/GHSA-xjgw-7638-29g5", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/RIOT-OS/RIOT/commit/34dc1757f5621be48e226cfebb2f4c63505b5360"}}