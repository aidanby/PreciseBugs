{"buggy_code": ["/* eslint-disable no-param-reassign */\n/* eslint-disable no-restricted-syntax */\n/* eslint-disable guard-for-in */\n\nimport assert from './assert';\nimport objectAssign from './object-assign';\n\nfunction pick(object, keys) {\n  return keys.reduce(function(prev, key) {\n    if (object[key]) {\n      prev[key] = object[key];\n    }\n    return prev;\n  }, {});\n}\n\nfunction getKeysNotIn(obj, allowedKeys) {\n  var notAllowed = [];\n  for (var key in obj) {\n    if (allowedKeys.indexOf(key) === -1) {\n      notAllowed.push(key);\n    }\n  }\n  return notAllowed;\n}\n\nfunction objectValues(obj) {\n  var values = [];\n  for (var key in obj) {\n    values.push(obj[key]);\n  }\n  return values;\n}\n\nfunction extend() {\n  var params = objectValues(arguments);\n  params.unshift({});\n  return objectAssign.get().apply(undefined, params);\n}\n\nfunction merge(object, keys) {\n  return {\n    base: keys ? pick(object, keys) : object,\n    with: function(object2, keys2) {\n      object2 = keys2 ? pick(object2, keys2) : object2;\n      return extend(this.base, object2);\n    }\n  };\n}\n\nfunction blacklist(object, blacklistedKeys) {\n  return Object.keys(object).reduce(function(p, key) {\n    if (blacklistedKeys.indexOf(key) === -1) {\n      p[key] = object[key];\n    }\n    return p;\n  }, {});\n}\n\nfunction camelToSnake(str) {\n  var newKey = '';\n  var index = 0;\n  var code;\n  var wasPrevNumber = true;\n  var wasPrevUppercase = true;\n\n  while (index < str.length) {\n    code = str.charCodeAt(index);\n    if (\n      (!wasPrevUppercase && code >= 65 && code <= 90) ||\n      (!wasPrevNumber && code >= 48 && code <= 57)\n    ) {\n      newKey += '_';\n      newKey += str[index].toLowerCase();\n    } else {\n      newKey += str[index].toLowerCase();\n    }\n    wasPrevNumber = code >= 48 && code <= 57;\n    wasPrevUppercase = code >= 65 && code <= 90;\n    index++;\n  }\n\n  return newKey;\n}\n\nfunction snakeToCamel(str) {\n  var parts = str.split('_');\n  return parts.reduce(function(p, c) {\n    return p + c.charAt(0).toUpperCase() + c.slice(1);\n  }, parts.shift());\n}\n\nfunction toSnakeCase(object, exceptions) {\n  if (typeof object !== 'object' || assert.isArray(object) || object === null) {\n    return object;\n  }\n  exceptions = exceptions || [];\n\n  return Object.keys(object).reduce(function(p, key) {\n    var newKey = exceptions.indexOf(key) === -1 ? camelToSnake(key) : key;\n    p[newKey] = toSnakeCase(object[key]);\n    return p;\n  }, {});\n}\n\nfunction toCamelCase(object, exceptions, options) {\n  if (typeof object !== 'object' || assert.isArray(object) || object === null) {\n    return object;\n  }\n\n  exceptions = exceptions || [];\n  options = options || {};\n  return Object.keys(object).reduce(function(p, key) {\n    var newKey = exceptions.indexOf(key) === -1 ? snakeToCamel(key) : key;\n\n    p[newKey] = toCamelCase(object[newKey] || object[key], [], options);\n\n    if (options.keepOriginal) {\n      p[key] = toCamelCase(object[key], [], options);\n    }\n    return p;\n  }, {});\n}\n\nfunction getLocationFromUrl(href) {\n  var match = href.match(\n    /^(https?:|file:|chrome-extension:)\\/\\/(([^:/?#]*)(?::([0-9]+))?)([/]{0,1}[^?#]*)(\\?[^#]*|)(#.*|)$/\n  );\n  return (\n    match && {\n      href: href,\n      protocol: match[1],\n      host: match[2],\n      hostname: match[3],\n      port: match[4],\n      pathname: match[5],\n      search: match[6],\n      hash: match[7]\n    }\n  );\n}\n\nfunction getOriginFromUrl(url) {\n  if (!url) {\n    return undefined;\n  }\n  var parsed = getLocationFromUrl(url);\n  var origin = parsed.protocol + '//' + parsed.hostname;\n  if (parsed.port) {\n    origin += ':' + parsed.port;\n  }\n  return origin;\n}\n\nfunction trim(options, key) {\n  var trimmed = extend(options);\n  if (options[key]) {\n    trimmed[key] = options[key].trim();\n  }\n  return trimmed;\n}\n\nfunction trimMultiple(options, keys) {\n  return keys.reduce(trim, options);\n}\n\nfunction trimUserDetails(options) {\n  return trimMultiple(options, ['username', 'email', 'phoneNumber']);\n}\n\nexport default {\n  toSnakeCase: toSnakeCase,\n  toCamelCase: toCamelCase,\n  blacklist: blacklist,\n  merge: merge,\n  pick: pick,\n  getKeysNotIn: getKeysNotIn,\n  extend: extend,\n  getOriginFromUrl: getOriginFromUrl,\n  getLocationFromUrl: getLocationFromUrl,\n  trimUserDetails: trimUserDetails\n};\n", "import error from './error';\nimport objectHelper from './object';\n\nfunction wrapCallback(cb, options) {\n  options = options || {};\n  options.ignoreCasing = options.ignoreCasing ? options.ignoreCasing : false;\n\n  return function(err, data) {\n    var errObj;\n\n    if (!err && !data) {\n      return cb(error.buildResponse('generic_error', 'Something went wrong'));\n    }\n\n    if (!err && data.err) {\n      err = data.err;\n      data = null;\n    }\n\n    if (!err && data.error) {\n      err = data;\n      data = null;\n    }\n\n    if (err) {\n      errObj = {\n        original: err\n      };\n\n      if (err.response && err.response.statusCode) {\n        errObj.statusCode = err.response.statusCode;\n      }\n\n      if (err.response && err.response.statusText) {\n        errObj.statusText = err.response.statusText;\n      }\n\n      if (err.response && err.response.body) {\n        err = err.response.body;\n      }\n\n      if (err.err) {\n        err = err.err;\n      }\n\n      errObj.code =\n        err.code || err.error || err.error_code || err.status || null;\n\n      errObj.description =\n        err.errorDescription ||\n        err.error_description ||\n        err.description ||\n        err.error ||\n        err.details ||\n        err.err ||\n        null;\n\n      if (options.forceLegacyError) {\n        errObj.error = errObj.code;\n        errObj.error_description = errObj.description;\n      }\n\n      if (err.error_codes && err.error_details) {\n        errObj.errorDetails = {\n          codes: err.error_codes,\n          details: err.error_details\n        };\n      }\n\n      if (err.name) {\n        errObj.name = err.name;\n      }\n\n      if (err.policy) {\n        errObj.policy = err.policy;\n      }\n\n      return cb(errObj);\n    }\n\n    if (\n      data.type &&\n      (data.type === 'text/html' || data.type === 'text/plain')\n    ) {\n      return cb(null, data.text);\n    }\n\n    if (options.ignoreCasing) {\n      return cb(null, data.body || data);\n    }\n\n    return cb(\n      null,\n      objectHelper.toCamelCase(data.body || data, [], {\n        keepOriginal: options.keepOriginalCasing\n      })\n    );\n  };\n}\n\nexport default wrapCallback;\n", "import expect from 'expect.js';\nimport sinon from 'sinon';\n\nimport objectAssign from '../../src/helper/object-assign';\nimport objectHelper from '../../src/helper/object';\nimport windowHelper from '../../src/helper/window';\n\ndescribe('helpers', function() {\n  describe('getKeysNotIn', function() {\n    it('should return the list of keys not allowed', function() {\n      var object = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      };\n\n      var notAllowed = ['attr1', 'attr2', 'attr4'];\n\n      var keysList = objectHelper.getKeysNotIn(object, notAllowed);\n\n      expect(keysList).to.eql(['attr3']);\n    });\n\n    it('should return an empty list', function() {\n      var object = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      };\n\n      var notAllowed = ['attr1', 'attr2', 'attr3'];\n\n      var keysList = objectHelper.getKeysNotIn(object, notAllowed);\n\n      expect(keysList).to.eql([]);\n    });\n\n    it('should return an all the keys', function() {\n      var object = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      };\n\n      var notAllowed = ['attr5', 'attr6', 'attr7'];\n\n      var keysList = objectHelper.getKeysNotIn(object, notAllowed);\n\n      expect(keysList).to.eql(['attr1', 'attr2', 'attr3']);\n    });\n\n    it('should return another empty list', function() {\n      var object = {};\n\n      var notAllowed = ['attr5', 'attr6', 'attr7'];\n\n      var keysList = objectHelper.getKeysNotIn(object, notAllowed);\n\n      expect(keysList).to.eql([]);\n    });\n  });\n\n  describe('pick', function() {\n    it('should return only the requested attributes', function() {\n      var object = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      };\n\n      var newObject = objectHelper.pick(object, ['attr1', 'attr2']);\n\n      expect(newObject).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2'\n      });\n\n      expect(object).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      });\n    });\n\n    it('should ignore missing keys', function() {\n      var object = {\n        attr1: 'attribute_1',\n        attr3: 'attribute_3'\n      };\n\n      var newObject = objectHelper.pick(object, ['attr1', 'attr2']);\n\n      expect(newObject).to.eql({\n        attr1: 'attribute_1'\n      });\n\n      expect(object).to.eql({\n        attr1: 'attribute_1',\n        attr3: 'attribute_3'\n      });\n    });\n  });\n\n  describe('extend', function() {\n    it('should merge objects attributes', function() {\n      var object1 = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2'\n      };\n\n      var object2 = {\n        attr3: 'attribute_3'\n      };\n\n      var newObject = objectHelper.extend(object1, object2);\n\n      expect(newObject).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      });\n\n      expect(object1).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2'\n      });\n\n      expect(object2).to.eql({\n        attr3: 'attribute_3'\n      });\n    });\n\n    it('shold merge objects attributes with polyfill', function() {\n      sinon.stub(objectAssign, 'get').callsFake(function() {\n        return objectAssign.objectAssignPolyfill;\n      });\n\n      var object1 = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2'\n      };\n\n      var object2 = {\n        attr3: 'attribute_3'\n      };\n\n      var newObject = objectHelper.extend(object1, object2);\n\n      expect(newObject).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      });\n\n      expect(object1).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2'\n      });\n\n      expect(object2).to.eql({\n        attr3: 'attribute_3'\n      });\n\n      objectAssign.get.restore();\n    });\n\n    it('shold merge objects attributes and override the first object ones', function() {\n      var object1 = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2'\n      };\n\n      var object2 = {\n        attr2: 'attribute_2_2',\n        attr3: 'attribute_3'\n      };\n\n      var newObject = objectHelper.extend(object1, object2);\n\n      expect(newObject).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2_2',\n        attr3: 'attribute_3'\n      });\n\n      expect(object1).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2'\n      });\n\n      expect(object2).to.eql({\n        attr2: 'attribute_2_2',\n        attr3: 'attribute_3'\n      });\n    });\n  });\n\n  describe('merge', function() {\n    it('shold merge without pick', function() {\n      var object1 = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      };\n\n      var object2 = {\n        attrA: 'attribute_A',\n        attrB: 'attribute_B',\n        attrC: 'attribute_C'\n      };\n\n      var newObject = objectHelper.merge(object1).with(object2);\n\n      expect(newObject).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3',\n        attrA: 'attribute_A',\n        attrB: 'attribute_B',\n        attrC: 'attribute_C'\n      });\n\n      expect(object1).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      });\n\n      expect(object2).to.eql({\n        attrA: 'attribute_A',\n        attrB: 'attribute_B',\n        attrC: 'attribute_C'\n      });\n    });\n\n    it('shold merge picking attributes of the base object', function() {\n      var object1 = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      };\n\n      var object2 = {\n        attrA: 'attribute_A',\n        attrB: 'attribute_B',\n        attrC: 'attribute_C'\n      };\n\n      var newObject = objectHelper\n        .merge(object1, ['attr1', 'attr2'])\n        .with(object2);\n\n      expect(newObject).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attrA: 'attribute_A',\n        attrB: 'attribute_B',\n        attrC: 'attribute_C'\n      });\n\n      expect(object1).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      });\n\n      expect(object2).to.eql({\n        attrA: 'attribute_A',\n        attrB: 'attribute_B',\n        attrC: 'attribute_C'\n      });\n    });\n\n    it('shold merge picking attributes of the second object', function() {\n      var object1 = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      };\n\n      var object2 = {\n        attrA: 'attribute_A',\n        attrB: 'attribute_B',\n        attrC: 'attribute_C'\n      };\n\n      var newObject = objectHelper\n        .merge(object1)\n        .with(object2, ['attrA', 'attrC']);\n\n      expect(newObject).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3',\n        attrA: 'attribute_A',\n        attrC: 'attribute_C'\n      });\n\n      expect(object1).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      });\n\n      expect(object2).to.eql({\n        attrA: 'attribute_A',\n        attrB: 'attribute_B',\n        attrC: 'attribute_C'\n      });\n    });\n\n    it('should merge picking attributes of both objects', function() {\n      var object1 = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      };\n\n      var object2 = {\n        attrA: 'attribute_A',\n        attrB: 'attribute_B',\n        attrC: 'attribute_C'\n      };\n\n      var newObject = objectHelper\n        .merge(object1, ['attr2', 'attr3'])\n        .with(object2, ['attrA', 'attrC']);\n\n      expect(newObject).to.eql({\n        attr2: 'attribute_2',\n        attr3: 'attribute_3',\n        attrA: 'attribute_A',\n        attrC: 'attribute_C'\n      });\n\n      expect(object1).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      });\n\n      expect(object2).to.eql({\n        attrA: 'attribute_A',\n        attrB: 'attribute_B',\n        attrC: 'attribute_C'\n      });\n    });\n  });\n\n  describe('blacklist', function() {\n    it('should return all the attributes not blacklisted', function() {\n      var object = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      };\n\n      var newObject = objectHelper.blacklist(object, ['attr1', 'attr2']);\n\n      expect(newObject).to.eql({\n        attr3: 'attribute_3'\n      });\n\n      expect(object).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      });\n    });\n  });\n\n  describe('toSnakeCase', function() {\n    it('should change the casing to all the attributes', function() {\n      var object = {\n        attrName1: 'attribute_1',\n        attrName22: 'attribute_2',\n        attrNAME3: 'attribute_3',\n        attrNULL: null,\n        arrayAtt: ['one', 'two'],\n        someObj: {\n          objAtt1: 'asd',\n          objAtt2: '123',\n          innerArrayAtt: ['one', 'two']\n        }\n      };\n\n      var newObject = objectHelper.toSnakeCase(object);\n\n      expect(object).to.eql({\n        attrName1: 'attribute_1',\n        attrName22: 'attribute_2',\n        attrNAME3: 'attribute_3',\n        attrNULL: null,\n        arrayAtt: ['one', 'two'],\n        someObj: {\n          objAtt1: 'asd',\n          objAtt2: '123',\n          innerArrayAtt: ['one', 'two']\n        }\n      });\n\n      expect(newObject.array_att).to.be.an('array');\n      expect(newObject.some_obj.inner_array_att).to.be.an('array');\n\n      expect(newObject).to.eql({\n        attr_name_1: 'attribute_1',\n        attr_name_22: 'attribute_2',\n        attr_name_3: 'attribute_3',\n        attr_null: null,\n        array_att: ['one', 'two'],\n        some_obj: {\n          obj_att_1: 'asd',\n          obj_att_2: '123',\n          inner_array_att: ['one', 'two']\n        }\n      });\n    });\n\n    it('should change the casing to all the attributes that are not blacklisted', function() {\n      var object = {\n        attrName1: 'attribute_1',\n        attrName22: 'attribute_2',\n        attrNAME3: 'attribute_3'\n      };\n\n      var newObject = objectHelper.toSnakeCase(object, ['attrName22']);\n\n      expect(object).to.eql({\n        attrName1: 'attribute_1',\n        attrName22: 'attribute_2',\n        attrNAME3: 'attribute_3'\n      });\n\n      expect(newObject).to.eql({\n        attr_name_1: 'attribute_1',\n        attrName22: 'attribute_2',\n        attr_name_3: 'attribute_3'\n      });\n    });\n  });\n\n  describe('toCamelCase', function() {\n    it('should change the casing to all the attributes', function() {\n      var object = {\n        attr_name_1: 'attribute_1',\n        attr_name_22: 'attribute_2',\n        attr__name_3: 'attribute_3',\n        attr_null: null,\n        arr_att: ['one', 'two'],\n        some_obj: {\n          obj_att_1: 'asdf',\n          obj_att_2: '1234',\n          inner_array_att: ['one', 'two']\n        }\n      };\n\n      var newObject = objectHelper.toCamelCase(object);\n\n      expect(newObject).to.eql({\n        attrName1: 'attribute_1',\n        attrName22: 'attribute_2',\n        attrName3: 'attribute_3',\n        attrNull: null,\n        arrAtt: ['one', 'two'],\n        someObj: {\n          objAtt1: 'asdf',\n          objAtt2: '1234',\n          innerArrayAtt: ['one', 'two']\n        }\n      });\n    });\n\n    it('should not break the string', function() {\n      var object = 'some random string';\n\n      var newObject = objectHelper.toCamelCase(object);\n\n      expect(object).to.eql('some random string');\n\n      expect(newObject).to.be.a('string');\n\n      expect(newObject).to.eql('some random string');\n    });\n\n    it('should change the casing to all the attributes that are not blacklisted', function() {\n      var object = {\n        attr_name_1: 'attribute_1',\n        attr_name_22: 'attribute_2',\n        attr__name_3: 'attribute_3'\n      };\n\n      var newObject = objectHelper.toCamelCase(object, ['attr_name_22']);\n\n      expect(object).to.eql({\n        attr_name_1: 'attribute_1',\n        attr_name_22: 'attribute_2',\n        attr__name_3: 'attribute_3'\n      });\n\n      expect(newObject).to.eql({\n        attrName1: 'attribute_1',\n        attr_name_22: 'attribute_2',\n        attrName3: 'attribute_3'\n      });\n    });\n\n    it('should keep original property as well', function() {\n      var object = {\n        attr_name_1: 'attribute_1',\n        attr_name_22: 'attribute_2',\n        attr__name_3: 'attribute_3',\n        attr_null: null,\n        arr_att: ['one', 'two'],\n        some_obj: {\n          obj_att_1: 'asdf',\n          obj_att_2: '1234',\n          inner_array_att: ['one', 'two']\n        }\n      };\n\n      var newObject = objectHelper.toCamelCase(object, [], {\n        keepOriginal: true\n      });\n\n      expect(newObject).to.eql({\n        attrName1: 'attribute_1',\n        attr_name_1: 'attribute_1',\n        attrName22: 'attribute_2',\n        attr_name_22: 'attribute_2',\n        attrName3: 'attribute_3',\n        attr__name_3: 'attribute_3',\n        attrNull: null,\n        attr_null: null,\n        arrAtt: ['one', 'two'],\n        arr_att: ['one', 'two'],\n        someObj: {\n          objAtt1: 'asdf',\n          obj_att_1: 'asdf',\n          objAtt2: '1234',\n          obj_att_2: '1234',\n          innerArrayAtt: ['one', 'two'],\n          inner_array_att: ['one', 'two']\n        },\n        some_obj: {\n          objAtt1: 'asdf',\n          obj_att_1: 'asdf',\n          objAtt2: '1234',\n          obj_att_2: '1234',\n          innerArrayAtt: ['one', 'two'],\n          inner_array_att: ['one', 'two']\n        }\n      });\n    });\n\n    it('do not change a property if it already exists in the object', function() {\n      var object = { attrName1: 'attr1', attr_name_1: 'attr_1' };\n      var object2 = { attr_name_1: 'attr_1', attrName1: 'attr1' };\n      var newObject = objectHelper.toCamelCase(object, [], {\n        keepOriginal: true\n      });\n      var newObject2 = objectHelper.toCamelCase(object2, [], {\n        keepOriginal: true\n      });\n      expect(newObject).to.eql({ attrName1: 'attr1', attr_name_1: 'attr_1' });\n      expect(newObject2).to.eql({ attr_name_1: 'attr_1', attrName1: 'attr1' });\n    });\n  });\n  describe('getOriginFromUrl', function() {\n    it('should return undefined if there is no url', function() {\n      expect(objectHelper.getOriginFromUrl()).to.be(undefined);\n      expect(objectHelper.getOriginFromUrl('')).to.be(undefined);\n      expect(objectHelper.getOriginFromUrl(null)).to.be(undefined);\n    });\n    it('should use an anchor to parse the url and return the origin', function() {\n      var url = 'https://test.com/example';\n      expect(objectHelper.getOriginFromUrl(url)).to.be('https://test.com');\n    });\n    it('should use add the `port` when available', function() {\n      var url = 'https://localhost:3000/example';\n      expect(objectHelper.getOriginFromUrl(url)).to.be(\n        'https://localhost:3000'\n      );\n    });\n  });\n  describe('getLocationFromUrl', function() {\n    const mapping = {\n      'https://localhost:3000/foo?id=1': {\n        href: 'https://localhost:3000/foo?id=1',\n        protocol: 'https:',\n        host: 'localhost:3000',\n        hostname: 'localhost',\n        port: '3000',\n        pathname: '/foo',\n        search: '?id=1',\n        hash: ''\n      },\n      'https://auth0.com/foo': {\n        href: 'https://auth0.com/foo',\n        protocol: 'https:',\n        host: 'auth0.com',\n        hostname: 'auth0.com',\n        port: undefined,\n        pathname: '/foo',\n        search: '',\n        hash: ''\n      },\n      'https://auth0.com#access_token=foo': {\n        href: 'https://auth0.com#access_token=foo',\n        protocol: 'https:',\n        host: 'auth0.com',\n        hostname: 'auth0.com',\n        port: undefined,\n        pathname: '',\n        search: '',\n        hash: '#access_token=foo'\n      },\n      'file://electron-app/foo?id=1': {\n        href: 'file://electron-app/foo?id=1',\n        protocol: 'file:',\n        host: 'electron-app',\n        hostname: 'electron-app',\n        port: undefined,\n        pathname: '/foo',\n        search: '?id=1',\n        hash: ''\n      }\n    };\n    for (const url in mapping) {\n      it('should map urls correctly: ' + url, function() {\n        expect(objectHelper.getLocationFromUrl(url)).to.be.eql(mapping[url]);\n      });\n    }\n  });\n  describe('trimUserDetails', function() {\n    var options;\n    function getTrimmed() {\n      return objectHelper.trimUserDetails(options);\n    }\n    beforeEach(function() {\n      options = {\n        email: '   me@example.com   ',\n        phoneNumber: '   +16505555555   ',\n        username: '   johndoe   '\n      };\n    });\n    it('should trim the username, email, and phoneNumber in an options object', function() {\n      expect(getTrimmed()).to.eql({\n        email: 'me@example.com',\n        phoneNumber: '+16505555555',\n        username: 'johndoe'\n      });\n    });\n    it('should not mutate the original options object', function() {\n      expect(options)\n        .to.not.equal(getTrimmed())\n        .and.eql({\n          email: '   me@example.com   ',\n          phoneNumber: '   +16505555555   ',\n          username: '   johndoe   '\n        });\n    });\n    it('should only trim username & email--not other properties', function() {\n      options.otherAttribute = '   stay untrimmed my friend   ';\n      expect(getTrimmed()).to.eql({\n        email: 'me@example.com',\n        otherAttribute: '   stay untrimmed my friend   ',\n        phoneNumber: '+16505555555',\n        username: 'johndoe'\n      });\n    });\n    it('should not fail when username, email, and/or phoneNumber are absent', function() {\n      options = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      };\n      expect(getTrimmed()).to.eql(options);\n      options = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        username: '   johndoe   '\n      };\n      expect(getTrimmed()).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        username: 'johndoe'\n      });\n      options = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        email: '   email@example.com   '\n      };\n      expect(getTrimmed()).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        email: 'email@example.com'\n      });\n      options = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        phoneNumber: '   +16505555555   '\n      };\n      expect(getTrimmed()).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        phoneNumber: '+16505555555'\n      });\n    });\n  });\n});\n", "import expect from 'expect.js';\n\nimport responseHandler from '../../src/helper/response-handler';\n\ndescribe('helpers responseHandler', function() {\n  it('should return default error', function(done) {\n    responseHandler(function(err, data) {\n      expect(data).to.be(undefined);\n      expect(err).to.eql({\n        error: 'generic_error',\n        errorDescription: 'Something went wrong'\n      });\n      done();\n    })(null, null);\n  });\n\n  it('should return normalized format 1', function(done) {\n    var assert_err = {};\n    assert_err.response = {};\n    assert_err.response.statusCode = 400;\n    assert_err.response.statusText = 'Bad request';\n    assert_err.response.body = {\n      error: 'the_error_code',\n      policy: 'the policy',\n      error_description: 'The error description.',\n      name: 'SomeName'\n    };\n\n    responseHandler(function(err, data) {\n      expect(data).to.be(undefined);\n      expect(err).to.eql({\n        original: assert_err,\n        statusCode: 400,\n        statusText: 'Bad request',\n        code: 'the_error_code',\n        policy: 'the policy',\n        description: 'The error description.',\n        name: 'SomeName'\n      });\n      done();\n    })(assert_err, null);\n  });\n\n  it('should return normalized format 2', function(done) {\n    var assert_err = {};\n    assert_err.response = {};\n    assert_err.response.body = {\n      code: 'the_error_code',\n      description: 'The error description.'\n    };\n\n    responseHandler(function(err, data) {\n      expect(data).to.be(undefined);\n      expect(err).to.eql({\n        original: assert_err,\n        code: 'the_error_code',\n        description: 'The error description.'\n      });\n      done();\n    })(assert_err, null);\n  });\n\n  it('should return normalized format 3', function(done) {\n    var assert_err = {};\n    assert_err.response = {};\n    assert_err.response.body = {};\n\n    responseHandler(function(err, data) {\n      expect(data).to.be(undefined);\n      expect(err).to.eql({\n        original: assert_err,\n        code: null,\n        description: null\n      });\n      done();\n    })(assert_err, null);\n  });\n\n  it('should return normalized format 4', function(done) {\n    var assert_err = {};\n    assert_err.response = {};\n    assert_err.response.body = {\n      error_code: 'the_error_code',\n      error_description: 'The error description.'\n    };\n\n    responseHandler(function(err, data) {\n      expect(data).to.be(undefined);\n      expect(err).to.eql({\n        original: assert_err,\n        code: 'the_error_code',\n        description: 'The error description.'\n      });\n      done();\n    })(assert_err, null);\n  });\n\n  it('should return normalized format 4', function(done) {\n    var assert_err = {};\n    assert_err.err = {};\n    assert_err.err = {\n      status: 'the_error_code',\n      err: 'The error description.'\n    };\n\n    responseHandler(function(err, data) {\n      expect(data).to.be(undefined);\n      expect(err).to.eql({\n        original: assert_err,\n        code: 'the_error_code',\n        description: 'The error description.'\n      });\n      done();\n    })(assert_err, null);\n  });\n\n  it('should return normalized format 5 (error comes from data)', function(done) {\n    var assert_err = {\n      error: 'the_error_code',\n      errorDescription: 'The error description.'\n    };\n\n    responseHandler(function(err, data) {\n      expect(data).to.be(undefined);\n      expect(err).to.eql({\n        original: assert_err,\n        code: 'the_error_code',\n        description: 'The error description.'\n      });\n      done();\n    })(null, assert_err);\n  });\n\n  it('should return normalized format 6', function(done) {\n    var assert_err = {};\n    assert_err.response = {};\n    assert_err.response.body = {\n      code: 'the_error_code',\n      error: 'The error description.'\n    };\n\n    responseHandler(function(err, data) {\n      expect(data).to.be(undefined);\n      expect(err).to.eql({\n        original: assert_err,\n        code: 'the_error_code',\n        description: 'The error description.'\n      });\n      done();\n    })(assert_err, null);\n  });\n\n  it('should return normalized error codes and details', function(done) {\n    var assert_err = {};\n    assert_err.response = {};\n    assert_err.response.body = {\n      code: 'blocked_user',\n      error: 'Blocked user.',\n      error_codes: ['reason-1', 'reason-2'],\n      error_details: {\n        'reason-1': {\n          timestamp: 123\n        },\n        'reason-2': {\n          timestamp: 456\n        }\n      }\n    };\n\n    responseHandler(function(err, data) {\n      expect(data).to.be(undefined);\n\n      expect(err).to.eql({\n        original: assert_err,\n        code: 'blocked_user',\n        description: 'Blocked user.',\n        errorDetails: {\n          codes: ['reason-1', 'reason-2'],\n          details: {\n            'reason-1': {\n              timestamp: 123\n            },\n            'reason-2': {\n              timestamp: 456\n            }\n          }\n        }\n      });\n\n      done();\n    })(assert_err, null);\n  });\n\n  it('should return the data', function(done) {\n    var assert_data = {\n      body: {\n        attr1: 'attribute 1',\n        attr2: 'attribute 2'\n      }\n    };\n\n    responseHandler(function(err, data) {\n      expect(err).to.be(null);\n      expect(data).to.eql({\n        attr1: 'attribute 1',\n        attr2: 'attribute 2'\n      });\n      done();\n    })(null, assert_data);\n  });\n\n  it('should return the data 2', function(done) {\n    var assert_data = {\n      text: 'The response message',\n      type: 'text/html'\n    };\n\n    responseHandler(function(err, data) {\n      expect(err).to.be(null);\n      expect(data).to.eql('The response message');\n      done();\n    })(null, assert_data);\n  });\n\n  it('should return the data respecting the `keepOriginalCasing` option', function(done) {\n    var assert_data = {\n      body: {\n        the_attr: 'attr'\n      }\n    };\n\n    responseHandler(\n      function(err, data) {\n        expect(err).to.be(null);\n        expect(data).to.eql({\n          the_attr: 'attr',\n          theAttr: 'attr'\n        });\n        done();\n      },\n      { keepOriginalCasing: true }\n    )(null, assert_data);\n  });\n});\n"], "fixing_code": ["/* eslint-disable no-param-reassign */\n/* eslint-disable no-restricted-syntax */\n/* eslint-disable guard-for-in */\n\nimport assert from './assert';\nimport objectAssign from './object-assign';\n\nfunction pick(object, keys) {\n  return keys.reduce(function(prev, key) {\n    if (object[key]) {\n      prev[key] = object[key];\n    }\n    return prev;\n  }, {});\n}\n\nfunction getKeysNotIn(obj, allowedKeys) {\n  var notAllowed = [];\n  for (var key in obj) {\n    if (allowedKeys.indexOf(key) === -1) {\n      notAllowed.push(key);\n    }\n  }\n  return notAllowed;\n}\n\nfunction objectValues(obj) {\n  var values = [];\n  for (var key in obj) {\n    values.push(obj[key]);\n  }\n  return values;\n}\n\nfunction extend() {\n  var params = objectValues(arguments);\n  params.unshift({});\n  return objectAssign.get().apply(undefined, params);\n}\n\nfunction merge(object, keys) {\n  return {\n    base: keys ? pick(object, keys) : object,\n    with: function(object2, keys2) {\n      object2 = keys2 ? pick(object2, keys2) : object2;\n      return extend(this.base, object2);\n    }\n  };\n}\n\nfunction blacklist(object, blacklistedKeys) {\n  return Object.keys(object).reduce(function(p, key) {\n    if (blacklistedKeys.indexOf(key) === -1) {\n      p[key] = object[key];\n    }\n    return p;\n  }, {});\n}\n\nfunction camelToSnake(str) {\n  var newKey = '';\n  var index = 0;\n  var code;\n  var wasPrevNumber = true;\n  var wasPrevUppercase = true;\n\n  while (index < str.length) {\n    code = str.charCodeAt(index);\n    if (\n      (!wasPrevUppercase && code >= 65 && code <= 90) ||\n      (!wasPrevNumber && code >= 48 && code <= 57)\n    ) {\n      newKey += '_';\n      newKey += str[index].toLowerCase();\n    } else {\n      newKey += str[index].toLowerCase();\n    }\n    wasPrevNumber = code >= 48 && code <= 57;\n    wasPrevUppercase = code >= 65 && code <= 90;\n    index++;\n  }\n\n  return newKey;\n}\n\nfunction snakeToCamel(str) {\n  var parts = str.split('_');\n  return parts.reduce(function(p, c) {\n    return p + c.charAt(0).toUpperCase() + c.slice(1);\n  }, parts.shift());\n}\n\nfunction toSnakeCase(object, exceptions) {\n  if (typeof object !== 'object' || assert.isArray(object) || object === null) {\n    return object;\n  }\n  exceptions = exceptions || [];\n\n  return Object.keys(object).reduce(function(p, key) {\n    var newKey = exceptions.indexOf(key) === -1 ? camelToSnake(key) : key;\n    p[newKey] = toSnakeCase(object[key]);\n    return p;\n  }, {});\n}\n\nfunction toCamelCase(object, exceptions, options) {\n  if (typeof object !== 'object' || assert.isArray(object) || object === null) {\n    return object;\n  }\n\n  exceptions = exceptions || [];\n  options = options || {};\n  return Object.keys(object).reduce(function(p, key) {\n    var newKey = exceptions.indexOf(key) === -1 ? snakeToCamel(key) : key;\n\n    p[newKey] = toCamelCase(object[newKey] || object[key], [], options);\n\n    if (options.keepOriginal) {\n      p[key] = toCamelCase(object[key], [], options);\n    }\n    return p;\n  }, {});\n}\n\nfunction getLocationFromUrl(href) {\n  var match = href.match(\n    /^(https?:|file:|chrome-extension:)\\/\\/(([^:/?#]*)(?::([0-9]+))?)([/]{0,1}[^?#]*)(\\?[^#]*|)(#.*|)$/\n  );\n  return (\n    match && {\n      href: href,\n      protocol: match[1],\n      host: match[2],\n      hostname: match[3],\n      port: match[4],\n      pathname: match[5],\n      search: match[6],\n      hash: match[7]\n    }\n  );\n}\n\nfunction getOriginFromUrl(url) {\n  if (!url) {\n    return undefined;\n  }\n  var parsed = getLocationFromUrl(url);\n  var origin = parsed.protocol + '//' + parsed.hostname;\n  if (parsed.port) {\n    origin += ':' + parsed.port;\n  }\n  return origin;\n}\n\nfunction trim(options, key) {\n  var trimmed = extend(options);\n  if (options[key]) {\n    trimmed[key] = options[key].trim();\n  }\n  return trimmed;\n}\n\nfunction trimMultiple(options, keys) {\n  return keys.reduce(trim, options);\n}\n\nfunction trimUserDetails(options) {\n  return trimMultiple(options, ['username', 'email', 'phoneNumber']);\n}\n\n/**\n * Updates the value of a property on the given object, using a deep path selector.\n * @param {object} obj The object to set the property value on\n * @param {string|array} path The path to the property that should have its value updated. e.g. 'prop1.prop2.prop3' or ['prop1', 'prop2', 'prop3']\n * @param {any} value The value to set\n */\nfunction updatePropertyOn(obj, path, value) {\n  if (typeof path === 'string') {\n    path = path.split('.');\n  }\n\n  var next = path[0];\n\n  if (obj.hasOwnProperty(next)) {\n    if (path.length === 1) {\n      obj[next] = value;\n    } else {\n      updatePropertyOn(obj[next], path.slice(1), value);\n    }\n  }\n}\n\nexport default {\n  toSnakeCase: toSnakeCase,\n  toCamelCase: toCamelCase,\n  blacklist: blacklist,\n  merge: merge,\n  pick: pick,\n  getKeysNotIn: getKeysNotIn,\n  extend: extend,\n  getOriginFromUrl: getOriginFromUrl,\n  getLocationFromUrl: getLocationFromUrl,\n  trimUserDetails: trimUserDetails,\n  updatePropertyOn: updatePropertyOn\n};\n", "import error from './error';\nimport objectHelper from './object';\n\nfunction wrapCallback(cb, options) {\n  options = options || {};\n  options.ignoreCasing = options.ignoreCasing ? options.ignoreCasing : false;\n\n  return function(err, data) {\n    var errObj;\n\n    if (!err && !data) {\n      return cb(error.buildResponse('generic_error', 'Something went wrong'));\n    }\n\n    if (!err && data.err) {\n      err = data.err;\n      data = null;\n    }\n\n    if (!err && data.error) {\n      err = data;\n      data = null;\n    }\n\n    if (err) {\n      errObj = {\n        original: err\n      };\n\n      objectHelper.updatePropertyOn(\n        errObj,\n        'original.response.req._data.password',\n        '*****'\n      );\n\n      if (err.response && err.response.statusCode) {\n        errObj.statusCode = err.response.statusCode;\n      }\n\n      if (err.response && err.response.statusText) {\n        errObj.statusText = err.response.statusText;\n      }\n\n      if (err.response && err.response.body) {\n        err = err.response.body;\n      }\n\n      if (err.err) {\n        err = err.err;\n      }\n\n      errObj.code =\n        err.code || err.error || err.error_code || err.status || null;\n\n      errObj.description =\n        err.errorDescription ||\n        err.error_description ||\n        err.description ||\n        err.error ||\n        err.details ||\n        err.err ||\n        null;\n\n      if (options.forceLegacyError) {\n        errObj.error = errObj.code;\n        errObj.error_description = errObj.description;\n      }\n\n      if (err.error_codes && err.error_details) {\n        errObj.errorDetails = {\n          codes: err.error_codes,\n          details: err.error_details\n        };\n      }\n\n      if (err.name) {\n        errObj.name = err.name;\n      }\n\n      if (err.policy) {\n        errObj.policy = err.policy;\n      }\n\n      return cb(errObj);\n    }\n\n    if (\n      data.type &&\n      (data.type === 'text/html' || data.type === 'text/plain')\n    ) {\n      return cb(null, data.text);\n    }\n\n    if (options.ignoreCasing) {\n      return cb(null, data.body || data);\n    }\n\n    return cb(\n      null,\n      objectHelper.toCamelCase(data.body || data, [], {\n        keepOriginal: options.keepOriginalCasing\n      })\n    );\n  };\n}\n\nexport default wrapCallback;\n", "import expect from 'expect.js';\nimport sinon from 'sinon';\n\nimport objectAssign from '../../src/helper/object-assign';\nimport objectHelper from '../../src/helper/object';\nimport windowHelper from '../../src/helper/window';\n\ndescribe('helpers', function() {\n  describe('getKeysNotIn', function() {\n    it('should return the list of keys not allowed', function() {\n      var object = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      };\n\n      var notAllowed = ['attr1', 'attr2', 'attr4'];\n\n      var keysList = objectHelper.getKeysNotIn(object, notAllowed);\n\n      expect(keysList).to.eql(['attr3']);\n    });\n\n    it('should return an empty list', function() {\n      var object = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      };\n\n      var notAllowed = ['attr1', 'attr2', 'attr3'];\n\n      var keysList = objectHelper.getKeysNotIn(object, notAllowed);\n\n      expect(keysList).to.eql([]);\n    });\n\n    it('should return an all the keys', function() {\n      var object = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      };\n\n      var notAllowed = ['attr5', 'attr6', 'attr7'];\n\n      var keysList = objectHelper.getKeysNotIn(object, notAllowed);\n\n      expect(keysList).to.eql(['attr1', 'attr2', 'attr3']);\n    });\n\n    it('should return another empty list', function() {\n      var object = {};\n\n      var notAllowed = ['attr5', 'attr6', 'attr7'];\n\n      var keysList = objectHelper.getKeysNotIn(object, notAllowed);\n\n      expect(keysList).to.eql([]);\n    });\n  });\n\n  describe('pick', function() {\n    it('should return only the requested attributes', function() {\n      var object = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      };\n\n      var newObject = objectHelper.pick(object, ['attr1', 'attr2']);\n\n      expect(newObject).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2'\n      });\n\n      expect(object).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      });\n    });\n\n    it('should ignore missing keys', function() {\n      var object = {\n        attr1: 'attribute_1',\n        attr3: 'attribute_3'\n      };\n\n      var newObject = objectHelper.pick(object, ['attr1', 'attr2']);\n\n      expect(newObject).to.eql({\n        attr1: 'attribute_1'\n      });\n\n      expect(object).to.eql({\n        attr1: 'attribute_1',\n        attr3: 'attribute_3'\n      });\n    });\n  });\n\n  describe('extend', function() {\n    it('should merge objects attributes', function() {\n      var object1 = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2'\n      };\n\n      var object2 = {\n        attr3: 'attribute_3'\n      };\n\n      var newObject = objectHelper.extend(object1, object2);\n\n      expect(newObject).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      });\n\n      expect(object1).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2'\n      });\n\n      expect(object2).to.eql({\n        attr3: 'attribute_3'\n      });\n    });\n\n    it('shold merge objects attributes with polyfill', function() {\n      sinon.stub(objectAssign, 'get').callsFake(function() {\n        return objectAssign.objectAssignPolyfill;\n      });\n\n      var object1 = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2'\n      };\n\n      var object2 = {\n        attr3: 'attribute_3'\n      };\n\n      var newObject = objectHelper.extend(object1, object2);\n\n      expect(newObject).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      });\n\n      expect(object1).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2'\n      });\n\n      expect(object2).to.eql({\n        attr3: 'attribute_3'\n      });\n\n      objectAssign.get.restore();\n    });\n\n    it('shold merge objects attributes and override the first object ones', function() {\n      var object1 = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2'\n      };\n\n      var object2 = {\n        attr2: 'attribute_2_2',\n        attr3: 'attribute_3'\n      };\n\n      var newObject = objectHelper.extend(object1, object2);\n\n      expect(newObject).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2_2',\n        attr3: 'attribute_3'\n      });\n\n      expect(object1).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2'\n      });\n\n      expect(object2).to.eql({\n        attr2: 'attribute_2_2',\n        attr3: 'attribute_3'\n      });\n    });\n  });\n\n  describe('merge', function() {\n    it('shold merge without pick', function() {\n      var object1 = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      };\n\n      var object2 = {\n        attrA: 'attribute_A',\n        attrB: 'attribute_B',\n        attrC: 'attribute_C'\n      };\n\n      var newObject = objectHelper.merge(object1).with(object2);\n\n      expect(newObject).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3',\n        attrA: 'attribute_A',\n        attrB: 'attribute_B',\n        attrC: 'attribute_C'\n      });\n\n      expect(object1).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      });\n\n      expect(object2).to.eql({\n        attrA: 'attribute_A',\n        attrB: 'attribute_B',\n        attrC: 'attribute_C'\n      });\n    });\n\n    it('shold merge picking attributes of the base object', function() {\n      var object1 = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      };\n\n      var object2 = {\n        attrA: 'attribute_A',\n        attrB: 'attribute_B',\n        attrC: 'attribute_C'\n      };\n\n      var newObject = objectHelper\n        .merge(object1, ['attr1', 'attr2'])\n        .with(object2);\n\n      expect(newObject).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attrA: 'attribute_A',\n        attrB: 'attribute_B',\n        attrC: 'attribute_C'\n      });\n\n      expect(object1).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      });\n\n      expect(object2).to.eql({\n        attrA: 'attribute_A',\n        attrB: 'attribute_B',\n        attrC: 'attribute_C'\n      });\n    });\n\n    it('shold merge picking attributes of the second object', function() {\n      var object1 = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      };\n\n      var object2 = {\n        attrA: 'attribute_A',\n        attrB: 'attribute_B',\n        attrC: 'attribute_C'\n      };\n\n      var newObject = objectHelper\n        .merge(object1)\n        .with(object2, ['attrA', 'attrC']);\n\n      expect(newObject).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3',\n        attrA: 'attribute_A',\n        attrC: 'attribute_C'\n      });\n\n      expect(object1).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      });\n\n      expect(object2).to.eql({\n        attrA: 'attribute_A',\n        attrB: 'attribute_B',\n        attrC: 'attribute_C'\n      });\n    });\n\n    it('should merge picking attributes of both objects', function() {\n      var object1 = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      };\n\n      var object2 = {\n        attrA: 'attribute_A',\n        attrB: 'attribute_B',\n        attrC: 'attribute_C'\n      };\n\n      var newObject = objectHelper\n        .merge(object1, ['attr2', 'attr3'])\n        .with(object2, ['attrA', 'attrC']);\n\n      expect(newObject).to.eql({\n        attr2: 'attribute_2',\n        attr3: 'attribute_3',\n        attrA: 'attribute_A',\n        attrC: 'attribute_C'\n      });\n\n      expect(object1).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      });\n\n      expect(object2).to.eql({\n        attrA: 'attribute_A',\n        attrB: 'attribute_B',\n        attrC: 'attribute_C'\n      });\n    });\n  });\n\n  describe('blacklist', function() {\n    it('should return all the attributes not blacklisted', function() {\n      var object = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      };\n\n      var newObject = objectHelper.blacklist(object, ['attr1', 'attr2']);\n\n      expect(newObject).to.eql({\n        attr3: 'attribute_3'\n      });\n\n      expect(object).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      });\n    });\n  });\n\n  describe('toSnakeCase', function() {\n    it('should change the casing to all the attributes', function() {\n      var object = {\n        attrName1: 'attribute_1',\n        attrName22: 'attribute_2',\n        attrNAME3: 'attribute_3',\n        attrNULL: null,\n        arrayAtt: ['one', 'two'],\n        someObj: {\n          objAtt1: 'asd',\n          objAtt2: '123',\n          innerArrayAtt: ['one', 'two']\n        }\n      };\n\n      var newObject = objectHelper.toSnakeCase(object);\n\n      expect(object).to.eql({\n        attrName1: 'attribute_1',\n        attrName22: 'attribute_2',\n        attrNAME3: 'attribute_3',\n        attrNULL: null,\n        arrayAtt: ['one', 'two'],\n        someObj: {\n          objAtt1: 'asd',\n          objAtt2: '123',\n          innerArrayAtt: ['one', 'two']\n        }\n      });\n\n      expect(newObject.array_att).to.be.an('array');\n      expect(newObject.some_obj.inner_array_att).to.be.an('array');\n\n      expect(newObject).to.eql({\n        attr_name_1: 'attribute_1',\n        attr_name_22: 'attribute_2',\n        attr_name_3: 'attribute_3',\n        attr_null: null,\n        array_att: ['one', 'two'],\n        some_obj: {\n          obj_att_1: 'asd',\n          obj_att_2: '123',\n          inner_array_att: ['one', 'two']\n        }\n      });\n    });\n\n    it('should change the casing to all the attributes that are not blacklisted', function() {\n      var object = {\n        attrName1: 'attribute_1',\n        attrName22: 'attribute_2',\n        attrNAME3: 'attribute_3'\n      };\n\n      var newObject = objectHelper.toSnakeCase(object, ['attrName22']);\n\n      expect(object).to.eql({\n        attrName1: 'attribute_1',\n        attrName22: 'attribute_2',\n        attrNAME3: 'attribute_3'\n      });\n\n      expect(newObject).to.eql({\n        attr_name_1: 'attribute_1',\n        attrName22: 'attribute_2',\n        attr_name_3: 'attribute_3'\n      });\n    });\n  });\n\n  describe('toCamelCase', function() {\n    it('should change the casing to all the attributes', function() {\n      var object = {\n        attr_name_1: 'attribute_1',\n        attr_name_22: 'attribute_2',\n        attr__name_3: 'attribute_3',\n        attr_null: null,\n        arr_att: ['one', 'two'],\n        some_obj: {\n          obj_att_1: 'asdf',\n          obj_att_2: '1234',\n          inner_array_att: ['one', 'two']\n        }\n      };\n\n      var newObject = objectHelper.toCamelCase(object);\n\n      expect(newObject).to.eql({\n        attrName1: 'attribute_1',\n        attrName22: 'attribute_2',\n        attrName3: 'attribute_3',\n        attrNull: null,\n        arrAtt: ['one', 'two'],\n        someObj: {\n          objAtt1: 'asdf',\n          objAtt2: '1234',\n          innerArrayAtt: ['one', 'two']\n        }\n      });\n    });\n\n    it('should not break the string', function() {\n      var object = 'some random string';\n\n      var newObject = objectHelper.toCamelCase(object);\n\n      expect(object).to.eql('some random string');\n\n      expect(newObject).to.be.a('string');\n\n      expect(newObject).to.eql('some random string');\n    });\n\n    it('should change the casing to all the attributes that are not blacklisted', function() {\n      var object = {\n        attr_name_1: 'attribute_1',\n        attr_name_22: 'attribute_2',\n        attr__name_3: 'attribute_3'\n      };\n\n      var newObject = objectHelper.toCamelCase(object, ['attr_name_22']);\n\n      expect(object).to.eql({\n        attr_name_1: 'attribute_1',\n        attr_name_22: 'attribute_2',\n        attr__name_3: 'attribute_3'\n      });\n\n      expect(newObject).to.eql({\n        attrName1: 'attribute_1',\n        attr_name_22: 'attribute_2',\n        attrName3: 'attribute_3'\n      });\n    });\n\n    it('should keep original property as well', function() {\n      var object = {\n        attr_name_1: 'attribute_1',\n        attr_name_22: 'attribute_2',\n        attr__name_3: 'attribute_3',\n        attr_null: null,\n        arr_att: ['one', 'two'],\n        some_obj: {\n          obj_att_1: 'asdf',\n          obj_att_2: '1234',\n          inner_array_att: ['one', 'two']\n        }\n      };\n\n      var newObject = objectHelper.toCamelCase(object, [], {\n        keepOriginal: true\n      });\n\n      expect(newObject).to.eql({\n        attrName1: 'attribute_1',\n        attr_name_1: 'attribute_1',\n        attrName22: 'attribute_2',\n        attr_name_22: 'attribute_2',\n        attrName3: 'attribute_3',\n        attr__name_3: 'attribute_3',\n        attrNull: null,\n        attr_null: null,\n        arrAtt: ['one', 'two'],\n        arr_att: ['one', 'two'],\n        someObj: {\n          objAtt1: 'asdf',\n          obj_att_1: 'asdf',\n          objAtt2: '1234',\n          obj_att_2: '1234',\n          innerArrayAtt: ['one', 'two'],\n          inner_array_att: ['one', 'two']\n        },\n        some_obj: {\n          objAtt1: 'asdf',\n          obj_att_1: 'asdf',\n          objAtt2: '1234',\n          obj_att_2: '1234',\n          innerArrayAtt: ['one', 'two'],\n          inner_array_att: ['one', 'two']\n        }\n      });\n    });\n\n    it('do not change a property if it already exists in the object', function() {\n      var object = { attrName1: 'attr1', attr_name_1: 'attr_1' };\n      var object2 = { attr_name_1: 'attr_1', attrName1: 'attr1' };\n      var newObject = objectHelper.toCamelCase(object, [], {\n        keepOriginal: true\n      });\n      var newObject2 = objectHelper.toCamelCase(object2, [], {\n        keepOriginal: true\n      });\n      expect(newObject).to.eql({ attrName1: 'attr1', attr_name_1: 'attr_1' });\n      expect(newObject2).to.eql({ attr_name_1: 'attr_1', attrName1: 'attr1' });\n    });\n  });\n  describe('getOriginFromUrl', function() {\n    it('should return undefined if there is no url', function() {\n      expect(objectHelper.getOriginFromUrl()).to.be(undefined);\n      expect(objectHelper.getOriginFromUrl('')).to.be(undefined);\n      expect(objectHelper.getOriginFromUrl(null)).to.be(undefined);\n    });\n    it('should use an anchor to parse the url and return the origin', function() {\n      var url = 'https://test.com/example';\n      expect(objectHelper.getOriginFromUrl(url)).to.be('https://test.com');\n    });\n    it('should use add the `port` when available', function() {\n      var url = 'https://localhost:3000/example';\n      expect(objectHelper.getOriginFromUrl(url)).to.be(\n        'https://localhost:3000'\n      );\n    });\n  });\n  describe('getLocationFromUrl', function() {\n    const mapping = {\n      'https://localhost:3000/foo?id=1': {\n        href: 'https://localhost:3000/foo?id=1',\n        protocol: 'https:',\n        host: 'localhost:3000',\n        hostname: 'localhost',\n        port: '3000',\n        pathname: '/foo',\n        search: '?id=1',\n        hash: ''\n      },\n      'https://auth0.com/foo': {\n        href: 'https://auth0.com/foo',\n        protocol: 'https:',\n        host: 'auth0.com',\n        hostname: 'auth0.com',\n        port: undefined,\n        pathname: '/foo',\n        search: '',\n        hash: ''\n      },\n      'https://auth0.com#access_token=foo': {\n        href: 'https://auth0.com#access_token=foo',\n        protocol: 'https:',\n        host: 'auth0.com',\n        hostname: 'auth0.com',\n        port: undefined,\n        pathname: '',\n        search: '',\n        hash: '#access_token=foo'\n      },\n      'file://electron-app/foo?id=1': {\n        href: 'file://electron-app/foo?id=1',\n        protocol: 'file:',\n        host: 'electron-app',\n        hostname: 'electron-app',\n        port: undefined,\n        pathname: '/foo',\n        search: '?id=1',\n        hash: ''\n      }\n    };\n    for (const url in mapping) {\n      it('should map urls correctly: ' + url, function() {\n        expect(objectHelper.getLocationFromUrl(url)).to.be.eql(mapping[url]);\n      });\n    }\n  });\n  describe('trimUserDetails', function() {\n    var options;\n    function getTrimmed() {\n      return objectHelper.trimUserDetails(options);\n    }\n    beforeEach(function() {\n      options = {\n        email: '   me@example.com   ',\n        phoneNumber: '   +16505555555   ',\n        username: '   johndoe   '\n      };\n    });\n    it('should trim the username, email, and phoneNumber in an options object', function() {\n      expect(getTrimmed()).to.eql({\n        email: 'me@example.com',\n        phoneNumber: '+16505555555',\n        username: 'johndoe'\n      });\n    });\n    it('should not mutate the original options object', function() {\n      expect(options)\n        .to.not.equal(getTrimmed())\n        .and.eql({\n          email: '   me@example.com   ',\n          phoneNumber: '   +16505555555   ',\n          username: '   johndoe   '\n        });\n    });\n    it('should only trim username & email--not other properties', function() {\n      options.otherAttribute = '   stay untrimmed my friend   ';\n      expect(getTrimmed()).to.eql({\n        email: 'me@example.com',\n        otherAttribute: '   stay untrimmed my friend   ',\n        phoneNumber: '+16505555555',\n        username: 'johndoe'\n      });\n    });\n    it('should not fail when username, email, and/or phoneNumber are absent', function() {\n      options = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        attr3: 'attribute_3'\n      };\n      expect(getTrimmed()).to.eql(options);\n      options = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        username: '   johndoe   '\n      };\n      expect(getTrimmed()).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        username: 'johndoe'\n      });\n      options = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        email: '   email@example.com   '\n      };\n      expect(getTrimmed()).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        email: 'email@example.com'\n      });\n      options = {\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        phoneNumber: '   +16505555555   '\n      };\n      expect(getTrimmed()).to.eql({\n        attr1: 'attribute_1',\n        attr2: 'attribute_2',\n        phoneNumber: '+16505555555'\n      });\n    });\n  });\n\n  describe('setPropertyValue', function() {\n    it('can set a property at the first level of the object', function() {\n      var obj = {\n        one: 1,\n        two: 2,\n        three: 3\n      };\n\n      objectHelper.updatePropertyOn(obj, 'one', 'one');\n\n      expect(obj).to.eql({\n        one: 'one',\n        two: 2,\n        three: 3\n      });\n    });\n\n    it('can set a nested property', function() {\n      var obj = {\n        one: {\n          two: {\n            three: 3\n          }\n        }\n      };\n\n      objectHelper.updatePropertyOn(obj, 'one.two.three', 'three');\n\n      expect(obj).to.eql({\n        one: {\n          two: {\n            three: 'three'\n          }\n        }\n      });\n    });\n\n    it(\"does not add new values if the key doesn't already exist\", function() {\n      var obj = {\n        one: {\n          two: {\n            three: 3\n          }\n        }\n      };\n\n      objectHelper.updatePropertyOn(obj, 'one.two.four', 4);\n\n      expect(obj).to.eql({\n        one: {\n          two: {\n            three: 3\n          }\n        }\n      });\n    });\n  });\n});\n", "import expect from 'expect.js';\n\nimport responseHandler from '../../src/helper/response-handler';\n\ndescribe('helpers responseHandler', function() {\n  it('should return default error', function(done) {\n    responseHandler(function(err, data) {\n      expect(data).to.be(undefined);\n      expect(err).to.eql({\n        error: 'generic_error',\n        errorDescription: 'Something went wrong'\n      });\n      done();\n    })(null, null);\n  });\n\n  it('should return normalized format 1', function(done) {\n    var assert_err = {};\n    assert_err.response = {};\n    assert_err.response.statusCode = 400;\n    assert_err.response.statusText = 'Bad request';\n    assert_err.response.body = {\n      error: 'the_error_code',\n      policy: 'the policy',\n      error_description: 'The error description.',\n      name: 'SomeName'\n    };\n\n    responseHandler(function(err, data) {\n      expect(data).to.be(undefined);\n      expect(err).to.eql({\n        original: assert_err,\n        statusCode: 400,\n        statusText: 'Bad request',\n        code: 'the_error_code',\n        policy: 'the policy',\n        description: 'The error description.',\n        name: 'SomeName'\n      });\n      done();\n    })(assert_err, null);\n  });\n\n  it('should return normalized format 2', function(done) {\n    var assert_err = {};\n    assert_err.response = {};\n    assert_err.response.body = {\n      code: 'the_error_code',\n      description: 'The error description.'\n    };\n\n    responseHandler(function(err, data) {\n      expect(data).to.be(undefined);\n      expect(err).to.eql({\n        original: assert_err,\n        code: 'the_error_code',\n        description: 'The error description.'\n      });\n      done();\n    })(assert_err, null);\n  });\n\n  it('should return normalized format 3', function(done) {\n    var assert_err = {};\n    assert_err.response = {};\n    assert_err.response.body = {};\n\n    responseHandler(function(err, data) {\n      expect(data).to.be(undefined);\n      expect(err).to.eql({\n        original: assert_err,\n        code: null,\n        description: null\n      });\n      done();\n    })(assert_err, null);\n  });\n\n  it('should return normalized format 4', function(done) {\n    var assert_err = {};\n    assert_err.response = {};\n    assert_err.response.body = {\n      error_code: 'the_error_code',\n      error_description: 'The error description.'\n    };\n\n    responseHandler(function(err, data) {\n      expect(data).to.be(undefined);\n      expect(err).to.eql({\n        original: assert_err,\n        code: 'the_error_code',\n        description: 'The error description.'\n      });\n      done();\n    })(assert_err, null);\n  });\n\n  it('should return normalized format 4', function(done) {\n    var assert_err = {};\n    assert_err.err = {};\n    assert_err.err = {\n      status: 'the_error_code',\n      err: 'The error description.'\n    };\n\n    responseHandler(function(err, data) {\n      expect(data).to.be(undefined);\n      expect(err).to.eql({\n        original: assert_err,\n        code: 'the_error_code',\n        description: 'The error description.'\n      });\n      done();\n    })(assert_err, null);\n  });\n\n  it('should return normalized format 5 (error comes from data)', function(done) {\n    var assert_err = {\n      error: 'the_error_code',\n      errorDescription: 'The error description.'\n    };\n\n    responseHandler(function(err, data) {\n      expect(data).to.be(undefined);\n      expect(err).to.eql({\n        original: assert_err,\n        code: 'the_error_code',\n        description: 'The error description.'\n      });\n      done();\n    })(null, assert_err);\n  });\n\n  it('should return normalized format 6', function(done) {\n    var assert_err = {};\n    assert_err.response = {};\n    assert_err.response.body = {\n      code: 'the_error_code',\n      error: 'The error description.'\n    };\n\n    responseHandler(function(err, data) {\n      expect(data).to.be(undefined);\n      expect(err).to.eql({\n        original: assert_err,\n        code: 'the_error_code',\n        description: 'The error description.'\n      });\n      done();\n    })(assert_err, null);\n  });\n\n  it('should return normalized error codes and details', function(done) {\n    var assert_err = {};\n    assert_err.response = {};\n    assert_err.response.body = {\n      code: 'blocked_user',\n      error: 'Blocked user.',\n      error_codes: ['reason-1', 'reason-2'],\n      error_details: {\n        'reason-1': {\n          timestamp: 123\n        },\n        'reason-2': {\n          timestamp: 456\n        }\n      }\n    };\n\n    responseHandler(function(err, data) {\n      expect(data).to.be(undefined);\n\n      expect(err).to.eql({\n        original: assert_err,\n        code: 'blocked_user',\n        description: 'Blocked user.',\n        errorDetails: {\n          codes: ['reason-1', 'reason-2'],\n          details: {\n            'reason-1': {\n              timestamp: 123\n            },\n            'reason-2': {\n              timestamp: 456\n            }\n          }\n        }\n      });\n\n      done();\n    })(assert_err, null);\n  });\n\n  it('should return the data', function(done) {\n    var assert_data = {\n      body: {\n        attr1: 'attribute 1',\n        attr2: 'attribute 2'\n      }\n    };\n\n    responseHandler(function(err, data) {\n      expect(err).to.be(null);\n      expect(data).to.eql({\n        attr1: 'attribute 1',\n        attr2: 'attribute 2'\n      });\n      done();\n    })(null, assert_data);\n  });\n\n  it('should return the data 2', function(done) {\n    var assert_data = {\n      text: 'The response message',\n      type: 'text/html'\n    };\n\n    responseHandler(function(err, data) {\n      expect(err).to.be(null);\n      expect(data).to.eql('The response message');\n      done();\n    })(null, assert_data);\n  });\n\n  it('should return the data respecting the `keepOriginalCasing` option', function(done) {\n    var assert_data = {\n      body: {\n        the_attr: 'attr'\n      }\n    };\n\n    responseHandler(\n      function(err, data) {\n        expect(err).to.be(null);\n        expect(data).to.eql({\n          the_attr: 'attr',\n          theAttr: 'attr'\n        });\n        done();\n      },\n      { keepOriginalCasing: true }\n    )(null, assert_data);\n  });\n\n  it('should mask the password object in the original response object', function(done) {\n    var assert_err = {\n      code: 'the_error_code',\n      error: 'The error description.',\n      response: {\n        req: {\n          _data: {\n            realm: 'realm',\n            client_id: 'client_id',\n            username: 'username',\n            password: 'this is a password'\n          }\n        }\n      }\n    };\n\n    responseHandler(function(err, data) {\n      expect(data).to.be(undefined);\n\n      expect(err).to.eql({\n        original: {\n          code: 'the_error_code',\n          error: 'The error description.',\n          response: {\n            req: {\n              _data: {\n                realm: 'realm',\n                client_id: 'client_id',\n                username: 'username',\n                password: '*****'\n              }\n            }\n          }\n        },\n        code: 'the_error_code',\n        description: 'The error description.'\n      });\n\n      done();\n    })(assert_err, null);\n  });\n\n  it('should mask the password object in the data object', function(done) {\n    var assert_err = {\n      code: 'the_error_code',\n      error: 'The error description.',\n      response: {\n        req: {\n          _data: {\n            realm: 'realm',\n            client_id: 'client_id',\n            username: 'username',\n            password: 'this is a password'\n          }\n        }\n      }\n    };\n\n    responseHandler(function(err, data) {\n      expect(data).to.be(undefined);\n\n      expect(err).to.eql({\n        original: {\n          code: 'the_error_code',\n          error: 'The error description.',\n          response: {\n            req: {\n              _data: {\n                realm: 'realm',\n                client_id: 'client_id',\n                username: 'username',\n                password: '*****'\n              }\n            }\n          }\n        },\n        code: 'the_error_code',\n        description: 'The error description.'\n      });\n\n      done();\n    })(assert_err, null);\n  });\n});\n"], "filenames": ["src/helper/object.js", "src/helper/response-handler.js", "test/helper/object.test.js", "test/helper/response-handler.test.js"], "buggy_code_start_loc": [170, 28, 709, 243], "buggy_code_end_loc": [182, 28, 709, 243], "fixing_code_start_loc": [171, 29, 710, 244], "fixing_code_end_loc": [205, 35, 768, 328], "type": "CWE-522", "message": "auth0.js (NPM package auth0-js) greater than version 8.0.0 and before version 9.12.3 has a vulnerability. In the case of an (authentication) error, the error object returned by the library contains the original request of the user, which may include the plaintext password the user entered. If the error object is exposed or logged without modification, the application risks password exposure. This is fixed in version 9.12.3", "other": {"cve": {"id": "CVE-2020-5263", "sourceIdentifier": "security-advisories@github.com", "published": "2020-04-09T16:15:12.160", "lastModified": "2020-04-10T13:25:15.837", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "auth0.js (NPM package auth0-js) greater than version 8.0.0 and before version 9.12.3 has a vulnerability. In the case of an (authentication) error, the error object returned by the library contains the original request of the user, which may include the plaintext password the user entered. If the error object is exposed or logged without modification, the application risks password exposure. This is fixed in version 9.12.3"}, {"lang": "es", "value": "auth0.js (paquete NPM auth0-js) versiones superiores a 8.0.0 y versiones anteriores 9.12.3, presenta una vulnerabilidad. En el caso de un error de (autenticaci\u00f3n), el objeto del error devuelto por la biblioteca contiene la petici\u00f3n original del usuario, que puede incluir la contrase\u00f1a de texto plano que ingres\u00f3 el usuario. Si el objeto de error se expone o registra sin modificaci\u00f3n, la aplicaci\u00f3n corre el riesgo de exponer la contrase\u00f1a. Esto es corregido en la versi\u00f3n 9.12.3"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:R/S:C/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.1, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-522"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-522"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:auth0:auth0.js:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0.0", "versionEndIncluding": "9.13.1", "matchCriteriaId": "610E2D65-C419-40AD-B656-4F4E241E61D0"}]}]}], "references": [{"url": "https://github.com/auth0/auth0.js/commit/355ca749b229fb93142f0b3978399b248d710828", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/auth0/auth0.js/security/advisories/GHSA-prfq-f66g-43mp", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/auth0/auth0.js/commit/355ca749b229fb93142f0b3978399b248d710828"}}