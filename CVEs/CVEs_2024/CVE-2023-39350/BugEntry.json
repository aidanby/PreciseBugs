{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RemoteFX Codec Library\n *\n * Copyright 2011 Vic Lee\n * Copyright 2015 Thincast Technologies GmbH\n * Copyright 2015 Norbert Federa <norbert.federa@thincast.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <freerdp/config.h>\n\n#include <winpr/assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/crt.h>\n#include <winpr/tchar.h>\n#include <winpr/sysinfo.h>\n#include <winpr/registry.h>\n#include <winpr/tchar.h>\n\n#include <freerdp/log.h>\n#include <freerdp/settings.h>\n#include <freerdp/codec/rfx.h>\n#include <freerdp/constants.h>\n#include <freerdp/primitives.h>\n#include <freerdp/codec/region.h>\n#include <freerdp/build-config.h>\n#include <freerdp/codec/region.h>\n\n#include \"rfx_constants.h\"\n#include \"rfx_types.h\"\n#include \"rfx_decode.h\"\n#include \"rfx_encode.h\"\n#include \"rfx_quantization.h\"\n#include \"rfx_dwt.h\"\n#include \"rfx_rlgr.h\"\n\n#include \"rfx_sse2.h\"\n#include \"rfx_neon.h\"\n\n#define TAG FREERDP_TAG(\"codec\")\n\n#ifndef RFX_INIT_SIMD\n#define RFX_INIT_SIMD(_rfx_context) \\\n\tdo                              \\\n\t{                               \\\n\t} while (0)\n#endif\n\n#define RFX_KEY \"Software\\\\\" FREERDP_VENDOR_STRING \"\\\\\" FREERDP_PRODUCT_STRING \"\\\\RemoteFX\"\n\n/**\n * The quantization values control the compression rate and quality. The value\n * range is between 6 and 15. The higher value, the higher compression rate\n * and lower quality.\n *\n * This is the default values being use by the MS RDP server, and we will also\n * use it as our default values for the encoder. It can be overrided by setting\n * the context->num_quants and context->quants member.\n *\n * The order of the values are:\n * LL3, LH3, HL3, HH3, LH2, HL2, HH2, LH1, HL1, HH1\n */\nstatic const UINT32 rfx_default_quantization_values[] = { 6, 6, 6, 6, 7, 7, 8, 8, 8, 9 };\n\nstatic void rfx_profiler_create(RFX_CONTEXT* context)\n{\n\tif (!context || !context->priv)\n\t\treturn;\n\tPROFILER_CREATE(context->priv->prof_rfx_decode_rgb, \"rfx_decode_rgb\")\n\tPROFILER_CREATE(context->priv->prof_rfx_decode_component, \"rfx_decode_component\")\n\tPROFILER_CREATE(context->priv->prof_rfx_rlgr_decode, \"rfx_rlgr_decode\")\n\tPROFILER_CREATE(context->priv->prof_rfx_differential_decode, \"rfx_differential_decode\")\n\tPROFILER_CREATE(context->priv->prof_rfx_quantization_decode, \"rfx_quantization_decode\")\n\tPROFILER_CREATE(context->priv->prof_rfx_dwt_2d_decode, \"rfx_dwt_2d_decode\")\n\tPROFILER_CREATE(context->priv->prof_rfx_ycbcr_to_rgb, \"prims->yCbCrToRGB\")\n\tPROFILER_CREATE(context->priv->prof_rfx_encode_rgb, \"rfx_encode_rgb\")\n\tPROFILER_CREATE(context->priv->prof_rfx_encode_component, \"rfx_encode_component\")\n\tPROFILER_CREATE(context->priv->prof_rfx_rlgr_encode, \"rfx_rlgr_encode\")\n\tPROFILER_CREATE(context->priv->prof_rfx_differential_encode, \"rfx_differential_encode\")\n\tPROFILER_CREATE(context->priv->prof_rfx_quantization_encode, \"rfx_quantization_encode\")\n\tPROFILER_CREATE(context->priv->prof_rfx_dwt_2d_encode, \"rfx_dwt_2d_encode\")\n\tPROFILER_CREATE(context->priv->prof_rfx_rgb_to_ycbcr, \"prims->RGBToYCbCr\")\n\tPROFILER_CREATE(context->priv->prof_rfx_encode_format_rgb, \"rfx_encode_format_rgb\")\n}\n\nstatic void rfx_profiler_free(RFX_CONTEXT* context)\n{\n\tif (!context || !context->priv)\n\t\treturn;\n\tPROFILER_FREE(context->priv->prof_rfx_decode_rgb)\n\tPROFILER_FREE(context->priv->prof_rfx_decode_component)\n\tPROFILER_FREE(context->priv->prof_rfx_rlgr_decode)\n\tPROFILER_FREE(context->priv->prof_rfx_differential_decode)\n\tPROFILER_FREE(context->priv->prof_rfx_quantization_decode)\n\tPROFILER_FREE(context->priv->prof_rfx_dwt_2d_decode)\n\tPROFILER_FREE(context->priv->prof_rfx_ycbcr_to_rgb)\n\tPROFILER_FREE(context->priv->prof_rfx_encode_rgb)\n\tPROFILER_FREE(context->priv->prof_rfx_encode_component)\n\tPROFILER_FREE(context->priv->prof_rfx_rlgr_encode)\n\tPROFILER_FREE(context->priv->prof_rfx_differential_encode)\n\tPROFILER_FREE(context->priv->prof_rfx_quantization_encode)\n\tPROFILER_FREE(context->priv->prof_rfx_dwt_2d_encode)\n\tPROFILER_FREE(context->priv->prof_rfx_rgb_to_ycbcr)\n\tPROFILER_FREE(context->priv->prof_rfx_encode_format_rgb)\n}\n\nstatic void rfx_profiler_print(RFX_CONTEXT* context)\n{\n\tif (!context || !context->priv)\n\t\treturn;\n\n\tPROFILER_PRINT_HEADER\n\tPROFILER_PRINT(context->priv->prof_rfx_decode_rgb)\n\tPROFILER_PRINT(context->priv->prof_rfx_decode_component)\n\tPROFILER_PRINT(context->priv->prof_rfx_rlgr_decode)\n\tPROFILER_PRINT(context->priv->prof_rfx_differential_decode)\n\tPROFILER_PRINT(context->priv->prof_rfx_quantization_decode)\n\tPROFILER_PRINT(context->priv->prof_rfx_dwt_2d_decode)\n\tPROFILER_PRINT(context->priv->prof_rfx_ycbcr_to_rgb)\n\tPROFILER_PRINT(context->priv->prof_rfx_encode_rgb)\n\tPROFILER_PRINT(context->priv->prof_rfx_encode_component)\n\tPROFILER_PRINT(context->priv->prof_rfx_rlgr_encode)\n\tPROFILER_PRINT(context->priv->prof_rfx_differential_encode)\n\tPROFILER_PRINT(context->priv->prof_rfx_quantization_encode)\n\tPROFILER_PRINT(context->priv->prof_rfx_dwt_2d_encode)\n\tPROFILER_PRINT(context->priv->prof_rfx_rgb_to_ycbcr)\n\tPROFILER_PRINT(context->priv->prof_rfx_encode_format_rgb)\n\tPROFILER_PRINT_FOOTER\n}\n\nstatic void rfx_tile_init(void* obj)\n{\n\tRFX_TILE* tile = (RFX_TILE*)obj;\n\tif (tile)\n\t{\n\t\ttile->x = 0;\n\t\ttile->y = 0;\n\t\ttile->YLen = 0;\n\t\ttile->YData = NULL;\n\t\ttile->CbLen = 0;\n\t\ttile->CbData = NULL;\n\t\ttile->CrLen = 0;\n\t\ttile->CrData = NULL;\n\t}\n}\n\nstatic void* rfx_decoder_tile_new(const void* val)\n{\n\tconst size_t size = 4 * 64 * 64;\n\tRFX_TILE* tile = NULL;\n\tWINPR_UNUSED(val);\n\n\tif (!(tile = (RFX_TILE*)winpr_aligned_calloc(1, sizeof(RFX_TILE), 32)))\n\t\treturn NULL;\n\n\tif (!(tile->data = (BYTE*)winpr_aligned_malloc(size, 16)))\n\t{\n\t\twinpr_aligned_free(tile);\n\t\treturn NULL;\n\t}\n\tmemset(tile->data, 0xff, size);\n\ttile->allocated = TRUE;\n\treturn tile;\n}\n\nstatic void rfx_decoder_tile_free(void* obj)\n{\n\tRFX_TILE* tile = (RFX_TILE*)obj;\n\n\tif (tile)\n\t{\n\t\tif (tile->allocated)\n\t\t\twinpr_aligned_free(tile->data);\n\n\t\twinpr_aligned_free(tile);\n\t}\n}\n\nstatic void* rfx_encoder_tile_new(const void* val)\n{\n\tWINPR_UNUSED(val);\n\treturn winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);\n}\n\nstatic void rfx_encoder_tile_free(void* obj)\n{\n\twinpr_aligned_free(obj);\n}\n\nRFX_CONTEXT* rfx_context_new(BOOL encoder)\n{\n\treturn rfx_context_new_ex(encoder, 0);\n}\n\nRFX_CONTEXT* rfx_context_new_ex(BOOL encoder, UINT32 ThreadingFlags)\n{\n\tHKEY hKey;\n\tLONG status;\n\tDWORD dwType;\n\tDWORD dwSize;\n\tDWORD dwValue;\n\tSYSTEM_INFO sysinfo;\n\tRFX_CONTEXT* context;\n\twObject* pool;\n\tRFX_CONTEXT_PRIV* priv;\n\tcontext = (RFX_CONTEXT*)winpr_aligned_calloc(1, sizeof(RFX_CONTEXT), 32);\n\n\tif (!context)\n\t\treturn NULL;\n\n\tcontext->encoder = encoder;\n\tcontext->currentMessage.freeArray = TRUE;\n\tcontext->priv = priv = (RFX_CONTEXT_PRIV*)winpr_aligned_calloc(1, sizeof(RFX_CONTEXT_PRIV), 32);\n\n\tif (!priv)\n\t\tgoto fail;\n\n\tpriv->log = WLog_Get(\"com.freerdp.codec.rfx\");\n\tWLog_OpenAppender(priv->log);\n\tpriv->TilePool = ObjectPool_New(TRUE);\n\n\tif (!priv->TilePool)\n\t\tgoto fail;\n\n\tpool = ObjectPool_Object(priv->TilePool);\n\tpool->fnObjectInit = rfx_tile_init;\n\n\tif (context->encoder)\n\t{\n\t\tpool->fnObjectNew = rfx_encoder_tile_new;\n\t\tpool->fnObjectFree = rfx_encoder_tile_free;\n\t}\n\telse\n\t{\n\t\tpool->fnObjectNew = rfx_decoder_tile_new;\n\t\tpool->fnObjectFree = rfx_decoder_tile_free;\n\t}\n\n\t/*\n\t * align buffers to 16 byte boundary (needed for SSE/NEON instructions)\n\t *\n\t * y_r_buffer, cb_g_buffer, cr_b_buffer: 64 * 64 * sizeof(INT16) = 8192 (0x2000)\n\t * dwt_buffer: 32 * 32 * 2 * 2 * sizeof(INT16) = 8192, maximum sub-band width is 32\n\t *\n\t * Additionally we add 32 bytes (16 in front and 16 at the back of the buffer)\n\t * in order to allow optimized functions (SEE, NEON) to read from positions\n\t * that are actually in front/beyond the buffer. Offset calculations are\n\t * performed at the BufferPool_Take function calls in rfx_encode/decode.c.\n\t *\n\t * We then multiply by 3 to use a single, partioned buffer for all 3 channels.\n\t */\n\tpriv->BufferPool = BufferPool_New(TRUE, (8192 + 32) * 3, 16);\n\n\tif (!priv->BufferPool)\n\t\tgoto fail;\n\n\tif (!(ThreadingFlags & THREADING_FLAGS_DISABLE_THREADS))\n\t{\n\t\tpriv->UseThreads = TRUE;\n\n\t\tGetNativeSystemInfo(&sysinfo);\n\t\tpriv->MinThreadCount = sysinfo.dwNumberOfProcessors;\n\t\tpriv->MaxThreadCount = 0;\n\t\tstatus = RegOpenKeyExA(HKEY_LOCAL_MACHINE, RFX_KEY, 0, KEY_READ | KEY_WOW64_64KEY, &hKey);\n\n\t\tif (status == ERROR_SUCCESS)\n\t\t{\n\t\t\tdwSize = sizeof(dwValue);\n\n\t\t\tif (RegQueryValueEx(hKey, _T(\"UseThreads\"), NULL, &dwType, (BYTE*)&dwValue, &dwSize) ==\n\t\t\t    ERROR_SUCCESS)\n\t\t\t\tpriv->UseThreads = dwValue ? 1 : 0;\n\n\t\t\tif (RegQueryValueEx(hKey, _T(\"MinThreadCount\"), NULL, &dwType, (BYTE*)&dwValue,\n\t\t\t                    &dwSize) == ERROR_SUCCESS)\n\t\t\t\tpriv->MinThreadCount = dwValue;\n\n\t\t\tif (RegQueryValueEx(hKey, _T(\"MaxThreadCount\"), NULL, &dwType, (BYTE*)&dwValue,\n\t\t\t                    &dwSize) == ERROR_SUCCESS)\n\t\t\t\tpriv->MaxThreadCount = dwValue;\n\n\t\t\tRegCloseKey(hKey);\n\t\t}\n\t}\n\telse\n\t{\n\t\tpriv->UseThreads = FALSE;\n\t}\n\n\tif (priv->UseThreads)\n\t{\n\t\t/* Call primitives_get here in order to avoid race conditions when using primitives_get */\n\t\t/* from multiple threads. This call will initialize all function pointers correctly     */\n\t\t/* before any decoding threads are started */\n\t\tprimitives_get();\n\t\tpriv->ThreadPool = CreateThreadpool(NULL);\n\n\t\tif (!priv->ThreadPool)\n\t\t\tgoto fail;\n\n\t\tInitializeThreadpoolEnvironment(&priv->ThreadPoolEnv);\n\t\tSetThreadpoolCallbackPool(&priv->ThreadPoolEnv, priv->ThreadPool);\n\n\t\tif (priv->MinThreadCount)\n\t\t\tif (!SetThreadpoolThreadMinimum(priv->ThreadPool, priv->MinThreadCount))\n\t\t\t\tgoto fail;\n\n\t\tif (priv->MaxThreadCount)\n\t\t\tSetThreadpoolThreadMaximum(priv->ThreadPool, priv->MaxThreadCount);\n\t}\n\n\t/* initialize the default pixel format */\n\trfx_context_set_pixel_format(context, PIXEL_FORMAT_BGRX32);\n\t/* create profilers for default decoding routines */\n\trfx_profiler_create(context);\n\t/* set up default routines */\n\tcontext->quantization_decode = rfx_quantization_decode;\n\tcontext->quantization_encode = rfx_quantization_encode;\n\tcontext->dwt_2d_decode = rfx_dwt_2d_decode;\n\tcontext->dwt_2d_encode = rfx_dwt_2d_encode;\n\tcontext->rlgr_decode = rfx_rlgr_decode;\n\tcontext->rlgr_encode = rfx_rlgr_encode;\n\tRFX_INIT_SIMD(context);\n\tcontext->state = RFX_STATE_SEND_HEADERS;\n\tcontext->expectedDataBlockType = WBT_FRAME_BEGIN;\n\treturn context;\nfail:\n\trfx_context_free(context);\n\treturn NULL;\n}\n\nvoid rfx_context_free(RFX_CONTEXT* context)\n{\n\tRFX_CONTEXT_PRIV* priv;\n\n\tif (!context)\n\t\treturn;\n\n\tWINPR_ASSERT(NULL != context);\n\n\tpriv = context->priv;\n\tWINPR_ASSERT(NULL != priv);\n\tWINPR_ASSERT(NULL != priv->TilePool);\n\tWINPR_ASSERT(NULL != priv->BufferPool);\n\n\t/* coverity[address_free] */\n\trfx_message_free(context, &context->currentMessage);\n\twinpr_aligned_free(context->quants);\n\trfx_profiler_print(context);\n\trfx_profiler_free(context);\n\n\tif (priv)\n\t{\n\t\tObjectPool_Free(priv->TilePool);\n\t\tif (priv->UseThreads)\n\t\t{\n\t\t\tif (priv->ThreadPool)\n\t\t\t\tCloseThreadpool(priv->ThreadPool);\n\t\t\tDestroyThreadpoolEnvironment(&priv->ThreadPoolEnv);\n\t\t\twinpr_aligned_free(priv->workObjects);\n\t\t\twinpr_aligned_free(priv->tileWorkParams);\n#ifdef WITH_PROFILER\n\t\t\tWLog_VRB(\n\t\t\t    TAG,\n\t\t\t    \"WARNING: Profiling results probably unusable with multithreaded RemoteFX codec!\");\n#endif\n\t\t}\n\n\t\tBufferPool_Free(priv->BufferPool);\n\t\twinpr_aligned_free(priv);\n\t}\n\twinpr_aligned_free(context);\n}\n\nstatic RFX_TILE* rfx_message_get_tile(RFX_MESSAGE* message, UINT32 index)\n{\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(message->tiles);\n\tWINPR_ASSERT(index < message->numTiles);\n\treturn message->tiles[index];\n}\n\nstatic const RFX_RECT* rfx_message_get_rect_const(const RFX_MESSAGE* message, UINT32 index)\n{\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(message->rects);\n\tWINPR_ASSERT(index < message->numRects);\n\treturn &message->rects[index];\n}\n\nstatic RFX_RECT* rfx_message_get_rect(RFX_MESSAGE* message, UINT32 index)\n{\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(message->rects);\n\tWINPR_ASSERT(index < message->numRects);\n\treturn &message->rects[index];\n}\n\nvoid rfx_context_set_pixel_format(RFX_CONTEXT* context, UINT32 pixel_format)\n{\n\tWINPR_ASSERT(context);\n\tcontext->pixel_format = pixel_format;\n\tcontext->bits_per_pixel = FreeRDPGetBitsPerPixel(pixel_format);\n}\n\nvoid rfx_context_set_palette(RFX_CONTEXT* context, const BYTE* palette)\n{\n\tWINPR_ASSERT(context);\n\tcontext->palette = palette;\n}\n\nBOOL rfx_context_reset(RFX_CONTEXT* context, UINT32 width, UINT32 height)\n{\n\tif (!context)\n\t\treturn FALSE;\n\n\tcontext->width = width;\n\tcontext->height = height;\n\tcontext->state = RFX_STATE_SEND_HEADERS;\n\tcontext->expectedDataBlockType = WBT_FRAME_BEGIN;\n\tcontext->frameIdx = 0;\n\treturn TRUE;\n}\n\nstatic BOOL rfx_process_message_sync(RFX_CONTEXT* context, wStream* s)\n{\n\tUINT32 magic;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tcontext->decodedHeaderBlocks &= ~RFX_DECODED_SYNC;\n\n\t/* RFX_SYNC */\n\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 6))\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, context->version); /* version (2 bytes), WF_VERSION_1_0 (0x0100) */\n\tif (context->version != WF_VERSION_1_0)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid version number 0x%08\" PRIX32 \"\",\n\t\t           context->version);\n\t\treturn FALSE;\n\t}\n\n\tWLog_Print(context->priv->log, WLOG_DEBUG, \"version 0x%08\" PRIX32 \"\", context->version);\n\tcontext->decodedHeaderBlocks |= RFX_DECODED_SYNC;\n\treturn TRUE;\n}\n\nstatic BOOL rfx_process_message_codec_versions(RFX_CONTEXT* context, wStream* s)\n{\n\tBYTE numCodecs;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tcontext->decodedHeaderBlocks &= ~RFX_DECODED_VERSIONS;\n\n\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 4))\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, numCodecs);         /* numCodecs (1 byte), must be set to 0x01 */\n\tStream_Read_UINT8(s, context->codec_id); /* codecId (1 byte), must be set to 0x01 */\n\tStream_Read_UINT16(\n\t    s, context->codec_version); /* version (2 bytes), must be set to WF_VERSION_1_0 (0x0100)  */\n\n\tif (numCodecs != 1)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"numCodes is 0x%02\" PRIX8 \" (must be 0x01)\",\n\t\t           numCodecs);\n\t\treturn FALSE;\n\t}\n\n\tif (context->codec_id != 0x01)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid codec id (0x%02\" PRIX32 \")\",\n\t\t           context->codec_id);\n\t\treturn FALSE;\n\t}\n\n\tif (context->codec_version != WF_VERSION_1_0)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid codec version (0x%08\" PRIX32 \")\",\n\t\t           context->codec_version);\n\t\treturn FALSE;\n\t}\n\n\tWLog_Print(context->priv->log, WLOG_DEBUG, \"id %\" PRIu32 \" version 0x%\" PRIX32 \".\",\n\t           context->codec_id, context->codec_version);\n\tcontext->decodedHeaderBlocks |= RFX_DECODED_VERSIONS;\n\treturn TRUE;\n}\n\nstatic BOOL rfx_process_message_channels(RFX_CONTEXT* context, wStream* s)\n{\n\tBYTE channelId;\n\tBYTE numChannels;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tcontext->decodedHeaderBlocks &= ~RFX_DECODED_CHANNELS;\n\n\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 1))\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, numChannels); /* numChannels (1 byte), must bet set to 0x01 */\n\n\t/* In RDVH sessions, numChannels will represent the number of virtual monitors\n\t * configured and does not always be set to 0x01 as [MS-RDPRFX] said.\n\t */\n\tif (numChannels < 1)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"no channels announced\");\n\t\treturn FALSE;\n\t}\n\n\tif (!Stream_CheckAndLogRequiredLengthOfSizeWLog(context->priv->log, s, numChannels, 5ull))\n\t\treturn FALSE;\n\n\t/* RFX_CHANNELT */\n\tStream_Read_UINT8(s, channelId); /* channelId (1 byte), must be set to 0x00 */\n\n\tif (channelId != 0x00)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"channelId:0x%02\" PRIX8 \", expected:0x00\",\n\t\t           channelId);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, context->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, context->height); /* height (2 bytes) */\n\n\tif (!context->width || !context->height)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR,\n\t\t           \"invalid channel with/height: %\" PRIu16 \"x%\" PRIu16 \"\", context->width,\n\t\t           context->height);\n\t\treturn FALSE;\n\t}\n\n\t/* Now, only the first monitor can be used, therefore the other channels will be ignored. */\n\tStream_Seek(s, 5 * (numChannels - 1));\n\tWLog_Print(context->priv->log, WLOG_DEBUG,\n\t           \"numChannels %\" PRIu8 \" id %\" PRIu8 \", %\" PRIu16 \"x%\" PRIu16 \".\", numChannels,\n\t           channelId, context->width, context->height);\n\tcontext->decodedHeaderBlocks |= RFX_DECODED_CHANNELS;\n\treturn TRUE;\n}\n\nstatic BOOL rfx_process_message_context(RFX_CONTEXT* context, wStream* s)\n{\n\tBYTE ctxId;\n\tUINT16 tileSize;\n\tUINT16 properties;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tcontext->decodedHeaderBlocks &= ~RFX_DECODED_CONTEXT;\n\n\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 5))\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, ctxId);     /* ctxId (1 byte), must be set to 0x00 */\n\tStream_Read_UINT16(s, tileSize); /* tileSize (2 bytes), must be set to CT_TILE_64x64 (0x0040) */\n\tStream_Read_UINT16(s, properties); /* properties (2 bytes) */\n\tWLog_Print(context->priv->log, WLOG_DEBUG,\n\t           \"ctxId %\" PRIu8 \" tileSize %\" PRIu16 \" properties 0x%04\" PRIX16 \".\", ctxId, tileSize,\n\t           properties);\n\tcontext->properties = properties;\n\tcontext->flags = (properties & 0x0007);\n\n\tif (context->flags == CODEC_MODE)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_DEBUG, \"codec is in image mode.\");\n\t}\n\telse\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_DEBUG, \"codec is in video mode.\");\n\t}\n\n\tswitch ((properties & 0x1E00) >> 9)\n\t{\n\t\tcase CLW_ENTROPY_RLGR1:\n\t\t\tcontext->mode = RLGR1;\n\t\t\tWLog_Print(context->priv->log, WLOG_DEBUG, \"RLGR1.\");\n\t\t\tbreak;\n\n\t\tcase CLW_ENTROPY_RLGR3:\n\t\t\tcontext->mode = RLGR3;\n\t\t\tWLog_Print(context->priv->log, WLOG_DEBUG, \"RLGR3.\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"unknown RLGR algorithm.\");\n\t\t\treturn FALSE;\n\t}\n\n\tcontext->decodedHeaderBlocks |= RFX_DECODED_CONTEXT;\n\treturn TRUE;\n}\n\nstatic BOOL rfx_process_message_frame_begin(RFX_CONTEXT* context, RFX_MESSAGE* message, wStream* s,\n                                            UINT16* pExpectedBlockType)\n{\n\tUINT32 frameIdx;\n\tUINT16 numRegions;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_BEGIN)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_BEGIN\");\n\t\treturn FALSE;\n\t}\n\n\t*pExpectedBlockType = WBT_REGION;\n\n\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 6))\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(\n\t    s, frameIdx); /* frameIdx (4 bytes), if codec is in video mode, must be ignored */\n\tStream_Read_UINT16(s, numRegions); /* numRegions (2 bytes) */\n\tWLog_Print(context->priv->log, WLOG_DEBUG,\n\t           \"RFX_FRAME_BEGIN: frameIdx: %\" PRIu32 \" numRegions: %\" PRIu16 \"\", frameIdx,\n\t           numRegions);\n\treturn TRUE;\n}\n\nstatic BOOL rfx_process_message_frame_end(RFX_CONTEXT* context, RFX_MESSAGE* message, wStream* s,\n                                          UINT16* pExpectedBlockType)\n{\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected, wants WBT_FRAME_END\");\n\t\treturn FALSE;\n\t}\n\n\t*pExpectedBlockType = WBT_FRAME_BEGIN;\n\tWLog_Print(context->priv->log, WLOG_DEBUG, \"RFX_FRAME_END\");\n\treturn TRUE;\n}\n\nstatic BOOL rfx_resize_rects(RFX_MESSAGE* message)\n{\n\tWINPR_ASSERT(message);\n\n\tRFX_RECT* tmpRects =\n\t    winpr_aligned_recalloc(message->rects, message->numRects, sizeof(RFX_RECT), 32);\n\tif (!tmpRects)\n\t\treturn FALSE;\n\tmessage->rects = tmpRects;\n\treturn TRUE;\n}\n\nstatic BOOL rfx_process_message_region(RFX_CONTEXT* context, RFX_MESSAGE* message, wStream* s,\n                                       UINT16* pExpectedBlockType)\n{\n\tUINT16 i;\n\tUINT16 regionType;\n\tUINT16 numTileSets;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_REGION)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_REGION\");\n\t\treturn FALSE;\n\t}\n\n\t*pExpectedBlockType = WBT_EXTENSION;\n\n\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 3))\n\t\treturn FALSE;\n\n\tStream_Seek_UINT8(s);                     /* regionFlags (1 byte) */\n\tStream_Read_UINT16(s, message->numRects); /* numRects (2 bytes) */\n\n\tif (message->numRects < 1)\n\t{\n\t\t/*\n\t\t   If numRects is zero the decoder must generate a rectangle with\n\t\t   coordinates (0, 0, width, height).\n\t\t   See [MS-RDPRFX] (revision >= 17.0) 2.2.2.3.3 TS_RFX_REGION\n\t\t   https://msdn.microsoft.com/en-us/library/ff635233.aspx\n\t\t*/\n\t\tmessage->numRects = 1;\n\t\tif (!rfx_resize_rects(message))\n\t\t\treturn FALSE;\n\n\t\tmessage->rects->x = 0;\n\t\tmessage->rects->y = 0;\n\t\tmessage->rects->width = context->width;\n\t\tmessage->rects->height = context->height;\n\t\treturn TRUE;\n\t}\n\n\tif (!Stream_CheckAndLogRequiredLengthOfSizeWLog(context->priv->log, s, message->numRects, 8ull))\n\t\treturn FALSE;\n\n\tif (!rfx_resize_rects(message))\n\t\treturn FALSE;\n\n\t/* rects */\n\tfor (i = 0; i < message->numRects; i++)\n\t{\n\t\tRFX_RECT* rect = rfx_message_get_rect(message, i);\n\t\t/* RFX_RECT */\n\t\tStream_Read_UINT16(s, rect->x);      /* x (2 bytes) */\n\t\tStream_Read_UINT16(s, rect->y);      /* y (2 bytes) */\n\t\tStream_Read_UINT16(s, rect->width);  /* width (2 bytes) */\n\t\tStream_Read_UINT16(s, rect->height); /* height (2 bytes) */\n\t\tWLog_Print(context->priv->log, WLOG_DEBUG,\n\t\t           \"rect %\" PRIu16 \" (x,y=%\" PRIu16 \",%\" PRIu16 \" w,h=%\" PRIu16 \" %\" PRIu16 \").\", i,\n\t\t           rect->x, rect->y, rect->width, rect->height);\n\t}\n\n\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 4))\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, regionType);  /*regionType (2 bytes): MUST be set to CBT_REGION (0xCAC1)*/\n\tStream_Read_UINT16(s, numTileSets); /*numTilesets (2 bytes): MUST be set to 0x0001.*/\n\n\tif (regionType != CBT_REGION)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid region type 0x%04\" PRIX16 \"\",\n\t\t           regionType);\n\t\treturn TRUE;\n\t}\n\n\tif (numTileSets != 0x0001)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid number of tilesets (%\" PRIu16 \")\",\n\t\t           numTileSets);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\ntypedef struct\n{\n\tRFX_TILE* tile;\n\tRFX_CONTEXT* context;\n} RFX_TILE_PROCESS_WORK_PARAM;\n\nstatic void CALLBACK rfx_process_message_tile_work_callback(PTP_CALLBACK_INSTANCE instance,\n                                                            void* context, PTP_WORK work)\n{\n\tRFX_TILE_PROCESS_WORK_PARAM* param = (RFX_TILE_PROCESS_WORK_PARAM*)context;\n\tWINPR_ASSERT(param);\n\trfx_decode_rgb(param->context, param->tile, param->tile->data, 64 * 4);\n}\n\nstatic BOOL rfx_allocate_tiles(RFX_MESSAGE* message, size_t count, BOOL allocOnly)\n{\n\tWINPR_ASSERT(message);\n\n\tRFX_TILE** tmpTiles = winpr_aligned_recalloc(message->tiles, count, sizeof(RFX_TILE*), 32);\n\tif (!tmpTiles && (count != 0))\n\t\treturn FALSE;\n\n\tmessage->tiles = tmpTiles;\n\tif (!allocOnly)\n\t\tmessage->numTiles = count;\n\telse\n\t{\n\t\tWINPR_ASSERT(message->numTiles <= count);\n\t}\n\tmessage->allocatedTiles = count;\n\n\treturn TRUE;\n}\nstatic BOOL rfx_process_message_tileset(RFX_CONTEXT* context, RFX_MESSAGE* message, wStream* s,\n                                        UINT16* pExpectedBlockType)\n{\n\tBOOL rc;\n\tsize_t close_cnt = 0;\n\tBYTE quant;\n\tRFX_TILE* tile;\n\tUINT32* quants;\n\tUINT16 subtype, numTiles;\n\tUINT32 blockLen;\n\tUINT32 blockType;\n\tUINT32 tilesDataSize;\n\tPTP_WORK* work_objects = NULL;\n\tRFX_TILE_PROCESS_WORK_PARAM* params = NULL;\n\tvoid* pmem;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_EXTENSION)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants a tileset\");\n\t\treturn FALSE;\n\t}\n\n\t*pExpectedBlockType = WBT_FRAME_END;\n\n\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 14))\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, subtype); /* subtype (2 bytes) must be set to CBT_TILESET (0xCAC2) */\n\tif (subtype != CBT_TILESET)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid subtype, expected CBT_TILESET.\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Seek_UINT16(s);                   /* idx (2 bytes), must be set to 0x0000 */\n\tStream_Seek_UINT16(s);                   /* properties (2 bytes) */\n\tStream_Read_UINT8(s, context->numQuant); /* numQuant (1 byte) */\n\tStream_Seek_UINT8(s);                    /* tileSize (1 byte), must be set to 0x40 */\n\n\tif (context->numQuant < 1)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"no quantization value.\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, numTiles); /* numTiles (2 bytes) */\n\tif (numTiles < 1)\n\t{\n\t\t/* Windows Server 2012 (not R2) can send empty tile sets */\n\t\treturn TRUE;\n\t}\n\n\tStream_Read_UINT32(s, tilesDataSize); /* tilesDataSize (4 bytes) */\n\n\tif (!(pmem =\n\t          winpr_aligned_recalloc(context->quants, context->numQuant, 10 * sizeof(UINT32), 32)))\n\t\treturn FALSE;\n\n\tquants = context->quants = (UINT32*)pmem;\n\n\t/* quantVals */\n\tif (!Stream_CheckAndLogRequiredLengthOfSizeWLog(context->priv->log, s, context->numQuant, 5ull))\n\t\treturn FALSE;\n\n\tfor (size_t i = 0; i < context->numQuant; i++)\n\t{\n\t\t/* RFX_CODEC_QUANT */\n\t\tStream_Read_UINT8(s, quant);\n\t\t*quants++ = (quant & 0x0F);\n\t\t*quants++ = (quant >> 4);\n\t\tStream_Read_UINT8(s, quant);\n\t\t*quants++ = (quant & 0x0F);\n\t\t*quants++ = (quant >> 4);\n\t\tStream_Read_UINT8(s, quant);\n\t\t*quants++ = (quant & 0x0F);\n\t\t*quants++ = (quant >> 4);\n\t\tStream_Read_UINT8(s, quant);\n\t\t*quants++ = (quant & 0x0F);\n\t\t*quants++ = (quant >> 4);\n\t\tStream_Read_UINT8(s, quant);\n\t\t*quants++ = (quant & 0x0F);\n\t\t*quants++ = (quant >> 4);\n\t\tWLog_Print(context->priv->log, WLOG_DEBUG,\n\t\t           \"quant %d (%\" PRIu32 \" %\" PRIu32 \" %\" PRIu32 \" %\" PRIu32 \" %\" PRIu32 \" %\" PRIu32\n\t\t           \" %\" PRIu32 \" %\" PRIu32 \" %\" PRIu32 \" %\" PRIu32 \").\",\n\t\t           i, context->quants[i * 10], context->quants[i * 10 + 1],\n\t\t           context->quants[i * 10 + 2], context->quants[i * 10 + 3],\n\t\t           context->quants[i * 10 + 4], context->quants[i * 10 + 5],\n\t\t           context->quants[i * 10 + 6], context->quants[i * 10 + 7],\n\t\t           context->quants[i * 10 + 8], context->quants[i * 10 + 9]);\n\t}\n\n\tfor (size_t i = 0; i < message->numTiles; i++)\n\t{\n\t\tObjectPool_Return(context->priv->TilePool, message->tiles[i]);\n\t\tmessage->tiles[i] = NULL;\n\t}\n\n\tif (!rfx_allocate_tiles(message, numTiles, FALSE))\n\t\treturn FALSE;\n\n\tif (context->priv->UseThreads)\n\t{\n\t\twork_objects = (PTP_WORK*)winpr_aligned_calloc(message->numTiles, sizeof(PTP_WORK), 32);\n\t\tparams = (RFX_TILE_PROCESS_WORK_PARAM*)winpr_aligned_recalloc(\n\t\t    NULL, message->numTiles, sizeof(RFX_TILE_PROCESS_WORK_PARAM), 32);\n\n\t\tif (!work_objects)\n\t\t{\n\t\t\twinpr_aligned_free(params);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (!params)\n\t\t{\n\t\t\twinpr_aligned_free(work_objects);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/* tiles */\n\tclose_cnt = 0;\n\trc = FALSE;\n\n\tif (Stream_GetRemainingLength(s) >= tilesDataSize)\n\t{\n\t\trc = TRUE;\n\t\tfor (size_t i = 0; i < message->numTiles; i++)\n\t\t{\n\t\t\twStream subBuffer;\n\t\t\twStream* sub;\n\n\t\t\tif (!(tile = (RFX_TILE*)ObjectPool_Take(context->priv->TilePool)))\n\t\t\t{\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR,\n\t\t\t\t           \"RfxMessageTileSet failed to get tile from object pool\");\n\t\t\t\trc = FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmessage->tiles[i] = tile;\n\n\t\t\t/* RFX_TILE */\n\t\t\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 6))\n\t\t\t{\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR,\n\t\t\t\t           \"RfxMessageTileSet packet too small to read tile %d/%\" PRIu16 \"\", i,\n\t\t\t\t           message->numTiles);\n\t\t\t\trc = FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsub = Stream_StaticInit(&subBuffer, Stream_Pointer(s), Stream_GetRemainingLength(s));\n\t\t\tStream_Read_UINT16(\n\t\t\t    sub, blockType); /* blockType (2 bytes), must be set to CBT_TILE (0xCAC3) */\n\t\t\tStream_Read_UINT32(sub, blockLen); /* blockLen (4 bytes) */\n\n\t\t\tif (!Stream_SafeSeek(s, blockLen))\n\t\t\t{\n\t\t\t\trc = FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((blockLen < 6 + 13) ||\n\t\t\t    (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, sub, blockLen - 6)))\n\t\t\t{\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR,\n\t\t\t\t           \"RfxMessageTileSet not enough bytes to read tile %d/%\" PRIu16\n\t\t\t\t           \" with blocklen=%\" PRIu32 \"\",\n\t\t\t\t           i, message->numTiles, blockLen);\n\t\t\t\trc = FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (blockType != CBT_TILE)\n\t\t\t{\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR,\n\t\t\t\t           \"unknown block type 0x%\" PRIX32 \", expected CBT_TILE (0xCAC3).\",\n\t\t\t\t           blockType);\n\t\t\t\trc = FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tStream_Read_UINT8(sub, tile->quantIdxY);  /* quantIdxY (1 byte) */\n\t\t\tStream_Read_UINT8(sub, tile->quantIdxCb); /* quantIdxCb (1 byte) */\n\t\t\tStream_Read_UINT8(sub, tile->quantIdxCr); /* quantIdxCr (1 byte) */\n\t\t\tStream_Read_UINT16(sub, tile->xIdx);      /* xIdx (2 bytes) */\n\t\t\tStream_Read_UINT16(sub, tile->yIdx);      /* yIdx (2 bytes) */\n\t\t\tStream_Read_UINT16(sub, tile->YLen);      /* YLen (2 bytes) */\n\t\t\tStream_Read_UINT16(sub, tile->CbLen);     /* CbLen (2 bytes) */\n\t\t\tStream_Read_UINT16(sub, tile->CrLen);     /* CrLen (2 bytes) */\n\t\t\tStream_GetPointer(sub, tile->YData);\n\t\t\tif (!Stream_SafeSeek(sub, tile->YLen))\n\t\t\t{\n\t\t\t\trc = FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tStream_GetPointer(sub, tile->CbData);\n\t\t\tif (!Stream_SafeSeek(sub, tile->CbLen))\n\t\t\t{\n\t\t\t\trc = FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tStream_GetPointer(sub, tile->CrData);\n\t\t\tif (!Stream_SafeSeek(sub, tile->CrLen))\n\t\t\t{\n\t\t\t\trc = FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttile->x = tile->xIdx * 64;\n\t\t\ttile->y = tile->yIdx * 64;\n\n\t\t\tif (context->priv->UseThreads)\n\t\t\t{\n\t\t\t\tif (!params)\n\t\t\t\t{\n\t\t\t\t\trc = FALSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tparams[i].context = context;\n\t\t\t\tparams[i].tile = message->tiles[i];\n\n\t\t\t\tif (!(work_objects[i] =\n\t\t\t\t          CreateThreadpoolWork(rfx_process_message_tile_work_callback,\n\t\t\t\t                               (void*)&params[i], &context->priv->ThreadPoolEnv)))\n\t\t\t\t{\n\t\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"CreateThreadpoolWork failed.\");\n\t\t\t\t\trc = FALSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tSubmitThreadpoolWork(work_objects[i]);\n\t\t\t\tclose_cnt = i + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trfx_decode_rgb(context, tile, tile->data, 64 * 4);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (context->priv->UseThreads)\n\t{\n\t\tfor (size_t i = 0; i < close_cnt; i++)\n\t\t{\n\t\t\tWaitForThreadpoolWorkCallbacks(work_objects[i], FALSE);\n\t\t\tCloseThreadpoolWork(work_objects[i]);\n\t\t}\n\t}\n\n\twinpr_aligned_free(work_objects);\n\twinpr_aligned_free(params);\n\n\tfor (size_t i = 0; i < message->numTiles; i++)\n\t{\n\t\tif (!(tile = message->tiles[i]))\n\t\t\tcontinue;\n\n\t\ttile->YLen = tile->CbLen = tile->CrLen = 0;\n\t\ttile->YData = tile->CbData = tile->CrData = NULL;\n\t}\n\n\treturn rc;\n}\n\nBOOL rfx_process_message(RFX_CONTEXT* context, const BYTE* data, UINT32 length, UINT32 left,\n                         UINT32 top, BYTE* dst, UINT32 dstFormat, UINT32 dstStride,\n                         UINT32 dstHeight, REGION16* invalidRegion)\n{\n\tREGION16 updateRegion = { 0 };\n\twStream inStream = { 0 };\n\tBOOL ok = TRUE;\n\n\tif (!context || !data || !length)\n\t\treturn FALSE;\n\n\tWINPR_ASSERT(context->priv);\n\tRFX_MESSAGE* message = &context->currentMessage;\n\n\twStream* s = Stream_StaticConstInit(&inStream, data, length);\n\n\twhile (ok && Stream_GetRemainingLength(s) > 6)\n\t{\n\t\twStream subStreamBuffer = { 0 };\n\t\tsize_t extraBlockLen = 0;\n\t\tUINT32 blockLen = 0;\n\t\tUINT32 blockType = 0;\n\n\t\t/* RFX_BLOCKT */\n\t\tStream_Read_UINT16(s, blockType); /* blockType (2 bytes) */\n\t\tStream_Read_UINT32(s, blockLen);  /* blockLen (4 bytes) */\n\t\tWLog_Print(context->priv->log, WLOG_DEBUG, \"blockType 0x%\" PRIX32 \" blockLen %\" PRIu32 \"\",\n\t\t           blockType, blockLen);\n\n\t\tif (blockLen < 6)\n\t\t{\n\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"blockLen too small(%\" PRIu32 \")\", blockLen);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, blockLen - 6))\n\t\t\treturn FALSE;\n\n\t\tif (blockType > WBT_CONTEXT && context->decodedHeaderBlocks != RFX_DECODED_HEADERS)\n\t\t{\n\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"incomplete header blocks processing\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (blockType >= WBT_CONTEXT && blockType <= WBT_EXTENSION)\n\t\t{\n\t\t\t/* RFX_CODEC_CHANNELT */\n\t\t\tUINT8 codecId = 0;\n\t\t\tUINT8 channelId = 0;\n\n\t\t\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 2))\n\t\t\t\treturn FALSE;\n\n\t\t\textraBlockLen = 2;\n\t\t\tStream_Read_UINT8(s, codecId);   /* codecId (1 byte) must be set to 0x01 */\n\t\t\tStream_Read_UINT8(s, channelId); /* channelId (1 byte) 0xFF or 0x00, see below */\n\n\t\t\tif (codecId != 0x01)\n\t\t\t{\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid codecId 0x%02\" PRIX8 \"\",\n\t\t\t\t           codecId);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tif (blockType == WBT_CONTEXT)\n\t\t\t{\n\t\t\t\t/* If the blockType is set to WBT_CONTEXT, then channelId MUST be set to 0xFF.*/\n\t\t\t\tif (channelId != 0xFF)\n\t\t\t\t{\n\t\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR,\n\t\t\t\t\t           \"invalid channelId 0x%02\" PRIX8 \" for blockType 0x%08\" PRIX32 \"\",\n\t\t\t\t\t           channelId, blockType);\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* For all other values of blockType, channelId MUST be set to 0x00. */\n\t\t\t\tif (channelId != 0x00)\n\t\t\t\t{\n\t\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR,\n\t\t\t\t\t           \"invalid channelId 0x%02\" PRIX8 \" for blockType WBT_CONTEXT\",\n\t\t\t\t\t           channelId);\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst size_t blockLenNoHeader = blockLen - 6;\n\t\tif (blockLenNoHeader < extraBlockLen)\n\t\t{\n\t\t\tWLog_Print(context->priv->log, WLOG_ERROR,\n\t\t\t           \"blockLen too small(%\" PRIu32 \"), must be >= 6 + %\" PRIu16, blockLen,\n\t\t\t           extraBlockLen);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tconst size_t subStreamLen = blockLenNoHeader - extraBlockLen;\n\t\twStream* subStream = Stream_StaticInit(&subStreamBuffer, Stream_Pointer(s), subStreamLen);\n\t\tStream_Seek(s, subStreamLen);\n\n\t\tswitch (blockType)\n\t\t{\n\t\t\t/* Header messages:\n\t\t\t * The stream MUST start with the header messages and any of these headers can appear\n\t\t\t * in the stream at a later stage. The header messages can be repeated.\n\t\t\t */\n\t\t\tcase WBT_SYNC:\n\t\t\t\tok = rfx_process_message_sync(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CONTEXT:\n\t\t\t\tok = rfx_process_message_context(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CODEC_VERSIONS:\n\t\t\t\tok = rfx_process_message_codec_versions(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CHANNELS:\n\t\t\t\tok = rfx_process_message_channels(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\t\t/* Data messages:\n\t\t\t\t * The data associated with each encoded frame or image is always bracketed by the\n\t\t\t\t * TS_RFX_FRAME_BEGIN (section 2.2.2.3.1) and TS_RFX_FRAME_END (section 2.2.2.3.2)\n\t\t\t\t * messages. There MUST only be one TS_RFX_REGION (section 2.2.2.3.3) message per\n\t\t\t\t * frame and one TS_RFX_TILESET (section 2.2.2.3.4) message per TS_RFX_REGION.\n\t\t\t\t */\n\n\t\t\tcase WBT_FRAME_BEGIN:\n\t\t\t\tok = rfx_process_message_frame_begin(context, message, subStream,\n\t\t\t\t                                     &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_REGION:\n\t\t\t\tok = rfx_process_message_region(context, message, subStream,\n\t\t\t\t                                &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_EXTENSION:\n\t\t\t\tok = rfx_process_message_tileset(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_FRAME_END:\n\t\t\t\tok = rfx_process_message_frame_end(context, message, subStream,\n\t\t\t\t                                   &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"unknown blockType 0x%\" PRIX32 \"\",\n\t\t\t\t           blockType);\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tif (ok)\n\t{\n\t\tUINT32 nbUpdateRects = 0;\n\t\tREGION16 clippingRects = { 0 };\n\t\tconst RECTANGLE_16* updateRects = NULL;\n\t\tconst DWORD formatSize = FreeRDPGetBytesPerPixel(context->pixel_format);\n\t\tconst UINT32 dstWidth = dstStride / FreeRDPGetBytesPerPixel(dstFormat);\n\t\tregion16_init(&clippingRects);\n\n\t\tWINPR_ASSERT(dstWidth <= UINT16_MAX);\n\t\tWINPR_ASSERT(dstHeight <= UINT16_MAX);\n\t\tfor (UINT32 i = 0; i < message->numRects; i++)\n\t\t{\n\t\t\tRECTANGLE_16 clippingRect = { 0 };\n\t\t\tconst RFX_RECT* rect = &(message->rects[i]);\n\n\t\t\tWINPR_ASSERT(left + rect->x <= UINT16_MAX);\n\t\t\tWINPR_ASSERT(top + rect->y <= UINT16_MAX);\n\t\t\tWINPR_ASSERT(clippingRect.left + rect->width <= UINT16_MAX);\n\t\t\tWINPR_ASSERT(clippingRect.top + rect->height <= UINT16_MAX);\n\n\t\t\tclippingRect.left = (UINT16)MIN(left + rect->x, dstWidth);\n\t\t\tclippingRect.top = (UINT16)MIN(top + rect->y, dstHeight);\n\t\t\tclippingRect.right = (UINT16)MIN(clippingRect.left + rect->width, dstWidth);\n\t\t\tclippingRect.bottom = (UINT16)MIN(clippingRect.top + rect->height, dstHeight);\n\t\t\tregion16_union_rect(&clippingRects, &clippingRects, &clippingRect);\n\t\t}\n\n\t\tfor (UINT32 i = 0; i < message->numTiles; i++)\n\t\t{\n\t\t\tRECTANGLE_16 updateRect = { 0 };\n\t\t\tconst RFX_TILE* tile = rfx_message_get_tile(message, i);\n\n\t\t\tWINPR_ASSERT(left + tile->x <= UINT16_MAX);\n\t\t\tWINPR_ASSERT(top + tile->y <= UINT16_MAX);\n\n\t\t\tupdateRect.left = (UINT16)left + tile->x;\n\t\t\tupdateRect.top = (UINT16)top + tile->y;\n\t\t\tupdateRect.right = updateRect.left + 64;\n\t\t\tupdateRect.bottom = updateRect.top + 64;\n\t\t\tregion16_init(&updateRegion);\n\t\t\tregion16_intersect_rect(&updateRegion, &clippingRects, &updateRect);\n\t\t\tupdateRects = region16_rects(&updateRegion, &nbUpdateRects);\n\n\t\t\tfor (UINT32 j = 0; j < nbUpdateRects; j++)\n\t\t\t{\n\t\t\t\tconst UINT32 stride = 64 * formatSize;\n\t\t\t\tconst UINT32 nXDst = updateRects[j].left;\n\t\t\t\tconst UINT32 nYDst = updateRects[j].top;\n\t\t\t\tconst UINT32 nXSrc = nXDst - updateRect.left;\n\t\t\t\tconst UINT32 nYSrc = nYDst - updateRect.top;\n\t\t\t\tconst UINT32 nWidth = updateRects[j].right - updateRects[j].left;\n\t\t\t\tconst UINT32 nHeight = updateRects[j].bottom - updateRects[j].top;\n\n\t\t\t\tif (!freerdp_image_copy(dst, dstFormat, dstStride, nXDst, nYDst, nWidth, nHeight,\n\t\t\t\t                        tile->data, context->pixel_format, stride, nXSrc, nYSrc,\n\t\t\t\t                        NULL, FREERDP_FLIP_NONE))\n\t\t\t\t{\n\t\t\t\t\tregion16_uninit(&updateRegion);\n\t\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR,\n\t\t\t\t\t           \"nbUpdateRectx[%\" PRIu32 \" (%\" PRIu32 \")] freerdp_image_copy failed\",\n\t\t\t\t\t           j, nbUpdateRects);\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tif (invalidRegion)\n\t\t\t\t\tregion16_union_rect(invalidRegion, invalidRegion, &updateRects[j]);\n\t\t\t}\n\n\t\t\tregion16_uninit(&updateRegion);\n\t\t}\n\n\t\tregion16_uninit(&clippingRects);\n\t\treturn TRUE;\n\t}\n\telse\n\t{\n\t\trfx_message_free(context, message);\n\t\tcontext->currentMessage.freeArray = TRUE;\n\t}\n\n\tWLog_Print(context->priv->log, WLOG_ERROR, \"failed\");\n\treturn FALSE;\n}\n\nconst UINT32* rfx_message_get_quants(const RFX_MESSAGE* message, UINT16* numQuantVals)\n{\n\tWINPR_ASSERT(message);\n\tif (numQuantVals)\n\t\t*numQuantVals = message->numQuant;\n\treturn message->quantVals;\n}\n\nconst RFX_TILE** rfx_message_get_tiles(const RFX_MESSAGE* message, UINT16* numTiles)\n{\n\tWINPR_ASSERT(message);\n\tif (numTiles)\n\t\t*numTiles = message->numTiles;\n\treturn message->tiles;\n}\n\nUINT16 rfx_message_get_tile_count(const RFX_MESSAGE* message)\n{\n\tWINPR_ASSERT(message);\n\treturn message->numTiles;\n}\n\nconst RFX_RECT* rfx_message_get_rects(const RFX_MESSAGE* message, UINT16* numRects)\n{\n\tWINPR_ASSERT(message);\n\tif (numRects)\n\t\t*numRects = message->numRects;\n\treturn message->rects;\n}\n\nUINT16 rfx_message_get_rect_count(const RFX_MESSAGE* message)\n{\n\tWINPR_ASSERT(message);\n\treturn message->numRects;\n}\n\nvoid rfx_message_free(RFX_CONTEXT* context, RFX_MESSAGE* message)\n{\n\tif (!message)\n\t\treturn;\n\n\twinpr_aligned_free(message->rects);\n\n\tif (message->tiles)\n\t{\n\t\tfor (size_t i = 0; i < message->numTiles; i++)\n\t\t{\n\t\t\tRFX_TILE* tile = message->tiles[i];\n\t\t\tif (!tile)\n\t\t\t\tcontinue;\n\n\t\t\tif (tile->YCbCrData)\n\t\t\t{\n\t\t\t\tBufferPool_Return(context->priv->BufferPool, tile->YCbCrData);\n\t\t\t\ttile->YCbCrData = NULL;\n\t\t\t}\n\n\t\t\tObjectPool_Return(context->priv->TilePool, (void*)tile);\n\t\t}\n\n\t\trfx_allocate_tiles(message, 0, FALSE);\n\t}\n\n\tconst BOOL freeArray = message->freeArray;\n\tconst RFX_MESSAGE empty = { 0 };\n\t*message = empty;\n\n\tif (!freeArray)\n\t\twinpr_aligned_free(message);\n}\n\nstatic void rfx_update_context_properties(RFX_CONTEXT* context)\n{\n\tUINT16 properties = 0;\n\n\tWINPR_ASSERT(context);\n\t/* properties in tilesets: note that this has different format from the one in TS_RFX_CONTEXT */\n\tproperties = 1;                          /* lt */\n\tproperties |= (context->flags << 1);     /* flags */\n\tproperties |= (COL_CONV_ICT << 4);       /* cct */\n\tproperties |= (CLW_XFORM_DWT_53_A << 6); /* xft */\n\tproperties |= ((context->mode == RLGR1 ? CLW_ENTROPY_RLGR1 : CLW_ENTROPY_RLGR3) << 10); /* et */\n\tproperties |= (SCALAR_QUANTIZATION << 14);                                              /* qt */\n\tcontext->properties = properties;\n}\n\nstatic void rfx_write_message_sync(const RFX_CONTEXT* context, wStream* s)\n{\n\tWINPR_ASSERT(context);\n\n\tStream_Write_UINT16(s, WBT_SYNC);       /* BlockT.blockType (2 bytes) */\n\tStream_Write_UINT32(s, 12);             /* BlockT.blockLen (4 bytes) */\n\tStream_Write_UINT32(s, WF_MAGIC);       /* magic (4 bytes) */\n\tStream_Write_UINT16(s, WF_VERSION_1_0); /* version (2 bytes) */\n}\n\nstatic void rfx_write_message_codec_versions(const RFX_CONTEXT* context, wStream* s)\n{\n\tWINPR_ASSERT(context);\n\n\tStream_Write_UINT16(s, WBT_CODEC_VERSIONS); /* BlockT.blockType (2 bytes) */\n\tStream_Write_UINT32(s, 10);                 /* BlockT.blockLen (4 bytes) */\n\tStream_Write_UINT8(s, 1);                   /* numCodecs (1 byte) */\n\tStream_Write_UINT8(s, 1);                   /* codecs.codecId (1 byte) */\n\tStream_Write_UINT16(s, WF_VERSION_1_0);     /* codecs.version (2 bytes) */\n}\n\nstatic void rfx_write_message_channels(const RFX_CONTEXT* context, wStream* s)\n{\n\tWINPR_ASSERT(context);\n\n\tStream_Write_UINT16(s, WBT_CHANNELS);    /* BlockT.blockType (2 bytes) */\n\tStream_Write_UINT32(s, 12);              /* BlockT.blockLen (4 bytes) */\n\tStream_Write_UINT8(s, 1);                /* numChannels (1 byte) */\n\tStream_Write_UINT8(s, 0);                /* Channel.channelId (1 byte) */\n\tStream_Write_UINT16(s, context->width);  /* Channel.width (2 bytes) */\n\tStream_Write_UINT16(s, context->height); /* Channel.height (2 bytes) */\n}\n\nstatic void rfx_write_message_context(RFX_CONTEXT* context, wStream* s)\n{\n\tUINT16 properties = 0;\n\tWINPR_ASSERT(context);\n\n\tStream_Write_UINT16(s, WBT_CONTEXT);   /* CodecChannelT.blockType (2 bytes) */\n\tStream_Write_UINT32(s, 13);            /* CodecChannelT.blockLen (4 bytes) */\n\tStream_Write_UINT8(s, 1);              /* CodecChannelT.codecId (1 byte) */\n\tStream_Write_UINT8(s, 0xFF);           /* CodecChannelT.channelId (1 byte) */\n\tStream_Write_UINT8(s, 0);              /* ctxId (1 byte) */\n\tStream_Write_UINT16(s, CT_TILE_64x64); /* tileSize (2 bytes) */\n\t/* properties */\n\tproperties = context->flags;             /* flags */\n\tproperties |= (COL_CONV_ICT << 3);       /* cct */\n\tproperties |= (CLW_XFORM_DWT_53_A << 5); /* xft */\n\tproperties |= ((context->mode == RLGR1 ? CLW_ENTROPY_RLGR1 : CLW_ENTROPY_RLGR3) << 9); /* et */\n\tproperties |= (SCALAR_QUANTIZATION << 13);                                             /* qt */\n\tStream_Write_UINT16(s, properties); /* properties (2 bytes) */\n\trfx_update_context_properties(context);\n}\n\nstatic BOOL rfx_compose_message_header(RFX_CONTEXT* context, wStream* s)\n{\n\tWINPR_ASSERT(context);\n\tif (!Stream_EnsureRemainingCapacity(s, 12 + 10 + 12 + 13))\n\t\treturn FALSE;\n\n\trfx_write_message_sync(context, s);\n\trfx_write_message_context(context, s);\n\trfx_write_message_codec_versions(context, s);\n\trfx_write_message_channels(context, s);\n\treturn TRUE;\n}\n\nstatic size_t rfx_tile_length(const RFX_TILE* tile)\n{\n\tWINPR_ASSERT(tile);\n\treturn 19ull + tile->YLen + tile->CbLen + tile->CrLen;\n}\n\nstatic BOOL rfx_write_tile(wStream* s, const RFX_TILE* tile)\n{\n\tconst size_t blockLen = rfx_tile_length(tile);\n\n\tif (!Stream_EnsureRemainingCapacity(s, blockLen))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, CBT_TILE);           /* BlockT.blockType (2 bytes) */\n\tStream_Write_UINT32(s, blockLen);           /* BlockT.blockLen (4 bytes) */\n\tStream_Write_UINT8(s, tile->quantIdxY);     /* quantIdxY (1 byte) */\n\tStream_Write_UINT8(s, tile->quantIdxCb);    /* quantIdxCb (1 byte) */\n\tStream_Write_UINT8(s, tile->quantIdxCr);    /* quantIdxCr (1 byte) */\n\tStream_Write_UINT16(s, tile->xIdx);         /* xIdx (2 bytes) */\n\tStream_Write_UINT16(s, tile->yIdx);         /* yIdx (2 bytes) */\n\tStream_Write_UINT16(s, tile->YLen);         /* YLen (2 bytes) */\n\tStream_Write_UINT16(s, tile->CbLen);        /* CbLen (2 bytes) */\n\tStream_Write_UINT16(s, tile->CrLen);        /* CrLen (2 bytes) */\n\tStream_Write(s, tile->YData, tile->YLen);   /* YData */\n\tStream_Write(s, tile->CbData, tile->CbLen); /* CbData */\n\tStream_Write(s, tile->CrData, tile->CrLen); /* CrData */\n\treturn TRUE;\n}\n\nstruct S_RFX_TILE_COMPOSE_WORK_PARAM\n{\n\tRFX_TILE* tile;\n\tRFX_CONTEXT* context;\n};\n\nstatic void CALLBACK rfx_compose_message_tile_work_callback(PTP_CALLBACK_INSTANCE instance,\n                                                            void* context, PTP_WORK work)\n{\n\tRFX_TILE_COMPOSE_WORK_PARAM* param = (RFX_TILE_COMPOSE_WORK_PARAM*)context;\n\tWINPR_ASSERT(param);\n\trfx_encode_rgb(param->context, param->tile);\n}\n\nstatic BOOL computeRegion(const RFX_RECT* rects, size_t numRects, REGION16* region, size_t width,\n                          size_t height)\n{\n\tconst RECTANGLE_16 mainRect = { 0, 0, width, height };\n\n\tWINPR_ASSERT(rects);\n\tfor (size_t i = 0; i < numRects; i++)\n\t{\n\t\tconst RFX_RECT* rect = &rects[i];\n\t\tRECTANGLE_16 rect16 = { 0 };\n\t\trect16.left = rect->x;\n\t\trect16.top = rect->y;\n\t\trect16.right = rect->x + rect->width;\n\t\trect16.bottom = rect->y + rect->height;\n\n\t\tif (!region16_union_rect(region, region, &rect16))\n\t\t\treturn FALSE;\n\t}\n\n\treturn region16_intersect_rect(region, region, &mainRect);\n}\n\n#define TILE_NO(v) ((v) / 64)\n\nstatic BOOL setupWorkers(RFX_CONTEXT* context, size_t nbTiles)\n{\n\tWINPR_ASSERT(context);\n\n\tRFX_CONTEXT_PRIV* priv = context->priv;\n\tWINPR_ASSERT(priv);\n\n\tvoid* pmem;\n\n\tif (!context->priv->UseThreads)\n\t\treturn TRUE;\n\n\tif (!(pmem = winpr_aligned_recalloc(priv->workObjects, nbTiles, sizeof(PTP_WORK), 32)))\n\t\treturn FALSE;\n\n\tpriv->workObjects = (PTP_WORK*)pmem;\n\n\tif (!(pmem = winpr_aligned_recalloc(priv->tileWorkParams, nbTiles,\n\t                                    sizeof(RFX_TILE_COMPOSE_WORK_PARAM), 32)))\n\t\treturn FALSE;\n\n\tpriv->tileWorkParams = (RFX_TILE_COMPOSE_WORK_PARAM*)pmem;\n\treturn TRUE;\n}\n\nstatic BOOL rfx_ensure_tiles(RFX_MESSAGE* message, size_t count)\n{\n\tWINPR_ASSERT(message);\n\n\tif (message->numTiles + count <= message->allocatedTiles)\n\t\treturn TRUE;\n\n\tconst size_t alloc = MAX(message->allocatedTiles + 1024, message->numTiles + count);\n\treturn rfx_allocate_tiles(message, alloc, TRUE);\n}\n\nRFX_MESSAGE* rfx_encode_message(RFX_CONTEXT* context, const RFX_RECT* rects, size_t numRects,\n                                const BYTE* data, UINT32 w, UINT32 h, size_t s)\n{\n\tconst UINT32 width = (UINT32)w;\n\tconst UINT32 height = (UINT32)h;\n\tconst UINT32 scanline = (UINT32)s;\n\tRFX_MESSAGE* message = NULL;\n\tPTP_WORK* workObject = NULL;\n\tRFX_TILE_COMPOSE_WORK_PARAM* workParam = NULL;\n\tBOOL success = FALSE;\n\tREGION16 rectsRegion = { 0 }, tilesRegion = { 0 };\n\tRECTANGLE_16 currentTileRect = { 0 };\n\tconst RECTANGLE_16* regionRect = NULL;\n\n\tWINPR_ASSERT(data);\n\tWINPR_ASSERT(rects);\n\tWINPR_ASSERT(numRects > 0);\n\tWINPR_ASSERT(w > 0);\n\tWINPR_ASSERT(h > 0);\n\tWINPR_ASSERT(s > 0);\n\n\tif (!(message = (RFX_MESSAGE*)winpr_aligned_calloc(1, sizeof(RFX_MESSAGE), 32)))\n\t\treturn NULL;\n\n\tregion16_init(&tilesRegion);\n\tregion16_init(&rectsRegion);\n\n\tif (context->state == RFX_STATE_SEND_HEADERS)\n\t\trfx_update_context_properties(context);\n\n\tmessage->frameIdx = context->frameIdx++;\n\n\tif (!context->numQuant)\n\t{\n\t\tWINPR_ASSERT(context->quants == NULL);\n\t\tif (!(context->quants =\n\t\t          (UINT32*)winpr_aligned_malloc(sizeof(rfx_default_quantization_values), 32)))\n\t\t\tgoto skip_encoding_loop;\n\n\t\tCopyMemory(context->quants, &rfx_default_quantization_values,\n\t\t           sizeof(rfx_default_quantization_values));\n\t\tcontext->numQuant = 1;\n\t\tcontext->quantIdxY = 0;\n\t\tcontext->quantIdxCb = 0;\n\t\tcontext->quantIdxCr = 0;\n\t}\n\n\tmessage->numQuant = context->numQuant;\n\tmessage->quantVals = context->quants;\n\tconst UINT32 bytesPerPixel = (context->bits_per_pixel / 8);\n\n\tif (!computeRegion(rects, numRects, &rectsRegion, width, height))\n\t\tgoto skip_encoding_loop;\n\n\tconst RECTANGLE_16* extents = region16_extents(&rectsRegion);\n\tWINPR_ASSERT((INT32)extents->right - extents->left > 0);\n\tWINPR_ASSERT((INT32)extents->bottom - extents->top > 0);\n\tconst UINT32 maxTilesX = 1 + TILE_NO(extents->right - 1) - TILE_NO(extents->left);\n\tconst UINT32 maxTilesY = 1 + TILE_NO(extents->bottom - 1) - TILE_NO(extents->top);\n\tconst UINT32 maxNbTiles = maxTilesX * maxTilesY;\n\n\tif (!rfx_ensure_tiles(message, maxNbTiles))\n\t\tgoto skip_encoding_loop;\n\n\tif (!setupWorkers(context, maxNbTiles))\n\t\tgoto skip_encoding_loop;\n\n\tif (context->priv->UseThreads)\n\t{\n\t\tworkObject = context->priv->workObjects;\n\t\tworkParam = context->priv->tileWorkParams;\n\t}\n\n\tUINT32 regionNbRects = 0;\n\tregionRect = region16_rects(&rectsRegion, &regionNbRects);\n\n\tif (!(message->rects = winpr_aligned_calloc(regionNbRects, sizeof(RFX_RECT), 32)))\n\t\tgoto skip_encoding_loop;\n\n\tmessage->numRects = regionNbRects;\n\n\tfor (UINT32 i = 0; i < regionNbRects; i++, regionRect++)\n\t{\n\t\tRFX_RECT* rfxRect = &message->rects[i];\n\t\tUINT32 startTileX = regionRect->left / 64;\n\t\tUINT32 endTileX = (regionRect->right - 1) / 64;\n\t\tUINT32 startTileY = regionRect->top / 64;\n\t\tUINT32 endTileY = (regionRect->bottom - 1) / 64;\n\t\trfxRect->x = regionRect->left;\n\t\trfxRect->y = regionRect->top;\n\t\trfxRect->width = (regionRect->right - regionRect->left);\n\t\trfxRect->height = (regionRect->bottom - regionRect->top);\n\n\t\tfor (UINT32 yIdx = startTileY, gridRelY = startTileY * 64; yIdx <= endTileY;\n\t\t     yIdx++, gridRelY += 64)\n\t\t{\n\t\t\tUINT32 tileHeight = 64;\n\n\t\t\tif ((yIdx == endTileY) && (gridRelY + 64 > height))\n\t\t\t\ttileHeight = height - gridRelY;\n\n\t\t\tcurrentTileRect.top = gridRelY;\n\t\t\tcurrentTileRect.bottom = gridRelY + tileHeight;\n\n\t\t\tfor (UINT32 xIdx = startTileX, gridRelX = startTileX * 64; xIdx <= endTileX;\n\t\t\t     xIdx++, gridRelX += 64)\n\t\t\t{\n\t\t\t\tunion\n\t\t\t\t{\n\t\t\t\t\tconst BYTE* cpv;\n\t\t\t\t\tBYTE* pv;\n\t\t\t\t} cnv;\n\t\t\t\tint tileWidth = 64;\n\n\t\t\t\tif ((xIdx == endTileX) && (gridRelX + 64 > width))\n\t\t\t\t\ttileWidth = width - gridRelX;\n\n\t\t\t\tcurrentTileRect.left = gridRelX;\n\t\t\t\tcurrentTileRect.right = gridRelX + tileWidth;\n\n\t\t\t\t/* checks if this tile is already treated */\n\t\t\t\tif (region16_intersects_rect(&tilesRegion, &currentTileRect))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tRFX_TILE* tile = (RFX_TILE*)ObjectPool_Take(context->priv->TilePool);\n\t\t\t\tif (!tile)\n\t\t\t\t\tgoto skip_encoding_loop;\n\n\t\t\t\ttile->xIdx = xIdx;\n\t\t\t\ttile->yIdx = yIdx;\n\t\t\t\ttile->x = gridRelX;\n\t\t\t\ttile->y = gridRelY;\n\t\t\t\ttile->scanline = scanline;\n\t\t\t\ttile->width = tileWidth;\n\t\t\t\ttile->height = tileHeight;\n\t\t\t\tconst UINT32 ax = gridRelX;\n\t\t\t\tconst UINT32 ay = gridRelY;\n\n\t\t\t\tif (tile->data && tile->allocated)\n\t\t\t\t{\n\t\t\t\t\twinpr_aligned_free(tile->data);\n\t\t\t\t\ttile->allocated = FALSE;\n\t\t\t\t}\n\n\t\t\t\t/* Cast away const */\n\t\t\t\tcnv.cpv = &data[(ay * scanline) + (ax * bytesPerPixel)];\n\t\t\t\ttile->data = cnv.pv;\n\t\t\t\ttile->quantIdxY = context->quantIdxY;\n\t\t\t\ttile->quantIdxCb = context->quantIdxCb;\n\t\t\t\ttile->quantIdxCr = context->quantIdxCr;\n\t\t\t\ttile->YLen = tile->CbLen = tile->CrLen = 0;\n\n\t\t\t\tif (!(tile->YCbCrData = (BYTE*)BufferPool_Take(context->priv->BufferPool, -1)))\n\t\t\t\t\tgoto skip_encoding_loop;\n\n\t\t\t\ttile->YData = (BYTE*)&(tile->YCbCrData[((8192 + 32) * 0) + 16]);\n\t\t\t\ttile->CbData = (BYTE*)&(tile->YCbCrData[((8192 + 32) * 1) + 16]);\n\t\t\t\ttile->CrData = (BYTE*)&(tile->YCbCrData[((8192 + 32) * 2) + 16]);\n\n\t\t\t\tif (!rfx_ensure_tiles(message, 1))\n\t\t\t\t\tgoto skip_encoding_loop;\n\t\t\t\tmessage->tiles[message->numTiles++] = tile;\n\n\t\t\t\tif (context->priv->UseThreads)\n\t\t\t\t{\n\t\t\t\t\tworkParam->context = context;\n\t\t\t\t\tworkParam->tile = tile;\n\n\t\t\t\t\tif (!(*workObject = CreateThreadpoolWork(rfx_compose_message_tile_work_callback,\n\t\t\t\t\t                                         (void*)workParam,\n\t\t\t\t\t                                         &context->priv->ThreadPoolEnv)))\n\t\t\t\t\t{\n\t\t\t\t\t\tgoto skip_encoding_loop;\n\t\t\t\t\t}\n\n\t\t\t\t\tSubmitThreadpoolWork(*workObject);\n\t\t\t\t\tworkObject++;\n\t\t\t\t\tworkParam++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trfx_encode_rgb(context, tile);\n\t\t\t\t}\n\n\t\t\t\tif (!region16_union_rect(&tilesRegion, &tilesRegion, &currentTileRect))\n\t\t\t\t\tgoto skip_encoding_loop;\n\t\t\t} /* xIdx */\n\t\t}     /* yIdx */\n\t}         /* rects */\n\n\tsuccess = TRUE;\nskip_encoding_loop:\n\n\t/* when using threads ensure all computations are done */\n\tif (success)\n\t{\n\t\tmessage->tilesDataSize = 0;\n\t\tworkObject = context->priv->workObjects;\n\n\t\tfor (UINT32 i = 0; i < message->numTiles; i++)\n\t\t{\n\t\t\tif (context->priv->UseThreads)\n\t\t\t{\n\t\t\t\tif (*workObject)\n\t\t\t\t{\n\t\t\t\t\tWaitForThreadpoolWorkCallbacks(*workObject, FALSE);\n\t\t\t\t\tCloseThreadpoolWork(*workObject);\n\t\t\t\t}\n\n\t\t\t\tworkObject++;\n\t\t\t}\n\n\t\t\tconst RFX_TILE* tile = message->tiles[i];\n\t\t\tmessage->tilesDataSize += rfx_tile_length(tile);\n\t\t}\n\n\t\tregion16_uninit(&tilesRegion);\n\t\tregion16_uninit(&rectsRegion);\n\n\t\treturn message;\n\t}\n\n\tWLog_Print(context->priv->log, WLOG_ERROR, \"failed\");\n\n\trfx_message_free(context, message);\n\treturn NULL;\n}\n\nstatic BOOL rfx_clone_rects(RFX_MESSAGE* dst, const RFX_MESSAGE* src)\n{\n\tWINPR_ASSERT(dst);\n\tWINPR_ASSERT(src);\n\n\tWINPR_ASSERT(dst->rects == NULL);\n\tWINPR_ASSERT(dst->numRects == 0);\n\n\tif (src->numRects == 0)\n\t\treturn TRUE;\n\n\tdst->rects = winpr_aligned_calloc(src->numRects, sizeof(RECTANGLE_16), 32);\n\tif (!dst->rects)\n\t\treturn FALSE;\n\tdst->numRects = src->numRects;\n\tfor (size_t x = 0; x < src->numRects; x++)\n\t{\n\t\tdst->rects[x] = src->rects[x];\n\t}\n\treturn TRUE;\n}\n\nstatic BOOL rfx_clone_quants(RFX_MESSAGE* dst, const RFX_MESSAGE* src)\n{\n\tWINPR_ASSERT(dst);\n\tWINPR_ASSERT(src);\n\n\tWINPR_ASSERT(dst->quantVals == NULL);\n\tWINPR_ASSERT(dst->numQuant == 0);\n\n\tif (src->numQuant == 0)\n\t\treturn TRUE;\n\n\t/* quantVals are part of context */\n\tdst->quantVals = src->quantVals;\n\tdst->numQuant = src->numQuant;\n\n\treturn TRUE;\n}\n\nstatic RFX_MESSAGE* rfx_split_message(RFX_CONTEXT* context, RFX_MESSAGE* message,\n                                      size_t* numMessages, size_t maxDataSize)\n{\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(numMessages);\n\n\tmaxDataSize -= 1024; /* reserve enough space for headers */\n\t*numMessages = ((message->tilesDataSize + maxDataSize) / maxDataSize) * 4ull;\n\n\tRFX_MESSAGE* messages =\n\t    (RFX_MESSAGE*)winpr_aligned_calloc((*numMessages), sizeof(RFX_MESSAGE), 32);\n\tif (!messages)\n\t\treturn NULL;\n\n\tsize_t j = 0;\n\tfor (size_t i = 0; i < message->numTiles; i++)\n\t{\n\t\tRFX_TILE* tile = message->tiles[i];\n\t\tRFX_MESSAGE* msg = &messages[j];\n\n\t\tWINPR_ASSERT(tile);\n\t\tWINPR_ASSERT(msg);\n\n\t\tconst size_t tileDataSize = rfx_tile_length(tile);\n\n\t\tif ((msg->tilesDataSize + tileDataSize) > ((UINT32)maxDataSize))\n\t\t\tj++;\n\n\t\tif (msg->numTiles == 0)\n\t\t{\n\t\t\tmsg->frameIdx = message->frameIdx + j;\n\t\t\tif (!rfx_clone_quants(msg, message))\n\t\t\t\tgoto free_messages;\n\t\t\tif (!rfx_clone_rects(msg, message))\n\t\t\t\tgoto free_messages;\n\t\t\tmsg->freeArray = TRUE;\n\t\t\tif (!rfx_allocate_tiles(msg, message->numTiles, TRUE))\n\t\t\t\tgoto free_messages;\n\t\t}\n\n\t\tmsg->tilesDataSize += tileDataSize;\n\n\t\tWINPR_ASSERT(msg->numTiles < msg->allocatedTiles);\n\t\tmsg->tiles[msg->numTiles++] = message->tiles[i];\n\t\tmessage->tiles[i] = NULL;\n\t}\n\n\t*numMessages = j + 1;\n\tcontext->frameIdx += j;\n\tmessage->numTiles = 0;\n\treturn messages;\nfree_messages:\n\n\tfor (size_t i = 0; i < j; i++)\n\t\trfx_allocate_tiles(&messages[i], 0, FALSE);\n\n\twinpr_aligned_free(messages);\n\treturn NULL;\n}\n\nconst RFX_MESSAGE* rfx_message_list_get(const RFX_MESSAGE_LIST* messages, size_t idx)\n{\n\tWINPR_ASSERT(messages);\n\tif (idx >= messages->count)\n\t\treturn NULL;\n\tWINPR_ASSERT(messages->list);\n\treturn &messages->list[idx];\n}\n\nvoid rfx_message_list_free(RFX_MESSAGE_LIST* messages)\n{\n\tif (!messages)\n\t\treturn;\n\tfor (size_t x = 0; x < messages->count; x++)\n\t\trfx_message_free(messages->context, &messages->list[x]);\n\tfree(messages);\n}\n\nstatic RFX_MESSAGE_LIST* rfx_message_list_new(RFX_CONTEXT* context, RFX_MESSAGE* messages,\n                                              size_t count)\n{\n\tWINPR_ASSERT(context);\n\tRFX_MESSAGE_LIST* msg = calloc(1, sizeof(RFX_MESSAGE_LIST));\n\tWINPR_ASSERT(msg);\n\n\tmsg->context = context;\n\tmsg->count = count;\n\tmsg->list = messages;\n\treturn msg;\n}\n\nRFX_MESSAGE_LIST* rfx_encode_messages(RFX_CONTEXT* context, const RFX_RECT* rects, size_t numRects,\n                                      const BYTE* data, UINT32 width, UINT32 height,\n                                      UINT32 scanline, size_t* numMessages, size_t maxDataSize)\n{\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(numMessages);\n\n\tRFX_MESSAGE* message =\n\t    rfx_encode_message(context, rects, numRects, data, width, height, scanline);\n\tif (!message)\n\t\treturn NULL;\n\n\tRFX_MESSAGE* list = rfx_split_message(context, message, numMessages, maxDataSize);\n\trfx_message_free(context, message);\n\tif (!list)\n\t\treturn NULL;\n\n\treturn rfx_message_list_new(context, list, *numMessages);\n}\n\nstatic BOOL rfx_write_message_tileset(RFX_CONTEXT* context, wStream* s, const RFX_MESSAGE* message)\n{\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(message);\n\n\tconst UINT32 blockLen = 22 + (message->numQuant * 5) + message->tilesDataSize;\n\n\tif (!Stream_EnsureRemainingCapacity(s, blockLen))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, WBT_EXTENSION);          /* CodecChannelT.blockType (2 bytes) */\n\tStream_Write_UINT32(s, blockLen);               /* set CodecChannelT.blockLen (4 bytes) */\n\tStream_Write_UINT8(s, 1);                       /* CodecChannelT.codecId (1 byte) */\n\tStream_Write_UINT8(s, 0);                       /* CodecChannelT.channelId (1 byte) */\n\tStream_Write_UINT16(s, CBT_TILESET);            /* subtype (2 bytes) */\n\tStream_Write_UINT16(s, 0);                      /* idx (2 bytes) */\n\tStream_Write_UINT16(s, context->properties);    /* properties (2 bytes) */\n\tStream_Write_UINT8(s, message->numQuant);       /* numQuant (1 byte) */\n\tStream_Write_UINT8(s, 0x40);                    /* tileSize (1 byte) */\n\tStream_Write_UINT16(s, message->numTiles);      /* numTiles (2 bytes) */\n\tStream_Write_UINT32(s, message->tilesDataSize); /* tilesDataSize (4 bytes) */\n\n\tUINT32* quantVals = message->quantVals;\n\tfor (size_t i = 0; i < message->numQuant * 5ul; i++)\n\t{\n\t\tWINPR_ASSERT(quantVals);\n\t\tStream_Write_UINT8(s, quantVals[0] + (quantVals[1] << 4));\n\t\tquantVals += 2;\n\t}\n\n\tfor (size_t i = 0; i < message->numTiles; i++)\n\t{\n\t\tRFX_TILE* tile = message->tiles[i];\n\t\tif (!tile)\n\t\t\treturn FALSE;\n\n\t\tif (!rfx_write_tile(s, tile))\n\t\t\treturn FALSE;\n\t}\n\n#ifdef WITH_DEBUG_RFX\n\tWLog_Print(context->priv->log, WLOG_DEBUG,\n\t           \"numQuant: %\" PRIu16 \" numTiles: %\" PRIu16 \" tilesDataSize: %\" PRIu32 \"\",\n\t           message->numQuant, message->numTiles, message->tilesDataSize);\n#endif\n\treturn TRUE;\n}\n\nstatic BOOL rfx_write_message_frame_begin(RFX_CONTEXT* context, wStream* s,\n                                          const RFX_MESSAGE* message)\n{\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(message);\n\n\tif (!Stream_EnsureRemainingCapacity(s, 14))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, WBT_FRAME_BEGIN);   /* CodecChannelT.blockType */\n\tStream_Write_UINT32(s, 14);                /* CodecChannelT.blockLen */\n\tStream_Write_UINT8(s, 1);                  /* CodecChannelT.codecId */\n\tStream_Write_UINT8(s, 0);                  /* CodecChannelT.channelId */\n\tStream_Write_UINT32(s, message->frameIdx); /* frameIdx */\n\tStream_Write_UINT16(s, 1);                 /* numRegions */\n\treturn TRUE;\n}\n\nstatic BOOL rfx_write_message_region(RFX_CONTEXT* context, wStream* s, const RFX_MESSAGE* message)\n{\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(message);\n\n\tconst size_t blockLen = 15 + (message->numRects * 8);\n\n\tif (!Stream_EnsureRemainingCapacity(s, blockLen))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, WBT_REGION);        /* CodecChannelT.blockType (2 bytes) */\n\tStream_Write_UINT32(s, blockLen);          /* set CodecChannelT.blockLen (4 bytes) */\n\tStream_Write_UINT8(s, 1);                  /* CodecChannelT.codecId (1 byte) */\n\tStream_Write_UINT8(s, 0);                  /* CodecChannelT.channelId (1 byte) */\n\tStream_Write_UINT8(s, 1);                  /* regionFlags (1 byte) */\n\tStream_Write_UINT16(s, message->numRects); /* numRects (2 bytes) */\n\n\tfor (size_t i = 0; i < message->numRects; i++)\n\t{\n\t\tconst RFX_RECT* rect = rfx_message_get_rect_const(message, i);\n\t\tWINPR_ASSERT(rect);\n\n\t\t/* Clipping rectangles are relative to destLeft, destTop */\n\t\tStream_Write_UINT16(s, rect->x);      /* x (2 bytes) */\n\t\tStream_Write_UINT16(s, rect->y);      /* y (2 bytes) */\n\t\tStream_Write_UINT16(s, rect->width);  /* width (2 bytes) */\n\t\tStream_Write_UINT16(s, rect->height); /* height (2 bytes) */\n\t}\n\n\tStream_Write_UINT16(s, CBT_REGION); /* regionType (2 bytes) */\n\tStream_Write_UINT16(s, 1);          /* numTilesets (2 bytes) */\n\treturn TRUE;\n}\n\nstatic BOOL rfx_write_message_frame_end(RFX_CONTEXT* context, wStream* s,\n                                        const RFX_MESSAGE* message)\n{\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(message);\n\n\tif (!Stream_EnsureRemainingCapacity(s, 8))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, WBT_FRAME_END); /* CodecChannelT.blockType */\n\tStream_Write_UINT32(s, 8);             /* CodecChannelT.blockLen */\n\tStream_Write_UINT8(s, 1);              /* CodecChannelT.codecId */\n\tStream_Write_UINT8(s, 0);              /* CodecChannelT.channelId */\n\treturn TRUE;\n}\n\nBOOL rfx_write_message(RFX_CONTEXT* context, wStream* s, const RFX_MESSAGE* message)\n{\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(message);\n\n\tif (context->state == RFX_STATE_SEND_HEADERS)\n\t{\n\t\tif (!rfx_compose_message_header(context, s))\n\t\t\treturn FALSE;\n\n\t\tcontext->state = RFX_STATE_SEND_FRAME_DATA;\n\t}\n\n\tif (!rfx_write_message_frame_begin(context, s, message) ||\n\t    !rfx_write_message_region(context, s, message) ||\n\t    !rfx_write_message_tileset(context, s, message) ||\n\t    !rfx_write_message_frame_end(context, s, message))\n\t{\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nBOOL rfx_compose_message(RFX_CONTEXT* context, wStream* s, const RFX_RECT* rects, size_t numRects,\n                         const BYTE* data, UINT32 width, UINT32 height, UINT32 scanline)\n{\n\tWINPR_ASSERT(context);\n\tRFX_MESSAGE* message =\n\t    rfx_encode_message(context, rects, numRects, data, width, height, scanline);\n\tif (!message)\n\t\treturn FALSE;\n\n\tconst BOOL ret = rfx_write_message(context, s, message);\n\trfx_message_free(context, message);\n\treturn ret;\n}\n\nBOOL rfx_context_set_mode(RFX_CONTEXT* context, RLGR_MODE mode)\n{\n\tWINPR_ASSERT(context);\n\tcontext->mode = mode;\n\treturn TRUE;\n}\n\nUINT32 rfx_context_get_frame_idx(const RFX_CONTEXT* context)\n{\n\tWINPR_ASSERT(context);\n\treturn context->frameIdx;\n}\n\nUINT32 rfx_message_get_frame_idx(const RFX_MESSAGE* message)\n{\n\tWINPR_ASSERT(message);\n\treturn message->frameIdx;\n}\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RemoteFX Codec Library\n *\n * Copyright 2011 Vic Lee\n * Copyright 2015 Thincast Technologies GmbH\n * Copyright 2015 Norbert Federa <norbert.federa@thincast.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <freerdp/config.h>\n\n#include <winpr/assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/crt.h>\n#include <winpr/tchar.h>\n#include <winpr/sysinfo.h>\n#include <winpr/registry.h>\n#include <winpr/tchar.h>\n\n#include <freerdp/log.h>\n#include <freerdp/settings.h>\n#include <freerdp/codec/rfx.h>\n#include <freerdp/constants.h>\n#include <freerdp/primitives.h>\n#include <freerdp/codec/region.h>\n#include <freerdp/build-config.h>\n#include <freerdp/codec/region.h>\n\n#include \"rfx_constants.h\"\n#include \"rfx_types.h\"\n#include \"rfx_decode.h\"\n#include \"rfx_encode.h\"\n#include \"rfx_quantization.h\"\n#include \"rfx_dwt.h\"\n#include \"rfx_rlgr.h\"\n\n#include \"rfx_sse2.h\"\n#include \"rfx_neon.h\"\n\n#define TAG FREERDP_TAG(\"codec\")\n\n#ifndef RFX_INIT_SIMD\n#define RFX_INIT_SIMD(_rfx_context) \\\n\tdo                              \\\n\t{                               \\\n\t} while (0)\n#endif\n\n#define RFX_KEY \"Software\\\\\" FREERDP_VENDOR_STRING \"\\\\\" FREERDP_PRODUCT_STRING \"\\\\RemoteFX\"\n\n/**\n * The quantization values control the compression rate and quality. The value\n * range is between 6 and 15. The higher value, the higher compression rate\n * and lower quality.\n *\n * This is the default values being use by the MS RDP server, and we will also\n * use it as our default values for the encoder. It can be overrided by setting\n * the context->num_quants and context->quants member.\n *\n * The order of the values are:\n * LL3, LH3, HL3, HH3, LH2, HL2, HH2, LH1, HL1, HH1\n */\nstatic const UINT32 rfx_default_quantization_values[] = { 6, 6, 6, 6, 7, 7, 8, 8, 8, 9 };\n\nstatic void rfx_profiler_create(RFX_CONTEXT* context)\n{\n\tif (!context || !context->priv)\n\t\treturn;\n\tPROFILER_CREATE(context->priv->prof_rfx_decode_rgb, \"rfx_decode_rgb\")\n\tPROFILER_CREATE(context->priv->prof_rfx_decode_component, \"rfx_decode_component\")\n\tPROFILER_CREATE(context->priv->prof_rfx_rlgr_decode, \"rfx_rlgr_decode\")\n\tPROFILER_CREATE(context->priv->prof_rfx_differential_decode, \"rfx_differential_decode\")\n\tPROFILER_CREATE(context->priv->prof_rfx_quantization_decode, \"rfx_quantization_decode\")\n\tPROFILER_CREATE(context->priv->prof_rfx_dwt_2d_decode, \"rfx_dwt_2d_decode\")\n\tPROFILER_CREATE(context->priv->prof_rfx_ycbcr_to_rgb, \"prims->yCbCrToRGB\")\n\tPROFILER_CREATE(context->priv->prof_rfx_encode_rgb, \"rfx_encode_rgb\")\n\tPROFILER_CREATE(context->priv->prof_rfx_encode_component, \"rfx_encode_component\")\n\tPROFILER_CREATE(context->priv->prof_rfx_rlgr_encode, \"rfx_rlgr_encode\")\n\tPROFILER_CREATE(context->priv->prof_rfx_differential_encode, \"rfx_differential_encode\")\n\tPROFILER_CREATE(context->priv->prof_rfx_quantization_encode, \"rfx_quantization_encode\")\n\tPROFILER_CREATE(context->priv->prof_rfx_dwt_2d_encode, \"rfx_dwt_2d_encode\")\n\tPROFILER_CREATE(context->priv->prof_rfx_rgb_to_ycbcr, \"prims->RGBToYCbCr\")\n\tPROFILER_CREATE(context->priv->prof_rfx_encode_format_rgb, \"rfx_encode_format_rgb\")\n}\n\nstatic void rfx_profiler_free(RFX_CONTEXT* context)\n{\n\tif (!context || !context->priv)\n\t\treturn;\n\tPROFILER_FREE(context->priv->prof_rfx_decode_rgb)\n\tPROFILER_FREE(context->priv->prof_rfx_decode_component)\n\tPROFILER_FREE(context->priv->prof_rfx_rlgr_decode)\n\tPROFILER_FREE(context->priv->prof_rfx_differential_decode)\n\tPROFILER_FREE(context->priv->prof_rfx_quantization_decode)\n\tPROFILER_FREE(context->priv->prof_rfx_dwt_2d_decode)\n\tPROFILER_FREE(context->priv->prof_rfx_ycbcr_to_rgb)\n\tPROFILER_FREE(context->priv->prof_rfx_encode_rgb)\n\tPROFILER_FREE(context->priv->prof_rfx_encode_component)\n\tPROFILER_FREE(context->priv->prof_rfx_rlgr_encode)\n\tPROFILER_FREE(context->priv->prof_rfx_differential_encode)\n\tPROFILER_FREE(context->priv->prof_rfx_quantization_encode)\n\tPROFILER_FREE(context->priv->prof_rfx_dwt_2d_encode)\n\tPROFILER_FREE(context->priv->prof_rfx_rgb_to_ycbcr)\n\tPROFILER_FREE(context->priv->prof_rfx_encode_format_rgb)\n}\n\nstatic void rfx_profiler_print(RFX_CONTEXT* context)\n{\n\tif (!context || !context->priv)\n\t\treturn;\n\n\tPROFILER_PRINT_HEADER\n\tPROFILER_PRINT(context->priv->prof_rfx_decode_rgb)\n\tPROFILER_PRINT(context->priv->prof_rfx_decode_component)\n\tPROFILER_PRINT(context->priv->prof_rfx_rlgr_decode)\n\tPROFILER_PRINT(context->priv->prof_rfx_differential_decode)\n\tPROFILER_PRINT(context->priv->prof_rfx_quantization_decode)\n\tPROFILER_PRINT(context->priv->prof_rfx_dwt_2d_decode)\n\tPROFILER_PRINT(context->priv->prof_rfx_ycbcr_to_rgb)\n\tPROFILER_PRINT(context->priv->prof_rfx_encode_rgb)\n\tPROFILER_PRINT(context->priv->prof_rfx_encode_component)\n\tPROFILER_PRINT(context->priv->prof_rfx_rlgr_encode)\n\tPROFILER_PRINT(context->priv->prof_rfx_differential_encode)\n\tPROFILER_PRINT(context->priv->prof_rfx_quantization_encode)\n\tPROFILER_PRINT(context->priv->prof_rfx_dwt_2d_encode)\n\tPROFILER_PRINT(context->priv->prof_rfx_rgb_to_ycbcr)\n\tPROFILER_PRINT(context->priv->prof_rfx_encode_format_rgb)\n\tPROFILER_PRINT_FOOTER\n}\n\nstatic void rfx_tile_init(void* obj)\n{\n\tRFX_TILE* tile = (RFX_TILE*)obj;\n\tif (tile)\n\t{\n\t\ttile->x = 0;\n\t\ttile->y = 0;\n\t\ttile->YLen = 0;\n\t\ttile->YData = NULL;\n\t\ttile->CbLen = 0;\n\t\ttile->CbData = NULL;\n\t\ttile->CrLen = 0;\n\t\ttile->CrData = NULL;\n\t}\n}\n\nstatic void* rfx_decoder_tile_new(const void* val)\n{\n\tconst size_t size = 4 * 64 * 64;\n\tRFX_TILE* tile = NULL;\n\tWINPR_UNUSED(val);\n\n\tif (!(tile = (RFX_TILE*)winpr_aligned_calloc(1, sizeof(RFX_TILE), 32)))\n\t\treturn NULL;\n\n\tif (!(tile->data = (BYTE*)winpr_aligned_malloc(size, 16)))\n\t{\n\t\twinpr_aligned_free(tile);\n\t\treturn NULL;\n\t}\n\tmemset(tile->data, 0xff, size);\n\ttile->allocated = TRUE;\n\treturn tile;\n}\n\nstatic void rfx_decoder_tile_free(void* obj)\n{\n\tRFX_TILE* tile = (RFX_TILE*)obj;\n\n\tif (tile)\n\t{\n\t\tif (tile->allocated)\n\t\t\twinpr_aligned_free(tile->data);\n\n\t\twinpr_aligned_free(tile);\n\t}\n}\n\nstatic void* rfx_encoder_tile_new(const void* val)\n{\n\tWINPR_UNUSED(val);\n\treturn winpr_aligned_calloc(1, sizeof(RFX_TILE), 32);\n}\n\nstatic void rfx_encoder_tile_free(void* obj)\n{\n\twinpr_aligned_free(obj);\n}\n\nRFX_CONTEXT* rfx_context_new(BOOL encoder)\n{\n\treturn rfx_context_new_ex(encoder, 0);\n}\n\nRFX_CONTEXT* rfx_context_new_ex(BOOL encoder, UINT32 ThreadingFlags)\n{\n\tHKEY hKey;\n\tLONG status;\n\tDWORD dwType;\n\tDWORD dwSize;\n\tDWORD dwValue;\n\tSYSTEM_INFO sysinfo;\n\tRFX_CONTEXT* context;\n\twObject* pool;\n\tRFX_CONTEXT_PRIV* priv;\n\tcontext = (RFX_CONTEXT*)winpr_aligned_calloc(1, sizeof(RFX_CONTEXT), 32);\n\n\tif (!context)\n\t\treturn NULL;\n\n\tcontext->encoder = encoder;\n\tcontext->currentMessage.freeArray = TRUE;\n\tcontext->priv = priv = (RFX_CONTEXT_PRIV*)winpr_aligned_calloc(1, sizeof(RFX_CONTEXT_PRIV), 32);\n\n\tif (!priv)\n\t\tgoto fail;\n\n\tpriv->log = WLog_Get(\"com.freerdp.codec.rfx\");\n\tWLog_OpenAppender(priv->log);\n\tpriv->TilePool = ObjectPool_New(TRUE);\n\n\tif (!priv->TilePool)\n\t\tgoto fail;\n\n\tpool = ObjectPool_Object(priv->TilePool);\n\tpool->fnObjectInit = rfx_tile_init;\n\n\tif (context->encoder)\n\t{\n\t\tpool->fnObjectNew = rfx_encoder_tile_new;\n\t\tpool->fnObjectFree = rfx_encoder_tile_free;\n\t}\n\telse\n\t{\n\t\tpool->fnObjectNew = rfx_decoder_tile_new;\n\t\tpool->fnObjectFree = rfx_decoder_tile_free;\n\t}\n\n\t/*\n\t * align buffers to 16 byte boundary (needed for SSE/NEON instructions)\n\t *\n\t * y_r_buffer, cb_g_buffer, cr_b_buffer: 64 * 64 * sizeof(INT16) = 8192 (0x2000)\n\t * dwt_buffer: 32 * 32 * 2 * 2 * sizeof(INT16) = 8192, maximum sub-band width is 32\n\t *\n\t * Additionally we add 32 bytes (16 in front and 16 at the back of the buffer)\n\t * in order to allow optimized functions (SEE, NEON) to read from positions\n\t * that are actually in front/beyond the buffer. Offset calculations are\n\t * performed at the BufferPool_Take function calls in rfx_encode/decode.c.\n\t *\n\t * We then multiply by 3 to use a single, partioned buffer for all 3 channels.\n\t */\n\tpriv->BufferPool = BufferPool_New(TRUE, (8192 + 32) * 3, 16);\n\n\tif (!priv->BufferPool)\n\t\tgoto fail;\n\n\tif (!(ThreadingFlags & THREADING_FLAGS_DISABLE_THREADS))\n\t{\n\t\tpriv->UseThreads = TRUE;\n\n\t\tGetNativeSystemInfo(&sysinfo);\n\t\tpriv->MinThreadCount = sysinfo.dwNumberOfProcessors;\n\t\tpriv->MaxThreadCount = 0;\n\t\tstatus = RegOpenKeyExA(HKEY_LOCAL_MACHINE, RFX_KEY, 0, KEY_READ | KEY_WOW64_64KEY, &hKey);\n\n\t\tif (status == ERROR_SUCCESS)\n\t\t{\n\t\t\tdwSize = sizeof(dwValue);\n\n\t\t\tif (RegQueryValueEx(hKey, _T(\"UseThreads\"), NULL, &dwType, (BYTE*)&dwValue, &dwSize) ==\n\t\t\t    ERROR_SUCCESS)\n\t\t\t\tpriv->UseThreads = dwValue ? 1 : 0;\n\n\t\t\tif (RegQueryValueEx(hKey, _T(\"MinThreadCount\"), NULL, &dwType, (BYTE*)&dwValue,\n\t\t\t                    &dwSize) == ERROR_SUCCESS)\n\t\t\t\tpriv->MinThreadCount = dwValue;\n\n\t\t\tif (RegQueryValueEx(hKey, _T(\"MaxThreadCount\"), NULL, &dwType, (BYTE*)&dwValue,\n\t\t\t                    &dwSize) == ERROR_SUCCESS)\n\t\t\t\tpriv->MaxThreadCount = dwValue;\n\n\t\t\tRegCloseKey(hKey);\n\t\t}\n\t}\n\telse\n\t{\n\t\tpriv->UseThreads = FALSE;\n\t}\n\n\tif (priv->UseThreads)\n\t{\n\t\t/* Call primitives_get here in order to avoid race conditions when using primitives_get */\n\t\t/* from multiple threads. This call will initialize all function pointers correctly     */\n\t\t/* before any decoding threads are started */\n\t\tprimitives_get();\n\t\tpriv->ThreadPool = CreateThreadpool(NULL);\n\n\t\tif (!priv->ThreadPool)\n\t\t\tgoto fail;\n\n\t\tInitializeThreadpoolEnvironment(&priv->ThreadPoolEnv);\n\t\tSetThreadpoolCallbackPool(&priv->ThreadPoolEnv, priv->ThreadPool);\n\n\t\tif (priv->MinThreadCount)\n\t\t\tif (!SetThreadpoolThreadMinimum(priv->ThreadPool, priv->MinThreadCount))\n\t\t\t\tgoto fail;\n\n\t\tif (priv->MaxThreadCount)\n\t\t\tSetThreadpoolThreadMaximum(priv->ThreadPool, priv->MaxThreadCount);\n\t}\n\n\t/* initialize the default pixel format */\n\trfx_context_set_pixel_format(context, PIXEL_FORMAT_BGRX32);\n\t/* create profilers for default decoding routines */\n\trfx_profiler_create(context);\n\t/* set up default routines */\n\tcontext->quantization_decode = rfx_quantization_decode;\n\tcontext->quantization_encode = rfx_quantization_encode;\n\tcontext->dwt_2d_decode = rfx_dwt_2d_decode;\n\tcontext->dwt_2d_encode = rfx_dwt_2d_encode;\n\tcontext->rlgr_decode = rfx_rlgr_decode;\n\tcontext->rlgr_encode = rfx_rlgr_encode;\n\tRFX_INIT_SIMD(context);\n\tcontext->state = RFX_STATE_SEND_HEADERS;\n\tcontext->expectedDataBlockType = WBT_FRAME_BEGIN;\n\treturn context;\nfail:\n\trfx_context_free(context);\n\treturn NULL;\n}\n\nvoid rfx_context_free(RFX_CONTEXT* context)\n{\n\tRFX_CONTEXT_PRIV* priv;\n\n\tif (!context)\n\t\treturn;\n\n\tWINPR_ASSERT(NULL != context);\n\n\tpriv = context->priv;\n\tWINPR_ASSERT(NULL != priv);\n\tWINPR_ASSERT(NULL != priv->TilePool);\n\tWINPR_ASSERT(NULL != priv->BufferPool);\n\n\t/* coverity[address_free] */\n\trfx_message_free(context, &context->currentMessage);\n\twinpr_aligned_free(context->quants);\n\trfx_profiler_print(context);\n\trfx_profiler_free(context);\n\n\tif (priv)\n\t{\n\t\tObjectPool_Free(priv->TilePool);\n\t\tif (priv->UseThreads)\n\t\t{\n\t\t\tif (priv->ThreadPool)\n\t\t\t\tCloseThreadpool(priv->ThreadPool);\n\t\t\tDestroyThreadpoolEnvironment(&priv->ThreadPoolEnv);\n\t\t\twinpr_aligned_free(priv->workObjects);\n\t\t\twinpr_aligned_free(priv->tileWorkParams);\n#ifdef WITH_PROFILER\n\t\t\tWLog_VRB(\n\t\t\t    TAG,\n\t\t\t    \"WARNING: Profiling results probably unusable with multithreaded RemoteFX codec!\");\n#endif\n\t\t}\n\n\t\tBufferPool_Free(priv->BufferPool);\n\t\twinpr_aligned_free(priv);\n\t}\n\twinpr_aligned_free(context);\n}\n\nstatic RFX_TILE* rfx_message_get_tile(RFX_MESSAGE* message, UINT32 index)\n{\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(message->tiles);\n\tWINPR_ASSERT(index < message->numTiles);\n\treturn message->tiles[index];\n}\n\nstatic const RFX_RECT* rfx_message_get_rect_const(const RFX_MESSAGE* message, UINT32 index)\n{\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(message->rects);\n\tWINPR_ASSERT(index < message->numRects);\n\treturn &message->rects[index];\n}\n\nstatic RFX_RECT* rfx_message_get_rect(RFX_MESSAGE* message, UINT32 index)\n{\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(message->rects);\n\tWINPR_ASSERT(index < message->numRects);\n\treturn &message->rects[index];\n}\n\nvoid rfx_context_set_pixel_format(RFX_CONTEXT* context, UINT32 pixel_format)\n{\n\tWINPR_ASSERT(context);\n\tcontext->pixel_format = pixel_format;\n\tcontext->bits_per_pixel = FreeRDPGetBitsPerPixel(pixel_format);\n}\n\nvoid rfx_context_set_palette(RFX_CONTEXT* context, const BYTE* palette)\n{\n\tWINPR_ASSERT(context);\n\tcontext->palette = palette;\n}\n\nBOOL rfx_context_reset(RFX_CONTEXT* context, UINT32 width, UINT32 height)\n{\n\tif (!context)\n\t\treturn FALSE;\n\n\tcontext->width = width;\n\tcontext->height = height;\n\tcontext->state = RFX_STATE_SEND_HEADERS;\n\tcontext->expectedDataBlockType = WBT_FRAME_BEGIN;\n\tcontext->frameIdx = 0;\n\treturn TRUE;\n}\n\nstatic BOOL rfx_process_message_sync(RFX_CONTEXT* context, wStream* s)\n{\n\tUINT32 magic;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tcontext->decodedHeaderBlocks &= ~RFX_DECODED_SYNC;\n\n\t/* RFX_SYNC */\n\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 6))\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, magic); /* magic (4 bytes), 0xCACCACCA */\n\tif (magic != WF_MAGIC)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid magic number 0x%08\" PRIX32 \"\", magic);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, context->version); /* version (2 bytes), WF_VERSION_1_0 (0x0100) */\n\tif (context->version != WF_VERSION_1_0)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid version number 0x%08\" PRIX32 \"\",\n\t\t           context->version);\n\t\treturn FALSE;\n\t}\n\n\tWLog_Print(context->priv->log, WLOG_DEBUG, \"version 0x%08\" PRIX32 \"\", context->version);\n\tcontext->decodedHeaderBlocks |= RFX_DECODED_SYNC;\n\treturn TRUE;\n}\n\nstatic BOOL rfx_process_message_codec_versions(RFX_CONTEXT* context, wStream* s)\n{\n\tBYTE numCodecs;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tcontext->decodedHeaderBlocks &= ~RFX_DECODED_VERSIONS;\n\n\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 4))\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, numCodecs);         /* numCodecs (1 byte), must be set to 0x01 */\n\tStream_Read_UINT8(s, context->codec_id); /* codecId (1 byte), must be set to 0x01 */\n\tStream_Read_UINT16(\n\t    s, context->codec_version); /* version (2 bytes), must be set to WF_VERSION_1_0 (0x0100)  */\n\n\tif (numCodecs != 1)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"numCodes is 0x%02\" PRIX8 \" (must be 0x01)\",\n\t\t           numCodecs);\n\t\treturn FALSE;\n\t}\n\n\tif (context->codec_id != 0x01)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid codec id (0x%02\" PRIX32 \")\",\n\t\t           context->codec_id);\n\t\treturn FALSE;\n\t}\n\n\tif (context->codec_version != WF_VERSION_1_0)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid codec version (0x%08\" PRIX32 \")\",\n\t\t           context->codec_version);\n\t\treturn FALSE;\n\t}\n\n\tWLog_Print(context->priv->log, WLOG_DEBUG, \"id %\" PRIu32 \" version 0x%\" PRIX32 \".\",\n\t           context->codec_id, context->codec_version);\n\tcontext->decodedHeaderBlocks |= RFX_DECODED_VERSIONS;\n\treturn TRUE;\n}\n\nstatic BOOL rfx_process_message_channels(RFX_CONTEXT* context, wStream* s)\n{\n\tBYTE channelId;\n\tBYTE numChannels;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tcontext->decodedHeaderBlocks &= ~RFX_DECODED_CHANNELS;\n\n\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 1))\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, numChannels); /* numChannels (1 byte), must bet set to 0x01 */\n\n\t/* In RDVH sessions, numChannels will represent the number of virtual monitors\n\t * configured and does not always be set to 0x01 as [MS-RDPRFX] said.\n\t */\n\tif (numChannels < 1)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"no channels announced\");\n\t\treturn FALSE;\n\t}\n\n\tif (!Stream_CheckAndLogRequiredLengthOfSizeWLog(context->priv->log, s, numChannels, 5ull))\n\t\treturn FALSE;\n\n\t/* RFX_CHANNELT */\n\tStream_Read_UINT8(s, channelId); /* channelId (1 byte), must be set to 0x00 */\n\n\tif (channelId != 0x00)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"channelId:0x%02\" PRIX8 \", expected:0x00\",\n\t\t           channelId);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, context->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, context->height); /* height (2 bytes) */\n\n\tif (!context->width || !context->height)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR,\n\t\t           \"invalid channel with/height: %\" PRIu16 \"x%\" PRIu16 \"\", context->width,\n\t\t           context->height);\n\t\treturn FALSE;\n\t}\n\n\t/* Now, only the first monitor can be used, therefore the other channels will be ignored. */\n\tStream_Seek(s, 5 * (numChannels - 1));\n\tWLog_Print(context->priv->log, WLOG_DEBUG,\n\t           \"numChannels %\" PRIu8 \" id %\" PRIu8 \", %\" PRIu16 \"x%\" PRIu16 \".\", numChannels,\n\t           channelId, context->width, context->height);\n\tcontext->decodedHeaderBlocks |= RFX_DECODED_CHANNELS;\n\treturn TRUE;\n}\n\nstatic BOOL rfx_process_message_context(RFX_CONTEXT* context, wStream* s)\n{\n\tBYTE ctxId;\n\tUINT16 tileSize;\n\tUINT16 properties;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tcontext->decodedHeaderBlocks &= ~RFX_DECODED_CONTEXT;\n\n\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 5))\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, ctxId);     /* ctxId (1 byte), must be set to 0x00 */\n\tStream_Read_UINT16(s, tileSize); /* tileSize (2 bytes), must be set to CT_TILE_64x64 (0x0040) */\n\tStream_Read_UINT16(s, properties); /* properties (2 bytes) */\n\tWLog_Print(context->priv->log, WLOG_DEBUG,\n\t           \"ctxId %\" PRIu8 \" tileSize %\" PRIu16 \" properties 0x%04\" PRIX16 \".\", ctxId, tileSize,\n\t           properties);\n\tcontext->properties = properties;\n\tcontext->flags = (properties & 0x0007);\n\n\tif (context->flags == CODEC_MODE)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_DEBUG, \"codec is in image mode.\");\n\t}\n\telse\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_DEBUG, \"codec is in video mode.\");\n\t}\n\n\tswitch ((properties & 0x1E00) >> 9)\n\t{\n\t\tcase CLW_ENTROPY_RLGR1:\n\t\t\tcontext->mode = RLGR1;\n\t\t\tWLog_Print(context->priv->log, WLOG_DEBUG, \"RLGR1.\");\n\t\t\tbreak;\n\n\t\tcase CLW_ENTROPY_RLGR3:\n\t\t\tcontext->mode = RLGR3;\n\t\t\tWLog_Print(context->priv->log, WLOG_DEBUG, \"RLGR3.\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"unknown RLGR algorithm.\");\n\t\t\treturn FALSE;\n\t}\n\n\tcontext->decodedHeaderBlocks |= RFX_DECODED_CONTEXT;\n\treturn TRUE;\n}\n\nstatic BOOL rfx_process_message_frame_begin(RFX_CONTEXT* context, RFX_MESSAGE* message, wStream* s,\n                                            UINT16* pExpectedBlockType)\n{\n\tUINT32 frameIdx;\n\tUINT16 numRegions;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_BEGIN)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_FRAME_BEGIN\");\n\t\treturn FALSE;\n\t}\n\n\t*pExpectedBlockType = WBT_REGION;\n\n\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 6))\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(\n\t    s, frameIdx); /* frameIdx (4 bytes), if codec is in video mode, must be ignored */\n\tStream_Read_UINT16(s, numRegions); /* numRegions (2 bytes) */\n\tWLog_Print(context->priv->log, WLOG_DEBUG,\n\t           \"RFX_FRAME_BEGIN: frameIdx: %\" PRIu32 \" numRegions: %\" PRIu16 \"\", frameIdx,\n\t           numRegions);\n\treturn TRUE;\n}\n\nstatic BOOL rfx_process_message_frame_end(RFX_CONTEXT* context, RFX_MESSAGE* message, wStream* s,\n                                          UINT16* pExpectedBlockType)\n{\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_FRAME_END)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected, wants WBT_FRAME_END\");\n\t\treturn FALSE;\n\t}\n\n\t*pExpectedBlockType = WBT_FRAME_BEGIN;\n\tWLog_Print(context->priv->log, WLOG_DEBUG, \"RFX_FRAME_END\");\n\treturn TRUE;\n}\n\nstatic BOOL rfx_resize_rects(RFX_MESSAGE* message)\n{\n\tWINPR_ASSERT(message);\n\n\tRFX_RECT* tmpRects =\n\t    winpr_aligned_recalloc(message->rects, message->numRects, sizeof(RFX_RECT), 32);\n\tif (!tmpRects)\n\t\treturn FALSE;\n\tmessage->rects = tmpRects;\n\treturn TRUE;\n}\n\nstatic BOOL rfx_process_message_region(RFX_CONTEXT* context, RFX_MESSAGE* message, wStream* s,\n                                       UINT16* pExpectedBlockType)\n{\n\tUINT16 i;\n\tUINT16 regionType;\n\tUINT16 numTileSets;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_REGION)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants WBT_REGION\");\n\t\treturn FALSE;\n\t}\n\n\t*pExpectedBlockType = WBT_EXTENSION;\n\n\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 3))\n\t\treturn FALSE;\n\n\tStream_Seek_UINT8(s);                     /* regionFlags (1 byte) */\n\tStream_Read_UINT16(s, message->numRects); /* numRects (2 bytes) */\n\n\tif (message->numRects < 1)\n\t{\n\t\t/*\n\t\t   If numRects is zero the decoder must generate a rectangle with\n\t\t   coordinates (0, 0, width, height).\n\t\t   See [MS-RDPRFX] (revision >= 17.0) 2.2.2.3.3 TS_RFX_REGION\n\t\t   https://msdn.microsoft.com/en-us/library/ff635233.aspx\n\t\t*/\n\t\tmessage->numRects = 1;\n\t\tif (!rfx_resize_rects(message))\n\t\t\treturn FALSE;\n\n\t\tmessage->rects->x = 0;\n\t\tmessage->rects->y = 0;\n\t\tmessage->rects->width = context->width;\n\t\tmessage->rects->height = context->height;\n\t\treturn TRUE;\n\t}\n\n\tif (!Stream_CheckAndLogRequiredLengthOfSizeWLog(context->priv->log, s, message->numRects, 8ull))\n\t\treturn FALSE;\n\n\tif (!rfx_resize_rects(message))\n\t\treturn FALSE;\n\n\t/* rects */\n\tfor (i = 0; i < message->numRects; i++)\n\t{\n\t\tRFX_RECT* rect = rfx_message_get_rect(message, i);\n\t\t/* RFX_RECT */\n\t\tStream_Read_UINT16(s, rect->x);      /* x (2 bytes) */\n\t\tStream_Read_UINT16(s, rect->y);      /* y (2 bytes) */\n\t\tStream_Read_UINT16(s, rect->width);  /* width (2 bytes) */\n\t\tStream_Read_UINT16(s, rect->height); /* height (2 bytes) */\n\t\tWLog_Print(context->priv->log, WLOG_DEBUG,\n\t\t           \"rect %\" PRIu16 \" (x,y=%\" PRIu16 \",%\" PRIu16 \" w,h=%\" PRIu16 \" %\" PRIu16 \").\", i,\n\t\t           rect->x, rect->y, rect->width, rect->height);\n\t}\n\n\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 4))\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, regionType);  /*regionType (2 bytes): MUST be set to CBT_REGION (0xCAC1)*/\n\tStream_Read_UINT16(s, numTileSets); /*numTilesets (2 bytes): MUST be set to 0x0001.*/\n\n\tif (regionType != CBT_REGION)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid region type 0x%04\" PRIX16 \"\",\n\t\t           regionType);\n\t\treturn TRUE;\n\t}\n\n\tif (numTileSets != 0x0001)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid number of tilesets (%\" PRIu16 \")\",\n\t\t           numTileSets);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\ntypedef struct\n{\n\tRFX_TILE* tile;\n\tRFX_CONTEXT* context;\n} RFX_TILE_PROCESS_WORK_PARAM;\n\nstatic void CALLBACK rfx_process_message_tile_work_callback(PTP_CALLBACK_INSTANCE instance,\n                                                            void* context, PTP_WORK work)\n{\n\tRFX_TILE_PROCESS_WORK_PARAM* param = (RFX_TILE_PROCESS_WORK_PARAM*)context;\n\tWINPR_ASSERT(param);\n\trfx_decode_rgb(param->context, param->tile, param->tile->data, 64 * 4);\n}\n\nstatic BOOL rfx_allocate_tiles(RFX_MESSAGE* message, size_t count, BOOL allocOnly)\n{\n\tWINPR_ASSERT(message);\n\n\tRFX_TILE** tmpTiles = winpr_aligned_recalloc(message->tiles, count, sizeof(RFX_TILE*), 32);\n\tif (!tmpTiles && (count != 0))\n\t\treturn FALSE;\n\n\tmessage->tiles = tmpTiles;\n\tif (!allocOnly)\n\t\tmessage->numTiles = count;\n\telse\n\t{\n\t\tWINPR_ASSERT(message->numTiles <= count);\n\t}\n\tmessage->allocatedTiles = count;\n\n\treturn TRUE;\n}\nstatic BOOL rfx_process_message_tileset(RFX_CONTEXT* context, RFX_MESSAGE* message, wStream* s,\n                                        UINT16* pExpectedBlockType)\n{\n\tBOOL rc;\n\tsize_t close_cnt = 0;\n\tBYTE quant;\n\tRFX_TILE* tile;\n\tUINT32* quants;\n\tUINT16 subtype, numTiles;\n\tUINT32 blockLen;\n\tUINT32 blockType;\n\tUINT32 tilesDataSize;\n\tPTP_WORK* work_objects = NULL;\n\tRFX_TILE_PROCESS_WORK_PARAM* params = NULL;\n\tvoid* pmem;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(pExpectedBlockType);\n\n\tif (*pExpectedBlockType != WBT_EXTENSION)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"message unexpected wants a tileset\");\n\t\treturn FALSE;\n\t}\n\n\t*pExpectedBlockType = WBT_FRAME_END;\n\n\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 14))\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, subtype); /* subtype (2 bytes) must be set to CBT_TILESET (0xCAC2) */\n\tif (subtype != CBT_TILESET)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid subtype, expected CBT_TILESET.\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Seek_UINT16(s);                   /* idx (2 bytes), must be set to 0x0000 */\n\tStream_Seek_UINT16(s);                   /* properties (2 bytes) */\n\tStream_Read_UINT8(s, context->numQuant); /* numQuant (1 byte) */\n\tStream_Seek_UINT8(s);                    /* tileSize (1 byte), must be set to 0x40 */\n\n\tif (context->numQuant < 1)\n\t{\n\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"no quantization value.\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, numTiles); /* numTiles (2 bytes) */\n\tif (numTiles < 1)\n\t{\n\t\t/* Windows Server 2012 (not R2) can send empty tile sets */\n\t\treturn TRUE;\n\t}\n\n\tStream_Read_UINT32(s, tilesDataSize); /* tilesDataSize (4 bytes) */\n\n\tif (!(pmem =\n\t          winpr_aligned_recalloc(context->quants, context->numQuant, 10 * sizeof(UINT32), 32)))\n\t\treturn FALSE;\n\n\tquants = context->quants = (UINT32*)pmem;\n\n\t/* quantVals */\n\tif (!Stream_CheckAndLogRequiredLengthOfSizeWLog(context->priv->log, s, context->numQuant, 5ull))\n\t\treturn FALSE;\n\n\tfor (size_t i = 0; i < context->numQuant; i++)\n\t{\n\t\t/* RFX_CODEC_QUANT */\n\t\tStream_Read_UINT8(s, quant);\n\t\t*quants++ = (quant & 0x0F);\n\t\t*quants++ = (quant >> 4);\n\t\tStream_Read_UINT8(s, quant);\n\t\t*quants++ = (quant & 0x0F);\n\t\t*quants++ = (quant >> 4);\n\t\tStream_Read_UINT8(s, quant);\n\t\t*quants++ = (quant & 0x0F);\n\t\t*quants++ = (quant >> 4);\n\t\tStream_Read_UINT8(s, quant);\n\t\t*quants++ = (quant & 0x0F);\n\t\t*quants++ = (quant >> 4);\n\t\tStream_Read_UINT8(s, quant);\n\t\t*quants++ = (quant & 0x0F);\n\t\t*quants++ = (quant >> 4);\n\t\tWLog_Print(context->priv->log, WLOG_DEBUG,\n\t\t           \"quant %d (%\" PRIu32 \" %\" PRIu32 \" %\" PRIu32 \" %\" PRIu32 \" %\" PRIu32 \" %\" PRIu32\n\t\t           \" %\" PRIu32 \" %\" PRIu32 \" %\" PRIu32 \" %\" PRIu32 \").\",\n\t\t           i, context->quants[i * 10], context->quants[i * 10 + 1],\n\t\t           context->quants[i * 10 + 2], context->quants[i * 10 + 3],\n\t\t           context->quants[i * 10 + 4], context->quants[i * 10 + 5],\n\t\t           context->quants[i * 10 + 6], context->quants[i * 10 + 7],\n\t\t           context->quants[i * 10 + 8], context->quants[i * 10 + 9]);\n\t}\n\n\tfor (size_t i = 0; i < message->numTiles; i++)\n\t{\n\t\tObjectPool_Return(context->priv->TilePool, message->tiles[i]);\n\t\tmessage->tiles[i] = NULL;\n\t}\n\n\tif (!rfx_allocate_tiles(message, numTiles, FALSE))\n\t\treturn FALSE;\n\n\tif (context->priv->UseThreads)\n\t{\n\t\twork_objects = (PTP_WORK*)winpr_aligned_calloc(message->numTiles, sizeof(PTP_WORK), 32);\n\t\tparams = (RFX_TILE_PROCESS_WORK_PARAM*)winpr_aligned_recalloc(\n\t\t    NULL, message->numTiles, sizeof(RFX_TILE_PROCESS_WORK_PARAM), 32);\n\n\t\tif (!work_objects)\n\t\t{\n\t\t\twinpr_aligned_free(params);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (!params)\n\t\t{\n\t\t\twinpr_aligned_free(work_objects);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/* tiles */\n\tclose_cnt = 0;\n\trc = FALSE;\n\n\tif (Stream_GetRemainingLength(s) >= tilesDataSize)\n\t{\n\t\trc = TRUE;\n\t\tfor (size_t i = 0; i < message->numTiles; i++)\n\t\t{\n\t\t\twStream subBuffer;\n\t\t\twStream* sub;\n\n\t\t\tif (!(tile = (RFX_TILE*)ObjectPool_Take(context->priv->TilePool)))\n\t\t\t{\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR,\n\t\t\t\t           \"RfxMessageTileSet failed to get tile from object pool\");\n\t\t\t\trc = FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmessage->tiles[i] = tile;\n\n\t\t\t/* RFX_TILE */\n\t\t\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 6))\n\t\t\t{\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR,\n\t\t\t\t           \"RfxMessageTileSet packet too small to read tile %d/%\" PRIu16 \"\", i,\n\t\t\t\t           message->numTiles);\n\t\t\t\trc = FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsub = Stream_StaticInit(&subBuffer, Stream_Pointer(s), Stream_GetRemainingLength(s));\n\t\t\tStream_Read_UINT16(\n\t\t\t    sub, blockType); /* blockType (2 bytes), must be set to CBT_TILE (0xCAC3) */\n\t\t\tStream_Read_UINT32(sub, blockLen); /* blockLen (4 bytes) */\n\n\t\t\tif (!Stream_SafeSeek(s, blockLen))\n\t\t\t{\n\t\t\t\trc = FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((blockLen < 6 + 13) ||\n\t\t\t    (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, sub, blockLen - 6)))\n\t\t\t{\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR,\n\t\t\t\t           \"RfxMessageTileSet not enough bytes to read tile %d/%\" PRIu16\n\t\t\t\t           \" with blocklen=%\" PRIu32 \"\",\n\t\t\t\t           i, message->numTiles, blockLen);\n\t\t\t\trc = FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (blockType != CBT_TILE)\n\t\t\t{\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR,\n\t\t\t\t           \"unknown block type 0x%\" PRIX32 \", expected CBT_TILE (0xCAC3).\",\n\t\t\t\t           blockType);\n\t\t\t\trc = FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tStream_Read_UINT8(sub, tile->quantIdxY);  /* quantIdxY (1 byte) */\n\t\t\tStream_Read_UINT8(sub, tile->quantIdxCb); /* quantIdxCb (1 byte) */\n\t\t\tStream_Read_UINT8(sub, tile->quantIdxCr); /* quantIdxCr (1 byte) */\n\t\t\tif (tile->quantIdxY >= context->numQuant)\n\t\t\t{\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR,\n\t\t\t\t           \"quantIdxY %\" PRIu8 \" >= numQuant %\" PRIu8, tile->quantIdxY,\n\t\t\t\t           context->numQuant);\n\t\t\t\trc = FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (tile->quantIdxCb >= context->numQuant)\n\t\t\t{\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR,\n\t\t\t\t           \"quantIdxCb %\" PRIu8 \" >= numQuant %\" PRIu8, tile->quantIdxCb,\n\t\t\t\t           context->numQuant);\n\t\t\t\trc = FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (tile->quantIdxCr >= context->numQuant)\n\t\t\t{\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR,\n\t\t\t\t           \"quantIdxCr %\" PRIu8 \" >= numQuant %\" PRIu8, tile->quantIdxCr,\n\t\t\t\t           context->numQuant);\n\t\t\t\trc = FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tStream_Read_UINT16(sub, tile->xIdx);      /* xIdx (2 bytes) */\n\t\t\tStream_Read_UINT16(sub, tile->yIdx);      /* yIdx (2 bytes) */\n\t\t\tStream_Read_UINT16(sub, tile->YLen);      /* YLen (2 bytes) */\n\t\t\tStream_Read_UINT16(sub, tile->CbLen);     /* CbLen (2 bytes) */\n\t\t\tStream_Read_UINT16(sub, tile->CrLen);     /* CrLen (2 bytes) */\n\t\t\tStream_GetPointer(sub, tile->YData);\n\t\t\tif (!Stream_SafeSeek(sub, tile->YLen))\n\t\t\t{\n\t\t\t\trc = FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tStream_GetPointer(sub, tile->CbData);\n\t\t\tif (!Stream_SafeSeek(sub, tile->CbLen))\n\t\t\t{\n\t\t\t\trc = FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tStream_GetPointer(sub, tile->CrData);\n\t\t\tif (!Stream_SafeSeek(sub, tile->CrLen))\n\t\t\t{\n\t\t\t\trc = FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttile->x = tile->xIdx * 64;\n\t\t\ttile->y = tile->yIdx * 64;\n\n\t\t\tif (context->priv->UseThreads)\n\t\t\t{\n\t\t\t\tif (!params)\n\t\t\t\t{\n\t\t\t\t\trc = FALSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tparams[i].context = context;\n\t\t\t\tparams[i].tile = message->tiles[i];\n\n\t\t\t\tif (!(work_objects[i] =\n\t\t\t\t          CreateThreadpoolWork(rfx_process_message_tile_work_callback,\n\t\t\t\t                               (void*)&params[i], &context->priv->ThreadPoolEnv)))\n\t\t\t\t{\n\t\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"CreateThreadpoolWork failed.\");\n\t\t\t\t\trc = FALSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tSubmitThreadpoolWork(work_objects[i]);\n\t\t\t\tclose_cnt = i + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trfx_decode_rgb(context, tile, tile->data, 64 * 4);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (context->priv->UseThreads)\n\t{\n\t\tfor (size_t i = 0; i < close_cnt; i++)\n\t\t{\n\t\t\tWaitForThreadpoolWorkCallbacks(work_objects[i], FALSE);\n\t\t\tCloseThreadpoolWork(work_objects[i]);\n\t\t}\n\t}\n\n\twinpr_aligned_free(work_objects);\n\twinpr_aligned_free(params);\n\n\tfor (size_t i = 0; i < message->numTiles; i++)\n\t{\n\t\tif (!(tile = message->tiles[i]))\n\t\t\tcontinue;\n\n\t\ttile->YLen = tile->CbLen = tile->CrLen = 0;\n\t\ttile->YData = tile->CbData = tile->CrData = NULL;\n\t}\n\n\treturn rc;\n}\n\nBOOL rfx_process_message(RFX_CONTEXT* context, const BYTE* data, UINT32 length, UINT32 left,\n                         UINT32 top, BYTE* dst, UINT32 dstFormat, UINT32 dstStride,\n                         UINT32 dstHeight, REGION16* invalidRegion)\n{\n\tREGION16 updateRegion = { 0 };\n\twStream inStream = { 0 };\n\tBOOL ok = TRUE;\n\n\tif (!context || !data || !length)\n\t\treturn FALSE;\n\n\tWINPR_ASSERT(context->priv);\n\tRFX_MESSAGE* message = &context->currentMessage;\n\n\twStream* s = Stream_StaticConstInit(&inStream, data, length);\n\n\twhile (ok && Stream_GetRemainingLength(s) > 6)\n\t{\n\t\twStream subStreamBuffer = { 0 };\n\t\tsize_t extraBlockLen = 0;\n\t\tUINT32 blockLen = 0;\n\t\tUINT32 blockType = 0;\n\n\t\t/* RFX_BLOCKT */\n\t\tStream_Read_UINT16(s, blockType); /* blockType (2 bytes) */\n\t\tStream_Read_UINT32(s, blockLen);  /* blockLen (4 bytes) */\n\t\tWLog_Print(context->priv->log, WLOG_DEBUG, \"blockType 0x%\" PRIX32 \" blockLen %\" PRIu32 \"\",\n\t\t           blockType, blockLen);\n\n\t\tif (blockLen < 6)\n\t\t{\n\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"blockLen too small(%\" PRIu32 \")\", blockLen);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, blockLen - 6))\n\t\t\treturn FALSE;\n\n\t\tif (blockType > WBT_CONTEXT && context->decodedHeaderBlocks != RFX_DECODED_HEADERS)\n\t\t{\n\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"incomplete header blocks processing\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (blockType >= WBT_CONTEXT && blockType <= WBT_EXTENSION)\n\t\t{\n\t\t\t/* RFX_CODEC_CHANNELT */\n\t\t\tUINT8 codecId = 0;\n\t\t\tUINT8 channelId = 0;\n\n\t\t\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 2))\n\t\t\t\treturn FALSE;\n\n\t\t\textraBlockLen = 2;\n\t\t\tStream_Read_UINT8(s, codecId);   /* codecId (1 byte) must be set to 0x01 */\n\t\t\tStream_Read_UINT8(s, channelId); /* channelId (1 byte) 0xFF or 0x00, see below */\n\n\t\t\tif (codecId != 0x01)\n\t\t\t{\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"invalid codecId 0x%02\" PRIX8 \"\",\n\t\t\t\t           codecId);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tif (blockType == WBT_CONTEXT)\n\t\t\t{\n\t\t\t\t/* If the blockType is set to WBT_CONTEXT, then channelId MUST be set to 0xFF.*/\n\t\t\t\tif (channelId != 0xFF)\n\t\t\t\t{\n\t\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR,\n\t\t\t\t\t           \"invalid channelId 0x%02\" PRIX8 \" for blockType 0x%08\" PRIX32 \"\",\n\t\t\t\t\t           channelId, blockType);\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* For all other values of blockType, channelId MUST be set to 0x00. */\n\t\t\t\tif (channelId != 0x00)\n\t\t\t\t{\n\t\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR,\n\t\t\t\t\t           \"invalid channelId 0x%02\" PRIX8 \" for blockType WBT_CONTEXT\",\n\t\t\t\t\t           channelId);\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst size_t blockLenNoHeader = blockLen - 6;\n\t\tif (blockLenNoHeader < extraBlockLen)\n\t\t{\n\t\t\tWLog_Print(context->priv->log, WLOG_ERROR,\n\t\t\t           \"blockLen too small(%\" PRIu32 \"), must be >= 6 + %\" PRIu16, blockLen,\n\t\t\t           extraBlockLen);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tconst size_t subStreamLen = blockLenNoHeader - extraBlockLen;\n\t\twStream* subStream = Stream_StaticInit(&subStreamBuffer, Stream_Pointer(s), subStreamLen);\n\t\tStream_Seek(s, subStreamLen);\n\n\t\tswitch (blockType)\n\t\t{\n\t\t\t/* Header messages:\n\t\t\t * The stream MUST start with the header messages and any of these headers can appear\n\t\t\t * in the stream at a later stage. The header messages can be repeated.\n\t\t\t */\n\t\t\tcase WBT_SYNC:\n\t\t\t\tok = rfx_process_message_sync(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CONTEXT:\n\t\t\t\tok = rfx_process_message_context(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CODEC_VERSIONS:\n\t\t\t\tok = rfx_process_message_codec_versions(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_CHANNELS:\n\t\t\t\tok = rfx_process_message_channels(context, subStream);\n\t\t\t\tbreak;\n\n\t\t\t\t/* Data messages:\n\t\t\t\t * The data associated with each encoded frame or image is always bracketed by the\n\t\t\t\t * TS_RFX_FRAME_BEGIN (section 2.2.2.3.1) and TS_RFX_FRAME_END (section 2.2.2.3.2)\n\t\t\t\t * messages. There MUST only be one TS_RFX_REGION (section 2.2.2.3.3) message per\n\t\t\t\t * frame and one TS_RFX_TILESET (section 2.2.2.3.4) message per TS_RFX_REGION.\n\t\t\t\t */\n\n\t\t\tcase WBT_FRAME_BEGIN:\n\t\t\t\tok = rfx_process_message_frame_begin(context, message, subStream,\n\t\t\t\t                                     &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_REGION:\n\t\t\t\tok = rfx_process_message_region(context, message, subStream,\n\t\t\t\t                                &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_EXTENSION:\n\t\t\t\tok = rfx_process_message_tileset(context, message, subStream,\n\t\t\t\t                                 &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tcase WBT_FRAME_END:\n\t\t\t\tok = rfx_process_message_frame_end(context, message, subStream,\n\t\t\t\t                                   &context->expectedDataBlockType);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR, \"unknown blockType 0x%\" PRIX32 \"\",\n\t\t\t\t           blockType);\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tif (ok)\n\t{\n\t\tUINT32 nbUpdateRects = 0;\n\t\tREGION16 clippingRects = { 0 };\n\t\tconst RECTANGLE_16* updateRects = NULL;\n\t\tconst DWORD formatSize = FreeRDPGetBytesPerPixel(context->pixel_format);\n\t\tconst UINT32 dstWidth = dstStride / FreeRDPGetBytesPerPixel(dstFormat);\n\t\tregion16_init(&clippingRects);\n\n\t\tWINPR_ASSERT(dstWidth <= UINT16_MAX);\n\t\tWINPR_ASSERT(dstHeight <= UINT16_MAX);\n\t\tfor (UINT32 i = 0; i < message->numRects; i++)\n\t\t{\n\t\t\tRECTANGLE_16 clippingRect = { 0 };\n\t\t\tconst RFX_RECT* rect = &(message->rects[i]);\n\n\t\t\tWINPR_ASSERT(left + rect->x <= UINT16_MAX);\n\t\t\tWINPR_ASSERT(top + rect->y <= UINT16_MAX);\n\t\t\tWINPR_ASSERT(clippingRect.left + rect->width <= UINT16_MAX);\n\t\t\tWINPR_ASSERT(clippingRect.top + rect->height <= UINT16_MAX);\n\n\t\t\tclippingRect.left = (UINT16)MIN(left + rect->x, dstWidth);\n\t\t\tclippingRect.top = (UINT16)MIN(top + rect->y, dstHeight);\n\t\t\tclippingRect.right = (UINT16)MIN(clippingRect.left + rect->width, dstWidth);\n\t\t\tclippingRect.bottom = (UINT16)MIN(clippingRect.top + rect->height, dstHeight);\n\t\t\tregion16_union_rect(&clippingRects, &clippingRects, &clippingRect);\n\t\t}\n\n\t\tfor (UINT32 i = 0; i < message->numTiles; i++)\n\t\t{\n\t\t\tRECTANGLE_16 updateRect = { 0 };\n\t\t\tconst RFX_TILE* tile = rfx_message_get_tile(message, i);\n\n\t\t\tWINPR_ASSERT(left + tile->x <= UINT16_MAX);\n\t\t\tWINPR_ASSERT(top + tile->y <= UINT16_MAX);\n\n\t\t\tupdateRect.left = (UINT16)left + tile->x;\n\t\t\tupdateRect.top = (UINT16)top + tile->y;\n\t\t\tupdateRect.right = updateRect.left + 64;\n\t\t\tupdateRect.bottom = updateRect.top + 64;\n\t\t\tregion16_init(&updateRegion);\n\t\t\tregion16_intersect_rect(&updateRegion, &clippingRects, &updateRect);\n\t\t\tupdateRects = region16_rects(&updateRegion, &nbUpdateRects);\n\n\t\t\tfor (UINT32 j = 0; j < nbUpdateRects; j++)\n\t\t\t{\n\t\t\t\tconst UINT32 stride = 64 * formatSize;\n\t\t\t\tconst UINT32 nXDst = updateRects[j].left;\n\t\t\t\tconst UINT32 nYDst = updateRects[j].top;\n\t\t\t\tconst UINT32 nXSrc = nXDst - updateRect.left;\n\t\t\t\tconst UINT32 nYSrc = nYDst - updateRect.top;\n\t\t\t\tconst UINT32 nWidth = updateRects[j].right - updateRects[j].left;\n\t\t\t\tconst UINT32 nHeight = updateRects[j].bottom - updateRects[j].top;\n\n\t\t\t\tif (!freerdp_image_copy(dst, dstFormat, dstStride, nXDst, nYDst, nWidth, nHeight,\n\t\t\t\t                        tile->data, context->pixel_format, stride, nXSrc, nYSrc,\n\t\t\t\t                        NULL, FREERDP_FLIP_NONE))\n\t\t\t\t{\n\t\t\t\t\tregion16_uninit(&updateRegion);\n\t\t\t\t\tWLog_Print(context->priv->log, WLOG_ERROR,\n\t\t\t\t\t           \"nbUpdateRectx[%\" PRIu32 \" (%\" PRIu32 \")] freerdp_image_copy failed\",\n\t\t\t\t\t           j, nbUpdateRects);\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tif (invalidRegion)\n\t\t\t\t\tregion16_union_rect(invalidRegion, invalidRegion, &updateRects[j]);\n\t\t\t}\n\n\t\t\tregion16_uninit(&updateRegion);\n\t\t}\n\n\t\tregion16_uninit(&clippingRects);\n\t\treturn TRUE;\n\t}\n\telse\n\t{\n\t\trfx_message_free(context, message);\n\t\tcontext->currentMessage.freeArray = TRUE;\n\t}\n\n\tWLog_Print(context->priv->log, WLOG_ERROR, \"failed\");\n\treturn FALSE;\n}\n\nconst UINT32* rfx_message_get_quants(const RFX_MESSAGE* message, UINT16* numQuantVals)\n{\n\tWINPR_ASSERT(message);\n\tif (numQuantVals)\n\t\t*numQuantVals = message->numQuant;\n\treturn message->quantVals;\n}\n\nconst RFX_TILE** rfx_message_get_tiles(const RFX_MESSAGE* message, UINT16* numTiles)\n{\n\tWINPR_ASSERT(message);\n\tif (numTiles)\n\t\t*numTiles = message->numTiles;\n\treturn message->tiles;\n}\n\nUINT16 rfx_message_get_tile_count(const RFX_MESSAGE* message)\n{\n\tWINPR_ASSERT(message);\n\treturn message->numTiles;\n}\n\nconst RFX_RECT* rfx_message_get_rects(const RFX_MESSAGE* message, UINT16* numRects)\n{\n\tWINPR_ASSERT(message);\n\tif (numRects)\n\t\t*numRects = message->numRects;\n\treturn message->rects;\n}\n\nUINT16 rfx_message_get_rect_count(const RFX_MESSAGE* message)\n{\n\tWINPR_ASSERT(message);\n\treturn message->numRects;\n}\n\nvoid rfx_message_free(RFX_CONTEXT* context, RFX_MESSAGE* message)\n{\n\tif (!message)\n\t\treturn;\n\n\twinpr_aligned_free(message->rects);\n\n\tif (message->tiles)\n\t{\n\t\tfor (size_t i = 0; i < message->numTiles; i++)\n\t\t{\n\t\t\tRFX_TILE* tile = message->tiles[i];\n\t\t\tif (!tile)\n\t\t\t\tcontinue;\n\n\t\t\tif (tile->YCbCrData)\n\t\t\t{\n\t\t\t\tBufferPool_Return(context->priv->BufferPool, tile->YCbCrData);\n\t\t\t\ttile->YCbCrData = NULL;\n\t\t\t}\n\n\t\t\tObjectPool_Return(context->priv->TilePool, (void*)tile);\n\t\t}\n\n\t\trfx_allocate_tiles(message, 0, FALSE);\n\t}\n\n\tconst BOOL freeArray = message->freeArray;\n\tconst RFX_MESSAGE empty = { 0 };\n\t*message = empty;\n\n\tif (!freeArray)\n\t\twinpr_aligned_free(message);\n}\n\nstatic void rfx_update_context_properties(RFX_CONTEXT* context)\n{\n\tUINT16 properties = 0;\n\n\tWINPR_ASSERT(context);\n\t/* properties in tilesets: note that this has different format from the one in TS_RFX_CONTEXT */\n\tproperties = 1;                          /* lt */\n\tproperties |= (context->flags << 1);     /* flags */\n\tproperties |= (COL_CONV_ICT << 4);       /* cct */\n\tproperties |= (CLW_XFORM_DWT_53_A << 6); /* xft */\n\tproperties |= ((context->mode == RLGR1 ? CLW_ENTROPY_RLGR1 : CLW_ENTROPY_RLGR3) << 10); /* et */\n\tproperties |= (SCALAR_QUANTIZATION << 14);                                              /* qt */\n\tcontext->properties = properties;\n}\n\nstatic void rfx_write_message_sync(const RFX_CONTEXT* context, wStream* s)\n{\n\tWINPR_ASSERT(context);\n\n\tStream_Write_UINT16(s, WBT_SYNC);       /* BlockT.blockType (2 bytes) */\n\tStream_Write_UINT32(s, 12);             /* BlockT.blockLen (4 bytes) */\n\tStream_Write_UINT32(s, WF_MAGIC);       /* magic (4 bytes) */\n\tStream_Write_UINT16(s, WF_VERSION_1_0); /* version (2 bytes) */\n}\n\nstatic void rfx_write_message_codec_versions(const RFX_CONTEXT* context, wStream* s)\n{\n\tWINPR_ASSERT(context);\n\n\tStream_Write_UINT16(s, WBT_CODEC_VERSIONS); /* BlockT.blockType (2 bytes) */\n\tStream_Write_UINT32(s, 10);                 /* BlockT.blockLen (4 bytes) */\n\tStream_Write_UINT8(s, 1);                   /* numCodecs (1 byte) */\n\tStream_Write_UINT8(s, 1);                   /* codecs.codecId (1 byte) */\n\tStream_Write_UINT16(s, WF_VERSION_1_0);     /* codecs.version (2 bytes) */\n}\n\nstatic void rfx_write_message_channels(const RFX_CONTEXT* context, wStream* s)\n{\n\tWINPR_ASSERT(context);\n\n\tStream_Write_UINT16(s, WBT_CHANNELS);    /* BlockT.blockType (2 bytes) */\n\tStream_Write_UINT32(s, 12);              /* BlockT.blockLen (4 bytes) */\n\tStream_Write_UINT8(s, 1);                /* numChannels (1 byte) */\n\tStream_Write_UINT8(s, 0);                /* Channel.channelId (1 byte) */\n\tStream_Write_UINT16(s, context->width);  /* Channel.width (2 bytes) */\n\tStream_Write_UINT16(s, context->height); /* Channel.height (2 bytes) */\n}\n\nstatic void rfx_write_message_context(RFX_CONTEXT* context, wStream* s)\n{\n\tUINT16 properties = 0;\n\tWINPR_ASSERT(context);\n\n\tStream_Write_UINT16(s, WBT_CONTEXT);   /* CodecChannelT.blockType (2 bytes) */\n\tStream_Write_UINT32(s, 13);            /* CodecChannelT.blockLen (4 bytes) */\n\tStream_Write_UINT8(s, 1);              /* CodecChannelT.codecId (1 byte) */\n\tStream_Write_UINT8(s, 0xFF);           /* CodecChannelT.channelId (1 byte) */\n\tStream_Write_UINT8(s, 0);              /* ctxId (1 byte) */\n\tStream_Write_UINT16(s, CT_TILE_64x64); /* tileSize (2 bytes) */\n\t/* properties */\n\tproperties = context->flags;             /* flags */\n\tproperties |= (COL_CONV_ICT << 3);       /* cct */\n\tproperties |= (CLW_XFORM_DWT_53_A << 5); /* xft */\n\tproperties |= ((context->mode == RLGR1 ? CLW_ENTROPY_RLGR1 : CLW_ENTROPY_RLGR3) << 9); /* et */\n\tproperties |= (SCALAR_QUANTIZATION << 13);                                             /* qt */\n\tStream_Write_UINT16(s, properties); /* properties (2 bytes) */\n\trfx_update_context_properties(context);\n}\n\nstatic BOOL rfx_compose_message_header(RFX_CONTEXT* context, wStream* s)\n{\n\tWINPR_ASSERT(context);\n\tif (!Stream_EnsureRemainingCapacity(s, 12 + 10 + 12 + 13))\n\t\treturn FALSE;\n\n\trfx_write_message_sync(context, s);\n\trfx_write_message_context(context, s);\n\trfx_write_message_codec_versions(context, s);\n\trfx_write_message_channels(context, s);\n\treturn TRUE;\n}\n\nstatic size_t rfx_tile_length(const RFX_TILE* tile)\n{\n\tWINPR_ASSERT(tile);\n\treturn 19ull + tile->YLen + tile->CbLen + tile->CrLen;\n}\n\nstatic BOOL rfx_write_tile(wStream* s, const RFX_TILE* tile)\n{\n\tconst size_t blockLen = rfx_tile_length(tile);\n\n\tif (!Stream_EnsureRemainingCapacity(s, blockLen))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, CBT_TILE);           /* BlockT.blockType (2 bytes) */\n\tStream_Write_UINT32(s, blockLen);           /* BlockT.blockLen (4 bytes) */\n\tStream_Write_UINT8(s, tile->quantIdxY);     /* quantIdxY (1 byte) */\n\tStream_Write_UINT8(s, tile->quantIdxCb);    /* quantIdxCb (1 byte) */\n\tStream_Write_UINT8(s, tile->quantIdxCr);    /* quantIdxCr (1 byte) */\n\tStream_Write_UINT16(s, tile->xIdx);         /* xIdx (2 bytes) */\n\tStream_Write_UINT16(s, tile->yIdx);         /* yIdx (2 bytes) */\n\tStream_Write_UINT16(s, tile->YLen);         /* YLen (2 bytes) */\n\tStream_Write_UINT16(s, tile->CbLen);        /* CbLen (2 bytes) */\n\tStream_Write_UINT16(s, tile->CrLen);        /* CrLen (2 bytes) */\n\tStream_Write(s, tile->YData, tile->YLen);   /* YData */\n\tStream_Write(s, tile->CbData, tile->CbLen); /* CbData */\n\tStream_Write(s, tile->CrData, tile->CrLen); /* CrData */\n\treturn TRUE;\n}\n\nstruct S_RFX_TILE_COMPOSE_WORK_PARAM\n{\n\tRFX_TILE* tile;\n\tRFX_CONTEXT* context;\n};\n\nstatic void CALLBACK rfx_compose_message_tile_work_callback(PTP_CALLBACK_INSTANCE instance,\n                                                            void* context, PTP_WORK work)\n{\n\tRFX_TILE_COMPOSE_WORK_PARAM* param = (RFX_TILE_COMPOSE_WORK_PARAM*)context;\n\tWINPR_ASSERT(param);\n\trfx_encode_rgb(param->context, param->tile);\n}\n\nstatic BOOL computeRegion(const RFX_RECT* rects, size_t numRects, REGION16* region, size_t width,\n                          size_t height)\n{\n\tconst RECTANGLE_16 mainRect = { 0, 0, width, height };\n\n\tWINPR_ASSERT(rects);\n\tfor (size_t i = 0; i < numRects; i++)\n\t{\n\t\tconst RFX_RECT* rect = &rects[i];\n\t\tRECTANGLE_16 rect16 = { 0 };\n\t\trect16.left = rect->x;\n\t\trect16.top = rect->y;\n\t\trect16.right = rect->x + rect->width;\n\t\trect16.bottom = rect->y + rect->height;\n\n\t\tif (!region16_union_rect(region, region, &rect16))\n\t\t\treturn FALSE;\n\t}\n\n\treturn region16_intersect_rect(region, region, &mainRect);\n}\n\n#define TILE_NO(v) ((v) / 64)\n\nstatic BOOL setupWorkers(RFX_CONTEXT* context, size_t nbTiles)\n{\n\tWINPR_ASSERT(context);\n\n\tRFX_CONTEXT_PRIV* priv = context->priv;\n\tWINPR_ASSERT(priv);\n\n\tvoid* pmem;\n\n\tif (!context->priv->UseThreads)\n\t\treturn TRUE;\n\n\tif (!(pmem = winpr_aligned_recalloc(priv->workObjects, nbTiles, sizeof(PTP_WORK), 32)))\n\t\treturn FALSE;\n\n\tpriv->workObjects = (PTP_WORK*)pmem;\n\n\tif (!(pmem = winpr_aligned_recalloc(priv->tileWorkParams, nbTiles,\n\t                                    sizeof(RFX_TILE_COMPOSE_WORK_PARAM), 32)))\n\t\treturn FALSE;\n\n\tpriv->tileWorkParams = (RFX_TILE_COMPOSE_WORK_PARAM*)pmem;\n\treturn TRUE;\n}\n\nstatic BOOL rfx_ensure_tiles(RFX_MESSAGE* message, size_t count)\n{\n\tWINPR_ASSERT(message);\n\n\tif (message->numTiles + count <= message->allocatedTiles)\n\t\treturn TRUE;\n\n\tconst size_t alloc = MAX(message->allocatedTiles + 1024, message->numTiles + count);\n\treturn rfx_allocate_tiles(message, alloc, TRUE);\n}\n\nRFX_MESSAGE* rfx_encode_message(RFX_CONTEXT* context, const RFX_RECT* rects, size_t numRects,\n                                const BYTE* data, UINT32 w, UINT32 h, size_t s)\n{\n\tconst UINT32 width = (UINT32)w;\n\tconst UINT32 height = (UINT32)h;\n\tconst UINT32 scanline = (UINT32)s;\n\tRFX_MESSAGE* message = NULL;\n\tPTP_WORK* workObject = NULL;\n\tRFX_TILE_COMPOSE_WORK_PARAM* workParam = NULL;\n\tBOOL success = FALSE;\n\tREGION16 rectsRegion = { 0 }, tilesRegion = { 0 };\n\tRECTANGLE_16 currentTileRect = { 0 };\n\tconst RECTANGLE_16* regionRect = NULL;\n\n\tWINPR_ASSERT(data);\n\tWINPR_ASSERT(rects);\n\tWINPR_ASSERT(numRects > 0);\n\tWINPR_ASSERT(w > 0);\n\tWINPR_ASSERT(h > 0);\n\tWINPR_ASSERT(s > 0);\n\n\tif (!(message = (RFX_MESSAGE*)winpr_aligned_calloc(1, sizeof(RFX_MESSAGE), 32)))\n\t\treturn NULL;\n\n\tregion16_init(&tilesRegion);\n\tregion16_init(&rectsRegion);\n\n\tif (context->state == RFX_STATE_SEND_HEADERS)\n\t\trfx_update_context_properties(context);\n\n\tmessage->frameIdx = context->frameIdx++;\n\n\tif (!context->numQuant)\n\t{\n\t\tWINPR_ASSERT(context->quants == NULL);\n\t\tif (!(context->quants =\n\t\t          (UINT32*)winpr_aligned_malloc(sizeof(rfx_default_quantization_values), 32)))\n\t\t\tgoto skip_encoding_loop;\n\n\t\tCopyMemory(context->quants, &rfx_default_quantization_values,\n\t\t           sizeof(rfx_default_quantization_values));\n\t\tcontext->numQuant = 1;\n\t\tcontext->quantIdxY = 0;\n\t\tcontext->quantIdxCb = 0;\n\t\tcontext->quantIdxCr = 0;\n\t}\n\n\tmessage->numQuant = context->numQuant;\n\tmessage->quantVals = context->quants;\n\tconst UINT32 bytesPerPixel = (context->bits_per_pixel / 8);\n\n\tif (!computeRegion(rects, numRects, &rectsRegion, width, height))\n\t\tgoto skip_encoding_loop;\n\n\tconst RECTANGLE_16* extents = region16_extents(&rectsRegion);\n\tWINPR_ASSERT((INT32)extents->right - extents->left > 0);\n\tWINPR_ASSERT((INT32)extents->bottom - extents->top > 0);\n\tconst UINT32 maxTilesX = 1 + TILE_NO(extents->right - 1) - TILE_NO(extents->left);\n\tconst UINT32 maxTilesY = 1 + TILE_NO(extents->bottom - 1) - TILE_NO(extents->top);\n\tconst UINT32 maxNbTiles = maxTilesX * maxTilesY;\n\n\tif (!rfx_ensure_tiles(message, maxNbTiles))\n\t\tgoto skip_encoding_loop;\n\n\tif (!setupWorkers(context, maxNbTiles))\n\t\tgoto skip_encoding_loop;\n\n\tif (context->priv->UseThreads)\n\t{\n\t\tworkObject = context->priv->workObjects;\n\t\tworkParam = context->priv->tileWorkParams;\n\t}\n\n\tUINT32 regionNbRects = 0;\n\tregionRect = region16_rects(&rectsRegion, &regionNbRects);\n\n\tif (!(message->rects = winpr_aligned_calloc(regionNbRects, sizeof(RFX_RECT), 32)))\n\t\tgoto skip_encoding_loop;\n\n\tmessage->numRects = regionNbRects;\n\n\tfor (UINT32 i = 0; i < regionNbRects; i++, regionRect++)\n\t{\n\t\tRFX_RECT* rfxRect = &message->rects[i];\n\t\tUINT32 startTileX = regionRect->left / 64;\n\t\tUINT32 endTileX = (regionRect->right - 1) / 64;\n\t\tUINT32 startTileY = regionRect->top / 64;\n\t\tUINT32 endTileY = (regionRect->bottom - 1) / 64;\n\t\trfxRect->x = regionRect->left;\n\t\trfxRect->y = regionRect->top;\n\t\trfxRect->width = (regionRect->right - regionRect->left);\n\t\trfxRect->height = (regionRect->bottom - regionRect->top);\n\n\t\tfor (UINT32 yIdx = startTileY, gridRelY = startTileY * 64; yIdx <= endTileY;\n\t\t     yIdx++, gridRelY += 64)\n\t\t{\n\t\t\tUINT32 tileHeight = 64;\n\n\t\t\tif ((yIdx == endTileY) && (gridRelY + 64 > height))\n\t\t\t\ttileHeight = height - gridRelY;\n\n\t\t\tcurrentTileRect.top = gridRelY;\n\t\t\tcurrentTileRect.bottom = gridRelY + tileHeight;\n\n\t\t\tfor (UINT32 xIdx = startTileX, gridRelX = startTileX * 64; xIdx <= endTileX;\n\t\t\t     xIdx++, gridRelX += 64)\n\t\t\t{\n\t\t\t\tunion\n\t\t\t\t{\n\t\t\t\t\tconst BYTE* cpv;\n\t\t\t\t\tBYTE* pv;\n\t\t\t\t} cnv;\n\t\t\t\tint tileWidth = 64;\n\n\t\t\t\tif ((xIdx == endTileX) && (gridRelX + 64 > width))\n\t\t\t\t\ttileWidth = width - gridRelX;\n\n\t\t\t\tcurrentTileRect.left = gridRelX;\n\t\t\t\tcurrentTileRect.right = gridRelX + tileWidth;\n\n\t\t\t\t/* checks if this tile is already treated */\n\t\t\t\tif (region16_intersects_rect(&tilesRegion, &currentTileRect))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tRFX_TILE* tile = (RFX_TILE*)ObjectPool_Take(context->priv->TilePool);\n\t\t\t\tif (!tile)\n\t\t\t\t\tgoto skip_encoding_loop;\n\n\t\t\t\ttile->xIdx = xIdx;\n\t\t\t\ttile->yIdx = yIdx;\n\t\t\t\ttile->x = gridRelX;\n\t\t\t\ttile->y = gridRelY;\n\t\t\t\ttile->scanline = scanline;\n\t\t\t\ttile->width = tileWidth;\n\t\t\t\ttile->height = tileHeight;\n\t\t\t\tconst UINT32 ax = gridRelX;\n\t\t\t\tconst UINT32 ay = gridRelY;\n\n\t\t\t\tif (tile->data && tile->allocated)\n\t\t\t\t{\n\t\t\t\t\twinpr_aligned_free(tile->data);\n\t\t\t\t\ttile->allocated = FALSE;\n\t\t\t\t}\n\n\t\t\t\t/* Cast away const */\n\t\t\t\tcnv.cpv = &data[(ay * scanline) + (ax * bytesPerPixel)];\n\t\t\t\ttile->data = cnv.pv;\n\t\t\t\ttile->quantIdxY = context->quantIdxY;\n\t\t\t\ttile->quantIdxCb = context->quantIdxCb;\n\t\t\t\ttile->quantIdxCr = context->quantIdxCr;\n\t\t\t\ttile->YLen = tile->CbLen = tile->CrLen = 0;\n\n\t\t\t\tif (!(tile->YCbCrData = (BYTE*)BufferPool_Take(context->priv->BufferPool, -1)))\n\t\t\t\t\tgoto skip_encoding_loop;\n\n\t\t\t\ttile->YData = (BYTE*)&(tile->YCbCrData[((8192 + 32) * 0) + 16]);\n\t\t\t\ttile->CbData = (BYTE*)&(tile->YCbCrData[((8192 + 32) * 1) + 16]);\n\t\t\t\ttile->CrData = (BYTE*)&(tile->YCbCrData[((8192 + 32) * 2) + 16]);\n\n\t\t\t\tif (!rfx_ensure_tiles(message, 1))\n\t\t\t\t\tgoto skip_encoding_loop;\n\t\t\t\tmessage->tiles[message->numTiles++] = tile;\n\n\t\t\t\tif (context->priv->UseThreads)\n\t\t\t\t{\n\t\t\t\t\tworkParam->context = context;\n\t\t\t\t\tworkParam->tile = tile;\n\n\t\t\t\t\tif (!(*workObject = CreateThreadpoolWork(rfx_compose_message_tile_work_callback,\n\t\t\t\t\t                                         (void*)workParam,\n\t\t\t\t\t                                         &context->priv->ThreadPoolEnv)))\n\t\t\t\t\t{\n\t\t\t\t\t\tgoto skip_encoding_loop;\n\t\t\t\t\t}\n\n\t\t\t\t\tSubmitThreadpoolWork(*workObject);\n\t\t\t\t\tworkObject++;\n\t\t\t\t\tworkParam++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trfx_encode_rgb(context, tile);\n\t\t\t\t}\n\n\t\t\t\tif (!region16_union_rect(&tilesRegion, &tilesRegion, &currentTileRect))\n\t\t\t\t\tgoto skip_encoding_loop;\n\t\t\t} /* xIdx */\n\t\t}     /* yIdx */\n\t}         /* rects */\n\n\tsuccess = TRUE;\nskip_encoding_loop:\n\n\t/* when using threads ensure all computations are done */\n\tif (success)\n\t{\n\t\tmessage->tilesDataSize = 0;\n\t\tworkObject = context->priv->workObjects;\n\n\t\tfor (UINT32 i = 0; i < message->numTiles; i++)\n\t\t{\n\t\t\tif (context->priv->UseThreads)\n\t\t\t{\n\t\t\t\tif (*workObject)\n\t\t\t\t{\n\t\t\t\t\tWaitForThreadpoolWorkCallbacks(*workObject, FALSE);\n\t\t\t\t\tCloseThreadpoolWork(*workObject);\n\t\t\t\t}\n\n\t\t\t\tworkObject++;\n\t\t\t}\n\n\t\t\tconst RFX_TILE* tile = message->tiles[i];\n\t\t\tmessage->tilesDataSize += rfx_tile_length(tile);\n\t\t}\n\n\t\tregion16_uninit(&tilesRegion);\n\t\tregion16_uninit(&rectsRegion);\n\n\t\treturn message;\n\t}\n\n\tWLog_Print(context->priv->log, WLOG_ERROR, \"failed\");\n\n\trfx_message_free(context, message);\n\treturn NULL;\n}\n\nstatic BOOL rfx_clone_rects(RFX_MESSAGE* dst, const RFX_MESSAGE* src)\n{\n\tWINPR_ASSERT(dst);\n\tWINPR_ASSERT(src);\n\n\tWINPR_ASSERT(dst->rects == NULL);\n\tWINPR_ASSERT(dst->numRects == 0);\n\n\tif (src->numRects == 0)\n\t\treturn TRUE;\n\n\tdst->rects = winpr_aligned_calloc(src->numRects, sizeof(RECTANGLE_16), 32);\n\tif (!dst->rects)\n\t\treturn FALSE;\n\tdst->numRects = src->numRects;\n\tfor (size_t x = 0; x < src->numRects; x++)\n\t{\n\t\tdst->rects[x] = src->rects[x];\n\t}\n\treturn TRUE;\n}\n\nstatic BOOL rfx_clone_quants(RFX_MESSAGE* dst, const RFX_MESSAGE* src)\n{\n\tWINPR_ASSERT(dst);\n\tWINPR_ASSERT(src);\n\n\tWINPR_ASSERT(dst->quantVals == NULL);\n\tWINPR_ASSERT(dst->numQuant == 0);\n\n\tif (src->numQuant == 0)\n\t\treturn TRUE;\n\n\t/* quantVals are part of context */\n\tdst->quantVals = src->quantVals;\n\tdst->numQuant = src->numQuant;\n\n\treturn TRUE;\n}\n\nstatic RFX_MESSAGE* rfx_split_message(RFX_CONTEXT* context, RFX_MESSAGE* message,\n                                      size_t* numMessages, size_t maxDataSize)\n{\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(message);\n\tWINPR_ASSERT(numMessages);\n\n\tmaxDataSize -= 1024; /* reserve enough space for headers */\n\t*numMessages = ((message->tilesDataSize + maxDataSize) / maxDataSize) * 4ull;\n\n\tRFX_MESSAGE* messages =\n\t    (RFX_MESSAGE*)winpr_aligned_calloc((*numMessages), sizeof(RFX_MESSAGE), 32);\n\tif (!messages)\n\t\treturn NULL;\n\n\tsize_t j = 0;\n\tfor (size_t i = 0; i < message->numTiles; i++)\n\t{\n\t\tRFX_TILE* tile = message->tiles[i];\n\t\tRFX_MESSAGE* msg = &messages[j];\n\n\t\tWINPR_ASSERT(tile);\n\t\tWINPR_ASSERT(msg);\n\n\t\tconst size_t tileDataSize = rfx_tile_length(tile);\n\n\t\tif ((msg->tilesDataSize + tileDataSize) > ((UINT32)maxDataSize))\n\t\t\tj++;\n\n\t\tif (msg->numTiles == 0)\n\t\t{\n\t\t\tmsg->frameIdx = message->frameIdx + j;\n\t\t\tif (!rfx_clone_quants(msg, message))\n\t\t\t\tgoto free_messages;\n\t\t\tif (!rfx_clone_rects(msg, message))\n\t\t\t\tgoto free_messages;\n\t\t\tmsg->freeArray = TRUE;\n\t\t\tif (!rfx_allocate_tiles(msg, message->numTiles, TRUE))\n\t\t\t\tgoto free_messages;\n\t\t}\n\n\t\tmsg->tilesDataSize += tileDataSize;\n\n\t\tWINPR_ASSERT(msg->numTiles < msg->allocatedTiles);\n\t\tmsg->tiles[msg->numTiles++] = message->tiles[i];\n\t\tmessage->tiles[i] = NULL;\n\t}\n\n\t*numMessages = j + 1;\n\tcontext->frameIdx += j;\n\tmessage->numTiles = 0;\n\treturn messages;\nfree_messages:\n\n\tfor (size_t i = 0; i < j; i++)\n\t\trfx_allocate_tiles(&messages[i], 0, FALSE);\n\n\twinpr_aligned_free(messages);\n\treturn NULL;\n}\n\nconst RFX_MESSAGE* rfx_message_list_get(const RFX_MESSAGE_LIST* messages, size_t idx)\n{\n\tWINPR_ASSERT(messages);\n\tif (idx >= messages->count)\n\t\treturn NULL;\n\tWINPR_ASSERT(messages->list);\n\treturn &messages->list[idx];\n}\n\nvoid rfx_message_list_free(RFX_MESSAGE_LIST* messages)\n{\n\tif (!messages)\n\t\treturn;\n\tfor (size_t x = 0; x < messages->count; x++)\n\t\trfx_message_free(messages->context, &messages->list[x]);\n\tfree(messages);\n}\n\nstatic RFX_MESSAGE_LIST* rfx_message_list_new(RFX_CONTEXT* context, RFX_MESSAGE* messages,\n                                              size_t count)\n{\n\tWINPR_ASSERT(context);\n\tRFX_MESSAGE_LIST* msg = calloc(1, sizeof(RFX_MESSAGE_LIST));\n\tWINPR_ASSERT(msg);\n\n\tmsg->context = context;\n\tmsg->count = count;\n\tmsg->list = messages;\n\treturn msg;\n}\n\nRFX_MESSAGE_LIST* rfx_encode_messages(RFX_CONTEXT* context, const RFX_RECT* rects, size_t numRects,\n                                      const BYTE* data, UINT32 width, UINT32 height,\n                                      UINT32 scanline, size_t* numMessages, size_t maxDataSize)\n{\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(numMessages);\n\n\tRFX_MESSAGE* message =\n\t    rfx_encode_message(context, rects, numRects, data, width, height, scanline);\n\tif (!message)\n\t\treturn NULL;\n\n\tRFX_MESSAGE* list = rfx_split_message(context, message, numMessages, maxDataSize);\n\trfx_message_free(context, message);\n\tif (!list)\n\t\treturn NULL;\n\n\treturn rfx_message_list_new(context, list, *numMessages);\n}\n\nstatic BOOL rfx_write_message_tileset(RFX_CONTEXT* context, wStream* s, const RFX_MESSAGE* message)\n{\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(message);\n\n\tconst UINT32 blockLen = 22 + (message->numQuant * 5) + message->tilesDataSize;\n\n\tif (!Stream_EnsureRemainingCapacity(s, blockLen))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, WBT_EXTENSION);          /* CodecChannelT.blockType (2 bytes) */\n\tStream_Write_UINT32(s, blockLen);               /* set CodecChannelT.blockLen (4 bytes) */\n\tStream_Write_UINT8(s, 1);                       /* CodecChannelT.codecId (1 byte) */\n\tStream_Write_UINT8(s, 0);                       /* CodecChannelT.channelId (1 byte) */\n\tStream_Write_UINT16(s, CBT_TILESET);            /* subtype (2 bytes) */\n\tStream_Write_UINT16(s, 0);                      /* idx (2 bytes) */\n\tStream_Write_UINT16(s, context->properties);    /* properties (2 bytes) */\n\tStream_Write_UINT8(s, message->numQuant);       /* numQuant (1 byte) */\n\tStream_Write_UINT8(s, 0x40);                    /* tileSize (1 byte) */\n\tStream_Write_UINT16(s, message->numTiles);      /* numTiles (2 bytes) */\n\tStream_Write_UINT32(s, message->tilesDataSize); /* tilesDataSize (4 bytes) */\n\n\tUINT32* quantVals = message->quantVals;\n\tfor (size_t i = 0; i < message->numQuant * 5ul; i++)\n\t{\n\t\tWINPR_ASSERT(quantVals);\n\t\tStream_Write_UINT8(s, quantVals[0] + (quantVals[1] << 4));\n\t\tquantVals += 2;\n\t}\n\n\tfor (size_t i = 0; i < message->numTiles; i++)\n\t{\n\t\tRFX_TILE* tile = message->tiles[i];\n\t\tif (!tile)\n\t\t\treturn FALSE;\n\n\t\tif (!rfx_write_tile(s, tile))\n\t\t\treturn FALSE;\n\t}\n\n#ifdef WITH_DEBUG_RFX\n\tWLog_Print(context->priv->log, WLOG_DEBUG,\n\t           \"numQuant: %\" PRIu16 \" numTiles: %\" PRIu16 \" tilesDataSize: %\" PRIu32 \"\",\n\t           message->numQuant, message->numTiles, message->tilesDataSize);\n#endif\n\treturn TRUE;\n}\n\nstatic BOOL rfx_write_message_frame_begin(RFX_CONTEXT* context, wStream* s,\n                                          const RFX_MESSAGE* message)\n{\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(message);\n\n\tif (!Stream_EnsureRemainingCapacity(s, 14))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, WBT_FRAME_BEGIN);   /* CodecChannelT.blockType */\n\tStream_Write_UINT32(s, 14);                /* CodecChannelT.blockLen */\n\tStream_Write_UINT8(s, 1);                  /* CodecChannelT.codecId */\n\tStream_Write_UINT8(s, 0);                  /* CodecChannelT.channelId */\n\tStream_Write_UINT32(s, message->frameIdx); /* frameIdx */\n\tStream_Write_UINT16(s, 1);                 /* numRegions */\n\treturn TRUE;\n}\n\nstatic BOOL rfx_write_message_region(RFX_CONTEXT* context, wStream* s, const RFX_MESSAGE* message)\n{\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(message);\n\n\tconst size_t blockLen = 15 + (message->numRects * 8);\n\n\tif (!Stream_EnsureRemainingCapacity(s, blockLen))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, WBT_REGION);        /* CodecChannelT.blockType (2 bytes) */\n\tStream_Write_UINT32(s, blockLen);          /* set CodecChannelT.blockLen (4 bytes) */\n\tStream_Write_UINT8(s, 1);                  /* CodecChannelT.codecId (1 byte) */\n\tStream_Write_UINT8(s, 0);                  /* CodecChannelT.channelId (1 byte) */\n\tStream_Write_UINT8(s, 1);                  /* regionFlags (1 byte) */\n\tStream_Write_UINT16(s, message->numRects); /* numRects (2 bytes) */\n\n\tfor (size_t i = 0; i < message->numRects; i++)\n\t{\n\t\tconst RFX_RECT* rect = rfx_message_get_rect_const(message, i);\n\t\tWINPR_ASSERT(rect);\n\n\t\t/* Clipping rectangles are relative to destLeft, destTop */\n\t\tStream_Write_UINT16(s, rect->x);      /* x (2 bytes) */\n\t\tStream_Write_UINT16(s, rect->y);      /* y (2 bytes) */\n\t\tStream_Write_UINT16(s, rect->width);  /* width (2 bytes) */\n\t\tStream_Write_UINT16(s, rect->height); /* height (2 bytes) */\n\t}\n\n\tStream_Write_UINT16(s, CBT_REGION); /* regionType (2 bytes) */\n\tStream_Write_UINT16(s, 1);          /* numTilesets (2 bytes) */\n\treturn TRUE;\n}\n\nstatic BOOL rfx_write_message_frame_end(RFX_CONTEXT* context, wStream* s,\n                                        const RFX_MESSAGE* message)\n{\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(message);\n\n\tif (!Stream_EnsureRemainingCapacity(s, 8))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, WBT_FRAME_END); /* CodecChannelT.blockType */\n\tStream_Write_UINT32(s, 8);             /* CodecChannelT.blockLen */\n\tStream_Write_UINT8(s, 1);              /* CodecChannelT.codecId */\n\tStream_Write_UINT8(s, 0);              /* CodecChannelT.channelId */\n\treturn TRUE;\n}\n\nBOOL rfx_write_message(RFX_CONTEXT* context, wStream* s, const RFX_MESSAGE* message)\n{\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(message);\n\n\tif (context->state == RFX_STATE_SEND_HEADERS)\n\t{\n\t\tif (!rfx_compose_message_header(context, s))\n\t\t\treturn FALSE;\n\n\t\tcontext->state = RFX_STATE_SEND_FRAME_DATA;\n\t}\n\n\tif (!rfx_write_message_frame_begin(context, s, message) ||\n\t    !rfx_write_message_region(context, s, message) ||\n\t    !rfx_write_message_tileset(context, s, message) ||\n\t    !rfx_write_message_frame_end(context, s, message))\n\t{\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nBOOL rfx_compose_message(RFX_CONTEXT* context, wStream* s, const RFX_RECT* rects, size_t numRects,\n                         const BYTE* data, UINT32 width, UINT32 height, UINT32 scanline)\n{\n\tWINPR_ASSERT(context);\n\tRFX_MESSAGE* message =\n\t    rfx_encode_message(context, rects, numRects, data, width, height, scanline);\n\tif (!message)\n\t\treturn FALSE;\n\n\tconst BOOL ret = rfx_write_message(context, s, message);\n\trfx_message_free(context, message);\n\treturn ret;\n}\n\nBOOL rfx_context_set_mode(RFX_CONTEXT* context, RLGR_MODE mode)\n{\n\tWINPR_ASSERT(context);\n\tcontext->mode = mode;\n\treturn TRUE;\n}\n\nUINT32 rfx_context_get_frame_idx(const RFX_CONTEXT* context)\n{\n\tWINPR_ASSERT(context);\n\treturn context->frameIdx;\n}\n\nUINT32 rfx_message_get_frame_idx(const RFX_MESSAGE* message)\n{\n\tWINPR_ASSERT(message);\n\treturn message->frameIdx;\n}\n"], "filenames": ["libfreerdp/codec/rfx.c"], "buggy_code_start_loc": [996], "buggy_code_end_loc": [996], "fixing_code_start_loc": [997], "fixing_code_end_loc": [1022], "type": "CWE-191", "message": "FreeRDP is a free implementation of the Remote Desktop Protocol (RDP), released under the Apache license. This issue affects Clients only. Integer underflow leading to DOS (e.g. abort due to `WINPR_ASSERT` with default compilation flags). When an insufficient blockLen is provided, and proper length validation is not performed, an Integer Underflow occurs, leading to a Denial of Service (DOS) vulnerability. This issue has been addressed in versions 2.11.0 and 3.0.0-beta3. Users are advised to upgrade. There are no known workarounds for this vulnerability.\n", "other": {"cve": {"id": "CVE-2023-39350", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-31T20:15:08.170", "lastModified": "2024-01-12T13:15:09.857", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "FreeRDP is a free implementation of the Remote Desktop Protocol (RDP), released under the Apache license. This issue affects Clients only. Integer underflow leading to DOS (e.g. abort due to `WINPR_ASSERT` with default compilation flags). When an insufficient blockLen is provided, and proper length validation is not performed, an Integer Underflow occurs, leading to a Denial of Service (DOS) vulnerability. This issue has been addressed in versions 2.11.0 and 3.0.0-beta3. Users are advised to upgrade. There are no known workarounds for this vulnerability.\n"}, {"lang": "es", "value": "FreeRDP es una implementaci\u00f3n libre del Protocolo de Escritorio Remoto (RDP), publicado bajo la licencia Apache. Este problema afecta s\u00f3lo a los clientes. Desbordamiento incompleto de enteros que conduce al DOS (por ejemplo, aborto debido a `WINPR_ASSERT` con los indicadores de compilaci\u00f3n predeterminados). Cuando se proporciona un blockLen insuficiente y no se realiza la validaci\u00f3n de longitud adecuada, se produce un desbordamiento de enteros, lo que provoca una vulnerabilidad de denegaci\u00f3n de servicio (DOS). Este problema se ha solucionado en las versiones 2.11.0 y 3.0.0-beta3. Se recomienda a los usuarios que actualicen. No se conocen soluciones para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-191"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.11.0", "matchCriteriaId": "80B02150-FC4E-43F5-A3DF-D8E585200977"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:3.0.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "D8720D61-0B0D-40ED-B3C4-B452D83BF3C2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:3.0.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "18A75D02-0E7A-4AAF-8E23-0CDCB1733FEA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:39:*:*:*:*:*:*:*", "matchCriteriaId": "B8EDB836-4E6A-4B71-B9B2-AA3E03E0F646"}]}]}], "references": [{"url": "https://github.com/FreeRDP/FreeRDP/commit/e204fc8be5a372626b13f66daf2abafe71dbc2dc", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-rrrv-3w42-pffh", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/10/msg00008.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/A6LLDAPEXRDJOM3PREDDD267SSNT77DP/", "source": "security-advisories@github.com", "tags": ["Mailing List"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/IHMTGKCZXJPQOR5ZD2I4GPDNP2DKRXMF/", "source": "security-advisories@github.com", "tags": ["Mailing List"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/OH2ATH2BKDNKCJAU4WPPXK4SHLE3UJUV/", "source": "security-advisories@github.com", "tags": ["Mailing List"]}, {"url": "https://security.gentoo.org/glsa/202401-16", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/e204fc8be5a372626b13f66daf2abafe71dbc2dc"}}