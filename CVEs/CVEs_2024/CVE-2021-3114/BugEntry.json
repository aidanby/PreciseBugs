{"buggy_code": ["// Copyright 2012 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage elliptic\n\n// This is a constant-time, 32-bit implementation of P224. See FIPS 186-3,\n// section D.2.2.\n//\n// See https://www.imperialviolet.org/2010/12/04/ecc.html ([1]) for background.\n\nimport (\n\t\"math/big\"\n)\n\nvar p224 p224Curve\n\ntype p224Curve struct {\n\t*CurveParams\n\tgx, gy, b p224FieldElement\n}\n\nfunc initP224() {\n\t// See FIPS 186-3, section D.2.2\n\tp224.CurveParams = &CurveParams{Name: \"P-224\"}\n\tp224.P, _ = new(big.Int).SetString(\"26959946667150639794667015087019630673557916260026308143510066298881\", 10)\n\tp224.N, _ = new(big.Int).SetString(\"26959946667150639794667015087019625940457807714424391721682722368061\", 10)\n\tp224.B, _ = new(big.Int).SetString(\"b4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4\", 16)\n\tp224.Gx, _ = new(big.Int).SetString(\"b70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\", 16)\n\tp224.Gy, _ = new(big.Int).SetString(\"bd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34\", 16)\n\tp224.BitSize = 224\n\n\tp224FromBig(&p224.gx, p224.Gx)\n\tp224FromBig(&p224.gy, p224.Gy)\n\tp224FromBig(&p224.b, p224.B)\n}\n\n// P224 returns a Curve which implements P-224 (see FIPS 186-3, section D.2.2).\n//\n// The cryptographic operations are implemented using constant-time algorithms.\nfunc P224() Curve {\n\tinitonce.Do(initAll)\n\treturn p224\n}\n\nfunc (curve p224Curve) Params() *CurveParams {\n\treturn curve.CurveParams\n}\n\nfunc (curve p224Curve) IsOnCurve(bigX, bigY *big.Int) bool {\n\tvar x, y p224FieldElement\n\tp224FromBig(&x, bigX)\n\tp224FromBig(&y, bigY)\n\n\t// y\u00b2 = x\u00b3 - 3x + b\n\tvar tmp p224LargeFieldElement\n\tvar x3 p224FieldElement\n\tp224Square(&x3, &x, &tmp)\n\tp224Mul(&x3, &x3, &x, &tmp)\n\n\tfor i := 0; i < 8; i++ {\n\t\tx[i] *= 3\n\t}\n\tp224Sub(&x3, &x3, &x)\n\tp224Reduce(&x3)\n\tp224Add(&x3, &x3, &curve.b)\n\tp224Contract(&x3, &x3)\n\n\tp224Square(&y, &y, &tmp)\n\tp224Contract(&y, &y)\n\n\tfor i := 0; i < 8; i++ {\n\t\tif y[i] != x3[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (p224Curve) Add(bigX1, bigY1, bigX2, bigY2 *big.Int) (x, y *big.Int) {\n\tvar x1, y1, z1, x2, y2, z2, x3, y3, z3 p224FieldElement\n\n\tp224FromBig(&x1, bigX1)\n\tp224FromBig(&y1, bigY1)\n\tif bigX1.Sign() != 0 || bigY1.Sign() != 0 {\n\t\tz1[0] = 1\n\t}\n\tp224FromBig(&x2, bigX2)\n\tp224FromBig(&y2, bigY2)\n\tif bigX2.Sign() != 0 || bigY2.Sign() != 0 {\n\t\tz2[0] = 1\n\t}\n\n\tp224AddJacobian(&x3, &y3, &z3, &x1, &y1, &z1, &x2, &y2, &z2)\n\treturn p224ToAffine(&x3, &y3, &z3)\n}\n\nfunc (p224Curve) Double(bigX1, bigY1 *big.Int) (x, y *big.Int) {\n\tvar x1, y1, z1, x2, y2, z2 p224FieldElement\n\n\tp224FromBig(&x1, bigX1)\n\tp224FromBig(&y1, bigY1)\n\tz1[0] = 1\n\n\tp224DoubleJacobian(&x2, &y2, &z2, &x1, &y1, &z1)\n\treturn p224ToAffine(&x2, &y2, &z2)\n}\n\nfunc (p224Curve) ScalarMult(bigX1, bigY1 *big.Int, scalar []byte) (x, y *big.Int) {\n\tvar x1, y1, z1, x2, y2, z2 p224FieldElement\n\n\tp224FromBig(&x1, bigX1)\n\tp224FromBig(&y1, bigY1)\n\tz1[0] = 1\n\n\tp224ScalarMult(&x2, &y2, &z2, &x1, &y1, &z1, scalar)\n\treturn p224ToAffine(&x2, &y2, &z2)\n}\n\nfunc (curve p224Curve) ScalarBaseMult(scalar []byte) (x, y *big.Int) {\n\tvar z1, x2, y2, z2 p224FieldElement\n\n\tz1[0] = 1\n\tp224ScalarMult(&x2, &y2, &z2, &curve.gx, &curve.gy, &z1, scalar)\n\treturn p224ToAffine(&x2, &y2, &z2)\n}\n\n// Field element functions.\n//\n// The field that we're dealing with is \u2124/p\u2124 where p = 2**224 - 2**96 + 1.\n//\n// Field elements are represented by a FieldElement, which is a typedef to an\n// array of 8 uint32's. The value of a FieldElement, a, is:\n//   a[0] + 2**28\u00b7a[1] + 2**56\u00b7a[1] + ... + 2**196\u00b7a[7]\n//\n// Using 28-bit limbs means that there's only 4 bits of headroom, which is less\n// than we would really like. But it has the useful feature that we hit 2**224\n// exactly, making the reflections during a reduce much nicer.\ntype p224FieldElement [8]uint32\n\n// p224P is the order of the field, represented as a p224FieldElement.\nvar p224P = [8]uint32{1, 0, 0, 0xffff000, 0xfffffff, 0xfffffff, 0xfffffff, 0xfffffff}\n\n// p224IsZero returns 1 if a == 0 mod p and 0 otherwise.\n//\n// a[i] < 2**29\nfunc p224IsZero(a *p224FieldElement) uint32 {\n\t// Since a p224FieldElement contains 224 bits there are two possible\n\t// representations of 0: 0 and p.\n\tvar minimal p224FieldElement\n\tp224Contract(&minimal, a)\n\n\tvar isZero, isP uint32\n\tfor i, v := range minimal {\n\t\tisZero |= v\n\t\tisP |= v - p224P[i]\n\t}\n\n\t// If either isZero or isP is 0, then we should return 1.\n\tisZero |= isZero >> 16\n\tisZero |= isZero >> 8\n\tisZero |= isZero >> 4\n\tisZero |= isZero >> 2\n\tisZero |= isZero >> 1\n\n\tisP |= isP >> 16\n\tisP |= isP >> 8\n\tisP |= isP >> 4\n\tisP |= isP >> 2\n\tisP |= isP >> 1\n\n\t// For isZero and isP, the LSB is 0 iff all the bits are zero.\n\tresult := isZero & isP\n\tresult = (^result) & 1\n\n\treturn result\n}\n\n// p224Add computes *out = a+b\n//\n// a[i] + b[i] < 2**32\nfunc p224Add(out, a, b *p224FieldElement) {\n\tfor i := 0; i < 8; i++ {\n\t\tout[i] = a[i] + b[i]\n\t}\n}\n\nconst two31p3 = 1<<31 + 1<<3\nconst two31m3 = 1<<31 - 1<<3\nconst two31m15m3 = 1<<31 - 1<<15 - 1<<3\n\n// p224ZeroModP31 is 0 mod p where bit 31 is set in all limbs so that we can\n// subtract smaller amounts without underflow. See the section \"Subtraction\" in\n// [1] for reasoning.\nvar p224ZeroModP31 = []uint32{two31p3, two31m3, two31m3, two31m15m3, two31m3, two31m3, two31m3, two31m3}\n\n// p224Sub computes *out = a-b\n//\n// a[i], b[i] < 2**30\n// out[i] < 2**32\nfunc p224Sub(out, a, b *p224FieldElement) {\n\tfor i := 0; i < 8; i++ {\n\t\tout[i] = a[i] + p224ZeroModP31[i] - b[i]\n\t}\n}\n\n// LargeFieldElement also represents an element of the field. The limbs are\n// still spaced 28-bits apart and in little-endian order. So the limbs are at\n// 0, 28, 56, ..., 392 bits, each 64-bits wide.\ntype p224LargeFieldElement [15]uint64\n\nconst two63p35 = 1<<63 + 1<<35\nconst two63m35 = 1<<63 - 1<<35\nconst two63m35m19 = 1<<63 - 1<<35 - 1<<19\n\n// p224ZeroModP63 is 0 mod p where bit 63 is set in all limbs. See the section\n// \"Subtraction\" in [1] for why.\nvar p224ZeroModP63 = [8]uint64{two63p35, two63m35, two63m35, two63m35, two63m35m19, two63m35, two63m35, two63m35}\n\nconst bottom12Bits = 0xfff\nconst bottom28Bits = 0xfffffff\n\n// p224Mul computes *out = a*b\n//\n// a[i] < 2**29, b[i] < 2**30 (or vice versa)\n// out[i] < 2**29\nfunc p224Mul(out, a, b *p224FieldElement, tmp *p224LargeFieldElement) {\n\tfor i := 0; i < 15; i++ {\n\t\ttmp[i] = 0\n\t}\n\n\tfor i := 0; i < 8; i++ {\n\t\tfor j := 0; j < 8; j++ {\n\t\t\ttmp[i+j] += uint64(a[i]) * uint64(b[j])\n\t\t}\n\t}\n\n\tp224ReduceLarge(out, tmp)\n}\n\n// Square computes *out = a*a\n//\n// a[i] < 2**29\n// out[i] < 2**29\nfunc p224Square(out, a *p224FieldElement, tmp *p224LargeFieldElement) {\n\tfor i := 0; i < 15; i++ {\n\t\ttmp[i] = 0\n\t}\n\n\tfor i := 0; i < 8; i++ {\n\t\tfor j := 0; j <= i; j++ {\n\t\t\tr := uint64(a[i]) * uint64(a[j])\n\t\t\tif i == j {\n\t\t\t\ttmp[i+j] += r\n\t\t\t} else {\n\t\t\t\ttmp[i+j] += r << 1\n\t\t\t}\n\t\t}\n\t}\n\n\tp224ReduceLarge(out, tmp)\n}\n\n// ReduceLarge converts a p224LargeFieldElement to a p224FieldElement.\n//\n// in[i] < 2**62\nfunc p224ReduceLarge(out *p224FieldElement, in *p224LargeFieldElement) {\n\tfor i := 0; i < 8; i++ {\n\t\tin[i] += p224ZeroModP63[i]\n\t}\n\n\t// Eliminate the coefficients at 2**224 and greater.\n\tfor i := 14; i >= 8; i-- {\n\t\tin[i-8] -= in[i]\n\t\tin[i-5] += (in[i] & 0xffff) << 12\n\t\tin[i-4] += in[i] >> 16\n\t}\n\tin[8] = 0\n\t// in[0..8] < 2**64\n\n\t// As the values become small enough, we start to store them in |out|\n\t// and use 32-bit operations.\n\tfor i := 1; i < 8; i++ {\n\t\tin[i+1] += in[i] >> 28\n\t\tout[i] = uint32(in[i] & bottom28Bits)\n\t}\n\tin[0] -= in[8]\n\tout[3] += uint32(in[8]&0xffff) << 12\n\tout[4] += uint32(in[8] >> 16)\n\t// in[0] < 2**64\n\t// out[3] < 2**29\n\t// out[4] < 2**29\n\t// out[1,2,5..7] < 2**28\n\n\tout[0] = uint32(in[0] & bottom28Bits)\n\tout[1] += uint32((in[0] >> 28) & bottom28Bits)\n\tout[2] += uint32(in[0] >> 56)\n\t// out[0] < 2**28\n\t// out[1..4] < 2**29\n\t// out[5..7] < 2**28\n}\n\n// Reduce reduces the coefficients of a to smaller bounds.\n//\n// On entry: a[i] < 2**31 + 2**30\n// On exit: a[i] < 2**29\nfunc p224Reduce(a *p224FieldElement) {\n\tfor i := 0; i < 7; i++ {\n\t\ta[i+1] += a[i] >> 28\n\t\ta[i] &= bottom28Bits\n\t}\n\ttop := a[7] >> 28\n\ta[7] &= bottom28Bits\n\n\t// top < 2**4\n\tmask := top\n\tmask |= mask >> 2\n\tmask |= mask >> 1\n\tmask <<= 31\n\tmask = uint32(int32(mask) >> 31)\n\t// Mask is all ones if top != 0, all zero otherwise\n\n\ta[0] -= top\n\ta[3] += top << 12\n\n\t// We may have just made a[0] negative but, if we did, then we must\n\t// have added something to a[3], this it's > 2**12. Therefore we can\n\t// carry down to a[0].\n\ta[3] -= 1 & mask\n\ta[2] += mask & (1<<28 - 1)\n\ta[1] += mask & (1<<28 - 1)\n\ta[0] += mask & (1 << 28)\n}\n\n// p224Invert calculates *out = in**-1 by computing in**(2**224 - 2**96 - 1),\n// i.e. Fermat's little theorem.\nfunc p224Invert(out, in *p224FieldElement) {\n\tvar f1, f2, f3, f4 p224FieldElement\n\tvar c p224LargeFieldElement\n\n\tp224Square(&f1, in, &c)    // 2\n\tp224Mul(&f1, &f1, in, &c)  // 2**2 - 1\n\tp224Square(&f1, &f1, &c)   // 2**3 - 2\n\tp224Mul(&f1, &f1, in, &c)  // 2**3 - 1\n\tp224Square(&f2, &f1, &c)   // 2**4 - 2\n\tp224Square(&f2, &f2, &c)   // 2**5 - 4\n\tp224Square(&f2, &f2, &c)   // 2**6 - 8\n\tp224Mul(&f1, &f1, &f2, &c) // 2**6 - 1\n\tp224Square(&f2, &f1, &c)   // 2**7 - 2\n\tfor i := 0; i < 5; i++ {   // 2**12 - 2**6\n\t\tp224Square(&f2, &f2, &c)\n\t}\n\tp224Mul(&f2, &f2, &f1, &c) // 2**12 - 1\n\tp224Square(&f3, &f2, &c)   // 2**13 - 2\n\tfor i := 0; i < 11; i++ {  // 2**24 - 2**12\n\t\tp224Square(&f3, &f3, &c)\n\t}\n\tp224Mul(&f2, &f3, &f2, &c) // 2**24 - 1\n\tp224Square(&f3, &f2, &c)   // 2**25 - 2\n\tfor i := 0; i < 23; i++ {  // 2**48 - 2**24\n\t\tp224Square(&f3, &f3, &c)\n\t}\n\tp224Mul(&f3, &f3, &f2, &c) // 2**48 - 1\n\tp224Square(&f4, &f3, &c)   // 2**49 - 2\n\tfor i := 0; i < 47; i++ {  // 2**96 - 2**48\n\t\tp224Square(&f4, &f4, &c)\n\t}\n\tp224Mul(&f3, &f3, &f4, &c) // 2**96 - 1\n\tp224Square(&f4, &f3, &c)   // 2**97 - 2\n\tfor i := 0; i < 23; i++ {  // 2**120 - 2**24\n\t\tp224Square(&f4, &f4, &c)\n\t}\n\tp224Mul(&f2, &f4, &f2, &c) // 2**120 - 1\n\tfor i := 0; i < 6; i++ {   // 2**126 - 2**6\n\t\tp224Square(&f2, &f2, &c)\n\t}\n\tp224Mul(&f1, &f1, &f2, &c) // 2**126 - 1\n\tp224Square(&f1, &f1, &c)   // 2**127 - 2\n\tp224Mul(&f1, &f1, in, &c)  // 2**127 - 1\n\tfor i := 0; i < 97; i++ {  // 2**224 - 2**97\n\t\tp224Square(&f1, &f1, &c)\n\t}\n\tp224Mul(out, &f1, &f3, &c) // 2**224 - 2**96 - 1\n}\n\n// p224Contract converts a FieldElement to its unique, minimal form.\n//\n// On entry, in[i] < 2**29\n// On exit, in[i] < 2**28\nfunc p224Contract(out, in *p224FieldElement) {\n\tcopy(out[:], in[:])\n\n\tfor i := 0; i < 7; i++ {\n\t\tout[i+1] += out[i] >> 28\n\t\tout[i] &= bottom28Bits\n\t}\n\ttop := out[7] >> 28\n\tout[7] &= bottom28Bits\n\n\tout[0] -= top\n\tout[3] += top << 12\n\n\t// We may just have made out[i] negative. So we carry down. If we made\n\t// out[0] negative then we know that out[3] is sufficiently positive\n\t// because we just added to it.\n\tfor i := 0; i < 3; i++ {\n\t\tmask := uint32(int32(out[i]) >> 31)\n\t\tout[i] += (1 << 28) & mask\n\t\tout[i+1] -= 1 & mask\n\t}\n\n\t// We might have pushed out[3] over 2**28 so we perform another, partial,\n\t// carry chain.\n\tfor i := 3; i < 7; i++ {\n\t\tout[i+1] += out[i] >> 28\n\t\tout[i] &= bottom28Bits\n\t}\n\ttop = out[7] >> 28\n\tout[7] &= bottom28Bits\n\n\t// Eliminate top while maintaining the same value mod p.\n\tout[0] -= top\n\tout[3] += top << 12\n\n\t// There are two cases to consider for out[3]:\n\t//   1) The first time that we eliminated top, we didn't push out[3] over\n\t//      2**28. In this case, the partial carry chain didn't change any values\n\t//      and top is zero.\n\t//   2) We did push out[3] over 2**28 the first time that we eliminated top.\n\t//      The first value of top was in [0..16), therefore, prior to eliminating\n\t//      the first top, 0xfff1000 <= out[3] <= 0xfffffff. Therefore, after\n\t//      overflowing and being reduced by the second carry chain, out[3] <=\n\t//      0xf000. Thus it cannot have overflowed when we eliminated top for the\n\t//      second time.\n\n\t// Again, we may just have made out[0] negative, so do the same carry down.\n\t// As before, if we made out[0] negative then we know that out[3] is\n\t// sufficiently positive.\n\tfor i := 0; i < 3; i++ {\n\t\tmask := uint32(int32(out[i]) >> 31)\n\t\tout[i] += (1 << 28) & mask\n\t\tout[i+1] -= 1 & mask\n\t}\n\n\t// Now we see if the value is >= p and, if so, subtract p.\n\n\t// First we build a mask from the top four limbs, which must all be\n\t// equal to bottom28Bits if the whole value is >= p. If top4AllOnes\n\t// ends up with any zero bits in the bottom 28 bits, then this wasn't\n\t// true.\n\ttop4AllOnes := uint32(0xffffffff)\n\tfor i := 4; i < 8; i++ {\n\t\ttop4AllOnes &= out[i]\n\t}\n\ttop4AllOnes |= 0xf0000000\n\t// Now we replicate any zero bits to all the bits in top4AllOnes.\n\ttop4AllOnes &= top4AllOnes >> 16\n\ttop4AllOnes &= top4AllOnes >> 8\n\ttop4AllOnes &= top4AllOnes >> 4\n\ttop4AllOnes &= top4AllOnes >> 2\n\ttop4AllOnes &= top4AllOnes >> 1\n\ttop4AllOnes = uint32(int32(top4AllOnes<<31) >> 31)\n\n\t// Now we test whether the bottom three limbs are non-zero.\n\tbottom3NonZero := out[0] | out[1] | out[2]\n\tbottom3NonZero |= bottom3NonZero >> 16\n\tbottom3NonZero |= bottom3NonZero >> 8\n\tbottom3NonZero |= bottom3NonZero >> 4\n\tbottom3NonZero |= bottom3NonZero >> 2\n\tbottom3NonZero |= bottom3NonZero >> 1\n\tbottom3NonZero = uint32(int32(bottom3NonZero<<31) >> 31)\n\n\t// Everything depends on the value of out[3].\n\t//    If it's > 0xffff000 and top4AllOnes != 0 then the whole value is >= p\n\t//    If it's = 0xffff000 and top4AllOnes != 0 and bottom3NonZero != 0,\n\t//      then the whole value is >= p\n\t//    If it's < 0xffff000, then the whole value is < p\n\tn := out[3] - 0xffff000\n\tout3Equal := n\n\tout3Equal |= out3Equal >> 16\n\tout3Equal |= out3Equal >> 8\n\tout3Equal |= out3Equal >> 4\n\tout3Equal |= out3Equal >> 2\n\tout3Equal |= out3Equal >> 1\n\tout3Equal = ^uint32(int32(out3Equal<<31) >> 31)\n\n\t// If out[3] > 0xffff000 then n's MSB will be zero.\n\tout3GT := ^uint32(int32(n) >> 31)\n\n\tmask := top4AllOnes & ((out3Equal & bottom3NonZero) | out3GT)\n\tout[0] -= 1 & mask\n\tout[3] -= 0xffff000 & mask\n\tout[4] -= 0xfffffff & mask\n\tout[5] -= 0xfffffff & mask\n\tout[6] -= 0xfffffff & mask\n\tout[7] -= 0xfffffff & mask\n}\n\n// Group element functions.\n//\n// These functions deal with group elements. The group is an elliptic curve\n// group with a = -3 defined in FIPS 186-3, section D.2.2.\n\n// p224AddJacobian computes *out = a+b where a != b.\nfunc p224AddJacobian(x3, y3, z3, x1, y1, z1, x2, y2, z2 *p224FieldElement) {\n\t// See https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#addition-p224Add-2007-bl\n\tvar z1z1, z2z2, u1, u2, s1, s2, h, i, j, r, v p224FieldElement\n\tvar c p224LargeFieldElement\n\n\tz1IsZero := p224IsZero(z1)\n\tz2IsZero := p224IsZero(z2)\n\n\t// Z1Z1 = Z1\u00b2\n\tp224Square(&z1z1, z1, &c)\n\t// Z2Z2 = Z2\u00b2\n\tp224Square(&z2z2, z2, &c)\n\t// U1 = X1*Z2Z2\n\tp224Mul(&u1, x1, &z2z2, &c)\n\t// U2 = X2*Z1Z1\n\tp224Mul(&u2, x2, &z1z1, &c)\n\t// S1 = Y1*Z2*Z2Z2\n\tp224Mul(&s1, z2, &z2z2, &c)\n\tp224Mul(&s1, y1, &s1, &c)\n\t// S2 = Y2*Z1*Z1Z1\n\tp224Mul(&s2, z1, &z1z1, &c)\n\tp224Mul(&s2, y2, &s2, &c)\n\t// H = U2-U1\n\tp224Sub(&h, &u2, &u1)\n\tp224Reduce(&h)\n\txEqual := p224IsZero(&h)\n\t// I = (2*H)\u00b2\n\tfor j := 0; j < 8; j++ {\n\t\ti[j] = h[j] << 1\n\t}\n\tp224Reduce(&i)\n\tp224Square(&i, &i, &c)\n\t// J = H*I\n\tp224Mul(&j, &h, &i, &c)\n\t// r = 2*(S2-S1)\n\tp224Sub(&r, &s2, &s1)\n\tp224Reduce(&r)\n\tyEqual := p224IsZero(&r)\n\tif xEqual == 1 && yEqual == 1 && z1IsZero == 0 && z2IsZero == 0 {\n\t\tp224DoubleJacobian(x3, y3, z3, x1, y1, z1)\n\t\treturn\n\t}\n\tfor i := 0; i < 8; i++ {\n\t\tr[i] <<= 1\n\t}\n\tp224Reduce(&r)\n\t// V = U1*I\n\tp224Mul(&v, &u1, &i, &c)\n\t// Z3 = ((Z1+Z2)\u00b2-Z1Z1-Z2Z2)*H\n\tp224Add(&z1z1, &z1z1, &z2z2)\n\tp224Add(&z2z2, z1, z2)\n\tp224Reduce(&z2z2)\n\tp224Square(&z2z2, &z2z2, &c)\n\tp224Sub(z3, &z2z2, &z1z1)\n\tp224Reduce(z3)\n\tp224Mul(z3, z3, &h, &c)\n\t// X3 = r\u00b2-J-2*V\n\tfor i := 0; i < 8; i++ {\n\t\tz1z1[i] = v[i] << 1\n\t}\n\tp224Add(&z1z1, &j, &z1z1)\n\tp224Reduce(&z1z1)\n\tp224Square(x3, &r, &c)\n\tp224Sub(x3, x3, &z1z1)\n\tp224Reduce(x3)\n\t// Y3 = r*(V-X3)-2*S1*J\n\tfor i := 0; i < 8; i++ {\n\t\ts1[i] <<= 1\n\t}\n\tp224Mul(&s1, &s1, &j, &c)\n\tp224Sub(&z1z1, &v, x3)\n\tp224Reduce(&z1z1)\n\tp224Mul(&z1z1, &z1z1, &r, &c)\n\tp224Sub(y3, &z1z1, &s1)\n\tp224Reduce(y3)\n\n\tp224CopyConditional(x3, x2, z1IsZero)\n\tp224CopyConditional(x3, x1, z2IsZero)\n\tp224CopyConditional(y3, y2, z1IsZero)\n\tp224CopyConditional(y3, y1, z2IsZero)\n\tp224CopyConditional(z3, z2, z1IsZero)\n\tp224CopyConditional(z3, z1, z2IsZero)\n}\n\n// p224DoubleJacobian computes *out = a+a.\nfunc p224DoubleJacobian(x3, y3, z3, x1, y1, z1 *p224FieldElement) {\n\tvar delta, gamma, beta, alpha, t p224FieldElement\n\tvar c p224LargeFieldElement\n\n\tp224Square(&delta, z1, &c)\n\tp224Square(&gamma, y1, &c)\n\tp224Mul(&beta, x1, &gamma, &c)\n\n\t// alpha = 3*(X1-delta)*(X1+delta)\n\tp224Add(&t, x1, &delta)\n\tfor i := 0; i < 8; i++ {\n\t\tt[i] += t[i] << 1\n\t}\n\tp224Reduce(&t)\n\tp224Sub(&alpha, x1, &delta)\n\tp224Reduce(&alpha)\n\tp224Mul(&alpha, &alpha, &t, &c)\n\n\t// Z3 = (Y1+Z1)\u00b2-gamma-delta\n\tp224Add(z3, y1, z1)\n\tp224Reduce(z3)\n\tp224Square(z3, z3, &c)\n\tp224Sub(z3, z3, &gamma)\n\tp224Reduce(z3)\n\tp224Sub(z3, z3, &delta)\n\tp224Reduce(z3)\n\n\t// X3 = alpha\u00b2-8*beta\n\tfor i := 0; i < 8; i++ {\n\t\tdelta[i] = beta[i] << 3\n\t}\n\tp224Reduce(&delta)\n\tp224Square(x3, &alpha, &c)\n\tp224Sub(x3, x3, &delta)\n\tp224Reduce(x3)\n\n\t// Y3 = alpha*(4*beta-X3)-8*gamma\u00b2\n\tfor i := 0; i < 8; i++ {\n\t\tbeta[i] <<= 2\n\t}\n\tp224Sub(&beta, &beta, x3)\n\tp224Reduce(&beta)\n\tp224Square(&gamma, &gamma, &c)\n\tfor i := 0; i < 8; i++ {\n\t\tgamma[i] <<= 3\n\t}\n\tp224Reduce(&gamma)\n\tp224Mul(y3, &alpha, &beta, &c)\n\tp224Sub(y3, y3, &gamma)\n\tp224Reduce(y3)\n}\n\n// p224CopyConditional sets *out = *in iff the least-significant-bit of control\n// is true, and it runs in constant time.\nfunc p224CopyConditional(out, in *p224FieldElement, control uint32) {\n\tcontrol <<= 31\n\tcontrol = uint32(int32(control) >> 31)\n\n\tfor i := 0; i < 8; i++ {\n\t\tout[i] ^= (out[i] ^ in[i]) & control\n\t}\n}\n\nfunc p224ScalarMult(outX, outY, outZ, inX, inY, inZ *p224FieldElement, scalar []byte) {\n\tvar xx, yy, zz p224FieldElement\n\tfor i := 0; i < 8; i++ {\n\t\toutX[i] = 0\n\t\toutY[i] = 0\n\t\toutZ[i] = 0\n\t}\n\n\tfor _, byte := range scalar {\n\t\tfor bitNum := uint(0); bitNum < 8; bitNum++ {\n\t\t\tp224DoubleJacobian(outX, outY, outZ, outX, outY, outZ)\n\t\t\tbit := uint32((byte >> (7 - bitNum)) & 1)\n\t\t\tp224AddJacobian(&xx, &yy, &zz, inX, inY, inZ, outX, outY, outZ)\n\t\t\tp224CopyConditional(outX, &xx, bit)\n\t\t\tp224CopyConditional(outY, &yy, bit)\n\t\t\tp224CopyConditional(outZ, &zz, bit)\n\t\t}\n\t}\n}\n\n// p224ToAffine converts from Jacobian to affine form.\nfunc p224ToAffine(x, y, z *p224FieldElement) (*big.Int, *big.Int) {\n\tvar zinv, zinvsq, outx, outy p224FieldElement\n\tvar tmp p224LargeFieldElement\n\n\tif isPointAtInfinity := p224IsZero(z); isPointAtInfinity == 1 {\n\t\treturn new(big.Int), new(big.Int)\n\t}\n\n\tp224Invert(&zinv, z)\n\tp224Square(&zinvsq, &zinv, &tmp)\n\tp224Mul(x, x, &zinvsq, &tmp)\n\tp224Mul(&zinvsq, &zinvsq, &zinv, &tmp)\n\tp224Mul(y, y, &zinvsq, &tmp)\n\n\tp224Contract(&outx, x)\n\tp224Contract(&outy, y)\n\treturn p224ToBig(&outx), p224ToBig(&outy)\n}\n\n// get28BitsFromEnd returns the least-significant 28 bits from buf>>shift,\n// where buf is interpreted as a big-endian number.\nfunc get28BitsFromEnd(buf []byte, shift uint) (uint32, []byte) {\n\tvar ret uint32\n\n\tfor i := uint(0); i < 4; i++ {\n\t\tvar b byte\n\t\tif l := len(buf); l > 0 {\n\t\t\tb = buf[l-1]\n\t\t\t// We don't remove the byte if we're about to return and we're not\n\t\t\t// reading all of it.\n\t\t\tif i != 3 || shift == 4 {\n\t\t\t\tbuf = buf[:l-1]\n\t\t\t}\n\t\t}\n\t\tret |= uint32(b) << (8 * i) >> shift\n\t}\n\tret &= bottom28Bits\n\treturn ret, buf\n}\n\n// p224FromBig sets *out = *in.\nfunc p224FromBig(out *p224FieldElement, in *big.Int) {\n\tbytes := in.Bytes()\n\tout[0], bytes = get28BitsFromEnd(bytes, 0)\n\tout[1], bytes = get28BitsFromEnd(bytes, 4)\n\tout[2], bytes = get28BitsFromEnd(bytes, 0)\n\tout[3], bytes = get28BitsFromEnd(bytes, 4)\n\tout[4], bytes = get28BitsFromEnd(bytes, 0)\n\tout[5], bytes = get28BitsFromEnd(bytes, 4)\n\tout[6], bytes = get28BitsFromEnd(bytes, 0)\n\tout[7], bytes = get28BitsFromEnd(bytes, 4)\n}\n\n// p224ToBig returns in as a big.Int.\nfunc p224ToBig(in *p224FieldElement) *big.Int {\n\tvar buf [28]byte\n\tbuf[27] = byte(in[0])\n\tbuf[26] = byte(in[0] >> 8)\n\tbuf[25] = byte(in[0] >> 16)\n\tbuf[24] = byte(((in[0] >> 24) & 0x0f) | (in[1]<<4)&0xf0)\n\n\tbuf[23] = byte(in[1] >> 4)\n\tbuf[22] = byte(in[1] >> 12)\n\tbuf[21] = byte(in[1] >> 20)\n\n\tbuf[20] = byte(in[2])\n\tbuf[19] = byte(in[2] >> 8)\n\tbuf[18] = byte(in[2] >> 16)\n\tbuf[17] = byte(((in[2] >> 24) & 0x0f) | (in[3]<<4)&0xf0)\n\n\tbuf[16] = byte(in[3] >> 4)\n\tbuf[15] = byte(in[3] >> 12)\n\tbuf[14] = byte(in[3] >> 20)\n\n\tbuf[13] = byte(in[4])\n\tbuf[12] = byte(in[4] >> 8)\n\tbuf[11] = byte(in[4] >> 16)\n\tbuf[10] = byte(((in[4] >> 24) & 0x0f) | (in[5]<<4)&0xf0)\n\n\tbuf[9] = byte(in[5] >> 4)\n\tbuf[8] = byte(in[5] >> 12)\n\tbuf[7] = byte(in[5] >> 20)\n\n\tbuf[6] = byte(in[6])\n\tbuf[5] = byte(in[6] >> 8)\n\tbuf[4] = byte(in[6] >> 16)\n\tbuf[3] = byte(((in[6] >> 24) & 0x0f) | (in[7]<<4)&0xf0)\n\n\tbuf[2] = byte(in[7] >> 4)\n\tbuf[1] = byte(in[7] >> 12)\n\tbuf[0] = byte(in[7] >> 20)\n\n\treturn new(big.Int).SetBytes(buf[:])\n}\n", "// Copyright 2012 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage elliptic\n\nimport (\n\t\"math/big\"\n\t\"testing\"\n)\n\nvar toFromBigTests = []string{\n\t\"0\",\n\t\"1\",\n\t\"23\",\n\t\"b70e0cb46bb4bf7f321390b94a03c1d356c01122343280d6105c1d21\",\n\t\"706a46d476dcb76798e6046d89474788d164c18032d268fd10704fa6\",\n}\n\nfunc p224AlternativeToBig(in *p224FieldElement) *big.Int {\n\tret := new(big.Int)\n\ttmp := new(big.Int)\n\n\tfor i := uint(0); i < 8; i++ {\n\t\ttmp.SetInt64(int64(in[i]))\n\t\ttmp.Lsh(tmp, 28*i)\n\t\tret.Add(ret, tmp)\n\t}\n\tret.Mod(ret, p224.P)\n\treturn ret\n}\n\nfunc TestToFromBig(t *testing.T) {\n\tfor i, test := range toFromBigTests {\n\t\tn, _ := new(big.Int).SetString(test, 16)\n\t\tvar x p224FieldElement\n\t\tp224FromBig(&x, n)\n\t\tm := p224ToBig(&x)\n\t\tif n.Cmp(m) != 0 {\n\t\t\tt.Errorf(\"#%d: %x != %x\", i, n, m)\n\t\t}\n\t\tq := p224AlternativeToBig(&x)\n\t\tif n.Cmp(q) != 0 {\n\t\t\tt.Errorf(\"#%d: %x != %x (alternative)\", i, n, m)\n\t\t}\n\t}\n}\n"], "fixing_code": ["// Copyright 2012 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage elliptic\n\n// This is a constant-time, 32-bit implementation of P224. See FIPS 186-3,\n// section D.2.2.\n//\n// See https://www.imperialviolet.org/2010/12/04/ecc.html ([1]) for background.\n\nimport (\n\t\"math/big\"\n)\n\nvar p224 p224Curve\n\ntype p224Curve struct {\n\t*CurveParams\n\tgx, gy, b p224FieldElement\n}\n\nfunc initP224() {\n\t// See FIPS 186-3, section D.2.2\n\tp224.CurveParams = &CurveParams{Name: \"P-224\"}\n\tp224.P, _ = new(big.Int).SetString(\"26959946667150639794667015087019630673557916260026308143510066298881\", 10)\n\tp224.N, _ = new(big.Int).SetString(\"26959946667150639794667015087019625940457807714424391721682722368061\", 10)\n\tp224.B, _ = new(big.Int).SetString(\"b4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4\", 16)\n\tp224.Gx, _ = new(big.Int).SetString(\"b70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\", 16)\n\tp224.Gy, _ = new(big.Int).SetString(\"bd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34\", 16)\n\tp224.BitSize = 224\n\n\tp224FromBig(&p224.gx, p224.Gx)\n\tp224FromBig(&p224.gy, p224.Gy)\n\tp224FromBig(&p224.b, p224.B)\n}\n\n// P224 returns a Curve which implements P-224 (see FIPS 186-3, section D.2.2).\n//\n// The cryptographic operations are implemented using constant-time algorithms.\nfunc P224() Curve {\n\tinitonce.Do(initAll)\n\treturn p224\n}\n\nfunc (curve p224Curve) Params() *CurveParams {\n\treturn curve.CurveParams\n}\n\nfunc (curve p224Curve) IsOnCurve(bigX, bigY *big.Int) bool {\n\tvar x, y p224FieldElement\n\tp224FromBig(&x, bigX)\n\tp224FromBig(&y, bigY)\n\n\t// y\u00b2 = x\u00b3 - 3x + b\n\tvar tmp p224LargeFieldElement\n\tvar x3 p224FieldElement\n\tp224Square(&x3, &x, &tmp)\n\tp224Mul(&x3, &x3, &x, &tmp)\n\n\tfor i := 0; i < 8; i++ {\n\t\tx[i] *= 3\n\t}\n\tp224Sub(&x3, &x3, &x)\n\tp224Reduce(&x3)\n\tp224Add(&x3, &x3, &curve.b)\n\tp224Contract(&x3, &x3)\n\n\tp224Square(&y, &y, &tmp)\n\tp224Contract(&y, &y)\n\n\tfor i := 0; i < 8; i++ {\n\t\tif y[i] != x3[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (p224Curve) Add(bigX1, bigY1, bigX2, bigY2 *big.Int) (x, y *big.Int) {\n\tvar x1, y1, z1, x2, y2, z2, x3, y3, z3 p224FieldElement\n\n\tp224FromBig(&x1, bigX1)\n\tp224FromBig(&y1, bigY1)\n\tif bigX1.Sign() != 0 || bigY1.Sign() != 0 {\n\t\tz1[0] = 1\n\t}\n\tp224FromBig(&x2, bigX2)\n\tp224FromBig(&y2, bigY2)\n\tif bigX2.Sign() != 0 || bigY2.Sign() != 0 {\n\t\tz2[0] = 1\n\t}\n\n\tp224AddJacobian(&x3, &y3, &z3, &x1, &y1, &z1, &x2, &y2, &z2)\n\treturn p224ToAffine(&x3, &y3, &z3)\n}\n\nfunc (p224Curve) Double(bigX1, bigY1 *big.Int) (x, y *big.Int) {\n\tvar x1, y1, z1, x2, y2, z2 p224FieldElement\n\n\tp224FromBig(&x1, bigX1)\n\tp224FromBig(&y1, bigY1)\n\tz1[0] = 1\n\n\tp224DoubleJacobian(&x2, &y2, &z2, &x1, &y1, &z1)\n\treturn p224ToAffine(&x2, &y2, &z2)\n}\n\nfunc (p224Curve) ScalarMult(bigX1, bigY1 *big.Int, scalar []byte) (x, y *big.Int) {\n\tvar x1, y1, z1, x2, y2, z2 p224FieldElement\n\n\tp224FromBig(&x1, bigX1)\n\tp224FromBig(&y1, bigY1)\n\tz1[0] = 1\n\n\tp224ScalarMult(&x2, &y2, &z2, &x1, &y1, &z1, scalar)\n\treturn p224ToAffine(&x2, &y2, &z2)\n}\n\nfunc (curve p224Curve) ScalarBaseMult(scalar []byte) (x, y *big.Int) {\n\tvar z1, x2, y2, z2 p224FieldElement\n\n\tz1[0] = 1\n\tp224ScalarMult(&x2, &y2, &z2, &curve.gx, &curve.gy, &z1, scalar)\n\treturn p224ToAffine(&x2, &y2, &z2)\n}\n\n// Field element functions.\n//\n// The field that we're dealing with is \u2124/p\u2124 where p = 2**224 - 2**96 + 1.\n//\n// Field elements are represented by a FieldElement, which is a typedef to an\n// array of 8 uint32's. The value of a FieldElement, a, is:\n//   a[0] + 2**28\u00b7a[1] + 2**56\u00b7a[1] + ... + 2**196\u00b7a[7]\n//\n// Using 28-bit limbs means that there's only 4 bits of headroom, which is less\n// than we would really like. But it has the useful feature that we hit 2**224\n// exactly, making the reflections during a reduce much nicer.\ntype p224FieldElement [8]uint32\n\n// p224P is the order of the field, represented as a p224FieldElement.\nvar p224P = [8]uint32{1, 0, 0, 0xffff000, 0xfffffff, 0xfffffff, 0xfffffff, 0xfffffff}\n\n// p224IsZero returns 1 if a == 0 mod p and 0 otherwise.\n//\n// a[i] < 2**29\nfunc p224IsZero(a *p224FieldElement) uint32 {\n\t// Since a p224FieldElement contains 224 bits there are two possible\n\t// representations of 0: 0 and p.\n\tvar minimal p224FieldElement\n\tp224Contract(&minimal, a)\n\n\tvar isZero, isP uint32\n\tfor i, v := range minimal {\n\t\tisZero |= v\n\t\tisP |= v - p224P[i]\n\t}\n\n\t// If either isZero or isP is 0, then we should return 1.\n\tisZero |= isZero >> 16\n\tisZero |= isZero >> 8\n\tisZero |= isZero >> 4\n\tisZero |= isZero >> 2\n\tisZero |= isZero >> 1\n\n\tisP |= isP >> 16\n\tisP |= isP >> 8\n\tisP |= isP >> 4\n\tisP |= isP >> 2\n\tisP |= isP >> 1\n\n\t// For isZero and isP, the LSB is 0 iff all the bits are zero.\n\tresult := isZero & isP\n\tresult = (^result) & 1\n\n\treturn result\n}\n\n// p224Add computes *out = a+b\n//\n// a[i] + b[i] < 2**32\nfunc p224Add(out, a, b *p224FieldElement) {\n\tfor i := 0; i < 8; i++ {\n\t\tout[i] = a[i] + b[i]\n\t}\n}\n\nconst two31p3 = 1<<31 + 1<<3\nconst two31m3 = 1<<31 - 1<<3\nconst two31m15m3 = 1<<31 - 1<<15 - 1<<3\n\n// p224ZeroModP31 is 0 mod p where bit 31 is set in all limbs so that we can\n// subtract smaller amounts without underflow. See the section \"Subtraction\" in\n// [1] for reasoning.\nvar p224ZeroModP31 = []uint32{two31p3, two31m3, two31m3, two31m15m3, two31m3, two31m3, two31m3, two31m3}\n\n// p224Sub computes *out = a-b\n//\n// a[i], b[i] < 2**30\n// out[i] < 2**32\nfunc p224Sub(out, a, b *p224FieldElement) {\n\tfor i := 0; i < 8; i++ {\n\t\tout[i] = a[i] + p224ZeroModP31[i] - b[i]\n\t}\n}\n\n// LargeFieldElement also represents an element of the field. The limbs are\n// still spaced 28-bits apart and in little-endian order. So the limbs are at\n// 0, 28, 56, ..., 392 bits, each 64-bits wide.\ntype p224LargeFieldElement [15]uint64\n\nconst two63p35 = 1<<63 + 1<<35\nconst two63m35 = 1<<63 - 1<<35\nconst two63m35m19 = 1<<63 - 1<<35 - 1<<19\n\n// p224ZeroModP63 is 0 mod p where bit 63 is set in all limbs. See the section\n// \"Subtraction\" in [1] for why.\nvar p224ZeroModP63 = [8]uint64{two63p35, two63m35, two63m35, two63m35, two63m35m19, two63m35, two63m35, two63m35}\n\nconst bottom12Bits = 0xfff\nconst bottom28Bits = 0xfffffff\n\n// p224Mul computes *out = a*b\n//\n// a[i] < 2**29, b[i] < 2**30 (or vice versa)\n// out[i] < 2**29\nfunc p224Mul(out, a, b *p224FieldElement, tmp *p224LargeFieldElement) {\n\tfor i := 0; i < 15; i++ {\n\t\ttmp[i] = 0\n\t}\n\n\tfor i := 0; i < 8; i++ {\n\t\tfor j := 0; j < 8; j++ {\n\t\t\ttmp[i+j] += uint64(a[i]) * uint64(b[j])\n\t\t}\n\t}\n\n\tp224ReduceLarge(out, tmp)\n}\n\n// Square computes *out = a*a\n//\n// a[i] < 2**29\n// out[i] < 2**29\nfunc p224Square(out, a *p224FieldElement, tmp *p224LargeFieldElement) {\n\tfor i := 0; i < 15; i++ {\n\t\ttmp[i] = 0\n\t}\n\n\tfor i := 0; i < 8; i++ {\n\t\tfor j := 0; j <= i; j++ {\n\t\t\tr := uint64(a[i]) * uint64(a[j])\n\t\t\tif i == j {\n\t\t\t\ttmp[i+j] += r\n\t\t\t} else {\n\t\t\t\ttmp[i+j] += r << 1\n\t\t\t}\n\t\t}\n\t}\n\n\tp224ReduceLarge(out, tmp)\n}\n\n// ReduceLarge converts a p224LargeFieldElement to a p224FieldElement.\n//\n// in[i] < 2**62\nfunc p224ReduceLarge(out *p224FieldElement, in *p224LargeFieldElement) {\n\tfor i := 0; i < 8; i++ {\n\t\tin[i] += p224ZeroModP63[i]\n\t}\n\n\t// Eliminate the coefficients at 2**224 and greater.\n\tfor i := 14; i >= 8; i-- {\n\t\tin[i-8] -= in[i]\n\t\tin[i-5] += (in[i] & 0xffff) << 12\n\t\tin[i-4] += in[i] >> 16\n\t}\n\tin[8] = 0\n\t// in[0..8] < 2**64\n\n\t// As the values become small enough, we start to store them in |out|\n\t// and use 32-bit operations.\n\tfor i := 1; i < 8; i++ {\n\t\tin[i+1] += in[i] >> 28\n\t\tout[i] = uint32(in[i] & bottom28Bits)\n\t}\n\tin[0] -= in[8]\n\tout[3] += uint32(in[8]&0xffff) << 12\n\tout[4] += uint32(in[8] >> 16)\n\t// in[0] < 2**64\n\t// out[3] < 2**29\n\t// out[4] < 2**29\n\t// out[1,2,5..7] < 2**28\n\n\tout[0] = uint32(in[0] & bottom28Bits)\n\tout[1] += uint32((in[0] >> 28) & bottom28Bits)\n\tout[2] += uint32(in[0] >> 56)\n\t// out[0] < 2**28\n\t// out[1..4] < 2**29\n\t// out[5..7] < 2**28\n}\n\n// Reduce reduces the coefficients of a to smaller bounds.\n//\n// On entry: a[i] < 2**31 + 2**30\n// On exit: a[i] < 2**29\nfunc p224Reduce(a *p224FieldElement) {\n\tfor i := 0; i < 7; i++ {\n\t\ta[i+1] += a[i] >> 28\n\t\ta[i] &= bottom28Bits\n\t}\n\ttop := a[7] >> 28\n\ta[7] &= bottom28Bits\n\n\t// top < 2**4\n\tmask := top\n\tmask |= mask >> 2\n\tmask |= mask >> 1\n\tmask <<= 31\n\tmask = uint32(int32(mask) >> 31)\n\t// Mask is all ones if top != 0, all zero otherwise\n\n\ta[0] -= top\n\ta[3] += top << 12\n\n\t// We may have just made a[0] negative but, if we did, then we must\n\t// have added something to a[3], this it's > 2**12. Therefore we can\n\t// carry down to a[0].\n\ta[3] -= 1 & mask\n\ta[2] += mask & (1<<28 - 1)\n\ta[1] += mask & (1<<28 - 1)\n\ta[0] += mask & (1 << 28)\n}\n\n// p224Invert calculates *out = in**-1 by computing in**(2**224 - 2**96 - 1),\n// i.e. Fermat's little theorem.\nfunc p224Invert(out, in *p224FieldElement) {\n\tvar f1, f2, f3, f4 p224FieldElement\n\tvar c p224LargeFieldElement\n\n\tp224Square(&f1, in, &c)    // 2\n\tp224Mul(&f1, &f1, in, &c)  // 2**2 - 1\n\tp224Square(&f1, &f1, &c)   // 2**3 - 2\n\tp224Mul(&f1, &f1, in, &c)  // 2**3 - 1\n\tp224Square(&f2, &f1, &c)   // 2**4 - 2\n\tp224Square(&f2, &f2, &c)   // 2**5 - 4\n\tp224Square(&f2, &f2, &c)   // 2**6 - 8\n\tp224Mul(&f1, &f1, &f2, &c) // 2**6 - 1\n\tp224Square(&f2, &f1, &c)   // 2**7 - 2\n\tfor i := 0; i < 5; i++ {   // 2**12 - 2**6\n\t\tp224Square(&f2, &f2, &c)\n\t}\n\tp224Mul(&f2, &f2, &f1, &c) // 2**12 - 1\n\tp224Square(&f3, &f2, &c)   // 2**13 - 2\n\tfor i := 0; i < 11; i++ {  // 2**24 - 2**12\n\t\tp224Square(&f3, &f3, &c)\n\t}\n\tp224Mul(&f2, &f3, &f2, &c) // 2**24 - 1\n\tp224Square(&f3, &f2, &c)   // 2**25 - 2\n\tfor i := 0; i < 23; i++ {  // 2**48 - 2**24\n\t\tp224Square(&f3, &f3, &c)\n\t}\n\tp224Mul(&f3, &f3, &f2, &c) // 2**48 - 1\n\tp224Square(&f4, &f3, &c)   // 2**49 - 2\n\tfor i := 0; i < 47; i++ {  // 2**96 - 2**48\n\t\tp224Square(&f4, &f4, &c)\n\t}\n\tp224Mul(&f3, &f3, &f4, &c) // 2**96 - 1\n\tp224Square(&f4, &f3, &c)   // 2**97 - 2\n\tfor i := 0; i < 23; i++ {  // 2**120 - 2**24\n\t\tp224Square(&f4, &f4, &c)\n\t}\n\tp224Mul(&f2, &f4, &f2, &c) // 2**120 - 1\n\tfor i := 0; i < 6; i++ {   // 2**126 - 2**6\n\t\tp224Square(&f2, &f2, &c)\n\t}\n\tp224Mul(&f1, &f1, &f2, &c) // 2**126 - 1\n\tp224Square(&f1, &f1, &c)   // 2**127 - 2\n\tp224Mul(&f1, &f1, in, &c)  // 2**127 - 1\n\tfor i := 0; i < 97; i++ {  // 2**224 - 2**97\n\t\tp224Square(&f1, &f1, &c)\n\t}\n\tp224Mul(out, &f1, &f3, &c) // 2**224 - 2**96 - 1\n}\n\n// p224Contract converts a FieldElement to its unique, minimal form.\n//\n// On entry, in[i] < 2**29\n// On exit, out[i] < 2**28 and out < p\nfunc p224Contract(out, in *p224FieldElement) {\n\tcopy(out[:], in[:])\n\n\t// First, carry the bits above 28 to the higher limb.\n\tfor i := 0; i < 7; i++ {\n\t\tout[i+1] += out[i] >> 28\n\t\tout[i] &= bottom28Bits\n\t}\n\ttop := out[7] >> 28\n\tout[7] &= bottom28Bits\n\n\t// Use the reduction identity to carry the overflow.\n\t//\n\t//   a + top * 2\u00b2\u00b2\u2074 = a + top * 2\u2079\u2076 - top\n\tout[0] -= top\n\tout[3] += top << 12\n\n\t// We may just have made out[0] negative. So we carry down. If we made\n\t// out[0] negative then we know that out[3] is sufficiently positive\n\t// because we just added to it.\n\tfor i := 0; i < 3; i++ {\n\t\tmask := uint32(int32(out[i]) >> 31)\n\t\tout[i] += (1 << 28) & mask\n\t\tout[i+1] -= 1 & mask\n\t}\n\n\t// We might have pushed out[3] over 2**28 so we perform another, partial,\n\t// carry chain.\n\tfor i := 3; i < 7; i++ {\n\t\tout[i+1] += out[i] >> 28\n\t\tout[i] &= bottom28Bits\n\t}\n\ttop = out[7] >> 28\n\tout[7] &= bottom28Bits\n\n\t// Eliminate top while maintaining the same value mod p.\n\tout[0] -= top\n\tout[3] += top << 12\n\n\t// There are two cases to consider for out[3]:\n\t//   1) The first time that we eliminated top, we didn't push out[3] over\n\t//      2**28. In this case, the partial carry chain didn't change any values\n\t//      and top is now zero.\n\t//   2) We did push out[3] over 2**28 the first time that we eliminated top.\n\t//      The first value of top was in [0..2], therefore, after overflowing\n\t//      and being reduced by the second carry chain, out[3] <= 2<<12 - 1.\n\t// In both cases, out[3] cannot have overflowed when we eliminated top for\n\t// the second time.\n\n\t// Again, we may just have made out[0] negative, so do the same carry down.\n\t// As before, if we made out[0] negative then we know that out[3] is\n\t// sufficiently positive.\n\tfor i := 0; i < 3; i++ {\n\t\tmask := uint32(int32(out[i]) >> 31)\n\t\tout[i] += (1 << 28) & mask\n\t\tout[i+1] -= 1 & mask\n\t}\n\n\t// Now we see if the value is >= p and, if so, subtract p.\n\n\t// First we build a mask from the top four limbs, which must all be\n\t// equal to bottom28Bits if the whole value is >= p. If top4AllOnes\n\t// ends up with any zero bits in the bottom 28 bits, then this wasn't\n\t// true.\n\ttop4AllOnes := uint32(0xffffffff)\n\tfor i := 4; i < 8; i++ {\n\t\ttop4AllOnes &= out[i]\n\t}\n\ttop4AllOnes |= 0xf0000000\n\t// Now we replicate any zero bits to all the bits in top4AllOnes.\n\ttop4AllOnes &= top4AllOnes >> 16\n\ttop4AllOnes &= top4AllOnes >> 8\n\ttop4AllOnes &= top4AllOnes >> 4\n\ttop4AllOnes &= top4AllOnes >> 2\n\ttop4AllOnes &= top4AllOnes >> 1\n\ttop4AllOnes = uint32(int32(top4AllOnes<<31) >> 31)\n\n\t// Now we test whether the bottom three limbs are non-zero.\n\tbottom3NonZero := out[0] | out[1] | out[2]\n\tbottom3NonZero |= bottom3NonZero >> 16\n\tbottom3NonZero |= bottom3NonZero >> 8\n\tbottom3NonZero |= bottom3NonZero >> 4\n\tbottom3NonZero |= bottom3NonZero >> 2\n\tbottom3NonZero |= bottom3NonZero >> 1\n\tbottom3NonZero = uint32(int32(bottom3NonZero<<31) >> 31)\n\n\t// Assuming top4AllOnes != 0, everything depends on the value of out[3].\n\t//    If it's > 0xffff000 then the whole value is > p\n\t//    If it's = 0xffff000 and bottom3NonZero != 0, then the whole value is >= p\n\t//    If it's < 0xffff000, then the whole value is < p\n\tn := 0xffff000 - out[3]\n\tout3Equal := n\n\tout3Equal |= out3Equal >> 16\n\tout3Equal |= out3Equal >> 8\n\tout3Equal |= out3Equal >> 4\n\tout3Equal |= out3Equal >> 2\n\tout3Equal |= out3Equal >> 1\n\tout3Equal = ^uint32(int32(out3Equal<<31) >> 31)\n\n\t// If out[3] > 0xffff000 then n's MSB will be one.\n\tout3GT := uint32(int32(n) >> 31)\n\n\tmask := top4AllOnes & ((out3Equal & bottom3NonZero) | out3GT)\n\tout[0] -= 1 & mask\n\tout[3] -= 0xffff000 & mask\n\tout[4] -= 0xfffffff & mask\n\tout[5] -= 0xfffffff & mask\n\tout[6] -= 0xfffffff & mask\n\tout[7] -= 0xfffffff & mask\n\n\t// Do one final carry down, in case we made out[0] negative. One of\n\t// out[0..3] needs to be positive and able to absorb the -1 or the value\n\t// would have been < p, and the subtraction wouldn't have happened.\n\tfor i := 0; i < 3; i++ {\n\t\tmask := uint32(int32(out[i]) >> 31)\n\t\tout[i] += (1 << 28) & mask\n\t\tout[i+1] -= 1 & mask\n\t}\n}\n\n// Group element functions.\n//\n// These functions deal with group elements. The group is an elliptic curve\n// group with a = -3 defined in FIPS 186-3, section D.2.2.\n\n// p224AddJacobian computes *out = a+b where a != b.\nfunc p224AddJacobian(x3, y3, z3, x1, y1, z1, x2, y2, z2 *p224FieldElement) {\n\t// See https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#addition-p224Add-2007-bl\n\tvar z1z1, z2z2, u1, u2, s1, s2, h, i, j, r, v p224FieldElement\n\tvar c p224LargeFieldElement\n\n\tz1IsZero := p224IsZero(z1)\n\tz2IsZero := p224IsZero(z2)\n\n\t// Z1Z1 = Z1\u00b2\n\tp224Square(&z1z1, z1, &c)\n\t// Z2Z2 = Z2\u00b2\n\tp224Square(&z2z2, z2, &c)\n\t// U1 = X1*Z2Z2\n\tp224Mul(&u1, x1, &z2z2, &c)\n\t// U2 = X2*Z1Z1\n\tp224Mul(&u2, x2, &z1z1, &c)\n\t// S1 = Y1*Z2*Z2Z2\n\tp224Mul(&s1, z2, &z2z2, &c)\n\tp224Mul(&s1, y1, &s1, &c)\n\t// S2 = Y2*Z1*Z1Z1\n\tp224Mul(&s2, z1, &z1z1, &c)\n\tp224Mul(&s2, y2, &s2, &c)\n\t// H = U2-U1\n\tp224Sub(&h, &u2, &u1)\n\tp224Reduce(&h)\n\txEqual := p224IsZero(&h)\n\t// I = (2*H)\u00b2\n\tfor j := 0; j < 8; j++ {\n\t\ti[j] = h[j] << 1\n\t}\n\tp224Reduce(&i)\n\tp224Square(&i, &i, &c)\n\t// J = H*I\n\tp224Mul(&j, &h, &i, &c)\n\t// r = 2*(S2-S1)\n\tp224Sub(&r, &s2, &s1)\n\tp224Reduce(&r)\n\tyEqual := p224IsZero(&r)\n\tif xEqual == 1 && yEqual == 1 && z1IsZero == 0 && z2IsZero == 0 {\n\t\tp224DoubleJacobian(x3, y3, z3, x1, y1, z1)\n\t\treturn\n\t}\n\tfor i := 0; i < 8; i++ {\n\t\tr[i] <<= 1\n\t}\n\tp224Reduce(&r)\n\t// V = U1*I\n\tp224Mul(&v, &u1, &i, &c)\n\t// Z3 = ((Z1+Z2)\u00b2-Z1Z1-Z2Z2)*H\n\tp224Add(&z1z1, &z1z1, &z2z2)\n\tp224Add(&z2z2, z1, z2)\n\tp224Reduce(&z2z2)\n\tp224Square(&z2z2, &z2z2, &c)\n\tp224Sub(z3, &z2z2, &z1z1)\n\tp224Reduce(z3)\n\tp224Mul(z3, z3, &h, &c)\n\t// X3 = r\u00b2-J-2*V\n\tfor i := 0; i < 8; i++ {\n\t\tz1z1[i] = v[i] << 1\n\t}\n\tp224Add(&z1z1, &j, &z1z1)\n\tp224Reduce(&z1z1)\n\tp224Square(x3, &r, &c)\n\tp224Sub(x3, x3, &z1z1)\n\tp224Reduce(x3)\n\t// Y3 = r*(V-X3)-2*S1*J\n\tfor i := 0; i < 8; i++ {\n\t\ts1[i] <<= 1\n\t}\n\tp224Mul(&s1, &s1, &j, &c)\n\tp224Sub(&z1z1, &v, x3)\n\tp224Reduce(&z1z1)\n\tp224Mul(&z1z1, &z1z1, &r, &c)\n\tp224Sub(y3, &z1z1, &s1)\n\tp224Reduce(y3)\n\n\tp224CopyConditional(x3, x2, z1IsZero)\n\tp224CopyConditional(x3, x1, z2IsZero)\n\tp224CopyConditional(y3, y2, z1IsZero)\n\tp224CopyConditional(y3, y1, z2IsZero)\n\tp224CopyConditional(z3, z2, z1IsZero)\n\tp224CopyConditional(z3, z1, z2IsZero)\n}\n\n// p224DoubleJacobian computes *out = a+a.\nfunc p224DoubleJacobian(x3, y3, z3, x1, y1, z1 *p224FieldElement) {\n\tvar delta, gamma, beta, alpha, t p224FieldElement\n\tvar c p224LargeFieldElement\n\n\tp224Square(&delta, z1, &c)\n\tp224Square(&gamma, y1, &c)\n\tp224Mul(&beta, x1, &gamma, &c)\n\n\t// alpha = 3*(X1-delta)*(X1+delta)\n\tp224Add(&t, x1, &delta)\n\tfor i := 0; i < 8; i++ {\n\t\tt[i] += t[i] << 1\n\t}\n\tp224Reduce(&t)\n\tp224Sub(&alpha, x1, &delta)\n\tp224Reduce(&alpha)\n\tp224Mul(&alpha, &alpha, &t, &c)\n\n\t// Z3 = (Y1+Z1)\u00b2-gamma-delta\n\tp224Add(z3, y1, z1)\n\tp224Reduce(z3)\n\tp224Square(z3, z3, &c)\n\tp224Sub(z3, z3, &gamma)\n\tp224Reduce(z3)\n\tp224Sub(z3, z3, &delta)\n\tp224Reduce(z3)\n\n\t// X3 = alpha\u00b2-8*beta\n\tfor i := 0; i < 8; i++ {\n\t\tdelta[i] = beta[i] << 3\n\t}\n\tp224Reduce(&delta)\n\tp224Square(x3, &alpha, &c)\n\tp224Sub(x3, x3, &delta)\n\tp224Reduce(x3)\n\n\t// Y3 = alpha*(4*beta-X3)-8*gamma\u00b2\n\tfor i := 0; i < 8; i++ {\n\t\tbeta[i] <<= 2\n\t}\n\tp224Sub(&beta, &beta, x3)\n\tp224Reduce(&beta)\n\tp224Square(&gamma, &gamma, &c)\n\tfor i := 0; i < 8; i++ {\n\t\tgamma[i] <<= 3\n\t}\n\tp224Reduce(&gamma)\n\tp224Mul(y3, &alpha, &beta, &c)\n\tp224Sub(y3, y3, &gamma)\n\tp224Reduce(y3)\n}\n\n// p224CopyConditional sets *out = *in iff the least-significant-bit of control\n// is true, and it runs in constant time.\nfunc p224CopyConditional(out, in *p224FieldElement, control uint32) {\n\tcontrol <<= 31\n\tcontrol = uint32(int32(control) >> 31)\n\n\tfor i := 0; i < 8; i++ {\n\t\tout[i] ^= (out[i] ^ in[i]) & control\n\t}\n}\n\nfunc p224ScalarMult(outX, outY, outZ, inX, inY, inZ *p224FieldElement, scalar []byte) {\n\tvar xx, yy, zz p224FieldElement\n\tfor i := 0; i < 8; i++ {\n\t\toutX[i] = 0\n\t\toutY[i] = 0\n\t\toutZ[i] = 0\n\t}\n\n\tfor _, byte := range scalar {\n\t\tfor bitNum := uint(0); bitNum < 8; bitNum++ {\n\t\t\tp224DoubleJacobian(outX, outY, outZ, outX, outY, outZ)\n\t\t\tbit := uint32((byte >> (7 - bitNum)) & 1)\n\t\t\tp224AddJacobian(&xx, &yy, &zz, inX, inY, inZ, outX, outY, outZ)\n\t\t\tp224CopyConditional(outX, &xx, bit)\n\t\t\tp224CopyConditional(outY, &yy, bit)\n\t\t\tp224CopyConditional(outZ, &zz, bit)\n\t\t}\n\t}\n}\n\n// p224ToAffine converts from Jacobian to affine form.\nfunc p224ToAffine(x, y, z *p224FieldElement) (*big.Int, *big.Int) {\n\tvar zinv, zinvsq, outx, outy p224FieldElement\n\tvar tmp p224LargeFieldElement\n\n\tif isPointAtInfinity := p224IsZero(z); isPointAtInfinity == 1 {\n\t\treturn new(big.Int), new(big.Int)\n\t}\n\n\tp224Invert(&zinv, z)\n\tp224Square(&zinvsq, &zinv, &tmp)\n\tp224Mul(x, x, &zinvsq, &tmp)\n\tp224Mul(&zinvsq, &zinvsq, &zinv, &tmp)\n\tp224Mul(y, y, &zinvsq, &tmp)\n\n\tp224Contract(&outx, x)\n\tp224Contract(&outy, y)\n\treturn p224ToBig(&outx), p224ToBig(&outy)\n}\n\n// get28BitsFromEnd returns the least-significant 28 bits from buf>>shift,\n// where buf is interpreted as a big-endian number.\nfunc get28BitsFromEnd(buf []byte, shift uint) (uint32, []byte) {\n\tvar ret uint32\n\n\tfor i := uint(0); i < 4; i++ {\n\t\tvar b byte\n\t\tif l := len(buf); l > 0 {\n\t\t\tb = buf[l-1]\n\t\t\t// We don't remove the byte if we're about to return and we're not\n\t\t\t// reading all of it.\n\t\t\tif i != 3 || shift == 4 {\n\t\t\t\tbuf = buf[:l-1]\n\t\t\t}\n\t\t}\n\t\tret |= uint32(b) << (8 * i) >> shift\n\t}\n\tret &= bottom28Bits\n\treturn ret, buf\n}\n\n// p224FromBig sets *out = *in.\nfunc p224FromBig(out *p224FieldElement, in *big.Int) {\n\tbytes := in.Bytes()\n\tout[0], bytes = get28BitsFromEnd(bytes, 0)\n\tout[1], bytes = get28BitsFromEnd(bytes, 4)\n\tout[2], bytes = get28BitsFromEnd(bytes, 0)\n\tout[3], bytes = get28BitsFromEnd(bytes, 4)\n\tout[4], bytes = get28BitsFromEnd(bytes, 0)\n\tout[5], bytes = get28BitsFromEnd(bytes, 4)\n\tout[6], bytes = get28BitsFromEnd(bytes, 0)\n\tout[7], bytes = get28BitsFromEnd(bytes, 4)\n}\n\n// p224ToBig returns in as a big.Int.\nfunc p224ToBig(in *p224FieldElement) *big.Int {\n\tvar buf [28]byte\n\tbuf[27] = byte(in[0])\n\tbuf[26] = byte(in[0] >> 8)\n\tbuf[25] = byte(in[0] >> 16)\n\tbuf[24] = byte(((in[0] >> 24) & 0x0f) | (in[1]<<4)&0xf0)\n\n\tbuf[23] = byte(in[1] >> 4)\n\tbuf[22] = byte(in[1] >> 12)\n\tbuf[21] = byte(in[1] >> 20)\n\n\tbuf[20] = byte(in[2])\n\tbuf[19] = byte(in[2] >> 8)\n\tbuf[18] = byte(in[2] >> 16)\n\tbuf[17] = byte(((in[2] >> 24) & 0x0f) | (in[3]<<4)&0xf0)\n\n\tbuf[16] = byte(in[3] >> 4)\n\tbuf[15] = byte(in[3] >> 12)\n\tbuf[14] = byte(in[3] >> 20)\n\n\tbuf[13] = byte(in[4])\n\tbuf[12] = byte(in[4] >> 8)\n\tbuf[11] = byte(in[4] >> 16)\n\tbuf[10] = byte(((in[4] >> 24) & 0x0f) | (in[5]<<4)&0xf0)\n\n\tbuf[9] = byte(in[5] >> 4)\n\tbuf[8] = byte(in[5] >> 12)\n\tbuf[7] = byte(in[5] >> 20)\n\n\tbuf[6] = byte(in[6])\n\tbuf[5] = byte(in[6] >> 8)\n\tbuf[4] = byte(in[6] >> 16)\n\tbuf[3] = byte(((in[6] >> 24) & 0x0f) | (in[7]<<4)&0xf0)\n\n\tbuf[2] = byte(in[7] >> 4)\n\tbuf[1] = byte(in[7] >> 12)\n\tbuf[0] = byte(in[7] >> 20)\n\n\treturn new(big.Int).SetBytes(buf[:])\n}\n", "// Copyright 2012 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage elliptic\n\nimport (\n\t\"math/big\"\n\t\"math/bits\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"testing\"\n\t\"testing/quick\"\n)\n\nvar toFromBigTests = []string{\n\t\"0\",\n\t\"1\",\n\t\"23\",\n\t\"b70e0cb46bb4bf7f321390b94a03c1d356c01122343280d6105c1d21\",\n\t\"706a46d476dcb76798e6046d89474788d164c18032d268fd10704fa6\",\n}\n\nfunc p224AlternativeToBig(in *p224FieldElement) *big.Int {\n\tret := new(big.Int)\n\ttmp := new(big.Int)\n\n\tfor i := len(in) - 1; i >= 0; i-- {\n\t\tret.Lsh(ret, 28)\n\t\ttmp.SetInt64(int64(in[i]))\n\t\tret.Add(ret, tmp)\n\t}\n\tret.Mod(ret, P224().Params().P)\n\treturn ret\n}\n\nfunc TestP224ToFromBig(t *testing.T) {\n\tfor i, test := range toFromBigTests {\n\t\tn, _ := new(big.Int).SetString(test, 16)\n\t\tvar x p224FieldElement\n\t\tp224FromBig(&x, n)\n\t\tm := p224ToBig(&x)\n\t\tif n.Cmp(m) != 0 {\n\t\t\tt.Errorf(\"#%d: %x != %x\", i, n, m)\n\t\t}\n\t\tq := p224AlternativeToBig(&x)\n\t\tif n.Cmp(q) != 0 {\n\t\t\tt.Errorf(\"#%d: %x != %x (alternative)\", i, n, q)\n\t\t}\n\t}\n}\n\n// quickCheckConfig32 will make each quickcheck test run (32 * -quickchecks)\n// times. The default value of -quickchecks is 100.\nvar quickCheckConfig32 = &quick.Config{MaxCountScale: 32}\n\n// weirdLimbs can be combined to generate a range of edge-case field elements.\nvar weirdLimbs = [...]uint32{\n\t0, 1, (1 << 29) - 1,\n\t(1 << 12), (1 << 12) - 1,\n\t(1 << 28), (1 << 28) - 1,\n}\n\nfunc generateLimb(rand *rand.Rand) uint32 {\n\tconst bottom29Bits = 0x1fffffff\n\tn := rand.Intn(len(weirdLimbs) + 3)\n\tswitch n {\n\tcase len(weirdLimbs):\n\t\t// Random value.\n\t\treturn uint32(rand.Int31n(1 << 29))\n\tcase len(weirdLimbs) + 1:\n\t\t// Sum of two values.\n\t\tk := generateLimb(rand) + generateLimb(rand)\n\t\treturn k & bottom29Bits\n\tcase len(weirdLimbs) + 2:\n\t\t// Difference of two values.\n\t\tk := generateLimb(rand) - generateLimb(rand)\n\t\treturn k & bottom29Bits\n\tdefault:\n\t\treturn weirdLimbs[n]\n\t}\n}\n\nfunc (p224FieldElement) Generate(rand *rand.Rand, size int) reflect.Value {\n\treturn reflect.ValueOf(p224FieldElement{\n\t\tgenerateLimb(rand),\n\t\tgenerateLimb(rand),\n\t\tgenerateLimb(rand),\n\t\tgenerateLimb(rand),\n\t\tgenerateLimb(rand),\n\t\tgenerateLimb(rand),\n\t\tgenerateLimb(rand),\n\t\tgenerateLimb(rand),\n\t})\n}\n\nfunc isInBounds(x *p224FieldElement) bool {\n\treturn bits.Len32(x[0]) <= 29 &&\n\t\tbits.Len32(x[1]) <= 29 &&\n\t\tbits.Len32(x[2]) <= 29 &&\n\t\tbits.Len32(x[3]) <= 29 &&\n\t\tbits.Len32(x[4]) <= 29 &&\n\t\tbits.Len32(x[5]) <= 29 &&\n\t\tbits.Len32(x[6]) <= 29 &&\n\t\tbits.Len32(x[7]) <= 29\n}\n\nfunc TestP224Mul(t *testing.T) {\n\tmulMatchesBigInt := func(a, b, out p224FieldElement) bool {\n\t\tvar tmp p224LargeFieldElement\n\t\tp224Mul(&out, &a, &b, &tmp)\n\n\t\texp := new(big.Int).Mul(p224AlternativeToBig(&a), p224AlternativeToBig(&b))\n\t\texp.Mod(exp, P224().Params().P)\n\t\tgot := p224AlternativeToBig(&out)\n\t\tif exp.Cmp(got) != 0 || !isInBounds(&out) {\n\t\t\tt.Logf(\"a = %x\", a)\n\t\t\tt.Logf(\"b = %x\", b)\n\t\t\tt.Logf(\"p224Mul(a, b) = %x = %v\", out, got)\n\t\t\tt.Logf(\"a * b = %v\", exp)\n\t\t\treturn false\n\t\t}\n\n\t\treturn true\n\t}\n\n\ta := p224FieldElement{0xfffffff, 0xfffffff, 0xf00ffff, 0x20f, 0x0, 0x0, 0x0, 0x0}\n\tb := p224FieldElement{1, 0, 0, 0, 0, 0, 0, 0}\n\tif !mulMatchesBigInt(a, b, p224FieldElement{}) {\n\t\tt.Fail()\n\t}\n\n\tif err := quick.Check(mulMatchesBigInt, quickCheckConfig32); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestP224Square(t *testing.T) {\n\tsquareMatchesBigInt := func(a, out p224FieldElement) bool {\n\t\tvar tmp p224LargeFieldElement\n\t\tp224Square(&out, &a, &tmp)\n\n\t\texp := p224AlternativeToBig(&a)\n\t\texp.Mul(exp, exp)\n\t\texp.Mod(exp, P224().Params().P)\n\t\tgot := p224AlternativeToBig(&out)\n\t\tif exp.Cmp(got) != 0 || !isInBounds(&out) {\n\t\t\tt.Logf(\"a = %x\", a)\n\t\t\tt.Logf(\"p224Square(a, b) = %x = %v\", out, got)\n\t\t\tt.Logf(\"a * a = %v\", exp)\n\t\t\treturn false\n\t\t}\n\n\t\treturn true\n\t}\n\n\tif err := quick.Check(squareMatchesBigInt, quickCheckConfig32); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestP224Add(t *testing.T) {\n\taddMatchesBigInt := func(a, b, out p224FieldElement) bool {\n\t\tp224Add(&out, &a, &b)\n\n\t\texp := new(big.Int).Add(p224AlternativeToBig(&a), p224AlternativeToBig(&b))\n\t\texp.Mod(exp, P224().Params().P)\n\t\tgot := p224AlternativeToBig(&out)\n\t\tif exp.Cmp(got) != 0 {\n\t\t\tt.Logf(\"a = %x\", a)\n\t\t\tt.Logf(\"b = %x\", b)\n\t\t\tt.Logf(\"p224Add(a, b) = %x = %v\", out, got)\n\t\t\tt.Logf(\"a + b = %v\", exp)\n\t\t\treturn false\n\t\t}\n\n\t\treturn true\n\t}\n\n\tif err := quick.Check(addMatchesBigInt, quickCheckConfig32); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestP224Reduce(t *testing.T) {\n\treduceMatchesBigInt := func(a p224FieldElement) bool {\n\t\tout := a\n\t\t// TODO: generate higher values for functions like p224Reduce that are\n\t\t// expected to work with higher input bounds.\n\t\tp224Reduce(&out)\n\n\t\texp := p224AlternativeToBig(&a)\n\t\tgot := p224AlternativeToBig(&out)\n\t\tif exp.Cmp(got) != 0 || !isInBounds(&out) {\n\t\t\tt.Logf(\"a = %x = %v\", a, exp)\n\t\t\tt.Logf(\"p224Reduce(a) = %x = %v\", out, got)\n\t\t\treturn false\n\t\t}\n\n\t\treturn true\n\t}\n\n\tif err := quick.Check(reduceMatchesBigInt, quickCheckConfig32); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestP224Contract(t *testing.T) {\n\tcontractMatchesBigInt := func(a, out p224FieldElement) bool {\n\t\tp224Contract(&out, &a)\n\n\t\texp := p224AlternativeToBig(&a)\n\t\tgot := p224AlternativeToBig(&out)\n\t\tif exp.Cmp(got) != 0 {\n\t\t\tt.Logf(\"a = %x = %v\", a, exp)\n\t\t\tt.Logf(\"p224Contract(a) = %x = %v\", out, got)\n\t\t\treturn false\n\t\t}\n\n\t\t// Check that out < P.\n\t\tfor i := range p224P {\n\t\t\tk := 8 - i - 1\n\t\t\tif out[k] > p224P[k] {\n\t\t\t\tt.Logf(\"p224Contract(a) = %x\", out)\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif out[k] < p224P[k] {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\tt.Logf(\"p224Contract(a) = %x\", out)\n\t\treturn false\n\t}\n\n\tif !contractMatchesBigInt(p224P, p224FieldElement{}) {\n\t\tt.Error(\"p224Contract(p) is broken\")\n\t}\n\tpMinus1 := p224FieldElement{0, 0, 0, 0xffff000, 0xfffffff, 0xfffffff, 0xfffffff, 0xfffffff}\n\tif !contractMatchesBigInt(pMinus1, p224FieldElement{}) {\n\t\tt.Error(\"p224Contract(p - 1) is broken\")\n\t}\n\t// Check that we can handle input above p, but lowest limb zero.\n\ta := p224FieldElement{0, 1, 0, 0xffff000, 0xfffffff, 0xfffffff, 0xfffffff, 0xfffffff}\n\tif !contractMatchesBigInt(a, p224FieldElement{}) {\n\t\tt.Error(\"p224Contract(p + 2\u00b2\u2078) is broken\")\n\t}\n\t// Check that we can handle input above p, but lowest three limbs zero.\n\tb := p224FieldElement{0, 0, 0, 0xffff001, 0xfffffff, 0xfffffff, 0xfffffff, 0xfffffff}\n\tif !contractMatchesBigInt(b, p224FieldElement{}) {\n\t\tt.Error(\"p224Contract(p + 2\u2078\u2074) is broken\")\n\t}\n\n\tif err := quick.Check(contractMatchesBigInt, quickCheckConfig32); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestP224IsZero(t *testing.T) {\n\tif got := p224IsZero(&p224FieldElement{}); got != 1 {\n\t\tt.Errorf(\"p224IsZero(0) = %d, expected 1\", got)\n\t}\n\tif got := p224IsZero((*p224FieldElement)(&p224P)); got != 1 {\n\t\tt.Errorf(\"p224IsZero(p) = %d, expected 1\", got)\n\t}\n\tif got := p224IsZero(&p224FieldElement{1}); got != 0 {\n\t\tt.Errorf(\"p224IsZero(1) = %d, expected 0\", got)\n\t}\n\n\tisZeroMatchesBigInt := func(a p224FieldElement) bool {\n\t\tisZero := p224IsZero(&a)\n\n\t\tbig := p224AlternativeToBig(&a)\n\t\tif big.Sign() == 0 && isZero != 1 {\n\t\t\treturn false\n\t\t}\n\t\tif big.Sign() != 0 && isZero != 0 {\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n\n\tif err := quick.Check(isZeroMatchesBigInt, quickCheckConfig32); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestP224Invert(t *testing.T) {\n\tvar out p224FieldElement\n\n\tp224Invert(&out, &p224FieldElement{})\n\tif got := p224IsZero(&out); got != 1 {\n\t\tt.Errorf(\"p224Invert(0) = %x, expected 0\", out)\n\t}\n\n\tp224Invert(&out, (*p224FieldElement)(&p224P))\n\tif got := p224IsZero(&out); got != 1 {\n\t\tt.Errorf(\"p224Invert(p) = %x, expected 0\", out)\n\t}\n\n\tp224Invert(&out, &p224FieldElement{1})\n\tp224Contract(&out, &out)\n\tif out != (p224FieldElement{1}) {\n\t\tt.Errorf(\"p224Invert(1) = %x, expected 1\", out)\n\t}\n\n\tvar tmp p224LargeFieldElement\n\ta := p224FieldElement{1, 2, 3, 4, 5, 6, 7, 8}\n\tp224Invert(&out, &a)\n\tp224Mul(&out, &out, &a, &tmp)\n\tp224Contract(&out, &out)\n\tif out != (p224FieldElement{1}) {\n\t\tt.Errorf(\"p224Invert(a) * a = %x, expected 1\", out)\n\t}\n}\n"], "filenames": ["src/crypto/elliptic/p224.go", "src/crypto/elliptic/p224_test.go"], "buggy_code_start_loc": [389, 8], "buggy_code_end_loc": [496, 48], "fixing_code_start_loc": [389, 9], "fixing_code_end_loc": [508, 315], "type": "CWE-682", "message": "In Go before 1.14.14 and 1.15.x before 1.15.7, crypto/elliptic/p224.go can generate incorrect outputs, related to an underflow of the lowest limb during the final complete reduction in the P-224 field.", "other": {"cve": {"id": "CVE-2021-3114", "sourceIdentifier": "cve@mitre.org", "published": "2021-01-26T18:16:27.567", "lastModified": "2022-09-14T21:02:40.880", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Go before 1.14.14 and 1.15.x before 1.15.7, crypto/elliptic/p224.go can generate incorrect outputs, related to an underflow of the lowest limb during the final complete reduction in the P-224 field."}, {"lang": "es", "value": "En Go versiones anteriores a 1.14.14 y versiones 1.15.x anteriores a 1.15.7, en el archivo crypto/elliptic/p224.go puede generar salidas incorrectas, relacionadas con un subdesbordamiento de la extremidad m\u00e1s baja durante la reducci\u00f3n completa final en el campo P-224"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-682"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:golang:go:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.14.14", "matchCriteriaId": "70690A8F-9E7C-4208-9550-254B1000BF93"}, {"vulnerable": true, "criteria": "cpe:2.3:a:golang:go:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.15", "versionEndExcluding": "1.15.7", "matchCriteriaId": "4C90339E-4E95-4FCE-BCFE-6DD9FB4F9255"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:cloud_insights_telegraf_agent:-:*:*:*:*:*:*:*", "matchCriteriaId": "5DAE7369-EEC5-405E-9D13-858335FDA647"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:storagegrid:-:*:*:*:*:*:*:*", "matchCriteriaId": "8ADFF451-740F-4DBA-BD23-3881945D3E40"}]}]}], "references": [{"url": "https://github.com/golang/go/commit/d95ca9138026cbe40e0857d76a81a16d03230871", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://groups.google.com/g/golang-announce/c/mperVMGa98w", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/03/msg00014.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/03/msg00015.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YWAYJGXWC232SG3UR3TR574E6BP3OSQQ/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-02", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210219-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2021/dsa-4848", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/golang/go/commit/d95ca9138026cbe40e0857d76a81a16d03230871"}}