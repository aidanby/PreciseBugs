{"buggy_code": ["<?php\n/**\n * The WordPress version string\n *\n * @global string $wp_version\n */\n$wp_version = '4.9-alpha-41457';\n\n/**\n * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema.\n *\n * @global int $wp_db_version\n */\n$wp_db_version = 38590;\n\n/**\n * Holds the TinyMCE version\n *\n * @global string $tinymce_version\n */\n$tinymce_version = '4603-20170530';\n\n/**\n * Holds the required PHP version\n *\n * @global string $required_php_version\n */\n$required_php_version = '5.2.4';\n\n/**\n * Holds the required MySQL version\n *\n * @global string $required_mysql_version\n */\n$required_mysql_version = '5.0';\n", "<?php\n/**\n * WordPress DB Class\n *\n * Original code from {@link http://php.justinvincent.com Justin Vincent (justin@visunet.ie)}\n *\n * @package WordPress\n * @subpackage Database\n * @since 0.71\n */\n\n/**\n * @since 0.71\n */\ndefine( 'EZSQL_VERSION', 'WP1.25' );\n\n/**\n * @since 0.71\n */\ndefine( 'OBJECT', 'OBJECT' );\ndefine( 'object', 'OBJECT' ); // Back compat.\n\n/**\n * @since 2.5.0\n */\ndefine( 'OBJECT_K', 'OBJECT_K' );\n\n/**\n * @since 0.71\n */\ndefine( 'ARRAY_A', 'ARRAY_A' );\n\n/**\n * @since 0.71\n */\ndefine( 'ARRAY_N', 'ARRAY_N' );\n\n/**\n * WordPress Database Access Abstraction Object\n *\n * It is possible to replace this class with your own\n * by setting the $wpdb global variable in wp-content/db.php\n * file to your class. The wpdb class will still be included,\n * so you can extend it or simply use your own.\n *\n * @link https://codex.wordpress.org/Function_Reference/wpdb_Class\n *\n * @since 0.71\n */\nclass wpdb {\n\n\t/**\n\t * Whether to show SQL/DB errors.\n\t *\n\t * Default behavior is to show errors if both WP_DEBUG and WP_DEBUG_DISPLAY\n\t * evaluated to true.\n\t *\n\t * @since 0.71\n\t * @var bool\n\t */\n\tvar $show_errors = false;\n\n\t/**\n\t * Whether to suppress errors during the DB bootstrapping.\n\t *\n\t * @since 2.5.0\n\t * @var bool\n\t */\n\tvar $suppress_errors = false;\n\n\t/**\n\t * The last error during query.\n\t *\n\t * @since 2.5.0\n\t * @var string\n\t */\n\tpublic $last_error = '';\n\n\t/**\n\t * Amount of queries made\n\t *\n\t * @since 1.2.0\n\t * @var int\n\t */\n\tpublic $num_queries = 0;\n\n\t/**\n\t * Count of rows returned by previous query\n\t *\n\t * @since 0.71\n\t * @var int\n\t */\n\tpublic $num_rows = 0;\n\n\t/**\n\t * Count of affected rows by previous query\n\t *\n\t * @since 0.71\n\t * @var int\n\t */\n\tvar $rows_affected = 0;\n\n\t/**\n\t * The ID generated for an AUTO_INCREMENT column by the previous query (usually INSERT).\n\t *\n\t * @since 0.71\n\t * @var int\n\t */\n\tpublic $insert_id = 0;\n\n\t/**\n\t * Last query made\n\t *\n\t * @since 0.71\n\t * @var array\n\t */\n\tvar $last_query;\n\n\t/**\n\t * Results of the last query made\n\t *\n\t * @since 0.71\n\t * @var array|null\n\t */\n\tvar $last_result;\n\n\t/**\n\t * MySQL result, which is either a resource or boolean.\n\t *\n\t * @since 0.71\n\t * @var mixed\n\t */\n\tprotected $result;\n\n\t/**\n\t * Cached column info, for sanity checking data before inserting\n\t *\n\t * @since 4.2.0\n\t * @var array\n\t */\n\tprotected $col_meta = array();\n\n\t/**\n\t * Calculated character sets on tables\n\t *\n\t * @since 4.2.0\n\t * @var array\n\t */\n\tprotected $table_charset = array();\n\n\t/**\n\t * Whether text fields in the current query need to be sanity checked.\n\t *\n\t * @since 4.2.0\n\t * @var bool\n\t */\n\tprotected $check_current_query = true;\n\n\t/**\n\t * Flag to ensure we don't run into recursion problems when checking the collation.\n\t *\n\t * @since 4.2.0\n\t * @see wpdb::check_safe_collation()\n\t * @var bool\n\t */\n\tprivate $checking_collation = false;\n\n\t/**\n\t * Saved info on the table column\n\t *\n\t * @since 0.71\n\t * @var array\n\t */\n\tprotected $col_info;\n\n\t/**\n\t * Saved queries that were executed\n\t *\n\t * @since 1.5.0\n\t * @var array\n\t */\n\tvar $queries;\n\n\t/**\n\t * The number of times to retry reconnecting before dying.\n\t *\n\t * @since 3.9.0\n\t * @see wpdb::check_connection()\n\t * @var int\n\t */\n\tprotected $reconnect_retries = 5;\n\n\t/**\n\t * WordPress table prefix\n\t *\n\t * You can set this to have multiple WordPress installations\n\t * in a single database. The second reason is for possible\n\t * security precautions.\n\t *\n\t * @since 2.5.0\n\t * @var string\n\t */\n\tpublic $prefix = '';\n\n\t/**\n\t * WordPress base table prefix.\n\t *\n\t * @since 3.0.0\n\t * @var string\n\t */\n\t public $base_prefix;\n\n\t/**\n\t * Whether the database queries are ready to start executing.\n\t *\n\t * @since 2.3.2\n\t * @var bool\n\t */\n\tvar $ready = false;\n\n\t/**\n\t * Blog ID.\n\t *\n\t * @since 3.0.0\n\t * @var int\n\t */\n\tpublic $blogid = 0;\n\n\t/**\n\t * Site ID.\n\t *\n\t * @since 3.0.0\n\t * @var int\n\t */\n\tpublic $siteid = 0;\n\n\t/**\n\t * List of WordPress per-blog tables\n\t *\n\t * @since 2.5.0\n\t * @see wpdb::tables()\n\t * @var array\n\t */\n\tvar $tables = array( 'posts', 'comments', 'links', 'options', 'postmeta',\n\t\t'terms', 'term_taxonomy', 'term_relationships', 'termmeta', 'commentmeta' );\n\n\t/**\n\t * List of deprecated WordPress tables\n\t *\n\t * categories, post2cat, and link2cat were deprecated in 2.3.0, db version 5539\n\t *\n\t * @since 2.9.0\n\t * @see wpdb::tables()\n\t * @var array\n\t */\n\tvar $old_tables = array( 'categories', 'post2cat', 'link2cat' );\n\n\t/**\n\t * List of WordPress global tables\n\t *\n\t * @since 3.0.0\n\t * @see wpdb::tables()\n\t * @var array\n\t */\n\tvar $global_tables = array( 'users', 'usermeta' );\n\n\t/**\n\t * List of Multisite global tables\n\t *\n\t * @since 3.0.0\n\t * @see wpdb::tables()\n\t * @var array\n\t */\n\tvar $ms_global_tables = array( 'blogs', 'signups', 'site', 'sitemeta',\n\t\t'sitecategories', 'registration_log', 'blog_versions' );\n\n\t/**\n\t * WordPress Comments table\n\t *\n\t * @since 1.5.0\n\t * @var string\n\t */\n\tpublic $comments;\n\n\t/**\n\t * WordPress Comment Metadata table\n\t *\n\t * @since 2.9.0\n\t * @var string\n\t */\n\tpublic $commentmeta;\n\n\t/**\n\t * WordPress Links table\n\t *\n\t * @since 1.5.0\n\t * @var string\n\t */\n\tpublic $links;\n\n\t/**\n\t * WordPress Options table\n\t *\n\t * @since 1.5.0\n\t * @var string\n\t */\n\tpublic $options;\n\n\t/**\n\t * WordPress Post Metadata table\n\t *\n\t * @since 1.5.0\n\t * @var string\n\t */\n\tpublic $postmeta;\n\n\t/**\n\t * WordPress Posts table\n\t *\n\t * @since 1.5.0\n\t * @var string\n\t */\n\tpublic $posts;\n\n\t/**\n\t * WordPress Terms table\n\t *\n\t * @since 2.3.0\n\t * @var string\n\t */\n\tpublic $terms;\n\n\t/**\n\t * WordPress Term Relationships table\n\t *\n\t * @since 2.3.0\n\t * @var string\n\t */\n\tpublic $term_relationships;\n\n\t/**\n\t * WordPress Term Taxonomy table\n\t *\n\t * @since 2.3.0\n\t * @var string\n\t */\n\tpublic $term_taxonomy;\n\n\t/**\n\t * WordPress Term Meta table.\n\t *\n\t * @since 4.4.0\n\t * @var string\n\t */\n\tpublic $termmeta;\n\n\t//\n\t// Global and Multisite tables\n\t//\n\n\t/**\n\t * WordPress User Metadata table\n\t *\n\t * @since 2.3.0\n\t * @var string\n\t */\n\tpublic $usermeta;\n\n\t/**\n\t * WordPress Users table\n\t *\n\t * @since 1.5.0\n\t * @var string\n\t */\n\tpublic $users;\n\n\t/**\n\t * Multisite Blogs table\n\t *\n\t * @since 3.0.0\n\t * @var string\n\t */\n\tpublic $blogs;\n\n\t/**\n\t * Multisite Blog Versions table\n\t *\n\t * @since 3.0.0\n\t * @var string\n\t */\n\tpublic $blog_versions;\n\n\t/**\n\t * Multisite Registration Log table\n\t *\n\t * @since 3.0.0\n\t * @var string\n\t */\n\tpublic $registration_log;\n\n\t/**\n\t * Multisite Signups table\n\t *\n\t * @since 3.0.0\n\t * @var string\n\t */\n\tpublic $signups;\n\n\t/**\n\t * Multisite Sites table\n\t *\n\t * @since 3.0.0\n\t * @var string\n\t */\n\tpublic $site;\n\n\t/**\n\t * Multisite Sitewide Terms table\n\t *\n\t * @since 3.0.0\n\t * @var string\n\t */\n\tpublic $sitecategories;\n\n\t/**\n\t * Multisite Site Metadata table\n\t *\n\t * @since 3.0.0\n\t * @var string\n\t */\n\tpublic $sitemeta;\n\n\t/**\n\t * Format specifiers for DB columns. Columns not listed here default to %s. Initialized during WP load.\n\t *\n\t * Keys are column names, values are format types: 'ID' => '%d'\n\t *\n\t * @since 2.8.0\n\t * @see wpdb::prepare()\n\t * @see wpdb::insert()\n\t * @see wpdb::update()\n\t * @see wpdb::delete()\n\t * @see wp_set_wpdb_vars()\n\t * @var array\n\t */\n\tpublic $field_types = array();\n\n\t/**\n\t * Database table columns charset\n\t *\n\t * @since 2.2.0\n\t * @var string\n\t */\n\tpublic $charset;\n\n\t/**\n\t * Database table columns collate\n\t *\n\t * @since 2.2.0\n\t * @var string\n\t */\n\tpublic $collate;\n\n\t/**\n\t * Database Username\n\t *\n\t * @since 2.9.0\n\t * @var string\n\t */\n\tprotected $dbuser;\n\n\t/**\n\t * Database Password\n\t *\n\t * @since 3.1.0\n\t * @var string\n\t */\n\tprotected $dbpassword;\n\n\t/**\n\t * Database Name\n\t *\n\t * @since 3.1.0\n\t * @var string\n\t */\n\tprotected $dbname;\n\n\t/**\n\t * Database Host\n\t *\n\t * @since 3.1.0\n\t * @var string\n\t */\n\tprotected $dbhost;\n\n\t/**\n\t * Database Handle\n\t *\n\t * @since 0.71\n\t * @var string\n\t */\n\tprotected $dbh;\n\n\t/**\n\t * A textual description of the last query/get_row/get_var call\n\t *\n\t * @since 3.0.0\n\t * @var string\n\t */\n\tpublic $func_call;\n\n\t/**\n\t * Whether MySQL is used as the database engine.\n\t *\n\t * Set in WPDB::db_connect() to true, by default. This is used when checking\n\t * against the required MySQL version for WordPress. Normally, a replacement\n\t * database drop-in (db.php) will skip these checks, but setting this to true\n\t * will force the checks to occur.\n\t *\n\t * @since 3.3.0\n\t * @var bool\n\t */\n\tpublic $is_mysql = null;\n\n\t/**\n\t * A list of incompatible SQL modes.\n\t *\n\t * @since 3.9.0\n\t * @var array\n\t */\n\tprotected $incompatible_modes = array( 'NO_ZERO_DATE', 'ONLY_FULL_GROUP_BY',\n\t\t'STRICT_TRANS_TABLES', 'STRICT_ALL_TABLES', 'TRADITIONAL' );\n\n\t/**\n\t * Whether to use mysqli over mysql.\n\t *\n\t * @since 3.9.0\n\t * @var bool\n\t */\n\tprivate $use_mysqli = false;\n\n\t/**\n\t * Whether we've managed to successfully connect at some point\n\t *\n\t * @since 3.9.0\n\t * @var bool\n\t */\n\tprivate $has_connected = false;\n\n\t/**\n\t * Connects to the database server and selects a database\n\t *\n\t * PHP5 style constructor for compatibility with PHP5. Does\n\t * the actual setting up of the class properties and connection\n\t * to the database.\n\t *\n\t * @link https://core.trac.wordpress.org/ticket/3354\n\t * @since 2.0.8\n\t *\n\t * @global string $wp_version\n\t *\n\t * @param string $dbuser     MySQL database user\n\t * @param string $dbpassword MySQL database password\n\t * @param string $dbname     MySQL database name\n\t * @param string $dbhost     MySQL database host\n\t */\n\tpublic function __construct( $dbuser, $dbpassword, $dbname, $dbhost ) {\n\t\tregister_shutdown_function( array( $this, '__destruct' ) );\n\n\t\tif ( WP_DEBUG && WP_DEBUG_DISPLAY )\n\t\t\t$this->show_errors();\n\n\t\t/* Use ext/mysqli if it exists and:\n\t\t *  - WP_USE_EXT_MYSQL is defined as false, or\n\t\t *  - We are a development version of WordPress, or\n\t\t *  - We are running PHP 5.5 or greater, or\n\t\t *  - ext/mysql is not loaded.\n\t\t */\n\t\tif ( function_exists( 'mysqli_connect' ) ) {\n\t\t\tif ( defined( 'WP_USE_EXT_MYSQL' ) ) {\n\t\t\t\t$this->use_mysqli = ! WP_USE_EXT_MYSQL;\n\t\t\t} elseif ( version_compare( phpversion(), '5.5', '>=' ) || ! function_exists( 'mysql_connect' ) ) {\n\t\t\t\t$this->use_mysqli = true;\n\t\t\t} elseif ( false !== strpos( $GLOBALS['wp_version'], '-' ) ) {\n\t\t\t\t$this->use_mysqli = true;\n\t\t\t}\n\t\t}\n\n\t\t$this->dbuser = $dbuser;\n\t\t$this->dbpassword = $dbpassword;\n\t\t$this->dbname = $dbname;\n\t\t$this->dbhost = $dbhost;\n\n\t\t// wp-config.php creation will manually connect when ready.\n\t\tif ( defined( 'WP_SETUP_CONFIG' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t$this->db_connect();\n\t}\n\n\t/**\n\t * PHP5 style destructor and will run when database object is destroyed.\n\t *\n\t * @see wpdb::__construct()\n\t * @since 2.0.8\n\t * @return true\n\t */\n\tpublic function __destruct() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Makes private properties readable for backward compatibility.\n\t *\n\t * @since 3.5.0\n\t *\n\t * @param string $name The private member to get, and optionally process\n\t * @return mixed The private member\n\t */\n\tpublic function __get( $name ) {\n\t\tif ( 'col_info' === $name )\n\t\t\t$this->load_col_info();\n\n\t\treturn $this->$name;\n\t}\n\n\t/**\n\t * Makes private properties settable for backward compatibility.\n\t *\n\t * @since 3.5.0\n\t *\n\t * @param string $name  The private member to set\n\t * @param mixed  $value The value to set\n\t */\n\tpublic function __set( $name, $value ) {\n\t\t$protected_members = array(\n\t\t\t'col_meta',\n\t\t\t'table_charset',\n\t\t\t'check_current_query',\n\t\t);\n\t\tif (  in_array( $name, $protected_members, true ) ) {\n\t\t\treturn;\n\t\t}\n\t\t$this->$name = $value;\n\t}\n\n\t/**\n\t * Makes private properties check-able for backward compatibility.\n\t *\n\t * @since 3.5.0\n\t *\n\t * @param string $name  The private member to check\n\t *\n\t * @return bool If the member is set or not\n\t */\n\tpublic function __isset( $name ) {\n\t\treturn isset( $this->$name );\n\t}\n\n\t/**\n\t * Makes private properties un-settable for backward compatibility.\n\t *\n\t * @since 3.5.0\n\t *\n\t * @param string $name  The private member to unset\n\t */\n\tpublic function __unset( $name ) {\n\t\tunset( $this->$name );\n\t}\n\n\t/**\n\t * Set $this->charset and $this->collate\n\t *\n\t * @since 3.1.0\n\t */\n\tpublic function init_charset() {\n\t\t$charset = '';\n\t\t$collate = '';\n\n\t\tif ( function_exists('is_multisite') && is_multisite() ) {\n\t\t\t$charset = 'utf8';\n\t\t\tif ( defined( 'DB_COLLATE' ) && DB_COLLATE ) {\n\t\t\t\t$collate = DB_COLLATE;\n\t\t\t} else {\n\t\t\t\t$collate = 'utf8_general_ci';\n\t\t\t}\n\t\t} elseif ( defined( 'DB_COLLATE' ) ) {\n\t\t\t$collate = DB_COLLATE;\n\t\t}\n\n\t\tif ( defined( 'DB_CHARSET' ) ) {\n\t\t\t$charset = DB_CHARSET;\n\t\t}\n\n\t\t$charset_collate = $this->determine_charset( $charset, $collate );\n\n\t\t$this->charset = $charset_collate['charset'];\n\t\t$this->collate = $charset_collate['collate'];\n\t}\n\n\t/**\n\t * Determines the best charset and collation to use given a charset and collation.\n\t *\n\t * For example, when able, utf8mb4 should be used instead of utf8.\n\t *\n\t * @since 4.6.0\n\t *\n\t * @param string $charset The character set to check.\n\t * @param string $collate The collation to check.\n\t * @return array The most appropriate character set and collation to use.\n\t */\n\tpublic function determine_charset( $charset, $collate ) {\n\t\tif ( ( $this->use_mysqli && ! ( $this->dbh instanceof mysqli ) ) || empty( $this->dbh ) ) {\n\t\t\treturn compact( 'charset', 'collate' );\n\t\t}\n\n\t\tif ( 'utf8' === $charset && $this->has_cap( 'utf8mb4' ) ) {\n\t\t\t$charset = 'utf8mb4';\n\t\t}\n\n\t\tif ( 'utf8mb4' === $charset && ! $this->has_cap( 'utf8mb4' ) ) {\n\t\t\t$charset = 'utf8';\n\t\t\t$collate = str_replace( 'utf8mb4_', 'utf8_', $collate );\n\t\t}\n\n\t\tif ( 'utf8mb4' === $charset ) {\n\t\t\t// _general_ is outdated, so we can upgrade it to _unicode_, instead.\n\t\t\tif ( ! $collate || 'utf8_general_ci' === $collate ) {\n\t\t\t\t$collate = 'utf8mb4_unicode_ci';\n\t\t\t} else {\n\t\t\t\t$collate = str_replace( 'utf8_', 'utf8mb4_', $collate );\n\t\t\t}\n\t\t}\n\n\t\t// _unicode_520_ is a better collation, we should use that when it's available.\n\t\tif ( $this->has_cap( 'utf8mb4_520' ) && 'utf8mb4_unicode_ci' === $collate ) {\n\t\t\t$collate = 'utf8mb4_unicode_520_ci';\n\t\t}\n\n\t\treturn compact( 'charset', 'collate' );\n\t}\n\n\t/**\n\t * Sets the connection's character set.\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param resource $dbh     The resource given by mysql_connect\n\t * @param string   $charset Optional. The character set. Default null.\n\t * @param string   $collate Optional. The collation. Default null.\n\t */\n\tpublic function set_charset( $dbh, $charset = null, $collate = null ) {\n\t\tif ( ! isset( $charset ) )\n\t\t\t$charset = $this->charset;\n\t\tif ( ! isset( $collate ) )\n\t\t\t$collate = $this->collate;\n\t\tif ( $this->has_cap( 'collation' ) && ! empty( $charset ) ) {\n\t\t\t$set_charset_succeeded = true;\n\n\t\t\tif ( $this->use_mysqli ) {\n\t\t\t\tif ( function_exists( 'mysqli_set_charset' ) && $this->has_cap( 'set_charset' ) ) {\n\t\t\t\t\t$set_charset_succeeded = mysqli_set_charset( $dbh, $charset );\n\t\t\t\t}\n\n\t\t\t\tif ( $set_charset_succeeded ) {\n\t\t\t\t\t$query = $this->prepare( 'SET NAMES %s', $charset );\n\t\t\t\t\tif ( ! empty( $collate ) )\n\t\t\t\t\t\t$query .= $this->prepare( ' COLLATE %s', $collate );\n\t\t\t\t\tmysqli_query( $dbh, $query );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ( function_exists( 'mysql_set_charset' ) && $this->has_cap( 'set_charset' ) ) {\n\t\t\t\t\t$set_charset_succeeded = mysql_set_charset( $charset, $dbh );\n\t\t\t\t}\n\t\t\t\tif ( $set_charset_succeeded ) {\n\t\t\t\t\t$query = $this->prepare( 'SET NAMES %s', $charset );\n\t\t\t\t\tif ( ! empty( $collate ) )\n\t\t\t\t\t\t$query .= $this->prepare( ' COLLATE %s', $collate );\n\t\t\t\t\tmysql_query( $query, $dbh );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Change the current SQL mode, and ensure its WordPress compatibility.\n\t *\n\t * If no modes are passed, it will ensure the current MySQL server\n\t * modes are compatible.\n\t *\n\t * @since 3.9.0\n\t *\n\t * @param array $modes Optional. A list of SQL modes to set.\n\t */\n\tpublic function set_sql_mode( $modes = array() ) {\n\t\tif ( empty( $modes ) ) {\n\t\t\tif ( $this->use_mysqli ) {\n\t\t\t\t$res = mysqli_query( $this->dbh, 'SELECT @@SESSION.sql_mode' );\n\t\t\t} else {\n\t\t\t\t$res = mysql_query( 'SELECT @@SESSION.sql_mode', $this->dbh );\n\t\t\t}\n\n\t\t\tif ( empty( $res ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( $this->use_mysqli ) {\n\t\t\t\t$modes_array = mysqli_fetch_array( $res );\n\t\t\t\tif ( empty( $modes_array[0] ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t$modes_str = $modes_array[0];\n\t\t\t} else {\n\t\t\t\t$modes_str = mysql_result( $res, 0 );\n\t\t\t}\n\n\t\t\tif ( empty( $modes_str ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t$modes = explode( ',', $modes_str );\n\t\t}\n\n\t\t$modes = array_change_key_case( $modes, CASE_UPPER );\n\n\t\t/**\n\t\t * Filters the list of incompatible SQL modes to exclude.\n\t\t *\n\t\t * @since 3.9.0\n\t\t *\n\t\t * @param array $incompatible_modes An array of incompatible modes.\n\t\t */\n\t\t$incompatible_modes = (array) apply_filters( 'incompatible_sql_modes', $this->incompatible_modes );\n\n\t\tforeach ( $modes as $i => $mode ) {\n\t\t\tif ( in_array( $mode, $incompatible_modes ) ) {\n\t\t\t\tunset( $modes[ $i ] );\n\t\t\t}\n\t\t}\n\n\t\t$modes_str = implode( ',', $modes );\n\n\t\tif ( $this->use_mysqli ) {\n\t\t\tmysqli_query( $this->dbh, \"SET SESSION sql_mode='$modes_str'\" );\n\t\t} else {\n\t\t\tmysql_query( \"SET SESSION sql_mode='$modes_str'\", $this->dbh );\n\t\t}\n\t}\n\n\t/**\n\t * Sets the table prefix for the WordPress tables.\n\t *\n\t * @since 2.5.0\n\t *\n\t * @param string $prefix          Alphanumeric name for the new prefix.\n\t * @param bool   $set_table_names Optional. Whether the table names, e.g. wpdb::$posts, should be updated or not.\n\t * @return string|WP_Error Old prefix or WP_Error on error\n\t */\n\tpublic function set_prefix( $prefix, $set_table_names = true ) {\n\n\t\tif ( preg_match( '|[^a-z0-9_]|i', $prefix ) )\n\t\t\treturn new WP_Error('invalid_db_prefix', 'Invalid database prefix' );\n\n\t\t$old_prefix = is_multisite() ? '' : $prefix;\n\n\t\tif ( isset( $this->base_prefix ) )\n\t\t\t$old_prefix = $this->base_prefix;\n\n\t\t$this->base_prefix = $prefix;\n\n\t\tif ( $set_table_names ) {\n\t\t\tforeach ( $this->tables( 'global' ) as $table => $prefixed_table )\n\t\t\t\t$this->$table = $prefixed_table;\n\n\t\t\tif ( is_multisite() && empty( $this->blogid ) )\n\t\t\t\treturn $old_prefix;\n\n\t\t\t$this->prefix = $this->get_blog_prefix();\n\n\t\t\tforeach ( $this->tables( 'blog' ) as $table => $prefixed_table )\n\t\t\t\t$this->$table = $prefixed_table;\n\n\t\t\tforeach ( $this->tables( 'old' ) as $table => $prefixed_table )\n\t\t\t\t$this->$table = $prefixed_table;\n\t\t}\n\t\treturn $old_prefix;\n\t}\n\n\t/**\n\t * Sets blog id.\n\t *\n\t * @since 3.0.0\n\t *\n\t * @param int $blog_id\n\t * @param int $network_id Optional.\n\t * @return int previous blog id\n\t */\n\tpublic function set_blog_id( $blog_id, $network_id = 0 ) {\n\t\tif ( ! empty( $network_id ) ) {\n\t\t\t$this->siteid = $network_id;\n\t\t}\n\n\t\t$old_blog_id  = $this->blogid;\n\t\t$this->blogid = $blog_id;\n\n\t\t$this->prefix = $this->get_blog_prefix();\n\n\t\tforeach ( $this->tables( 'blog' ) as $table => $prefixed_table )\n\t\t\t$this->$table = $prefixed_table;\n\n\t\tforeach ( $this->tables( 'old' ) as $table => $prefixed_table )\n\t\t\t$this->$table = $prefixed_table;\n\n\t\treturn $old_blog_id;\n\t}\n\n\t/**\n\t * Gets blog prefix.\n\t *\n\t * @since 3.0.0\n\t * @param int $blog_id Optional.\n\t * @return string Blog prefix.\n\t */\n\tpublic function get_blog_prefix( $blog_id = null ) {\n\t\tif ( is_multisite() ) {\n\t\t\tif ( null === $blog_id )\n\t\t\t\t$blog_id = $this->blogid;\n\t\t\t$blog_id = (int) $blog_id;\n\t\t\tif ( defined( 'MULTISITE' ) && ( 0 == $blog_id || 1 == $blog_id ) )\n\t\t\t\treturn $this->base_prefix;\n\t\t\telse\n\t\t\t\treturn $this->base_prefix . $blog_id . '_';\n\t\t} else {\n\t\t\treturn $this->base_prefix;\n\t\t}\n\t}\n\n\t/**\n\t * Returns an array of WordPress tables.\n\t *\n\t * Also allows for the CUSTOM_USER_TABLE and CUSTOM_USER_META_TABLE to\n\t * override the WordPress users and usermeta tables that would otherwise\n\t * be determined by the prefix.\n\t *\n\t * The scope argument can take one of the following:\n\t *\n\t * 'all' - returns 'all' and 'global' tables. No old tables are returned.\n\t * 'blog' - returns the blog-level tables for the queried blog.\n\t * 'global' - returns the global tables for the installation, returning multisite tables only if running multisite.\n\t * 'ms_global' - returns the multisite global tables, regardless if current installation is multisite.\n\t * 'old' - returns tables which are deprecated.\n\t *\n\t * @since 3.0.0\n\t * @uses wpdb::$tables\n\t * @uses wpdb::$old_tables\n\t * @uses wpdb::$global_tables\n\t * @uses wpdb::$ms_global_tables\n\t *\n\t * @param string $scope   Optional. Can be all, global, ms_global, blog, or old tables. Defaults to all.\n\t * @param bool   $prefix  Optional. Whether to include table prefixes. Default true. If blog\n\t *                        prefix is requested, then the custom users and usermeta tables will be mapped.\n\t * @param int    $blog_id Optional. The blog_id to prefix. Defaults to wpdb::$blogid. Used only when prefix is requested.\n\t * @return array Table names. When a prefix is requested, the key is the unprefixed table name.\n\t */\n\tpublic function tables( $scope = 'all', $prefix = true, $blog_id = 0 ) {\n\t\tswitch ( $scope ) {\n\t\t\tcase 'all' :\n\t\t\t\t$tables = array_merge( $this->global_tables, $this->tables );\n\t\t\t\tif ( is_multisite() )\n\t\t\t\t\t$tables = array_merge( $tables, $this->ms_global_tables );\n\t\t\t\tbreak;\n\t\t\tcase 'blog' :\n\t\t\t\t$tables = $this->tables;\n\t\t\t\tbreak;\n\t\t\tcase 'global' :\n\t\t\t\t$tables = $this->global_tables;\n\t\t\t\tif ( is_multisite() )\n\t\t\t\t\t$tables = array_merge( $tables, $this->ms_global_tables );\n\t\t\t\tbreak;\n\t\t\tcase 'ms_global' :\n\t\t\t\t$tables = $this->ms_global_tables;\n\t\t\t\tbreak;\n\t\t\tcase 'old' :\n\t\t\t\t$tables = $this->old_tables;\n\t\t\t\tbreak;\n\t\t\tdefault :\n\t\t\t\treturn array();\n\t\t}\n\n\t\tif ( $prefix ) {\n\t\t\tif ( ! $blog_id )\n\t\t\t\t$blog_id = $this->blogid;\n\t\t\t$blog_prefix = $this->get_blog_prefix( $blog_id );\n\t\t\t$base_prefix = $this->base_prefix;\n\t\t\t$global_tables = array_merge( $this->global_tables, $this->ms_global_tables );\n\t\t\tforeach ( $tables as $k => $table ) {\n\t\t\t\tif ( in_array( $table, $global_tables ) )\n\t\t\t\t\t$tables[ $table ] = $base_prefix . $table;\n\t\t\t\telse\n\t\t\t\t\t$tables[ $table ] = $blog_prefix . $table;\n\t\t\t\tunset( $tables[ $k ] );\n\t\t\t}\n\n\t\t\tif ( isset( $tables['users'] ) && defined( 'CUSTOM_USER_TABLE' ) )\n\t\t\t\t$tables['users'] = CUSTOM_USER_TABLE;\n\n\t\t\tif ( isset( $tables['usermeta'] ) && defined( 'CUSTOM_USER_META_TABLE' ) )\n\t\t\t\t$tables['usermeta'] = CUSTOM_USER_META_TABLE;\n\t\t}\n\n\t\treturn $tables;\n\t}\n\n\t/**\n\t * Selects a database using the current database connection.\n\t *\n\t * The database name will be changed based on the current database\n\t * connection. On failure, the execution will bail and display an DB error.\n\t *\n\t * @since 0.71\n\t *\n\t * @param string        $db  MySQL database name\n\t * @param resource|null $dbh Optional link identifier.\n\t */\n\tpublic function select( $db, $dbh = null ) {\n\t\tif ( is_null($dbh) )\n\t\t\t$dbh = $this->dbh;\n\n\t\tif ( $this->use_mysqli ) {\n\t\t\t$success = mysqli_select_db( $dbh, $db );\n\t\t} else {\n\t\t\t$success = mysql_select_db( $db, $dbh );\n\t\t}\n\t\tif ( ! $success ) {\n\t\t\t$this->ready = false;\n\t\t\tif ( ! did_action( 'template_redirect' ) ) {\n\t\t\t\twp_load_translations_early();\n\n\t\t\t\t$message = '<h1>' . __( 'Can&#8217;t select database' ) . \"</h1>\\n\";\n\n\t\t\t\t$message .= '<p>' . sprintf(\n\t\t\t\t\t/* translators: %s: database name */\n\t\t\t\t\t__( 'We were able to connect to the database server (which means your username and password is okay) but not able to select the %s database.' ),\n\t\t\t\t\t'<code>' . htmlspecialchars( $db, ENT_QUOTES ) . '</code>'\n\t\t\t\t) . \"</p>\\n\";\n\n\t\t\t\t$message .= \"<ul>\\n\";\n\t\t\t\t$message .= '<li>' . __( 'Are you sure it exists?' ) . \"</li>\\n\";\n\n\t\t\t\t$message .= '<li>' . sprintf(\n\t\t\t\t\t/* translators: 1: database user, 2: database name */\n\t\t\t\t\t__( 'Does the user %1$s have permission to use the %2$s database?' ),\n\t\t\t\t\t'<code>' . htmlspecialchars( $this->dbuser, ENT_QUOTES )  . '</code>',\n\t\t\t\t\t'<code>' . htmlspecialchars( $db, ENT_QUOTES ) . '</code>'\n\t\t\t\t) . \"</li>\\n\";\n\n\t\t\t\t$message .= '<li>' . sprintf(\n\t\t\t\t\t/* translators: %s: database name */\n\t\t\t\t\t__( 'On some systems the name of your database is prefixed with your username, so it would be like <code>username_%1$s</code>. Could that be the problem?' ),\n\t\t\t\t\thtmlspecialchars( $db, ENT_QUOTES )\n\t\t\t\t). \"</li>\\n\";\n\n\t\t\t\t$message .= \"</ul>\\n\";\n\n\t\t\t\t$message .= '<p>' . sprintf(\n\t\t\t\t\t/* translators: %s: support forums URL */\n\t\t\t\t\t__( 'If you don&#8217;t know how to set up a database you should <strong>contact your host</strong>. If all else fails you may find help at the <a href=\"%s\">WordPress Support Forums</a>.' ),\n\t\t\t\t\t__( 'https://wordpress.org/support/' )\n\t\t\t\t) . \"</p>\\n\";\n\n\t\t\t\t$this->bail( $message, 'db_select_fail' );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Do not use, deprecated.\n\t *\n\t * Use esc_sql() or wpdb::prepare() instead.\n\t *\n\t * @since 2.8.0\n\t * @deprecated 3.6.0 Use wpdb::prepare()\n\t * @see wpdb::prepare\n\t * @see esc_sql()\n\t *\n\t * @param string $string\n\t * @return string\n\t */\n\tfunction _weak_escape( $string ) {\n\t\tif ( func_num_args() === 1 && function_exists( '_deprecated_function' ) )\n\t\t\t_deprecated_function( __METHOD__, '3.6.0', 'wpdb::prepare() or esc_sql()' );\n\t\treturn addslashes( $string );\n\t}\n\n\t/**\n\t * Real escape, using mysqli_real_escape_string() or mysql_real_escape_string()\n\t *\n\t * @see mysqli_real_escape_string()\n\t * @see mysql_real_escape_string()\n\t * @since 2.8.0\n\t *\n\t * @param  string $string to escape\n\t * @return string escaped\n\t */\n\tfunction _real_escape( $string ) {\n\t\tif ( $this->dbh ) {\n\t\t\tif ( $this->use_mysqli ) {\n\t\t\t\treturn mysqli_real_escape_string( $this->dbh, $string );\n\t\t\t} else {\n\t\t\t\treturn mysql_real_escape_string( $string, $this->dbh );\n\t\t\t}\n\t\t}\n\n\t\t$class = get_class( $this );\n\t\tif ( function_exists( '__' ) ) {\n\t\t\t/* translators: %s: database access abstraction class, usually wpdb or a class extending wpdb */\n\t\t\t_doing_it_wrong( $class, sprintf( __( '%s must set a database connection for use with escaping.' ), $class ), '3.6.0' );\n\t\t} else {\n\t\t\t_doing_it_wrong( $class, sprintf( '%s must set a database connection for use with escaping.', $class ), '3.6.0' );\n\t\t}\n\t\treturn addslashes( $string );\n\t}\n\n\t/**\n\t * Escape data. Works on arrays.\n\t *\n\t * @uses wpdb::_real_escape()\n\t * @since  2.8.0\n\t *\n\t * @param  string|array $data\n\t * @return string|array escaped\n\t */\n\tpublic function _escape( $data ) {\n\t\tif ( is_array( $data ) ) {\n\t\t\tforeach ( $data as $k => $v ) {\n\t\t\t\tif ( is_array( $v ) ) {\n\t\t\t\t\t$data[$k] = $this->_escape( $v );\n\t\t\t\t} else {\n\t\t\t\t\t$data[$k] = $this->_real_escape( $v );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t$data = $this->_real_escape( $data );\n\t\t}\n\n\t\treturn $data;\n\t}\n\n\t/**\n\t * Do not use, deprecated.\n\t *\n\t * Use esc_sql() or wpdb::prepare() instead.\n\t *\n\t * @since 0.71\n\t * @deprecated 3.6.0 Use wpdb::prepare()\n\t * @see wpdb::prepare()\n\t * @see esc_sql()\n\t *\n\t * @param mixed $data\n\t * @return mixed\n\t */\n\tpublic function escape( $data ) {\n\t\tif ( func_num_args() === 1 && function_exists( '_deprecated_function' ) )\n\t\t\t_deprecated_function( __METHOD__, '3.6.0', 'wpdb::prepare() or esc_sql()' );\n\t\tif ( is_array( $data ) ) {\n\t\t\tforeach ( $data as $k => $v ) {\n\t\t\t\tif ( is_array( $v ) )\n\t\t\t\t\t$data[$k] = $this->escape( $v, 'recursive' );\n\t\t\t\telse\n\t\t\t\t\t$data[$k] = $this->_weak_escape( $v, 'internal' );\n\t\t\t}\n\t\t} else {\n\t\t\t$data = $this->_weak_escape( $data, 'internal' );\n\t\t}\n\n\t\treturn $data;\n\t}\n\n\t/**\n\t * Escapes content by reference for insertion into the database, for security\n\t *\n\t * @uses wpdb::_real_escape()\n\t *\n\t * @since 2.3.0\n\t *\n\t * @param string $string to escape\n\t */\n\tpublic function escape_by_ref( &$string ) {\n\t\tif ( ! is_float( $string ) )\n\t\t\t$string = $this->_real_escape( $string );\n\t}\n\n\t/**\n\t * Prepares a SQL query for safe execution. Uses sprintf()-like syntax.\n\t *\n\t * The following directives can be used in the query format string:\n\t *   %d (integer)\n\t *   %f (float)\n\t *   %s (string)\n\t *   %% (literal percentage sign - no argument needed)\n\t *\n\t * All of %d, %f, and %s are to be left unquoted in the query string and they need an argument passed for them.\n\t * Literals (%) as parts of the query must be properly written as %%.\n\t *\n\t * This function only supports a small subset of the sprintf syntax; it only supports %d (integer), %f (float), and %s (string).\n\t * Does not support sign, padding, alignment, width or precision specifiers.\n\t * Does not support argument numbering/swapping.\n\t *\n\t * May be called like {@link https://secure.php.net/sprintf sprintf()} or like {@link https://secure.php.net/vsprintf vsprintf()}.\n\t *\n\t * Both %d and %s should be left unquoted in the query string.\n\t *\n\t *     $wpdb->prepare( \"SELECT * FROM `table` WHERE `column` = %s AND `field` = %d\", 'foo', 1337 );\n\t *     $wpdb->prepare( \"SELECT DATE_FORMAT(`field`, '%%c') FROM `table` WHERE `column` = %s\", 'foo' );\n\t *\n\t * @link https://secure.php.net/sprintf Description of syntax.\n\t * @since 2.3.0\n\t *\n\t * @param string      $query    Query statement with sprintf()-like placeholders\n\t * @param array|mixed $args     The array of variables to substitute into the query's placeholders if being called like\n\t *                              {@link https://secure.php.net/vsprintf vsprintf()}, or the first variable to substitute into the query's placeholders if\n\t *                              being called like {@link https://secure.php.net/sprintf sprintf()}.\n\t * @param mixed       $args,... further variables to substitute into the query's placeholders if being called like\n\t *                              {@link https://secure.php.net/sprintf sprintf()}.\n\t * @return string|void Sanitized query string, if there is a query to prepare.\n\t */\n\tpublic function prepare( $query, $args ) {\n\t\tif ( is_null( $query ) )\n\t\t\treturn;\n\n\t\t// This is not meant to be foolproof -- but it will catch obviously incorrect usage.\n\t\tif ( strpos( $query, '%' ) === false ) {\n\t\t\t_doing_it_wrong( 'wpdb::prepare', sprintf( __( 'The query argument of %s must have a placeholder.' ), 'wpdb::prepare()' ), '3.9.0' );\n\t\t}\n\n\t\t$args = func_get_args();\n\t\tarray_shift( $args );\n\t\t// If args were passed as an array (as in vsprintf), move them up\n\t\tif ( isset( $args[0] ) && is_array($args[0]) )\n\t\t\t$args = $args[0];\n\t\t$query = str_replace( \"'%s'\", '%s', $query ); // in case someone mistakenly already singlequoted it\n\t\t$query = str_replace( '\"%s\"', '%s', $query ); // doublequote unquoting\n\t\t$query = preg_replace( '|(?<!%)%f|' , '%F', $query ); // Force floats to be locale unaware\n\t\t$query = preg_replace( '|(?<!%)%s|', \"'%s'\", $query ); // quote the strings, avoiding escaped strings like %%s\n\t\tarray_walk( $args, array( $this, 'escape_by_ref' ) );\n\t\treturn @vsprintf( $query, $args );\n\t}\n\n\t/**\n\t * First half of escaping for LIKE special characters % and _ before preparing for MySQL.\n\t *\n\t * Use this only before wpdb::prepare() or esc_sql().  Reversing the order is very bad for security.\n\t *\n\t * Example Prepared Statement:\n\t *\n\t *     $wild = '%';\n\t *     $find = 'only 43% of planets';\n\t *     $like = $wild . $wpdb->esc_like( $find ) . $wild;\n\t *     $sql  = $wpdb->prepare( \"SELECT * FROM $wpdb->posts WHERE post_content LIKE '%s'\", $like );\n\t *\n\t * Example Escape Chain:\n\t *\n\t *     $sql  = esc_sql( $wpdb->esc_like( $input ) );\n\t *\n\t * @since 4.0.0\n\t *\n\t * @param string $text The raw text to be escaped. The input typed by the user should have no\n\t *                     extra or deleted slashes.\n\t * @return string Text in the form of a LIKE phrase. The output is not SQL safe. Call $wpdb::prepare()\n\t *                or real_escape next.\n\t */\n\tpublic function esc_like( $text ) {\n\t\treturn addcslashes( $text, '_%\\\\' );\n\t}\n\n\t/**\n\t * Print SQL/DB error.\n\t *\n\t * @since 0.71\n\t * @global array $EZSQL_ERROR Stores error information of query and error string\n\t *\n\t * @param string $str The error to display\n\t * @return false|void False if the showing of errors is disabled.\n\t */\n\tpublic function print_error( $str = '' ) {\n\t\tglobal $EZSQL_ERROR;\n\n\t\tif ( !$str ) {\n\t\t\tif ( $this->use_mysqli ) {\n\t\t\t\t$str = mysqli_error( $this->dbh );\n\t\t\t} else {\n\t\t\t\t$str = mysql_error( $this->dbh );\n\t\t\t}\n\t\t}\n\t\t$EZSQL_ERROR[] = array( 'query' => $this->last_query, 'error_str' => $str );\n\n\t\tif ( $this->suppress_errors )\n\t\t\treturn false;\n\n\t\twp_load_translations_early();\n\n\t\tif ( $caller = $this->get_caller() ) {\n\t\t\t/* translators: 1: Database error message, 2: SQL query, 3: Name of the calling function */\n\t\t\t$error_str = sprintf( __( 'WordPress database error %1$s for query %2$s made by %3$s' ), $str, $this->last_query, $caller );\n\t\t} else {\n\t\t\t/* translators: 1: Database error message, 2: SQL query */\n\t\t\t$error_str = sprintf( __( 'WordPress database error %1$s for query %2$s' ), $str, $this->last_query );\n\t\t}\n\n\t\terror_log( $error_str );\n\n\t\t// Are we showing errors?\n\t\tif ( ! $this->show_errors )\n\t\t\treturn false;\n\n\t\t// If there is an error then take note of it\n\t\tif ( is_multisite() ) {\n\t\t\t$msg = sprintf(\n\t\t\t\t\"%s [%s]\\n%s\\n\",\n\t\t\t\t__( 'WordPress database error:' ),\n\t\t\t\t$str,\n\t\t\t\t$this->last_query\n\t\t\t);\n\n\t\t\tif ( defined( 'ERRORLOGFILE' ) ) {\n\t\t\t\terror_log( $msg, 3, ERRORLOGFILE );\n\t\t\t}\n\t\t\tif ( defined( 'DIEONDBERROR' ) ) {\n\t\t\t\twp_die( $msg );\n\t\t\t}\n\t\t} else {\n\t\t\t$str   = htmlspecialchars( $str, ENT_QUOTES );\n\t\t\t$query = htmlspecialchars( $this->last_query, ENT_QUOTES );\n\n\t\t\tprintf(\n\t\t\t\t'<div id=\"error\"><p class=\"wpdberror\"><strong>%s</strong> [%s]<br /><code>%s</code></p></div>',\n\t\t\t\t__( 'WordPress database error:' ),\n\t\t\t\t$str,\n\t\t\t\t$query\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Enables showing of database errors.\n\t *\n\t * This function should be used only to enable showing of errors.\n\t * wpdb::hide_errors() should be used instead for hiding of errors. However,\n\t * this function can be used to enable and disable showing of database\n\t * errors.\n\t *\n\t * @since 0.71\n\t * @see wpdb::hide_errors()\n\t *\n\t * @param bool $show Whether to show or hide errors\n\t * @return bool Old value for showing errors.\n\t */\n\tpublic function show_errors( $show = true ) {\n\t\t$errors = $this->show_errors;\n\t\t$this->show_errors = $show;\n\t\treturn $errors;\n\t}\n\n\t/**\n\t * Disables showing of database errors.\n\t *\n\t * By default database errors are not shown.\n\t *\n\t * @since 0.71\n\t * @see wpdb::show_errors()\n\t *\n\t * @return bool Whether showing of errors was active\n\t */\n\tpublic function hide_errors() {\n\t\t$show = $this->show_errors;\n\t\t$this->show_errors = false;\n\t\treturn $show;\n\t}\n\n\t/**\n\t * Whether to suppress database errors.\n\t *\n\t * By default database errors are suppressed, with a simple\n\t * call to this function they can be enabled.\n\t *\n\t * @since 2.5.0\n\t * @see wpdb::hide_errors()\n\t * @param bool $suppress Optional. New value. Defaults to true.\n\t * @return bool Old value\n\t */\n\tpublic function suppress_errors( $suppress = true ) {\n\t\t$errors = $this->suppress_errors;\n\t\t$this->suppress_errors = (bool) $suppress;\n\t\treturn $errors;\n\t}\n\n\t/**\n\t * Kill cached query results.\n\t *\n\t * @since 0.71\n\t */\n\tpublic function flush() {\n\t\t$this->last_result = array();\n\t\t$this->col_info    = null;\n\t\t$this->last_query  = null;\n\t\t$this->rows_affected = $this->num_rows = 0;\n\t\t$this->last_error  = '';\n\n\t\tif ( $this->use_mysqli && $this->result instanceof mysqli_result ) {\n\t\t\tmysqli_free_result( $this->result );\n\t\t\t$this->result = null;\n\n\t\t\t// Sanity check before using the handle\n\t\t\tif ( empty( $this->dbh ) || !( $this->dbh instanceof mysqli ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Clear out any results from a multi-query\n\t\t\twhile ( mysqli_more_results( $this->dbh ) ) {\n\t\t\t\tmysqli_next_result( $this->dbh );\n\t\t\t}\n\t\t} elseif ( is_resource( $this->result ) ) {\n\t\t\tmysql_free_result( $this->result );\n\t\t}\n\t}\n\n\t/**\n\t * Connect to and select database.\n\t *\n\t * If $allow_bail is false, the lack of database connection will need\n\t * to be handled manually.\n\t *\n\t * @since 3.0.0\n\t * @since 3.9.0 $allow_bail parameter added.\n\t *\n\t * @param bool $allow_bail Optional. Allows the function to bail. Default true.\n\t * @return bool True with a successful connection, false on failure.\n\t */\n\tpublic function db_connect( $allow_bail = true ) {\n\t\t$this->is_mysql = true;\n\n\t\t/*\n\t\t * Deprecated in 3.9+ when using MySQLi. No equivalent\n\t\t * $new_link parameter exists for mysqli_* functions.\n\t\t */\n\t\t$new_link = defined( 'MYSQL_NEW_LINK' ) ? MYSQL_NEW_LINK : true;\n\t\t$client_flags = defined( 'MYSQL_CLIENT_FLAGS' ) ? MYSQL_CLIENT_FLAGS : 0;\n\n\t\tif ( $this->use_mysqli ) {\n\t\t\t$this->dbh = mysqli_init();\n\n\t\t\t// mysqli_real_connect doesn't support the host param including a port or socket\n\t\t\t// like mysql_connect does. This duplicates how mysql_connect detects a port and/or socket file.\n\t\t\t$port = null;\n\t\t\t$socket = null;\n\t\t\t$host = $this->dbhost;\n\t\t\t$port_or_socket = strstr( $host, ':' );\n\t\t\tif ( ! empty( $port_or_socket ) ) {\n\t\t\t\t$host = substr( $host, 0, strpos( $host, ':' ) );\n\t\t\t\t$port_or_socket = substr( $port_or_socket, 1 );\n\t\t\t\tif ( 0 !== strpos( $port_or_socket, '/' ) ) {\n\t\t\t\t\t$port = intval( $port_or_socket );\n\t\t\t\t\t$maybe_socket = strstr( $port_or_socket, ':' );\n\t\t\t\t\tif ( ! empty( $maybe_socket ) ) {\n\t\t\t\t\t\t$socket = substr( $maybe_socket, 1 );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$socket = $port_or_socket;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( WP_DEBUG ) {\n\t\t\t\tmysqli_real_connect( $this->dbh, $host, $this->dbuser, $this->dbpassword, null, $port, $socket, $client_flags );\n\t\t\t} else {\n\t\t\t\t@mysqli_real_connect( $this->dbh, $host, $this->dbuser, $this->dbpassword, null, $port, $socket, $client_flags );\n\t\t\t}\n\n\t\t\tif ( $this->dbh->connect_errno ) {\n\t\t\t\t$this->dbh = null;\n\n\t\t\t\t/* It's possible ext/mysqli is misconfigured. Fall back to ext/mysql if:\n\t\t \t\t *  - We haven't previously connected, and\n\t\t \t\t *  - WP_USE_EXT_MYSQL isn't set to false, and\n\t\t \t\t *  - ext/mysql is loaded.\n\t\t \t\t */\n\t\t\t\t$attempt_fallback = true;\n\n\t\t\t\tif ( $this->has_connected ) {\n\t\t\t\t\t$attempt_fallback = false;\n\t\t\t\t} elseif ( defined( 'WP_USE_EXT_MYSQL' ) && ! WP_USE_EXT_MYSQL ) {\n\t\t\t\t\t$attempt_fallback = false;\n\t\t\t\t} elseif ( ! function_exists( 'mysql_connect' ) ) {\n\t\t\t\t\t$attempt_fallback = false;\n\t\t\t\t}\n\n\t\t\t\tif ( $attempt_fallback ) {\n\t\t\t\t\t$this->use_mysqli = false;\n\t\t\t\t\treturn $this->db_connect( $allow_bail );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif ( WP_DEBUG ) {\n\t\t\t\t$this->dbh = mysql_connect( $this->dbhost, $this->dbuser, $this->dbpassword, $new_link, $client_flags );\n\t\t\t} else {\n\t\t\t\t$this->dbh = @mysql_connect( $this->dbhost, $this->dbuser, $this->dbpassword, $new_link, $client_flags );\n\t\t\t}\n\t\t}\n\n\t\tif ( ! $this->dbh && $allow_bail ) {\n\t\t\twp_load_translations_early();\n\n\t\t\t// Load custom DB error template, if present.\n\t\t\tif ( file_exists( WP_CONTENT_DIR . '/db-error.php' ) ) {\n\t\t\t\trequire_once( WP_CONTENT_DIR . '/db-error.php' );\n\t\t\t\tdie();\n\t\t\t}\n\n\t\t\t$message = '<h1>' . __( 'Error establishing a database connection' ) . \"</h1>\\n\";\n\n\t\t\t$message .= '<p>' . sprintf(\n\t\t\t\t/* translators: 1: wp-config.php. 2: database host */\n\t\t\t\t__( 'This either means that the username and password information in your %1$s file is incorrect or we can&#8217;t contact the database server at %2$s. This could mean your host&#8217;s database server is down.' ),\n\t\t\t\t'<code>wp-config.php</code>',\n\t\t\t\t'<code>' . htmlspecialchars( $this->dbhost, ENT_QUOTES ) . '</code>'\n\t\t\t) . \"</p>\\n\";\n\n\t\t\t$message .= \"<ul>\\n\";\n\t\t\t$message .= '<li>' . __( 'Are you sure you have the correct username and password?' ) . \"</li>\\n\";\n\t\t\t$message .= '<li>' . __( 'Are you sure that you have typed the correct hostname?' ) . \"</li>\\n\";\n\t\t\t$message .= '<li>' . __( 'Are you sure that the database server is running?' ) . \"</li>\\n\";\n\t\t\t$message .= \"</ul>\\n\";\n\n\t\t\t$message .= '<p>' . sprintf(\n\t\t\t\t/* translators: %s: support forums URL */\n\t\t\t\t__( 'If you&#8217;re unsure what these terms mean you should probably contact your host. If you still need help you can always visit the <a href=\"%s\">WordPress Support Forums</a>.' ),\n\t\t\t\t__( 'https://wordpress.org/support/' )\n\t\t\t) . \"</p>\\n\";\n\n\t\t\t$this->bail( $message, 'db_connect_fail' );\n\n\t\t\treturn false;\n\t\t} elseif ( $this->dbh ) {\n\t\t\tif ( ! $this->has_connected ) {\n\t\t\t\t$this->init_charset();\n\t\t\t}\n\n\t\t\t$this->has_connected = true;\n\n\t\t\t$this->set_charset( $this->dbh );\n\n\t\t\t$this->ready = true;\n\t\t\t$this->set_sql_mode();\n\t\t\t$this->select( $this->dbname, $this->dbh );\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Checks that the connection to the database is still up. If not, try to reconnect.\n\t *\n\t * If this function is unable to reconnect, it will forcibly die, or if after the\n\t * the {@see 'template_redirect'} hook has been fired, return false instead.\n\t *\n\t * If $allow_bail is false, the lack of database connection will need\n\t * to be handled manually.\n\t *\n\t * @since 3.9.0\n\t *\n\t * @param bool $allow_bail Optional. Allows the function to bail. Default true.\n\t * @return bool|void True if the connection is up.\n\t */\n\tpublic function check_connection( $allow_bail = true ) {\n\t\tif ( $this->use_mysqli ) {\n\t\t\tif ( ! empty( $this->dbh ) && mysqli_ping( $this->dbh ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tif ( ! empty( $this->dbh ) && mysql_ping( $this->dbh ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t$error_reporting = false;\n\n\t\t// Disable warnings, as we don't want to see a multitude of \"unable to connect\" messages\n\t\tif ( WP_DEBUG ) {\n\t\t\t$error_reporting = error_reporting();\n\t\t\terror_reporting( $error_reporting & ~E_WARNING );\n\t\t}\n\n\t\tfor ( $tries = 1; $tries <= $this->reconnect_retries; $tries++ ) {\n\t\t\t// On the last try, re-enable warnings. We want to see a single instance of the\n\t\t\t// \"unable to connect\" message on the bail() screen, if it appears.\n\t\t\tif ( $this->reconnect_retries === $tries && WP_DEBUG ) {\n\t\t\t\terror_reporting( $error_reporting );\n\t\t\t}\n\n\t\t\tif ( $this->db_connect( false ) ) {\n\t\t\t\tif ( $error_reporting ) {\n\t\t\t\t\terror_reporting( $error_reporting );\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tsleep( 1 );\n\t\t}\n\n\t\t// If template_redirect has already happened, it's too late for wp_die()/dead_db().\n\t\t// Let's just return and hope for the best.\n\t\tif ( did_action( 'template_redirect' ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( ! $allow_bail ) {\n\t\t\treturn false;\n\t\t}\n\n\t\twp_load_translations_early();\n\n\t\t$message = '<h1>' . __( 'Error reconnecting to the database' ) . \"</h1>\\n\";\n\n\t\t$message .= '<p>' . sprintf(\n\t\t\t/* translators: %s: database host */\n\t\t\t__( 'This means that we lost contact with the database server at %s. This could mean your host&#8217;s database server is down.' ),\n\t\t\t'<code>' . htmlspecialchars( $this->dbhost, ENT_QUOTES ) . '</code>'\n\t\t) . \"</p>\\n\";\n\n\t\t$message .= \"<ul>\\n\";\n\t\t$message .= '<li>' . __( 'Are you sure that the database server is running?' ) . \"</li>\\n\";\n\t\t$message .= '<li>' . __( 'Are you sure that the database server is not under particularly heavy load?' ) . \"</li>\\n\";\n\t\t$message .= \"</ul>\\n\";\n\n\t\t$message .= '<p>' . sprintf(\n\t\t\t/* translators: %s: support forums URL */\n\t\t\t__( 'If you&#8217;re unsure what these terms mean you should probably contact your host. If you still need help you can always visit the <a href=\"%s\">WordPress Support Forums</a>.' ),\n\t\t\t__( 'https://wordpress.org/support/' )\n\t\t) . \"</p>\\n\";\n\n\t\t// We weren't able to reconnect, so we better bail.\n\t\t$this->bail( $message, 'db_connect_fail' );\n\n\t\t// Call dead_db() if bail didn't die, because this database is no more. It has ceased to be (at least temporarily).\n\t\tdead_db();\n\t}\n\n\t/**\n\t * Perform a MySQL database query, using current database connection.\n\t *\n\t * More information can be found on the codex page.\n\t *\n\t * @since 0.71\n\t *\n\t * @param string $query Database query\n\t * @return int|false Number of rows affected/selected or false on error\n\t */\n\tpublic function query( $query ) {\n\t\tif ( ! $this->ready ) {\n\t\t\t$this->check_current_query = true;\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * Filters the database query.\n\t\t *\n\t\t * Some queries are made before the plugins have been loaded,\n\t\t * and thus cannot be filtered with this method.\n\t\t *\n\t\t * @since 2.1.0\n\t\t *\n\t\t * @param string $query Database query.\n\t\t */\n\t\t$query = apply_filters( 'query', $query );\n\n\t\t$this->flush();\n\n\t\t// Log how the function was called\n\t\t$this->func_call = \"\\$db->query(\\\"$query\\\")\";\n\n\t\t// If we're writing to the database, make sure the query will write safely.\n\t\tif ( $this->check_current_query && ! $this->check_ascii( $query ) ) {\n\t\t\t$stripped_query = $this->strip_invalid_text_from_query( $query );\n\t\t\t// strip_invalid_text_from_query() can perform queries, so we need\n\t\t\t// to flush again, just to make sure everything is clear.\n\t\t\t$this->flush();\n\t\t\tif ( $stripped_query !== $query ) {\n\t\t\t\t$this->insert_id = 0;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t$this->check_current_query = true;\n\n\t\t// Keep track of the last query for debug.\n\t\t$this->last_query = $query;\n\n\t\t$this->_do_query( $query );\n\n\t\t// MySQL server has gone away, try to reconnect.\n\t\t$mysql_errno = 0;\n\t\tif ( ! empty( $this->dbh ) ) {\n\t\t\tif ( $this->use_mysqli ) {\n\t\t\t\tif ( $this->dbh instanceof mysqli ) {\n\t\t\t\t\t$mysql_errno = mysqli_errno( $this->dbh );\n\t\t\t\t} else {\n\t\t\t\t\t// $dbh is defined, but isn't a real connection.\n\t\t\t\t\t// Something has gone horribly wrong, let's try a reconnect.\n\t\t\t\t\t$mysql_errno = 2006;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ( is_resource( $this->dbh ) ) {\n\t\t\t\t\t$mysql_errno = mysql_errno( $this->dbh );\n\t\t\t\t} else {\n\t\t\t\t\t$mysql_errno = 2006;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( empty( $this->dbh ) || 2006 == $mysql_errno ) {\n\t\t\tif ( $this->check_connection() ) {\n\t\t\t\t$this->_do_query( $query );\n\t\t\t} else {\n\t\t\t\t$this->insert_id = 0;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// If there is an error then take note of it.\n\t\tif ( $this->use_mysqli ) {\n\t\t\tif ( $this->dbh instanceof mysqli ) {\n\t\t\t\t$this->last_error = mysqli_error( $this->dbh );\n\t\t\t} else {\n\t\t\t\t$this->last_error = __( 'Unable to retrieve the error message from MySQL' );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( is_resource( $this->dbh ) ) {\n\t\t\t\t$this->last_error = mysql_error( $this->dbh );\n\t\t\t} else {\n\t\t\t\t$this->last_error = __( 'Unable to retrieve the error message from MySQL' );\n\t\t\t}\n\t\t}\n\n\t\tif ( $this->last_error ) {\n\t\t\t// Clear insert_id on a subsequent failed insert.\n\t\t\tif ( $this->insert_id && preg_match( '/^\\s*(insert|replace)\\s/i', $query ) )\n\t\t\t\t$this->insert_id = 0;\n\n\t\t\t$this->print_error();\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( preg_match( '/^\\s*(create|alter|truncate|drop)\\s/i', $query ) ) {\n\t\t\t$return_val = $this->result;\n\t\t} elseif ( preg_match( '/^\\s*(insert|delete|update|replace)\\s/i', $query ) ) {\n\t\t\tif ( $this->use_mysqli ) {\n\t\t\t\t$this->rows_affected = mysqli_affected_rows( $this->dbh );\n\t\t\t} else {\n\t\t\t\t$this->rows_affected = mysql_affected_rows( $this->dbh );\n\t\t\t}\n\t\t\t// Take note of the insert_id\n\t\t\tif ( preg_match( '/^\\s*(insert|replace)\\s/i', $query ) ) {\n\t\t\t\tif ( $this->use_mysqli ) {\n\t\t\t\t\t$this->insert_id = mysqli_insert_id( $this->dbh );\n\t\t\t\t} else {\n\t\t\t\t\t$this->insert_id = mysql_insert_id( $this->dbh );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Return number of rows affected\n\t\t\t$return_val = $this->rows_affected;\n\t\t} else {\n\t\t\t$num_rows = 0;\n\t\t\tif ( $this->use_mysqli && $this->result instanceof mysqli_result ) {\n\t\t\t\twhile ( $row = mysqli_fetch_object( $this->result ) ) {\n\t\t\t\t\t$this->last_result[$num_rows] = $row;\n\t\t\t\t\t$num_rows++;\n\t\t\t\t}\n\t\t\t} elseif ( is_resource( $this->result ) ) {\n\t\t\t\twhile ( $row = mysql_fetch_object( $this->result ) ) {\n\t\t\t\t\t$this->last_result[$num_rows] = $row;\n\t\t\t\t\t$num_rows++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Log number of rows the query returned\n\t\t\t// and return number of rows selected\n\t\t\t$this->num_rows = $num_rows;\n\t\t\t$return_val     = $num_rows;\n\t\t}\n\n\t\treturn $return_val;\n\t}\n\n\t/**\n\t * Internal function to perform the mysql_query() call.\n\t *\n\t * @since 3.9.0\n\t *\n\t * @see wpdb::query()\n\t *\n\t * @param string $query The query to run.\n\t */\n\tprivate function _do_query( $query ) {\n\t\tif ( defined( 'SAVEQUERIES' ) && SAVEQUERIES ) {\n\t\t\t$this->timer_start();\n\t\t}\n\n\t\tif ( ! empty( $this->dbh ) && $this->use_mysqli ) {\n\t\t\t$this->result = mysqli_query( $this->dbh, $query );\n\t\t} elseif ( ! empty( $this->dbh ) ) {\n\t\t\t$this->result = mysql_query( $query, $this->dbh );\n\t\t}\n\t\t$this->num_queries++;\n\n\t\tif ( defined( 'SAVEQUERIES' ) && SAVEQUERIES ) {\n\t\t\t$this->queries[] = array( $query, $this->timer_stop(), $this->get_caller() );\n\t\t}\n\t}\n\n\t/**\n\t * Insert a row into a table.\n\t *\n\t *     wpdb::insert( 'table', array( 'column' => 'foo', 'field' => 'bar' ) )\n\t *     wpdb::insert( 'table', array( 'column' => 'foo', 'field' => 1337 ), array( '%s', '%d' ) )\n\t *\n\t * @since 2.5.0\n\t * @see wpdb::prepare()\n\t * @see wpdb::$field_types\n\t * @see wp_set_wpdb_vars()\n\t *\n\t * @param string       $table  Table name\n\t * @param array        $data   Data to insert (in column => value pairs).\n\t *                             Both $data columns and $data values should be \"raw\" (neither should be SQL escaped).\n\t *                             Sending a null value will cause the column to be set to NULL - the corresponding format is ignored in this case.\n\t * @param array|string $format Optional. An array of formats to be mapped to each of the value in $data.\n\t *                             If string, that format will be used for all of the values in $data.\n\t *                             A format is one of '%d', '%f', '%s' (integer, float, string).\n\t *                             If omitted, all values in $data will be treated as strings unless otherwise specified in wpdb::$field_types.\n\t * @return int|false The number of rows inserted, or false on error.\n\t */\n\tpublic function insert( $table, $data, $format = null ) {\n\t\treturn $this->_insert_replace_helper( $table, $data, $format, 'INSERT' );\n\t}\n\n\t/**\n\t * Replace a row into a table.\n\t *\n\t *     wpdb::replace( 'table', array( 'column' => 'foo', 'field' => 'bar' ) )\n\t *     wpdb::replace( 'table', array( 'column' => 'foo', 'field' => 1337 ), array( '%s', '%d' ) )\n\t *\n\t * @since 3.0.0\n\t * @see wpdb::prepare()\n\t * @see wpdb::$field_types\n\t * @see wp_set_wpdb_vars()\n\t *\n\t * @param string       $table  Table name\n\t * @param array        $data   Data to insert (in column => value pairs).\n\t *                             Both $data columns and $data values should be \"raw\" (neither should be SQL escaped).\n\t *                             Sending a null value will cause the column to be set to NULL - the corresponding format is ignored in this case.\n\t * @param array|string $format Optional. An array of formats to be mapped to each of the value in $data.\n\t *                             If string, that format will be used for all of the values in $data.\n\t *                             A format is one of '%d', '%f', '%s' (integer, float, string).\n\t *                             If omitted, all values in $data will be treated as strings unless otherwise specified in wpdb::$field_types.\n\t * @return int|false The number of rows affected, or false on error.\n\t */\n\tpublic function replace( $table, $data, $format = null ) {\n\t\treturn $this->_insert_replace_helper( $table, $data, $format, 'REPLACE' );\n\t}\n\n\t/**\n\t * Helper function for insert and replace.\n\t *\n\t * Runs an insert or replace query based on $type argument.\n\t *\n\t * @since 3.0.0\n\t * @see wpdb::prepare()\n\t * @see wpdb::$field_types\n\t * @see wp_set_wpdb_vars()\n\t *\n\t * @param string       $table  Table name\n\t * @param array        $data   Data to insert (in column => value pairs).\n\t *                             Both $data columns and $data values should be \"raw\" (neither should be SQL escaped).\n\t *                             Sending a null value will cause the column to be set to NULL - the corresponding format is ignored in this case.\n\t * @param array|string $format Optional. An array of formats to be mapped to each of the value in $data.\n\t *                             If string, that format will be used for all of the values in $data.\n\t *                             A format is one of '%d', '%f', '%s' (integer, float, string).\n\t *                             If omitted, all values in $data will be treated as strings unless otherwise specified in wpdb::$field_types.\n\t * @param string $type         Optional. What type of operation is this? INSERT or REPLACE. Defaults to INSERT.\n\t * @return int|false The number of rows affected, or false on error.\n\t */\n\tfunction _insert_replace_helper( $table, $data, $format = null, $type = 'INSERT' ) {\n\t\t$this->insert_id = 0;\n\n\t\tif ( ! in_array( strtoupper( $type ), array( 'REPLACE', 'INSERT' ) ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$data = $this->process_fields( $table, $data, $format );\n\t\tif ( false === $data ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$formats = $values = array();\n\t\tforeach ( $data as $value ) {\n\t\t\tif ( is_null( $value['value'] ) ) {\n\t\t\t\t$formats[] = 'NULL';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$formats[] = $value['format'];\n\t\t\t$values[]  = $value['value'];\n\t\t}\n\n\t\t$fields  = '`' . implode( '`, `', array_keys( $data ) ) . '`';\n\t\t$formats = implode( ', ', $formats );\n\n\t\t$sql = \"$type INTO `$table` ($fields) VALUES ($formats)\";\n\n\t\t$this->check_current_query = false;\n\t\treturn $this->query( $this->prepare( $sql, $values ) );\n\t}\n\n\t/**\n\t * Update a row in the table\n\t *\n\t *     wpdb::update( 'table', array( 'column' => 'foo', 'field' => 'bar' ), array( 'ID' => 1 ) )\n\t *     wpdb::update( 'table', array( 'column' => 'foo', 'field' => 1337 ), array( 'ID' => 1 ), array( '%s', '%d' ), array( '%d' ) )\n\t *\n\t * @since 2.5.0\n\t * @see wpdb::prepare()\n\t * @see wpdb::$field_types\n\t * @see wp_set_wpdb_vars()\n\t *\n\t * @param string       $table        Table name\n\t * @param array        $data         Data to update (in column => value pairs).\n\t *                                   Both $data columns and $data values should be \"raw\" (neither should be SQL escaped).\n\t *                                   Sending a null value will cause the column to be set to NULL - the corresponding\n\t *                                   format is ignored in this case.\n\t * @param array        $where        A named array of WHERE clauses (in column => value pairs).\n\t *                                   Multiple clauses will be joined with ANDs.\n\t *                                   Both $where columns and $where values should be \"raw\".\n\t *                                   Sending a null value will create an IS NULL comparison - the corresponding format will be ignored in this case.\n\t * @param array|string $format       Optional. An array of formats to be mapped to each of the values in $data.\n\t *                                   If string, that format will be used for all of the values in $data.\n\t *                                   A format is one of '%d', '%f', '%s' (integer, float, string).\n\t *                                   If omitted, all values in $data will be treated as strings unless otherwise specified in wpdb::$field_types.\n\t * @param array|string $where_format Optional. An array of formats to be mapped to each of the values in $where.\n\t *                                   If string, that format will be used for all of the items in $where.\n\t *                                   A format is one of '%d', '%f', '%s' (integer, float, string).\n\t *                                   If omitted, all values in $where will be treated as strings.\n\t * @return int|false The number of rows updated, or false on error.\n\t */\n\tpublic function update( $table, $data, $where, $format = null, $where_format = null ) {\n\t\tif ( ! is_array( $data ) || ! is_array( $where ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$data = $this->process_fields( $table, $data, $format );\n\t\tif ( false === $data ) {\n\t\t\treturn false;\n\t\t}\n\t\t$where = $this->process_fields( $table, $where, $where_format );\n\t\tif ( false === $where ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$fields = $conditions = $values = array();\n\t\tforeach ( $data as $field => $value ) {\n\t\t\tif ( is_null( $value['value'] ) ) {\n\t\t\t\t$fields[] = \"`$field` = NULL\";\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$fields[] = \"`$field` = \" . $value['format'];\n\t\t\t$values[] = $value['value'];\n\t\t}\n\t\tforeach ( $where as $field => $value ) {\n\t\t\tif ( is_null( $value['value'] ) ) {\n\t\t\t\t$conditions[] = \"`$field` IS NULL\";\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$conditions[] = \"`$field` = \" . $value['format'];\n\t\t\t$values[] = $value['value'];\n\t\t}\n\n\t\t$fields = implode( ', ', $fields );\n\t\t$conditions = implode( ' AND ', $conditions );\n\n\t\t$sql = \"UPDATE `$table` SET $fields WHERE $conditions\";\n\n\t\t$this->check_current_query = false;\n\t\treturn $this->query( $this->prepare( $sql, $values ) );\n\t}\n\n\t/**\n\t * Delete a row in the table\n\t *\n\t *     wpdb::delete( 'table', array( 'ID' => 1 ) )\n\t *     wpdb::delete( 'table', array( 'ID' => 1 ), array( '%d' ) )\n\t *\n\t * @since 3.4.0\n\t * @see wpdb::prepare()\n\t * @see wpdb::$field_types\n\t * @see wp_set_wpdb_vars()\n\t *\n\t * @param string       $table        Table name\n\t * @param array        $where        A named array of WHERE clauses (in column => value pairs).\n\t *                                   Multiple clauses will be joined with ANDs.\n\t *                                   Both $where columns and $where values should be \"raw\".\n\t *                                   Sending a null value will create an IS NULL comparison - the corresponding format will be ignored in this case.\n\t * @param array|string $where_format Optional. An array of formats to be mapped to each of the values in $where.\n\t *                                   If string, that format will be used for all of the items in $where.\n\t *                                   A format is one of '%d', '%f', '%s' (integer, float, string).\n\t *                                   If omitted, all values in $where will be treated as strings unless otherwise specified in wpdb::$field_types.\n\t * @return int|false The number of rows updated, or false on error.\n\t */\n\tpublic function delete( $table, $where, $where_format = null ) {\n\t\tif ( ! is_array( $where ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$where = $this->process_fields( $table, $where, $where_format );\n\t\tif ( false === $where ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$conditions = $values = array();\n\t\tforeach ( $where as $field => $value ) {\n\t\t\tif ( is_null( $value['value'] ) ) {\n\t\t\t\t$conditions[] = \"`$field` IS NULL\";\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$conditions[] = \"`$field` = \" . $value['format'];\n\t\t\t$values[] = $value['value'];\n\t\t}\n\n\t\t$conditions = implode( ' AND ', $conditions );\n\n\t\t$sql = \"DELETE FROM `$table` WHERE $conditions\";\n\n\t\t$this->check_current_query = false;\n\t\treturn $this->query( $this->prepare( $sql, $values ) );\n\t}\n\n\t/**\n\t * Processes arrays of field/value pairs and field formats.\n\t *\n\t * This is a helper method for wpdb's CRUD methods, which take field/value\n\t * pairs for inserts, updates, and where clauses. This method first pairs\n\t * each value with a format. Then it determines the charset of that field,\n\t * using that to determine if any invalid text would be stripped. If text is\n\t * stripped, then field processing is rejected and the query fails.\n\t *\n\t * @since 4.2.0\n\t *\n\t * @param string $table  Table name.\n\t * @param array  $data   Field/value pair.\n\t * @param mixed  $format Format for each field.\n\t * @return array|false Returns an array of fields that contain paired values\n\t *                    and formats. Returns false for invalid values.\n\t */\n\tprotected function process_fields( $table, $data, $format ) {\n\t\t$data = $this->process_field_formats( $data, $format );\n\t\tif ( false === $data ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$data = $this->process_field_charsets( $data, $table );\n\t\tif ( false === $data ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$data = $this->process_field_lengths( $data, $table );\n\t\tif ( false === $data ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$converted_data = $this->strip_invalid_text( $data );\n\n\t\tif ( $data !== $converted_data ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn $data;\n\t}\n\n\t/**\n\t * Prepares arrays of value/format pairs as passed to wpdb CRUD methods.\n\t *\n\t * @since 4.2.0\n\t *\n\t * @param array $data   Array of fields to values.\n\t * @param mixed $format Formats to be mapped to the values in $data.\n\t * @return array Array, keyed by field names with values being an array\n\t *               of 'value' and 'format' keys.\n\t */\n\tprotected function process_field_formats( $data, $format ) {\n\t\t$formats = $original_formats = (array) $format;\n\n\t\tforeach ( $data as $field => $value ) {\n\t\t\t$value = array(\n\t\t\t\t'value'  => $value,\n\t\t\t\t'format' => '%s',\n\t\t\t);\n\n\t\t\tif ( ! empty( $format ) ) {\n\t\t\t\t$value['format'] = array_shift( $formats );\n\t\t\t\tif ( ! $value['format'] ) {\n\t\t\t\t\t$value['format'] = reset( $original_formats );\n\t\t\t\t}\n\t\t\t} elseif ( isset( $this->field_types[ $field ] ) ) {\n\t\t\t\t$value['format'] = $this->field_types[ $field ];\n\t\t\t}\n\n\t\t\t$data[ $field ] = $value;\n\t\t}\n\n\t\treturn $data;\n\t}\n\n\t/**\n\t * Adds field charsets to field/value/format arrays generated by\n\t * the wpdb::process_field_formats() method.\n\t *\n\t * @since 4.2.0\n\t *\n\t * @param array  $data  As it comes from the wpdb::process_field_formats() method.\n\t * @param string $table Table name.\n\t * @return array|false The same array as $data with additional 'charset' keys.\n\t */\n\tprotected function process_field_charsets( $data, $table ) {\n\t\tforeach ( $data as $field => $value ) {\n\t\t\tif ( '%d' === $value['format'] || '%f' === $value['format'] ) {\n\t\t\t\t/*\n\t\t\t\t * We can skip this field if we know it isn't a string.\n\t\t\t\t * This checks %d/%f versus ! %s because its sprintf() could take more.\n\t\t\t\t */\n\t\t\t\t$value['charset'] = false;\n\t\t\t} else {\n\t\t\t\t$value['charset'] = $this->get_col_charset( $table, $field );\n\t\t\t\tif ( is_wp_error( $value['charset'] ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$data[ $field ] = $value;\n\t\t}\n\n\t\treturn $data;\n\t}\n\n\t/**\n\t * For string fields, record the maximum string length that field can safely save.\n\t *\n\t * @since 4.2.1\n\t *\n\t * @param array  $data  As it comes from the wpdb::process_field_charsets() method.\n\t * @param string $table Table name.\n\t * @return array|false The same array as $data with additional 'length' keys, or false if\n\t *                     any of the values were too long for their corresponding field.\n\t */\n\tprotected function process_field_lengths( $data, $table ) {\n\t\tforeach ( $data as $field => $value ) {\n\t\t\tif ( '%d' === $value['format'] || '%f' === $value['format'] ) {\n\t\t\t\t/*\n\t\t\t\t * We can skip this field if we know it isn't a string.\n\t\t\t\t * This checks %d/%f versus ! %s because its sprintf() could take more.\n\t\t\t\t */\n\t\t\t\t$value['length'] = false;\n\t\t\t} else {\n\t\t\t\t$value['length'] = $this->get_col_length( $table, $field );\n\t\t\t\tif ( is_wp_error( $value['length'] ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$data[ $field ] = $value;\n\t\t}\n\n\t\treturn $data;\n\t}\n\n\t/**\n\t * Retrieve one variable from the database.\n\t *\n\t * Executes a SQL query and returns the value from the SQL result.\n\t * If the SQL result contains more than one column and/or more than one row, this function returns the value in the column and row specified.\n\t * If $query is null, this function returns the value in the specified column and row from the previous SQL result.\n\t *\n\t * @since 0.71\n\t *\n\t * @param string|null $query Optional. SQL query. Defaults to null, use the result from the previous query.\n\t * @param int         $x     Optional. Column of value to return. Indexed from 0.\n\t * @param int         $y     Optional. Row of value to return. Indexed from 0.\n\t * @return string|null Database query result (as string), or null on failure\n\t */\n\tpublic function get_var( $query = null, $x = 0, $y = 0 ) {\n\t\t$this->func_call = \"\\$db->get_var(\\\"$query\\\", $x, $y)\";\n\n\t\tif ( $this->check_current_query && $this->check_safe_collation( $query ) ) {\n\t\t\t$this->check_current_query = false;\n\t\t}\n\n\t\tif ( $query ) {\n\t\t\t$this->query( $query );\n\t\t}\n\n\t\t// Extract var out of cached results based x,y vals\n\t\tif ( !empty( $this->last_result[$y] ) ) {\n\t\t\t$values = array_values( get_object_vars( $this->last_result[$y] ) );\n\t\t}\n\n\t\t// If there is a value return it else return null\n\t\treturn ( isset( $values[$x] ) && $values[$x] !== '' ) ? $values[$x] : null;\n\t}\n\n\t/**\n\t * Retrieve one row from the database.\n\t *\n\t * Executes a SQL query and returns the row from the SQL result.\n\t *\n\t * @since 0.71\n\t *\n\t * @param string|null $query  SQL query.\n\t * @param string      $output Optional. The required return type. One of OBJECT, ARRAY_A, or ARRAY_N, which correspond to\n\t *                            an stdClass object, an associative array, or a numeric array, respectively. Default OBJECT.\n\t * @param int         $y      Optional. Row to return. Indexed from 0.\n\t * @return array|object|null|void Database query result in format specified by $output or null on failure\n\t */\n\tpublic function get_row( $query = null, $output = OBJECT, $y = 0 ) {\n\t\t$this->func_call = \"\\$db->get_row(\\\"$query\\\",$output,$y)\";\n\n\t\tif ( $this->check_current_query && $this->check_safe_collation( $query ) ) {\n\t\t\t$this->check_current_query = false;\n\t\t}\n\n\t\tif ( $query ) {\n\t\t\t$this->query( $query );\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( !isset( $this->last_result[$y] ) )\n\t\t\treturn null;\n\n\t\tif ( $output == OBJECT ) {\n\t\t\treturn $this->last_result[$y] ? $this->last_result[$y] : null;\n\t\t} elseif ( $output == ARRAY_A ) {\n\t\t\treturn $this->last_result[$y] ? get_object_vars( $this->last_result[$y] ) : null;\n\t\t} elseif ( $output == ARRAY_N ) {\n\t\t\treturn $this->last_result[$y] ? array_values( get_object_vars( $this->last_result[$y] ) ) : null;\n\t\t} elseif ( strtoupper( $output ) === OBJECT ) {\n\t\t\t// Back compat for OBJECT being previously case insensitive.\n\t\t\treturn $this->last_result[$y] ? $this->last_result[$y] : null;\n\t\t} else {\n\t\t\t$this->print_error( \" \\$db->get_row(string query, output type, int offset) -- Output type must be one of: OBJECT, ARRAY_A, ARRAY_N\" );\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve one column from the database.\n\t *\n\t * Executes a SQL query and returns the column from the SQL result.\n\t * If the SQL result contains more than one column, this function returns the column specified.\n\t * If $query is null, this function returns the specified column from the previous SQL result.\n\t *\n\t * @since 0.71\n\t *\n\t * @param string|null $query Optional. SQL query. Defaults to previous query.\n\t * @param int         $x     Optional. Column to return. Indexed from 0.\n\t * @return array Database query result. Array indexed from 0 by SQL result row number.\n\t */\n\tpublic function get_col( $query = null , $x = 0 ) {\n\t\tif ( $this->check_current_query && $this->check_safe_collation( $query ) ) {\n\t\t\t$this->check_current_query = false;\n\t\t}\n\n\t\tif ( $query ) {\n\t\t\t$this->query( $query );\n\t\t}\n\n\t\t$new_array = array();\n\t\t// Extract the column values\n\t\tfor ( $i = 0, $j = count( $this->last_result ); $i < $j; $i++ ) {\n\t\t\t$new_array[$i] = $this->get_var( null, $x, $i );\n\t\t}\n\t\treturn $new_array;\n\t}\n\n\t/**\n\t * Retrieve an entire SQL result set from the database (i.e., many rows)\n\t *\n\t * Executes a SQL query and returns the entire SQL result.\n\t *\n\t * @since 0.71\n\t *\n\t * @param string $query  SQL query.\n\t * @param string $output Optional. Any of ARRAY_A | ARRAY_N | OBJECT | OBJECT_K constants.\n\t *                       With one of the first three, return an array of rows indexed from 0 by SQL result row number.\n\t *                       Each row is an associative array (column => value, ...), a numerically indexed array (0 => value, ...), or an object. ( ->column = value ), respectively.\n\t *                       With OBJECT_K, return an associative array of row objects keyed by the value of each row's first column's value.\n\t *                       Duplicate keys are discarded.\n\t * @return array|object|null Database query results\n\t */\n\tpublic function get_results( $query = null, $output = OBJECT ) {\n\t\t$this->func_call = \"\\$db->get_results(\\\"$query\\\", $output)\";\n\n\t\tif ( $this->check_current_query && $this->check_safe_collation( $query ) ) {\n\t\t\t$this->check_current_query = false;\n\t\t}\n\n\t\tif ( $query ) {\n\t\t\t$this->query( $query );\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\n\t\t$new_array = array();\n\t\tif ( $output == OBJECT ) {\n\t\t\t// Return an integer-keyed array of row objects\n\t\t\treturn $this->last_result;\n\t\t} elseif ( $output == OBJECT_K ) {\n\t\t\t// Return an array of row objects with keys from column 1\n\t\t\t// (Duplicates are discarded)\n\t\t\tforeach ( $this->last_result as $row ) {\n\t\t\t\t$var_by_ref = get_object_vars( $row );\n\t\t\t\t$key = array_shift( $var_by_ref );\n\t\t\t\tif ( ! isset( $new_array[ $key ] ) )\n\t\t\t\t\t$new_array[ $key ] = $row;\n\t\t\t}\n\t\t\treturn $new_array;\n\t\t} elseif ( $output == ARRAY_A || $output == ARRAY_N ) {\n\t\t\t// Return an integer-keyed array of...\n\t\t\tif ( $this->last_result ) {\n\t\t\t\tforeach ( (array) $this->last_result as $row ) {\n\t\t\t\t\tif ( $output == ARRAY_N ) {\n\t\t\t\t\t\t// ...integer-keyed row arrays\n\t\t\t\t\t\t$new_array[] = array_values( get_object_vars( $row ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// ...column name-keyed row arrays\n\t\t\t\t\t\t$new_array[] = get_object_vars( $row );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $new_array;\n\t\t} elseif ( strtoupper( $output ) === OBJECT ) {\n\t\t\t// Back compat for OBJECT being previously case insensitive.\n\t\t\treturn $this->last_result;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Retrieves the character set for the given table.\n\t *\n\t * @since 4.2.0\n\t *\n\t * @param string $table Table name.\n\t * @return string|WP_Error Table character set, WP_Error object if it couldn't be found.\n\t */\n\tprotected function get_table_charset( $table ) {\n\t\t$tablekey = strtolower( $table );\n\n\t\t/**\n\t\t * Filters the table charset value before the DB is checked.\n\t\t *\n\t\t * Passing a non-null value to the filter will effectively short-circuit\n\t\t * checking the DB for the charset, returning that value instead.\n\t\t *\n\t\t * @since 4.2.0\n\t\t *\n\t\t * @param string $charset The character set to use. Default null.\n\t\t * @param string $table   The name of the table being checked.\n\t\t */\n\t\t$charset = apply_filters( 'pre_get_table_charset', null, $table );\n\t\tif ( null !== $charset ) {\n\t\t\treturn $charset;\n\t\t}\n\n\t\tif ( isset( $this->table_charset[ $tablekey ] ) ) {\n\t\t\treturn $this->table_charset[ $tablekey ];\n\t\t}\n\n\t\t$charsets = $columns = array();\n\n\t\t$table_parts = explode( '.', $table );\n\t\t$table = '`' . implode( '`.`', $table_parts ) . '`';\n\t\t$results = $this->get_results( \"SHOW FULL COLUMNS FROM $table\" );\n\t\tif ( ! $results ) {\n\t\t\treturn new WP_Error( 'wpdb_get_table_charset_failure' );\n\t\t}\n\n\t\tforeach ( $results as $column ) {\n\t\t\t$columns[ strtolower( $column->Field ) ] = $column;\n\t\t}\n\n\t\t$this->col_meta[ $tablekey ] = $columns;\n\n\t\tforeach ( $columns as $column ) {\n\t\t\tif ( ! empty( $column->Collation ) ) {\n\t\t\t\tlist( $charset ) = explode( '_', $column->Collation );\n\n\t\t\t\t// If the current connection can't support utf8mb4 characters, let's only send 3-byte utf8 characters.\n\t\t\t\tif ( 'utf8mb4' === $charset && ! $this->has_cap( 'utf8mb4' ) ) {\n\t\t\t\t\t$charset = 'utf8';\n\t\t\t\t}\n\n\t\t\t\t$charsets[ strtolower( $charset ) ] = true;\n\t\t\t}\n\n\t\t\tlist( $type ) = explode( '(', $column->Type );\n\n\t\t\t// A binary/blob means the whole query gets treated like this.\n\t\t\tif ( in_array( strtoupper( $type ), array( 'BINARY', 'VARBINARY', 'TINYBLOB', 'MEDIUMBLOB', 'BLOB', 'LONGBLOB' ) ) ) {\n\t\t\t\t$this->table_charset[ $tablekey ] = 'binary';\n\t\t\t\treturn 'binary';\n\t\t\t}\n\t\t}\n\n\t\t// utf8mb3 is an alias for utf8.\n\t\tif ( isset( $charsets['utf8mb3'] ) ) {\n\t\t\t$charsets['utf8'] = true;\n\t\t\tunset( $charsets['utf8mb3'] );\n\t\t}\n\n\t\t// Check if we have more than one charset in play.\n\t\t$count = count( $charsets );\n\t\tif ( 1 === $count ) {\n\t\t\t$charset = key( $charsets );\n\t\t} elseif ( 0 === $count ) {\n\t\t\t// No charsets, assume this table can store whatever.\n\t\t\t$charset = false;\n\t\t} else {\n\t\t\t// More than one charset. Remove latin1 if present and recalculate.\n\t\t\tunset( $charsets['latin1'] );\n\t\t\t$count = count( $charsets );\n\t\t\tif ( 1 === $count ) {\n\t\t\t\t// Only one charset (besides latin1).\n\t\t\t\t$charset = key( $charsets );\n\t\t\t} elseif ( 2 === $count && isset( $charsets['utf8'], $charsets['utf8mb4'] ) ) {\n\t\t\t\t// Two charsets, but they're utf8 and utf8mb4, use utf8.\n\t\t\t\t$charset = 'utf8';\n\t\t\t} else {\n\t\t\t\t// Two mixed character sets. ascii.\n\t\t\t\t$charset = 'ascii';\n\t\t\t}\n\t\t}\n\n\t\t$this->table_charset[ $tablekey ] = $charset;\n\t\treturn $charset;\n\t}\n\n\t/**\n\t * Retrieves the character set for the given column.\n\t *\n\t * @since 4.2.0\n\t *\n\t * @param string $table  Table name.\n\t * @param string $column Column name.\n\t * @return string|false|WP_Error Column character set as a string. False if the column has no\n\t *                               character set. WP_Error object if there was an error.\n\t */\n\tpublic function get_col_charset( $table, $column ) {\n\t\t$tablekey = strtolower( $table );\n\t\t$columnkey = strtolower( $column );\n\n\t\t/**\n\t\t * Filters the column charset value before the DB is checked.\n\t\t *\n\t\t * Passing a non-null value to the filter will short-circuit\n\t\t * checking the DB for the charset, returning that value instead.\n\t\t *\n\t\t * @since 4.2.0\n\t\t *\n\t\t * @param string $charset The character set to use. Default null.\n\t\t * @param string $table   The name of the table being checked.\n\t\t * @param string $column  The name of the column being checked.\n\t\t */\n\t\t$charset = apply_filters( 'pre_get_col_charset', null, $table, $column );\n\t\tif ( null !== $charset ) {\n\t\t\treturn $charset;\n\t\t}\n\n\t\t// Skip this entirely if this isn't a MySQL database.\n\t\tif ( empty( $this->is_mysql ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( empty( $this->table_charset[ $tablekey ] ) ) {\n\t\t\t// This primes column information for us.\n\t\t\t$table_charset = $this->get_table_charset( $table );\n\t\t\tif ( is_wp_error( $table_charset ) ) {\n\t\t\t\treturn $table_charset;\n\t\t\t}\n\t\t}\n\n\t\t// If still no column information, return the table charset.\n\t\tif ( empty( $this->col_meta[ $tablekey ] ) ) {\n\t\t\treturn $this->table_charset[ $tablekey ];\n\t\t}\n\n\t\t// If this column doesn't exist, return the table charset.\n\t\tif ( empty( $this->col_meta[ $tablekey ][ $columnkey ] ) ) {\n\t\t\treturn $this->table_charset[ $tablekey ];\n\t\t}\n\n\t\t// Return false when it's not a string column.\n\t\tif ( empty( $this->col_meta[ $tablekey ][ $columnkey ]->Collation ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlist( $charset ) = explode( '_', $this->col_meta[ $tablekey ][ $columnkey ]->Collation );\n\t\treturn $charset;\n\t}\n\n\t/**\n\t * Retrieve the maximum string length allowed in a given column.\n\t * The length may either be specified as a byte length or a character length.\n\t *\n\t * @since 4.2.1\n\t *\n\t * @param string $table  Table name.\n\t * @param string $column Column name.\n\t * @return array|false|WP_Error array( 'length' => (int), 'type' => 'byte' | 'char' )\n\t *                              false if the column has no length (for example, numeric column)\n\t *                              WP_Error object if there was an error.\n\t */\n\tpublic function get_col_length( $table, $column ) {\n\t\t$tablekey = strtolower( $table );\n\t\t$columnkey = strtolower( $column );\n\n\t\t// Skip this entirely if this isn't a MySQL database.\n\t\tif ( empty( $this->is_mysql ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( empty( $this->col_meta[ $tablekey ] ) ) {\n\t\t\t// This primes column information for us.\n\t\t\t$table_charset = $this->get_table_charset( $table );\n\t\t\tif ( is_wp_error( $table_charset ) ) {\n\t\t\t\treturn $table_charset;\n\t\t\t}\n\t\t}\n\n\t\tif ( empty( $this->col_meta[ $tablekey ][ $columnkey ] ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$typeinfo = explode( '(', $this->col_meta[ $tablekey ][ $columnkey ]->Type );\n\n\t\t$type = strtolower( $typeinfo[0] );\n\t\tif ( ! empty( $typeinfo[1] ) ) {\n\t\t\t$length = trim( $typeinfo[1], ')' );\n\t\t} else {\n\t\t\t$length = false;\n\t\t}\n\n\t\tswitch( $type ) {\n\t\t\tcase 'char':\n\t\t\tcase 'varchar':\n\t\t\t\treturn array(\n\t\t\t\t\t'type'   => 'char',\n\t\t\t\t\t'length' => (int) $length,\n\t\t\t\t);\n\n\t\t\tcase 'binary':\n\t\t\tcase 'varbinary':\n\t\t\t\treturn array(\n\t\t\t\t\t'type'   => 'byte',\n\t\t\t\t\t'length' => (int) $length,\n\t\t\t\t);\n\n\t\t\tcase 'tinyblob':\n\t\t\tcase 'tinytext':\n\t\t\t\treturn array(\n\t\t\t\t\t'type'   => 'byte',\n\t\t\t\t\t'length' => 255,        // 2^8 - 1\n\t\t\t\t);\n\n\t\t\tcase 'blob':\n\t\t\tcase 'text':\n\t\t\t\treturn array(\n\t\t\t\t\t'type'   => 'byte',\n\t\t\t\t\t'length' => 65535,      // 2^16 - 1\n\t\t\t\t);\n\n\t\t\tcase 'mediumblob':\n\t\t\tcase 'mediumtext':\n\t\t\t\treturn array(\n\t\t\t\t\t'type'   => 'byte',\n\t\t\t\t\t'length' => 16777215,   // 2^24 - 1\n\t\t\t\t);\n\n\t\t\tcase 'longblob':\n\t\t\tcase 'longtext':\n\t\t\t\treturn array(\n\t\t\t\t\t'type'   => 'byte',\n\t\t\t\t\t'length' => 4294967295, // 2^32 - 1\n\t\t\t\t);\n\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Check if a string is ASCII.\n\t *\n\t * The negative regex is faster for non-ASCII strings, as it allows\n\t * the search to finish as soon as it encounters a non-ASCII character.\n\t *\n\t * @since 4.2.0\n\t *\n\t * @param string $string String to check.\n\t * @return bool True if ASCII, false if not.\n\t */\n\tprotected function check_ascii( $string ) {\n\t\tif ( function_exists( 'mb_check_encoding' ) ) {\n\t\t\tif ( mb_check_encoding( $string, 'ASCII' ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} elseif ( ! preg_match( '/[^\\x00-\\x7F]/', $string ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if the query is accessing a collation considered safe on the current version of MySQL.\n\t *\n\t * @since 4.2.0\n\t *\n\t * @param string $query The query to check.\n\t * @return bool True if the collation is safe, false if it isn't.\n\t */\n\tprotected function check_safe_collation( $query ) {\n\t\tif ( $this->checking_collation ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// We don't need to check the collation for queries that don't read data.\n\t\t$query = ltrim( $query, \"\\r\\n\\t (\" );\n\t\tif ( preg_match( '/^(?:SHOW|DESCRIBE|DESC|EXPLAIN|CREATE)\\s/i', $query ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// All-ASCII queries don't need extra checking.\n\t\tif ( $this->check_ascii( $query ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t$table = $this->get_table_from_query( $query );\n\t\tif ( ! $table ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$this->checking_collation = true;\n\t\t$collation = $this->get_table_charset( $table );\n\t\t$this->checking_collation = false;\n\n\t\t// Tables with no collation, or latin1 only, don't need extra checking.\n\t\tif ( false === $collation || 'latin1' === $collation ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t$table = strtolower( $table );\n\t\tif ( empty( $this->col_meta[ $table ] ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// If any of the columns don't have one of these collations, it needs more sanity checking.\n\t\tforeach ( $this->col_meta[ $table ] as $col ) {\n\t\t\tif ( empty( $col->Collation ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( ! in_array( $col->Collation, array( 'utf8_general_ci', 'utf8_bin', 'utf8mb4_general_ci', 'utf8mb4_bin' ), true ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Strips any invalid characters based on value/charset pairs.\n\t *\n\t * @since 4.2.0\n\t *\n\t * @param array $data Array of value arrays. Each value array has the keys\n\t *                    'value' and 'charset'. An optional 'ascii' key can be\n\t *                    set to false to avoid redundant ASCII checks.\n\t * @return array|WP_Error The $data parameter, with invalid characters removed from\n\t *                        each value. This works as a passthrough: any additional keys\n\t *                        such as 'field' are retained in each value array. If we cannot\n\t *                        remove invalid characters, a WP_Error object is returned.\n\t */\n\tprotected function strip_invalid_text( $data ) {\n\t\t$db_check_string = false;\n\n\t\tforeach ( $data as &$value ) {\n\t\t\t$charset = $value['charset'];\n\n\t\t\tif ( is_array( $value['length'] ) ) {\n\t\t\t\t$length = $value['length']['length'];\n\t\t\t\t$truncate_by_byte_length = 'byte' === $value['length']['type'];\n\t\t\t} else {\n\t\t\t\t$length = false;\n\t\t\t\t// Since we have no length, we'll never truncate.\n\t\t\t\t// Initialize the variable to false. true would take us\n\t\t\t\t// through an unnecessary (for this case) codepath below.\n\t\t\t\t$truncate_by_byte_length = false;\n\t\t\t}\n\n\t\t\t// There's no charset to work with.\n\t\t\tif ( false === $charset ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Column isn't a string.\n\t\t\tif ( ! is_string( $value['value'] ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$needs_validation = true;\n\t\t\tif (\n\t\t\t\t// latin1 can store any byte sequence\n\t\t\t\t'latin1' === $charset\n\t\t\t||\n\t\t\t\t// ASCII is always OK.\n\t\t\t\t( ! isset( $value['ascii'] ) && $this->check_ascii( $value['value'] ) )\n\t\t\t) {\n\t\t\t\t$truncate_by_byte_length = true;\n\t\t\t\t$needs_validation = false;\n\t\t\t}\n\n\t\t\tif ( $truncate_by_byte_length ) {\n\t\t\t\tmbstring_binary_safe_encoding();\n\t\t\t\tif ( false !== $length && strlen( $value['value'] ) > $length ) {\n\t\t\t\t\t$value['value'] = substr( $value['value'], 0, $length );\n\t\t\t\t}\n\t\t\t\treset_mbstring_encoding();\n\n\t\t\t\tif ( ! $needs_validation ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// utf8 can be handled by regex, which is a bunch faster than a DB lookup.\n\t\t\tif ( ( 'utf8' === $charset || 'utf8mb3' === $charset || 'utf8mb4' === $charset ) && function_exists( 'mb_strlen' ) ) {\n\t\t\t\t$regex = '/\n\t\t\t\t\t(\n\t\t\t\t\t\t(?: [\\x00-\\x7F]                  # single-byte sequences   0xxxxxxx\n\t\t\t\t\t\t|   [\\xC2-\\xDF][\\x80-\\xBF]       # double-byte sequences   110xxxxx 10xxxxxx\n\t\t\t\t\t\t|   \\xE0[\\xA0-\\xBF][\\x80-\\xBF]   # triple-byte sequences   1110xxxx 10xxxxxx * 2\n\t\t\t\t\t\t|   [\\xE1-\\xEC][\\x80-\\xBF]{2}\n\t\t\t\t\t\t|   \\xED[\\x80-\\x9F][\\x80-\\xBF]\n\t\t\t\t\t\t|   [\\xEE-\\xEF][\\x80-\\xBF]{2}';\n\n\t\t\t\tif ( 'utf8mb4' === $charset ) {\n\t\t\t\t\t$regex .= '\n\t\t\t\t\t\t|    \\xF0[\\x90-\\xBF][\\x80-\\xBF]{2} # four-byte sequences   11110xxx 10xxxxxx * 3\n\t\t\t\t\t\t|    [\\xF1-\\xF3][\\x80-\\xBF]{3}\n\t\t\t\t\t\t|    \\xF4[\\x80-\\x8F][\\x80-\\xBF]{2}\n\t\t\t\t\t';\n\t\t\t\t}\n\n\t\t\t\t$regex .= '){1,40}                          # ...one or more times\n\t\t\t\t\t)\n\t\t\t\t\t| .                                  # anything else\n\t\t\t\t\t/x';\n\t\t\t\t$value['value'] = preg_replace( $regex, '$1', $value['value'] );\n\n\n\t\t\t\tif ( false !== $length && mb_strlen( $value['value'], 'UTF-8' ) > $length ) {\n\t\t\t\t\t$value['value'] = mb_substr( $value['value'], 0, $length, 'UTF-8' );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// We couldn't use any local conversions, send it to the DB.\n\t\t\t$value['db'] = $db_check_string = true;\n\t\t}\n\t\tunset( $value ); // Remove by reference.\n\n\t\tif ( $db_check_string ) {\n\t\t\t$queries = array();\n\t\t\tforeach ( $data as $col => $value ) {\n\t\t\t\tif ( ! empty( $value['db'] ) ) {\n\t\t\t\t\t// We're going to need to truncate by characters or bytes, depending on the length value we have.\n\t\t\t\t\tif ( 'byte' === $value['length']['type'] ) {\n\t\t\t\t\t\t// Using binary causes LEFT() to truncate by bytes.\n\t\t\t\t\t\t$charset = 'binary';\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$charset = $value['charset'];\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( $this->charset ) {\n\t\t\t\t\t\t$connection_charset = $this->charset;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( $this->use_mysqli ) {\n\t\t\t\t\t\t\t$connection_charset = mysqli_character_set_name( $this->dbh );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$connection_charset = mysql_client_encoding();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( is_array( $value['length'] ) ) {\n\t\t\t\t\t\t$queries[ $col ] = $this->prepare( \"CONVERT( LEFT( CONVERT( %s USING $charset ), %.0f ) USING $connection_charset )\", $value['value'], $value['length']['length'] );\n\t\t\t\t\t} else if ( 'binary' !== $charset ) {\n\t\t\t\t\t\t// If we don't have a length, there's no need to convert binary - it will always return the same result.\n\t\t\t\t\t\t$queries[ $col ] = $this->prepare( \"CONVERT( CONVERT( %s USING $charset ) USING $connection_charset )\", $value['value'] );\n\t\t\t\t\t}\n\n\t\t\t\t\tunset( $data[ $col ]['db'] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$sql = array();\n\t\t\tforeach ( $queries as $column => $query ) {\n\t\t\t\tif ( ! $query ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t$sql[] = $query . \" AS x_$column\";\n\t\t\t}\n\n\t\t\t$this->check_current_query = false;\n\t\t\t$row = $this->get_row( \"SELECT \" . implode( ', ', $sql ), ARRAY_A );\n\t\t\tif ( ! $row ) {\n\t\t\t\treturn new WP_Error( 'wpdb_strip_invalid_text_failure' );\n\t\t\t}\n\n\t\t\tforeach ( array_keys( $data ) as $column ) {\n\t\t\t\tif ( isset( $row[\"x_$column\"] ) ) {\n\t\t\t\t\t$data[ $column ]['value'] = $row[\"x_$column\"];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn $data;\n\t}\n\n\t/**\n\t * Strips any invalid characters from the query.\n\t *\n\t * @since 4.2.0\n\t *\n\t * @param string $query Query to convert.\n\t * @return string|WP_Error The converted query, or a WP_Error object if the conversion fails.\n\t */\n\tprotected function strip_invalid_text_from_query( $query ) {\n\t\t// We don't need to check the collation for queries that don't read data.\n\t\t$trimmed_query = ltrim( $query, \"\\r\\n\\t (\" );\n\t\tif ( preg_match( '/^(?:SHOW|DESCRIBE|DESC|EXPLAIN|CREATE)\\s/i', $trimmed_query ) ) {\n\t\t\treturn $query;\n\t\t}\n\n\t\t$table = $this->get_table_from_query( $query );\n\t\tif ( $table ) {\n\t\t\t$charset = $this->get_table_charset( $table );\n\t\t\tif ( is_wp_error( $charset ) ) {\n\t\t\t\treturn $charset;\n\t\t\t}\n\n\t\t\t// We can't reliably strip text from tables containing binary/blob columns\n\t\t\tif ( 'binary' === $charset ) {\n\t\t\t\treturn $query;\n\t\t\t}\n\t\t} else {\n\t\t\t$charset = $this->charset;\n\t\t}\n\n\t\t$data = array(\n\t\t\t'value'   => $query,\n\t\t\t'charset' => $charset,\n\t\t\t'ascii'   => false,\n\t\t\t'length'  => false,\n\t\t);\n\n\t\t$data = $this->strip_invalid_text( array( $data ) );\n\t\tif ( is_wp_error( $data ) ) {\n\t\t\treturn $data;\n\t\t}\n\n\t\treturn $data[0]['value'];\n\t}\n\n\t/**\n\t * Strips any invalid characters from the string for a given table and column.\n\t *\n\t * @since 4.2.0\n\t *\n\t * @param string $table  Table name.\n\t * @param string $column Column name.\n\t * @param string $value  The text to check.\n\t * @return string|WP_Error The converted string, or a WP_Error object if the conversion fails.\n\t */\n\tpublic function strip_invalid_text_for_column( $table, $column, $value ) {\n\t\tif ( ! is_string( $value ) ) {\n\t\t\treturn $value;\n\t\t}\n\n\t\t$charset = $this->get_col_charset( $table, $column );\n\t\tif ( ! $charset ) {\n\t\t\t// Not a string column.\n\t\t\treturn $value;\n\t\t} elseif ( is_wp_error( $charset ) ) {\n\t\t\t// Bail on real errors.\n\t\t\treturn $charset;\n\t\t}\n\n\t\t$data = array(\n\t\t\t$column => array(\n\t\t\t\t'value'   => $value,\n\t\t\t\t'charset' => $charset,\n\t\t\t\t'length'  => $this->get_col_length( $table, $column ),\n\t\t\t)\n\t\t);\n\n\t\t$data = $this->strip_invalid_text( $data );\n\t\tif ( is_wp_error( $data ) ) {\n\t\t\treturn $data;\n\t\t}\n\n\t\treturn $data[ $column ]['value'];\n\t}\n\n\t/**\n\t * Find the first table name referenced in a query.\n\t *\n\t * @since 4.2.0\n\t *\n\t * @param string $query The query to search.\n\t * @return string|false $table The table name found, or false if a table couldn't be found.\n\t */\n\tprotected function get_table_from_query( $query ) {\n\t\t// Remove characters that can legally trail the table name.\n\t\t$query = rtrim( $query, ';/-#' );\n\n\t\t// Allow (select...) union [...] style queries. Use the first query's table name.\n\t\t$query = ltrim( $query, \"\\r\\n\\t (\" );\n\n\t\t// Strip everything between parentheses except nested selects.\n\t\t$query = preg_replace( '/\\((?!\\s*select)[^(]*?\\)/is', '()', $query );\n\n\t\t// Quickly match most common queries.\n\t\tif ( preg_match( '/^\\s*(?:'\n\t\t\t\t. 'SELECT.*?\\s+FROM'\n\t\t\t\t. '|INSERT(?:\\s+LOW_PRIORITY|\\s+DELAYED|\\s+HIGH_PRIORITY)?(?:\\s+IGNORE)?(?:\\s+INTO)?'\n\t\t\t\t. '|REPLACE(?:\\s+LOW_PRIORITY|\\s+DELAYED)?(?:\\s+INTO)?'\n\t\t\t\t. '|UPDATE(?:\\s+LOW_PRIORITY)?(?:\\s+IGNORE)?'\n\t\t\t\t. '|DELETE(?:\\s+LOW_PRIORITY|\\s+QUICK|\\s+IGNORE)*(?:.+?FROM)?'\n\t\t\t\t. ')\\s+((?:[0-9a-zA-Z$_.`-]|[\\xC2-\\xDF][\\x80-\\xBF])+)/is', $query, $maybe ) ) {\n\t\t\treturn str_replace( '`', '', $maybe[1] );\n\t\t}\n\n\t\t// SHOW TABLE STATUS and SHOW TABLES WHERE Name = 'wp_posts'\n\t\tif ( preg_match( '/^\\s*SHOW\\s+(?:TABLE\\s+STATUS|(?:FULL\\s+)?TABLES).+WHERE\\s+Name\\s*=\\s*(\"|\\')((?:[0-9a-zA-Z$_.-]|[\\xC2-\\xDF][\\x80-\\xBF])+)\\\\1/is', $query, $maybe ) ) {\n\t\t\treturn $maybe[2];\n\t\t}\n\n\t\t// SHOW TABLE STATUS LIKE and SHOW TABLES LIKE 'wp\\_123\\_%'\n\t\t// This quoted LIKE operand seldom holds a full table name.\n\t\t// It is usually a pattern for matching a prefix so we just\n\t\t// strip the trailing % and unescape the _ to get 'wp_123_'\n\t\t// which drop-ins can use for routing these SQL statements.\n\t\tif ( preg_match( '/^\\s*SHOW\\s+(?:TABLE\\s+STATUS|(?:FULL\\s+)?TABLES)\\s+(?:WHERE\\s+Name\\s+)?LIKE\\s*(\"|\\')((?:[\\\\\\\\0-9a-zA-Z$_.-]|[\\xC2-\\xDF][\\x80-\\xBF])+)%?\\\\1/is', $query, $maybe ) ) {\n\t\t\treturn str_replace( '\\\\_', '_', $maybe[2] );\n\t\t}\n\n\t\t// Big pattern for the rest of the table-related queries.\n\t\tif ( preg_match( '/^\\s*(?:'\n\t\t\t\t. '(?:EXPLAIN\\s+(?:EXTENDED\\s+)?)?SELECT.*?\\s+FROM'\n\t\t\t\t. '|DESCRIBE|DESC|EXPLAIN|HANDLER'\n\t\t\t\t. '|(?:LOCK|UNLOCK)\\s+TABLE(?:S)?'\n\t\t\t\t. '|(?:RENAME|OPTIMIZE|BACKUP|RESTORE|CHECK|CHECKSUM|ANALYZE|REPAIR).*\\s+TABLE'\n\t\t\t\t. '|TRUNCATE(?:\\s+TABLE)?'\n\t\t\t\t. '|CREATE(?:\\s+TEMPORARY)?\\s+TABLE(?:\\s+IF\\s+NOT\\s+EXISTS)?'\n\t\t\t\t. '|ALTER(?:\\s+IGNORE)?\\s+TABLE'\n\t\t\t\t. '|DROP\\s+TABLE(?:\\s+IF\\s+EXISTS)?'\n\t\t\t\t. '|CREATE(?:\\s+\\w+)?\\s+INDEX.*\\s+ON'\n\t\t\t\t. '|DROP\\s+INDEX.*\\s+ON'\n\t\t\t\t. '|LOAD\\s+DATA.*INFILE.*INTO\\s+TABLE'\n\t\t\t\t. '|(?:GRANT|REVOKE).*ON\\s+TABLE'\n\t\t\t\t. '|SHOW\\s+(?:.*FROM|.*TABLE)'\n\t\t\t\t. ')\\s+\\(*\\s*((?:[0-9a-zA-Z$_.`-]|[\\xC2-\\xDF][\\x80-\\xBF])+)\\s*\\)*/is', $query, $maybe ) ) {\n\t\t\treturn str_replace( '`', '', $maybe[1] );\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Load the column metadata from the last query.\n\t *\n\t * @since 3.5.0\n\t *\n\t */\n\tprotected function load_col_info() {\n\t\tif ( $this->col_info )\n\t\t\treturn;\n\n\t\tif ( $this->use_mysqli ) {\n\t\t\t$num_fields = mysqli_num_fields( $this->result );\n\t\t\tfor ( $i = 0; $i < $num_fields; $i++ ) {\n\t\t\t\t$this->col_info[ $i ] = mysqli_fetch_field( $this->result );\n\t\t\t}\n\t\t} else {\n\t\t\t$num_fields = mysql_num_fields( $this->result );\n\t\t\tfor ( $i = 0; $i < $num_fields; $i++ ) {\n\t\t\t\t$this->col_info[ $i ] = mysql_fetch_field( $this->result, $i );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve column metadata from the last query.\n\t *\n\t * @since 0.71\n\t *\n\t * @param string $info_type  Optional. Type one of name, table, def, max_length, not_null, primary_key, multiple_key, unique_key, numeric, blob, type, unsigned, zerofill\n\t * @param int    $col_offset Optional. 0: col name. 1: which table the col's in. 2: col's max length. 3: if the col is numeric. 4: col's type\n\t * @return mixed Column Results\n\t */\n\tpublic function get_col_info( $info_type = 'name', $col_offset = -1 ) {\n\t\t$this->load_col_info();\n\n\t\tif ( $this->col_info ) {\n\t\t\tif ( $col_offset == -1 ) {\n\t\t\t\t$i = 0;\n\t\t\t\t$new_array = array();\n\t\t\t\tforeach ( (array) $this->col_info as $col ) {\n\t\t\t\t\t$new_array[$i] = $col->{$info_type};\n\t\t\t\t\t$i++;\n\t\t\t\t}\n\t\t\t\treturn $new_array;\n\t\t\t} else {\n\t\t\t\treturn $this->col_info[$col_offset]->{$info_type};\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Starts the timer, for debugging purposes.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @return true\n\t */\n\tpublic function timer_start() {\n\t\t$this->time_start = microtime( true );\n\t\treturn true;\n\t}\n\n\t/**\n\t * Stops the debugging timer.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @return float Total time spent on the query, in seconds\n\t */\n\tpublic function timer_stop() {\n\t\treturn ( microtime( true ) - $this->time_start );\n\t}\n\n\t/**\n\t * Wraps errors in a nice header and footer and dies.\n\t *\n\t * Will not die if wpdb::$show_errors is false.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param string $message    The Error message\n\t * @param string $error_code Optional. A Computer readable string to identify the error.\n\t * @return false|void\n\t */\n\tpublic function bail( $message, $error_code = '500' ) {\n\t\tif ( !$this->show_errors ) {\n\t\t\tif ( class_exists( 'WP_Error', false ) ) {\n\t\t\t\t$this->error = new WP_Error($error_code, $message);\n\t\t\t} else {\n\t\t\t\t$this->error = $message;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\twp_die($message);\n\t}\n\n\n\t/**\n\t * Closes the current database connection.\n\t *\n\t * @since 4.5.0\n\t *\n\t * @return bool True if the connection was successfully closed, false if it wasn't,\n\t *              or the connection doesn't exist.\n\t */\n\tpublic function close() {\n\t\tif ( ! $this->dbh ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( $this->use_mysqli ) {\n\t\t\t$closed = mysqli_close( $this->dbh );\n\t\t} else {\n\t\t\t$closed = mysql_close( $this->dbh );\n\t\t}\n\n\t\tif ( $closed ) {\n\t\t\t$this->dbh = null;\n\t\t\t$this->ready = false;\n\t\t\t$this->has_connected = false;\n\t\t}\n\n\t\treturn $closed;\n\t}\n\n\t/**\n\t * Whether MySQL database is at least the required minimum version.\n\t *\n\t * @since 2.5.0\n\t *\n\t * @global string $wp_version\n\t * @global string $required_mysql_version\n\t *\n\t * @return WP_Error|void\n\t */\n\tpublic function check_database_version() {\n\t\tglobal $wp_version, $required_mysql_version;\n\t\t// Make sure the server has the required MySQL version\n\t\tif ( version_compare($this->db_version(), $required_mysql_version, '<') ) {\n\t\t\t/* translators: 1: WordPress version number, 2: Minimum required MySQL version number */\n\t\t\treturn new WP_Error('database_version', sprintf( __( '<strong>ERROR</strong>: WordPress %1$s requires MySQL %2$s or higher' ), $wp_version, $required_mysql_version ));\n\t\t}\n\t}\n\n\t/**\n\t * Whether the database supports collation.\n\t *\n\t * Called when WordPress is generating the table scheme.\n\t *\n\t * Use `wpdb::has_cap( 'collation' )`.\n\t *\n\t * @since 2.5.0\n\t * @deprecated 3.5.0 Use wpdb::has_cap()\n\t *\n\t * @return bool True if collation is supported, false if version does not\n\t */\n\tpublic function supports_collation() {\n\t\t_deprecated_function( __FUNCTION__, '3.5.0', 'wpdb::has_cap( \\'collation\\' )' );\n\t\treturn $this->has_cap( 'collation' );\n\t}\n\n\t/**\n\t * The database character collate.\n\t *\n\t * @since 3.5.0\n\t *\n\t * @return string The database character collate.\n\t */\n\tpublic function get_charset_collate() {\n\t\t$charset_collate = '';\n\n\t\tif ( ! empty( $this->charset ) )\n\t\t\t$charset_collate = \"DEFAULT CHARACTER SET $this->charset\";\n\t\tif ( ! empty( $this->collate ) )\n\t\t\t$charset_collate .= \" COLLATE $this->collate\";\n\n\t\treturn $charset_collate;\n\t}\n\n\t/**\n\t * Determine if a database supports a particular feature.\n\t *\n\t * @since 2.7.0\n\t * @since 4.1.0 Added support for the 'utf8mb4' feature.\n\t * @since 4.6.0 Added support for the 'utf8mb4_520' feature.\n\t *\n\t * @see wpdb::db_version()\n\t *\n\t * @param string $db_cap The feature to check for. Accepts 'collation',\n\t *                       'group_concat', 'subqueries', 'set_charset',\n\t *                       'utf8mb4', or 'utf8mb4_520'.\n\t * @return int|false Whether the database feature is supported, false otherwise.\n\t */\n\tpublic function has_cap( $db_cap ) {\n\t\t$version = $this->db_version();\n\n\t\tswitch ( strtolower( $db_cap ) ) {\n\t\t\tcase 'collation' :    // @since 2.5.0\n\t\t\tcase 'group_concat' : // @since 2.7.0\n\t\t\tcase 'subqueries' :   // @since 2.7.0\n\t\t\t\treturn version_compare( $version, '4.1', '>=' );\n\t\t\tcase 'set_charset' :\n\t\t\t\treturn version_compare( $version, '5.0.7', '>=' );\n\t\t\tcase 'utf8mb4' :      // @since 4.1.0\n\t\t\t\tif ( version_compare( $version, '5.5.3', '<' ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif ( $this->use_mysqli ) {\n\t\t\t\t\t$client_version = mysqli_get_client_info();\n\t\t\t\t} else {\n\t\t\t\t\t$client_version = mysql_get_client_info();\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * libmysql has supported utf8mb4 since 5.5.3, same as the MySQL server.\n\t\t\t\t * mysqlnd has supported utf8mb4 since 5.0.9.\n\t\t\t\t */\n\t\t\t\tif ( false !== strpos( $client_version, 'mysqlnd' ) ) {\n\t\t\t\t\t$client_version = preg_replace( '/^\\D+([\\d.]+).*/', '$1', $client_version );\n\t\t\t\t\treturn version_compare( $client_version, '5.0.9', '>=' );\n\t\t\t\t} else {\n\t\t\t\t\treturn version_compare( $client_version, '5.5.3', '>=' );\n\t\t\t\t}\n\t\t\tcase 'utf8mb4_520' : // @since 4.6.0\n\t\t\t\treturn version_compare( $version, '5.6', '>=' );\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Retrieve the name of the function that called wpdb.\n\t *\n\t * Searches up the list of functions until it reaches\n\t * the one that would most logically had called this method.\n\t *\n\t * @since 2.5.0\n\t *\n\t * @return string|array The name of the calling function\n\t */\n\tpublic function get_caller() {\n\t\treturn wp_debug_backtrace_summary( __CLASS__ );\n\t}\n\n\t/**\n\t * Retrieves the MySQL server version.\n\t *\n\t * @since 2.7.0\n\t *\n\t * @return null|string Null on failure, version number on success.\n\t */\n\tpublic function db_version() {\n\t\tif ( $this->use_mysqli ) {\n\t\t\t$server_info = mysqli_get_server_info( $this->dbh );\n\t\t} else {\n\t\t\t$server_info = mysql_get_server_info( $this->dbh );\n\t\t}\n\t\treturn preg_replace( '/[^0-9.].*/', '', $server_info );\n\t}\n}\n"], "fixing_code": ["<?php\n/**\n * The WordPress version string\n *\n * @global string $wp_version\n */\n$wp_version = '4.9-alpha-41470';\n\n/**\n * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema.\n *\n * @global int $wp_db_version\n */\n$wp_db_version = 38590;\n\n/**\n * Holds the TinyMCE version\n *\n * @global string $tinymce_version\n */\n$tinymce_version = '4603-20170530';\n\n/**\n * Holds the required PHP version\n *\n * @global string $required_php_version\n */\n$required_php_version = '5.2.4';\n\n/**\n * Holds the required MySQL version\n *\n * @global string $required_mysql_version\n */\n$required_mysql_version = '5.0';\n", "<?php\n/**\n * WordPress DB Class\n *\n * Original code from {@link http://php.justinvincent.com Justin Vincent (justin@visunet.ie)}\n *\n * @package WordPress\n * @subpackage Database\n * @since 0.71\n */\n\n/**\n * @since 0.71\n */\ndefine( 'EZSQL_VERSION', 'WP1.25' );\n\n/**\n * @since 0.71\n */\ndefine( 'OBJECT', 'OBJECT' );\ndefine( 'object', 'OBJECT' ); // Back compat.\n\n/**\n * @since 2.5.0\n */\ndefine( 'OBJECT_K', 'OBJECT_K' );\n\n/**\n * @since 0.71\n */\ndefine( 'ARRAY_A', 'ARRAY_A' );\n\n/**\n * @since 0.71\n */\ndefine( 'ARRAY_N', 'ARRAY_N' );\n\n/**\n * WordPress Database Access Abstraction Object\n *\n * It is possible to replace this class with your own\n * by setting the $wpdb global variable in wp-content/db.php\n * file to your class. The wpdb class will still be included,\n * so you can extend it or simply use your own.\n *\n * @link https://codex.wordpress.org/Function_Reference/wpdb_Class\n *\n * @since 0.71\n */\nclass wpdb {\n\n\t/**\n\t * Whether to show SQL/DB errors.\n\t *\n\t * Default behavior is to show errors if both WP_DEBUG and WP_DEBUG_DISPLAY\n\t * evaluated to true.\n\t *\n\t * @since 0.71\n\t * @var bool\n\t */\n\tvar $show_errors = false;\n\n\t/**\n\t * Whether to suppress errors during the DB bootstrapping.\n\t *\n\t * @since 2.5.0\n\t * @var bool\n\t */\n\tvar $suppress_errors = false;\n\n\t/**\n\t * The last error during query.\n\t *\n\t * @since 2.5.0\n\t * @var string\n\t */\n\tpublic $last_error = '';\n\n\t/**\n\t * Amount of queries made\n\t *\n\t * @since 1.2.0\n\t * @var int\n\t */\n\tpublic $num_queries = 0;\n\n\t/**\n\t * Count of rows returned by previous query\n\t *\n\t * @since 0.71\n\t * @var int\n\t */\n\tpublic $num_rows = 0;\n\n\t/**\n\t * Count of affected rows by previous query\n\t *\n\t * @since 0.71\n\t * @var int\n\t */\n\tvar $rows_affected = 0;\n\n\t/**\n\t * The ID generated for an AUTO_INCREMENT column by the previous query (usually INSERT).\n\t *\n\t * @since 0.71\n\t * @var int\n\t */\n\tpublic $insert_id = 0;\n\n\t/**\n\t * Last query made\n\t *\n\t * @since 0.71\n\t * @var array\n\t */\n\tvar $last_query;\n\n\t/**\n\t * Results of the last query made\n\t *\n\t * @since 0.71\n\t * @var array|null\n\t */\n\tvar $last_result;\n\n\t/**\n\t * MySQL result, which is either a resource or boolean.\n\t *\n\t * @since 0.71\n\t * @var mixed\n\t */\n\tprotected $result;\n\n\t/**\n\t * Cached column info, for sanity checking data before inserting\n\t *\n\t * @since 4.2.0\n\t * @var array\n\t */\n\tprotected $col_meta = array();\n\n\t/**\n\t * Calculated character sets on tables\n\t *\n\t * @since 4.2.0\n\t * @var array\n\t */\n\tprotected $table_charset = array();\n\n\t/**\n\t * Whether text fields in the current query need to be sanity checked.\n\t *\n\t * @since 4.2.0\n\t * @var bool\n\t */\n\tprotected $check_current_query = true;\n\n\t/**\n\t * Flag to ensure we don't run into recursion problems when checking the collation.\n\t *\n\t * @since 4.2.0\n\t * @see wpdb::check_safe_collation()\n\t * @var bool\n\t */\n\tprivate $checking_collation = false;\n\n\t/**\n\t * Saved info on the table column\n\t *\n\t * @since 0.71\n\t * @var array\n\t */\n\tprotected $col_info;\n\n\t/**\n\t * Saved queries that were executed\n\t *\n\t * @since 1.5.0\n\t * @var array\n\t */\n\tvar $queries;\n\n\t/**\n\t * The number of times to retry reconnecting before dying.\n\t *\n\t * @since 3.9.0\n\t * @see wpdb::check_connection()\n\t * @var int\n\t */\n\tprotected $reconnect_retries = 5;\n\n\t/**\n\t * WordPress table prefix\n\t *\n\t * You can set this to have multiple WordPress installations\n\t * in a single database. The second reason is for possible\n\t * security precautions.\n\t *\n\t * @since 2.5.0\n\t * @var string\n\t */\n\tpublic $prefix = '';\n\n\t/**\n\t * WordPress base table prefix.\n\t *\n\t * @since 3.0.0\n\t * @var string\n\t */\n\t public $base_prefix;\n\n\t/**\n\t * Whether the database queries are ready to start executing.\n\t *\n\t * @since 2.3.2\n\t * @var bool\n\t */\n\tvar $ready = false;\n\n\t/**\n\t * Blog ID.\n\t *\n\t * @since 3.0.0\n\t * @var int\n\t */\n\tpublic $blogid = 0;\n\n\t/**\n\t * Site ID.\n\t *\n\t * @since 3.0.0\n\t * @var int\n\t */\n\tpublic $siteid = 0;\n\n\t/**\n\t * List of WordPress per-blog tables\n\t *\n\t * @since 2.5.0\n\t * @see wpdb::tables()\n\t * @var array\n\t */\n\tvar $tables = array( 'posts', 'comments', 'links', 'options', 'postmeta',\n\t\t'terms', 'term_taxonomy', 'term_relationships', 'termmeta', 'commentmeta' );\n\n\t/**\n\t * List of deprecated WordPress tables\n\t *\n\t * categories, post2cat, and link2cat were deprecated in 2.3.0, db version 5539\n\t *\n\t * @since 2.9.0\n\t * @see wpdb::tables()\n\t * @var array\n\t */\n\tvar $old_tables = array( 'categories', 'post2cat', 'link2cat' );\n\n\t/**\n\t * List of WordPress global tables\n\t *\n\t * @since 3.0.0\n\t * @see wpdb::tables()\n\t * @var array\n\t */\n\tvar $global_tables = array( 'users', 'usermeta' );\n\n\t/**\n\t * List of Multisite global tables\n\t *\n\t * @since 3.0.0\n\t * @see wpdb::tables()\n\t * @var array\n\t */\n\tvar $ms_global_tables = array( 'blogs', 'signups', 'site', 'sitemeta',\n\t\t'sitecategories', 'registration_log', 'blog_versions' );\n\n\t/**\n\t * WordPress Comments table\n\t *\n\t * @since 1.5.0\n\t * @var string\n\t */\n\tpublic $comments;\n\n\t/**\n\t * WordPress Comment Metadata table\n\t *\n\t * @since 2.9.0\n\t * @var string\n\t */\n\tpublic $commentmeta;\n\n\t/**\n\t * WordPress Links table\n\t *\n\t * @since 1.5.0\n\t * @var string\n\t */\n\tpublic $links;\n\n\t/**\n\t * WordPress Options table\n\t *\n\t * @since 1.5.0\n\t * @var string\n\t */\n\tpublic $options;\n\n\t/**\n\t * WordPress Post Metadata table\n\t *\n\t * @since 1.5.0\n\t * @var string\n\t */\n\tpublic $postmeta;\n\n\t/**\n\t * WordPress Posts table\n\t *\n\t * @since 1.5.0\n\t * @var string\n\t */\n\tpublic $posts;\n\n\t/**\n\t * WordPress Terms table\n\t *\n\t * @since 2.3.0\n\t * @var string\n\t */\n\tpublic $terms;\n\n\t/**\n\t * WordPress Term Relationships table\n\t *\n\t * @since 2.3.0\n\t * @var string\n\t */\n\tpublic $term_relationships;\n\n\t/**\n\t * WordPress Term Taxonomy table\n\t *\n\t * @since 2.3.0\n\t * @var string\n\t */\n\tpublic $term_taxonomy;\n\n\t/**\n\t * WordPress Term Meta table.\n\t *\n\t * @since 4.4.0\n\t * @var string\n\t */\n\tpublic $termmeta;\n\n\t//\n\t// Global and Multisite tables\n\t//\n\n\t/**\n\t * WordPress User Metadata table\n\t *\n\t * @since 2.3.0\n\t * @var string\n\t */\n\tpublic $usermeta;\n\n\t/**\n\t * WordPress Users table\n\t *\n\t * @since 1.5.0\n\t * @var string\n\t */\n\tpublic $users;\n\n\t/**\n\t * Multisite Blogs table\n\t *\n\t * @since 3.0.0\n\t * @var string\n\t */\n\tpublic $blogs;\n\n\t/**\n\t * Multisite Blog Versions table\n\t *\n\t * @since 3.0.0\n\t * @var string\n\t */\n\tpublic $blog_versions;\n\n\t/**\n\t * Multisite Registration Log table\n\t *\n\t * @since 3.0.0\n\t * @var string\n\t */\n\tpublic $registration_log;\n\n\t/**\n\t * Multisite Signups table\n\t *\n\t * @since 3.0.0\n\t * @var string\n\t */\n\tpublic $signups;\n\n\t/**\n\t * Multisite Sites table\n\t *\n\t * @since 3.0.0\n\t * @var string\n\t */\n\tpublic $site;\n\n\t/**\n\t * Multisite Sitewide Terms table\n\t *\n\t * @since 3.0.0\n\t * @var string\n\t */\n\tpublic $sitecategories;\n\n\t/**\n\t * Multisite Site Metadata table\n\t *\n\t * @since 3.0.0\n\t * @var string\n\t */\n\tpublic $sitemeta;\n\n\t/**\n\t * Format specifiers for DB columns. Columns not listed here default to %s. Initialized during WP load.\n\t *\n\t * Keys are column names, values are format types: 'ID' => '%d'\n\t *\n\t * @since 2.8.0\n\t * @see wpdb::prepare()\n\t * @see wpdb::insert()\n\t * @see wpdb::update()\n\t * @see wpdb::delete()\n\t * @see wp_set_wpdb_vars()\n\t * @var array\n\t */\n\tpublic $field_types = array();\n\n\t/**\n\t * Database table columns charset\n\t *\n\t * @since 2.2.0\n\t * @var string\n\t */\n\tpublic $charset;\n\n\t/**\n\t * Database table columns collate\n\t *\n\t * @since 2.2.0\n\t * @var string\n\t */\n\tpublic $collate;\n\n\t/**\n\t * Database Username\n\t *\n\t * @since 2.9.0\n\t * @var string\n\t */\n\tprotected $dbuser;\n\n\t/**\n\t * Database Password\n\t *\n\t * @since 3.1.0\n\t * @var string\n\t */\n\tprotected $dbpassword;\n\n\t/**\n\t * Database Name\n\t *\n\t * @since 3.1.0\n\t * @var string\n\t */\n\tprotected $dbname;\n\n\t/**\n\t * Database Host\n\t *\n\t * @since 3.1.0\n\t * @var string\n\t */\n\tprotected $dbhost;\n\n\t/**\n\t * Database Handle\n\t *\n\t * @since 0.71\n\t * @var string\n\t */\n\tprotected $dbh;\n\n\t/**\n\t * A textual description of the last query/get_row/get_var call\n\t *\n\t * @since 3.0.0\n\t * @var string\n\t */\n\tpublic $func_call;\n\n\t/**\n\t * Whether MySQL is used as the database engine.\n\t *\n\t * Set in WPDB::db_connect() to true, by default. This is used when checking\n\t * against the required MySQL version for WordPress. Normally, a replacement\n\t * database drop-in (db.php) will skip these checks, but setting this to true\n\t * will force the checks to occur.\n\t *\n\t * @since 3.3.0\n\t * @var bool\n\t */\n\tpublic $is_mysql = null;\n\n\t/**\n\t * A list of incompatible SQL modes.\n\t *\n\t * @since 3.9.0\n\t * @var array\n\t */\n\tprotected $incompatible_modes = array( 'NO_ZERO_DATE', 'ONLY_FULL_GROUP_BY',\n\t\t'STRICT_TRANS_TABLES', 'STRICT_ALL_TABLES', 'TRADITIONAL' );\n\n\t/**\n\t * Whether to use mysqli over mysql.\n\t *\n\t * @since 3.9.0\n\t * @var bool\n\t */\n\tprivate $use_mysqli = false;\n\n\t/**\n\t * Whether we've managed to successfully connect at some point\n\t *\n\t * @since 3.9.0\n\t * @var bool\n\t */\n\tprivate $has_connected = false;\n\n\t/**\n\t * Connects to the database server and selects a database\n\t *\n\t * PHP5 style constructor for compatibility with PHP5. Does\n\t * the actual setting up of the class properties and connection\n\t * to the database.\n\t *\n\t * @link https://core.trac.wordpress.org/ticket/3354\n\t * @since 2.0.8\n\t *\n\t * @global string $wp_version\n\t *\n\t * @param string $dbuser     MySQL database user\n\t * @param string $dbpassword MySQL database password\n\t * @param string $dbname     MySQL database name\n\t * @param string $dbhost     MySQL database host\n\t */\n\tpublic function __construct( $dbuser, $dbpassword, $dbname, $dbhost ) {\n\t\tregister_shutdown_function( array( $this, '__destruct' ) );\n\n\t\tif ( WP_DEBUG && WP_DEBUG_DISPLAY )\n\t\t\t$this->show_errors();\n\n\t\t/* Use ext/mysqli if it exists and:\n\t\t *  - WP_USE_EXT_MYSQL is defined as false, or\n\t\t *  - We are a development version of WordPress, or\n\t\t *  - We are running PHP 5.5 or greater, or\n\t\t *  - ext/mysql is not loaded.\n\t\t */\n\t\tif ( function_exists( 'mysqli_connect' ) ) {\n\t\t\tif ( defined( 'WP_USE_EXT_MYSQL' ) ) {\n\t\t\t\t$this->use_mysqli = ! WP_USE_EXT_MYSQL;\n\t\t\t} elseif ( version_compare( phpversion(), '5.5', '>=' ) || ! function_exists( 'mysql_connect' ) ) {\n\t\t\t\t$this->use_mysqli = true;\n\t\t\t} elseif ( false !== strpos( $GLOBALS['wp_version'], '-' ) ) {\n\t\t\t\t$this->use_mysqli = true;\n\t\t\t}\n\t\t}\n\n\t\t$this->dbuser = $dbuser;\n\t\t$this->dbpassword = $dbpassword;\n\t\t$this->dbname = $dbname;\n\t\t$this->dbhost = $dbhost;\n\n\t\t// wp-config.php creation will manually connect when ready.\n\t\tif ( defined( 'WP_SETUP_CONFIG' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t$this->db_connect();\n\t}\n\n\t/**\n\t * PHP5 style destructor and will run when database object is destroyed.\n\t *\n\t * @see wpdb::__construct()\n\t * @since 2.0.8\n\t * @return true\n\t */\n\tpublic function __destruct() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Makes private properties readable for backward compatibility.\n\t *\n\t * @since 3.5.0\n\t *\n\t * @param string $name The private member to get, and optionally process\n\t * @return mixed The private member\n\t */\n\tpublic function __get( $name ) {\n\t\tif ( 'col_info' === $name )\n\t\t\t$this->load_col_info();\n\n\t\treturn $this->$name;\n\t}\n\n\t/**\n\t * Makes private properties settable for backward compatibility.\n\t *\n\t * @since 3.5.0\n\t *\n\t * @param string $name  The private member to set\n\t * @param mixed  $value The value to set\n\t */\n\tpublic function __set( $name, $value ) {\n\t\t$protected_members = array(\n\t\t\t'col_meta',\n\t\t\t'table_charset',\n\t\t\t'check_current_query',\n\t\t);\n\t\tif (  in_array( $name, $protected_members, true ) ) {\n\t\t\treturn;\n\t\t}\n\t\t$this->$name = $value;\n\t}\n\n\t/**\n\t * Makes private properties check-able for backward compatibility.\n\t *\n\t * @since 3.5.0\n\t *\n\t * @param string $name  The private member to check\n\t *\n\t * @return bool If the member is set or not\n\t */\n\tpublic function __isset( $name ) {\n\t\treturn isset( $this->$name );\n\t}\n\n\t/**\n\t * Makes private properties un-settable for backward compatibility.\n\t *\n\t * @since 3.5.0\n\t *\n\t * @param string $name  The private member to unset\n\t */\n\tpublic function __unset( $name ) {\n\t\tunset( $this->$name );\n\t}\n\n\t/**\n\t * Set $this->charset and $this->collate\n\t *\n\t * @since 3.1.0\n\t */\n\tpublic function init_charset() {\n\t\t$charset = '';\n\t\t$collate = '';\n\n\t\tif ( function_exists('is_multisite') && is_multisite() ) {\n\t\t\t$charset = 'utf8';\n\t\t\tif ( defined( 'DB_COLLATE' ) && DB_COLLATE ) {\n\t\t\t\t$collate = DB_COLLATE;\n\t\t\t} else {\n\t\t\t\t$collate = 'utf8_general_ci';\n\t\t\t}\n\t\t} elseif ( defined( 'DB_COLLATE' ) ) {\n\t\t\t$collate = DB_COLLATE;\n\t\t}\n\n\t\tif ( defined( 'DB_CHARSET' ) ) {\n\t\t\t$charset = DB_CHARSET;\n\t\t}\n\n\t\t$charset_collate = $this->determine_charset( $charset, $collate );\n\n\t\t$this->charset = $charset_collate['charset'];\n\t\t$this->collate = $charset_collate['collate'];\n\t}\n\n\t/**\n\t * Determines the best charset and collation to use given a charset and collation.\n\t *\n\t * For example, when able, utf8mb4 should be used instead of utf8.\n\t *\n\t * @since 4.6.0\n\t *\n\t * @param string $charset The character set to check.\n\t * @param string $collate The collation to check.\n\t * @return array The most appropriate character set and collation to use.\n\t */\n\tpublic function determine_charset( $charset, $collate ) {\n\t\tif ( ( $this->use_mysqli && ! ( $this->dbh instanceof mysqli ) ) || empty( $this->dbh ) ) {\n\t\t\treturn compact( 'charset', 'collate' );\n\t\t}\n\n\t\tif ( 'utf8' === $charset && $this->has_cap( 'utf8mb4' ) ) {\n\t\t\t$charset = 'utf8mb4';\n\t\t}\n\n\t\tif ( 'utf8mb4' === $charset && ! $this->has_cap( 'utf8mb4' ) ) {\n\t\t\t$charset = 'utf8';\n\t\t\t$collate = str_replace( 'utf8mb4_', 'utf8_', $collate );\n\t\t}\n\n\t\tif ( 'utf8mb4' === $charset ) {\n\t\t\t// _general_ is outdated, so we can upgrade it to _unicode_, instead.\n\t\t\tif ( ! $collate || 'utf8_general_ci' === $collate ) {\n\t\t\t\t$collate = 'utf8mb4_unicode_ci';\n\t\t\t} else {\n\t\t\t\t$collate = str_replace( 'utf8_', 'utf8mb4_', $collate );\n\t\t\t}\n\t\t}\n\n\t\t// _unicode_520_ is a better collation, we should use that when it's available.\n\t\tif ( $this->has_cap( 'utf8mb4_520' ) && 'utf8mb4_unicode_ci' === $collate ) {\n\t\t\t$collate = 'utf8mb4_unicode_520_ci';\n\t\t}\n\n\t\treturn compact( 'charset', 'collate' );\n\t}\n\n\t/**\n\t * Sets the connection's character set.\n\t *\n\t * @since 3.1.0\n\t *\n\t * @param resource $dbh     The resource given by mysql_connect\n\t * @param string   $charset Optional. The character set. Default null.\n\t * @param string   $collate Optional. The collation. Default null.\n\t */\n\tpublic function set_charset( $dbh, $charset = null, $collate = null ) {\n\t\tif ( ! isset( $charset ) )\n\t\t\t$charset = $this->charset;\n\t\tif ( ! isset( $collate ) )\n\t\t\t$collate = $this->collate;\n\t\tif ( $this->has_cap( 'collation' ) && ! empty( $charset ) ) {\n\t\t\t$set_charset_succeeded = true;\n\n\t\t\tif ( $this->use_mysqli ) {\n\t\t\t\tif ( function_exists( 'mysqli_set_charset' ) && $this->has_cap( 'set_charset' ) ) {\n\t\t\t\t\t$set_charset_succeeded = mysqli_set_charset( $dbh, $charset );\n\t\t\t\t}\n\n\t\t\t\tif ( $set_charset_succeeded ) {\n\t\t\t\t\t$query = $this->prepare( 'SET NAMES %s', $charset );\n\t\t\t\t\tif ( ! empty( $collate ) )\n\t\t\t\t\t\t$query .= $this->prepare( ' COLLATE %s', $collate );\n\t\t\t\t\tmysqli_query( $dbh, $query );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ( function_exists( 'mysql_set_charset' ) && $this->has_cap( 'set_charset' ) ) {\n\t\t\t\t\t$set_charset_succeeded = mysql_set_charset( $charset, $dbh );\n\t\t\t\t}\n\t\t\t\tif ( $set_charset_succeeded ) {\n\t\t\t\t\t$query = $this->prepare( 'SET NAMES %s', $charset );\n\t\t\t\t\tif ( ! empty( $collate ) )\n\t\t\t\t\t\t$query .= $this->prepare( ' COLLATE %s', $collate );\n\t\t\t\t\tmysql_query( $query, $dbh );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Change the current SQL mode, and ensure its WordPress compatibility.\n\t *\n\t * If no modes are passed, it will ensure the current MySQL server\n\t * modes are compatible.\n\t *\n\t * @since 3.9.0\n\t *\n\t * @param array $modes Optional. A list of SQL modes to set.\n\t */\n\tpublic function set_sql_mode( $modes = array() ) {\n\t\tif ( empty( $modes ) ) {\n\t\t\tif ( $this->use_mysqli ) {\n\t\t\t\t$res = mysqli_query( $this->dbh, 'SELECT @@SESSION.sql_mode' );\n\t\t\t} else {\n\t\t\t\t$res = mysql_query( 'SELECT @@SESSION.sql_mode', $this->dbh );\n\t\t\t}\n\n\t\t\tif ( empty( $res ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( $this->use_mysqli ) {\n\t\t\t\t$modes_array = mysqli_fetch_array( $res );\n\t\t\t\tif ( empty( $modes_array[0] ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t$modes_str = $modes_array[0];\n\t\t\t} else {\n\t\t\t\t$modes_str = mysql_result( $res, 0 );\n\t\t\t}\n\n\t\t\tif ( empty( $modes_str ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t$modes = explode( ',', $modes_str );\n\t\t}\n\n\t\t$modes = array_change_key_case( $modes, CASE_UPPER );\n\n\t\t/**\n\t\t * Filters the list of incompatible SQL modes to exclude.\n\t\t *\n\t\t * @since 3.9.0\n\t\t *\n\t\t * @param array $incompatible_modes An array of incompatible modes.\n\t\t */\n\t\t$incompatible_modes = (array) apply_filters( 'incompatible_sql_modes', $this->incompatible_modes );\n\n\t\tforeach ( $modes as $i => $mode ) {\n\t\t\tif ( in_array( $mode, $incompatible_modes ) ) {\n\t\t\t\tunset( $modes[ $i ] );\n\t\t\t}\n\t\t}\n\n\t\t$modes_str = implode( ',', $modes );\n\n\t\tif ( $this->use_mysqli ) {\n\t\t\tmysqli_query( $this->dbh, \"SET SESSION sql_mode='$modes_str'\" );\n\t\t} else {\n\t\t\tmysql_query( \"SET SESSION sql_mode='$modes_str'\", $this->dbh );\n\t\t}\n\t}\n\n\t/**\n\t * Sets the table prefix for the WordPress tables.\n\t *\n\t * @since 2.5.0\n\t *\n\t * @param string $prefix          Alphanumeric name for the new prefix.\n\t * @param bool   $set_table_names Optional. Whether the table names, e.g. wpdb::$posts, should be updated or not.\n\t * @return string|WP_Error Old prefix or WP_Error on error\n\t */\n\tpublic function set_prefix( $prefix, $set_table_names = true ) {\n\n\t\tif ( preg_match( '|[^a-z0-9_]|i', $prefix ) )\n\t\t\treturn new WP_Error('invalid_db_prefix', 'Invalid database prefix' );\n\n\t\t$old_prefix = is_multisite() ? '' : $prefix;\n\n\t\tif ( isset( $this->base_prefix ) )\n\t\t\t$old_prefix = $this->base_prefix;\n\n\t\t$this->base_prefix = $prefix;\n\n\t\tif ( $set_table_names ) {\n\t\t\tforeach ( $this->tables( 'global' ) as $table => $prefixed_table )\n\t\t\t\t$this->$table = $prefixed_table;\n\n\t\t\tif ( is_multisite() && empty( $this->blogid ) )\n\t\t\t\treturn $old_prefix;\n\n\t\t\t$this->prefix = $this->get_blog_prefix();\n\n\t\t\tforeach ( $this->tables( 'blog' ) as $table => $prefixed_table )\n\t\t\t\t$this->$table = $prefixed_table;\n\n\t\t\tforeach ( $this->tables( 'old' ) as $table => $prefixed_table )\n\t\t\t\t$this->$table = $prefixed_table;\n\t\t}\n\t\treturn $old_prefix;\n\t}\n\n\t/**\n\t * Sets blog id.\n\t *\n\t * @since 3.0.0\n\t *\n\t * @param int $blog_id\n\t * @param int $network_id Optional.\n\t * @return int previous blog id\n\t */\n\tpublic function set_blog_id( $blog_id, $network_id = 0 ) {\n\t\tif ( ! empty( $network_id ) ) {\n\t\t\t$this->siteid = $network_id;\n\t\t}\n\n\t\t$old_blog_id  = $this->blogid;\n\t\t$this->blogid = $blog_id;\n\n\t\t$this->prefix = $this->get_blog_prefix();\n\n\t\tforeach ( $this->tables( 'blog' ) as $table => $prefixed_table )\n\t\t\t$this->$table = $prefixed_table;\n\n\t\tforeach ( $this->tables( 'old' ) as $table => $prefixed_table )\n\t\t\t$this->$table = $prefixed_table;\n\n\t\treturn $old_blog_id;\n\t}\n\n\t/**\n\t * Gets blog prefix.\n\t *\n\t * @since 3.0.0\n\t * @param int $blog_id Optional.\n\t * @return string Blog prefix.\n\t */\n\tpublic function get_blog_prefix( $blog_id = null ) {\n\t\tif ( is_multisite() ) {\n\t\t\tif ( null === $blog_id )\n\t\t\t\t$blog_id = $this->blogid;\n\t\t\t$blog_id = (int) $blog_id;\n\t\t\tif ( defined( 'MULTISITE' ) && ( 0 == $blog_id || 1 == $blog_id ) )\n\t\t\t\treturn $this->base_prefix;\n\t\t\telse\n\t\t\t\treturn $this->base_prefix . $blog_id . '_';\n\t\t} else {\n\t\t\treturn $this->base_prefix;\n\t\t}\n\t}\n\n\t/**\n\t * Returns an array of WordPress tables.\n\t *\n\t * Also allows for the CUSTOM_USER_TABLE and CUSTOM_USER_META_TABLE to\n\t * override the WordPress users and usermeta tables that would otherwise\n\t * be determined by the prefix.\n\t *\n\t * The scope argument can take one of the following:\n\t *\n\t * 'all' - returns 'all' and 'global' tables. No old tables are returned.\n\t * 'blog' - returns the blog-level tables for the queried blog.\n\t * 'global' - returns the global tables for the installation, returning multisite tables only if running multisite.\n\t * 'ms_global' - returns the multisite global tables, regardless if current installation is multisite.\n\t * 'old' - returns tables which are deprecated.\n\t *\n\t * @since 3.0.0\n\t * @uses wpdb::$tables\n\t * @uses wpdb::$old_tables\n\t * @uses wpdb::$global_tables\n\t * @uses wpdb::$ms_global_tables\n\t *\n\t * @param string $scope   Optional. Can be all, global, ms_global, blog, or old tables. Defaults to all.\n\t * @param bool   $prefix  Optional. Whether to include table prefixes. Default true. If blog\n\t *                        prefix is requested, then the custom users and usermeta tables will be mapped.\n\t * @param int    $blog_id Optional. The blog_id to prefix. Defaults to wpdb::$blogid. Used only when prefix is requested.\n\t * @return array Table names. When a prefix is requested, the key is the unprefixed table name.\n\t */\n\tpublic function tables( $scope = 'all', $prefix = true, $blog_id = 0 ) {\n\t\tswitch ( $scope ) {\n\t\t\tcase 'all' :\n\t\t\t\t$tables = array_merge( $this->global_tables, $this->tables );\n\t\t\t\tif ( is_multisite() )\n\t\t\t\t\t$tables = array_merge( $tables, $this->ms_global_tables );\n\t\t\t\tbreak;\n\t\t\tcase 'blog' :\n\t\t\t\t$tables = $this->tables;\n\t\t\t\tbreak;\n\t\t\tcase 'global' :\n\t\t\t\t$tables = $this->global_tables;\n\t\t\t\tif ( is_multisite() )\n\t\t\t\t\t$tables = array_merge( $tables, $this->ms_global_tables );\n\t\t\t\tbreak;\n\t\t\tcase 'ms_global' :\n\t\t\t\t$tables = $this->ms_global_tables;\n\t\t\t\tbreak;\n\t\t\tcase 'old' :\n\t\t\t\t$tables = $this->old_tables;\n\t\t\t\tbreak;\n\t\t\tdefault :\n\t\t\t\treturn array();\n\t\t}\n\n\t\tif ( $prefix ) {\n\t\t\tif ( ! $blog_id )\n\t\t\t\t$blog_id = $this->blogid;\n\t\t\t$blog_prefix = $this->get_blog_prefix( $blog_id );\n\t\t\t$base_prefix = $this->base_prefix;\n\t\t\t$global_tables = array_merge( $this->global_tables, $this->ms_global_tables );\n\t\t\tforeach ( $tables as $k => $table ) {\n\t\t\t\tif ( in_array( $table, $global_tables ) )\n\t\t\t\t\t$tables[ $table ] = $base_prefix . $table;\n\t\t\t\telse\n\t\t\t\t\t$tables[ $table ] = $blog_prefix . $table;\n\t\t\t\tunset( $tables[ $k ] );\n\t\t\t}\n\n\t\t\tif ( isset( $tables['users'] ) && defined( 'CUSTOM_USER_TABLE' ) )\n\t\t\t\t$tables['users'] = CUSTOM_USER_TABLE;\n\n\t\t\tif ( isset( $tables['usermeta'] ) && defined( 'CUSTOM_USER_META_TABLE' ) )\n\t\t\t\t$tables['usermeta'] = CUSTOM_USER_META_TABLE;\n\t\t}\n\n\t\treturn $tables;\n\t}\n\n\t/**\n\t * Selects a database using the current database connection.\n\t *\n\t * The database name will be changed based on the current database\n\t * connection. On failure, the execution will bail and display an DB error.\n\t *\n\t * @since 0.71\n\t *\n\t * @param string        $db  MySQL database name\n\t * @param resource|null $dbh Optional link identifier.\n\t */\n\tpublic function select( $db, $dbh = null ) {\n\t\tif ( is_null($dbh) )\n\t\t\t$dbh = $this->dbh;\n\n\t\tif ( $this->use_mysqli ) {\n\t\t\t$success = mysqli_select_db( $dbh, $db );\n\t\t} else {\n\t\t\t$success = mysql_select_db( $db, $dbh );\n\t\t}\n\t\tif ( ! $success ) {\n\t\t\t$this->ready = false;\n\t\t\tif ( ! did_action( 'template_redirect' ) ) {\n\t\t\t\twp_load_translations_early();\n\n\t\t\t\t$message = '<h1>' . __( 'Can&#8217;t select database' ) . \"</h1>\\n\";\n\n\t\t\t\t$message .= '<p>' . sprintf(\n\t\t\t\t\t/* translators: %s: database name */\n\t\t\t\t\t__( 'We were able to connect to the database server (which means your username and password is okay) but not able to select the %s database.' ),\n\t\t\t\t\t'<code>' . htmlspecialchars( $db, ENT_QUOTES ) . '</code>'\n\t\t\t\t) . \"</p>\\n\";\n\n\t\t\t\t$message .= \"<ul>\\n\";\n\t\t\t\t$message .= '<li>' . __( 'Are you sure it exists?' ) . \"</li>\\n\";\n\n\t\t\t\t$message .= '<li>' . sprintf(\n\t\t\t\t\t/* translators: 1: database user, 2: database name */\n\t\t\t\t\t__( 'Does the user %1$s have permission to use the %2$s database?' ),\n\t\t\t\t\t'<code>' . htmlspecialchars( $this->dbuser, ENT_QUOTES )  . '</code>',\n\t\t\t\t\t'<code>' . htmlspecialchars( $db, ENT_QUOTES ) . '</code>'\n\t\t\t\t) . \"</li>\\n\";\n\n\t\t\t\t$message .= '<li>' . sprintf(\n\t\t\t\t\t/* translators: %s: database name */\n\t\t\t\t\t__( 'On some systems the name of your database is prefixed with your username, so it would be like <code>username_%1$s</code>. Could that be the problem?' ),\n\t\t\t\t\thtmlspecialchars( $db, ENT_QUOTES )\n\t\t\t\t). \"</li>\\n\";\n\n\t\t\t\t$message .= \"</ul>\\n\";\n\n\t\t\t\t$message .= '<p>' . sprintf(\n\t\t\t\t\t/* translators: %s: support forums URL */\n\t\t\t\t\t__( 'If you don&#8217;t know how to set up a database you should <strong>contact your host</strong>. If all else fails you may find help at the <a href=\"%s\">WordPress Support Forums</a>.' ),\n\t\t\t\t\t__( 'https://wordpress.org/support/' )\n\t\t\t\t) . \"</p>\\n\";\n\n\t\t\t\t$this->bail( $message, 'db_select_fail' );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Do not use, deprecated.\n\t *\n\t * Use esc_sql() or wpdb::prepare() instead.\n\t *\n\t * @since 2.8.0\n\t * @deprecated 3.6.0 Use wpdb::prepare()\n\t * @see wpdb::prepare\n\t * @see esc_sql()\n\t *\n\t * @param string $string\n\t * @return string\n\t */\n\tfunction _weak_escape( $string ) {\n\t\tif ( func_num_args() === 1 && function_exists( '_deprecated_function' ) )\n\t\t\t_deprecated_function( __METHOD__, '3.6.0', 'wpdb::prepare() or esc_sql()' );\n\t\treturn addslashes( $string );\n\t}\n\n\t/**\n\t * Real escape, using mysqli_real_escape_string() or mysql_real_escape_string()\n\t *\n\t * @see mysqli_real_escape_string()\n\t * @see mysql_real_escape_string()\n\t * @since 2.8.0\n\t *\n\t * @param  string $string to escape\n\t * @return string escaped\n\t */\n\tfunction _real_escape( $string ) {\n\t\tif ( $this->dbh ) {\n\t\t\tif ( $this->use_mysqli ) {\n\t\t\t\treturn mysqli_real_escape_string( $this->dbh, $string );\n\t\t\t} else {\n\t\t\t\treturn mysql_real_escape_string( $string, $this->dbh );\n\t\t\t}\n\t\t}\n\n\t\t$class = get_class( $this );\n\t\tif ( function_exists( '__' ) ) {\n\t\t\t/* translators: %s: database access abstraction class, usually wpdb or a class extending wpdb */\n\t\t\t_doing_it_wrong( $class, sprintf( __( '%s must set a database connection for use with escaping.' ), $class ), '3.6.0' );\n\t\t} else {\n\t\t\t_doing_it_wrong( $class, sprintf( '%s must set a database connection for use with escaping.', $class ), '3.6.0' );\n\t\t}\n\t\treturn addslashes( $string );\n\t}\n\n\t/**\n\t * Escape data. Works on arrays.\n\t *\n\t * @uses wpdb::_real_escape()\n\t * @since  2.8.0\n\t *\n\t * @param  string|array $data\n\t * @return string|array escaped\n\t */\n\tpublic function _escape( $data ) {\n\t\tif ( is_array( $data ) ) {\n\t\t\tforeach ( $data as $k => $v ) {\n\t\t\t\tif ( is_array( $v ) ) {\n\t\t\t\t\t$data[$k] = $this->_escape( $v );\n\t\t\t\t} else {\n\t\t\t\t\t$data[$k] = $this->_real_escape( $v );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t$data = $this->_real_escape( $data );\n\t\t}\n\n\t\treturn $data;\n\t}\n\n\t/**\n\t * Do not use, deprecated.\n\t *\n\t * Use esc_sql() or wpdb::prepare() instead.\n\t *\n\t * @since 0.71\n\t * @deprecated 3.6.0 Use wpdb::prepare()\n\t * @see wpdb::prepare()\n\t * @see esc_sql()\n\t *\n\t * @param mixed $data\n\t * @return mixed\n\t */\n\tpublic function escape( $data ) {\n\t\tif ( func_num_args() === 1 && function_exists( '_deprecated_function' ) )\n\t\t\t_deprecated_function( __METHOD__, '3.6.0', 'wpdb::prepare() or esc_sql()' );\n\t\tif ( is_array( $data ) ) {\n\t\t\tforeach ( $data as $k => $v ) {\n\t\t\t\tif ( is_array( $v ) )\n\t\t\t\t\t$data[$k] = $this->escape( $v, 'recursive' );\n\t\t\t\telse\n\t\t\t\t\t$data[$k] = $this->_weak_escape( $v, 'internal' );\n\t\t\t}\n\t\t} else {\n\t\t\t$data = $this->_weak_escape( $data, 'internal' );\n\t\t}\n\n\t\treturn $data;\n\t}\n\n\t/**\n\t * Escapes content by reference for insertion into the database, for security\n\t *\n\t * @uses wpdb::_real_escape()\n\t *\n\t * @since 2.3.0\n\t *\n\t * @param string $string to escape\n\t */\n\tpublic function escape_by_ref( &$string ) {\n\t\tif ( ! is_float( $string ) )\n\t\t\t$string = $this->_real_escape( $string );\n\t}\n\n\t/**\n\t * Prepares a SQL query for safe execution. Uses sprintf()-like syntax.\n\t *\n\t * The following directives can be used in the query format string:\n\t *   %d (integer)\n\t *   %f (float)\n\t *   %s (string)\n\t *   %% (literal percentage sign - no argument needed)\n\t *\n\t * All of %d, %f, and %s are to be left unquoted in the query string and they need an argument passed for them.\n\t * Literals (%) as parts of the query must be properly written as %%.\n\t *\n\t * This function only supports a small subset of the sprintf syntax; it only supports %d (integer), %f (float), and %s (string).\n\t * Does not support sign, padding, alignment, width or precision specifiers.\n\t * Does not support argument numbering/swapping.\n\t *\n\t * May be called like {@link https://secure.php.net/sprintf sprintf()} or like {@link https://secure.php.net/vsprintf vsprintf()}.\n\t *\n\t * Both %d and %s should be left unquoted in the query string.\n\t *\n\t *     $wpdb->prepare( \"SELECT * FROM `table` WHERE `column` = %s AND `field` = %d\", 'foo', 1337 );\n\t *     $wpdb->prepare( \"SELECT DATE_FORMAT(`field`, '%%c') FROM `table` WHERE `column` = %s\", 'foo' );\n\t *\n\t * @link https://secure.php.net/sprintf Description of syntax.\n\t * @since 2.3.0\n\t *\n\t * @param string      $query    Query statement with sprintf()-like placeholders\n\t * @param array|mixed $args     The array of variables to substitute into the query's placeholders if being called like\n\t *                              {@link https://secure.php.net/vsprintf vsprintf()}, or the first variable to substitute into the query's placeholders if\n\t *                              being called like {@link https://secure.php.net/sprintf sprintf()}.\n\t * @param mixed       $args,... further variables to substitute into the query's placeholders if being called like\n\t *                              {@link https://secure.php.net/sprintf sprintf()}.\n\t * @return string|void Sanitized query string, if there is a query to prepare.\n\t */\n\tpublic function prepare( $query, $args ) {\n\t\tif ( is_null( $query ) )\n\t\t\treturn;\n\n\t\t// This is not meant to be foolproof -- but it will catch obviously incorrect usage.\n\t\tif ( strpos( $query, '%' ) === false ) {\n\t\t\t_doing_it_wrong( 'wpdb::prepare', sprintf( __( 'The query argument of %s must have a placeholder.' ), 'wpdb::prepare()' ), '3.9.0' );\n\t\t}\n\n\t\t$args = func_get_args();\n\t\tarray_shift( $args );\n\n\t\t// If args were passed as an array (as in vsprintf), move them up\n\t\tif ( is_array( $args[0] ) && count( $args ) == 1 ) {\n\t\t\t$args = $args[0];\n\t\t}\n\n\t\tforeach ( $args as $arg ) {\n\t\t\tif ( ! is_scalar( $arg ) ) {\n\t\t\t\t_doing_it_wrong( 'wpdb::prepare', sprintf( __( 'Unsupported value type (%s).' ), gettype( $arg ) ), '4.8.2' );\n\t\t\t}\n\t\t}\n\n\t\t$query = str_replace( \"'%s'\", '%s', $query ); // in case someone mistakenly already singlequoted it\n\t\t$query = str_replace( '\"%s\"', '%s', $query ); // doublequote unquoting\n\t\t$query = preg_replace( '|(?<!%)%f|' , '%F', $query ); // Force floats to be locale unaware\n\t\t$query = preg_replace( '|(?<!%)%s|', \"'%s'\", $query ); // quote the strings, avoiding escaped strings like %%s\n\t\tarray_walk( $args, array( $this, 'escape_by_ref' ) );\n\t\treturn @vsprintf( $query, $args );\n\t}\n\n\t/**\n\t * First half of escaping for LIKE special characters % and _ before preparing for MySQL.\n\t *\n\t * Use this only before wpdb::prepare() or esc_sql().  Reversing the order is very bad for security.\n\t *\n\t * Example Prepared Statement:\n\t *\n\t *     $wild = '%';\n\t *     $find = 'only 43% of planets';\n\t *     $like = $wild . $wpdb->esc_like( $find ) . $wild;\n\t *     $sql  = $wpdb->prepare( \"SELECT * FROM $wpdb->posts WHERE post_content LIKE '%s'\", $like );\n\t *\n\t * Example Escape Chain:\n\t *\n\t *     $sql  = esc_sql( $wpdb->esc_like( $input ) );\n\t *\n\t * @since 4.0.0\n\t *\n\t * @param string $text The raw text to be escaped. The input typed by the user should have no\n\t *                     extra or deleted slashes.\n\t * @return string Text in the form of a LIKE phrase. The output is not SQL safe. Call $wpdb::prepare()\n\t *                or real_escape next.\n\t */\n\tpublic function esc_like( $text ) {\n\t\treturn addcslashes( $text, '_%\\\\' );\n\t}\n\n\t/**\n\t * Print SQL/DB error.\n\t *\n\t * @since 0.71\n\t * @global array $EZSQL_ERROR Stores error information of query and error string\n\t *\n\t * @param string $str The error to display\n\t * @return false|void False if the showing of errors is disabled.\n\t */\n\tpublic function print_error( $str = '' ) {\n\t\tglobal $EZSQL_ERROR;\n\n\t\tif ( !$str ) {\n\t\t\tif ( $this->use_mysqli ) {\n\t\t\t\t$str = mysqli_error( $this->dbh );\n\t\t\t} else {\n\t\t\t\t$str = mysql_error( $this->dbh );\n\t\t\t}\n\t\t}\n\t\t$EZSQL_ERROR[] = array( 'query' => $this->last_query, 'error_str' => $str );\n\n\t\tif ( $this->suppress_errors )\n\t\t\treturn false;\n\n\t\twp_load_translations_early();\n\n\t\tif ( $caller = $this->get_caller() ) {\n\t\t\t/* translators: 1: Database error message, 2: SQL query, 3: Name of the calling function */\n\t\t\t$error_str = sprintf( __( 'WordPress database error %1$s for query %2$s made by %3$s' ), $str, $this->last_query, $caller );\n\t\t} else {\n\t\t\t/* translators: 1: Database error message, 2: SQL query */\n\t\t\t$error_str = sprintf( __( 'WordPress database error %1$s for query %2$s' ), $str, $this->last_query );\n\t\t}\n\n\t\terror_log( $error_str );\n\n\t\t// Are we showing errors?\n\t\tif ( ! $this->show_errors )\n\t\t\treturn false;\n\n\t\t// If there is an error then take note of it\n\t\tif ( is_multisite() ) {\n\t\t\t$msg = sprintf(\n\t\t\t\t\"%s [%s]\\n%s\\n\",\n\t\t\t\t__( 'WordPress database error:' ),\n\t\t\t\t$str,\n\t\t\t\t$this->last_query\n\t\t\t);\n\n\t\t\tif ( defined( 'ERRORLOGFILE' ) ) {\n\t\t\t\terror_log( $msg, 3, ERRORLOGFILE );\n\t\t\t}\n\t\t\tif ( defined( 'DIEONDBERROR' ) ) {\n\t\t\t\twp_die( $msg );\n\t\t\t}\n\t\t} else {\n\t\t\t$str   = htmlspecialchars( $str, ENT_QUOTES );\n\t\t\t$query = htmlspecialchars( $this->last_query, ENT_QUOTES );\n\n\t\t\tprintf(\n\t\t\t\t'<div id=\"error\"><p class=\"wpdberror\"><strong>%s</strong> [%s]<br /><code>%s</code></p></div>',\n\t\t\t\t__( 'WordPress database error:' ),\n\t\t\t\t$str,\n\t\t\t\t$query\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Enables showing of database errors.\n\t *\n\t * This function should be used only to enable showing of errors.\n\t * wpdb::hide_errors() should be used instead for hiding of errors. However,\n\t * this function can be used to enable and disable showing of database\n\t * errors.\n\t *\n\t * @since 0.71\n\t * @see wpdb::hide_errors()\n\t *\n\t * @param bool $show Whether to show or hide errors\n\t * @return bool Old value for showing errors.\n\t */\n\tpublic function show_errors( $show = true ) {\n\t\t$errors = $this->show_errors;\n\t\t$this->show_errors = $show;\n\t\treturn $errors;\n\t}\n\n\t/**\n\t * Disables showing of database errors.\n\t *\n\t * By default database errors are not shown.\n\t *\n\t * @since 0.71\n\t * @see wpdb::show_errors()\n\t *\n\t * @return bool Whether showing of errors was active\n\t */\n\tpublic function hide_errors() {\n\t\t$show = $this->show_errors;\n\t\t$this->show_errors = false;\n\t\treturn $show;\n\t}\n\n\t/**\n\t * Whether to suppress database errors.\n\t *\n\t * By default database errors are suppressed, with a simple\n\t * call to this function they can be enabled.\n\t *\n\t * @since 2.5.0\n\t * @see wpdb::hide_errors()\n\t * @param bool $suppress Optional. New value. Defaults to true.\n\t * @return bool Old value\n\t */\n\tpublic function suppress_errors( $suppress = true ) {\n\t\t$errors = $this->suppress_errors;\n\t\t$this->suppress_errors = (bool) $suppress;\n\t\treturn $errors;\n\t}\n\n\t/**\n\t * Kill cached query results.\n\t *\n\t * @since 0.71\n\t */\n\tpublic function flush() {\n\t\t$this->last_result = array();\n\t\t$this->col_info    = null;\n\t\t$this->last_query  = null;\n\t\t$this->rows_affected = $this->num_rows = 0;\n\t\t$this->last_error  = '';\n\n\t\tif ( $this->use_mysqli && $this->result instanceof mysqli_result ) {\n\t\t\tmysqli_free_result( $this->result );\n\t\t\t$this->result = null;\n\n\t\t\t// Sanity check before using the handle\n\t\t\tif ( empty( $this->dbh ) || !( $this->dbh instanceof mysqli ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Clear out any results from a multi-query\n\t\t\twhile ( mysqli_more_results( $this->dbh ) ) {\n\t\t\t\tmysqli_next_result( $this->dbh );\n\t\t\t}\n\t\t} elseif ( is_resource( $this->result ) ) {\n\t\t\tmysql_free_result( $this->result );\n\t\t}\n\t}\n\n\t/**\n\t * Connect to and select database.\n\t *\n\t * If $allow_bail is false, the lack of database connection will need\n\t * to be handled manually.\n\t *\n\t * @since 3.0.0\n\t * @since 3.9.0 $allow_bail parameter added.\n\t *\n\t * @param bool $allow_bail Optional. Allows the function to bail. Default true.\n\t * @return bool True with a successful connection, false on failure.\n\t */\n\tpublic function db_connect( $allow_bail = true ) {\n\t\t$this->is_mysql = true;\n\n\t\t/*\n\t\t * Deprecated in 3.9+ when using MySQLi. No equivalent\n\t\t * $new_link parameter exists for mysqli_* functions.\n\t\t */\n\t\t$new_link = defined( 'MYSQL_NEW_LINK' ) ? MYSQL_NEW_LINK : true;\n\t\t$client_flags = defined( 'MYSQL_CLIENT_FLAGS' ) ? MYSQL_CLIENT_FLAGS : 0;\n\n\t\tif ( $this->use_mysqli ) {\n\t\t\t$this->dbh = mysqli_init();\n\n\t\t\t// mysqli_real_connect doesn't support the host param including a port or socket\n\t\t\t// like mysql_connect does. This duplicates how mysql_connect detects a port and/or socket file.\n\t\t\t$port = null;\n\t\t\t$socket = null;\n\t\t\t$host = $this->dbhost;\n\t\t\t$port_or_socket = strstr( $host, ':' );\n\t\t\tif ( ! empty( $port_or_socket ) ) {\n\t\t\t\t$host = substr( $host, 0, strpos( $host, ':' ) );\n\t\t\t\t$port_or_socket = substr( $port_or_socket, 1 );\n\t\t\t\tif ( 0 !== strpos( $port_or_socket, '/' ) ) {\n\t\t\t\t\t$port = intval( $port_or_socket );\n\t\t\t\t\t$maybe_socket = strstr( $port_or_socket, ':' );\n\t\t\t\t\tif ( ! empty( $maybe_socket ) ) {\n\t\t\t\t\t\t$socket = substr( $maybe_socket, 1 );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$socket = $port_or_socket;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( WP_DEBUG ) {\n\t\t\t\tmysqli_real_connect( $this->dbh, $host, $this->dbuser, $this->dbpassword, null, $port, $socket, $client_flags );\n\t\t\t} else {\n\t\t\t\t@mysqli_real_connect( $this->dbh, $host, $this->dbuser, $this->dbpassword, null, $port, $socket, $client_flags );\n\t\t\t}\n\n\t\t\tif ( $this->dbh->connect_errno ) {\n\t\t\t\t$this->dbh = null;\n\n\t\t\t\t/* It's possible ext/mysqli is misconfigured. Fall back to ext/mysql if:\n\t\t \t\t *  - We haven't previously connected, and\n\t\t \t\t *  - WP_USE_EXT_MYSQL isn't set to false, and\n\t\t \t\t *  - ext/mysql is loaded.\n\t\t \t\t */\n\t\t\t\t$attempt_fallback = true;\n\n\t\t\t\tif ( $this->has_connected ) {\n\t\t\t\t\t$attempt_fallback = false;\n\t\t\t\t} elseif ( defined( 'WP_USE_EXT_MYSQL' ) && ! WP_USE_EXT_MYSQL ) {\n\t\t\t\t\t$attempt_fallback = false;\n\t\t\t\t} elseif ( ! function_exists( 'mysql_connect' ) ) {\n\t\t\t\t\t$attempt_fallback = false;\n\t\t\t\t}\n\n\t\t\t\tif ( $attempt_fallback ) {\n\t\t\t\t\t$this->use_mysqli = false;\n\t\t\t\t\treturn $this->db_connect( $allow_bail );\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif ( WP_DEBUG ) {\n\t\t\t\t$this->dbh = mysql_connect( $this->dbhost, $this->dbuser, $this->dbpassword, $new_link, $client_flags );\n\t\t\t} else {\n\t\t\t\t$this->dbh = @mysql_connect( $this->dbhost, $this->dbuser, $this->dbpassword, $new_link, $client_flags );\n\t\t\t}\n\t\t}\n\n\t\tif ( ! $this->dbh && $allow_bail ) {\n\t\t\twp_load_translations_early();\n\n\t\t\t// Load custom DB error template, if present.\n\t\t\tif ( file_exists( WP_CONTENT_DIR . '/db-error.php' ) ) {\n\t\t\t\trequire_once( WP_CONTENT_DIR . '/db-error.php' );\n\t\t\t\tdie();\n\t\t\t}\n\n\t\t\t$message = '<h1>' . __( 'Error establishing a database connection' ) . \"</h1>\\n\";\n\n\t\t\t$message .= '<p>' . sprintf(\n\t\t\t\t/* translators: 1: wp-config.php. 2: database host */\n\t\t\t\t__( 'This either means that the username and password information in your %1$s file is incorrect or we can&#8217;t contact the database server at %2$s. This could mean your host&#8217;s database server is down.' ),\n\t\t\t\t'<code>wp-config.php</code>',\n\t\t\t\t'<code>' . htmlspecialchars( $this->dbhost, ENT_QUOTES ) . '</code>'\n\t\t\t) . \"</p>\\n\";\n\n\t\t\t$message .= \"<ul>\\n\";\n\t\t\t$message .= '<li>' . __( 'Are you sure you have the correct username and password?' ) . \"</li>\\n\";\n\t\t\t$message .= '<li>' . __( 'Are you sure that you have typed the correct hostname?' ) . \"</li>\\n\";\n\t\t\t$message .= '<li>' . __( 'Are you sure that the database server is running?' ) . \"</li>\\n\";\n\t\t\t$message .= \"</ul>\\n\";\n\n\t\t\t$message .= '<p>' . sprintf(\n\t\t\t\t/* translators: %s: support forums URL */\n\t\t\t\t__( 'If you&#8217;re unsure what these terms mean you should probably contact your host. If you still need help you can always visit the <a href=\"%s\">WordPress Support Forums</a>.' ),\n\t\t\t\t__( 'https://wordpress.org/support/' )\n\t\t\t) . \"</p>\\n\";\n\n\t\t\t$this->bail( $message, 'db_connect_fail' );\n\n\t\t\treturn false;\n\t\t} elseif ( $this->dbh ) {\n\t\t\tif ( ! $this->has_connected ) {\n\t\t\t\t$this->init_charset();\n\t\t\t}\n\n\t\t\t$this->has_connected = true;\n\n\t\t\t$this->set_charset( $this->dbh );\n\n\t\t\t$this->ready = true;\n\t\t\t$this->set_sql_mode();\n\t\t\t$this->select( $this->dbname, $this->dbh );\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Checks that the connection to the database is still up. If not, try to reconnect.\n\t *\n\t * If this function is unable to reconnect, it will forcibly die, or if after the\n\t * the {@see 'template_redirect'} hook has been fired, return false instead.\n\t *\n\t * If $allow_bail is false, the lack of database connection will need\n\t * to be handled manually.\n\t *\n\t * @since 3.9.0\n\t *\n\t * @param bool $allow_bail Optional. Allows the function to bail. Default true.\n\t * @return bool|void True if the connection is up.\n\t */\n\tpublic function check_connection( $allow_bail = true ) {\n\t\tif ( $this->use_mysqli ) {\n\t\t\tif ( ! empty( $this->dbh ) && mysqli_ping( $this->dbh ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tif ( ! empty( $this->dbh ) && mysql_ping( $this->dbh ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t$error_reporting = false;\n\n\t\t// Disable warnings, as we don't want to see a multitude of \"unable to connect\" messages\n\t\tif ( WP_DEBUG ) {\n\t\t\t$error_reporting = error_reporting();\n\t\t\terror_reporting( $error_reporting & ~E_WARNING );\n\t\t}\n\n\t\tfor ( $tries = 1; $tries <= $this->reconnect_retries; $tries++ ) {\n\t\t\t// On the last try, re-enable warnings. We want to see a single instance of the\n\t\t\t// \"unable to connect\" message on the bail() screen, if it appears.\n\t\t\tif ( $this->reconnect_retries === $tries && WP_DEBUG ) {\n\t\t\t\terror_reporting( $error_reporting );\n\t\t\t}\n\n\t\t\tif ( $this->db_connect( false ) ) {\n\t\t\t\tif ( $error_reporting ) {\n\t\t\t\t\terror_reporting( $error_reporting );\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tsleep( 1 );\n\t\t}\n\n\t\t// If template_redirect has already happened, it's too late for wp_die()/dead_db().\n\t\t// Let's just return and hope for the best.\n\t\tif ( did_action( 'template_redirect' ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( ! $allow_bail ) {\n\t\t\treturn false;\n\t\t}\n\n\t\twp_load_translations_early();\n\n\t\t$message = '<h1>' . __( 'Error reconnecting to the database' ) . \"</h1>\\n\";\n\n\t\t$message .= '<p>' . sprintf(\n\t\t\t/* translators: %s: database host */\n\t\t\t__( 'This means that we lost contact with the database server at %s. This could mean your host&#8217;s database server is down.' ),\n\t\t\t'<code>' . htmlspecialchars( $this->dbhost, ENT_QUOTES ) . '</code>'\n\t\t) . \"</p>\\n\";\n\n\t\t$message .= \"<ul>\\n\";\n\t\t$message .= '<li>' . __( 'Are you sure that the database server is running?' ) . \"</li>\\n\";\n\t\t$message .= '<li>' . __( 'Are you sure that the database server is not under particularly heavy load?' ) . \"</li>\\n\";\n\t\t$message .= \"</ul>\\n\";\n\n\t\t$message .= '<p>' . sprintf(\n\t\t\t/* translators: %s: support forums URL */\n\t\t\t__( 'If you&#8217;re unsure what these terms mean you should probably contact your host. If you still need help you can always visit the <a href=\"%s\">WordPress Support Forums</a>.' ),\n\t\t\t__( 'https://wordpress.org/support/' )\n\t\t) . \"</p>\\n\";\n\n\t\t// We weren't able to reconnect, so we better bail.\n\t\t$this->bail( $message, 'db_connect_fail' );\n\n\t\t// Call dead_db() if bail didn't die, because this database is no more. It has ceased to be (at least temporarily).\n\t\tdead_db();\n\t}\n\n\t/**\n\t * Perform a MySQL database query, using current database connection.\n\t *\n\t * More information can be found on the codex page.\n\t *\n\t * @since 0.71\n\t *\n\t * @param string $query Database query\n\t * @return int|false Number of rows affected/selected or false on error\n\t */\n\tpublic function query( $query ) {\n\t\tif ( ! $this->ready ) {\n\t\t\t$this->check_current_query = true;\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * Filters the database query.\n\t\t *\n\t\t * Some queries are made before the plugins have been loaded,\n\t\t * and thus cannot be filtered with this method.\n\t\t *\n\t\t * @since 2.1.0\n\t\t *\n\t\t * @param string $query Database query.\n\t\t */\n\t\t$query = apply_filters( 'query', $query );\n\n\t\t$this->flush();\n\n\t\t// Log how the function was called\n\t\t$this->func_call = \"\\$db->query(\\\"$query\\\")\";\n\n\t\t// If we're writing to the database, make sure the query will write safely.\n\t\tif ( $this->check_current_query && ! $this->check_ascii( $query ) ) {\n\t\t\t$stripped_query = $this->strip_invalid_text_from_query( $query );\n\t\t\t// strip_invalid_text_from_query() can perform queries, so we need\n\t\t\t// to flush again, just to make sure everything is clear.\n\t\t\t$this->flush();\n\t\t\tif ( $stripped_query !== $query ) {\n\t\t\t\t$this->insert_id = 0;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t$this->check_current_query = true;\n\n\t\t// Keep track of the last query for debug.\n\t\t$this->last_query = $query;\n\n\t\t$this->_do_query( $query );\n\n\t\t// MySQL server has gone away, try to reconnect.\n\t\t$mysql_errno = 0;\n\t\tif ( ! empty( $this->dbh ) ) {\n\t\t\tif ( $this->use_mysqli ) {\n\t\t\t\tif ( $this->dbh instanceof mysqli ) {\n\t\t\t\t\t$mysql_errno = mysqli_errno( $this->dbh );\n\t\t\t\t} else {\n\t\t\t\t\t// $dbh is defined, but isn't a real connection.\n\t\t\t\t\t// Something has gone horribly wrong, let's try a reconnect.\n\t\t\t\t\t$mysql_errno = 2006;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ( is_resource( $this->dbh ) ) {\n\t\t\t\t\t$mysql_errno = mysql_errno( $this->dbh );\n\t\t\t\t} else {\n\t\t\t\t\t$mysql_errno = 2006;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( empty( $this->dbh ) || 2006 == $mysql_errno ) {\n\t\t\tif ( $this->check_connection() ) {\n\t\t\t\t$this->_do_query( $query );\n\t\t\t} else {\n\t\t\t\t$this->insert_id = 0;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// If there is an error then take note of it.\n\t\tif ( $this->use_mysqli ) {\n\t\t\tif ( $this->dbh instanceof mysqli ) {\n\t\t\t\t$this->last_error = mysqli_error( $this->dbh );\n\t\t\t} else {\n\t\t\t\t$this->last_error = __( 'Unable to retrieve the error message from MySQL' );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( is_resource( $this->dbh ) ) {\n\t\t\t\t$this->last_error = mysql_error( $this->dbh );\n\t\t\t} else {\n\t\t\t\t$this->last_error = __( 'Unable to retrieve the error message from MySQL' );\n\t\t\t}\n\t\t}\n\n\t\tif ( $this->last_error ) {\n\t\t\t// Clear insert_id on a subsequent failed insert.\n\t\t\tif ( $this->insert_id && preg_match( '/^\\s*(insert|replace)\\s/i', $query ) )\n\t\t\t\t$this->insert_id = 0;\n\n\t\t\t$this->print_error();\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( preg_match( '/^\\s*(create|alter|truncate|drop)\\s/i', $query ) ) {\n\t\t\t$return_val = $this->result;\n\t\t} elseif ( preg_match( '/^\\s*(insert|delete|update|replace)\\s/i', $query ) ) {\n\t\t\tif ( $this->use_mysqli ) {\n\t\t\t\t$this->rows_affected = mysqli_affected_rows( $this->dbh );\n\t\t\t} else {\n\t\t\t\t$this->rows_affected = mysql_affected_rows( $this->dbh );\n\t\t\t}\n\t\t\t// Take note of the insert_id\n\t\t\tif ( preg_match( '/^\\s*(insert|replace)\\s/i', $query ) ) {\n\t\t\t\tif ( $this->use_mysqli ) {\n\t\t\t\t\t$this->insert_id = mysqli_insert_id( $this->dbh );\n\t\t\t\t} else {\n\t\t\t\t\t$this->insert_id = mysql_insert_id( $this->dbh );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Return number of rows affected\n\t\t\t$return_val = $this->rows_affected;\n\t\t} else {\n\t\t\t$num_rows = 0;\n\t\t\tif ( $this->use_mysqli && $this->result instanceof mysqli_result ) {\n\t\t\t\twhile ( $row = mysqli_fetch_object( $this->result ) ) {\n\t\t\t\t\t$this->last_result[$num_rows] = $row;\n\t\t\t\t\t$num_rows++;\n\t\t\t\t}\n\t\t\t} elseif ( is_resource( $this->result ) ) {\n\t\t\t\twhile ( $row = mysql_fetch_object( $this->result ) ) {\n\t\t\t\t\t$this->last_result[$num_rows] = $row;\n\t\t\t\t\t$num_rows++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Log number of rows the query returned\n\t\t\t// and return number of rows selected\n\t\t\t$this->num_rows = $num_rows;\n\t\t\t$return_val     = $num_rows;\n\t\t}\n\n\t\treturn $return_val;\n\t}\n\n\t/**\n\t * Internal function to perform the mysql_query() call.\n\t *\n\t * @since 3.9.0\n\t *\n\t * @see wpdb::query()\n\t *\n\t * @param string $query The query to run.\n\t */\n\tprivate function _do_query( $query ) {\n\t\tif ( defined( 'SAVEQUERIES' ) && SAVEQUERIES ) {\n\t\t\t$this->timer_start();\n\t\t}\n\n\t\tif ( ! empty( $this->dbh ) && $this->use_mysqli ) {\n\t\t\t$this->result = mysqli_query( $this->dbh, $query );\n\t\t} elseif ( ! empty( $this->dbh ) ) {\n\t\t\t$this->result = mysql_query( $query, $this->dbh );\n\t\t}\n\t\t$this->num_queries++;\n\n\t\tif ( defined( 'SAVEQUERIES' ) && SAVEQUERIES ) {\n\t\t\t$this->queries[] = array( $query, $this->timer_stop(), $this->get_caller() );\n\t\t}\n\t}\n\n\t/**\n\t * Insert a row into a table.\n\t *\n\t *     wpdb::insert( 'table', array( 'column' => 'foo', 'field' => 'bar' ) )\n\t *     wpdb::insert( 'table', array( 'column' => 'foo', 'field' => 1337 ), array( '%s', '%d' ) )\n\t *\n\t * @since 2.5.0\n\t * @see wpdb::prepare()\n\t * @see wpdb::$field_types\n\t * @see wp_set_wpdb_vars()\n\t *\n\t * @param string       $table  Table name\n\t * @param array        $data   Data to insert (in column => value pairs).\n\t *                             Both $data columns and $data values should be \"raw\" (neither should be SQL escaped).\n\t *                             Sending a null value will cause the column to be set to NULL - the corresponding format is ignored in this case.\n\t * @param array|string $format Optional. An array of formats to be mapped to each of the value in $data.\n\t *                             If string, that format will be used for all of the values in $data.\n\t *                             A format is one of '%d', '%f', '%s' (integer, float, string).\n\t *                             If omitted, all values in $data will be treated as strings unless otherwise specified in wpdb::$field_types.\n\t * @return int|false The number of rows inserted, or false on error.\n\t */\n\tpublic function insert( $table, $data, $format = null ) {\n\t\treturn $this->_insert_replace_helper( $table, $data, $format, 'INSERT' );\n\t}\n\n\t/**\n\t * Replace a row into a table.\n\t *\n\t *     wpdb::replace( 'table', array( 'column' => 'foo', 'field' => 'bar' ) )\n\t *     wpdb::replace( 'table', array( 'column' => 'foo', 'field' => 1337 ), array( '%s', '%d' ) )\n\t *\n\t * @since 3.0.0\n\t * @see wpdb::prepare()\n\t * @see wpdb::$field_types\n\t * @see wp_set_wpdb_vars()\n\t *\n\t * @param string       $table  Table name\n\t * @param array        $data   Data to insert (in column => value pairs).\n\t *                             Both $data columns and $data values should be \"raw\" (neither should be SQL escaped).\n\t *                             Sending a null value will cause the column to be set to NULL - the corresponding format is ignored in this case.\n\t * @param array|string $format Optional. An array of formats to be mapped to each of the value in $data.\n\t *                             If string, that format will be used for all of the values in $data.\n\t *                             A format is one of '%d', '%f', '%s' (integer, float, string).\n\t *                             If omitted, all values in $data will be treated as strings unless otherwise specified in wpdb::$field_types.\n\t * @return int|false The number of rows affected, or false on error.\n\t */\n\tpublic function replace( $table, $data, $format = null ) {\n\t\treturn $this->_insert_replace_helper( $table, $data, $format, 'REPLACE' );\n\t}\n\n\t/**\n\t * Helper function for insert and replace.\n\t *\n\t * Runs an insert or replace query based on $type argument.\n\t *\n\t * @since 3.0.0\n\t * @see wpdb::prepare()\n\t * @see wpdb::$field_types\n\t * @see wp_set_wpdb_vars()\n\t *\n\t * @param string       $table  Table name\n\t * @param array        $data   Data to insert (in column => value pairs).\n\t *                             Both $data columns and $data values should be \"raw\" (neither should be SQL escaped).\n\t *                             Sending a null value will cause the column to be set to NULL - the corresponding format is ignored in this case.\n\t * @param array|string $format Optional. An array of formats to be mapped to each of the value in $data.\n\t *                             If string, that format will be used for all of the values in $data.\n\t *                             A format is one of '%d', '%f', '%s' (integer, float, string).\n\t *                             If omitted, all values in $data will be treated as strings unless otherwise specified in wpdb::$field_types.\n\t * @param string $type         Optional. What type of operation is this? INSERT or REPLACE. Defaults to INSERT.\n\t * @return int|false The number of rows affected, or false on error.\n\t */\n\tfunction _insert_replace_helper( $table, $data, $format = null, $type = 'INSERT' ) {\n\t\t$this->insert_id = 0;\n\n\t\tif ( ! in_array( strtoupper( $type ), array( 'REPLACE', 'INSERT' ) ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$data = $this->process_fields( $table, $data, $format );\n\t\tif ( false === $data ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$formats = $values = array();\n\t\tforeach ( $data as $value ) {\n\t\t\tif ( is_null( $value['value'] ) ) {\n\t\t\t\t$formats[] = 'NULL';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$formats[] = $value['format'];\n\t\t\t$values[]  = $value['value'];\n\t\t}\n\n\t\t$fields  = '`' . implode( '`, `', array_keys( $data ) ) . '`';\n\t\t$formats = implode( ', ', $formats );\n\n\t\t$sql = \"$type INTO `$table` ($fields) VALUES ($formats)\";\n\n\t\t$this->check_current_query = false;\n\t\treturn $this->query( $this->prepare( $sql, $values ) );\n\t}\n\n\t/**\n\t * Update a row in the table\n\t *\n\t *     wpdb::update( 'table', array( 'column' => 'foo', 'field' => 'bar' ), array( 'ID' => 1 ) )\n\t *     wpdb::update( 'table', array( 'column' => 'foo', 'field' => 1337 ), array( 'ID' => 1 ), array( '%s', '%d' ), array( '%d' ) )\n\t *\n\t * @since 2.5.0\n\t * @see wpdb::prepare()\n\t * @see wpdb::$field_types\n\t * @see wp_set_wpdb_vars()\n\t *\n\t * @param string       $table        Table name\n\t * @param array        $data         Data to update (in column => value pairs).\n\t *                                   Both $data columns and $data values should be \"raw\" (neither should be SQL escaped).\n\t *                                   Sending a null value will cause the column to be set to NULL - the corresponding\n\t *                                   format is ignored in this case.\n\t * @param array        $where        A named array of WHERE clauses (in column => value pairs).\n\t *                                   Multiple clauses will be joined with ANDs.\n\t *                                   Both $where columns and $where values should be \"raw\".\n\t *                                   Sending a null value will create an IS NULL comparison - the corresponding format will be ignored in this case.\n\t * @param array|string $format       Optional. An array of formats to be mapped to each of the values in $data.\n\t *                                   If string, that format will be used for all of the values in $data.\n\t *                                   A format is one of '%d', '%f', '%s' (integer, float, string).\n\t *                                   If omitted, all values in $data will be treated as strings unless otherwise specified in wpdb::$field_types.\n\t * @param array|string $where_format Optional. An array of formats to be mapped to each of the values in $where.\n\t *                                   If string, that format will be used for all of the items in $where.\n\t *                                   A format is one of '%d', '%f', '%s' (integer, float, string).\n\t *                                   If omitted, all values in $where will be treated as strings.\n\t * @return int|false The number of rows updated, or false on error.\n\t */\n\tpublic function update( $table, $data, $where, $format = null, $where_format = null ) {\n\t\tif ( ! is_array( $data ) || ! is_array( $where ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$data = $this->process_fields( $table, $data, $format );\n\t\tif ( false === $data ) {\n\t\t\treturn false;\n\t\t}\n\t\t$where = $this->process_fields( $table, $where, $where_format );\n\t\tif ( false === $where ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$fields = $conditions = $values = array();\n\t\tforeach ( $data as $field => $value ) {\n\t\t\tif ( is_null( $value['value'] ) ) {\n\t\t\t\t$fields[] = \"`$field` = NULL\";\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$fields[] = \"`$field` = \" . $value['format'];\n\t\t\t$values[] = $value['value'];\n\t\t}\n\t\tforeach ( $where as $field => $value ) {\n\t\t\tif ( is_null( $value['value'] ) ) {\n\t\t\t\t$conditions[] = \"`$field` IS NULL\";\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$conditions[] = \"`$field` = \" . $value['format'];\n\t\t\t$values[] = $value['value'];\n\t\t}\n\n\t\t$fields = implode( ', ', $fields );\n\t\t$conditions = implode( ' AND ', $conditions );\n\n\t\t$sql = \"UPDATE `$table` SET $fields WHERE $conditions\";\n\n\t\t$this->check_current_query = false;\n\t\treturn $this->query( $this->prepare( $sql, $values ) );\n\t}\n\n\t/**\n\t * Delete a row in the table\n\t *\n\t *     wpdb::delete( 'table', array( 'ID' => 1 ) )\n\t *     wpdb::delete( 'table', array( 'ID' => 1 ), array( '%d' ) )\n\t *\n\t * @since 3.4.0\n\t * @see wpdb::prepare()\n\t * @see wpdb::$field_types\n\t * @see wp_set_wpdb_vars()\n\t *\n\t * @param string       $table        Table name\n\t * @param array        $where        A named array of WHERE clauses (in column => value pairs).\n\t *                                   Multiple clauses will be joined with ANDs.\n\t *                                   Both $where columns and $where values should be \"raw\".\n\t *                                   Sending a null value will create an IS NULL comparison - the corresponding format will be ignored in this case.\n\t * @param array|string $where_format Optional. An array of formats to be mapped to each of the values in $where.\n\t *                                   If string, that format will be used for all of the items in $where.\n\t *                                   A format is one of '%d', '%f', '%s' (integer, float, string).\n\t *                                   If omitted, all values in $where will be treated as strings unless otherwise specified in wpdb::$field_types.\n\t * @return int|false The number of rows updated, or false on error.\n\t */\n\tpublic function delete( $table, $where, $where_format = null ) {\n\t\tif ( ! is_array( $where ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$where = $this->process_fields( $table, $where, $where_format );\n\t\tif ( false === $where ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$conditions = $values = array();\n\t\tforeach ( $where as $field => $value ) {\n\t\t\tif ( is_null( $value['value'] ) ) {\n\t\t\t\t$conditions[] = \"`$field` IS NULL\";\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$conditions[] = \"`$field` = \" . $value['format'];\n\t\t\t$values[] = $value['value'];\n\t\t}\n\n\t\t$conditions = implode( ' AND ', $conditions );\n\n\t\t$sql = \"DELETE FROM `$table` WHERE $conditions\";\n\n\t\t$this->check_current_query = false;\n\t\treturn $this->query( $this->prepare( $sql, $values ) );\n\t}\n\n\t/**\n\t * Processes arrays of field/value pairs and field formats.\n\t *\n\t * This is a helper method for wpdb's CRUD methods, which take field/value\n\t * pairs for inserts, updates, and where clauses. This method first pairs\n\t * each value with a format. Then it determines the charset of that field,\n\t * using that to determine if any invalid text would be stripped. If text is\n\t * stripped, then field processing is rejected and the query fails.\n\t *\n\t * @since 4.2.0\n\t *\n\t * @param string $table  Table name.\n\t * @param array  $data   Field/value pair.\n\t * @param mixed  $format Format for each field.\n\t * @return array|false Returns an array of fields that contain paired values\n\t *                    and formats. Returns false for invalid values.\n\t */\n\tprotected function process_fields( $table, $data, $format ) {\n\t\t$data = $this->process_field_formats( $data, $format );\n\t\tif ( false === $data ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$data = $this->process_field_charsets( $data, $table );\n\t\tif ( false === $data ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$data = $this->process_field_lengths( $data, $table );\n\t\tif ( false === $data ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$converted_data = $this->strip_invalid_text( $data );\n\n\t\tif ( $data !== $converted_data ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn $data;\n\t}\n\n\t/**\n\t * Prepares arrays of value/format pairs as passed to wpdb CRUD methods.\n\t *\n\t * @since 4.2.0\n\t *\n\t * @param array $data   Array of fields to values.\n\t * @param mixed $format Formats to be mapped to the values in $data.\n\t * @return array Array, keyed by field names with values being an array\n\t *               of 'value' and 'format' keys.\n\t */\n\tprotected function process_field_formats( $data, $format ) {\n\t\t$formats = $original_formats = (array) $format;\n\n\t\tforeach ( $data as $field => $value ) {\n\t\t\t$value = array(\n\t\t\t\t'value'  => $value,\n\t\t\t\t'format' => '%s',\n\t\t\t);\n\n\t\t\tif ( ! empty( $format ) ) {\n\t\t\t\t$value['format'] = array_shift( $formats );\n\t\t\t\tif ( ! $value['format'] ) {\n\t\t\t\t\t$value['format'] = reset( $original_formats );\n\t\t\t\t}\n\t\t\t} elseif ( isset( $this->field_types[ $field ] ) ) {\n\t\t\t\t$value['format'] = $this->field_types[ $field ];\n\t\t\t}\n\n\t\t\t$data[ $field ] = $value;\n\t\t}\n\n\t\treturn $data;\n\t}\n\n\t/**\n\t * Adds field charsets to field/value/format arrays generated by\n\t * the wpdb::process_field_formats() method.\n\t *\n\t * @since 4.2.0\n\t *\n\t * @param array  $data  As it comes from the wpdb::process_field_formats() method.\n\t * @param string $table Table name.\n\t * @return array|false The same array as $data with additional 'charset' keys.\n\t */\n\tprotected function process_field_charsets( $data, $table ) {\n\t\tforeach ( $data as $field => $value ) {\n\t\t\tif ( '%d' === $value['format'] || '%f' === $value['format'] ) {\n\t\t\t\t/*\n\t\t\t\t * We can skip this field if we know it isn't a string.\n\t\t\t\t * This checks %d/%f versus ! %s because its sprintf() could take more.\n\t\t\t\t */\n\t\t\t\t$value['charset'] = false;\n\t\t\t} else {\n\t\t\t\t$value['charset'] = $this->get_col_charset( $table, $field );\n\t\t\t\tif ( is_wp_error( $value['charset'] ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$data[ $field ] = $value;\n\t\t}\n\n\t\treturn $data;\n\t}\n\n\t/**\n\t * For string fields, record the maximum string length that field can safely save.\n\t *\n\t * @since 4.2.1\n\t *\n\t * @param array  $data  As it comes from the wpdb::process_field_charsets() method.\n\t * @param string $table Table name.\n\t * @return array|false The same array as $data with additional 'length' keys, or false if\n\t *                     any of the values were too long for their corresponding field.\n\t */\n\tprotected function process_field_lengths( $data, $table ) {\n\t\tforeach ( $data as $field => $value ) {\n\t\t\tif ( '%d' === $value['format'] || '%f' === $value['format'] ) {\n\t\t\t\t/*\n\t\t\t\t * We can skip this field if we know it isn't a string.\n\t\t\t\t * This checks %d/%f versus ! %s because its sprintf() could take more.\n\t\t\t\t */\n\t\t\t\t$value['length'] = false;\n\t\t\t} else {\n\t\t\t\t$value['length'] = $this->get_col_length( $table, $field );\n\t\t\t\tif ( is_wp_error( $value['length'] ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$data[ $field ] = $value;\n\t\t}\n\n\t\treturn $data;\n\t}\n\n\t/**\n\t * Retrieve one variable from the database.\n\t *\n\t * Executes a SQL query and returns the value from the SQL result.\n\t * If the SQL result contains more than one column and/or more than one row, this function returns the value in the column and row specified.\n\t * If $query is null, this function returns the value in the specified column and row from the previous SQL result.\n\t *\n\t * @since 0.71\n\t *\n\t * @param string|null $query Optional. SQL query. Defaults to null, use the result from the previous query.\n\t * @param int         $x     Optional. Column of value to return. Indexed from 0.\n\t * @param int         $y     Optional. Row of value to return. Indexed from 0.\n\t * @return string|null Database query result (as string), or null on failure\n\t */\n\tpublic function get_var( $query = null, $x = 0, $y = 0 ) {\n\t\t$this->func_call = \"\\$db->get_var(\\\"$query\\\", $x, $y)\";\n\n\t\tif ( $this->check_current_query && $this->check_safe_collation( $query ) ) {\n\t\t\t$this->check_current_query = false;\n\t\t}\n\n\t\tif ( $query ) {\n\t\t\t$this->query( $query );\n\t\t}\n\n\t\t// Extract var out of cached results based x,y vals\n\t\tif ( !empty( $this->last_result[$y] ) ) {\n\t\t\t$values = array_values( get_object_vars( $this->last_result[$y] ) );\n\t\t}\n\n\t\t// If there is a value return it else return null\n\t\treturn ( isset( $values[$x] ) && $values[$x] !== '' ) ? $values[$x] : null;\n\t}\n\n\t/**\n\t * Retrieve one row from the database.\n\t *\n\t * Executes a SQL query and returns the row from the SQL result.\n\t *\n\t * @since 0.71\n\t *\n\t * @param string|null $query  SQL query.\n\t * @param string      $output Optional. The required return type. One of OBJECT, ARRAY_A, or ARRAY_N, which correspond to\n\t *                            an stdClass object, an associative array, or a numeric array, respectively. Default OBJECT.\n\t * @param int         $y      Optional. Row to return. Indexed from 0.\n\t * @return array|object|null|void Database query result in format specified by $output or null on failure\n\t */\n\tpublic function get_row( $query = null, $output = OBJECT, $y = 0 ) {\n\t\t$this->func_call = \"\\$db->get_row(\\\"$query\\\",$output,$y)\";\n\n\t\tif ( $this->check_current_query && $this->check_safe_collation( $query ) ) {\n\t\t\t$this->check_current_query = false;\n\t\t}\n\n\t\tif ( $query ) {\n\t\t\t$this->query( $query );\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( !isset( $this->last_result[$y] ) )\n\t\t\treturn null;\n\n\t\tif ( $output == OBJECT ) {\n\t\t\treturn $this->last_result[$y] ? $this->last_result[$y] : null;\n\t\t} elseif ( $output == ARRAY_A ) {\n\t\t\treturn $this->last_result[$y] ? get_object_vars( $this->last_result[$y] ) : null;\n\t\t} elseif ( $output == ARRAY_N ) {\n\t\t\treturn $this->last_result[$y] ? array_values( get_object_vars( $this->last_result[$y] ) ) : null;\n\t\t} elseif ( strtoupper( $output ) === OBJECT ) {\n\t\t\t// Back compat for OBJECT being previously case insensitive.\n\t\t\treturn $this->last_result[$y] ? $this->last_result[$y] : null;\n\t\t} else {\n\t\t\t$this->print_error( \" \\$db->get_row(string query, output type, int offset) -- Output type must be one of: OBJECT, ARRAY_A, ARRAY_N\" );\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve one column from the database.\n\t *\n\t * Executes a SQL query and returns the column from the SQL result.\n\t * If the SQL result contains more than one column, this function returns the column specified.\n\t * If $query is null, this function returns the specified column from the previous SQL result.\n\t *\n\t * @since 0.71\n\t *\n\t * @param string|null $query Optional. SQL query. Defaults to previous query.\n\t * @param int         $x     Optional. Column to return. Indexed from 0.\n\t * @return array Database query result. Array indexed from 0 by SQL result row number.\n\t */\n\tpublic function get_col( $query = null , $x = 0 ) {\n\t\tif ( $this->check_current_query && $this->check_safe_collation( $query ) ) {\n\t\t\t$this->check_current_query = false;\n\t\t}\n\n\t\tif ( $query ) {\n\t\t\t$this->query( $query );\n\t\t}\n\n\t\t$new_array = array();\n\t\t// Extract the column values\n\t\tfor ( $i = 0, $j = count( $this->last_result ); $i < $j; $i++ ) {\n\t\t\t$new_array[$i] = $this->get_var( null, $x, $i );\n\t\t}\n\t\treturn $new_array;\n\t}\n\n\t/**\n\t * Retrieve an entire SQL result set from the database (i.e., many rows)\n\t *\n\t * Executes a SQL query and returns the entire SQL result.\n\t *\n\t * @since 0.71\n\t *\n\t * @param string $query  SQL query.\n\t * @param string $output Optional. Any of ARRAY_A | ARRAY_N | OBJECT | OBJECT_K constants.\n\t *                       With one of the first three, return an array of rows indexed from 0 by SQL result row number.\n\t *                       Each row is an associative array (column => value, ...), a numerically indexed array (0 => value, ...), or an object. ( ->column = value ), respectively.\n\t *                       With OBJECT_K, return an associative array of row objects keyed by the value of each row's first column's value.\n\t *                       Duplicate keys are discarded.\n\t * @return array|object|null Database query results\n\t */\n\tpublic function get_results( $query = null, $output = OBJECT ) {\n\t\t$this->func_call = \"\\$db->get_results(\\\"$query\\\", $output)\";\n\n\t\tif ( $this->check_current_query && $this->check_safe_collation( $query ) ) {\n\t\t\t$this->check_current_query = false;\n\t\t}\n\n\t\tif ( $query ) {\n\t\t\t$this->query( $query );\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\n\t\t$new_array = array();\n\t\tif ( $output == OBJECT ) {\n\t\t\t// Return an integer-keyed array of row objects\n\t\t\treturn $this->last_result;\n\t\t} elseif ( $output == OBJECT_K ) {\n\t\t\t// Return an array of row objects with keys from column 1\n\t\t\t// (Duplicates are discarded)\n\t\t\tforeach ( $this->last_result as $row ) {\n\t\t\t\t$var_by_ref = get_object_vars( $row );\n\t\t\t\t$key = array_shift( $var_by_ref );\n\t\t\t\tif ( ! isset( $new_array[ $key ] ) )\n\t\t\t\t\t$new_array[ $key ] = $row;\n\t\t\t}\n\t\t\treturn $new_array;\n\t\t} elseif ( $output == ARRAY_A || $output == ARRAY_N ) {\n\t\t\t// Return an integer-keyed array of...\n\t\t\tif ( $this->last_result ) {\n\t\t\t\tforeach ( (array) $this->last_result as $row ) {\n\t\t\t\t\tif ( $output == ARRAY_N ) {\n\t\t\t\t\t\t// ...integer-keyed row arrays\n\t\t\t\t\t\t$new_array[] = array_values( get_object_vars( $row ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// ...column name-keyed row arrays\n\t\t\t\t\t\t$new_array[] = get_object_vars( $row );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $new_array;\n\t\t} elseif ( strtoupper( $output ) === OBJECT ) {\n\t\t\t// Back compat for OBJECT being previously case insensitive.\n\t\t\treturn $this->last_result;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Retrieves the character set for the given table.\n\t *\n\t * @since 4.2.0\n\t *\n\t * @param string $table Table name.\n\t * @return string|WP_Error Table character set, WP_Error object if it couldn't be found.\n\t */\n\tprotected function get_table_charset( $table ) {\n\t\t$tablekey = strtolower( $table );\n\n\t\t/**\n\t\t * Filters the table charset value before the DB is checked.\n\t\t *\n\t\t * Passing a non-null value to the filter will effectively short-circuit\n\t\t * checking the DB for the charset, returning that value instead.\n\t\t *\n\t\t * @since 4.2.0\n\t\t *\n\t\t * @param string $charset The character set to use. Default null.\n\t\t * @param string $table   The name of the table being checked.\n\t\t */\n\t\t$charset = apply_filters( 'pre_get_table_charset', null, $table );\n\t\tif ( null !== $charset ) {\n\t\t\treturn $charset;\n\t\t}\n\n\t\tif ( isset( $this->table_charset[ $tablekey ] ) ) {\n\t\t\treturn $this->table_charset[ $tablekey ];\n\t\t}\n\n\t\t$charsets = $columns = array();\n\n\t\t$table_parts = explode( '.', $table );\n\t\t$table = '`' . implode( '`.`', $table_parts ) . '`';\n\t\t$results = $this->get_results( \"SHOW FULL COLUMNS FROM $table\" );\n\t\tif ( ! $results ) {\n\t\t\treturn new WP_Error( 'wpdb_get_table_charset_failure' );\n\t\t}\n\n\t\tforeach ( $results as $column ) {\n\t\t\t$columns[ strtolower( $column->Field ) ] = $column;\n\t\t}\n\n\t\t$this->col_meta[ $tablekey ] = $columns;\n\n\t\tforeach ( $columns as $column ) {\n\t\t\tif ( ! empty( $column->Collation ) ) {\n\t\t\t\tlist( $charset ) = explode( '_', $column->Collation );\n\n\t\t\t\t// If the current connection can't support utf8mb4 characters, let's only send 3-byte utf8 characters.\n\t\t\t\tif ( 'utf8mb4' === $charset && ! $this->has_cap( 'utf8mb4' ) ) {\n\t\t\t\t\t$charset = 'utf8';\n\t\t\t\t}\n\n\t\t\t\t$charsets[ strtolower( $charset ) ] = true;\n\t\t\t}\n\n\t\t\tlist( $type ) = explode( '(', $column->Type );\n\n\t\t\t// A binary/blob means the whole query gets treated like this.\n\t\t\tif ( in_array( strtoupper( $type ), array( 'BINARY', 'VARBINARY', 'TINYBLOB', 'MEDIUMBLOB', 'BLOB', 'LONGBLOB' ) ) ) {\n\t\t\t\t$this->table_charset[ $tablekey ] = 'binary';\n\t\t\t\treturn 'binary';\n\t\t\t}\n\t\t}\n\n\t\t// utf8mb3 is an alias for utf8.\n\t\tif ( isset( $charsets['utf8mb3'] ) ) {\n\t\t\t$charsets['utf8'] = true;\n\t\t\tunset( $charsets['utf8mb3'] );\n\t\t}\n\n\t\t// Check if we have more than one charset in play.\n\t\t$count = count( $charsets );\n\t\tif ( 1 === $count ) {\n\t\t\t$charset = key( $charsets );\n\t\t} elseif ( 0 === $count ) {\n\t\t\t// No charsets, assume this table can store whatever.\n\t\t\t$charset = false;\n\t\t} else {\n\t\t\t// More than one charset. Remove latin1 if present and recalculate.\n\t\t\tunset( $charsets['latin1'] );\n\t\t\t$count = count( $charsets );\n\t\t\tif ( 1 === $count ) {\n\t\t\t\t// Only one charset (besides latin1).\n\t\t\t\t$charset = key( $charsets );\n\t\t\t} elseif ( 2 === $count && isset( $charsets['utf8'], $charsets['utf8mb4'] ) ) {\n\t\t\t\t// Two charsets, but they're utf8 and utf8mb4, use utf8.\n\t\t\t\t$charset = 'utf8';\n\t\t\t} else {\n\t\t\t\t// Two mixed character sets. ascii.\n\t\t\t\t$charset = 'ascii';\n\t\t\t}\n\t\t}\n\n\t\t$this->table_charset[ $tablekey ] = $charset;\n\t\treturn $charset;\n\t}\n\n\t/**\n\t * Retrieves the character set for the given column.\n\t *\n\t * @since 4.2.0\n\t *\n\t * @param string $table  Table name.\n\t * @param string $column Column name.\n\t * @return string|false|WP_Error Column character set as a string. False if the column has no\n\t *                               character set. WP_Error object if there was an error.\n\t */\n\tpublic function get_col_charset( $table, $column ) {\n\t\t$tablekey = strtolower( $table );\n\t\t$columnkey = strtolower( $column );\n\n\t\t/**\n\t\t * Filters the column charset value before the DB is checked.\n\t\t *\n\t\t * Passing a non-null value to the filter will short-circuit\n\t\t * checking the DB for the charset, returning that value instead.\n\t\t *\n\t\t * @since 4.2.0\n\t\t *\n\t\t * @param string $charset The character set to use. Default null.\n\t\t * @param string $table   The name of the table being checked.\n\t\t * @param string $column  The name of the column being checked.\n\t\t */\n\t\t$charset = apply_filters( 'pre_get_col_charset', null, $table, $column );\n\t\tif ( null !== $charset ) {\n\t\t\treturn $charset;\n\t\t}\n\n\t\t// Skip this entirely if this isn't a MySQL database.\n\t\tif ( empty( $this->is_mysql ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( empty( $this->table_charset[ $tablekey ] ) ) {\n\t\t\t// This primes column information for us.\n\t\t\t$table_charset = $this->get_table_charset( $table );\n\t\t\tif ( is_wp_error( $table_charset ) ) {\n\t\t\t\treturn $table_charset;\n\t\t\t}\n\t\t}\n\n\t\t// If still no column information, return the table charset.\n\t\tif ( empty( $this->col_meta[ $tablekey ] ) ) {\n\t\t\treturn $this->table_charset[ $tablekey ];\n\t\t}\n\n\t\t// If this column doesn't exist, return the table charset.\n\t\tif ( empty( $this->col_meta[ $tablekey ][ $columnkey ] ) ) {\n\t\t\treturn $this->table_charset[ $tablekey ];\n\t\t}\n\n\t\t// Return false when it's not a string column.\n\t\tif ( empty( $this->col_meta[ $tablekey ][ $columnkey ]->Collation ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlist( $charset ) = explode( '_', $this->col_meta[ $tablekey ][ $columnkey ]->Collation );\n\t\treturn $charset;\n\t}\n\n\t/**\n\t * Retrieve the maximum string length allowed in a given column.\n\t * The length may either be specified as a byte length or a character length.\n\t *\n\t * @since 4.2.1\n\t *\n\t * @param string $table  Table name.\n\t * @param string $column Column name.\n\t * @return array|false|WP_Error array( 'length' => (int), 'type' => 'byte' | 'char' )\n\t *                              false if the column has no length (for example, numeric column)\n\t *                              WP_Error object if there was an error.\n\t */\n\tpublic function get_col_length( $table, $column ) {\n\t\t$tablekey = strtolower( $table );\n\t\t$columnkey = strtolower( $column );\n\n\t\t// Skip this entirely if this isn't a MySQL database.\n\t\tif ( empty( $this->is_mysql ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( empty( $this->col_meta[ $tablekey ] ) ) {\n\t\t\t// This primes column information for us.\n\t\t\t$table_charset = $this->get_table_charset( $table );\n\t\t\tif ( is_wp_error( $table_charset ) ) {\n\t\t\t\treturn $table_charset;\n\t\t\t}\n\t\t}\n\n\t\tif ( empty( $this->col_meta[ $tablekey ][ $columnkey ] ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$typeinfo = explode( '(', $this->col_meta[ $tablekey ][ $columnkey ]->Type );\n\n\t\t$type = strtolower( $typeinfo[0] );\n\t\tif ( ! empty( $typeinfo[1] ) ) {\n\t\t\t$length = trim( $typeinfo[1], ')' );\n\t\t} else {\n\t\t\t$length = false;\n\t\t}\n\n\t\tswitch( $type ) {\n\t\t\tcase 'char':\n\t\t\tcase 'varchar':\n\t\t\t\treturn array(\n\t\t\t\t\t'type'   => 'char',\n\t\t\t\t\t'length' => (int) $length,\n\t\t\t\t);\n\n\t\t\tcase 'binary':\n\t\t\tcase 'varbinary':\n\t\t\t\treturn array(\n\t\t\t\t\t'type'   => 'byte',\n\t\t\t\t\t'length' => (int) $length,\n\t\t\t\t);\n\n\t\t\tcase 'tinyblob':\n\t\t\tcase 'tinytext':\n\t\t\t\treturn array(\n\t\t\t\t\t'type'   => 'byte',\n\t\t\t\t\t'length' => 255,        // 2^8 - 1\n\t\t\t\t);\n\n\t\t\tcase 'blob':\n\t\t\tcase 'text':\n\t\t\t\treturn array(\n\t\t\t\t\t'type'   => 'byte',\n\t\t\t\t\t'length' => 65535,      // 2^16 - 1\n\t\t\t\t);\n\n\t\t\tcase 'mediumblob':\n\t\t\tcase 'mediumtext':\n\t\t\t\treturn array(\n\t\t\t\t\t'type'   => 'byte',\n\t\t\t\t\t'length' => 16777215,   // 2^24 - 1\n\t\t\t\t);\n\n\t\t\tcase 'longblob':\n\t\t\tcase 'longtext':\n\t\t\t\treturn array(\n\t\t\t\t\t'type'   => 'byte',\n\t\t\t\t\t'length' => 4294967295, // 2^32 - 1\n\t\t\t\t);\n\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Check if a string is ASCII.\n\t *\n\t * The negative regex is faster for non-ASCII strings, as it allows\n\t * the search to finish as soon as it encounters a non-ASCII character.\n\t *\n\t * @since 4.2.0\n\t *\n\t * @param string $string String to check.\n\t * @return bool True if ASCII, false if not.\n\t */\n\tprotected function check_ascii( $string ) {\n\t\tif ( function_exists( 'mb_check_encoding' ) ) {\n\t\t\tif ( mb_check_encoding( $string, 'ASCII' ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} elseif ( ! preg_match( '/[^\\x00-\\x7F]/', $string ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check if the query is accessing a collation considered safe on the current version of MySQL.\n\t *\n\t * @since 4.2.0\n\t *\n\t * @param string $query The query to check.\n\t * @return bool True if the collation is safe, false if it isn't.\n\t */\n\tprotected function check_safe_collation( $query ) {\n\t\tif ( $this->checking_collation ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// We don't need to check the collation for queries that don't read data.\n\t\t$query = ltrim( $query, \"\\r\\n\\t (\" );\n\t\tif ( preg_match( '/^(?:SHOW|DESCRIBE|DESC|EXPLAIN|CREATE)\\s/i', $query ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// All-ASCII queries don't need extra checking.\n\t\tif ( $this->check_ascii( $query ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t$table = $this->get_table_from_query( $query );\n\t\tif ( ! $table ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t$this->checking_collation = true;\n\t\t$collation = $this->get_table_charset( $table );\n\t\t$this->checking_collation = false;\n\n\t\t// Tables with no collation, or latin1 only, don't need extra checking.\n\t\tif ( false === $collation || 'latin1' === $collation ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t$table = strtolower( $table );\n\t\tif ( empty( $this->col_meta[ $table ] ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// If any of the columns don't have one of these collations, it needs more sanity checking.\n\t\tforeach ( $this->col_meta[ $table ] as $col ) {\n\t\t\tif ( empty( $col->Collation ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( ! in_array( $col->Collation, array( 'utf8_general_ci', 'utf8_bin', 'utf8mb4_general_ci', 'utf8mb4_bin' ), true ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Strips any invalid characters based on value/charset pairs.\n\t *\n\t * @since 4.2.0\n\t *\n\t * @param array $data Array of value arrays. Each value array has the keys\n\t *                    'value' and 'charset'. An optional 'ascii' key can be\n\t *                    set to false to avoid redundant ASCII checks.\n\t * @return array|WP_Error The $data parameter, with invalid characters removed from\n\t *                        each value. This works as a passthrough: any additional keys\n\t *                        such as 'field' are retained in each value array. If we cannot\n\t *                        remove invalid characters, a WP_Error object is returned.\n\t */\n\tprotected function strip_invalid_text( $data ) {\n\t\t$db_check_string = false;\n\n\t\tforeach ( $data as &$value ) {\n\t\t\t$charset = $value['charset'];\n\n\t\t\tif ( is_array( $value['length'] ) ) {\n\t\t\t\t$length = $value['length']['length'];\n\t\t\t\t$truncate_by_byte_length = 'byte' === $value['length']['type'];\n\t\t\t} else {\n\t\t\t\t$length = false;\n\t\t\t\t// Since we have no length, we'll never truncate.\n\t\t\t\t// Initialize the variable to false. true would take us\n\t\t\t\t// through an unnecessary (for this case) codepath below.\n\t\t\t\t$truncate_by_byte_length = false;\n\t\t\t}\n\n\t\t\t// There's no charset to work with.\n\t\t\tif ( false === $charset ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Column isn't a string.\n\t\t\tif ( ! is_string( $value['value'] ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$needs_validation = true;\n\t\t\tif (\n\t\t\t\t// latin1 can store any byte sequence\n\t\t\t\t'latin1' === $charset\n\t\t\t||\n\t\t\t\t// ASCII is always OK.\n\t\t\t\t( ! isset( $value['ascii'] ) && $this->check_ascii( $value['value'] ) )\n\t\t\t) {\n\t\t\t\t$truncate_by_byte_length = true;\n\t\t\t\t$needs_validation = false;\n\t\t\t}\n\n\t\t\tif ( $truncate_by_byte_length ) {\n\t\t\t\tmbstring_binary_safe_encoding();\n\t\t\t\tif ( false !== $length && strlen( $value['value'] ) > $length ) {\n\t\t\t\t\t$value['value'] = substr( $value['value'], 0, $length );\n\t\t\t\t}\n\t\t\t\treset_mbstring_encoding();\n\n\t\t\t\tif ( ! $needs_validation ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// utf8 can be handled by regex, which is a bunch faster than a DB lookup.\n\t\t\tif ( ( 'utf8' === $charset || 'utf8mb3' === $charset || 'utf8mb4' === $charset ) && function_exists( 'mb_strlen' ) ) {\n\t\t\t\t$regex = '/\n\t\t\t\t\t(\n\t\t\t\t\t\t(?: [\\x00-\\x7F]                  # single-byte sequences   0xxxxxxx\n\t\t\t\t\t\t|   [\\xC2-\\xDF][\\x80-\\xBF]       # double-byte sequences   110xxxxx 10xxxxxx\n\t\t\t\t\t\t|   \\xE0[\\xA0-\\xBF][\\x80-\\xBF]   # triple-byte sequences   1110xxxx 10xxxxxx * 2\n\t\t\t\t\t\t|   [\\xE1-\\xEC][\\x80-\\xBF]{2}\n\t\t\t\t\t\t|   \\xED[\\x80-\\x9F][\\x80-\\xBF]\n\t\t\t\t\t\t|   [\\xEE-\\xEF][\\x80-\\xBF]{2}';\n\n\t\t\t\tif ( 'utf8mb4' === $charset ) {\n\t\t\t\t\t$regex .= '\n\t\t\t\t\t\t|    \\xF0[\\x90-\\xBF][\\x80-\\xBF]{2} # four-byte sequences   11110xxx 10xxxxxx * 3\n\t\t\t\t\t\t|    [\\xF1-\\xF3][\\x80-\\xBF]{3}\n\t\t\t\t\t\t|    \\xF4[\\x80-\\x8F][\\x80-\\xBF]{2}\n\t\t\t\t\t';\n\t\t\t\t}\n\n\t\t\t\t$regex .= '){1,40}                          # ...one or more times\n\t\t\t\t\t)\n\t\t\t\t\t| .                                  # anything else\n\t\t\t\t\t/x';\n\t\t\t\t$value['value'] = preg_replace( $regex, '$1', $value['value'] );\n\n\n\t\t\t\tif ( false !== $length && mb_strlen( $value['value'], 'UTF-8' ) > $length ) {\n\t\t\t\t\t$value['value'] = mb_substr( $value['value'], 0, $length, 'UTF-8' );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// We couldn't use any local conversions, send it to the DB.\n\t\t\t$value['db'] = $db_check_string = true;\n\t\t}\n\t\tunset( $value ); // Remove by reference.\n\n\t\tif ( $db_check_string ) {\n\t\t\t$queries = array();\n\t\t\tforeach ( $data as $col => $value ) {\n\t\t\t\tif ( ! empty( $value['db'] ) ) {\n\t\t\t\t\t// We're going to need to truncate by characters or bytes, depending on the length value we have.\n\t\t\t\t\tif ( 'byte' === $value['length']['type'] ) {\n\t\t\t\t\t\t// Using binary causes LEFT() to truncate by bytes.\n\t\t\t\t\t\t$charset = 'binary';\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$charset = $value['charset'];\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( $this->charset ) {\n\t\t\t\t\t\t$connection_charset = $this->charset;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( $this->use_mysqli ) {\n\t\t\t\t\t\t\t$connection_charset = mysqli_character_set_name( $this->dbh );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$connection_charset = mysql_client_encoding();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( is_array( $value['length'] ) ) {\n\t\t\t\t\t\t$queries[ $col ] = $this->prepare( \"CONVERT( LEFT( CONVERT( %s USING $charset ), %.0f ) USING $connection_charset )\", $value['value'], $value['length']['length'] );\n\t\t\t\t\t} else if ( 'binary' !== $charset ) {\n\t\t\t\t\t\t// If we don't have a length, there's no need to convert binary - it will always return the same result.\n\t\t\t\t\t\t$queries[ $col ] = $this->prepare( \"CONVERT( CONVERT( %s USING $charset ) USING $connection_charset )\", $value['value'] );\n\t\t\t\t\t}\n\n\t\t\t\t\tunset( $data[ $col ]['db'] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$sql = array();\n\t\t\tforeach ( $queries as $column => $query ) {\n\t\t\t\tif ( ! $query ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t$sql[] = $query . \" AS x_$column\";\n\t\t\t}\n\n\t\t\t$this->check_current_query = false;\n\t\t\t$row = $this->get_row( \"SELECT \" . implode( ', ', $sql ), ARRAY_A );\n\t\t\tif ( ! $row ) {\n\t\t\t\treturn new WP_Error( 'wpdb_strip_invalid_text_failure' );\n\t\t\t}\n\n\t\t\tforeach ( array_keys( $data ) as $column ) {\n\t\t\t\tif ( isset( $row[\"x_$column\"] ) ) {\n\t\t\t\t\t$data[ $column ]['value'] = $row[\"x_$column\"];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn $data;\n\t}\n\n\t/**\n\t * Strips any invalid characters from the query.\n\t *\n\t * @since 4.2.0\n\t *\n\t * @param string $query Query to convert.\n\t * @return string|WP_Error The converted query, or a WP_Error object if the conversion fails.\n\t */\n\tprotected function strip_invalid_text_from_query( $query ) {\n\t\t// We don't need to check the collation for queries that don't read data.\n\t\t$trimmed_query = ltrim( $query, \"\\r\\n\\t (\" );\n\t\tif ( preg_match( '/^(?:SHOW|DESCRIBE|DESC|EXPLAIN|CREATE)\\s/i', $trimmed_query ) ) {\n\t\t\treturn $query;\n\t\t}\n\n\t\t$table = $this->get_table_from_query( $query );\n\t\tif ( $table ) {\n\t\t\t$charset = $this->get_table_charset( $table );\n\t\t\tif ( is_wp_error( $charset ) ) {\n\t\t\t\treturn $charset;\n\t\t\t}\n\n\t\t\t// We can't reliably strip text from tables containing binary/blob columns\n\t\t\tif ( 'binary' === $charset ) {\n\t\t\t\treturn $query;\n\t\t\t}\n\t\t} else {\n\t\t\t$charset = $this->charset;\n\t\t}\n\n\t\t$data = array(\n\t\t\t'value'   => $query,\n\t\t\t'charset' => $charset,\n\t\t\t'ascii'   => false,\n\t\t\t'length'  => false,\n\t\t);\n\n\t\t$data = $this->strip_invalid_text( array( $data ) );\n\t\tif ( is_wp_error( $data ) ) {\n\t\t\treturn $data;\n\t\t}\n\n\t\treturn $data[0]['value'];\n\t}\n\n\t/**\n\t * Strips any invalid characters from the string for a given table and column.\n\t *\n\t * @since 4.2.0\n\t *\n\t * @param string $table  Table name.\n\t * @param string $column Column name.\n\t * @param string $value  The text to check.\n\t * @return string|WP_Error The converted string, or a WP_Error object if the conversion fails.\n\t */\n\tpublic function strip_invalid_text_for_column( $table, $column, $value ) {\n\t\tif ( ! is_string( $value ) ) {\n\t\t\treturn $value;\n\t\t}\n\n\t\t$charset = $this->get_col_charset( $table, $column );\n\t\tif ( ! $charset ) {\n\t\t\t// Not a string column.\n\t\t\treturn $value;\n\t\t} elseif ( is_wp_error( $charset ) ) {\n\t\t\t// Bail on real errors.\n\t\t\treturn $charset;\n\t\t}\n\n\t\t$data = array(\n\t\t\t$column => array(\n\t\t\t\t'value'   => $value,\n\t\t\t\t'charset' => $charset,\n\t\t\t\t'length'  => $this->get_col_length( $table, $column ),\n\t\t\t)\n\t\t);\n\n\t\t$data = $this->strip_invalid_text( $data );\n\t\tif ( is_wp_error( $data ) ) {\n\t\t\treturn $data;\n\t\t}\n\n\t\treturn $data[ $column ]['value'];\n\t}\n\n\t/**\n\t * Find the first table name referenced in a query.\n\t *\n\t * @since 4.2.0\n\t *\n\t * @param string $query The query to search.\n\t * @return string|false $table The table name found, or false if a table couldn't be found.\n\t */\n\tprotected function get_table_from_query( $query ) {\n\t\t// Remove characters that can legally trail the table name.\n\t\t$query = rtrim( $query, ';/-#' );\n\n\t\t// Allow (select...) union [...] style queries. Use the first query's table name.\n\t\t$query = ltrim( $query, \"\\r\\n\\t (\" );\n\n\t\t// Strip everything between parentheses except nested selects.\n\t\t$query = preg_replace( '/\\((?!\\s*select)[^(]*?\\)/is', '()', $query );\n\n\t\t// Quickly match most common queries.\n\t\tif ( preg_match( '/^\\s*(?:'\n\t\t\t\t. 'SELECT.*?\\s+FROM'\n\t\t\t\t. '|INSERT(?:\\s+LOW_PRIORITY|\\s+DELAYED|\\s+HIGH_PRIORITY)?(?:\\s+IGNORE)?(?:\\s+INTO)?'\n\t\t\t\t. '|REPLACE(?:\\s+LOW_PRIORITY|\\s+DELAYED)?(?:\\s+INTO)?'\n\t\t\t\t. '|UPDATE(?:\\s+LOW_PRIORITY)?(?:\\s+IGNORE)?'\n\t\t\t\t. '|DELETE(?:\\s+LOW_PRIORITY|\\s+QUICK|\\s+IGNORE)*(?:.+?FROM)?'\n\t\t\t\t. ')\\s+((?:[0-9a-zA-Z$_.`-]|[\\xC2-\\xDF][\\x80-\\xBF])+)/is', $query, $maybe ) ) {\n\t\t\treturn str_replace( '`', '', $maybe[1] );\n\t\t}\n\n\t\t// SHOW TABLE STATUS and SHOW TABLES WHERE Name = 'wp_posts'\n\t\tif ( preg_match( '/^\\s*SHOW\\s+(?:TABLE\\s+STATUS|(?:FULL\\s+)?TABLES).+WHERE\\s+Name\\s*=\\s*(\"|\\')((?:[0-9a-zA-Z$_.-]|[\\xC2-\\xDF][\\x80-\\xBF])+)\\\\1/is', $query, $maybe ) ) {\n\t\t\treturn $maybe[2];\n\t\t}\n\n\t\t// SHOW TABLE STATUS LIKE and SHOW TABLES LIKE 'wp\\_123\\_%'\n\t\t// This quoted LIKE operand seldom holds a full table name.\n\t\t// It is usually a pattern for matching a prefix so we just\n\t\t// strip the trailing % and unescape the _ to get 'wp_123_'\n\t\t// which drop-ins can use for routing these SQL statements.\n\t\tif ( preg_match( '/^\\s*SHOW\\s+(?:TABLE\\s+STATUS|(?:FULL\\s+)?TABLES)\\s+(?:WHERE\\s+Name\\s+)?LIKE\\s*(\"|\\')((?:[\\\\\\\\0-9a-zA-Z$_.-]|[\\xC2-\\xDF][\\x80-\\xBF])+)%?\\\\1/is', $query, $maybe ) ) {\n\t\t\treturn str_replace( '\\\\_', '_', $maybe[2] );\n\t\t}\n\n\t\t// Big pattern for the rest of the table-related queries.\n\t\tif ( preg_match( '/^\\s*(?:'\n\t\t\t\t. '(?:EXPLAIN\\s+(?:EXTENDED\\s+)?)?SELECT.*?\\s+FROM'\n\t\t\t\t. '|DESCRIBE|DESC|EXPLAIN|HANDLER'\n\t\t\t\t. '|(?:LOCK|UNLOCK)\\s+TABLE(?:S)?'\n\t\t\t\t. '|(?:RENAME|OPTIMIZE|BACKUP|RESTORE|CHECK|CHECKSUM|ANALYZE|REPAIR).*\\s+TABLE'\n\t\t\t\t. '|TRUNCATE(?:\\s+TABLE)?'\n\t\t\t\t. '|CREATE(?:\\s+TEMPORARY)?\\s+TABLE(?:\\s+IF\\s+NOT\\s+EXISTS)?'\n\t\t\t\t. '|ALTER(?:\\s+IGNORE)?\\s+TABLE'\n\t\t\t\t. '|DROP\\s+TABLE(?:\\s+IF\\s+EXISTS)?'\n\t\t\t\t. '|CREATE(?:\\s+\\w+)?\\s+INDEX.*\\s+ON'\n\t\t\t\t. '|DROP\\s+INDEX.*\\s+ON'\n\t\t\t\t. '|LOAD\\s+DATA.*INFILE.*INTO\\s+TABLE'\n\t\t\t\t. '|(?:GRANT|REVOKE).*ON\\s+TABLE'\n\t\t\t\t. '|SHOW\\s+(?:.*FROM|.*TABLE)'\n\t\t\t\t. ')\\s+\\(*\\s*((?:[0-9a-zA-Z$_.`-]|[\\xC2-\\xDF][\\x80-\\xBF])+)\\s*\\)*/is', $query, $maybe ) ) {\n\t\t\treturn str_replace( '`', '', $maybe[1] );\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Load the column metadata from the last query.\n\t *\n\t * @since 3.5.0\n\t *\n\t */\n\tprotected function load_col_info() {\n\t\tif ( $this->col_info )\n\t\t\treturn;\n\n\t\tif ( $this->use_mysqli ) {\n\t\t\t$num_fields = mysqli_num_fields( $this->result );\n\t\t\tfor ( $i = 0; $i < $num_fields; $i++ ) {\n\t\t\t\t$this->col_info[ $i ] = mysqli_fetch_field( $this->result );\n\t\t\t}\n\t\t} else {\n\t\t\t$num_fields = mysql_num_fields( $this->result );\n\t\t\tfor ( $i = 0; $i < $num_fields; $i++ ) {\n\t\t\t\t$this->col_info[ $i ] = mysql_fetch_field( $this->result, $i );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve column metadata from the last query.\n\t *\n\t * @since 0.71\n\t *\n\t * @param string $info_type  Optional. Type one of name, table, def, max_length, not_null, primary_key, multiple_key, unique_key, numeric, blob, type, unsigned, zerofill\n\t * @param int    $col_offset Optional. 0: col name. 1: which table the col's in. 2: col's max length. 3: if the col is numeric. 4: col's type\n\t * @return mixed Column Results\n\t */\n\tpublic function get_col_info( $info_type = 'name', $col_offset = -1 ) {\n\t\t$this->load_col_info();\n\n\t\tif ( $this->col_info ) {\n\t\t\tif ( $col_offset == -1 ) {\n\t\t\t\t$i = 0;\n\t\t\t\t$new_array = array();\n\t\t\t\tforeach ( (array) $this->col_info as $col ) {\n\t\t\t\t\t$new_array[$i] = $col->{$info_type};\n\t\t\t\t\t$i++;\n\t\t\t\t}\n\t\t\t\treturn $new_array;\n\t\t\t} else {\n\t\t\t\treturn $this->col_info[$col_offset]->{$info_type};\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Starts the timer, for debugging purposes.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @return true\n\t */\n\tpublic function timer_start() {\n\t\t$this->time_start = microtime( true );\n\t\treturn true;\n\t}\n\n\t/**\n\t * Stops the debugging timer.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @return float Total time spent on the query, in seconds\n\t */\n\tpublic function timer_stop() {\n\t\treturn ( microtime( true ) - $this->time_start );\n\t}\n\n\t/**\n\t * Wraps errors in a nice header and footer and dies.\n\t *\n\t * Will not die if wpdb::$show_errors is false.\n\t *\n\t * @since 1.5.0\n\t *\n\t * @param string $message    The Error message\n\t * @param string $error_code Optional. A Computer readable string to identify the error.\n\t * @return false|void\n\t */\n\tpublic function bail( $message, $error_code = '500' ) {\n\t\tif ( !$this->show_errors ) {\n\t\t\tif ( class_exists( 'WP_Error', false ) ) {\n\t\t\t\t$this->error = new WP_Error($error_code, $message);\n\t\t\t} else {\n\t\t\t\t$this->error = $message;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\twp_die($message);\n\t}\n\n\n\t/**\n\t * Closes the current database connection.\n\t *\n\t * @since 4.5.0\n\t *\n\t * @return bool True if the connection was successfully closed, false if it wasn't,\n\t *              or the connection doesn't exist.\n\t */\n\tpublic function close() {\n\t\tif ( ! $this->dbh ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( $this->use_mysqli ) {\n\t\t\t$closed = mysqli_close( $this->dbh );\n\t\t} else {\n\t\t\t$closed = mysql_close( $this->dbh );\n\t\t}\n\n\t\tif ( $closed ) {\n\t\t\t$this->dbh = null;\n\t\t\t$this->ready = false;\n\t\t\t$this->has_connected = false;\n\t\t}\n\n\t\treturn $closed;\n\t}\n\n\t/**\n\t * Whether MySQL database is at least the required minimum version.\n\t *\n\t * @since 2.5.0\n\t *\n\t * @global string $wp_version\n\t * @global string $required_mysql_version\n\t *\n\t * @return WP_Error|void\n\t */\n\tpublic function check_database_version() {\n\t\tglobal $wp_version, $required_mysql_version;\n\t\t// Make sure the server has the required MySQL version\n\t\tif ( version_compare($this->db_version(), $required_mysql_version, '<') ) {\n\t\t\t/* translators: 1: WordPress version number, 2: Minimum required MySQL version number */\n\t\t\treturn new WP_Error('database_version', sprintf( __( '<strong>ERROR</strong>: WordPress %1$s requires MySQL %2$s or higher' ), $wp_version, $required_mysql_version ));\n\t\t}\n\t}\n\n\t/**\n\t * Whether the database supports collation.\n\t *\n\t * Called when WordPress is generating the table scheme.\n\t *\n\t * Use `wpdb::has_cap( 'collation' )`.\n\t *\n\t * @since 2.5.0\n\t * @deprecated 3.5.0 Use wpdb::has_cap()\n\t *\n\t * @return bool True if collation is supported, false if version does not\n\t */\n\tpublic function supports_collation() {\n\t\t_deprecated_function( __FUNCTION__, '3.5.0', 'wpdb::has_cap( \\'collation\\' )' );\n\t\treturn $this->has_cap( 'collation' );\n\t}\n\n\t/**\n\t * The database character collate.\n\t *\n\t * @since 3.5.0\n\t *\n\t * @return string The database character collate.\n\t */\n\tpublic function get_charset_collate() {\n\t\t$charset_collate = '';\n\n\t\tif ( ! empty( $this->charset ) )\n\t\t\t$charset_collate = \"DEFAULT CHARACTER SET $this->charset\";\n\t\tif ( ! empty( $this->collate ) )\n\t\t\t$charset_collate .= \" COLLATE $this->collate\";\n\n\t\treturn $charset_collate;\n\t}\n\n\t/**\n\t * Determine if a database supports a particular feature.\n\t *\n\t * @since 2.7.0\n\t * @since 4.1.0 Added support for the 'utf8mb4' feature.\n\t * @since 4.6.0 Added support for the 'utf8mb4_520' feature.\n\t *\n\t * @see wpdb::db_version()\n\t *\n\t * @param string $db_cap The feature to check for. Accepts 'collation',\n\t *                       'group_concat', 'subqueries', 'set_charset',\n\t *                       'utf8mb4', or 'utf8mb4_520'.\n\t * @return int|false Whether the database feature is supported, false otherwise.\n\t */\n\tpublic function has_cap( $db_cap ) {\n\t\t$version = $this->db_version();\n\n\t\tswitch ( strtolower( $db_cap ) ) {\n\t\t\tcase 'collation' :    // @since 2.5.0\n\t\t\tcase 'group_concat' : // @since 2.7.0\n\t\t\tcase 'subqueries' :   // @since 2.7.0\n\t\t\t\treturn version_compare( $version, '4.1', '>=' );\n\t\t\tcase 'set_charset' :\n\t\t\t\treturn version_compare( $version, '5.0.7', '>=' );\n\t\t\tcase 'utf8mb4' :      // @since 4.1.0\n\t\t\t\tif ( version_compare( $version, '5.5.3', '<' ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif ( $this->use_mysqli ) {\n\t\t\t\t\t$client_version = mysqli_get_client_info();\n\t\t\t\t} else {\n\t\t\t\t\t$client_version = mysql_get_client_info();\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * libmysql has supported utf8mb4 since 5.5.3, same as the MySQL server.\n\t\t\t\t * mysqlnd has supported utf8mb4 since 5.0.9.\n\t\t\t\t */\n\t\t\t\tif ( false !== strpos( $client_version, 'mysqlnd' ) ) {\n\t\t\t\t\t$client_version = preg_replace( '/^\\D+([\\d.]+).*/', '$1', $client_version );\n\t\t\t\t\treturn version_compare( $client_version, '5.0.9', '>=' );\n\t\t\t\t} else {\n\t\t\t\t\treturn version_compare( $client_version, '5.5.3', '>=' );\n\t\t\t\t}\n\t\t\tcase 'utf8mb4_520' : // @since 4.6.0\n\t\t\t\treturn version_compare( $version, '5.6', '>=' );\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Retrieve the name of the function that called wpdb.\n\t *\n\t * Searches up the list of functions until it reaches\n\t * the one that would most logically had called this method.\n\t *\n\t * @since 2.5.0\n\t *\n\t * @return string|array The name of the calling function\n\t */\n\tpublic function get_caller() {\n\t\treturn wp_debug_backtrace_summary( __CLASS__ );\n\t}\n\n\t/**\n\t * Retrieves the MySQL server version.\n\t *\n\t * @since 2.7.0\n\t *\n\t * @return null|string Null on failure, version number on success.\n\t */\n\tpublic function db_version() {\n\t\tif ( $this->use_mysqli ) {\n\t\t\t$server_info = mysqli_get_server_info( $this->dbh );\n\t\t} else {\n\t\t\t$server_info = mysql_get_server_info( $this->dbh );\n\t\t}\n\t\treturn preg_replace( '/[^0-9.].*/', '', $server_info );\n\t}\n}\n"], "filenames": ["wp-includes/version.php", "wp-includes/wp-db.php"], "buggy_code_start_loc": [7, 1238], "buggy_code_end_loc": [8, 1241], "fixing_code_start_loc": [7, 1239], "fixing_code_end_loc": [8, 1251], "type": "CWE-89", "message": "Before version 4.8.2, WordPress mishandled % characters and additional placeholder values in $wpdb->prepare, and thus did not properly address the possibility of plugins and themes enabling SQL injection attacks.", "other": {"cve": {"id": "CVE-2017-14723", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-23T20:29:00.420", "lastModified": "2017-11-10T02:29:18.077", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Before version 4.8.2, WordPress mishandled % characters and additional placeholder values in $wpdb->prepare, and thus did not properly address the possibility of plugins and themes enabling SQL injection attacks."}, {"lang": "es", "value": "Antes de la versi\u00f3n 4.8.2, WordPress no gestionaba correctamente caracteres % y valores de sustituci\u00f3n adicionales en $wpdb->prepare, por lo que no abordaba correctamente la posibilidad de que los plugins o los temas permitiesen los ataques de inyecci\u00f3n SQL."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wordpress:wordpress:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.8.1", "matchCriteriaId": "1C048B30-793C-4BDC-A2DE-6C87991205A4"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/100912", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1039553", "source": "cve@mitre.org"}, {"url": "https://core.trac.wordpress.org/changeset/41470", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://core.trac.wordpress.org/changeset/41496", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/WordPress/WordPress/commit/70b21279098fc973eae803693c0705a548128e48", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/WordPress/WordPress/commit/fc930d3daed1c3acef010d04acc2c5de93cd18ec", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://medium.com/websec/wordpress-sqli-bbb2afcc8e94", "source": "cve@mitre.org", "tags": ["Exploit", "Mitigation", "Third Party Advisory"]}, {"url": "https://medium.com/websec/wordpress-sqli-poc-f1827c20bf8e", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://wordpress.org/news/2017/09/wordpress-4-8-2-security-and-maintenance-release/", "source": "cve@mitre.org", "tags": ["Release Notes", "Patch", "Vendor Advisory"]}, {"url": "https://www.debian.org/security/2017/dsa-3997", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/WordPress/WordPress/commit/70b21279098fc973eae803693c0705a548128e48"}}