{"buggy_code": ["<?php\n/**\n ***********************************************************************************************\n * Handle image uploads from CKEditor\n *\n * @copyright 2004-2023 The Admidio Team\n * @see https://www.admidio.org/\n * @license https://www.gnu.org/licenses/gpl-2.0.html GNU General Public License v2.0 only\n *\n * Parameters:\n *\n * CKEditor        : ID of textarea, that had triggered the upload\n * CKEditorFuncNum : function number, that will handle in the editor the new URL\n * langCode        : language code\n ***********************************************************************************************\n */\nrequire_once(__DIR__ . '/common.php');\nrequire(__DIR__ . '/login_valid.php');\n\n$getCKEditor        = admFuncVariableIsValid($_GET, 'CKEditor', 'string', array('directOutput' => true, 'requireValue' => true));\n$getCKEditorFuncNum = admFuncVariableIsValid($_GET, 'CKEditorFuncNum', 'string', array('directOutput' => true, 'requireValue' => true));\n$getlangCode        = admFuncVariableIsValid($_GET, 'langCode', 'string', array('directOutput' => true));\n\n$htmlUrl = '';\n$message = '';\n\n// check if a file was really uploaded\nif (!file_exists($_FILES['upload']['tmp_name']) || !is_uploaded_file($_FILES['upload']['tmp_name'])) {\n    $message = $gL10n->get('SYS_FILE_NOT_EXIST');\n}\n\n// checks if the server settings for file_upload are set to ON\nif (!PhpIniUtils::isFileUploadEnabled()) {\n    $message = $gL10n->get('SYS_SERVER_NO_UPLOAD');\n}\n\n// if necessary create the module folders in adm_my_files\nswitch ($getCKEditor) {\n    case 'ann_description':\n        $folderName = 'announcements';\n        break;\n    case 'dat_description':\n        $folderName = 'dates';\n        break;\n    case 'lnk_description':\n        $folderName = 'weblinks';\n        break;\n    case 'msg_body':\n        $folderName = 'mail';\n        break;\n    case 'room_description':\n        $folderName = 'rooms';\n        break;\n    case 'usf_description':\n        $folderName = 'user_fields';\n        break;\n    default:\n        $folderName = 'plugins';\n        break;\n}\n\ntry {\n    $imagesPath = ADMIDIO_PATH . FOLDER_DATA . '/' . $folderName . '/images';\n\n    FileSystemUtils::createDirectoryIfNotExists($imagesPath);\n\n    // create a filename with a timestamp and a 16 chars secure-random string,\n    // so we have a scheme for the filenames and the risk of duplicates is negligible.\n    // Format: 20180131-123456_0123456789abcdef.jpg\n    $filename = FileSystemUtils::getGeneratedFilename($_FILES['upload']['name']);\n\n    $htmlUrl = SecurityUtils::encodeUrl(ADMIDIO_URL . '/adm_program/system/show_image.php', array('module' => $folderName, 'file' => $filename));\n\n    move_uploaded_file($_FILES['upload']['tmp_name'], $imagesPath . '/' . $filename);\n} catch (\\RuntimeException $exception) {\n    $message = $exception->getMessage();\n}\n\n// now call CKEditor function and send photo data\necho '<!DOCTYPE html>\n<html>\n    <body>\n        <script type=\"text/javascript\">\n            window.parent.CKEDITOR.tools.callFunction('.$getCKEditorFuncNum.', \"'.$htmlUrl.'\", \"'.$message.'\");\n        </script>\n    </body>\n</html>';\n", "<?php\n/**\n ***********************************************************************************************\n * This class handles the most necessary file-system operations\n *\n * @copyright 2004-2023 The Admidio Team\n * @see https://www.admidio.org/\n * @license https://www.gnu.org/licenses/gpl-2.0.html GNU General Public License v2.0 only\n ***********************************************************************************************\n */\n\n/**\n * This class handles the most necessary file-system operations like:\n * - Function: get normalized path, get human readable bytes, restrict all operations to specific directories\n * - Info: disk space, process owner/group info, path owner/group info, is path owner, path mode, path permissions\n * - Folder: create, is empty, get content, delete content, delete folder, copy, move, chmod\n * - File: delete, copy, move, chmod, read, write\n */\nfinal class FileSystemUtils\n{\n    public const CONTENT_TYPE_DIRECTORY = 'directory';\n    public const CONTENT_TYPE_FILE      = 'file';\n    public const CONTENT_TYPE_LINK      = 'link';\n\n    public const ROOT_ID = 0;\n    public const ROOT_FOLDER = '/';\n\n    public const DEFAULT_MODE_DIRECTORY = 0775;\n    public const DEFAULT_MODE_FILE      = 0664;\n\n    /**\n     * @var array<int,string> The allowed directories\n     */\n    private static $allowedDirectories = array();\n\n    /**\n     * @var array<string,string> Array with file extensions and the best Font Awesome icon that should be used\n     */\n    private static $iconFileExtension = array(\n        'bmp'  => array('icon' => 'fa-file-image', 'mime-type' => 'image/bmp', 'viewable' => true),\n        'gif'  => array('icon' => 'fa-file-image', 'mime-type' => 'image/gif', 'viewable' => true),\n        'jpg'  => array('icon' => 'fa-file-image', 'mime-type' => 'image/jpeg', 'viewable' => true),\n        'jpeg' => array('icon' => 'fa-file-image', 'mime-type' => 'image/jpeg', 'viewable' => true),\n        'png'  => array('icon' => 'fa-file-image', 'mime-type' => 'image/png', 'viewable' => true),\n        'tiff' => array('icon' => 'fa-file-image', 'mime-type' => 'image/tiff', 'viewable' => true),\n        'doc'  => array('icon' => 'fa-file-word', 'mime-type' => 'application/msword', 'viewable' => false),\n        'docx' => array('icon' => 'fa-file-word', 'mime-type' => 'application/msword', 'viewable' => false),\n        'dot'  => array('icon' => 'fa-file-word', 'mime-type' => 'application/msword', 'viewable' => false),\n        'dotx' => array('icon' => 'fa-file-word', 'mime-type' => 'application/msword', 'viewable' => false),\n        'odt'  => array('icon' => 'fa-file-word', 'mime-type' => 'application/vnd.oasis.opendocument.text', 'viewable' => false),\n        'csv'  => array('icon' => 'fa-file-excel', 'mime-type' => 'text/comma-separated-values', 'viewable' => false),\n        'xls'  => array('icon' => 'fa-file-excel', 'mime-type' => 'application/msexcel', 'viewable' => false),\n        'xlsx' => array('icon' => 'fa-file-excel', 'mime-type' => 'application/msexcel', 'viewable' => false),\n        'xlt'  => array('icon' => 'fa-file-excel', 'mime-type' => 'application/msexcel', 'viewable' => false),\n        'xltx' => array('icon' => 'fa-file-excel', 'mime-type' => 'application/msexcel', 'viewable' => false),\n        'ods'  => array('icon' => 'fa-file-excel', 'mime-type' => 'application/vnd.oasis.opendocument.spreadsheet', 'viewable' => false),\n        'pps'  => array('icon' => 'fa-file-powerpoint', 'mime-type' => 'application/mspowerpoint', 'viewable' => false),\n        'ppsx' => array('icon' => 'fa-file-powerpoint', 'mime-type' => 'application/mspowerpoint', 'viewable' => false),\n        'ppt'  => array('icon' => 'fa-file-powerpoint', 'mime-type' => 'application/mspowerpoint', 'viewable' => false),\n        'pptx' => array('icon' => 'fa-file-powerpoint', 'mime-type' => 'application/mspowerpoint', 'viewable' => false),\n        'odp'  => array('icon' => 'fa-file-powerpoint', 'mime-type' => 'application/vnd.oasis.opendocument.presentation', 'viewable' => false),\n        'css'  => array('icon' => 'fa-file-alt', 'mime-type' => 'text/css', 'viewable' => true),\n        'log'  => array('icon' => 'fa-file-alt', 'mime-type' => 'text/plain', 'viewable' => true),\n        'md'   => array('icon' => 'fa-file-alt', 'mime-type' => 'text/plain', 'viewable' => true),\n        'rtf'  => array('icon' => 'fa-file-alt', 'mime-type' => 'text/rtf', 'viewable' => false),\n        'txt'  => array('icon' => 'fa-file-alt', 'mime-type' => 'text/plain', 'viewable' => true),\n        'pdf'  => array('icon' => 'fa-file-pdf', 'mime-type' => 'application/pdf', 'viewable' => true),\n        'gz'   => array('icon' => 'fa-file-archive', 'mime-type' => 'application/gzip', 'viewable' => false),\n        'tar'  => array('icon' => 'fa-file-archive', 'mime-type' => 'application/x-tar', 'viewable' => false),\n        'zip'  => array('icon' => 'fa-file-archive', 'mime-type' => 'application/zip', 'viewable' => false),\n        'avi'  => array('icon' => 'fa-file-video', 'mime-type' => 'video/x-msvideo', 'viewable' => true),\n        'flv'  => array('icon' => 'fa-file-video', 'mime-type' => 'video/x-flv', 'viewable' => true),\n        'mov'  => array('icon' => 'fa-file-video', 'mime-type' => 'video/quicktime', 'viewable' => true),\n        'mp4'  => array('icon' => 'fa-file-video', 'mime-type' => 'video/mp4', 'viewable' => true),\n        'mpeg' => array('icon' => 'fa-file-video', 'mime-type' => 'video/mpeg', 'viewable' => true),\n        'mpg'  => array('icon' => 'fa-file-video', 'mime-type' => 'video/mpeg', 'viewable' => true),\n        'webm' => array('icon' => 'fa-file-video', 'mime-type' => 'video/webm', 'viewable' => true),\n        'wmv'  => array('icon' => 'fa-file-video', 'mime-type' => 'video/x-ms-wmv', 'viewable' => true),\n        'aac'  => array('icon' => 'fa-file-audio', 'mime-type' => 'audio/aac', 'viewable' => true),\n        'midi' => array('icon' => 'fa-file-audio', 'mime-type' => 'audio/x-midi', 'viewable' => true),\n        'mp3'  => array('icon' => 'fa-file-audio', 'mime-type' => 'audio/mpeg3', 'viewable' => true),\n        'wav'  => array('icon' => 'fa-file-audio', 'mime-type' => 'audio/x-midi', 'viewable' => true),\n        'wma'  => array('icon' => 'fa-file-audio', 'mime-type' => 'audio/x-ms-wma', 'viewable' => true)\n    );\n\n    /**\n     * Check if the file extension of the current file format is allowed for upload and the\n     * documents and files module.\n     * @param string $fileExtension The file extension that should be checked.\n     * @return bool Return true if the file extension is allowed to be used within Admidio.\n     */\n    public static function allowedFileExtension($fileExtension)\n    {\n        if (array_key_exists($fileExtension, self::$iconFileExtension)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks if file-system is UNIX\n     * @return bool Returns true if file-system is UNIX\n     */\n    public static function isUnix()\n    {\n        return DIRECTORY_SEPARATOR === '/';\n    }\n\n    /**\n     * Checks if file-system is UNIX and the POSIX functions are installed\n     * @return bool Returns true if file-system is UNIX and POSIX functions are installed\n     */\n    public static function isUnixWithPosix()\n    {\n        return self::isUnix() && function_exists('posix_getpwuid');\n    }\n\n    /**\n     * Checks if all preconditions are fulfilled\n     * @param string             $oldDirectoryPath The source directory\n     * @param string             $newDirectoryPath The destination directory\n     * @param array<string,bool> $options          Operation options ([bool] createDirectoryStructure = true, [bool] overwriteContent = false)\n     * @throws \\UnexpectedValueException Throws if source directory is not readable, destination directory is not writable or a collision is detected\n     * @throws \\RuntimeException         Throws if the mkdir or opendir process fails\n     * @return bool Returns true if content will get overwritten\n     */\n    private static function checkDirectoryPreconditions($oldDirectoryPath, $newDirectoryPath, array $options = array())\n    {\n        self::checkIsInAllowedDirectories($oldDirectoryPath);\n        self::checkIsInAllowedDirectories($newDirectoryPath);\n\n        $defaultOptions = array('createDirectoryStructure' => true, 'overwriteContent' => false);\n        $options = array_merge($defaultOptions, $options);\n\n        if (!is_dir($oldDirectoryPath)) {\n            throw new \\UnexpectedValueException('Source directory \"' . $oldDirectoryPath . '\" does not exist!');\n        }\n        if (!is_readable($oldDirectoryPath)) {\n            throw new \\UnexpectedValueException('Source directory \"' . $oldDirectoryPath . '\" is not readable!');\n        }\n\n        if (!is_dir($newDirectoryPath)) {\n            if ($options['createDirectoryStructure']) {\n                self::createDirectoryIfNotExists($newDirectoryPath);\n\n                return false;\n            }\n\n            throw new \\UnexpectedValueException('Destination directory \"' . $newDirectoryPath . '\" does not exist!');\n        }\n        if (self::isUnix() && !is_executable($newDirectoryPath)) {\n            throw new \\UnexpectedValueException('Destination directory \"' . $newDirectoryPath . '\" is not executable!');\n        }\n        if (!is_writable($newDirectoryPath)) {\n            throw new \\UnexpectedValueException('Destination directory \"' . $newDirectoryPath . '\" is not writable!');\n        }\n\n        $oldDirectoryContentTree = self::getDirectoryContent($oldDirectoryPath, true, false);\n        $newDirectoryContentTree = self::getDirectoryContent($newDirectoryPath, true, false);\n\n        $collision = self::checkDirectoryContentTreeCollisions($oldDirectoryContentTree, $newDirectoryContentTree);\n        if (!$collision) {\n            return false;\n        }\n        if ($options['overwriteContent']) {\n            return true;\n        }\n\n        throw new \\UnexpectedValueException('Destination directory \"' . $newDirectoryPath . '\" has collisions!');\n    }\n\n    /**\n     * Checks if two directories have same files or directories\n     * @param array<string,string|array> $directoryContentTree1       Thirst directory to check\n     * @param array<string,string|array> $directoryContentTree2       Second directory to check\n     * @param bool                       $considerDirectoryCollisions If true, also directory collisions are checked\n     * @return bool Returns true if both directories has same files or directories\n     */\n    private static function checkDirectoryContentTreeCollisions(array $directoryContentTree1, array $directoryContentTree2, $considerDirectoryCollisions = false)\n    {\n        foreach ($directoryContentTree1 as $directoryContentName => $directoryContentType1) {\n            if (array_key_exists($directoryContentName, $directoryContentTree2)) {\n                if ($considerDirectoryCollisions) {\n                    return true;\n                }\n\n                $directoryContentType2 = $directoryContentTree2[$directoryContentName];\n\n                if (!is_array($directoryContentType1) || !is_array($directoryContentType2)) {\n                    return true;\n                }\n\n                $collision = self::checkDirectoryContentTreeCollisions($directoryContentType1, $directoryContentType2, $considerDirectoryCollisions);\n                if ($collision) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks the preconditions for tile copy and move\n     * @param string             $mode        The operation mode (copy or move)\n     * @param string             $oldFilePath The source path\n     * @param string             $newFilePath The destination path\n     * @param array<string,bool> $options     Operation options ([bool] createDirectoryStructure = true, [bool] overwrite = false)\n     * @throws \\UnexpectedValueException Throws if a precondition is not fulfilled\n     * @throws \\RuntimeException         Throws if the destination folder could not be created\n     * @return bool Returns true if the destination path will be overwritten\n     */\n    private static function checkFilePreconditions($mode, $oldFilePath, $newFilePath, array $options = array())\n    {\n        $defaultOptions = array('createDirectoryStructure' => true, 'overwrite' => false);\n        $options = array_merge($defaultOptions, $options);\n\n        self::checkIsInAllowedDirectories($oldFilePath);\n        self::checkIsInAllowedDirectories($newFilePath);\n\n        $oldParentDirectoryPath = dirname($oldFilePath);\n        if (self::isUnix() && !is_executable($oldParentDirectoryPath)) {\n            throw new \\UnexpectedValueException('Source parent directory \"' . $oldParentDirectoryPath . '\" is not executable!');\n        }\n        if ($mode === 'move' && !is_writable($oldParentDirectoryPath)) {\n            throw new \\UnexpectedValueException('Source parent directory \"' . $oldParentDirectoryPath . '\" is not writable!');\n        }\n\n        if (!is_file($oldFilePath)) {\n            throw new \\UnexpectedValueException('Source file \"' . $oldFilePath . '\" does not exist!');\n        }\n        if ($mode === 'copy' && !is_readable($oldFilePath)) {\n            throw new \\UnexpectedValueException('Source file \"' . $oldFilePath . '\" is not readable!');\n        }\n\n        $newParentDirectoryPath = dirname($newFilePath);\n        if (!is_dir($newParentDirectoryPath)) {\n            if ($options['createDirectoryStructure']) {\n                self::createDirectoryIfNotExists($newParentDirectoryPath);\n\n                return false;\n            }\n\n            throw new \\UnexpectedValueException('Destination parent directory \"' . $newParentDirectoryPath . '\" does not exist!');\n        }\n        if (self::isUnix() && !is_executable($newParentDirectoryPath)) {\n            throw new \\UnexpectedValueException('Destination parent directory \"' . $newParentDirectoryPath . '\" is not executable!');\n        }\n        if (!is_writable($newParentDirectoryPath)) {\n            throw new \\UnexpectedValueException('Destination parent directory \"' . $newParentDirectoryPath . '\" is not writable!');\n        }\n\n        if (!is_file($newFilePath)) {\n            return false;\n        }\n        if ($options['overwrite']) {\n            return true;\n        }\n\n        throw new \\UnexpectedValueException('Destination file \"' . $newFilePath . '\" already exist!');\n    }\n\n    /**\n     * Checks if a given path is in the allowed directories\n     * @param string $path The path to check\n     * @throws \\RuntimeException Throws if the given path is not in an allowed directory\n     */\n    private static function checkIsInAllowedDirectories(&$path)\n    {\n        $path = self::getNormalizedPath($path);\n\n        if (count(self::$allowedDirectories) === 0) {\n            return;\n        }\n\n        foreach (self::$allowedDirectories as $allowedDirectory) {\n            if (strpos($path, $allowedDirectory) === 0) {\n                return;\n            }\n        }\n\n        throw new \\RuntimeException('Path \"' . $path . '\" is not in allowed directory!');\n    }\n\n    /**\n     * Checks if the parent directory is executable and the path exist\n     * @param string $path The path to check\n     * @throws \\UnexpectedValueException Throws if path does not exist or parent directory is not executable\n     */\n    private static function checkParentDirExecAndPathExist($path)\n    {\n        $parentDirectoryPath = dirname($path);\n        if (self::isUnix() && !is_executable($parentDirectoryPath)) {\n            throw new \\UnexpectedValueException('Parent directory \"' . $parentDirectoryPath . '\" is not executable!');\n        }\n\n        if (!file_exists($path)) {\n            throw new \\UnexpectedValueException('Path \"' . $path . '\" does not exist!');\n        }\n    }\n\n    /**\n     * Chmod a directory and optional recursive all subdirectories and files\n     * @param string $directoryPath   The directory to chmod\n     * @param int    $mode            The mode to set, in octal notation (e.g. 0775)\n     * @param bool   $recursive       If true, subdirectories are chmod too\n     * @param bool   $onlyDirectories If true, only directories gets chmod. If false all content gets chmod\n     * @throws \\UnexpectedValueException Throws if process is not directory owner\n     * @throws \\RuntimeException         Throws if the chmod or opendir process fails\n     * @see https://www.php.net/manual/en/function.chmod.php\n     */\n    public static function chmodDirectory($directoryPath, $mode = self::DEFAULT_MODE_DIRECTORY, $recursive = false, $onlyDirectories = true)\n    {\n        if (!self::isUnixWithPosix()) {\n            throw new \\RuntimeException('\"FileSystemUtils::chmodDirectory()\" is only available on systems with POSIX support!');\n        }\n\n        self::checkIsInAllowedDirectories($directoryPath);\n\n        if (!is_dir($directoryPath)) {\n            throw new \\UnexpectedValueException('Directory \"' . $directoryPath . '\" does not exist!');\n        }\n\n        if (!self::hasPathOwnerRight($directoryPath)) {\n            throw new \\UnexpectedValueException('Directory \"' . $directoryPath . '\" owner is different to process owner!');\n        }\n\n        $chmodResult = chmod($directoryPath, $mode);\n        if (!$chmodResult) {\n            throw new \\RuntimeException('Directory \"' . $directoryPath . '\" mode cannot be changed!');\n        }\n\n        if ($recursive) {\n            $directoryContent = self::getDirectoryContent($directoryPath);\n\n            foreach ($directoryContent as $entryPath => $type) {\n                if ($type === self::CONTENT_TYPE_DIRECTORY) {\n                    self::chmodDirectory($entryPath, $mode, $recursive, $onlyDirectories);\n                } elseif (!$onlyDirectories) {\n                    self::chmodFile($entryPath, $mode);\n                }\n            }\n        }\n    }\n\n    /**\n     * @param string $filePath The file to chmod\n     * @param int    $mode     The mode to set in octal notation (e.g. 0664)\n     * @throws \\UnexpectedValueException Throws if the file does not exist or is not chmod-able\n     * @throws \\RuntimeException         Throws if the chmod process fails\n     * @see https://www.php.net/manual/en/function.chmod.php\n     */\n    public static function chmodFile($filePath, $mode = self::DEFAULT_MODE_FILE)\n    {\n        if (!self::isUnixWithPosix()) {\n            throw new \\RuntimeException('\"FileSystemUtils::chmodFile()\" is only available on systems with POSIX support!');\n        }\n\n        self::checkIsInAllowedDirectories($filePath);\n\n        $parentDirectoryPath = dirname($filePath);\n        if (self::isUnix() && !is_executable($parentDirectoryPath)) {\n            throw new \\UnexpectedValueException('Parent directory \"' . $parentDirectoryPath . '\" is not executable!');\n        }\n\n        if (!is_file($filePath)) {\n            throw new \\UnexpectedValueException('File \"' . $filePath . '\" does not exist!');\n        }\n        if (!self::hasPathOwnerRight($filePath)) {\n            throw new \\UnexpectedValueException('File \"' . $filePath . '\" owner is different to process owner!');\n        }\n\n        $chmodResult = chmod($filePath, $mode);\n        if (!$chmodResult) {\n            throw new \\RuntimeException('File \"' . $filePath . '\" mode cannot be changed!');\n        }\n    }\n\n    /**\n     * Convert file permissions to string representation\n     * @param int $perms The file permissions\n     * @return string Returns file permissions in string representation\n     * @see https://www.php.net/manual/en/function.fileperms.php\n     */\n    private static function convertPermsToString($perms)\n    {\n        switch ($perms & 0xF000) {\n            case 0xC000: // Socket\n                $info = 's';\n                break;\n            case 0xA000: // Symbolic Link\n                $info = 'l';\n                break;\n            case 0x8000: // Regular\n                $info = '-'; // r\n                break;\n            case 0x6000: // Block special\n                $info = 'b';\n                break;\n            case 0x4000: // Directory\n                $info = 'd';\n                break;\n            case 0x2000: // Character special\n                $info = 'c';\n                break;\n            case 0x1000: // FIFO pipe\n                $info = 'p';\n                break;\n            default: // unknown\n                $info = 'u';\n        }\n\n        // User\n        $info .= (($perms & 0x0100) ? 'r' : '-');\n        $info .= (($perms & 0x0080) ? 'w' : '-');\n        $info .= (($perms & 0x0040)\n            ? (($perms & 0x0800) ? 's' : 'x')\n            : (($perms & 0x0800) ? 'S' : '-'));\n\n        // Group\n        $info .= (($perms & 0x0020) ? 'r' : '-');\n        $info .= (($perms & 0x0010) ? 'w' : '-');\n        $info .= (($perms & 0x0008)\n            ? (($perms & 0x0400) ? 's' : 'x')\n            : (($perms & 0x0400) ? 'S' : '-'));\n\n        // Other\n        $info .= (($perms & 0x0004) ? 'r' : '-');\n        $info .= (($perms & 0x0002) ? 'w' : '-');\n        $info .= (($perms & 0x0001)\n            ? (($perms & 0x0200) ? 't' : 'x')\n            : (($perms & 0x0200) ? 'T' : '-'));\n\n        return $info;\n    }\n\n    /**\n     * Copies a directory\n     * @param string             $oldDirectoryPath The directory to copy\n     * @param string             $newDirectoryPath The destination directory\n     * @param array<string,bool> $options          Operation options ([bool] createDirectoryStructure = true, [bool] overwriteContent = false)\n     * @throws \\UnexpectedValueException Throws if a precondition is not fulfilled\n     * @throws \\RuntimeException         Throws if the mkdir, copy or opendir process fails\n     * @return bool Returns true if content was overwritten\n     */\n    public static function copyDirectory($oldDirectoryPath, $newDirectoryPath, array $options = array())\n    {\n        $returnValue = self::checkDirectoryPreconditions($oldDirectoryPath, $newDirectoryPath, $options);\n\n        self::doCopyDirectory($oldDirectoryPath, $newDirectoryPath);\n\n        return $returnValue;\n    }\n\n    /**\n     * Copies a file\n     * @param string             $oldFilePath The file to copy\n     * @param string             $newFilePath The path where to copy to\n     * @param array<string,bool> $options     Operation options ([bool] createDirectoryStructure = true, [bool] overwrite = false)\n     * @throws \\UnexpectedValueException Throws if a precondition is not fulfilled\n     * @throws \\RuntimeException         Throws if the copy process fails\n     * @return bool Returns true if the destination path was overwritten\n     * @see https://www.php.net/manual/en/function.copy.php\n     */\n    public static function copyFile($oldFilePath, $newFilePath, array $options = array())\n    {\n        $returnValue = self::checkFilePreconditions('copy', $oldFilePath, $newFilePath, $options);\n\n        $copyResult = copy($oldFilePath, $newFilePath);\n        if (!$copyResult) {\n            throw new \\RuntimeException('File \"' . $oldFilePath . '\" cannot be copied!');\n        }\n\n        return $returnValue;\n    }\n\n    /**\n     * Creates a directory if it already did not exist\n     * @param string              $directoryPath The directory to create\n     * @param array<string,mixed> $options       Operation options ([int] mode = 0775, [int] modeParents = 0775, [bool] createDirectoryStructure = true)\n     * @throws \\UnexpectedValueException Throws if the parent directory is not writable\n     * @throws \\RuntimeException         Throws if the mkdir process fails\n     * @return bool Returns true if directory was successfully created or false if directory did already exist\n     * @see https://www.php.net/manual/en/function.mkdir.php\n     */\n    public static function createDirectoryIfNotExists($directoryPath, array $options = array())\n    {\n        self::checkIsInAllowedDirectories($directoryPath);\n\n        $defaultOptions = array('mode' => self::DEFAULT_MODE_DIRECTORY, 'modeParents' => self::DEFAULT_MODE_DIRECTORY, 'createDirectoryStructure' => true);\n        $options = array_merge($defaultOptions, $options);\n\n        if (is_dir($directoryPath)) {\n            return false;\n        }\n\n        $parentDirectoryPath = dirname($directoryPath);\n        if (!is_dir($parentDirectoryPath)) {\n            if ($options['createDirectoryStructure']) {\n                $parentOptions = $options;\n                $parentOptions['mode'] = $options['modeParents'];\n                self::createDirectoryIfNotExists($parentDirectoryPath, $parentOptions);\n            } else {\n                throw new \\UnexpectedValueException('Parent directory \"' . $parentDirectoryPath . '\" does not exist!');\n            }\n        }\n        if (self::isUnix() && !is_executable($parentDirectoryPath)) {\n            throw new \\UnexpectedValueException('Parent directory \"' . $parentDirectoryPath . '\" is not executable!');\n        }\n        if (!is_writable($parentDirectoryPath)) {\n            throw new \\UnexpectedValueException('Parent directory \"' . $parentDirectoryPath . '\" is not writable!');\n        }\n\n        $mkdirResult = mkdir($directoryPath, $options['mode']);\n        if (!$mkdirResult) {\n            throw new \\RuntimeException('Directory \"' . $directoryPath . '\" cannot be created!');\n        }\n\n        if (self::isUnixWithPosix()) {\n            if (!self::hasPathOwnerRight($directoryPath)) {\n                throw new \\UnexpectedValueException('Directory \"' . $directoryPath . '\" owner is different to process owner!');\n            }\n\n            $chmodResult = chmod($directoryPath, $options['mode']);\n            if (!$chmodResult) {\n                throw new \\RuntimeException('Directory \"' . $directoryPath . '\" mode cannot be changed!');\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Deletes the content of a directory\n     * @param string $directoryPath The directory where to delete the content\n     * @throws \\UnexpectedValueException Throws if directory is not writable and readable\n     * @throws \\RuntimeException         Throws if the unlink, rmdir or opendir process fails\n     * @return bool Returns true if directory content was successfully deleted or false if directory was already empty\n     * @see https://www.php.net/manual/en/function.opendir.php\n     * @see https://www.php.net/manual/en/function.readdir.php\n     */\n    public static function deleteDirectoryContentIfExists($directoryPath)\n    {\n        self::checkIsInAllowedDirectories($directoryPath);\n\n        if (!is_dir($directoryPath)) {\n            throw new \\UnexpectedValueException('Directory \"' . $directoryPath . '\" does not exist!');\n        }\n\n        if (self::isDirectoryEmpty($directoryPath)) {\n            return false;\n        }\n\n        if (!is_writable($directoryPath)) {\n            throw new \\UnexpectedValueException('Directory \"' . $directoryPath . '\" is not writable!');\n        }\n        if (!is_readable($directoryPath)) {\n            throw new \\UnexpectedValueException('Directory \"' . $directoryPath . '\" is not readable!');\n        }\n\n        $dirHandle = opendir($directoryPath);\n        if ($dirHandle === false) {\n            throw new \\RuntimeException('Directory \"' . $directoryPath . '\" cannot be opened!');\n        }\n\n        while (($entry = readdir($dirHandle)) !== false) {\n            if ($entry === '.' || $entry === '..') {\n                continue;\n            }\n\n            $directoryEntry = $directoryPath . DIRECTORY_SEPARATOR . $entry;\n\n            if (is_dir($directoryEntry)) {\n                self::deleteDirectoryIfExists($directoryEntry, true);\n            } else {\n                self::deleteFileIfExists($directoryEntry);\n            }\n        }\n        closedir($dirHandle);\n\n        return true;\n    }\n\n    /**\n     * Deletes a directory if it exists\n     * @param string $directoryPath     The directory to delete\n     * @param bool   $deleteWithContent If true, directory will also be deleted if directory is not empty\n     * @throws \\UnexpectedValueException Throws if the parent directory is not writable\n     * @throws \\RuntimeException         Throws if the rmdir or opendir process fails\n     * @return bool Returns true if directory was successfully deleted or false if directory already did not exist\n     * @see https://www.php.net/manual/en/function.rmdir.php\n     */\n    public static function deleteDirectoryIfExists($directoryPath, $deleteWithContent = false)\n    {\n        self::checkIsInAllowedDirectories($directoryPath);\n\n        if ($directoryPath === self::ROOT_FOLDER) {\n            throw new \\UnexpectedValueException('Directory \"' . self::ROOT_FOLDER . '\" cannot be deleted!');\n        }\n\n        $parentDirectoryPath = dirname($directoryPath);\n        if (self::isUnix() && !is_executable($parentDirectoryPath)) {\n            throw new \\UnexpectedValueException('Parent directory \"' . $parentDirectoryPath . '\" is not executable!');\n        }\n        if (!is_dir($directoryPath)) {\n            return false;\n        }\n\n        if (!self::isDirectoryEmpty($directoryPath)) {\n            if ($deleteWithContent) {\n                self::deleteDirectoryContentIfExists($directoryPath);\n            } else {\n                throw new \\UnexpectedValueException('Directory \"' . $directoryPath . '\" is not empty!');\n            }\n        }\n\n        if (!is_writable($parentDirectoryPath)) {\n            throw new \\UnexpectedValueException('Parent directory \"' . $parentDirectoryPath . '\" is not writable!');\n        }\n\n        $rmdirResult = rmdir($directoryPath);\n        if (!$rmdirResult) {\n            throw new \\RuntimeException('Directory \"' . $directoryPath . '\" cannot be deleted!');\n        }\n\n        return true;\n    }\n\n    /**\n     * Deletes a file if it exists\n     * @param string $filePath The file to delete\n     * @throws UnexpectedValueException Throws if the file is not writable\n     * @throws RuntimeException         Throws if the delete process fails\n     * @return bool Returns true if file was successfully deleted or false if file already did not exist\n     * @see https://www.php.net/manual/en/function.unlink.php\n     */\n    public static function deleteFileIfExists($filePath)\n    {\n        self::checkIsInAllowedDirectories($filePath);\n\n        $parentDirectoryPath = dirname($filePath);\n        if (self::isUnix() && !is_executable($parentDirectoryPath)) {\n            throw new UnexpectedValueException('Parent directory \"' . $parentDirectoryPath . '\" is not executable!');\n        }\n        if (!is_writable($parentDirectoryPath)) {\n            throw new UnexpectedValueException('Parent directory \"' . $parentDirectoryPath . '\" is not writable!');\n        }\n\n        if (!is_file($filePath)) {\n            return false;\n        }\n\n        $unlinkResult = unlink($filePath);\n        if (!$unlinkResult) {\n            throw new RuntimeException('File \"' . $filePath . '\" cannot be deleted!');\n        }\n\n        return true;\n    }\n\n    /**\n     * Execute the copy process to copy a directory\n     * @param string $oldDirectoryPath The directory to copy\n     * @param string $newDirectoryPath The destination directory\n     * @throws \\UnexpectedValueException Throws if a precondition is not fulfilled\n     * @throws \\RuntimeException         Throws if the mkdir, copy or opendir process fails\n     */\n    private static function doCopyDirectory($oldDirectoryPath, $newDirectoryPath)\n    {\n        $oldDirectoryContent = self::getDirectoryContent($oldDirectoryPath, false, false);\n\n        foreach ($oldDirectoryContent as $entry => $type) {\n            $oldEntryPath = $oldDirectoryPath . DIRECTORY_SEPARATOR . $entry;\n            $newEntryPath = $newDirectoryPath . DIRECTORY_SEPARATOR . $entry;\n\n            if ($type === self::CONTENT_TYPE_DIRECTORY) {\n                if (!is_dir($newEntryPath)) {\n                    self::createDirectoryIfNotExists($newEntryPath);\n                }\n\n                self::doCopyDirectory($oldEntryPath, $newEntryPath);\n            } else {\n                self::copyFile($oldEntryPath, $newEntryPath, array('overwrite' => true));\n            }\n        }\n    }\n\n    /**\n     * Gets the total, free and used disk space in bytes\n     * @param string $path Path of the filesystem\n     * @throws \\RuntimeException Throws if the given path is not in an allowed directory or disk-space could not be determined\n     * @return array<string,float> Returns the total, free and used disk space in bytes\n     * @see https://www.php.net/manual/en/function.disk-total-space.php\n     * @see https://www.php.net/manual/en/function.disk-free-space.php\n     * @example array(\"total\" => 10737418240, \"free\" => 2147483648, \"used\" => 8589934592)\n     */\n    public static function getDiskSpace($path = self::ROOT_FOLDER)\n    {\n        self::checkIsInAllowedDirectories($path);\n\n        $total = function_exists('disk_total_space') ? disk_total_space($path) : false;\n        if ($total === false) {\n            throw new \\RuntimeException('Total disk-space could not be determined!');\n        }\n\n        $free = function_exists('disk_free_space') ? disk_free_space($path) : false;\n        if ($free === false) {\n            throw new \\RuntimeException('Free disk-space could not be determined!');\n        }\n\n        $used = $total - $free;\n\n        return array('total' => $total, 'free' => $free, 'used' => $used);\n    }\n\n    /**\n     * Get the relevant Font Awesome icon for the current file\n     * @return string Returns the name of the Font Awesome icon\n     */\n    public static function getFileFontAwesomeIcon($filename)\n    {\n        $iconFile = 'fa-file';\n        $fileExtension = strtolower(pathinfo($filename, PATHINFO_EXTENSION));\n\n\n        if (array_key_exists($fileExtension, self::$iconFileExtension)) {\n            $iconFile = self::$iconFileExtension[$fileExtension]['icon'];\n        }\n\n        return $iconFile;\n    }\n\n    /**\n     * Get the MIME type of the current file e.g. 'image/jpeg'\n     * @return string MIME type of the current file\n     */\n    public static function getFileMimeType($filename)\n    {\n        $mimeType = 'application/octet-stream';\n        $fileExtension = strtolower(pathinfo($filename, PATHINFO_EXTENSION));\n\n        if (array_key_exists($fileExtension, self::$iconFileExtension)) {\n            $mimeType = self::$iconFileExtension[$fileExtension]['mime-type'];\n        }\n\n        return $mimeType;\n    }\n\n    /**\n     * Get a generated filename with a timestamp and a secure random identifier\n     * @param string $filename The original filename\n     * @throws AdmException Throws if secure random identifier could not be generated\n     * @return string Returns the generated filename\n     * @example \"IMG_123456.JPG\" => \"20180131-123456_0123456789abcdef.jpg\"\n     */\n    public static function getGeneratedFilename($filename)\n    {\n        $extension = pathinfo($filename, PATHINFO_EXTENSION);\n        $now = new \\DateTime();\n\n        return $now->format('Ymd-His') . '_' . SecurityUtils::getRandomString(16, $charset = '0123456789abcdefghijklmnopqrstuvwxyz') . '.' . strtolower($extension);\n    }\n\n    /**\n     * Get a from special-characters clean path-entry\n     * @param string $pathname The path-entry to clean\n     * @param string $replacer The character to replace spacial-characters with\n     * @return string Returns the special-characters cleaned path-entry\n     * @example \"image-12#34+\u00df.jpg\" => \"image-12_34__.jpg\"\n     */\n    public static function getSanitizedPathEntry($pathname, $replacer = '_')\n    {\n        return preg_replace('/[^A-Za-z0-9._-]/u', $replacer, $pathname);\n    }\n\n    /**\n     * Get a normalized/simplified path\n     * @param string $path The path to normalize\n     * @throws \\UnexpectedValueException Throws if the given path is higher than root\n     * @return string Returns the normalized path\n     * @see https://www.php.net/manual/en/function.realpath.php\n     * @example \"/path/to/test/.././..//..///..///../one/two/../three/filename\" => \"../../one/three/filename\"\n     */\n    public static function getNormalizedPath($path)\n    {\n        $path = str_replace('\\\\', '/', $path); // Replace back-slashes with forward-slashes\n        $path = preg_replace('/\\/+/', '/', $path); // Combine multiple slashes into a single slash\n\n        $segments = explode('/', $path);\n\n        $parts = array();\n        foreach ($segments as $segment) {\n            if ($segment === '.') {\n                // Actual directory => ignore\n                continue;\n            }\n\n            $test = array_pop($parts);\n            if ($test === null) {\n                // No path added => add first path\n                $parts[] = $segment;\n            } elseif ($segment === '..') {\n                if ($test === '..') {\n                    // Change to grand-parent directory => add two times \"..\"\n                    $parts[] = $test;\n                    $parts[] = $segment;\n                } elseif ($test === '') {\n                    // File-system root => higher as root is not possible/valid => throw Exception\n                    throw new \\UnexpectedValueException('Path \"' . $path . '\" is higher than root!');\n                }\n//                else\n//                {\n//                    // Change to parent directory => ignore\n//                }\n            } else {\n                // New sub-path => add parent path and new path\n                $parts[] = $test;\n                $parts[] = $segment;\n            }\n        }\n\n        return implode(DIRECTORY_SEPARATOR, $parts);\n    }\n\n    /**\n     * Gets human readable bytes with unit\n     * @param int  $bytes The bytes\n     * @param bool $si    Use SI or binary unit. Set true for SI units\n     * @return string Returns human readable bytes with unit.\n     * @example \"[value] [unit]\" (e.g: 34.5 MiB)\n     */\n    public static function getHumanReadableBytes($bytes, $si = false)\n    {\n        $divider = 1024;\n        $units = array('B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'YiB');\n        if ($si) {\n            $divider = 1000;\n            $units = array('B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'YB');\n        }\n\n        $iteration = 0;\n        while ($bytes >= $divider) {\n            ++$iteration;\n            $bytes /= $divider;\n        }\n\n        $unit = $units[$iteration];\n\n        return round($bytes, 3 - (int) floor(log10($bytes))) . ' ' . $unit;\n    }\n\n    /**\n     * Gets info about the php-process owner\n     * @throws \\RuntimeException Throws if system does not support POSIX\n     * @return array<string,string|int> Returns info about the php-process owner\n     * @see https://www.php.net/manual/en/function.posix-geteuid.php\n     * @see https://www.php.net/manual/en/function.posix-getpwuid.php\n     * @example\n     * array(\n     *     \"name\" => \"max\", \"passwd\" => \"x\", \"uid\" => 1000, \"gid\" => 1000,\n     *     \"gecos\" => \"max,,,\", \"dir\" => \"/home/max\", \"shell\" => \"/bin/bash\"\n     * )\n     */\n    public static function getProcessOwnerInfo()\n    {\n        if (!self::isUnix()) {\n            throw new \\RuntimeException('\"FileSystemUtils::getProcessOwnerInfo()\" is only available on systems with POSIX support!');\n        }\n\n        return posix_getpwuid(posix_geteuid());\n    }\n\n    /**\n     * Gets info about the php-process group\n     * @throws \\RuntimeException Throws if system does not support POSIX\n     * @return array<string,string|int|array> Returns info about the php-process group\n     * @see https://www.php.net/manual/en/function.posix-getegid.php\n     * @see https://www.php.net/manual/en/function.posix-getgrgid.php\n     * @example array(\"name\" => \"max\", \"passwd\" => \"x\", \"members\" => array(), \"gid\" => 1000)\n     */\n    public static function getProcessGroupInfo()\n    {\n        if (!self::isUnix()) {\n            throw new \\RuntimeException('\"FileSystemUtils::getProcessGroupInfo()\" is only available on systems with POSIX support!');\n        }\n\n        return posix_getgrgid(posix_getegid());\n    }\n\n    /**\n     * Gets info about the path owner\n     * @param string $path The path from which to get the information\n     * @throws \\UnexpectedValueException Throws if path does not exist\n     * @throws \\RuntimeException         Throws if the fileowner determination fails or system does not support POSIX\n     * @return array<string,string|int> Returns info about the path owner\n     * @see https://www.php.net/manual/en/function.fileowner.php\n     */\n    public static function getPathOwnerInfo($path)\n    {\n        if (!self::isUnixWithPosix()) {\n            throw new \\RuntimeException('\"FileSystemUtils::getPathOwnerInfo()\" is only available on systems with POSIX support!');\n        }\n\n        self::checkIsInAllowedDirectories($path);\n\n        self::checkParentDirExecAndPathExist($path);\n\n        $fileOwnerResult = fileowner($path);\n        if ($fileOwnerResult === false) {\n            throw new \\RuntimeException('File \"' . $path . '\" owner cannot be determined!');\n        }\n\n        return posix_getpwuid($fileOwnerResult);\n    }\n\n    /**\n     * Gets info about the path group\n     * @param string $path The path from which to get the information\n     * @throws \\UnexpectedValueException Throws if path does not exist\n     * @throws \\RuntimeException         Throws if the groupowner determination fails or system does not support POSIX\n     * @return array<string,string|int|array> Returns info about the path group\n     * @see https://www.php.net/manual/en/function.filegroup.php\n     */\n    public static function getPathGroupInfo($path)\n    {\n        if (!self::isUnix()) {\n            throw new \\RuntimeException('\"FileSystemUtils::getPathGroupInfo()\" is only available on systems with POSIX support!');\n        }\n\n        self::checkIsInAllowedDirectories($path);\n\n        self::checkParentDirExecAndPathExist($path);\n\n        $fileGroupResult = filegroup($path);\n        if ($fileGroupResult === false) {\n            throw new \\RuntimeException('File \"' . $path . '\" group cannot be determined!');\n        }\n\n        return posix_getgrgid($fileGroupResult);\n    }\n\n    /**\n     * Checks if the php-process is the path owner\n     * @param string $path The path from which to get the information\n     * @throws \\UnexpectedValueException Throws if path does not exist\n     * @throws \\RuntimeException         Throws if the fileowner determination fails or system does not support POSIX\n     * @return bool Returns true if php-process is the path owner\n     * @see https://www.php.net/manual/en/function.posix-geteuid.php\n     * @see https://www.php.net/manual/en/function.posix-getpwuid.php\n     * @see https://www.php.net/manual/en/function.fileowner.php\n     */\n    public static function hasPathOwnerRight($path)\n    {\n        if (!self::isUnixWithPosix()) {\n            throw new \\RuntimeException('\"FileSystemUtils::hasPathOwnerRight()\" is only available on systems with POSIX support!');\n        }\n\n        self::checkIsInAllowedDirectories($path);\n\n        $processOwnerInfo = self::getProcessOwnerInfo();\n        $pathOwnerInfo = self::getPathOwnerInfo($path);\n\n        return $processOwnerInfo['uid'] === self::ROOT_ID || $processOwnerInfo['uid'] === $pathOwnerInfo['uid'];\n    }\n\n    /**\n     * Gets the mode permissions of a path\n     * @param string $path  The path from which to get the information\n     * @param bool   $octal Set true to get the octal instead of the string mode representation\n     * @throws \\UnexpectedValueException Throws if path does not exist\n     * @throws \\RuntimeException         Throws if the permissions determination fails\n     * @return string Returns the mode permissions of a path in octal or string representation\n     * @see https://www.php.net/manual/en/function.fileperms.php\n     * @example \"drwxrwxr-x\" or \"0775\"\n     */\n    public static function getPathMode($path, $octal = false)\n    {\n        self::checkIsInAllowedDirectories($path);\n\n        self::checkParentDirExecAndPathExist($path);\n\n        $perms = fileperms($path);\n        if ($perms === false) {\n            throw new \\RuntimeException('File \"' . $path . '\" permissions cannot be read!');\n        }\n\n        if ($octal) {\n            return substr(sprintf('%o', $perms), -4);\n        }\n\n        return self::convertPermsToString($perms);\n    }\n\n    /**\n     * Gets owner, group and mode info from a path\n     * @param string $path The path from which to get the information\n     * @throws \\UnexpectedValueException Throws if path does not exist\n     * @throws \\RuntimeException         Throws if a info determination fails\n     * @return array<string,string> Returns owner, group and mode info from a path\n     * @see https://www.php.net/manual/en/function.fileowner.php\n     * @see https://www.php.net/manual/en/function.filegroup.php\n     * @see https://www.php.net/manual/en/function.fileperms.php\n     * @example array(\"owner\" => \"www-data\", \"group\" => \"www\", \"mode\" => \"drwxrwxr-x\")\n     */\n    public static function getPathPermissions($path)\n    {\n        self::checkIsInAllowedDirectories($path);\n\n        self::checkParentDirExecAndPathExist($path);\n\n        if (self::isUnixWithPosix()) {\n            $ownerInfo = self::getPathOwnerInfo($path);\n            $groupInfo = self::getPathGroupInfo($path);\n\n            return array(\n                'owner' => $ownerInfo['name'],\n                'group' => $groupInfo['name'],\n                'mode' => self::getPathMode($path)\n            );\n        }\n\n        return array(\n            'owner' => null,\n            'group' => null,\n            'mode' => self::getPathMode($path)\n        );\n    }\n\n    /**\n     * Gets the content of a directory and optional recursive from all subdirectories\n     * @param string            $directoryPath        The directory from which to get the content\n     * @param bool              $recursive            If true, also all subdirectories are scanned\n     * @param bool              $fullPath             Set true to get the full paths instead of the content entry names\n     * @param array<int,string> $includedContentTypes A list with all content types that should get returned (directories, files, links)\n     * @throws \\UnexpectedValueException Throws if directory is not readable\n     * @throws \\RuntimeException         Throws if the opendir process fails\n     * @return array<string,string|array> The content of the directory (and all the subdirectories)\n     * @see https://www.php.net/manual/en/function.opendir.php\n     * @see https://www.php.net/manual/en/function.readdir.php\n     */\n    public static function getDirectoryContent($directoryPath, $recursive = false, $fullPath = true, array $includedContentTypes = array(self::CONTENT_TYPE_DIRECTORY, self::CONTENT_TYPE_FILE, self::CONTENT_TYPE_LINK))\n    {\n        self::checkIsInAllowedDirectories($directoryPath);\n\n        if (!is_dir($directoryPath)) {\n            throw new \\UnexpectedValueException('Directory \"' . $directoryPath . '\" does not exist!');\n        }\n        if (!is_readable($directoryPath)) {\n            throw new \\UnexpectedValueException('Directory \"' . $directoryPath . '\" is not readable!');\n        }\n\n        $dirHandle = opendir($directoryPath);\n        if ($dirHandle === false) {\n            throw new \\RuntimeException('Directory \"' . $directoryPath . '\" cannot be opened!');\n        }\n\n        $directoryContent = array();\n\n        while (($entry = readdir($dirHandle)) !== false) {\n            if ($entry === '.' || $entry === '..' || strpos($entry, '.') === 0) {\n                continue;\n            }\n\n            $directoryEntry = $directoryPath . DIRECTORY_SEPARATOR . $entry;\n            $entryValue = $fullPath ? $directoryEntry : (string) $entry;\n\n            if (is_dir($directoryEntry)) {\n                if ($recursive) {\n                    $directoryContent[$entryValue] = self::getDirectoryContent($directoryEntry, $recursive, $fullPath, $includedContentTypes);\n                } elseif (in_array(self::CONTENT_TYPE_DIRECTORY, $includedContentTypes, true)) {\n                    $directoryContent[$entryValue] = self::CONTENT_TYPE_DIRECTORY;\n                }\n            } elseif (is_file($directoryEntry) && in_array(self::CONTENT_TYPE_FILE, $includedContentTypes, true)) {\n                $directoryContent[$entryValue] = self::CONTENT_TYPE_FILE;\n            } elseif (is_link($directoryEntry) && in_array(self::CONTENT_TYPE_LINK, $includedContentTypes, true)) {\n                $directoryContent[$entryValue] = self::CONTENT_TYPE_LINK;\n            }\n        }\n        closedir($dirHandle);\n\n        return $directoryContent;\n    }\n\n    /**\n     * Checks if a directory is empty\n     * @param string $directoryPath The directory to check if is empty\n     * @throws \\UnexpectedValueException Throws if the directory is not readable\n     * @throws \\RuntimeException         Throws if the opendir process fails\n     * @return bool Returns true if the directory is empty\n     * @see https://www.php.net/manual/en/function.opendir.php\n     * @see https://www.php.net/manual/en/function.readdir.php\n     */\n    public static function isDirectoryEmpty($directoryPath)\n    {\n        self::checkIsInAllowedDirectories($directoryPath);\n\n        if (!is_dir($directoryPath)) {\n            throw new \\UnexpectedValueException('Directory \"' . $directoryPath . '\" does not exist!');\n        }\n        if (!is_readable($directoryPath)) {\n            throw new \\UnexpectedValueException('Directory \"' . $directoryPath . '\" is not readable!');\n        }\n\n        $dirHandle = opendir($directoryPath);\n        if ($dirHandle === false) {\n            throw new \\RuntimeException('Directory \"' . $directoryPath . '\" cannot be opened!');\n        }\n\n        while (($entry = readdir($dirHandle)) !== false) {\n            if ($entry !== '.' && $entry !== '..') {\n                closedir($dirHandle);\n\n                return false;\n            }\n        }\n        closedir($dirHandle);\n\n        return true;\n    }\n\n    /**\n     * Check if the current file format could be viewed within a browser.\n     * @return bool Return true if the file could be viewed in the browser otherwise false.\n     */\n    public static function isViewableFileInBrowser($filename)\n    {\n        $returnCode = false;\n        $fileExtension = strtolower(pathinfo($filename, PATHINFO_EXTENSION));\n\n        if (array_key_exists($fileExtension, self::$iconFileExtension)) {\n            $returnCode = self::$iconFileExtension[$fileExtension]['viewable'];\n        }\n\n        return $returnCode;\n    }\n\n    /**\n     * Moves a directory\n     * @param string             $oldDirectoryPath The directory to move\n     * @param string             $newDirectoryPath The destination directory\n     * @param array<string,bool> $options          Operation options ([bool] createDirectoryStructure = true, [bool] overwriteContent = false)\n     * @throws \\UnexpectedValueException Throws if a precondition is not fulfilled\n     * @throws \\RuntimeException         Throws if the mkdir, copy, rmdir, unlink or opendir process fails\n     * @return bool Returns true if content was overwritten\n     */\n    public static function moveDirectory($oldDirectoryPath, $newDirectoryPath, array $options = array())\n    {\n        $returnValue = self::checkDirectoryPreconditions($oldDirectoryPath, $newDirectoryPath, $options);\n\n        self::doCopyDirectory($oldDirectoryPath, $newDirectoryPath);\n\n        self::deleteDirectoryIfExists($oldDirectoryPath, true);\n\n        return $returnValue;\n    }\n\n    /**\n     * Moves a file\n     * @param string             $oldFilePath The file to move\n     * @param string             $newFilePath The path where to move to\n     * @param array<string,bool> $options     Operation options ([bool] createDirectoryStructure = true, [bool] overwrite = false)\n     * @throws \\UnexpectedValueException Throws if a precondition is not fulfilled\n     * @throws \\RuntimeException         Throws if the move process fails\n     * @return bool Returns true if the destination path was overwritten\n     * @see https://www.php.net/manual/en/function.rename.php\n     */\n    public static function moveFile($oldFilePath, $newFilePath, array $options = array())\n    {\n        $returnValue = self::checkFilePreconditions('move', $oldFilePath, $newFilePath, $options);\n\n        $renameResult = rename($oldFilePath, $newFilePath);\n        if (!$renameResult) {\n            throw new \\RuntimeException('File \"' . $oldFilePath . '\" cannot be moved!');\n        }\n\n        return $returnValue;\n    }\n\n    /**\n     * Method will read the content of the file that is set through the parameter and return the\n     * file content. It will check if the file exists and if it's readable for the PHP user.\n     * @param string $filePath The file to read\n     * @throws \\UnexpectedValueException Throws if the file does not exist or is not readable\n     * @throws \\RuntimeException         Throws if the read process fails\n     * @return string Returns the file content\n     * @see https://www.php.net/manual/en/function.file-get-contents.php\n     */\n    public static function readFile($filePath)\n    {\n        self::checkIsInAllowedDirectories($filePath);\n\n        if (!is_file($filePath)) {\n            throw new \\UnexpectedValueException('File \"' . $filePath . '\" does not exist!');\n        }\n        if (!is_readable($filePath)) {\n            throw new \\UnexpectedValueException('File \"' . $filePath . '\" is not readable!');\n        }\n\n        $data = file_get_contents($filePath);\n        if ($data === false) {\n            throw new \\RuntimeException('File \"' . $filePath . '\" cannot be read!');\n        }\n\n        return $data;\n    }\n\n    /**\n     * Remove anything which isn't a word, whitespace, number\n     * or any of the following characters: \"-_~:;<>|[]().\"\n     * @params string $filename The filename where the invalid characters should be removed\n     * @return string Returns the filename with the removed invalid characters\n     */\n    public static function removeInvalidCharsInFilename($filename)\n    {\n        // remove NULL value from filename\n        $filename = str_replace(chr(0), '', $filename);\n        $filename = preg_replace(\"/([^\\w\\s\\d\\-_~:;<>|\\[\\]\\(\\).])/u\", '', $filename);\n        // Remove any runs of periods\n        $filename = preg_replace(\"/([\\.]{2,})/u\", '', $filename);\n\n        return $filename;\n    }\n\n    /**\n     * Restrict all operations of this class to specific directories\n     * @param array<int,string> $directoryPaths The allowed directories\n     * @throws \\UnexpectedValueException Throws if a given directory does not exist\n     */\n    public static function setAllowedDirectories(array $directoryPaths = array())\n    {\n        foreach ($directoryPaths as &$directoryPath) {\n            $directoryPath = self::getNormalizedPath($directoryPath);\n            if (!is_dir($directoryPath)) {\n                throw new \\UnexpectedValueException('Directory \"' . $directoryPath . '\" does not exist!');\n            }\n        }\n        unset($directoryPath);\n\n        self::$allowedDirectories = $directoryPaths;\n    }\n\n    /**\n     * Write some data into a file\n     * @param string $filePath The file to write\n     * @param string $data     The data to write\n     * @param bool   $append   If true the data gets appended instead of overwriting the content\n     * @throws \\UnexpectedValueException Throws if the file or parent directory is not writable\n     * @throws \\RuntimeException         Throws if the write process fails\n     * @return int Returns the written bytes\n     * @see https://www.php.net/manual/en/function.file-put-contents.php\n     */\n    public static function writeFile($filePath, $data, $append = false)\n    {\n        self::checkIsInAllowedDirectories($filePath);\n\n        $parentDirectoryPath = dirname($filePath);\n        if (self::isUnix() && !is_executable($parentDirectoryPath)) {\n            throw new \\UnexpectedValueException('Parent directory \"' . $parentDirectoryPath . '\" is not executable!');\n        }\n\n        if (is_file($filePath)) {\n            if (!is_writable($filePath)) {\n                throw new \\UnexpectedValueException('File \"' . $filePath . '\" is not writable!');\n            }\n        } else {\n            if (!is_writable($parentDirectoryPath)) {\n                throw new \\UnexpectedValueException('Parent directory \"' . $parentDirectoryPath . '\" is not writable!');\n            }\n        }\n\n        $flags = 0;\n        if ($append) {\n            $flags = FILE_APPEND;\n        }\n\n        $bytes = file_put_contents($filePath, $data, $flags);\n        if ($bytes === false) {\n            throw new \\RuntimeException('File \"' . $filePath . '\" cannot be written!');\n        }\n\n        return $bytes;\n    }\n}\n", "<?php\n/**\n ***********************************************************************************************\n * Class manages access to database table adm_files\n *\n * @copyright 2004-2023 The Admidio Team\n * @see https://www.admidio.org/\n * @license https://www.gnu.org/licenses/gpl-2.0.html GNU General Public License v2.0 only\n ***********************************************************************************************\n */\n\n/**\n * Diese Klasse dient dazu ein Fileobjekt zu erstellen.\n * Eine Datei kann ueber diese Klasse in der Datenbank verwaltet werden\n *\n * Beside the methods of the parent class there are the following additional methods:\n *\n * getFileForDownload($fileId)\n *                         - File mit der uebergebenen ID aus der Datenbank auslesen fuer\n *                           das Downloadmodul. Hier wird auch direkt ueberprueft ob die\n *                           Datei oder der Ordner gesperrt ist.\n * getCompletePathOfFile() - Gibt den kompletten Pfad der Datei zurueck\n */\nclass TableFile extends TableAccess\n{\n    /**\n     * Constructor that will create an object of a recordset of the table adm_files.\n     * If the id is set than the specific files will be loaded.\n     * @param Database $database Object of the class Database. This should be the default global object **$gDb**.\n     * @param int      $filId    The recordset of the files with this id will be loaded. If id isn't set than an empty object of the table is created.\n     */\n    public function __construct(Database $database, $filId = 0)\n    {\n        // read also data of assigned folder\n        $this->connectAdditionalTable(TBL_FOLDERS, 'fol_id', 'fil_fol_id');\n\n        parent::__construct($database, TBL_FILES, 'fil', $filId);\n    }\n\n    /**\n     * Check if the file extension of the current file format is allowed for upload and the\n     * documents and files module.\n     * @return bool Return true if the file extension is allowed to be used within Admidio.\n     */\n    public function allowedFileExtension()\n    {\n        return FileSystemUtils::allowedFileExtension($this->getFileExtension());\n    }\n\n    /**\n     * Deletes the selected record of the table and the associated file in the file system.\n     * After that the class will be initialize.\n     * @return bool **true** if no error occurred\n     */\n    public function delete()\n    {\n        global $gLogger;\n\n        try {\n            FileSystemUtils::deleteFileIfExists($this->getFullFilePath());\n        } catch (\\RuntimeException $exception) {\n            $gLogger->error('Could not delete file!', array('filePath' => $this->getFullFilePath()));\n            // TODO\n        }\n\n        // Even if the delete won't work, return true, so that the entry of the DB disappears\n        return parent::delete();\n    }\n\n    /**\n     * Gets the absolute path of the folder (with folder-name)\n     * @return string Returns the folder path of the current file.\n     */\n    public function getFullFolderPath()\n    {\n        return ADMIDIO_PATH . $this->getValue('fol_path', 'database') . '/' . $this->getValue('fol_name', 'database');\n    }\n\n    /**\n     * Gets the absolute path of the file\n     * @return string Returns the folder path with the file name of the current file.\n     */\n    public function getFullFilePath()\n    {\n        return $this->getFullFolderPath() . '/' . $this->getValue('fil_name', 'database');\n    }\n\n    /**\n     * Get the extension of the file\n     * @return string Extension of the file e.g. 'pdf' or 'jpg'\n     */\n    public function getFileExtension()\n    {\n        return strtolower(pathinfo($this->getValue('fil_name'), PATHINFO_EXTENSION));\n    }\n\n    /**\n     * Reads the file recordset from database table **adm_folders** and throws an AdmException\n     * if the user has no right to see the corresponding folder or the file id doesn't exists.\n     * @param string $fileUuid The UUID of the file.\n     * @throws AdmException SYS_FOLDER_NO_RIGHTS\n     *                      SYS_INVALID_PAGE_VIEW\n     * @return true Returns **true** if everything is ok otherwise an AdmException is thrown.\n     */\n    public function getFileForDownload($fileUuid)\n    {\n        global $gCurrentUser;\n\n        $this->readDataByUuid($fileUuid);\n\n        // Check if a dataset is found\n        if ((int) $this->getValue('fil_id') === 0) {\n            throw new AdmException('SYS_INVALID_PAGE_VIEW');\n        }\n\n        // If current user has download-admin-rights => allow\n        if ($gCurrentUser->adminDocumentsFiles()) {\n            return true;\n        }\n\n        // If file is locked (and no download-admin-rights) => throw exception\n        if ($this->getValue('fil_locked')) {\n            $this->clear();\n            throw new AdmException('SYS_FOLDER_NO_RIGHTS');\n        }\n\n        // If folder is public (and file is not locked) => allow\n        if ($this->getValue('fol_public')) {\n            return true;\n        }\n\n        // check if user has a membership in a role that is assigned to the current folder\n        $folderViewRolesObject = new RolesRights($this->db, 'folder_view', (int) $this->getValue('fol_id'));\n\n        if ($folderViewRolesObject->hasRight($gCurrentUser->getRoleMemberships())) {\n            return true;\n        }\n\n        $this->clear();\n        throw new AdmException('SYS_FOLDER_NO_RIGHTS');\n    }\n\n    /**\n     * Get the relevant Font Awesome icon for the current file\n     * @return string Returns the name of the Font Awesome icon\n     */\n    public function getFontAwesomeIcon()\n    {\n        return FileSystemUtils::getFileFontAwesomeIcon($this->getValue('fil_name'));\n    }\n\n    /**\n     * Get the MIME type of the current file e.g. 'image/jpeg'\n     * @return string MIME type of the current file\n     */\n    public function getMimeType()\n    {\n        return FileSystemUtils::getFileMimeType($this->getValue('fil_name'));\n    }\n\n    /**\n     * If the value was manipulated before with **setValue** than the manipulated value is returned.\n     * @param string $columnName The name of the database column whose value should be read\n     * @param string $format     For date or timestamp columns the format should be the date/time format e.g. **d.m.Y = '02.04.2011'**.\n     *                           For text columns the format can be **database** that would return the original database value without any transformations\n     * @return int|string|bool Returns the value of the database column.\n     *                         If the value was manipulated before with **setValue** than the manipulated value is returned.\n     */\n    public function getValue($columnName, $format = '')\n    {\n        $value = parent::getValue($columnName, $format);\n\n        // getValue transforms & to html chars. This must be undone.\n        if ($columnName === 'fil_name') {\n            $value = htmlspecialchars_decode($value);\n        }\n\n        return $value;\n    }\n\n    /**\n     * Check if the current file format could be viewed within a browser.\n     * @return bool Return true if the file could be viewed in the browser otherwise false.\n     */\n    public function isViewableInBrowser()\n    {\n        return FileSystemUtils::isViewableFileInBrowser($this->getValue('fil_name'));\n    }\n\n    /**\n     * Save all changed columns of the recordset in table of database. Therefore the class remembers if it's\n     * a new record or if only an update is necessary. The update statement will only update the changed columns.\n     * If the table has columns for creator or editor than these column with their timestamp will be updated.\n     * For new records the user and timestamp will be set per default.\n     * @param bool $updateFingerPrint Default **true**. Will update the creator or editor of the recordset if table has columns like **usr_id_create** or **usr_id_changed**\n     * @return bool If an update or insert into the database was done then return true, otherwise false.\n     */\n    public function save($updateFingerPrint = true)\n    {\n        if ($this->newRecord) {\n            $this->setValue('fil_timestamp', DATETIME_NOW);\n            $this->setValue('fil_usr_id', $GLOBALS['gCurrentUserId']);\n        }\n\n        return parent::save($updateFingerPrint);\n    }\n}\n", "<?php\n/**\n ***********************************************************************************************\n * @copyright 2004-2023 The Admidio Team\n * @see https://www.admidio.org/\n * @license https://www.gnu.org/licenses/gpl-2.0.html GNU General Public License v2.0 only\n ***********************************************************************************************\n */\n\n/**\n * Improved checks and update of database after upload of photos.\n *\n * This class extends the UploadHandler of the jquery-file-upload library. After\n * the upload of a photo we do some checks on the file and if no check fails then\n * the Admidio database will be updated. If you want do upload photos for the photos\n * module just create an instance of this class.\n *\n * **Code example**\n * ```\n * // create object and do upload\n * $uploadHandler = new UploadHandlerPhoto(array('upload_dir' => $uploadDir,\n *                                               'upload_url' => $uploadUrl,\n *                                               'image_versions' => array(),\n *                                               'accept_file_types' => '/\\.(jpe?g|png)$/i'), true,\n *                                               'array('accept_file_types' => $gL10n->get('PHO_PHOTO_FORMAT_INVALID')));\n * ```\n */\n\nclass UploadHandlerPhoto extends UploadHandler\n{\n    /**\n     * Override the default method to handle the specific things of the photo module and\n     * update the database after file was successful uploaded.\n     * This method has the same parameters as the default.\n     * @param string $uploadedFile\n     * @param string $name\n     * @param int    $size\n     * @param        $type\n     * @param        $error\n     * @param        $index\n     * @param        $contentRange\n     * @return \\stdClass\n     */\n    protected function handle_file_upload($uploadedFile, $name, $size, $type, $error, $index = null, $contentRange = null)\n    {\n        global $photoAlbum, $gSettingsManager, $gL10n, $gLogger;\n\n        $file = parent::handle_file_upload($uploadedFile, $name, $size, $type, $error, $index, $contentRange);\n\n        if (!isset($file->error)) {\n            try {\n                $fileLocation = ADMIDIO_PATH . FOLDER_DATA . '/photos/upload/' . $file->name;\n                $albumFolder  = ADMIDIO_PATH . FOLDER_DATA . '/photos/' . $photoAlbum->getValue('pho_begin', 'Y-m-d') . '_' . (int) $photoAlbum->getValue('pho_id');\n\n                // check filename and throw exception if something is wrong\n                StringUtils::strIsValidFileName($file->name, false);\n\n                // replace invalid characters in filename\n                $file->name = FileSystemUtils::removeInvalidCharsInFilename($file->name);\n\n                // create folder if not exists\n                if (!is_dir($albumFolder)) {\n                    $error = $photoAlbum->createFolder();\n\n                    if (is_array($error)) {\n                        $file->error = $gL10n->get($error['text'], array($error['path']));\n                        return $file;\n                    }\n                }\n\n                $newPhotoFileNumber = $photoAlbum->getValue('pho_quantity') + 1;\n\n                // read image size\n                $imageProperties = getimagesize($fileLocation);\n                if ($imageProperties === false) {\n                    throw new AdmException('PHO_PHOTO_FORMAT_INVALID');\n                }\n\n                // check mime type and set file extension\n                switch ($imageProperties['mime']) {\n                    case 'image/jpeg':\n                        $fileExtension = 'jpg';\n                        break;\n                    case 'image/png':\n                        $fileExtension = 'png';\n                        break;\n                    default:\n                        throw new AdmException('PHO_PHOTO_FORMAT_INVALID');\n                }\n\n                $imageDimensions = $imageProperties[0] * $imageProperties[1];\n                $processableImageSize = admFuncProcessableImageSize();\n                if ($imageDimensions > $processableImageSize) {\n                    throw new AdmException($gL10n->get('PHO_RESOLUTION_MORE_THAN') . ' ' . round($processableImageSize / 1000000, 2) . ' ' . $gL10n->get('SYS_MEGAPIXEL'));\n                }\n\n                // create image object and scale image to defined size of preferences\n                $image = new Image($fileLocation);\n                $image->setImageType('jpeg');\n                $image->scaleLargerSide($gSettingsManager->getInt('photo_save_scale'));\n                $image->copyToFile(null, $albumFolder.'/'.$newPhotoFileNumber.'.jpg');\n                $image->delete();\n\n                // if enabled then save original image\n                if ($gSettingsManager->getBool('photo_keep_original')) {\n                    try {\n                        FileSystemUtils::createDirectoryIfNotExists($albumFolder . '/originals');\n\n                        try {\n                            FileSystemUtils::moveFile($fileLocation, $albumFolder.'/originals/'.$newPhotoFileNumber.'.'.$fileExtension);\n                        } catch (\\RuntimeException $exception) {\n                            $gLogger->error('Could not move file!', array('from' => $fileLocation, 'to' => $albumFolder.'/originals/'.$newPhotoFileNumber.'.'.$fileExtension));\n                            // TODO\n                        }\n                    } catch (\\RuntimeException $exception) {\n                        $gLogger->error('Could not create directory!', array('directoryPath' => $albumFolder . '/originals'));\n                        // TODO\n                    }\n                }\n\n                // save thumbnail\n                try {\n                    FileSystemUtils::createDirectoryIfNotExists($albumFolder . '/thumbnails');\n                } catch (\\RuntimeException $exception) {\n                }\n\n                $image = new Image($fileLocation);\n                $image->scaleLargerSide($gSettingsManager->getInt('photo_thumbs_scale'));\n                $image->copyToFile(null, $albumFolder.'/thumbnails/'.$newPhotoFileNumber.'.jpg');\n                $image->delete();\n\n                // delete image from upload folder\n                try {\n                    FileSystemUtils::deleteFileIfExists($fileLocation);\n                } catch (\\RuntimeException $exception) {\n                }\n\n                // if image was successfully saved in filesystem then update image count of album\n                if (is_file($albumFolder.'/'.$newPhotoFileNumber.'.jpg')) {\n                    $photoAlbum->setValue('pho_quantity', (int) $photoAlbum->getValue('pho_quantity') + 1);\n                    $photoAlbum->save();\n                } else {\n                    throw new AdmException('PHO_PHOTO_PROCESSING_ERROR');\n                }\n            } catch (AdmException $e) {\n                $file->error = $e->getText();\n\n                try {\n                    FileSystemUtils::deleteFileIfExists($this->options['upload_dir'].$file->name);\n                } catch (\\RuntimeException $exception) {\n                }\n\n                return $file;\n            }\n        }\n\n        return $file;\n    }\n\n    /**\n     * Override the default method to handle specific form data that will be set when creating the Javascript\n     * file upload object. Here we validate the CSRF token that will be set. If the check failed an error will\n     * be set and the file upload will be canceled.\n     * @param string $file\n     * @param int    $index\n     */\n    protected function handle_form_data($file, $index)\n    {\n        // ADM Start\n        try {\n            // check the CSRF token of the form against the session token\n            SecurityUtils::validateCsrfToken($_REQUEST['admidio-csrf-token']);\n        } catch (AdmException $exception) {\n            $file->error = $exception->getText();\n            // => EXIT\n        }\n        // ADM End\n    }\n}\n"], "fixing_code": ["<?php\n/**\n ***********************************************************************************************\n * Handle image uploads from CKEditor\n *\n * @copyright 2004-2023 The Admidio Team\n * @see https://www.admidio.org/\n * @license https://www.gnu.org/licenses/gpl-2.0.html GNU General Public License v2.0 only\n *\n * Parameters:\n *\n * CKEditor        : ID of textarea, that had triggered the upload\n * CKEditorFuncNum : function number, that will handle in the editor the new URL\n * langCode        : language code\n ***********************************************************************************************\n */\nrequire_once(__DIR__ . '/common.php');\nrequire(__DIR__ . '/login_valid.php');\n\n$getCKEditor        = admFuncVariableIsValid($_GET, 'CKEditor', 'string', array('directOutput' => true, 'requireValue' => true));\n$getCKEditorFuncNum = admFuncVariableIsValid($_GET, 'CKEditorFuncNum', 'string', array('directOutput' => true, 'requireValue' => true));\n$getlangCode        = admFuncVariableIsValid($_GET, 'langCode', 'string', array('directOutput' => true));\n\n$htmlUrl = '';\n$message = '';\n\n// check if a file was really uploaded\nif (!file_exists($_FILES['upload']['tmp_name']) || !is_uploaded_file($_FILES['upload']['tmp_name'])) {\n    $message = $gL10n->get('SYS_FILE_NOT_EXIST');\n}\n\n// checks if the server settings for file_upload are set to ON\nif (!PhpIniUtils::isFileUploadEnabled()) {\n    $message = $gL10n->get('SYS_SERVER_NO_UPLOAD');\n}\n\nif (!FileSystemUtils::allowedFileExtension($_FILES['upload']['name'])) {\n    $message = $gL10n->get('SYS_FILE_EXTENSION_INVALID');\n}\n\n// if necessary create the module folders in adm_my_files\nswitch ($getCKEditor) {\n    case 'ann_description':\n        $folderName = 'announcements';\n        break;\n    case 'dat_description':\n        $folderName = 'dates';\n        break;\n    case 'lnk_description':\n        $folderName = 'weblinks';\n        break;\n    case 'msg_body':\n        $folderName = 'mail';\n        break;\n    case 'room_description':\n        $folderName = 'rooms';\n        break;\n    case 'usf_description':\n        $folderName = 'user_fields';\n        break;\n    default:\n        $folderName = 'plugins';\n        break;\n}\n\nif ($message === '') {\n    try {\n        $imagesPath = ADMIDIO_PATH . FOLDER_DATA . '/' . $folderName . '/images';\n\n        FileSystemUtils::createDirectoryIfNotExists($imagesPath);\n\n        // create a filename with a timestamp and 16 chars secure-random string,\n        // so we have a scheme for the filenames and the risk of duplicates is negligible.\n        // Format: 20180131-123456_0123456789abcdef.jpg\n        $fileName = FileSystemUtils::getGeneratedFilename($_FILES['upload']['name']);\n        $fileNamePath = $imagesPath . '/' . $fileName;\n\n        $htmlUrl = SecurityUtils::encodeUrl(ADMIDIO_URL . '/adm_program/system/show_image.php', array('module' => $folderName, 'file' => $fileName));\n\n        move_uploaded_file($_FILES['upload']['tmp_name'], $fileNamePath);\n\n        // check if the file contains a valid image\n        if (!getimagesize($fileNamePath)) {\n            $message = $gL10n->get('PHO_PHOTO_FORMAT_INVALID');\n            FileSystemUtils::deleteFileIfExists($fileNamePath);\n        }\n\n    } catch (RuntimeException|AdmException $exception) {\n        $message = $exception->getMessage();\n    }\n}\n\n// now call CKEditor function and send photo data\necho '<!DOCTYPE html>\n<html>\n    <body>\n        <script type=\"text/javascript\">\n            window.parent.CKEDITOR.tools.callFunction('.$getCKEditorFuncNum.', \"'.$htmlUrl.'\", \"'.$message.'\")\n        </script>\n    </body>\n</html>';\n", "<?php\n/**\n ***********************************************************************************************\n * This class handles the most necessary file-system operations\n *\n * @copyright 2004-2023 The Admidio Team\n * @see https://www.admidio.org/\n * @license https://www.gnu.org/licenses/gpl-2.0.html GNU General Public License v2.0 only\n ***********************************************************************************************\n */\n\n/**\n * This class handles the most necessary file-system operations like:\n * - Function: get normalized path, get human readable bytes, restrict all operations to specific directories\n * - Info: disk space, process owner/group info, path owner/group info, is path owner, path mode, path permissions\n * - Folder: create, is empty, get content, delete content, delete folder, copy, move, chmod\n * - File: delete, copy, move, chmod, read, write\n */\nfinal class FileSystemUtils\n{\n    public const CONTENT_TYPE_DIRECTORY = 'directory';\n    public const CONTENT_TYPE_FILE      = 'file';\n    public const CONTENT_TYPE_LINK      = 'link';\n\n    public const ROOT_ID = 0;\n    public const ROOT_FOLDER = '/';\n\n    public const DEFAULT_MODE_DIRECTORY = 0775;\n    public const DEFAULT_MODE_FILE      = 0664;\n\n    /**\n     * @var array<int,string> The allowed directories\n     */\n    private static $allowedDirectories = array();\n\n    /**\n     * @var array<string,string> Array with file extensions and the best Font Awesome icon that should be used\n     */\n    private static $iconFileExtension = array(\n        'bmp'  => array('icon' => 'fa-file-image', 'mime-type' => 'image/bmp', 'viewable' => true),\n        'gif'  => array('icon' => 'fa-file-image', 'mime-type' => 'image/gif', 'viewable' => true),\n        'jpg'  => array('icon' => 'fa-file-image', 'mime-type' => 'image/jpeg', 'viewable' => true),\n        'jpeg' => array('icon' => 'fa-file-image', 'mime-type' => 'image/jpeg', 'viewable' => true),\n        'png'  => array('icon' => 'fa-file-image', 'mime-type' => 'image/png', 'viewable' => true),\n        'tiff' => array('icon' => 'fa-file-image', 'mime-type' => 'image/tiff', 'viewable' => true),\n        'doc'  => array('icon' => 'fa-file-word', 'mime-type' => 'application/msword', 'viewable' => false),\n        'docx' => array('icon' => 'fa-file-word', 'mime-type' => 'application/msword', 'viewable' => false),\n        'dot'  => array('icon' => 'fa-file-word', 'mime-type' => 'application/msword', 'viewable' => false),\n        'dotx' => array('icon' => 'fa-file-word', 'mime-type' => 'application/msword', 'viewable' => false),\n        'odt'  => array('icon' => 'fa-file-word', 'mime-type' => 'application/vnd.oasis.opendocument.text', 'viewable' => false),\n        'csv'  => array('icon' => 'fa-file-excel', 'mime-type' => 'text/comma-separated-values', 'viewable' => false),\n        'xls'  => array('icon' => 'fa-file-excel', 'mime-type' => 'application/msexcel', 'viewable' => false),\n        'xlsx' => array('icon' => 'fa-file-excel', 'mime-type' => 'application/msexcel', 'viewable' => false),\n        'xlt'  => array('icon' => 'fa-file-excel', 'mime-type' => 'application/msexcel', 'viewable' => false),\n        'xltx' => array('icon' => 'fa-file-excel', 'mime-type' => 'application/msexcel', 'viewable' => false),\n        'ods'  => array('icon' => 'fa-file-excel', 'mime-type' => 'application/vnd.oasis.opendocument.spreadsheet', 'viewable' => false),\n        'pps'  => array('icon' => 'fa-file-powerpoint', 'mime-type' => 'application/mspowerpoint', 'viewable' => false),\n        'ppsx' => array('icon' => 'fa-file-powerpoint', 'mime-type' => 'application/mspowerpoint', 'viewable' => false),\n        'ppt'  => array('icon' => 'fa-file-powerpoint', 'mime-type' => 'application/mspowerpoint', 'viewable' => false),\n        'pptx' => array('icon' => 'fa-file-powerpoint', 'mime-type' => 'application/mspowerpoint', 'viewable' => false),\n        'odp'  => array('icon' => 'fa-file-powerpoint', 'mime-type' => 'application/vnd.oasis.opendocument.presentation', 'viewable' => false),\n        'css'  => array('icon' => 'fa-file-alt', 'mime-type' => 'text/css', 'viewable' => true),\n        'log'  => array('icon' => 'fa-file-alt', 'mime-type' => 'text/plain', 'viewable' => true),\n        'md'   => array('icon' => 'fa-file-alt', 'mime-type' => 'text/plain', 'viewable' => true),\n        'rtf'  => array('icon' => 'fa-file-alt', 'mime-type' => 'text/rtf', 'viewable' => false),\n        'txt'  => array('icon' => 'fa-file-alt', 'mime-type' => 'text/plain', 'viewable' => true),\n        'pdf'  => array('icon' => 'fa-file-pdf', 'mime-type' => 'application/pdf', 'viewable' => true),\n        'gz'   => array('icon' => 'fa-file-archive', 'mime-type' => 'application/gzip', 'viewable' => false),\n        'tar'  => array('icon' => 'fa-file-archive', 'mime-type' => 'application/x-tar', 'viewable' => false),\n        'zip'  => array('icon' => 'fa-file-archive', 'mime-type' => 'application/zip', 'viewable' => false),\n        'avi'  => array('icon' => 'fa-file-video', 'mime-type' => 'video/x-msvideo', 'viewable' => true),\n        'flv'  => array('icon' => 'fa-file-video', 'mime-type' => 'video/x-flv', 'viewable' => true),\n        'mov'  => array('icon' => 'fa-file-video', 'mime-type' => 'video/quicktime', 'viewable' => true),\n        'mp4'  => array('icon' => 'fa-file-video', 'mime-type' => 'video/mp4', 'viewable' => true),\n        'mpeg' => array('icon' => 'fa-file-video', 'mime-type' => 'video/mpeg', 'viewable' => true),\n        'mpg'  => array('icon' => 'fa-file-video', 'mime-type' => 'video/mpeg', 'viewable' => true),\n        'webm' => array('icon' => 'fa-file-video', 'mime-type' => 'video/webm', 'viewable' => true),\n        'wmv'  => array('icon' => 'fa-file-video', 'mime-type' => 'video/x-ms-wmv', 'viewable' => true),\n        'aac'  => array('icon' => 'fa-file-audio', 'mime-type' => 'audio/aac', 'viewable' => true),\n        'midi' => array('icon' => 'fa-file-audio', 'mime-type' => 'audio/x-midi', 'viewable' => true),\n        'mp3'  => array('icon' => 'fa-file-audio', 'mime-type' => 'audio/mpeg3', 'viewable' => true),\n        'wav'  => array('icon' => 'fa-file-audio', 'mime-type' => 'audio/x-midi', 'viewable' => true),\n        'wma'  => array('icon' => 'fa-file-audio', 'mime-type' => 'audio/x-ms-wma', 'viewable' => true)\n    );\n\n    /**\n     * Check if the file extension of the current file format is allowed for upload and the\n     * documents and files module.\n     * @param string $filename The name of the file that should be checked.\n     * @return bool Return true if the file extension is allowed to be used within Admidio.\n     */\n    public static function allowedFileExtension(string $filename): bool\n    {\n        $fileExtension = strtolower(pathinfo($filename, PATHINFO_EXTENSION));\n\n        if (array_key_exists($fileExtension, self::$iconFileExtension)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks if file-system is UNIX\n     * @return bool Returns true if file-system is UNIX\n     */\n    public static function isUnix()\n    {\n        return DIRECTORY_SEPARATOR === '/';\n    }\n\n    /**\n     * Checks if file-system is UNIX and the POSIX functions are installed\n     * @return bool Returns true if file-system is UNIX and POSIX functions are installed\n     */\n    public static function isUnixWithPosix()\n    {\n        return self::isUnix() && function_exists('posix_getpwuid');\n    }\n\n    /**\n     * Checks if all preconditions are fulfilled\n     * @param string             $oldDirectoryPath The source directory\n     * @param string             $newDirectoryPath The destination directory\n     * @param array<string,bool> $options          Operation options ([bool] createDirectoryStructure = true, [bool] overwriteContent = false)\n     * @throws \\UnexpectedValueException Throws if source directory is not readable, destination directory is not writable or a collision is detected\n     * @throws \\RuntimeException         Throws if the mkdir or opendir process fails\n     * @return bool Returns true if content will get overwritten\n     */\n    private static function checkDirectoryPreconditions($oldDirectoryPath, $newDirectoryPath, array $options = array())\n    {\n        self::checkIsInAllowedDirectories($oldDirectoryPath);\n        self::checkIsInAllowedDirectories($newDirectoryPath);\n\n        $defaultOptions = array('createDirectoryStructure' => true, 'overwriteContent' => false);\n        $options = array_merge($defaultOptions, $options);\n\n        if (!is_dir($oldDirectoryPath)) {\n            throw new \\UnexpectedValueException('Source directory \"' . $oldDirectoryPath . '\" does not exist!');\n        }\n        if (!is_readable($oldDirectoryPath)) {\n            throw new \\UnexpectedValueException('Source directory \"' . $oldDirectoryPath . '\" is not readable!');\n        }\n\n        if (!is_dir($newDirectoryPath)) {\n            if ($options['createDirectoryStructure']) {\n                self::createDirectoryIfNotExists($newDirectoryPath);\n\n                return false;\n            }\n\n            throw new \\UnexpectedValueException('Destination directory \"' . $newDirectoryPath . '\" does not exist!');\n        }\n        if (self::isUnix() && !is_executable($newDirectoryPath)) {\n            throw new \\UnexpectedValueException('Destination directory \"' . $newDirectoryPath . '\" is not executable!');\n        }\n        if (!is_writable($newDirectoryPath)) {\n            throw new \\UnexpectedValueException('Destination directory \"' . $newDirectoryPath . '\" is not writable!');\n        }\n\n        $oldDirectoryContentTree = self::getDirectoryContent($oldDirectoryPath, true, false);\n        $newDirectoryContentTree = self::getDirectoryContent($newDirectoryPath, true, false);\n\n        $collision = self::checkDirectoryContentTreeCollisions($oldDirectoryContentTree, $newDirectoryContentTree);\n        if (!$collision) {\n            return false;\n        }\n        if ($options['overwriteContent']) {\n            return true;\n        }\n\n        throw new \\UnexpectedValueException('Destination directory \"' . $newDirectoryPath . '\" has collisions!');\n    }\n\n    /**\n     * Checks if two directories have same files or directories\n     * @param array<string,string|array> $directoryContentTree1       Thirst directory to check\n     * @param array<string,string|array> $directoryContentTree2       Second directory to check\n     * @param bool                       $considerDirectoryCollisions If true, also directory collisions are checked\n     * @return bool Returns true if both directories has same files or directories\n     */\n    private static function checkDirectoryContentTreeCollisions(array $directoryContentTree1, array $directoryContentTree2, $considerDirectoryCollisions = false)\n    {\n        foreach ($directoryContentTree1 as $directoryContentName => $directoryContentType1) {\n            if (array_key_exists($directoryContentName, $directoryContentTree2)) {\n                if ($considerDirectoryCollisions) {\n                    return true;\n                }\n\n                $directoryContentType2 = $directoryContentTree2[$directoryContentName];\n\n                if (!is_array($directoryContentType1) || !is_array($directoryContentType2)) {\n                    return true;\n                }\n\n                $collision = self::checkDirectoryContentTreeCollisions($directoryContentType1, $directoryContentType2, $considerDirectoryCollisions);\n                if ($collision) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks the preconditions for tile copy and move\n     * @param string             $mode        The operation mode (copy or move)\n     * @param string             $oldFilePath The source path\n     * @param string             $newFilePath The destination path\n     * @param array<string,bool> $options     Operation options ([bool] createDirectoryStructure = true, [bool] overwrite = false)\n     * @throws \\UnexpectedValueException Throws if a precondition is not fulfilled\n     * @throws \\RuntimeException         Throws if the destination folder could not be created\n     * @return bool Returns true if the destination path will be overwritten\n     */\n    private static function checkFilePreconditions($mode, $oldFilePath, $newFilePath, array $options = array())\n    {\n        $defaultOptions = array('createDirectoryStructure' => true, 'overwrite' => false);\n        $options = array_merge($defaultOptions, $options);\n\n        self::checkIsInAllowedDirectories($oldFilePath);\n        self::checkIsInAllowedDirectories($newFilePath);\n\n        $oldParentDirectoryPath = dirname($oldFilePath);\n        if (self::isUnix() && !is_executable($oldParentDirectoryPath)) {\n            throw new \\UnexpectedValueException('Source parent directory \"' . $oldParentDirectoryPath . '\" is not executable!');\n        }\n        if ($mode === 'move' && !is_writable($oldParentDirectoryPath)) {\n            throw new \\UnexpectedValueException('Source parent directory \"' . $oldParentDirectoryPath . '\" is not writable!');\n        }\n\n        if (!is_file($oldFilePath)) {\n            throw new \\UnexpectedValueException('Source file \"' . $oldFilePath . '\" does not exist!');\n        }\n        if ($mode === 'copy' && !is_readable($oldFilePath)) {\n            throw new \\UnexpectedValueException('Source file \"' . $oldFilePath . '\" is not readable!');\n        }\n\n        $newParentDirectoryPath = dirname($newFilePath);\n        if (!is_dir($newParentDirectoryPath)) {\n            if ($options['createDirectoryStructure']) {\n                self::createDirectoryIfNotExists($newParentDirectoryPath);\n\n                return false;\n            }\n\n            throw new \\UnexpectedValueException('Destination parent directory \"' . $newParentDirectoryPath . '\" does not exist!');\n        }\n        if (self::isUnix() && !is_executable($newParentDirectoryPath)) {\n            throw new \\UnexpectedValueException('Destination parent directory \"' . $newParentDirectoryPath . '\" is not executable!');\n        }\n        if (!is_writable($newParentDirectoryPath)) {\n            throw new \\UnexpectedValueException('Destination parent directory \"' . $newParentDirectoryPath . '\" is not writable!');\n        }\n\n        if (!is_file($newFilePath)) {\n            return false;\n        }\n        if ($options['overwrite']) {\n            return true;\n        }\n\n        throw new \\UnexpectedValueException('Destination file \"' . $newFilePath . '\" already exist!');\n    }\n\n    /**\n     * Checks if a given path is in the allowed directories\n     * @param string $path The path to check\n     * @throws \\RuntimeException Throws if the given path is not in an allowed directory\n     */\n    private static function checkIsInAllowedDirectories(&$path)\n    {\n        $path = self::getNormalizedPath($path);\n\n        if (count(self::$allowedDirectories) === 0) {\n            return;\n        }\n\n        foreach (self::$allowedDirectories as $allowedDirectory) {\n            if (strpos($path, $allowedDirectory) === 0) {\n                return;\n            }\n        }\n\n        throw new \\RuntimeException('Path \"' . $path . '\" is not in allowed directory!');\n    }\n\n    /**\n     * Checks if the parent directory is executable and the path exist\n     * @param string $path The path to check\n     * @throws \\UnexpectedValueException Throws if path does not exist or parent directory is not executable\n     */\n    private static function checkParentDirExecAndPathExist($path)\n    {\n        $parentDirectoryPath = dirname($path);\n        if (self::isUnix() && !is_executable($parentDirectoryPath)) {\n            throw new \\UnexpectedValueException('Parent directory \"' . $parentDirectoryPath . '\" is not executable!');\n        }\n\n        if (!file_exists($path)) {\n            throw new \\UnexpectedValueException('Path \"' . $path . '\" does not exist!');\n        }\n    }\n\n    /**\n     * Chmod a directory and optional recursive all subdirectories and files\n     * @param string $directoryPath   The directory to chmod\n     * @param int    $mode            The mode to set, in octal notation (e.g. 0775)\n     * @param bool   $recursive       If true, subdirectories are chmod too\n     * @param bool   $onlyDirectories If true, only directories gets chmod. If false all content gets chmod\n     * @throws \\UnexpectedValueException Throws if process is not directory owner\n     * @throws \\RuntimeException         Throws if the chmod or opendir process fails\n     * @see https://www.php.net/manual/en/function.chmod.php\n     */\n    public static function chmodDirectory($directoryPath, $mode = self::DEFAULT_MODE_DIRECTORY, $recursive = false, $onlyDirectories = true)\n    {\n        if (!self::isUnixWithPosix()) {\n            throw new \\RuntimeException('\"FileSystemUtils::chmodDirectory()\" is only available on systems with POSIX support!');\n        }\n\n        self::checkIsInAllowedDirectories($directoryPath);\n\n        if (!is_dir($directoryPath)) {\n            throw new \\UnexpectedValueException('Directory \"' . $directoryPath . '\" does not exist!');\n        }\n\n        if (!self::hasPathOwnerRight($directoryPath)) {\n            throw new \\UnexpectedValueException('Directory \"' . $directoryPath . '\" owner is different to process owner!');\n        }\n\n        $chmodResult = chmod($directoryPath, $mode);\n        if (!$chmodResult) {\n            throw new \\RuntimeException('Directory \"' . $directoryPath . '\" mode cannot be changed!');\n        }\n\n        if ($recursive) {\n            $directoryContent = self::getDirectoryContent($directoryPath);\n\n            foreach ($directoryContent as $entryPath => $type) {\n                if ($type === self::CONTENT_TYPE_DIRECTORY) {\n                    self::chmodDirectory($entryPath, $mode, $recursive, $onlyDirectories);\n                } elseif (!$onlyDirectories) {\n                    self::chmodFile($entryPath, $mode);\n                }\n            }\n        }\n    }\n\n    /**\n     * @param string $filePath The file to chmod\n     * @param int    $mode     The mode to set in octal notation (e.g. 0664)\n     * @throws \\UnexpectedValueException Throws if the file does not exist or is not chmod-able\n     * @throws \\RuntimeException         Throws if the chmod process fails\n     * @see https://www.php.net/manual/en/function.chmod.php\n     */\n    public static function chmodFile($filePath, $mode = self::DEFAULT_MODE_FILE)\n    {\n        if (!self::isUnixWithPosix()) {\n            throw new \\RuntimeException('\"FileSystemUtils::chmodFile()\" is only available on systems with POSIX support!');\n        }\n\n        self::checkIsInAllowedDirectories($filePath);\n\n        $parentDirectoryPath = dirname($filePath);\n        if (self::isUnix() && !is_executable($parentDirectoryPath)) {\n            throw new \\UnexpectedValueException('Parent directory \"' . $parentDirectoryPath . '\" is not executable!');\n        }\n\n        if (!is_file($filePath)) {\n            throw new \\UnexpectedValueException('File \"' . $filePath . '\" does not exist!');\n        }\n        if (!self::hasPathOwnerRight($filePath)) {\n            throw new \\UnexpectedValueException('File \"' . $filePath . '\" owner is different to process owner!');\n        }\n\n        $chmodResult = chmod($filePath, $mode);\n        if (!$chmodResult) {\n            throw new \\RuntimeException('File \"' . $filePath . '\" mode cannot be changed!');\n        }\n    }\n\n    /**\n     * Convert file permissions to string representation\n     * @param int $perms The file permissions\n     * @return string Returns file permissions in string representation\n     * @see https://www.php.net/manual/en/function.fileperms.php\n     */\n    private static function convertPermsToString($perms)\n    {\n        switch ($perms & 0xF000) {\n            case 0xC000: // Socket\n                $info = 's';\n                break;\n            case 0xA000: // Symbolic Link\n                $info = 'l';\n                break;\n            case 0x8000: // Regular\n                $info = '-'; // r\n                break;\n            case 0x6000: // Block special\n                $info = 'b';\n                break;\n            case 0x4000: // Directory\n                $info = 'd';\n                break;\n            case 0x2000: // Character special\n                $info = 'c';\n                break;\n            case 0x1000: // FIFO pipe\n                $info = 'p';\n                break;\n            default: // unknown\n                $info = 'u';\n        }\n\n        // User\n        $info .= (($perms & 0x0100) ? 'r' : '-');\n        $info .= (($perms & 0x0080) ? 'w' : '-');\n        $info .= (($perms & 0x0040)\n            ? (($perms & 0x0800) ? 's' : 'x')\n            : (($perms & 0x0800) ? 'S' : '-'));\n\n        // Group\n        $info .= (($perms & 0x0020) ? 'r' : '-');\n        $info .= (($perms & 0x0010) ? 'w' : '-');\n        $info .= (($perms & 0x0008)\n            ? (($perms & 0x0400) ? 's' : 'x')\n            : (($perms & 0x0400) ? 'S' : '-'));\n\n        // Other\n        $info .= (($perms & 0x0004) ? 'r' : '-');\n        $info .= (($perms & 0x0002) ? 'w' : '-');\n        $info .= (($perms & 0x0001)\n            ? (($perms & 0x0200) ? 't' : 'x')\n            : (($perms & 0x0200) ? 'T' : '-'));\n\n        return $info;\n    }\n\n    /**\n     * Copies a directory\n     * @param string             $oldDirectoryPath The directory to copy\n     * @param string             $newDirectoryPath The destination directory\n     * @param array<string,bool> $options          Operation options ([bool] createDirectoryStructure = true, [bool] overwriteContent = false)\n     * @throws \\UnexpectedValueException Throws if a precondition is not fulfilled\n     * @throws \\RuntimeException         Throws if the mkdir, copy or opendir process fails\n     * @return bool Returns true if content was overwritten\n     */\n    public static function copyDirectory($oldDirectoryPath, $newDirectoryPath, array $options = array())\n    {\n        $returnValue = self::checkDirectoryPreconditions($oldDirectoryPath, $newDirectoryPath, $options);\n\n        self::doCopyDirectory($oldDirectoryPath, $newDirectoryPath);\n\n        return $returnValue;\n    }\n\n    /**\n     * Copies a file\n     * @param string             $oldFilePath The file to copy\n     * @param string             $newFilePath The path where to copy to\n     * @param array<string,bool> $options     Operation options ([bool] createDirectoryStructure = true, [bool] overwrite = false)\n     * @throws \\UnexpectedValueException Throws if a precondition is not fulfilled\n     * @throws \\RuntimeException         Throws if the copy process fails\n     * @return bool Returns true if the destination path was overwritten\n     * @see https://www.php.net/manual/en/function.copy.php\n     */\n    public static function copyFile($oldFilePath, $newFilePath, array $options = array())\n    {\n        $returnValue = self::checkFilePreconditions('copy', $oldFilePath, $newFilePath, $options);\n\n        $copyResult = copy($oldFilePath, $newFilePath);\n        if (!$copyResult) {\n            throw new \\RuntimeException('File \"' . $oldFilePath . '\" cannot be copied!');\n        }\n\n        return $returnValue;\n    }\n\n    /**\n     * Creates a directory if it already did not exist\n     * @param string              $directoryPath The directory to create\n     * @param array<string,mixed> $options       Operation options ([int] mode = 0775, [int] modeParents = 0775, [bool] createDirectoryStructure = true)\n     * @throws \\UnexpectedValueException Throws if the parent directory is not writable\n     * @throws \\RuntimeException         Throws if the mkdir process fails\n     * @return bool Returns true if directory was successfully created or false if directory did already exist\n     * @see https://www.php.net/manual/en/function.mkdir.php\n     */\n    public static function createDirectoryIfNotExists($directoryPath, array $options = array())\n    {\n        self::checkIsInAllowedDirectories($directoryPath);\n\n        $defaultOptions = array('mode' => self::DEFAULT_MODE_DIRECTORY, 'modeParents' => self::DEFAULT_MODE_DIRECTORY, 'createDirectoryStructure' => true);\n        $options = array_merge($defaultOptions, $options);\n\n        if (is_dir($directoryPath)) {\n            return false;\n        }\n\n        $parentDirectoryPath = dirname($directoryPath);\n        if (!is_dir($parentDirectoryPath)) {\n            if ($options['createDirectoryStructure']) {\n                $parentOptions = $options;\n                $parentOptions['mode'] = $options['modeParents'];\n                self::createDirectoryIfNotExists($parentDirectoryPath, $parentOptions);\n            } else {\n                throw new \\UnexpectedValueException('Parent directory \"' . $parentDirectoryPath . '\" does not exist!');\n            }\n        }\n        if (self::isUnix() && !is_executable($parentDirectoryPath)) {\n            throw new \\UnexpectedValueException('Parent directory \"' . $parentDirectoryPath . '\" is not executable!');\n        }\n        if (!is_writable($parentDirectoryPath)) {\n            throw new \\UnexpectedValueException('Parent directory \"' . $parentDirectoryPath . '\" is not writable!');\n        }\n\n        $mkdirResult = mkdir($directoryPath, $options['mode']);\n        if (!$mkdirResult) {\n            throw new \\RuntimeException('Directory \"' . $directoryPath . '\" cannot be created!');\n        }\n\n        if (self::isUnixWithPosix()) {\n            if (!self::hasPathOwnerRight($directoryPath)) {\n                throw new \\UnexpectedValueException('Directory \"' . $directoryPath . '\" owner is different to process owner!');\n            }\n\n            $chmodResult = chmod($directoryPath, $options['mode']);\n            if (!$chmodResult) {\n                throw new \\RuntimeException('Directory \"' . $directoryPath . '\" mode cannot be changed!');\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Deletes the content of a directory\n     * @param string $directoryPath The directory where to delete the content\n     * @throws \\UnexpectedValueException Throws if directory is not writable and readable\n     * @throws \\RuntimeException         Throws if the unlink, rmdir or opendir process fails\n     * @return bool Returns true if directory content was successfully deleted or false if directory was already empty\n     * @see https://www.php.net/manual/en/function.opendir.php\n     * @see https://www.php.net/manual/en/function.readdir.php\n     */\n    public static function deleteDirectoryContentIfExists($directoryPath)\n    {\n        self::checkIsInAllowedDirectories($directoryPath);\n\n        if (!is_dir($directoryPath)) {\n            throw new \\UnexpectedValueException('Directory \"' . $directoryPath . '\" does not exist!');\n        }\n\n        if (self::isDirectoryEmpty($directoryPath)) {\n            return false;\n        }\n\n        if (!is_writable($directoryPath)) {\n            throw new \\UnexpectedValueException('Directory \"' . $directoryPath . '\" is not writable!');\n        }\n        if (!is_readable($directoryPath)) {\n            throw new \\UnexpectedValueException('Directory \"' . $directoryPath . '\" is not readable!');\n        }\n\n        $dirHandle = opendir($directoryPath);\n        if ($dirHandle === false) {\n            throw new \\RuntimeException('Directory \"' . $directoryPath . '\" cannot be opened!');\n        }\n\n        while (($entry = readdir($dirHandle)) !== false) {\n            if ($entry === '.' || $entry === '..') {\n                continue;\n            }\n\n            $directoryEntry = $directoryPath . DIRECTORY_SEPARATOR . $entry;\n\n            if (is_dir($directoryEntry)) {\n                self::deleteDirectoryIfExists($directoryEntry, true);\n            } else {\n                self::deleteFileIfExists($directoryEntry);\n            }\n        }\n        closedir($dirHandle);\n\n        return true;\n    }\n\n    /**\n     * Deletes a directory if it exists\n     * @param string $directoryPath     The directory to delete\n     * @param bool   $deleteWithContent If true, directory will also be deleted if directory is not empty\n     * @throws \\UnexpectedValueException Throws if the parent directory is not writable\n     * @throws \\RuntimeException         Throws if the rmdir or opendir process fails\n     * @return bool Returns true if directory was successfully deleted or false if directory already did not exist\n     * @see https://www.php.net/manual/en/function.rmdir.php\n     */\n    public static function deleteDirectoryIfExists($directoryPath, $deleteWithContent = false)\n    {\n        self::checkIsInAllowedDirectories($directoryPath);\n\n        if ($directoryPath === self::ROOT_FOLDER) {\n            throw new \\UnexpectedValueException('Directory \"' . self::ROOT_FOLDER . '\" cannot be deleted!');\n        }\n\n        $parentDirectoryPath = dirname($directoryPath);\n        if (self::isUnix() && !is_executable($parentDirectoryPath)) {\n            throw new \\UnexpectedValueException('Parent directory \"' . $parentDirectoryPath . '\" is not executable!');\n        }\n        if (!is_dir($directoryPath)) {\n            return false;\n        }\n\n        if (!self::isDirectoryEmpty($directoryPath)) {\n            if ($deleteWithContent) {\n                self::deleteDirectoryContentIfExists($directoryPath);\n            } else {\n                throw new \\UnexpectedValueException('Directory \"' . $directoryPath . '\" is not empty!');\n            }\n        }\n\n        if (!is_writable($parentDirectoryPath)) {\n            throw new \\UnexpectedValueException('Parent directory \"' . $parentDirectoryPath . '\" is not writable!');\n        }\n\n        $rmdirResult = rmdir($directoryPath);\n        if (!$rmdirResult) {\n            throw new \\RuntimeException('Directory \"' . $directoryPath . '\" cannot be deleted!');\n        }\n\n        return true;\n    }\n\n    /**\n     * Deletes a file if it exists\n     * @param string $filePath The file to delete\n     * @throws UnexpectedValueException Throws if the file is not writable\n     * @throws RuntimeException         Throws if the delete process fails\n     * @return bool Returns true if file was successfully deleted or false if file already did not exist\n     * @see https://www.php.net/manual/en/function.unlink.php\n     */\n    public static function deleteFileIfExists($filePath)\n    {\n        self::checkIsInAllowedDirectories($filePath);\n\n        $parentDirectoryPath = dirname($filePath);\n        if (self::isUnix() && !is_executable($parentDirectoryPath)) {\n            throw new UnexpectedValueException('Parent directory \"' . $parentDirectoryPath . '\" is not executable!');\n        }\n        if (!is_writable($parentDirectoryPath)) {\n            throw new UnexpectedValueException('Parent directory \"' . $parentDirectoryPath . '\" is not writable!');\n        }\n\n        if (!is_file($filePath)) {\n            return false;\n        }\n\n        $unlinkResult = unlink($filePath);\n        if (!$unlinkResult) {\n            throw new RuntimeException('File \"' . $filePath . '\" cannot be deleted!');\n        }\n\n        return true;\n    }\n\n    /**\n     * Execute the copy process to copy a directory\n     * @param string $oldDirectoryPath The directory to copy\n     * @param string $newDirectoryPath The destination directory\n     * @throws \\UnexpectedValueException Throws if a precondition is not fulfilled\n     * @throws \\RuntimeException         Throws if the mkdir, copy or opendir process fails\n     */\n    private static function doCopyDirectory($oldDirectoryPath, $newDirectoryPath)\n    {\n        $oldDirectoryContent = self::getDirectoryContent($oldDirectoryPath, false, false);\n\n        foreach ($oldDirectoryContent as $entry => $type) {\n            $oldEntryPath = $oldDirectoryPath . DIRECTORY_SEPARATOR . $entry;\n            $newEntryPath = $newDirectoryPath . DIRECTORY_SEPARATOR . $entry;\n\n            if ($type === self::CONTENT_TYPE_DIRECTORY) {\n                if (!is_dir($newEntryPath)) {\n                    self::createDirectoryIfNotExists($newEntryPath);\n                }\n\n                self::doCopyDirectory($oldEntryPath, $newEntryPath);\n            } else {\n                self::copyFile($oldEntryPath, $newEntryPath, array('overwrite' => true));\n            }\n        }\n    }\n\n    /**\n     * Gets the total, free and used disk space in bytes\n     * @param string $path Path of the filesystem\n     * @throws \\RuntimeException Throws if the given path is not in an allowed directory or disk-space could not be determined\n     * @return array<string,float> Returns the total, free and used disk space in bytes\n     * @see https://www.php.net/manual/en/function.disk-total-space.php\n     * @see https://www.php.net/manual/en/function.disk-free-space.php\n     * @example array(\"total\" => 10737418240, \"free\" => 2147483648, \"used\" => 8589934592)\n     */\n    public static function getDiskSpace($path = self::ROOT_FOLDER)\n    {\n        self::checkIsInAllowedDirectories($path);\n\n        $total = function_exists('disk_total_space') ? disk_total_space($path) : false;\n        if ($total === false) {\n            throw new \\RuntimeException('Total disk-space could not be determined!');\n        }\n\n        $free = function_exists('disk_free_space') ? disk_free_space($path) : false;\n        if ($free === false) {\n            throw new \\RuntimeException('Free disk-space could not be determined!');\n        }\n\n        $used = $total - $free;\n\n        return array('total' => $total, 'free' => $free, 'used' => $used);\n    }\n\n    /**\n     * Get the relevant Font Awesome icon for the current file\n     * @return string Returns the name of the Font Awesome icon\n     */\n    public static function getFileFontAwesomeIcon($filename)\n    {\n        $iconFile = 'fa-file';\n        $fileExtension = strtolower(pathinfo($filename, PATHINFO_EXTENSION));\n\n\n        if (array_key_exists($fileExtension, self::$iconFileExtension)) {\n            $iconFile = self::$iconFileExtension[$fileExtension]['icon'];\n        }\n\n        return $iconFile;\n    }\n\n    /**\n     * Get the MIME type of the current file e.g. 'image/jpeg'\n     * @return string MIME type of the current file\n     */\n    public static function getFileMimeType($filename)\n    {\n        $mimeType = 'application/octet-stream';\n        $fileExtension = strtolower(pathinfo($filename, PATHINFO_EXTENSION));\n\n        if (array_key_exists($fileExtension, self::$iconFileExtension)) {\n            $mimeType = self::$iconFileExtension[$fileExtension]['mime-type'];\n        }\n\n        return $mimeType;\n    }\n\n    /**\n     * Get a generated filename with a timestamp and a secure random identifier\n     * @param string $filename The original filename\n     * @throws AdmException Throws if secure random identifier could not be generated\n     * @return string Returns the generated filename\n     * @example \"IMG_123456.JPG\" => \"20180131-123456_0123456789abcdef.jpg\"\n     */\n    public static function getGeneratedFilename($filename)\n    {\n        $extension = pathinfo($filename, PATHINFO_EXTENSION);\n        $now = new \\DateTime();\n\n        return $now->format('Ymd-His') . '_' . SecurityUtils::getRandomString(16, $charset = '0123456789abcdefghijklmnopqrstuvwxyz') . '.' . strtolower($extension);\n    }\n\n    /**\n     * Get a from special-characters clean path-entry\n     * @param string $pathname The path-entry to clean\n     * @param string $replacer The character to replace spacial-characters with\n     * @return string Returns the special-characters cleaned path-entry\n     * @example \"image-12#34+\u00df.jpg\" => \"image-12_34__.jpg\"\n     */\n    public static function getSanitizedPathEntry($pathname, $replacer = '_')\n    {\n        return preg_replace('/[^A-Za-z0-9._-]/u', $replacer, $pathname);\n    }\n\n    /**\n     * Get a normalized/simplified path\n     * @param string $path The path to normalize\n     * @throws \\UnexpectedValueException Throws if the given path is higher than root\n     * @return string Returns the normalized path\n     * @see https://www.php.net/manual/en/function.realpath.php\n     * @example \"/path/to/test/.././..//..///..///../one/two/../three/filename\" => \"../../one/three/filename\"\n     */\n    public static function getNormalizedPath($path)\n    {\n        $path = str_replace('\\\\', '/', $path); // Replace back-slashes with forward-slashes\n        $path = preg_replace('/\\/+/', '/', $path); // Combine multiple slashes into a single slash\n\n        $segments = explode('/', $path);\n\n        $parts = array();\n        foreach ($segments as $segment) {\n            if ($segment === '.') {\n                // Actual directory => ignore\n                continue;\n            }\n\n            $test = array_pop($parts);\n            if ($test === null) {\n                // No path added => add first path\n                $parts[] = $segment;\n            } elseif ($segment === '..') {\n                if ($test === '..') {\n                    // Change to grand-parent directory => add two times \"..\"\n                    $parts[] = $test;\n                    $parts[] = $segment;\n                } elseif ($test === '') {\n                    // File-system root => higher as root is not possible/valid => throw Exception\n                    throw new \\UnexpectedValueException('Path \"' . $path . '\" is higher than root!');\n                }\n//                else\n//                {\n//                    // Change to parent directory => ignore\n//                }\n            } else {\n                // New sub-path => add parent path and new path\n                $parts[] = $test;\n                $parts[] = $segment;\n            }\n        }\n\n        return implode(DIRECTORY_SEPARATOR, $parts);\n    }\n\n    /**\n     * Gets human readable bytes with unit\n     * @param int  $bytes The bytes\n     * @param bool $si    Use SI or binary unit. Set true for SI units\n     * @return string Returns human readable bytes with unit.\n     * @example \"[value] [unit]\" (e.g: 34.5 MiB)\n     */\n    public static function getHumanReadableBytes($bytes, $si = false)\n    {\n        $divider = 1024;\n        $units = array('B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'YiB');\n        if ($si) {\n            $divider = 1000;\n            $units = array('B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'YB');\n        }\n\n        $iteration = 0;\n        while ($bytes >= $divider) {\n            ++$iteration;\n            $bytes /= $divider;\n        }\n\n        $unit = $units[$iteration];\n\n        return round($bytes, 3 - (int) floor(log10($bytes))) . ' ' . $unit;\n    }\n\n    /**\n     * Gets info about the php-process owner\n     * @throws \\RuntimeException Throws if system does not support POSIX\n     * @return array<string,string|int> Returns info about the php-process owner\n     * @see https://www.php.net/manual/en/function.posix-geteuid.php\n     * @see https://www.php.net/manual/en/function.posix-getpwuid.php\n     * @example\n     * array(\n     *     \"name\" => \"max\", \"passwd\" => \"x\", \"uid\" => 1000, \"gid\" => 1000,\n     *     \"gecos\" => \"max,,,\", \"dir\" => \"/home/max\", \"shell\" => \"/bin/bash\"\n     * )\n     */\n    public static function getProcessOwnerInfo()\n    {\n        if (!self::isUnix()) {\n            throw new \\RuntimeException('\"FileSystemUtils::getProcessOwnerInfo()\" is only available on systems with POSIX support!');\n        }\n\n        return posix_getpwuid(posix_geteuid());\n    }\n\n    /**\n     * Gets info about the php-process group\n     * @throws \\RuntimeException Throws if system does not support POSIX\n     * @return array<string,string|int|array> Returns info about the php-process group\n     * @see https://www.php.net/manual/en/function.posix-getegid.php\n     * @see https://www.php.net/manual/en/function.posix-getgrgid.php\n     * @example array(\"name\" => \"max\", \"passwd\" => \"x\", \"members\" => array(), \"gid\" => 1000)\n     */\n    public static function getProcessGroupInfo()\n    {\n        if (!self::isUnix()) {\n            throw new \\RuntimeException('\"FileSystemUtils::getProcessGroupInfo()\" is only available on systems with POSIX support!');\n        }\n\n        return posix_getgrgid(posix_getegid());\n    }\n\n    /**\n     * Gets info about the path owner\n     * @param string $path The path from which to get the information\n     * @throws \\UnexpectedValueException Throws if path does not exist\n     * @throws \\RuntimeException         Throws if the fileowner determination fails or system does not support POSIX\n     * @return array<string,string|int> Returns info about the path owner\n     * @see https://www.php.net/manual/en/function.fileowner.php\n     */\n    public static function getPathOwnerInfo($path)\n    {\n        if (!self::isUnixWithPosix()) {\n            throw new \\RuntimeException('\"FileSystemUtils::getPathOwnerInfo()\" is only available on systems with POSIX support!');\n        }\n\n        self::checkIsInAllowedDirectories($path);\n\n        self::checkParentDirExecAndPathExist($path);\n\n        $fileOwnerResult = fileowner($path);\n        if ($fileOwnerResult === false) {\n            throw new \\RuntimeException('File \"' . $path . '\" owner cannot be determined!');\n        }\n\n        return posix_getpwuid($fileOwnerResult);\n    }\n\n    /**\n     * Gets info about the path group\n     * @param string $path The path from which to get the information\n     * @throws \\UnexpectedValueException Throws if path does not exist\n     * @throws \\RuntimeException         Throws if the groupowner determination fails or system does not support POSIX\n     * @return array<string,string|int|array> Returns info about the path group\n     * @see https://www.php.net/manual/en/function.filegroup.php\n     */\n    public static function getPathGroupInfo($path)\n    {\n        if (!self::isUnix()) {\n            throw new \\RuntimeException('\"FileSystemUtils::getPathGroupInfo()\" is only available on systems with POSIX support!');\n        }\n\n        self::checkIsInAllowedDirectories($path);\n\n        self::checkParentDirExecAndPathExist($path);\n\n        $fileGroupResult = filegroup($path);\n        if ($fileGroupResult === false) {\n            throw new \\RuntimeException('File \"' . $path . '\" group cannot be determined!');\n        }\n\n        return posix_getgrgid($fileGroupResult);\n    }\n\n    /**\n     * Checks if the php-process is the path owner\n     * @param string $path The path from which to get the information\n     * @throws \\UnexpectedValueException Throws if path does not exist\n     * @throws \\RuntimeException         Throws if the fileowner determination fails or system does not support POSIX\n     * @return bool Returns true if php-process is the path owner\n     * @see https://www.php.net/manual/en/function.posix-geteuid.php\n     * @see https://www.php.net/manual/en/function.posix-getpwuid.php\n     * @see https://www.php.net/manual/en/function.fileowner.php\n     */\n    public static function hasPathOwnerRight($path)\n    {\n        if (!self::isUnixWithPosix()) {\n            throw new \\RuntimeException('\"FileSystemUtils::hasPathOwnerRight()\" is only available on systems with POSIX support!');\n        }\n\n        self::checkIsInAllowedDirectories($path);\n\n        $processOwnerInfo = self::getProcessOwnerInfo();\n        $pathOwnerInfo = self::getPathOwnerInfo($path);\n\n        return $processOwnerInfo['uid'] === self::ROOT_ID || $processOwnerInfo['uid'] === $pathOwnerInfo['uid'];\n    }\n\n    /**\n     * Gets the mode permissions of a path\n     * @param string $path  The path from which to get the information\n     * @param bool   $octal Set true to get the octal instead of the string mode representation\n     * @throws \\UnexpectedValueException Throws if path does not exist\n     * @throws \\RuntimeException         Throws if the permissions determination fails\n     * @return string Returns the mode permissions of a path in octal or string representation\n     * @see https://www.php.net/manual/en/function.fileperms.php\n     * @example \"drwxrwxr-x\" or \"0775\"\n     */\n    public static function getPathMode($path, $octal = false)\n    {\n        self::checkIsInAllowedDirectories($path);\n\n        self::checkParentDirExecAndPathExist($path);\n\n        $perms = fileperms($path);\n        if ($perms === false) {\n            throw new \\RuntimeException('File \"' . $path . '\" permissions cannot be read!');\n        }\n\n        if ($octal) {\n            return substr(sprintf('%o', $perms), -4);\n        }\n\n        return self::convertPermsToString($perms);\n    }\n\n    /**\n     * Gets owner, group and mode info from a path\n     * @param string $path The path from which to get the information\n     * @throws \\UnexpectedValueException Throws if path does not exist\n     * @throws \\RuntimeException         Throws if a info determination fails\n     * @return array<string,string> Returns owner, group and mode info from a path\n     * @see https://www.php.net/manual/en/function.fileowner.php\n     * @see https://www.php.net/manual/en/function.filegroup.php\n     * @see https://www.php.net/manual/en/function.fileperms.php\n     * @example array(\"owner\" => \"www-data\", \"group\" => \"www\", \"mode\" => \"drwxrwxr-x\")\n     */\n    public static function getPathPermissions($path)\n    {\n        self::checkIsInAllowedDirectories($path);\n\n        self::checkParentDirExecAndPathExist($path);\n\n        if (self::isUnixWithPosix()) {\n            $ownerInfo = self::getPathOwnerInfo($path);\n            $groupInfo = self::getPathGroupInfo($path);\n\n            return array(\n                'owner' => $ownerInfo['name'],\n                'group' => $groupInfo['name'],\n                'mode' => self::getPathMode($path)\n            );\n        }\n\n        return array(\n            'owner' => null,\n            'group' => null,\n            'mode' => self::getPathMode($path)\n        );\n    }\n\n    /**\n     * Gets the content of a directory and optional recursive from all subdirectories\n     * @param string            $directoryPath        The directory from which to get the content\n     * @param bool              $recursive            If true, also all subdirectories are scanned\n     * @param bool              $fullPath             Set true to get the full paths instead of the content entry names\n     * @param array<int,string> $includedContentTypes A list with all content types that should get returned (directories, files, links)\n     * @throws \\UnexpectedValueException Throws if directory is not readable\n     * @throws \\RuntimeException         Throws if the opendir process fails\n     * @return array<string,string|array> The content of the directory (and all the subdirectories)\n     * @see https://www.php.net/manual/en/function.opendir.php\n     * @see https://www.php.net/manual/en/function.readdir.php\n     */\n    public static function getDirectoryContent($directoryPath, $recursive = false, $fullPath = true, array $includedContentTypes = array(self::CONTENT_TYPE_DIRECTORY, self::CONTENT_TYPE_FILE, self::CONTENT_TYPE_LINK))\n    {\n        self::checkIsInAllowedDirectories($directoryPath);\n\n        if (!is_dir($directoryPath)) {\n            throw new \\UnexpectedValueException('Directory \"' . $directoryPath . '\" does not exist!');\n        }\n        if (!is_readable($directoryPath)) {\n            throw new \\UnexpectedValueException('Directory \"' . $directoryPath . '\" is not readable!');\n        }\n\n        $dirHandle = opendir($directoryPath);\n        if ($dirHandle === false) {\n            throw new \\RuntimeException('Directory \"' . $directoryPath . '\" cannot be opened!');\n        }\n\n        $directoryContent = array();\n\n        while (($entry = readdir($dirHandle)) !== false) {\n            if ($entry === '.' || $entry === '..' || strpos($entry, '.') === 0) {\n                continue;\n            }\n\n            $directoryEntry = $directoryPath . DIRECTORY_SEPARATOR . $entry;\n            $entryValue = $fullPath ? $directoryEntry : (string) $entry;\n\n            if (is_dir($directoryEntry)) {\n                if ($recursive) {\n                    $directoryContent[$entryValue] = self::getDirectoryContent($directoryEntry, $recursive, $fullPath, $includedContentTypes);\n                } elseif (in_array(self::CONTENT_TYPE_DIRECTORY, $includedContentTypes, true)) {\n                    $directoryContent[$entryValue] = self::CONTENT_TYPE_DIRECTORY;\n                }\n            } elseif (is_file($directoryEntry) && in_array(self::CONTENT_TYPE_FILE, $includedContentTypes, true)) {\n                $directoryContent[$entryValue] = self::CONTENT_TYPE_FILE;\n            } elseif (is_link($directoryEntry) && in_array(self::CONTENT_TYPE_LINK, $includedContentTypes, true)) {\n                $directoryContent[$entryValue] = self::CONTENT_TYPE_LINK;\n            }\n        }\n        closedir($dirHandle);\n\n        return $directoryContent;\n    }\n\n    /**\n     * Checks if a directory is empty\n     * @param string $directoryPath The directory to check if is empty\n     * @throws \\UnexpectedValueException Throws if the directory is not readable\n     * @throws \\RuntimeException         Throws if the opendir process fails\n     * @return bool Returns true if the directory is empty\n     * @see https://www.php.net/manual/en/function.opendir.php\n     * @see https://www.php.net/manual/en/function.readdir.php\n     */\n    public static function isDirectoryEmpty($directoryPath)\n    {\n        self::checkIsInAllowedDirectories($directoryPath);\n\n        if (!is_dir($directoryPath)) {\n            throw new \\UnexpectedValueException('Directory \"' . $directoryPath . '\" does not exist!');\n        }\n        if (!is_readable($directoryPath)) {\n            throw new \\UnexpectedValueException('Directory \"' . $directoryPath . '\" is not readable!');\n        }\n\n        $dirHandle = opendir($directoryPath);\n        if ($dirHandle === false) {\n            throw new \\RuntimeException('Directory \"' . $directoryPath . '\" cannot be opened!');\n        }\n\n        while (($entry = readdir($dirHandle)) !== false) {\n            if ($entry !== '.' && $entry !== '..') {\n                closedir($dirHandle);\n\n                return false;\n            }\n        }\n        closedir($dirHandle);\n\n        return true;\n    }\n\n    /**\n     * Check if the current file format could be viewed within a browser.\n     * @return bool Return true if the file could be viewed in the browser otherwise false.\n     */\n    public static function isViewableFileInBrowser($filename)\n    {\n        $returnCode = false;\n        $fileExtension = strtolower(pathinfo($filename, PATHINFO_EXTENSION));\n\n        if (array_key_exists($fileExtension, self::$iconFileExtension)) {\n            $returnCode = self::$iconFileExtension[$fileExtension]['viewable'];\n        }\n\n        return $returnCode;\n    }\n\n    /**\n     * Moves a directory\n     * @param string             $oldDirectoryPath The directory to move\n     * @param string             $newDirectoryPath The destination directory\n     * @param array<string,bool> $options          Operation options ([bool] createDirectoryStructure = true, [bool] overwriteContent = false)\n     * @throws \\UnexpectedValueException Throws if a precondition is not fulfilled\n     * @throws \\RuntimeException         Throws if the mkdir, copy, rmdir, unlink or opendir process fails\n     * @return bool Returns true if content was overwritten\n     */\n    public static function moveDirectory($oldDirectoryPath, $newDirectoryPath, array $options = array())\n    {\n        $returnValue = self::checkDirectoryPreconditions($oldDirectoryPath, $newDirectoryPath, $options);\n\n        self::doCopyDirectory($oldDirectoryPath, $newDirectoryPath);\n\n        self::deleteDirectoryIfExists($oldDirectoryPath, true);\n\n        return $returnValue;\n    }\n\n    /**\n     * Moves a file\n     * @param string             $oldFilePath The file to move\n     * @param string             $newFilePath The path where to move to\n     * @param array<string,bool> $options     Operation options ([bool] createDirectoryStructure = true, [bool] overwrite = false)\n     * @throws \\UnexpectedValueException Throws if a precondition is not fulfilled\n     * @throws \\RuntimeException         Throws if the move process fails\n     * @return bool Returns true if the destination path was overwritten\n     * @see https://www.php.net/manual/en/function.rename.php\n     */\n    public static function moveFile($oldFilePath, $newFilePath, array $options = array())\n    {\n        $returnValue = self::checkFilePreconditions('move', $oldFilePath, $newFilePath, $options);\n\n        $renameResult = rename($oldFilePath, $newFilePath);\n        if (!$renameResult) {\n            throw new \\RuntimeException('File \"' . $oldFilePath . '\" cannot be moved!');\n        }\n\n        return $returnValue;\n    }\n\n    /**\n     * Method will read the content of the file that is set through the parameter and return the\n     * file content. It will check if the file exists and if it's readable for the PHP user.\n     * @param string $filePath The file to read\n     * @throws \\UnexpectedValueException Throws if the file does not exist or is not readable\n     * @throws \\RuntimeException         Throws if the read process fails\n     * @return string Returns the file content\n     * @see https://www.php.net/manual/en/function.file-get-contents.php\n     */\n    public static function readFile($filePath)\n    {\n        self::checkIsInAllowedDirectories($filePath);\n\n        if (!is_file($filePath)) {\n            throw new \\UnexpectedValueException('File \"' . $filePath . '\" does not exist!');\n        }\n        if (!is_readable($filePath)) {\n            throw new \\UnexpectedValueException('File \"' . $filePath . '\" is not readable!');\n        }\n\n        $data = file_get_contents($filePath);\n        if ($data === false) {\n            throw new \\RuntimeException('File \"' . $filePath . '\" cannot be read!');\n        }\n\n        return $data;\n    }\n\n    /**\n     * Remove anything which isn't a word, whitespace, number\n     * or any of the following characters: \"-_~:;<>|[]().\"\n     * @params string $filename The filename where the invalid characters should be removed\n     * @return string Returns the filename with the removed invalid characters\n     */\n    public static function removeInvalidCharsInFilename($filename)\n    {\n        // remove NULL value from filename\n        $filename = str_replace(chr(0), '', $filename);\n        $filename = preg_replace(\"/([^\\w\\s\\d\\-_~:;<>|\\[\\]\\(\\).])/u\", '', $filename);\n        // Remove any runs of periods\n        $filename = preg_replace(\"/([\\.]{2,})/u\", '', $filename);\n\n        return $filename;\n    }\n\n    /**\n     * Restrict all operations of this class to specific directories\n     * @param array<int,string> $directoryPaths The allowed directories\n     * @throws \\UnexpectedValueException Throws if a given directory does not exist\n     */\n    public static function setAllowedDirectories(array $directoryPaths = array())\n    {\n        foreach ($directoryPaths as &$directoryPath) {\n            $directoryPath = self::getNormalizedPath($directoryPath);\n            if (!is_dir($directoryPath)) {\n                throw new \\UnexpectedValueException('Directory \"' . $directoryPath . '\" does not exist!');\n            }\n        }\n        unset($directoryPath);\n\n        self::$allowedDirectories = $directoryPaths;\n    }\n\n    /**\n     * Write some data into a file\n     * @param string $filePath The file to write\n     * @param string $data     The data to write\n     * @param bool   $append   If true the data gets appended instead of overwriting the content\n     * @throws \\UnexpectedValueException Throws if the file or parent directory is not writable\n     * @throws \\RuntimeException         Throws if the write process fails\n     * @return int Returns the written bytes\n     * @see https://www.php.net/manual/en/function.file-put-contents.php\n     */\n    public static function writeFile($filePath, $data, $append = false)\n    {\n        self::checkIsInAllowedDirectories($filePath);\n\n        $parentDirectoryPath = dirname($filePath);\n        if (self::isUnix() && !is_executable($parentDirectoryPath)) {\n            throw new \\UnexpectedValueException('Parent directory \"' . $parentDirectoryPath . '\" is not executable!');\n        }\n\n        if (is_file($filePath)) {\n            if (!is_writable($filePath)) {\n                throw new \\UnexpectedValueException('File \"' . $filePath . '\" is not writable!');\n            }\n        } else {\n            if (!is_writable($parentDirectoryPath)) {\n                throw new \\UnexpectedValueException('Parent directory \"' . $parentDirectoryPath . '\" is not writable!');\n            }\n        }\n\n        $flags = 0;\n        if ($append) {\n            $flags = FILE_APPEND;\n        }\n\n        $bytes = file_put_contents($filePath, $data, $flags);\n        if ($bytes === false) {\n            throw new \\RuntimeException('File \"' . $filePath . '\" cannot be written!');\n        }\n\n        return $bytes;\n    }\n}\n", "<?php\n/**\n ***********************************************************************************************\n * Class manages access to database table adm_files\n *\n * @copyright 2004-2023 The Admidio Team\n * @see https://www.admidio.org/\n * @license https://www.gnu.org/licenses/gpl-2.0.html GNU General Public License v2.0 only\n ***********************************************************************************************\n */\n\n/**\n * Diese Klasse dient dazu ein Fileobjekt zu erstellen.\n * Eine Datei kann ueber diese Klasse in der Datenbank verwaltet werden\n *\n * Beside the methods of the parent class there are the following additional methods:\n *\n * getFileForDownload($fileId)\n *                         - File mit der uebergebenen ID aus der Datenbank auslesen fuer\n *                           das Downloadmodul. Hier wird auch direkt ueberprueft ob die\n *                           Datei oder der Ordner gesperrt ist.\n * getCompletePathOfFile() - Gibt den kompletten Pfad der Datei zurueck\n */\nclass TableFile extends TableAccess\n{\n    /**\n     * Constructor that will create an object of a recordset of the table adm_files.\n     * If the id is set than the specific files will be loaded.\n     * @param Database $database Object of the class Database. This should be the default global object **$gDb**.\n     * @param int      $filId    The recordset of the files with this id will be loaded. If id isn't set than an empty object of the table is created.\n     */\n    public function __construct(Database $database, $filId = 0)\n    {\n        // read also data of assigned folder\n        $this->connectAdditionalTable(TBL_FOLDERS, 'fol_id', 'fil_fol_id');\n\n        parent::__construct($database, TBL_FILES, 'fil', $filId);\n    }\n\n    /**\n     * Check if the file extension of the current file format is allowed for upload and the\n     * documents and files module.\n     * @return bool Return true if the file extension is allowed to be used within Admidio.\n     */\n    public function allowedFileExtension(): bool\n    {\n        return FileSystemUtils::allowedFileExtension($this->getValue('fil_name', 'database'));\n    }\n\n    /**\n     * Deletes the selected record of the table and the associated file in the file system.\n     * After that the class will be initialize.\n     * @return bool **true** if no error occurred\n     */\n    public function delete()\n    {\n        global $gLogger;\n\n        try {\n            FileSystemUtils::deleteFileIfExists($this->getFullFilePath());\n        } catch (\\RuntimeException $exception) {\n            $gLogger->error('Could not delete file!', array('filePath' => $this->getFullFilePath()));\n            // TODO\n        }\n\n        // Even if the delete won't work, return true, so that the entry of the DB disappears\n        return parent::delete();\n    }\n\n    /**\n     * Gets the absolute path of the folder (with folder-name)\n     * @return string Returns the folder path of the current file.\n     */\n    public function getFullFolderPath()\n    {\n        return ADMIDIO_PATH . $this->getValue('fol_path', 'database') . '/' . $this->getValue('fol_name', 'database');\n    }\n\n    /**\n     * Gets the absolute path of the file\n     * @return string Returns the folder path with the file name of the current file.\n     */\n    public function getFullFilePath()\n    {\n        return $this->getFullFolderPath() . '/' . $this->getValue('fil_name', 'database');\n    }\n\n    /**\n     * Get the extension of the file\n     * @return string Extension of the file e.g. 'pdf' or 'jpg'\n     */\n    public function getFileExtension()\n    {\n        return strtolower(pathinfo($this->getValue('fil_name'), PATHINFO_EXTENSION));\n    }\n\n    /**\n     * Reads the file recordset from database table **adm_folders** and throws an AdmException\n     * if the user has no right to see the corresponding folder or the file id doesn't exists.\n     * @param string $fileUuid The UUID of the file.\n     * @throws AdmException SYS_FOLDER_NO_RIGHTS\n     *                      SYS_INVALID_PAGE_VIEW\n     * @return true Returns **true** if everything is ok otherwise an AdmException is thrown.\n     */\n    public function getFileForDownload($fileUuid)\n    {\n        global $gCurrentUser;\n\n        $this->readDataByUuid($fileUuid);\n\n        // Check if a dataset is found\n        if ((int) $this->getValue('fil_id') === 0) {\n            throw new AdmException('SYS_INVALID_PAGE_VIEW');\n        }\n\n        // If current user has download-admin-rights => allow\n        if ($gCurrentUser->adminDocumentsFiles()) {\n            return true;\n        }\n\n        // If file is locked (and no download-admin-rights) => throw exception\n        if ($this->getValue('fil_locked')) {\n            $this->clear();\n            throw new AdmException('SYS_FOLDER_NO_RIGHTS');\n        }\n\n        // If folder is public (and file is not locked) => allow\n        if ($this->getValue('fol_public')) {\n            return true;\n        }\n\n        // check if user has a membership in a role that is assigned to the current folder\n        $folderViewRolesObject = new RolesRights($this->db, 'folder_view', (int) $this->getValue('fol_id'));\n\n        if ($folderViewRolesObject->hasRight($gCurrentUser->getRoleMemberships())) {\n            return true;\n        }\n\n        $this->clear();\n        throw new AdmException('SYS_FOLDER_NO_RIGHTS');\n    }\n\n    /**\n     * Get the relevant Font Awesome icon for the current file\n     * @return string Returns the name of the Font Awesome icon\n     */\n    public function getFontAwesomeIcon()\n    {\n        return FileSystemUtils::getFileFontAwesomeIcon($this->getValue('fil_name'));\n    }\n\n    /**\n     * Get the MIME type of the current file e.g. 'image/jpeg'\n     * @return string MIME type of the current file\n     */\n    public function getMimeType()\n    {\n        return FileSystemUtils::getFileMimeType($this->getValue('fil_name'));\n    }\n\n    /**\n     * If the value was manipulated before with **setValue** than the manipulated value is returned.\n     * @param string $columnName The name of the database column whose value should be read\n     * @param string $format     For date or timestamp columns the format should be the date/time format e.g. **d.m.Y = '02.04.2011'**.\n     *                           For text columns the format can be **database** that would return the original database value without any transformations\n     * @return int|string|bool Returns the value of the database column.\n     *                         If the value was manipulated before with **setValue** than the manipulated value is returned.\n     */\n    public function getValue($columnName, $format = '')\n    {\n        $value = parent::getValue($columnName, $format);\n\n        // getValue transforms & to html chars. This must be undone.\n        if ($columnName === 'fil_name') {\n            $value = htmlspecialchars_decode($value);\n        }\n\n        return $value;\n    }\n\n    /**\n     * Check if the current file format could be viewed within a browser.\n     * @return bool Return true if the file could be viewed in the browser otherwise false.\n     */\n    public function isViewableInBrowser()\n    {\n        return FileSystemUtils::isViewableFileInBrowser($this->getValue('fil_name'));\n    }\n\n    /**\n     * Save all changed columns of the recordset in table of database. Therefore the class remembers if it's\n     * a new record or if only an update is necessary. The update statement will only update the changed columns.\n     * If the table has columns for creator or editor than these column with their timestamp will be updated.\n     * For new records the user and timestamp will be set per default.\n     * @param bool $updateFingerPrint Default **true**. Will update the creator or editor of the recordset if table has columns like **usr_id_create** or **usr_id_changed**\n     * @return bool If an update or insert into the database was done then return true, otherwise false.\n     */\n    public function save($updateFingerPrint = true)\n    {\n        if ($this->newRecord) {\n            $this->setValue('fil_timestamp', DATETIME_NOW);\n            $this->setValue('fil_usr_id', $GLOBALS['gCurrentUserId']);\n        }\n\n        return parent::save($updateFingerPrint);\n    }\n}\n", "<?php\n/**\n ***********************************************************************************************\n * @copyright 2004-2023 The Admidio Team\n * @see https://www.admidio.org/\n * @license https://www.gnu.org/licenses/gpl-2.0.html GNU General Public License v2.0 only\n ***********************************************************************************************\n */\n\n/**\n * Improved checks and update of database after upload of photos.\n *\n * This class extends the UploadHandler of the jquery-file-upload library. After\n * the upload of a photo we do some checks on the file and if no check fails then\n * the Admidio database will be updated. If you want do upload photos for the photos\n * module just create an instance of this class.\n *\n * **Code example**\n * ```\n * // create object and do upload\n * $uploadHandler = new UploadHandlerPhoto(array('upload_dir' => $uploadDir,\n *                                               'upload_url' => $uploadUrl,\n *                                               'image_versions' => array(),\n *                                               'accept_file_types' => '/\\.(jpe?g|png)$/i'), true,\n *                                               'array('accept_file_types' => $gL10n->get('PHO_PHOTO_FORMAT_INVALID')));\n * ```\n */\n\nclass UploadHandlerPhoto extends UploadHandler\n{\n    /**\n     * Override the default method to handle the specific things of the photo module and\n     * update the database after file was successful uploaded.\n     * This method has the same parameters as the default.\n     * @param string $uploadedFile\n     * @param string $name\n     * @param int    $size\n     * @param        $type\n     * @param        $error\n     * @param        $index\n     * @param        $contentRange\n     * @return \\stdClass\n     */\n    protected function handle_file_upload($uploadedFile, $name, $size, $type, $error, $index = null, $contentRange = null)\n    {\n        global $photoAlbum, $gSettingsManager, $gL10n, $gLogger;\n\n        $file = parent::handle_file_upload($uploadedFile, $name, $size, $type, $error, $index, $contentRange);\n\n        if (!isset($file->error)) {\n            try {\n                $fileLocation = ADMIDIO_PATH . FOLDER_DATA . '/photos/upload/' . $file->name;\n                $albumFolder  = ADMIDIO_PATH . FOLDER_DATA . '/photos/' . $photoAlbum->getValue('pho_begin', 'Y-m-d') . '_' . (int) $photoAlbum->getValue('pho_id');\n\n                // check filename and throw exception if something is wrong\n                StringUtils::strIsValidFileName($file->name, false);\n\n                // replace invalid characters in filename\n                $file->name = FileSystemUtils::removeInvalidCharsInFilename($file->name);\n\n                // create folder if not exists\n                if (!is_dir($albumFolder)) {\n                    $error = $photoAlbum->createFolder();\n\n                    if (is_array($error)) {\n                        $file->error = $gL10n->get($error['text'], array($error['path']));\n                        return $file;\n                    }\n                }\n\n                $newPhotoFileNumber = $photoAlbum->getValue('pho_quantity') + 1;\n\n                // check if the file contains a valid image and read image properties\n                $imageProperties = getimagesize($fileLocation);\n                if ($imageProperties === false) {\n                    throw new AdmException('PHO_PHOTO_FORMAT_INVALID');\n                }\n\n                // check mime type and set file extension\n                switch ($imageProperties['mime']) {\n                    case 'image/jpeg':\n                        $fileExtension = 'jpg';\n                        break;\n                    case 'image/png':\n                        $fileExtension = 'png';\n                        break;\n                    default:\n                        throw new AdmException('PHO_PHOTO_FORMAT_INVALID');\n                }\n\n                $imageDimensions = $imageProperties[0] * $imageProperties[1];\n                $processableImageSize = admFuncProcessableImageSize();\n                if ($imageDimensions > $processableImageSize) {\n                    throw new AdmException($gL10n->get('PHO_RESOLUTION_MORE_THAN') . ' ' . round($processableImageSize / 1000000, 2) . ' ' . $gL10n->get('SYS_MEGAPIXEL'));\n                }\n\n                // create image object and scale image to defined size of preferences\n                $image = new Image($fileLocation);\n                $image->setImageType('jpeg');\n                $image->scaleLargerSide($gSettingsManager->getInt('photo_save_scale'));\n                $image->copyToFile(null, $albumFolder.'/'.$newPhotoFileNumber.'.jpg');\n                $image->delete();\n\n                // if enabled then save original image\n                if ($gSettingsManager->getBool('photo_keep_original')) {\n                    try {\n                        FileSystemUtils::createDirectoryIfNotExists($albumFolder . '/originals');\n\n                        try {\n                            FileSystemUtils::moveFile($fileLocation, $albumFolder.'/originals/'.$newPhotoFileNumber.'.'.$fileExtension);\n                        } catch (\\RuntimeException $exception) {\n                            $gLogger->error('Could not move file!', array('from' => $fileLocation, 'to' => $albumFolder.'/originals/'.$newPhotoFileNumber.'.'.$fileExtension));\n                            // TODO\n                        }\n                    } catch (\\RuntimeException $exception) {\n                        $gLogger->error('Could not create directory!', array('directoryPath' => $albumFolder . '/originals'));\n                        // TODO\n                    }\n                }\n\n                // save thumbnail\n                try {\n                    FileSystemUtils::createDirectoryIfNotExists($albumFolder . '/thumbnails');\n                } catch (\\RuntimeException $exception) {\n                }\n\n                $image = new Image($fileLocation);\n                $image->scaleLargerSide($gSettingsManager->getInt('photo_thumbs_scale'));\n                $image->copyToFile(null, $albumFolder.'/thumbnails/'.$newPhotoFileNumber.'.jpg');\n                $image->delete();\n\n                // delete image from upload folder\n                try {\n                    FileSystemUtils::deleteFileIfExists($fileLocation);\n                } catch (\\RuntimeException $exception) {\n                }\n\n                // if image was successfully saved in filesystem then update image count of album\n                if (is_file($albumFolder.'/'.$newPhotoFileNumber.'.jpg')) {\n                    $photoAlbum->setValue('pho_quantity', (int) $photoAlbum->getValue('pho_quantity') + 1);\n                    $photoAlbum->save();\n                } else {\n                    throw new AdmException('PHO_PHOTO_PROCESSING_ERROR');\n                }\n            } catch (AdmException $e) {\n                $file->error = $e->getText();\n\n                try {\n                    FileSystemUtils::deleteFileIfExists($this->options['upload_dir'].$file->name);\n                } catch (\\RuntimeException $exception) {\n                }\n\n                return $file;\n            }\n        }\n\n        return $file;\n    }\n\n    /**\n     * Override the default method to handle specific form data that will be set when creating the Javascript\n     * file upload object. Here we validate the CSRF token that will be set. If the check failed an error will\n     * be set and the file upload will be canceled.\n     * @param string $file\n     * @param int    $index\n     */\n    protected function handle_form_data($file, $index)\n    {\n        // ADM Start\n        try {\n            // check the CSRF token of the form against the session token\n            SecurityUtils::validateCsrfToken($_REQUEST['admidio-csrf-token']);\n        } catch (AdmException $exception) {\n            $file->error = $exception->getText();\n            // => EXIT\n        }\n        // ADM End\n    }\n}\n"], "filenames": ["adm_program/system/ckeditor_upload_handler.php", "adm_program/system/classes/FileSystemUtils.php", "adm_program/system/classes/TableFile.php", "adm_program/system/classes/UploadHandlerPhoto.php"], "buggy_code_start_loc": [36, 89, 45, 73], "buggy_code_end_loc": [85, 94, 48, 74], "fixing_code_start_loc": [37, 89, 45, 73], "fixing_code_end_loc": [99, 96, 48, 74], "type": "CWE-434", "message": "Unrestricted Upload of File with Dangerous Type in GitHub repository admidio/admidio prior to 4.2.10.", "other": {"cve": {"id": "CVE-2023-3692", "sourceIdentifier": "security@huntr.dev", "published": "2023-07-16T01:15:09.893", "lastModified": "2023-07-27T19:56:48.617", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Unrestricted Upload of File with Dangerous Type in GitHub repository admidio/admidio prior to 4.2.10."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 6.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 5.5}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:admidio:admidio:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.2.10", "matchCriteriaId": "1EA8EFD3-7A16-4F71-986E-420C021635C4"}]}]}], "references": [{"url": "https://github.com/admidio/admidio/commit/d66585d14b1160712a8a9bfaf9769dd3da0e9a83", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/be6616eb-384d-40d6-b1fd-0ec9e4973f12", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/admidio/admidio/commit/d66585d14b1160712a8a9bfaf9769dd3da0e9a83"}}