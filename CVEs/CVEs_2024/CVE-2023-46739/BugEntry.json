{"buggy_code": ["package master\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/cubefs/cubefs/proto\"\n\t\"github.com/cubefs/cubefs/util/log\"\n\t\"github.com/samsarahq/thunder/graphql\"\n\t\"github.com/samsarahq/thunder/graphql/schemabuilder\"\n\t\"sort\"\n)\n\ntype UserService struct {\n\tuser    *User\n\tcluster *Cluster\n}\n\nfunc (s *UserService) Schema() *graphql.Schema {\n\tschema := schemabuilder.NewSchema()\n\n\ts.registerObject(schema)\n\ts.registerQuery(schema)\n\n\ts.registerMutation(schema)\n\n\treturn schema.MustBuild()\n}\n\ntype UserStatistical struct {\n\tData               uint64\n\tVolumeCount        int32\n\tDataPartitionCount int32\n\tMetaPartitionCount int32\n}\n\ntype AuthorizedVols struct {\n\tVol        string\n\tAuthorized []string\n}\n\nfunc (s *UserService) registerObject(schema *schemabuilder.Schema) {\n\n\tobject := schema.Object(\"UserInfo\", proto.UserInfo{})\n\n\tobject.FieldFunc(\"userStatistical\", func(u *proto.UserInfo) (*UserStatistical, error) {\n\t\tus := &UserStatistical{\n\t\t\tVolumeCount: int32(len(u.Policy.OwnVols)),\n\t\t}\n\t\tfor _, volName := range u.Policy.OwnVols {\n\t\t\tv, e := s.cluster.getVol(volName)\n\t\t\tif e != nil {\n\t\t\t\treturn nil, e\n\t\t\t}\n\t\t\tus.MetaPartitionCount += int32(len(v.MetaPartitions))\n\t\t\tus.DataPartitionCount += int32(len(v.dataPartitions.partitions))\n\t\t\tus.Data += v.totalUsedSpace()\n\t\t}\n\t\treturn us, nil\n\t})\n\n\tobject = schema.Object(\"UserPolicy\", proto.UserPolicy{})\n\tobject.FieldFunc(\"authorizedVols\", func(p *proto.UserPolicy) []AuthorizedVols {\n\t\tvar list []AuthorizedVols\n\t\tfor vol, a := range p.AuthorizedVols {\n\t\t\tlist = append(list, AuthorizedVols{\n\t\t\t\tVol:        vol,\n\t\t\t\tAuthorized: a,\n\t\t\t})\n\t\t}\n\t\treturn list\n\t})\n\n}\n\nfunc (s *UserService) registerQuery(schema *schemabuilder.Schema) {\n\tquery := schema.Query()\n\n\tquery.FieldFunc(\"getUserInfo\", s.getUserInfo)\n\tquery.FieldFunc(\"getUserAKInfo\", s.getUserAKInfo)\n\tquery.FieldFunc(\"validatePassword\", s.validatePassword)\n\tquery.FieldFunc(\"listUserInfo\", s.listUserInfo)\n\tquery.FieldFunc(\"topNUser\", s.topNUser)\n}\n\nfunc (m *UserService) getUserAKInfo(ctx context.Context, args struct {\n\tAccessKey string\n}) (*proto.UserInfo, error) {\n\tuid, perm, err := permissions(ctx, ADMIN|USER)\n\tuserInfo, err := m.user.getKeyInfo(args.AccessKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif perm != ADMIN {\n\t\tif uid != userInfo.UserID {\n\t\t\treturn nil, fmt.Errorf(\"user info not found by you accesskey\")\n\t\t}\n\t}\n\n\treturn userInfo, nil\n}\n\nfunc (s *UserService) registerMutation(schema *schemabuilder.Schema) {\n\tmutation := schema.Mutation()\n\n\tmutation.FieldFunc(\"createUser\", s.createUser)\n\tmutation.FieldFunc(\"updateUser\", s.updateUser)\n\tmutation.FieldFunc(\"deleteUser\", s.deleteUser)\n\tmutation.FieldFunc(\"updateUserPolicy\", s.updateUserPolicy)\n\tmutation.FieldFunc(\"removeUserPolicy\", s.removeUserPolicy)\n\tmutation.FieldFunc(\"transferUserVol\", s.transferUserVol)\n\n}\n\nfunc (m *UserService) transferUserVol(ctx context.Context, args proto.UserTransferVolParam) (*proto.UserInfo, error) {\n\tuid, perm, err := permissions(ctx, ADMIN)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvol, err := m.cluster.getVol(args.Volume)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif perm == USER && vol.Owner != uid {\n\t\treturn nil, fmt.Errorf(\"not have permission for vol:[%s]\", args.Volume)\n\t}\n\n\tif !args.Force && vol.Owner != args.UserSrc {\n\t\treturn nil, fmt.Errorf(\"force param need validate user name for vol:[%s]\", args.Volume)\n\t}\n\n\tuserInfo, err := m.user.transferVol(&args)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\towner := vol.Owner\n\tvol.Owner = userInfo.UserID\n\tif err = m.cluster.syncUpdateVol(vol); err != nil {\n\t\tvol.Owner = owner\n\t\treturn nil, err\n\t}\n\treturn userInfo, nil\n}\n\nfunc (s *UserService) updateUserPolicy(ctx context.Context, args proto.UserPermUpdateParam) (*proto.UserInfo, error) {\n\tuid, perm, err := permissions(ctx, ADMIN|USER)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif perm == USER {\n\t\tif args.Volume == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"user:[%s] need set userID\", uid)\n\t\t}\n\t\tif v, e := s.cluster.getVol(args.Volume); e != nil {\n\t\t\treturn nil, e\n\t\t} else {\n\t\t\tif v.Owner != uid {\n\t\t\t\treturn nil, fmt.Errorf(\"user:[%s] is not volume:[%s] onwer\", uid, args.UserID)\n\t\t\t}\n\t\t}\n\t}\n\tif _, err := s.cluster.getVol(args.Volume); err != nil {\n\t\treturn nil, err\n\t}\n\tuserInfo, err := s.user.updatePolicy(&args)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn userInfo, nil\n}\n\nfunc (s *UserService) removeUserPolicy(ctx context.Context, args proto.UserPermRemoveParam) (*proto.UserInfo, error) {\n\tif _, err := s.cluster.getVol(args.Volume); err != nil {\n\t\treturn nil, err\n\t}\n\tuserInfo, err := s.user.removePolicy(&args)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn userInfo, nil\n}\n\nfunc (s *UserService) createUser(ctx context.Context, args proto.UserCreateParam) (*proto.UserInfo, error) {\n\tuid, _, err := permissions(ctx, ADMIN)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif !ownerRegexp.MatchString(args.ID) {\n\t\treturn nil, fmt.Errorf(\"user id:[%s] is invalid\", args.ID)\n\t}\n\tif args.Type == proto.UserTypeRoot {\n\t\treturn nil, fmt.Errorf(\"user type:[%s] can not to root\", args.Type)\n\t}\n\n\tlog.LogInfof(\"create user:[%s] by admin:[%s]\", args.ID, uid)\n\treturn s.user.createKey(&args)\n}\n\nfunc (s *UserService) updateUser(ctx context.Context, args proto.UserUpdateParam) (*proto.UserInfo, error) {\n\tuid, _, err := permissions(ctx, ADMIN)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\told, err := s.user.getUserInfo(args.UserID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif old.UserType != args.Type && args.Type == proto.UserTypeRoot {\n\t\treturn nil, fmt.Errorf(\"user type:[%s] can not to root\", args.Type)\n\t}\n\n\tlog.LogInfof(\"update user:[%s] by admin:[%s]\", args.UserID, uid)\n\treturn s.user.updateKey(&args)\n}\n\nfunc (s *UserService) deleteUser(ctx context.Context, args struct {\n\tUserID string\n}) (*proto.GeneralResp, error) {\n\tuid, _, err := permissions(ctx, ADMIN)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t//TODO : make sure can delete self? can delete other admin ??\n\tlog.LogInfof(\"delete user:[%s] by admin:[%s]\", args.UserID, uid)\n\tif err := s.user.deleteKey(args.UserID); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn proto.Success(\"del user ok\"), nil\n\n}\n\nfunc (s *UserService) getUserInfo(ctx context.Context, args struct {\n\tUserID string\n}) (*proto.UserInfo, error) {\n\tuid, perm, err := permissions(ctx, ADMIN|USER)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif perm == USER {\n\t\tif uid != args.UserID {\n\t\t\treturn nil, fmt.Errorf(\"you:[%s] not have permission visit this userID:[%s]\", uid, args.UserID)\n\t\t}\n\t}\n\n\treturn s.user.getUserInfo(args.UserID)\n}\n\nfunc (s *UserService) listUserInfo(ctx context.Context, args struct{}) ([]*proto.UserInfo, error) {\n\tif _, _, err := permissions(ctx, ADMIN); err != nil {\n\t\treturn nil, err\n\t}\n\tvar list []*proto.UserInfo\n\ts.user.userStore.Range(func(_, ui interface{}) bool {\n\t\tlist = append(list, ui.(*proto.UserInfo))\n\t\treturn true\n\t})\n\treturn list, nil\n}\n\ntype UserUseSpace struct {\n\tName  string\n\tSize  uint64\n\tRatio float32\n}\n\nfunc (s *UserService) topNUser(ctx context.Context, args struct {\n\tN int32\n}) ([]*UserUseSpace, error) {\n\tif _, _, err := permissions(ctx, ADMIN); err != nil {\n\t\treturn nil, err\n\t}\n\tlist := make([]*UserUseSpace, 0)\n\n\tvar err error\n\ts.user.userStore.Range(func(_, ui interface{}) bool {\n\n\t\tu := ui.(*proto.UserInfo)\n\n\t\tus := &UserUseSpace{\n\t\t\tName:  u.UserID,\n\t\t\tSize:  0,\n\t\t\tRatio: 0,\n\t\t}\n\n\t\tfor _, volName := range u.Policy.OwnVols {\n\t\t\tv, e := s.cluster.getVol(volName)\n\t\t\tif e != nil {\n\t\t\t\terr = e\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tus.Size += v.totalUsedSpace()\n\t\t}\n\n\t\tlist = append(list, us)\n\t\treturn true\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsort.Slice(list, func(i int, j int) bool {\n\t\treturn list[i].Size > list[j].Size\n\t})\n\n\tif len(list) > 10 {\n\t\tlist = list[:10]\n\t}\n\n\tvar sum uint64\n\tfor _, u := range list {\n\t\tsum += u.Size\n\t}\n\n\tfor _, u := range list {\n\t\tif sum == 0 {\n\t\t\tu.Ratio = float32(1) / float32(len(list))\n\t\t} else {\n\t\t\tu.Ratio = float32(u.Size) / float32(sum)\n\t\t}\n\n\t}\n\n\treturn list, nil\n}\n\nfunc (s *UserService) validatePassword(ctx context.Context, args struct {\n\tUserID   string\n\tPassword string\n}) (*proto.UserInfo, error) {\n\tui, err := s.user.getUserInfo(args.UserID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tak, err := s.user.getAKUser(ui.AccessKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif ak.Password != args.Password {\n\t\tlog.LogWarnf(\"user:[%s] login pass word has err\", args.UserID)\n\t\treturn nil, fmt.Errorf(\"user or password has err\")\n\t}\n\treturn ui, nil\n}\n\ntype permissionMode int\n\nconst ADMIN permissionMode = permissionMode(1)\nconst USER permissionMode = permissionMode(2)\n\nfunc permissions(ctx context.Context, mode permissionMode) (userID string, perm permissionMode, err error) {\n\tuserInfo := ctx.Value(proto.UserInfoKey).(*proto.UserInfo)\n\n\tuserID = userInfo.UserID\n\n\tperm = USER\n\tif userInfo.UserType == proto.UserTypeRoot || userInfo.UserType == proto.UserTypeAdmin {\n\t\tperm = ADMIN\n\t}\n\n\tif ADMIN&mode == ADMIN {\n\t\tif perm == ADMIN {\n\t\t\treturn\n\t\t}\n\t}\n\n\tif USER&mode == USER {\n\t\tif perm == USER {\n\t\t\treturn\n\t\t}\n\t}\n\n\terr = fmt.Errorf(\"user:[%s] permissions has err:[%d] your:[%d]\", userInfo.UserID, mode, perm)\n\treturn\n}\n"], "fixing_code": ["package master\n\nimport (\n\t\"context\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"github.com/cubefs/cubefs/proto\"\n\t\"github.com/cubefs/cubefs/util/log\"\n\t\"github.com/samsarahq/thunder/graphql\"\n\t\"github.com/samsarahq/thunder/graphql/schemabuilder\"\n\t\"sort\"\n)\n\ntype UserService struct {\n\tuser    *User\n\tcluster *Cluster\n}\n\nfunc (s *UserService) Schema() *graphql.Schema {\n\tschema := schemabuilder.NewSchema()\n\n\ts.registerObject(schema)\n\ts.registerQuery(schema)\n\n\ts.registerMutation(schema)\n\n\treturn schema.MustBuild()\n}\n\ntype UserStatistical struct {\n\tData               uint64\n\tVolumeCount        int32\n\tDataPartitionCount int32\n\tMetaPartitionCount int32\n}\n\ntype AuthorizedVols struct {\n\tVol        string\n\tAuthorized []string\n}\n\nfunc (s *UserService) registerObject(schema *schemabuilder.Schema) {\n\n\tobject := schema.Object(\"UserInfo\", proto.UserInfo{})\n\n\tobject.FieldFunc(\"userStatistical\", func(u *proto.UserInfo) (*UserStatistical, error) {\n\t\tus := &UserStatistical{\n\t\t\tVolumeCount: int32(len(u.Policy.OwnVols)),\n\t\t}\n\t\tfor _, volName := range u.Policy.OwnVols {\n\t\t\tv, e := s.cluster.getVol(volName)\n\t\t\tif e != nil {\n\t\t\t\treturn nil, e\n\t\t\t}\n\t\t\tus.MetaPartitionCount += int32(len(v.MetaPartitions))\n\t\t\tus.DataPartitionCount += int32(len(v.dataPartitions.partitions))\n\t\t\tus.Data += v.totalUsedSpace()\n\t\t}\n\t\treturn us, nil\n\t})\n\n\tobject = schema.Object(\"UserPolicy\", proto.UserPolicy{})\n\tobject.FieldFunc(\"authorizedVols\", func(p *proto.UserPolicy) []AuthorizedVols {\n\t\tvar list []AuthorizedVols\n\t\tfor vol, a := range p.AuthorizedVols {\n\t\t\tlist = append(list, AuthorizedVols{\n\t\t\t\tVol:        vol,\n\t\t\t\tAuthorized: a,\n\t\t\t})\n\t\t}\n\t\treturn list\n\t})\n\n}\n\nfunc (s *UserService) registerQuery(schema *schemabuilder.Schema) {\n\tquery := schema.Query()\n\n\tquery.FieldFunc(\"getUserInfo\", s.getUserInfo)\n\tquery.FieldFunc(\"getUserAKInfo\", s.getUserAKInfo)\n\tquery.FieldFunc(\"validatePassword\", s.validatePassword)\n\tquery.FieldFunc(\"listUserInfo\", s.listUserInfo)\n\tquery.FieldFunc(\"topNUser\", s.topNUser)\n}\n\nfunc (m *UserService) getUserAKInfo(ctx context.Context, args struct {\n\tAccessKey string\n}) (*proto.UserInfo, error) {\n\tuid, perm, err := permissions(ctx, ADMIN|USER)\n\tuserInfo, err := m.user.getKeyInfo(args.AccessKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif perm != ADMIN {\n\t\tif uid != userInfo.UserID {\n\t\t\treturn nil, fmt.Errorf(\"user info not found by you accesskey\")\n\t\t}\n\t}\n\n\treturn userInfo, nil\n}\n\nfunc (s *UserService) registerMutation(schema *schemabuilder.Schema) {\n\tmutation := schema.Mutation()\n\n\tmutation.FieldFunc(\"createUser\", s.createUser)\n\tmutation.FieldFunc(\"updateUser\", s.updateUser)\n\tmutation.FieldFunc(\"deleteUser\", s.deleteUser)\n\tmutation.FieldFunc(\"updateUserPolicy\", s.updateUserPolicy)\n\tmutation.FieldFunc(\"removeUserPolicy\", s.removeUserPolicy)\n\tmutation.FieldFunc(\"transferUserVol\", s.transferUserVol)\n\n}\n\nfunc (m *UserService) transferUserVol(ctx context.Context, args proto.UserTransferVolParam) (*proto.UserInfo, error) {\n\tuid, perm, err := permissions(ctx, ADMIN)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvol, err := m.cluster.getVol(args.Volume)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif perm == USER && vol.Owner != uid {\n\t\treturn nil, fmt.Errorf(\"not have permission for vol:[%s]\", args.Volume)\n\t}\n\n\tif !args.Force && vol.Owner != args.UserSrc {\n\t\treturn nil, fmt.Errorf(\"force param need validate user name for vol:[%s]\", args.Volume)\n\t}\n\n\tuserInfo, err := m.user.transferVol(&args)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\towner := vol.Owner\n\tvol.Owner = userInfo.UserID\n\tif err = m.cluster.syncUpdateVol(vol); err != nil {\n\t\tvol.Owner = owner\n\t\treturn nil, err\n\t}\n\treturn userInfo, nil\n}\n\nfunc (s *UserService) updateUserPolicy(ctx context.Context, args proto.UserPermUpdateParam) (*proto.UserInfo, error) {\n\tuid, perm, err := permissions(ctx, ADMIN|USER)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif perm == USER {\n\t\tif args.Volume == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"user:[%s] need set userID\", uid)\n\t\t}\n\t\tif v, e := s.cluster.getVol(args.Volume); e != nil {\n\t\t\treturn nil, e\n\t\t} else {\n\t\t\tif v.Owner != uid {\n\t\t\t\treturn nil, fmt.Errorf(\"user:[%s] is not volume:[%s] onwer\", uid, args.UserID)\n\t\t\t}\n\t\t}\n\t}\n\tif _, err := s.cluster.getVol(args.Volume); err != nil {\n\t\treturn nil, err\n\t}\n\tuserInfo, err := s.user.updatePolicy(&args)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn userInfo, nil\n}\n\nfunc (s *UserService) removeUserPolicy(ctx context.Context, args proto.UserPermRemoveParam) (*proto.UserInfo, error) {\n\tif _, err := s.cluster.getVol(args.Volume); err != nil {\n\t\treturn nil, err\n\t}\n\tuserInfo, err := s.user.removePolicy(&args)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn userInfo, nil\n}\n\nfunc (s *UserService) createUser(ctx context.Context, args proto.UserCreateParam) (*proto.UserInfo, error) {\n\tuid, _, err := permissions(ctx, ADMIN)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif !ownerRegexp.MatchString(args.ID) {\n\t\treturn nil, fmt.Errorf(\"user id:[%s] is invalid\", args.ID)\n\t}\n\tif args.Type == proto.UserTypeRoot {\n\t\treturn nil, fmt.Errorf(\"user type:[%s] can not to root\", args.Type)\n\t}\n\n\tlog.LogInfof(\"create user:[%s] by admin:[%s]\", args.ID, uid)\n\treturn s.user.createKey(&args)\n}\n\nfunc (s *UserService) updateUser(ctx context.Context, args proto.UserUpdateParam) (*proto.UserInfo, error) {\n\tuid, _, err := permissions(ctx, ADMIN)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\told, err := s.user.getUserInfo(args.UserID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif old.UserType != args.Type && args.Type == proto.UserTypeRoot {\n\t\treturn nil, fmt.Errorf(\"user type:[%s] can not to root\", args.Type)\n\t}\n\n\tlog.LogInfof(\"update user:[%s] by admin:[%s]\", args.UserID, uid)\n\treturn s.user.updateKey(&args)\n}\n\nfunc (s *UserService) deleteUser(ctx context.Context, args struct {\n\tUserID string\n}) (*proto.GeneralResp, error) {\n\tuid, _, err := permissions(ctx, ADMIN)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t//TODO : make sure can delete self? can delete other admin ??\n\tlog.LogInfof(\"delete user:[%s] by admin:[%s]\", args.UserID, uid)\n\tif err := s.user.deleteKey(args.UserID); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn proto.Success(\"del user ok\"), nil\n\n}\n\nfunc (s *UserService) getUserInfo(ctx context.Context, args struct {\n\tUserID string\n}) (*proto.UserInfo, error) {\n\tuid, perm, err := permissions(ctx, ADMIN|USER)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif perm == USER {\n\t\tif uid != args.UserID {\n\t\t\treturn nil, fmt.Errorf(\"you:[%s] not have permission visit this userID:[%s]\", uid, args.UserID)\n\t\t}\n\t}\n\n\treturn s.user.getUserInfo(args.UserID)\n}\n\nfunc (s *UserService) listUserInfo(ctx context.Context, args struct{}) ([]*proto.UserInfo, error) {\n\tif _, _, err := permissions(ctx, ADMIN); err != nil {\n\t\treturn nil, err\n\t}\n\tvar list []*proto.UserInfo\n\ts.user.userStore.Range(func(_, ui interface{}) bool {\n\t\tlist = append(list, ui.(*proto.UserInfo))\n\t\treturn true\n\t})\n\treturn list, nil\n}\n\ntype UserUseSpace struct {\n\tName  string\n\tSize  uint64\n\tRatio float32\n}\n\nfunc (s *UserService) topNUser(ctx context.Context, args struct {\n\tN int32\n}) ([]*UserUseSpace, error) {\n\tif _, _, err := permissions(ctx, ADMIN); err != nil {\n\t\treturn nil, err\n\t}\n\tlist := make([]*UserUseSpace, 0)\n\n\tvar err error\n\ts.user.userStore.Range(func(_, ui interface{}) bool {\n\n\t\tu := ui.(*proto.UserInfo)\n\n\t\tus := &UserUseSpace{\n\t\t\tName:  u.UserID,\n\t\t\tSize:  0,\n\t\t\tRatio: 0,\n\t\t}\n\n\t\tfor _, volName := range u.Policy.OwnVols {\n\t\t\tv, e := s.cluster.getVol(volName)\n\t\t\tif e != nil {\n\t\t\t\terr = e\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tus.Size += v.totalUsedSpace()\n\t\t}\n\n\t\tlist = append(list, us)\n\t\treturn true\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsort.Slice(list, func(i int, j int) bool {\n\t\treturn list[i].Size > list[j].Size\n\t})\n\n\tif len(list) > 10 {\n\t\tlist = list[:10]\n\t}\n\n\tvar sum uint64\n\tfor _, u := range list {\n\t\tsum += u.Size\n\t}\n\n\tfor _, u := range list {\n\t\tif sum == 0 {\n\t\t\tu.Ratio = float32(1) / float32(len(list))\n\t\t} else {\n\t\t\tu.Ratio = float32(u.Size) / float32(sum)\n\t\t}\n\n\t}\n\n\treturn list, nil\n}\n\nfunc (s *UserService) validatePassword(ctx context.Context, args struct {\n\tUserID   string\n\tPassword string\n}) (*proto.UserInfo, error) {\n\tui, err := s.user.getUserInfo(args.UserID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tak, err := s.user.getAKUser(ui.AccessKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\thashedPassword := sha256.Sum256([]byte(args.Password))\n\thashedPasswordStr := hex.EncodeToString(hashedPassword[:])\n\n\thashedPassword_ := sha256.Sum256([]byte(ak.Password))\n\thashedPasswordStr_ := hex.EncodeToString(hashedPassword_[:])\n\n\tif hashedPasswordStr != hashedPasswordStr_ {\n\t\tlog.LogWarnf(\"user:[%s] login pass word has err\", args.UserID)\n\t\treturn nil, fmt.Errorf(\"user or password has err\")\n\t}\n\treturn ui, nil\n}\n\ntype permissionMode int\n\nconst ADMIN permissionMode = permissionMode(1)\nconst USER permissionMode = permissionMode(2)\n\nfunc permissions(ctx context.Context, mode permissionMode) (userID string, perm permissionMode, err error) {\n\tuserInfo := ctx.Value(proto.UserInfoKey).(*proto.UserInfo)\n\n\tuserID = userInfo.UserID\n\n\tperm = USER\n\tif userInfo.UserType == proto.UserTypeRoot || userInfo.UserType == proto.UserTypeAdmin {\n\t\tperm = ADMIN\n\t}\n\n\tif ADMIN&mode == ADMIN {\n\t\tif perm == ADMIN {\n\t\t\treturn\n\t\t}\n\t}\n\n\tif USER&mode == USER {\n\t\tif perm == USER {\n\t\t\treturn\n\t\t}\n\t}\n\n\terr = fmt.Errorf(\"user:[%s] permissions has err:[%d] your:[%d]\", userInfo.UserID, mode, perm)\n\treturn\n}\n"], "filenames": ["master/gapi_user.go"], "buggy_code_start_loc": [4], "buggy_code_end_loc": [352], "fixing_code_start_loc": [5], "fixing_code_end_loc": [359], "type": "CWE-203", "message": "CubeFS is an open-source cloud-native file storage system. A vulnerability was found during in the CubeFS master component in versions prior to 3.3.1 that could allow an untrusted attacker to steal user passwords by carrying out a timing attack. The root case of the vulnerability was that CubeFS used raw string comparison of passwords. The vulnerable part of CubeFS was the UserService of the master component. The UserService gets instantiated when starting the server of the master component. The issue has been patched in v3.3.1. For impacted users, there is no other way to mitigate the issue besides upgrading.", "other": {"cve": {"id": "CVE-2023-46739", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-03T17:15:10.303", "lastModified": "2024-01-10T17:06:39.047", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "CubeFS is an open-source cloud-native file storage system. A vulnerability was found during in the CubeFS master component in versions prior to 3.3.1 that could allow an untrusted attacker to steal user passwords by carrying out a timing attack. The root case of the vulnerability was that CubeFS used raw string comparison of passwords. The vulnerable part of CubeFS was the UserService of the master component. The UserService gets instantiated when starting the server of the master component. The issue has been patched in v3.3.1. For impacted users, there is no other way to mitigate the issue besides upgrading."}, {"lang": "es", "value": "CubeFS es un sistema de almacenamiento de archivos nativo de la nube de c\u00f3digo abierto. Se encontr\u00f3 una vulnerabilidad en el componente maestro de CubeFS en versiones anteriores a la 3.3.1 que podr\u00eda permitir a un atacante no confiable robar contrase\u00f1as de usuario mediante la realizaci\u00f3n de un ataque de sincronizaci\u00f3n. El caso ra\u00edz de la vulnerabilidad fue que CubeFS utiliz\u00f3 una comparaci\u00f3n de contrase\u00f1as sin formato. La parte vulnerable de CubeFS era el UserService del componente maestro. Se crea una instancia de UserService al iniciar el servidor del componente maestro. El problema se solucion\u00f3 en la versi\u00f3n 3.3.1. Para los usuarios afectados, no hay otra forma de mitigar el problema adem\u00e1s de actualizar."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:cubefs:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.3.1", "matchCriteriaId": "6E8D59D8-6863-4398-9D77-2442BAF81108"}]}]}], "references": [{"url": "https://github.com/cubefs/cubefs/commit/6a0d5fa45a77ff20c752fa9e44738bf5d86c84bd", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/cubefs/cubefs/security/advisories/GHSA-8579-7p32-f398", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/cubefs/cubefs/commit/6a0d5fa45a77ff20c752fa9e44738bf5d86c84bd"}}