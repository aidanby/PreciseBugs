{"buggy_code": ["/*\n * Copyright (C) 2004 Red Hat Inc.\n * Copyright (C) 2005 Martin Koegler\n * Copyright (C) 2010 m-privacy GmbH\n * Copyright (C) 2010 TigerVNC Team\n * Copyright (C) 2011-2019 Brian P. Hinz\n * Copyright (C) 2015 D. R. Commander.  All Rights Reserved.\n *\n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n * USA.\n */\n\npackage com.tigervnc.rfb;\n\nimport javax.net.ssl.*;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.MessageDigest;\nimport java.security.cert.*;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Base64;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport javax.naming.InvalidNameException;\nimport javax.naming.ldap.LdapName;\nimport javax.naming.ldap.Rdn;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.swing.JOptionPane;\n\nimport com.tigervnc.rdr.*;\nimport com.tigervnc.network.*;\nimport com.tigervnc.vncviewer.*;\n\nimport static javax.swing.JOptionPane.*;\n\npublic class CSecurityTLS extends CSecurity {\n\n  public static StringParameter X509CA\n  = new StringParameter(\"X509CA\",\n                        \"X509 CA certificate\", \"\", Configuration.ConfigurationObject.ConfViewer);\n  public static StringParameter X509CRL\n  = new StringParameter(\"X509CRL\",\n                        \"X509 CRL file\", \"\", Configuration.ConfigurationObject.ConfViewer);\n  public static UserMsgBox msg;\n\n  private void initGlobal()\n  {\n    try {\n      ctx = SSLContext.getInstance(\"TLS\");\n    } catch(NoSuchAlgorithmException e) {\n      throw new Exception(e.toString());\n    }\n  }\n\n  public CSecurityTLS(boolean _anon)\n  {\n    anon = _anon;\n    manager = null;\n\n    setDefaults();\n    cafile = X509CA.getData();\n    crlfile = X509CRL.getData();\n  }\n\n  public static String getDefaultCA() {\n    if (UserPreferences.get(\"viewer\", \"x509ca\") != null)\n      return UserPreferences.get(\"viewer\", \"x509ca\");\n    return FileUtils.getVncHomeDir()+\"x509_ca.pem\";\n  }\n\n  public static String getDefaultCRL() {\n    if (UserPreferences.get(\"viewer\", \"x509crl\") != null)\n      return UserPreferences.get(\"viewer\", \"x509crl\");\n    return FileUtils.getVncHomeDir()+\"x509_crl.pem\";\n  }\n\n  public static void setDefaults()\n  {\n    if (new File(getDefaultCA()).exists())\n      X509CA.setDefaultStr(getDefaultCA());\n    if (new File(getDefaultCRL()).exists())\n      X509CRL.setDefaultStr(getDefaultCRL());\n  }\n\n// FIXME:\n// Need to shutdown the connection cleanly\n\n// FIXME?\n// add a finalizer method that calls shutdown\n\n  public boolean processMsg(CConnection cc) {\n    is = (FdInStream)cc.getInStream();\n    os = (FdOutStream)cc.getOutStream();\n    client = cc;\n\n    initGlobal();\n\n    if (manager == null) {\n      if (!is.checkNoWait(1))\n        return false;\n\n      if (is.readU8() == 0) {\n        int result = is.readU32();\n        String reason;\n        if (result == Security.secResultFailed ||\n            result == Security.secResultTooMany)\n          reason = is.readString();\n        else\n          reason = new String(\"Authentication failure (protocol error)\");\n        throw new AuthFailureException(reason);\n      }\n\n      setParam();\n    }\n\n    try {\n      manager = new SSLEngineManager(engine, is, os);\n      manager.doHandshake();\n    } catch(java.lang.Exception e) {\n      throw new SystemException(e.toString());\n    }\n\n    cc.setStreams(new TLSInStream(is, manager),\n\t\t              new TLSOutStream(os, manager));\n    return true;\n  }\n\n  private void setParam() {\n\n    if (anon) {\n      try {\n        ctx.init(null, null, null);\n      } catch(KeyManagementException e) {\n        throw new AuthFailureException(e.toString());\n      }\n    } else {\n      try {\n        TrustManager[] myTM = new TrustManager[] {\n          new MyX509TrustManager()\n        };\n        ctx.init (null, myTM, null);\n      } catch (java.security.GeneralSecurityException e) {\n        throw new AuthFailureException(e.toString());\n      }\n    }\n    SSLSocketFactory sslfactory = ctx.getSocketFactory();\n    engine = ctx.createSSLEngine(client.getServerName(),\n                                 client.getServerPort());\n    engine.setUseClientMode(true);\n\n    String[] supported = engine.getSupportedProtocols();\n    ArrayList<String> enabled = new ArrayList<String>();\n    for (int i = 0; i < supported.length; i++)\n      if (supported[i].matches(\"TLS.*\"))\n\t      enabled.add(supported[i]);\n    engine.setEnabledProtocols(enabled.toArray(new String[0]));\n\n    if (anon) {\n      supported = engine.getSupportedCipherSuites();\n      enabled = new ArrayList<String>();\n      // prefer ECDH over DHE\n      for (int i = 0; i < supported.length; i++)\n        if (supported[i].matches(\"TLS_ECDH_anon.*\"))\n\t        enabled.add(supported[i]);\n      for (int i = 0; i < supported.length; i++)\n        if (supported[i].matches(\"TLS_DH_anon.*\"))\n\t        enabled.add(supported[i]);\n      engine.setEnabledCipherSuites(enabled.toArray(new String[0]));\n    } else {\n      engine.setEnabledCipherSuites(engine.getSupportedCipherSuites());\n    }\n\n  }\n\n  class MyX509TrustManager implements X509TrustManager\n  {\n\n    X509TrustManager tm;\n\n    MyX509TrustManager() throws java.security.GeneralSecurityException\n    {\n      KeyStore ks = KeyStore.getInstance(\"JKS\");\n      CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n      try {\n        ks.load(null, null);\n        String a = TrustManagerFactory.getDefaultAlgorithm();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(a);\n        tmf.init((KeyStore)null);\n        for (TrustManager m : tmf.getTrustManagers())\n          if (m instanceof X509TrustManager)\n            for (X509Certificate c : ((X509TrustManager)m).getAcceptedIssuers())\n              ks.setCertificateEntry(getThumbprint((X509Certificate)c), c);\n        File cacert = new File(cafile);\n        if (cacert.exists() && cacert.canRead()) {\n          InputStream caStream = new MyFileInputStream(cacert);\n          Collection<? extends Certificate> cacerts =\n            cf.generateCertificates(caStream);\n          for (Certificate cert : cacerts) {\n            String thumbprint = getThumbprint((X509Certificate)cert);\n            ks.setCertificateEntry(thumbprint, (X509Certificate)cert);\n          }\n        }\n        PKIXBuilderParameters params =\n          new PKIXBuilderParameters(ks, new X509CertSelector());\n        File crlcert = new File(crlfile);\n        if (!crlcert.exists() || !crlcert.canRead()) {\n          params.setRevocationEnabled(false);\n        } else {\n          InputStream crlStream = new FileInputStream(crlfile);\n          Collection<? extends CRL> crls = cf.generateCRLs(crlStream);\n          CertStoreParameters csp = new CollectionCertStoreParameters(crls);\n          CertStore store = CertStore.getInstance(\"Collection\", csp);\n          params.addCertStore(store);\n          params.setRevocationEnabled(true);\n        }\n        tmf = TrustManagerFactory.getInstance(\"PKIX\");\n        tmf.init(new CertPathTrustManagerParameters(params));\n        tm = (X509TrustManager)tmf.getTrustManagers()[0];\n      } catch (java.lang.Exception e) {\n        throw new Exception(e.getMessage());\n      }\n    }\n\n    public void checkClientTrusted(X509Certificate[] chain, String authType)\n      throws CertificateException\n    {\n      tm.checkClientTrusted(chain, authType);\n    }\n\n    private final char[] hexCode = \"0123456789ABCDEF\".toCharArray();\n\n    private String printHexBinary(byte[] data)\n    {\n      StringBuilder r = new StringBuilder(data.length*2);\n      for (byte b : data) {\n        r.append(hexCode[(b >> 4) & 0xF]);\n        r.append(hexCode[(b & 0xF)]); \n      }\n      return r.toString();\n    }\n\n    public void checkServerTrusted(X509Certificate[] chain, String authType)\n      throws CertificateException\n    {\n      Collection<? extends Certificate> certs = null;\n      X509Certificate cert = chain[0];\n      try {\n        cert.checkValidity();\n      } catch(CertificateNotYetValidException e) {\n        throw new AuthFailureException(\"server certificate has not been activated\");\n      } catch(CertificateExpiredException e) {\n        if (!msg.showMsgBox(YES_NO_OPTION, \"certificate has expired\",\n\t\t\t      \"The certificate of the server has expired, \"+\n\t\t\t      \"do you want to continue?\"))\n          throw new AuthFailureException(\"server certificate has expired\");\n      }\n      String thumbprint = getThumbprint(cert);\n      File vncDir = new File(FileUtils.getVncHomeDir());\n      File certFile = new File(vncDir, \"x509_savedcerts.pem\");\n      CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n      if (vncDir.exists() && certFile.exists() && certFile.canRead()) {\n        InputStream certStream = new MyFileInputStream(certFile);\n        certs = cf.generateCertificates(certStream);\n        for (Certificate c : certs)\n          if (thumbprint.equals(getThumbprint((X509Certificate)c)))\n            return;\n      }\n      try {\n        verifyHostname(cert);\n        tm.checkServerTrusted(chain, authType);\n      } catch (java.lang.Exception e) {\n        if (e.getCause() instanceof CertPathBuilderException) {\n          String certinfo =\n            \"This certificate has been signed by an unknown authority\\n\"+\n            \"\\n\"+\n            \"  Subject: \"+cert.getSubjectX500Principal().getName()+\"\\n\"+\n            \"  Issuer: \"+cert.getIssuerX500Principal().getName()+\"\\n\"+\n            \"  Serial Number: \"+cert.getSerialNumber()+\"\\n\"+\n            \"  Version: \"+cert.getVersion()+\"\\n\"+\n            \"  Signature Algorithm: \"+cert.getPublicKey().getAlgorithm()+\"\\n\"+\n            \"  Not Valid Before: \"+cert.getNotBefore()+\"\\n\"+\n            \"  Not Valid After: \"+cert.getNotAfter()+\"\\n\"+\n            \"  SHA1 Fingerprint: \"+getThumbprint(cert)+\"\\n\"+\n            \"\\n\"+\n            \"Do you want to save it and continue?\";\n          if (!msg.showMsgBox(YES_NO_OPTION, \"certificate issuer unknown\",\n                certinfo)) {\n            throw new AuthFailureException(\"certificate issuer unknown\");\n          }\n          if (certs == null || !certs.contains(cert)) {\n            byte[] der = cert.getEncoded();\n            String pem = Base64.getEncoder().encodeToString(der);\n            pem = pem.replaceAll(\"(.{64})\", \"$1\\n\");\n            FileWriter fw = null;\n            try {\n              if (!vncDir.exists())\n                vncDir.mkdir();\n              if (!certFile.exists() && !certFile.createNewFile()) {\n                vlog.error(\"Certificate save failed.\");\n              } else {\n                fw = new FileWriter(certFile.getAbsolutePath(), true);\n                fw.write(\"-----BEGIN CERTIFICATE-----\\n\");\n                fw.write(pem+\"\\n\");\n                fw.write(\"-----END CERTIFICATE-----\\n\");\n              }\n            } catch (IOException ioe) {\n              msg.showMsgBox(OK_OPTION, \"certificate save failed\",\n                             \"Could not save the certificate\");\n            } finally {\n              try {\n                if (fw != null)\n                  fw.close();\n              } catch(IOException ioe2) {\n                throw new Exception(ioe2.getMessage());\n              }\n            }\n          }\n        } else {\n          throw new SystemException(e.getMessage());\n        }\n      }\n    }\n\n    public X509Certificate[] getAcceptedIssuers ()\n    {\n      return tm.getAcceptedIssuers();\n    }\n\n    private String getThumbprint(X509Certificate cert)\n    {\n      String thumbprint = null;\n      try {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        md.update(cert.getEncoded());\n        thumbprint = printHexBinary(md.digest());\n        thumbprint = thumbprint.replaceAll(\"..(?!$)\", \"$0 \");\n      } catch(CertificateEncodingException e) {\n        throw new SystemException(e.getMessage());\n      } catch(NoSuchAlgorithmException e) {\n        throw new SystemException(e.getMessage());\n      }\n      return thumbprint;\n    }\n\n    private void verifyHostname(X509Certificate cert)\n      throws CertificateParsingException\n    {\n      try {\n        Collection sans = cert.getSubjectAlternativeNames();\n        if (sans == null) {\n          String dn = cert.getSubjectX500Principal().getName();\n          LdapName ln = new LdapName(dn);\n          for (Rdn rdn : ln.getRdns()) {\n            if (rdn.getType().equalsIgnoreCase(\"CN\")) {\n              String peer = client.getServerName().toLowerCase();\n              if (peer.equals(((String)rdn.getValue()).toLowerCase()))\n                return;\n            }\n          }\n        } else {\n          Iterator i = sans.iterator();\n          while (i.hasNext()) {\n            List nxt = (List)i.next();\n            if (((Integer)nxt.get(0)).intValue() == 2) {\n              String peer = client.getServerName().toLowerCase();\n              if (peer.equals(((String)nxt.get(1)).toLowerCase()))\n                return;\n            } else if (((Integer)nxt.get(0)).intValue() == 7) {\n              String peer = ((CConn)client).getSocket().getPeerAddress();\n              if (peer.equals(((String)nxt.get(1)).toLowerCase()))\n                return;\n            }\n          }\n        }\n        Object[] answer = {\"YES\", \"NO\"};\n        int ret = JOptionPane.showOptionDialog(null,\n          \"Hostname verification failed. Do you want to continue?\",\n          \"Hostname Verification Failure\",\n          JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,\n          null, answer, answer[0]);\n        if (ret != JOptionPane.YES_OPTION)\n          throw new WarningException(\"Hostname verification failed.\");\n      } catch (CertificateParsingException e) {\n        throw new SystemException(e.getMessage());\n      } catch (InvalidNameException e) {\n        throw new SystemException(e.getMessage());\n      }\n    }\n\n    private class MyFileInputStream extends InputStream {\n      // Blank lines in a certificate file will cause Java 6 to throw a\n      // \"DerInputStream.getLength(): lengthTag=127, too big\" exception.\n      ByteBuffer buf;\n\n      public MyFileInputStream(String name) {\n        this(new File(name));\n      }\n\n      public MyFileInputStream(File file) {\n        StringBuffer sb = new StringBuffer();\n        BufferedReader reader = null;\n        try {\n          reader = new BufferedReader(new FileReader(file));\n          String l;\n          while ((l = reader.readLine()) != null) {\n            if (l.trim().length() > 0 )\n              sb.append(l+\"\\n\");\n          }\n        } catch (java.lang.Exception e) {\n          throw new Exception(e.toString());\n        } finally {\n          try {\n            if (reader != null)\n              reader.close();\n          } catch(IOException ioe) {\n            throw new Exception(ioe.getMessage());\n          }\n        }\n        Charset utf8 = Charset.forName(\"UTF-8\");\n        buf = ByteBuffer.wrap(sb.toString().getBytes(utf8));\n        buf.limit(buf.capacity());\n      }\n\n      @Override\n      public int read(byte[] b) throws IOException {\n        return this.read(b, 0, b.length);\n      }\n\n      @Override\n      public int read(byte[] b, int off, int len) throws IOException {\n        if (!buf.hasRemaining())\n          return -1;\n        len = Math.min(len, buf.remaining());\n        buf.get(b, off, len);\n        return len;\n      }\n\n      @Override\n      public int read() throws IOException {\n        if (!buf.hasRemaining())\n          return -1;\n        return buf.get() & 0xFF;\n      }\n    }\n  }\n\n  public final int getType() { return anon ? Security.secTypeTLSNone : Security.secTypeX509None; }\n  public final String description()\n    { return anon ? \"TLS Encryption without VncAuth\" : \"X509 Encryption without VncAuth\"; }\n  public boolean isSecure() { return !anon; }\n\n  protected CConnection client;\n\n  private SSLContext ctx;\n  private SSLEngine engine;\n  private SSLEngineManager manager;\n  private boolean anon;\n\n  private String cafile, crlfile;\n  private FdInStream is;\n  private FdOutStream os;\n\n  static LogWriter vlog = new LogWriter(\"CSecurityTLS\");\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2004 Red Hat Inc.\n * Copyright (C) 2005 Martin Koegler\n * Copyright (C) 2010 m-privacy GmbH\n * Copyright (C) 2010 TigerVNC Team\n * Copyright (C) 2011-2019 Brian P. Hinz\n * Copyright (C) 2015 D. R. Commander.  All Rights Reserved.\n *\n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n * USA.\n */\n\npackage com.tigervnc.rfb;\n\nimport javax.net.ssl.*;\nimport java.security.KeyManagementException;\nimport java.security.KeyStore;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.MessageDigest;\nimport java.security.cert.*;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Base64;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport javax.naming.InvalidNameException;\nimport javax.naming.ldap.LdapName;\nimport javax.naming.ldap.Rdn;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.swing.JOptionPane;\n\nimport com.tigervnc.rdr.*;\nimport com.tigervnc.network.*;\nimport com.tigervnc.vncviewer.*;\n\nimport static javax.swing.JOptionPane.*;\n\npublic class CSecurityTLS extends CSecurity {\n\n  public static StringParameter X509CA\n  = new StringParameter(\"X509CA\",\n                        \"X509 CA certificate\", \"\", Configuration.ConfigurationObject.ConfViewer);\n  public static StringParameter X509CRL\n  = new StringParameter(\"X509CRL\",\n                        \"X509 CRL file\", \"\", Configuration.ConfigurationObject.ConfViewer);\n  public static UserMsgBox msg;\n\n  private void initGlobal()\n  {\n    try {\n      ctx = SSLContext.getInstance(\"TLS\");\n    } catch(NoSuchAlgorithmException e) {\n      throw new Exception(e.toString());\n    }\n  }\n\n  public CSecurityTLS(boolean _anon)\n  {\n    anon = _anon;\n    manager = null;\n\n    setDefaults();\n    cafile = X509CA.getData();\n    crlfile = X509CRL.getData();\n  }\n\n  public static String getDefaultCA() {\n    if (UserPreferences.get(\"viewer\", \"x509ca\") != null)\n      return UserPreferences.get(\"viewer\", \"x509ca\");\n    return FileUtils.getVncHomeDir()+\"x509_ca.pem\";\n  }\n\n  public static String getDefaultCRL() {\n    if (UserPreferences.get(\"viewer\", \"x509crl\") != null)\n      return UserPreferences.get(\"viewer\", \"x509crl\");\n    return FileUtils.getVncHomeDir()+\"x509_crl.pem\";\n  }\n\n  public static void setDefaults()\n  {\n    if (new File(getDefaultCA()).exists())\n      X509CA.setDefaultStr(getDefaultCA());\n    if (new File(getDefaultCRL()).exists())\n      X509CRL.setDefaultStr(getDefaultCRL());\n  }\n\n  public boolean processMsg(CConnection cc) {\n    is = (FdInStream)cc.getInStream();\n    os = (FdOutStream)cc.getOutStream();\n    client = cc;\n\n    initGlobal();\n\n    if (manager == null) {\n      if (!is.checkNoWait(1))\n        return false;\n\n      if (is.readU8() == 0) {\n        int result = is.readU32();\n        String reason;\n        if (result == Security.secResultFailed ||\n            result == Security.secResultTooMany)\n          reason = is.readString();\n        else\n          reason = new String(\"Authentication failure (protocol error)\");\n        throw new AuthFailureException(reason);\n      }\n\n      setParam();\n    }\n\n    try {\n      manager = new SSLEngineManager(engine, is, os);\n      manager.doHandshake();\n    } catch(java.lang.Exception e) {\n      throw new SystemException(e.toString());\n    }\n\n    cc.setStreams(new TLSInStream(is, manager),\n\t\t              new TLSOutStream(os, manager));\n    return true;\n  }\n\n  private void setParam() {\n\n    if (anon) {\n      try {\n        ctx.init(null, null, null);\n      } catch(KeyManagementException e) {\n        throw new AuthFailureException(e.toString());\n      }\n    } else {\n      try {\n        TrustManager[] myTM = new TrustManager[] {\n          new MyX509TrustManager()\n        };\n        ctx.init (null, myTM, null);\n      } catch (java.security.GeneralSecurityException e) {\n        throw new AuthFailureException(e.toString());\n      }\n    }\n    SSLSocketFactory sslfactory = ctx.getSocketFactory();\n    engine = ctx.createSSLEngine(client.getServerName(),\n                                 client.getServerPort());\n    engine.setUseClientMode(true);\n\n    String[] supported = engine.getSupportedProtocols();\n    ArrayList<String> enabled = new ArrayList<String>();\n    for (int i = 0; i < supported.length; i++)\n      if (supported[i].matches(\"TLS.*\"))\n\t      enabled.add(supported[i]);\n    engine.setEnabledProtocols(enabled.toArray(new String[0]));\n\n    if (anon) {\n      supported = engine.getSupportedCipherSuites();\n      enabled = new ArrayList<String>();\n      // prefer ECDH over DHE\n      for (int i = 0; i < supported.length; i++)\n        if (supported[i].matches(\"TLS_ECDH_anon.*\"))\n\t        enabled.add(supported[i]);\n      for (int i = 0; i < supported.length; i++)\n        if (supported[i].matches(\"TLS_DH_anon.*\"))\n\t        enabled.add(supported[i]);\n      engine.setEnabledCipherSuites(enabled.toArray(new String[0]));\n    } else {\n      engine.setEnabledCipherSuites(engine.getSupportedCipherSuites());\n    }\n\n  }\n\n  class MyX509TrustManager implements X509TrustManager\n  {\n\n    X509TrustManager tm;\n\n    MyX509TrustManager() throws java.security.GeneralSecurityException\n    {\n      KeyStore ks = KeyStore.getInstance(\"JKS\");\n      CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n      try {\n        ks.load(null, null);\n        String a = TrustManagerFactory.getDefaultAlgorithm();\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(a);\n        tmf.init((KeyStore)null);\n        for (TrustManager m : tmf.getTrustManagers())\n          if (m instanceof X509TrustManager)\n            for (X509Certificate c : ((X509TrustManager)m).getAcceptedIssuers())\n              ks.setCertificateEntry(getThumbprint((X509Certificate)c), c);\n        File cacert = new File(cafile);\n        if (cacert.exists() && cacert.canRead()) {\n          InputStream caStream = new MyFileInputStream(cacert);\n          Collection<? extends Certificate> cacerts =\n            cf.generateCertificates(caStream);\n          for (Certificate cert : cacerts) {\n            String thumbprint = getThumbprint((X509Certificate)cert);\n            ks.setCertificateEntry(thumbprint, (X509Certificate)cert);\n          }\n        }\n        PKIXBuilderParameters params =\n          new PKIXBuilderParameters(ks, new X509CertSelector());\n        File crlcert = new File(crlfile);\n        if (!crlcert.exists() || !crlcert.canRead()) {\n          params.setRevocationEnabled(false);\n        } else {\n          InputStream crlStream = new FileInputStream(crlfile);\n          Collection<? extends CRL> crls = cf.generateCRLs(crlStream);\n          CertStoreParameters csp = new CollectionCertStoreParameters(crls);\n          CertStore store = CertStore.getInstance(\"Collection\", csp);\n          params.addCertStore(store);\n          params.setRevocationEnabled(true);\n        }\n        tmf = TrustManagerFactory.getInstance(\"PKIX\");\n        tmf.init(new CertPathTrustManagerParameters(params));\n        tm = (X509TrustManager)tmf.getTrustManagers()[0];\n      } catch (java.lang.Exception e) {\n        throw new Exception(e.getMessage());\n      }\n    }\n\n    public void checkClientTrusted(X509Certificate[] chain, String authType)\n      throws CertificateException\n    {\n      tm.checkClientTrusted(chain, authType);\n    }\n\n    private final char[] hexCode = \"0123456789ABCDEF\".toCharArray();\n\n    private String printHexBinary(byte[] data)\n    {\n      StringBuilder r = new StringBuilder(data.length*2);\n      for (byte b : data) {\n        r.append(hexCode[(b >> 4) & 0xF]);\n        r.append(hexCode[(b & 0xF)]); \n      }\n      return r.toString();\n    }\n\n    public void checkServerTrusted(X509Certificate[] chain, String authType)\n      throws CertificateException\n    {\n      Collection<? extends Certificate> certs = null;\n      X509Certificate cert = chain[0];\n      String pk =\n        Base64.getEncoder().encodeToString(cert.getPublicKey().getEncoded());\n      try {\n        cert.checkValidity();\n        verifyHostname(cert);\n      } catch(CertificateParsingException e) {\n        throw new SystemException(e.getMessage());\n      } catch(CertificateNotYetValidException e) {\n        throw new AuthFailureException(\"server certificate has not been activated\");\n      } catch(CertificateExpiredException e) {\n        if (!msg.showMsgBox(YES_NO_OPTION, \"certificate has expired\",\n\t\t\t      \"The certificate of the server has expired, \"+\n\t\t\t      \"do you want to continue?\"))\n          throw new AuthFailureException(\"server certificate has expired\");\n      }\n      File vncDir = new File(FileUtils.getVncHomeDir());\n      if (!vncDir.exists())\n        throw new AuthFailureException(\"Could not obtain VNC home directory \"+\n                                       \"path for known hosts storage\");\n      File dbPath = new File(vncDir, \"x509_known_hosts\");\n      String info =\n        \"  Subject: \"+cert.getSubjectX500Principal().getName()+\"\\n\"+\n        \"  Issuer: \"+cert.getIssuerX500Principal().getName()+\"\\n\"+\n        \"  Serial Number: \"+cert.getSerialNumber()+\"\\n\"+\n        \"  Version: \"+cert.getVersion()+\"\\n\"+\n        \"  Signature Algorithm: \"+cert.getPublicKey().getAlgorithm()+\"\\n\"+\n        \"  Not Valid Before: \"+cert.getNotBefore()+\"\\n\"+\n        \"  Not Valid After: \"+cert.getNotAfter()+\"\\n\"+\n        \"  SHA-1 Fingerprint: \"+getThumbprint(cert)+\"\\n\";\n      try {\n        if (dbPath.exists()) {\n          FileReader db = new FileReader(dbPath);\n          BufferedReader dbBuf = new BufferedReader(db);\n          String line;\n          String server = client.getServerName().toLowerCase();\n          while ((line = dbBuf.readLine())!=null) {\n            String fields[] = line.split(\"\\\\|\");\n            if (fields.length==6) {\n              if (server.equals(fields[2]) && pk.equals(fields[5])) {\n                vlog.debug(\"Server certificate found in known hosts file\");\n                dbBuf.close();\n                return;\n              } else if (server.equals(fields[2]) && !pk.equals(fields[5]) ||\n                         !server.equals(fields[2]) && pk.equals(fields[5])) {\n                throw new CertStoreException();\n              }\n            }\n          }\n          dbBuf.close();\n        }\n        tm.checkServerTrusted(chain, authType);\n      } catch (IOException e) {\n        throw new AuthFailureException(\"Could not load known hosts database\");\n      } catch (CertStoreException e) {\n        vlog.debug(\"Server host key mismatch\");\n        vlog.debug(info);\n        String text =\n          \"This host is previously known with a different \"+\n          \"certificate, and the new certificate has been \"+\n          \"signed by an unknown authority\\n\"+\n          \"\\n\"+info+\"\\n\"+\n          \"Someone could be trying to impersonate the site and you should not continue.\\n\"+\n          \"\\n\"+\n          \"Do you want to make an exception for this server?\";\n        if (!msg.showMsgBox(YES_NO_OPTION, \"Unexpected certificate issuer\", text))\n          throw new AuthFailureException(\"Unexpected certificate issuer\");\n        store_pubkey(dbPath, client.getServerName().toLowerCase(), pk);\n      } catch (java.lang.Exception e) {\n        if (e.getCause() instanceof CertPathBuilderException) {\n          vlog.debug(\"Server host not previously known\");\n          vlog.debug(info);\n          String text =\n            \"This certificate has been signed by an unknown authority\\n\"+\n            \"\\n\"+info+\"\\n\"+\n            \"Someone could be trying to impersonate the site and you should not continue.\\n\"+\n            \"\\n\"+\n            \"Do you want to make an exception for this server?\";\n          if (!msg.showMsgBox(YES_NO_OPTION, \"Unknown certificate issuer\", text))\n            throw new AuthFailureException(\"Unknown certificate issuer\");\n          store_pubkey(dbPath, client.getServerName().toLowerCase(), pk);\n        } else {\n          throw new SystemException(e.getMessage());\n        }\n      }\n    }\n\n    private void store_pubkey(File dbPath, String serverName, String pk)\n    {\n      ArrayList<String> lines = new ArrayList<String>();\n      File vncDir = new File(FileUtils.getVncHomeDir());\n      try {\n        if (dbPath.exists()) {\n          FileReader db = new FileReader(dbPath);\n          BufferedReader dbBuf = new BufferedReader(db);\n          String line;\n          while ((line = dbBuf.readLine())!=null) {\n            String fields[] = line.split(\"\\\\|\");\n            if (fields.length==6)\n              if (!serverName.equals(fields[2]) && !pk.equals(fields[5]))\n                lines.add(line);\n          }\n          dbBuf.close();\n        }\n      } catch (IOException e) {\n        throw new AuthFailureException(\"Could not load known hosts database\");\n      }\n      try {\n        if (!dbPath.exists())\n          dbPath.createNewFile();\n        FileWriter fw = new FileWriter(dbPath.getAbsolutePath(), false);\n        Iterator i = lines.iterator();\n        while (i.hasNext())\n          fw.write((String)i.next()+\"\\n\");\n        fw.write(\"|g0|\"+serverName+\"|*|0|\"+pk+\"\\n\");\n        fw.close();\n      } catch (IOException e) {\n        vlog.error(\"Failed to store server certificate to known hosts database\");\n      }\n    }\n\n    public X509Certificate[] getAcceptedIssuers ()\n    {\n      return tm.getAcceptedIssuers();\n    }\n\n    private String getThumbprint(X509Certificate cert)\n    {\n      String thumbprint = null;\n      try {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        md.update(cert.getEncoded());\n        thumbprint = printHexBinary(md.digest());\n        thumbprint = thumbprint.replaceAll(\"..(?!$)\", \"$0 \");\n      } catch(CertificateEncodingException e) {\n        throw new SystemException(e.getMessage());\n      } catch(NoSuchAlgorithmException e) {\n        throw new SystemException(e.getMessage());\n      }\n      return thumbprint;\n    }\n\n    private void verifyHostname(X509Certificate cert)\n      throws CertificateParsingException\n    {\n      try {\n        Collection sans = cert.getSubjectAlternativeNames();\n        if (sans == null) {\n          String dn = cert.getSubjectX500Principal().getName();\n          LdapName ln = new LdapName(dn);\n          for (Rdn rdn : ln.getRdns()) {\n            if (rdn.getType().equalsIgnoreCase(\"CN\")) {\n              String peer = client.getServerName().toLowerCase();\n              if (peer.equals(((String)rdn.getValue()).toLowerCase()))\n                return;\n            }\n          }\n        } else {\n          Iterator i = sans.iterator();\n          while (i.hasNext()) {\n            List nxt = (List)i.next();\n            if (((Integer)nxt.get(0)).intValue() == 2) {\n              String peer = client.getServerName().toLowerCase();\n              if (peer.equals(((String)nxt.get(1)).toLowerCase()))\n                return;\n            } else if (((Integer)nxt.get(0)).intValue() == 7) {\n              String peer = ((CConn)client).getSocket().getPeerAddress();\n              if (peer.equals(((String)nxt.get(1)).toLowerCase()))\n                return;\n            }\n          }\n        }\n        Object[] answer = {\"YES\", \"NO\"};\n        int ret = JOptionPane.showOptionDialog(null,\n          \"Hostname (\"+client.getServerName()+\") does not match the\"+\n          \" server certificate, do you want to continue?\",\n          \"Certificate hostname mismatch\",\n          JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,\n          null, answer, answer[0]);\n        if (ret != JOptionPane.YES_OPTION)\n          throw new WarningException(\"Certificate hostname mismatch.\");\n      } catch (CertificateParsingException e) {\n        throw new SystemException(e.getMessage());\n      } catch (InvalidNameException e) {\n        throw new SystemException(e.getMessage());\n      }\n    }\n\n    private class MyFileInputStream extends InputStream {\n      // Blank lines in a certificate file will cause Java 6 to throw a\n      // \"DerInputStream.getLength(): lengthTag=127, too big\" exception.\n      ByteBuffer buf;\n\n      public MyFileInputStream(String name) {\n        this(new File(name));\n      }\n\n      public MyFileInputStream(File file) {\n        StringBuffer sb = new StringBuffer();\n        BufferedReader reader = null;\n        try {\n          reader = new BufferedReader(new FileReader(file));\n          String l;\n          while ((l = reader.readLine()) != null) {\n            if (l.trim().length() > 0 )\n              sb.append(l+\"\\n\");\n          }\n        } catch (java.lang.Exception e) {\n          throw new Exception(e.toString());\n        } finally {\n          try {\n            if (reader != null)\n              reader.close();\n          } catch(IOException ioe) {\n            throw new Exception(ioe.getMessage());\n          }\n        }\n        Charset utf8 = Charset.forName(\"UTF-8\");\n        buf = ByteBuffer.wrap(sb.toString().getBytes(utf8));\n        buf.limit(buf.capacity());\n      }\n\n      @Override\n      public int read(byte[] b) throws IOException {\n        return this.read(b, 0, b.length);\n      }\n\n      @Override\n      public int read(byte[] b, int off, int len) throws IOException {\n        if (!buf.hasRemaining())\n          return -1;\n        len = Math.min(len, buf.remaining());\n        buf.get(b, off, len);\n        return len;\n      }\n\n      @Override\n      public int read() throws IOException {\n        if (!buf.hasRemaining())\n          return -1;\n        return buf.get() & 0xFF;\n      }\n    }\n  }\n\n  public final int getType() { return anon ? Security.secTypeTLSNone : Security.secTypeX509None; }\n  public final String description()\n    { return anon ? \"TLS Encryption without VncAuth\" : \"X509 Encryption without VncAuth\"; }\n  public boolean isSecure() { return !anon; }\n\n  protected CConnection client;\n\n  private SSLContext ctx;\n  private SSLEngine engine;\n  private SSLEngineManager manager;\n  private boolean anon;\n\n  private String cafile, crlfile;\n  private FdInStream is;\n  private FdOutStream os;\n\n  static LogWriter vlog = new LogWriter(\"CSecurityTLS\");\n}\n"], "filenames": ["java/com/tigervnc/rfb/CSecurityTLS.java"], "buggy_code_start_loc": [110], "buggy_code_end_loc": [408], "fixing_code_start_loc": [109], "fixing_code_end_loc": [446], "type": "CWE-295", "message": "In rfb/CSecurityTLS.cxx and rfb/CSecurityTLS.java in TigerVNC before 1.11.0, viewers mishandle TLS certificate exceptions. They store the certificates as authorities, meaning that the owner of a certificate could impersonate any server after a client had added an exception.", "other": {"cve": {"id": "CVE-2020-26117", "sourceIdentifier": "cve@mitre.org", "published": "2020-09-27T04:15:11.650", "lastModified": "2022-11-16T14:13:22.957", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In rfb/CSecurityTLS.cxx and rfb/CSecurityTLS.java in TigerVNC before 1.11.0, viewers mishandle TLS certificate exceptions. They store the certificates as authorities, meaning that the owner of a certificate could impersonate any server after a client had added an exception."}, {"lang": "es", "value": "En los archivos rfb/CSecurityTLS.cxx y rfb/CSecurityTLS.java en TigerVNC versiones anteriores a 1.11.0, los espectadores manejan inapropiadamente las excepciones del certificado TLS.&#xa0;Almacenan los certificados como autoridades, lo que significa que el propietario de un certificado puede hacerse pasar por cualquier servidor despu\u00e9s de que un cliente haya agregado una excepci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-295"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tigervnc:tigervnc:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.11.0", "matchCriteriaId": "EC52A117-CA1A-4BDC-B60B-36D84CB48B35"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.2:*:*:*:*:*:*:*", "matchCriteriaId": "B009C22E-30A4-4288-BCF6-C3E81DEAF45A"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-10/msg00025.html", "source": "cve@mitre.org", "tags": ["Broken Link", "Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-11/msg00024.html", "source": "cve@mitre.org", "tags": ["Broken Link", "Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.opensuse.org/show_bug.cgi?id=1176733", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/TigerVNC/tigervnc/commit/20dea801e747318525a5859fe4f37c52b05310cb", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/TigerVNC/tigervnc/commit/7399eab79a4365434d26494fa1628ce1eb91562b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/TigerVNC/tigervnc/commit/b30f10c681ec87720cff85d490f67098568a9cba", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/TigerVNC/tigervnc/commit/f029745f63ac7d22fb91639b2cb5b3ab56134d6e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/TigerVNC/tigervnc/releases/tag/v1.11.0", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/10/msg00007.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/TigerVNC/tigervnc/commit/20dea801e747318525a5859fe4f37c52b05310cb"}}