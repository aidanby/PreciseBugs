{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                         BBBB   L       OOO   BBBB                           %\n%                         B   B  L      O   O  B   B                          %\n%                         BBBB   L      O   O  BBBB                           %\n%                         B   B  L      O   O  B   B                          %\n%                         BBBB   LLLLL   OOO   BBBB                           %\n%                                                                             %\n%                                                                             %\n%                     MagickCore Binary Large OBjectS Methods                 %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1999                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#ifdef __VMS\n#include  <types.h>\n#include  <mman.h>\n#endif\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/delegate.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/locale_.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/nt-base-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/policy.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/timer-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n#include \"zlib.h\"\n#endif\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n#include \"bzlib.h\"\n#endif\n\f\n/*\n  Define declarations.\n*/\n#define MagickMaxBlobExtent  (8*8192)\n#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)\n# define MAP_ANONYMOUS  MAP_ANON\n#endif\n#if !defined(MAP_FAILED)\n#define MAP_FAILED  ((void *) -1)\n#endif\n#if defined(__OS2__)\n#include <io.h>\n#define _O_BINARY O_BINARY\n#endif\n\f\n/*\n  Typedef declarations.\n*/\ntypedef union FileInfo\n{\n  FILE\n    *file;\n\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n  gzFile\n    gzfile;\n#endif\n\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n  BZFILE\n    *bzfile;\n#endif\n} FileInfo;\n\nstruct _BlobInfo\n{\n  size_t\n    length,\n    extent,\n    quantum;\n\n  BlobMode\n    mode;\n\n  MagickBooleanType\n    mapped,\n    eof;\n\n  int\n    error;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    size;\n\n  MagickBooleanType\n    exempt,\n    synchronize,\n    status,\n    temporary;\n\n  StreamType\n    type;\n\n  FileInfo\n    file_info;\n\n  struct stat\n    properties;\n\n  StreamHandler\n    stream;\n\n  CustomStreamInfo\n    *custom_stream;\n\n  unsigned char\n    *data;\n\n  MagickBooleanType\n    debug;\n\n  SemaphoreInfo\n    *semaphore;\n\n  ssize_t\n    reference_count;\n\n  size_t\n    signature;\n};\n\nstruct _CustomStreamInfo\n{\n  CustomStreamHandler\n    reader,\n    writer;\n\n  CustomStreamSeeker\n    seeker;\n\n  CustomStreamTeller\n    teller;\n\n  void\n    *data;\n\n  size_t\n    signature;\n};\n\f\n/*\n  Forward declarations.\n*/\nstatic int\n  SyncBlob(Image *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A c q u i r e C u s t o m S t r e a m I n f o                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireCustomStreamInfo() allocates the CustomStreamInfo structure.\n%\n%  The format of the AcquireCustomStreamInfo method is:\n%\n%      CustomStreamInfo *AcquireCustomStreamInfo(ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport CustomStreamInfo *AcquireCustomStreamInfo(\n  ExceptionInfo *magick_unused(exception))\n{\n  CustomStreamInfo\n    *custom_stream;\n\n  magick_unreferenced(exception);\n  custom_stream=(CustomStreamInfo *) AcquireCriticalMemory(\n    sizeof(*custom_stream));\n  (void) memset(custom_stream,0,sizeof(*custom_stream));\n  custom_stream->signature=MagickCoreSignature;\n  return(custom_stream);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A t t a c h B l o b                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AttachBlob() attaches a blob to the BlobInfo structure.\n%\n%  The format of the AttachBlob method is:\n%\n%      void AttachBlob(BlobInfo *blob_info,const void *blob,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o blob_info: Specifies a pointer to a BlobInfo structure.\n%\n%    o blob: the address of a character stream in one of the image formats\n%      understood by ImageMagick.\n%\n%    o length: This size_t integer reflects the length in bytes of the blob.\n%\n*/\nMagickExport void AttachBlob(BlobInfo *blob_info,const void *blob,\n  const size_t length)\n{\n  assert(blob_info != (BlobInfo *) NULL);\n  if (blob_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  blob_info->length=length;\n  blob_info->extent=length;\n  blob_info->quantum=(size_t) MagickMaxBlobExtent;\n  blob_info->offset=0;\n  blob_info->type=BlobStream;\n  blob_info->file_info.file=(FILE *) NULL;\n  blob_info->data=(unsigned char *) blob;\n  blob_info->mapped=MagickFalse;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A t t a c h C u s t o m S t r e a m                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AttachCustomStream() attaches a CustomStreamInfo to the BlobInfo structure.\n%\n%  The format of the AttachCustomStream method is:\n%\n%      void AttachCustomStream(BlobInfo *blob_info,\n%        CustomStreamInfo *custom_stream)\n%\n%  A description of each parameter follows:\n%\n%    o blob_info: specifies a pointer to a BlobInfo structure.\n%\n%    o custom_stream: the custom stream info.\n%\n*/\nMagickExport void AttachCustomStream(BlobInfo *blob_info,\n  CustomStreamInfo *custom_stream)\n{\n  assert(blob_info != (BlobInfo *) NULL);\n  assert(custom_stream != (CustomStreamInfo *) NULL);\n  assert(custom_stream->signature == MagickCoreSignature);\n  if (blob_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  blob_info->type=CustomStream;\n  blob_info->custom_stream=custom_stream;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   B l o b T o F i l e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  BlobToFile() writes a blob to a file.  It returns MagickFalse if an error\n%  occurs otherwise MagickTrue.\n%\n%  The format of the BlobToFile method is:\n%\n%       MagickBooleanType BlobToFile(char *filename,const void *blob,\n%         const size_t length,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o filename: Write the blob to this file.\n%\n%    o blob: the address of a blob.\n%\n%    o length: This length in bytes of the blob.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType BlobToFile(char *filename,const void *blob,\n  const size_t length,ExceptionInfo *exception)\n{\n  int\n    file;\n\n  register size_t\n    i;\n\n  ssize_t\n    count;\n\n  assert(filename != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  assert(blob != (const void *) NULL);\n  if (*filename == '\\0')\n    file=AcquireUniqueFileResource(filename);\n  else\n    file=open_utf8(filename,O_RDWR | O_CREAT | O_EXCL | O_BINARY,S_MODE);\n  if (file == -1)\n    {\n      ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",filename);\n      return(MagickFalse);\n    }\n  for (i=0; i < length; i+=count)\n  {\n    count=write(file,(const char *) blob+i,MagickMin(length-i,(size_t)\n      SSIZE_MAX));\n    if (count <= 0)\n      {\n        count=0;\n        if (errno != EINTR)\n          break;\n      }\n  }\n  file=close(file);\n  if ((file == -1) || (i < length))\n    {\n      ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",filename);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   B l o b T o I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  BlobToImage() implements direct to memory image formats.  It returns the\n%  blob as an image.\n%\n%  The format of the BlobToImage method is:\n%\n%      Image *BlobToImage(const ImageInfo *image_info,const void *blob,\n%        const size_t length,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o blob: the address of a character stream in one of the image formats\n%      understood by ImageMagick.\n%\n%    o length: This size_t integer reflects the length in bytes of the blob.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *BlobToImage(const ImageInfo *image_info,const void *blob,\n  const size_t length,ExceptionInfo *exception)\n{\n  const MagickInfo\n    *magick_info;\n\n  Image\n    *image;\n\n  ImageInfo\n    *blob_info,\n    *clone_info;\n\n  MagickBooleanType\n    status;\n\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  if ((blob == (const void *) NULL) || (length == 0))\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),BlobError,\n        \"ZeroLengthBlobNotPermitted\",\"`%s'\",image_info->filename);\n      return((Image *) NULL);\n    }\n  blob_info=CloneImageInfo(image_info);\n  blob_info->blob=(void *) blob;\n  blob_info->length=length;\n  if (*blob_info->magick == '\\0')\n    (void) SetImageInfo(blob_info,0,exception);\n  magick_info=GetMagickInfo(blob_info->magick,exception);\n  if (magick_info == (const MagickInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        MissingDelegateError,\"NoDecodeDelegateForThisImageFormat\",\"`%s'\",\n        blob_info->magick);\n      blob_info=DestroyImageInfo(blob_info);\n      return((Image *) NULL);\n    }\n  if (GetMagickBlobSupport(magick_info) != MagickFalse)\n    {\n      char\n        filename[MagickPathExtent];\n\n      /*\n        Native blob support for this image format.\n      */\n      (void) CopyMagickString(filename,blob_info->filename,MagickPathExtent);\n      (void) FormatLocaleString(blob_info->filename,MagickPathExtent,\"%s:%s\",\n        blob_info->magick,filename);\n      image=ReadImage(blob_info,exception);\n      if (image != (Image *) NULL)\n        (void) DetachBlob(image->blob);\n      blob_info=DestroyImageInfo(blob_info);\n      return(image);\n    }\n  /*\n    Write blob to a temporary file on disk.\n  */\n  blob_info->blob=(void *) NULL;\n  blob_info->length=0;\n  *blob_info->filename='\\0';\n  status=BlobToFile(blob_info->filename,blob,length,exception);\n  if (status == MagickFalse)\n    {\n      (void) RelinquishUniqueFileResource(blob_info->filename);\n      blob_info=DestroyImageInfo(blob_info);\n      return((Image *) NULL);\n    }\n  clone_info=CloneImageInfo(blob_info);\n  (void) FormatLocaleString(clone_info->filename,MagickPathExtent,\"%s:%s\",\n    blob_info->magick,blob_info->filename);\n  image=ReadImage(clone_info,exception);\n  if (image != (Image *) NULL)\n    {\n      Image\n        *images;\n\n      /*\n        Restore original filenames and image format.\n      */\n      for (images=GetFirstImageInList(image); images != (Image *) NULL; )\n      {\n        (void) CopyMagickString(images->filename,image_info->filename,\n          MagickPathExtent);\n        (void) CopyMagickString(images->magick_filename,image_info->filename,\n          MagickPathExtent);\n        (void) CopyMagickString(images->magick,magick_info->name,\n          MagickPathExtent);\n        images=GetNextImageInList(images);\n      }\n    }\n  clone_info=DestroyImageInfo(clone_info);\n  (void) RelinquishUniqueFileResource(blob_info->filename);\n  blob_info=DestroyImageInfo(blob_info);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C l o n e B l o b I n f o                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneBlobInfo() makes a duplicate of the given blob info structure, or if\n%  blob info is NULL, a new one.\n%\n%  The format of the CloneBlobInfo method is:\n%\n%      BlobInfo *CloneBlobInfo(const BlobInfo *blob_info)\n%\n%  A description of each parameter follows:\n%\n%    o blob_info: the blob info.\n%\n*/\nMagickExport BlobInfo *CloneBlobInfo(const BlobInfo *blob_info)\n{\n  BlobInfo\n    *clone_info;\n\n  SemaphoreInfo\n    *semaphore;\n\n  clone_info=(BlobInfo *) AcquireCriticalMemory(sizeof(*clone_info));\n  GetBlobInfo(clone_info);\n  if (blob_info == (BlobInfo *) NULL)\n    return(clone_info);\n  semaphore=clone_info->semaphore;\n  (void) memcpy(clone_info,blob_info,sizeof(*clone_info));\n  if (blob_info->mapped != MagickFalse)\n    (void) AcquireMagickResource(MapResource,blob_info->length);\n  clone_info->semaphore=semaphore;\n  LockSemaphoreInfo(clone_info->semaphore);\n  clone_info->reference_count=1;\n  UnlockSemaphoreInfo(clone_info->semaphore);\n  return(clone_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C l o s e B l o b                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloseBlob() closes a stream associated with the image.\n%\n%  The format of the CloseBlob method is:\n%\n%      MagickBooleanType CloseBlob(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType CloseBlob(Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  int\n    status;\n\n  /*\n    Close image file.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  blob_info=image->blob;\n  if ((blob_info == (BlobInfo *) NULL) || (blob_info->type == UndefinedStream))\n    return(MagickTrue);\n  status=SyncBlob(image);\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    case PipeStream:\n    {\n      if (blob_info->synchronize != MagickFalse)\n        status=fsync(fileno(blob_info->file_info.file));\n      status=ferror(blob_info->file_info.file);\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      (void) gzerror(blob_info->file_info.gzfile,&status);\n#endif\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      (void) BZ2_bzerror(blob_info->file_info.bzfile,&status);\n#endif\n      break;\n    }\n    case FifoStream:\n      break;\n    case BlobStream:\n    {\n      if (blob_info->file_info.file != (FILE *) NULL)\n        {\n          if (blob_info->synchronize != MagickFalse)\n            status=fsync(fileno(blob_info->file_info.file));\n          status=ferror(blob_info->file_info.file);\n        }\n      break;\n    }\n    case CustomStream:\n      break;\n  }\n  blob_info->status=status < 0 ? MagickTrue : MagickFalse;\n  blob_info->size=GetBlobSize(image);\n  image->extent=blob_info->size;\n  blob_info->eof=MagickFalse;\n  blob_info->error=0;\n  blob_info->mode=UndefinedBlobMode;\n  if (blob_info->exempt != MagickFalse)\n    {\n      blob_info->type=UndefinedStream;\n      return(blob_info->status);\n    }\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    {\n      if (fileno(blob_info->file_info.file) != -1)\n        status=fclose(blob_info->file_info.file);\n      break;\n    }\n    case PipeStream:\n    {\n#if defined(MAGICKCORE_HAVE_PCLOSE)\n      status=pclose(blob_info->file_info.file);\n#endif\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      status=gzclose(blob_info->file_info.gzfile);\n#endif\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      BZ2_bzclose(blob_info->file_info.bzfile);\n#endif\n      break;\n    }\n    case FifoStream:\n      break;\n    case BlobStream:\n    {\n      if (blob_info->file_info.file != (FILE *) NULL)\n        status=fclose(blob_info->file_info.file);\n      break;\n    }\n    case CustomStream:\n      break;\n  }\n  (void) DetachBlob(blob_info);\n  blob_info->status=status < 0 ? MagickTrue : MagickFalse;\n  return(blob_info->status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C u s t o m S t r e a m T o I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CustomStreamToImage() is the equivalent of ReadImage(), but reads the\n%  formatted \"file\" from the suplied method rather than to an actual file.\n%\n%  The format of the CustomStreamToImage method is:\n%\n%      Image *CustomStreamToImage(const ImageInfo *image_info,\n%         ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *CustomStreamToImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const MagickInfo\n    *magick_info;\n\n  Image\n    *image;\n\n  ImageInfo\n    *blob_info;\n\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(image_info->custom_stream != (CustomStreamInfo *) NULL);\n  assert(image_info->custom_stream->signature == MagickCoreSignature);\n  assert(image_info->custom_stream->reader != (CustomStreamHandler) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  blob_info=CloneImageInfo(image_info);\n  if (*blob_info->magick == '\\0')\n    (void) SetImageInfo(blob_info,0,exception);\n  magick_info=GetMagickInfo(blob_info->magick,exception);\n  if (magick_info == (const MagickInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        MissingDelegateError,\"NoDecodeDelegateForThisImageFormat\",\"`%s'\",\n        blob_info->magick);\n      blob_info=DestroyImageInfo(blob_info);\n      return((Image *) NULL);\n    }\n  image=(Image *) NULL;\n  if ((GetMagickBlobSupport(magick_info) != MagickFalse) ||\n      (*blob_info->filename != '\\0'))\n    {\n      char\n        filename[MagickPathExtent];\n\n      /*\n        Native blob support for this image format or SetImageInfo changed the\n        blob to a file.\n      */\n      (void) CopyMagickString(filename,blob_info->filename,MagickPathExtent);\n      (void) FormatLocaleString(blob_info->filename,MagickPathExtent,\"%s:%s\",\n        blob_info->magick,filename);\n      image=ReadImage(blob_info,exception);\n      if (image != (Image *) NULL)\n        (void) CloseBlob(image);\n    }\n  else\n    {\n      char\n        unique[MagickPathExtent];\n\n      int\n        file;\n\n      ImageInfo\n        *clone_info;\n\n      unsigned char\n        *blob;\n\n      /*\n        Write data to file on disk.\n      */\n      blob_info->custom_stream=(CustomStreamInfo *) NULL;\n      blob=(unsigned char *) AcquireQuantumMemory(MagickMaxBufferExtent,\n        sizeof(*blob));\n      if (blob == (unsigned char *) NULL)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToReadBlob\",\n            image_info->filename);\n          blob_info=DestroyImageInfo(blob_info);\n          return((Image *) NULL);\n        }\n      file=AcquireUniqueFileResource(unique);\n      if (file == -1)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToReadBlob\",\n            image_info->filename);\n          blob=(unsigned char *) RelinquishMagickMemory(blob);\n          blob_info=DestroyImageInfo(blob_info);\n          return((Image *) NULL);\n        }\n      clone_info=CloneImageInfo(blob_info);\n      blob_info->file=fdopen(file,\"wb+\");\n      if (blob_info->file != (FILE *) NULL)\n        {\n          ssize_t\n            count;\n\n          count=(ssize_t) MagickMaxBufferExtent;\n          while (count == (ssize_t) MagickMaxBufferExtent)\n          {\n            count=image_info->custom_stream->reader(blob,MagickMaxBufferExtent,\n              image_info->custom_stream->data);\n            count=(ssize_t) write(file,(const char *) blob,(size_t) count);\n          }\n          (void) fclose(blob_info->file);\n          (void) FormatLocaleString(clone_info->filename,MagickPathExtent,\n            \"%s:%s\",blob_info->magick,unique);\n          image=ReadImage(clone_info,exception);\n          if (image != (Image *) NULL)\n            {\n              Image\n                *images;\n\n              /*\n                Restore original filenames and image format.\n              */\n              for (images=GetFirstImageInList(image); images != (Image *) NULL; )\n              {\n                (void) CopyMagickString(images->filename,image_info->filename,\n                  MagickPathExtent);\n                (void) CopyMagickString(images->magick_filename,\n                  image_info->filename,MagickPathExtent);\n                (void) CopyMagickString(images->magick,magick_info->name,\n                  MagickPathExtent);\n                (void) CloseBlob(images);\n                images=GetNextImageInList(images);\n              }\n            }\n        }\n      clone_info=DestroyImageInfo(clone_info);\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n      (void) RelinquishUniqueFileResource(unique);\n    }\n  blob_info=DestroyImageInfo(blob_info);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y B l o b                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyBlob() deallocates memory associated with a blob.\n%\n%  The format of the DestroyBlob method is:\n%\n%      void DestroyBlob(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void DestroyBlob(Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  MagickBooleanType\n    destroy;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->signature == MagickCoreSignature);\n  blob_info=image->blob;\n  destroy=MagickFalse;\n  LockSemaphoreInfo(blob_info->semaphore);\n  blob_info->reference_count--;\n  assert(blob_info->reference_count >= 0);\n  if (blob_info->reference_count == 0)\n    destroy=MagickTrue;\n  UnlockSemaphoreInfo(blob_info->semaphore);\n  if (destroy == MagickFalse)\n    {\n      image->blob=(BlobInfo *) NULL;\n      return;\n    }\n  (void) CloseBlob(image);\n  if (blob_info->mapped != MagickFalse)\n    {\n      (void) UnmapBlob(blob_info->data,blob_info->length);\n      RelinquishMagickResource(MapResource,blob_info->length);\n    }\n  if (blob_info->semaphore != (SemaphoreInfo *) NULL)\n    RelinquishSemaphoreInfo(&blob_info->semaphore);\n  blob_info->signature=(~MagickCoreSignature);\n  image->blob=(BlobInfo *) RelinquishMagickMemory(blob_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y C u s t o m S t r e a m I n f o                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyCustomStreamInfo() destroys memory associated with the\n%  CustomStreamInfo structure.\n%\n%  The format of the DestroyCustomStreamInfo method is:\n%\n%      CustomStreamInfo *DestroyCustomStreamInfo(CustomStreamInfo *stream_info)\n%\n%  A description of each parameter follows:\n%\n%    o custom_stream: the custom stream info.\n%\n*/\nMagickExport CustomStreamInfo *DestroyCustomStreamInfo(\n  CustomStreamInfo *custom_stream)\n{\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(custom_stream != (CustomStreamInfo *) NULL);\n  assert(custom_stream->signature == MagickCoreSignature);\n  custom_stream->signature=(~MagickCoreSignature);\n  custom_stream=(CustomStreamInfo *) RelinquishMagickMemory(custom_stream);\n  return(custom_stream);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e t a c h B l o b                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DetachBlob() detaches a blob from the BlobInfo structure.\n%\n%  The format of the DetachBlob method is:\n%\n%      void *DetachBlob(BlobInfo *blob_info)\n%\n%  A description of each parameter follows:\n%\n%    o blob_info: Specifies a pointer to a BlobInfo structure.\n%\n*/\nMagickExport void *DetachBlob(BlobInfo *blob_info)\n{\n  void\n    *data;\n\n  assert(blob_info != (BlobInfo *) NULL);\n  if (blob_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  if (blob_info->mapped != MagickFalse)\n    {\n      (void) UnmapBlob(blob_info->data,blob_info->length);\n      RelinquishMagickResource(MapResource,blob_info->length);\n    }\n  blob_info->mapped=MagickFalse;\n  blob_info->length=0;\n  blob_info->offset=0;\n  blob_info->eof=MagickFalse;\n  blob_info->error=0;\n  blob_info->exempt=MagickFalse;\n  blob_info->type=UndefinedStream;\n  blob_info->file_info.file=(FILE *) NULL;\n  data=blob_info->data;\n  blob_info->data=(unsigned char *) NULL;\n  blob_info->stream=(StreamHandler) NULL;\n  blob_info->custom_stream=(CustomStreamInfo *) NULL;\n  return(data);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D i s a s s o c i a t e B l o b                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DisassociateBlob() disassociates the image stream.  It checks if the\n%  blob of the specified image is referenced by other images. If the reference\n%  count is higher then 1 a new blob is assigned to the specified image.\n%\n%  The format of the DisassociateBlob method is:\n%\n%      void DisassociateBlob(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void DisassociateBlob(Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info,\n    *clone_info;\n\n  MagickBooleanType\n    clone;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->signature == MagickCoreSignature);\n  blob_info=image->blob;\n  clone=MagickFalse;\n  LockSemaphoreInfo(blob_info->semaphore);\n  assert(blob_info->reference_count >= 0);\n  if (blob_info->reference_count > 1)\n    clone=MagickTrue;\n  UnlockSemaphoreInfo(blob_info->semaphore);\n  if (clone == MagickFalse)\n    return;\n  clone_info=CloneBlobInfo(blob_info);\n  DestroyBlob(image);\n  image->blob=clone_info;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  D i s c a r d B l o b B y t e s                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DiscardBlobBytes() discards bytes in a blob.\n%\n%  The format of the DiscardBlobBytes method is:\n%\n%      MagickBooleanType DiscardBlobBytes(Image *image,\n%        const MagickSizeType length)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o length:  the number of bytes to skip.\n%\n*/\nMagickExport MagickBooleanType DiscardBlobBytes(Image *image,\n  const MagickSizeType length)\n{\n  register MagickOffsetType\n    i;\n\n  size_t\n    quantum;\n\n  ssize_t\n    count;\n\n  unsigned char\n    buffer[16384];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (length != (MagickSizeType) ((MagickOffsetType) length))\n    return(MagickFalse);\n  count=0;\n  for (i=0; i < (MagickOffsetType) length; i+=count)\n  {\n    quantum=(size_t) MagickMin(length-i,sizeof(buffer));\n    (void) ReadBlobStream(image,quantum,buffer,&count);\n    if (count <= 0)\n      {\n        count=0;\n        if (errno != EINTR)\n          break;\n      }\n  }\n  return(i < (MagickOffsetType) length ? MagickFalse : MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D u p l i c a t e s B l o b                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DuplicateBlob() duplicates a blob descriptor.\n%\n%  The format of the DuplicateBlob method is:\n%\n%      void DuplicateBlob(Image *image,const Image *duplicate)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o duplicate: the duplicate image.\n%\n*/\nMagickExport void DuplicateBlob(Image *image,const Image *duplicate)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(duplicate != (Image *) NULL);\n  assert(duplicate->signature == MagickCoreSignature);\n  DestroyBlob(image);\n  image->blob=ReferenceBlob(duplicate->blob);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  E O F B l o b                                                              %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  EOFBlob() returns a non-zero value when EOF has been detected reading from\n%  a blob or file.\n%\n%  The format of the EOFBlob method is:\n%\n%      int EOFBlob(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport int EOFBlob(const Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  blob_info=image->blob;\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    case PipeStream:\n    {\n      blob_info->eof=feof(blob_info->file_info.file) != 0 ? MagickTrue :\n        MagickFalse;\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      blob_info->eof=gzeof(blob_info->file_info.gzfile) != 0 ? MagickTrue :\n        MagickFalse;\n#endif\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      int\n        status;\n\n      status=0;\n      (void) BZ2_bzerror(blob_info->file_info.bzfile,&status);\n      blob_info->eof=status == BZ_UNEXPECTED_EOF ? MagickTrue : MagickFalse;\n#endif\n      break;\n    }\n    case FifoStream:\n    {\n      blob_info->eof=MagickFalse;\n      break;\n    }\n    case BlobStream:\n      break;\n    case CustomStream:\n      break;\n  }\n  return((int) blob_info->eof);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  E r r o r B l o b                                                          %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ErrorBlob() returns a non-zero value when an error has been detected reading\n%  from a blob or file.\n%\n%  The format of the ErrorBlob method is:\n%\n%      int ErrorBlob(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport int ErrorBlob(const Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  blob_info=image->blob;\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    case PipeStream:\n    {\n      blob_info->error=ferror(blob_info->file_info.file);\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      (void) gzerror(blob_info->file_info.gzfile,&blob_info->error);\n#endif\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      (void) BZ2_bzerror(blob_info->file_info.bzfile,&blob_info->error);\n#endif\n      break;\n    }\n    case FifoStream:\n    {\n      blob_info->error=0;\n      break;\n    }\n    case BlobStream:\n      break;\n    case CustomStream:\n      break;\n  }\n  return(blob_info->error);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   F i l e T o B l o b                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FileToBlob() returns the contents of a file as a buffer terminated with\n%  the '\\0' character.  The length of the buffer (not including the extra\n%  terminating '\\0' character) is returned via the 'length' parameter.  Free\n%  the buffer with RelinquishMagickMemory().\n%\n%  The format of the FileToBlob method is:\n%\n%      void *FileToBlob(const char *filename,const size_t extent,\n%        size_t *length,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o blob:  FileToBlob() returns the contents of a file as a blob.  If\n%      an error occurs NULL is returned.\n%\n%    o filename: the filename.\n%\n%    o extent:  The maximum length of the blob.\n%\n%    o length: On return, this reflects the actual length of the blob.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport void *FileToBlob(const char *filename,const size_t extent,\n  size_t *length,ExceptionInfo *exception)\n{\n  int\n    file;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  register size_t\n    i;\n\n  ssize_t\n    count;\n\n  struct stat\n    attributes;\n\n  unsigned char\n    *blob;\n\n  void\n    *map;\n\n  assert(filename != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  *length=0;\n  status=IsRightsAuthorized(PathPolicyDomain,ReadPolicyRights,filename);\n  if (status == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",filename);\n      return(NULL);\n    }\n  file=fileno(stdin);\n  if (LocaleCompare(filename,\"-\") != 0)\n    {\n      status=GetPathAttributes(filename,&attributes);\n      if ((status == MagickFalse) || (S_ISDIR(attributes.st_mode) != 0))\n        {\n          ThrowFileException(exception,BlobError,\"UnableToReadBlob\",filename);\n          return(NULL);\n        }\n      file=open_utf8(filename,O_RDONLY | O_BINARY,0);\n    }\n  if (file == -1)\n    {\n      ThrowFileException(exception,BlobError,\"UnableToOpenFile\",filename);\n      return(NULL);\n    }\n  offset=(MagickOffsetType) lseek(file,0,SEEK_END);\n  count=0;\n  if ((file == fileno(stdin)) || (offset < 0) ||\n      (offset != (MagickOffsetType) ((ssize_t) offset)))\n    {\n      size_t\n        quantum;\n\n      struct stat\n        file_stats;\n\n      /*\n        Stream is not seekable.\n      */\n      offset=(MagickOffsetType) lseek(file,0,SEEK_SET);\n      quantum=(size_t) MagickMaxBufferExtent;\n      if ((fstat(file,&file_stats) == 0) && (file_stats.st_size > 0))\n        quantum=(size_t) MagickMin(file_stats.st_size,MagickMaxBufferExtent);\n      blob=(unsigned char *) AcquireQuantumMemory(quantum,sizeof(*blob));\n      for (i=0; blob != (unsigned char *) NULL; i+=count)\n      {\n        count=read(file,blob+i,quantum);\n        if (count <= 0)\n          {\n            count=0;\n            if (errno != EINTR)\n              break;\n          }\n        if (~((size_t) i) < (quantum+1))\n          {\n            blob=(unsigned char *) RelinquishMagickMemory(blob);\n            break;\n          }\n        blob=(unsigned char *) ResizeQuantumMemory(blob,i+quantum+1,\n          sizeof(*blob));\n        if ((size_t) (i+count) >= extent)\n          break;\n      }\n      if (LocaleCompare(filename,\"-\") != 0)\n        file=close(file);\n      if (blob == (unsigned char *) NULL)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",filename);\n          return(NULL);\n        }\n      if (file == -1)\n        {\n          blob=(unsigned char *) RelinquishMagickMemory(blob);\n          ThrowFileException(exception,BlobError,\"UnableToReadBlob\",filename);\n          return(NULL);\n        }\n      *length=(size_t) MagickMin(i+count,extent);\n      blob[*length]='\\0';\n      return(blob);\n    }\n  *length=(size_t) MagickMin(offset,(MagickOffsetType)\n    MagickMin(extent,(size_t) SSIZE_MAX));\n  blob=(unsigned char *) NULL;\n  if (~(*length) >= (MagickPathExtent-1))\n    blob=(unsigned char *) AcquireQuantumMemory(*length+MagickPathExtent,\n      sizeof(*blob));\n  if (blob == (unsigned char *) NULL)\n    {\n      file=close(file);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",filename);\n      return(NULL);\n    }\n  map=MapBlob(file,ReadMode,0,*length);\n  if (map != (unsigned char *) NULL)\n    {\n      (void) memcpy(blob,map,*length);\n      (void) UnmapBlob(map,*length);\n    }\n  else\n    {\n      (void) lseek(file,0,SEEK_SET);\n      for (i=0; i < *length; i+=count)\n      {\n        count=read(file,blob+i,(size_t) MagickMin(*length-i,(size_t)\n          SSIZE_MAX));\n        if (count <= 0)\n          {\n            count=0;\n            if (errno != EINTR)\n              break;\n          }\n      }\n      if (i < *length)\n        {\n          file=close(file)-1;\n          blob=(unsigned char *) RelinquishMagickMemory(blob);\n          ThrowFileException(exception,BlobError,\"UnableToReadBlob\",filename);\n          return(NULL);\n        }\n    }\n  blob[*length]='\\0';\n  if (LocaleCompare(filename,\"-\") != 0)\n    file=close(file);\n  if (file == -1)\n    {\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n      ThrowFileException(exception,BlobError,\"UnableToReadBlob\",filename);\n    }\n  return(blob);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   F i l e T o I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FileToImage() write the contents of a file to an image.\n%\n%  The format of the FileToImage method is:\n%\n%      MagickBooleanType FileToImage(Image *,const char *filename)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o filename: the filename.\n%\n*/\n\nstatic inline ssize_t WriteBlobStream(Image *image,const size_t length,\n  const void *data)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  MagickSizeType\n    extent;\n\n  register unsigned char\n    *q;\n\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  assert(data != NULL);\n  blob_info=image->blob;\n  if (blob_info->type != BlobStream)\n    return(WriteBlob(image,length,(const unsigned char *) data));\n  extent=(MagickSizeType) (blob_info->offset+(MagickOffsetType) length);\n  if (extent >= blob_info->extent)\n    {\n      extent=blob_info->extent+blob_info->quantum+length;\n      blob_info->quantum<<=1;\n      if (SetBlobExtent(image,extent) == MagickFalse)\n        return(0);\n    }\n  q=blob_info->data+blob_info->offset;\n  (void) memcpy(q,data,length);\n  blob_info->offset+=length;\n  if (blob_info->offset >= (MagickOffsetType) blob_info->length)\n    blob_info->length=(size_t) blob_info->offset;\n  return((ssize_t) length);\n}\n\nMagickExport MagickBooleanType FileToImage(Image *image,const char *filename,\n  ExceptionInfo *exception)\n{\n  int\n    file;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length,\n    quantum;\n\n  ssize_t\n    count;\n\n  struct stat\n    file_stats;\n\n  unsigned char\n    *blob;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(filename != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  status=IsRightsAuthorized(PathPolicyDomain,WritePolicyRights,filename);\n  if (status == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",filename);\n      return(MagickFalse);\n    }\n  file=fileno(stdin);\n  if (LocaleCompare(filename,\"-\") != 0)\n    file=open_utf8(filename,O_RDONLY | O_BINARY,0);\n  if (file == -1)\n    {\n      ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n      return(MagickFalse);\n    }\n  quantum=(size_t) MagickMaxBufferExtent;\n  if ((fstat(file,&file_stats) == 0) && (file_stats.st_size > 0))\n    quantum=(size_t) MagickMin(file_stats.st_size,MagickMaxBufferExtent);\n  blob=(unsigned char *) AcquireQuantumMemory(quantum,sizeof(*blob));\n  if (blob == (unsigned char *) NULL)\n    {\n      file=close(file);\n      ThrowFileException(exception,ResourceLimitError,\"MemoryAllocationFailed\",\n        filename);\n      return(MagickFalse);\n    }\n  for ( ; ; )\n  {\n    count=read(file,blob,quantum);\n    if (count <= 0)\n      {\n        count=0;\n        if (errno != EINTR)\n          break;\n      }\n    length=(size_t) count;\n    count=WriteBlobStream(image,length,blob);\n    if (count != (ssize_t) length)\n      {\n        ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",filename);\n        break;\n      }\n  }\n  file=close(file);\n  if (file == -1)\n    ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",filename);\n  blob=(unsigned char *) RelinquishMagickMemory(blob);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t B l o b E r r o r                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetBlobError() returns MagickTrue if the blob associated with the specified\n%  image encountered an error.\n%\n%  The format of the GetBlobError method is:\n%\n%       MagickBooleanType GetBlobError(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType GetBlobError(const Image *image)\n{\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  return(image->blob->status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t B l o b F i l e H a n d l e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetBlobFileHandle() returns the file handle associated with the image blob.\n%\n%  The format of the GetBlobFile method is:\n%\n%      FILE *GetBlobFileHandle(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport FILE *GetBlobFileHandle(const Image *image)\n{\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  return(image->blob->file_info.file);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t B l o b I n f o                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetBlobInfo() initializes the BlobInfo structure.\n%\n%  The format of the GetBlobInfo method is:\n%\n%      void GetBlobInfo(BlobInfo *blob_info)\n%\n%  A description of each parameter follows:\n%\n%    o blob_info: Specifies a pointer to a BlobInfo structure.\n%\n*/\nMagickExport void GetBlobInfo(BlobInfo *blob_info)\n{\n  assert(blob_info != (BlobInfo *) NULL);\n  (void) memset(blob_info,0,sizeof(*blob_info));\n  blob_info->type=UndefinedStream;\n  blob_info->quantum=(size_t) MagickMaxBlobExtent;\n  blob_info->properties.st_mtime=GetMagickTime();\n  blob_info->properties.st_ctime=blob_info->properties.st_mtime;\n  blob_info->debug=IsEventLogging();\n  blob_info->reference_count=1;\n  blob_info->semaphore=AcquireSemaphoreInfo();\n  blob_info->signature=MagickCoreSignature;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  G e t B l o b P r o p e r t i e s                                          %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetBlobProperties() returns information about an image blob.\n%\n%  The format of the GetBlobProperties method is:\n%\n%      const struct stat *GetBlobProperties(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport const struct stat *GetBlobProperties(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  return(&image->blob->properties);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  G e t B l o b S i z e                                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetBlobSize() returns the current length of the image file or blob; zero is\n%  returned if the size cannot be determined.\n%\n%  The format of the GetBlobSize method is:\n%\n%      MagickSizeType GetBlobSize(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickSizeType GetBlobSize(const Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  MagickSizeType\n    extent;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->blob != (BlobInfo *) NULL);\n  blob_info=image->blob;\n  extent=0;\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n    {\n      extent=blob_info->size;\n      break;\n    }\n    case FileStream:\n    {\n      int\n        file_descriptor;\n\n      extent=(MagickSizeType) blob_info->properties.st_size;\n      if (extent == 0)\n        extent=blob_info->size;\n      file_descriptor=fileno(blob_info->file_info.file);\n      if (file_descriptor == -1)\n        break;\n      if (fstat(file_descriptor,&blob_info->properties) == 0)\n        extent=(MagickSizeType) blob_info->properties.st_size;\n      break;\n    }\n    case PipeStream:\n    {\n      extent=blob_info->size;\n      break;\n    }\n    case ZipStream:\n    case BZipStream:\n    {\n      MagickBooleanType\n        status;\n\n      status=GetPathAttributes(image->filename,&blob_info->properties);\n      if (status != MagickFalse)\n        extent=(MagickSizeType) blob_info->properties.st_size;\n      break;\n    }\n    case FifoStream:\n      break;\n    case BlobStream:\n    {\n      extent=(MagickSizeType) blob_info->length;\n      break;\n    }\n    case CustomStream:\n    {\n      if ((blob_info->custom_stream->teller != (CustomStreamTeller) NULL) &&\n          (blob_info->custom_stream->seeker != (CustomStreamSeeker) NULL))\n        {\n          MagickOffsetType\n            offset;\n\n          offset=blob_info->custom_stream->teller(\n            blob_info->custom_stream->data);\n          extent=(MagickSizeType) blob_info->custom_stream->seeker(0,SEEK_END,\n            blob_info->custom_stream->data);\n          (void) blob_info->custom_stream->seeker(offset,SEEK_SET,\n            blob_info->custom_stream->data);\n        }\n      break;\n    }\n  }\n  return(extent);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t B l o b S t r e a m D a t a                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetBlobStreamData() returns the stream data for the image.\n%\n%  The format of the GetBlobStreamData method is:\n%\n%      void *GetBlobStreamData(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void *GetBlobStreamData(const Image *image)\n{\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  return(image->blob->data);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t B l o b S t r e a m H a n d l e r                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetBlobStreamHandler() returns the stream handler for the image.\n%\n%  The format of the GetBlobStreamHandler method is:\n%\n%      StreamHandler GetBlobStreamHandler(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport StreamHandler GetBlobStreamHandler(const Image *image)\n{\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  return(image->blob->stream);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I m a g e T o B l o b                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ImageToBlob() implements direct to memory image formats.  It returns the\n%  image as a formatted blob and its length.  The magick member of the Image\n%  structure determines the format of the returned blob (GIF, JPEG, PNG,\n%  etc.).  This method is the equivalent of WriteImage(), but writes the\n%  formatted \"file\" to a memory buffer rather than to an actual file.\n%\n%  The format of the ImageToBlob method is:\n%\n%      void *ImageToBlob(const ImageInfo *image_info,Image *image,\n%        size_t *length,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n%    o length: return the actual length of the blob.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport void *ImageToBlob(const ImageInfo *image_info,\n  Image *image,size_t *length,ExceptionInfo *exception)\n{\n  const MagickInfo\n    *magick_info;\n\n  ImageInfo\n    *blob_info;\n\n  MagickBooleanType\n    status;\n\n  void\n    *blob;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  *length=0;\n  blob=(unsigned char *) NULL;\n  blob_info=CloneImageInfo(image_info);\n  blob_info->adjoin=MagickFalse;\n  (void) SetImageInfo(blob_info,1,exception);\n  if (*blob_info->magick != '\\0')\n    (void) CopyMagickString(image->magick,blob_info->magick,MagickPathExtent);\n  magick_info=GetMagickInfo(image->magick,exception);\n  if (magick_info == (const MagickInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        MissingDelegateError,\"NoDecodeDelegateForThisImageFormat\",\"`%s'\",\n        image->magick);\n      blob_info=DestroyImageInfo(blob_info);\n      return(blob);\n    }\n  (void) CopyMagickString(blob_info->magick,image->magick,MagickPathExtent);\n  if (GetMagickBlobSupport(magick_info) != MagickFalse)\n    {\n      /*\n        Native blob support for this image format.\n      */\n      blob_info->length=0;\n      blob_info->blob=AcquireQuantumMemory(MagickMaxBlobExtent,\n        sizeof(unsigned char));\n      if (blob_info->blob == NULL)\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      else\n        {\n          (void) CloseBlob(image);\n          image->blob->exempt=MagickTrue;\n          *image->filename='\\0';\n          status=WriteImage(blob_info,image,exception);\n          *length=image->blob->length;\n          blob=DetachBlob(image->blob);\n          if (blob == (void *) NULL)\n            blob_info->blob=RelinquishMagickMemory(blob_info->blob);\n          else if (status == MagickFalse)\n            blob=RelinquishMagickMemory(blob);\n          else\n            blob=ResizeQuantumMemory(blob,*length+1,sizeof(unsigned char));\n        }\n    }\n  else\n    {\n      char\n        unique[MagickPathExtent];\n\n      int\n        file;\n\n      /*\n        Write file to disk in blob image format.\n      */\n      file=AcquireUniqueFileResource(unique);\n      if (file == -1)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",\n            image_info->filename);\n        }\n      else\n        {\n          blob_info->file=fdopen(file,\"wb\");\n          if (blob_info->file != (FILE *) NULL)\n            {\n              (void) FormatLocaleString(image->filename,MagickPathExtent,\n                \"%s:%s\",image->magick,unique);\n              status=WriteImage(blob_info,image,exception);\n              (void) CloseBlob(image);\n              (void) fclose(blob_info->file);\n              if (status != MagickFalse)\n                blob=FileToBlob(unique,~0UL,length,exception);\n            }\n          (void) RelinquishUniqueFileResource(unique);\n        }\n    }\n  blob_info=DestroyImageInfo(blob_info);\n  return(blob);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  I m a g e T o C u s t o m S t r e a m                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ImageToCustomStream() is the equivalent of WriteImage(), but writes the\n%  formatted \"file\" to the custom stream rather than to an actual file.\n%\n%  The format of the ImageToCustomStream method is:\n%\n%      void ImageToCustomStream(const ImageInfo *image_info,Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport void ImageToCustomStream(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  const MagickInfo\n    *magick_info;\n\n  ImageInfo\n    *clone_info;\n\n  MagickBooleanType\n    blob_support,\n    status;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image_info->custom_stream != (CustomStreamInfo *) NULL);\n  assert(image_info->custom_stream->signature == MagickCoreSignature);\n  assert(image_info->custom_stream->writer != (CustomStreamHandler) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  clone_info=CloneImageInfo(image_info);\n  clone_info->adjoin=MagickFalse;\n  (void) SetImageInfo(clone_info,1,exception);\n  if (*clone_info->magick != '\\0')\n    (void) CopyMagickString(image->magick,clone_info->magick,MagickPathExtent);\n  magick_info=GetMagickInfo(image->magick,exception);\n  if (magick_info == (const MagickInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        MissingDelegateError,\"NoEncodeDelegateForThisImageFormat\",\"`%s'\",\n        image->magick);\n      clone_info=DestroyImageInfo(clone_info);\n      return;\n    }\n  (void) CopyMagickString(clone_info->magick,image->magick,MagickPathExtent);\n  blob_support=GetMagickBlobSupport(magick_info);\n  if ((blob_support != MagickFalse) &&\n      (GetMagickEncoderSeekableStream(magick_info) != MagickFalse))\n    {\n      if ((clone_info->custom_stream->seeker == (CustomStreamSeeker) NULL) ||\n          (clone_info->custom_stream->teller == (CustomStreamTeller) NULL))\n        blob_support=MagickFalse;\n    }\n  if (blob_support != MagickFalse)\n    {\n      /*\n        Native blob support for this image format.\n      */\n      (void) CloseBlob(image);\n      *image->filename='\\0';\n      (void) WriteImage(clone_info,image,exception);\n      (void) CloseBlob(image);\n    }\n  else\n    {\n      char\n        unique[MagickPathExtent];\n\n      int\n        file;\n\n      unsigned char\n        *blob;\n\n      /*\n        Write file to disk in blob image format.\n      */\n      clone_info->custom_stream=(CustomStreamInfo *) NULL;\n      blob=(unsigned char *) AcquireQuantumMemory(MagickMaxBufferExtent,\n        sizeof(*blob));\n      if (blob == (unsigned char *) NULL)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",\n            image_info->filename);\n          clone_info=DestroyImageInfo(clone_info);\n          return;\n        }\n      file=AcquireUniqueFileResource(unique);\n      if (file == -1)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",\n            image_info->filename);\n          blob=(unsigned char *) RelinquishMagickMemory(blob);\n          clone_info=DestroyImageInfo(clone_info);\n          return;\n        }\n      clone_info->file=fdopen(file,\"wb+\");\n      if (clone_info->file != (FILE *) NULL)\n        {\n          ssize_t\n            count;\n\n          (void) FormatLocaleString(image->filename,MagickPathExtent,\n            \"%s:%s\",image->magick,unique);\n          status=WriteImage(clone_info,image,exception);\n          (void) CloseBlob(image);\n          if (status != MagickFalse)\n            {\n              (void) fseek(clone_info->file,0,SEEK_SET);\n              count=(ssize_t) MagickMaxBufferExtent;\n              while (count == (ssize_t) MagickMaxBufferExtent)\n              {\n                count=(ssize_t) fread(blob,sizeof(*blob),MagickMaxBufferExtent,\n                  clone_info->file);\n                (void) image_info->custom_stream->writer(blob,(size_t) count,\n                  image_info->custom_stream->data);\n              }\n            }\n          (void) fclose(clone_info->file);\n        }\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n      (void) RelinquishUniqueFileResource(unique);\n    }\n  clone_info=DestroyImageInfo(clone_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I m a g e T o F i l e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ImageToFile() writes an image to a file.  It returns MagickFalse if an error\n%  occurs otherwise MagickTrue.\n%\n%  The format of the ImageToFile method is:\n%\n%       MagickBooleanType ImageToFile(Image *image,char *filename,\n%         ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o filename: Write the image to this file.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType ImageToFile(Image *image,char *filename,\n  ExceptionInfo *exception)\n{\n  int\n    file;\n\n  register const unsigned char\n    *p;\n\n  register size_t\n    i;\n\n  size_t\n    length,\n    quantum;\n\n  ssize_t\n    count;\n\n  struct stat\n    file_stats;\n\n  unsigned char\n    *buffer;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  assert(filename != (const char *) NULL);\n  if (*filename == '\\0')\n    file=AcquireUniqueFileResource(filename);\n  else\n    if (LocaleCompare(filename,\"-\") == 0)\n      file=fileno(stdout);\n    else\n      file=open_utf8(filename,O_RDWR | O_CREAT | O_EXCL | O_BINARY,S_MODE);\n  if (file == -1)\n    {\n      ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",filename);\n      return(MagickFalse);\n    }\n  quantum=(size_t) MagickMaxBufferExtent;\n  if ((fstat(file,&file_stats) == 0) && (file_stats.st_size > 0))\n    quantum=(size_t) MagickMin(file_stats.st_size,MagickMaxBufferExtent);\n  buffer=(unsigned char *) AcquireQuantumMemory(quantum,sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    {\n      file=close(file)-1;\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationError\",\"`%s'\",filename);\n      return(MagickFalse);\n    }\n  length=0;\n  p=(const unsigned char *) ReadBlobStream(image,quantum,buffer,&count);\n  for (i=0; count > 0; )\n  {\n    length=(size_t) count;\n    for (i=0; i < length; i+=count)\n    {\n      count=write(file,p+i,(size_t) (length-i));\n      if (count <= 0)\n        {\n          count=0;\n          if (errno != EINTR)\n            break;\n        }\n    }\n    if (i < length)\n      break;\n    p=(const unsigned char *) ReadBlobStream(image,quantum,buffer,&count);\n  }\n  if (LocaleCompare(filename,\"-\") != 0)\n    file=close(file);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  if ((file == -1) || (i < length))\n    {\n      if (file != -1)\n        file=close(file);\n      ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",filename);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I m a g e s T o B l o b                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ImagesToBlob() implements direct to memory image formats.  It returns the\n%  image sequence as a blob and its length.  The magick member of the ImageInfo\n%  structure determines the format of the returned blob (GIF, JPEG,  PNG, etc.)\n%\n%  Note, some image formats do not permit multiple images to the same image\n%  stream (e.g. JPEG).  in this instance, just the first image of the\n%  sequence is returned as a blob.\n%\n%  The format of the ImagesToBlob method is:\n%\n%      void *ImagesToBlob(const ImageInfo *image_info,Image *images,\n%        size_t *length,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o images: the image list.\n%\n%    o length: return the actual length of the blob.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport void *ImagesToBlob(const ImageInfo *image_info,Image *images,\n  size_t *length,ExceptionInfo *exception)\n{\n  const MagickInfo\n    *magick_info;\n\n  ImageInfo\n    *clone_info;\n\n  MagickBooleanType\n    status;\n\n  void\n    *blob;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  *length=0;\n  blob=(unsigned char *) NULL;\n  clone_info=CloneImageInfo(image_info);\n  (void) SetImageInfo(clone_info,(unsigned int) GetImageListLength(images),\n    exception);\n  if (*clone_info->magick != '\\0')\n    (void) CopyMagickString(images->magick,clone_info->magick,MagickPathExtent);\n  magick_info=GetMagickInfo(images->magick,exception);\n  if (magick_info == (const MagickInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        MissingDelegateError,\"NoDecodeDelegateForThisImageFormat\",\"`%s'\",\n        images->magick);\n      clone_info=DestroyImageInfo(clone_info);\n      return(blob);\n    }\n  if (GetMagickAdjoin(magick_info) == MagickFalse)\n    {\n      clone_info=DestroyImageInfo(clone_info);\n      return(ImageToBlob(image_info,images,length,exception));\n    }\n  (void) CopyMagickString(clone_info->magick,images->magick,MagickPathExtent);\n  if (GetMagickBlobSupport(magick_info) != MagickFalse)\n    {\n      /*\n        Native blob support for this images format.\n      */\n      clone_info->length=0;\n      clone_info->blob=(void *) AcquireQuantumMemory(MagickMaxBlobExtent,\n        sizeof(unsigned char));\n      if (clone_info->blob == (void *) NULL)\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",images->filename);\n      else\n        {\n          (void) CloseBlob(images);\n          images->blob->exempt=MagickTrue;\n          *images->filename='\\0';\n          status=WriteImages(clone_info,images,images->filename,exception);\n          *length=images->blob->length;\n          blob=DetachBlob(images->blob);\n          if (blob == (void *) NULL)\n            clone_info->blob=RelinquishMagickMemory(clone_info->blob);\n          else if (status == MagickFalse)\n            blob=RelinquishMagickMemory(blob);\n          else\n            blob=ResizeQuantumMemory(blob,*length+1,sizeof(unsigned char));\n        }\n    }\n  else\n    {\n      char\n        filename[MagickPathExtent],\n        unique[MagickPathExtent];\n\n      int\n        file;\n\n      /*\n        Write file to disk in blob images format.\n      */\n      file=AcquireUniqueFileResource(unique);\n      if (file == -1)\n        {\n          ThrowFileException(exception,FileOpenError,\"UnableToWriteBlob\",\n            image_info->filename);\n        }\n      else\n        {\n          clone_info->file=fdopen(file,\"wb\");\n          if (clone_info->file != (FILE *) NULL)\n            {\n              (void) FormatLocaleString(filename,MagickPathExtent,\"%s:%s\",\n                images->magick,unique);\n              status=WriteImages(clone_info,images,filename,exception);\n              (void) CloseBlob(images);\n              (void) fclose(clone_info->file);\n              if (status != MagickFalse)\n                blob=FileToBlob(unique,~0UL,length,exception);\n            }\n          (void) RelinquishUniqueFileResource(unique);\n        }\n    }\n  clone_info=DestroyImageInfo(clone_info);\n  return(blob);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  I m a g e s T o C u s t o m B l o b                                        %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ImagesToCustomStream() is the equivalent of WriteImages(), but writes the\n%  formatted \"file\" to the custom stream rather than to an actual file.\n%\n%  The format of the ImageToCustomStream method is:\n%\n%      void ImagesToCustomStream(const ImageInfo *image_info,Image *images,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o images: the image list.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport void ImagesToCustomStream(const ImageInfo *image_info,\n  Image *images,ExceptionInfo *exception)\n{\n  const MagickInfo\n    *magick_info;\n\n  ImageInfo\n    *clone_info;\n\n  MagickBooleanType\n    blob_support,\n    status;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  assert(image_info->custom_stream != (CustomStreamInfo *) NULL);\n  assert(image_info->custom_stream->signature == MagickCoreSignature);\n  assert(image_info->custom_stream->reader != (CustomStreamHandler) NULL);\n  assert(image_info->custom_stream->writer != (CustomStreamHandler) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  clone_info=CloneImageInfo(image_info);\n  (void) SetImageInfo(clone_info,(unsigned int) GetImageListLength(images),\n    exception);\n  if (*clone_info->magick != '\\0')\n    (void) CopyMagickString(images->magick,clone_info->magick,MagickPathExtent);\n  magick_info=GetMagickInfo(images->magick,exception);\n  if (magick_info == (const MagickInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        MissingDelegateError,\"NoEncodeDelegateForThisImageFormat\",\"`%s'\",\n        images->magick);\n      clone_info=DestroyImageInfo(clone_info);\n      return;\n    }\n  (void) CopyMagickString(clone_info->magick,images->magick,MagickPathExtent);\n  blob_support=GetMagickBlobSupport(magick_info);\n  if ((blob_support != MagickFalse) &&\n      (GetMagickEncoderSeekableStream(magick_info) != MagickFalse))\n    {\n      if ((clone_info->custom_stream->seeker == (CustomStreamSeeker) NULL) ||\n          (clone_info->custom_stream->teller == (CustomStreamTeller) NULL))\n        blob_support=MagickFalse;\n    }\n  if (blob_support != MagickFalse)\n    {\n      /*\n        Native blob support for this image format.\n      */\n      (void) CloseBlob(images);\n      *images->filename='\\0';\n      (void) WriteImages(clone_info,images,images->filename,exception);\n      (void) CloseBlob(images);\n    }\n  else\n    {\n      char\n        filename[MagickPathExtent],\n        unique[MagickPathExtent];\n\n      int\n        file;\n\n      unsigned char\n        *blob;\n\n      /*\n        Write file to disk in blob image format.\n      */\n      clone_info->custom_stream=(CustomStreamInfo *) NULL;\n      blob=(unsigned char *) AcquireQuantumMemory(MagickMaxBufferExtent,\n        sizeof(*blob));\n      if (blob == (unsigned char *) NULL)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",\n            image_info->filename);\n          clone_info=DestroyImageInfo(clone_info);\n          return;\n        }\n      file=AcquireUniqueFileResource(unique);\n      if (file == -1)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",\n            image_info->filename);\n          blob=(unsigned char *) RelinquishMagickMemory(blob);\n          clone_info=DestroyImageInfo(clone_info);\n          return;\n        }\n      clone_info->file=fdopen(file,\"wb+\");\n      if (clone_info->file != (FILE *) NULL)\n        {\n          ssize_t\n            count;\n\n          (void) FormatLocaleString(filename,MagickPathExtent,\"%s:%s\",\n            images->magick,unique);\n          status=WriteImages(clone_info,images,filename,exception);\n          (void) CloseBlob(images);\n          if (status != MagickFalse)\n            {\n              (void) fseek(clone_info->file,0,SEEK_SET);\n              count=(ssize_t) MagickMaxBufferExtent;\n              while (count == (ssize_t) MagickMaxBufferExtent)\n              {\n                count=(ssize_t) fread(blob,sizeof(*blob),MagickMaxBufferExtent,\n                  clone_info->file);\n                (void) image_info->custom_stream->writer(blob,(size_t) count,\n                  image_info->custom_stream->data);\n              }\n            }\n          (void) fclose(clone_info->file);\n        }\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n      (void) RelinquishUniqueFileResource(unique);\n    }\n  clone_info=DestroyImageInfo(clone_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I n j e c t I m a g e B l o b                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InjectImageBlob() injects the image with a copy of itself in the specified\n%  format (e.g. inject JPEG into a PDF image).\n%\n%  The format of the InjectImageBlob method is:\n%\n%      MagickBooleanType InjectImageBlob(const ImageInfo *image_info,\n%        Image *image,Image *inject_image,const char *format,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info..\n%\n%    o image: the image.\n%\n%    o inject_image: inject into the image stream.\n%\n%    o format: the image format.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType InjectImageBlob(const ImageInfo *image_info,\n  Image *image,Image *inject_image,const char *format,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *unique_file;\n\n  Image\n    *byte_image;\n\n  ImageInfo\n    *write_info;\n\n  int\n    file;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    quantum;\n\n  ssize_t\n    count;\n\n  struct stat\n    file_stats;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Write inject image to a temporary file.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(inject_image != (Image *) NULL);\n  assert(inject_image->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  unique_file=(FILE *) NULL;\n  file=AcquireUniqueFileResource(filename);\n  if (file != -1)\n    unique_file=fdopen(file,\"wb\");\n  if ((file == -1) || (unique_file == (FILE *) NULL))\n    {\n      (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  byte_image=CloneImage(inject_image,0,0,MagickFalse,exception);\n  if (byte_image == (Image *) NULL)\n    {\n      (void) fclose(unique_file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleString(byte_image->filename,MagickPathExtent,\"%s:%s\",\n    format,filename);\n  DestroyBlob(byte_image);\n  byte_image->blob=CloneBlobInfo((BlobInfo *) NULL);\n  write_info=CloneImageInfo(image_info);\n  SetImageInfoFile(write_info,unique_file);\n  status=WriteImage(write_info,byte_image,exception);\n  write_info=DestroyImageInfo(write_info);\n  byte_image=DestroyImage(byte_image);\n  (void) fclose(unique_file);\n  if (status == MagickFalse)\n    {\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  /*\n    Inject into image stream.\n  */\n  file=open_utf8(filename,O_RDONLY | O_BINARY,0);\n  if (file == -1)\n    {\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      return(MagickFalse);\n    }\n  quantum=(size_t) MagickMaxBufferExtent;\n  if ((fstat(file,&file_stats) == 0) && (file_stats.st_size > 0))\n    quantum=(size_t) MagickMin(file_stats.st_size,MagickMaxBufferExtent);\n  buffer=(unsigned char *) AcquireQuantumMemory(quantum,sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(filename);\n      file=close(file);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  for (i=0; ; i+=count)\n  {\n    count=read(file,buffer,quantum);\n    if (count <= 0)\n      {\n        count=0;\n        if (errno != EINTR)\n          break;\n      }\n    status=WriteBlobStream(image,(size_t) count,buffer) == count ? MagickTrue :\n      MagickFalse;\n  }\n  file=close(file);\n  if (file == -1)\n    ThrowFileException(exception,FileOpenError,\"UnableToWriteBlob\",filename);\n  (void) RelinquishUniqueFileResource(filename);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s B l o b E x e m p t                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsBlobExempt() returns true if the blob is exempt.\n%\n%  The format of the IsBlobExempt method is:\n%\n%       MagickBooleanType IsBlobExempt(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType IsBlobExempt(const Image *image)\n{\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  return(image->blob->exempt);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s B l o b S e e k a b l e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsBlobSeekable() returns true if the blob is seekable.\n%\n%  The format of the IsBlobSeekable method is:\n%\n%       MagickBooleanType IsBlobSeekable(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType IsBlobSeekable(const Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  blob_info=image->blob;\n  switch (blob_info->type)\n  {\n    case BlobStream:\n      return(MagickTrue);\n    case FileStream:\n    {\n      int\n        status;\n\n      if (blob_info->file_info.file == (FILE *) NULL)\n        return(MagickFalse);\n      status=fseek(blob_info->file_info.file,0,SEEK_CUR);\n      return(status == -1 ? MagickFalse : MagickTrue);\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      MagickOffsetType\n        offset;\n\n      if (blob_info->file_info.gzfile == (gzFile) NULL)\n        return(MagickFalse);\n      offset=gzseek(blob_info->file_info.gzfile,0,SEEK_CUR);\n      return(offset < 0 ? MagickFalse : MagickTrue);\n#else\n      break;\n#endif\n    }\n    case UndefinedStream:\n    case BZipStream:\n    case FifoStream:\n    case PipeStream:\n    case StandardStream:\n      break;\n    case CustomStream:\n    {\n      if ((blob_info->custom_stream->seeker != (CustomStreamSeeker) NULL) &&\n          (blob_info->custom_stream->teller != (CustomStreamTeller) NULL))\n        return(MagickTrue);\n      break;\n    }\n    default:\n      break;\n  }\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s B l o b T e m p o r a r y                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsBlobTemporary() returns true if the blob is temporary.\n%\n%  The format of the IsBlobTemporary method is:\n%\n%       MagickBooleanType IsBlobTemporary(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType IsBlobTemporary(const Image *image)\n{\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  return(image->blob->temporary);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  M a p B l o b                                                              %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MapBlob() creates a mapping from a file to a binary large object.\n%\n%  The format of the MapBlob method is:\n%\n%      void *MapBlob(int file,const MapMode mode,const MagickOffsetType offset,\n%        const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o file: map this file descriptor.\n%\n%    o mode: ReadMode, WriteMode, or IOMode.\n%\n%    o offset: starting at this offset within the file.\n%\n%    o length: the length of the mapping is returned in this pointer.\n%\n*/\nMagickExport void *MapBlob(int file,const MapMode mode,\n  const MagickOffsetType offset,const size_t length)\n{\n#if defined(MAGICKCORE_HAVE_MMAP)\n  int\n    flags,\n    protection;\n\n  void\n    *map;\n\n  /*\n    Map file.\n  */\n  flags=0;\n  if (file == -1)\n#if defined(MAP_ANONYMOUS)\n    flags|=MAP_ANONYMOUS;\n#else\n    return(NULL);\n#endif\n  switch (mode)\n  {\n    case ReadMode:\n    default:\n    {\n      protection=PROT_READ;\n      flags|=MAP_PRIVATE;\n      break;\n    }\n    case WriteMode:\n    {\n      protection=PROT_WRITE;\n      flags|=MAP_SHARED;\n      break;\n    }\n    case IOMode:\n    {\n      protection=PROT_READ | PROT_WRITE;\n      flags|=MAP_SHARED;\n      break;\n    }\n  }\n#if !defined(MAGICKCORE_HAVE_HUGEPAGES) || !defined(MAP_HUGETLB)\n  map=mmap((char *) NULL,length,protection,flags,file,offset);\n#else\n  map=mmap((char *) NULL,length,protection,flags | MAP_HUGETLB,file,offset);\n  if (map == MAP_FAILED)\n    map=mmap((char *) NULL,length,protection,flags,file,offset);\n#endif\n  if (map == MAP_FAILED)\n    return(NULL);\n  return(map);\n#else\n  (void) file;\n  (void) mode;\n  (void) offset;\n  (void) length;\n  return(NULL);\n#endif\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  M S B O r d e r L o n g                                                    %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MSBOrderLong() converts a least-significant byte first buffer of integers to\n%  most-significant byte first.\n%\n%  The format of the MSBOrderLong method is:\n%\n%      void MSBOrderLong(unsigned char *buffer,const size_t length)\n%\n%  A description of each parameter follows.\n%\n%   o  buffer:  Specifies a pointer to a buffer of integers.\n%\n%   o  length:  Specifies the length of the buffer.\n%\n*/\nMagickExport void MSBOrderLong(unsigned char *buffer,const size_t length)\n{\n  int\n    c;\n\n  register unsigned char\n    *p,\n    *q;\n\n  assert(buffer != (unsigned char *) NULL);\n  q=buffer+length;\n  while (buffer < q)\n  {\n    p=buffer+3;\n    c=(int) (*p);\n    *p=(*buffer);\n    *buffer++=(unsigned char) c;\n    p=buffer+1;\n    c=(int) (*p);\n    *p=(*buffer);\n    *buffer++=(unsigned char) c;\n    buffer+=2;\n  }\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  M S B O r d e r S h o r t                                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MSBOrderShort() converts a least-significant byte first buffer of integers\n%  to most-significant byte first.\n%\n%  The format of the MSBOrderShort method is:\n%\n%      void MSBOrderShort(unsigned char *p,const size_t length)\n%\n%  A description of each parameter follows.\n%\n%   o  p:  Specifies a pointer to a buffer of integers.\n%\n%   o  length:  Specifies the length of the buffer.\n%\n*/\nMagickExport void MSBOrderShort(unsigned char *p,const size_t length)\n{\n  int\n    c;\n\n  register unsigned char\n    *q;\n\n  assert(p != (unsigned char *) NULL);\n  q=p+length;\n  while (p < q)\n  {\n    c=(int) (*p);\n    *p=(*(p+1));\n    p++;\n    *p++=(unsigned char) c;\n  }\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   O p e n B l o b                                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  OpenBlob() opens a file associated with the image.  A file name of '-' sets\n%  the file to stdin for type 'r' and stdout for type 'w'.  If the filename\n%  suffix is '.gz' or '.Z', the image is decompressed for type 'r' and\n%  compressed for type 'w'.  If the filename prefix is '|', it is piped to or\n%  from a system command.\n%\n%  The format of the OpenBlob method is:\n%\n%       MagickBooleanType OpenBlob(const ImageInfo *image_info,Image *image,\n%        const BlobMode mode,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n%    o mode: the mode for opening the file.\n%\n*/\n\nstatic inline MagickBooleanType SetStreamBuffering(const ImageInfo *image_info,\n  Image *image)\n{\n  const char\n    *option;\n\n  int\n    status;\n\n  size_t\n    size;\n\n  size=16384;\n  option=GetImageOption(image_info,\"stream:buffer-size\");\n  if (option != (const char *) NULL)\n    size=StringToUnsignedLong(option);\n  status=setvbuf(image->blob->file_info.file,(char *) NULL,size == 0 ?\n    _IONBF : _IOFBF,size);\n  return(status == 0 ? MagickTrue : MagickFalse);\n}\n\nMagickExport MagickBooleanType OpenBlob(const ImageInfo *image_info,\n  Image *image,const BlobMode mode,ExceptionInfo *exception)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  char\n    extension[MagickPathExtent],\n    filename[MagickPathExtent];\n\n  const char\n    *type;\n\n  MagickBooleanType\n    status;\n\n  PolicyRights\n    rights;\n\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  blob_info=image->blob;\n  if (image_info->blob != (void *) NULL)\n    {\n      if (image_info->stream != (StreamHandler) NULL)\n        blob_info->stream=(StreamHandler) image_info->stream;\n      AttachBlob(blob_info,image_info->blob,image_info->length);\n      return(MagickTrue);\n    }\n  if ((image_info->custom_stream != (CustomStreamInfo *) NULL) &&\n      (*image->filename == '\\0'))\n    {\n      blob_info->type=CustomStream;\n      blob_info->custom_stream=image_info->custom_stream;\n      return(MagickTrue);\n    }\n  (void) DetachBlob(blob_info);\n  blob_info->mode=mode;\n  switch (mode)\n  {\n    default: type=\"r\"; break;\n    case ReadBlobMode: type=\"r\"; break;\n    case ReadBinaryBlobMode: type=\"rb\"; break;\n    case WriteBlobMode: type=\"w\"; break;\n    case WriteBinaryBlobMode: type=\"w+b\"; break;\n    case AppendBlobMode: type=\"a\"; break;\n    case AppendBinaryBlobMode: type=\"a+b\"; break;\n  }\n  if (*type != 'r')\n    blob_info->synchronize=image_info->synchronize;\n  if (image_info->stream != (StreamHandler) NULL)\n    {\n      blob_info->stream=image_info->stream;\n      if (*type == 'w')\n        {\n          blob_info->type=FifoStream;\n          return(MagickTrue);\n        }\n    }\n  /*\n    Open image file.\n  */\n  *filename='\\0';\n  (void) CopyMagickString(filename,image->filename,MagickPathExtent);\n  rights=ReadPolicyRights;\n  if (*type == 'w')\n    rights=WritePolicyRights;\n  if (IsRightsAuthorized(PathPolicyDomain,rights,filename) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",filename);\n      return(MagickFalse);\n    }\n  if ((LocaleCompare(filename,\"-\") == 0) ||\n      ((*filename == '\\0') && (image_info->file == (FILE *) NULL)))\n    {\n      blob_info->file_info.file=(*type == 'r') ? stdin : stdout;\n#if defined(MAGICKCORE_WINDOWS_SUPPORT) || defined(__OS2__)\n      if (strchr(type,'b') != (char *) NULL)\n        setmode(fileno(blob_info->file_info.file),_O_BINARY);\n#endif\n      blob_info->type=StandardStream;\n      blob_info->exempt=MagickTrue;\n      return(SetStreamBuffering(image_info,image));\n    }\n  if ((LocaleNCompare(filename,\"fd:\",3) == 0) &&\n      (IsGeometry(filename+3) != MagickFalse))\n    {\n      char\n        fileMode[MagickPathExtent];\n\n      *fileMode =(*type);\n      fileMode[1]='\\0';\n      blob_info->file_info.file=fdopen(StringToLong(filename+3),fileMode);\n      if (blob_info->file_info.file == (FILE *) NULL)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n          return(MagickFalse);\n        }\n#if defined(MAGICKCORE_WINDOWS_SUPPORT) || defined(__OS2__)\n      if (strchr(type,'b') != (char *) NULL)\n        setmode(fileno(blob_info->file_info.file),_O_BINARY);\n#endif\n      blob_info->type=FileStream;\n      blob_info->exempt=MagickTrue;\n      return(SetStreamBuffering(image_info,image));\n    }\n#if defined(MAGICKCORE_HAVE_POPEN) && defined(MAGICKCORE_PIPES_SUPPORT)\n  if (*filename == '|')\n    {\n      char\n        fileMode[MagickPathExtent],\n        *sanitize_command;\n\n      /*\n        Pipe image to or from a system command.\n      */\n#if defined(SIGPIPE)\n      if (*type == 'w')\n        (void) signal(SIGPIPE,SIG_IGN);\n#endif\n      *fileMode =(*type);\n      fileMode[1]='\\0';\n      sanitize_command=SanitizeString(filename+1);\n      blob_info->file_info.file=(FILE *) popen_utf8(sanitize_command,fileMode);\n      sanitize_command=DestroyString(sanitize_command);\n      if (blob_info->file_info.file == (FILE *) NULL)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n          return(MagickFalse);\n        }\n      blob_info->type=PipeStream;\n      blob_info->exempt=MagickTrue;\n      return(SetStreamBuffering(image_info,image));\n    }\n#endif\n  status=GetPathAttributes(filename,&blob_info->properties);\n#if defined(S_ISFIFO)\n  if ((status != MagickFalse) && S_ISFIFO(blob_info->properties.st_mode))\n    {\n      blob_info->file_info.file=(FILE *) fopen_utf8(filename,type);\n      if (blob_info->file_info.file == (FILE *) NULL)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n          return(MagickFalse);\n        }\n      blob_info->type=FileStream;\n      blob_info->exempt=MagickTrue;\n      return(SetStreamBuffering(image_info,image));\n    }\n#endif\n  GetPathComponent(image->filename,ExtensionPath,extension);\n  if (*type == 'w')\n    {\n      (void) CopyMagickString(filename,image->filename,MagickPathExtent);\n      if ((image_info->adjoin == MagickFalse) ||\n          (strchr(filename,'%') != (char *) NULL))\n        {\n          /*\n            Form filename for multi-part images.\n          */\n          (void) InterpretImageFilename(image_info,image,image->filename,(int)\n            image->scene,filename,exception);\n          if ((LocaleCompare(filename,image->filename) == 0) &&\n              ((GetPreviousImageInList(image) != (Image *) NULL) ||\n               (GetNextImageInList(image) != (Image *) NULL)))\n            {\n              char\n                path[MagickPathExtent];\n\n              GetPathComponent(image->filename,RootPath,path);\n              if (*extension == '\\0')\n                (void) FormatLocaleString(filename,MagickPathExtent,\"%s-%.20g\",\n                  path,(double) image->scene);\n              else\n                (void) FormatLocaleString(filename,MagickPathExtent,\n                  \"%s-%.20g.%s\",path,(double) image->scene,extension);\n            }\n          (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n#if defined(macintosh)\n          SetApplicationType(filename,image_info->magick,'8BIM');\n#endif\n        }\n    }\n  if (image_info->file != (FILE *) NULL)\n    {\n      blob_info->file_info.file=image_info->file;\n      blob_info->type=FileStream;\n      blob_info->exempt=MagickTrue;\n    }\n  else\n    if (*type == 'r')\n      {\n        blob_info->file_info.file=(FILE *) fopen_utf8(filename,type);\n        if (blob_info->file_info.file != (FILE *) NULL)\n          {\n            size_t\n              count;\n\n            unsigned char\n              magick[3];\n\n            blob_info->type=FileStream;\n            (void) SetStreamBuffering(image_info,image);\n            (void) memset(magick,0,sizeof(magick));\n            count=fread(magick,1,sizeof(magick),blob_info->file_info.file);\n            (void) fseek(blob_info->file_info.file,-((off_t) count),SEEK_CUR);\n#if defined(MAGICKCORE_POSIX_SUPPORT)\n            (void) fflush(blob_info->file_info.file);\n#endif\n            (void) LogMagickEvent(BlobEvent,GetMagickModule(),\n               \"  read %.20g magic header bytes\",(double) count);\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (((int) magick[0] == 0x1F) && ((int) magick[1] == 0x8B) &&\n                ((int) magick[2] == 0x08))\n              {\n                if (blob_info->file_info.file != (FILE *) NULL)\n                  (void) fclose(blob_info->file_info.file);\n                blob_info->file_info.file=(FILE *) NULL;\n                blob_info->file_info.gzfile=gzopen(filename,\"rb\");\n                if (blob_info->file_info.gzfile != (gzFile) NULL)\n                  blob_info->type=ZipStream;\n               }\n#endif\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n            if (strncmp((char *) magick,\"BZh\",3) == 0)\n              {\n                if (blob_info->file_info.file != (FILE *) NULL)\n                  (void) fclose(blob_info->file_info.file);\n                blob_info->file_info.file=(FILE *) NULL;\n                blob_info->file_info.bzfile=BZ2_bzopen(filename,\"r\");\n                if (blob_info->file_info.bzfile != (BZFILE *) NULL)\n                  blob_info->type=BZipStream;\n              }\n#endif\n            if (blob_info->type == FileStream)\n              {\n                const MagickInfo\n                  *magick_info;\n\n                ExceptionInfo\n                  *sans_exception;\n\n                size_t\n                  length;\n\n                sans_exception=AcquireExceptionInfo();\n                magick_info=GetMagickInfo(image_info->magick,sans_exception);\n                sans_exception=DestroyExceptionInfo(sans_exception);\n                length=(size_t) blob_info->properties.st_size;\n                if ((magick_info != (const MagickInfo *) NULL) &&\n                    (GetMagickBlobSupport(magick_info) != MagickFalse) &&\n                    (length > MagickMaxBufferExtent) &&\n                    (AcquireMagickResource(MapResource,length) != MagickFalse))\n                  {\n                    void\n                      *blob;\n\n                    blob=MapBlob(fileno(blob_info->file_info.file),ReadMode,0,\n                      length);\n                    if (blob == (void *) NULL)\n                      RelinquishMagickResource(MapResource,length);\n                    else\n                      {\n                        /*\n                          Format supports blobs-- use memory-mapped I/O.\n                        */\n                        if (image_info->file != (FILE *) NULL)\n                          blob_info->exempt=MagickFalse;\n                        else\n                          {\n                            (void) fclose(blob_info->file_info.file);\n                            blob_info->file_info.file=(FILE *) NULL;\n                          }\n                        AttachBlob(blob_info,blob,length);\n                        blob_info->mapped=MagickTrue;\n                      }\n                  }\n              }\n          }\n        }\n      else\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n        if ((LocaleCompare(extension,\"Z\") == 0) ||\n            (LocaleCompare(extension,\"gz\") == 0) ||\n            (LocaleCompare(extension,\"wmz\") == 0) ||\n            (LocaleCompare(extension,\"svgz\") == 0))\n          {\n            blob_info->file_info.gzfile=gzopen(filename,\"wb\");\n            if (blob_info->file_info.gzfile != (gzFile) NULL)\n              blob_info->type=ZipStream;\n          }\n        else\n#endif\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n          if (LocaleCompare(extension,\"bz2\") == 0)\n            {\n              blob_info->file_info.bzfile=BZ2_bzopen(filename,\"w\");\n              if (blob_info->file_info.bzfile != (BZFILE *) NULL)\n                blob_info->type=BZipStream;\n            }\n          else\n#endif\n            {\n              blob_info->file_info.file=(FILE *) fopen_utf8(filename,type);\n              if (blob_info->file_info.file != (FILE *) NULL)\n                {\n                  blob_info->type=FileStream;\n                  (void) SetStreamBuffering(image_info,image);\n                }\n       }\n  blob_info->status=MagickFalse;\n  if (blob_info->type != UndefinedStream)\n    blob_info->size=GetBlobSize(image);\n  else\n    {\n      ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   P i n g B l o b                                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PingBlob() returns all the attributes of an image or image sequence except\n%  for the pixels.  It is much faster and consumes far less memory than\n%  BlobToImage().  On failure, a NULL image is returned and exception\n%  describes the reason for the failure.\n%\n%  The format of the PingBlob method is:\n%\n%      Image *PingBlob(const ImageInfo *image_info,const void *blob,\n%        const size_t length,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o blob: the address of a character stream in one of the image formats\n%      understood by ImageMagick.\n%\n%    o length: This size_t integer reflects the length in bytes of the blob.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic size_t PingStream(const Image *magick_unused(image),\n  const void *magick_unused(pixels),const size_t columns)\n{\n  magick_unreferenced(image);\n  magick_unreferenced(pixels);\n  return(columns);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nMagickExport Image *PingBlob(const ImageInfo *image_info,const void *blob,\n  const size_t length,ExceptionInfo *exception)\n{\n  const MagickInfo\n    *magick_info;\n\n  Image\n    *image;\n\n  ImageInfo\n    *clone_info,\n    *ping_info;\n\n  MagickBooleanType\n    status;\n\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  if ((blob == (const void *) NULL) || (length == 0))\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),BlobError,\n        \"ZeroLengthBlobNotPermitted\",\"`%s'\",image_info->filename);\n      return((Image *) NULL);\n    }\n  ping_info=CloneImageInfo(image_info);\n  ping_info->blob=(void *) blob;\n  ping_info->length=length;\n  ping_info->ping=MagickTrue;\n  if (*ping_info->magick == '\\0')\n    (void) SetImageInfo(ping_info,0,exception);\n  magick_info=GetMagickInfo(ping_info->magick,exception);\n  if (magick_info == (const MagickInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        MissingDelegateError,\"NoDecodeDelegateForThisImageFormat\",\"`%s'\",\n        ping_info->magick);\n      ping_info=DestroyImageInfo(ping_info);\n      return((Image *) NULL);\n    }\n  if (GetMagickBlobSupport(magick_info) != MagickFalse)\n    {\n      char\n        filename[MagickPathExtent];\n\n      /*\n        Native blob support for this image format.\n      */\n      (void) CopyMagickString(filename,ping_info->filename,MagickPathExtent);\n      (void) FormatLocaleString(ping_info->filename,MagickPathExtent,\"%s:%s\",\n        ping_info->magick,filename);\n      image=ReadStream(ping_info,&PingStream,exception);\n      if (image != (Image *) NULL)\n        (void) DetachBlob(image->blob);\n      ping_info=DestroyImageInfo(ping_info);\n      return(image);\n    }\n  /*\n    Write blob to a temporary file on disk.\n  */\n  ping_info->blob=(void *) NULL;\n  ping_info->length=0;\n  *ping_info->filename='\\0';\n  status=BlobToFile(ping_info->filename,blob,length,exception);\n  if (status == MagickFalse)\n    {\n      (void) RelinquishUniqueFileResource(ping_info->filename);\n      ping_info=DestroyImageInfo(ping_info);\n      return((Image *) NULL);\n    }\n  clone_info=CloneImageInfo(ping_info);\n  (void) FormatLocaleString(clone_info->filename,MagickPathExtent,\"%s:%s\",\n    ping_info->magick,ping_info->filename);\n  image=ReadStream(clone_info,&PingStream,exception);\n  if (image != (Image *) NULL)\n    {\n      Image\n        *images;\n\n      /*\n        Restore original filenames and image format.\n      */\n      for (images=GetFirstImageInList(image); images != (Image *) NULL; )\n      {\n        (void) CopyMagickString(images->filename,image_info->filename,\n          MagickPathExtent);\n        (void) CopyMagickString(images->magick_filename,image_info->filename,\n          MagickPathExtent);\n        (void) CopyMagickString(images->magick,magick_info->name,\n          MagickPathExtent);\n        images=GetNextImageInList(images);\n      }\n    }\n  clone_info=DestroyImageInfo(clone_info);\n  (void) RelinquishUniqueFileResource(ping_info->filename);\n  ping_info=DestroyImageInfo(ping_info);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b                                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlob() reads data from the blob or image file and returns it.  It\n%  returns the number of bytes read. If length is zero, ReadBlob() returns\n%  zero and has no other results. If length is greater than SSIZE_MAX, the\n%  result is unspecified.\n%\n%  The format of the ReadBlob method is:\n%\n%      ssize_t ReadBlob(Image *image,const size_t length,void *data)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o length:  Specifies an integer representing the number of bytes to read\n%      from the file.\n%\n%    o data:  Specifies an area to place the information requested from the\n%      file.\n%\n*/\nMagickExport ssize_t ReadBlob(Image *image,const size_t length,void *data)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  int\n    c;\n\n  register unsigned char\n    *q;\n\n  ssize_t\n    count;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  if (length == 0)\n    return(0);\n  assert(data != (void *) NULL);\n  blob_info=image->blob;\n  count=0;\n  q=(unsigned char *) data;\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n      break;\n    case StandardStream:\n    case FileStream:\n    case PipeStream:\n    {\n      switch (length)\n      {\n        default:\n        {\n          count=(ssize_t) fread(q,1,length,blob_info->file_info.file);\n          break;\n        }\n        case 4:\n        {\n          c=getc(blob_info->file_info.file);\n          if (c == EOF)\n            break;\n          *q++=(unsigned char) c;\n          count++;\n        }\n        case 3:\n        {\n          c=getc(blob_info->file_info.file);\n          if (c == EOF)\n            break;\n          *q++=(unsigned char) c;\n          count++;\n        }\n        case 2:\n        {\n          c=getc(blob_info->file_info.file);\n          if (c == EOF)\n            break;\n          *q++=(unsigned char) c;\n          count++;\n        }\n        case 1:\n        {\n          c=getc(blob_info->file_info.file);\n          if (c == EOF)\n            break;\n          *q++=(unsigned char) c;\n          count++;\n        }\n        case 0:\n          break;\n      }\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      switch (length)\n      {\n        default:\n        {\n          register ssize_t\n            i;\n\n          for (i=0; i < (ssize_t) length; i+=count)\n          {\n            count=(ssize_t) gzread(blob_info->file_info.gzfile,q+i,\n              (unsigned int) MagickMin(length-i,MagickMaxBufferExtent));\n            if (count <= 0)\n              {\n                count=0;\n                if (errno != EINTR)\n                  break;\n              }\n          }\n          count=i;\n          break;\n        }\n        case 4:\n        {\n          c=gzgetc(blob_info->file_info.gzfile);\n          if (c == EOF)\n            break;\n          *q++=(unsigned char) c;\n          count++;\n        }\n        case 3:\n        {\n          c=gzgetc(blob_info->file_info.gzfile);\n          if (c == EOF)\n            break;\n          *q++=(unsigned char) c;\n          count++;\n        }\n        case 2:\n        {\n          c=gzgetc(blob_info->file_info.gzfile);\n          if (c == EOF)\n            break;\n          *q++=(unsigned char) c;\n          count++;\n        }\n        case 1:\n        {\n          c=gzgetc(blob_info->file_info.gzfile);\n          if (c == EOF)\n            break;\n          *q++=(unsigned char) c;\n          count++;\n        }\n        case 0:\n          break;\n      }\n#endif\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) length; i+=count)\n      {\n        count=(ssize_t) BZ2_bzread(blob_info->file_info.bzfile,q+i,\n          (unsigned int) MagickMin(length-i,MagickMaxBufferExtent));\n        if (count <= 0)\n          {\n            count=0;\n            if (errno != EINTR)\n              break;\n          }\n      }\n      count=i;\n#endif\n      break;\n    }\n    case FifoStream:\n      break;\n    case BlobStream:\n    {\n      register const unsigned char\n        *p;\n\n      if (blob_info->offset >= (MagickOffsetType) blob_info->length)\n        {\n          blob_info->eof=MagickTrue;\n          break;\n        }\n      p=blob_info->data+blob_info->offset;\n      count=(ssize_t) MagickMin((MagickOffsetType) length,(MagickOffsetType)\n        blob_info->length-blob_info->offset);\n      blob_info->offset+=count;\n      if (count != (ssize_t) length)\n        blob_info->eof=MagickTrue;\n      (void) memcpy(q,p,(size_t) count);\n      break;\n    }\n    case CustomStream:\n    {\n      if (blob_info->custom_stream->reader != (CustomStreamHandler) NULL)\n        count=blob_info->custom_stream->reader(q,length,\n          blob_info->custom_stream->data);\n      break;\n    }\n  }\n  return(count);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b B y t e                                                    %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobByte() reads a single byte from the image file and returns it.\n%\n%  The format of the ReadBlobByte method is:\n%\n%      int ReadBlobByte(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport int ReadBlobByte(Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  register const unsigned char\n    *p;\n\n  unsigned char\n    buffer[1];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  blob_info=image->blob;\n  switch (blob_info->type)\n  {\n    case StandardStream:\n    case FileStream:\n    case PipeStream:\n    {\n      int\n        c;\n\n      p=(const unsigned char *) buffer;\n      c=getc(blob_info->file_info.file);\n      if (c == EOF)\n        return(EOF);\n      *buffer=(unsigned char) c;\n      break;\n    }\n    default:\n    {\n      ssize_t\n        count;\n\n      p=(const unsigned char *) ReadBlobStream(image,1,buffer,&count);\n      if (count != 1)\n        return(EOF);\n      break;\n    }\n  }\n  return((int) (*p));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b D o u b l e                                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobDouble() reads a double value as a 64-bit quantity in the byte-order\n%  specified by the endian member of the image structure.\n%\n%  The format of the ReadBlobDouble method is:\n%\n%      double ReadBlobDouble(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport double ReadBlobDouble(Image *image)\n{\n  union\n  {\n    MagickSizeType\n      unsigned_value;\n\n    double\n      double_value;\n  } quantum;\n\n  quantum.double_value=0.0;\n  quantum.unsigned_value=ReadBlobLongLong(image);\n  return(quantum.double_value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b F l o a t                                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobFloat() reads a float value as a 32-bit quantity in the byte-order\n%  specified by the endian member of the image structure.\n%\n%  The format of the ReadBlobFloat method is:\n%\n%      float ReadBlobFloat(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport float ReadBlobFloat(Image *image)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    float\n      float_value;\n  } quantum;\n\n  quantum.float_value=0.0;\n  quantum.unsigned_value=ReadBlobLong(image);\n  return(quantum.float_value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b L o n g                                                    %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobLong() reads a unsigned int value as a 32-bit quantity in the\n%  byte-order specified by the endian member of the image structure.\n%\n%  The format of the ReadBlobLong method is:\n%\n%      unsigned int ReadBlobLong(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport unsigned int ReadBlobLong(Image *image)\n{\n  register const unsigned char\n    *p;\n\n  ssize_t\n    count;\n\n  unsigned char\n    buffer[4];\n\n  unsigned int\n    value;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  *buffer='\\0';\n  p=(const unsigned char *) ReadBlobStream(image,4,buffer,&count);\n  if (count != 4)\n    return(0UL);\n  if (image->endian == LSBEndian)\n    {\n      value=(unsigned int) (*p++);\n      value|=(unsigned int) (*p++) << 8;\n      value|=(unsigned int) (*p++) << 16;\n      value|=(unsigned int) (*p++) << 24;\n      return(value);\n    }\n  value=(unsigned int) (*p++) << 24;\n  value|=(unsigned int) (*p++) << 16;\n  value|=(unsigned int) (*p++) << 8;\n  value|=(unsigned int) (*p++);\n  return(value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b L o n g L o n g                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobLongLong() reads a long long value as a 64-bit quantity in the\n%  byte-order specified by the endian member of the image structure.\n%\n%  The format of the ReadBlobLongLong method is:\n%\n%      MagickSizeType ReadBlobLongLong(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickSizeType ReadBlobLongLong(Image *image)\n{\n  MagickSizeType\n    value;\n\n  register const unsigned char\n    *p;\n\n  ssize_t\n    count;\n\n  unsigned char\n    buffer[8];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  *buffer='\\0';\n  p=(const unsigned char *) ReadBlobStream(image,8,buffer,&count);\n  if (count != 8)\n    return(MagickULLConstant(0));\n  if (image->endian == LSBEndian)\n    {\n      value=(MagickSizeType) (*p++);\n      value|=(MagickSizeType) (*p++) << 8;\n      value|=(MagickSizeType) (*p++) << 16;\n      value|=(MagickSizeType) (*p++) << 24;\n      value|=(MagickSizeType) (*p++) << 32;\n      value|=(MagickSizeType) (*p++) << 40;\n      value|=(MagickSizeType) (*p++) << 48;\n      value|=(MagickSizeType) (*p++) << 56;\n      return(value);\n    }\n  value=(MagickSizeType) (*p++) << 56;\n  value|=(MagickSizeType) (*p++) << 48;\n  value|=(MagickSizeType) (*p++) << 40;\n  value|=(MagickSizeType) (*p++) << 32;\n  value|=(MagickSizeType) (*p++) << 24;\n  value|=(MagickSizeType) (*p++) << 16;\n  value|=(MagickSizeType) (*p++) << 8;\n  value|=(MagickSizeType) (*p++);\n  return(value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b S h o r t                                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobShort() reads a short value as a 16-bit quantity in the byte-order\n%  specified by the endian member of the image structure.\n%\n%  The format of the ReadBlobShort method is:\n%\n%      unsigned short ReadBlobShort(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport unsigned short ReadBlobShort(Image *image)\n{\n  register const unsigned char\n    *p;\n\n  register unsigned short\n    value;\n\n  ssize_t\n    count;\n\n  unsigned char\n    buffer[2];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  *buffer='\\0';\n  p=(const unsigned char *) ReadBlobStream(image,2,buffer,&count);\n  if (count != 2)\n    return((unsigned short) 0U);\n  if (image->endian == LSBEndian)\n    {\n      value=(unsigned short) (*p++);\n      value|=(unsigned short) (*p++) << 8;\n      return(value);\n    }\n  value=(unsigned short) ((unsigned short) (*p++) << 8);\n  value|=(unsigned short) (*p++);\n  return(value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b L S B L o n g                                              %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobLSBLong() reads a unsigned int value as a 32-bit quantity in\n%  least-significant byte first order.\n%\n%  The format of the ReadBlobLSBLong method is:\n%\n%      unsigned int ReadBlobLSBLong(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport unsigned int ReadBlobLSBLong(Image *image)\n{\n  register const unsigned char\n    *p;\n\n  register unsigned int\n    value;\n\n  ssize_t\n    count;\n\n  unsigned char\n    buffer[4];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  *buffer='\\0';\n  p=(const unsigned char *) ReadBlobStream(image,4,buffer,&count);\n  if (count != 4)\n    return(0U);\n  value=(unsigned int) (*p++);\n  value|=(unsigned int) (*p++) << 8;\n  value|=(unsigned int) (*p++) << 16;\n  value|=(unsigned int) (*p++) << 24;\n  return(value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b L S B S i g n e d L o n g                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobLSBSignedLong() reads a signed int value as a 32-bit quantity in\n%  least-significant byte first order.\n%\n%  The format of the ReadBlobLSBSignedLong method is:\n%\n%      signed int ReadBlobLSBSignedLong(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport signed int ReadBlobLSBSignedLong(Image *image)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  quantum.unsigned_value=ReadBlobLSBLong(image);\n  return(quantum.signed_value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b L S B S h o r t                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobLSBShort() reads a short value as a 16-bit quantity in\n%  least-significant byte first order.\n%\n%  The format of the ReadBlobLSBShort method is:\n%\n%      unsigned short ReadBlobLSBShort(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport unsigned short ReadBlobLSBShort(Image *image)\n{\n  register const unsigned char\n    *p;\n\n  register unsigned short\n    value;\n\n  ssize_t\n    count;\n\n  unsigned char\n    buffer[2];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  *buffer='\\0';\n  p=(const unsigned char *) ReadBlobStream(image,2,buffer,&count);\n  if (count != 2)\n    return((unsigned short) 0U);\n  value=(unsigned short) (*p++);\n  value|=(unsigned short) (*p++) << 8;\n  return(value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b L S B S i g n e d S h o r t                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobLSBSignedShort() reads a signed short value as a 16-bit quantity in\n%  least-significant byte-order.\n%\n%  The format of the ReadBlobLSBSignedShort method is:\n%\n%      signed short ReadBlobLSBSignedShort(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport signed short ReadBlobLSBSignedShort(Image *image)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  quantum.unsigned_value=ReadBlobLSBShort(image);\n  return(quantum.signed_value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b M S B L o n g                                              %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobMSBLong() reads a unsigned int value as a 32-bit quantity in\n%  most-significant byte first order.\n%\n%  The format of the ReadBlobMSBLong method is:\n%\n%      unsigned int ReadBlobMSBLong(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport unsigned int ReadBlobMSBLong(Image *image)\n{\n  register const unsigned char\n    *p;\n\n  register unsigned int\n    value;\n\n  ssize_t\n    count;\n\n  unsigned char\n    buffer[4];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  *buffer='\\0';\n  p=(const unsigned char *) ReadBlobStream(image,4,buffer,&count);\n  if (count != 4)\n    return(0UL);\n  value=(unsigned int) (*p++) << 24;\n  value|=(unsigned int) (*p++) << 16;\n  value|=(unsigned int) (*p++) << 8;\n  value|=(unsigned int) (*p++);\n  return(value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b M S B L o n g L o n g                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobMSBLongLong() reads a unsigned long long value as a 64-bit quantity\n%  in most-significant byte first order.\n%\n%  The format of the ReadBlobMSBLongLong method is:\n%\n%      unsigned int ReadBlobMSBLongLong(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickSizeType ReadBlobMSBLongLong(Image *image)\n{\n  register const unsigned char\n    *p;\n\n  register MagickSizeType\n    value;\n\n  ssize_t\n    count;\n\n  unsigned char\n    buffer[8];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  *buffer='\\0';\n  p=(const unsigned char *) ReadBlobStream(image,8,buffer,&count);\n  if (count != 8)\n    return(MagickULLConstant(0));\n  value=(MagickSizeType) (*p++) << 56;\n  value|=(MagickSizeType) (*p++) << 48;\n  value|=(MagickSizeType) (*p++) << 40;\n  value|=(MagickSizeType) (*p++) << 32;\n  value|=(MagickSizeType) (*p++) << 24;\n  value|=(MagickSizeType) (*p++) << 16;\n  value|=(MagickSizeType) (*p++) << 8;\n  value|=(MagickSizeType) (*p++);\n  return(value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b M S B S h o r t                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobMSBShort() reads a short value as a 16-bit quantity in\n%  most-significant byte first order.\n%\n%  The format of the ReadBlobMSBShort method is:\n%\n%      unsigned short ReadBlobMSBShort(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport unsigned short ReadBlobMSBShort(Image *image)\n{\n  register const unsigned char\n    *p;\n\n  register unsigned short\n    value;\n\n  ssize_t\n    count;\n\n  unsigned char\n    buffer[2];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  *buffer='\\0';\n  p=(const unsigned char *) ReadBlobStream(image,2,buffer,&count);\n  if (count != 2)\n    return((unsigned short) 0U);\n  value=(unsigned short) ((*p++) << 8);\n  value|=(unsigned short) (*p++);\n  return((unsigned short) (value & 0xffff));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b M S B S i g n e d L o n g                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobMSBSignedLong() reads a signed int value as a 32-bit quantity in\n%  most-significant byte-order.\n%\n%  The format of the ReadBlobMSBSignedLong method is:\n%\n%      signed int ReadBlobMSBSignedLong(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport signed int ReadBlobMSBSignedLong(Image *image)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  quantum.unsigned_value=ReadBlobMSBLong(image);\n  return(quantum.signed_value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b M S B S i g n e d S h o r t                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobMSBSignedShort() reads a signed short value as a 16-bit quantity in\n%  most-significant byte-order.\n%\n%  The format of the ReadBlobMSBSignedShort method is:\n%\n%      signed short ReadBlobMSBSignedShort(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport signed short ReadBlobMSBSignedShort(Image *image)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  quantum.unsigned_value=ReadBlobMSBShort(image);\n  return(quantum.signed_value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b S i g n e d L o n g                                        %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobSignedLong() reads a signed int value as a 32-bit quantity in the\n%  byte-order specified by the endian member of the image structure.\n%\n%  The format of the ReadBlobSignedLong method is:\n%\n%      signed int ReadBlobSignedLong(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport signed int ReadBlobSignedLong(Image *image)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  quantum.unsigned_value=ReadBlobLong(image);\n  return(quantum.signed_value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b S i g n e d S h o r t                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobSignedShort() reads a signed short value as a 16-bit quantity in the\n%  byte-order specified by the endian member of the image structure.\n%\n%  The format of the ReadBlobSignedShort method is:\n%\n%      signed short ReadBlobSignedShort(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport signed short ReadBlobSignedShort(Image *image)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  quantum.unsigned_value=ReadBlobShort(image);\n  return(quantum.signed_value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b S t r e a m                                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobStream() reads data from the blob or image file and returns it.  It\n%  returns a pointer to the data buffer you supply or to the image memory\n%  buffer if its supported (zero-copy). If length is zero, ReadBlobStream()\n%  returns a count of zero and has no other results. If length is greater than\n%  SSIZE_MAX, the result is unspecified.\n%\n%  The format of the ReadBlobStream method is:\n%\n%      const void *ReadBlobStream(Image *image,const size_t length,void *data,\n%        ssize_t *count)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o length:  Specifies an integer representing the number of bytes to read\n%      from the file.\n%\n%    o count: returns the number of bytes read.\n%\n%    o data:  Specifies an area to place the information requested from the\n%      file.\n%\n*/\nMagickExport const void *ReadBlobStream(Image *image,const size_t length,\n  void *data,ssize_t *count)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  assert(count != (ssize_t *) NULL);\n  blob_info=image->blob;\n  if (blob_info->type != BlobStream)\n    {\n      assert(data != NULL);\n      *count=ReadBlob(image,length,(unsigned char *) data);\n      return(data);\n    }\n  if (blob_info->offset >= (MagickOffsetType) blob_info->length)\n    {\n      *count=0;\n      blob_info->eof=MagickTrue;\n      return(data);\n    }\n  data=blob_info->data+blob_info->offset;\n  *count=(ssize_t) MagickMin((MagickOffsetType) length,(MagickOffsetType)\n    blob_info->length-blob_info->offset);\n  blob_info->offset+=(*count);\n  if (*count != (ssize_t) length)\n    blob_info->eof=MagickTrue;\n  return(data);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e a d B l o b S t r i n g                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobString() reads characters from a blob or file until a newline\n%  character is read or an end-of-file condition is encountered.\n%\n%  The format of the ReadBlobString method is:\n%\n%      char *ReadBlobString(Image *image,char *string)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o string: the address of a character buffer.\n%\n*/\nMagickExport char *ReadBlobString(Image *image,char *string)\n{\n  int\n    c;\n\n  register ssize_t\n    i;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  for (i=0; i < (MagickPathExtent-1L); i++)\n  {\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      {\n        if (i == 0)\n          return((char *) NULL);\n        break;\n      }\n    string[i]=c;\n    if (c == '\\n')\n      {\n        if ((i > 0) && (string[i-1] == '\\r'))\n          i--;\n        break;\n      }\n  }\n  string[i]='\\0';\n  return(string);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e f e r e n c e B l o b                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReferenceBlob() increments the reference count associated with the pixel\n%  blob returning a pointer to the blob.\n%\n%  The format of the ReferenceBlob method is:\n%\n%      BlobInfo ReferenceBlob(BlobInfo *blob_info)\n%\n%  A description of each parameter follows:\n%\n%    o blob_info: the blob_info.\n%\n*/\nMagickExport BlobInfo *ReferenceBlob(BlobInfo *blob)\n{\n  assert(blob != (BlobInfo *) NULL);\n  assert(blob->signature == MagickCoreSignature);\n  if (blob->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  LockSemaphoreInfo(blob->semaphore);\n  blob->reference_count++;\n  UnlockSemaphoreInfo(blob->semaphore);\n  return(blob);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  S e e k B l o b                                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SeekBlob() sets the offset in bytes from the beginning of a blob or file\n%  and returns the resulting offset.\n%\n%  The format of the SeekBlob method is:\n%\n%      MagickOffsetType SeekBlob(Image *image,const MagickOffsetType offset,\n%        const int whence)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o offset:  Specifies an integer representing the offset in bytes.\n%\n%    o whence:  Specifies an integer representing how the offset is\n%      treated relative to the beginning of the blob as follows:\n%\n%        SEEK_SET  Set position equal to offset bytes.\n%        SEEK_CUR  Set position to current location plus offset.\n%        SEEK_END  Set position to EOF plus offset.\n%\n*/\nMagickExport MagickOffsetType SeekBlob(Image *image,\n  const MagickOffsetType offset,const int whence)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  blob_info=image->blob;\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n      break;\n    case StandardStream:\n    case PipeStream:\n      return(-1);\n    case FileStream:\n    {\n      if ((offset < 0) && (whence == SEEK_SET))\n        return(-1);\n      if (fseek(blob_info->file_info.file,offset,whence) < 0)\n        return(-1);\n      blob_info->offset=TellBlob(image);\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      if (gzseek(blob_info->file_info.gzfile,offset,whence) < 0)\n        return(-1);\n#endif\n      blob_info->offset=TellBlob(image);\n      break;\n    }\n    case BZipStream:\n      return(-1);\n    case FifoStream:\n      return(-1);\n    case BlobStream:\n    {\n      switch (whence)\n      {\n        case SEEK_SET:\n        default:\n        {\n          if (offset < 0)\n            return(-1);\n          blob_info->offset=offset;\n          break;\n        }\n        case SEEK_CUR:\n        {\n          if (((offset > 0) && (blob_info->offset > (SSIZE_MAX-offset))) ||\n              ((offset < 0) && (blob_info->offset < (-SSIZE_MAX-offset))))\n            {\n              errno=EOVERFLOW;\n              return(-1);\n            }\n          if ((blob_info->offset+offset) < 0)\n            return(-1);\n          blob_info->offset+=offset;\n          break;\n        }\n        case SEEK_END:\n        {\n          if (((MagickOffsetType) blob_info->length+offset) < 0)\n            return(-1);\n          blob_info->offset=blob_info->length+offset;\n          break;\n        }\n      }\n      if (blob_info->offset < (MagickOffsetType) ((off_t) blob_info->length))\n        {\n          blob_info->eof=MagickFalse;\n          break;\n        }\n      if (blob_info->offset >= (MagickOffsetType) ((off_t) blob_info->extent))\n        return(-1);\n      break;\n    }\n    case CustomStream:\n    {\n      if (blob_info->custom_stream->seeker == (CustomStreamSeeker) NULL)\n        return(-1);\n      blob_info->offset=blob_info->custom_stream->seeker(offset,whence,\n        blob_info->custom_stream->data);\n      break;\n    }\n  }\n  return(blob_info->offset);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S e t B l o b E x e m p t                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetBlobExempt() sets the blob exempt status.\n%\n%  The format of the SetBlobExempt method is:\n%\n%      MagickBooleanType SetBlobExempt(const Image *image,\n%        const MagickBooleanType exempt)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exempt: Set to true if this blob is exempt from being closed.\n%\n*/\nMagickExport void SetBlobExempt(Image *image,const MagickBooleanType exempt)\n{\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  image->blob->exempt=exempt;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  S e t B l o b E x t e n t                                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetBlobExtent() ensures enough space is allocated for the blob.  If the\n%  method is successful, subsequent writes to bytes in the specified range are\n%  guaranteed not to fail.\n%\n%  The format of the SetBlobExtent method is:\n%\n%      MagickBooleanType SetBlobExtent(Image *image,const MagickSizeType extent)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o extent:  the blob maximum extent.\n%\n*/\nMagickExport MagickBooleanType SetBlobExtent(Image *image,\n  const MagickSizeType extent)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  blob_info=image->blob;\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n      break;\n    case StandardStream:\n      return(MagickFalse);\n    case FileStream:\n    {\n      MagickOffsetType\n        offset;\n\n      ssize_t\n        count;\n\n      if (extent != (MagickSizeType) ((off_t) extent))\n        return(MagickFalse);\n      offset=SeekBlob(image,0,SEEK_END);\n      if (offset < 0)\n        return(MagickFalse);\n      if ((MagickSizeType) offset >= extent)\n        break;\n      offset=SeekBlob(image,(MagickOffsetType) extent-1,SEEK_SET);\n      if (offset < 0)\n        break;\n      count=(ssize_t) fwrite((const unsigned char *) \"\",1,1,\n        blob_info->file_info.file);\n#if defined(MAGICKCORE_HAVE_POSIX_FALLOCATE)\n      if (blob_info->synchronize != MagickFalse)\n        {\n          int\n            file;\n\n          file=fileno(blob_info->file_info.file);\n          if ((file == -1) || (offset < 0))\n            return(MagickFalse);\n          (void) posix_fallocate(file,offset,extent-offset);\n        }\n#endif\n      offset=SeekBlob(image,offset,SEEK_SET);\n      if (count != 1)\n        return(MagickFalse);\n      break;\n    }\n    case PipeStream:\n    case ZipStream:\n      return(MagickFalse);\n    case BZipStream:\n      return(MagickFalse);\n    case FifoStream:\n      return(MagickFalse);\n    case BlobStream:\n    {\n      if (extent != (MagickSizeType) ((size_t) extent))\n        return(MagickFalse);\n      if (blob_info->mapped != MagickFalse)\n        {\n          MagickOffsetType\n            offset;\n\n          ssize_t\n            count;\n\n          (void) UnmapBlob(blob_info->data,blob_info->length);\n          RelinquishMagickResource(MapResource,blob_info->length);\n          if (extent != (MagickSizeType) ((off_t) extent))\n            return(MagickFalse);\n          offset=SeekBlob(image,0,SEEK_END);\n          if (offset < 0)\n            return(MagickFalse);\n          if ((MagickSizeType) offset >= extent)\n            break;\n          offset=SeekBlob(image,(MagickOffsetType) extent-1,SEEK_SET);\n          count=(ssize_t) fwrite((const unsigned char *) \"\",1,1,\n            blob_info->file_info.file);\n#if defined(MAGICKCORE_HAVE_POSIX_FALLOCATE)\n          if (blob_info->synchronize != MagickFalse)\n            {\n              int\n                file;\n\n              file=fileno(blob_info->file_info.file);\n              if ((file == -1) || (offset < 0))\n                return(MagickFalse);\n              (void) posix_fallocate(file,offset,extent-offset);\n            }\n#endif\n          offset=SeekBlob(image,offset,SEEK_SET);\n          if (count != 1)\n            return(MagickFalse);\n          (void) AcquireMagickResource(MapResource,extent);\n          blob_info->data=(unsigned char*) MapBlob(fileno(\n            blob_info->file_info.file),WriteMode,0,(size_t) extent);\n          blob_info->extent=(size_t) extent;\n          blob_info->length=(size_t) extent;\n          (void) SyncBlob(image);\n          break;\n        }\n      blob_info->extent=(size_t) extent;\n      blob_info->data=(unsigned char *) ResizeQuantumMemory(blob_info->data,\n        blob_info->extent+1,sizeof(*blob_info->data));\n      (void) SyncBlob(image);\n      if (blob_info->data == (unsigned char *) NULL)\n        {\n          (void) DetachBlob(blob_info);\n          return(MagickFalse);\n        }\n      break;\n    }\n    case CustomStream:\n      break;\n  }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  S e t C u s t o m S t r e a m D a t a                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetCustomStreamData() sets the stream info data member.\n%\n%  The format of the SetCustomStreamData method is:\n%\n%      void SetCustomStreamData(CustomStreamInfo *custom_stream,void *)\n%\n%  A description of each parameter follows:\n%\n%    o custom_stream: the custom stream info.\n%\n%    o data: an object containing information about the custom stream.\n%\n*/\nMagickExport void SetCustomStreamData(CustomStreamInfo *custom_stream,\n  void *data)\n{\n  assert(custom_stream != (CustomStreamInfo *) NULL);\n  assert(custom_stream->signature == MagickCoreSignature);\n  custom_stream->data=data;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  S e t C u s t o m S t r e a m R e a d e r                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetCustomStreamReader() sets the stream info reader member.\n%\n%  The format of the SetCustomStreamReader method is:\n%\n%      void SetCustomStreamReader(CustomStreamInfo *custom_stream,\n%        CustomStreamHandler reader)\n%\n%  A description of each parameter follows:\n%\n%    o custom_stream: the custom stream info.\n%\n%    o reader: a function to read from the stream.\n%\n*/\nMagickExport void SetCustomStreamReader(CustomStreamInfo *custom_stream,\n  CustomStreamHandler reader)\n{\n  assert(custom_stream != (CustomStreamInfo *) NULL);\n  assert(custom_stream->signature == MagickCoreSignature);\n  custom_stream->reader=reader;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  S e t C u s t o m S t r e a m S e e k e r                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetCustomStreamSeeker() sets the stream info seeker member.\n%\n%  The format of the SetCustomStreamReader method is:\n%\n%      void SetCustomStreamSeeker(CustomStreamInfo *custom_stream,\n%        CustomStreamSeeker seeker)\n%\n%  A description of each parameter follows:\n%\n%    o custom_stream: the custom stream info.\n%\n%    o seeker: a function to seek in the custom stream.\n%\n*/\nMagickExport void SetCustomStreamSeeker(CustomStreamInfo *custom_stream,\n  CustomStreamSeeker seeker)\n{\n  assert(custom_stream != (CustomStreamInfo *) NULL);\n  assert(custom_stream->signature == MagickCoreSignature);\n  custom_stream->seeker=seeker;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  S e t C u s t o m S t r e a m T e l l e r                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetCustomStreamTeller() sets the stream info teller member.\n%\n%  The format of the SetCustomStreamTeller method is:\n%\n%      void SetCustomStreamTeller(CustomStreamInfo *custom_stream,\n%        CustomStreamTeller *teller)\n%\n%  A description of each parameter follows:\n%\n%    o custom_stream: the custom stream info.\n%\n%    o teller: a function to set the position in the stream.\n%\n*/\nMagickExport void SetCustomStreamTeller(CustomStreamInfo *custom_stream,\n  CustomStreamTeller teller)\n{\n  assert(custom_stream != (CustomStreamInfo *) NULL);\n  assert(custom_stream->signature == MagickCoreSignature);\n  custom_stream->teller=teller;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  S e t C u s t o m S t r e a m W r i t e r                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetCustomStreamWriter() sets the stream info writer member.\n%\n%  The format of the SetCustomStreamWriter method is:\n%\n%      void SetCustomStreamWriter(CustomStreamInfo *custom_stream,\n%        CustomStreamHandler *writer)\n%\n%  A description of each parameter follows:\n%\n%    o custom_stream: the custom stream info.\n%\n%    o writer: a function to write to the custom stream.\n%\n*/\nMagickExport void SetCustomStreamWriter(CustomStreamInfo *custom_stream,\n  CustomStreamHandler writer)\n{\n  assert(custom_stream != (CustomStreamInfo *) NULL);\n  assert(custom_stream->signature == MagickCoreSignature);\n  custom_stream->writer=writer;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  S y n c B l o b                                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncBlob() flushes the datastream if it is a file or synchronizes the data\n%  attributes if it is an blob.\n%\n%  The format of the SyncBlob method is:\n%\n%      int SyncBlob(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nstatic int SyncBlob(Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  int\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  blob_info=image->blob;\n  status=0;\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    case PipeStream:\n    {\n      status=fflush(blob_info->file_info.file);\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      status=gzflush(blob_info->file_info.gzfile,Z_SYNC_FLUSH);\n#endif\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      status=BZ2_bzflush(blob_info->file_info.bzfile);\n#endif\n      break;\n    }\n    case FifoStream:\n      break;\n    case BlobStream:\n      break;\n    case CustomStream:\n      break;\n  }\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  T e l l B l o b                                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TellBlob() obtains the current value of the blob or file position.\n%\n%  The format of the TellBlob method is:\n%\n%      MagickOffsetType TellBlob(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickOffsetType TellBlob(const Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  MagickOffsetType\n    offset;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  blob_info=image->blob;\n  offset=(-1);\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    {\n      offset=ftell(blob_info->file_info.file);\n      break;\n    }\n    case PipeStream:\n      break;\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      offset=(MagickOffsetType) gztell(blob_info->file_info.gzfile);\n#endif\n      break;\n    }\n    case BZipStream:\n      break;\n    case FifoStream:\n      break;\n    case BlobStream:\n    {\n      offset=blob_info->offset;\n      break;\n    }\n    case CustomStream:\n    {\n      if (blob_info->custom_stream->teller != (CustomStreamTeller) NULL)\n        offset=blob_info->custom_stream->teller(blob_info->custom_stream->data);\n      break;\n    }\n  }\n  return(offset);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  U n m a p B l o b                                                          %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnmapBlob() deallocates the binary large object previously allocated with\n%  the MapBlob method.\n%\n%  The format of the UnmapBlob method is:\n%\n%       MagickBooleanType UnmapBlob(void *map,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o map: the address  of the binary large object.\n%\n%    o length: the length of the binary large object.\n%\n*/\nMagickExport MagickBooleanType UnmapBlob(void *map,const size_t length)\n{\n#if defined(MAGICKCORE_HAVE_MMAP)\n  int\n    status;\n\n  status=munmap(map,length);\n  return(status == -1 ? MagickFalse : MagickTrue);\n#else\n  (void) map;\n  (void) length;\n  return(MagickFalse);\n#endif\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  W r i t e B l o b                                                          %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlob() writes data to a blob or image file.  It returns the number of\n%  bytes written.\n%\n%  The format of the WriteBlob method is:\n%\n%      ssize_t WriteBlob(Image *image,const size_t length,const void *data)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o length:  Specifies an integer representing the number of bytes to\n%      write to the file.\n%\n%    o data:  The address of the data to write to the blob or file.\n%\n*/\nMagickExport ssize_t WriteBlob(Image *image,const size_t length,\n  const void *data)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  int\n    c;\n\n  register const unsigned char\n    *p;\n\n  register unsigned char\n    *q;\n\n  ssize_t\n    count;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  if (length == 0)\n    return(0);\n  assert(data != (const void *) NULL);\n  blob_info=image->blob;\n  count=0;\n  p=(const unsigned char *) data;\n  q=(unsigned char *) data;\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n      break;\n    case StandardStream:\n    case FileStream:\n    case PipeStream:\n    {\n      switch (length)\n      {\n        default:\n        {\n          count=(ssize_t) fwrite((const char *) data,1,length,\n            blob_info->file_info.file);\n          break;\n        }\n        case 4:\n        {\n          c=putc((int) *p++,blob_info->file_info.file);\n          if (c == EOF)\n            break;\n          count++;\n        }\n        case 3:\n        {\n          c=putc((int) *p++,blob_info->file_info.file);\n          if (c == EOF)\n            break;\n          count++;\n        }\n        case 2:\n        {\n          c=putc((int) *p++,blob_info->file_info.file);\n          if (c == EOF)\n            break;\n          count++;\n        }\n        case 1:\n        {\n          c=putc((int) *p++,blob_info->file_info.file);\n          if (c == EOF)\n            break;\n          count++;\n        }\n        case 0:\n          break;\n      }\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      switch (length)\n      {\n        default:\n        {\n          register ssize_t\n            i;\n\n          for (i=0; i < (ssize_t) length; i+=count)\n          {\n            count=(ssize_t) gzwrite(blob_info->file_info.gzfile,q+i,\n              (unsigned int) MagickMin(length-i,MagickMaxBufferExtent));\n            if (count <= 0)\n              {\n                count=0;\n                if (errno != EINTR)\n                  break;\n              }\n          }\n          count=i;\n          break;\n        }\n        case 4:\n        {\n          c=gzputc(blob_info->file_info.gzfile,(int) *p++);\n          if (c == EOF)\n            break;\n          count++;\n        }\n        case 3:\n        {\n          c=gzputc(blob_info->file_info.gzfile,(int) *p++);\n          if (c == EOF)\n            break;\n          count++;\n        }\n        case 2:\n        {\n          c=gzputc(blob_info->file_info.gzfile,(int) *p++);\n          if (c == EOF)\n            break;\n          count++;\n        }\n        case 1:\n        {\n          c=gzputc(blob_info->file_info.gzfile,(int) *p++);\n          if (c == EOF)\n            break;\n          count++;\n        }\n        case 0:\n          break;\n      }\n#endif\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) length; i+=count)\n      {\n        count=(ssize_t) BZ2_bzwrite(blob_info->file_info.bzfile,q+i,\n          (int) MagickMin(length-i,MagickMaxBufferExtent));\n        if (count <= 0)\n          {\n            count=0;\n            if (errno != EINTR)\n              break;\n          }\n      }\n      count=i;\n#endif\n      break;\n    }\n    case FifoStream:\n    {\n      count=(ssize_t) blob_info->stream(image,data,length);\n      break;\n    }\n    case BlobStream:\n    {\n      if ((blob_info->offset+(MagickOffsetType) length) >=\n          (MagickOffsetType) blob_info->extent)\n        {\n          if (blob_info->mapped != MagickFalse)\n            return(0);\n          blob_info->extent+=length+blob_info->quantum;\n          blob_info->quantum<<=1;\n          blob_info->data=(unsigned char *) ResizeQuantumMemory(\n            blob_info->data,blob_info->extent+1,sizeof(*blob_info->data));\n          (void) SyncBlob(image);\n          if (blob_info->data == (unsigned char *) NULL)\n            {\n              (void) DetachBlob(blob_info);\n              return(0);\n            }\n        }\n      q=blob_info->data+blob_info->offset;\n      (void) memcpy(q,p,length);\n      blob_info->offset+=length;\n      if (blob_info->offset >= (MagickOffsetType) blob_info->length)\n        blob_info->length=(size_t) blob_info->offset;\n      count=(ssize_t) length;\n      break;\n    }\n    case CustomStream:\n    {\n      if (blob_info->custom_stream->writer != (CustomStreamHandler) NULL)\n        count=blob_info->custom_stream->writer((unsigned char *) data,\n          length,blob_info->custom_stream->data);\n      break;\n    }\n  }\n  return(count);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  W r i t e B l o b B y t e                                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobByte() write an integer to a blob.  It returns the number of bytes\n%  written (either 0 or 1);\n%\n%  The format of the WriteBlobByte method is:\n%\n%      ssize_t WriteBlobByte(Image *image,const unsigned char value)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o value: Specifies the value to write.\n%\n*/\nMagickExport ssize_t WriteBlobByte(Image *image,const unsigned char value)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  ssize_t\n    count;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  blob_info=image->blob;\n  count=0;\n  switch (blob_info->type)\n  {\n    case StandardStream:\n    case FileStream:\n    case PipeStream:\n    {\n      int\n        c;\n\n      c=putc((int) value,blob_info->file_info.file);\n      if (c == EOF)\n        break;\n      count++;\n      break;\n    }\n    default:\n    {\n      count=WriteBlobStream(image,1,&value);\n      break;\n    }\n  }\n  return(count);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  W r i t e B l o b F l o a t                                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobFloat() writes a float value as a 32-bit quantity in the byte-order\n%  specified by the endian member of the image structure.\n%\n%  The format of the WriteBlobFloat method is:\n%\n%      ssize_t WriteBlobFloat(Image *image,const float value)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o value: Specifies the value to write.\n%\n*/\nMagickExport ssize_t WriteBlobFloat(Image *image,const float value)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    float\n      float_value;\n  } quantum;\n\n  quantum.unsigned_value=0U;\n  quantum.float_value=value;\n  return(WriteBlobLong(image,quantum.unsigned_value));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  W r i t e B l o b L o n g                                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobLong() writes a unsigned int value as a 32-bit quantity in the\n%  byte-order specified by the endian member of the image structure.\n%\n%  The format of the WriteBlobLong method is:\n%\n%      ssize_t WriteBlobLong(Image *image,const unsigned int value)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o value: Specifies the value to write.\n%\n*/\nMagickExport ssize_t WriteBlobLong(Image *image,const unsigned int value)\n{\n  unsigned char\n    buffer[4];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->endian == LSBEndian)\n    {\n      buffer[0]=(unsigned char) value;\n      buffer[1]=(unsigned char) (value >> 8);\n      buffer[2]=(unsigned char) (value >> 16);\n      buffer[3]=(unsigned char) (value >> 24);\n      return(WriteBlobStream(image,4,buffer));\n    }\n  buffer[0]=(unsigned char) (value >> 24);\n  buffer[1]=(unsigned char) (value >> 16);\n  buffer[2]=(unsigned char) (value >> 8);\n  buffer[3]=(unsigned char) value;\n  return(WriteBlobStream(image,4,buffer));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  W r i t e B l o b L o n g L o n g                                          %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobMSBLongLong() writes a long long value as a 64-bit quantity in the\n%  byte-order specified by the endian member of the image structure.\n%\n%  The format of the WriteBlobLongLong method is:\n%\n%      ssize_t WriteBlobLongLong(Image *image,const MagickSizeType value)\n%\n%  A description of each parameter follows.\n%\n%    o value:  Specifies the value to write.\n%\n%    o image: the image.\n%\n*/\nMagickExport ssize_t WriteBlobLongLong(Image *image,const MagickSizeType value)\n{\n  unsigned char\n    buffer[8];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->endian == LSBEndian)\n    {\n      buffer[0]=(unsigned char) value;\n      buffer[1]=(unsigned char) (value >> 8);\n      buffer[2]=(unsigned char) (value >> 16);\n      buffer[3]=(unsigned char) (value >> 24);\n      buffer[4]=(unsigned char) (value >> 32);\n      buffer[5]=(unsigned char) (value >> 40);\n      buffer[6]=(unsigned char) (value >> 48);\n      buffer[7]=(unsigned char) (value >> 56);\n      return(WriteBlobStream(image,8,buffer));\n    }\n  buffer[0]=(unsigned char) (value >> 56);\n  buffer[1]=(unsigned char) (value >> 48);\n  buffer[2]=(unsigned char) (value >> 40);\n  buffer[3]=(unsigned char) (value >> 32);\n  buffer[4]=(unsigned char) (value >> 24);\n  buffer[5]=(unsigned char) (value >> 16);\n  buffer[6]=(unsigned char) (value >> 8);\n  buffer[7]=(unsigned char) value;\n  return(WriteBlobStream(image,8,buffer));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   W r i t e B l o b S h o r t                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobShort() writes a short value as a 16-bit quantity in the\n%  byte-order specified by the endian member of the image structure.\n%\n%  The format of the WriteBlobShort method is:\n%\n%      ssize_t WriteBlobShort(Image *image,const unsigned short value)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o value:  Specifies the value to write.\n%\n*/\nMagickExport ssize_t WriteBlobShort(Image *image,const unsigned short value)\n{\n  unsigned char\n    buffer[2];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->endian == LSBEndian)\n    {\n      buffer[0]=(unsigned char) value;\n      buffer[1]=(unsigned char) (value >> 8);\n      return(WriteBlobStream(image,2,buffer));\n    }\n  buffer[0]=(unsigned char) (value >> 8);\n  buffer[1]=(unsigned char) value;\n  return(WriteBlobStream(image,2,buffer));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  W r i t e B l o b S i g n e d L o n g                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobSignedLong() writes a signed value as a 32-bit quantity in the\n%  byte-order specified by the endian member of the image structure.\n%\n%  The format of the WriteBlobSignedLong method is:\n%\n%      ssize_t WriteBlobSignedLong(Image *image,const signed int value)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o value: Specifies the value to write.\n%\n*/\nMagickExport ssize_t WriteBlobSignedLong(Image *image,const signed int value)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  unsigned char\n    buffer[4];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  quantum.signed_value=value;\n  if (image->endian == LSBEndian)\n    {\n      buffer[0]=(unsigned char) quantum.unsigned_value;\n      buffer[1]=(unsigned char) (quantum.unsigned_value >> 8);\n      buffer[2]=(unsigned char) (quantum.unsigned_value >> 16);\n      buffer[3]=(unsigned char) (quantum.unsigned_value >> 24);\n      return(WriteBlobStream(image,4,buffer));\n    }\n  buffer[0]=(unsigned char) (quantum.unsigned_value >> 24);\n  buffer[1]=(unsigned char) (quantum.unsigned_value >> 16);\n  buffer[2]=(unsigned char) (quantum.unsigned_value >> 8);\n  buffer[3]=(unsigned char) quantum.unsigned_value;\n  return(WriteBlobStream(image,4,buffer));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  W r i t e B l o b L S B L o n g                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobLSBLong() writes a unsigned int value as a 32-bit quantity in\n%  least-significant byte first order.\n%\n%  The format of the WriteBlobLSBLong method is:\n%\n%      ssize_t WriteBlobLSBLong(Image *image,const unsigned int value)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o value: Specifies the value to write.\n%\n*/\nMagickExport ssize_t WriteBlobLSBLong(Image *image,const unsigned int value)\n{\n  unsigned char\n    buffer[4];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  buffer[0]=(unsigned char) value;\n  buffer[1]=(unsigned char) (value >> 8);\n  buffer[2]=(unsigned char) (value >> 16);\n  buffer[3]=(unsigned char) (value >> 24);\n  return(WriteBlobStream(image,4,buffer));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   W r i t e B l o b L S B S h o r t                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobLSBShort() writes a unsigned short value as a 16-bit quantity in\n%  least-significant byte first order.\n%\n%  The format of the WriteBlobLSBShort method is:\n%\n%      ssize_t WriteBlobLSBShort(Image *image,const unsigned short value)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o value:  Specifies the value to write.\n%\n*/\nMagickExport ssize_t WriteBlobLSBShort(Image *image,const unsigned short value)\n{\n  unsigned char\n    buffer[2];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  buffer[0]=(unsigned char) value;\n  buffer[1]=(unsigned char) (value >> 8);\n  return(WriteBlobStream(image,2,buffer));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  W r i t e B l o b L S B S i g n e d L o n g                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobLSBSignedLong() writes a signed value as a 32-bit quantity in\n%  least-significant byte first order.\n%\n%  The format of the WriteBlobLSBSignedLong method is:\n%\n%      ssize_t WriteBlobLSBSignedLong(Image *image,const signed int value)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o value: Specifies the value to write.\n%\n*/\nMagickExport ssize_t WriteBlobLSBSignedLong(Image *image,const signed int value)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  unsigned char\n    buffer[4];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  quantum.signed_value=value;\n  buffer[0]=(unsigned char) quantum.unsigned_value;\n  buffer[1]=(unsigned char) (quantum.unsigned_value >> 8);\n  buffer[2]=(unsigned char) (quantum.unsigned_value >> 16);\n  buffer[3]=(unsigned char) (quantum.unsigned_value >> 24);\n  return(WriteBlobStream(image,4,buffer));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   W r i t e B l o b L S B S i g n e d S h o r t                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobLSBSignedShort() writes a signed short value as a 16-bit quantity\n%  in least-significant byte first order.\n%\n%  The format of the WriteBlobLSBSignedShort method is:\n%\n%      ssize_t WriteBlobLSBSignedShort(Image *image,const signed short value)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o value:  Specifies the value to write.\n%\n*/\nMagickExport ssize_t WriteBlobLSBSignedShort(Image *image,\n  const signed short value)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  unsigned char\n    buffer[2];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  quantum.signed_value=value;\n  buffer[0]=(unsigned char) quantum.unsigned_value;\n  buffer[1]=(unsigned char) (quantum.unsigned_value >> 8);\n  return(WriteBlobStream(image,2,buffer));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  W r i t e B l o b M S B L o n g                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobMSBLong() writes a unsigned int value as a 32-bit quantity in\n%  most-significant byte first order.\n%\n%  The format of the WriteBlobMSBLong method is:\n%\n%      ssize_t WriteBlobMSBLong(Image *image,const unsigned int value)\n%\n%  A description of each parameter follows.\n%\n%    o value:  Specifies the value to write.\n%\n%    o image: the image.\n%\n*/\nMagickExport ssize_t WriteBlobMSBLong(Image *image,const unsigned int value)\n{\n  unsigned char\n    buffer[4];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  buffer[0]=(unsigned char) (value >> 24);\n  buffer[1]=(unsigned char) (value >> 16);\n  buffer[2]=(unsigned char) (value >> 8);\n  buffer[3]=(unsigned char) value;\n  return(WriteBlobStream(image,4,buffer));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   W r i t e B l o b M S B S i g n e d S h o r t                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobMSBSignedShort() writes a signed short value as a 16-bit quantity\n%  in most-significant byte first order.\n%\n%  The format of the WriteBlobMSBSignedShort method is:\n%\n%      ssize_t WriteBlobMSBSignedShort(Image *image,const signed short value)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o value:  Specifies the value to write.\n%\n*/\nMagickExport ssize_t WriteBlobMSBSignedShort(Image *image,\n  const signed short value)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  unsigned char\n    buffer[2];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  quantum.signed_value=value;\n  buffer[0]=(unsigned char) (quantum.unsigned_value >> 8);\n  buffer[1]=(unsigned char) quantum.unsigned_value;\n  return(WriteBlobStream(image,2,buffer));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  W r i t e B l o b M S B S h o r t                                          %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobMSBShort() writes a unsigned short value as a 16-bit quantity in\n%  most-significant byte first order.\n%\n%  The format of the WriteBlobMSBShort method is:\n%\n%      ssize_t WriteBlobMSBShort(Image *image,const unsigned short value)\n%\n%  A description of each parameter follows.\n%\n%   o  value:  Specifies the value to write.\n%\n%   o  file:  Specifies the file to write the data to.\n%\n*/\nMagickExport ssize_t WriteBlobMSBShort(Image *image,const unsigned short value)\n{\n  unsigned char\n    buffer[2];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  buffer[0]=(unsigned char) (value >> 8);\n  buffer[1]=(unsigned char) value;\n  return(WriteBlobStream(image,2,buffer));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  W r i t e B l o b S t r i n g                                              %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobString() write a string to a blob.  It returns the number of\n%  characters written.\n%\n%  The format of the WriteBlobString method is:\n%\n%      ssize_t WriteBlobString(Image *image,const char *string)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o string: Specifies the string to write.\n%\n*/\nMagickExport ssize_t WriteBlobString(Image *image,const char *string)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(string != (const char *) NULL);\n  return(WriteBlobStream(image,strlen(string),(const unsigned char *) string));\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                         BBBB   L       OOO   BBBB                           %\n%                         B   B  L      O   O  B   B                          %\n%                         BBBB   L      O   O  BBBB                           %\n%                         B   B  L      O   O  B   B                          %\n%                         BBBB   LLLLL   OOO   BBBB                           %\n%                                                                             %\n%                                                                             %\n%                     MagickCore Binary Large OBjectS Methods                 %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1999                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#ifdef __VMS\n#include  <types.h>\n#include  <mman.h>\n#endif\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/delegate.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/locale_.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/nt-base-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/policy.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/timer-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n#include \"zlib.h\"\n#endif\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n#include \"bzlib.h\"\n#endif\n\f\n/*\n  Define declarations.\n*/\n#define MagickMaxBlobExtent  (8*8192)\n#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)\n# define MAP_ANONYMOUS  MAP_ANON\n#endif\n#if !defined(MAP_FAILED)\n#define MAP_FAILED  ((void *) -1)\n#endif\n#if defined(__OS2__)\n#include <io.h>\n#define _O_BINARY O_BINARY\n#endif\n\f\n/*\n  Typedef declarations.\n*/\ntypedef union FileInfo\n{\n  FILE\n    *file;\n\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n  gzFile\n    gzfile;\n#endif\n\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n  BZFILE\n    *bzfile;\n#endif\n} FileInfo;\n\nstruct _BlobInfo\n{\n  size_t\n    length,\n    extent,\n    quantum;\n\n  BlobMode\n    mode;\n\n  MagickBooleanType\n    mapped,\n    eof;\n\n  int\n    error;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    size;\n\n  MagickBooleanType\n    exempt,\n    synchronize,\n    status,\n    temporary;\n\n  StreamType\n    type;\n\n  FileInfo\n    file_info;\n\n  struct stat\n    properties;\n\n  StreamHandler\n    stream;\n\n  CustomStreamInfo\n    *custom_stream;\n\n  unsigned char\n    *data;\n\n  MagickBooleanType\n    debug;\n\n  SemaphoreInfo\n    *semaphore;\n\n  ssize_t\n    reference_count;\n\n  size_t\n    signature;\n};\n\nstruct _CustomStreamInfo\n{\n  CustomStreamHandler\n    reader,\n    writer;\n\n  CustomStreamSeeker\n    seeker;\n\n  CustomStreamTeller\n    teller;\n\n  void\n    *data;\n\n  size_t\n    signature;\n};\n\f\n/*\n  Forward declarations.\n*/\nstatic int\n  SyncBlob(Image *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A c q u i r e C u s t o m S t r e a m I n f o                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireCustomStreamInfo() allocates the CustomStreamInfo structure.\n%\n%  The format of the AcquireCustomStreamInfo method is:\n%\n%      CustomStreamInfo *AcquireCustomStreamInfo(ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport CustomStreamInfo *AcquireCustomStreamInfo(\n  ExceptionInfo *magick_unused(exception))\n{\n  CustomStreamInfo\n    *custom_stream;\n\n  magick_unreferenced(exception);\n  custom_stream=(CustomStreamInfo *) AcquireCriticalMemory(\n    sizeof(*custom_stream));\n  (void) memset(custom_stream,0,sizeof(*custom_stream));\n  custom_stream->signature=MagickCoreSignature;\n  return(custom_stream);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A t t a c h B l o b                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AttachBlob() attaches a blob to the BlobInfo structure.\n%\n%  The format of the AttachBlob method is:\n%\n%      void AttachBlob(BlobInfo *blob_info,const void *blob,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o blob_info: Specifies a pointer to a BlobInfo structure.\n%\n%    o blob: the address of a character stream in one of the image formats\n%      understood by ImageMagick.\n%\n%    o length: This size_t integer reflects the length in bytes of the blob.\n%\n*/\nMagickExport void AttachBlob(BlobInfo *blob_info,const void *blob,\n  const size_t length)\n{\n  assert(blob_info != (BlobInfo *) NULL);\n  if (blob_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  blob_info->length=length;\n  blob_info->extent=length;\n  blob_info->quantum=(size_t) MagickMaxBlobExtent;\n  blob_info->offset=0;\n  blob_info->type=BlobStream;\n  blob_info->file_info.file=(FILE *) NULL;\n  blob_info->data=(unsigned char *) blob;\n  blob_info->mapped=MagickFalse;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A t t a c h C u s t o m S t r e a m                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AttachCustomStream() attaches a CustomStreamInfo to the BlobInfo structure.\n%\n%  The format of the AttachCustomStream method is:\n%\n%      void AttachCustomStream(BlobInfo *blob_info,\n%        CustomStreamInfo *custom_stream)\n%\n%  A description of each parameter follows:\n%\n%    o blob_info: specifies a pointer to a BlobInfo structure.\n%\n%    o custom_stream: the custom stream info.\n%\n*/\nMagickExport void AttachCustomStream(BlobInfo *blob_info,\n  CustomStreamInfo *custom_stream)\n{\n  assert(blob_info != (BlobInfo *) NULL);\n  assert(custom_stream != (CustomStreamInfo *) NULL);\n  assert(custom_stream->signature == MagickCoreSignature);\n  if (blob_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  blob_info->type=CustomStream;\n  blob_info->custom_stream=custom_stream;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   B l o b T o F i l e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  BlobToFile() writes a blob to a file.  It returns MagickFalse if an error\n%  occurs otherwise MagickTrue.\n%\n%  The format of the BlobToFile method is:\n%\n%       MagickBooleanType BlobToFile(char *filename,const void *blob,\n%         const size_t length,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o filename: Write the blob to this file.\n%\n%    o blob: the address of a blob.\n%\n%    o length: This length in bytes of the blob.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType BlobToFile(char *filename,const void *blob,\n  const size_t length,ExceptionInfo *exception)\n{\n  int\n    file;\n\n  register size_t\n    i;\n\n  ssize_t\n    count;\n\n  assert(filename != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  assert(blob != (const void *) NULL);\n  if (*filename == '\\0')\n    file=AcquireUniqueFileResource(filename);\n  else\n    file=open_utf8(filename,O_RDWR | O_CREAT | O_EXCL | O_BINARY,S_MODE);\n  if (file == -1)\n    {\n      ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",filename);\n      return(MagickFalse);\n    }\n  for (i=0; i < length; i+=count)\n  {\n    count=write(file,(const char *) blob+i,MagickMin(length-i,(size_t)\n      SSIZE_MAX));\n    if (count <= 0)\n      {\n        count=0;\n        if (errno != EINTR)\n          break;\n      }\n  }\n  file=close(file);\n  if ((file == -1) || (i < length))\n    {\n      ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",filename);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   B l o b T o I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  BlobToImage() implements direct to memory image formats.  It returns the\n%  blob as an image.\n%\n%  The format of the BlobToImage method is:\n%\n%      Image *BlobToImage(const ImageInfo *image_info,const void *blob,\n%        const size_t length,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o blob: the address of a character stream in one of the image formats\n%      understood by ImageMagick.\n%\n%    o length: This size_t integer reflects the length in bytes of the blob.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *BlobToImage(const ImageInfo *image_info,const void *blob,\n  const size_t length,ExceptionInfo *exception)\n{\n  const MagickInfo\n    *magick_info;\n\n  Image\n    *image;\n\n  ImageInfo\n    *blob_info,\n    *clone_info;\n\n  MagickBooleanType\n    status;\n\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  if ((blob == (const void *) NULL) || (length == 0))\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),BlobError,\n        \"ZeroLengthBlobNotPermitted\",\"`%s'\",image_info->filename);\n      return((Image *) NULL);\n    }\n  blob_info=CloneImageInfo(image_info);\n  blob_info->blob=(void *) blob;\n  blob_info->length=length;\n  if (*blob_info->magick == '\\0')\n    (void) SetImageInfo(blob_info,0,exception);\n  magick_info=GetMagickInfo(blob_info->magick,exception);\n  if (magick_info == (const MagickInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        MissingDelegateError,\"NoDecodeDelegateForThisImageFormat\",\"`%s'\",\n        blob_info->magick);\n      blob_info=DestroyImageInfo(blob_info);\n      return((Image *) NULL);\n    }\n  if (GetMagickBlobSupport(magick_info) != MagickFalse)\n    {\n      char\n        filename[MagickPathExtent];\n\n      /*\n        Native blob support for this image format.\n      */\n      (void) CopyMagickString(filename,blob_info->filename,MagickPathExtent);\n      (void) FormatLocaleString(blob_info->filename,MagickPathExtent,\"%s:%s\",\n        blob_info->magick,filename);\n      image=ReadImage(blob_info,exception);\n      if (image != (Image *) NULL)\n        (void) DetachBlob(image->blob);\n      blob_info=DestroyImageInfo(blob_info);\n      return(image);\n    }\n  /*\n    Write blob to a temporary file on disk.\n  */\n  blob_info->blob=(void *) NULL;\n  blob_info->length=0;\n  *blob_info->filename='\\0';\n  status=BlobToFile(blob_info->filename,blob,length,exception);\n  if (status == MagickFalse)\n    {\n      (void) RelinquishUniqueFileResource(blob_info->filename);\n      blob_info=DestroyImageInfo(blob_info);\n      return((Image *) NULL);\n    }\n  clone_info=CloneImageInfo(blob_info);\n  (void) FormatLocaleString(clone_info->filename,MagickPathExtent,\"%s:%s\",\n    blob_info->magick,blob_info->filename);\n  image=ReadImage(clone_info,exception);\n  if (image != (Image *) NULL)\n    {\n      Image\n        *images;\n\n      /*\n        Restore original filenames and image format.\n      */\n      for (images=GetFirstImageInList(image); images != (Image *) NULL; )\n      {\n        (void) CopyMagickString(images->filename,image_info->filename,\n          MagickPathExtent);\n        (void) CopyMagickString(images->magick_filename,image_info->filename,\n          MagickPathExtent);\n        (void) CopyMagickString(images->magick,magick_info->name,\n          MagickPathExtent);\n        images=GetNextImageInList(images);\n      }\n    }\n  clone_info=DestroyImageInfo(clone_info);\n  (void) RelinquishUniqueFileResource(blob_info->filename);\n  blob_info=DestroyImageInfo(blob_info);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C l o n e B l o b I n f o                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneBlobInfo() makes a duplicate of the given blob info structure, or if\n%  blob info is NULL, a new one.\n%\n%  The format of the CloneBlobInfo method is:\n%\n%      BlobInfo *CloneBlobInfo(const BlobInfo *blob_info)\n%\n%  A description of each parameter follows:\n%\n%    o blob_info: the blob info.\n%\n*/\nMagickExport BlobInfo *CloneBlobInfo(const BlobInfo *blob_info)\n{\n  BlobInfo\n    *clone_info;\n\n  SemaphoreInfo\n    *semaphore;\n\n  clone_info=(BlobInfo *) AcquireCriticalMemory(sizeof(*clone_info));\n  GetBlobInfo(clone_info);\n  if (blob_info == (BlobInfo *) NULL)\n    return(clone_info);\n  semaphore=clone_info->semaphore;\n  (void) memcpy(clone_info,blob_info,sizeof(*clone_info));\n  if (blob_info->mapped != MagickFalse)\n    (void) AcquireMagickResource(MapResource,blob_info->length);\n  clone_info->semaphore=semaphore;\n  LockSemaphoreInfo(clone_info->semaphore);\n  clone_info->reference_count=1;\n  UnlockSemaphoreInfo(clone_info->semaphore);\n  return(clone_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C l o s e B l o b                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloseBlob() closes a stream associated with the image.\n%\n%  The format of the CloseBlob method is:\n%\n%      MagickBooleanType CloseBlob(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType CloseBlob(Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  int\n    status;\n\n  /*\n    Close image file.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  blob_info=image->blob;\n  if ((blob_info == (BlobInfo *) NULL) || (blob_info->type == UndefinedStream))\n    return(MagickTrue);\n  status=SyncBlob(image);\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    case PipeStream:\n    {\n      if (blob_info->synchronize != MagickFalse)\n        status=fsync(fileno(blob_info->file_info.file));\n      status=ferror(blob_info->file_info.file);\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      (void) gzerror(blob_info->file_info.gzfile,&status);\n#endif\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      (void) BZ2_bzerror(blob_info->file_info.bzfile,&status);\n#endif\n      break;\n    }\n    case FifoStream:\n      break;\n    case BlobStream:\n    {\n      if (blob_info->file_info.file != (FILE *) NULL)\n        {\n          if (blob_info->synchronize != MagickFalse)\n            status=fsync(fileno(blob_info->file_info.file));\n          status=ferror(blob_info->file_info.file);\n        }\n      break;\n    }\n    case CustomStream:\n      break;\n  }\n  blob_info->status=status < 0 ? MagickTrue : MagickFalse;\n  blob_info->size=GetBlobSize(image);\n  image->extent=blob_info->size;\n  blob_info->eof=MagickFalse;\n  blob_info->error=0;\n  blob_info->mode=UndefinedBlobMode;\n  if (blob_info->exempt != MagickFalse)\n    {\n      blob_info->type=UndefinedStream;\n      return(blob_info->status);\n    }\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    {\n      if (fileno(blob_info->file_info.file) != -1)\n        status=fclose(blob_info->file_info.file);\n      break;\n    }\n    case PipeStream:\n    {\n#if defined(MAGICKCORE_HAVE_PCLOSE)\n      status=pclose(blob_info->file_info.file);\n#endif\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      status=gzclose(blob_info->file_info.gzfile);\n#endif\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      BZ2_bzclose(blob_info->file_info.bzfile);\n#endif\n      break;\n    }\n    case FifoStream:\n      break;\n    case BlobStream:\n    {\n      if (blob_info->file_info.file != (FILE *) NULL)\n        status=fclose(blob_info->file_info.file);\n      break;\n    }\n    case CustomStream:\n      break;\n  }\n  (void) DetachBlob(blob_info);\n  blob_info->status=status < 0 ? MagickTrue : MagickFalse;\n  return(blob_info->status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C u s t o m S t r e a m T o I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CustomStreamToImage() is the equivalent of ReadImage(), but reads the\n%  formatted \"file\" from the suplied method rather than to an actual file.\n%\n%  The format of the CustomStreamToImage method is:\n%\n%      Image *CustomStreamToImage(const ImageInfo *image_info,\n%         ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *CustomStreamToImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const MagickInfo\n    *magick_info;\n\n  Image\n    *image;\n\n  ImageInfo\n    *blob_info;\n\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(image_info->custom_stream != (CustomStreamInfo *) NULL);\n  assert(image_info->custom_stream->signature == MagickCoreSignature);\n  assert(image_info->custom_stream->reader != (CustomStreamHandler) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  blob_info=CloneImageInfo(image_info);\n  if (*blob_info->magick == '\\0')\n    (void) SetImageInfo(blob_info,0,exception);\n  magick_info=GetMagickInfo(blob_info->magick,exception);\n  if (magick_info == (const MagickInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        MissingDelegateError,\"NoDecodeDelegateForThisImageFormat\",\"`%s'\",\n        blob_info->magick);\n      blob_info=DestroyImageInfo(blob_info);\n      return((Image *) NULL);\n    }\n  image=(Image *) NULL;\n  if ((GetMagickBlobSupport(magick_info) != MagickFalse) ||\n      (*blob_info->filename != '\\0'))\n    {\n      char\n        filename[MagickPathExtent];\n\n      /*\n        Native blob support for this image format or SetImageInfo changed the\n        blob to a file.\n      */\n      (void) CopyMagickString(filename,blob_info->filename,MagickPathExtent);\n      (void) FormatLocaleString(blob_info->filename,MagickPathExtent,\"%s:%s\",\n        blob_info->magick,filename);\n      image=ReadImage(blob_info,exception);\n      if (image != (Image *) NULL)\n        (void) CloseBlob(image);\n    }\n  else\n    {\n      char\n        unique[MagickPathExtent];\n\n      int\n        file;\n\n      ImageInfo\n        *clone_info;\n\n      unsigned char\n        *blob;\n\n      /*\n        Write data to file on disk.\n      */\n      blob_info->custom_stream=(CustomStreamInfo *) NULL;\n      blob=(unsigned char *) AcquireQuantumMemory(MagickMaxBufferExtent,\n        sizeof(*blob));\n      if (blob == (unsigned char *) NULL)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToReadBlob\",\n            image_info->filename);\n          blob_info=DestroyImageInfo(blob_info);\n          return((Image *) NULL);\n        }\n      file=AcquireUniqueFileResource(unique);\n      if (file == -1)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToReadBlob\",\n            image_info->filename);\n          blob=(unsigned char *) RelinquishMagickMemory(blob);\n          blob_info=DestroyImageInfo(blob_info);\n          return((Image *) NULL);\n        }\n      clone_info=CloneImageInfo(blob_info);\n      blob_info->file=fdopen(file,\"wb+\");\n      if (blob_info->file != (FILE *) NULL)\n        {\n          ssize_t\n            count;\n\n          count=(ssize_t) MagickMaxBufferExtent;\n          while (count == (ssize_t) MagickMaxBufferExtent)\n          {\n            count=image_info->custom_stream->reader(blob,MagickMaxBufferExtent,\n              image_info->custom_stream->data);\n            count=(ssize_t) write(file,(const char *) blob,(size_t) count);\n          }\n          (void) fclose(blob_info->file);\n          (void) FormatLocaleString(clone_info->filename,MagickPathExtent,\n            \"%s:%s\",blob_info->magick,unique);\n          image=ReadImage(clone_info,exception);\n          if (image != (Image *) NULL)\n            {\n              Image\n                *images;\n\n              /*\n                Restore original filenames and image format.\n              */\n              for (images=GetFirstImageInList(image); images != (Image *) NULL; )\n              {\n                (void) CopyMagickString(images->filename,image_info->filename,\n                  MagickPathExtent);\n                (void) CopyMagickString(images->magick_filename,\n                  image_info->filename,MagickPathExtent);\n                (void) CopyMagickString(images->magick,magick_info->name,\n                  MagickPathExtent);\n                (void) CloseBlob(images);\n                images=GetNextImageInList(images);\n              }\n            }\n        }\n      clone_info=DestroyImageInfo(clone_info);\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n      (void) RelinquishUniqueFileResource(unique);\n    }\n  blob_info=DestroyImageInfo(blob_info);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y B l o b                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyBlob() deallocates memory associated with a blob.\n%\n%  The format of the DestroyBlob method is:\n%\n%      void DestroyBlob(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void DestroyBlob(Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  MagickBooleanType\n    destroy;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->signature == MagickCoreSignature);\n  blob_info=image->blob;\n  destroy=MagickFalse;\n  LockSemaphoreInfo(blob_info->semaphore);\n  blob_info->reference_count--;\n  assert(blob_info->reference_count >= 0);\n  if (blob_info->reference_count == 0)\n    destroy=MagickTrue;\n  UnlockSemaphoreInfo(blob_info->semaphore);\n  if (destroy == MagickFalse)\n    {\n      image->blob=(BlobInfo *) NULL;\n      return;\n    }\n  (void) CloseBlob(image);\n  if (blob_info->mapped != MagickFalse)\n    {\n      (void) UnmapBlob(blob_info->data,blob_info->length);\n      RelinquishMagickResource(MapResource,blob_info->length);\n    }\n  if (blob_info->semaphore != (SemaphoreInfo *) NULL)\n    RelinquishSemaphoreInfo(&blob_info->semaphore);\n  blob_info->signature=(~MagickCoreSignature);\n  image->blob=(BlobInfo *) RelinquishMagickMemory(blob_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y C u s t o m S t r e a m I n f o                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyCustomStreamInfo() destroys memory associated with the\n%  CustomStreamInfo structure.\n%\n%  The format of the DestroyCustomStreamInfo method is:\n%\n%      CustomStreamInfo *DestroyCustomStreamInfo(CustomStreamInfo *stream_info)\n%\n%  A description of each parameter follows:\n%\n%    o custom_stream: the custom stream info.\n%\n*/\nMagickExport CustomStreamInfo *DestroyCustomStreamInfo(\n  CustomStreamInfo *custom_stream)\n{\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(custom_stream != (CustomStreamInfo *) NULL);\n  assert(custom_stream->signature == MagickCoreSignature);\n  custom_stream->signature=(~MagickCoreSignature);\n  custom_stream=(CustomStreamInfo *) RelinquishMagickMemory(custom_stream);\n  return(custom_stream);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e t a c h B l o b                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DetachBlob() detaches a blob from the BlobInfo structure.\n%\n%  The format of the DetachBlob method is:\n%\n%      void *DetachBlob(BlobInfo *blob_info)\n%\n%  A description of each parameter follows:\n%\n%    o blob_info: Specifies a pointer to a BlobInfo structure.\n%\n*/\nMagickExport void *DetachBlob(BlobInfo *blob_info)\n{\n  void\n    *data;\n\n  assert(blob_info != (BlobInfo *) NULL);\n  if (blob_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  if (blob_info->mapped != MagickFalse)\n    {\n      (void) UnmapBlob(blob_info->data,blob_info->length);\n      blob_info->data=NULL;\n      RelinquishMagickResource(MapResource,blob_info->length);\n    }\n  blob_info->mapped=MagickFalse;\n  blob_info->length=0;\n  blob_info->offset=0;\n  blob_info->eof=MagickFalse;\n  blob_info->error=0;\n  blob_info->exempt=MagickFalse;\n  blob_info->type=UndefinedStream;\n  blob_info->file_info.file=(FILE *) NULL;\n  data=blob_info->data;\n  blob_info->data=(unsigned char *) NULL;\n  blob_info->stream=(StreamHandler) NULL;\n  blob_info->custom_stream=(CustomStreamInfo *) NULL;\n  return(data);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D i s a s s o c i a t e B l o b                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DisassociateBlob() disassociates the image stream.  It checks if the\n%  blob of the specified image is referenced by other images. If the reference\n%  count is higher then 1 a new blob is assigned to the specified image.\n%\n%  The format of the DisassociateBlob method is:\n%\n%      void DisassociateBlob(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void DisassociateBlob(Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info,\n    *clone_info;\n\n  MagickBooleanType\n    clone;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->signature == MagickCoreSignature);\n  blob_info=image->blob;\n  clone=MagickFalse;\n  LockSemaphoreInfo(blob_info->semaphore);\n  assert(blob_info->reference_count >= 0);\n  if (blob_info->reference_count > 1)\n    clone=MagickTrue;\n  UnlockSemaphoreInfo(blob_info->semaphore);\n  if (clone == MagickFalse)\n    return;\n  clone_info=CloneBlobInfo(blob_info);\n  DestroyBlob(image);\n  image->blob=clone_info;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  D i s c a r d B l o b B y t e s                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DiscardBlobBytes() discards bytes in a blob.\n%\n%  The format of the DiscardBlobBytes method is:\n%\n%      MagickBooleanType DiscardBlobBytes(Image *image,\n%        const MagickSizeType length)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o length:  the number of bytes to skip.\n%\n*/\nMagickExport MagickBooleanType DiscardBlobBytes(Image *image,\n  const MagickSizeType length)\n{\n  register MagickOffsetType\n    i;\n\n  size_t\n    quantum;\n\n  ssize_t\n    count;\n\n  unsigned char\n    buffer[16384];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (length != (MagickSizeType) ((MagickOffsetType) length))\n    return(MagickFalse);\n  count=0;\n  for (i=0; i < (MagickOffsetType) length; i+=count)\n  {\n    quantum=(size_t) MagickMin(length-i,sizeof(buffer));\n    (void) ReadBlobStream(image,quantum,buffer,&count);\n    if (count <= 0)\n      {\n        count=0;\n        if (errno != EINTR)\n          break;\n      }\n  }\n  return(i < (MagickOffsetType) length ? MagickFalse : MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D u p l i c a t e s B l o b                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DuplicateBlob() duplicates a blob descriptor.\n%\n%  The format of the DuplicateBlob method is:\n%\n%      void DuplicateBlob(Image *image,const Image *duplicate)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o duplicate: the duplicate image.\n%\n*/\nMagickExport void DuplicateBlob(Image *image,const Image *duplicate)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(duplicate != (Image *) NULL);\n  assert(duplicate->signature == MagickCoreSignature);\n  DestroyBlob(image);\n  image->blob=ReferenceBlob(duplicate->blob);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  E O F B l o b                                                              %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  EOFBlob() returns a non-zero value when EOF has been detected reading from\n%  a blob or file.\n%\n%  The format of the EOFBlob method is:\n%\n%      int EOFBlob(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport int EOFBlob(const Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  blob_info=image->blob;\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    case PipeStream:\n    {\n      blob_info->eof=feof(blob_info->file_info.file) != 0 ? MagickTrue :\n        MagickFalse;\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      blob_info->eof=gzeof(blob_info->file_info.gzfile) != 0 ? MagickTrue :\n        MagickFalse;\n#endif\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      int\n        status;\n\n      status=0;\n      (void) BZ2_bzerror(blob_info->file_info.bzfile,&status);\n      blob_info->eof=status == BZ_UNEXPECTED_EOF ? MagickTrue : MagickFalse;\n#endif\n      break;\n    }\n    case FifoStream:\n    {\n      blob_info->eof=MagickFalse;\n      break;\n    }\n    case BlobStream:\n      break;\n    case CustomStream:\n      break;\n  }\n  return((int) blob_info->eof);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  E r r o r B l o b                                                          %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ErrorBlob() returns a non-zero value when an error has been detected reading\n%  from a blob or file.\n%\n%  The format of the ErrorBlob method is:\n%\n%      int ErrorBlob(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport int ErrorBlob(const Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  blob_info=image->blob;\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    case PipeStream:\n    {\n      blob_info->error=ferror(blob_info->file_info.file);\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      (void) gzerror(blob_info->file_info.gzfile,&blob_info->error);\n#endif\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      (void) BZ2_bzerror(blob_info->file_info.bzfile,&blob_info->error);\n#endif\n      break;\n    }\n    case FifoStream:\n    {\n      blob_info->error=0;\n      break;\n    }\n    case BlobStream:\n      break;\n    case CustomStream:\n      break;\n  }\n  return(blob_info->error);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   F i l e T o B l o b                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FileToBlob() returns the contents of a file as a buffer terminated with\n%  the '\\0' character.  The length of the buffer (not including the extra\n%  terminating '\\0' character) is returned via the 'length' parameter.  Free\n%  the buffer with RelinquishMagickMemory().\n%\n%  The format of the FileToBlob method is:\n%\n%      void *FileToBlob(const char *filename,const size_t extent,\n%        size_t *length,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o blob:  FileToBlob() returns the contents of a file as a blob.  If\n%      an error occurs NULL is returned.\n%\n%    o filename: the filename.\n%\n%    o extent:  The maximum length of the blob.\n%\n%    o length: On return, this reflects the actual length of the blob.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport void *FileToBlob(const char *filename,const size_t extent,\n  size_t *length,ExceptionInfo *exception)\n{\n  int\n    file;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  register size_t\n    i;\n\n  ssize_t\n    count;\n\n  struct stat\n    attributes;\n\n  unsigned char\n    *blob;\n\n  void\n    *map;\n\n  assert(filename != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  *length=0;\n  status=IsRightsAuthorized(PathPolicyDomain,ReadPolicyRights,filename);\n  if (status == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",filename);\n      return(NULL);\n    }\n  file=fileno(stdin);\n  if (LocaleCompare(filename,\"-\") != 0)\n    {\n      status=GetPathAttributes(filename,&attributes);\n      if ((status == MagickFalse) || (S_ISDIR(attributes.st_mode) != 0))\n        {\n          ThrowFileException(exception,BlobError,\"UnableToReadBlob\",filename);\n          return(NULL);\n        }\n      file=open_utf8(filename,O_RDONLY | O_BINARY,0);\n    }\n  if (file == -1)\n    {\n      ThrowFileException(exception,BlobError,\"UnableToOpenFile\",filename);\n      return(NULL);\n    }\n  offset=(MagickOffsetType) lseek(file,0,SEEK_END);\n  count=0;\n  if ((file == fileno(stdin)) || (offset < 0) ||\n      (offset != (MagickOffsetType) ((ssize_t) offset)))\n    {\n      size_t\n        quantum;\n\n      struct stat\n        file_stats;\n\n      /*\n        Stream is not seekable.\n      */\n      offset=(MagickOffsetType) lseek(file,0,SEEK_SET);\n      quantum=(size_t) MagickMaxBufferExtent;\n      if ((fstat(file,&file_stats) == 0) && (file_stats.st_size > 0))\n        quantum=(size_t) MagickMin(file_stats.st_size,MagickMaxBufferExtent);\n      blob=(unsigned char *) AcquireQuantumMemory(quantum,sizeof(*blob));\n      for (i=0; blob != (unsigned char *) NULL; i+=count)\n      {\n        count=read(file,blob+i,quantum);\n        if (count <= 0)\n          {\n            count=0;\n            if (errno != EINTR)\n              break;\n          }\n        if (~((size_t) i) < (quantum+1))\n          {\n            blob=(unsigned char *) RelinquishMagickMemory(blob);\n            break;\n          }\n        blob=(unsigned char *) ResizeQuantumMemory(blob,i+quantum+1,\n          sizeof(*blob));\n        if ((size_t) (i+count) >= extent)\n          break;\n      }\n      if (LocaleCompare(filename,\"-\") != 0)\n        file=close(file);\n      if (blob == (unsigned char *) NULL)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",filename);\n          return(NULL);\n        }\n      if (file == -1)\n        {\n          blob=(unsigned char *) RelinquishMagickMemory(blob);\n          ThrowFileException(exception,BlobError,\"UnableToReadBlob\",filename);\n          return(NULL);\n        }\n      *length=(size_t) MagickMin(i+count,extent);\n      blob[*length]='\\0';\n      return(blob);\n    }\n  *length=(size_t) MagickMin(offset,(MagickOffsetType)\n    MagickMin(extent,(size_t) SSIZE_MAX));\n  blob=(unsigned char *) NULL;\n  if (~(*length) >= (MagickPathExtent-1))\n    blob=(unsigned char *) AcquireQuantumMemory(*length+MagickPathExtent,\n      sizeof(*blob));\n  if (blob == (unsigned char *) NULL)\n    {\n      file=close(file);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",filename);\n      return(NULL);\n    }\n  map=MapBlob(file,ReadMode,0,*length);\n  if (map != (unsigned char *) NULL)\n    {\n      (void) memcpy(blob,map,*length);\n      (void) UnmapBlob(map,*length);\n    }\n  else\n    {\n      (void) lseek(file,0,SEEK_SET);\n      for (i=0; i < *length; i+=count)\n      {\n        count=read(file,blob+i,(size_t) MagickMin(*length-i,(size_t)\n          SSIZE_MAX));\n        if (count <= 0)\n          {\n            count=0;\n            if (errno != EINTR)\n              break;\n          }\n      }\n      if (i < *length)\n        {\n          file=close(file)-1;\n          blob=(unsigned char *) RelinquishMagickMemory(blob);\n          ThrowFileException(exception,BlobError,\"UnableToReadBlob\",filename);\n          return(NULL);\n        }\n    }\n  blob[*length]='\\0';\n  if (LocaleCompare(filename,\"-\") != 0)\n    file=close(file);\n  if (file == -1)\n    {\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n      ThrowFileException(exception,BlobError,\"UnableToReadBlob\",filename);\n    }\n  return(blob);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   F i l e T o I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FileToImage() write the contents of a file to an image.\n%\n%  The format of the FileToImage method is:\n%\n%      MagickBooleanType FileToImage(Image *,const char *filename)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o filename: the filename.\n%\n*/\n\nstatic inline ssize_t WriteBlobStream(Image *image,const size_t length,\n  const void *data)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  MagickSizeType\n    extent;\n\n  register unsigned char\n    *q;\n\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  assert(data != NULL);\n  blob_info=image->blob;\n  if (blob_info->type != BlobStream)\n    return(WriteBlob(image,length,(const unsigned char *) data));\n  extent=(MagickSizeType) (blob_info->offset+(MagickOffsetType) length);\n  if (extent >= blob_info->extent)\n    {\n      extent=blob_info->extent+blob_info->quantum+length;\n      blob_info->quantum<<=1;\n      if (SetBlobExtent(image,extent) == MagickFalse)\n        return(0);\n    }\n  q=blob_info->data+blob_info->offset;\n  (void) memcpy(q,data,length);\n  blob_info->offset+=length;\n  if (blob_info->offset >= (MagickOffsetType) blob_info->length)\n    blob_info->length=(size_t) blob_info->offset;\n  return((ssize_t) length);\n}\n\nMagickExport MagickBooleanType FileToImage(Image *image,const char *filename,\n  ExceptionInfo *exception)\n{\n  int\n    file;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length,\n    quantum;\n\n  ssize_t\n    count;\n\n  struct stat\n    file_stats;\n\n  unsigned char\n    *blob;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(filename != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  status=IsRightsAuthorized(PathPolicyDomain,WritePolicyRights,filename);\n  if (status == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",filename);\n      return(MagickFalse);\n    }\n  file=fileno(stdin);\n  if (LocaleCompare(filename,\"-\") != 0)\n    file=open_utf8(filename,O_RDONLY | O_BINARY,0);\n  if (file == -1)\n    {\n      ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n      return(MagickFalse);\n    }\n  quantum=(size_t) MagickMaxBufferExtent;\n  if ((fstat(file,&file_stats) == 0) && (file_stats.st_size > 0))\n    quantum=(size_t) MagickMin(file_stats.st_size,MagickMaxBufferExtent);\n  blob=(unsigned char *) AcquireQuantumMemory(quantum,sizeof(*blob));\n  if (blob == (unsigned char *) NULL)\n    {\n      file=close(file);\n      ThrowFileException(exception,ResourceLimitError,\"MemoryAllocationFailed\",\n        filename);\n      return(MagickFalse);\n    }\n  for ( ; ; )\n  {\n    count=read(file,blob,quantum);\n    if (count <= 0)\n      {\n        count=0;\n        if (errno != EINTR)\n          break;\n      }\n    length=(size_t) count;\n    count=WriteBlobStream(image,length,blob);\n    if (count != (ssize_t) length)\n      {\n        ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",filename);\n        break;\n      }\n  }\n  file=close(file);\n  if (file == -1)\n    ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",filename);\n  blob=(unsigned char *) RelinquishMagickMemory(blob);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t B l o b E r r o r                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetBlobError() returns MagickTrue if the blob associated with the specified\n%  image encountered an error.\n%\n%  The format of the GetBlobError method is:\n%\n%       MagickBooleanType GetBlobError(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType GetBlobError(const Image *image)\n{\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  return(image->blob->status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t B l o b F i l e H a n d l e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetBlobFileHandle() returns the file handle associated with the image blob.\n%\n%  The format of the GetBlobFile method is:\n%\n%      FILE *GetBlobFileHandle(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport FILE *GetBlobFileHandle(const Image *image)\n{\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  return(image->blob->file_info.file);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t B l o b I n f o                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetBlobInfo() initializes the BlobInfo structure.\n%\n%  The format of the GetBlobInfo method is:\n%\n%      void GetBlobInfo(BlobInfo *blob_info)\n%\n%  A description of each parameter follows:\n%\n%    o blob_info: Specifies a pointer to a BlobInfo structure.\n%\n*/\nMagickExport void GetBlobInfo(BlobInfo *blob_info)\n{\n  assert(blob_info != (BlobInfo *) NULL);\n  (void) memset(blob_info,0,sizeof(*blob_info));\n  blob_info->type=UndefinedStream;\n  blob_info->quantum=(size_t) MagickMaxBlobExtent;\n  blob_info->properties.st_mtime=GetMagickTime();\n  blob_info->properties.st_ctime=blob_info->properties.st_mtime;\n  blob_info->debug=IsEventLogging();\n  blob_info->reference_count=1;\n  blob_info->semaphore=AcquireSemaphoreInfo();\n  blob_info->signature=MagickCoreSignature;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  G e t B l o b P r o p e r t i e s                                          %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetBlobProperties() returns information about an image blob.\n%\n%  The format of the GetBlobProperties method is:\n%\n%      const struct stat *GetBlobProperties(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport const struct stat *GetBlobProperties(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  return(&image->blob->properties);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  G e t B l o b S i z e                                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetBlobSize() returns the current length of the image file or blob; zero is\n%  returned if the size cannot be determined.\n%\n%  The format of the GetBlobSize method is:\n%\n%      MagickSizeType GetBlobSize(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickSizeType GetBlobSize(const Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  MagickSizeType\n    extent;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->blob != (BlobInfo *) NULL);\n  blob_info=image->blob;\n  extent=0;\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n    {\n      extent=blob_info->size;\n      break;\n    }\n    case FileStream:\n    {\n      int\n        file_descriptor;\n\n      extent=(MagickSizeType) blob_info->properties.st_size;\n      if (extent == 0)\n        extent=blob_info->size;\n      file_descriptor=fileno(blob_info->file_info.file);\n      if (file_descriptor == -1)\n        break;\n      if (fstat(file_descriptor,&blob_info->properties) == 0)\n        extent=(MagickSizeType) blob_info->properties.st_size;\n      break;\n    }\n    case PipeStream:\n    {\n      extent=blob_info->size;\n      break;\n    }\n    case ZipStream:\n    case BZipStream:\n    {\n      MagickBooleanType\n        status;\n\n      status=GetPathAttributes(image->filename,&blob_info->properties);\n      if (status != MagickFalse)\n        extent=(MagickSizeType) blob_info->properties.st_size;\n      break;\n    }\n    case FifoStream:\n      break;\n    case BlobStream:\n    {\n      extent=(MagickSizeType) blob_info->length;\n      break;\n    }\n    case CustomStream:\n    {\n      if ((blob_info->custom_stream->teller != (CustomStreamTeller) NULL) &&\n          (blob_info->custom_stream->seeker != (CustomStreamSeeker) NULL))\n        {\n          MagickOffsetType\n            offset;\n\n          offset=blob_info->custom_stream->teller(\n            blob_info->custom_stream->data);\n          extent=(MagickSizeType) blob_info->custom_stream->seeker(0,SEEK_END,\n            blob_info->custom_stream->data);\n          (void) blob_info->custom_stream->seeker(offset,SEEK_SET,\n            blob_info->custom_stream->data);\n        }\n      break;\n    }\n  }\n  return(extent);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t B l o b S t r e a m D a t a                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetBlobStreamData() returns the stream data for the image.\n%\n%  The format of the GetBlobStreamData method is:\n%\n%      void *GetBlobStreamData(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void *GetBlobStreamData(const Image *image)\n{\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  return(image->blob->data);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t B l o b S t r e a m H a n d l e r                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetBlobStreamHandler() returns the stream handler for the image.\n%\n%  The format of the GetBlobStreamHandler method is:\n%\n%      StreamHandler GetBlobStreamHandler(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport StreamHandler GetBlobStreamHandler(const Image *image)\n{\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  return(image->blob->stream);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I m a g e T o B l o b                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ImageToBlob() implements direct to memory image formats.  It returns the\n%  image as a formatted blob and its length.  The magick member of the Image\n%  structure determines the format of the returned blob (GIF, JPEG, PNG,\n%  etc.).  This method is the equivalent of WriteImage(), but writes the\n%  formatted \"file\" to a memory buffer rather than to an actual file.\n%\n%  The format of the ImageToBlob method is:\n%\n%      void *ImageToBlob(const ImageInfo *image_info,Image *image,\n%        size_t *length,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n%    o length: return the actual length of the blob.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport void *ImageToBlob(const ImageInfo *image_info,\n  Image *image,size_t *length,ExceptionInfo *exception)\n{\n  const MagickInfo\n    *magick_info;\n\n  ImageInfo\n    *blob_info;\n\n  MagickBooleanType\n    status;\n\n  void\n    *blob;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  *length=0;\n  blob=(unsigned char *) NULL;\n  blob_info=CloneImageInfo(image_info);\n  blob_info->adjoin=MagickFalse;\n  (void) SetImageInfo(blob_info,1,exception);\n  if (*blob_info->magick != '\\0')\n    (void) CopyMagickString(image->magick,blob_info->magick,MagickPathExtent);\n  magick_info=GetMagickInfo(image->magick,exception);\n  if (magick_info == (const MagickInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        MissingDelegateError,\"NoDecodeDelegateForThisImageFormat\",\"`%s'\",\n        image->magick);\n      blob_info=DestroyImageInfo(blob_info);\n      return(blob);\n    }\n  (void) CopyMagickString(blob_info->magick,image->magick,MagickPathExtent);\n  if (GetMagickBlobSupport(magick_info) != MagickFalse)\n    {\n      /*\n        Native blob support for this image format.\n      */\n      blob_info->length=0;\n      blob_info->blob=AcquireQuantumMemory(MagickMaxBlobExtent,\n        sizeof(unsigned char));\n      if (blob_info->blob == NULL)\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      else\n        {\n          (void) CloseBlob(image);\n          image->blob->exempt=MagickTrue;\n          *image->filename='\\0';\n          status=WriteImage(blob_info,image,exception);\n          *length=image->blob->length;\n          blob=DetachBlob(image->blob);\n          if (blob == (void *) NULL)\n            blob_info->blob=RelinquishMagickMemory(blob_info->blob);\n          else if (status == MagickFalse)\n            blob=RelinquishMagickMemory(blob);\n          else\n            blob=ResizeQuantumMemory(blob,*length+1,sizeof(unsigned char));\n        }\n    }\n  else\n    {\n      char\n        unique[MagickPathExtent];\n\n      int\n        file;\n\n      /*\n        Write file to disk in blob image format.\n      */\n      file=AcquireUniqueFileResource(unique);\n      if (file == -1)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",\n            image_info->filename);\n        }\n      else\n        {\n          blob_info->file=fdopen(file,\"wb\");\n          if (blob_info->file != (FILE *) NULL)\n            {\n              (void) FormatLocaleString(image->filename,MagickPathExtent,\n                \"%s:%s\",image->magick,unique);\n              status=WriteImage(blob_info,image,exception);\n              (void) CloseBlob(image);\n              (void) fclose(blob_info->file);\n              if (status != MagickFalse)\n                blob=FileToBlob(unique,~0UL,length,exception);\n            }\n          (void) RelinquishUniqueFileResource(unique);\n        }\n    }\n  blob_info=DestroyImageInfo(blob_info);\n  return(blob);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  I m a g e T o C u s t o m S t r e a m                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ImageToCustomStream() is the equivalent of WriteImage(), but writes the\n%  formatted \"file\" to the custom stream rather than to an actual file.\n%\n%  The format of the ImageToCustomStream method is:\n%\n%      void ImageToCustomStream(const ImageInfo *image_info,Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport void ImageToCustomStream(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  const MagickInfo\n    *magick_info;\n\n  ImageInfo\n    *clone_info;\n\n  MagickBooleanType\n    blob_support,\n    status;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image_info->custom_stream != (CustomStreamInfo *) NULL);\n  assert(image_info->custom_stream->signature == MagickCoreSignature);\n  assert(image_info->custom_stream->writer != (CustomStreamHandler) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  clone_info=CloneImageInfo(image_info);\n  clone_info->adjoin=MagickFalse;\n  (void) SetImageInfo(clone_info,1,exception);\n  if (*clone_info->magick != '\\0')\n    (void) CopyMagickString(image->magick,clone_info->magick,MagickPathExtent);\n  magick_info=GetMagickInfo(image->magick,exception);\n  if (magick_info == (const MagickInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        MissingDelegateError,\"NoEncodeDelegateForThisImageFormat\",\"`%s'\",\n        image->magick);\n      clone_info=DestroyImageInfo(clone_info);\n      return;\n    }\n  (void) CopyMagickString(clone_info->magick,image->magick,MagickPathExtent);\n  blob_support=GetMagickBlobSupport(magick_info);\n  if ((blob_support != MagickFalse) &&\n      (GetMagickEncoderSeekableStream(magick_info) != MagickFalse))\n    {\n      if ((clone_info->custom_stream->seeker == (CustomStreamSeeker) NULL) ||\n          (clone_info->custom_stream->teller == (CustomStreamTeller) NULL))\n        blob_support=MagickFalse;\n    }\n  if (blob_support != MagickFalse)\n    {\n      /*\n        Native blob support for this image format.\n      */\n      (void) CloseBlob(image);\n      *image->filename='\\0';\n      (void) WriteImage(clone_info,image,exception);\n      (void) CloseBlob(image);\n    }\n  else\n    {\n      char\n        unique[MagickPathExtent];\n\n      int\n        file;\n\n      unsigned char\n        *blob;\n\n      /*\n        Write file to disk in blob image format.\n      */\n      clone_info->custom_stream=(CustomStreamInfo *) NULL;\n      blob=(unsigned char *) AcquireQuantumMemory(MagickMaxBufferExtent,\n        sizeof(*blob));\n      if (blob == (unsigned char *) NULL)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",\n            image_info->filename);\n          clone_info=DestroyImageInfo(clone_info);\n          return;\n        }\n      file=AcquireUniqueFileResource(unique);\n      if (file == -1)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",\n            image_info->filename);\n          blob=(unsigned char *) RelinquishMagickMemory(blob);\n          clone_info=DestroyImageInfo(clone_info);\n          return;\n        }\n      clone_info->file=fdopen(file,\"wb+\");\n      if (clone_info->file != (FILE *) NULL)\n        {\n          ssize_t\n            count;\n\n          (void) FormatLocaleString(image->filename,MagickPathExtent,\n            \"%s:%s\",image->magick,unique);\n          status=WriteImage(clone_info,image,exception);\n          (void) CloseBlob(image);\n          if (status != MagickFalse)\n            {\n              (void) fseek(clone_info->file,0,SEEK_SET);\n              count=(ssize_t) MagickMaxBufferExtent;\n              while (count == (ssize_t) MagickMaxBufferExtent)\n              {\n                count=(ssize_t) fread(blob,sizeof(*blob),MagickMaxBufferExtent,\n                  clone_info->file);\n                (void) image_info->custom_stream->writer(blob,(size_t) count,\n                  image_info->custom_stream->data);\n              }\n            }\n          (void) fclose(clone_info->file);\n        }\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n      (void) RelinquishUniqueFileResource(unique);\n    }\n  clone_info=DestroyImageInfo(clone_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I m a g e T o F i l e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ImageToFile() writes an image to a file.  It returns MagickFalse if an error\n%  occurs otherwise MagickTrue.\n%\n%  The format of the ImageToFile method is:\n%\n%       MagickBooleanType ImageToFile(Image *image,char *filename,\n%         ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o filename: Write the image to this file.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType ImageToFile(Image *image,char *filename,\n  ExceptionInfo *exception)\n{\n  int\n    file;\n\n  register const unsigned char\n    *p;\n\n  register size_t\n    i;\n\n  size_t\n    length,\n    quantum;\n\n  ssize_t\n    count;\n\n  struct stat\n    file_stats;\n\n  unsigned char\n    *buffer;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  assert(filename != (const char *) NULL);\n  if (*filename == '\\0')\n    file=AcquireUniqueFileResource(filename);\n  else\n    if (LocaleCompare(filename,\"-\") == 0)\n      file=fileno(stdout);\n    else\n      file=open_utf8(filename,O_RDWR | O_CREAT | O_EXCL | O_BINARY,S_MODE);\n  if (file == -1)\n    {\n      ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",filename);\n      return(MagickFalse);\n    }\n  quantum=(size_t) MagickMaxBufferExtent;\n  if ((fstat(file,&file_stats) == 0) && (file_stats.st_size > 0))\n    quantum=(size_t) MagickMin(file_stats.st_size,MagickMaxBufferExtent);\n  buffer=(unsigned char *) AcquireQuantumMemory(quantum,sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    {\n      file=close(file)-1;\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationError\",\"`%s'\",filename);\n      return(MagickFalse);\n    }\n  length=0;\n  p=(const unsigned char *) ReadBlobStream(image,quantum,buffer,&count);\n  for (i=0; count > 0; )\n  {\n    length=(size_t) count;\n    for (i=0; i < length; i+=count)\n    {\n      count=write(file,p+i,(size_t) (length-i));\n      if (count <= 0)\n        {\n          count=0;\n          if (errno != EINTR)\n            break;\n        }\n    }\n    if (i < length)\n      break;\n    p=(const unsigned char *) ReadBlobStream(image,quantum,buffer,&count);\n  }\n  if (LocaleCompare(filename,\"-\") != 0)\n    file=close(file);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  if ((file == -1) || (i < length))\n    {\n      if (file != -1)\n        file=close(file);\n      ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",filename);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I m a g e s T o B l o b                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ImagesToBlob() implements direct to memory image formats.  It returns the\n%  image sequence as a blob and its length.  The magick member of the ImageInfo\n%  structure determines the format of the returned blob (GIF, JPEG,  PNG, etc.)\n%\n%  Note, some image formats do not permit multiple images to the same image\n%  stream (e.g. JPEG).  in this instance, just the first image of the\n%  sequence is returned as a blob.\n%\n%  The format of the ImagesToBlob method is:\n%\n%      void *ImagesToBlob(const ImageInfo *image_info,Image *images,\n%        size_t *length,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o images: the image list.\n%\n%    o length: return the actual length of the blob.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport void *ImagesToBlob(const ImageInfo *image_info,Image *images,\n  size_t *length,ExceptionInfo *exception)\n{\n  const MagickInfo\n    *magick_info;\n\n  ImageInfo\n    *clone_info;\n\n  MagickBooleanType\n    status;\n\n  void\n    *blob;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  *length=0;\n  blob=(unsigned char *) NULL;\n  clone_info=CloneImageInfo(image_info);\n  (void) SetImageInfo(clone_info,(unsigned int) GetImageListLength(images),\n    exception);\n  if (*clone_info->magick != '\\0')\n    (void) CopyMagickString(images->magick,clone_info->magick,MagickPathExtent);\n  magick_info=GetMagickInfo(images->magick,exception);\n  if (magick_info == (const MagickInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        MissingDelegateError,\"NoDecodeDelegateForThisImageFormat\",\"`%s'\",\n        images->magick);\n      clone_info=DestroyImageInfo(clone_info);\n      return(blob);\n    }\n  if (GetMagickAdjoin(magick_info) == MagickFalse)\n    {\n      clone_info=DestroyImageInfo(clone_info);\n      return(ImageToBlob(image_info,images,length,exception));\n    }\n  (void) CopyMagickString(clone_info->magick,images->magick,MagickPathExtent);\n  if (GetMagickBlobSupport(magick_info) != MagickFalse)\n    {\n      /*\n        Native blob support for this images format.\n      */\n      clone_info->length=0;\n      clone_info->blob=(void *) AcquireQuantumMemory(MagickMaxBlobExtent,\n        sizeof(unsigned char));\n      if (clone_info->blob == (void *) NULL)\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",images->filename);\n      else\n        {\n          (void) CloseBlob(images);\n          images->blob->exempt=MagickTrue;\n          *images->filename='\\0';\n          status=WriteImages(clone_info,images,images->filename,exception);\n          *length=images->blob->length;\n          blob=DetachBlob(images->blob);\n          if (blob == (void *) NULL)\n            clone_info->blob=RelinquishMagickMemory(clone_info->blob);\n          else if (status == MagickFalse)\n            blob=RelinquishMagickMemory(blob);\n          else\n            blob=ResizeQuantumMemory(blob,*length+1,sizeof(unsigned char));\n        }\n    }\n  else\n    {\n      char\n        filename[MagickPathExtent],\n        unique[MagickPathExtent];\n\n      int\n        file;\n\n      /*\n        Write file to disk in blob images format.\n      */\n      file=AcquireUniqueFileResource(unique);\n      if (file == -1)\n        {\n          ThrowFileException(exception,FileOpenError,\"UnableToWriteBlob\",\n            image_info->filename);\n        }\n      else\n        {\n          clone_info->file=fdopen(file,\"wb\");\n          if (clone_info->file != (FILE *) NULL)\n            {\n              (void) FormatLocaleString(filename,MagickPathExtent,\"%s:%s\",\n                images->magick,unique);\n              status=WriteImages(clone_info,images,filename,exception);\n              (void) CloseBlob(images);\n              (void) fclose(clone_info->file);\n              if (status != MagickFalse)\n                blob=FileToBlob(unique,~0UL,length,exception);\n            }\n          (void) RelinquishUniqueFileResource(unique);\n        }\n    }\n  clone_info=DestroyImageInfo(clone_info);\n  return(blob);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  I m a g e s T o C u s t o m B l o b                                        %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ImagesToCustomStream() is the equivalent of WriteImages(), but writes the\n%  formatted \"file\" to the custom stream rather than to an actual file.\n%\n%  The format of the ImageToCustomStream method is:\n%\n%      void ImagesToCustomStream(const ImageInfo *image_info,Image *images,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o images: the image list.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport void ImagesToCustomStream(const ImageInfo *image_info,\n  Image *images,ExceptionInfo *exception)\n{\n  const MagickInfo\n    *magick_info;\n\n  ImageInfo\n    *clone_info;\n\n  MagickBooleanType\n    blob_support,\n    status;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  assert(image_info->custom_stream != (CustomStreamInfo *) NULL);\n  assert(image_info->custom_stream->signature == MagickCoreSignature);\n  assert(image_info->custom_stream->reader != (CustomStreamHandler) NULL);\n  assert(image_info->custom_stream->writer != (CustomStreamHandler) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  clone_info=CloneImageInfo(image_info);\n  (void) SetImageInfo(clone_info,(unsigned int) GetImageListLength(images),\n    exception);\n  if (*clone_info->magick != '\\0')\n    (void) CopyMagickString(images->magick,clone_info->magick,MagickPathExtent);\n  magick_info=GetMagickInfo(images->magick,exception);\n  if (magick_info == (const MagickInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        MissingDelegateError,\"NoEncodeDelegateForThisImageFormat\",\"`%s'\",\n        images->magick);\n      clone_info=DestroyImageInfo(clone_info);\n      return;\n    }\n  (void) CopyMagickString(clone_info->magick,images->magick,MagickPathExtent);\n  blob_support=GetMagickBlobSupport(magick_info);\n  if ((blob_support != MagickFalse) &&\n      (GetMagickEncoderSeekableStream(magick_info) != MagickFalse))\n    {\n      if ((clone_info->custom_stream->seeker == (CustomStreamSeeker) NULL) ||\n          (clone_info->custom_stream->teller == (CustomStreamTeller) NULL))\n        blob_support=MagickFalse;\n    }\n  if (blob_support != MagickFalse)\n    {\n      /*\n        Native blob support for this image format.\n      */\n      (void) CloseBlob(images);\n      *images->filename='\\0';\n      (void) WriteImages(clone_info,images,images->filename,exception);\n      (void) CloseBlob(images);\n    }\n  else\n    {\n      char\n        filename[MagickPathExtent],\n        unique[MagickPathExtent];\n\n      int\n        file;\n\n      unsigned char\n        *blob;\n\n      /*\n        Write file to disk in blob image format.\n      */\n      clone_info->custom_stream=(CustomStreamInfo *) NULL;\n      blob=(unsigned char *) AcquireQuantumMemory(MagickMaxBufferExtent,\n        sizeof(*blob));\n      if (blob == (unsigned char *) NULL)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",\n            image_info->filename);\n          clone_info=DestroyImageInfo(clone_info);\n          return;\n        }\n      file=AcquireUniqueFileResource(unique);\n      if (file == -1)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",\n            image_info->filename);\n          blob=(unsigned char *) RelinquishMagickMemory(blob);\n          clone_info=DestroyImageInfo(clone_info);\n          return;\n        }\n      clone_info->file=fdopen(file,\"wb+\");\n      if (clone_info->file != (FILE *) NULL)\n        {\n          ssize_t\n            count;\n\n          (void) FormatLocaleString(filename,MagickPathExtent,\"%s:%s\",\n            images->magick,unique);\n          status=WriteImages(clone_info,images,filename,exception);\n          (void) CloseBlob(images);\n          if (status != MagickFalse)\n            {\n              (void) fseek(clone_info->file,0,SEEK_SET);\n              count=(ssize_t) MagickMaxBufferExtent;\n              while (count == (ssize_t) MagickMaxBufferExtent)\n              {\n                count=(ssize_t) fread(blob,sizeof(*blob),MagickMaxBufferExtent,\n                  clone_info->file);\n                (void) image_info->custom_stream->writer(blob,(size_t) count,\n                  image_info->custom_stream->data);\n              }\n            }\n          (void) fclose(clone_info->file);\n        }\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n      (void) RelinquishUniqueFileResource(unique);\n    }\n  clone_info=DestroyImageInfo(clone_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I n j e c t I m a g e B l o b                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InjectImageBlob() injects the image with a copy of itself in the specified\n%  format (e.g. inject JPEG into a PDF image).\n%\n%  The format of the InjectImageBlob method is:\n%\n%      MagickBooleanType InjectImageBlob(const ImageInfo *image_info,\n%        Image *image,Image *inject_image,const char *format,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info..\n%\n%    o image: the image.\n%\n%    o inject_image: inject into the image stream.\n%\n%    o format: the image format.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType InjectImageBlob(const ImageInfo *image_info,\n  Image *image,Image *inject_image,const char *format,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *unique_file;\n\n  Image\n    *byte_image;\n\n  ImageInfo\n    *write_info;\n\n  int\n    file;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    quantum;\n\n  ssize_t\n    count;\n\n  struct stat\n    file_stats;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Write inject image to a temporary file.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(inject_image != (Image *) NULL);\n  assert(inject_image->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  unique_file=(FILE *) NULL;\n  file=AcquireUniqueFileResource(filename);\n  if (file != -1)\n    unique_file=fdopen(file,\"wb\");\n  if ((file == -1) || (unique_file == (FILE *) NULL))\n    {\n      (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  byte_image=CloneImage(inject_image,0,0,MagickFalse,exception);\n  if (byte_image == (Image *) NULL)\n    {\n      (void) fclose(unique_file);\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleString(byte_image->filename,MagickPathExtent,\"%s:%s\",\n    format,filename);\n  DestroyBlob(byte_image);\n  byte_image->blob=CloneBlobInfo((BlobInfo *) NULL);\n  write_info=CloneImageInfo(image_info);\n  SetImageInfoFile(write_info,unique_file);\n  status=WriteImage(write_info,byte_image,exception);\n  write_info=DestroyImageInfo(write_info);\n  byte_image=DestroyImage(byte_image);\n  (void) fclose(unique_file);\n  if (status == MagickFalse)\n    {\n      (void) RelinquishUniqueFileResource(filename);\n      return(MagickFalse);\n    }\n  /*\n    Inject into image stream.\n  */\n  file=open_utf8(filename,O_RDONLY | O_BINARY,0);\n  if (file == -1)\n    {\n      (void) RelinquishUniqueFileResource(filename);\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      return(MagickFalse);\n    }\n  quantum=(size_t) MagickMaxBufferExtent;\n  if ((fstat(file,&file_stats) == 0) && (file_stats.st_size > 0))\n    quantum=(size_t) MagickMin(file_stats.st_size,MagickMaxBufferExtent);\n  buffer=(unsigned char *) AcquireQuantumMemory(quantum,sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(filename);\n      file=close(file);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  for (i=0; ; i+=count)\n  {\n    count=read(file,buffer,quantum);\n    if (count <= 0)\n      {\n        count=0;\n        if (errno != EINTR)\n          break;\n      }\n    status=WriteBlobStream(image,(size_t) count,buffer) == count ? MagickTrue :\n      MagickFalse;\n  }\n  file=close(file);\n  if (file == -1)\n    ThrowFileException(exception,FileOpenError,\"UnableToWriteBlob\",filename);\n  (void) RelinquishUniqueFileResource(filename);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s B l o b E x e m p t                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsBlobExempt() returns true if the blob is exempt.\n%\n%  The format of the IsBlobExempt method is:\n%\n%       MagickBooleanType IsBlobExempt(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType IsBlobExempt(const Image *image)\n{\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  return(image->blob->exempt);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s B l o b S e e k a b l e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsBlobSeekable() returns true if the blob is seekable.\n%\n%  The format of the IsBlobSeekable method is:\n%\n%       MagickBooleanType IsBlobSeekable(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType IsBlobSeekable(const Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  blob_info=image->blob;\n  switch (blob_info->type)\n  {\n    case BlobStream:\n      return(MagickTrue);\n    case FileStream:\n    {\n      int\n        status;\n\n      if (blob_info->file_info.file == (FILE *) NULL)\n        return(MagickFalse);\n      status=fseek(blob_info->file_info.file,0,SEEK_CUR);\n      return(status == -1 ? MagickFalse : MagickTrue);\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      MagickOffsetType\n        offset;\n\n      if (blob_info->file_info.gzfile == (gzFile) NULL)\n        return(MagickFalse);\n      offset=gzseek(blob_info->file_info.gzfile,0,SEEK_CUR);\n      return(offset < 0 ? MagickFalse : MagickTrue);\n#else\n      break;\n#endif\n    }\n    case UndefinedStream:\n    case BZipStream:\n    case FifoStream:\n    case PipeStream:\n    case StandardStream:\n      break;\n    case CustomStream:\n    {\n      if ((blob_info->custom_stream->seeker != (CustomStreamSeeker) NULL) &&\n          (blob_info->custom_stream->teller != (CustomStreamTeller) NULL))\n        return(MagickTrue);\n      break;\n    }\n    default:\n      break;\n  }\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s B l o b T e m p o r a r y                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsBlobTemporary() returns true if the blob is temporary.\n%\n%  The format of the IsBlobTemporary method is:\n%\n%       MagickBooleanType IsBlobTemporary(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType IsBlobTemporary(const Image *image)\n{\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  return(image->blob->temporary);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  M a p B l o b                                                              %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MapBlob() creates a mapping from a file to a binary large object.\n%\n%  The format of the MapBlob method is:\n%\n%      void *MapBlob(int file,const MapMode mode,const MagickOffsetType offset,\n%        const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o file: map this file descriptor.\n%\n%    o mode: ReadMode, WriteMode, or IOMode.\n%\n%    o offset: starting at this offset within the file.\n%\n%    o length: the length of the mapping is returned in this pointer.\n%\n*/\nMagickExport void *MapBlob(int file,const MapMode mode,\n  const MagickOffsetType offset,const size_t length)\n{\n#if defined(MAGICKCORE_HAVE_MMAP)\n  int\n    flags,\n    protection;\n\n  void\n    *map;\n\n  /*\n    Map file.\n  */\n  flags=0;\n  if (file == -1)\n#if defined(MAP_ANONYMOUS)\n    flags|=MAP_ANONYMOUS;\n#else\n    return(NULL);\n#endif\n  switch (mode)\n  {\n    case ReadMode:\n    default:\n    {\n      protection=PROT_READ;\n      flags|=MAP_PRIVATE;\n      break;\n    }\n    case WriteMode:\n    {\n      protection=PROT_WRITE;\n      flags|=MAP_SHARED;\n      break;\n    }\n    case IOMode:\n    {\n      protection=PROT_READ | PROT_WRITE;\n      flags|=MAP_SHARED;\n      break;\n    }\n  }\n#if !defined(MAGICKCORE_HAVE_HUGEPAGES) || !defined(MAP_HUGETLB)\n  map=mmap((char *) NULL,length,protection,flags,file,offset);\n#else\n  map=mmap((char *) NULL,length,protection,flags | MAP_HUGETLB,file,offset);\n  if (map == MAP_FAILED)\n    map=mmap((char *) NULL,length,protection,flags,file,offset);\n#endif\n  if (map == MAP_FAILED)\n    return(NULL);\n  return(map);\n#else\n  (void) file;\n  (void) mode;\n  (void) offset;\n  (void) length;\n  return(NULL);\n#endif\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  M S B O r d e r L o n g                                                    %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MSBOrderLong() converts a least-significant byte first buffer of integers to\n%  most-significant byte first.\n%\n%  The format of the MSBOrderLong method is:\n%\n%      void MSBOrderLong(unsigned char *buffer,const size_t length)\n%\n%  A description of each parameter follows.\n%\n%   o  buffer:  Specifies a pointer to a buffer of integers.\n%\n%   o  length:  Specifies the length of the buffer.\n%\n*/\nMagickExport void MSBOrderLong(unsigned char *buffer,const size_t length)\n{\n  int\n    c;\n\n  register unsigned char\n    *p,\n    *q;\n\n  assert(buffer != (unsigned char *) NULL);\n  q=buffer+length;\n  while (buffer < q)\n  {\n    p=buffer+3;\n    c=(int) (*p);\n    *p=(*buffer);\n    *buffer++=(unsigned char) c;\n    p=buffer+1;\n    c=(int) (*p);\n    *p=(*buffer);\n    *buffer++=(unsigned char) c;\n    buffer+=2;\n  }\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  M S B O r d e r S h o r t                                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MSBOrderShort() converts a least-significant byte first buffer of integers\n%  to most-significant byte first.\n%\n%  The format of the MSBOrderShort method is:\n%\n%      void MSBOrderShort(unsigned char *p,const size_t length)\n%\n%  A description of each parameter follows.\n%\n%   o  p:  Specifies a pointer to a buffer of integers.\n%\n%   o  length:  Specifies the length of the buffer.\n%\n*/\nMagickExport void MSBOrderShort(unsigned char *p,const size_t length)\n{\n  int\n    c;\n\n  register unsigned char\n    *q;\n\n  assert(p != (unsigned char *) NULL);\n  q=p+length;\n  while (p < q)\n  {\n    c=(int) (*p);\n    *p=(*(p+1));\n    p++;\n    *p++=(unsigned char) c;\n  }\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   O p e n B l o b                                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  OpenBlob() opens a file associated with the image.  A file name of '-' sets\n%  the file to stdin for type 'r' and stdout for type 'w'.  If the filename\n%  suffix is '.gz' or '.Z', the image is decompressed for type 'r' and\n%  compressed for type 'w'.  If the filename prefix is '|', it is piped to or\n%  from a system command.\n%\n%  The format of the OpenBlob method is:\n%\n%       MagickBooleanType OpenBlob(const ImageInfo *image_info,Image *image,\n%        const BlobMode mode,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o image: the image.\n%\n%    o mode: the mode for opening the file.\n%\n*/\n\nstatic inline MagickBooleanType SetStreamBuffering(const ImageInfo *image_info,\n  Image *image)\n{\n  const char\n    *option;\n\n  int\n    status;\n\n  size_t\n    size;\n\n  size=16384;\n  option=GetImageOption(image_info,\"stream:buffer-size\");\n  if (option != (const char *) NULL)\n    size=StringToUnsignedLong(option);\n  status=setvbuf(image->blob->file_info.file,(char *) NULL,size == 0 ?\n    _IONBF : _IOFBF,size);\n  return(status == 0 ? MagickTrue : MagickFalse);\n}\n\nMagickExport MagickBooleanType OpenBlob(const ImageInfo *image_info,\n  Image *image,const BlobMode mode,ExceptionInfo *exception)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  char\n    extension[MagickPathExtent],\n    filename[MagickPathExtent];\n\n  const char\n    *type;\n\n  MagickBooleanType\n    status;\n\n  PolicyRights\n    rights;\n\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  blob_info=image->blob;\n  if (image_info->blob != (void *) NULL)\n    {\n      if (image_info->stream != (StreamHandler) NULL)\n        blob_info->stream=(StreamHandler) image_info->stream;\n      AttachBlob(blob_info,image_info->blob,image_info->length);\n      return(MagickTrue);\n    }\n  if ((image_info->custom_stream != (CustomStreamInfo *) NULL) &&\n      (*image->filename == '\\0'))\n    {\n      blob_info->type=CustomStream;\n      blob_info->custom_stream=image_info->custom_stream;\n      return(MagickTrue);\n    }\n  (void) DetachBlob(blob_info);\n  blob_info->mode=mode;\n  switch (mode)\n  {\n    default: type=\"r\"; break;\n    case ReadBlobMode: type=\"r\"; break;\n    case ReadBinaryBlobMode: type=\"rb\"; break;\n    case WriteBlobMode: type=\"w\"; break;\n    case WriteBinaryBlobMode: type=\"w+b\"; break;\n    case AppendBlobMode: type=\"a\"; break;\n    case AppendBinaryBlobMode: type=\"a+b\"; break;\n  }\n  if (*type != 'r')\n    blob_info->synchronize=image_info->synchronize;\n  if (image_info->stream != (StreamHandler) NULL)\n    {\n      blob_info->stream=image_info->stream;\n      if (*type == 'w')\n        {\n          blob_info->type=FifoStream;\n          return(MagickTrue);\n        }\n    }\n  /*\n    Open image file.\n  */\n  *filename='\\0';\n  (void) CopyMagickString(filename,image->filename,MagickPathExtent);\n  rights=ReadPolicyRights;\n  if (*type == 'w')\n    rights=WritePolicyRights;\n  if (IsRightsAuthorized(PathPolicyDomain,rights,filename) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",filename);\n      return(MagickFalse);\n    }\n  if ((LocaleCompare(filename,\"-\") == 0) ||\n      ((*filename == '\\0') && (image_info->file == (FILE *) NULL)))\n    {\n      blob_info->file_info.file=(*type == 'r') ? stdin : stdout;\n#if defined(MAGICKCORE_WINDOWS_SUPPORT) || defined(__OS2__)\n      if (strchr(type,'b') != (char *) NULL)\n        setmode(fileno(blob_info->file_info.file),_O_BINARY);\n#endif\n      blob_info->type=StandardStream;\n      blob_info->exempt=MagickTrue;\n      return(SetStreamBuffering(image_info,image));\n    }\n  if ((LocaleNCompare(filename,\"fd:\",3) == 0) &&\n      (IsGeometry(filename+3) != MagickFalse))\n    {\n      char\n        fileMode[MagickPathExtent];\n\n      *fileMode =(*type);\n      fileMode[1]='\\0';\n      blob_info->file_info.file=fdopen(StringToLong(filename+3),fileMode);\n      if (blob_info->file_info.file == (FILE *) NULL)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n          return(MagickFalse);\n        }\n#if defined(MAGICKCORE_WINDOWS_SUPPORT) || defined(__OS2__)\n      if (strchr(type,'b') != (char *) NULL)\n        setmode(fileno(blob_info->file_info.file),_O_BINARY);\n#endif\n      blob_info->type=FileStream;\n      blob_info->exempt=MagickTrue;\n      return(SetStreamBuffering(image_info,image));\n    }\n#if defined(MAGICKCORE_HAVE_POPEN) && defined(MAGICKCORE_PIPES_SUPPORT)\n  if (*filename == '|')\n    {\n      char\n        fileMode[MagickPathExtent],\n        *sanitize_command;\n\n      /*\n        Pipe image to or from a system command.\n      */\n#if defined(SIGPIPE)\n      if (*type == 'w')\n        (void) signal(SIGPIPE,SIG_IGN);\n#endif\n      *fileMode =(*type);\n      fileMode[1]='\\0';\n      sanitize_command=SanitizeString(filename+1);\n      blob_info->file_info.file=(FILE *) popen_utf8(sanitize_command,fileMode);\n      sanitize_command=DestroyString(sanitize_command);\n      if (blob_info->file_info.file == (FILE *) NULL)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n          return(MagickFalse);\n        }\n      blob_info->type=PipeStream;\n      blob_info->exempt=MagickTrue;\n      return(SetStreamBuffering(image_info,image));\n    }\n#endif\n  status=GetPathAttributes(filename,&blob_info->properties);\n#if defined(S_ISFIFO)\n  if ((status != MagickFalse) && S_ISFIFO(blob_info->properties.st_mode))\n    {\n      blob_info->file_info.file=(FILE *) fopen_utf8(filename,type);\n      if (blob_info->file_info.file == (FILE *) NULL)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n          return(MagickFalse);\n        }\n      blob_info->type=FileStream;\n      blob_info->exempt=MagickTrue;\n      return(SetStreamBuffering(image_info,image));\n    }\n#endif\n  GetPathComponent(image->filename,ExtensionPath,extension);\n  if (*type == 'w')\n    {\n      (void) CopyMagickString(filename,image->filename,MagickPathExtent);\n      if ((image_info->adjoin == MagickFalse) ||\n          (strchr(filename,'%') != (char *) NULL))\n        {\n          /*\n            Form filename for multi-part images.\n          */\n          (void) InterpretImageFilename(image_info,image,image->filename,(int)\n            image->scene,filename,exception);\n          if ((LocaleCompare(filename,image->filename) == 0) &&\n              ((GetPreviousImageInList(image) != (Image *) NULL) ||\n               (GetNextImageInList(image) != (Image *) NULL)))\n            {\n              char\n                path[MagickPathExtent];\n\n              GetPathComponent(image->filename,RootPath,path);\n              if (*extension == '\\0')\n                (void) FormatLocaleString(filename,MagickPathExtent,\"%s-%.20g\",\n                  path,(double) image->scene);\n              else\n                (void) FormatLocaleString(filename,MagickPathExtent,\n                  \"%s-%.20g.%s\",path,(double) image->scene,extension);\n            }\n          (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n#if defined(macintosh)\n          SetApplicationType(filename,image_info->magick,'8BIM');\n#endif\n        }\n    }\n  if (image_info->file != (FILE *) NULL)\n    {\n      blob_info->file_info.file=image_info->file;\n      blob_info->type=FileStream;\n      blob_info->exempt=MagickTrue;\n    }\n  else\n    if (*type == 'r')\n      {\n        blob_info->file_info.file=(FILE *) fopen_utf8(filename,type);\n        if (blob_info->file_info.file != (FILE *) NULL)\n          {\n            size_t\n              count;\n\n            unsigned char\n              magick[3];\n\n            blob_info->type=FileStream;\n            (void) SetStreamBuffering(image_info,image);\n            (void) memset(magick,0,sizeof(magick));\n            count=fread(magick,1,sizeof(magick),blob_info->file_info.file);\n            (void) fseek(blob_info->file_info.file,-((off_t) count),SEEK_CUR);\n#if defined(MAGICKCORE_POSIX_SUPPORT)\n            (void) fflush(blob_info->file_info.file);\n#endif\n            (void) LogMagickEvent(BlobEvent,GetMagickModule(),\n               \"  read %.20g magic header bytes\",(double) count);\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (((int) magick[0] == 0x1F) && ((int) magick[1] == 0x8B) &&\n                ((int) magick[2] == 0x08))\n              {\n                if (blob_info->file_info.file != (FILE *) NULL)\n                  (void) fclose(blob_info->file_info.file);\n                blob_info->file_info.file=(FILE *) NULL;\n                blob_info->file_info.gzfile=gzopen(filename,\"rb\");\n                if (blob_info->file_info.gzfile != (gzFile) NULL)\n                  blob_info->type=ZipStream;\n               }\n#endif\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n            if (strncmp((char *) magick,\"BZh\",3) == 0)\n              {\n                if (blob_info->file_info.file != (FILE *) NULL)\n                  (void) fclose(blob_info->file_info.file);\n                blob_info->file_info.file=(FILE *) NULL;\n                blob_info->file_info.bzfile=BZ2_bzopen(filename,\"r\");\n                if (blob_info->file_info.bzfile != (BZFILE *) NULL)\n                  blob_info->type=BZipStream;\n              }\n#endif\n            if (blob_info->type == FileStream)\n              {\n                const MagickInfo\n                  *magick_info;\n\n                ExceptionInfo\n                  *sans_exception;\n\n                size_t\n                  length;\n\n                sans_exception=AcquireExceptionInfo();\n                magick_info=GetMagickInfo(image_info->magick,sans_exception);\n                sans_exception=DestroyExceptionInfo(sans_exception);\n                length=(size_t) blob_info->properties.st_size;\n                if ((magick_info != (const MagickInfo *) NULL) &&\n                    (GetMagickBlobSupport(magick_info) != MagickFalse) &&\n                    (length > MagickMaxBufferExtent) &&\n                    (AcquireMagickResource(MapResource,length) != MagickFalse))\n                  {\n                    void\n                      *blob;\n\n                    blob=MapBlob(fileno(blob_info->file_info.file),ReadMode,0,\n                      length);\n                    if (blob == (void *) NULL)\n                      RelinquishMagickResource(MapResource,length);\n                    else\n                      {\n                        /*\n                          Format supports blobs-- use memory-mapped I/O.\n                        */\n                        if (image_info->file != (FILE *) NULL)\n                          blob_info->exempt=MagickFalse;\n                        else\n                          {\n                            (void) fclose(blob_info->file_info.file);\n                            blob_info->file_info.file=(FILE *) NULL;\n                          }\n                        AttachBlob(blob_info,blob,length);\n                        blob_info->mapped=MagickTrue;\n                      }\n                  }\n              }\n          }\n        }\n      else\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n        if ((LocaleCompare(extension,\"Z\") == 0) ||\n            (LocaleCompare(extension,\"gz\") == 0) ||\n            (LocaleCompare(extension,\"wmz\") == 0) ||\n            (LocaleCompare(extension,\"svgz\") == 0))\n          {\n            blob_info->file_info.gzfile=gzopen(filename,\"wb\");\n            if (blob_info->file_info.gzfile != (gzFile) NULL)\n              blob_info->type=ZipStream;\n          }\n        else\n#endif\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n          if (LocaleCompare(extension,\"bz2\") == 0)\n            {\n              blob_info->file_info.bzfile=BZ2_bzopen(filename,\"w\");\n              if (blob_info->file_info.bzfile != (BZFILE *) NULL)\n                blob_info->type=BZipStream;\n            }\n          else\n#endif\n            {\n              blob_info->file_info.file=(FILE *) fopen_utf8(filename,type);\n              if (blob_info->file_info.file != (FILE *) NULL)\n                {\n                  blob_info->type=FileStream;\n                  (void) SetStreamBuffering(image_info,image);\n                }\n       }\n  blob_info->status=MagickFalse;\n  if (blob_info->type != UndefinedStream)\n    blob_info->size=GetBlobSize(image);\n  else\n    {\n      ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   P i n g B l o b                                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PingBlob() returns all the attributes of an image or image sequence except\n%  for the pixels.  It is much faster and consumes far less memory than\n%  BlobToImage().  On failure, a NULL image is returned and exception\n%  describes the reason for the failure.\n%\n%  The format of the PingBlob method is:\n%\n%      Image *PingBlob(const ImageInfo *image_info,const void *blob,\n%        const size_t length,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o blob: the address of a character stream in one of the image formats\n%      understood by ImageMagick.\n%\n%    o length: This size_t integer reflects the length in bytes of the blob.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic size_t PingStream(const Image *magick_unused(image),\n  const void *magick_unused(pixels),const size_t columns)\n{\n  magick_unreferenced(image);\n  magick_unreferenced(pixels);\n  return(columns);\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nMagickExport Image *PingBlob(const ImageInfo *image_info,const void *blob,\n  const size_t length,ExceptionInfo *exception)\n{\n  const MagickInfo\n    *magick_info;\n\n  Image\n    *image;\n\n  ImageInfo\n    *clone_info,\n    *ping_info;\n\n  MagickBooleanType\n    status;\n\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  if ((blob == (const void *) NULL) || (length == 0))\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),BlobError,\n        \"ZeroLengthBlobNotPermitted\",\"`%s'\",image_info->filename);\n      return((Image *) NULL);\n    }\n  ping_info=CloneImageInfo(image_info);\n  ping_info->blob=(void *) blob;\n  ping_info->length=length;\n  ping_info->ping=MagickTrue;\n  if (*ping_info->magick == '\\0')\n    (void) SetImageInfo(ping_info,0,exception);\n  magick_info=GetMagickInfo(ping_info->magick,exception);\n  if (magick_info == (const MagickInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        MissingDelegateError,\"NoDecodeDelegateForThisImageFormat\",\"`%s'\",\n        ping_info->magick);\n      ping_info=DestroyImageInfo(ping_info);\n      return((Image *) NULL);\n    }\n  if (GetMagickBlobSupport(magick_info) != MagickFalse)\n    {\n      char\n        filename[MagickPathExtent];\n\n      /*\n        Native blob support for this image format.\n      */\n      (void) CopyMagickString(filename,ping_info->filename,MagickPathExtent);\n      (void) FormatLocaleString(ping_info->filename,MagickPathExtent,\"%s:%s\",\n        ping_info->magick,filename);\n      image=ReadStream(ping_info,&PingStream,exception);\n      if (image != (Image *) NULL)\n        (void) DetachBlob(image->blob);\n      ping_info=DestroyImageInfo(ping_info);\n      return(image);\n    }\n  /*\n    Write blob to a temporary file on disk.\n  */\n  ping_info->blob=(void *) NULL;\n  ping_info->length=0;\n  *ping_info->filename='\\0';\n  status=BlobToFile(ping_info->filename,blob,length,exception);\n  if (status == MagickFalse)\n    {\n      (void) RelinquishUniqueFileResource(ping_info->filename);\n      ping_info=DestroyImageInfo(ping_info);\n      return((Image *) NULL);\n    }\n  clone_info=CloneImageInfo(ping_info);\n  (void) FormatLocaleString(clone_info->filename,MagickPathExtent,\"%s:%s\",\n    ping_info->magick,ping_info->filename);\n  image=ReadStream(clone_info,&PingStream,exception);\n  if (image != (Image *) NULL)\n    {\n      Image\n        *images;\n\n      /*\n        Restore original filenames and image format.\n      */\n      for (images=GetFirstImageInList(image); images != (Image *) NULL; )\n      {\n        (void) CopyMagickString(images->filename,image_info->filename,\n          MagickPathExtent);\n        (void) CopyMagickString(images->magick_filename,image_info->filename,\n          MagickPathExtent);\n        (void) CopyMagickString(images->magick,magick_info->name,\n          MagickPathExtent);\n        images=GetNextImageInList(images);\n      }\n    }\n  clone_info=DestroyImageInfo(clone_info);\n  (void) RelinquishUniqueFileResource(ping_info->filename);\n  ping_info=DestroyImageInfo(ping_info);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b                                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlob() reads data from the blob or image file and returns it.  It\n%  returns the number of bytes read. If length is zero, ReadBlob() returns\n%  zero and has no other results. If length is greater than SSIZE_MAX, the\n%  result is unspecified.\n%\n%  The format of the ReadBlob method is:\n%\n%      ssize_t ReadBlob(Image *image,const size_t length,void *data)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o length:  Specifies an integer representing the number of bytes to read\n%      from the file.\n%\n%    o data:  Specifies an area to place the information requested from the\n%      file.\n%\n*/\nMagickExport ssize_t ReadBlob(Image *image,const size_t length,void *data)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  int\n    c;\n\n  register unsigned char\n    *q;\n\n  ssize_t\n    count;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  if (length == 0)\n    return(0);\n  assert(data != (void *) NULL);\n  blob_info=image->blob;\n  count=0;\n  q=(unsigned char *) data;\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n      break;\n    case StandardStream:\n    case FileStream:\n    case PipeStream:\n    {\n      switch (length)\n      {\n        default:\n        {\n          count=(ssize_t) fread(q,1,length,blob_info->file_info.file);\n          break;\n        }\n        case 4:\n        {\n          c=getc(blob_info->file_info.file);\n          if (c == EOF)\n            break;\n          *q++=(unsigned char) c;\n          count++;\n        }\n        case 3:\n        {\n          c=getc(blob_info->file_info.file);\n          if (c == EOF)\n            break;\n          *q++=(unsigned char) c;\n          count++;\n        }\n        case 2:\n        {\n          c=getc(blob_info->file_info.file);\n          if (c == EOF)\n            break;\n          *q++=(unsigned char) c;\n          count++;\n        }\n        case 1:\n        {\n          c=getc(blob_info->file_info.file);\n          if (c == EOF)\n            break;\n          *q++=(unsigned char) c;\n          count++;\n        }\n        case 0:\n          break;\n      }\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      switch (length)\n      {\n        default:\n        {\n          register ssize_t\n            i;\n\n          for (i=0; i < (ssize_t) length; i+=count)\n          {\n            count=(ssize_t) gzread(blob_info->file_info.gzfile,q+i,\n              (unsigned int) MagickMin(length-i,MagickMaxBufferExtent));\n            if (count <= 0)\n              {\n                count=0;\n                if (errno != EINTR)\n                  break;\n              }\n          }\n          count=i;\n          break;\n        }\n        case 4:\n        {\n          c=gzgetc(blob_info->file_info.gzfile);\n          if (c == EOF)\n            break;\n          *q++=(unsigned char) c;\n          count++;\n        }\n        case 3:\n        {\n          c=gzgetc(blob_info->file_info.gzfile);\n          if (c == EOF)\n            break;\n          *q++=(unsigned char) c;\n          count++;\n        }\n        case 2:\n        {\n          c=gzgetc(blob_info->file_info.gzfile);\n          if (c == EOF)\n            break;\n          *q++=(unsigned char) c;\n          count++;\n        }\n        case 1:\n        {\n          c=gzgetc(blob_info->file_info.gzfile);\n          if (c == EOF)\n            break;\n          *q++=(unsigned char) c;\n          count++;\n        }\n        case 0:\n          break;\n      }\n#endif\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) length; i+=count)\n      {\n        count=(ssize_t) BZ2_bzread(blob_info->file_info.bzfile,q+i,\n          (unsigned int) MagickMin(length-i,MagickMaxBufferExtent));\n        if (count <= 0)\n          {\n            count=0;\n            if (errno != EINTR)\n              break;\n          }\n      }\n      count=i;\n#endif\n      break;\n    }\n    case FifoStream:\n      break;\n    case BlobStream:\n    {\n      register const unsigned char\n        *p;\n\n      if (blob_info->offset >= (MagickOffsetType) blob_info->length)\n        {\n          blob_info->eof=MagickTrue;\n          break;\n        }\n      p=blob_info->data+blob_info->offset;\n      count=(ssize_t) MagickMin((MagickOffsetType) length,(MagickOffsetType)\n        blob_info->length-blob_info->offset);\n      blob_info->offset+=count;\n      if (count != (ssize_t) length)\n        blob_info->eof=MagickTrue;\n      (void) memcpy(q,p,(size_t) count);\n      break;\n    }\n    case CustomStream:\n    {\n      if (blob_info->custom_stream->reader != (CustomStreamHandler) NULL)\n        count=blob_info->custom_stream->reader(q,length,\n          blob_info->custom_stream->data);\n      break;\n    }\n  }\n  return(count);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b B y t e                                                    %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobByte() reads a single byte from the image file and returns it.\n%\n%  The format of the ReadBlobByte method is:\n%\n%      int ReadBlobByte(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport int ReadBlobByte(Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  register const unsigned char\n    *p;\n\n  unsigned char\n    buffer[1];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  blob_info=image->blob;\n  switch (blob_info->type)\n  {\n    case StandardStream:\n    case FileStream:\n    case PipeStream:\n    {\n      int\n        c;\n\n      p=(const unsigned char *) buffer;\n      c=getc(blob_info->file_info.file);\n      if (c == EOF)\n        return(EOF);\n      *buffer=(unsigned char) c;\n      break;\n    }\n    default:\n    {\n      ssize_t\n        count;\n\n      p=(const unsigned char *) ReadBlobStream(image,1,buffer,&count);\n      if (count != 1)\n        return(EOF);\n      break;\n    }\n  }\n  return((int) (*p));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b D o u b l e                                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobDouble() reads a double value as a 64-bit quantity in the byte-order\n%  specified by the endian member of the image structure.\n%\n%  The format of the ReadBlobDouble method is:\n%\n%      double ReadBlobDouble(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport double ReadBlobDouble(Image *image)\n{\n  union\n  {\n    MagickSizeType\n      unsigned_value;\n\n    double\n      double_value;\n  } quantum;\n\n  quantum.double_value=0.0;\n  quantum.unsigned_value=ReadBlobLongLong(image);\n  return(quantum.double_value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b F l o a t                                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobFloat() reads a float value as a 32-bit quantity in the byte-order\n%  specified by the endian member of the image structure.\n%\n%  The format of the ReadBlobFloat method is:\n%\n%      float ReadBlobFloat(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport float ReadBlobFloat(Image *image)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    float\n      float_value;\n  } quantum;\n\n  quantum.float_value=0.0;\n  quantum.unsigned_value=ReadBlobLong(image);\n  return(quantum.float_value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b L o n g                                                    %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobLong() reads a unsigned int value as a 32-bit quantity in the\n%  byte-order specified by the endian member of the image structure.\n%\n%  The format of the ReadBlobLong method is:\n%\n%      unsigned int ReadBlobLong(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport unsigned int ReadBlobLong(Image *image)\n{\n  register const unsigned char\n    *p;\n\n  ssize_t\n    count;\n\n  unsigned char\n    buffer[4];\n\n  unsigned int\n    value;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  *buffer='\\0';\n  p=(const unsigned char *) ReadBlobStream(image,4,buffer,&count);\n  if (count != 4)\n    return(0UL);\n  if (image->endian == LSBEndian)\n    {\n      value=(unsigned int) (*p++);\n      value|=(unsigned int) (*p++) << 8;\n      value|=(unsigned int) (*p++) << 16;\n      value|=(unsigned int) (*p++) << 24;\n      return(value);\n    }\n  value=(unsigned int) (*p++) << 24;\n  value|=(unsigned int) (*p++) << 16;\n  value|=(unsigned int) (*p++) << 8;\n  value|=(unsigned int) (*p++);\n  return(value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b L o n g L o n g                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobLongLong() reads a long long value as a 64-bit quantity in the\n%  byte-order specified by the endian member of the image structure.\n%\n%  The format of the ReadBlobLongLong method is:\n%\n%      MagickSizeType ReadBlobLongLong(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickSizeType ReadBlobLongLong(Image *image)\n{\n  MagickSizeType\n    value;\n\n  register const unsigned char\n    *p;\n\n  ssize_t\n    count;\n\n  unsigned char\n    buffer[8];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  *buffer='\\0';\n  p=(const unsigned char *) ReadBlobStream(image,8,buffer,&count);\n  if (count != 8)\n    return(MagickULLConstant(0));\n  if (image->endian == LSBEndian)\n    {\n      value=(MagickSizeType) (*p++);\n      value|=(MagickSizeType) (*p++) << 8;\n      value|=(MagickSizeType) (*p++) << 16;\n      value|=(MagickSizeType) (*p++) << 24;\n      value|=(MagickSizeType) (*p++) << 32;\n      value|=(MagickSizeType) (*p++) << 40;\n      value|=(MagickSizeType) (*p++) << 48;\n      value|=(MagickSizeType) (*p++) << 56;\n      return(value);\n    }\n  value=(MagickSizeType) (*p++) << 56;\n  value|=(MagickSizeType) (*p++) << 48;\n  value|=(MagickSizeType) (*p++) << 40;\n  value|=(MagickSizeType) (*p++) << 32;\n  value|=(MagickSizeType) (*p++) << 24;\n  value|=(MagickSizeType) (*p++) << 16;\n  value|=(MagickSizeType) (*p++) << 8;\n  value|=(MagickSizeType) (*p++);\n  return(value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b S h o r t                                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobShort() reads a short value as a 16-bit quantity in the byte-order\n%  specified by the endian member of the image structure.\n%\n%  The format of the ReadBlobShort method is:\n%\n%      unsigned short ReadBlobShort(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport unsigned short ReadBlobShort(Image *image)\n{\n  register const unsigned char\n    *p;\n\n  register unsigned short\n    value;\n\n  ssize_t\n    count;\n\n  unsigned char\n    buffer[2];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  *buffer='\\0';\n  p=(const unsigned char *) ReadBlobStream(image,2,buffer,&count);\n  if (count != 2)\n    return((unsigned short) 0U);\n  if (image->endian == LSBEndian)\n    {\n      value=(unsigned short) (*p++);\n      value|=(unsigned short) (*p++) << 8;\n      return(value);\n    }\n  value=(unsigned short) ((unsigned short) (*p++) << 8);\n  value|=(unsigned short) (*p++);\n  return(value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b L S B L o n g                                              %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobLSBLong() reads a unsigned int value as a 32-bit quantity in\n%  least-significant byte first order.\n%\n%  The format of the ReadBlobLSBLong method is:\n%\n%      unsigned int ReadBlobLSBLong(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport unsigned int ReadBlobLSBLong(Image *image)\n{\n  register const unsigned char\n    *p;\n\n  register unsigned int\n    value;\n\n  ssize_t\n    count;\n\n  unsigned char\n    buffer[4];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  *buffer='\\0';\n  p=(const unsigned char *) ReadBlobStream(image,4,buffer,&count);\n  if (count != 4)\n    return(0U);\n  value=(unsigned int) (*p++);\n  value|=(unsigned int) (*p++) << 8;\n  value|=(unsigned int) (*p++) << 16;\n  value|=(unsigned int) (*p++) << 24;\n  return(value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b L S B S i g n e d L o n g                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobLSBSignedLong() reads a signed int value as a 32-bit quantity in\n%  least-significant byte first order.\n%\n%  The format of the ReadBlobLSBSignedLong method is:\n%\n%      signed int ReadBlobLSBSignedLong(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport signed int ReadBlobLSBSignedLong(Image *image)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  quantum.unsigned_value=ReadBlobLSBLong(image);\n  return(quantum.signed_value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b L S B S h o r t                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobLSBShort() reads a short value as a 16-bit quantity in\n%  least-significant byte first order.\n%\n%  The format of the ReadBlobLSBShort method is:\n%\n%      unsigned short ReadBlobLSBShort(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport unsigned short ReadBlobLSBShort(Image *image)\n{\n  register const unsigned char\n    *p;\n\n  register unsigned short\n    value;\n\n  ssize_t\n    count;\n\n  unsigned char\n    buffer[2];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  *buffer='\\0';\n  p=(const unsigned char *) ReadBlobStream(image,2,buffer,&count);\n  if (count != 2)\n    return((unsigned short) 0U);\n  value=(unsigned short) (*p++);\n  value|=(unsigned short) (*p++) << 8;\n  return(value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b L S B S i g n e d S h o r t                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobLSBSignedShort() reads a signed short value as a 16-bit quantity in\n%  least-significant byte-order.\n%\n%  The format of the ReadBlobLSBSignedShort method is:\n%\n%      signed short ReadBlobLSBSignedShort(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport signed short ReadBlobLSBSignedShort(Image *image)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  quantum.unsigned_value=ReadBlobLSBShort(image);\n  return(quantum.signed_value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b M S B L o n g                                              %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobMSBLong() reads a unsigned int value as a 32-bit quantity in\n%  most-significant byte first order.\n%\n%  The format of the ReadBlobMSBLong method is:\n%\n%      unsigned int ReadBlobMSBLong(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport unsigned int ReadBlobMSBLong(Image *image)\n{\n  register const unsigned char\n    *p;\n\n  register unsigned int\n    value;\n\n  ssize_t\n    count;\n\n  unsigned char\n    buffer[4];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  *buffer='\\0';\n  p=(const unsigned char *) ReadBlobStream(image,4,buffer,&count);\n  if (count != 4)\n    return(0UL);\n  value=(unsigned int) (*p++) << 24;\n  value|=(unsigned int) (*p++) << 16;\n  value|=(unsigned int) (*p++) << 8;\n  value|=(unsigned int) (*p++);\n  return(value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b M S B L o n g L o n g                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobMSBLongLong() reads a unsigned long long value as a 64-bit quantity\n%  in most-significant byte first order.\n%\n%  The format of the ReadBlobMSBLongLong method is:\n%\n%      unsigned int ReadBlobMSBLongLong(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickSizeType ReadBlobMSBLongLong(Image *image)\n{\n  register const unsigned char\n    *p;\n\n  register MagickSizeType\n    value;\n\n  ssize_t\n    count;\n\n  unsigned char\n    buffer[8];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  *buffer='\\0';\n  p=(const unsigned char *) ReadBlobStream(image,8,buffer,&count);\n  if (count != 8)\n    return(MagickULLConstant(0));\n  value=(MagickSizeType) (*p++) << 56;\n  value|=(MagickSizeType) (*p++) << 48;\n  value|=(MagickSizeType) (*p++) << 40;\n  value|=(MagickSizeType) (*p++) << 32;\n  value|=(MagickSizeType) (*p++) << 24;\n  value|=(MagickSizeType) (*p++) << 16;\n  value|=(MagickSizeType) (*p++) << 8;\n  value|=(MagickSizeType) (*p++);\n  return(value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b M S B S h o r t                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobMSBShort() reads a short value as a 16-bit quantity in\n%  most-significant byte first order.\n%\n%  The format of the ReadBlobMSBShort method is:\n%\n%      unsigned short ReadBlobMSBShort(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport unsigned short ReadBlobMSBShort(Image *image)\n{\n  register const unsigned char\n    *p;\n\n  register unsigned short\n    value;\n\n  ssize_t\n    count;\n\n  unsigned char\n    buffer[2];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  *buffer='\\0';\n  p=(const unsigned char *) ReadBlobStream(image,2,buffer,&count);\n  if (count != 2)\n    return((unsigned short) 0U);\n  value=(unsigned short) ((*p++) << 8);\n  value|=(unsigned short) (*p++);\n  return((unsigned short) (value & 0xffff));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b M S B S i g n e d L o n g                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobMSBSignedLong() reads a signed int value as a 32-bit quantity in\n%  most-significant byte-order.\n%\n%  The format of the ReadBlobMSBSignedLong method is:\n%\n%      signed int ReadBlobMSBSignedLong(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport signed int ReadBlobMSBSignedLong(Image *image)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  quantum.unsigned_value=ReadBlobMSBLong(image);\n  return(quantum.signed_value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b M S B S i g n e d S h o r t                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobMSBSignedShort() reads a signed short value as a 16-bit quantity in\n%  most-significant byte-order.\n%\n%  The format of the ReadBlobMSBSignedShort method is:\n%\n%      signed short ReadBlobMSBSignedShort(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport signed short ReadBlobMSBSignedShort(Image *image)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  quantum.unsigned_value=ReadBlobMSBShort(image);\n  return(quantum.signed_value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b S i g n e d L o n g                                        %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobSignedLong() reads a signed int value as a 32-bit quantity in the\n%  byte-order specified by the endian member of the image structure.\n%\n%  The format of the ReadBlobSignedLong method is:\n%\n%      signed int ReadBlobSignedLong(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport signed int ReadBlobSignedLong(Image *image)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  quantum.unsigned_value=ReadBlobLong(image);\n  return(quantum.signed_value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b S i g n e d S h o r t                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobSignedShort() reads a signed short value as a 16-bit quantity in the\n%  byte-order specified by the endian member of the image structure.\n%\n%  The format of the ReadBlobSignedShort method is:\n%\n%      signed short ReadBlobSignedShort(Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n*/\nMagickExport signed short ReadBlobSignedShort(Image *image)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  quantum.unsigned_value=ReadBlobShort(image);\n  return(quantum.signed_value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  R e a d B l o b S t r e a m                                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobStream() reads data from the blob or image file and returns it.  It\n%  returns a pointer to the data buffer you supply or to the image memory\n%  buffer if its supported (zero-copy). If length is zero, ReadBlobStream()\n%  returns a count of zero and has no other results. If length is greater than\n%  SSIZE_MAX, the result is unspecified.\n%\n%  The format of the ReadBlobStream method is:\n%\n%      const void *ReadBlobStream(Image *image,const size_t length,void *data,\n%        ssize_t *count)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o length:  Specifies an integer representing the number of bytes to read\n%      from the file.\n%\n%    o count: returns the number of bytes read.\n%\n%    o data:  Specifies an area to place the information requested from the\n%      file.\n%\n*/\nMagickExport const void *ReadBlobStream(Image *image,const size_t length,\n  void *data,ssize_t *count)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  assert(count != (ssize_t *) NULL);\n  blob_info=image->blob;\n  if (blob_info->type != BlobStream)\n    {\n      assert(data != NULL);\n      *count=ReadBlob(image,length,(unsigned char *) data);\n      return(data);\n    }\n  if (blob_info->offset >= (MagickOffsetType) blob_info->length)\n    {\n      *count=0;\n      blob_info->eof=MagickTrue;\n      return(data);\n    }\n  data=blob_info->data+blob_info->offset;\n  *count=(ssize_t) MagickMin((MagickOffsetType) length,(MagickOffsetType)\n    blob_info->length-blob_info->offset);\n  blob_info->offset+=(*count);\n  if (*count != (ssize_t) length)\n    blob_info->eof=MagickTrue;\n  return(data);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e a d B l o b S t r i n g                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBlobString() reads characters from a blob or file until a newline\n%  character is read or an end-of-file condition is encountered.\n%\n%  The format of the ReadBlobString method is:\n%\n%      char *ReadBlobString(Image *image,char *string)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o string: the address of a character buffer.\n%\n*/\nMagickExport char *ReadBlobString(Image *image,char *string)\n{\n  int\n    c;\n\n  register ssize_t\n    i;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  for (i=0; i < (MagickPathExtent-1L); i++)\n  {\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      {\n        if (i == 0)\n          return((char *) NULL);\n        break;\n      }\n    string[i]=c;\n    if (c == '\\n')\n      {\n        if ((i > 0) && (string[i-1] == '\\r'))\n          i--;\n        break;\n      }\n  }\n  string[i]='\\0';\n  return(string);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e f e r e n c e B l o b                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReferenceBlob() increments the reference count associated with the pixel\n%  blob returning a pointer to the blob.\n%\n%  The format of the ReferenceBlob method is:\n%\n%      BlobInfo ReferenceBlob(BlobInfo *blob_info)\n%\n%  A description of each parameter follows:\n%\n%    o blob_info: the blob_info.\n%\n*/\nMagickExport BlobInfo *ReferenceBlob(BlobInfo *blob)\n{\n  assert(blob != (BlobInfo *) NULL);\n  assert(blob->signature == MagickCoreSignature);\n  if (blob->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  LockSemaphoreInfo(blob->semaphore);\n  blob->reference_count++;\n  UnlockSemaphoreInfo(blob->semaphore);\n  return(blob);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  S e e k B l o b                                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SeekBlob() sets the offset in bytes from the beginning of a blob or file\n%  and returns the resulting offset.\n%\n%  The format of the SeekBlob method is:\n%\n%      MagickOffsetType SeekBlob(Image *image,const MagickOffsetType offset,\n%        const int whence)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o offset:  Specifies an integer representing the offset in bytes.\n%\n%    o whence:  Specifies an integer representing how the offset is\n%      treated relative to the beginning of the blob as follows:\n%\n%        SEEK_SET  Set position equal to offset bytes.\n%        SEEK_CUR  Set position to current location plus offset.\n%        SEEK_END  Set position to EOF plus offset.\n%\n*/\nMagickExport MagickOffsetType SeekBlob(Image *image,\n  const MagickOffsetType offset,const int whence)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  blob_info=image->blob;\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n      break;\n    case StandardStream:\n    case PipeStream:\n      return(-1);\n    case FileStream:\n    {\n      if ((offset < 0) && (whence == SEEK_SET))\n        return(-1);\n      if (fseek(blob_info->file_info.file,offset,whence) < 0)\n        return(-1);\n      blob_info->offset=TellBlob(image);\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      if (gzseek(blob_info->file_info.gzfile,offset,whence) < 0)\n        return(-1);\n#endif\n      blob_info->offset=TellBlob(image);\n      break;\n    }\n    case BZipStream:\n      return(-1);\n    case FifoStream:\n      return(-1);\n    case BlobStream:\n    {\n      switch (whence)\n      {\n        case SEEK_SET:\n        default:\n        {\n          if (offset < 0)\n            return(-1);\n          blob_info->offset=offset;\n          break;\n        }\n        case SEEK_CUR:\n        {\n          if (((offset > 0) && (blob_info->offset > (SSIZE_MAX-offset))) ||\n              ((offset < 0) && (blob_info->offset < (-SSIZE_MAX-offset))))\n            {\n              errno=EOVERFLOW;\n              return(-1);\n            }\n          if ((blob_info->offset+offset) < 0)\n            return(-1);\n          blob_info->offset+=offset;\n          break;\n        }\n        case SEEK_END:\n        {\n          if (((MagickOffsetType) blob_info->length+offset) < 0)\n            return(-1);\n          blob_info->offset=blob_info->length+offset;\n          break;\n        }\n      }\n      if (blob_info->offset < (MagickOffsetType) ((off_t) blob_info->length))\n        {\n          blob_info->eof=MagickFalse;\n          break;\n        }\n      if (blob_info->offset >= (MagickOffsetType) ((off_t) blob_info->extent))\n        return(-1);\n      break;\n    }\n    case CustomStream:\n    {\n      if (blob_info->custom_stream->seeker == (CustomStreamSeeker) NULL)\n        return(-1);\n      blob_info->offset=blob_info->custom_stream->seeker(offset,whence,\n        blob_info->custom_stream->data);\n      break;\n    }\n  }\n  return(blob_info->offset);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S e t B l o b E x e m p t                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetBlobExempt() sets the blob exempt status.\n%\n%  The format of the SetBlobExempt method is:\n%\n%      MagickBooleanType SetBlobExempt(const Image *image,\n%        const MagickBooleanType exempt)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exempt: Set to true if this blob is exempt from being closed.\n%\n*/\nMagickExport void SetBlobExempt(Image *image,const MagickBooleanType exempt)\n{\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  image->blob->exempt=exempt;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  S e t B l o b E x t e n t                                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetBlobExtent() ensures enough space is allocated for the blob.  If the\n%  method is successful, subsequent writes to bytes in the specified range are\n%  guaranteed not to fail.\n%\n%  The format of the SetBlobExtent method is:\n%\n%      MagickBooleanType SetBlobExtent(Image *image,const MagickSizeType extent)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o extent:  the blob maximum extent.\n%\n*/\nMagickExport MagickBooleanType SetBlobExtent(Image *image,\n  const MagickSizeType extent)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  blob_info=image->blob;\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n      break;\n    case StandardStream:\n      return(MagickFalse);\n    case FileStream:\n    {\n      MagickOffsetType\n        offset;\n\n      ssize_t\n        count;\n\n      if (extent != (MagickSizeType) ((off_t) extent))\n        return(MagickFalse);\n      offset=SeekBlob(image,0,SEEK_END);\n      if (offset < 0)\n        return(MagickFalse);\n      if ((MagickSizeType) offset >= extent)\n        break;\n      offset=SeekBlob(image,(MagickOffsetType) extent-1,SEEK_SET);\n      if (offset < 0)\n        break;\n      count=(ssize_t) fwrite((const unsigned char *) \"\",1,1,\n        blob_info->file_info.file);\n#if defined(MAGICKCORE_HAVE_POSIX_FALLOCATE)\n      if (blob_info->synchronize != MagickFalse)\n        {\n          int\n            file;\n\n          file=fileno(blob_info->file_info.file);\n          if ((file == -1) || (offset < 0))\n            return(MagickFalse);\n          (void) posix_fallocate(file,offset,extent-offset);\n        }\n#endif\n      offset=SeekBlob(image,offset,SEEK_SET);\n      if (count != 1)\n        return(MagickFalse);\n      break;\n    }\n    case PipeStream:\n    case ZipStream:\n      return(MagickFalse);\n    case BZipStream:\n      return(MagickFalse);\n    case FifoStream:\n      return(MagickFalse);\n    case BlobStream:\n    {\n      if (extent != (MagickSizeType) ((size_t) extent))\n        return(MagickFalse);\n      if (blob_info->mapped != MagickFalse)\n        {\n          MagickOffsetType\n            offset;\n\n          ssize_t\n            count;\n\n          (void) UnmapBlob(blob_info->data,blob_info->length);\n          RelinquishMagickResource(MapResource,blob_info->length);\n          if (extent != (MagickSizeType) ((off_t) extent))\n            return(MagickFalse);\n          offset=SeekBlob(image,0,SEEK_END);\n          if (offset < 0)\n            return(MagickFalse);\n          if ((MagickSizeType) offset >= extent)\n            break;\n          offset=SeekBlob(image,(MagickOffsetType) extent-1,SEEK_SET);\n          count=(ssize_t) fwrite((const unsigned char *) \"\",1,1,\n            blob_info->file_info.file);\n#if defined(MAGICKCORE_HAVE_POSIX_FALLOCATE)\n          if (blob_info->synchronize != MagickFalse)\n            {\n              int\n                file;\n\n              file=fileno(blob_info->file_info.file);\n              if ((file == -1) || (offset < 0))\n                return(MagickFalse);\n              (void) posix_fallocate(file,offset,extent-offset);\n            }\n#endif\n          offset=SeekBlob(image,offset,SEEK_SET);\n          if (count != 1)\n            return(MagickFalse);\n          (void) AcquireMagickResource(MapResource,extent);\n          blob_info->data=(unsigned char*) MapBlob(fileno(\n            blob_info->file_info.file),WriteMode,0,(size_t) extent);\n          blob_info->extent=(size_t) extent;\n          blob_info->length=(size_t) extent;\n          (void) SyncBlob(image);\n          break;\n        }\n      blob_info->extent=(size_t) extent;\n      blob_info->data=(unsigned char *) ResizeQuantumMemory(blob_info->data,\n        blob_info->extent+1,sizeof(*blob_info->data));\n      (void) SyncBlob(image);\n      if (blob_info->data == (unsigned char *) NULL)\n        {\n          (void) DetachBlob(blob_info);\n          return(MagickFalse);\n        }\n      break;\n    }\n    case CustomStream:\n      break;\n  }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  S e t C u s t o m S t r e a m D a t a                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetCustomStreamData() sets the stream info data member.\n%\n%  The format of the SetCustomStreamData method is:\n%\n%      void SetCustomStreamData(CustomStreamInfo *custom_stream,void *)\n%\n%  A description of each parameter follows:\n%\n%    o custom_stream: the custom stream info.\n%\n%    o data: an object containing information about the custom stream.\n%\n*/\nMagickExport void SetCustomStreamData(CustomStreamInfo *custom_stream,\n  void *data)\n{\n  assert(custom_stream != (CustomStreamInfo *) NULL);\n  assert(custom_stream->signature == MagickCoreSignature);\n  custom_stream->data=data;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  S e t C u s t o m S t r e a m R e a d e r                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetCustomStreamReader() sets the stream info reader member.\n%\n%  The format of the SetCustomStreamReader method is:\n%\n%      void SetCustomStreamReader(CustomStreamInfo *custom_stream,\n%        CustomStreamHandler reader)\n%\n%  A description of each parameter follows:\n%\n%    o custom_stream: the custom stream info.\n%\n%    o reader: a function to read from the stream.\n%\n*/\nMagickExport void SetCustomStreamReader(CustomStreamInfo *custom_stream,\n  CustomStreamHandler reader)\n{\n  assert(custom_stream != (CustomStreamInfo *) NULL);\n  assert(custom_stream->signature == MagickCoreSignature);\n  custom_stream->reader=reader;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  S e t C u s t o m S t r e a m S e e k e r                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetCustomStreamSeeker() sets the stream info seeker member.\n%\n%  The format of the SetCustomStreamReader method is:\n%\n%      void SetCustomStreamSeeker(CustomStreamInfo *custom_stream,\n%        CustomStreamSeeker seeker)\n%\n%  A description of each parameter follows:\n%\n%    o custom_stream: the custom stream info.\n%\n%    o seeker: a function to seek in the custom stream.\n%\n*/\nMagickExport void SetCustomStreamSeeker(CustomStreamInfo *custom_stream,\n  CustomStreamSeeker seeker)\n{\n  assert(custom_stream != (CustomStreamInfo *) NULL);\n  assert(custom_stream->signature == MagickCoreSignature);\n  custom_stream->seeker=seeker;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  S e t C u s t o m S t r e a m T e l l e r                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetCustomStreamTeller() sets the stream info teller member.\n%\n%  The format of the SetCustomStreamTeller method is:\n%\n%      void SetCustomStreamTeller(CustomStreamInfo *custom_stream,\n%        CustomStreamTeller *teller)\n%\n%  A description of each parameter follows:\n%\n%    o custom_stream: the custom stream info.\n%\n%    o teller: a function to set the position in the stream.\n%\n*/\nMagickExport void SetCustomStreamTeller(CustomStreamInfo *custom_stream,\n  CustomStreamTeller teller)\n{\n  assert(custom_stream != (CustomStreamInfo *) NULL);\n  assert(custom_stream->signature == MagickCoreSignature);\n  custom_stream->teller=teller;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  S e t C u s t o m S t r e a m W r i t e r                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetCustomStreamWriter() sets the stream info writer member.\n%\n%  The format of the SetCustomStreamWriter method is:\n%\n%      void SetCustomStreamWriter(CustomStreamInfo *custom_stream,\n%        CustomStreamHandler *writer)\n%\n%  A description of each parameter follows:\n%\n%    o custom_stream: the custom stream info.\n%\n%    o writer: a function to write to the custom stream.\n%\n*/\nMagickExport void SetCustomStreamWriter(CustomStreamInfo *custom_stream,\n  CustomStreamHandler writer)\n{\n  assert(custom_stream != (CustomStreamInfo *) NULL);\n  assert(custom_stream->signature == MagickCoreSignature);\n  custom_stream->writer=writer;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  S y n c B l o b                                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncBlob() flushes the datastream if it is a file or synchronizes the data\n%  attributes if it is an blob.\n%\n%  The format of the SyncBlob method is:\n%\n%      int SyncBlob(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nstatic int SyncBlob(Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  int\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  blob_info=image->blob;\n  status=0;\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    case PipeStream:\n    {\n      status=fflush(blob_info->file_info.file);\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      status=gzflush(blob_info->file_info.gzfile,Z_SYNC_FLUSH);\n#endif\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      status=BZ2_bzflush(blob_info->file_info.bzfile);\n#endif\n      break;\n    }\n    case FifoStream:\n      break;\n    case BlobStream:\n      break;\n    case CustomStream:\n      break;\n  }\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  T e l l B l o b                                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TellBlob() obtains the current value of the blob or file position.\n%\n%  The format of the TellBlob method is:\n%\n%      MagickOffsetType TellBlob(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickOffsetType TellBlob(const Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  MagickOffsetType\n    offset;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  blob_info=image->blob;\n  offset=(-1);\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    {\n      offset=ftell(blob_info->file_info.file);\n      break;\n    }\n    case PipeStream:\n      break;\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      offset=(MagickOffsetType) gztell(blob_info->file_info.gzfile);\n#endif\n      break;\n    }\n    case BZipStream:\n      break;\n    case FifoStream:\n      break;\n    case BlobStream:\n    {\n      offset=blob_info->offset;\n      break;\n    }\n    case CustomStream:\n    {\n      if (blob_info->custom_stream->teller != (CustomStreamTeller) NULL)\n        offset=blob_info->custom_stream->teller(blob_info->custom_stream->data);\n      break;\n    }\n  }\n  return(offset);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  U n m a p B l o b                                                          %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnmapBlob() deallocates the binary large object previously allocated with\n%  the MapBlob method.\n%\n%  The format of the UnmapBlob method is:\n%\n%       MagickBooleanType UnmapBlob(void *map,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o map: the address  of the binary large object.\n%\n%    o length: the length of the binary large object.\n%\n*/\nMagickExport MagickBooleanType UnmapBlob(void *map,const size_t length)\n{\n#if defined(MAGICKCORE_HAVE_MMAP)\n  int\n    status;\n\n  status=munmap(map,length);\n  return(status == -1 ? MagickFalse : MagickTrue);\n#else\n  (void) map;\n  (void) length;\n  return(MagickFalse);\n#endif\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  W r i t e B l o b                                                          %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlob() writes data to a blob or image file.  It returns the number of\n%  bytes written.\n%\n%  The format of the WriteBlob method is:\n%\n%      ssize_t WriteBlob(Image *image,const size_t length,const void *data)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o length:  Specifies an integer representing the number of bytes to\n%      write to the file.\n%\n%    o data:  The address of the data to write to the blob or file.\n%\n*/\nMagickExport ssize_t WriteBlob(Image *image,const size_t length,\n  const void *data)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  int\n    c;\n\n  register const unsigned char\n    *p;\n\n  register unsigned char\n    *q;\n\n  ssize_t\n    count;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  if (length == 0)\n    return(0);\n  assert(data != (const void *) NULL);\n  blob_info=image->blob;\n  count=0;\n  p=(const unsigned char *) data;\n  q=(unsigned char *) data;\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n      break;\n    case StandardStream:\n    case FileStream:\n    case PipeStream:\n    {\n      switch (length)\n      {\n        default:\n        {\n          count=(ssize_t) fwrite((const char *) data,1,length,\n            blob_info->file_info.file);\n          break;\n        }\n        case 4:\n        {\n          c=putc((int) *p++,blob_info->file_info.file);\n          if (c == EOF)\n            break;\n          count++;\n        }\n        case 3:\n        {\n          c=putc((int) *p++,blob_info->file_info.file);\n          if (c == EOF)\n            break;\n          count++;\n        }\n        case 2:\n        {\n          c=putc((int) *p++,blob_info->file_info.file);\n          if (c == EOF)\n            break;\n          count++;\n        }\n        case 1:\n        {\n          c=putc((int) *p++,blob_info->file_info.file);\n          if (c == EOF)\n            break;\n          count++;\n        }\n        case 0:\n          break;\n      }\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      switch (length)\n      {\n        default:\n        {\n          register ssize_t\n            i;\n\n          for (i=0; i < (ssize_t) length; i+=count)\n          {\n            count=(ssize_t) gzwrite(blob_info->file_info.gzfile,q+i,\n              (unsigned int) MagickMin(length-i,MagickMaxBufferExtent));\n            if (count <= 0)\n              {\n                count=0;\n                if (errno != EINTR)\n                  break;\n              }\n          }\n          count=i;\n          break;\n        }\n        case 4:\n        {\n          c=gzputc(blob_info->file_info.gzfile,(int) *p++);\n          if (c == EOF)\n            break;\n          count++;\n        }\n        case 3:\n        {\n          c=gzputc(blob_info->file_info.gzfile,(int) *p++);\n          if (c == EOF)\n            break;\n          count++;\n        }\n        case 2:\n        {\n          c=gzputc(blob_info->file_info.gzfile,(int) *p++);\n          if (c == EOF)\n            break;\n          count++;\n        }\n        case 1:\n        {\n          c=gzputc(blob_info->file_info.gzfile,(int) *p++);\n          if (c == EOF)\n            break;\n          count++;\n        }\n        case 0:\n          break;\n      }\n#endif\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) length; i+=count)\n      {\n        count=(ssize_t) BZ2_bzwrite(blob_info->file_info.bzfile,q+i,\n          (int) MagickMin(length-i,MagickMaxBufferExtent));\n        if (count <= 0)\n          {\n            count=0;\n            if (errno != EINTR)\n              break;\n          }\n      }\n      count=i;\n#endif\n      break;\n    }\n    case FifoStream:\n    {\n      count=(ssize_t) blob_info->stream(image,data,length);\n      break;\n    }\n    case BlobStream:\n    {\n      if ((blob_info->offset+(MagickOffsetType) length) >=\n          (MagickOffsetType) blob_info->extent)\n        {\n          if (blob_info->mapped != MagickFalse)\n            return(0);\n          blob_info->extent+=length+blob_info->quantum;\n          blob_info->quantum<<=1;\n          blob_info->data=(unsigned char *) ResizeQuantumMemory(\n            blob_info->data,blob_info->extent+1,sizeof(*blob_info->data));\n          (void) SyncBlob(image);\n          if (blob_info->data == (unsigned char *) NULL)\n            {\n              (void) DetachBlob(blob_info);\n              return(0);\n            }\n        }\n      q=blob_info->data+blob_info->offset;\n      (void) memcpy(q,p,length);\n      blob_info->offset+=length;\n      if (blob_info->offset >= (MagickOffsetType) blob_info->length)\n        blob_info->length=(size_t) blob_info->offset;\n      count=(ssize_t) length;\n      break;\n    }\n    case CustomStream:\n    {\n      if (blob_info->custom_stream->writer != (CustomStreamHandler) NULL)\n        count=blob_info->custom_stream->writer((unsigned char *) data,\n          length,blob_info->custom_stream->data);\n      break;\n    }\n  }\n  return(count);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  W r i t e B l o b B y t e                                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobByte() write an integer to a blob.  It returns the number of bytes\n%  written (either 0 or 1);\n%\n%  The format of the WriteBlobByte method is:\n%\n%      ssize_t WriteBlobByte(Image *image,const unsigned char value)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o value: Specifies the value to write.\n%\n*/\nMagickExport ssize_t WriteBlobByte(Image *image,const unsigned char value)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  ssize_t\n    count;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  blob_info=image->blob;\n  count=0;\n  switch (blob_info->type)\n  {\n    case StandardStream:\n    case FileStream:\n    case PipeStream:\n    {\n      int\n        c;\n\n      c=putc((int) value,blob_info->file_info.file);\n      if (c == EOF)\n        break;\n      count++;\n      break;\n    }\n    default:\n    {\n      count=WriteBlobStream(image,1,&value);\n      break;\n    }\n  }\n  return(count);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  W r i t e B l o b F l o a t                                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobFloat() writes a float value as a 32-bit quantity in the byte-order\n%  specified by the endian member of the image structure.\n%\n%  The format of the WriteBlobFloat method is:\n%\n%      ssize_t WriteBlobFloat(Image *image,const float value)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o value: Specifies the value to write.\n%\n*/\nMagickExport ssize_t WriteBlobFloat(Image *image,const float value)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    float\n      float_value;\n  } quantum;\n\n  quantum.unsigned_value=0U;\n  quantum.float_value=value;\n  return(WriteBlobLong(image,quantum.unsigned_value));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  W r i t e B l o b L o n g                                                  %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobLong() writes a unsigned int value as a 32-bit quantity in the\n%  byte-order specified by the endian member of the image structure.\n%\n%  The format of the WriteBlobLong method is:\n%\n%      ssize_t WriteBlobLong(Image *image,const unsigned int value)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o value: Specifies the value to write.\n%\n*/\nMagickExport ssize_t WriteBlobLong(Image *image,const unsigned int value)\n{\n  unsigned char\n    buffer[4];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->endian == LSBEndian)\n    {\n      buffer[0]=(unsigned char) value;\n      buffer[1]=(unsigned char) (value >> 8);\n      buffer[2]=(unsigned char) (value >> 16);\n      buffer[3]=(unsigned char) (value >> 24);\n      return(WriteBlobStream(image,4,buffer));\n    }\n  buffer[0]=(unsigned char) (value >> 24);\n  buffer[1]=(unsigned char) (value >> 16);\n  buffer[2]=(unsigned char) (value >> 8);\n  buffer[3]=(unsigned char) value;\n  return(WriteBlobStream(image,4,buffer));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  W r i t e B l o b L o n g L o n g                                          %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobMSBLongLong() writes a long long value as a 64-bit quantity in the\n%  byte-order specified by the endian member of the image structure.\n%\n%  The format of the WriteBlobLongLong method is:\n%\n%      ssize_t WriteBlobLongLong(Image *image,const MagickSizeType value)\n%\n%  A description of each parameter follows.\n%\n%    o value:  Specifies the value to write.\n%\n%    o image: the image.\n%\n*/\nMagickExport ssize_t WriteBlobLongLong(Image *image,const MagickSizeType value)\n{\n  unsigned char\n    buffer[8];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->endian == LSBEndian)\n    {\n      buffer[0]=(unsigned char) value;\n      buffer[1]=(unsigned char) (value >> 8);\n      buffer[2]=(unsigned char) (value >> 16);\n      buffer[3]=(unsigned char) (value >> 24);\n      buffer[4]=(unsigned char) (value >> 32);\n      buffer[5]=(unsigned char) (value >> 40);\n      buffer[6]=(unsigned char) (value >> 48);\n      buffer[7]=(unsigned char) (value >> 56);\n      return(WriteBlobStream(image,8,buffer));\n    }\n  buffer[0]=(unsigned char) (value >> 56);\n  buffer[1]=(unsigned char) (value >> 48);\n  buffer[2]=(unsigned char) (value >> 40);\n  buffer[3]=(unsigned char) (value >> 32);\n  buffer[4]=(unsigned char) (value >> 24);\n  buffer[5]=(unsigned char) (value >> 16);\n  buffer[6]=(unsigned char) (value >> 8);\n  buffer[7]=(unsigned char) value;\n  return(WriteBlobStream(image,8,buffer));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   W r i t e B l o b S h o r t                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobShort() writes a short value as a 16-bit quantity in the\n%  byte-order specified by the endian member of the image structure.\n%\n%  The format of the WriteBlobShort method is:\n%\n%      ssize_t WriteBlobShort(Image *image,const unsigned short value)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o value:  Specifies the value to write.\n%\n*/\nMagickExport ssize_t WriteBlobShort(Image *image,const unsigned short value)\n{\n  unsigned char\n    buffer[2];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->endian == LSBEndian)\n    {\n      buffer[0]=(unsigned char) value;\n      buffer[1]=(unsigned char) (value >> 8);\n      return(WriteBlobStream(image,2,buffer));\n    }\n  buffer[0]=(unsigned char) (value >> 8);\n  buffer[1]=(unsigned char) value;\n  return(WriteBlobStream(image,2,buffer));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  W r i t e B l o b S i g n e d L o n g                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobSignedLong() writes a signed value as a 32-bit quantity in the\n%  byte-order specified by the endian member of the image structure.\n%\n%  The format of the WriteBlobSignedLong method is:\n%\n%      ssize_t WriteBlobSignedLong(Image *image,const signed int value)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o value: Specifies the value to write.\n%\n*/\nMagickExport ssize_t WriteBlobSignedLong(Image *image,const signed int value)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  unsigned char\n    buffer[4];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  quantum.signed_value=value;\n  if (image->endian == LSBEndian)\n    {\n      buffer[0]=(unsigned char) quantum.unsigned_value;\n      buffer[1]=(unsigned char) (quantum.unsigned_value >> 8);\n      buffer[2]=(unsigned char) (quantum.unsigned_value >> 16);\n      buffer[3]=(unsigned char) (quantum.unsigned_value >> 24);\n      return(WriteBlobStream(image,4,buffer));\n    }\n  buffer[0]=(unsigned char) (quantum.unsigned_value >> 24);\n  buffer[1]=(unsigned char) (quantum.unsigned_value >> 16);\n  buffer[2]=(unsigned char) (quantum.unsigned_value >> 8);\n  buffer[3]=(unsigned char) quantum.unsigned_value;\n  return(WriteBlobStream(image,4,buffer));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  W r i t e B l o b L S B L o n g                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobLSBLong() writes a unsigned int value as a 32-bit quantity in\n%  least-significant byte first order.\n%\n%  The format of the WriteBlobLSBLong method is:\n%\n%      ssize_t WriteBlobLSBLong(Image *image,const unsigned int value)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o value: Specifies the value to write.\n%\n*/\nMagickExport ssize_t WriteBlobLSBLong(Image *image,const unsigned int value)\n{\n  unsigned char\n    buffer[4];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  buffer[0]=(unsigned char) value;\n  buffer[1]=(unsigned char) (value >> 8);\n  buffer[2]=(unsigned char) (value >> 16);\n  buffer[3]=(unsigned char) (value >> 24);\n  return(WriteBlobStream(image,4,buffer));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   W r i t e B l o b L S B S h o r t                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobLSBShort() writes a unsigned short value as a 16-bit quantity in\n%  least-significant byte first order.\n%\n%  The format of the WriteBlobLSBShort method is:\n%\n%      ssize_t WriteBlobLSBShort(Image *image,const unsigned short value)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o value:  Specifies the value to write.\n%\n*/\nMagickExport ssize_t WriteBlobLSBShort(Image *image,const unsigned short value)\n{\n  unsigned char\n    buffer[2];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  buffer[0]=(unsigned char) value;\n  buffer[1]=(unsigned char) (value >> 8);\n  return(WriteBlobStream(image,2,buffer));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  W r i t e B l o b L S B S i g n e d L o n g                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobLSBSignedLong() writes a signed value as a 32-bit quantity in\n%  least-significant byte first order.\n%\n%  The format of the WriteBlobLSBSignedLong method is:\n%\n%      ssize_t WriteBlobLSBSignedLong(Image *image,const signed int value)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o value: Specifies the value to write.\n%\n*/\nMagickExport ssize_t WriteBlobLSBSignedLong(Image *image,const signed int value)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  unsigned char\n    buffer[4];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  quantum.signed_value=value;\n  buffer[0]=(unsigned char) quantum.unsigned_value;\n  buffer[1]=(unsigned char) (quantum.unsigned_value >> 8);\n  buffer[2]=(unsigned char) (quantum.unsigned_value >> 16);\n  buffer[3]=(unsigned char) (quantum.unsigned_value >> 24);\n  return(WriteBlobStream(image,4,buffer));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   W r i t e B l o b L S B S i g n e d S h o r t                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobLSBSignedShort() writes a signed short value as a 16-bit quantity\n%  in least-significant byte first order.\n%\n%  The format of the WriteBlobLSBSignedShort method is:\n%\n%      ssize_t WriteBlobLSBSignedShort(Image *image,const signed short value)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o value:  Specifies the value to write.\n%\n*/\nMagickExport ssize_t WriteBlobLSBSignedShort(Image *image,\n  const signed short value)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  unsigned char\n    buffer[2];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  quantum.signed_value=value;\n  buffer[0]=(unsigned char) quantum.unsigned_value;\n  buffer[1]=(unsigned char) (quantum.unsigned_value >> 8);\n  return(WriteBlobStream(image,2,buffer));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  W r i t e B l o b M S B L o n g                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobMSBLong() writes a unsigned int value as a 32-bit quantity in\n%  most-significant byte first order.\n%\n%  The format of the WriteBlobMSBLong method is:\n%\n%      ssize_t WriteBlobMSBLong(Image *image,const unsigned int value)\n%\n%  A description of each parameter follows.\n%\n%    o value:  Specifies the value to write.\n%\n%    o image: the image.\n%\n*/\nMagickExport ssize_t WriteBlobMSBLong(Image *image,const unsigned int value)\n{\n  unsigned char\n    buffer[4];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  buffer[0]=(unsigned char) (value >> 24);\n  buffer[1]=(unsigned char) (value >> 16);\n  buffer[2]=(unsigned char) (value >> 8);\n  buffer[3]=(unsigned char) value;\n  return(WriteBlobStream(image,4,buffer));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   W r i t e B l o b M S B S i g n e d S h o r t                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobMSBSignedShort() writes a signed short value as a 16-bit quantity\n%  in most-significant byte first order.\n%\n%  The format of the WriteBlobMSBSignedShort method is:\n%\n%      ssize_t WriteBlobMSBSignedShort(Image *image,const signed short value)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o value:  Specifies the value to write.\n%\n*/\nMagickExport ssize_t WriteBlobMSBSignedShort(Image *image,\n  const signed short value)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  unsigned char\n    buffer[2];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  quantum.signed_value=value;\n  buffer[0]=(unsigned char) (quantum.unsigned_value >> 8);\n  buffer[1]=(unsigned char) quantum.unsigned_value;\n  return(WriteBlobStream(image,2,buffer));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  W r i t e B l o b M S B S h o r t                                          %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobMSBShort() writes a unsigned short value as a 16-bit quantity in\n%  most-significant byte first order.\n%\n%  The format of the WriteBlobMSBShort method is:\n%\n%      ssize_t WriteBlobMSBShort(Image *image,const unsigned short value)\n%\n%  A description of each parameter follows.\n%\n%   o  value:  Specifies the value to write.\n%\n%   o  file:  Specifies the file to write the data to.\n%\n*/\nMagickExport ssize_t WriteBlobMSBShort(Image *image,const unsigned short value)\n{\n  unsigned char\n    buffer[2];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  buffer[0]=(unsigned char) (value >> 8);\n  buffer[1]=(unsigned char) value;\n  return(WriteBlobStream(image,2,buffer));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  W r i t e B l o b S t r i n g                                              %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBlobString() write a string to a blob.  It returns the number of\n%  characters written.\n%\n%  The format of the WriteBlobString method is:\n%\n%      ssize_t WriteBlobString(Image *image,const char *string)\n%\n%  A description of each parameter follows.\n%\n%    o image: the image.\n%\n%    o string: Specifies the string to write.\n%\n*/\nMagickExport ssize_t WriteBlobString(Image *image,const char *string)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(string != (const char *) NULL);\n  return(WriteBlobStream(image,strlen(string),(const unsigned char *) string));\n}\n"], "filenames": ["MagickCore/blob.c"], "buggy_code_start_loc": [1013], "buggy_code_end_loc": [1013], "fixing_code_start_loc": [1014], "fixing_code_end_loc": [1015], "type": "CWE-416", "message": "In ImageMagick 7.x before 7.0.8-42 and 6.x before 6.9.10-42, there is a use after free vulnerability in the UnmapBlob function that allows an attacker to cause a denial of service by sending a crafted file.", "other": {"cve": {"id": "CVE-2019-14980", "sourceIdentifier": "cve@mitre.org", "published": "2019-08-12T23:15:11.493", "lastModified": "2023-03-02T18:00:56.910", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In ImageMagick 7.x before 7.0.8-42 and 6.x before 6.9.10-42, there is a use after free vulnerability in the UnmapBlob function that allows an attacker to cause a denial of service by sending a crafted file."}, {"lang": "es", "value": "En ImageMagick versiones 7.x anteriores a 7.0.8-42 y versiones 6.x anteriores a 6.9.10-42, hay  una vulnerabilidad de uso de la memoria previamente liberada en la funci\u00f3n UnmapBlob que permite a un atacante causar una denegaci\u00f3n de servicio mediante el env\u00edo de un archivo especialmente dise\u00f1ado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0", "versionEndExcluding": "6.9.10-42", "matchCriteriaId": "20ADD76D-50E8-4DCE-8572-28070BFE3835"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0-0", "versionEndExcluding": "7.0.8-42", "matchCriteriaId": "5F512348-96B1-4F5F-94A2-3112BD1FEA9A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-11/msg00040.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-11/msg00042.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/c5d012a46ae22be9444326aa37969a3f75daa3ba", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/ImageMagick/ImageMagick/compare/7.0.8-41...7.0.8-42", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/ImageMagick/ImageMagick6/commit/614a257295bdcdeda347086761062ac7658b6830", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/ImageMagick/ImageMagick6/issues/43", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/c5d012a46ae22be9444326aa37969a3f75daa3ba"}}